<?xml version='1.0' encoding='utf-8'?>
<!-- Chapters are enclosed with <chapter> tags. Use xml:id to -->
<!-- uniquely identify the chapter.  The @xmlns:xi attribute  -->
<!-- is needed if you use xi:include in this file             -->
<chapter xml:id="ch_markup" xmlns:xi="http://www.w3.org/2001/XInclude">

    <title>Markup</title>
    <section xml:id="section-markup-exercise">
        <title>Overview of Exercise Markup</title>
        <p>
            As much as possible, the markup should follow PreTeXt standards.
            One goal is that any user-facing content on a web-page should match the style of other elements generated by PreTeXt.
            Problems transcoded to WeBWorK should match how similar problems defined in PreTeXt using <tag>pg</tag> elements are created.
            Consequently, tags supported for standard exercises should be supported natively as much as possible in dynamic exercises.
        </p>
        <remark>
        <p>
            This is very much a draft proposal for markup.
            Ideas for improvement and implementation warnings are welcome.
        </p>
        </remark>
        <p>
            We will use an <tag>exercise</tag> element with an attribute <c>@exercise-interactive='fillin-dynamic'</c> to indicate that the exercise involves a Runestone fillin exercise using dynamic processing.    
        </p>
        <p>
            The overall structure of an exercise is proposed to have the following structure.
            There are two XML blocks that are specific to a dynamic exercise, <c>setup</c> and <c>evaluation</c>.
            The other blocks are intended to match PreTeXt standard usage.
            An <c>answer</c> block perhaps does not make sense.
            The other standard elements will be formatted as usual, with some additional tags to
            specify where items such as values and expressions are inserted.
        </p>
        <listing>
        <pre><![CDATA[ 
            <exercise xml:id='my-id' exercise-interactive='fillin-dynamic'>
            <title/>
            <setup>
                <de-environment>   <!-- Specify the dynamic problem randomization elements  -->
                ...              <!-- and other environment settings like error tolerance -->
                </de-environment>  <!-- This piece is not yet specified.                    -->
                <de-object/>       <!-- One or more dynamically created objects             -->
                <de-object/>       <!-- These are translated into script commands           -->
                ...
            </setup>
            <statement> <!-- Usual PreTeXt with elements to include dynamic expressions -->
                ...
            </statement>
            <solution> <!-- Usual PreTeXt with elements to include dynamic expressions  -->
                ...      <!-- As far as I can tell this is not supported by Runestone yet -->
            </solution>
            <evaluation> <!-- Specify the dynamic problem evaluation and feedback -->
                ...
            </evaluation>
        </exercise>
            ]]>
        </pre>
        <caption>Overall XML structure of a dynamic exercise.</caption>
        </listing>
    </section>
    <section xml:id="section-markup-setup">
        <title>Setup and Randomization</title>
        <p>
            The <c>setup</c> block defines all of the dynamically generated mathematical objects.
            It also specifies particular constraints on any variables in the system as well as other environmental settings, such as required tolerance for values to match.
            The tag has an attribute <c>seed</c> which is used to provide a default seed for the initial state of the problem that will be used to create the static version. (Question: Should we use the same style seed that would be used for WeBWorK since this can create WeBWorK questions as well?)
        </p>
        <p>
            The block consists of a single <tag>de-environment</tag> element (not yet specified). 
            This will include a specification of variables that will be used in the problem, the standard domain of evaluation for those variables (where formulas are evaluated), and how values will be compared for approximate equality (relative vs absolute error and tolerance values).
        </p>
        <p>
            The environment will be followed by a sequence of <tag>de-object</tag> elements that create dynamic content objects that will be used to describe the problem fully, including when answers are evaluated.
            Instruction elements can define expressions represent numbers or formulas by including <c>@context</c> attributes of <c>@context='number'</c> and <c>@context='formula'</c>, respectively.
            This should allow flexibility for additional contexts to be implemented in the future, such as text, lists, sets, points, vectors, or matrices.
            Additional attributes will be specific to the <c>@context</c>.
        </p>
        <p>
            Each object must have a <c>@name</c> attribute which will be used as a variable name in the corresponding scripts used in implementation.
            Object names should must with a letter and can contain letters A-Za-z, digits 0-9, and the underscore.
            Additionally, objects can be defined in terms of previously defined objects, referencing them by name, and the order in which the elements are included is critical.
            An object can not be referenced prior to its creation.
        </p>
        <p>
            Numerical quantities (constants) are objects with <c>@context="number"</c>.
            The <c>@mode</c> attribute specifies how the number is defined.
            They can be defined as a specific value (<c>@mode="value"</c>), as a random value (<c>@mode="random"</c>), calculated in terms of previously defined numbers (<c>@mode="formula"</c>) using mustache substitution, or evaluating a formula object at specific variable instances (<c>@mode="evaluate"</c>).
            Expression terms can be computed in terms of previously defined parameters or expressions using the defined variables.
        </p>
        <p>
            Algebraic expressions involving variables are objects with <c>@context="formula"</c>.
            The <c>@mode</c> attribute specifies how the formula is defined.
            The most common approach is by providing a formula in terms of previous objects (<c>@mode="formula"</c>) using mustache substitution.
            Additionally, a formula can be defined by substitution of a variable with another expression (<c>@mode="substitution"</c>), by differentiating with respect to a variable (<c>@mode="derivative"</c>), or by evaluating variables at specific values (<c>@mode="evaluate"</c>).
        </p>
        <paragraphs xml:id="mustache-substitution">
        <title>Mustache Substitution vs VAR elements</title>
        <p>
            Implementations of dynamic exercises will reference the object names in different ways.
            For example, WeBWorK and WebAssign both use Perl syntax and so the names will be transcoded with a dollar sign $ before the name.
            Other implementations will just use the names directly.
            To retain a simple substitution schema when <em>defining</em> a value or an expression, we adopt <term>mustache substitution</term>.
            This means that the name of the parameter or expression needs to be surrounded by double curly braces.
            Variables themselves are not enclosed by braces.
            For example, if we had previously defined a parameter <c>c</c> and wanted to introduce an expression <m>cx+3</m>,
            the mustache-substitution expression would be written <c>{{c}}*x+3</c>.
        </p>
        <p>
            In all contexts other than providing a formula that will be parsed, we will refer to objects either for display in PreTeXt content or to refer to expressions as objects for evaluation (as in when checking answers), using an XML <c>#var</c> element with <c>@name="expression-name"</c> to match.
        </p>
        </paragraphs>
        <p>
            Examples of typical statements are included below with an explanation of the options.
        </p>
        <p>
            <ul>
                <li>
<pre>&lt;de-object name="a" context="number" mode="value"&gt;12&lt;/de-object&gt;</pre>
                <p>
                    This would create a mathematical object representing the number 12 assigned to the name <c>a</c>.
                </p>
                </li>
                <li>
<pre>&lt;de-object name="cSq" context="number" mode="formula"&gt;{{a}}^2+{{b}}^2&lt;/de-object&gt;</pre>
<p>
                        This would create a mathematical object calculated in terms of previously created numbers <c>a</c> and <c>b</c> according to the formula <m>a^2+b^2</m> and saved with the name of <c>cSq</c>.
                    </p>
                </li>
                <li>
<pre>&lt;de-object name="fVal" context="number" mode="evaluate"&gt;
    &lt;formula&gt;&lt;var name="fFunc"&gt;&lt;/formula&gt;
    &lt;variable name="x"&gt;&lt;var name="x0"&gt;&lt;/variable&gt;
&lt;/de-object&gt;
                    </pre>
                    <p>
                        This would create a numerical mathematical object <c>fVal</c> by evaluating a formula previously created and named <c>fFunc</c> using a value for the variable <m>x</m> using the value previously stored in another numerical object <c>x0</c>.
                    </p>
                </li>
                <li>
<pre>&lt;de-object name="fVal" context="number" mode="random"&gt;
    &lt;options distribution="discrete" min="-5" max="5" by="1" nonzero="yes" /&gt;
&lt;/de-object&gt;
                    </pre>
                    <p>
                        At present, only one random distribution is implemented.
                        The options for the random distribution will all be given in the <tag>options</tag> as attributes.
                        For the <c>distribution="discrete"</c> distribution, there are default values of <c>@by="1"</c> and <c>@nonzero="no"</c>.
                        The distribution considers the values starting at <c>@min</c>, counting by <c>@by</c>, until we reach <c>@max</c>. Each value has the same probability.
                    </p>
                    <p>
                        Using attributes instead of XML is simpler to type.
                        However, if we want to implement distributions where the properties themselves are dynamically determined (for example, change the min/max values or the by value), then this probably should be done use tags. Can we allow both? I wonder if the following would be reasonable and possible:
                    </p>
<pre>&lt;de-object name="fVal" context="number" mode="random"&gt;
    &lt;options distribution="discrete" by="1" nonzero="yes"&gt;
        &lt;min&gt;&lt;var name="myMin"/&gt;&lt;/min&gt;
        &lt;max&gt;&lt;var name="myMin"/&gt;&lt;/max&gt;
    &lt;/options&gt;
&lt;/de-object&gt;
</pre>
                </li>
                <li>
                    <pre>&lt;de-object name="quadratic" context="formula" mode="formula"&gt;{{a}}x^2+{{b}}x+{{{c}}&lt;/de-object&gt;</pre>
                    <p>
                        Define the formula <m>ax^2+bx+c</m>, replacing the values of <m>a,b,c</m> with the values previously assigned as their own objects.
                    </p>
                </li>
                <li>
<pre>&lt;de-object name="quadComp" context="formula" mode="substitution"&gt;
    &lt;formula&gt;&lt;var name="quadratic" /&gt;&lt;/formula&gt;
    &lt;variable name="x"&gt;
        &lt;de-object context="formula" mode="formula"&gt;{{m}}x+{{b2}}&lt;/de-object&gt;
    &lt;/variable&gt;
&lt;/de-object&gt;</pre>
                    <p>
                        It is technically possible to define a new object anywhere that we would otherwise use the <tag>var</tag> tag to refer to a previously-defined value. 
                        This is not recommended because the value of the intermediate result is never saved.
                        However, in this example, we would start with the quadratic formula defined in the previous example <m>ax^2+bx+c</m> and create a new expression replacing <m>x</m> with the formula <m>mx+b_2</m>. In other words, this is how we implement composition of functions.
                    </p>
                    <p>
                        Alternatively, we could accomplish the same thing (recommended) by defining the intermediate object:
                    </p>
<pre>&lt;de-object name="myLine" context="formula" mode="formula"&gt;{{m}}x+{{b2}}&lt;/de-object&gt;
&lt;de-object name="quadComp" context="formula" mode="substitution"&gt;
    &lt;formula&gt;&lt;var name="quadratic" /&gt;&lt;/formula&gt;
    &lt;variable name="x"&gt;&lt;var name="myLine"/&gt;&lt;/variable&gt;
&lt;/de-object&gt;</pre>
                </li>
                <li>
<pre>&lt;de-object name="quadDeriv" context="formula" mode="derivative"&gt;
    &lt;formula&gt;&lt;var name="quadratic" /&gt;&lt;/formula&gt;
    &lt;variable name="x" /&gt;
&lt;/de-object&gt;</pre>
                    <p>
                        Calculate the derivative of <c>quadratic</c> with respect to <m>x</m>.
                        This relies on the implementation environments being able to do differentiation. Both WeBWorK and BTMExpressions.js support this intrinsically.
                    </p>
                </li>
                <li>
<pre>&lt;de-object name="quadDeriv" context="formula" mode="evaluate"&gt;
    &lt;formula&gt;&lt;var name="myFormula" /&gt;&lt;/formula&gt;
    &lt;variable name="x"&gt;&lt;var name="myValue" /&gt;&lt;/variable&gt;
&lt;/de-object&gt;</pre>
                    <p>
                        This is similar to substitution, except that the variable <m>x</m> in the expression defined as <c>myFormula</c> is evaluated at a numerical value defined by <c>myValue</c>.
                    </p>
                </li>
            </ul>
        </p>
    </section>
    <section xml:id="section-markup-evaluation">
        <title>Evaluation and Feedback</title>
        <p>
            In the content of the exercise, specifically in the <c>statement</c> element and its content, 
            the author should insert <c>fillin</c> elements for where answers will be entered for evaluation.
            Each <c>#fillin</c> should have a <c>@submit</c> attribute that will give a name used for matching evaluation rules to the specific student response.
            That is, a mathematical object with a name based on <c>@submit</c> will be parsed from the student response and be available at the time the answer checker evaluates the work.
            It should also have a <c>@correct</c> attribute that gives the name of a <c>#de-object</c> element that represents a possible correct answer.
            WeBWorK uses this value when showing correct answers. (I don't know if Runestone provides a way to show correct answers.)
            Other attributes that are used for defining WeBWorK problems in PreTeXt are also intended to be available.
            This includes an optional attribute <c>@width</c> that specifies how large the answer blank should be.
        </p>
        <p>
            The <c>evaluation</c> block of XML provides the necessary information for how to determine whether student answers are correct.
            It also is responsible for describing any special feedback that is provided to the student, 
            such as answer hints specific to the submitted student response.
        </p>
        <p>
            The <c>evaluation</c> block contains <c>evaluate</c> elements that includes a <c>@submit</c> attribute that must match the <c>@submit</c> attribute of a <c>#fillin</c> inside the statement. 
            Each <c>#evaluate</c> will include <c>#test</c> elements that perform tests and provide feedback when the test evaluates to <c>true</c>.
            Each test will contain one or more boolean operator elements and a feedback response. When more than one operator appears, ALL of the operators must return <c>true</c> (performing an implicit AND operation).
            An attribute on an <c>#evaluate</c> of <c>@correct="yes"</c> is used to specify how to check for correctness. If no evaluation has this set, then the <c>@correct</c> variable defined with the fillin will be used to test for correctness.
            I am working on having the ability to use a single test to determine correctness of all blanks.
            Some systems (WeBWorK) use different techniques depending on whether student answers for other blanks are used in evaluation of correctness. Consequently, if answer evaluators involve student answers other than the answer being tested, the <c>#evalation</c> should have <c>@answers-coupled="yes"</c>. (Maybe it is possible to check for this automatically.)
        </p>
        <p>
            The overall evaluation block should have the following structure:
        </p>
        <listing xml:id="listing-evaluation-block-single">
        <pre>
&lt;evaluation&gt;
    &lt;evaluate submit="answerBlank1"&gt;  &lt;!-- Block to provide feedback for matching fillin --&gt;
        ...
    &lt;/evaluate&gt;
    &lt;evaluate submit="answerBlank2"&gt;  &lt;!-- Block to provide feedback for matching fillin --&gt;
        ...
    &lt;/evaluate&gt;
&lt;/evaluation&gt;
        </pre>
        <caption>XML structure of the evaluation block for independent answer blanks.</caption>
        </listing>
        <p>
            I am thinking about the following structure for a single checker for all fillins.
            The model I am exploring is to have an additional <c>#evaluate</c> with <c>@all="yes"</c> instead of <c>@submit</c> to define a test that will be used for all of the answers,
            illustrated in the following example. There should not be any <c>@correct</c> attributes on the tests for the individual blanks.
        </p>
        <listing xml:id="listing-evaluation-block-mixed">
        <pre>
&lt;evaluation answers-coupled="yes"&gt;
&lt;evaluate all="yes"&gt;  &lt;!-- Block to evaluate entire exercise at once --&gt;
    ...
&lt;evaluate&gt;
&lt;evaluate submit="answerBlank1"&gt;  &lt;!-- Block to provide limited feedback for matching fillin --&gt;
    ...
&lt;/evaluate&gt;
&lt;evaluate submit="answerBlank2"&gt;  &lt;!-- Block to provide limited feedback for matching fillin --&gt;
    ...
&lt;/evaluate&gt;
&lt;/evaluation&gt;
        </pre>
        <caption>XML structure of the evaluation block for fully-coordinated answer blanks.</caption>
        </listing>
        <p>
            Each <c>test</c> element consists of the logical test and a <c>feedback</c> element giving the text response when the logical test results in a true value.
            The logical test can consist of a formula object specified by either <c>var</c> or <c>de-term</c> elements, in which case truth is determined by testing if the student answer defined by <c>@submit</c> matches the given formula object.
            The logical test can also compare any two formula elements using an <c>#equal</c> logical test element, where one or both of the formula elements were constructed using the student responses.
            Or the logical test can be a composite logical tests using Boolean operators <c>#and</c>, <c>#or</c>, or <c>#not</c>, with child elements containing additional logical tests.
            As mentioned previously, the root test is presumed to be like <c>#and</c> when there are multiple logical tests as children of the <c>test</c> element.
            Default feedback statements for correct and incorrect answers will be part of the configurable settings.
        </p>
        <p>A simple example of an <c>#evaluate</c> block is presented:</p>
        <listing xml:id="listing-evaluate-block-simple-test">
        <pre>
&lt;evaluate submit="answerBlank1"&gt;
    &lt;test correct="yes"&gt;
        &lt;var name="expression1"/&gt;
    &lt;/test&gt;
    &lt;test&gt;
        &lt;var name="expression2"/&gt;
        &lt;feedback&gt;custom response&lt;/feedback&gt;
    &lt;/test&gt;
    &lt;feedback&gt;default incorrect feedback&lt;/feedback&gt;
&lt;/evaluate&gt;
        </pre>
        <caption>XML structure of the evaluate block marking correct if <c>answerBlank1</c> and <c>expression1</c> match and giving <q>custom response</q> as feedback if it matches <c>expression2</c>.</caption>
        </listing>
        <p>A more complex example of an <c>#evaluate</c> block is presented, illustrating one way to test two answer blanks where the order of values entered does not matter. One of two and statements must be true to be correct, so there is an <c>#or</c> test at the base level with two <c>#and</c> tests inside each of the options:</p>
        <listing xml:id="listing-evaluate-block-coupled-test">
        <pre>
&lt;evaluate&gt;
    &lt;test correct="yes"&gt;
        &lt;or&gt;
            &lt;and&gt;
                &lt;equal&gt;
                    &lt;var name="expression1" /&gt;
                    &lt;var name="answerBlank1" /&gt;
                &lt;/equal&gt;
                &lt;equal&gt;
                    &lt;var name="expression2" /&gt;
                    &lt;var name="answerBlank2" /&gt;
                &lt;/equal&gt;
            &lt;/and&gt;
            &lt;and&gt;
                &lt;equal&gt;
                    &lt;var name="expression1" /&gt;
                    &lt;var name="answerBlank2" /&gt;
                &lt;/equal&gt;
                &lt;equal&gt;
                    &lt;var name="expression2" /&gt;
                    &lt;var name="answerBlank1" /&gt;
                &lt;/equal&gt;
            &lt;/and&gt;
        &lt;/or&gt;
        &lt;feedback&gt;Outstanding!&lt;/feedback&gt;
    &lt;/test&gt;
&lt;/evaluate&gt;
        </pre>
        <caption>XML structure of an evaluate block based on comparing two blanks with two answers.</caption>
        </listing>
    </section>
</chapter>
