(self["webpackChunkWebComponents"] = self["webpackChunkWebComponents"] || []).push([["node_modules_moment_locale_sync_recursive_-runestone_activecode_js_acfactory_js-node_modules_-ef73b3"],{

/***/ 27375:
/*!*************************************************!*\
  !*** ./runestone/activecode/css/activecode.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 42786,
	"./af.js": 42786,
	"./ar": 30867,
	"./ar-dz": 14130,
	"./ar-dz.js": 14130,
	"./ar-kw": 96135,
	"./ar-kw.js": 96135,
	"./ar-ly": 56440,
	"./ar-ly.js": 56440,
	"./ar-ma": 47702,
	"./ar-ma.js": 47702,
	"./ar-sa": 16040,
	"./ar-sa.js": 16040,
	"./ar-tn": 37100,
	"./ar-tn.js": 37100,
	"./ar.js": 30867,
	"./az": 31083,
	"./az.js": 31083,
	"./be": 9808,
	"./be.js": 9808,
	"./bg": 68338,
	"./bg.js": 68338,
	"./bm": 67438,
	"./bm.js": 67438,
	"./bn": 8905,
	"./bn.js": 8905,
	"./bo": 11560,
	"./bo.js": 11560,
	"./br": 1278,
	"./br.js": 1278,
	"./bs": 80622,
	"./bs.js": 80622,
	"./ca": 2468,
	"./ca.js": 2468,
	"./cs": 5822,
	"./cs.js": 5822,
	"./cv": 50877,
	"./cv.js": 50877,
	"./cy": 47373,
	"./cy.js": 47373,
	"./da": 24780,
	"./da.js": 24780,
	"./de": 59740,
	"./de-at": 60217,
	"./de-at.js": 60217,
	"./de-ch": 60894,
	"./de-ch.js": 60894,
	"./de.js": 59740,
	"./dv": 5300,
	"./dv.js": 5300,
	"./el": 50837,
	"./el.js": 50837,
	"./en-au": 78348,
	"./en-au.js": 78348,
	"./en-ca": 77925,
	"./en-ca.js": 77925,
	"./en-gb": 22243,
	"./en-gb.js": 22243,
	"./en-ie": 46436,
	"./en-ie.js": 46436,
	"./en-nz": 76319,
	"./en-nz.js": 76319,
	"./eo": 92915,
	"./eo.js": 92915,
	"./es": 55655,
	"./es-do": 55251,
	"./es-do.js": 55251,
	"./es-us": 71146,
	"./es-us.js": 71146,
	"./es.js": 55655,
	"./et": 5603,
	"./et.js": 5603,
	"./eu": 77763,
	"./eu.js": 77763,
	"./fa": 76959,
	"./fa.js": 76959,
	"./fi": 11897,
	"./fi.js": 11897,
	"./fo": 94694,
	"./fo.js": 94694,
	"./fr": 94470,
	"./fr-ca": 63049,
	"./fr-ca.js": 63049,
	"./fr-ch": 52330,
	"./fr-ch.js": 52330,
	"./fr.js": 94470,
	"./fy": 5044,
	"./fy.js": 5044,
	"./gd": 2101,
	"./gd.js": 2101,
	"./gl": 38794,
	"./gl.js": 38794,
	"./gom-latn": 23168,
	"./gom-latn.js": 23168,
	"./gu": 95349,
	"./gu.js": 95349,
	"./he": 24206,
	"./he.js": 24206,
	"./hi": 30094,
	"./hi.js": 30094,
	"./hr": 30316,
	"./hr.js": 30316,
	"./hu": 22138,
	"./hu.js": 22138,
	"./hy-am": 11423,
	"./hy-am.js": 11423,
	"./id": 29218,
	"./id.js": 29218,
	"./is": 90135,
	"./is.js": 90135,
	"./it": 90626,
	"./it.js": 90626,
	"./ja": 39183,
	"./ja.js": 39183,
	"./jv": 24286,
	"./jv.js": 24286,
	"./ka": 40415,
	"./ka.js": 40415,
	"./kk": 47772,
	"./kk.js": 47772,
	"./km": 18758,
	"./km.js": 18758,
	"./kn": 79282,
	"./kn.js": 79282,
	"./ko": 33730,
	"./ko.js": 33730,
	"./ky": 33291,
	"./ky.js": 33291,
	"./lb": 36841,
	"./lb.js": 36841,
	"./lo": 55466,
	"./lo.js": 55466,
	"./lt": 57010,
	"./lt.js": 57010,
	"./lv": 37595,
	"./lv.js": 37595,
	"./me": 39861,
	"./me.js": 39861,
	"./mi": 35493,
	"./mi.js": 35493,
	"./mk": 95966,
	"./mk.js": 95966,
	"./ml": 87341,
	"./ml.js": 87341,
	"./mr": 10370,
	"./mr.js": 10370,
	"./ms": 9847,
	"./ms-my": 41237,
	"./ms-my.js": 41237,
	"./ms.js": 9847,
	"./mt": 72126,
	"./mt.js": 72126,
	"./my": 56165,
	"./my.js": 56165,
	"./nb": 64924,
	"./nb.js": 64924,
	"./ne": 16744,
	"./ne.js": 16744,
	"./nl": 93901,
	"./nl-be": 59814,
	"./nl-be.js": 59814,
	"./nl.js": 93901,
	"./nn": 83877,
	"./nn.js": 83877,
	"./pa-in": 15858,
	"./pa-in.js": 15858,
	"./pl": 64495,
	"./pl.js": 64495,
	"./pt": 89520,
	"./pt-br": 57971,
	"./pt-br.js": 57971,
	"./pt.js": 89520,
	"./ro": 96459,
	"./ro.js": 96459,
	"./ru": 21793,
	"./ru.js": 21793,
	"./sd": 40950,
	"./sd.js": 40950,
	"./se": 10490,
	"./se.js": 10490,
	"./si": 90124,
	"./si.js": 90124,
	"./sk": 64249,
	"./sk.js": 64249,
	"./sl": 14985,
	"./sl.js": 14985,
	"./sq": 51104,
	"./sq.js": 51104,
	"./sr": 49131,
	"./sr-cyrl": 13709,
	"./sr-cyrl.js": 13709,
	"./sr.js": 49131,
	"./ss": 85893,
	"./ss.js": 85893,
	"./sv": 98760,
	"./sv.js": 98760,
	"./sw": 91172,
	"./sw.js": 91172,
	"./ta": 27333,
	"./ta.js": 27333,
	"./te": 23110,
	"./te.js": 23110,
	"./tet": 52095,
	"./tet.js": 52095,
	"./th": 9041,
	"./th.js": 9041,
	"./tl-ph": 75768,
	"./tl-ph.js": 75768,
	"./tlh": 89444,
	"./tlh.js": 89444,
	"./tr": 72397,
	"./tr.js": 72397,
	"./tzl": 28254,
	"./tzl.js": 28254,
	"./tzm": 51106,
	"./tzm-latn": 30699,
	"./tzm-latn.js": 30699,
	"./tzm.js": 51106,
	"./uk": 67691,
	"./uk.js": 67691,
	"./ur": 13795,
	"./ur.js": 13795,
	"./uz": 6791,
	"./uz-latn": 60588,
	"./uz-latn.js": 60588,
	"./uz.js": 6791,
	"./vi": 65666,
	"./vi.js": 65666,
	"./x-pseudo": 14378,
	"./x-pseudo.js": 14378,
	"./yo": 75805,
	"./yo.js": 75805,
	"./zh-cn": 83839,
	"./zh-cn.js": 83839,
	"./zh-hk": 55726,
	"./zh-hk.js": 55726,
	"./zh-tw": 74152,
	"./zh-tw.js": 74152
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 86902:
/*!**********************************************!*\
  !*** ./runestone/activecode/js/acfactory.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ACFactory)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var _activecode_js_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activecode_js.js */ 40653);
/* harmony import */ var _activecode_html_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode_html.js */ 15033);
/* harmony import */ var _activecode_sql_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode_sql.js */ 23538);
/* harmony import */ var _livecode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./livecode.js */ 45425);
/* harmony import */ var _timed_activecode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./timed_activecode */ 12797);
/* harmony import */ var _common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/js/jquery.highlight.js */ 33194);
/* harmony import */ var _common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_6__);








class ACFactory {
    constructor() {
        this.foo = "bar";
    }
    static createActiveCode(orig, lang, addopts) {
        var opts = {
            orig: orig,
            useRunestoneServices: eBookConfig.useRunestoneServices,
            python3: eBookConfig.python3,
        };
        if (addopts) {
            for (var attrname in addopts) {
                opts[attrname] = addopts[attrname];
            }
        }
        if (lang === undefined) {
            lang = $(opts.orig).find("[data-lang]").data("lang");
        }
        if (opts.timed == true) {
            if (lang === "python") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedActiveCode(opts);
            } else if (
                lang === "java" ||
                lang === "cpp" ||
                lang === "c" ||
                lang === "python3"
            ) {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedLiveCode(opts);
            } else if (lang === "javascript") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedJSActiveCode(opts);
            } else if (lang === "htmlmixed") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedHTMLActiveCode(opts);
            } else if (lang === "sql") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedSQLActiveCode(opts);
            } else {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedActiveCode(opts);
            }
        } else {
            if (lang === "javascript") {
                return new _activecode_js_js__WEBPACK_IMPORTED_MODULE_1__["default"](opts);
            } else if (lang === "htmlmixed") {
                return new _activecode_html_js__WEBPACK_IMPORTED_MODULE_2__["default"](opts);
            } else if (lang === "sql") {
                return new _activecode_sql_js__WEBPACK_IMPORTED_MODULE_3__["default"](opts);
            } else if (
                ["java", "cpp", "c", "python3", "python2", "octave"].indexOf(
                    lang
                ) > -1
            ) {
                return new _livecode_js__WEBPACK_IMPORTED_MODULE_4__["default"](opts);
            } else {
                // default is python
                return new _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode(opts);
            }
        }
    }
    // used by web2py controller(s)
    static addActiveCodeToDiv(outerdivid, acdivid, sid, initialcode, language) {
        var thepre, newac;
        var acdiv = document.getElementById(acdivid);
        $(acdiv).empty();
        thepre = document.createElement("textarea");
        thepre["data-component"] = "activecode";
        thepre.id = outerdivid;
        $(thepre).data("lang", language);
        $(acdiv).append(thepre);
        var opts = {
            orig: thepre,
            useRunestoneServices: true,
        };
        var addopts = {
            sid: sid,
            graderactive: true,
        };
        if (language === "htmlmixed") {
            addopts["vertical"] = true;
        }
        newac = ACFactory.createActiveCode(thepre, language, addopts);
        var savediv = newac.divid;
        newac.divid = savediv;
        newac.editor.setSize(500, 300);
        setTimeout(function () {
            newac.editor.refresh();
        }, 500);
    }
    static createActiveCodeFromOpts(opts) {
        return ACFactory.createActiveCode(opts.orig, opts.lang, opts);
    }
    static createScratchActivecode() {
        /* set up the scratch Activecode editor in the search menu */
        // use the URL to assign a divid - each page should have a unique Activecode block id.
        // Remove everything from the URL but the course and page name
        // todo:  this could probably be eliminated and simply moved to the template file

        if (eBookConfig.enableScratchAC == false) return;

        var divid = eBookConfig.course + "_scratch_ac";
        divid = divid.replace(/[#.]/g, ""); // in case book title has characters that will mess up our selectors
        eBookConfig.scratchDiv = divid;
        let stdin = "";
        var lang = eBookConfig.acDefaultLanguage
            ? eBookConfig.acDefaultLanguage
            : "python";
        if (lang === "java" || lang === "cpp" || lang === "python3") {
            stdin = `data-stdin="text for stdin"`;
        }
        // generate the HTML
        var html = `<div id="ac_modal_${divid}" class="modal fade">
              <div class="modal-dialog scratch-ac-modal">
                <div class="modal-content">
                  <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                    <h4 class="modal-title">Scratch ActiveCode</h4>
                  </div>
                  <div class="modal-body">
                  <div data-component="activecode" id=${divid}>
                  <div id=${divid}_question class="ac_question"><p>Use this area for writing code or taking notes.</p></div>
                  <textarea data-codelens="true" data-lang="${lang}" ${stdin}>




                  </textarea>
                  </div>
                  </div>
                </div>
              </div>
            </div>`;
        var el = $(html);
        $("body").append(el);
        el.on("shown.bs.modal show.bs.modal", function () {
            el.find(".CodeMirror").each(function (i, e) {
                e.CodeMirror.refresh();
                e.CodeMirror.focus();
            });
        });
    }
    static toggleScratchActivecode() {
        if (!eBookConfig.enableScratchAC) return;
        var divid = "ac_modal_" + eBookConfig.scratchDiv;
        var div = $("#" + divid);
        $(`#${eBookConfig.scratchDiv}`).removeClass("ac_section");
        div.modal("toggle");
    }
}

//
// Page Initialization
//

$(document).on("runestone:login-complete", function () {
    ACFactory.createScratchActivecode();
    $("[data-component=activecode]").each(function () {
        if ($(this).closest("[data-component=timedAssessment]").length == 0) {
            // If this element exists within a timed component, don't render it here
            try {
                window.edList[this.id] = ACFactory.createActiveCode(
                    this,
                    $(this).find("textarea").data("lang")
                );
            } catch (err) {
                console.log(`Error rendering Activecode Problem ${this.id}
                Details: ${err}`);
            }
        }
    });
    if (loggedout) {
        for (let k in window.edList) {
            window.edList[k].disableSaveLoad();
        }
    } else {
        for (let k in window.edList) {
            window.edList[k].enableSaveLoad();
        }
    }
});

if (typeof window.component_factory === "undefined") {
    window.component_factory = {};
}

window.component_factory.activecode = ACFactory.createActiveCodeFromOpts;

// This is the easiest way to expose this outside the module.
window.ACFactory = ACFactory;

// This seems a bit hacky and possibly brittle, but its hard to know how long it will take to
// figure out the login/logout status of the user.  Sometimes its immediate, and sometimes its
// long.  So to be safe we'll do it both ways..
var loggedout;
$(document).on("runestone:logout", function () {
    loggedout = true;
});
$(document).on("runestone:logout", function () {
    for (let k in window.edList) {
        if (window.edList.hasOwnProperty(k)) {
            window.edList[k].disableSaveLoad();
        }
    }
});


/***/ }),

/***/ 40053:
/*!*******************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.en.js ***!
  \*******************************************************/
/***/ (() => {

$.i18n().load({
    en: {
        msg_activecode_load_history: "Load History",
        msg_activecode_audio_tour: "Audio Tour",
        msg_activecode_loaded_code: "Loaded your saved code.",
        msg_activecode_no_saved_code: "No saved code.",
        msg_activecode_run_code: "Run",
        msg_activecode_show_feedback: "Show Feedback",
        msg_activecode_show_code: "Show Code",
        msg_activecode_hide_code: "Hide Code",
        msg_activecode_show_codelens: "Show CodeLens",
        msg_activecode_show_in_codelens: "Show in CodeLens",
        msg_activecode_hide_codelens: "Hide Codelens",

        msg_activecode_parse_error:
            "A parse error means that Python does not understand the syntax on the line the error message points out. Common examples are forgetting commas beteween arguments or forgetting a : on a for statement",
        msg_activecode_parse_error_fix:
            "To fix a parse error you just need to look carefully at the line with the error and possibly the line before it.  Make sure it conforms to all of Python's rules.",
        msg_activecode_type_error:
            "Type errors most often occur when an expression tries to combine two objects with types that should not be combined.  Like raising a string to a power",
        msg_activecode_type_error_fix:
            "To fix a type error you will most likely need to trace through your code and make sure the variables have the types you expect them to have.  It may be helpful to print out each variable along the way to be sure its value is what you think it should be.",
        msg_activecode_name_error:
            "A name error almost always means that you have used a variable before it has a value.  Often this may be a simple typo, so check the spelling carefully.",
        msg_activecode_name_error_fix:
            "Check the right hand side of assignment statements and your function calls, this is the most likely place for a NameError to be found.",
        msg_activecode_value_error:
            "A ValueError most often occurs when you pass a parameter to a function and the function is expecting one type and you pass another.",
        msg_activecode_value_error_fix:
            "The error message gives you a pretty good hint about the name of the function as well as the value that is incorrect. Look at the error message closely and then trace back to the variable containing the problematic value.",
        msg_activecode_attribute_error:
            "This error message is telling you that the object on the left hand side of the dot, does not have the attribute or method on the right hand side.",
        msg_activecode_attribute_error_fix:
            "The most common variant of this message is that the object undefined does not have attribute X.  This tells you that the object on the left hand side of the dot is not what you think. Trace the variable back and print it out in various places until you discover where it becomes undefined.  Otherwise check the attribute on the right hand side of the dot for a typo.",
        msg_activecode_token_error:
            "Most of the time this error indicates that you have forgotten a right parenthesis or have forgotten to close a pair of quotes.",
        msg_activecode_token_error_fix:
            "Check each line of your program and make sure that your parenthesis are balanced.",
        msg_activecode_time_limit_error:
            "Your program is running too long.  Most programs in this book should run in less than 10 seconds easily. This probably indicates your program is in an infinite loop.",
        msg_activecode_time_limit_error_fix:
            "Add some print statements to figure out if your program is in an infinte loop.  If it is not you can increase the run time with sys.setExecutionLimit(msecs)",
        msg_activecode_general_error:
            "Your program is running for too long.  Most programs in this book should run in less than 30 seconds easily. This probably indicates your program is in an infinite loop.",
        msg_activecode_general_error_fix:
            "Add some print statements to figure out if your program is in an infinte loop.  If it is not you can increase the run time with sys.setExecutionLimit(msecs)",
        msg_activecode_syntax_error:
            "This message indicates that Python can't figure out the syntax of a particular statement.  Some examples are assigning to a literal, or a function call",
        msg_activecode_syntax_error_fix:
            "Check your assignment statements and make sure that the left hand side of the assignment is a variable, not a literal or a function.",
        msg_activecode_key_error:
            "This message indicates that you are trying to access an element of a dictionary, but the dictionary does not have that the key you are using.",
        msg_activecode_key_error_fix:
            "You may have a typo in the name of your key.  It is also good practice to check if the key exists using a statement like if key in mydict.  You can also use mydict.get(key,defaultvalue) so that if the key is not in the dictionary you get the default value instead of an error.",
        msg_activecode_index_error:
            "This message means that you are trying to index past the end of a string or a list.  For example if your list has 3 things in it and you try to access the item at position 3 or more.",
        msg_activecode_index_error_fix:
            "Remember that the first item in a list or string is at index position 0, quite often this message comes about because you are off by one.  Remember in a list of length 3 the last legal index is 2",
        msg_activecode_uri_error: "",
        msg_activecode_uri_error_fix: "",
        msg_activecode_import_error:
            "This error message indicates that you are trying to import a module that does not exist",
        msg_activecode_import_error_fix:
            "One problem may simply be that you have a typo.  It may also be that you are trying to import a module that exists in 'real' Python, but does not exist in this book.  If this is the case, please submit a feature request to have the module added.",
        msg_activecode_reference_error:
            "This is most likely an internal error, particularly if the message references the console.",
        msg_activecode_reference_error_fix:
            "Try refreshing the webpage, and if the error continues, submit a bug report along with your code",
        msg_activecode_zero_division_error:
            "This tells you that you are trying to divide by 0. Typically this is because the value of the variable in the denominator of a division expression has the value 0",
        msg_activecode_zero_division_error_fix:
            "You may need to protect against dividing by 0 with an if statment, or you may need to rexamine your assumptions about the legal values of variables, it could be an earlier statment that is unexpectedly assigning a value of zero to the variable in question.",
        msg_activecode_range_error:
            "This message almost always shows up in the form of Maximum call stack size exceeded.",
        msg_activecode_range_error_fix:
            "This always occurs when a function calls itself.  Its pretty likely that you are not doing this on purpose. Except in the chapter on recursion.  If you are in that chapter then its likely you haven't identified a good base case.",
        msg_activecode_internal_error:
            "An Internal error may mean that you've triggered a bug in our Python",
        msg_activecode_internal_error_fix:
            "Report this error, along with your code as a bug.",
        msg_activecode_indentation_error:
            "This error occurs when you have not indented your code properly.  This is most likely to happen as part of an if, for, while or def statement.",
        msg_activecode_indentation_error_fix:
            "Check your if, def, for, and while statements to be sure the lines are properly indented beneath them.  Another source of this error comes from copying and pasting code where you have accidentally left some bits of code lying around that don't belong there anymore.",
        msg_activecode_not_implemented_error:
            "This error occurs when you try to use a builtin function of Python that has not been implemented in this in-browser version of Python.",
        msg_activecode_not_implemented_error_fix:
            "For now the only way to fix this is to not use the function.  There may be workarounds.  If you really need this builtin function then file a bug report and tell us how you are trying to use the function.",

        msg_activecode_file_not_found: "File not found: '$1'",
        msg_activecode_no_file_or_dir:
            "[Errno 2] No such file or directory: '$1'",
        msg_activecode_starting: "Click the play button to begin the $1",
        msg_activecode_playing: "Playing the $1",
        msg_activecode_loading_audio:
            "Loading audio.  Please wait.   If the tour doesn't start soon click on the leftmost control button (Play first audio in tour)",
        msg_activecode_pause_current_audio: "Pause current audio",
        msg_activecode_pause_audio: "Pause audio",
        msg_activecode_play_paused_audio: "Play paused audio",
        msg_activecode_audio_paused:
            "The $1 has been paused. Click on the play button to resume the tour.",
        msg_activecode_input_prg: "Input for Program",
        msg_activecode_were_compiling_err:
            "There were errors compiling your code. See below.",
        msg_activecode_time_limit_exc: "Time Limit Exceeded on your program",
        msg_activecode_server_err: "A server error occurred: $1 $2",
        msg_activecode_compiling_running:
            "Compiling and Running your Code Now...",
        msg_activecode_server_comm_err: "Error communicating with the server.",
        msg_activecode_save_run: "Save & Run",
        msg_activecode_render: "Save & Render",
        msg_activecode_assertion_error:
            "An assertion error happens when python encounters an assertion statement.  Python evaluates the expression to the right of the word assert; if that expression is True everything is fine and the program continues.  If the expression is False Python raises an error and stops.",
        msg_activecode_assertion_error_fix:
            "Check the expression to the right of assert.  The expression is False and you will need to determine why that is.  You may want to simply print out the individual parts of the expression to understand why it is evaluating to False.",
        msg_activecode_load_db: "Loading DB...",
    },
});


/***/ }),

/***/ 46108:
/*!**********************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.pt-br.js ***!
  \**********************************************************/
/***/ (() => {

$.i18n().load({
    "pt-br": {
        msg_activecode_load_history: "Carregar histórico",
        msg_activecode_audio_tour: "Tour de áudio",
        msg_activecode_loaded_code: "Código salvo carregado.",
        msg_activecode_no_saved_code: "Não há código salvo.",
        msg_activecode_run_code: "Executar",
        msg_activecode_show_feedback: "Exibir Feedbacks",
        msg_activecode_show_code: "Mostrar Código",
        msg_activecode_hide_code: "Ocultar Código",
        msg_activecode_show_codelens: "Mostrar CodeLens",
        msg_activecode_show_in_codelens: "Mostrar em CodeLens",
        msg_activecode_hide_codelens: "Ocultar Codelens",

        msg_activecode_parse_error:
            "Um erro de Parse significa que Python não entende a sintaxe da linha que a mensagem de erro aponta. Exemplos comuns são esquecer vírgulas entre argumentos ou esquecer ':' em um comando for.",
        msg_activecode_parse_error_fix:
            "Para corrigir um erro de Parse, você só precisa olhar cuidadosamente a linha com o erro e possivelmente a linha antes dela. Tenha certeza que estão de acordo com todas as regras de Python.",
        msg_activecode_type_error:
            "Erros de tipagem ocorrem mais frequentemente quando uma expressão tenta combinar dois objetos com tipos que não deveriam ser combinados. Como elevar uma String a uma potência.",
        msg_activecode_type_error_fix:
            "Para corrigir um erro de tipagem você provavelmente precisará percorrer seu código e ter certeza de que as variáveis possuem os tipos que você espera que elas tenham. Pode ser útil imprimir cada variável ao longo do caminho para checar se elas possuem o valor que você acha que deveriam ter.",
        msg_activecode_name_error:
            "Um erro de nome quase sempre significa que você usou uma variável antes dela ter um valor. Frequentemente isso pode ser um erro de digitação, então cheque a ortografia cuidadosamente.",
        msg_activecode_name_error_fix:
            "Cheque o lado direito das atribuições e suas chamadas de funções, são os lugares mais prováveis de encontrar um erro de nome.",
        msg_activecode_value_error:
            "Um erro de valor ocorre mais frequentemente quando uma função está esperando um tipo mas você passa um parâmetro de outro tipo.",
        msg_activecode_value_error_fix:
            "A mensagem de erro te dá uma boa dica sobre o nome da função e o valor incorreto. Leia atentamente a mensagem de erro e volte à variável que contém o valor problemático.",
        msg_activecode_attribute_error:
            "Essa mensagem de erro está te dizendo que o objeto do lado esquerdo do ponto não tem o atributo ou método do seu lado direito.",
        msg_activecode_attribute_error_fix:
            "A variante mais comum dessa mensagem é que o objeto indefinido não tem o atributo X. Isso diz que o objeto do lado esquerdo do ponto não é o que você pensa. Rastreie essa variável e imprima-a em vários lugares até descobrir onde ela se torna indefinida. Caso contrário, cheque se há erro de digitação no atributo do lado direito do ponto.",
        msg_activecode_token_error:
            "Na maioria das vezes este erro indica que você esqueceu de fechar um parênteses ou aspas.",
        msg_activecode_token_error_fix:
            "Cheque cada linha do seu programa e certifique-se de que todos os parênteses estão fechados.",
        msg_activecode_time_limit_error:
            "Seu programa está demorando muito. Os programas deste livro deveriam rodar em menos de 10 segundos. Isso provavelmente indica que seu programa está em um loop infinito.",
        msg_activecode_time_limit_error_fix:
            "Imprima mensagens em algumas linhas para descobrir se seu programa está em um loop infinito. Caso não esteja, você pode aumentar o tempo limite de execução com o comando sys.setExecutionLimit(ms)",
        msg_activecode_general_error:
            "Seu programa está demorando muito. Os programas deste livro deveriam rodar em menos de 30 segundos. Isso provavelmente indica que seu programa está em um loop infinito.",
        msg_activecode_general_error_fix:
            "Imprima mensagens em algumas linhas para descobrir se seu programa está em um loop infinito. Caso não esteja, você pode aumentar o tempo limite de execução com o comando sys.setExecutionLimit(ms)",
        msg_activecode_syntax_error:
            "Esta mensagem indica que Python não entendeu a sintaxe de um comando. Alguns exemplos são atribuição de um literal, ou uma chamada de função",
        msg_activecode_syntax_error_fix:
            "Cheque as atribuições de seu programa e certifique-se de que o lado esquerdo é uma variável, e não um literal ou função.",
        msg_activecode_key_error:
            "Esta mensagem indica que você está tentando acessar um elemento cuja chave não existe no dicionário.",
        msg_activecode_key_error_fix:
            "Você pode ter um erro de digitação no nome da sua chave. É uma boa prática checar se a chave existe usando um comando 'if (chave) in meu_dicionario'. Você também pode usar o comando 'meu_dicionario.get(chave, valorPadrão)' para obter o valor padrão ao invés de um erro caso a chave não exista.",
        msg_activecode_index_error:
            "Você está tentando acessar um índice além do final de uma string ou lista. Por exemplo, se sua lista possui 3 elementos nela e você tenta acessar o item na posição 3 ou mais.",
        msg_activecode_index_error_fix:
            "Lembre-se que o primeiro elemento de uma lista ou string está no índice 0, normalmente esta mensagem é exibida porque você errou o índice por 1. Em uma lista de tamanho 3, o último índice válido é 2",
        msg_activecode_uri_error: "",
        msg_activecode_uri_error_fix: "",
        msg_activecode_import_error:
            "Esta mensagem indica que você está tentando importar um módulo que não existe",
        msg_activecode_import_error_fix:
            "Um problema pode ser apenas um erro de digitação. Também pode ser que você está tentando importar um módulo que existe em Python 'real', mas não existe neste livro. Se este é o caso, por favor envie um pedido para ter esse módulo adicionado.",
        msg_activecode_reference_error:
            "Isso parece ser um erro interno, especialmente se a mensagem faz referência ao console.",
        msg_activecode_reference_error_fix:
            "Tente atualizar a página. Se o erro persistir, envie um relatório de bug junto com seu código",
        msg_activecode_zero_division_error:
            "Isso diz que você está tentando dividir por 0. Normalmente é porque o valor da variável no denominador de uma divisão tem o valor 0",
        msg_activecode_zero_division_error_fix:
            "Você pode proteger contra dividir por 0 com um comando 'if', ou você pode precisar reavaliar suas suposições sobre os valores das variáveis, pois um comando anterior pode ter inesperadamente atribuído o valor 0 a essa variável.",
        msg_activecode_range_error:
            "Esta mensagem quase sempre aparece na forma de 'Tamanho máximo da pilha de chamadas excedido'.",
        msg_activecode_range_error_fix:
            "Isso sempre ocorre quando uma função chama ela mesma. Provavelmente você não está fazendo isso de propósito, exceto no capítulo sobre recursão. Se você está nesse capítulo, então provavelmente ainda não identificou um bom caso base.",
        msg_activecode_internal_error:
            "Um erro interno pode significar que você desencadeou um bug no nosso Python",
        msg_activecode_internal_error_fix:
            "Reporte este erro como um bug, juntamente com seu código",
        msg_activecode_indentation_error:
            "Este erro ocorre quando você não indentou seu código devidamente. Isso é mais provável de ocorrer como parte de um comando if, for, while ou def.",
        msg_activecode_indentation_error_fix:
            "Cheque seus comandos if, def, for e while para ter certeza de que as linhas estão devidamente indentadas abaixo delas. Outra fonte deste erro é copiar e colar código em que você acidentalmente deixou restos de código que não pertencem mais ali.",
        msg_activecode_not_implemented_error:
            "Este erro ocorre quando você tenta usar uma função embutida de Python que não foi implementada nesta versão browser de Python.",
        msg_activecode_not_implemented_error_fix:
            "Por enquanto a única maneira de consertar isso é não usando a função. Podem haver soluções alternativas. Se você realmente precisa desta função embutida, envie-nos um relatório de bug e digac omo está tentando usar a função.",

        msg_activecode_file_not_found: "Arquivo não encontrado: '$1'",
        msg_activecode_no_file_or_dir:
            "[Erro nº 2] Arquivo ou diretório inexistente: '$1'",
        msg_activecode_starting: "Clique no botão de execução para começar $1",
        msg_activecode_playing: "Executando $1",
        msg_activecode_loading_audio:
            "Carregando áudio. Por favor, espere. Se o tour não começar logo, clique em 'Stop Tour' e tente novamente.",
        msg_activecode_pause_current_audio: "Pausar áudio atual",
        msg_activecode_pause_audio: "Pausar áudio",
        msg_activecode_play_paused_audio: "Reproduzir áudio pausado",
        msg_activecode_audio_paused:
            "$1 foi pausado. Clique no botão de execução para retomar o tour.",
        msg_activecode_input_prg: "Entrada para o programa",
        msg_activecode_were_compiling_err:
            "Houveram erros ao compilar seu código. Veja abaixo.",
        msg_activecode_time_limit_exc: "Limite de tempo excedido no seu programa",
        msg_activecode_server_err: "Um erro de servidor ocorreu: $1 $2",
        msg_activecode_compiling_running:
            "Compilando e executando seu código...",
        msg_activecode_server_comm_err: "Erro ao comunicar com o servidor.",
        msg_activecode_save_run: "Salvar & Executar",
        msg_activecode_render: "Salvar & Renderizar",
        msg_activecode_assertion_error:
            "Um erro de asserção ocorre quando python encontra um comando 'assert'. Python avalia a expressão do lado direito; se é verdadeira, o programa continua normalmente. Se é falsa, python gera um erro e para a execução." ,
        msg_activecode_assertion_error_fix:
            "Cheque a expressão do lado direito de 'assert'. Essa expressão é falsa e é preciso verificar o motivo. Você pode querer imprimir cada parte da expressão e entender porque é falsa.",
        msg_activecode_load_db: "Carregando banco de dados...",
    },
});


/***/ }),

/***/ 82510:
/*!************************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.sr-Cyrl.js ***!
  \************************************************************/
/***/ (() => {

$.i18n().load({
    "sr-Cyrl": {
        msg_activecode_load_history: "Учитај историју",
        msg_activecode_audio_tour: "Аудио тура",
        msg_activecode_loaded_code: "Ваш изворни код је учитан.",
        msg_activecode_no_saved_code: "Не постоји снимљен код.",
        msg_activecode_run_code: "Покрени програм",
        msg_activecode_show_feedback: "Прикажи резултат",
        msg_activecode_show_code: "Прикажи код",
        msg_activecode_hide_code: "Затвори код",
        msg_activecode_show_codelens: "Корак по корак",
        msg_activecode_show_in_codelens: "Корак по корак",
        msg_activecode_hide_codelens: "Затвори корак по корак",

        msg_sctivecode_parse_error:
            "Синтаксна грешка (parse error) значи да Пајтон не разуме синтаксу у линији кога на коју порука о грешци указује. Типични примери овакве грешке су заборавлјена двотачка код 'if' или 'for' исказа или заборављена запета између аргумената код позива функције",
        msg_sctivecode_parse_error_fix:
            "Да бисте исправили синтаксну грешку треба пажњиво да погледате линију изворног кода на коју указује поруга о грешци и можда претходну линину изворног кода. Проверите да ли су поштована сва синтаксна правила Пајтона.",
    },
});


/***/ }),

/***/ 750:
/*!***********************************************!*\
  !*** ./runestone/activecode/js/activecode.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveCode": () => (/* binding */ ActiveCode)
/* harmony export */ });
/* harmony import */ var _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/js/runestonebase.js */ 2568);
/* harmony import */ var _audiotour_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audiotour.js */ 27350);
/* harmony import */ var _activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode-i18n.en.js */ 40053);
/* harmony import */ var _activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode-i18n.pt-br.js */ 46108);
/* harmony import */ var _activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activecode-i18n.sr-Cyrl.js */ 82510);
/* harmony import */ var _activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! codemirror */ 4631);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! codemirror/mode/python/python.js */ 5321);
/* harmony import */ var codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! codemirror/mode/css/css.js */ 36629);
/* harmony import */ var codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! codemirror/mode/htmlmixed/htmlmixed.js */ 16531);
/* harmony import */ var codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! codemirror/mode/xml/xml.js */ 29589);
/* harmony import */ var codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! codemirror/mode/javascript/javascript.js */ 96876);
/* harmony import */ var codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! codemirror/mode/sql/sql.js */ 54086);
/* harmony import */ var codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! codemirror/mode/clike/clike.js */ 99762);
/* harmony import */ var codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! codemirror/mode/octave/octave.js */ 15734);
/* harmony import */ var codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _css_activecode_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./../css/activecode.css */ 27375);
/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ 90464);
/* harmony import */ var codemirror_addon_hint_show_hint_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! codemirror/addon/hint/show-hint.js */ 71707);
/* harmony import */ var codemirror_addon_hint_show_hint_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_hint_show_hint_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var codemirror_addon_hint_show_hint_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! codemirror/addon/hint/show-hint.css */ 68129);
/* harmony import */ var codemirror_addon_hint_sql_hint_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! codemirror/addon/hint/sql-hint.js */ 3585);
/* harmony import */ var codemirror_addon_hint_sql_hint_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_hint_sql_hint_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var codemirror_addon_hint_anyword_hint_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! codemirror/addon/hint/anyword-hint.js */ 48991);
/* harmony import */ var codemirror_addon_hint_anyword_hint_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_hint_anyword_hint_js__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var codemirror_addon_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! codemirror/addon/edit/matchbrackets.js */ 4328);
/* harmony import */ var codemirror_addon_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _skulpt_min_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./skulpt.min.js */ 53098);
/* harmony import */ var _skulpt_min_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_skulpt_min_js__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./skulpt-stdlib.js */ 55409);
/* harmony import */ var _skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var vega_embed__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! vega-embed */ 39119);
/**
 *
 * Created by bmiller on 3/19/15.
 */
/* Define global variables for ESLint */
/* global Sk */


























// Used by Skulpt.

// Adapt for use outside webpack -- see https://github.com/vega/vega-embed.
window.vegaEmbed = vega_embed__WEBPACK_IMPORTED_MODULE_23__["default"];

var isMouseDown = false;
document.onmousedown = function () {
    isMouseDown = true;
};

document.onmouseup = function () {
    isMouseDown = false;
};
window.edList = {};

var socket, connection, doc;
var chatcodesServer = "chat.codes";

(codemirror__WEBPACK_IMPORTED_MODULE_5___default().commands.autocomplete) = function (cm) {
    cm.showHint({ hint: (codemirror__WEBPACK_IMPORTED_MODULE_5___default().hint.anyword) });
};

// separate into constructor and init
class ActiveCode extends _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(opts) {
        super(opts);
        var suffStart;
        var orig = $(opts.orig).find("textarea")[0];
        this.containerDiv = opts.orig;
        this.useRunestoneServices = opts.useRunestoneServices;
        this.python3 = true;
        this.alignVertical = opts.vertical;
        this.origElem = orig;
        this.origText = this.origElem.textContent;
        this.divid = opts.orig.id;
        this.code = $(orig).text() || "\n\n\n\n\n";
        this.language = $(orig).data("lang");
        this.timelimit = $(orig).data("timelimit");
        this.includes = $(orig).data("include");
        this.hidecode = $(orig).data("hidecode");
        this.chatcodes = $(orig).data("chatcodes");
        this.hidehistory = $(orig).data("hidehistory");
        this.question = $(opts.orig).find(`#${this.divid}_question`)[0];
        this.tie = $(orig).data("tie");
        this.dburl = $(orig).data("dburl");
        this.runButton = null;
        this.enabledownload = $(orig).data("enabledownload");
        this.downloadButton = null;
        this.saveButton = null;
        this.loadButton = null;
        this.outerDiv = null;
        this.partner = "";
        this.runCount = 0;
        this.logResults = true;
        if (!eBookConfig.allow_pairs || $(orig).data("nopair")) {
            this.enablePartner = false;
        } else {
            this.enablePartner = true;
        }
        this.output = null; // create pre for output
        this.graphics = null; // create div for turtle graphics
        this.codecoach = null;
        this.codelens = null;
        this.controlDiv = null;
        this.historyScrubber = null;
        this.timestamps = ["Original"];
        this.autorun = $(orig).data("autorun");
        if (this.chatcodes && eBookConfig.enable_chatcodes) {
            if (!socket) {
                socket = new WebSocket("wss://" + chatcodesServer);
            }
            if (!connection) {
                connection = new window.sharedb.Connection(socket);
            }
            if (!doc) {
                doc = connection.get("chatcodes", "channels");
            }
        }
        if (this.graderactive || this.isTimed) {
            this.hidecode = false;
        }
        if (this.includes) {
            this.includes = this.includes.split(/\s+/);
        }
        let prefixEnd = this.code.indexOf("^^^^");
        if (prefixEnd > -1) {
            this.prefix = this.code.substring(0, prefixEnd);
            this.code = this.code.substring(prefixEnd + 5);
        }
        suffStart = this.code.indexOf("====");
        if (suffStart > -1) {
            // The +5 gets past the ====\n
            this.suffix = this.code.substring(suffStart + 5);
            this.code = this.code.substring(0, suffStart);
        }
        this.history = [this.code];
        this.createEditor();
        this.createOutput();
        this.createControls();
        if ($(orig).data("caption")) {
            this.caption = $(orig).data("caption");
        } else {
            this.caption = "ActiveCode";
        }
        this.addCaption("runestone");
        setTimeout(
            function () {
                this.editor.refresh();
            }.bind(this),
            1000
        );
        if (this.autorun) {
            // Simulate pressing the run button, since this will also prevent the user from clicking it until the initial run is complete, and also help the user understand why they're waiting.
            $(this.runButtonHandler.bind(this));
        }
        this.indicate_component_ready();
        if (typeof Prism !== "undefined") {
            Prism.highlightAllUnder(this.containerDiv);
        }
    }

    createEditor(index) {
        this.outerDiv = document.createElement("div");
        var linkdiv = document.createElement("div");
        linkdiv.id = this.divid.replace(/_/g, "-").toLowerCase(); // :ref: changes _ to - so add this as a target
        var codeDiv = document.createElement("div");
        $(codeDiv).addClass("ac_code_div col-md-12");
        this.codeDiv = codeDiv;
        this.outerDiv.lang = this.language;
        $(this.origElem).replaceWith(this.outerDiv);
        if (linkdiv.id !== this.divid) {
            // Don't want the 'extra' target if they match.
            this.outerDiv.appendChild(linkdiv);
        }
        this.outerDiv.appendChild(codeDiv);
        var edmode = this.outerDiv.lang;
        if (edmode === "sql") {
            edmode = "text/x-sql";
        } else if (edmode === "java") {
            edmode = "text/x-java";
        } else if (edmode === "cpp") {
            edmode = "text/x-c++src";
        } else if (edmode === "c") {
            edmode = "text/x-csrc";
        } else if (edmode === "python3") {
            edmode = "python";
        } else if (edmode === "octave" || edmode === "MATLAB") {
            edmode = "text/x-octave";
        }
        var editor = codemirror__WEBPACK_IMPORTED_MODULE_5___default()(codeDiv, {
            value: this.code,
            lineNumbers: true,
            mode: edmode,
            indentUnit: 4,
            matchBrackets: true,
            autoMatchParens: true,
            extraKeys: {
                Tab: "indentMore",
                "Shift-Tab": "indentLess",
                "Ctrl-Space": "autocomplete",
            },
        });
        // Make the editor resizable
        $(editor.getWrapperElement()).resizable({
            resize: function () {
                editor.setSize($(this).width(), $(this).height());
                editor.refresh();
            },
        });
        // give the user a visual cue that they have changed but not saved
        editor.on(
            "change",
            function (ev) {
                if (
                    editor.acEditEvent == false ||
                    editor.acEditEvent === undefined
                ) {
                    // change events can come before any real changes for various reasons, some unknown
                    // this avoids unneccsary log events and updates to the activity counter
                    // offsetParent === null means that the element is not on the screen and so can't change
                    // this.controlDiv.offsetParent
                    if (
                        this.origText === editor.getValue() ||
                        this.addingScrubber
                    ) {
                        console.log("Fake change event, skipping the log");
                        return;
                    }
                    $(editor.getWrapperElement()).css(
                        "border-top",
                        "2px solid #b43232"
                    );
                    $(editor.getWrapperElement()).css(
                        "border-bottom",
                        "2px solid #b43232"
                    );
                    this.isAnswered = true;
                    // the first time the student types in the write-code box
                    this.logBookEvent({
                        event: "activecode",
                        act: "edit",
                        div_id: this.divid,
                    });
                }
                editor.acEditEvent = true;
            }.bind(this)
        ); // use bind to preserve *this* inside the on handler.
        //Solving Keyboard Trap of ActiveCode: If user use tab for navigation outside of ActiveCode, then change tab behavior in ActiveCode to enable tab user to tab out of the textarea
        $(window).keydown(function (e) {
            var code = e.keyCode ? e.keyCode : e.which;
            if (code == 9 && $("textarea:focus").length === 0) {
                editor.setOption("extraKeys", {
                    Tab: function (cm) {
                        $(document.activeElement)
                            .closest(".tab-content")
                            .nextSibling.focus();
                    },
                    "Shift-Tab": function (cm) {
                        $(document.activeElement)
                            .closest(".tab-content")
                            .previousSibling.focus();
                    },
                });
            }
        });
        this.editor = editor;
        if (this.hidecode) {
            $(this.codeDiv).css("display", "none");
        }
    }

    async runButtonHandler() {
        // Disable the run button until the run is finished.
        this.runButton.disabled = true;
        try {
            await this.runProg();
        } catch (e) {
            console.log(`there was an error ${e} running the code`);
        }
        if (this.logResults) {
            this.logCurrentAnswer();
        }
        this.renderFeedback();
        // The run is finished; re-enable the button.
        this.runButton.disabled = false;
        this.runCount += 1;
        this.toggleAlert();
    }

    createControls() {
        var ctrlDiv = document.createElement("div");
        var butt;
        $(ctrlDiv).addClass("ac_actions");
        $(ctrlDiv).addClass("col-md-12");
        // Run
        butt = document.createElement("button");
        $(butt).text($.i18n("msg_activecode_run_code"));
        $(butt).addClass("btn btn-success run-button");
        ctrlDiv.appendChild(butt);
        this.runButton = butt;
        // console.log("adding click function for run");
        this.runButton.onclick = this.runButtonHandler.bind(this);
        $(butt).attr("type", "button");

        if (this.enabledownload || eBookConfig.downloadsEnabled) {
            this.addDownloadButton(ctrlDiv);
        }
        if (!this.hidecode && !this.hidehistory) {
            this.addHistoryScrubber(true);
        }
        if ($(this.origElem).data("gradebutton") && !this.graderactive) {
            this.addFeedbackButton(ctrlDiv);
        }
        // Show/Hide Code
        if (this.hidecode) {
            this.enableHideShow(ctrlDiv);
        }
        // CodeLens
        if ($(this.origElem).data("codelens") && !this.graderactive) {
            this.enableCodeLens(ctrlDiv);
        }
        // Audio Tour
        if ($(this.origElem).data("audio")) {
            this.enableAudioTours(ctrlDiv);
        }
        if (eBookConfig.isInstructor) {
            this.enableInstructorSharing(ctrlDiv);
        }
        if (this.enablePartner) {
            this.setupPartner(ctrlDiv);
        }
        if (this.chatcodes && eBookConfig.enable_chatcodes) {
            this.enableChatCodes(ctrlDiv);
        }

        $(this.outerDiv).prepend(ctrlDiv);
        if (this.question) {
            if ($(this.question).html().match(/^\s+$/)) {
                $(this.question).remove();
            } else {
                $(this.outerDiv).prepend(this.question);
            }
        }
        this.controlDiv = ctrlDiv;
    }

    addFeedbackButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_feedback"));
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        this.gradeButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(this.createGradeSummary.bind(this));
    }

    addDownloadButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).text("Download");
        $(butt).addClass("btn save-button");
        ctrlDiv.appendChild(butt);
        this.downloadButton = butt;
        $(butt).click(this.downloadFile.bind(this, this.language));
        $(butt).attr("type", "button");
    }

    enableHideShow(ctrlDiv) {
        $(this.runButton).attr("disabled", "disabled");
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_code"));
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        this.showHideButt = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            function () {
                $(this.codeDiv).toggle();
                if (this.historyScrubber == null) {
                    this.addHistoryScrubber(true);
                } else {
                    $(this.historyScrubber.parentElement).toggle();
                }
                if (
                    $(this.showHideButt).text() ==
                    $.i18n("msg_activecode_show_code")
                ) {
                    $(this.showHideButt).text(
                        $.i18n("msg_activecode_hide_code")
                    );
                } else {
                    $(this.showHideButt).text(
                        $.i18n("msg_activecode_show_code")
                    );
                }
                if ($(this.runButton).attr("disabled")) {
                    $(this.runButton).removeAttr("disabled");
                } else {
                    $(this.runButton).attr("disabled", "disabled");
                }
            }.bind(this)
        );
    }

    enableCodeLens(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_codelens"));
        $(butt).css("margin-left", "10px");
        this.clButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(this.showCodelens.bind(this));
    }

    enableAudioTours(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_audio_tour"));
        $(butt).css("margin-left", "10px");
        this.atButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            function () {
                new _audiotour_js__WEBPACK_IMPORTED_MODULE_1__["default"](
                    this.divid,
                    this.code,
                    1,
                    $(this.origElem).data("audio")
                );
            }.bind(this)
        );
    }

    enableInstructorSharing(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("btn btn-info");
        $(butt).text("Share Code");
        $(butt).css("margin-left", "10px");
        this.shareButt = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            async function () {
                if (
                    !confirm(
                        "You are about to share this code with ALL of your students.  Are you sure you want to continue?"
                    )
                ) {
                    return;
                }
                let data = {
                    divid: this.divid,
                    code: this.editor.getValue(),
                    lang: this.language,
                };
                let request = new Request(
                    eBookConfig.ajaxURL + "broadcast_code.json",
                    {
                        method: "POST",
                        headers: this.jsonHeaders,
                        body: JSON.stringify(data),
                    }
                );
                let post_promise = await fetch(request);
                let status = await post_promise.json();
                if (status.mess === "success") {
                    alert(`Shared Code with ${status.share_count} students`);
                } else {
                    alert("Sharing Failed");
                }
            }.bind(this)
        );
    }

    setupPartner(ctrlDiv) {
        var checkPartner = document.createElement("input");
        checkPartner.type = "checkbox";
        checkPartner.id = `${this.divid}_part`;
        ctrlDiv.appendChild(checkPartner);
        var plabel = document.createElement("label");
        plabel.for = `${this.divid}_part`;
        $(plabel).text("Pair?");
        ctrlDiv.appendChild(plabel);
        $(checkPartner).click(
            function () {
                if (this.partner) {
                    this.partner = false;
                    $(partnerTextBox).hide();
                    this.partner = "";
                    partnerTextBox.value = "";
                    $(plabel).text("Pair?");
                } else {
                    let didAgree = localStorage.getItem("partnerAgree");
                    if (!didAgree) {
                        didAgree = confirm(
                            "Pair Programming should only be used with the consent of your instructor." +
                                "Your partner must be a registered member of the class and have agreed to pair with you." +
                                "By clicking OK you certify that both of these conditions have been met."
                        );
                        if (didAgree) {
                            localStorage.setItem("partnerAgree", "true");
                        } else {
                            return;
                        }
                    }
                    this.partner = true;
                    $(plabel).text("with: ");
                    $(partnerTextBox).show();
                }
            }.bind(this)
        );
        var partnerTextBox = document.createElement("input");
        partnerTextBox.type = "text";
        ctrlDiv.appendChild(partnerTextBox);
        $(partnerTextBox).hide();
        $(partnerTextBox).change(
            function () {
                this.partner = partnerTextBox.value;
            }.bind(this)
        );
    }

    // This is probably obsolete.  Not sure if anyone at Michigan will come back
    // to working on this again.
    enableChatCodes(ctrlDiv) {
        var chatBar = document.createElement("div");
        var channels = document.createElement("span");
        var topic = window.location.host + "-" + this.divid;
        ctrlDiv.appendChild(chatBar);
        $(chatBar).text("Chat: ");
        $(chatBar).append(channels);
        let butt = document.createElement("a");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text("Create Channel");
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        $(butt).attr("target", "_blank");
        $(butt).attr(
            "href",
            "http://" +
                chatcodesServer +
                "/new?" +
                $.param({
                    topic: window.location.host + "-" + this.divid,
                    code: this.editor.getValue(),
                    lang: "Python",
                })
        );
        this.chatButton = butt;
        chatBar.appendChild(butt);
        var updateChatCodesChannels = function () {
            var data = doc.data;
            var i = 1;
            $(channels).html("");
            data["channels"].forEach(function (channel) {
                if (!channel.archived && topic === channel.topic) {
                    var link = $("<a />");
                    var href =
                        "http://" + chatcodesServer + "/" + channel.channelName;
                    link.attr({
                        href: href,
                        target: "_blank",
                    });
                    link.text(" " + channel.channelName + "(" + i + ") ");
                    $(channels).append(link);
                    i++;
                }
            });
            if (i === 1) {
                $(channels).text("(no active converstations on this problem)");
            }
        };
        doc.subscribe(updateChatCodesChannels);
        doc.on("op", updateChatCodesChannels);
    }

    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_save_run"));
    }

    // _`addHistoryScrubber`
    // ---------------------
    // Activecode -- If the code has not changed wrt the scrubber position value then don't save the code or reposition the scrubber
    //  -- still call runlog, but add a parameter to not save the code
    // add an initial load history button
    // if there is no edit then there is no append   to_save (True/False)
    async addHistoryScrubber(pos_last) {
        this.addingScrubber = true;
        let response;
        var reqData = {
            acid: this.divid,
        };
        if (this.sid !== undefined) {
            reqData["sid"] = this.sid;
        }
        console.log("before get hist");
        if (
            eBookConfig.practice_mode ||
            !eBookConfig.isLoggedIn ||
            (this.isTimed && !this.assessmentTaken)
        ) {
            // If this is timed and already taken we should restore history info
            this.renderScrubber();
        } else {
            let request = new Request(
                `${eBookConfig.new_server_prefix}/assessment/gethist`,
                {
                    method: "POST",
                    headers: this.jsonHeaders,
                    body: JSON.stringify(reqData),
                }
            );
            try {
                response = await fetch(request);
                let data = await response.json();
                if (!response.ok) {
                    throw new Error(
                        `Failed to get the history data: ${data.detail}`
                    );
                }
                data = data.detail;
                if (data.history !== undefined) {
                    this.history = this.history.concat(data.history);
                    for (let t in data.timestamps) {
                        this.timestamps.push(
                            new Date(data.timestamps[t]).toLocaleString()
                        );
                    }
                }
            } catch (e) {
                console.log(`unable to fetch history: ${e}`);
            }
            this.renderScrubber(pos_last);
        }
        this.addingScrubber = false;
        return "success";
    }

    renderScrubber(pos_last) {
        console.log("making a new scrubber");
        var scrubberDiv = document.createElement("div");
        $(scrubberDiv).css("display", "inline-block");
        $(scrubberDiv).css("margin-left", "10px");
        $(scrubberDiv).css("margin-right", "10px");
        $(scrubberDiv).css({
            "min-width": "200px",
            "max-width": "300px",
        });
        var scrubber = document.createElement("div");
        this.timestampP = document.createElement("span");
        this.slideit = function (ev, el) {
            this.editor.setValue(this.history[$(scrubber).slider("value")]);
            var curVal = this.timestamps[$(scrubber).slider("value")];
            let pos = $(scrubber).slider("value");
            let outOf = this.history.length;
            $(this.timestampP).text(`${curVal} - ${pos + 1} of ${outOf}`);
            // a slide will also result in a slidechange event we don't want to double
            // log these events.  So do not log the slide until it stops and creates the changed
            if (ev !== null && ev.type != "slide") {
                this.logBookEvent({
                    event: "activecode",
                    act: "slide:" + curVal,
                    div_id: this.divid,
                });
            }
        };
        $(scrubber).slider({
            max: this.history.length - 1,
            value: this.history.length - 1,
        });
        $(scrubber).css("margin", "10px");
        $(scrubber).on("slide", this.slideit.bind(this));
        $(scrubber).on("slidechange", this.slideit.bind(this));
        scrubberDiv.appendChild(scrubber);
        scrubberDiv.appendChild(this.timestampP);
        // If there is a deadline set then position the scrubber at the last submission
        // prior to the deadline
        if (this.deadline) {
            let i = 0;
            let done = false;
            while (i < this.history.length && !done) {
                if (new Date(this.timestamps[i]) > this.deadline) {
                    done = true;
                } else {
                    i += 1;
                }
            }
            i = i - 1;
            scrubber.value = Math.max(i, 0);
            this.editor.setValue(this.history[scrubber.value]);
            $(scrubber).slider("value", scrubber.value);
        } else if (pos_last) {
            scrubber.value = this.history.length - 1;
            this.editor.setValue(this.history[scrubber.value]);
        } else {
            scrubber.value = 0;
        }
        let pos = $(scrubber).slider("value");
        let outOf = this.history.length;
        let ts = this.timestamps[$(scrubber).slider("value")];
        $(this.timestampP).text(`${ts} - ${pos + 1} of ${outOf}`);
        this.historyScrubber = scrubber;
        $(scrubberDiv).insertAfter(this.runButton);
    } // end definition of helper

    createOutput() {
        // Create a parent div with two elements:  pre for standard output and a div
        // to hold turtle graphics output.  We use a div in case the turtle changes from
        // using a canvas to using some other element like svg in the future.
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output col-md-12");
        this.outDiv = outDiv;
        this.output = document.createElement("pre");
        this.output.id = this.divid + "_stdout";
        $(this.output).css("visibility", "hidden");
        this.graphics = document.createElement("div");
        this.graphics.id = this.divid + "_graphics";
        $(this.graphics).addClass("ac-canvas");
        // This bit of magic adds an event which waits for a canvas child to be created on our
        // newly created div.  When a canvas child is added we add a new class so that the visible
        // canvas can be styled in CSS.  Which a the moment means just adding a border.
        $(this.graphics).on(
            "DOMNodeInserted",
            "canvas",
            function () {
                $(this.graphics).addClass("visible-ac-canvas");
            }.bind(this)
        );
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
        outDiv.appendChild(this.output);
        outDiv.appendChild(this.graphics);
        this.outerDiv.appendChild(outDiv);
        var lensDiv = document.createElement("div");
        lensDiv.id = `${this.divid}_codelens`;
        $(lensDiv).addClass("col-md-12");
        $(lensDiv).css("display", "none");
        this.codelens = lensDiv;
        this.outerDiv.appendChild(lensDiv);
        var coachDiv = document.createElement("div");
        $(coachDiv).addClass("col-md-12");
        $(coachDiv).css("display", "none");
        this.codecoach = coachDiv;
        this.outerDiv.appendChild(coachDiv);
        clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
    }

    disableSaveLoad() {
        $(this.saveButton).addClass("disabled");
        $(this.saveButton).attr("title", "Login to save your code");
        $(this.loadButton).addClass("disabled");
        $(this.loadButton).attr("title", "Login to load your code");
    }

    downloadFile(lang) {
        var fnb = this.divid;
        var d = new Date();
        var fileName =
            fnb +
            "_" +
            d
                .toJSON()
                .substring(0, 10) // reverse date format
                .split("-")
                .join("") +
            "." +
            languageExtensions[lang];
        var code = this.editor.getValue();
        if ("Blob" in window) {
            var textToWrite = code.replace(/\n/g, "\r\n");
            var textFileAsBlob = new Blob([textToWrite], {
                type: "text/plain",
            });
            if ("msSaveOrOpenBlob" in navigator) {
                navigator.msSaveOrOpenBlob(textFileAsBlob, fileName);
            } else {
                var downloadLink = document.createElement("a");
                downloadLink.download = fileName;
                downloadLink.innerHTML = "Download File";
                downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
                downloadLink.click();
            }
        } else {
            alert("Your browser does not support the HTML5 Blob.");
        }
    }

    async createGradeSummary() {
        // get grade and comments for this assignment
        // get summary of all grades for this student
        // display grades in modal window
        var data = {
            div_id: this.divid,
        };
        let request = new Request(eBookConfig.ajaxURL + "getassignmentgrade", {
            method: "POST",
            headers: this.jsonHeaders,
            body: JSON.stringify(data),
        });
        let response = await fetch(request);
        let report = await response.json();
        var body;
        // check for report['message']
        if (report) {
            if (report["version"] == 2) {
                // new version; would be better to embed this in HTML for the activecode
                body =
                    "<h4>Grade Report</h4>" +
                    "<p>This question: " +
                    report["grade"];
                if (report["released"]) {
                    body += " out of " + report["max"];
                }
                body += "</p> <p>";
                if (report["released"] == false) {
                    body += "Preliminary Comments: ";
                }
                body += report["comment"] + "</p>";
            } else {
                body =
                    "<h4>Grade Report</h4>" +
                    "<p>This assignment: " +
                    report["grade"] +
                    "</p>" +
                    "<p>" +
                    report["comment"] +
                    "</p>" +
                    "<p>Number of graded assignments: " +
                    report["count"] +
                    "</p>" +
                    "<p>Average score: " +
                    report["avg"] +
                    "</p>";
            }
        } else {
            body = "<h4>The server did not return any grade information</h4>";
        }
        var html = `<div class="modal fade">
                  <div class="modal-dialog compare-modal">
                    <div class="modal-content">
                      <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                        <h4 class="modal-title">Assignment Feedback</h4>
                      </div>
                      <div class="modal-body">
                        ${body}
                      </div>
                    </div>
                  </div>
                </div>`;
        var el = $(html);
        el.modal();

        return response;
    }

    async showCodelens() {
        if (this.codelens.style.display == "none") {
            this.codelens.style.display = "block";
            this.clButton.innerText = $.i18n("msg_activecode_hide_codelens");
        } else {
            this.codelens.style.display = "none";
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
            return;
        }
        var cl = this.codelens.firstChild;
        if (cl) {
            this.codelens.removeChild(cl);
        }
        var code = await this.buildProg(false);
        var myVars = {};
        myVars.code = code;
        myVars.origin = "opt-frontend.js";
        myVars.cumulative = false;
        myVars.heapPrimitives = false;
        myVars.drawParentPointers = false;
        myVars.textReferences = false;
        myVars.showOnlyOutputs = false;
        myVars.rawInputLstJSON = JSON.stringify([]);
        if (this.language == "python") {
            if (this.python3) {
                myVars.py = 3;
            } else {
                myVars.py = 2;
            }
        } else if (this.langauge == "javascript") {
            myVars.py = "js";
        } else {
            myVars.py = this.language;
        }
        myVars.curInstr = 0;
        myVars.codeDivWidth = 350;
        myVars.codeDivHeight = 400;
        var srcURL = "https://pythontutor.com/iframe-embed.html";
        var srcVars = $.param(myVars);
        var embedUrlStr = `${srcURL}#${srcVars}`;
        var myIframe = document.createElement("iframe");
        myIframe.setAttribute("id", this.divid + "_codelens");
        myIframe.setAttribute("width", "100%");
        myIframe.setAttribute("height", "500");
        myIframe.setAttribute("style", "display:block");
        myIframe.style.background = "#fff";
        //myIframe.setAttribute("src",srcURL)
        myIframe.src = embedUrlStr;
        this.codelens.appendChild(myIframe);
        this.logBookEvent({
            event: "codelens",
            act: "view",
            div_id: this.divid,
        });
    }
    // <iframe id="%(divid)s_codelens" width="800" height="500" style="display:block"src="#">
    // </iframe>
    showCodeCoach() {
        var myIframe;
        var srcURL;
        var cl;
        var div_id = this.divid;
        if (this.codecoach === null) {
            this.codecoach = document.createElement("div");
            this.codecoach.style.display = "block";
        }
        cl = this.codecoach.firstChild;
        if (cl) {
            this.codecoach.removeChild(cl);
        }
        srcURL = eBookConfig.app + "/admin/diffviewer?divid=" + div_id;
        myIframe = document.createElement("iframe");
        myIframe.setAttribute("id", div_id + "_coach");
        myIframe.setAttribute("width", "100%");
        myIframe.setAttribute("height", "500px");
        myIframe.setAttribute("style", "display:block");
        myIframe.style.background = "#fff";
        myIframe.style.width = "100%";
        myIframe.src = srcURL;
        this.codecoach.appendChild(myIframe);
        $(this.codecoach).show();
        this.logBookEvent({
            event: "coach",
            act: "view",
            div_id: this.divid,
        });
    }

    toggleEditorVisibility() {}

    addErrorMessage(err) {
        // Add the error message
        this.errLastRun = true;
        var errHead = $("<h3>").html("Error");
        this.eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.eContainer.className = "error alert alert-danger";
        this.eContainer.id = this.divid + "_errinfo";
        this.eContainer.appendChild(errHead[0]);
        var errText = this.eContainer.appendChild(
            document.createElement("pre")
        );
        // But, adjust the line numbers.  If the line number is <= pretextLines then it is in included code
        // if it is greater than the number of included lines but less than the pretext + current editor then it is in the student code.
        // adjust the line number we display by eliminating the pre-included code.
        if (err.traceback.length >= 1) {
            var errorLine = err.traceback[0].lineno;
            if (errorLine <= this.pretextLines) {
                errText.innerHTML =
                    "An error occurred in the hidden, included code. Sorry we can't give you a more helpful error message";
                return;
            } else if (errorLine > this.progLines + this.pretextLines) {
                errText.innerHTML = `An error occurred after the end of your code.
One possible reason is that you have an unclosed parenthesis or string.
Another possibility is that there is an error in the hidden test code.
Yet another is that there is an internal error.  The internal error message is: ${err.message}`;
                return;
            } else {
                if (this.pretextLines > 0) {
                    err.traceback[0].lineno =
                        err.traceback[0].lineno - this.pretextLines + 1;
                }
            }
        }
        var errString = err.toString();
        var to = errString.indexOf(":");
        var errName = errString.substring(0, to);
        errText.innerHTML = errString;
        $(this.eContainer).append("<h3>Description</h3>");
        var errDesc = this.eContainer.appendChild(document.createElement("p"));
        errDesc.innerHTML = errorText[errName];
        $(this.eContainer).append("<h3>To Fix</h3>");
        var errFix = this.eContainer.appendChild(document.createElement("p"));
        errFix.innerHTML = errorText[errName + "Fix"];
        var moreInfo = "../ErrorHelp/" + errName.toLowerCase() + ".html";
        //console.log("Runtime Error: " + err.toString());
    }
    setTimeLimit(timer) {
        var timelimit = this.timelimit;
        if (timer !== undefined) {
            timelimit = timer;
        }
        // set execLimit in milliseconds  -- for student projects set this to
        // 25 seconds -- just less than Chrome's own timer.
        if (
            this.code.indexOf("ontimer") > -1 ||
            this.code.indexOf("onclick") > -1 ||
            this.code.indexOf("onkey") > -1 ||
            this.code.indexOf("setDelay") > -1
        ) {
            Sk.execLimit = null;
        } else {
            if (timelimit === "off") {
                Sk.execLimit = null;
            } else if (timelimit) {
                Sk.execLimit = timelimit;
            } else {
                Sk.execLimit = 25000;
            }
        }
    }
    builtinRead(x) {
        if (
            Sk.builtinFiles === undefined ||
            Sk.builtinFiles["files"][x] === undefined
        )
            throw $.i18n("msg_activecode_file_not_found", x);
        return Sk.builtinFiles["files"][x];
    }
    fileReader(divid) {
        // In the beginning files were just pre tags and we used the divid as the filename
        let elem = document.getElementById(divid);
        // In PreTeXt we moved that to a @data-filename
        if (elem === null) {
            elem = document.querySelector(`[data-filename="${divid}"]`);
        }
        let data = "";
        let result = "";
        if (elem == null && Sk.builtinFiles.files.hasOwnProperty(divid)) {
            return Sk.builtinFiles["files"][divid];
        } else {
            // try remote file unless it ends with .js or .py -- otherwise we'll ask the server for all
            // kinds of modules that we are trying to import
            if (!(divid.endsWith(".js") || divid.endsWith(".py"))) {
                $.ajax({
                    async: false,
                    url: `/runestone/ajax/get_datafile?course_id=${eBookConfig.course}&acid=${divid}`,
                    success: function (data) {
                        result = JSON.parse(data).data;
                    },
                    error: function (err) {
                        result = null;
                    },
                });
                if (result) {
                    return result;
                }
            }
        }
        if (elem == null && result === null) {
            throw new Sk.builtin.IOError(
                $.i18n("msg_activecode_no_file_or_dir", divid)
            );
        } else {
            // for backward compatibility - early on we had textarea with the divid on it.
            // but later this switched to a runestone wrapper.  So we may need to dig for a pre
            // or a textarea?
            if (elem.nodeName.toLowerCase() == "textarea") {
                data = elem.value;
            } else {
                let pre = elem.querySelector("pre");
                if (pre) {
                    data = pre.textContent;
                } else {
                    data = elem.textContent;
                }
            }
        }
        return data;
    }
    outputfun(text) {
        // bnm python 3
        var pyStr = function (x) {
            if (x instanceof Array) {
                return "[" + x.join(", ") + "]";
            } else {
                return x;
            }
        };
        var x = text;
        if (!this.python3) {
            if (x.charAt(0) == "(") {
                x = x.slice(1, -1);
                x = "[" + x + "]";
                try {
                    var xl = eval(x);
                    xl = xl.map(pyStr);
                    x = xl.join(" ");
                } catch (err) {}
            }
        }
        $(this.output).css("visibility", "visible");
        text = x;
        text = text
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\n/g, "<br/>");
        return Promise.resolve().then(
            function () {
                setTimeout(
                    function () {
                        $(this.output).append(text);
                    }.bind(this),
                    0
                );
            }.bind(this)
        );
    }

    filewriter(fobj, bytes) {
        let filecomponent = document.getElementById(fobj.name);
        if (!filecomponent) {
            let container = document.createElement("div");
            $(container).addClass("runestone");
            let tab = document.createElement("div");
            $(tab).addClass("datafile_caption");
            tab.innerHTML = `Data file: <code>${fobj.name}</code>`;
            filecomponent = document.createElement("textarea");
            filecomponent.rows = 10;
            filecomponent.cols = 50;
            filecomponent.id = fobj.name;
            $(filecomponent).css("margin-bottom", "5px");
            $(filecomponent).addClass("ac_output");
            container.appendChild(tab);
            container.appendChild(filecomponent);
            this.outerDiv.appendChild(container);
        } else {
            if (fobj.pos$ == 0) {
                $(filecomponent).val("");
            }
        }
        let current = $(filecomponent).val();
        current = current + bytes.v;
        $(filecomponent).val(current);
        $(filecomponent).css("display", "block");
        fobj.pos$ = current.length;
        return current.length;
    }

    async getIncludedCode(divid) {
        if (window.edList[divid]) {
            return window.edList[divid].editor.getValue();
        } else {
            let request = new Request(
                `/runestone/ajax/get_datafile?course_id=${eBookConfig.course}&acid=${divid}`,
                {
                    method: "GET",
                    headers: this.jsonHeaders,
                }
            );
            let wresult = await fetch(request);
            let obj = await wresult.json();
            return obj.data;
        }
    }

    async buildProg(useSuffix) {
        // assemble code from prefix, suffix, and editor for running.
        var pretext;
        var prog = this.editor.getValue() + "\n";
        if (this.prefix) {
            prog = this.prefix + prog;
        }
        this.pretext = "";
        this.pretextLines = 0;
        this.progLines = prog.match(/\n/g).length + 1;
        if (this.includes) {
            // iterate over the includes, in-order prepending to prog
            pretext = "";
            for (var x = 0; x < this.includes.length; x++) {
                let iCode = await this.getIncludedCode(this.includes[x]);
                pretext = pretext + iCode + "\n";
            }
            this.pretext = pretext;
            if (this.pretext) {
                this.pretextLines = (this.pretext.match(/\n/g) || "").length;
            }
            prog = pretext + prog;
        }
        if (useSuffix && this.suffix) {
            prog = prog + this.suffix;
        }
        return Promise.resolve(prog);
    }

    async manage_scrubber(saveCode) {
        if (this.historyScrubber === null && !this.autorun) {
            await this.addHistoryScrubber();
        }
        if (
            this.historyScrubber &&
            this.history[$(this.historyScrubber).slider("value")] !=
                this.editor.getValue()
        ) {
            saveCode = "True";
            this.history.push(this.editor.getValue());
            this.timestamps.push(new Date().toLocaleString());
            $(this.historyScrubber).slider(
                "option",
                "max",
                this.history.length - 1
            );
            $(this.historyScrubber).slider(
                "option",
                "value",
                this.history.length - 1
            );
            this.slideit(null);
        } else {
            saveCode = "False";
        }
        if (this.historyScrubber == null) {
            saveCode = "False";
        }
        return saveCode;
    }

    async checkCurrentAnswer() {
        try {
            await this.runProg();
        } catch (e) {
            console.log(`error running code ${e}`);
        }
    }

    // the sid parameter is optional and is used for group submissions
    async logCurrentAnswer(sid) {
        let data = {
            div_id: this.divid,
            code: this.editor.getValue(),
            language: this.language,
            errinfo: this.errinfo || "",
            to_save: this.saveCode || "F",
            prefix: this.pretext,
            suffix: this.suffix,
            partner: this.partner,
        }; // Log the run event
        if (typeof sid !== "undefined") {
            data.sid = sid;
        }
        await this.logRunEvent(data);
        // If unit tests were run there will be a unit_results
        if (this.unit_results) {
            let unitData = {
                act: this.unit_results,
                div_id: this.divid,
                event: "unittest",
            };
            if (typeof sid !== "undefined") {
                unitData.sid = sid;
            }
            await this.logBookEvent(unitData);
        }
    }

    renderFeedback() {
        // The python unit test code builds the table as it is running the tests
        // In "normal" usage this is displayed immediately.
        // However in exam mode we make a div which is offscreen
        if (this.unit_results_divid) {
            if (this.unit_results_divid.indexOf("_offscreen_") > 0) {
                let urDivid = `${this.divid}_offscreen_unit_results`;
                let unitFeedback = document.getElementById(urDivid);
                let tmp = document.body.removeChild(unitFeedback);
                if ($(this.outerDiv).find(`#${urDivid}`).length > 0) {
                    tmp = $(this.outerDiv).find(`#${urDivid}`)[0];
                } else {
                    this.outerDiv.appendChild(tmp);
                }
                $(tmp).show();
            } else {
                let urDivid = this.divid + "_unit_results";
                if (
                    $(this.outerDiv).find(`#${urDivid}`).length == 0 &&
                    $(this.outerDiv).find(`#${urDivid}_offscreen_unit_results`)
                        .length == 0
                ) {
                    let urResults = document.getElementById(urDivid);
                    this.outerDiv.appendChild(urResults);
                }
            }
        }
    }

    toggleAlert() {
        if (this.is_toggle && this.runCount == 3) {
            if (
                this.errinfo != "success" ||
                this.unit_results.substring(8, 11) != 100.0
            ) {
                setTimeout(function () {
                    alert(
                        "Help is Available Using the Toggle Question Selector! You can try the Mixed-up Question first."
                    );
                }, 500);
                this.logBookEvent({
                    event: "togglealert",
                    act: "Help is Available Using the Toggle Question Selector",
                    div_id: this.divid,
                });
            }
        }
    }

    /* runProg has several async elements to it.
     * 1. Skulpt runs the python program asynchronously
     * 2. The history is restored asynchronously
     * 3. Logging is asynchronous
     *
     * This method returns the skulpt Promise and so the promise will resolve when skulpt is finished.
     * when finished this.unit_results will contain the results of any unit tests that have been run.
     * The table of results is constructed and added to the DOM by the python unittest.gui module in skulpt.
     *
     */
    async runProg(noUI, logResults) {
        console.log("starting runProg");
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        var prog = await this.buildProg(true);
        this.saveCode = "True";
        $(this.output).text("");
        while ($(`#${this.divid}_errinfo`).length > 0) {
            $(`#${this.divid}_errinfo`).remove();
        }
        //$(this.eContainer).remove();
        if (this.codelens) {
            this.codelens.style.display = "none";
        }
        if (this.clButton) {
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
        }
        Sk.configure({
            output: this.outputfun.bind(this),
            read: this.fileReader,
            filewrite: this.filewriter.bind(this),
            __future__: Sk.python3,
            nonreadopen: true,
            //        python3: this.python3,
            imageProxy: "http://image.runestone.academy:8080/320x",
            inputfunTakesPrompt: true,
            jsonpSites: ["https://itunes.apple.com"],
        });
        Sk.divid = this.divid;
        Sk.logResults = logResults;
        if (this.graderactive && this.outerDiv.closest(".loading")) {
            Sk.gradeContainer = this.outerDiv.closest(".loading").id;
        } else {
            Sk.gradeContainer = this.divid;
        }
        this.setTimeLimit();
        (Sk.TurtleGraphics || (Sk.TurtleGraphics = {})).target = this.graphics;
        Sk.canvas = this.graphics.id; //todo: get rid of this here and in image
        if (!noUI) {
            this.saveCode = await this.manage_scrubber(this.saveCode);
            $(this.runButton).attr("disabled", "disabled");
            $(this.historyScrubber).off("slidechange");
            $(this.historyScrubber).slider("disable");
            $(this.outDiv).show({
                duration: 700,
                queue: false,
            });
        }
        try {
            await Sk.misceval.asyncToPromise(function () {
                return Sk.importMainWithBody("<stdin>", false, prog, true);
            });
            if (!noUI) {
                if (this.slideit) {
                    $(this.historyScrubber).on(
                        "slidechange",
                        this.slideit.bind(this)
                    );
                }
                $(this.historyScrubber).slider("enable");
            }
            this.errLastRun = false;
            this.errinfo = "success";
        } catch (err) {
            if (!noUI) {
                $(this.historyScrubber).on(
                    "slidechange",
                    this.slideit.bind(this)
                );
                $(this.historyScrubber).slider("enable");
            }
            this.errinfo = err.toString();
            this.addErrorMessage(err);
        } finally {
            $(this.runButton).removeAttr("disabled");
            if (typeof window.allVisualizers != "undefined") {
                $.each(window.allVisualizers, function (i, e) {
                    e.redrawConnectors();
                });
            }
        }
    }

    disableInteraction() {
        $(this.runButton).hide();
        $(this.codeDiv).addClass("ac-disabled");
    }
}

var languageExtensions = {
    python: "py",
    html: "html",
    javascript: "js",
    java: "java",
    python2: "py",
    python3: "py",
    cpp: "cpp",
    c: "c",
    sql: "sql",
    octave: "m",
};

var errorText = {};

errorText.ParseError = $.i18n("msg_sctivecode_parse_error");
errorText.ParseErrorFix = $.i18n("msg_sctivecode_parse_error_fix");
errorText.TypeError = $.i18n("msg_activecode_type_error");
errorText.TypeErrorFix = $.i18n("msg_activecode_type_error_fix");
errorText.NameError = $.i18n("msg_activecode_name_error");
errorText.NameErrorFix = $.i18n("msg_activecode_name_error_fix");
errorText.ValueError = $.i18n("msg_activecode_value_error");
errorText.ValueErrorFix = $.i18n("msg_activecode_value_error_fix");
errorText.AttributeError = $.i18n("msg_activecode_attribute_error");
errorText.AttributeErrorFix = $.i18n("msg_activecode_attribute_error_fix");
errorText.TokenError = $.i18n("msg_activecode_token_error");
errorText.TokenErrorFix = $.i18n("msg_activecode_token_error_fix");
errorText.TimeLimitError = $.i18n("msg_activecode_time_limit_error");
errorText.TimeLimitErrorFix = $.i18n("msg_activecode_time_limit_error_fix");
errorText.Error = $.i18n("msg_activecode_general_error");
errorText.ErrorFix = $.i18n("msg_activecode_general_error_fix");
errorText.SyntaxError = $.i18n("msg_activecode_syntax_error");
errorText.SyntaxErrorFix = $.i18n("msg_activecode_syntax_error_fix");
errorText.IndexError = $.i18n("msg_activecode_index_error");
errorText.IndexErrorFix = $.i18n("msg_activecode_index_error_fix");
errorText.URIError = $.i18n("msg_activecode_uri_error");
errorText.URIErrorFix = $.i18n("msg_activecode_uri_error_fix");
errorText.ImportError = $.i18n("msg_activecode_import_error");
errorText.ImportErrorFix = $.i18n("msg_activecode_import_error_fix");
errorText.ReferenceError = $.i18n("msg_activecode_reference_error");
errorText.ReferenceErrorFix = $.i18n("msg_activecode_reference_error_fix");
errorText.ZeroDivisionError = $.i18n("msg_activecode_zero_division_error");
errorText.ZeroDivisionErrorFix = $.i18n(
    "msg_activecode_zero_division_error_fix"
);
errorText.RangeError = $.i18n("msg_activecode_range_error");
errorText.RangeErrorFix = $.i18n("msg_activecode_range_error_fix");
errorText.InternalError = $.i18n("msg_activecode_internal_error");
errorText.InternalErrorFix = $.i18n("msg_activecode_internal_error_fix");
errorText.IndentationError = $.i18n("msg_activecode_indentation_error");
errorText.IndentationErrorFix = $.i18n("msg_activecode_indentation_error_fix");
errorText.NotImplementedError = $.i18n("msg_activecode_not_implemented_error");
errorText.NotImplementedErrorFix = $.i18n(
    "msg_activecode_not_implemented_error_fix"
);
errorText.KeyError = $.i18n("msg_activecode_key_error");
errorText.KeyErrorFix = $.i18n("msg_activecode_key_error_fix");
errorText.AssertionError = $.i18n("msg_activecode_assertion_error");
errorText.AssertionErrorFix = $.i18n("msg_activecode_assertion_error_fix");

String.prototype.replaceAll = function (target, replacement) {
    return this.split(target).join(replacement);
};


/***/ }),

/***/ 15033:
/*!****************************************************!*\
  !*** ./runestone/activecode/js/activecode_html.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HTMLActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class HTMLActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        opts.alignVertical = true;
        this.code = $("<textarea />").html(this.origElem.innerHTML).text();
        $(this.runButton).text("Render");
        this.editor.setValue(this.code);
    }

    async runProg() {
        var prog = await this.buildProg(true);
        let saveCode = "True";
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.output).text("");
        if (!this.alignVertical) {
            $(this.codeDiv).switchClass("col-md-12", "col-md-6", {
                duration: 500,
                queue: false,
            });
        }
        $(this.outDiv).show({ duration: 700, queue: false });
        prog =
            "<script type=text/javascript>window.onerror = function(msg,url,line) {alert(msg+' on line: '+line);};</script>" +
            prog;
        this.output.srcdoc = prog;
    }

    createOutput() {
        this.alignVertical = true;
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output");
        if (this.alignVertical) {
            $(outDiv).addClass("col-md-12");
        } else {
            $(outDiv).addClass("col-md-5");
        }
        this.outDiv = outDiv;
        this.output = document.createElement("iframe");
        $(this.output).css("background-color", "white");
        $(this.output).css("position", "relative");
        $(this.output).css("height", "400px");
        $(this.output).css("width", "100%");
        outDiv.appendChild(this.output);
        this.outerDiv.appendChild(outDiv);
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
    }
    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_render"));
    }
}


/***/ }),

/***/ 40653:
/*!**************************************************!*\
  !*** ./runestone/activecode/js/activecode_js.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JSActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class JSActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
    }
    outputfun(a) {
        $(this.output).css("visibility", "visible");
        var str = "[";
        if (typeof a == "object" && a.length) {
            for (var i = 0; i < a.length; i++)
                if (typeof a[i] == "object" && a[i].length) {
                    str += (i == 0 ? "" : " ") + "[";
                    for (var j = 0; j < a[i].length; j++)
                        str +=
                            a[i][j] +
                            (j == a[i].length - 1
                                ? "]" + (i == a.length - 1 ? "]" : ",") + "\n"
                                : ", ");
                } else str += a[i] + (i == a.length - 1 ? "]" : ", ");
        } else {
            try {
                str = JSON.stringify(a);
            } catch (e) {
                str = a;
            }
        }
        return str;
    }
    async runProg() {
        var _this = this;
        var prog = await this.buildProg(true);
        var saveCode = "True";
        var write = function (str) {
            _this.output.innerHTML += _this.outputfun(str);
        };
        var writeln = function (str) {
            if (!str) str = "";
            _this.output.innerHTML += _this.outputfun(str) + "<br />";
        };
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.eContainer).remove();
        $(this.output).text("");
        $(this.outDiv).show({ duration: 700, queue: false });
        try {
            eval(prog);
            this.errinfo = "success";
        } catch (e) {
            this.addErrorMessage(e);
            this.errinfo = e;
        }
    }

    addErrorMessage(err) {
        // Add the error message
        this.errLastRun = true;
        var errHead = $("<h3>").html("Error");
        this.eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.eContainer.className = "error alert alert-danger";
        this.eContainer.id = this.divid + "_errinfo";
        this.eContainer.appendChild(errHead[0]);
        var errText = this.eContainer.appendChild(
            document.createElement("pre")
        );
        var errString = err.toString();
        errText.innerHTML = errString;
        console.log("Runtime Error: " + err.toString());
    }
}


/***/ }),

/***/ 23538:
/*!***************************************************!*\
  !*** ./runestone/activecode/js/activecode_sql.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SQLActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var handsontable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! handsontable */ 36080);
/* harmony import */ var handsontable_dist_handsontable_full_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! handsontable/dist/handsontable.full.css */ 59823);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sql.js/dist/sql-wasm.js */ 26657);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3__);





var allDburls = {};

class SQLActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        //  fnprefix sets the path to load the sql-wasm.wasm file
        var bookprefix;
        var fnprefix;
        // Fix: the mode=browsing problem wich disables useRunestoneServices and
        // makes it impossible to cororectly load sql-wasm
        if (
            eBookConfig.useRunestoneServices ||
            window.location.search.includes("mode=browsing")
        ) {
            bookprefix = `${eBookConfig.app}/books/published/${eBookConfig.basecourse}`;
            fnprefix = bookprefix + "/_static";
        } else {
            // The else clause handles the case where you are building for a static web browser
            bookprefix = "";
            fnprefix = "/_static";
        }
        this.config = {
            locateFile: (filename) => `${fnprefix}/${filename}`,
        };
        this.showLast = $(this.origElem).data("showlastsql");
        var self = this;
        sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3___default()(this.config).then(function (SQL) {
            // set up call to load database asynchronously if given
            if (self.dburl) {
                if (self.dburl.startsWith("/_static")) {
                    self.dburl = `${bookprefix}${self.dburl}`;
                }
                $(self.runButton).attr("disabled", "disabled");
                let buttonText = $(self.runButton).text();
                $(self.runButton).text($.i18n("msg_activecode_load_db"));
                if (!(self.dburl in allDburls)) {
                    allDburls[self.dburl] = {
                        status: "loading",
                        xWaitFor: jQuery.Deferred(),
                    };
                } else {
                    if (allDburls[self.dburl].status == "loading") {
                        allDburls[self.dburl].xWaitFor.done(function () {
                            self.db = allDburls[self.dburl].dbObject;
                            $(self.runButton).removeAttr("disabled");
                            $(self.runButton).text(buttonText);
                        });
                        return;
                    }
                    self.db = allDburls[self.dburl].dbObject;
                    $(self.runButton).removeAttr("disabled");
                    $(self.runButton).text(buttonText);
                    return;
                }
                var xhr = new XMLHttpRequest();
                // For example: https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite
                xhr.open("GET", self.dburl, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = (e) => {
                    var uInt8Array = new Uint8Array(xhr.response);
                    self.db = new SQL.Database(uInt8Array);
                    allDburls[self.dburl].dbObject = self.db;
                    $(self.runButton).text(buttonText);
                    $(self.runButton).removeAttr("disabled");
                    allDburls[self.dburl].db = uInt8Array;
                    allDburls[self.dburl].status = "ready";
                    allDburls[self.dburl].xWaitFor.resolve();
                    // contents is now [{columns:['col1','col2',...], values:[[first row], [second row], ...]}]
                };
                xhr.send();
            } else {
                self.db = new SQL.Database();
            }
        });
    }
    async runProg(noUI, logResults) {
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        // Clear any old results
        this.saveCode = "True";
        let divid = this.divid + "_sql_out";
        let respDiv = document.getElementById(divid);
        if (respDiv) {
            respDiv.parentElement.removeChild(respDiv);
        }
        $(this.output).text("");
        // Run this query
        let query = await this.buildProg(false); // false --> Do not include suffix
        if (!this.db) {
            $(this.output).text(
                `Error: Database not initialized! DBURL: ${this.dburl}`
            );
            return;
        }

        let it = this.db.iterateStatements(query);
        this.results = [];
        try {
            for (let statement of it) {
                let columns = statement.getColumnNames();
                if (columns.length > 0) {
                    // data! probably a SELECT
                    let data = [];
                    while (statement.step()) {
                        data.push(statement.get());
                    }
                    this.results.push({
                        status: "success",
                        columns: columns,
                        values: data,
                        rowcount: data.length,
                    });
                } else {
                    let nsql = statement.getNormalizedSQL();
                    let prefix = nsql.substr(0, 6).toLowerCase();
                    statement.step(); // execute the query
                    // Try to detect INSERT/UPDATE/DELETE to give friendly feedback
                    // on rows modified - unfortunately, this won't catch such queries
                    // if they use CTEs.  There seems to be no reliable way of knowing
                    // when a SQLite query actually modified data.
                    if (
                        prefix === "insert" ||
                        prefix === "update" ||
                        prefix === "delete"
                    ) {
                        this.results.push({
                            status: "success",
                            operation: prefix,
                            rowcount: this.db.getRowsModified(),
                        });
                    } else {
                        this.results.push({ status: "success" });
                    }
                }
            }
        } catch (e) {
            this.results.push({
                status: "failure",
                message: e.toString(),
                sql: it.getRemainingSQL(),
            });
        }

        if (this.results.length === 0) {
            this.results.push({
                status: "failure",
                message: "No queries submitted.",
            });
        }

        try {
            this.saveCode = await this.manage_scrubber(this.saveCode);
            if (this.slideit) {
                $(this.historyScrubber).on(
                    "slidechange",
                    this.slideit.bind(this)
                );
            }
            $(this.historyScrubber).slider("enable");
        } catch (e) {
            console.log(`Failed to update scrubber ${e}`);
        }

        respDiv = document.createElement("div");
        respDiv.id = divid;
        this.outDiv.appendChild(respDiv);
        $(this.outDiv).show();
        // Sometimes we don't want to show a bunch of intermediate results
        // like when we are including a bunch of previous statements from
        // other activecodes In that case the showlastsql flag can be set
        // so we only show the last result
        let resultArray = this.results;
        if (this.showLast) {
            resultArray = this.results.slice(-1);
        }
        for (let r of resultArray) {
            let section = document.createElement("div");
            section.setAttribute("class", "ac_sql_result");
            respDiv.appendChild(section);
            if (r.status === "success") {
                if (r.columns) {
                    let tableDiv = document.createElement("div");
                    section.appendChild(tableDiv);
                    let maxHeight = 350;
                    if (resultArray.length > 1) maxHeight = 200; // max height smaller if lots of results
                    createTable(r, tableDiv, maxHeight);
                    let messageBox = document.createElement("pre");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    let msg = "" + r.rowcount + rmsg + "returned";
                    if (r.rowcount > 100) {
                        msg = msg + " (only first 100 rows displayed)";
                    }
                    msg = msg + ".";
                    messageBox.textContent = msg;
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                } else if (r.rowcount) {
                    let messageBox = document.createElement("pre");
                    let op = r.operation;
                    op = op + (op.charAt(op.length - 1) === "e" ? "d." : "ed.");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    messageBox.textContent = "" + r.rowcount + rmsg + op;
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                } else {
                    let messageBox = document.createElement("pre");
                    messageBox.textContent = "Operation succeeded.";
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                }
            } else {
                let messageBox = document.createElement("pre");
                messageBox.textContent = r.message;
                messageBox.setAttribute("class", "ac_sql_result_failure");
                section.appendChild(messageBox);
            }
        }

        // Now handle autograding
        if (this.suffix) {
            this.testResult = this.autograde(
                this.results[this.results.length - 1]
            );
        } else {
            $(this.output).css("visibility", "hidden");
        }

        return Promise.resolve("done");
    }

    async logCurrentAnswer(sid) {
        let data = {
            div_id: this.divid,
            code: this.editor.getValue(),
            language: this.language,
            errinfo: this.results[this.results.length - 1].status,
            to_save: this.saveCode,
            prefix: this.pretext,
            suffix: this.suffix,
            partner: this.partner,
        }; // Log the run event
        if (typeof sid !== "undefined") {
            data.sid = sid;
        }
        await this.logRunEvent(data);

        if (this.unit_results) {
            let unitData = {
                event: "unittest",
                div_id: this.divid,
                course: eBookConfig.course,
                act: this.unit_results,
            };
            if (typeof sid !== "undefined") {
                unitData.sid = sid;
            }
            await this.logBookEvent(unitData);
        }
    }

    renderFeedback() {
        if (this.testResult) {
            $(this.output).text(this.testResult);
            $(this.output).css("visibility", "visible");
        }
    }

    autograde(result_table) {
        var tests = this.suffix.split(/\n/);
        this.passed = 0;
        this.failed = 0;
        // Tests should be of the form
        // assert row,col oper value for example
        // assert 4,4 == 3
        var result = "";
        tests = tests.filter(function (s) {
            return s.indexOf("assert") > -1;
        });
        for (let test of tests) {
            let wlist = test.split(/\s+/);
            wlist.shift();
            let loc = wlist.shift();
            let oper = wlist.shift();
            let expected = wlist.join(" ");
            let [row, col] = loc.split(",");
            result += this.testOneAssert(
                row,
                col,
                oper,
                expected,
                result_table
            );
            result += "\n";
        }
        let pct = (100 * this.passed) / (this.passed + this.failed);
        if (isNaN(pct)) {
            pct = 0.0;
        }
        pct = pct.toLocaleString(undefined, { maximumFractionDigits: 2 });
        result += `You passed ${this.passed} out of ${
            this.passed + this.failed
        } tests for ${pct}%`;
        this.unit_results = `percent:${pct}:passed:${this.passed}:failed:${this.failed}`;
        return result;
    }
    testOneAssert(row, col, oper, expected, result_table) {
        // make sure row and col are in bounds
        let actual;
        let output = "";
        try {
            actual = result_table.values[row][col];
        } catch (e) {
            output = `Failed Not enough data to check row ${row} or column ${col}`;
            this.failed++;
            return output;
        }
        const operators = {
            "==": function (operand1, operand2) {
                return operand1 == operand2;
            },
            "!=": function (operand1, operand2) {
                return operand1 != operand2;
            },
            ">": function (operand1, operand2) {
                return operand1 > operand2;
            },
            "<": function (operand1, operand2) {
                return operand1 > operand2;
            },
        };
        let res = operators[oper](actual, expected);
        if (res) {
            output = `Pass: ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.passed++;
        } else {
            output = `Failed ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.failed++;
        }
        return output;
    }
}

function createTable(tableData, container, maxHeight) {
    let data = tableData.values;
    let trimRows = undefined;
    if (data.length === 0) {
        // kludge: no column headers will show up unless we do this
        data = [tableData.columns.map((e) => null)];
        trimRows = [0];
    }

    var hot = new handsontable__WEBPACK_IMPORTED_MODULE_1__["default"](container, {
        data: data,
        trimRows: trimRows,
        width: "100%",
        height: maxHeight,
        autoRowSize: true,
        autoColumnSize: { useHeaders: true },
        rowHeaders: false,
        colHeaders: tableData.columns,
        editor: false,
        maxRows: 100,
        filters: false,
        dropdownMenu: false,
        licenseKey: "non-commercial-and-evaluation",
    });

    // calculate actual height and resize
    let actualHeight = 40; // header height + small margin
    if (tableData.values.length > 0) {
        for (let i = 0; i < data.length; i++) {
            actualHeight = actualHeight + hot.getRowHeight(i);
            if (actualHeight > maxHeight) break;
        }
    }

    hot.updateSettings({ height: actualHeight });

    return hot;
}


/***/ }),

/***/ 27350:
/*!**********************************************!*\
  !*** ./runestone/activecode/js/audiotour.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioTour)
/* harmony export */ });
/* harmony import */ var _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/js/runestonebase.js */ 2568);


// function to display the audio tours
class AudioTour extends _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(divid, code, bnum, audio_text) {
        // Bug Fix: If a class extends another class, this is undefined UNTIL super is called
        super();
        this.audio_tour = null;
        this.audio_code = null;
        this.windowcode = null;
        this.first_audio = null;
        this.prev_audio = null;
        this.pause_audio = null;
        this.next_audio = null;
        this.last_audio = null;
        this.status = null;
        this.stop_button = null;
        this.tourButtons = [];
        this.elem = null; // current audio element playing
        this.currIndex = null; // current index
        this.len = null; // current length of audio files for tour
        this.buttonCount = null; // number of audio tour buttons
        this.aname = null; // the audio file name
        this.ahash = null; // hash of the audio file name to the lines to highlight
        this.theDivid = null; // div id
        this.afile = null; // file name for audio
        this.playing = false; // flag to say if playing or not
        this.tourName = "";
        // Replacing has been done here to make sure special characters in the code are displayed correctly
        code = code.replaceAll("*doubleq*", '"');
        code = code.replaceAll("*singleq*", "'");
        code = code.replaceAll("*open*", "(");
        code = code.replaceAll("*close*", ")");
        code = code.replaceAll("*nline*", "<br/>");
        var codeArray = code.split("\n");
        var audio_hash = [];
        var bval = [];
        var atype = audio_text.replaceAll("*doubleq*", '"');
        var audio_type = atype.split("*atype*");
        for (let i = 0; i < audio_type.length - 1; i++) {
            audio_hash[i] = audio_type[i];
            var aword = audio_type[i].split(";");
            bval.push(aword[0]);
        }
        var first =
            "<pre><div id='" +
            divid +
            "_l1'>" +
            "1.   " +
            codeArray[0] +
            "</div>";
        var num_lines = codeArray.length;
        for (let i = 1; i < num_lines; i++) {
            if (i < 9) {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ".   " +
                    codeArray[i] +
                    "</div>";
            } else if (i < 99) {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ".  " +
                    codeArray[i] +
                    "</div>";
            } else {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ". " +
                    codeArray[i] +
                    "</div>";
            }
        }
        first = first + "</pre>";
        //laying out the HTML content
        var bcount = 0;
        for (var i = 0; i < audio_type.length - 1; i++) {
            var newButton = document.createElement("button");
            newButton.className = "btn btn-success";
            newButton.innerHTML = bval[i].replace(/\"/g, "");
            this.tourButtons.push(newButton);
            bcount++;
        }
        this.audio_tour = document.createElement("div");
        this.audio_tour.align = "center";
        this.audio_code = document.createElement("p");
        this.windowcode = document.createElement("div");
        this.windowcode.align = "left";
        $(this.windowcode).html(first);
        this.first_audio = document.createElement("button");
        this.prev_audio = document.createElement("button");
        this.pause_audio = document.createElement("button");
        this.next_audio = document.createElement("button");
        this.last_audio = document.createElement("button");
        this.first_audio.className =
            "btn-default glyphicon glyphicon-fast-backward";
        this.prev_audio.className =
            "btn-default glyphicon glyphicon-step-backward";
        this.pause_audio.className = "btn-default glyphicon glyphicon-pause";
        this.next_audio.className =
            "btn-default glyphicon glyphicon-step-forward";
        this.last_audio.className =
            "btn-default glyphicon glyphicon-fast-forward";
        this.first_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.prev_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.pause_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.next_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.last_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.first_audio.name = "first_audio";
        this.prev_audio.name = "prev_audio";
        this.pause_audio.name = "pause_audio";
        this.next_audio.name = "next_audio";
        this.last_audio.name = "last_audio";
        this.first_audio.title = "Play first audio in tour";
        this.prev_audio.title = "Play previous audio in tour";
        this.pause_audio.title = "Pause current audio";
        this.next_audio.title = "Play next audio in tour";
        this.last_audio.title = "Play last audio in tour";
        this.first_audio.setAttribute("aria-label", "Play first audio in tour");
        this.prev_audio.setAttribute(
            "aria-label",
            "Play previous audio in tour"
        );
        this.pause_audio.setAttribute("aria-label", "Pause audio");
        this.next_audio.setAttribute("aria-label", "Play next audio in tour");
        this.last_audio.setAttribute("aria-label", "Play last audio in tour");
        this.first_audio.disabled = true;
        this.prev_audio.disabled = true;
        this.pause_audio.disabled = true;
        this.next_audio.disabled = true;
        this.last_audio.disabled = true;
        this.status = document.createElement("div");
        this.status.className = "alert alert-info";
        this.status.setAttribute("style", "display: none;");
        this.stop_button = document.createElement("button");
        this.stop_button.className = "btn btn-default";
        this.stop_button.innerHTML = "Stop tour";
        $(this.audio_tour).append(
            this.audio_code,
            this.windowcode,
            document.createElement("br"),
            this.first_audio,
            this.prev_audio,
            this.pause_audio,
            this.next_audio,
            this.last_audio,
            document.createElement("br"),
            this.status,
            document.createElement("br"),
            this.tourButtons,
            this.stop_button
        );
        $("#" + divid + " .ac_code_div").append(this.audio_tour);
        $("#" + divid + " .ac_code_div").css("width", "100%");
        $("#" + divid + " .CodeMirror.cm-s-default.ui-resizable").hide();
        $("#" + divid + " .ac_opt.btn.btn-default:last-child").hide();
        $(this.stop_button).click(
            function () {
                if (this.playing) {
                    this.elem.pause();
                }
                //log change to db
                this.logBookEvent({
                    event: "Audio",
                    act: "closeWindow",
                    div_id: divid,
                });
                $(this.audio_tour).remove();
                $(
                    "#" + divid + " .CodeMirror.cm-s-default.ui-resizable"
                ).show();
                $("#" + divid + " .ac_opt.btn.btn-default:last-child").show();
                $("#" + divid + " .ac_code_div").css("width", "");
            }.bind(this)
        );
        $(this.tourButtons[0]).click(
            function () {
                this.tour(divid, audio_hash[0], bcount);
            }.bind(this)
        );
        $(this.tourButtons[1]).click(
            function () {
                this.tour(divid, audio_hash[1], bcount);
            }.bind(this)
        );
        $(this.tourButtons[2]).click(
            function () {
                this.tour(divid, audio_hash[2], bcount);
            }.bind(this)
        );
        $(this.tourButtons[3]).click(
            function () {
                this.tour(divid, audio_hash[3], bcount);
            }.bind(this)
        );
        $(this.tourButtons[4]).click(
            function () {
                this.tour(divid, audio_hash[4], bcount);
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.first_audio).click(
            function () {
                this.firstAudio();
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.prev_audio).click(
            function () {
                this.prevAudio();
            }.bind(this)
        );
        // handle the click to pause or play the audio
        $(this.pause_audio).click(
            function () {
                this.pauseAndPlayAudio(divid);
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.next_audio).click(
            function () {
                this.nextAudio();
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.last_audio).click(
            function () {
                this.lastAudio();
            }.bind(this)
        );
        // make the image buttons look disabled
        $(this.first_audio).css("opacity", 0.25);
        $(this.prev_audio).css("opacity", 0.25);
        $(this.pause_audio).css("opacity", 0.25);
        $(this.next_audio).css("opacity", 0.25);
        $(this.last_audio).css("opacity", 0.25);
    }
    tour(divid, audio_type, bcount) {
        // set globals
        this.buttonCount = bcount;
        this.theDivid = divid;
        this.status.setAttribute(
            "style",
            "display: inline-block; margin-top: 7px; margin-bottom: 3px;"
        );
        // enable prev, pause/play and next buttons and make visible
        $(this.first_audio).removeAttr("disabled");
        $(this.prev_audio).removeAttr("disabled");
        $(this.pause_audio).removeAttr("disabled");
        $(this.next_audio).removeAttr("disabled");
        $(this.last_audio).removeAttr("disabled");
        $(this.first_audio).css("opacity", 1.0);
        $(this.prev_audio).css("opacity", 1.0);
        $(this.pause_audio).css("opacity", 1.0);
        $(this.next_audio).css("opacity", 1.0);
        $(this.last_audio).css("opacity", 1.0);
        // disable tour buttons
        for (var i = 0; i < bcount; i++)
            $(this.tourButtons[i]).attr("disabled", "disabled");
        var atype = audio_type.split(";");
        var name = atype[0].replaceAll('"', " ");
        this.tourName = name;
        $(this.status).html($.i18n("msg_activecode_starting", name));
        //log tour type to db
        this.logBookEvent({ event: "Audio", act: name, div_id: divid });
        var max = atype.length;
        var str = "";
        this.ahash = [];
        this.aname = [];
        for (i = 1; i < max - 1; i++) {
            var temp = atype[i].split(":");
            var temp_line = temp[0];
            var temp_aname = temp[1];
            var akey = temp_aname.substring(1, temp_aname.length);
            var lnums = temp_line.substring(1, temp_line.length);
            //alert("akey:"+akey+"lnum:"+lnums);
            // str+="<audio id="+akey+" preload='auto'><source src='http://ice-web.cc.gatech.edu/ce21/audio/"+
            // akey+".mp3' type='audio/mpeg'><source src='http://ice-web.cc.gatech.edu/ce21/audio/"+akey+
            // ".ogg' type='audio/ogg'>Your browser does not support the audio tag</audio>";
            //var dir =
            //    "http://media.interactivepython.org/" +
            //    eBookConfig.basecourse.toLowerCase() +
            //    "/audio/";
            var dir = "../_static/audio/"
            str += "<audio id=" + akey + " preload='auto' >";
            str += "<source src='" + dir + akey + ".wav' type='audio/wav'>";
            str += "<source src='" + dir + akey + ".mp3' type='audio/mpeg'>";
            str += "<source src='" + dir + akey + ".wav' type='audio/wav'>";
            str += "<source src='" + dir + akey + ".mp3' type='audio/mpeg'>";
            str += "<br />Your browser does not support the audio tag</audio>";
            this.ahash[akey] = lnums;
            this.aname.push(akey);
        }
        $(this.audio_code).html(str);
        this.len = this.aname.length; // set the number of audio file in the tour
        this.currIndex = 0;
        this.playCurrIndexAudio();
    }
    handlePlaying() {
        this.elem.pause();
        // unbind current ended
        $("#" + this.afile).unbind("ended");
        // unhighlight the prev lines
        this.unhighlightLines(
            this.theDivid,
            this.ahash[this.aname[this.currIndex]]
        );
    }
    firstAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "first",
            div_id: this.theDivid,
        });
        // move to the first audio
        this.currIndex = 0;
        // start at the first audio
        this.playCurrIndexAudio();
    }
    prevAudio() {
        // if there is a previous audio
        if (this.currIndex > 0) {
            // if audio is this.playing handle it
            this.handlePlaying();
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "prev",
                div_id: this.theDivid,
            });
            // move to previous to the current (but the current index has moved to the next)
            this.currIndex = this.currIndex - 1;
            // start at the prev audio
            this.playCurrIndexAudio();
        }
    }
    nextAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "next",
            div_id: this.theDivid,
        });
        // if not at the end
        if (this.currIndex < this.len - 1) {
            // start at the next audio
            this.currIndex = this.currIndex + 1;
            this.playCurrIndexAudio();
        } else if (this.currIndex == this.len - 1) {
            this.handleTourEnd();
        }
    }
    lastAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "last",
            div_id: this.theDivid,
        });
        // move to the last audio
        this.currIndex = this.len - 1;
        // start at last
        this.playCurrIndexAudio();
    }
    // play the audio at the current index
    playCurrIndexAudio() {
        // set this.playing to false
        this.playing = false;
        // play the current audio and highlight the lines
        this.playaudio(this.currIndex, this.aname, this.theDivid, this.ahash);
    }
    // handle the end of the tour
    handleTourEnd() {
        $(this.status).html("The " + this.tourName + " has ended.");
        this.pause_audio.className = "btn-default glyphicon glyphicon-pause";
        this.pause_audio.title = "Pause audio";
        this.pause_audio.setAttribute("aria-label", "Pause audio");
        $(this.first_audio).attr("disabled", "disabled");
        $(this.prev_audio).attr("disabled", "disabled");
        $(this.pause_audio).attr("disabled", "disabled");
        $(this.next_audio).attr("disabled", "disabled");
        $(this.last_audio).attr("disabled", "disabled");
        $(this.first_audio).css("opacity", 0.25);
        $(this.prev_audio).css("opacity", 0.25);
        $(this.pause_audio).css("opacity", 0.25);
        $(this.next_audio).css("opacity", 0.25);
        $(this.last_audio).css("opacity", 0.25);
        // enable the tour buttons
        for (var j = 0; j < this.buttonCount; j++)
            $(this.tourButtons[j]).removeAttr("disabled");
    }
    // only call this one after the first time
    outerAudio() {
        // unbind ended
        $("#" + this.afile).unbind("ended");
        // set this.playing to false
        this.playing = false;
        // unhighlight previous lines from the last audio
        this.unhighlightLines(
            this.theDivid,
            this.ahash[this.aname[this.currIndex]]
        );
        // increment the this.currIndex to point to the next one
        this.currIndex++;
        // if the end of the tour reset the buttons
        if (this.currIndex == this.len) {
            this.handleTourEnd();
        }
        // else not done yet so play the next audio
        else {
            // play the audio at the current index
            this.playCurrIndexAudio();
        }
    }
    // play the audio now that it is ready
    playWhenReady(afile, divid, ahash) {
        // unbind current
        $("#" + afile).unbind("canplaythrough");
        this.elem.currentTime = 0;
        this.playing = true;
        //console.log("in playWhenReady " + elem.duration);
        this.highlightLines(divid, ahash[afile]);
        if (
            this.pause_audio.className ===
            "btn-default glyphicon glyphicon-pause"
        ) {
            $(this.status).html(
                $.i18n("msg_activecode_playing", this.tourName)
            );
            $("#" + afile).bind(
                "ended",
                function () {
                    this.outerAudio();
                }.bind(this)
            );
            this.elem.play();
        } else {
            $("#" + afile).bind(
                "ended",
                function () {
                    this.outerAudio();
                }.bind(this)
            );
        }
    }
    // play the audio at the specified index i and set the duration and highlight the lines
    playaudio(i, aname, divid, ahash) {
        this.afile = aname[i];
        this.elem = document.getElementById(this.afile);
        // if this isn't ready to play yet - no duration yet then wait
        //console.log("in playaudio " + elem.duration);
        if (isNaN(this.elem.duration) || this.elem.duration == 0) {
            // set the status
            $(this.status).html($.i18n("msg_activecode_loading_audio"));
            $("#" + this.afile).bind(
                "canplaythrough",
                function () {
                    this.playWhenReady(this.afile, divid, ahash);
                }.bind(this)
            );
        }
        // otherwise it is ready so play it
        else {
            this.playWhenReady(this.afile, divid, ahash);
        }
    }
    // pause if this.playing and play if paused
    pauseAndPlayAudio(divid) {
        var btn = this.pause_audio;
        // if paused and clicked then continue from current
        if (this.elem.paused) {
            // calcualte the time left to play in milliseconds
            let counter = (this.elem.duration - this.elem.currentTime) * 1000;
            this.elem.play(); // start the audio from current spot
            this.pause_audio.className =
                "btn-default glyphicon glyphicon-pause";
            this.pause_audio.title = $.i18n(
                "msg_activecode_pause_current_audio"
            );
            this.pause_audio.setAttribute(
                "aria-label",
                $.i18n("msg_activecode_pause_audio")
            );
            $(this.status).html(
                $.i18n("msg_activecode_playing", this.tourName)
            );
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "play",
                div_id: this.theDivid,
            });
        }
        // if audio was this.playing pause it
        else if (this.playing) {
            this.elem.pause(); // pause the audio
            this.pause_audio.className = "btn-default glyphicon glyphicon-play";
            this.pause_audio.title = $.i18n("msg_activecode_play_paused_audio");
            this.pause_audio.setAttribute(
                "aria-label",
                $.i18n("msg_activecode_play_paused_audio")
            );
            $(this.status).html(
                $.i18n("msg_activecode_audio_paused", this.tourName)
            );
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "pause",
                div_id: this.theDivid,
            });
        }
    }
    // process the lines
    processLines(divid, lnum, color) {
        var comma = lnum.split(",");
        if (comma.length > 1) {
            for (let i = 0; i < comma.length; i++) {
                this.setBackgroundForLines(divid, comma[i], color);
            }
        } else {
            this.setBackgroundForLines(divid, lnum, color);
        }
    }
    // unhighlight the lines - set the background back to transparent
    unhighlightLines(divid, lnum) {
        this.processLines(divid, lnum, "transparent");
    }
    // highlight the lines - set the background to a yellow color
    highlightLines(divid, lnum) {
        this.processLines(divid, lnum, "#ffff99");
    }
    // set the background to the passed color
    setBackgroundForLines(divid, lnum, color) {
        var hyphen = lnum.split("-");
        var str;
        // if a range of lines
        if (hyphen.length > 1) {
            var start = parseInt(hyphen[0]);
            var end = parseInt(hyphen[1]) + 1;
            for (var k = start; k < end; k++) {
                //alert(k);
                str = "#" + divid + "_l" + k;
                if ($(str).text() != "") {
                    $(str).css("background-color", color);
                }
                //$(str).effect("highlight",{},(dur*1000)+4500);
            }
        } else {
            //alert(lnum);
            str = "#" + divid + "_l" + lnum;
            $(str).css("background-color", color);
            //$(str).effect("highlight",{},(dur*1000)+4500);
        }
    }
}


/***/ }),

/***/ 69902:
/*!*******************************************************!*\
  !*** ./runestone/activecode/js/extractUnitResults.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JUnitTestParser)
/* harmony export */ });
var testString = `Starting Tests
Expected: Answer                   Actual: Answer                   Message: Checking method printAnswer()                     Passed: true
Expected: 6 line(s) of text        Actual: 0 line(s) of text        Message: Checking main method                              Passed: false
Hello World
Expected: String String            Actual: String String            Message: Checking Instance Variable Type(s)                Passed: true
Expected: Question                 Actual: Question                 Message: Checking method printQuestion()                   Passed: true
Debugging output
More debug output
Expected: 2 Private                Actual: 2 Private                Message: Checking Private Instance Variable(s)             Passed: true
Expected: pass                     Actual: pass                     Message: Checking constructor with parameters              Passed: true
Expected: fail                     Actual: fail                     Message: Checking default constructor                      Passed: true
Ending Tests
You got 6 out of 7 correct. 85.71%`;

class JUnitTestParser {
    constructor(output, parentId) {
        let patt = new RegExp(
            "Expected:\\s+(.*?)Actual:\\s+(.*?)Message:\\s+(.*?)Passed:\\s+(true|false)",
            "g"
        );
        this.textResults = "";
        let matches = output.matchAll(patt);
        let parent = document.createElement("div");
        parent.classList.add("unittest-results");
        let tbl = document.createElement("table");
        tbl.classList.add("ac-feedback");
        parent.appendChild(tbl);
        parent.setAttribute("id", `${parentId}_unit_results`);
        let tr = document.createElement("tr");
        tr.innerHTML =
            '<th class="ac-feedback">Result</th><th class="ac-feedback">Expected</th><th class="ac-feedback">Actual</th><th class="ac-feedback">Notes</th>';
        tbl.appendChild(tr);
        for (const match of matches) {
            let tr = document.createElement("tr");
            let td = document.createElement("td");
            td.classList.add("ac-feedback");
            if (match[match.length - 1] == "true") {
                td.innerHTML = "Pass";
                td.style =
                    "background-color: rgb(131, 211, 130); text-align: center;";
            } else {
                td.innerHTML = "Fail";
                td.style =
                    "background-color: rgb(222, 142, 150); text-align: center;";
            }
            tr.appendChild(td);
            tbl.appendChild(tr);
            for (let i = 1; i < match.length - 1; i++) {
                let td = document.createElement("td");
                td.innerHTML = match[i];
                td.classList.add("ac-feedback");
                tr.appendChild(td);
            }
            tbl.appendChild(tr);
            this.table = parent;
            this.textResults += match[0] + "\n";
            output = output.replace(match[0], "");
        }
        let match = output.match(
            /You got\s+(\d+) out of (\d+) correct.\s+(\d+\.\d+)%/
        );
        if (match) {
            output = output.replace(match[0], "");
            let pctString = document.createElement("span");
            pctString.innerHTML = match[0];
            this.pctString = pctString;
            this.pct = match[3];
            this.passed = match[1];
            this.failed = match[2] - match[1];
        }
        output = output.replace("Starting Tests", "");
        output = output.replace("Ending Tests", "");
        output = output.replace(/\n/g, "<br>");
        output = output.replace(/(<br>)+/g, "<br>");
        output = output.replaceAll("&lt;img", "<img");
        this.stdout = output;
    }
}

// let x = new ResultsToTable(testString);
// console.log(x.stdout);
// console.log(x.table);


/***/ }),

/***/ 45425:
/*!*********************************************!*\
  !*** ./runestone/activecode/js/livecode.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ 64440);
/* harmony import */ var _extractUnitResults_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extractUnitResults.js */ 69902);
/* harmony import */ var _codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../codelens/js/pytutor-embed.bundle.js */ 71951);
/* harmony import */ var _codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3__);





class LiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        var orig = $(opts.orig).find("textarea")[0];
        super(opts);
        this.stdin = $(orig).data("stdin");
        this.datafile = $(orig).data("datafile");
        this.sourcefile = $(orig).data("sourcefile");
        this.compileargs = unescapeHtml($(orig).data("compileargs"));
        this.linkargs = unescapeHtml($(orig).data("linkargs"));
        this.runargs = unescapeHtml($(orig).data("runargs"));
        this.interpreterargs = unescapeHtml($(orig).data("interpreterargs"));
        this.API_KEY = "67033pV7eUUvqo07OJDIV8UZ049aLEK1";
        this.USE_API_KEY = true;
        this.JOBE_SERVER = eBookConfig.jobehost || eBookConfig.host;
        this.resource = eBookConfig.proxyuri_runs || "/runestone/proxy/jobeRun";
        this.jobePutFiles =
            eBookConfig.proxyuri_files || "/runestone/proxy/jobePushFile/";
        this.jobeCheckFiles =
            eBookConfig.proxyuri_files || "/runestone/proxy/jobeCheckFile/";
        // TODO:  should add a proper put/check in pavement.tmpl as this is misleading and will break on runestone
        this.div2id = {};
        if (this.stdin) {
            this.createInputElement();
        }
        this.createErrorOutput();
    }
    outputfun(a) {}
    createInputElement() {
        var label = document.createElement("label");
        label.for = this.divid + "_stdin";
        $(label).text($.i18n("msg_activecode_input_prg"));
        var input = document.createElement("input");
        input.id = this.divid + "_stdin";
        input.type = "text";
        input.size = "35";
        input.value = this.stdin;
        this.outerDiv.appendChild(label);
        this.outerDiv.appendChild(input);
        this.stdin_el = input;
    }
    createErrorOutput() {}

    /*  Main runProg method for livecode
     *
     */
    async runProg(noUI, logResults) {
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        await this.runSetup();
        try {
            let res = await this.submitToJobe();
            if (!res.ok) {
                this.addJobeErrorMessage(
                    $.i18n(`Server Error: ${res.statusText}`)
                );
                $(this.runButton).removeAttr("disabled");
                return "fail";
            }
            let runResults = await res.json();
            this.processJobeResponse(runResults);
        } catch (e) {
            this.addJobeErrorMessage(
                $.i18n("msg_activecode_server_comm_err") + e.toString()
            );
            $(this.runButton).removeAttr("disabled");
            return `fail: ${e}`;
        }
        return "success";
    }
    /**
     * Note:
     * In order to check for supplemental files in java and deal with asynchronicity
     * I split the original runProg into two functions: runProg and runProg_callback
     */
    async runSetup() {
        var stdin;
        var source;
        var saveCode = "True";
        var sfilemap = {
            java: "",
            cpp: "test.cpp",
            c: "test.c",
            python3: "test.py",
            python2: "test.py",
            octave: "octatest.m",
        };
        var sourcefilename = "";
        var testdrivername = "";
        var file_checkp;

        // extract the class names so files can be named properly
        if (this.suffix && this.language == "java") {
            // the suffix contains unit test code and should include and import of junit
            // import static org.junit.Assert.*;
            // import org.junit.*;
            // import java.io.*;
            if (this.suffix.indexOf("import org.junit") <0 ) {
                console.log(`Missing imports in unit tests:
                    ${this.suffix}`);
                // alert("The unit tests for this problem are incomplete, Please report this.");
                this.suffix = `
                import static org.junit.Assert.*;
                import org.junit.*;
                import java.io.*;
                ` + this.suffix;
            }
            let classMatch = new RegExp(/public class\s+(\w+)[\s+{]/);
            source = await this.buildProg(false);
            let m = source.match(classMatch);
            if (m) {
                sourcefilename = m[1] + ".java";
            }
            // this will be unit test code
            m = this.suffix.match(classMatch);
            if (m) {
                testdrivername = m[1] + ".java";
            }
        } else {
            source = await this.buildProg(true);
        }
        // Validate the data is convertible to Base64. If not then error out now
        try {
            btoa(source);
        } catch (e) {
            alert(
                "Error: Bad Characters in the activecode window. Likely a quote character that has been copy/pasted. 🙁"
            );
            return;
        }

        this.saveCode = await this.manage_scrubber(saveCode);

        // assemble parameters for JOBE
        var paramlist = [
            "compileargs",
            "linkargs",
            "runargs",
            "interpreterargs",
            "memorylimit",
        ];
        var paramobj = {};
        for (let param of paramlist) {
            if (this[param]) {
                paramobj[param] = eval(this[param]); // needs a list
            }
        }
        if (this.language === "octave") {
            paramobj.memorylimit = 200000;
        }

        if (this.stdin) {
            stdin = $(this.stdin_el).val();
        }
        if (!this.sourcefile) {
            this.sourcefile = sfilemap[this.language];
        }

        $(this.output).html($.i18n("msg_activecode_compiling_running"));
        var files = [];
        var content, base64;
        if (this.datafile != undefined) {
            var ids = this.datafile.split(",");
            for (var i = 0; i < ids.length; i++) {
                let fileName = ids[i].trim();
                let file = document.getElementById(fileName);
                let fileExtension = fileName.substring(
                    fileName.lastIndexOf(".") + 1
                );
                if (file === null || file === undefined) {
                    // console.log("No file with given id");
                    // check to see if file is in db
                    content = this.fileReader(fileName);
                } else {
                    content = file.textContent;
                    // may be undefined at this point if file is an image
                }
                if (fileExtension === "jar") {
                    files = files.concat(this.parseJavaClasses(content));
                } else if (["jpg", "png", "gif"].indexOf(fileExtension) > -1) {
                    if (file) {
                        if (file.toDataURL) {
                            base64 = file.toDataURL("image/" + fileExtension);
                            base64 = base64.substring(base64.indexOf(",") + 1);
                        } else {
                            base64 = file.src.substring(
                                file.src.indexOf(",") + 1
                            );
                        }
                    } else {
                        base64 = content;
                    }
                    files.push({ name: fileName, content: base64 });
                } else {
                    // if no className or un recognized className it is treated as an individual file
                    // this could be any type of file, .txt, .java, .csv, etc
                    files.push({ name: fileName, content: content });
                }
            }
        }
        // If we are running unit tests we need to substitute the test driver for the student
        // code and send the student code as a file.  We'll do that here.
        this.junitDriverCode = `
        import org.junit.runner.JUnitCore;
        import org.junit.runner.Result;
        import org.junit.runner.notification.Failure;

        public class TestRunner {
            public static void main(String[] args) {
                CodeTestHelper.resetFinalResults();
                Result result = JUnitCore.runClasses(${testdrivername.replace(
                    ".java",
                    ".class"
                )});
                System.out.println(CodeTestHelper.getFinalResults());

                int total = result.getRunCount();
                int fails = result.getFailureCount();
                int corr  = total - fails;
                System.out.println("You got " + corr + " out of " + total + " correct. " + String.format("%.2f", (100.0 * corr / total)) + "%");
            }
        }
        `;
        if (this.suffix && this.language == "java") {
            files.push({ name: sourcefilename, content: source });
            files.push({ name: testdrivername, content: this.suffix });
            source = this.junitDriverCode;
            if (paramobj.compileargs) {
                paramobj.compileargs.push(sourcefilename);
            } else {
                paramobj.compileargs = [sourcefilename];
            }
        }
        let runspec = {
            language_id: this.language,
            sourcecode: source,
            parameters: paramobj,
            sourcefilename: this.sourcefile,
        };

        if (stdin) {
            runspec.input = stdin;
        }
        if (files.length === 0) {
            this.json_runspec = JSON.stringify({ run_spec: runspec });
            file_checkp = Promise.resolve("ready");
        } else {
            runspec["file_list"] = [];
            var promises = [];
            var instance = this;

            for (let i = 0; i < files.length; i++) {
                var fileName = files[i].name;
                var fileContent = files[i].content;
                instance.div2id[fileName] =
                    "runestone" + (0,_md5_js__WEBPACK_IMPORTED_MODULE_1__["default"])(fileName + fileContent);
                runspec["file_list"].push([
                    instance.div2id[fileName],
                    fileName,
                ]);
                promises.push(
                    new Promise((resolve, reject) => {
                        instance.checkFile(files[i], resolve, reject);
                    })
                );
            }
            this.json_runspec = JSON.stringify({ run_spec: runspec });
            this.div2id = instance.div2id;
            file_checkp = Promise.all(promises).catch(function (err) {
                console.log("Error: " + err);
            });
        }
        return file_checkp;
    }

    /* Submit the assembled job to the JOBE server and await the results.
     *
     */
    async submitToJobe() {
        var data = this.json_runspec;
        let host = this.JOBE_SERVER + this.resource;
        $(this.runButton).attr("disabled", "disabled");
        $(this.outDiv).show({ duration: 700, queue: false });
        $(this.errDiv).remove();
        $(this.output).css("visibility", "visible");

        let headers = new Headers({
            "Content-type": "application/json; charset=utf-8",
            Accept: "application/json",
            "X-API-KEY": this.API_KEY,
        });
        let request = new Request(host, {
            method: "POST",
            headers: headers,
            body: data,
        });
        return fetch(request);

        ///$("#" + divid + "_errinfo").remove();
    }

    processJobeResponse(result) {
        var logresult;
        var odiv = this.output;
        this.parsedOutput = {};
        $(this.runButton).removeAttr("disabled");
        if (result.outcome === 15) {
            logresult = "success";
        } else {
            logresult = result.outcome;
        }
        this.errinfo = logresult;
        switch (result.outcome) {
            case 15: {
                this.parsedOutput = new _extractUnitResults_js__WEBPACK_IMPORTED_MODULE_2__["default"](
                    result.stdout,
                    this.divid
                );
                $(odiv).html(this.parsedOutput.stdout);
                if (this.suffix) {
                    if (this.parsedOutput.pct === undefined) {
                        this.parsedOutput.pct =
                            this.parsedOutput.passed =
                            this.parsedOutput.failed =
                                0;
                    }
                    this.unit_results = `percent:${this.parsedOutput.pct}:passed:${this.parsedOutput.passed}:failed:${this.parsedOutput.failed}`;
                }
                break;
            }
            case 11: // compiler error
                $(odiv).html($.i18n("msg_activecode_were_compiling_err"));
                this.addJobeErrorMessage(result.cmpinfo);
                break;
            case 12: // run time error
                $(odiv).html(result.stdout.replace(/\n/g, "<br>"));
                if (result.stderr) {
                    this.addJobeErrorMessage(result.stderr);
                }
                break;
            case 13: // time limit
                $(odiv).html(result.stdout.replace(/\n/g, "<br>"));
                this.addJobeErrorMessage(
                    $.i18n("msg_activecode_time_limit_exc")
                );
                break;
            default:
                if (result.stderr) {
                    $(odiv).html(result.stderr.replace(/\n/g, "<br>"));
                } else {
                    this.addJobeErrorMessage(
                        $.i18n("msg_activecode_server_err")
                    );
                }
        }
        // todo: handle server busy and timeout errors too
    }

    renderFeedback() {
        let rdiv = document.getElementById(`${this.divid}_unit_results`);
        if (rdiv) {
            rdiv.remove();
        }
        if (this.parsedOutput && this.parsedOutput.table) {
            this.outDiv.appendChild(this.parsedOutput.table);
        }
        rdiv = document.getElementById(`${this.divid}_unit_results`);
        if (rdiv) {
            rdiv.appendChild(this.parsedOutput.pctString);
        }
    }

    addJobeErrorMessage(err) {
        var errHead = $("<h3>").html("Error");
        var eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.errDiv = eContainer;
        eContainer.className = "error alert alert-danger";
        eContainer.id = this.divid + "_errinfo";
        eContainer.appendChild(errHead[0]);
        var errText = eContainer.appendChild(document.createElement("pre"));
        errText.innerHTML = err;
    }
    /**
     * Checks to see if file is on server
     * Places it on server if it is not on server
     * @param  {object{name, contents}} file    File to place on server
     * @param  {function} resolve promise resolve function
     * @param  {function} reject  promise reject function
     */
    checkFile(file, resolve, reject) {
        var file_id = this.div2id[file.name];
        var resource = this.jobeCheckFiles + file_id;
        var host = this.JOBE_SERVER + resource;
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", host, true);
        xhr.setRequestHeader("Content-type", "application/json");
        xhr.setRequestHeader("Accept", "text/plain");
        xhr.setRequestHeader("X-API-KEY", this.API_KEY);
        xhr.onerror = function () {
            // console.log("error sending file" + xhr.responseText);
        };
        xhr.onload = function () {
            switch (xhr.status) {
                case 208:
                case 404:
                    // console.log("File not on Server");
                    this.pushDataFile(file, resolve, reject);
                    break;
                case 400:
                    // console.log("Bad Request");
                    reject();
                    break;
                case 204:
                    // console.log("File already on Server");
                    resolve();
                    break;
                default:
                    //console.log("This case should never happen");
                    reject();
            }
        }.bind(this);
        xhr.send();
    }
    /**
     * Places a file on a server
     */
    pushDataFile(file, resolve, reject) {
        var fileName = file.name;
        var extension = fileName.substring(fileName.indexOf(".") + 1);
        var file_id = this.div2id[fileName];
        var contents = file.content;
        // File types being uploaded that come in already in base64 format
        var extensions = ["jar", "zip", "png", "jpg", "jpeg"];
        var contentsb64;
        if (extensions.indexOf(extension) === -1) {
            contentsb64 = btoa(contents);
        } else {
            contentsb64 = contents;
        }
        var data = JSON.stringify({ file_contents: contentsb64 });
        var resource = this.jobePutFiles + file_id;
        var host = this.JOBE_SERVER + resource;
        var xhr = new XMLHttpRequest();
        xhr.open("PUT", host, true);
        xhr.setRequestHeader("Content-type", "application/json");
        xhr.setRequestHeader("Accept", "text/plain");
        xhr.setRequestHeader("X-API-KEY", this.API_KEY);
        xhr.onload = function () {
            switch (xhr.status) {
                case 403:
                    // console.log("Forbidden");
                    reject();
                    break;
                case 400:
                    // console.log("Bad Request");
                    reject();
                    break;
                case 204:
                    //console.log("successfully sent file " + xhr.responseText);
                    //console.log("File " + fileName +", " + file_id +" placed on server");
                    resolve();
                    break;
                default:
                    // console.log("This case should never happen");
                    reject();
            }
        }.bind(this);
        xhr.onerror = function () {
            // console.log("error sending file" + xhr.responseText);
            reject();
        };
        xhr.send(data);
    }

    async showCodelens() {
        let clMess = "";
        if (this.codelens.style.display == "none") {
            this.codelens.style.display = "block";
            clMess = "Building your visualization";
            this.codelens.innerHTML = clMess;
            this.clButton.innerText = $.i18n("msg_activecode_hide_codelens");
        } else {
            this.codelens.style.display = "none";
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
            return;
        }
        var cl = this.codelens.firstChild;
        if (cl) {
            this.codelens.removeChild(cl);
            this.codelens.innerHTML = clMess;
        }
        var code = await this.buildProg(false);
        if (code.match(/System.exit/)) {
            alert(
                "Sorry... System.exit breaks the visualizer temporarily removing"
            );
            code = code.replace(/System.exit\(\d+\);/, "");
        }
        var myVars = {};
        myVars.code = code;
        myVars.lang = this.language;
        if (this.stdin) {
            myVars.stdin = $(this.stdin_el).val();
        }
        var targetDiv = this.codelens.id;

        let request = new Request("/runestone/proxy/pytutor_trace", {
            method: "POST",
            body: JSON.stringify(myVars),
            headers: this.jsonHeaders,
        });
        try {
            let response = await fetch(request);
            let data = await response.json();
            let vis = addVisualizerToPage(data, targetDiv, {
                startingInstruction: 0,
                editCodeBaseURL: null,
                hideCode: false,
                lang: myVars.lang,
            });
        } catch (error) {
            let targetDivError = document.getElementById(targetDiv);
            targetDivError.innerHTML =
                "Sorry, an error occurred while creating your visualization.";
            console.log("Get Trace Failed -- ");
            console.log(error);
        }

        this.logBookEvent({
            event: "codelens",
            act: "view",
            div_id: this.divid,
        });
    }

    /**
     * Seperates text into multiple .java files
     * @param  {String} text String with muliple java classes needed to be seperated
     * @return {array of objects}  .name gives the name of the java file with .java extension
     *                   .content gives the contents of the file
     */
    parseJavaClasses(text) {
        text = text.trim();
        var found = false;
        var stack = 0;
        var startIndex = 0;
        var classes = [];
        var importIndex = 0;
        var endOfLastCommentBeforeClassBegins = 0;
        for (var i = 0; i < text.length; i++) {
            var char = text.charAt(i);
            if (char === "/") {
                i++;
                if (text.charAt(i) === "/") {
                    i++;
                    while (text.charAt(i) !== "\n" && i < text.length) {
                        i++;
                    }
                    if (!found) {
                        endOfLastCommentBeforeClassBegins = i;
                    }
                } else if (text.charAt(i) == "*") {
                    i++;
                    while (
                        (text.charAt(i) !== "*" ||
                            text.charAt(i + 1) !== "/") &&
                        i + 1 < text.length
                    ) {
                        i++;
                    }
                    if (!found) {
                        endOfLastCommentBeforeClassBegins = i;
                    }
                }
            } else if (char === '"') {
                i++;
                while (text.charAt(i) !== '"' && i < text.length) {
                    i++;
                }
            } else if (char === "'") {
                while (text.charAt(i) !== "'" && i < text.length) {
                    i++;
                }
            } else if (char === "(") {
                var pCount = 1;
                i++;
                while (pCount > 0 && i < text.length) {
                    if (text.charAt(i) === "(") {
                        pCount++;
                    } else if (text.charAt(i) === ")") {
                        pCount--;
                    }
                    i++;
                }
            }
            if (!found && text.charAt(i) === "{") {
                startIndex = i;
                found = true;
                stack = 1;
            } else if (found) {
                if (text.charAt(i) === "{") {
                    stack++;
                }
                if (text.charAt(i) === "}") {
                    stack--;
                }
            }
            if (found && stack === 0) {
                let endIndex = i + 1;
                var words = text
                    .substring(endOfLastCommentBeforeClassBegins, startIndex)
                    .trim()
                    .split(" ");
                var className = "";
                for (var w = 0; w < words.length; w++) {
                    className = words[w];
                    if (words[w] === "extends" || words[w] === "implements") {
                        className = words[w - 1];
                        w = words.length;
                    }
                }
                className = className.trim() + ".java";
                classes.push({
                    name: className,
                    content: text.substring(importIndex, endIndex),
                });
                found = false;
                importIndex = endIndex;
                endOfLastCommentBeforeClassBegins = endIndex;
            }
        }
        return classes;
    }
}
function unescapeHtml(safe) {
    if (safe) {
        return safe
            .replace(/&amp;/g, "&")
            .replace(/&lt;/g, "<")
            .replace(/&gt;/g, ">")
            .replace(/&quot;/g, '"')
            .replace(/&#x27;/g, "'");
    }
}


/***/ }),

/***/ 64440:
/*!****************************************!*\
  !*** ./runestone/activecode/js/md5.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MD5)
/* harmony export */ });
/**
 *
 *  MD5 (Message-Digest Algorithm)
 *  http://www.webtoolkit.info/
 *
 **/

function MD5(string) {
    function RotateLeft(lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    }

    function AddUnsigned(lX, lY) {
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = lX & 0x80000000;
        lY8 = lY & 0x80000000;
        lX4 = lX & 0x40000000;
        lY4 = lY & 0x40000000;
        lResult = (lX & 0x3fffffff) + (lY & 0x3fffffff);
        if (lX4 & lY4) {
            return lResult ^ 0x80000000 ^ lX8 ^ lY8;
        }
        if (lX4 | lY4) {
            if (lResult & 0x40000000) {
                return lResult ^ 0xc0000000 ^ lX8 ^ lY8;
            } else {
                return lResult ^ 0x40000000 ^ lX8 ^ lY8;
            }
        } else {
            return lResult ^ lX8 ^ lY8;
        }
    }

    function F(x, y, z) {
        return (x & y) | (~x & z);
    }

    function G(x, y, z) {
        return (x & z) | (y & ~z);
    }

    function H(x, y, z) {
        return x ^ y ^ z;
    }

    function I(x, y, z) {
        return y ^ (x | ~z);
    }

    function FF(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function GG(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function HH(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function II(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function ConvertToWordArray(string) {
        var lWordCount;
        var lMessageLength = string.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 =
            (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount < lMessageLength) {
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] =
                lWordArray[lWordCount] |
                (string.charCodeAt(lByteCount) << lBytePosition);
            lByteCount++;
        }
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] =
            lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
    }

    function WordToHex(lValue) {
        var WordToHexValue = "",
            WordToHexValue_temp = "",
            lByte,
            lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
            lByte = (lValue >>> (lCount * 8)) & 255;
            WordToHexValue_temp = "0" + lByte.toString(16);
            WordToHexValue =
                WordToHexValue +
                WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        }
        return WordToHexValue;
    }

    function Utf8Encode(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if (c > 127 && c < 2048) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }

        return utftext;
    }

    var x = Array();
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7,
        S12 = 12,
        S13 = 17,
        S14 = 22;
    var S21 = 5,
        S22 = 9,
        S23 = 14,
        S24 = 20;
    var S31 = 4,
        S32 = 11,
        S33 = 16,
        S34 = 23;
    var S41 = 6,
        S42 = 10,
        S43 = 15,
        S44 = 21;

    string = Utf8Encode(string);

    x = ConvertToWordArray(string);

    a = 0x67452301;
    b = 0xefcdab89;
    c = 0x98badcfe;
    d = 0x10325476;

    for (k = 0; k < x.length; k += 16) {
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = FF(a, b, c, d, x[k + 0], S11, 0xd76aa478);
        d = FF(d, a, b, c, x[k + 1], S12, 0xe8c7b756);
        c = FF(c, d, a, b, x[k + 2], S13, 0x242070db);
        b = FF(b, c, d, a, x[k + 3], S14, 0xc1bdceee);
        a = FF(a, b, c, d, x[k + 4], S11, 0xf57c0faf);
        d = FF(d, a, b, c, x[k + 5], S12, 0x4787c62a);
        c = FF(c, d, a, b, x[k + 6], S13, 0xa8304613);
        b = FF(b, c, d, a, x[k + 7], S14, 0xfd469501);
        a = FF(a, b, c, d, x[k + 8], S11, 0x698098d8);
        d = FF(d, a, b, c, x[k + 9], S12, 0x8b44f7af);
        c = FF(c, d, a, b, x[k + 10], S13, 0xffff5bb1);
        b = FF(b, c, d, a, x[k + 11], S14, 0x895cd7be);
        a = FF(a, b, c, d, x[k + 12], S11, 0x6b901122);
        d = FF(d, a, b, c, x[k + 13], S12, 0xfd987193);
        c = FF(c, d, a, b, x[k + 14], S13, 0xa679438e);
        b = FF(b, c, d, a, x[k + 15], S14, 0x49b40821);
        a = GG(a, b, c, d, x[k + 1], S21, 0xf61e2562);
        d = GG(d, a, b, c, x[k + 6], S22, 0xc040b340);
        c = GG(c, d, a, b, x[k + 11], S23, 0x265e5a51);
        b = GG(b, c, d, a, x[k + 0], S24, 0xe9b6c7aa);
        a = GG(a, b, c, d, x[k + 5], S21, 0xd62f105d);
        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = GG(c, d, a, b, x[k + 15], S23, 0xd8a1e681);
        b = GG(b, c, d, a, x[k + 4], S24, 0xe7d3fbc8);
        a = GG(a, b, c, d, x[k + 9], S21, 0x21e1cde6);
        d = GG(d, a, b, c, x[k + 14], S22, 0xc33707d6);
        c = GG(c, d, a, b, x[k + 3], S23, 0xf4d50d87);
        b = GG(b, c, d, a, x[k + 8], S24, 0x455a14ed);
        a = GG(a, b, c, d, x[k + 13], S21, 0xa9e3e905);
        d = GG(d, a, b, c, x[k + 2], S22, 0xfcefa3f8);
        c = GG(c, d, a, b, x[k + 7], S23, 0x676f02d9);
        b = GG(b, c, d, a, x[k + 12], S24, 0x8d2a4c8a);
        a = HH(a, b, c, d, x[k + 5], S31, 0xfffa3942);
        d = HH(d, a, b, c, x[k + 8], S32, 0x8771f681);
        c = HH(c, d, a, b, x[k + 11], S33, 0x6d9d6122);
        b = HH(b, c, d, a, x[k + 14], S34, 0xfde5380c);
        a = HH(a, b, c, d, x[k + 1], S31, 0xa4beea44);
        d = HH(d, a, b, c, x[k + 4], S32, 0x4bdecfa9);
        c = HH(c, d, a, b, x[k + 7], S33, 0xf6bb4b60);
        b = HH(b, c, d, a, x[k + 10], S34, 0xbebfbc70);
        a = HH(a, b, c, d, x[k + 13], S31, 0x289b7ec6);
        d = HH(d, a, b, c, x[k + 0], S32, 0xeaa127fa);
        c = HH(c, d, a, b, x[k + 3], S33, 0xd4ef3085);
        b = HH(b, c, d, a, x[k + 6], S34, 0x4881d05);
        a = HH(a, b, c, d, x[k + 9], S31, 0xd9d4d039);
        d = HH(d, a, b, c, x[k + 12], S32, 0xe6db99e5);
        c = HH(c, d, a, b, x[k + 15], S33, 0x1fa27cf8);
        b = HH(b, c, d, a, x[k + 2], S34, 0xc4ac5665);
        a = II(a, b, c, d, x[k + 0], S41, 0xf4292244);
        d = II(d, a, b, c, x[k + 7], S42, 0x432aff97);
        c = II(c, d, a, b, x[k + 14], S43, 0xab9423a7);
        b = II(b, c, d, a, x[k + 5], S44, 0xfc93a039);
        a = II(a, b, c, d, x[k + 12], S41, 0x655b59c3);
        d = II(d, a, b, c, x[k + 3], S42, 0x8f0ccc92);
        c = II(c, d, a, b, x[k + 10], S43, 0xffeff47d);
        b = II(b, c, d, a, x[k + 1], S44, 0x85845dd1);
        a = II(a, b, c, d, x[k + 8], S41, 0x6fa87e4f);
        d = II(d, a, b, c, x[k + 15], S42, 0xfe2ce6e0);
        c = II(c, d, a, b, x[k + 6], S43, 0xa3014314);
        b = II(b, c, d, a, x[k + 13], S44, 0x4e0811a1);
        a = II(a, b, c, d, x[k + 4], S41, 0xf7537e82);
        d = II(d, a, b, c, x[k + 11], S42, 0xbd3af235);
        c = II(c, d, a, b, x[k + 2], S43, 0x2ad7d2bb);
        b = II(b, c, d, a, x[k + 9], S44, 0xeb86d391);
        a = AddUnsigned(a, AA);
        b = AddUnsigned(b, BB);
        c = AddUnsigned(c, CC);
        d = AddUnsigned(d, DD);
    }

    var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);

    return temp.toLowerCase();
}


/***/ }),

/***/ 55409:
/*!**************************************************!*\
  !*** ./runestone/activecode/js/skulpt-stdlib.js ***!
  \**************************************************/
/***/ (() => {

Sk.builtinFiles={"files":{"src/builtin/this.py":"s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint(\"\".join([d.get(c, c) for c in s]))\n","src/lib/BaseHTTPServer.py":"import _sk_fail; _sk_fail._(\"BaseHTTPServer\")\n","src/lib/Bastion.py":"import _sk_fail; _sk_fail._(\"Bastion\")\n","src/lib/CGIHTTPServer.py":"import _sk_fail; _sk_fail._(\"CGIHTTPServer\")\n","src/lib/ConfigParser.py":"import _sk_fail; _sk_fail._(\"ConfigParser\")\n","src/lib/Cookie.py":"import _sk_fail; _sk_fail._(\"Cookie\")\n","src/lib/DocXMLRPCServer.py":"import _sk_fail; _sk_fail._(\"DocXMLRPCServer\")\n","src/lib/HTMLParser.py":"import _sk_fail; _sk_fail._(\"HTMLParser\")\n","src/lib/MimeWriter.py":"import _sk_fail; _sk_fail._(\"MimeWriter\")\n","src/lib/Queue.py":"import _sk_fail; _sk_fail._(\"Queue\")\n","src/lib/SimpleHTTPServer.py":"import _sk_fail; _sk_fail._(\"SimpleHTTPServer\")\n","src/lib/SimpleXMLRPCServer.py":"import _sk_fail; _sk_fail._(\"SimpleXMLRPCServer\")\n","src/lib/SocketServer.py":"import _sk_fail; _sk_fail._(\"SocketServer\")\n","src/lib/StringIO.py":"r\"\"\"File-like objects that read from or write to a string buffer.\n\nThis implements (nearly) all stdio methods.\n\nf = StringIO()      # ready for writing\nf = StringIO(buf)   # ready for reading\nf.close()           # explicitly release resources held\nflag = f.isatty()   # always false\npos = f.tell()      # get current position\nf.seek(pos)         # set current position\nf.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF\nbuf = f.read()      # read until EOF\nbuf = f.read(n)     # read up to n bytes\nbuf = f.readline()  # read until end of line ('\\n') or EOF\nlist = f.readlines()# list of f.readline() results until EOF\nf.truncate([size])  # truncate file at to at most size (default: current pos)\nf.write(buf)        # write at current position\nf.writelines(list)  # for line in list: f.write(line)\nf.getvalue()        # return whole file's contents as a string\n\nNotes:\n- Using a real file is often faster (but less convenient).\n- There's also a much faster implementation in C, called cStringIO, but\n  it's not subclassable.\n- fileno() is left unimplemented so that code which uses it triggers\n  an exception early.\n- Seeking far beyond EOF and then writing will insert real null\n  bytes that occupy space in the buffer.\n- There's a simple test set (see end of this file).\n\"\"\"\n\n__all__ = [\"StringIO\"]\n\ndef _complain_ifclosed(closed):\n    if closed:\n        raise ValueError(\"I/O operation on closed file\")\n\nclass StringIO:\n    \"\"\"class StringIO([buffer])\n\n    When a StringIO object is created, it can be initialized to an existing\n    string by passing the string to the constructor. If no string is given,\n    the StringIO will start empty.\n\n    The StringIO object can accept either Unicode or 8-bit strings, but\n    mixing the two may take some care. If both are used, 8-bit strings that\n    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause\n    a UnicodeError to be raised when getvalue() is called.\n    \"\"\"\n    def __init__(self, buf = ''):\n        # Force self.buf to be a string or unicode\n        if not isinstance(buf, str):\n            buf = str(buf)\n        self.buf = buf\n        self.len = len(buf)\n        self.buflist = []\n        self.pos = 0\n        self.closed = False\n        self.softspace = 0\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"A file object is its own iterator, for example iter(f) returns f\n        (unless f is closed). When a file is used as an iterator, typically\n        in a for loop (for example, for line in f: print line), the next()\n        method is called repeatedly. This method returns the next input line,\n        or raises StopIteration when EOF is hit.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        r = self.readline()\n        if not r:\n            raise StopIteration\n        return r\n\n    def close(self):\n        \"\"\"Free the memory buffer.\n        \"\"\"\n        if not self.closed:\n            self.closed = True\n            self.buf = None\n            self.pos = None\n\n    def isatty(self):\n        \"\"\"Returns False because StringIO objects are not connected to a\n        tty-like device.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        return False\n\n    def seek(self, pos, mode = 0):\n        \"\"\"Set the file's current position.\n\n        The mode argument is optional and defaults to 0 (absolute file\n        positioning); other values are 1 (seek relative to the current\n        position) and 2 (seek relative to the file's end).\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if mode == 1:\n            pos += self.pos\n        elif mode == 2:\n            pos += self.len\n        self.pos = max(0, pos)\n\n    def tell(self):\n        \"\"\"Return the file's current position.\"\"\"\n        _complain_ifclosed(self.closed)\n        return self.pos\n\n    def read(self, n = -1):\n        \"\"\"Read at most size bytes from the file\n        (less if the read hits EOF before obtaining size bytes).\n\n        If the size argument is negative or omitted, read all data until EOF\n        is reached. The bytes are returned as a string object. An empty\n        string is returned when EOF is encountered immediately.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if n is None or n < 0:\n            newpos = self.len\n        else:\n            newpos = min(self.pos+n, self.len)\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readline(self, length=None):\n        r\"\"\"Read one entire line from the file.\n\n        A trailing newline character is kept in the string (but may be absent\n        when a file ends with an incomplete line). If the size argument is\n        present and non-negative, it is a maximum byte count (including the\n        trailing newline) and an incomplete line may be returned.\n\n        An empty string is returned only when EOF is encountered immediately.\n\n        Note: Unlike stdio's fgets(), the returned string contains null\n        characters ('\\0') if they occurred in the input.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        i = self.buf.find('\\n', self.pos)\n        if i < 0:\n            newpos = self.len\n        else:\n            newpos = i+1\n        if length is not None and length >= 0:\n            if self.pos + length < newpos:\n                newpos = self.pos + length\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readlines(self, sizehint = 0):\n        \"\"\"Read until EOF using readline() and return a list containing the\n        lines thus read.\n\n        If the optional sizehint argument is present, instead of reading up\n        to EOF, whole lines totalling approximately sizehint bytes (or more\n        to accommodate a final whole line).\n        \"\"\"\n        total = 0\n        lines = []\n        line = self.readline()\n        while line:\n            lines.append(line)\n            total += len(line)\n            if 0 < sizehint <= total:\n                break\n            line = self.readline()\n        return lines\n\n    def truncate(self, size=None):\n        \"\"\"Truncate the file's size.\n\n        If the optional size argument is present, the file is truncated to\n        (at most) that size. The size defaults to the current position.\n        The current file position is not changed unless the position\n        is beyond the new file size.\n\n        If the specified size exceeds the file's current size, the\n        file remains unchanged.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if size is None:\n            size = self.pos\n        elif size < 0:\n            raise IOError(22, \"Negative size not allowed\")\n        elif size < self.pos:\n            self.pos = size\n        self.buf = self.getvalue()[:size]\n        self.len = size\n\n    def write(self, s):\n        \"\"\"Write a string to the file.\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if not s: return\n        # Force s to be a string or unicode\n        if not isinstance(s, str):\n            s = str(s)\n        spos = self.pos\n        slen = self.len\n        if spos == slen:\n            self.buflist.append(s)\n            self.len = self.pos = spos + len(s)\n            return\n        if spos > slen:\n            self.buflist.append('\\0'*(spos - slen))\n            slen = spos\n        newpos = spos + len(s)\n        if spos < slen:\n            if self.buflist:\n                self.buf += ''.join(self.buflist)\n            self.buflist = [self.buf[:spos], s, self.buf[newpos:]]\n            self.buf = ''\n            if newpos > slen:\n                slen = newpos\n        else:\n            self.buflist.append(s)\n            slen = newpos\n        self.len = slen\n        self.pos = newpos\n\n    def writelines(self, iterable):\n        \"\"\"Write a sequence of strings to the file. The sequence can be any\n        iterable object producing strings, typically a list of strings. There\n        is no return value.\n\n        (The name is intended to match readlines(); writelines() does not add\n        line separators.)\n        \"\"\"\n        write = self.write\n        for line in iterable:\n            write(line)\n\n    def flush(self):\n        \"\"\"Flush the internal buffer\n        \"\"\"\n        _complain_ifclosed(self.closed)\n\n    def getvalue(self):\n        \"\"\"\n        Retrieve the entire contents of the \"file\" at any time before\n        the StringIO object's close() method is called.\n\n        The StringIO object can accept either Unicode or 8-bit strings,\n        but mixing the two may take some care. If both are used, 8-bit\n        strings that cannot be interpreted as 7-bit ASCII (that use the\n        8th bit) will cause a UnicodeError to be raised when getvalue()\n        is called.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        return self.buf\n","src/lib/UserDict.py":"import _sk_fail; _sk_fail._(\"UserDict\")\n","src/lib/UserList.py":"import _sk_fail; _sk_fail._(\"UserList\")\n","src/lib/UserString.py":"import _sk_fail; _sk_fail._(\"UserString\")\n","src/lib/_LWPCookieJar.py":"import _sk_fail; _sk_fail._(\"_LWPCookieJar\")\n","src/lib/_MozillaCookieJar.py":"import _sk_fail; _sk_fail._(\"_MozillaCookieJar\")\n","src/lib/__future__.py":"import _sk_fail;_sk_fail._(\"__future__\")\n","src/lib/__phello__.foo.py":"import _sk_fail; _sk_fail._(\"__phello__.foo\")\n","src/lib/_abcoll.py":"import _sk_fail; _sk_fail._(\"_abcoll\")\n","src/lib/_sk_fail.py":"class NotImplementedImportError(ImportError, NotImplementedError): pass\n\ndef _(name):\n    msg = \"{} is not yet implemented in Skulpt\".format(name)\n    raise NotImplementedImportError(msg, name=name)\n","src/lib/_threading_local.py":"import _sk_fail; _sk_fail._(\"_threading_local\")\n","src/lib/abc.py":"import _sk_fail; _sk_fail._(\"abc\")\n","src/lib/aifc.py":"import _sk_fail; _sk_fail._(\"aifc\")\n","src/lib/altair/__init__.py":"import random\n\ntry:\n    from vega_caller import render_graph\nexcept:\n    print(\"Mock render\")\n\n    def render_graph(js):\n        print(js)\n\n\nclass Chart:\n    # TODO allow data to be specified as a URL to a CSV or DB or json\n    def __init__(self, data, title=None):\n        self.title = title\n        self.data_id = random.randrange(1000000, 5000000)\n        self.dsname = \"data-{}\".format(self.data_id)\n        if isinstance(data, dict):\n            self.data = Data(**data)\n        else:\n            self.data = data\n\n        self.json = {}\n        self.json[\"$schema\"] = \"https://vega.github.io/schema/vega-lite/v2.5.json\"\n        self.json[\"data\"] = {}\n        if self.title:\n            self.json[\"title\"] = self.title\n\n        self.json[\"data\"] = {\"values\": self.data.vals}\n        self.is_composite = False\n\n    # mark can be a simple string or a dictionary\n    # \"mark\": {\"color\": \"green\", \"opacity\": 0.2, \"type\": \"rect\"}\n\n    def mark_json(self, mark_type, **kwargs):\n        if kwargs:\n            self.json[\"mark\"] = {}\n            self.json[\"mark\"][\"type\"] = mark_type\n            self.json[\"mark\"].update(kwargs)\n        else:\n            self.json[\"mark\"] = mark_type\n\n        return self\n\n    def mark_bar(self, **kwargs):\n        return self.mark_json(\"bar\", **kwargs)\n\n    def mark_point(self, **kwargs):\n        return self.mark_json(\"point\", **kwargs)\n\n    def mark_line(self, **kwargs):\n        return self.mark_json(\"line\", **kwargs)\n\n    def mark_rect(self, **kwargs):\n        return self.mark_json(\"rect\", **kwargs)\n\n    def mark_area(self, **kwargs):\n        return self.mark_json(\"area\", **kwargs)\n\n    def mark_tick(self, **kwargs):\n        return self.mark_json(\"tick\", **kwargs)\n\n    def encode(self, x=\"\", y=\"\", color=\"\", size=\"\", tooltip=\"\"):\n        self.encoding = {}\n        if x:\n            if isinstance(x, Axis):\n                self.encoding[\"x\"] = x.toJson()\n            else:\n                self.encoding[\"x\"] = Axis(x).toJson()\n        if y:\n            if isinstance(y, Axis):\n                self.encoding[\"y\"] = y.toJson()\n            else:\n                self.encoding[\"y\"] = Axis(y).toJson()\n\n        # \"color\": {\"type\": \"nominal\", \"field\": \"species\"}\n        if color:\n            field, tp = _get_name_type(color)\n            self.encoding[\"color\"] = dict(type=tp, field=field)\n\n        # \"size\": {\"type\": \"quantitative\", \"field\": \"Acceleration\"}\n        if size:\n            field, tp = _get_name_type(size)\n            self.encoding[\"size\"] = dict(type=tp, field=field)\n\n        if tooltip:\n            field, tp = _get_name_type(tooltip)\n            self.encoding[\"tooltip\"] = dict(type=tp, field=field)\n\n        self.json[\"encoding\"] = self.encoding\n        return self\n\n    def interactive(self):\n        iconfig = {\n            \"selector002\": {\n                \"type\": \"interval\",\n                \"bind\": \"scales\",\n                \"encodings\": [\"x\", \"y\"],\n                \"on\": \"[mousedown, window:mouseup] > window:mousemove!\",\n                \"translate\": \"[mousedown, window:mouseup] > window:mousemove!\",\n                \"zoom\": \"wheel!\",\n                \"mark\": {\"fill\": \"#333\", \"fillOpacity\": 0.125, \"stroke\": \"white\"},\n                \"resolve\": \"global\",\n            }\n        }\n        self.json[\"selection\"] = iconfig\n        return self\n\n    def display(self):\n        render_graph(self.json)\n\n    def __add__(self, other):\n        return self.add_layer(other, \"layer\")\n\n    def __and__(self, other):\n        return self.add_layer(other, \"vconcat\")\n\n    def __or__(self, other):\n        return self.add_layer(other, \"hconcat\")\n\n    def add_layer(self, other, lname):\n        # multle layers are added by concatenating the new element to the\n        # existing layer.  If the layer does not exist then initialize\n        # it from self.\n        if lname not in self.json:\n            self.json[lname] = []\n            self.json[\"datasets\"] = {}\n            temp = {}\n            temp[\"data\"] = {\"name\": self.dsname}\n            self.json[\"datasets\"][self.dsname] = self.json[\"data\"][\"values\"]\n            del self.json[\"data\"]\n            temp[\"encoding\"] = self.json[\"encoding\"]\n            del self.json[\"encoding\"]\n            temp[\"mark\"] = self.json[\"mark\"]\n            del self.json[\"mark\"]\n            self.json[lname].append(temp)\n        temp = {}\n        self.json[\"datasets\"][other.dsname] = other.json[\"data\"][\"values\"]\n        temp[\"data\"] = {\"name\": other.dsname}\n        temp[\"encoding\"] = other.json[\"encoding\"]\n        temp[\"mark\"] = other.json[\"mark\"]\n        self.json[lname].append(temp)\n        return self\n\n\n#   \"datasets\": {\n#     \"data-e56e43354d9b8f2ab0d1e90cf27cd47f\": [\n#       {\"a\": 4, \"b\": 1, \"c\": \"r\"},\n#       {\"a\": 5, \"b\": 2, \"c\": \"g\"},\n#       {\"a\": 6, \"b\": 3, \"c\": \"b\"}\n#     ],\n#     \"data-a4c3047a15bf9380c2e615cf87648369\": [\n#       {\"a\": 1, \"b\": 4, \"c\": \"r\"},\n#       {\"a\": 2, \"b\": 5, \"c\": \"g\"},\n#       {\"a\": 3, \"b\": 6, \"c\": \"b\"}\n#     ]\n#   }\n\n# TODO:  add a rect mark type for a heat map\n\n\ndef _get_name_type(name):\n    typed = {\"Q\": \"quantitative\", \"O\": \"ordinal\", \"N\": \"nominal\", \"T\": \"temporal\"}\n    nt = name.split(\":\")\n    tstring = \"quantitative\"\n    if len(nt) == 2:\n        tstring = typed[nt[1]]\n    return nt[0], tstring\n\n\nclass Axis:\n    def __init__(self, name, bin=False):\n        self.aggregate = None\n        self.name, self.type = _get_name_type(name)\n        if \"()\" in self.name:  # aggregate function\n            self.aggregate = self.name.replace(\"()\", \"\")\n            self.name = None\n        self.bin = bin\n\n    def toJson(self):\n        json = {}\n        if self.name:\n            json[\"field\"] = self.name\n        if self.type:\n            json[\"type\"] = self.type\n        if self.bin:\n            json[\"bin\"] = True\n        if self.aggregate:\n            json[\"aggregate\"] = self.aggregate\n\n        return json\n\n\nclass X(Axis):\n    pass\n\n\nclass Y(Axis):\n    pass\n\n\nclass Data:\n    def __init__(self, **kwargs):\n        \"\"\"\n        input can be the form of a series of keyword args where\n        the keyword is the column name, or a single keyword data\n        that is a list of json style records as rows.\n        could also accept a csv file? or keywords columns and rows\n        This accepts a lot more options that \"real altair\" to make it easier\n        to work with non-DataFrame data sets.  Internally:\n        self.keys contains the list of column names\n        self.vals is a list of dictionaries of the form [{col1:val1, col2:val2, ... coln:valn},\n                                                         {col1:val3, col2:val4, ... coln:valn},\n                                                         {col1:val5, col2:val6, ... coln:valn}]\n        \"\"\"\n        # todo: accept a URL as the argument to read a CSV or JSON file\n        if len(kwargs) == 1 and \"data\" in kwargs:\n            self.data = kwargs[\"data\"]\n            self.keys = self.data[0].keys()\n            self.vals = self.data\n        elif len(kwargs) == 2 and (\"columns\" in kwargs) and (\"rows\" in kwargs):\n            self.keys = kwargs[\"columns\"]\n            self.vals = []\n            for r in kwargs[\"rows\"]:\n                self.vals.append(dict(zip(self.keys, r)))\n        else:\n            keys = kwargs.keys()\n            vals = []\n            primary_key = list(keys)[0]\n            for ix in range(len(kwargs[primary_key])):\n                d = {}\n                for key in keys:\n                    d[key] = kwargs[key][ix]\n                vals.append(d)\n            self.vals = vals\n            self.keys = keys\n\n    def __str__(self):\n        # header = \"\\t\".join(self.keys) + \"\\n\"\n        header = \"\"\n        for key in self.keys:\n            header += key.center(10) + \" \"\n        header += \"\\n\"\n        template = \"\"\n        for key in self.keys:\n            template += \"{\" + key + \": <10} \"\n        template += \"\\n\"\n        res = \"\"\n        for row in self.vals:\n            res += template.format(**row)\n\n        return header + res\n\n\nif __name__ == \"__main__\":\n    d = Data(a=[3, 4, 5], b=[1, 2, 3], c=[\"r\", \"g\", \"b\"])\n    print(d)\n    print(\n        type(\n            Chart({\"a\": list(\"abc\"), \"b\": [1, 2, 3]}).mark_bar().encode(x=\"a:N\", y=\"b\")\n        )\n    )\n    aa = (\n        Chart(Data(a=[3, 4, 5], b=[1, 2, 3], c=[\"r\", \"g\", \"b\"]))\n        .mark_point(color=\"red\")\n        .encode(x=\"b\", y=\"a\", color=\"c:O\")\n    )\n    print(\"aa = \", aa)\n    aa.display()\n\n    bb = (\n        Chart(Data(a=[1, 2, 3], b=[4, 5, 6], c=[\"r\", \"g\", \"b\"]))\n        .mark_line()\n        .encode(x=\"b\", y=\"a\", color=\"c:O\")\n    )\n    print(\"bb = \", bb)\n    bb.display()\n    print(\"aa+bb\", (aa + bb).display())\n    # Chart(Data(a=[1,2,3,2,2,4,5,5,6,7,8,8,8,8,8,9,0,0])).mark_bar().encode(Axis('a:Q', bin=True),y='count()')\n\n\n# todo: see if I can work with the repr of an object to get the behavior that altair gets in notebooks\n# todo: implement a Bin object to specifiy maxbins\n","src/lib/antigravity.py":"import webbrowser\n\nwebbrowser.open(\"https://xkcd.com/353/\")\n","src/lib/anydbm.py":"import _sk_fail; _sk_fail._(\"anydbm\")\n","src/lib/ast.py":"import _sk_fail; _sk_fail._(\"ast\")\n","src/lib/asynchat.py":"import _sk_fail; _sk_fail._(\"asynchat\")\n","src/lib/asyncore.py":"import _sk_fail; _sk_fail._(\"asyncore\")\n","src/lib/atexit.py":"import _sk_fail; _sk_fail._(\"atexit\")\n","src/lib/audiodev.py":"import _sk_fail; _sk_fail._(\"audiodev\")\n","src/lib/base64.py":"import _sk_fail; _sk_fail._(\"base64\")\n","src/lib/bdb.py":"import _sk_fail; _sk_fail._(\"bdb\")\n","src/lib/binhex.py":"import _sk_fail; _sk_fail._(\"binhex\")\n","src/lib/bisect.py":"\"\"\"Bisection algorithms.\"\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n\ndef bisect_right(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    return lo\n\ndef insort_left(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    a.insert(lo, x)\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    return lo\n\n# Overwrite above definitions with a fast C implementation\ntry:\n    from _bisect import *\nexcept ImportError:\n    pass\n\n# Create aliases\nbisect = bisect_right\ninsort = insort_right\n","src/lib/bsddb/__init__.py":"import _sk_fail; _sk_fail._(\"bsddb\")\n","src/lib/cProfile.py":"import _sk_fail; _sk_fail._(\"cProfile\")\n","src/lib/cgi.py":"import _sk_fail; _sk_fail._(\"cgi\")\n","src/lib/cgitb.py":"import _sk_fail; _sk_fail._(\"cgitb\")\n","src/lib/chunk.py":"import _sk_fail; _sk_fail._(\"chunk\")\n","src/lib/cmd.py":"import _sk_fail; _sk_fail._(\"cmd\")\n","src/lib/code.py":"import _sk_fail; _sk_fail._(\"code\")\n","src/lib/codecs.py":"import _sk_fail; _sk_fail._(\"codecs\")\n","src/lib/codeop.py":"import _sk_fail; _sk_fail._(\"codeop\")\n","src/lib/colorsys.py":"import _sk_fail; _sk_fail._(\"colorsys\")\n","src/lib/commands.py":"import _sk_fail; _sk_fail._(\"commands\")\n","src/lib/compileall.py":"import _sk_fail; _sk_fail._(\"compileall\")\n","src/lib/compiler/__init__.py":"import _sk_fail; _sk_fail._(\"compiler\")\n","src/lib/config/__init__.py":"import _sk_fail; _sk_fail._(\"config\")\n","src/lib/contextlib.py":"import _sk_fail; _sk_fail._(\"contextlib\")\n","src/lib/cookielib.py":"import _sk_fail; _sk_fail._(\"cookielib\")\n","src/lib/copy.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\nimport types\nclass Error(Exception):\n    pass\nerror = Error \nclass _EmptyClass:\n    pass\ntry:\n    long\nexcept NameError:\n    long = int\ntry:\n    bytes\nexcept NameError:\n    bytes = str\n\ndef check_notimplemented_state(x):\n    getstate = getattr(x, \"__getstate__\", None)\n    setstate = getattr(x, \"__setstate__\", None)\n    initargs = getattr(x, \"__getinitargs__\", None)\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n\n\ndef copy(x):\n    cls = type(x)\n    if callable(x):\n        return x\n    copier = getattr(cls, \"__copy__\", None)\n    if copier:\n        return copier(x)\n    if cls in (type(None), int, float, bool, str, bytes, tuple, type, frozenset, long):\n        return x\n    if (cls == list) or (cls == dict) or (cls == set) or (cls == slice):\n        return cls(x)\n    reductor = getattr(x, \"__reduce_ex__\", None)\n    if reductor:\n        rv = reductor(4)\n    else:\n        reductor = getattr(x, \"__reduce__\", None)\n        if reductor:\n            rv = reductor()\n        elif str(cls)[1:6] == \"class\":\n            check_notimplemented_state(x)\n            copier = _copy_inst\n            return copier(x)\n        else:\n            raise Error(\"un(shallow)copyable object of type %s\" % cls)\n    if isinstance(rv, str):\n        return x\n    return _reconstruct(x, rv, 0)\n\ndef _copy_inst(x):\n    if hasattr(x, '__copy__'):\n        return x.__copy__()\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n    return y\n\nd = _deepcopy_dispatch = {}\n\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    idx = id(x)\n    y = memo.get(idx, _nil)\n    if y is not _nil:\n        return y\n    cls = type(x)\n    copier = _deepcopy_dispatch.get(cls)\n    if copier:\n        y = copier(x, memo)\n    else:\n        try:\n            issc = issubclass(cls, type)\n        except TypeError: # cls is not a class (old Boost; see SF #502085)\n            issc = 0\n        if issc:\n            y = _deepcopy_atomic(x, memo)\n        else:\n            copier = getattr(x, \"__deepcopy__\", None)\n            if copier:\n                y = copier(memo)\n            else:\n                reductor = getattr(x, \"__reduce_ex__\", None)\n                if reductor:\n                    rv = reductor(2)\n                else:\n                    rv = None\n                    reductor = getattr(x, \"__reduce__\", None)\n                    if reductor:\n                        rv = reductor()\n                    elif str(cls)[1:6] == \"class\":\n                        check_notimplemented_state(x)\n                        copier = _deepcopy_dispatch[\"InstanceType\"]\n                        y = copier(x, memo)\n                    else:\n                        raise Error(\n                            \"un(deep)copyable object of type %s\" % cls)\n                if rv is not None:\n                    y = _reconstruct(x, rv, 1, memo)\n    memo[idx] = y\n    _keep_alive(x, memo) # Make sure x lives at least as long as d\n    return y\n\ndef _deepcopy_atomic(x, memo):\n    return x\nd[type(None)] = _deepcopy_atomic\n# d[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\n# try:\n# d[types.CodeType] = _deepcopy_atomic\n# except AttributeError:\n#   pass\nd[type] = _deepcopy_atomic\n# d[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\n# d[weakref.ref] = _deepcopy_atomic\n\ndef _deepcopy_list(x, memo):\n    y = []\n    memo[id(x)] = y\n    for a in x:\n        y.append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list\n\ndef _deepcopy_set(x, memo):\n    result = set([])  # make empty set\n    memo[id(x)] = result  # register this set in the memo for loop checking\n    for a in x:   # go through elements of set\n        result.add(deepcopy(a, memo))  # add the copied elements into the new set\n    return result # return the new set\nd[set] = _deepcopy_set\n\ndef _deepcopy_frozenset(x, memo):\n    result = frozenset(_deepcopy_set(x,memo)) \n    memo[id(x)] = result \n    return result\nd[frozenset] = _deepcopy_frozenset\n\ndef _deepcopy_tuple(x, memo):\n    y = [deepcopy(a, memo) for a in x]\n    # We're not going to put the tuple in the memo, but it's still important we\n    # check for it, in case the tuple contains recursive mutable structures.\n    try:\n        return memo[id(x)]\n    except KeyError:\n        pass\n    for k, j in zip(x, y):\n        if k is not j:\n            y = tuple(y)\n            break\n    else:\n        y = x\n    return y\nd[tuple] = _deepcopy_tuple\n\ndef _deepcopy_dict(x, memo):\n    y = {}\n    memo[id(x)] = y\n    for key, value in x.items():\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    return y\nd[dict] = _deepcopy_dict\n\n# def _deepcopy_method(x, memo): # Copy instance methods\n#     y = type(x)(x.im_func, deepcopy(x.im_self, memo), x.im_class);\n#     return y\nd[types.MethodType] = _deepcopy_atomic\n\ndef _deepcopy_inst(x, memo):\n    if hasattr(x, '__deepcopy__'):\n         return x.__deepcopy__(memo)\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        args = deepcopy(args, memo)\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    memo[id(x)] = y\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    state = deepcopy(state, memo)\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n        return y\nd[\"InstanceType\"] = _deepcopy_inst\n\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.\n    We store a reference at the id of the memo, which should\n    normally not be used unless someone tries to deepcopy\n    the memo itself...\n    \"\"\"\n    try:\n        memo[id(memo)].append(x)\n    except KeyError:\n        # aha, this is the first one :-)\n        memo[id(memo)]=[x]\n\ndef _reconstruct(x, info, deep, memo=None):\n    if isinstance(info, str):\n        return x\n    assert isinstance(info, tuple)\n    if memo is None:\n        memo = {}\n    n = len(info)\n    assert n in (2, 3, 4, 5)\n    callable, args = info[:2]\n    if n > 2:\n        state = info[2]\n    else:\n        state = None\n    if n > 3:\n        listiter = info[3]\n    else:\n        listiter = None\n    if n > 4:\n        dictiter = info[4]\n    else:\n        dictiter = None\n    if deep:\n        args = deepcopy(args, memo)\n    y = callable(*args)\n    memo[id(x)] = y\n\n    if state is not None:\n        if deep:\n            state = deepcopy(state, memo)\n        if hasattr(y, '__setstate__'):\n            y.__setstate__(state)\n        else:\n            if isinstance(state, tuple) and len(state) == 2:\n                state, slotstate = state\n            else:\n                slotstate = None\n            if state is not None:\n                y.__dict__.update(state)\n            if slotstate is not None:\n                for key, value in slotstate.items():\n                    setattr(y, key, value)\n\n    if listiter is not None:\n        for item in listiter:\n            if deep:\n                item = deepcopy(item, memo)\n            y.append(item)\n    if dictiter is not None:\n        for key, value in dictiter:\n            if deep:\n                key = deepcopy(key, memo)\n                value = deepcopy(value, memo)\n            y[key] = value\n    return y\n\ndel d\n\ndel types\n\n# Helper for instance creation without calling __init__\nclass _EmptyClass:\n    pass","src/lib/copy_reg.py":"import _sk_fail; _sk_fail._(\"copy_reg\")\n","src/lib/csv.py":"import _sk_fail; _sk_fail._(\"csv\")\n","src/lib/ctypes/__init__.py":"import _sk_fail; _sk_fail._(\"ctypes\")\n","src/lib/ctypes/macholib/__init__.py":"import _sk_fail; _sk_fail._(\"macholib\")\n","src/lib/curses/__init__.py":"import _sk_fail; _sk_fail._(\"curses\")\n","src/lib/dbhash.py":"import _sk_fail; _sk_fail._(\"dbhash\")\n","src/lib/decimal.py":"import _sk_fail; _sk_fail._(\"decimal\")\n","src/lib/difflib.py":"import _sk_fail; _sk_fail._(\"difflib\")\n","src/lib/dircache.py":"import _sk_fail; _sk_fail._(\"dircache\")\n","src/lib/dis.py":"import _sk_fail; _sk_fail._(\"dis\")\n","src/lib/distutils/__init__.py":"import _sk_fail; _sk_fail._(\"distutils\")\n","src/lib/distutils/command/__init__.py":"import _sk_fail; _sk_fail._(\"command\")\n","src/lib/distutils/tests/__init__.py":"import _sk_fail; _sk_fail._(\"tests\")\n","src/lib/doctest.py":"import _sk_fail; _sk_fail._(\"doctest\")\n","src/lib/dumbdbm.py":"import _sk_fail; _sk_fail._(\"dumbdbm\")\n","src/lib/dummy_thread.py":"import _sk_fail; _sk_fail._(\"dummy_thread\")\n","src/lib/dummy_threading.py":"import _sk_fail; _sk_fail._(\"dummy_threading\")\n","src/lib/email/__init__.py":"import _sk_fail; _sk_fail._(\"email\")\n","src/lib/email/mime/__init__.py":"import _sk_fail; _sk_fail._(\"mime\")\n","src/lib/email/test/data/__init__.py":"import _sk_fail; _sk_fail._(\"data\")\n","src/lib/encodings/__init__.py":"import _sk_fail; _sk_fail._(\"encodings\")\n","src/lib/filecmp.py":"import _sk_fail; _sk_fail._(\"filecmp\")\n","src/lib/fileinput.py":"import _sk_fail; _sk_fail._(\"fileinput\")\n","src/lib/fnmatch.py":"import _sk_fail; _sk_fail._(\"fnmatch\")\n","src/lib/formatter.py":"import _sk_fail; _sk_fail._(\"formatter\")\n","src/lib/fpformat.py":"import _sk_fail; _sk_fail._(\"fpformat\")\n","src/lib/fractions.py":"import _sk_fail; _sk_fail._(\"fractions\")\n","src/lib/ftplib.py":"import _sk_fail; _sk_fail._(\"ftplib\")\n","src/lib/genericpath.py":"import _sk_fail; _sk_fail._(\"genericpath\")\n","src/lib/getopt.py":"import _sk_fail; _sk_fail._(\"getopt\")\n","src/lib/getpass.py":"import _sk_fail; _sk_fail._(\"getpass\")\n","src/lib/gettext.py":"import _sk_fail; _sk_fail._(\"gettext\")\n","src/lib/glob.py":"import _sk_fail; _sk_fail._(\"glob\")\n","src/lib/gzip.py":"import _sk_fail; _sk_fail._(\"gzip\")\n","src/lib/hashlib.py":"import _sk_fail; _sk_fail._(\"hashlib\")\n","src/lib/heapq.py":"\"\"\"Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!\n\"\"\"\n\n# Original code by Kevin O'Connor, augmented by Tim Peters and Raymond Hettinger\n\n__about__ = \"\"\"Heap queues\n\n[explanation by François Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\na usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n\"\"\"\n\n__all__ = ['heappush', 'heappop', 'heapify', 'heapreplace',\n           'nlargest', 'nsmallest', 'heappushpop']\n\n\ndef heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap) - 1)\n\n\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup(heap, 0)\n        return returnitem\n    return lastelt\n\n\ndef heapreplace(heap, item):\n    \"\"\"Pop and return the current smallest value, and add the new item.\n\n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed-size heap.  Note that the value\n    returned may be larger than item!  That constrains reasonable uses of\n    this routine unless written as part of a conditional replacement:\n\n        if item > heap[0]:\n            item = heapreplace(heap, item)\n    \"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup(heap, 0)\n    return returnitem\n\n\ndef heappushpop(heap, item):\n    \"\"\"Fast version of a heappush followed by a heappop.\"\"\"\n    if heap and heap[0] < item:\n        item, heap[0] = heap[0], item\n        _siftup(heap, 0)\n    return item\n\n\ndef heapify(x):\n    \"\"\"Transform list into a heap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    # Transform bottom-up.  The largest index there's any point to looking at\n    # is the largest with a child index in-range, so must have 2*i + 1 < n,\n    # or i < (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so\n    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is\n    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.\n    for i in reversed(range(n // 2)):\n        _siftup(x, i)\n\n\ndef _heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt\n\n\ndef _heapreplace_max(heap, item):\n    \"\"\"Maxheap version of a heappop followed by a heappush.\"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup_max(heap, 0)\n    return returnitem\n\n\ndef _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n // 2)):\n        _siftup_max(x, i)\n\n# 'heap' is a heap at all indices >= startpos, except possibly for pos.  pos\n# is the index of a leaf with a possibly out-of-order value.  Restore the\n# heap invariant.\n\n\ndef _siftdown(heap, startpos, pos):\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if newitem < parent:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\n# The child indices of heap index pos are already heaps, and we want to make\n# a heap at index pos too.  We do this by bubbling the smaller child of\n# pos up (and so on with that child's children, etc) until hitting a leaf,\n# then using _siftdown to move the oddball originally at index pos into place.\n#\n# We *could* break out of the loop as soon as we find a pos where newitem <=\n# both its children, but turns out that's not a good idea, and despite that\n# many books write the algorithm that way.  During a heap pop, the last array\n# element is sifted in, and that tends to be large, so that comparing it\n# against values starting from the root usually doesn't pay (= usually doesn't\n# get us out of the loop early).  See Knuth, Volume 3, where this is\n# explained and quantified in an exercise.\n#\n# Cutting the # of comparisons is important, since these routines have no\n# way to extract \"the priority\" from an array element, so that intelligence\n# is likely to be hiding in custom comparison methods, or in array elements\n# storing (priority, record) tuples.  Comparisons are thus potentially\n# expensive.\n#\n# On random arrays of length 1000, making this change cut the number of\n# comparisons made by heapify() a little, and those made by exhaustive\n# heappop() a lot, in accord with theory.  Here are typical results from 3\n# runs (3 just to demonstrate how small the variance is):\n#\n# Compares needed by heapify     Compares needed by 1000 heappops\n# --------------------------     --------------------------------\n# 1837 cut to 1663               14996 cut to 8680\n# 1855 cut to 1659               14966 cut to 8678\n# 1847 cut to 1660               15024 cut to 8703\n#\n# Building the heap by using heappush() 1000 times instead required\n# 2198, 2148, and 2219 compares:  heapify() is more efficient, when\n# you can use it.\n#\n# The total compares needed by list.sort() on the same lists were 8627,\n# 8627, and 8632 (this should be compared to the sum of heapify() and\n# heappop() compares):  list.sort() is (unsurprisingly!) more efficient\n# for sorting.\n\n\ndef _siftup(heap, pos):\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the smaller child until hitting a leaf.\n    childpos = 2 * pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of smaller child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[childpos] < heap[rightpos]:\n            childpos = rightpos\n        # Move the smaller child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2 * pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown(heap, startpos, pos)\n\n\ndef _siftdown_max(heap, startpos, pos):\n    'Maxheap variant of _siftdown'\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if parent < newitem:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\n\ndef _siftup_max(heap, pos):\n    'Maxheap variant of _siftup'\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the larger child until hitting a leaf.\n    childpos = 2 * pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of larger child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[rightpos] < heap[childpos]:\n            childpos = rightpos\n        # Move the larger child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2 * pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown_max(heap, startpos, pos)\n\n\n# Algorithm notes for nlargest() and nsmallest()\n# ==============================================\n#\n# Make a single pass over the data while keeping the k most extreme values\n# in a heap.  Memory consumption is limited to keeping k values in a list.\n#\n# Measured performance for random inputs:\n#\n#                                   number of comparisons\n#    n inputs     k-extreme values  (average of 5 trials)   % more than min()\n# -------------   ----------------  ---------------------   -----------------\n#      1,000           100                  3,317               231.7%\n#     10,000           100                 14,046                40.5%\n#    100,000           100                105,749                 5.7%\n#  1,000,000           100              1,007,751                 0.8%\n# 10,000,000           100             10,009,401                 0.1%\n#\n# Theoretical number of comparisons for k smallest of n random inputs:\n#\n# Step   Comparisons                  Action\n# ----   --------------------------   ---------------------------\n#  1     1.66 * k                     heapify the first k-inputs\n#  2     n - k                        compare remaining elements to top of heap\n#  3     k * (1 + lg2(k)) * ln(n/k)   replace the topmost value on the heap\n#  4     k * lg2(k) - (k/2)           final sort of the k most extreme values\n#\n# Combining and simplifying for a rough estimate gives:\n#\n#        comparisons = n + k * (log(k, 2) * log(n/k) + log(k, 2) + log(n/k))\n#\n# Computing the number of comparisons for step 3:\n# -----------------------------------------------\n# * For the i-th new value from the iterable, the probability of being in the\n#   k most extreme values is k/i.  For example, the probability of the 101st\n#   value seen being in the 100 most extreme values is 100/101.\n# * If the value is a new extreme value, the cost of inserting it into the\n#   heap is 1 + log(k, 2).\n# * The probability times the cost gives:\n#            (k/i) * (1 + log(k, 2))\n# * Summing across the remaining n-k elements gives:\n#            sum((k/i) * (1 + log(k, 2)) for i in range(k+1, n+1))\n# * This reduces to:\n#            (H(n) - H(k)) * k * (1 + log(k, 2))\n# * Where H(n) is the n-th harmonic number estimated by:\n#            gamma = 0.5772156649\n#            H(n) = log(n, e) + gamma + 1 / (2 * n)\n#   http://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Rate_of_divergence\n# * Substituting the H(n) formula:\n#            comparisons = k * (1 + log(k, 2)) * (log(n/k, e) + (1/n - 1/k) / 2)\n#\n# Worst-case for step 3:\n# ----------------------\n# In the worst case, the input data is reversed sorted so that every new element\n# must be inserted in the heap:\n#\n#             comparisons = 1.66 * k + log(k, 2) * (n - k)\n#\n# Alternative Algorithms\n# ----------------------\n# Other algorithms were not used because they:\n# 1) Took much more auxiliary memory,\n# 2) Made multiple passes over the data.\n# 3) Made more comparisons in common cases (small k, large n, semi-random input).\n# See the more detailed comparison of approach at:\n# http://code.activestate.com/recipes/577573-compare-algorithms-for-heapqsmallest\n\ndef nsmallest(n, iterable, key=None):\n    \"\"\"Find the n smallest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key)[:n]\n    \"\"\"\n\n    # Short-cut for n==1 is to use min()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = min(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]\n\n    # When n>=size, it's faster to use sorted()\n    try:\n        size = len(iterable)\n    except (TypeError, AttributeError):\n        pass\n    else:\n        if n >= size:\n            return sorted(iterable, key=key)[:n]\n\n    # When key is none, use simpler decoration\n    if key is None:\n        it = iter(iterable)\n        # put the range(n) first so that zip() doesn't\n        # consume one too many elements from the iterator\n        result = [(elem, i) for i, elem in zip(range(n), it)]\n        if not result:\n            return result\n        _heapify_max(result)\n        top = result[0][0]\n        order = n\n        _heapreplace = _heapreplace_max\n        for elem in it:\n            if elem < top:\n                _heapreplace(result, (elem, order))\n                top, _order = result[0]\n                order += 1\n        result.sort()\n        return [elem for (elem, order) in result]\n\n    # General case, slowest method\n    it = iter(iterable)\n    result = [(key(elem), i, elem) for i, elem in zip(range(n), it)]\n    if not result:\n        return result\n    _heapify_max(result)\n    top = result[0][0]\n    order = n\n    _heapreplace = _heapreplace_max\n    for elem in it:\n        k = key(elem)\n        if k < top:\n            _heapreplace(result, (k, order, elem))\n            top, _order, _elem = result[0]\n            order += 1\n    result.sort()\n    return [elem for (k, order, elem) in result]\n\n\ndef nlargest(n, iterable, key=None):\n    \"\"\"Find the n largest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]\n    \"\"\"\n\n    # Short-cut for n==1 is to use max()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = max(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]\n\n    # When n>=size, it's faster to use sorted()\n    try:\n        size = len(iterable)\n    except (TypeError, AttributeError):\n        pass\n    else:\n        if n >= size:\n            return sorted(iterable, key=key, reverse=True)[:n]\n\n    # When key is none, use simpler decoration\n    if key is None:\n        it = iter(iterable)\n        result = [(elem, i) for i, elem in zip(range(0, -n, -1), it)]\n        if not result:\n            return result\n        heapify(result)\n        top = result[0][0]\n        order = -n\n        _heapreplace = heapreplace\n        for elem in it:\n            if top < elem:\n                _heapreplace(result, (elem, order))\n                top, _order = result[0]\n                order -= 1\n        result.sort(reverse=True)\n        return [elem for (elem, order) in result]\n\n    # General case, slowest method\n    it = iter(iterable)\n    result = [(key(elem), i, elem) for i, elem in zip(range(0, -n, -1), it)]\n    if not result:\n        return result\n    heapify(result)\n    top = result[0][0]\n    order = -n\n    _heapreplace = heapreplace\n    for elem in it:\n        k = key(elem)\n        if top < k:\n            _heapreplace(result, (k, order, elem))\n            top, _order, _elem = result[0]\n            order -= 1\n    result.sort(reverse=True)\n    return [elem for (k, order, elem) in result]\n\n\n# If available, use C implementation\ntry:\n    from _heapq import *\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapreplace_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapify_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heappop_max\nexcept ImportError:\n    pass\n\n\nif __name__ == \"__main__\":\n\n    import doctest  # pragma: no cover\n    print(doctest.testmod())  # pragma: no cover\n","src/lib/hmac.py":"import _sk_fail; _sk_fail._(\"hmac\")\n","src/lib/hotshot/__init__.py":"import _sk_fail; _sk_fail._(\"hotshot\")\n","src/lib/htmlentitydefs.py":"import _sk_fail; _sk_fail._(\"htmlentitydefs\")\n","src/lib/htmllib.py":"import _sk_fail; _sk_fail._(\"htmllib\")\n","src/lib/httplib.py":"import _sk_fail; _sk_fail._(\"httplib\")\n","src/lib/idlelib/Icons/__init__.py":"import _sk_fail; _sk_fail._(\"Icons\")\n","src/lib/idlelib/__init__.py":"import _sk_fail; _sk_fail._(\"idlelib\")\n","src/lib/ihooks.py":"import _sk_fail; _sk_fail._(\"ihooks\")\n","src/lib/imaplib.py":"import _sk_fail; _sk_fail._(\"imaplib\")\n","src/lib/imghdr.py":"import _sk_fail; _sk_fail._(\"imghdr\")\n","src/lib/imputil.py":"import _sk_fail; _sk_fail._(\"imputil\")\n","src/lib/io.py":"import _sk_fail; _sk_fail._(\"io\")\n","src/lib/json/tests/__init__.py":"import _sk_fail; _sk_fail._(\"tests\")\n","src/lib/lib-dynload/__init__.py":"import _sk_fail; _sk_fail._(\"lib-dynload\")\n","src/lib/lib-tk/__init__.py":"import _sk_fail; _sk_fail._(\"lib-tk\")\n","src/lib/lib2to3/__init__.py":"import _sk_fail; _sk_fail._(\"lib2to3\")\n","src/lib/lib2to3/fixes/__init__.py":"import _sk_fail; _sk_fail._(\"fixes\")\n","src/lib/lib2to3/pgen2/__init__.py":"import _sk_fail; _sk_fail._(\"pgen2\")\n","src/lib/lib2to3/tests/__init__.py":"import _sk_fail; _sk_fail._(\"tests\")\n","src/lib/linecache.py":"import _sk_fail; _sk_fail._(\"linecache\")\n","src/lib/locale.py":"import _sk_fail; _sk_fail._(\"locale\")\n","src/lib/logging/__init__.py":"import _sk_fail; _sk_fail._(\"logging\")\n","src/lib/macpath.py":"import _sk_fail; _sk_fail._(\"macpath\")\n","src/lib/macurl2path.py":"import _sk_fail; _sk_fail._(\"macurl2path\")\n","src/lib/mailbox.py":"import _sk_fail; _sk_fail._(\"mailbox\")\n","src/lib/mailcap.py":"import _sk_fail; _sk_fail._(\"mailcap\")\n","src/lib/markupbase.py":"import _sk_fail; _sk_fail._(\"markupbase\")\n","src/lib/md5.py":"import _sk_fail; _sk_fail._(\"md5\")\n","src/lib/mhlib.py":"import _sk_fail; _sk_fail._(\"mhlib\")\n","src/lib/mimetools.py":"import _sk_fail; _sk_fail._(\"mimetools\")\n","src/lib/mimetypes.py":"import _sk_fail; _sk_fail._(\"mimetypes\")\n","src/lib/mimify.py":"import _sk_fail; _sk_fail._(\"mimify\")\n","src/lib/modulefinder.py":"import _sk_fail; _sk_fail._(\"modulefinder\")\n","src/lib/multifile.py":"import _sk_fail; _sk_fail._(\"multifile\")\n","src/lib/multiprocessing/__init__.py":"import _sk_fail; _sk_fail._(\"multiprocessing\")\n","src/lib/multiprocessing/dummy/__init__.py":"import _sk_fail; _sk_fail._(\"dummy\")\n","src/lib/mutex.py":"import _sk_fail; _sk_fail._(\"mutex\")\n","src/lib/netrc.py":"import _sk_fail; _sk_fail._(\"netrc\")\n","src/lib/new.py":"import _sk_fail; _sk_fail._(\"new\")\n","src/lib/nntplib.py":"import _sk_fail; _sk_fail._(\"nntplib\")\n","src/lib/ntpath.py":"import _sk_fail; _sk_fail._(\"ntpath\")\n","src/lib/nturl2path.py":"import _sk_fail; _sk_fail._(\"nturl2path\")\n","src/lib/numbers.py":"Number = (int, float, complex)\nIntegral = int\nComplex = complex\n","src/lib/opcode.py":"import _sk_fail; _sk_fail._(\"opcode\")\n","src/lib/optparse.py":"import _sk_fail; _sk_fail._(\"optparse\")\n","src/lib/os.py":"import _sk_fail; _sk_fail._(\"os\")\n","src/lib/os2emxpath.py":"import _sk_fail; _sk_fail._(\"os2emxpath\")\n","src/lib/pdb.py":"import _sk_fail; _sk_fail._(\"pdb\")\n","src/lib/pickle.py":"import _sk_fail; _sk_fail._(\"pickle\")\n","src/lib/pickletools.py":"import _sk_fail; _sk_fail._(\"pickletools\")\n","src/lib/pipes.py":"import _sk_fail; _sk_fail._(\"pipes\")\n","src/lib/pkgutil.py":"import _sk_fail; _sk_fail._(\"pkgutil\")\n","src/lib/platform.py":"import _sk_fail; _sk_fail._(\"platform\")\n","src/lib/plistlib.py":"import _sk_fail; _sk_fail._(\"plistlib\")\n","src/lib/popen2.py":"import _sk_fail; _sk_fail._(\"popen2\")\n","src/lib/poplib.py":"import _sk_fail; _sk_fail._(\"poplib\")\n","src/lib/posixfile.py":"import _sk_fail; _sk_fail._(\"posixfile\")\n","src/lib/posixpath.py":"import _sk_fail; _sk_fail._(\"posixpath\")\n","src/lib/pprint.py":"import _sk_fail; _sk_fail._(\"pprint\")\n","src/lib/profile.py":"import _sk_fail; _sk_fail._(\"profile\")\n","src/lib/pstats.py":"import _sk_fail; _sk_fail._(\"pstats\")\n","src/lib/pty.py":"import _sk_fail; _sk_fail._(\"pty\")\n","src/lib/py_compile.py":"import _sk_fail; _sk_fail._(\"py_compile\")\n","src/lib/pyclbr.py":"import _sk_fail; _sk_fail._(\"pyclbr\")\n","src/lib/pydoc.py":"import _sk_fail; _sk_fail._(\"pydoc\")\n","src/lib/pydoc_topics.py":"import _sk_fail; _sk_fail._(\"pydoc_topics\")\n","src/lib/pythonds/__init__.py":"","src/lib/pythonds/basic/__init__.py":"\n#__all__ = [\"stack\"]\n\n\nfrom .stack import Stack\nfrom .queue import Queue\nfrom .deque import Deque\n\n\n","src/lib/pythonds/basic/deque.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# deque.py\n\n\nclass Deque:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def addFront(self, item):\n        self.items.append(item)\n\n    def addRear(self, item):\n        self.items.insert(0, item)\n\n    def removeFront(self):\n        return self.items.pop()\n\n    def removeRear(self):\n        return self.items.pop(0)\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/basic/queue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# queue.py\n\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def enqueue(self, item):\n        self.items.insert(0, item)\n\n    def dequeue(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/basic/stack.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# stack.py\n\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/graphs/__init__.py":"\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n","src/lib/pythonds/graphs/adjGraph.py":"#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = 'white'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":disc \" + str(self.disc) + \":fin \" + str(self.fin) + \":dist \" + str(self.dist) + \":pred \\n\\t[\" + str(self.pred)+ \"]\\n\"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open(\"test.dat\")\n        for line in gFile:\n            fVertex, tVertex = line.split('|')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == '__main__':\n    unittest.main()\n              \n","src/lib/pythonds/graphs/priorityQueue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,'x'))\n        self.theHeap.add((3,'y'))\n        self.theHeap.add((5,'z'))\n        self.theHeap.add((6,'a'))\n        self.theHeap.add((4,'d'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == 'x'\n        assert self.theHeap.delMin() == 'y'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey('d',1)\n        assert self.theHeap.delMin() == 'd'\n        \nif __name__ == '__main__':\n    unittest.main()\n","src/lib/pythonds/trees/__init__.py":"\nfrom .binaryTree import BinaryTree\nfrom .balance import AVLTree\nfrom .bst import BinarySearchTree\nfrom .binheap import BinHeap\n\n\n","src/lib/pythonds/trees/balance.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    '''\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n","src/lib/pythonds/trees/binaryTree.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    \"\"\"    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print('(')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(')')\n\n    def postordereval(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print('(')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(')') \n\ndef printexp(tree):\n    sVal = \"\"\n    if tree:\n        sVal = '(' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + ')'\n    return sVal\n\ndef postordereval(tree):\n    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree('*')\n# x.insertLeft('+')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n","src/lib/pythonds/trees/binheap.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n","src/lib/pythonds/trees/bst.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    '''\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError('Error, key not in tree')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree.\"\"\"\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n","src/lib/pythonds3/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3 import statement\n\"\"\"\n\nfrom pythonds3.basic import Stack, Queue, Deque\nfrom pythonds3.graphs import Graph, Vertex\nfrom pythonds3.searching import HashTable\nfrom pythonds3.trees import (\n    BinaryTree,\n    AVLTree,\n    BinarySearchTree,\n    BinaryHeap,\n    PriorityQueue,\n)\n\n__all__ = [\n    \"Stack\",\n    \"Queue\",\n    \"Deque\",\n    \"Graph\",\n    \"Vertex\",\n    \"HashTable\",\n    \"BinaryTree\",\n    \"AVLTree\",\n    \"BinarySearchTree\",\n    \"BinaryHeap\",\n    \"BinaryTree\",\n    \"PriorityQueue\",\n]\n","src/lib/pythonds3/basic/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.basic import statement\n\"\"\"\nfrom pythonds3.basic.stack import Stack\nfrom pythonds3.basic.queue import Queue\nfrom pythonds3.basic.deque import Deque\nfrom pythonds3.basic.linked_list import OrderedList\nfrom pythonds3.basic.linked_list import UnorderedList\n\n__all__ = [\"Stack\", \"Queue\", \"Deque\", \"OrderedList\", \"UnorderedList\"]\n","src/lib/pythonds3/basic/deque.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Deque:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new deque\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the deque is empty\"\"\"\n        return not bool(self._items)\n\n    def add_front(self, item):\n        \"\"\"Add an item to the front of the deque\"\"\"\n        self._items.append(item)\n\n    def add_rear(self, item):\n        \"\"\"Add an item to the rear of the deque\"\"\"\n        self._items.insert(0, item)\n\n    def remove_front(self):\n        \"\"\"Remove an item from the front of the deque\"\"\"\n        return self._items.pop()\n\n    def remove_rear(self):\n        \"\"\"Remove an item from the rear of the deque\"\"\"\n        return self._items.pop(0)\n\n    def size(self):\n        \"\"\"Get the number of items in the deque\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/basic/linked_list.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass LinkedListNode:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n\n\nclass LinkedList:\n    \"\"\"Linked List class implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a linked list\"\"\"\n        self._head = None\n        self._count = 0\n\n    def is_empty(self):\n        \"\"\"Is the list empty\"\"\"\n        return self._head is None\n\n    def size(self):\n        \"\"\"Size of the list\"\"\"\n        return self._count\n\n    def __len__(self):\n        \"\"\"Size of the list\"\"\"\n        return self._count\n\n    def __str__(self):\n        \"\"\"List as a string\"\"\"\n        list_str = \"[\"\n        current = self._head\n\n        while current:\n            list_str += str(current)\n            if current.next:\n                list_str += \", \"\n            current = current.next\n        list_str += \"]\"\n        return list_str\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        pass\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        pass\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        pass\n\n\nclass UnorderedList(LinkedList):\n    \"\"\"Unordered linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create an unordered linked list\"\"\"\n        LinkedList.__init__(self)\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        new_node = LinkedListNode(value)\n        new_node.set_next(self._head)\n        self._head = new_node\n        self._count = self._count + 1\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        current = self._head\n        prev = None\n\n        while current:\n            if current.data == value:\n                if prev is None:\n                    self._head = current.next\n                else:\n                    prev.next = current.next\n                self._count = self._count - 1\n                return\n            prev = current\n            current = current.next\n        raise ValueError(\"{} is not in the list\".format(value))\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        current = self._head\n\n        while current:\n            if current.data == value:\n                return True\n            current = current.next\n        return False\n\n\nclass OrderedList(LinkedList):\n    \"\"\"Ordered linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create an Ordered linked list\"\"\"\n        LinkedList.__init__(self)\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        current = self._head\n        prev = None\n        new_node = LinkedListNode(value)\n\n        while current and current.data < value:\n            prev = current\n            current = current.next\n\n        if prev is None:\n            new_node.next = self._head\n            self._head = new_node\n        else:\n            new_node.next = current\n            prev.next = new_node\n        self._count = self._count + 1\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        # This is an exercise\n        pass\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        # This is an exercise\n        pass\n","src/lib/pythonds3/basic/queue.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Queue:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new queue\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return not bool(self._items)\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the queue\"\"\"\n        self._items.insert(0, item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the queue\"\"\"\n        return self._items.pop()\n\n    def size(self):\n        \"\"\"Get the number of items in the queue\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/basic/stack.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Stack:\n    \"\"\"Stack implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new stack\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the stack is empty\"\"\"\n        return not bool(self._items)\n\n    def push(self, item):\n        \"\"\"Add an item to the stack\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove an item from the stack\"\"\"\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"Get the value of the top item in the stack\"\"\"\n        return self._items[-1]\n\n    def size(self):\n        \"\"\"Get the number of items in the stack\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/graphs/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.graphs import statement\n\"\"\"\nfrom pythonds3.graphs.adjacency_graph import Graph\nfrom pythonds3.graphs.adjacency_graph import Vertex\n\n__all__ = [\"Graph\"]\n","src/lib/pythonds3/graphs/adjacency_graph.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport heapq\nimport sys\n\n\nclass Vertex:\n    \"\"\"Graph vertex class\"\"\"\n\n    def __init__(self, key):\n        \"\"\"Create new vertex\"\"\"\n        self._key = key\n        self._neighbors = {}\n        self._color = \"white\"\n        self._distance = sys.maxsize\n        self._previous = None\n        self._discovery_time = 0\n        self._closing_time = 0\n\n    def __lt__(self, other):\n        \"\"\"Less than operator required for heapify\"\"\"\n        return self.key < other.key\n\n    def get_key(self):\n        \"\"\"Get vertex key\"\"\"\n        return self._key\n\n    key = property(get_key)\n\n    def get_neighbor(self, other):\n        \"\"\"Get the distance (edge weight) to an adjacent node (neighbor)\"\"\"\n        return self._neighbors.get(other, None)\n\n    def set_neighbor(self, other, weight=0):\n        \"\"\"Set the distance (add an edge) to an adjacent node (neighbor)\"\"\"\n        self._neighbors[other] = weight\n\n    def get_neighbors(self):\n        \"\"\"Get all adjacent nodes (neighbors)\"\"\"\n        return self._neighbors.keys()\n\n    def get_color(self):\n        \"\"\"Get vertex color\"\"\"\n        return self._color\n\n    def set_color(self, color):\n        \"\"\"Set vertex color\"\"\"\n        self._color = color\n\n    color = property(get_color, set_color)\n\n    def get_distance(self):\n        \"\"\"Get distance\"\"\"\n        return self._distance\n\n    def set_distance(self, distance):\n        \"\"\"Set distance\"\"\"\n        self._distance = distance\n\n    distance = property(get_distance, set_distance)\n\n    def get_previous(self):\n        \"\"\"Get previous\"\"\"\n        return self._previous\n\n    def set_previous(self, previous):\n        \"\"\"Set previous\"\"\"\n        self._previous = previous\n\n    previous = property(get_previous, set_previous)\n\n    def get_discovery_time(self):\n        \"\"\"Get discovery time\"\"\"\n        return self._discovery_time\n\n    def set_discovery_time(self, discovery_time):\n        \"\"\"Set discovery time\"\"\"\n        self._discovery_time = discovery_time\n\n    discovery_time = property(get_discovery_time, set_discovery_time)\n\n    def get_closing_time(self):\n        \"\"\"Get closing time\"\"\"\n        return self._closing_time\n\n    def set_closing_time(self, closing_time):\n        \"\"\"Set closing time\"\"\"\n        self._closing_time = closing_time\n\n    closing_time = property(get_closing_time, set_closing_time)\n\n    def __str__(self):\n        return \"{:^8}|{:^8}|{:^8}|{:^8}|{:^8}| {}\".format(\n            self._key,\n            self._color,\n            self._distance,\n            self._discovery_time,\n            self._closing_time,\n            self._previous,\n        )\n\n\nclass Graph:\n    \"\"\"Graph as an adjacency matrix\"\"\"\n\n    def __init__(self):\n        self._vertices = {}\n        self._edges = {}\n        self._time = 0\n\n    def __iter__(self):\n        \"\"\"Iterator\"\"\"\n        return iter(self._vertices.values())\n\n    def size(self):\n        \"\"\"Graph's size\"\"\"\n        return len(self._vertices)\n\n    def __len__(self):\n        \"\"\"Graph's size\"\"\"\n        return len(self._vertices)\n\n    def __contains__(self, key):\n        \"\"\"in operator override\"\"\"\n        return key in self._vertices\n\n    def get_vertex(self, key):\n        \"\"\"Find the vertex in the graph named vert_key\"\"\"\n        return self._vertices.get(key, None)\n\n    def set_vertex(self, key):\n        \"\"\"Add an instance of Vertex to the graph\"\"\"\n        self._vertices[key] = Vertex(key)\n\n    def add_edge(self, from_vertex, to_vertex, weight=0):\n        \"\"\"Add a weighted and directed edge to the graph\"\"\"\n        if from_vertex not in self._vertices:\n            self.set_vertex(from_vertex)\n        if to_vertex not in self._vertices:\n            self.set_vertex(to_vertex)\n        self._vertices[from_vertex].set_neighbor(self._vertices[to_vertex], weight)\n        self._edges[(from_vertex, to_vertex)] = weight\n\n    def get_vertices(self):\n        \"\"\"Return the list of all vertices in the graph\"\"\"\n        return self._vertices.keys()\n\n    def get_edges(self):\n        \"\"\"Return the list of all edges in the graph\"\"\"\n        return self._edges.keys()\n\n    def reset_distances(self, default_distance=sys.maxsize):\n        \"\"\"Reset distances to test Dijkstra's\"\"\"\n        for vertex in self:\n            vertex.distance = default_distance\n\n    def bfs(self, start):\n        \"\"\"Breadth First Search\"\"\"\n        start.distance = 0\n        start.previous = None\n        vert_queue = [start]\n        while vert_queue:\n            current_vert = vert_queue.pop(0)\n            for neigh in current_vert.get_neighbors():\n                if neigh.color == \"white\":\n                    neigh.color = \"gray\"\n                    neigh.distance = current_vert.distance + 1\n                    neigh.previous = current_vert\n                    vert_queue.append(neigh)\n            current_vert.color = \"black\"\n\n    def dfs(self):\n        \"\"\"Depth First search\"\"\"\n        for vertex in self:\n            if vertex.color == \"white\":\n                self.dfs_visit(vertex)\n\n    def dfs_visit(self, start):\n        \"\"\"DFS helper function\"\"\"\n        start.color = \"gray\"\n        self._time = self._time + 1\n        start.discovery_time = self._time\n        for next_vertex in start.get_neighbors():\n            if next_vertex.color == \"white\":\n                next_vertex.set_previous(start)\n                self.dfs_visit(next_vertex)\n        start.color = \"black\"\n        self._time = self._time + 1\n        start.closing_time = self._time\n\n    def traverse(self, src, dst):\n        \"\"\"Traverse a graph\"\"\"\n        path = []\n        current = self.get_vertex(dst)\n        while current:\n            path.append(current)\n            current = current.previous\n        print(\n            \"Path from {} to {} ({}): {}\".format(\n                self.get_vertex(src).key,\n                self.get_vertex(dst).key,\n                self.get_vertex(dst).distance,\n                \" \".join(vertex.key for vertex in reversed(path)),\n            )\n        )\n\n    def dijkstra(self, start):\n        \"\"\"Dijkstra's shortest path algorithm\"\"\"\n        start.distance = 0\n        not_yet_visited = [[start.distance, start]]\n        heapq.heapify(not_yet_visited)\n        while not_yet_visited:\n            current_vertex = heapq.heappop(not_yet_visited)[1]\n            for next_vertex in current_vertex.get_neighbors():\n                new_distance = current_vertex.distance + current_vertex.get_neighbor(\n                    next_vertex\n                )\n                if new_distance < next_vertex.distance:\n                    next_vertex.distance = new_distance\n                    next_vertex.previous = current_vertex\n                    found = False\n                    for vertex in not_yet_visited:\n                        if vertex[1].key == next_vertex.key:\n                            vertex[0] = next_vertex.distance\n                            heapq.heapify(not_yet_visited)\n                            found = True\n                    if not found:\n                        heapq.heappush(\n                            not_yet_visited, [next_vertex.distance, next_vertex]\n                        )\n\n    def bellman_ford(self, start):\n        \"\"\"Bellman-Ford shortest path algorithm\"\"\"\n        start.distance = 0\n        for _ in range(len(self._vertices)):\n            for edge in self._edges:\n                if (\n                    self.get_vertex(edge[0]).distance + self._edges[edge]\n                    < self.get_vertex(edge[1]).distance\n                ):\n                    self.get_vertex(edge[1]).distance = (\n                        self.get_vertex(edge[0]).distance + self._edges[edge]\n                    )\n                    self.get_vertex(edge[1]).previous = self.get_vertex(edge[0])\n        for edge in self._edges:\n            if (\n                self.get_vertex(edge[0]).distance + self._edges[edge]\n                < self.get_vertex(edge[1]).distance\n            ):\n                raise ValueError(\"Graph contains a negative-weight cycle\")\n\n    def prim(self, start):\n        \"\"\"Prim's spanning tree algorithm\"\"\"\n        start.distance = 0\n        not_in_a_tree = [[vertex.distance, vertex] for vertex in self]\n        heapq.heapify(not_in_a_tree)\n        while not_in_a_tree:\n            current_vertex = heapq.heappop(not_in_a_tree)[1]\n            for next_vertex in current_vertex.get_neighbors():\n                new_distance = current_vertex.get_neighbor(next_vertex)\n                if (\n                    any(item[1] == next_vertex for item in not_in_a_tree)\n                    and new_distance < next_vertex.distance\n                ):\n                    next_vertex.previous = current_vertex\n                    next_vertex.distance = new_distance\n                    for item in not_in_a_tree:\n                        if item[1] == next_vertex:\n                            item[0] = new_distance\n                            heapq.heapify(not_in_a_tree)\n                            break\n","src/lib/pythonds3/intro/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.intro import statement\n\"\"\"\nfrom pythonds3.intro.oop import Fraction\n\n__all__ = [\"Fraction\"]\n","src/lib/pythonds3/intro/oop.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\ndef gcd(number1, number2):\n    \"\"\"Helper function to simplify fractions\"\"\"\n    if not isinstance(number1, int) or not isinstance(number2, int):\n        raise TypeError(\"Numerator and denominator must be integers\")\n    while number1 % number2:\n        number1, number2 = number2, number1 % number2\n    return number2\n\n\nclass Fraction:\n    \"\"\"Fraction class\"\"\"\n\n    def __init__(self, new_numer, new_denom):\n        try:\n            common = gcd(new_numer, new_denom)\n        except TypeError:\n            raise\n        self._numer = new_numer // common\n        self._denom = new_denom // common\n\n    @property\n    def numer(self):\n        \"\"\"Get numerator\"\"\"\n        return self._numer\n\n    @numer.setter\n    def set_numer(self, new_numer):\n        \"\"\"Set numerator\"\"\"\n        self._numer = new_numer\n\n    def get_denom(self):\n        \"\"\"Get deniminator\"\"\"\n        return self._denom\n\n    def set_denom(self, new_denom):\n        \"\"\"Set deniminator\"\"\"\n        self._denom = new_denom\n\n    # Another way to create an attribute\n    denom = property(get_denom, set_denom)\n\n    def __str__(self):\n        \"\"\"Get the string value\"\"\"\n        if self._numer > self._denom:\n            return \"{} {}/{}\".format(\n                self._numer // self._denom, self._numer % self._denom, self._denom\n            )\n        return \"{}/{}\".format(self._numer, self._denom)\n\n    def __repr__(self):\n        \"\"\"Fraction representation\"\"\"\n        return \"Fraction({}, {})\".format(self._numer, self._denom)\n\n    def __eq__(self, other):\n        \"\"\"Equality comparison\"\"\"\n        return self._numer * other.denom == other.numer * self._denom\n\n    def __add__(self, other):\n        \"\"\"Add two fractions\"\"\"\n        new_numer = self._numer * other.denom + self._denom * other.numer\n        new_denom = self._denom * other.denom\n        return Fraction(new_numer, new_denom)\n","src/lib/pythonds3/searching/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.search import statement\n\"\"\"\nfrom pythonds3.searching.hash_table import HashTable\n\n__all__ = [\"HashTable\"]\n","src/lib/pythonds3/searching/hash_table.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass HashTable:\n    \"\"\"Hash Table implementation\"\"\"\n\n    def __init__(self, size=16):\n        \"\"\"Create a hash table\"\"\"\n        self._size = size\n        self._slots = [None] * self._size\n        self._data = [None] * self._size\n\n    def __getitem__(self, key):\n        \"\"\"Magic __get__\"\"\"\n        return self.get(key)\n\n    def __setitem__(self, key, data):\n        \"\"\"Magic __set__\"\"\"\n        self.put(key, data)\n\n    def __len__(self):\n        \"\"\"Magic __len__\"\"\"\n        return self._size - self._slots.count(None)\n\n    def __contains__(self, key):\n        \"\"\"Magin in\"\"\"\n        return key in self._slots\n\n    def _hash_function(self, key, size):\n        \"\"\"Simple hash function\"\"\"\n        return key % size\n\n    def _rehash(self, old_hash, size, step=1):\n        \"\"\"Simple rehash function\"\"\"\n        return (old_hash + step) % size\n\n    def is_empty(self):\n        \"\"\"Check if the table is empty\"\"\"\n        return self._size == self._slots.count(None)\n\n    def size(self):\n        \"\"\"Get number of items in the table\"\"\"\n        return self._size - self._slots.count(None)\n\n    def put(self, key, data):\n        \"\"\"Add an item to the table\"\"\"\n        hash_value = self._hash_function(key, len(self._slots))\n\n        if self._slots[hash_value] is None:\n            self._slots[hash_value] = key\n            self._data[hash_value] = data\n        else:\n            if self._slots[hash_value] == key:\n                self._data[hash_value] = data  # replace\n            else:\n                j = 0\n                next_slot = self._rehash(hash_value, len(self._slots), j)\n                while (\n                    self._slots[next_slot] is not None\n                    and self._slots[next_slot] != key\n                    and j < self._size\n                ):\n                    j = j + 1\n                    next_slot = self._rehash(hash_value, len(self._slots), j)\n\n                if self._slots[next_slot] is None:\n                    self._slots[next_slot] = key\n                    self._data[next_slot] = data\n                elif j == self._size:\n                    raise Exception(\"Hash Table is full\")\n                else:\n                    self._data[next_slot] = data  # replace\n\n    def get(self, key):\n        \"\"\"Get an item from the table\"\"\"\n        start_slot = self._hash_function(key, len(self._slots))\n        position = start_slot\n        j = 0\n\n        while self._slots[position] is not None and j < self._size:\n            if self._slots[position] == key:\n                return self._data[position]\n            j = j + 1\n            position = self._rehash(start_slot, len(self._slots), j)\n\n        raise KeyError(\"{} is not in the table\".format(key))\n","src/lib/pythonds3/sorting/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.sorting import statement\n\"\"\"\nfrom pythonds3.sorting.sorting_algorithms import bubble_sort\nfrom pythonds3.sorting.sorting_algorithms import select_sort\nfrom pythonds3.sorting.sorting_algorithms import insert_sort\nfrom pythonds3.sorting.sorting_algorithms import shell_sort\nfrom pythonds3.sorting.sorting_algorithms import merge_sort\nfrom pythonds3.sorting.sorting_algorithms import quick_sort\nfrom pythonds3.sorting.sorting_algorithms import heap_sort\n","src/lib/pythonds3/sorting/sorting_algorithms.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport heapq\n\n\ndef bubble_sort(lst):\n    \"\"\"Bubble sort\"\"\"\n    for i in range(len(lst) - 1, 0, -1):\n        exchanges = False\n        for j in range(i):\n            if lst[j] > lst[j + 1]:\n                exchanges = True\n                lst[j], lst[j + 1] = lst[j + 1], lst[j]\n        if not exchanges:\n            break\n\n\ndef select_sort(lst):\n    \"\"\"Selection sort\"\"\"\n    for i, item in enumerate(lst):\n        min_idx = len(lst) - 1\n        for j in range(i, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            lst[min_idx], lst[i] = lst[i], lst[min_idx]\n\n\ndef insert_sort(lst):\n    \"\"\"Insertion sort\"\"\"\n    for i in range(1, len(lst)):\n        cur_val = lst[i]\n        cur_pos = i\n\n        while cur_pos > 0 and lst[cur_pos - 1] > cur_val:\n            lst[cur_pos] = lst[cur_pos - 1]\n            cur_pos = cur_pos - 1\n        lst[cur_pos] = cur_val\n\n\ndef shell_sort(lst):\n    \"\"\"Shell sort\"\"\"\n    sublist_count = len(lst) // 3\n    while sublist_count > 0:\n        for pos_start in range(sublist_count):\n            _gap_insert_sort(lst, pos_start, sublist_count)\n        sublist_count = sublist_count // 2\n\n\ndef _gap_insert_sort(lst, start, gap):\n    \"\"\"Shell sort helper function\"\"\"\n    for i in range(start + gap, len(lst), gap):\n        cur_val = lst[i]\n        cur_pos = i\n        while cur_pos >= gap and lst[cur_pos - gap] > cur_val:\n            lst[cur_pos] = lst[cur_pos - gap]\n            cur_pos = cur_pos - gap\n        lst[cur_pos] = cur_val\n\n\ndef merge_sort(lst):\n    \"\"\"Merge sort\"\"\"\n    if len(lst) > 1:\n        mid = len(lst) // 2\n        left_half = lst[:mid]\n        right_half = lst[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i, j, k = 0, 0, 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] <= right_half[j]:\n                lst[k] = left_half[i]\n                i = i + 1\n            else:\n                lst[k] = right_half[j]\n                j = j + 1\n            k = k + 1\n\n        while i < len(left_half):\n            lst[k] = left_half[i]\n            i = i + 1\n            k = k + 1\n\n        while j < len(right_half):\n            lst[k] = right_half[j]\n            j = j + 1\n            k = k + 1\n\n\ndef quick_sort(lst):\n    \"\"\"Quick sort\"\"\"\n    _quick_sort_help(lst, 0, len(lst) - 1)\n\n\ndef _quick_sort_help(lst, mark_l, mark_r):\n    \"\"\"Quick sort helper\"\"\"\n    if mark_l < mark_r:\n        split = _quick_sort_part(lst, mark_l, mark_r)\n        _quick_sort_help(lst, mark_l, split - 1)\n        _quick_sort_help(lst, split + 1, mark_r)\n\n\ndef _quick_sort_part(lst, mark_l, mark_r):\n    \"\"\"Quick sort partition\"\"\"\n    pivot_val = lst[mark_l]\n    mark_l_cur = mark_l + 1\n    mark_r_cur = mark_r\n    done = False\n\n    while not done:\n        while mark_l_cur <= mark_r_cur and lst[mark_l_cur] <= pivot_val:\n            mark_l_cur = mark_l_cur + 1\n        while mark_l_cur <= mark_r_cur and lst[mark_r_cur] >= pivot_val:\n            mark_r_cur = mark_r_cur - 1\n        if mark_r_cur < mark_l_cur:\n            done = True\n        else:\n            lst[mark_l_cur], lst[mark_r_cur] = lst[mark_r_cur], lst[mark_l_cur]\n    lst[mark_l], lst[mark_r_cur] = lst[mark_r_cur], lst[mark_l]\n\n    return mark_r_cur\n\n\ndef heap_sort(lst):\n    \"\"\"Heap sort\"\"\"\n    res = []\n    heapq.heapify(lst)\n    while lst:\n        res.append(heapq.heappop(lst))\n    for i in res:\n        lst.append(i)\n","src/lib/pythonds3/trees/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.trees import statement\n\"\"\"\nfrom pythonds3.trees.avl_tree import AVLTree\nfrom pythonds3.trees.binary_search_tree import BinarySearchTree\nfrom pythonds3.trees.binary_heap import BinaryHeap\nfrom pythonds3.trees.binary_tree import BinaryTree\nfrom pythonds3.trees.priority_queue import PriorityQueue\n\n__all__ = [\"BinaryTree\", \"BinaryHeap\", \"BinarySearchTree\", \"AVLTree\", \"PriorityQueue\"]\n","src/lib/pythonds3/trees/avl_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005, 2010\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nfrom pythonds3.trees.binary_search_tree import BinarySearchTree\nfrom pythonds3.trees.binary_search_tree import BinaryTreeNode\n\n\nclass AVLTreeNode(BinaryTreeNode):\n    \"\"\"AVL Tree Node\"\"\"\n\n    def __init__(self, key, val, balance_factor, left=None, right=None, parent=None):\n        \"\"\"Create an AVL tree node\"\"\"\n        BinaryTreeNode.__init__(self, key, val, left, right, parent)\n        self._balance_factor = balance_factor\n\n    def get_balance_factor(self):\n        \"\"\"Get the node balance factor\"\"\"\n        return self._balance_factor\n\n    def set_balance_factor(self, value):\n        \"\"\"Set the node balance factor\"\"\"\n        self._balance_factor = value\n\n    balance_factor = property(get_balance_factor, set_balance_factor)\n\n\nclass AVLTree(BinarySearchTree):\n    \"\"\"AVL tree implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a new AVL tree\"\"\"\n        BinarySearchTree.__init__(self)\n\n    def put(self, key, value):\n        \"\"\"Add new node\"\"\"\n        if self._root:\n            self._put(key, value, self._root)\n        else:\n            self._root = AVLTreeNode(key, value, 0)\n        self._size = self._size + 1\n\n    def _put(self, key, value, current_node):\n        \"\"\"Add a new node to the tree (helper function)\"\"\"\n        if key < current_node.key:\n            if current_node.get_child_left():\n                self._put(key, value, current_node.child_left)\n            else:\n                current_node.child_left = AVLTreeNode(\n                    key, value, 0, parent=current_node\n                )\n                self.update_balance(current_node.child_left)\n        else:\n            if current_node.get_child_right():\n                self._put(key, value, current_node.child_right)\n            else:\n                current_node.child_right = AVLTreeNode(\n                    key, value, 0, parent=current_node\n                )\n                self.update_balance(current_node.child_right)\n\n    def update_balance(self, node):\n        \"\"\"Update the tree balance\"\"\"\n        if node.balance_factor > 1 or node.balance_factor < -1:\n            self.rebalance(node)\n            return\n        if node.parent:\n            if node.is_child_left():\n                node.parent.balance_factor += 1\n            elif node.is_child_right():\n                node.parent.balance_factor -= 1\n\n            if node.parent.balance_factor != 0:\n                self.update_balance(node.parent)\n\n    def rebalance(self, node):\n        \"\"\"Rebalance the tree\"\"\"\n        if node.balance_factor < 0:\n            if node.child_right.balance_factor > 0:\n                # Do an LR Rotation\n                self.rotate_right(node.child_right)\n                self.rotate_left(node)\n            else:\n                # single left\n                self.rotate_left(node)\n        elif node.balance_factor > 0:\n            if node.child_left.balance_factor < 0:\n                # Do an RL Rotation\n                self.rotate_left(node.child_left)\n                self.rotate_right(node)\n            else:\n                # single right\n                self.rotate_right(node)\n\n    def rotate_left(self, rotation_root):\n        \"\"\"Left rotation\"\"\"\n        new_root = rotation_root.child_right\n        rotation_root.child_right = new_root.child_left\n        if new_root.child_left:\n            new_root.child_left.parent = rotation_root\n        new_root.parent = rotation_root.parent\n        if rotation_root.is_root():\n            self._root = new_root\n        else:\n            if rotation_root.is_child_left():\n                rotation_root.parent.child_left = new_root\n            else:\n                rotation_root.parent.child_right = new_root\n        new_root.child_left = rotation_root\n        rotation_root.parent = new_root\n        rotation_root.balance_factor = (\n            rotation_root.balance_factor + 1 - min(new_root.balance_factor, 0)\n        )\n        new_root.balance_factor = (\n            new_root.balance_factor + 1 + max(rotation_root.balance_factor, 0)\n        )\n\n    def rotate_right(self, rotation_root):\n        \"\"\"Right rotation\"\"\"\n        new_root = rotation_root.child_left\n        rotation_root.child_left = new_root.child_right\n        if new_root.child_right:\n            new_root.child_right.parent = rotation_root\n        new_root.parent = rotation_root.parent\n        if rotation_root.is_root():\n            self._root = new_root\n        else:\n            if rotation_root.is_child_right():\n                rotation_root.parent.child_right = new_root\n            else:\n                rotation_root.parent.child_left = new_root\n        new_root.child_right = rotation_root\n        rotation_root.parent = new_root\n        rotation_root.balance_factor = (\n            rotation_root.balance_factor - 1 - max(new_root.balance_factor, 0)\n        )\n        new_root.balance_factor = (\n            new_root.balance_factor - 1 + min(rotation_root.balance_factor, 0)\n        )\n","src/lib/pythonds3/trees/binary_heap.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass BinaryHeap:\n    \"\"\"Minimal Binary Heap\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a heap\"\"\"\n        self._heap = []\n\n    def _perc_up(self, cur_idx):\n        \"\"\"Move a node up\"\"\"\n        while (cur_idx - 1) // 2 >= 0:\n            parent_idx = (cur_idx - 1) // 2\n            if self._heap[cur_idx] < self._heap[parent_idx]:\n                self._heap[cur_idx], self._heap[parent_idx] = (\n                    self._heap[parent_idx],\n                    self._heap[cur_idx],\n                )\n            cur_idx = parent_idx\n\n    def _perc_down(self, cur_idx):\n        \"\"\"Move a node down\"\"\"\n        while 2 * cur_idx + 1 < len(self._heap):\n            min_child_idx = self._get_min_child(cur_idx)\n            if self._heap[cur_idx] > self._heap[min_child_idx]:\n                self._heap[cur_idx], self._heap[min_child_idx] = (\n                    self._heap[min_child_idx],\n                    self._heap[cur_idx],\n                )\n            else:\n                return\n            cur_idx = min_child_idx\n\n    def _get_min_child(self, parent_idx):\n        \"\"\"Get a smaller child\"\"\"\n        if 2 * parent_idx + 2 > len(self._heap) - 1:\n            return 2 * parent_idx + 1\n        if self._heap[2 * parent_idx + 1] < self._heap[2 * parent_idx + 2]:\n            return 2 * parent_idx + 1\n        return 2 * parent_idx + 2\n\n    def heapify(self, not_a_heap, show_details=False):\n        \"\"\"Build a heap from any list\"\"\"\n        self._heap = not_a_heap[:]\n        cur_idx = len(self._heap) // 2 - 1\n        while cur_idx >= 0:\n            self._perc_down(cur_idx)\n            cur_idx = cur_idx - 1\n            if show_details:\n                print(self._heap)\n\n    def insert(self, item):\n        \"\"\"Add a new item\"\"\"\n        self._heap.append(item)\n        self._perc_up(len(self._heap) - 1)\n\n    def delete(self):\n        \"\"\"Remove an item\"\"\"\n        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]\n        result = self._heap.pop()\n        self._perc_down(0)\n        return result\n\n    def is_empty(self):\n        \"\"\"Check if the heap is empty\"\"\"\n        return not bool(self._heap)\n\n    def __len__(self):\n        \"\"\"Get heap size\"\"\"\n        return len(self._heap)\n\n    def __str__(self):\n        \"\"\"Heap as a string\"\"\"\n        return str(self._heap)\n\n    def __contains__(self, item):\n        \"\"\"__contains__in method override\"\"\"\n        return item in self._heap\n","src/lib/pythonds3/trees/binary_search_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005, 2010\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass BinaryTreeNode:\n    \"\"\"Binary Tree Node class\"\"\"\n\n    def __init__(self, key, value, left=None, right=None, parent=None):\n        \"\"\"Create new Tree Node\"\"\"\n        self._key = key\n        self._value = value\n        self._child_left = left\n        self._child_right = right\n        self._parent = parent\n\n    def get_child_left(self):\n        \"\"\"Return the node's left child\"\"\"\n        return self._child_left\n\n    def set_child_left(self, node):\n        \"\"\"Assign the node's left child\"\"\"\n        self._child_left = node\n\n    child_left = property(get_child_left, set_child_left)\n\n    def get_child_right(self):\n        \"\"\"Return the node's right child\"\"\"\n        return self._child_right\n\n    def set_child_right(self, node):\n        \"\"\"Assign the node's right child\"\"\"\n        self._child_right = node\n\n    child_right = property(get_child_right, set_child_right)\n\n    def get_parent(self):\n        \"\"\"Return the node's parent\"\"\"\n        return self._parent\n\n    def set_parent(self, node):\n        \"\"\"Assign the node's parent\"\"\"\n        self._parent = node\n\n    parent = property(get_parent, set_parent)\n\n    def is_child_left(self):\n        \"\"\"Check if the node is a left child\"\"\"\n        return self._parent and self._parent.child_left == self\n\n    def is_child_right(self):\n        \"\"\"Check if the node is a right child\"\"\"\n        return self._parent and self._parent.child_right == self\n\n    def is_root(self):\n        \"\"\"Check if the node is a tree root\"\"\"\n        return not self._parent\n\n    def is_leaf(self):\n        \"\"\"Check if the node is a leaf\"\"\"\n        return not (self._child_right or self._child_left)\n\n    def has_a_child(self):\n        \"\"\"Check if the node has any child\"\"\"\n        return self._child_right or self._child_left\n\n    def has_children(self):\n        \"\"\"Check if the node has both children\"\"\"\n        return self._child_right and self._child_left\n\n    def get_key(self):\n        \"\"\"Get node key\"\"\"\n        return self._key\n\n    def set_key(self, key):\n        \"\"\"Set node key\"\"\"\n        self._key = key\n\n    key = property(get_key, set_key)\n\n    def get_value(self):\n        \"\"\"Get node value\"\"\"\n        return self._value\n\n    def set_value(self, value):\n        \"\"\"Set node value\"\"\"\n        self._value = value\n\n    value = property(get_value, set_value)\n\n    def replace_payload(self, key, value, left, right):\n        \"\"\"Change node payload\"\"\"\n        self._key = key\n        self._value = value\n        self._child_left = left\n        self._child_right = right\n        if self.child_left:\n            self._child_left.parent = self\n        if self.child_right:\n            self._child_right.parent = self\n\n    def find_successor(self):\n        \"\"\"Find the node's successor\"\"\"\n        successor = None\n        if self._child_right:\n            successor = self._child_right.find_min()\n        else:\n            if self._parent:\n                if self.is_child_left():\n                    successor = self._parent\n                else:\n                    self._parent.child_right = None\n                    successor = self._parent.find_successor()\n                    self._parent.child_right = self\n        return successor\n\n    def find_min(self):\n        \"\"\"Find the smallest node in the right subtree\"\"\"\n        current = self\n        while current.child_left:\n            current = current.child_left\n        return current\n\n    def splice_out(self):\n        \"\"\"Splice out\"\"\"\n        if self.is_leaf():\n            if self.is_child_left():\n                self._parent.child_left = None\n            else:\n                self._parent.child_right = None\n        elif self.has_a_child():\n            if self.child_left:\n                if self.is_child_left():\n                    self._parent.child_left = self._child_left\n                else:\n                    self._parent.child_right = self._child_left\n                self._child_left.parent = self._parent\n            else:\n                if self.is_child_left():\n                    self._parent.child_left = self._child_right\n                else:\n                    self._parent.child_right = self._child_right\n                self._child_right.parent = self._parent\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree\"\"\"\n        if self:\n            if self._child_left:\n                for elem in self._child_left:\n                    yield elem\n            yield self._key\n            if self._child_right:\n                for elem in self._child_right:\n                    yield elem\n\n\nclass BinarySearchTree:\n    \"\"\"Binary search tree implementation\"\"\"\n\n    def __init__(self):\n        self._root = None\n        self._size = 0\n\n    def __len__(self):\n        \"\"\"Tree size\"\"\"\n        return self._size\n\n    def size(self):\n        \"\"\"Tree size\"\"\"\n        return self._size\n\n    def __iter__(self):\n        \"\"\"Iterator\"\"\"\n        return self._root.__iter__()\n\n    def __getitem__(self, key):\n        \"\"\"[] getter operator override\"\"\"\n        result = self.get(key)\n        if result:\n            return result\n        raise KeyError(\"Error, key not in tree\")\n\n    def get_root(self):\n        \"\"\"Get tree root\"\"\"\n        return self._root\n\n    def set_root(self, node):\n        \"\"\"Set tree root\"\"\"\n        self._root = node\n\n    root = property(get_root, set_root)\n\n    def get(self, key):\n        \"\"\"Retrieve a value by the key\"\"\"\n        if self._root:\n            result = self._get(key, self._root)\n            if result:\n                return result.value\n            return None\n        else:\n            return None\n\n    def _get(self, key, current_node):\n        \"\"\"Retrieve a value by the key (helper function)\"\"\"\n        if not current_node:\n            return None\n        if current_node.key == key:\n            return current_node\n        elif key < current_node.key:\n            return self._get(key, current_node.child_left)\n        else:\n            return self._get(key, current_node.child_right)\n\n    def __setitem__(self, key, value):\n        \"\"\"[] setter operator override\"\"\"\n        self.put(key, value)\n\n    def put(self, key, value):\n        \"\"\"Add new node\"\"\"\n        if self._root:\n            self._put(key, value, self._root)\n        else:\n            self._root = BinaryTreeNode(key, value)\n        self._size = self._size + 1\n\n    def _put(self, key, value, current_node):\n        \"\"\"Add new node (helper function)\"\"\"\n        if key < current_node.key:\n            if current_node.child_left:\n                self._put(key, value, current_node.child_left)\n            else:\n                current_node.child_left = BinaryTreeNode(\n                    key, value, parent=current_node\n                )\n        else:\n            if current_node.child_right:\n                self._put(key, value, current_node.child_right)\n            else:\n                current_node.child_right = BinaryTreeNode(\n                    key, value, parent=current_node\n                )\n\n    def __contains__(self, key):\n        \"\"\"in operator override\"\"\"\n        return bool(self._get(key, self._root))\n\n    def __delitem__(self, key):\n        \"\"\"del operator override\"\"\"\n        self.delete(key)\n\n    def delete(self, key):\n        \"\"\"Remove a node by its key\"\"\"\n        if self._size > 1:\n            node_to_remove = self._get(key, self._root)\n            if node_to_remove:\n                self._delete(node_to_remove)\n                self._size = self._size - 1\n            else:\n                raise KeyError(\"Error, key not in tree\")\n        elif self._size == 1 and self._root.key == key:\n            self._root = None\n            self._size = self._size - 1\n        else:\n            raise KeyError(\"Error, key not in tree\")\n\n    def _delete(self, current_node):\n        \"\"\"Remove a node by its key (helper function)\"\"\"\n        if current_node.is_leaf():  # removing a leaf\n            if current_node == current_node.parent.child_left:\n                current_node.parent.child_left = None\n            else:\n                current_node.parent.child_right = None\n        elif current_node.has_children():  # removing a node with two children\n            successor = current_node.find_successor()\n            successor.splice_out()\n            current_node.key = successor.key\n            current_node.value = successor.value\n        else:  # removing a node with one child\n            if current_node.get_child_left():\n                if current_node.is_child_left():\n                    current_node.child_left.parent = current_node.parent\n                    current_node.parent.child_left = current_node.child_left\n                elif current_node.is_child_right():\n                    current_node.child_left.parent = current_node.parent\n                    current_node.parent.child_right = current_node.child_left\n                else:\n                    current_node.replace_payload(\n                        current_node.child_left.key,\n                        current_node.child_left.value,\n                        current_node.child_left.child_left,\n                        current_node.child_left.child_right,\n                    )\n            else:\n                if current_node.is_child_left():\n                    current_node.child_right.parent = current_node.parent\n                    current_node.parent.child_left = current_node.child_right\n                elif current_node.is_child_right():\n                    current_node.child_right.parent = current_node.parent\n                    current_node.parent.child_right = current_node.child_right\n                else:\n                    current_node.replace_payload(\n                        current_node.child_right.key,\n                        current_node.child_right.value,\n                        current_node.child_right.child_left,\n                        current_node.child_right.child_right,\n                    )\n\n    def inorder(self):\n        \"\"\"In-order tree traversal\"\"\"\n        self._inorder(self._root)\n\n    def _inorder(self, tree):\n        \"\"\"In-order tree traversal (helper function)\"\"\"\n        if tree:\n            self._inorder(tree.child_left)\n            print(tree.key, end=\" \")\n            self._inorder(tree.child_right)\n\n    def postorder(self):\n        \"\"\"Post-order tree traversal\"\"\"\n        self._postorder(self._root)\n\n    def _postorder(self, tree):\n        \"\"\"Post-order tree traversal (helper function)\"\"\"\n        if tree:\n            self._postorder(tree.child_left)\n            self._postorder(tree.child_right)\n            print(tree.key, end=\" \")\n\n    def preorder(self):\n        \"\"\"Pre-order tree traversal\"\"\"\n        self._preorder(self._root)\n\n    def _preorder(self, tree):\n        \"\"\"Pre-order tree traversal (helper function)\"\"\"\n        if tree:\n            print(tree.key, end=\" \")\n            self._preorder(tree.child_left)\n            self._preorder(tree.child_right)\n\n    def clear(self):\n        \"\"\"Remove all nodes\"\"\"\n        while self._root:\n            self.delete(self._root.key)\n","src/lib/pythonds3/trees/binary_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport operator\n\n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n\n    Modified to allow for trees to be constructed from other trees\n    rather than always creating a new tree in the insert_feft or insert_right\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"Create new tree\"\"\"\n        self._key = key\n        self._child_left = None\n        self._child_right = None\n\n    def get_root_val(self):\n        \"\"\"Get root key value\"\"\"\n        return self._key\n\n    def set_root_val(self, key):\n        \"\"\"Set root key value\"\"\"\n        self._key = key\n\n    root = property(get_root_val, set_root_val)\n\n    def get_child_left(self):\n        \"\"\"Get left child\"\"\"\n        return self._child_left\n\n    def set_child_left(self, node):\n        \"\"\"Set left child\"\"\"\n        self._child_left = node\n\n    child_left = property(get_child_left, set_child_left)\n\n    def get_child_right(self):\n        \"\"\"Get right child\"\"\"\n        return self._child_right\n\n    def set_child_right(self, node):\n        \"\"\"Set right child\"\"\"\n        self._child_right = node\n\n    child_right = property(get_child_right, set_child_right)\n\n    def is_leaf(self):\n        \"\"\"Check if a node is leaf\"\"\"\n        return (not self._child_left) and (not self._child_right)\n\n    def insert_left(self, new_node):\n        \"\"\"Insert left subtree\"\"\"\n        if isinstance(new_node, BinaryTree):\n            new_subtree = new_node\n        else:\n            new_subtree = BinaryTree(new_node)\n\n        if self._child_left:\n            new_subtree.set_child_left(self._child_left)\n\n        self._child_left = new_subtree\n\n    def insert_right(self, new_node):\n        \"\"\"Insert right subtree\"\"\"\n        if isinstance(new_node, BinaryTree):\n            new_subtree = new_node\n        else:\n            new_subtree = BinaryTree(new_node)\n\n        if self._child_right:\n            new_subtree.set_child_right(self._child_right)\n        self._child_right = new_subtree\n\n    def preorder(self):\n        \"\"\"Pre-order tree traversal\"\"\"\n        print(self._key, end=\" \")\n        if self._child_left:\n            self._child_left.preorder()\n        if self._child_right:\n            self._child_right.preorder()\n\n    def inorder(self):\n        \"\"\"In-order tree traversal\"\"\"\n        if self._child_left:\n            self._child_left.inorder()\n        print(self._key, end=\" \")\n        if self._child_right:\n            self._child_right.inorder()\n\n    def postorder(self):\n        \"\"\"Post-order tree traversal\"\"\"\n        if self._child_left:\n            self._child_left.postorder()\n        if self._child_right:\n            self._child_right.postorder()\n        print(self._key, end=\" \")\n\n    def print_exp(self):\n        \"\"\"Print an expression\"\"\"\n        if self._child_left:\n            print(\"(\", end=\" \")\n            self._child_left.print_exp()\n        print(self._key, end=\" \")\n        if self._child_right:\n            self._child_right.print_exp()\n            print(\")\", end=\" \")\n\n    def postorder_eval(self):\n        \"\"\"Postorder evaluation\"\"\"\n        operations = {\n            \"+\": operator.add,\n            \"-\": operator.sub,\n            \"*\": operator.mul,\n            \"/\": operator.truediv,\n        }\n        result_1 = None\n        result_2 = None\n        if self._child_left:\n            result_1 = self._child_left.postorder_eval()\n        if self._child_right:\n            result_2 = self._child_right.postorder_eval()\n        if result_1 and result_2:\n            return operations[self._key](result_1, result_2)\n        return self._key\n\n    def height(self):\n        \"\"\"Height of a tree\"\"\"\n        if not self._key:\n            return -1\n        if self._child_left:\n            height_left = self._child_left.height()\n        else:\n            height_left = -1\n\n        if self._child_right:\n            height_right = self._child_right.height()\n        else:\n            height_right = -1\n\n        return 1 + max(height_left, height_right)\n\n    def __len__(self):\n        \"\"\"Size of a tree\"\"\"\n        return self.size()\n\n    def size(self):\n        \"\"\"Count nodes in a tree\"\"\"\n        if not self._key:\n            return 0\n        if self._child_left:\n            children_left = self._child_left.size()\n        else:\n            children_left = 0\n\n        if self._child_right:\n            children_right = self._child_right.size()\n        else:\n            children_right = 0\n\n        return 1 + children_left + children_right\n","src/lib/pythonds3/trees/priority_queue.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nfrom pythonds3.trees.binary_heap import BinaryHeap\n\n\nclass PriorityQueue(BinaryHeap):\n    \"\"\"\n    This implementation of binary heap takes (key, value) pairs where key signifies priority\n    We will assume that the keys are all comparable.\n    \"\"\"\n\n    def change_priority(self, new_priority, value):\n        \"\"\"Change the priority\"\"\"\n        key_to_move = 0\n        for i in range(len(self._heap)):\n            if self._heap[i][1] == value:\n                key_to_move = i\n                break\n        if key_to_move > -1:\n            self._heap[key_to_move] = (new_priority, self._heap[key_to_move][1])\n            self._perc_up(key_to_move)\n","src/lib/pythoned/__init__.py":"","src/lib/pythoned/arboles/__init__.py":"\n\n\nfrom .avl import ArbolAVL\nfrom .abb import ArbolBinarioBusqueda\nfrom .monticuloBinario import MonticuloBinario\n\n\n","src/lib/pythoned/arboles/abb.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#abb.py\n\nclass ArbolBinarioBusqueda:\n\n    def __init__(self):\n        self.raiz = None\n        self.tamano = 0\n\n    def agregar(self,clave,valor):\n        if self.raiz:\n            self._agregar(clave,valor,self.raiz)\n        else:\n            self.raiz = NodoArbol(clave,valor)\n        self.tamano = self.tamano + 1\n\n    def _agregar(self,clave,valor,nodoActual):\n        if clave < nodoActual.clave:\n            if nodoActual.tieneHijoIzquierdo():\n                   self._agregar(clave,valor,nodoActual.hijoIzquierdo)\n            else:\n                   nodoActual.hijoIzquierdo = NodoArbol(clave,valor,padre=nodoActual)\n        else:\n            if nodoActual.tieneHijoDerecho():\n                   self._agregar(clave,valor,nodoActual.hijoDerecho)\n            else:\n                   nodoActual.hijoDerecho = NodoArbol(clave,valor,padre=nodoActual)\n \n    def __setitem__(self,c,v):\n        self.agregar(c,v)\n\n    def obtener(self,clave):\n        if self.raiz:\n            res = self._obtener(clave,self.raiz)\n            if res:\n                return res.cargaUtil\n            else:\n                return None\n        else:\n            return None\n\n    def _obtener(self,clave,nodoActual):\n    \tif not nodoActual:\n    \t    return None\n    \telif nodoActual.clave == clave:\n    \t    return nodoActual\n    \telif clave < nodoActual.clave:\n    \t    return self._obtener(clave,nodoActual.hijoIzquierdo)\n    \telse:\n    \t    return self._obtener(clave,nodoActual.hijoDerecho)        \n\n    def __getitem__(self,clave):\n        res = self.obtener(clave) \n        if res:\n            return res\n        else:\n            raise KeyError('Error, la clave no está en el árbol')\n\n    def __contains__(self,clave):\n    \tif self._obtener(clave,self.raiz):\n    \t    return True\n    \telse:\n    \t    return False\n       \n    def longitud(self):\n        return self.tamano\n\n    def __len__(self):\n        return self.tamano\n\n    def __iter__(self):\n        return self.raiz.__iter__()\n\n    def eliminar(self,clave):\n        if self.tamano > 1:\n           nodoAEliminar = self._obtener(clave,self.raiz)\n    \t   if nodoAEliminar:\n    \t       self.remover(nodoAEliminar)\n    \t       self.tamano = self.tamano-1\n    \t   else:\n    \t       raise KeyError('Error, la clave no está en el árbol')\n        elif self.tamano == 1 and self.raiz.clave == clave:\n    \t    self.raiz = None\n    \t    self.tamano = self.tamano - 1\n        else:\n    \t    raise KeyError('Error, la clave no está en el árbol')\n\n    def __delitem__(self,clave):\n        self.eliminar(clave)\n\n    def remover(self,nodoActual):\n        if nodoActual.esHoja(): #hoja\n            if nodoActual == nodoActual.padre.hijoIzquierdo:\n                nodoActual.padre.hijoIzquierdo = None\n            else:\n                nodoActual.padre.hijoDerecho = None\n        elif nodoActual.tieneAmbosHijos(): #interior\n            suc = nodoActual.encontrarSucesor()\n            suc.empalmar()\n            nodoActual.clave = suc.clave\n            nodoActual.cargaUtil = suc.cargaUtil\n\n        else: # este nodo tiene un (1) hijo\n            if nodoActual.tieneHijoIzquierdo():\n                if nodoActual.esHijoIzquierdo():\n                    nodoActual.hijoIzquierdo.padre = nodoActual.padre\n                    nodoActual.padre.hijoIzquierdo = nodoActual.hijoIzquierdo\n                elif nodoActual.esHijoDerecho():\n                    nodoActual.hijoIzquierdo.padre = nodoActual.padre\n                    nodoActual.padre.hijoDerecho = nodoActual.hijoIzquierdo\n                else:\n                    nodoActual.reemplazarDatoDeNodo(nodoActual.hijoIzquierdo.clave, nodoActual.hijoIzquierdo.cargaUtil, nodoActual.hijoIzquierdo.hijoIzquierdo, nodoActual.hijoIzquierdo.hijoDerecho)\n            else:\n                if nodoActual.esHijoIzquierdo():\n                    nodoActual.hijoDerecho.padre = nodoActual.padre\n                    nodoActual.padre.hijoIzquierdo = nodoActual.hijoDerecho\n                elif nodoActual.esHijoDerecho():\n                    nodoActual.hijoDerecho.padre = nodoActual.padre\n                    nodoActual.padre.hijoDerecho = nodoActual.hijoDerecho\n                else:\n                    nodoActual.reemplazarDatoDeNodo(nodoActual.hijoDerecho.clave, nodoActual.hijoDerecho.cargaUtil, nodoActual.hijoDerecho.hijoIzquierdo, nodoActual.hijoDerecho.hijoDerecho)\n\n    def inorden(self):\n        self._inorden(self.raiz)\n\n    def _inorden(self,arbol):\n        if arbol != None:\n            self._inorden(arbol.hijoIzquierdo)\n            print(arbol.clave)\n            self._inorden(arbol.hijoDerecho)\n\n    def postorden(self):\n        self._postorden(self.raiz)\n\n    def _postorden(self, arbol):\n        if arbol:\n            self._postorden(arbol.hijoDerecho)\n            self._postorden(arbol.hijoIzquierdo)\n            print(arbol.clave)            \n\n    def preorden(self):\n        self._preorden(self,self.raiz)\n\n    def _preorden(self,arbol):\n        if arbol:\n            print(arbol.clave)            \n            self._preorden(arbol.hijoIzquierdo)\n            self._preorden(arbol.hijoDerecho)\n\n\nclass NodoArbol:\n   def __init__(self,clave,valor,izquierdo=None,derecho=None,padre=None):\n        self.clave = clave\n        self.cargaUtil = valor\n        self.hijoIzquierdo = izquierdo\n        self.hijoDerecho = derecho\n        self.padre = padre\n        self.factorEquilibrio = 0\n\n    def tieneHijoIzquierdo(self):\n        return self.hijoIzquierdo\n       \n    def tieneHijoDerecho(self):\n        return self.hijoDerecho\n\n    def esHijoIzquierdo(self):\n        return self.padre and self.padre.hijoIzquierdo == self\n    \n    def esHijoDerecho(self):\n        return self.padre and self.padre.hijoDerecho == self\n\n    def esRaiz(self):\n        return not self.padre\n\n    def esHoja(self):\n        return not (self.hijoDerecho or self.hijoIzquierdo)\n\n    def tieneAlgunHijo(self):\n        return self.hijoDerecho or self.hijoIzquierdo\n\n    def tieneAmbosHijos(self):\n        return self.hijoDerecho and self.hijoIzquierdo\n\n    def reemplazarDatoDeNodo(self,clave,valor,hizq,hder):\n        self.clave = clave\n        self.cargaUtil = valor\n        self.hijoIzquierdo = hizq\n        self.hijoDerecho = hder\n        if self.tieneHijoIzquierdo():\n            self.hijoIzquierdo.padre = self\n        if self.tieneHijoDerecho():\n            self.hijoDerecho.padre = self    \n\n    def encontrarSucesor(self):\n        suc = None\n        if self.tieneHijoDerecho():\n            suc = self.hijoDerecho.encontrarMin()\n        else:\n            if self.padre:\n                if self.esHijoIzquierdo():\n                    suc = self.padre\n                else:\n                    self.padre.hijoDerecho = None\n                    suc = self.padre.encontrarSucesor()\n                    self.padre.hijoDerecho = self\n        return suc\n\n    def empalmar(self):\n        if self.esHoja():\n            if self.esHijoIzquierdo():\n                self.padre.hijoIzquierdo = None\n            else:\n                self.padre.hijoDerecho = None\n        elif self.tieneAlgunHijo():\n            if self.tieneHijoIzquierdo():\n                if self.esHijoIzquierdo():\n                    self.padre.hijoIzquierdo = self.hijoIzquierdo\n                else:\n                    self.padre.hijoDerecho = self.hijoIzquierdo\n                self.hijoIzquierdo.padre = self.padre\n            else:\n                if self.esHijoIzquierdo():\n                    self.padre.hijoIzquierdo = self.hijoDerecho\n                else:\n                    self.padre.hijoDerecho = self.hijoDerecho\n                self.hijoDerecho.padre = self.padre\n\n    def encontrarMin(self):\n        actual = self\n        while actual.tieneHijoIzquierdo():\n            actual = actual.hijoIzquierdo\n        return actual\n\n    def __iter__(self):\n        if self:\n    \t    if self.tieneHijoIzquierdo():\n    \t        for elem in self.hijoIzquierdo:\n    \t\t    yield elem\n            yield self.clave\n    \t    if self.tieneHijoDerecho():\n                for elem in self.hijoDerecho:\n    \t\t    yield elem\n","src/lib/pythoned/arboles/arbolBinario.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#arbolBinario.py\n\nclass ArbolBinario:\n    def __init__(self,objetoRaiz):\n        self.clave = objetoRaiz\n        self.hijoIzquierdo = None\n        self.hijoDerecho = None\n    \n    def insertarIzquierdo(self,nuevoNodo):\n        if self.hijoIzquierdo == None:\n            self.hijoIzquierdo = ArbolBinario(nuevoNodo)\n        else:  \n            t = ArbolBinario(nuevoNodo)\n            t.hijoIzquierdo = self.hijoIzquierdo\n            self.hijoIzquierdo = t\n\n    def insertarDerecho(self,nuevoNodo):\n        if self.hijoDerecho == None:\n            self.hijoDerecho = ArbolBinario(nuevoNodo)\n        else:\n            t = ArbolBinario(nuevoNodo)\n            t.hijoDerecho = self.hijoDerecho\n            self.hijoDerecho = t\n\n    def esHoja(self):\n        return ((not self.hijoIzquierdo) and (not self.hijoDerecho))\n\n    def obtenerHijoDerecho(self):\n        return self.hijoDerecho\n    \n    def obtenerHijoIzquierdo(self):\n        return self.hijoIzquierdo\n    \n    def asignarValorRaiz(self,obj):\n        self.clave = obj\n\n    def obtenerValorRaiz(self):\n        return self.clave\n\n    def inorden(self):\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.inorden()\n        print(self.clave)\n        if self.hijoDerecho:\n            self.hijoDerecho.inorden()\n\n    def postorden(self):\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.postorden()\n        if self.hijoDerecho:\n            self.hijoDerecho.postorden()\n        print(self.clave)\n\n    def preorden(self):\n        print(self.clave)\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.preorden()\n        if self.hijoDerecho:\n            self.hijoDerecho.preorden()\n\n    def imprimirExpresion(self):\n        if self.hijoIzquierdo:\n            print('(', end=' ')\n            self.hijoIzquierdo.imprimirExpresion()\n        print(self.clave, end=' ')\n        if self.hijoDerecho:\n            self.hijoDerecho.imprimirExpresion()\n            print(')', end=' ')\n\n    def evalPostorden(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.hijoIzquierdo:\n            res1 = self.hijoIzquierdo.evalPostorden()  #// \\label{peleft}\n        if self.hijoDerecho:\n            res2 = self.hijoDerecho.evalPostorden() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.clave](res1,res2) #// \\label{peeval}\n        else:\n            return self.clave\n\ndef inorden(arbol):\n    if arbol != None:\n        inorden(arbol.obtenerHijoIzquierdo())\n        print(arbol.obtenerValorRaiz())\n        inorden(arbol.obtenerHijoDerecho())\n\ndef imprimirExpresion(arbol):\n    if arbol.hijoIzquierdo:\n        print('(', end=' ')\n        imprimirExpresion(arbol.obtenerHijoIzquierdo())\n    print(arbol.obtenerValorRaiz(), end=' ')\n    if arbol.hijoDerecho:\n        imprimirExpresion(arbol.obtenerHijoDerecho())\n        print(')', end=' ') \n\ndef imprimirExpresion(arbol):\n  valorCadena = \"\"\n  if arbol:\n      valorCadena = '(' + imprimirExpresion(arbol.obtenerHijoIzquierdo())\n      valorCadena = valorCadena + str(arbol.obtenerValorRaiz())\n      valorCadena = valorCadena + imprimirExpresion(arbol.obtenerHijoDerecho())+')'\n  return valorCadena\n\ndef evalPostorden(arbol):\n    operadores = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if arbol:\n        res1 = evalPostorden(arbol.obtenerHijoIzquierdo()) #// \\label{peleft}\n        res2 = evalPostorden(arbol.obtenerHijoDerecho())  #// \\label{peright}\n        if res1 and res2:\n            return operadores[arbol.obtenerValorRaiz()](res1,res2) #// \\label{peeval}\n        else:\n            return arbol.obtenerValorRaiz()\n\ndef altura(arbol):\n    if arbol == None:\n        return -1\n    else:\n        return 1 + max(altura(arbol.hijoIzquierdo),altura(arbol.hijoDerecho))\n\nt = ArbolBinario(7)\nt.insertarIzquierdo(3)\nt.insertarDerecho(9)\ninorden(t)\nimport operator\nx = ArbolBinario('*')\nx.insertarIzquierdo('+')\nl = x.obtenerHijoIzquierdo()\nl.insertarIzquierdo(4)\nl.insertarDerecho(5)\nx.insertarDerecho(7)\nprint(imprimirExpresion(x))\nprint(evalPostorden(x))\nprint(altura(x))\n","src/lib/pythoned/arboles/avl.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#avl.py\n\nfrom .abb import ArbolBinarioBusqueda, NodoArbol\n\nclass ArbolAVL(ArbolBinarioBusqueda):\n\n    def _agregar(self,clave,valor,nodoActual):\n    \tif clave < nodoActual.clave:\n    \t    if nodoActual.tieneHijoIzquierdo():\n    \t\tself._agregar(clave,valor,nodoActual.hijoIzquierdo)\n    \t    else:\n    \t\tnodoActual.hijoIzquierdo = NodoArbol(clave,valor,padre=nodoActual)\n    \t\tself.actualizarEquilibrio(nodoActual.hijoIzquierdo)\n    \telse:\n    \t    if nodoActual.tieneHijoDerecho():\n    \t\tself._agregar(clave,valor,nodoActual.hijoDerecho)\n    \t    else:\n    \t\tnodoActual.hijoDerecho = NodoArbol(clave,valor,padre=nodoActual)\n    \t\tself.actualizarEquilibrio(nodoActual.hijoDerecho)\n\n    def actualizarEquilibrio(self,nodo):\n    \tif nodo.factorEquilibrio > 1 or nodo.factorEquilibrio < -1:\n    \t    self.reequilibrar(nodo)    \n    \t    return\n    \tif nodo.padre != None:\n    \t    if nodo.esHijoIzquierdo():\n    \t\t    nodo.padre.factorEquilibrio += 1\n    \t    elif nodo.esHijoDerecho():\n    \t\t    nodo.padre.factorEquilibrio -= 1\n\n    \t    if nodo.padre.factorEquilibrio != 0:\n    \t\t    self.actualizarEquilibrio(nodo.padre)\n\n    def reequilibrar(self,nodo):\n        if nodo.factorEquilibrio < 0:\n\t    if nodo.hijoDerecho.factorEquilibrio > 0:\n\t        self.rotarDerecha(nodo.hijoDerecho)\n\t        self.rotarIzquierda(nodo)\n\t    else:\n\t        self.rotarIzquierda(nodo)\n        elif nodo.factorEquilibrio > 0:\n\t    if nodo.hijoIzquierdo.factorEquilibrio < 0:\n\t        self.rotarIzquierda(nodo.hijoIzquierdo)\n\t        self.rotarDerecha(nodo)\n\t     else:\n\t        self.rotarDerecha(nodo)\n           \n    def rotarIzquierda(self,rotRaiz):\n    \tnuevaRaiz = rotRaiz.hijoDerecho\n    \trotRaiz.hijoDerecho = nuevaRaiz.hijoIzquierdo\n    \tif nuevaRaiz.hijoIzquierdo != None:\n    \t    nuevaRaiz.hijoIzquierdo.padre = rotRaiz\n    \tnuevaRaiz.padre = rotRaiz.padre\n    \tif rotRaiz.esRaiz():\n    \t    self.raiz = nuevaRaiz\n    \telse:\n    \t    if rotRaiz.esHijoIzquierdo():\n    \t        rotRaiz.padre.hijoIzquierdo = nuevaRaiz\n    \t    else:\n    \t    \trotRaiz.padre.hijoDerecho = nuevaRaiz\n    \tnuevaRaiz.hijoIzquierdo = rotRaiz\n    \trotRaiz.padre = nuevaRaiz\n    \trotRaiz.factorEquilibrio = rotRaiz.factorEquilibrio + 1 - min(nuevaRaiz.factorEquilibrio, 0)\n    \tnuevaRaiz.factorEquilibrio = nuevaRaiz.factorEquilibrio + 1 + max(rotRaiz.factorEquilibrio, 0)\n\n    def rotarDerecha(self,rotRaiz):\n        nuevaRaiz = rotRaiz.hijoIzquierdo\n        rotRaiz.hijoIzquierdo = nuevaRaiz.hijoDerecho\n        if nuevaRaiz.hijoDerecho != None:\n            nuevaRaiz.hijoDerecho.padre = rotRaiz\n        nuevaRaiz.padre = rotRaiz.padre\n        if rotRaiz.esRaiz():\n            self.raiz = nuevaRaiz\n        else:\n            if rotRaiz.esHijoDerecho():\n                rotRaiz.padre.hijoDerecho = nuevaRaiz\n            else:\n                rotRaiz.padre.hijoIzquierdo = nuevaRaiz\n        nuevaRaiz.hijoDerecho = rotRaiz\n        rotRaiz.padre = nuevaRaiz\n        rotRaiz.factorEquilibrio = rotRaiz.factorEquilibrio - 1 - max(nuevaRaiz.factorEquilibrio, 0)\n        nuevaRaiz.factorEquilibrio = nuevaRaiz.factorEquilibrio - 1 + min(rotRaiz.factorEquilibrio, 0)  \n\n","src/lib/pythoned/arboles/monticuloBinario.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#monticuloBinario.py\n\nclass MonticuloBinario:\n    def __init__(self):\n        self.listaMonticulo = [0]\n        self.tamanoActual = 0\n\n    def construirMonticulo(self,unaLista):\n        i = len(unaLista) // 2\n        self.tamanoActual = len(unaLista)\n        self.listaMonticulo = [0] + unaLista[:]\n        print(len(self.listaMonticulo), i)\n        while (i > 0):\n            print(self.listaMonticulo, i)\n            self.infiltAbajo(i)\n            i = i - 1\n        print(self.listaMonticulo,i)\n                        \n    def infiltAbajo(self,i):\n        while (i * 2) <= self.tamanoActual:\n            hm = self.hijoMin(i)\n            if self.listaMonticulo[i] > self.listaMonticulo[hm]:\n                tmp = self.listaMonticulo[i]\n                self.listaMonticulo[i] = self.listaMonticulo[hm]\n                self.listaMonticulo[hm] = tmp\n            i = hm\n                \n    def hijoMin(self,i):\n        if i * 2 + 1 > self.tamanoActual:\n            return i * 2\n        else:\n            if self.listaMonticulo[i * 2] < self.listaMonticulo[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def infiltArriba(self,i):\n        while i // 2 > 0:\n            if self.listaMonticulo[i] < self.listaMonticulo[i//2]:\n               tmp = self.listaMonticulo[i // 2]\n               self.listaMonticulo[i // 2] = self.listaMonticulo[i]\n               self.listaMonticulo[i] = tmp\n            i = i // 2\n \n    def insertar(self,k):\n        self.listaMonticulo.append(k)\n        self.tamanoActual = self.tamanoActual + 1\n        self.infiltArriba(self.tamanoActual)\n\n    def eliminarMin(self):\n        valorSacado = self.listaMonticulo[1]\n        self.listaMonticulo[1] = self.listaMonticulo[self.tamanoActual]\n        self.tamanoActual = self.tamanoActual - 1\n        self.listaMonticulo.pop()\n        self.infiltAbajo(1)\n        return valorSacado\n        \n    def estaVacio(self):\n        if tamanoActual == 0:\n            return True\n        else:\n            return False\n","src/lib/pythoned/basicas/__init__.py":"\n#__all__ = [\"pila\"]\n\n\nfrom .pila import Pila\nfrom .cola import Cola\nfrom .coladoble import ColaDoble\n\n\n","src/lib/pythoned/basicas/cola.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#cola.py\n\nclass Cola:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def agregar(self, item):\n        self.items.insert(0,item)\n\n    def avanzar(self):\n        return self.items.pop()\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/basicas/coladoble.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#coladoble.py\n\nclass ColaDoble:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def agregarFrente(self, item):\n        self.items.append(item)\n\n    def agregarFinal(self, item):\n        self.items.insert(0,item)\n\n    def removerFrente(self):\n        return self.items.pop()\n\n    def removerFinal(self):\n        return self.items.pop(0)\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/basicas/pila.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#pila.py\n\nclass Pila:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def incluir(self, item):\n        self.items.append(item)\n\n    def extraer(self):\n        return self.items.pop()\n\n    def inspeccionar(self):\n        return self.items[len(self.items)-1]\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/grafos/__init__.py":"\n\nfrom .grafoAdy import Grafo\nfrom .grafoAdy import Vertice\nfrom .colaPrioridad import ColaPrioridad\n","src/lib/pythoned/grafos/colaPrioridad.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#colaPrioridad.py\n\nclass ColaPrioridad:\n    def __init__(self):\n        self.arregloMonticulo = [(0,0)]\n        self.tamanoActual = 0\n\n    def construirMonticulo(self,unaLista):\n        self.tamanoActual = len(unaLista)\n        self.arregloMonticulo = [(0,0)]\n        for i in unaLista:\n            self.arregloMonticulo.append(i)\n        i = len(unaLista) // 2            \n        while (i > 0):\n            self.infiltAbajo(i)\n            i = i - 1\n                        \n    def infiltAbajo(self,i):\n        while (i * 2) <= self.tamanoActual:\n            hm = self.hijoMin(i)\n            if self.arregloMonticulo[i][0] > self.arregloMonticulo[hm][0]:\n                tmp = self.arregloMonticulo[i]\n                self.arregloMonticulo[i] = self.arregloMonticulo[hm]\n                self.arregloMonticulo[hm] = tmp\n            i = hm\n                \n    def hijoMin(self,i):\n        if i*2 > self.tamanoActual:\n            return -1\n        else:\n            if i*2 + 1 > self.tamanoActual:\n                return i*2\n            else:\n                if self.arregloMonticulo[i*2][0] < self.arregloMonticulo[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def infiltArriba(self,i):\n        while i // 2 > 0:\n            if self.arregloMonticulo[i][0] < self.arregloMonticulo[i//2][0]:\n               tmp = self.arregloMonticulo[i//2]\n               self.arregloMonticulo[i//2] = self.arregloMonticulo[i]\n               self.arregloMonticulo[i] = tmp\n            i = i//2\n \n    def insertar(self,k):\n        self.arregloMonticulo.append(k)\n        self.tamanoActual = self.tamanoActual + 1\n        self.infiltArriba(self.tamanoActual)\n\n    def eliminarMin(self):\n        valorSacado = self.arregloMonticulo[1][1]\n        self.arregloMonticulo[1] = self.arregloMonticulo[self.tamanoActual]\n        self.tamanoActual = self.tamanoActual - 1\n        self.arregloMonticulo.pop()\n        self.infiltAbajo(1)\n        return valorSacado\n        \n    def estaVacia(self):\n        if self.tamanoActual == 0:\n            return True\n        else:\n            return False\n\n    def decrementarClave(self,valor,nuevo):\n        hecho = False\n        i = 1\n        miClave = 0\n        while not hecho and i <= self.tamanoActual:\n            if self.arregloMonticulo[i][1] == valor:\n                hecho = True\n                miClave = i\n            else:\n                i = i + 1\n        if miClave > 0:\n            self.arregloMonticulo[miClave] = (nuevo,self.arregloMonticulo[miClave][1])\n            self.infiltArriba(miClave)\n            \n    def __contains__(self,vertice):\n        for pareja in self.arregloMonticulo:\n            if pareja[1] == vertice:\n                return True\n        return False     \n\n","src/lib/pythoned/grafos/grafoAdy.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#grafoAdy.py\n\n\nimport sys\n\nclass Grafo:\n    def __init__(self):\n        self.listaVertices = {}\n        self.numVertices = 0\n        \n    def agregarVertice(self,clave):\n        self.numVertices = self.numVertices + 1\n        nuevoVertice = Vertice(clave)\n        self.listaVertices[clave] = nuevoVertice\n        return nuevoVertice\n    \n    def obtenerVertice(self,n):\n        if n in self.listaVertices:\n            return self.listaVertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.listaVertices\n    \n    def agregarArista(self,de,a,costo=0):\n            if de not in self.listaVertices:\n                nv = self.agregarVertice(de)\n            if a not in self.listaVertices:\n                nv = self.agregarVertice(a)\n            self.listaVertices[de].agregarVecino(self.listaVertices[a],costo)\n    \n    def obtenerVertices(self):\n        return list(self.listaVertices.keys())\n        \n    def __iter__(self):\n        return iter(self.listaVertices.values())\n                \nclass Vertice:\n    def __init__(self,clave):\n        self.id = clave\n        self.conectadoA = {}\n        self.color = 'blanco'\n        self.dist = sys.maxsize\n        self.predecesor = None\n        self.desc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def  agregarVecino(self,vecino,ponderacion=0):\n        self.conectadoA[vecino] = ponderacion\n        \n    def asignarColor(self,color):\n        self.color = color\n        \n    def asignarDistancia(self,d):\n        self.dist = d\n\n    def asignarPredecesor(self,p):\n        self.predecesor = p\n\n    def asignarDescubrimiento(self,tiempoDescubrimiento):\n        self.desc = tiempoDescubrimiento\n        \n    def asignarFinalizacion(self,tiempoFinalizacion):\n        self.fin = tiempoFinalizacion\n        \n    def obtenerFinalizacion(self):\n        return self.fin\n        \n    def obtenerDescubrimiento(self):\n        return self.desc\n        \n    def obtenerPredecesor(self):\n        return self.predecesor\n        \n    def obtenerDistancia(self):\n        return self.dist\n        \n    def obtenerColor(self):\n        return self.color\n    \n    def obtenerConexiones(self):\n        return self.conectadoA.keys()\n        \n    def obtenerPonderacion(self,vecino):\n        return self.conectadoA[vecino]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":desc \" + str(self.desc) + \":fin \" + str(self.fin) + \":distancia \" + str(self.dist) + \":predecesor \\n\\t[\" + str(self.predecesor)+ \"]\\n\"\n    \n    def obtenerId(self):\n        return self.id\n","src/lib/quopri.py":"import _sk_fail; _sk_fail._(\"quopri\")\n","src/lib/repr.py":"import _sk_fail; _sk_fail._(\"repr\")\n","src/lib/requests.py":"# most restricted version\n\"\"\"\nThis solution works in runestone - however it is much more limited.\nAn error does not occur in the same way in the textbook as it does\nfor the command line. Since HTTPError is not currently available in\nRunestone, I had to change the exception.\nDecode and Encode are not available in Runestone, so there might be\nissues with reponses.\nDoes not use the status attribute for urlopen, would be nice to have\nthat back.\nDoes not work on regular web pages (like google or the michigan daily) because of cross-site scripting limits.\n\"\"\"\nfrom urllib.request import urlopen\nimport json\n\nclass Response:\n    def __init__(self, data, url):\n        self.text = data\n        self.url = url\n\n    def json(self):\n        try:\n            return json.loads(self.text)\n        except:\n            return {\"error\": \"Response not interpretable as json. Try printing the .text attribute\"}\n\n    def __str__(self):\n        return \"<A Response object for the following request: {}>\".format(self.url)\n\n\nurl_subs = {\" \": \"+\",\n            \"!\": \"%21\",\n            '\"': \"%22\",\n            \"#\": \"%23\",\n            \"$\": \"%24\",\n            \"'\": \"%27\",\n            \"(\": \"%28\",\n            \")\": \"%29\",\n            \"*\": \"%2A\",\n            \"+\": \"%2B\",\n            \",\": \"%2C\",\n            \"/\": \"%2F\",\n            \":\": \"%3A\",\n            \";\": \"%3B\",\n            \"=\": \"%3D\",\n            \"?\": \"%3F\",\n            \"@\": \"%40\",\n            \"[\": \"%5B\",\n            \"]\": \"%5D\",\n            }\n\ndef _subst(s, substitutions=url_subs):\n    res = \"\"\n    for c in str(s):\n        if c in substitutions:\n            res += substitutions[c]\n        else:\n            res += c\n    return res\n\n\ndef requestURL(baseurl, params={}):\n    try:\n        if len(params) == 0:\n            return baseurl\n        complete_url = baseurl + \"?\"\n        pairs = [\"{}={}\".format(_subst(k), _subst(params[k])) for k in params]\n        complete_url += \"&\".join(pairs)\n        return complete_url\n    except:\n        return None\n\ndef get(baseurl, params={}):\n    full_url = requestURL(baseurl, params)\n    if not full_url:\n        text_data = \"<html><body><h1>invalid request</h1></body></html>\"\n        full_url = \"Couldn’t generate a valid URL\"\n    else:\n        data = urlopen(full_url)\n        text_data = data.read().strip()\n        if len(text_data) == 0:\n            text_data = \"Failed to retrieve that URL\"\n    return Response(text_data, full_url)","src/lib/requests_with_caching.py":"import requests\nimport json\n\nPERMANENT_CACHE_FNAME = \"permanent_cache.txt\"\nTEMP_CACHE_FNAME = \"this_page_cache.txt\"\n\ndef _write_to_file(cache, fname):\n    with open(fname, 'w') as outfile:\n        outfile.write(json.dumps(cache, indent=2))\n\ndef _read_from_file(fname):\n    try:\n        with open(fname, 'r') as infile:\n            res = infile.read()\n            return json.loads(res)\n    except:\n        return {}\n\ndef add_to_cache(cache_file, cache_key, cache_value):\n    temp_cache = _read_from_file(cache_file)\n    temp_cache[cache_key] = cache_value\n    _write_to_file(temp_cache, cache_file)\n\ndef clear_cache(cache_file=TEMP_CACHE_FNAME):\n    _write_to_file({}, cache_file)\n\ndef make_cache_key(baseurl, params_d, private_keys=[\"api_key\", \"apikey\"]):\n    \"\"\"Makes a long string representing the query.\n    Alphabetize the keys from the params dictionary so we get the same order each time.\n    Omit keys with private info.\"\"\"\n    alphabetized_keys = sorted(params_d.keys())\n    res = []\n    for k in alphabetized_keys:\n        if k not in private_keys:\n            res.append(\"{}-{}\".format(k, params_d[k]))\n    return baseurl + \"_\".join(res)\n\ndef get(baseurl, params={}, private_keys_to_ignore=[\"api_key\", \"apikey\"], permanent_cache_file=PERMANENT_CACHE_FNAME, temp_cache_file=TEMP_CACHE_FNAME):\n    full_url = requests.requestURL(baseurl, params)\n    cache_key = make_cache_key(baseurl, params, private_keys_to_ignore)\n    # Load the permanent and page-specific caches from files\n    permanent_cache = _read_from_file(permanent_cache_file)\n    temp_cache = _read_from_file(temp_cache_file)\n    if cache_key in temp_cache:\n        print(\"found in page-specific cache\")\n        # make a Response object containing text from the change, and the full_url that would have been fetched\n        return requests.Response(temp_cache[cache_key], full_url)\n    elif cache_key in permanent_cache:\n        print(\"found in permanent_cache\")\n        # make a Response object containing text from the change, and the full_url that would have been fetched\n        return requests.Response(permanent_cache[cache_key], full_url)\n    else:\n        print(\"new; adding to cache\")\n        # actually request it\n        resp = requests.get(baseurl, params)\n        # save it\n        add_to_cache(temp_cache_file, cache_key, resp.text)\n        return resp","src/lib/rexec.py":"import _sk_fail; _sk_fail._(\"rexec\")\n","src/lib/rfc822.py":"import _sk_fail; _sk_fail._(\"rfc822\")\n","src/lib/rlcompleter.py":"import _sk_fail; _sk_fail._(\"rlcompleter\")\n","src/lib/robotparser.py":"import _sk_fail; _sk_fail._(\"robotparser\")\n","src/lib/runpy.py":"import _sk_fail; _sk_fail._(\"runpy\")\n","src/lib/sched.py":"import _sk_fail; _sk_fail._(\"sched\")\n","src/lib/sets.py":"import _sk_fail; _sk_fail._(\"sets\")\n","src/lib/sgmllib.py":"import _sk_fail; _sk_fail._(\"sgmllib\")\n","src/lib/sha.py":"import _sk_fail; _sk_fail._(\"sha\")\n","src/lib/shelve.py":"import _sk_fail; _sk_fail._(\"shelve\")\n","src/lib/shlex.py":"import _sk_fail; _sk_fail._(\"shlex\")\n","src/lib/shutil.py":"import _sk_fail; _sk_fail._(\"shutil\")\n","src/lib/site.py":"import _sk_fail; _sk_fail._(\"site\")\n","src/lib/smtpd.py":"import _sk_fail; _sk_fail._(\"smtpd\")\n","src/lib/smtplib.py":"import _sk_fail; _sk_fail._(\"smtplib\")\n","src/lib/sndhdr.py":"import _sk_fail; _sk_fail._(\"sndhdr\")\n","src/lib/socket.py":"import _sk_fail; _sk_fail._(\"socket\")\n","src/lib/sqlite3/__init__.py":"import _sk_fail; _sk_fail._(\"sqlite3\")\n","src/lib/sre.py":"import _sk_fail; _sk_fail._(\"sre\")\n","src/lib/sre_compile.py":"import _sk_fail; _sk_fail._(\"sre_compile\")\n","src/lib/sre_constants.py":"import _sk_fail; _sk_fail._(\"sre_constants\")\n","src/lib/sre_parse.py":"import _sk_fail; _sk_fail._(\"sre_parse\")\n","src/lib/ssl.py":"import _sk_fail; _sk_fail._(\"ssl\")\n","src/lib/stat.py":"import _sk_fail; _sk_fail._(\"stat\")\n","src/lib/statistics.py":"\"\"\"\nBasic statistics module.\n\nThis module provides functions for calculating statistics of data, including\naverages, variance, and standard deviation.\n\nCalculating averages\n--------------------\n\n==================  =============================================\nFunction            Description\n==================  =============================================\nmean                Arithmetic mean (average) of data.\nharmonic_mean       Harmonic mean of data.\nmedian              Median (middle value) of data.\nmedian_low          Low median of data.\nmedian_high         High median of data.\nmedian_grouped      Median, or 50th percentile, of grouped data.\nmode                Mode (most common value) of data.\n==================  =============================================\n\nCalculate the arithmetic mean (\"the average\") of data:\n\n>>> mean([-1.0, 2.5, 3.25, 5.75])\n2.625\n\n\nCalculate the standard median of discrete data:\n\n>>> median([2, 3, 4, 5])\n3.5\n\n\nCalculate the median, or 50th percentile, of data grouped into class intervals\ncentred on the data values provided. E.g. if your data points are rounded to\nthe nearest whole number:\n\n>>> median_grouped([2, 2, 3, 3, 3, 4])  #doctest: +ELLIPSIS\n2.8333333333...\n\nThis should be interpreted in this way: you have two data points in the class\ninterval 1.5-2.5, three data points in the class interval 2.5-3.5, and one in\nthe class interval 3.5-4.5. The median of these data points is 2.8333...\n\n\nCalculating variability or spread\n---------------------------------\n\n==================  =============================================\nFunction            Description\n==================  =============================================\npvariance           Population variance of data.\nvariance            Sample variance of data.\npstdev              Population standard deviation of data.\nstdev               Sample standard deviation of data.\n==================  =============================================\n\nCalculate the standard deviation of sample data:\n\n>>> stdev([2.5, 3.25, 5.5, 11.25, 11.75])  #doctest: +ELLIPSIS\n4.38961843444...\n\nIf you have previously calculated the mean, you can pass it as the optional\nsecond argument to the four \"spread\" functions to avoid recalculating it:\n\n>>> data = [1, 2, 2, 4, 4, 4, 5, 6]\n>>> mu = mean(data)\n>>> pvariance(data, mu)\n2.5\n\n\nExceptions\n----------\n\nA single exception is defined: StatisticsError is a subclass of ValueError.\n\n\"\"\"\n\n__all__ = [ 'StatisticsError',\n            'pstdev', 'pvariance', 'stdev', 'variance',\n            'median',  'median_low', 'median_high', 'median_grouped',\n            'mean', 'mode', 'harmonic_mean',\n          ]\n\nfrom collections import Counter\nfrom math import sqrt\n\ndef mean(data):\n    return sum(data) / len(data)\n\ndef harmonic_mean(data):\n    raise NotImplementedError\n\n\ndef median(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = (_data[l//2] + _data[l//2-1]) / 2\n    else:\n        _median = _data[l//2]\n    return _median\n\ndef median_low(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = _data[l//2-1]\n    else:\n        _median = _data[l//2]\n    return _median\n\n\ndef median_high(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = _data[l//2]\n    else:\n        _median = _data[l//2]\n    return _median\n\n\ndef median_grouped(data):\n    return median(data)\n\ndef mode(data):\n    counter = Counter(data)\n    max_count = max(counter.values())\n    _mode = [k for k,v in counter.items() if v == max_count]\n    if len(_mode) > 1:\n        raise ValueError(\"No Unique Mode, found {} equally common values\".format(len(_mode)))\n    else:\n        return _mode[0]\n\n\ndef variance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/len(data)\n    return final_variance\n\ndef pvariance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/len(data)\n    return final_variance\n\ndef variance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/(len(data) -1)\n    return final_variance\n\ndef pstdev(data):\n    return sqrt(pvariance(data))\n\ndef stdev(data):\n    return sqrt(variance(data))\n\n","src/lib/statvfs.py":"import _sk_fail; _sk_fail._(\"statvfs\")\n","src/lib/stringold.py":"import _sk_fail; _sk_fail._(\"stringold\")\n","src/lib/stringprep.py":"import _sk_fail; _sk_fail._(\"stringprep\")\n","src/lib/struct.py":"import _sk_fail; _sk_fail._(\"struct\")\n","src/lib/subprocess.py":"import _sk_fail; _sk_fail._(\"subprocess\")\n","src/lib/sunau.py":"import _sk_fail; _sk_fail._(\"sunau\")\n","src/lib/sunaudio.py":"import _sk_fail; _sk_fail._(\"sunaudio\")\n","src/lib/symbol.py":"import _sk_fail; _sk_fail._(\"symbol\")\n","src/lib/symtable.py":"import _sk_fail; _sk_fail._(\"symtable\")\n","src/lib/tabnanny.py":"import _sk_fail; _sk_fail._(\"tabnanny\")\n","src/lib/tarfile.py":"import _sk_fail; _sk_fail._(\"tarfile\")\n","src/lib/telnetlib.py":"import _sk_fail; _sk_fail._(\"telnetlib\")\n","src/lib/tempfile.py":"import _sk_fail; _sk_fail._(\"tempfile\")\n","src/lib/test/__init__.py":"__author__ = 'bmiller'\n\ndef testEqual(actual, expected, places=5):\n    if isinstance(expected,int):\n        if actual == expected:\n            print('Pass')\n            return True\n    elif isinstance(expected,float):\n        if abs(actual-expected) < 10**(-places):\n            print('Pass')\n            return True\n    else:\n        if actual == expected:\n            print('Pass')\n            return True\n    print('Test Failed: expected ' + str(expected) + ' but got ' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n","src/lib/test/ann_module.py":"\n\n\"\"\"\nThe module for testing variable annotations.\nEmpty lines above are for good reason (testing for correct line numbers)\n\"\"\"\n\n# from typing import Optional\n# from functools import wraps\n\n__annotations__[1] = 2\n\nclass C:\n\n    x = 5; #y: Optional['C'] = None\n\n# from typing import Tuple\nx: int = 5; y: str = x;# f: Tuple[int, int]\n\nclass M(type):\n\n    __annotations__['123'] = 123\n    o: type = object\n\n(pars): bool = True\n\nclass D(C):\n    j: str = 'hi'; k: str= 'bye'\n\n# from types import new_class\n# h_class = new_class('H', (C,))\n# j_class = new_class('J')\n\nclass F():\n    z: int = 5\n    def __init__(self, x):\n        pass\n\nclass Y(F):\n    def __init__(self):\n        super(F, self).__init__(123)\n\nclass Meta(type):\n    def __new__(meta, name, bases, namespace):\n        return super().__new__(meta, name, bases, namespace)\n\nclass S(metaclass = Meta):\n    x: str = 'something'\n    y: str = 'something else'\n\n# def foo(x: int = 10):\n#     def bar(y: List[str]):\n#         x: str = 'yes'\n#     bar()\n\n# def dec(func):\n#     @wraps(func)\n#     def wrapper(*args, **kwargs):\n#         return func(*args, **kwargs)\n#     return wrapper\n","src/lib/test/ann_module2.py":"\"\"\"\nSome correct syntax for variable annotation here.\nMore examples are in test_grammar and test_parser.\n\"\"\"\n\n# from typing import no_type_check, ClassVar\n\ni: int = 1\nj: int\nx: float = i/10\n\ndef f():\n    # class C: ...\n    class C: pass\n    return C()\n\nf().new_attr: object = object()\n\nclass C:\n    def __init__(self, x: int) -> None:\n        self.x = x\n\nc = C(5)\nc.new_attr: int = 10\n\n__annotations__ = {}\n\n\n# @no_type_check\n# class NTC:\n#     def meth(self, param: complex) -> None:\n#         ...\n\n# class CV:\n#     var: ClassVar['CV']\n\n# CV.var = CV()\n","src/lib/test/ann_module3.py":"\"\"\"\nCorrect syntax for variable annotation that should fail at runtime\nin a certain manner. More examples are in test_grammar and test_parser.\n\"\"\"\n\ndef f_bad_ann():\n    __annotations__[1] = 2\n\nclass C_OK:\n    def __init__(self, x: int) -> None:\n        self.x: no_such_name = x  # This one is OK as proposed by Guido\n\nclass D_bad_ann:\n    def __init__(self, x: int) -> None:\n        sfel.y: int = 0\n\ndef g_bad_ann():\n    no_such_name.attr: int = 0\n","src/lib/test/bad_getattr.py":"x = 1\n\n__getattr__ = \"Surprise!\"\n__dir__ = \"Surprise again!\"\n","src/lib/test/bad_getattr2.py":"def __getattr__():\n    \"Bad one\"\n\nx = 1\n\ndef __dir__(bad_sig):\n    return []\n","src/lib/test/bad_getattr3.py":"def __getattr__(name):\n    global __getattr__\n    if name != 'delgetattr':\n        raise AttributeError\n    del __getattr__\n    raise AttributeError\n","src/lib/test/decimaltestdata/__init__.py":"import _sk_fail; _sk_fail._(\"decimaltestdata\")\n","src/lib/test/good_getattr.py":"x = 1\n\ndef __dir__():\n    return ['a', 'b', 'c']\n\ndef __getattr__(name):\n    if name == \"yolo\":\n        raise AttributeError(\"Deprecated, use whatever instead\")\n    return f\"There is {name}\"\n\ny = 2\n","src/lib/test/test_support.py":"\"\"\"Supporting definitions for the Python regression tests.\"\"\"\n\nif __name__ != 'test.test_support':\n    raise ImportError('test_support must be imported from the test package')\n\nimport unittest\n\n\n# def run_unittest(*classes):\n#     \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n#     valid_types = (unittest.TestSuite, unittest.TestCase)\n#     suite = unittest.TestSuite()\n#     for cls in classes:\n#         if isinstance(cls, str):\n#             if cls in sys.modules:\n#                 suite.addTest(unittest.findTestCases(sys.modules[cls]))\n#             else:\n#                 raise ValueError(\"str arguments must be keys in sys.modules\")\n#         elif isinstance(cls, valid_types):\n#             suite.addTest(cls)\n#         else:\n#             suite.addTest(unittest.makeSuite(cls))\n#     _run_suite(suite)\n\ndef run_unittest(*classes):\n    \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n    for cls in classes:\n        print cls\n        if issubclass(cls, unittest.TestCase):\n            cls().main()\n        else:\n            print \"Don't know what to do with \", cls\n","src/lib/textwrap.py":"\"\"\"Text wrapping and filling.\n\"\"\"\n\n# Copyright (C) 1999-2001 Gregory P. Ward.\n# Copyright (C) 2002, 2003 Python Software Foundation.\n# Written by Greg Ward <gward@python.net>\n\nimport re, string\n\n__all__ = ['TextWrapper', 'wrap', 'fill', 'dedent', 'indent', 'shorten']\n\n# Hardcode the recognized whitespace characters to the US-ASCII\n# whitespace characters.  The main reason for doing this is that\n# some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n_whitespace = '\\t\\n\\x0b\\x0c\\r '\n\nclass TextWrapper:\n    \"\"\"\n    Object for wrapping/filling text.  The public interface consists of\n    the wrap() and fill() methods; the other methods are just there for\n    subclasses to override in order to tweak the default behaviour.\n    If you want to completely replace the main wrapping algorithm,\n    you'll probably have to override _wrap_chunks().\n    Several instance attributes control various aspects of wrapping:\n      width (default: 70)\n        the maximum width of wrapped lines (unless break_long_words\n        is false)\n      initial_indent (default: \"\")\n        string that will be prepended to the first line of wrapped\n        output.  Counts towards the line's width.\n      subsequent_indent (default: \"\")\n        string that will be prepended to all lines save the first\n        of wrapped output; also counts towards each line's width.\n      expand_tabs (default: true)\n        Expand tabs in input text to spaces before further processing.\n        Each tab will become 0 .. 'tabsize' spaces, depending on its position\n        in its line.  If false, each tab is treated as a single character.\n      tabsize (default: 8)\n        Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n        'expand_tabs' is false.\n      replace_whitespace (default: true)\n        Replace all whitespace characters in the input text by spaces\n        after tab expansion.  Note that if expand_tabs is false and\n        replace_whitespace is true, every tab will be converted to a\n        single space!\n      fix_sentence_endings (default: false)\n        Ensure that sentence-ending punctuation is always followed\n        by two spaces.  Off by default because the algorithm is\n        (unavoidably) imperfect.\n      break_long_words (default: true)\n        Break words longer than 'width'.  If false, those words will not\n        be broken, and some lines might be longer than 'width'.\n      break_on_hyphens (default: true)\n        Allow breaking hyphenated words. If true, wrapping will occur\n        preferably on whitespaces and right after hyphens part of\n        compound words.\n      drop_whitespace (default: true)\n        Drop leading and trailing whitespace from lines.\n      max_lines (default: None)\n        Truncate wrapped lines.\n      placeholder (default: ' [...]')\n        Append to the last line of truncated text.\n    \"\"\"\n\n    unicode_whitespace_trans = {}\n    # uspace = ord(' ')\n    uspace = ' '\n    for x in _whitespace:\n        # unicode_whitespace_trans[ord(x)] = uspace\n        unicode_whitespace_trans[x] = uspace\n\n    # This funky little regex is just the trick for splitting\n    # text up into word-wrappable chunks.  E.g.\n    #   \"Hello there -- you goof-ball, use the -b option!\"\n    # splits into\n    #   Hello/ /there/ /--/ /you/ /goof-/ball,/ /use/ /the/ /-b/ /option!\n    # (after stripping out empty strings).\n    wordsep_re = re.compile(\n        r'(\\s+|'                                  # any whitespace\n        r'[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W]))')  # hyphenated words\n    em_dash = re.compile(r'(\\s+|'                                  # any whitespace\n                         r'[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W])|'   # hyphenated words\n                         r'(?!^)-{2,}(?=\\w))')                     # em-dash\n\n                         \n    # This less funky little regex just split on recognized spaces. E.g.\n    #   \"Hello there -- you goof-ball, use the -b option!\"\n    # splits into\n    #   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\n    wordsep_simple_re = re.compile(r'(\\s+)')\n\n\n    # XXX this is not locale- or charset-aware -- string.lowercase\n    # is US-ASCII only (and therefore English-only)\n    sentence_end_re = re.compile(r'[a-z]'             # lowercase letter\n                                 r'[\\.\\!\\?]'          # sentence-ending punct.\n                                 r'[\\\"\\']?'           # optional end-of-quote\n                                 r'\\Z')               # end of chunk\n    sentence_end_re = r'[a-z][\\.\\!\\?][\\\"\\']?'\n\n    def __init__(self,\n                 width=70,\n                 initial_indent=\"\",\n                 subsequent_indent=\"\",\n                 expand_tabs=True,\n                 replace_whitespace=True,\n                 fix_sentence_endings=False,\n                 break_long_words=True,\n                 drop_whitespace=True,\n                 break_on_hyphens=True,\n                 tabsize=8,\n                 max_lines=None,\n                 placeholder=' [...]'):\n        self.width = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs = expand_tabs\n        self.replace_whitespace = replace_whitespace\n        self.fix_sentence_endings = fix_sentence_endings\n        self.break_long_words = break_long_words\n        self.drop_whitespace = drop_whitespace\n        self.break_on_hyphens = break_on_hyphens\n        self.tabsize = tabsize\n        self.max_lines = max_lines\n        self.placeholder = placeholder\n\n\n    # -- Private methods -----------------------------------------------\n    # (possibly useful for subclasses to override)\n\n    def _munge_whitespace(self, text):\n        \"\"\"_munge_whitespace(text : string) -> string\n        Munge whitespace in text: expand tabs and convert all other\n        whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n        becomes \" foo    bar  baz\".\n        \"\"\"\n        if self.expand_tabs:\n            text = text.expandtabs(self.tabsize)\n        if self.replace_whitespace:\n            for key, val in self.unicode_whitespace_trans.items():\n                text = text.replace(key, val)\n        return text\n\n\n    def _split(self, text):\n        \"\"\"_split(text : string) -> [string]\n        Split the text to wrap into indivisible chunks.  Chunks are\n        not quite the same as words; see _wrap_chunks() for full\n        details.  As an example, the text\n          Look, goof-ball -- use the -b option!\n        breaks into the following chunks:\n          'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n        if break_on_hyphens is True, or in:\n          'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', option!'\n        otherwise.\n        \"\"\"\n        if self.break_on_hyphens is True:\n            chunks = self.wordsep_re.split(text)\n            if \"--\" in text:\n                chunks = [item \n                            for sublist in [self.em_dash.split(chunk) for chunk in chunks] \n                                for item in sublist]\n        else:\n            chunks = self.wordsep_simple_re.split(text)\n        chunks = [c for c in chunks if c]\n        return chunks\n\n    def _fix_sentence_endings(self, chunks):\n        \"\"\"_fix_sentence_endings(chunks : [string])\n        Correct for sentence endings buried in 'chunks'.  Eg. when the\n        original text contains \"... foo.\\\\nBar ...\", munge_whitespace()\n        and split() will convert that to [..., \"foo.\", \" \", \"Bar\", ...]\n        which has one too few spaces; this method simply changes the one\n        space to two.\n        \"\"\"\n        i = 0\n        # patsearch = self.sentence_end_re.search\n        while i < len(chunks)-1:\n            if chunks[i+1] == \" \" and re.search(self.sentence_end_re, chunks[i]) and chunks[i][-1] in \".!?\\\"\\'\":\n                chunks[i+1] = \"  \"\n                i += 2\n            else:\n                i += 1\n\n    def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):\n        \"\"\"_handle_long_word(chunks : [string],\n                             cur_line : [string],\n                             cur_len : int, width : int)\n        Handle a chunk of text (most likely a word, not whitespace) that\n        is too long to fit in any line.\n        \"\"\"\n        # Figure out when indent is larger than the specified width, and make\n        # sure at least one character is stripped off on every pass\n        if width < 1:\n            space_left = 1\n        else:\n            space_left = width - cur_len\n\n        # If we're allowed to break long words, then do so: put as much\n        # of the next chunk onto the current line as will fit.\n        if self.break_long_words:\n            cur_line.append(reversed_chunks[-1][:space_left])\n            reversed_chunks[-1] = reversed_chunks[-1][space_left:]\n\n        # Otherwise, we have to preserve the long word intact.  Only add\n        # it to the current line if there's nothing already there --\n        # that minimizes how much we violate the width constraint.\n        elif not cur_line:\n            cur_line.append(reversed_chunks.pop())\n\n        # If we're not allowed to break long words, and there's already\n        # text on the current line, do nothing.  Next time through the\n        # main loop of _wrap_chunks(), we'll wind up here again, but\n        # cur_len will be zero, so the next line will be entirely\n        # devoted to the long word that we can't handle right now.\n\n    def _wrap_chunks(self, chunks):\n        \"\"\"_wrap_chunks(chunks : [string]) -> [string]\n        Wrap a sequence of text chunks and return a list of lines of\n        length 'self.width' or less.  (If 'break_long_words' is false,\n        some lines may be longer than this.)  Chunks correspond roughly\n        to words and the whitespace between them: each chunk is\n        indivisible (modulo 'break_long_words'), but a line break can\n        come between any two chunks.  Chunks should not have internal\n        whitespace; ie. a chunk is either all whitespace or a \"word\".\n        Whitespace chunks will be removed from the beginning and end of\n        lines, but apart from that whitespace is preserved.\n        \"\"\"\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            if len(indent) + len(self.placeholder.lstrip()) > self.width:\n                raise ValueError(\"placeholder too large for max width\")\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            # Maximum width for this line.\n            width = self.width - len(indent)\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if self.drop_whitespace and cur_line and cur_line[-1].strip() == '':\n                cur_len -= len(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                    len(lines) + 1 < self.max_lines or\n                    (not chunks or\n                     self.drop_whitespace and\n                     len(chunks) == 1 and\n                     not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n                    while cur_line:\n                        if (cur_line[-1].strip() and\n                            cur_len + len(self.placeholder) <= width):\n                            cur_line.append(self.placeholder)\n                            lines.append(indent + ''.join(cur_line))\n                            break\n                        cur_len -= len(cur_line[-1])\n                        del cur_line[-1]\n                    else:\n                        if lines:\n                            prev_line = lines[-1].rstrip()\n                            if (len(prev_line) + len(self.placeholder) <=\n                                    self.width):\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def _split_chunks(self, text):\n        text = self._munge_whitespace(text)\n        return self._split(text)\n\n    # -- Public interface ----------------------------------------------\n\n    def wrap(self, text):\n        \"\"\"wrap(text : string) -> [string]\n        Reformat the single paragraph in 'text' so it fits in lines of\n        no more than 'self.width' columns, and return a list of wrapped\n        lines.  Tabs in 'text' are expanded with string.expandtabs(),\n        and all other whitespace characters (including newline) are\n        converted to space.\n        \"\"\"\n        chunks = self._split_chunks(text)\n        if self.fix_sentence_endings:\n            self._fix_sentence_endings(chunks)\n        return self._wrap_chunks(chunks)\n\n    def fill(self, text):\n        \"\"\"fill(text : string) -> string\n        Reformat the single paragraph in 'text' to fit in lines of no\n        more than 'self.width' columns, and return a new string\n        containing the entire wrapped paragraph.\n        \"\"\"\n        return \"\\n\".join(self.wrap(text))\n\n\n# -- Convenience interface ---------------------------------------------\n\ndef wrap(text, width=70, **kwargs):\n    \"\"\"Wrap a single paragraph of text, returning a list of wrapped lines.\n    Reformat the single paragraph in 'text' so it fits in lines of no\n    more than 'width' columns, and return a list of wrapped lines.  By\n    default, tabs in 'text' are expanded with string.expandtabs(), and\n    all other whitespace characters (including newline) are converted to\n    space.  See TextWrapper class for available keyword args to customize\n    wrapping behaviour.\n    \"\"\"\n    w = TextWrapper(width=width, **kwargs)\n    return w.wrap(text)\n\ndef fill(text, width=70, **kwargs):\n    \"\"\"Fill a single paragraph of text, returning a new string.\n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n    \"\"\"\n    w = TextWrapper(width=width, **kwargs)\n    return w.fill(text)\n\ndef shorten(text, width, **kwargs):\n    \"\"\"Collapse and truncate the given text to fit in the given width.\n    The text first has its whitespace collapsed.  If it then fits in\n    the *width*, it is returned as is.  Otherwise, as many words\n    as possible are joined and then the placeholder is appended::\n        >>> textwrap.shorten(\"Hello  world!\", width=12)\n        'Hello world!'\n        >>> textwrap.shorten(\"Hello  world!\", width=11)\n        'Hello [...]'\n    \"\"\"\n    w = TextWrapper(width=width, max_lines=1, **kwargs)\n    return w.fill(' '.join(text.strip().split()))\n\n\n# -- Loosely related functionality -------------------------------------\n\n# _whitespace_only_re = re.compile('^[ \\t]+$', re.MULTILINE)\n# _leading_whitespace_re = re.compile('(^[ \\t]*)(?:[^ \\t\\n])', re.MULTILINE)\n\ndef dedent(text):\n    \"\"\"Remove any common leading whitespace from every line in `text`.\n    This can be used to make triple-quoted strings line up with the left\n    edge of the display, while still presenting them in the source code\n    in indented form.\n    Note that tabs and spaces are both treated as whitespace, but they\n    are not equal: the lines \"  hello\" and \"\\\\thello\" are\n    considered to have no common leading whitespace.\n    Entirely blank lines are normalized to a newline character.\n    \"\"\"\n    # Look for the longest leading string of spaces and tabs common to\n    # all lines.\n    margin = None\n\n    indents = re.findall(r'(^[ \\t]*)(?:[^ \\t\\n])',text, re.MULTILINE)\n    for indent in indents:\n        if margin is None:\n            margin = indent\n\n        # Current line more deeply indented than previous winner:\n        # no change (previous winner is still on top).\n        elif indent.startswith(margin):\n            pass\n\n        # Current line consistent with and no deeper than previous winner:\n        # it's the new winner.\n        elif margin.startswith(indent):\n            margin = indent\n\n        # Find the largest common whitespace between current line and previous\n        # winner.\n        else:\n            for i, (x, y) in enumerate(zip(margin, indent)):\n                if x != y:\n                    margin = margin[:i]\n                    break\n    # sanity check (testing/debugging only)\n    if 0 and margin:\n        for line in text.split(\"\\n\"):\n            assert not line or line.startswith(margin), \\\n                   \"line = %r, margin = %r\" % (line, margin)\n\n    if margin:\n        lines = [line[len(margin):] \n                    if line.strip()\n                        else line.strip() \n                            for line in text.split(\"\\n\")]\n        text = \"\\n\".join(lines)\n    return text\n\n\ndef indent(text, prefix, predicate=None):\n    \"\"\"Adds 'prefix' to the beginning of selected lines in 'text'.\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.\n    \"\"\"\n    if predicate is None:\n        def predicate(line):\n            return line.strip()\n\n    def prefixed_lines():\n        for line in text.splitlines(True):\n            yield (prefix + line if predicate(line) else line)\n    return ''.join(prefixed_lines())\n\n\nif __name__ == \"__main__\":\n    #print dedent(\"\\tfoo\\n\\tbar\")\n    #print dedent(\"  \\thello there\\n  \\t  how are you?\")\n    print(dedent(\"Hello there.\\n  This is indented.\"))","src/lib/this.py":"\nprint(\"\"\"\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\"\"\"\n      )\n","src/lib/threading.py":"import _sk_fail; _sk_fail._(\"threading\")\n","src/lib/timeit.py":"import _sk_fail; _sk_fail._(\"timeit\")\n","src/lib/toaiff.py":"import _sk_fail; _sk_fail._(\"toaiff\")\n","src/lib/trace.py":"import _sk_fail; _sk_fail._(\"trace\")\n","src/lib/traceback.py":"import _sk_fail; _sk_fail._(\"traceback\")\n","src/lib/tty.py":"import _sk_fail; _sk_fail._(\"tty\")\n","src/lib/types.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\n\"\"\"Define names for all type symbols known in the standard interpreter.\nTypes that are part of optional modules (e.g. array) are not listed.\n\"\"\"\nimport sys\n\n# Iterators in Python aren't a matter of type but of protocol.  A large\n# and changing number of builtin types implement *some* flavor of\n# iterator.  Don't check the type!  Use hasattr to check for both\n# \"__iter__\" and \"next\" attributes instead.\nMappingProxyType = type(type.__dict__)\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\n\nNoneType = type(None)\nTypeType = type\nObjectType = object\nIntType = int\ntry:\n    LongType = long\nexcept: pass\nFloatType = float\nBooleanType = bool\ntry:\n    ComplexType = complex\nexcept NameError:\n    pass\nStringType = str\n\n# StringTypes is already outdated.  Instead of writing \"type(x) in\n# types.StringTypes\", you should use \"isinstance(x, basestring)\".  But\n# we keep around for compatibility with Python 2.2.\ntry:\n    UnicodeType = unicode\n    StringTypes = (StringType, UnicodeType)\nexcept NameError:\n    StringTypes = (StringType,)\n\nBufferType = buffer\n\nTupleType = tuple\nListType = list\nDictType = DictionaryType = dict\n\ndef _f(): pass\nFunctionType = type(_f)\nLambdaType = type(lambda: None)         # Same as FunctionType\n#CodeType = type(_f.func_code)\n\ndef _g():\n    yield 1\nGeneratorType = type(_g())\n\nclass _C:\n    def _m(self): pass\nClassType = type(_C)\nUnboundMethodType = type(_C._m)         # Same as MethodType\n_x = _C()\nInstanceType = type(_x)\nMethodType = type(_x._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\n\nModuleType = type(sys)\nFileType = file\ntry:\n    XRangeType = xrange\nexcept NameError:\n    pass\n\n# try:\n#     raise TypeError\n# except TypeError:\n#     tb = sys.exc_info()[2]\n#     TracebackType = type(tb)\n#     FrameType = type(tb.tb_frame)\n#     del tb\n\nSliceType = slice\nEllipsisType = type(Ellipsis)\n\n# DictProxyType = type(TypeType.__dict__)\nNotImplementedType = type(NotImplemented)\n\n# For Jython, the following two types are identical\n# GetSetDescriptorType = type(FunctionType.func_code)\n# MemberDescriptorType = type(FunctionType.func_globals)\n\ndel sys, _f, _g, _C, _x                           # Not for export\n__all__ = list(n for n in globals() if n[:1] != '_')\n\nGenericAlias = type(type[int])","src/lib/unittest/__init__.py":"__author__ = 'bmiller'\n'''\nThis is the start of something that behaves like\nthe unittest module from cpython.\n\n'''\nimport re\n\nclass _AssertRaisesContext(object):\n    \"\"\"A context manager used to implement TestCase.assertRaises* methods.\"\"\"\n    def __init__(self, expected, test_case):\n        self.test_case = test_case\n        self.expected = expected\n        self.exception = None\n\n    def _is_subtype(self, expected, basetype):\n        if isinstance(expected, tuple):\n            return all(self._is_subtype(e, basetype) for e in expected)\n        return isinstance(expected, type) and issubclass(expected, basetype)\n\n    def handle(self, args, kwargs):\n        \"\"\"\n        If args is empty, assertRaises is being used as a\n        context manager, so return self.\n        If args is not empty, call a callable passing positional and keyword\n        arguments.\n        \"\"\"\n        try:\n            if not self._is_subtype(self.expected, BaseException):\n                raise TypeError('assertRaises() arg 1 must be an exception type or tuple of exception types')\n            if not args:\n                return self\n\n            callable_obj = args[0]\n            args = args[1:]\n            with self:\n                callable_obj(*args, **kwargs) \n\n        finally:\n            # bpo-23890: manually break a reference cycle\n            self = None\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        res = True\n        feedback = \"\"\n        self.exception = exc_value\n        try:\n            act_exc = exc_type.__name__\n        except AttributeError:\n            act_exc = str(exc_type)\n        try:\n            exp_exc = self.expected.__name__\n        except AttributeError:\n            exp_exc = str(self.expected)\n\n        if exc_type is None:\n            res = False\n            feedback = \"{} not raised\".format(exp_exc)\n        elif not issubclass(exc_type, self.expected):\n            res = False\n            feedback = \"Expected {} but got {}\".format(exp_exc, act_exc)\n\n        self.test_case.appendResult(res, act_exc, exp_exc, feedback)\n        return True\n\n\nclass TestCase(object):\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.assertPassed = 0\n        self.assertFailed = 0\n        self.verbosity = 1\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == 'test' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n    \n    def cleanName(self,funcName):\n        return funcName.__func__.__name__\n\n    def main(self):\n\n        for func in self.tlist:\n            if self.verbosity > 1:\n                print('Running %s' % self.cleanName(func))\n            try:\n                self.setUp()\n                self.assertPassed = 0\n                self.assertFailed = 0\n                func()\n                self.tearDown()\n                if self.assertFailed == 0:\n                    self.numPassed += 1\n                else:\n                    self.numFailed += 1\n                    print('Tests failed in %s ' % self.cleanName(func))\n            except Exception as e:\n                self.assertFailed += 1\n                self.numFailed += 1\n                print('Test threw exception in %s (%s)' % (self.cleanName(func), e))\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=\"\"):\n        res = actual==expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual ,expected, feedback)\n\n    def assertNotEqual(self, actual, expected, feedback=\"\"):\n        res = actual != expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual, expected, feedback)\n\n    def assertTrue(self,x, feedback=\"\"):\n        res = bool(x) is True\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be True\" % (str(x))\n        self.appendResult(res, x, True, feedback)\n\n    def assertFalse(self,x, feedback=\"\"):\n        res = not bool(x)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be False\" % (str(x))\n        self.appendResult(res, x, False, feedback)\n\n    def assertIs(self,a,b, feedback=\"\"):\n        res = a is b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNot(self,a,b, feedback=\"\"):\n        res = a is not b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNone(self,x, feedback=\"\"):\n        res = x is None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIsNotNone(self,x, feedback=\"\"):\n        res = x is not None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIn(self, a, b, feedback=\"\"):\n        res = a in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIn(self, a, b, feedback=\"\"):\n        res = a not in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsInstance(self,a,b, feedback=\"\"):\n        res = isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be an instance of %s\" % (str(a), str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=\"\"):\n        res = not isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be an instance of %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertRegex(self, text, expected_regex, feedback=\"\"):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, )): #bytes\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            res = False\n            if feedback == \"\":\n                feedback = \"Regex didn't match: %r not found in %r\" % (\n                    repr(expected_regex), text)\n        else:\n            res = True\n        self.appendResult(res, text, expected_regex, feedback)\n\n    def assertNotRegex(self, text, unexpected_regex, feedback=\"\"):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, )): # bytes\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            feedback = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                repr(unexpected_regex),\n                text)\n            # _formatMessage ensures the longMessage option is respected\n        self.appendResult(not bool(match), text, unexpected_regex, feedback)\n\n    def assertAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = abs(a-b) <= delta\n        else:\n            if places is None:\n                places = 7\n            res = round(a-b, places) == 0\n        \n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = not (a == b) and abs(a - b) > delta\n        else:\n            if places is None:\n                places = 7\n\n            res = round(a-b, places) != 0\n\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreater(self,a,b, feedback=\"\"):\n        res = a > b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be greater than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=\"\"):\n        res = a >= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be >= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLess(self, a, b, feedback=\"\"):\n        res = a < b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be less than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLessEqual(self,a,b, feedback=\"\"):\n        res = a <= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be <= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res:\n            msg = 'Pass'\n            self.assertPassed += 1\n        else:\n            msg = 'Fail: ' +  feedback\n            print(msg)\n            self.assertFailed += 1\n\n    def assertRaises(self, expected_exception, *args, **kwargs):\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle(args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n\n    def fail(self, msg=None):\n        if msg is None:\n            msg = 'Fail'\n        else:\n            msg = 'Fail: ' + msg\n        print(msg)\n        self.assertFailed += 1\n\n    def showSummary(self):\n        # don't divde by zero\n        # pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        print(\"Ran %d tests, passed: %d failed: %d\\n\" % (self.numPassed+self.numFailed,\n                                               self.numPassed, self.numFailed))\n\n\n\ndef main(verbosity=1):\n    glob = globals() # globals() still needs work\n    for name in glob:\n        if type(glob[name]) == type and issubclass(glob[name], TestCase):\n            try:\n                tc = glob[name]()\n                tc.verbosity = verbosity\n                tc.main()\n            except:\n                print(\"Uncaught Error in: \", name)\n","src/lib/unittest/gui.py":"import document\nfrom unittest import TestCase\nfrom urllib.request import urlopen\nfrom time import sleep\n\n\nclass TestCaseGui(TestCase):\n    def __init__(self):\n        TestCase.__init__(self)\n        self.closestDiv = document.currentDiv()\n        self.divid = document.currentGradingContainer()\n        self.mydiv = document.getElementById(self.divid)\n        # If there is no div then create a dummy to avoid errors when running\n        # grading \"off screen\"\n        if self.mydiv is None:\n            self.mydiv = document.createElement(\"div\")\n            self.mydiv.setAttribute(\"id\", self.divid + \"_offscreen_unit_results\")\n            self.mydiv.setCSS(\"display\", \"none\")\n            body = document.getElementsByTagName(\"body\")[0]\n            body.appendChild(self.mydiv)\n            self.unit_results_divid = self.divid + \"_offscreen_unit_results\"\n\n        res = document.getElementById(self.divid + \"_unit_results\")\n        if res:\n            self.resdiv = res\n            res.innerHTML = \"\"\n            self.unit_results_divid = self.divid + \"_unit_results\"\n        else:\n            self.resdiv = document.createElement(\"div\")\n            self.resdiv.setAttribute(\"id\", self.divid + \"_unit_results\")\n            self.resdiv.setAttribute(\"class\", \"unittest-results\")\n            self.mydiv.appendChild(self.resdiv)\n            self.unit_results_divid = self.divid + \"_unit_results\"\n\n    def main(self):\n        t = document.createElement(\"table\")\n        self.resTable = t\n        x = self.resdiv.closest(\".timedComponent\")\n        if x:\n            self.is_timed = True\n        else:\n            self.is_timed = False\n        self.resdiv.appendChild(self.resTable)\n        if self.is_timed:\n            self.resdiv.setCSS(\"display\", \"none\")\n\n        headers = [\"Result\", \"Actual Value\", \"Expected Value\", \"Notes\"]\n        row = document.createElement(\"tr\")\n        for item in headers:\n            head = document.createElement(\"th\")\n            head.setAttribute(\"class\", \"ac-feedback\")\n            head.innerHTML = item\n            head.setCSS(\"text-align\", \"center\")\n            row.appendChild(head)\n        self.resTable.appendChild(row)\n\n        for func in self.tlist:\n            try:\n                self.setUp()\n                func()\n                self.tearDown()\n            except Exception as e:\n                self.appendResult(\"Error\", None, None, str(e).split(\"on line\")[0])\n                self.numFailed += 1\n        self.showSummary()\n\n    def getOutput(self):\n        sleep(0.2)\n        # self.divid will be the gradingWrapper when in grading mode\n        if self.closestDiv != self.divid:\n            output = document.querySelector(\n                \"#{} #{}_stdout\".format(self.divid, self.closestDiv)\n            )\n        else:\n            output = document.getElementById(self.divid + \"_stdout\")\n        return output.innerText\n\n    def getEditorText(self):\n        return document.getCurrentEditorValue()\n\n    def appendResult(self, res, actual, expected, param):\n        trimActual = False\n        if len(str(actual)) > 15:\n            trimActual = True\n            actualType = type(actual)\n        trimExpected = False\n        if len(str(expected)) > 15:\n            trimExpected = True\n            expectedType = type(expected)\n        row = document.createElement(\"tr\")\n        err = False\n        if res == \"Error\":\n            err = True\n            msg = \"Error: %s\" % param\n            errorData = document.createElement(\"td\")\n            errorData.setAttribute(\"class\", \"ac-feedback\")\n            errorData.innerHTML = \"ERROR\"\n            errorData.setCSS(\"background-color\", \"#de8e96\")\n            errorData.setCSS(\"text-align\", \"center\")\n            row.appendChild(errorData)\n        elif res:\n            passed = document.createElement(\"td\")\n            passed.setAttribute(\"class\", \"ac-feedback\")\n            passed.innerHTML = \"Pass\"\n            passed.setCSS(\"background-color\", \"#83d382\")\n            passed.setCSS(\"text-align\", \"center\")\n            row.appendChild(passed)\n            self.numPassed += 1\n        else:\n            fail = document.createElement(\"td\")\n            fail.setAttribute(\"class\", \"ac-feedback\")\n            fail.innerHTML = \"Fail\"\n            fail.setCSS(\"background-color\", \"#de8e96\")\n            fail.setCSS(\"text-align\", \"center\")\n            row.appendChild(fail)\n            self.numFailed += 1\n\n        act = document.createElement(\"td\")\n        act.setAttribute(\"class\", \"ac-feedback\")\n        if trimActual:\n            actHTML = str(actual)[:5] + \"...\" + str(actual)[-5:]\n            if actualType == str:\n                actHTML = repr(actHTML)\n            act.innerHTML = actHTML\n        else:\n            act.innerHTML = repr(actual)\n        act.setCSS(\"text-align\", \"center\")\n        row.appendChild(act)\n\n        expect = document.createElement(\"td\")\n        expect.setAttribute(\"class\", \"ac-feedback\")\n\n        if trimExpected:\n            expectedHTML = str(expected)[:5] + \"...\" + str(expected)[-5:]\n            if expectedType == str:\n                expectedHTML = repr(expectedHTML)\n            expect.innerHTML = expectedHTML\n        else:\n            expect.innerHTML = repr(expected)\n        expect.setCSS(\"text-align\", \"center\")\n        row.appendChild(expect)\n        inp = document.createElement(\"td\")\n        inp.setAttribute(\"class\", \"ac-feedback\")\n\n        if err:\n            inp.innerHTML = msg\n        else:\n            inp.innerHTML = param\n        inp.setCSS(\"text-align\", \"center\")\n        row.appendChild(inp)\n\n        if trimActual or trimExpected:\n            expandbutton = document.createElement(\"button\")\n            expandbutton.innerHTML = \"Expand Differences\"\n            expandmsg = \"Actual: \" + str(actual) + \"\\nExpected: \" + str(expected)\n            expandbutton.setAttribute(\"value\", expandmsg)\n            expandbutton.setAttribute(\"type\", \"button\")\n            expandbutton.setAttribute(\"onclick\", \"alert(this.value)\")\n            expandbutton.setAttribute(\"class\", \"btn btn-info\")\n            row.appendChild(expandbutton)\n\n        self.resTable.appendChild(row)\n\n    def showSummary(self):\n        pct = float(self.numPassed) / (self.numPassed + self.numFailed) * 100\n        pctcorrect = (\n            \"percent:\"\n            + str(pct)\n            + \":passed:\"\n            + str(self.numPassed)\n            + \":failed:\"\n            + str(self.numFailed)\n        )\n        pTag = document.createElement(\"p\")\n        if not self.is_timed:\n            pTag.innerHTML = \"You passed: \" + str(pct) + \"% of the tests\"\n            self.resdiv.appendChild(pTag)\n        try:\n            jseval(\"window.edList['{}'].pct_correct = {}\".format(self.closestDiv, pct))\n            jseval(\n                \"window.edList['{}'].unit_results = '{}'\".format(\n                    self.closestDiv, pctcorrect\n                )\n            )\n            jseval(\n                \"window.edList['{}'].unit_results_divid = '{}'\".format(\n                    self.closestDiv, self.mydiv.getAttribute(\"id\")\n                )\n            )\n\n        except:\n            print(\n                \"failed to find object to record unittest results! {}\".format(\n                    pctcorrect\n                )\n            )\n","src/lib/urllib2.py":"import _sk_fail; _sk_fail._(\"urllib2\")\n","src/lib/urlparse.py":"import _sk_fail; _sk_fail._(\"urlparse\")\n","src/lib/user.py":"import _sk_fail; _sk_fail._(\"user\")\n","src/lib/uu.py":"import _sk_fail; _sk_fail._(\"uu\")\n","src/lib/uuid.py":"import _sk_fail; _sk_fail._(\"uuid\")\n","src/lib/warnings.py":"import _sk_fail; _sk_fail._(\"warnings\")\n","src/lib/wave.py":"import _sk_fail; _sk_fail._(\"wave\")\n","src/lib/weakref.py":"import _sk_fail; _sk_fail._(\"weakref\")\n","src/lib/whichdb.py":"import _sk_fail; _sk_fail._(\"whichdb\")\n","src/lib/wsgiref/__init__.py":"import _sk_fail; _sk_fail._(\"wsgiref\")\n","src/lib/xdrlib.py":"import _sk_fail; _sk_fail._(\"xdrlib\")\n","src/lib/xml/__init__.py":"import _sk_fail; _sk_fail._(\"xml\")\n","src/lib/xml/dom/__init__.py":"import _sk_fail; _sk_fail._(\"dom\")\n","src/lib/xml/etree/__init__.py":"import _sk_fail; _sk_fail._(\"etree\")\n","src/lib/xml/parsers/__init__.py":"import _sk_fail; _sk_fail._(\"parsers\")\n","src/lib/xml/sax/__init__.py":"import _sk_fail; _sk_fail._(\"sax\")\n","src/lib/xmllib.py":"import _sk_fail; _sk_fail._(\"xmllib\")\n","src/lib/xmlrpclib.py":"import _sk_fail; _sk_fail._(\"xmlrpclib\")\n","src/lib/zipfile.py":"import _sk_fail; _sk_fail._(\"zipfile\")\n","src/builtin/sys.js":"var $builtinmodule=function(i){var t,n={},e=[],u=Sk.getSysArgv();for(t=0;t<u.length;++t)e.push(new Sk.builtin.str(u[t]));n.argv=new Sk.builtins.list(e),n.copyright=new Sk.builtin.str(\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\"),Sk.__future__.python3?(n.version=new Sk.builtin.str(\"3.7(ish) [Skulpt]\"),n.version_info=new Sk.builtin.tuple([new Sk.builtin.int_(3),new Sk.builtin.int_(7)])):(n.version=new Sk.builtin.str(\"2.7(ish) [Skulpt]\"),n.version_info=new Sk.builtin.tuple([new Sk.builtin.int_(2),new Sk.builtin.int_(7)])),n.maxint=new Sk.builtin.int_(Math.pow(2,53)-1),n.maxsize=new Sk.builtin.int_(Math.pow(2,53)-1),n.modules=Sk.sysmodules,n.path=Sk.realsyspath,n.getdefaultencoding=new Sk.builtin.func((()=>new Sk.builtin.str(\"utf-8\"))),n.getExecutionLimit=new Sk.builtin.func((function(){return null===Sk.execLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.execLimit)})),n.setExecutionLimit=new Sk.builtin.func((function(i){if(null===Sk.execLimit)throw new Sk.builtin.NotImplementedError(\"Execution limiting is not enabled\");void 0!==i&&(Sk.execLimit=Sk.builtin.asnum$(i))})),n.resetTimeout=new Sk.builtin.func((function(){Sk.execStart=new Date})),n.getYieldLimit=new Sk.builtin.func((function(){return null===Sk.yieldLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.yieldLimit)})),n.setYieldLimit=new Sk.builtin.func((function(i){if(null===Sk.yieldLimit)throw new Sk.builtin.NotImplementedError(\"Yielding is not enabled\");void 0!==i&&(Sk.yieldLimit=Sk.builtin.asnum$(i))})),n.debug=new Sk.builtin.func((function(){return Sk.builtin.none.none$}));const l=Sk.builtin.make_structseq(\"sys\",\"float_info\",{max:\"DBL_MAX -- maximum representable finite float\",max_exp:\"DBL_MAX_EXP -- maximum int e such that radix**(e-1) is representable\",max_10_exp:\"DBL_MAX_10_EXP -- maximum int e such that 10**e is representable\",min:\"DBL_MIN -- Minimum positive normalized float\",min_exp:\"DBL_MIN_EXP -- minimum int e such that radix**(e-1) is a normalized float\",min_10_exp:\"DBL_MIN_10_EXP -- minimum int e such that 10**e is a normalized\",dig:\"DBL_DIG -- digits\",mant_dig:\"DBL_MANT_DIG -- mantissa digits\",epsilon:\"DBL_EPSILON -- Difference between 1 and the next representable float\",radix:\"FLT_RADIX -- radix of exponent\",rounds:\"FLT_ROUNDS -- rounding mode\"});n.float_info=new l([Number.MAX_VALUE,Math.floor(Math.log2(Number.MAX_VALUE)),Math.floor(Math.log10(Number.MAX_VALUE)),Number.MIN_VALUE,Math.ceil(Math.log2(Number.MIN_VALUE)),Math.ceil(Math.log10(Number.MIN_VALUE)),15,Math.log2(Number.MAX_SAFE_INTEGER),Number.EPSILON,2,1].map((i=>Sk.ffi.remapToPy(i))));const o=Sk.builtin.make_structseq(\"sys\",\"int_info\",{bits_per_digit:\"size of a digit in bits\",sizeof_digit:\"size in bytes of the C type used to represent a digit\"});return n.int_info=new o([30,4].map((i=>Sk.ffi.remapToPy(i)))),n.__stdout__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdout\"),new Sk.builtin.str(\"w\")),n.__stdin__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdin\"),new Sk.builtin.str(\"r\")),n.stdout=n.__stdout__,n.stdin=n.__stdin__,n};","src/lib/JoBase.js":"const $builtinmodule=()=>{Sk.misceval.print_(\"Welcome to JoBase\\n\");const e=Sk.JoBase,o={},t=[],r=[],n=e.getContext(\"webgl\"),a=n.createProgram(),c=n.createBuffer(),i=n.createShader(n.VERTEX_SHADER),s=n.createShader(n.FRAGMENT_SHADER),str=e=>new Sk.builtin.str(e),def=e=>new Sk.builtin.func(e),float=e=>new Sk.builtin.float_(e),int=e=>new Sk.builtin.int_(e),bool=e=>new Sk.builtin.bool(e),tuple=e=>new Sk.builtin.tuple(e),number=e=>{if(Sk.builtin.checkNumber(e))return e.v;throw new Sk.builtin.TypeError(\"must be real number, not \"+e.tp$name)},string=e=>{if(Sk.builtin.checkString(e))return e.v;throw new Sk.builtin.TypeError(\"must be str, not \"+e.tp$name)},property=(...e)=>call(Sk.builtins.property,...e),build=(...e)=>Sk.misceval.buildClass(o,...e),call=(...e)=>Sk.misceval.callsimOrSuspend(...e),is=(...e)=>Sk.builtin.isinstance(...e).v,wait=e=>Sk.misceval.promiseToSuspension(new Promise(e)),object=e=>{throw new Sk.builtin.TypeError(\"must be Shape or cursor, not \"+e.tp$name)},path=e=>str(\"https://jobase.org/Browser/JoBase/\"+e),width=()=>e.width/devicePixelRatio,height=()=>e.height/devicePixelRatio,x=()=>o.cursor.$x-width()/2,y=()=>height()/2-o.cursor.$y,blank=()=>{},mouseEnter=()=>o.cursor.$enter=!0,mouseLeave=()=>o.cursor.$leave=!0,mouseDown=()=>{o.cursor.$press=!0,o.cursor.$hold=!0},mouseUp=()=>{o.cursor.$release=!0,o.cursor.$hold=!1},mouseMove=t=>{const r=e.getBoundingClientRect();o.cursor.$x=t.clientX-r.left,o.cursor.$y=t.clientY-r.top,o.cursor.$move=!0},keyDown=e=>{const t=Object.keys(o.key.$data).find((t=>o.key.$data[t].code==e.code)),r=o.key.$data[t];e.repeat?(o.key.$repeat=!0,r&&(r.repeat=!0)):(o.key.$press=!0,r&&(r.press=!0)&&(r.hold=!0))},keyUp=e=>{const t=Object.keys(o.key.$data).find((t=>o.key.$data[t].code==e.code)),r=o.key.$data[t];o.key.$release=!0,r&&(r.release=!0)&&(r.hold=!1)},collidePolyPoint=(e,o)=>e.reduce(((e,t,r,n)=>{const a=n[r+1==n.length?0:r+1];return o[0]<(a[0]-t[0])*(o[1]-t[1])/(a[1]-t[1])+t[0]&&(t[1]>o[1]&&a[1]<o[1]||t[1]<o[1]&&a[1]>o[1])?!e:e}),!1),getRectPoly=e=>{const o=e.$anchor[0]+e.$size[0]*e.$scale[0]/2,t=e.$anchor[1]+e.$size[1]*e.$scale[1]/2;return((e,o,t)=>{const r=Math.cos(o*Math.PI/180),n=Math.sin(o*Math.PI/180);return e.map((e=>[e[0]*r-e[1]*n+t[0],e[0]*n+e[1]*r+t[1]]))})([[-o,t],[o,t],[o,-t],[-o,-t]],e.$angle,e.$pos)},createImage=e=>{const o=n.createTexture();return n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),o},renderText=e=>{const o=document.createElement(\"canvas\"),t=o.getContext(\"2d\"),a=e.$fontSize+\"px _\"+r.indexOf(e.$font);t.font=a;const c=t.measureText(e.$content),i=c.actualBoundingBoxRight-c.actualBoundingBoxLeft,s=t.measureText(\"Sy\"),d=s.actualBoundingBoxDescent+s.actualBoundingBoxAscent;e.$size[0]=o.width=i,e.$size[1]=o.height=d,t.font=a,t.fillStyle=\"#fff\",t.fillText(e.$content,0,s.actualBoundingBoxAscent),n.deleteTexture(e.$texture),e.$texture=createImage(o)},loadFont=e=>new Promise(((o,t)=>{if(r.includes(e))return o();new FontFace(\"_\"+r.length,`url(${e})`).load().then((t=>{document.fonts.add(t),r.push(e),o()})).catch((()=>{return t((o=`failed to load font: \"${e}\"`,new Sk.builtin.FileNotFoundError(o)));var o}))})),drawShape=(e,o,t,r,c,i)=>{const s=o[0]*e.$scale[0],d=o[1]*e.$scale[1],l=e.$anchor[0],u=e.$anchor[1],$=e.$pos[0],p=e.$pos[1],m=Math.sin(e.$angle*Math.PI/180),f=Math.cos(e.$angle*Math.PI/180);var h,_;h=[s*f,s*m,0,0,d*-m,d*f,0,0,0,0,1,0,l*f+u*-m+$,l*m+u*f+p,0,1],_=e.$color,n.uniform4fv(n.getUniformLocation(a,\"color\"),new Float32Array(_)),n.uniformMatrix4fv(n.getUniformLocation(a,\"object\"),!1,new Float32Array(h)),n.bindBuffer(n.ARRAY_BUFFER,t),n.uniform1i(n.getUniformLocation(a,\"image\"),c),n.drawArrays(r,0,i)},d=def(((e,t)=>{if(is(e,o.Rectangle)){if(is(t,o.Rectangle))return bool((r=getRectPoly(e),n=getRectPoly(t),collidePolyPoint(r,n[0])||collidePolyPoint(n,r[0])||r.find(((e,o,t)=>((e,o,t)=>e.find(((e,r,n)=>((e,o,t,r)=>{const n=(r[1]-t[1])*(o[0]-e[0])-(r[0]-t[0])*(o[1]-e[1]),a=((r[0]-t[0])*(e[1]-t[1])-(r[1]-t[1])*(e[0]-t[0]))/n,c=((o[0]-e[0])*(e[1]-t[1])-(o[1]-e[1])*(e[0]-t[0]))/n;return a>=0&&a<=1&&c>=0&&c<=1})(o,t,e,n[r+1==n.length?0:r+1]))))(n,e,t[o+1==t.length?0:o+1])))));if(t==o.cursor)return bool(collidePolyPoint(getRectPoly(e),[x(),y()]));object(t)}var r,n;if(e==o.cursor){if(is(t,o.Rectangle))return bool(collidePolyPoint(getRectPoly(t),[x(),y()]));if(t==o.cursor)return Sk.builtins.bool.true$;object(t)}object(e)})),l={set:(e,o)=>{if(e.ob$type==l.class)o.forEach(((o,t,r)=>r[t]=t<e.$data.length?e.$get()[t]:o));else{if(!Sk.builtin.checkSequence(e))throw new Sk.builtins.TypeError(\"attribute must be a sequence of values\");o.forEach(((o,t,r)=>r[t]=t<e.v.length?e.v[t].v:o))}return o},new:(e,o,...t)=>{const r=call(l.class);return r.$parent=e,r.$get=o,r.$data=t.map((e=>({name:e[0],set:e[1]}))),r},class:build(((e,o)=>{o.__getattr__=def(((e,o)=>{const t=e.$data.findIndex((e=>e.name==o.v));if(-1!=t)return float(e.$get()[t])})),o.__setattr__=def(((e,o,t)=>{const r=e.$data.find((e=>e.name==o.v));r&&r.set(e.$parent,t)})),o.__str__=def((e=>str(`(${e.$get().join(\", \")})`))),o.__repr__=def((e=>str(`[${e.$get().join(\", \")}]`)))}),\"Vector\")},u={new:(e,o,t,r,n)=>{e.$color=l.set(n,[0,0,0,1]),e.$pos=[number(o),number(t)],e.$angle=number(r),e.$anchor=[0,0],e.$scale=[1,1]},class:build(((e,t)=>{t.collides_with=d,t.look_at=def(((e,t)=>{const set=(o,t)=>{const r=Math.atan2(t-e.$pos[1],o-e.$pos[0]);e.$angle=180*r/Math.PI};t==o.cursor?set(x(),y()):is(t,u.class)?set(...t.$pos):object(t)})),t.move_toward=def(((e,t,r)=>{const n=number(r)??1,set=(o,t)=>{const r=o-e.$pos[0],a=t-e.$pos[1];Math.hypot(r,a)<n?(e.$pos[0]+=r,e.$pos[1]+=a):(e.$pos[0]+=Math.cos(Math.atan2(a,r))*n,e.$pos[1]+=Math.sin(Math.atan2(a,r))*n)};t==o.cursor?set(x(),y()):is(t,u.class)?set(...t.$pos):object(t)}));const x=(e,o)=>e.$pos[0]=number(o),y=(e,o)=>e.$pos[1]=number(o);t.x=property(def((e=>float(e.$pos[0]))),def(x)),t.y=property(def((e=>float(e.$pos[1]))),def(y)),t.pos=t.position=property(def((e=>l.new(e,(()=>e.$pos),[\"x\",x],[\"y\",y]))),def(((e,o)=>l.set(o,e.$pos)))),t.top=property(def((e=>float(e.$top()))),def(((e,o)=>e.$pos[1]+=o-e.$top()))),t.left=property(def((e=>float(e.$left()))),def(((e,o)=>e.$pos[0]+=o-e.$left()))),t.bottom=property(def((e=>float(e.$bottom()))),def(((e,o)=>e.$pos[1]+=o-e.$bottom()))),t.right=property(def((e=>float(e.$right()))),def(((e,o)=>e.$pos[0]+=o-e.$right())));const scaleX=(e,o)=>e.$scale[0]=number(o),scaleY=(e,o)=>e.$scale[1]=number(o);t.scale=property(def((e=>l.new(e,(()=>e.$scale),[\"x\",scaleX],[\"y\",scaleY]))),def(((e,o)=>l.set(o,e.$scale))));const anchorX=(e,o)=>e.$anchor[0]=number(o),anchorY=(e,o)=>e.$anchor[1]=number(o);t.anchor=property(def((e=>l.new(e,(()=>e.$anchor),[\"x\",anchorX],[\"y\",anchorY]))),def(((e,o)=>l.set(o,e.$anchor)))),t.angle=property(def((e=>float(e.$angle))),def(((e,o)=>e.$angle=number(o))));const red=(e,o)=>e.$color[0]=number(o),green=(e,o)=>e.$color[1]=number(o),blue=(e,o)=>e.$color[2]=number(o),alpha=(e,o)=>e.$color[3]=number(o);t.red=property(def((e=>float(e.$color[0]))),def(red)),t.green=property(def((e=>float(e.$color[1]))),def(green)),t.blue=property(def((e=>float(e.$color[2]))),def(blue)),t.blue=property(def((e=>float(e.$color[3]))),def(alpha)),t.color=property(def((e=>l.new(e,(()=>e.$color),[\"red\",red],[\"green\",green],[\"blue\",blue],[\"alpha\",alpha]))),def(((e,o)=>l.set(o,e.$color))))}),\"Shape\")};return o.MAN=path(\"images/man.png\"),o.COIN=path(\"images/coin.png\"),o.ENEMY=path(\"images/enemy.png\"),o.DEFAULT=path(\"fonts/default.ttf\"),o.CODE=path(\"fonts/code.ttf\"),o.PENCIL=path(\"fonts/pencil.ttf\"),o.SERIF=path(\"fonts/serif.ttf\"),o.HANDWRITING=path(\"fonts/handwriting.ttf\"),o.TYPEWRITER=path(\"fonts/typewriter.ttf\"),o.JOINED=path(\"fonts/joined.ttf\"),o.window=call(build(((e,o)=>{const init=(e,o,t,r,a)=>{e.$caption=string(o),e.$color=l.set(a,[1,1,1]),n.clearColor(...e.$color,1)};init.$defaults=[str(\"JoBase\"),null,null,tuple()],init.co_varnames=[\"self\",\"caption\",\"width\",\"height\",\"color\"],o.__init__=def(init),o.close=def((e=>e.$close=!0)),o.maximize=def(blank),o.minimize=def(blank),o.focus=def(blank),o.caption=property(def((e=>str(e.$caption))),def(((e,o)=>e.$caption=string(o))));const red=(e,o)=>{e.$color[0]=number(o),n.clearColor(...e.$color,1)},green=(e,o)=>{e.$color[1]=number(o),n.clearColor(...e.$color,1)},blue=(e,o)=>{e.$color[2]=number(o),n.clearColor(...e.$color,1)};o.red=property(def((e=>float(e.$color[0]))),def(red)),o.green=property(def((e=>float(e.$color[1]))),def(green)),o.blue=property(def((e=>float(e.$color[2]))),def(blue)),o.color=property(def((e=>l.new(e,(()=>e.$color),[\"red\",red],[\"green\",green],[\"blue\",blue]))),def(((e,o)=>n.clearColor(...l.set(o,e.$color),1)))),o.width=property(def((()=>float(width())))),o.height=property(def((()=>float(height())))),o.size=property(def((e=>l.new(e,(()=>[width(),height()]),[\"x\",blank],[\"y\",blank]))),def(((e,o)=>l.set(o,new Array(2))))),o.top=property(def((()=>float(height()/2)))),o.bottom=property(def((()=>float(height()/-2)))),o.left=property(def((()=>float(width()/-2)))),o.right=property(def((()=>float(width()/2)))),o.resize=property(def((e=>bool(e.$resize))))}),\"Window\")),o.cursor=call(build(((e,o)=>{o.x=property(def((()=>float(x())))),o.y=property(def((()=>float(y())))),o.pos=o.position=property(def((e=>l.new(e,(()=>[x(),y()]),[\"x\",blank],[\"y\",blank]))),def(((e,o)=>l.set(o,new Array(2))))),o.move=property(def((e=>bool(e.$move)))),o.enter=property(def((e=>bool(e.$enter)))),o.leave=property(def((e=>bool(e.$leave)))),o.press=property(def((e=>bool(e.$press)))),o.release=property(def((e=>bool(e.$release)))),o.hold=property(def((e=>bool(e.$hold))))}),\"Cursor\")),o.cursor.$x=0,o.cursor.$y=0,o.key=call(build(((e,o)=>{o.__getattr__=def(((e,o)=>{const t=e.$data[o.v];if(t)return t.hold||t.release?(r=[str(\"press\"),bool(t.press),str(\"release\"),bool(t.release),str(\"repeat\"),bool(t.repeat)],new Sk.builtin.dict(r)):Sk.builtin.bool.false$;var r})),o.hold=property(def((e=>{for(const o in e.$data)if(e.$data[o].hold)return Sk.builtin.bool.true$;return Sk.builtin.bool.false$}))),o.press=property(def((e=>bool(e.$press)))),o.release=property(def((e=>bool(e.$release)))),o.repeat=property(def((e=>bool(e.$repeat))))}),\"Key\")),o.key.$data={space:{code:\"Space\"},apostrophe:{code:\"Quote\"},comma:{code:\"Comma\"},minus:{code:\"Minus\"},period:{code:\"Period\"},slash:{code:\"Slash\"},_0:{code:\"Digit0\"},_1:{code:\"Digit1\"},_2:{code:\"Digit2\"},_3:{code:\"Digit3\"},_4:{code:\"Digit4\"},_5:{code:\"Digit5\"},_6:{code:\"Digit6\"},_7:{code:\"Digit7\"},_8:{code:\"Digit8\"},_9:{code:\"Digit9\"},semicolon:{code:\"Semicolon\"},equal:{code:\"Equal\"},a:{code:\"KeyA\"},b:{code:\"KeyB\"},c:{code:\"KeyC\"},d:{code:\"KeyD\"},e:{code:\"KeyE\"},f:{code:\"KeyF\"},g:{code:\"KeyG\"},h:{code:\"KeyH\"},i:{code:\"KeyI\"},j:{code:\"KeyJ\"},k:{code:\"KeyK\"},l:{code:\"KeyL\"},m:{code:\"KeyM\"},n:{code:\"KeyN\"},o:{code:\"KeyO\"},p:{code:\"KeyP\"},q:{code:\"KeyQ\"},r:{code:\"KeyR\"},s:{code:\"KeyS\"},t:{code:\"KeyT\"},u:{code:\"KeyU\"},v:{code:\"KeyV\"},w:{code:\"KeyW\"},x:{code:\"KeyX\"},y:{code:\"KeyY\"},z:{code:\"KeyZ\"},left_bracket:{code:\"BracketLeft\"},backslash:{code:\"Backslash\"},right_bracket:{code:\"BracketRight\"},backquote:{code:\"Backquote\"},escape:{code:\"Escape\"},enter:{code:\"Enter\"},tab:{code:\"Tab\"},backspace:{code:\"Backspace\"},insert:{code:\"Insert\"},delete:{code:\"Delete\"},right:{code:\"ArrowRight\"},left:{code:\"ArrowLeft\"},down:{code:\"ArrowDown\"},up:{code:\"ArrowUp\"},page_up:{code:\"PageUp\"},page_down:{code:\"PageDown\"},home:{code:\"Home\"},end:{code:\"End\"},caps_lock:{code:\"CapsLock\"},scroll_lock:{code:\"ScrollLock\"},num_lock:{code:\"NumLock\"},print_screen:{code:\"PrintScreen\"},pause:{code:\"Pause\"},f1:{code:\"F1\"},f2:{code:\"F2\"},f3:{code:\"F3\"},f4:{code:\"F4\"},f5:{code:\"F5\"},f6:{code:\"F6\"},f7:{code:\"F7\"},f8:{code:\"F8\"},f9:{code:\"F9\"},f10:{code:\"F10\"},f11:{code:\"F11\"},f12:{code:\"F12\"},f13:{code:\"F13\"},f14:{code:\"F14\"},f15:{code:\"F15\"},f16:{code:\"F16\"},f17:{code:\"F17\"},f18:{code:\"F18\"},f19:{code:\"F19\"},f20:{code:\"F20\"},f21:{code:\"F21\"},f22:{code:\"F22\"},f23:{code:\"F23\"},f24:{code:\"F24\"},f25:{code:\"F25\"},pad_0:{code:\"Numpad0\"},pad_1:{code:\"Numpad1\"},pad_2:{code:\"Numpad2\"},pad_3:{code:\"Numpad3\"},pad_4:{code:\"Numpad4\"},pad_5:{code:\"Numpad5\"},pad_6:{code:\"Numpad6\"},pad_7:{code:\"Numpad7\"},pad_8:{code:\"Numpad8\"},pad_9:{code:\"Numpad9\"},decimal:{code:\"NumpadDecimal\"},divide:{code:\"NumpadDivide\"},multiply:{code:\"NumpadMultiply\"},subtract:{code:\"NumpadSubtract\"},add:{code:\"NumpadAdd\"},enter:{code:\"NumpadEnter\"},equal:{code:\"NumpadEqual\"},left_shift:{code:\"ShiftLeft\"},left_ctrl:{code:\"ControlLeft\"},left_alt:{code:\"AltLeft\"},left_super:{code:\"SuperLeft\"},right_shift:{code:\"ShiftRight\"},right_ctrl:{code:\"ControlRight\"},right_alt:{code:\"AltRight\"},right_super:{code:\"SuperRight\"},menu:{code:\"Menu\"}},o.camera=call(build(((e,o)=>{const init=(e,o,t)=>{e.$pos=[number(o),number(t)]};init.$defaults=[int(),int()],init.co_varnames=[\"self\",\"x\",\"y\"],o.__init__=def(init);const x=(e,o)=>e.$pos[0]=number(o),y=(e,o)=>e.$pos[1]=number(o);o.x=property(def((e=>float(e.$pos[0]))),def(x)),o.y=property(def((e=>float(e.$pos[1]))),def(y)),o.pos=o.position=property(def((e=>l.new(e,(()=>e.$pos),[\"x\",x],[\"y\",y]))),def(((e,o)=>l.set(o,e.$pos))))}),\"Camera\")),o.Rectangle=build(((e,o)=>{const init=(e,o,t,r,n,a,c)=>{u.new(e,o,t,a,c),e.$size=[number(r),number(n)],e.$top=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[1]>e?o[1]:e),o[0][1]);var o},e.$left=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[0]<e?o[0]:e),o[0][0]);var o},e.$bottom=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[1]<e?o[1]:e),o[0][1]);var o},e.$right=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[0]>e?o[0]:e),o[0][0]);var o}};init.$defaults=[int(),int(),int(50),int(50),int(),tuple()],init.co_varnames=[\"self\",\"x\",\"y\",\"width\",\"height\",\"angle\",\"color\"],o.__init__=def(init),o.draw=def((e=>drawShape(e,e.$size,c,n.TRIANGLE_STRIP,!1,4)));const width=(e,o)=>e.$size[0]=number(o),height=(e,o)=>e.$size[1]=number(o);o.width=property(def((e=>float(e.$size[0]))),def(width)),o.height=property(def((e=>float(e.$size[1]))),def(height)),o.size=property(def((e=>l.new(e,(()=>e.$size),[\"width\",width],[\"height\",height]))),def(((e,o)=>l.set(o,e.$size))))}),\"Rectangle\",[u.class]),o.Image=build(((e,r)=>{const init=(e,r,n,a,c,i,s,d)=>wait(((u,$)=>{call(o.Rectangle.prototype.__init__,e,n,a,i,s,c);const p=t.find((e=>e.name==string(r))),set=o=>{e.$texture=o.source,e.$size[0]||=o.width,e.$size[1]||=o.height};if(e.$color=l.set(d,[1,1,1,1]),p)return set(p),u();const m=new Image;m.crossOrigin=\"anonymous\",m.src=string(r),m.onerror=()=>$(new Sk.builtin.FileNotFoundError(`failed to load image: \"${string(r)}\"`)),m.onload=()=>{const e={name:string(r),width:m.width,height:m.height,source:createImage(m)};t.push(e),set(e),u()}}));init.$defaults=[o.MAN,int(),int(),int(),int(),int(),tuple()],init.co_varnames=[\"self\",\"name\",\"x\",\"y\",\"angle\",\"width\",\"height\",\"color\"],r.__init__=def(init),r.draw=def((e=>{n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,e.$texture),drawShape(e,e.$size,c,n.TRIANGLE_STRIP,!0,4)}))}),\"Image\",[o.Rectangle]),o.Text=build(((e,t)=>{const init=(e,t,r,n,a,c,i,s)=>wait(((d,l)=>{call(o.Rectangle.prototype.__init__,e,r,n,int(),int(),c,i),e.$font=string(s),e.$fontSize=number(a),e.$content=string(t),loadFont(e.$font).then((()=>{renderText(e),d()})).catch(l)}));init.$defaults=[str(\"Text\"),int(),int(),int(50),int(),tuple(),o.DEFAULT],init.co_varnames=[\"self\",\"content\",\"x\",\"y\",\"font_size\",\"angle\",\"color\",\"font\"],t.__init__=def(init),t.draw=def((e=>{n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,e.$texture),drawShape(e,e.$size,c,n.TRIANGLE_STRIP,!0,4)})),t.content=property(def((e=>str(e.$content))),def(((e,o)=>{e.$content=string(o),renderText(e)}))),t.font=property(def((e=>str(e.$font))),def(((e,o)=>wait(((t,r)=>{loadFont(e.$font=string(o)).then((()=>{renderText(e),t()})).catch(r)}))))),t.font_size=property(def((e=>float(e.$font_size))),def(((e,o)=>{e.$font_size=number(o),renderText(e)})))}),\"Text\",[o.Rectangle]),o.random=def(((e,o)=>{const t=Math.min(number(e),number(o));return float(Math.random()*(Math.max(number(e),number(o))-t)+t)})),o.run=def((()=>wait(((r,i)=>{const update=()=>{const final=o=>{n.deleteBuffer(c),n.deleteProgram(a),t.forEach((e=>n.deleteTexture(e.source))),d.disconnect(),e.removeEventListener(\"mouseenter\",mouseEnter),e.removeEventListener(\"mouseleave\",mouseLeave),e.removeEventListener(\"mousedown\",mouseDown),e.removeEventListener(\"mouseup\",mouseUp),e.removeEventListener(\"mousemove\",mouseMove),e.removeEventListener(\"keydown\",keyDown),e.removeEventListener(\"keyup\",keyUp),cancelAnimationFrame(s.frame),o?i(o):r()};if(o.window.$close||Date.now()-Sk.execStart>Sk.execLimit)return final();const l=o.camera.$pos[0],u=o.camera.$pos[1],$=new Float32Array([2/width(),0,0,0,0,2/height(),0,0,0,0,-2,0,2*-l/width(),2*-u/height(),-1,1]);n.uniformMatrix4fv(n.getUniformLocation(a,\"camera\"),!1,$),n.clear(n.COLOR_BUFFER_BIT);try{s.main.$d.loop&&call(s.main.$d.loop)}catch(p){final(p)}o.window.$resize=!1,o.cursor.$move=!1,o.cursor.$enter=!1,o.cursor.$leave=!1,o.cursor.$press=!1,o.cursor.$release=!1,o.key.$press=!1,o.key.$release=!1,o.key.$repeat=!1;for(const e in o.key.$data)o.key.$data[e].press=!1,o.key.$data[e].release=!1,o.key.$data[e].repeat=!1},loop=()=>{s.frame=requestAnimationFrame(loop),update()},s={main:Sk.importModule(\"__main__\",!1,!0),frame:requestAnimationFrame(loop)},d=new MutationObserver((()=>{n.viewport(0,0,e.width,e.height),o.window.$resize=!0,update()}));d.observe(e,{attributes:!0})})))),e.addEventListener(\"mouseenter\",mouseEnter),e.addEventListener(\"mouseleave\",mouseLeave),e.addEventListener(\"mousedown\",mouseDown),e.addEventListener(\"mouseup\",mouseUp),e.addEventListener(\"mousemove\",mouseMove),e.addEventListener(\"keydown\",keyDown),e.addEventListener(\"keyup\",keyUp),e.tabIndex=0,e.focus(),n.shaderSource(i,\"\\n        attribute vec2 vertex;\\n        attribute vec2 coordinate;\\n        varying vec2 position;\\n        \\n        uniform mat4 camera;\\n        uniform mat4 object;\\n        \\n        void main(void) {\\n            gl_Position = camera * object * vec4(vertex, 0, 1);\\n            position = coordinate;\\n        }\"),n.shaderSource(s,\"\\n        precision mediump float;\\n        varying vec2 position;\\n\\n        uniform vec4 color;\\n        uniform sampler2D sampler;\\n        uniform int image;\\n\\n        void main(void) {\\n            if (image == 1) gl_FragColor = texture2D(sampler, position) * color;\\n            else gl_FragColor = color;\\n        }\"),n.compileShader(i),n.compileShader(s),n.attachShader(a,i),n.attachShader(a,s),n.linkProgram(a),n.useProgram(a),n.uniform1i(n.getUniformLocation(a,\"sampler\"),0),n.deleteShader(i),n.deleteShader(s),n.bindBuffer(n.ARRAY_BUFFER,c),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-.5,.5,0,0,.5,.5,1,0,-.5,-.5,0,1,.5,-.5,1,1]),n.STATIC_DRAW),n.vertexAttribPointer(n.getAttribLocation(a,\"vertex\"),2,n.FLOAT,!1,16,0),n.vertexAttribPointer(n.getAttribLocation(a,\"coordinate\"),2,n.FLOAT,!1,16,8),n.enableVertexAttribArray(0),n.enableVertexAttribArray(1),n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.pixelStorei(n.UNPACK_ALIGNMENT,1),o};","src/lib/_strptime.js":"function $builtinmodule(){const e=Sk.builtin.int_,t=Sk.builtin.none.none$,i=Sk.builtin.str,s=Sk.builtin.tuple,n=Sk.misceval.callsimOrSuspendArray,{isTrue:a,richCompareBool:r,chain:l}=Sk.misceval,{typeName:o,setUpModuleMethods:_,buildNativeClass:c}=Sk.abstr,{TypeError:m,ValueError:d,KeyError:h,IndexError:f,checkString:u,asnum$:w}=Sk.builtin,{remapToPy:p,remapToJs:g}=Sk.ffi,{getAttr:$,setAttr:y}=Sk.generic,S=l,k=/^[0-9]+$/;function _as_integer(e){if(!k.test(e))throw new d(`invalid literal for int() with base 10: '${e}'`);return parseInt(e)}const b=/([\\\\.^$*+?\\(\\){}\\[\\]|])/g,v=/\\s+/g;let O=Sk.importModule(\"time\",!1,!0),z=Sk.importModule(\"datetime\",!1,!0);const L=S(z,(e=>(z=e.$d,O)),(e=>{O=e.$d}));return S(L,(()=>{function _strftime(e){return t=>e.$strftime(t).toString().toLowerCase()}function _strftime_timetuple(e,t){return O.strftime.tp$call([new i(e),t]).toString().toLowerCase()}const l=new i(\"fromordinal\");function _struct_time(t){return O.struct_time.tp$call([new s(t.map((t=>new e(t))))])}function _localized_month(){const e=[()=>\"\"];for(let t=0;t<12;t++){const i=new k(2001,t+1,1);e.push(_strftime(i))}return e}function _localized_day(){const e=[];for(let t=0;t<7;t++){const i=new k(2001,1,t+1);e.push(_strftime(i))}return e}const S={__name__:new i(\"_strptime\")},k=z.date,L=z.timedelta,E=z.timezone;function _getlang(){return[t,t]}class LocaleTime{constructor(){this.lang=_getlang(),this.__calc_weekday(),this.__calc_month(),this.__calc_am_pm(),this.__calc_timezone(),this.__calc_date_time()}__calc_weekday(){this.a_weekday=_localized_day().map((e=>e(\"%a\"))),this.f_weekday=_localized_day().map((e=>e(\"%A\")))}__calc_month(){this.a_month=_localized_month().map((e=>e(\"%b\"))),this.f_month=_localized_month().map((e=>e(\"%B\")))}__calc_am_pm(){const e=[];[1,22].forEach((t=>{const i=_strftime_timetuple(\"%p\",_struct_time([1999,3,17,t,44,55,2,76,0]));e.push(i)})),this.am_pm=e}__calc_date_time(){const e=_struct_time([1999,3,17,22,44,55,2,76,0]),i=[t,t,t];i[0]=_strftime_timetuple(\"%c\",e),i[1]=_strftime_timetuple(\"%x\",e),i[2]=_strftime_timetuple(\"%X\",e);const s=[[\"%\",\"%%\"],[this.f_weekday[2],\"%A\"],[this.f_month[3],\"%B\"],[this.a_weekday[2],\"%a\"],[this.a_month[3],\"%b\"],[this.am_pm[1],\"%p\"],[\"1999\",\"%Y\"],[\"99\",\"%y\"],[\"22\",\"%H\"],[\"44\",\"%M\"],[\"55\",\"%S\"],[\"76\",\"%j\"],[\"17\",\"%d\"],[\"03\",\"%m\"],[\"3\",\"%m\"],[\"2\",\"%w\"],[\"10\",\"%I\"]];s.push(...this.timezone.flat().map((e=>[e,\"%Z\"]))),[[0,\"%c\"],[1,\"%x\"],[2,\"%X\"]].forEach((([e,t])=>{let n=i[e];s.forEach((([e,t])=>{e&&(n=n.replace(e,t))}));let a;a=_strftime_timetuple(t,_struct_time([1999,1,3,1,1,1,6,3,0])).includes(\"00\")?\"%W\":\"%U\",i[e]=n.replace(\"11\",a)})),this.LC_date_time=i[0],this.LC_date=i[1],this.LC_time=i[2]}__calc_timezone(){try{O.tzset.tp$call([])}catch{}this.tzname=O.tzname.v.map((e=>e.toString())),this.daylight=w(O.daylight);const e=[this.tzname[0].toLowerCase(),\"utc\",\"gmt\"];let t;t=this.daylight?[this.tzname[1].toLowerCase()]:[],this.timezone=[e,t]}}class TimeRE{constructor(e=null){this.locale_time=e||new LocaleTime,Object.assign(this,{d:\"(?<d>3[0-1]|[1-2]\\\\d|0[1-9]|[1-9]| [1-9])\",f:\"(?<f>[0-9]{1,6})\",H:\"(?<H>2[0-3]|[0-1]\\\\d|\\\\d)\",I:\"(?<I>1[0-2]|0[1-9]|[1-9])\",G:\"(?<G>\\\\d\\\\d\\\\d\\\\d)\",j:\"(?<j>36[0-6]|3[0-5]\\\\d|[1-2]\\\\d\\\\d|0[1-9]\\\\d|00[1-9]|[1-9]\\\\d|0[1-9]|[1-9])\",m:\"(?<m>1[0-2]|0[1-9]|[1-9])\",M:\"(?<M>[0-5]\\\\d|\\\\d)\",S:\"(?<S>6[0-1]|[0-5]\\\\d|\\\\d)\",U:\"(?<U>5[0-3]|[0-4]\\\\d|\\\\d)\",w:\"(?<w>[0-6])\",u:\"(?<u>[1-7])\",V:\"(?<V>5[0-3]|0[1-9]|[1-4]\\\\d|\\\\d)\",y:\"(?<y>\\\\d\\\\d)\",Y:\"(?<Y>\\\\d\\\\d\\\\d\\\\d)\",z:\"(?<z>[+-]\\\\d\\\\d:?[0-5]\\\\d(:?[0-5]\\\\d(\\\\.\\\\d{1,6})?)?|Z)\",A:this.__seqToRE(this.locale_time.f_weekday,\"A\"),a:this.__seqToRE(this.locale_time.a_weekday,\"a\"),B:this.__seqToRE(this.locale_time.f_month.slice(1),\"B\"),b:this.__seqToRE(this.locale_time.a_month.slice(1),\"b\"),p:this.__seqToRE(this.locale_time.am_pm,\"p\"),Z:this.__seqToRE(this.locale_time.timezone.flat(),\"Z\"),\"%\":\"%\"}),this.W=this.U.replace(\"U\",\"W\"),this.x=this.pattern(this.locale_time.LC_date),this.X=this.pattern(this.locale_time.LC_time),this.c=this.pattern(this.locale_time.LC_date_time)}__seqToRE(e,t){if((e=e.slice(0).sort(((e,t)=>t.length-e.length))).every((e=>\"\"===e)))return\"\";return`(?<${t}>${e.map((e=>e)).join(\"|\")})`}pattern(e){let t=\"\";for(e=(e=e.replace(b,\"\\\\$1\")).replace(v,\"\\\\s+\");e.includes(\"%\");){const i=e.indexOf(\"%\")+1,s=this[e[i]];if(void 0===s)throw new h(e[i]);t=`${t}${e.slice(0,i-1)}${s}`,e=e.slice(i+1)}return t+e}compile(e){return new RegExp(\"^\"+this.pattern(e),\"i\")}}let C=new TimeRE;let T={};function _strptime(i,s=\"%a %b %d %H:%M:%S %Y\"){function _checkString(e,t){if(\"string\"!=typeof e&&!u(e))throw new m(`strptime() argument ${t} must be a str, not '${o(e)}'`)}_checkString(i,0),_checkString(s,1),i=i.toString(),s=s.toString();let n,_=C.locale_time;if(Object.keys(T).length>5&&(T={}),n=T[s],void 0===n)try{n=C.compile(s)}catch(R){if(R instanceof h){let e=R.args.v[0];throw\"\\\\\"==e&&(e=\"%\"),new d(`'${e}' is a bad directive in format '${s}'`)}if(R instanceof f)throw new d(\"stray %% in format '\"+s+\"'\");throw R}const c=i.match(n);if(null===c)throw new d(`time data '${i}' does not match format '${s}'`);if(i.length!==c[0].length)throw new d(`unconverted data remains: ${i.slice(c[0].length)}`);let w=t,p=t,g=1,$=1,y=0,S=0,b=0,v=0,z=-1,L=t,E=0,A=t,I=t,M=t,H=t,Y=t,j=c.groups||{};if(Object.keys(j).forEach((e=>{if(void 0!==j[e])if(\"y\"===e)p=_as_integer(j.y),p+=p<=68?2e3:1900;else if(\"Y\"===e)p=_as_integer(j.Y);else if(\"G\"===e)w=_as_integer(j.G);else if(\"m\"===e)g=_as_integer(j.m);else if(\"B\"===e)g=_.f_month.indexOf(j.B.toLowerCase());else if(\"b\"===e)g=_.a_month.indexOf(j.b.toLowerCase());else if(\"d\"===e)$=_as_integer(j.d);else if(\"H\"===e)y=_as_integer(j.H);else if(\"H\"===e)y=_as_integer(j.H);else if(\"I\"===e){y=_as_integer(j.I);const e=(j.p||\"\").toLowerCase();[\"\",_.am_pm[0]].includes(e)?12===y&&(y=0):e===_.am_pm[1]&&12!==y&&(y+=12)}else if(\"M\"===e)S=_as_integer(j.M);else if(\"S\"===e)b=_as_integer(j.S);else if(\"f\"===e){let e=j.f;e+=\"0\".repeat(6-e.length),v=_as_integer(e)}else if(\"A\"===e)H=_.f_weekday.indexOf(j.A.toLowerCase());else if(\"a\"===e)H=_.a_weekday.indexOf(j.a.toLowerCase());else if(\"w\"===e)H=_as_integer(j.w),0===H?H=6:H-=1;else if(\"u\"===e)H=_as_integer(j.u),H-=1;else if(\"j\"===e)Y=_as_integer(j.j);else if([\"U\",\"W\"].includes(e))I=_as_integer(j[e]),M=\"U\"===e?6:0;else if(\"V\"===e)A=_as_integer(j.V);else if(\"z\"===e){let e=j.z;if(\"Z\"===e)L=0;else{if(\":\"===e[3]&&(e=e.slice(0,3)+e.slice(4),e.length>5)){if(\":\"!==e[5]){const e=`Inconsistent use of : in ${j.z}`;throw new d(e)}e=e.slice(0,5)+e.slice(6)}const t=_as_integer(e.slice(1,3)),i=_as_integer(e.slice(3,5)),s=_as_integer(e.slice(5,7)||0);L=3600*t+60*i+s;const n=e.slice(8),a=\"0\".repeat(6-n.length);E=_as_integer(n+a),e.startsWith(\"-\")&&(L=-L,E=-E)}}else if(\"Z\"===e){let e=j.Z.toLowerCase(),t=0;for(let i of _.timezone){if(i.includes(e)){const i=O.tzname.v;if(r(i[0],i[1],\"Eq\")&&a(O.daylight)&&![\"utc\",\"gmt\"].includes(e))break;z=t}t++}}})),p===t&&w!==t){if(A===t||H===t)throw new d(\"ISO year directive '%G' must be used with the ISO week directive '%V' and a weekday directive ('%A','%a', '%w', or '%u').\");if(Y!==t)throw new d(\"Day of the year directive '%j' is not compatible with ISO year directive '%G'.Use '%Y' instead.\")}else if(I===t&&A!==t)throw new d(H===t?\"ISO week directive '%V' must be used with the ISO year directive '%G' and a weekday directive ('%A', '%a', '%w', or '%u').\":\"ISO week directive '%V' is incompatible with the year directive '%Y'. Use the ISO year '%G' instead.\");let U=!1;if(p===t&&2===g&&29===$?(p=1904,U=!0):p===t&&(p=1900),Y===t&&H!==t){if(I!==t){Y=function _calc_julian_from_U_or_W(e,t,i,s){let n=(new k(e,1,1).$toOrdinal()+6)%7;return s||(n=(n+1)%7,i=(i+1)%7),0===t?1+i-n:(7-n)%7+7*(t-1)+1+i}(p,I,H,0===M)}else w!==t&&A!==t&&([p,Y]=function _calc_julian_from_V(e,t,i){let s=7*t+i-((new k(e,1,4).$toOrdinal()%7||7)+3);return s<1&&(s+=new k(e,1,1).$toOrdinal(),s-=new k(e-=1,1,1).$toOrdinal()),[e,s]}(w,A,H+1));if(Y!==t&&Y<=0){p-=1;const e=function _is_leap(e){return e%4==0&&(e%100!=0||e%400==0)}(p)?366:365;Y+=e}}if(Y===t)Y=new k(p,g,$).$toOrdinal()-new k(p,1,1).$toOrdinal()+1;else{const t=function _fromordinal(t){return k.tp$getattr(l).tp$call([new e(t)])}(Y-1+new k(p,1,1).$toOrdinal());p=t.$year,g=t.$month,$=t.$day}H===t&&(H=(new k(p,g,$).$toOrdinal()+6)%7);const x=j.Z||t;return U&&(p=1900),[[p,g,$,y,S,b,H,Y,z,x,L],v,E]}return _(\"_strptime\",S,{_strptime_time:{$meth:function _strptime_time(t,i=\"%a %b %d %H:%M:%S %Y\"){let n=_strptime(t,i)[0].slice(0,11);return n=n.map(((t,i)=>i<9?new e(t):p(t))),O.struct_time.tp$call([new s(n)])},$flags:{NamedArgs:[\"data_string\",\"format\"],Defaults:[\"%a %b %d %H:%M:%S %Y\"]}},_strptime_datetime:{$meth:function _strptime_datetime(s,r,l=\"%a %b %d %H:%M:%S %Y\"){const[o,_,c]=_strptime(r,l),[m,d]=o.slice(-2),h=o.slice(0,6);let f,u;return h.push(_),h.map((t=>new e(t))),d!==t&&(f=new L(0,d,c),u=a(m)?new E(f,new i(m)):new E(f),h.push(u)),n(s,h)},$flags:{NamedArgs:[\"cls\",\"data_string\",\"format\"],Defaults:[\"%a %b %d %H:%M:%S %Y\"]}},_strptime:{$meth(i,n){const a=_strptime(i,n);return a[0]=new s(a[0].map((i=>i===t?i:new e(i)))),a[1]=new e(a[1]),a[2]=new e(a[2]),new s(a)},$flags:{NamedArgs:[\"data_string\",\"format\"],Defaults:[\"%a %b %d %H:%M:%S %Y\"]}},_getlang:{$meth:()=>p(_getlang()),$flags:{NoArgs:!0}}}),S.LocaleTime=c(\"_strptime.LocaleTime\",{constructor:function(){this.v=new LocaleTime},slots:{tp$getattr(e,t){return this.v.hasOwnProperty(e.toString())?p(this.v[e.toString()]):$.call(this,e,t)},tp$setattr(e,t){if(!this.v.hasOwnProperty(e.toString()))return y.call(this,e,t);this.v[e.toString()]=g(t)}}}),S}))}","src/lib/altair/vega_caller.js":"var $builtinmodule=function(e){var n={__file__:\"/src/lib/vega_caller.js\"};return n.__package__=Sk.builtin.none.none$,n.render_graph=new Sk.builtin.func((function(e){Sk.builtin.pyCheckArgs(\"render_graph\",arguments,1,1);let n=\"#\"+Sk.divid+\"_graphics\";try{vegaEmbed(n,Sk.ffi.remapToJs(e),{actions:!0})}catch(i){throw new Sk.builtin.Exception(\"Error in graph specification unable to render the graph\\n\"+i.message)}})),n};","src/lib/array.js":"function $builtinmodule(e){var n={},t=[\"c\",\"b\",\"B\",\"u\",\"h\",\"H\",\"i\",\"I\",\"l\",\"L\",\"f\",\"d\"];return n.__name__=new Sk.builtin.str(\"array\"),n.array=Sk.misceval.buildClass(n,(function(e,n){n.__init__=new Sk.builtin.func((function(e,n,i){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,3),-1==t.indexOf(Sk.ffi.remapToJs(n)))throw new Sk.builtin.ValueError(\"bad typecode (must be c, b, B, u, h, H, i, I, l, L, f or d)\");if(i&&!Sk.builtin.checkIterable(i))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");if(e.$d.mp$ass_subscript(new Sk.builtin.str(\"typecode\"),n),e.$d.mp$ass_subscript(new Sk.builtin.str(\"__module__\"),new Sk.builtin.str(\"array\")),e.typecode=n,void 0===i)e.internalIterable=new Sk.builtin.list;else if(i instanceof Sk.builtin.list)e.internalIterable=i;else{e.internalIterable=new Sk.builtin.list;for(let n=Sk.abstr.iter(i),t=n.tp$iternext();void 0!==t;t=n.tp$iternext())Sk.misceval.callsimArray(e.internalIterable.append,[e.internalIterable,t])}})),n.__repr__=new Sk.builtin.func((function(e){var n=Sk.ffi.remapToJs(e.typecode),t=\"\";return Sk.ffi.remapToJs(e.internalIterable).length&&(t=\"c\"==Sk.ffi.remapToJs(e.typecode)?\", '\"+Sk.ffi.remapToJs(e.internalIterable).join(\"\")+\"'\":\", \"+Sk.ffi.remapToJs(Sk.misceval.callsimArray(e.internalIterable.__repr__,[e.internalIterable]))),new Sk.builtin.str(\"array('\"+n+\"'\"+t+\")\")})),n.__str__=n.__repr__,n.__getattribute__=new Sk.builtin.func((function(e,n){return e.tp$getattr(n)})),n.append=new Sk.builtin.func((function(e,n){return Sk.misceval.callsimArray(e.internalIterable.append,[e.internalIterable,n]),Sk.builtin.none.none$})),n.extend=new Sk.builtin.func((function(e,n){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2),!Sk.builtin.checkIterable(n))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");for(let t=Sk.abstr.iter(n),i=t.tp$iternext();void 0!==i;i=t.tp$iternext())Sk.misceval.callsimArray(e.internalIterable.append,[e.internalIterable,i])}))}),\"array\",[]),n}","src/lib/calendar.js":"function $builtinmodule(e){const t={},{misceval:{chain:n},importModule:r}=Sk,importOrSuspend=e=>r(e,!1,!0);return n(importOrSuspend(\"datetime\"),(e=>(t.datetime=e,importOrSuspend(\"itertools\"))),(e=>(t.iterRepeat=e.$d.repeat,t.iterChain=e.$d.chain,calendarModule(t))))}function calendarModule(e){const{abstr:{setUpModuleMethods:t,numberBinOp:n,iter:r,objectGetItem:o},builtin:{bool:s,bool:{true$:m,false$:d},func:l,int_:i,list:c,none:{none$:f},str:h,slice:w,tuple:y,range:u,max:_,min:g,property:k,print:p,enumerate:$,ValueError:b},ffi:{remapToPy:M},misceval:{isTrue:T,iterator:C,arrayFromIterable:O,buildClass:L,richCompareBool:x,asIndexOrThrow:F,objectRepr:I,callsimArray:A},global:v,global:{strftime:E}}=Sk,S=new i(0),H=new i(1),D=new i(2),N=new i(3),R=new i(6),j=new i(7),J=new i(9),P=new i(12),Y=new i(13),U=new i(24),z=new i(60),le=(e,t)=>x(e,t,\"LtE\"),eq=(e,t)=>x(e,t,\"Eq\"),mod=(e,t)=>n(e,t,\"Mod\"),add=(e,t)=>n(e,t,\"Add\"),sub=(e,t)=>n(e,t,\"Sub\"),mul=(e,t)=>n(e,t,\"Mult\"),inc=e=>add(e,H),dec=e=>sub(e,H),mod7=e=>mod(e,j),getA=(e,t)=>e.tp$getattr(new h(t)),callA=(e,t,...n)=>A(e.tp$getattr(new h(t)),n);function*iterJs(e){const t=r(e);let n;for(;n=t.tp$iternext();)yield n}function iterFn(e,t){return e=r(e),new C((()=>{const n=e.tp$iternext();return n&&t(n)}),!0)}function makePyMethod(e,t,{args:n,name:r,doc:o,defaults:s}){t.co_varnames=[\"self\",...n||[]],t.co_docstring=o?new h(o):f,s&&(t.$defaults=s),t.co_name=new h(r),t.co_qualname=new h(e+\".\"+r);const m=new l(t);return m.$module=Q.__name__,m}const{datetime:B,iterRepeat:W,iterChain:q}=e;let{MINYEAR:G,MAXYEAR:X,date:V}=B.$d;const K=getA(h,\"center\"),pyCenter=(e,t)=>A(K,[e,t]),pyRStrip=e=>new h(e.toString().trimRight());G=G.valueOf(),X=X.valueOf();const Q={__name__:new h(\"calendar\"),__all__:M([\"IllegalMonthError\",\"IllegalWeekdayError\",\"setfirstweekday\",\"firstweekday\",\"isleap\",\"leapdays\",\"weekday\",\"monthrange\",\"monthcalendar\",\"prmonth\",\"month\",\"prcal\",\"calendar\",\"timegm\",\"month_name\",\"month_abbr\",\"day_name\",\"day_abbr\",\"Calendar\",\"TextCalendar\",\"HTMLCalendar\",\"LocaleTextCalendar\",\"LocaleHTMLCalendar\",\"weekheader\"])};function makeErr(e,t){return L(Q,((e,n)=>{n.__init__=new l((function __init__(e,t){e.$attr=t})),n.__str__=new l((function __str__(e){return new h(t.replace(\"$\",I(e.$attr)))}))}),e,[b])}const Z=makeErr(\"IllegalMonthError\",\"bad month $; must be 1-12\"),ee=makeErr(\"IllegalWeekdayError\",\"bad weekday number $; must be 0 (Monday) to 6 (Sunday)\"),te=[0,31,28,31,30,31,30,31,31,30,31,30,31];function mkLocalizedCls(e,t){t.__init__=new l((function __init__(e,t){e.format=t})),t.__getitem__=new l((function __getitem__(t,n){const r=o(e,n);if(n instanceof w){const e=[];for(const n of r.valueOf())e.push(A(n,[t.format]));return new c(e)}return A(r,[t.format])}));const n=new i(e.valueOf().length);t.__len__=new l((function __len__(e){return n}))}const ae=new h(\"strftime\"),ne=L(Q,((e,t)=>{let n=[new l((e=>h.$empty))];for(let r=0;r<12;r++){const e=new V(2001,r+1,1);n.push(e.tp$getattr(ae))}n=new c(n),t._months=n,mkLocalizedCls(n,t)}),\"_localized_month\"),re=L(Q,((e,t)=>{let n=[];for(let r=0;r<7;r++){const e=new V(2001,1,r+1);n.push(e.tp$getattr(ae))}n=new c(n),t._days=n,mkLocalizedCls(n,t)}),\"_localized_day\"),oe=A(re,[new h(\"%A\")]),se=A(re,[new h(\"%a\")]),me=A(ne,[new h(\"%B\")]),de=A(ne,[new h(\"%b\")]),[ie,ce,fe,he,we,ye,ue]=[0,1,2,3,4,5,6];function isleap(e){return(e=F(e))%4==0&&(e%100!=0||e%400==0)}function weekday(e,t,n){e=F(e),G<=e&&e<=X||(e=2e3+e%400);const r=A(V,[new i(e),t,n]);return callA(V,\"weekday\",r)}function monthrange(e,t){if(!le(H,t)||!le(t,P))throw A(Z,[t]);const n=weekday(e,t,H);t=F(t);const r=te[t]+Number(2===t&&isleap(e));return[n,new i(r)]}function iterweekdays(e){return iterFn(A(u,[e.fwd,add(e.fwd,j)]),mod7)}function itermonthdates(e,t,n){return iterFn(itermonthdays3(e,t,n),(e=>A(V,e.valueOf())))}function itermonthdays(e,t,n){const[r,o]=monthrange(t,n),s=mod7(sub(r,e.fwd)),m=A(W,[S,s]),d=A(u,[H,inc(o)]),l=mod7(sub(e.fwd,add(r,o))),i=A(W,[S,l]);return A(q,[m,d,i])}function itermonthdays2(e,t,n){return iterFn(A($,[itermonthdays(e,t,n),e.fwd]),(e=>{const[t,n]=e.valueOf();return new y([n,mod7(t)])}))}function itermonthdays3(e,t,n){const ymdIter=(e,t,n)=>iterFn(n,(n=>new y([e,t,n]))),[r,o]=monthrange(t,n),s=mod7(sub(r,e.fwd)),m=mod7(sub(e.fwd,add(r,o))),[d,l]=function _prevmonth(e,t){return eq(t,H)?[dec(e),P]:[e,dec(t)]}(t,n),c=inc(function _monthlen(e,t){return t=F(t),new i(te[t]+Number(2===t&&isleap(e)))}(d,l)),f=A(u,[sub(c,s),c]),h=A(u,[H,inc(o)]),[w,_]=function _nextmonth(e,t){return eq(t,P)?[inc(e),H]:[e,inc(t)]}(t,n),g=A(u,[H,inc(m)]);return A(q,[ymdIter(d,l,f),ymdIter(t,n,h),ymdIter(w,_,g)])}function itermonthdays4(e,t,n){const r=itermonthdays3(e,t,n);let o=0;return iterFn(r,(t=>new y([...t.valueOf(),mod7(add(e.fwd,new i(o++)))])))}function _monthIter(e,t,n,r){const o=O(e(t,n,r)),s=[];for(let m=0;m<o.length;m+=7)s.push(new c(o.slice(m,m+7)));return new c(s)}function monthdatescalendar(e,t,n){return _monthIter(itermonthdates,e,t,n)}function monthdays2calendar(e,t,n){return _monthIter(itermonthdays2,e,t,n)}function monthdayscalendar(e,t,n){return _monthIter(itermonthdays,e,t,n)}function _yearIter(e,t,n,r){r=F(r);const o=[];for(let m=1;m<13;m++)o.push(e(t,n,new i(m)));const s=[];for(let m=0;m<o.length;m+=r)s.push(new c(o.slice(m,m+r)));return new c(s)}function yeardatescalendar(e,t,n){return _yearIter(monthdatescalendar,e,t,n)}function yeardays2calendar(e,t,n){return _yearIter(monthdays2calendar,e,t,n)}function yeardayscalendar(e,t,n){return _yearIter(monthdayscalendar,e,t,n)}const _e=L(Q,((e,t)=>{const n=makePyMethod.bind(null,\"Calendar\"),r=[\"firstweekday\"],o=[\"year\",\"month\"],s=[\"year\",\"width\"],m={__init__:n((function __init__(e,t){return Object.defineProperty(e,\"fwd\",{get(){return mod7(this._fwd)},set(e){return this._fwd=e,!0}}),e.fwd=t,f}),{name:\"__init__\",args:r,defaults:[S]}),getfirstweekday:n((function getfirstweekday(e){return e.fwd}),{name:\"getfirstweekday\"}),setfirstweekday:n((function setfirstweekday(e,t){return e.fwd=t,f}),{name:\"setfirstweekday\",args:r}),iterweekdays:n(iterweekdays,{name:\"iterweekdays\"}),itermonthdates:n(itermonthdates,{name:\"itermonthdates\",args:o}),itermonthdays:n(itermonthdays,{name:\"itermonthdays\",args:o}),itermonthdays2:n(itermonthdays2,{name:\"itermonthdays2\",args:o}),itermonthdays3:n(itermonthdays3,{name:\"itermonthdays3\",args:o}),itermonthdays4:n(itermonthdays4,{name:\"itermonthdays4\",args:o}),monthdatescalendar:n(monthdatescalendar,{name:\"monthdatescalendar\",args:o}),monthdays2calendar:n(monthdays2calendar,{name:\"monthdays2calendar\",args:o}),monthdayscalendar:n(monthdayscalendar,{name:\"monthdayscalendar\",args:o}),yeardatescalendar:n(yeardatescalendar,{name:\"yeardatescalendar\",args:s,defaults:[N]}),yeardays2calendar:n(yeardays2calendar,{name:\"yeardays2calendar\",args:s,defaults:[N]}),yeardayscalendar:n(yeardayscalendar,{name:\"yeardayscalendar\",args:s,defaults:[N]})};m.firstweekday=new k(m.getfirstweekday,m.setfirstweekday),Object.assign(t,m)}),\"Calendar\");function doTextFormatweekday(e,t,n){let r;return r=x(n,J,\"GtE\")?oe:se,pyCenter(o(o(r,t),new w(f,n)),n)}function doTextFormatmonthname(e,t,n,r,s=!0){let m=o(me,n);return T(s)&&(m=mod(new h(\"%s %r\"),new y([m,t]))),pyCenter(m,r)}const ge=L(Q,((e,t)=>{const txtPrint=e=>p([e],[\"end\",h.$empty]);const n=doTextFormatweekday;function formatweekheader(e,t){const n=[];for(const r of iterJs(iterweekdays(e)))n.push(callA(e,\"formatweekday\",r,t).toString());return new h(n.join(\" \"))}const r=doTextFormatmonthname;const o=makePyMethod.bind(null,\"TextCalendar\"),s={prweek:o((function prweek(e,t,n){txtPrint(callA(e,\"formatweek\",t,n))}),{name:\"prweek\",args:[\"theweek\",\"width\"]}),formatday:o((function formatday(e,t,n,r){let o;return o=eq(t,S)?h.$empty:mod(new h(\"%2i\"),t),pyCenter(o,r)}),{name:\"formatday\",args:[\"day\",\"weekday\",\"width\"]}),formatweek:o((function formatweek(e,t,n){const r=[];for(const o of iterJs(t)){const[t,s]=o.valueOf();r.push(callA(e,\"formatday\",t,s,n).toString())}return new h(r.join(\" \"))}),{name:\"formatweek\",args:[\"theweek\",\"width\"]}),formatweekday:o(n,{name:\"formatweekday\",args:[\"day\",\"width\"]}),formatweekheader:o(formatweekheader,{name:\"formatweekheader\",args:[\"width\"]}),formatmonthname:o(r,{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"width\",\"withyear\"],defaults:[m]}),prmonth:o((function prmonth(e,t,n,r,o){txtPrint(callA(e,\"formatmonth\",t,n,r,o))}),{name:\"prmonth\",args:[\"theyear\",\"themonth\",\"w\",\"l\"],defaults:[S,S]}),formatmonth:o((function formatmonth(e,t,n,r,o){const addNewLines=e=>new h(e+\"\\n\".repeat(o.valueOf()));r=_([D,r]),o=_([H,o]);let s=callA(e,\"formatmonthname\",t,n,dec(mul(j,inc(r))),!0);s=pyRStrip(s),s=addNewLines(s),s=add(s,pyRStrip(callA(e,\"formatweekheader\",r))),s=addNewLines(s);for(const m of iterJs(monthdays2calendar(e,t,n)))s=add(s,pyRStrip(callA(e,\"formatweek\",m,r))),s=addNewLines(s);return s}),{name:\"formatmonth\",args:[\"thyear\",\"themonth\",\"w\",\"l\"],defaults:[S,S]}),formatyear:o((function formatyear(e,t,n,r,o,s){n=_([D,n]),r=_([H,r]),o=_([D,o]);const m=dec(mul(inc(n),j));let d=\"\";const a=e=>d+=e;a(pyRStrip(pyCenter(t.$r(),add(mul(m,s),mul(o,dec(s)))))),a(\"\\n\".repeat(r));const l=formatweekheader(e,n);let f=0;for(const w of iterJs(yeardays2calendar(e,t,s))){const d=new i(f),y=inc(mul(s,d)),_=g([inc(mul(s,inc(d))),Y]),k=A(u,[y,_]);a(\"\\n\".repeat(r));const p=iterFn(k,(n=>callA(e,\"formatmonthname\",t,n,m,!1)));a(pyRStrip(formatstring(p,m,o))),a(\"\\n\".repeat(r));const $=iterFn(k,(e=>l));a(pyRStrip(formatstring($,m,o))),a(\"\\n\".repeat(r));const b=Math.max(...w.valueOf().map((e=>e.valueOf().length)));for(let t=0;t<b;t++){const s=[];for(let r of w.valueOf())r=r.valueOf(),t>=r.length?s.push(h.$empty):s.push(callA(e,\"formatweek\",r[t],n));a(pyRStrip(formatstring(new c(s),m,o))),a(\"\\n\".repeat(r))}f++}return new h(d)}),{name:\"formatyear\",args:[\"theyear\",\"w\",\"l\",\"c\",\"m\"],defaults:[D,H,R,N]}),pryear:o((function pryear(e,t,n,r,o,s){txtPrint(callA(e,\"formatyear\",t,n,r,o,s))}),{name:\"pryear\",args:[\"theyear\",\"w\",\"l\",\"c\",\"m\"],defaults:[S,S,R,N]})};Object.assign(t,s)}),\"TextCalendar\",[_e]);function doHtmlFormatweekday(e,t){return new h(`<th class=\"${o(getA(e,\"cssclasses_weekday_head\"),t)}\">${o(se,t)}</th>`)}function doHtmlFormatmonthname(e,t,n,r=!0){let s=\"\"+o(me,n);return T(r)&&(s+=\" \"+t),new h(`<tr><th colspan=\"7\" class=\"${getA(e,\"cssclass_month_head\")}\">${s}</th></tr>`)}const ke=L(Q,((e,t)=>{const n=M([\"mon\",\"tue\",\"wed\",\"thu\",\"fri\",\"sat\",\"sun\"]),r=n,s=new h(\"noday\"),d=new h(\"month\"),l=d,c=new h(\"year\"),w=c,u=new h('<td class=\"%s\">&nbsp;</td>'),g=new h('<td class=\"%s\">%d</td>');const k=doHtmlFormatweekday;function formatweekheader(e){let t=\"\";for(const n of iterJs(iterweekdays(e)))t+=callA(e,\"formatweekday\",n);return new h(`<tr>${t}</tr>`)}const p=doHtmlFormatmonthname;const $=makePyMethod.bind(null,\"HTMLCalendar\"),b={formatday:$((function formatday(e,t,n){return eq(t,S)?mod(u,getA(e,\"cssclass_noday\")):mod(g,new y([o(getA(e,\"cssclasses\"),n),t]))}),{name:\"formatday\",args:[\"day\",\"weekday\"]}),formatweek:$((function formatweek(e,t){let n=\"\";for(const r of iterJs(t)){const[t,o]=r.valueOf();n+=callA(e,\"formatday\",t,o)}return new h(`<tr>${n}</tr>`)}),{name:\"formatweek\",args:[\"theweek\"]}),formatweekday:$(k,{name:\"formatweekday\",args:[\"day\"]}),formatweekheader:$(formatweekheader,{name:\"formatweekheader\"}),formatmonthname:$(p,{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"withyear\"],defaults:[m]}),formatmonth:$((function formatmonth(e,t,n,r=!0){let o=\"\";const a=e=>o+=e+\"\\n\";a(`<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"${getA(e,\"cssclass_month\")}\">`),a(callA(e,\"formatmonthname\",t,n,r)),a(formatweekheader(e));for(const s of iterJs(monthdays2calendar(e,t,n)))a(callA(e,\"formatweek\",s));return a(\"</table>\"),new h(o)}),{name:\"formatmonth\",args:[\"thyear\",\"themonth\",\"withyear\"],defaults:[m]}),formatyear:$((function formatyear(e,t,n){let r=\"\";const a=e=>r+=e;n=_([n,H]).valueOf(),a(`<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"${getA(e,\"cssclass_year\")}\">`),a(\"\\n\"),a(`<tr><th colspan=\"${n}\" class=\"${getA(e,\"cssclass_year_head\")}\">${t}</th></tr>`);for(let o=1;o<13;o+=n){a(\"<tr>\");const r=Math.min(o+n,13);for(let n=o;n<r;n++)a(\"<td>\"),a(callA(e,\"formatmonth\",t,new i(n),!1)),a(\"</td>\");a(\"</tr>\")}return a(\"</table>\"),new h(r)}),{name:\"formatyear\",args:[\"theyear\",\"width\"],defaults:[N]}),formatyearpage:$((function formatyearpage(e,t,n=3,r=\"calendar.css\",o=null){null!==o&&o!==f||(o=new h(\"utf-8\"));let s=\"\";const a=e=>s+=e;return a(`<?xml version=\"1.0\" encoding=\"${o}\"?>\\n`),a('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n'),a(\"<html>\\n\"),a(\"<head>\\n\"),a(`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=${o}\" />\\n`),r!==f&&a(`<link rel=\"stylesheet\" type=\"text/css\" href=\"${r}\" />\\n`),a(`<title>Calendar for ${t}</title>\\n`),a(\"</head>\\n\"),a(\"<body>\\n\"),a(callA(e,\"formatyear\",t,n)),a(\"</body>\\n\"),a(\"</html>\\n\"),callA(h,\"encode\",new h(s),o,new h(\"ignore\"))}),{name:\"formatyearpage\",args:[\"theyear\",\"width\",\"css\",\"encoding\"],defaults:[N,new h(\"calendar.css\"),new h(\"utf-8\")]}),cssclasses:n,cssclasses_weekday_head:r,cssclass_noday:s,cssclass_month_head:d,cssclass_month:l,cssclass_year_head:c,cssclass_year:w};Object.assign(t,b)}),\"HTMLCalendar\",[_e]);function withLocale(e,t){const n=E.localizeByIdentifier(e.toString());v.strftime=n;try{return t()}finally{v.strftime=E}}function localInit(e,t){T(t)||(t=new h(\"en_US\")),e.locale=t}const pe=L(Q,((e,t)=>{const n=makePyMethod.bind(null,\"LocaleTextCalendar\"),r={__init__:n((function __init__(e,t,n){return callA(ge,\"__init__\",e,t),localInit(e,n),f}),{name:\"__init__\",args:[\"firstweekday\",\"locale\"],defaults:[S,f]}),formatweekday:n((function formatweekday(e,t,n){return withLocale(e.locale,(()=>doTextFormatweekday(0,t,n)))}),{name:\"formatweekday\",args:[\"day\",\"width\"]}),formatmonthname:n((function formatmonthname(e,t,n,r,o){return withLocale(e.locale,(()=>doTextFormatmonthname(0,t,n,r,o)))}),{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"width\",\"withyear\"],defaults:[m]})};Object.assign(t,r)}),\"LocaleTextCalendar\",[ge]),$e=L(Q,((e,t)=>{const n=makePyMethod.bind(null,\"LocaleHTMLCalendar\"),r={__init__:n((function __init__(e,t,n){return callA(ke,\"__init__\",e,t),localInit(e,n),f}),{name:\"__init__\",args:[\"firstweekday\",\"locale\"],defaults:[S,f]}),formatweekday:n((function formatweekday(e,t){return withLocale(e.locale,(()=>doHtmlFormatweekday(e,t)))}),{name:\"formatweekday\",args:[\"day\"]}),formatmonthname:n((function formatmonthname(e,t,n,r){return withLocale(e.locale,(()=>doHtmlFormatmonthname(e,t,n,r)))}),{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"withyear\"],defaults:[m]})};Object.assign(t,r)}),\"LocaleHTMLCalendar\",[ke]),be=A(ge,[]);Object.assign(Q,{IllegalMonthError:Z,IllegalWeekdayError:ee,day_name:oe,month_name:me,day_abbr:se,month_abbr:de,January:new i(1),February:new i(2),mdays:M(te),MONDAY:new i(ie),TUESDAY:new i(ce),WEDNESDAY:new i(fe),THURSDAY:new i(he),FRIDAY:new i(we),SATURDAY:new i(ye),SUNDAY:new i(ue),Calendar:_e,TextCalendar:ge,HTMLCalendar:ke,LocaleTextCalendar:pe,LocaleHTMLCalendar:$e,c:be,firstweekday:getA(be,\"getfirstweekday\"),monthcalendar:getA(be,\"monthdayscalendar\"),prweek:getA(be,\"prweek\"),week:getA(be,\"formatweek\"),weekheader:getA(be,\"formatweekheader\"),prmonth:getA(be,\"prmonth\"),month:getA(be,\"formatmonth\"),calendar:getA(be,\"formatyear\"),prcal:getA(be,\"pryear\")});const Me=new i(20),Te=R;function formatstring(e,t,n){t||(t=Me),n||(n=Te),n=mul(n,new h(\" \"));const r=[];for(const o of iterJs(e))r.push(pyCenter(o,t).toString());return new h(r.join(n.toString()))}const Ce=getA(V,\"toordinal\"),Oe=A(Ce,[new V(1970,1,1)]);return t(\"calendar\",Q,{isleap:{$meth:e=>s(isleap(e)),$flags:{NamedArgs:[\"year\"]},$doc:\"Return True for leap years, False for non-leap years\"},leapdays:{$meth(e,t){e=F(e)-1,t=F(t)-1;const n=Math.floor;return new i(n(t/4)-n(e/4)-(n(t/100)-n(e/100))+(n(t/400)-n(e/400)))},$flags:{MinArgs:2,MaxArgs:2}},weekday:{$meth:weekday,$flags:{NamedArgs:[\"year\",\"month\",\"day\"]},$doc:\"Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).\"},monthrange:{$meth:(e,t)=>new y(monthrange(e,t)),$flags:{NamedArgs:[\"year\",\"month\"]},$doc:\"Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for year, month.\"},setfirstweekday:{$meth(e){const t=F(e);if(!(ie<=t&&t<=ue))throw A(ee,[e]);be.fwd=e},$flags:{NamedArgs:[\"firstweekday\"]}},format:{$meth:function format(e,t,n){return p([formatstring(e,t,n)]),f},$flags:{NamedArgs:[\"cols\",\"colwidth\",\"spacing\"],Defaults:[Me,Te]}},formatstring:{$meth:formatstring,$flags:{NamedArgs:[\"cols\",\"colwidth\",\"spacing\"],Defaults:[Me,Te]}},timegm:{$meth(e){const[t,n,r,o,s,m]=e.valueOf(),d=A(V,[t,n,H]),l=A(Ce,[d]),i=add(sub(l,Oe),dec(r)),c=add(mul(i,U),o),f=add(mul(c,z),s);return add(mul(f,z),m)},$flags:{OneArg:!0}}}),Q}","src/lib/cellbotics/__init__.js":"\"use strict\";function promiseToPy(e){const n=new Sk.misceval.Suspension;let i,t;return n.resume=function(){if(t)throw t;return i},n.data={type:\"Sk.promise\",promise:e.then((function(e){return i=e,e}),(function(e){return t=e,e}))},n}function remapToPy(e){return e instanceof Promise&&(e=promiseToPy(e)),Sk.ffi.remapToPy(e)}function remapToJsFunc(e,...n){return function(...i){n&&Sk.builtin.pyCheckArgs(e.name,i,...n),i=i.slice(1);return remapToPy(e(...i.map((e=>Sk.ffi.remapToJs(e)))))}}var $builtinmodule=function(e){return remapToPy(Promise.all([runestoneComponents.runestone_import(\"ble\"),runestoneComponents.runestone_import(\"simple_sensor\")]).then((([e,n])=>{const i={__name__:new Sk.builtin.str(\"cellbotics\")},get_self=e=>e&&e.__js_class;i.JsProperty=Sk.misceval.buildClass(i,(function(e,n){n.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",e,2,2);const[n,i]=e;n.__js_property=Sk.ffi.remapToJs(i)})),n.__get__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__get__\",e,2,3);const[n,i,t]=e;return remapToPy(get_self(i)[n.__js_property])}))}),\"JsProperty\",[]);const prop_wrap=e=>Sk.misceval.callsim(i.JsProperty,new Sk.builtins.str(e)),t=e.cell_bot_ble_gui.cell_bot_ble;t&&(i.CellBot=Sk.misceval.buildClass(i,(function(e,n){n.__init__=new Sk.builtin.func((function(e){if(!t.paired())throw\"The CellBot is not paired. Click on the Pair button before running your program.\";return remapToPy(t.resetHardware().then((()=>{})))})),n.INPUT=new Sk.builtin.int_(t.INPUT),n.OUTPUT=new Sk.builtin.int_(t.OUTPUT);const wrap=(e,n)=>new Sk.builtin.func(remapToJsFunc(e,n,n));n.resetHardware=wrap(t.resetHardware,1),n.pinMode=wrap(t.pinMode,3),n.digitalWrite=wrap(t.digitalWrite,3),n.digitalRead=wrap(t.digitalRead,2),n.ledcSetup=wrap(t.ledcSetup,4),n.ledcAttachPin=wrap(t.ledcAttachPin,3),n.ledcDetachPin=wrap(t.ledcDetachPin,2),n.ledcWrite=wrap(t.ledcWrite,3)}),\"CellBot\",[]));const method_wrap=(e,n)=>new Sk.builtin.func(((...i)=>remapToJsFunc(get_self(i[0])[e],n,n)(...i)));i._Sensor=Sk.misceval.buildClass(i,(function(e,n){n.start=method_wrap(\"start\",1),n.stop=method_wrap(\"stop\",1)}),\"_Sensor\",[]),i._XYZSensor=Sk.misceval.buildClass(i,(function(e,n){n.x=prop_wrap(\"x\"),n.y=prop_wrap(\"y\"),n.z=prop_wrap(\"z\")}),\"_XYZSensor\",[i._Sensor]),i._OrientationSensor=Sk.misceval.buildClass(i,(function(e,n){n.quaternion=prop_wrap(\"quaternion\")}),\"_OrientationSensor\",[i._Sensor]);const sensor_factory=(e,n,t)=>i[e]=Sk.misceval.buildClass(i,(function(e,n){n.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",[e],1,1),e[0].__js_class=new t}))}),e,[n]);return i.AmbientLightSensor=Sk.misceval.buildClass(i,(function(e,i){i.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",[e],1,1),e[0].__js_class=new n.SimpleAmbientLightSensor})),i.illuminance=prop_wrap(\"illuminance\")}),\"AmbientLightSensor\",[i._Sensor]),i.GeolocationSensor=Sk.misceval.buildClass(i,(function(e,i){i.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",[e],1,1),e[0].__js_class=new n.SimpleGeolocationSensor})),i.latitude=prop_wrap(\"latitude\"),i.longitude=prop_wrap(\"longitude\"),i.altitude=prop_wrap(\"altitude\"),i.accuracy=prop_wrap(\"accuracy\"),i.altitudeAccuracy=prop_wrap(\"altitudeAccuracy\"),i.heading=prop_wrap(\"heading\"),i.speed=prop_wrap(\"speed\")}),\"GeolocationSensor\",[i._Sensor]),sensor_factory(\"Accelerometer\",i._XYZSensor,n.SimpleAccelerometer),sensor_factory(\"Gyroscope\",i._XYZSensor,n.SimpleGyroscope),sensor_factory(\"Magnetometer\",i._XYZSensor,n.SimpleMagnetometer),sensor_factory(\"LinearAccelerationSensor\",i._XYZSensor,n.SimpleLinearAccelerationSensor),sensor_factory(\"GravitySensor\",i._XYZSensor,n.SimpleGravitySensor),sensor_factory(\"AbsoluteOrientationSensor\",i._OrientationSensor,n.SimpleAbsoluteOrientationSensor),sensor_factory(\"RelativeOrientationSensor\",i._OrientationSensor,n.SimpleRelativeOrientationSensor),i})))};","src/lib/collections.js":"function $builtinmodule(t){const e={};return Sk.misceval.chain(Sk.importModule(\"keyword\",!1,!0),(t=>(e._iskeyword=t.$d.iskeyword,Sk.importModule(\"itertools\",!1,!0))),(t=>(e._chain=t.$d.chain,e._starmap=t.$d.starmap,e._repeat=t.$d.repeat,Sk.importModule(\"operator\",!1,!0))),(t=>{e._itemgetter=t.$d.itemgetter}),(()=>collections_mod(e)))}function collections_mod(t){function counterNumberSlot(e){return function(i){if(void 0!==i&&!(i instanceof t.Counter))return Sk.builtin.NotImplemented.NotImplemented$;const s=new t.Counter;return e.call(this,s,i),s}}function counterInplaceSlot(t,e){return function(i){if(!(i instanceof Sk.builtin.dict))throw new Sk.builtin.TypeError(\"Counter \"+t+\"= \"+Sk.abstr.typeName(i)+\" is not supported\");return e.call(this,i),this.keep$positive()}}t.__all__=new Sk.builtin.list([\"deque\",\"defaultdict\",\"namedtuple\",\"Counter\",\"OrderedDict\"].map((t=>new Sk.builtin.str(t)))),t.defaultdict=Sk.abstr.buildNativeClass(\"collections.defaultdict\",{constructor:function defaultdict(t,e){this.default_factory=t,Sk.builtin.dict.call(this,e)},base:Sk.builtin.dict,methods:{copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__missing__:{$meth(t){if(Sk.builtin.checkNone(this.default_factory))throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(t));{const e=Sk.misceval.callsimArray(this.default_factory,[]);return this.mp$ass_subscript(t,e),e}},$flags:{OneArg:!0}}},getsets:{default_factory:{$get(){return this.default_factory},$set(t){t=t||Sk.builtin.none.none$,this.default_factory=t}}},slots:{tp$doc:\"defaultdict(default_factory[, ...]) --\\x3e dict with default factory\\n\\nThe default factory is called without arguments to produce\\na new value when a key is not present, in __getitem__ only.\\nA defaultdict compares equal to a dict with the same items.\\nAll remaining arguments are treated the same as if they were\\npassed to the dict constructor, including keyword arguments.\\n\",tp$init(t,e){const i=t.shift();if(void 0===i)this.default_factory=Sk.builtin.none.none$;else{if(!Sk.builtin.checkCallable(i)&&!Sk.builtin.checkNone(i))throw new Sk.builtin.TypeError(\"first argument must be callable\");this.default_factory=i}return Sk.builtin.dict.prototype.tp$init.call(this,t,e)},$r(){const t=Sk.misceval.objectRepr(this.default_factory),e=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str(\"defaultdict(\"+t+\", \"+e+\")\")}},proto:{$copy(){const e=[];return Sk.misceval.iterFor(Sk.abstr.iter(this),(t=>{e.push(t),e.push(this.mp$subscript(t))})),new t.defaultdict(this.default_factory,e)}}}),t.Counter=Sk.abstr.buildNativeClass(\"Counter\",{constructor:function Counter(){this.$d=new Sk.builtin.dict,Sk.builtin.dict.apply(this)},base:Sk.builtin.dict,methods:{elements:{$flags:{NoArgs:!0},$meth(){const e=t._chain.tp$getattr(new Sk.builtin.str(\"from_iterable\")),i=t._starmap,s=t._repeat,n=Sk.misceval.callsimArray;return n(e,[n(i,[s,n(this.tp$getattr(this.str$items))])])}},most_common:{$flags:{NamedArgs:[\"n\"],Defaults:[Sk.builtin.none.none$]},$meth(t){const e=this.sq$length();t=Sk.builtin.checkNone(t)||(t=Sk.misceval.asIndexOrThrow(t))>e?e:t<0?0:t;const i=this.$items().sort(((t,e)=>Sk.misceval.richCompareBool(t[1],e[1],\"Lt\")?1:Sk.misceval.richCompareBool(t[1],e[1],\"Gt\")?-1:0));return new Sk.builtin.list(i.slice(0,t).map((t=>new Sk.builtin.tuple(t))))}},update:{$flags:{FastCall:!0},$meth(t,e){return Sk.abstr.checkArgsLen(\"update\",t,0,1),this.counter$update(t,e)}},subtract:{$flags:{FastCall:!0},$meth(t,e){Sk.abstr.checkArgsLen(\"subtract\",t,0,1);const i=t[0];if(void 0!==i)if(i instanceof Sk.builtin.dict)for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,i.mp$subscript(n),\"Sub\"))}else for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,this.$one,\"Sub\"))}e=e||[];for(let s=0;s<e.length;s+=2){const t=new Sk.builtin.str(e[s]),i=this.mp$subscript(t);this.mp$ass_subscript(t,Sk.abstr.numberBinOp(i,e[s+1],\"Sub\"))}return Sk.builtin.none.none$}},__missing__:{$meth(t){return this.$zero},$flags:{OneArg:!0}},copy:{$meth(){return Sk.misceval.callsimArray(t.Counter,[this])},$flags:{NoArgs:!0}}},getsets:{__dict__:Sk.generic.getSetDict},slots:{tp$doc:\"Dict subclass for counting hashable items.  Sometimes called a bag\\n    or multiset.  Elements are stored as dictionary keys and their counts\\n    are stored as dictionary values.\\n\\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\\n\\n    >>> c.most_common(3)                # three most common elements\\n    [('a', 5), ('b', 4), ('c', 3)]\\n    >>> sorted(c)                       # list all unique elements\\n    ['a', 'b', 'c', 'd', 'e']\\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\\n    'aaaaabbbbcccdde'\\n    >>> sum(c.values())                 # total of all counts\\n    15\\n\\n    >>> c['a']                          # count of letter 'a'\\n    5\\n    >>> for elem in 'shazam':           # update counts from an iterable\\n    ...     c[elem] += 1                # by adding 1 to each element's count\\n    >>> c['a']                          # now there are seven 'a'\\n    7\\n    >>> del c['b']                      # remove all 'b'\\n    >>> c['b']                          # now there are zero 'b'\\n    0\\n\\n    >>> d = Counter('simsalabim')       # make another counter\\n    >>> c.update(d)                     # add in the second counter\\n    >>> c['a']                          # now there are nine 'a'\\n    9\\n\\n    >>> c.clear()                       # empty the counter\\n    >>> c\\n    Counter()\\n\\n    Note:  If a count is set to zero or reduced to zero, it will remain\\n    in the counter until the entry is deleted or the counter is cleared:\\n\\n    >>> c = Counter('aaabbc')\\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\\n    [('a', 3), ('c', 1), ('b', 0)]\\n\\n\",tp$init(t,e){return Sk.abstr.checkArgsLen(this.tpjs_name,t,0,1),this.counter$update(t,e)},$r(){const t=this.size>0?Sk.builtin.dict.prototype.$r.call(this).v:\"\";return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+\")\")},tp$as_sequence_or_mapping:!0,mp$ass_subscript(t,e){return void 0===e?this.mp$lookup(t)&&Sk.builtin.dict.prototype.mp$ass_subscript.call(this,t,e):Sk.builtin.dict.prototype.mp$ass_subscript.call(this,t,e)},tp$as_number:!0,nb$positive:counterNumberSlot((function(t){this.$items().forEach((([e,i])=>{Sk.misceval.richCompareBool(i,this.$zero,\"Gt\")&&t.mp$ass_subscript(e,i)}))})),nb$negative:counterNumberSlot((function(t){this.$items().forEach((([e,i])=>{Sk.misceval.richCompareBool(i,this.$zero,\"Lt\")&&t.mp$ass_subscript(e,Sk.abstr.numberBinOp(this.$zero,i,\"Sub\"))}))})),nb$subtract:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=Sk.abstr.numberBinOp(s,e.mp$subscript(i),\"Sub\");Sk.misceval.richCompareBool(n,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,n)})),e.$items().forEach((([e,i])=>{void 0===this.mp$lookup(e)&&Sk.misceval.richCompareBool(i,this.$zero,\"Lt\")&&t.mp$ass_subscript(e,Sk.abstr.numberBinOp(this.$zero,i,\"Sub\"))}))})),nb$add:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=Sk.abstr.numberBinOp(s,e.mp$subscript(i),\"Add\");Sk.misceval.richCompareBool(n,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,n)})),e.$items().forEach((([e,i])=>{void 0===this.mp$lookup(e)&&Sk.misceval.richCompareBool(i,this.$zero,\"Gt\")&&t.mp$ass_subscript(e,i)}))})),nb$inplace_add:counterInplaceSlot(\"+\",(function(t){t.$items().forEach((([t,e])=>{const i=Sk.abstr.numberInplaceBinOp(this.mp$subscript(t),e,\"Add\");this.mp$ass_subscript(t,i)}))})),nb$inplace_subtract:counterInplaceSlot(\"-\",(function(t){t.$items().forEach((([t,e])=>{const i=Sk.abstr.numberInplaceBinOp(this.mp$subscript(t),e,\"Sub\");this.mp$ass_subscript(t,i)}))})),nb$or:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=e.mp$subscript(i),r=Sk.misceval.richCompareBool(s,n,\"Lt\")?n:s;Sk.misceval.richCompareBool(r,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,r)})),e.$items().forEach((([e,i])=>{void 0===this.mp$lookup(e)&&Sk.misceval.richCompareBool(i,this.$zero,\"Gt\")&&t.mp$ass_subscript(e,i)}))})),nb$and:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=e.mp$subscript(i),r=Sk.misceval.richCompareBool(s,n,\"Lt\")?s:n;Sk.misceval.richCompareBool(r,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,r)}))})),nb$inplace_and:counterInplaceSlot(\"&\",(function(t){this.$items().forEach((([e,i])=>{const s=t.mp$subscript(e);Sk.misceval.richCompareBool(s,i,\"Lt\")&&this.mp$ass_subscript(e,s)}))})),nb$inplace_or:counterInplaceSlot(\"|\",(function(t){t.$items().forEach((([t,e])=>{Sk.misceval.richCompareBool(e,this.mp$subscript(t),\"Gt\")&&this.mp$ass_subscript(t,e)}))})),nb$reflected_and:null,nb$reflected_or:null,nb$reflected_add:null,nb$reflected_subtract:null},proto:{keep$positive(){return this.$items().forEach((([t,e])=>{Sk.misceval.richCompareBool(e,this.$zero,\"LtE\")&&this.mp$ass_subscript(t)})),this},$zero:new Sk.builtin.int_(0),$one:new Sk.builtin.int_(1),str$items:new Sk.builtin.str(\"items\"),counter$update(t,e){const i=t[0];if(void 0!==i)if(Sk.builtin.checkMapping(i))if(this.sq$length())for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,i.mp$subscript(n),\"Add\"))}else this.update$common(t,void 0,\"update\");else for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,this.$one,\"Add\"))}if(e&&e.length)if(this.sq$length())for(let s=0;s<e.length;s+=2){const t=new Sk.builtin.str(e[s]),i=this.mp$subscript(t);this.mp$ass_subscript(t,Sk.abstr.numberBinOp(i,e[s+1],\"Add\"))}else this.update$common([],e,\"update\");return Sk.builtin.none.none$}},classmethods:{fromkeys:{$meth:function fromkeys(){throw new Sk.builtin.NotImplementedError(\"Counter.fromkeys() is undefined.  Use Counter(iterable) instead.\")},$flags:{MinArgs:1,MaxArgs:2}}}}),t.OrderedDict=Sk.abstr.buildNativeClass(\"collections.OrderedDict\",{constructor:function OrderedDict(){Sk.builtin.dict.call(this)},base:Sk.builtin.dict,slots:{tp$doc:\"Dictionary that remembers insertion order\",$r(){if(this.in$repr)return new Sk.builtin.str(\"...\");this.in$repr=!0;let t=this.$items().map((([t,e])=>`(${Sk.misceval.objectRepr(t)}, ${Sk.misceval.objectRepr(e)})`));return t=0===t.length?\"\":\"[\"+t.join(\", \")+\"]\",this.in$repr=!1,new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+\")\")},tp$richcompare(e,i){if(\"Eq\"!==i&&\"Ne\"!==i)return Sk.builtin.NotImplemented.NotImplemented$;if(!(e instanceof t.OrderedDict))return Sk.builtin.dict.prototype.tp$richcompare.call(this,e,i);const s=\"Eq\"==i,n=this.size;if(n!==e.size)return!s;const r=e.$items(),a=this.$items();for(let t=0;t<n;t++){const e=a[t],i=r[t],n=e[0],o=i[0];if(n!==o&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(n,o,\"Eq\")))return!s;const l=e[1],h=i[1];if(l!==h&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(l,h,\"Eq\")))return!s}return s}},methods:{popitem:{$flags:{NamedArgs:[\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(t){const e=this.get$size();if(0===e)throw new Sk.builtin.KeyError(\"dictionary is empty\");const[i,s]=this.$items()[Sk.misceval.isTrue(t)?e-1:0];return this.pop$item(i),new Sk.builtin.tuple([i,s])}},move_to_end:{$flags:{NamedArgs:[\"key\",\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(t,e){let i;for(let n in this.entries){const e=this.entries[n][0];if(e===t||Sk.misceval.richCompareBool(e,t,\"Eq\")){i=n;break}}if(void 0===i)throw new Sk.builtin.KeyError(t);const s=this.entries[i];return delete this.entries[i],Sk.misceval.isTrue(e)?this.entries[i]=s:this.entries={[i]:s,...this.entries},Sk.builtin.none.none$}}}}),t.deque=Sk.abstr.buildNativeClass(\"collections.deque\",{constructor:function deque(t,e,i,s,n){this.head=i||0,this.tail=s||0,this.mask=n||1,this.maxlen=e,this.v=t||new Array(2)},slots:{tp$doc:\"deque([iterable[, maxlen]]) --\\x3e deque object\\n\\nA list-like sequence optimized for data accesses near its endpoints.\",tp$hash:Sk.builtin.none.none$,tp$new:Sk.generic.new,tp$init(t,e){let[i,s]=Sk.abstr.copyKeywordsToNamedArgs(\"deque\",[\"iterable\",\"maxlen\"],t,e);if(void 0!==s&&!Sk.builtin.checkNone(s)){if(s=Sk.misceval.asIndexSized(s,Sk.builtin.OverflowError,\"an integer is required\"),s<0)throw new Sk.builtin.ValueError(\"maxlen must be non-negative\");this.maxlen=s}this.$clear(),void 0!==i&&this.$extend(i)},tp$getattr:Sk.generic.getAttr,tp$richcompare(e,i){if(this===e&&Sk.misceval.opAllowsEquality(i))return!0;if(!(e instanceof t.deque))return Sk.builtin.NotImplemented.NotImplemented$;const s=e,n=this.v;e=e.v;const r=this.tail-this.head&this.mask,a=s.tail-s.head&s.mask;let o,l=Math.max(r,a);if(r===a)for(l=0;l<r&&l<a&&(o=Sk.misceval.richCompareBool(n[this.head+l&this.mask],e[s.head+l&s.mask],\"Eq\"),o);++l);if(l>=r||l>=a)switch(i){case\"Lt\":return r<a;case\"LtE\":return r<=a;case\"Eq\":return r===a;case\"NotEq\":return r!==a;case\"Gt\":return r>a;case\"GtE\":return r>=a}return\"Eq\"!==i&&(\"NotEq\"===i||Sk.misceval.richCompareBool(n[this.head+l&this.mask],e[s.head+l&s.mask],i))},tp$iter(){return new e(this)},$r(){const t=[],e=this.tail-this.head&this.mask;if(this.$entered_repr)return new Sk.builtin.str(\"[...]\");this.$entered_repr=!0;for(let s=0;s<e;s++)t.push(Sk.misceval.objectRepr(this.v[this.head+s&this.mask]));const i=Sk.abstr.typeName(this);return void 0!==this.maxlen?new Sk.builtin.str(i+\"([\"+t.filter(Boolean).join(\", \")+\"], maxlen=\"+this.maxlen+\")\"):(this.$entered_repr=void 0,new Sk.builtin.str(i+\"([\"+t.filter(Boolean).join(\", \")+\"])\"))},tp$as_number:!0,nb$bool(){return 0!=(this.tail-this.head&this.mask)},tp$as_sequence_or_mapping:!0,sq$contains(t){for(let e=this.tp$iter(),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())if(Sk.misceval.richCompareBool(i,t,\"Eq\"))return!0;return!1},sq$concat(e){if(!(e instanceof t.deque))throw new Sk.builtin.TypeError(\"can only concatenate deque (not '\"+Sk.abstr.typeName(e)+\"') to deque\");const i=this.$copy();for(let t=e.tp$iter(),s=t.tp$iternext();void 0!==s;s=t.tp$iternext())i.$push(s);return i},sq$length(){return this.tail-this.head&this.mask},sq$repeat(t){t=Sk.misceval.asIndexOrThrow(t,\"can't multiply sequence by non-int of type '{tp$name}'\");const e=this.tail-this.head&this.mask,i=this.$copy();let s;t<=0&&i.$clear();for(let n=1;n<t;n++)for(let t=0;t<e;t++)s=this.head+t&this.mask,i.$push(this.v[s]);return i},mp$subscript(t){t=Sk.misceval.asIndexOrThrow(t);const e=this.tail-this.head&this.mask;if(t>=e||t<-e)throw new Sk.builtin.IndexError(\"deque index out of range\");const i=(t>=0?this.head:this.tail)+t&this.mask;return this.v[i]},mp$ass_subscript(t,e){t=Sk.misceval.asIndexOrThrow(t);const i=this.tail-this.head&this.mask;if(t>=i||t<-i)throw new Sk.builtin.IndexError(\"deque index out of range\");void 0===e?this.del$item(t):this.set$item(t,e)},nb$inplace_add(t){this.maxlen=void 0;for(let e=Sk.abstr.iter(t),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())this.$push(i);return this},nb$inplace_multiply(t){(t=Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError,\"can't multiply sequence by non-int of type '{tp$name}'\"))<=0&&this.$clear();const e=this.$copy(),i=this.tail-this.head&this.mask;for(let s=1;s<t;s++)for(let t=0;t<i;t++){const i=this.head+t&this.mask;e.$push(this.v[i])}return this.v=e.v,this.head=e.head,this.tail=e.tail,this.mask=e.mask,this}},methods:{append:{$meth(t){return this.$push(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the right side of the deque.\"},appendleft:{$meth(t){return this.$pushLeft(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the left side of the deque.\"},clear:{$meth(){return this.$clear(),Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove all elements from the deque.\"},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},count:{$meth(t){const e=this.tail-this.head&this.mask;let i=0;for(let s=0;s<e;s++)Sk.misceval.richCompareBool(this.v[this.head+s&this.mask],t,\"Eq\")&&i++;return new Sk.builtin.int_(i)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.count(value) -> integer -- return number of occurrences of value\"},extend:{$meth(t){return this.$extend(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the right side of the deque with elements from the iterable\"},extendleft:{$meth(t){for(let e=Sk.abstr.iter(t),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())this.$pushLeft(i);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the left side of the deque with elements from the iterable\"},index:{$meth(t,e,i){const s=this.$index(t,e,i);if(void 0!==s)return new Sk.builtin.int_(s);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(t)+\" is not in deque\")},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:\"D.index(value, [start, [stop]]) -> integer -- return first index of value.\\nRaises ValueError if the value is not present.\"},insert:{$meth(t,e){t=Sk.misceval.asIndexOrThrow(t,\"integer argument expected, got {tp$name}\");const i=this.tail-this.head&this.mask;if(void 0!==this.maxlen&&i>=this.maxlen)throw new Sk.builtin.IndexError(\"deque already at its maximum size\");t>i&&(t=i),t<=-i&&(t=0);const s=(t>=0?this.head:this.tail)+t&this.mask;let n=this.tail;for(this.tail=this.tail+1&this.mask;n!==s;){const t=n-1&this.mask;this.v[n]=this.v[t],n=t}return this.v[s]=e,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1),Sk.builtin.none.none$},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"D.insert(index, object) -- insert object before index\"},pop:{$meth(){return this.$pop()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the rightmost element.\"},popleft:{$meth(){return this.$popLeft()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the leftmost element.\"},remove:{$meth(t){const e=this.$index(t);if(void 0===e)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(t)+\" is not in deque\");let i=this.head+e&this.mask;for(;i!==this.tail;){const t=i+1&this.mask;this.v[i]=this.v[t],i=t}this.tail=this.tail-1&this.mask;var s=this.tail-this.head&this.mask;s<this.mask>>>1&&this.$resize(s,this.v.length>>>1)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.remove(value) -- remove first occurrence of value.\"},__reversed__:{$meth(){return new i(this)},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.__reversed__() -- return a reverse iterator over the deque\"},reverse:{$meth(){const t=this.head,e=this.tail,i=this.mask,s=this.tail-this.head&this.mask;for(let n=0;n<~~(s/2);n++){const s=e-n-1&i,r=t+n&i,a=this.v[s];this.v[s]=this.v[r],this.v[r]=a}return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.reverse() -- reverse *IN PLACE*\"},rotate:{$meth(t){t=void 0===t?1:Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError);const e=this.head,i=this.tail;if(0===t||e===i)return this;if(this.head=e-t&this.mask,this.tail=i-t&this.mask,t>0)for(let s=1;s<=t;s++){const t=e-s&this.mask,n=i-s&this.mask;this.v[t]=this.v[n],this.v[n]=void 0}else for(let s=0;s>t;s--){const t=i-s&this.mask,n=e-s&this.mask;this.v[t]=this.v[n],this.v[n]=void 0}return Sk.builtin.none.none$},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:\"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.\"}},classmethods:Sk.generic.classGetItem,getsets:{maxlen:{$get(){return void 0===this.maxlen?Sk.builtin.none.none$:new Sk.builtin.int_(this.maxlen)},$doc:\"maximum size of a deque or None if unbounded\"}},proto:{$clear(){this.head=0,this.tail=0,this.mask=1,this.v=new Array(2)},$copy(){return new t.deque(this.v.slice(0),this.maxlen,this.head,this.tail,this.mask)},$extend(t){for(let e=Sk.abstr.iter(t),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())this.$push(i)},set$item(t,e){const i=(t>=0?this.head:this.tail)+t&this.mask;this.v[i]=e},del$item(t){let e=(t>=0?this.head:this.tail)+t&this.mask;for(;e!==this.tail;){const t=e+1&this.mask;this.v[e]=this.v[t],e=t}const i=this.tail-this.head&this.mask;this.tail=this.tail-1&this.mask,i<this.mask>>>1&&this.$resize(i,this.v.length>>>1)},$push(t){this.v[this.tail]=t,this.tail=this.tail+1&this.mask,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);const e=this.tail-this.head&this.mask;return void 0!==this.maxlen&&e>this.maxlen&&this.$popLeft(),this},$pushLeft(t){this.head=this.head-1&this.mask,this.v[this.head]=t,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);const e=this.tail-this.head&this.mask;return void 0!==this.maxlen&&e>this.maxlen&&this.$pop(),this},$pop(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");this.tail=this.tail-1&this.mask;const t=this.v[this.tail];this.v[this.tail]=void 0;const e=this.tail-this.head&this.mask;return e<this.mask>>>1&&this.$resize(e,this.v.length>>>1),t},$popLeft(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");const t=this.v[this.head];this.v[this.head]=void 0,this.head=this.head+1&this.mask;const e=this.tail-this.head&this.mask;return e<this.mask>>>1&&this.$resize(e,this.v.length>>>1),t},$resize(t,e){const i=this.head,s=this.mask;if(this.head=0,this.tail=t,this.mask=e-1,0===i)return void(this.v.length=e);const n=new Array(e);for(let r=0;r<t;r++)n[r]=this.v[i+r&s];this.v=n},$index(t,e,i){const s=this.tail-this.head&this.mask;e=void 0===e?0:Sk.misceval.asIndexOrThrow(e),i=void 0===i?s:Sk.misceval.asIndexOrThrow(i);const n=this.head,r=this.mask,a=this.v;i=i>=0?i:i<-s?0:s+i;for(let o=e>=0?e:e<-s?0:s+e;o<i;o++)if(a[n+o&r]===t)return o},sk$asarray(){const t=[],e=this.tail-this.head&this.mask;for(let i=0;i<e;++i){const e=this.head+i&this.mask;t.push(this.v[e])}return t}}});const e=Sk.abstr.buildIteratorClass(\"_collections._deque_iterator\",{constructor:function _deque_iterator(t){this.$index=0,this.dq=t.v,this.$length=t.tail-t.head&t.mask,this.$head=t.head,this.$tail=t.tail,this.$mask=t.mask},iternext(){if(this.$index>=this.$length)return;const t=(this.$index>=0?this.$head:this.$tail)+this.$index&this.$mask;return this.$index++,this.dq[t]},methods:{__length_hint__:{$meth:function __length_hint__(){return new Sk.builtin.int_(this.$length-this.$index)},$flags:{NoArgs:!0}}}}),i=Sk.abstr.buildIteratorClass(\"_collections._deque_reverse_iterator\",{constructor:function _deque_reverse_iterator(t){this.$index=(t.tail-t.head&t.mask)-1,this.dq=t.v,this.$head=t.head,this.$mask=t.mask},iternext(){if(this.$index<0)return;const t=this.$head+this.$index&this.$mask;return this.$index--,this.dq[t]},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef}}),s=new RegExp(/^[0-9].*/),n=new RegExp(/^[0-9_].*/),r=new RegExp(/^\\w*$/),a=/,/g,o=/\\s+/;function namedtuple(e,i,l,h,c){if(e=e.tp$str(),Sk.misceval.isTrue(Sk.misceval.callsimArray(t._iskeyword,[e])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+Sk.misceval.objectRepr(e)+\"'\");const u=e.$jsstr();if(s.test(u)||!r.test(u)||!u)throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+u+\"'\");let m,d;if(Sk.builtin.checkString(i))m=i.$jsstr().replace(a,\" \").split(o),1==m.length&&\"\"===m[0]&&(m=[]),d=m.map((t=>new Sk.builtin.str(t)));else{m=[],d=[];for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())e=e.tp$str(),d.push(e),m.push(e.$jsstr())}let p=new Set;if(Sk.misceval.isTrue(l))for(let s=0;s<m.length;s++)(Sk.misceval.isTrue(Sk.misceval.callsimArray(t._iskeyword,[d[s]]))||n.test(m[s])||!r.test(m[s])||!m[s]||p.has(m[s]))&&(m[s]=\"_\"+s,d[s]=new Sk.builtin.str(\"_\"+s)),p.add(m[s]);else for(let s=0;s<m.length;s++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(t._iskeyword,[d[s]])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+m[s]+\"'\");if(n.test(m[s]))throw new Sk.builtin.ValueError(\"Field names cannot start with an underscore: '\"+m[s]+\"'\");if(!r.test(m[s])||!m[s])throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+m[s]+\"'\");if(p.has(m[s]))throw new Sk.builtin.ValueError(\"Encountered duplicate field name: '\"+m[s]+\"'\");p.add(m[s])}const $=new Sk.builtin.tuple(d),k=[];let b=[];if(!Sk.builtin.checkNone(h)){if(b=Sk.misceval.arrayFromIterable(h),b.length>m.length)throw new Sk.builtin.TypeError(\"Got more default values than field names\");for(let t=0,e=d.length-b.length;e<d.length;t++,e++)k.push(d[e]),k.push(b[t])}const f=new Sk.builtin.dict(k);function _make(t,e){return t.prototype.tp$new(Sk.misceval.arrayFromIterable(e))}function _asdict(t){const e=[];for(let i=0;i<t._fields.v.length;i++)e.push(t._fields.v[i]),e.push(t.v[i]);return new Sk.builtin.dict(e)}function _replace(t,e){const i=(t=new Sk.builtin.dict(t)).tp$getattr(new Sk.builtin.str(\"pop\")),s=Sk.abstr.gattr(e,new Sk.builtin.str(\"_make\")),n=Sk.misceval.callsimArray,r=n(s,[n(Sk.builtin.map_,[i,$,e])]);if(t.sq$length()){const e=t.sk$asarray();throw new Sk.builtin.ValueError(\"Got unexpectd field names: [\"+e.map((t=>\"'\"+t.$jsstr()+\"'\"))+\"]\")}return r}_make.co_varnames=[\"_cls\",\"iterable\"],_asdict.co_varnames=[\"self\"],_replace.co_kwargs=1,_replace.co_varnames=[\"_self\"];const S={};for(let s=0;s<m.length;s++)S[d[s].$mangled]=new Sk.builtin.property(new t._itemgetter([new Sk.builtin.int_(s)]),void 0,void 0,new Sk.builtin.str(\"Alias for field number \"+s));return Sk.abstr.buildNativeClass(u,{constructor:function NamedTuple(){},base:Sk.builtin.tuple,slots:{tp$doc:u+\"(\"+m.join(\", \")+\")\",tp$new(t,e){t=Sk.abstr.copyKeywordsToNamedArgs(\"__new__\",m,t,e,b);const i=new this.constructor;return Sk.builtin.tuple.call(i,t),i},$r(){const t=this.v.map(((t,e)=>m[e]+\"=\"+Sk.misceval.objectRepr(t)));return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t.join(\", \")+\")\")}},flags:{sk$klass:!0},proto:Object.assign({__module__:Sk.builtin.checkNone(c)?Sk.globals.__name__:c,__slots__:new Sk.builtin.tuple,_fields:$,_field_defaults:f,_make:new Sk.builtin.classmethod(new Sk.builtin.func(_make)),_asdict:new Sk.builtin.func(_asdict),_replace:new Sk.builtin.func(_replace)},S)})}return namedtuple.co_argcount=2,namedtuple.co_kwonlyargcount=3,namedtuple.$kwdefs=[Sk.builtin.bool.false$,Sk.builtin.none.none$,Sk.builtin.none.none$],namedtuple.co_varnames=[\"typename\",\"field_names\",\"rename\",\"defaults\",\"module\"],t.namedtuple=new Sk.builtin.func(namedtuple),t}","src/lib/datetime.js":"function $builtinmodule(){const{isTrue:t,richCompareBool:e,asIndexOrThrow:n,asIndexSized:i,objectRepr:s,opAllowsEquality:o,callsimArray:r,callsimOrSuspendArray:a}=Sk.misceval,{numberBinOp:$,typeName:c,buildNativeClass:h,checkArgsLen:m,objectHash:u,copyKeywordsToNamedArgs:l}=Sk.abstr,{int_:f,float_:d,str:w,bytes:_,tuple:p,bool:{true$:g},none:{none$:y},NotImplemented:{NotImplemented$:b},TypeError:z,ValueError:v,OverflowError:M,ZeroDivisionError:A,NotImplementedError:x,checkNumber:N,checkFloat:S,checkString:k,checkInt:O,asnum$:I,round:E,getattr:T}=Sk.builtin,{remapToPy:D,remapToJs:R}=Sk.ffi,intRound=t=>E(t).nb$int(),q=$,C=new w(\"auto\"),U=new w(\"utcoffset\"),Y=new w(\"tzname\"),j=new w(\"as_integer_ratio\"),F=new w(\"dst\"),H=new w(\"isoformat\"),J=new w(\"replace\"),B=new w(\"fromtimestamp\"),G=new w(\"fromordinal\"),L=new w(\"utcfromtimestamp\"),X=new w(\"strftime\"),P=new w(\"fromutc\"),W=new f(0),Z=new d(0),K=new f(7),V=new f(60),Q=new f(3600),tt=new f(1e3),et=new f(1e6),nt=new d(1e6),it=new f(86400),st=new d(86400);let ot=null;function pyDivMod(t,e){return q(t,e,\"DivMod\").v}function $divMod(t,e){if(\"number\"!=typeof t||\"number\"!=typeof e)return t=JSBI.BigInt(t),e=JSBI.BigInt(e),[JSBI.toNumber(JSBI.divide(t,e)),JSBI.toNumber(JSBI.remainder(t,e))];if(0===e)throw new A(\"integer division or modulo by zero\");return[Math.floor(t/e),t-Math.floor(t/e)*e]}function modf(t){const e=(t=I(t))<0?-1:1;return t=Math.abs(t),[new d(e*(t-Math.floor(t))),new d(e*Math.floor(t))]}function _d(t,e=\"0\",n=2){return t.toString().padStart(n,e)}const rt=/^[0-9]+$/;function _as_integer(t){if(!rt.test(t))throw new Error;return parseInt(t)}function _as_int_ratio(t){let e=r(t.tp$getattr(j));if(!(e instanceof p))throw new z(\"unexpected return type from as_integer_ratio(): expected tuple, got '\"+c(e)+\"'\");if(e=e.v,2!==e.length)throw new v(\"as_integer_ratio() must return a 2-tuple\");return e}return Sk.misceval.chain(Sk.importModule(\"time\",!1,!0),(a=>{const $=a.$d,E={__name__:new w(\"datetime\"),__all__:new Sk.builtin.list([\"date\",\"datetime\",\"time\",\"timedelta\",\"timezone\",\"tzinfo\",\"MINYEAR\",\"MAXYEAR\"].map((t=>new w(t))))};function _cmp(t,e){for(let n=0;n<t.length;n++)if(t[n]!==e[n])return t[n]>e[n]?1:-1;return 0}function _do_compare(t,e,n){const i=t.$cmp(e,n);switch(n){case\"Lt\":return i<0;case\"LtE\":return i<=0;case\"Eq\":return 0===i;case\"NotEq\":return 0!==i;case\"Gt\":return i>0;case\"GtE\":return i>=0}}const j=9999;E.MINYEAR=new f(1),E.MAXYEAR=new f(j);const rt=3652059,at=[-1,31,28,31,30,31,30,31,31,30,31,30,31],$t=[-1];let ct=0;function _is_leap(t){return t%4==0&&(t%100!=0||t%400==0)}function _days_before_year(t){const e=t-1;return 365*e+Math.floor(e/4)-Math.floor(e/100)+Math.floor(e/400)}function _days_before_month(t,e){return $t[e]+(e>2&&_is_leap(t))}function _ymd2ord(t,e,n){return _days_before_year(t)+_days_before_month(t,e)+n}at.slice(1).forEach((t=>{$t.push(ct),ct+=t}));const ht=_days_before_year(401),mt=_days_before_year(101),ut=_days_before_year(5);function _ord2ymd(t){if((t=n(t))>Number.MAX_SAFE_INTEGER)throw new M(\"Python int too large to convert to js number\");if(t<1)throw new v(\"ordinal must be >= 1\");let e,i,s,o;t-=1,[e,t]=$divMod(t,ht);let r=400*e+1;if([i,t]=$divMod(t,mt),[s,t]=$divMod(t,ut),[o,t]=$divMod(t,365),r+=100*i+4*s+o,4===o||4===i)return[r-1,12,31].map((t=>new f(t)));const a=3===o&&(24!==s||3===i);let $=t+50>>5,c=$t[$]+($>2&&a);return c>t&&($-=1,c-=at[$]+(2===$&&a)),[r,$,(t-=c)+1].map((t=>new f(t)))}const lt=[null,\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],ft=[null,\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"];function _build_struct_time(t,e,n,i,s,o,r){const a=(_ymd2ord(t,e,n)+6)%7,c=_days_before_month(t,e)+n;return $.struct_time.tp$call([new p([t,e,n,i,s,o,a,c,r].map((t=>new f(t))))])}const dt={hours:t=>_d(t),minutes:(t,e)=>_d(t)+\":\"+_d(e),seconds:(t,e,n)=>_d(t)+\":\"+_d(e)+\":\"+_d(n),milliseconds:(t,e,n,i)=>_d(t)+\":\"+_d(e)+\":\"+_d(n)+\".\"+_d(i,\"0\",3),microseconds:(t,e,n,i)=>_d(t)+\":\"+_d(e)+\":\"+_d(n)+\".\"+_d(i,\"0\",6)};function _format_time(t,e,n,i,s=\"auto\"){if(\"string\"!=typeof s&&!k(s))throw new z(\"must be str, not \"+c(s));\"auto\"===(s=s.toString())?s=i?\"microseconds\":\"seconds\":\"milliseconds\"===s&&(i=Math.floor(i/1e3));let o=dt[s];if(void 0===o)throw new v(\"Unknown timespec value\");return o(t,e,n,i)}function _format_offset(t){let e,n=\"\";if(t!==y){let i,s,o;return t.$days<0?(e=\"-\",t=new wt(-t.$days,-t.$secs,-t.$micro)):e=\"+\",[i,s]=pyDivMod(t,pt),[s,o]=pyDivMod(s,gt),n+=e+`${_d(i)}:${_d(s)}`,(o.$secs||o.$micro)&&(n+=\":\"+_d(o.$secs,\"0\",2),o.$micro&&(n+=\".\"+_d(o.$micro,\"0\",6))),n}}function _wrap_strftime(t,e,n){let i=null,s=null,o=null,a=[],c=0;const h=e.length;for(;c<h;){let n=e[c];if(c+=1,\"%\"===n)if(c<h)if(n=e[c],c+=1,\"f\"===n)null===i&&(i=_d(t.$micro||0,\"0\",6)),a.push(i);else if(\"z\"===n){if(null===s){s=\"\";const e=t.tp$getattr(U);if(void 0!==e){let t=r(e);if(t!==y){let e,n,i,o=\"+\";t.$days<0&&(t=new wt(-t.$days,-t.$secs,-t.$micro),o=\"-\"),[e,i]=pyDivMod(t,pt),[n,i]=pyDivMod(i,gt),e=e,n=n;const r=i.$secs,a=t.$micro;s=a?o+_d(e)+_d(n)+_d(r)+\".\"+_d(a,\"0\",6):r?o+_d(e)+_d(n)+_d(r):o+_d(e)+_d(n)}}}a.push(s)}else if(\"Z\"===n){if(null===o){o=\"\";const e=t.tp$getattr(Y);if(void 0!==e){let t=r(e);if(t!==y){const e=t.tp$getattr(J);if(o=r(e,[new w(\"%\"),new w(\"%%\")]),!k(o))throw new z(\"tzname.replace() did not return a string\")}}}a.push(o)}else a.push(\"%\",n);else a.push(\"%\");else a.push(n)}return a=a.join(\"\"),$.strftime.tp$call([new w(a),n])}function _parse_isoformat_date(t){const e=_as_integer(t.slice(0,4));if(\"-\"!==t[4])throw new v(\"Invalid date separator: \"+t[4]);const n=_as_integer(t.slice(5,7));if(\"-\"!==t[7])throw new v(\"Invalid date separator: \"+t[7]);return[e,n,_as_integer(t.slice(8,10))].map((t=>new f(t)))}function _parse_hh_mm_ss_ff(t){const e=t.length,n=[0,0,0,0];let i=0;for(let s=0;s<3;s++){if(e-i<2)throw new v(\"Incomplete time component\");n[s]=_as_integer(t.slice(i,i+2)),i+=2;const o=t.substr(i,1);if(!o||s>=2)break;if(\":\"!==o)throw new v(\"Invalid time separator: \"+o);i+=1}if(i<e){if(\".\"!==t[i])throw new v(\"Invalid microsecond component\");{i+=1;const s=e-i;if(3!==s&&6!==s)throw new v(\"Invalid microsecond component\");n[3]=_as_integer(t.slice(i)),3===s&&(n[3]*=1e3)}}return n}function _parse_isoformat_time(t){if(t.length<2)throw new v(\"Isoformat time too short\");const e=t.indexOf(\"-\")+1||t.indexOf(\"+\")+1;let n,i=_parse_hh_mm_ss_ff(e>0?t.slice(0,e-1):t),s=y;if(e>0){if(n=t.slice(e),![5,8,15].includes(n.length))throw new v(\"Malformed time zone string\");const i=_parse_hh_mm_ss_ff(n);if(i.every((t=>0===t)))s=St.prototype.utc;else{const n=\"-\"===t[e-1]?-1:1,o=new wt(0,n*(3600*i[0]+60*i[1]+i[2]),n*i[3]);s=new St(o)}}return i=i.map((t=>new f(t))),i.push(s),i}function _check_tzname(t){if(t!==y&&!k(t))throw new z(\"tzinfo.tzname() must return None or string, not '\"+c(t)+\"'\")}function _check_utc_offset(t,n){if(n!==y){if(!(n instanceof wt))throw new z(`tzinfo.${t}() must return None or timedelta, not '${c(n)}'`);if(!e(zt,n,\"Lt\")||!e(n,_t,\"Lt\"))throw new v(`${t}()=${n.toString()}, must be strictly between -timedelta(hours=24) and timedelta(hours=24)`)}}function _check_date_fields(t,e=null,i=null){if(null===e||null===i){throw new z(`function missing required argument '${null===i?\"day\":\"month\"}' (pos ${null===i?\"3\":\"2\"})`)}if(t=n(t),e=n(e),i=n(i),!(1<=t&&t<=j))throw new v(\"year must be in 1..9999\",new f(t));if(!(1<=e&&e<=12))throw new v(\"month must be in 1..12\",new f(e));const s=function _days_in_month(t,e){return 2===e&&_is_leap(t)?29:at[e]}(t,e);if(!(1<=i&&i<=s))throw new v(\"day must be in 1..\"+s,new f(i));return[t,e,i]}function _check_time_fields(t,e,i,s,o){if(t=n(t),e=n(e),i=n(i),s=n(s),o=n(o),!(0<=t&&t<=23))throw new v(\"hour must be in 0..23\",new f(t));if(!(0<=e&&e<=59))throw new v(\"minute must be in 0..59\",new f(e));if(!(0<=i&&i<=59))throw new v(\"second must be in 0..59\",new f(i));if(!(0<=s&&s<=999999))throw new v(\"microsecond must be in 0..999999\",new f(s));if(0!==o&&1!==o)throw new v(\"fold must be either 0 or 1\",new f(o));return[t,e,i,s,o]}function _check_tzinfo_arg(t){if(t!==y&&!(t instanceof Mt))throw new z(\"tzinfo argument must be None or of a tzinfo subclass\")}function _divide_and_round(t,e){let[n,i]=$divMod(t,e);return i*=2,((e>0?i>e:i<e)||i===e&&Math.abs(n)%2==1)&&(n+=1),n}const wt=E.timedelta=h(\"datetime.timedelta\",{constructor:function timedelta(t=0,e=0,n=0){let i,s;if([i,n]=$divMod(n,1e6),e+=i,[s,e]=$divMod(e,86400),t+=s,this.$days=t,this.$secs=e,this.$micro=n,this.$hashcode=-1,Math.abs(t)>999999999)throw new M(`days=${t}; must have magnitude <= 999999999`)},slots:{tp$new(t,e){let i,s,o,r,a,$,c,[h,m,u,d,w,_,p]=l(\"timedelta\",[\"days\",\"seconds\",\"microseconds\",\"milliseconds\",\"minutes\",\"hours\",\"weeks\"],t,e,new Array(7).fill(W));i=s=o=W,h=q(h,q(p,K,\"Mult\"),\"Add\"),m=q(m,q(q(w,V,\"Mult\"),q(_,Q,\"Mult\"),\"Add\"),\"Add\"),u=q(u,q(d,tt,\"Mult\"),\"Add\"),S(h)?([r,h]=modf(h),[a,$]=modf(q(r,st,\"Mult\")),s=new f($),i=new f(h)):(a=Z,i=h),S(m)?([c,m]=modf(m),m=new f(m),c=q(c,a,\"Add\")):c=a,[h,m]=pyDivMod(m,it),i=q(i,h,\"Add\"),s=q(s,new f(m),\"Add\");const g=q(c,nt,\"Mult\");if(S(u)?(u=intRound(q(u,g,\"Add\")),[m,u]=pyDivMod(u,et),[h,m]=pyDivMod(m,it),i=q(i,h,\"Add\"),s=q(s,m,\"Add\")):(u=new f(u),[m,u]=pyDivMod(u,et),[h,m]=pyDivMod(m,it),i=q(i,h,\"Add\"),s=q(s,m,\"Add\"),u=intRound(q(u,g,\"Add\"))),[m,o]=pyDivMod(u,et),s=q(s,m,\"Add\"),[h,s]=pyDivMod(s,it),i=q(i,h,\"Add\"),i=n(i),s=n(s),o=n(o),Math.abs(i)>999999999)throw new M(\"timedelta # of days is too large: \"+h.toString());if(this===wt.prototype)return new wt(i,s,o);{const t=new this.constructor;return wt.call(t,i,s,o),t}},$r(){const t=[];return this.$days&&t.push(`days=${this.$days}`),this.$secs&&t.push(`seconds=${this.$secs}`),this.$micro&&t.push(`microseconds=${this.$micro}`),t.length||t.push(\"0\"),new w(`${this.tp$name}(${t.join(\", \")})`)},tp$str(){const t=this.$secs%60;let e=Math.floor(this.$secs/60);const n=Math.floor(e/60);e%=60;let i=`${n}:${_d(e)}:${_d(t)}`;if(this.$days){i=`${this.$days} day${function plural(t){return 1!==Math.abs(t)?\"s\":\"\"}(this.$days)}, `+i}return this.$micro&&(i+=`.${_d(this.$micro,\"0\",6)}`),new w(i)},tp$as_number:!0,nb$add(t){return t instanceof wt?new wt(this.$days+t.$days,this.$secs+t.$secs,this.$micro+t.$micro):b},nb$subtract(t){return t instanceof wt?new wt(this.$days-t.$days,this.$secs-t.$secs,this.$micro-t.$micro):b},nb$positive(){return this},nb$negative(){return new wt(-this.$days,-this.$secs,-this.$micro)},nb$abs(){return this.$days<0?this.nb$negative():this},nb$multiply(t){if(O(t))return t=i(t,M),new wt(this.$days*t,this.$secs*t,this.$micro*t);if(S(t)){const e=this.$toMicrosecs();let[s,o]=_as_int_ratio(t);return s=i(s,M),o=n(o),new wt(0,0,_divide_and_round(e*s,o))}return b},nb$floor_divide(t){const e=this.$toMicrosecs();if(t instanceof wt){const n=t.$toMicrosecs();if(0===n)throw new A(\"integer division or modulo by zero\");return new f(Math.floor(e/n))}if(O(t)){if(0===(t=i(t,M)))throw new A(\"integer division or modulo by zero\");return new wt(0,0,Math.floor(e/t))}return b},nb$divide(t){const e=this.$toMicrosecs();if(t instanceof wt){if(0===t.$toMicrosecs())throw new A(\"integer division or modulo by zero\");return new d(e/t.$toMicrosecs())}if(O(t))return t=n(t),new wt(0,0,_divide_and_round(e,t));if(S(t)){let[s,o]=_as_int_ratio(t);return s=n(s),o=i(o,M),new wt(0,0,_divide_and_round(o*e,s))}return b},nb$remainder(t){if(!(t instanceof wt))return b;const e=this.$toMicrosecs(),n=t.$toMicrosecs();if(0===n)throw new A(\"integer division or modulo by zero\");const i=e-Math.floor(e/n)*n;return new wt(0,0,i)},nb$divmod(t){if(!(t instanceof wt))return b;const e=this.$toMicrosecs(),n=t.$toMicrosecs(),[i,s]=$divMod(e,n);return new p([new f(i),new wt(0,0,s)])},tp$richcompare(t,e){return t instanceof wt?_do_compare(this,t,e):b},tp$hash(){return-1===this.$hashcode&&(this.$hashcode=u(new p(this.$getState().map((t=>new f(t)))))),this.$hashcode},nb$bool(){return 0!==this.$days||0!==this.$secs||0!==this.$micro}},methods:{total_seconds:{$meth(){return new d(((86400*this.$days+this.$secs)*10**6+this.$micro)/10**6)},$flags:{NoArgs:!0},$doc:\"Total seconds in the duration.\"},__reduce__:{$meth(){return new p([this.ob$type,new p(this.$getState().map((t=>D(t))))])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},getsets:{days:{$get(){return new f(this.$days)},$doc:\"Number of days.\"},seconds:{$get(){return new f(this.$secs)},$doc:\"Number of seconds (>= 0 and less than 1 day).\"},microseconds:{$get(){return new f(this.$micro)},$doc:\"Number of microseconds (>= 0 and less than 1 second).\"}},proto:{$toMicrosecs(){return 1e6*(86400*this.$days+this.$secs)+this.$micro},$cmp(t){return _cmp(this.$getState(),t.$getState())},$getState(){return[this.$days,this.$secs,this.$micro]}}});wt.prototype.min=new wt(-999999999),wt.prototype.max=new wt(999999999,86399,999999),wt.prototype.resolution=new wt(0,0,1);const _t=new wt(1),pt=new wt(0,3600),gt=new wt(0,60),yt=new wt(0,1),bt=new wt(0),zt=new wt(-1),vt=E.date=h(\"datetime.date\",{constructor:function date(t,e,n){this.$year=t,this.$month=e,this.$day=n,this.$hashcode=-1},slots:{tp$new(t,e){let n,[i,s,o]=l(\"date\",[\"year\",\"month\",\"day\"],t,e,[null,null]);if(null===s&&i instanceof _&&4===(n=i.valueOf()).length&&1<=n[2]&&n[2]<=12){const t=new this.constructor;return t.$setState(n),t}if([i,s,o]=_check_date_fields(i,s,o),this===vt.prototype)return new vt(i,s,o);{const t=new this.constructor;return vt.call(t,i,s,o),t}},$r(){return new w(`${this.tp$name}(${this.$year}, ${this.$month}, ${this.$day})`)},tp$str(){return this.tp$getattr(H).tp$call([])},tp$richcompare(t,e){return t instanceof vt?_do_compare(this,t,e):b},tp$hash(){return-1===this.$hashcode&&(this.$hashcode=u(this.$getState())),this.$hashcode},tp$as_number:!0,nb$add(t){if(t instanceof wt){const e=this.$toOrdinal()+t.$days;if(0<e&&e<=rt)return this.ob$type.tp$getattr(G).tp$call([new f(e)]);throw new M(\"result out of range\")}return b},nb$subtract(t){if(t instanceof wt)return q(this,new wt(-t.$days),\"Add\");if(t instanceof vt){const e=this.$toOrdinal(),n=t.$toOrdinal();return new wt(e-n)}return b},nb$reflected_subtract:null},classmethods:{fromtimestamp:{$meth:function fromtimestamp(t){const[e,n,i]=$.localtime.tp$call([t]).v;return this.tp$call([e,n,i])},$flags:{OneArg:!0},$textsig:null,$doc:\"timestamp -> local date from a POSIX timestamp (like time.time()).\"},fromordinal:{$meth:function fromordinal(t){return this.tp$call(_ord2ymd(t))},$flags:{OneArg:!0},$textsig:null,$doc:\"int -> date corresponding to a proleptic Gregorian ordinal.\"},fromisocalendar:{$meth:function fromisocalendar(t,e,i){if(t=n(t),e=n(e),i=n(i),!(1<=t&&t<=j))throw new v(`Year is out of range: ${t}`);let s,o;if(!(0<e&&e<53)&&(s=!0,53===e&&(o=_ymd2ord(t,1,1)%7,(4===o||3===o&&_is_leap(t))&&(s=!1)),s))throw new v(`Invalid week: ${e}`);if(!(0<i&&i<8))throw new v(`Invalid weekday: ${i} (range is [1, 7])`);const r=7*(e-1)+(i-1),a=_isoweek1monday(t)+r;return this.tp$call(_ord2ymd(a))},$flags:{NamedArgs:[\"year\",\"week\",\"day\"]},$textsig:null,$doc:\"int -> date corresponding to a proleptic Gregorian ordinal.\"},fromisoformat:{$meth:function fromisoformat(t){if(!k(t))throw new z(\"fromisoformat: argument must be str\");t=t.toString();try{if(10!==t.length)throw new Error;return this.tp$call(_parse_isoformat_date(t))}catch(e){throw new v(\"Invalid isoformat string: '\"+t+\"'\")}},$flags:{OneArg:!0},$textsig:null,$doc:\"str -> Construct a date from the output of date.isoformat()\"},today:{$meth:function today(){const t=$.time.tp$call([]);return this.tp$getattr(B).tp$call([t])},$flags:{NoArgs:!0},$textsig:null,$doc:\"Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).\"}},methods:{ctime:{$meth:function ctime(){const t=this.$toOrdinal()%7||7,e=ft[t],n=lt[this.$month];return new w(`${e} ${n} ${_d(this.$day,\" \",2)} 00:00:00 ${_d(this.$year,\"0\",4)}`)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return ctime() style string.\"},strftime:{$meth:function strftime(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return _wrap_strftime(this,t=t.toString(),this.$timetuple())},$flags:{OneArg:!0},$textsig:null,$doc:\"format -> strftime() style string.\"},__format__:{$meth:function __format__(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return t!==w.$empty?this.tp$getattr(X).tp$call([t]):this.tp$str()},$flags:{OneArg:!0},$textsig:null,$doc:\"Formats self with strftime.\"},timetuple:{$meth:function timetuple(){return this.$timetuple()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time tuple, compatible with time.localtime().\"},isocalendar:{$meth:function isocalendar(){let t=this.$year,e=_isoweek1monday(t);const n=_ymd2ord(this.$year,this.$month,this.$day);let[i,s]=$divMod(n-e,7);return i<0?(t-=1,e=_isoweek1monday(t),[i,s]=$divMod(n-e,7)):i>=52&&n>=_isoweek1monday(t+1)&&(t+=1,i=0),new At(new f(t),new f(i+1),new f(s+1))},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a 3-tuple containing ISO year, week number, and weekday.\"},isoformat:{$meth:function isoformat(){return this.$isoformat()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return string in ISO 8601 format, YYYY-MM-DD.\"},isoweekday:{$meth:function isoweekday(){return new f(this.$toOrdinal()%7||7)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return the day of the week represented by the date.\\nMonday == 1 ... Sunday == 7\"},toordinal:{$meth:function toordinal(){return new f(this.$toOrdinal())},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.\"},weekday:{$meth:function weekday(){return new f((this.$toOrdinal()+6)%7)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return the day of the week represented by the date.\\nMonday == 0 ... Sunday == 6\"},replace:{$meth:function replace(t,e,n){return t===y&&(t=new f(this.$year)),e===y&&(e=new f(this.$month)),n===y&&(n=new f(this.$day)),this.ob$type.tp$call([t,e,n])},$flags:{NamedArgs:[\"year\",\"month\",\"day\"],Defaults:[y,y,y]},$textsig:null,$doc:\"Return date with new specified fields.\"},__reduce__:{$meth(){return new p([this.ob$type,new p([this.$getState()])])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},getsets:{year:{$get(){return new f(this.$year)},$doc:\"year (1-9999)\"},month:{$get(){return new f(this.$month)},$doc:\"month (1-12)\"},day:{$get(){return new f(this.$day)},$doc:\"day (1-31)\"}},proto:{$cmp(t){return _cmp([this.$year,this.$month,this.$day],[t.$year,t.$month,t.$day])},$getState(){const[t,e]=$divMod(this.$year,256);return new _([t,e,this.$month,this.$day])},$setState(t){const[e,n,i,s]=t,o=256*e+n;this.$year=o,this.$month=i,this.$day=s},$toOrdinal(){return _ymd2ord(this.$year,this.$month,this.$day)},$isoformat(){return new w(`${_d(this.$year,\"0\",4)}-${_d(this.$month,\"0\",2)}-${_d(this.$day,\"0\",2)}`)},$timetuple(){return _build_struct_time(this.$year,this.$month,this.$day,this.$hour||0,this.$min||0,this.$sec||0,-1)},$strftime(t=\"\"){return _wrap_strftime(this,t.toString(),this.$timetuple())}}});vt.prototype.min=new vt(1,1,1),vt.prototype.max=new vt(9999,12,31),vt.prototype.resolution=new wt(1);const Mt=E.tzinfo=h(\"datetime.tzinfo\",{constructor:function tzinfo(){},methods:{tzname:{$meth:function tzname(t){throw new x(\"tzinfo subclass must override tzname()\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime -> string name of time zone.\"},utcoffset:{$meth:function utcoffset(t){throw new x(\"tzinfo subclass must override utcoffset()\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime -> timedelta showing offset from UTC, negative values indicating West of UTC\"},dst:{$meth:function dst(t){throw new x(\"tzinfo subclass must override dst()\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime -> DST offset as timedelta positive east of UTC.\"},fromutc:{$meth:function fromutc(e){if(!(e instanceof Nt))throw new z(\"fromutc() requires a datetime argument\");if(e.$tzinfo!==this)throw new v(\"dt.tzinfo is not self\");const n=r(e.tp$getattr(U));if(n===y)throw new v(\"fromutc() requires a non-None utcoffset() result\");let i=r(e.tp$getattr(F));if(i===y)throw new v(\"fromutc() requires a non-None dst() result\");const s=q(n,i,\"Sub\");if(t(s)&&(e=q(e,s,\"Add\"),i=r(e.tp$getattr(F)),i===y))throw new v(\"fromutc(): dt.dst gave inconsistent results; cannot convert\");return q(e,i,\"Add\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime in UTC -> datetime in local time.\"},__reduce__:{$meth(){let e,n;const i=T(this,new w(\"__getinitargs__\"),y);e=i!==y?r(i,[]):new p;const s=T(this,new w(\"__getstate__\"),y);return s!==y?n=r(s,[]):(n=T(this,new w(\"__dict__\"),y),n=t(n)?n:y),new p(n===y?[this.ob$type,e]:[this.ob$type,e,n])},$flags:{NoArgs:!0},$textsig:null,$doc:\"-> (cls, state)\"}}}),At=h(\"datetime.IsoCalendarDate\",{base:p,constructor:function IsoCalendarDate(t,e,n){this.y=t,this.w=e,this.wd=n,p.call(this,[t,e,n])},slots:{tp$new(t,e){const[n,i,s]=l(\"IsoCalendarDate\",[\"year\",\"week\",\"weekday\"],t,e);return new this.constructor(n,i,s)},$r(){return new w(`${this.tp$name}(year=${this.y}, week=${this.w}, weekday=${this.wd})`)}},getsets:{year:{$get(){return this.y}},week:{$get(){return this.w}},weekday:{$get(){return this.wd}}}}),xt=E.time=h(\"datetime.time\",{constructor:function time(t=0,e=0,n=0,i=0,s=null,o=0){this.$hour=t,this.$min=e,this.$sec=n,this.$micro=i,this.$tzinfo=s||y,this.$fold=o,this.$hashcode=-1},slots:{tp$new(t,e){m(\"time\",t,0,5);let n,[i,s,o,r,a,$]=l(\"time\",[\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[W,W,W,W,y,W]);if(i instanceof _&&6===(n=i.valueOf()).length&&(127&n[0])<24){const t=new this.constructor;return t.$setState(n,s===W?y:s),t}if([i,s,o,r,$]=_check_time_fields(i,s,o,r,$),_check_tzinfo_arg(a),this===xt.prototype)return new xt(i,s,o,r,a,$);{const t=new this.constructor;return xt.call(t,i,s,o,r,a,$),t}},tp$richcompare(t,e){return t instanceof xt?_do_compare(this,t,e):b},tp$hash(){if(-1===this.$hashcode){const e=this.$fold?r(this.tp$getattr(J),[],[\"fold\",W]):this,n=r(e.tp$getattr(U));if(t(n)){let[t,e]=pyDivMod(new wt(0,3600*this.$hour+60*this.$min).nb$subtract(n),pt);e=e.nb$floor_divide(gt),0<=t&&t<=24?(t=I(t),e=I(e),this.$hashcode=u(new xt(t,e,this.$sec,this.$micro))):this.$hashcode=u(new p([t,e,new f(this.$sec),new f(this.$micro)]))}else this.$hashcode=u(e.$getState()[0])}return this.$hashcode},$r(){let t;return t=0!==this.$micro?`, ${this.$sec}, ${this.$micro}`:0!==this.$sec?`, ${this.$sec}`:\"\",t=`${this.tp$name}(${this.$hour}, ${this.$min}${t})`,this.$tzinfo!==y&&(t=t.slice(0,-1)+\", tzinfo=\"+s(this.$tzinfo)+\")\"),this.$fold&&(t=t.slice(0,-1)+\", fold=1)\"),new w(t)},tp$str(){return this.tp$getattr(H).tp$call([])}},methods:{isoformat:{$meth:function isoformat(t){let e=_format_time(this.$hour,this.$min,this.$sec,this.$micro,t);const n=this.$tzstr();return n&&(e+=n),new w(e)},$flags:{NamedArgs:[\"timespec\"],Defaults:[C]},$textsig:null,$doc:\"Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\\n\\ntimespec specifies what components of the time to include.\\n\"},strftime:{$meth:function strftime(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return _wrap_strftime(this,t=t.toString(),new p([1900,1,1,this.$hour,this.$min,this.$sec,0,1,-1].map((t=>new f(t)))))},$flags:{OneArg:!0},$textsig:null,$doc:\"format -> strftime() style string.\"},__format__:{$meth:function __format__(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return t!==w.$empty?this.tp$getattr(X).tp$call([t]):this.tp$str()},$flags:{OneArg:!0},$textsig:null,$doc:\"Formats self with strftime.\"},utcoffset:{$meth:function utcoffset(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(U),e=r(t,[y]);return _check_utc_offset(\"utcoffset\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.utcoffset(self).\"},tzname:{$meth:function tzname(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(Y),e=r(t,[y]);return _check_tzname(e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.tzname(self).\"},dst:{$meth:function dst(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(F),e=r(t,[y]);return _check_utc_offset(\"dst\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.dst(self).\"},replace:{$meth:function replace(t,e){m(\"replace\",t,0,5);let[n,i,s,o,r,a]=l(\"replace\",[\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[y,y,y,y,g,y]);return n===y&&(n=new f(this.$hour)),i===y&&(i=new f(this.$min)),s===y&&(s=new f(this.$sec)),o===y&&(o=new f(this.$micro)),r===g&&(r=this.$tzinfo),a===y&&(a=new f(this.$fold)),this.ob$type.tp$call([n,i,s,o,r],[\"fold\",a])},$flags:{FastCall:!0},$textsig:null,$doc:\"Return time with new specified fields.\"},__reduce_ex__:{$meth(t){return new p([this.ob$type,new p(this.$getState(R(t)))])},$flags:{OneArg:!0},$textsig:null,$doc:\"__reduce_ex__(proto) -> (cls, state)\"},__reduce__:{$meth(){return this.tp$getattr(new w(\"__reduce_ex__\")).tp$call([new f(2)])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},classmethods:{fromisoformat:{$meth:function fromisoformat(t){if(!k(t))throw new z(\"fromisoformat: argument must be str\");t=t.toString();try{return this.tp$call(_parse_isoformat_time(t))}catch{throw new v(\"Invalid isofrmat string: '\"+t+\"'\")}},$flags:{OneArg:!0},$textsig:null,$doc:\"string -> time from time.isoformat() output\"}},getsets:{hour:{$get(){return new f(this.$hour)}},minute:{$get(){return new f(this.$min)}},second:{$get(){return new f(this.$sec)}},microsecond:{$get(){return new f(this.$micro)}},tzinfo:{$get(){return this.$tzinfo}},fold:{$get(){return new f(this.$fold)}}},proto:{$cmp(t,n){const s=this.$tzinfo,o=t.$tzinfo;let a,$,c;if(a=$=y,s===o?c=!0:(a=r(this.tp$getattr(U)),$=r(t.tp$getattr(U)),c=e(a,$,\"Eq\")),c)return _cmp([this.$hour,this.$min,this.$sec,this.$micro],[t.$hour,t.$min,t.$sec,t.$micro]);if(a===y||$===y){if(\"Eq\"===n||\"NotEq\"===n)return 2;throw new z(\"cannot compare naive and aware times\")}const h=60*this.$hour+this.$min-i(a.nb$floor_divide(gt)),m=60*t.$hour+t.$min-i($.nb$floor_divide(gt));return _cmp([h,this.$sec,this.$micro],[m,t.$sec,t.$micro])},$tzstr(){return _format_offset(r(this.tp$getattr(U)))},$getState(t=3){let[e,n]=$divMod(this.$micro,256),[i,s]=$divMod(e,256),o=this.$hour;this.$fold&&t>3&&(o+=128);const r=new _([o,this.$min,this.$sec,i,s,n]);return this.$tzinfo===y?[r]:[r,this.$tzinfo]},$setState(t,e){const[n,i,s,o,r,a]=t;n>127?(this.$fold=1,this.$hour=n-128):(this.$fold=0,this.$hour=n),this.$min=i,this.$sec=s,this.$micro=(o<<8|r)<<8|a,this.$tzinfo=e}}});xt.prototype.min=new xt(0,0,0),xt.prototype.max=new xt(23,59,59,999999),xt.prototype.resolution=new wt;const Nt=E.datetime=h(\"datetime.datetime\",{base:vt,constructor:function datetime(t,e,n,i=0,s=0,o=0,r=0,a=null,$=0){this.$year=t,this.$month=e,this.$day=n,this.$hour=i,this.$min=s,this.$sec=o,this.$micro=r,this.$tzinfo=a||y,this.$fold=$,this.$hashcode=-1},slots:{tp$new(t,e){m(\"datetime\",t,0,9);let n,[i,s,o,r,a,$,c,h,u]=l(\"time\",[\"year\",\"month\",\"day\",\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[null,null,W,W,W,W,y,W]);if(i instanceof _&&10===(n=i.valueOf()).length&&(127&n[2])<=12){const t=new this.constructor;return t.$setState(n,null===s?y:s),t}if([i,s,o]=_check_date_fields(i,s,o),[r,a,$,c,u]=_check_time_fields(r,a,$,c,u),_check_tzinfo_arg(h),this===Nt.prototype)return new Nt(i,s,o,r,a,$,c,h,u);{const t=new this.constructor;return Nt.call(t,i,s,o,r,a,$,c,h,u),t}},$r(){const t=[this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,this.$micro];0===t[t.length-1]&&t.pop(),0===t[t.length-1]&&t.pop();let e=`${this.tp$name}(${t.join(\", \")})`;return this.$tzinfo!==y&&(e=e.slice(0,-1)+\", tzinfo=\"+s(this.$tzinfo)+\")\"),this.$fold&&(e=e.slice(0,-1)+\", fold=1)\"),new w(e)},tp$str(){return this.tp$getattr(H).tp$call([],[\"sep\",new w(\" \")])},tp$richcompare(t,e){if(t instanceof Nt)return _do_compare(this,t,e);if(!(t instanceof vt))return b;if(\"Eq\"===e||\"NotEq\"===e)return\"NotEq\"===e;throw new z(`can't compare '${c(this)}' to '${c(t)}'`)},tp$as_number:!0,nb$add(t){if(!(t instanceof wt))return b;let e=new wt(this.$toOrdinal(),3600*this.$hour+60*this.$min+this.$sec,this.$micro);e=q(e,t,\"Add\");let[n,i]=$divMod(e.$secs,3600),[s,o]=$divMod(i,60);if(0<e.$days&&e.$days<=rt)return this.ob$type.tp$getattr(new w(\"combine\")).tp$call([vt.tp$call(_ord2ymd(e.$days)),new xt(n,s,o,e.$micro,this.$tzinfo)]);throw new M(\"result out of range\")},nb$subtract(t){if(!(t instanceof Nt))return t instanceof wt?this.nb$add(t.nb$negative()):b;const n=this.$toOrdinal(),i=t.$toOrdinal(),s=this.$sec+60*this.$min+3600*this.$hour,o=t.$sec+60*t.$min+3600*t.$hour,a=new wt(n-i,s-o,this.$micro-t.$micro);if(this.$tzinfo===t.$tzinfo)return a;const $=r(this.tp$getattr(U)),c=r(t.tp$getattr(U));if(e($,c,\"Eq\"))return a;if($===y||c===y)throw new z(\"cannot mix naive and timezone-aware time\");return a.nb$add(c).nb$subtract($)},nb$reflected_subtract:null,tp$hash(){if(-1===this.$hashcode){const t=this.$fold?r(this.tp$getattr(J),[],[\"fold\",W]):this,e=r(t.tp$getattr(U));if(e===y)this.$hashcode=u(t.$getState()[0]);else{const t=_ymd2ord(this.$year,this.$month,this.$day),n=3600*this.$hour+60*this.$min+this.$sec;this.$hashcode=u(new wt(t,n,this.$micro).nb$subtract(e))}}return this.$hashcode}},methods:{date:{$meth:function _date(){return new vt(this.$year,this.$month,this.$day)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return date object with same year, month and day.\"},time:{$meth:function _time(){return new xt(this.$hour,this.$min,this.$sec,this.$micro,y,this.$fold)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time object with same time but with tzinfo=None.\"},timetz:{$meth:function timetz(){return new xt(this.$hour,this.$min,this.$sec,this.$micro,this.$tzinfo,this.$fold)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time object with same time and tzinfo.\"},ctime:{$meth:function ctime(){const t=this.$toOrdinal()%7||7,e=ft[t],n=lt[this.$month];return new w(`${e} ${n} ${_d(this.$day,\" \",2)} ${_d(this.$hour,\"0\",2)}:${_d(this.$min,\"0\",2)}:${_d(this.$sec,\"0\",2)} ${_d(this.$year,\"0\",4)}`)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return ctime() style string.\"},timetuple:{$meth:function timetuple(){let e=r(this.tp$getattr(F));return e=e===y?-1:t(e)?1:0,_build_struct_time(this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,e)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time tuple, compatible with time.localtime().\"},timestamp:{$meth:function timestamp(){if(this.$tzinfo===y){let t=this.$mkTime();return t=I(t),new d(t+this.$micro/1e6)}{const t=q(this,kt,\"Sub\");return new d(((86400*t.$days+t.$secs)*10**6+t.$micro)/10**6)}},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return POSIX timestamp as float.\"},utctimetuple:{$meth:function utctimetuple(){const e=r(this.tp$getattr(U));let n=this;return t(e)&&(n=q(n,e,\"Sub\")),_build_struct_time(n.$year,n.$month,n.$day,n.$hour,n.$min,n.$sec,0)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return UTC time tuple, compatible with time.localtime().\"},isoformat:{$meth:function isoformat(t,e){if(!k(t))throw new z(\"sep must be str, not \"+c(t));let n=`${_d(this.$year,\"0\",4)}-${_d(this.$month,\"0\",2)}-${_d(this.$day,\"0\",2)}`+t.toString();n+=_format_time(this.$hour,this.$min,this.$sec,this.$micro,e);const i=_format_offset(r(this.tp$getattr(U)));return i&&(n+=i),new w(n)},$flags:{NamedArgs:[\"sep\",\"timespec\"],Defaults:[new w(\"T\"),C]},$textsig:null,$doc:\"[sep] -> string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\\nsep is used to separate the year from the time, and defaults to 'T'.\\ntimespec specifies what components of the time to include (allowed values are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds', and 'microseconds').\\n\"},utcoffset:{$meth:function utcoffset(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(U),e=r(t,[this]);return _check_utc_offset(\"utcoffset\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.utcoffset(self).\"},tzname:{$meth:function tzname(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(Y),e=r(t,[this]);return _check_tzname(e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.tzname(self).\"},dst:{$meth:function dst(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(F),e=r(t,[this]);return _check_utc_offset(\"dst\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.dst(self).\"},replace:{$meth:function replace(t,e){m(\"replace\",t,0,8);let[n,i,s,o,r,a,$,c,h]=l(\"replace\",[\"year\",\"month\",\"day\",\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[y,y,y,y,y,y,y,g,y]);return n===y&&(n=new f(this.$year)),i===y&&(i=new f(this.$month)),s===y&&(s=new f(this.$day)),o===y&&(o=new f(this.$hour)),r===y&&(r=new f(this.$min)),a===y&&(a=new f(this.$sec)),$===y&&($=new f(this.$micro)),c===g&&(c=this.$tzinfo),h===y&&(h=new f(this.$fold)),this.ob$type.tp$call([n,i,s,o,r,a,$,c],[\"fold\",h])},$flags:{FastCall:!0},$textsig:null,$doc:\"Return datetime with new specified fields.\"},astimezone:{$meth:function astimezone(t){if(t===y)t=this.$localTimezone();else if(!(t instanceof Mt))throw new z(\"tz argument must be an instance of tzinfo\");let e,n=this.$tzinfo;if(n===y?(n=this.$localTimezone(),e=r(n.tp$getattr(U),[this])):(e=r(n.tp$getattr(U),[this]),e===y&&(n=r(this.tp$getattr(J),[],[\"tzinfo\",y]).$localTimezone(),e=r(n.tp$getattr(U),[this]))),t===n)return this;const i=r(this.nb$subtract(e).tp$getattr(J),[],[\"tzinfo\",t]);return t.tp$getattr(P).tp$call([i])},$flags:{NamedArgs:[\"tz\"],Defaults:[y]},$textsig:null,$doc:\"tz -> convert to local time in new timezone tz\\n\"},__reduce_ex__:{$meth(t){return new p([this.ob$type,new p(this.$getState(R(t)))])},$flags:{OneArg:!0},$textsig:null,$doc:\"__reduce_ex__(proto) -> (cls, state)\"},__reduce__:{$meth(){return this.tp$getattr(new w(\"__reduce_ex__\")).tp$call([new f(2)])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},classmethods:{now:{$meth:function now(t){const e=$.time.tp$call([]);return this.tp$getattr(B).tp$call([e,t])},$flags:{NamedArgs:[\"tz\"],Defaults:[y]},$textsig:\"($type, /, tz=None)\",$doc:\"Returns new datetime object representing current time local to tz.\\n\\n  tz\\n    Timezone object.\\n\\nIf no tz is specified, uses local timezone.\"},utcnow:{$meth:function utcnow(){const t=$.time.tp$call([]);return this.tp$getattr(L).tp$call([t])},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a new datetime representing UTC day and time.\"},fromtimestamp:{$meth:function fromtimestamp(t,e){return _check_tzinfo_arg(e),this.prototype.$fromtimestamp.call(this,t,e!==y,e)},$flags:{NamedArgs:[\"timestamp\",\"tz\"],Defaults:[y]},$textsig:null,$doc:\"timestamp[, tz] -> tz's local time from POSIX timestamp.\"},utcfromtimestamp:{$meth:function utcfromtimestamp(t){return this.prototype.$fromtimestamp.call(this,t,!0,y)},$flags:{OneArg:!0},$textsig:null,$doc:\"Construct a naive UTC datetime from a POSIX timestamp.\"},strptime:{$meth:function strptime(t,e){return null===ot?Sk.misceval.chain(Sk.importModule(\"_strptime\",!1,!0),(n=>(ot=n.tp$getattr(new w(\"_strptime_datetime\")),ot.tp$call([this,t,e])))):ot.tp$call([this,t,e])},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"string, format -> new datetime parsed from a string (like time.strptime()).\"},combine:{$meth:function combine(t,e,n){if(!(t instanceof vt))throw new z(\"date argument must be a date instance\");if(!(e instanceof xt))throw new z(\"time argument must be a time instance\");n===g&&(n=e.$tzinfo);const i=[t.$year,t.$month,t.$day,e.$hour,e.$min,e.$sec,e.$micro].map((t=>new f(t)));return i.push(n),this.tp$call(i,[\"fold\",new f(e.$fold)])},$flags:{NamedArgs:[\"date\",\"time\",\"tzinfo\"],Defaults:[g]},$textsig:null,$doc:\"date, time -> datetime with same date and time fields\"},fromisoformat:{$meth:function fromisoformat(t){if(!k(t))throw new z(\"fromisoformat: argument must be str\");const e=(t=t.toString()).slice(0,10),n=t.slice(11);let i,s;try{i=_parse_isoformat_date(e)}catch(o){throw new v(\"Invalid isoformat string: '\"+t+\"'\")}if(n)try{s=_parse_isoformat_time(n)}catch(o){throw new v(\"Invalid isoformat string: '\"+t+\"'\")}else s=[W,W,W,W,y];return this.tp$call(i.concat(s))},$flags:{OneArg:!0},$textsig:null,$doc:\"string -> datetime from datetime.isoformat() output\"}},getsets:{hour:{$get(){return new f(this.$hour)}},minute:{$get(){return new f(this.$min)}},second:{$get(){return new f(this.$sec)}},microsecond:{$get(){return new f(this.$micro)}},tzinfo:{$get(){return this.$tzinfo}},fold:{$get(){return new f(this.$fold)}}},proto:{$cmp(n,i){const s=this.$tzinfo,o=n.$tzinfo;let a,$,c;if(a=$=y,s===o)c=!0;else{if(a=r(this.tp$getattr(U)),$=r(n.tp$getattr(U)),\"Eq\"===i||\"NotEq\"===i){const t=r(this.tp$getattr(J),[],[\"fold\",new f(Number(!this.$fold))]);if(e(a,r(t.tp$getattr(U)),\"NotEq\"))return 2;const i=r(n.tp$getattr(J),[],[\"fold\",new f(Number(!n.$fold))]);if(e($,r(i.tp$getattr(U)),\"NotEq\"))return 2}c=e(a,$,\"Eq\")}if(c)return _cmp([this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,this.$micro],[n.$year,n.$month,n.$day,n.$hour,n.$min,n.$sec,n.$micro]);if(a===y||$===y){if(\"Eq\"===i||\"NotEq\"===i)return 2;throw new z(\"cannot compare naive and aware datetimes\")}const h=this.nb$subtract(n);return h.$days<0?-1:t(h)?1:0},$mkTime(){const t=new Nt(1970,1,1),e=this.nb$subtract(t).nb$floor_divide(yt);function local(e){const[n,i,s,o,r,a]=$.localtime.tp$call([e]).v;return Nt.tp$call([n,i,s,o,r,a]).nb$subtract(t).nb$floor_divide(yt)}let n,i,s=local(e).nb$subtract(e),o=e.nb$subtract(s),r=local(o);if(r.ob$eq(e)){if(n=o.nb$add([new f(-86400),new f(86400)][this.$fold]),i=local(n).nb$subtract(n),s.ob$eq(i))return o}else i=r.nb$subtract(o);n=e.nb$subtract(i);if(local(n).ob$eq(e))return n;if(r.ob$eq(e))return o;const a=o.ob$ge(n)?o:n;return[a,o===a?n:o][this.$fold]},$fromtimestamp(t,n,s){let o;if(!N(t))throw new z(\"a number is required, (got '\"+c(t)+\"'\");[o,t]=modf(t);let a=intRound(q(o,nt,\"Mult\"));a=a.v,t=t.v,a>=1e6?(t+=1,a-=1e6):a<0&&(t-=1,a+=1e6),t=new f(t),Number.isInteger(a)||(a=Math.trunc(a)),a=new f(a);const h=n?$.gmtime:$.localtime;function converter(t){return h.tp$call([t]).v}let[m,u,l,d,_,p]=converter(t);p=new f(Math.min(i(p),59));let g=r(this,[m,u,l,d,_,p,a,s]);if(s===y){const n=86400;[m,u,l,d,_,p]=converter(q(t,new f(n),\"Sub\"));const i=r(this,[m,u,l,d,_,p,a,s]),o=q(q(g,i,\"Sub\"),new wt(0,n),\"Sub\");if(o.$days<0){[m,u,l,d,_,p]=converter(q(t,q(o,yt,\"FloorDiv\"),\"Add\"));const n=r(this,[m,u,l,d,_,p,a,s]);e(n,g,\"Eq\")&&(g.$fold=1)}}else g=r(s.tp$getattr(new w(\"fromutc\")),[g]);return g},$localTimezone(){let t;t=this.$tzinfo===y?this.$mkTime():this.nb$subtract(kt).nb$floor_divide(yt);const e=$.localtime.tp$call([t]),n=(Nt.tp$call(e.v.slice(0,6)),e.tp$getattr(new w(\"tm_gmtoff\"))),i=e.tp$getattr(new w(\"tm_zone\"));return new St(wt.tp$call([W,n]),i)},$getState(t=3){let[e,n]=$divMod(this.$year,256),[i,s]=$divMod(this.$micro,256),[o,r]=$divMod(i,256),a=this.$month;this.$fold&&t>3&&(a+=128);const $=new _([e,n,a,this.$day,this.$hour,this.$min,this.$sec,o,r,s]);return this.$tzinfo===y?[$]:[$,this.$tzinfo]},$setState(t,e){const[n,i,s,o,r,a,$,c,h,m]=t;s>127?(this.$fold=1,this.$month=s-128):(this.$fold=0,this.$month=s),this.$year=256*n+i,this.$day=o,this.$hour=r,this.$min=a,this.$sec=$,this.$micro=(c<<8|h)<<8|m,this.$tzinfo=e}}});function _isoweek1monday(t){const e=_ymd2ord(t,1,1),n=(e+6)%7;let i=e-n;return n>3&&(i+=7),i}Nt.prototype.min=new Nt(1,1,1),Nt.prototype.max=new Nt(9999,12,31,23,59,59,999999),Nt.prototype.resolution=new wt(0,0,1);const St=E.timezone=h(\"datetime.timezone\",{base:Mt,constructor:function timezone(t,n){if(this.$offset=t,this.$name=n||y,!e(this.$minoffset,t,\"LtE\")||!e(this.$maxoffset,t,\"GtE\"))throw new v(\"offset must be a timedelta strictly between -timedelta(hours=24) and timedelta(hours=24).\")},slots:{tp$new(e,n){let[i,s]=l(\"timezone\",[\"offset\",\"name\"],e,n,[null]);if(!(i instanceof wt))throw new z(\"offset must be a timedelta\");if(null===s){if(!t(i))return this.utc;s=y}else if(!k(s))throw new z(\"name must be a string\");if(this===St.prototype)return new St(i,s);{const t=new this.constructor;return St.call(t,i,s),t}},tp$richcompare(t,n){if(!(t instanceof St))return b;const i=e(this.$offset,t.$offset,\"Eq\");return\"NotEq\"===n?!i:\"Eq\"===n||i&&o(n)?i:b},$r(){return this===this.utc?new w(\"datetime.timezone.utc\"):this.$name===y?new w(`${this.tp$name}(${s(this.$offset)})`):new w(`${this.tp$name}(${s(this.$offset)}, ${s(this.$name)})`)},tp$str(){return this.tp$getattr(Y).tp$call([y])},tp$hash(){return u(this.$offset)}},methods:{tzname:{$meth:function tzname(t){if(t instanceof Nt||t===y)return this.$name===y?this.$nameFromOff(this.$offset):this.$name;throw new z(\"tzname() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"If name is specified when timezone is created, returns the name.  Otherwise returns offset as 'UTC(+|-)HH:MM'.\"},utcoffset:{$meth:function utcoffset(t){if(t instanceof Nt||t===y)return this.$offset;throw new z(\"utcoffset() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"Return fixed offset.\"},dst:{$meth:function dst(t){if(t instanceof Nt||t===y)return y;throw new z(\"dst() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"Return None.\"},fromutc:{$meth:function fromutc(t){if(t instanceof Nt){if(t.$tzinfo!==this)throw new v(\"fromutc: dt.tzinfo is not self\");return q(t,this.$offset,\"Add\")}throw new z(\"fromutc() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime in UTC -> datetime in local time.\"},__getinitargs__:{$meth(){return this.$name===y?new p([this.$offset]):new p([this.$offset,this.$name])},$flags:{NoArgs:!0}}},proto:{$maxoffset:new wt(0,86399,999999),$minoffset:new wt(-1,0,1),$nameFromOff(n){if(!t(n))return new w(\"UTC\");let i,s,o,r,a,$;return e(n,bt,\"Lt\")?(i=\"-\",n=n.nb$negative()):i=\"+\",[s,o]=pyDivMod(n,pt),[r,o]=pyDivMod(o,gt),a=o.$secs,$=o.$micro,new w($?`UTC${i}${_d(s)}:${_d(r)}:${_d(a)}.${_d($,\"0\",6)}`:a?`UTC${i}${_d(s)}:${_d(r)}:${_d(a)}`:`UTC${i}${_d(s)}:${_d(r)}`)}}});St.prototype.utc=new St(new wt(0)),St.prototype.min=new St(new wt(0,-86340,0)),St.prototype.max=new St(new wt(0,86340,0));const kt=new Nt(1970,1,1,0,0,0,0,St.prototype.utc);return E}))}","src/lib/document.js":"var $builtinmodule=function(n){var e,t={__name__:new Sk.builtin.str(\"document\")};return t.getElementById=new Sk.builtin.func((function(n){var e=document.getElementById(n.v);return e?Sk.misceval.callsimArray(t.Element,[e]):Sk.builtin.none.none$})),t.createElement=new Sk.builtin.func((function(n){var e=document.createElement(n.v);if(e)return Sk.misceval.callsimArray(t.Element,[e])})),t.getElementsByTagName=new Sk.builtin.func((function(n){for(var e=document.getElementsByTagName(n.v),i=[],r=e.length-1;r>=0;r--)i.push(Sk.misceval.callsimArray(t.Element,[e[r]]));return new Sk.builtin.list(i)})),t.getElementsByClassName=new Sk.builtin.func((function(n){for(var e=document.getElementsByClassName(n.v),i=[],r=0;r<e.length;r++)i.push(Sk.misceval.callsimArray(t.Element,[e[r]]));return new Sk.builtin.list(i)})),t.getElementsByName=new Sk.builtin.func((function(n){for(var e=document.getElementsByName(n.v),i=[],r=0;r<e.length;r++)i.push(Sk.misceval.callsimArray(t.Element,[e[r]]));return new Sk.builtin.list(i)})),t.querySelector=new Sk.builtin.func((function(n){var e=document.querySelector(n.v);return e?Sk.misceval.callsimArray(t.Element,[e]):Sk.builtin.none.none$})),t.querySelectorAll=new Sk.builtin.func((function(n){for(var e=document.querySelectorAll(n.v),i=[],r=0;r<e.length;r++)i.push(Sk.misceval.callsimArray(t.Element,[e[r]]));return new Sk.builtin.list(i)})),t.getCurrentEditorValue=new Sk.builtin.func((function(){if(void 0!==Sk.divid&&void 0!==window.edList){if(Sk.gradeContainer!=Sk.divid){var n=Sk.gradeContainer+\" \"+Sk.divid;return new Sk.builtin.str(window.edList[n].editor.getValue())}return new Sk.builtin.str(window.edList[Sk.divid].editor.getValue())}throw new Sk.builtin.AttributeError(\"Can't find editor for this div\")})),t.currentDiv=new Sk.builtin.func((function(){if(void 0!==Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for divid\")})),t.currentCourse=new Sk.builtin.func((function(){if(void 0!==eBookConfig)return new Sk.builtin.str(eBookConfig.course);throw new Sk.builtin.AttributeError(\"There is no course\")})),t.currentGradingContainer=new Sk.builtin.func((function(){if(void 0!==Sk.gradeContainer)return new Sk.builtin.str(Sk.gradeContainer);if(null!=Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for grading\")})),e=function(n,e){e.__init__=new Sk.builtin.func((function(n,e){n.v=e,n.innerHTML=e.innerHTML,n.innerText=e.innerText,void 0!==e.value&&(n.value=e.value,Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(\"value\"),new Sk.builtin.str(n.value))),void 0!==e.checked&&(n.checked=e.checked,Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(\"checked\"),Sk.builtin.bool(n.checked))),Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(\"innerHTML\"),new Sk.builtin.str(n.innerHTML)),Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(\"innerText\"),new Sk.builtin.str(n.innerText))})),e.__setattr__=new Sk.builtin.func((function(n,e,t){\"innerHTML\"===(e=Sk.ffi.remapToJs(e))&&(n.innerHTML=t,n.v.innerHTML=t.v,Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(\"innerHTML\"),t)),\"innerText\"===e&&(n.innerText=t,n.v.innerText=t.v,Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(\"innerText\"),t))})),e.appendChild=new Sk.builtin.func((function(n,e){n.v.appendChild(e.v)})),e.removeChild=new Sk.builtin.func((function(n,e){n.v.removeChild(e.v)})),e.closest=new Sk.builtin.func((function(n,e){var i=n.v.closest(e.v);return i?Sk.misceval.callsimArray(t.Element,[i]):Sk.builtin.none.none$})),e.getCSS=new Sk.builtin.func((function(n,e){return new Sk.builtin.str(n.v.style[e.v])})),e.setCSS=new Sk.builtin.func((function(n,e,t){n.v.style[e.v]=t.v})),e.getAttribute=new Sk.builtin.func((function(n,e){var t=n.v.getAttribute(e.v);return t?new Sk.builtin.str(t):Sk.builtin.none.none$})),e.setAttribute=new Sk.builtin.func((function(n,e,t){n.v.setAttribute(e.v,t.v)})),e.getProperty=new Sk.builtin.func((function(n,e){var t=n.v[e.v];return t?new Sk.builtin.str(t):Sk.builtin.none.none$})),e.__str__=new Sk.builtin.func((function(n){return console.log(n.v.tagName),new Sk.builtin.str(n.v.tagName)})),e.__repr__=new Sk.builtin.func((function(n){return new Sk.builtin.str(\"[DOM Element]\")}))},t.Element=Sk.misceval.buildClass(t,e,\"Element\",[]),t};","src/lib/functools.js":"function $builtinmodule(){const t={};return Sk.misceval.chain(Sk.importModule(\"collections\",!1,!0),(e=>(t._namedtuple=e.$d.namedtuple,functools_mod(t))))}function functools_mod(t){const{object:e,int_:n,str:r,list:s,tuple:a,dict:i,none:{none$:o},bool:{false$:c},NotImplemented:{NotImplemented$:_},bool:l,func:p,method:u,TypeError:h,RuntimeError:d,ValueError:f,NotImplementedError:m,AttributeErrror:w,OverflowError:g,checkNone:$,checkBool:y,checkCallable:k,checkClass:b}=Sk.builtin,{callsimArray:x,callsimOrSuspendArray:A,iterFor:S,chain:E,isIndex:v,asIndexSized:N,isTrue:P,richCompareBool:j,objectRepr:R}=Sk.misceval,{remapToPy:z}=Sk.ffi,{buildNativeClass:q,setUpModuleMethods:T,keywordArrayFromPyDict:I,keywordArrayToPyDict:D,objectHash:C,lookupSpecial:M,copyKeywordsToNamedArgs:W,typeName:F,iter:U,gattr:O}=Sk.abstr,{getSetDict:G,getAttr:B,setAttr:K}=Sk.generic;function proxyFail(t){return new p((()=>{throw new m(t+\" is not yet implemented in skulpt\")}))}Object.assign(t,{__name__:new r(\"functools\"),__doc__:new r(\"Tools for working with functions and callable objects\"),__all__:new s([\"update_wrapper\",\"wraps\",\"WRAPPER_ASSIGNMENTS\",\"WRAPPER_UPDATES\",\"total_ordering\",\"cmp_to_key\",\"cache\",\"lru_cache\",\"reduce\",\"partial\",\"partialmethod\",\"singledispatch\",\"singledispatchmethod\",\"cached_property\"].map((t=>new r(t)))),WRAPPER_ASSIGNMENTS:new a([\"__module__\",\"__name__\",\"__qualname__\",\"__doc__\",\"__annotations__\"].map((t=>new r(t)))),WRAPPER_UPDATES:new a([new r(\"__dict__\")]),singledispatch:proxyFail(\"singledispatch\"),singledispatchmethod:proxyFail(\"singledispatchmethod\"),cached_property:proxyFail(\"cached_property\")});const L=new r(\"cache_parameters\");function _lru_cache(e,n){if(n||(n=c),v(e))(e=N(e,g))<0&&(e=0);else{if(k(e)&&y(n)){const r=e,s=new V(r,e=128,n);return s.tp$setattr(L,new p((()=>z({maxsize:e,typed:n})))),A(t.update_wrapper,[s,r])}if(!$(e))throw new h(\"Expected first argument to be an integer, a callable, or None\")}return new p((r=>{const s=new V(r,e,n);return s.tp$setattr(L,new p((()=>z({maxsize:e,typed:n})))),A(t.update_wrapper,[s,r])}))}const H=t._CacheInfo=x(t._namedtuple,[\"CacheInfo\",[\"hits\",\"misses\",\"maxsize\",\"currsize\"]].map((t=>z(t))),[\"module\",new r(\"functools\")]),V=q(\"functools._lru_cache_wrapper\",{constructor:function _lru_cache_wrapper(t,e,n,r){if(!k(t))throw new h(\"the first argument must be callable\");let s;if($(e))s=infinite_lru_cache_wrapper,e=-1;else{if(!v(e))throw new h(\"maxsize should be integer or None\");(e=N(e,g))<0&&(e=0),s=0===e?uncached_lru_cache_wrapper:bounded_lru_cache_wrapper}this.root={},this.root.prev=this.root.next=this.root,this.wrapper=s,this.maxsize=e,this.typed=n,this.cache=new i([]),this.func=t,this.misses=this.hits=0,this.$d=new i([])},slots:{tp$new(t,e){const[n,r,s,a]=W(\"_lru_cache_wrapper\",[\"user_function\",\"maxsize\",\"typed\",\"cache_info_type\"],t,e);return new V(n,r,s,a)},tp$call(t,e){return this.wrapper(t,e)},tp$descr_get(t,e){return null===t?this:new u(this,t)},tp$doc:\"Create a cached callable that wraps another function.\\n\\nuser_function:      the function being cached\\n\\nmaxsize:  0         for no caching\\n          None      for unlimited cache size\\n          n         for a bounded cache\\n\\ntyped:    False     cache f(3) and f(3.0) as identical calls\\n          True      cache f(3) and f(3.0) as distinct calls\\n\\ncache_info_type:    namedtuple class with the fields:\\n                        hits misses currsize maxsize\\n\"},methods:{cache_info:{$meth(){return A(H,[this.hits,this.misses,-1===this.maxsize?o:this.maxsize,this.cache.get$size()].map((t=>z(t))))},$flags:{NoArgs:!0},$doc:\"Report cache statistics\"},cache_clear:{$meth(){return this.hits=this.misses=0,this.root={},this.root.next=this.root.prev=this.root,A(this.cache.tp$getattr(new r(\"clear\"),!0))},$flags:{NoArgs:!0},$doc:\"Clear the cache and cache statistics\"},__deepcopy__:{$meth(t){return this},$flags:{OneArg:!0}},__copy__:{$meth(){return this},$flags:{NoArgs:!0}}},getsets:{__dict__:G}});function infinite_lru_cache_wrapper(t,e){const n=_make_key(t,e,this.typed),r=this.cache.mp$lookup(n);return void 0!==r?(this.hits++,r):(this.misses++,E(A(this.func,t,e),(t=>(this.cache.mp$ass_subscript(n,t),t))))}function uncached_lru_cache_wrapper(t,e){return this.misses++,A(this.func,t,e)}function bounded_lru_cache_wrapper(t,e){const n=_make_key(t,e,this.typed),r=this.cache.mp$lookup(n);if(void 0!==r){const{result:t}=r;return lru_cache_extract_link(r),lru_cache_append_link(this,r),this.hits++,t}return this.misses++,E(A(this.func,t,e),(t=>{if(void 0!==this.cache.mp$lookup(n))return t;if(this.cache.get$size()<this.maxsize||this.root.next===this.root){const e={key:n,result:t};return this.cache.mp$ass_subscript(n,e),lru_cache_append_link(this,e),t}const e=this.root.next;lru_cache_extract_link(e);if(void 0===this.cache.pop$item(e.key))throw function lru_cache_prepend_link(t,e){const n=t.root,r=n.next;r.prev=n.next=e,e.prev=n,e.next=r}(this,e),new d(\"cached item removed unexpectedly\");return e.key=n,e.result=t,this.cache.mp$ass_subscript(n,e),lru_cache_append_link(this,e),t}))}function lru_cache_extract_link(t){const{prev:e,next:n}=t;e.next=t.next,n.prev=t.prev}function lru_cache_append_link(t,e){const n=t.root,r=n.prev;r.next=n.prev=e,e.prev=r,e.next=n}const J=q(\"_HachedSeq\",{base:s,constructor:function _HachedSeq(t){this.$hashval=C(new a(t)),s.call(this,t)},slots:{tp$hash(){return this.$hashval}}}),Q=new e,X=new Set([n,r]);function _make_key(t,e,n){const s=t.slice(0),i=[];if(e&&e.length){s.push(Q);for(let t=0;t<e.length;t+=2){const n=e[t+1];i.push(n),s.push(new a([new r(e[t]),n]))}}if(P(n))s.push(...t.map((t=>t.ob$type)),...i.map((t=>t.ob$type)));else if(1===s.length&&X.has(s[0].ob$type))return s[0];return new J(s)}function partial_adjust_args_kwargs(t,e){if(t=this.arg_arr.concat(t),e){e=D(e);const t=this.kwdict.dict$copy();t.dict$merge(e),e=I(t)}else e=I(this.kwdict);return{args:t,kwargs:e}}function partial_new(t,e){if(t.length<1)throw new h(\"type 'partial' takes at least 1 argument\");let n,r,s=t.shift();if(s instanceof this.sk$builtinBase){const t=s;s=t.fn,n=t.arg_arr,r=t.kwdict}this.check$func(s),n&&(t=n.concat(t));let a=D(e=e||[]);if(r){const t=r.dict$copy();t.dict$merge(a),a=t}if(this.sk$builtinBase===this.constructor)return new this.constructor(s,t,a);{const e=new this.constructor;return this.sk$builtinBase.call(e,s,t,a),e}}function partial_repr(){if(this.in$repr)return new r(\"...\");this.in$repr=!0;const t=[R(this.fn)];return this.arg_arr.forEach((e=>{t.push(R(e))})),this.kwdict.$items().forEach((([e,n])=>{t.push(e.toString()+\"=\"+R(n))})),this.in$repr=!1,new r(this.tp$name+\"(\"+t.join(\", \")+\")\")}t.partial=q(\"functools.partial\",{constructor:function partial(t,e,n){this.fn=t,this.arg_arr=e,this.arg_tup=new a(e),this.kwdict=n,this.in$repr=!1,this.$d=new i([])},slots:{tp$new:partial_new,tp$call(t,e){return({args:t,kwargs:e}=this.adj$args_kws(t,e)),this.fn.tp$call(t,e)},tp$doc:\"partial(func, *args, **keywords) - new function with partial application\\n    of the given arguments and keywords.\\n\",$r:partial_repr,tp$getattr:B,tp$setattr:K},getsets:{func:{$get(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:G},methods:{},classmethods:Sk.generic.classGetItem,proto:{adj$args_kws:partial_adjust_args_kwargs,check$func(t){if(!k(t))throw new h(\"the first argument must be callable\")}}}),t.partialmethod=q(\"functools.partialmethod\",{constructor:function partialmethod(t,e,n){this.fn=t,this.arg_arr=e,this.arg_tup=new a(e),this.kwdict=n},slots:{tp$new:partial_new,tp$doc:\"Method descriptor with partial application of the given arguments\\n    and keywords.\\n\\n    Supports wrapping existing descriptors and handles non-descriptor\\n    callables as instance methods.\\n    \",$r:partial_repr,tp$descr_get(e,n){let r;if(this.fn.tp$descr_get){const s=this.fn.tp$descr_get(e,n);if(s!==this.fn){if(!k(s))throw new h(\"type 'partial' requires a callable\");r=new t.partial(s,this.arg_arr.slice(0),this.kwdict.dict$copy());const e=M(s,this.str$self);void 0!==e&&r.tp$setattr(this.str$self,e)}}return void 0===r&&(r=this.make$unbound().tp$descr_get(e,n)),r}},methods:{_make_unbound_method:{$meth(){return this.make$unbound()},$flags:{NoArgs:!0}}},classmethods:Sk.generic.classGetItem,getsets:{func:{$get(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:G},proto:{str$self:new r(\"__self__\"),make$unbound(){const t=this;function _method(e,n){const r=e.shift();return({args:e,kwargs:n}=t.adj$args_kws(e,n)),e.unshift(r),A(t.fn,e,n)}return _method.co_fastcall=!0,new p(_method)},adj$args_kws:partial_adjust_args_kwargs,check$func(t){if(!k(t)&&void 0===t.tp$descr_get)throw new h(R(t)+\" is not callable or a descriptor\")}}});const Y={__lt__:r.$lt,__le__:r.$le,__gt__:r.$gt,__ge__:r.$ge};function from_slot(t,e){const n=Y[t];function compare_slot(t,r){let s=x(t.tp$getattr(n),[r]);return s===_?s:(s=P(s),new l(e(s,t,r)))}return compare_slot.co_name=n,compare_slot}const Z=from_slot(\"__lt__\",((t,e,n)=>!t&&j(e,n,\"NotEq\"))),tt=from_slot(\"__lt__\",((t,e,n)=>t||j(e,n,\"Eq\"))),et=from_slot(\"__lt__\",(t=>!t)),nt=from_slot(\"__le__\",((t,e,n)=>!t||j(e,n,\"Eq\"))),rt=from_slot(\"__le__\",((t,e,n)=>t&&j(e,n,\"NotEq\"))),st=from_slot(\"__le__\",(t=>!t)),at=from_slot(\"__gt__\",((t,e,n)=>!t&&j(e,n,\"NotEq\"))),it=from_slot(\"__gt__\",((t,e,n)=>t||j(e,n,\"Eq\"))),ot=from_slot(\"__gt__\",(t=>!t)),ct=from_slot(\"__ge__\",((t,e,n)=>!t||j(e,n,\"Eq\"))),_t=from_slot(\"__ge__\",((t,e,n)=>t&&j(e,n,\"NotEq\"))),lt=from_slot(\"__ge__\",(t=>!t)),pt={__lt__:{__gt__:new p(Z),__le__:new p(tt),__ge__:new p(et)},__le__:{__ge__:new p(nt),__lt__:new p(rt),__gt__:new p(st)},__gt__:{__lt__:new p(at),__ge__:new p(it),__le__:new p(ot)},__ge__:{__le__:new p(ct),__gt__:new p(_t),__lt__:new p(lt)}},ut={__lt__:\"ob$lt\",__le__:\"ob$le\",__gt__:\"ob$gt\",__ge__:\"ob$ge\"};const ht=new n(0),dt=q(\"functools.KeyWrapper\",{constructor:function(t,e){this.cmp=t,this.obj=e},slots:{tp$call(t,e){const[n]=W(\"K\",[\"obj\"],t,e,[]);return new dt(this.cmp,n)},tp$richcompare(t,e){if(!(t instanceof dt))throw new h(\"other argument must be K instance\");const n=this.obj,r=t.obj;if(!n||!r)throw new w(\"object\");const s=A(this.cmp,[n,r]);return E(s,(t=>j(t,ht,e)))},tp$getattr:B,tp$hash:o},getsets:{obj:{$get(){return this.obj||o},$set(t){this.obj=t},$doc:\"Value wrapped by a key function.\"}}}),ft=new r(\"update\"),mt=new r(\"__wrapped__\");return T(\"functools\",t,{cache:{$meth:function cache(t){return A(_lru_cache(o),[t])},$flags:{OneArg:!0},$doc:'Simple lightweight unbounded cache.  Sometimes called \"memoize\".',$textsig:\"($module, user_function, /)\"},lru_cache:{$meth:_lru_cache,$flags:{NamedArgs:[\"maxsize\",\"typed\"],Defaults:[new n(128),c]},$doc:\"Least-recently-used cache decorator.\\n\\nIf *maxsize* is set to None, the LRU features are disabled and the cache\\ncan grow without bound.\\n\\nIf *typed* is True, arguments of different types will be cached separately.\\nFor example, f(3.0) and f(3) will be treated as distinct calls with\\ndistinct results.\\n\\nArguments to the cached function must be hashable.\\n\\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\\nAccess the underlying function with f.__wrapped__.\\n\\nSee:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\"},cmp_to_key:{$meth:function cmp_to_key(t){return new dt(t)},$flags:{NamedArgs:[\"mycmp\"],Defaults:[]},$doc:\"Convert a cmp= function into a key= function.\",$textsig:\"($module, cmp, /)\"},reduce:{$meth:function reduce(t,e,n){const r=U(e);let s;return n=n||r.tp$iternext(!0),E(n,(e=>{if(void 0===e)throw new h(\"reduce() of empty sequence with no initial value\");return s=e,S(r,(e=>E(A(t,[s,e]),(t=>{s=t}))))}),(()=>s))},$flags:{MinArgs:2,MaxArgs:3},$doc:\"reduce(function, sequence[, initial]) -> value\\n\\nApply a function of two arguments cumulatively to the items of a sequence,\\nfrom left to right, so as to reduce the sequence to a single value.\\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\\nof the sequence in the calculation, and serves as a default when the\\nsequence is empty.\",$textsig:\"($module, function, sequence[, initial], /)\"},total_ordering:{$meth:function total_ordering(t){const n=[];if(!b(t))throw new h(\"total ordering only supported for type objects not '\"+F(t)+\"'\");if(Object.keys(pt).forEach((r=>{const s=ut[r];t.prototype[s]!==e.prototype[s]&&n.push(r)})),!n.length)throw new f(\"must define atleast one ordering operation: <, >, <=, >=\");const r=n[0];return Object.entries(pt[r]).forEach((([e,r])=>{n.includes(e)||t.tp$setattr(Y[e],r)})),t},$flags:{OneArg:!0},$doc:\"Class decorator that fills in missing ordering methods\"},update_wrapper:{$meth:function update_wrapper(t,e,n,r){let s,a=U(n);for(let i=a.tp$iternext();void 0!==i;i=a.tp$iternext())void 0!==(s=e.tp$getattr(i))&&t.tp$setattr(i,s);a=U(r);for(let o=a.tp$iternext();void 0!==o;o=a.tp$iternext()){s=e.tp$getattr(o)||new i([]);const n=O(t,o),r=O(n,ft);x(r,[s])}return t.tp$setattr(mt,e),t},$flags:{NamedArgs:[\"wrapper\",\"wrapped\",\"assigned\",\"updated\"],Defaults:[t.WRAPPER_ASSIGNMENTS,t.WRAPPER_UPDATES]},$doc:\"Update a wrapper function to look like the wrapped function\\n\\n       wrapper is the function to be updated\\n       wrapped is the original function\\n       assigned is a tuple naming the attributes assigned directly\\n       from the wrapped function to the wrapper function (defaults to\\n       functools.WRAPPER_ASSIGNMENTS)\\n       updated is a tuple naming the attributes of the wrapper that\\n       are updated with the corresponding attribute from the wrapped\\n       function (defaults to functools.WRAPPER_UPDATES)\\n    \",$textsig:\"($module, /, wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"},wraps:{$meth:function wraps(e,n,r){const s=[\"wrapped\",e,\"assigned\",n,\"updated\",r];return A(t.partial,[t.update_wrapper],s)},$flags:{NamedArgs:[\"wrapped\",\"assigned\",\"updated\"],Defaults:[t.WRAPPER_ASSIGNMENTS,t.WRAPPER_UPDATES]},$doc:\"Decorator factory to apply update_wrapper() to a wrapper function\\n\\n       Returns a decorator that invokes update_wrapper() with the decorated\\n       function as the wrapper argument and the arguments to wraps() as the\\n       remaining arguments. Default arguments are as for update_wrapper().\\n       This is a convenience function to simplify applying partial() to\\n       update_wrapper().\\n    \",$textsig:\"($module, /, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"}}),t}","src/lib/image.js":"var ImageMod,$builtinmodule;ImageMod||((ImageMod={}).canvasLib=[]),$builtinmodule=function(e){var n,t,i,a,u,l,r,s={__name__:new Sk.builtin.str(\"image\")};return s.Image=Sk.misceval.buildClass(s,(function(e,n){u=function(e){e.width=e.image.width,e.height=e.image.height,e.delay=0,e.updateCount=0,e.updateInterval=1,e.lastx=0,e.lasty=0,e.canvas=document.createElement(\"canvas\"),e.canvas.height=e.height,e.canvas.width=e.width,e.ctx=e.canvas.getContext(\"2d\"),e.ctx.drawImage(e.image,0,0),e.imagedata=e.ctx.getImageData(0,0,e.width,e.height)},n.__init__=new Sk.builtin.func((function(e,n){var t;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2);try{e.image=document.getElementById(Sk.ffi.remapToJs(n)),null==e.image&&(e.image=document.querySelector(`[data-filename=\"${Sk.ffi.remapToJs(n)}\"]`)),u(e)}catch(i){e.image=null}if(null==e.image)return(t=new Sk.misceval.Suspension).resume=function(){if(t.data.error)throw new Sk.builtin.IOError(t.data.error.message)},t.data={type:\"Sk.promise\",promise:new Promise((function(t,i){var a=new Image;a.crossOrigin=\"\",a.onerror=function(){i(Error(\"Failed to load URL: \"+a.src))},a.onload=function(){e.image=this,u(e),t()},a.src=r(n)}))},t})),r=function(e){let n=Sk.ffi.remapToJs(e);try{let e=Sk.read(n);return`data:image/${n.substring(n.lastIndexOf(\".\")+1)};base64, ${e}`}catch(u){console.log(`${n} is not in the database ${u}`)}var t,i,a=\"function\"==typeof Sk.imageProxy?Sk.imageProxy:function(e){return(t=document.createElement(\"a\")).href=i,window.location.host!==t.host?Sk.imageProxy+\"/\"+e:e};return i=a(i=Sk.ffi.remapToJs(e))},l=function(e,n,t){if(n<0||t<0||n>=e.width||t>=e.height)throw new Sk.builtin.ValueError(\"Pixel index out of range.\")};var setdelay=function(e,n,t){var i;Sk.builtin.pyCheckArgsLen(\"setdelay\",arguments.length,2,3),e.delay=Sk.ffi.remapToJs(n),i=Sk.builtin.asnum$(t),e.updateInterval=i||1};n.set_delay=new Sk.builtin.func(setdelay),n.setDelay=new Sk.builtin.func(setdelay);var getpixels=function(e){var n,t=[];for(Sk.builtin.pyCheckArgsLen(\"getpixels\",arguments.length,1,1),n=0;n<e.image.height*e.image.width;n++)t[n]=Sk.misceval.callsimArray(e.getPixel,[e,n%e.image.width,Math.floor(n/e.image.width)]);return new Sk.builtin.tuple(t)};n.get_pixels=new Sk.builtin.func(getpixels),n.getPixels=new Sk.builtin.func(getpixels),n.getData=new Sk.builtin.func((function(e){var n,t,i,a,u,r,s,c=[];for(Sk.builtin.pyCheckArgsLen(\"getData\",arguments.length,1,1),n=0;n<e.image.height*e.image.width;n++)t=n%e.image.width,i=Math.floor(n/e.image.width),l(e,t,i),s=4*i*e.width+4*t,a=e.imagedata.data[s],u=e.imagedata.data[s+1],r=e.imagedata.data[s+2],c[n]=new Sk.builtin.tuple([new Sk.builtin.int_(a),new Sk.builtin.int_(u),new Sk.builtin.int_(r)]);return new Sk.builtin.list(c)}));var getpixel=function(e,n,t){var i,a,u,r;return Sk.builtin.pyCheckArgsLen(\"getpixel\",arguments.length,3,3),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),l(e,n,t),r=4*t*e.width+4*n,i=e.imagedata.data[r],u=e.imagedata.data[r+1],a=e.imagedata.data[r+2],Sk.misceval.callsimArray(s.Pixel,[i,u,a,n,t])};n.get_pixel=new Sk.builtin.func(getpixel),n.getPixel=new Sk.builtin.func(getpixel),a=function(e,n,t){var i=new Sk.misceval.Suspension;return i.resume=function(){return Sk.builtin.none.none$},i.data={type:\"Sk.promise\",promise:new Promise((function(i,a){e.updateCount++,e.updateCount%e.updateInterval==0?(e.lastx+e.updateInterval>=e.width?e.lastCtx.putImageData(e.imagedata,e.lastUlx,e.lastUly,0,e.lasty,e.width,2):e.lasty+e.updateInterval>=e.height?e.lastCtx.putImageData(e.imagedata,e.lastUlx,e.lastUly,e.lastx,0,2,e.height):e.lastCtx.putImageData(e.imagedata,e.lastUlx,e.lastUly,Math.min(n,e.lastx),Math.min(t,e.lasty),Math.max(Math.abs(n-e.lastx),1),Math.max(Math.abs(t-e.lasty),1)),e.lastx=n,e.lasty=t,e.delay>0?window.setTimeout(i,e.delay):i()):i()}))},i};var setpixel=function(e,n,t,i){var u;return Sk.builtin.pyCheckArgsLen(\"setpixel\",arguments.length,4,4),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),l(e,n,t),u=4*t*e.width+4*n,e.imagedata.data[u]=Sk.builtin.asnum$(Sk.misceval.callsimArray(i.getRed,[i])),e.imagedata.data[u+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(i.getGreen,[i])),e.imagedata.data[u+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(i.getBlue,[i])),e.imagedata.data[u+3]=255,a(e,n,t)};n.set_pixel=new Sk.builtin.func(setpixel),n.setPixel=new Sk.builtin.func(setpixel);var setpixelat=function(e,n,t){var i,u,r;return Sk.builtin.pyCheckArgsLen(\"setpixelat\",arguments.length,3,3),i=(n=Sk.builtin.asnum$(n))%e.image.width,u=Math.floor(n/e.image.width),l(e,i,u),r=4*u*e.width+4*i,e.imagedata.data[r]=Sk.builtin.asnum$(Sk.misceval.callsimArray(t.getRed,[t])),e.imagedata.data[r+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(t.getGreen,[t])),e.imagedata.data[r+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(t.getBlue,[t])),e.imagedata.data[r+3]=255,a(e,i,u)};n.set_pixel_at=new Sk.builtin.func(setpixelat),n.setPixelAt=new Sk.builtin.func(setpixelat);var updatepixel=function(e,n){var t,i,u;return Sk.builtin.pyCheckArgsLen(\"updatepixel\",arguments.length,2,2),t=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getX,[n])),i=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getY,[n])),l(e,t,i),u=4*i*e.width+4*t,e.imagedata.data[u]=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getRed,[n])),e.imagedata.data[u+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getGreen,[n])),e.imagedata.data[u+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getBlue,[n])),e.imagedata.data[u+3]=255,a(e,t,i)};n.update_pixel=new Sk.builtin.func(updatepixel),n.updatePixel=new Sk.builtin.func(updatepixel);var getheight=function(e){return Sk.builtin.pyCheckArgsLen(\"getheight\",arguments.length,1,1),new Sk.builtin.int_(e.height)};n.get_height=new Sk.builtin.func(getheight),n.getHeight=new Sk.builtin.func(getheight);var getwidth=function(e,n){return Sk.builtin.pyCheckArgsLen(\"getwidth\",arguments.length,1,1),new Sk.builtin.int_(e.width)};n.get_width=new Sk.builtin.func(getwidth),n.getWidth=new Sk.builtin.func(getwidth),n.__getattr__=new Sk.builtin.func((function(e,n){return\"height\"===(n=Sk.ffi.remapToJs(n))?Sk.builtin.assk$(e.height):\"width\"===n?Sk.builtin.assk$(e.width):void 0})),n.__setattr__=new Sk.builtin.func((function(e,n,t){throw\"height\"===(n=Sk.ffi.remapToJs(n))||\"width\"===n?new Sk.builtin.Exception(\"Cannot change height or width they can only be set on creation\"):new Sk.builtin.Exception(\"Unknown attribute: \"+n)})),n.draw=new Sk.builtin.func((function(e,n,t,i){var a;return Sk.builtin.pyCheckArgsLen(\"draw\",arguments.length,2,4),(a=new Sk.misceval.Suspension).resume=function(){return Sk.builtin.none.none$},a.data={type:\"Sk.promise\",promise:new Promise((function(a,u){var l;n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),i=Sk.builtin.asnum$(i),l=Sk.misceval.callsimArray(n.getWin,[n]).getContext(\"2d\"),void 0===t&&(t=0,i=0),e.lastUlx=t,e.lastUly=i,e.lastCtx=l,l.putImageData(e.imagedata,t,i),e.delay>0?window.setTimeout(a,e.delay):window.setTimeout(a,200)}))},a}))}),\"Image\",[]),i=function(e,n){n.__init__=new Sk.builtin.func((function(e,n,t){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,3,3),e.width=Sk.builtin.asnum$(n),e.height=Sk.builtin.asnum$(t),e.canvas=document.createElement(\"canvas\"),e.ctx=e.canvas.getContext(\"2d\"),e.canvas.height=e.height,e.canvas.width=e.width,e.imagedata=e.ctx.getImageData(0,0,e.width,e.height)}))},s.EmptyImage=Sk.misceval.buildClass(s,i,\"EmptyImage\",[s.Image]),t=function(e,n){n.__init__=new Sk.builtin.func((function(e,n,t,i,a,u){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,4,6),e.red=Sk.builtin.asnum$(n),e.green=Sk.builtin.asnum$(t),e.blue=Sk.builtin.asnum$(i),e.x=Sk.builtin.asnum$(a),e.y=Sk.builtin.asnum$(u)}));var getred=function(e){return Sk.builtin.pyCheckArgsLen(\"getred\",arguments.length,1,1),Sk.builtin.assk$(e.red)};n.get_red=new Sk.builtin.func(getred),n.getRed=new Sk.builtin.func(getred);var getgreen=function(e){return Sk.builtin.pyCheckArgsLen(\"getgreen\",arguments.length,1,1),Sk.builtin.assk$(e.green)};n.get_green=new Sk.builtin.func(getgreen),n.getGreen=new Sk.builtin.func(getgreen);var getblue=function(e){return Sk.builtin.pyCheckArgsLen(\"getblue\",arguments.length,1,1),Sk.builtin.assk$(e.blue)};n.get_blue=new Sk.builtin.func(getblue),n.getBlue=new Sk.builtin.func(getblue);var getx=function(e){return Sk.builtin.pyCheckArgsLen(\"getx\",arguments.length,1,1),Sk.builtin.assk$(e.x)};n.get_x=new Sk.builtin.func(getx),n.getX=new Sk.builtin.func(getx);var gety=function(e){return Sk.builtin.pyCheckArgsLen(\"gety\",arguments.length,1,1),Sk.builtin.assk$(e.y)};n.get_y=new Sk.builtin.func(gety),n.getY=new Sk.builtin.func(gety);var setred=function(e,n){Sk.builtin.pyCheckArgsLen(\"setred\",arguments.length,2,2),e.red=Sk.builtin.asnum$(n)};n.set_red=new Sk.builtin.func(setred),n.setRed=new Sk.builtin.func(setred);var setgreen=function(e,n){Sk.builtin.pyCheckArgsLen(\"setgreen\",arguments.length,2,2),e.green=Sk.builtin.asnum$(n)};n.set_green=new Sk.builtin.func(setgreen),n.setGreen=new Sk.builtin.func(setgreen);var setblue=function(e,n){Sk.builtin.pyCheckArgsLen(\"setblue\",arguments.length,2,2),e.blue=Sk.builtin.asnum$(n)};n.set_blue=new Sk.builtin.func(setblue),n.setBlue=new Sk.builtin.func(setblue),n.__getattr__=new Sk.builtin.func((function(e,n){return\"red\"===(n=Sk.ffi.remapToJs(n))?Sk.builtin.assk$(e.red):\"green\"===n?Sk.builtin.assk$(e.green):\"blue\"===n?Sk.builtin.assk$(e.blue):void 0})),n.__setattr__=new Sk.builtin.func((function(e,n,t){\"red\"!==(n=Sk.ffi.remapToJs(n))&&\"green\"!==n&&\"blue\"!==n||(e[n]=Sk.builtin.asnum$(t))}));var setx=function(e,n){Sk.builtin.pyCheckArgsLen(\"setx\",arguments.length,2,2),e.x=Sk.builtin.asnum$(n)};n.set_x=new Sk.builtin.func(setx),n.setX=new Sk.builtin.func(setx);var sety=function(e,n){Sk.builtin.pyCheckArgsLen(\"sety\",arguments.length,2,2),e.y=Sk.builtin.asnum$(n)};n.set_y=new Sk.builtin.func(sety),n.setY=new Sk.builtin.func(sety),n.__getitem__=new Sk.builtin.func((function(e,n){return 0===(n=Sk.builtin.asnum$(n))?e.red:1==n?e.green:2==n?e.blue:void 0})),n.__str__=new Sk.builtin.func((function(e){return Sk.ffi.remapToPy(\"[\"+e.red+\",\"+e.green+\",\"+e.blue+\"]\")})),n.getColorTuple=new Sk.builtin.func((function(e,n,t){})),n.setRange=new Sk.builtin.func((function(e,n){e.max=Sk.builtin.asnum$(n)}))},s.Pixel=Sk.misceval.buildClass(s,t,\"Pixel\",[]),n=function(e,n){n.__init__=new Sk.builtin.func((function(e,n,t){var i,a,u;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,1,3),void 0===(i=ImageMod.canvasLib[Sk.canvas])?(a=document.createElement(\"canvas\"),u=document.getElementById(Sk.canvas),e.theScreen=a,u.appendChild(a),ImageMod.canvasLib[Sk.canvas]=a,ImageMod.canvasLib[Sk.canvas]=e.theScreen):(e.theScreen=i,e.theScreen.height=e.theScreen.height),void 0!==n?(e.theScreen.height=t.v,e.theScreen.width=n.v):(Sk.availableHeight&&(e.theScreen.height=Sk.availableHeight),Sk.availableWidth&&(e.theScreen.width=Sk.availableWidth)),e.theScreen.style.display=\"block\"})),n.getWin=new Sk.builtin.func((function(e){return e.theScreen})),n.exitonclick=new Sk.builtin.func((function(e){var n=e.theScreen.id;e.theScreen.onclick=function(){document.getElementById(n).style.display=\"none\",document.getElementById(n).onclick=null,delete ImageMod.canvasLib[n]}}))},s.ImageWin=Sk.misceval.buildClass(s,n,\"ImageWin\",[]),s};","src/lib/itertools.js":"var $builtinmodule=function(t){var e={};function combinationsNew(t,e,i){let r,s;[r,s]=Sk.abstr.copyKeywordsToNamedArgs(t.tp$name,[\"iterable\",\"r\"],e,i,[]);const n=Sk.misceval.arrayFromIterable(r);if(s=Sk.misceval.asIndexSized(s,Sk.builtin.OverFlowError),s<0)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===t)return new t.constructor(n,s);{const e=new this.constructor;return t.constructor.call(e,n,s),e}}return e.accumulate=Sk.abstr.buildIteratorClass(\"itertools.accumulate\",{constructor:function accumulate(t,e,i){this.iter=t,this.func=e,this.total=i,this.tp$iternext=()=>(this.total=Sk.builtin.checkNone(this.total)?this.iter.tp$iternext():this.total,this.tp$iternext=this.constructor.prototype.tp$iternext,this.total)},iternext(t){let e=this.iter.tp$iternext();if(void 0!==e)return this.total=Sk.misceval.callsimArray(this.func,[this.total,e]),this.total},slots:{tp$doc:\"accumulate(iterable[, func, initial]) --\\x3e accumulate object\\n\\nReturn series of accumulated sums (or other binary function results).\",tp$new(t,i){Sk.abstr.checkArgsLen(\"accumulate\",t,0,2);let[r,s,n]=Sk.abstr.copyKeywordsToNamedArgs(\"accumulate\",[\"iterable\",\"func\",\"initial\"],t,i,[Sk.builtin.none.none$,Sk.builtin.none.none$]);if(r=Sk.abstr.iter(r),s=Sk.builtin.checkNone(s)?new Sk.builtin.func(((t,e)=>Sk.abstr.numberBinOp(t,e,\"Add\"))):s,this===e.accumulate.prototype)return new e.accumulate(r,s,n);{const t=new this.constructor;return e.accumulate.call(t,r,s,n),t}}}}),e.chain=Sk.abstr.buildIteratorClass(\"itertools.chain\",{constructor:function chain(t){this.iterables=t,this.current_it=null,this.tp$iternext=()=>{if(this.tp$iternext=this.constructor.prototype.tp$iternext,this.current_it=this.iterables.tp$iternext(),void 0!==this.current_it)return this.current_it=Sk.abstr.iter(this.current_it),this.tp$iternext();this.tp$iternext=()=>{}}},iternext(t){let e;for(;void 0===e;){if(e=this.current_it.tp$iternext(),void 0!==e)return e;if(this.current_it=this.iterables.tp$iternext(),void 0===this.current_it)return void(this.tp$iternext=()=>{});this.current_it=Sk.abstr.iter(this.current_it)}},slots:{tp$doc:\"chain(*iterables) --\\x3e chain object\\n\\nReturn a chain object whose .__next__() method returns elements from the\\nfirst iterable until it is exhausted, then elements from the next\\niterable, until all of the iterables are exhausted.\",tp$new(t,i){if(Sk.abstr.checkNoKwargs(\"chain\",i),t=new Sk.builtin.tuple(t.slice(0)).tp$iter(),this===e.chain.prototype)return new e.chain(t);{const i=new this.constructor;return e.chain.call(i,t),i}}},classmethods:Object.assign({from_iterable:{$meth(t){const i=Sk.abstr.iter(t);return new e.chain(i)},$flags:{OneArg:!0},$doc:\"chain.from_iterable(iterable) --\\x3e chain object\\n\\nAlternate chain() constructor taking a single iterable argument\\nthat evaluates lazily.\",$textsig:null}},Sk.generic.classGetItem)}),e.combinations=Sk.abstr.buildIteratorClass(\"itertools.combinations\",{constructor:function combinations(t,e){this.pool=t,this.r=e,this.indices=new Array(e).fill().map(((t,e)=>e)),this.n=t.length,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(t){let e,i=!1;for(e=this.r-1;e>=0;e--)if(this.indices[e]!=e+this.n-this.r){i=!0;break}if(!i)return void(this.r=0);this.indices[e]++;for(let s=e+1;s<this.r;s++)this.indices[s]=this.indices[s-1]+1;const r=this.indices.map((t=>this.pool[t]));return new Sk.builtin.tuple(r)},slots:{tp$doc:\"combinations(iterable, r) --\\x3e combinations object\\n\\nReturn successive r-length combinations of elements in the iterable.\\n\\ncombinations(range(4), 3) --\\x3e (0,1,2), (0,1,3), (0,2,3), (1,2,3)\",tp$new(t,i){return combinationsNew.call(this,e.combinations.prototype,t,i)}}}),e.combinations_with_replacement=Sk.abstr.buildIteratorClass(\"itertools.combinations_with_replacement\",{constructor:function combinations_with_replacement(t,e){this.pool=t,this.r=e,this.indices=new Array(e).fill(0),this.n=t.length,this.tp$iternext=()=>{if(this.r&&!this.n)return;this.tp$iternext=this.constructor.prototype.tp$iternext;const t=this.indices.map((t=>this.pool[t]));return new Sk.builtin.tuple(t)}},iternext(t){let e,i=!1;for(e=this.r-1;e>=0;e--)if(this.indices[e]!=this.n-1){i=!0;break}if(!i)return void(this.r=0);const r=this.indices[e]+1;for(let n=e;n<this.r;n++)this.indices[n]=r;const s=this.indices.map((t=>this.pool[t]));return new Sk.builtin.tuple(s)},slots:{tp$doc:\"combinations_with_replacement(iterable, r) --\\x3e combinations_with_replacement object\\n\\nReturn successive r-length combinations of elements in the iterable\\nallowing individual elements to have successive repeats.\\ncombinations_with_replacement('ABC', 2) --\\x3e AA AB AC BB BC CC\",tp$new(t,i){return combinationsNew.call(this,e.combinations_with_replacement.prototype,t,i)}}}),e.compress=Sk.abstr.buildIteratorClass(\"itertools.compress\",{constructor:function compress(t,e){this.data=t,this.selectors=e},iternext(){let t=this.data.tp$iternext(),e=this.selectors.tp$iternext();for(;void 0!==t&&void 0!==e;){if(Sk.misceval.isTrue(e))return t;t=this.data.tp$iternext(),e=this.selectors.tp$iternext()}},slots:{tp$doc:\"compress(data, selectors) --\\x3e iterator over selected data\\n\\nReturn data elements corresponding to true selector elements.\\nForms a shorter iterator from selected data elements using the\\nselectors to choose the data elements.\",tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"compress\",[\"data\",\"selectors\"],t,i,[]),r=Sk.abstr.iter(r),s=Sk.abstr.iter(s),this===e.count.prototype)return new e.compress(r,s);{const t=new this.constructor;return e.compress.call(t,r,s),t}}}}),e.count=Sk.abstr.buildIteratorClass(\"itertools.count\",{constructor:function count(t,e){this.start=t,this.step=e},iternext(){const t=this.start;return this.start=Sk.abstr.numberBinOp(this.start,this.step,\"Add\"),t},slots:{tp$doc:\"count(start=0, step=1) --\\x3e count object\\n\\nReturn a count object whose .__next__() method returns consecutive values.\\nEquivalent to:\\n\\n    def count(firstval=0, step=1):\\n        x = firstval\\n        while 1:\\n            yield x\\n            x += step\\n\",tp$new(t,i){const[r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"count\",[\"start\",\"step\"],t,i,[new Sk.builtin.int_(0),new Sk.builtin.int_(1)]);if(!Sk.builtin.checkNumber(r)&&!Sk.builtin.checkComplex(r))throw new Sk.builtin.TypeError(\"a number is required\");if(!Sk.builtin.checkNumber(s)&&!Sk.builtin.checkComplex(s))throw new Sk.builtin.TypeError(\"a number is required\");if(this===e.count.prototype)return new e.count(r,s);{const t=new this.constructor;return e.count.call(t,r,s),t}},$r(){const t=Sk.misceval.objectRepr(this.start);let e=Sk.misceval.objectRepr(this.step);return e=\"1\"===e?\"\":\", \"+e,new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+e+\")\")}}}),e.cycle=Sk.abstr.buildIteratorClass(\"itertools.cycle\",{constructor:function cycle(t){this.iter=t,this.saved=[],this.consumed=!1,this.i=0,this.length},iternext(){let t;if(!this.consumed){if(t=this.iter.tp$iternext(),void 0!==t)return this.saved.push(t),t;if(this.consumed=!0,this.length=this.saved.length,!this.length)return}return t=this.saved[this.i],this.i=(this.i+1)%this.length,t},slots:{tp$doc:\"cycle(iterable) --\\x3e cycle object\\n\\nReturn elements from the iterable until it is exhausted.\\nThen repeat the sequence indefinitely.\",tp$new(t,i){Sk.abstr.checkOneArg(\"cycle\",t,i);const r=Sk.abstr.iter(t[0]);if(this===e.cycle.prototype)return new e.cycle(r);{const t=new this.constructor;return e.cycle.call(t,r),t}}}}),e.dropwhile=Sk.abstr.buildIteratorClass(\"itertools.dropwhile\",{constructor:function dropwhile(t,e){this.predicate=t,this.iter=e,this.passed},iternext(){let t=this.iter.tp$iternext();for(;void 0===this.passed&&void 0!==t;){const e=Sk.misceval.callsimArray(this.predicate,[t]);if(!Sk.misceval.isTrue(e))return this.passed=!0,t;t=this.iter.tp$iternext()}return t},slots:{tp$doc:\"dropwhile(predicate, iterable) --\\x3e dropwhile object\\n\\nDrop items from the iterable while predicate(item) is true.\\nAfterwards, return every element until the iterable is exhausted.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"dropwhile\",i),Sk.abstr.checkArgsLen(\"dropwhile\",t,2,2);const r=t[0],s=Sk.abstr.iter(t[1]);if(this===e.dropwhile.prototype)return new e.dropwhile(r,s);{const t=new this.constructor;return e.dropwhile.call(t,r,s),t}}}}),e.filterfalse=Sk.abstr.buildIteratorClass(\"itertools.filterfalse\",{constructor:function filterfalse(t,e){this.predicate=t,this.iter=e},iternext(t){let e=this.iter.tp$iternext();if(void 0===e)return;let i=Sk.misceval.callsimArray(this.predicate,[e]);for(;Sk.misceval.isTrue(i);){if(e=this.iter.tp$iternext(),void 0===e)return;i=Sk.misceval.callsimArray(this.predicate,[e])}return e},slots:{tp$doc:\"filterfalse(function or None, sequence) --\\x3e filterfalse object\\n\\nReturn those items of sequence for which function(item) is false.\\nIf function is None, return the items that are false.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"filterfalse\",i),Sk.abstr.checkArgsLen(\"filterfalse\",t,2,2);const r=Sk.builtin.checkNone(t[0])?Sk.builtin.bool:t[0],s=Sk.abstr.iter(t[1]);if(this===e.filterfalse.prototype)return new e.filterfalse(r,s);{const t=new this.constructor;return e.filterfalse.call(t,r,s),t}}}}),e._grouper=Sk.abstr.buildIteratorClass(\"itertools._grouper\",{constructor:function _grouper(t,e){this.groupby=t,this.tgtkey=t.tgtkey,this.id=t.id},iternext(t){const e=Sk.misceval.richCompareBool(this.groupby.currkey,this.tgtkey,\"Eq\");if(this.groupby.id===this.id&&e){let t=this.groupby.currval;return this.groupby.currval=this.groupby.iter.tp$iternext(),void 0!==this.groupby.currval&&(this.groupby.currkey=Sk.misceval.callsimArray(this.groupby.keyf,[this.groupby.currval])),t}}}),e.groupby=Sk.abstr.buildIteratorClass(\"itertools.groupby\",{constructor:function groupby(t,e){this.iter=t,this.keyf=e,this.currval,this.currkey=this.tgtkey=new Sk.builtin.object,this.id},iternext(t){this.id=new Object;let i=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\");for(;i;){if(this.currval=this.iter.tp$iternext(),void 0===this.currval)return;this.currkey=Sk.misceval.callsimArray(this.keyf,[this.currval]),i=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\")}this.tgtkey=this.currkey;const r=new e._grouper(this);return new Sk.builtin.tuple([this.currkey,r])},slots:{tp$doc:\"groupby(iterable, key=None) -> make an iterator that returns consecutive\\nkeys and groups from the iterable.  If the key function is not specified or\\nis None, the element itself is used for grouping.\\n\",tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"groupby\",[\"iterable\",\"key\"],t,i,[Sk.builtin.none.none$]),r=Sk.abstr.iter(r),s=Sk.builtin.checkNone(s)?new Sk.builtin.func((t=>t)):s,this===e.groupby.prototype)return new e.groupby(r,s);{const t=new this.constructor;return e.groupby.call(t,r,s),t}}}}),e.islice=Sk.abstr.buildIteratorClass(\"itertools.islice\",{constructor:function islice(t,e,i,r){this.iter=t,this.previt=e,this.stop=i,this.step=r,this.tp$iternext=()=>{if(this.tp$iternext=this.constructor.prototype.tp$iternext,!(this.previt>=this.stop)){for(let t=0;t<this.previt;t++)this.iter.tp$iternext();return this.iter.tp$iternext()}for(let t=0;t<this.stop;t++)this.iter.tp$iternext()}},iternext(t){if(!(this.previt+this.step>=this.stop)){for(let t=this.previt+1;t<this.previt+this.step;t++)this.iter.tp$iternext();return this.previt+=this.step,this.iter.tp$iternext()}for(let e=this.previt+1;e<this.stop;e++)this.previt+=this.step,this.iter.tp$iternext()},slots:{tp$doc:\"islice(iterable, stop) --\\x3e islice object\\nislice(iterable, start, stop[, step]) --\\x3e islice object\\n\\nReturn an iterator whose next() method returns selected values from an\\niterable.  If start is specified, will skip all preceding elements;\\notherwise, start defaults to zero.  Step defaults to one.  If\\nspecified as another value, step determines how many values are \\nskipped between successive calls.  Works like a slice() on a list\\nbut returns an iterator.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"islice\",i),Sk.abstr.checkArgsLen(\"islice\",t,2,4);const r=Sk.abstr.iter(t[0]);let s=t[1],n=t[2],o=t[3];if(void 0===n?(n=s,s=Sk.builtin.none.none$,o=Sk.builtin.none.none$):void 0===o&&(o=Sk.builtin.none.none$),!Sk.builtin.checkNone(n)&&!Sk.misceval.isIndex(n))throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(n=Sk.builtin.checkNone(n)?Number.MAX_SAFE_INTEGER:Sk.misceval.asIndexSized(n),n<0||n>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(!Sk.builtin.checkNone(s)&&!Sk.misceval.isIndex(s))throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(s=Sk.builtin.checkNone(s)?0:Sk.misceval.asIndexSized(s),s<0||s>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(!Sk.builtin.checkNone(o)&&!Sk.misceval.isIndex(o))throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None\");if(o=Sk.builtin.checkNone(o)?1:Sk.misceval.asIndexSized(o),o<=0||o>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None.\");if(this===e.islice.prototype)return new e.islice(r,s,n,o);{const t=new this.constructor;return e.islice.call(t,r,s,n,o),t}}}}),e.permutations=Sk.abstr.buildIteratorClass(\"itertools.permutations\",{constructor:function permutations(t,e){this.pool=t,this.r=e;const i=t.length;this.indices=new Array(i).fill().map(((t,e)=>e)),this.cycles=new Array(e).fill().map(((t,e)=>i-e)),this.n=i,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(t){for(let e=this.r-1;e>=0;e--){if(this.cycles[e]--,0!=this.cycles[e]){const t=this.cycles[e];[this.indices[e],this.indices[this.n-t]]=[this.indices[this.n-t],this.indices[e]];const i=this.indices.map((t=>this.pool[t])).slice(0,this.r);return new Sk.builtin.tuple(i)}this.indices.push(this.indices.splice(e,1)[0]),this.cycles[e]=this.n-e}this.r=0},slots:{tp$doc:\"permutations(iterable[, r]) --\\x3e permutations object\\n\\nReturn successive r-length permutations of elements in the iterable.\\n\\npermutations(range(3), 2) --\\x3e (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)\",tp$new(t,i){let r,s;[r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"permutations\",[\"iterable\",\"r\"],t,i,[Sk.builtin.none.none$]);const n=Sk.misceval.arrayFromIterable(r);if(s=Sk.builtin.checkNone(s)?n.length:Sk.misceval.asIndexSized(s,Sk.builtin.OverFlowError),s<0)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===e.permutations.prototype)return new e.permutations(n,s);{const t=new this.constructor;return e.permutations.call(t,n,s),t}}}}),e.product=Sk.abstr.buildIteratorClass(\"itertools.product\",{constructor:function product(t){this.pools=t,this.n=t.length,this.indices=Array(t.length).fill(0),this.pool_sizes=t.map((t=>t.length)),this.tp$iternext=()=>{this.tp$iternext=this.constructor.prototype.tp$iternext;const t=this.indices.map(((t,e)=>this.pools[e][this.indices[e]]));if(!t.some((t=>void 0===t)))return new Sk.builtin.tuple(t);this.n=0}},iternext(t){let e=this.n-1;for(;e>=0&&e<this.n;)this.indices[e]++,this.indices[e]>=this.pool_sizes[e]?(this.indices[e]=-1,e--):e++;if(this.n&&!this.indices.every((t=>-1===t))){const t=this.indices.map(((t,e)=>this.pools[e][this.indices[e]]));return new Sk.builtin.tuple(t)}this.n=0},slots:{tp$doc:\"product(*iterables, repeat=1) --\\x3e product object\\n\\nCartesian product of input iterables.  Equivalent to nested for-loops.\\n\\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\\nThe leftmost iterators are in the outermost for-loop, so the output tuples\\ncycle in a manner similar to an odometer (with the rightmost element changing\\non every iteration).\\n\\nTo compute the product of an iterable with itself, specify the number\\nof repetitions with the optional repeat keyword argument. For example,\\nproduct(A, repeat=4) means the same as product(A, A, A, A).\\n\\nproduct('ab', range(3)) --\\x3e ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\\nproduct((0,1), (0,1), (0,1)) --\\x3e (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...\",tp$new(t,i){let[r]=Sk.abstr.copyKeywordsToNamedArgs(\"product\",[\"repeat\"],[],i,[new Sk.builtin.int_(1)]);if(r=Sk.misceval.asIndexSized(r,Sk.builtin.OverFlowError),r<0)throw new Sk.builtin.ValueError(\"repeat argument cannot be negative\");const s=[];for(let e=0;e<t.length;e++)s.push(Sk.misceval.arrayFromIterable(t[e]));const n=[].concat(...Array(r).fill(s));if(this===e.product.prototype)return new e.product(n);{const t=new this.constructor;return e.product.call(t,n),t}}}}),e.repeat=Sk.abstr.buildIteratorClass(\"itertools.repeat\",{constructor:function repeat(t,e){this.object=t,this.times=e,void 0===e&&(this.tp$iternext=()=>this.object)},iternext(t){return this.times-- >0?this.object:void 0},slots:{tp$doc:\"repeat(object [,times]) -> create an iterator which returns the object\\nfor the specified number of times.  If not specified, returns the object\\nendlessly.\",tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"repeat\",[\"object\",\"times\"],t,i,[null]),s=null!==s?Sk.misceval.asIndexSized(s,Sk.builtin.OverFlowError):void 0,this===e.repeat.prototype)return new e.repeat(r,s);{const t=new this.constructor;return e.repeat.call(t,r,s),t}},$r(){const t=Sk.misceval.objectRepr(this.object),e=void 0===this.times?\"\":\", \"+(this.times>=0?this.times:0);return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+e+\")\")}},methods:{__lenght_hint__:{$meth(){if(void 0===this.times)throw new Sk.builtin.TypeError(\"len() of unsized object\");return new Sk.builtin.int_(this.times)},$flags:{NoArgs:!0},$textsig:null}}}),e.starmap=Sk.abstr.buildIteratorClass(\"itertools.starmap\",{constructor:function starmap(t,e){this.func=t,this.iter=e},iternext(t){const e=this.iter.tp$iternext();if(void 0===e)return;const i=Sk.misceval.arrayFromIterable(e);return Sk.misceval.callsimArray(this.func,i)},slots:{tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"starmap\",[\"func\",\"iterable\"],t,i,[]),s=Sk.abstr.iter(s),r=Sk.builtin.checkNone(r)?Sk.builtin.bool:r,this===e.starmap.prototype)return new e.starmap(r,s);{const t=new this.constructor;return e.starmap.call(t,r,s),t}}}}),e.takewhile=Sk.abstr.buildIteratorClass(\"itertools.takewhile\",{constructor:function takewhile(t,e){this.predicate=t,this.iter=e},iternext(){const t=this.iter.tp$iternext();if(void 0!==t){const e=Sk.misceval.callsimArray(this.predicate,[t]);if(Sk.misceval.isTrue(e))return t;this.tp$iternext=()=>{}}},slots:{tp$doc:\"takewhile(predicate, iterable) --\\x3e takewhile object\\n\\nReturn successive entries from an iterable as long as the \\npredicate evaluates to true for each entry.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"takewhile\",i),Sk.abstr.checkArgsLen(\"takewhile\",t,2,2);const r=t[0],s=Sk.abstr.iter(t[1]);if(this===e.takewhile.prototype)return new e.takewhile(r,s);{const t=new this.constructor;return e.takewhile.call(t,r,s),t}}}}),e.tee=new Sk.builtin.func((function(){throw new Sk.builtin.NotImplementedError(\"tee is not yet implemented in Skulpt\")})),e.zip_longest=Sk.abstr.buildIteratorClass(\"itertools.zip_longest\",{constructor:function zip_longest(t,e){this.iters=t,this.fillvalue=e,this.active=this.iters.length},iternext(t){if(!this.active)return;let i;const r=[];for(let s=0;s<this.iters.length;s++){if(i=this.iters[s].tp$iternext(),void 0===i){if(this.active--,!this.active)return;this.iters[s]=new e.repeat(this.fillvalue),i=this.fillvalue}r.push(i)}return new Sk.builtin.tuple(r)},slots:{tp$doc:\"zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --\\x3e zip_longest object\\n\\nReturn a zip_longest object whose .__next__() method returns a tuple where\\nthe i-th element comes from the i-th iterable argument.  The .__next__()\\nmethod continues until the longest iterable in the argument sequence\\nis exhausted and then it raises StopIteration.  When the shorter iterables\\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\\ndefaults to None or can be specified by a keyword argument.\\n\",tp$new(t,i){const[r]=Sk.abstr.copyKeywordsToNamedArgs(\"zip_longest\",[\"fillvalue\"],[],i,[Sk.builtin.none.none$]),s=[];for(let e=0;e<t.length;e++)s.push(Sk.abstr.iter(t[e]));if(this===e.zip_longest.prototype)return new e.zip_longest(s,r);{const t=new this.constructor;return e.zip_longest.call(t,s,r),t}}}}),e.__doc__=new Sk.builtin.str(\"An implementation of the python itertools module in Skulpt\"),e.__package__=new Sk.builtin.str(\"\"),e};","src/lib/json/__init__.js":"var $builtinmodule=function(t){\"use strict\";var e={},dumps_f=function(t){Sk.builtin.pyCheckArgs(\"dumps\",arguments,1,1/0,!0,!1);var e,n,i,u=Array.prototype.slice.call(arguments,1),f=new Sk.builtins.dict(t),a=!1;return e={ascii:!0,separators:{item_separator:\", \",key_separator:\": \"}},f=Sk.ffi.remapToJs(f),n=Sk.ffi.remapToJs(u[0]),\"boolean\"==typeof f.ensure_ascii&&!1===f.ensure_ascii&&(e.ascii=!1),\"boolean\"==typeof f.sort_keys&&f.sort_keys&&(a=!0),a||(e.cmp=function(t,e){return 0}),\"object\"==typeof f.separators&&2==f.separators.length&&(e.separators.item_separator=f.separators[0],e.separators.key_separator=f.separators[1]),f.indent&&(e.space=f.indent),f.default,i=stringify(n,e),new Sk.builtin.str(i)};dumps_f.co_kwargs=!0,e.dumps=new Sk.builtin.func(dumps_f);var loads_f=function(t){Sk.builtin.pyCheckArgs(\"loads\",arguments,1,1/0,!0,!1);var e,n,i=Array.prototype.slice.call(arguments,1),u=new Sk.builtins.dict(t);return u=Sk.ffi.remapToJs(u),e=i[0].v,n=JSON.parse(e),Sk.ffi.remapToPy(n)};return loads_f.co_kwargs=!0,e.loads=new Sk.builtin.func(loads_f),e};!function r(t,e,n){function o(u,f){if(!e[u]){if(!t[u]){var a=\"function\"==typeof require&&require;if(!f&&a)return a(u,!0);if(i)return i(u,!0);var s=new Error(\"Cannot find module '\"+u+\"'\");throw s.code=\"MODULE_NOT_FOUND\",s}var c=e[u]={exports:{}};t[u][0].call(c.exports,(function(e){return o(t[u][1][e]||e)}),c,c.exports,r,t,e,n)}return e[u].exports}for(var i=\"function\"==typeof require&&require,u=0;u<n.length;u++)o(n[u]);return o}({1:[function(t,e,n){var i=\"undefined\"!=typeof JSON?JSON:t(\"jsonify\");e.exports=function(t,e){e||(e={}),\"function\"==typeof e&&(e={cmp:e});var n,a=e.cmp&&(n=e.cmp,function(t){return function(e,i){var u={key:e,value:t[e]},f={key:i,value:t[i]};return n(u,f)}});return function stringify(t){if(\"object\"!=typeof t||null===t)return i.stringify(t);if(u(t)){for(var e=[],n=0;n<t.length;n++)e.push(stringify(t[n]));return\"[\"+e.join(\",\")+\"]\"}var s=f(t).sort(a&&a(t));for(e=[],n=0;n<s.length;n++){var c=s[n];e.push(stringify(c)+\":\"+stringify(t[c]))}return\"{\"+e.join(\",\")+\"}\"}(t)};var u=Array.isArray||function(t){return\"[object Array]\"==={}.toString.call(t)},f=Object.keys||function(t){var e=Object.prototype.hasOwnProperty||function(){return!0},n=[];for(var i in t)e.call(t,i)&&n.push(i);return n}},{jsonify:2}],2:[function(t,e,n){n.parse=t(\"./lib/parse\"),n.stringify=t(\"./lib/stringify\")},{\"./lib/parse\":3,\"./lib/stringify\":4}],3:[function(t,e,n){var i,u,f,a,s={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},error=function(t){throw{name:\"SyntaxError\",message:t,at:i,text:f}},next=function(t){return t&&t!==u&&error(\"Expected '\"+t+\"' instead of '\"+u+\"'\"),u=f.charAt(i),i+=1,u},number=function(){var t,e=\"\";for(\"-\"===u&&(e=\"-\",next(\"-\"));u>=\"0\"&&u<=\"9\";)e+=u,next();if(\".\"===u)for(e+=\".\";next()&&u>=\"0\"&&u<=\"9\";)e+=u;if(\"e\"===u||\"E\"===u)for(e+=u,next(),\"-\"!==u&&\"+\"!==u||(e+=u,next());u>=\"0\"&&u<=\"9\";)e+=u,next();if(t=+e,isFinite(t))return t;error(\"Bad number\")},string=function(){var t,e,n,i=\"\";if('\"'===u)for(;next();){if('\"'===u)return next(),i;if(\"\\\\\"===u)if(next(),\"u\"===u){for(n=0,e=0;e<4&&(t=parseInt(next(),16),isFinite(t));e+=1)n=16*n+t;i+=String.fromCharCode(n)}else{if(\"string\"!=typeof s[u])break;i+=s[u]}else i+=u}error(\"Bad string\")},white=function(){for(;u&&u<=\" \";)next()};a=function(){switch(white(),u){case\"{\":return function(){var t,e={};if(\"{\"===u){if(next(\"{\"),white(),\"}\"===u)return next(\"}\"),e;for(;u;){if(t=string(),white(),next(\":\"),Object.hasOwnProperty.call(e,t)&&error('Duplicate key \"'+t+'\"'),e[t]=a(),white(),\"}\"===u)return next(\"}\"),e;next(\",\"),white()}}error(\"Bad object\")}();case\"[\":return function(){var t=[];if(\"[\"===u){if(next(\"[\"),white(),\"]\"===u)return next(\"]\"),t;for(;u;){if(t.push(a()),white(),\"]\"===u)return next(\"]\"),t;next(\",\"),white()}}error(\"Bad array\")}();case'\"':return string();case\"-\":return number();default:return u>=\"0\"&&u<=\"9\"?number():function(){switch(u){case\"t\":return next(\"t\"),next(\"r\"),next(\"u\"),next(\"e\"),!0;case\"f\":return next(\"f\"),next(\"a\"),next(\"l\"),next(\"s\"),next(\"e\"),!1;case\"n\":return next(\"n\"),next(\"u\"),next(\"l\"),next(\"l\"),null}error(\"Unexpected '\"+u+\"'\")}()}},e.exports=function(t,e){var n;return f=t,i=0,u=\" \",n=a(),white(),u&&error(\"Syntax error\"),\"function\"==typeof e?function walk(t,n){var i,u,f=t[n];if(f&&\"object\"==typeof f)for(i in f)Object.prototype.hasOwnProperty.call(f,i)&&(void 0!==(u=walk(f,i))?f[i]=u:delete f[i]);return e.call(t,n,f)}({\"\":n},\"\"):n}},{}],4:[function(t,e,n){var i,u,f,a=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,s={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"};function quote(t){return a.lastIndex=0,a.test(t)?'\"'+t.replace(a,(function(t){var e=s[t];return\"string\"==typeof e?e:\"\\\\u\"+(\"0000\"+t.charCodeAt(0).toString(16)).slice(-4)}))+'\"':'\"'+t+'\"'}function str(t,e){var n,a,s,c,l,p=i,y=e[t];switch(y&&\"object\"==typeof y&&\"function\"==typeof y.toJSON&&(y=y.toJSON(t)),\"function\"==typeof f&&(y=f.call(e,t,y)),typeof y){case\"string\":return quote(y);case\"number\":return isFinite(y)?String(y):\"null\";case\"boolean\":case\"null\":return String(y);case\"object\":if(!y)return\"null\";if(i+=u,l=[],\"[object Array]\"===Object.prototype.toString.apply(y)){for(c=y.length,n=0;n<c;n+=1)l[n]=str(n,y)||\"null\";return s=0===l.length?\"[]\":i?\"[\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"]\":\"[\"+l.join(\",\")+\"]\",i=p,s}if(f&&\"object\"==typeof f)for(c=f.length,n=0;n<c;n+=1)\"string\"==typeof(a=f[n])&&(s=str(a,y))&&l.push(quote(a)+(i?\": \":\":\")+s);else for(a in y)Object.prototype.hasOwnProperty.call(y,a)&&(s=str(a,y))&&l.push(quote(a)+(i?\": \":\":\")+s);return s=0===l.length?\"{}\":i?\"{\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"}\":\"{\"+l.join(\",\")+\"}\",i=p,s}}e.exports=function(t,e,n){var a;if(i=\"\",u=\"\",\"number\"==typeof n)for(a=0;a<n;a+=1)u+=\" \";else\"string\"==typeof n&&(u=n);if(f=e,e&&\"function\"!=typeof e&&(\"object\"!=typeof e||\"number\"!=typeof e.length))throw new Error(\"JSON.stringify\");return str(\"\",{\"\":t})}},{}],5:[function(t,e,n){var i,u,f=e.exports={};function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}function runTimeout(t){if(i===setTimeout)return setTimeout(t,0);if((i===defaultSetTimout||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{return i(t,0)}catch(e){try{return i.call(null,t,0)}catch(e){return i.call(this,t,0)}}}!function(){try{i=\"function\"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){i=defaultSetTimout}try{u=\"function\"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){u=defaultClearTimeout}}();var a,s=[],c=!1,l=-1;function cleanUpNextTick(){c&&a&&(c=!1,a.length?s=a.concat(s):l=-1,s.length&&drainQueue())}function drainQueue(){if(!c){var t=runTimeout(cleanUpNextTick);c=!0;for(var e=s.length;e;){for(a=s,s=[];++l<e;)a&&a[l].run();l=-1,e=s.length}a=null,c=!1,function runClearTimeout(t){if(u===clearTimeout)return clearTimeout(t);if((u===defaultClearTimeout||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(t);try{return u(t)}catch(e){try{return u.call(null,t)}catch(e){return u.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];s.push(new Item(t,e)),1!==s.length||c||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},f.title=\"browser\",f.browser=!0,f.env={},f.argv=[],f.version=\"\",f.versions={},f.on=noop,f.addListener=noop,f.once=noop,f.off=noop,f.removeListener=noop,f.removeAllListeners=noop,f.emit=noop,f.prependListener=noop,f.prependOnceListener=noop,f.listeners=function(t){return[]},f.binding=function(t){throw new Error(\"process.binding is not supported\")},f.cwd=function(){return\"/\"},f.chdir=function(t){throw new Error(\"process.chdir is not supported\")},f.umask=function(){return 0}},{}],6:[function(t,e,n){(function(n){var i=t(\"json-stable-stringify\");n.browser?window.stringify=i:e.exports=i}).call(this,t(\"_process\"))},{_process:5,\"json-stable-stringify\":1}]},{},[6]);","src/lib/json/stringify.js":"!function r(t,e,n){function o(u,f){if(!e[u]){if(!t[u]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(u,!0);if(i)return i(u,!0);var a=new Error(\"Cannot find module '\"+u+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var s=e[u]={exports:{}};t[u][0].call(s.exports,(function(e){return o(t[u][1][e]||e)}),s,s.exports,r,t,e,n)}return e[u].exports}for(var i=\"function\"==typeof require&&require,u=0;u<n.length;u++)o(n[u]);return o}({1:[function(t,e,n){var i=\"undefined\"!=typeof JSON?JSON:t(\"jsonify\");e.exports=function(t,e){e||(e={}),\"function\"==typeof e&&(e={cmp:e});var n,c=e.cmp&&(n=e.cmp,function(t){return function(e,i){var u={key:e,value:t[e]},f={key:i,value:t[i]};return n(u,f)}});return function stringify(t){if(\"object\"!=typeof t||null===t)return i.stringify(t);if(u(t)){for(var e=[],n=0;n<t.length;n++)e.push(stringify(t[n]));return\"[\"+e.join(\",\")+\"]\"}var a=f(t).sort(c&&c(t));for(e=[],n=0;n<a.length;n++){var s=a[n];e.push(stringify(s)+\":\"+stringify(t[s]))}return\"{\"+e.join(\",\")+\"}\"}(t)};var u=Array.isArray||function(t){return\"[object Array]\"==={}.toString.call(t)},f=Object.keys||function(t){var e=Object.prototype.hasOwnProperty||function(){return!0},n=[];for(var i in t)e.call(t,i)&&n.push(i);return n}},{jsonify:2}],2:[function(t,e,n){n.parse=t(\"./lib/parse\"),n.stringify=t(\"./lib/stringify\")},{\"./lib/parse\":3,\"./lib/stringify\":4}],3:[function(t,e,n){var i,u,f,c,a={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},error=function(t){throw{name:\"SyntaxError\",message:t,at:i,text:f}},next=function(t){return t&&t!==u&&error(\"Expected '\"+t+\"' instead of '\"+u+\"'\"),u=f.charAt(i),i+=1,u},number=function(){var t,e=\"\";for(\"-\"===u&&(e=\"-\",next(\"-\"));u>=\"0\"&&u<=\"9\";)e+=u,next();if(\".\"===u)for(e+=\".\";next()&&u>=\"0\"&&u<=\"9\";)e+=u;if(\"e\"===u||\"E\"===u)for(e+=u,next(),\"-\"!==u&&\"+\"!==u||(e+=u,next());u>=\"0\"&&u<=\"9\";)e+=u,next();if(t=+e,isFinite(t))return t;error(\"Bad number\")},string=function(){var t,e,n,i=\"\";if('\"'===u)for(;next();){if('\"'===u)return next(),i;if(\"\\\\\"===u)if(next(),\"u\"===u){for(n=0,e=0;e<4&&(t=parseInt(next(),16),isFinite(t));e+=1)n=16*n+t;i+=String.fromCharCode(n)}else{if(\"string\"!=typeof a[u])break;i+=a[u]}else i+=u}error(\"Bad string\")},white=function(){for(;u&&u<=\" \";)next()};c=function(){switch(white(),u){case\"{\":return function(){var t,e={};if(\"{\"===u){if(next(\"{\"),white(),\"}\"===u)return next(\"}\"),e;for(;u;){if(t=string(),white(),next(\":\"),Object.hasOwnProperty.call(e,t)&&error('Duplicate key \"'+t+'\"'),e[t]=c(),white(),\"}\"===u)return next(\"}\"),e;next(\",\"),white()}}error(\"Bad object\")}();case\"[\":return function(){var t=[];if(\"[\"===u){if(next(\"[\"),white(),\"]\"===u)return next(\"]\"),t;for(;u;){if(t.push(c()),white(),\"]\"===u)return next(\"]\"),t;next(\",\"),white()}}error(\"Bad array\")}();case'\"':return string();case\"-\":return number();default:return u>=\"0\"&&u<=\"9\"?number():function(){switch(u){case\"t\":return next(\"t\"),next(\"r\"),next(\"u\"),next(\"e\"),!0;case\"f\":return next(\"f\"),next(\"a\"),next(\"l\"),next(\"s\"),next(\"e\"),!1;case\"n\":return next(\"n\"),next(\"u\"),next(\"l\"),next(\"l\"),null}error(\"Unexpected '\"+u+\"'\")}()}},e.exports=function(t,e){var n;return f=t,i=0,u=\" \",n=c(),white(),u&&error(\"Syntax error\"),\"function\"==typeof e?function walk(t,n){var i,u,f=t[n];if(f&&\"object\"==typeof f)for(i in f)Object.prototype.hasOwnProperty.call(f,i)&&(void 0!==(u=walk(f,i))?f[i]=u:delete f[i]);return e.call(t,n,f)}({\"\":n},\"\"):n}},{}],4:[function(t,e,n){var i,u,f,c=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,a={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"};function quote(t){return c.lastIndex=0,c.test(t)?'\"'+t.replace(c,(function(t){var e=a[t];return\"string\"==typeof e?e:\"\\\\u\"+(\"0000\"+t.charCodeAt(0).toString(16)).slice(-4)}))+'\"':'\"'+t+'\"'}function str(t,e){var n,c,a,s,l,p=i,y=e[t];switch(y&&\"object\"==typeof y&&\"function\"==typeof y.toJSON&&(y=y.toJSON(t)),\"function\"==typeof f&&(y=f.call(e,t,y)),typeof y){case\"string\":return quote(y);case\"number\":return isFinite(y)?String(y):\"null\";case\"boolean\":case\"null\":return String(y);case\"object\":if(!y)return\"null\";if(i+=u,l=[],\"[object Array]\"===Object.prototype.toString.apply(y)){for(s=y.length,n=0;n<s;n+=1)l[n]=str(n,y)||\"null\";return a=0===l.length?\"[]\":i?\"[\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"]\":\"[\"+l.join(\",\")+\"]\",i=p,a}if(f&&\"object\"==typeof f)for(s=f.length,n=0;n<s;n+=1)\"string\"==typeof(c=f[n])&&(a=str(c,y))&&l.push(quote(c)+(i?\": \":\":\")+a);else for(c in y)Object.prototype.hasOwnProperty.call(y,c)&&(a=str(c,y))&&l.push(quote(c)+(i?\": \":\":\")+a);return a=0===l.length?\"{}\":i?\"{\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"}\":\"{\"+l.join(\",\")+\"}\",i=p,a}}e.exports=function(t,e,n){var c;if(i=\"\",u=\"\",\"number\"==typeof n)for(c=0;c<n;c+=1)u+=\" \";else\"string\"==typeof n&&(u=n);if(f=e,e&&\"function\"!=typeof e&&(\"object\"!=typeof e||\"number\"!=typeof e.length))throw new Error(\"JSON.stringify\");return str(\"\",{\"\":t})}},{}],5:[function(t,e,n){var i,u,f=e.exports={};function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}function runTimeout(t){if(i===setTimeout)return setTimeout(t,0);if((i===defaultSetTimout||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{return i(t,0)}catch(e){try{return i.call(null,t,0)}catch(e){return i.call(this,t,0)}}}!function(){try{i=\"function\"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){i=defaultSetTimout}try{u=\"function\"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){u=defaultClearTimeout}}();var c,a=[],s=!1,l=-1;function cleanUpNextTick(){s&&c&&(s=!1,c.length?a=c.concat(a):l=-1,a.length&&drainQueue())}function drainQueue(){if(!s){var t=runTimeout(cleanUpNextTick);s=!0;for(var e=a.length;e;){for(c=a,a=[];++l<e;)c&&c[l].run();l=-1,e=a.length}c=null,s=!1,function runClearTimeout(t){if(u===clearTimeout)return clearTimeout(t);if((u===defaultClearTimeout||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(t);try{return u(t)}catch(e){try{return u.call(null,t)}catch(e){return u.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];a.push(new Item(t,e)),1!==a.length||s||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},f.title=\"browser\",f.browser=!0,f.env={},f.argv=[],f.version=\"\",f.versions={},f.on=noop,f.addListener=noop,f.once=noop,f.off=noop,f.removeListener=noop,f.removeAllListeners=noop,f.emit=noop,f.prependListener=noop,f.prependOnceListener=noop,f.listeners=function(t){return[]},f.binding=function(t){throw new Error(\"process.binding is not supported\")},f.cwd=function(){return\"/\"},f.chdir=function(t){throw new Error(\"process.chdir is not supported\")},f.umask=function(){return 0}},{}],6:[function(t,e,n){(function(n){var i=t(\"json-stable-stringify\");n.browser?window.stringify=i:e.exports=i}).call(this,t(\"_process\"))},{_process:5,\"json-stable-stringify\":1}]},{},[6]);","src/lib/keyword.js":"function $builtinmodule(){const{ffi:{remapToPy:t},builtin:{frozenset:e,str:s}}=Sk,i=new s(\"keyword\"),n=t([\"iskeyword\",\"issoftkeyword\",\"kwlist\",\"softkwlist\"]),o=t([\"False\",\"None\",\"True\",\"and\",\"as\",\"assert\",\"async\",\"await\",\"break\",\"class\",\"continue\",\"def\",\"del\",\"elif\",\"else\",\"except\",\"finally\",\"for\",\"from\",\"global\",\"if\",\"import\",\"in\",\"is\",\"lambda\",\"nonlocal\",\"not\",\"or\",\"pass\",\"raise\",\"return\",\"try\",\"while\",\"with\",\"yield\"]),a=t([\"_\",\"case\",\"match\"]);return{__name__:i,__all__:n,kwlist:o,softkwlist:a,iskeyword:new e(o).tp$getattr(s.$contains),issoftkeyword:new e(a).tp$getattr(s.$contains)}}","src/lib/math.js":"const $builtinmodule=function(e){const t={pi:new Sk.builtin.float_(Math.PI),e:new Sk.builtin.float_(Math.E),tau:new Sk.builtin.float_(2*Math.PI),nan:new Sk.builtin.float_(NaN),inf:new Sk.builtin.float_(1/0)};const get_sign=function(e){return e=e?e<0?-1:1:1/e<0?-1:1};function factorial(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=Sk.builtin.asnum$(e);if((e=Math.floor(t))!=t)throw new Sk.builtin.ValueError(\"factorial() only accepts integral values\");if(e<0)throw new Sk.builtin.ValueError(\"factorial() not defined for negative numbers\");let n=1;for(let i=2;i<=e&&i<=18;i++)n*=i;if(e<=18)return new Sk.builtin.int_(n);n=JSBI.BigInt(n);for(let i=19;i<=e;i++)n=JSBI.multiply(n,JSBI.BigInt(i));return new Sk.builtin.int_(n)}function _gcd_internal(e,t){let n;return\"number\"==typeof e&&\"number\"==typeof t?(n=function _gcd(e,t){return 0==t?e:_gcd(t,e%t)}(e=Math.abs(e),t=Math.abs(t)),n=n<0?-n:n):(n=function _biggcd(e,t){return JSBI.equal(t,JSBI.__ZERO)?e:_biggcd(t,JSBI.remainder(e,t))}(e=JSBI.BigInt(e),t=JSBI.BigInt(t)),JSBI.lessThan(n,JSBI.__ZERO)&&(n=JSBI.multiply(n,JSBI.BigInt(-1)))),n}return Sk.abstr.setUpModuleMethods(\"math\",t,{acos:{$meth:function acos(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.acos(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc cosine (measured in radians) of x.\"},acosh:{$meth:function acosh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=(e=Sk.builtin.asnum$(e))+Math.sqrt(e*e-1);return new Sk.builtin.float_(Math.log(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic cosine of x.\"},asin:{$meth:function asin(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.asin(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc sine (measured in radians) of x.\"},asinh:{$meth:function asinh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=(e=Sk.builtin.asnum$(e))+Math.sqrt(e*e+1);return new Sk.builtin.float_(Math.log(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic sine of x.\"},atan:{$meth:function atan(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.atan(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc tangent (measured in radians) of x.\"},atan2:{$meth:function atan2(e,t){return Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(t)),new Sk.builtin.float_(Math.atan2(Sk.builtin.asnum$(e),Sk.builtin.asnum$(t)))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, y, x, /)\",$doc:\"Return the arc tangent (measured in radians) of y/x.\\n\\nUnlike atan(y/x), the signs of both x and y are considered.\"},atanh:{$meth:function atanh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=(1+(e=Sk.builtin.asnum$(e)))/(1-e);return new Sk.builtin.float_(Math.log(t)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic tangent of x.\"},ceil:{$meth:function ceil(e){Sk.builtin.pyCheckType(\"\",\"real number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);return Sk.__future__.ceil_floor_int?new Sk.builtin.int_(Math.ceil(t)):new Sk.builtin.float_(Math.ceil(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the ceiling of x as an Integral.\\n\\nThis is the smallest integer >= x.\"},comb:{$meth:function comb(e,t){let n=Sk.misceval.asIndexOrThrow(e),i=Sk.misceval.asIndexOrThrow(t);if(n<0)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");if(i<0)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(i>e)return new Sk.builtin.int_(0);e=new Sk.builtin.int_(n),t=new Sk.builtin.int_(i);let r=Sk.ffi.remapToJs(e.nb$subtract(t));if(r<i&&(i=r),0===i)return new Sk.builtin.int_(1);if(i>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"min(n - k, k) must not exceed \"+Number.MAX_SAFE_INTEGER);const u=new Sk.builtin.int_(1);let l=e;for(let o=1;o<i;o++)e=e.nb$subtract(u),r=new Sk.builtin.int_(o+1),l=l.nb$multiply(e),l=l.nb$floor_divide(r);return l},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.\"},copysign:{$meth:function copysign(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));const n=Sk.builtin.asnum$(t),i=Sk.builtin.asnum$(e),r=get_sign(i)*get_sign(n);return new Sk.builtin.float_(i*r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return a float with the magnitude (absolute value) of x but the sign of y.\\n\\nOn platforms that support signed zeros, copysign(1.0, -0.0)\\nreturns -1.0.\\n\"},cos:{$meth:function cos(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.cos(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the cosine of x (measured in radians).\"},cosh:{$meth:function cosh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e);const t=Math.E,n=Math.pow(t,e),i=(n+1/n)/2;return new Sk.builtin.float_(i)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic cosine of x.\"},degrees:{$meth:function degrees(e){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e));const t=180/Math.PI*Sk.builtin.asnum$(e);return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from radians to degrees.\"},erf:{$meth:function erf(e){throw new Sk.builtin.NotImplementedError(\"math.erf() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Error function at x.\"},erfc:{$meth:function erfc(e){throw new Sk.builtin.NotImplementedError(\"math.erfc() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Complementary error function at x.\"},exp:{$meth:function exp(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=e.v;if(\"number\"!=typeof t&&(t=e.nb$float().v),t==1/0||t==-1/0||isNaN(t))return new Sk.builtin.float_(Math.exp(t));const n=Math.exp(t);if(!isFinite(n))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(n)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return e raised to the power of x.\"},expm1:{$meth:function expm1(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);if(Math.abs(t)<.7){const e=Math.exp(t);if(1==e)return new Sk.builtin.float_(t);{const n=(e-1)*t/Math.log(e);return new Sk.builtin.float_(n)}}{const e=Math.exp(t)-1;return new Sk.builtin.float_(e)}},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return exp(x)-1.\\n\\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.\"},fabs:{$meth:function fabs(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=e.v;return JSBI.__isBigInt(t)&&(t=e.nb$float().v),t=Math.abs(t),new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the absolute value of the float x.\"},factorial:{$meth:factorial,$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Find x!.\\n\\nRaise a ValueError if x is negative or non-integral.\"},floor:{$meth:function floor(e){return Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.__future__.ceil_floor_int?new Sk.builtin.int_(Math.floor(Sk.builtin.asnum$(e))):new Sk.builtin.float_(Math.floor(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the floor of x as an Integral.\\n\\nThis is the largest integer <= x.\"},fmod:{$meth:function fmod(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if(\"number\"!=typeof n&&(n=e.nb$float().v),\"number\"!=typeof i&&(i=t.nb$float().v),(i==1/0||i==-1/0)&&isFinite(n))return new Sk.builtin.float_(n);const r=n%i;if(isNaN(r)&&!isNaN(n)&&!isNaN(i))throw new Sk.builtin.ValueError(\"math domain error\");return new Sk.builtin.float_(r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return fmod(x, y), according to platform C.\\n\\nx % y may differ.\"},frexp:{$meth:function frexp(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e),n=[t,0];if(0!==t&&Number.isFinite(t)){const e=Math.abs(t);let i=Math.max(-1023,Math.floor(Math.log2(e))+1),r=e*Math.pow(2,-i);for(;r<.5;)r*=2,i--;for(;r>=1;)r*=.5,i++;t<0&&(r=-r),n[0]=r,n[1]=i}return n[0]=new Sk.builtin.float_(n[0]),n[1]=new Sk.builtin.int_(n[1]),new Sk.builtin.tuple(n)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the mantissa and exponent of x, as pair (m, e).\\n\\nm is a float and e is an int, such that x = m * 2.**e.\\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.\"},fsum:{$meth:function fsum(e){if(!Sk.builtin.checkIterable(e))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(e)+\"' object is not iterable\");let t,n,i,r=[];for(let l=(e=Sk.abstr.iter(e)).tp$iternext();void 0!==l;l=e.tp$iternext()){Sk.builtin.pyCheckType(\"\",\"real number\",Sk.builtin.checkNumber(l)),t=0;let e=l.v;\"number\"!=typeof e&&(e=l.nb$float().v),l=e;for(let u=0,o=r.length;u<o;u++){let e=r[u];if(Math.abs(l)<Math.abs(e)){let t=l;l=e,e=t}n=l+e,i=e-(n-l),i&&(r[t]=i,t++),l=n}r=r.slice(0,t).concat([l])}const u=r.reduce((function(e,t){return e+t}),0);return new Sk.builtin.float_(u)},$flags:{OneArg:!0},$textsig:\"($module, seq, /)\",$doc:\"Return an accurate floating point sum of values in the iterable seq.\\n\\nAssumes IEEE-754 floating point arithmetic.\"},gamma:{$meth:function gamma(e){throw new Sk.builtin.NotImplementedError(\"math.gamma() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Gamma function at x.\"},gcd:{$meth:function gcd(e,t){Sk.builtin.pyCheckType(\"a\",\"integer\",Sk.builtin.checkInt(e)),Sk.builtin.pyCheckType(\"b\",\"integer\",Sk.builtin.checkInt(t));const n=_gcd_internal(Sk.builtin.asnum$(e),Sk.builtin.asnum$(t));return\"number\"==typeof n?new Sk.builtin.int_(n):new Sk.builtin.int_(n.toString())},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"greatest common divisor of x and y\"},hypot:{$meth:function hypot(e,t){return Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t)),e=Sk.builtin.asnum$(e),t=Sk.builtin.asnum$(t),new Sk.builtin.float_(Math.sqrt(e*e+t*t))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return the Euclidean distance, sqrt(x*x + y*y).\"},isclose:{$meth:function isclose(e,t){Sk.abstr.checkArgsLen(\"isclose\",e,2,2);const n=Sk.abstr.copyKeywordsToNamedArgs(\"isclose\",[\"rel_tol\",\"abs_tol\"],[],t,[new Sk.builtin.float_(1e-9),new Sk.builtin.float_(0)]),i=e[0],r=e[1],u=n[0],l=n[1];Sk.builtin.pyCheckType(\"a\",\"number\",Sk.builtin.checkNumber(i)),Sk.builtin.pyCheckType(\"b\",\"number\",Sk.builtin.checkNumber(r)),Sk.builtin.pyCheckType(\"rel_tol\",\"number\",Sk.builtin.checkNumber(u)),Sk.builtin.pyCheckType(\"abs_tol\",\"number\",Sk.builtin.checkNumber(l));const o=Sk.builtin.asnum$(i),a=Sk.builtin.asnum$(r),s=Sk.builtin.asnum$(u),b=Sk.builtin.asnum$(l);if(s<0||b<0)throw new Sk.builtin.ValueError(\"tolerances must be non-negative\");if(o==a)return Sk.builtin.bool.true$;if(o==1/0||o==-1/0||a==1/0||a==-1/0)return Sk.builtin.bool.false$;const c=Math.abs(a-o),m=c<=Math.abs(s*a)||c<=Math.abs(s*o)||c<=b;return new Sk.builtin.bool(m)},$flags:{FastCall:!0},$textsig:\"($module, /, a, b, *, rel_tol=1e-09, abs_tol=0.0)\",$doc:'Determine whether two floating point numbers are close in value.\\n\\n  rel_tol\\n    maximum difference for being considered \"close\", relative to the\\n    magnitude of the input values\\n  abs_tol\\n    maximum difference for being considered \"close\", regardless of the\\n    magnitude of the input values\\n\\nReturn True if a is close in value to b, and False otherwise.\\n\\nFor the values to be considered close, the difference between them\\nmust be smaller than at least one of the tolerances.\\n\\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\\nis, NaN is not close to anything, even itself.  inf and -inf are\\nonly close to themselves.'},isfinite:{$meth:function isfinite(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);return Sk.builtin.checkInt(e)||isFinite(t)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is neither an infinity nor a NaN, and False otherwise.\"},isinf:{$meth:function isinf(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);return Sk.builtin.checkInt(e)||isFinite(t)||isNaN(t)?Sk.builtin.bool.false$:Sk.builtin.bool.true$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a positive or negative infinity, and False otherwise.\"},isnan:{$meth:function isnan(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);return isNaN(t)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a NaN (not a number), and False otherwise.\"},isqrt:{$meth:function isqrt(e){let t=Sk.misceval.asIndexOrThrow(e);if(t<0)throw new Sk.builtin.ValueError(\"isqrt() argument must be nonnegative\");return 0==t?new Sk.builtin.int_(0):\"number\"==typeof t?new Sk.builtin.int_(Math.floor(Math.sqrt(t))):function bigint_isqrt(e){let t=e.toString(2).length;t=Math.floor((t-1)/2);let n=t.toString(2).length;const i=JSBI.BigInt(1),r=JSBI.BigInt(2),u=JSBI.BigInt(t),l=JSBI.multiply(r,u);let o=i,a=JSBI.BigInt(0);for(;n>0;){n--;let t=a;a=JSBI.signedRightShift(u,JSBI.BigInt(n));const r=JSBI.subtract(JSBI.subtract(a,t),i),s=JSBI.leftShift(o,r),b=JSBI.add(JSBI.subtract(JSBI.subtract(l,t),a),i),c=JSBI.signedRightShift(e,b);o=JSBI.add(s,JSBI.divide(c,o))}let s=o;return JSBI.greaterThan(JSBI.multiply(s,s),e)&&(s=JSBI.subtract(s,i)),JSBI.lessThanOrEqual(s,JSBI.BigInt(Number.MAX_SAFE_INTEGER))&&(s=Number(s)),new Sk.builtin.int_(s)}(t)},$flags:{OneArg:!0},$textsig:\"($module, n, /)\",$doc:\"Return the integer part of the square root of the input.\"},lcm:{$meth:function lcm(...e){function abs(e){return\"number\"==typeof e?new Sk.builtin.int_(Math.abs(e)):JSBI.lessThan(e,JSBI.__ZERO)?new Sk.builtin.int_(JSBI.unaryMinus(e)):new Sk.builtin.int_(e)}const t=e.length;if(0===t)return new Sk.builtin.int_(1);let n;for(n=0;n<t;++n)e[n]=Sk.misceval.asIndexOrThrow(e[n]);let i,r=e[0];if(1===t)return abs(r);for(n=1;n<t;++n){if(i=e[n],0===i)return new Sk.builtin.int_(0);if(\"number\"==typeof r&&\"number\"==typeof i){let e=r/_gcd_internal(r,i)*i;e=Math.abs(e),r=e>Number.MAX_SAFE_INTEGER?JSBI.BigInt(r):e}else r=JSBI.BigInt(r);\"number\"!=typeof r&&(i=JSBI.BigInt(i),r=JSBI.multiply(JSBI.divide(r,_gcd_internal(r,i)),i))}return abs(r)},$flags:{MinArgs:0},$textsig:\"($module, *integers, /)\",$doc:\"Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1.\"},ldexp:{$meth:function ldexp(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"i\",\"integer\",Sk.builtin.checkInt(t));let n=e.v;\"number\"!=typeof n&&(n=e.nb$float().v);const i=Sk.builtin.asnum$(t);if(n==1/0||n==-1/0||0==n||isNaN(n))return new Sk.builtin.float_(n);const r=n*Math.pow(2,i);if(!isFinite(r))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, i, /)\",$doc:\"Return x * (2**i).\\n\\nThis is essentially the inverse of frexp().\"},lgamma:{$meth:function lgamma(e){throw new Sk.builtin.NotImplementedError(\"math.lgamma() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Natural logarithm of absolute value of Gamma function at x.\"},log:{$meth:function log(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let n,i,r=Sk.builtin.asnum$(e);if(r<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(void 0===t?n=Math.E:(Sk.builtin.pyCheckType(\"base\",\"number\",Sk.builtin.checkNumber(t)),n=Sk.builtin.asnum$(t)),n<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(Sk.builtin.checkFloat(e)||r<Number.MAX_SAFE_INTEGER)i=Math.log(r)/Math.log(n);else{r=new Sk.builtin.str(e).$jsstr();const t=r.length,u=parseFloat(\"0.\"+r);i=(t*Math.log(10)+Math.log(u))/Math.log(n)}return new Sk.builtin.float_(i)},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:\"log(x, [base=e])\\nReturn the logarithm of x to the given base.\\n\\nIf the base not specified, returns the natural logarithm (base e) of x.\"},log10:{$meth:function log10(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t,n=Sk.builtin.asnum$(e);if(n<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(Sk.builtin.checkFloat(e)||n<Number.MAX_SAFE_INTEGER)t=Math.log10(n);else{n=new Sk.builtin.str(e).$jsstr();const i=n.length,r=parseFloat(\"0.\"+n);t=i+Math.log10(r)}return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 10 logarithm of x.\"},log1p:{$meth:function log1p(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=e.v;if(\"number\"!=typeof t&&(t=e.nb$float().v),t<=-1)throw new Sk.builtin.ValueError(\"math domain error\");if(0==t)return new Sk.builtin.float_(t);if(Math.abs(t)<Number.EPSILON/2)return new Sk.builtin.float_(t);if(-.5<=t&&t<=1){const e=1+t,n=Math.log(e)-(e-1-t)/e;return new Sk.builtin.float_(n)}{const e=Math.log(1+t);return new Sk.builtin.float_(e)}},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the natural logarithm of 1+x (base e).\\n\\nThe result is computed in a way which is accurate for x near zero.\"},log2:{$meth:function log2(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t,n=Sk.builtin.asnum$(e);if(n<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(Sk.builtin.checkFloat(e)||n<Number.MAX_SAFE_INTEGER)t=Math.log2(n);else{n=new Sk.builtin.str(e).$jsstr();const i=n.length,r=parseFloat(\"0.\"+n);t=i*Math.log2(10)+Math.log2(r)}return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 2 logarithm of x.\"},modf:{$meth:function modf(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=Sk.builtin.asnum$(e);if(!isFinite(t)){if(t==1/0)return new Sk.builtin.tuple([new Sk.builtin.float_(0),new Sk.builtin.float_(t)]);if(t==-1/0)return new Sk.builtin.tuple([new Sk.builtin.float_(-0),new Sk.builtin.float_(t)]);if(isNaN(t))return new Sk.builtin.tuple([new Sk.builtin.float_(t),new Sk.builtin.float_(t)])}const n=get_sign(t);t=Math.abs(t);const i=n*Math.floor(t),r=n*(t-Math.floor(t));return new Sk.builtin.tuple([new Sk.builtin.float_(r),new Sk.builtin.float_(i)])},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the fractional and integer parts of x.\\n\\nBoth results carry the sign of x and are floats.\"},perm:{$meth:function perm(e,t){if(void 0===t||Sk.builtin.checkNone(t))return factorial(e);if(e=Sk.misceval.asIndexOrThrow(e),t=Sk.misceval.asIndexOrThrow(t),e<0)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");if(t<0)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(t>e)return new Sk.builtin.int_(0);if(0===t)return new Sk.builtin.int_(1);if(t>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"k must not exceed \"+Number.MAX_SAFE_INTEGER);const n=new Sk.builtin.int_(1);let i=e=new Sk.builtin.int_(e);for(let r=1;r<t;r++)e=e.nb$subtract(n),i=i.nb$multiply(e);return i},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"'Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.'\"},prod:{$meth:function prod(e,t){Sk.abstr.checkArgsLen(\"prod\",e,1,1),e=Sk.abstr.copyKeywordsToNamedArgs(\"prod\",[null,\"start\"],e,t,[new Sk.builtin.int_(1)]);const n=Sk.abstr.iter(e[0]);let i,r=e[1];return i=r.constructor===Sk.builtin.int_?function fastProdInt(){return Sk.misceval.iterFor(n,(e=>{if(e.constructor!==Sk.builtin.int_)return e.constructor===Sk.builtin.float_?(r=r.nb$float().nb$multiply(e),new Sk.misceval.Break(\"float\")):(r=Sk.abstr.numberBinOp(r,e,\"Mult\"),new Sk.misceval.Break(\"slow\"));r=r.nb$multiply(e)}))}():r.constructor===Sk.builtin.float_?\"float\":\"slow\",Sk.misceval.chain(i,(e=>\"float\"===e?function fastProdFloat(){return Sk.misceval.iterFor(n,(e=>{if(e.constructor!==Sk.builtin.float_&&e.constructor!==Sk.builtin.int_)return r=Sk.abstr.numberBinOp(r,e,\"Mult\"),new Sk.misceval.Break(\"slow\");r=r.nb$multiply(e)}))}():e),(e=>{if(\"slow\"===e)return function slowProd(){return Sk.misceval.iterFor(n,(e=>{r=Sk.abstr.numberBinOp(r,e,\"Mult\")}))}()}),(()=>r))},$flags:{FastCall:!0},$textsig:\"($module, iterable, /, *, start=1)\",$doc:\"Calculate the product of all the elements in the input iterable. The default start value for the product is 1.\\n\\nWhen the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.\"},pow:{$meth:function pow(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if(\"number\"!=typeof n&&(n=e.nb$float().v),\"number\"!=typeof i&&(i=t.nb$float().v),0==n&&i<0)throw new Sk.builtin.ValueError(\"math domain error\");if(1==n)return new Sk.builtin.float_(1);if(Number.isFinite(n)&&Number.isFinite(i)&&n<0&&!Number.isInteger(i))throw new Sk.builtin.ValueError(\"math domain error\");if(-1==n&&(i==-1/0||i==1/0))return new Sk.builtin.float_(1);const r=Math.pow(n,i);if(!Number.isFinite(n)||!Number.isFinite(i))return new Sk.builtin.float_(r);if(r==1/0||r==-1/0)throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return x**y (x to the power of y).\"},radians:{$meth:function radians(e){Sk.builtin.pyCheckType(\"deg\",\"number\",Sk.builtin.checkNumber(e));const t=Math.PI/180*Sk.builtin.asnum$(e);return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from degrees to radians.\"},remainder:{$meth:function remainder(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if(\"number\"!=typeof n&&(n=e.nb$float().v),\"number\"!=typeof i&&(i=t.nb$float().v),isFinite(n)&&isFinite(i)){let e,t,r,u,l;if(0==i)throw new Sk.builtin.ValueError(\"math domain error\");if(e=Math.abs(n),t=Math.abs(i),u=e%t,r=t-u,u<r)l=u;else if(u>r)l=-r;else{if(u!=r)throw new Sk.builtin.AssertionError;l=u-.5*(e-u)%t*2}return new Sk.builtin.float_(get_sign(n)*l)}if(isNaN(n))return e;if(isNaN(i))return t;if(n==1/0||n==-1/0)throw new Sk.builtin.ValueError(\"math domain error\");if(i!=1/0&&i!=-1/0)throw new Sk.builtin.AssertionError;return new Sk.builtin.float_(n)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Difference between x and the closest integer multiple of y.\\n\\nReturn x - n*y where n*y is the closest integer multiple of y.\\nIn the case where x is exactly halfway between two multiples of\\ny, the nearest even value of n is used. The result is always exact.\"},sin:{$meth:function sin(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.sin(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the sine of x (measured in radians).\"},sinh:{$meth:function sinh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e);const t=Math.E,n=Math.pow(t,e),i=(n-1/n)/2;return new Sk.builtin.float_(i)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic sine of x.\"},sqrt:{$meth:function sqrt(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);if(t<0)throw new Sk.builtin.ValueError(\"math domain error\");return new Sk.builtin.float_(Math.sqrt(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the square root of x.\"},tan:{$meth:function tan(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.tan(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the tangent of x (measured in radians).\"},tanh:{$meth:function tanh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);if(0===t)return new Sk.builtin.float_(t);const n=Math.E,i=Math.pow(n,t),r=1/i,u=(i-r)/2/((i+r)/2);return new Sk.builtin.float_(u)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic tangent of x.\"},trunc:{$meth:function trunc(e){return Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.checkInt(e)?e:new Sk.builtin.int_(0|Sk.builtin.asnum$(e))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Truncates the Real x to the nearest Integral toward 0.\\n\\nUses the __trunc__ magic method.\"}}),t};","src/lib/operator.js":"function $builtinmodule(e){const{builtin:{str:t,tuple:a,list:r,int_:o,bool:n,TypeError:s,ValueError:i,none:{none$:m},NotImplemented:{NotImplemented$:d},abs:l,len:h,checkString:u,checkInt:c},abstr:{buildNativeClass:M,checkNoKwargs:b,checkArgsLen:g,checkOneArg:f,numberUnaryOp:p,numberBinOp:A,numberInplaceBinOp:k,objectGetItem:$,objectDelItem:_,objectSetItem:w,sequenceConcat:v,sequenceContains:x,sequenceGetCountOf:j,sequenceGetIndexOf:O,sequenceInPlaceConcat:I,typeName:S,lookupSpecial:y,gattr:q,setUpModuleMethods:R},misceval:{richCompareBool:B,asIndexOrThrow:N,chain:E,callsimArray:T,callsimOrSuspendArray:C,objectRepr:D},generic:{getAttr:G}}=Sk,L=[\"abs\",\"add\",\"and_\",\"concat\",\"contains\",\"delitem\",\"eq\",\"floordiv\",\"ge\",\"getitem\",\"gt\",\"iadd\",\"iand\",\"iconcat\",\"ifloordiv\",\"ilshift\",\"imatmul\",\"imod\",\"imul\",\"index\",\"inv\",\"invert\",\"ior\",\"ipow\",\"irshift\",\"isub\",\"itruediv\",\"ixor\",\"le\",\"lshift\",\"lt\",\"matmul\",\"mod\",\"mul\",\"ne\",\"neg\",\"not_\",\"or_\",\"pos\",\"pow\",\"rshift\",\"setitem\",\"sub\",\"truediv\",\"xor\"],F=[\"attrgetter\",\"countOf\",\"indexOf\",\"is_\",\"is_not\",\"itemgetter\",\"length_hint\",\"methodcaller\",\"truth\",...L].sort(),P={__name__:new t(\"operator\"),__doc__:new t(\"Operator interface.\\n\\nThis module exports a set of functions implemented in javascript corresponding\\nto the intrinsic operators of Python.  For example, operator.add(x, y)\\nis equivalent to the expression x+y.  The function names are those\\nused for special methods; variants without leading and trailing\\n'__' are also provided for convenience.\"),__all__:new r(F.map((e=>new t(e))))};P.itemgetter=M(\"operator.itemgetter\",{constructor:function itemgetter(e){this.items=e,this.oneitem=1===e.length,this.item=e[0],this.in$repr=!1},slots:{tp$getattr:G,tp$new:(e,t)=>(b(\"itemgetter\",t),g(\"itemgetter\",e,1),new P.itemgetter(e)),tp$call(e,t){f(\"itemgetter\",e,t);const r=e[0];return this.oneitem?$(r,this.item,!0):new a(this.items.map((e=>$(r,e))))},tp$doc:\"Return a callable object that fetches the given item(s) from its operand.\\n            After f = itemgetter(2), the call f(r) returns r[2].\\n            After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\",$r(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;const e=this.tp$name+\"(\"+this.items.map((e=>D(e))).join(\", \")+\")\";return this.in$repr=!1,e}}}),P.attrgetter=M(\"operator.attrgetter\",{constructor:function attrgetter(e){this.attrs=e,this.oneattr=1===e.length,this.attr=e[0],this.in$repr=!1},slots:{tp$getattr:G,tp$new(e,a){b(\"attrgetter\",a),g(\"attrgetter\",e,1);const r=[];for(let o=0;o<e.length;o++){const a=e[o];if(!u(a))throw new s(\"attribute name must be a string\");const n=a.toString();n.includes(\".\")?r.push(n.split(\".\").map((e=>new t(e)))):r.push([a])}return new P.attrgetter(r)},tp$call(e,t){f(\"attrgetter\",e,t);const r=e[0];if(this.oneattr)return this.attr.reduce(((e,t)=>q(e,t)),r);const o=this.attrs.map((e=>e.reduce(((e,t)=>q(e,t)),r)));return new a(o)},tp$doc:\"attrgetter(attr, ...) --\\x3e attrgetter object\\n\\nReturn a callable object that fetches the given attribute(s) from its operand.\\nAfter f = attrgetter('name'), the call f(r) returns r.name.\\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\\n(r.name.first, r.name.last).\",$r(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;const e=this.tp$name+\"(\"+this.items.map((e=>D(e))).join(\", \")+\")\";return this.in$repr=!1,e}}}),P.methodcaller=M(\"operator.methodcaller\",{constructor:function methodcaller(e,t,a){this.$name=e,this.args=t,this.kwargs=a||[],this.in$repr=!1},slots:{tp$getattr:G,tp$new(e,t){g(\"methodcaller\",e,1);const a=e[0];if(!u(a))throw new s(\"method name must be a string\");return new P.methodcaller(a,e.slice(1),t)},tp$call(e,t){f(\"methodcaller\",e,t);const a=e[0];return E(q(a,this.$name,!0),(e=>C(e,this.args,this.kwargs)))},tp$doc:\"methodcaller(name, ...) --\\x3e methodcaller object\\n\\nReturn a callable object that calls the given method on its operand.\\nAfter f = methodcaller('name'), the call f(r) returns r.name().\\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\\nr.name('date', foo=1).\",$r(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;let e=[D(this.$name)];e.push(...this.args.map((e=>D(e))));for(let t=0;t<this.kwargs.length;t+=2)e.push(this.kwargs[t]+\"=\"+D(this.kwargs[t+1]));return e=this.tp$name+\"(\"+e.join(\", \")+\")\",this.in$repr=!1,e}}});const U={1:{$flags:{OneArg:!0},$textsig:\"($module, a, /)\"},2:{$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\"},3:{$flags:{MinArgs:3,MaxArgs:3},$textsig:\"($module, a, b, c, /)\"}};function makeModuleMethod(e,t){return{$meth:e,$doc:t,...U[e.length]}}function sameAs(e){return\"Same as \"+e+\".\"}return R(\"operator\",P,{lt:makeModuleMethod(((e,t)=>n(B(e,t,\"Lt\"))),sameAs(\"a < b\")),le:makeModuleMethod(((e,t)=>n(B(e,t,\"LtE\"))),sameAs(\"a <= b\")),eq:makeModuleMethod(((e,t)=>n(B(e,t,\"Eq\"))),sameAs(\"a == b\")),ne:makeModuleMethod(((e,t)=>n(B(e,t,\"NotEq\"))),sameAs(\"a != b\")),ge:makeModuleMethod(((e,t)=>n(B(e,t,\"GtE\"))),sameAs(\"a >= b\")),gt:makeModuleMethod(((e,t)=>n(B(e,t,\"Gt\"))),sameAs(\"a > b\")),not_:makeModuleMethod((e=>p(e,\"Not\")),sameAs(\"not a\")),truth:makeModuleMethod((e=>n(e)),\"Return True if a is true, False otherwise.\"),is_:makeModuleMethod(((e,t)=>n(B(e,t,\"Is\"))),sameAs(\"a is b\")),is_not:makeModuleMethod(((e,t)=>n(B(e,t,\"IsNot\"))),sameAs(\"a is not b\")),abs:makeModuleMethod((e=>l(e)),sameAs(\"abs(a)\")),add:makeModuleMethod(((e,t)=>A(e,t,\"Add\")),sameAs(\"a + b\")),and_:makeModuleMethod(((e,t)=>A(e,t,\"BitAnd\")),sameAs(\"a & b\")),floordiv:makeModuleMethod(((e,t)=>A(e,t,\"FloorDiv\")),sameAs(\"a // b\")),index:makeModuleMethod((e=>new o(N(e))),sameAs(\"a.__index__()\")),inv:makeModuleMethod((e=>p(e,\"Invert\")),sameAs(\"~a\")),invert:makeModuleMethod((e=>p(e,\"Invert\")),sameAs(\"~a\")),lshift:makeModuleMethod(((e,t)=>A(e,t,\"LShift\")),sameAs(\"a << b\")),mod:makeModuleMethod(((e,t)=>A(e,t,\"Mod\")),sameAs(\"a % b\")),mul:makeModuleMethod(((e,t)=>A(e,t,\"Mult\")),sameAs(\"a * b\")),matmul:makeModuleMethod(((e,t)=>A(e,t,\"MatMult\")),sameAs(\"a @ b\")),neg:makeModuleMethod((e=>p(e,\"USub\")),sameAs(\"-a\")),or_:makeModuleMethod(((e,t)=>A(e,t,\"BitOr\")),sameAs(\"a | b\")),pos:makeModuleMethod((e=>p(e,\"UAdd\")),sameAs(\"+a\")),pow:makeModuleMethod(((e,t)=>A(e,t,\"Pow\")),sameAs(\"a ** b\")),rshift:makeModuleMethod(((e,t)=>A(e,t,\"RShift\")),sameAs(\"a >> b\")),sub:makeModuleMethod(((e,t)=>A(e,t,\"Sub\")),sameAs(\"a - b\")),truediv:makeModuleMethod(((e,t)=>A(e,t,\"Div\")),sameAs(\"a / b\")),xor:makeModuleMethod(((e,t)=>A(e,t,\"BitXor\")),sameAs(\"a ^ b\")),concat:makeModuleMethod(((e,t)=>v(e,t)),sameAs(\"a + b, for a and b sequences\")),contains:makeModuleMethod(((e,t)=>E(x(e,t),n)),sameAs(\"b in a (note reversed operands)\")),countOf:makeModuleMethod(((e,t)=>j(e,t)),\"Return thenumber of times b occurs in a.\"),delitem:makeModuleMethod(((e,t)=>E(_(e,t,!0),(()=>m))),sameAs(\"del a[b]\")),getitem:makeModuleMethod(((e,t)=>$(e,t,!0)),sameAs(\"a[b]\")),indexOf:makeModuleMethod(((e,t)=>O(e,t)),\"Return the first index of b in a\"),setitem:makeModuleMethod(((e,t,a)=>E(w(e,t,a,!0),(()=>m))),sameAs(\"a[b] = c\")),length_hint:{$meth:function length_hint(e,a){if(void 0===a)a=new o(0);else if(!c(a))throw new s(\"'\"+S(a)+\"' object cannot be interpreted as an integer\");try{return h(e)}catch(m){if(!(m instanceof s))throw m}const r=y(e,t.$length_hint);if(void 0===r)return a;let n;try{n=T(r,[])}catch(m){if(!(m instanceof s))throw m;return a}if(n===d)return a;if(!c(n))throw new s(\"__length_hint__ must be an integer, not \"+S(n));if(n.nb$isnegative())throw new i(\"__length_hint__() should return >= 0\");return n},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, obj, default=0, /)\",$doc:\"Return an estimate of the number of items in obj.\\n\\nThis is useful for presizing containers when building from an iterable.\\n\\nIf the object supports len(), the result will be exact.\\nOtherwise, it may over- or under-estimate by an arbitrary amount.\\nThe result will be an integer >= 0.\"},iadd:makeModuleMethod(((e,t)=>k(e,t,\"Add\")),sameAs(\"a += b\")),iand:makeModuleMethod(((e,t)=>k(e,t,\"BitAnd\")),sameAs(\"a &= b\")),iconcat:makeModuleMethod(((e,t)=>I(e,t)),sameAs(\"a += b, for a and b sequences\")),ifloordiv:makeModuleMethod(((e,t)=>k(e,t,\"FloorDiv\")),sameAs(\"a //= b\")),ilshift:makeModuleMethod(((e,t)=>k(e,t,\"LShift\")),sameAs(\"a <<= b\")),imod:makeModuleMethod(((e,t)=>k(e,t,\"Mod\")),sameAs(\"a %= b\")),imul:makeModuleMethod(((e,t)=>k(e,t,\"Mult\")),sameAs(\"a *= b\")),imatmul:makeModuleMethod(((e,t)=>k(e,t,\"MatMult\")),sameAs(\"a @= b\")),ior:makeModuleMethod(((e,t)=>k(e,t,\"BitOr\")),sameAs(\"a |= b\")),ipow:makeModuleMethod(((e,t)=>k(e,t,\"Pow\")),sameAs(\"a **= b\")),irshift:makeModuleMethod(((e,t)=>k(e,t,\"RShift\")),sameAs(\"a >>= b\")),isub:makeModuleMethod(((e,t)=>k(e,t,\"Sub\")),sameAs(\"a -= b\")),itruediv:makeModuleMethod(((e,t)=>k(e,t,\"Div\")),sameAs(\"a /= b\")),ixor:makeModuleMethod(((e,t)=>k(e,t,\"BitXor\")),sameAs(\"a ^= b\"))}),L.forEach((e=>{P[`__${e.replace(\"_\",\"\")}__`]=P[e]})),P.div=P.truediv,P.__div__=P.div,P}","src/lib/platform.js":"var $builtinmodule=function(n){var e={},i=\"undefined\"!=typeof window&&\"undefined\"!=typeof window.navigator;return e.python_implementation=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"python_implementation\",arguments.length,0,0),new Sk.builtin.str(\"Skulpt\")})),e.node=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"node\",arguments.length,0,0),new Sk.builtin.str(\"\")})),e.version=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"version\",arguments.length,0,0),new Sk.builtin.str(\"\")})),e.python_version=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"python_version\",arguments.length,0,0),n=Sk.__future__.python_version?\"3.2.0\":\"2.7.0\",new Sk.builtin.str(n)})),e.system=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"system\",arguments.length,0,0),n=i?window.navigator.appCodeName:\"\",new Sk.builtin.str(n)})),e.machine=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"machine\",arguments.length,0,0),n=i?window.navigator.platform:\"\",new Sk.builtin.str(n)})),e.release=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"release\",arguments.length,0,0),n=i?window.navigator.appVersion:\"\",new Sk.builtin.str(n)})),e.architecture=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"architecture\",arguments.length,0,0),new Sk.builtin.tuple([new Sk.builtin.str(\"64bit\"),new Sk.builtin.str(\"\")])})),e.processor=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"processor\",arguments.length,0,0),new Sk.builtin.str(\"\")})),e};","src/lib/processing.js":"var $builtinmodule=function(n){var i,e,t,u,o,s,l,c={__name__:new Sk.builtin.str(\"processing\")},r=[],v=!0,f=null;c.processing=null,c.p=null,c.X=new Sk.builtin.int_(0),c.Y=new Sk.builtin.int_(1),c.Z=new Sk.builtin.int_(2),c.R=new Sk.builtin.int_(3),c.G=new Sk.builtin.int_(4),c.B=new Sk.builtin.int_(5),c.A=new Sk.builtin.int_(6),c.U=new Sk.builtin.int_(7),c.V=new Sk.builtin.int_(8),c.NX=new Sk.builtin.int_(9),c.NY=new Sk.builtin.int_(10),c.NZ=new Sk.builtin.int_(11),c.EDGE=new Sk.builtin.int_(12),c.SR=new Sk.builtin.int_(13),c.SG=new Sk.builtin.int_(14),c.SB=new Sk.builtin.int_(15),c.SA=new Sk.builtin.int_(16),c.SW=new Sk.builtin.int_(17),c.TX=new Sk.builtin.int_(18),c.TY=new Sk.builtin.int_(19),c.TZ=new Sk.builtin.int_(20),c.VX=new Sk.builtin.int_(21),c.VY=new Sk.builtin.int_(22),c.VZ=new Sk.builtin.int_(23),c.VW=new Sk.builtin.int_(24),c.AR=new Sk.builtin.int_(25),c.AG=new Sk.builtin.int_(26),c.AB=new Sk.builtin.int_(27),c.DR=new Sk.builtin.int_(3),c.DG=new Sk.builtin.int_(4),c.DB=new Sk.builtin.int_(5),c.DA=new Sk.builtin.int_(6),c.SPR=new Sk.builtin.int_(28),c.SPG=new Sk.builtin.int_(29),c.SPB=new Sk.builtin.int_(30),c.SHINE=new Sk.builtin.int_(31),c.ER=new Sk.builtin.int_(32),c.EG=new Sk.builtin.int_(33),c.EB=new Sk.builtin.int_(34),c.BEEN_LIT=new Sk.builtin.int_(35),c.VERTEX_FIELD_COUNT=new Sk.builtin.int_(36),c.CENTER=new Sk.builtin.int_(3),c.RADIUS=new Sk.builtin.int_(2),c.CORNERS=new Sk.builtin.int_(1),c.CORNER=new Sk.builtin.int_(0),c.DIAMETER=new Sk.builtin.int_(3),c.BASELINE=new Sk.builtin.int_(0),c.TOP=new Sk.builtin.int_(101),c.BOTTOM=new Sk.builtin.int_(102),c.NORMAL=new Sk.builtin.int_(1),c.NORMALIZED=new Sk.builtin.int_(1),c.IMAGE=new Sk.builtin.int_(2),c.MODEL=new Sk.builtin.int_(4),c.SHAPE=new Sk.builtin.int_(5),c.AMBIENT=new Sk.builtin.int_(0),c.DIRECTIONAL=new Sk.builtin.int_(1),c.SPOT=new Sk.builtin.int_(3),c.RGB=new Sk.builtin.int_(1),c.ARGB=new Sk.builtin.int_(2),c.HSB=new Sk.builtin.int_(3),c.ALPHA=new Sk.builtin.int_(4),c.CMYK=new Sk.builtin.int_(5),c.TIFF=new Sk.builtin.int_(0),c.TARGA=new Sk.builtin.int_(1),c.JPEG=new Sk.builtin.int_(2),c.GIF=new Sk.builtin.int_(3),c.MITER=new Sk.builtin.str(\"miter\"),c.BEVEL=new Sk.builtin.str(\"bevel\"),c.ROUND=new Sk.builtin.str(\"round\"),c.SQUARE=new Sk.builtin.str(\"butt\"),c.PROJECT=new Sk.builtin.str(\"square\"),c.P2D=new Sk.builtin.int_(1),c.JAVA2D=new Sk.builtin.int_(1),c.WEBGL=new Sk.builtin.int_(2),c.P3D=new Sk.builtin.int_(2),c.OPENGL=new Sk.builtin.int_(2),c.PDF=new Sk.builtin.int_(0),c.DXF=new Sk.builtin.int_(0),c.OTHER=new Sk.builtin.int_(0),c.WINDOWS=new Sk.builtin.int_(1),c.MAXOSX=new Sk.builtin.int_(2),c.LINUX=new Sk.builtin.int_(3),c.EPSILON=new Sk.builtin.float_(1e-4),c.MAX_FLOAT=new Sk.builtin.float_(34028235e31),c.MIN_FLOAT=new Sk.builtin.float_(-34028235e31),c.MAX_INT=new Sk.builtin.int_(2147483647),c.MIN_INT=new Sk.builtin.int_(-2147483648),c.HALF_PI=new Sk.builtin.float_(Math.PI/2),c.THIRD_PI=new Sk.builtin.float_(Math.PI/3),c.PI=new Sk.builtin.float_(Math.PI),c.TWO_PI=new Sk.builtin.float_(2*Math.PI),c.TAU=new Sk.builtin.float_(2*Math.PI),c.QUARTER_PI=new Sk.builtin.float_(Math.PI/4),c.DEG_TO_RAD=new Sk.builtin.float_(Math.PI/180),c.RAD_TO_DEG=new Sk.builtin.float_(180/Math.PI),c.WHITESPACE=new Sk.builtin.str(\" \\t\\n\\r\\f \"),c.POINT=new Sk.builtin.int_(2),c.POINTS=new Sk.builtin.int_(2),c.LINE=new Sk.builtin.int_(4),c.LINES=new Sk.builtin.int_(4),c.TRIANGLE=new Sk.builtin.int_(8),c.TRIANGLES=new Sk.builtin.int_(9),c.TRIANGLE_FAN=new Sk.builtin.int_(11),c.TRIANGLE_STRIP=new Sk.builtin.int_(10),c.QUAD=new Sk.builtin.int_(16),c.QUADS=new Sk.builtin.int_(16),c.QUAD_STRIP=new Sk.builtin.int_(17),c.POLYGON=new Sk.builtin.int_(20),c.PATH=new Sk.builtin.int_(21),c.RECT=new Sk.builtin.int_(30),c.ELLIPSE=new Sk.builtin.int_(31),c.ARC=new Sk.builtin.int_(32),c.SPHERE=new Sk.builtin.int_(40),c.BOX=new Sk.builtin.int_(41),c.GROUP=new Sk.builtin.int_(0),c.PRIMITIVE=new Sk.builtin.int_(1),c.GEOMETRY=new Sk.builtin.int_(3),c.VERTEX=new Sk.builtin.int_(0),c.BEZIER_VERTEX=new Sk.builtin.int_(1),c.CURVE_VERTEX=new Sk.builtin.int_(2),c.BREAK=new Sk.builtin.int_(3),c.CLOSESHAPE=new Sk.builtin.int_(4),c.REPLACE=new Sk.builtin.int_(0),c.BLEND=new Sk.builtin.int_(1),c.ADD=new Sk.builtin.int_(2),c.SUBTRACT=new Sk.builtin.int_(4),c.LIGHTEST=new Sk.builtin.int_(8),c.DARKEST=new Sk.builtin.int_(16),c.DIFFERENCE=new Sk.builtin.int_(32),c.EXCLUSION=new Sk.builtin.int_(64),c.MULTIPLY=new Sk.builtin.int_(128),c.SCREEN=new Sk.builtin.int_(256),c.OVERLAY=new Sk.builtin.int_(512),c.HARD_LIGHT=new Sk.builtin.int_(1024),c.SOFT_LIGHT=new Sk.builtin.int_(2048),c.DODGE=new Sk.builtin.int_(4096),c.BURN=new Sk.builtin.int_(8192),c.ALPHA_MASK=new Sk.builtin.int_(4278190080),c.RED_MASK=new Sk.builtin.int_(16711680),c.GREEN_MASK=new Sk.builtin.int_(65280),c.BLUE_MASK=new Sk.builtin.int_(255),c.CUSTOM=new Sk.builtin.int_(0),c.ORTHOGRAPHIC=new Sk.builtin.int_(2),c.PERSPECTIVE=new Sk.builtin.int_(3),c.ARROW=new Sk.builtin.str(\"default\"),c.CROSS=new Sk.builtin.str(\"crosshair\"),c.HAND=new Sk.builtin.str(\"pointer\"),c.MOVE=new Sk.builtin.str(\"move\"),c.TEXT=new Sk.builtin.str(\"text\"),c.WAIT=new Sk.builtin.str(\"wait\"),c.NOCURSOR=Sk.builtin.assk$(\"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\"),c.DISABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(1),c.ENABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(-1),c.ENABLE_OPENGL_4X_SMOOTH=new Sk.builtin.int_(2),c.ENABLE_NATIVE_FONTS=new Sk.builtin.int_(3),c.DISABLE_DEPTH_TEST=new Sk.builtin.int_(4),c.ENABLE_DEPTH_TEST=new Sk.builtin.int_(-4),c.ENABLE_DEPTH_SORT=new Sk.builtin.int_(5),c.DISABLE_DEPTH_SORT=new Sk.builtin.int_(-5),c.DISABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(6),c.ENABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(-6),c.ENABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(7),c.DISABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(-7),c.HINT_COUNT=new Sk.builtin.int_(10),c.OPEN=new Sk.builtin.int_(1),c.CLOSE=new Sk.builtin.int_(2),c.BLUR=new Sk.builtin.int_(11),c.GRAY=new Sk.builtin.int_(12),c.INVERT=new Sk.builtin.int_(13),c.OPAQUE=new Sk.builtin.int_(14),c.POSTERIZE=new Sk.builtin.int_(15),c.THRESHOLD=new Sk.builtin.int_(16),c.ERODE=new Sk.builtin.int_(17),c.DILATE=new Sk.builtin.int_(18),c.BACKSPACE=new Sk.builtin.int_(8),c.TAB=new Sk.builtin.int_(9),c.ENTER=new Sk.builtin.int_(10),c.RETURN=new Sk.builtin.int_(13),c.ESC=new Sk.builtin.int_(27),c.DELETE=new Sk.builtin.int_(127),c.CODED=new Sk.builtin.int_(65535),c.SHIFT=new Sk.builtin.int_(16),c.CONTROL=new Sk.builtin.int_(17),c.ALT=new Sk.builtin.int_(18),c.CAPSLK=new Sk.builtin.int_(20),c.PGUP=new Sk.builtin.int_(33),c.PGDN=new Sk.builtin.int_(34),c.END=new Sk.builtin.int_(35),c.HOME=new Sk.builtin.int_(36),c.LEFT=new Sk.builtin.int_(37),c.UP=new Sk.builtin.int_(38),c.RIGHT=new Sk.builtin.int_(39),c.DOWN=new Sk.builtin.int_(40),c.F1=new Sk.builtin.int_(112),c.F2=new Sk.builtin.int_(113),c.F3=new Sk.builtin.int_(114),c.F4=new Sk.builtin.int_(115),c.F5=new Sk.builtin.int_(116),c.F6=new Sk.builtin.int_(117),c.F7=new Sk.builtin.int_(118),c.F8=new Sk.builtin.int_(119),c.F9=new Sk.builtin.int_(120),c.F10=new Sk.builtin.int_(121),c.F11=new Sk.builtin.int_(122),c.F12=new Sk.builtin.int_(123),c.NUMLK=new Sk.builtin.int_(144),c.META=new Sk.builtin.int_(157),c.INSERT=new Sk.builtin.int_(155),c.SINCOS_LENGTH=new Sk.builtin.int_(720),c.PRECISIONB=new Sk.builtin.int_(15),c.PRECISIONF=new Sk.builtin.int_(32768),c.PREC_MAXVAL=new Sk.builtin.int_(32767),c.PREC_ALPHA_SHIFT=new Sk.builtin.int_(9),c.PREC_RED_SHIFT=new Sk.builtin.int_(1),c.NORMAL_MODE_AUTO=new Sk.builtin.int_(0),c.NORMAL_MODE_SHAPE=new Sk.builtin.int_(1),c.NORMAL_MODE_VERTEX=new Sk.builtin.int_(2),c.MAX_LIGHTS=new Sk.builtin.int_(8),c.line=new Sk.builtin.func((function(n,i,e,t){c.processing.line(n.v,i.v,e.v,t.v)})),c.ellipse=new Sk.builtin.func((function(n,i,e,t){c.processing.ellipse(n.v,i.v,e.v,t.v)})),c.circle=new Sk.builtin.func((function(n,i,e){c.processing.ellipse(n.v,i.v,e.v,e.v)})),c.text=new Sk.builtin.func((function(n,i,e){c.processing.text(n.v,i.v,e.v)})),c.point=new Sk.builtin.func((function(n,i){c.processing.point(n.v,i.v)})),c.arc=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.arc(n.v,i.v,e.v,t.v,u.v,o.v)})),c.quad=new Sk.builtin.func((function(n,i,e,t,u,o,s,l){c.processing.quad(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v)})),c.rect=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof u?c.processing.rect(n.v,i.v,e.v,t.v):c.processing.rect(n.v,i.v,e.v,t.v,u.v)})),c.triangle=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.triangle(n.v,i.v,e.v,t.v,u.v,o.v)})),c.bezier=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r,v,f,S){\"undefined\"==typeof r?c.processing.bezier(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):c.processing.bezier(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v,f.v,S.v)})),c.alpha=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.alpha(n.v)):\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.alpha(n.v,i.v)):new Sk.builtin.float_(c.processing.alpha(n.v,i.v,e.v))})),c.ambient=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof i?c.processing.ambient(n.v):\"undefined\"==typeof e?c.processing.ambient(n.v,i.v):c.processing.ambient(n.v,i.v,e.v)})),c.ambientLight=new Sk.builtin.func((function(n,i,e,t,u,o){\"undefined\"==typeof t?c.processing.ambientLight(n.v,i.v,e.v):\"undefined\"==typeof u?c.processing.ambientLight(n.v,i.v,e.v,t.v):\"undefined\"==typeof o?c.processing.ambientLight(n.v,i.v,e.v,t.v,u.v):c.processing.ambientLight(n.v,i.v,e.v,t.v,u.v,o.v)})),c.beginCamera=new Sk.builtin.func((function(){c.processing.beginCamera()})),c.beginShape=new Sk.builtin.func((function(n){\"undefined\"==typeof n&&(n=c.POLYGON),c.processing.beginShape(n.v)})),c.bezierDetail=new Sk.builtin.func((function(n){n=\"undefined\"!=typeof n?n.v:20,c.processing.bezierDetail(n)})),c.bezierPoint=new Sk.builtin.func((function(n,i,e,t,u){c.processing.bezierPoint(n.v,i.v,e.v,t.v,u.v)})),c.bezierTangent=new Sk.builtin.func((function(n,i,e,t,u){c.processing.bezierTangent(n.v,i.v,e.v,t.v,u.v)})),c.bezierVertex=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r){\"undefined\"==typeof s?c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v):\"undefined\"==typeof l?c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v,s.v):\"undefined\"==typeof r?c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v)})),c.blend=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r,v){n instanceof Sk.builtin.int_||n instanceof Sk.builtin.float_?c.processing.blend(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v):c.processing.blend(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v)})),c.blendColor=new Sk.builtin.func((function(n,i,e){var t=Sk.misceval.callsimArray(c.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return t.v=c.processing.blendColor(n.v,i.v,e.v),t})),c.brightness=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.brightness(n.v)):\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.brightness(n.v,i.v)):new Sk.builtin.float_(c.processing.brightness(n.v,i.v,e.v))})),c.camera=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r){\"undefined\"==typeof n?c.processing.camera():c.processing.camera(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v)})),c.constrain=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.constrain(n.v,i.v,e.v))})),c.copy=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r){n instanceof Sk.builtin.int_||n instanceof Sk.builtin.float_?c.processing.copy(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):c.processing.copy(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v)})),c.createFont=new Sk.builtin.func((function(n,i,e,t){var u=Sk.misceval.callsimArray(c.PFont);return u.v=\"undefined\"==typeof e?c.processing.createFont(n.v,i.v):\"undefined\"==typeof t?c.processing.createFont(n.v,i.v,e.v):c.processing.createFont(n.v,i.v,e.v,t.v),u})),c.createGraphics=new Sk.builtin.func((function(n,i,e,t){var u=Sk.misceval.callsimArray(c.PGraphics);return u.v=\"undefined\"==typeof t?c.processing.createGraphics(n.v,i.v,e.v):c.processing.createGraphics(n.v,i.v,e.v,t.v),u})),c.createImage=new Sk.builtin.func((function(n,i,e){var t=Sk.misceval.callsimArray(c.PImage);return t.v=c.processing.createImage(n.v,i.v,e.v),t})),c.cursor=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof n?c.processing.cursor():\"undefined\"==typeof i?c.processing.cursor(n.v):\"undefined\"==typeof e?c.processing.cursor(n.v,i.v):c.processing.cursor(n.v,i.v,e.v)})),c.curve=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r,v,f,S){\"undefined\"==typeof r?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):\"undefined\"==typeof v?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v):\"undefined\"==typeof f?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v):\"undefined\"==typeof S?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v,f.v):c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v,f.v,S.v)})),c.curveDetail=new Sk.builtin.func((function(n){c.processing.curveDetail(n.v)})),c.curvePoint=new Sk.builtin.func((function(n,i,e,t,u){c.processing.curvePoint(n.v,i.v,e.v,t.v,u.v)})),c.curveTangent=new Sk.builtin.func((function(n,i,e,t,u){c.processing.curveTangent(n.v,i.v,e.v,t.v,u.v)})),c.curveTightness=new Sk.builtin.func((function(n){c.processing.curveTightness(n.v)})),c.curveVertex=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof e?c.processing.curveVertex(n.v,i.v):c.processing.curveVertex(n.v,i.v,e.v)})),c.day=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.day())})),c.degrees=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.degrees(n.v))})),c.directionalLight=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.directionalLight(n.v,i.v,e.v,t.v,u.v,o.v)})),c.dist=new Sk.builtin.func((function(n,i,e,t,u,o){return\"undefined\"==typeof u?new Sk.builtin.float_(c.processing.dist(n.v,i.v,e.v,t.v)):\"undefined\"==typeof o?new Sk.builtin.float_(c.processing.dist(n.v,i.v,e.v,t.v,u.v)):new Sk.builtin.float_(c.processing.dist(n.v,i.v,e.v,t.v,u.v,o.v))})),c.emissive=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof i?c.processing.emissive(n.v):\"undefined\"==typeof e?c.processing.emissive(n.v,i.v):c.processing.emissive(n.v,i.v,e.v)})),c.endCamera=new Sk.builtin.func((function(){c.processing.endCamera()})),c.endShape=new Sk.builtin.func((function(n){\"undefined\"==typeof n?c.processing.endShape():c.processing.endShape(n.v)})),c.filter=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.filter(n.v):c.processing.filter(n.v,i.v)})),c.frustum=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.frustum(n,i,e,t,u,o)})),c.hint=new Sk.builtin.func((function(n){c.processing.hint(n)})),c.hour=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.hour())})),c.hue=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.hue(n.v))})),c.imageMode=new Sk.builtin.func((function(n){c.processing.imageMode(n.v)})),c.lerp=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.lerp(n.v,i.v,e.v))})),c.lerpColor=new Sk.builtin.func((function(n,i,e){var t=Sk.misceval.callsimArray(c.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return t.v=c.processing.lerpColor(n.v,i.v,e.v),t})),c.lightFalloff=new Sk.builtin.func((function(n,i,e){c.processing.lightFalloff(n.v,i.v,e.v)})),c.lights=new Sk.builtin.func((function(){c.processing.lights()})),c.lightSpecular=new Sk.builtin.func((function(n,i,e){c.processing.lightSpecular(n.v,i.v,e.v)})),c.loadBytes=new Sk.builtin.func((function(n){return new Sk.builtin.list(c.processing.loadBytes(n.v))})),c.loadFont=new Sk.builtin.func((function(n){var i=Sk.misceval.callsimArray(c.PFont);return i.v=c.processing.loadFont(n.v),i})),c.loadShape=new Sk.builtin.func((function(n){return Sk.misceval.callsimArray(c.PShapeSVG,[new Sk.builtin.str(\"string\"),n])})),c.loadStrings=new Sk.builtin.func((function(n){return new Sk.builtin.list(c.processing.loadStrings(n.v))})),c.mag=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.mag(n.v,i.v)):new Sk.builtin.float_(c.processing.mag(n.v,i.v,e.v))})),c.map=new Sk.builtin.func((function(n,i,e,t,u){return new Sk.builtin.float_(c.processing.map(n.v,i.v,e.v,t.v,u.v))})),c.millis=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.millis())})),c.minute=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.minute())})),c.modelX=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.modelX(n.v,i.v,e.v))})),c.modelY=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.modelY(n.v,i.v,e.v))})),c.modelZ=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.modelZ(n.v,i.v,e.v))})),c.month=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.month())})),c.noCursor=new Sk.builtin.func((function(){c.processing.noCursor()})),c.noise=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.noise(n.v)):\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.noise(n.v,i.v)):new Sk.builtin.float_(c.processing.noise(n.v,i.v,e.v))})),c.noiseDetail=new Sk.builtin.func((function(n,i){c.processing.noiseDetail(n.v,i.v)})),c.noiseSeed=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.noiseSeed(n.v))})),c.noLights=new Sk.builtin.func((function(){c.processing.noLights()})),c.norm=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.norm(n.v,i.v,e.v))})),c.normal=new Sk.builtin.func((function(n,i,e){c.processing.normal(n.v,i.v,e.v)})),c.noTint=new Sk.builtin.func((function(){c.processing.noTint()})),c.ortho=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.ortho(n.v,i.v,e.v,t.v,u.v,o.v)})),c.perspective=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof n?c.processing.perspective():\"undefined\"==typeof i?c.processing.perspective(n.v):\"undefined\"==typeof e?c.processing.perspective(n.v,i.v):\"undefined\"==typeof t?c.processing.perspective(n.v,i.v,e.v):c.processing.perspective(n.v,i.v,e.v,t.v)})),c.pointLight=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.pointLight(n.v,i.v,e.v,t.v,u.v,o.v)})),c.printCamera=new Sk.builtin.func((function(){c.processing.printCamera()})),c.println=new Sk.builtin.func((function(n){c.processing.println(n.v)})),c.printProjection=new Sk.builtin.func((function(){c.processing.printProjection()})),c.radians=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.radians(n.v))})),c.randomSeed=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.randomSeed(n.v))})),c.random=new Sk.builtin.func((function(n,i){return\"undefined\"==typeof n?new Sk.builtin.float_(c.processing.random()):\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.random(n.v)):new Sk.builtin.float_(c.processing.random(n.v,i.v))})),c.requestImage=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PImage);return e.v=\"undefined\"==typeof i?c.processing.requestImage(n.v):c.processing.requestImage(n.v,i.v),e})),c.saturation=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.saturation(n.v))})),c.save=new Sk.builtin.func((function(n){c.processing.save(n.v)})),c.saveFrame=new Sk.builtin.func((function(n){\"undefined\"==typeof n?c.processing.saveFrame():c.processing.saveFrame(n.v)})),c.saveStrings=new Sk.builtin.func((function(n,i){c.processing.saveStrings(n.v,i.v)})),c.screenX=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.screenX(n.v,i.v,e.v))})),c.screenY=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.screenY(n.v,i.v,e.v))})),c.screenZ=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.screenZ(n.v,i.v,e.v))})),c.second=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.second())})),c.shape=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof i?c.processing.shape(n.v):\"undefined\"==typeof e?c.processing.shape(n.v,i.v):\"undefined\"==typeof t?c.processing.shape(n.v,i.v,e.v):\"undefined\"==typeof u?c.processing.shape(n.v,i.v,e.v,t.v):c.processing.shape(n.v,i.v,e.v,t.v,u.v)})),c.shapeMode=new Sk.builtin.func((function(n){c.processing.shapeMode(n.v)})),c.shininess=new Sk.builtin.func((function(n){c.processing.shininess(n.v)})),c.specular=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof i?c.processing.specular(n.v):\"undefined\"==typeof e?c.processing.specular(n.v,i.v):c.processing.specular(n.v,i.v,e.v)})),c.spotLight=new Sk.builtin.func((function(n,i,e,t,u,o,s,l){c.processing.spotLight(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v)})),c.sq=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.sq(n))})),c.status=new Sk.builtin.func((function(n){c.processing.status(n.v)})),c.textAlign=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.textAlign(n.v):c.processing.textAlign(n.v,i.v)})),c.textAscent=new Sk.builtin.func((function(){return new Sk.builtin.float_(c.processing.textAscent())})),c.textDescent=new Sk.builtin.func((function(){return new Sk.builtin.float_(c.processing.textDescent())})),c.textFont=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.textFont(n.v):c.processing.textFont(n.v,i.v)})),c.textLeading=new Sk.builtin.func((function(n){c.processing.textLeading(n.v)})),c.textMode=new Sk.builtin.func((function(n){c.processing.textMode(n.v)})),c.textSize=new Sk.builtin.func((function(n){c.processing.textSize(n.v)})),c.texture=new Sk.builtin.func((function(n){c.processing.texture(n.v)})),c.textureMode=new Sk.builtin.func((function(n){c.processing.textureMode(n.v)})),c.textWidth=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.textWidth(n.v))})),c.tint=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof i?c.processing.tint(n.v):\"undefined\"==typeof e?c.processing.tint(n.v,i.v):\"undefined\"==typeof t?c.processing.tint(n.v,i.v,e.v):c.processing.tint(n.v,i.v,e.v,t.v)})),c.updatePixels=new Sk.builtin.func((function(){c.processing.updatePixels()})),c.vertex=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof e?c.processing.vertex(n.v,i.v):\"undefined\"==typeof t?c.processing.vertex(n.v,i.v,e.v):\"undefined\"==typeof u?c.processing.vertex(n.v,i.v,e.v,t.v):c.processing.vertex(n.v,i.v,e.v,t.v,u.v)})),c.year=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.year())})),c.box=new Sk.builtin.func((function(n){c.processing.box(n.v)})),c.sphere=new Sk.builtin.func((function(n){c.processing.sphere(n.v)})),c.sphereDetail=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.sphereDetail(n.v):c.processing.sphereDetail(n.v,i.v)})),c.background=new Sk.builtin.func((function(n,i,e){\"undefined\"!=typeof i&&(i=i.v),\"undefined\"!=typeof e&&(e=e.v),c.processing.background(n.v,i,e)})),c.fill=new Sk.builtin.func((function(n,i,e,t){\"undefined\"!=typeof i&&(i=i.v),\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),c.processing.fill(n.v,i,e,t)})),c.stroke=new Sk.builtin.func((function(n,i,e,t){\"undefined\"!=typeof i&&(i=i.v),\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),c.processing.stroke(n.v,i,e,t)})),c.noStroke=new Sk.builtin.func((function(){c.processing.noStroke()})),c.colorMode=new Sk.builtin.func((function(n,i,e,t,u){i=\"undefined\"==typeof i?255:i.v,\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),\"undefined\"!=typeof u&&(u=u.v),c.processing.colorMode(n.v,i,e,t,u)})),c.noFill=new Sk.builtin.func((function(){c.processing.noFill()})),c.loop=new Sk.builtin.func((function(){if(null===c.processing)throw new Sk.builtin.Exception(\"loop() should be called after run()\");v=!0,c.processing.loop()})),c.noLoop=new Sk.builtin.func((function(){if(null===c.processing)throw new Sk.builtin.Exception(\"noLoop() should be called after run()\");v=!1,c.processing.noLoop()})),c.frameRate=new Sk.builtin.func((function(n){c.processing.frameRate(n.v)})),c.width=new Sk.builtin.int_(0),c.height=new Sk.builtin.int_(0),c.renderMode=c.P2D,c.size=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof e&&(e=c.P2D),c.processing.size(n.v,i.v,e.v),c.width=new Sk.builtin.int_(c.processing.width),c.height=new Sk.builtin.int_(c.processing.height),c.renderMode=e})),c.exitp=new Sk.builtin.func((function(){c.processing.exit()})),c.mouseX=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.mouseX)})),c.mouseY=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.mouseY)})),c.pmouseX=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.pmouseX)})),c.pmouseY=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.pmouseY)})),c.rectMode=new Sk.builtin.func((function(n){c.processing.rectMode(n.v)})),c.strokeWeight=new Sk.builtin.func((function(n){c.processing.strokeWeight(n.v)})),c.smooth=new Sk.builtin.func((function(){c.processing.smooth()})),c.noSmooth=new Sk.builtin.func((function(){c.processing.noSmooth()})),c.ellipseMode=new Sk.builtin.func((function(n){c.processing.ellipseMode(n.v)})),c.strokeCap=new Sk.builtin.func((function(n){c.processing.strokeCap(n.v)})),c.strokeJoin=new Sk.builtin.func((function(n){c.processing.strokeJoin(n.v)})),c.rotate=new Sk.builtin.func((function(n){c.processing.rotate(n.v)})),c.rotateX=new Sk.builtin.func((function(n){c.processing.rotateX(n.v)})),c.rotateY=new Sk.builtin.func((function(n){c.processing.rotateY(n.v)})),c.rotateZ=new Sk.builtin.func((function(n){c.processing.rotateZ(n.v)})),c.scale=new Sk.builtin.func((function(n,i,e){i=\"undefined\"==typeof i?1:i.v,e=\"undefined\"==typeof e?1:e.v,c.processing.scale(n.v,i,e)})),c.translate=new Sk.builtin.func((function(n,i,e){i=\"undefined\"==typeof i?1:i.v,e=\"undefined\"==typeof e?1:e.v,c.processing.translate(n.v,i,e)})),c.popMatrix=new Sk.builtin.func((function(){c.processing.popMatrix()})),c.pushMatrix=new Sk.builtin.func((function(){c.processing.pushMatrix()})),c.applyMatrix=new Sk.builtin.func((function(){var n,i=Array.prototype.slice.call(arguments,0,16);for(n=0;n<i.length;n++)i[n]=\"undefined\"==typeof i[n]?0:i[n].v;c.processing.applyMatrix.apply(c.processing,i)})),c.resetMatrix=new Sk.builtin.func((function(){c.processing.resetMatrix()})),c.printMatrix=new Sk.builtin.func((function(){return Sk.ffi.remapToPy(c.processing.printMatrix())})),c.run=new Sk.builtin.func((function(){var n=document.getElementById(Sk.canvas);if(!n)throw new Error(\"Processing module: Canvas element not specified\");if(window.Processing.logger={log:function(n){Sk.misceval.print_(n)}},(f=window.Processing.getInstanceById(Sk.canvas))&&f.exit(),c.p=new window.Processing(n,(function sketchProc(n){c.processing=n,n.draw=function(){var i=!1;for(var e in r)0===r[e].width&&(i=!0);if(!0===i)return!0===v?void 0:void n.loop();if(!1===v&&n.noLoop(),c.frameCount=n.frameCount,Sk.globals.draw)try{Sk.misceval.callsimArray(Sk.globals.draw)}catch(t){Sk.uncaughtException(t)}};var i=[\"setup\",\"mouseMoved\",\"mouseClicked\",\"mouseDragged\",\"mouseMoved\",\"mouseOut\",\"mouseOver\",\"mousePressed\",\"mouseReleased\",\"keyPressed\",\"keyReleased\",\"keyTyped\"];for(var e in i)Sk.globals[i[e]]&&(n[i[e]]=new Function(\"try {Sk.misceval.callsimArray(Sk.globals['\"+i[e]+\"']);} catch(e) {Sk.uncaughtException(e);}\"))})),0===c.width.v&&0===c.height.v){var i=n.offsetWidth,e=n.offsetHeight;Sk.misceval.callsimArray(c.size,[new Sk.builtin.int_(i),new Sk.builtin.int_(e),c.renderMode])}})),s=function(n,i){i.__getattr__=new Sk.builtin.func((function(n,i){return\"x\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(c.processing.mouseX):\"y\"===i?Sk.builtin.assk$(c.processing.mouseY):\"px\"===i?Sk.builtin.assk$(c.processing.pmouseX):\"py\"===i?Sk.builtin.assk$(c.processing.pmouseY):\"pressed\"===i?new Sk.builtin.bool(c.processing.__mousePressed):\"button\"===i?Sk.builtin.assk$(c.processing.mouseButton):void 0}))},c.Mouse=Sk.misceval.buildClass(c,s,\"Mouse\",[]),c.mouse=Sk.misceval.callsimArray(c.Mouse),o=function(n,i){i.__getattr__=new Sk.builtin.func((function(n,i){return\"key\"===(i=Sk.ffi.remapToJs(i))?new Sk.builtin.str(c.processing.key.toString()):\"keyCode\"===i?Sk.builtin.assk$(c.processing.keyCode):\"keyPressed\"===i?new Sk.builtin.str(c.processing.keyPressed):void 0}))},c.Keyboard=Sk.misceval.buildClass(c,o,\"Keyboard\",[]),c.keyboard=Sk.misceval.callsimArray(c.Keyboard),u=function(n,i){i.__getattr__=new Sk.builtin.func((function(n,i){return\"frameCount\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(c.processing.frameCount):\"frameRate\"===i?Sk.builtin.assk$(c.processing.frameRate):\"height\"===i?Sk.builtin.assk$(c.processing.height):\"width\"===i?Sk.builtin.assk$(c.processing.width):\"online\"===i?new Sk.builtin.bool(c.processing.online):\"focused\"===i?new Sk.builtin.bool(c.processing.focused):void 0}))},c.Environment=Sk.misceval.buildClass(c,u,\"Environment\",[]),c.environment=Sk.misceval.callsimArray(c.Environment),t=function(n,i){i.__init__=new Sk.builtin.func((function(n){n.pixels=null})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"height\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(c.processing.height):\"width\"===i?Sk.builtin.assk$(c.processing.width):(\"pixels\"===i&&null==n.pixels&&(n.pixels=new Sk.builtin.list(c.processing.pixels.toArray())),n.pixels)}))},c.Screen=Sk.misceval.buildClass(c,t,\"Screen\",[]),c.screen=Sk.misceval.callsimArray(c.Screen),c.loadPixels=new Sk.builtin.func((function(){c.processing.loadPixels()})),e=function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),\"undefined\"!=typeof u&&(u=u.v),n.v=c.processing.color(i.v,e,t,u)}))},c.color=Sk.misceval.buildClass(c,e,\"color\",[]),c.red=new Sk.builtin.func((function(n){return new Sk.builtin.int_(c.processing.red(n.v))})),c.green=new Sk.builtin.func((function(n){return new Sk.builtin.int_(c.processing.green(n.v))})),c.blue=new Sk.builtin.func((function(n){return new Sk.builtin.int_(c.processing.blue(n.v))})),i=function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?new c.processing.PImage:\"undefined\"==typeof e?new c.processing.PImage(i.v):\"undefined\"==typeof t?new c.processing.PImage(i.v,e.v):new c.processing.PImage(i.v,e.v,t.v)})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"width\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(n.v.width):\"height\"===i?Sk.builtin.assk$(n.v.height):void 0}))},c.loadImage=new Sk.builtin.func((function(n){var i=c.processing.loadImage(n.v);r.push(i);var e=Sk.misceval.callsimArray(c.PImage);return e.v=i,e})),c.image=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof t?c.processing.image(n.v,i.v,e.v):c.processing.image(n.v,i.v,e.v,t.v,u.v)})),c.get=new Sk.builtin.func((function(n,i){var e=c.processing.get(n.v,i.v);return Sk.misceval.callsimArray(c.color,[new Sk.builtin.int_(c.processing.red(e)),new Sk.builtin.int_(c.processing.green(e)),new Sk.builtin.int_(c.processing.blue(e))])})),c.set=new Sk.builtin.func((function(n,i,e){c.processing.set(n.v,i.v,e.v)})),l=function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?new c.processing.PVector:\"undefined\"==typeof t?new c.processing.PVector(i.v,e.v):new c.processing.PVector(i.v,e.v,t.v)})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"x\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(n.v.x):\"y\"===i?Sk.builtin.assk$(n.v.y):\"z\"===i?Sk.builtin.assk$(n.v.z):void 0})),i.get=new Sk.builtin.func((function(n){var i=Sk.misceval.callsimArray(c.PVector);return i.v=n.v.get(),i})),i.set=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof t?n.v.set(i.v,e.v):n.v.set(i.v,e.v,t.v)})),i.mag=new Sk.builtin.func((function(n){return Sk.builtin.assk$(n.v.mag())})),i.add=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.add(i.v),e})),i.sub=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.sub(i.v),e})),i.mult=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.mult(i.v),e})),i.div=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.div(i.v),e})),i.dist=new Sk.builtin.func((function(n,i){return Sk.builtin.assk$(n.v.dist(i.v))})),i.dot=new Sk.builtin.func((function(n,i,e,t){return\"undefined\"==typeof e?Sk.builtin.assk$(n.v.dot(i.v)):Sk.builtin.assk$(n.v.dot(i.v,e.v,t.v))})),i.cross=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.cross(i.v),e})),i.normalize=new Sk.builtin.func((function(n){n.v.normalize()})),i.limit=new Sk.builtin.func((function(n,i){n.v.limit(i.v)})),i.angleBetween=new Sk.builtin.func((function(n,i){return Sk.builtin.assk$(n.v.angleBetween(i.v))})),i.array=new Sk.builtin.func((function(n){return new Sk.builtin.list(n.v.array())}))};return c.PFont=Sk.misceval.buildClass(c,(function(n,i){i.__init__=new Sk.builtin.func((function(n,i){n.v=\"undefined\"==typeof i?new c.processing.PFont:new c.processing.PVector(i.v)})),i.list=new Sk.builtin.func((function(n){return new Sk.builtin.list(n.v.list())}))}),\"PFont\",[]),c.PGraphics=Sk.misceval.buildClass(c,(function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?new c.processing.PVector:\"undefined\"==typeof t?new c.processing.PVector(i.v,e.v):new c.processing.PVector(i.v,e.v,t.v)})),i.beginDraw=new Sk.builtin.func((function(n){n.v.beginDraw()})),i.endDraw=new Sk.builtin.func((function(n){n.v.endDraw()}))}),\"PGraphics\",[]),c.PShapeSVG=Sk.misceval.buildClass(c,(function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?null:\"undefined\"==typeof e?new c.processing.PShapeSVG(i.v):\"undefined\"==typeof t?new c.processing.PShapeSVG(i.v,e.v):new c.processing.PShapeSVG(i.v,e.v,t.v)})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"width\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(n.v.width):\"height\"===i?Sk.builtin.assk$(n.v.height):void 0})),i.isVisible=new Sk.builtin.func((function(n){return new Sk.builtin.bool(n.v.isVisible())})),i.setVisible=new Sk.builtin.func((function(n,i){n.v.setVisible(i.v)})),i.disableStyle=new Sk.builtin.func((function(n){n.v.disableStyle()})),i.enableStyle=new Sk.builtin.func((function(n){n.v.enableStyle()})),i.getChild=new Sk.builtin.func((function(n,i){var e=n.v.getChild(i.v);if(null!=e){var t=Sk.misceval.callsimArray(c.PShapeSVG);return t.v=e,t}return null})),i.translate=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof t?n.v.translate(i.v,e.v):n.v.translate(i.v,e.v,t.v)})),i.rotate=new Sk.builtin.func((function(n,i){n.v.rotate(i.v)})),i.rotateX=new Sk.builtin.func((function(n,i){n.v.rotateX(i.v)})),i.rotateY=new Sk.builtin.func((function(n,i){n.v.rotateY(i.v)})),i.rotateZ=new Sk.builtin.func((function(n,i){n.v.rotateZ(i.v)})),i.scale=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof e?n.v.scale(i.v):\"undefined\"==typeof t?n.v.scale(i.v,e.v):n.v.scale(i.v,e.v,t.v)}))}),\"PShapeSVG\",[]),c.PVector=Sk.misceval.buildClass(c,l,\"PVector\",[]),c.PImage=Sk.misceval.buildClass(c,i,\"PImage\",[]),c};","src/lib/random.js":"var MersenneTwister=function(n){null==n&&(n=(new Date).getTime()),this.N=624,this.M=397,this.MATRIX_A=2567483615,this.UPPER_MASK=2147483648,this.LOWER_MASK=2147483647,this.mt=new Array(this.N),this.mti=this.N+1,this.init_genrand(n)};MersenneTwister.prototype.init_genrand=function(n){for(this.mt[0]=n>>>0,this.mti=1;this.mti<this.N;this.mti++)n=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30,this.mt[this.mti]=(1812433253*((4294901760&n)>>>16)<<16)+1812433253*(65535&n)+this.mti,this.mt[this.mti]>>>=0},MersenneTwister.prototype.init_by_array=function(n,t){var i,e,r;for(this.init_genrand(19650218),i=1,e=0,r=this.N>t?this.N:t;r;r--){var u=this.mt[i-1]^this.mt[i-1]>>>30;this.mt[i]=(this.mt[i]^(1664525*((4294901760&u)>>>16)<<16)+1664525*(65535&u))+n[e]+e,this.mt[i]>>>=0,e++,++i>=this.N&&(this.mt[0]=this.mt[this.N-1],i=1),e>=t&&(e=0)}for(r=this.N-1;r;r--){u=this.mt[i-1]^this.mt[i-1]>>>30;this.mt[i]=(this.mt[i]^(1566083941*((4294901760&u)>>>16)<<16)+1566083941*(65535&u))-i,this.mt[i]>>>=0,++i>=this.N&&(this.mt[0]=this.mt[this.N-1],i=1)}this.mt[0]=2147483648},MersenneTwister.prototype.genrand_int32=function(){var n,t=new Array(0,this.MATRIX_A);if(this.mti>=this.N){var i;for(this.mti==this.N+1&&this.init_genrand(5489),i=0;i<this.N-this.M;i++)n=this.mt[i]&this.UPPER_MASK|this.mt[i+1]&this.LOWER_MASK,this.mt[i]=this.mt[i+this.M]^n>>>1^t[1&n];for(;i<this.N-1;i++)n=this.mt[i]&this.UPPER_MASK|this.mt[i+1]&this.LOWER_MASK,this.mt[i]=this.mt[i+(this.M-this.N)]^n>>>1^t[1&n];n=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK,this.mt[this.N-1]=this.mt[this.M-1]^n>>>1^t[1&n],this.mti=0}return n=this.mt[this.mti++],n^=n>>>11,n^=n<<7&2636928640,n^=n<<15&4022730752,(n^=n>>>18)>>>0},MersenneTwister.prototype.genrand_int31=function(){return this.genrand_int32()>>>1},MersenneTwister.prototype.genrand_real1=function(){return this.genrand_int32()*(1/4294967295)},MersenneTwister.prototype.random=function(){return this.genrand_int32()*(1/4294967296)},MersenneTwister.prototype.genrand_real3=function(){return(this.genrand_int32()+.5)*(1/4294967296)},MersenneTwister.prototype.genrand_res53=function(){return(67108864*(this.genrand_int32()>>>5)+(this.genrand_int32()>>>6))*(1/9007199254740992)};var $builtinmodule=function(n){var t={},i=new MersenneTwister,e=void 0;t.seed=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"seed\",arguments.length,0,1),n=Sk.builtin.asnum$(n),i=arguments.length>0?new MersenneTwister(n):new MersenneTwister,Sk.builtin.none.none$})),t.random=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"random\",arguments.length,0,0),new Sk.builtin.float_(i.genrand_res53())}));var toInt=function(n){return 0|n},randrange=function(n,t,e){var r,u,s;if(!Sk.builtin.checkInt(n))throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");if(void 0===t)return s=toInt(i.genrand_res53()*n),new Sk.builtin.int_(s);if(!Sk.builtin.checkInt(t))throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");if(void 0===e&&(e=1),r=t-n,1==e&&r>0)return s=n+toInt(i.genrand_res53()*r),new Sk.builtin.int_(s);if(1==e)throw new Sk.builtin.ValueError(\"empty range for randrange() (\"+n+\", \"+t+\", \"+r+\")\");if(!Sk.builtin.checkInt(e))throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");if(e>0)u=toInt((r+e-1)/e);else{if(!(e<0))throw new Sk.builtin.ValueError(\"zero step for randrange()\");u=toInt((r+e+1)/e)}if(u<=0)throw new Sk.builtin.ValueError(\"empty range for randrange()\");return s=n+e*toInt(i.genrand_res53()*u),new Sk.builtin.int_(s)};t.randint=new Sk.builtin.func((function(n,t){return Sk.builtin.pyCheckArgsLen(\"randint\",arguments.length,2,2),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),randrange(n,t+1)})),t.randrange=new Sk.builtin.func((function(n,t,i){return Sk.builtin.pyCheckArgsLen(\"randrange\",arguments.length,1,3),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),i=Sk.builtin.asnum$(i),randrange(n,t,i)})),t.uniform=new Sk.builtin.func((function(n,t){Sk.builtin.pyCheckArgsLen(\"uniform\",arguments.length,2,2),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t);var e=i.genrand_res53();const r=n+e*(t-n);return new Sk.builtin.float_(r)})),t.triangular=new Sk.builtin.func((function(n,t,e){var r,u,s;return Sk.builtin.pyCheckArgsLen(\"triangular\",arguments.length,2,3),Sk.builtin.pyCheckType(\"low\",\"number\",Sk.builtin.checkNumber(n)),Sk.builtin.pyCheckType(\"high\",\"number\",Sk.builtin.checkNumber(t)),(n=Sk.builtin.asnum$(n))>(t=Sk.builtin.asnum$(t))&&(s=n,n=t,t=s),void 0===e||e===Sk.builtin.none.none$?e=(t-n)/2:(Sk.builtin.pyCheckType(\"mode\",\"number\",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e)),u=(r=i.genrand_res53())<(e-n)/(t-n)?n+Math.sqrt(r*(t-n)*(e-n)):t-Math.sqrt((1-r)*(t-n)*(t-e)),new Sk.builtin.float_(u)}));var normalSample=function(n,t){var r,u,s,h,l;return void 0!==e?(l=e,e=void 0):(r=i.genrand_res53(),u=i.genrand_res53(),s=Math.sqrt(-2*Math.log(r)),h=2*Math.PI*u,l=s*Math.cos(h),e=s*Math.sin(h)),n+t*l};return t.gauss=new Sk.builtin.func((function(n,t){return Sk.builtin.pyCheckArgsLen(\"gauss\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(n)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(t)),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),new Sk.builtin.float_(normalSample(n,t))})),t.normalvariate=t.gauss,t.lognormvariate=new Sk.builtin.func((function(n,t){return Sk.builtin.pyCheckArgsLen(\"lognormvariate\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(n)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(t)),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),new Sk.builtin.float_(Math.exp(normalSample(n,t)))})),t.expovariate=new Sk.builtin.func((function(n){Sk.builtin.pyCheckArgsLen(\"expovariate\",arguments.length,1,1),Sk.builtin.pyCheckType(\"lambd\",\"number\",Sk.builtin.checkNumber(n)),n=Sk.builtin.asnum$(n);var t=i.genrand_res53();return new Sk.builtin.float_(-Math.log(t)/n)})),t.choice=new Sk.builtin.func((function(n){if(Sk.builtin.pyCheckArgsLen(\"choice\",arguments.length,1,1),Sk.builtin.pyCheckType(\"seq\",\"sequence\",Sk.builtin.checkSequence(n)),void 0!==n.sq$length){var t=new Sk.builtin.int_(toInt(i.genrand_res53()*n.sq$length()));return n.mp$subscript(t)}throw new Sk.builtin.TypeError(\"object has no length\")})),t.shuffle=new Sk.builtin.func((function(n){if(Sk.builtin.pyCheckArgsLen(\"shuffle\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"sequence\",Sk.builtin.checkSequence(n)),n.constructor===Sk.builtin.list){const u=n.v;for(var t=u.length-1;t>0;t-=1){var e=u[r=toInt(i.genrand_res53()*(t+1))];u[r]=u[t],u[t]=e}}else{if(void 0===n.sq$length)throw new Sk.builtin.TypeError(\"object has no length\");if(void 0===n.mp$ass_subscript)throw new Sk.builtin.TypeError(\"object is immutable\");for(t=n.sq$length()-1;t>0;t-=1){var r=new Sk.builtin.int_(toInt(i.genrand_res53()*(t+1)));t=new Sk.builtin.int_(t);e=n.mp$subscript(r);n.mp$ass_subscript(r,n.mp$subscript(t)),n.mp$ass_subscript(t,e)}}return Sk.builtin.none.none$})),t.sample=new Sk.builtin.func((function(n,t){var e,r,u,s,h;for(Sk.builtin.pyCheckArgsLen(\"sample\",arguments.length,2,2),Sk.builtin.pyCheckType(\"population\",\"iterable\",Sk.builtin.checkIterable(n)),Sk.builtin.pyCheckType(\"k\",\"integer\",Sk.builtin.checkInt(t)),t=Sk.builtin.asnum$(t),h=[],e=0,s=(u=Sk.abstr.iter(n)).tp$iternext();void 0!==s;e++,s=u.tp$iternext())r=Math.floor(i.genrand_res53()*(e+1)),e<t?(r<e&&(h[e]=h[r]),h[r]=s):r<t&&(h[r]=s);if(e<t)throw new Sk.builtin.ValueError(\"sample larger than population\");return new Sk.builtin.list(h)})),t};","src/lib/re.js":"var $builtinmodule=function(name){var mod={__name__:new Sk.builtin.str(\"re\")},validGroups,convert,getFlags,_split,_findall,matchobj,_search,_match,regexobj;return mod.I=2,mod.IGNORECASE=2,mod.M=8,mod.MULTILINE=8,validGroups=[\"(?:\",\"(?=\",\"(?!\"],convert=function(n){var t,e;if(t=n.match(/\\(\\?./g))for(e=0;e<t.length;e++)if(-1==validGroups.indexOf(t[e]))throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"+t[e]+\"'\");return n.replace(\"/\\\\/g\",\"\\\\\\\\\"),n.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\")},getFlags=function(n){var t=\"g\";return(n&mod.IGNORECASE)==mod.IGNORECASE&&(t+=\"i\"),(n&mod.MULTILINE)==mod.MULTILINE&&(t+=\"m\"),t},_split=function(n,t,e,r){var l,u,s,a,o,c,b,f,k;if(Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,4),!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===e&&(e=0),!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"maxsplit must be a number\");if(void 0===r&&(r=0),!Sk.builtin.checkNumber(r))throw new Sk.builtin.TypeError(\"flags must be a number\");for(e=Sk.builtin.asnum$(e),l=Sk.ffi.unwrapo(n),u=Sk.ffi.unwrapo(t),s=!(null===(l=convert(l)).match(/^\\(.*\\)$/)),a=getFlags(r),o=new RegExp(l,a),c=[],f=0,k=0;null!=(b=o.exec(u))&&b.index!==o.lastIndex&&(c.push(new Sk.builtin.str(u.substring(f,b.index))),s&&c.push(new Sk.builtin.str(b[0])),f=o.lastIndex,k+=1,!(e&&k>=e)););return c.push(new Sk.builtin.str(u.substring(f))),new Sk.builtin.list(c)},_split.co_varnames=[\"pattern\",\"string\",\"maxsplit\",\"flags\"],_split.$defaults=[new Sk.builtin.int_(0),new Sk.builtin.int_(0)],mod.split=new Sk.builtin.func(_split),_findall=function(n,t,e){var r,l,u,s,a,o;if(Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,3),!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===e&&(e=0),!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"flags must be a number\");if(r=Sk.ffi.unwrapo(n),l=Sk.ffi.unwrapo(t),r=convert(r),u=getFlags(e),s=new RegExp(r,u),r.match(/\\$/)){var c=new RegExp(/\\n$/);l.match(c)&&(l=l.slice(0,-1))}for(a=[];null!=(o=s.exec(l));){if(o.length<2)a.push(new Sk.builtin.str(o[0]));else if(2==o.length)a.push(new Sk.builtin.str(o[1]));else{for(var b=[],f=1;f<o.length;f++)b.push(new Sk.builtin.str(o[f]));a.push(new Sk.builtin.tuple(b))}o.index===s.lastIndex&&(s.lastIndex+=1)}return new Sk.builtin.list(a)},_findall.co_varnames=[\"pattern\",\"string\",\"flags\"],_findall.$defaults=[new Sk.builtin.int_(0)],mod.findall=new Sk.builtin.func(_findall),matchobj=function(n,t){t.__init__=new Sk.builtin.func((function(n,t,e,r){return n.thematch=t,n.re=e,n.string=r,Sk.builtin.none.none$})),t.groups=new Sk.builtin.func((function(n){var t=n.thematch.v.slice(1);return new Sk.builtin.tuple(t)})),t.group=new Sk.builtin.func((function(n,t){if((t=void 0===t?0:Sk.builtin.asnum$(t))>=n.thematch.v.length)throw new Sk.builtin.IndexError(\"Index out of range: \"+t);return n.thematch.v[t]}))},mod.MatchObject=Sk.misceval.buildClass(mod,matchobj,\"MatchObject\",[]),mod._findre=function(res,string){var matches,sitem,retval;res=res.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\");var re=eval(res),patt=new RegExp(\"\\n$\"),str=Sk.ffi.remapToJs(string);if(matches=str.match(patt)?str.slice(0,-1).match(re):str.match(re),retval=new Sk.builtin.list,null==matches)return retval;for(var i=0;i<matches.length;++i)sitem=new Sk.builtin.str(matches[i]),retval.v.push(sitem);return retval},_search=function(n,t,e){var r;if(Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,3),!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===e&&(e=0),!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"flags must be a number\");r=\"/\"+n.v.replace(/\\//g,\"\\\\/\")+\"/\";const l=mod._findre(r,t);return l.v.length<1?Sk.builtin.none.none$:Sk.misceval.callsimArray(mod.MatchObject,[l,n,t])},_search.co_varnames=[\"pattern\",\"string\",\"flags\"],_search.$defaults=[new Sk.builtin.int_(0)],mod.search=new Sk.builtin.func(_search),_match=function(n,t,e){var r;if(Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,3),!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===e&&(e=0),!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"flags must be a number\");const l=Sk.ffi.remapToJs(n);r=\"/^\"+l.replace(/\\//g,\"\\\\/\")+\"/\";const u=mod._findre(r,t);return Sk.ffi.remapToJs(u).length<1?Sk.builtin.none.none$:Sk.misceval.callsimArray(mod.MatchObject,[u,n,t])},_match.co_varnames=[\"pattern\",\"string\",\"flags\"],_match.$defaults=[new Sk.builtin.int_(0)],mod.match=new Sk.builtin.func(_match),regexobj=function(n,t){var e,r,l,u,s,a;t.__init__=new Sk.builtin.func((function(n,t,e){return n.re=t,n.flags=void 0===e?0:e,Sk.builtin.none.none$})),a=new Sk.builtin.func((function(n){var t=\"re.compile('\"+Sk.ffi.remapToJs(n.re)+\"')\";return Sk.ffi.remapToPy(t.substring(0,212))})),t.__str__=a,t.__repr__=a,e=function(n,t,e){var r=Sk.ffi.remapToJs(n),l=null==t?0:Sk.ffi.remapToJs(t),u=null==e?r.length:Sk.ffi.remapToJs(e);return\"^\"==l&&(l=r.indexOf(\"\\n\")+1),null===u&&(u=r.length),Sk.ffi.remapToPy(r.substring(l,u))},(r=function(n,t,r,l){Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,4);var u=e(t,r,l);return _search(n.re,u,n.flags)}).co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],r.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],t.search=new Sk.builtin.func(r),(l=function(n,t,r,l){Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,4);var u=e(t,r,l);return _match(n.re,u,n.flags)}).co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],l.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],t.match=new Sk.builtin.func(l),(u=function(n,t,e){if(Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,3),void 0===e&&(e=0),!Sk.builtin.checkInt(e))throw new Sk.builtin.TypeError(\"maxsplit must be an integer\");return _split(n.re,t,e,n.flags)}).co_varnames=[\"self\",\"string\",\"maxsplit\"],u.$defaults=[new Sk.builtin.int_(0)],t.split=new Sk.builtin.func(u),(s=function(n,t,r,l){Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,4);var u=e(t,r,l);return _findall(n.re,u,n.flags)}).co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],s.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],t.findall=new Sk.builtin.func(s)},mod.RegexObject=Sk.misceval.buildClass(mod,regexobj,\"RegexObject\",[]),mod.compile=new Sk.builtin.func((function(n,t){if(Sk.builtin.pyCheckArgsLen(\"compile\",arguments.length,1,2),!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(void 0===t&&(t=0),!Sk.builtin.checkNumber(t))throw new Sk.builtin.TypeError(\"flags must be a number\");return Sk.misceval.callsimArray(mod.RegexObject,[n,t])})),mod.purge=new Sk.builtin.func((function(){})),mod};","src/lib/signal.js":"var $builtinmodule=function(n){var i={};return i.SIG_DFL=new Sk.builtin.int_(0),i.SIG_IGN=new Sk.builtin.int_(1),i.CTRL_C_EVENT=new Sk.builtin.int_(0),i.CTRL_BREAK_EVENT=new Sk.builtin.int_(0),i.NSIG=new Sk.builtin.int_(23),i.SIGHUP=new Sk.builtin.int_(1),i.SIGNINT=new Sk.builtin.int_(2),i.SIGILL=new Sk.builtin.int_(4),i.SIGFPE=new Sk.builtin.int_(8),i.SIGKILL=new Sk.builtin.int_(9),i.SIGSEGV=new Sk.builtin.int_(11),i.SIGTERM=new Sk.builtin.int_(15),i.SIGBREAK=new Sk.builtin.int_(21),i.SIGABRT=new Sk.builtin.int_(22),i.pause=new Sk.builtin.func((function(){Sk.builtin.pyCheckArgsLen(\"pause\",arguments.length,0,0);var n=new Sk.misceval.Suspension;return n.resume=function(){return Sk.builtin.none.none$},n.data={type:\"Sk.promise\",promise:new Promise((function(n,i){if(null!=Sk.signals&&Sk.signals.addEventListener){Sk.signals.addEventListener((function handleSignal(i){Sk.signals.removeEventListener(handleSignal),n()}))}else console.warn(\"signal.pause() not supported\"),Sk.misceval.print_(\"signal.pause() not supported\"),n()}))},n})),i.signal=new Sk.builtin.func((function(){throw new Sk.builtin.NotImplementedError(\"signal.signal is not supported.\")})),i};","src/lib/string.js":"var $builtinmodule=function(i){var t={};return t.ascii_lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),t.ascii_uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),t.ascii_letters=new Sk.builtin.str(t.ascii_lowercase.v+t.ascii_uppercase.v),t.lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),t.uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),t.letters=new Sk.builtin.str(t.lowercase.v+t.uppercase.v),t.digits=new Sk.builtin.str(\"0123456789\"),t.hexdigits=new Sk.builtin.str(\"0123456789abcdefABCDEF\"),t.octdigits=new Sk.builtin.str(\"01234567\"),t.punctuation=new Sk.builtin.str(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"),t.whitespace=new Sk.builtin.str(\"\\t\\n\\v\\f\\r \"),t.printable=new Sk.builtin.str(t.digits.v+t.letters.v+t.punctuation.v+\" \\t\\n\\r\\v\\f\"),t.split=new Sk.builtin.func((function(...i){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.split,i)})),t.capitalize=new Sk.builtin.func((function(i){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.capitalize,[i])})),t.join=new Sk.builtin.func((function(i,t){return void 0===t&&(t=new Sk.builtin.str(\" \")),Sk.misceval.callsimArray(Sk.builtin.str.prototype.join,[t,i])})),t.capwords=new Sk.builtin.func((function(i,n){if(Sk.builtin.pyCheckArgsLen(\"capwords\",arguments.length,1,2),!Sk.builtin.checkString(i))throw new Sk.builtin.TypeError(\"s must be a string\");if(void 0===n&&(n=new Sk.builtin.str(\" \")),!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError(\"sep must be a string\");for(var e=Sk.misceval.callsimArray(t.split,[i,n]).v,r=[],l=0;l<e.length;l++){var s=e[l],u=Sk.misceval.callsimArray(t.capitalize,[s]);r.push(u)}return Sk.misceval.callsimArray(t.join,[new Sk.builtin.list(r),n])})),t};","src/lib/time.js":"var $builtinmodule=function(t){var e={};e.__package__=new Sk.builtin.str(\"\");var n=Sk.builtin.make_structseq(\"time\",\"struct_time\",{tm_year:\"year, for example, 1993\",tm_mon:\"month of year, range [1, 12]\",tm_mday:\"day of month, range [1, 31]\",tm_hour:\"hours, range [0, 23]\",tm_min:\"minutes, range [0, 59]\",tm_sec:\"seconds, range [0, 61]\",tm_wday:\"day of week, range [0, 6], Monday is 0\",tm_yday:\"day of year, range [1, 366]\",tm_isdst:\"1 if summer time is in effect, 0 if not, and -1 if unknown\"},{tm_zone:\"abbreviation of timezone name\",tm_gmtoff:\"offset from UTC in seconds\"});function check_struct_time(t){if(!(t instanceof n))throw new Sk.builtin.TypeError(\"Required argument 'struct_time' must be of type: 'struct_time'\");var e,i=t.v.length,u=t.v;for(e=0;e<i;++e)if(!Sk.builtin.checkInt(u[e]))throw new Sk.builtin.TypeError(\"struct_time may only contain integers\");return!0}function padLeft(t,e,n){var i=t.toString();return Array(e-i.length+1).join(n||\" \")+i}function getDayOfYear(t,e){var n=(e=e||!1)?t.getUTCMonth():t.getMonth(),i=e?t.getUTCDate():t.getDate(),u=[0,31,59,90,120,151,181,212,243,273,304,334][n]+i;return n>1&&function isLeapYear(t){return 0==(3&t)&&(t%100!=0||t%400==0)}(e?t.getUTCFullYear():t.getFullYear())&&u++,u}function stdTimezoneOffset(){var t=new Date(2002,0,1),e=new Date(2002,6,1);return Math.max(t.getTimezoneOffset(),e.getTimezoneOffset())}function dst(t){return t.getTimezoneOffset()<stdTimezoneOffset()}function timeZoneName(t){var e,n=/\\((.*)\\)/.exec(t.toString());if(null!=Sk.global.navigator&&(e=Sk.global.navigator.userLanguage||Sk.global.navigator.language),n&&n.length>1)return n[1];if(void 0===e)return null;try{return(n=t.toLocaleString(e,{timeZoneName:\"short\"}).split(\" \"))[n.length-1]}catch(i){return null}}function from_seconds(t,e){var i=new Date;if(t){Sk.builtin.pyCheckType(\"secs\",\"number\",Sk.builtin.checkNumber(t));var u=Sk.builtin.asnum$(t);i.setTime(1e3*u)}return function date_to_struct_time(t,e){let i;if(e=e||!1)i=[new Sk.builtin.str(\"UTC\"),new Sk.builtin.int_(0)];else{var u=-t.getTimezoneOffset()/60,r=(u<0?\"-\":\"+\")+(\"\"+Math.abs(u)).padStart(2,\"0\");i=[new Sk.builtin.str(r),new Sk.builtin.int_(3600*u)]}return new n([Sk.builtin.assk$(e?t.getUTCFullYear():t.getFullYear()),Sk.builtin.assk$((e?t.getUTCMonth():t.getMonth())+1),Sk.builtin.assk$(e?t.getUTCDate():t.getDate()),Sk.builtin.assk$(e?t.getUTCHours():t.getHours()),Sk.builtin.assk$(e?t.getUTCMinutes():t.getMinutes()),Sk.builtin.assk$(e?t.getUTCSeconds():t.getSeconds()),Sk.builtin.assk$(((e?t.getUTCDay():t.getDay())+6)%7),Sk.builtin.assk$(getDayOfYear(t,e)),Sk.builtin.assk$(e?0:dst(t)?1:0)],i)}(i,e)}e.struct_time=n,e.time=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"time\",arguments.length,0,0),new Sk.builtin.float_(Date.now()/1e3)})),e.sleep=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"sleep\",arguments.length,1,1),Sk.builtin.pyCheckType(\"delay\",\"float\",Sk.builtin.checkNumber(t)),new Sk.misceval.promiseToSuspension(new Promise((function(e){Sk.setTimeout((function(){e(Sk.builtin.none.none$)}),1e3*Sk.ffi.remapToJs(t))})))})),e.localtime=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"localtime\",arguments.length,0,1),from_seconds(t,!1)})),e.gmtime=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"gmtime\",arguments.length,0,1),from_seconds(t,!0)}));var i=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],u=[\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"];function asctime_f(t){if(Sk.builtin.pyCheckArgsLen(\"asctime\",arguments.length,0,1),!t||Sk.builtin.checkNone(t)?t=from_seconds():t instanceof n||(t=new n(t)),t instanceof Sk.builtin.tuple&&9==t.v.length){var e=[];return e.push(u[Sk.builtin.asnum$(t.v[6])]),e.push(i[Sk.builtin.asnum$(t.v[1])-1]),e.push(padLeft(Sk.builtin.asnum$(t.v[2]).toString(),2,\"0\")),e.push(padLeft(Sk.builtin.asnum$(t.v[3]).toString(),2,\"0\")+\":\"+padLeft(Sk.builtin.asnum$(t.v[4]).toString(),2,\"0\")+\":\"+padLeft(Sk.builtin.asnum$(t.v[5]).toString(),2,\"0\")),e.push(padLeft(Sk.builtin.asnum$(t.v[0]).toString(),4,\"0\")),new Sk.builtin.str(e.join(\" \"))}}function mktime_f(t){if(Sk.builtin.pyCheckArgsLen(\"mktime\",arguments.length,1,1),t instanceof Sk.builtin.tuple&&9==t.v.length){var e=new Date(Sk.builtin.asnum$(t.v[0]),Sk.builtin.asnum$(t.v[1])-1,Sk.builtin.asnum$(t.v[2]),Sk.builtin.asnum$(t.v[3]),Sk.builtin.asnum$(t.v[4]),Sk.builtin.asnum$(t.v[5]));return Sk.builtin.assk$(e.getTime()/1e3,void 0)}throw new Sk.builtin.TypeError(\"mktime() requires a struct_time or 9-tuple\")}e.asctime=new Sk.builtin.func(asctime_f),e.ctime=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"ctime\",arguments.length,0,1),asctime_f(from_seconds(t))})),e.mktime=new Sk.builtin.func(mktime_f),e.timezone=new Sk.builtin.int_(60*stdTimezoneOffset()),e.altzone=new Sk.builtin.int_(60*function altTimezoneOffset(){var t=new Date(2002,0,1),e=new Date(2002,6,1);return Math.min(t.getTimezoneOffset(),e.getTimezoneOffset())}()),e.daylight=new Sk.builtin.int_(function daylight_check(){const t=new Date(2002,0,1),e=new Date(2002,6,1);return t.getTimezoneOffset()!=e.getTimezoneOffset()}()?1:0),e.tzname=new Sk.builtin.tuple(function timeZoneNames(){var t=new Date(2002,0,1),e=new Date(2002,6,1);return dst(t)?[new Sk.builtin.str(timeZoneName(e)),new Sk.builtin.str(timeZoneName(t))]:[new Sk.builtin.str(timeZoneName(t)),new Sk.builtin.str(timeZoneName(e))]}()),e.accept2dyear=Sk.builtin.assk$(1),e.clock=new Sk.builtin.func((function(){var t=0;return t=Sk.global.performance&&Sk.global.performance.now?performance.now()/1e3:(new Date).getTime()/1e3,new Sk.builtin.float_(t)})),e.strftime=new Sk.builtin.func((function strftime_f(t,e){var i;if(Sk.builtin.pyCheckArgsLen(\"strftime\",arguments.length,1,2),!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError(\"format must be a string\");return e?e instanceof n||(e=new n(e)):e=from_seconds(),check_struct_time(e),i=Sk.ffi.remapToJs(t),Sk.ffi.remapToPy(Sk.global.strftime(i,new Date(1e3*mktime_f(e).v)))})),e.tzset=new Sk.builtin.func((function tzset_f(){throw new Sk.builtin.NotImplementedError(\"time.tzset() is not yet implemented\")}));let r=null;return e.strptime=new Sk.builtin.func((function strptime_f(...t){return Sk.builtin.pyCheckArgsLen(\"strptime\",t.length,1,2),null===r?Sk.misceval.chain(Sk.importModule(\"_strptime\",!1,!0),(e=>(r=e.tp$getattr(new Sk.builtin.str(\"_strptime_time\")),r.tp$call(t)))):r.tp$call(t)})),e};","src/lib/token.js":"var $builtinmodule=function(n){var e={};e.__file__=new Sk.builtin.str(\"/src/lib/token.py\");const t=[];for(let i in Sk.token.tok_name){const n=Sk.token.tok_name[i].slice(2),k=parseInt(i,10);t.push(Sk.ffi.remapToPy(k)),t.push(Sk.ffi.remapToPy(n)),e[n]=Sk.ffi.remapToPy(k)}return e.tok_name=new Sk.builtin.dict(t),e.ISTERMINAL=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"ISTERMINAL\",arguments.length,1,1),Sk.token.ISTERMINAL(Sk.ffi.remapToJs(n))})),e.ISNONTERMINAL=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"ISNONTERMINAL\",arguments.length,1,1),Sk.token.ISNONTERMINAL(Sk.ffi.remapToJs(n))})),e.ISEOF=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"ISEOF\",arguments.length,1,1),Sk.token.ISEOF(Sk.ffi.remapToJs(n))})),e};","src/lib/tokenize.js":"var $builtinmodule=function(e){var i={};return i.tokenize=new Sk.builtin.func((function(e){Sk.builtin.pyCheckArgsLen(\"tokenize\",1,1),Sk.builtin.checkFunction(e);const i=[];return Sk._tokenize(\"<stdin>\",(function jsReadline(){const i=Sk.misceval.callsimArray(e);return Sk.ffi.remapToJs(i)}),\"UTF-8\",(function receiveToken(e){i.push(new Sk.builtin.tuple([Sk.ffi.remapToPy(e.type),Sk.ffi.remapToPy(e.string),new Sk.builtin.tuple([Sk.ffi.remapToPy(e.start[0]),Sk.ffi.remapToPy(e.start[1])]),new Sk.builtin.tuple([Sk.ffi.remapToPy(e.end[0]),Sk.ffi.remapToPy(e.end[1])]),Sk.ffi.remapToPy(e.line)]))})),new Sk.builtin.list(i)})),i};","src/lib/turtle.js":"var $builtinmodule=function(e){\"use strict\";var t=function getConfiguredTarget(){var e,t;for(t=\"string\"==typeof(e=Sk.TurtleGraphics&&Sk.TurtleGraphics.target||\"turtle\")?document.getElementById(e):e;t.firstChild;)t.removeChild(t.firstChild);return t}();return t.turtleInstance?t.turtleInstance.reset():t.turtleInstance=function generateTurtleModule(e){var t,n,r,i,s,a,o,l,u={__name__:new Sk.builtin.str(\"turtle\")},c=!0,h=1e3/30,d={},f={},_={target:\"turtle\",width:400,height:400,worldWidth:0,worldHeight:0,animate:!0,bufferSize:0,allowUndo:!0,assets:{}};function getAsset(e){var t=i.assets,n=\"function\"==typeof t?t(e):t[e];return\"string\"==typeof n?new Promise((function(t,r){var s=new Image;s.onload=function(){i.assets[e]=this,t(s)},s.onerror=function(){r(new Error(\"Missing asset: \"+n))},s.src=n})):new InstantPromise(void 0,n)}function InstantPromise(e,t){this.lastResult=t,this.lastError=e}function FrameManager(){this.reset()}function getFrameManager(){return o||(o=new FrameManager),o}function MouseHandler(){var e=this;for(var t in this._target=getTarget(),this._managers={},this._handlers={mousedown:function(t){e.onEvent(\"mousedown\",t)},mouseup:function(t){e.onEvent(\"mouseup\",t)},mousemove:function(t){e.onEvent(\"mousemove\",t)}},this._handlers)this._target.addEventListener(t,this._handlers[t])}function EventManager(e,t){this._type=e,this._target=t,this._handlers=void 0,function getMouseHandler(){return a||(a=new MouseHandler),a}().addManager(e,this)}function Turtle(e){if(getFrameManager().addTurtle(this),this._screen=getScreen(),this._managers={},this._shape=e.v,!d.hasOwnProperty(this._shape))throw new Sk.builtin.ValueError(\"Shape:'\"+this._shape+\"' not in default shape, please check shape again!\");this.reset()}function Screen(){var e,t;this._frames=1,this._delay=void 0,this._bgcolor=\"none\",this._mode=\"standard\",this._managers={},this._keyLogger={},e=(i.worldWidth||i.width||getWidth())/2,t=(i.worldHeight||i.height||getHeight())/2,this.setUpWorld(-e,-t,e,t)}function ensureAnonymous(){return s||(s=Sk.misceval.callsimArray(u.Turtle)),s.instance}function getTarget(){return e}function getScreen(){return r||(r=new Screen),r}function getWidth(){return 0|(r&&r._width||i.width||getTarget().clientWidth||_.width)}function getHeight(){return 0|(r&&r._height||i.height||getTarget().clientHeight||_.height)}function createLayer(e,t){var n,r=document.createElement(\"canvas\"),i=getWidth(),s=getHeight(),a=getTarget().firstChild?-s+\"px\":\"0\";return r.width=i,r.height=s,r.style.position=\"relative\",r.style.display=\"block\",r.style.setProperty(\"margin-top\",a),r.style.setProperty(\"z-index\",e),t&&(r.style.display=\"none\"),getTarget().appendChild(r),(n=r.getContext(\"2d\")).lineCap=\"round\",n.lineJoin=\"round\",applyWorld(getScreen(),n),n}function cancelAnimationFrame(){t&&((window.cancelAnimationFrame||window.mozCancelAnimationFrame)(t),t=void 0),n&&(window.clearTimeout(n),n=void 0)}function applyWorld(e,t){var n=e.llx,r=(e.lly,e.urx,e.ury),i=e.xScale,s=e.yScale;t&&(clearLayer(t),t.restore(),t.save(),t.scale(1/i,1/s),t.translate(-n,-r))}function pushUndo(e){var t,n,r;if(i.allowUndo&&e._bufferSize){for(e._undoBuffer||(e._undoBuffer=[]);e._undoBuffer.length>e._bufferSize;)e._undoBuffer.shift();for(n={},t=\"x y angle radians color fill down filling shown shape size\".split(\" \"),r=0;r<t.length;r++)n[t[r]]=e[\"_\"+t[r]];return e._undoBuffer.push(n),e.addUpdate((function(){n.fillBuffer=this.fillBuffer?this.fillBuffer.slice():void 0,e._paper&&e._paper.canvas&&(n.image=e._paper.canvas.toDataURL())}),!1)}}e.hasAttribute(\"tabindex\")||e.setAttribute(\"tabindex\",0),f.FLOAT=function(e){return new Sk.builtin.float_(e)},f.COLOR=function(e){if(\"string\"==typeof e)return new Sk.builtin.str(e);for(var t=0;t<3;t++)e[t]=Sk.builtin.assk$(e[t]);return 4===e.length&&(e[3]=new Sk.builtin.float_(e[3])),new Sk.builtin.tuple(e)},f.TURTLE_LIST=function(e){for(var t=[],n=0;n<e.length;n++)t.push(e[n].skInstance);return new Sk.builtin.tuple(t)},d.arrow=[[-10,0],[10,0],[0,10]],d.square=[[10,-10],[10,10],[-10,10],[-10,-10]],d.triangle=[[10,-5.77],[0,11.55],[-10,-5.77]],d.classic=[[0,0],[-5,-9],[0,-7],[5,-9]],d.turtle=[[0,16],[-2,14],[-1,10],[-4,7],[-7,9],[-9,8],[-6,5],[-7,1],[-5,-3],[-8,-6],[-6,-8],[-4,-5],[0,-7],[4,-5],[6,-8],[8,-6],[5,-3],[7,1],[6,5],[9,8],[7,9],[4,7],[1,10],[2,14]],d.circle=[[10,0],[9.51,3.09],[8.09,5.88],[5.88,8.09],[3.09,9.51],[0,10],[-3.09,9.51],[-5.88,8.09],[-8.09,5.88],[-9.51,3.09],[-10,0],[-9.51,-3.09],[-8.09,-5.88],[-5.88,-8.09],[-3.09,-9.51],[-0,-10],[3.09,-9.51],[5.88,-8.09],[8.09,-5.88],[9.51,-3.09]],i=function(){var e;for(e in Sk.TurtleGraphics||(Sk.TurtleGraphics={}),_)Sk.TurtleGraphics.hasOwnProperty(e)||(Sk.TurtleGraphics[e]=_[e]);return Sk.TurtleGraphics}(),InstantPromise.prototype.then=function(e){if(this.lastError)return this;try{this.lastResult=e(this.lastResult)}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this},InstantPromise.prototype.catch=function(e){if(this.lastError)try{this.lastResult=e(this.lastError),this.lastError=void 0}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this},function(e){var r,s;function animationFrame(e){return i.animate?!e&&r?r:function(t){return n=window.setTimeout(t,e||h)}:function(e){e()}}(s=window.requestAnimationFrame||window.mozRequestAnimationFrame)&&(r=function(e){return t=s(e)}),e.willRenderNext=function(){return!(!this._buffer||this._frameCount+1!==this.frameBuffer())},e.turtles=function(){return this._turtles},e.addTurtle=function(e){this._turtles.push(e)},e.reset=function(){if(this._turtles)for(var e=this._turtles.length;--e>=0;)this._turtles[e].reset();this._turtles=[],this._frames=[],this._frameCount=0,this._buffer=1,this._rate=0,this._animationFrame=animationFrame()},e.addFrame=function(e,t){return t&&(this._frameCount+=1),this.frames().push(e),!i.animate||this._buffer&&this._frameCount===this.frameBuffer()?this.update():new InstantPromise},e.frames=function(){return this._frames},e.frameBuffer=function(e){return\"number\"==typeof e&&(this._buffer=0|e,e&&e<=this._frameCount)?this.update():this._buffer},e.refreshInterval=function(e){return\"number\"==typeof e&&(this._rate=0|e,this._animationFrame=animationFrame(e)),this._rate},e.update=function(){return this._frames&&this._frames.length?this.requestAnimationFrame():new InstantPromise},e.requestAnimationFrame=function(){var e,t,n=this._frames,r=this._animationFrame,i=this._turtles,s=getScreen().spriteLayer();return this._frames=[],this._frameCount=0,new Promise((function(a){r((function paint(){for(t=0;t<n.length;t++)n[t]&&n[t]();for(clearLayer(s),t=0;t<i.length;t++)(e=i[t]).getState().shown&&drawTurtle(e.getState(),s);a()}))}))}}(FrameManager.prototype),(l=MouseHandler.prototype).onEvent=function(e,t){var n,r,i,s,a,o=this._managers[e],l=this._managers.mousemove,u=!1;function computeCoordinates(){if(!u){var e=getScreen(),a=e.spriteLayer().canvas.getBoundingClientRect();n=t.clientX-a.left|0,r=t.clientY-a.top|0,i=n*e.xScale+e.llx,s=r*e.yScale+e.ury,u=!0}}if((\"mousedown\"===e||\"mouseup\"===e)&&l&&l.length)for(computeCoordinates(),a=l.length;--a>=0;)l[a].test(n,r,i,s)&&l[a].canMove(\"mousedown\"===e);if(o&&o.length)for(computeCoordinates(),a=o.length;--a>=0;)(\"mousemove\"===e&&o[a].canMove()&&o[a].test(n,r,i,s)||\"mousedown\"===e&&o[a].test(n,r,i,s))&&o[a].trigger([i,s])},l.reset=function(){this._managers={}},l.addManager=function(e,t){this._managers[e]||(this._managers[e]=[]),this._managers[e].push(t)},function(e){e.reset=function(){this._handlers=void 0},e.canMove=function(e){return!(!this._target||!this._target.hitTest)&&(void 0!==e&&(this._target.hitTest.hit=e),this._target.hitTest.hit)},e.test=function(e,t,n,r){return this._target&&this._target.hitTest?this._target.hitTest(e,t,n,r):!!this._target},e.trigger=function(e){var t,n=this._handlers;if(n&&n.length)for(t=0;t<n.length;t++)n[t].apply({},e)},e.addHandler=function(e,t){var n=this._handlers;if(!t&&n&&n.length)for(;n.shift(););\"function\"==typeof e?(n||(n=this._handlers=[]),n.push(e)):n&&!n.length&&this.reset()}}(EventManager.prototype),Turtle.RADIANS=2*Math.PI,function(e){function circleRotate(e,t,n){return function(){return e.addUpdate(void 0,!1,{angle:t,radians:n})}}function circleSegment(e,t,n,r,i,s){return function(){return e.translate(t,n,r,i,s,!0)}}e.hitTest=function(e,t,n,r){var i=getScreen().hitTestLayer();clearLayer(i),drawTurtle(this.getState(),i);var s=i.getImageData(e,t,1,1).data;return s[3]||s[0]||s[1]||s[2]},e.addUpdate=function(e,t,n){var r=this.getState(),i=Array.prototype.slice.call(arguments,n?2:3);return getFrameManager().addFrame((function(){if(e&&e.apply(r,i),n)for(var t in n)r[t]=n[t]}),t)},e.getState=function(){var e=this;return this._state||(this._state={x:this._x,y:this._y,angle:this._angle,radians:this._radians,shape:this._shape,color:this._color,fill:this._fill,filling:this._filling,size:this._size,speed:this._computed_speed,down:this._down,shown:this._shown,colorMode:this._colorMode,context:function(){return e.getPaper()}}),this._state},e.translate=function(e,t,n,r,i,s){var a=this;return function translate(e,t,n,r,i,s,a){var o,l=e._computed_speed,u=getScreen(),c=Math.abs(u.xScale),h=Math.abs(u.yScale),d=t,f=n,_=Math.sqrt(r*r*c+i*i*h),g=l?Math.round(Math.max(1,_/l)):1,p=r/g,m=i/g,v=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise,y=!(!l&&a);for(e.addUpdate((function(){this.filling&&this.fillBuffer.push({x:this.x,y:this.y,stroke:this.down,color:this.color,size:this.size})}),!1),o=0;o<g;o++)d=t+p*(o+1),f=n+m*(o+1),v=v.then(partialTranslate(e,d,f,s,y)),s=!1;return v.then((function(){return[t+r,n+i]}))}(this,e,t,n,r,i,s).then((function(e){a._x=e[0],a._y=e[1]}))},e.rotate=function(e,t,n){var r=this;return function rotate(e,t,n,r){var i,s=e._computed_speed,a=n/e._fullCircle*360,o=s?Math.round(Math.max(1,Math.abs(a)/s)):1,l=n/o,u={},c=!(!s&&r),h=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise;for(i=0;i<o;i++)calculateHeading(e,t+l*(i+1),u),h=h.then(partialRotate(e,u.angle,u.radians,c));return h.then((function(){return calculateHeading(e,t+n)}))}(this,e,t,n).then((function(e){r._angle=e.angle,r._radians=e.radians}))},e.queueMoveBy=function(e,t,n,r){var i=Math.cos(n)*r,s=Math.sin(n)*r;return this.translate(e,t,i,s,!0)},e.queueTurnTo=function(e,t){return(t%=this._fullCircle)<0&&(t+=this._fullCircle),this.rotate(e,t-e)},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new EventManager(e,this)),this._managers[e]},e.getPaper=function(){return this._paper||(this._paper=createLayer(2))},e.reset=function(){for(var e in this._x=0,this._y=0,this._radians=0,this._angle=0,this._shown=!0,this._down=!0,this._color=\"black\",this._fill=\"black\",this._size=1,this._filling=!1,this._undoBuffer=[],this._speed=3,this._computed_speed=6,this._colorMode=1,this._state=void 0,this._managers)this._managers[e].reset();this._isRadians=!1,this._fullCircle=360,this._bufferSize=\"number\"==typeof i.bufferSize?i.bufferSize:0,removeLayer(this._paper),this._paper=void 0},e.$degrees=function(e){return e=\"number\"==typeof e?Math.abs(e):360,this._isRadians=!1,e&&this._fullCircle?this._angle=this._angle/this._fullCircle*e:this._angle=this._radians=0,this._fullCircle=e,this.addUpdate(void 0,!1,{angle:this._angle,radians:this._radians})},e.$degrees.minArgs=0,e.$degrees.co_varnames=[\"fullcircle\"],e.$degrees.returnType=f.FLOAT,e.$radians=function(){return this._isRadians||(this._isRadians=!0,this._angle=this._radians,this._fullCircle=Turtle.RADIANS),this._angle},e.$radians.returnType=f.FLOAT,e.$position=e.$pos=function(){return[this.$xcor(),this.$ycor()]},e.$position.returnType=function(e){return new Sk.builtin.tuple([new Sk.builtin.float_(e[0]),new Sk.builtin.float_(e[1])])},e.$towards=function(e,t){var n=getCoordinates(e,t);return(Math.PI+Math.atan2(this._y-n.y,this._x-n.x))*(this._fullCircle/Turtle.RADIANS)},e.$towards.co_varnames=[\"x\",\"y\"],e.$towards.minArgs=1,e.$towards.returnType=f.FLOAT,e.$distance=function(e,t){var n=getCoordinates(e,t),r=n.x-this._x,i=n.y-this._y;return Math.sqrt(r*r+i*i)},e.$distance.co_varnames=[\"x\",\"y\"],e.$distance.minArgs=1,e.$distance.returnType=f.FLOAT,e.$heading=function(){return Math.abs(this._angle)<1e-13?0:this._angle},e.$heading.returnType=f.FLOAT,e.$xcor=function(){return Math.abs(this._x)<1e-13?0:this._x},e.$xcor.returnType=f.FLOAT,e.$ycor=function(){return Math.abs(this._y)<1e-13?0:this._y},e.$ycor.returnType=f.FLOAT,e.$forward=e.$fd=function(e){return pushUndo(this),this.queueMoveBy(this._x,this._y,this._radians,e)},e.$forward.co_varnames=e.$fd.co_varnames=[\"distance\"],e.$undo=function(){!function popUndo(e){var t;if(e._bufferSize&&e._undoBuffer&&(t=e._undoBuffer.pop())){for(var n in t)\"image\"!==n&&\"fillBuffer\"!==n&&(e[\"_\"+n]=t[n]);e.addUpdate((function(){t.image&&(g.src=t.image),clearLayer(this.context(),!1,g),delete t.image}),!0,t)}}(this)},e.$undobufferentries=function(){return this._undoBuffer.length},e.$setundobuffer=function(e){this._bufferSize=\"number\"==typeof e?Math.min(Math.abs(e),1e3):0},e.$setundobuffer.co_varnames=[\"size\"],e.$backward=e.$back=e.$bk=function(e){return pushUndo(this),this.queueMoveBy(this._x,this._y,this._radians,-e)},e.$backward.co_varnames=e.$back.co_varnames=e.$bk.co_varnames=[\"distance\"],e.$goto_$rw$=e.$setpos=e.$setposition=function(e,t){var n=getCoordinates(e,t);return pushUndo(this),this.translate(this._x,this._y,n.x-this._x,n.y-this._y,!0)},e.$goto_$rw$.co_varnames=e.$setpos.co_varnames=e.$setposition.co_varnames=[\"x\",\"y\"],e.$goto_$rw$.minArgs=e.$setpos.minArgs=e.$setposition.minArgs=1,e.$setx=function(e){return this.translate(this._x,this._y,e-this._x,0,!0)},e.$setx.co_varnames=[\"x\"],e.$sety=function(e){return this.translate(this._x,this._y,0,e-this._y,!0)},e.$sety.co_varnames=[\"y\"],e.$home=function(){var e=this,t=this._angle;return pushUndo(this),e.translate(this._x,this._y,-this._x,-this._y,!0).then((function(n){return e.queueTurnTo(t,0)})).then((function(e){}))},e.$right=e.$rt=function(e){return pushUndo(this),this.rotate(this._angle,-e)},e.$right.co_varnames=e.$rt.co_varnames=[\"angle\"],e.$left=e.$lt=function(e){return pushUndo(this),this.rotate(this._angle,e)},e.$left.co_varnames=e.$lt.co_varnames=[\"angle\"],e.$setheading=e.$seth=function(e){return pushUndo(this),this.queueTurnTo(this._angle,e)},e.$setheading.co_varnames=e.$seth.co_varnames=[\"angle\"],e.$circle=function(e,t,n){var r,i,s,a,o,l,u,c,h,d=this,f=this._x,_=this._y,g=this._angle,p={},m=1/getScreen().lineScale,v=!0;for(pushUndo(this),void 0===t&&(t=d._fullCircle),void 0===n&&(i=Math.abs(t)/d._fullCircle,n=1+(Math.min(11+Math.abs(e*m)/6,59)*i|0)),a=.5*(s=t/n),o=2*e*Math.sin(s*Math.PI/d._fullCircle),e<0?(o=-o,s=-s,a=-a,r=g-t):r=g+t,h=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise,g+=a,l=0;l<n;l++)calculateHeading(d,g+s*l,p),u=Math.cos(p.radians)*o,c=Math.sin(p.radians)*o,h=h.then(circleRotate(d,p.angle,p.radians)).then(circleSegment(d,f,_,u,c,v)),f+=u,_+=c,v=!1;return h.then((function(){return calculateHeading(d,r,p),d._angle=p.angle,d._radians=p.radians,d.addUpdate(void 0,!0,p)}))},e.$circle.co_varnames=[\"radius\",\"extent\",\"steps\"],e.$circle.minArgs=1,e.$penup=e.$up=e.$pu=function(){return this._down=!1,this.addUpdate(void 0,!1,{down:!1})},e.$pendown=e.$down=e.$pd=function(){return this._down=!0,this.addUpdate(void 0,!1,{down:!0})},e.$isdown=function(){return this._down},e.$speed=function(e){if(\"undefined\"==typeof e)return this._speed;const t={fastest:0,fast:10,normal:6,slow:3,slowest:1};if(e in t&&(e=t[e]),\"number\"!=typeof e){if(\"string\"==typeof e){const e=Object.keys(t).join(\", \");throw new Sk.builtin.TypeError(\"speed string expected one of \"+e)}throw new Sk.builtin.TypeError(\"speed expected a string or number\")}return e=e>.5&&e<10.5?Sk.builtin.asnum$(Sk.builtin.round(Sk.builtin.assk$(e))):0,this._speed=e,this._computed_speed=2*e,this.addUpdate(void 0,!1,{speed:this._computed_speed})},e.$speed.minArgs=0,e.$speed.co_varnames=[\"speed\"],e.$pencolor=function(e,t,n,r){return void 0!==e?(this._color=createColor(this._colorMode,e,t,n,r),this.addUpdate(void 0,this._shown,{color:this._color})):hexToRGB(this._color)},e.$pencolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$pencolor.minArgs=0,e.$pencolor.returnType=f.COLOR,e.$fillcolor=function(e,t,n,r){return void 0!==e?(this._fill=createColor(this._colorMode,e,t,n,r),this.addUpdate(void 0,this._shown,{fill:this._fill})):hexToRGB(this._fill)},e.$fillcolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$fillcolor.minArgs=0,e.$fillcolor.returnType=f.COLOR,e.$color=function(e,t,n,r){return void 0!==e?(void 0===t||void 0!==n?(this._color=createColor(this._colorMode,e,t,n,r),this._fill=this._color):(this._color=createColor(this._colorMode,e),this._fill=createColor(this._colorMode,t)),this.addUpdate(void 0,this._shown,{color:this._color,fill:this._fill})):[this.$pencolor(),this.$fillcolor()]},e.$color.minArgs=0,e.$color.co_varnames=[\"color\",\"fill\",\"b\",\"a\"],e.$color.returnType=function(e){return new Sk.builtin.tuple([f.COLOR(e[0]),f.COLOR(e[1])])},e.$fill=function(e){if(void 0!==e){if((e=!!e)===this._filling)return;return this._filling=e,e?(pushUndo(this),this.addUpdate(void 0,!1,{filling:!0,fillBuffer:[{x:this._x,y:this._y}]})):(pushUndo(this),this.addUpdate((function(){this.fillBuffer.push(this),drawFill.call(this)}),!0,{filling:!1,fillBuffer:void 0}))}return this._filling},e.$fill.co_varnames=[\"flag\"],e.$fill.minArgs=0,e.$begin_fill=function(){return this.$fill(!0)},e.$end_fill=function(){return this.$fill(!1)},e.$stamp=function(){return pushUndo(this),this.addUpdate((function(){drawTurtle(this,this.context())}),!0)},e.$dot=function(e,t,n,r,i){return pushUndo(this),e=\"number\"==typeof(e=Sk.builtin.asnum$(e))?Math.max(1,0|Math.abs(e)):Math.max(this._size+4,2*this._size),t=void 0!==t?createColor(this._colorMode,t,n,r,i):this._color,this.addUpdate(drawDot,!0,void 0,e,t)},e.$dot.co_varnames=[\"size\",\"color\",\"g\",\"b\",\"a\"],e.$write=function(e,t,n,r){var i,s,a,o,l,u=this;return pushUndo(this),e=String(e),r&&r.constructor===Array&&(s=\"string\"==typeof r[0]?r[0]:\"Arial\",a=String(r[1]||\"12pt\"),o=\"string\"==typeof r[2]?r[2]:\"normal\",/^\\d+$/.test(a)&&(a+=\"pt\"),r=[o,a,s].join(\" \")),n||(n=\"left\"),i=this.addUpdate(drawText,!0,void 0,e,n,r),!t||\"left\"!==n&&\"center\"!==n||(l=function measureText(e,t){return t&&(p.font=t),p.measureText(e).width}(e,r),\"center\"===n&&(l/=2),i=i.then((function(){var e=u.getState();return u.translate(e.x,e.y,l,0,!0)}))),i},e.$write.co_varnames=[\"message\",\"move\",\"align\",\"font\"],e.$write.minArgs=1,e.$pensize=e.$width=function(e){return void 0!==e?(this._size=e,this.addUpdate(void 0,this._shown,{size:e})):this._size},e.$pensize.minArgs=e.$width.minArgs=0,e.$pensize.co_varnames=e.$width.co_varnames=[\"width\"],e.$showturtle=e.$st=function(){return this._shown=!0,this.addUpdate(void 0,!0,{shown:!0})},e.$hideturtle=e.$ht=function(){return this._shown=!1,this.addUpdate(void 0,!0,{shown:!1})},e.$isvisible=function(){return this._shown},e.$shape=function(e){return e&&d[e]?(this._shape=e,this.addUpdate(void 0,this._shown,{shape:e})):this._shape},e.$shape.minArgs=0,e.$shape.co_varnames=[\"name\"],e.$window_width=function(){return this._screen.$window_width()},e.$window_height=function(){return this._screen.$window_height()},e.$tracer=function(e,t){return this._screen.$tracer(e,t)},e.$tracer.minArgs=0,e.$tracer.co_varnames=[\"n\",\"delay\"],e.$update=function(){return this._screen.$update()},e.$delay=function(e){return this._screen.$delay(e)},e.$delay.minArgs=0,e.$delay.co_varnames=[\"delay\"],e.$reset=function(){return this.reset(),this.$clear()},e.$mainloop=e.$done=function(){return this._screen.$mainloop()},e.$clear=function(){return this.addUpdate((function(){clearLayer(this.context())}),!0)},e.$dot.minArgs=0,e.$onclick=function(e,t,n){this.getManager(\"mousedown\").addHandler(e,n)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$onrelease=function(e,t,n){this.getManager(\"mouseup\").addHandler(e,n)},e.$onrelease.minArgs=1,e.$onrelease.co_varnames=[\"method\",\"btn\",\"add\"],e.$ondrag=function(e,t,n){this.getManager(\"mousemove\").addHandler(e,n)},e.$ondrag.minArgs=1,e.$ondrag.co_varnames=[\"method\",\"btn\",\"add\"],e.$getscreen=function(){return Sk.misceval.callsimArray(u.Screen)},e.$getscreen.isSk=!0,e.$clone=function(){var e=Sk.misceval.callsimOrSuspendArray(u.Turtle);return e.instance._x=this._x,e.instance._y=this._y,e.instance._angle=this._angle,e.instance._radians=this._radians,e.instance._shape=this._shape,e.instance._color=this._color,e.instance._fill=this._fill,e.instance._filling=this._filling,e.instance._size=this._size,e.instance._computed_speed=this._computed_speed,e.instance._down=this._down,e.instance._shown=this._shown,e.instance._colorMode=this._colorMode,e.instance._isRadians=this._isRadians,e.instance._fullCircle=this._fullCircle,e.instance._bufferSize=this._bufferSize,e.instance._undoBuffer=this._undoBuffer,e._clonedFrom=this,e},e.$clone.returnType=function(e){return e},e.$getturtle=e.$getpen=function(){return this.skInstance},e.$getturtle.isSk=!0}(Turtle.prototype),function(e){e.spriteLayer=function(){return this._sprites||(this._sprites=createLayer(3))},e.bgLayer=function(){return this._background||(this._background=createLayer(1))},e.hitTestLayer=function(){return this._hitTest||(this._hitTest=createLayer(0,!0))},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new EventManager(e,this)),this._managers[e]},e.reset=function(){var e;for(e in this._keyListeners=void 0,this._keyLogger)window.clearInterval(this._keyLogger[e]),window.clearTimeout(this._keyLogger[e]),delete this._keyLogger[e];for(e in this._keyDownListener&&(getTarget().removeEventListener(\"keydown\",this._keyDownListener),this._keyDownListener=void 0),this._keyUpListener&&(getTarget().removeEventListener(\"keyup\",this._keyUpListener),this._keyUpListener=void 0),this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),this._managers)this._managers[e].reset();this._mode=\"standard\",removeLayer(this._sprites),this._sprites=void 0,removeLayer(this._background),this._background=void 0},e.setUpWorld=function(e,t,n,r){var i=this;i.llx=e,i.lly=t,i.urx=n,i.ury=r,i.xScale=(n-e)/getWidth(),i.yScale=-1*(r-t)/getHeight(),i.lineScale=Math.min(Math.abs(i.xScale),Math.abs(i.yScale))},e.$setup=function(e,t,n,r){return isNaN(parseFloat(e))&&(e=getWidth()),isNaN(parseFloat(t))&&(t=getHeight()),e<=1&&(e=getWidth()*e),t<=1&&(t=getHeight()*t),this._width=e,this._height=t,this._xOffset=void 0===n||isNaN(parseInt(n))?0:parseInt(n),this._yOffset=void 0===r||isNaN(parseInt(r))?0:parseInt(r),\"world\"===this._mode?this._setworldcoordinates(this.llx,this.lly,this.urx,this.ury):this._setworldcoordinates(-e/2,-t/2,e/2,t/2)},e.$setup.minArgs=0,e.$setup.co_varnames=[\"width\",\"height\",\"startx\",\"starty\"],e.$register_shape=e.$addshape=function(e,t){if(!t)return getAsset(e).then((function(t){d[e]=t}));d[e]=t},e.$register_shape.minArgs=1,e.$register_shape.co_varnames=[\"name\",\"shape\"],e.$getshapes=function(){return Object.keys(d)},e.$tracer=function(e,t){return void 0!==e||void 0!==t?(\"number\"==typeof t&&(this._delay=t,getFrameManager().refreshInterval(t)),\"number\"==typeof e?(this._frames=e,getFrameManager().frameBuffer(e)):void 0):this._frames},e.$tracer.co_varnames=[\"frames\",\"delay\"],e.$tracer.minArgs=0,e.$delay=function(e){return void 0!==e?this.$tracer(void 0,e):void 0===this._delay?h:this._delay},e.$delay.co_varnames=[\"delay\"],e._setworldcoordinates=function(e,t,n,r){return getFrameManager().turtles(),this.setUpWorld(e,t,n,r),this._sprites&&applyWorld(this,this._sprites),this._background&&applyWorld(this,this._background),this.$clear()},e.$setworldcoordinates=function(e,t,n,r){return this._mode=\"world\",this._setworldcoordinates(e,t,n,r)},e.$setworldcoordinates.co_varnames=[\"llx\",\"lly\",\"urx\",\"ury\"],e.minArgs=4,e.$clear=e.$clearscreen=function(){return this.reset(),this.$reset()},e.$update=function(){return getFrameManager().update()},e.$reset=e.$resetscreen=function(){var e=this,t=getFrameManager().turtles();return getFrameManager().addFrame((function(){applyWorld(e,e._sprites),applyWorld(e,e._background);for(var n=0;n<t.length;n++)t[n].reset(),applyWorld(e,t[n]._paper)}),!0)},e.$window_width=function(){return getWidth()},e.$window_height=function(){return getHeight()},e.$delay.minArgs=0,e.$turtles=function(){return getFrameManager().turtles()},e.$turtles.returnType=f.TURTLE_LIST,e.$bgpic=function(e){var t;return e?(t=this,getAsset(e).then((function(e){clearLayer(t.bgLayer(),void 0,e)}))):this._bgpic},e.$bgpic.minArgs=0,e.$bgpic.co_varnames=[\"name\"],e.$bgcolor=function(e,t,n,r){return void 0!==e?(this._bgcolor=createColor(this._colorMode,e,t,n,r),void clearLayer(this.bgLayer(),this._bgcolor)):hexToRGB(this._bgcolor)},e.$bgcolor.minArgs=0,e.$bgcolor.co_varnames=[\"color\",\"g\",\"b\",\"a\"],e.$bgcolor.returnType=f.COLOR,e.$colormode=function(e){return void 0!==e?(this._colorMode=255===e?255:1,this.addUpdate(void 0,this._shown,{colorMode:this._colorMode})):this._colorMode},e.$colormode.minArgs=0,e.$colormode.co_varnames=[\"cmode\"],e.$colormode.returnType=function(e){return 255===e?new Sk.builtin.int_(255):new Sk.builtin.float_(1)},e.$mainloop=e.$done=function(){},e.$bye=function(){return Sk.TurtleGraphics.reset()},e.$exitonclick=function(){return this._exitOnClick=!0,this.getManager(\"mousedown\").addHandler((function(){resetTurtle()}),!1)},e.$onclick=function(e,t,n){this._exitOnClick||this.getManager(\"mousedown\").addHandler(e,n)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"];var t={8:/^back(space)?$/i,9:/^tab$/i,13:/^(enter|return)$/i,16:/^shift$/i,17:/^(ctrl|control)$/i,18:/^alt$/i,27:/^esc(ape)?$/i,32:/^space$/i,33:/^page[\\s\\-]?up$/i,34:/^page[\\s\\-]?down$/i,35:/^end$/i,36:/^home$/i,37:/^left([\\s\\-]?arrow)?$/i,38:/^up([\\s\\-]?arrow)?$/i,39:/^right([\\s\\-]?arrow)?$/i,40:/^down([\\s\\-]?arrow)?$/i,45:/^insert$/i,46:/^del(ete)?$/i};e._createKeyRepeater=function(e,t){var n=this;n._keyLogger[t]=window.setTimeout((function(){n._keyListeners[e](),n._keyLogger[t]=window.setInterval((function(){n._keyListeners[e]()}),50)}),333)},e._createKeyDownListener=function(){var e=this;this._keyDownListener||(this._keyDownListener=function(n){if(focusTurtle()){var r,i,s=n.charCode||n.keyCode,a=String.fromCharCode(s).toLowerCase();if(!e._keyLogger[s])for(r in e._keyListeners)if(i=r.length>1&&t[s]&&t[s].test(r),r===a||i){e._keyListeners[r](),e._createKeyRepeater(r,s),n.preventDefault();break}}},getTarget().addEventListener(\"keydown\",this._keyDownListener))},e._createKeyUpListener=function(){var e=this;this._keyUpListener||(this._keyUpListener=function(t){var n=e._keyLogger[t.charCode||t.keyCode];void 0!==n&&(t.preventDefault(),window.clearInterval(n),window.clearTimeout(n),delete e._keyLogger[t.charCode||t.keyCode])},getTarget().addEventListener(\"keyup\",this._keyUpListener))},e.$title=function(e){document.title=e},e.$title.minArgs=1,e.$title.co_varnames=[\"title\"],e.$listen=function(){this._createKeyUpListener(),this._createKeyDownListener()},e.$onkey=function(e,t){if(\"function\"==typeof t){var n=e;e=t,t=n}t=String(t).toLowerCase(),e&&\"function\"==typeof e?(this._keyListeners||(this._keyListeners={}),this._keyListeners[t]=e):delete this._keyListeners[t]},e.$onkey.minArgs=2,e.$onkey.co_varnames=[\"method\",\"keyValue\"],e.$onscreenclick=function(e,t,n){this.getManager(\"mousedown\").addHandler(e,n)},e.$onscreenclick.minArgs=1,e.$onscreenclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$ontimer=function(e,t){this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),e&&\"number\"==typeof t&&(this._timer=window.setTimeout(e,Math.max(0,0|t)))},e.$ontimer.minArgs=0,e.$ontimer.co_varnames=[\"method\",\"interval\"]}(Screen.prototype);var g=new Image;function removeLayer(e){e&&e.canvas&&e.canvas.parentNode&&e.canvas.parentNode.removeChild(e.canvas)}function clearLayer(e,t,n){e&&(e.save(),e.setTransform(1,0,0,1,0,0),t?(e.fillStyle=t,e.fillRect(0,0,e.canvas.width,e.canvas.height)):e.clearRect(0,0,e.canvas.width,e.canvas.height),n&&e.drawImage(n,0,0),e.restore())}function drawTurtle(e,t){var n,r,i,s=d[e.shape],a=getScreen(),o=(getWidth(),getHeight(),a.xScale),l=a.yScale;if(t){if(n=Math.cos(e.radians)/o,r=Math.sin(e.radians)/l,i=Math.atan2(r,n)-Math.PI/2,t.save(),t.translate(e.x,e.y),t.scale(o,l),s.nodeName){var u=s.naturalWidth,c=s.naturalHeight;t.drawImage(s,0,0,u,c,-u/2,-c/2,u,c)}else{t.rotate(i),t.beginPath(),t.lineWidth=1,t.strokeStyle=e.color,t.fillStyle=e.fill,t.moveTo(-s[0][0],s[0][1]);for(var h=1;h<s.length;h++)t.lineTo(-s[h][0],s[h][1]);t.closePath(),t.fill(),t.stroke()}t.restore()}}function drawDot(e,t){var n=this.context(),r=getScreen(),i=r.xScale,s=r.yScale;n&&(n.beginPath(),n.moveTo(this.x,this.y),e*=Math.min(Math.abs(i),Math.abs(s)),n.arc(this.x,this.y,e/2,0,Turtle.RADIANS),n.closePath(),n.fillStyle=t||this.color,n.fill())}var p=document.createElement(\"canvas\").getContext(\"2d\");function drawText(e,t,n){var r=this.context();r&&(r.save(),n&&(r.font=n),t&&t.match(/^(left|right|center)$/)&&(r.textAlign=t),r.scale(1,-1),r.fillStyle=this.fill,r.fillText(e,this.x,-this.y),r.restore())}function drawLine(e,t,n){var r=this.context();r&&(t&&(r.beginPath(),r.moveTo(this.x,this.y)),r.lineWidth=this.size*getScreen().lineScale,r.strokeStyle=this.color,r.lineTo(e.x,e.y),r.stroke())}function drawFill(){var e,t=this.context(),n=this.fillBuffer;if(t&&n&&n.length){for(t.save(),t.beginPath(),t.moveTo(n[0].x,n[0].y),e=1;e<n.length;e++)t.lineTo(n[e].x,n[e].y);for(t.closePath(),t.fillStyle=this.fill,t.fill(),e=1;e<n.length;e++)n[e].stroke&&(t.beginPath(),t.moveTo(n[e-1].x,n[e-1].y),t.lineWidth=n[e].size*getScreen().lineScale,t.strokeStyle=n[e].color,t.lineTo(n[e].x,n[e].y),t.stroke());t.restore()}}function partialTranslate(e,t,n,r,i){return function(){return e.addUpdate((function(e){this.down&&drawLine.call(this,e,r)}),i,{x:t,y:n},r)}}function partialRotate(e,t,n,r){return function(){return e.addUpdate(void 0,r,{angle:t,radians:n})}}function getCoordinates(e,t){return void 0===t&&(t=e&&(e.y||e._y||e[1])||0,e=e&&(e.x||e._x||e[0])||0),{x:e,y:t}}function hexToRGB(e){var t,n,r;return(t=/^rgba?\\((\\d+),(\\d+),(\\d+)(?:,([.\\d]+))?\\)$/.exec(e))?(r=[parseInt(t[1]),parseInt(t[2]),parseInt(t[3])],t[4]&&r.push(parseFloat(t[4]))):/^#?[a-f\\d]{3}|[a-f\\d]{6}$/i.exec(e)?(4===e.length&&(e=e.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,(function(e,t,n,r){return t+t+n+n+r+r}))),n=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e),r=[parseInt(n[1],16),parseInt(n[2],16),parseInt(n[3],16)]):r=e,r}function createColor(e,t,n,r,i){var s;if(void 0!==n&&(t=[t,n,r,i]),t.constructor===Array&&t.length){if(255===e)for(s=0;s<3;s++){if(\"number\"!=typeof t[s])throw new Sk.builtin.ValueError(\"bad color sequence\");t[s]=Math.max(0,Math.min(255,parseInt(t[s])))}else for(s=0;s<3;s++){if(\"number\"!=typeof t[s])throw new Sk.builtin.ValueError(\"bad color sequence\");if(!(t[s]<=1))throw new Sk.builtin.ValueError(\"bad color sequence\");t[s]=Math.max(0,Math.min(255,parseInt(255*t[s])))}\"number\"==typeof t[s]?(t[3]=Math.max(0,Math.min(1,t[s])),t=\"rgba(\"+t.join(\",\")+\")\"):t=\"rgb(\"+t.slice(0,3).join(\",\")+\")\"}else{if(\"string\"!=typeof t||t.match(/\\s*url\\s*\\(/i))return\"black\";t=t.replace(/\\s+/g,\"\")}return t}function calculateHeading(e,t,n){var r=e._angle||0,i=e._radians||0;return n||(n={}),\"number\"==typeof t&&(e._isRadians?r=i=t%Turtle.RADIANS:e._fullCircle?i=(r=t%e._fullCircle)/e._fullCircle*Turtle.RADIANS:r=i=0,r<0&&(r+=e._fullCircle,i+=Turtle.RADIANS)),n.angle=r,n.radians=i,n}function pythonToJavascriptFunction(e,t){return function(){var n=Array.prototype.slice.call(arguments).map((function(e){return Sk.ffi.remapToPy(e)}));return\"undefined\"!=typeof t&&n.unshift(t),Sk.misceval.applyAsync(void 0,e,void 0,void 0,void 0,n).catch(Sk.uncaughtException)}}function addModuleMethod(e,t,n,r){var i,s=n.replace(/^\\$/,\"\"),a=s.replace(/_\\$[a-z]+\\$$/i,\"\"),o=e.prototype[n].length,l=e.prototype[n].minArgs,u=e.prototype[n].co_varnames||[],c=e.prototype[n].returnType,h=e.prototype[n].isSk;void 0===l&&(l=o),(i=function(){var e,t,i,s,u,d=Array.prototype.slice.call(arguments,0),f=r?r():d.shift().instance;if(d.length<l||d.length>o)throw u=l===o?\"exactly \"+o:\"between \"+l+\" and \"+o,new Sk.builtin.TypeError(a+\"() takes \"+u+\" positional argument(s) (\"+d.length+\" given)\");for(e=d.length;--e>=0;)void 0!==d[e]&&(d[e]instanceof Sk.builtin.func?d[e]=pythonToJavascriptFunction(d[e]):d[e]instanceof Sk.builtin.method?d[e]=pythonToJavascriptFunction(d[e].im_func,d[e].im_self):d[e]&&d[e].$d instanceof Sk.builtin.dict&&d[e].instance?d[e]=d[e].instance:d[e]=Sk.ffi.remapToJs(d[e]));var _=d.slice(0);for(d=[],e=_.length;e>=0;--e)null!==_[e]&&(d[e]=_[e]);try{t=f[n].apply(f,d)}catch(g){throw window&&window.console&&(window.console.log(\"wrapped method failed\"),window.console.log(g.stack)),g}return t instanceof InstantPromise&&(t=t.lastResult),t instanceof Promise?(t=t.catch((function(e){throw window&&window.console&&(window.console.log(\"promise failed\"),window.console.log(e.stack)),e})),(i=new Sk.misceval.Suspension).resume=function(){return void 0===s?Sk.builtin.none.none$:Sk.ffi.remapToPy(s)},i.data={type:\"Sk.promise\",promise:t.then((function(e){return s=e,e}))},i):void 0===t?Sk.builtin.none.none$:h?t:\"function\"==typeof c?c(t):Sk.ffi.remapToPy(t)}).co_name=new Sk.builtin.str(a),i.co_varnames=u.slice(),i.$defaults=[];for(var d=l;d<u.length;d++)i.$defaults.push(Sk.builtin.none.none$);r||i.co_varnames.unshift(\"self\"),t[s]=new Sk.builtin.func(i)}function initTurtle(e,t){Sk.builtin.pyCheckArgs(\"__init__\",arguments,2,3,!1,!1),e.instance=new Turtle(t),e.instance.skInstance=e}for(var m in initTurtle.co_varnames=[\"self\",\"shape\"],initTurtle.co_name=new Sk.builtin.str(\"Turtle\"),initTurtle.co_argcount=2,initTurtle.$defaults=[Sk.builtin.none.none$,new Sk.builtin.str(\"classic\")],Turtle.prototype)/^\\$[a-z_]+/.test(m)&&addModuleMethod(Turtle,u,m,ensureAnonymous);function focusTurtle(e){return void 0!==e&&((c=!!e)?getTarget().focus():getTarget().blur()),c}function resetTurtle(){for(cancelAnimationFrame(),getScreen().reset(),getFrameManager().reset();e.firstChild;)e.removeChild(e.firstChild);a&&a.reset(),r=void 0,s=void 0,a=void 0}return addModuleMethod(Screen,u,\"$mainloop\",getScreen),addModuleMethod(Screen,u,\"$done\",getScreen),addModuleMethod(Screen,u,\"$bye\",getScreen),addModuleMethod(Screen,u,\"$tracer\",getScreen),addModuleMethod(Screen,u,\"$update\",getScreen),addModuleMethod(Screen,u,\"$delay\",getScreen),addModuleMethod(Screen,u,\"$window_width\",getScreen),addModuleMethod(Screen,u,\"$window_height\",getScreen),addModuleMethod(Screen,u,\"$title\",getScreen),addModuleMethod(Screen,u,\"$onkey\",getScreen),addModuleMethod(Screen,u,\"$listen\",getScreen),addModuleMethod(Screen,u,\"$register_shape\",getScreen),addModuleMethod(Screen,u,\"$clearscreen\",getScreen),addModuleMethod(Screen,u,\"$bgcolor\",getScreen),addModuleMethod(Screen,u,\"$bgpic\",getScreen),addModuleMethod(Screen,u,\"$setworldcoordinates\",getScreen),addModuleMethod(Screen,u,\"$ontimer\",getScreen),addModuleMethod(Screen,u,\"$onscreenclick\",getScreen),addModuleMethod(Screen,u,\"$exitonclick\",getScreen),addModuleMethod(Screen,u,\"$resetscreen\",getScreen),addModuleMethod(Screen,u,\"$setup\",getScreen),addModuleMethod(Screen,u,\"$turtles\",getScreen),u.Turtle=Sk.misceval.buildClass(u,(function TurtleWrapper(e,t){for(var n in t.__init__=new Sk.builtin.func(initTurtle),Turtle.prototype)/^\\$[a-z_]+/.test(n)&&addModuleMethod(Turtle,t,n)}),\"Turtle\",[]),u.Screen=Sk.misceval.buildClass(u,(function ScreenWrapper(e,t){for(var n in t.__init__=new Sk.builtin.func((function(e){e.instance=getScreen()})),Screen.prototype)/^\\$[a-z_]+/.test(n)&&addModuleMethod(Screen,t,n)}),\"Screen\",[]),{skModule:u,reset:resetTurtle,stop:function stopTurtle(){cancelAnimationFrame(),a&&a.reset(),r=void 0,s=void 0,a=void 0},focus:focusTurtle,Turtle:Turtle,Screen:Screen}}(t),Sk.TurtleGraphics.module=t.turtleInstance.skModule,Sk.TurtleGraphics.reset=t.turtleInstance.reset,Sk.TurtleGraphics.stop=t.turtleInstance.stop,Sk.TurtleGraphics.focus=t.turtleInstance.focus,Sk.TurtleGraphics.raw={Turtle:t.turtleInstance.Turtle,Screen:t.turtleInstance.Screen},t.turtleInstance.skModule};","src/lib/urllib/__init__.js":"var $builtinmodule=function(n){return{}};","src/lib/urllib/request/__init__.js":"var $builtinmodule=function(n){var e={};e.Response=Sk.misceval.buildClass(e,(function(n,e){e.__init__=new Sk.builtin.func((function(n,e){n.data$=e.responseText,n.lineList=n.data$.split(\"\\n\"),n.lineList=n.lineList.slice(0,-1);for(var i=0;i<n.lineList.length;i++)n.lineList[i]=n.lineList[i]+\"\\n\";n.currentLine=0,n.pos$=0})),e.__str__=new Sk.builtin.func((function(n){return Sk.ffi.remapToPy(\"<Response>\")})),e.__iter__=new Sk.builtin.func((function(n){var e=n.lineList;return Sk.builtin.makeGenerator((function(){if(!(this.$index>=this.$lines.length))return new Sk.builtin.str(this.$lines[this.$index++])}),{$obj:n,$index:0,$lines:e})})),e.read=new Sk.builtin.func((function(n,e){if(n.closed)throw new Sk.builtin.ValueError(\"I/O operation on closed file\");var i=n.data$.length;void 0===e&&(e=i);var t=new Sk.builtin.str(n.data$.substr(n.pos$,e));return n.pos$+=e,n.pos$>=i&&(n.pos$=i),t})),e.readline=new Sk.builtin.func((function(n,e){var i=\"\";return n.currentLine<n.lineList.length&&(i=n.lineList[n.currentLine],n.currentLine++),new Sk.builtin.str(i)})),e.readlines=new Sk.builtin.func((function(n,e){for(var i=[],t=n.currentLine;t<n.lineList.length;t++)i.push(new Sk.builtin.str(n.lineList[t]));return new Sk.builtin.list(i)}))}),\"Response\",[]);return e.urlopen=new Sk.builtin.func((function(n,i,t){var r;r=function(n){var e;if(!Sk.jsonpSites)return!1;for(e=0;e<Sk.jsonpSites.length;e++)if(n.startsWith(Sk.jsonpSites[e]))return!0;return!1}(n.v)?new Promise((function(i,t){var r=document.createElement(\"script\");r.src=n.v+\"&callback=Sk.jsonpcallback\",r.onerror=function(n){t(\"An error occured getting the data\")},Sk.jsonpcallback=function(n){var t={responseText:JSON.stringify(n)};i(Sk.misceval.callsimArray(e.Response,[t]))};try{document.body.appendChild(r)}catch(s){console.log(\"caught error in urlopen\"+s)}})):new Promise((function(t,r){var s=new XMLHttpRequest;s.addEventListener(\"loadend\",(function(n){t(Sk.misceval.callsimArray(e.Response,[s]))})),i?(s.open(\"POST\",n.v),s.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"),s.send(i.v)):(s.open(\"GET\",n.v),s.send(null))}));var s,u=new Sk.misceval.Suspension;return u.resume=function(){return s},u.data={type:\"Sk.promise\",promise:r.then((function(n){return s=n,n}),(function(n){return s=\"\",n}))},u})),e};","src/lib/webbrowser.js":"var $builtinmodule=function(n){var e={},t=\"undefined\"!=typeof window&&\"undefined\"!=typeof window.navigator;function open_tab(n){return Sk.builtin.pyCheckType(\"url\",\"string\",Sk.builtin.checkString(n)),t?(n=n.$jsstr(),window.open(n,\"_blank\"),Sk.builtin.bool.true$):Sk.builtin.bool.false$}return e.__name__=new Sk.builtin.str(\"webbrowser\"),e.open=new Sk.builtin.func((function open(n){return Sk.builtin.pyCheckArgsLen(\"open\",arguments.length+1,1,3),open_tab(n)})),e.open_new=new Sk.builtin.func((function open_new(n){return Sk.builtin.pyCheckArgsLen(\"open_new\",arguments.length,1,1),open_tab(n)})),e.open_new_tab=new Sk.builtin.func((function open_new_tab(n){return Sk.builtin.pyCheckArgsLen(\"open_new_tab\",arguments.length,1,1),open_tab(n)})),e.DefaultBrowser=Sk.misceval.buildClass(e,(function dflbrowser(n,e){e.__init__=new Sk.builtin.func((function __init__(n){return Sk.builtin.none.none$})),e.open=new Sk.builtin.func((function open(n,e){return Sk.builtin.pyCheckArgsLen(\"open\",arguments.length,2,4),open_tab(e)})),e.open_new=new Sk.builtin.func((function open_new(n,e){return Sk.builtin.pyCheckArgsLen(\"open_new\",arguments.length,2,2),open_tab(e)})),e.open_new_tab=new Sk.builtin.func((function open_new_tab(n,e){return Sk.builtin.pyCheckArgsLen(\"open_new_tab\",arguments.length,2,2),open_tab(e)}))}),\"DefaultBrowser\",[]),e.get=new Sk.builtin.func((function get(){return Sk.builtin.pyCheckArgsLen(\"get\",arguments.length,0,1),Sk.misceval.callsimArray(e.DefaultBrowser,[])})),e};","src/lib/webgl/__init__.js":"var $builtinmodule=function(n){var t={__name__:new Sk.builtin.str(\"webgl\")},makeFailHTML=function(n){return'<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr><td align=\"center\"><div style=\"display: table-cell; vertical-align: middle;\"><div style=\"\">'+n+\"</div></div></td></tr></table>\"},e='This page requires a browser that supports WebGL.<br/><a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';return t.Context=Sk.misceval.buildClass(t,(function(n,t){t.__init__=new Sk.builtin.func((function(n,t){var i=document.getElementById(t.v),r=function(n,t){var i=document.getElementById(n);if(t||(t=i.getElementsByTagName(\"canvas\")[0]),t){var r=function(n){for(var t=[\"webgl\",\"experimental-webgl\",\"webkit-3d\",\"moz-webgl\"],e=null,i=0;i<t.length;++i){try{e=n.getContext(t[i])}catch(r){}if(e)break}if(e){function returnFalse(){return!1}n.onselectstart=returnFalse,n.onmousedown=returnFalse}return e}(t);if(!r){var u=navigator.userAgent.match(/(\\w+\\/.*? )/g),a={};try{for(var o=0;o<u.length;++o){for(var l=u[o].match(/(\\w+)/g),c=[],f=1;f<l.length;++f)c.push(parseInt(l[f]));a[l[0]]=c}}catch(s){}a.Chrome&&(a.Chrome[0]>7||7==a.Chrome[0]&&a.Chrome[1]>0||7==a.Chrome[0]&&0==a.Chrome[1]&&a.Chrome[2]>=521)?i.innerHTML=makeFailHTML('It doesn\\'t appear your computer can support WebGL.<br/><a href=\"http://get.webgl.org\">Click here for more information.</a>'):i.innerHTML=makeFailHTML(e)}return r}i.innerHTML=makeFailHTML(e)}(t.v,i);if(!r)throw new Error(\"Your browser does not appear to support WebGL.\");for(var u in n.gl=r,r.__proto__)if(\"number\"==typeof r.__proto__[u])Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(u),r.__proto__[u]);else if(\"function\"==typeof r.__proto__[u])switch(u){case\"bufferData\":case\"clearColor\":case\"drawArrays\":case\"getAttribLocation\":case\"getUniformLocation\":case\"shaderSource\":case\"uniformMatrix4fv\":case\"vertexAttribPointer\":case\"viewport\":break;default:!function(t){Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(u),new Sk.builtin.func((function(){var n=r.__proto__[t];return n.apply(r,arguments)})))}(u)}r.clearColor(100/255,149/255,237/255,1),r.clear(r.COLOR_BUFFER_BIT)})),t.tp$getattr=Sk.generic.getAttr,t.bufferData=new Sk.builtin.func((function(n,t,e,i){n.gl.bufferData(t,e.v,i)})),t.clearColor=new Sk.builtin.func((function(n,t,e,i,r){n.gl.clearColor(Sk.builtin.asnum$(t),Sk.builtin.asnum$(e),Sk.builtin.asnum$(i),Sk.builtin.asnum$(r))})),t.getAttribLocation=new Sk.builtin.func((function(n,t,e){return n.gl.getAttribLocation(t,e.v)})),t.getUniformLocation=new Sk.builtin.func((function(n,t,e){return n.gl.getUniformLocation(t,e.v)})),t.shaderSource=new Sk.builtin.func((function(n,t,e){n.gl.shaderSource(t,e.v)})),t.drawArrays=new Sk.builtin.func((function(n,t,e,i){n.gl.drawArrays(Sk.builtin.asnum$(t),Sk.builtin.asnum$(e),Sk.builtin.asnum$(i))})),t.vertexAttribPointer=new Sk.builtin.func((function(n,t,e,i,r,u,a){n.gl.vertexAttribPointer(t,Sk.builtin.asnum$(e),Sk.builtin.asnum$(i),r,Sk.builtin.asnum$(u),Sk.builtin.asnum$(a))})),t.viewport=new Sk.builtin.func((function(n,t,e,i,r){n.gl.viewport(Sk.builtin.asnum$(t),Sk.builtin.asnum$(e),Sk.builtin.asnum$(i),Sk.builtin.asnum$(r))})),t.uniformMatrix4fv=new Sk.builtin.func((function(n,t,e,i){n.gl.uniformMatrix4fv(Sk.builtin.asnum$(t),e,i.v)})),t.setDrawFunc=new Sk.builtin.func((function(n,t){var e=(new Date).getTime();setInterval((function(){Sk.misceval.callsimArray(t,[n,(new Date).getTime()-e])}),1e3/60)}))}),\"Context\",[]),t.Float32Array=Sk.misceval.buildClass(t,(function(n,t){t.__init__=new Sk.builtin.func((function(n,t){n.v=\"number\"==typeof t?new Float32Array(t):new Float32Array(Sk.ffi.remapToJs(t))})),t.__repr__=new Sk.builtin.func((function(n){for(var t=[],e=0;e<n.v.length;++e)t.push(n.v[e]);return new Sk.builtin.str(\"[\"+t.join(\", \")+\"]\")}))}),\"Float32Array\",[]),t.Matrix4x4=Sk.misceval.buildClass(t,(function(n,t){t.__init__=new Sk.builtin.func((function(n,t){n.v=new Float32Array(Sk.ffi.remapToJs(t))})),t.identity=new Sk.builtin.func((function(n){var t=n.v;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1})),t.perspective=new Sk.builtin.func((function(n,t,e,i,r){var u=Math.tan(.5*Math.PI-Sk.builtin.asnum$(t)*Math.PI/180*.5),a=Sk.builtin.asnum$(e),o=Sk.builtin.asnum$(i),l=Sk.builtin.asnum$(r),c=1/(o-l),f=n.v;f[0]=u/a,f[1]=0,f[2]=0,f[3]=0,f[4]=0,f[5]=u,f[6]=0,f[7]=0,f[8]=0,f[9]=0,f[10]=(o+l)*c,f[11]=-1,f[12]=0,f[13]=0,f[14]=o*l*c*2,f[15]=0})),t.translate=new Sk.builtin.func((function(n,t){var e=n.v,i=Sk.ffi.remapToJs(t);e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=i[0],e[13]=i[1],e[14]=i[2],e[15]=1})),t.__repr__=new Sk.builtin.func((function(n){for(var t=[],e=0;e<n.v.length;++e)t.push(n.v[e]);return new Sk.builtin.str(\"[\"+t.join(\", \")+\"]\")}))}),\"Matrix4x4\",[]),t};","src/lib/webgl/math.js":"var $builtinmodule=function(e){var n={};return n.Mat44=Sk.misceval.buildClass(n,(function(e,t){t.__init__=new Sk.builtin.func((function(e){Sk.misceval.callsimArray(t.loadIdentity,[e]),e.stack=[]})),t.push=new Sk.builtin.func((function(e){e.stack.push(e.elements.slice(0))})),t.pop=new Sk.builtin.func((function(e){e.elements=e.stack.pop()})),t.loadIdentity=new Sk.builtin.func((function(e){e.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]})),t.transform3=new Sk.builtin.func((function(e,t){var l=e.elements;return Sk.misceval.callsimArray(n.Vec3,[l[0]*t.x+l[4]*t.y+l[8]*t.z,l[1]*t.x+l[5]*t.y+l[9]*t.z,l[2]*t.x+l[6]*t.y+l[10]*t.z])})),t.scale=new Sk.builtin.func((function(e,n,t,l){return e.elements[0]*=n,e.elements[1]*=n,e.elements[2]*=n,e.elements[3]*=n,e.elements[4]*=t,e.elements[5]*=t,e.elements[6]*=t,e.elements[7]*=t,e.elements[8]*=l,e.elements[9]*=l,e.elements[10]*=l,e.elements[11]*=l,e})),t.translate=new Sk.builtin.func((function(e,n,t,l){return e.elements[12]+=e.elements[0]*n+e.elements[4]*t+e.elements[8]*l,e.elements[13]+=e.elements[1]*n+e.elements[5]*t+e.elements[9]*l,e.elements[14]+=e.elements[2]*n+e.elements[6]*t+e.elements[10]*l,e.elements[15]+=e.elements[3]*n+e.elements[7]*t+e.elements[11]*l,e})),t.rotate=new Sk.builtin.func((function(e,t,l,s,m){var i,a,c,u,r,f,o,k,S,y,b,v=Math.sqrt(l*l+s*s+m*m),_=Math.sin(t*Math.PI/180),w=Math.cos(t*Math.PI/180);v>0&&(i=(l/=v)*l,a=(s/=v)*s,c=(m/=v)*m,u=l*s,r=s*m,f=m*l,o=l*_,k=s*_,S=m*_,y=1-w,(b=Sk.misceval.callsimArray(n.Mat44)).elements[0]=y*i+w,b.elements[1]=y*u-S,b.elements[2]=y*f+k,b.elements[3]=0,b.elements[4]=y*u+S,b.elements[5]=y*a+w,b.elements[6]=y*r-o,b.elements[7]=0,b.elements[8]=y*f-k,b.elements[9]=y*r+o,b.elements[10]=y*c+w,b.elements[11]=0,b.elements[12]=0,b.elements[13]=0,b.elements[14]=0,b.elements[15]=1,b=b.multiply(e),e.elements=b.elements);return e})),t.multiply=new Sk.builtin.func((function(e,t){for(var l=Sk.misceval.callsimArray(n.Mat44),s=0;s<4;s++)l.elements[4*s+0]=e.elements[4*s+0]*t.elements[0]+e.elements[4*s+1]*t.elements[4]+e.elements[4*s+2]*t.elements[8]+e.elements[4*s+3]*t.elements[12],l.elements[4*s+1]=e.elements[4*s+0]*t.elements[1]+e.elements[4*s+1]*t.elements[5]+e.elements[4*s+2]*t.elements[9]+e.elements[4*s+3]*t.elements[13],l.elements[4*s+2]=e.elements[4*s+0]*t.elements[2]+e.elements[4*s+1]*t.elements[6]+e.elements[4*s+2]*t.elements[10]+e.elements[4*s+3]*t.elements[14],l.elements[4*s+3]=e.elements[4*s+0]*t.elements[3]+e.elements[4*s+1]*t.elements[7]+e.elements[4*s+2]*t.elements[11]+e.elements[4*s+3]*t.elements[15];return e.elements=l.elements,e})),t.lookAt=new Sk.builtin.func((function(e,t,l,s,m,i,a,c,u,r){var f=[t-m,l-i,s-a],o=Math.sqrt(f[0]*f[0]+f[1]*f[1]+f[2]*f[2]);o&&(f[0]/=o,f[1]/=o,f[2]/=o);var k=[c,u,r],S=[];S[0]=k[1]*f[2]-k[2]*f[1],S[1]=-k[0]*f[2]+k[2]*f[0],S[2]=k[0]*f[1]-k[1]*f[0],k[0]=f[1]*S[2]-f[2]*S[1],k[1]=-f[0]*S[2]+f[2]*S[0],k[2]=f[0]*S[1]-f[1]*S[0],(o=Math.sqrt(S[0]*S[0]+S[1]*S[1]+S[2]*S[2]))&&(S[0]/=o,S[1]/=o,S[2]/=o),(o=Math.sqrt(k[0]*k[0]+k[1]*k[1]+k[2]*k[2]))&&(k[0]/=o,k[1]/=o,k[2]/=o);var y=Sk.misceval.callsimArray(n.Mat44);return y.elements[0]=S[0],y.elements[4]=S[1],y.elements[8]=S[2],y.elements[12]=0,y.elements[1]=k[0],y.elements[5]=k[1],y.elements[9]=k[2],y.elements[13]=0,y.elements[2]=f[0],y.elements[6]=f[1],y.elements[10]=f[2],y.elements[14]=0,y.elements[3]=0,y.elements[7]=0,y.elements[11]=0,y.elements[15]=1,y=y.multiply(e),e.elements=y.elements,e.translate(-t,-l,-s),e}))}),\"Mat44\",[]),n.Mat33=Sk.misceval.buildClass(n,(function(e,n){n.__init__=new Sk.builtin.func((function(e){Sk.misceval.callsimArray(n.loadIdentity,[e])})),n.loadIdentity=new Sk.builtin.func((function(e){e.elements=[1,0,0,0,1,0,0,0,1]}))}),\"Mat33\",[]),n.Vec3=Sk.misceval.buildClass(n,(function(e,t){t.__init__=new Sk.builtin.func((function(e,n,t,l){e.x=n,e.y=t,e.z=l})),t.__sub__=new Sk.builtin.func((function(e,t){return Sk.misceval.callsimArray(n.Vec3,[e.x-t.x,e.y-t.y,e.z-t.z])}))}),\"Vec3\",[]),n.cross=new Sk.builtin.func((function(e,t){return Sk.asserts.assert(e instanceof n.Vec3&&t instanceof n.Vec3),Sk.misceval.callsimArray(n.Vec3,[e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x])})),n};","src/lib/webgl/matrix4.js":"var $builtinmodule=function(n){var r={},t=new Float32Array(3),a=new Float32Array(3),u=new Float32Array(3),e=(new Float32Array(4),new Float32Array(4),new Float32Array(4),new Float32Array(16),new Float32Array(16),new Float32Array(16),function(n,r){for(var t=0,a=r.length,u=0;u<a;++u)t+=r[u]*r[u];if((t=Math.sqrt(t))>1e-5)for(u=0;u<a;++u)n[u]=r[u]/t;else for(u=0;u<a;++u)n[u]=0;return n}),cross=function(n,r,t){return n[0]=r[1]*t[2]-r[2]*t[1],n[1]=r[2]*t[0]-r[0]*t[2],n[2]=r[0]*t[1]-r[1]*t[0],n},dot=function(n,r){return n[0]*r[0]+n[1]*r[1]+n[2]*r[2]};return r.lookAt=new Sk.builtin.func((function(n,r,i,o){var v=a,f=u,l=e(t,function(n,r,t){for(var a=r.length,u=0;u<a;++u)n[u]=r[u]-t[u];return n}(t,r.v,i.v)),c=e(v,cross(v,o.v,l)),w=cross(f,l,c),h=n.v;return h[0]=c[0],h[1]=w[0],h[2]=l[0],h[3]=0,h[4]=c[1],h[5]=w[1],h[6]=l[1],h[7]=0,h[8]=c[2],h[9]=w[2],h[10]=l[2],h[11]=0,h[12]=-dot(c,r.v),h[13]=-dot(w,r.v),h[14]=-dot(l,r.v),h[15]=1,n})),r.perspective=new Sk.builtin.func((function(n,r,t,a,u){var e=Math.tan(.5*Math.PI-r*Math.PI/180*.5),i=1/(a-u),o=n.v;return o[0]=e/t,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=e,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=(a+u)*i,o[11]=-1,o[12]=0,o[13]=0,o[14]=a*u*i*2,o[15]=0,n})),r.rotationY=new Sk.builtin.func((function(n,r){var t=n.v,a=Math.cos(r*Math.PI/180),u=Math.sin(r*Math.PI/180);return t[0]=a,t[1]=0,t[2]=-u,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=u,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,n})),r.identity=new Sk.builtin.func((function(n){var r=n.v;return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,n})),r.mul=new Sk.builtin.func((function(n,r,t){var a=n.v,u=r.v,e=t.v,i=u[0],o=u[1],v=u[2],f=u[3],l=u[4],c=u[5],w=u[6],h=u[7],y=u[8],A=u[9],F=u[10],b=u[11],k=u[12],M=u[13],s=u[14],S=u[15],I=e[0],P=e[1],p=e[2],d=e[3],g=e[4],m=e[5],q=e[6],Y=e[7],$=e[8],j=e[9],x=e[10],z=e[11],B=e[12],C=e[13],D=e[14],E=e[15];return a[0]=i*I+o*g+v*$+f*B,a[1]=i*P+o*m+v*j+f*C,a[2]=i*p+o*q+v*x+f*D,a[3]=i*d+o*Y+v*z+f*E,a[4]=l*I+c*g+w*$+h*B,a[5]=l*P+c*m+w*j+h*C,a[6]=l*p+c*q+w*x+h*D,a[7]=l*d+c*Y+w*z+h*E,a[8]=y*I+A*g+F*$+b*B,a[9]=y*P+A*m+F*j+b*C,a[10]=y*p+A*q+F*x+b*D,a[11]=y*d+A*Y+F*z+b*E,a[12]=k*I+M*g+s*$+S*B,a[13]=k*P+M*m+s*j+S*C,a[14]=k*p+M*q+s*x+S*D,a[15]=k*d+M*Y+s*z+S*E,n})),r.invert=new Sk.builtin.func((function(n,r){var t=n.v,a=r.v,u=a[0],e=a[1],i=a[2],o=a[3],v=a[4],f=a[5],l=a[6],c=a[7],w=a[8],h=a[9],y=a[10],A=a[11],F=a[12],b=a[13],k=a[14],M=a[15],s=y*M,S=k*A,I=l*M,P=k*c,p=l*A,d=y*c,g=i*M,m=k*o,q=i*A,Y=y*o,$=i*c,j=l*o,x=w*b,z=F*h,B=v*b,C=F*f,D=v*h,E=w*f,G=u*b,H=F*e,J=u*h,K=w*e,L=u*f,N=v*e,O=s*f+P*h+p*b-(S*f+I*h+d*b),Q=S*e+g*h+Y*b-(s*e+m*h+q*b),R=I*e+m*f+$*b-(P*e+g*f+j*b),T=d*e+q*f+j*h-(p*e+Y*f+$*h),U=1/(u*O+v*Q+w*R+F*T);return t[0]=U*O,t[1]=U*Q,t[2]=U*R,t[3]=U*T,t[4]=U*(S*v+I*w+d*F-(s*v+P*w+p*F)),t[5]=U*(s*u+m*w+q*F-(S*u+g*w+Y*F)),t[6]=U*(P*u+g*v+j*F-(I*u+m*v+$*F)),t[7]=U*(p*u+Y*v+$*w-(d*u+q*v+j*w)),t[8]=U*(x*c+C*A+D*M-(z*c+B*A+E*M)),t[9]=U*(z*o+G*A+K*M-(x*o+H*A+J*M)),t[10]=U*(B*o+H*c+L*M-(C*o+G*c+N*M)),t[11]=U*(E*o+J*c+N*A-(D*o+K*c+L*A)),t[12]=U*(B*y+E*k+z*l-(D*k+x*l+C*y)),t[13]=U*(J*k+x*i+H*y-(G*y+K*k+z*i)),t[14]=U*(G*l+N*k+C*i-(L*k+B*i+H*l)),t[15]=U*(L*y+D*i+K*l-(J*l+N*y+E*i)),n})),r.transpose=new Sk.builtin.func((function(n,r){for(var t=n.v,a=r.v,u=0;u<4;++u)for(var e=0;e<4;++e)t[4*u+e]=a[4*e+u];return t})),r};","src/lib/webgl/models.js":"var $builtinmodule=function(t){return Sk.misceval.chain(Sk.importModule(\"webgl\",!1,!0),(e=>{const n=e.$d;var r={},Buffer=function(t,e){var r=e||n.ARRAY_BUFFER,i=n.createBuffer();if(this.target=r,this.buf=i,this.set(t),this.numComponents_=t.numComponents,this.numElements_=t.numElements,this.totalComponents_=this.numComponents_*this.numElements_,t.buffer instanceof Float32Array)this.type_=n.FLOAT;else if(t.buffer instanceof Uint8Array)this.type_=n.UNSIGNED_BYTE;else if(t.buffer instanceof Int8Array)this.type_=n._BYTE;else if(t.buffer instanceof Uint16Array)this.type_=n.UNSIGNED_SHORT;else{if(!(t.buffer instanceof Int16Array))throw\"unhandled type:\"+typeof t.buffer;this.type_=n.SHORT}};return Buffer.prototype.set=function(t){n.bindBuffer(this.target,this.buf),n.bufferData(this.target,t.buffer,n.STATIC_DRAW)},Buffer.prototype.type=function(){return this.type_},Buffer.prototype.numComponents=function(){return this.numComponents_},Buffer.prototype.numElements=function(){return this.numElements_},Buffer.prototype.totalComponents=function(){return this.totalComponents_},Buffer.prototype.buffer=function(){return this.buf},Buffer.prototype.stride=function(){return 0},Buffer.prototype.offset=function(){return 0},r.Model=Sk.misceval.buildClass(r,(function(e,r){r.__init__=new Sk.builtin.func((function(e,r,i,f){e.buffers={};var setBuffer=function(t,r){var i=\"indices\"==t?n.ELEMENT_ARRAY_BUFFER:n.ARRAY_BUFFER;let f=e.buffers[t];f?f.set(r):f=new Buffer(r,i),e.buffers[t]=f};for(t in i)setBuffer(t,i[t]);var o={},s=0;for(var u in f)o[u]=s++;e.mode=n.TRIANGLES,e.textures=f.v,e.textureUnits=o,e.shader=r})),r.drawPrep=new Sk.builtin.func((function(t,e){var r=t.shader,i=t.buffers,f=t.textures;for(var o in e=Sk.ffi.remapToJs(e),Sk.misceval.callsimArray(r.use,[r]),i){var s=i[o];if(\"indices\"==o)n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,s.buffer());else{var u=r.attrib[o];u&&u(s)}}for(var a in f){var m=t.textureUnits[a];r.setUniform$impl(r,f,m),f[a].bindToUnit(m)}for(var p in e)r.setUniform$impl(r,p,e[p])})),r.draw=new Sk.builtin.func((function(t,e,r){var i=t.shader;e=Sk.ffi.remapToJs(e);for(let n in e)i.setUniform$impl(i,n,e[n]);if(r)for(var f in r){var o=t.textureUnits[f];i.setUniform$impl(i,f,o),r[f].bindToUnit(o)}var s=t.buffers;n.drawElements(t.mode,s.indices.totalComponents(),n.UNSIGNED_SHORT,0)}))}),\"Model\",[]),r}))};","src/lib/webgl/primitives.js":"var $builtinmodule=function(t){var n={},AttribBuffer=function(t,n,e){e=e||\"Float32Array\";var r=window[e];n.length?(this.buffer=new r(n),n=this.buffer.length/t,this.cursor=n):(this.buffer=new r(t*n),this.cursor=0),this.numComponents=t,this.numElements=n,this.type=e};return AttribBuffer.prototype.stride=function(){return 0},AttribBuffer.prototype.offset=function(){return 0},AttribBuffer.prototype.getElement=function(t){for(var n=t*this.numComponents,e=[],r=0;r<this.numComponents;++r)e.push(this.buffer[n+r]);return e},AttribBuffer.prototype.setElement=function(t,n){for(var e=t*this.numComponents,r=0;r<this.numComponents;++r)this.buffer[e+r]=n[r]},AttribBuffer.prototype.clone=function(){var t=new AttribBuffer(this.numComponents,this.numElements,this.type);return t.pushArray(this),t},AttribBuffer.prototype.push=function(t){this.setElement(this.cursor++,t)},AttribBuffer.prototype.pushArray=function(t){for(var n=0;n<t.numElements;++n)this.push(t.getElement(n))},AttribBuffer.prototype.pushArrayWithOffset=function(t,n){for(var e=0;e<t.numElements;++e){for(var r=t.getElement(e),o=0;o<n.length;++o)r[o]+=n[o];this.push(r)}},AttribBuffer.prototype.computeExtents=function(){for(var t=this.numElements,n=this.numComponents,e=this.getElement(0),r=this.getElement(0),o=1;o<t;++o)for(var s=this.getElement(o),u=0;u<n;++u)e[u]=Math.min(e[u],s[u]),r[u]=Math.max(r[u],s[u]);return{min:e,max:r}},n.createCube=new Sk.builtin.func((function(t){for(var n=[[3,7,5,1],[0,4,6,2],[6,7,3,2],[0,1,5,4],[5,7,6,4],[2,3,1,0]],e=t/2,r=[[-e,-e,-e],[+e,-e,-e],[-e,+e,-e],[+e,+e,-e],[-e,-e,+e],[+e,-e,+e],[-e,+e,+e],[+e,+e,+e]],o=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],s=[[0,0],[1,0],[1,1],[0,1]],u=new AttribBuffer(3,24),i=new AttribBuffer(3,24),h=new AttribBuffer(2,24),p=new AttribBuffer(3,12,\"Uint16Array\"),m=0;m<6;++m){for(var f=n[m],a=0;a<4;++a){var l=r[f[a]],c=o[m],y=s[a];u.push(l),i.push(c),h.push(y)}var v=4*m;p.push([v+0,v+1,v+2]),p.push([v+0,v+2,v+3])}return{position:u,normal:i,texCoord:h,indices:p}})),n};"}}

/***/ }),

/***/ 53098:
/*!***********************************************!*\
  !*** ./runestone/activecode/js/skulpt.min.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

(function(){/*
 unicode_hack.js
    Copyright (C) 2010-2012  Marcelo Gibson de Castro Gonçalves. All rights reserved.

    Copying and distribution of this file, with or without modification,
    are permitted in any medium without royalty provided the copyright
    notice and this notice are preserved.  This file is offered as-is,
    without any warranty.
*/
'use strict';var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.ISOLATE_POLYFILLS=!1;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(E,Q,b){if(E==Array.prototype||E==Object.prototype)return E;E[Q]=b.value;return E};
$jscomp.getGlobal=function(E){E=["object"==typeof globalThis&&globalThis,E,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof __webpack_require__.g&&__webpack_require__.g];for(var Q=0;Q<E.length;++Q){var b=E[Q];if(b&&b.Math==Math)return b}throw Error("Cannot find global object");};$jscomp.global=$jscomp.getGlobal(this);$jscomp.IS_SYMBOL_NATIVE="function"===typeof Symbol&&"symbol"===typeof Symbol("x");$jscomp.TRUST_ES6_POLYFILLS=!$jscomp.ISOLATE_POLYFILLS||$jscomp.IS_SYMBOL_NATIVE;$jscomp.polyfills={};
$jscomp.propertyToPolyfillSymbol={};$jscomp.POLYFILL_PREFIX="$jscp$";var $jscomp$lookupPolyfilledValue=function(E,Q){var b=$jscomp.propertyToPolyfillSymbol[Q];if(null==b)return E[Q];b=E[b];return void 0!==b?b:E[Q]};$jscomp.polyfill=function(E,Q,b,f){Q&&($jscomp.ISOLATE_POLYFILLS?$jscomp.polyfillIsolated(E,Q,b,f):$jscomp.polyfillUnisolated(E,Q,b,f))};
$jscomp.polyfillUnisolated=function(E,Q,b,f){b=$jscomp.global;E=E.split(".");for(f=0;f<E.length-1;f++){var e=E[f];if(!(e in b))return;b=b[e]}E=E[E.length-1];f=b[E];Q=Q(f);Q!=f&&null!=Q&&$jscomp.defineProperty(b,E,{configurable:!0,writable:!0,value:Q})};
$jscomp.polyfillIsolated=function(E,Q,b,f){var e=E.split(".");E=1===e.length;f=e[0];f=!E&&f in $jscomp.polyfills?$jscomp.polyfills:$jscomp.global;for(var g=0;g<e.length-1;g++){var k=e[g];if(!(k in f))return;f=f[k]}e=e[e.length-1];b=$jscomp.IS_SYMBOL_NATIVE&&"es6"===b?f[e]:null;Q=Q(b);null!=Q&&(E?$jscomp.defineProperty($jscomp.polyfills,e,{configurable:!0,writable:!0,value:Q}):Q!==b&&(void 0===$jscomp.propertyToPolyfillSymbol[e]&&($jscomp.propertyToPolyfillSymbol[e]=$jscomp.IS_SYMBOL_NATIVE?$jscomp.global.Symbol(e):
$jscomp.POLYFILL_PREFIX+e),$jscomp.defineProperty(f,$jscomp.propertyToPolyfillSymbol[e],{configurable:!0,writable:!0,value:Q})))};$jscomp.polyfill("Array.prototype.flat",function(E){return E?E:function(Q){Q=void 0===Q?1:Q;for(var b=[],f=0;f<this.length;f++){var e=this[f];Array.isArray(e)&&0<Q?(e=Array.prototype.flat.call(e,Q-1),b.push.apply(b,e)):b.push(e)}return b}},"es9","es5");
$jscomp.polyfill("Array.prototype.includes",function(E){return E?E:function(Q,b){var f=this;f instanceof String&&(f=String(f));var e=f.length;b=b||0;for(0>b&&(b=Math.max(b+e,0));b<e;b++){var g=f[b];if(g===Q||Object.is(g,Q))return!0}return!1}},"es7","es3");$jscomp.owns=function(E,Q){return Object.prototype.hasOwnProperty.call(E,Q)};$jscomp.polyfill("Object.entries",function(E){return E?E:function(Q){var b=[],f;for(f in Q)$jscomp.owns(Q,f)&&b.push([f,Q[f]]);return b}},"es8","es3");
$jscomp.arrayIteratorImpl=function(E){var Q=0;return function(){return Q<E.length?{done:!1,value:E[Q++]}:{done:!0}}};$jscomp.arrayIterator=function(E){return{next:$jscomp.arrayIteratorImpl(E)}};$jscomp.initSymbol=function(){};$jscomp.iteratorPrototype=function(E){E={next:E};E[Symbol.iterator]=function(){return this};return E};
$jscomp.polyfill("Object.fromEntries",function(E){return E?E:function(Q){var b={};if(!(Symbol.iterator in Q))throw new TypeError(""+Q+" is not iterable");Q=Q[Symbol.iterator].call(Q);for(var f=Q.next();!f.done;f=Q.next()){f=f.value;if(Object(f)!==f)throw new TypeError("iterable for fromEntries should yield objects");b[f[0]]=f[1]}return b}},"es_2019","es3");
$jscomp.checkStringArgs=function(E,Q,b){if(null==E)throw new TypeError("The 'this' value for String.prototype."+b+" must not be null or undefined");if(Q instanceof RegExp)throw new TypeError("First argument to String.prototype."+b+" must not be a regular expression");return E+""};$jscomp.stringPadding=function(E,Q){E=void 0!==E?String(E):" ";return 0<Q&&E?E.repeat(Math.ceil(Q/E.length)).substring(0,Q):""};
$jscomp.polyfill("String.prototype.padStart",function(E){return E?E:function(Q,b){var f=$jscomp.checkStringArgs(this,null,"padStart");return $jscomp.stringPadding(b,Q-f.length)+f}},"es8","es3");$jscomp.polyfill("Object.values",function(E){return E?E:function(Q){var b=[],f;for(f in Q)$jscomp.owns(Q,f)&&b.push(Q[f]);return b}},"es8","es3");
$jscomp.iteratorFromArray=function(E,Q){E instanceof String&&(E+="");var b=0,f=!1,e={next:function(){if(!f&&b<E.length){var g=b++;return{value:Q(g,E[g]),done:!1}}f=!0;return{done:!0,value:void 0}}};e[Symbol.iterator]=function(){return e};return e};$jscomp.polyfill("Array.prototype.values",function(E){return E?E:function(){return $jscomp.iteratorFromArray(this,function(Q,b){return b})}},"es8","es3");
(function(E){function Q(f){if(b[f])return b[f].exports;var e=b[f]={i:f,l:!1,exports:{}};E[f].call(e.exports,e,e.exports,Q);e.l=!0;return e.exports}var b={};Q.m=E;Q.c=b;Q.d=function(f,e,g){Q.o(f,e)||Object.defineProperty(f,e,{enumerable:!0,get:g})};Q.r=function(f){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(f,Symbol.toStringTag,{value:"Module"});Object.defineProperty(f,"__esModule",{value:!0})};Q.t=function(f,e){e&1&&(f=Q(f));if(e&8||e&4&&"object"===typeof f&&f&&f.__esModule)return f;
var g=Object.create(null);Q.r(g);Object.defineProperty(g,"default",{enumerable:!0,value:f});if(e&2&&"string"!=typeof f)for(var k in f)Q.d(g,k,function(p){return f[p]}.bind(null,k));return g};Q.n=function(f){var e=f&&f.__esModule?function(){return f["default"]}:function(){return f};Q.d(e,"a",e);return e};Q.o=function(f,e){return Object.prototype.hasOwnProperty.call(f,e)};Q.p="";return Q(Q.s=1)})([function(E,Q){Q=function(){return this}();try{Q=Q||(new Function("return this"))()}catch(b){"object"===
typeof window&&(Q=window)}E.exports=Q},function(E,Q,b){b(2);Sk.global.strftime=b(3);b(4);b(6);b(7);b(9);b(10);b(11);b(12);b(13);b(14);b(15);b(16);b(17);b(18);[Sk.builtin.object,Sk.builtin.type].forEach(f=>{Sk.abstr.setUpSlots(f);Sk.abstr.setUpMethods(f);Sk.abstr.setUpGetSets(f);Sk.abstr.setUpClassMethods(f)});b(19);b(20);b(21);[Sk.builtin.str,Sk.builtin.none,Sk.builtin.NotImplemented,Sk.builtin.object].forEach(f=>{f=f.prototype;f.__doc__=f.hasOwnProperty("tp$doc")?new Sk.builtin.str(f.tp$doc):Sk.builtin.none.none$});
b(22);b(23);b(24);b(25);b(26);b(27);b(28);b(29);b(31);b(32);b(33);b(34);b(35);b(36);b(37);b(38);b(39);b(40);b(41);b(42);b(43);b(44);b(45);b(46);b(47);b(48);b(49);b(50);b(51);b(52);b(53);b(66);b(54);b(55);b(56);b(57);b(58);b(59);b(60);b(61);b(62);b(63);b(64);b(65)},function(E,Q,b){(function(f){var e={build:{githash:"d58dc11c5bf02f5c934020aefa4029d5a90deb34",date:"2023-02-02T01:09:13.560Z"}};e.global="undefined"!==typeof f?f:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{};e.exportSymbol=
function(g,k){g=g.split(".");var p=e.global,h;for(h=0;h<g.length-1;h++){var a=g[h];p=p.hasOwnProperty(a)?p[a]:p[a]={}}"undefined"!==typeof k&&(a=g[h],p[a]=k)};e.isArrayLike=function(g){return g instanceof Array||g&&g.length&&"number"==typeof g.length?!0:!1};e.js_beautify=function(g){return g};e.exportSymbol("Sk",e);e.exportSymbol("Sk.global",e.global);e.exportSymbol("Sk.build",e.build);e.exportSymbol("Sk.exportSymbol",e.exportSymbol);e.exportSymbol("Sk.isArrayLike",e.isArrayLike);e.exportSymbol("Sk.js_beautify",
e.js_beautify)}).call(this,b(0))},function(E,Q){(function(){function b(d,l,r){function v(N,A,H,x){for(var B="",F=null,J=!1,P=N.length,W=!1,ca=0;ca<P;ca++){var ha=N.charCodeAt(ca);if(!0===J)if(45===ha)F="";else if(95===ha)F=" ";else if(48===ha)F="0";else if(58===ha)W&&h("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime"),W=!0;else{switch(ha){case 37:B+="%";break;case 65:B+=H.days[A.getDay()];break;case 66:B+=H.months[A.getMonth()];break;case 67:B+=f(Math.floor(A.getFullYear()/
100),F);break;case 68:B+=v(H.formats.D,A,H,x);break;case 70:B+=v(H.formats.F,A,H,x);break;case 72:B+=f(A.getHours(),F);break;case 73:B+=f(g(A.getHours()),F);break;case 76:B+=e(Math.floor(x%1E3));break;case 77:B+=f(A.getMinutes(),F);break;case 80:B+=12>A.getHours()?H.am:H.pm;break;case 82:B+=v(H.formats.R,A,H,x);break;case 83:B+=f(A.getSeconds(),F);break;case 84:B+=v(H.formats.T,A,H,x);break;case 85:B+=f(k(A,"sunday"),F);break;case 87:B+=f(k(A,"monday"),F);break;case 88:B+=v(H.formats.X,A,H,x);break;
case 89:B+=A.getFullYear();break;case 90:w&&0===t?B+="GMT":(F=A.toString().match(/\(([\w\s]+)\)/),B+=F&&F[1]||"");break;case 97:B+=H.shortDays[A.getDay()];break;case 98:B+=H.shortMonths[A.getMonth()];break;case 99:B+=v(H.formats.c,A,H,x);break;case 100:B+=f(A.getDate(),F);break;case 101:B+=f(A.getDate(),null==F?" ":F);break;case 104:B+=H.shortMonths[A.getMonth()];break;case 106:F=new Date(A.getFullYear(),0,1);F=Math.ceil((A.getTime()-F.getTime())/864E5);B+=e(F);break;case 107:B+=f(A.getHours(),null==
F?" ":F);break;case 108:B+=f(g(A.getHours()),null==F?" ":F);break;case 109:B+=f(A.getMonth()+1,F);break;case 110:B+="\n";break;case 111:F=A.getDate();B=H.ordinalSuffixes?B+(String(F)+(H.ordinalSuffixes[F-1]||p(F))):B+(String(F)+p(F));break;case 112:B+=12>A.getHours()?H.AM:H.PM;break;case 114:B+=v(H.formats.r,A,H,x);break;case 115:B+=Math.floor(x/1E3);break;case 116:B+="\t";break;case 117:F=A.getDay();B+=0===F?7:F;break;case 118:B+=v(H.formats.v,A,H,x);break;case 119:B+=A.getDay();break;case 120:B+=
v(H.formats.x,A,H,x);break;case 121:B+=(""+A.getFullYear()).slice(2);break;case 122:w&&0===t?B+=W?"+00:00":"+0000":(F=0!==t?t/6E4:-A.getTimezoneOffset(),J=W?":":"",ha=Math.abs(F%60),B+=(0>F?"-":"+")+f(Math.floor(Math.abs(F/60)))+J+f(ha));break;default:J&&(B+="%"),B+=N[ca]}F=null;J=!1}else 37===ha?J=!0:B+=N[ca]}return B}var q=d||c,t=l||0,w=r||!1,C=0,D,L=function(N,A){if(A){var H=A.getTime();if(w){var x=6E4*(A.getTimezoneOffset()||0);A=new Date(H+x+t);6E4*(A.getTimezoneOffset()||0)!==x&&(A=6E4*(A.getTimezoneOffset()||
0),A=new Date(H+A+t))}}else H=Date.now(),H>C?(C=H,D=new Date(C),H=C,w&&(D=new Date(C+6E4*(D.getTimezoneOffset()||0)+t))):H=C,A=D;return v(N,A,q,H)};L.localize=function(N){return new b(N||q,t,w)};L.localizeByIdentifier=function(N){var A=a[N];return A?L.localize(A):(h('[WARNING] No locale found with identifier "'+N+'".'),L)};L.timezone=function(N){var A=t,H=w,x=typeof N;if("number"===x||"string"===x)H=!0,"string"===x?(A="-"===N[0]?-1:1,x=parseInt(N.slice(1,3),10),N=parseInt(N.slice(3,5),10),A=A*(60*
x+N)*6E4):"number"===x&&(A=6E4*N);return new b(q,A,H)};L.utc=function(){return new b(q,t,!0)};return L}function f(d,l){if(""===l||9<d)return d;null==l&&(l="0");return l+d}function e(d){return 99<d?d:9<d?"0"+d:"00"+d}function g(d){return 0===d?12:12<d?d-12:d}function k(d,l){l=l||"sunday";var r=d.getDay();"monday"===l&&(0===r?r=6:r--);l=Date.UTC(d.getFullYear(),0,1);d=Date.UTC(d.getFullYear(),d.getMonth(),d.getDate());return Math.floor((Math.floor((d-l)/864E5)+7-r)/7)}function p(d){var l=d%10;d%=100;
if(11<=d&&13>=d||0===l||4<=l)return"th";switch(l){case 1:return"st";case 2:return"nd";case 3:return"rd"}}function h(d){"undefined"!==typeof console&&"function"==typeof console.warn&&console.warn(d)}var a={de_DE:{days:"Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag".split(" "),shortDays:"So Mo Di Mi Do Fr Sa".split(" "),months:"Januar Februar M\u00e4rz April Mai Juni Juli August September Oktober November Dezember".split(" "),shortMonths:"Jan Feb M\u00e4r Apr Mai Jun Jul Aug Sep Okt Nov Dez".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d.%m.%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},en_CA:{days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),ordinalSuffixes:"st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}},en_US:{days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),ordinalSuffixes:"st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%m/%d/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}},es_MX:{days:"domingo lunes martes mi\u00e9rcoles jueves viernes s\u00e1bado".split(" "),shortDays:"dom lun mar mi\u00e9 jue vie s\u00e1b".split(" "),months:"enero;febrero;marzo;abril;mayo;junio;julio;agosto;septiembre;octubre;noviembre; diciembre".split(";"),shortMonths:"ene feb mar abr may jun jul ago sep oct nov dic".split(" "),AM:"AM",PM:"PM",
am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},fr_FR:{days:"dimanche lundi mardi mercredi jeudi vendredi samedi".split(" "),shortDays:"dim. lun. mar. mer. jeu. ven. sam.".split(" "),months:"janvier f\u00e9vrier mars avril mai juin juillet ao\u00fbt septembre octobre novembre d\u00e9cembre".split(" "),shortMonths:"janv. f\u00e9vr. mars avril mai juin juil. ao\u00fbt sept. oct. nov. d\u00e9c.".split(" "),AM:"AM",
PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},it_IT:{days:"domenica luned\u00ec marted\u00ec mercoled\u00ec gioved\u00ec venerd\u00ec sabato".split(" "),shortDays:"dom lun mar mer gio ven sab".split(" "),months:"gennaio febbraio marzo aprile maggio giugno luglio agosto settembre ottobre novembre dicembre".split(" "),shortMonths:"pr mag giu lug ago set ott nov dic".split(" "),AM:"AM",PM:"PM",am:"am",
pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},nl_NL:{days:"zondag maandag dinsdag woensdag donderdag vrijdag zaterdag".split(" "),shortDays:"zo ma di wo do vr za".split(" "),months:"januari februari maart april mei juni juli augustus september oktober november december".split(" "),shortMonths:"jan feb mrt apr mei jun jul aug sep okt nov dec".split(" "),AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",
D:"%d-%m-%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},pt_BR:{days:"domingo segunda ter\u00e7a quarta quinta sexta s\u00e1bado".split(" "),shortDays:"Dom Seg Ter Qua Qui Sex S\u00e1b".split(" "),months:"janeiro fevereiro mar\u00e7o abril maio junho julho agosto setembro outubro novembro dezembro".split(" "),shortMonths:"Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez".split(" "),AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d-%m-%Y",F:"%Y-%m-%d",
R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},ru_RU:{days:"\u0412\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435 \u041f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a \u0412\u0442\u043e\u0440\u043d\u0438\u043a \u0421\u0440\u0435\u0434\u0430 \u0427\u0435\u0442\u0432\u0435\u0440\u0433 \u041f\u044f\u0442\u043d\u0438\u0446\u0430 \u0421\u0443\u0431\u0431\u043e\u0442\u0430".split(" "),shortDays:"\u0412\u0441 \u041f\u043d \u0412\u0442 \u0421\u0440 \u0427\u0442 \u041f\u0442 \u0421\u0431".split(" "),
months:"\u042f\u043d\u0432\u0430\u0440\u044c \u0424\u0435\u0432\u0440\u0430\u043b\u044c \u041c\u0430\u0440\u0442 \u0410\u043f\u0440\u0435\u043b\u044c \u041c\u0430\u0439 \u0418\u044e\u043d\u044c \u0418\u044e\u043b\u044c \u0410\u0432\u0433\u0443\u0441\u0442 \u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c \u041e\u043a\u0442\u044f\u0431\u0440\u044c \u041d\u043e\u044f\u0431\u0440\u044c \u0414\u0435\u043a\u0430\u0431\u0440\u044c".split(" "),shortMonths:"\u044f\u043d\u0432 \u0444\u0435\u0432 \u043c\u0430\u0440 \u0430\u043f\u0440 \u043c\u0430\u0439 \u0438\u044e\u043d \u0438\u044e\u043b \u0430\u0432\u0433 \u0441\u0435\u043d \u043e\u043a\u0442 \u043d\u043e\u044f \u0434\u0435\u043a".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X",D:"%d.%m.%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},tr_TR:{days:"Pazar Pazartesi Sal\u0131 \u00c7ar\u015famba Per\u015fembe Cuma Cumartesi".split(" "),shortDays:"Paz Pzt Sal \u00c7r\u015f Pr\u015f Cum Cts".split(" "),months:"Ocak \u015eubat Mart Nisan May\u0131s Haziran Temmuz A\u011fustos Eyl\u00fcl Ekim Kas\u0131m Aral\u0131k".split(" "),shortMonths:"Oca \u015eub Mar Nis May Haz Tem A\u011fu Eyl Eki Kas Ara".split(" "),
AM:"\u00d6\u00d6",PM:"\u00d6S",am:"\u00d6\u00d6",pm:"\u00d6S",formats:{c:"%a %d %b %Y %X %Z",D:"%d-%m-%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},zh_CN:{days:"\u661f\u671f\u65e5 \u661f\u671f\u4e00 \u661f\u671f\u4e8c \u661f\u671f\u4e09 \u661f\u671f\u56db \u661f\u671f\u4e94 \u661f\u671f\u516d".split(" "),shortDays:"\u65e5\u4e00\u4e8c\u4e09\u56db\u4e94\u516d".split(""),months:"\u4e00\u6708\u4efd \u4e8c\u6708\u4efd \u4e09\u6708\u4efd \u56db\u6708\u4efd \u4e94\u6708\u4efd \u516d\u6708\u4efd \u4e03\u6708\u4efd \u516b\u6708\u4efd \u4e5d\u6708\u4efd \u5341\u6708\u4efd \u5341\u4e00\u6708\u4efd \u5341\u4e8c\u6708\u4efd".split(" "),
shortMonths:"\u4e00\u6708 \u4e8c\u6708 \u4e09\u6708 \u56db\u6708 \u4e94\u6708 \u516d\u6708 \u4e03\u6708 \u516b\u6708 \u4e5d\u6708 \u5341\u6708 \u5341\u4e00\u6708 \u5341\u4e8c\u6708".split(" "),AM:"\u4e0a\u5348",PM:"\u4e0b\u5348",am:"\u4e0a\u5348",pm:"\u4e0b\u5348",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}}},c=a.en_US,m=new b(c,0,!1);if("undefined"!==typeof E)var n=E.exports=m;else n=function(){return this||(0,eval)("this")}(),
n.strftime=m;"function"!==typeof Date.now&&(Date.now=function(){return+new Date})})()},function(E,Q,b){E=b(5);const f=Sk.global.JSBI=void 0!==Sk.global.BigInt?{}:E;void 0===Sk.global.BigInt?(f.__isBigInt||(f.__isBigInt=e=>e instanceof f),f.powermod=(e,g,k)=>{const p=f.BigInt(1);let h=p;for(g=f.greaterThan(g,f.__ZERO)?g:f.unaryMinus(g);f.greaterThan(g,f.__ZERO);)f.bitwiseAnd(g,p)&&(h=f.remainder(f.multiply(h,e),k)),g=f.signedRightShift(g,p),e=f.remainder(f.multiply(e,e),k);return h}):Object.assign(f,
{BigInt:Sk.global.BigInt,toNumber:e=>Number(e),toString:e=>e.toString(),__isBigInt:e=>"bigint"===typeof e,unaryMinus:e=>-e,bitwiseNot:e=>~e,bitwiseAnd:(e,g)=>e&g,bitwiseOr:(e,g)=>e|g,bitwiseXor:(e,g)=>e^g,exponentiate:(e,g)=>{const k=f.BigInt(1);let p=k;for(g=g>f.__ZERO?g:-g;g>f.__ZERO;)g&k&&(p*=e),g>>=k,e*=e;return p},powermod:(e,g,k)=>{const p=f.BigInt(1);let h=p;for(g=g>f.__ZERO?g:-g;g>f.__ZERO;)g&p&&(h=h*e%k),g>>=p,e=e*e%k;return h},multiply:(e,g)=>e*g,divide:(e,g)=>e/g,remainder:(e,g)=>e%g,add:(e,
g)=>e+g,subtract:(e,g)=>e-g,leftShift:(e,g)=>e<<g,signedRightShift:(e,g)=>e>>g,unsignedRightShift:(e,g)=>e>>>g,lessThan:(e,g)=>e<g,lessThanOrEqual:(e,g)=>e<=g,greaterThan:(e,g)=>e>g,greaterThanOrEqual:(e,g)=>e>=g,equal:(e,g)=>e===g,notEqual:(e,g)=>e!==g});f.__ZERO=f.BigInt(0);f.__MAX_SAFE=f.BigInt(Number.MAX_SAFE_INTEGER);f.__MIN_SAFE=f.BigInt(-Number.MAX_SAFE_INTEGER);f.numberIfSafe=e=>f.lessThan(e,f.__MAX_SAFE)&&f.greaterThan(e,f.__MIN_SAFE)?f.toNumber(e):e},function(E,Q,b){(function(f,e){E.exports=
e()})(this,function(){var f=Math.imul,e=Math.clz32,g=Math.abs,k=Math.max,p=Math.floor;class h extends Array{constructor(a,c){if(super(a),this.sign=c,a>h.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded");}static BigInt(a){var c=Number.isFinite;if("number"==typeof a){if(0===a)return h.__zero();if(h.__isOneDigitInt(a))return 0>a?h.__oneDigit(-a,!0):h.__oneDigit(a,!1);if(!c(a)||p(a)!==a)throw new RangeError("The number "+a+" cannot be converted to BigInt because it is not an integer");
return h.__fromDouble(a)}if("string"==typeof a){c=h.__fromString(a);if(null===c)throw new SyntaxError("Cannot convert "+a+" to a BigInt");return c}if("boolean"==typeof a)return!0===a?h.__oneDigit(1,!1):h.__zero();if("object"==typeof a){if(a.constructor===h)return a;a=h.__toPrimitive(a);return h.BigInt(a)}throw new TypeError("Cannot convert "+a+" to a BigInt");}toDebugString(){const a=["BigInt["];for(const c of this)a.push((c?(c>>>0).toString(16):c)+", ");return a.push("]"),a.join("")}toString(a){a=
void 0===a?10:a;if(2>a||36<a)throw new RangeError("toString() radix argument must be between 2 and 36");return 0===this.length?"0":0==(a&a-1)?h.__toStringBasePowerOfTwo(this,a):h.__toStringGeneric(this,a,!1)}static toNumber(a){var c=a.length;if(0===c)return 0;if(1===c){var m=a.__unsignedDigit(0);return a.sign?-m:m}var n=a.__digit(c-1),d=h.__clz30(n);m=30*c-d;if(1024<m)return a.sign?-Infinity:1/0;--m;let l=c-1;var r=d+3;d=(32===r?0:n<<r)>>>12;const v=r-12;c=12<=r?0:n<<20+r;r=20+r;for(0<v&&0<l&&(l--,
n=a.__digit(l),d|=n>>>30-v,c=n<<v+2,r=v+2);0<r&&0<l;)l--,n=a.__digit(l),c|=30<=r?n<<r-30:n>>>30-r,r-=30;n=h.__decideRounding(a,r,l,n);if((1===n||0===n&&1==(1&c))&&(c=c+1>>>0,0===c&&(d++,0!=d>>>20&&(d=0,m++,1023<m))))return a.sign?-Infinity:1/0;a=a.sign?-2147483648:0;return m=m+1023<<20,h.__kBitConversionInts[1]=a|m|d,h.__kBitConversionInts[0]=c,h.__kBitConversionDouble[0]}static unaryMinus(a){if(0===a.length)return a;const c=a.__copy();return c.sign=!a.sign,c}static bitwiseNot(a){return a.sign?h.__absoluteSubOne(a).__trim():
h.__absoluteAddOne(a,!0)}static exponentiate(a,c){if(c.sign)throw new RangeError("Exponent must be positive");if(0===c.length)return h.__oneDigit(1,!1);if(0===a.length)return a;if(1===a.length&&1===a.__digit(0))return a.sign&&0==(1&c.__digit(0))?h.unaryMinus(a):a;if(1<c.length)throw new RangeError("BigInt too big");c=c.__unsignedDigit(0);if(1===c)return a;if(c>=h.__kMaxLengthBits)throw new RangeError("BigInt too big");if(1===a.length&&2===a.__digit(0)){var m=1+(0|c/30);a=new h(m,a.sign&&0!=(1&c));
a.__initializeDigits();return a.__setDigit(m-1,1<<c%30),a}m=null;let n=a;0!=(1&c)&&(m=a);for(c>>=1;0!==c;c>>=1)n=h.multiply(n,n),0!=(1&c)&&(null===m?m=n:m=h.multiply(m,n));return m}static multiply(a,c){if(0===a.length)return a;if(0===c.length)return c;var m=a.length+c.length;30<=a.__clzmsd()+c.__clzmsd()&&m--;m=new h(m,a.sign!==c.sign);m.__initializeDigits();for(let n=0;n<a.length;n++)h.__multiplyAccumulate(c,a.__digit(n),m,n);return m.__trim()}static divide(a,c){if(0===c.length)throw new RangeError("Division by zero");
if(0>h.__absoluteCompare(a,c))return h.__zero();const m=a.sign!==c.sign,n=c.__unsignedDigit(0);if(1===c.length&&32767>=n){if(1===n)return m===a.sign?a:h.unaryMinus(a);a=h.__absoluteDivSmall(a,n,null)}else a=h.__absoluteDivLarge(a,c,!0,!1);return a.sign=m,a.__trim()}static remainder(a,c){if(0===c.length)throw new RangeError("Division by zero");if(0>h.__absoluteCompare(a,c))return a;const m=c.__unsignedDigit(0);if(1===c.length&&32767>=m){if(1===m)return h.__zero();c=h.__absoluteModSmall(a,m);return 0===
c?h.__zero():h.__oneDigit(c,a.sign)}c=h.__absoluteDivLarge(a,c,!1,!0);return c.sign=a.sign,c.__trim()}static add(a,c){const m=a.sign;return m===c.sign?h.__absoluteAdd(a,c,m):0<=h.__absoluteCompare(a,c)?h.__absoluteSub(a,c,m):h.__absoluteSub(c,a,!m)}static subtract(a,c){const m=a.sign;return m===c.sign?0<=h.__absoluteCompare(a,c)?h.__absoluteSub(a,c,m):h.__absoluteSub(c,a,!m):h.__absoluteAdd(a,c,m)}static leftShift(a,c){return 0===c.length||0===a.length?a:c.sign?h.__rightShiftByAbsolute(a,c):h.__leftShiftByAbsolute(a,
c)}static signedRightShift(a,c){return 0===c.length||0===a.length?a:c.sign?h.__leftShiftByAbsolute(a,c):h.__rightShiftByAbsolute(a,c)}static unsignedRightShift(){throw new TypeError("BigInts have no unsigned right shift; use >> instead");}static lessThan(a,c){return 0>h.__compareToBigInt(a,c)}static lessThanOrEqual(a,c){return 0>=h.__compareToBigInt(a,c)}static greaterThan(a,c){return 0<h.__compareToBigInt(a,c)}static greaterThanOrEqual(a,c){return 0<=h.__compareToBigInt(a,c)}static equal(a,c){if(a.sign!==
c.sign||a.length!==c.length)return!1;for(let m=0;m<a.length;m++)if(a.__digit(m)!==c.__digit(m))return!1;return!0}static notEqual(a,c){return!h.equal(a,c)}static bitwiseAnd(a,c){if(!a.sign&&!c.sign)return h.__absoluteAnd(a,c).__trim();if(a.sign&&c.sign){const m=k(a.length,c.length)+1;a=h.__absoluteSubOne(a,m);c=h.__absoluteSubOne(c);return a=h.__absoluteOr(a,c,a),h.__absoluteAddOne(a,!0,a).__trim()}a.sign&&([a,c]=[c,a]);return h.__absoluteAndNot(a,h.__absoluteSubOne(c)).__trim()}static bitwiseXor(a,
c){if(!a.sign&&!c.sign)return h.__absoluteXor(a,c).__trim();if(a.sign&&c.sign){var m=k(a.length,c.length);a=h.__absoluteSubOne(a,m);c=h.__absoluteSubOne(c);return h.__absoluteXor(a,c,a).__trim()}m=k(a.length,c.length)+1;a.sign&&([a,c]=[c,a]);c=h.__absoluteSubOne(c,m);return c=h.__absoluteXor(c,a,c),h.__absoluteAddOne(c,!0,c).__trim()}static bitwiseOr(a,c){const m=k(a.length,c.length);if(!a.sign&&!c.sign)return h.__absoluteOr(a,c).__trim();if(a.sign&&c.sign)return a=h.__absoluteSubOne(a,m),c=h.__absoluteSubOne(c),
a=h.__absoluteAnd(a,c,a),h.__absoluteAddOne(a,!0,a).__trim();a.sign&&([a,c]=[c,a]);c=h.__absoluteSubOne(c,m);return c=h.__absoluteAndNot(c,a,c),h.__absoluteAddOne(c,!0,c).__trim()}static asIntN(a,c){if(0===c.length)return c;if(a=p(a),0>a)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===a)return h.__zero();if(a>=h.__kMaxLengthBits)return c;const m=0|(a+29)/30;if(c.length<m)return c;const n=c.__unsignedDigit(m-1),d=1<<(a-1)%30;if(c.length===m&&n<d)return c;if((n&d)!==
d)return h.__truncateToNBits(a,c);if(!c.sign)return h.__truncateAndSubFromPowerOfTwo(a,c,!0);if(0==(n&d-1)){for(let l=m-2;0<=l;l--)if(0!==c.__digit(l))return h.__truncateAndSubFromPowerOfTwo(a,c,!1);return c.length===m&&n===d?c:h.__truncateToNBits(a,c)}return h.__truncateAndSubFromPowerOfTwo(a,c,!1)}static asUintN(a,c){if(0===c.length)return c;if(a=p(a),0>a)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===a)return h.__zero();if(c.sign){if(a>h.__kMaxLengthBits)throw new RangeError("BigInt too big");
return h.__truncateAndSubFromPowerOfTwo(a,c,!1)}if(a>=h.__kMaxLengthBits)return c;const m=0|(a+29)/30;if(c.length<m)return c;const n=a%30;return c.length!=m||0!==n&&0!=c.__digit(m-1)>>>n?h.__truncateToNBits(a,c):c}static ADD(a,c){if(a=h.__toPrimitive(a),c=h.__toPrimitive(c),"string"==typeof a)return"string"!=typeof c&&(c=c.toString()),a+c;if("string"==typeof c)return a.toString()+c;if(a=h.__toNumeric(a),c=h.__toNumeric(c),h.__isBigInt(a)&&h.__isBigInt(c))return h.add(a,c);if("number"==typeof a&&"number"==
typeof c)return a+c;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");}static LT(a,c){return h.__compare(a,c,0)}static LE(a,c){return h.__compare(a,c,1)}static GT(a,c){return h.__compare(a,c,2)}static GE(a,c){return h.__compare(a,c,3)}static EQ(a,c){for(;;){if(h.__isBigInt(a))return h.__isBigInt(c)?h.equal(a,c):h.EQ(c,a);if("number"==typeof a){if(h.__isBigInt(c))return h.__equalToNumber(c,a);if("object"!=typeof c)return a==c;c=h.__toPrimitive(c)}else if("string"==
typeof a){if(h.__isBigInt(c))return a=h.__fromString(a),null!==a&&h.equal(a,c);if("object"!=typeof c)return a==c;c=h.__toPrimitive(c)}else if("boolean"==typeof a){if(h.__isBigInt(c))return h.__equalToNumber(c,+a);if("object"!=typeof c)return a==c;c=h.__toPrimitive(c)}else if("symbol"==typeof a){if(h.__isBigInt(c))return!1;if("object"!=typeof c)return a==c;c=h.__toPrimitive(c)}else if("object"==typeof a){if("object"==typeof c&&c.constructor!==h)return a==c;a=h.__toPrimitive(a)}else return a==c}}static NE(a,
c){return!h.EQ(a,c)}static __zero(){return new h(0,!1)}static __oneDigit(a,c){c=new h(1,c);return c.__setDigit(0,a),c}__copy(){const a=new h(this.length,this.sign);for(let c=0;c<this.length;c++)a[c]=this[c];return a}__trim(){let a=this.length,c=this[a-1];for(;0===c;)a--,c=this[a-1],this.pop();return 0===a&&(this.sign=!1),this}__initializeDigits(){for(let a=0;a<this.length;a++)this[a]=0}static __decideRounding(a,c,m,n){if(0<c)return-1;if(0>c)c=-c-1;else{if(0===m)return-1;m--;n=a.__digit(m);c=29}c=
1<<c;if(0==(n&c))return-1;if(--c,0!=(n&c))return 1;for(;0<m;)if(m--,0!==a.__digit(m))return 1;return 0}static __fromDouble(a){h.__kBitConversionDouble[0]=a;var c=(2047&h.__kBitConversionInts[1]>>>20)-1023,m=(0|c/30)+1;a=new h(m,0>a);let n=1048575&h.__kBitConversionInts[1]|1048576,d=h.__kBitConversionInts[0];c%=30;let l;if(20>c){var r=20-c;l=r+32;c=n>>>r;n=n<<32-r|d>>>r;d<<=32-r}else 20===c?(l=32,c=n,n=d):(r=c-20,l=32-r,c=n<<r|d>>>32-r,n=d<<r),d=0;a.__setDigit(m-1,c);for(m-=2;0<=m;m--)0<l?(l-=30,c=
n>>>2,n=n<<30|d>>>2,d<<=30):c=0,a.__setDigit(m,c);return a.__trim()}static __isWhitespace(a){return!!(13>=a&&9<=a)||(159>=a?32==a:131071>=a?160==a||5760==a:196607>=a?(a&=131071,10>=a||40==a||41==a||47==a||95==a||4096==a):65279==a)}static __fromString(a,c){c=void 0===c?0:c;let m=0;const n=a.length;let d=0;if(d===n)return h.__zero();let l=a.charCodeAt(d);for(;h.__isWhitespace(l);){if(++d===n)return h.__zero();l=a.charCodeAt(d)}if(43===l){if(++d===n)return null;l=a.charCodeAt(d);m=1}else if(45===l){if(++d===
n)return null;l=a.charCodeAt(d);m=-1}if(0===c){if(c=10,48===l){if(++d===n)return h.__zero();if(l=a.charCodeAt(d),88===l||120===l){if(c=16,++d===n)return null;l=a.charCodeAt(d)}else if(79===l||111===l){if(c=8,++d===n)return null;l=a.charCodeAt(d)}else if(66===l||98===l){if(c=2,++d===n)return null;l=a.charCodeAt(d)}}}else if(16===c&&48===l){if(++d===n)return h.__zero();if(l=a.charCodeAt(d),88===l||120===l){if(++d===n)return null;l=a.charCodeAt(d)}}if(0!=m&&10!==c)return null;for(;48===l;){if(++d===
n)return h.__zero();l=a.charCodeAt(d)}var r=n-d;let v=h.__kMaxBitsPerChar[c];var q=h.__kBitsPerCharTableMultiplier-1;if(r>1073741824/v)return null;r=new h(0|((v*r+q>>>h.__kBitsPerCharTableShift)+29)/30,!1);const t=10>c?c:10,w=10<c?c-10:0;if(0==(c&c-1)){v>>=h.__kBitsPerCharTableShift;c=[];var C=[],D=!1;do{for(var L=0,N=0;;){if(l-48>>>0<t)q=l-48;else if((32|l)-97>>>0<w)q=(32|l)-87;else{D=!0;break}if(N+=v,L=L<<v|q,++d===n){D=!0;break}if(l=a.charCodeAt(d),30<N+v)break}c.push(L);C.push(N)}while(!D);h.__fillFromParts(r,
c,C)}else{r.__initializeDigits();C=!1;D=0;do{L=0;for(N=1;;){if(l-48>>>0<t)q=l-48;else if((32|l)-97>>>0<w)q=(32|l)-87;else{C=!0;break}const A=N*c;if(1073741823<A)break;if(N=A,L=L*c+q,D++,++d===n){C=!0;break}l=a.charCodeAt(d)}q=30*h.__kBitsPerCharTableMultiplier-1;r.__inplaceMultiplyAdd(N,L,0|(v*D+q>>>h.__kBitsPerCharTableShift)/30)}while(!C)}if(d!==n){if(!h.__isWhitespace(l))return null;for(d++;d<n;d++)if(l=a.charCodeAt(d),!h.__isWhitespace(l))return null}return r.sign=-1==m,r.__trim()}static __fillFromParts(a,
c,m){let n=0,d=0,l=0;for(let r=c.length-1;0<=r;r--){const v=c[r],q=m[r];d|=v<<l;l+=q;30===l?(a.__setDigit(n++,d),l=0,d=0):30<l&&(a.__setDigit(n++,1073741823&d),l-=30,d=v>>>q-l)}if(0!==d){if(n>=a.length)throw Error("implementation bug");a.__setDigit(n++,d)}for(;n<a.length;n++)a.__setDigit(n,0)}static __toStringBasePowerOfTwo(a,c){const m=a.length;var n=c-1;n=(85&n>>>1)+(85&n);n=(51&n>>>2)+(51&n);n=(15&n>>>4)+(15&n);--c;const d=a.__digit(m-1);var l=h.__clz30(d),r=0|(30*m-l+n-1)/n;if(a.sign&&r++,268435456<
r)throw Error("string too long");l=Array(r);--r;var v=0,q=0;for(let t=0;t<m-1;t++){const w=a.__digit(t);v=(v|w<<q)&c;l[r--]=h.__kConversionChars[v];q=n-q;v=w>>>q;for(q=30-q;q>=n;)l[r--]=h.__kConversionChars[v&c],v>>>=n,q-=n}l[r--]=h.__kConversionChars[(v|d<<q)&c];for(v=d>>>n-q;0!==v;)l[r--]=h.__kConversionChars[v&c],v>>>=n;if(a.sign&&(l[r--]="-"),-1!=r)throw Error("implementation bug");return l.join("")}static __toStringGeneric(a,c,m){var n=a.length;if(0===n)return"";if(1===n)return c=a.__unsignedDigit(0).toString(c),
!1===m&&a.sign&&(c="-"+c),c;var d=30*n-h.__clz30(a.__digit(n-1));n=h.__kMaxBitsPerChar[c]-1;d*=h.__kBitsPerCharTableMultiplier;n=(0|(d+(n-1))/n)+1>>1;d=h.exponentiate(h.__oneDigit(c,!1),h.__oneDigit(n,!1));var l=d.__unsignedDigit(0);if(1===d.length&&32767>=l){d=new h(a.length,!1);d.__initializeDigits();var r=0;for(let v=2*a.length-1;0<=v;v--)r=r<<15|a.__halfDigit(v),d.__setHalfDigit(v,0|r/l),r=0|r%l;l=r.toString(c)}else l=h.__absoluteDivLarge(a,d,!0,!0),d=l.quotient,l=l.remainder.__trim(),l=h.__toStringGeneric(l,
c,!0);d.__trim();for(c=h.__toStringGeneric(d,c,!0);l.length<n;)l="0"+l;return!1===m&&a.sign&&(c="-"+c),c+l}static __unequalSign(a){return a?-1:1}static __absoluteGreater(a){return a?-1:1}static __absoluteLess(a){return a?1:-1}static __compareToBigInt(a,c){const m=a.sign;if(m!==c.sign)return h.__unequalSign(m);a=h.__absoluteCompare(a,c);return 0<a?h.__absoluteGreater(m):0>a?h.__absoluteLess(m):0}static __compareToNumber(a,c){if(h.__isOneDigitInt(c)){const m=a.sign,n=0>c;if(m!==n)return h.__unequalSign(m);
if(0===a.length){if(n)throw Error("implementation bug");return 0===c?0:-1}if(1<a.length)return h.__absoluteGreater(m);c=g(c);a=a.__unsignedDigit(0);return a>c?h.__absoluteGreater(m):a<c?h.__absoluteLess(m):0}return h.__compareToDouble(a,c)}static __compareToDouble(a,c){if(c!==c)return c;if(c===1/0)return-1;if(-Infinity===c)return 1;const m=a.sign;if(m!==0>c)return h.__unequalSign(m);if(0===c)throw Error("implementation bug: should be handled elsewhere");if(0===a.length)return-1;h.__kBitConversionDouble[0]=
c;c=2047&h.__kBitConversionInts[1]>>>20;if(2047==c)throw Error("implementation bug: handled elsewhere");var n=c-1023;if(0>n)return h.__absoluteGreater(m);c=a.length;var d=a.__digit(c-1),l=h.__clz30(d),r=30*c-l;n+=1;if(r<n)return h.__absoluteLess(m);if(r>n)return h.__absoluteGreater(m);n=1048576|1048575&h.__kBitConversionInts[1];let v=h.__kBitConversionInts[0];l=29-l;if(l!==(0|(r-1)%30))throw Error("implementation bug");if(20>l){var q=20-l;l=q+32;r=n>>>q;n=n<<32-q|v>>>q;v<<=32-q}else 20===l?(l=32,
r=n,n=v):(q=l-20,l=32-q,r=n<<q|v>>>32-q,n=v<<q),v=0;if(d>>>=0,r>>>=0,d>r)return h.__absoluteGreater(m);if(d<r)return h.__absoluteLess(m);for(c-=2;0<=c;c--){0<l?(l-=30,r=n>>>2,n=n<<30|v>>>2,v<<=30):r=0;d=a.__unsignedDigit(c);if(d>r)return h.__absoluteGreater(m);if(d<r)return h.__absoluteLess(m)}if(0!==n||0!==v){if(0===l)throw Error("implementation bug");return h.__absoluteLess(m)}return 0}static __equalToNumber(a,c){return h.__isOneDigitInt(c)?0===c?0===a.length:1===a.length&&a.sign===0>c&&a.__unsignedDigit(0)===
g(c):0===h.__compareToDouble(a,c)}static __comparisonResultToBool(a,c){return 0===c?0>a:1===c?0>=a:2===c?0<a:3===c?0<=a:void 0}static __compare(a,c,m){if(a=h.__toPrimitive(a),c=h.__toPrimitive(c),"string"==typeof a&&"string"==typeof c)switch(m){case 0:return a<c;case 1:return a<=c;case 2:return a>c;case 3:return a>=c}if(h.__isBigInt(a)&&"string"==typeof c)return c=h.__fromString(c),null!==c&&h.__comparisonResultToBool(h.__compareToBigInt(a,c),m);if("string"==typeof a&&h.__isBigInt(c))return a=h.__fromString(a),
null!==a&&h.__comparisonResultToBool(h.__compareToBigInt(a,c),m);if(a=h.__toNumeric(a),c=h.__toNumeric(c),h.__isBigInt(a)){if(h.__isBigInt(c))return h.__comparisonResultToBool(h.__compareToBigInt(a,c),m);if("number"!=typeof c)throw Error("implementation bug");return h.__comparisonResultToBool(h.__compareToNumber(a,c),m)}if("number"!=typeof a)throw Error("implementation bug");if(h.__isBigInt(c))return h.__comparisonResultToBool(h.__compareToNumber(c,a),2^m);if("number"!=typeof c)throw Error("implementation bug");
return 0===m?a<c:1===m?a<=c:2===m?a>c:3===m?a>=c:void 0}__clzmsd(){return h.__clz30(this.__digit(this.length-1))}static __absoluteAdd(a,c,m){if(a.length<c.length)return h.__absoluteAdd(c,a,m);if(0===a.length)return a;if(0===c.length)return a.sign===m?a:h.unaryMinus(a);var n=a.length;(0===a.__clzmsd()||c.length===a.length&&0===c.__clzmsd())&&n++;m=new h(n,m);let d=n=0;for(;d<c.length;d++){const l=a.__digit(d)+c.__digit(d)+n;n=l>>>30;m.__setDigit(d,1073741823&l)}for(;d<a.length;d++)c=a.__digit(d)+n,
n=c>>>30,m.__setDigit(d,1073741823&c);return d<m.length&&m.__setDigit(d,n),m.__trim()}static __absoluteSub(a,c,m){if(0===a.length)return a;if(0===c.length)return a.sign===m?a:h.unaryMinus(a);m=new h(a.length,m);let n=0,d=0;for(;d<c.length;d++){const l=a.__digit(d)-c.__digit(d)-n;n=1&l>>>30;m.__setDigit(d,1073741823&l)}for(;d<a.length;d++)c=a.__digit(d)-n,n=1&c>>>30,m.__setDigit(d,1073741823&c);return m.__trim()}static __absoluteAddOne(a,c,m){m=void 0===m?null:m;const n=a.length;null===m?m=new h(n,
c):m.sign=c;c=1;for(let d=0;d<n;d++){const l=a.__digit(d)+c;c=l>>>30;m.__setDigit(d,1073741823&l)}return 0!=c&&m.__setDigitGrow(n,1),m}static __absoluteSubOne(a,c){const m=a.length;c=c||m;const n=new h(c,!1);let d=1;for(let l=0;l<m;l++){const r=a.__digit(l)-d;d=1&r>>>30;n.__setDigit(l,1073741823&r)}if(0!=d)throw Error("implementation bug");for(a=m;a<c;a++)n.__setDigit(a,0);return n}static __absoluteAnd(a,c,m){m=void 0===m?null:m;var n=a.length,d=c.length;let l=d;n<d&&(l=n,n=a,a=c,c=n);n=l;null===
m?m=new h(n,!1):n=m.length;for(d=0;d<l;d++)m.__setDigit(d,a.__digit(d)&c.__digit(d));for(;d<n;d++)m.__setDigit(d,0);return m}static __absoluteAndNot(a,c,m){m=void 0===m?null:m;const n=a.length;var d=c.length;let l=d;n<d&&(l=n);d=n;null===m?m=new h(d,!1):d=m.length;let r=0;for(;r<l;r++)m.__setDigit(r,a.__digit(r)&~c.__digit(r));for(;r<n;r++)m.__setDigit(r,a.__digit(r));for(;r<d;r++)m.__setDigit(r,0);return m}static __absoluteOr(a,c,m){m=void 0===m?null:m;let n=a.length;var d=c.length;let l=d;if(n<
d){l=n;var r=a;a=c;n=d;c=r}d=n;null===m?m=new h(d,!1):d=m.length;for(r=0;r<l;r++)m.__setDigit(r,a.__digit(r)|c.__digit(r));for(;r<n;r++)m.__setDigit(r,a.__digit(r));for(;r<d;r++)m.__setDigit(r,0);return m}static __absoluteXor(a,c,m){m=void 0===m?null:m;let n=a.length;var d=c.length;let l=d;if(n<d){l=n;var r=a;a=c;n=d;c=r}d=n;null===m?m=new h(d,!1):d=m.length;for(r=0;r<l;r++)m.__setDigit(r,a.__digit(r)^c.__digit(r));for(;r<n;r++)m.__setDigit(r,a.__digit(r));for(;r<d;r++)m.__setDigit(r,0);return m}static __absoluteCompare(a,
c){var m=a.length-c.length;if(0!=m)return m;for(m=a.length-1;0<=m&&a.__digit(m)===c.__digit(m);)m--;return 0>m?0:a.__unsignedDigit(m)>c.__unsignedDigit(m)?1:-1}static __multiplyAccumulate(a,c,m,n){if(0!==c){var d=32767&c,l=c>>>15,r=c=0;for(let w,C=0;C<a.length;C++,n++){w=m.__digit(n);var v=a.__digit(C),q=32767&v,t=v>>>15;v=h.__imul(q,d);q=h.__imul(q,l);const D=h.__imul(t,d);t=h.__imul(t,l);w+=r+v+c;c=w>>>30;w&=1073741823;w+=((32767&q)<<15)+((32767&D)<<15);c+=w>>>30;r=t+(q>>>15)+(D>>>15);m.__setDigit(n,
1073741823&w)}for(;0!=c||0!==r;n++)a=m.__digit(n),a+=c+r,r=0,c=a>>>30,m.__setDigit(n,1073741823&a)}}static __internalMultiplyAdd(a,c,m,n,d){let l=0;for(let q=0;q<n;q++){var r=a.__digit(q),v=h.__imul(32767&r,c);r=h.__imul(r>>>15,c);v=v+((32767&r)<<15)+l+m;m=v>>>30;l=r>>>15;d.__setDigit(q,1073741823&v)}if(d.length>n)for(d.__setDigit(n++,m+l);n<d.length;)d.__setDigit(n++,0);else if(0!==m+l)throw Error("implementation bug");}__inplaceMultiplyAdd(a,c,m){m>this.length&&(m=this.length);const n=32767&a;a>>>=
15;let d=0;for(let q=0;q<m;q++){var l=this.__digit(q),r=32767&l,v=l>>>15;l=h.__imul(r,n);r=h.__imul(r,a);const t=h.__imul(v,n);v=h.__imul(v,a);l=c+l+d;d=l>>>30;l&=1073741823;l+=((32767&r)<<15)+((32767&t)<<15);d+=l>>>30;c=v+(r>>>15)+(t>>>15);this.__setDigit(q,1073741823&l)}if(0!=d||0!==c)throw Error("implementation bug");}static __absoluteDivSmall(a,c,m){m=void 0===m?null:m;null===m&&(m=new h(a.length,!1));let n=0;for(let d,l=2*a.length-1;0<=l;l-=2){d=(n<<15|a.__halfDigit(l))>>>0;const r=0|d/c;n=0|
d%c;d=(n<<15|a.__halfDigit(l-1))>>>0;const v=0|d/c;n=0|d%c;m.__setDigit(l>>>1,r<<15|v)}return m}static __absoluteModSmall(a,c){let m=0;for(let n=2*a.length-1;0<=n;n--)m=0|((m<<15|a.__halfDigit(n))>>>0)%c;return m}static __absoluteDivLarge(a,c,m,n){const d=c.__halfDigitLength(),l=c.length;var r=a.__halfDigitLength()-d;let v=null;m&&(v=new h(r+2>>>1,!1),v.__initializeDigits());const q=new h(d+2>>>1,!1);q.__initializeDigits();const t=h.__clz15(c.__halfDigit(d-1));0<t&&(c=h.__specialLeftShift(c,t,0));
a=h.__specialLeftShift(a,t,1);const w=c.__halfDigit(d-1);let C=0;for(let D,L=r;0<=L;L--){D=32767;r=a.__halfDigit(L+d);if(r!==w){r=(r<<15|a.__halfDigit(L+d-1))>>>0;D=0|r/w;r=0|r%w;const N=c.__halfDigit(d-2),A=a.__halfDigit(L+d-2);for(;h.__imul(D,N)>>>0>(r<<16|A)>>>0&&(D--,r+=w,!(32767<r)););}h.__internalMultiplyAdd(c,D,0,l,q);r=a.__inplaceSub(q,L,d+1);0!==r&&(r=a.__inplaceAdd(c,L,d),a.__setHalfDigit(L+d,32767&a.__halfDigit(L+d)+r),D--);m&&(1&L?C=D<<15:v.__setDigit(L>>>1,C|D))}if(n)return a.__inplaceRightShift(t),
m?{quotient:v,remainder:a}:a;if(m)return v;throw Error("unreachable");}static __clz15(a){return h.__clz30(a)-15}__inplaceAdd(a,c,m){let n=0;for(let d=0;d<m;d++){const l=this.__halfDigit(c+d)+a.__halfDigit(d)+n;n=l>>>15;this.__setHalfDigit(c+d,32767&l)}return n}__inplaceSub(a,c,m){let n=0;if(1&c){c>>=1;for(var d=this.__digit(c),l=32767&d,r=0;r<m-1>>>1;r++){var v=a.__digit(r);d=(d>>>15)-(32767&v)-n;n=1&d>>>15;this.__setDigit(c+r,(32767&d)<<15|32767&l);d=this.__digit(c+r+1);l=(32767&d)-(v>>>15)-n;n=
1&l>>>15}v=a.__digit(r);const q=(d>>>15)-(32767&v)-n;n=1&q>>>15;this.__setDigit(c+r,(32767&q)<<15|32767&l);if(c+r+1>=this.length)throw new RangeError("out of bounds");0==(1&m)&&(d=this.__digit(c+r+1),l=(32767&d)-(v>>>15)-n,n=1&l>>>15,this.__setDigit(c+a.length,1073709056&d|32767&l))}else{c>>=1;for(l=0;l<a.length-1;l++)d=this.__digit(c+l),v=a.__digit(l),r=(32767&d)-(32767&v)-n,n=1&r>>>15,d=(d>>>15)-(v>>>15)-n,n=1&d>>>15,this.__setDigit(c+l,(32767&d)<<15|32767&r);r=this.__digit(c+l);a=a.__digit(l);
d=(32767&r)-(32767&a)-n;n=1&d>>>15;v=0;0==(1&m)&&(v=(r>>>15)-(a>>>15)-n,n=1&v>>>15);this.__setDigit(c+l,(32767&v)<<15|32767&d)}return n}__inplaceRightShift(a){if(0!==a){var c=this.__digit(0)>>>a,m=this.length-1;for(let n=0;n<m;n++){const d=this.__digit(n+1);this.__setDigit(n,1073741823&d<<30-a|c);c=d>>>a}this.__setDigit(m,c)}}static __specialLeftShift(a,c,m){const n=a.length,d=new h(n+m,!1);if(0===c){for(c=0;c<n;c++)d.__setDigit(c,a.__digit(c));return 0<m&&d.__setDigit(n,0),d}let l=0;for(let r=0;r<
n;r++){const v=a.__digit(r);d.__setDigit(r,1073741823&v<<c|l);l=v>>>30-c}return 0<m&&d.__setDigit(n,l),d}static __leftShiftByAbsolute(a,c){var m=h.__toShiftAmount(c);if(0>m)throw new RangeError("BigInt too big");c=0|m/30;var n=m%30;const d=a.length,l=0!==n&&0!=a.__digit(d-1)>>>30-n;var r=d+c+(l?1:0);m=new h(r,a.sign);if(0===n){for(n=0;n<c;n++)m.__setDigit(n,0);for(;n<r;n++)m.__setDigit(n,a.__digit(n-c))}else{r=0;for(var v=0;v<c;v++)m.__setDigit(v,0);for(v=0;v<d;v++){const q=a.__digit(v);m.__setDigit(v+
c,1073741823&q<<n|r);r=q>>>30-n}if(l)m.__setDigit(d+c,r);else if(0!==r)throw Error("implementation bug");}return m.__trim()}static __rightShiftByAbsolute(a,c){var m=a.length,n=a.sign,d=h.__toShiftAmount(c);if(0>d)return h.__rightShiftByMaximum(n);c=0|d/30;var l=d%30,r=m-c;if(0>=r)return h.__rightShiftByMaximum(n);d=!1;if(n)if(0!=(a.__digit(c)&(1<<l)-1))d=!0;else for(var v=0;v<c;v++)if(0!==a.__digit(v)){d=!0;break}d&&0===l&&0==~a.__digit(m-1)&&r++;n=new h(r,n);if(0===l)for(n.__setDigit(r-1,0),l=c;l<
m;l++)n.__setDigit(l-c,a.__digit(l));else{r=a.__digit(c)>>>l;m=m-c-1;for(v=0;v<m;v++){const q=a.__digit(v+c+1);n.__setDigit(v,1073741823&q<<30-l|r);r=q>>>l}n.__setDigit(m,r)}return d&&(n=h.__absoluteAddOne(n,!0,n)),n.__trim()}static __rightShiftByMaximum(a){return a?h.__oneDigit(1,!0):h.__zero()}static __toShiftAmount(a){if(1<a.length)return-1;a=a.__unsignedDigit(0);return a>h.__kMaxLengthBits?-1:a}static __toPrimitive(a,c){c=void 0===c?"default":c;if("object"!=typeof a||a.constructor===h)return a;
const m=a[Symbol.toPrimitive];if(m){a=m(c);if("object"!=typeof a)return a;throw new TypeError("Cannot convert object to primitive value");}if(c=a.valueOf)if(c=c.call(a),"object"!=typeof c)return c;if(c=a.toString)if(a=c.call(a),"object"!=typeof a)return a;throw new TypeError("Cannot convert object to primitive value");}static __toNumeric(a){return h.__isBigInt(a)?a:+a}static __isBigInt(a){return"object"==typeof a&&null!==a&&a.constructor===h}static __truncateToNBits(a,c){var m=0|(a+29)/30;const n=
new h(m,c.sign);--m;for(let d=0;d<m;d++)n.__setDigit(d,c.__digit(d));c=c.__digit(m);0!=a%30&&(a=32-a%30,c=c<<a>>>a);return n.__setDigit(m,c),n.__trim()}static __truncateAndSubFromPowerOfTwo(a,c,m){var n=Math.min,d=0|(a+29)/30;m=new h(d,m);let l=0;--d;var r=0;for(n=n(d,c.length);l<n;l++){const v=0-c.__digit(l)-r;r=1&v>>>30;m.__setDigit(l,1073741823&v)}for(;l<d;l++)m.__setDigit(l,0|1073741823&-r);c=d<c.length?c.__digit(d):0;a%=30;0==a?r=0-c-r&1073741823:(a=32-a,c=c<<a>>>a,a=1<<32-a,r=a-c-r,r&=a-1);
return m.__setDigit(d,r),m.__trim()}__digit(a){return this[a]}__unsignedDigit(a){return this[a]>>>0}__setDigit(a,c){this[a]=0|c}__setDigitGrow(a,c){this[a]=0|c}__halfDigitLength(){const a=this.length;return 32767>=this.__unsignedDigit(a-1)?2*a-1:2*a}__halfDigit(a){return 32767&this[a>>>1]>>>15*(1&a)}__setHalfDigit(a,c){const m=a>>>1,n=this.__digit(m);this.__setDigit(m,1&a?32767&n|c<<15:1073709056&n|32767&c)}static __digitPow(a,c){let m=1;for(;0<c;)1&c&&(m*=a),c>>>=1,a*=a;return m}static __isOneDigitInt(a){return(1073741823&
a)===a}}return h.__kMaxLength=33554432,h.__kMaxLengthBits=h.__kMaxLength<<5,h.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],h.__kBitsPerCharTableShift=5,h.__kBitsPerCharTableMultiplier=1<<h.__kBitsPerCharTableShift,h.__kConversionChars="0123456789abcdefghijklmnopqrstuvwxyz".split(""),h.__kBitConversionBuffer=new ArrayBuffer(8),h.__kBitConversionDouble=new Float64Array(h.__kBitConversionBuffer),
h.__kBitConversionInts=new Int32Array(h.__kBitConversionBuffer),h.__clz30=e?function(a){return e(a)-2}:function(a){var c=Math.LN2,m=Math.log;return 0===a?30:0|29-(0|m(a>>>0)/c)},h.__imul=f||function(a,c){return 0|a*c},h})},function(E,Q){[..."abc"].flat()},function(E,Q,b){(function(f,e){(function(g,k){function p(D){delete v[D]}function h(D){if(q)setTimeout(h,0,D);else{var L=v[D];if(L){q=!0;try{var N=L.callback,A=L.args;switch(A.length){case 0:N();break;case 1:N(A[0]);break;case 2:N(A[0],A[1]);break;
case 3:N(A[0],A[1],A[2]);break;default:N.apply(k,A)}}finally{p(D),q=!1}}}}function a(){w=function(D){e.nextTick(function(){h(D)})}}function c(){if(g.postMessage&&!g.importScripts){var D=!0,L=g.onmessage;g.onmessage=function(){D=!1};g.postMessage("","*");g.onmessage=L;return D}}function m(){var D="setImmediate$"+Math.random()+"$",L=function(N){N.source===g&&"string"===typeof N.data&&0===N.data.indexOf(D)&&h(+N.data.slice(D.length))};g.addEventListener?g.addEventListener("message",L,!1):g.attachEvent("onmessage",
L);w=function(N){g.postMessage(D+N,"*")}}function n(){var D=new MessageChannel;D.port1.onmessage=function(L){h(L.data)};w=function(L){D.port2.postMessage(L)}}function d(){var D=t.documentElement;w=function(L){var N=t.createElement("script");N.onreadystatechange=function(){h(L);N.onreadystatechange=null;D.removeChild(N);N=null};D.appendChild(N)}}function l(){w=function(D){setTimeout(h,0,D)}}if(!g.setImmediate){var r=1,v={},q=!1,t=g.document,w,C=Object.getPrototypeOf&&Object.getPrototypeOf(g);C=C&&
C.setTimeout?C:g;"[object process]"==={}.toString.call(g.process)?a():c()?m():g.MessageChannel?n():t&&"onreadystatechange"in t.createElement("script")?d():l();C.setImmediate=function(D){"function"!==typeof D&&(D=new Function(""+D));for(var L=Array(arguments.length-1),N=0;N<L.length;N++)L[N]=arguments[N+1];v[r]={callback:D,args:L};w(r);return r++};C.clearImmediate=p}})("undefined"===typeof self?"undefined"===typeof f?this:f:self)}).call(this,b(0),b(8))},function(E,Q){function b(){throw Error("setTimeout has not been defined");
}function f(){throw Error("clearTimeout has not been defined");}function e(v){if(c===setTimeout)return setTimeout(v,0);if((c===b||!c)&&setTimeout)return c=setTimeout,setTimeout(v,0);try{return c(v,0)}catch(q){try{return c.call(null,v,0)}catch(t){return c.call(this,v,0)}}}function g(v){if(m===clearTimeout)return clearTimeout(v);if((m===f||!m)&&clearTimeout)return m=clearTimeout,clearTimeout(v);try{return m(v)}catch(q){try{return m.call(null,v)}catch(t){return m.call(this,v)}}}function k(){d&&l&&(d=
!1,l.length?n=l.concat(n):r=-1,n.length&&p())}function p(){if(!d){var v=e(k);d=!0;for(var q=n.length;q;){l=n;for(n=[];++r<q;)l&&l[r].run();r=-1;q=n.length}l=null;d=!1;g(v)}}function h(v,q){this.fun=v;this.array=q}function a(){}E=E.exports={};try{var c="function"===typeof setTimeout?setTimeout:b}catch(v){c=b}try{var m="function"===typeof clearTimeout?clearTimeout:f}catch(v){m=f}var n=[],d=!1,l,r=-1;E.nextTick=function(v){var q=Array(arguments.length-1);if(1<arguments.length)for(var t=1;t<arguments.length;t++)q[t-
1]=arguments[t];n.push(new h(v,q));1!==n.length||d||e(p)};h.prototype.run=function(){this.fun.apply(null,this.array)};E.title="browser";E.browser=!0;E.env={};E.argv=[];E.version="";E.versions={};E.on=a;E.addListener=a;E.once=a;E.off=a;E.removeListener=a;E.removeAllListeners=a;E.emit=a;E.prependListener=a;E.prependOnceListener=a;E.listeners=function(v){return[]};E.binding=function(v){throw Error("process.binding is not supported");};E.cwd=function(){return"/"};E.chdir=function(v){throw Error("process.chdir is not supported");
};E.umask=function(){return 0}},function(E,Q){Sk.asserts={};Sk.asserts.assert=function(b,f){return b};Sk.exportSymbol("Sk.asserts.assert",Sk.asserts.assert);Sk.asserts.fail=function(b){};Sk.exportSymbol("Sk.asserts.fail",Sk.asserts.fail)},function(E,Q){Sk.bool_check=function(b,f){if(void 0===b||null===b||"boolean"!==typeof b)throw Error("must specify "+f+" and it must be a boolean");};Sk.python2={print_function:!1,division:!1,absolute_import:null,unicode_literals:!1,python3:!1,class_repr:!1,inherit_from_object:!1,
super_args:!1,octal_number_literal:!1,bankers_rounding:!1,python_version:!1,dunder_round:!1,exceptions:!1,no_long_type:!1,ceil_floor_int:!1,silent_octal_literal:!0};Sk.python3={print_function:!0,division:!0,absolute_import:null,unicode_literals:!0,python3:!0,class_repr:!0,inherit_from_object:!0,super_args:!0,octal_number_literal:!0,bankers_rounding:!0,python_version:!0,dunder_round:!0,exceptions:!0,no_long_type:!0,ceil_floor_int:!0,silent_octal_literal:!1};Sk.configure=function(b){Sk.output=b.output||
Sk.output;Sk.asserts.assert("function"===typeof Sk.output);Sk.filewriter=b.filewriter||Sk.filewriter;Sk.asserts.assert("function"===typeof Sk.filewriter);Sk.debugout=b.debugout||Sk.debugout;Sk.asserts.assert("function"===typeof Sk.debugout);Sk.uncaughtException=b.uncaughtException||Sk.uncaughtException;Sk.asserts.assert("function"===typeof Sk.uncaughtException);Sk.read=b.read||Sk.read;Sk.asserts.assert("function"===typeof Sk.read);Sk.nonreadopen=b.nonreadopen||!1;Sk.asserts.assert("boolean"===typeof Sk.nonreadopen);
Sk.fileopen=b.fileopen||void 0;Sk.asserts.assert("function"===typeof Sk.fileopen||"undefined"===typeof Sk.fileopen);Sk.filewrite=b.filewrite||void 0;Sk.asserts.assert("function"===typeof Sk.filewrite||"undefined"===typeof Sk.filewrite);Sk.timeoutMsg=b.timeoutMsg||Sk.timeoutMsg;Sk.asserts.assert("function"===typeof Sk.timeoutMsg);Sk.exportSymbol("Sk.timeoutMsg",Sk.timeoutMsg);Sk.sysargv=b.sysargv||Sk.sysargv;Sk.asserts.assert(Sk.isArrayLike(Sk.sysargv));Sk.__future__=b.__future__||Sk.python3;Sk.bool_check(Sk.__future__.print_function,
"Sk.__future__.print_function");Sk.bool_check(Sk.__future__.division,"Sk.__future__.division");Sk.bool_check(Sk.__future__.unicode_literals,"Sk.__future__.unicode_literals");Sk.bool_check(Sk.__future__.class_repr,"Sk.__future__.class_repr");Sk.bool_check(Sk.__future__.inherit_from_object,"Sk.__future__.inherit_from_object");Sk.bool_check(Sk.__future__.super_args,"Sk.__future__.super_args");Sk.bool_check(Sk.__future__.octal_number_literal,"Sk.__future__.octal_number_literal");Sk.bool_check(Sk.__future__.bankers_rounding,
"Sk.__future__.bankers_rounding");Sk.bool_check(Sk.__future__.python_version,"Sk.__future__.python_version");Sk.bool_check(Sk.__future__.dunder_round,"Sk.__future__.dunder_round");Sk.bool_check(Sk.__future__.exceptions,"Sk.__future__.exceptions");Sk.bool_check(Sk.__future__.no_long_type,"Sk.__future__.no_long_type");Sk.bool_check(Sk.__future__.ceil_floor_int,"Sk.__future__.ceil_floor_int");Sk.bool_check(Sk.__future__.silent_octal_literal,"Sk.__future__.silent_octal_literal");Sk.imageProxy=b.imageProxy||
"http://localhost:8080/320x";Sk.asserts.assert("string"===typeof Sk.imageProxy||"function"===typeof Sk.imageProxy);Sk.inputfun=b.inputfun||Sk.inputfun;Sk.asserts.assert("function"===typeof Sk.inputfun);Sk.inputfunTakesPrompt=b.inputfunTakesPrompt||!1;Sk.asserts.assert("boolean"===typeof Sk.inputfunTakesPrompt);Sk.retainGlobals=b.retainglobals||b.retainGlobals||!1;Sk.asserts.assert("boolean"===typeof Sk.retainGlobals);Sk.debugging=b.debugging||!1;Sk.asserts.assert("boolean"===typeof Sk.debugging);
Sk.killableWhile=b.killableWhile||!1;Sk.asserts.assert("boolean"===typeof Sk.killableWhile);Sk.killableFor=b.killableFor||!1;Sk.asserts.assert("boolean"===typeof Sk.killableFor);Sk.signals=b.signals;Sk.signals=!0===Sk.signals?{listeners:[],addEventListener(f){Sk.signals.listeners.push(f)},removeEventListener(f){f=Sk.signals.listeners.indexOf(f);0<=f&&Sk.signals.listeners.splice(f,1)},signal(f,e){for(var g=0;g<Sk.signals.listeners.length;g++)Sk.signals.listeners[g].call(null,f,e)}}:null;Sk.asserts.assert("object"===
typeof Sk.signals);Sk.breakpoints=b.breakpoints||function(){return!0};Sk.asserts.assert("function"===typeof Sk.breakpoints);Sk.setTimeout=b.setTimeout;void 0===Sk.setTimeout&&(Sk.setTimeout="function"===typeof setTimeout?function(f,e){setTimeout(f,e)}:function(f,e){f()});Sk.asserts.assert("function"===typeof Sk.setTimeout);"execLimit"in b&&(Sk.execLimit=b.execLimit);"yieldLimit"in b&&(Sk.yieldLimit=b.yieldLimit);b.syspath&&(Sk.syspath=b.syspath,Sk.asserts.assert(Sk.isArrayLike(Sk.syspath)),Sk.realsyspath=
void 0,Sk.sysmodules=new Sk.builtin.dict([]));Sk.misceval.softspace_=!1;Sk.switch_version(Sk.__future__.python3);Sk.builtin.str.$next=Sk.__future__.python3?new Sk.builtin.str("__next__"):new Sk.builtin.str("next");Sk.setupOperators(Sk.__future__.python3);Sk.setupDunderMethods(Sk.__future__.python3);Sk.setupObjects(Sk.__future__.python3);Sk.token.setupTokens(Sk.__future__.python3)};Sk.exportSymbol("Sk.configure",Sk.configure);Sk.uncaughtException=function(b){throw b;};Sk.uncaughtException=function(b){throw b;
};Sk.exportSymbol("Sk.uncaughtException",Sk.uncaughtException);Sk.timeoutMsg=function(){return"Program exceeded run time limit."};Sk.exportSymbol("Sk.timeoutMsg",Sk.timeoutMsg);Sk.execLimit=Number.POSITIVE_INFINITY;Sk.yieldLimit=Number.POSITIVE_INFINITY;Sk.output=function(b){};Sk.read=function(b){if(void 0===Sk.builtinFiles)throw"skulpt-stdlib.js has not been loaded";if(void 0===Sk.builtinFiles.files[b])throw"File not found: '"+b+"'";return Sk.builtinFiles.files[b]};Sk.sysargv=[];Sk.getSysArgv=function(){return Sk.sysargv};
Sk.exportSymbol("Sk.getSysArgv",Sk.getSysArgv);Sk.syspath=[];Sk.inBrowser=void 0!==Sk.global.document;Sk.debugout=function(b){};(function(){void 0!==Sk.global.write?(Sk.output=Sk.global.write,Sk.filewriter=Sk.global.write):void 0!==Sk.global.console&&void 0!==Sk.global.console.log?(Sk.output=function(b){Sk.global.console.log(b)},Sk.filewriter=Sk.output):void 0!==Sk.global.print&&(Sk.output=Sk.global.print,Sk.filewriter=Sk.output);void 0!==Sk.global.console&&void 0!==Sk.global.console.log?Sk.debugout=
function(b){Sk.global.console.log(b)}:void 0!==Sk.global.print&&(Sk.debugout=Sk.global.print)})();Sk.inputfun=function(b){return window.prompt(b)};Sk.setup_method_mappings=function(){};Sk.setupDictIterators=function(b){};Sk.switch_version=function(b){const f={float_:{method_names:["__round__"],2:[!1],3:[!0]},int_:{method_names:["__round__"],2:[!1],3:[!0]},list:{method_names:["clear","copy","sort"],2:[!1,!1,!0],3:[!0,!0,!0]},dict:{method_names:["has_key","keys","items","values"],2:[!0,!0,!0,!0],3:[!1,
!0,!0,!0]}};for(let p in f){const h=Sk.builtin[p],a=f[p].method_names;var e=f[p][3];if(b&&void 0===h.py3$methods)break;else if(void 0===h.py3$methods){h.py3$methods={};for(var g=0;g<a.length;g++){var k=a[g];e[g]&&(h.py3$methods[k]=h.prototype[k].d$def)}}b?g=h.py3$methods:(e=f[p][2],g=h.py2$methods);for(k=0;k<a.length;k++){const c=a[k];delete h.prototype[c];e[k]&&(h.prototype[c]=new Sk.builtin.method_descriptor(h,g[c]))}}};Sk.exportSymbol("Sk.__future__",Sk.__future__);Sk.exportSymbol("Sk.inputfun",
Sk.inputfun)},function(E,Q){function b(d,l,r){if(d.hasOwnProperty(l)){const v=d[l];v instanceof Sk.builtin.func&&(d[l]=new Sk.builtin[r](v))}}function f(d){return this.prototype[d.$mangled]}function e(d){d=d.$mangled;const l=this.prototype.tp$mro;for(let r=0;r<l.length;++r){const v=l[r].prototype;if(v.hasOwnProperty(d))return v[d]}}function g(d,l,r,v){const q=k(r),t=l.prototype;Sk.abstr.setUpInheritance(d,l,q,v);d=new Sk.builtin.str(d);Object.defineProperties(t,{sk$prototypical:{value:!0,writable:!0},
tp$bases:{value:r,writable:!0},tp$mro:{value:null,writable:!0},ht$type:{value:!0,writable:!0},ht$name:{value:d,writable:!0},ht$qualname:{value:d,writable:!0}});t.tp$mro=l.$buildMRO();Object.defineProperties(l,{$typeLookup:{value:t.sk$prototypical?f:e,writable:!0},sk$klass:{value:!0,writable:!0}})}function k(d){function l(w){return w.sk$solidBase||w.sk$solidSlotBase?w:l(w.prototype.tp$base)}0===d.length&&d.push(Sk.builtin.object);let r,v,q,t;for(let w=0;w<d.length;w++){t=d[w];if(!Sk.builtin.checkClass(t))throw new Sk.builtin.TypeError("bases must be 'type' objects");
if(t.sk$unacceptableBase)throw new Sk.builtin.TypeError("type '"+t.prototype.tp$name+"' is not an acceptable base type");q=l(t);if(void 0===v)v=q,r=t;else if(!v.$isSubType(q))if(q.$isSubType(v))v=q,r=t;else throw new Sk.builtin.TypeError("multiple bases have instance layout conflicts");}return r}function p(d,l){const r=l.prototype,v=r.sk$nslots||0;Object.defineProperty(r,"sk$nslots",{value:v+d.length,writable:!0});d.length&&Object.defineProperty(l,"sk$solidSlotBase",{value:!0,writable:!0});d.forEach((q,
t)=>{t+=v;r[q.$mangled]=new Sk.builtin.getset_descriptor(l,{$get(){const w=this.$s[t];if(void 0===w)throw new Sk.builtin.AttributeError(q);return w},$set(w){this.$s[t]=w}})})}function h(d){for(;null!==d.prototype.tp$base;){if(void 0===d.sk$klass&&d.prototype.hasOwnProperty("__dict__"))return d=d.prototype.__dict__,Sk.builtin.checkDataDescr(d)?d:void 0;d=d.prototype.tp$base}}function a(d,l,r){if(void 0===d.sk$klass)throw new Sk.builtin.TypeError("can't set "+d.prototype.tp$name+"."+r.$jsstr());if(void 0===
l)throw new Sk.builtin.TypeError("can't delete "+d.prototype.tp$name+"."+r.$jsstr());}function c(d,l){d=(new Sk.builtin.super_(d,d)).tp$getattr(Sk.builtin.str.$initsubclass);Sk.misceval.callsimArray(d,[],l)}function m(d){const l=d.prototype;Object.keys(l).forEach(r=>{const v=Sk.abstr.lookupSpecial(l[r],Sk.builtin.str.$setname);if(void 0!==v)try{Sk.misceval.callsimArray(v,[d,new Sk.builtin.str(r)])}catch(q){throw r=new Sk.builtin.RuntimeError("Error calling __set_name__ on '"+Sk.abstr.typeName(l[r])+
"' instance '"+r+"' in '"+d.prototype.tp$name+"'"),r.$cause=q,r;}})}void 0===Sk.builtin&&(Sk.builtin={});Sk.builtin.type=function(d){this instanceof Sk.builtin.type&&Sk.asserts.fail("calling new Sk.builtin.type is not safe");return d.ob$type};Object.defineProperties(Sk.builtin.type.prototype,{call:{value:Function.prototype.call},apply:{value:Function.prototype.apply},tp$slots:{value:{tp$doc:"type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type",
tp$call:function(d,l){if(this===Sk.builtin.type){if(1===d.length&&(void 0===l||!l.length))return d[0].ob$type;if(3!==d.length)throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");}let r=this.prototype.tp$new(d,l);if(r.$isSuspension)return Sk.misceval.chain(r,v=>{r=v;if(r.ob$type.$isSubType(this))return r.tp$init(d,l)},()=>r);if(r.ob$type.$isSubType(this)){const v=r.tp$init(d,l);return void 0!==v&&v.$isSuspension?Sk.misceval.chain(v,()=>r):r}return r},tp$new:function(d,l){if(3!==d.length){if(1===
d.length&&(void 0===l||!l.length))return d[0].ob$type;throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");}const r=d[0];var v=d[1];const q=d[2];if("dict"!==q.tp$name)throw new Sk.builtin.TypeError("type() argument 3 must be dict, not "+Sk.abstr.typeName(q));if(!Sk.builtin.checkString(r))throw new Sk.builtin.TypeError("type() argument 1 must be str, not "+Sk.abstr.typeName(r));const t=r.$jsstr();if("tuple"!==v.tp$name)throw new Sk.builtin.TypeError("type() argument 2 must be tuple, not "+
Sk.abstr.typeName(v));v=v.sk$asarray();d=function(){this.sk$hasDict&&(this.$d=new Sk.builtin.dict);this.$s=[]};g(t,d,v,this.constructor);const w=d.prototype;Sk.globals&&(w.__module__=Sk.globals.__name__);w.__doc__=Sk.builtin.none.none$;v=q.quick$lookup(Sk.builtin.str.$slots);let C=void 0===v,D=void 0!==d.$typeLookup(Sk.builtin.str.$dict),L;void 0!==v&&(L=new Set,v=Sk.builtin.checkString(v)?[v]:Sk.misceval.arrayFromIterable(v),v.forEach(N=>{if(!Sk.builtin.checkString(N))throw new Sk.builtin.TypeError("__slots__ items must be strings, not '"+
Sk.abstr.typeName(N)+"'");if(!N.$isIdentifier())throw new Sk.builtin.TypeError("__slots__ must be identifiers");if(N===Sk.builtin.str.$dict){if(D)throw new Sk.builtin.TypeError("__dict__ slot disallowed: we already got one");C=!0}else L.add(Sk.mangleName(r,N))}),v=[...L].sort((N,A)=>N.toString().localeCompare(A.toString())),p(v,d));C&&!D&&(w.__dict__=new Sk.builtin.getset_descriptor(d,n),D=!0);Object.defineProperties(w,{ht$slots:{value:v||null,writable:!0},sk$hasDict:{value:D,writable:!0}});q.$items().forEach(N=>
{var [A,H]=N;if(L&&L.has(A))throw new Sk.builtin.ValueError("'"+A.toString()+"' in __slots__ conflicts with class variable");w[A.$mangled]=H});if(w.hasOwnProperty("__qualname__")){v=w.__qualname__;if(!Sk.builtin.checkString(v))throw new Sk.builtin.TypeError("type __qualname__ must be a str, not '"+Sk.abstr.typeName(v)+"'");w.ht$qualname=v}v=d.prototype;b(v,"__init_subclass__","classmethod");b(v,"__new__","staticmethod");b(v,"__class_getitem__","classmethod");d.$allocateSlots();m(d);c(d,l);return d},
tp$init:function(d,l){if(d&&1==d.length&&l&&l.length)throw new Sk.builtin.TypeError("type.__init__() takes no keyword arguments");if(3!=d.length&&1!=d.length)throw new Sk.builtin.TypeError("type.__init__() takes 1 or 3 arguments");return Sk.builtin.object.prototype.tp$init.call(this,[])},tp$getattr:function(d,l){var r=this.ob$type;const v=r.$typeLookup(d);let q;if(void 0!==v&&(q=v.tp$descr_get,void 0!==q&&void 0!==v.tp$descr_set))return l=q.call(v,this,r,l);d=this.$typeLookup(d);if(void 0!==d)return r=
d.tp$descr_get,void 0!==r?l=r.call(d,null,this,l):d;if(void 0!==q)return l=q.call(v,this,r,l);if(void 0!==v)return v},tp$setattr:function(d,l,r){if(!this.sk$klass){if(void 0!==l)throw new Sk.builtin.TypeError("can't set attributes of built-in/extension type '"+this.prototype.tp$name+"'");throw new Sk.builtin.TypeError("can't delete attributes on type object '"+this.prototype.tp$name+"'");}const v=this.ob$type.$typeLookup(d);if(void 0!==v){const q=v.tp$descr_set;if(q)return q.call(v,this,l,r)}r=d.$mangled;
if(void 0===l)if(l=this.prototype,l.hasOwnProperty(r))delete l[r],d=Sk.dunderToSkulpt[r],void 0!==d&&(delete this.prototype[d],l.sk$prototypical||this.$allocateGetterSlot(r));else throw new Sk.builtin.AttributeError("type object '"+this.prototype.tp$name+"' has no attribute '"+d.$jsstr()+"'");else this.prototype[r]=l,r in Sk.dunderToSkulpt&&this.$allocateSlot(r,l)},$r:function(){let d=this.prototype.__module__,l="",r="class";d&&Sk.builtin.checkString(d)?l=d.v+".":d=null;d||this.sk$klass||Sk.__future__.class_repr||
(r="type");return new Sk.builtin.str("<"+r+" '"+l+this.prototype.tp$name+"'>")}},writable:!0},tp$methods:{value:null,writable:!0},tp$classmethods:{value:null,writable:!0},tp$getsets:{value:null,writable:!0},sk$type:{value:!0},$isSubType:{value:function(d){return this===d||this.prototype instanceof d||!this.prototype.sk$prototypical&&this.prototype.tp$mro.includes(d)}},$allocateSlot:{value:function(d,l){d=Sk.slots[d];const r=d.$slot_name,v=this.prototype;v.hasOwnProperty(r)&&delete v[r];Object.defineProperty(v,
r,{value:d.$slot_func(l),writable:!0,configurable:!0})}},$allocateSlots:{value:function(){const d=this.prototype;this.prototype.sk$prototypical?Object.keys(d).forEach(l=>{l in Sk.slots&&this.$allocateSlot(l,d[l])}):Object.keys(Sk.slots).forEach(l=>{d.hasOwnProperty(l)?this.$allocateSlot(l,d[l]):this.$allocateGetterSlot(l)});d.hasOwnProperty("__eq__")&&!d.hasOwnProperty("__hash__")&&(d.tp$hash=d.__hash__=Sk.builtin.none.none$)}},$allocateGetterSlot:{value:function(d){const l=Sk.slots[d].$slot_name,
r=this.prototype;r.hasOwnProperty(l)||Object.defineProperty(r,l,{configurable:!0,get(){const v=r.tp$mro;for(let q=1;q<v.length;q++){const t=Object.getOwnPropertyDescriptor(v[q].prototype,l);if(void 0!==t&&t.value)return t.value}}})}},$typeLookup:{value:function(d){return this.prototype.sk$prototypical?this.prototype[d.$mangled]:e.call(this,d)},writable:!0},$mroMerge:{value:function(d){this.prototype.sk$prototypical=!0;let l;const r=[];for(;;){for(l=0;l<d.length;++l){var v=d[l];if(0!==v.length)break}if(l===
d.length)return r;var q=[];for(l=0;l<d.length;++l)if(v=d[l],0!==v.length){const t=v[0];v=0;a:for(;v<d.length;++v){const w=d[v];for(let C=1;C<w.length;++C)if(w[C]===t)break a}v===d.length&&q.push(t)}if(0===q.length)throw new Sk.builtin.TypeError("Inconsistent precedences in type hierarchy");q=q[0];r.length&&this.prototype.sk$prototypical&&Object.getPrototypeOf(r[r.length-1].prototype)!==q.prototype&&(this.prototype.sk$prototypical=!1);r.push(q);for(l=0;l<d.length;++l)v=d[l],0<v.length&&v[0]===q&&v.splice(0,
1)}}},$buildMRO:{value:function(){const d=[[this]],l=this.prototype.tp$bases;for(var r=0;r<l.length;++r)d.push([...l[r].prototype.tp$mro]);r=[];for(let v=0;v<l.length;++v)r.push(l[v]);d.push(r);return this.$mroMerge(d)}},sk$attrError:{value(){return"type object '"+this.prototype.tp$name+"'"},writable:!0}});Sk.builtin.type.prototype.tp$getsets={__base__:{$get(){return this.prototype.tp$base||Sk.builtin.none.none$}},__bases__:{$get(){void 0===this.sk$tuple_bases&&(this.sk$tuple_bases=new Sk.builtin.tuple(this.prototype.tp$bases));
return this.sk$tuple_bases}},__mro__:{$get(){void 0===this.sk$tuple_mro&&(this.sk$tuple_mro=new Sk.builtin.tuple(this.prototype.tp$mro));return this.sk$tuple_mro}},__dict__:{$get(){return new Sk.builtin.mappingproxy(this.prototype)}},__doc__:{$get(){const d=this.$typeLookup(Sk.builtin.str.$doc);return d?void 0!==d.tp$descr_get?this===Sk.builtin.type?new Sk.builtin.str(this.prototype.tp$doc):d.tp$descr_get(null,this):this.prototype.__doc__:Sk.builtin.none.none$},$set(d){a(this,d,Sk.builtin.str.$doc);
this.prototype.__doc__=d}},__name__:{$get(){let d=this.prototype.ht$name;if(void 0!==d)return new Sk.builtin.str(d);d=this.prototype.tp$name;d.includes(".")&&(d=d.slice(d.lastIndexOf(".")+1));return new Sk.builtin.str(d)},$set(d){a(this,d,Sk.builtin.str.$name);if(!Sk.builtin.checkString(d))throw new Sk.builtin.TypeError("can only assign string to "+this.prototype.tp$name+".__name__, not '"+Sk.abstr.typeName(d)+"'");this.prototype.ht$name=d;this.prototype.tp$name=d.$jsstr()}},__qualname__:{$get(){return this.prototype.ht$qualname||
Sk.abstr.lookupSpecial(this,Sk.builtin.str.$name)},$set(d){a(this,d,Sk.builtin.str.$name);if(!Sk.builtin.checkString(d))throw new Sk.builtin.TypeError("can only assign string to "+this.prototype.tp$name+".__qualname__, not '"+Sk.abstr.typeName(d)+"'");this.prototype.ht$qualname=d}},__module__:{$get(){const d=this.prototype,l=d.__module__;return l&&l.ob$type!==Sk.builtin.getset_descriptor?l:d.tp$name.includes(".")?new Sk.builtin.str(d.tp$name.slice(0,d.tp$name.lastIndexOf("."))):new Sk.builtin.str("builtins")},
$set(d){a(this,d,Sk.builtin.str.$module);this.prototype.__module__=d}}};Sk.builtin.type.prototype.tp$methods={mro:{$meth(){return new Sk.builtin.list(this.$buildMRO())},$flags:{NoArgs:!0}},__dir__:{$meth:function(){function d(q){q in Sk.reservedWords_||(q=Sk.unfixReserved(q),-1!==q.indexOf("$")||l.has(q)||(l.add(q),r.push(new Sk.builtin.str(q))))}const l=new Set,r=[];if(this.prototype.sk$prototypical)for(var v in this.prototype)d(v);else{v=this.prototype.tp$mro;for(let q=0;q<v.length;q++){const t=
Object.getOwnPropertyNames(v[q].prototype);for(let w=0;w<t.length;w++)d(t[w])}}return new Sk.builtin.list(r)},$flags:{NoArgs:!0},$doc:"Specialized __dir__ implementation for types."}};Sk.builtin.type.tp$classmethods={__prepare__:{$meth(){return new Sk.builtin.dict([])},$flags:{FastCall:!0}}};const n={$get(){const d=h(this.ob$type);return void 0!==d?d.tp$descr_get(this,this.ob$type):Sk.generic.getSetDict.$get.call(this)},$set(d){const l=h(this.ob$type);if(void 0!==l)return l.tp$descr_set(this,d);if(void 0===
d)this.$d=new Sk.builtin.dict([]);else return Sk.generic.getSetDict.$set.call(this,d)},$doc:"dictionary for instance variables (if defined)",$name:"__dict__"}},function(E,Q){Sk.generic={};Sk.generic.getAttr=function(b,f){let e;const g=this.ob$type,k=g.$typeLookup(b);if(void 0!==k&&(e=k.tp$descr_get,void 0!==e&&void 0!==k.tp$descr_set))return e.call(k,this,g,f);const p=this.$d;if(void 0!==p&&(b=p.quick$lookup(b),void 0!==b))return b;if(void 0!==e)return e.call(k,this,g,f);if(void 0!==k)return k};Sk.exportSymbol("Sk.generic.getAttr",
Sk.generic.getAttr);Sk.generic.setAttr=function(b,f,e){var g=this.ob$type.$typeLookup(b);if(void 0!==g&&null!==g){const k=g.tp$descr_set;if(k)return k.call(g,this,f,e)}e=this.$d;if(void 0!==e)if(e.mp$ass_subscript){if(void 0!==f)return e.mp$ass_subscript(b,f);try{return e.mp$ass_subscript(b)}catch(k){if(k instanceof Sk.builtin.KeyError)throw new Sk.builtin.AttributeError("'"+Sk.abstr.typeName(this)+"' object has no attribute '"+b.$jsstr()+"'");throw k;}}else if("object"===typeof e){g=b.$mangled;if(void 0!==
f){e[g]=f;return}if(void 0!==e[g]){delete e[g];return}}throw new Sk.builtin.AttributeError(this.sk$attrError()+" has no attribute '"+b.$jsstr()+"'");};Sk.exportSymbol("Sk.generic.setAttr",Sk.generic.setAttr);Sk.generic.new=function(b){return function(f,e){if(this.constructor===b)return new this.constructor;f=new this.constructor;b.call(f);return f}};Sk.generic.newMethodDef={$meth(b,f){const e=this.prototype;if(1>b.length)throw b=e.tp$name,new Sk.builtin.TypeError(b+".__new__(): not enough arguments");
var g=b.shift();if(void 0===g.sk$type)throw b=e.tp$name,new Sk.builtin.TypeError(b+"__new__(X): X is not a type object ("+Sk.abstr.typeName(g)+")");if(!g.$isSubType(this))throw b=e.tp$name,g=g.prototype.tp$name,new Sk.builtin.TypeError(b+".__new__("+g+"): "+g+" is not a subtype of "+b);const k=g.prototype.sk$staticNew.prototype;if(k.tp$new!==e.tp$new)throw b=e.tp$name,g=g.prototype.tp$name,new Sk.builtin.TypeError(b+".__new__("+g+") is not safe, use "+k.tp$name+".__new__()");return e.tp$new.call(g.prototype,
b,f)},$flags:{FastCall:!0},$textsig:"($type, *args, **kwargs)",$name:"__new__"};Sk.generic.selfIter=function(){return this};Sk.generic.iterNextWithArrayCheckSize=function(){if(this.$seq.length!==this.$orig.get$size()){const b=this.tp$name.split("_")[0];throw new Sk.builtin.RuntimeError(b+" changed size during iteration");}if(!(this.$index>=this.$seq.length))return this.$seq[this.$index++]};Sk.generic.iterNextWithArray=function(){const b=this.$seq[this.$index++];void 0===b&&(this.tp$iternext=()=>{});
return b};Sk.generic.iterLengthHintWithArrayMethodDef={$meth:function(){return new Sk.builtin.int_(this.$seq.length-this.$index)},$flags:{NoArgs:!0}};Sk.generic.iterReverseLengthHintMethodDef={$meth:function(){return new Sk.builtin.int_(this.$index)},$flags:{NoArgs:!0}};Sk.generic.getSetDict={$get(){return this.$d},$set(b){if(void 0===b)throw new Sk.builtin.TypeError("cannot delete __dict__");if(b instanceof Sk.builtin.dict)this.$d=b;else throw new Sk.builtin.TypeError("__dict__ must be set to a dictionary, not a '"+
Sk.abstr.typeName(b)+"'");},$doc:"dictionary for instance variables (if defined)",$name:"__dict__"};Sk.generic.seqCompare=function(b,f){if(this===b&&Sk.misceval.opAllowsEquality(f))return!0;if(!(b instanceof this.sk$builtinBase))return Sk.builtin.NotImplemented.NotImplemented$;const e=this.v;b=b.v;let g;if(e.length!==b.length&&("Eq"===f||"NotEq"===f))return"Eq"===f?!1:!0;for(g=0;g<e.length&&g<b.length&&(e[g]===b[g]||Sk.misceval.richCompareBool(e[g],b[g],"Eq"));++g);const k=e.length,p=b.length;if(g>=
k||g>=p)switch(f){case "Lt":return k<p;case "LtE":return k<=p;case "Eq":return k===p;case "NotEq":return k!==p;case "Gt":return k>p;case "GtE":return k>=p;default:Sk.asserts.fail()}return"Eq"===f?!1:"NotEq"===f?!0:Sk.misceval.richCompareBool(e[g],b[g],f)};Sk.generic.classGetItem={__class_getitem__:{$meth(b){return new Sk.builtin.GenericAlias(this,b)},$flags:{OneArg:!0}}}},function(E,Q){Sk.builtin.pyCheckArgs=function(b,f,e,g,k,p){f=f.length;void 0===g&&(g=Infinity);k&&--f;p&&--f;if(f<e||f>g)throw new Sk.builtin.TypeError((e===
g?b+"() takes exactly "+e+" arguments":f<e?b+"() takes at least "+e+" arguments":0<e?b+"() takes at most "+g+" arguments":b+"() takes no arguments")+(" ("+f+" given)"));};Sk.exportSymbol("Sk.builtin.pyCheckArgs",Sk.builtin.pyCheckArgs);Sk.builtin.pyCheckArgsLen=function(b,f,e,g,k,p){void 0===g&&(g=Infinity);k&&--f;p&&--f;if(f<e||f>g)throw new Sk.builtin.TypeError((e===g?b+"() takes exactly "+e+" arguments":f<e?b+"() takes at least "+e+" arguments":b+"() takes at most "+g+" arguments")+(" ("+f+" given)"));
};Sk.builtin.pyCheckType=function(b,f,e){if(!e)throw new Sk.builtin.TypeError(b+" must be a "+f);};Sk.exportSymbol("Sk.builtin.pyCheckType",Sk.builtin.pyCheckType);Sk.builtin.checkSequence=function(b){return null!=b&&void 0!==b.mp$subscript};Sk.exportSymbol("Sk.builtin.checkSequence",Sk.builtin.checkSequence);Sk.builtin.checkIterable=function(b){return void 0===b?!1:b.tp$iter?void 0!==b.tp$iter().tp$iternext:void 0!==b.mp$subscript};Sk.exportSymbol("Sk.builtin.checkIterable",Sk.builtin.checkIterable);
Sk.builtin.checkCallable=function(b){return null!=b&&void 0!==b.tp$call};Sk.builtin.checkNumber=function(b){return"number"===typeof b||b instanceof Sk.builtin.int_||b instanceof Sk.builtin.float_||b instanceof Sk.builtin.lng};Sk.exportSymbol("Sk.builtin.checkNumber",Sk.builtin.checkNumber);Sk.builtin.checkComplex=function(b){return b instanceof Sk.builtin.complex};Sk.exportSymbol("Sk.builtin.checkComplex",Sk.builtin.checkComplex);Sk.builtin.checkInt=function(b){return b instanceof Sk.builtin.int_||
"number"===typeof b&&Number.isInteger(b)};Sk.exportSymbol("Sk.builtin.checkInt",Sk.builtin.checkInt);Sk.builtin.checkFloat=function(b){return b instanceof Sk.builtin.float_};Sk.exportSymbol("Sk.builtin.checkFloat",Sk.builtin.checkFloat);Sk.builtin.checkString=function(b){return b instanceof Sk.builtin.str};Sk.exportSymbol("Sk.builtin.checkString",Sk.builtin.checkString);Sk.builtin.checkBytes=function(b){return b instanceof Sk.builtin.bytes};Sk.builtin.checkClass=function(b){return b instanceof Sk.builtin.type};
Sk.exportSymbol("Sk.builtin.checkClass",Sk.builtin.checkClass);Sk.builtin.checkBool=function(b){return b instanceof Sk.builtin.bool};Sk.exportSymbol("Sk.builtin.checkBool",Sk.builtin.checkBool);Sk.builtin.checkNone=function(b){return b===Sk.builtin.none.none$};Sk.exportSymbol("Sk.builtin.checkNone",Sk.builtin.checkNone);Sk.builtin.checkFunction=function(b){return null!=b&&void 0!==b.tp$call};Sk.exportSymbol("Sk.builtin.checkFunction",Sk.builtin.checkFunction);Sk.builtin.checkDataDescr=function(b){return b&&
void 0!==b.tp$descr_set};Sk.exportSymbol("Sk.builtin.checkDataDescr",Sk.builtin.checkDataDescr);Sk.builtin.checkAnySet=function(b){return b instanceof Sk.builtin.set||b instanceof Sk.builtin.frozenset};Sk.builtin.checkMapping=function(b){return b instanceof Sk.builtin.dict||null!=b&&void 0!==b.mp$subscript&&void 0!==Sk.abstr.lookupSpecial(b,Sk.builtin.str.$keys)}},function(E,Q){function b(d,l){switch(l){case "Add":return d.nb$add;case "Sub":return d.nb$subtract;case "Mult":return d.nb$multiply;case "MatMult":if(Sk.__future__.python3)return d.nb$matrix_multiply;
case "Div":return d.nb$divide;case "FloorDiv":return d.nb$floor_divide;case "Mod":return d.nb$remainder;case "DivMod":return d.nb$divmod;case "Pow":return d.nb$power;case "LShift":return d.nb$lshift;case "RShift":return d.nb$rshift;case "BitAnd":return d.nb$and;case "BitXor":return d.nb$xor;case "BitOr":return d.nb$or}}function f(d,l){switch(l){case "Add":return d.nb$reflected_add;case "Sub":return d.nb$reflected_subtract;case "Mult":return d.nb$reflected_multiply;case "MatMult":if(Sk.__future__.python3)return d.nb$reflected_matrix_multiply;
case "Div":return d.nb$reflected_divide;case "FloorDiv":return d.nb$reflected_floor_divide;case "Mod":return d.nb$reflected_remainder;case "DivMod":return d.nb$reflected_divmod;case "Pow":return d.nb$reflected_power;case "LShift":return d.nb$reflected_lshift;case "RShift":return d.nb$reflected_rshift;case "BitAnd":return d.nb$reflected_and;case "BitXor":return d.nb$reflected_xor;case "BitOr":return d.nb$reflected_or}}function e(d,l){switch(l){case "Add":return d.nb$inplace_add;case "Sub":return d.nb$inplace_subtract;
case "Mult":return d.nb$inplace_multiply;case "MatMult":if(Sk.__future__.python3)return d.nb$inplace_matrix_multiply;case "Div":return d.nb$inplace_divide;case "FloorDiv":return d.nb$inplace_floor_divide;case "Mod":return d.nb$inplace_remainder;case "Pow":return d.nb$inplace_power;case "LShift":return d.nb$inplace_lshift;case "RShift":return d.nb$inplace_rshift;case "BitAnd":return d.nb$inplace_and;case "BitOr":return d.nb$inplace_or;case "BitXor":return d.nb$inplace_xor}}function g(d,l,r){const v=
l.constructor,q=d.constructor;let t;let w=!1;if(v!==q&&void 0===v.sk$baseClass&&l instanceof q)if(t=f(l,r),void 0===t)w=!0;else if(t!==f(d,r)){w=!0;var C=t.call(l,d);if(C!==Sk.builtin.NotImplemented.NotImplemented$)return C}C=b(d,r);if(void 0!==C&&(C=C.call(d,l),C!==Sk.builtin.NotImplemented.NotImplemented$)||!w&&v!==q&&(t||(t=f(l,r)),void 0!==t&&(C=t.call(l,d),C!==Sk.builtin.NotImplemented.NotImplemented$)))return C}function k(d,l,r){var v=e(d,r);return void 0!==v&&(v=v.call(d,l),v!==Sk.builtin.NotImplemented.NotImplemented$)?
v:g(d,l,r)}function p(d){n.forEach(l=>{var [r,v]=l;d[v]=function(q){return this.tp$richcompare(q,r)}})}function h(d){const l=Sk.reflectedNumberSlots;Object.keys(l).forEach(r=>{if(void 0!==d[r]){const v=l[r],q=v.reflected,t=d[q];void 0!==t?null===t&&delete d[q]:d[q]=v.slot||d[r]}})}function a(d){const l=Sk.sequenceAndMappingSlots;Object.keys(l).forEach(r=>{void 0!==d[r]&&l[r].forEach(v=>{d[v]=d[r]})})}Sk.abstr={};Sk.abstr.typeName=function(d){if(null!=d&&void 0!==d.tp$name){let l=d.ht$name;if(void 0!==
l)return l.toString();l=d.tp$name;l.includes(".")&&(l=l.slice(l.lastIndexOf(".")+1));return l}Sk.asserts.fail(d+" passed to typeName");return"<invalid type>"};const c={Add:"+",Sub:"-",Mult:"*",MatMult:"@",Div:"/",FloorDiv:"//",Mod:"%",DivMod:"divmod()",Pow:"** or pow()",LShift:"<<",RShift:">>",BitAnd:"&",BitXor:"^",BitOr:"|"},m={UAdd:"+",USub:"-",Invert:"~"};Sk.abstr.numberBinOp=function(d,l,r){var v;if(!(v=g(d,l,r)))throw d=Sk.abstr.typeName(d),l=Sk.abstr.typeName(l),new Sk.builtin.TypeError("unsupported operand type(s) for "+
c[r]+": '"+d+"' and '"+l+"'");return v};Sk.exportSymbol("Sk.abstr.numberBinOp",Sk.abstr.numberBinOp);Sk.abstr.numberInplaceBinOp=function(d,l,r){var v;if(!(v=k(d,l,r)))throw d=Sk.abstr.typeName(d),l=Sk.abstr.typeName(l),new Sk.builtin.TypeError("unsupported operand type(s) for "+c[r]+"=: '"+d+"' and '"+l+"'");return v};Sk.exportSymbol("Sk.abstr.numberInplaceBinOp",Sk.abstr.numberInplaceBinOp);Sk.abstr.numberUnaryOp=function(d,l){if("Not"===l)return Sk.misceval.isTrue(d)?Sk.builtin.bool.false$:Sk.builtin.bool.true$;
b:{switch(l){case "USub":var r=d.nb$negative;break b;case "UAdd":r=d.nb$positive;break b;case "Invert":r=d.nb$invert;break b}r=void 0}r=void 0!==r?r.call(d):void 0;if(!r)throw d=Sk.abstr.typeName(d),new Sk.builtin.TypeError("bad operand type for unary "+m[l]+": '"+d+"'");return r};Sk.exportSymbol("Sk.abstr.numberUnaryOp",Sk.abstr.numberUnaryOp);Sk.abstr.fixSeqIndex_=function(d,l){l=Sk.builtin.asnum$(l);0>l&&d.sq$length&&(l+=d.sq$length());return l};Sk.abstr.sequenceContains=function(d,l,r){if(d.sq$contains)return d.sq$contains(l,
r);d=Sk.misceval.iterFor(Sk.abstr.iter(d),function(v){return v===l||Sk.misceval.richCompareBool(v,l,"Eq")?new Sk.misceval.Break(!0):!1},!1);return r?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)};Sk.abstr.sequenceConcat=function(d,l){if(d.sq$concat)return d.sq$concat(l);if(Sk.builtin.checkSequence(d)&&Sk.builtin.checkSequence(l)&&(l=g(d,l,"Add"),void 0!==l))return l;throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(d)+"' object can't be concatenated");};Sk.abstr.sequenceInPlaceConcat=function(d,
l){if(d.sq$inplace_concat)return d.sq$inplace_concat(l);if(d.sq$concat)return d.sq$concat(l);if(Sk.builtin.checkSequence(d)&&Sk.builtin.checkSequence(l)&&(l=k(d,l,"Add"),void 0!==l))return l;throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(d)+"' object can't be concatenated");};Sk.abstr.sequenceGetIndexOf=function(d,l){if(d.index)return Sk.misceval.callsimArray(d.index,[d,l]);let r=0;for(let v=Sk.abstr.iter(d),q=v.tp$iternext();void 0!==q;q=v.tp$iternext()){if(Sk.misceval.richCompareBool(l,q,
"Eq"))return new Sk.builtin.int_(r);r+=1}throw new Sk.builtin.ValueError("sequence.index(x): x not in sequence");};Sk.abstr.sequenceGetCountOf=function(d,l){if(d.count)return Sk.misceval.callsimArray(d.count,[d,l]);let r=0;for(let v=Sk.abstr.iter(d),q=v.tp$iternext();void 0!==q;q=v.tp$iternext())Sk.misceval.richCompareBool(l,q,"Eq")&&(r+=1);return new Sk.builtin.int_(r)};Sk.abstr.sequenceGetItem=function(d,l,r){"number"===typeof l&&(l=new Sk.builtin.int_(l));return Sk.abstr.objectGetItem(d,l,r)};
Sk.abstr.sequenceSetItem=function(d,l,r,v){"number"===typeof l&&(l=new Sk.builtin.int_(l));return Sk.abstr.objectSetItem(d,l,r,v)};Sk.abstr.sequenceDelItem=function(d,l,r){return Sk.abstr.objectDelItem(d,l,r)};Sk.abstr.sequenceGetSlice=function(d,l,r){return Sk.abstr.objectGetItem(d,new Sk.builtin.slice(l,r))};Sk.abstr.sequenceDelSlice=function(d,l,r){return Sk.abstr.objectDelItem(d,new Sk.builtin.slice(l,r))};Sk.abstr.sequenceSetSlice=function(d,l,r,v){return Sk.abstr.objectSetItem(d,new Sk.builtin.slice(l,
r))};Sk.abstr.sequenceUnpack=function(d,l,r,v){if(!Sk.builtin.checkIterable(d))throw new Sk.builtin.TypeError("cannot unpack non-iterable "+Sk.abstr.typeName(d)+" object");const q=Sk.abstr.iter(d),t=[];let w=0,C;0<l&&(C=Sk.misceval.iterFor(q,D=>{t.push(D);if(++w===l)return new Sk.misceval.Break}));return Sk.misceval.chain(C,()=>{if(t.length<l)throw new Sk.builtin.ValueError("not enough values to unpack (expected at least "+r+", got "+t.length+")");if(!v)return Sk.misceval.chain(q.tp$iternext(!0),
L=>{if(void 0!==L)throw new Sk.builtin.ValueError("too many values to unpack (expected "+l+")");return t});const D=[];return Sk.misceval.chain(Sk.misceval.iterFor(q,L=>{D.push(L)}),()=>{const L=D.length+l-r;if(0>L)throw new Sk.builtin.ValueError("not enough values to unpack (expected at least "+r+", got "+(r+L)+")");t.push(new Sk.builtin.list(D.slice(0,L)));t.push(...D.slice(L));return t})})};Sk.abstr.mappingUnpackIntoKeywordArray=function(d,l,r){if(l instanceof Sk.builtin.dict)l.$items().forEach(q=>
{var [t,w]=q;if(!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError((r.$qualname?r.$qualname+"() ":"")+"keywords must be strings");d.push(t.v);d.push(w)});else{var v=Sk.abstr.lookupSpecial(l,Sk.builtin.str.$keys);if(void 0===v)throw new Sk.builtin.TypeError("Object is not a mapping");return Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(v),q=>Sk.misceval.iterFor(Sk.abstr.iter(q),t=>{if(!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError((r.$qualname?r.$qualname+"() ":"")+"keywords must be strings");
return Sk.misceval.chain(l.mp$subscript(t,!0),w=>{d.push(t.v);d.push(w)})}))}};Sk.abstr.keywordArrayFromPyDict=function(d){const l=[];d.$items().forEach(r=>{var [v,q]=r;if(!Sk.builtin.checkString(v))throw new Sk.builtin.TypeError("keywords must be strings");l.push(v.toString());l.push(q)});return l};Sk.abstr.keywordArrayToPyDict=function(d){const l=new Sk.builtin.dict;for(let r=0;r<d.length;r+=2)l.mp$ass_subscript(new Sk.builtin.str(d[r]),d[r+1]);return l};Sk.abstr.copyKeywordsToNamedArgs=function(d,
l,r,v,q){v=v||[];var t=r.length+v.length/2;if(t>l.length)throw new Sk.builtin.TypeError(d+"() expected at most "+l.length+" arguments ("+t+" given)");if(v.length||void 0!==q){if(t===l.length&&!v.length)return r;if(0===t&&l.length===(q&&q.length))return q}else return r;r=r.slice(0);for(t=0;t<v.length;t+=2){const w=v[t],C=v[t+1],D=l.indexOf(w);if(0<=D){if(void 0!==r[D])throw new Sk.builtin.TypeError(d+"() got multiple values for argument '"+w+"'");r[D]=C}else throw new Sk.builtin.TypeError(d+"() got an unexpected keyword argument '"+
w+"'");}if(q){v=l.length;for(t=v-1;0<=t;t--)void 0===r[t]&&(r[t]=q[q.length-1-(v-1-t)]);l=l.filter((w,C)=>void 0===r[C]);if(l.length)throw new Sk.builtin.TypeError(d+"() missing "+l.length+" required positional arguments: "+l.join(", "));}return r};Sk.exportSymbol("Sk.abstr.copyKeywordsToNamedArgs",Sk.abstr.copyKeywordsToNamedArgs);Sk.abstr.checkNoKwargs=function(d,l){if(l&&l.length)throw new Sk.builtin.TypeError(d+"() takes no keyword arguments");};Sk.exportSymbol("Sk.abstr.checkNoKwargs",Sk.abstr.checkNoKwargs);
Sk.abstr.checkNoArgs=function(d,l,r){if(l=l.length+(r?r.length:0))throw new Sk.builtin.TypeError(d+"() takes no arguments ("+l+" given)");};Sk.exportSymbol("Sk.abstr.checkNoArgs",Sk.abstr.checkNoArgs);Sk.abstr.checkOneArg=function(d,l,r){Sk.abstr.checkNoKwargs(d,r);if(1!==l.length)throw new Sk.builtin.TypeError(d+"() takes exactly one argument ("+l.length+" given)");};Sk.exportSymbol("Sk.abstr.checkOneArg",Sk.abstr.checkOneArg);Sk.abstr.checkArgsLen=function(d,l,r,v){l=l.length;void 0===v&&(v=Infinity);
if(l<r||l>v)throw new Sk.builtin.TypeError((r===v?d+"() takes exactly "+r+" arguments":l<r?d+"() takes at least "+r+" arguments":d+"() takes at most "+v+" arguments")+(" ("+l+" given)"));};Sk.exportSymbol("Sk.abstr.checkArgsLen",Sk.abstr.checkArgsLen);Sk.abstr.objectFormat=function(d,l){if(void 0===l)l=Sk.builtin.str.$emptystr;else if(!Sk.builtin.checkString(l))throw new Sk.builtin.TypeError("Format specifier must be a string, not "+Sk.abstr.typeName(l));d=Sk.abstr.lookupSpecial(d,Sk.builtin.str.$format);
l=Sk.misceval.callsimArray(d,[l]);if(!Sk.builtin.checkString(l))throw new Sk.builtin.TypeError("__format__ must return a str, not "+Sk.abstr.typeName(l));return l};Sk.abstr.objectHash=function(d){const l=d.tp$hash;if(void 0!==l){if(Sk.builtin.checkNone(l))throw new Sk.builtin.TypeError("unhashable type: '"+Sk.abstr.typeName(d)+"'");return d.tp$hash()}throw new Sk.builtin.TypeError("unsupported Javascript type");};Sk.abstr.objectAdd=function(d,l){if(d.nb$add)return d.nb$add(l);d=Sk.abstr.typeName(d);
l=Sk.abstr.typeName(l);throw new Sk.builtin.TypeError("unsupported operand type(s) for +: '"+d+"' and '"+l+"'");};Sk.abstr.objectNegative=function(d){if(d.nb$negative)return d.nb$negative();throw new Sk.builtin.TypeError("bad operand type for unary -: '"+Sk.abstr.typeName(d)+"'");};Sk.abstr.objectPositive=function(d){if(d.nb$positive)return d.nb$positive();throw new Sk.builtin.TypeError("bad operand type for unary +: '"+Sk.abstr.typeName(d)+"'");};Sk.abstr.objectDelItem=function(d,l,r){if(d.mp$ass_subscript)return d.mp$ass_subscript(l,
void 0,r);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(d)+"' object does not support item deletion");};Sk.exportSymbol("Sk.abstr.objectDelItem",Sk.abstr.objectDelItem);Sk.abstr.objectGetItem=function(d,l,r){if(d.mp$subscript)return d.mp$subscript(l,r);if(Sk.builtin.checkClass(d)){if(d===Sk.builtin.type)return new Sk.builtin.GenericAlias(d,l);const v=Sk.abstr.typeLookup(d,Sk.builtin.str.$class_getitem);if(void 0!==v)return d=Sk.misceval.callsimOrSuspendArray(v,[l]),r?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)}throw new Sk.builtin.TypeError("'"+
Sk.abstr.typeName(d)+"' does not support indexing");};Sk.exportSymbol("Sk.abstr.objectGetItem",Sk.abstr.objectGetItem);Sk.abstr.objectSetItem=function(d,l,r,v){if(d.mp$ass_subscript)return d.mp$ass_subscript(l,r,v);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(d)+"' does not support item assignment");};Sk.exportSymbol("Sk.abstr.objectSetItem",Sk.abstr.objectSetItem);Sk.abstr.gattr=function(d,l,r){r=d.tp$getattr(l,r);if(void 0===r)throw new Sk.builtin.AttributeError(d.sk$attrError()+" has no attribute '"+
l.$jsstr()+"'");return r.$isSuspension?Sk.misceval.chain(r,function(v){if(void 0===v)throw new Sk.builtin.AttributeError(d.sk$attrError()+" has no attribute '"+l.$jsstr()+"'");return v}):r};Sk.exportSymbol("Sk.abstr.gattr",Sk.abstr.gattr);Sk.abstr.sattr=function(d,l,r,v){return d.tp$setattr(l,r,v)};Sk.exportSymbol("Sk.abstr.sattr",Sk.abstr.sattr);Sk.abstr.iternext=function(d,l){return d.tp$iternext(l)};Sk.exportSymbol("Sk.abstr.iternext",Sk.abstr.iternext);Sk.abstr.iter=function(d){if(d.tp$iter){d=
d.tp$iter();if(d.tp$iternext)return d;throw new Sk.builtin.TypeError("iter() returned non-iterator of type '"+Sk.abstr.typeName(d)+"'");}if(d.mp$subscript)return new Sk.builtin.seq_iter_(d);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(d)+"' object is not iterable");};Sk.exportSymbol("Sk.abstr.iter",Sk.abstr.iter);Sk.abstr.lookupSpecial=function(d,l){var r=d.ob$type;if(void 0===r)Sk.asserts.fail("javascript object sent to lookupSpecial");else if(l=r.$typeLookup(l),void 0!==l)return void 0!==
l.tp$descr_get&&(l=l.tp$descr_get(d,r)),l};Sk.exportSymbol("Sk.abstr.lookupSpecial",Sk.abstr.lookupSpecial);Sk.abstr.typeLookup=function(d,l){l=d.$typeLookup(l);return void 0!==l&&l.tp$descr_get?l.tp$descr_get(null,d):l};Sk.abstr.markUnhashable=function(d){d=d.prototype;d.__hash__=Sk.builtin.none.none$;d.tp$hash=Sk.builtin.none.none$};Sk.abstr.setUpInheritance=function(d,l,r,v){v=v||Sk.builtin.type;r=void 0===r?Sk.builtin.object:r;const q=null!==r?r.prototype:null;Object.setPrototypeOf(l,v.prototype);
Object.setPrototypeOf(l.prototype,q);Object.defineProperties(l.prototype,{sk$object:{value:l,writable:!0},ob$type:{value:l,writable:!0},tp$name:{value:d,writable:!0},tp$base:{value:r,writable:!0}})};Sk.abstr.setUpBuiltinMro=function(d){let l=d.prototype.tp$base;const r=null===l?[]:[l];if(l===Sk.builtin.object||null===l)Object.defineProperty(d,"sk$baseClass",{value:!0,writable:!0}),Object.defineProperty(d.prototype,"sk$builtinBase",{value:d,writable:!0});Object.defineProperty(d,"sk$solidBase",{value:!0,
writable:!0});const v=[d];for(;null!==l;)v.push(l),l=l.prototype.tp$base;Object.defineProperties(d.prototype,{sk$prototypical:{value:!0,writable:!0},tp$bases:{value:r,writable:!0},tp$mro:{value:v,writable:!0}});Object.defineProperty(d,"$typeLookup",{value:function(q){return this.prototype[q.$mangled]},writable:!0})};Sk.abstr.setUpGetSets=function(d,l){if(void 0!==Sk.builtin.getset_descriptor){var r=d.prototype;l=l||r.tp$getsets||{};Object.entries(l).forEach(v=>{var [q,t]=v;t.$name=q;r[q]=new Sk.builtin.getset_descriptor(d,
t)});Object.defineProperty(r,"tp$getsets",{value:null,writable:!0})}};Sk.abstr.setUpMethods=function(d,l){if(void 0!==Sk.builtin.method_descriptor){var r=d.prototype;l=l||r.tp$methods||{};Object.entries(l).forEach(v=>{var [q,t]=v;t.$name=q;r[q]=new Sk.builtin.method_descriptor(d,t)});Object.defineProperty(r,"tp$methods",{value:null,writable:!0})}};Sk.abstr.setUpClassMethods=function(d,l){if(void 0!==Sk.builtin.classmethod_descriptor){var r=d.prototype;l=l||r.tp$classmethods||{};Object.entries(l).forEach(v=>
{var [q,t]=v;t.$name=q;r[q]=new Sk.builtin.classmethod_descriptor(d,t)});Object.defineProperty(r,"tp$classmethods",{value:null,writable:!0})}};const n=Object.entries({Eq:"ob$eq",NotEq:"ob$ne",Gt:"ob$gt",GtE:"ob$ge",Lt:"ob$lt",LtE:"ob$le"});Sk.abstr.setUpSlots=function(d,l){function r(w,C){q[w]=new Sk.builtin.wrapper_descriptor(d,Sk.slots[w],C)}function v(w,C){"string"===typeof w?r(w,C):w.forEach(D=>{r(D,C)})}if(void 0!==Sk.builtin.wrapper_descriptor){var q=d.prototype;l=l||q.tp$slots||{};l.tp$new===
Sk.generic.new&&(l.tp$new=Sk.generic.new(d));l.tp$richcompare&&p(l);l.tp$as_number&&h(l);l.tp$as_sequence_or_mapping&&a(l);Object.entries(l).forEach(w=>{var [C,D]=w;Object.defineProperty(q,C,{value:D,writable:!0})});l.tp$new&&(q.__new__=new Sk.builtin.sk_method(Sk.generic.newMethodDef,d),Object.defineProperty(q,"sk$staticNew",{value:d,writable:!0}));Sk.subSlots.main_slots.forEach(w=>{var [C,D]=w;w=l[C];void 0!==w&&v(D,w)});var t=l.tp$hash;void 0!==t&&("function"===typeof t?r("__hash__",t):t===Sk.builtin.none.none$?
q.__hash__=t:Sk.asserts.fail("invalid tp$hash"));l.tp$as_number&&Sk.subSlots.number_slots.forEach(w=>{var [C,D]=w;w=l[C];void 0!==w&&v(D,w)});l.tp$as_sequence_or_mapping&&Sk.subSlots.sequence_and_mapping_slots.forEach(w=>{var [C,D]=w;w=l[C];void 0!==w&&v(D,w)});Object.defineProperty(q,"tp$slots",{value:null,writable:!0})}};Sk.abstr.buildNativeClass=function(d,l){l=l||{};Sk.asserts.assert(l.hasOwnProperty("constructor"),"A constructor is required to build a native class");let r=l.constructor;Sk.abstr.setUpInheritance(d,
r,l.base,l.meta);Sk.abstr.setUpBuiltinMro(r);const v=r.prototype;Object.defineProperties(v,{tp$slots:{value:l.slots,writable:!0},tp$getsets:{value:l.getsets,writable:!0},tp$methods:{value:l.methods,writable:!0},tp$classmethods:{value:l.classmethods,writable:!0}});Sk.abstr.setUpSlots(r,l.slots||{});Sk.abstr.setUpMethods(r,l.methods);Sk.abstr.setUpGetSets(r,l.getsets);Sk.abstr.setUpClassMethods(r,l.classmethods);Object.entries(l.proto||{}).forEach(q=>{var [t,w]=q;Object.defineProperty(v,t,{value:w,
writable:!0,enumerable:!(t.includes("$")||t in Object.prototype)})});Object.entries(l.flags||{}).forEach(q=>{var [t,w]=q;Object.defineProperty(r,t,{value:w,writable:!0})});void 0!==Sk.builtin.str&&v.hasOwnProperty("tp$doc")&&!v.hasOwnProperty("__doc__")&&(d=v.tp$doc||null,v.__doc__="string"===typeof d?new Sk.builtin.str(d):Sk.builtin.none.none$);return r};Sk.abstr.buildIteratorClass=function(d,l){Sk.asserts.assert(l.hasOwnProperty("constructor"),"must provide a constructor");l.slots=l.slots||{};l.slots.tp$iter=
Sk.generic.selfIter;l.slots.tp$iternext=l.slots.tp$iternext||l.iternext;l.slots.tp$getattr=l.slots.tp$getattr||Sk.generic.getAttr;d=Sk.abstr.buildNativeClass(d,l);Sk.abstr.built$iterators.push(d);return d};Sk.abstr.built$iterators=[];Sk.abstr.setUpModuleMethods=function(d,l,r){Object.entries(r).forEach(v=>{var [q,t]=v;t.$name=t.$name||q;l[q]=new Sk.builtin.sk_method(t,null,d)})};Sk.abstr.superConstructor=function(d,l,r){var v=Array.prototype.slice.call(arguments,2);d.prototype.tp$base.apply(l,v)}},
function(E,Q){function b(g){const k=g.prototype,p=k.tp$base;if(null==p)return!1;const h=p.prototype;return p.sk$solidSlotBase||g.sk$solidSlotBase||h.sk$hasDict!==k.sk$hasDict||p.sk$solidBase&&p!==Sk.builtin.module?!1:!0}function f(g,k){g=g.prototype;k=k.prototype;const p=g.ht$slots,h=k.ht$slots;return g.sk$hasDict!==k.sk$hasDict?!1:p===h?!0:p&&h?p.length===h.length&&p.every((a,c)=>a===h[c]):(p&&(p.length||null))===(h&&(h.length||null))}const e=new WeakMap;Sk.builtin.object=Sk.abstr.buildNativeClass("object",
{constructor:function(){Sk.asserts.assert(this instanceof Sk.builtin.object,"bad call to object, use 'new'")},base:null,slots:{tp$new(g,k){if(g.length||k&&k.length){if(this.tp$new!==Sk.builtin.object.prototype.tp$new)throw new Sk.builtin.TypeError("object.__new__() takes exactly one argument (the type to instantiate)");if(this.tp$init===Sk.builtin.object.prototype.tp$init)throw new Sk.builtin.TypeError(Sk.abstr.typeName(this)+"() takes no arguments");}return new this.constructor},tp$init(g,k){if(g.length||
k&&k.length){if(this.tp$init!==Sk.builtin.object.prototype.tp$init)throw new Sk.builtin.TypeError("object.__init__() takes exactly one argument (the instance to initialize)");if(this.tp$new===Sk.builtin.object.prototype.tp$new)throw new Sk.builtin.TypeError(Sk.abstr.typeName(this)+".__init__() takes exactly one argument (the instance to initialize)");}},tp$getattr:Sk.generic.getAttr,tp$setattr:Sk.generic.setAttr,$r(){const g=Sk.abstr.lookupSpecial(this,Sk.builtin.str.$module);let k="";g&&Sk.builtin.checkString(g)&&
(k=g.v+".");return new Sk.builtin.str("<"+k+Sk.abstr.typeName(this)+" object>")},tp$str(){return this.$r()},tp$hash(){let g=e.get(this);if(void 0!==g)return g;g=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER-Number.MAX_SAFE_INTEGER/2);e.set(this,g);return g},tp$richcompare(g,k){switch(k){case "Eq":g=this===g||Sk.builtin.NotImplemented.NotImplemented$;break;case "NotEq":g=this.ob$eq(g,"Eq");g!==Sk.builtin.NotImplemented.NotImplemented$&&(g=!Sk.misceval.isTrue(g));break;default:g=Sk.builtin.NotImplemented.NotImplemented$}return g},
tp$doc:"The most base type"},getsets:{__class__:{$get(){return this.ob$type},$set(g){if(void 0===g)throw new Sk.builtin.TypeError("can't delete __class__ attribute");if(!Sk.builtin.checkClass(g))throw new Sk.builtin.TypeError("__class__ must be set to a class, not '"+Sk.abstr.typeName(g)+"' object");const k=this.ob$type;if(!(k.$isSubType(Sk.builtin.module)&&g.$isSubType(Sk.builtin.module)||void 0!==k.prototype.ht$type&&void 0!==g.prototype.ht$type))throw new Sk.builtin.TypeError(" __class__ assignment only supported for heap types or ModuleType subclasses");
{let p=k,h=g;for(;b(p);)p=p.prototype.tp$base;for(;b(h);)h=h.prototype.tp$base;if(p!==h&&(p.prototype.tp$base!==h.prototype.tp$base||!f(p,h)))throw new Sk.builtin.TypeError("__class__ assignment: '"+g.prototype.tp$name+"' object layout differs from '"+k.prototype.tp$name+"'");}Object.setPrototypeOf(this,g.prototype)},$doc:"the object's class"}},methods:{__dir__:{$meth:function(){let g=[];if(this.$d)if(this.$d instanceof Sk.builtin.dict)g=this.$d.sk$asarray();else for(var k in this.$d)g.push(new Sk.builtin.str(k));
k=Sk.misceval.callsimArray(Sk.builtin.type.prototype.__dir__,[this.ob$type]);g.push(...k.v);k.v=g;return k},$flags:{NoArgs:!0},$doc:"Default dir() implementation."},__format__:{$meth(g){if(!Sk.builtin.checkString(g))throw new Sk.builtin.TypeError("__format__() argument must be str, not "+Sk.abstr.typeName(g));if(g!==Sk.builtin.str.$empty)throw new Sk.builtin.TypeError(`unsupported format string passed to ${Sk.abstr.typeName(this)}.__format__`);return this.tp$str()},$flags:{OneArg:!0},$doc:"Default object formatter."}},
classmethods:{__init_subclass__:{$meth(g){return Sk.builtin.none.none$},$flags:{FastCall:!0,NoKwargs:!0}}},proto:{valueOf:Object.prototype.valueOf,toString(){return this.tp$str().v},hasOwnProperty:Object.prototype.hasOwnProperty,ht$type:void 0,sk$attrError(){return"'"+this.tp$name+"' object"}}});Sk.abstr.setUpInheritance("type",Sk.builtin.type,Sk.builtin.object);Sk.abstr.setUpBuiltinMro(Sk.builtin.type)},function(E,Q){function b(q,t,w){Sk.abstr.checkNoArgs(this.$name,t,w);q=this.call(q);return void 0===
q?Sk.builtin.none.none$:q}function f(q,t,w){Sk.abstr.checkOneArg(this.$name,t,w);q=this.call(q,t[0]);return void 0===q?Sk.builtin.none.none$:q}function e(q,t,w){Sk.abstr.checkNoKwargs(this.$name,w);Sk.abstr.checkArgsLen(this.$name,t,1,2);q=this.call(q,...t);return void 0===q?Sk.builtin.none.none$:q}function g(q,t,w){Sk.abstr.checkNoKwargs(this.$name,w);Sk.abstr.checkArgsLen(this.$name,t,2,2);this.call(q,t[0],t[1]);return Sk.builtin.none.none$}function k(q,t,w){q=f.call(this,q,t,w);return q===Sk.builtin.NotImplemented.NotImplemented$?
q:new Sk.builtin.bool(q)}function p(q,t){return function(w,C,D){w=q.call(this,w,C,D);return t(w)}}function h(q){return function(){const t=q.tp$descr_get?q.tp$descr_get(this):q;return Sk.misceval.callsimArray(t,[])}}function a(q,t,w,C){return function(D){return function(){var L=D.tp$descr_get?D.tp$descr_get(this):D;L=Sk.misceval.callsimArray(L,[]);if(!t(L))throw new Sk.builtin.TypeError(q+" should return "+w+" (returned "+Sk.abstr.typeName(L)+")");return void 0!==C?C(L):L}}}function c(q){return function(t){const w=
q.tp$descr_get?q.tp$descr_get(this):q;return Sk.misceval.callsimArray(w,[t])}}function m(q,t){let w=this.ob$type.$typeLookup(Sk.builtin.str.$getattribute);if(w instanceof Sk.builtin.wrapper_descriptor)return w.d$wrapped.call(this,q,t);w.tp$descr_get&&(w=w.tp$descr_get(this));const C=Sk.misceval.tryCatch(()=>Sk.misceval.callsimOrSuspendArray(w,[q]),D=>{if(!(D instanceof Sk.builtin.AttributeError))throw D;});return t?C:Sk.misceval.retryOptionalSuspensionOrThrow(C)}function n(q,t,w){return function(C){return function(D,
L,N){let A;void 0===L?(A=t,w=null):A=q;let H=this.ob$type.$typeLookup(new Sk.builtin.str(A));if(H instanceof Sk.builtin.wrapper_descriptor)return H.d$wrapped.call(this,D,L);H.tp$descr_get&&(H=H.tp$descr_get(this,this.ob$type,N));if(void 0!==H)D=Sk.misceval.callsimOrSuspendArray(H,void 0===L?[D]:[D,L]);else{if(w)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(this)+"' object "+w);throw new Sk.builtin.AttributeError(A);}return N?D:Sk.misceval.retryOptionalSuspensionOrThrow(D)}}}function d(q,t){let w=
q.ob$type;for(;w&&void 0!==w.sk$klass;)w=w.prototype.tp$base;if(w&&w.prototype.tp$setattr!==t)throw new Sk.builtin.TypeError("can't apply this "+t.$name+" to "+Sk.abstr.typeName(q)+" object");}Sk.slots=Object.create(null);E=Sk.slots;Sk.slots.__init__={$name:"__init__",$slot_name:"tp$init",$slot_func:function(q){return function(t,w){const C=q.tp$descr_get?q.tp$descr_get(this):q;t=Sk.misceval.callsimOrSuspendArray(C,t,w);return Sk.misceval.chain(t,D=>{if(!Sk.builtin.checkNone(D)&&void 0!==D)throw new Sk.builtin.TypeError("__init__() should return None, not "+
Sk.abstr.typeName(D));})}},$wrapper:function(q,t,w){this.call(q,t,w);return Sk.builtin.none.none$},$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Initialize self.  See help(type(self)) for accurate signature."};E.__new__={$name:"__new__",$slot_name:"tp$new",$slot_func:function(q){const t=function(w,C){let D=q;q.tp$descr_get&&(D=q.tp$descr_get(null,this.constructor));return Sk.misceval.callsimOrSuspendArray(D,[this.constructor,...w],C)};t.sk$static_new=!1;return t},$wrapper:null,
$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Create and return a new object."};E.__call__={$name:"__call__",$slot_name:"tp$call",$slot_func:function(q){return function(t,w){const C=q.tp$descr_get?q.tp$descr_get(this):q;return Sk.misceval.callsimOrSuspendArray(C,t,w)}},$wrapper:function(q,t,w){q=q.tp$call(t,w);return void 0===q?Sk.builtin.none.none$:q},$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Call self as a function."};E.__repr__={$name:"__repr__",$slot_name:"$r",
$slot_func:a("__repr__",Sk.builtin.checkString,"str"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return repr(self)."};E.__str__={$name:"__str__",$slot_name:"tp$str",$slot_func:a("__str__",Sk.builtin.checkString,"str"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return str(self)."};var l=a("__hash__",Sk.builtin.checkInt,"int",q=>"number"===typeof q.v?q.v:q.tp$hash());E.__hash__={$name:"__hash__",$slot_name:"tp$hash",$slot_func:function(q){return q===Sk.builtin.none.none$?
Sk.builtin.none.none$:l(q)},$wrapper:p(b,q=>new Sk.builtin.int_(q)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return hash(self)."};E.__getattribute__={$name:"__getattribute__",$slot_name:"tp$getattr",$slot_func:function(q){return function(t,w){let C=this.ob$type.$typeLookup(Sk.builtin.str.$getattr);if(void 0===C)return m.call(this,t,w);const D=Sk.misceval.chain(m.call(this,t,w),L=>Sk.misceval.tryCatch(()=>{if(void 0!==L)return L;C.tp$descr_get&&(C=C.tp$descr_get(this));return Sk.misceval.callsimOrSuspendArray(C,
[t])},function(N){if(!(N instanceof Sk.builtin.AttributeError))throw N;}));return w?D:Sk.misceval.retryOptionalSuspensionOrThrow(D)}},$wrapper:function(q,t,w){Sk.abstr.checkOneArg(this.$name,t,w);t=t[0];if(!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError("attribute name must be string, not '"+Sk.abstr.typeName(t)+"'");w=this.call(q,t);if(void 0===w)throw new Sk.builtin.AttributeError(Sk.abstr.typeName(q)+" has no attribute "+t.$jsstr());return w},$textsig:"($self, name, /)",$flags:{OneArg:!0},
$doc:"Return getattr(self, name)."};E.__getattr__={$name:"__getattr__",$slot_name:"tp$getattr",$slot_func:E.__getattribute__.$slot_func,$wrapper:null,$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Return getattr(self, name)."};E.__setattr__={$name:"__setattr__",$slot_name:"tp$setattr",$slot_func:n("__setattr__","__delattr__"),$wrapper:function(q,t,w){Sk.abstr.checkNoKwargs(this.$name,w);Sk.abstr.checkArgsLen(this.$name,t,2,2);d(q,this);this.call(q,t[0],t[1]);return Sk.builtin.none.none$},$textsig:"($self, name, value, /)",
$flags:{MinArgs:2,MaxArgs:2},$doc:"Implement setattr(self, name, value)."};E.__delattr__={$name:"__delattr__",$slot_name:"tp$setattr",$slot_func:E.__setattr__.$slot_func,$wrapper:function(q,t,w){Sk.abstr.checkOneArg(this.$name,t,w);d(q,this);this.call(q,t[0]);return Sk.builtin.none.none$},$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Implement delattr(self, name)."};E.__get__={$name:"__get__",$slot_name:"tp$descr_get",$slot_func:function(q){return function(t,w,C){null===t&&(t=Sk.builtin.none.none$);
null==w&&(w=Sk.builtin.none.none$);const D=q.tp$descr_get?q.tp$descr_get(this):q;t=Sk.misceval.callsimOrSuspendArray(D,[t,w]);return C?t:Sk.misceval.retryOptionalSuspensionOrThrow(t)}},$wrapper:function(q,t,w){Sk.abstr.checkNoKwargs(this.$name,w);Sk.abstr.checkArgsLen(this.$name,t,1,2);w=t[0];t=t[1];w===Sk.builtin.none.none$&&(w=null);t===Sk.builtin.none.none$&&(t=null);if(null===t&&null===w)throw new Sk.builtin.TypeError("__get__(None, None) is invalid");return this.call(q,w,t)},$textsig:"($self, instance, owner, /)",
$flags:{MinArgs:2,MaxArgs:2},$doc:"Return an attribute of instance, which is of type owner."};E.__set__={$name:"__set__",$slot_name:"tp$descr_set",$slot_func:n("__set__","__delete__"),$wrapper:g,$textsig:"($self, instance, value, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Set an attribute of instance to value."};E.__delete__={$name:"__delete__",$slot_name:"tp$descr_set",$slot_func:E.__set__.$slot_func,$wrapper:f,$textsig:"($self, instance, /)",$flags:{OneArg:!0},$doc:"Delete an attribute of instance."};
E.__eq__={$name:"__eq__",$slot_name:"ob$eq",$slot_func:c,$wrapper:k,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self==value."};E.__ge__={$name:"__ge__",$slot_name:"ob$ge",$slot_func:c,$wrapper:k,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>=value."};E.__gt__={$name:"__gt__",$slot_name:"ob$gt",$slot_func:c,$wrapper:k,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>value."};E.__le__={$name:"__le__",$slot_name:"ob$le",$slot_func:c,$wrapper:k,$textsig:"($self, value, /)",
$flags:{OneArg:!0},$doc:"Return self<=value."};E.__lt__={$name:"__lt__",$slot_name:"ob$lt",$slot_func:c,$wrapper:k,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<value."};E.__ne__={$name:"__ne__",$slot_name:"ob$ne",$slot_func:c,$wrapper:k,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self!=value."};E.__iter__={$name:"__iter__",$slot_name:"tp$iter",$slot_func:h,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Implement iter(self)."};E.__next__={$name:"__next__",
$slot_name:"tp$iternext",$slot_func:function(q){return function(t){const w=q.tp$descr_get?q.tp$descr_get(this):q,C=Sk.misceval.tryCatch(()=>Sk.misceval.callsimOrSuspendArray(w,[]),D=>{if(D instanceof Sk.builtin.StopIteration)this.gi$ret=D.$value;else throw D;});return t?C:Sk.misceval.retryOptionalSuspensionOrThrow(C)}},$wrapper:function(q,t,w){Sk.abstr.checkNoArgs(this.$name,t,w);return Sk.misceval.chain(q.tp$iternext(!0),C=>{if(void 0===C)throw new Sk.builtin.StopIteration;return C})},$textsig:"($self, /)",
$flags:{NoArgs:!0},$doc:"Implement next(self)."};E.__len__={$name:"__len__",$slot_name:"sq$length",$slot_func:function(q){return function(t){const w=q.tp$descr_get?q.tp$descr_get(this):q;if(t)return t=Sk.misceval.callsimOrSuspendArray(w,[]),Sk.misceval.chain(t,C=>Sk.misceval.asIndexOrThrow(C));t=Sk.misceval.callsimArray(w,[]);return Sk.misceval.asIndexOrThrow(t)}},$wrapper:p(b,q=>new Sk.builtin.int_(q)),$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return len(self)."};E.__contains__={$name:"__contains__",
$slot_name:"sq$contains",$slot_func:function(q){return function(t,w){const C=q.tp$descr_get?q.tp$descr_get(this):q;t=Sk.misceval.callsimOrSuspendArray(C,[t]);t=Sk.misceval.chain(t,D=>Sk.misceval.isTrue(D));return t.$isSuspension?w?t:Sk.misceval.retryOptionalSuspensionOrThrow(t):t}},$wrapper:p(f,q=>new Sk.builtin.bool(q)),$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Return key in self."};E.__getitem__={$name:"__getitem__",$slot_name:"mp$subscript",$slot_func:function(q){return function(t,w){const C=
q.tp$descr_get?q.tp$descr_get(this):q;t=Sk.misceval.callsimOrSuspendArray(C,[t]);return w?t:Sk.misceval.retryOptionalSuspensionOrThrow(t)}},$wrapper:f,$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Return self[key]."};E.__setitem__={$name:"__setitem__",$slot_name:"mp$ass_subscript",$slot_func:n("__setitem__","__delitem__","does not support item assignment"),$wrapper:g,$textsig:"($self, key, value, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Set self[key] to value."};E.__delitem__={$name:"__delitem__",
$slot_name:"mp$ass_subscript",$slot_func:E.__setitem__.$slot_func,$wrapper:f,$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Delete self[key]."};E.__add__={$name:"__add__",$slot_name:"nb$add",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self+value."};E.__radd__={$name:"__radd__",$slot_name:"nb$reflected_add",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value+self."};E.__iadd__={$name:"__iadd__",$slot_name:"nb$inplace_add",
$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self+=value."};E.__sub__={$name:"__sub__",$slot_name:"nb$subtract",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self-value."};E.__rsub__={$name:"__rsub__",$slot_name:"nb$reflected_subtract",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value-self."};E.__imul__={$name:"__imul__",$slot_name:"nb$inplace_multiply",$slot_func:c,$wrapper:f,
$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self*=value."};E.__mul__={$name:"__mul__",$slot_name:"nb$multiply",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self*value."};E.__rmul__={$name:"__rmul__",$slot_name:"nb$reflected_multiply",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value*self."};E.__isub__={$name:"__isub__",$slot_name:"nb$inplace_subtract",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",
$flags:{OneArg:!0},$doc:"Implement self-=value."};E.__mod__={$name:"__mod__",$slot_name:"nb$remainder",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self%value."};E.__rmod__={$name:"__rmod__",$slot_name:"nb$reflected_remainder",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value%self."};E.__imod__={$name:"__imod__",$slot_name:"nb$inplace_remainder",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},
$doc:"Implement value%=self."};E.__divmod__={$name:"__divmod__",$slot_name:"nb$divmod",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return divmod(self, value)."};E.__rdivmod__={$name:"__rdivmod__",$slot_name:"nb$reflected_divmod",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return divmod(value, self)"};E.__pos__={$name:"__pos__",$slot_name:"nb$positive",$slot_func:h,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"+self"};
E.__neg__={$name:"__neg__",$slot_name:"nb$negative",$slot_func:h,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"-self"};E.__abs__={$name:"__abs__",$slot_name:"nb$abs",$slot_func:h,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"abs(self)"};E.__bool__={$name:"__bool__",$slot_name:"nb$bool",$slot_func:a("__bool__",Sk.builtin.checkBool,"bool",q=>0!==q.v),$wrapper:p(b,q=>new Sk.builtin.bool(q)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"self != 0"};E.__invert__={$name:"__invert__",
$slot_name:"nb$invert",$slot_func:h,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"~self"};E.__lshift__={$name:"__lshift__",$slot_name:"nb$lshift",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<<value."};E.__rlshift__={$name:"__rlshift__",$slot_name:"nb$reflected_lshift",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value<<self."};E.__rshift__={$name:"__rshift__",$slot_name:"nb$rshift",$slot_func:c,$wrapper:f,
$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>>value."};E.__rrshift__={$name:"__rrshift__",$slot_name:"nb$reflected_rshift",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value>>self."};E.__ilshift__={$name:"__ilshift__",$slot_name:"nb$inplace_lshift",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self<<=value."};E.__irshift__={$name:"__irshift__",$slot_name:"nb$inplace_rshift",$slot_func:c,$wrapper:f,
$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self=>>value."};E.__and__={$name:"__and__",$slot_name:"nb$and",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self&value."};E.__rand__={$name:"__rand__",$slot_name:"nb$refelcted_and",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value&self."};E.__iand__={$name:"__iand__",$slot_name:"nb$and",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},
$doc:"Implement self&=value."};E.__xor__={$name:"__xor__",$slot_name:"nb$xor",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self^value."};E.__rxor__={$name:"__rxor__",$slot_name:"nb$reflected_xor",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value^self."};E.__ixor__={$name:"__ixor__",$slot_name:"nb$inplace_xor",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self^=value."};E.__or__=
{$name:"__or__",$slot_name:"nb$or",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self|value."};E.__ror__={$name:"__ror__",$slot_name:"nb$reflected_or",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value|self."};E.__ior__={$name:"__ior__",$slot_name:"nb$inplace_or",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self|=value."};E.__int__={$name:"__int__",$slot_name:"nb$int",$slot_func:a("__int__",
Sk.builtin.checkInt,"int"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"int(self)"};E.__float__={$name:"__float__",$slot_name:"nb$float",$slot_func:a("__float__",Sk.builtin.checkFloat,"float"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"float(self)"};E.__floordiv__={$name:"__floordiv__",$slot_name:"nb$floor_divide",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self//value."};E.__rfloordiv__={$name:"__rfloordiv__",$slot_name:"nb$reflected_floor_divide",
$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value//self."};E.__ifloordiv__={$name:"__ifloordiv__",$slot_name:"nb$inplace_floor_divide",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self//=value."};E.__truediv__={$name:"__truediv__",$slot_name:"nb$divide",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self/value."};E.__rtruediv__={$name:"__rtruediv__",$slot_name:"nb$reflected_divide",
$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value/self."};E.__itruediv__={$name:"__itruediv__",$slot_name:"nb$inplace_divide",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self/=value."};E.__index__={$name:"__index__",$slot_name:"nb$index",$slot_func:a("__index__",Sk.builtin.checkInt,"int",q=>q.v),$wrapper:p(b,q=>new Sk.builtin.int_(q)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return self converted to an integer, if self is suitable for use as an index into a list."};
E.__pow__={$name:"__pow__",$slot_name:"nb$power",$slot_func:function(q){return function(t,w){const C=q.tp$descr_get?q.tp$descr_get(this):q;return void 0==w?Sk.misceval.callsimArray(C,[t]):Sk.misceval.callsimArray(C,[t,w])}},$wrapper:e,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,MaxArgs:2},$doc:"Return pow(self, value, mod)."};E.__rpow__={$name:"__rpow__",$slot_name:"nb$reflected_power",$slot_func:E.__pow__.$slot_func,$wrapper:e,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,
MaxArgs:2},$doc:"Return pow(value, self, mod)."};E.__ipow__={$name:"__ipow__",$slot_name:"nb$inplace_power",$slot_func:E.__pow__.$slot_func,$wrapper:e,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,MaxArgs:2},$doc:"Implement **="};E.__matmul__={$name:"__matmul__",$slot_name:"nb$matrix_multiply",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self@value."};E.__rmatmul__={$name:"__rmatmul__",$slot_name:"nb$reflected_matrix_multiply",$slot_func:c,$wrapper:f,
$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value@self."};E.__imatmul__={$name:"__imatmul__",$slot_name:"nb$inplace_matrix_multiply",$slot_func:c,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self@=value."};E.__long__={$name:"__long__",$slot_name:"nb$long",$slot_func:a("__long__",Sk.builtin.checkInt,"int"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"int(self)"};var r,v={next:{$name:"next",$slot_name:"tp$iternext",$slot_func:E.__next__.$slot_func,
$wrapper:E.__next__.$wrapper,$textsig:E.__next__.$textsig,$flags:E.__next__.$flags},__nonzero__:{$name:"__nonzero__",$slot_name:"nb$bool",$slot_func:a("__nonzero__",Sk.builtin.checkInt,"int",q=>0!==q.v),$wrapper:p(b,q=>new Sk.builtin.bool(q)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"x.__nonzero__() <==> x != 0"},__div__:{$name:"__div__",$slot_name:"nb$divide",$slot_func:c,$wrapper:f,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"x.__div__(y) <==> x/y"},__rdiv__:{$name:"__rdiv__",$slot_name:"nb$reflected_divide",
$slot_func:c,$wrapper:f,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"x.__rdiv__(y) <==> x/y"},__idiv__:{$name:"__idiv__",$slot_name:"nb$inplace_divide",$slot_func:c,$wrapper:f,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"implement self /= other"}};Sk.subSlots={main_slots:Object.entries({tp$init:"__init__",tp$call:"__call__",$r:"__repr__",tp$str:"__str__",tp$getattr:"__getattribute__",tp$setattr:["__setattr__","__delattr__"],ob$eq:"__eq__",ob$ne:"__ne__",ob$lt:"__lt__",ob$le:"__le__",
ob$gt:"__gt__",ob$ge:"__ge__",tp$descr_get:"__get__",tp$descr_set:["__set__","__delete__"],tp$iter:"__iter__",tp$iternext:"__next__"}),number_slots:Object.entries({nb$abs:"__abs__",nb$negative:"__neg__",nb$positive:"__pos__",nb$int:"__int__",nb$long:"__long__",nb$float:"__float__",nb$add:"__add__",nb$reflected_add:"__radd__",nb$inplace_add:"__iadd__",nb$subtract:"__sub__",nb$reflected_subtract:"__rsub__",nb$inplace_subtract:"__isub__",nb$multiply:"__mul__",nb$reflected_multiply:"__rmul__",nb$inplace_multiply:"__imul__",
nb$floor_divide:"__floordiv__",nb$reflected_floor_divide:"__rfloordiv__",nb$inplace_floor_divide:"__ifloordiv__",nb$invert:"__invert__",nb$remainder:"__mod__",nb$reflected_remainder:"__rmod__",nb$inplace_remainder:"__imod__",nb$divmod:"__divmod__",nb$reflected_divmod:"__rdivmod__",nb$power:"__pow__",nb$reflected_power:"__rpow__",nb$inplace_power:"__ipow__",nb$divide:"__truediv__",nb$reflected_divide:"__rtruediv__",nb$inplace_divide:"__itruediv__",nb$bool:"__bool__",nb$and:"__and__",nb$reflected_and:"__rand__",
nb$inplace_and:"__iand__",nb$or:"__or__",nb$reflected_or:"__ror__",nb$inplace_or:"__ior__",nb$xor:"__xor__",nb$reflected_xor:"__rxor__",nb$inplace_xor:"__ixor__",nb$lshift:"__lshift__",nb$reflected_lshift:"__rlshift__",nb$rshift:"__rshift__",nb$reflected_rshift:"__rrshift__",nb$inplace_lshift:"__ilshift__",nb$inplace_rshift:"__irshift__",nb$matrix_multiply:"__matmul__",nb$reflected_matrix_multiply:"__rmatmul__",nb$inplace_matrix_multiply:"__imatmul__"}),sequence_and_mapping_slots:Object.entries({sq$length:"__len__",
sq$contains:"__contains__",mp$subscript:"__getitem__",mp$ass_subscript:["__setitem__","__delitem__"],nb$add:"__add__",nb$multiply:"__mul__",nb$reflected_multiply:"__rmul__",nb$inplace_add:"__iadd__",nb$inplace_multiply:"__imul__"})};Sk.reflectedNumberSlots={nb$add:{reflected:"nb$reflected_add"},nb$subtract:{reflected:"nb$reflected_subtract",slot:function(q){return q instanceof this.constructor?q.nb$subtract(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$multiply:{reflected:"nb$reflected_multiply"},
nb$divide:{reflected:"nb$reflected_divide",slot:function(q){return q instanceof this.constructor?q.nb$divide(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$floor_divide:{reflected:"nb$reflected_floor_divide",slot:function(q){return q instanceof this.constructor?q.nb$floor_divide(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$remainder:{reflected:"nb$reflected_remainder",slot:function(q){return q instanceof this.constructor?q.nb$remainder(this):Sk.builtin.NotImplemented.NotImplemented$}},
nb$divmod:{reflected:"nb$reflected_divmod",slot:function(q){return q instanceof this.constructor?q.nb$divmod(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$power:{reflected:"nb$reflected_power",slot:function(q,t){return q instanceof this.constructor?q.nb$power(this,t):Sk.builtin.NotImplemented.NotImplemented$}},nb$and:{reflected:"nb$reflected_and"},nb$or:{reflected:"nb$reflected_or"},nb$xor:{reflected:"nb$reflected_xor"},nb$lshift:{reflected:"nb$reflected_lshift",slot:function(q){return q instanceof
this.constructor?q.nb$lshift(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$rshift:{reflected:"nb$reflected_rshift",slot:function(q){return q instanceof this.constructor?q.nb$rshift(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$matrix_multiply:{reflected:"nb$reflexted_matrix_multiply",slot:function(q){return q instanceof this.constructor?q.nb$matrix_multiply(this):Sk.builtin.NotImplemented.NotImplemented$}}};Sk.sequenceAndMappingSlots={sq$concat:["nb$add"],sq$repeat:["nb$multiply","nb$reflected_multiply"],
mp$length:["sq$length"],sq$inplace_repeat:["nb$inplace_multiply"],sq$inplace_concat:["nb$inplace_add"]};Sk.dunderToSkulpt={__repr__:"$r",__str__:"tp$str",__init__:"tp$init",__new__:"tp$new",__hash__:"tp$hash",__call__:"tp$call",__iter__:"tp$iter",__next__:"tp$iternext",__eq__:"ob$eq",__ne__:"ob$ne",__lt__:"ob$lt",__le__:"ob$le",__gt__:"ob$gt",__ge__:"ob$ge",__abs__:"nb$abs",__neg__:"nb$negative",__pos__:"nb$positive",__int__:"nb$int",__float__:"nb$float",__add__:"nb$add",__radd__:"nb$reflected_add",
__iadd__:"nb$inplace_add",__sub__:"nb$subtract",__rsub__:"nb$reflected_subtract",__isub__:"nb$inplace_subtract",__mul__:"nb$multiply",__rmul__:"nb$reflected_multiply",__imul__:"nb$inplace_multiply",__truediv__:"nb$divide",__rtruediv__:"nb$reflected_divide",__itruediv__:"nb$inplace_divide",__floordiv__:"nb$floor_divide",__rfloordiv__:"nb$reflected_floor_divide",__ifloordiv__:"nb$inplace_floor_divide",__invert__:"nb$invert",__mod__:"nb$remainder",__rmod__:"nb$reflected_remainder",__imod__:"nb$inplace_remainder",
__divmod__:"nb$divmod",__rdivmod__:"nb$reflected_divmod",__pow__:"nb$power",__rpow__:"nb$reflected_power",__ipow__:"nb$inplace_power",__bool__:"nb$bool",__long__:"nb$long",__lshift__:"nb$lshift",__rlshift__:"nb$reflected_lshift",__ilshift__:"nb$inplace_lshift",__rshift__:"nb$rshift",__rrshift__:"nb$reflected_rshift",__irshift__:"nb$inplace_rshift",__and__:"nb$and",__rand__:"nb$reflected_and",__iand__:"nb$inplace_and",__or__:"nb$or",__ror__:"nb$reflected_or",__ior__:"nb$inplace_or",__xor__:"nb$xor",
__rxor__:"nb$reflected_xor",__ixor__:"nb$inplace_xor",__matmul__:"nb$matrix_multiply",__rmatmul__:"nb$reflected_matrix_multiply",__imatmul__:"nb$inplace_matrix_multiply",__get__:"tp$descr_get",__set__:"tp$descr_set",__delete__:"tp$descr_set",__getattribute__:"tp$getattr",__getattr__:"tp$getattr",__setattr__:"tp$setattr",__delattr__:"tp$setattr",__len__:"sq$length",__contains__:"sq$contains",__getitem__:"mp$subscript",__setitem__:"mp$ass_subscript",__delitem__:"mp$ass_subscript"};Sk.exportSymbol("Sk.setupDunderMethods",
Sk.setupDunderMethods);Sk.setupDunderMethods=function(q){function t(B,F,J){for(let P=0;P<B.length;P++){const W=B[P].prototype;W.hasOwnProperty(J)||(W[J]=W[F],delete W[F])}}var w=Sk.slots;if(!q||void 0!==r){var C=Sk.abstr.built$iterators,D=[Sk.builtin.int_,Sk.builtin.lng,Sk.builtin.float_,Sk.builtin.complex],L=Sk.subSlots.number_slots,N=Sk.subSlots.main_slots,A=N.findIndex(B=>"tp$iternext"===B[0]),H=L.findIndex(B=>"nb$bool"===B[0]),x=Sk.dunderToSkulpt;if(q){x.__bool__="nb$bool";x.__next__="tp$iternext";
delete x.__nonzero__;delete x.__div__;delete x.__rdiv__;delete x.__idiv__;delete x.next;for(let B in r)w[B]=r[B];for(let B in v)delete w[B];for(q=0;q<D.length;q++)w=D[q].prototype,delete w.__div__,delete w.__rdiv__;N[A][1]="__next__";L[H][1]="__bool__";t(C,"next","__next__");t(D,"__bool__","__nonzero__")}else{void 0===r&&(w.py3$slots={__next__:w.__next__},r=w.py3$slots);x.next="tp$iternext";x.__nonzero__="nb$bool";x.__div__="nb$divide";x.__rdiv__="nb$reflected_divide";x.__idiv__="nb$inplace_divide";
delete x.__bool__;delete x.__next__;for(let B in v)w[B]=v[B];for(let B in r)delete w[B];N[A][1]="next";L[H][1]="__nonzero__";t(C,"__next__","next");t(D,"__nonzero__","__bool__");for(C=0;C<D.length;C++)L=D[C],N=L.prototype,N.hasOwnProperty("__div__")||(N.__div__=new Sk.builtin.wrapper_descriptor(L,v.__div__,N.nb$divide),N.__rdiv__=new Sk.builtin.wrapper_descriptor(L,v.__rdiv__,Sk.reflectedNumberSlots.nb$divide.slot))}}}},function(E,Q){function b(p,h,a){return Sk.abstr.buildNativeClass(p,{constructor:a.constructor,
slots:Object.assign({tp$getattr:Sk.generic.getAttr,$r:g},a.slots),getsets:Object.assign(a.getsets||{},k),proto:Object.assign(a.proto||{},{d$repr_name:h||p,d$check:f,d$set_check:e}),flags:{sk$unacceptableBase:!0}})}function f(p){if(null==p)return this;if(!p.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(p)+"' object");}function e(p){if(!p.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+
this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(p)+"' object");}function g(){return new Sk.builtin.str("<"+this.d$repr_name+" '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects>")}const k={__doc__:{$get(){return this.d$def.$doc?new Sk.builtin.str(this.d$def.$doc):Sk.builtin.none.none$}},__objclass__:{$get(){return this.d$type}},__name__:{$get(){return new Sk.builtin.str(this.d$name)}}};E={__text_signature__:{$get(){return this.d$def.$textsig?
new Sk.builtin.str(this.d$def.$textsig):Sk.builtin.none.none$}}};Sk.builtin.getset_descriptor=b("getset_descriptor",void 0,{constructor:function(p,h){this.d$def=h;this.$get=h.$get;this.$set=h.$set;this.d$type=p;this.d$name=h.$name},slots:{tp$descr_get(p,h,a){if(h=this.d$check(p))return h;if(void 0!==this.$get)return p=this.$get.call(p),a?p:Sk.misceval.retryOptionalSuspensionOrThrow(p);throw new Sk.builtin.AttributeError("getset_descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects is not readable");
},tp$descr_set(p,h,a){this.d$set_check(p);if(void 0!==this.$set)return p=this.$set.call(p,h),a?p:Sk.misceval.retryOptionalSuspensionOrThrow(p);throw new Sk.builtin.AttributeError("attribute '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects is readonly");}}});Sk.builtin.method_descriptor=b("method_descriptor","method",{constructor:function(p,h){this.d$def=h;this.$meth=h.$meth;this.d$type=p;this.d$name=h.$name||"<native JS>";this.$flags=p=h.$flags||{};p.FastCall&&p.NoKwargs?this.tp$call=
this.$methodFastCallNoKwargs:p.FastCall?this.tp$call=this.$methodFastCall:p.NoArgs?this.tp$call=this.$methodCallNoArgs:p.OneArg?this.tp$call=this.$methodCallOneArg:p.NamedArgs?this.tp$call=this.$methodCallNamedArgs:void 0!==p.MinArgs?this.tp$call=this.$methodCallMinArgs:(this.func_code=h.$meth,this.tp$call=this.$defaultCall,this.$memoiseFlags=Sk.builtin.func.prototype.$memoiseFlags,this.$resolveArgs=Sk.builtin.func.prototype.$resolveArgs)},slots:{tp$call(p,h){return this.tp$call(p,h)},tp$descr_get(p,
h){let a;return(a=this.d$check(p))?a:new Sk.builtin.sk_method(this.d$def,p)}},getsets:E,proto:{$methodFastCall(p,h){const a=p.shift();this.m$checkself(a);return this.$meth.call(a,p,h)},$methodFastCallNoKwargs(p,h){const a=p.shift();this.m$checkself(a);Sk.abstr.checkNoKwargs(this.d$name,h);return this.$meth.call(a,p)},$methodCallNoArgs(p,h){const a=p.shift();this.m$checkself(a);Sk.abstr.checkNoArgs(this.d$name,p,h);return this.$meth.call(a)},$methodCallOneArg(p,h){const a=p.shift();this.m$checkself(a);
Sk.abstr.checkOneArg(this.d$name,p,h);return this.$meth.call(a,p[0])},$methodCallNamedArgs(p,h){const a=p.shift();this.m$checkself(a);p=Sk.abstr.copyKeywordsToNamedArgs(this.d$name,this.$flags.NamedArgs,p,h,this.$flags.Defaults);return this.$meth.call(a,...p)},$methodCallMinArgs(p,h){const a=p.shift();this.m$checkself(a);Sk.abstr.checkNoKwargs(this.d$name,h);Sk.abstr.checkArgsLen(this.d$name,p,this.$flags.MinArgs,this.$flags.MaxArgs);return this.$meth.call(a,...p)},$defaultCall(p,h){this.m$checkself(p[0]);
return Sk.builtin.func.prototype.tp$call.call(this,p,h)},m$checkself(p){if(void 0===p)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");this.d$check(p)}}});Sk.builtin.wrapper_descriptor=b("wrapper_descriptor","slot wrapper",{constructor:function(p,h,a){this.d$def=h;this.d$type=p;this.d$name=a.$name=h.$name;this.d$wrapped=a},slots:{tp$descr_get(p,h){let a;return(a=this.d$check(p))?a:new Sk.builtin.method_wrapper(this,p)},
tp$call(p,h){if(1>p.length)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");const a=p.shift();if(!a.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(a)+"'");return this.raw$call(a,p,h)}},proto:{raw$call(p,h,a){this.d$wrapped.$name=this.d$name;return this.d$def.$wrapper.call(this.d$wrapped,
p,h,a)}}});Sk.builtin.method_wrapper=b("method_wrapper",void 0,{constructor:function(p,h){this.m$descr=p;this.m$self=h;this.d$def=p.d$def;this.d$name=p.d$name;this.d$type=p.d$type},slots:{tp$call(p,h){return this.m$descr.raw$call(this.m$self,p,h)},tp$richcompare(p,h){if("Eq"!==h&&"NotEq"!==h||!(p instanceof Sk.builtin.method_wrapper))return Sk.builtin.NotImplemented.NotImplemented$;p=this.m$self===p.m$self&&this.m$descr===p.m$descr;return"Eq"===h?p:!p},$r(){return new Sk.builtin.str("<method-wrapper '"+
this.d$name+"' of "+Sk.abstr.typeName(this.m$self)+" object>")}},getsets:{__self__:{$get(){return this.m$self}}}});Sk.builtin.classmethod_descriptor=b("classmethod_descriptor","method",{constructor:function(p,h){this.d$def=h;this.$meth=h.$meth;this.d$type=p;this.d$name=h.$name||"<native JS>"},slots:{tp$call(p,h){if(1>p.length)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");const a=p.shift();return this.tp$descr_get(null,
a).tp$call(p,h)},tp$descr_get(p,h,a){if(void 0===h)if(null!==p)h=h||p.ob$type;else throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' for type '"+this.d$type.prototype.tp$name+"' needs an object or a type");if(!h.ob$type.$isSubType(Sk.builtin.type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' for type '"+this.d$type.prototype.tp$name+"' needs a type not a '"+Sk.abstr.typeName(h)+"' as arg 2");if(!h.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+
"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(h)+"' object");return new Sk.builtin.sk_method(this.d$def,h)}},getsets:E});[Sk.builtin.method_descriptor,Sk.builtin.getset_descriptor,Sk.builtin.wrapper_descriptor,Sk.builtin.method_wrapper,Sk.builtin.classmethod_descriptor].forEach(p=>{Sk.abstr.setUpSlots(p);Sk.abstr.setUpMethods(p);Sk.abstr.setUpGetSets(p)})},function(E,Q){Sk.builtin.sk_method=Sk.abstr.buildNativeClass("builtin_function_or_method",{constructor:function(b,
f,e){this.$meth=b.$meth.bind(f);this.$doc=b.$doc;this.$self=f||null;this.$module=e?new Sk.builtin.str(e):null;this.$name=b.$name||b.$meth.name||"<native JS>";this.m$def=b;this.$textsig=b.$textsig;this.$flags=b=b.$flags||{};b.FastCall&&b.NoKwargs?this.tp$call=this.$fastCallNoKwargs:b.FastCall?this.tp$call=this.$meth:b.NoArgs?this.tp$call=this.$callNoArgs:b.OneArg?this.tp$call=this.$callOneArg:b.NamedArgs?this.tp$call=this.$callNamedArgs:void 0!==b.MinArgs?this.tp$call=this.$callMinArgs:(this.func_code=
this.$meth,this.tp$call=this.$defaultCallMethod)},proto:{$fastCallNoKwargs(b,f){Sk.abstr.checkNoKwargs(this.$name,f);return this.$meth(b)},$callNoArgs(b,f){Sk.abstr.checkNoArgs(this.$name,b,f);return this.$meth()},$callOneArg(b,f){Sk.abstr.checkOneArg(this.$name,b,f);return this.$meth(b[0])},$callNamedArgs(b,f){b=Sk.abstr.copyKeywordsToNamedArgs(this.$name,this.$flags.NamedArgs,b,f,this.$flags.Defaults);return this.$meth(...b)},$callMinArgs(b,f){Sk.abstr.checkNoKwargs(this.$name,f);Sk.abstr.checkArgsLen(this.$name,
b,this.$flags.MinArgs,this.$flags.MaxArgs);return this.$meth(...b)},$defaultCallMethod(b,f){return null!==this.$self?Sk.builtin.func.prototype.tp$call.call(this,[this.$self,...b],f):Sk.builtin.func.prototype.tp$call.call(this,b,f)},$memoiseFlags(){return Sk.builtin.func.prototype.$memoiseFlags.call(this)},$resolveArgs(){return Sk.builtin.func.prototype.$resolveArgs.call(this)}},flags:{sk$unacceptableBase:!0},slots:{tp$getattr:Sk.generic.getAttr,$r(){return null===this.$self?new Sk.builtin.str("<built-in function "+
this.$name+">"):new Sk.builtin.str("<built-in method "+this.$name+" of "+Sk.abstr.typeName(this.$self)+" object>")},tp$call(b,f){return this.tp$call(b,f)},tp$richcompare(b,f){if("Eq"!==f&&"NotEq"!==f||!(b instanceof Sk.builtin.sk_method))return Sk.builtin.NotImplemented.NotImplemented$;b=this.$self===b.$self&&this.m$def.$meth===b.m$def.$meth;return"Eq"===f?b:!b}},getsets:{__module__:{$get(){return this.$module||Sk.builtin.none.none$},$set(b){this.$module=b=b||Sk.builtin.none.none$}},__doc__:{$get(){return this.$doc?
new Sk.builtin.str(this.$doc):Sk.builtin.none.none$}},__name__:{$get(){return new Sk.builtin.str(this.$name)}},__text_signature__:{$get(){return new Sk.builtin.str(this.$textsig)}},__self__:{$get(){return this.$self||Sk.sysModules.mp$lookup(this.$module)||Sk.builtin.none.none$}}}})},function(E,Q){Sk.builtin.none=Sk.abstr.buildNativeClass("NoneType",{constructor:function(){return Sk.builtin.none.none$},slots:{tp$new(b,f){Sk.abstr.checkNoArgs("NoneType",b,f);return Sk.builtin.none.none$},$r(){return new Sk.builtin.str("None")},
tp$as_number:!0,nb$bool(){return!1}},proto:{valueOf(){return null}},flags:{sk$unacceptableBase:!0}});Sk.builtin.none.none$=Object.create(Sk.builtin.none.prototype,{v:{value:null,enumerable:!0}});Sk.builtin.NotImplemented=Sk.abstr.buildNativeClass("NotImplementedType",{constructor:function(){return Sk.builtin.NotImplemented.NotImplemented$},slots:{$r(){return new Sk.builtin.str("NotImplemented")},tp$new(b,f){Sk.abstr.checkNoArgs("NotImplementedType",b,f);return Sk.builtin.NotImplemented.NotImplemented$}},
flags:{sk$unacceptableBase:!0}});Sk.builtin.NotImplemented.NotImplemented$=Object.create(Sk.builtin.NotImplemented.prototype,{v:{value:null,enumerable:!0}});E=Sk.abstr.buildNativeClass("ellipsis",{constructor:function(){return Sk.builtin.Ellipsis},slots:{tp$new(b,f){Sk.abstr.checkNoArgs("ellipsis",b,f);return Sk.builtin.Ellipsis},$r(){return new Sk.builtin.str("Ellipsis")}},flags:{sk$unacceptableBase:!0}});Sk.builtin.Ellipsis=Object.create(E.prototype,{v:{value:"..."}})},function(E,Q){const b=/^(?:(.)?([<>=\^]))?([\+\-\s])?(#)?(0)?(\d+)?(,|_)?(?:\.(\d+))?([bcdeEfFgGnosxX%])?$/;
Sk.formatting={};let f=function(a,c,m,n){Sk.asserts.assert("string"===typeof c);if(a[6]){var d=parseInt(a[6],10);n=a[2]||(a[5]?"=":n?">":"<");let l=d-(c.length+(m?m.length:0));if(0>=l)return m+c;d=(a[1]||(a[5]?"0":" ")).repeat(l);switch(n){case "=":if("s"===a[9])throw new Sk.builtin.ValueError("'=' alignment not allowed in string format specifier");return m+d+c;case ">":return d+m+c;case "<":return m+c+d;case "^":return a=Math.floor(l/2),d.substring(0,a)+m+c+d.substring(a)}}return m+c},e=function(a,
c){return c?"-":"+"===a[3]?"+":" "===a[3]?" ":""};const g=/\B(?=(\d{3})+(?!\d))/g,k=/\B(?=([A-Za-z0-9]{4})+(?![A-Za-z0-9]))/g;let p=function(a,c,m){Sk.asserts.assert(c instanceof Sk.builtin.int_||c instanceof Sk.builtin.lng);if(a[8])throw new Sk.builtin.ValueError("Precision not allowed in integer format");var n=c.str$(m,!1);c=c.nb$isnegative();c=e(a,c);a[4]&&(16===m?c+="0x":8===m?c+="0o":2===m&&(c+="0b"));const d=a[9];"X"===d&&(n=n.toUpperCase());if("n"===a[9])n=(+n).toLocaleString();else if(a[7]){n=
n.split(".");const l=a[7];if(","===l&&10!==m)throw new Sk.builtin.ValueError(`Cannot specify ',' with '${d}'`);n[0]=n[0].replace(10===m?g:k,l);n=n.join(".")}return f(a,n,c,!0)},h=function(a,c,m){if(!c)return a.str$(10,!0);c=c.match(b);if(!c)throw new Sk.builtin.ValueError("Invalid format specifier");var n=c[9];n||(n=m?"g":"d");if(-1==(m?"fFeEgG%":"bcdoxXnfFeEgG%").indexOf(n))throw new Sk.builtin.ValueError("Unknown format code '"+c[9]+"' for object of type '"+Sk.abstr.typeName(a)+"'");switch(n){case "d":case "n":return p(c,
a,10);case "x":case "X":return p(c,a,16);case "o":return p(c,a,8);case "b":return p(c,a,2);case "c":if(c[3])throw new Sk.builtin.ValueError("Sign not allowed with integer format specifier 'c'");if(c[4])throw new Sk.builtin.ValueError("Alternate form not allowed with integer format specifier 'c'");if(c[7])throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");if(c[8])throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");return f(c,String.fromCodePoint(Sk.builtin.asnum$(a)),"",!0);
case "f":case "F":case "e":case "E":case "g":case "G":{if(c[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed in float format specifier");m=Sk.builtin.asnum$(a);"string"===typeof m&&(m=Number(m));if(Infinity===m)return f(c,"inf","",!0);if(-Infinity===m)return f(c,"inf","-",!0);if(isNaN(m))return f(c,"nan","",!0);a=!1;0>m&&(m=-m,a=!0);var d=["toExponential","toFixed","toPrecision"]["efg".indexOf(n.toLowerCase())];let l=c[8]?parseInt(c[8],10):6;m=m[d](l);-1!=="EFG".indexOf(n)&&(m=m.toUpperCase());
if("g"===n.toLowerCase()||!c[9]){if(d=m.match(/\.(\d*[1-9])?(0+)$/)){let [,r,v]=d;m=m.slice(0,r?-v.length:-(v.length+1))}-1!=m.indexOf(".")||c[9]||(m+=".0")}"e"===n.toLowerCase()&&(m=m.replace(/^([-+]?[0-9]*\.?[0-9]+[eE][-+]?)([0-9])?$/,"$10$2"));c[7]&&(n=m.toString().split("."),n[0]=n[0].replace(/\B(?=(\d{3})+(?!\d))/g,","),m=n.join("."));return f(c,m,e(c,a),!0)}case "%":if(c[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed with format specifier '%'");a=Sk.builtin.asnum$(a);"string"===
typeof a&&(a=Number(a));if(Infinity===a)return f(c,"inf%","",!0);if(-Infinity===a)return f(c,"inf%","-",!0);if(isNaN(a))return f(c,"nan%","",!0);n=!1;0>a&&(a=-a,n=!0);m=c[8]?parseInt(c[8],10):6;a=(100*a).toFixed(m)+"%";return f(c,a,e(c,n),!0);default:throw new Sk.builtin.ValueError("Unknown format code '"+c[9]+"'");}};Sk.formatting.mkNumber__format__=a=>function(c){if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError("format() argument 2 must be str, not "+Sk.abstr.typeName(c));return new Sk.builtin.str(h(this,
c.$jsstr(),a))};Sk.formatting.format=function(a,c){c=c||[];const m={};for(let d=0;d<c.length;d+=2)m[c[d]]=c[d+1];for(let d in a)m[d]=a[d];let n=0;a=this.v.replace(/{(((?:\d+)|(?:\w+))?((?:\.(\w+))|(?:\[((?:\d+)|(?:\w+))\])?))?(?:!([rs]))?(?::([^}]*))?}/g,function(d,l,r,v,q,t,w,C,D,L){let N;if(void 0!==t&&""!==t)d=m[r],N=d.constructor===Array?d[t]:/^\d+$/.test(t)?Sk.abstr.objectGetItem(d,new Sk.builtin.int_(parseInt(t,10)),!1):Sk.abstr.objectGetItem(d,new Sk.builtin.str(t),!1),n++;else if(void 0!==
q&&""!==q)N=Sk.abstr.gattr(m[r||n++],new Sk.builtin.str(q));else if(void 0!==r&&""!==r)N=m[r];else if(void 0===l||""===l)N=m[n],n++;else if(l instanceof Sk.builtin.int_||l instanceof Sk.builtin.float_||l instanceof Sk.builtin.lng||/^\d+$/.test(l))N=m[l],n++;if("s"===w)N=new Sk.builtin.str(N);else if("r"===w)N=Sk.builtin.repr(N);else if(""!==w&&void 0!==w)throw new Sk.builtin.ValueError("Unknown conversion specifier "+w);return Sk.abstr.objectFormat(N,new Sk.builtin.str(C)).$jsstr()});return new Sk.builtin.str(a)};
Sk.formatting.formatString=function(a){if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("format() argument 2 must be str, not "+Sk.abstr.typeName(a));a=a.$jsstr().match(b);if(a[9]&&"s"!==a[9])throw new Sk.builtin.ValueError("Unknown format code '"+a[9]+"' for object of type 'str'");if(a[3])throw new Sk.builtin.ValueError("Sign not allowed in string format specifier");if(a[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed with string format specifier");if(a[7])throw new Sk.builtin.ValueError("Cannot specify ',' with 's'");
let c=this.v;a[8]&&(c=c.substring(0,a[8]));return new Sk.builtin.str(f(a,c,"",!1))}},function(E,Q){function b(q){let t;const w=[];for(let C=0;C<q.length;C++)t=q.charAt(C),n.test(t)?w.push(t):"\\000"===t?w.push("\\000"):w.push("\\"+t);return w.join("")}function f(q,t,w){t=Sk.builtin.checkNone(t)?null:q.get$tgt(t);if(null!==t&&!t.length)throw new Sk.builtin.ValueError("empty separator");q=q.v;var C=0;if(null===t){var D=/[\s\xa0]+/g;C=q.length;q=q.replace(l,"");C-=q.length}else D=t.replace(d,"\\$1"),
D=new RegExp(D,"g");const L=[];let N=0,A=0,H;for(w=0>w?Infinity:w;null!=(H=D.exec(q))&&A<w&&H.index!==D.lastIndex;)L.push(N+C),L.push(H.index+C),N=D.lastIndex,A+=1;if(null!==t||q.length-N)L.push(N+C),L.push(q.length+C);return L}function e(q,t){return function(w){if(void 0===w||Sk.builtin.checkNone(w))w=q;else if(w instanceof Sk.builtin.str)w=b(w.v),w=new RegExp(t(w),"g");else throw new Sk.builtin.TypeError("strip arg must be None or str");return new Sk.builtin.str(this.v.replace(w,""))}}function g(q){return function(t){t=
this.get$tgt(t);const w=this.v;let C;if(q){if(C=w.lastIndexOf(t),0>C)return new Sk.builtin.tuple([new Sk.builtin.str(""),new Sk.builtin.str(""),new Sk.builtin.str(w)])}else if(C=w.indexOf(t),0>C)return new Sk.builtin.tuple([new Sk.builtin.str(w),new Sk.builtin.str(""),new Sk.builtin.str("")]);return new Sk.builtin.tuple([new Sk.builtin.str(w.substring(0,C)),new Sk.builtin.str(t),new Sk.builtin.str(w.substring(C+t.length))])}}function k(q,t){return function(w,C){w=Sk.misceval.asIndexSized(w,Sk.builtin.OverflowError);
if(void 0===C)C=" ";else if(C instanceof Sk.builtin.str&&1===C.sq$length())C=C.v;else throw new Sk.builtin.TypeError("the fill character must be a str of length 1");var D=this.sq$length();if(D>=w)return new Sk.builtin.str(this.v);if(t)return D=w-D,w=Math.floor(D/2)+(D&w&1),C=C.repeat(w)+this.v+C.repeat(D-w),new Sk.builtin.str(C);C=C.repeat(w-D);return new Sk.builtin.str(q?C+this.v:this.v+C)}}function p(q,t,w){({start:t,end:w}=Sk.builtin.slice.startEnd$wrt(q,t,w));if(q.$hasAstralCodePoints()){const C=
q.codepoints[t];t=void 0===C?t+q.v.length-q.codepoints.length:C;w=q.codepoints[w];w=void 0===w?q.v.length:w}return{start:t,end:w}}function h(q){return function(t,w,C){t=this.get$tgt(t);({start:w,end:C}=p(this,w,C));if(C<w)return-1;C-=t.length;t=q?this.v.lastIndexOf(t,C):this.v.indexOf(t,w);t=t>=w&&t<=C?t:-1;if(this.codepoints){C=this.sq$length();w=-1;for(let D=0;D<C;D++)t==this.codepoints[D]&&(w=D)}else w=t;return w}}function a(q,t){return function(w,C,D){if(!(w instanceof Sk.builtin.str||w instanceof
Sk.builtin.tuple))throw new Sk.builtin.TypeError(q+" first arg must be str or a tuple of str, not "+Sk.abstr.typeName(w));({start:C,end:D}=p(this,C,D));if(C>D)return Sk.builtin.bool.false$;C=this.v.slice(C,D);if(w instanceof Sk.builtin.tuple){for(let L=Sk.abstr.iter(w),N=L.tp$iternext();void 0!==N;N=L.tp$iternext()){if(!(N instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("tuple for "+q+" must only contain str, not "+Sk.abstr.typeName(N));if(t(C,N.v))return Sk.builtin.bool.true$}return Sk.builtin.bool.false$}return new Sk.builtin.bool(t(C,
w.v))}}var c=/^[0-9!#_]/,m=Object.create(null);Sk.builtin.str=Sk.abstr.buildNativeClass("str",{constructor:function(q){Sk.asserts.assert(this instanceof Sk.builtin.str,"bad call to str - use 'new'");if("string"!==typeof q)if(void 0===q)q="";else if(null===q)q="None";else{if(void 0!==q.tp$str)return q.tp$str();if("number"===typeof q)q=Number.isFinite(q)?String(q):String(q).replace("Infinity","inf").replace("NaN","nan");else throw new Sk.builtin.TypeError("could not convert object of type '"+Sk.abstr.typeName(q)+
"' to str");}var t=m[q];if(void 0!==t)return t;m[q]=this;t=void 0===v[q]?q:q+"_$rw$";this.$mangled=t;this.$savedKeyHash=q.replace(c,"!$&");this.v=q},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
tp$new(q,t){t=t||[];if(this!==Sk.builtin.str.prototype)return this.$subtype_new(q,t);if(1>=q.length&&!t.length)return new Sk.builtin.str(q[0]);if(Sk.__future__.python3){const [w,C,D]=Sk.abstr.copyKeywordsToNamedArgs("str",["object","encoding","errors"],q,t);if(void 0===w||void 0===C&&void 0===D)return new Sk.builtin.str(w);Sk.builtin.bytes.check$encodeArgs("str",C,D);if(!Sk.builtin.checkBytes(w))throw new Sk.builtin.TypeError("decoding to str: need a bytes-like object, "+Sk.abstr.typeName(w)+" found");
return Sk.builtin.bytes.$decode.call(w,C,D)}throw new Sk.builtin.TypeError("str takes at most one argument ("+(q.length+t.length)+" given)");},$r(){let q="'";-1!==this.v.indexOf("'")&&-1===this.v.indexOf('"')&&(q='"');const t=this.v.length;let w=q;for(let L=0;L<t;L++){var C=this.v.charAt(L);var D=this.v.charCodeAt(L);C===q||"\\"===C?w+="\\"+C:"\t"===C?w+="\\t":"\n"===C?w+="\\n":"\r"===C?w+="\\r":(255<D&&55296>D||57344<=D)&&!Sk.__future__.python3?w+="\\u"+("000"+D.toString(16)).slice(-4):55296<=D&&
!Sk.__future__.python3?(C=this.v.codePointAt(L),L++,C=C.toString(16),D="0000000"+C.toString(16),w=4<C.length?w+("\\U"+D.slice(-8)):w+("\\u"+D.slice(-4))):255<D&&!Sk.__future__.python3?w+="\\ufffd":" ">C||127<=D&&!Sk.__future__.python3?(C=C.charCodeAt(0).toString(16),2>C.length&&(C="0"+C),w+="\\x"+C):w+=C}return new Sk.builtin.str(w+q)},tp$str(){return this.constructor===Sk.builtin.str?this:new Sk.builtin.str(this.v)},tp$iter(){return new r(this)},tp$richcompare(q,t){if(!(q instanceof Sk.builtin.str))return Sk.builtin.NotImplemented.NotImplemented$;
switch(t){case "Lt":return this.v<q.v;case "LtE":return this.v<=q.v;case "Eq":return this.v===q.v;case "NotEq":return this.v!==q.v;case "Gt":return this.v>q.v;case "GtE":return this.v>=q.v}},mp$subscript(q){let t;if(Sk.misceval.isIndex(q)){q=Sk.misceval.asIndexSized(q,Sk.builtin.OverflowError);t=this.sq$length();0>q&&(q+=t);if(0>q||q>=t)throw new Sk.builtin.IndexError("string index out of range");return this.codepoints?new Sk.builtin.str(this.v.substring(this.codepoints[q],this.codepoints[q+1])):
new Sk.builtin.str(this.v.charAt(q))}if(q instanceof Sk.builtin.slice){let w="";t=this.sq$length();this.codepoints?q.sssiter$(t,C=>{w+=this.v.substring(this.codepoints[C],this.codepoints[C+1])}):q.sssiter$(t,C=>{w+=this.v.charAt(C)});return new Sk.builtin.str(w)}throw new Sk.builtin.TypeError("string indices must be integers, not "+Sk.abstr.typeName(q));},sq$length(){return this.$hasAstralCodePoints()?this.codepoints.length:this.v.length},sq$concat(q){if(!(q instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("cannot concatenate 'str' and '"+
Sk.abstr.typeName(q)+"' objects");return new Sk.builtin.str(this.v+q.v)},sq$repeat(q){if(!Sk.misceval.isIndex(q))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(q)+"'");q=Sk.misceval.asIndexSized(q,Sk.builtin.OverflowError);if(q*this.v.length>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;let t="";for(let w=0;w<q;w++)t+=this.v;return new Sk.builtin.str(t)},sq$contains(q){if(!(q instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("'in <string>' requires string as left operand not "+
Sk.abstr.typeName(q));return-1!==this.v.indexOf(q.v)},tp$as_number:!0,nb$remainder:function(q){var t;const w=this.sk$builtinBase;q.constructor===Sk.builtin.tuple||q instanceof Sk.builtin.dict||q instanceof Sk.builtin.mappingproxy||(q=new Sk.builtin.tuple([q]));var C=0;var D=this.$jsstr().replace(/%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrsb%])/g,function(L,N,A,H,x,B,F){var J,P,W,ca,ha;H=Sk.builtin.asnum$(H);x=Sk.builtin.asnum$(x);void 0!==N&&""!==N||"%"==F||
(J=C++);""===x&&(x=void 0);var oa=P=W=ca=ha=!1;A&&(-1!==A.indexOf("-")?ca=!0:-1!==A.indexOf("0")&&(ha=!0),-1!==A.indexOf("+")?P=!0:-1!==A.indexOf(" ")&&(W=!0),oa=-1!==A.indexOf("#"));x&&(x=parseInt(x.substr(1),10));A=function(ia,ba){var ja;ba=Sk.builtin.asnum$(ba);var na=!1;if("number"===typeof ia){0>ia&&(ia=-ia,na=!0);var fa=ia.toString(ba)}else ia instanceof Sk.builtin.float_?(fa=ia.str$(ba,!1),2<fa.length&&".0"===fa.substr(-2)&&(fa=fa.substr(0,fa.length-2)),na=ia.nb$isnegative()):ia instanceof
Sk.builtin.int_?(fa=ia.str$(ba,!1),na=ia.nb$isnegative()):ia instanceof Sk.builtin.lng&&(fa=ia.str$(ba,!1),na=ia.nb$isnegative());Sk.asserts.assert(void 0!==fa,"unhandled number format");ia=!1;if(x)for(ja=fa.length;ja<x;++ja)fa="0"+fa,ia=!0;ja="";na?ja="-":P?ja="+"+ja:W&&(ja=" "+ja);oa&&(16===ba?ja+="0x":8!==ba||ia||"0"===fa||(ja+="0"));return[ja,fa]};L=function(ia){var ba=ia[0];ia=ia[1];if(H){H=parseInt(H,10);var ja=ia.length+ba.length;if(ha)for(;ja<H;++ja)ia="0"+ia;else if(ca){for(;ja<H;++ja)ia+=
" ";Sk.__future__.python3&&(ia+=ba,ba="")}else for(;ja<H;++ja)ba=" "+ba}return ba+ia};if(q.constructor===Sk.builtin.tuple)N=q.v[J];else if(void 0!==q.mp$subscript&&void 0!==N)N=N.substring(1,N.length-1),N=q.mp$subscript(new w(N));else if(q.constructor===Sk.builtin.dict||q.constructor===Sk.builtin.list)N=q;else throw new Sk.builtin.AttributeError(q.tp$name+" instance has no attribute 'mp$subscript'");if("d"===F||"i"===F){var ka=A(N,10);if(void 0===ka[1])throw new Sk.builtin.TypeError("%"+F+" format: a number is required, not "+
Sk.abstr.typeName(N));F=ka[1];ka[1]=-1!==F.indexOf(".")?parseInt(F,10).toString():F;return L(ka)}if("o"===F)return L(A(N,8));if("x"===F)return L(A(N,16));if("X"===F)return L(A(N,16)).toUpperCase();if("f"===F||"F"===F||"e"===F||"E"===F||"g"===F||"G"===F){ka=Sk.builtin.asnum$(N);"string"===typeof ka&&(ka=Number(ka));if(Infinity===ka)return"inf";if(-Infinity===ka)return"-inf";if(isNaN(ka))return"nan";J=["toExponential","toFixed","toPrecision"]["efg".indexOf(F.toLowerCase())];if(void 0===x||""===x)if("e"===
F||"E"===F)x=6;else if("f"===F||"F"===F)x=Sk.__future__.python3?6:7;J=ka[J](x);Sk.builtin.checkFloat(N)&&0===ka&&-Infinity===1/ka&&(J="-"+J);Sk.__future__.python3&&(7<=J.length&&"0.0000"==J.slice(0,6)&&(t=parseFloat(J),J=t.toExponential()),"-"==J.charAt(J.length-2)&&(J=J.slice(0,J.length-1)+"0"+J.charAt(J.length-1)));-1!=="EFG".indexOf(F)&&(J=J.toUpperCase());return L(["",J])}if("c"===F){if("number"===typeof N)return String.fromCharCode(N);if(N instanceof Sk.builtin.int_||N instanceof Sk.builtin.float_)return String.fromCharCode(N.v);
if(N instanceof Sk.builtin.lng)return String.fromCharCode(N.str$(10,!1)[0]);if(N.constructor===Sk.builtin.str)return N.v.substr(0,1);throw new Sk.builtin.TypeError("an integer is required");}if("r"===F)return F=Sk.builtin.repr(N),x?F.v.substr(0,x):F.v;if("s"===F&&w===Sk.builtin.str){F=new Sk.builtin.str(N);F=F.$jsstr();if(x)return F.substr(0,x);H&&(F=L([" ",F]));return F}if("b"===F||"s"===F){if(w===Sk.builtin.str)throw new Sk.builtin.ValueError("unsupported format character 'b'");if(!(N instanceof
Sk.builtin.bytes)&&void 0===(ka=Sk.abstr.lookupSpecial(N,Sk.builtin.str.$bytes)))throw new Sk.builtin.TypeError("%b requires a bytes-like object, or an object that implements __bytes__, not '"+Sk.abstr.typeName(N)+"'");void 0!==ka&&(N=new Sk.builtin.bytes(N));F=N.$jsstr();if(x)return F.substr(0,x);H&&(F=L([" ",F]));return F}if("%"===F)return"%"});if(q instanceof Sk.builtin.tuple&&C<q.sq$length())throw new Sk.builtin.TypeError("not all arguments converted during string formatting");return new w(D)}},
proto:{toString(){return this.v},$subtype_new(q,t){const w=new this.constructor;q=Sk.builtin.str.prototype.tp$new(q,t);w.$mangled=q.$mangled;w.$savedKeyHash=q.$savedKeyHash;w.v=q.v;return w},$jsstr(){return this.v},$hasAstralCodePoints(){if(null===this.codepoints)return!1;if(void 0!==this.codepoints)return!0;for(var q=0;q<this.v.length;q++){let t=this.v.charCodeAt(q);if(55296<=t&&57344>t){this.codepoints=[];for(q=0;q<this.v.length;q++)this.codepoints.push(q),t=this.v.charCodeAt(q),55296<=t&&56320>
t&&q++;return!0}}this.codepoints=null;return!1},sk$asarray(){const q=[];if(this.$hasAstralCodePoints()){var t=this.codepoints;for(let w=0;w<t.length;w++)q.push(new Sk.builtin.str(this.v.substring(t[w],t[w+1])))}else for(t=0;t<this.v.length;t++)q.push(new Sk.builtin.str(this.v[t]));return q},find$left:h(!1),find$right:h(!0),get$tgt(q){if(q instanceof Sk.builtin.str)return q.v;throw new Sk.builtin.TypeError("a str instance is required not '"+Sk.abstr.typeName(q)+"'");},valueOf(){return this.v},$isIdentifier(){return Sk.token.isIdentifier(this.v)}},
methods:{encode:{$meth:function(q,t){({encoding:q,errors:t}=Sk.builtin.bytes.check$encodeArgs("encode",q,t));q=Sk.builtin.bytes.str$encode(this,q,t);return Sk.__future__.python3?q:new Sk.builtin.str(q.$jsstr())},$flags:{NamedArgs:["encoding","errors"]},$textsig:"($self, /, encoding='utf-8', errors='strict')",$doc:"Encode the string using the codec registered for encoding.\n\n  encoding\n    The encoding in which to encode the string.\n  errors\n    The error handling scheme to use for encoding errors.\n    The default is 'strict' meaning that encoding errors raise a\n    UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n    'xmlcharrefreplace' as well as any other name registered with\n    codecs.register_error that can handle UnicodeEncodeErrors."},
replace:{$meth(q,t,w){q=this.get$tgt(q);t=this.get$tgt(t);w=void 0===w?-1:Sk.misceval.asIndexSized(w,Sk.builtin.OverflowError);q=new RegExp(b(q),"g");if(0>w)return new Sk.builtin.str(this.v.replace(q,t));let C=0;q=this.v.replace(q,D=>C++<w?t:D);return new Sk.builtin.str(q)},$flags:{MinArgs:2,MaxArgs:3},$textsig:"($self, old, new, count=-1, /)",$doc:"Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."},
split:{$meth:function(q,t){t=Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError);q=f(this,q,t);t=[];for(let w=0;w<q.length;w++)t.push(new Sk.builtin.str(this.v.substring(q[w],q[++w])));return new Sk.builtin.list(t)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."},
rsplit:{$meth:function(q,t){t=Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError);q=f(this,q,-1);var w=0>t?0:2*(q.length/2-t);t=[];for(0>=w?w=0:t.push(new Sk.builtin.str(this.v.slice(0,q[w-1])));w<q.length;w++)t.push(new Sk.builtin.str(this.v.substring(q[w],q[++w])));return new Sk.builtin.list(t)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplits are done starting at the end of the string and working to the front."},
join:{$meth(q){const t=[];return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(q),w=>{if(!(w instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("sequence item "+t.length+": expected str, "+Sk.abstr.typeName(w)+" found");t.push(w.v)}),()=>new Sk.builtin.str(t.join(this.v)))},$flags:{OneArg:!0},$textsig:"($self, iterable, /)",$doc:"Concatenate any number of strings.\n\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\n\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'"},
capitalize:{$meth:function(){return new Sk.builtin.str(this.v.charAt(0).toUpperCase()+this.v.slice(1).toLowerCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a capitalized version of the string.\n\nMore specifically, make the first character have upper case and the rest lower\ncase."},title:{$meth:function(){const q=this.v.replace(/[a-z][a-z]*/gi,t=>t[0].toUpperCase()+t.substr(1).toLowerCase());return new Sk.builtin.str(q)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a version of the string where each word is titlecased.\n\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case."},
center:{$meth:k(!1,!0),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a centered string of length width.\n\nPadding is done using the specified fill character (default is a space)."},count:{$meth:function(q,t,w){q=this.get$tgt(q);({start:t,end:w}=p(this,t,w));if(w<t)return new Sk.builtin.int_(0);q=q.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");q=new RegExp(q,"g");return(t=this.v.slice(t,w).match(q))?new Sk.builtin.int_(t.length):new Sk.builtin.int_(0)},$flags:{MinArgs:1,
MaxArgs:3},$textsig:null,$doc:"S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation."},expandtabs:{$meth:function(q){if(Sk.builtin.checkInt(q))q=Sk.builtin.asnum$(q);else throw new Sk.builtin.TypeError("an integer is required, got type"+Sk.abstr.typeName(q));const t=Array(q+1).join(" "),w=this.v.replace(/([^\r\n\t]*)\t/g,(C,D)=>D+t.slice(D.length%q));
return new Sk.builtin.str(w)},$flags:{NamedArgs:["tabsize"],Defaults:[8]},$textsig:"($self, /, tabsize=8)",$doc:"Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed."},find:{$meth:function(q,t,w){return new Sk.builtin.int_(this.find$left(q,t,w))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},
partition:{$meth:g(!1),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings."},index:{$meth:function(q,t,w){q=this.find$left(q,t,w);if(-1===q)throw new Sk.builtin.ValueError("substring not found");
return new Sk.builtin.int_(q)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found, \nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."},ljust:{$meth:k(!1,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a left-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."},
lower:{$meth(){return new Sk.builtin.str(this.v.toLowerCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a copy of the string converted to lowercase."},lstrip:{$meth:e(/^\s+/g,q=>"^["+q+"]+"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with leading whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."},rfind:{$meth(q,t,w){return new Sk.builtin.int_(this.find$right(q,t,w))},$flags:{MinArgs:1,MaxArgs:3},
$textsig:null,$doc:"S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},rindex:{$meth:function(q,t,w){q=this.find$right(q,t,w);if(-1===q)throw new Sk.builtin.ValueError("substring not found");return new Sk.builtin.int_(q)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."},
rjust:{$meth:k(!0,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a right-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."},rstrip:{$meth:e(/\s+$/g,q=>"["+q+"]+$"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."},rpartition:{$meth:g(!0),$flags:{OneArg:!0},
$textsig:"($self, sep, /)",$doc:"Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string."},splitlines:{$meth:function(q){q=Sk.misceval.isTrue(q);const t=this.v,w=[],C=t.length;var D=
0;for(let N=0;N<C;N++){var L=t.charAt(N);if("\n"===t.charAt(N+1)&&"\r"===L)L=N+2,D=t.slice(D,L),q||(D=D.replace(/(\r|\n)/g,"")),w.push(new Sk.builtin.str(D)),D=L;else if("\n"===L&&"\r"!==t.charAt(N-1)||"\r"===L)L=N+1,D=t.slice(D,L),q||(D=D.replace(/(\r|\n)/g,"")),w.push(new Sk.builtin.str(D)),D=L}D<C&&(D=t.slice(D,C),q||(D=D.replace(/(\r|\n)/g,"")),w.push(new Sk.builtin.str(D)));return new Sk.builtin.list(w)},$flags:{NamedArgs:["keepends"],Defaults:[!1]},$textsig:"($self, /, keepends=False)",$doc:"Return a list of the lines in the string, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."},
strip:{$meth:e(/^\s+|\s+$/g,q=>"^["+q+"]+|["+q+"]+$"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with leading and trailing whitespace remove.\n\nIf chars is given and not None, remove characters in chars instead."},swapcase:{$meth(){const q=this.v.replace(/[a-z]/gi,t=>{const w=t.toLowerCase();return w===t?t.toUpperCase():w});return new Sk.builtin.str(q)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Convert uppercase characters to lowercase and lowercase characters to uppercase."},
upper:{$meth(){return new Sk.builtin.str(this.v.toUpperCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a copy of the string converted to uppercase."},startswith:{$meth:a("startswith",(q,t)=>0===q.indexOf(t)),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try."},
endswith:{$meth:a("endswith",(q,t)=>-1!==q.indexOf(t,q.length-t.length)),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try."},isascii:{$meth(){return new Sk.builtin.bool(/^[\x00-\x7F]*$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too."},islower:{$meth:function(){return new Sk.builtin.bool(this.v.length&&/[a-z]/.test(this.v)&&!/[A-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string."},
isupper:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[a-z]/.test(this.v)&&/[A-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string."},istitle:{$meth:function(){const q=this.v;let t=!1,w=!1,C;for(let D=0;D<q.length;D++)if(C=q.charAt(D),!/[a-z]/.test(C)&&/[A-Z]/.test(C)){if(w)return Sk.builtin.bool.false$;
t=w=!0}else if(/[a-z]/.test(C)&&!/[A-Z]/.test(C)){if(!w)return Sk.builtin.bool.false$;t=!0}else w=!1;return new Sk.builtin.bool(t)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a title-cased string, False otherwise.\n\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones."},isspace:{$meth:function(){return new Sk.builtin.bool(/^\s+$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return True if the string is a whitespace string, False otherwise.\n\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string."},isdigit:{$meth:function(){return new Sk.builtin.bool(/^\d+$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string."},
isnumeric:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^0-9]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a numeric string, False otherwise.\n\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string."},isalpha:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^a-zA-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an alphabetic string, False otherwise.\n\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string."},
isalnum:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^a-zA-Z0-9]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an alpha-numeric string, False otherwise.\n\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string."},isidentifier:{$meth:function(){return this.$isIdentifier()?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:'Return True if the string is a valid Python identifier, False otherwise.\n\nUse keyword.iskeyword() to test for reserved identifiers such as "def" and\n"class".'},
zfill:{$meth:function(q){q=Sk.misceval.asIndexSized(q,Sk.builtin.OverflowError);let t="";q-=this.v.length;const w="+"===this.v[0]||"-"===this.v[0]?1:0;for(let C=0;C<q;C++)t+="0";return new Sk.builtin.str(this.v.substr(0,w)+t+this.v.substr(w))},$flags:{OneArg:!0},$textsig:"($self, width, /)",$doc:"Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe string is never truncated."},format:{$meth:Sk.formatting.format,$flags:{FastCall:!0},$textsig:null,$doc:"S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}')."},
__format__:{$meth:Sk.formatting.formatString,$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:"Return a formatted version of the string as described by format_spec."},__getnewargs__:{$meth(){return new Sk.builtin.tuple(new Sk.builtin.str(this.v))},$flags:{NoArgs:!0},$textsig:null,$doc:null}}});Sk.exportSymbol("Sk.builtin.str",Sk.builtin.str);var n=/^[A-Za-z0-9]+$/,d=/([.*+?=|\\\/()\[\]\{\}^$])/g,l=/^[\s\xa0]+/;Sk.builtin.str.$py2decode=new Sk.builtin.method_descriptor(Sk.builtin.str,{$name:"decode",
$meth(q,t){const w=new Sk.builtin.bytes(this.v);return Sk.builtin.bytes.$decode.call(w,q,t)},$flags:{NamedArgs:["encoding","errors"]}});var r=Sk.abstr.buildIteratorClass("str_iterator",{constructor:function(q){this.$index=0;q.$hasAstralCodePoints()?(this.$seq=q.codepoints,this.tp$iternext=()=>{const t=this.$seq[this.$index];if(void 0!==t)return new Sk.builtin.str(q.v.substring(t,this.$seq[++this.$index]))}):(this.$seq=q.v,this.tp$iternext=()=>{const t=this.$seq[this.$index++];if(void 0!==t)return new Sk.builtin.str(t)})},
iternext(){return this.tp$iternext()},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}}),v={abstract:!0,as:!0,boolean:!0,break:!0,byte:!0,case:!0,catch:!0,char:!0,class:!0,continue:!0,const:!0,debugger:!0,default:!0,delete:!0,do:!0,double:!0,else:!0,enum:!0,export:!0,extends:!0,false:!0,final:!0,finally:!0,float:!0,for:!0,function:!0,goto:!0,if:!0,implements:!0,import:!0,in:!0,instanceof:!0,int:!0,interface:!0,is:!0,long:!0,namespace:!0,native:!0,
new:!0,null:!0,package:!0,private:!0,protected:!0,public:!0,return:!0,short:!0,static:!0,super:!0,switch:!0,synchronized:!0,this:!0,throw:!0,throws:!0,transient:!0,true:!0,try:!0,typeof:!0,use:!0,var:!0,void:!0,volatile:!0,while:!0,with:!0,constructor:!0,__defineGetter__:!0,__defineSetter__:!0,apply:!0,arguments:!0,call:!0,caller:!0,eval:!0,hasOwnProperty:!0,isPrototypeOf:!0,__lookupGetter__:!0,__lookupSetter__:!0,__noSuchMethod__:!0,propertyIsEnumerable:!0,prototype:!0,toSource:!0,toLocaleString:!0,
toString:!0,unwatch:!0,valueOf:!0,watch:!0,length:!0,name:!0};Sk.builtin.str.reservedWords_=v},function(E,Q){Sk.builtin.func=Sk.abstr.buildNativeClass("function",{constructor:function(b,f,e,g){Sk.asserts.assert(this instanceof Sk.builtin.func,"builtin func should be called as a class with `new`");this.func_code=b;this.func_globals=f||null;this.$name=b.co_name&&b.co_name.v||b.name||"<native JS>";this.$d=Sk.builtin.dict?new Sk.builtin.dict:void 0;this.$doc=b.co_docstring||Sk.builtin.none.none$;this.$module=
Sk.globals&&Sk.globals.__name__||Sk.builtin.none.none$;this.$qualname=b.co_qualname&&b.co_qualname.v||this.$name;if(void 0!==g)for(let k in g)e[k]=g[k];this.func_closure=e;this.func_annotations=null;this.$memoiseFlags();this.memoised=b.co_fastcall||null;this.tp$call=b.co_fastcall?b.bind(this):Sk.builtin.func.prototype.tp$call.bind(this)},slots:{tp$getattr:Sk.generic.getAttr,tp$descr_get(b,f){return null===b?this:new Sk.builtin.method(this,b)},$r(){return new Sk.builtin.str("<function "+this.$qualname+
">")},tp$call(b,f){this.memoised||(this.$memoiseFlags(),this.memoised=!0);if(void 0===this.co_argcount&&void 0===this.co_varnames&&!this.co_kwargs&&!this.func_closure){if(f&&0!==f.length)throw new Sk.builtin.TypeError(this.$name+"() takes no keyword arguments");return this.func_code.apply(this.func_globals,b)}b=this.$resolveArgs(b,f);this.func_closure&&b.push(this.func_closure);return this.func_code.apply(this.func_globals,b)}},getsets:{__name__:{$get(){return new Sk.builtin.str(this.$name)},$set(b){if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("__name__ must be set to a string object");
this.$name=b.$jsstr()}},__qualname__:{$get(){return new Sk.builtin.str(this.$qualname)},$set(b){if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("__qualname__ must be set to a string object");this.$qualname=b.$jsstr()}},__dict__:Sk.generic.getSetDict,__annotations__:{$get(){null===this.func_annotations?this.func_annotations=new Sk.builtin.dict([]):Array.isArray(this.func_annotations)&&(this.func_annotations=Sk.abstr.keywordArrayToPyDict(this.func_annotations));return this.func_annotations},
$set(b){if(void 0===b||Sk.builtin.checkNone(b))this.func_annotations=new Sk.builtin.dict([]);else if(b instanceof Sk.builtin.dict)this.func_annotations=b;else throw new Sk.builtin.TypeError("__annotations__ must be set to a dict object");}},__defaults__:{$get(){return new Sk.builtin.tuple(this.$defaults)}},__doc__:{$get(){return this.$doc},$set(b){this.$doc=b||Sk.builtin.none.none$}},__module__:{$get(){return this.$module},$set(b){this.$module=b||Sk.builtin.none.none$}}},proto:{$memoiseFlags(){this.co_varnames=
this.func_code.co_varnames;this.co_argcount=this.func_code.co_argcount;void 0===this.co_argcount&&this.co_varnames&&(this.co_argcount=this.co_varnames.length);this.co_kwonlyargcount=this.func_code.co_kwonlyargcount||0;this.co_varargs=this.func_code.co_varargs;this.co_kwargs=this.func_code.co_kwargs;this.$defaults=this.func_code.$defaults||[];this.$kwdefs=this.func_code.$kwdefs||[]},$resolveArgs:function(b,f){var e=this.co_argcount;void 0===e&&(e=this.co_varnames?this.co_varnames.length:b.length);
var g=this.co_varnames||[],k=this.co_kwonlyargcount||0;let p=e+k;if(!(0!==k||this.co_kwargs||f&&0!==f.length||this.co_varargs)){if(b.length==e)return b;if(0===b.length&&this.$defaults&&this.$defaults.length===e){for(g=0;g!=this.$defaults.length;g++)b[g]=this.$defaults[g];return b}}let h;this.co_kwargs&&(h=[]);var a=b.length;let c=b.length<=e?b:b.slice(0,e);if(this.co_varargs)b=b.length>c.length?b.slice(c.length):[],c[p]=new Sk.builtin.tuple(b);else if(a>e)throw new Sk.builtin.TypeError(`${this.$name}"() takes ${e} positional ${1==
e?"argument":"arguments"} but ${a} ${1==a?"was":"were"} given`);if(f){if(this.func_code.no_kw)throw new Sk.builtin.TypeError(this.$name+"() takes no keyword arguments");for(b=0;b<f.length;b+=2){a=f[b];var m=f[b+1],n=g.indexOf(a);if(0<=n){if(void 0!==c[n])throw new Sk.builtin.TypeError(this.$name+"() got multiple values for argument '"+a+"'");c[n]=m}else if(h)h.push(new Sk.builtin.str(a),m);else throw new Sk.builtin.TypeError(this.$name+"() got an unexpected keyword argument '"+a+"'");}}f=this.$defaults||
[];b=0;a=[];m=!1;for(n=e-f.length;b<n;b++)void 0===c[b]&&(a.push(g[b]),void 0===g[b]&&(m=!0));if(0!=a.length&&(this.co_argcount||this.co_varnames))throw new Sk.builtin.TypeError(this.$name+"() missing "+a.length+" required argument"+(1==a.length?"":"s")+(m?"":": "+a.map(d=>"'"+d+"'").join(", ")));for(;b<e;b++)void 0===c[b]&&(c[b]=f[b-n]);if(0<k){k=[];f=this.$kwdefs;for(b=e;b<p;b++)void 0===c[b]&&(void 0!==f[b-e]?c[b]=f[b-e]:k.push(g[b]));if(0!==k.length)throw new Sk.builtin.TypeError(this.$name+"() missing "+
k.length+" required keyword argument"+(1==k.length?"":"s")+": "+k.join(", "));}if(this.func_closure&&g)for(e=c.length;e<g.length;e++)c.push(void 0);h&&c.unshift(h);return c}}})},function(E,Q){Sk.builtin.asnum$=function(g){return void 0===g||null===g||"number"===typeof g?g:g instanceof Sk.builtin.int_?"number"===typeof g.v?g.v:g.v.toString():g instanceof Sk.builtin.float_?g.v:g===Sk.builtin.none.none$?null:g};Sk.exportSymbol("Sk.builtin.asnum$",Sk.builtin.asnum$);Sk.builtin.assk$=function(g){return 0===
g%1?new Sk.builtin.int_(g):new Sk.builtin.float_(g)};Sk.exportSymbol("Sk.builtin.assk$",Sk.builtin.assk$);Sk.builtin.asnum$nofloat=function(g){if(void 0===g||null===g)return g;if("number"===typeof g)g=g.toString();else if(g instanceof Sk.builtin.int_)g=g.v.toString();else if(g instanceof Sk.builtin.float_)g=g.v.toString();else{if(g===Sk.builtin.none.none$)return null;return}if(0>g.indexOf(".")&&0>g.indexOf("e")&&0>g.indexOf("E"))return g;var k=0;if(0<=g.indexOf("e")){var p=g.substr(0,g.indexOf("e"));
k=g.substr(g.indexOf("e")+1)}else 0<=g.indexOf("E")?(p=g.substr(0,g.indexOf("e")),k=g.substr(g.indexOf("E")+1)):p=g;k=parseInt(k,10);g=p.indexOf(".");if(0>g){if(0<=k){for(;0<k--;)p+="0";return p}return p.length>-k?p.substr(0,p.length+k):0}p=0===g?p.substr(1):g<p.length?p.substr(0,g)+p.substr(g+1):p.substr(0,g);for(g+=k;g>p.length;)p+="0";return p=0>=g?0:p.substr(0,g)};Sk.exportSymbol("Sk.builtin.asnum$nofloat",Sk.builtin.asnum$nofloat);Sk.builtin.round=function(g,k){if(void 0===g)throw new Sk.builtin.TypeError("a float is required");
if(!Sk.__future__.dunder_round){if(!Sk.builtin.checkNumber(g))throw new Sk.builtin.TypeError("a float is required");if(g.round$)return g.round$(k);throw new Sk.builtin.AttributeError(Sk.abstr.typeName(g)+" instance has no attribute '__float__'");}if(void 0!==k&&!Sk.builtin.checkNone(k)&&!Sk.misceval.isIndex(k))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(k)+"' object cannot be interpreted as an index");g=Sk.abstr.lookupSpecial(g,Sk.builtin.str.$round);if(void 0!==g)return void 0!==k?Sk.misceval.callsimArray(g,
[k]):Sk.misceval.callsimArray(g,[]);throw new Sk.builtin.TypeError("a float is required");};Sk.builtin.len=function(g){if(g.sq$length)g=g.sq$length(!0);else throw new Sk.builtin.TypeError("object of type '"+Sk.abstr.typeName(g)+"' has no len()");return Sk.misceval.chain(g,k=>new Sk.builtin.int_(k))};Sk.builtin.min=function(g,k){let p;const h=g.length;if(!h)throw new Sk.builtin.TypeError("min expected 1 argument, got 0");const [a,c]=Sk.abstr.copyKeywordsToNamedArgs("min",["default","key"],[],k,[null,
Sk.builtin.none.none$]);if(1<h&&null!==a)throw new Sk.builtin.TypeError("Cannot specify a default for min() with multiple positional arguments");p=1==h?Sk.abstr.iter(g[0]):Sk.abstr.iter(new Sk.builtin.tuple(g));if(!Sk.builtin.checkNone(c)&&!Sk.builtin.checkCallable(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not callable");let m;return Sk.misceval.chain(p.tp$iternext(!0),n=>{m=n;if(void 0!==m)return Sk.builtin.checkNone(c)?Sk.misceval.iterFor(p,d=>{Sk.misceval.richCompareBool(d,
m,"Lt")&&(m=d)}):Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,[m]),d=>Sk.misceval.iterFor(p,l=>Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,[l]),r=>{Sk.misceval.richCompareBool(r,d,"Lt")&&(m=l,d=r)})))},()=>{if(void 0===m){if(null===a)throw new Sk.builtin.ValueError("min() arg is an empty sequence");m=a}return m})};Sk.builtin.max=function(g,k){let p;const h=g.length;if(!h)throw new Sk.builtin.TypeError("max expected 1 argument, got 0");const [a,c]=Sk.abstr.copyKeywordsToNamedArgs("max",
["default","key"],[],k,[null,Sk.builtin.none.none$]);if(1<h&&null!==a)throw new Sk.builtin.TypeError("Cannot specify a default for max() with multiple positional arguments");p=1===h?Sk.abstr.iter(g[0]):Sk.abstr.iter(new Sk.builtin.tuple(g));if(!Sk.builtin.checkNone(c)&&!Sk.builtin.checkCallable(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not callable");let m;return Sk.misceval.chain(p.tp$iternext(!0),n=>{m=n;if(void 0!==m)return Sk.builtin.checkNone(c)?Sk.misceval.iterFor(p,
d=>{Sk.misceval.richCompareBool(d,m,"Gt")&&(m=d)}):Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,[m]),d=>Sk.misceval.iterFor(p,l=>Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,[l]),r=>{Sk.misceval.richCompareBool(r,d,"Gt")&&(m=l,d=r)})))},()=>{if(void 0===m){if(null===a)throw new Sk.builtin.ValueError("max() arg is an empty sequence");m=a}return m})};Sk.builtin.min.co_fastcall=Sk.builtin.max.co_fastcall=1;Sk.builtin.any=function(g){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(g),
function(k){if(Sk.misceval.isTrue(k))return new Sk.misceval.Break(Sk.builtin.bool.true$)}),k=>k||Sk.builtin.bool.false$)};Sk.builtin.all=function(g){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(g),function(k){if(!Sk.misceval.isTrue(k))return new Sk.misceval.Break(Sk.builtin.bool.false$)}),k=>k||Sk.builtin.bool.true$)};Sk.builtin.sum=function(g,k){function p(){return Sk.misceval.iterFor(c,n=>{if(n.constructor===Sk.builtin.int_)m=m.nb$add(n);else{if(n.constructor===Sk.builtin.float_)return m=
m.nb$float().nb$add(n),new Sk.misceval.Break("float");m=Sk.abstr.numberBinOp(m,n,"Add");return new Sk.misceval.Break("slow")}})}function h(){return Sk.misceval.iterFor(c,n=>{if(n.constructor===Sk.builtin.float_||n.constructor===Sk.builtin.int_)m=m.nb$add(n);else return m=Sk.abstr.numberBinOp(m,n,"Add"),new Sk.misceval.Break("slow")})}function a(){return Sk.misceval.iterFor(c,n=>{m=Sk.abstr.numberBinOp(m,n,"Add")})}const c=Sk.abstr.iter(g);if(void 0===k)var m=new Sk.builtin.int_(0);else{if(Sk.builtin.checkString(k))throw new Sk.builtin.TypeError("sum() can't sum strings [use ''.join(seq) instead]");
m=k}g=void 0===k||k.constructor===Sk.builtin.int_?p():k.constructor===Sk.builtin.float_?"float":"slow";return Sk.misceval.chain(g,n=>"float"===n?h():n,n=>{if("slow"===n)return a()},()=>m)};Sk.builtin.zip=function(){var g,k;if(0===arguments.length)return new Sk.builtin.list([]);var p=[];for(k=0;k<arguments.length;k++)if(Sk.builtin.checkIterable(arguments[k]))p.push(Sk.abstr.iter(arguments[k]));else throw new Sk.builtin.TypeError("argument "+k+" must support iteration");var h=[];for(g=!1;!g;){var a=
[];for(k=0;k<arguments.length;k++){var c=p[k].tp$iternext();if(void 0===c){g=!0;break}a.push(c)}g||h.push(new Sk.builtin.tuple(a))}return new Sk.builtin.list(h)};Sk.builtin.abs=function(g){if(g.nb$abs)return g.nb$abs();throw new Sk.builtin.TypeError("bad operand type for abs(): '"+Sk.abstr.typeName(g)+"'");};Sk.builtin.fabs=function(g){return Sk.builtin.abs(g)};Sk.builtin.ord=function(g){if(Sk.builtin.checkString(g)){if(1!==g.v.length&&1!==g.sq$length())throw new Sk.builtin.TypeError("ord() expected a character, but string of length "+
g.v.length+" found");return new Sk.builtin.int_(g.v.codePointAt(0))}if(Sk.builtin.checkBytes(g)){if(1!==g.sq$length())throw new Sk.builtin.TypeError("ord() expected a character, but string of length "+g.v.length+" found");return new Sk.builtin.int_(g.v[0])}throw new Sk.builtin.TypeError("ord() expected a string of length 1, but "+Sk.abstr.typeName(g)+" found");};Sk.builtin.chr=function(g){if(!Sk.builtin.checkInt(g))throw new Sk.builtin.TypeError("an integer is required");g=Sk.builtin.asnum$(g);if(Sk.__future__.python3){if(0>
g||1114112<=g)throw new Sk.builtin.ValueError("chr() arg not in range(0x110000)");}else if(0>g||256<=g)throw new Sk.builtin.ValueError("chr() arg not in range(256)");return new Sk.builtin.str(String.fromCodePoint(g))};Sk.builtin.unichr=function(g){Sk.builtin.pyCheckArgsLen("unichr",arguments.length,1,1);if(!Sk.builtin.checkInt(g))throw new Sk.builtin.TypeError("an integer is required");g=Sk.builtin.asnum$(g);try{return new Sk.builtin.str(String.fromCodePoint(g))}catch(k){if(k instanceof RangeError)throw new Sk.builtin.ValueError(k.message);
throw k;}};Sk.builtin.int2str_=function(g,k,p){let h=g.nb$index(),a;h="number"===typeof h?(a=0>h)?-h:h:(a=JSBI.lessThan(h,JSBI.__ZERO))?JSBI.unaryMinus(h):h;let c=h.toString(k);c=a?"-"+p+c:p+c;2!==k&&!Sk.__future__.python3&&(g instanceof Sk.builtin.lng||JSBI.__isBigInt(h))&&(c+="L");return new Sk.builtin.str(c)};Sk.builtin.hex=function(g){if(!Sk.misceval.isIndex(g))throw new Sk.builtin.TypeError("hex() argument can't be converted to hex");return Sk.builtin.int2str_(g,16,"0x")};Sk.builtin.oct=function(g){if(!Sk.misceval.isIndex(g))throw new Sk.builtin.TypeError("oct() argument can't be converted to hex");
return Sk.__future__.octal_number_literal?Sk.builtin.int2str_(g,8,"0o"):Sk.builtin.int2str_(g,8,"0")};Sk.builtin.bin=function(g){if(!Sk.misceval.isIndex(g))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(g)+"' object can't be interpreted as an index");return Sk.builtin.int2str_(g,2,"0b")};Sk.builtin.dir=function(g){if(void 0!==g)return g=Sk.abstr.lookupSpecial(g,Sk.builtin.str.$dir),Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(g,[]),k=>Sk.builtin.sorted(k));throw new Sk.builtin.NotImplementedError("skulpt does not yet support dir with no args");
};Sk.builtin.repr=function(g){return g.$r()};Sk.builtin.ascii=function(g){return Sk.misceval.chain(g.$r(),k=>{let p,h;for(h=0;h<k.v.length;h++)if(127<=k.v.charCodeAt(h)){p=k.v.substr(0,h);break}if(!p)return k;for(;h<k.v.length;h++){var a=k.v.charAt(h),c=k.v.charCodeAt(h);127<c&&255>=c?(a=c.toString(16),2>a.length&&(a="0"+a),p+="\\x"+a):127<c&&55296>c||57344<=c?p+="\\u"+("000"+c.toString(16)).slice(-4):55296<=c?(a=k.v.codePointAt(h),h++,a=a.toString(16),c="0000000"+a.toString(16),p=4<a.length?p+("\\U"+
c.slice(-8)):p+("\\u"+c.slice(-4))):p+=a}return new Sk.builtin.str(p)})};Sk.builtin.open=function(g,k,p){void 0===k&&(k=new Sk.builtin.str("r"));if(/\+/.test(k.v))throw"todo; haven't implemented read/write mode";if(("w"===k.v||"wb"===k.v||"a"===k.v||"ab"===k.v)&&!Sk.nonreadopen)throw"todo; haven't implemented non-read opens";return new Sk.builtin.file(g,k,p)};Sk.builtin.isinstance=function(g,k){if(!(Sk.builtin.checkClass(k)||k instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError("isinstance() arg 2 must be a class, type, or tuple of classes and types");
var p=g.ob$type;if(p===k)return Sk.builtin.bool.true$;if(!(k instanceof Sk.builtin.tuple)){if(p.$isSubType(k))return Sk.builtin.bool.true$;g=g.tp$getattr(Sk.builtin.str.$class);return g!=p&&Sk.builtin.checkClass(g)&&g.$isSubType(k)?Sk.builtin.bool.true$:Sk.builtin.bool.false$}for(p=0;p<k.v.length;++p)if(Sk.misceval.isTrue(Sk.builtin.isinstance(g,k.v[p])))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$};Sk.builtin.hash=function(g){return new Sk.builtin.int_(Sk.abstr.objectHash(g))};Sk.builtin.getattr=
function(g,k,p){if(!Sk.builtin.checkString(k))throw new Sk.builtin.TypeError("attribute name must be string");const h=Sk.misceval.tryCatch(()=>g.tp$getattr(k,!0),a=>{if(!(a instanceof Sk.builtin.AttributeError))throw a;});return Sk.misceval.chain(h,a=>{if(void 0===a){if(void 0!==p)return p;throw new Sk.builtin.AttributeError(g.sk$attrError()+" has no attribute "+Sk.misceval.objectRepr(k));}return a})};Sk.builtin.setattr=function(g,k,p){if(!Sk.builtin.checkString(k))throw new Sk.builtin.TypeError("attribute name must be string");
return Sk.misceval.chain(g.tp$setattr(k,p,!0),()=>Sk.builtin.none.none$)};Sk.builtin.raw_input=function(g){var k=g?g:"";return Sk.misceval.chain(Sk.importModule("sys",!1,!0),function(p){return Sk.inputfunTakesPrompt?Sk.builtin.file.$readline(p.$d.stdin,null,k):Sk.misceval.chain(void 0,function(){return Sk.misceval.callsimOrSuspendArray(p.$d.stdout.write,[p.$d.stdout,new Sk.builtin.str(k)])},function(){return Sk.misceval.callsimOrSuspendArray(p.$d.stdin.readline,[p.$d.stdin])})})};Sk.builtin.input=
Sk.builtin.raw_input;Sk.builtin.jseval=function(g){g=Sk.global.eval(Sk.ffi.remapToJs(g));return Sk.ffi.remapToPy(g)};Sk.builtin.jsmillis=function(){console.warn("jsmillis is deprecated");return(new Date).valueOf()};const b=Sk.abstr.buildNativeClass("code",{constructor:function(g,k){this.compiled=k;this.code=k.code;this.filename=g},slots:{tp$new(g,k){throw new Sk.builtin.NotImplementedError("cannot construct a code object in skulpt");},$r(){return new Sk.builtin.str("<code object <module>, file "+
this.filename+">")}}});Sk.builtin.compile=function(g,k,p,h,a,c){Sk.builtin.pyCheckType("source","str",Sk.builtin.checkString(g));Sk.builtin.pyCheckType("filename","str",Sk.builtin.checkString(k));Sk.builtin.pyCheckType("mode","str",Sk.builtin.checkString(p));g=g.$jsstr();k=k.$jsstr();p=p.$jsstr();return Sk.misceval.chain(Sk.compile(g,k,p,!0),m=>new b(k,m))};Sk.builtin.exec=function(g,k,p){let h=k&&k.__file__;h=void 0!==h&&Sk.builtin.checkString(h)?h.toString():"<string>";if(Sk.builtin.checkString(g))g=
Sk.compile(g.$jsstr(),h,"exec",!0);else if("string"===typeof g)g=Sk.compile(g,h,"exec",!0);else if(!(g instanceof b))throw new Sk.builtin.TypeError("exec() arg 1 must be a string, bytes or code object");Sk.asserts.assert(void 0===k||k.constructor===Object,"internal calls to exec should be called with a javascript object for globals");Sk.asserts.assert(void 0===p||p.constructor===Object,"internal calls to exec should be called with a javascript object for locals");const a=Sk.globals;k=k||a;return Sk.misceval.chain(g,
c=>Sk.global.eval(c.code)(k,p),c=>{Sk.globals=a;return c})};Sk.builtin.eval=function(g,k,p){if(Sk.builtin.checkString(g))g=g.$jsstr();else if(Sk.builtin.checkBytes(g))throw new Sk.builtin.NotImplementedError("bytes for eval is not yet implemented in skulpt");if("string"===typeof g){g=g.trim();var h=Sk.parse("?",g);h=Sk.astFromParse(h.cst,"?",h.flags);if(1<h.body.length||!(h.body[0]instanceof Sk.astnodes.Expr))throw new Sk.builtin.SyntaxError("invalid syntax");g="__final_res__ = "+g}else if(!(g instanceof
b))throw new Sk.builtin.TypeError("eval() arg 1 must be a string, bytes or code object");return Sk.misceval.chain(Sk.builtin.exec(g,k,p),a=>{const c=a.__final_res__||Sk.builtin.none.none$;delete a.__final_res__;return c})};Sk.builtin.map=function(g,k){var p=[],h,a;Sk.builtin.pyCheckArgsLen("map",arguments.length,2);if(2<arguments.length){var c=[];var m=Array.prototype.slice.apply(arguments).slice(1);for(a=0;a<m.length;a++){if(!Sk.builtin.checkIterable(m[a])){var n=parseInt(a,10)+2;throw new Sk.builtin.TypeError("argument "+
n+" to map() must support iteration");}m[a]=Sk.abstr.iter(m[a])}for(;;){var d=[];for(a=h=0;a<m.length;a++)n=m[a].tp$iternext(),void 0===n?(d.push(Sk.builtin.none.none$),h++):d.push(n);if(h!==m.length)c.push(d);else break}k=new Sk.builtin.list(c)}if(!Sk.builtin.checkIterable(k))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(k)+"' object is not iterable");return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(k),function(l){if(g===Sk.builtin.none.none$)l instanceof Array&&(l=new Sk.builtin.tuple(l)),
p.push(l);else return l instanceof Array||(l=[l]),Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(g,l),function(r){p.push(r)})}),function(){return new Sk.builtin.list(p)})};Sk.builtin.reduce=function(g,k,p){if(!Sk.builtin.checkIterable(k))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(k)+"' object is not iterable");k=Sk.abstr.iter(k);if(void 0===p&&(p=k.tp$iternext(),void 0===p))throw new Sk.builtin.TypeError("reduce() of empty sequence with no initial value");var h=p;for(p=k.tp$iternext();void 0!==
p;p=k.tp$iternext())h=Sk.misceval.callsimArray(g,[h,p]);return h};Sk.builtin.sorted=function(g,k,p,h){g=Sk.misceval.arrayFromIterable(g,!0);return Sk.misceval.chain(g,a=>{a=new Sk.builtin.list(a);a.list$sort(k,p,h);return a})};Sk.builtin.filter=function(g,k){var p;Sk.builtin.pyCheckArgsLen("filter",arguments.length,2,2);if(!Sk.builtin.checkIterable(k))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(k)+"' object is not iterable");var h=function(){return[]};var a=function(d,l){d.push(l);return d};
var c=function(d){return new Sk.builtin.list(d)};k.ob$type===Sk.builtin.str?(h=function(){return new Sk.builtin.str("")},a=function(d,l){return d.sq$concat(l)},c=function(d){return d}):k.ob$type===Sk.builtin.tuple&&(c=function(d){return new Sk.builtin.tuple(d)});var m=h();var n=Sk.abstr.iter(k);for(p=n.tp$iternext();void 0!==p;p=n.tp$iternext())h=g===Sk.builtin.none.none$?new Sk.builtin.bool(p):Sk.misceval.callsimArray(g,[p]),Sk.misceval.isTrue(h)&&(m=a(m,p));return c(m)};Sk.builtin.hasattr=function(g,
k){if(!Sk.builtin.checkString(k))throw new Sk.builtin.TypeError("hasattr(): attribute name must be string");const p=Sk.misceval.tryCatch(()=>g.tp$getattr(k,!0),h=>{if(!(h instanceof Sk.builtin.AttributeError))throw h;});return Sk.misceval.chain(p,h=>void 0===h?Sk.builtin.bool.false$:Sk.builtin.bool.true$)};Sk.builtin.pow=function(g,k,p){if(void 0===p||Sk.builtin.checkNone(p))return Sk.abstr.numberBinOp(g,k,"Pow");if(!(Sk.builtin.checkInt(g)&&Sk.builtin.checkInt(k)&&Sk.builtin.checkInt(p))){if(Sk.builtin.checkFloat(g)||
Sk.builtin.checkComplex(g))return g.nb$power(k,p);throw new Sk.builtin.TypeError("unsupported operand type(s) for ** or pow(): '"+Sk.abstr.typeName(g)+"', '"+Sk.abstr.typeName(k)+"', '"+Sk.abstr.typeName(p)+"'");}return g.nb$power(k,p)};Sk.builtin.quit=function(g){g=(new Sk.builtin.str(g)).v;throw new Sk.builtin.SystemExit(g);};Sk.builtin.issubclass=function(g,k){if(!Sk.builtin.checkClass(g))throw new Sk.builtin.TypeError("issubclass() arg 1 must be a class");var p=Sk.builtin.checkClass(k);if(!(p||
k instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError("issubclass() arg 2 must be a class or tuple of classes");if(p)return g.$isSubType(k)?Sk.builtin.bool.true$:Sk.builtin.bool.false$;for(p=0;p<k.v.length;++p)if(Sk.misceval.isTrue(Sk.builtin.issubclass(g,k.v[p])))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$};Sk.builtin.globals=function(){var g,k=new Sk.builtin.dict([]);for(g in Sk.globals){var p=Sk.unfixReserved(g);k.mp$ass_subscript(new Sk.builtin.str(p),Sk.globals[g])}return k};
Sk.builtin.divmod=function(g,k){return Sk.abstr.numberBinOp(g,k,"DivMod")};Sk.builtin.format=function(g,k){return Sk.abstr.objectFormat(g,k)};const f=new WeakMap;let e=0;Sk.builtin.id=function(g){const k=f.get(g);if(void 0!==k)return new Sk.builtin.int_(k);f.set(g,e);return new Sk.builtin.int_(e++)};Sk.builtin.bytearray=function(){throw new Sk.builtin.NotImplementedError("bytearray is not yet implemented");};Sk.builtin.callable=function(g){return Sk.builtin.checkCallable(g)?Sk.builtin.bool.true$:
Sk.builtin.bool.false$};Sk.builtin.delattr=function(g,k){return Sk.builtin.setattr(g,k,void 0)};Sk.builtin.execfile=function(){throw new Sk.builtin.NotImplementedError("execfile is not yet implemented");};Sk.builtin.help=function(){throw new Sk.builtin.NotImplementedError("help is not yet implemented");};Sk.builtin.iter=function(g,k){return 1===arguments.length?Sk.abstr.iter(g):Sk.abstr.iter(new Sk.builtin.callable_iter_(g,k))};Sk.builtin.locals=function(){throw new Sk.builtin.NotImplementedError("locals is not yet implemented");
};Sk.builtin.memoryview=function(){throw new Sk.builtin.NotImplementedError("memoryview is not yet implemented");};Sk.builtin.next_=function(g,k){if(!g.tp$iternext)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(g)+"' object is not an iterator");return Sk.misceval.chain(g.tp$iternext(!0),p=>{if(void 0===p){if(k)return k;p=g.gi$ret;if(void 0!==p&&p!==Sk.builtin.none.none$)throw new Sk.builtin.StopIteration(p);throw new Sk.builtin.StopIteration;}return p})};Sk.builtin.reload=function(){throw new Sk.builtin.NotImplementedError("reload is not yet implemented");
};Sk.builtin.vars=function(){throw new Sk.builtin.NotImplementedError("vars is not yet implemented");};Sk.builtin.apply_=function(){throw new Sk.builtin.NotImplementedError("apply is not yet implemented");};Sk.builtin.buffer=function(){throw new Sk.builtin.NotImplementedError("buffer is not yet implemented");};Sk.builtin.coerce=function(){throw new Sk.builtin.NotImplementedError("coerce is not yet implemented");};Sk.builtin.intern=function(){throw new Sk.builtin.NotImplementedError("intern is not yet implemented");
}},function(E,Q){function b(T,Y){Y=new this.constructor;this.ht$type&&p.call(Y);Y.args=new Sk.builtin.tuple(T.slice(0));return Y}function f(T,Y){Sk.abstr.checkNoKwargs(Sk.abstr.typeName(this),Y);this.args=new Sk.builtin.tuple(T.slice(0))}function e(){return 1>=this.args.v.length?new Sk.builtin.str(this.args.v[0]):this.args.$r()}function g(T,Y,da,qa,pa,z){pa||(pa=[]);const u=qa?{}:{sk$solidBase:!1};da={tp$init:qa||f,tp$doc:da};z&&(da.tp$str=z);return Sk.abstr.buildNativeClass(Y,{base:T,constructor:function(...y){T.apply(this,
y);pa.forEach((G,K)=>{this["$"+G]=Sk.ffi.remapToPy(y[K])})},slots:da,getsets:Object.fromEntries(pa.map(y=>[y,{$get(){return this["$"+y]||Sk.builtin.none.none$},$set(G){this["$"+y]=G||Sk.builtin.none.none$}}])),flags:u})}function k(T,Y,da){const qa=T.prototype.tp$init;da={tp$doc:da,tp$init:qa};qa===f&&(da.tp$new=b);return Sk.abstr.buildNativeClass(Y,{base:T,constructor:function(...pa){T.apply(this,pa)},slots:da,flags:{sk$solidBase:!1}})}const p=Sk.abstr.buildNativeClass("BaseException",{constructor:function qa(Y,
...da){Sk.asserts.assert(this instanceof qa,"bad call to exception constructor, use 'new'");"string"===typeof Y&&(Y=new Sk.builtin.str(Y));this.args=new Sk.builtin.tuple(Y?[Y]:[]);this.traceback=2<=da.length?[{filename:da[0]||"<unknown>",lineno:da[1]}]:[];this.context=this.cause=null;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"Common base class for all exceptions",tp$new:b,tp$init:f,$r(){let Y=this.tp$name;Y+="("+this.args.v.map(da=>Sk.misceval.objectRepr(da)).join(", ")+
")";return new Sk.builtin.str(Y)},tp$str:e},getsets:{args:{$get(){return this.args},$set(Y){if(void 0===Y)throw new Sk.builtin.TypeError("args may not be deleted");this.args=new Sk.builtin.tuple(Y)}},__cause__:{$get(){return this.$cause||Sk.builtin.none.none$},$set(Y){if(!(Sk.builtin.checkNone(Y)||Y instanceof Sk.builtin.BaseException))throw new na("exception cause must be None or derive from BaseException");this.$cause=Y}},__dict__:Sk.generic.getSetDict},proto:{toString(){let Y=this.tp$name;Y+=": "+
this.tp$str().v;return Y=0!==this.traceback.length?Y+(" on line "+this.traceback[0].lineno):Y+" at <unknown>"}}});E=k(p,"SystemExit","Request to exit from the interpreter.");Q=k(p,"KeyboardInterrupt","Program interrupted by user.");const h=k(p,"GeneratorExit","Request that a generator exit."),a=k(p,"Exception","Common base class for all non-exit exceptions."),c=g(a,"StopIteration","Signal the end from iterator.__next__().",function(Y,da){f.call(this,Y,da);this.$value=Y[0]||Sk.builtin.none.none$},
["value"]),m=k(a,"StopAsyncIteration","Signal the end from iterator.__anext__()."),n=k(a,"ArithmeticError","Base class for arithmetic errors."),d=k(n,"FloatingPointError","Floating point operation failed."),l=k(n,"OverflowError","Result too large to be represented."),r=k(n,"ZeroDivisionError","Second argument to a division or modulo operation was zero."),v=k(a,"AssertionError","Assertion failed."),q=k(a,"AttributeError","Attribute not found."),t=k(a,"BufferError","Buffer error."),w=k(a,"EOFError",
"Read beyond end of file."),C=g(a,"ImportError","Import can't find module, or can't find name in module.",function(Y,da){f.call(this,Y);const [qa,pa]=Sk.abstr.copyKeywordsToNamedArgs("ImportError",["name","path"],[],da);this.$name=qa;this.$path=pa;1===Y.length&&(this.$msg=Y[0])},["msg","name","path"],function(){return Sk.builtin.checkString(this.$msg)?this.$msg:e.call(this)}),D=k(C,"ModuleNotFoundError","Module not found."),L=k(a,"LookupError","Base class for lookup errors."),N=k(L,"IndexError","Sequence index out of range."),
A=g(L,"KeyError","Mapping key not found.",null,null,function(){return 1===this.args.v.length?this.args.v[0].$r():e.call(this)}),H=k(a,"MemoryError","Out of memory."),x=k(a,"NameError","Name not found globally."),B=k(x,"UnboundLocalError","Local name referenced but not bound to a value."),F=g(a,"OSError","Base class for I/O related errors.",function(Y,da){f.call(this,Y,da)}),J=k(F,"FileNotFoundError","File not found."),P=k(F,"TimeoutError","Timeout expired."),W=k(a,"ReferenceError","Weak ref proxy used after referent went away."),
ca=k(a,"RuntimeError","Unspecified run-time error."),ha=k(ca,"NotImplementedError","Method or function hasn't been implemented yet."),oa=k(ca,"RecursionError","Recursion limit exceeded."),ka=g(a,"SyntaxError","Invalid syntax.",function(Y,da){f.call(this,Y,da);1<=Y.length&&(this.$msg=Y[0]);2===Y.length&&(Y=(new Sk.builtin.tuple(Y[1])).v,this.$filename=Y[0],this.$lineno=Y[1],this.$offset=Y[2],this.$text=Y[3])},["msg","filename","lineno","offset","text"],function(){return e.call(this)}),ia=k(ka,"IndentationError",
"Improper indentation."),ba=k(ia,"TabError","Improper mixture of spaces and tabs."),ja=k(a,"SystemError","Internal error in the Skulpt interpreter."),na=k(a,"TypeError","Inappropriate argument type."),fa=k(a,"ValueError","Inappropriate argument value (of correct type)."),V=k(fa,"UnicodeError","Unicode related error."),la=k(V,"UnicodeDecodeError","Unicode decoding error."),O=k(V,"UnicodeEncodeError","Unicode encoding error.");Object.assign(Sk.builtin,{BaseException:p,SystemExit:E,KeyboardInterrupt:Q,
GeneratorExit:h,Exception:a,StopIteration:c,StopAsyncIteration:m,ArithmeticError:n,FloatingPointError:d,OverflowError:l,ZeroDivisionError:r,AssertionError:v,AttributeError:q,BufferError:t,EOFError:w,ImportError:C,ModuleNotFoundError:D,LookupError:L,IndexError:N,KeyError:A,MemoryError:H,NameError:x,UnboundLocalError:B,OSError:F,IOError:F,FileNotFoundError:J,TimeoutError:P,ReferenceError:W,RuntimeError:ca,NotImplementedError:ha,RecursionError:oa,SyntaxError:ka,IndentationError:ia,TabError:ba,SystemError:ja,
TypeError:na,ValueError:fa,UnicodeError:V,UnicodeDecodeError:la,UnicodeEncodeError:O});Sk.builtin.SuspensionError=k(a,"SuspensionError","Unsupported Suspension in code.");Sk.builtin.ExternalError=Sk.abstr.buildNativeClass("ExternalError",{constructor:function(...Y){this.nativeError=Y[0];if(!Sk.builtin.checkString(this.nativeError)&&(Y[0]=this.nativeError.toString(),Y[0].startsWith("RangeError: Maximum call")))return Y[0]="Maximum call stack size exceeded",new oa(...Y);a.apply(this,Y)},base:a});Sk.builtin.getExcInfo=
function(Y){return new Sk.builtin.tuple([Y.ob$type||Sk.builtin.none.none$,Y,Sk.builtin.none.none$])}},function(E,Q){Sk.builtin.method=Sk.abstr.buildNativeClass("method",{constructor:function(b,f){Sk.asserts.assert(this instanceof Sk.builtin.method,"bad call to method constructor, use 'new'");this.im_func=b;this.im_self=f;this.im_call=b.tp$call},slots:{$r(){let b=this.im_func.tp$getattr(Sk.builtin.str.$qualname)||this.im_func.tp$getattr(Sk.builtin.str.$name);b=b&&b.v||"?";return new Sk.builtin.str("<bound method "+
b+" of "+Sk.misceval.objectRepr(this.im_self)+">")},tp$hash(){const b=Sk.abstr.objectHash(this.im_self),f=Sk.abstr.objectHash(this.im_func);return b+f},tp$call(b,f){var e=this.im_call;if(void 0===e)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(this.im_func)+"' object is not callable");b=[this.im_self,...b];return e.call(this.im_func,b,f)},tp$new(b,f){Sk.abstr.checkNoKwargs("method",f);Sk.abstr.checkArgsLen("method",b,2,2);f=b[0];b=b[1];if(!Sk.builtin.checkCallable(f))throw new Sk.builtin.TypeError("first argument must be callable");
if(Sk.builtin.checkNone(b))throw new Sk.builtin.TypeError("self must not be None");return new Sk.builtin.method(f,b)},tp$richcompare(b,f){if("Eq"!=f&&"NotEq"!=f||!(b instanceof Sk.builtin.method))return Sk.builtin.NotImplemented.NotImplemented$;let e;try{e=Sk.misceval.richCompareBool(this.im_self,b.im_self,"Eq",!1)&&this.im_func==b.im_func}catch(g){e=!1}return"Eq"==f?e:!e},tp$descr_get(b,f){return this},tp$getattr(b,f){const e=Sk.abstr.lookupSpecial(this,b);return void 0!==e?e:this.im_func.tp$getattr(b,
f)}},getsets:{__func__:{$get(){return this.im_func}},__self__:{$get(){return this.im_self}},__doc__:{$get(){return this.im_func.tp$getattr(Sk.builtin.str.$doc)}}},flags:{sk$unacceptableBase:!0}})},function(E,Q){function b(p){if(null!==p&&void 0!==p){if(p.nb$index)return p.nb$index();if("number"===typeof p&&Number.isInteger(p))return p}}function f(p,h){const a=b(p);if(void 0!==a)return a;h=(h||"'{tp$name}' object cannot be interpreted as an integer").replace("{tp$name}",Sk.abstr.typeName(p));throw new Sk.builtin.TypeError(h);
}function e(){const p=(Sk.global.navigator||{}).userAgent||"";return-1<p.indexOf("MSIE ")||-1<p.indexOf("Trident/")}function g(p,h){let a=p;h.forEach(c=>{c=c.ob$type;if(!a.$isSubType(c))if(c.$isSubType(a))a=c;else throw new Sk.builtin.TypeError("metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases");});return a}function k(p,h,a,c,m){const n=p.tp$getattr(Sk.builtin.str.$prepare);let d,l=null;if(void 0===n)return[l,d];l=Sk.misceval.callsimArray(n,
[h,a],c);if(!Sk.builtin.checkMapping(l))throw new Sk.builtin.TypeError(m?p.prototype.tp$name:"<metaclass>.__prepare__() must return a mapping not '"+Sk.abstr.typeName(l)+"'");d={get(r,v){try{return Sk.abstr.objectGetItem(r,new Sk.builtin.str(Sk.unfixReserved(v)))}catch(q){if(!(q instanceof Sk.builtin.KeyError))throw q;}},set(r,v,q){Sk.abstr.objectSetItem(r,new Sk.builtin.str(Sk.unfixReserved(v)),q);return!0}};return[l,d]}Sk.misceval={};Sk.misceval.Suspension=function(p,h,a){this.$isSuspension=!0;
void 0!==p&&void 0!==h&&(this.resume=function(){return p(h.resume())});this.child=h;this.optional=void 0!==h&&h.optional;this.data=void 0===a&&void 0!==h?h.data:a};Sk.exportSymbol("Sk.misceval.Suspension",Sk.misceval.Suspension);Sk.misceval.retryOptionalSuspensionOrThrow=function(p,h){for(;p instanceof Sk.misceval.Suspension;){if(!p.optional){h=new Sk.builtin.SuspensionError(h||"Cannot call a function that blocks or suspends here");const a=[];for(;null!=p;)p.$lineno&&a.push({filename:p.$filename,
lineno:p.$lineno,colno:p.$colno}),p=p.child;a.reverse();h.traceback.push(...a);throw h;}p=p.resume()}return p};Sk.exportSymbol("Sk.misceval.retryOptionalSuspensionOrThrow",Sk.misceval.retryOptionalSuspensionOrThrow);Sk.misceval.isIndex=function(p){return null!==p&&void 0!==p&&(void 0!==p.nb$index||"number"===typeof p&&Number.isInteger(p))};Sk.exportSymbol("Sk.misceval.isIndex",Sk.misceval.isIndex);Sk.misceval.asIndex=b;Sk.misceval.asIndexSized=function(p,h,a){a=f(p,a);if("number"===typeof a)return a;
if(null==h)return JSBI.lessThan(a,JSBI.__ZERO)?-Number.MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER;throw new h("cannot fit '"+Sk.abstr.typeName(p)+"' into an index-sized integer");};Sk.misceval.asIndexOrThrow=f;Sk.misceval.applySlice=function(p,h,a,c){return Sk.abstr.objectGetItem(p,new Sk.builtin.slice(h,a,null),c)};Sk.exportSymbol("Sk.misceval.applySlice",Sk.misceval.applySlice);Sk.misceval.assignSlice=function(p,h,a,c,m){h=new Sk.builtin.slice(h,a);return null===c?Sk.abstr.objectDelItem(p,h):Sk.abstr.objectSetItem(p,
h,c,m)};Sk.exportSymbol("Sk.misceval.assignSlice",Sk.misceval.assignSlice);Sk.misceval.arrayFromArguments=function(p){var h;if(1!=p.length)return p;var a=p[0];a instanceof Sk.builtin.set?a=a.tp$iter().$obj:a instanceof Sk.builtin.dict&&(a=Sk.builtin.dict.prototype.keys.func_code(a));if(a instanceof Sk.builtin.list||a instanceof Sk.builtin.tuple)return a.v;if(Sk.builtin.checkIterable(a)){p=[];a=Sk.abstr.iter(a);for(h=a.tp$iternext();void 0!==h;h=a.tp$iternext())p.push(h);return p}throw new Sk.builtin.TypeError("'"+
Sk.abstr.typeName(a)+"' object is not iterable");};Sk.exportSymbol("Sk.misceval.arrayFromArguments",Sk.misceval.arrayFromArguments);Sk.misceval.iterator=Sk.abstr.buildIteratorClass("iterator",{constructor:function(p,h){this.tp$iternext=h?p:function(a){let c=p();return a||void 0===c||!c.$isSuspension?c:Sk.misceval.retryOptionalSuspensionOrThrow(c)}},iternext:function(p){return this.tp$iternext(p)},flags:{sk$unacceptableBase:!0}});Sk.misceval.swappedOp_={Eq:"Eq",NotEq:"NotEq",Lt:"Gt",LtE:"GtE",Gt:"Lt",
GtE:"LtE"};Sk.misceval.opSymbols={Eq:"==",NotEq:"!=",Lt:"<",LtE:"<=",Gt:">",GtE:">=",Is:"is",IsNot:"is not",In_:"in",NotIn:"not in"};Sk.misceval.richCompareBool=function(p,h,a,c){Sk.asserts.assert(p.sk$object&&h.sk$object,"JS object passed to richCompareBool");var m=p.ob$type,n=h.ob$type,d=n!==m&&void 0===n.sk$baseClass&&n.$isSubType(m);if(!Sk.__future__.python3&&m!==n&&("GtE"===a||"Gt"===a||"LtE"===a||"Lt"===a)){var l=[Sk.builtin.float_,Sk.builtin.int_,Sk.builtin.lng,Sk.builtin.bool];const v=[Sk.builtin.dict,
Sk.builtin.enumerate,Sk.builtin.filter_,Sk.builtin.list,Sk.builtin.map_,Sk.builtin.str,Sk.builtin.tuple,Sk.builtin.zip_];var r=l.indexOf(m);m=v.indexOf(m);l=l.indexOf(n);n=v.indexOf(n);if(p===Sk.builtin.none.none$)switch(a){case "Lt":return!0;case "LtE":return!0;case "Gt":return!1;case "GtE":return!1}if(h===Sk.builtin.none.none$)switch(a){case "Lt":return!1;case "LtE":return!1;case "Gt":return!0;case "GtE":return!0}if(-1!==r&&-1!==n)switch(a){case "Lt":return!0;case "LtE":return!0;case "Gt":return!1;
case "GtE":return!1}if(-1!==m&&-1!==l)switch(a){case "Lt":return!1;case "LtE":return!1;case "Gt":return!0;case "GtE":return!0}if(-1!==m&&-1!==n)switch(a){case "Lt":return m<n;case "LtE":return m<=n;case "Gt":return m>n;case "GtE":return m>=n}}if("Is"===a)return p===h;if("IsNot"===a)return p!==h;if("In"===a)return Sk.misceval.chain(Sk.abstr.sequenceContains(h,p,c),Sk.misceval.isTrue);if("NotIn"===a)return Sk.misceval.chain(Sk.abstr.sequenceContains(h,p,c),function(v){return!Sk.misceval.isTrue(v)});
n={Eq:"ob$eq",NotEq:"ob$ne",Gt:"ob$gt",GtE:"ob$ge",Lt:"ob$lt",LtE:"ob$le"};r=n[a];if(d&&(c=n[Sk.misceval.swappedOp_[a]],(c=h[c](p))!==Sk.builtin.NotImplemented.NotImplemented$)||(c=p[r](h))!==Sk.builtin.NotImplemented.NotImplemented$||!d&&(c=n[Sk.misceval.swappedOp_[a]],(c=h[c](p))!==Sk.builtin.NotImplemented.NotImplemented$))return Sk.misceval.isTrue(c);if(!Sk.__future__.python3){if(d=Sk.abstr.lookupSpecial(p,Sk.builtin.str.$cmp))try{c=Sk.misceval.callsimArray(d,[h]);if(Sk.builtin.checkNumber(c)){c=
Sk.builtin.asnum$(c);if("Eq"===a)return 0===c;if("NotEq"===a)return 0!==c;if("Lt"===a)return 0>c;if("Gt"===a)return 0<c;if("LtE"===a)return 0>=c;if("GtE"===a)return 0<=c}if(c!==Sk.builtin.NotImplemented.NotImplemented$)throw new Sk.builtin.TypeError("comparison did not return an int");}catch(v){throw new Sk.builtin.TypeError("comparison did not return an int");}if(d=Sk.abstr.lookupSpecial(h,Sk.builtin.str.$cmp))try{c=Sk.misceval.callsimArray(d,[p]);if(Sk.builtin.checkNumber(c)){c=Sk.builtin.asnum$(c);
if("Eq"===a)return 0===c;if("NotEq"===a)return 0!==c;if("Lt"===a)return 0<c;if("Gt"===a)return 0>c;if("LtE"===a)return 0<=c;if("GtE"===a)return 0>=c}if(c!==Sk.builtin.NotImplemented.NotImplemented$)throw new Sk.builtin.TypeError("comparison did not return an int");}catch(v){throw new Sk.builtin.TypeError("comparison did not return an int");}if(p===Sk.builtin.none.none$&&h===Sk.builtin.none.none$){if("Eq"===a)return p.v===h.v;if("NotEq"===a)return p.v!==h.v;if("Gt"===a)return p.v>h.v;if("GtE"===a)return p.v>=
h.v;if("Lt"===a)return p.v<h.v;if("LtE"===a)return p.v<=h.v}}if("Eq"===a)return p===h;if("NotEq"===a)return p!==h;p=Sk.abstr.typeName(p);h=Sk.abstr.typeName(h);throw new Sk.builtin.TypeError("'"+Sk.misceval.opSymbols[a]+"' not supported between instances of '"+p+"' and '"+h+"'");};Sk.exportSymbol("Sk.misceval.richCompareBool",Sk.misceval.richCompareBool);Sk.misceval.objectRepr=function(p){Sk.asserts.assert(void 0!==p,"trying to repr undefined");if(null!==p&&p.$r)return p.$r().v;try{return(new Sk.builtin.str(p)).v}catch(h){if(h instanceof
Sk.builtin.TypeError)return"<unknown>";throw h;}};Sk.exportSymbol("Sk.misceval.objectRepr",Sk.misceval.objectRepr);Sk.misceval.opAllowsEquality=function(p){switch(p){case "LtE":case "Eq":case "GtE":return!0}return!1};Sk.exportSymbol("Sk.misceval.opAllowsEquality",Sk.misceval.opAllowsEquality);Sk.misceval.isTrue=function(p){return!0===p||p===Sk.builtin.bool.true$?!0:!1===p||p===Sk.builtin.bool.false$||null===p||void 0===p?!1:p.nb$bool?p.nb$bool():p.sq$length?0!==p.sq$length():!!p};Sk.exportSymbol("Sk.misceval.isTrue",
Sk.misceval.isTrue);Sk.misceval.softspace_=!1;Sk.misceval.print_=function(p){Sk.misceval.softspace_&&("\n"!==p&&Sk.output(" "),Sk.misceval.softspace_=!1);var h=new Sk.builtin.str(p);return Sk.misceval.chain(Sk.importModule("sys",!1,!0),function(a){return Sk.misceval.apply(a.$d.stdout.write,void 0,void 0,void 0,[a.$d.stdout,h])},function(){var a;(a=0===h.v.length)||(a=h.v[h.v.length-1],a=!("\n"===a||"\t"===a||"\r"===a));if(a||" "===h.v[h.v.length-1])Sk.misceval.softspace_=!0})};Sk.exportSymbol("Sk.misceval.print_",
Sk.misceval.print_);Sk.misceval.loadname=function(p,h){h=h[p];if(void 0!==h)return h;h=Sk.builtins[p];if(void 0!==h)return h;throw new Sk.builtin.NameError("name '"+Sk.unfixReserved(p)+"' is not defined");};Sk.exportSymbol("Sk.misceval.loadname",Sk.misceval.loadname);Sk.misceval.call=function(p,h,a,c,m){m=Array.prototype.slice.call(arguments,4);return Sk.misceval.apply(p,h,a,c,m)};Sk.exportSymbol("Sk.misceval.call",Sk.misceval.call);Sk.misceval.callAsync=function(p,h,a,c,m,n){n=Array.prototype.slice.call(arguments,
5);return Sk.misceval.applyAsync(p,h,a,c,m,n)};Sk.exportSymbol("Sk.misceval.callAsync",Sk.misceval.callAsync);Sk.misceval.callOrSuspend=function(p,h,a,c,m){m=Array.prototype.slice.call(arguments,4);return Sk.misceval.applyOrSuspend(p,h,a,c,m)};Sk.exportSymbol("Sk.misceval.callOrSuspend",Sk.misceval.callOrSuspend);Sk.misceval.callsim=function(p,h){h=Array.prototype.slice.call(arguments,1);return Sk.misceval.apply(p,void 0,void 0,void 0,h)};Sk.exportSymbol("Sk.misceval.callsim",Sk.misceval.callsim);
Sk.misceval.callsimArray=function(p,h,a){h=h||[];return Sk.misceval.retryOptionalSuspensionOrThrow(Sk.misceval.callsimOrSuspendArray(p,h,a))};Sk.exportSymbol("Sk.misceval.callsimArray",Sk.misceval.callsimArray);Sk.misceval.callsimAsync=function(p,h,a){a=Array.prototype.slice.call(arguments,2);return Sk.misceval.applyAsync(p,h,void 0,void 0,void 0,a)};Sk.exportSymbol("Sk.misceval.callsimAsync",Sk.misceval.callsimAsync);Sk.misceval.callsimOrSuspend=function(p,h){h=Array.prototype.slice.call(arguments,
1);return Sk.misceval.applyOrSuspend(p,void 0,void 0,void 0,h)};Sk.exportSymbol("Sk.misceval.callsimOrSuspend",Sk.misceval.callsimOrSuspend);Sk.misceval.callsimOrSuspendArray=function(p,h,a){h=h||[];return void 0!==p&&p.tp$call?p.tp$call(h,a):Sk.misceval.applyOrSuspend(p,void 0,void 0,a,h)};Sk.exportSymbol("Sk.misceval.callsimOrSuspendArray",Sk.misceval.callsimOrSuspendArray);Sk.misceval.apply=function(p,h,a,c,m){p=Sk.misceval.applyOrSuspend(p,h,a,c,m);return p instanceof Sk.misceval.Suspension?Sk.misceval.retryOptionalSuspensionOrThrow(p):
p};Sk.exportSymbol("Sk.misceval.apply",Sk.misceval.apply);Sk.misceval.asyncToPromise=function(p,h){return new Promise(function(a,c){try{(function d(n){try{for(var l=function(){try{d(n.resume())}catch(w){c(w)}},r=function(w){try{n.data.result=w,l()}catch(C){c(C)}},v=function(w){try{n.data.error=w,l()}catch(C){c(C)}};n instanceof Sk.misceval.Suspension;){var q=h&&(h[n.data.type]||h["*"]);if(q){var t=q(n);if(t){t.then(d,c);return}}if("Sk.promise"==n.data.type){n.data.promise.then(r,v);return}if("Sk.yield"==
n.data.type){Sk.global.setImmediate(l);return}if("Sk.delay"==n.data.type){Sk.global.setImmediate(l);return}if(n.optional)n=n.resume();else throw new Sk.builtin.SuspensionError("Unhandled non-optional suspension of type '"+n.data.type+"'");}a(n)}catch(w){c(w)}})(p())}catch(m){c(m)}})};Sk.exportSymbol("Sk.misceval.asyncToPromise",Sk.misceval.asyncToPromise);Sk.misceval.applyAsync=function(p,h,a,c,m,n){return Sk.misceval.asyncToPromise(function(){return Sk.misceval.applyOrSuspend(h,a,c,m,n)},p)};Sk.exportSymbol("Sk.misceval.applyAsync",
Sk.misceval.applyAsync);Sk.misceval.chain=function(p,h){for(var a=1,c=p,m,n;;){if(a==arguments.length)return c;if(c&&c.$isSuspension)break;c=arguments[a](c);a++}n=Array(arguments.length-a);for(m=0;m<arguments.length-a;m++)n[m]=arguments[a+m];m=0;return function r(l){for(;m<n.length;){if(l instanceof Sk.misceval.Suspension)return new Sk.misceval.Suspension(r,l);l=n[m](l);m++}return l}(c)};Sk.exportSymbol("Sk.misceval.chain",Sk.misceval.chain);Sk.misceval.tryCatch=function(p,h){try{var a=p()}catch(c){return h(c)}return a instanceof
Sk.misceval.Suspension?(p=new Sk.misceval.Suspension(void 0,a),p.resume=function(){return Sk.misceval.tryCatch(a.resume,h)},p):a};Sk.exportSymbol("Sk.misceval.tryCatch",Sk.misceval.tryCatch);Sk.misceval.iterFor=function(p,h,a){var c=a,m=function(n){c=n;return n instanceof Sk.misceval.Break?n:p.tp$iternext(!0)};return function l(d){for(;void 0!==d;){if(d instanceof Sk.misceval.Suspension)return new Sk.misceval.Suspension(l,d);if(d===Sk.misceval.Break||d instanceof Sk.misceval.Break)return d.brValue;
d=Sk.misceval.chain(h(d,c),m)}return c}(p.tp$iternext(!0))};Sk.exportSymbol("Sk.misceval.iterFor",Sk.misceval.iterFor);Sk.misceval.iterArray=function(p,h,a){Sk.asserts.assert(Array.isArray(p),"iterArgs requires an array");let c=0;return Sk.misceval.iterFor({tp$iternext:()=>p[c++]},h,a)};Sk.misceval.arrayFromIterable=function(p,h){if(void 0===p)return[];if(void 0===p.ht$type&&void 0!==p.sk$asarray)return p.sk$asarray();const a=[];p=Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(p),c=>{a.push(c)}),
()=>a);return h?p:Sk.misceval.retryOptionalSuspensionOrThrow(p)};Sk.misceval.Break=function(p){if(!(this instanceof Sk.misceval.Break))return new Sk.misceval.Break(p);this.brValue=p};Sk.exportSymbol("Sk.misceval.Break",Sk.misceval.Break);Sk.misceval.applyOrSuspend=function(p,h,a,c,m){var n;if(null==p||p===Sk.builtin.none.none$)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(p)+"' object is not callable");"function"===typeof p&&void 0===p.tp$call&&(p=new Sk.builtin.func(p));var d=p.tp$call;if(void 0!==
d){if(a)for(a=a.tp$iter(),n=a.tp$iternext();void 0!==n;n=a.tp$iternext())m.push(n);if(h)for(a=Sk.abstr.iter(h),n=a.tp$iternext();void 0!==n;n=a.tp$iternext()){if(!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError("Function keywords must be strings");c.push(n.v);c.push(Sk.abstr.objectGetItem(h,n,!1))}return d.call(p,m,c,h)}d=p.__call__;if(void 0!==d)return m.unshift(p),Sk.misceval.apply(d,h,a,c,m);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(p)+"' object is not callable");};Sk.exportSymbol("Sk.misceval.applyOrSuspend",
Sk.misceval.applyOrSuspend);Sk.misceval.promiseToSuspension=function(p){var h=new Sk.misceval.Suspension;h.resume=function(){if(h.data.error)throw h.data.error;return h.data.result};h.data={type:"Sk.promise",promise:p};return h};Sk.exportSymbol("Sk.misceval.promiseToSuspension",Sk.misceval.promiseToSuspension);Sk.misceval.buildClass=function(p,h,a,c,m,n){a=new Sk.builtin.str(a);const d=new Sk.builtin.tuple(c);n=n||[];c=c||[];let l;var r=!0;const v=n.indexOf("metaclass");-1<v?(l=n[v+1],n[v]=n[n.length-
2],n[v+1]=n[n.length-1],n.pop(),n.pop(),r=Sk.builtin.checkClass(l)):l=c.length?c[0].ob$type:Sk.builtin.type;r&&(l=g(l,c));let q=null;l!==Sk.builtin.type&&([q,w]=k(l,a,d,n,r));c=!1;let t={};if(null===q)q=new Sk.builtin.dict([]);else if(q.constructor===Sk.builtin.dict||e()){var w=Sk.abstr.iter(Sk.misceval.callsimArray(q.tp$getattr(Sk.builtin.str.$keys)));for(r=w.tp$iternext();void 0!==r;r=w.tp$iternext())Sk.builtin.checkString(r)&&(t[r.toString()]=q.mp$subscript(r))}else t=new Proxy(q,w),c=!0;p.__name__&&
(t.__module__=p.__name__);h(p,t,void 0===m?{}:m);c||Object.keys(t).forEach(C=>{Sk.abstr.objectSetItem(q,new Sk.builtin.str(C),t[C])});return Sk.misceval.callsimOrSuspendArray(l,[a,d,q],n)};Sk.exportSymbol("Sk.misceval.buildClass",Sk.misceval.buildClass)},function(E,Q){Sk.builtin.callable_iter_=Sk.abstr.buildIteratorClass("callable_iterator",{constructor:function(b,f){if(!Sk.builtin.checkCallable(b))throw new Sk.builtin.TypeError("iter(v, w): v must be callable");this.$callable=b;this.$sentinel=f;
this.$flag=!1},iternext(b){if(!0!==this.$flag){if(b)return b=Sk.misceval.callsimOrSuspendArray(this.$callable,[]),Sk.misceval.chain(b,f=>{if(Sk.misceval.richCompareBool(f,this.$sentinel,"Eq",!0))this.$flag=!0;else return f});b=Sk.misceval.callsimArray(this.$callable,[]);if(Sk.misceval.richCompareBool(b,this.$sentinel,"Eq",!1))this.$flag=!0;else return b}},flags:{sk$unacceptableBase:!0}});Sk.builtin.seq_iter_=Sk.abstr.buildIteratorClass("iterator",{constructor:function(b){this.$index=0;this.$seq=b},
iternext(b){let f;f=Sk.misceval.tryCatch(()=>this.$seq.mp$subscript(new Sk.builtin.int_(this.$index++),b),e=>{if(e instanceof Sk.builtin.IndexError||e instanceof Sk.builtin.StopIteration)this.gi$ret=e.$value||Sk.builtin.none.none$;else throw e;});return b?f:Sk.misceval.retryOptionalSuspensionOrThrow(f)},methods:{__length_hint__:{$flags:{NoArgs:!0},$meth(){if(this.$seq.sq$length)return this.$seq.sq$length()-this.$index;throw new Sk.builtin.NotImplementedError("len is not implemented for "+Sk.abstr.typeName(this.$seq));
}}},flags:{sk$unacceptableBase:!0}});Sk.exportSymbol("Sk.builtin.callable_iter_",Sk.builtin.callable_iter_)},function(E,Q){Sk.builtin.list=Sk.abstr.buildNativeClass("list",{constructor:function(e){void 0===e?e=[]:Array.isArray(e)||(e=Sk.misceval.arrayFromIterable(e));Sk.asserts.assert(this instanceof Sk.builtin.list,"bad call to list, use 'new' with an Array of python objects");this.v=e;this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,
tp$doc:"Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",tp$new:Sk.generic.new,tp$init(e,g){Sk.abstr.checkNoKwargs("list",g);Sk.abstr.checkArgsLen("list",e,0,1);return Sk.misceval.chain(Sk.misceval.arrayFromIterable(e[0],!0),k=>{this.v=k})},$r(){if(this.in$repr)return new Sk.builtin.str("[...]");this.in$repr=!0;const e=this.v.map(g=>Sk.misceval.objectRepr(g));this.in$repr=!1;return new Sk.builtin.str("["+
e.join(", ")+"]")},tp$richcompare:Sk.generic.seqCompare,tp$iter(){return new b(this)},sq$length(){return this.v.length},sq$concat(e){if(!(e instanceof Sk.builtin.list))throw new Sk.builtin.TypeError("can only concatenate list to list");return new Sk.builtin.list(this.v.concat(e.v))},sq$contains(e){for(let g=this.tp$iter(),k=g.tp$iternext();void 0!==k;k=g.tp$iternext())if(k===e||Sk.misceval.richCompareBool(k,e,"Eq"))return!0;return!1},sq$repeat(e){if(!Sk.misceval.isIndex(e))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+
Sk.abstr.typeName(e)+"'");e=Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError);if(e*this.v.length>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;const g=[];for(let k=0;k<e;k++)for(let p=0;p<this.v.length;p++)g.push(this.v[p]);return new Sk.builtin.list(g)},mp$subscript(e){if(Sk.misceval.isIndex(e))return e=Sk.misceval.asIndexSized(e,Sk.builtin.IndexError),e=this.list$inRange(e,"list index out of range"),this.v[e];if(e instanceof Sk.builtin.slice){const g=[];e.sssiter$(this.v.length,
k=>{g.push(this.v[k])});return new Sk.builtin.list(g)}throw new Sk.builtin.TypeError("list indices must be integers or slices, not "+Sk.abstr.typeName(e));},mp$ass_subscript(e,g){void 0===g?this.del$subscript(e):this.ass$subscript(e,g)},sq$inplace_concat(e){return e===this?(this.v.push(...this.v),this):Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(e),g=>{this.v.push(g)}),()=>this)},sq$inplace_repeat(e){if(!Sk.misceval.isIndex(e))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+
Sk.abstr.typeName(e)+"'");e=Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError);const g=this.v.length;if(0>=e)this.v.length=0;else if(e*g>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;for(let k=1;k<e;k++)for(let p=0;p<g;p++)this.v.push(this.v[p]);return this}},methods:{__reversed__:{$meth(){return new f(this)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a reverse iterator over the list."},clear:{$meth(){this.v.length=0;return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Remove all items from list."},copy:{$meth(){return new Sk.builtin.list(this.v.slice(0))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a shallow copy of the list."},append:{$meth(e){this.v.push(e);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:"($self, object, /)",$doc:"Append object to the end of the list."},insert:{$meth(e,g){e=Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError);({start:e}=Sk.builtin.slice.startEnd$wrt(this,e));this.v.splice(e,0,g);return Sk.builtin.none.none$},
$flags:{MinArgs:2,MaxArgs:2},$textsig:"($self, index, object, /)",$doc:"Insert object before index."},extend:{$meth(e){return e===this?(this.v.push(...this.v),Sk.builtin.none.none$):Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(e),g=>{this.v.push(g)}),()=>Sk.builtin.none.none$)},$flags:{OneArg:!0},$textsig:"($self, iterable, /)",$doc:"Extend list by appending elements from the iterable."},pop:{$meth(e){e=void 0===e?this.v.length-1:Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError);e=this.list$inRange(e,
"pop index out of range");const g=this.v[e];this.v.splice(e,1);return g},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, index=-1, /)",$doc:"Remove and return item at index (default last).\n\nRaises IndexError if list is empty or index is out of range."},remove:{$meth(e){e=this.list$indexOf(e);if(-1===e)throw new Sk.builtin.ValueError("list.remove(x): x not in list");this.v.splice(e,1);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Remove first occurrence of value.\n\nRaises ValueError if the value is not present."},
sort:{$meth(e,g){if(e.length)throw new Sk.builtin.TypeError("sort() takes no positional arguments");const [k,p]=Sk.abstr.copyKeywordsToNamedArgs("sort",["key","reverse"],e,g,[Sk.builtin.none.none$,Sk.builtin.bool.false$]);return this.list$sort(void 0,k,p)},$flags:{FastCall:!0},$textsig:"($self, /, *, key=None, reverse=False)",$doc:"Stable sort *IN PLACE*."},index:{$meth(e,g,k){if(void 0!==g&&!Sk.misceval.isIndex(g)||void 0!==k&&!Sk.misceval.isIndex(k))throw new Sk.builtin.TypeError("slice indices must be integers or have an __index__ method");
g=this.list$indexOf(e,g,k);if(-1===g)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(e)+" is not in list");return new Sk.builtin.int_(g)},$flags:{MinArgs:1,MaxArgs:3},$textsig:"($self, value, start=0, stop=sys.maxsize, /)",$doc:"Return first index of value.\n\nRaises ValueError if the value is not present."},count:{$meth(e){let g=0;const k=this.v.length;for(let p=0;p<k;p++)if(this.v[p]===e||Sk.misceval.richCompareBool(this.v[p],e,"Eq"))g+=1;return new Sk.builtin.int_(g)},$flags:{OneArg:!0},
$textsig:"($self, value, /)",$doc:"Return number of occurrences of value."},reverse:{$meth(){this.list$reverse();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Reverse *IN PLACE*."}},classmethods:Sk.generic.classGetItem,proto:{sk$asarray(){return this.v.slice(0)},list$sort:function(e,g,k){const p=null!=g&&g!==Sk.builtin.none.none$;var h=null!=e&&e!==Sk.builtin.none.none$;let a;if(void 0===k)a=!1;else if(Sk.builtin.checkInt(k))a=Sk.misceval.isTrue(k);else throw new Sk.builtin.TypeError("an integer is required");
k=new Sk.builtin.timSort(this);this.v=[];const c=new Sk.builtin.int_(0);if(p){k.lt=h?function(m,n){m=Sk.misceval.callsimArray(e,[m[0],n[0]]);return Sk.misceval.richCompareBool(m,c,"Lt")}:function(m,n){return Sk.misceval.richCompareBool(m[0],n[0],"Lt")};for(let m=0;m<k.listlength;m++){h=k.list.v[m];const n=Sk.misceval.callsimArray(g,[h]);k.list.v[m]=[n,h]}}else h&&(k.lt=function(m,n){m=Sk.misceval.callsimArray(e,[m,n]);return Sk.misceval.richCompareBool(m,c,"Lt")});a&&k.list.list$reverse();k.sort();
a&&k.list.list$reverse();if(p)for(g=0;g<k.listlength;g++)h=k.list.v[g][1],k.list.v[g]=h;g=0<this.sq$length();this.v=k.list.v;if(g)throw new Sk.builtin.ValueError("list modified during sort");return Sk.builtin.none.none$},list$inRange(e,g){0>e&&(e+=this.v.length);if(0<=e&&e<this.v.length)return e;throw new Sk.builtin.IndexError(g);},list$indexOf(e,g,k){for({start:g,end:k}=Sk.builtin.slice.startEnd$wrt(this,g,k);g<k&&g<this.v.length;g++)if(this.v[g]===e||Sk.misceval.richCompareBool(this.v[g],e,"Eq"))return g;
return-1},list$reverse(){this.v.reverse()},ass$subscript(e,g){if(Sk.misceval.isIndex(e))this.ass$index(e,g);else if(e instanceof Sk.builtin.slice){const {start:k,stop:p,step:h}=e.slice$indices(this.v.length);1===h?this.ass$slice(k,p,g):this.ass$ext_slice(e,g)}else throw new Sk.builtin.TypeError("list indices must be integers or slices, not "+Sk.abstr.typeName(e));},ass$index(e,g){e=Sk.misceval.asIndexSized(e,Sk.builtin.IndexError);e=this.list$inRange(e,"list assignment index out of range");this.v[e]=
g},ass$slice(e,g,k){if(!Sk.builtin.checkIterable(k))throw new Sk.builtin.TypeError("can only assign an iterable");k=Sk.misceval.arrayFromIterable(k);this.v.splice(e,g-e,...k)},ass$ext_slice(e,g){const k=[];e.sssiter$(this.v.length,p=>{k.push(p)});if(!Sk.builtin.checkIterable(g))throw new Sk.builtin.TypeError("must assign iterable to extended slice");e=Sk.misceval.arrayFromIterable(g);if(k.length!==e.length)throw new Sk.builtin.ValueError("attempt to assign sequence of size "+e.length+" to extended slice of size "+
k.length);for(g=0;g<k.length;g++)this.v.splice(k[g],1,e[g])},del$subscript(e){if(Sk.misceval.isIndex(e))this.del$index(e);else if(e instanceof Sk.builtin.slice){const {start:g,stop:k,step:p}=e.slice$indices(this.v.length);1===p?this.del$slice(g,k):this.del$ext_slice(e,0<p?1:0)}else throw new Sk.builtin.TypeError("list indices must be integers, not "+Sk.abstr.typeName(e));},del$index(e){e=Sk.misceval.asIndexSized(e,Sk.builtin.IndexError);e=this.list$inRange(e,"list assignment index out of range");
this.v.splice(e,1)},del$slice(e,g){this.v.splice(e,g-e)},del$ext_slice(e,g){let k=0;e.sssiter$(this.v.length,p=>{this.v.splice(p-k,1);k+=g})},valueOf(){return this.v}}});Sk.exportSymbol("Sk.builtin.list",Sk.builtin.list);Sk.builtin.list.py2$methods={sort:{$name:"sort",$meth(e,g){const [k,p,h]=Sk.abstr.copyKeywordsToNamedArgs("sort",["cmp","key","reverse"],e,g,[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.bool.false$]);return this.list$sort(k,p,h)},$flags:{FastCall:!0},$textsig:"($self, cmp=None, key=None, reverse=False)",
$doc:"Stable sort *IN PLACE*."}};var b=Sk.abstr.buildIteratorClass("list_iterator",{constructor:function(e){this.$index=0;this.$seq=e.v},iternext:Sk.generic.iterNextWithArray,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}}),f=Sk.abstr.buildIteratorClass("list_reverseiterator",{constructor:function(e){this.$index=e.v.length-1;this.$seq=e.v},iternext(){const e=this.$seq[this.$index--];if(void 0===e)this.tp$iternext=()=>{};else return e},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef},
flags:{sk$unacceptableBase:!0}})},function(E,Q,b){function f(x){var B=x.replace(D,"").replace(L,"_").toLowerCase();B=C[B];return void 0===B?x:B}function e(x,B,F){if(void 0===B)B="utf-8";else if(Sk.builtin.checkString(B))B=B.$jsstr();else throw new Sk.builtin.TypeError(x+"() argument "+("bytesstr".includes(x)?2:1)+" must be str not "+Sk.abstr.typeName(B));if(void 0===F)F="strict";else if(Sk.builtin.checkString(F))F=F.$jsstr();else throw new Sk.builtin.TypeError(x+"() argument "+("bytesstr".includes(x)?
3:2)+" must be str not "+Sk.abstr.typeName(F));return{encoding:B,errors:F}}function g(x,B,F){x=x.$jsstr();B=f(B);if("strict"!==F&&"ignore"!==F&&"replace"!==F)throw new Sk.builtin.NotImplementedError("'"+F+"' error handling not implemented in Skulpt");if("ascii"===B){B=[];for(J in x){const P=x.charCodeAt(J);if(127<P){if("strict"===F)throw F=k(P),new Sk.builtin.UnicodeEncodeError("'ascii' codec can't encode character '"+F+"' in position "+J+": ordinal not in range(128)");"replace"===F&&B.push(63)}else B.push(P)}var J=
new Uint8Array(B)}else if("utf-8"===B)J=N.encode(x);else throw new Sk.builtin.LookupError("unknown encoding: "+B);return new Sk.builtin.bytes(J)}function k(x){var B=265>=x?"\\x":"\\u";x=x.toString(16);3===x.length&&(x=x.slice(1,3));return x=1===x.length?B+"0"+x:B+x}function p(x,B){({encoding:x,errors:B}=e("decode",x,B));x=f(x);if("strict"!==B&&"ignore"!==B&&"replace"!==B)throw new Sk.builtin.NotImplementedError("'"+B+"' error handling not implemented in Skulpt");if("ascii"===x){x=this.v;var F="";
for(let J=0;J<x.length;J++){const P=x[J];if(127<P){if("strict"===B)throw new Sk.builtin.UnicodeDecodeError("'ascii' codec can't decode byte 0x"+P.toString(16)+" in position "+J+": ordinal not in range(128)");"replace"===B&&(F+=String.fromCharCode(65533))}else F+=String.fromCharCode(P)}x=F}else if("utf-8"===x)a:if(x=this.v,F=B,B=A.decode(x),"replace"===F)x=B;else{if("strict"===F){F=B.indexOf("\ufffd");if(-1===F){x=B;break a}throw new Sk.builtin.UnicodeDecodeError("'utf-8' codec can't decode byte 0x"+
x[F].toString(16)+" in position "+F+": invalid start byte");}x=B.replace(/\ufffd/g,"")}else throw new Sk.builtin.LookupError("unknown encoding: "+x);return new Sk.builtin.str(x)}function h(x,B){return function(F,J,P){if(!(F instanceof Sk.builtin.bytes||F instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError(x+" first arg must be bytes or a tuple of bytes, not "+Sk.abstr.typeName(F));({start:J,end:P}=Sk.builtin.slice.startEnd$wrt(this,J,P));if(P<J)return Sk.builtin.bool.false$;J=this.v.subarray(J,
P);if(F instanceof Sk.builtin.tuple){for(let W=Sk.abstr.iter(F),ca=W.tp$iternext();void 0!==ca;ca=W.tp$iternext())if(ca=this.get$raw(ca),B(J,ca))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$}return B(J,F.v)?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function a(x){return function(B,F,J){B=this.get$tgt(B);({start:F,end:J}=Sk.builtin.slice.startEnd$wrt(this,F,J));return J<F?-1:"number"===typeof B?(B=x?this.v.lastIndexOf(B,J-1):this.v.indexOf(B,F),B>=F&&B<J?B:-1):x?this.find$subright(B,
F,J):this.find$subleft(B,F,J)}}function c(x){return function(B){B=this.get$raw(B);let F;if(x){if(F=this.find$subright(B,0,this.v.length),0>F)return new Sk.builtin.tuple([new Sk.builtin.bytes,new Sk.builtin.bytes,this])}else if(F=this.find$subleft(B,0,this.v.length),0>F)return new Sk.builtin.tuple([this,new Sk.builtin.bytes,new Sk.builtin.bytes]);return new Sk.builtin.tuple([new Sk.builtin.bytes(this.v.subarray(0,F)),new Sk.builtin.bytes(B),new Sk.builtin.bytes(this.v.subarray(F+B.length))])}}function m(x,
B){return function(F){var J=void 0===F||F===Sk.builtin.none.none$?new Uint8Array([9,10,11,12,13,32,133]):this.get$raw(F);F=0;var P=this.v.length;if(x)for(;F<P&&J.includes(this.v[F]);)F++;if(B)for(;P>F&&J.includes(this.v[P-1]);)P--;J=new Uint8Array(P-F);for(P=0;P<J.length;P++)J[P]=this.v[P+F];return new Sk.builtin.bytes(J)}}function n(x,B,F){return function(J,P){if(void 0===P)P=32;else if(P instanceof Sk.builtin.bytes&&1==P.v.length)P=P.v[0];else throw new Sk.builtin.TypeError(x+"() argument 2 must be a byte string of length 1, not "+
Sk.abstr.typeName(P));const W=this.v.length;J=Sk.misceval.asIndexSized(J,Sk.builtin.OverflowError);if(J<=W)return new Sk.builtin.bytes(this.v);const ca=new Uint8Array(J);let ha,oa;F?(ha=Math.floor((J-W)/2),oa=(J-W)%2?ha+1:ha):B?(ha=J-W,oa=0):(ha=0,oa=J-W);ca.fill(P,0,ha);for(let ka=0;ka<W;ka++)ca[ka+ha]=this.v[ka];ca.fill(P,J-oa);return new Sk.builtin.bytes(ca)}}function d(x){return 9<=x&&13>=x||32===x}function l(x){return 97<=x&&122>=x}function r(x){return 65<=x&&90>=x}function v(x){return 48<=x&&
57>=x}function q(x,B){return function(){return 0===this.v.length?B?Sk.builtin.bool.true$:Sk.builtin.bool.false$:this.v.every(F=>x(F))?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function t(x,B){return function(){let F=!1;for(let J=0;J<this.v.length;J++){if(B(this.v[J]))return Sk.builtin.bool.false$;!F&&x(this.v[J])&&(F=!0)}return F?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function w(x){return function(){const B=new Uint8Array(this.v.length);for(let F=0;F<this.v.length;F++)B[F]=x(this.v[F]);
return new Sk.builtin.bytes(B)}}b(30);const C={utf:"utf-8",utf8:"utf-8",utf_8:"utf-8",ascii:"ascii"};var D=/\s+/g,L=/[_-]+/g;const N=new TextEncoder,A=new TextDecoder;Sk.builtin.bytes=Sk.abstr.buildNativeClass("bytes",{constructor:function(x){if(!(this instanceof Sk.builtin.bytes))throw new TypeError("bytes is a constructor use 'new'");if(void 0===x)this.v=new Uint8Array;else if(x instanceof Uint8Array)this.v=x;else if(Array.isArray(x))Sk.asserts.assert(x.every(B=>0<=B&&255>=B),"bad internal call to bytes with array"),
this.v=new Uint8Array(x);else if("string"===typeof x){let B;const F=new Uint8Array(x.length),J=x.length;for(let P=0;P<J;P++){B=x.charCodeAt(P);if(255<B)throw new Sk.builtin.UnicodeDecodeError("invalid string at index "+P+" (possibly contains a unicode character)");F[P]=B}this.v=F}else if("number"===typeof x)this.v=new Uint8Array(x);else throw new TypeError(`bad internal argument to bytes constructor (got '${typeof x}': ${x})`);},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
tp$new(x,B){if(this!==Sk.builtin.bytes.prototype)return this.$subtype_new(x,B);B=B||[];let F;if(1>=x.length&&0===+B.length)x=x[0];else{[x,B,F]=Sk.abstr.copyKeywordsToNamedArgs("bytes",[null,"pySource","errors"],x,B);({encoding:B,errors:F}=e("bytes",B,F));if(!Sk.builtin.checkString(x))throw new Sk.builtin.TypeError("encoding or errors without a string argument");return g(x,B,F)}if(void 0===x)return new Sk.builtin.bytes;if(void 0!==(B=Sk.abstr.lookupSpecial(x,Sk.builtin.str.$bytes)))return x=Sk.misceval.callsimOrSuspendArray(B,
[]),Sk.misceval.chain(x,J=>{if(!Sk.builtin.checkBytes(J))throw new Sk.builtin.TypeError("__bytes__ returned non-bytes (type "+Sk.abstr.typeName(J)+")");return J});if(Sk.misceval.isIndex(x)){x=Sk.misceval.asIndexSized(x,Sk.builtin.OverflowError);if(0>x)throw new Sk.builtin.ValueError("negative count");return new Sk.builtin.bytes(x)}if(Sk.builtin.checkBytes(x))return new Sk.builtin.bytes(x.v);if(Sk.builtin.checkString(x))throw new Sk.builtin.TypeError("string argument without an encoding");if(Sk.builtin.checkIterable(x)){let J=
[];x=Sk.misceval.iterFor(Sk.abstr.iter(x),P=>{P=Sk.misceval.asIndexSized(P);if(0>P||255<P)throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");J.push(P)});return Sk.misceval.chain(x,()=>new Sk.builtin.bytes(J))}throw new Sk.builtin.TypeError("cannot convert '"+Sk.abstr.typeName(x)+"' object into bytes");},$r(){let x,B="'";const F=-1!==this.v.indexOf(34);let J="";for(let P=0;P<this.v.length;P++)if(x=this.v[P],9>x||10<x&&13>x||13<x&&32>x||126<x)J+=k(x);else if(9===x||10===x||13===x||39===
x||92===x)switch(x){case 9:J+="\\t";break;case 10:J+="\\n";break;case 13:J+="\\r";break;case 39:F?J+="\\'":(J+="'",B='"');break;case 92:J+="\\\\"}else J+=String.fromCharCode(x);return new Sk.builtin.str("b"+B+J+B)},tp$str(){return this.$r()},tp$iter(){return new H(this)},tp$richcompare(x,B){if(this===x&&Sk.misceval.opAllowsEquality(B))return!0;if(!(x instanceof Sk.builtin.bytes))return Sk.builtin.NotImplemented.NotImplemented$;const F=this.v;x=x.v;if(F.length!==x.length&&("Eq"===B||"NotEq"===B))return"Eq"===
B?!1:!0;let J;const P=Math.min(F.length,x.length);for(J=0;J<P&&F[J]===x[J];J++);switch(B){case "Lt":return J===P&&F.length<x.length||F[J]<x[J];case "LtE":return J===P&&F.length<=x.length||F[J]<=x[J];case "Eq":return J===P;case "NotEq":return J<P;case "Gt":return J===P&&F.length>x.length||F[J]>x[J];case "GtE":return J===P&&F.length>=x.length||F[J]>=x[J]}},tp$hash(){return(new Sk.builtin.str(this.$jsstr())).tp$hash()},tp$as_sequence_or_mapping:!0,mp$subscript(x){if(Sk.misceval.isIndex(x)){let B=Sk.misceval.asIndexSized(x,
Sk.builtin.IndexError);if(void 0!==B){0>B&&(B=this.v.length+B);if(0>B||B>=this.v.length)throw new Sk.builtin.IndexError("index out of range");return new Sk.builtin.int_(this.v[B])}}else if(x instanceof Sk.builtin.slice){const B=[];x.sssiter$(this.v.length,F=>{B.push(this.v[F])});return new Sk.builtin.bytes(new Uint8Array(B))}throw new Sk.builtin.TypeError("byte indices must be integers or slices, not "+Sk.abstr.typeName(x));},sq$length(){return this.v.length},sq$concat(x){if(!(x instanceof Sk.builtin.bytes))throw new Sk.builtin.TypeError("can't concat "+
Sk.abstr.typeName(x)+" to bytes");const B=new Uint8Array(this.v.length+x.v.length);let F;for(F=0;F<this.v.length;F++)B[F]=this.v[F];for(let J=0;J<x.v.length;J++,F++)B[F]=x.v[J];return new Sk.builtin.bytes(B)},sq$repeat(x){if(!Sk.misceval.isIndex(x))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(x)+"'");x=Sk.misceval.asIndexSized(x,Sk.builtin.OverflowError);const B=x*this.v.length;if(B>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;if(0>=
x)return new Sk.builtin.bytes;x=new Uint8Array(B);let F=0;for(;F<B;)for(let J=0;J<this.v.length;J++)x[F++]=this.v[J];return new Sk.builtin.bytes(x)},sq$contains(x){return-1!==this.find$left(x)},tp$as_number:!0,nb$remainder:Sk.builtin.str.prototype.nb$remainder},proto:{$jsstr(){let x="";for(let B=0;B<this.v.length;B++)x+=String.fromCharCode(this.v[B]);return x},get$tgt(x){if(x instanceof Sk.builtin.bytes)return x.v;x=Sk.misceval.asIndexOrThrow(x,"argument should be integer or bytes-like object, not {tp$name}");
if(0>x||255<x)throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");return x},get$raw(x){if(x instanceof Sk.builtin.bytes)return x.v;throw new Sk.builtin.TypeError("a bytes-like object is required, not '"+Sk.abstr.typeName(x)+"'");},get$splitArgs:function(x,B){B=Sk.misceval.asIndexSized(B,Sk.builtin.OverflowError);B=0>B?Infinity:B;x=Sk.builtin.checkNone(x)?null:this.get$raw(x);if(null!==x&&!x.length)throw new Sk.builtin.ValueError("empty separator");return{sep:x,maxsplit:B}},find$left:a(!1),
find$right:a(!0),find$subleft:function(x,B,F){F=F-x.length+1;let J=B;for(;J<F;){if(x.every((P,W)=>P===this.v[J+W]))return J;J++}return-1},find$subright(x,B,F){let J=F-x.length;for(;J>=B;){if(x.every((P,W)=>P===this.v[J+W]))return J;J--}return-1},$subtype_new(x,B){const F=new this.constructor;x=Sk.builtin.bytes.prototype.tp$new(x,B);F.v=x.v;return F},sk$asarray(){const x=[];this.v.forEach(B=>{x.push(new Sk.builtin.int_(B))});return x},valueOf(){return this.v}},flags:{str$encode:g,$decode:p,check$encodeArgs:e},
methods:{__getnewargs__:{$meth(){return new Sk.builtin.tuple(new Sk.builtin.bytes(this.v))},$flags:{NoArgs:!0},$textsig:null,$doc:null},capitalize:{$meth(){const x=this.v.length;if(0===x)return new Sk.builtin.bytes(this.v);const B=new Uint8Array(x);let F=this.v[0];B[0]=l(F)?F-32:F;for(let J=1;J<x;J++)F=this.v[J],B[J]=r(F)?F+32:F;return new Sk.builtin.bytes(B)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased."},
center:{$meth:n("center",!1,!0),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.center(width[, fillchar]) -> copy of B\n\nReturn B centered in a string of length width.  Padding is\ndone using the specified fill character (default is a space)."},count:{$meth(x,B,F){x=this.get$tgt(x);({start:B,end:F}=Sk.builtin.slice.startEnd$wrt(this,B,F));let J=0;if("number"===typeof x)for(;B<F;B++)this.v[B]===x&&J++;else{F=F-x.length+1;for(let P=B;P<F;P++)x.every((W,ca)=>W===this.v[P+ca])&&(J++,P+=x.length-1)}return new Sk.builtin.int_(J)},
$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of subsection sub in\nbytes B[start:end].  Optional arguments start and end are interpreted\nas in slice notation."},decode:{$meth:p,$flags:{NamedArgs:["encoding","errors"]},$textsig:"($self, /, encoding='utf-8', errors='strict')",$doc:"Decode the bytes using the codec registered for encoding.\n\n  encoding\n    The encoding with which to decode the bytes.\n  errors\n    The error handling scheme to use for the handling of decoding errors.\n    The default is 'strict' meaning that decoding errors raise a\n    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n    as well as any other name registered with codecs.register_error that\n    can handle UnicodeDecodeErrors."},
endswith:{$meth:h("endswith",(x,B)=>{const F=x.length-B.length;return 0<=F&&B.every((J,P)=>J===x[F+P])}),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if B ends with the specified suffix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nsuffix can also be a tuple of bytes to try."},expandtabs:{$meth(x){x=Sk.misceval.asIndexSized(x,Sk.builtin.OverflowError,"an integer is required (got type {tp$nam})");
const B=[];let F=0;for(let P=0;P<this.v.length;P++){var J=this.v[P];9===J?(J=x-F%x,B.push(...Array(J).fill(32)),F+=J):10===J||13===J?(B.push(J),F=0):(B.push(J),F++)}return new Sk.builtin.bytes(new Uint8Array(B))},$flags:{NamedArgs:["tabsize"],Defaults:[8]},$textsig:null,$doc:"B.expandtabs(tabsize=8) -> copy of B\n\nReturn a copy of B where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed."},find:{$meth:function(x,B,F){return new Sk.builtin.int_(this.find$left(x,
B,F))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},hex:{$meth(){let x="";for(let B=0;B<this.v.length;B++)x+=this.v[B].toString(16).padStart(2,"0");return new Sk.builtin.str(x)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.hex() -> string\n\nCreate a string of hexadecimal numbers from a bytes object.\nExample: b'\\xb9\\x01\\xef'.hex() -> 'b901ef'."},
index:{$meth:function(x,B,F){x=this.find$left(x,B,F);if(-1===x)throw new Sk.builtin.ValueError("subsection not found");return new Sk.builtin.int_(x)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the subsection is not found."},isalnum:{$meth:q(x=>v(x)||
l(x)||r(x)),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise."},isalpha:{$meth:q(x=>65<=x&&90>=x||97<=x&&122>=x),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise."},isascii:{$meth:q(x=>0<=x&&127>=x,!0),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise."},
isdigit:{$meth:q(v),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise."},islower:{$meth:t(l,r),$flags:{NoArgs:!0},$textsig:null,$doc:"B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise."},isspace:{$meth:q(d),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise."},
istitle:{$meth:function(){let x=!1,B=!1;for(let F=0;F<this.v.length;F++){const J=this.v[F];if(r(J)){if(x)return Sk.builtin.bool.false$;B=x=!0}else if(l(J)){if(!x)return Sk.builtin.bool.false$;B=!0}else x=!1}return B?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{NoArgs:!0},$textsig:null,$doc:"B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise."},
isupper:{$meth:t(r,l),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise."},join:{$meth(x){const B=[];let F=0;return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(x),J=>{if(!(J instanceof Sk.builtin.bytes))throw new Sk.builtin.TypeError("sequence item "+F+": expected a bytes-like object, "+Sk.abstr.typeName(J)+" found");F++;B.length&&B.push(...this.v);B.push(...J.v)}),
()=>new Sk.builtin.bytes(new Uint8Array(B)))},$flags:{OneArg:!0},$textsig:"($self, iterable_of_bytes, /)",$doc:"Concatenate any number of bytes objects.\n\nThe bytes whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytes object.\n\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'."},ljust:{$meth:n("ljust",!1,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.ljust(width[, fillchar]) -> copy of B\n\nReturn B left justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)."},
lower:{$meth:w(x=>r(x)?x+32:x),$flags:{NoArgs:!0},$textsig:null,$doc:"B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase."},lstrip:{$meth:m(!0,!1),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading  ASCII whitespace."},partition:{$meth:c(!1),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects."},
replace:{$meth(x,B,F){x=this.get$raw(x);B=this.get$raw(B);F=void 0===F?-1:Sk.misceval.asIndexSized(F,Sk.builtin.OverflowError);F=0>F?Infinity:F;const J=[];let P=0;for(var W=0;W<this.v.length&&P<F;){const ca=this.find$subleft(x,W,this.v.length);if(-1===ca)break;for(;W<ca;W++)J.push(this.v[W]);J.push(...B);W=ca+x.length;P++}for(W;W<this.v.length;W++)J.push(this.v[W]);return new Sk.builtin.bytes(new Uint8Array(J))},$flags:{MinArgs:2,MaxArgs:3},$textsig:"($self, old, new, count=-1, /)",$doc:"Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."},
rfind:{$meth(x,B,F){return new Sk.builtin.int_(this.find$right(x,B,F))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},rindex:{$meth:function(x,B,F){x=this.find$right(x,B,F);if(-1===x)throw new Sk.builtin.ValueError("subsection not found");return new Sk.builtin.int_(x)},
$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaise ValueError when the subsection is not found."},rjust:{$meth:n("rjust",!0,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.rjust(width[, fillchar]) -> copy of B\n\nReturn B right justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)"},
rpartition:{$meth:c(!0),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object."},rsplit:{$meth:function(x,B){({sep:x,
maxsplit:B}=this.get$splitArgs(x,B));const F=[];let J=0,P=this.v.length;if(null!==x){for(;0<=P&&J<B;){const W=this.find$subright(x,0,P);if(-1===W)break;F.push(new Sk.builtin.bytes(this.v.subarray(W+x.length,P)));P=W;J++}F.push(new Sk.builtin.bytes(this.v.subarray(0,P)))}else{for(P--;J<B;){for(;d(this.v[P]);)P--;if(0>P)break;x=P+1;for(P--;0<=P&&!d(this.v[P]);)P--;F.push(new Sk.builtin.bytes(this.v.subarray(P+1,x)));J++}if(0<=P){for(;d(this.v[P]);)P--;0<=P&&F.push(new Sk.builtin.bytes(this.v.subarray(0,
P+1)))}}return new Sk.builtin.list(F.reverse())},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytes and working to the front."},
rstrip:{$meth:m(!1,!0),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace."},split:{$meth:function(x,B){({sep:x,maxsplit:B}=this.get$splitArgs(x,B));const F=[],J=this.v.length;let P=0,W=0;if(null!==x){for(;W<J&&P<B;){const ca=this.find$subleft(x,W,J);if(-1===ca)break;F.push(new Sk.builtin.bytes(this.v.subarray(W,ca)));W=ca+x.length;P++}F.push(new Sk.builtin.bytes(this.v.subarray(W,
J)))}else{for(;P<B;){for(;d(this.v[W]);)W++;if(W===J)break;x=W;for(W++;W<J&&!d(this.v[W]);)W++;F.push(new Sk.builtin.bytes(this.v.subarray(x,W)));P++}if(W<J){for(;d(this.v[W]);)W++;W<J&&F.push(new Sk.builtin.bytes(this.v.subarray(W,J)))}}return new Sk.builtin.list(F)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."},
splitlines:{$meth(x){x=Sk.misceval.isTrue(x);const B=[];let F=0;let J=0;const P=this.v.length;for(;J<P;){var W=this.v[J];if(13===W){const ca=10===this.v[J+1];W=x?ca?J+2:J+1:J;B.push(new Sk.builtin.bytes(this.v.subarray(F,W)));J=F=ca?J+2:J+1}else 10===W?(W=x?J+1:J,B.push(new Sk.builtin.bytes(this.v.subarray(F,W))),J=F=J+1):J++}F<P&&B.push(new Sk.builtin.bytes(this.v.subarray(F,P)));return new Sk.builtin.list(B)},$flags:{NamedArgs:["keepends"],Defaults:[!1]},$textsig:"($self, /, keepends=False)",$doc:"Return a list of the lines in the bytes, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."},
startswith:{$meth:h("startswith",(x,B)=>B.length<=x.length&&B.every((F,J)=>F===x[J])),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if B starts with the specified prefix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nprefix can also be a tuple of bytes to try."},strip:{$meth:m(!0,!0),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace."},
swapcase:{$meth:w(x=>r(x)?x+32:l(x)?x-32:x),$flags:{NoArgs:!0},$textsig:null,$doc:"B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa."},title:{$meth(){const x=this.v.length,B=new Uint8Array(x);let F=!1;for(let J=0;J<x;J++){const P=this.v[J];r(P)?(B[J]=F?P+32:P,F=!0):l(P)?(B[J]=F?P:P-32,F=!0):(B[J]=P,F=!1)}return new Sk.builtin.bytes(B)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase."},
upper:{$meth:w(x=>l(x)?x-32:x),$flags:{NoArgs:!0},$textsig:null,$doc:"B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase."},zfill:{$meth(x){x=Sk.misceval.asIndexSized(x,Sk.builtin.IndexError);const B=x-this.v.length;if(0>=B)return new Sk.builtin.bytes(this.v);const F=new Uint8Array(x);let J=0,P;if(43===this.v[0]||45===this.v[0])F[0]=this.v[0],J++;F.fill(48,J,J+B);P=J;for(J+=B;J<x;J++,P++)F[J]=this.v[P];return new Sk.builtin.bytes(F)},$flags:{OneArg:!0},$textsig:null,
$doc:"B.zfill(width) -> copy of B\n\nPad a numeric string B with zeros on the left, to fill a field\nof the specified width.  B is never truncated."}},classmethods:{fromhex:{$meth:function(x){function B(ha){for(let oa=W;oa<ha;oa+=2){let ka=x.substr(oa,2);if(!J.test(ka))throw new Sk.builtin.ValueError("non-hexadecimal number found in fromhex() arg at position "+(oa+1));P.push(parseInt(ka,16))}}if(!Sk.builtin.checkString(x))throw new Sk.builtin.TypeError("fromhex() argument must be str, not "+Sk.abstr.typeName(x));
x=x.$jsstr();const F=/\s+/g,J=/^[abcdefABCDEF0123456789]{2}$/,P=[];let W=0,ca;for(;null!==(ca=F.exec(x));)B(ca.index),W=F.lastIndex;B(x.length);return new this(P)},$flags:{OneArg:!0},$textsig:"($type, string, /)",$doc:"Create a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'."}}});var H=Sk.abstr.buildIteratorClass("bytes_iterator",{constructor:function(x){this.$index=0;this.$seq=x.v},iternext(){const x=
this.$seq[this.$index++];if(void 0!==x)return new Sk.builtin.int_(x)},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}});Sk.exportSymbol("Sk.builtin.bytes",Sk.builtin.bytes)},function(E,Q,b){(function(f){(function(e){function g(){}function k(){}var p=String.fromCharCode,h={}.toString,a=h.call(e.SharedArrayBuffer),c=h(),m=e.Uint8Array,n=m||Array,d=m?ArrayBuffer:n,l=d.isView||function(t){return t&&"length"in t},r=h.call(d.prototype);d=k.prototype;
var v=e.TextEncoder,q=new (m?Uint16Array:n)(32);g.prototype.decode=function(t){if(!l(t)){var w=h.call(t);if(w!==r&&w!==a&&w!==c)throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");t=m?new n(t):t||[]}for(var C=w="",D=0,L=t.length|0,N=L-32|0,A,H,x=0,B=0,F,J=0,P=-1;D<L;){for(A=D<=N?32:L-D|0;J<A;D=D+1|0,J=J+1|0){H=t[D]&255;switch(H>>4){case 15:F=t[D=D+1|0]&255;if(2!==F>>6||247<H){D=D-1|0;break}x=(H&7)<<6|F&63;B=5;H=256;case 14:F=
t[D=D+1|0]&255,x<<=6,x|=(H&15)<<6|F&63,B=2===F>>6?B+4|0:24,H=H+256&768;case 13:case 12:F=t[D=D+1|0]&255,x<<=6,x|=(H&31)<<6|F&63,B=B+7|0,D<L&&2===F>>6&&x>>B&&1114112>x?(H=x,x=x-65536|0,0<=x&&(P=(x>>10)+55296|0,H=(x&1023)+56320|0,31>J?(q[J]=P,J=J+1|0,P=-1):(F=P,P=H,H=F))):(H>>=8,D=D-H-1|0,H=65533),x=B=0,A=D<=N?32:L-D|0;default:q[J]=H;continue;case 11:case 10:case 9:case 8:}q[J]=65533}C+=p(q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7],q[8],q[9],q[10],q[11],q[12],q[13],q[14],q[15],q[16],q[17],q[18],q[19],q[20],
q[21],q[22],q[23],q[24],q[25],q[26],q[27],q[28],q[29],q[30],q[31]);32>J&&(C=C.slice(0,J-32|0));if(D<L){if(q[0]=P,J=~P>>>31,P=-1,C.length<w.length)continue}else-1!==P&&(C+=p(P));w+=C;C=""}return w};d.encode=function(t){t=void 0===t?"":""+t;var w=t.length|0,C=new n((w<<1)+8|0),D,L=0,N=!m;for(D=0;D<w;D=D+1|0,L=L+1|0){var A=t.charCodeAt(D)|0;if(127>=A)C[L]=A;else{if(2047>=A)C[L]=192|A>>6;else{a:{if(55296<=A)if(56319>=A){var H=t.charCodeAt(D=D+1|0)|0;if(56320<=H&&57343>=H){A=(A<<10)+H-56613888|0;if(65535<
A){C[L]=240|A>>18;C[L=L+1|0]=128|A>>12&63;C[L=L+1|0]=128|A>>6&63;C[L=L+1|0]=128|A&63;continue}break a}A=65533}else 57343>=A&&(A=65533);!N&&D<<1<L&&D<<1<(L-7|0)&&(N=!0,H=new n(3*w),H.set(C),C=H)}C[L]=224|A>>12;C[L=L+1|0]=128|A>>6&63}C[L=L+1|0]=128|A&63}}return m?C.subarray(0,L):C.slice(0,L)};v||(e.TextDecoder=g,e.TextEncoder=k)})("undefined"==typeof f?"undefined"==typeof self?this:self:f)}).call(this,b(0))},function(E,Q){Sk.builtin.tuple=Sk.abstr.buildNativeClass("tuple",{constructor:function(f){void 0===
f?f=[]:Array.isArray(f)||(f=Sk.misceval.arrayFromIterable(f));Sk.asserts.assert(this instanceof Sk.builtin.tuple,"bad call to tuple, use 'new' with an Array of python objects");this.v=f;this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.",
$r(){if(this.in$repr)return new Sk.builtin.str("(...)");this.in$repr=!0;let f=this.v.map(e=>Sk.misceval.objectRepr(e));this.in$repr=!1;f=f.join(", ");1===this.v.length&&(f+=",");return new Sk.builtin.str("("+f+")")},tp$new(f,e){if(this!==Sk.builtin.tuple.prototype)return this.$subtype_new(f,e);Sk.abstr.checkNoKwargs("tuple",e);Sk.abstr.checkArgsLen("tuple",f,0,1);f=f[0];return void 0===f?new Sk.builtin.tuple([]):f.constructor===Sk.builtin.tuple?f:Sk.misceval.chain(Sk.misceval.arrayFromIterable(f,
!0),g=>new Sk.builtin.tuple(g))},tp$hash(){let f,e=3430008,g=1000003;const k=this.v.length;for(let p=0;p<k;++p){f=Sk.abstr.objectHash(this.v[p]);if(-1===f)return-1;e=(e^f)*g;g+=82520+k+k}e+=97531;-1===e&&(e=-2);return e|0},tp$richcompare:Sk.generic.seqCompare,tp$iter(){return new b(this)},mp$subscript(f){if(Sk.misceval.isIndex(f)){f=Sk.misceval.asIndexSized(f);0>f&&(f=this.v.length+f);if(0>f||f>=this.v.length)throw new Sk.builtin.IndexError("tuple index out of range");return this.v[f]}if(f instanceof
Sk.builtin.slice){const e=[];f.sssiter$(this.v.length,g=>{e.push(this.v[g])});return new Sk.builtin.tuple(e)}throw new Sk.builtin.TypeError("tuple indices must be integers or slices, not "+Sk.abstr.typeName(f));},sq$length(){return this.v.length},sq$repeat(f){f=Sk.misceval.asIndexSized(f,Sk.builtin.OverflowError);if(1===f&&this.constructor===Sk.builtin.tuple)return this;const e=[];for(let g=0;g<f;g++)for(let k=0;k<this.v.length;k++)e.push(this.v[k]);return new Sk.builtin.tuple(e)},sq$concat(f){if(!(f instanceof
Sk.builtin.tuple))throw new Sk.builtin.TypeError("can only concatenate tuple (not '"+Sk.abstr.typeName(f)+"') to tuple");return new Sk.builtin.tuple(this.v.concat(f.v))},sq$contains(f){for(let e=this.tp$iter(),g=e.tp$iternext();void 0!==g;g=e.tp$iternext())if(g===f||Sk.misceval.richCompareBool(g,f,"Eq"))return!0;return!1}},proto:{$subtype_new(f,e){e=new this.constructor;f=Sk.builtin.tuple.prototype.tp$new(f);e.v=f.v;return e},sk$asarray(){return this.v.slice(0)},valueOf(){return this.v}},methods:{__getnewargs__:{$meth(){return new Sk.builtin.tuple(this.v.slice(0))},
$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:null},index:{$meth(f,e,g){if(void 0!==e&&!Sk.misceval.isIndex(e)||void 0!==g&&!Sk.misceval.isIndex(g))throw new Sk.builtin.TypeError("slice indices must be integers or have an __index__ method");({start:e,end:g}=Sk.builtin.slice.startEnd$wrt(this,e,g));const k=this.v;for(;e<g;e++)if(k[e]===f||Sk.misceval.richCompareBool(k[e],f,"Eq"))return new Sk.builtin.int_(e);throw new Sk.builtin.ValueError("tuple.index(x): x not in tuple");},$flags:{MinArgs:1,MaxArgs:3},
$textsig:"($self, value, start=0, stop=sys.maxsize, /)",$doc:"Return first index of value.\n\nRaises ValueError if the value is not present."},count:{$meth(f){const e=this.v.length,g=this.v;let k=0;for(let p=0;p<e;++p)if(g[p]===f||Sk.misceval.richCompareBool(g[p],f,"Eq"))k+=1;return new Sk.builtin.int_(k)},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Return number of occurrences of value."}},classmethods:Sk.generic.classGetItem});Sk.exportSymbol("Sk.builtin.tuple",Sk.builtin.tuple);var b=
Sk.abstr.buildIteratorClass("tuple_iterator",{constructor:function(f){this.$index=0;this.$seq=f.sk$asarray()},iternext:Sk.generic.iterNextWithArray,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}})},function(E,Q){function b(t){let w=t.$savedKeyHash;return void 0!==w?w:w=Sk.abstr.objectHash(t)}function f(t){return new Sk.builtin.set(Sk.misceval.arrayFromIterable(t))}function e(t,w){for(let C=Sk.abstr.iter(t),D=C.tp$iternext();void 0!==D;D=C.tp$iternext())if(!Sk.abstr.sequenceContains(w,
D))return!1;return!0}function g(t,w,C){const D={constructor:function(L){if(1!==arguments.length)throw new Sk.builtin.TypeError("cannot create '"+Sk.abstr.typeName(this)+"' instances");this.dict=L;this.in$repr=!1}};D.slots=Object.assign(w,h);D.methods={isdisjoint:{$meth(L){const N=f(this);return N.isdisjoint.$meth.call(N,L)},$flags:{OneArg:!0},$textsig:null,$doc:"Return True if the view and the given iterable have a null intersection."},__reversed__:{$meth:C,$flags:{NoArgs:!0},$textsig:null,$doc:"Return a reverse iterator over the dict keys."}};
D.flags={sk$acceptable_as_base:!1};"dict_values"===t&&(delete D.slots.tp$as_number,delete D.slots.tp$richcompare);return Sk.abstr.buildNativeClass(t,D)}function k(t,w,C){return Sk.abstr.buildIteratorClass(t,{constructor:function(D){this.$index=0;this.$orig=D;this.tp$iternext=()=>{this.$seq=D.$items();this.$version=D.$version;C&&(this.$seq=this.$seq.reverse());this.tp$iternext=this.constructor.prototype.tp$iternext;return this.tp$iternext()}},iternext:w,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},
flags:{sk$unacceptableBase:!0},proto:{next$item:p}})}function p(){if(this.$version!==this.$orig.$version){if(this.$seq.length!==this.$orig.get$size())throw new Sk.builtin.RuntimeError("dict changed size during iteration");throw new Sk.builtin.RuntimeError("dictionary keys changed during iteration");}return this.$seq[this.$index++]}Sk.builtin.dict=Sk.abstr.buildNativeClass("dict",{constructor:function(t){void 0===t&&(t=[]);Sk.asserts.assert(Array.isArray(t)&&0===t.length%2&&this instanceof Sk.builtin.dict,
"bad call to dict constructor");this.size=0;this.entries=Object.create(null);this.buckets={};for(let w=0;w<t.length;w+=2)this.set$item(t[w],t[w+1]);this.in$repr=!1;this.$version=0},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$as_number:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
$r(){if(this.in$repr)return new Sk.builtin.str("{...}");this.in$repr=!0;const t=this.$items().map(w=>{var [C,D]=w;return Sk.misceval.objectRepr(C)+": "+Sk.misceval.objectRepr(D)});this.in$repr=!1;return new Sk.builtin.str("{"+t.join(", ")+"}")},tp$new:Sk.generic.new,tp$init(t,w){return this.update$common(t,w,"dict")},tp$iter(){return new n(this)},tp$richcompare(t,w){let C;if(!(t instanceof Sk.builtin.dict)||"Eq"!==w&&"NotEq"!==w)return Sk.builtin.NotImplemented.NotImplemented$;if(t===this)C=!0;else if(this.size!==
t.size)C=!1;else{let D;C=this.$items().every(L=>{var [N,A]=L;D=t.mp$lookup(N);return void 0!==D&&(D===A||Sk.misceval.richCompareBool(A,D,"Eq"))})}return"Eq"===w?C:!C},nb$or(t){if(!(t instanceof Sk.builtin.dict))return Sk.builtin.NotImplemented.NotImplemented$;const w=this.dict$copy();w.dict$merge(t);return w},nb$reflected_or(t){if(!(t instanceof Sk.builtin.dict))return Sk.builtin.NotImplemented.NotImplemented$;t=t.dict$copy();t.dict$merge(this);return t},nb$inplace_or(t){return Sk.misceval.chain(this.update$onearg(t),
()=>this)},sq$length(){return this.get$size()},sq$contains(t){return void 0!==this.mp$lookup(t)},mp$subscript(t,w){var C=this.mp$lookup(t);if(void 0!==C)return C;C=Sk.abstr.lookupSpecial(this,Sk.builtin.str.$missing);if(void 0!==C)return t=Sk.misceval.callsimOrSuspendArray(C,[t]),w?t:Sk.misceval.retryOptionalSuspensionOrThrow(t);throw new Sk.builtin.KeyError(t);},mp$ass_subscript(t,w){if(void 0===w){if(void 0===this.pop$item(t))throw new Sk.builtin.KeyError(t);}else this.set$item(t,w)}},methods:{__reversed__:{$meth(){return new r(this)},
$flags:{NoArgs:!0},$textsig:null,$doc:"Return a reverse iterator over the dict keys."},get:{$meth(t,w){return this.mp$lookup(t)||w||Sk.builtin.none.none$},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, key, default=None, /)",$doc:"Return the value for key if key is in the dictionary, else default."},setdefault:{$meth(t,w){let C;const D=b(t);C="string"===typeof D?this.entries[D]:this.get$bucket_item(t,D);if(void 0!==C)return C[1];w=w||Sk.builtin.none.none$;"string"===typeof D?this.entries[D]=[t,w]:
this.set$bucket_item(t,w,D);this.size++;this.$version++;return w},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, key, default=None, /)",$doc:"Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default."},pop:{$meth(t,w){const C=this.pop$item(t);if(void 0!==C)return C[1];if(void 0!==w)return w;throw new Sk.builtin.KeyError(t);},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised"},
popitem:{$meth(){const t=this.get$size();if(0===t)throw new Sk.builtin.KeyError("popitem(): dictionary is empty");const [w,C]=this.$items()[t-1];this.pop$item(w);return new Sk.builtin.tuple([w,C])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.popitem() -> (k, v), remove and return some (key, value) pair as a\n2-tuple; but raise KeyError if D is empty."},keys:{$meth(){return new a(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$meth(){return new m(this)},
$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$meth(){return new c(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> an object providing a view on D's values"},update:{$meth(t,w){return Sk.misceval.chain(this.update$common(t,w,"update"),()=>Sk.builtin.none.none$)},$flags:{FastCall:!0},$textsig:null,$doc:"D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]"},
clear:{$meth(){this.size=0;this.$version++;this.entries=Object.create(null);this.buckets={}},$flags:{NoArgs:!0},$textsig:null,$doc:"D.clear() -> None.  Remove all items from D."},copy:{$meth(){return this.dict$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"D.copy() -> a shallow copy of D"}},classmethods:Object.assign({fromkeys:{$meth:function(t,w){w=w||Sk.builtin.none.none$;let C=this===Sk.builtin.dict?new this:this.tp$call([],[]);return Sk.misceval.chain(C,D=>{C=D;return Sk.misceval.iterFor(Sk.abstr.iter(t),
L=>C.mp$ass_subscript(L,w,!0))},()=>C)},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($type, iterable, value=None, /)",$doc:"Create a new dictionary with keys from iterable and values set to value."}},Sk.generic.classGetItem),proto:{quick$lookup:function(t){t=this.entries[t.$savedKeyHash];if(void 0!==t)return t[1]},mp$lookup:function(t){const w=b(t);t="string"===typeof w?this.entries[w]:this.get$bucket_item(t,w);if(void 0!==t)return t[1]},get$size(){return this.size},sk$asarray(){return Object.values(this.entries).map(t=>
t[0])},update$common:function(t,w,C){Sk.abstr.checkArgsLen(C,t,0,1);t=t[0];let D;void 0!==t&&(D=this.update$onearg(t));return Sk.misceval.chain(D,()=>{if(w)for(let L=0;L<w.length;L+=2)this.set$item(new Sk.builtin.str(w[L]),w[L+1])})},update$onearg(t){return t instanceof Sk.builtin.dict||void 0!==Sk.abstr.lookupSpecial(t,Sk.builtin.str.$keys)?this.dict$merge(t):this.dict$merge_seq(t)},dict$copy(){const t=new Sk.builtin.dict([]);t.size=this.size;var w=Object.entries(this.entries);for(var C in w){var D=
w[C][1];t.entries[w[C][0]]=[D[0],D[1]]}for(let L in this.buckets)for(C=this.buckets[L],t.buckets[L]=w=[],D=0;D<C.length;D++)w.push(t.entries["#"+L+"_"+D]);return t},$items(){return Object.values(this.entries)},set$item:function(t,w){const C=b(t);let D;"string"===typeof C?(D=this.entries[C],void 0===D?(this.entries[C]=[t,w],this.size++,this.$version++):D[1]=w):(D=this.get$bucket_item(t,C),void 0===D?(this.set$bucket_item(t,w,C),this.size++,this.$version++):D[1]=w)},get$bucket_item:function(t,w){w=
this.buckets[w];if(void 0!==w)for(let D=0;D<w.length;D++){var C=w[D];if(void 0!==C&&(C[0]===t||Sk.misceval.richCompareBool(t,C[0],"Eq")))return C}},pop$bucket_item:function(t,w){const C=this.buckets[w];let D;if(void 0!==C)for(let L=0;L<C.length;L++)if(D=C[L],void 0!==D&&(D[0]===t||Sk.misceval.richCompareBool(t,D[0],"Eq")))return delete this.entries["#"+w+"_"+L],C[L]=void 0,C.every(N=>void 0===N)&&delete this.buckets[w],D},set$bucket_item:function(t,w,C){let D=this.buckets[C];t=[t,w];void 0===D?(this.buckets[C]=
[t],C="#"+C+"_0"):(w=D.indexOf(void 0),-1!==w?(C="#"+C+"_"+w,D[w]=t):(C="#"+C+"_"+D.length,D.push(t)));this.entries[C]=t},pop$item:function(t){const w=b(t);"string"===typeof w?(t=this.entries[w],delete this.entries[w]):t=this.pop$bucket_item(t,w);if(void 0!==t)return this.size--,this.$version++,t},dict$merge:function(t){if(t.tp$iter===Sk.builtin.dict.prototype.tp$iter){var w=t.tp$iter();for(let C=w.tp$iternext();void 0!==C;C=w.tp$iternext()){const D=t.mp$subscript(C);this.set$item(C,D)}}else{w=Sk.abstr.lookupSpecial(t,
Sk.builtin.str.$keys);if(void 0===w)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(t)+"' object is not a mapping");return Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(w),C=>Sk.misceval.iterFor(Sk.abstr.iter(C),D=>Sk.misceval.chain(Sk.abstr.objectGetItem(t,D,!0),L=>{this.set$item(D,L)})))}},dict$merge_seq:function(t){let w=0;return Sk.misceval.iterFor(Sk.abstr.iter(t),C=>{if(!Sk.builtin.checkIterable(C))throw new Sk.builtin.TypeError("cannot convert dictionary update sequence element #"+
w+" to a sequence");C=Sk.misceval.arrayFromIterable(C);if(2!==C.length)throw new Sk.builtin.ValueError("dictionary update sequence element #"+w+" has length "+C.length+"; 2 is required");this.set$item(C[0],C[1]);w++})}}});const h={tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,$r(){if(this.in$repr)return new Sk.builtin.str("...");this.in$repr=!0;let t=Sk.misceval.arrayFromIterable(this);t=t.map(w=>Sk.misceval.objectRepr(w));this.in$repr=!1;
return new Sk.builtin.str(Sk.abstr.typeName(this)+"(["+t.join(", ")+"])")},tp$richcompare(t,w){if(!(Sk.builtin.checkAnySet(t)||t instanceof a||t instanceof m))return Sk.builtin.NotImplemented.NotImplemented$;const C=this.sq$length(),D=t.sq$length();switch(w){case "NotEq":case "Eq":let L;this===t?L=!0:C===D&&(L=e(this,t));return"NotEq"===w?!L:L;case "Lt":return C<D&&e(this,t);case "LtE":return C<=D&&e(this,t);case "Gt":return C>D&&e(t,this);case "GtE":return C>=D&&e(t,this)}},nb$subtract(t){const w=
f(this);return w.difference.$meth.call(w,t)},nb$and(t){const w=f(this);return w.intersection.$meth.call(w,t)},nb$or(t){const w=f(this);return w.union.$meth.call(w,t)},nb$xor(t){const w=f(this);return w.symmetric_difference.$meth.call(w,t)},sq$length(){return this.dict.get$size()}};var a=g("dict_keys",{sq$contains(t){return void 0!==this.dict.mp$lookup(t)},tp$iter(){return new n(this.dict)}},function(){return new r(this.dict)}),c=g("dict_values",{tp$iter(){return new l(this.dict)}},function(){return new q(this.dict)}),
m=g("dict_items",{sq$contains(t){if(!(t instanceof Sk.builtin.tuple&&2===t.sq$length()))return!1;var w=t.mp$subscript(new Sk.builtin.int_(0));t=t.mp$subscript(new Sk.builtin.int_(1));w=this.dict.mp$lookup(w);return void 0===w?!1:w===t||Sk.misceval.richCompareBool(w,t,"Eq")},tp$iter(){return new d(this.dict)}},function(){return new v(this.dict)}),n=k("dict_keyiterator",function(){const t=this.next$item();return t&&t[0]}),d=k("dict_itemiterator",function(){const t=this.next$item();return t&&new Sk.builtin.tuple([t[0],
t[1]])}),l=k("dict_valueiterator",function(){const t=this.next$item();return t&&t[1]}),r=k("dict_reversekeyiterator",n.prototype.tp$iternext,!0),v=k("dict_reverseitemiterator",d.prototype.tp$iternext,!0),q=k("dict_reversevalueiterator",l.prototype.tp$iternext,!0);Sk.builtin.dict.py2$methods={has_key:{$name:"has_key",$flags:{OneArg:!0},$meth(t){return new Sk.builtin.bool(this.sq$contains(t))},$doc:"D.has_key(k) -> True if D has a key k, else False"},keys:{$name:"keys",$meth(){return new Sk.builtin.list(this.sk$asarray())},
$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$name:"items",$meth(){return new Sk.builtin.list(this.$items().map(t=>{var [w,C]=t;return new Sk.builtin.tuple([w,C])}))},$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$name:"values",$meth(){return new Sk.builtin.list(this.$items().map(t=>{[,t]=t;return t}))},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> an object providing a view on D's values"}}},
function(E,Q){function b(f,e){Object.defineProperties(f,{entries:{get:()=>{const g=Object.create(null);Object.entries(e).forEach(k=>{var [p,h]=k;p=Sk.unfixReserved(p);p.includes("$")||(p=new Sk.builtin.str(p),g[p.$savedKeyHash]=[p,h])});return g},configurable:!0},size:{get:()=>Object.keys(e).map(g=>Sk.unfixReserved(g)).filter(g=>!g.includes("$")).length,configurable:!0}})}Sk.builtin.mappingproxy=Sk.abstr.buildNativeClass("mappingproxy",{constructor:function(f){Sk.asserts.assert(this instanceof Sk.builtin.mappingproxy,
"bad call to mapping proxy, use 'new'");this.mapping=new Sk.builtin.dict([]);void 0!==f&&b(this.mapping,f)},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$new(f,e){Sk.abstr.checkNoKwargs("mappingproxy",e);Sk.abstr.checkOneArg("mappingproxy",f,e);f=f[0];if(!Sk.builtin.checkMapping(f))throw new Sk.builtin.TypeError("mappingproxy() argument must be a mapping, not "+Sk.abstr.typeName(f));e=new Sk.builtin.mappingproxy;e.mapping=f;return e},tp$richcompare(f,
e){return Sk.misceval.richCompareBool(this.mapping,f,e)},tp$str(){return this.mapping.tp$str()},$r(){return new Sk.builtin.str("mappingproxy("+Sk.misceval.objectRepr(this.mapping)+")")},mp$subscript(f,e){return this.mapping.mp$subscript(f,e)},sq$contains(f){return this.mapping.sq$contains(f)},sq$length(){return this.mapping.sq$length()},tp$iter(){return this.mapping.tp$iter()},tp$as_number:!0,nb$or(f){f instanceof Sk.builtin.mappingproxy&&(f=f.mapping);return Sk.abstr.numberBinOp(this.mapping,f,"BitOr")},
nb$reflected_or(f){f instanceof Sk.builtin.mappingproxy&&(f=f.mapping);return Sk.abstr.numberBinOp(f,this.mapping,"BitOr")},nb$inplace_or(f){throw new Sk.builtin.TypeError("'|=' is not supported by "+Sk.abstr.typeName(this)+"; use '|' instead");}},methods:{get:{$meth(f,e){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$get),f,e)},$flags:{FastCall:!0},$textsig:null,$doc:"D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."},keys:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$keys),
[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$items),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$values),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> a set-like object providing a view on D's values"},copy:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$copy),
[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.copy() -> a shallow copy of D"}},classmethods:Sk.generic.classGetItem,proto:{str$get:new Sk.builtin.str("get"),str$copy:new Sk.builtin.str("copy"),str$keys:new Sk.builtin.str("keys"),str$items:new Sk.builtin.str("items"),str$values:new Sk.builtin.str("values"),mp$lookup(f){return this.mapping.mp$lookup(f)}},flags:{sk$unacceptableBase:!0}})},function(E,Q){Sk.builtin.property=Sk.abstr.buildNativeClass("property",{constructor:function(b,f,e,g){this.prop$get=
b||Sk.builtin.none.none$;this.prop$set=f||Sk.builtin.none.none$;this.prop$del=e||Sk.builtin.none.none$;this.prop$doc=g||b&&b.$doc||Sk.builtin.none.none$},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,tp$init(b,f){b=Sk.abstr.copyKeywordsToNamedArgs("property",["fget","fset","fdel","doc"],b,f,Array(4).fill(Sk.builtin.none.none$));this.prop$get=b[0];this.prop$set=b[1];this.prop$del=b[2];Sk.builtin.checkNone(b[3])?Sk.builtin.checkNone(b[0])||(this.prop$doc=b[0].$doc||b[3]):this.prop$doc=
b[3]},tp$doc:"Property attribute.\n\n  fget\n    function to be used for getting an attribute value\n  fset\n    function to be used for setting an attribute value\n  fdel\n    function to be used for del'ing an attribute\n  doc\n    docstring\n\nTypical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, 'I'm the 'x' property.')\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        'I am the 'x' property.'\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x",
tp$descr_get(b,f,e){if(null===b)return this;if(void 0===this.prop$get)throw new Sk.builtin.AttributeError("unreadable attribute");b=Sk.misceval.callsimOrSuspendArray(this.prop$get,[b]);return e?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)},tp$descr_set(b,f,e){let g;g=null==f?this.prop$del:this.prop$set;if(Sk.builtin.checkNone(g))throw new Sk.builtin.AttributeError("can't "+(null==f?"delete":"set")+" attribute");if(!g.tp$call)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(g)+"' is not callable");
b=null==f?g.tp$call([b]):g.tp$call([b,f]);return e?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)}},methods:{getter:{$meth(b){return new Sk.builtin.property(b,this.prop$set,this.prop$del,this.prop$doc)},$flags:{OneArg:!0}},setter:{$meth(b){return new Sk.builtin.property(this.prop$get,b,this.prop$del,this.prop$doc)},$flags:{OneArg:!0}},deleter:{$meth(b){return new Sk.builtin.property(this.prop$get,this.prop$set,b,this.prop$doc)},$flags:{OneArg:!0}}},getsets:{fget:{$get(){return this.prop$get}},fset:{$get(){return this.prop$set}},
fdel:{$get(){return this.prop$del}},__doc__:{$get(){return this.prop$doc},$set(b){this.prop$doc=b=b||Sk.builtin.none.none$}}}});Sk.builtin.classmethod=Sk.abstr.buildNativeClass("classmethod",{constructor:function(b){this.cm$callable=b;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,tp$init(b,f){Sk.abstr.checkNoKwargs("classmethod",f);Sk.abstr.checkArgsLen("classmethod",b,1,1);this.cm$callable=b[0]},tp$doc:"classmethod(function) -> method\n\nConvert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, ...):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
tp$descr_get(b,f,e){const g=this.cm$callable;if(void 0===g)throw new Sk.builtin.RuntimeError("uninitialized classmethod object");void 0===f&&(f=b.ob$type);return(b=g.tp$descr_get)?b.call(g,f,e):new Sk.builtin.method(g,f)}},getsets:{__func__:{$get(){return this.cm$callable}},__dict__:Sk.generic.getSetDict}});Sk.builtin.staticmethod=Sk.abstr.buildNativeClass("staticmethod",{constructor:function(b){this.sm$callable=b;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,
tp$init(b,f){Sk.abstr.checkNoKwargs("staticmethod",f);Sk.abstr.checkArgsLen("staticmethod",b,1,1);this.sm$callable=b[0]},tp$doc:"staticmethod(function) -> method\n\nConvert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, ...):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
tp$descr_get(b,f){if(void 0===this.sm$callable)throw new Sk.builtin.RuntimeError("uninitialized staticmethod object");return this.sm$callable}},getsets:{__func__:{$get(){return this.sm$callable}},__dict__:Sk.generic.getSetDict}})},function(E,Q){function b(A,H){return function(x){if(!(x instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;let B=this.v;x=x.v;if("number"===typeof B&&"number"===typeof x){const F=A(B,x);if(m(F))return new Sk.builtin.int_(F)}B=d(B);x=d(x);return new Sk.builtin.int_(H(B,
x))}}function f(A,H){return function(x){if(!(x instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;let B=this.v;x=x.v;if("number"===typeof B&&"number"===typeof x)return A(B,x);B=d(B);x=d(x);return H(B,x)}}function e(A,H){return function(){let x=this.v;if("number"===typeof x){const B=A(x);if(void 0!==B)return new Sk.builtin.int_(B);x=d(x)}return new Sk.builtin.int_(H(x))}}function g(){return new Sk.builtin.int_(this.v)}function k(A,H){return function(x){if(!(x instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;
let B=this.v;x=x.v;if(0===x)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");if("number"===typeof B&&"number"===typeof x)return new Sk.builtin.int_(A(B,x));B=d(B);x=d(x);return new Sk.builtin.int_(JSBI.numberIfSafe(H(B,x)))}}function p(A,H){return function(x){if(!(x instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;if(x.nb$isnegative())throw new Sk.builtin.ValueError("negative shift count");let B=this.v;if(0===B)return new Sk.builtin.int_(0);
x=x.v;if("number"===typeof B&&"number"===typeof x&&53>x){const F=A(B,x);if(void 0!==F)return new Sk.builtin.int_(F)}B=d(B);x=d(x);return new Sk.builtin.int_(H(B,x))}}function h(A,H){return function(x){if(!(x instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;let B=this.v;x=x.v;if("number"===typeof B&&"number"===typeof x&&Math.abs(B)<Math.pow(2,31)&&Math.abs(x)<Math.pow(2,31))return new Sk.builtin.int_(A(B,x));B=d(B);x=d(x);return new Sk.builtin.int_(JSBI.numberIfSafe(H(B,
x)))}}function a(A){return JSBI.lessThan(A,JSBI.__ZERO)?JSBI.unaryMinus(A):A}function c(A,H){if(JSBI.greaterThanOrEqual(JSBI.bitwiseXor(A,H),JSBI.__ZERO))return JSBI.divide(A,H);A=JSBI.lessThan(A,JSBI.__ZERO)?JSBI.add(A,q):JSBI.subtract(A,q);return JSBI.subtract(JSBI.divide(A,H),q)}function m(A){return A<=Number.MAX_SAFE_INTEGER&&A>=-Number.MAX_SAFE_INTEGER}function n(A){return A<=Number.MAX_SAFE_INTEGER&&A>=-Number.MAX_SAFE_INTEGER?+A:JSBI.BigInt(A)}function d(A){return"number"===typeof A?JSBI.BigInt(A):
A}Sk.builtin.int_=Sk.abstr.buildNativeClass("int",{constructor:function(A){Sk.asserts.assert(this instanceof Sk.builtin.int_,"bad call to int use 'new'");let H;if("number"===typeof A){if(-6<A&&257>A)return L[A];H=A}else if(JSBI.__isBigInt(A))H=A;else{if(void 0===A)return N;if("string"===typeof A)H=n(A);else{if(A.nb$int)return A.nb$int();Sk.asserts.fail("bad argument to int constructor")}}this.v=H},slots:{tp$as_number:!0,tp$doc:"int(x=0) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
$r(){return new Sk.builtin.str(this.v.toString())},tp$hash(){const A=this.v;return"number"===typeof A?A:JSBI.toNumber(JSBI.remainder(A,JSBI.__MAX_SAFE))},tp$new(A,H){1===A.length+(H?H.length:0)?(H=A[0],A=Sk.builtin.none.none$):(A=Sk.abstr.copyKeywordsToNamedArgs("int",[null,"base"],A,H,[N,Sk.builtin.none.none$]),H=A[0],A=A[1]);A=A!==Sk.builtin.none.none$?Sk.misceval.asIndexOrThrow(A):null;if(H instanceof Sk.builtin.str)null===A&&(A=10),H=new Sk.builtin.int_(Sk.str2number(H.v,A));else{if(null!==A)throw new Sk.builtin.TypeError("int() can't convert non-string with explicit base");
if(H.nb$int)H=H.nb$int();else if(A=Sk.abstr.lookupSpecial(H,Sk.builtin.str.$trunc)){A=Sk.misceval.callsimArray(A,[]);if(!Sk.builtin.checkInt(A))throw new Sk.builtin.TypeError(Sk.builtin.str.$trunc.$jsstr()+" returned non-Integral (type "+Sk.abstr.typeName(H)+")");H=new Sk.builtin.int_(A.v)}else throw new Sk.builtin.TypeError("int() argument must be a string, a bytes-like object or a number, not '"+Sk.abstr.typeName(H)+"'");}if(this===Sk.builtin.int_.prototype)return H;A=new this.constructor;A.v=H.v;
return A},tp$getattr:Sk.generic.getAttr,ob$eq:f((A,H)=>A==H,JSBI.equal),ob$ne:f((A,H)=>A!=H,JSBI.notEqual),ob$gt:f((A,H)=>A>H,JSBI.greaterThan),ob$ge:f((A,H)=>A>=H,JSBI.greaterThanOrEqual),ob$lt:f((A,H)=>A<H,JSBI.lessThan),ob$le:f((A,H)=>A<=H,JSBI.lessThanOrEqual),nb$int:g,nb$index(){return this.v},nb$float(){var A=this.v;if("number"===typeof A)return new Sk.builtin.float_(A);A=parseFloat(JSBI.toNumber(A));if(Infinity===A||-Infinity===A)throw new Sk.builtin.OverflowError("int too large to convert to float");
return new Sk.builtin.float_(A)},nb$isnegative(){const A=this.v;return"number"===typeof A?0>A:JSBI.lessThan(A,JSBI.__ZERO)},nb$ispositive(){const A=this.v;return"number"===typeof A?0<=A:JSBI.greaterThanOrEqual(A,JSBI.__ZERO)},nb$bool(){return 0!==this.v},nb$positive:g,nb$negative:e(A=>-A,JSBI.unaryMinus),nb$add:b((A,H)=>A+H,(A,H)=>JSBI.numberIfSafe(JSBI.add(A,H))),nb$subtract:b((A,H)=>A-H,(A,H)=>JSBI.numberIfSafe(JSBI.subtract(A,H))),nb$multiply:b((A,H)=>A*H,(A,H)=>A===JSBI.__ZERO||H===JSBI.__ZERO?
0:JSBI.multiply(A,H)),nb$divide:function(A){if(!Sk.__future__.python3)return this.nb$floor_divide(A);if(!(A instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;var H=this.v,x=A.v;if(0===x)throw new Sk.builtin.ZeroDivisionError("division by zero");if("number"===typeof H&&"number"===typeof x)return new Sk.builtin.float_(H/x);H=d(H);x=d(x);A=JSBI.lessThan(JSBI.bitwiseXor(H,x),JSBI.__ZERO);if(JSBI.equal(H,JSBI.__ZERO))return new Sk.builtin.float_(A?-0:0);H=a(H);x=a(x);if(JSBI.greaterThanOrEqual(H,
JSBI.multiply(t,x)))throw new Sk.builtin.OverflowError("int/int too large to represent as a float");var B=H.toString(2).length-x.toString(2).length,F=JSBI.BigInt(0>B?-B:B);if(0<=B&&JSBI.greaterThanOrEqual(H,JSBI.multiply(JSBI.exponentiate(v,F),x))||0>B&&JSBI.greaterThanOrEqual(JSBI.multiply(H,JSBI.exponentiate(v,F)),x))B+=1;B=Math.max(B,r)-l;H=JSBI.leftShift(H,JSBI.BigInt(Math.max(-B,0)));x=JSBI.leftShift(x,JSBI.BigInt(Math.max(B,0)));F=JSBI.divide(H,x);H=JSBI.remainder(H,x);H=JSBI.multiply(v,H);
if(JSBI.greaterThan(H,x)||JSBI.equal(H,x)&&JSBI.equal(JSBI.remainder(F,v),q))F=JSBI.add(F,q);F=JSBI.toNumber(F);if(Infinity===F||-Infinity===F)throw new Sk.builtin.OverflowError("int/int too large to represent as a float");x=F*Math.pow(2,B);return new Sk.builtin.float_(A?-x:x)},nb$floor_divide:k((A,H)=>Math.floor(A/H),c),nb$remainder:k((A,H)=>A-Math.floor(A/H)*H,(A,H)=>JSBI.subtract(A,JSBI.multiply(H,c(A,H)))),nb$divmod(A){const H=this.nb$floor_divide(A);A=this.nb$remainder(A);return H===Sk.builtin.NotImplemented.NotImplemented$||
A===Sk.builtin.NotImplemented.NotImplemented$?Sk.builtin.NotImplemented.NotImplemented$:new Sk.builtin.tuple([H,A])},nb$and:h((A,H)=>A&H,JSBI.bitwiseAnd),nb$or:h((A,H)=>A|H,JSBI.bitwiseOr),nb$xor:h((A,H)=>A^H,JSBI.bitwiseXor),nb$abs:e(Math.abs,a),nb$lshift:p((A,H)=>{A=2*A*C[H];if(m(A))return A},JSBI.leftShift),nb$rshift:p((A,H)=>{Math.floor(A/C[H+1])},(A,H)=>JSBI.numberIfSafe(JSBI.signedRightShift(A,H))),nb$invert:e(A=>Math.abs(A)<Math.pow(2,31)?~A:void 0,A=>JSBI.numberIfSafe(JSBI.bitwiseNot(A))),
nb$power(A,H){let x;void 0!==H&&Sk.builtin.checkNone(H)&&(H=void 0);if(!(A instanceof Sk.builtin.int_&&(void 0===H||H instanceof Sk.builtin.int_)))return Sk.builtin.NotImplemented.NotImplemented$;const B=A.nb$isnegative();if(B&&void 0===H)return this.nb$float().nb$power(A.nb$float());let F=this.v;A=A.v;if("number"===typeof F&&"number"===typeof A){const J=Math.pow(F,A);if(m(J)&&(x=new Sk.builtin.int_(J),void 0===H))return x}if(void 0!==H){if(B)throw new Sk.builtin.ValueError("pow() 2nd argument cannot be negative when 3rd argument specified");
if(0===H.v)throw new Sk.builtin.ValueError("pow() 3rd argument cannot be 0");return void 0!==x?x.nb$remainder(H):new Sk.builtin.int_(JSBI.powermod(d(F),d(A),d(H.v)))}return new Sk.builtin.int_(JSBI.exponentiate(d(F),d(A)))},nb$long(){return new Sk.builtin.lng(this.v)}},getsets:{real:{$get:g,$doc:"the real part of a complex number"},imag:{$get(){return N},$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth:g,$flags:{NoArgs:!0},$textsig:null,$doc:"Returns self, the complex conjugate of any int."},
bit_length:{$meth(){let A=this.v;if(0===A)return new Sk.builtin.int_(0);A="number"===typeof A?Math.abs(A):a(A);return new Sk.builtin.int_(A.toString(2).length)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6"},to_bytes:{$meth(){throw new Sk.builtin.NotImplementedError("Not yet implemented in Skulpt");},$flags:{FastCall:!0},$textsig:"($self, /, length, byteorder, *, signed=False)",$doc:"Return an array of bytes representing an integer.\n\n  length\n    Length of bytes object to use.  An OverflowError is raised if the\n    integer is not representable with the given number of bytes.\n  byteorder\n    The byte order used to represent the integer.  If byteorder is 'big',\n    the most significant byte is at the beginning of the byte array.  If\n    byteorder is 'little', the most significant byte is at the end of the\n    byte array.  To request the native byte order of the host system, use\n    `sys.byteorder' as the byte order value.\n  signed\n    Determines whether two's complement is used to represent the integer.\n    If signed is False and a negative integer is given, an OverflowError\n    is raised."},
__trunc__:{$meth:g,$flags:{NoArgs:!0},$textsig:null,$doc:"Truncating an Integral returns itself."},__floor__:{$meth:g,$flags:{NoArgs:!0},$textsig:null,$doc:"Flooring an Integral returns itself."},__ceil__:{$meth:g,$flags:{NoArgs:!0},$textsig:null,$doc:"Ceiling of an Integral returns itself."},__round__:{$meth(A){return this.round$(A)},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"Rounding an Integral returns itself.\nRounding with an ndigits argument also returns an integer."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([new Sk.builtin.int_(this.v)])},
$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:Sk.builtin.none.none$},__format__:{$meth:Sk.formatting.mkNumber__format__(!1),$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:Sk.builtin.none.none$}},proto:{str$(A,H){A=void 0===A||10===A?this.v.toString():this.v.toString(A);H||void 0===H||"-"===A[0]&&(A=A.substring(1));return A},round$(A){A=void 0===A?0:Sk.misceval.asIndexSized(A);var H=this.v;if(0<=A)return new Sk.builtin.int_(H);if("number"!==typeof H){{var x=A;(A=JSBI.lessThan(H,JSBI.__ZERO))&&
(H=JSBI.unaryMinus(H));x=JSBI.exponentiate(JSBI.BigInt(10),JSBI.unaryMinus(JSBI.BigInt(x)));let B=JSBI.divide(H,x);H=JSBI.remainder(H,x);H=JSBI.multiply(H,v);JSBI.greaterThan(H,x)?B=JSBI.add(B,q):JSBI.equal(H,x)&&(Sk.__future__.bankers_rounding?JSBI.equal(JSBI.remainder(B,v),q)&&(B=JSBI.add(B,q)):B=JSBI.add(B,q));B=JSBI.multiply(B,x);A&&(B=JSBI.unaryMinus(B));A=new Sk.builtin.int_(B)}return A}A=Math.pow(10,-A);if(A/10>Math.abs(H))return new Sk.builtin.int_(0);if(!Sk.__future__.bankers_rounding)return new Sk.builtin.int_(Math.round(H/
A)*A);H/=A;x=Math.round(H);return new Sk.builtin.int_((.5===(0<H?H:-H)%1?0===x%2?x:x-1:x)*A)},valueOf(){return this.v}}});Sk.exportSymbol("Sk.builtin.int_",Sk.builtin.int_);const l=Math.log2(Number.MAX_SAFE_INTEGER);E=JSBI.BigInt(Math.floor(Math.log2(Number.MAX_VALUE)));const r=Math.ceil(Math.log2(Number.MIN_VALUE)),v=JSBI.BigInt(2),q=JSBI.BigInt(1),t=JSBI.subtract(JSBI.exponentiate(v,E),JSBI.exponentiate(v,JSBI.subtract(E,JSBI.add(JSBI.BigInt(l),q)))),w=/_(?=[^_])/g;Sk.str2number=function(A,H){var x=
A,B=!1,F;A=A.replace(/^\s+|\s+$/g,"");"-"===A.charAt(0)&&(B=!0,A=A.substring(1));"+"===A.charAt(0)&&(A=A.substring(1));if(null===H||void 0===H)H=10;if((2>H||36<H)&&0!==H)throw new Sk.builtin.ValueError("int() base must be >= 2 and <= 36");"string"===typeof H&&(H=Number(H));if("0x"===A.substring(0,2).toLowerCase())if(16===H||0===H)A=A.substring(2),H=16;else{if(34>H)throw new Sk.builtin.ValueError("invalid literal for int() with base "+H+": '"+x+"'");}else if("0b"===A.substring(0,2).toLowerCase())if(2===
H||0===H)A=A.substring(2),H=2;else{if(12>H)throw new Sk.builtin.ValueError("invalid literal for int() with base "+H+": '"+x+"'");}else if("0o"===A.substring(0,2).toLowerCase())if(8===H||0===H)A=A.substring(2),H=8;else{if(25>H)throw new Sk.builtin.ValueError("invalid literal for int() with base "+H+": '"+x+"'");}else if("0"===A.charAt(0)){if("0"===A)return 0;if(8===H||0===H)H=8}0===H&&(H=10);if(-1!==A.indexOf("_")){if(-1!==A.indexOf("__"))throw new Sk.builtin.ValueError("invalid literal for int() with base "+
H+": '"+x+"'");A=10!==H?A.replace(w,""):A.charAt(0)+A.substring(1).replace(w,"")}if(0===A.length)throw new Sk.builtin.ValueError("invalid literal for int() with base "+H+": '"+x+"'");for(F=0;F<A.length;F+=1){var J=A.charCodeAt(F);var P=H;48<=J&&57>=J?P=J-48:65<=J&&90>=J?P=J-65+10:97<=J&&122>=J&&(P=J-97+10);if(P>=H)throw new Sk.builtin.ValueError("invalid literal for int() with base "+H+": '"+x+"'");}B&&(A="-"+A);P=parseInt(A,H);if(m(P))return P;x=!1;"-"===A[0]&&(x=!0,A=A.substring(1));H=JSBI.BigInt(H);
B=q;F=JSBI.__ZERO;for(J=A.length-1;0<=J;J--)P=A.charCodeAt(J),48<=P&&57>=P?P-=48:65<=P&&90>=P?P=P-65+10:97<=P&&122>=P&&(P=P-97+10),P=JSBI.multiply(JSBI.BigInt(P),B),F=JSBI.add(F,P),B=JSBI.multiply(B,H);x&&(F=JSBI.multiply(F,JSBI.BigInt(-1)));return A=F};Sk.builtin.int_.py2$methods={};Sk.longFromStr=function(A,H){if(Sk.__future__.python3)return new Sk.builtin.int_(n(A));A=Sk.str2number(A,H);return new Sk.builtin.lng(A)};Sk.exportSymbol("Sk.longFromStr",Sk.longFromStr);Sk.builtin.int_.withinThreshold=
m;Sk.builtin.int_.stringToNumberOrBig=n;const C=[.5,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,0x800000000000,281474976710656,562949953421312,0x4000000000000,
0x8000000000000,4503599627370496,9007199254740992];Sk.builtin.lng=Sk.abstr.buildNativeClass("long",{base:Sk.builtin.int_,constructor:function(A){A=Sk.builtin.int_.call(this,A);void 0!==A&&(this.v=A.v)},slots:{$r(){return new Sk.builtin.str(this.v.toString()+"L")},tp$as_number:!0,nb$negative(){return new Sk.builtin.lng(D.nb$negative.call(this).v)},nb$positive(){return new Sk.builtin.lng(D.nb$positive.call(this).v)}}});const D=Sk.builtin.int_.prototype,L=[];for(E=-5;257>E;E++)L[E]=Object.create(Sk.builtin.int_.prototype,
{v:{value:E}});const N=L[0]},function(E,Q){const b=Sk.builtin.int_.prototype;Sk.builtin.bool=Sk.abstr.buildNativeClass("bool",{constructor:function(f){return Sk.misceval.isTrue(f)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},base:Sk.builtin.int_,slots:{tp$doc:"bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",tp$new(f,e){Sk.abstr.checkNoKwargs("bool",
e);Sk.abstr.checkArgsLen("bool",f,0,1);return new Sk.builtin.bool(f[0])},$r(){return this.v?this.str$True:this.str$False},tp$as_number:!0,nb$and(f){return f.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v&f.v):b.nb$and.call(this,f)},nb$or(f){return f.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v|f.v):b.nb$or.call(this,f)},nb$xor(f){return f.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v^f.v):b.nb$xor.call(this,f)}},flags:{sk$unacceptableBase:!0},methods:{__format__:{$meth(){return this.$r()},
$flags:{OneArg:!0}}},proto:{str$False:new Sk.builtin.str("False"),str$True:new Sk.builtin.str("True"),valueOf(){return!!this.v}}});Sk.exportSymbol("Sk.builtin.bool",Sk.builtin.bool);Sk.builtin.bool.true$=Object.create(Sk.builtin.bool.prototype,{v:{value:1,enumerable:!0}});Sk.builtin.bool.false$=Object.create(Sk.builtin.bool.prototype,{v:{value:0,enumerable:!0}})},function(E,Q){function b(){return new Sk.builtin.float_(this.v)}function f(d){return function(l){const r=this.v;l=l.v;if("number"!==typeof l)if(JSBI.__isBigInt(l)){if(l=
parseFloat(JSBI.toNumber(l)),Infinity==l||-Infinity==l)throw new Sk.builtin.OverflowError("int too large to convert to float");}else return Sk.builtin.NotImplemented.NotImplemented$;return d(r,l)}}function e(d,l){return function(r){const v=this.v;r=r.v;if("number"!==typeof r){if(!JSBI.__isBigInt(r))return Sk.builtin.NotImplemented.NotImplemented$;if(void 0!==l)return l(v,r)}return d(v,r)}}function g(d){const l=f(d);return function(r,v){if(void 0!==v&&!Sk.builtin.checkNone(v))throw new Sk.builtin.TypeError("pow() 3rd argument not allowed unless all arguments are integers");
return l.call(this,r)}}function k(d,l){if(0===l)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");return Infinity===d?Infinity===l||-Infinity===d?new Sk.builtin.float_(NaN):0>l?new Sk.builtin.float_(-Infinity):new Sk.builtin.float_(Infinity):-Infinity===d?Infinity===l||-Infinity===d?new Sk.builtin.float_(NaN):0>l?new Sk.builtin.float_(Infinity):new Sk.builtin.float_(-Infinity):new Sk.builtin.float_(d/l)}function p(d,l){if(Infinity===d||-Infinity===d)return new Sk.builtin.float_(NaN);
if(0===l)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");return Infinity===l?0>d?new Sk.builtin.float_(-1):new Sk.builtin.float_(0):-Infinity===l?0>d||0!==d?new Sk.builtin.float_(0):new Sk.builtin.float_(-1):new Sk.builtin.float_(Math.floor(d/l))}function h(d,l){if(0===l)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");if(0===d)return new Sk.builtin.float_(0);if(Infinity===l)return Infinity===d||-Infinity===this.v?new Sk.builtin.float_(NaN):
0<d?new Sk.builtin.float_(d):new Sk.builtin.float_(Infinity);let r=d%l;0>d?0<l&&0>r&&(r+=l):0>l&&0!==r&&(r+=l);0===r&&(0>l?r=-0:-Infinity===Infinity/r&&(r=0));return new Sk.builtin.float_(r)}function a(d,l){if(0>d&&0!==l%1)throw new Sk.builtin.ValueError("negative number cannot be raised to a fractional power");if(0===d&&0>l)throw new Sk.builtin.ZeroDivisionError("0.0 cannot be raised to a negative power");const r=Math.pow(d,l);if(Infinity===Math.abs(r)&&Infinity!==Math.abs(d)&&Infinity!==Math.abs(l))throw new Sk.builtin.OverflowError("Numerical result out of range");
return new Sk.builtin.float_(r)}const c=Object.create(null,{Infinity:{value:314159},"-Infinity":{value:-314159},NaN:{value:0}});Sk.builtin.float_=Sk.abstr.buildNativeClass("float",{constructor:function(d){Sk.asserts.assert(this instanceof Sk.builtin.float_,"bad call to float use 'new'");if("number"===typeof d)this.v=d;else if(void 0===d)this.v=0;else if("string"===typeof d)this.v=parseFloat(d);else{if(d.nb$float)return d.nb$float();Sk.asserts.fail("bad argument to float constructor")}},slots:{tp$getattr:Sk.generic.getAttr,
tp$as_number:!0,tp$doc:"Convert a string or number to a floating point number, if possible.",tp$hash(){const d=this.v;let l=c[d];if(void 0!==l)return l;l=Number.isInteger(d)?this.nb$int().tp$hash():Math.floor(Math.random()*Number.MAX_SAFE_INTEGER-Number.MAX_SAFE_INTEGER/2);return c[this.v]=l},$r(){return new Sk.builtin.str(this.str$(10,!0))},tp$new(d,l){if(l&&l.length)throw new Sk.builtin.TypeError("float() takes no keyword arguments");if(d&&1<d.length)throw new Sk.builtin.TypeError("float expected at most 1 arguments, got "+
d.length);d=d[0];if(void 0===d)var r=new Sk.builtin.float_(0);else if(d.nb$float)r=d.nb$float();else if(Sk.builtin.checkString(d)){r=d.v;d=r;if(-1!==r.indexOf("_")){if(m.test(r))throw new Sk.builtin.ValueError("could not convert string to float: '"+r+"'");d=r.charAt(0)+r.substring(1).replace(n,"")}if(r.match(/^-inf$/i))var v=-Infinity;else r.match(/^[+]?inf$/i)?v=Infinity:r.match(/^[-+]?nan$/i)?v=NaN:isNaN(d)||(v=parseFloat(d),Number.isNaN(v)&&(v=void 0));if(void 0===v)throw new Sk.builtin.ValueError("could not convert string to float: "+
Sk.misceval.objectRepr(new Sk.builtin.str(r)));r=new Sk.builtin.float_(v)}if(void 0===r)throw new Sk.builtin.TypeError("float() argument must be a string or a number");if(this===Sk.builtin.float_.prototype)return r;v=new this.constructor;v.v=r.v;return v},nb$int(){let d=this.v;if(!Number.isFinite(d)){if(Infinity===d||-Infinity===d)throw new Sk.builtin.OverflowError("cannot convert float infinity to integer");throw new Sk.builtin.ValueError("cannot convert float NaN to integer");}d=0>d?Math.ceil(d):
Math.floor(d);return Sk.builtin.int_.withinThreshold(d)?new Sk.builtin.int_(d):new Sk.builtin.int_(JSBI.BigInt(d))},nb$float:b,nb$long(){return new Sk.builtin.lng(this.nb$int().v)},nb$add:f((d,l)=>new Sk.builtin.float_(d+l)),nb$subtract:f((d,l)=>new Sk.builtin.float_(d-l)),nb$reflected_subtract:f((d,l)=>new Sk.builtin.float_(l-d)),nb$multiply:f((d,l)=>new Sk.builtin.float_(d*l)),nb$divide:f(k),nb$reflected_divide:f((d,l)=>k(l,d)),nb$floor_divide:f(p),nb$reflected_floor_divide:f((d,l)=>p(l,d)),nb$remainder:f(h),
nb$reflected_remainder:f((d,l)=>h(l,d)),nb$divmod:f((d,l)=>new Sk.builtin.tuple([p(d,l),h(d,l)])),nb$reflected_divmod:f((d,l)=>new Sk.builtin.tuple([p(l,d),h(l,d)])),nb$power:g(a),nb$reflected_power:g((d,l)=>a(l,d)),nb$abs(){return new Sk.builtin.float_(Math.abs(this.v))},nb$negative(){return new Sk.builtin.float_(-this.v)},nb$positive(){return new Sk.builtin.float_(this.v)},nb$bool(){return 0!==this.v},nb$isnegative(){return 0>this.v},nb$ispositive(){return 0<=this.v},ob$eq:e((d,l)=>d==l,JSBI.EQ),
ob$ne:e((d,l)=>d!=l,JSBI.NE),ob$gt:e((d,l)=>d>l,JSBI.GT),ob$ge:e((d,l)=>d>=l,JSBI.GE),ob$lt:e((d,l)=>d<l,JSBI.LT),ob$le:e((d,l)=>d<=l,JSBI.LE)},getsets:{real:{$get:b,$doc:"the real part of a complex number"},imag:{$get(){return new Sk.builtin.float_(0)},$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth:b,$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return self, the complex conjugate of any float."},__trunc__:{$meth(){return this.nb$int()},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return the Integral closest to x between 0 and x."},__round__:{$meth(d){return this.round$(d)},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, ndigits=None, /)",$doc:"Return the Integral closest to x, rounding half toward even.\n\nWhen an argument is passed, work like built-in round(x, ndigits)."},as_integer_ratio:{$meth(){if(!Number.isFinite(this.v)){if(Number.isNaN(this.v))throw new Sk.builtin.ValueError("cannot convert NaN to integer ratio");throw new Sk.builtin.OverflowError("cannot convert Infinity to integer ratio");
}var d=this.v;var l=[d,0];if(0!==d){var r=Math.abs(d),v=Math.max(-1023,Math.floor(Math.log2(r))+1);for(r*=Math.pow(2,-v);.5>r;)r*=2,v--;for(;1<=r;)r*=.5,v++;0>d&&(r=-r);l[0]=r;l[1]=v}d=l;let [q,t]=d;for(d=0;300>d&&q!=Math.floor(q);d++)q*=2,t--;d=new Sk.builtin.int_(Math.abs(t));v=new Sk.builtin.int_(q);l=new Sk.builtin.int_(1);0<t?v=v.nb$lshift(d):l=l.nb$lshift(d);return new Sk.builtin.tuple([v,l])},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return integer ratio.\n\nReturn a pair of integers, whose ratio is exactly equal to the original float\nand with a positive denominator.\n\nRaise OverflowError on infinities and a ValueError on NaNs.\n\n>>> (10.0).as_integer_ratio()\n(10, 1)\n>>> (0.0).as_integer_ratio()\n(0, 1)\n>>> (-.25).as_integer_ratio()\n(-1, 4)"},
is_integer:{$meth(){return new Sk.builtin.bool(Number.isInteger(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the float is an integer."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([this])},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:Sk.builtin.none.none$},__format__:{$meth:Sk.formatting.mkNumber__format__(!0),$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:Sk.builtin.none.none$}},proto:{valueOf(){return this.v}}});const m=/_[eE]|[eE]_|\._|_\.|[+-]_|__/,
n=/_(?=[^_])/g;Sk.builtin.float_.PyFloat_Check=function(d){return void 0===d?!1:Sk.builtin.checkNumber(d)||Sk.builtin.checkFloat(d)||d.ob$type.$isSubType(Sk.builtin.float_)?!0:!1};Sk.builtin.float_.prototype.toFixed=function(d){d=Sk.builtin.asnum$(d);return this.v.toFixed(d)};Sk.builtin.float_.prototype.round$=function(d){var l=Sk.builtin.asnum$(this);var r=void 0===d?0:Sk.misceval.asIndexSized(d);if(Sk.__future__.bankers_rounding){l*=Math.pow(10,r);var v=Math.round(l);r=(.5===(0<l?l:-l)%1?0===v%
2?v:v-1:v)/Math.pow(10,r);return void 0===d?new Sk.builtin.int_(r):new Sk.builtin.float_(r)}d=Math.pow(10,r);r=Math.round(l*d)/d;return new Sk.builtin.float_(r)};Sk.builtin.float_.prototype.str$=function(d,l){if(isNaN(this.v))return"nan";void 0===l&&(l=!0);if(Infinity==this.v)return"inf";if(-Infinity==this.v&&l)return"-inf";if(-Infinity==this.v&&!l)return"inf";l=l?this.v:Math.abs(this.v);if(void 0===d||10===d){var r=Sk.__future__.python3?l.toPrecision(16):l.toPrecision(12);var v=r.indexOf(".");d=
l.toString().slice(0,v);v=l.toString().slice(v);d.match(/^-?0$/)&&v.slice(1).match(/^0{4,}/)&&(r=12>r.length?l.toExponential():l.toExponential(11));if(0>r.indexOf("e")&&0<=r.indexOf(".")){for(;"0"==r.charAt(r.length-1);)r=r.substring(0,r.length-1);"."==r.charAt(r.length-1)&&(r+="0")}r=r.replace(/\.0+e/,"e","i");r=r.replace(/(e[-+])([1-9])$/,"$10$2");r=r.replace(/0+(e.*)/,"$1")}else r=l.toString(d);0===this.v&&-Infinity===1/this.v&&(r="-"+r);0>r.indexOf(".")&&0>r.indexOf("E")&&0>r.indexOf("e")&&(r+=
".0");return r};Sk.builtin.float_.py2$methods={}},function(E,Q){function b(d){let l=d.v;if("number"===typeof l)return l;d.nb$float&&(l=d.nb$float());if(void 0===l)throw new Sk.builtin.TypeError("a float is required");return l.v}function f(d,l,r){if(r===Sk.builtin.complex.prototype)return new Sk.builtin.complex(d,l);r=new r.constructor;Sk.builtin.complex.call(r,d,l);return r}function e(d,l){return function(r){const v=this.real,q=this.imag;var t=r.real;const w=r.v;if("number"===typeof t)r=r.imag;else if("number"===
typeof w)t=w,r=0;else if(JSBI.__isBigInt(w)){if(void 0===l){if(t=parseFloat(JSBI.toNumber(w)),Infinity==t||-Infinity==t)throw new Sk.builtin.OverflowError("int too large to convert to float");}else t=w.toString();r=0}else return Sk.builtin.NotImplemented.NotImplemented$;return d(v,q,t,r)}}function g(d,l,r,v){var q=Math.abs(r);const t=Math.abs(v);if(q>=t){if(0===q)throw new Sk.builtin.ZeroDivisionError("complex division by zero");q=v/r;r+=v*q;v=(d+l*q)/r;d=(l-d*q)/r}else t>=q?(q=r/v,r=r*q+v,Sk.asserts.assert(0!==
v),v=(d*q+l)/r,d=(l*q-d)/r):d=v=NaN;return new Sk.builtin.complex(v,d)}function k(d,l,r,v){if(0===r&&0===v){v=1;var q=0}else if(0===d&&0===l){if(0!==v||0>r)throw new Sk.builtin.ZeroDivisionError("complex division by zero");q=v=0}else{const t=Math.hypot(d,l);q=Math.pow(t,r);d=Math.atan2(l,d);r*=d;0!==v&&(q/=Math.exp(d*v),r+=v*Math.log(t));v=q*Math.cos(r);q*=Math.sin(r)}return new Sk.builtin.complex(v,q)}function p(d,l,r){let v=1;var q=new Sk.builtin.complex(1,0);for(d=new Sk.builtin.complex(d,l);0<
v&&r>=v;)r&v&&(q=new Sk.builtin.complex(q.real*d.real-q.imag*d.imag,q.real*d.imag+d.real*q.imag)),v<<=1,d=new Sk.builtin.complex(d.real*d.real-d.imag*d.imag,2*d.real*d.imag);return q}function h(d,l,r,v,q){q=!1;switch(l){case "e":case "f":case "g":break;case "E":q=!0;l="e";break;case "F":q=!0;l="f";break;case "r":if(0!==r)throw Error("Bad internall call");r=17;l="g";break;default:throw Error("Bad internall call");}if(isNaN(d))d="nan";else if(Infinity===d)d="inf";else if(-Infinity===d)d="-inf";else{v&
h.Py_DTSF_ADD_DOT_0&&(l="g");var t="%"+(v&h.Py_DTSF_ALT?"#":"");null!=r&&(t=t+"."+r);t=new Sk.builtin.str(t+l);d=t.nb$remainder(new Sk.builtin.float_(d));d=d.v}v&h.Py_DTSF_SIGN&&"-"!==d[0]&&(d="+"+d);q&&(d=d.toUpperCase());return d}Sk.builtin.complex=Sk.abstr.buildNativeClass("complex",{constructor:function(d,l){Sk.asserts.assert(this instanceof Sk.builtin.complex,"bad call to complex constructor, use 'new'");this.real=d;this.imag=l},slots:{tp$as_number:!0,tp$doc:"Create a complex number from a real part and an optional imaginary part.\n\nThis is equivalent to (real + imag*1j) where imag defaults to 0.",
tp$hash(){var d=(new Sk.builtin.float_(this.real)).tp$hash();d=1003*(new Sk.builtin.float_(this.imag)).tp$hash()+d;return Sk.builtin.int_.withinThreshold(d)?d:(new Sk.builtin.int_(JSBI.BigInt(d))).tp$hash()},tp$getattr:Sk.generic.getAttr,tp$new(d,l){d=Sk.abstr.copyKeywordsToNamedArgs("complex",["real","imag"],d,l,[null,null]);{var r=d[1],v;let t=l=!1;var q=d[0];if(null!=q&&q.constructor===Sk.builtin.complex&&null==r)l=q;else if(Sk.builtin.checkString(q)){if(null!=r)throw new Sk.builtin.TypeError("complex() can't take second arg if first is a string");
l=Sk.builtin.complex.complex_subtype_from_string(q,this)}else{if(null!=r&&Sk.builtin.checkString(r))throw new Sk.builtin.TypeError("complex() second arg can't be a string");null==q?d=null:(d=Sk.abstr.lookupSpecial(q,Sk.builtin.str.$complex),d=void 0!==d?Sk.misceval.callsimArray(d,[]):null);if(null!=d&&d!==Sk.builtin.NotImplemented.NotImplemented$){if(!a(d))throw new Sk.builtin.TypeError("__complex__ should return a complex object");q=d}if(null!=q&&void 0===q.nb$float)throw new Sk.builtin.TypeError("complex() first argument must be a string or a number, not '"+
Sk.abstr.typeName(q)+"'");if(null!=r&&void 0===r.nb$float)throw new Sk.builtin.TypeError("complex() second argument must be a number, not '"+Sk.abstr.typeName(q)+"'");null==q?q=d=0:a(q)?(d=q.real,q=q.imag,l=!0):(d=b(q),q=0);null==r?r=v=0:a(r)?(v=r.real,r=r.imag,t=!0):(v=b(r),r=0);!0===t&&(d-=r);!0===l&&(v+=q);l=f(d,v,this)}}return l},tp$richcompare(d,l){if("Eq"!==l&&"NotEq"!==l){if(Sk.builtin.checkNumber(d)||a(d))throw new Sk.builtin.TypeError("no ordering relation is defined for complex numbers");
return Sk.builtin.NotImplemented.NotImplemented$}return e(function(r,v,q,t){r=r==q&&v==t;return"Eq"===l?r:!r},!0).call(this,d)},$r(){{var d,l;let q=d="";var r=this.real;var v=this.imag;if(l=0===r)l=1==(r?0>r?-1:1:0>1/r?-1:1);l?(r="",l=h(v,"g",null,0,null)):(r=d=h(r,"g",null,0,null),l=h(v,"g",null,h.Py_DTSF_SIGN,null),0===v&&-Infinity===1/v&&l&&"-"!==l[0]&&(l="-"+l),d="(",q=")");v=new Sk.builtin.str(""+d+r+l+"j"+q)}return v},nb$int(){throw new Sk.builtin.TypeError("can't convert complex to int");},
nb$long(){throw new Sk.builtin.TypeError("can't convert complex to long");},nb$float(){throw new Sk.builtin.TypeError("can't convert complex to float");},nb$positive(){return new Sk.builtin.complex(this.real,this.imag)},nb$negative(){return new Sk.builtin.complex(-this.real,-this.imag)},nb$bool(){return this.real||this.imag},nb$add:e((d,l,r,v)=>new Sk.builtin.complex(d+r,l+v)),nb$subtract:e((d,l,r,v)=>new Sk.builtin.complex(d-r,l-v)),nb$reflected_subtract:e((d,l,r,v)=>new Sk.builtin.complex(r-d,v-
l)),nb$multiply:e((d,l,r,v)=>new Sk.builtin.complex(r*d-v*l,d*v+l*r)),nb$divide:e(g),nb$reflected_divide:e((d,l,r,v)=>g(r,v,d,l)),nb$floor_divide(d){throw new Sk.builtin.TypeError("can't take floor of complex number.");},nb$reflected_floor_divide(d){throw new Sk.builtin.TypeError("can't take floor of complex number.");},nb$remainder(d){throw new Sk.builtin.TypeError("can't mod complex numbers.");},nb$reflected_remainder(d){throw new Sk.builtin.TypeError("can't mod complex numbers.");},nb$divmod(d){throw new Sk.builtin.TypeError("can't take floor or mod of complex number.");
},nb$power(d,l){if(null!=l&&!Sk.builtin.checkNone(l))throw new Sk.builtin.ValueError("complex modulo");return n.call(this,d)},nb$abs(){var d=this.real;const l=this.imag;if(!Number.isFinite(d)||!Number.isFinite(l))return Infinity===d||-Infinity===d?new Sk.builtin.float_(Math.abs(d)):Infinity===l||-Infinity===l?new Sk.builtin.float_(Math.abs(l)):new Sk.builtin.float_(NaN);d=Math.hypot(d,l);if(!Number.isFinite(d))throw new Sk.builtin.OverflowError("absolute value too large");return new Sk.builtin.float_(d)}},
getsets:{real:{$get(){return new Sk.builtin.float_(this.real)},$doc:"the real part of a complex number"},imag:{$get(){return new Sk.builtin.float_(this.imag)},$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth(){return new Sk.builtin.complex(this.real,-this.imag)},$flags:{NoArgs:!0},$textsig:null,$doc:"complex.conjugate() -> complex\n\nReturn the complex conjugate of its argument. (3-4j).conjugate() == 3+4j."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([new Sk.builtin.float_(this.real),
new Sk.builtin.float_(this.imag)])},$flags:{NoArgs:!0},$textsig:null,$doc:Sk.builtin.none.none$},__format__:{$meth(d){if(Sk.builtin.checkString(d))throw new Sk.builtin.NotImplementedError("__format__ is not implemented for complex type.");throw new Sk.builtin.TypeError("__format__ requires str");},$flags:{OneArg:!0},$textsig:null,$doc:"complex.__format__() -> str\n\nConvert to a string according to format_spec."}}});Sk.exportSymbol("Sk.builtin.complex",Sk.builtin.complex);const a=Sk.builtin.checkComplex,
c=/_[eE]|[eE]_|\._|_\.|[+-]_|_j|j_/,m=/_(?=[^_])/g;Sk.builtin.complex.complex_subtype_from_string=function(d,l){l=l||Sk.builtin.complex.prototype;var r=0,v=0,q=!1;if(Sk.builtin.checkString(d))d=Sk.ffi.remapToJs(d);else if("string"!==typeof d)throw new TypeError("provided unsupported string-alike argument");if(-1!==d.indexOf("\x00")||0===d.length||""===d)throw new Sk.builtin.ValueError("complex() arg is a malformed string");var t=0;d=d.replace(/inf|infinity/gi,"Infinity");for(d=d.replace(/nan/gi,"NaN");" "===
d[t];)t++;if("("===d[t])for(q=!0,t++;" "===d[t];)t++;if(-1!==d.indexOf("_")){if(c.test(d))throw new Sk.builtin.ValueError("could not convert string to complex: '"+d+"'");d=d.charAt(0)+d.substring(1).replace(m,"")}var w=/^(?:[+-]?(?:(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[eE][+-]?\d+)?|NaN|Infinity))/;var C=d.substr(t);var D=C.match(w);if(null!==D)if(t+=D[0].length,"j"===d[t]||"J"===d[t])v=parseFloat(D[0]),t++;else if("+"===d[t]||"-"===d[t]){r=parseFloat(D[0]);D=d.substr(t).match(w);null!==D?(v=parseFloat(D[0]),
t+=D[0].length):(v="+"===d[t]?1:-1,t++);if("j"!==d[t]&&"J"!==d[t])throw new Sk.builtin.ValueError("complex() arg is malformed string");t++}else r=parseFloat(D[0]);else D=D=C.match(/^([+-]?[jJ])/),null!==D&&(v=1===D[0].length?1:"+"===D[0][0]?1:-1,t+=D[0].length);for(;" "===d[t];)t++;if(q){if(")"!==d[t])throw new Sk.builtin.ValueError("complex() arg is malformed string");for(t++;" "===d[t];)t++}if(d.length!==t)throw new Sk.builtin.ValueError("complex() arg is malformed string");return f(r,v,l)};const n=
e((d,l,r,v)=>{const q=r|0;return 0===v&&r===q?(100<q||-100>q?d=k(d,l,q,0):0<q?d=p(d,l,q):(d=p(d,l,-q),d=g(1,0,d.real,d.imag)),d):k(d,l,r,v)});h.Py_DTSF_SIGN=1;h.Py_DTSF_ADD_DOT_0=2;h.Py_DTSF_ALT=4;h.Py_DTST_FINITE=0;h.Py_DTST_INFINITE=1;h.Py_DTST_NAN=2},function(E,Q){Sk.builtin.slice=Sk.abstr.buildNativeClass("slice",{constructor:function(b,f,e){void 0===f&&void 0===e&&(f=b,b=Sk.builtin.none.none$);void 0===f&&(f=Sk.builtin.none.none$);void 0===e&&(e=Sk.builtin.none.none$);this.start=b;this.stop=
f;this.step=e},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"slice(stop)\nslice(start, stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",tp$hash:Sk.builtin.none.none$,tp$new(b,f){Sk.abstr.checkNoKwargs("slice",f);Sk.abstr.checkArgsLen("slice",b,1,3);return new Sk.builtin.slice(...b)},$r(){const b=Sk.misceval.objectRepr(this.start),f=Sk.misceval.objectRepr(this.stop),e=Sk.misceval.objectRepr(this.step);return new Sk.builtin.str("slice("+b+", "+f+", "+e+")")},
tp$richcompare(b,f){if(b.ob$type!==Sk.builtin.slice)return Sk.builtin.NotImplemented.NotImplemented$;const e=new Sk.builtin.tuple([this.start,this.stop,this.step]);b=new Sk.builtin.tuple([b.start,b.stop,b.step]);return e.tp$richcompare(b,f)}},getsets:{start:{$get(){return this.start}},step:{$get(){return this.step}},stop:{$get(){return this.stop}}},methods:{indices:{$meth:function(b){b=Sk.misceval.asIndexSized(b,Sk.builtin.OverflowError);if(0>b)throw new Sk.builtin.TypeError("length should not be negative");
const {start:f,stop:e,step:g}=this.slice$indices(b);return new Sk.builtin.tuple([new Sk.builtin.int_(f),new Sk.builtin.int_(e),new Sk.builtin.int_(g)])},$doc:"S.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop\nindices, and the stride length of the extended slice described by\nS. Out of bounds indices are clipped in a manner consistent with the\nhandling of normal slices.",$textsig:null,$flags:{OneArg:!0}}},proto:{slice$as_indices(b){let f;var e=
b?g=>Sk.misceval.asIndexSized(g,null,"slice indices must be integers or None or have an __index__ method"):g=>Sk.misceval.asIndexOrThrow(g,"slice indices must be integers or None or have an __index__ method");if(Sk.builtin.checkNone(this.step))f=1;else if(f=e(this.step),0===f)throw new Sk.builtin.ValueError("slice step cannot be zero");b=Sk.builtin.checkNone(this.start)?null:e(this.start);e=Sk.builtin.checkNone(this.stop)?null:e(this.stop);return{start:b,stop:e,step:f}},$wrt(b,f,e,g,k){k=k?p=>JSBI.__isBigInt(p)?
JSBI.add(p,JSBI.BigInt(b)):p+b:p=>p+b;0<g?(null===f?f=0:0>f&&(f=k(f),0>f&&(f=0)),null===e?e=b:e>b?e=b:0>e&&(e=k(e))):(null===f?f=b-1:f>=b?f=b-1:0>f&&(f=k(f)),null===e?e=-1:0>e&&(e=k(e),0>e&&(e=-1)));return{start:f,stop:e,step:g}},slice$indices(b,f){let {start:e,stop:g,step:k}=this.slice$as_indices(!0,f);return this.$wrt(b,e,g,k,f)},sssiter$(b,f){let {start:e,stop:g,step:k}=this.slice$indices(b,!0);if(0<k)for(b=e;b<g;b+=k)f(b);else for(b=e;b>g;b+=k)f(b)}},flags:{sk$unacceptableBase:!0}});Sk.builtin.slice.startEnd$wrt=
function(b,f,e){b=b.sq$length();void 0===f||Sk.builtin.checkNone(f)?f=0:(f=Sk.misceval.asIndexSized(f,null,"slice indices must be integers or have an __index__ method"),0>f&&(f+=b,0>f&&(f=0)));void 0===e||Sk.builtin.checkNone(e)?e=b:(e=Sk.misceval.asIndexSized(e,null,"slice indices must be integers or have an __index__ method"),0>e?(e+=b,0>e&&(e=0)):e>b&&(e=b));return{start:f,end:e}}},function(E,Q){function b(g){return function(k){return Sk.builtin.checkAnySet(k)?g.call(this,k):Sk.builtin.NotImplemented.NotImplemented$}}
function f(g){g instanceof Sk.builtin.set&&g.tp$hash===Sk.builtin.none.none$&&(g=new Sk.builtin.frozenset(Sk.misceval.arrayFromIterable(g)));return g}E={};Sk.builtin.set=Sk.abstr.buildNativeClass("set",{constructor:function(g){void 0===g?g=[]:Array.isArray(g)||(g=Sk.misceval.arrayFromIterable(g));Sk.asserts.assert(this instanceof Sk.builtin.set,"Bad call to set - must be called with an Array and 'new'");const k=[];for(let p=0;p<g.length;p++)k.push(g[p]),k.push(!0);this.v=new Sk.builtin.dict(k);this.in$repr=
!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"set() -> new empty set object\nset(iterable) -> new set object\n\nBuild an unordered collection of unique elements.",tp$init(g,k){Sk.abstr.checkNoKwargs("set",k);Sk.abstr.checkArgsLen("set",g,0,1);this.set$clear();return(g=g[0])&&this.set$update(g)},tp$new:Sk.generic.new,$r(){if(this.in$repr)return new Sk.builtin.str(Sk.abstr.typeName(this)+"(...)");this.in$repr=!0;const g=this.sk$asarray().map(k=>
Sk.misceval.objectRepr(k));this.in$repr=!1;return Sk.__future__.python3?0===g.length?new Sk.builtin.str(Sk.abstr.typeName(this)+"()"):this.ob$type!==Sk.builtin.set?new Sk.builtin.str(Sk.abstr.typeName(this)+"({"+g.join(", ")+"})"):new Sk.builtin.str("{"+g.join(", ")+"}"):new Sk.builtin.str(Sk.abstr.typeName(this)+"(["+g.join(", ")+"])")},tp$iter(){return new e(this)},tp$richcompare(g,k){if(!Sk.builtin.checkAnySet(g))return Sk.builtin.NotImplemented.NotImplemented$;switch(k){case "NotEq":case "Eq":return g=
this===g?!0:this.get$size()!==g.get$size()?!1:Sk.misceval.isTrue(this.set$issubset(g)),"Eq"===k?g:!g;case "LtE":return this===g||Sk.misceval.isTrue(this.set$issubset(g));case "GtE":return this===g||Sk.misceval.isTrue(g.set$issubset(this));case "Lt":return this.get$size()<g.get$size()&&Sk.misceval.isTrue(this.set$issubset(g));case "Gt":return this.get$size()>g.get$size()&&Sk.misceval.isTrue(g.set$issubset(this))}},nb$subtract:b(function(g){return this.difference.$meth.call(this,g)}),nb$and:b(function(g){return this.intersection.$meth.call(this,
g)}),nb$or:b(function(g){return this.union.$meth.call(this,g)}),nb$xor:b(function(g){return this.symmetric_difference.$meth.call(this,g)}),nb$inplace_subtract:b(function(g){g===this&&(g=g.set$copy());return Sk.misceval.chain(this.difference_update.$meth.call(this,g),()=>this)}),nb$inplace_and:b(function(g){return Sk.misceval.chain(this.intersection_update.$meth.call(this,g),()=>this)}),nb$inplace_or:b(function(g){return Sk.misceval.chain(this.update.$meth.call(this,g),()=>this)}),nb$inplace_xor:b(function(g){g===
this&&(g=g.set$copy());return Sk.misceval.chain(this.symmetric_difference_update.$meth.call(this,g),()=>this)}),sq$length(){return this.get$size()},sq$contains(g){g=f(g);return this.v.sq$contains(g)}},methods:{add:{$meth(g){this.set$add(g);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Add an element to a set.\n\nThis has no effect if the element is already present."},clear:{$meth(){this.set$clear();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:"Remove all elements from this set."},
copy:{$meth(){return this.set$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a shallow copy of a set."},discard:{$meth(g){g=f(g);this.set$discard(g);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Remove an element from a set if it is a member.\n\nIf the element is not a member, do nothing."},difference:{$meth(...g){const k=this.set$copy();return Sk.misceval.chain(Sk.misceval.iterArray(g,p=>k.set$difference_update(p)),()=>k)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the difference of two or more sets as a new set.\n\n(i.e. all elements that are in this set but not the others.)"},
difference_update:{$meth(...g){return Sk.misceval.chain(Sk.misceval.iterArray(g,k=>this.set$difference_update(k)),()=>Sk.builtin.none.none$)},$flags:{MinArgs:0},$textsig:null,$doc:"Remove all elements of another set from this set."},intersection:{$meth(...g){return this.set$intersection_multi(...g)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the intersection of two sets as a new set.\n\n(i.e. all elements that are in both sets.)"},intersection_update:{$meth(...g){return Sk.misceval.chain(this.set$intersection_multi(...g),
k=>{this.swap$bodies(k);return Sk.builtin.none.none$})},$flags:{MinArgs:0},$textsig:null,$doc:"Update a set with the intersection of itself and another."},isdisjoint:{$meth(g){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(g),k=>{if(this.sq$contains(k))return new Sk.misceval.Break(Sk.builtin.bool.false$)}),k=>k||Sk.builtin.bool.true$)},$flags:{OneArg:!0},$textsig:null,$doc:"Return True if two sets have a null intersection."},issubset:{$meth(g){Sk.builtin.checkAnySet(g)||(g=this.set$make_basetype(g));
return Sk.misceval.chain(g,k=>this.set$issubset(k))},$flags:{OneArg:!0},$textsig:null,$doc:"Report whether another set contains this set."},issuperset:{$meth(g){Sk.builtin.checkAnySet(g)||(g=this.set$make_basetype(g));return Sk.misceval.chain(g,k=>k.set$issubset(this))},$flags:{OneArg:!0},$textsig:null,$doc:"Report whether this set contains another set."},pop:{$meth(){if(0===this.get$size())throw new Sk.builtin.KeyError("pop from an empty set");return Sk.misceval.callsimArray(this.v.popitem,[this.v]).v[0]},
$flags:{NoArgs:!0},$textsig:null,$doc:"Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."},remove:{$meth(g){const k=f(g);if(this.v.mp$lookup(k))return this.v.mp$ass_subscript(k),Sk.builtin.none.none$;throw new Sk.builtin.KeyError(g);},$flags:{OneArg:!0},$textsig:null,$doc:"Remove an element from a set; it must be a member.\n\nIf the element is not a member, raise a KeyError."},symmetric_difference:{$meth(g){let k;return Sk.misceval.chain(this.set$make_basetype(g),p=>
{k=p;return k.set$symmetric_diff_update(this)},()=>k)},$flags:{OneArg:!0},$textsig:null,$doc:"Return the symmetric difference of two sets as a new set.\n\n(i.e. all elements that are in exactly one of the sets.)"},symmetric_difference_update:{$meth(g){Sk.builtin.checkAnySet(g)||(g=this.set$make_basetype(g));return Sk.misceval.chain(g,k=>this.set$symmetric_diff_update(k),()=>Sk.builtin.none.none$)},$flags:{OneArg:!0},$textsig:null,$doc:"Update a set with the symmetric difference of itself and another."},
union:{$meth(...g){const k=this.set$copy();return Sk.misceval.chain(Sk.misceval.iterArray(g,p=>k.set$update(p)),()=>k)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the union of sets as a new set.\n\n(i.e. all elements that are in either set.)"},update:{$meth(...g){return Sk.misceval.chain(Sk.misceval.iterArray(g,k=>this.set$update(k)),()=>Sk.builtin.none.none$)},$flags:{MinArgs:0},$textsig:null,$doc:"Update a set with the union of itself and others."}},classmethods:Sk.generic.classGetItem,proto:Object.assign(E,
{sk$asarray(){return this.v.sk$asarray()},get$size(){return this.v.sq$length()},set$add(g){this.v.mp$ass_subscript(g,!0)},set$make_basetype(g){return Sk.misceval.chain(Sk.misceval.arrayFromIterable(g,!0),k=>new this.sk$builtinBase(k))},set$discard(g){return this.v.pop$item(g)},set$clear(){this.v=new Sk.builtin.dict([])},set$copy(){const g=new this.sk$builtinBase;g.v=this.v.dict$copy();return g},set$difference_update(g){return Sk.misceval.iterFor(Sk.abstr.iter(g),k=>{this.set$discard(k)})},set$intersection(g){const k=
new this.sk$builtinBase;return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(g),p=>{this.sq$contains(p)&&k.set$add(p)}),()=>k)},set$intersection_multi(...g){if(!g.length)return this.set$copy();let k=this;return Sk.misceval.chain(Sk.misceval.iterArray(g,p=>Sk.misceval.chain(k.set$intersection(p),h=>{k=h})),()=>k)},set$issubset(g){const k=this.get$size(),p=g.get$size();if(k>p)return Sk.builtin.bool.false$;for(let h=this.tp$iter(),a=h.tp$iternext();void 0!==a;a=h.tp$iternext())if(!g.sq$contains(a))return Sk.builtin.bool.false$;
return Sk.builtin.bool.true$},set$symmetric_diff_update(g){return Sk.misceval.iterFor(Sk.abstr.iter(g),k=>{void 0===this.set$discard(k)&&this.set$add(k)})},set$update(g){return Sk.misceval.iterFor(Sk.abstr.iter(g),k=>{this.set$add(k)})},swap$bodies(g){this.v=g.v}})});Sk.exportSymbol("Sk.builtin.set",Sk.builtin.set);Q=Sk.builtin.set.prototype;Sk.builtin.frozenset=Sk.abstr.buildNativeClass("frozenset",{constructor:function(g){void 0===g?g=[]:Array.isArray(g)||(g=Sk.misceval.arrayFromIterable(g));Sk.asserts.assert(this instanceof
Sk.builtin.frozenset,"bad call to frozen set - must be called with 'new'");const k=[];for(let p=0;p<g.length;p++)k.push(g[p]),k.push(!0);this.v=new Sk.builtin.dict(k);this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$doc:"frozenset() -> empty frozenset object\nfrozenset(iterable) -> frozenset object\n\nBuild an immutable unordered collection of unique elements.",tp$hash(){let g=1927868237;const k=this.sk$asarray();g*=k.length+1;for(let p=0;p<k.length;p++){const h=
Sk.abstr.objectHash(k[p]);g^=3644798167*(h^h<<16^89869747)}return 69069*g+907133923},tp$new(g,k){if(this!==Sk.builtin.frozenset.prototype)return this.$subtype_new(g,k);Sk.abstr.checkNoKwargs("frozenset",k);Sk.abstr.checkArgsLen("frozenset",g,0,1);g=g[0];return void 0!==g&&g.ob$type===Sk.builtin.frozenset?g:Sk.misceval.chain(Sk.misceval.arrayFromIterable(g,!0),p=>p.length?new Sk.builtin.frozenset(p):Sk.builtin.frozenset.$emptyset)},$r:Q.$r,tp$iter:Q.tp$iter,tp$richcompare:Q.tp$richcompare,nb$subtract:Q.nb$subtract,
nb$and:Q.nb$and,nb$or:Q.nb$or,nb$xor:Q.nb$xor,sq$length:Q.sq$length,sq$contains:Q.sq$contains},methods:{copy:Object.assign({},Q.copy.d$def,{$meth(){return this.constructor===this.sk$builtinBase?this:new Sk.builtin.frozenset(this.sk$asarray())}}),difference:Q.difference.d$def,intersection:Q.intersection.d$def,isdisjoint:Q.isdisjoint.d$def,issubset:Q.issubset.d$def,issuperset:Q.issuperset.d$def,symmetric_difference:Q.symmetric_difference.d$def,union:Q.union.d$def},classmethods:Sk.generic.classGetItem,
proto:Object.assign({$subtype_new(g,k){const p=new this.constructor;return Sk.misceval.chain(Sk.builtin.frozenset.prototype.tp$new(g),h=>{p.v=h.v;return p})}},E)});Sk.builtin.frozenset.$emptyset=new Sk.builtin.frozenset([]);Sk.exportSymbol("Sk.builtin.frozenset",Sk.builtin.frozenset);var e=Sk.abstr.buildIteratorClass("set_iterator",{constructor:function(g){this.$index=0;this.$seq=g.sk$asarray();this.$orig=g},iternext:Sk.generic.iterNextWithArrayCheckSize,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},
flags:{sk$unacceptableBase:!0}})},function(E,Q){Sk.builtin.print=function(b,f){let [e,g,k]=Sk.abstr.copyKeywordsToNamedArgs("print",["sep","end","file","flush"],[],f);if(void 0===e||Sk.builtin.checkNone(e))e=" ";else if(Sk.builtin.checkString(e))e=e.$jsstr();else throw new Sk.builtin.TypeError("sep must be None or a string, not "+Sk.abstr.typeName(e));if(void 0===g||Sk.builtin.checkNone(g))g="\n";else if(Sk.builtin.checkString(g))g=g.$jsstr();else throw new Sk.builtin.TypeError("end must be None or a string, not "+
Sk.abstr.typeName(g));let p;if(void 0!==k&&!Sk.builtin.checkNone(k)&&(p=Sk.abstr.lookupSpecial(k,Sk.builtin.str.$write),void 0===p))throw new Sk.builtin.AttributeError("'"+Sk.abstr.typeName(k)+"' object has no attribute 'write'");const h=new Sk.builtin.str(b.map(a=>(new Sk.builtin.str(a)).toString()).join(e)+g);if(void 0!==p)Sk.misceval.callsimArray(p,[h]);else return Sk.misceval.chain(Sk.importModule("sys",!1,!0),a=>(p=Sk.abstr.lookupSpecial(a.$d.stdout,Sk.builtin.str.$write))&&Sk.misceval.callsimOrSuspendArray(p,
[h]))};Sk.builtin.print.co_fastcall=1},function(E,Q){Sk.builtin.module=Sk.abstr.buildNativeClass("module",{constructor:function(){this.$d={}},slots:{tp$doc:"Create a module object.\n\nThe name must be a string; the optional doc argument can have any type.",tp$getattr(b,f){var e=this.$d[b.$mangled];if(void 0!==e)return e;e=this.ob$type.$typeLookup(b);if(void 0!==e){const k=e.tp$descr_get;return k?k.call(e,this,this.ob$type,f):e}const g=this.$d.__getattr__;if(void 0!==g)return e=Sk.misceval.tryCatch(()=>
Sk.misceval.callsimOrSuspendArray(g,[b]),k=>{if(!(k instanceof Sk.builtin.AttributeError))throw k;}),f?e:Sk.misceval.retryOptionalSuspensionOrThrow(e)},tp$setattr:Sk.generic.setAttr,tp$new:Sk.generic.new,tp$init(b,f){const [e,g]=Sk.abstr.copyKeywordsToNamedArgs("module",["name","doc"],b,f,[Sk.builtin.none.none$]);Sk.builtin.pyCheckType("module","string",e);this.init$dict(e,g)},$r(){let b=this.get$name();if(void 0!==b){var f=this.get$mod_reprf();if(void 0!==f)return Sk.misceval.callsimOrSuspendArray(f,
[this])}b=void 0===b?"'?'":b;f=this.from$file();f=void 0===f?this.empty_or$loader():f;return new Sk.builtin.str("<module "+b+f+">")}},getsets:{__dict__:{$get(){return new Sk.builtin.mappingproxy(this.$d)}}},methods:{__dir__:{$meth(){const b=this.tp$getattr(Sk.builtin.str.$dict);if(!Sk.builtin.checkMapping(b))throw new Sk.builtin.TypeError("__dict__ is not a dictionary");const f=b.mp$lookup(Sk.builtin.str.$dir);return void 0!==f?Sk.misceval.callsimOrSuspendArray(f,[]):new Sk.builtin.list(Sk.misceval.arrayFromIterable(b))},
$flags:{NoArgs:!0},$doc:"__dir__() -> list\nspecialized dir() implementation"}},proto:{sk$hasDict:!0,init$dict(b,f){this.$d.__name__=b;this.$d.__doc__=f;this.$d.__package__=Sk.builtin.none.none$;this.$d.__spec__=Sk.builtin.none.none$;this.$d.__loader__=Sk.builtin.none.none$},sk$attrError(){let b=this.get$name();b=void 0===b?"module":"module "+b;this.$initializing&&(b="(most likely due to a circular import) partially initialized "+b);return b},get$name(){const b=this.tp$getattr(Sk.builtin.str.$name);
return b&&Sk.misceval.objectRepr(b)},from$file(){const b=this.tp$getattr(Sk.builtin.str.$file);return b&&" from "+Sk.misceval.objectRepr(b)},empty_or$loader(){if(this.$js&&this.$js.includes("$builtinmodule"))return" (built-in)";const b=this.tp$getattr(Sk.builtin.str.$loader);return void 0===b||Sk.builtin.checkNone(b)?"":" ("+Sk.misceval.objectRepr(b)+")"},get$mod_reprf(){const b=this.tp$getattr(Sk.builtin.str.$loader);return b&&b.tp$getattr(this.str$mod_repr)},str$mod_repr:new Sk.builtin.str("module_repr")}});
Sk.exportSymbol("Sk.builtin.module",Sk.builtin.module)},function(E,Q){Sk.builtin.structseq_types={};Sk.builtin.make_structseq=function(b,f,e,g,k){g=void 0===g?{}:g;k=void 0===k?null:k;const p=b+"."+f,h=[],a={};Object.keys(e).forEach((d,l)=>{h.push(d);a[d]={$get(){return this.v[l]},$doc:e[d]}});const c=h.length;let m=c;Object.keys(g).forEach((d,l)=>{a[d]={$get(){return this.$hidden[l]||Sk.builtin.none.none$},$doc:g[d]};m++});var n=Sk.abstr.buildNativeClass(p,{constructor:function(d,l){Sk.asserts.assert(this instanceof
n);Sk.builtin.tuple.call(this,d);this.$hidden=l||[]},base:Sk.builtin.tuple,slots:{tp$new(d,l){Sk.abstr.checkOneArg(p,d,l);d=Sk.misceval.arrayFromIterable(d[0]);if(d.length<c)throw new Sk.builtin.TypeError(p+"() takes an at least "+c+"-sequence ("+d.length+"-sequence given)");if(d.length>m)throw new Sk.builtin.TypeError(p+"() takes an at most "+m+"-sequence ("+d.length+"-sequence given)");return new n(d.slice(0,c),d.slice(c))},tp$doc:k?k:Sk.builtin.none.none$,$r(){var d;if(0===this.v.length)return new Sk.builtin.str(p+
"()");var l=[];for(d=0;d<h.length;++d)l[d]=h[d]+"="+Sk.misceval.objectRepr(this.v[d]);d=l.join(", ");1===this.v.length&&(d+=",");return new Sk.builtin.str(p+"("+d+")")}},methods:{__reduce__:{$meth(){throw new Sk.builtin.NotImplementedError("__reduce__ is not implemented");},$flags:{NoArgs:!0}}},getsets:a,proto:{num_sequence_fields:new Sk.builtin.int_(c)}});return n};Sk.exportSymbol("Sk.builtin.make_structseq",Sk.builtin.make_structseq)},function(E,Q){Sk.builtin.generator=Sk.abstr.buildIteratorClass("generator",
{constructor:function(b,f,e,g,k){var p;if(b){if(!(this instanceof Sk.builtin.generator))throw new TypeError("bad internal call to generator, use 'new'");this.func_code=b;this.func_globals=f||null;this.gi$running=!1;this.gi$resumeat=0;this.gi$sentvalue=Sk.builtin.none.none$;this.gi$locals={};this.gi$cells={};if(0<e.length)for(f=0;f<b.co_varnames.length;++f)this.gi$locals[b.co_varnames[f]]=e[f];if(void 0!==k)for(p in k)g[p]=k[p];this.func_closure=g}},slots:{$r(){return new Sk.builtin.str("<generator object "+
this.func_code.co_name.v+">")}},iternext(b,f){var e=this;if(this.gi$running)throw new Sk.builtin.ValueError("generator already executing");this.gi$running=!0;void 0===f&&(f=Sk.builtin.none.none$);this.gi$sentvalue=f;f=[this];this.func_closure&&f.push(this.func_closure);return function p(k){if(k instanceof Sk.misceval.Suspension){if(b)return new Sk.misceval.Suspension(p,k);k=Sk.misceval.retryOptionalSuspensionOrThrow(k)}e.gi$running=!1;Sk.asserts.assert(void 0!==k);if(Array.isArray(k))return e.gi$resumeat=
k[0],k=k[1];e.gi$ret=k}(this.func_code.apply(this.func_globals,f))},methods:{send:{$meth(b){return Sk.misceval.chain(this.tp$iternext(!0,b),f=>{if(void 0===f)throw f=this.gi$ret,void 0!==f&&f!==Sk.builtin.none.none$?new Sk.builtin.StopIteration(f):new Sk.builtin.StopIteration;return f})},$flags:{OneArg:!0},$doc:"send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration."}}});Sk.exportSymbol("Sk.builtin.generator",Sk.builtin.generator);Sk.builtin.makeGenerator=function(b,
f){var e,g=new Sk.builtin.generator(null,null,null);g.tp$iternext=b;for(e in f)f.hasOwnProperty(e)&&(g[e]=f[e]);return g};Sk.exportSymbol("Sk.builtin.makeGenerator",Sk.builtin.makeGenerator)},function(E,Q){Sk.builtin.file=function(b,f,e){var g;if(!(this instanceof Sk.builtin.file))return new Sk.builtin.file(b,f,e);this.mode=f;this.name=Sk.ffi.remapToJs(b);this.closed=!1;if("/dev/stdout"===this.name)this.data$=Sk.builtin.none.none$,this.fileno=1;else if("/dev/stdin"===this.name)this.fileno=0;else if("/dev/stderr"===
this.name)this.fileno=2;else{if("w"===Sk.ffi.remapToJs(this.mode))this.fileno=Sk.builtin.file.currentFileno++;else for(g in this.fileno=Sk.inBrowser?10:11,this.data$=Sk.read(b.v),this.lineList=this.data$.split("\n"),this.lineList=this.lineList.slice(0,-1),this.lineList)this.lineList[g]+="\n";this.currentLine=0}this.pos$=0;Sk.fileopen&&10<=this.fileno&&Sk.fileopen(this);return this};Sk.builtin.file.currentFileno=12;Sk.abstr.setUpInheritance("file",Sk.builtin.file,Sk.builtin.object);Sk.abstr.setUpBuiltinMro(Sk.builtin.file);
Sk.builtin.file.prototype.$r=function(){return new Sk.builtin.str("<"+(this.closed?"closed":"open")+"file '"+this.name+"', mode '"+Sk.ffi.remapToJs(this.mode)+"'>")};Sk.builtin.file.prototype.tp$iter=function(){var b={tp$iter:function(){return b},$obj:this,$index:this.currentLine,$lines:this.lineList,tp$iternext:function(){if(!(b.$index>=b.$lines.length))return new Sk.builtin.str(b.$lines[b.$index++])}};return b};Sk.abstr.setUpSlots(Sk.builtin.file);Sk.builtin.file.prototype.__enter__=new Sk.builtin.func(function(b){return b});
Sk.builtin.file.prototype.__exit__=new Sk.builtin.func(function(b){return Sk.misceval.callsimArray(Sk.builtin.file.prototype.close,[b])});Sk.builtin.file.prototype.close=new Sk.builtin.func(function(b){b.closed=!0;return Sk.builtin.none.none$});Sk.builtin.file.prototype.flush=new Sk.builtin.func(function(b){});Sk.builtin.file.prototype.fileno=new Sk.builtin.func(function(b){return this.fileno});Sk.builtin.file.prototype.isatty=new Sk.builtin.func(function(b){return!1});Sk.builtin.file.prototype.read=
new Sk.builtin.func(function(b,f){var e=b.data$.length;if(b.closed)throw new Sk.builtin.ValueError("I/O operation on closed file");var g=void 0===f?e:Sk.ffi.remapToJs(f);g=new Sk.builtin.str(b.data$.substr(b.pos$,g));b.pos$=void 0===f?e:b.pos$+Sk.ffi.remapToJs(f);b.pos$>=e&&(b.pos$=e);return g});Sk.builtin.file.$readline=function(b,f,e){if(0===b.fileno){b=Sk.ffi.remapToJs(e);b=Sk.inputfun(b?b:"");if(b instanceof Promise||b&&"function"===typeof b.then){var g=new Sk.misceval.Suspension;g.resume=function(){if(g.data.error)throw g.data.error;
return new Sk.builtin.str(g.data.result)};g.data={type:"Sk.promise",promise:b};return g}return new Sk.builtin.str(b)}f="";b.currentLine<b.lineList.length&&(f=b.lineList[b.currentLine],b.currentLine++);return new Sk.builtin.str(f)};Sk.builtin.file.prototype.readline=new Sk.builtin.func(function(b,f){return Sk.builtin.file.$readline(b,f,void 0)});Sk.builtin.file.prototype.readlines=new Sk.builtin.func(function(b,f){if(0===b.fileno)return new Sk.builtin.NotImplementedError("readlines ins't implemented because the web doesn't support Ctrl+D");
var e=[];for(f=b.currentLine;f<b.lineList.length;f++)e.push(new Sk.builtin.str(b.lineList[f]));return new Sk.builtin.list(e)});Sk.builtin.file.prototype.seek=new Sk.builtin.func(function(b,f,e){f=Sk.ffi.remapToJs(f);void 0===e&&(e=0);0===e?b.pos$=f:1==e?b.pos$=b.data$.length+f:2==e&&(b.pos$=b.data$.length+f);return Sk.builtin.none.none$});Sk.builtin.file.prototype.tell=new Sk.builtin.func(function(b){return Sk.ffi.remapToPy(b.pos$)});Sk.builtin.file.prototype.truncate=new Sk.builtin.func(function(b,
f){Sk.asserts.fail()});Sk.builtin.file.prototype.write=new Sk.builtin.func(function(b,f){var e=Sk.ffi.remapToJs(b.mode);Sk.ffi.remapToJs(f);if("w"===e||"wb"===e||"a"===e||"ab"===e)if(Sk.filewrite){if(b.closed)throw new Sk.builtin.ValueError("I/O operation on closed file");1===b.fileno?Sk.output(Sk.ffi.remapToJs(f)):Sk.filewrite(b,f)}else 1===b.fileno?Sk.output(Sk.ffi.remapToJs(f)):Sk.asserts.fail();return Sk.builtin.none.none$});Sk.exportSymbol("Sk.builtin.file",Sk.builtin.file)},function(E,Q){Sk.ffi=
Sk.ffi||{};Sk.ffi.remapToPy=function(b){var f;if(null===b||"undefined"===typeof b)return Sk.builtin.none.none$;if(b.ob$type||b instanceof Sk.misceval.Suspension)return b;if("[object Array]"===Object.prototype.toString.call(b)){var e=[];for(f=0;f<b.length;++f)e.push(Sk.ffi.remapToPy(b[f]));return new Sk.builtin.list(e)}if("object"===typeof b){e=[];for(f in b)e.push(Sk.ffi.remapToPy(f)),e.push(Sk.ffi.remapToPy(b[f]));return new Sk.builtin.dict(e)}if("string"===typeof b)return new Sk.builtin.str(b);
if("number"===typeof b)return Sk.builtin.assk$(b);if("boolean"===typeof b)return new Sk.builtin.bool(b);if("undefined"===typeof b)return Sk.builtin.none.none$;if("function"===typeof b)return new Sk.builtin.func(b);Sk.asserts.fail("unhandled remap type "+typeof b)};Sk.exportSymbol("Sk.ffi.remapToPy",Sk.ffi.remapToPy);Sk.ffi.remapToJs=function(b){var f,e;if(b instanceof Sk.builtin.dict){var g={};b.$items().forEach(k=>{var [p,h]=k;e=Sk.ffi.remapToJs(p);g[e]=Sk.ffi.remapToJs(h)});return g}if(b instanceof
Sk.builtin.list||b instanceof Sk.builtin.tuple){g=[];for(f=0;f<b.v.length;++f)g.push(Sk.ffi.remapToJs(b.v[f]));return g}if(b instanceof Sk.builtin.bool)return b.v?!0:!1;if(b instanceof Sk.builtin.int_||b instanceof Sk.builtin.float_||b instanceof Sk.builtin.lng)return Sk.builtin.asnum$(b);if("number"===typeof b||"boolean"===typeof b||"string"===typeof b)return b;if(void 0!==b)return b.v};Sk.exportSymbol("Sk.ffi.remapToJs",Sk.ffi.remapToJs);Sk.ffi.callback=function(b){return void 0===b?b:function(){return Sk.misceval.apply(b,
void 0,void 0,void 0,Array.prototype.slice.call(arguments,0))}};Sk.exportSymbol("Sk.ffi.callback",Sk.ffi.callback);Sk.ffi.stdwrap=function(b,f){b=new b;b.v=f;return b};Sk.exportSymbol("Sk.ffi.stdwrap",Sk.ffi.stdwrap);Sk.ffi.basicwrap=function(b){if(b instanceof Sk.builtin.int_||b instanceof Sk.builtin.float_||b instanceof Sk.builtin.lng)return Sk.builtin.asnum$(b);if("number"===typeof b||"boolean"===typeof b)return b;if("string"===typeof b)return new Sk.builtin.str(b);Sk.asserts.fail("unexpected type for basicwrap")};
Sk.exportSymbol("Sk.ffi.basicwrap",Sk.ffi.basicwrap);Sk.ffi.unwrapo=function(b){if(void 0!==b)return b.v};Sk.exportSymbol("Sk.ffi.unwrapo",Sk.ffi.unwrapo);Sk.ffi.unwrapn=function(b){return null===b?null:b.v};Sk.exportSymbol("Sk.ffi.unwrapn",Sk.ffi.unwrapn)},function(E,Q){function b(k,p,h){k=void 0===k?k:Sk.misceval.asIndexOrThrow(k);p=void 0===p?p:Sk.misceval.asIndexOrThrow(p);h=void 0===h?h:Sk.misceval.asIndexOrThrow(h);if(void 0===p&&void 0===h)p=k,k=0,h=1;else if(void 0===h)h=1;else if(0===h)throw new Sk.builtin.ValueError("range() step argument must not be zero");
const a=[];if("number"===typeof k&&"number"===typeof p&&"number"===typeof h)if(0<h)for(var c=k;c<p;c+=h)a.push(new Sk.builtin.int_(c));else for(c=k;c>p;c+=h)a.push(new Sk.builtin.int_(c));else{k=c=JSBI.BigInt(k);h=JSBI.BigInt(h);p=JSBI.BigInt(p);if(JSBI.greaterThan(h,JSBI.__ZERO))for(;JSBI.lessThan(c,p);)a.push(new Sk.builtin.int_(f(c))),c=JSBI.add(c,h);else for(;JSBI.greaterThan(c,p);)a.push(new Sk.builtin.int_(f(c))),c=JSBI.add(c,h);k=f(k);h=f(h);p=f(p)}return new Sk.builtin.range_(k,p,h,a)}function f(k){return JSBI.lessThan(k,
JSBI.__MAX_SAFE)&&JSBI.greaterThan(k,JSBI.__MIN_SAFE)?JSBI.toNumber(k):k}Sk.builtin.range_=Sk.abstr.buildNativeClass("range",{constructor:function(k,p,h,a){this.start=k;this.stop=p;this.step=h;this.v=a},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"range(stop) -> range object\nrange(start, stop[, step]) -> range object\n\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).",
tp$new(k,p){Sk.abstr.checkNoKwargs("range",p);Sk.abstr.checkArgsLen("range",k,1,3);return b(k[0],k[1],k[2])},$r(){let k="range("+this.start+", "+this.stop;1!=this.step&&(k+=", "+this.step);return new Sk.builtin.str(k+")")},tp$richcompare(k,p){if("Eq"!==p&&"NotEq"!==p||k.ob$type!==Sk.builtin.range_)return Sk.builtin.NotImplemented.NotImplemented$;k=new Sk.builtin.list(k.v);return(new Sk.builtin.list(this.v)).tp$richcompare(k,p)},tp$iter(){return new e(this)},nb$bool(){return 0!==this.v.length},sq$contains(k){const p=
this.v;for(let h=0;h<p.length;h++)if(Sk.misceval.richCompareBool(k,p[h],"Eq"))return!0;return!1},sq$length(){return this.v.length},mp$subscript(k){if(Sk.misceval.isIndex(k)){k=Sk.misceval.asIndexSized(k);0>k&&(k=this.v.length+k);if(0>k||k>=this.v.length)throw new Sk.builtin.IndexError("range object index out of range");return this.v[k]}if(k.constructor===Sk.builtin.slice){const p=[],h=this.v;k.sssiter$(h.length,n=>{p.push(h[n])});let {start:a,stop:c,step:m}=k.slice$indices(h.length);a=Sk.misceval.asIndex(h[a])||
this.start;c=Sk.misceval.asIndex(h[c])||this.stop;m="number"===typeof this.step?m*this.step:JSBI.multiply(this.step,JSBI.BigInt(m));return new Sk.builtin.range_(a,c,m,p)}throw new Sk.builtin.TypeError("range indices must be integers or slices, not "+Sk.abstr.typeName(k));}},getsets:{start:{$get(){return new Sk.builtin.int_(this.start)}},step:{$get(){return new Sk.builtin.int_(this.step)}},stop:{$get(){return new Sk.builtin.int_(this.stop)}}},methods:{__reversed__:{$meth(){return new g(this)},$flags:{NoArgs:!0},
$textsig:null,$doc:"Return a reverse iterator."},count:{$meth(k){let p=0;for(let h=0;h<this.v.length;h++)Sk.misceval.richCompareBool(k,this.v[h],"Eq")&&p++;return new Sk.builtin.int_(p)},$flags:{OneArg:!0},$textsig:null,$doc:"rangeobject.count(value) -> integer -- return number of occurrences of value"},index:{$meth(k){for(let p=0;p<this.v.length;p++)if(Sk.misceval.richCompareBool(k,this.v[p],"Eq"))return new Sk.builtin.int_(p);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(k)+"is not in range");
},$flags:{OneArg:!0},$textsig:null,$doc:"rangeobject.index(value, [start, [stop]]) -> integer -- return index of value.\nRaise ValueError if the value is not present."}},proto:{sk$asarray(){return this.v.slice(0)}},flags:{sk$unacceptableBase:!0}});var e=Sk.abstr.buildIteratorClass("range_iterator",{constructor:function(k){this.$index=0;this.$seq=k.v},iternext(){return this.$seq[this.$index++]},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}}),g=
Sk.abstr.buildIteratorClass("range_reverseiterator",{constructor:function(k){this.$seq=k.v;this.$index=this.$seq.length-1},iternext(){return this.$seq[this.$index--]},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef},flags:{sk$unacceptableBase:!0}});Sk.builtin.range=Sk.builtin.xrange=function(k,p,h){k=b(k,p,h);return new Sk.builtin.list(k.v)}},function(E,Q){Sk.builtin.enumerate=Sk.abstr.buildIteratorClass("enumerate",{constructor:function(b,f){if(!(this instanceof Sk.builtin.enumerate))throw TypeError("Failed to construct 'enumerate': Please use the 'new' operator");
this.$iterable=b;this.$index=f;return this},iternext(b){const f=Sk.misceval.chain(this.$iterable.tp$iternext(b),e=>{if(void 0!==e)return new Sk.builtin.tuple([new Sk.builtin.int_(this.$index++),e])});return b?f:Sk.misceval.retryOptionalSuspensionOrThrow(f)},slots:{tp$doc:"Return an enumerate object.\n\n  iterable\n    an object supporting iteration\n\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\n\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",
tp$new(b,f){let [e,g]=Sk.abstr.copyKeywordsToNamedArgs("enumerate",["iterable","start"],b,f,[new Sk.builtin.int_(0)]);e=Sk.abstr.iter(e);g=Sk.misceval.asIndexOrThrow(g);if(this===Sk.builtin.enumerate.prototype)return new Sk.builtin.enumerate(e,g);b=new this.constructor;Sk.builtin.enumerate.call(b,e,g);return b}},classmethods:Sk.generic.classGetItem});Sk.exportSymbol("Sk.builtin.enumerate",Sk.builtin.enumerate)},function(E,Q){Sk.builtin.filter_=Sk.abstr.buildIteratorClass("filter",{constructor:function(b,
f){this.$func=b;this.$iterable=f},iternext(b){const f=Sk.misceval.iterFor(this.$iterable,e=>Sk.misceval.chain(this.check$filter(e),g=>g?new Sk.misceval.Break(g):void 0));return b?f:Sk.misceval.retryOptionalSuspensionOrThrow(f)},slots:{tp$doc:"Return an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",tp$new(b,f){let [e,g]=Sk.abstr.copyKeywordsToNamedArgs("filter",["predicate","iterable"],b,f,[]);e=Sk.builtin.checkNone(e)?
null:e;g=Sk.abstr.iter(g);if(this===Sk.builtin.filter_.prototype)return new Sk.builtin.filter_(e,g);b=new this.constructor;Sk.builtin.filter_.call(b,e,g);return b}},proto:{check$filter(b){let f;f=null===this.$func?b:Sk.misceval.callsimOrSuspendArray(this.$func,[b]);return Sk.misceval.chain(f,e=>Sk.misceval.isTrue(e)?b:void 0)}}});Sk.exportSymbol("Sk.builtin.filter_",Sk.builtin.filter_)},function(E,Q){Sk.builtin.map_=Sk.abstr.buildIteratorClass("map",{constructor:function(b,f){this.$func=b;this.$iters=
f},iternext(b){const f=[],e=Sk.misceval.chain(Sk.misceval.iterArray(this.$iters,g=>Sk.misceval.chain(g.tp$iternext(b),k=>{if(void 0===k)return new Sk.misceval.Break(!0);f.push(k)})),g=>g?void 0:Sk.misceval.callsimOrSuspendArray(this.$func,f));return b?e:Sk.misceval.retryOptionalSuspensionOrThrow(e)},slots:{tp$doc:"map(func, *iterables) --\x3e map object\n\nMake an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",tp$new(b,
f){this===Sk.builtin.map_.prototype&&Sk.abstr.checkNoKwargs("map",f);Sk.abstr.checkArgsLen("map",b,2);f=b[0];const e=[];for(let g=1;g<b.length;g++)e.push(Sk.abstr.iter(b[g]));if(this===Sk.builtin.map_.prototype)return new Sk.builtin.map_(f,e);b=new this.constructor;Sk.builtin.map_.call(b,f,e);return b}}});Sk.exportSymbol("Sk.builtin.map_",Sk.builtin.map_)},function(E,Q){Sk.builtin.reversed=Sk.abstr.buildIteratorClass("reversed",{constructor:function(b){this.$idx=b.sq$length()-1;this.$seq=b;return this},
iternext(b){if(!(0>this.$idx)){var f=Sk.misceval.tryCatch(()=>Sk.abstr.objectGetItem(this.$seq,new Sk.builtin.int_(this.$idx--),b),e=>{if(e instanceof Sk.builtin.IndexError)this.$idx=-1;else throw e;});return b?f:Sk.misceval.retryOptionalSuspensionOrThrow(f)}},slots:{tp$doc:"Return a reverse iterator over the values of the given sequence.",tp$new(b,f){this===Sk.builtin.reversed.prototype&&Sk.abstr.checkNoKwargs("reversed",f);Sk.abstr.checkArgsLen("reversed",b,1,1);b=b[0];f=Sk.abstr.lookupSpecial(b,
Sk.builtin.str.$reversed);if(void 0!==f)return Sk.misceval.callsimArray(f,[]);if(!Sk.builtin.checkSequence(b)||void 0===Sk.abstr.lookupSpecial(b,Sk.builtin.str.$len))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(b)+"' object is not a sequence");if(this===Sk.builtin.reversed.prototype)return new Sk.builtin.reversed(b);f=new this.constructor;Sk.builtin.reversed.call(f,b);return f}},methods:{__length_hint__:{$meth:function(){return 0<=this.$idx?new Sk.builtin.int_(this.$idx):new Sk.builtin.int_(0)},
$flags:{NoArgs:!0}}}})},function(E,Q){Sk.builtin.zip_=Sk.abstr.buildIteratorClass("zip",{constructor:function(b){this.$iters=b;0===b.length&&(this.tp$iternext=()=>{})},iternext(b){const f=[],e=Sk.misceval.chain(Sk.misceval.iterArray(this.$iters,g=>Sk.misceval.chain(g.tp$iternext(b),k=>{if(void 0===k)return new Sk.misceval.Break(!0);f.push(k)})),g=>g?void 0:new Sk.builtin.tuple(f));return b?e:Sk.misceval.retryOptionalSuspensionOrThrow(e)},slots:{tp$doc:"zip(iter1 [,iter2 [...]]) --\x3e zip object\n\nReturn a zip object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the shortest iterable in the argument sequence\nis exhausted and then it raises StopIteration.",
tp$new(b,f){this===Sk.builtin.zip_.prototype&&Sk.abstr.checkNoKwargs("zip",f);f=[];for(let e=0;e<b.length;e++)try{f.push(Sk.abstr.iter(b[e]))}catch(g){if(g instanceof Sk.builtin.TypeError)throw new Sk.builtin.TypeError("zip argument #"+(e+1)+" must support iteration");throw g;}if(this===Sk.builtin.zip_.prototype)return new Sk.builtin.zip_(f);b=new this.constructor;Sk.builtin.zip_.call(b,f);return b}}});Sk.exportSymbol("Sk.builtin.zip_",Sk.builtin.zip_)},function(E,Q){var b={T_ENDMARKER:0,T_NAME:1,
T_NUMBER:2,T_STRING:3,T_NEWLINE:4,T_INDENT:5,T_DEDENT:6,T_LPAR:7,T_RPAR:8,T_LSQB:9,T_RSQB:10,T_COLON:11,T_COMMA:12,T_SEMI:13,T_PLUS:14,T_MINUS:15,T_STAR:16,T_SLASH:17,T_VBAR:18,T_AMPER:19,T_LESS:20,T_GREATER:21,T_EQUAL:22,T_DOT:23,T_PERCENT:24,T_LBRACE:25,T_RBRACE:26,T_EQEQUAL:27,T_NOTEQUAL:28,T_LESSEQUAL:29,T_GREATEREQUAL:30,T_TILDE:31,T_CIRCUMFLEX:32,T_LEFTSHIFT:33,T_RIGHTSHIFT:34,T_DOUBLESTAR:35,T_PLUSEQUAL:36,T_MINEQUAL:37,T_STAREQUAL:38,T_SLASHEQUAL:39,T_PERCENTEQUAL:40,T_AMPEREQUAL:41,T_VBAREQUAL:42,
T_CIRCUMFLEXEQUAL:43,T_LEFTSHIFTEQUAL:44,T_RIGHTSHIFTEQUAL:45,T_DOUBLESTAREQUAL:46,T_DOUBLESLASH:47,T_DOUBLESLASHEQUAL:48,T_AT:49,T_ATEQUAL:50,T_RARROW:51,T_ELLIPSIS:52,T_OP:53,T_AWAIT:54,T_ASYNC:55,T_ERRORTOKEN:56,T_NT_OFFSET:256,T_N_TOKENS:60,T_COMMENT:57,T_NL:58,T_ENCODING:59};E={"!=":b.T_NOTEQUAL,"%":b.T_PERCENT,"%=":b.T_PERCENTEQUAL,"&":b.T_AMPER,"&=":b.T_AMPEREQUAL,"(":b.T_LPAR,")":b.T_RPAR,"*":b.T_STAR,"**":b.T_DOUBLESTAR,"**=":b.T_DOUBLESTAREQUAL,"*=":b.T_STAREQUAL,"+":b.T_PLUS,"+=":b.T_PLUSEQUAL,
",":b.T_COMMA,"-":b.T_MINUS,"-=":b.T_MINEQUAL,"->":b.T_RARROW,".":b.T_DOT,"...":b.T_ELLIPSIS,"/":b.T_SLASH,"//":b.T_DOUBLESLASH,"//=":b.T_DOUBLESLASHEQUAL,"/=":b.T_SLASHEQUAL,":":b.T_COLON,";":b.T_SEMI,"<":b.T_LESS,"<<":b.T_LEFTSHIFT,"<<=":b.T_LEFTSHIFTEQUAL,"<=":b.T_LESSEQUAL,"=":b.T_EQUAL,"==":b.T_EQEQUAL,">":b.T_GREATER,">=":b.T_GREATEREQUAL,">>":b.T_RIGHTSHIFT,">>=":b.T_RIGHTSHIFTEQUAL,"@":b.T_AT,"@=":b.T_ATEQUAL,"[":b.T_LSQB,"]":b.T_RSQB,"^":b.T_CIRCUMFLEX,"^=":b.T_CIRCUMFLEXEQUAL,"{":b.T_LBRACE,
"|":b.T_VBAR,"|=":b.T_VBAREQUAL,"}":b.T_RBRACE,"~":b.T_TILDE};var f={};(function(){for(var e in b)f[b[e]]=e})();["tok_name","ISTERMINAL","ISNONTERMINAL","ISEOF"].concat(Object.keys(f).map(function(e){return f[e]}));Sk.token={};Sk.token.tokens=b;Sk.token.tok_name=f;Sk.token.EXACT_TOKEN_TYPES=E;Sk.token.ISTERMINAL=function(e){return e<b.T_NT_OFFSET};Sk.token.ISNONTERMINAL=function(e){return e>=b.T_NT_OFFSET};Sk.token.ISEOF=function(e){return e==b.T_ENDMARKER};Sk.exportSymbol("Sk.token",Sk.token);Sk.exportSymbol("Sk.token.tokens",
Sk.token.tokens);Sk.exportSymbol("Sk.token.tok_name",Sk.token.tok_name);Sk.exportSymbol("Sk.token.EXACT_TOKEN_TYPES");Sk.exportSymbol("Sk.token.ISTERMINAL",Sk.token.ISTERMINAL);Sk.exportSymbol("Sk.token.ISNONTERMINAL",Sk.token.ISNONTERMINAL);Sk.exportSymbol("Sk.token.ISEOF",Sk.token.ISEOF)},function(E,Q){Sk.OpMap={"(":Sk.token.tokens.T_LPAR,")":Sk.token.tokens.T_RPAR,"[":Sk.token.tokens.T_LSQB,"]":Sk.token.tokens.T_RSQB,":":Sk.token.tokens.T_COLON,",":Sk.token.tokens.T_COMMA,";":Sk.token.tokens.T_SEMI,
"+":Sk.token.tokens.T_PLUS,"-":Sk.token.tokens.T_MINUS,"*":Sk.token.tokens.T_STAR,"/":Sk.token.tokens.T_SLASH,"|":Sk.token.tokens.T_VBAR,"&":Sk.token.tokens.T_AMPER,"<":Sk.token.tokens.T_LESS,">":Sk.token.tokens.T_GREATER,"=":Sk.token.tokens.T_EQUAL,".":Sk.token.tokens.T_DOT,"%":Sk.token.tokens.T_PERCENT,"`":Sk.token.tokens.T_BACKQUOTE,"{":Sk.token.tokens.T_LBRACE,"}":Sk.token.tokens.T_RBRACE,"@":Sk.token.tokens.T_AT,"@=":Sk.token.tokens.T_ATEQUAL,"==":Sk.token.tokens.T_EQEQUAL,"!=":Sk.token.tokens.T_NOTEQUAL,
"<>":Sk.token.tokens.T_NOTEQUAL,"<=":Sk.token.tokens.T_LESSEQUAL,">=":Sk.token.tokens.T_GREATEREQUAL,"~":Sk.token.tokens.T_TILDE,"^":Sk.token.tokens.T_CIRCUMFLEX,"<<":Sk.token.tokens.T_LEFTSHIFT,">>":Sk.token.tokens.T_RIGHTSHIFT,"**":Sk.token.tokens.T_DOUBLESTAR,"+=":Sk.token.tokens.T_PLUSEQUAL,"-=":Sk.token.tokens.T_MINEQUAL,"*=":Sk.token.tokens.T_STAREQUAL,"/=":Sk.token.tokens.T_SLASHEQUAL,"%=":Sk.token.tokens.T_PERCENTEQUAL,"&=":Sk.token.tokens.T_AMPEREQUAL,"|=":Sk.token.tokens.T_VBAREQUAL,"^=":Sk.token.tokens.T_CIRCUMFLEXEQUAL,
"<<=":Sk.token.tokens.T_LEFTSHIFTEQUAL,">>=":Sk.token.tokens.T_RIGHTSHIFTEQUAL,"**=":Sk.token.tokens.T_DOUBLESTAREQUAL,"//":Sk.token.tokens.T_DOUBLESLASH,"//=":Sk.token.tokens.T_DOUBLESLASHEQUAL,"->":Sk.token.tokens.T_RARROW,"...":Sk.token.tokens.T_ELLIPSIS};Sk.ParseTables={sym:{and_expr:257,and_test:258,annassign:259,arglist:260,argument:261,arith_expr:262,assert_stmt:263,async_funcdef:264,async_stmt:265,atom:266,atom_expr:267,augassign:268,break_stmt:269,classdef:270,comp_for:271,comp_if:272,comp_iter:273,
comp_op:274,comparison:275,compound_stmt:276,continue_stmt:277,debugger_stmt:278,decorated:279,decorator:280,decorators:281,del_stmt:282,dictorsetmaker:283,dotted_as_name:284,dotted_as_names:285,dotted_name:286,encoding_decl:287,eval_input:288,except_clause:289,expr:290,expr_stmt:291,exprlist:292,factor:293,file_input:294,flow_stmt:295,for_stmt:296,funcdef:297,global_stmt:298,if_stmt:299,import_as_name:300,import_as_names:301,import_from:302,import_name:303,import_stmt:304,lambdef:305,lambdef_nocond:306,
nonlocal_stmt:307,not_test:308,or_test:309,parameters:310,pass_stmt:311,power:312,print_stmt:313,raise_stmt:314,return_stmt:315,shift_expr:316,simple_stmt:317,single_input:256,sliceop:318,small_stmt:319,star_expr:320,stmt:321,subscript:322,subscriptlist:323,suite:324,term:325,test:326,test_nocond:327,testlist:328,testlist_comp:329,testlist_star_expr:330,tfpdef:331,trailer:332,try_stmt:333,typedargslist:334,varargslist:335,vfpdef:336,while_stmt:337,with_item:338,with_stmt:339,xor_expr:340,yield_arg:341,
yield_expr:342,yield_stmt:343},number2symbol:{256:"single_input",257:"and_expr",258:"and_test",259:"annassign",260:"arglist",261:"argument",262:"arith_expr",263:"assert_stmt",264:"async_funcdef",265:"async_stmt",266:"atom",267:"atom_expr",268:"augassign",269:"break_stmt",270:"classdef",271:"comp_for",272:"comp_if",273:"comp_iter",274:"comp_op",275:"comparison",276:"compound_stmt",277:"continue_stmt",278:"debugger_stmt",279:"decorated",280:"decorator",281:"decorators",282:"del_stmt",283:"dictorsetmaker",
284:"dotted_as_name",285:"dotted_as_names",286:"dotted_name",287:"encoding_decl",288:"eval_input",289:"except_clause",290:"expr",291:"expr_stmt",292:"exprlist",293:"factor",294:"file_input",295:"flow_stmt",296:"for_stmt",297:"funcdef",298:"global_stmt",299:"if_stmt",300:"import_as_name",301:"import_as_names",302:"import_from",303:"import_name",304:"import_stmt",305:"lambdef",306:"lambdef_nocond",307:"nonlocal_stmt",308:"not_test",309:"or_test",310:"parameters",311:"pass_stmt",312:"power",313:"print_stmt",
314:"raise_stmt",315:"return_stmt",316:"shift_expr",317:"simple_stmt",318:"sliceop",319:"small_stmt",320:"star_expr",321:"stmt",322:"subscript",323:"subscriptlist",324:"suite",325:"term",326:"test",327:"test_nocond",328:"testlist",329:"testlist_comp",330:"testlist_star_expr",331:"tfpdef",332:"trailer",333:"try_stmt",334:"typedargslist",335:"varargslist",336:"vfpdef",337:"while_stmt",338:"with_item",339:"with_stmt",340:"xor_expr",341:"yield_arg",342:"yield_expr",343:"yield_stmt"},dfas:{256:[[[[1,1],
[2,1],[3,2]],[[0,1]],[[2,1]]],{2:1,4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1}],257:[[[[44,1]],[[45,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],258:[[[[46,1]],[[47,0],[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],259:[[[[48,1]],[[49,2]],[[50,3],[0,2]],[[49,4]],[[0,4]]],{48:1}],
260:[[[[51,1]],[[52,2],[0,1]],[[51,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],261:[[[[49,1],[15,2],[53,2]],[[50,2],[54,3],[0,1]],[[49,3]],[[0,3]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],262:[[[[55,1]],[[30,0],[43,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],263:[[[[24,1]],[[49,2]],[[52,3],[0,2]],[[49,4]],[[0,4]]],{24:1}],264:[[[[10,1]],[[56,2]],[[0,2]]],{10:1}],
265:[[[[10,1]],[[57,2],[56,2],[58,2]],[[0,2]]],{10:1}],266:[[[[6,1],[25,1],[33,1],[9,1],[11,1],[12,2],[35,3],[38,4],[19,1],[7,5]],[[0,1]],[[59,1],[60,6]],[[61,1],[62,7],[63,7]],[[64,1],[63,8]],[[7,5],[0,5]],[[59,1]],[[61,1]],[[64,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,33:1,35:1,38:1}],267:[[[[29,1],[65,2]],[[65,2]],[[66,2],[0,2]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,29:1,33:1,35:1,38:1}],268:[[[[67,1],[68,1],[69,1],[70,1],[71,1],[72,1],[73,1],[74,1],[75,1],[76,1],[77,1],[78,1],[79,1]],[[0,1]]],{67:1,
68:1,69:1,70:1,71:1,72:1,73:1,74:1,75:1,76:1,77:1,78:1,79:1}],269:[[[[39,1]],[[0,1]]],{39:1}],270:[[[[13,1]],[[25,2]],[[48,3],[35,4]],[[80,5]],[[61,6],[81,7]],[[0,5]],[[48,3]],[[61,6]]],{13:1}],271:[[[[10,1],[34,2]],[[34,2]],[[82,3]],[[83,4]],[[84,5]],[[85,6],[0,5]],[[0,6]]],{10:1,34:1}],272:[[[[37,1]],[[86,2]],[[85,3],[0,2]],[[0,3]]],{37:1}],273:[[[[87,1],[54,1]],[[0,1]]],{10:1,34:1,37:1}],274:[[[[88,1],[89,1],[8,2],[90,1],[88,1],[83,1],[91,1],[92,3],[93,1],[94,1]],[[0,1]],[[83,1]],[[8,1],[0,3]]],
{8:1,83:1,88:1,89:1,90:1,91:1,92:1,93:1,94:1}],275:[[[[95,1]],[[96,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],276:[[[[97,1],[98,1],[58,1],[99,1],[57,1],[100,1],[56,1],[101,1],[102,1]],[[0,1]]],{4:1,10:1,13:1,20:1,21:1,34:1,37:1,41:1,42:1}],277:[[[[40,1]],[[0,1]]],{40:1}],278:[[[[17,1]],[[0,1]]],{17:1}],279:[[[[103,1]],[[56,2],[104,2],[99,2]],[[0,2]]],{41:1}],280:[[[[41,1]],[[105,2]],[[2,4],[35,3]],[[61,5],[81,6]],[[0,4]],[[2,4]],[[61,5]]],{41:1}],281:[[[[106,
1]],[[106,1],[0,1]]],{41:1}],282:[[[[27,1]],[[82,2]],[[0,2]]],{27:1}],283:[[[[49,1],[107,2],[53,3]],[[48,4],[54,5],[52,6],[0,1]],[[54,5],[52,6],[0,2]],[[95,7]],[[49,7]],[[0,5]],[[49,8],[107,8],[0,6]],[[54,5],[52,9],[0,7]],[[52,6],[0,8]],[[49,10],[53,11],[0,9]],[[48,12]],[[95,13]],[[49,13]],[[52,9],[0,13]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],284:[[[[105,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],{25:1}],285:[[[[109,1]],[[52,0],[0,1]]],{25:1}],286:[[[[25,
1]],[[110,0],[0,1]]],{25:1}],287:[[[[25,1]],[[0,1]]],{25:1}],288:[[[[111,1]],[[2,1],[112,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],289:[[[[113,1]],[[49,2],[0,1]],[[108,3],[52,3],[0,2]],[[49,4]],[[0,4]]],{113:1}],290:[[[[114,1]],[[115,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],291:[[[[116,1]],[[117,2],[50,3],[118,4],[0,1]],[[111,4],[62,4]],[[116,5],[62,5]],[[0,4]],[[50,3],[0,5]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,
15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],292:[[[[95,1],[107,1]],[[52,2],[0,1]],[[95,1],[107,1],[0,2]]],{6:1,7:1,9:1,11:1,12:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],293:[[[[119,2],[30,1],[22,1],[43,1]],[[120,2]],[[0,2]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],294:[[[[2,0],[112,1],[121,0]],[[0,1]]],{2:1,4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,
34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1,112:1}],295:[[[[122,1],[123,1],[124,1],[125,1],[126,1]],[[0,1]]],{5:1,23:1,31:1,39:1,40:1}],296:[[[[34,1]],[[82,2]],[[83,3]],[[111,4]],[[48,5]],[[80,6]],[[127,7],[0,6]],[[48,8]],[[80,9]],[[0,9]]],{34:1}],297:[[[[4,1]],[[25,2]],[[128,3]],[[48,4],[129,5]],[[80,6]],[[49,7]],[[0,6]],[[48,4]]],{4:1}],298:[[[[26,1]],[[25,2]],[[52,1],[0,2]]],{26:1}],299:[[[[37,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[130,1],[0,4]],[[48,6]],[[80,7]],[[0,7]]],{37:1}],300:[[[[25,
1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],{25:1}],301:[[[[131,1]],[[52,2],[0,1]],[[131,1],[0,2]]],{25:1}],302:[[[[36,1]],[[105,2],[19,3],[110,3]],[[32,4]],[[105,2],[19,3],[32,4],[110,3]],[[132,5],[15,5],[35,6]],[[0,5]],[[132,7]],[[61,5]]],{36:1}],303:[[[[32,1]],[[133,2]],[[0,2]]],{32:1}],304:[[[[134,1],[135,1]],[[0,1]]],{32:1,36:1}],305:[[[[14,1]],[[48,2],[136,3]],[[49,4]],[[48,2]],[[0,4]]],{14:1}],306:[[[[14,1]],[[48,2],[136,3]],[[86,4]],[[48,2]],[[0,4]]],{14:1}],307:[[[[18,1]],[[25,2]],[[52,1],[0,2]]],
{18:1}],308:[[[[8,1],[137,2]],[[46,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],309:[[[[138,1]],[[139,0],[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],310:[[[[35,1]],[[61,2],[140,3]],[[0,2]],[[61,2]]],{35:1}],311:[[[[28,1]],[[0,1]]],{28:1}],312:[[[[141,1]],[[53,2],[0,1]],[[120,3]],[[0,3]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,29:1,33:1,35:1,38:1}],313:[[[[16,1]],[[49,2],[142,3],[0,1]],[[52,4],[0,2]],[[49,5]],[[49,2],[0,4]],
[[52,6],[0,5]],[[49,7]],[[52,8],[0,7]],[[49,7],[0,8]]],{16:1}],314:[[[[5,1]],[[49,2],[0,1]],[[36,3],[52,3],[0,2]],[[49,4]],[[52,5],[0,4]],[[49,6]],[[0,6]]],{5:1}],315:[[[[23,1]],[[111,2],[0,1]],[[0,2]]],{23:1}],316:[[[[143,1]],[[144,0],[142,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],317:[[[[145,1]],[[2,2],[146,3]],[[0,2]],[[145,1],[2,2]]],{5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,
36:1,38:1,39:1,40:1,43:1}],318:[[[[48,1]],[[49,2],[0,1]],[[0,2]]],{48:1}],319:[[[[147,1],[148,1],[149,1],[150,1],[151,1],[152,1],[153,1],[154,1],[155,1],[156,1]],[[0,1]]],{5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,36:1,38:1,39:1,40:1,43:1}],320:[[[[15,1]],[[95,2]],[[0,2]]],{15:1}],321:[[[[1,1],[3,1]],[[0,1]]],{4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,
27:1,28:1,29:1,30:1,31:1,32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1}],322:[[[[49,1],[48,2]],[[48,2],[0,1]],[[49,3],[157,4],[0,2]],[[157,4],[0,3]],[[0,4]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,48:1}],323:[[[[158,1]],[[52,2],[0,1]],[[158,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,48:1}],324:[[[[1,1],[2,2]],[[0,1]],[[159,3]],[[121,4]],[[160,1],[121,4]]],{2:1,5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,
17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,36:1,38:1,39:1,40:1,43:1}],325:[[[[120,1]],[[161,0],[15,0],[162,0],[41,0],[163,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],326:[[[[84,1],[164,2]],[[37,3],[0,1]],[[0,2]],[[84,4]],[[127,5]],[[49,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],327:[[[[165,1],[84,1]],[[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],
328:[[[[49,1]],[[52,2],[0,1]],[[49,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],329:[[[[49,1],[107,1]],[[54,2],[52,3],[0,1]],[[0,2]],[[49,4],[107,4],[0,3]],[[52,3],[0,4]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],330:[[[[49,1],[107,1]],[[52,2],[0,1]],[[49,1],[107,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],331:[[[[25,1]],[[48,2],[0,1]],[[49,3]],[[0,3]]],{25:1}],
332:[[[[35,1],[110,2],[38,3]],[[61,4],[81,5]],[[25,4]],[[166,6]],[[0,4]],[[61,4]],[[64,4]]],{35:1,38:1,110:1}],333:[[[[20,1]],[[48,2]],[[80,3]],[[167,4],[168,5]],[[48,6]],[[48,7]],[[80,8]],[[80,9]],[[167,4],[127,10],[168,5],[0,8]],[[0,9]],[[48,11]],[[80,12]],[[168,5],[0,12]]],{20:1}],334:[[[[15,1],[169,2],[53,3]],[[169,4],[52,5],[0,1]],[[50,6],[52,7],[0,2]],[[169,8]],[[52,5],[0,4]],[[169,9],[53,3],[0,5]],[[49,10]],[[15,11],[169,2],[53,3],[0,7]],[[52,12],[0,8]],[[50,13],[52,5],[0,9]],[[52,7],[0,10]],
[[169,14],[52,15],[0,11]],[[0,12]],[[49,4]],[[52,15],[0,14]],[[169,16],[53,3],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],{15:1,25:1,53:1}],335:[[[[15,1],[53,2],[170,3]],[[170,5],[52,4],[0,1]],[[170,6]],[[50,7],[52,8],[0,3]],[[53,2],[170,9],[0,4]],[[52,4],[0,5]],[[52,10],[0,6]],[[49,11]],[[15,12],[53,2],[170,3],[0,8]],[[50,13],[52,4],[0,9]],[[0,10]],[[52,8],[0,11]],[[52,15],[170,14],[0,12]],[[49,5]],[[52,15],[0,14]],[[53,2],[170,16],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],{15:1,25:1,53:1}],336:[[[[25,
1]],[[0,1]]],{25:1}],337:[[[[21,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[0,4]],[[48,6]],[[80,7]],[[0,7]]],{21:1}],338:[[[[49,1]],[[108,2],[0,1]],[[95,3]],[[0,3]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],339:[[[[42,1]],[[171,2]],[[48,3],[52,1]],[[80,4]],[[0,4]]],{42:1}],340:[[[[172,1]],[[173,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],341:[[[[111,2],[36,1]],[[49,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,
30:1,33:1,35:1,36:1,38:1,43:1}],342:[[[[31,1]],[[174,2],[0,1]],[[0,2]]],{31:1}],343:[[[[62,1]],[[0,1]]],{31:1}]},states:[[[[1,1],[2,1],[3,2]],[[0,1]],[[2,1]]],[[[44,1]],[[45,0],[0,1]]],[[[46,1]],[[47,0],[0,1]]],[[[48,1]],[[49,2]],[[50,3],[0,2]],[[49,4]],[[0,4]]],[[[51,1]],[[52,2],[0,1]],[[51,1],[0,2]]],[[[49,1],[15,2],[53,2]],[[50,2],[54,3],[0,1]],[[49,3]],[[0,3]]],[[[55,1]],[[30,0],[43,0],[0,1]]],[[[24,1]],[[49,2]],[[52,3],[0,2]],[[49,4]],[[0,4]]],[[[10,1]],[[56,2]],[[0,2]]],[[[10,1]],[[57,2],[56,
2],[58,2]],[[0,2]]],[[[6,1],[25,1],[33,1],[9,1],[11,1],[12,2],[35,3],[38,4],[19,1],[7,5]],[[0,1]],[[59,1],[60,6]],[[61,1],[62,7],[63,7]],[[64,1],[63,8]],[[7,5],[0,5]],[[59,1]],[[61,1]],[[64,1]]],[[[29,1],[65,2]],[[65,2]],[[66,2],[0,2]]],[[[67,1],[68,1],[69,1],[70,1],[71,1],[72,1],[73,1],[74,1],[75,1],[76,1],[77,1],[78,1],[79,1]],[[0,1]]],[[[39,1]],[[0,1]]],[[[13,1]],[[25,2]],[[48,3],[35,4]],[[80,5]],[[61,6],[81,7]],[[0,5]],[[48,3]],[[61,6]]],[[[10,1],[34,2]],[[34,2]],[[82,3]],[[83,4]],[[84,5]],[[85,
6],[0,5]],[[0,6]]],[[[37,1]],[[86,2]],[[85,3],[0,2]],[[0,3]]],[[[87,1],[54,1]],[[0,1]]],[[[88,1],[89,1],[8,2],[90,1],[88,1],[83,1],[91,1],[92,3],[93,1],[94,1]],[[0,1]],[[83,1]],[[8,1],[0,3]]],[[[95,1]],[[96,0],[0,1]]],[[[97,1],[98,1],[58,1],[99,1],[57,1],[100,1],[56,1],[101,1],[102,1]],[[0,1]]],[[[40,1]],[[0,1]]],[[[17,1]],[[0,1]]],[[[103,1]],[[56,2],[104,2],[99,2]],[[0,2]]],[[[41,1]],[[105,2]],[[2,4],[35,3]],[[61,5],[81,6]],[[0,4]],[[2,4]],[[61,5]]],[[[106,1]],[[106,1],[0,1]]],[[[27,1]],[[82,2]],
[[0,2]]],[[[49,1],[107,2],[53,3]],[[48,4],[54,5],[52,6],[0,1]],[[54,5],[52,6],[0,2]],[[95,7]],[[49,7]],[[0,5]],[[49,8],[107,8],[0,6]],[[54,5],[52,9],[0,7]],[[52,6],[0,8]],[[49,10],[53,11],[0,9]],[[48,12]],[[95,13]],[[49,13]],[[52,9],[0,13]]],[[[105,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],[[[109,1]],[[52,0],[0,1]]],[[[25,1]],[[110,0],[0,1]]],[[[25,1]],[[0,1]]],[[[111,1]],[[2,1],[112,2]],[[0,2]]],[[[113,1]],[[49,2],[0,1]],[[108,3],[52,3],[0,2]],[[49,4]],[[0,4]]],[[[114,1]],[[115,0],[0,1]]],[[[116,1]],
[[117,2],[50,3],[118,4],[0,1]],[[111,4],[62,4]],[[116,5],[62,5]],[[0,4]],[[50,3],[0,5]]],[[[95,1],[107,1]],[[52,2],[0,1]],[[95,1],[107,1],[0,2]]],[[[119,2],[30,1],[22,1],[43,1]],[[120,2]],[[0,2]]],[[[2,0],[112,1],[121,0]],[[0,1]]],[[[122,1],[123,1],[124,1],[125,1],[126,1]],[[0,1]]],[[[34,1]],[[82,2]],[[83,3]],[[111,4]],[[48,5]],[[80,6]],[[127,7],[0,6]],[[48,8]],[[80,9]],[[0,9]]],[[[4,1]],[[25,2]],[[128,3]],[[48,4],[129,5]],[[80,6]],[[49,7]],[[0,6]],[[48,4]]],[[[26,1]],[[25,2]],[[52,1],[0,2]]],[[[37,
1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[130,1],[0,4]],[[48,6]],[[80,7]],[[0,7]]],[[[25,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],[[[131,1]],[[52,2],[0,1]],[[131,1],[0,2]]],[[[36,1]],[[105,2],[19,3],[110,3]],[[32,4]],[[105,2],[19,3],[32,4],[110,3]],[[132,5],[15,5],[35,6]],[[0,5]],[[132,7]],[[61,5]]],[[[32,1]],[[133,2]],[[0,2]]],[[[134,1],[135,1]],[[0,1]]],[[[14,1]],[[48,2],[136,3]],[[49,4]],[[48,2]],[[0,4]]],[[[14,1]],[[48,2],[136,3]],[[86,4]],[[48,2]],[[0,4]]],[[[18,1]],[[25,2]],[[52,1],[0,2]]],[[[8,
1],[137,2]],[[46,2]],[[0,2]]],[[[138,1]],[[139,0],[0,1]]],[[[35,1]],[[61,2],[140,3]],[[0,2]],[[61,2]]],[[[28,1]],[[0,1]]],[[[141,1]],[[53,2],[0,1]],[[120,3]],[[0,3]]],[[[16,1]],[[49,2],[142,3],[0,1]],[[52,4],[0,2]],[[49,5]],[[49,2],[0,4]],[[52,6],[0,5]],[[49,7]],[[52,8],[0,7]],[[49,7],[0,8]]],[[[5,1]],[[49,2],[0,1]],[[36,3],[52,3],[0,2]],[[49,4]],[[52,5],[0,4]],[[49,6]],[[0,6]]],[[[23,1]],[[111,2],[0,1]],[[0,2]]],[[[143,1]],[[144,0],[142,0],[0,1]]],[[[145,1]],[[2,2],[146,3]],[[0,2]],[[145,1],[2,2]]],
[[[48,1]],[[49,2],[0,1]],[[0,2]]],[[[147,1],[148,1],[149,1],[150,1],[151,1],[152,1],[153,1],[154,1],[155,1],[156,1]],[[0,1]]],[[[15,1]],[[95,2]],[[0,2]]],[[[1,1],[3,1]],[[0,1]]],[[[49,1],[48,2]],[[48,2],[0,1]],[[49,3],[157,4],[0,2]],[[157,4],[0,3]],[[0,4]]],[[[158,1]],[[52,2],[0,1]],[[158,1],[0,2]]],[[[1,1],[2,2]],[[0,1]],[[159,3]],[[121,4]],[[160,1],[121,4]]],[[[120,1]],[[161,0],[15,0],[162,0],[41,0],[163,0],[0,1]]],[[[84,1],[164,2]],[[37,3],[0,1]],[[0,2]],[[84,4]],[[127,5]],[[49,2]]],[[[165,1],
[84,1]],[[0,1]]],[[[49,1]],[[52,2],[0,1]],[[49,1],[0,2]]],[[[49,1],[107,1]],[[54,2],[52,3],[0,1]],[[0,2]],[[49,4],[107,4],[0,3]],[[52,3],[0,4]]],[[[49,1],[107,1]],[[52,2],[0,1]],[[49,1],[107,1],[0,2]]],[[[25,1]],[[48,2],[0,1]],[[49,3]],[[0,3]]],[[[35,1],[110,2],[38,3]],[[61,4],[81,5]],[[25,4]],[[166,6]],[[0,4]],[[61,4]],[[64,4]]],[[[20,1]],[[48,2]],[[80,3]],[[167,4],[168,5]],[[48,6]],[[48,7]],[[80,8]],[[80,9]],[[167,4],[127,10],[168,5],[0,8]],[[0,9]],[[48,11]],[[80,12]],[[168,5],[0,12]]],[[[15,1],
[169,2],[53,3]],[[169,4],[52,5],[0,1]],[[50,6],[52,7],[0,2]],[[169,8]],[[52,5],[0,4]],[[169,9],[53,3],[0,5]],[[49,10]],[[15,11],[169,2],[53,3],[0,7]],[[52,12],[0,8]],[[50,13],[52,5],[0,9]],[[52,7],[0,10]],[[169,14],[52,15],[0,11]],[[0,12]],[[49,4]],[[52,15],[0,14]],[[169,16],[53,3],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],[[[15,1],[53,2],[170,3]],[[170,5],[52,4],[0,1]],[[170,6]],[[50,7],[52,8],[0,3]],[[53,2],[170,9],[0,4]],[[52,4],[0,5]],[[52,10],[0,6]],[[49,11]],[[15,12],[53,2],[170,3],[0,8]],
[[50,13],[52,4],[0,9]],[[0,10]],[[52,8],[0,11]],[[52,15],[170,14],[0,12]],[[49,5]],[[52,15],[0,14]],[[53,2],[170,16],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],[[[25,1]],[[0,1]]],[[[21,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[0,4]],[[48,6]],[[80,7]],[[0,7]]],[[[49,1]],[[108,2],[0,1]],[[95,3]],[[0,3]]],[[[42,1]],[[171,2]],[[48,3],[52,1]],[[80,4]],[[0,4]]],[[[172,1]],[[173,0],[0,1]]],[[[111,2],[36,1]],[[49,2]],[[0,2]]],[[[31,1]],[[174,2],[0,1]],[[0,2]]],[[[62,1]],[[0,1]]]],labels:[[0,"EMPTY"],[317,
null],[4,null],[276,null],[1,"def"],[1,"raise"],[1,"True"],[3,null],[1,"not"],[1,"null"],[55,null],[2,null],[25,null],[1,"class"],[1,"lambda"],[16,null],[1,"print"],[1,"debugger"],[1,"nonlocal"],[52,null],[1,"try"],[1,"while"],[31,null],[1,"return"],[1,"assert"],[1,null],[1,"global"],[1,"del"],[1,"pass"],[54,null],[15,null],[1,"yield"],[1,"import"],[1,"False"],[1,"for"],[7,null],[1,"from"],[1,"if"],[9,null],[1,"break"],[1,"continue"],[49,null],[1,"with"],[14,null],[316,null],[19,null],[308,null],
[1,"and"],[11,null],[326,null],[22,null],[261,null],[12,null],[35,null],[271,null],[325,null],[297,null],[339,null],[296,null],[26,null],[283,null],[8,null],[342,null],[329,null],[10,null],[266,null],[332,null],[45,null],[38,null],[40,null],[50,null],[46,null],[41,null],[42,null],[36,null],[43,null],[48,null],[44,null],[37,null],[39,null],[324,null],[260,null],[292,null],[1,"in"],[309,null],[273,null],[327,null],[272,null],[28,null],[21,null],[27,null],[29,null],[1,"is"],[30,null],[20,null],[290,
null],[274,null],[333,null],[299,null],[270,null],[337,null],[279,null],[265,null],[281,null],[264,null],[286,null],[280,null],[320,null],[1,"as"],[284,null],[23,null],[328,null],[0,null],[1,"except"],[340,null],[18,null],[330,null],[268,null],[259,null],[312,null],[293,null],[321,null],[269,null],[277,null],[314,null],[315,null],[343,null],[1,"else"],[310,null],[51,null],[1,"elif"],[300,null],[301,null],[285,null],[303,null],[302,null],[335,null],[275,null],[258,null],[1,"or"],[334,null],[267,null],
[34,null],[262,null],[33,null],[319,null],[13,null],[295,null],[263,null],[291,null],[311,null],[307,null],[313,null],[282,null],[298,null],[304,null],[278,null],[318,null],[322,null],[5,null],[6,null],[47,null],[17,null],[24,null],[305,null],[306,null],[323,null],[289,null],[1,"finally"],[331,null],[336,null],[338,null],[257,null],[32,null],[341,null]],keywords:{False:33,"null":9,True:6,and:47,as:108,assert:24,"break":39,"class":13,"continue":40,"debugger":17,def:4,del:27,elif:130,"else":127,except:113,
"finally":168,"for":34,from:36,global:26,"if":37,"import":32,"in":83,is:92,lambda:14,nonlocal:18,not:8,or:139,pass:28,print:16,raise:5,"return":23,"try":20,"while":21,"with":42,yield:31},tokens:{0:112,1:25,2:11,3:7,4:2,5:159,6:160,7:35,8:61,9:38,10:64,11:48,12:52,13:146,14:43,15:30,16:15,17:162,18:115,19:45,20:94,21:89,22:50,23:110,24:163,25:12,26:59,27:90,28:88,29:91,30:93,31:22,32:173,33:144,34:142,35:53,36:74,37:78,38:68,39:79,40:69,41:72,42:73,43:75,44:77,45:67,46:71,47:161,48:76,49:41,50:70,
51:129,52:19,54:29,55:10},start:256}},function(E,Q){function b(e,g){this.filename=e;this.grammar=g;this.p_flags=0;return this}function f(e,g){void 0===g&&(g="file_input");e=new b(e,Sk.ParseTables);"file_input"===g?e.setup(Sk.ParseTables.sym.file_input):Sk.asserts.fail("todo;");return e}b.FUTURE_PRINT_FUNCTION="print_function";b.FUTURE_UNICODE_LITERALS="unicode_literals";b.FUTURE_DIVISION="division";b.FUTURE_ABSOLUTE_IMPORT="absolute_import";b.FUTURE_WITH_STATEMENT="with_statement";b.FUTURE_NESTED_SCOPES=
"nested_scopes";b.FUTURE_GENERATORS="generators";b.CO_FUTURE_PRINT_FUNCTION=65536;b.CO_FUTURE_UNICODE_LITERALS=131072;b.CO_FUTURE_DIVISON=8192;b.CO_FUTURE_ABSOLUTE_IMPORT=16384;b.CO_FUTURE_WITH_STATEMENT=32768;b.prototype.setup=function(e){e=e||this.grammar.start;this.stack=[{dfa:this.grammar.dfas[e],state:0,node:{type:e,value:null,context:null,children:[]}}];this.used_names={}};b.prototype.addtoken=function(e,g,k){var p,h=this.classify(e,g,k);a:for(;;){var a=this.stack[this.stack.length-1];var c=
a.dfa[0];var m=c[a.state];for(p=0;p<m.length;++p){var n=m[p][0];var d=m[p][1];var l=this.grammar.labels[n][0];if(h===n){Sk.asserts.assert(256>l);this.shift(e,g,d,k);for(k=d;1===c[k].length&&0===c[k][0][0]&&c[k][0][1]===k;){this.pop();if(0===this.stack.length)return!0;a=this.stack[this.stack.length-1];k=a.state;c=a.dfa[0]}return!1}if(256<=l&&(n=this.grammar.dfas[l],n=n[1],n.hasOwnProperty(h))){this.push(l,this.grammar.dfas[l],d,k);continue a}}b:{c=[0,a.state];for(a=m.length;a--;)if(m[a][0]===c[0]&&
m[a][1]===c[1]){m=!0;break b}m=!1}if(m){if(this.pop(),0===this.stack.length)throw new Sk.builtin.SyntaxError("too much input",this.filename);}else throw e=k[0][0],new Sk.builtin.SyntaxError("bad input",this.filename,e,k);}};b.prototype.classify=function(e,g,k){if(e===Sk.token.tokens.T_NAME){this.used_names[g]=!0;var p=this.grammar.keywords.hasOwnProperty(g)&&this.grammar.keywords[g];"print"===g&&(this.p_flags&b.CO_FUTURE_PRINT_FUNCTION||!0===Sk.__future__.print_function)&&(p=!1);if(p)return p}p=this.grammar.tokens.hasOwnProperty(e)&&
this.grammar.tokens[e];if(!p){g="#"+e;for(let h in Sk.token.tokens)if(Sk.token.tokens[h]==e){g=h;break}throw new Sk.builtin.SyntaxError("bad token "+g,this.filename,k[0][0],k);}return p};b.prototype.shift=function(e,g,k,p){var h=this.stack[this.stack.length-1].dfa,a=this.stack[this.stack.length-1].node;a.children.push({type:e,value:g,lineno:p[0][0],col_offset:p[0][1],children:null});this.stack[this.stack.length-1]={dfa:h,state:k,node:a}};b.prototype.push=function(e,g,k,p){e={type:e,value:null,lineno:p[0][0],
col_offset:p[0][1],children:[]};this.stack[this.stack.length-1]={dfa:this.stack[this.stack.length-1].dfa,state:k,node:this.stack[this.stack.length-1].node};this.stack.push({dfa:g,state:0,node:e})};b.prototype.pop=function(){var e=this.stack.pop().node;if(e)if(0!==this.stack.length){var g=this.stack[this.stack.length-1].node;g.children.push(e)}else this.rootnode=e,this.rootnode.used_names=this.used_names};Sk.parse=function(e,g){var k=Sk.token.tokens.T_COMMENT,p=Sk.token.tokens.T_NL,h=Sk.token.tokens.T_OP,
a=Sk.token.tokens.T_ENDMARKER,c=Sk.token.tokens.T_ENCODING,m=!1,n=f(e);Sk._tokenize(e,function(d){var l=d.split("\n").reverse().map(function(r){return r+"\n"});return function(){if(0===l.length)throw new Sk.builtin.Exception("EOF");return l.pop()}}(g),"utf-8",function(d){var l=null;d.type!==k&&d.type!==p&&d.type!==c&&(d.type===h&&(l=Sk.OpMap[d.string]),n.addtoken(l||d.type,d.string,[d.start,d.end,d.line]),d.type===a&&(m=!0))});if(!m)throw new Sk.builtin.SyntaxError("incomplete input",this.filename);
return{cst:n.rootnode,flags:n.p_flags}};Sk.parseTreeDump=function(e,g){var k;g=g||"";var p=""+g;if(256<=e.type)for(p+=Sk.ParseTables.number2symbol[e.type]+"\n",k=0;k<e.children.length;++k)p+=Sk.parseTreeDump(e.children[k],g+"  ");else p+=Sk.token.tok_name[e.type]+": "+(new Sk.builtin.str(e.value)).$r().v+"\n";return p};Sk.exportSymbol("Sk.Parser",b);Sk.exportSymbol("Sk.parse",Sk.parse);Sk.exportSymbol("Sk.parseTreeDump",Sk.parseTreeDump)},function(E,Q){Sk.astnodes={};Sk.astnodes.Load=function(){};
Sk.astnodes.Store=function(){};Sk.astnodes.Del=function(){};Sk.astnodes.AugLoad=function(){};Sk.astnodes.AugStore=function(){};Sk.astnodes.Param=function(){};Sk.astnodes.And=function(){};Sk.astnodes.Or=function(){};Sk.astnodes.Add=function(){};Sk.astnodes.Sub=function(){};Sk.astnodes.Mult=function(){};Sk.astnodes.MatMult=function(){};Sk.astnodes.Div=function(){};Sk.astnodes.Mod=function(){};Sk.astnodes.Pow=function(){};Sk.astnodes.LShift=function(){};Sk.astnodes.RShift=function(){};Sk.astnodes.BitOr=
function(){};Sk.astnodes.BitXor=function(){};Sk.astnodes.BitAnd=function(){};Sk.astnodes.FloorDiv=function(){};Sk.astnodes.Invert=function(){};Sk.astnodes.Not=function(){};Sk.astnodes.UAdd=function(){};Sk.astnodes.USub=function(){};Sk.astnodes.Eq=function(){};Sk.astnodes.NotEq=function(){};Sk.astnodes.Lt=function(){};Sk.astnodes.LtE=function(){};Sk.astnodes.Gt=function(){};Sk.astnodes.GtE=function(){};Sk.astnodes.Is=function(){};Sk.astnodes.IsNot=function(){};Sk.astnodes.In=function(){};Sk.astnodes.NotIn=
function(){};Sk.astnodes.Module=function(b,f){this.body=b;this.docstring=f;return this};Sk.astnodes.Interactive=function(b){this.body=b;return this};Sk.astnodes.Expression=function(b){this.body=b;return this};Sk.astnodes.Suite=function(b){this.body=b;return this};Sk.astnodes.FunctionDef=function(b,f,e,g,k,p,h,a){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==a&&void 0!==a);this.name=b;this.args=f;this.body=e;this.decorator_list=g;this.returns=k;this.docstring=p;this.lineno=h;this.col_offset=
a;return this};Sk.astnodes.AsyncFunctionDef=function(b,f,e,g,k,p,h,a){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==a&&void 0!==a);this.name=b;this.args=f;this.body=e;this.decorator_list=g;this.returns=k;this.docstring=p;this.lineno=h;this.col_offset=a;return this};Sk.astnodes.ClassDef=function(b,f,e,g,k,p,h,a){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==a&&void 0!==a);this.name=b;this.bases=f;this.keywords=e;this.body=g;this.decorator_list=k;this.docstring=
p;this.lineno=h;this.col_offset=a;return this};Sk.astnodes.Return=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.value=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Delete=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.targets=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Assign=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==
g);this.targets=b;this.value=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.AugAssign=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.target=b;this.op=f;this.value=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.AnnAssign=function(b,f,e,g,k,p){Sk.asserts.assert(null!==k&&void 0!==k);Sk.asserts.assert(null!==p&&void 0!==p);this.target=b;this.annotation=f;this.value=e;this.simple=g;this.lineno=k;this.col_offset=p;return this};
Sk.astnodes.For=function(b,f,e,g,k,p){Sk.asserts.assert(null!==k&&void 0!==k);Sk.asserts.assert(null!==p&&void 0!==p);this.target=b;this.iter=f;this.body=e;this.orelse=g;this.lineno=k;this.col_offset=p;return this};Sk.astnodes.AsyncFor=function(b,f,e,g,k,p){Sk.asserts.assert(null!==k&&void 0!==k);Sk.asserts.assert(null!==p&&void 0!==p);this.target=b;this.iter=f;this.body=e;this.orelse=g;this.lineno=k;this.col_offset=p;return this};Sk.astnodes.While=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&
void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.test=b;this.body=f;this.orelse=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.If=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.test=b;this.body=f;this.orelse=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.With=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.items=b;this.body=f;this.lineno=e;this.col_offset=
g;return this};Sk.astnodes.AsyncWith=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.items=b;this.body=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Raise=function(b,f,e,g,k,p){Sk.asserts.assert(null!==k&&void 0!==k);Sk.asserts.assert(null!==p&&void 0!==p);this.exc=b;this.cause=f;this.inst=e;this.tback=g;this.lineno=k;this.col_offset=p;return this};Sk.astnodes.Try=function(b,f,e,g,k,p){Sk.asserts.assert(null!==k&&void 0!==k);Sk.asserts.assert(null!==
p&&void 0!==p);this.body=b;this.handlers=f;this.orelse=e;this.finalbody=g;this.lineno=k;this.col_offset=p;return this};Sk.astnodes.Assert=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.test=b;this.msg=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Import=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.names=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.ImportFrom=function(b,
f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.module=b;this.names=f;this.level=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.Global=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.names=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Nonlocal=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.names=b;this.lineno=f;this.col_offset=
e;return this};Sk.astnodes.Expr=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.value=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Pass=function(b,f){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==f&&void 0!==f);this.lineno=b;this.col_offset=f;return this};Sk.astnodes.Break=function(b,f){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==f&&void 0!==f);this.lineno=b;this.col_offset=f;return this};Sk.astnodes.Continue=
function(b,f){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==f&&void 0!==f);this.lineno=b;this.col_offset=f;return this};Sk.astnodes.Print=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.dest=b;this.values=f;this.nl=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.Debugger=function(b,f){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==f&&void 0!==f);this.lineno=b;this.col_offset=f;return this};Sk.astnodes.BoolOp=
function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.op=b;this.values=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.BinOp=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.left=b;this.op=f;this.right=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.UnaryOp=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.op=b;this.operand=
f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Lambda=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.args=b;this.body=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.IfExp=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.test=b;this.body=f;this.orelse=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.Dict=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==
e);Sk.asserts.assert(null!==g&&void 0!==g);this.keys=b;this.values=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Set=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.elts=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.ListComp=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.elt=b;this.generators=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.SetComp=function(b,
f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.elt=b;this.generators=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.DictComp=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.key=b;this.value=f;this.generators=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.GeneratorExp=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.elt=
b;this.generators=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Await=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.value=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Yield=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.value=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.YieldFrom=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==
e&&void 0!==e);this.value=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Compare=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.left=b;this.ops=f;this.comparators=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.Call=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.func=b;this.args=f;this.keywords=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.Num=function(b,
f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.n=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Str=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.s=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.FormattedValue=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.value=b;this.conversion=f;this.format_spec=e;this.lineno=g;this.col_offset=
k;return this};Sk.astnodes.JoinedStr=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.values=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Bytes=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.s=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.NameConstant=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.value=b;this.lineno=
f;this.col_offset=e;return this};Sk.astnodes.Ellipsis=function(b,f){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==f&&void 0!==f);this.lineno=b;this.col_offset=f;return this};Sk.astnodes.Constant=function(b,f,e){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==e&&void 0!==e);this.value=b;this.lineno=f;this.col_offset=e;return this};Sk.astnodes.Attribute=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.value=
b;this.attr=f;this.ctx=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.Subscript=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.value=b;this.slice=f;this.ctx=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.Starred=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.value=b;this.ctx=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Name=function(b,f,e,g){Sk.asserts.assert(null!==
e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.id=b;this.ctx=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.List=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.elts=b;this.ctx=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Tuple=function(b,f,e,g){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==g&&void 0!==g);this.elts=b;this.ctx=f;this.lineno=e;this.col_offset=g;return this};Sk.astnodes.Slice=
function(b,f,e){this.lower=b;this.upper=f;this.step=e;return this};Sk.astnodes.ExtSlice=function(b){this.dims=b;return this};Sk.astnodes.Index=function(b){this.value=b;return this};Sk.astnodes.comprehension=function(b,f,e,g){this.target=b;this.iter=f;this.ifs=e;this.is_async=g;return this};Sk.astnodes.ExceptHandler=function(b,f,e,g,k){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==k&&void 0!==k);this.type=b;this.name=f;this.body=e;this.lineno=g;this.col_offset=k;return this};Sk.astnodes.arguments_=
function(b,f,e,g,k,p){this.args=b;this.vararg=f;this.kwonlyargs=e;this.kw_defaults=g;this.kwarg=k;this.defaults=p;return this};Sk.astnodes.arg=function b(b,f){this.arg=b;this.annotation=f;return this};Sk.astnodes.keyword=function(b,f){this.arg=b;this.value=f;return this};Sk.astnodes.alias=function(b,f){this.name=b;this.asname=f;return this};Sk.astnodes.withitem=function(b,f){this.context_expr=b;this.optional_vars=f;return this};Sk.astnodes.Module.prototype._astname="Module";Sk.astnodes.Module.prototype._fields=
["body",function(b){return b.body},"docstring",function(b){return b.docstring}];Sk.astnodes.Interactive.prototype._astname="Interactive";Sk.astnodes.Interactive.prototype._fields=["body",function(b){return b.body}];Sk.astnodes.Expression.prototype._astname="Expression";Sk.astnodes.Expression.prototype._fields=["body",function(b){return b.body}];Sk.astnodes.Suite.prototype._astname="Suite";Sk.astnodes.Suite.prototype._fields=["body",function(b){return b.body}];Sk.astnodes.FunctionDef.prototype._astname=
"FunctionDef";Sk.astnodes.FunctionDef.prototype._fields=["name",function(b){return b.name},"args",function(b){return b.args},"body",function(b){return b.body},"decorator_list",function(b){return b.decorator_list},"returns",function(b){return b.returns},"docstring",function(b){return b.docstring}];Sk.astnodes.AsyncFunctionDef.prototype._astname="AsyncFunctionDef";Sk.astnodes.AsyncFunctionDef.prototype._fields=["name",function(b){return b.name},"args",function(b){return b.args},"body",function(b){return b.body},
"decorator_list",function(b){return b.decorator_list},"returns",function(b){return b.returns},"docstring",function(b){return b.docstring}];Sk.astnodes.ClassDef.prototype._astname="ClassDef";Sk.astnodes.ClassDef.prototype._fields=["name",function(b){return b.name},"bases",function(b){return b.bases},"keywords",function(b){return b.keywords},"body",function(b){return b.body},"decorator_list",function(b){return b.decorator_list},"docstring",function(b){return b.docstring}];Sk.astnodes.Return.prototype._astname=
"Return";Sk.astnodes.Return.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Delete.prototype._astname="Delete";Sk.astnodes.Delete.prototype._fields=["targets",function(b){return b.targets}];Sk.astnodes.Assign.prototype._astname="Assign";Sk.astnodes.Assign.prototype._fields=["targets",function(b){return b.targets},"value",function(b){return b.value}];Sk.astnodes.AugAssign.prototype._astname="AugAssign";Sk.astnodes.AugAssign.prototype._fields=["target",function(b){return b.target},
"op",function(b){return b.op},"value",function(b){return b.value}];Sk.astnodes.AnnAssign.prototype._astname="AnnAssign";Sk.astnodes.AnnAssign.prototype._fields=["target",function(b){return b.target},"annotation",function(b){return b.annotation},"value",function(b){return b.value},"simple",function(b){return b.simple}];Sk.astnodes.For.prototype._astname="For";Sk.astnodes.For.prototype._fields=["target",function(b){return b.target},"iter",function(b){return b.iter},"body",function(b){return b.body},
"orelse",function(b){return b.orelse}];Sk.astnodes.AsyncFor.prototype._astname="AsyncFor";Sk.astnodes.AsyncFor.prototype._fields=["target",function(b){return b.target},"iter",function(b){return b.iter},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.While.prototype._astname="While";Sk.astnodes.While.prototype._fields=["test",function(b){return b.test},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.If.prototype._astname="If";
Sk.astnodes.If.prototype._fields=["test",function(b){return b.test},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.With.prototype._astname="With";Sk.astnodes.With.prototype._fields=["items",function(b){return b.items},"body",function(b){return b.body}];Sk.astnodes.AsyncWith.prototype._astname="AsyncWith";Sk.astnodes.AsyncWith.prototype._fields=["items",function(b){return b.items},"body",function(b){return b.body}];Sk.astnodes.Raise.prototype._astname="Raise";
Sk.astnodes.Raise.prototype._fields=["exc",function(b){return b.exc},"cause",function(b){return b.cause},"inst",function(b){return b.inst},"tback",function(b){return b.tback}];Sk.astnodes.Try.prototype._astname="Try";Sk.astnodes.Try.prototype._fields=["body",function(b){return b.body},"handlers",function(b){return b.handlers},"orelse",function(b){return b.orelse},"finalbody",function(b){return b.finalbody}];Sk.astnodes.Assert.prototype._astname="Assert";Sk.astnodes.Assert.prototype._fields=["test",
function(b){return b.test},"msg",function(b){return b.msg}];Sk.astnodes.Import.prototype._astname="Import";Sk.astnodes.Import.prototype._fields=["names",function(b){return b.names}];Sk.astnodes.ImportFrom.prototype._astname="ImportFrom";Sk.astnodes.ImportFrom.prototype._fields=["module",function(b){return b.module},"names",function(b){return b.names},"level",function(b){return b.level}];Sk.astnodes.Global.prototype._astname="Global";Sk.astnodes.Global.prototype._fields=["names",function(b){return b.names}];
Sk.astnodes.Nonlocal.prototype._astname="Nonlocal";Sk.astnodes.Nonlocal.prototype._fields=["names",function(b){return b.names}];Sk.astnodes.Expr.prototype._astname="Expr";Sk.astnodes.Expr.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Pass.prototype._astname="Pass";Sk.astnodes.Pass.prototype._fields=[];Sk.astnodes.Break.prototype._astname="Break";Sk.astnodes.Break.prototype._fields=[];Sk.astnodes.Continue.prototype._astname="Continue";Sk.astnodes.Continue.prototype._fields=[];
Sk.astnodes.Print.prototype._astname="Print";Sk.astnodes.Print.prototype._fields=["dest",function(b){return b.dest},"values",function(b){return b.values},"nl",function(b){return b.nl}];Sk.astnodes.Debugger.prototype._astname="Debugger";Sk.astnodes.Debugger.prototype._fields=[];Sk.astnodes.BoolOp.prototype._astname="BoolOp";Sk.astnodes.BoolOp.prototype._fields=["op",function(b){return b.op},"values",function(b){return b.values}];Sk.astnodes.BinOp.prototype._astname="BinOp";Sk.astnodes.BinOp.prototype._fields=
["left",function(b){return b.left},"op",function(b){return b.op},"right",function(b){return b.right}];Sk.astnodes.UnaryOp.prototype._astname="UnaryOp";Sk.astnodes.UnaryOp.prototype._fields=["op",function(b){return b.op},"operand",function(b){return b.operand}];Sk.astnodes.Lambda.prototype._astname="Lambda";Sk.astnodes.Lambda.prototype._fields=["args",function(b){return b.args},"body",function(b){return b.body}];Sk.astnodes.IfExp.prototype._astname="IfExp";Sk.astnodes.IfExp.prototype._fields=["test",
function(b){return b.test},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.Dict.prototype._astname="Dict";Sk.astnodes.Dict.prototype._fields=["keys",function(b){return b.keys},"values",function(b){return b.values}];Sk.astnodes.Set.prototype._astname="Set";Sk.astnodes.Set.prototype._fields=["elts",function(b){return b.elts}];Sk.astnodes.ListComp.prototype._astname="ListComp";Sk.astnodes.ListComp.prototype._fields=["elt",function(b){return b.elt},"generators",function(b){return b.generators}];
Sk.astnodes.SetComp.prototype._astname="SetComp";Sk.astnodes.SetComp.prototype._fields=["elt",function(b){return b.elt},"generators",function(b){return b.generators}];Sk.astnodes.DictComp.prototype._astname="DictComp";Sk.astnodes.DictComp.prototype._fields=["key",function(b){return b.key},"value",function(b){return b.value},"generators",function(b){return b.generators}];Sk.astnodes.GeneratorExp.prototype._astname="GeneratorExp";Sk.astnodes.GeneratorExp.prototype._fields=["elt",function(b){return b.elt},
"generators",function(b){return b.generators}];Sk.astnodes.Await.prototype._astname="Await";Sk.astnodes.Await.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Yield.prototype._astname="Yield";Sk.astnodes.Yield.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.YieldFrom.prototype._astname="YieldFrom";Sk.astnodes.YieldFrom.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Compare.prototype._astname="Compare";Sk.astnodes.Compare.prototype._fields=
["left",function(b){return b.left},"ops",function(b){return b.ops},"comparators",function(b){return b.comparators}];Sk.astnodes.Call.prototype._astname="Call";Sk.astnodes.Call.prototype._fields=["func",function(b){return b.func},"args",function(b){return b.args},"keywords",function(b){return b.keywords}];Sk.astnodes.Num.prototype._astname="Num";Sk.astnodes.Num.prototype._fields=["n",function(b){return b.n}];Sk.astnodes.Str.prototype._astname="Str";Sk.astnodes.Str.prototype._fields=["s",function(b){return b.s}];
Sk.astnodes.FormattedValue.prototype._astname="FormattedValue";Sk.astnodes.FormattedValue.prototype._fields=["value",function(b){return b.value},"conversion",function(b){return b.conversion},"format_spec",function(b){return b.format_spec}];Sk.astnodes.JoinedStr.prototype._astname="JoinedStr";Sk.astnodes.JoinedStr.prototype._fields=["values",function(b){return b.values}];Sk.astnodes.Bytes.prototype._astname="Bytes";Sk.astnodes.Bytes.prototype._fields=["s",function(b){return b.s}];Sk.astnodes.NameConstant.prototype._astname=
"NameConstant";Sk.astnodes.NameConstant.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Ellipsis.prototype._astname="Ellipsis";Sk.astnodes.Ellipsis.prototype._fields=[];Sk.astnodes.Constant.prototype._astname="Constant";Sk.astnodes.Constant.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Attribute.prototype._astname="Attribute";Sk.astnodes.Attribute.prototype._fields=["value",function(b){return b.value},"attr",function(b){return b.attr},"ctx",function(b){return b.ctx}];
Sk.astnodes.Subscript.prototype._astname="Subscript";Sk.astnodes.Subscript.prototype._fields=["value",function(b){return b.value},"slice",function(b){return b.slice},"ctx",function(b){return b.ctx}];Sk.astnodes.Starred.prototype._astname="Starred";Sk.astnodes.Starred.prototype._fields=["value",function(b){return b.value},"ctx",function(b){return b.ctx}];Sk.astnodes.Name.prototype._astname="Name";Sk.astnodes.Name.prototype._fields=["id",function(b){return b.id},"ctx",function(b){return b.ctx}];Sk.astnodes.List.prototype._astname=
"List";Sk.astnodes.List.prototype._fields=["elts",function(b){return b.elts},"ctx",function(b){return b.ctx}];Sk.astnodes.Tuple.prototype._astname="Tuple";Sk.astnodes.Tuple.prototype._fields=["elts",function(b){return b.elts},"ctx",function(b){return b.ctx}];Sk.astnodes.Load.prototype._astname="Load";Sk.astnodes.Load.prototype._isenum=!0;Sk.astnodes.Store.prototype._astname="Store";Sk.astnodes.Store.prototype._isenum=!0;Sk.astnodes.Del.prototype._astname="Del";Sk.astnodes.Del.prototype._isenum=!0;
Sk.astnodes.AugLoad.prototype._astname="AugLoad";Sk.astnodes.AugLoad.prototype._isenum=!0;Sk.astnodes.AugStore.prototype._astname="AugStore";Sk.astnodes.AugStore.prototype._isenum=!0;Sk.astnodes.Param.prototype._astname="Param";Sk.astnodes.Param.prototype._isenum=!0;Sk.astnodes.Slice.prototype._astname="Slice";Sk.astnodes.Slice.prototype._fields=["lower",function(b){return b.lower},"upper",function(b){return b.upper},"step",function(b){return b.step}];Sk.astnodes.ExtSlice.prototype._astname="ExtSlice";
Sk.astnodes.ExtSlice.prototype._fields=["dims",function(b){return b.dims}];Sk.astnodes.Index.prototype._astname="Index";Sk.astnodes.Index.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.And.prototype._astname="And";Sk.astnodes.And.prototype._isenum=!0;Sk.astnodes.Or.prototype._astname="Or";Sk.astnodes.Or.prototype._isenum=!0;Sk.astnodes.Add.prototype._astname="Add";Sk.astnodes.Add.prototype._isenum=!0;Sk.astnodes.Sub.prototype._astname="Sub";Sk.astnodes.Sub.prototype._isenum=!0;
Sk.astnodes.Mult.prototype._astname="Mult";Sk.astnodes.Mult.prototype._isenum=!0;Sk.astnodes.MatMult.prototype._astname="MatMult";Sk.astnodes.MatMult.prototype._isenum=!0;Sk.astnodes.Div.prototype._astname="Div";Sk.astnodes.Div.prototype._isenum=!0;Sk.astnodes.Mod.prototype._astname="Mod";Sk.astnodes.Mod.prototype._isenum=!0;Sk.astnodes.Pow.prototype._astname="Pow";Sk.astnodes.Pow.prototype._isenum=!0;Sk.astnodes.LShift.prototype._astname="LShift";Sk.astnodes.LShift.prototype._isenum=!0;Sk.astnodes.RShift.prototype._astname=
"RShift";Sk.astnodes.RShift.prototype._isenum=!0;Sk.astnodes.BitOr.prototype._astname="BitOr";Sk.astnodes.BitOr.prototype._isenum=!0;Sk.astnodes.BitXor.prototype._astname="BitXor";Sk.astnodes.BitXor.prototype._isenum=!0;Sk.astnodes.BitAnd.prototype._astname="BitAnd";Sk.astnodes.BitAnd.prototype._isenum=!0;Sk.astnodes.FloorDiv.prototype._astname="FloorDiv";Sk.astnodes.FloorDiv.prototype._isenum=!0;Sk.astnodes.Invert.prototype._astname="Invert";Sk.astnodes.Invert.prototype._isenum=!0;Sk.astnodes.Not.prototype._astname=
"Not";Sk.astnodes.Not.prototype._isenum=!0;Sk.astnodes.UAdd.prototype._astname="UAdd";Sk.astnodes.UAdd.prototype._isenum=!0;Sk.astnodes.USub.prototype._astname="USub";Sk.astnodes.USub.prototype._isenum=!0;Sk.astnodes.Eq.prototype._astname="Eq";Sk.astnodes.Eq.prototype._isenum=!0;Sk.astnodes.NotEq.prototype._astname="NotEq";Sk.astnodes.NotEq.prototype._isenum=!0;Sk.astnodes.Lt.prototype._astname="Lt";Sk.astnodes.Lt.prototype._isenum=!0;Sk.astnodes.LtE.prototype._astname="LtE";Sk.astnodes.LtE.prototype._isenum=
!0;Sk.astnodes.Gt.prototype._astname="Gt";Sk.astnodes.Gt.prototype._isenum=!0;Sk.astnodes.GtE.prototype._astname="GtE";Sk.astnodes.GtE.prototype._isenum=!0;Sk.astnodes.Is.prototype._astname="Is";Sk.astnodes.Is.prototype._isenum=!0;Sk.astnodes.IsNot.prototype._astname="IsNot";Sk.astnodes.IsNot.prototype._isenum=!0;Sk.astnodes.In.prototype._astname="In";Sk.astnodes.In.prototype._isenum=!0;Sk.astnodes.NotIn.prototype._astname="NotIn";Sk.astnodes.NotIn.prototype._isenum=!0;Sk.astnodes.comprehension.prototype._astname=
"comprehension";Sk.astnodes.comprehension.prototype._fields=["target",function(b){return b.target},"iter",function(b){return b.iter},"ifs",function(b){return b.ifs},"is_async",function(b){return b.is_async}];Sk.astnodes.ExceptHandler.prototype._astname="ExceptHandler";Sk.astnodes.ExceptHandler.prototype._fields=["type",function(b){return b.type},"name",function(b){return b.name},"body",function(b){return b.body}];Sk.astnodes.arguments_.prototype._astname="arguments";Sk.astnodes.arguments_.prototype._fields=
["args",function(b){return b.args},"vararg",function(b){return b.vararg},"kwonlyargs",function(b){return b.kwonlyargs},"kw_defaults",function(b){return b.kw_defaults},"kwarg",function(b){return b.kwarg},"defaults",function(b){return b.defaults}];Sk.astnodes.arg.prototype._astname="arg";Sk.astnodes.arg.prototype._fields=["arg",function(b){return b.arg},"annotation",function(b){return b.annotation}];Sk.astnodes.keyword.prototype._astname="keyword";Sk.astnodes.keyword.prototype._fields=["arg",function(b){return b.arg},
"value",function(b){return b.value}];Sk.astnodes.alias.prototype._astname="alias";Sk.astnodes.alias.prototype._fields=["name",function(b){return b.name},"asname",function(b){return b.asname}];Sk.astnodes.withitem.prototype._astname="withitem";Sk.astnodes.withitem.prototype._fields=["context_expr",function(b){return b.context_expr},"optional_vars",function(b){return b.optional_vars}];Sk.exportSymbol("Sk.astnodes",Sk.astnodes)},function(E,Q){function b(z,u,y){this.c_encoding=z;this.c_filename=u;this.c_flags=
y||0}function f(z){Sk.asserts.assert(void 0!==z,"node must be defined");return null===z.children?0:z.children.length}function e(z,u){Sk.asserts.assert(void 0!==z,"node must be defined");Sk.asserts.assert(void 0!==u,"index of child must be specified");return z.children[u]}function g(z,u){Sk.asserts.assert(z.type===u,"node wasn't expected type")}function k(z,u,y){throw new Sk.builtin.SyntaxError(y,z.c_filename,u.lineno);}function p(z){Sk.asserts.assert("string"===typeof z,"expecting string, got "+typeof z);
return new Sk.builtin.str(z)}function h(z){var u,y;switch(z.type){case O.single_input:if(e(z,0).type===T.T_NEWLINE)break;else return h(e(z,0));case O.file_input:for(u=y=0;u<f(z);++u){var G=e(z,u);G.type===O.stmt&&(y+=h(G))}return y;case O.stmt:return h(e(z,0));case O.compound_stmt:return 1;case O.simple_stmt:return Math.floor(f(z)/2);case O.suite:if(1===f(z))return h(e(z,0));y=0;for(u=2;u<f(z)-1;++u)y+=h(e(z,u));return y;default:Sk.asserts.fail("Non-statement found")}return 0}function a(z,u,y,G){y instanceof
Sk.builtin.str&&(y=y.v);if("None"===y)throw new Sk.builtin.SyntaxError("assignment to None",z.c_filename,G);if("True"===y||"False"===y)throw new Sk.builtin.SyntaxError("assignment to True or False is forbidden",z.c_filename,G);}function c(z,u,y,G){var K;Sk.asserts.assert(y!==Sk.astnodes.AugStore&&y!==Sk.astnodes.AugLoad,"context not AugStore or AugLoad");var I=K=null;switch(u.constructor){case Sk.astnodes.Attribute:case Sk.astnodes.Name:y===Sk.astnodes.Store&&a(z,G,u.attr,G.lineno);u.ctx=y;break;
case Sk.astnodes.Starred:u.ctx=y;c(z,u.value,y,G);break;case Sk.astnodes.Subscript:u.ctx=y;break;case Sk.astnodes.List:u.ctx=y;K=u.elts;break;case Sk.astnodes.Tuple:if(0===u.elts.length)throw new Sk.builtin.SyntaxError("can't assign to ()",z.c_filename,G.lineno);u.ctx=y;K=u.elts;break;case Sk.astnodes.Lambda:I="lambda";break;case Sk.astnodes.Call:I="function call";break;case Sk.astnodes.BoolOp:case Sk.astnodes.BinOp:case Sk.astnodes.UnaryOp:I="operator";break;case Sk.astnodes.GeneratorExp:I="generator expression";
break;case Sk.astnodes.Yield:I="yield expression";break;case Sk.astnodes.ListComp:I="list comprehension";break;case Sk.astnodes.SetComp:I="set comprehension";break;case Sk.astnodes.DictComp:I="dict comprehension";break;case Sk.astnodes.Dict:case Sk.astnodes.Set:case Sk.astnodes.Num:case Sk.astnodes.Str:I="literal";break;case Sk.astnodes.NameConstant:I="True, False or None";break;case Sk.astnodes.Compare:I="comparison";break;case Sk.astnodes.Repr:I="repr";break;case Sk.astnodes.IfExp:I="conditional expression";
break;default:Sk.asserts.fail("unhandled expression in assignment")}if(I)throw new Sk.builtin.SyntaxError("can't "+(y===Sk.astnodes.Store?"assign to":"delete")+" "+I,z.c_filename,G.lineno);if(K)for(u=0;u<K.length;++u)c(z,K[u],y,G)}function m(z){if(void 0===da[z.type])throw new Sk.builtin.SyntaxError("invalid syntax",z.type,z.lineno);return da[z.type]}function n(z,u){return z.value?new Sk.builtin.str(z.value):new Sk.builtin.str(z)}function d(z,u){g(u,O.comp_op);if(1===f(u))switch(u=e(u,0),u.type){case T.T_LESS:return Sk.astnodes.Lt;
case T.T_GREATER:return Sk.astnodes.Gt;case T.T_EQEQUAL:return Sk.astnodes.Eq;case T.T_LESSEQUAL:return Sk.astnodes.LtE;case T.T_GREATEREQUAL:return Sk.astnodes.GtE;case T.T_NOTEQUAL:return Sk.astnodes.NotEq;case T.T_NAME:if("in"===u.value)return Sk.astnodes.In;if("is"===u.value)return Sk.astnodes.Is}else if(2===f(u)&&e(u,0).type===T.T_NAME){if("in"===e(u,1).value)return Sk.astnodes.NotIn;if("is"===e(u,0).value)return Sk.astnodes.IsNot}Sk.asserts.fail("invalid comp_op")}function l(z,u){z&&(z.lineno=
u.lineno,z.col_offset=u.col_offset,z.end_lineno=u.end_lineno,z.end_col_offset=u.end_col_offset);return z}function r(z,u){var y,G=[];Sk.asserts.assert(u.type===O.testlist||u.type===O.testlist_star_expr||u.type===O.listmaker||u.type===O.testlist_comp||u.type===O.testlist_safe||u.type===O.testlist1,"node type must be listlike");for(y=0;y<f(u);y+=2)Sk.asserts.assert(e(u,y).type===O.test||e(u,y).type===O.old_test||e(u,y).type===O.star_expr),G[y/2]=V(z,e(u,y));return G}function v(z,u){var y;g(u,O.suite);
var G=[];var K=0;if(e(u,0).type===O.simple_stmt){u=e(u,0);var I=f(u)-1;e(u,I-1).type===T.T_SEMI&&--I;for(y=0;y<I;y+=2)G[K++]=la(z,e(u,y))}else for(y=2;y<f(u)-1;++y){I=e(u,y);g(I,O.stmt);var M=h(I);if(1===M)G[K++]=la(z,I);else for(I=e(I,0),g(I,O.simple_stmt),M=0;M<f(I);M+=2){if(0===f(e(I,M))){Sk.asserts.assert(M+1===f(I));break}G[K++]=la(z,e(I,M))}}Sk.asserts.assert(K===h(u));return G}function q(z,u,y){var G;g(u,O.exprlist);var K=[];for(G=0;G<f(u);G+=2){var I=V(z,e(u,G));K[G/2]=I;y&&c(z,I,y,e(u,G))}return K}
function t(z,u){a:for(;;)switch(u.type){case O.import_as_name:z=null;var y=p(e(u,0).value);3===f(u)&&(z=e(u,2).value);return new Sk.astnodes.alias(y,null==z?null:p(z));case O.dotted_as_name:if(1===f(u)){u=e(u,0);continue a}else return z=t(z,e(u,0)),Sk.asserts.assert(!z.asname),z.asname=p(e(u,2).value),z;case O.dotted_name:if(1===f(u))return new Sk.astnodes.alias(p(e(u,0).value),null);z="";for(y=0;y<f(u);y+=2)z+=e(u,y).value+".";return new Sk.astnodes.alias(p(z.substr(0,z.length-1)),null);case T.T_STAR:return new Sk.astnodes.alias(p("*"),
null);default:throw new Sk.builtin.SyntaxError("unexpected import name",z.c_filename,u.lineno);}}function w(z,u){Sk.asserts.assert(u.type==O.testlist_comp||u.type==O.argument);return W(z,u,0)}function C(z,u){if(e(u,0).type===T.T_MINUS&&2===f(u)){var y=e(u,1);if(y.type===O.factor&&1===f(y)&&(y=e(y,0),y.type===O.power&&1===f(y))){var G=e(y,0);if(G.type===O.atom&&(y=e(G,0),y.type===T.T_NUMBER))return y.value="-"+y.value,na(z,G)}}z=V(z,e(u,1));switch(e(u,0).type){case T.T_PLUS:return new Sk.astnodes.UnaryOp(Sk.astnodes.UAdd,
z,u.lineno,u.col_offset);case T.T_MINUS:return new Sk.astnodes.UnaryOp(Sk.astnodes.USub,z,u.lineno,u.col_offset);case T.T_TILDE:return new Sk.astnodes.UnaryOp(Sk.astnodes.Invert,z,u.lineno,u.col_offset)}Sk.asserts.fail("unhandled factor")}function D(z,u,y,G){var K,I,M;g(u,O.arglist);for(K=M=I=0;K<f(u);K++){var R=e(u,K);R.type==O.argument&&(1==f(R)?I++:e(R,1).type==O.comp_for?(I++,G||k(z,R,"invalid syntax"),1<f(u)&&k(z,R,"Generator expression must be parenthesized")):e(R,0).type==T.T_STAR?I++:M++)}var U=
[];var S=[];for(K=G=M=I=0;K<f(u);K++)if(R=e(u,K),R.type==O.argument){var Z=e(R,0);if(1==f(R)){M&&(G?k(z,Z,"positional argument follows keyword argument unpacking"):k(z,Z,"positional argument follows keyword argument"));var X=V(z,Z);if(!X)return null;U[I++]=X}else if(Z.type==T.T_STAR){if(G)return k(z,Z,"iterable argument unpacking follows keyword argument unpacking"),null;X=V(z,e(R,1));if(!X)return null;R=new Sk.astnodes.Starred(X,Sk.astnodes.Load,Z.lineno,Z.col_offset);U[I++]=R}else if(Z.type==T.T_DOUBLESTAR){K++;
X=V(z,e(R,1));if(!X)return null;R=new Sk.astnodes.keyword(null,X);S[M++]=R;G++}else if(e(R,1).type==O.comp_for){X=w(z,R);if(!X)return null;U[I++]=X}else{var aa;X=V(z,Z);if(!X)return null;if(X.constructor===Sk.astnodes.Lambda)return k(z,Z,"lambda cannot contain assignment"),null;if(X.constructor!==Sk.astnodes.Name)return k(z,Z,"keyword can't be an expression"),null;if(a(z,X.id,R,1))return null;var ma=X.id;for(aa=0;aa<M;aa++)if((X=S[aa].arg)&&X===ma)return k(z,Z,"keyword argument repeated"),null;X=
V(z,e(R,2));if(!X)return null;R=new Sk.astnodes.keyword(ma,X);S[M++]=R}}return new Sk.astnodes.Call(y,U,S,y.lineno,y.col_offset)}function L(z,u,y){g(u,O.trailer);if(e(u,0).type==T.T_LPAR)return 2==f(u)?new Sk.astnodes.Call(y,null,null,u.lineno,u.col_offset):D(z,e(u,1),y,!0);if(e(u,0).type==T.T_DOT){var G=n(e(u,1));return G?new Sk.astnodes.Attribute(y,G,Sk.astnodes.Load,u.lineno,u.col_offset):null}g(e(u,0),T.T_LSQB);g(e(u,2),T.T_RSQB);u=e(u,1);if(1==f(u))return(G=ja(z,e(u,0)))?new Sk.astnodes.Subscript(y,
G,Sk.astnodes.Load,u.lineno,u.col_offset):null;var K,I=1,M=[];for(K=0;K<f(u);K+=2){G=ja(z,e(u,K));if(!G)return null;G.kind!=Y.Index_kind&&(I=0);M[K/2]=G}if(!I)return new Sk.astnodes.Subscript(y,new Sk.astnodes.ExtSlice(M),Sk.astnodes.Load,u.lineno,u.col_offset);z=[];for(K=0;K<M.length;++K)G=M[K],Sk.asserts.assert(G.kind==Y.Index_kind&&G.v.Index.value),z[K]=G.v.Index.value;G=new Sk.astnodes.Tuple(z,Sk.astnodes.Load,u.lineno,u.col_offset);return new Sk.astnodes.Subscript(y,new Sk.astnodes.Index(G),
Sk.astnodes.Load,u.lineno,u.col_offset)}function N(z,u){g(u,O.flow_stmt);var y=e(u,0);switch(y.type){case O.break_stmt:return new Sk.astnodes.Break(u.lineno,u.col_offset,u.end_lineno,u.end_col_offset);case O.continue_stmt:return new Sk.astnodes.Continue(u.lineno,u.col_offset,u.end_lineno,u.end_col_offset);case O.yield_stmt:return(z=V(z,e(y,0)))?new Sk.astnodes.Expr(z,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset):null;case O.return_stmt:if(1==f(y))return new Sk.astnodes.Return(null,u.lineno,
u.col_offset,u.end_lineno,u.end_col_offset);var G=ha(z,e(y,1));return G?new Sk.astnodes.Return(G,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset):null;case O.raise_stmt:if(1==f(y))return new Sk.astnodes.Raise(null,null,null,null,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset);if(2<=f(y)){var K=null;G=V(z,e(y,1));var I=null,M=null;4==f(y)&&"from"==e(y,2).value?(Sk.__future__.python3||k(z,e(y,2),"raise ... from ... is not available in Python 2"),K=V(z,e(y,3))):4<=f(y)&&","==e(y,2).value&&(Sk.__future__.python3&&
k(z,u,"Old raise syntax is not available in Python 3"),I=V(z,e(y,3)),6==f(y)&&(M=V(z,e(y,5))));return new Sk.astnodes.Raise(G,K,I,M,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset)}default:return Sk.asserts.fail("unexpected flow_stmt: ",y.type),null}}function A(z,u){var y=null;Sk.asserts.assert(u.type===O.tfpdef||u.type===O.vfpdef);var G=e(u,0);a(z,G,G.value,G.lineno);G=p(G.value);3==f(u)&&e(u,1).type===T.T_COLON&&(y=V(z,e(u,2)));return new Sk.astnodes.arg(G,y,u.lineno,u.col_offset)}function H(z,
u,y,G,K){var I=y,M=0;G||k(z,e(u,y),"named arguments must follow bare *");for(Sk.asserts.assert(K);I<f(u);){var R=e(u,I);switch(R.type){case O.vfpdef:case O.tfpdef:I+1<f(u)&&e(u,I+1).type==T.T_EQUAL?(K[M]=V(z,e(u,I+2)),I+=2):K[M]=null;var U=3==f(R)?V(z,e(R,2)):null;R=e(R,0);a(z,R,R.value,R.lineno);y=p(R.value);G[M++]=new Sk.astnodes.arg(y,U,R.lineno,R.col_offset);I+=2;break;case T.T_DOUBLESTAR:return I;default:k(z,R,"unexpected node")}}return I}function x(z,u){var y,G,K,I=[],M=[],R=[],U=[],S=null,
Z=null;if(u.type===O.parameters){if(2===f(u))return new Sk.astnodes.arguments_([],null,[],[],null,[]);u=e(u,1)}Sk.asserts.assert(u.type===O.varargslist||u.type===O.typedargslist);for(y=G=K=0;K<f(u);){var X=e(u,K);switch(X.type){case O.tfpdef:case O.vfpdef:if(K+1<f(u)&&e(u,K+1).type==T.T_EQUAL){M[G++]=V(z,e(u,K+2));K+=2;var aa=1}else if(aa)throw new Sk.builtin.SyntaxError("non-default argument follows default argument",z.c_filename,u.lineno);I[y++]=A(z,X);K+=2;break;case T.T_STAR:if(K+1>=f(u)||K+2==
f(u)&&e(u,K+1).type==T.T_COMMA)throw new Sk.builtin.SyntaxError("named arguments must follow bare *",z.c_filename,u.lineno);X=e(u,K+1);X.type==T.T_COMMA?(K+=2,K=H(z,u,K,R,U)):(S=A(z,X),K+=3,K<f(u)&&(e(u,K).type==O.tfpdef||e(u,K).type==O.vfpdef)&&(K=H(z,u,K,R,U)));break;case T.T_DOUBLESTAR:X=e(u,K+1);Sk.asserts.assert(X.type==O.tfpdef||X.type==O.vfpdef);Z=A(z,X);K+=3;break;default:Sk.asserts.fail("unexpected node in varargslist");return}}return new Sk.astnodes.arguments_(I,S,R,U,Z,M)}function B(z,
u,y,G){var K=G?e(u,1):u,I=null,M=1,R=null;if(G&&5>z.c_feature_version)return k(z,K,"Async functions are only supported in Python 3.5 and greater"),null;g(K,O.funcdef);var U=n(e(K,M));if(a(z,U,e(K,M),0))return null;var S=x(z,e(K,M+1));if(!S)return null;if(e(K,M+2).type==T.T_RARROW){I=V(z,e(K,M+3));if(!I)return null;M+=2}if(e(K,M+3).type==T.T_TYPE_COMMENT){R=T.T_NEW_TYPE_COMMENT(e(K,M+3));if(!R)return null;M+=1}var Z=v(z,e(K,M+3));if(!Z)return null;if(1<f(e(K,M+3))&&(M=e(e(K,M+3),1),M.type==T.T_TYPE_COMMENT)){if(null!=
R)return k(z,K,"Cannot have two type comments on def"),null;R=T.T_NEW_TYPE_COMMENT(M);if(!R)return null}return G?new Sk.astnodes.AsyncFunctionDef(U,S,Z,y,I,R,u.lineno,u.col_offset,void 0,void 0):new Sk.astnodes.FunctionDef(U,S,Z,y,I,R,K.lineno,K.col_offset,void 0,void 0)}function F(z,u,y){g(u,O.classdef);if(4==f(u)){var G=v(z,e(u,3));var K=n(e(u,1).value);a(z,e(u,3),K,u.lineno);return new Sk.astnodes.ClassDef(K,[],[],G,y,null,u.lineno,u.col_offset)}if(e(u,3).type===T.T_RPAR)return G=v(z,e(u,5)),K=
n(e(u,1).value),a(z,e(u,3),K,e(u,3).lineno),new Sk.astnodes.ClassDef(K,[],[],G,y,null,u.lineno,u.col_offset);K=n(e(u,1));K=new Sk.astnodes.Name(K,Sk.astnodes.Load,u.lineno,u.col_offset);var I=D(z,e(u,3),K,!1);G=v(z,e(u,6));K=n(e(u,1).value);a(z,e(u,1),K,e(u,1).lineno);return new Sk.astnodes.ClassDef(K,I.args,I.keywords,G,y,null,u.lineno,u.col_offset)}function J(z,u){function y(X,aa){for(X=0;;){g(aa,O.comp_iter);if(e(aa,0).type===O.comp_for)return X;aa=e(aa,0);g(aa,O.comp_if);X++;if(2===f(aa))return X;
aa=e(aa,2)}}var G;var K=function(X,aa){X=0;a:for(;;){X++;g(aa,O.comp_for);if(5===f(aa))aa=e(aa,4);else return X;b:for(;;){g(aa,O.comp_iter);aa=e(aa,0);if(aa.type===O.comp_for)continue a;else if(aa.type===O.comp_if)if(3===f(aa)){aa=e(aa,2);continue b}else return X;break}break}Sk.asserts.fail("logic error in countCompFors")}(z,u);var I=[];for(G=0;G<K;++G){g(u,O.comp_for);var M=e(u,1);var R=q(z,M,Sk.astnodes.Store);var U=V(z,e(u,3));var S=1===f(M)?new Sk.astnodes.comprehension(R[0],U,[]):new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(R,
Sk.astnodes.Store,u.lineno,u.col_offset),U,[]);if(5===f(u)){u=e(u,4);var Z=y(z,u);M=[];for(R=0;R<Z;++R)g(u,O.comp_iter),u=e(u,0),g(u,O.comp_if),U=V(z,e(u,1)),M[R]=U,3===f(u)&&(u=e(u,2));u.type===O.comp_iter&&(u=e(u,0));S.ifs=M}I[G]=S}return I}function P(z,u){var y=[];a:{var G=u;var K=0;b:for(;;){var I=0;K++;g(G,O.comp_for);e(G,0).type==T.T_ASYNC&&(I=1);if(f(G)==5+I)G=e(G,4+I);else break a;c:for(;;){g(G,O.comp_iter);G=e(G,0);if(G.type===O.comp_for)continue b;else if(G.type===O.comp_if)if(3===f(G)){G=
e(G,2);continue c}else break a;break}break}K=void 0}for(G=0;G<K;G++){var M=0;e(u,0).type==T.T_ASYNC&&(M=1);var R=e(u,1+M);var U=q(z,R,Sk.astnodes.Store);if(!U)return null;I=V(z,e(u,3+M));if(!I)return null;var S=U[0];U=1==f(R)?new Sk.astnodes.comprehension(S,I,null,M):new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(U,Sk.astnodes.Store,S.lineno,S.col_offset,R.end_lineno,R.end_col_offset),I,null,M);if(f(u)==5+M){S=[];u=e(u,4+M);a:for(I=u,M=0;;){g(I,O.comp_iter);if(e(I,0).type==O.comp_for){R=M;break a}I=
e(I,0);g(I,O.comp_if);M++;if(2==f(I)){R=M;break a}I=e(I,2)}if(-1==R)return null;for(M=0;M<R;M++){g(u,O.comp_iter);u=e(u,0);g(u,O.comp_if);I=V(z,e(u,1));if(!I)return null;S[M]=I;3==f(u)&&(u=e(u,2))}u.type==O.comp_iter&&(u=e(u,0));U.ifs=S}y[G]=U}return y}function W(z,u,y){Sk.asserts.assert(1<f(u));var G=e(u,0);var K=V(z,G);if(K.constructor===Sk.astnodes.Starred)return k(z,G,"iterable unpacking cannot be used in comprehension"),null;z=P(z,e(u,1));return 0==y?new Sk.astnodes.GeneratorExp(K,z,u.lineno,
u.col_offset,u.end_lineno,u.end_col_offset):1==y?new Sk.astnodes.ListComp(K,z,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset):2==y?new Sk.astnodes.SetComp(K,z,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset):null}function ca(z,u){g(u,O.augassign);u=e(u,0);switch(u.value.charAt(0)){case "+":return Sk.astnodes.Add;case "-":return Sk.astnodes.Sub;case "/":return"/"===u.value.charAt(1)?Sk.astnodes.FloorDiv:Sk.astnodes.Div;case "%":return Sk.astnodes.Mod;case "<":return Sk.astnodes.LShift;case ">":return Sk.astnodes.RShift;
case "&":return Sk.astnodes.BitAnd;case "^":return Sk.astnodes.BitXor;case "|":return Sk.astnodes.BitOr;case "*":return"*"===u.value.charAt(1)?Sk.astnodes.Pow:Sk.astnodes.Mult;case "@":if(Sk.__future__.python3)return Sk.astnodes.MatMult;default:Sk.asserts.fail("invalid augassign")}}function ha(z,u){Sk.asserts.assert(0<f(u));u.type===O.testlist_comp?1<f(u)&&Sk.asserts.assert(e(u,1).type!==O.comp_for):Sk.asserts.assert(u.type===O.testlist||u.type===O.testlist_star_expr);return 1===f(u)?V(z,e(u,0)):
new Sk.astnodes.Tuple(r(z,u),Sk.astnodes.Load,u.lineno,u.col_offset)}function oa(z,u){g(u,O.expr_stmt);if(1===f(u))return new Sk.astnodes.Expr(ha(z,e(u,0)),u.lineno,u.col_offset);if(e(u,1).type===O.augassign){var y=e(u,0);var G=ha(z,y);c(z,G,Sk.astnodes.Store,y);switch(G.constructor){case Sk.astnodes.Name:var K=G.id;a(z,y,K,u.lineno);break;case Sk.astnodes.Attribute:case Sk.astnodes.Subscript:break;case Sk.astnodes.GeneratorExp:throw new Sk.builtin.SyntaxError("augmented assignment to generator expression not possible",
z.c_filename,u.lineno);case Sk.astnodes.Yield:throw new Sk.builtin.SyntaxError("augmented assignment to yield expression not possible",z.c_filename,u.lineno);default:throw new Sk.builtin.SyntaxError("illegal expression for augmented assignment",z.c_filename,u.lineno);}y=e(u,2);K=y.type===O.testlist?ha(z,y):V(z,y);return new Sk.astnodes.AugAssign(G,ca(z,e(u,1)),K,u.lineno,u.col_offset)}if(e(u,1).type===O.annassign){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("Annotated assignment is not supported in Python 2",
z.c_filename,u.lineno);y=e(u,0);var I=e(u,1);var M=1;for(G=y;1==f(G);)G=e(G,0);0<f(G)&&e(G,0).type==T.T_LPAR&&(M=0);G=ha(z,y);switch(G.constructor){case Sk.astnodes.Name:K=G.id;a(z,y,K,u.lineno);c(z,G,Sk.astnodes.Store,y);break;case Sk.astnodes.Attribute:K=G.attr;a(z,y,K,u.lineno);c(z,G,Sk.astnodes.Store,y);break;case Sk.astnodes.Subscript:c(z,G,Sk.astnodes.Store,y);break;case Sk.astnodes.List:throw new Sk.builtin.SyntaxError("only single target (not list) can be annotated",z.c_filename,u.lineno);
case Sk.astnodes.Tuple:throw new Sk.builtin.SyntaxError("only single target (not tuple) can be annotated",z.c_filename,u.lineno);default:throw new Sk.builtin.SyntaxError("illegal target for annotation",z.c_filename,u.lineno);}G.constructor!=Sk.astnodes.Name&&(M=0);y=e(I,1);K=V(z,y);if(2==f(I))return new Sk.astnodes.AnnAssign(G,K,null,M,u.lineno,u.col_offset);y=e(I,3);z=V(z,y);return new Sk.astnodes.AnnAssign(G,K,z,M,u.lineno,u.col_offset)}g(e(u,1),T.T_EQUAL);M=[];for(G=0;G<f(u)-2;G+=2){y=e(u,G);if(y.type===
O.yield_expr)throw new Sk.builtin.SyntaxError("assignment to yield expression not possible",z.c_filename,u.lineno);y=ha(z,y);c(z,y,Sk.astnodes.Store,e(u,G));M[G/2]=y}y=e(u,f(u)-1);z=y.type===O.testlist_star_expr?ha(z,y):V(z,y);return new Sk.astnodes.Assign(M,z,u.lineno,u.col_offset)}function ka(z,u,y,G,K){Sk.asserts.assert(y>=u);Sk.asserts.assert("{"==z.charAt(u-1));Sk.asserts.assert("}"==z.charAt(y)||"!"==z.charAt(y)||":"==z.charAt(y));z=z.substring(u,y);/^\s*$/.test(z)&&k(G,K,"f-string: empty expression not allowed");
try{let M=Sk.parse("<fstring>","("+z+")");var I=Sk.astFromParse(M.cst,"<fstring>",M.flags)}catch(M){throw M.traceback&&M.traceback[0]&&(I=M.traceback[0],I.lineno=(I.lineno||1)-1+K.lineno,I.filename=G.c_filename),M;}Sk.asserts.assert(1==I.body.length&&I.body[0].constructor===Sk.astnodes.Expr);return I.body[0].value}function ia(z,u,y,G,K,I,M){Sk.asserts.assert("{"==z.charAt(u));u++;var R=u;let U=null,S=0,Z=0,X,aa,ma=()=>k(I,M,"f-string: expecting '}'");for(Sk.asserts.assert(u<=y);u<y;u++){let ea=z.charAt(u);
"\\"==ea&&k(I,M,"f-string expression part cannot include a backslash");if(U)ea==U&&(3==S?u+2<y&&z.charAt(u+1)==ea&&z.charAt(u+2)==ea&&(u+=2,U=S=0):S=U=0);else if("'"==ea||'"'==ea)u+2<y&&z.charAt(u+1)==ea&&z.charAt(u+2)==ea?(S=3,u+=2):S=1,U=ea;else if("["==ea||"{"==ea||"("==ea)Z++;else if(0!=Z&&("]"==ea||"}"==ea||")"==ea))Z--;else if("#"==ea)k(I,M,"f-string expression part cannot include '#'");else if(!(0!=Z||"!"!=ea&&":"!=ea&&"}"!=ea||"!"==ea&&u+1<y&&"="==z.charAt(u+1)))break}U&&k(I,M,"f-string: unterminated string");
Z&&k(I,M,"f-string: mismatched '(', '{', or '['");R=ka(z,R,u,I,M);"!"==z.charAt(u)&&(u++,u>=y&&ma(),aa=z.charAt(u),u++,"s"!=aa&&"r"!=aa&&"a"!=aa&&k(I,M,"f-string: invalid conversion character: expected 's', 'r', or 'a'"));u>=y&&ma();":"==z.charAt(u)&&(u++,u>=y&&ma(),[X,u]=ba(z,u,y,G,K+1,I,M));(u>=y||"}"!=z.charAt(u))&&ma();u++;return[new Sk.astnodes.FormattedValue(R,aa,X,M.lineno,M.col_offset),u]}function ba(z,u,y,G,K,I,M){let R=[],U=S=>{if(-1!==S.indexOf("}")){if(/(^|[^}])}(}})*($|[^}])/.test(S))throw new Sk.builtin.SyntaxError("f-string: single '}' is not allowed",
I.c_filename,M.lineno,M.col_offset);S=S.replace(/}}/g,"}")}R.push(new Sk.astnodes.Str(new Sk.builtin.str(S),M.lineno,M.col_offset,I.end_lineno,M.end_col_offset))};for(;u<y;){let S=z.indexOf("{",u);if(0!==K){let Z=z.indexOf("}",u);-1!==Z&&(-1===S?y=Z:S>Z&&(S=-1,y=Z))}if(-1===S){U(z.substring(u,y));u=y;break}else if(S+1<y&&"{"===z.charAt(S+1))U(z.substring(u,S+1)),u=S+2;else{U(z.substring(u,S));u=S;let [Z,X]=ia(z,S,y,G,K,I,M);R.push(Z);u=X}}return[new Sk.astnodes.JoinedStr(R,M.lineno,M.col_offset),
u]}function ja(z,u){var y,G;g(u,O.subscript);var K=e(u,0);var I=y=G=null;if(K.type===T.T_DOT)return new Sk.astnodes.Ellipsis;if(1===f(u)&&K.type===O.test)return new Sk.astnodes.Index(V(z,K));K.type===O.test&&(G=V(z,K));K.type===T.T_COLON?1<f(u)&&(K=e(u,1),K.type===O.test&&(y=V(z,K))):2<f(u)&&(K=e(u,2),K.type===O.test&&(y=V(z,K)));K=e(u,f(u)-1);K.type===O.sliceop&&(1===f(K)?(K=e(K,0),I=new Sk.astnodes.NameConstant(Sk.builtin.none.none$,Sk.astnodes.Load,K.lineno,K.col_offset)):(K=e(K,1),K.type===O.test&&
(I=V(z,K))));return new Sk.astnodes.Slice(G,y,I)}function na(z,u){var y=e(u,0);switch(y.type){case T.T_NAME:var G=y.value;if(4<=G.length&&5>=G.length){if("None"===G)return new Sk.astnodes.NameConstant(Sk.builtin.none.none$,u.lineno,u.col_offset);if("True"===G)return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$,u.lineno,u.col_offset);if("False"===G)return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$,u.lineno,u.col_offset)}z=n(G,z);return new Sk.astnodes.Name(z,Sk.astnodes.Load,u.lineno,
u.col_offset,u.end_lineno,u.end_col_offset);case T.T_STRING:y=[];for(var K=0;K<f(u);++K){var I=e(u,K).value;var M=z;var R=e(u,K);var U=I;var S=U.charAt(0);for(var Z=!1,X=I=!1;;){if("u"!==S&&"U"!==S)if("r"===S||"R"===S)Z=!0;else if("b"===S||"B"===S)X=!0;else if("f"===S||"F"===S)I=!0;else break;U=U.substr(1);S=U.charAt(0)}Sk.asserts.assert("'"===S||'"'===S&&U.charAt(U.length-1)===S);U=U.substr(1,U.length-2);4<=U.length&&U.charAt(0)===S&&U.charAt(1)===S&&(Sk.asserts.assert(U.charAt(U.length-1)===S&&
U.charAt(U.length-2)===S),U=U.substr(2,U.length-4));if(Z||-1===U.indexOf("\\")){if(X)for(S=0;S<U.length;S++)127<U.charCodeAt(S)&&k(M,R,"bytes can only contain ASCII literal characters");M=[p(U),I,X]}else{Z=U;var aa=Z.length,ma="";for(U=0;U<aa;++U)S=Z.charAt(U),"\\"===S?(++U,S=Z.charAt(U),"n"===S?ma+="\n":"\\"===S?ma+="\\":"t"===S?ma+="\t":"r"===S?ma+="\r":"b"===S?ma+="\b":"f"===S?ma+="\f":"v"===S?ma+="\v":"0"===S?ma+="\x00":'"'===S?ma+='"':"'"===S?ma+="'":"\n"!==S&&("x"===S?(U+2>=aa&&k(M,R,"Truncated \\xNN escape"),
ma+=String.fromCharCode(parseInt(Z.substr(U+1,2),16)),U+=2):X||"u"!==S?X||"U"!==S?ma+="\\"+S:(U+8>=aa&&k(M,R,"Truncated \\UXXXXXXXX escape"),ma+=String.fromCodePoint(parseInt(Z.substr(U+1,8),16)),U+=8):(U+4>=aa&&k(M,R,"Truncated \\uXXXX escape"),ma+=String.fromCharCode(parseInt(Z.substr(U+1,4),16)),U+=4))):X&&127<S.charCodeAt(0)?k(M,R,"bytes can only contain ASCII literal characters"):ma+=S;M=ma;M=[p(M),I,X]}I=M;M=I[0];R=I[1];I=I[2];0!=K&&G!==I&&k(z,u,"cannot mix bytes and nonbytes literals");G=I;
if(R){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("invalid string (f-strings are not supported in Python 2)",z.c_filename,e(u,K).lineno);var ea=M.$jsstr();[ea]=ba(ea,0,ea.length,!1,0,z,e(u,K));y.push.apply(y,ea.values);ea=null}else ea?ea.s=ea.s.sq$concat(M):(ea=new (G?Sk.astnodes.Bytes:Sk.astnodes.Str)(M,u.lineno,u.col_offset,z.end_lineno,u.end_col_offset),y.push(ea))}u=1===y.length&&y[0].constructor===Sk.astnodes.Str?y[0]:new Sk.astnodes.JoinedStr(y,u.lineno,u.col_offset,z.end_lineno,
u.end_col_offset);return u;case T.T_NUMBER:z=Sk.astnodes.Num;G=y.value;G=G.replace(pa,"");K=G[G.length-1];if("j"===K||"J"===K)G=new Sk.builtin.complex(0,parseFloat(G.slice(0,-1)));else if(qa.test(G))G=new Sk.builtin.float_(parseFloat(G));else{"0"===G[0]&&"0"!==G&&65>G.charCodeAt(1)&&(G="0o"+G.substring(1));y=!0;if("l"===K||"L"===K)G=G.slice(0,-1),y=!1;K=Number(G);G=K>Number.MAX_SAFE_INTEGER?y?new Sk.builtin.int_(JSBI.BigInt(G)):new Sk.builtin.lng(JSBI.BigInt(G)):y?new Sk.builtin.int_(K):new Sk.builtin.lng(K)}return new z(G,
u.lineno,u.col_offset);case T.T_ELLIPSIS:return new Sk.astnodes.Ellipsis(u.lineno,u.col_offset,u.end_lineno,u.end_col_offset);case T.T_LPAR:return y=e(u,1),y.type==T.T_RPAR?new Sk.astnodes.Tuple([],Sk.astnodes.Load,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset):y.type==O.yield_expr?V(z,y):1==f(y)?ha(z,y):e(y,1).type==O.comp_for?l(w(z,y),u):l(ha(z,y),u);case T.T_LSQB:y=e(u,1);if(y.type==T.T_RSQB)return new Sk.astnodes.List([],Sk.astnodes.Load,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset);
g(y,O.testlist_comp);if(1==f(y)||e(y,1).type==T.T_COMMA)return(z=r(z,y))?new Sk.astnodes.List(z,Sk.astnodes.Load,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset):null;G=y;Sk.asserts.assert(G.type==O.testlist_comp);z=W(z,G,1);return l(z,u);case T.T_LBRACE:y=e(u,1);if(y.type==T.T_RBRACE)return new Sk.astnodes.Dict(null,null,u.lineno,u.col_offset,u.end_lineno,u.end_col_offset);G=e(y,0).type==T.T_DOUBLESTAR;if(1==f(y)||1<f(y)&&e(y,1).type==T.T_COMMA){G=y;K=[];Sk.asserts.assert(G.type===O.dictorsetmaker);
for(y=0;y<f(G);y+=2)ea=V(z,e(G,y)),K[y/2]=ea;z=new Sk.astnodes.Set(K,G.lineno,G.col_offset)}else if(1<f(y)&&e(y,1).type==O.comp_for)G=y,Sk.asserts.assert(G.type===O.dictorsetmaker),Sk.asserts.assert(1<f(G)),y=V(z,e(G,0)),z=J(z,e(G,1)),z=new Sk.astnodes.SetComp(y,z,G.lineno,G.col_offset);else if(f(y)>3-G&&e(y,3-G).type==O.comp_for){if(G)return k(z,u,"dict unpacking cannot be used in dict comprehension"),null;G=y;Sk.asserts.assert(3<f(G));g(e(G,1),T.T_COLON);y=V(z,e(G,0));K=V(z,e(G,2));z=J(z,e(G,3));
z=new Sk.astnodes.DictComp(y,K,z,G.lineno,G.col_offset)}else{G=y;K=[];ea=[];for(I=y=0;I<f(G);I++)M=z,R=G,X=I,e(R,X).type==T.T_DOUBLESTAR?(Sk.asserts.assert(2<=f(R)-X),I=V(M,e(R,X+1)),M={key:null,value:I,i:X+2}):(Sk.asserts.assert(3<=f(R)-X),(I=V(M,e(R,X)))?(U=I,g(e(R,X+1),T.T_COLON),M=(I=V(M,e(R,X+2)))?{key:U,value:I,i:X+3}:!1):M=0),I=M.i,K[y]=M.key,ea[y]=M.value,y++;z=new Sk.astnodes.Dict(K,ea,G.lineno,G.col_offset,G.end_lineno,G.end_col_offset)}return l(z,u);default:return Sk.asserts.fail("unhandled atom "+
y.type),null}}function fa(z,u){var y,G=0;g(u,O.atom_expr);var K=f(u);e(u,0).type===T.T_AWAIT&&(G=1,Sk.asserts.assert(1<K));var I=na(z,e(u,G));if(!I)return null;if(1===K)return I;if(G&&2===K)return new Sk.astnodes.Await(I,u.lineno,u.col_offset);for(y=G+1;y<K;y++){var M=e(u,y);if(M.type!==O.trailer)break;M=L(z,M,I);if(!M)return null;M.lineno=I.lineno;M.col_offset=I.col_offset;I=M}return G?new Sk.astnodes.Await(I,u.line,u.col_offset):I}function V(z,u){a:for(;;){switch(u.type){case O.test:case O.test_nocond:if(e(u,
0).type===O.lambdef||e(u,0).type===O.lambdef_nocond){var y=e(u,0);3===f(y)?(u=new Sk.astnodes.arguments_([],null,null,[]),z=V(z,e(y,2))):(u=x(z,e(y,1)),z=V(z,e(y,3)));return new Sk.astnodes.Lambda(u,z,y.lineno,y.col_offset)}if(1<f(u))return Sk.asserts.assert(5===f(u)),new Sk.astnodes.IfExp(V(z,e(u,2)),V(z,e(u,0)),V(z,e(u,4)),u.lineno,u.col_offset);case O.or_test:case O.and_test:if(1===f(u)){u=e(u,0);continue a}var G=[];for(y=0;y<f(u);y+=2)G[y/2]=V(z,e(u,y));if("and"===e(u,1).value)return new Sk.astnodes.BoolOp(Sk.astnodes.And,
G,u.lineno,u.col_offset);Sk.asserts.assert("or"===e(u,1).value);return new Sk.astnodes.BoolOp(Sk.astnodes.Or,G,u.lineno,u.col_offset);case O.not_test:if(1===f(u)){u=e(u,0);continue a}else return new Sk.astnodes.UnaryOp(Sk.astnodes.Not,V(z,e(u,1)),u.lineno,u.col_offset);case O.comparison:if(1===f(u)){u=e(u,0);continue a}else{var K=[];G=[];for(y=1;y<f(u);y+=2)K[(y-1)/2]=d(z,e(u,y)),G[(y-1)/2]=V(z,e(u,y+1));return new Sk.astnodes.Compare(V(z,e(u,0)),K,G,u.lineno,u.col_offset)}case O.star_expr:return g(u,
O.star_expr),new Sk.astnodes.Starred(V(z,e(u,1)),Sk.astnodes.Load,u.lineno,u.col_offset);case O.expr:case O.xor_expr:case O.and_expr:case O.shift_expr:case O.arith_expr:case O.term:if(1===f(u)){u=e(u,0);continue a}var I=u,M=new Sk.astnodes.BinOp(V(z,e(I,0)),m(e(I,1)),V(z,e(I,2)),I.lineno,I.col_offset),R=(f(I)-1)/2;for(u=1;u<R;++u)y=e(I,2*u+1),G=m(y),K=V(z,e(I,2*u+2)),M=new Sk.astnodes.BinOp(M,G,K,y.lineno,y.col_offset);return M;case O.yield_expr:return G=!1,K=null,1<f(u)&&(y=e(u,1)),y&&(K=e(y,f(y)-
1),2==f(y)?(G=!0,K=V(z,K)):K=ha(z,K)),G?new Sk.astnodes.YieldFrom(K,u.lineno,u.col_offset):new Sk.astnodes.Yield(K,u.lineno,u.col_offset);case O.factor:if(1===f(u)){u=e(u,0);continue a}return C(z,u);case O.power:return y=u,g(y,O.power),u=fa(z,e(y,0)),1!==f(y)&&e(y,f(y)-1).type===O.factor&&(z=V(z,e(y,f(y)-1)),u=new Sk.astnodes.BinOp(u,Sk.astnodes.Pow,z,y.lineno,y.col_offset)),u;default:Sk.asserts.fail("unhandled expr","n.type: %d",u.type)}break}}function la(z,u){u.type===O.stmt&&(Sk.asserts.assert(1===
f(u)),u=e(u,0));u.type===O.simple_stmt&&(Sk.asserts.assert(1===h(u)),u=e(u,0));if(u.type===O.small_stmt)switch(u=e(u,0),u.type){case O.expr_stmt:return oa(z,u);case O.del_stmt:var y=u;g(y,O.del_stmt);return new Sk.astnodes.Delete(q(z,e(y,1),Sk.astnodes.Del),y.lineno,y.col_offset);case O.pass_stmt:return new Sk.astnodes.Pass(u.lineno,u.col_offset);case O.flow_stmt:return N(z,u);case O.import_stmt:var G=u,K;g(G,O.import_stmt);var I=G.lineno;u=G.col_offset;G=e(G,0);if(G.type===O.import_name){G=e(G,1);
g(G,O.dotted_as_names);var M=[];for(K=0;K<f(G);K+=2)M[K/2]=t(z,e(G,K));z=new Sk.astnodes.Import(M,I,u)}else if(G.type===O.import_from){var R=null;y=0;for(M=1;M<f(G);++M)if(e(G,M).type===O.dotted_name){R=t(z,e(G,M));M++;break}else if(e(G,M).type===T.T_DOT)y++;else if(e(G,M).type===T.T_ELLIPSIS)y+=3;else break;++M;switch(e(G,M).type){case T.T_STAR:G=e(G,M);break;case T.T_LPAR:G=e(G,M+1);f(G);break;case O.import_as_names:G=e(G,M);M=f(G);if(0===M%2)throw new Sk.builtin.SyntaxError("trailing comma not allowed without surrounding parentheses",
z.c_filename,G.lineno);break;default:throw new Sk.builtin.SyntaxError("Unexpected node-type in from-import",z.c_filename,G.lineno);}M=[];if(G.type===T.T_STAR)M[0]=t(z,G);else for(K=0;K<f(G);K+=2)M[K/2]=t(z,e(G,K));z=R?R.name.v:"";z=new Sk.astnodes.ImportFrom(p(z),M,y,I,u)}else throw new Sk.builtin.SyntaxError("unknown import statement",z.c_filename,G.lineno);return z;case O.global_stmt:z=u;u=[];g(z,O.global_stmt);for(y=1;y<f(z);y+=2)u[(y-1)/2]=p(e(z,y).value);return new Sk.astnodes.Global(u,z.lineno,
z.col_offset);case O.nonlocal_stmt:k(z,u,"Not implemented: nonlocal");break;case O.assert_stmt:return y=u,g(y,O.assert_stmt),2===f(y)?z=new Sk.astnodes.Assert(V(z,e(y,1)),null,y.lineno,y.col_offset):4===f(y)?z=new Sk.astnodes.Assert(V(z,e(y,1)),V(z,e(y,3)),y.lineno,y.col_offset):(Sk.asserts.fail("improper number of parts to assert stmt"),z=void 0),z;case O.print_stmt:y=u;Sk.__future__.print_function&&k(z,y,"Missing parentheses in call to 'print'");G=1;I=null;g(y,O.print_stmt);2<=f(y)&&e(y,1).type===
T.T_RIGHTSHIFT&&(I=V(z,e(y,2)),G=4);u=[];for(R=0;G<f(y);G+=2,++R)u[R]=V(z,e(y,G));z=e(y,f(y)-1).type===T.T_COMMA?!1:!0;return new Sk.astnodes.Print(I,u,z,y.lineno,y.col_offset);case O.debugger_stmt:return new Sk.astnodes.Debugger(u.lineno,u.col_offset);default:Sk.asserts.fail("unhandled small_stmt")}else switch(y=e(u,0),g(u,O.compound_stmt),y.type){case O.if_stmt:g(y,O.if_stmt);if(4===f(y))z=new Sk.astnodes.If(V(z,e(y,1)),v(z,e(y,3)),[],y.lineno,y.col_offset);else if(u=e(y,4).value.charAt(2),"s"===
u)z=new Sk.astnodes.If(V(z,e(y,1)),v(z,e(y,3)),v(z,e(y,6)),y.lineno,y.col_offset);else if("i"===u){I=f(y)-4;G=!1;u=[];e(y,I+1).type===T.T_NAME&&"s"===e(y,I+1).value.charAt(2)&&(G=!0,I-=3);I/=4;G&&(u=[new Sk.astnodes.If(V(z,e(y,f(y)-6)),v(z,e(y,f(y)-4)),v(z,e(y,f(y)-1)),e(y,f(y)-6).lineno,e(y,f(y)-6).col_offset)],I--);for(R=0;R<I;++R)G=5+4*(I-R-1),u=[new Sk.astnodes.If(V(z,e(y,G)),v(z,e(y,G+2)),u,e(y,G).lineno,e(y,G).col_offset)];z=new Sk.astnodes.If(V(z,e(y,1)),v(z,e(y,3)),u,y.lineno,y.col_offset)}else Sk.asserts.fail("unexpected token in 'if' statement"),
z=void 0;return z;case O.while_stmt:return g(y,O.while_stmt),4===f(y)?z=new Sk.astnodes.While(V(z,e(y,1)),v(z,e(y,3)),[],y.lineno,y.col_offset):7===f(y)?z=new Sk.astnodes.While(V(z,e(y,1)),v(z,e(y,3)),v(z,e(y,6)),y.lineno,y.col_offset):(Sk.asserts.fail("wrong number of tokens for 'while' stmt"),z=void 0),z;case O.for_stmt:return u=[],g(y,O.for_stmt),9===f(y)&&(u=v(z,e(y,8))),G=e(y,1),I=q(z,G,Sk.astnodes.Store),I=1===f(G)?I[0]:new Sk.astnodes.Tuple(I,Sk.astnodes.Store,y.lineno,y.col_offset),new Sk.astnodes.For(I,
ha(z,e(y,3)),v(z,e(y,5)),u,y.lineno,y.col_offset);case O.try_stmt:u=[];K=f(y);I=(K-3)/3;R=[];M=null;g(y,O.try_stmt);G=v(z,e(y,2));if(e(y,K-3).type===T.T_NAME)"finally"===e(y,K-3).value?(9<=K&&e(y,K-6).type===T.T_NAME&&(R=v(z,e(y,K-4)),I--),M=v(z,e(y,K-1))):R=v(z,e(y,K-1)),I--;else if(e(y,K-3).type!==O.except_clause)throw new Sk.builtin.SyntaxError("malformed 'try' statement",z.c_filename,y.lineno);if(0<I)for(K=0;K<I;K++){var U=K;var S=z,Z=e(y,3+3*K),X=e(y,5+3*K);g(Z,O.except_clause);g(X,O.suite);
if(1===f(Z))var aa=new Sk.astnodes.ExceptHandler(null,null,v(S,X),Z.lineno,Z.col_offset);else 2===f(Z)?aa=new Sk.astnodes.ExceptHandler(V(S,e(Z,1)),null,v(S,X),Z.lineno,Z.col_offset):4===f(Z)?(Sk.__future__.python3&&","==e(Z,2).value&&k(S,Z,"Old-style 'except' clauses are not supported in Python 3"),V(S,e(Z,1)),aa=V(S,e(Z,3)),c(S,aa,Sk.astnodes.Store,e(Z,3)),aa=new Sk.astnodes.ExceptHandler(V(S,e(Z,1)),aa,v(S,X),Z.lineno,Z.col_offset)):(Sk.asserts.fail("wrong number of children for except clause"),
aa=void 0);u[U]=aa}Sk.asserts.assert(!!M||0!=u.length);return new Sk.astnodes.Try(G,u,R,M,y.lineno,y.col_offset);case O.with_stmt:u=[];g(y,O.with_stmt);for(I=1;I<f(y)-2;I+=2)G=void 0,M=z,K=e(y,I),g(K,O.with_item),R=V(M,e(K,0)),3==f(K)&&(G=V(M,e(K,2)),c(M,G,Sk.astnodes.Store,K)),G=new Sk.astnodes.withitem(R,G),u[(I-1)/2]=G;z=v(z,e(y,f(y)-1));z=new Sk.astnodes.With(u,z,y.lineno,y.col_offset);return z;case O.funcdef:return B(z,y,[],!1);case O.classdef:return F(z,y,[]);case O.decorated:I=null;g(y,O.decorated);
G=e(y,0);g(G,O.decorators);u=[];for(R=0;R<f(G);++R){M=u;K=R;U=z;aa=e(G,R);g(aa,O.decorator);g(e(aa,0),T.T_AT);g(e(aa,f(aa)-1),T.T_NEWLINE);var ma,ea=e(aa,1);g(ea,O.dotted_name);S=ea.lineno;Z=ea.col_offset;X=p(e(ea,0).value);var ra=new Sk.astnodes.Name(X,Sk.astnodes.Load,S,Z);for(ma=2;ma<f(ea);ma+=2)X=p(e(ea,ma).value),ra=new Sk.astnodes.Attribute(ra,X,Sk.astnodes.Load,S,Z);S=ra;U=3===f(aa)?S:5===f(aa)?new Sk.astnodes.Call(S,[],[],aa.lineno,aa.col_offset):D(U,e(aa,3),S);M[K]=U}Sk.asserts.assert(e(y,
1).type==O.funcdef||e(y,1).type==O.async_funcdef||e(y,1).type==O.classdef);e(y,1).type==O.funcdef?(I=e(y,1),I=B(z,I,u,!1)):e(y,1).type==O.classdef?I=F(z,e(y,1),u):e(y,1).type==O.async_funcdef&&(I=e(y,1),g(I,O.async_funcdef),g(e(I,0),T.T_NAME),Sk.asserts.assert(("async"===e(I,0)).value),g(e(I,1),O.funcdef),I=B(z,I,u,!0));I&&(I.lineno=y.lineno,I.col_offset=y.col_offset);return I;case O.async_stmt:k(z,y,"Not implemented: async");break;default:Sk.asserts.assert("unhandled compound_stmt")}}var O=Sk.ParseTables.sym,
T=Sk.token.tokens,Y={Slice_kind:1,ExtSlice_kind:2,Index_kind:3},da={};da[T.T_VBAR]=Sk.astnodes.BitOr;da[T.T_CIRCUMFLEX]=Sk.astnodes.BitXor;da[T.T_AMPER]=Sk.astnodes.BitAnd;da[T.T_LEFTSHIFT]=Sk.astnodes.LShift;da[T.T_RIGHTSHIFT]=Sk.astnodes.RShift;da[T.T_PLUS]=Sk.astnodes.Add;da[T.T_MINUS]=Sk.astnodes.Sub;da[T.T_STAR]=Sk.astnodes.Mult;da[T.T_SLASH]=Sk.astnodes.Div;da[T.T_DOUBLESLASH]=Sk.astnodes.FloorDiv;da[T.T_PERCENT]=Sk.astnodes.Mod;Sk.setupOperators=function(z){z?da[T.T_AT]=Sk.astnodes.MatMult:
da[T.T_AT]&&delete da[T.T_AT]};Sk.exportSymbol("Sk.setupOperators",Sk.setupOperators);const qa=new RegExp(Sk._tokenize.Floatnumber),pa=/_/g;Sk.astFromParse=function(z,u,y){var G,K=new b("utf-8",u,y),I=[],M=0;switch(z.type){case O.file_input:for(G=0;G<f(z)-1;++G){var R=e(z,G);if(R.type!==T.T_NEWLINE)if(g(R,O.stmt),y=h(R),1===y)I[M++]=la(K,R);else for(R=e(R,0),g(R,O.simple_stmt),u=0;u<y;++u)I[M++]=la(K,e(R,2*u))}return new Sk.astnodes.Module(I);case O.eval_input:Sk.asserts.fail("todo;");case O.single_input:Sk.asserts.fail("todo;");
default:Sk.asserts.fail("todo;")}};Sk.astDump=function(z){var u=function(G){var K,I="";for(K=0;K<G;++K)I+=" ";return I},y=function(G,K){var I;if(null===G)return K+"None";if(G.prototype&&void 0!==G.prototype._astname&&G.prototype._isenum)return K+G.prototype._astname+"()";if(void 0!==G._astname){var M=u(G._astname.length+1);var R=[];for(I=0;I<G._fields.length;I+=2){var U=G._fields[I];var S=G._fields[I+1](G);var Z=u(U.length+1);R.push([U,y(S,K+M+Z)])}S=[];for(I=0;I<R.length;++I)Z=R[I],S.push(Z[0]+"="+
Z[1].replace(/^\s+/,""));I=S.join(",\n"+K+M);return K+G._astname+"("+I+")"}if(Sk.isArrayLike(G)){M=[];for(I=0;I<G.length;++I)R=G[I],M.push(y(R,K+" "));G=M.join(",\n");return K+"["+G.replace(/^\s+/,"")+"]"}G=!0===G?"True":!1===G?"False":G instanceof Sk.builtin.lng?G.tp$str().v:G instanceof Sk.builtin.str?G.$r().v:""+G;return K+G};return y(z,"")};Sk.exportSymbol("Sk.astFromParse",Sk.astFromParse);Sk.exportSymbol("Sk.astDump",Sk.astDump)},function(E,Q){function b(h,a,c){this.__name=h;this.__flags=a;
this.__scope=a>>11&7;this.__namespaces=c||[]}function f(h,a,c,m,n){this.symFlags={};this.name=a;this.varnames=[];this.children=[];this.blockType=c;this.returnsValue=this.varkeywords=this.varargs=this.generator=this.childHasFree=this.hasFree=this.isNested=!1;this.lineno=n;this.table=h;h.cur&&(h.cur.nested||"function"===h.cur.blockType)&&(this.isNested=!0);m.scopeId=p++;h.stss[m.scopeId]=this;this.symbols={}}function e(h){this.filename=h;this.top=this.cur=null;this.stack=[];this.curClass=this.global=
null;this.tmpname=0;this.stss={}}function g(h,a){var c;for(c=0;c<a.length;c++)h(a[c])}function k(h,a){for(var c in a)h[c]=a[c]}Sk.exportSymbol("Sk.SYMTAB_CONSTS",{DEF_GLOBAL:1,DEF_LOCAL:2,DEF_PARAM:4,USE:8,DEF_STAR:16,DEF_DOUBLESTAR:32,DEF_INTUPLE:64,DEF_FREE:128,DEF_FREE_GLOBAL:256,DEF_FREE_CLASS:512,DEF_IMPORT:1024,DEF_BOUND:1030,SCOPE_OFF:11,SCOPE_MASK:7,LOCAL:1,GLOBAL_EXPLICIT:2,GLOBAL_IMPLICIT:3,FREE:4,CELL:5,OPT_IMPORT_STAR:1,OPT_EXEC:2,OPT_BARE_EXEC:4,OPT_TOPLEVEL:8,GENERATOR:2,GENERATOR_EXPRESSION:2,
ModuleBlock:"module",FunctionBlock:"function",ClassBlock:"class"});b.prototype.get_name=function(){return this.__name};b.prototype.is_referenced=function(){return!!(this.__flags&8)};b.prototype.is_parameter=function(){return!!(this.__flags&4)};b.prototype.is_global=function(){return 3===this.__scope||2==this.__scope};b.prototype.is_declared_global=function(){return 2==this.__scope};b.prototype.is_local=function(){return!!(this.__flags&1030)};b.prototype.is_free=function(){return 4==this.__scope};
b.prototype.is_imported=function(){return!!(this.__flags&1024)};b.prototype.is_assigned=function(){return!!(this.__flags&2)};b.prototype.is_namespace=function(){return this.__namespaces&&0<this.__namespaces.length};b.prototype.get_namespaces=function(){return this.__namespaces};var p=0;f.prototype.get_type=function(){return this.blockType};f.prototype.get_name=function(){return this.name};f.prototype.get_lineno=function(){return this.lineno};f.prototype.is_nested=function(){return this.isNested};
f.prototype.has_children=function(){return 0<this.children.length};f.prototype.get_identifiers=function(){return this._identsMatching(function(){return!0})};f.prototype.lookup=function(h){if(this.symbols.hasOwnProperty(h))h=this.symbols[h];else{var a=this.symFlags[h];var c=this.__check_children(h);h=this.symbols[h]=new b(h,a,c)}return h};f.prototype.__check_children=function(h){var a,c=[];for(a=0;a<this.children.length;++a){var m=this.children[a];m.name===h&&c.push(m)}return c};f.prototype._identsMatching=
function(h){var a,c=[];for(a in this.symFlags)this.symFlags.hasOwnProperty(a)&&h(this.symFlags[a])&&c.push(a);c.sort();return c};f.prototype.get_parameters=function(){Sk.asserts.assert("function"==this.get_type(),"get_parameters only valid for function scopes");this._funcParams||(this._funcParams=this._identsMatching(function(h){return h&4}));return this._funcParams};f.prototype.get_locals=function(){Sk.asserts.assert("function"==this.get_type(),"get_locals only valid for function scopes");this._funcLocals||
(this._funcLocals=this._identsMatching(function(h){return h&1030}));return this._funcLocals};f.prototype.get_globals=function(){Sk.asserts.assert("function"==this.get_type(),"get_globals only valid for function scopes");this._funcGlobals||(this._funcGlobals=this._identsMatching(function(h){h=h>>11&7;return 3==h||2==h}));return this._funcGlobals};f.prototype.get_frees=function(){Sk.asserts.assert("function"==this.get_type(),"get_frees only valid for function scopes");this._funcFrees||(this._funcFrees=
this._identsMatching(function(h){return 4==(h>>11&7)}));return this._funcFrees};f.prototype.get_methods=function(){var h;Sk.asserts.assert("class"==this.get_type(),"get_methods only valid for class scopes");if(!this._classMethods){var a=[];for(h=0;h<this.children.length;++h)a.push(this.children[h].name);a.sort();this._classMethods=a}return this._classMethods};f.prototype.getScope=function(h){h=this.symFlags[h];return void 0===h?0:h>>11&7};e.prototype.getStsForAst=function(h){Sk.asserts.assert(void 0!==
h.scopeId,"ast wasn't added to st?");h=this.stss[h.scopeId];Sk.asserts.assert(void 0!==h,"unknown sym tab entry");return h};e.prototype.SEQStmt=function(h){var a,c;if(null!==h){Sk.asserts.assert(Sk.isArrayLike(h),"SEQ: nodes isn't array? got "+h.toString());var m=h.length;for(c=0;c<m;++c)(a=h[c])&&this.visitStmt(a)}};e.prototype.SEQExpr=function(h){var a,c;if(null!==h){Sk.asserts.assert(Sk.isArrayLike(h),"SEQ: nodes isn't array? got "+h.toString());var m=h.length;for(c=0;c<m;++c)(a=h[c])&&this.visitExpr(a)}};
e.prototype.enterBlock=function(h,a,c,m){h=Sk.fixReserved(h);var n=null;this.cur&&(n=this.cur,this.stack.push(this.cur));this.cur=new f(this,h,a,c,m);"top"===h&&(this.global=this.cur.symFlags);n&&n.children.push(this.cur)};e.prototype.exitBlock=function(){this.cur=null;0<this.stack.length&&(this.cur=this.stack.pop())};e.prototype.visitParams=function(h,a){var c;for(c=0;c<h.length;++c)if(a=h[c],a.constructor===Sk.astnodes.arg)this.addDef(a.arg,4,a.lineno);else throw new Sk.builtin.SyntaxError("invalid expression in parameter list",
this.filename);};e.prototype.visitAnnotations=function(h,a){h.posonlyargs&&this.visitArgAnnotations(h.posonlyargs);h.args&&this.visitArgAnnotations(h.args);h.vararg&&h.vararg.annotation&&this.visitExpr(h.vararg.annotation);h.kwarg&&h.kwarg.annotation&&this.visitExpr(h.kwarg.annotation);h.kwonlyargs&&this.visitArgAnnotations(h.kwonlyargs);a&&this.visitExpr(a)};e.prototype.visitArgAnnotations=function(h){for(let a=0;a<h.length;a++){const c=h[a];c.annotation&&this.visitExpr(c.annotation)}};e.prototype.visitArguments=
function(h,a){h.args&&this.visitParams(h.args,!0);h.kwonlyargs&&this.visitParams(h.kwonlyargs,!0);h.vararg&&(this.addDef(h.vararg.arg,4,a),this.cur.varargs=!0);h.kwarg&&(this.addDef(h.kwarg.arg,4,a),this.cur.varkeywords=!0)};e.prototype.newTmpname=function(h){this.addDef(new Sk.builtin.str("_["+ ++this.tmpname+"]"),2,h)};e.prototype.addDef=function(h,a,c){var m=Sk.mangleName(this.curClass,h).v;m=Sk.fixReserved(m);var n=this.cur.symFlags[m];if(void 0!==n){if(a&4&&n&4)throw new Sk.builtin.SyntaxError("duplicate argument '"+
h.v+"' in function definition",this.filename,c);n|=a}else n=a;this.cur.symFlags[m]=n;a&4?this.cur.varnames.push(m):a&1&&(n=a,h=this.global[m],void 0!==h&&(n|=h),this.global[m]=n)};e.prototype.visitSlice=function(h){var a;switch(h.constructor){case Sk.astnodes.Slice:h.lower&&this.visitExpr(h.lower);h.upper&&this.visitExpr(h.upper);h.step&&this.visitExpr(h.step);break;case Sk.astnodes.ExtSlice:for(a=0;a<h.dims.length;++a)this.visitSlice(h.dims[a]);break;case Sk.astnodes.Index:this.visitExpr(h.value)}};
e.prototype.visitStmt=function(h){var a;Sk.asserts.assert(void 0!==h,"visitStmt called with undefined");switch(h.constructor){case Sk.astnodes.FunctionDef:this.addDef(h.name,2,h.lineno);h.args.defaults&&this.SEQExpr(h.args.defaults);h.decorator_list&&this.SEQExpr(h.decorator_list);this.visitAnnotations(h.args,h.returns);this.enterBlock(h.name.v,"function",h,h.lineno);this.visitArguments(h.args,h.lineno);this.SEQStmt(h.body);this.exitBlock();break;case Sk.astnodes.ClassDef:this.addDef(h.name,2,h.lineno);
this.SEQExpr(h.bases);h.decorator_list&&this.SEQExpr(h.decorator_list);this.enterBlock(h.name.v,"class",h,h.lineno);this.curClass=h.name;this.SEQStmt(h.body);this.exitBlock();break;case Sk.astnodes.Return:h.value&&(this.visitExpr(h.value),this.cur.returnsValue=!0);break;case Sk.astnodes.Delete:this.SEQExpr(h.targets);break;case Sk.astnodes.Assign:this.SEQExpr(h.targets);this.visitExpr(h.value);break;case Sk.astnodes.AnnAssign:if(h.target.constructor==Sk.astnodes.Name){var c=h.target;var m=Sk.mangleName(this.curClass,
c.id).v;m=Sk.fixReserved(m);c=this.cur.symFlags[m];if(c&2049&&this.global!=this.cur.symFlags&&h.simple)throw new Sk.builtin.SyntaxError("annotated name '"+m+"' can't be global",this.filename,h.lineno);h.simple?this.addDef(new Sk.builtin.str(m),4098,h.lineno):h.value&&this.addDef(new Sk.builtin.str(m),2,h.lineno)}else this.visitExpr(h.target);this.visitExpr(h.annotation);h.value&&this.visitExpr(h.value);break;case Sk.astnodes.AugAssign:this.visitExpr(h.target);this.visitExpr(h.value);break;case Sk.astnodes.Print:h.dest&&
this.visitExpr(h.dest);this.SEQExpr(h.values);break;case Sk.astnodes.For:this.visitExpr(h.target);this.visitExpr(h.iter);this.SEQStmt(h.body);h.orelse&&this.SEQStmt(h.orelse);break;case Sk.astnodes.While:this.visitExpr(h.test);this.SEQStmt(h.body);h.orelse&&this.SEQStmt(h.orelse);break;case Sk.astnodes.If:this.visitExpr(h.test);this.SEQStmt(h.body);h.orelse&&this.SEQStmt(h.orelse);break;case Sk.astnodes.Raise:h.exc&&(this.visitExpr(h.exc),h.inst&&(this.visitExpr(h.inst),h.tback&&this.visitExpr(h.tback)),
h.cause&&this.visitExpr(h.cause));break;case Sk.astnodes.Assert:this.visitExpr(h.test);h.msg&&this.visitExpr(h.msg);break;case Sk.astnodes.Import:case Sk.astnodes.ImportFrom:this.visitAlias(h.names,h.lineno);break;case Sk.astnodes.Global:var n=h.names.length;for(a=0;a<n;++a){m=Sk.mangleName(this.curClass,h.names[a]).v;m=Sk.fixReserved(m);c=this.cur.symFlags[m];if(c&10){if(c&2)throw new Sk.builtin.SyntaxError("name '"+m+"' is assigned to before global declaration",this.filename,h.lineno);throw new Sk.builtin.SyntaxError("name '"+
m+"' is used prior to global declaration",this.filename,h.lineno);}this.addDef(new Sk.builtin.str(m),1,h.lineno)}break;case Sk.astnodes.Expr:this.visitExpr(h.value);break;case Sk.astnodes.Pass:case Sk.astnodes.Break:case Sk.astnodes.Continue:case Sk.astnodes.Debugger:break;case Sk.astnodes.With:g(this.visit_withitem.bind(this),h.items);g(this.visitStmt.bind(this),h.body);break;case Sk.astnodes.Try:this.SEQStmt(h.body);this.visitExcepthandlers(h.handlers);this.SEQStmt(h.orelse);this.SEQStmt(h.finalbody);
break;default:Sk.asserts.fail("Unhandled type "+h.constructor.name+" in visitStmt")}};e.prototype.visit_withitem=function(h){this.visitExpr(h.context_expr);h.optional_vars&&this.visitExpr(h.optional_vars)};e.prototype.visitExpr=function(h){Sk.asserts.assert(void 0!==h,"visitExpr called with undefined");switch(h.constructor){case Sk.astnodes.BoolOp:this.SEQExpr(h.values);break;case Sk.astnodes.BinOp:this.visitExpr(h.left);this.visitExpr(h.right);break;case Sk.astnodes.UnaryOp:this.visitExpr(h.operand);
break;case Sk.astnodes.Lambda:this.addDef(new Sk.builtin.str("lambda"),2,h.lineno);h.args.defaults&&this.SEQExpr(h.args.defaults);this.enterBlock("lambda","function",h,h.lineno);this.visitArguments(h.args,h.lineno);this.visitExpr(h.body);this.exitBlock();break;case Sk.astnodes.IfExp:this.visitExpr(h.test);this.visitExpr(h.body);this.visitExpr(h.orelse);break;case Sk.astnodes.Dict:this.SEQExpr(h.keys);this.SEQExpr(h.values);break;case Sk.astnodes.DictComp:case Sk.astnodes.SetComp:this.visitComprehension(h.generators,
0);break;case Sk.astnodes.ListComp:this.newTmpname(h.lineno);this.visitExpr(h.elt);this.visitComprehension(h.generators,0);break;case Sk.astnodes.GeneratorExp:this.visitGenexp(h);break;case Sk.astnodes.YieldFrom:case Sk.astnodes.Yield:h.value&&this.visitExpr(h.value);this.cur.generator=!0;if(this.cur.returnsValue)throw new Sk.builtin.SyntaxError("'return' with argument inside generator",this.filename);break;case Sk.astnodes.Compare:this.visitExpr(h.left);this.SEQExpr(h.comparators);break;case Sk.astnodes.Call:this.visitExpr(h.func);
if(h.args)for(let a of h.args)a.constructor===Sk.astnodes.Starred?this.visitExpr(a.value):this.visitExpr(a);if(h.keywords)for(let a of h.keywords)this.visitExpr(a.value);break;case Sk.astnodes.Num:case Sk.astnodes.Str:case Sk.astnodes.Bytes:break;case Sk.astnodes.JoinedStr:for(let a of h.values)this.visitExpr(a);break;case Sk.astnodes.FormattedValue:this.visitExpr(h.value);h.format_spec&&this.visitExpr(h.format_spec);break;case Sk.astnodes.Attribute:this.visitExpr(h.value);break;case Sk.astnodes.Subscript:this.visitExpr(h.value);
this.visitSlice(h.slice);break;case Sk.astnodes.Name:this.addDef(h.id,h.ctx===Sk.astnodes.Load?8:2,h.lineno);break;case Sk.astnodes.NameConstant:break;case Sk.astnodes.List:case Sk.astnodes.Tuple:case Sk.astnodes.Set:this.SEQExpr(h.elts);break;case Sk.astnodes.Starred:this.visitExpr(h.value);break;case Sk.astnodes.Ellipsis:break;default:Sk.asserts.fail("Unhandled type "+h.constructor.name+" in visitExpr")}};e.prototype.visitComprehension=function(h,a){var c,m=h.length;for(c=a;c<m;++c)a=h[c],this.visitExpr(a.target),
this.visitExpr(a.iter),this.SEQExpr(a.ifs)};e.prototype.visitAlias=function(h,a){var c,m;for(m=0;m<h.length;++m){var n=h[m];var d=c=null===n.asname?n.name.v:n.asname.v;n=c.indexOf(".");-1!==n&&(d=c.substr(0,n));if("*"!==c)this.addDef(new Sk.builtin.str(d),1024,a);else if("module"!==this.cur.blockType)throw new Sk.builtin.SyntaxError("import * only allowed at module level",this.filename);}};e.prototype.visitGenexp=function(h){var a=h.generators[0];this.visitExpr(a.iter);this.enterBlock("genexpr","function",
h,h.lineno);this.cur.generator=!0;this.addDef(new Sk.builtin.str(".0"),4,h.lineno);this.visitExpr(a.target);this.SEQExpr(a.ifs);this.visitComprehension(h.generators,1);this.visitExpr(h.elt);this.exitBlock()};e.prototype.visitExcepthandlers=function(h){var a,c;for(a=0;c=h[a];++a)c.type&&this.visitExpr(c.type),c.name&&this.visitExpr(c.name),this.SEQStmt(c.body)};e.prototype.analyzeBlock=function(h,a,c,m){var n={};var d={},l={},r={},v={};"class"==h.blockType&&(k(l,m),a&&k(r,a));for(t in h.symFlags){var q=
h.symFlags[t];this.analyzeName(h,d,t,q,a,n,c,m)}"class"!==h.blockType&&("function"===h.blockType&&k(r,n),a&&k(r,a),k(l,m));n={};var t=h.children.length;for(q=0;q<t;++q)if(m=h.children[q],this.analyzeChildBlock(m,r,v,l,n),m.hasFree||m.childHasFree)h.childHasFree=!0;k(v,n);"function"===h.blockType&&this.analyzeCells(d,v);a=this.updateSymbols(h.symFlags,d,a,v,"class"===h.blockType);h.hasFree=h.hasFree||a;k(c,v)};e.prototype.analyzeChildBlock=function(h,a,c,m,n){var d={};k(d,a);a={};k(a,c);c={};k(c,m);
this.analyzeBlock(h,d,a,c);k(n,a)};e.prototype.analyzeCells=function(h,a){var c;for(c in h){var m=h[c];1===m&&void 0!==a[c]&&(h[c]=5,delete a[c])}};e.prototype.updateSymbols=function(h,a,c,m,n){var d,l=!1;for(d in h){var r=h[d];var v=a[d];r|=v<<11;h[d]=r}for(d in m)a=h[d],void 0!==a?n&&a&1031&&(a|=512,h[d]=a):void 0!==c[d]&&(h[d]=8192,l=!0);return l};e.prototype.analyzeName=function(h,a,c,m,n,d,l,r){if(m&1){if(m&4)throw new Sk.builtin.SyntaxError("name '"+c+"' is local and global",this.filename,h.lineno);
a[c]=2;r[c]=null;n&&void 0!==n[c]&&delete n[c]}else m&1030?(a[c]=1,d[c]=null,delete r[c]):n&&void 0!==n[c]?(a[c]=4,h.hasFree=!0,l[c]=null):(r&&void 0!==r[c]||!h.isNested||(h.hasFree=!0),a[c]=3)};e.prototype.analyze=function(){this.analyzeBlock(this.top,null,{},{})};Sk.symboltable=function(h,a){var c=new e(a);c.enterBlock("top","module",h,0);c.top=c.cur;for(a=0;a<h.body.length;++a)c.visitStmt(h.body[a]);c.exitBlock();c.analyze();return c};Sk.dumpSymtab=function(h){var a=function(n){return n?"True":
"False"},c=function(n){var d,l=[];for(d=0;d<n.length;++d)l.push((new Sk.builtin.str(n[d])).$r().v);return"["+l.join(", ")+"]"},m=function(n,d){var l,r;void 0===d&&(d="");var v=d+"Sym_type: "+n.get_type()+"\n";v+=d+"Sym_name: "+n.get_name()+"\n";v+=d+"Sym_lineno: "+n.get_lineno()+"\n";v+=d+"Sym_nested: "+a(n.is_nested())+"\n";v+=d+"Sym_haschildren: "+a(n.has_children())+"\n";"class"===n.get_type()?v+=d+"Class_methods: "+c(n.get_methods())+"\n":"function"===n.get_type()&&(v+=d+"Func_params: "+c(n.get_parameters())+
"\n",v+=d+"Func_locals: "+c(n.get_locals())+"\n",v+=d+"Func_globals: "+c(n.get_globals())+"\n",v+=d+"Func_frees: "+c(n.get_frees())+"\n");v+=d+"-- Identifiers --\n";var q=n.get_identifiers();var t=q.length;for(r=0;r<t;++r){var w=n.lookup(q[r]);v+=d+"name: "+w.get_name()+"\n";v+=d+"  is_referenced: "+a(w.is_referenced())+"\n";v+=d+"  is_imported: "+a(w.is_imported())+"\n";v+=d+"  is_parameter: "+a(w.is_parameter())+"\n";v+=d+"  is_global: "+a(w.is_global())+"\n";v+=d+"  is_declared_global: "+a(w.is_declared_global())+
"\n";v+=d+"  is_local: "+a(w.is_local())+"\n";v+=d+"  is_free: "+a(w.is_free())+"\n";v+=d+"  is_assigned: "+a(w.is_assigned())+"\n";v+=d+"  is_namespace: "+a(w.is_namespace())+"\n";var C=w.get_namespaces();var D=C.length;v+=d+"  namespaces: [\n";var L=[];for(l=0;l<D;++l)w=C[l],L.push(m(w,d+"    "));v+=L.join("\n");v+=d+"  ]\n"}return v};return m(h.top,"")};Sk.exportSymbol("Sk.symboltable",Sk.symboltable);Sk.exportSymbol("Sk.dumpSymtab",Sk.dumpSymtab)},function(E,Q){function b(a,c,m,n,d){this.filename=
a;this.st=c;this.flags=m;this.canSuspend=n;this.interactive=!1;this.nestlevel=0;this.u=null;this.stack=[];this.result=[];this.allUnits=[];this.source=d?d.split("\n"):!1}function f(){this.name=this.ste=null;this.doesSuspend=this.canSuspend=!1;this.private_=null;this.lineno=this.firstlineno=0;this.linenoSet=!1;this.localnames=[];this.localtemps=[];this.tempsToSave=[];this.blocknum=0;this.blocks=[];this.curblock=0;this.consts={};this.scopename=null;this.suffixCode=this.switchCode=this.varDeclsCode=this.prefixCode=
"";this.breakBlocks=[];this.continueBlocks=[];this.exceptBlocks=[];this.finallyBlocks=[]}function e(a){return void 0===p[a]?a:a+"_$rw$"}function g(a,c){var m=c.v;if(null===a||null===m||"_"!==m.charAt(0)||"_"!==m.charAt(1)||"_"===m.charAt(m.length-1)&&"_"===m.charAt(m.length-2))return c;var n=a.v;n.replace(/_/g,"");if(""===n)return c;n=a.v;n.replace(/^_*/,"");return n=new Sk.builtin.str("_"+n+m)}var k;Sk.gensymcount=0;f.prototype.activateScope=function(){var a=this;k=function(){var c,m=a.blocks[a.curblock];
if(null===m._next)for(c=0;c<arguments.length;++c)m.push(arguments[c])}};b.prototype.getSourceLine=function(a){Sk.asserts.assert(this.source);return this.source[a-1]};b.prototype.annotateSource=function(a){var c;if(this.source){var m=a.lineno;var n=a.col_offset;k("\n//\n// line ",m,":\n// ",this.getSourceLine(m),"\n// ");for(c=0;c<n;++c)k(" ");k("^\n//\n");Sk.asserts.assert(void 0!==a.lineno&&void 0!==a.col_offset);k("$currLineNo = ",m,";\n$currColNo = ",n,";\n\n")}};b.prototype.gensym=function(a){return a=
"$"+(a||"")+Sk.gensymcount++};b.prototype.niceName=function(a){return this.gensym(a.replace("<","").replace(">","").replace(" ","_"))};var p=Sk.builtin.str.reservedWords_;b.prototype.makeConstant=function(a){var c,m="";for(c=0;c<arguments.length;++c)m+=arguments[c];for(n in this.u.consts)if(this.u.consts.hasOwnProperty(n)&&(c=this.u.consts[n],c==m))return n;var n=this.u.scopename+"."+this.gensym("const");this.u.consts[n]=m;return n};b.prototype._gr=function(a,c){var m,n=this.gensym(a);this.u.localtemps.push(n);
k("var ",n,"=");for(m=1;m<arguments.length;++m)k(arguments[m]);k(";");return n};b.prototype.outputInterruptTest=function(){var a="";if(null!==Sk.execLimit||null!==Sk.yieldLimit&&this.u.canSuspend)a+="var $dateNow = Date.now();",null!==Sk.execLimit&&(a+="if ($dateNow - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeoutError(Sk.timeoutMsg())}"),null!==Sk.yieldLimit&&this.u.canSuspend&&(a=a+"if (!$waking && ($dateNow - Sk.lastYield > Sk.yieldLimit)) {var $susp = $saveSuspension({data: {type: 'Sk.yield'}, resume: function() {}}, '"+
(this.filename+"',$currLineNo,$currColNo);"),a+="$susp.$blk = $blk;$susp.optional = true;return $susp;}$waking = false;",this.u.doesSuspend=!0);return a};b.prototype._jumpfalse=function(a,c){a=this._gr("jfalse","(",a,"===false||!Sk.misceval.isTrue(",a,"))");k("if(",a,"){/*test failed */$blk=",c,";continue;}")};b.prototype._jumpundef=function(a,c){k("if(",a,"===undefined){$blk=",c,";continue;}")};b.prototype._jumpnotundef=function(a,c){k("if(",a,"!==undefined){$blk=",c,";continue;}")};b.prototype._jumptrue=
function(a,c){a=this._gr("jtrue","(",a,"===true||Sk.misceval.isTrue(",a,"))");k("if(",a,"){/*test passed */$blk=",c,";continue;}")};b.prototype._jump=function(a){null===this.u.blocks[this.u.curblock]._next&&(k("$blk=",a,";"),this.u.blocks[this.u.curblock]._next=a)};b.prototype._checkSuspension=function(a){if(this.u.canSuspend){var c=this.newBlock("function return or resume suspension");this._jump(c);this.setBlock(c);a=a||{lineno:"$currLineNo",col_offset:"$currColNo"};k("if ($ret && $ret.$isSuspension) { return $saveSuspension($ret,'"+
this.filename+"',"+a.lineno+","+a.col_offset+"); }");this.u.doesSuspend=!0;this.u.tempsToSave=this.u.tempsToSave.concat(this.u.localtemps)}else k("if ($ret && $ret.$isSuspension) { $ret = Sk.misceval.retryOptionalSuspensionOrThrow($ret); }")};b.prototype.cunpackstarstoarray=function(a,c){if(!a||0==a.length)return"[]";let m=!1;for(let n of a){if(c&&m)throw new Sk.builtin.SyntaxError("Extended argument unpacking is not permitted in Python 2");n.constructor===Sk.astnodes.Starred&&(m=!0)}if(m){c=this._gr("unpack",
"[]");for(let n of a)n.constructor!==Sk.astnodes.Starred?k(c,".push(",this.vexpr(n),");"):(k("$ret = Sk.misceval.iterFor(Sk.abstr.iter(",this.vexpr(n.value),"), function(e) { ",c,".push(e); });"),this._checkSuspension());return c}return"["+a.map(n=>this.vexpr(n)).join(",")+"]"};b.prototype.cunpackkwstoarray=function(a,c){var m="undefined";if(a&&0<a.length){let n=!1;m=[];for(let d of a){if(n&&!Sk.__future__.python3)throw new SyntaxError("Advanced unpacking of function arguments is not supported in Python 2");
d.arg?(m.push("'"+d.arg.v+"'"),m.push(this.vexpr(d.value))):n=!0}m="["+m.join(",")+"]";if(n){m=this._gr("keywordArgs",m);for(let d of a)d.arg||(k("$ret = Sk.abstr.mappingUnpackIntoKeywordArray(",m,",",this.vexpr(d.value),",",c,");"),this._checkSuspension())}}return m};b.prototype.ctuplelistorset=function(a,c,m){var n;Sk.asserts.assert("tuple"===m||"list"===m||"set"===m);var d=!1;for(n=0;n<a.elts.length;n++)if(a.elts[n].constructor===Sk.astnodes.Starred){d=!0;var l=n;break}if(a.ctx===Sk.astnodes.Store){if(d){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("assignment unpacking with stars is not supported in Python 2",
this.filename,a.lineno);for(n=l+1;n<a.elts.length;n++)if(a.elts[n].constructor===Sk.astnodes.Starred)throw new Sk.builtin.SyntaxError("multiple starred expressions in assignment",this.filename,a.lineno);}m=d?l:a.elts.length;k("$ret = Sk.abstr.sequenceUnpack("+c+","+m+","+(d?a.elts.length-1:m)+", "+d+");");this._checkSuspension();c=this._gr("items","$ret");for(n=0;n<a.elts.length;++n)n===l?this.vexpr(a.elts[n].value,c+"["+n+"]"):this.vexpr(a.elts[n],c+"["+n+"]")}else if(a.ctx===Sk.astnodes.Load||"set"===
m){if(d){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("List packing with stars is not supported in Python 2");return this._gr("load"+m,"new Sk.builtins['",m,"'](",this.cunpackstarstoarray(a.elts),")")}if("tuple"===m){d=!0;c=[];for(n=0;n<a.elts.length;++n)l=this.vexpr(a.elts[n]),d&&-1==l.indexOf("$const")&&(d=!1),c.push(l);if(d)return this.makeConstant("new Sk.builtin.tuple(["+c+"])");for(n=0;n<c.length;++n)c[n]=this._gr("elem",c[n]);return this._gr("load"+m,"new Sk.builtins['",m,"']([",
c,"])")}c=[];for(n=0;n<a.elts.length;++n)c.push(this._gr("elem",this.vexpr(a.elts[n])));return this._gr("load"+m,"new Sk.builtins['",m,"']([",c,"])")}};b.prototype.csubdict=function(a,c,m){const n=[];for(;c<m;c++)n.push(this.vexpr(a.keys[c])),n.push(this.vexpr(a.values[c]));return this._gr("loaddict","new Sk.builtins['dict']([",n,"])")};b.prototype.cdict=function(a){let c=0;var m;const n=a.values?a.values.length:0;let d=0,l;for(let r=0;r<n;r++)(m=null===a.keys[r])?(d&&(m=this.csubdict(a,r-d,r),c?
k(l,".dict$merge(",m,");"):(l=m,c=1),d=0),0===c&&(l=this._gr("loaddict","new Sk.builtins.dict([])"),c=1),m=this.vexpr(a.values[r]),k("$ret = ",l,".dict$merge(",m,");"),this._checkSuspension(a)):d++;d&&(m=this.csubdict(a,n-d,n),c?k(l,".dict$merge(",m,");"):(l=m,c=1));0===c&&(l=this._gr("loaddict","new Sk.builtins.dict([])"));return l};b.prototype.clistcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.ListComp);var c=this._gr("_compr","new Sk.builtins['list']([])");return this.ccompgen("list",
c,a.generators,0,a.elt,null,a)};b.prototype.cdictcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.DictComp);var c=this._gr("_dcompr","new Sk.builtins.dict([])");return this.ccompgen("dict",c,a.generators,0,a.value,a.key,a)};b.prototype.csetcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.SetComp);var c=this._gr("_setcompr","new Sk.builtins.set([])");return this.ccompgen("set",c,a.generators,0,a.elt,null,a)};b.prototype.ccompgen=function(a,c,m,n,d,l,r){var v=this.newBlock(a+" comp start"),
q=this.newBlock(a+" comp skip"),t=this.newBlock(a+" comp anchor"),w=m[n],C=this.vexpr(w.iter);C=this._gr("iter","Sk.abstr.iter(",C,")");var D;this._jump(v);this.setBlock(v);k("$ret = Sk.abstr.iternext(",C,", true);");this._checkSuspension(r);C=this._gr("next","$ret");this._jumpundef(C,t);this.vexpr(w.target,C);var L=w.ifs?w.ifs.length:0;for(D=0;D<L;++D)C=this.vexpr(w.ifs[D]),this._jumpfalse(C,v);++n<m.length&&this.ccompgen(a,c,m,n,d,l,r);n>=m.length&&(m=this.vexpr(d),"dict"===a?(a=this.vexpr(l),k(c,
".mp$ass_subscript(",a,",",m,");")):"list"===a?k(c,".v.push(",m,");"):"set"===a&&k(c,".v.mp$ass_subscript(",m,", true);"),this._jump(q),this.setBlock(q));this._jump(v);this.setBlock(t);return c};b.prototype.cyield=function(a){if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'yield' outside function",this.filename,a.lineno);var c="Sk.builtin.none.none$";a.value&&(c=this.vexpr(a.value));a=this.newBlock("after yield");k("return [/*resume*/",a,",/*ret*/",c,"];");
this.setBlock(a);return"$gen.gi$sentvalue"};b.prototype.cyieldfrom=function(a){if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'yield' outside function",this.filename,a.lineno);var c=this.vexpr(a.value);c=this._gr("iter","Sk.abstr.iter(",c,")");k("$gen."+c+"=",c,";");var m=this.newBlock("after iter"),n=this.newBlock("after yield from");this._jump(m);this.setBlock(m);var d=this.gensym("retval");k(c,"=$gen.",c,";");k("var ",d,";");k("if ($gen.gi$sentvalue === Sk.builtin.none.none$ || "+
c+".constructor === Sk.builtin.generator) {");k("$ret=",c,".tp$iternext(true, $gen.gi$sentvalue);");k("} else {");var l=this.makeConstant("new Sk.builtin.str('send');");k("$ret=Sk.misceval.tryCatch(");k("function(){");k("return Sk.misceval.callsimOrSuspendArray(Sk.abstr.gattr(",c,",",l,"), [$gen.gi$sentvalue]);},");k("function (e) { ");k("if (e instanceof Sk.builtin.StopIteration) { ");k(c,".gi$ret = e.$value;");k("return undefined;");k("} else { throw e; }");k("}");k(");");k("}");this._checkSuspension(a);
k(d,"=$ret;");k("if(",d,"===undefined) {");k("$gen.gi$sentvalue=$gen."+c+".gi$ret;");k("$blk=",n,";continue;");k("}");k("return [/*resume*/",m,",/*ret*/",d,"];");this.setBlock(n);return"$gen.gi$sentvalue"};b.prototype.ccompare=function(a){var c;Sk.asserts.assert(a.ops.length===a.comparators.length);var m=this.vexpr(a.left);var n=a.ops.length;var d=this.newBlock("done");var l=this._gr("compareres","null");for(c=0;c<n;++c){var r=this.vexpr(a.comparators[c]);const v=a.ops[c];v===Sk.astnodes.Is?k("$ret = ",
m,"===",r,";"):v===Sk.astnodes.IsNot?k("$ret = ",m,"!==",r,";"):(k("$ret = Sk.misceval.richCompareBool(",m,",",r,",'",v.prototype._astname,"', true);"),this._checkSuspension(a));k(l,"=Sk.builtin.bool($ret);");this._jumpfalse("$ret",d);m=r}this._jump(d);this.setBlock(d);return l};b.prototype.ccall=function(a){var c=this.vexpr(a.func);let m=this.cunpackstarstoarray(a.args,!Sk.__future__.python3);var n=this.cunpackkwstoarray(a.keywords,c);if(a.keywords&&0<a.keywords.length){let d=!1;n=[];for(let l of a.keywords){if(d&&
!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("Advanced unpacking of function arguments is not supported in Python 2");l.arg?(n.push("'"+l.arg.v+"'"),n.push(this.vexpr(l.value))):d=!0}n="["+n.join(",")+"]";if(d){n=this._gr("keywordArgs",n);for(let l of a.keywords)l.arg||(k("$ret = Sk.abstr.mappingUnpackIntoKeywordArray(",n,",",this.vexpr(l.value),",",c,");"),this._checkSuspension())}}Sk.__future__.super_args&&a.func.id&&"super"===a.func.id.v&&"[]"===m&&(this.u.tempsToSave.push("$sup"),k('if (typeof $sup === "undefined") { throw new Sk.builtin.RuntimeError("super(): no arguments") };'),
m="[$gbl.__class__,$sup]");k("$ret = (",c,".tp$call)?",c,".tp$call(",m,",",n,") : Sk.misceval.applyOrSuspend(",c,",undefined,undefined,",n,",",m,");");this._checkSuspension(a);return this._gr("call","$ret")};b.prototype.cslice=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.Slice);if(Sk.__future__.python3){var c=a.lower?this.vexpr(a.lower):"Sk.builtin.none.none$";var m=a.upper?this.vexpr(a.upper):"Sk.builtin.none.none$"}else c=a.lower?this.vexpr(a.lower):a.step?"Sk.builtin.none.none$":"new Sk.builtin.int_(0)",
m=a.upper?this.vexpr(a.upper):a.step?"Sk.builtin.none.none$":"new Sk.builtin.int_(2147483647)";a=a.step?this.vexpr(a.step):"Sk.builtin.none.none$";return this._gr("slice","new Sk.builtins['slice'](",c,",",m,",",a,")")};b.prototype.eslice=function(a){var c;Sk.asserts.assert(a instanceof Array);var m=[];for(c=0;c<a.length;c++)m.push(this.vslicesub(a[c]));return this._gr("extslice","new Sk.builtins['tuple']([",m,"])")};b.prototype.vslicesub=function(a){switch(a.constructor){case Sk.astnodes.Index:var c=
this.vexpr(a.value);break;case Sk.astnodes.Slice:c=this.cslice(a);break;case Sk.astnodes.Ellipsis:Sk.asserts.fail("todo compile.js Ellipsis;");break;case Sk.astnodes.ExtSlice:c=this.eslice(a.dims);break;default:Sk.asserts.fail("invalid subscript kind")}return c};b.prototype.vslice=function(a,c,m,n){a=this.vslicesub(a);return this.chandlesubscr(c,m,a,n)};b.prototype.chandlesubscr=function(a,c,m,n){if(a===Sk.astnodes.Load||a===Sk.astnodes.AugLoad)return k("$ret = Sk.abstr.objectGetItem(",c,",",m,", true);"),
this._checkSuspension(),this._gr("lsubscr","$ret");a===Sk.astnodes.Store||a===Sk.astnodes.AugStore?(k("$ret = Sk.abstr.objectSetItem(",c,",",m,",",n,", true);"),this._checkSuspension()):a===Sk.astnodes.Del?k("Sk.abstr.objectDelItem(",c,",",m,");"):Sk.asserts.fail("handlesubscr fail")};b.prototype.cboolop=function(a){var c,m;Sk.asserts.assert(a instanceof Sk.astnodes.BoolOp);var n=a.op===Sk.astnodes.And?this._jumpfalse:this._jumptrue;var d=this.newBlock("end of boolop");var l=a.values;var r=l.length;
for(c=0;c<r;++c)a=this.vexpr(l[c]),0===c&&(m=this._gr("boolopsucc",a)),k(m,"=",a,";"),n.call(this,a,d);this._jump(d);this.setBlock(d);return m};b.prototype.cjoinedstr=function(a){let c;Sk.asserts.assert(a instanceof Sk.astnodes.JoinedStr);for(let m of a.values)a=this.vexpr(m),c?k(c,"=",c,".sq$concat(",a,");"):c=this._gr("joinedstr",a);c||(c="Sk.builtin.str.$emptystr");return c};b.prototype.cformattedvalue=function(a){let c=this.vexpr(a.value);switch(a.conversion){case "s":c=this._gr("value","new Sk.builtin.str(",
c,")");break;case "a":c=this._gr("value","Sk.builtin.ascii(",c,")");break;case "r":c=this._gr("value","Sk.builtin.repr(",c,")")}a=a.format_spec?this.vexpr(a.format_spec):"Sk.builtin.str.$emptystr";return this._gr("formatted","Sk.abstr.objectFormat("+c+","+a+")")};b.prototype.vexpr=function(a,c,m,n){var d;a.lineno>this.u.lineno&&(this.u.lineno=a.lineno,this.u.linenoSet=!1);switch(a.constructor){case Sk.astnodes.BoolOp:return this.cboolop(a);case Sk.astnodes.BinOp:return this._gr("binop","Sk.abstr.numberBinOp(",
this.vexpr(a.left),",",this.vexpr(a.right),",'",a.op.prototype._astname,"')");case Sk.astnodes.UnaryOp:return this._gr("unaryop","Sk.abstr.numberUnaryOp(",this.vexpr(a.operand),",'",a.op.prototype._astname,"')");case Sk.astnodes.Lambda:return this.clambda(a);case Sk.astnodes.IfExp:return this.cifexp(a);case Sk.astnodes.Dict:return this.cdict(a);case Sk.astnodes.ListComp:return this.clistcomp(a);case Sk.astnodes.DictComp:return this.cdictcomp(a);case Sk.astnodes.SetComp:return this.csetcomp(a);case Sk.astnodes.GeneratorExp:return this.cgenexp(a);
case Sk.astnodes.Yield:return this.cyield(a);case Sk.astnodes.YieldFrom:return this.cyieldfrom(a);case Sk.astnodes.Compare:return this.ccompare(a);case Sk.astnodes.Call:return c=this.ccall(a),this.annotateSource(a),c;case Sk.astnodes.Num:if("number"===typeof a.n)return a.n;if(a.n instanceof Sk.builtin.lng)return this.makeConstant("new Sk.builtin.lng('"+a.n.v.toString()+"')");if(a.n instanceof Sk.builtin.int_)return"number"===typeof a.n.v?this.makeConstant("new Sk.builtin.int_("+a.n.v+")"):this.makeConstant("new Sk.builtin.int_('"+
a.n.v.toString()+"')");if(a.n instanceof Sk.builtin.float_)return a=0===a.n.v&&-Infinity===1/a.n.v?"-0":a.n.v,this.makeConstant("new Sk.builtin.float_("+a+")");if(a.n instanceof Sk.builtin.complex)return this.makeConstant("new Sk.builtin.complex("+(0===a.n.real&&-Infinity===1/a.n.real?"-0":a.n.real)+", "+(0===a.n.imag&&-Infinity===1/a.n.imag?"-0":a.n.imag)+")");Sk.asserts.fail("unhandled Num type");case Sk.astnodes.Bytes:if(Sk.__future__.python3){c=[];a=a.s.$jsstr();for(m=0;m<a.length;m++)c.push(a.charCodeAt(m));
return this.makeConstant("new Sk.builtin.bytes([",c.join(", "),"])")}case Sk.astnodes.Str:c=this.makeConstant;a=a.s.$jsstr();m='"';for(d=0;d<a.length;d++)n=a.charCodeAt(d),m=10==n?m+"\\n":92==n?m+"\\\\":34==n||32>n||127<=n&&256>n?m+("\\x"+("0"+n.toString(16)).substr(-2)):256<=n?m+("\\u"+("000"+n.toString(16)).substr(-4)):m+a.charAt(d);a=m+'"';return c.call(this,"new Sk.builtin.str(",a,")");case Sk.astnodes.Attribute:a.ctx!==Sk.astnodes.AugLoad&&a.ctx!==Sk.astnodes.AugStore&&(d=this.vexpr(a.value));
n=a.attr.$r().v;n=n.substring(1,n.length-1);n=g(this.u.private_,new Sk.builtin.str(n)).v;n=this.makeConstant("new Sk.builtin.str('"+n+"')");switch(a.ctx){case Sk.astnodes.AugLoad:return k("$ret = ",m,".tp$getattr(",n,", true);"),this._checkSuspension(a),k("\nif ($ret === undefined) {"),k("\nthrow new Sk.builtin.AttributeError(",m,'.sk$attrError() + " has no attribute \'" + ',n,'.$jsstr() + "\'");'),k("\n};"),this._gr("lattr","$ret");case Sk.astnodes.Load:return k("$ret = ",d,".tp$getattr(",n,", true);"),
this._checkSuspension(a),k("\nif ($ret === undefined) {"),k("\nthrow new Sk.builtin.AttributeError(",d,'.sk$attrError() + " has no attribute \'" + ',n,'.$jsstr() + "\'");'),k("\n};"),this._gr("lattr","$ret");case Sk.astnodes.AugStore:k("$ret = undefined;");k("if(",c,"!==undefined){");k("$ret = ",m,".tp$setattr(",n,",",c,", true);");k("}");this._checkSuspension(a);break;case Sk.astnodes.Store:k("$ret = ",d,".tp$setattr(",n,",",c,", true);");this._checkSuspension(a);break;case Sk.astnodes.Del:k("$ret = ",
d,".tp$setattr(",n,", undefined, true);");this._checkSuspension(a);break;default:Sk.asserts.fail("invalid attribute expression")}break;case Sk.astnodes.Subscript:switch(a.ctx){case Sk.astnodes.AugLoad:return k("$ret = Sk.abstr.objectGetItem(",m,",",n,", true);"),this._checkSuspension(a),this._gr("gitem","$ret");case Sk.astnodes.Load:case Sk.astnodes.Store:case Sk.astnodes.Del:return this.vslice(a.slice,a.ctx,this.vexpr(a.value),c);case Sk.astnodes.AugStore:k("$ret=undefined;");k("if(",c,"!==undefined){");
k("$ret=Sk.abstr.objectSetItem(",m,",",n,",",c,", true)");k("}");this._checkSuspension(a);break;default:Sk.asserts.fail("invalid subscript expression")}break;case Sk.astnodes.Name:return this.nameop(a.id,a.ctx,c);case Sk.astnodes.NameConstant:if(a.ctx===Sk.astnodes.Store||a.ctx===Sk.astnodes.AugStore||a.ctx===Sk.astnodes.Del)throw new Sk.builtin.SyntaxError("can not assign to a constant name");switch(a.value){case Sk.builtin.none.none$:return"Sk.builtin.none.none$";case Sk.builtin.bool.true$:return"Sk.builtin.bool.true$";
case Sk.builtin.bool.false$:return"Sk.builtin.bool.false$";default:Sk.asserts.fail("invalid named constant")}break;case Sk.astnodes.List:return this.ctuplelistorset(a,c,"list");case Sk.astnodes.Tuple:return this.ctuplelistorset(a,c,"tuple");case Sk.astnodes.Set:return this.ctuplelistorset(a,c,"set");case Sk.astnodes.Starred:switch(a.ctx){case Sk.astnodes.Store:throw new Sk.builtin.SyntaxError("starred assignment target must be in a list or tuple",this.filename,a.lineno);default:throw new Sk.builtin.SyntaxError("can't use starred expression here",
this.filename,a.lineno);}case Sk.astnodes.JoinedStr:return this.cjoinedstr(a);case Sk.astnodes.FormattedValue:return this.cformattedvalue(a);case Sk.astnodes.Ellipsis:return this.makeConstant("Sk.builtin.Ellipsis");default:Sk.asserts.fail("unhandled case "+a.constructor.name+" vexpr")}};b.prototype.vseqexpr=function(a,c){var m;Sk.asserts.assert(void 0===c||a.length===c.length);var n=[];for(m=0;m<a.length;++m)n.push(this.vexpr(a[m],void 0===c?void 0:c[m]));return n};b.prototype.cannassign=function(a){var c=
a.target;let m=a.value;m&&(m=this.vexpr(a.value),this.vexpr(c,m));switch(c.constructor){case Sk.astnodes.Name:!a.simple||this.u.ste.blockType!==Sk.SYMTAB_CONSTS.ClassBlock&&this.u.ste.blockType!=Sk.SYMTAB_CONSTS.ModuleBlock||(this.u.hasAnnotations=!0,a=this.vexpr(a.annotation),c=e(g(this.u.private_,c.id).v),c=this.makeConstant("new Sk.builtin.str('"+c+"')"),this.chandlesubscr(Sk.astnodes.Store,"$loc.__annotations__",c,a))}};b.prototype.caugassign=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.AugAssign);
var c=a.target;switch(c.constructor){case Sk.astnodes.Attribute:var m=this.vexpr(c.value);c=new Sk.astnodes.Attribute(c.value,c.attr,Sk.astnodes.AugLoad,c.lineno,c.col_offset);var n=this.vexpr(c,void 0,m);var d=this.vexpr(a.value);a=this._gr("inplbinopattr","Sk.abstr.numberInplaceBinOp(",n,",",d,",'",a.op.prototype._astname,"')");c.ctx=Sk.astnodes.AugStore;return this.vexpr(c,a,m);case Sk.astnodes.Subscript:m=this.vexpr(c.value);var l=this.vslicesub(c.slice);c=new Sk.astnodes.Subscript(c.value,l,
Sk.astnodes.AugLoad,c.lineno,c.col_offset);n=this.vexpr(c,void 0,m,l);d=this.vexpr(a.value);a=this._gr("inplbinopsubscr","Sk.abstr.numberInplaceBinOp(",n,",",d,",'",a.op.prototype._astname,"')");c.ctx=Sk.astnodes.AugStore;return this.vexpr(c,a,m,l);case Sk.astnodes.Name:return m=this.nameop(c.id,Sk.astnodes.Load),d=this.vexpr(a.value),a=this._gr("inplbinop","Sk.abstr.numberInplaceBinOp(",m,",",d,",'",a.op.prototype._astname,"')"),this.nameop(c.id,Sk.astnodes.Store,a);default:Sk.asserts.fail("unhandled case in augassign")}};
b.prototype.exprConstant=function(a){switch(a.constructor){case Sk.astnodes.Num:return Sk.misceval.isTrue(a.n)?1:0;case Sk.astnodes.Str:return Sk.misceval.isTrue(a.s)?1:0;default:return-1}};b.prototype.newBlock=function(a){var c=this.u.blocknum++;this.u.blocks[c]=[];this.u.blocks[c]._name=a||"<unnamed>";this.u.blocks[c]._next=null;return c};b.prototype.setBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.curblock=a};b.prototype.pushBreakBlock=function(a){Sk.asserts.assert(0<=a&&
a<this.u.blocknum);this.u.breakBlocks.push(a)};b.prototype.popBreakBlock=function(){this.u.breakBlocks.pop()};b.prototype.pushContinueBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.continueBlocks.push(a)};b.prototype.popContinueBlock=function(){this.u.continueBlocks.pop()};b.prototype.pushExceptBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.exceptBlocks.push(a)};b.prototype.popExceptBlock=function(){this.u.exceptBlocks.pop()};b.prototype.pushFinallyBlock=
function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);Sk.asserts.assert(this.u.breakBlocks.length===this.u.continueBlocks.length);this.u.finallyBlocks.push({blk:a,breakDepth:this.u.breakBlocks.length})};b.prototype.popFinallyBlock=function(){this.u.finallyBlocks.pop()};b.prototype.peekFinallyBlock=function(){return 0<this.u.finallyBlocks.length?this.u.finallyBlocks[this.u.finallyBlocks.length-1]:void 0};b.prototype.setupExcept=function(a){k("$exc.push(",a,");")};b.prototype.endExcept=function(){k("$exc.pop();")};
b.prototype.outputLocals=function(a){var c,m={};for(c=0;a.argnames&&c<a.argnames.length;++c)m[a.argnames[c]]=!0;a.localnames.sort();var n=[];for(c=0;c<a.localnames.length;++c){var d=a.localnames[c];void 0===m[d]&&(n.push(d),m[d]=!0)}return 0<n.length?"var "+n.join(",")+"; /* locals */":""};b.prototype.outputSuspensionHelpers=function(a){var c,m=[],n=a.localnames.concat(a.tempsToSave),d={},l=a.ste.blockType===Sk.SYMTAB_CONSTS.FunctionBlock&&a.ste.childHasFree,r=(0<n.length?"var "+n.join(",")+";":"")+
"var $wakeFromSuspension = function() {var susp = "+a.scopename+".$wakingSuspension; "+a.scopename+".$wakingSuspension = undefined;$blk=susp.$blk; $loc=susp.$loc; $gbl=susp.$gbl; $exc=susp.$exc; $err=susp.$err; $postfinally=susp.$postfinally;$currLineNo=susp.$lineno; $currColNo=susp.$colno; Sk.lastYield=Date.now();"+(l?"$cell=susp.$cell;":"");for(c=0;c<n.length;c++){var v=n[c];void 0===d[v]&&(r+=v+"=susp.$tmps."+v+";",d[v]=!0)}r+="try { $ret=susp.child.resume(); } catch(err) { if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+
this.filename+"'}); if($exc.length>0) { $err=err; $blk=$exc.pop(); } else { throw err; } }};";r+="var $saveSuspension = function($child, $filename, $lineno, $colno) {var susp = new Sk.misceval.Suspension(); susp.child=$child;susp.resume=function(){"+a.scopename+".$wakingSuspension=susp; return "+a.scopename+"("+(a.ste.generator?"$gen":"")+"); };susp.data=susp.child.data;susp.$blk=$blk;susp.$loc=$loc;susp.$gbl=$gbl;susp.$exc=$exc;susp.$err=$err;susp.$postfinally=$postfinally;susp.$filename=$filename;susp.$lineno=$lineno;susp.$colno=$colno;susp.optional=susp.child.optional;"+
(l?"susp.$cell=$cell;":"");d={};for(c=0;c<n.length;c++)v=n[c],void 0===d[v]&&(m.push('"'+v+'":'+v),d[v]=!0);return r+="susp.$tmps={"+m.join(",")+"};return susp;};"};b.prototype.outputAllUnits=function(){var a,c,m="";for(c=0;c<this.allUnits.length;++c){var n=this.allUnits[c];m+=n.prefixCode;m+=this.outputLocals(n);n.doesSuspend&&(m+=this.outputSuspensionHelpers(n));m+=n.varDeclsCode;m+=n.switchCode;var d=n.blocks;var l=Object.create(null);for(a=0;a<d.length;++a){var r=a;if(!(r in l))for(;;)if(l[r]=
!0,m+="case "+r+": /* --- "+d[r]._name+" --- */",m+=d[r].join(""),null!==d[r]._next)if(d[r]._next in l){m+="/* jump */ continue;";break}else m+="/* allowing case fallthrough */",r=d[r]._next;else{m+="throw new Sk.builtin.SystemError('internal error: unterminated block');";break}}m+=n.suffixCode}return m};b.prototype.cif=function(a){var c;Sk.asserts.assert(a instanceof Sk.astnodes.If);var m=this.exprConstant(a.test);if(0===m)a.orelse&&0<a.orelse.length&&this.vseqstmt(a.orelse);else if(1===m)this.vseqstmt(a.body);
else{var n=this.newBlock("end of if");a.orelse&&0<a.orelse.length&&(c=this.newBlock("next branch of if"));m=this.vexpr(a.test);a.orelse&&0<a.orelse.length?(this._jumpfalse(m,c),this.vseqstmt(a.body),this._jump(n),this.setBlock(c),this.vseqstmt(a.orelse)):(this._jumpfalse(m,n),this.vseqstmt(a.body));this._jump(n);this.setBlock(n)}};b.prototype.cwhile=function(a){if(0===this.exprConstant(a.test))a.orelse&&this.vseqstmt(a.orelse);else{var c=this.newBlock("while test");this._jump(c);this.setBlock(c);
var m=this.newBlock("after while");var n=0<a.orelse.length?this.newBlock("while orelse"):null;var d=this.newBlock("while body");this.annotateSource(a);this._jumpfalse(this.vexpr(a.test),n?n:m);this._jump(d);this.pushBreakBlock(m);this.pushContinueBlock(c);this.setBlock(d);(Sk.debugging||Sk.killableWhile)&&this.u.canSuspend&&(d=this.newBlock("debug breakpoint for line "+a.lineno),k("if (Sk.breakpoints('"+this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.delay'}, resume: function() {}}, '"+
this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+d+";","$susp.optional = true;","return $susp;","}"),this._jump(d),this.setBlock(d),this.u.doesSuspend=!0);this.vseqstmt(a.body);this._jump(c);this.popContinueBlock();this.popBreakBlock();0<a.orelse.length&&(this.setBlock(n),this.vseqstmt(a.orelse),this._jump(m));this.setBlock(m)}};b.prototype.cfor=function(a){var c=this.newBlock("for start"),m=this.newBlock("for cleanup"),n=this.newBlock("for end");this.pushBreakBlock(n);this.pushContinueBlock(c);
var d=this.vexpr(a.iter);if(this.u.ste.generator){var l="$loc."+this.gensym("iter");k(l,"=Sk.abstr.iter(",d,");")}else l=this._gr("iter","Sk.abstr.iter(",d,")"),this.u.tempsToSave.push(l);this._jump(c);this.setBlock(c);k("$ret = Sk.abstr.iternext(",l,this.u.canSuspend?", true":", false",");");this._checkSuspension(a);l=this._gr("next","$ret");this._jumpundef(l,m);this.vexpr(a.target,l);(Sk.debugging||Sk.killableFor)&&this.u.canSuspend&&(l=this.newBlock("debug breakpoint for line "+a.lineno),k("if (Sk.breakpoints('"+
this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.delay'}, resume: function() {}}, '"+this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+l+";","$susp.optional = true;","return $susp;","}"),this._jump(l),this.setBlock(l),this.u.doesSuspend=!0);this.vseqstmt(a.body);this._jump(c);this.setBlock(m);this.popContinueBlock();this.popBreakBlock();this.vseqstmt(a.orelse);this._jump(n);this.setBlock(n)};b.prototype.craise=function(a){if(a.exc){var c=
this._gr("exc",this.vexpr(a.exc)),m=this.newBlock("exception now instantiated"),n=this._gr("isclass",c+".prototype instanceof Sk.builtin.BaseException");this._jumpfalse(n,m);a.inst?(n=this._gr("inst",this.vexpr(a.inst)),k("if(!(",n," instanceof Sk.builtin.tuple)) {",n,"= new Sk.builtin.tuple([",n,"]);","}"),k("$ret = Sk.misceval.callsimOrSuspendArray(",c,",",n,".v);")):k("$ret = Sk.misceval.callsimOrSuspend(",c,");");this._checkSuspension(a);k(c,"=$ret;");this._jump(m);this.setBlock(m);k("if (",c,
" instanceof Sk.builtin.BaseException) {throw ",c,";} else {throw new Sk.builtin.TypeError('exceptions must derive from BaseException');};")}else k("throw $err;")};b.prototype.outputFinallyCascade=function(a){if(0==this.u.finallyBlocks.length)k("if($postfinally!==undefined) { if ($postfinally.returning) { return $postfinally.returning; } else { $blk=$postfinally.gotoBlock; $postfinally=undefined; continue; } }");else{var c=this.peekFinallyBlock();k("if($postfinally!==undefined) {","if ($postfinally.returning",
c.breakDepth==a.breakDepth?"|| $postfinally.isBreak":"",") {","$blk=",c.blk,";continue;","} else {","$blk=$postfinally.gotoBlock;$postfinally=undefined;continue;","}","}")}};b.prototype.ctry=function(a){var c,m=a.handlers.length;if(a.finalbody){var n=this.newBlock("finalbody");var d=this.newBlock("finalexh");var l=this._gr("finally_reraise","undefined");this.u.tempsToSave.push(l);this.pushFinallyBlock(n);var r=this.peekFinallyBlock();this.setupExcept(d)}var v=[];for(c=0;c<m;++c)v.push(this.newBlock("except_"+
c+"_"));var q=this.newBlock("unhandled");var t=this.newBlock("orelse");var w=this.newBlock("end");0!=v.length&&this.setupExcept(v[0]);this.vseqstmt(a.body);0!=v.length&&this.endExcept();this._jump(t);for(c=0;c<m;++c){this.setBlock(v[c]);var C=a.handlers[c];if(!C.type&&c<m-1)throw new Sk.builtin.SyntaxError("default 'except:' must be last",this.filename,C.lineno);if(C.type){var D=this.vexpr(C.type);var L=c==m-1?q:v[c+1];D=this._gr("instance","Sk.misceval.isTrue(Sk.builtin.isinstance($err, ",D,"))");
this._jumpfalse(D,L)}C.name&&this.vexpr(C.name,"$err");this.vseqstmt(C.body);this._jump(w)}this.setBlock(q);k("throw $err;");this.setBlock(t);this.vseqstmt(a.orelse);this._jump(w);this.setBlock(w);a.finalbody&&(this.endExcept(),this._jump(n),this.setBlock(d),k(l,"=$err;"),this._jump(n),this.setBlock(n),this.popFinallyBlock(),this.vseqstmt(a.finalbody),k("if(",l,"!==undefined) { throw ",l,";}"),this.outputFinallyCascade(r))};b.prototype.cwith=function(a,c){var m=this.newBlock("withexh"),n=this.newBlock("withtidyup"),
d=this.newBlock("withcarryon");var l=this._gr("mgr",this.vexpr(a.items[c].context_expr));k("$ret = Sk.abstr.lookupSpecial(",l,",Sk.builtin.str.$exit);");this._checkSuspension(a);var r=this._gr("exit","$ret");this.u.tempsToSave.push(r);k("$ret = Sk.abstr.lookupSpecial(",l,",Sk.builtin.str.$enter);");this._checkSuspension(a);k("$ret = Sk.misceval.callsimOrSuspendArray($ret);");this._checkSuspension(a);l=this._gr("value","$ret");this.pushFinallyBlock(n);var v=this.u.finallyBlocks[this.u.finallyBlocks.length-
1];this.setupExcept(m);a.items[c].optional_vars&&this.nameop(a.items[c].optional_vars.id,Sk.astnodes.Store,l);c+1<a.items.length?this.cwith(a,c+1):this.vseqstmt(a.body);this.endExcept();this._jump(n);this.setBlock(m);k("$ret = Sk.misceval.applyOrSuspend(",r,",undefined,Sk.builtin.getExcInfo($err),undefined,[]);");this._checkSuspension(a);this._jumptrue("$ret",d);k("throw $err;");this.setBlock(n);this.popFinallyBlock();k("$ret = Sk.misceval.callsimOrSuspendArray(",r,",[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.none.none$]);");
this._checkSuspension(a);this.outputFinallyCascade(v);this._jump(d);this.setBlock(d)};b.prototype.cassert=function(a){var c=this.vexpr(a.test),m=this.newBlock("end");this._jumptrue(c,m);k("throw new Sk.builtin.AssertionError(",a.msg?this.vexpr(a.msg):"",");");this.setBlock(m)};b.prototype.cimportas=function(a,c,m){a=a.v;var n=a.indexOf("."),d=m;if(-1!==n)for(a=a.substr(n+1);-1!==n;)n=a.indexOf("."),m=-1!==n?a.substr(0,n):a,d=this._gr("lattr","Sk.abstr.gattr(",d,", new Sk.builtin.str('",m,"'))"),a=
a.substr(n+1);return this.nameop(c,Sk.astnodes.Store,d)};b.prototype.cimport=function(a){var c,m=a.names.length;for(c=0;c<m;++c){var n=a.names[c];k("$ret = Sk.builtin.__import__(",n.name.$r().v,",$gbl,$loc,[],",Sk.__future__.absolute_import?0:-1,");");this._checkSuspension(a);var d=this._gr("module","$ret");if(n.asname)this.cimportas(n.name,n.asname,d);else{var l=n.name;n=l.v.indexOf(".");-1!==n&&(l=new Sk.builtin.str(l.v.substr(0,n)));this.nameop(l,Sk.astnodes.Store,d)}}};b.prototype.cfromimport=
function(a){var c,m=a.names.length;var n=[];var d=a.level;0!=d||Sk.__future__.absolute_import||(d=-1);for(c=0;c<m;++c)n[c]="'"+a.names[c].name.v+"'";k("$ret = Sk.builtin.__import__(",a.module.$r().v,",$gbl,$loc,[",n,"],",d,");");this._checkSuspension(a);d=this._gr("module","$ret");for(c=0;c<m;++c){n=a.names[c];var l="'"+n.name.v+"'";if(0===c&&"*"===n.name.v){Sk.asserts.assert(1===m);k("Sk.importStar(",d,",$loc, $gbl);");break}var r=this._gr("item","Sk.abstr.gattr(",d,", new Sk.builtin.str(",l,"), undefined)");
l=n.name;n.asname&&(l=n.asname);this.nameop(l,Sk.astnodes.Store,r)}};b.prototype.buildcodeobj=function(a,c,m,n,d,l){var r=[],v,q=[],t=[],w=[],C=null,D=null;m&&(q=this.vseqexpr(m));n&&n.defaults&&(t=this.vseqexpr(n.defaults));m=this.cannotations(n,a.returns);n&&n.kw_defaults&&(w=n.kw_defaults.map(P=>P?this.vexpr(P):"undefined"));n&&n.vararg&&(C=n.vararg);n&&n.kwarg&&(D=n.kwarg);if(!Sk.__future__.python3&&n&&n.kwonlyargs&&0!=n.kwonlyargs.length)throw new Sk.builtin.SyntaxError("Keyword-only arguments are not supported in Python 2");
var L=this.enterScope(c,a,a.lineno,this.canSuspend);var N=this.u.ste.generator;var A=this.u.ste.hasFree;var H=this.u.ste.childHasFree;var x=this.newBlock("codeobj entry");this.u.prefixCode="var "+L+"=(function "+this.niceName(c.v)+"$(";var B=[];if(N){if(D)throw new Sk.builtin.SyntaxError(c.v+"(): keyword arguments in generators not supported",this.filename,a.lineno);if(C)throw new Sk.builtin.SyntaxError(c.v+"(): variable number of arguments in generators not supported",this.filename,a.lineno);B.push("$gen")}else{D&&
(B.push("$kwa"),this.u.tempsToSave.push("$kwa"));for(v=0;n&&v<n.args.length;++v)B.push(this.nameop(n.args[v].arg,Sk.astnodes.Param));for(v=0;n&&n.kwonlyargs&&v<n.kwonlyargs.length;++v)B.push(this.nameop(n.kwonlyargs[v].arg,Sk.astnodes.Param));C&&B.push(this.nameop(n.vararg.arg,Sk.astnodes.Param))}let F=!N;A&&(F||B.push("$free"),this.u.tempsToSave.push("$free"));this.u.prefixCode=F?this.u.prefixCode+"$posargs,$kwargs":this.u.prefixCode+B.join(",");this.u.prefixCode+="){";N&&(this.u.prefixCode+="\n// generator\n");
A&&(this.u.prefixCode+="\n// has free\n");H&&(this.u.prefixCode+="\n// has cell\n");F&&(this.u.prefixCode+="\n// fast call\n");var J="{}";N&&(x="$gen.gi$resumeat",J="$gen.gi$locals");v=",$cell={}";H&&N&&(v=",$cell=$gen.gi$cells");this.u.varDeclsCode+="var $blk="+x+",$exc=[],$loc="+J+v+",$gbl="+(F?"this && this.func_globals":"this")+(F&&A?",$free=this && this.func_closure":"")+",$err=undefined,$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";null!==Sk.execLimit&&(this.u.varDeclsCode+=
"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.varDeclsCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.varDeclsCode+="var $waking=false; if ("+L+".$wakingSuspension!==undefined) { $wakeFromSuspension(); $waking=true; } else {";if(F){this.u.varDeclsCode=D||C||n&&n.kwonlyargs&&0!==n.kwonlyargs.length?this.u.varDeclsCode+"\nvar $args = this.$resolveArgs($posargs,$kwargs)\n":this.u.varDeclsCode+
("var $args = ((!$kwargs || $kwargs.length===0) && $posargs.length==="+B.length+") ? $posargs : this.$resolveArgs($posargs,$kwargs)");v=D?1:0;for(x=0;x<B.length;x++)this.u.varDeclsCode+=","+(x===v?"$sup = ":"")+B[x]+"=$args["+x+"]";this.u.varDeclsCode+=";\n"}if(N&&0<t.length)for(x=n.args.length-t.length,v=0;v<t.length;++v)B=this.nameop(n.args[v+x].arg,Sk.astnodes.Param),this.u.varDeclsCode+="if("+B+"===undefined)"+B+"="+L+".$defaults["+v+"];";for(v=0;n&&v<n.args.length;++v)B=n.args[v].arg,this.isCell(B)&&
(B=e(g(this.u.private_,B).v),this.u.varDeclsCode+="$cell."+B+"="+B+";");for(v=0;n&&n.kwonlyargs&&v<n.kwonlyargs.length;++v)B=n.kwonlyargs[v].arg,this.isCell(B)&&(B=e(g(this.u.private_,B).v),this.u.varDeclsCode+="$cell."+B+"="+B+";");C&&this.isCell(C.arg)&&(v=e(g(this.u.private_,C.arg).v),this.u.varDeclsCode+="$cell."+v+"="+v+";");D&&(this.u.localnames.push(D.arg.v),this.u.varDeclsCode+=D.arg.v+"=new Sk.builtins['dict']($kwa);",this.isCell(D.arg)&&(v=e(g(this.u.private_,D.arg).v),this.u.varDeclsCode+=
"$cell."+v+"="+v+";"));this.u.varDeclsCode+="}";Sk.__future__.python3&&l&&(this.u.varDeclsCode+="$gbl.__class__=$gbl."+l.v+";");this.u.switchCode="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="} }catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});";
d.call(this,L);if(n){for(let P of n.args)r.push(P.arg.v);for(let P of n.kwonlyargs||[])r.push(P.arg.v);this.u.argnames=r}this.exitScope();0<t.length&&k(L,".$defaults=[",t.join(","),"];");n&&n.kwonlyargs&&0<n.kwonlyargs.length&&(k(L,".co_argcount=",n.args.length,";"),k(L,".co_kwonlyargcount=",n.kwonlyargs.length,";"),k(L,".$kwdefs=[",w.join(","),"];"));0<r.length?k(L,".co_varnames=['",r.join("','"),"'];"):k(L,".co_varnames=[];");k(L,".co_docstring=",this.cDocstringOfCode(a),";");D&&k(L,".co_kwargs=1;");
C&&k(L,".co_varargs=1;");N||k(L,".co_fastcall=1;");a="";A&&(a=",$cell",(d=this.u.ste.hasFree)&&(a+=",$free"));if(N)return n&&0<n.args.length?this._gr("gener","new Sk.builtins['function']((function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgsLen(\"",c.v,'",arguments.length,',n.args.length-t.length,",",n.args.length,");return new Sk.builtins['generator'](",L,",$gbl,$origargs",a,");}))"):this._gr("gener","new Sk.builtins['function']((function(){Sk.builtin.pyCheckArgsLen(\"",
c.v,"\",arguments.length,0,0);return new Sk.builtins['generator'](",L,",$gbl,[]",a,");}))");if(0<q.length){k("$ret = new Sk.builtins['function'](",L,",$gbl",a,");");for(let P of q.reverse())k("$ret = Sk.misceval.callsimOrSuspendArray(",P,",[$ret]);"),this._checkSuspension();c=this._gr("funcobj","$ret")}else c=this._gr("funcobj","new Sk.builtins['function'](",L,",$gbl",a,")");m&&k(c,".func_annotations=",m,";");return c};b.prototype.cargannotation=function(a,c,m){c&&(a=g(this.u.private_,a).v,m.push(`'${a}'`),
m.push(this.vexpr(c)))};b.prototype.cargannotations=function(a,c){if(a)for(let m=0;m<a.length;m++){const n=a[m];this.cargannotation(n.arg,n.annotation,c)}};const h=new Sk.builtin.str("return");b.prototype.cannotations=function(a,c){const m=[];a&&(this.cargannotations(a.posonlyargs,m),this.cargannotations(a.args,m),a.vararg&&a.vararg.annotation&&this.cargannotation(a.vararg.arg,a.vararg.annotation,m),this.cargannotations(a.kwonlyargs,m),a.kwarg&&a.kwarg.annotation&&this.cargannotation(a.kwarg.arg,
a.kwarg.annotation,m));c&&this.cargannotation(h,c,m);if(0!==m.length)return"["+m.join(",")+"]"};b.prototype.maybeCDocstringOfBody=function(a){if(0===a.length)return null;a=a[0];if(a.constructor!==Sk.astnodes.Expr)return null;a=a.value;return a.constructor!==Sk.astnodes.Str?null:this.vexpr(a)};b.prototype.cDocstringOfCode=function(a){switch(a.constructor){case Sk.astnodes.AsyncFunctionDef:case Sk.astnodes.FunctionDef:return this.maybeCDocstringOfBody(a.body)||"Sk.builtin.none.none$";case Sk.astnodes.Lambda:case Sk.astnodes.GeneratorExp:return"Sk.builtin.none.none$";
default:Sk.asserts.fail(`unexpected node kind ${a.constructor.name}`)}};b.prototype.cfunction=function(a,c){Sk.asserts.assert(a instanceof Sk.astnodes.FunctionDef);c=this.buildcodeobj(a,a.name,a.decorator_list,a.args,function(m){this.vseqstmt(a.body);k("return Sk.builtin.none.none$;")},c);this.nameop(a.name,Sk.astnodes.Store,c)};b.prototype.clambda=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.Lambda);return this.buildcodeobj(a,new Sk.builtin.str("<lambda>"),null,a.args,function(c){c=this.vexpr(a.body);
k("return ",c,";")})};b.prototype.cifexp=function(a){var c=this.newBlock("next of ifexp"),m=this.newBlock("end of ifexp"),n=this._gr("res","null"),d=this.vexpr(a.test);this._jumpfalse(d,c);k(n,"=",this.vexpr(a.body),";");this._jump(m);this.setBlock(c);k(n,"=",this.vexpr(a.orelse),";");this._jump(m);this.setBlock(m);return n};b.prototype.cgenexpgen=function(a,c,m){var n=this.newBlock("start for "+c),d=this.newBlock("skip for "+c);this.newBlock("if cleanup for "+c);var l=this.newBlock("end for "+c),
r=a[c];if(0===c)var v="$loc.$iter0";else{var q=this.vexpr(r.iter);v="$loc."+this.gensym("iter");k(v,"=","Sk.abstr.iter(",q,");")}this._jump(n);this.setBlock(n);this.annotateSource(m);k("$ret = Sk.abstr.iternext(",v,this.u.canSuspend?", true":", false",");");this._checkSuspension(m);q=this._gr("next","$ret");this._jumpundef(q,l);this.vexpr(r.target,q);var t=r.ifs?r.ifs.length:0;for(v=0;v<t;++v)this.annotateSource(r.ifs[v]),q=this.vexpr(r.ifs[v]),this._jumpfalse(q,n);++c<a.length&&this.cgenexpgen(a,
c,m);c>=a.length&&(this.annotateSource(m),a=this.vexpr(m),k("return [",d,"/*resume*/,",a,"/*ret*/];"),this.setBlock(d));this._jump(n);this.setBlock(l);1===c&&k("return Sk.builtin.none.none$;")};b.prototype.cgenexp=function(a){var c=this.buildcodeobj(a,new Sk.builtin.str("<genexpr>"),null,null,function(m){this.cgenexpgen(a.generators,0,a.elt)});c=this._gr("gener","Sk.misceval.callsimArray(",c,");");k(c,".gi$locals.$iter0=Sk.abstr.iter(",this.vexpr(a.generators[0].iter),");");return c};b.prototype.cclass=
function(a){Sk.asserts.assert(a instanceof Sk.astnodes.ClassDef);var c=this.vseqexpr(a.decorator_list);var m=this.vseqexpr(a.bases);let n=this.cunpackkwstoarray(a.keywords);var d=this.enterScope(a.name,a,a.lineno);var l=this.newBlock("class entry");this.u.prefixCode="var "+d+"=(function $"+a.name.v+"$class_outer($globals,$locals,$cell){var $gbl=$globals,$loc=$locals,$free=$globals;";this.u.switchCode+="(function $"+a.name.v+"$_closure($cell){";this.u.switchCode+="var $blk="+l+",$exc=[],$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";
null!==Sk.execLimit&&(this.u.switchCode+="if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.switchCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.switchCode+="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="}}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+
this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }}}";this.u.suffixCode+="}).call(null, $cell);});";this.u.private_=a.name;this.cbody(a.body,a.name);k("return;");this.exitScope();k("$ret = Sk.misceval.buildClass($gbl,",d,",",a.name.$r().v,",[",m,"], $cell, ",n,");");this._checkSuspension();for(let r of c.reverse())k("$ret = Sk.misceval.callsimOrSuspendArray(",r,", [$ret]);"),this._checkSuspension();this.nameop(a.name,Sk.astnodes.Store,"$ret")};b.prototype.ccontinue=
function(a){var c=this.peekFinallyBlock();if(0==this.u.continueBlocks.length)throw new Sk.builtin.SyntaxError("'continue' outside loop",this.filename,a.lineno);a=this.u.continueBlocks[this.u.continueBlocks.length-1];Sk.asserts.assert(this.u.breakBlocks.length===this.u.continueBlocks.length);c&&c.breakDepth==this.u.continueBlocks.length?k("$postfinally={isBreak:true,gotoBlock:",a,"};"):this._jump(a)};b.prototype.cbreak=function(a){var c=this.peekFinallyBlock();if(0===this.u.breakBlocks.length)throw new Sk.builtin.SyntaxError("'break' outside loop",
this.filename,a.lineno);a=this.u.breakBlocks[this.u.breakBlocks.length-1];c&&c.breakDepth==this.u.breakBlocks.length?k("$postfinally={isBreak:true,gotoBlock:",a,"};"):this._jump(a)};b.prototype.vstmt=function(a,c){this.u.lineno=a.lineno;this.u.linenoSet=!1;this.u.localtemps=[];if(Sk.debugging&&this.u.canSuspend){var m=this.newBlock("debug breakpoint for line "+a.lineno);k("if (Sk.breakpoints('"+this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.debug'}, resume: function() {}}, '"+
this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+m+";","$susp.optional = true;","return $susp;","}");this._jump(m);this.setBlock(m);this.u.doesSuspend=!0}this.annotateSource(a);switch(a.constructor){case Sk.astnodes.FunctionDef:this.cfunction(a,c);break;case Sk.astnodes.ClassDef:this.cclass(a);break;case Sk.astnodes.Return:if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'return' outside function",this.filename,a.lineno);m=a.value?this.vexpr(a.value):
"Sk.builtin.none.none$";0==this.u.finallyBlocks.length?k("return ",m,";"):(k("$postfinally={returning:",m,"};"),this._jump(this.peekFinallyBlock().blk));break;case Sk.astnodes.Delete:this.vseqexpr(a.targets);break;case Sk.astnodes.Assign:var n=a.targets.length;m=this.vexpr(a.value);for(c=0;c<n;++c)this.vexpr(a.targets[c],m);break;case Sk.astnodes.AnnAssign:return this.cannassign(a);case Sk.astnodes.AugAssign:return this.caugassign(a);case Sk.astnodes.Print:this.cprint(a);break;case Sk.astnodes.For:return this.cfor(a);
case Sk.astnodes.While:return this.cwhile(a);case Sk.astnodes.If:return this.cif(a);case Sk.astnodes.Raise:return this.craise(a);case Sk.astnodes.Try:return this.ctry(a);case Sk.astnodes.With:return this.cwith(a,0);case Sk.astnodes.Assert:return this.cassert(a);case Sk.astnodes.Import:return this.cimport(a);case Sk.astnodes.ImportFrom:return this.cfromimport(a);case Sk.astnodes.Global:break;case Sk.astnodes.Expr:this.vexpr(a.value);break;case Sk.astnodes.Pass:break;case Sk.astnodes.Break:this.cbreak(a);
break;case Sk.astnodes.Continue:this.ccontinue(a);break;case Sk.astnodes.Debugger:k("debugger;");break;default:Sk.asserts.fail("unhandled case in vstmt: "+JSON.stringify(a))}};b.prototype.vseqstmt=function(a){var c;for(c=0;c<a.length;++c)this.vstmt(a[c])};b.prototype.isCell=function(a){a=e(g(this.u.private_,a).v);return this.u.ste.getScope(a)===Sk.SYMTAB_CONSTS.CELL};b.prototype.nameop=function(a,c,m){if((c===Sk.astnodes.Store||c===Sk.astnodes.AugStore||c===Sk.astnodes.Del)&&"__debug__"===a.v)throw new Sk.builtin.SyntaxError("can not assign to __debug__",
this.filename,this.u.lineno);Sk.asserts.assert("None"!==a.v);if("NotImplemented"===a.v)return"Sk.builtin.NotImplemented.NotImplemented$";var n=g(this.u.private_,a).v;n=e(n);var d=3;var l=this.u.ste.getScope(n);var r=null;switch(l){case Sk.SYMTAB_CONSTS.FREE:r="$free";d=2;break;case Sk.SYMTAB_CONSTS.CELL:r="$cell";d=2;break;case Sk.SYMTAB_CONSTS.LOCAL:this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock||this.u.ste.generator||(d=0);break;case Sk.SYMTAB_CONSTS.GLOBAL_IMPLICIT:this.u.ste.blockType===
Sk.SYMTAB_CONSTS.FunctionBlock&&(d=1);break;case Sk.SYMTAB_CONSTS.GLOBAL_EXPLICIT:d=1}Sk.asserts.assert(l||"_"===a.v.charAt(1));a=n;this.u.ste.generator||this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock?n="$loc."+n:(0===d||3===d)&&this.u.localnames.push(n);switch(d){case 0:switch(c){case Sk.astnodes.Load:case Sk.astnodes.Param:return k("if (",n," === undefined) { throw new Sk.builtin.UnboundLocalError('local variable \\'",n,"\\' referenced before assignment'); }\n"),n;case Sk.astnodes.Store:k(n,
"=",m,";");break;case Sk.astnodes.Del:k("delete ",n,";");break;default:Sk.asserts.fail("unhandled")}break;case 3:switch(c){case Sk.astnodes.Load:return this._gr("loadname",n,"!==undefined?",n,":Sk.misceval.loadname('",a,"',$gbl);");case Sk.astnodes.Store:k(n,"=",m,";");break;case Sk.astnodes.Del:k("delete ",n,";");break;case Sk.astnodes.Param:return n;default:Sk.asserts.fail("unhandled")}break;case 1:switch(c){case Sk.astnodes.Load:return this._gr("loadgbl","Sk.misceval.loadname('",a,"',$gbl)");case Sk.astnodes.Store:k("$gbl.",
a,"=",m,";");break;case Sk.astnodes.Del:k("delete $gbl.",a);break;default:Sk.asserts.fail("unhandled case in name op_global")}break;case 2:switch(c){case Sk.astnodes.Load:return r+"."+a;case Sk.astnodes.Store:k(r,".",a,"=",m,";");break;case Sk.astnodes.Param:return a;default:Sk.asserts.fail("unhandled case in name op_deref")}break;default:Sk.asserts.fail("unhandled case")}};b.prototype.enterScope=function(a,c,m,n){var d=new f;d.ste=this.st.getStsForAst(c);d.name=a;d.firstlineno=m;d.canSuspend=n||
!1;this.u&&this.u.private_&&(d.private_=this.u.private_);this.stack.push(this.u);this.allUnits.push(d);a=this.gensym("scope");d.scopename=a;this.u=d;this.u.activateScope();this.nestlevel++;return a};b.prototype.exitScope=function(){var a=this.u;this.nestlevel--;(this.u=0<=this.stack.length-1?this.stack.pop():null)&&this.u.activateScope();if("<module>"!==a.name.v){var c=a.name.$r().v;c=c.substring(1,c.length-1);k(a.scopename,".co_name=new Sk.builtins['str']('",c,"');");this.stack.length&&"class"==
this.u.ste.blockType&&k(a.scopename,".co_qualname=new Sk.builtins['str']('"+this.u.name.v+"."+c+"');")}for(var m in a.consts)a.consts.hasOwnProperty(m)&&(a.suffixCode+=m+" = "+a.consts[m]+";")};b.prototype.cbody=function(a,c){var m=0;const n=this.maybeCDocstringOfBody(a);null!==n&&(k("$loc.__doc__ = ",n,";"),m=1);for(;m<a.length;++m)this.vstmt(a[m],c);this.u.hasAnnotations&&(this.u.varDeclsCode+="$loc.__annotations__ || ($loc.__annotations__ = new Sk.builtin.dict());")};b.prototype.cprint=function(a){var c;
Sk.asserts.assert(a instanceof Sk.astnodes.Print);a.dest&&this.vexpr(a.dest);var m=a.values.length;for(c=0;c<m;++c)k("$ret = Sk.misceval.print_(","new Sk.builtins['str'](",this.vexpr(a.values[c]),").v);"),this._checkSuspension(a);a.nl&&(k("$ret = Sk.misceval.print_(",'"\\n");'),this._checkSuspension(a))};b.prototype.cmod=function(a){var c=this.enterScope(new Sk.builtin.str("<module>"),a,0,this.canSuspend),m=this.newBlock("module entry");this.u.prefixCode="var "+c+"=(function($forcegbl, $forceloc){";
this.u.varDeclsCode="var $gbl = $forcegbl || {}, $blk="+m+",$exc=[],$loc=$forceloc || $gbl,$cell={},$err=undefined;var $ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";null!==Sk.execLimit&&(this.u.varDeclsCode+="if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.varDeclsCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.varDeclsCode+="var $waking=false; if ("+c+
".$wakingSuspension!==undefined) { $wakeFromSuspension(); $waking=true; }if (Sk.retainGlobals) {    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; }    else { Sk.globals = $gbl; }} else { Sk.globals = $gbl; }";this.u.switchCode="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="}";this.u.suffixCode+="}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+
this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } });";switch(a.constructor){case Sk.astnodes.Module:this.cbody(a.body);k("return $loc;");break;default:Sk.asserts.fail("todo; unhandled case in compilerMod")}this.exitScope();this.result.push(this.outputAllUnits());return c};Sk.compile=function(a,c,m,n){m=Sk.__future__;Sk.__future__=Object.create(Sk.__future__);var d=Sk.parse(c,a),l=Sk.astFromParse(d.cst,c,d.flags);d=d.flags;var r=Sk.symboltable(l,
c);a=new b(c,r,d,n,a);n=a.cmod(l);Sk.__future__=m;return{funcname:"$compiledmod",code:`var $compiledmod = function() {${a.result.join("")}\nreturn ${n};}();\n$compiledmod;`,filename:c}};Sk.exportSymbol("Sk.compile",Sk.compile);Sk.resetCompiler=function(){Sk.gensymcount=0};Sk.exportSymbol("Sk.resetCompiler",Sk.resetCompiler);Sk.fixReserved=e;Sk.exportSymbol("Sk.fixReserved",Sk.fixReserved);Sk.unfixReserved=function(a){return a.replace(/_\$rw\$$/,"")};Sk.exportSymbol("Sk.unfixReserved",Sk.unfixReserved);
Sk.mangleName=g;Sk.exportSymbol("Sk.mangleName",Sk.mangleName);Sk.reservedWords_=p;Sk.exportSymbol("Sk.reservedWords_",Sk.reservedWords_)},function(E,Q){Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.importSearchPathForName=function(b,f,e){var g=b.replace(/\./g,"/"),k=function(p,h){return Sk.misceval.chain(Sk.misceval.tryCatch(function(){return Sk.read(p)},function(a){}),function(a){if(void 0!==a)return new Sk.misceval.Break({filename:p,code:a,packagePath:h})})};void 0===e&&(e=Sk.realsyspath);
return Sk.misceval.iterFor(e.tp$iter(),function(p){return Sk.misceval.chain(k(p.v+"/"+g+f,!1),function(h){return h?h:k(p.v+"/"+g+"/__init__"+f,p.v+"/"+g)})})};Sk.importSetUpPath=function(b){if(!Sk.realsyspath){var f=[new Sk.builtin.str("src/builtin"),new Sk.builtin.str("src/lib"),new Sk.builtin.str(".")];for(b=0;b<Sk.syspath.length;++b)f.push(new Sk.builtin.str(Sk.syspath[b]));Sk.realsyspath=new Sk.builtin.list(f)}};Sk.importModuleInternal_=function(b,f,e,g,k,p,h){var a,c,m,n,d=null,l=void 0!==k?
k.tp$getattr(Sk.builtin.str.$name):void 0,r=void 0!==l?l.v+".":"",v=void 0!==k?k.tp$getattr(Sk.builtin.str.$path):void 0;Sk.importSetUpPath(h);if(k&&!l){if(p)return;throw new Sk.builtin.ValueError("Attempted to import relative to invalid package (no name)");}void 0===e&&(e=r+b);var q=b.split(".");if(1<q.length){var t=q.slice(0,q.length-1).join(".");d=Sk.importModuleInternal_(t,f,void 0,void 0,k,p,h)}var w=Sk.misceval.chain(d,function(C){d=C;c=Sk.sysmodules.quick$lookup(new Sk.builtin.str(e));return void 0!==
c?d||c:Sk.misceval.chain(void 0,function(){var D=b;if(1<q.length){if(!d)return;m=Sk.sysmodules.mp$subscript(new Sk.builtin.str(r+t));D=q[q.length-1];v=m.tp$getattr(Sk.builtin.str.$path)}n=new Sk.builtin.module;if("string"===typeof g){a=b+".py";var L=Sk.compile(g,a,"exec",h)}else L=Sk.misceval.chain(void 0,function(){if(Sk.onBeforeImport&&"function"===typeof Sk.onBeforeImport)return Sk.onBeforeImport(b)},function(N){if(!1===N)throw new Sk.builtin.ImportError("Importing "+b+" is not allowed");if("string"===
typeof N)throw new Sk.builtin.ImportError(N);return Sk.importSearchPathForName(D,".js",v)},function(N){return N?{funcname:"$builtinmodule",code:N.code,filename:N.filename,packagePath:N.packagePath}:Sk.misceval.chain(Sk.importSearchPathForName(D,".py",v),function(A){if(N=A)return Sk.compile(N.code,N.filename,"exec",h)},function(A){if(A)return A.packagePath=N.packagePath,A})});return L},function(D){if(D){var L=n.$js=D.code;null==a&&(a=D.filename);null!=Sk.dateSet&&Sk.dateSet||(L="Sk.execStart = Sk.lastYield = new Date();\n"+
D.code,Sk.dateSet=!0);if(f){var N=function(F){var J,P=Sk.js_beautify(F).split("\n");for(J=1;J<=P.length;++J){var W=(""+J).length;for(F="";5>W;++W)F+=" ";P[J-1]="/* "+F+J+" */ "+P[J-1]}return P.join("\n")};L=N(L);Sk.debugout(L)}"$compiledmod"!==D.funcname&&(L+="\n"+D.funcname+";");var A=new Sk.builtin.str(e),H=new Sk.builtin.str(b);Sk.sysmodules.mp$ass_subscript(A,n);k&&k.tp$setattr(H,n);var x=Sk.global.eval(L);n.init$dict(A,Sk.builtin.none.none$);n.$d.__package__=D.packagePath?A:t?new Sk.builtin.str(r+
t):l?l:Sk.builtin.none.none$;D.packagePath&&(n.$d.__path__=new Sk.builtin.tuple([new Sk.builtin.str(D.packagePath)]));D.filename&&"$builtinmodule"!==D.funcname&&(n.$d.__file__=new Sk.builtin.str(D.filename));var B=k&&k.$initializing;n.$initializing=!0;k&&!B&&(k.$initializing=!0);return Sk.misceval.tryCatch(()=>Sk.misceval.chain(x(n.$d),F=>{n.$initializing=!1;k&&!B&&(k.$initializing=!1);return F}),F=>{try{Sk.abstr.objectDelItem(Sk.sysmodules,A)}catch(J){}if(k)try{k.tp$setattr(H,void 0)}catch(J){}n.$initializing=
!1;k&&!B&&(k.$initializing=!1);throw F;})}},function(D){var L;if(void 0===D){if(p&&!d)return;throw new Sk.builtin.ModuleNotFoundError("No module named "+Sk.misceval.objectRepr(new Sk.builtin.str(b)));}if(D!==n.$d){for(L in n.$d)D[L]||(D[L]=n.$d[L]);n.$d=D}if(Sk.onAfterImport&&"function"===typeof Sk.onAfterImport)try{Sk.onAfterImport(b)}catch(N){}return d?(m.tp$setattr(new Sk.builtin.str(q[q.length-1]),n),d):n})});return h?w:Sk.misceval.retryOptionalSuspensionOrThrow(w)};Sk.importModule=function(b,
f,e){return Sk.importModuleInternal_(b,f,void 0,void 0,void 0,!1,e)};Sk.importMain=function(b,f,e){Sk.dateSet=!1;Sk.filesLoaded=!1;Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.resetCompiler();return Sk.importModuleInternal_(b,f,"__main__",void 0,void 0,!1,e)};Sk.importMainWithBody=function(b,f,e,g){Sk.dateSet=!1;Sk.filesLoaded=!1;Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.resetCompiler();return Sk.importModuleInternal_(b,f,"__main__",e,void 0,!1,g)};Sk.importBuiltinWithBody=
function(b,f,e,g){return Sk.importModuleInternal_(b,f,"__builtin__."+b,e,void 0,!1,g)};Sk.builtin.__import__=function(b,f,e,g,k){b=b.toString();var p=Sk.globals,h;null==k&&(k=Sk.__future__.absolute_import?0:-1);if(0!==k&&f.__package__&&f.__package__!==Sk.builtin.none.none$){if((h=f.__package__.v)&&0<k){f=h.split(".");if(k-1>=f.length)throw new Sk.builtin.ImportError("Attempted relative import beyond toplevel package");f.length-=k-1;h=f.join(".")}var a=Sk.sysmodules.quick$lookup(new Sk.builtin.str(h))}if(0<
k&&void 0===a)throw new Sk.builtin.ImportError("Attempted relative import in non-package");b.split(".");return Sk.misceval.chain(void 0,function(){if(0!==k&&void 0!==a)return""===b?a:Sk.importModuleInternal_(b,void 0,h+"."+b,void 0,a,-1==k,!0)},function(c){return void 0===c?(h=a=void 0,Sk.importModuleInternal_(b,void 0,void 0,void 0,void 0,!1,!0)):c},function(c){if(g&&0!==g.length){c=[null];const m=Sk.sysmodules.mp$subscript(new Sk.builtin.str((h||"")+(h&&b?".":"")+b));for(let n=0;n<g.length;n++){const d=
g[n];"*"!==d&&void 0===m.tp$getattr(new Sk.builtin.str(d))&&c.push(()=>Sk.importModuleInternal_(d,void 0,void 0,void 0,m,!0,!0))}return Sk.misceval.chain(...c,function(){Sk.asserts.assert(m);return m})}return c},function(c){p!==Sk.globals&&(Sk.globals=p);return c})};Sk.importStar=function(b,f,e){if(e=b.tp$getattr(new Sk.builtin.str("__all__")))for(let g=Sk.abstr.iter(e),k=g.tp$iternext();void 0!==k;k=g.tp$iternext())f[k.v]=Sk.abstr.gattr(b,k);else{e=Object.getOwnPropertyNames(b.$d);for(let g in e)"_"!=
e[g].charAt(0)&&(f[e[g]]=b.$d[e[g]])}};Sk.exportSymbol("Sk.importMain",Sk.importMain);Sk.exportSymbol("Sk.importMainWithBody",Sk.importMainWithBody);Sk.exportSymbol("Sk.importBuiltinWithBody",Sk.importBuiltinWithBody);Sk.exportSymbol("Sk.builtin.__import__",Sk.builtin.__import__);Sk.exportSymbol("Sk.importStar",Sk.importStar)},function(E,Q){Sk.builtin.timSort=function(b,f){this.list=new Sk.builtin.list(b.v);this.MIN_GALLOP=7;this.listlength=f?f:b.sq$length()};Sk.builtin.timSort.prototype.lt=function(b,
f){return Sk.misceval.richCompareBool(b,f,"Lt")};Sk.builtin.timSort.prototype.le=function(b,f){return!this.lt(f,b)};Sk.builtin.timSort.prototype.setitem=function(b,f){this.list.v[b]=f};Sk.builtin.timSort.prototype.binary_sort=function(b,f){var e;for(e=b.base+f;e<b.base+b.len;e++){var g=b.base;var k=e;for(f=b.getitem(k);g<k;){var p=g+(k-g>>1);this.lt(f,b.getitem(p))?k=p:g=p+1}Sk.asserts.assert(g===k);for(p=e;p>g;p--)b.setitem(p,b.getitem(p-1));b.setitem(g,f)}};Sk.builtin.timSort.prototype.count_run=
function(b){var f;if(1>=b.len){var e=b.len;var g=!1}else if(e=2,this.lt(b.getitem(b.base+1),b.getitem(b.base)))for(g=!0,f=b.base+2;f<b.base+b.len;f++)if(this.lt(b.getitem(f),b.getitem(f-1)))e++;else break;else for(g=!1,f=b.base+2;f<b.base+b.len&&!this.lt(b.getitem(f),b.getitem(f-1));f++)e++;return{run:new Sk.builtin.listSlice(b.list,b.base,e),descending:g}};Sk.builtin.timSort.prototype.sort=function(){var b,f=new Sk.builtin.listSlice(this.list,0,this.listlength);if(!(2>f.len)){this.merge_init();for(b=
this.merge_compute_minrun(f.len);0<f.len;){var e=this.count_run(f);e.descending&&e.run.reverse();if(e.run.len<b){var g=e.run.len;e.run.len=b<f.len?b:f.len;this.binary_sort(e.run,g)}f.advance(e.run.len);this.pending.push(e.run);this.merge_collapse()}Sk.asserts.assert(f.base==this.listlength);this.merge_force_collapse();Sk.asserts.assert(1==this.pending.length);Sk.asserts.assert(0===this.pending[0].base);Sk.asserts.assert(this.pending[0].len==this.listlength)}};Sk.builtin.timSort.prototype.gallop=function(b,
f,e,g){var k;Sk.asserts.assert(0<=e&&e<f.len);var p=this;g=g?function(m,n){return p.le(m,n)}:function(m,n){return p.lt(m,n)};var h=f.base+e;var a=0;var c=1;if(g(f.getitem(h),b)){for(k=f.len-e;c<k;)if(g(f.getitem(h+c),b)){a=c;try{c=(c<<1)+1}catch(m){c=k}}else break;c>k&&(c=k);a+=e;c+=e}else{for(k=e+1;c<k&&!g(f.getitem(h-c),b);){a=c;try{c=(c<<1)+1}catch(m){c=k}}c>k&&(c=k);h=e-a;a=e-c;c=h}Sk.asserts.assert(-1<=a<c<=f.len);for(a+=1;a<c;)e=a+(c-a>>1),g(f.getitem(f.base+e),b)?a=e+1:c=e;Sk.asserts.assert(a==
c);return c};Sk.builtin.timSort.prototype.merge_init=function(){this.min_gallop=this.MIN_GALLOP;this.pending=[]};Sk.builtin.timSort.prototype.merge_lo=function(b,f){var e,g,k;Sk.asserts.assert(0<b.len&&0<f.len&&b.base+b.len==f.base);var p=this.min_gallop;var h=b.base;b=b.copyitems();try{if(this.setitem(h,f.popleft()),h++,1!=b.len&&0!==f.len)for(;;){for(g=e=0;;)if(this.lt(f.getitem(f.base),b.getitem(b.base))){this.setitem(h,f.popleft());h++;if(0===f.len)return;g++;e=0;if(g>=p)break}else{this.setitem(h,
b.popleft());h++;if(1==b.len)return;e++;g=0;if(e>=p)break}for(p+=1;;){this.min_gallop=p-=1<p;e=this.gallop(f.getitem(f.base),b,0,!0);for(k=b.base;k<b.base+e;k++)this.setitem(h,b.getitem(k)),h++;b.advance(e);if(1>=b.len)return;this.setitem(h,f.popleft());h++;if(0===f.len)return;g=this.gallop(b.getitem(b.base),f,0,!1);for(k=f.base;k<f.base+g;k++)this.setitem(h,f.getitem(k)),h++;f.advance(g);if(0===f.len)return;this.setitem(h,b.popleft());h++;if(1==b.len)return;if(e<this.MIN_GALLOP&&g<this.MIN_GALLOP)break;
p++;this.min_gallop=p}}}finally{Sk.asserts.assert(0<=b.len&&0<=f.len);for(k=f.base;k<f.base+f.len;k++)this.setitem(h,f.getitem(k)),h++;for(k=b.base;k<b.base+b.len;k++)this.setitem(h,b.getitem(k)),h++}};Sk.builtin.timSort.prototype.merge_hi=function(b,f){var e,g,k;Sk.asserts.assert(0<b.len&&0<f.len&&b.base+b.len==f.base);var p=this.min_gallop;var h=f.base+f.len;f=f.copyitems();try{if(h--,this.setitem(h,b.popright()),0!==b.len&&1!=f.len)for(;;){for(g=e=0;;){var a=b.getitem(b.base+b.len-1);var c=f.getitem(f.base+
f.len-1);if(this.lt(c,a)){h--;this.setitem(h,a);b.len--;if(0===b.len)return;e++;g=0;if(e>=p)break}else{h--;this.setitem(h,c);f.len--;if(1==f.len)return;g++;e=0;if(g>=p)break}}for(p+=1;;){this.min_gallop=p-=1<p;c=f.getitem(f.base+f.len-1);var m=this.gallop(c,b,b.len-1,!0);e=b.len-m;for(k=b.base+b.len-1;k>b.base+m-1;k--)h--,this.setitem(h,b.getitem(k));b.len-=e;if(0===b.len)return;h--;this.setitem(h,f.popright());if(1==f.len)return;a=b.getitem(b.base+b.len-1);m=this.gallop(a,f,f.len-1,!1);g=f.len-m;
for(k=f.base+f.len-1;k>f.base+m-1;k--)h--,this.setitem(h,f.getitem(k));f.len-=g;if(1>=f.len)return;h--;this.setitem(h,b.popright());if(0===b.len)return;if(e<this.MIN_GALLOP&&g<this.MIN_GALLOP)break;p++;this.min_gallop=p}}}finally{Sk.asserts.assert(0<=b.len&&0<=f.len);for(k=b.base+b.len-1;k>b.base-1;k--)h--,this.setitem(h,b.getitem(k));for(k=f.base+f.len-1;k>f.base-1;k--)h--,this.setitem(h,f.getitem(k))}};Sk.builtin.timSort.prototype.merge_at=function(b){0>b&&(b=this.pending.length+b);var f=this.pending[b];
var e=this.pending[b+1];Sk.asserts.assert(0<f.len&&0<e.len);Sk.asserts.assert(f.base+f.len==e.base);this.pending[b]=new Sk.builtin.listSlice(this.list,f.base,f.len+e.len);this.pending.splice(b+1,1);b=this.gallop(e.getitem(e.base),f,0,!0);f.advance(b);0!==f.len&&(e.len=this.gallop(f.getitem(f.base+f.len-1),e,e.len-1,!1),0!==e.len&&(f.len<=e.len?this.merge_lo(f,e):this.merge_hi(f,e)))};Sk.builtin.timSort.prototype.merge_collapse=function(){for(var b=this.pending;1<b.length;)if(3<=b.length&&b[b.length-
3].len<=b[b.length-2].len+b[b.length-1].len)b[b.length-3].len<b[b.length-1].len?this.merge_at(-3):this.merge_at(-2);else if(b[b.length-2].len<=b[b.length-1].len)this.merge_at(-2);else break};Sk.builtin.timSort.prototype.merge_force_collapse=function(){for(var b=this.pending;1<b.length;)3<=b.length&&b[b.length-3].len<b[b.length-1].len?this.merge_at(-3):this.merge_at(-2)};Sk.builtin.timSort.prototype.merge_compute_minrun=function(b){for(var f=0;64<=b;)f|=b&1,b>>=1;return b+f};Sk.builtin.listSlice=function(b,
f,e){this.list=b;this.base=f;this.len=e};Sk.builtin.listSlice.prototype.copyitems=function(){var b=this.base,f=this.base+this.len;Sk.asserts.assert(0<=b<=f);return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(b,f)),0,this.len)};Sk.builtin.listSlice.prototype.advance=function(b){this.base+=b;this.len-=b;Sk.asserts.assert(this.base<=this.list.sq$length())};Sk.builtin.listSlice.prototype.getitem=function(b){return this.list.v[b]};Sk.builtin.listSlice.prototype.setitem=function(b,f){this.list.v[b]=
f};Sk.builtin.listSlice.prototype.popleft=function(){var b=this.list.v[this.base];this.base++;this.len--;return b};Sk.builtin.listSlice.prototype.popright=function(){this.len--;return this.list.v[this.base+this.len]};Sk.builtin.listSlice.prototype.reverse=function(){for(var b,f,e=this.list,g=this.base,k=g+this.len-1;g<k;)b=e.v[k],f=e.v[g],e.v[g]=b,e.v[k]=f,g++,k--};Sk.exportSymbol("Sk.builtin.listSlice",Sk.builtin.listSlice);Sk.exportSymbol("Sk.builtin.timSort",Sk.builtin.timSort)},function(E,Q){Sk.builtin.super_=
Sk.abstr.buildNativeClass("super",{constructor:function(b,f){Sk.asserts.assert(this instanceof Sk.builtin.super_,"bad call to super, use 'new'");this.type=b;this.obj=f;if(void 0!==b&&!Sk.builtin.checkClass(b))throw new Sk.builtin.TypeError("must be type, not "+Sk.abstr.typeName(b));this.obj_type=void 0!==this.obj?this.$supercheck(b,this.obj):null},slots:{tp$doc:"super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)\n",
tp$new:Sk.generic.new,tp$init(b,f){Sk.abstr.checkNoKwargs("super",f);Sk.abstr.checkArgsLen("super",b,1,2);f=b[0];b=b[1];if(!Sk.builtin.checkClass(f))throw new Sk.builtin.TypeError("must be type, not "+Sk.abstr.typeName(f));this.obj=b;this.type=f;null!=this.obj&&(this.obj_type=this.$supercheck(f,this.obj))},$r(){return this.obj?new Sk.builtin.str("<super: <class '"+this.type.prototype.tp$name+"'>, <"+Sk.abstr.typeName(this.obj)+" object>>"):new Sk.builtin.str("<super: <class '"+this.type.prototype.tp$name+
"'>, NULL>")},tp$getattr(b,f){let e=this.obj_type;if(null==e)return Sk.generic.getAttr.call(this,b,f);var g=e.prototype.tp$mro;const k=g.length;if(b===Sk.builtin.str.$class)return Sk.generic.getAttr.call(this,b,f);let p;for(p=0;p+1<k&&this.type!==g[p];p++);p++;if(p>=k)return Sk.generic.getAttr.call(this,b,f);b=b.$mangled;let h;for(;p<k;){f=g[p].prototype;f.hasOwnProperty(b)&&(h=f[b]);if(void 0!==h)return g=h.tp$descr_get,void 0!==g&&(h=g.call(h,this.obj===e?null:this.obj,e)),h;p++}},tp$descr_get(b,
f,e){if(null===b||null!=this.obj)return this;if(this.ob$type!==Sk.builtin.super_)return b=Sk.misceval.callsimOrSuspendArray(this.ob$type,[this.type,b]),e?b:Sk.misceval.retryOptionalSuspensionOrThrow(b);e=this.$supercheck(this.type,b);f=new Sk.builtin.super_;f.type=this.type;f.obj=b;f.obj_type=e;return f}},getsets:{__thisclass__:{$get(){return this.type},$doc:"the class invoking super()"},__self__:{$get(){return this.obj||Sk.builtin.none.none$},$doc:"the instance invoking super(); may be None"},__self_class__:{$get(){return this.obj_type||
Sk.builtin.none.none$},$doc:"the type of the instance invoking super(); may be None"}},proto:{$supercheck(b,f){if(Sk.builtin.checkClass(f)&&f.$isSubType(b))return f;if(f.ob$type.$isSubType(b))return f.ob$type;{const e=f.tp$getattr(Sk.builtin.str.$class);if(void 0!==e&&e!==f.ob$type&&Sk.builtin.checkClass(e)&&e.$isSubType(b))return e}throw new Sk.builtin.TypeError("super(type, obj): obj must be an instance or subtype of type");}}})},function(E,Q){Sk.builtin.GenericAlias=Sk.abstr.buildNativeClass("types.GenericAlias",
{constructor:function(b,f){this.$origin=b;f instanceof Sk.builtin.tuple||(f=new Sk.builtin.tuple([f]));this.$args=f;this.$params=null},slots:{tp$new(b,f){Sk.abstr.checkNoKwargs("GenericAlias",f);Sk.abstr.checkArgsLen("GenericAlias",b,2,2);return new Sk.builtin.GenericAlias(b[0],b[1])},tp$getattr(b,f){return Sk.builtin.checkString(b)&&!this.attr$exc.includes(b)?this.$origin.tp$getattr(b,f):Sk.generic.getAttr.call(this,b,f)},$r(){const b=this.ga$repr(this.$origin);let f="";this.$args.v.forEach((e,g)=>
{f+=0<g?", ":"";f+=this.ga$repr(e)});f||(f="()");return new Sk.builtin.str(b+"["+f+"]")},tp$doc:"Represent a PEP 585 generic type\n\nE.g. for t = list[int], t.origin is list and t.args is (int,).",tp$hash(){const b=Sk.abstr.objectHash(this.$origin);if(-1==b)return-1;const f=Sk.abstr.objectHash(this.$args);return-1==f?-1:b^f},tp$call(b,f){b=Sk.misceval.callsimArray(this.$origin,b,f);try{b.tp$setattr(new Sk.builtin.str("__orig_class__"),this)}catch(e){if(!(e instanceof Sk.builtin.AttributeError||e instanceof
Sk.builtin.TypeError))throw e;}return b},tp$richcompare(b,f){if(!(b instanceof Sk.builtin.GenericAlias)||"Eq"!==f&&"NotEq"!==f)return Sk.builtin.NotImplemented.NotImplemented$;const e=Sk.misceval.richCompareBool(this.$origin,b.$origin,"Eq");if(!e)return"Eq"===f?e:!e;b=Sk.misceval.richCompareBool(this.$args,b.$args,"Eq");return"Eq"===f?b:!b},tp$as_sequence_or_mapping:!0,mp$subscript(b){null===this.$params&&this.mk$params();if(0===this.$params.sq$length())throw new Sk.builtin.TypeError("There are no type variables left in "+
Sk.misceval.objectRepr(this));}},methods:{__mro_entries__:{$meth(){return new Sk.builtin.tuple([this.$origin])},$flags:{NoArgs:!0}},__instancecheck__:{$meth(b){throw new Sk.builtin.TypeError("isinstance() argument 2 cannot be a parameterized generic");},$flags:{OneArg:!0}},__subclasscheck__:{$meth(b){throw new Sk.builtin.TypeError("issubclass() argument 2 cannot be a parameterized generic");},$flags:{OneArg:!0}}},getsets:{__parameters__:{$get(){null===this.$params&&this.mk$params();return this.$params},
$doc:"Type variables in the GenericAlias."},__origin__:{$get(){return this.$origin}},__args__:{$get(){return this.$args}}},proto:{mk$params(){const b=[];this.$args.v.forEach(f=>{this.is$typevar(f)&&0>this.tuple$index(b,f)&&b.push(f)});this.$params=new Sk.builtin.tuple(b)},tuple$index(b,f){return b.indexOf(f)},is$typevar(b){if("TypeVar"!==b.tp$name)return!1;b=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$module);if(void 0===b)throw Sk.builtin.RuntimeError("found object withought a __module__");return"typing"===
b.toString()},ga$repr(b){if(b===Sk.builtin.Ellipsis)return"...";if(Sk.abstr.lookupSpecial(b,this.str$orig)&&Sk.abstr.lookupSpecial(b,this.str$args))return Sk.misceval.objectRepr(b);const f=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$qualname);if(void 0===f)return Sk.misceval.objectRepr(b);const e=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$module);return void 0===e||Sk.builtin.checkNone(e)?Sk.misceval.objectRepr(b):"builtins"===e.toString()?f.toString():e.toString()+"."+f.toString()},str$orig:new Sk.builtin.str("__origin__"),
str$args:new Sk.builtin.str("__args__"),attr$exc:"__origin__ __args__ __parameters__ __mro_entries__ __reduce_ex__ __reduce__".split(" ").map(b=>new Sk.builtin.str(b))}})},function(E,Q){function b(g,k){let p=void 0;if(void 0===g||Sk.builtin.checkNone(g))g=void 0;else if(g instanceof Sk.builtin.dict)p={},g.$items().forEach(h=>{var [a,c]=h;Sk.builtin.checkString(a)&&(p[a.$mangled]=c)});else throw new Sk.builtin.TypeError(k+" must be a dict or None, not "+Sk.abstr.typeName(g));return p}function f(g,
k){if(void 0!==g&&!Sk.builtin.checkNone(g))for(let p in k)g.mp$ass_subscript(new Sk.builtin.str(Sk.unfixReserved(p)),k[p])}Sk.builtins={round:null,len:null,min:null,max:null,sum:null,abs:null,fabs:null,ord:null,chr:null,hex:null,oct:null,bin:null,dir:null,repr:null,open:null,isinstance:null,hash:null,getattr:null,hasattr:null,id:null,sorted:null,any:null,all:null,enumerate:Sk.builtin.enumerate,filter:Sk.builtin.filter_,map:Sk.builtin.map_,range:Sk.builtin.range_,reversed:Sk.builtin.reversed,zip:Sk.builtin.zip_,
BaseException:Sk.builtin.BaseException,AttributeError:Sk.builtin.AttributeError,ValueError:Sk.builtin.ValueError,Exception:Sk.builtin.Exception,ZeroDivisionError:Sk.builtin.ZeroDivisionError,AssertionError:Sk.builtin.AssertionError,ImportError:Sk.builtin.ImportError,ModuleNotFoundError:Sk.builtin.ModuleNotFoundError,IndentationError:Sk.builtin.IndentationError,IndexError:Sk.builtin.IndexError,LookupError:Sk.builtin.LookupError,KeyError:Sk.builtin.KeyError,TypeError:Sk.builtin.TypeError,UnicodeDecodeError:Sk.builtin.UnicodeDecodeError,
UnicodeEncodeError:Sk.builtin.UnicodeEncodeError,NameError:Sk.builtin.NameError,UnboundLocalError:Sk.builtin.UnboundLocalError,IOError:Sk.builtin.IOError,NotImplementedError:Sk.builtin.NotImplementedError,SystemExit:Sk.builtin.SystemExit,OverflowError:Sk.builtin.OverflowError,OperationError:Sk.builtin.OperationError,NegativePowerError:Sk.builtin.NegativePowerError,RuntimeError:Sk.builtin.RuntimeError,RecursionError:Sk.builtin.RecursionError,StopIteration:Sk.builtin.StopIteration,SyntaxError:Sk.builtin.SyntaxError,
SystemError:Sk.builtin.SystemError,KeyboardInterrupt:Sk.builtin.KeyboardInterrupt,float_$rw$:Sk.builtin.float_,int_$rw$:Sk.builtin.int_,bool:Sk.builtin.bool,complex:Sk.builtin.complex,dict:Sk.builtin.dict,file:Sk.builtin.file,frozenset:Sk.builtin.frozenset,"function":Sk.builtin.func,generator:Sk.builtin.generator,list:Sk.builtin.list,long_$rw$:Sk.builtin.lng,method:Sk.builtin.method,object:Sk.builtin.object,slice:Sk.builtin.slice,str:Sk.builtin.str,set:Sk.builtin.set,tuple:Sk.builtin.tuple,type:Sk.builtin.type,
input:null,raw_input:new Sk.builtin.func(Sk.builtin.raw_input),setattr:null,jseval:Sk.builtin.jseval,jsmillis:Sk.builtin.jsmillis,quit:new Sk.builtin.func(Sk.builtin.quit),exit:new Sk.builtin.func(Sk.builtin.quit),print:null,divmod:null,format:null,globals:null,issubclass:null,iter:null,execfile:Sk.builtin.execfile,help:Sk.builtin.help,memoryview:Sk.builtin.memoryview,reload:Sk.builtin.reload,super_$rw$:Sk.builtin.super_,unichr:new Sk.builtin.func(Sk.builtin.unichr),vars:Sk.builtin.vars,apply_$rw$:Sk.builtin.apply_,
buffer:Sk.builtin.buffer,coerce:Sk.builtin.coerce,intern:Sk.builtin.intern,property:Sk.builtin.property,classmethod:Sk.builtin.classmethod,staticmethod:Sk.builtin.staticmethod,Ellipsis:Sk.builtin.Ellipsis};E=Sk.builtin.none.none$;Q=new Sk.builtin.tuple;const e=new Sk.builtin.int_(0);Sk.abstr.setUpModuleMethods("builtins",Sk.builtins,{__import__:{$meth(g,k,p,h,a){if(!Sk.builtin.checkString(g))throw new Sk.builtin.TypeError("__import__() argument 1 must be str, not "+g.tp$name);if(g===Sk.builtin.str.$empty&&
0===a.v)throw new Sk.builtin.ValueError("Empty module name");k=b(k,"globals")||{};h=Sk.ffi.remapToJs(h);a=Sk.ffi.remapToJs(a);return Sk.builtin.__import__(g,k,void 0,h,a)},$flags:{NamedArgs:["name","globals","locals","fromlist","level"],Defaults:[E,E,Q,e]},$textsig:null,$doc:"__import__(name, globals=None, locals=None, fromlist=(), level=0) -> module\n\nImport a module. Because this function is meant for use by the Python\ninterpreter and not for general use, it is better to use\nimportlib.import_module() to programmatically import a module.\n\nThe globals argument is only used to determine the context;\nthey are not modified.  The locals argument is unused.  The fromlist\nshould be a list of names to emulate ``from name import ...'', or an\nempty list to emulate ``import name''.\nWhen importing a module from a package, note that __import__('A.B', ...)\nreturns package A when fromlist is empty, but its submodule B when\nfromlist is not empty.  The level argument is used to determine whether to\nperform absolute or relative imports: 0 is absolute, while a positive number\nis the number of parent directories to search relative to the current module."},
abs:{$meth:Sk.builtin.abs,$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the absolute value of the argument."},all:{$meth:Sk.builtin.all,$flags:{OneArg:!0},$textsig:"($module, iterable, /)",$doc:"Return True if bool(x) is True for all values x in the iterable.\n\nIf the iterable is empty, return True."},any:{$meth:Sk.builtin.any,$flags:{OneArg:!0},$textsig:"($module, iterable, /)",$doc:"Return True if bool(x) is True for any x in the iterable.\n\nIf the iterable is empty, return False."},
ascii:{$meth:Sk.builtin.ascii,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."},bin:{$meth:Sk.builtin.bin,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the binary representation of an integer.\n\n   >>> bin(2796202)\n   '0b1010101010101010101010'"},
callable:{$meth:Sk.builtin.callable,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a\n__call__() method."},chr:{$meth:Sk.builtin.chr,$flags:{OneArg:!0},$textsig:"($module, i, /)",$doc:"Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff."},compile:{$meth:Sk.builtin.compile,$flags:{MinArgs:3,MaxArgs:6},$textsig:"($module, /, source, filename, mode, flags=0,\n        dont_inherit=False, optimize=-1)",
$doc:"Compile source into a code object that can be executed by exec() or eval().\n\nThe source code may represent a Python module, statement or expression.\nThe filename will be used for run-time error messages.\nThe mode must be 'exec' to compile a module, 'single' to compile a\nsingle (interactive) statement, or 'eval' to compile an expression.\nThe flags argument, if present, controls which future statements influence\nthe compilation of the code.\nThe dont_inherit argument, if true, stops the compilation inheriting\nthe effects of any future statements in effect in the code calling\ncompile; if absent or false these statements do influence the compilation,\nin addition to any features explicitly specified."},
delattr:{$meth:Sk.builtin.delattr,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, name, /)",$doc:"Deletes the named attribute from the given object.\n\ndelattr(x, 'y') is equivalent to ``del x.y''"},dir:{$meth:Sk.builtin.dir,$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"dir([object]) -> list of strings\n\nIf called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes."},
divmod:{$meth:Sk.builtin.divmod,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."},eval_$rw$:{$name:"eval",$meth:function(g,k,p){const h=b(k,"globals"),a=b(p,"locals");return Sk.misceval.chain(Sk.builtin.eval(g,h,a),c=>{f(k,h);f(p,a);return c})},$flags:{MinArgs:1,MaxArgs:3},$textsig:"($module, source, globals=None, locals=None, /)",$doc:"Evaluate the given source in the context of globals and locals.\n\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it."},
exec:{$meth:function(g,k,p){const h=b(k,"globals"),a=b(p,"locals");return Sk.misceval.chain(Sk.builtin.exec(g,h,a),c=>{f(k,h);f(p,a);return Sk.builtin.none.none$})},$flags:{MinArgs:1,MaxArgs:3},$textsig:"($module, source, globals=None, locals=None, /)",$doc:"Execute the given source in the context of globals and locals.\n\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it."},
format:{$meth:Sk.builtin.format,$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, value, format_spec='', /)",$doc:"Return value.__format__(format_spec)\n\nformat_spec defaults to the empty string.\nSee the Format Specification Mini-Language section of help('FORMATTING') for\ndetails."},getattr:{$meth:Sk.builtin.getattr,$flags:{MinArgs:2,MaxArgs:3},$textsig:null,$doc:"getattr(object, name[, default]) -> value\n\nGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case."},
globals:{$meth:Sk.builtin.globals,$flags:{NoArgs:!0},$textsig:"($module, /)",$doc:"Return the dictionary containing the current scope's global variables.\n\nNOTE: Updates to this dictionary *will* affect name lookups in the current\nglobal scope and vice-versa."},hasattr:{$meth:Sk.builtin.hasattr,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, name, /)",$doc:"Return whether the object has an attribute with the given name.\n\nThis is done by calling getattr(obj, name) and catching AttributeError."},
hash:{$meth:Sk.builtin.hash,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the hash value for the given object.\n\nTwo objects that compare equal must also have the same hash value, but the\nreverse is not necessarily true."},hex:{$meth:Sk.builtin.hex,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the hexadecimal representation of an integer.\n\n   >>> hex(12648430)\n   '0xc0ffee'"},id:{$meth:Sk.builtin.id,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the identity of an object.\n\nThis is guaranteed to be unique among simultaneously existing objects.\n(CPython uses the object's memory address.)"},
input:{$meth:Sk.builtin.input,$flags:{MinArgs:0,MaxArgs:1},$textsig:"($module, prompt=None, /)",$doc:"Read a string from standard input.  The trailing newline is stripped.\n\nThe prompt string, if given, is printed to standard output without a\ntrailing newline before reading input.\n\nIf the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\nOn *nix systems, readline is used if available."},isinstance:{$meth:Sk.builtin.isinstance,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, class_or_tuple, /)",
$doc:"Return whether an object is an instance of a class or of a subclass thereof.\n\nA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\nor ...`` etc."},issubclass:{$meth:Sk.builtin.issubclass,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, cls, class_or_tuple, /)",$doc:"Return whether 'cls' is a derived from another class or is the same class.\n\nA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\nor ...`` etc."},
iter:{$meth:Sk.builtin.iter,$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, iterable /)",$doc:"iter(iterable) -> iterator\niter(callable, sentinel) -> iterator\n\nGet an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel."},len:{$meth:Sk.builtin.len,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the number of items in a container."},locals:{$meth:Sk.builtin.locals,
$flags:{NoArgs:!0},$textsig:"($module, /)",$doc:"Return a dictionary containing the current scope's local variables.\n\nNOTE: Whether or not updates to this dictionary will affect name lookups in\nthe local scope and vice-versa is *implementation dependent* and not\ncovered by any backwards compatibility guarantees."},max:{$meth:Sk.builtin.max,$flags:{FastCall:!0},$textsig:null,$doc:"max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the largest argument."},
min:{$meth:Sk.builtin.min,$flags:{FastCall:!0},$textsig:null,$doc:"min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the smallest argument."},next:{$name:"next",$meth:Sk.builtin.next_,$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"next(iterator[, default])\n\nReturn the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration."},
oct:{$meth:Sk.builtin.oct,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the octal representation of an integer.\n\n   >>> oct(342391)\n   '0o1234567'"},open:{$meth:Sk.builtin.open,$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"open(name[, mode[, buffering]]) -> file object\n\nOpen a file using the file() type, returns a file object.  This is the\npreferred way to open a file.  See file.__doc__ for further information."},ord:{$meth:Sk.builtin.ord,$flags:{OneArg:!0},$textsig:"($module, c, /)",
$doc:"Return the Unicode code point for a one-character string."},pow:{$meth:Sk.builtin.pow,$flags:{MinArgs:2,MaxArgs:3},$textsig:"($module, x, y, z=None, /)",$doc:"Equivalent to x**y (with two arguments) or x**y % z (with three arguments)\n\nSome types, such as ints, are able to use a more efficient algorithm when\ninvoked using the three argument form."},print:{$meth:Sk.builtin.print,$flags:{FastCall:!0},$textsig:null,$doc:"print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream."},
repr:{$meth:Sk.builtin.repr,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the canonical string representation of the object.\n\nFor many object types, including most builtins, eval(repr(obj)) == obj."},round:{$meth:Sk.builtin.round,$flags:{NamedArgs:["number","ndigits"]},$textsig:"($module, /, number, ndigits=None)",$doc:"Round a number to a given precision in decimal digits.\n\nThe return value is an integer if ndigits is omitted or None.  Otherwise\nthe return value has the same type as the number.  ndigits may be negative."},
setattr:{$meth:Sk.builtin.setattr,$flags:{MinArgs:3,MaxArgs:3},$textsig:"($module, obj, name, value, /)",$doc:"Sets the named attribute on the given object to the specified value.\n\nsetattr(x, 'y', v) is equivalent to ``x.y = v''"},sorted:{$meth:Sk.builtin.sorted,$flags:{NamedArgs:[null,"cmp","key","reverse"],Defaults:[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.bool.false$]},$textsig:"($module, iterable, /, *, key=None, reverse=False)",$doc:"Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order."},
sum:{$meth:Sk.builtin.sum,$flags:{NamedArgs:[null,"start"],Defaults:[new Sk.builtin.int_(0)]},$textsig:"($module, iterable, /, start=0)",$doc:"Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types."},vars:{$meth:Sk.builtin.vars,$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"vars([object]) -> dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__."}});
Sk.setupObjects=function(g){g?(Sk.builtins.filter=Sk.builtin.filter_,Sk.builtins.map=Sk.builtin.map_,Sk.builtins.zip=Sk.builtin.zip_,Sk.builtins.range=Sk.builtin.range_,delete Sk.builtins.reduce,delete Sk.builtins.xrange,delete Sk.builtins.StandardError,delete Sk.builtins.unicode,delete Sk.builtins.basestring,delete Sk.builtins.long_$rw$,Sk.builtin.int_.prototype.$r=function(){return new Sk.builtin.str(this.v.toString())},delete Sk.builtin.int_.prototype.tp$str,delete Sk.builtin.bool.prototype.tp$str,
delete Sk.builtins.raw_input,delete Sk.builtins.unichr,delete Sk.builtin.str.prototype.decode,Sk.builtins.bytes=Sk.builtin.bytes,Sk.builtins.ascii=new Sk.builtin.sk_method({$meth:Sk.builtin.ascii,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."},
null,"builtins")):(Sk.builtins.range=new Sk.builtin.sk_method({$meth:Sk.builtin.range,$name:"range",$flags:{MinArgs:1,MaxArgs:3}},void 0,"builtins"),Sk.builtins.xrange=new Sk.builtin.sk_method({$meth:Sk.builtin.xrange,$name:"xrange",$flags:{MinArgs:1,MaxArgs:3}},null,"builtins"),Sk.builtins.reduce=new Sk.builtin.sk_method({$meth:Sk.builtin.reduce,$name:"reduce",$flags:{MinArgs:2,MaxArgs:3}},null,"builtins"),Sk.builtins.filter=new Sk.builtin.func(Sk.builtin.filter),Sk.builtins.map=new Sk.builtin.func(Sk.builtin.map),
Sk.builtins.zip=new Sk.builtin.func(Sk.builtin.zip),Sk.builtins.StandardError=Sk.builtin.Exception,Sk.builtins.unicode=Sk.builtin.str,Sk.builtins.basestring=Sk.builtin.str,Sk.builtins.long_$rw$=Sk.builtin.lng,Sk.builtin.int_.prototype.$r=function(){const k=this.v;return"number"===typeof k?new Sk.builtin.str(k.toString()):new Sk.builtin.str(k.toString()+"L")},Sk.builtin.int_.prototype.tp$str=function(){return new Sk.builtin.str(this.v.toString())},Sk.builtin.bool.prototype.tp$str=function(){return this.$r()},
Sk.builtins.raw_input=new Sk.builtin.func(Sk.builtin.raw_input),Sk.builtins.unichr=new Sk.builtin.func(Sk.builtin.unichr),Sk.builtin.str.prototype.decode=Sk.builtin.str.$py2decode,delete Sk.builtins.bytes,delete Sk.builtins.ascii)};Sk.exportSymbol("Sk.setupObjects",Sk.setupObjects);Sk.exportSymbol("Sk.builtins",Sk.builtins)},function(E,Q){Sk.builtin.str.$empty=new Sk.builtin.str("");Sk.builtin.str.$emptystr=Sk.builtin.str.$empty;Sk.builtin.str.$utf8=new Sk.builtin.str("utf-8");Sk.builtin.str.$ascii=
new Sk.builtin.str("ascii");Sk.builtin.str.$default_factory=new Sk.builtin.str("default_factory");Sk.builtin.str.$imag=new Sk.builtin.str("imag");Sk.builtin.str.$real=new Sk.builtin.str("real");Sk.builtin.str.$abs=new Sk.builtin.str("__abs__");Sk.builtin.str.$bytes=new Sk.builtin.str("__bytes__");Sk.builtin.str.$call=new Sk.builtin.str("__call__");Sk.builtin.str.$class=new Sk.builtin.str("__class__");Sk.builtin.str.$class_getitem=new Sk.builtin.str("__class_getitem__");Sk.builtin.str.$cmp=new Sk.builtin.str("__cmp__");
Sk.builtin.str.$complex=new Sk.builtin.str("__complex__");Sk.builtin.str.$contains=new Sk.builtin.str("__contains__");Sk.builtin.str.$copy=new Sk.builtin.str("__copy__");Sk.builtin.str.$dict=new Sk.builtin.str("__dict__");Sk.builtin.str.$dir=new Sk.builtin.str("__dir__");Sk.builtin.str.$doc=new Sk.builtin.str("__doc__");Sk.builtin.str.$enter=new Sk.builtin.str("__enter__");Sk.builtin.str.$eq=new Sk.builtin.str("__eq__");Sk.builtin.str.$exit=new Sk.builtin.str("__exit__");Sk.builtin.str.$index=new Sk.builtin.str("__index__");
Sk.builtin.str.$init=new Sk.builtin.str("__init__");Sk.builtin.str.$initsubclass=new Sk.builtin.str("__init_subclass__");Sk.builtin.str.$int_=new Sk.builtin.str("__int__");Sk.builtin.str.$iter=new Sk.builtin.str("__iter__");Sk.builtin.str.$file=new Sk.builtin.str("__file__");Sk.builtin.str.$float_=new Sk.builtin.str("__float__");Sk.builtin.str.$format=new Sk.builtin.str("__format__");Sk.builtin.str.$ge=new Sk.builtin.str("__ge__");Sk.builtin.str.$getattr=new Sk.builtin.str("__getattr__");Sk.builtin.str.$getattribute=
new Sk.builtin.str("__getattribute__");Sk.builtin.str.$getitem=new Sk.builtin.str("__getitem__");Sk.builtin.str.$gt=new Sk.builtin.str("__gt__");Sk.builtin.str.$keys=new Sk.builtin.str("keys");Sk.builtin.str.$le=new Sk.builtin.str("__le__");Sk.builtin.str.$len=new Sk.builtin.str("__len__");Sk.builtin.str.$length_hint=new Sk.builtin.str("__length_hint__");Sk.builtin.str.$loader=new Sk.builtin.str("__loader__");Sk.builtin.str.$lt=new Sk.builtin.str("__lt__");Sk.builtin.str.$module=new Sk.builtin.str("__module__");
Sk.builtin.str.$missing=new Sk.builtin.str("__missing__");Sk.builtin.str.$name=new Sk.builtin.str("__name__");Sk.builtin.str.$ne=new Sk.builtin.str("__ne__");Sk.builtin.str.$new=new Sk.builtin.str("__new__");Sk.builtin.str.$next=new Sk.builtin.str("__next__");Sk.builtin.str.$path=new Sk.builtin.str("__path__");Sk.builtin.str.$prepare=new Sk.builtin.str("__prepare__");Sk.builtin.str.$qualname=new Sk.builtin.str("__qualname__");Sk.builtin.str.$repr=new Sk.builtin.str("__repr__");Sk.builtin.str.$reversed=
new Sk.builtin.str("__reversed__");Sk.builtin.str.$round=new Sk.builtin.str("__round__");Sk.builtin.str.$setattr=new Sk.builtin.str("__setattr__");Sk.builtin.str.$setitem=new Sk.builtin.str("__setitem__");Sk.builtin.str.$slots=new Sk.builtin.str("__slots__");Sk.builtin.str.$str=new Sk.builtin.str("__str__");Sk.builtin.str.$setname=new Sk.builtin.str("__set_name__");Sk.builtin.str.$trunc=new Sk.builtin.str("__trunc__");Sk.builtin.str.$write=new Sk.builtin.str("write");Sk.misceval.op2method_={Eq:Sk.builtin.str.$eq,
NotEq:Sk.builtin.str.$ne,Gt:Sk.builtin.str.$gt,GtE:Sk.builtin.str.$ge,Lt:Sk.builtin.str.$lt,LtE:Sk.builtin.str.$le}},function(E,Q,b){function f(ba,ja,na,fa,V){this.type=ba;this.string=ja;this.start=na;this.end=fa;this.line=V}function e(ba){return"("+Array.prototype.slice.call(arguments).join("|")+")"}function g(ba){return e.apply(null,arguments)+"?"}function k(ba,ja){for(var na=ba.length;na--;)if(ba[na]===ja)return!0;return!1}function p(ba){ba=ba.normalize("NFKC");return x.test(ba)}function h(){return" FR RF Br BR Fr r B R b bR f rb rB F Rf U rF u RB br fR fr rf Rb".split(" ")}
function a(ba){ba?delete Sk.token.EXACT_TOKEN_TYPES["<>"]:Sk.token.EXACT_TOKEN_TYPES["<>"]=Sk.token.tokens.T_NOTEQUAL;J=Object.keys(Sk.token.EXACT_TOKEN_TYPES).sort();P=e.apply(this,J.reverse().map(function(ja){return ja&&l.test(ja)?ja.replace(d,"\\$&"):ja}));W=e("\\r?\\n",P)}b.r(Q);E={Cc:"\\0-\\x1F\\x7F-\\x9F",Cf:"\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB",Co:"\\uE000-\\uF8FF",Cs:"\\uD800-\\uDFFF",Ll:"a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0560-\\u0588\\u10D0-\\u10FA\\u10FD-\\u10FF\\u13F8-\\u13FD\\u1C80-\\u1C88\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7AF\\uA7B5\\uA7B7\\uA7B9\\uA7BB\\uA7BD\\uA7BF\\uA7C3\\uA7C8\\uA7CA\\uA7F6\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB68\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A",
Lm:"\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3\\uAAF4\\uAB5C-\\uAB5F\\uAB69\\uFF70\\uFF9E\\uFF9F",
Lo:"\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC",
Lt:"\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC",Lu:"A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AE\\uA7B0-\\uA7B4\\uA7B6\\uA7B8\\uA7BA\\uA7BC\\uA7BE\\uA7C2\\uA7C4-\\uA7C7\\uA7C9\\uA7F5\\uFF21-\\uFF3A",
M:"\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81-\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA82C\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F",
Mc:"\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\u302E\\u302F\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uAA7D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC",
Me:"\\u0488\\u0489\\u1ABE\\u20DD-\\u20E0\\u20E2-\\u20E4\\uA670-\\uA672",Mn:"\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1ABF\\u1AC0\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F",
Nd:"0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19",
Nl:"\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF",No:"\\xB2\\xB3\\xB9\\xBC-\\xBE\\u09F4-\\u09F9\\u0B72-\\u0B77\\u0BF0-\\u0BF2\\u0C78-\\u0C7E\\u0D58-\\u0D5E\\u0D70-\\u0D78\\u0F2A-\\u0F33\\u1369-\\u137C\\u17F0-\\u17F9\\u19DA\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2150-\\u215F\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2CFD\\u3192-\\u3195\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\uA830-\\uA835",Pc:"_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F",
Pd:"\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D",Pe:"\\)\\]\\}\\u0F3B\\u0F3D\\u169C\\u2046\\u207E\\u208E\\u2309\\u230B\\u232A\\u2769\\u276B\\u276D\\u276F\\u2771\\u2773\\u2775\\u27C6\\u27E7\\u27E9\\u27EB\\u27ED\\u27EF\\u2984\\u2986\\u2988\\u298A\\u298C\\u298E\\u2990\\u2992\\u2994\\u2996\\u2998\\u29D9\\u29DB\\u29FD\\u2E23\\u2E25\\u2E27\\u2E29\\u3009\\u300B\\u300D\\u300F\\u3011\\u3015\\u3017\\u3019\\u301B\\u301E\\u301F\\uFD3E\\uFE18\\uFE36\\uFE38\\uFE3A\\uFE3C\\uFE3E\\uFE40\\uFE42\\uFE44\\uFE48\\uFE5A\\uFE5C\\uFE5E\\uFF09\\uFF3D\\uFF5D\\uFF60\\uFF63",
Pf:"\\xBB\\u2019\\u201D\\u203A\\u2E03\\u2E05\\u2E0A\\u2E0D\\u2E1D\\u2E21",Pi:"\\xAB\\u2018\\u201B\\u201C\\u201F\\u2039\\u2E02\\u2E04\\u2E09\\u2E0C\\u2E1C\\u2E20",Po:"!-#%-'\\*,\\.\\/:;\\?@\\xA1\\xA7\\xB6\\xB7\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u166E\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u1805\\u1807-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2016\\u2017\\u2020-\\u2027\\u2030-\\u2038\\u203B-\\u203E\\u2041-\\u2043\\u2047-\\u2051\\u2053\\u2055-\\u205E\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00\\u2E01\\u2E06-\\u2E08\\u2E0B\\u2E0E-\\u2E16\\u2E18\\u2E19\\u2E1B\\u2E1E\\u2E1F\\u2E2A-\\u2E2E\\u2E30-\\u2E39\\u2E3C-\\u2E3F\\u2E41\\u2E43-\\u2E4F\\u2E52\\u3001-\\u3003\\u303D\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFE10-\\uFE16\\uFE19\\uFE30\\uFE45\\uFE46\\uFE49-\\uFE4C\\uFE50-\\uFE52\\uFE54-\\uFE57\\uFE5F-\\uFE61\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF07\\uFF0A\\uFF0C\\uFF0E\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3C\\uFF61\\uFF64\\uFF65",
Ps:"\\(\\[\\{\\u0F3A\\u0F3C\\u169B\\u201A\\u201E\\u2045\\u207D\\u208D\\u2308\\u230A\\u2329\\u2768\\u276A\\u276C\\u276E\\u2770\\u2772\\u2774\\u27C5\\u27E6\\u27E8\\u27EA\\u27EC\\u27EE\\u2983\\u2985\\u2987\\u2989\\u298B\\u298D\\u298F\\u2991\\u2993\\u2995\\u2997\\u29D8\\u29DA\\u29FC\\u2E22\\u2E24\\u2E26\\u2E28\\u2E42\\u3008\\u300A\\u300C\\u300E\\u3010\\u3014\\u3016\\u3018\\u301A\\u301D\\uFD3F\\uFE17\\uFE35\\uFE37\\uFE39\\uFE3B\\uFE3D\\uFE3F\\uFE41\\uFE43\\uFE47\\uFE59\\uFE5B\\uFE5D\\uFF08\\uFF3B\\uFF5B\\uFF5F\\uFF62",
Sc:"\\$\\xA2-\\xA5\\u058F\\u060B\\u07FE\\u07FF\\u09F2\\u09F3\\u09FB\\u0AF1\\u0BF9\\u0E3F\\u17DB\\u20A0-\\u20BF\\uA838\\uFDFC\\uFE69\\uFF04\\uFFE0\\uFFE1\\uFFE5\\uFFE6",Sk:"\\^`\\xA8\\xAF\\xB4\\xB8\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0384\\u0385\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD\\u1FFE\\u309B\\u309C\\uA700-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uAB5B\\uAB6A\\uAB6B\\uFBB2-\\uFBC1\\uFF3E\\uFF40\\uFFE3",Sm:"\\+<->\\|~\\xAC\\xB1\\xD7\\xF7\\u03F6\\u0606-\\u0608\\u2044\\u2052\\u207A-\\u207C\\u208A-\\u208C\\u2118\\u2140-\\u2144\\u214B\\u2190-\\u2194\\u219A\\u219B\\u21A0\\u21A3\\u21A6\\u21AE\\u21CE\\u21CF\\u21D2\\u21D4\\u21F4-\\u22FF\\u2320\\u2321\\u237C\\u239B-\\u23B3\\u23DC-\\u23E1\\u25B7\\u25C1\\u25F8-\\u25FF\\u266F\\u27C0-\\u27C4\\u27C7-\\u27E5\\u27F0-\\u27FF\\u2900-\\u2982\\u2999-\\u29D7\\u29DC-\\u29FB\\u29FE-\\u2AFF\\u2B30-\\u2B44\\u2B47-\\u2B4C\\uFB29\\uFE62\\uFE64-\\uFE66\\uFF0B\\uFF1C-\\uFF1E\\uFF5C\\uFF5E\\uFFE2\\uFFE9-\\uFFEC",
So:"\\xA6\\xA9\\xAE\\xB0\\u0482\\u058D\\u058E\\u060E\\u060F\\u06DE\\u06E9\\u06FD\\u06FE\\u07F6\\u09FA\\u0B70\\u0BF3-\\u0BF8\\u0BFA\\u0C7F\\u0D4F\\u0D79\\u0F01-\\u0F03\\u0F13\\u0F15-\\u0F17\\u0F1A-\\u0F1F\\u0F34\\u0F36\\u0F38\\u0FBE-\\u0FC5\\u0FC7-\\u0FCC\\u0FCE\\u0FCF\\u0FD5-\\u0FD8\\u109E\\u109F\\u1390-\\u1399\\u166D\\u1940\\u19DE-\\u19FF\\u1B61-\\u1B6A\\u1B74-\\u1B7C\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116\\u2117\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u214A\\u214C\\u214D\\u214F\\u218A\\u218B\\u2195-\\u2199\\u219C-\\u219F\\u21A1\\u21A2\\u21A4\\u21A5\\u21A7-\\u21AD\\u21AF-\\u21CD\\u21D0\\u21D1\\u21D3\\u21D5-\\u21F3\\u2300-\\u2307\\u230C-\\u231F\\u2322-\\u2328\\u232B-\\u237B\\u237D-\\u239A\\u23B4-\\u23DB\\u23E2-\\u2426\\u2440-\\u244A\\u249C-\\u24E9\\u2500-\\u25B6\\u25B8-\\u25C0\\u25C2-\\u25F7\\u2600-\\u266E\\u2670-\\u2767\\u2794-\\u27BF\\u2800-\\u28FF\\u2B00-\\u2B2F\\u2B45\\u2B46\\u2B4D-\\u2B73\\u2B76-\\u2B95\\u2B97-\\u2BFF\\u2CE5-\\u2CEA\\u2E50\\u2E51\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303E\\u303F\\u3190\\u3191\\u3196-\\u319F\\u31C0-\\u31E3\\u3200-\\u321E\\u322A-\\u3247\\u3250\\u3260-\\u327F\\u328A-\\u32B0\\u32C0-\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA828-\\uA82B\\uA836\\uA837\\uA839\\uAA77-\\uAA79\\uFDFD\\uFFE4\\uFFE8\\uFFED\\uFFEE\\uFFFC\\uFFFD",
Zl:"\\u2028",Zp:"\\u2029",Zs:" \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000"};E.C=E.Cc+E.Cf+E.Cs+E.Co;E.L=E.Lu+E.Ll+E.Lt+E.Lm+E.Mn+E.Lo;E.LC=E.Lu+E.Ll+E.Lt;E.M=E.Mn+E.Mc+E.Me;E.N=E.Nd+E.Nl+E.No;E.P=E.Pc+E.Pd+E.Ps+E.Pe+E.Pi+E.Pf+E.Po;E.S=E.Sm+E.Sc+E.Sk+E.So;E.Z=E.Zs+E.Zl+E.Zp;E.w="_"+E.L+E.N;E.b="(?:["+E.w+"](?:[^"+E.w+"]|$)|(?:^|[^"+E.w+"])["+E.w+"])";E.bOut="(?=[^"+E.w+"]|$)";E.bIn="(?:^|[^"+E.w+"])";E.bInCapture="(?:^|([^"+E.w+"]))";E.B="(?:["+E.w+"]["+E.w+"]|[^"+E.w+"][^"+E.w+"])";E.d=E.N;
var c=Sk.token.tokens;const m=Sk.builtin.SyntaxError,n=Sk.builtin.SyntaxError;f.prototype.exact_type=function(){return this.type==c.T_OP&&this.string in Sk.token.EXACT_TOKEN_TYPES?Sk.token.EXACT_TOKEN_TYPES[this.string]:this.type};var d=/[\\^$.*+?()[\]{}|]/g,l=RegExp(d.source);const {Lu:r,Ll:v,Lt:q,Lm:t,Lo:w,Nl:C,Mn:D,Mc:L,Nd:N,Pc:A}=E;E=r+v+q+t+w+C+"_\\u1885-\\u1886\\u2118\\u212E\\u309B-\\u309C";const H="["+E+"]+["+(E+D+L+N+A+"\\u00B7\\u0387\\u1369-\\u1371\\u19DA]*"),x=new RegExp("^"+H+"$");Sk.token.isIdentifier=
p;(function(ba){return e.apply(null,arguments)+"*"})("\\\\\\r?\\n[ \\f\\t]*");g("#[^\\r\\n]*");E=e("[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?","\\.[0-9](?:_?[0-9])*")+g("[eE][-+]?[0-9](?:_?[0-9])*");var B=e(E,"[0-9](?:_?[0-9])*[eE][-+]?[0-9](?:_?[0-9])*"),F=e("[0-9](?:_?[0-9])*[jJ]",B+"[jJ]");E=e.apply(null,h());Q=e(E+"'''",E+'"""');e(E+"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'",E+'"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');var J,P,W;a(!0);Sk.token.setupTokens=a;var ca=e(E+"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*"+
e("'","\\\\\\r?\\n"),E+'"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*'+e('"',"\\\\\\r?\\n")),ha=e("\\\\\\r?\\n|$","#[^\\r\\n]*",Q),oa={};E=h();for(let ba of E)oa[ba+"'"]="^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'",oa[ba+'"']='^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"',oa[ba+"'''"]="^[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''",oa[ba+'"""']='^[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';let ka=[],ia=[];for(let ba of E)ka.push(ba+'"'),ka.push(ba+"'"),ia.push(ba+'"""'),ia.push(ba+"'''");Sk._tokenize=function(ba,ja,na,fa){var V=Sk.__future__.python3?
"":"(?:L?)";V=e("0[xX](?:_?[0-9a-fA-F])+"+V,"0[bB](?:_?[01])+"+V,Sk.__future__.silent_octal_literal?"0([oO]?)(?:_?[0-7])+"+V:"0([oO])(?:_?[0-7])+"+V,"(?:0(?:_?0)*|[1-9](?:_?[0-9])*)"+V);V=e(F,B,V);V="[ \\f\\t]*"+e(ha,V,W,ca,H);V=new RegExp(V);var la=0,O=0,T=0,Y="",da=0,qa=null,pa=[0],z,u=void 0,y=void 0,G,K;void 0!==na&&("utf-8-sig"==na&&(na="utf-8"),fa(new f(c.T_ENCODING,na,[0,0],[0,0],"")));for(var I=na="";;){try{na=I,I=ja()}catch(X){I=""}la+=1;var M=0,R=I.length;if(Y){if(!I)throw new m("EOF in multi-line string",
ba,y[0],y[1]);u.lastIndex=0;var U=u.exec(I);if(U)M=G=U[0].length,fa(new f(c.T_STRING,Y+I.substring(0,G),y,[la,G],qa+I)),Y="",da=0,qa=null;else{da&&"\\\n"!==I.substring(I.length-2)&&"\\\r\n"!==I.substring(I.length-3)?(fa(new f(c.T_ERRORTOKEN,Y+I,y,[la,I.length],qa)),Y="",qa=null):(Y+=I,qa+=I);continue}}else if(0!=O||T){if(!I)throw new m("EOF in multi-line statement",ba,la,0);T=0}else{if(!I)break;for(z=0;M<R;){if(" "==I[M])z+=1;else if("\t"==I[M])z=8*Math.floor(z/8+1);else if("\f"==I[M])z=0;else break;
M+=1}if(M==R)break;if(k("#\r\n",I[M])){if("#"==I[M]){z=I.substring(M);for(R=z.length;0<R&&-1!=="\r\n".indexOf(z.charAt(R-1));--R);R=z.substring(0,R);fa(new f(c.T_COMMENT,R,[la,M],[la,M+R.length],I));M+=R.length}fa(new f(c.T_NL,I.substring(M),[la,M],[la,I.length],I));continue}z>pa[pa.length-1]&&(pa.push(z),fa(new f(c.T_INDENT,I.substring(M),[la,0],[la,M],I)));for(;z<pa[pa.length-1];){if(!k(pa,z))throw new n("unindent does not match any outer indentation level",ba,la,M);pa=pa.slice(0,-1);fa(new f(c.T_DEDENT,
"",[la,M],[la,M],I))}}for(;M<R;){for(z=I.charAt(M);" "===z||"\f"===z||"\t"===z;)M+=1,z=I.charAt(M);if(K=V.exec(I.substring(M))){if(z=M,G=z+K[1].length,K=[la,z],U=[la,G],M=G,z!=G){G=I.substring(z,G);var S=I[z];if(k("0123456789",S)||"."==S&&"."!=G&&"..."!=G)fa(new f(c.T_NUMBER,G,K,U,I));else if(k("\r\n",S))0<O?fa(new f(c.T_NL,G,K,U,I)):fa(new f(c.T_NEWLINE,G,K,U,I));else if("#"==S)fa(new f(c.T_COMMENT,G,K,U,I));else if(k(ia,G))if(u=RegExp(oa[G]),U=u.exec(I.substring(M)))M=U[0].length+M,G=I.substring(z,
M),fa(new f(c.T_STRING,G,K,[la,M],I));else{y=[la,z];Y=I.substring(z);qa=I;break}else if(k(ka,S)||k(ka,G.substring(0,2))||k(ka,G.substring(0,3)))if("\n"==G[G.length-1]){y=[la,z];u=RegExp(oa[S]||oa[G[1]]||oa[G[2]]);Y=I.substring(z);da=1;qa=I;break}else fa(new f(c.T_STRING,G,K,U,I));else p(S)?fa(new f(c.T_NAME,G,K,U,I)):"\\"==S?T=1:(k("([{",S)?O+=1:k(")]}",S)&&--O,fa(new f(c.T_OP,G,K,U,I)))}}else fa(new f(c.T_ERRORTOKEN,I[M],[la,M],[la,M+1],I)),M+=1}}na&&!k("\r\n",na[na.length-1])&&fa(new f(c.T_NEWLINE,
"",[la-1,na.length],[la-1,na.length+1],""));for(var Z in pa.slice(1))fa(new f(c.T_DEDENT,"",[la,0],[la,0],""));fa(new f(c.T_ENDMARKER,"",[la,0],[la,0],""))};Sk._tokenize.Floatnumber=B;Sk.exportSymbol("Sk._tokenize",Sk._tokenize)}]);}).call(this || window)

//# sourceMappingURL=skulpt.min.js.map

/***/ }),

/***/ 12797:
/*!*****************************************************!*\
  !*** ./runestone/activecode/js/timed_activecode.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimedActiveCode": () => (/* binding */ TimedActiveCode),
/* harmony export */   "TimedHTMLActiveCode": () => (/* binding */ TimedHTMLActiveCode),
/* harmony export */   "TimedJSActiveCode": () => (/* binding */ TimedJSActiveCode),
/* harmony export */   "TimedLiveCode": () => (/* binding */ TimedLiveCode),
/* harmony export */   "TimedSQLActiveCode": () => (/* binding */ TimedSQLActiveCode)
/* harmony export */ });
/* harmony import */ var _livecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./livecode */ 45425);
/* harmony import */ var _activecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activecode */ 750);
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode_js */ 40653);
/* harmony import */ var _activecode_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode_html */ 15033);
/* harmony import */ var _activecode_sql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activecode_sql */ 23538);
/*
The TimedActivecode classes are a great example of where multiple inheritance would be useful
But since Javascript does not support multiple inheritance we use the mixin pattern.

*/






var TimedActiveCodeMixin = {
    timedInit: async function (opts) {
        this.isTimed = true;
        this.hideButtons();
        this.needsReinitialization = true; // the run button click listener needs to be reinitialized
        this.containerDiv.classList.add("timedComponent");
        window.edList[this.divid] = this;
        return true;
    },

    hideButtons: function () {
        var buttonList = [
            this.saveButton,
            this.loadButton,
            this.gradeButton,
            this.showHideButt,
            this.coachButton,
            this.atButton,
        ];
        for (var i = 0; i < buttonList.length; i++) {
            if (buttonList[i] !== undefined && buttonList[i] !== null)
                $(buttonList[i]).hide();
        }
    },

    // bje - not needed anymore
    renderTimedIcon: function (component) {
        // renders the clock icon on timed components.    The component parameter
        // is the element that the icon should be appended to.
        var timeIconDiv = document.createElement("div");
        var timeIcon = document.createElement("img");
        $(timeIcon).attr({
            src: "../_static/clock.png",
            style: "width:15px;height:15px",
        });
        timeIconDiv.className = "timeTip";
        timeIconDiv.title = "";
        timeIconDiv.appendChild(timeIcon);
        $(component).prepend(timeIconDiv);
    },

    checkCorrectTimed: function () {
        // pct_correct is set by the unittest/gui.py module in skulpt.
        // it relies on finding this object in the edList
        if (this.isAnswered) {
            if (this.pct_correct >= 100.0) {
                return "T";
            } else {
                return "F";
            }
        } else {
            return "I"; // we ignore this in the grading if no unittests
        }
    },

    hideFeedback: function () {
        $(this.output).css("visibility", "hidden");
    },

    reinitializeListeners: function (taken) {
        if (!this.runButton.onclick) {
            console.log("reattaching runbuttonhandler");
            this.runButton.onclick = this.runButtonHander.bind(this);
        }
        $(this.codeDiv).show();
        this.runButton.disabled = false;
        $(this.codeDiv).removeClass("ac-disabled");
        this.editor.refresh();
        if (this.historyScrubber !== null) {
            $(this.historyScrubber).slider({
                max: this.history.length - 1,
                value: this.history.length - 1,
                slide: this.slideit.bind(this),
                change: this.slideit.bind(this),
            });
        }
        if (taken) {
            $(`#${this.divid}_unit_results`).show();
        }
    },
};

class TimedLiveCode extends _livecode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}

Object.assign(TimedLiveCode.prototype, TimedActiveCodeMixin);

class TimedActiveCode extends _activecode__WEBPACK_IMPORTED_MODULE_1__.ActiveCode {
    constructor(opts) {
        super(opts);
        this.timedInitComplete = this.timedInit(opts);
    }

    // for timed exams we need to call runProg and tell it that there is
    // no GUI for sliders or other things.
    // the answers.
    async checkCurrentAnswer() {
        let noUI = true;
        const result = await this.timedInitComplete;
        if (this.isAnswered) {
            await this.runProg(noUI, false);
        }
    }
}

Object.assign(TimedActiveCode.prototype, TimedActiveCodeMixin);

class TimedJSActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedJSActiveCode.prototype, TimedActiveCodeMixin);

class TimedHTMLActiveCode extends _activecode_html__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedHTMLActiveCode.prototype, TimedActiveCodeMixin);

class TimedSQLActiveCode extends _activecode_sql__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedSQLActiveCode.prototype, TimedActiveCodeMixin);


/***/ }),

/***/ 33194:
/*!*************************************************!*\
  !*** ./runestone/common/js/jquery.highlight.js ***!
  \*************************************************/
/***/ (() => {

/*

highlight v4

Highlights arbitrary terms.

<http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html>

MIT license.

Johann Burkard
<http://johannburkard.de>
<mailto:jb@eaio.com>

*/

jQuery.fn.highlight = function(pat) {
 function innerHighlight(node, pat) {
  var skip = 0;
  if (node.nodeType == 3) {
   var pos = node.data.toUpperCase().indexOf(pat);
   if (pos >= 0) {
    var spannode = document.createElement('span');
    spannode.className = 'highlight';
    var middlebit = node.splitText(pos);
    var endbit = middlebit.splitText(pat.length);
    var middleclone = middlebit.cloneNode(true);
    spannode.appendChild(middleclone);
    middlebit.parentNode.replaceChild(spannode, middlebit);
    skip = 1;
   }
  }
  else if (node.nodeType == 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
   for (var i = 0; i < node.childNodes.length; ++i) {
    i += innerHighlight(node.childNodes[i], pat);
   }
  }
  return skip;
 }
 return this.length && pat && pat.length ? this.each(function() {
  innerHighlight(this, pat.toUpperCase());
 }) : this;
};

jQuery.fn.removeHighlight = function() {
 return this.find("span.highlight").each(function() {
  this.parentNode.firstChild.nodeName;
  with (this.parentNode) {
   replaceChild(this.firstChild, this);
   normalize();
  }
 }).end();
};


/***/ }),

/***/ 37607:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 70803:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 59547:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 16449:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 23516:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX21vbWVudF9sb2NhbGVfc3luY19yZWN1cnNpdmVfLXJ1bmVzdG9uZV9hY3RpdmVjb2RlX2pzX2FjZmFjdG9yeV9qcy1ub2RlX21vZHVsZXNfLWVmNzNiMy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25RNkM7QUFDQztBQUNJO0FBQ0Y7QUFDWDtBQU9UO0FBQ2lCOztBQUU5QjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFlO0FBQzFDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFhO0FBQ3hDLGNBQWM7QUFDZCwyQkFBMkIsZ0VBQWlCO0FBQzVDLGNBQWM7QUFDZCwyQkFBMkIsa0VBQW1CO0FBQzlDLGNBQWM7QUFDZCwyQkFBMkIsaUVBQWtCO0FBQzdDLGNBQWM7QUFDZCwyQkFBMkIsOERBQWU7QUFDMUM7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwyQkFBMkIseURBQVk7QUFDdkMsY0FBYztBQUNkLDJCQUEyQiwyREFBYztBQUN6QyxjQUFjO0FBQ2QsMkJBQTJCLDBEQUFhO0FBQ3hDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBUTtBQUNuQyxjQUFjO0FBQ2Q7QUFDQSwyQkFBMkIsc0RBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQsNEJBQTRCLE1BQU07QUFDbEMsOERBQThELEtBQUssSUFBSSxNQUFNOzs7OztBQUs3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtFQUFrRTtBQUNsRSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNyTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUpBQXlKO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7Ozs7Ozs7OztBQ3JIRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7Ozs7Ozs7Ozs7O0FDckhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUVnRDtBQUN0QjtBQUNOO0FBQ0c7QUFDRTtBQUNGO0FBQ007QUFDTjtBQUNZO0FBQ1o7QUFDYztBQUNkO0FBQ0k7QUFDRTtBQUNUO0FBQ007QUFDSztBQUNDO0FBQ0Y7QUFDSTtBQUNDO0FBQ3ZCO0FBQ0c7QUFDNUI7QUFDK0I7QUFDL0I7QUFDQSxtQkFBbUIsbURBQUs7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUVBQWdDO0FBQ2hDLGtCQUFrQixNQUFNLGdFQUF1QixFQUFFO0FBQ2pEOztBQUVBO0FBQ08seUJBQXlCLG1FQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOENBQThDLEdBQUc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CO0FBQ2xFLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsd0RBQXdELEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRLElBQUksU0FBUyxLQUFLLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSSxJQUFJLFNBQVMsS0FBSyxNQUFNO0FBQy9EO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxHQUFHLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFlBQVk7QUFDOUY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEMsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbjhDNkM7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7Ozs7Ozs7QUNwREE7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQSIsInNvdXJjZXMiOlsid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9jc3MvYWN0aXZlY29kZS5jc3M/YThiMiIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvIHN5bmMgXlxcLlxcLy4qJCIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWNmYWN0b3J5LmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY3RpdmVjb2RlLWkxOG4uZW4uanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGUtaTE4bi5wdC1ici5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZS1pMThuLnNyLUN5cmwuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGUuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGVfaHRtbC5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZV9qcy5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZV9zcWwuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2F1ZGlvdG91ci5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvZXh0cmFjdFVuaXRSZXN1bHRzLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9saXZlY29kZS5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvbWQ1LmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9za3VscHQtc3RkbGliLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9za3VscHQubWluLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy90aW1lZF9hY3RpdmVjb2RlLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvY29tbW9uL2pzL2pxdWVyeS5oaWdobGlnaHQuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy9pZ25vcmVkfC9Vc2Vycy93YWx0b25kYi9EZXZlbG9wZXIvUnVuZXN0b25lQ29tcG9uZW50cy9ub2RlX21vZHVsZXMvc3FsLmpzL2Rpc3R8Y3J5cHRvIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvVXNlcnMvd2FsdG9uZGIvRGV2ZWxvcGVyL1J1bmVzdG9uZUNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3NxbC5qcy9kaXN0fGZzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvVXNlcnMvd2FsdG9uZGIvRGV2ZWxvcGVyL1J1bmVzdG9uZUNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3NxbC5qcy9kaXN0fHBhdGgiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy9pZ25vcmVkfC9Vc2Vycy93YWx0b25kYi9EZXZlbG9wZXIvUnVuZXN0b25lQ29tcG9uZW50cy9ub2RlX21vZHVsZXMvdmVnYS1sb2FkZXIvc3JjfGZzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvVXNlcnMvd2FsdG9uZGIvRGV2ZWxvcGVyL1J1bmVzdG9uZUNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3ZlZ2EtbG9hZGVyL3NyY3xub2RlLWZldGNoIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsInZhciBtYXAgPSB7XG5cdFwiLi9hZlwiOiA0Mjc4Nixcblx0XCIuL2FmLmpzXCI6IDQyNzg2LFxuXHRcIi4vYXJcIjogMzA4NjcsXG5cdFwiLi9hci1kelwiOiAxNDEzMCxcblx0XCIuL2FyLWR6LmpzXCI6IDE0MTMwLFxuXHRcIi4vYXIta3dcIjogOTYxMzUsXG5cdFwiLi9hci1rdy5qc1wiOiA5NjEzNSxcblx0XCIuL2FyLWx5XCI6IDU2NDQwLFxuXHRcIi4vYXItbHkuanNcIjogNTY0NDAsXG5cdFwiLi9hci1tYVwiOiA0NzcwMixcblx0XCIuL2FyLW1hLmpzXCI6IDQ3NzAyLFxuXHRcIi4vYXItc2FcIjogMTYwNDAsXG5cdFwiLi9hci1zYS5qc1wiOiAxNjA0MCxcblx0XCIuL2FyLXRuXCI6IDM3MTAwLFxuXHRcIi4vYXItdG4uanNcIjogMzcxMDAsXG5cdFwiLi9hci5qc1wiOiAzMDg2Nyxcblx0XCIuL2F6XCI6IDMxMDgzLFxuXHRcIi4vYXouanNcIjogMzEwODMsXG5cdFwiLi9iZVwiOiA5ODA4LFxuXHRcIi4vYmUuanNcIjogOTgwOCxcblx0XCIuL2JnXCI6IDY4MzM4LFxuXHRcIi4vYmcuanNcIjogNjgzMzgsXG5cdFwiLi9ibVwiOiA2NzQzOCxcblx0XCIuL2JtLmpzXCI6IDY3NDM4LFxuXHRcIi4vYm5cIjogODkwNSxcblx0XCIuL2JuLmpzXCI6IDg5MDUsXG5cdFwiLi9ib1wiOiAxMTU2MCxcblx0XCIuL2JvLmpzXCI6IDExNTYwLFxuXHRcIi4vYnJcIjogMTI3OCxcblx0XCIuL2JyLmpzXCI6IDEyNzgsXG5cdFwiLi9ic1wiOiA4MDYyMixcblx0XCIuL2JzLmpzXCI6IDgwNjIyLFxuXHRcIi4vY2FcIjogMjQ2OCxcblx0XCIuL2NhLmpzXCI6IDI0NjgsXG5cdFwiLi9jc1wiOiA1ODIyLFxuXHRcIi4vY3MuanNcIjogNTgyMixcblx0XCIuL2N2XCI6IDUwODc3LFxuXHRcIi4vY3YuanNcIjogNTA4NzcsXG5cdFwiLi9jeVwiOiA0NzM3Myxcblx0XCIuL2N5LmpzXCI6IDQ3MzczLFxuXHRcIi4vZGFcIjogMjQ3ODAsXG5cdFwiLi9kYS5qc1wiOiAyNDc4MCxcblx0XCIuL2RlXCI6IDU5NzQwLFxuXHRcIi4vZGUtYXRcIjogNjAyMTcsXG5cdFwiLi9kZS1hdC5qc1wiOiA2MDIxNyxcblx0XCIuL2RlLWNoXCI6IDYwODk0LFxuXHRcIi4vZGUtY2guanNcIjogNjA4OTQsXG5cdFwiLi9kZS5qc1wiOiA1OTc0MCxcblx0XCIuL2R2XCI6IDUzMDAsXG5cdFwiLi9kdi5qc1wiOiA1MzAwLFxuXHRcIi4vZWxcIjogNTA4MzcsXG5cdFwiLi9lbC5qc1wiOiA1MDgzNyxcblx0XCIuL2VuLWF1XCI6IDc4MzQ4LFxuXHRcIi4vZW4tYXUuanNcIjogNzgzNDgsXG5cdFwiLi9lbi1jYVwiOiA3NzkyNSxcblx0XCIuL2VuLWNhLmpzXCI6IDc3OTI1LFxuXHRcIi4vZW4tZ2JcIjogMjIyNDMsXG5cdFwiLi9lbi1nYi5qc1wiOiAyMjI0Myxcblx0XCIuL2VuLWllXCI6IDQ2NDM2LFxuXHRcIi4vZW4taWUuanNcIjogNDY0MzYsXG5cdFwiLi9lbi1uelwiOiA3NjMxOSxcblx0XCIuL2VuLW56LmpzXCI6IDc2MzE5LFxuXHRcIi4vZW9cIjogOTI5MTUsXG5cdFwiLi9lby5qc1wiOiA5MjkxNSxcblx0XCIuL2VzXCI6IDU1NjU1LFxuXHRcIi4vZXMtZG9cIjogNTUyNTEsXG5cdFwiLi9lcy1kby5qc1wiOiA1NTI1MSxcblx0XCIuL2VzLXVzXCI6IDcxMTQ2LFxuXHRcIi4vZXMtdXMuanNcIjogNzExNDYsXG5cdFwiLi9lcy5qc1wiOiA1NTY1NSxcblx0XCIuL2V0XCI6IDU2MDMsXG5cdFwiLi9ldC5qc1wiOiA1NjAzLFxuXHRcIi4vZXVcIjogNzc3NjMsXG5cdFwiLi9ldS5qc1wiOiA3Nzc2Myxcblx0XCIuL2ZhXCI6IDc2OTU5LFxuXHRcIi4vZmEuanNcIjogNzY5NTksXG5cdFwiLi9maVwiOiAxMTg5Nyxcblx0XCIuL2ZpLmpzXCI6IDExODk3LFxuXHRcIi4vZm9cIjogOTQ2OTQsXG5cdFwiLi9mby5qc1wiOiA5NDY5NCxcblx0XCIuL2ZyXCI6IDk0NDcwLFxuXHRcIi4vZnItY2FcIjogNjMwNDksXG5cdFwiLi9mci1jYS5qc1wiOiA2MzA0OSxcblx0XCIuL2ZyLWNoXCI6IDUyMzMwLFxuXHRcIi4vZnItY2guanNcIjogNTIzMzAsXG5cdFwiLi9mci5qc1wiOiA5NDQ3MCxcblx0XCIuL2Z5XCI6IDUwNDQsXG5cdFwiLi9meS5qc1wiOiA1MDQ0LFxuXHRcIi4vZ2RcIjogMjEwMSxcblx0XCIuL2dkLmpzXCI6IDIxMDEsXG5cdFwiLi9nbFwiOiAzODc5NCxcblx0XCIuL2dsLmpzXCI6IDM4Nzk0LFxuXHRcIi4vZ29tLWxhdG5cIjogMjMxNjgsXG5cdFwiLi9nb20tbGF0bi5qc1wiOiAyMzE2OCxcblx0XCIuL2d1XCI6IDk1MzQ5LFxuXHRcIi4vZ3UuanNcIjogOTUzNDksXG5cdFwiLi9oZVwiOiAyNDIwNixcblx0XCIuL2hlLmpzXCI6IDI0MjA2LFxuXHRcIi4vaGlcIjogMzAwOTQsXG5cdFwiLi9oaS5qc1wiOiAzMDA5NCxcblx0XCIuL2hyXCI6IDMwMzE2LFxuXHRcIi4vaHIuanNcIjogMzAzMTYsXG5cdFwiLi9odVwiOiAyMjEzOCxcblx0XCIuL2h1LmpzXCI6IDIyMTM4LFxuXHRcIi4vaHktYW1cIjogMTE0MjMsXG5cdFwiLi9oeS1hbS5qc1wiOiAxMTQyMyxcblx0XCIuL2lkXCI6IDI5MjE4LFxuXHRcIi4vaWQuanNcIjogMjkyMTgsXG5cdFwiLi9pc1wiOiA5MDEzNSxcblx0XCIuL2lzLmpzXCI6IDkwMTM1LFxuXHRcIi4vaXRcIjogOTA2MjYsXG5cdFwiLi9pdC5qc1wiOiA5MDYyNixcblx0XCIuL2phXCI6IDM5MTgzLFxuXHRcIi4vamEuanNcIjogMzkxODMsXG5cdFwiLi9qdlwiOiAyNDI4Nixcblx0XCIuL2p2LmpzXCI6IDI0Mjg2LFxuXHRcIi4va2FcIjogNDA0MTUsXG5cdFwiLi9rYS5qc1wiOiA0MDQxNSxcblx0XCIuL2trXCI6IDQ3NzcyLFxuXHRcIi4va2suanNcIjogNDc3NzIsXG5cdFwiLi9rbVwiOiAxODc1OCxcblx0XCIuL2ttLmpzXCI6IDE4NzU4LFxuXHRcIi4va25cIjogNzkyODIsXG5cdFwiLi9rbi5qc1wiOiA3OTI4Mixcblx0XCIuL2tvXCI6IDMzNzMwLFxuXHRcIi4va28uanNcIjogMzM3MzAsXG5cdFwiLi9reVwiOiAzMzI5MSxcblx0XCIuL2t5LmpzXCI6IDMzMjkxLFxuXHRcIi4vbGJcIjogMzY4NDEsXG5cdFwiLi9sYi5qc1wiOiAzNjg0MSxcblx0XCIuL2xvXCI6IDU1NDY2LFxuXHRcIi4vbG8uanNcIjogNTU0NjYsXG5cdFwiLi9sdFwiOiA1NzAxMCxcblx0XCIuL2x0LmpzXCI6IDU3MDEwLFxuXHRcIi4vbHZcIjogMzc1OTUsXG5cdFwiLi9sdi5qc1wiOiAzNzU5NSxcblx0XCIuL21lXCI6IDM5ODYxLFxuXHRcIi4vbWUuanNcIjogMzk4NjEsXG5cdFwiLi9taVwiOiAzNTQ5Myxcblx0XCIuL21pLmpzXCI6IDM1NDkzLFxuXHRcIi4vbWtcIjogOTU5NjYsXG5cdFwiLi9tay5qc1wiOiA5NTk2Nixcblx0XCIuL21sXCI6IDg3MzQxLFxuXHRcIi4vbWwuanNcIjogODczNDEsXG5cdFwiLi9tclwiOiAxMDM3MCxcblx0XCIuL21yLmpzXCI6IDEwMzcwLFxuXHRcIi4vbXNcIjogOTg0Nyxcblx0XCIuL21zLW15XCI6IDQxMjM3LFxuXHRcIi4vbXMtbXkuanNcIjogNDEyMzcsXG5cdFwiLi9tcy5qc1wiOiA5ODQ3LFxuXHRcIi4vbXRcIjogNzIxMjYsXG5cdFwiLi9tdC5qc1wiOiA3MjEyNixcblx0XCIuL215XCI6IDU2MTY1LFxuXHRcIi4vbXkuanNcIjogNTYxNjUsXG5cdFwiLi9uYlwiOiA2NDkyNCxcblx0XCIuL25iLmpzXCI6IDY0OTI0LFxuXHRcIi4vbmVcIjogMTY3NDQsXG5cdFwiLi9uZS5qc1wiOiAxNjc0NCxcblx0XCIuL25sXCI6IDkzOTAxLFxuXHRcIi4vbmwtYmVcIjogNTk4MTQsXG5cdFwiLi9ubC1iZS5qc1wiOiA1OTgxNCxcblx0XCIuL25sLmpzXCI6IDkzOTAxLFxuXHRcIi4vbm5cIjogODM4NzcsXG5cdFwiLi9ubi5qc1wiOiA4Mzg3Nyxcblx0XCIuL3BhLWluXCI6IDE1ODU4LFxuXHRcIi4vcGEtaW4uanNcIjogMTU4NTgsXG5cdFwiLi9wbFwiOiA2NDQ5NSxcblx0XCIuL3BsLmpzXCI6IDY0NDk1LFxuXHRcIi4vcHRcIjogODk1MjAsXG5cdFwiLi9wdC1iclwiOiA1Nzk3MSxcblx0XCIuL3B0LWJyLmpzXCI6IDU3OTcxLFxuXHRcIi4vcHQuanNcIjogODk1MjAsXG5cdFwiLi9yb1wiOiA5NjQ1OSxcblx0XCIuL3JvLmpzXCI6IDk2NDU5LFxuXHRcIi4vcnVcIjogMjE3OTMsXG5cdFwiLi9ydS5qc1wiOiAyMTc5Myxcblx0XCIuL3NkXCI6IDQwOTUwLFxuXHRcIi4vc2QuanNcIjogNDA5NTAsXG5cdFwiLi9zZVwiOiAxMDQ5MCxcblx0XCIuL3NlLmpzXCI6IDEwNDkwLFxuXHRcIi4vc2lcIjogOTAxMjQsXG5cdFwiLi9zaS5qc1wiOiA5MDEyNCxcblx0XCIuL3NrXCI6IDY0MjQ5LFxuXHRcIi4vc2suanNcIjogNjQyNDksXG5cdFwiLi9zbFwiOiAxNDk4NSxcblx0XCIuL3NsLmpzXCI6IDE0OTg1LFxuXHRcIi4vc3FcIjogNTExMDQsXG5cdFwiLi9zcS5qc1wiOiA1MTEwNCxcblx0XCIuL3NyXCI6IDQ5MTMxLFxuXHRcIi4vc3ItY3lybFwiOiAxMzcwOSxcblx0XCIuL3NyLWN5cmwuanNcIjogMTM3MDksXG5cdFwiLi9zci5qc1wiOiA0OTEzMSxcblx0XCIuL3NzXCI6IDg1ODkzLFxuXHRcIi4vc3MuanNcIjogODU4OTMsXG5cdFwiLi9zdlwiOiA5ODc2MCxcblx0XCIuL3N2LmpzXCI6IDk4NzYwLFxuXHRcIi4vc3dcIjogOTExNzIsXG5cdFwiLi9zdy5qc1wiOiA5MTE3Mixcblx0XCIuL3RhXCI6IDI3MzMzLFxuXHRcIi4vdGEuanNcIjogMjczMzMsXG5cdFwiLi90ZVwiOiAyMzExMCxcblx0XCIuL3RlLmpzXCI6IDIzMTEwLFxuXHRcIi4vdGV0XCI6IDUyMDk1LFxuXHRcIi4vdGV0LmpzXCI6IDUyMDk1LFxuXHRcIi4vdGhcIjogOTA0MSxcblx0XCIuL3RoLmpzXCI6IDkwNDEsXG5cdFwiLi90bC1waFwiOiA3NTc2OCxcblx0XCIuL3RsLXBoLmpzXCI6IDc1NzY4LFxuXHRcIi4vdGxoXCI6IDg5NDQ0LFxuXHRcIi4vdGxoLmpzXCI6IDg5NDQ0LFxuXHRcIi4vdHJcIjogNzIzOTcsXG5cdFwiLi90ci5qc1wiOiA3MjM5Nyxcblx0XCIuL3R6bFwiOiAyODI1NCxcblx0XCIuL3R6bC5qc1wiOiAyODI1NCxcblx0XCIuL3R6bVwiOiA1MTEwNixcblx0XCIuL3R6bS1sYXRuXCI6IDMwNjk5LFxuXHRcIi4vdHptLWxhdG4uanNcIjogMzA2OTksXG5cdFwiLi90em0uanNcIjogNTExMDYsXG5cdFwiLi91a1wiOiA2NzY5MSxcblx0XCIuL3VrLmpzXCI6IDY3NjkxLFxuXHRcIi4vdXJcIjogMTM3OTUsXG5cdFwiLi91ci5qc1wiOiAxMzc5NSxcblx0XCIuL3V6XCI6IDY3OTEsXG5cdFwiLi91ei1sYXRuXCI6IDYwNTg4LFxuXHRcIi4vdXotbGF0bi5qc1wiOiA2MDU4OCxcblx0XCIuL3V6LmpzXCI6IDY3OTEsXG5cdFwiLi92aVwiOiA2NTY2Nixcblx0XCIuL3ZpLmpzXCI6IDY1NjY2LFxuXHRcIi4veC1wc2V1ZG9cIjogMTQzNzgsXG5cdFwiLi94LXBzZXVkby5qc1wiOiAxNDM3OCxcblx0XCIuL3lvXCI6IDc1ODA1LFxuXHRcIi4veW8uanNcIjogNzU4MDUsXG5cdFwiLi96aC1jblwiOiA4MzgzOSxcblx0XCIuL3poLWNuLmpzXCI6IDgzODM5LFxuXHRcIi4vemgtaGtcIjogNTU3MjYsXG5cdFwiLi96aC1oay5qc1wiOiA1NTcyNixcblx0XCIuL3poLXR3XCI6IDc0MTUyLFxuXHRcIi4vemgtdHcuanNcIjogNzQxNTJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSA0NjcwMDsiLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xuaW1wb3J0IEpTQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX2pzLmpzXCI7XG5pbXBvcnQgSFRNTEFjdGl2ZUNvZGUgZnJvbSBcIi4vYWN0aXZlY29kZV9odG1sLmpzXCI7XG5pbXBvcnQgU1FMQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX3NxbC5qc1wiO1xuaW1wb3J0IExpdmVDb2RlIGZyb20gXCIuL2xpdmVjb2RlLmpzXCI7XG5pbXBvcnQge1xuICAgIFRpbWVkQWN0aXZlQ29kZSxcbiAgICBUaW1lZExpdmVDb2RlLFxuICAgIFRpbWVkSlNBY3RpdmVDb2RlLFxuICAgIFRpbWVkSFRNTEFjdGl2ZUNvZGUsXG4gICAgVGltZWRTUUxBY3RpdmVDb2RlLFxufSBmcm9tIFwiLi90aW1lZF9hY3RpdmVjb2RlXCI7XG5pbXBvcnQgXCIuLi8uLi9jb21tb24vanMvanF1ZXJ5LmhpZ2hsaWdodC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQ0ZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZvbyA9IFwiYmFyXCI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBY3RpdmVDb2RlKG9yaWcsIGxhbmcsIGFkZG9wdHMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICBvcmlnOiBvcmlnLFxuICAgICAgICAgICAgdXNlUnVuZXN0b25lU2VydmljZXM6IGVCb29rQ29uZmlnLnVzZVJ1bmVzdG9uZVNlcnZpY2VzLFxuICAgICAgICAgICAgcHl0aG9uMzogZUJvb2tDb25maWcucHl0aG9uMyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFkZG9wdHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHJuYW1lIGluIGFkZG9wdHMpIHtcbiAgICAgICAgICAgICAgICBvcHRzW2F0dHJuYW1lXSA9IGFkZG9wdHNbYXR0cm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhbmcgPSAkKG9wdHMub3JpZykuZmluZChcIltkYXRhLWxhbmddXCIpLmRhdGEoXCJsYW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnRpbWVkID09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYW5nID09PSBcInB5dGhvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZEFjdGl2ZUNvZGUob3B0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGxhbmcgPT09IFwiamF2YVwiIHx8XG4gICAgICAgICAgICAgICAgbGFuZyA9PT0gXCJjcHBcIiB8fFxuICAgICAgICAgICAgICAgIGxhbmcgPT09IFwiY1wiIHx8XG4gICAgICAgICAgICAgICAgbGFuZyA9PT0gXCJweXRob24zXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGltZWRMaXZlQ29kZShvcHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFuZyA9PT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRpbWVkSlNBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYW5nID09PSBcImh0bWxtaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZEhUTUxBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYW5nID09PSBcInNxbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZFNRTEFjdGl2ZUNvZGUob3B0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGltZWRBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxhbmcgPT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKU0FjdGl2ZUNvZGUob3B0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhbmcgPT09IFwiaHRtbG1peGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhUTUxBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYW5nID09PSBcInNxbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTUUxBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBbXCJqYXZhXCIsIFwiY3BwXCIsIFwiY1wiLCBcInB5dGhvbjNcIiwgXCJweXRob24yXCIsIFwib2N0YXZlXCJdLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgIGxhbmdcbiAgICAgICAgICAgICAgICApID4gLTFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGl2ZUNvZGUob3B0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgcHl0aG9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgd2ViMnB5IGNvbnRyb2xsZXIocylcbiAgICBzdGF0aWMgYWRkQWN0aXZlQ29kZVRvRGl2KG91dGVyZGl2aWQsIGFjZGl2aWQsIHNpZCwgaW5pdGlhbGNvZGUsIGxhbmd1YWdlKSB7XG4gICAgICAgIHZhciB0aGVwcmUsIG5ld2FjO1xuICAgICAgICB2YXIgYWNkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhY2RpdmlkKTtcbiAgICAgICAgJChhY2RpdikuZW1wdHkoKTtcbiAgICAgICAgdGhlcHJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICB0aGVwcmVbXCJkYXRhLWNvbXBvbmVudFwiXSA9IFwiYWN0aXZlY29kZVwiO1xuICAgICAgICB0aGVwcmUuaWQgPSBvdXRlcmRpdmlkO1xuICAgICAgICAkKHRoZXByZSkuZGF0YShcImxhbmdcIiwgbGFuZ3VhZ2UpO1xuICAgICAgICAkKGFjZGl2KS5hcHBlbmQodGhlcHJlKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICBvcmlnOiB0aGVwcmUsXG4gICAgICAgICAgICB1c2VSdW5lc3RvbmVTZXJ2aWNlczogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFkZG9wdHMgPSB7XG4gICAgICAgICAgICBzaWQ6IHNpZCxcbiAgICAgICAgICAgIGdyYWRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxhbmd1YWdlID09PSBcImh0bWxtaXhlZFwiKSB7XG4gICAgICAgICAgICBhZGRvcHRzW1widmVydGljYWxcIl0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld2FjID0gQUNGYWN0b3J5LmNyZWF0ZUFjdGl2ZUNvZGUodGhlcHJlLCBsYW5ndWFnZSwgYWRkb3B0cyk7XG4gICAgICAgIHZhciBzYXZlZGl2ID0gbmV3YWMuZGl2aWQ7XG4gICAgICAgIG5ld2FjLmRpdmlkID0gc2F2ZWRpdjtcbiAgICAgICAgbmV3YWMuZWRpdG9yLnNldFNpemUoNTAwLCAzMDApO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5ld2FjLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBY3RpdmVDb2RlRnJvbU9wdHMob3B0cykge1xuICAgICAgICByZXR1cm4gQUNGYWN0b3J5LmNyZWF0ZUFjdGl2ZUNvZGUob3B0cy5vcmlnLCBvcHRzLmxhbmcsIG9wdHMpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlU2NyYXRjaEFjdGl2ZWNvZGUoKSB7XG4gICAgICAgIC8qIHNldCB1cCB0aGUgc2NyYXRjaCBBY3RpdmVjb2RlIGVkaXRvciBpbiB0aGUgc2VhcmNoIG1lbnUgKi9cbiAgICAgICAgLy8gdXNlIHRoZSBVUkwgdG8gYXNzaWduIGEgZGl2aWQgLSBlYWNoIHBhZ2Ugc2hvdWxkIGhhdmUgYSB1bmlxdWUgQWN0aXZlY29kZSBibG9jayBpZC5cbiAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgVVJMIGJ1dCB0aGUgY291cnNlIGFuZCBwYWdlIG5hbWVcbiAgICAgICAgLy8gdG9kbzogIHRoaXMgY291bGQgcHJvYmFibHkgYmUgZWxpbWluYXRlZCBhbmQgc2ltcGx5IG1vdmVkIHRvIHRoZSB0ZW1wbGF0ZSBmaWxlXG5cbiAgICAgICAgaWYgKGVCb29rQ29uZmlnLmVuYWJsZVNjcmF0Y2hBQyA9PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBkaXZpZCA9IGVCb29rQ29uZmlnLmNvdXJzZSArIFwiX3NjcmF0Y2hfYWNcIjtcbiAgICAgICAgZGl2aWQgPSBkaXZpZC5yZXBsYWNlKC9bIy5dL2csIFwiXCIpOyAvLyBpbiBjYXNlIGJvb2sgdGl0bGUgaGFzIGNoYXJhY3RlcnMgdGhhdCB3aWxsIG1lc3MgdXAgb3VyIHNlbGVjdG9yc1xuICAgICAgICBlQm9va0NvbmZpZy5zY3JhdGNoRGl2ID0gZGl2aWQ7XG4gICAgICAgIGxldCBzdGRpbiA9IFwiXCI7XG4gICAgICAgIHZhciBsYW5nID0gZUJvb2tDb25maWcuYWNEZWZhdWx0TGFuZ3VhZ2VcbiAgICAgICAgICAgID8gZUJvb2tDb25maWcuYWNEZWZhdWx0TGFuZ3VhZ2VcbiAgICAgICAgICAgIDogXCJweXRob25cIjtcbiAgICAgICAgaWYgKGxhbmcgPT09IFwiamF2YVwiIHx8IGxhbmcgPT09IFwiY3BwXCIgfHwgbGFuZyA9PT0gXCJweXRob24zXCIpIHtcbiAgICAgICAgICAgIHN0ZGluID0gYGRhdGEtc3RkaW49XCJ0ZXh0IGZvciBzdGRpblwiYDtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgSFRNTFxuICAgICAgICB2YXIgaHRtbCA9IGA8ZGl2IGlkPVwiYWNfbW9kYWxfJHtkaXZpZH1cIiBjbGFzcz1cIm1vZGFsIGZhZGVcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBzY3JhdGNoLWFjLW1vZGFsXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJtb2RhbC10aXRsZVwiPlNjcmF0Y2ggQWN0aXZlQ29kZTwvaDQ+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGRhdGEtY29tcG9uZW50PVwiYWN0aXZlY29kZVwiIGlkPSR7ZGl2aWR9PlxuICAgICAgICAgICAgICAgICAgPGRpdiBpZD0ke2RpdmlkfV9xdWVzdGlvbiBjbGFzcz1cImFjX3F1ZXN0aW9uXCI+PHA+VXNlIHRoaXMgYXJlYSBmb3Igd3JpdGluZyBjb2RlIG9yIHRha2luZyBub3Rlcy48L3A+PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgZGF0YS1jb2RlbGVucz1cInRydWVcIiBkYXRhLWxhbmc9XCIke2xhbmd9XCIgJHtzdGRpbn0+XG5cblxuXG5cbiAgICAgICAgICAgICAgICAgIDwvdGV4dGFyZWE+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgIHZhciBlbCA9ICQoaHRtbCk7XG4gICAgICAgICQoXCJib2R5XCIpLmFwcGVuZChlbCk7XG4gICAgICAgIGVsLm9uKFwic2hvd24uYnMubW9kYWwgc2hvdy5icy5tb2RhbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5maW5kKFwiLkNvZGVNaXJyb3JcIikuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgIGUuQ29kZU1pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgZS5Db2RlTWlycm9yLmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b2dnbGVTY3JhdGNoQWN0aXZlY29kZSgpIHtcbiAgICAgICAgaWYgKCFlQm9va0NvbmZpZy5lbmFibGVTY3JhdGNoQUMpIHJldHVybjtcbiAgICAgICAgdmFyIGRpdmlkID0gXCJhY19tb2RhbF9cIiArIGVCb29rQ29uZmlnLnNjcmF0Y2hEaXY7XG4gICAgICAgIHZhciBkaXYgPSAkKFwiI1wiICsgZGl2aWQpO1xuICAgICAgICAkKGAjJHtlQm9va0NvbmZpZy5zY3JhdGNoRGl2fWApLnJlbW92ZUNsYXNzKFwiYWNfc2VjdGlvblwiKTtcbiAgICAgICAgZGl2Lm1vZGFsKFwidG9nZ2xlXCIpO1xuICAgIH1cbn1cblxuLy9cbi8vIFBhZ2UgSW5pdGlhbGl6YXRpb25cbi8vXG5cbiQoZG9jdW1lbnQpLm9uKFwicnVuZXN0b25lOmxvZ2luLWNvbXBsZXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBBQ0ZhY3RvcnkuY3JlYXRlU2NyYXRjaEFjdGl2ZWNvZGUoKTtcbiAgICAkKFwiW2RhdGEtY29tcG9uZW50PWFjdGl2ZWNvZGVdXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoJCh0aGlzKS5jbG9zZXN0KFwiW2RhdGEtY29tcG9uZW50PXRpbWVkQXNzZXNzbWVudF1cIikubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBleGlzdHMgd2l0aGluIGEgdGltZWQgY29tcG9uZW50LCBkb24ndCByZW5kZXIgaXQgaGVyZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZWRMaXN0W3RoaXMuaWRdID0gQUNGYWN0b3J5LmNyZWF0ZUFjdGl2ZUNvZGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuZmluZChcInRleHRhcmVhXCIpLmRhdGEoXCJsYW5nXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciByZW5kZXJpbmcgQWN0aXZlY29kZSBQcm9ibGVtICR7dGhpcy5pZH1cbiAgICAgICAgICAgICAgICBEZXRhaWxzOiAke2Vycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChsb2dnZWRvdXQpIHtcbiAgICAgICAgZm9yIChsZXQgayBpbiB3aW5kb3cuZWRMaXN0KSB7XG4gICAgICAgICAgICB3aW5kb3cuZWRMaXN0W2tdLmRpc2FibGVTYXZlTG9hZCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgayBpbiB3aW5kb3cuZWRMaXN0KSB7XG4gICAgICAgICAgICB3aW5kb3cuZWRMaXN0W2tdLmVuYWJsZVNhdmVMb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuaWYgKHR5cGVvZiB3aW5kb3cuY29tcG9uZW50X2ZhY3RvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cuY29tcG9uZW50X2ZhY3RvcnkgPSB7fTtcbn1cblxud2luZG93LmNvbXBvbmVudF9mYWN0b3J5LmFjdGl2ZWNvZGUgPSBBQ0ZhY3RvcnkuY3JlYXRlQWN0aXZlQ29kZUZyb21PcHRzO1xuXG4vLyBUaGlzIGlzIHRoZSBlYXNpZXN0IHdheSB0byBleHBvc2UgdGhpcyBvdXRzaWRlIHRoZSBtb2R1bGUuXG53aW5kb3cuQUNGYWN0b3J5ID0gQUNGYWN0b3J5O1xuXG4vLyBUaGlzIHNlZW1zIGEgYml0IGhhY2t5IGFuZCBwb3NzaWJseSBicml0dGxlLCBidXQgaXRzIGhhcmQgdG8ga25vdyBob3cgbG9uZyBpdCB3aWxsIHRha2UgdG9cbi8vIGZpZ3VyZSBvdXQgdGhlIGxvZ2luL2xvZ291dCBzdGF0dXMgb2YgdGhlIHVzZXIuICBTb21ldGltZXMgaXRzIGltbWVkaWF0ZSwgYW5kIHNvbWV0aW1lcyBpdHNcbi8vIGxvbmcuICBTbyB0byBiZSBzYWZlIHdlJ2xsIGRvIGl0IGJvdGggd2F5cy4uXG52YXIgbG9nZ2Vkb3V0O1xuJChkb2N1bWVudCkub24oXCJydW5lc3RvbmU6bG9nb3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICBsb2dnZWRvdXQgPSB0cnVlO1xufSk7XG4kKGRvY3VtZW50KS5vbihcInJ1bmVzdG9uZTpsb2dvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAobGV0IGsgaW4gd2luZG93LmVkTGlzdCkge1xuICAgICAgICBpZiAod2luZG93LmVkTGlzdC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgd2luZG93LmVkTGlzdFtrXS5kaXNhYmxlU2F2ZUxvYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiJC5pMThuKCkubG9hZCh7XG4gICAgZW46IHtcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9oaXN0b3J5OiBcIkxvYWQgSGlzdG9yeVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdWRpb190b3VyOiBcIkF1ZGlvIFRvdXJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZGVkX2NvZGU6IFwiTG9hZGVkIHlvdXIgc2F2ZWQgY29kZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fc2F2ZWRfY29kZTogXCJObyBzYXZlZCBjb2RlLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ydW5fY29kZTogXCJSdW5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19mZWVkYmFjazogXCJTaG93IEZlZWRiYWNrXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZTogXCJTaG93IENvZGVcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaGlkZV9jb2RlOiBcIkhpZGUgQ29kZVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2NvZGVsZW5zOiBcIlNob3cgQ29kZUxlbnNcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19pbl9jb2RlbGVuczogXCJTaG93IGluIENvZGVMZW5zXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2hpZGVfY29kZWxlbnM6IFwiSGlkZSBDb2RlbGVuc1wiLFxuXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BhcnNlX2Vycm9yOlxuICAgICAgICAgICAgXCJBIHBhcnNlIGVycm9yIG1lYW5zIHRoYXQgUHl0aG9uIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhlIHN5bnRheCBvbiB0aGUgbGluZSB0aGUgZXJyb3IgbWVzc2FnZSBwb2ludHMgb3V0LiBDb21tb24gZXhhbXBsZXMgYXJlIGZvcmdldHRpbmcgY29tbWFzIGJldGV3ZWVuIGFyZ3VtZW50cyBvciBmb3JnZXR0aW5nIGEgOiBvbiBhIGZvciBzdGF0ZW1lbnRcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGFyc2VfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJUbyBmaXggYSBwYXJzZSBlcnJvciB5b3UganVzdCBuZWVkIHRvIGxvb2sgY2FyZWZ1bGx5IGF0IHRoZSBsaW5lIHdpdGggdGhlIGVycm9yIGFuZCBwb3NzaWJseSB0aGUgbGluZSBiZWZvcmUgaXQuICBNYWtlIHN1cmUgaXQgY29uZm9ybXMgdG8gYWxsIG9mIFB5dGhvbidzIHJ1bGVzLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90eXBlX2Vycm9yOlxuICAgICAgICAgICAgXCJUeXBlIGVycm9ycyBtb3N0IG9mdGVuIG9jY3VyIHdoZW4gYW4gZXhwcmVzc2lvbiB0cmllcyB0byBjb21iaW5lIHR3byBvYmplY3RzIHdpdGggdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbWJpbmVkLiAgTGlrZSByYWlzaW5nIGEgc3RyaW5nIHRvIGEgcG93ZXJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlRvIGZpeCBhIHR5cGUgZXJyb3IgeW91IHdpbGwgbW9zdCBsaWtlbHkgbmVlZCB0byB0cmFjZSB0aHJvdWdoIHlvdXIgY29kZSBhbmQgbWFrZSBzdXJlIHRoZSB2YXJpYWJsZXMgaGF2ZSB0aGUgdHlwZXMgeW91IGV4cGVjdCB0aGVtIHRvIGhhdmUuICBJdCBtYXkgYmUgaGVscGZ1bCB0byBwcmludCBvdXQgZWFjaCB2YXJpYWJsZSBhbG9uZyB0aGUgd2F5IHRvIGJlIHN1cmUgaXRzIHZhbHVlIGlzIHdoYXQgeW91IHRoaW5rIGl0IHNob3VsZCBiZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcjpcbiAgICAgICAgICAgIFwiQSBuYW1lIGVycm9yIGFsbW9zdCBhbHdheXMgbWVhbnMgdGhhdCB5b3UgaGF2ZSB1c2VkIGEgdmFyaWFibGUgYmVmb3JlIGl0IGhhcyBhIHZhbHVlLiAgT2Z0ZW4gdGhpcyBtYXkgYmUgYSBzaW1wbGUgdHlwbywgc28gY2hlY2sgdGhlIHNwZWxsaW5nIGNhcmVmdWxseS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZWNrIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgYXNzaWdubWVudCBzdGF0ZW1lbnRzIGFuZCB5b3VyIGZ1bmN0aW9uIGNhbGxzLCB0aGlzIGlzIHRoZSBtb3N0IGxpa2VseSBwbGFjZSBmb3IgYSBOYW1lRXJyb3IgdG8gYmUgZm91bmQuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3ZhbHVlX2Vycm9yOlxuICAgICAgICAgICAgXCJBIFZhbHVlRXJyb3IgbW9zdCBvZnRlbiBvY2N1cnMgd2hlbiB5b3UgcGFzcyBhIHBhcmFtZXRlciB0byBhIGZ1bmN0aW9uIGFuZCB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0aW5nIG9uZSB0eXBlIGFuZCB5b3UgcGFzcyBhbm90aGVyLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlRoZSBlcnJvciBtZXNzYWdlIGdpdmVzIHlvdSBhIHByZXR0eSBnb29kIGhpbnQgYWJvdXQgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGFzIHdlbGwgYXMgdGhlIHZhbHVlIHRoYXQgaXMgaW5jb3JyZWN0LiBMb29rIGF0IHRoZSBlcnJvciBtZXNzYWdlIGNsb3NlbHkgYW5kIHRoZW4gdHJhY2UgYmFjayB0byB0aGUgdmFyaWFibGUgY29udGFpbmluZyB0aGUgcHJvYmxlbWF0aWMgdmFsdWUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvcjpcbiAgICAgICAgICAgIFwiVGhpcyBlcnJvciBtZXNzYWdlIGlzIHRlbGxpbmcgeW91IHRoYXQgdGhlIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGRvdCwgZG9lcyBub3QgaGF2ZSB0aGUgYXR0cmlidXRlIG9yIG1ldGhvZCBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdHRyaWJ1dGVfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJUaGUgbW9zdCBjb21tb24gdmFyaWFudCBvZiB0aGlzIG1lc3NhZ2UgaXMgdGhhdCB0aGUgb2JqZWN0IHVuZGVmaW5lZCBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZSBYLiAgVGhpcyB0ZWxscyB5b3UgdGhhdCB0aGUgb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgZG90IGlzIG5vdCB3aGF0IHlvdSB0aGluay4gVHJhY2UgdGhlIHZhcmlhYmxlIGJhY2sgYW5kIHByaW50IGl0IG91dCBpbiB2YXJpb3VzIHBsYWNlcyB1bnRpbCB5b3UgZGlzY292ZXIgd2hlcmUgaXQgYmVjb21lcyB1bmRlZmluZWQuICBPdGhlcndpc2UgY2hlY2sgdGhlIGF0dHJpYnV0ZSBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBkb3QgZm9yIGEgdHlwby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdG9rZW5fZXJyb3I6XG4gICAgICAgICAgICBcIk1vc3Qgb2YgdGhlIHRpbWUgdGhpcyBlcnJvciBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBmb3Jnb3R0ZW4gYSByaWdodCBwYXJlbnRoZXNpcyBvciBoYXZlIGZvcmdvdHRlbiB0byBjbG9zZSBhIHBhaXIgb2YgcXVvdGVzLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZWNrIGVhY2ggbGluZSBvZiB5b3VyIHByb2dyYW0gYW5kIG1ha2Ugc3VyZSB0aGF0IHlvdXIgcGFyZW50aGVzaXMgYXJlIGJhbGFuY2VkLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90aW1lX2xpbWl0X2Vycm9yOlxuICAgICAgICAgICAgXCJZb3VyIHByb2dyYW0gaXMgcnVubmluZyB0b28gbG9uZy4gIE1vc3QgcHJvZ3JhbXMgaW4gdGhpcyBib29rIHNob3VsZCBydW4gaW4gbGVzcyB0aGFuIDEwIHNlY29uZHMgZWFzaWx5LiBUaGlzIHByb2JhYmx5IGluZGljYXRlcyB5b3VyIHByb2dyYW0gaXMgaW4gYW4gaW5maW5pdGUgbG9vcC5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkFkZCBzb21lIHByaW50IHN0YXRlbWVudHMgdG8gZmlndXJlIG91dCBpZiB5b3VyIHByb2dyYW0gaXMgaW4gYW4gaW5maW50ZSBsb29wLiAgSWYgaXQgaXMgbm90IHlvdSBjYW4gaW5jcmVhc2UgdGhlIHJ1biB0aW1lIHdpdGggc3lzLnNldEV4ZWN1dGlvbkxpbWl0KG1zZWNzKVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yOlxuICAgICAgICAgICAgXCJZb3VyIHByb2dyYW0gaXMgcnVubmluZyBmb3IgdG9vIGxvbmcuICBNb3N0IHByb2dyYW1zIGluIHRoaXMgYm9vayBzaG91bGQgcnVuIGluIGxlc3MgdGhhbiAzMCBzZWNvbmRzIGVhc2lseS4gVGhpcyBwcm9iYWJseSBpbmRpY2F0ZXMgeW91ciBwcm9ncmFtIGlzIGluIGFuIGluZmluaXRlIGxvb3AuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2dlbmVyYWxfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJBZGQgc29tZSBwcmludCBzdGF0ZW1lbnRzIHRvIGZpZ3VyZSBvdXQgaWYgeW91ciBwcm9ncmFtIGlzIGluIGFuIGluZmludGUgbG9vcC4gIElmIGl0IGlzIG5vdCB5b3UgY2FuIGluY3JlYXNlIHRoZSBydW4gdGltZSB3aXRoIHN5cy5zZXRFeGVjdXRpb25MaW1pdChtc2VjcylcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc3ludGF4X2Vycm9yOlxuICAgICAgICAgICAgXCJUaGlzIG1lc3NhZ2UgaW5kaWNhdGVzIHRoYXQgUHl0aG9uIGNhbid0IGZpZ3VyZSBvdXQgdGhlIHN5bnRheCBvZiBhIHBhcnRpY3VsYXIgc3RhdGVtZW50LiAgU29tZSBleGFtcGxlcyBhcmUgYXNzaWduaW5nIHRvIGEgbGl0ZXJhbCwgb3IgYSBmdW5jdGlvbiBjYWxsXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N5bnRheF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZWNrIHlvdXIgYXNzaWdubWVudCBzdGF0ZW1lbnRzIGFuZCBtYWtlIHN1cmUgdGhhdCB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgaXMgYSB2YXJpYWJsZSwgbm90IGEgbGl0ZXJhbCBvciBhIGZ1bmN0aW9uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9rZXlfZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgbWVzc2FnZSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3MgYW4gZWxlbWVudCBvZiBhIGRpY3Rpb25hcnksIGJ1dCB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBoYXZlIHRoYXQgdGhlIGtleSB5b3UgYXJlIHVzaW5nLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9rZXlfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJZb3UgbWF5IGhhdmUgYSB0eXBvIGluIHRoZSBuYW1lIG9mIHlvdXIga2V5LiAgSXQgaXMgYWxzbyBnb29kIHByYWN0aWNlIHRvIGNoZWNrIGlmIHRoZSBrZXkgZXhpc3RzIHVzaW5nIGEgc3RhdGVtZW50IGxpa2UgaWYga2V5IGluIG15ZGljdC4gIFlvdSBjYW4gYWxzbyB1c2UgbXlkaWN0LmdldChrZXksZGVmYXVsdHZhbHVlKSBzbyB0aGF0IGlmIHRoZSBrZXkgaXMgbm90IGluIHRoZSBkaWN0aW9uYXJ5IHlvdSBnZXQgdGhlIGRlZmF1bHQgdmFsdWUgaW5zdGVhZCBvZiBhbiBlcnJvci5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZXhfZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgbWVzc2FnZSBtZWFucyB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGluZGV4IHBhc3QgdGhlIGVuZCBvZiBhIHN0cmluZyBvciBhIGxpc3QuICBGb3IgZXhhbXBsZSBpZiB5b3VyIGxpc3QgaGFzIDMgdGhpbmdzIGluIGl0IGFuZCB5b3UgdHJ5IHRvIGFjY2VzcyB0aGUgaXRlbSBhdCBwb3NpdGlvbiAzIG9yIG1vcmUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2luZGV4X2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiUmVtZW1iZXIgdGhhdCB0aGUgZmlyc3QgaXRlbSBpbiBhIGxpc3Qgb3Igc3RyaW5nIGlzIGF0IGluZGV4IHBvc2l0aW9uIDAsIHF1aXRlIG9mdGVuIHRoaXMgbWVzc2FnZSBjb21lcyBhYm91dCBiZWNhdXNlIHlvdSBhcmUgb2ZmIGJ5IG9uZS4gIFJlbWVtYmVyIGluIGEgbGlzdCBvZiBsZW5ndGggMyB0aGUgbGFzdCBsZWdhbCBpbmRleCBpcyAyXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3VyaV9lcnJvcjogXCJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yX2ZpeDogXCJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yOlxuICAgICAgICAgICAgXCJUaGlzIGVycm9yIG1lc3NhZ2UgaW5kaWNhdGVzIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gaW1wb3J0IGEgbW9kdWxlIHRoYXQgZG9lcyBub3QgZXhpc3RcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiT25lIHByb2JsZW0gbWF5IHNpbXBseSBiZSB0aGF0IHlvdSBoYXZlIGEgdHlwby4gIEl0IG1heSBhbHNvIGJlIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gaW1wb3J0IGEgbW9kdWxlIHRoYXQgZXhpc3RzIGluICdyZWFsJyBQeXRob24sIGJ1dCBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGJvb2suICBJZiB0aGlzIGlzIHRoZSBjYXNlLCBwbGVhc2Ugc3VibWl0IGEgZmVhdHVyZSByZXF1ZXN0IHRvIGhhdmUgdGhlIG1vZHVsZSBhZGRlZC5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yOlxuICAgICAgICAgICAgXCJUaGlzIGlzIG1vc3QgbGlrZWx5IGFuIGludGVybmFsIGVycm9yLCBwYXJ0aWN1bGFybHkgaWYgdGhlIG1lc3NhZ2UgcmVmZXJlbmNlcyB0aGUgY29uc29sZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiVHJ5IHJlZnJlc2hpbmcgdGhlIHdlYnBhZ2UsIGFuZCBpZiB0aGUgZXJyb3IgY29udGludWVzLCBzdWJtaXQgYSBidWcgcmVwb3J0IGFsb25nIHdpdGggeW91ciBjb2RlXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3plcm9fZGl2aXNpb25fZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgdGVsbHMgeW91IHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gZGl2aWRlIGJ5IDAuIFR5cGljYWxseSB0aGlzIGlzIGJlY2F1c2UgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBpbiB0aGUgZGVub21pbmF0b3Igb2YgYSBkaXZpc2lvbiBleHByZXNzaW9uIGhhcyB0aGUgdmFsdWUgMFwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV96ZXJvX2RpdmlzaW9uX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiWW91IG1heSBuZWVkIHRvIHByb3RlY3QgYWdhaW5zdCBkaXZpZGluZyBieSAwIHdpdGggYW4gaWYgc3RhdG1lbnQsIG9yIHlvdSBtYXkgbmVlZCB0byByZXhhbWluZSB5b3VyIGFzc3VtcHRpb25zIGFib3V0IHRoZSBsZWdhbCB2YWx1ZXMgb2YgdmFyaWFibGVzLCBpdCBjb3VsZCBiZSBhbiBlYXJsaWVyIHN0YXRtZW50IHRoYXQgaXMgdW5leHBlY3RlZGx5IGFzc2lnbmluZyBhIHZhbHVlIG9mIHplcm8gdG8gdGhlIHZhcmlhYmxlIGluIHF1ZXN0aW9uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcjpcbiAgICAgICAgICAgIFwiVGhpcyBtZXNzYWdlIGFsbW9zdCBhbHdheXMgc2hvd3MgdXAgaW4gdGhlIGZvcm0gb2YgTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JhbmdlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiVGhpcyBhbHdheXMgb2NjdXJzIHdoZW4gYSBmdW5jdGlvbiBjYWxscyBpdHNlbGYuICBJdHMgcHJldHR5IGxpa2VseSB0aGF0IHlvdSBhcmUgbm90IGRvaW5nIHRoaXMgb24gcHVycG9zZS4gRXhjZXB0IGluIHRoZSBjaGFwdGVyIG9uIHJlY3Vyc2lvbi4gIElmIHlvdSBhcmUgaW4gdGhhdCBjaGFwdGVyIHRoZW4gaXRzIGxpa2VseSB5b3UgaGF2ZW4ndCBpZGVudGlmaWVkIGEgZ29vZCBiYXNlIGNhc2UuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ludGVybmFsX2Vycm9yOlxuICAgICAgICAgICAgXCJBbiBJbnRlcm5hbCBlcnJvciBtYXkgbWVhbiB0aGF0IHlvdSd2ZSB0cmlnZ2VyZWQgYSBidWcgaW4gb3VyIFB5dGhvblwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlJlcG9ydCB0aGlzIGVycm9yLCBhbG9uZyB3aXRoIHlvdXIgY29kZSBhcyBhIGJ1Zy5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZW50YXRpb25fZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgZXJyb3Igb2NjdXJzIHdoZW4geW91IGhhdmUgbm90IGluZGVudGVkIHlvdXIgY29kZSBwcm9wZXJseS4gIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGFzIHBhcnQgb2YgYW4gaWYsIGZvciwgd2hpbGUgb3IgZGVmIHN0YXRlbWVudC5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZW50YXRpb25fZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJDaGVjayB5b3VyIGlmLCBkZWYsIGZvciwgYW5kIHdoaWxlIHN0YXRlbWVudHMgdG8gYmUgc3VyZSB0aGUgbGluZXMgYXJlIHByb3Blcmx5IGluZGVudGVkIGJlbmVhdGggdGhlbS4gIEFub3RoZXIgc291cmNlIG9mIHRoaXMgZXJyb3IgY29tZXMgZnJvbSBjb3B5aW5nIGFuZCBwYXN0aW5nIGNvZGUgd2hlcmUgeW91IGhhdmUgYWNjaWRlbnRhbGx5IGxlZnQgc29tZSBiaXRzIG9mIGNvZGUgbHlpbmcgYXJvdW5kIHRoYXQgZG9uJ3QgYmVsb25nIHRoZXJlIGFueW1vcmUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25vdF9pbXBsZW1lbnRlZF9lcnJvcjpcbiAgICAgICAgICAgIFwiVGhpcyBlcnJvciBvY2N1cnMgd2hlbiB5b3UgdHJ5IHRvIHVzZSBhIGJ1aWx0aW4gZnVuY3Rpb24gb2YgUHl0aG9uIHRoYXQgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGluIHRoaXMgaW4tYnJvd3NlciB2ZXJzaW9uIG9mIFB5dGhvbi5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm90X2ltcGxlbWVudGVkX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiRm9yIG5vdyB0aGUgb25seSB3YXkgdG8gZml4IHRoaXMgaXMgdG8gbm90IHVzZSB0aGUgZnVuY3Rpb24uICBUaGVyZSBtYXkgYmUgd29ya2Fyb3VuZHMuICBJZiB5b3UgcmVhbGx5IG5lZWQgdGhpcyBidWlsdGluIGZ1bmN0aW9uIHRoZW4gZmlsZSBhIGJ1ZyByZXBvcnQgYW5kIHRlbGwgdXMgaG93IHlvdSBhcmUgdHJ5aW5nIHRvIHVzZSB0aGUgZnVuY3Rpb24uXCIsXG5cbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfZmlsZV9ub3RfZm91bmQ6IFwiRmlsZSBub3QgZm91bmQ6ICckMSdcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fZmlsZV9vcl9kaXI6XG4gICAgICAgICAgICBcIltFcnJubyAyXSBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5OiAnJDEnXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N0YXJ0aW5nOiBcIkNsaWNrIHRoZSBwbGF5IGJ1dHRvbiB0byBiZWdpbiB0aGUgJDFcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGxheWluZzogXCJQbGF5aW5nIHRoZSAkMVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkaW5nX2F1ZGlvOlxuICAgICAgICAgICAgXCJMb2FkaW5nIGF1ZGlvLiAgUGxlYXNlIHdhaXQuICAgSWYgdGhlIHRvdXIgZG9lc24ndCBzdGFydCBzb29uIGNsaWNrIG9uIHRoZSBsZWZ0bW9zdCBjb250cm9sIGJ1dHRvbiAoUGxheSBmaXJzdCBhdWRpbyBpbiB0b3VyKVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXVzZV9jdXJyZW50X2F1ZGlvOiBcIlBhdXNlIGN1cnJlbnQgYXVkaW9cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGF1c2VfYXVkaW86IFwiUGF1c2UgYXVkaW9cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGxheV9wYXVzZWRfYXVkaW86IFwiUGxheSBwYXVzZWQgYXVkaW9cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fcGF1c2VkOlxuICAgICAgICAgICAgXCJUaGUgJDEgaGFzIGJlZW4gcGF1c2VkLiBDbGljayBvbiB0aGUgcGxheSBidXR0b24gdG8gcmVzdW1lIHRoZSB0b3VyLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnB1dF9wcmc6IFwiSW5wdXQgZm9yIFByb2dyYW1cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfd2VyZV9jb21waWxpbmdfZXJyOlxuICAgICAgICAgICAgXCJUaGVyZSB3ZXJlIGVycm9ycyBjb21waWxpbmcgeW91ciBjb2RlLiBTZWUgYmVsb3cuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXhjOiBcIlRpbWUgTGltaXQgRXhjZWVkZWQgb24geW91ciBwcm9ncmFtXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3NlcnZlcl9lcnI6IFwiQSBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWQ6ICQxICQyXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2NvbXBpbGluZ19ydW5uaW5nOlxuICAgICAgICAgICAgXCJDb21waWxpbmcgYW5kIFJ1bm5pbmcgeW91ciBDb2RlIE5vdy4uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zZXJ2ZXJfY29tbV9lcnI6IFwiRXJyb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBzZXJ2ZXIuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3NhdmVfcnVuOiBcIlNhdmUgJiBSdW5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVuZGVyOiBcIlNhdmUgJiBSZW5kZXJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXNzZXJ0aW9uX2Vycm9yOlxuICAgICAgICAgICAgXCJBbiBhc3NlcnRpb24gZXJyb3IgaGFwcGVucyB3aGVuIHB5dGhvbiBlbmNvdW50ZXJzIGFuIGFzc2VydGlvbiBzdGF0ZW1lbnQuICBQeXRob24gZXZhbHVhdGVzIHRoZSBleHByZXNzaW9uIHRvIHRoZSByaWdodCBvZiB0aGUgd29yZCBhc3NlcnQ7IGlmIHRoYXQgZXhwcmVzc2lvbiBpcyBUcnVlIGV2ZXJ5dGhpbmcgaXMgZmluZSBhbmQgdGhlIHByb2dyYW0gY29udGludWVzLiAgSWYgdGhlIGV4cHJlc3Npb24gaXMgRmFsc2UgUHl0aG9uIHJhaXNlcyBhbiBlcnJvciBhbmQgc3RvcHMuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZWNrIHRoZSBleHByZXNzaW9uIHRvIHRoZSByaWdodCBvZiBhc3NlcnQuICBUaGUgZXhwcmVzc2lvbiBpcyBGYWxzZSBhbmQgeW91IHdpbGwgbmVlZCB0byBkZXRlcm1pbmUgd2h5IHRoYXQgaXMuICBZb3UgbWF5IHdhbnQgdG8gc2ltcGx5IHByaW50IG91dCB0aGUgaW5kaXZpZHVhbCBwYXJ0cyBvZiB0aGUgZXhwcmVzc2lvbiB0byB1bmRlcnN0YW5kIHdoeSBpdCBpcyBldmFsdWF0aW5nIHRvIEZhbHNlLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkX2RiOiBcIkxvYWRpbmcgREIuLi5cIixcbiAgICB9LFxufSk7XG4iLCIkLmkxOG4oKS5sb2FkKHtcbiAgICBcInB0LWJyXCI6IHtcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9oaXN0b3J5OiBcIkNhcnJlZ2FyIGhpc3TDs3JpY29cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fdG91cjogXCJUb3VyIGRlIMOhdWRpb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkZWRfY29kZTogXCJDw7NkaWdvIHNhbHZvIGNhcnJlZ2Fkby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fc2F2ZWRfY29kZTogXCJOw6NvIGjDoSBjw7NkaWdvIHNhbHZvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ydW5fY29kZTogXCJFeGVjdXRhclwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2ZlZWRiYWNrOiBcIkV4aWJpciBGZWVkYmFja3NcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlOiBcIk1vc3RyYXIgQ8OzZGlnb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGU6IFwiT2N1bHRhciBDw7NkaWdvXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZWxlbnM6IFwiTW9zdHJhciBDb2RlTGVuc1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2luX2NvZGVsZW5zOiBcIk1vc3RyYXIgZW0gQ29kZUxlbnNcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaGlkZV9jb2RlbGVuczogXCJPY3VsdGFyIENvZGVsZW5zXCIsXG5cbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGFyc2VfZXJyb3I6XG4gICAgICAgICAgICBcIlVtIGVycm8gZGUgUGFyc2Ugc2lnbmlmaWNhIHF1ZSBQeXRob24gbsOjbyBlbnRlbmRlIGEgc2ludGF4ZSBkYSBsaW5oYSBxdWUgYSBtZW5zYWdlbSBkZSBlcnJvIGFwb250YS4gRXhlbXBsb3MgY29tdW5zIHPDo28gZXNxdWVjZXIgdsOtcmd1bGFzIGVudHJlIGFyZ3VtZW50b3Mgb3UgZXNxdWVjZXIgJzonIGVtIHVtIGNvbWFuZG8gZm9yLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXJzZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlBhcmEgY29ycmlnaXIgdW0gZXJybyBkZSBQYXJzZSwgdm9jw6ogc8OzIHByZWNpc2Egb2xoYXIgY3VpZGFkb3NhbWVudGUgYSBsaW5oYSBjb20gbyBlcnJvIGUgcG9zc2l2ZWxtZW50ZSBhIGxpbmhhIGFudGVzIGRlbGEuIFRlbmhhIGNlcnRlemEgcXVlIGVzdMOjbyBkZSBhY29yZG8gY29tIHRvZGFzIGFzIHJlZ3JhcyBkZSBQeXRob24uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3R5cGVfZXJyb3I6XG4gICAgICAgICAgICBcIkVycm9zIGRlIHRpcGFnZW0gb2NvcnJlbSBtYWlzIGZyZXF1ZW50ZW1lbnRlIHF1YW5kbyB1bWEgZXhwcmVzc8OjbyB0ZW50YSBjb21iaW5hciBkb2lzIG9iamV0b3MgY29tIHRpcG9zIHF1ZSBuw6NvIGRldmVyaWFtIHNlciBjb21iaW5hZG9zLiBDb21vIGVsZXZhciB1bWEgU3RyaW5nIGEgdW1hIHBvdMOqbmNpYS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlBhcmEgY29ycmlnaXIgdW0gZXJybyBkZSB0aXBhZ2VtIHZvY8OqIHByb3ZhdmVsbWVudGUgcHJlY2lzYXLDoSBwZXJjb3JyZXIgc2V1IGPDs2RpZ28gZSB0ZXIgY2VydGV6YSBkZSBxdWUgYXMgdmFyacOhdmVpcyBwb3NzdWVtIG9zIHRpcG9zIHF1ZSB2b2PDqiBlc3BlcmEgcXVlIGVsYXMgdGVuaGFtLiBQb2RlIHNlciDDunRpbCBpbXByaW1pciBjYWRhIHZhcmnDoXZlbCBhbyBsb25nbyBkbyBjYW1pbmhvIHBhcmEgY2hlY2FyIHNlIGVsYXMgcG9zc3VlbSBvIHZhbG9yIHF1ZSB2b2PDqiBhY2hhIHF1ZSBkZXZlcmlhbSB0ZXIuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25hbWVfZXJyb3I6XG4gICAgICAgICAgICBcIlVtIGVycm8gZGUgbm9tZSBxdWFzZSBzZW1wcmUgc2lnbmlmaWNhIHF1ZSB2b2PDqiB1c291IHVtYSB2YXJpw6F2ZWwgYW50ZXMgZGVsYSB0ZXIgdW0gdmFsb3IuIEZyZXF1ZW50ZW1lbnRlIGlzc28gcG9kZSBzZXIgdW0gZXJybyBkZSBkaWdpdGHDp8OjbywgZW50w6NvIGNoZXF1ZSBhIG9ydG9ncmFmaWEgY3VpZGFkb3NhbWVudGUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25hbWVfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJDaGVxdWUgbyBsYWRvIGRpcmVpdG8gZGFzIGF0cmlidWnDp8O1ZXMgZSBzdWFzIGNoYW1hZGFzIGRlIGZ1bsOnw7Vlcywgc8OjbyBvcyBsdWdhcmVzIG1haXMgcHJvdsOhdmVpcyBkZSBlbmNvbnRyYXIgdW0gZXJybyBkZSBub21lLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvcjpcbiAgICAgICAgICAgIFwiVW0gZXJybyBkZSB2YWxvciBvY29ycmUgbWFpcyBmcmVxdWVudGVtZW50ZSBxdWFuZG8gdW1hIGZ1bsOnw6NvIGVzdMOhIGVzcGVyYW5kbyB1bSB0aXBvIG1hcyB2b2PDqiBwYXNzYSB1bSBwYXLDom1ldHJvIGRlIG91dHJvIHRpcG8uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3ZhbHVlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiQSBtZW5zYWdlbSBkZSBlcnJvIHRlIGTDoSB1bWEgYm9hIGRpY2Egc29icmUgbyBub21lIGRhIGZ1bsOnw6NvIGUgbyB2YWxvciBpbmNvcnJldG8uIExlaWEgYXRlbnRhbWVudGUgYSBtZW5zYWdlbSBkZSBlcnJvIGUgdm9sdGUgw6AgdmFyacOhdmVsIHF1ZSBjb250w6ltIG8gdmFsb3IgcHJvYmxlbcOhdGljby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXR0cmlidXRlX2Vycm9yOlxuICAgICAgICAgICAgXCJFc3NhIG1lbnNhZ2VtIGRlIGVycm8gZXN0w6EgdGUgZGl6ZW5kbyBxdWUgbyBvYmpldG8gZG8gbGFkbyBlc3F1ZXJkbyBkbyBwb250byBuw6NvIHRlbSBvIGF0cmlidXRvIG91IG3DqXRvZG8gZG8gc2V1IGxhZG8gZGlyZWl0by5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXR0cmlidXRlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiQSB2YXJpYW50ZSBtYWlzIGNvbXVtIGRlc3NhIG1lbnNhZ2VtIMOpIHF1ZSBvIG9iamV0byBpbmRlZmluaWRvIG7Do28gdGVtIG8gYXRyaWJ1dG8gWC4gSXNzbyBkaXogcXVlIG8gb2JqZXRvIGRvIGxhZG8gZXNxdWVyZG8gZG8gcG9udG8gbsOjbyDDqSBvIHF1ZSB2b2PDqiBwZW5zYS4gUmFzdHJlaWUgZXNzYSB2YXJpw6F2ZWwgZSBpbXByaW1hLWEgZW0gdsOhcmlvcyBsdWdhcmVzIGF0w6kgZGVzY29icmlyIG9uZGUgZWxhIHNlIHRvcm5hIGluZGVmaW5pZGEuIENhc28gY29udHLDoXJpbywgY2hlcXVlIHNlIGjDoSBlcnJvIGRlIGRpZ2l0YcOnw6NvIG5vIGF0cmlidXRvIGRvIGxhZG8gZGlyZWl0byBkbyBwb250by5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdG9rZW5fZXJyb3I6XG4gICAgICAgICAgICBcIk5hIG1haW9yaWEgZGFzIHZlemVzIGVzdGUgZXJybyBpbmRpY2EgcXVlIHZvY8OqIGVzcXVlY2V1IGRlIGZlY2hhciB1bSBwYXLDqm50ZXNlcyBvdSBhc3Bhcy5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdG9rZW5fZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJDaGVxdWUgY2FkYSBsaW5oYSBkbyBzZXUgcHJvZ3JhbWEgZSBjZXJ0aWZpcXVlLXNlIGRlIHF1ZSB0b2RvcyBvcyBwYXLDqm50ZXNlcyBlc3TDo28gZmVjaGFkb3MuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXJyb3I6XG4gICAgICAgICAgICBcIlNldSBwcm9ncmFtYSBlc3TDoSBkZW1vcmFuZG8gbXVpdG8uIE9zIHByb2dyYW1hcyBkZXN0ZSBsaXZybyBkZXZlcmlhbSByb2RhciBlbSBtZW5vcyBkZSAxMCBzZWd1bmRvcy4gSXNzbyBwcm92YXZlbG1lbnRlIGluZGljYSBxdWUgc2V1IHByb2dyYW1hIGVzdMOhIGVtIHVtIGxvb3AgaW5maW5pdG8uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJJbXByaW1hIG1lbnNhZ2VucyBlbSBhbGd1bWFzIGxpbmhhcyBwYXJhIGRlc2NvYnJpciBzZSBzZXUgcHJvZ3JhbWEgZXN0w6EgZW0gdW0gbG9vcCBpbmZpbml0by4gQ2FzbyBuw6NvIGVzdGVqYSwgdm9jw6ogcG9kZSBhdW1lbnRhciBvIHRlbXBvIGxpbWl0ZSBkZSBleGVjdcOnw6NvIGNvbSBvIGNvbWFuZG8gc3lzLnNldEV4ZWN1dGlvbkxpbWl0KG1zKVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yOlxuICAgICAgICAgICAgXCJTZXUgcHJvZ3JhbWEgZXN0w6EgZGVtb3JhbmRvIG11aXRvLiBPcyBwcm9ncmFtYXMgZGVzdGUgbGl2cm8gZGV2ZXJpYW0gcm9kYXIgZW0gbWVub3MgZGUgMzAgc2VndW5kb3MuIElzc28gcHJvdmF2ZWxtZW50ZSBpbmRpY2EgcXVlIHNldSBwcm9ncmFtYSBlc3TDoSBlbSB1bSBsb29wIGluZmluaXRvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiSW1wcmltYSBtZW5zYWdlbnMgZW0gYWxndW1hcyBsaW5oYXMgcGFyYSBkZXNjb2JyaXIgc2Ugc2V1IHByb2dyYW1hIGVzdMOhIGVtIHVtIGxvb3AgaW5maW5pdG8uIENhc28gbsOjbyBlc3RlamEsIHZvY8OqIHBvZGUgYXVtZW50YXIgbyB0ZW1wbyBsaW1pdGUgZGUgZXhlY3XDp8OjbyBjb20gbyBjb21hbmRvIHN5cy5zZXRFeGVjdXRpb25MaW1pdChtcylcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc3ludGF4X2Vycm9yOlxuICAgICAgICAgICAgXCJFc3RhIG1lbnNhZ2VtIGluZGljYSBxdWUgUHl0aG9uIG7Do28gZW50ZW5kZXUgYSBzaW50YXhlIGRlIHVtIGNvbWFuZG8uIEFsZ3VucyBleGVtcGxvcyBzw6NvIGF0cmlidWnDp8OjbyBkZSB1bSBsaXRlcmFsLCBvdSB1bWEgY2hhbWFkYSBkZSBmdW7Dp8Ojb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJDaGVxdWUgYXMgYXRyaWJ1acOnw7VlcyBkZSBzZXUgcHJvZ3JhbWEgZSBjZXJ0aWZpcXVlLXNlIGRlIHF1ZSBvIGxhZG8gZXNxdWVyZG8gw6kgdW1hIHZhcmnDoXZlbCwgZSBuw6NvIHVtIGxpdGVyYWwgb3UgZnVuw6fDo28uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2tleV9lcnJvcjpcbiAgICAgICAgICAgIFwiRXN0YSBtZW5zYWdlbSBpbmRpY2EgcXVlIHZvY8OqIGVzdMOhIHRlbnRhbmRvIGFjZXNzYXIgdW0gZWxlbWVudG8gY3VqYSBjaGF2ZSBuw6NvIGV4aXN0ZSBubyBkaWNpb27DoXJpby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiVm9jw6ogcG9kZSB0ZXIgdW0gZXJybyBkZSBkaWdpdGHDp8OjbyBubyBub21lIGRhIHN1YSBjaGF2ZS4gw4kgdW1hIGJvYSBwcsOhdGljYSBjaGVjYXIgc2UgYSBjaGF2ZSBleGlzdGUgdXNhbmRvIHVtIGNvbWFuZG8gJ2lmIChjaGF2ZSkgaW4gbWV1X2RpY2lvbmFyaW8nLiBWb2PDqiB0YW1iw6ltIHBvZGUgdXNhciBvIGNvbWFuZG8gJ21ldV9kaWNpb25hcmlvLmdldChjaGF2ZSwgdmFsb3JQYWRyw6NvKScgcGFyYSBvYnRlciBvIHZhbG9yIHBhZHLDo28gYW8gaW52w6lzIGRlIHVtIGVycm8gY2FzbyBhIGNoYXZlIG7Do28gZXhpc3RhLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbmRleF9lcnJvcjpcbiAgICAgICAgICAgIFwiVm9jw6ogZXN0w6EgdGVudGFuZG8gYWNlc3NhciB1bSDDrW5kaWNlIGFsw6ltIGRvIGZpbmFsIGRlIHVtYSBzdHJpbmcgb3UgbGlzdGEuIFBvciBleGVtcGxvLCBzZSBzdWEgbGlzdGEgcG9zc3VpIDMgZWxlbWVudG9zIG5lbGEgZSB2b2PDqiB0ZW50YSBhY2Vzc2FyIG8gaXRlbSBuYSBwb3Npw6fDo28gMyBvdSBtYWlzLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbmRleF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkxlbWJyZS1zZSBxdWUgbyBwcmltZWlybyBlbGVtZW50byBkZSB1bWEgbGlzdGEgb3Ugc3RyaW5nIGVzdMOhIG5vIMOtbmRpY2UgMCwgbm9ybWFsbWVudGUgZXN0YSBtZW5zYWdlbSDDqSBleGliaWRhIHBvcnF1ZSB2b2PDqiBlcnJvdSBvIMOtbmRpY2UgcG9yIDEuIEVtIHVtYSBsaXN0YSBkZSB0YW1hbmhvIDMsIG8gw7psdGltbyDDrW5kaWNlIHbDoWxpZG8gw6kgMlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV91cmlfZXJyb3I6IFwiXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3VyaV9lcnJvcl9maXg6IFwiXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvcjpcbiAgICAgICAgICAgIFwiRXN0YSBtZW5zYWdlbSBpbmRpY2EgcXVlIHZvY8OqIGVzdMOhIHRlbnRhbmRvIGltcG9ydGFyIHVtIG3Ds2R1bG8gcXVlIG7Do28gZXhpc3RlXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlVtIHByb2JsZW1hIHBvZGUgc2VyIGFwZW5hcyB1bSBlcnJvIGRlIGRpZ2l0YcOnw6NvLiBUYW1iw6ltIHBvZGUgc2VyIHF1ZSB2b2PDqiBlc3TDoSB0ZW50YW5kbyBpbXBvcnRhciB1bSBtw7NkdWxvIHF1ZSBleGlzdGUgZW0gUHl0aG9uICdyZWFsJywgbWFzIG7Do28gZXhpc3RlIG5lc3RlIGxpdnJvLiBTZSBlc3RlIMOpIG8gY2FzbywgcG9yIGZhdm9yIGVudmllIHVtIHBlZGlkbyBwYXJhIHRlciBlc3NlIG3Ds2R1bG8gYWRpY2lvbmFkby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yOlxuICAgICAgICAgICAgXCJJc3NvIHBhcmVjZSBzZXIgdW0gZXJybyBpbnRlcm5vLCBlc3BlY2lhbG1lbnRlIHNlIGEgbWVuc2FnZW0gZmF6IHJlZmVyw6puY2lhIGFvIGNvbnNvbGUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JlZmVyZW5jZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlRlbnRlIGF0dWFsaXphciBhIHDDoWdpbmEuIFNlIG8gZXJybyBwZXJzaXN0aXIsIGVudmllIHVtIHJlbGF0w7NyaW8gZGUgYnVnIGp1bnRvIGNvbSBzZXUgY8OzZGlnb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV96ZXJvX2RpdmlzaW9uX2Vycm9yOlxuICAgICAgICAgICAgXCJJc3NvIGRpeiBxdWUgdm9jw6ogZXN0w6EgdGVudGFuZG8gZGl2aWRpciBwb3IgMC4gTm9ybWFsbWVudGUgw6kgcG9ycXVlIG8gdmFsb3IgZGEgdmFyacOhdmVsIG5vIGRlbm9taW5hZG9yIGRlIHVtYSBkaXZpc8OjbyB0ZW0gbyB2YWxvciAwXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3plcm9fZGl2aXNpb25fZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJWb2PDqiBwb2RlIHByb3RlZ2VyIGNvbnRyYSBkaXZpZGlyIHBvciAwIGNvbSB1bSBjb21hbmRvICdpZicsIG91IHZvY8OqIHBvZGUgcHJlY2lzYXIgcmVhdmFsaWFyIHN1YXMgc3Vwb3Npw6fDtWVzIHNvYnJlIG9zIHZhbG9yZXMgZGFzIHZhcmnDoXZlaXMsIHBvaXMgdW0gY29tYW5kbyBhbnRlcmlvciBwb2RlIHRlciBpbmVzcGVyYWRhbWVudGUgYXRyaWJ1w61kbyBvIHZhbG9yIDAgYSBlc3NhIHZhcmnDoXZlbC5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmFuZ2VfZXJyb3I6XG4gICAgICAgICAgICBcIkVzdGEgbWVuc2FnZW0gcXVhc2Ugc2VtcHJlIGFwYXJlY2UgbmEgZm9ybWEgZGUgJ1RhbWFuaG8gbcOheGltbyBkYSBwaWxoYSBkZSBjaGFtYWRhcyBleGNlZGlkbycuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JhbmdlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiSXNzbyBzZW1wcmUgb2NvcnJlIHF1YW5kbyB1bWEgZnVuw6fDo28gY2hhbWEgZWxhIG1lc21hLiBQcm92YXZlbG1lbnRlIHZvY8OqIG7Do28gZXN0w6EgZmF6ZW5kbyBpc3NvIGRlIHByb3DDs3NpdG8sIGV4Y2V0byBubyBjYXDDrXR1bG8gc29icmUgcmVjdXJzw6NvLiBTZSB2b2PDqiBlc3TDoSBuZXNzZSBjYXDDrXR1bG8sIGVudMOjbyBwcm92YXZlbG1lbnRlIGFpbmRhIG7Do28gaWRlbnRpZmljb3UgdW0gYm9tIGNhc28gYmFzZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW50ZXJuYWxfZXJyb3I6XG4gICAgICAgICAgICBcIlVtIGVycm8gaW50ZXJubyBwb2RlIHNpZ25pZmljYXIgcXVlIHZvY8OqIGRlc2VuY2FkZW91IHVtIGJ1ZyBubyBub3NzbyBQeXRob25cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW50ZXJuYWxfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJSZXBvcnRlIGVzdGUgZXJybyBjb21vIHVtIGJ1ZywganVudGFtZW50ZSBjb20gc2V1IGPDs2RpZ29cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZW50YXRpb25fZXJyb3I6XG4gICAgICAgICAgICBcIkVzdGUgZXJybyBvY29ycmUgcXVhbmRvIHZvY8OqIG7Do28gaW5kZW50b3Ugc2V1IGPDs2RpZ28gZGV2aWRhbWVudGUuIElzc28gw6kgbWFpcyBwcm92w6F2ZWwgZGUgb2NvcnJlciBjb21vIHBhcnRlIGRlIHVtIGNvbWFuZG8gaWYsIGZvciwgd2hpbGUgb3UgZGVmLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbmRlbnRhdGlvbl9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZXF1ZSBzZXVzIGNvbWFuZG9zIGlmLCBkZWYsIGZvciBlIHdoaWxlIHBhcmEgdGVyIGNlcnRlemEgZGUgcXVlIGFzIGxpbmhhcyBlc3TDo28gZGV2aWRhbWVudGUgaW5kZW50YWRhcyBhYmFpeG8gZGVsYXMuIE91dHJhIGZvbnRlIGRlc3RlIGVycm8gw6kgY29waWFyIGUgY29sYXIgY8OzZGlnbyBlbSBxdWUgdm9jw6ogYWNpZGVudGFsbWVudGUgZGVpeG91IHJlc3RvcyBkZSBjw7NkaWdvIHF1ZSBuw6NvIHBlcnRlbmNlbSBtYWlzIGFsaS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm90X2ltcGxlbWVudGVkX2Vycm9yOlxuICAgICAgICAgICAgXCJFc3RlIGVycm8gb2NvcnJlIHF1YW5kbyB2b2PDqiB0ZW50YSB1c2FyIHVtYSBmdW7Dp8OjbyBlbWJ1dGlkYSBkZSBQeXRob24gcXVlIG7Do28gZm9pIGltcGxlbWVudGFkYSBuZXN0YSB2ZXJzw6NvIGJyb3dzZXIgZGUgUHl0aG9uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ub3RfaW1wbGVtZW50ZWRfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJQb3IgZW5xdWFudG8gYSDDum5pY2EgbWFuZWlyYSBkZSBjb25zZXJ0YXIgaXNzbyDDqSBuw6NvIHVzYW5kbyBhIGZ1bsOnw6NvLiBQb2RlbSBoYXZlciBzb2x1w6fDtWVzIGFsdGVybmF0aXZhcy4gU2Ugdm9jw6ogcmVhbG1lbnRlIHByZWNpc2EgZGVzdGEgZnVuw6fDo28gZW1idXRpZGEsIGVudmllLW5vcyB1bSByZWxhdMOzcmlvIGRlIGJ1ZyBlIGRpZ2FjIG9tbyBlc3TDoSB0ZW50YW5kbyB1c2FyIGEgZnVuw6fDo28uXCIsXG5cbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfZmlsZV9ub3RfZm91bmQ6IFwiQXJxdWl2byBuw6NvIGVuY29udHJhZG86ICckMSdcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fZmlsZV9vcl9kaXI6XG4gICAgICAgICAgICBcIltFcnJvIG7CuiAyXSBBcnF1aXZvIG91IGRpcmV0w7NyaW8gaW5leGlzdGVudGU6ICckMSdcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc3RhcnRpbmc6IFwiQ2xpcXVlIG5vIGJvdMOjbyBkZSBleGVjdcOnw6NvIHBhcmEgY29tZcOnYXIgJDFcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGxheWluZzogXCJFeGVjdXRhbmRvICQxXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRpbmdfYXVkaW86XG4gICAgICAgICAgICBcIkNhcnJlZ2FuZG8gw6F1ZGlvLiBQb3IgZmF2b3IsIGVzcGVyZS4gU2UgbyB0b3VyIG7Do28gY29tZcOnYXIgbG9nbywgY2xpcXVlIGVtICdTdG9wIFRvdXInIGUgdGVudGUgbm92YW1lbnRlLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXVzZV9jdXJyZW50X2F1ZGlvOiBcIlBhdXNhciDDoXVkaW8gYXR1YWxcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGF1c2VfYXVkaW86IFwiUGF1c2FyIMOhdWRpb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wbGF5X3BhdXNlZF9hdWRpbzogXCJSZXByb2R1emlyIMOhdWRpbyBwYXVzYWRvXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2F1ZGlvX3BhdXNlZDpcbiAgICAgICAgICAgIFwiJDEgZm9pIHBhdXNhZG8uIENsaXF1ZSBubyBib3TDo28gZGUgZXhlY3XDp8OjbyBwYXJhIHJldG9tYXIgbyB0b3VyLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnB1dF9wcmc6IFwiRW50cmFkYSBwYXJhIG8gcHJvZ3JhbWFcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfd2VyZV9jb21waWxpbmdfZXJyOlxuICAgICAgICAgICAgXCJIb3V2ZXJhbSBlcnJvcyBhbyBjb21waWxhciBzZXUgY8OzZGlnby4gVmVqYSBhYmFpeG8uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXhjOiBcIkxpbWl0ZSBkZSB0ZW1wbyBleGNlZGlkbyBubyBzZXUgcHJvZ3JhbWFcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2VydmVyX2VycjogXCJVbSBlcnJvIGRlIHNlcnZpZG9yIG9jb3JyZXU6ICQxICQyXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2NvbXBpbGluZ19ydW5uaW5nOlxuICAgICAgICAgICAgXCJDb21waWxhbmRvIGUgZXhlY3V0YW5kbyBzZXUgY8OzZGlnby4uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zZXJ2ZXJfY29tbV9lcnI6IFwiRXJybyBhbyBjb211bmljYXIgY29tIG8gc2Vydmlkb3IuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3NhdmVfcnVuOiBcIlNhbHZhciAmIEV4ZWN1dGFyXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JlbmRlcjogXCJTYWx2YXIgJiBSZW5kZXJpemFyXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvcjpcbiAgICAgICAgICAgIFwiVW0gZXJybyBkZSBhc3NlcsOnw6NvIG9jb3JyZSBxdWFuZG8gcHl0aG9uIGVuY29udHJhIHVtIGNvbWFuZG8gJ2Fzc2VydCcuIFB5dGhvbiBhdmFsaWEgYSBleHByZXNzw6NvIGRvIGxhZG8gZGlyZWl0bzsgc2Ugw6kgdmVyZGFkZWlyYSwgbyBwcm9ncmFtYSBjb250aW51YSBub3JtYWxtZW50ZS4gU2Ugw6kgZmFsc2EsIHB5dGhvbiBnZXJhIHVtIGVycm8gZSBwYXJhIGEgZXhlY3XDp8Ojby5cIiAsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZXF1ZSBhIGV4cHJlc3PDo28gZG8gbGFkbyBkaXJlaXRvIGRlICdhc3NlcnQnLiBFc3NhIGV4cHJlc3PDo28gw6kgZmFsc2EgZSDDqSBwcmVjaXNvIHZlcmlmaWNhciBvIG1vdGl2by4gVm9jw6ogcG9kZSBxdWVyZXIgaW1wcmltaXIgY2FkYSBwYXJ0ZSBkYSBleHByZXNzw6NvIGUgZW50ZW5kZXIgcG9ycXVlIMOpIGZhbHNhLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkX2RiOiBcIkNhcnJlZ2FuZG8gYmFuY28gZGUgZGFkb3MuLi5cIixcbiAgICB9LFxufSk7XG4iLCIkLmkxOG4oKS5sb2FkKHtcbiAgICBcInNyLUN5cmxcIjoge1xuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkX2hpc3Rvcnk6IFwi0KPRh9C40YLQsNGYINC40YHRgtC+0YDQuNGY0YNcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fdG91cjogXCLQkNGD0LTQuNC+INGC0YPRgNCwXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRlZF9jb2RlOiBcItCS0LDRiCDQuNC30LLQvtGA0L3QuCDQutC+0LQg0ZjQtSDRg9GH0LjRgtCw0L0uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25vX3NhdmVkX2NvZGU6IFwi0J3QtSDQv9C+0YHRgtC+0ZjQuCDRgdC90LjQvNGZ0LXQvSDQutC+0LQuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3J1bl9jb2RlOiBcItCf0L7QutGA0LXQvdC4INC/0YDQvtCz0YDQsNC8XCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfZmVlZGJhY2s6IFwi0J/RgNC40LrQsNC20Lgg0YDQtdC30YPQu9GC0LDRglwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2NvZGU6IFwi0J/RgNC40LrQsNC20Lgg0LrQvtC0XCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2hpZGVfY29kZTogXCLQl9Cw0YLQstC+0YDQuCDQutC+0LRcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlbGVuczogXCLQmtC+0YDQsNC6INC/0L4g0LrQvtGA0LDQulwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2luX2NvZGVsZW5zOiBcItCa0L7RgNCw0Log0L/QviDQutC+0YDQsNC6XCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2hpZGVfY29kZWxlbnM6IFwi0JfQsNGC0LLQvtGA0Lgg0LrQvtGA0LDQuiDQv9C+INC60L7RgNCw0LpcIixcblxuICAgICAgICBtc2dfc2N0aXZlY29kZV9wYXJzZV9lcnJvcjpcbiAgICAgICAgICAgIFwi0KHQuNC90YLQsNC60YHQvdCwINCz0YDQtdGI0LrQsCAocGFyc2UgZXJyb3IpINC30L3QsNGH0Lgg0LTQsCDQn9Cw0ZjRgtC+0L0g0L3QtSDRgNCw0LfRg9C80LUg0YHQuNC90YLQsNC60YHRgyDRgyDQu9C40L3QuNGY0Lgg0LrQvtCz0LAg0L3QsCDQutC+0ZjRgyDQv9C+0YDRg9C60LAg0L4g0LPRgNC10YjRhtC4INGD0LrQsNC30YPRmNC1LiDQotC40L/QuNGH0L3QuCDQv9GA0LjQvNC10YDQuCDQvtCy0LDQutCy0LUg0LPRgNC10YjQutC1INGB0YMg0LfQsNCx0L7RgNCw0LLQu9GY0LXQvdCwINC00LLQvtGC0LDRh9C60LAg0LrQvtC0ICdpZicg0LjQu9C4ICdmb3InINC40YHQutCw0LfQsCDQuNC70Lgg0LfQsNCx0L7RgNCw0LLRmdC10L3QsCDQt9Cw0L/QtdGC0LAg0LjQt9C80LXRktGDINCw0YDQs9GD0LzQtdC90LDRgtCwINC60L7QtCDQv9C+0LfQuNCy0LAg0YTRg9C90LrRhtC40ZjQtVwiLFxuICAgICAgICBtc2dfc2N0aXZlY29kZV9wYXJzZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcItCU0LAg0LHQuNGB0YLQtSDQuNGB0L/RgNCw0LLQuNC70Lgg0YHQuNC90YLQsNC60YHQvdGDINCz0YDQtdGI0LrRgyDRgtGA0LXQsdCwINC/0LDQttGa0LjQstC+INC00LAg0L/QvtCz0LvQtdC00LDRgtC1INC70LjQvdC40ZjRgyDQuNC30LLQvtGA0L3QvtCzINC60L7QtNCwINC90LAg0LrQvtGY0YMg0YPQutCw0LfRg9GY0LUg0L/QvtGA0YPQs9CwINC+INCz0YDQtdGI0YbQuCDQuCDQvNC+0LbQtNCwINC/0YDQtdGC0YXQvtC00L3RgyDQu9C40L3QuNC90YMg0LjQt9Cy0L7RgNC90L7QsyDQutC+0LTQsC4g0J/RgNC+0LLQtdGA0LjRgtC1INC00LAg0LvQuCDRgdGDINC/0L7RiNGC0L7QstCw0L3QsCDRgdCy0LAg0YHQuNC90YLQsNC60YHQvdCwINC/0YDQsNCy0LjQu9CwINCf0LDRmNGC0L7QvdCwLlwiLFxuICAgIH0sXG59KTtcbiIsIi8qKlxuICpcbiAqIENyZWF0ZWQgYnkgYm1pbGxlciBvbiAzLzE5LzE1LlxuICovXG4vKiBEZWZpbmUgZ2xvYmFsIHZhcmlhYmxlcyBmb3IgRVNMaW50ICovXG4vKiBnbG9iYWwgU2sgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdW5lc3RvbmVCYXNlIGZyb20gXCIuLi8uLi9jb21tb24vanMvcnVuZXN0b25lYmFzZS5qc1wiO1xuaW1wb3J0IEF1ZGlvVG91ciBmcm9tIFwiLi9hdWRpb3RvdXIuanNcIjtcbmltcG9ydCBcIi4vYWN0aXZlY29kZS1pMThuLmVuLmpzXCI7XG5pbXBvcnQgXCIuL2FjdGl2ZWNvZGUtaTE4bi5wdC1ici5qc1wiO1xuaW1wb3J0IFwiLi9hY3RpdmVjb2RlLWkxOG4uc3ItQ3lybC5qc1wiO1xuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcImNvZGVtaXJyb3JcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS9weXRob24vcHl0aG9uLmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvY3NzL2Nzcy5qc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2h0bWxtaXhlZC9odG1sbWl4ZWQuanNcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0LmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvc3FsL3NxbC5qc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2NsaWtlL2NsaWtlLmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvb2N0YXZlL29jdGF2ZS5qc1wiO1xuaW1wb3J0IFwiLi8uLi9jc3MvYWN0aXZlY29kZS5jc3NcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuY3NzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL2hpbnQvc2hvdy1oaW50LmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL2hpbnQvc2hvdy1oaW50LmNzc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9oaW50L3NxbC1oaW50LmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL2hpbnQvYW55d29yZC1oaW50LmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2FkZG9uL2VkaXQvbWF0Y2hicmFja2V0cy5qc1wiO1xuaW1wb3J0IFwiLi9za3VscHQubWluLmpzXCI7XG5pbXBvcnQgXCIuL3NrdWxwdC1zdGRsaWIuanNcIjtcbi8vIFVzZWQgYnkgU2t1bHB0LlxuaW1wb3J0IGVtYmVkIGZyb20gXCJ2ZWdhLWVtYmVkXCI7XG4vLyBBZGFwdCBmb3IgdXNlIG91dHNpZGUgd2VicGFjayAtLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1lbWJlZC5cbndpbmRvdy52ZWdhRW1iZWQgPSBlbWJlZDtcblxudmFyIGlzTW91c2VEb3duID0gZmFsc2U7XG5kb2N1bWVudC5vbm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc01vdXNlRG93biA9IHRydWU7XG59O1xuXG5kb2N1bWVudC5vbm1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaXNNb3VzZURvd24gPSBmYWxzZTtcbn07XG53aW5kb3cuZWRMaXN0ID0ge307XG5cbnZhciBzb2NrZXQsIGNvbm5lY3Rpb24sIGRvYztcbnZhciBjaGF0Y29kZXNTZXJ2ZXIgPSBcImNoYXQuY29kZXNcIjtcblxuQ29kZU1pcnJvci5jb21tYW5kcy5hdXRvY29tcGxldGUgPSBmdW5jdGlvbiAoY20pIHtcbiAgICBjbS5zaG93SGludCh7IGhpbnQ6IENvZGVNaXJyb3IuaGludC5hbnl3b3JkIH0pO1xufTtcblxuLy8gc2VwYXJhdGUgaW50byBjb25zdHJ1Y3RvciBhbmQgaW5pdFxuZXhwb3J0IGNsYXNzIEFjdGl2ZUNvZGUgZXh0ZW5kcyBSdW5lc3RvbmVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB2YXIgc3VmZlN0YXJ0O1xuICAgICAgICB2YXIgb3JpZyA9ICQob3B0cy5vcmlnKS5maW5kKFwidGV4dGFyZWFcIilbMF07XG4gICAgICAgIHRoaXMuY29udGFpbmVyRGl2ID0gb3B0cy5vcmlnO1xuICAgICAgICB0aGlzLnVzZVJ1bmVzdG9uZVNlcnZpY2VzID0gb3B0cy51c2VSdW5lc3RvbmVTZXJ2aWNlcztcbiAgICAgICAgdGhpcy5weXRob24zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbGlnblZlcnRpY2FsID0gb3B0cy52ZXJ0aWNhbDtcbiAgICAgICAgdGhpcy5vcmlnRWxlbSA9IG9yaWc7XG4gICAgICAgIHRoaXMub3JpZ1RleHQgPSB0aGlzLm9yaWdFbGVtLnRleHRDb250ZW50O1xuICAgICAgICB0aGlzLmRpdmlkID0gb3B0cy5vcmlnLmlkO1xuICAgICAgICB0aGlzLmNvZGUgPSAkKG9yaWcpLnRleHQoKSB8fCBcIlxcblxcblxcblxcblxcblwiO1xuICAgICAgICB0aGlzLmxhbmd1YWdlID0gJChvcmlnKS5kYXRhKFwibGFuZ1wiKTtcbiAgICAgICAgdGhpcy50aW1lbGltaXQgPSAkKG9yaWcpLmRhdGEoXCJ0aW1lbGltaXRcIik7XG4gICAgICAgIHRoaXMuaW5jbHVkZXMgPSAkKG9yaWcpLmRhdGEoXCJpbmNsdWRlXCIpO1xuICAgICAgICB0aGlzLmhpZGVjb2RlID0gJChvcmlnKS5kYXRhKFwiaGlkZWNvZGVcIik7XG4gICAgICAgIHRoaXMuY2hhdGNvZGVzID0gJChvcmlnKS5kYXRhKFwiY2hhdGNvZGVzXCIpO1xuICAgICAgICB0aGlzLmhpZGVoaXN0b3J5ID0gJChvcmlnKS5kYXRhKFwiaGlkZWhpc3RvcnlcIik7XG4gICAgICAgIHRoaXMucXVlc3Rpb24gPSAkKG9wdHMub3JpZykuZmluZChgIyR7dGhpcy5kaXZpZH1fcXVlc3Rpb25gKVswXTtcbiAgICAgICAgdGhpcy50aWUgPSAkKG9yaWcpLmRhdGEoXCJ0aWVcIik7XG4gICAgICAgIHRoaXMuZGJ1cmwgPSAkKG9yaWcpLmRhdGEoXCJkYnVybFwiKTtcbiAgICAgICAgdGhpcy5ydW5CdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLmVuYWJsZWRvd25sb2FkID0gJChvcmlnKS5kYXRhKFwiZW5hYmxlZG93bmxvYWRcIik7XG4gICAgICAgIHRoaXMuZG93bmxvYWRCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLnNhdmVCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLm91dGVyRGl2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJ0bmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5ydW5Db3VudCA9IDA7XG4gICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IHRydWU7XG4gICAgICAgIGlmICghZUJvb2tDb25maWcuYWxsb3dfcGFpcnMgfHwgJChvcmlnKS5kYXRhKFwibm9wYWlyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBhcnRuZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUGFydG5lciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBjcmVhdGUgcHJlIGZvciBvdXRwdXRcbiAgICAgICAgdGhpcy5ncmFwaGljcyA9IG51bGw7IC8vIGNyZWF0ZSBkaXYgZm9yIHR1cnRsZSBncmFwaGljc1xuICAgICAgICB0aGlzLmNvZGVjb2FjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29kZWxlbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRyb2xEaXYgPSBudWxsO1xuICAgICAgICB0aGlzLmhpc3RvcnlTY3J1YmJlciA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZXN0YW1wcyA9IFtcIk9yaWdpbmFsXCJdO1xuICAgICAgICB0aGlzLmF1dG9ydW4gPSAkKG9yaWcpLmRhdGEoXCJhdXRvcnVuXCIpO1xuICAgICAgICBpZiAodGhpcy5jaGF0Y29kZXMgJiYgZUJvb2tDb25maWcuZW5hYmxlX2NoYXRjb2Rlcykge1xuICAgICAgICAgICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KFwid3NzOi8vXCIgKyBjaGF0Y29kZXNTZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IG5ldyB3aW5kb3cuc2hhcmVkYi5Db25uZWN0aW9uKHNvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgICAgIGRvYyA9IGNvbm5lY3Rpb24uZ2V0KFwiY2hhdGNvZGVzXCIsIFwiY2hhbm5lbHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JhZGVyYWN0aXZlIHx8IHRoaXMuaXNUaW1lZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlY29kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVzID0gdGhpcy5pbmNsdWRlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVmaXhFbmQgPSB0aGlzLmNvZGUuaW5kZXhPZihcIl5eXl5cIik7XG4gICAgICAgIGlmIChwcmVmaXhFbmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSB0aGlzLmNvZGUuc3Vic3RyaW5nKDAsIHByZWZpeEVuZCk7XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUuc3Vic3RyaW5nKHByZWZpeEVuZCArIDUpO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZTdGFydCA9IHRoaXMuY29kZS5pbmRleE9mKFwiPT09PVwiKTtcbiAgICAgICAgaWYgKHN1ZmZTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGUgKzUgZ2V0cyBwYXN0IHRoZSA9PT09XFxuXG4gICAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHRoaXMuY29kZS5zdWJzdHJpbmcoc3VmZlN0YXJ0ICsgNSk7XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUuc3Vic3RyaW5nKDAsIHN1ZmZTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW3RoaXMuY29kZV07XG4gICAgICAgIHRoaXMuY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlT3V0cHV0KCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udHJvbHMoKTtcbiAgICAgICAgaWYgKCQob3JpZykuZGF0YShcImNhcHRpb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdGlvbiA9ICQob3JpZykuZGF0YShcImNhcHRpb25cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhcHRpb24gPSBcIkFjdGl2ZUNvZGVcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENhcHRpb24oXCJydW5lc3RvbmVcIik7XG4gICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgMTAwMFxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5hdXRvcnVuKSB7XG4gICAgICAgICAgICAvLyBTaW11bGF0ZSBwcmVzc2luZyB0aGUgcnVuIGJ1dHRvbiwgc2luY2UgdGhpcyB3aWxsIGFsc28gcHJldmVudCB0aGUgdXNlciBmcm9tIGNsaWNraW5nIGl0IHVudGlsIHRoZSBpbml0aWFsIHJ1biBpcyBjb21wbGV0ZSwgYW5kIGFsc28gaGVscCB0aGUgdXNlciB1bmRlcnN0YW5kIHdoeSB0aGV5J3JlIHdhaXRpbmcuXG4gICAgICAgICAgICAkKHRoaXMucnVuQnV0dG9uSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGljYXRlX2NvbXBvbmVudF9yZWFkeSgpO1xuICAgICAgICBpZiAodHlwZW9mIFByaXNtICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcih0aGlzLmNvbnRhaW5lckRpdik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVFZGl0b3IoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5vdXRlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBsaW5rZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbGlua2Rpdi5pZCA9IHRoaXMuZGl2aWQucmVwbGFjZSgvXy9nLCBcIi1cIikudG9Mb3dlckNhc2UoKTsgLy8gOnJlZjogY2hhbmdlcyBfIHRvIC0gc28gYWRkIHRoaXMgYXMgYSB0YXJnZXRcbiAgICAgICAgdmFyIGNvZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAkKGNvZGVEaXYpLmFkZENsYXNzKFwiYWNfY29kZV9kaXYgY29sLW1kLTEyXCIpO1xuICAgICAgICB0aGlzLmNvZGVEaXYgPSBjb2RlRGl2O1xuICAgICAgICB0aGlzLm91dGVyRGl2LmxhbmcgPSB0aGlzLmxhbmd1YWdlO1xuICAgICAgICAkKHRoaXMub3JpZ0VsZW0pLnJlcGxhY2VXaXRoKHRoaXMub3V0ZXJEaXYpO1xuICAgICAgICBpZiAobGlua2Rpdi5pZCAhPT0gdGhpcy5kaXZpZCkge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgd2FudCB0aGUgJ2V4dHJhJyB0YXJnZXQgaWYgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQobGlua2Rpdik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChjb2RlRGl2KTtcbiAgICAgICAgdmFyIGVkbW9kZSA9IHRoaXMub3V0ZXJEaXYubGFuZztcbiAgICAgICAgaWYgKGVkbW9kZSA9PT0gXCJzcWxcIikge1xuICAgICAgICAgICAgZWRtb2RlID0gXCJ0ZXh0L3gtc3FsXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRtb2RlID09PSBcImphdmFcIikge1xuICAgICAgICAgICAgZWRtb2RlID0gXCJ0ZXh0L3gtamF2YVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGVkbW9kZSA9PT0gXCJjcHBcIikge1xuICAgICAgICAgICAgZWRtb2RlID0gXCJ0ZXh0L3gtYysrc3JjXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRtb2RlID09PSBcImNcIikge1xuICAgICAgICAgICAgZWRtb2RlID0gXCJ0ZXh0L3gtY3NyY1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGVkbW9kZSA9PT0gXCJweXRob24zXCIpIHtcbiAgICAgICAgICAgIGVkbW9kZSA9IFwicHl0aG9uXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRtb2RlID09PSBcIm9jdGF2ZVwiIHx8IGVkbW9kZSA9PT0gXCJNQVRMQUJcIikge1xuICAgICAgICAgICAgZWRtb2RlID0gXCJ0ZXh0L3gtb2N0YXZlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkaXRvciA9IENvZGVNaXJyb3IoY29kZURpdiwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuY29kZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogZWRtb2RlLFxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcbiAgICAgICAgICAgIG1hdGNoQnJhY2tldHM6IHRydWUsXG4gICAgICAgICAgICBhdXRvTWF0Y2hQYXJlbnM6IHRydWUsXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcbiAgICAgICAgICAgICAgICBUYWI6IFwiaW5kZW50TW9yZVwiLFxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgICAgICAgICAgIFwiQ3RybC1TcGFjZVwiOiBcImF1dG9jb21wbGV0ZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2UgdGhlIGVkaXRvciByZXNpemFibGVcbiAgICAgICAgJChlZGl0b3IuZ2V0V3JhcHBlckVsZW1lbnQoKSkucmVzaXphYmxlKHtcbiAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRTaXplKCQodGhpcykud2lkdGgoKSwgJCh0aGlzKS5oZWlnaHQoKSk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBnaXZlIHRoZSB1c2VyIGEgdmlzdWFsIGN1ZSB0aGF0IHRoZXkgaGF2ZSBjaGFuZ2VkIGJ1dCBub3Qgc2F2ZWRcbiAgICAgICAgZWRpdG9yLm9uKFxuICAgICAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgICAgIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFjRWRpdEV2ZW50ID09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5hY0VkaXRFdmVudCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBldmVudHMgY2FuIGNvbWUgYmVmb3JlIGFueSByZWFsIGNoYW5nZXMgZm9yIHZhcmlvdXMgcmVhc29ucywgc29tZSB1bmtub3duXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYXZvaWRzIHVubmVjY3NhcnkgbG9nIGV2ZW50cyBhbmQgdXBkYXRlcyB0byB0aGUgYWN0aXZpdHkgY291bnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXRQYXJlbnQgPT09IG51bGwgbWVhbnMgdGhhdCB0aGUgZWxlbWVudCBpcyBub3Qgb24gdGhlIHNjcmVlbiBhbmQgc28gY2FuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuY29udHJvbERpdi5vZmZzZXRQYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnVGV4dCA9PT0gZWRpdG9yLmdldFZhbHVlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkaW5nU2NydWJiZXJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZha2UgY2hhbmdlIGV2ZW50LCBza2lwcGluZyB0aGUgbG9nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQoZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkpLmNzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIycHggc29saWQgI2I0MzIzMlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICQoZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkpLmNzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIycHggc29saWQgI2I0MzIzMlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBbnN3ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0aW1lIHRoZSBzdHVkZW50IHR5cGVzIGluIHRoZSB3cml0ZS1jb2RlIGJveFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJhY3RpdmVjb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Q6IFwiZWRpdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWRpdG9yLmFjRWRpdEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApOyAvLyB1c2UgYmluZCB0byBwcmVzZXJ2ZSAqdGhpcyogaW5zaWRlIHRoZSBvbiBoYW5kbGVyLlxuICAgICAgICAvL1NvbHZpbmcgS2V5Ym9hcmQgVHJhcCBvZiBBY3RpdmVDb2RlOiBJZiB1c2VyIHVzZSB0YWIgZm9yIG5hdmlnYXRpb24gb3V0c2lkZSBvZiBBY3RpdmVDb2RlLCB0aGVuIGNoYW5nZSB0YWIgYmVoYXZpb3IgaW4gQWN0aXZlQ29kZSB0byBlbmFibGUgdGFiIHVzZXIgdG8gdGFiIG91dCBvZiB0aGUgdGV4dGFyZWFcbiAgICAgICAgJCh3aW5kb3cpLmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZS5rZXlDb2RlID8gZS5rZXlDb2RlIDogZS53aGljaDtcbiAgICAgICAgICAgIGlmIChjb2RlID09IDkgJiYgJChcInRleHRhcmVhOmZvY3VzXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb24oXCJleHRyYUtleXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBUYWI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KFwiLnRhYi1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5leHRTaWJsaW5nLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KFwiLnRhYi1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByZXZpb3VzU2libGluZy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIGlmICh0aGlzLmhpZGVjb2RlKSB7XG4gICAgICAgICAgICAkKHRoaXMuY29kZURpdikuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBydW5CdXR0b25IYW5kbGVyKCkge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBydW4gYnV0dG9uIHVudGlsIHRoZSBydW4gaXMgZmluaXNoZWQuXG4gICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuUHJvZygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgdGhlcmUgd2FzIGFuIGVycm9yICR7ZX0gcnVubmluZyB0aGUgY29kZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvZ1Jlc3VsdHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nQ3VycmVudEFuc3dlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyRmVlZGJhY2soKTtcbiAgICAgICAgLy8gVGhlIHJ1biBpcyBmaW5pc2hlZDsgcmUtZW5hYmxlIHRoZSBidXR0b24uXG4gICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnVuQ291bnQgKz0gMTtcbiAgICAgICAgdGhpcy50b2dnbGVBbGVydCgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvbnRyb2xzKCkge1xuICAgICAgICB2YXIgY3RybERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBidXR0O1xuICAgICAgICAkKGN0cmxEaXYpLmFkZENsYXNzKFwiYWNfYWN0aW9uc1wiKTtcbiAgICAgICAgJChjdHJsRGl2KS5hZGRDbGFzcyhcImNvbC1tZC0xMlwiKTtcbiAgICAgICAgLy8gUnVuXG4gICAgICAgIGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcnVuX2NvZGVcIikpO1xuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYnRuIGJ0bi1zdWNjZXNzIHJ1bi1idXR0b25cIik7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XG4gICAgICAgIHRoaXMucnVuQnV0dG9uID0gYnV0dDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJhZGRpbmcgY2xpY2sgZnVuY3Rpb24gZm9yIHJ1blwiKTtcbiAgICAgICAgdGhpcy5ydW5CdXR0b24ub25jbGljayA9IHRoaXMucnVuQnV0dG9uSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAkKGJ1dHQpLmF0dHIoXCJ0eXBlXCIsIFwiYnV0dG9uXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWRvd25sb2FkIHx8IGVCb29rQ29uZmlnLmRvd25sb2Fkc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRG93bmxvYWRCdXR0b24oY3RybERpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhpZGVjb2RlICYmICF0aGlzLmhpZGVoaXN0b3J5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhpc3RvcnlTY3J1YmJlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJCh0aGlzLm9yaWdFbGVtKS5kYXRhKFwiZ3JhZGVidXR0b25cIikgJiYgIXRoaXMuZ3JhZGVyYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZlZWRiYWNrQnV0dG9uKGN0cmxEaXYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3cvSGlkZSBDb2RlXG4gICAgICAgIGlmICh0aGlzLmhpZGVjb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUhpZGVTaG93KGN0cmxEaXYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvZGVMZW5zXG4gICAgICAgIGlmICgkKHRoaXMub3JpZ0VsZW0pLmRhdGEoXCJjb2RlbGVuc1wiKSAmJiAhdGhpcy5ncmFkZXJhY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQ29kZUxlbnMoY3RybERpdik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXVkaW8gVG91clxuICAgICAgICBpZiAoJCh0aGlzLm9yaWdFbGVtKS5kYXRhKFwiYXVkaW9cIikpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQXVkaW9Ub3VycyhjdHJsRGl2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZUJvb2tDb25maWcuaXNJbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUluc3RydWN0b3JTaGFyaW5nKGN0cmxEaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVBhcnRuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBQYXJ0bmVyKGN0cmxEaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYXRjb2RlcyAmJiBlQm9va0NvbmZpZy5lbmFibGVfY2hhdGNvZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUNoYXRDb2RlcyhjdHJsRGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcy5vdXRlckRpdikucHJlcGVuZChjdHJsRGl2KTtcbiAgICAgICAgaWYgKHRoaXMucXVlc3Rpb24pIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMucXVlc3Rpb24pLmh0bWwoKS5tYXRjaCgvXlxccyskLykpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMucXVlc3Rpb24pLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMub3V0ZXJEaXYpLnByZXBlbmQodGhpcy5xdWVzdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sRGl2ID0gY3RybERpdjtcbiAgICB9XG5cbiAgICBhZGRGZWVkYmFja0J1dHRvbihjdHJsRGl2KSB7XG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImFjX29wdCBidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgICQoYnV0dCkudGV4dCgkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zaG93X2ZlZWRiYWNrXCIpKTtcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XG4gICAgICAgICQoYnV0dCkuYXR0cihcInR5cGVcIiwgXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMuZ3JhZGVCdXR0b24gPSBidXR0O1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xuICAgICAgICAkKGJ1dHQpLmNsaWNrKHRoaXMuY3JlYXRlR3JhZGVTdW1tYXJ5LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGFkZERvd25sb2FkQnV0dG9uKGN0cmxEaXYpIHtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAkKGJ1dHQpLnRleHQoXCJEb3dubG9hZFwiKTtcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImJ0biBzYXZlLWJ1dHRvblwiKTtcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChidXR0KTtcbiAgICAgICAgdGhpcy5kb3dubG9hZEJ1dHRvbiA9IGJ1dHQ7XG4gICAgICAgICQoYnV0dCkuY2xpY2sodGhpcy5kb3dubG9hZEZpbGUuYmluZCh0aGlzLCB0aGlzLmxhbmd1YWdlKSk7XG4gICAgICAgICQoYnV0dCkuYXR0cihcInR5cGVcIiwgXCJidXR0b25cIik7XG4gICAgfVxuXG4gICAgZW5hYmxlSGlkZVNob3coY3RybERpdikge1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgJChidXR0KS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZVwiKSk7XG4gICAgICAgICQoYnV0dCkuY3NzKFwibWFyZ2luLWxlZnRcIiwgXCIxMHB4XCIpO1xuICAgICAgICAkKGJ1dHQpLmF0dHIoXCJ0eXBlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLnNob3dIaWRlQnV0dCA9IGJ1dHQ7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XG4gICAgICAgICQoYnV0dCkuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmNvZGVEaXYpLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpc3RvcnlTY3J1YmJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSGlzdG9yeVNjcnViYmVyKHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIucGFyZW50RWxlbWVudCkudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLnNob3dIaWRlQnV0dCkudGV4dCgpID09XG4gICAgICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZVwiKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuc2hvd0hpZGVCdXR0KS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfaGlkZV9jb2RlXCIpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLnNob3dIaWRlQnV0dCkudGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZVwiKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzLnJ1bkJ1dHRvbikuYXR0cihcImRpc2FibGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBlbmFibGVDb2RlTGVucyhjdHJsRGl2KSB7XG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImFjX29wdCBidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgICQoYnV0dCkudGV4dCgkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zaG93X2NvZGVsZW5zXCIpKTtcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XG4gICAgICAgIHRoaXMuY2xCdXR0b24gPSBidXR0O1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xuICAgICAgICAkKGJ1dHQpLmNsaWNrKHRoaXMuc2hvd0NvZGVsZW5zLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGVuYWJsZUF1ZGlvVG91cnMoY3RybERpdikge1xuICAgICAgICBsZXQgYnV0dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgICQoYnV0dCkuYWRkQ2xhc3MoXCJhY19vcHQgYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfYXVkaW9fdG91clwiKSk7XG4gICAgICAgICQoYnV0dCkuY3NzKFwibWFyZ2luLWxlZnRcIiwgXCIxMHB4XCIpO1xuICAgICAgICB0aGlzLmF0QnV0dG9uID0gYnV0dDtcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChidXR0KTtcbiAgICAgICAgJChidXR0KS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXcgQXVkaW9Ub3VyKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdmlkLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5vcmlnRWxlbSkuZGF0YShcImF1ZGlvXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGVuYWJsZUluc3RydWN0b3JTaGFyaW5nKGN0cmxEaXYpIHtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYnRuIGJ0bi1pbmZvXCIpO1xuICAgICAgICAkKGJ1dHQpLnRleHQoXCJTaGFyZSBDb2RlXCIpO1xuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcbiAgICAgICAgdGhpcy5zaGFyZUJ1dHQgPSBidXR0O1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xuICAgICAgICAkKGJ1dHQpLmNsaWNrKFxuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWNvbmZpcm0oXG4gICAgICAgICAgICAgICAgICAgICAgICBcIllvdSBhcmUgYWJvdXQgdG8gc2hhcmUgdGhpcyBjb2RlIHdpdGggQUxMIG9mIHlvdXIgc3R1ZGVudHMuICBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY29udGludWU/XCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBkaXZpZDogdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZzogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgIGVCb29rQ29uZmlnLmFqYXhVUkwgKyBcImJyb2FkY2FzdF9jb2RlLmpzb25cIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGV0IHBvc3RfcHJvbWlzZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSBhd2FpdCBwb3N0X3Byb21pc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMubWVzcyA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoYFNoYXJlZCBDb2RlIHdpdGggJHtzdGF0dXMuc2hhcmVfY291bnR9IHN0dWRlbnRzYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJTaGFyaW5nIEZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXR1cFBhcnRuZXIoY3RybERpdikge1xuICAgICAgICB2YXIgY2hlY2tQYXJ0bmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBjaGVja1BhcnRuZXIudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgY2hlY2tQYXJ0bmVyLmlkID0gYCR7dGhpcy5kaXZpZH1fcGFydGA7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoY2hlY2tQYXJ0bmVyKTtcbiAgICAgICAgdmFyIHBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgcGxhYmVsLmZvciA9IGAke3RoaXMuZGl2aWR9X3BhcnRgO1xuICAgICAgICAkKHBsYWJlbCkudGV4dChcIlBhaXI/XCIpO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKHBsYWJlbCk7XG4gICAgICAgICQoY2hlY2tQYXJ0bmVyKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJ0bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydG5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkKHBhcnRuZXJUZXh0Qm94KS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydG5lciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRuZXJUZXh0Qm94LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgJChwbGFiZWwpLnRleHQoXCJQYWlyP1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlkQWdyZWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInBhcnRuZXJBZ3JlZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWRBZ3JlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkQWdyZWUgPSBjb25maXJtKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUGFpciBQcm9ncmFtbWluZyBzaG91bGQgb25seSBiZSB1c2VkIHdpdGggdGhlIGNvbnNlbnQgb2YgeW91ciBpbnN0cnVjdG9yLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJZb3VyIHBhcnRuZXIgbXVzdCBiZSBhIHJlZ2lzdGVyZWQgbWVtYmVyIG9mIHRoZSBjbGFzcyBhbmQgaGF2ZSBhZ3JlZWQgdG8gcGFpciB3aXRoIHlvdS5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQnkgY2xpY2tpbmcgT0sgeW91IGNlcnRpZnkgdGhhdCBib3RoIG9mIHRoZXNlIGNvbmRpdGlvbnMgaGF2ZSBiZWVuIG1ldC5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWRBZ3JlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwicGFydG5lckFncmVlXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydG5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICQocGxhYmVsKS50ZXh0KFwid2l0aDogXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKHBhcnRuZXJUZXh0Qm94KS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBwYXJ0bmVyVGV4dEJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgcGFydG5lclRleHRCb3gudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKHBhcnRuZXJUZXh0Qm94KTtcbiAgICAgICAgJChwYXJ0bmVyVGV4dEJveCkuaGlkZSgpO1xuICAgICAgICAkKHBhcnRuZXJUZXh0Qm94KS5jaGFuZ2UoXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0bmVyID0gcGFydG5lclRleHRCb3gudmFsdWU7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IG9ic29sZXRlLiAgTm90IHN1cmUgaWYgYW55b25lIGF0IE1pY2hpZ2FuIHdpbGwgY29tZSBiYWNrXG4gICAgLy8gdG8gd29ya2luZyBvbiB0aGlzIGFnYWluLlxuICAgIGVuYWJsZUNoYXRDb2RlcyhjdHJsRGl2KSB7XG4gICAgICAgIHZhciBjaGF0QmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIGNoYW5uZWxzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHZhciB0b3BpYyA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgXCItXCIgKyB0aGlzLmRpdmlkO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGNoYXRCYXIpO1xuICAgICAgICAkKGNoYXRCYXIpLnRleHQoXCJDaGF0OiBcIik7XG4gICAgICAgICQoY2hhdEJhcikuYXBwZW5kKGNoYW5uZWxzKTtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImFjX29wdCBidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgICQoYnV0dCkudGV4dChcIkNyZWF0ZSBDaGFubmVsXCIpO1xuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcbiAgICAgICAgJChidXR0KS5hdHRyKFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpO1xuICAgICAgICAkKGJ1dHQpLmF0dHIoXG4gICAgICAgICAgICBcImhyZWZcIixcbiAgICAgICAgICAgIFwiaHR0cDovL1wiICtcbiAgICAgICAgICAgICAgICBjaGF0Y29kZXNTZXJ2ZXIgK1xuICAgICAgICAgICAgICAgIFwiL25ldz9cIiArXG4gICAgICAgICAgICAgICAgJC5wYXJhbSh7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljOiB3aW5kb3cubG9jYXRpb24uaG9zdCArIFwiLVwiICsgdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZzogXCJQeXRob25cIixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNoYXRCdXR0b24gPSBidXR0O1xuICAgICAgICBjaGF0QmFyLmFwcGVuZENoaWxkKGJ1dHQpO1xuICAgICAgICB2YXIgdXBkYXRlQ2hhdENvZGVzQ2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRvYy5kYXRhO1xuICAgICAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICAgICAgJChjaGFubmVscykuaHRtbChcIlwiKTtcbiAgICAgICAgICAgIGRhdGFbXCJjaGFubmVsc1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFubmVsLmFyY2hpdmVkICYmIHRvcGljID09PSBjaGFubmVsLnRvcGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rID0gJChcIjxhIC8+XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly9cIiArIGNoYXRjb2Rlc1NlcnZlciArIFwiL1wiICsgY2hhbm5lbC5jaGFubmVsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbGluay5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnRleHQoXCIgXCIgKyBjaGFubmVsLmNoYW5uZWxOYW1lICsgXCIoXCIgKyBpICsgXCIpIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgJChjaGFubmVscykuYXBwZW5kKGxpbmspO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICQoY2hhbm5lbHMpLnRleHQoXCIobm8gYWN0aXZlIGNvbnZlcnN0YXRpb25zIG9uIHRoaXMgcHJvYmxlbSlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvYy5zdWJzY3JpYmUodXBkYXRlQ2hhdENvZGVzQ2hhbm5lbHMpO1xuICAgICAgICBkb2Mub24oXCJvcFwiLCB1cGRhdGVDaGF0Q29kZXNDaGFubmVscyk7XG4gICAgfVxuXG4gICAgZW5hYmxlU2F2ZUxvYWQoKSB7XG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2F2ZV9ydW5cIikpO1xuICAgIH1cblxuICAgIC8vIF9gYWRkSGlzdG9yeVNjcnViYmVyYFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFjdGl2ZWNvZGUgLS0gSWYgdGhlIGNvZGUgaGFzIG5vdCBjaGFuZ2VkIHdydCB0aGUgc2NydWJiZXIgcG9zaXRpb24gdmFsdWUgdGhlbiBkb24ndCBzYXZlIHRoZSBjb2RlIG9yIHJlcG9zaXRpb24gdGhlIHNjcnViYmVyXG4gICAgLy8gIC0tIHN0aWxsIGNhbGwgcnVubG9nLCBidXQgYWRkIGEgcGFyYW1ldGVyIHRvIG5vdCBzYXZlIHRoZSBjb2RlXG4gICAgLy8gYWRkIGFuIGluaXRpYWwgbG9hZCBoaXN0b3J5IGJ1dHRvblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGVkaXQgdGhlbiB0aGVyZSBpcyBubyBhcHBlbmQgICB0b19zYXZlIChUcnVlL0ZhbHNlKVxuICAgIGFzeW5jIGFkZEhpc3RvcnlTY3J1YmJlcihwb3NfbGFzdCkge1xuICAgICAgICB0aGlzLmFkZGluZ1NjcnViYmVyID0gdHJ1ZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB2YXIgcmVxRGF0YSA9IHtcbiAgICAgICAgICAgIGFjaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnNpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXFEYXRhW1wic2lkXCJdID0gdGhpcy5zaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJiZWZvcmUgZ2V0IGhpc3RcIik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGVCb29rQ29uZmlnLnByYWN0aWNlX21vZGUgfHxcbiAgICAgICAgICAgICFlQm9va0NvbmZpZy5pc0xvZ2dlZEluIHx8XG4gICAgICAgICAgICAodGhpcy5pc1RpbWVkICYmICF0aGlzLmFzc2Vzc21lbnRUYWtlbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRpbWVkIGFuZCBhbHJlYWR5IHRha2VuIHdlIHNob3VsZCByZXN0b3JlIGhpc3RvcnkgaW5mb1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTY3J1YmJlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcbiAgICAgICAgICAgICAgICBgJHtlQm9va0NvbmZpZy5uZXdfc2VydmVyX3ByZWZpeH0vYXNzZXNzbWVudC9nZXRoaXN0YCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcURhdGEpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGdldCB0aGUgaGlzdG9yeSBkYXRhOiAke2RhdGEuZGV0YWlsfWBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhpc3RvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmhpc3RvcnkuY29uY2F0KGRhdGEuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gZGF0YS50aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShkYXRhLnRpbWVzdGFtcHNbdF0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVuYWJsZSB0byBmZXRjaCBoaXN0b3J5OiAke2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbmRlclNjcnViYmVyKHBvc19sYXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZGluZ1NjcnViYmVyID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbiAgICB9XG5cbiAgICByZW5kZXJTY3J1YmJlcihwb3NfbGFzdCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm1ha2luZyBhIG5ldyBzY3J1YmJlclwiKTtcbiAgICAgICAgdmFyIHNjcnViYmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgJChzY3J1YmJlckRpdikuY3NzKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKTtcbiAgICAgICAgJChzY3J1YmJlckRpdikuY3NzKFwibWFyZ2luLWxlZnRcIiwgXCIxMHB4XCIpO1xuICAgICAgICAkKHNjcnViYmVyRGl2KS5jc3MoXCJtYXJnaW4tcmlnaHRcIiwgXCIxMHB4XCIpO1xuICAgICAgICAkKHNjcnViYmVyRGl2KS5jc3Moe1xuICAgICAgICAgICAgXCJtaW4td2lkdGhcIjogXCIyMDBweFwiLFxuICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogXCIzMDBweFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNjcnViYmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXBQID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMuc2xpZGVpdCA9IGZ1bmN0aW9uIChldiwgZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRoaXMuaGlzdG9yeVskKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKV0pO1xuICAgICAgICAgICAgdmFyIGN1clZhbCA9IHRoaXMudGltZXN0YW1wc1skKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKV07XG4gICAgICAgICAgICBsZXQgcG9zID0gJChzY3J1YmJlcikuc2xpZGVyKFwidmFsdWVcIik7XG4gICAgICAgICAgICBsZXQgb3V0T2YgPSB0aGlzLmhpc3RvcnkubGVuZ3RoO1xuICAgICAgICAgICAgJCh0aGlzLnRpbWVzdGFtcFApLnRleHQoYCR7Y3VyVmFsfSAtICR7cG9zICsgMX0gb2YgJHtvdXRPZn1gKTtcbiAgICAgICAgICAgIC8vIGEgc2xpZGUgd2lsbCBhbHNvIHJlc3VsdCBpbiBhIHNsaWRlY2hhbmdlIGV2ZW50IHdlIGRvbid0IHdhbnQgdG8gZG91YmxlXG4gICAgICAgICAgICAvLyBsb2cgdGhlc2UgZXZlbnRzLiAgU28gZG8gbm90IGxvZyB0aGUgc2xpZGUgdW50aWwgaXQgc3RvcHMgYW5kIGNyZWF0ZXMgdGhlIGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChldiAhPT0gbnVsbCAmJiBldi50eXBlICE9IFwic2xpZGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYWN0aXZlY29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Q6IFwic2xpZGU6XCIgKyBjdXJWYWwsXG4gICAgICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJChzY3J1YmJlcikuc2xpZGVyKHtcbiAgICAgICAgICAgIG1heDogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXG4gICAgICAgIH0pO1xuICAgICAgICAkKHNjcnViYmVyKS5jc3MoXCJtYXJnaW5cIiwgXCIxMHB4XCIpO1xuICAgICAgICAkKHNjcnViYmVyKS5vbihcInNsaWRlXCIsIHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgJChzY3J1YmJlcikub24oXCJzbGlkZWNoYW5nZVwiLCB0aGlzLnNsaWRlaXQuYmluZCh0aGlzKSk7XG4gICAgICAgIHNjcnViYmVyRGl2LmFwcGVuZENoaWxkKHNjcnViYmVyKTtcbiAgICAgICAgc2NydWJiZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy50aW1lc3RhbXBQKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkZWFkbGluZSBzZXQgdGhlbiBwb3NpdGlvbiB0aGUgc2NydWJiZXIgYXQgdGhlIGxhc3Qgc3VibWlzc2lvblxuICAgICAgICAvLyBwcmlvciB0byB0aGUgZGVhZGxpbmVcbiAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmUpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMuaGlzdG9yeS5sZW5ndGggJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUodGhpcy50aW1lc3RhbXBzW2ldKSA+IHRoaXMuZGVhZGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBpIC0gMTtcbiAgICAgICAgICAgIHNjcnViYmVyLnZhbHVlID0gTWF0aC5tYXgoaSwgMCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0aGlzLmhpc3Rvcnlbc2NydWJiZXIudmFsdWVdKTtcbiAgICAgICAgICAgICQoc2NydWJiZXIpLnNsaWRlcihcInZhbHVlXCIsIHNjcnViYmVyLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NfbGFzdCkge1xuICAgICAgICAgICAgc2NydWJiZXIudmFsdWUgPSB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRoaXMuaGlzdG9yeVtzY3J1YmJlci52YWx1ZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NydWJiZXIudmFsdWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb3MgPSAkKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKTtcbiAgICAgICAgbGV0IG91dE9mID0gdGhpcy5oaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgbGV0IHRzID0gdGhpcy50aW1lc3RhbXBzWyQoc2NydWJiZXIpLnNsaWRlcihcInZhbHVlXCIpXTtcbiAgICAgICAgJCh0aGlzLnRpbWVzdGFtcFApLnRleHQoYCR7dHN9IC0gJHtwb3MgKyAxfSBvZiAke291dE9mfWApO1xuICAgICAgICB0aGlzLmhpc3RvcnlTY3J1YmJlciA9IHNjcnViYmVyO1xuICAgICAgICAkKHNjcnViYmVyRGl2KS5pbnNlcnRBZnRlcih0aGlzLnJ1bkJ1dHRvbik7XG4gICAgfSAvLyBlbmQgZGVmaW5pdGlvbiBvZiBoZWxwZXJcblxuICAgIGNyZWF0ZU91dHB1dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcGFyZW50IGRpdiB3aXRoIHR3byBlbGVtZW50czogIHByZSBmb3Igc3RhbmRhcmQgb3V0cHV0IGFuZCBhIGRpdlxuICAgICAgICAvLyB0byBob2xkIHR1cnRsZSBncmFwaGljcyBvdXRwdXQuICBXZSB1c2UgYSBkaXYgaW4gY2FzZSB0aGUgdHVydGxlIGNoYW5nZXMgZnJvbVxuICAgICAgICAvLyB1c2luZyBhIGNhbnZhcyB0byB1c2luZyBzb21lIG90aGVyIGVsZW1lbnQgbGlrZSBzdmcgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgdmFyIG91dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImFjX291dHB1dCBjb2wtbWQtMTJcIik7XG4gICAgICAgIHRoaXMub3V0RGl2ID0gb3V0RGl2O1xuICAgICAgICB0aGlzLm91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgIHRoaXMub3V0cHV0LmlkID0gdGhpcy5kaXZpZCArIFwiX3N0ZG91dFwiO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5pZCA9IHRoaXMuZGl2aWQgKyBcIl9ncmFwaGljc1wiO1xuICAgICAgICAkKHRoaXMuZ3JhcGhpY3MpLmFkZENsYXNzKFwiYWMtY2FudmFzXCIpO1xuICAgICAgICAvLyBUaGlzIGJpdCBvZiBtYWdpYyBhZGRzIGFuIGV2ZW50IHdoaWNoIHdhaXRzIGZvciBhIGNhbnZhcyBjaGlsZCB0byBiZSBjcmVhdGVkIG9uIG91clxuICAgICAgICAvLyBuZXdseSBjcmVhdGVkIGRpdi4gIFdoZW4gYSBjYW52YXMgY2hpbGQgaXMgYWRkZWQgd2UgYWRkIGEgbmV3IGNsYXNzIHNvIHRoYXQgdGhlIHZpc2libGVcbiAgICAgICAgLy8gY2FudmFzIGNhbiBiZSBzdHlsZWQgaW4gQ1NTLiAgV2hpY2ggYSB0aGUgbW9tZW50IG1lYW5zIGp1c3QgYWRkaW5nIGEgYm9yZGVyLlxuICAgICAgICAkKHRoaXMuZ3JhcGhpY3MpLm9uKFxuICAgICAgICAgICAgXCJET01Ob2RlSW5zZXJ0ZWRcIixcbiAgICAgICAgICAgIFwiY2FudmFzXCIsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmdyYXBoaWNzKS5hZGRDbGFzcyhcInZpc2libGUtYWMtY2FudmFzXCIpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBjbGVhckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQoY2xlYXJEaXYpLmNzcyhcImNsZWFyXCIsIFwiYm90aFwiKTsgLy8gbmVlZGVkIHRvIG1ha2UgcGFyZW50IGRpdiByZXNpemUgcHJvcGVybHlcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChjbGVhckRpdik7XG4gICAgICAgIG91dERpdi5hcHBlbmRDaGlsZCh0aGlzLm91dHB1dCk7XG4gICAgICAgIG91dERpdi5hcHBlbmRDaGlsZCh0aGlzLmdyYXBoaWNzKTtcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChvdXREaXYpO1xuICAgICAgICB2YXIgbGVuc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGxlbnNEaXYuaWQgPSBgJHt0aGlzLmRpdmlkfV9jb2RlbGVuc2A7XG4gICAgICAgICQobGVuc0RpdikuYWRkQ2xhc3MoXCJjb2wtbWQtMTJcIik7XG4gICAgICAgICQobGVuc0RpdikuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIHRoaXMuY29kZWxlbnMgPSBsZW5zRGl2O1xuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGxlbnNEaXYpO1xuICAgICAgICB2YXIgY29hY2hEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAkKGNvYWNoRGl2KS5hZGRDbGFzcyhcImNvbC1tZC0xMlwiKTtcbiAgICAgICAgJChjb2FjaERpdikuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIHRoaXMuY29kZWNvYWNoID0gY29hY2hEaXY7XG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoY29hY2hEaXYpO1xuICAgICAgICBjbGVhckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQoY2xlYXJEaXYpLmNzcyhcImNsZWFyXCIsIFwiYm90aFwiKTsgLy8gbmVlZGVkIHRvIG1ha2UgcGFyZW50IGRpdiByZXNpemUgcHJvcGVybHlcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChjbGVhckRpdik7XG4gICAgfVxuXG4gICAgZGlzYWJsZVNhdmVMb2FkKCkge1xuICAgICAgICAkKHRoaXMuc2F2ZUJ1dHRvbikuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLnNhdmVCdXR0b24pLmF0dHIoXCJ0aXRsZVwiLCBcIkxvZ2luIHRvIHNhdmUgeW91ciBjb2RlXCIpO1xuICAgICAgICAkKHRoaXMubG9hZEJ1dHRvbikuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLmxvYWRCdXR0b24pLmF0dHIoXCJ0aXRsZVwiLCBcIkxvZ2luIHRvIGxvYWQgeW91ciBjb2RlXCIpO1xuICAgIH1cblxuICAgIGRvd25sb2FkRmlsZShsYW5nKSB7XG4gICAgICAgIHZhciBmbmIgPSB0aGlzLmRpdmlkO1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9XG4gICAgICAgICAgICBmbmIgK1xuICAgICAgICAgICAgXCJfXCIgK1xuICAgICAgICAgICAgZFxuICAgICAgICAgICAgICAgIC50b0pTT04oKVxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgMTApIC8vIHJldmVyc2UgZGF0ZSBmb3JtYXRcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCItXCIpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIikgK1xuICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgbGFuZ3VhZ2VFeHRlbnNpb25zW2xhbmddO1xuICAgICAgICB2YXIgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChcIkJsb2JcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0VG9Xcml0ZSA9IGNvZGUucmVwbGFjZSgvXFxuL2csIFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgdmFyIHRleHRGaWxlQXNCbG9iID0gbmV3IEJsb2IoW3RleHRUb1dyaXRlXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXCJtc1NhdmVPck9wZW5CbG9iXCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IodGV4dEZpbGVBc0Jsb2IsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5pbm5lckhUTUwgPSBcIkRvd25sb2FkIEZpbGVcIjtcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHRleHRGaWxlQXNCbG9iKTtcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIEhUTUw1IEJsb2IuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlR3JhZGVTdW1tYXJ5KCkge1xuICAgICAgICAvLyBnZXQgZ3JhZGUgYW5kIGNvbW1lbnRzIGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICAgICAgLy8gZ2V0IHN1bW1hcnkgb2YgYWxsIGdyYWRlcyBmb3IgdGhpcyBzdHVkZW50XG4gICAgICAgIC8vIGRpc3BsYXkgZ3JhZGVzIGluIG1vZGFsIHdpbmRvd1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChlQm9va0NvbmZpZy5hamF4VVJMICsgXCJnZXRhc3NpZ25tZW50Z3JhZGVcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJlcG9ydFsnbWVzc2FnZSddXG4gICAgICAgIGlmIChyZXBvcnQpIHtcbiAgICAgICAgICAgIGlmIChyZXBvcnRbXCJ2ZXJzaW9uXCJdID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgdmVyc2lvbjsgd291bGQgYmUgYmV0dGVyIHRvIGVtYmVkIHRoaXMgaW4gSFRNTCBmb3IgdGhlIGFjdGl2ZWNvZGVcbiAgICAgICAgICAgICAgICBib2R5ID1cbiAgICAgICAgICAgICAgICAgICAgXCI8aDQ+R3JhZGUgUmVwb3J0PC9oND5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiPHA+VGhpcyBxdWVzdGlvbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJncmFkZVwiXTtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0W1wicmVsZWFzZWRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSArPSBcIiBvdXQgb2YgXCIgKyByZXBvcnRbXCJtYXhcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkgKz0gXCI8L3A+IDxwPlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRbXCJyZWxlYXNlZFwiXSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ICs9IFwiUHJlbGltaW5hcnkgQ29tbWVudHM6IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib2R5ICs9IHJlcG9ydFtcImNvbW1lbnRcIl0gKyBcIjwvcD5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keSA9XG4gICAgICAgICAgICAgICAgICAgIFwiPGg0PkdyYWRlIFJlcG9ydDwvaDQ+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIjxwPlRoaXMgYXNzaWdubWVudDogXCIgK1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJncmFkZVwiXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8cD5cIiArXG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFtcImNvbW1lbnRcIl0gK1xuICAgICAgICAgICAgICAgICAgICBcIjwvcD5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiPHA+TnVtYmVyIG9mIGdyYWRlZCBhc3NpZ25tZW50czogXCIgK1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJjb3VudFwiXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8cD5BdmVyYWdlIHNjb3JlOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFtcImF2Z1wiXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IFwiPGg0PlRoZSBzZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IGdyYWRlIGluZm9ybWF0aW9uPC9oND5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaHRtbCA9IGA8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBjb21wYXJlLW1vZGFsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVwibW9kYWwtdGl0bGVcIj5Bc3NpZ25tZW50IEZlZWRiYWNrPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgJHtib2R5fVxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgIHZhciBlbCA9ICQoaHRtbCk7XG4gICAgICAgIGVsLm1vZGFsKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGFzeW5jIHNob3dDb2RlbGVucygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgdGhpcy5jbEJ1dHRvbi5pbm5lclRleHQgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVsZW5zXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB0aGlzLmNsQnV0dG9uLmlubmVyVGV4dCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfaW5fY29kZWxlbnNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsID0gdGhpcy5jb2RlbGVucy5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMucmVtb3ZlQ2hpbGQoY2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlID0gYXdhaXQgdGhpcy5idWlsZFByb2coZmFsc2UpO1xuICAgICAgICB2YXIgbXlWYXJzID0ge307XG4gICAgICAgIG15VmFycy5jb2RlID0gY29kZTtcbiAgICAgICAgbXlWYXJzLm9yaWdpbiA9IFwib3B0LWZyb250ZW5kLmpzXCI7XG4gICAgICAgIG15VmFycy5jdW11bGF0aXZlID0gZmFsc2U7XG4gICAgICAgIG15VmFycy5oZWFwUHJpbWl0aXZlcyA9IGZhbHNlO1xuICAgICAgICBteVZhcnMuZHJhd1BhcmVudFBvaW50ZXJzID0gZmFsc2U7XG4gICAgICAgIG15VmFycy50ZXh0UmVmZXJlbmNlcyA9IGZhbHNlO1xuICAgICAgICBteVZhcnMuc2hvd09ubHlPdXRwdXRzID0gZmFsc2U7XG4gICAgICAgIG15VmFycy5yYXdJbnB1dExzdEpTT04gPSBKU09OLnN0cmluZ2lmeShbXSk7XG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlID09IFwicHl0aG9uXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB5dGhvbjMpIHtcbiAgICAgICAgICAgICAgICBteVZhcnMucHkgPSAzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBteVZhcnMucHkgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFuZ2F1Z2UgPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgIG15VmFycy5weSA9IFwianNcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG15VmFycy5weSA9IHRoaXMubGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgbXlWYXJzLmN1ckluc3RyID0gMDtcbiAgICAgICAgbXlWYXJzLmNvZGVEaXZXaWR0aCA9IDM1MDtcbiAgICAgICAgbXlWYXJzLmNvZGVEaXZIZWlnaHQgPSA0MDA7XG4gICAgICAgIHZhciBzcmNVUkwgPSBcImh0dHBzOi8vcHl0aG9udHV0b3IuY29tL2lmcmFtZS1lbWJlZC5odG1sXCI7XG4gICAgICAgIHZhciBzcmNWYXJzID0gJC5wYXJhbShteVZhcnMpO1xuICAgICAgICB2YXIgZW1iZWRVcmxTdHIgPSBgJHtzcmNVUkx9IyR7c3JjVmFyc31gO1xuICAgICAgICB2YXIgbXlJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBteUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLmRpdmlkICsgXCJfY29kZWxlbnNcIik7XG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICAgICAgbXlJZnJhbWUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiNTAwXCIpO1xuICAgICAgICBteUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgICAgIG15SWZyYW1lLnN0eWxlLmJhY2tncm91bmQgPSBcIiNmZmZcIjtcbiAgICAgICAgLy9teUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIixzcmNVUkwpXG4gICAgICAgIG15SWZyYW1lLnNyYyA9IGVtYmVkVXJsU3RyO1xuICAgICAgICB0aGlzLmNvZGVsZW5zLmFwcGVuZENoaWxkKG15SWZyYW1lKTtcbiAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwiY29kZWxlbnNcIixcbiAgICAgICAgICAgIGFjdDogXCJ2aWV3XCIsXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyA8aWZyYW1lIGlkPVwiJShkaXZpZClzX2NvZGVsZW5zXCIgd2lkdGg9XCI4MDBcIiBoZWlnaHQ9XCI1MDBcIiBzdHlsZT1cImRpc3BsYXk6YmxvY2tcInNyYz1cIiNcIj5cbiAgICAvLyA8L2lmcmFtZT5cbiAgICBzaG93Q29kZUNvYWNoKCkge1xuICAgICAgICB2YXIgbXlJZnJhbWU7XG4gICAgICAgIHZhciBzcmNVUkw7XG4gICAgICAgIHZhciBjbDtcbiAgICAgICAgdmFyIGRpdl9pZCA9IHRoaXMuZGl2aWQ7XG4gICAgICAgIGlmICh0aGlzLmNvZGVjb2FjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb2RlY29hY2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5jb2RlY29hY2guc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICBjbCA9IHRoaXMuY29kZWNvYWNoLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjbCkge1xuICAgICAgICAgICAgdGhpcy5jb2RlY29hY2gucmVtb3ZlQ2hpbGQoY2wpO1xuICAgICAgICB9XG4gICAgICAgIHNyY1VSTCA9IGVCb29rQ29uZmlnLmFwcCArIFwiL2FkbWluL2RpZmZ2aWV3ZXI/ZGl2aWQ9XCIgKyBkaXZfaWQ7XG4gICAgICAgIG15SWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgbXlJZnJhbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgZGl2X2lkICsgXCJfY29hY2hcIik7XG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICAgICAgbXlJZnJhbWUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiNTAwcHhcIik7XG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcbiAgICAgICAgbXlJZnJhbWUuc3R5bGUuYmFja2dyb3VuZCA9IFwiI2ZmZlwiO1xuICAgICAgICBteUlmcmFtZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICBteUlmcmFtZS5zcmMgPSBzcmNVUkw7XG4gICAgICAgIHRoaXMuY29kZWNvYWNoLmFwcGVuZENoaWxkKG15SWZyYW1lKTtcbiAgICAgICAgJCh0aGlzLmNvZGVjb2FjaCkuc2hvdygpO1xuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJjb2FjaFwiLFxuICAgICAgICAgICAgYWN0OiBcInZpZXdcIixcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRWRpdG9yVmlzaWJpbGl0eSgpIHt9XG5cbiAgICBhZGRFcnJvck1lc3NhZ2UoZXJyKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgZXJyb3IgbWVzc2FnZVxuICAgICAgICB0aGlzLmVyckxhc3RSdW4gPSB0cnVlO1xuICAgICAgICB2YXIgZXJySGVhZCA9ICQoXCI8aDM+XCIpLmh0bWwoXCJFcnJvclwiKTtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyID0gdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwiZXJyb3IgYWxlcnQgYWxlcnQtZGFuZ2VyXCI7XG4gICAgICAgIHRoaXMuZUNvbnRhaW5lci5pZCA9IHRoaXMuZGl2aWQgKyBcIl9lcnJpbmZvXCI7XG4gICAgICAgIHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJIZWFkWzBdKTtcbiAgICAgICAgdmFyIGVyclRleHQgPSB0aGlzLmVDb250YWluZXIuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpXG4gICAgICAgICk7XG4gICAgICAgIC8vIEJ1dCwgYWRqdXN0IHRoZSBsaW5lIG51bWJlcnMuICBJZiB0aGUgbGluZSBudW1iZXIgaXMgPD0gcHJldGV4dExpbmVzIHRoZW4gaXQgaXMgaW4gaW5jbHVkZWQgY29kZVxuICAgICAgICAvLyBpZiBpdCBpcyBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBpbmNsdWRlZCBsaW5lcyBidXQgbGVzcyB0aGFuIHRoZSBwcmV0ZXh0ICsgY3VycmVudCBlZGl0b3IgdGhlbiBpdCBpcyBpbiB0aGUgc3R1ZGVudCBjb2RlLlxuICAgICAgICAvLyBhZGp1c3QgdGhlIGxpbmUgbnVtYmVyIHdlIGRpc3BsYXkgYnkgZWxpbWluYXRpbmcgdGhlIHByZS1pbmNsdWRlZCBjb2RlLlxuICAgICAgICBpZiAoZXJyLnRyYWNlYmFjay5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgdmFyIGVycm9yTGluZSA9IGVyci50cmFjZWJhY2tbMF0ubGluZW5vO1xuICAgICAgICAgICAgaWYgKGVycm9yTGluZSA8PSB0aGlzLnByZXRleHRMaW5lcykge1xuICAgICAgICAgICAgICAgIGVyclRleHQuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgaGlkZGVuLCBpbmNsdWRlZCBjb2RlLiBTb3JyeSB3ZSBjYW4ndCBnaXZlIHlvdSBhIG1vcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvckxpbmUgPiB0aGlzLnByb2dMaW5lcyArIHRoaXMucHJldGV4dExpbmVzKSB7XG4gICAgICAgICAgICAgICAgZXJyVGV4dC5pbm5lckhUTUwgPSBgQW4gZXJyb3Igb2NjdXJyZWQgYWZ0ZXIgdGhlIGVuZCBvZiB5b3VyIGNvZGUuXG5PbmUgcG9zc2libGUgcmVhc29uIGlzIHRoYXQgeW91IGhhdmUgYW4gdW5jbG9zZWQgcGFyZW50aGVzaXMgb3Igc3RyaW5nLlxuQW5vdGhlciBwb3NzaWJpbGl0eSBpcyB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBoaWRkZW4gdGVzdCBjb2RlLlxuWWV0IGFub3RoZXIgaXMgdGhhdCB0aGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvci4gIFRoZSBpbnRlcm5hbCBlcnJvciBtZXNzYWdlIGlzOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV0ZXh0TGluZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci50cmFjZWJhY2tbMF0ubGluZW5vID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci50cmFjZWJhY2tbMF0ubGluZW5vIC0gdGhpcy5wcmV0ZXh0TGluZXMgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyU3RyaW5nID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciB0byA9IGVyclN0cmluZy5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgdmFyIGVyck5hbWUgPSBlcnJTdHJpbmcuc3Vic3RyaW5nKDAsIHRvKTtcbiAgICAgICAgZXJyVGV4dC5pbm5lckhUTUwgPSBlcnJTdHJpbmc7XG4gICAgICAgICQodGhpcy5lQ29udGFpbmVyKS5hcHBlbmQoXCI8aDM+RGVzY3JpcHRpb248L2gzPlwiKTtcbiAgICAgICAgdmFyIGVyckRlc2MgPSB0aGlzLmVDb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikpO1xuICAgICAgICBlcnJEZXNjLmlubmVySFRNTCA9IGVycm9yVGV4dFtlcnJOYW1lXTtcbiAgICAgICAgJCh0aGlzLmVDb250YWluZXIpLmFwcGVuZChcIjxoMz5UbyBGaXg8L2gzPlwiKTtcbiAgICAgICAgdmFyIGVyckZpeCA9IHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSk7XG4gICAgICAgIGVyckZpeC5pbm5lckhUTUwgPSBlcnJvclRleHRbZXJyTmFtZSArIFwiRml4XCJdO1xuICAgICAgICB2YXIgbW9yZUluZm8gPSBcIi4uL0Vycm9ySGVscC9cIiArIGVyck5hbWUudG9Mb3dlckNhc2UoKSArIFwiLmh0bWxcIjtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJ1bnRpbWUgRXJyb3I6IFwiICsgZXJyLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBzZXRUaW1lTGltaXQodGltZXIpIHtcbiAgICAgICAgdmFyIHRpbWVsaW1pdCA9IHRoaXMudGltZWxpbWl0O1xuICAgICAgICBpZiAodGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZWxpbWl0ID0gdGltZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGV4ZWNMaW1pdCBpbiBtaWxsaXNlY29uZHMgIC0tIGZvciBzdHVkZW50IHByb2plY3RzIHNldCB0aGlzIHRvXG4gICAgICAgIC8vIDI1IHNlY29uZHMgLS0ganVzdCBsZXNzIHRoYW4gQ2hyb21lJ3Mgb3duIHRpbWVyLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmNvZGUuaW5kZXhPZihcIm9udGltZXJcIikgPiAtMSB8fFxuICAgICAgICAgICAgdGhpcy5jb2RlLmluZGV4T2YoXCJvbmNsaWNrXCIpID4gLTEgfHxcbiAgICAgICAgICAgIHRoaXMuY29kZS5pbmRleE9mKFwib25rZXlcIikgPiAtMSB8fFxuICAgICAgICAgICAgdGhpcy5jb2RlLmluZGV4T2YoXCJzZXREZWxheVwiKSA+IC0xXG4gICAgICAgICkge1xuICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aW1lbGltaXQgPT09IFwib2ZmXCIpIHtcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lbGltaXQpIHtcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXQgPSB0aW1lbGltaXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNrLmV4ZWNMaW1pdCA9IDI1MDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWx0aW5SZWFkKHgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgU2suYnVpbHRpbkZpbGVzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW3hdID09PSB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgICAgICAgdGhyb3cgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfZmlsZV9ub3RfZm91bmRcIiwgeCk7XG4gICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVt4XTtcbiAgICB9XG4gICAgZmlsZVJlYWRlcihkaXZpZCkge1xuICAgICAgICAvLyBJbiB0aGUgYmVnaW5uaW5nIGZpbGVzIHdlcmUganVzdCBwcmUgdGFncyBhbmQgd2UgdXNlZCB0aGUgZGl2aWQgYXMgdGhlIGZpbGVuYW1lXG4gICAgICAgIGxldCBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQpO1xuICAgICAgICAvLyBJbiBQcmVUZVh0IHdlIG1vdmVkIHRoYXQgdG8gYSBAZGF0YS1maWxlbmFtZVxuICAgICAgICBpZiAoZWxlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWZpbGVuYW1lPVwiJHtkaXZpZH1cIl1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IFwiXCI7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAoZWxlbSA9PSBudWxsICYmIFNrLmJ1aWx0aW5GaWxlcy5maWxlcy5oYXNPd25Qcm9wZXJ0eShkaXZpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtkaXZpZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0cnkgcmVtb3RlIGZpbGUgdW5sZXNzIGl0IGVuZHMgd2l0aCAuanMgb3IgLnB5IC0tIG90aGVyd2lzZSB3ZSdsbCBhc2sgdGhlIHNlcnZlciBmb3IgYWxsXG4gICAgICAgICAgICAvLyBraW5kcyBvZiBtb2R1bGVzIHRoYXQgd2UgYXJlIHRyeWluZyB0byBpbXBvcnRcbiAgICAgICAgICAgIGlmICghKGRpdmlkLmVuZHNXaXRoKFwiLmpzXCIpIHx8IGRpdmlkLmVuZHNXaXRoKFwiLnB5XCIpKSkge1xuICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBgL3J1bmVzdG9uZS9hamF4L2dldF9kYXRhZmlsZT9jb3Vyc2VfaWQ9JHtlQm9va0NvbmZpZy5jb3Vyc2V9JmFjaWQ9JHtkaXZpZH1gLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtID09IG51bGwgJiYgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX25vX2ZpbGVfb3JfZGlyXCIsIGRpdmlkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gZWFybHkgb24gd2UgaGFkIHRleHRhcmVhIHdpdGggdGhlIGRpdmlkIG9uIGl0LlxuICAgICAgICAgICAgLy8gYnV0IGxhdGVyIHRoaXMgc3dpdGNoZWQgdG8gYSBydW5lc3RvbmUgd3JhcHBlci4gIFNvIHdlIG1heSBuZWVkIHRvIGRpZyBmb3IgYSBwcmVcbiAgICAgICAgICAgIC8vIG9yIGEgdGV4dGFyZWE/XG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IFwidGV4dGFyZWFcIikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlbGVtLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlID0gZWxlbS5xdWVyeVNlbGVjdG9yKFwicHJlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHByZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZWxlbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIG91dHB1dGZ1bih0ZXh0KSB7XG4gICAgICAgIC8vIGJubSBweXRob24gM1xuICAgICAgICB2YXIgcHlTdHIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIHguam9pbihcIiwgXCIpICsgXCJdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgeCA9IHRleHQ7XG4gICAgICAgIGlmICghdGhpcy5weXRob24zKSB7XG4gICAgICAgICAgICBpZiAoeC5jaGFyQXQoMCkgPT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICB4ID0geC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgeCA9IFwiW1wiICsgeCArIFwiXVwiO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4bCA9IGV2YWwoeCk7XG4gICAgICAgICAgICAgICAgICAgIHhsID0geGwubWFwKHB5U3RyKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHhsLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcbiAgICAgICAgdGV4dCA9IHg7XG4gICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIjxici8+XCIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMub3V0cHV0KS5hcHBlbmQodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmaWxld3JpdGVyKGZvYmosIGJ5dGVzKSB7XG4gICAgICAgIGxldCBmaWxlY29tcG9uZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9iai5uYW1lKTtcbiAgICAgICAgaWYgKCFmaWxlY29tcG9uZW50KSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICQoY29udGFpbmVyKS5hZGRDbGFzcyhcInJ1bmVzdG9uZVwiKTtcbiAgICAgICAgICAgIGxldCB0YWIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgJCh0YWIpLmFkZENsYXNzKFwiZGF0YWZpbGVfY2FwdGlvblwiKTtcbiAgICAgICAgICAgIHRhYi5pbm5lckhUTUwgPSBgRGF0YSBmaWxlOiA8Y29kZT4ke2ZvYmoubmFtZX08L2NvZGU+YDtcbiAgICAgICAgICAgIGZpbGVjb21wb25lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgICAgICBmaWxlY29tcG9uZW50LnJvd3MgPSAxMDtcbiAgICAgICAgICAgIGZpbGVjb21wb25lbnQuY29scyA9IDUwO1xuICAgICAgICAgICAgZmlsZWNvbXBvbmVudC5pZCA9IGZvYmoubmFtZTtcbiAgICAgICAgICAgICQoZmlsZWNvbXBvbmVudCkuY3NzKFwibWFyZ2luLWJvdHRvbVwiLCBcIjVweFwiKTtcbiAgICAgICAgICAgICQoZmlsZWNvbXBvbmVudCkuYWRkQ2xhc3MoXCJhY19vdXRwdXRcIik7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGFiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxlY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb2JqLnBvcyQgPT0gMCkge1xuICAgICAgICAgICAgICAgICQoZmlsZWNvbXBvbmVudCkudmFsKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50ID0gJChmaWxlY29tcG9uZW50KS52YWwoKTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgKyBieXRlcy52O1xuICAgICAgICAkKGZpbGVjb21wb25lbnQpLnZhbChjdXJyZW50KTtcbiAgICAgICAgJChmaWxlY29tcG9uZW50KS5jc3MoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgIGZvYmoucG9zJCA9IGN1cnJlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gY3VycmVudC5sZW5ndGg7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0SW5jbHVkZWRDb2RlKGRpdmlkKSB7XG4gICAgICAgIGlmICh3aW5kb3cuZWRMaXN0W2RpdmlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5lZExpc3RbZGl2aWRdLmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcbiAgICAgICAgICAgICAgICBgL3J1bmVzdG9uZS9hamF4L2dldF9kYXRhZmlsZT9jb3Vyc2VfaWQ9JHtlQm9va0NvbmZpZy5jb3Vyc2V9JmFjaWQ9JHtkaXZpZH1gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmpzb25IZWFkZXJzLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgd3Jlc3VsdCA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgbGV0IG9iaiA9IGF3YWl0IHdyZXN1bHQuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG9iai5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgYnVpbGRQcm9nKHVzZVN1ZmZpeCkge1xuICAgICAgICAvLyBhc3NlbWJsZSBjb2RlIGZyb20gcHJlZml4LCBzdWZmaXgsIGFuZCBlZGl0b3IgZm9yIHJ1bm5pbmcuXG4gICAgICAgIHZhciBwcmV0ZXh0O1xuICAgICAgICB2YXIgcHJvZyA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCkgKyBcIlxcblwiO1xuICAgICAgICBpZiAodGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHByb2cgPSB0aGlzLnByZWZpeCArIHByb2c7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV0ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5wcmV0ZXh0TGluZXMgPSAwO1xuICAgICAgICB0aGlzLnByb2dMaW5lcyA9IHByb2cubWF0Y2goL1xcbi9nKS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlcykge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBpbmNsdWRlcywgaW4tb3JkZXIgcHJlcGVuZGluZyB0byBwcm9nXG4gICAgICAgICAgICBwcmV0ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5pbmNsdWRlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBpQ29kZSA9IGF3YWl0IHRoaXMuZ2V0SW5jbHVkZWRDb2RlKHRoaXMuaW5jbHVkZXNbeF0pO1xuICAgICAgICAgICAgICAgIHByZXRleHQgPSBwcmV0ZXh0ICsgaUNvZGUgKyBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV0ZXh0ID0gcHJldGV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXRleHRMaW5lcyA9ICh0aGlzLnByZXRleHQubWF0Y2goL1xcbi9nKSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9nID0gcHJldGV4dCArIHByb2c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZVN1ZmZpeCAmJiB0aGlzLnN1ZmZpeCkge1xuICAgICAgICAgICAgcHJvZyA9IHByb2cgKyB0aGlzLnN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2cpO1xuICAgIH1cblxuICAgIGFzeW5jIG1hbmFnZV9zY3J1YmJlcihzYXZlQ29kZSkge1xuICAgICAgICBpZiAodGhpcy5oaXN0b3J5U2NydWJiZXIgPT09IG51bGwgJiYgIXRoaXMuYXV0b3J1bikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRIaXN0b3J5U2NydWJiZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlTY3J1YmJlciAmJlxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WyQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcInZhbHVlXCIpXSAhPVxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmdldFZhbHVlKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBzYXZlQ29kZSA9IFwiVHJ1ZVwiO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcHMucHVzaChuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCkpO1xuICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikuc2xpZGVyKFxuICAgICAgICAgICAgICAgIFwib3B0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJtYXhcIixcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcbiAgICAgICAgICAgICAgICBcIm9wdGlvblwiLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVpdChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhdmVDb2RlID0gXCJGYWxzZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlTY3J1YmJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBzYXZlQ29kZSA9IFwiRmFsc2VcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2F2ZUNvZGU7XG4gICAgfVxuXG4gICAgYXN5bmMgY2hlY2tDdXJyZW50QW5zd2VyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5Qcm9nKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBlcnJvciBydW5uaW5nIGNvZGUgJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlIHNpZCBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwgYW5kIGlzIHVzZWQgZm9yIGdyb3VwIHN1Ym1pc3Npb25zXG4gICAgYXN5bmMgbG9nQ3VycmVudEFuc3dlcihzaWQpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICAgICAgICBlcnJpbmZvOiB0aGlzLmVycmluZm8gfHwgXCJcIixcbiAgICAgICAgICAgIHRvX3NhdmU6IHRoaXMuc2F2ZUNvZGUgfHwgXCJGXCIsXG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMucHJldGV4dCxcbiAgICAgICAgICAgIHN1ZmZpeDogdGhpcy5zdWZmaXgsXG4gICAgICAgICAgICBwYXJ0bmVyOiB0aGlzLnBhcnRuZXIsXG4gICAgICAgIH07IC8vIExvZyB0aGUgcnVuIGV2ZW50XG4gICAgICAgIGlmICh0eXBlb2Ygc2lkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkYXRhLnNpZCA9IHNpZDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmxvZ1J1bkV2ZW50KGRhdGEpO1xuICAgICAgICAvLyBJZiB1bml0IHRlc3RzIHdlcmUgcnVuIHRoZXJlIHdpbGwgYmUgYSB1bml0X3Jlc3VsdHNcbiAgICAgICAgaWYgKHRoaXMudW5pdF9yZXN1bHRzKSB7XG4gICAgICAgICAgICBsZXQgdW5pdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWN0OiB0aGlzLnVuaXRfcmVzdWx0cyxcbiAgICAgICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwidW5pdHRlc3RcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNpZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHVuaXREYXRhLnNpZCA9IHNpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9nQm9va0V2ZW50KHVuaXREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlckZlZWRiYWNrKCkge1xuICAgICAgICAvLyBUaGUgcHl0aG9uIHVuaXQgdGVzdCBjb2RlIGJ1aWxkcyB0aGUgdGFibGUgYXMgaXQgaXMgcnVubmluZyB0aGUgdGVzdHNcbiAgICAgICAgLy8gSW4gXCJub3JtYWxcIiB1c2FnZSB0aGlzIGlzIGRpc3BsYXllZCBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBleGFtIG1vZGUgd2UgbWFrZSBhIGRpdiB3aGljaCBpcyBvZmZzY3JlZW5cbiAgICAgICAgaWYgKHRoaXMudW5pdF9yZXN1bHRzX2RpdmlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51bml0X3Jlc3VsdHNfZGl2aWQuaW5kZXhPZihcIl9vZmZzY3JlZW5fXCIpID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB1ckRpdmlkID0gYCR7dGhpcy5kaXZpZH1fb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c2A7XG4gICAgICAgICAgICAgICAgbGV0IHVuaXRGZWVkYmFjayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVyRGl2aWQpO1xuICAgICAgICAgICAgICAgIGxldCB0bXAgPSBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHVuaXRGZWVkYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcy5vdXRlckRpdikuZmluZChgIyR7dXJEaXZpZH1gKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9ICQodGhpcy5vdXRlckRpdikuZmluZChgIyR7dXJEaXZpZH1gKVswXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQodG1wKS5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB1ckRpdmlkID0gdGhpcy5kaXZpZCArIFwiX3VuaXRfcmVzdWx0c1wiO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLm91dGVyRGl2KS5maW5kKGAjJHt1ckRpdmlkfWApLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5vdXRlckRpdikuZmluZChgIyR7dXJEaXZpZH1fb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c2ApXG4gICAgICAgICAgICAgICAgICAgICAgICAubGVuZ3RoID09IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVyUmVzdWx0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVyRGl2aWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKHVyUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlQWxlcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX3RvZ2dsZSAmJiB0aGlzLnJ1bkNvdW50ID09IDMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzLmVycmluZm8gIT0gXCJzdWNjZXNzXCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnVuaXRfcmVzdWx0cy5zdWJzdHJpbmcoOCwgMTEpICE9IDEwMC4wXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkhlbHAgaXMgQXZhaWxhYmxlIFVzaW5nIHRoZSBUb2dnbGUgUXVlc3Rpb24gU2VsZWN0b3IhIFlvdSBjYW4gdHJ5IHRoZSBNaXhlZC11cCBRdWVzdGlvbiBmaXJzdC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJ0b2dnbGVhbGVydFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Q6IFwiSGVscCBpcyBBdmFpbGFibGUgVXNpbmcgdGhlIFRvZ2dsZSBRdWVzdGlvbiBTZWxlY3RvclwiLFxuICAgICAgICAgICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBydW5Qcm9nIGhhcyBzZXZlcmFsIGFzeW5jIGVsZW1lbnRzIHRvIGl0LlxuICAgICAqIDEuIFNrdWxwdCBydW5zIHRoZSBweXRob24gcHJvZ3JhbSBhc3luY2hyb25vdXNseVxuICAgICAqIDIuIFRoZSBoaXN0b3J5IGlzIHJlc3RvcmVkIGFzeW5jaHJvbm91c2x5XG4gICAgICogMy4gTG9nZ2luZyBpcyBhc3luY2hyb25vdXNcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNrdWxwdCBQcm9taXNlIGFuZCBzbyB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiBza3VscHQgaXMgZmluaXNoZWQuXG4gICAgICogd2hlbiBmaW5pc2hlZCB0aGlzLnVuaXRfcmVzdWx0cyB3aWxsIGNvbnRhaW4gdGhlIHJlc3VsdHMgb2YgYW55IHVuaXQgdGVzdHMgdGhhdCBoYXZlIGJlZW4gcnVuLlxuICAgICAqIFRoZSB0YWJsZSBvZiByZXN1bHRzIGlzIGNvbnN0cnVjdGVkIGFuZCBhZGRlZCB0byB0aGUgRE9NIGJ5IHRoZSBweXRob24gdW5pdHRlc3QuZ3VpIG1vZHVsZSBpbiBza3VscHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBydW5Qcm9nKG5vVUksIGxvZ1Jlc3VsdHMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBydW5Qcm9nXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxvZ1Jlc3VsdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1Jlc3VsdHMgPSBsb2dSZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9VSSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIG5vVUkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZyA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKHRydWUpO1xuICAgICAgICB0aGlzLnNhdmVDb2RlID0gXCJUcnVlXCI7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLnRleHQoXCJcIik7XG4gICAgICAgIHdoaWxlICgkKGAjJHt0aGlzLmRpdmlkfV9lcnJpbmZvYCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJChgIyR7dGhpcy5kaXZpZH1fZXJyaW5mb2ApLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vJCh0aGlzLmVDb250YWluZXIpLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5jb2RlbGVucykge1xuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xCdXR0b24uaW5uZXJUZXh0ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19pbl9jb2RlbGVuc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBTay5jb25maWd1cmUoe1xuICAgICAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dGZ1bi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVhZDogdGhpcy5maWxlUmVhZGVyLFxuICAgICAgICAgICAgZmlsZXdyaXRlOiB0aGlzLmZpbGV3cml0ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9fZnV0dXJlX186IFNrLnB5dGhvbjMsXG4gICAgICAgICAgICBub25yZWFkb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIC8vICAgICAgICBweXRob24zOiB0aGlzLnB5dGhvbjMsXG4gICAgICAgICAgICBpbWFnZVByb3h5OiBcImh0dHA6Ly9pbWFnZS5ydW5lc3RvbmUuYWNhZGVteTo4MDgwLzMyMHhcIixcbiAgICAgICAgICAgIGlucHV0ZnVuVGFrZXNQcm9tcHQ6IHRydWUsXG4gICAgICAgICAgICBqc29ucFNpdGVzOiBbXCJodHRwczovL2l0dW5lcy5hcHBsZS5jb21cIl0sXG4gICAgICAgIH0pO1xuICAgICAgICBTay5kaXZpZCA9IHRoaXMuZGl2aWQ7XG4gICAgICAgIFNrLmxvZ1Jlc3VsdHMgPSBsb2dSZXN1bHRzO1xuICAgICAgICBpZiAodGhpcy5ncmFkZXJhY3RpdmUgJiYgdGhpcy5vdXRlckRpdi5jbG9zZXN0KFwiLmxvYWRpbmdcIikpIHtcbiAgICAgICAgICAgIFNrLmdyYWRlQ29udGFpbmVyID0gdGhpcy5vdXRlckRpdi5jbG9zZXN0KFwiLmxvYWRpbmdcIikuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTay5ncmFkZUNvbnRhaW5lciA9IHRoaXMuZGl2aWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRUaW1lTGltaXQoKTtcbiAgICAgICAgKFNrLlR1cnRsZUdyYXBoaWNzIHx8IChTay5UdXJ0bGVHcmFwaGljcyA9IHt9KSkudGFyZ2V0ID0gdGhpcy5ncmFwaGljcztcbiAgICAgICAgU2suY2FudmFzID0gdGhpcy5ncmFwaGljcy5pZDsgLy90b2RvOiBnZXQgcmlkIG9mIHRoaXMgaGVyZSBhbmQgaW4gaW1hZ2VcbiAgICAgICAgaWYgKCFub1VJKSB7XG4gICAgICAgICAgICB0aGlzLnNhdmVDb2RlID0gYXdhaXQgdGhpcy5tYW5hZ2Vfc2NydWJiZXIodGhpcy5zYXZlQ29kZSk7XG4gICAgICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLm9mZihcInNsaWRlY2hhbmdlXCIpO1xuICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikuc2xpZGVyKFwiZGlzYWJsZVwiKTtcbiAgICAgICAgICAgICQodGhpcy5vdXREaXYpLnNob3coe1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA3MDAsXG4gICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2suaW1wb3J0TWFpbldpdGhCb2R5KFwiPHN0ZGluPlwiLCBmYWxzZSwgcHJvZywgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghbm9VSSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNsaWRlaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikub24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNsaWRlY2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlaXQuYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5zbGlkZXIoXCJlbmFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVyckxhc3RSdW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXJyaW5mbyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghbm9VSSkge1xuICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLm9uKFxuICAgICAgICAgICAgICAgICAgICBcInNsaWRlY2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5zbGlkZXIoXCJlbmFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycmluZm8gPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3JNZXNzYWdlKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5hbGxWaXN1YWxpemVycyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKHdpbmRvdy5hbGxWaXN1YWxpemVycywgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5yZWRyYXdDb25uZWN0b3JzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlSW50ZXJhY3Rpb24oKSB7XG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLmhpZGUoKTtcbiAgICAgICAgJCh0aGlzLmNvZGVEaXYpLmFkZENsYXNzKFwiYWMtZGlzYWJsZWRcIik7XG4gICAgfVxufVxuXG52YXIgbGFuZ3VhZ2VFeHRlbnNpb25zID0ge1xuICAgIHB5dGhvbjogXCJweVwiLFxuICAgIGh0bWw6IFwiaHRtbFwiLFxuICAgIGphdmFzY3JpcHQ6IFwianNcIixcbiAgICBqYXZhOiBcImphdmFcIixcbiAgICBweXRob24yOiBcInB5XCIsXG4gICAgcHl0aG9uMzogXCJweVwiLFxuICAgIGNwcDogXCJjcHBcIixcbiAgICBjOiBcImNcIixcbiAgICBzcWw6IFwic3FsXCIsXG4gICAgb2N0YXZlOiBcIm1cIixcbn07XG5cbnZhciBlcnJvclRleHQgPSB7fTtcblxuZXJyb3JUZXh0LlBhcnNlRXJyb3IgPSAkLmkxOG4oXCJtc2dfc2N0aXZlY29kZV9wYXJzZV9lcnJvclwiKTtcbmVycm9yVGV4dC5QYXJzZUVycm9yRml4ID0gJC5pMThuKFwibXNnX3NjdGl2ZWNvZGVfcGFyc2VfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0LlR5cGVFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3R5cGVfZXJyb3JcIik7XG5lcnJvclRleHQuVHlwZUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuTmFtZUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvclwiKTtcbmVycm9yVGV4dC5OYW1lRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9uYW1lX2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5WYWx1ZUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdmFsdWVfZXJyb3JcIik7XG5lcnJvclRleHQuVmFsdWVFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3ZhbHVlX2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5BdHRyaWJ1dGVFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvclwiKTtcbmVycm9yVGV4dC5BdHRyaWJ1dGVFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuVG9rZW5FcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Rva2VuX2Vycm9yXCIpO1xuZXJyb3JUZXh0LlRva2VuRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuVGltZUxpbWl0RXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV90aW1lX2xpbWl0X2Vycm9yXCIpO1xuZXJyb3JUZXh0LlRpbWVMaW1pdEVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yXCIpO1xuZXJyb3JUZXh0LkVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfZ2VuZXJhbF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuU3ludGF4RXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3JcIik7XG5lcnJvclRleHQuU3ludGF4RXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0LkluZGV4RXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbmRleF9lcnJvclwiKTtcbmVycm9yVGV4dC5JbmRleEVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfaW5kZXhfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0LlVSSUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yXCIpO1xuZXJyb3JUZXh0LlVSSUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5JbXBvcnRFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvclwiKTtcbmVycm9yVGV4dC5JbXBvcnRFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuUmVmZXJlbmNlRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9yZWZlcmVuY2VfZXJyb3JcIik7XG5lcnJvclRleHQuUmVmZXJlbmNlRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9yZWZlcmVuY2VfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0Llplcm9EaXZpc2lvbkVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfemVyb19kaXZpc2lvbl9lcnJvclwiKTtcbmVycm9yVGV4dC5aZXJvRGl2aXNpb25FcnJvckZpeCA9ICQuaTE4bihcbiAgICBcIm1zZ19hY3RpdmVjb2RlX3plcm9fZGl2aXNpb25fZXJyb3JfZml4XCJcbik7XG5lcnJvclRleHQuUmFuZ2VFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3JhbmdlX2Vycm9yXCIpO1xuZXJyb3JUZXh0LlJhbmdlRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuSW50ZXJuYWxFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ludGVybmFsX2Vycm9yXCIpO1xuZXJyb3JUZXh0LkludGVybmFsRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuSW5kZW50YXRpb25FcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2luZGVudGF0aW9uX2Vycm9yXCIpO1xuZXJyb3JUZXh0LkluZGVudGF0aW9uRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbmRlbnRhdGlvbl9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuTm90SW1wbGVtZW50ZWRFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX25vdF9pbXBsZW1lbnRlZF9lcnJvclwiKTtcbmVycm9yVGV4dC5Ob3RJbXBsZW1lbnRlZEVycm9yRml4ID0gJC5pMThuKFxuICAgIFwibXNnX2FjdGl2ZWNvZGVfbm90X2ltcGxlbWVudGVkX2Vycm9yX2ZpeFwiXG4pO1xuZXJyb3JUZXh0LktleUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yXCIpO1xuZXJyb3JUZXh0LktleUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5Bc3NlcnRpb25FcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvclwiKTtcbmVycm9yVGV4dC5Bc3NlcnRpb25FcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvcl9maXhcIik7XG5cblN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaXQodGFyZ2V0KS5qb2luKHJlcGxhY2VtZW50KTtcbn07XG4iLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVE1MQWN0aXZlQ29kZSBleHRlbmRzIEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIG9wdHMuYWxpZ25WZXJ0aWNhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29kZSA9ICQoXCI8dGV4dGFyZWEgLz5cIikuaHRtbCh0aGlzLm9yaWdFbGVtLmlubmVySFRNTCkudGV4dCgpO1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS50ZXh0KFwiUmVuZGVyXCIpO1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0aGlzLmNvZGUpO1xuICAgIH1cblxuICAgIGFzeW5jIHJ1blByb2coKSB7XG4gICAgICAgIHZhciBwcm9nID0gYXdhaXQgdGhpcy5idWlsZFByb2codHJ1ZSk7XG4gICAgICAgIGxldCBzYXZlQ29kZSA9IFwiVHJ1ZVwiO1xuICAgICAgICB0aGlzLnNhdmVDb2RlID0gYXdhaXQgdGhpcy5tYW5hZ2Vfc2NydWJiZXIoc2F2ZUNvZGUpO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFwiXCIpO1xuICAgICAgICBpZiAoIXRoaXMuYWxpZ25WZXJ0aWNhbCkge1xuICAgICAgICAgICAgJCh0aGlzLmNvZGVEaXYpLnN3aXRjaENsYXNzKFwiY29sLW1kLTEyXCIsIFwiY29sLW1kLTZcIiwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm91dERpdikuc2hvdyh7IGR1cmF0aW9uOiA3MDAsIHF1ZXVlOiBmYWxzZSB9KTtcbiAgICAgICAgcHJvZyA9XG4gICAgICAgICAgICBcIjxzY3JpcHQgdHlwZT10ZXh0L2phdmFzY3JpcHQ+d2luZG93Lm9uZXJyb3IgPSBmdW5jdGlvbihtc2csdXJsLGxpbmUpIHthbGVydChtc2crJyBvbiBsaW5lOiAnK2xpbmUpO307PC9zY3JpcHQ+XCIgK1xuICAgICAgICAgICAgcHJvZztcbiAgICAgICAgdGhpcy5vdXRwdXQuc3JjZG9jID0gcHJvZztcbiAgICB9XG5cbiAgICBjcmVhdGVPdXRwdXQoKSB7XG4gICAgICAgIHRoaXMuYWxpZ25WZXJ0aWNhbCA9IHRydWU7XG4gICAgICAgIHZhciBvdXREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAkKG91dERpdikuYWRkQ2xhc3MoXCJhY19vdXRwdXRcIik7XG4gICAgICAgIGlmICh0aGlzLmFsaWduVmVydGljYWwpIHtcbiAgICAgICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImNvbC1tZC0xMlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImNvbC1tZC01XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0RGl2ID0gb3V0RGl2O1xuICAgICAgICB0aGlzLm91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKTtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwiaGVpZ2h0XCIsIFwiNDAwcHhcIik7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICAgICAgb3V0RGl2LmFwcGVuZENoaWxkKHRoaXMub3V0cHV0KTtcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChvdXREaXYpO1xuICAgICAgICB2YXIgY2xlYXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAkKGNsZWFyRGl2KS5jc3MoXCJjbGVhclwiLCBcImJvdGhcIik7IC8vIG5lZWRlZCB0byBtYWtlIHBhcmVudCBkaXYgcmVzaXplIHByb3Blcmx5XG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoY2xlYXJEaXYpO1xuICAgIH1cbiAgICBlbmFibGVTYXZlTG9hZCgpIHtcbiAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikudGV4dCgkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9yZW5kZXJcIikpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEFjdGl2ZUNvZGUgfSBmcm9tIFwiLi9hY3RpdmVjb2RlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpTQWN0aXZlQ29kZSBleHRlbmRzIEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgfVxuICAgIG91dHB1dGZ1bihhKSB7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuICAgICAgICB2YXIgc3RyID0gXCJbXCI7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhW2ldID09IFwib2JqZWN0XCIgJiYgYVtpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IChpID09IDAgPyBcIlwiIDogXCIgXCIpICsgXCJbXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYVtpXS5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV1bal0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChqID09IGFbaV0ubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiXVwiICsgKGkgPT0gYS5sZW5ndGggLSAxID8gXCJdXCIgOiBcIixcIikgKyBcIlxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCIsIFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Ugc3RyICs9IGFbaV0gKyAoaSA9PSBhLmxlbmd0aCAtIDEgPyBcIl1cIiA6IFwiLCBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgYXN5bmMgcnVuUHJvZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb2cgPSBhd2FpdCB0aGlzLmJ1aWxkUHJvZyh0cnVlKTtcbiAgICAgICAgdmFyIHNhdmVDb2RlID0gXCJUcnVlXCI7XG4gICAgICAgIHZhciB3cml0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dC5pbm5lckhUTUwgKz0gX3RoaXMub3V0cHV0ZnVuKHN0cik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3cml0ZWxuID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgaWYgKCFzdHIpIHN0ciA9IFwiXCI7XG4gICAgICAgICAgICBfdGhpcy5vdXRwdXQuaW5uZXJIVE1MICs9IF90aGlzLm91dHB1dGZ1bihzdHIpICsgXCI8YnIgLz5cIjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHNhdmVDb2RlKTtcbiAgICAgICAgJCh0aGlzLmVDb250YWluZXIpLnJlbW92ZSgpO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFwiXCIpO1xuICAgICAgICAkKHRoaXMub3V0RGl2KS5zaG93KHsgZHVyYXRpb246IDcwMCwgcXVldWU6IGZhbHNlIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZhbChwcm9nKTtcbiAgICAgICAgICAgIHRoaXMuZXJyaW5mbyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yTWVzc2FnZShlKTtcbiAgICAgICAgICAgIHRoaXMuZXJyaW5mbyA9IGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRFcnJvck1lc3NhZ2UoZXJyKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgZXJyb3IgbWVzc2FnZVxuICAgICAgICB0aGlzLmVyckxhc3RSdW4gPSB0cnVlO1xuICAgICAgICB2YXIgZXJySGVhZCA9ICQoXCI8aDM+XCIpLmh0bWwoXCJFcnJvclwiKTtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyID0gdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwiZXJyb3IgYWxlcnQgYWxlcnQtZGFuZ2VyXCI7XG4gICAgICAgIHRoaXMuZUNvbnRhaW5lci5pZCA9IHRoaXMuZGl2aWQgKyBcIl9lcnJpbmZvXCI7XG4gICAgICAgIHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJIZWFkWzBdKTtcbiAgICAgICAgdmFyIGVyclRleHQgPSB0aGlzLmVDb250YWluZXIuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlcnJTdHJpbmcgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgZXJyVGV4dC5pbm5lckhUTUwgPSBlcnJTdHJpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUnVudGltZSBFcnJvcjogXCIgKyBlcnIudG9TdHJpbmcoKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQWN0aXZlQ29kZSB9IGZyb20gXCIuL2FjdGl2ZWNvZGUuanNcIjtcbmltcG9ydCBIYW5kc29udGFibGUgZnJvbSBcImhhbmRzb250YWJsZVwiO1xuaW1wb3J0IFwiaGFuZHNvbnRhYmxlL2Rpc3QvaGFuZHNvbnRhYmxlLmZ1bGwuY3NzXCI7XG5pbXBvcnQgaW5pdFNxbEpzIGZyb20gXCJzcWwuanMvZGlzdC9zcWwtd2FzbS5qc1wiO1xuXG52YXIgYWxsRGJ1cmxzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNRTEFjdGl2ZUNvZGUgZXh0ZW5kcyBBY3RpdmVDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICAvLyAgZm5wcmVmaXggc2V0cyB0aGUgcGF0aCB0byBsb2FkIHRoZSBzcWwtd2FzbS53YXNtIGZpbGVcbiAgICAgICAgdmFyIGJvb2twcmVmaXg7XG4gICAgICAgIHZhciBmbnByZWZpeDtcbiAgICAgICAgLy8gRml4OiB0aGUgbW9kZT1icm93c2luZyBwcm9ibGVtIHdpY2ggZGlzYWJsZXMgdXNlUnVuZXN0b25lU2VydmljZXMgYW5kXG4gICAgICAgIC8vIG1ha2VzIGl0IGltcG9zc2libGUgdG8gY29yb3JlY3RseSBsb2FkIHNxbC13YXNtXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGVCb29rQ29uZmlnLnVzZVJ1bmVzdG9uZVNlcnZpY2VzIHx8XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKFwibW9kZT1icm93c2luZ1wiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGJvb2twcmVmaXggPSBgJHtlQm9va0NvbmZpZy5hcHB9L2Jvb2tzL3B1Ymxpc2hlZC8ke2VCb29rQ29uZmlnLmJhc2Vjb3Vyc2V9YDtcbiAgICAgICAgICAgIGZucHJlZml4ID0gYm9va3ByZWZpeCArIFwiL19zdGF0aWNcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbHNlIGNsYXVzZSBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHlvdSBhcmUgYnVpbGRpbmcgZm9yIGEgc3RhdGljIHdlYiBicm93c2VyXG4gICAgICAgICAgICBib29rcHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgIGZucHJlZml4ID0gXCIvX3N0YXRpY1wiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbG9jYXRlRmlsZTogKGZpbGVuYW1lKSA9PiBgJHtmbnByZWZpeH0vJHtmaWxlbmFtZX1gLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNob3dMYXN0ID0gJCh0aGlzLm9yaWdFbGVtKS5kYXRhKFwic2hvd2xhc3RzcWxcIik7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaW5pdFNxbEpzKHRoaXMuY29uZmlnKS50aGVuKGZ1bmN0aW9uIChTUUwpIHtcbiAgICAgICAgICAgIC8vIHNldCB1cCBjYWxsIHRvIGxvYWQgZGF0YWJhc2UgYXN5bmNocm9ub3VzbHkgaWYgZ2l2ZW5cbiAgICAgICAgICAgIGlmIChzZWxmLmRidXJsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGJ1cmwuc3RhcnRzV2l0aChcIi9fc3RhdGljXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGJ1cmwgPSBgJHtib29rcHJlZml4fSR7c2VsZi5kYnVybH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgYnV0dG9uVGV4dCA9ICQoc2VsZi5ydW5CdXR0b24pLnRleHQoKTtcbiAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2xvYWRfZGJcIikpO1xuICAgICAgICAgICAgICAgIGlmICghKHNlbGYuZGJ1cmwgaW4gYWxsRGJ1cmxzKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwibG9hZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeFdhaXRGb3I6IGpRdWVyeS5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYnVybHNbc2VsZi5kYnVybF0uc3RhdHVzID09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0ueFdhaXRGb3IuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYiA9IGFsbERidXJsc1tzZWxmLmRidXJsXS5kYk9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikudGV4dChidXR0b25UZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGIgPSBhbGxEYnVybHNbc2VsZi5kYnVybF0uZGJPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikudGV4dChidXR0b25UZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9sZXJvY2hhL2NoaW5vb2stZGF0YWJhc2UvcmF3L21hc3Rlci9DaGlub29rRGF0YWJhc2UvRGF0YVNvdXJjZXMvQ2hpbm9va19TcWxpdGUuc3FsaXRlXG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgc2VsZi5kYnVybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRiID0gbmV3IFNRTC5EYXRhYmFzZSh1SW50OEFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGJ1cmxzW3NlbGYuZGJ1cmxdLmRiT2JqZWN0ID0gc2VsZi5kYjtcbiAgICAgICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikudGV4dChidXR0b25UZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0uZGIgPSB1SW50OEFycmF5O1xuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0uc3RhdHVzID0gXCJyZWFkeVwiO1xuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0ueFdhaXRGb3IucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250ZW50cyBpcyBub3cgW3tjb2x1bW5zOlsnY29sMScsJ2NvbDInLC4uLl0sIHZhbHVlczpbW2ZpcnN0IHJvd10sIFtzZWNvbmQgcm93XSwgLi4uXX1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRiID0gbmV3IFNRTC5EYXRhYmFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcnVuUHJvZyhub1VJLCBsb2dSZXN1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9nUmVzdWx0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5sb2dSZXN1bHRzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IGxvZ1Jlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub1VJICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgbm9VSSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGFueSBvbGQgcmVzdWx0c1xuICAgICAgICB0aGlzLnNhdmVDb2RlID0gXCJUcnVlXCI7XG4gICAgICAgIGxldCBkaXZpZCA9IHRoaXMuZGl2aWQgKyBcIl9zcWxfb3V0XCI7XG4gICAgICAgIGxldCByZXNwRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQpO1xuICAgICAgICBpZiAocmVzcERpdikge1xuICAgICAgICAgICAgcmVzcERpdi5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHJlc3BEaXYpO1xuICAgICAgICB9XG4gICAgICAgICQodGhpcy5vdXRwdXQpLnRleHQoXCJcIik7XG4gICAgICAgIC8vIFJ1biB0aGlzIHF1ZXJ5XG4gICAgICAgIGxldCBxdWVyeSA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKGZhbHNlKTsgLy8gZmFsc2UgLS0+IERvIG5vdCBpbmNsdWRlIHN1ZmZpeFxuICAgICAgICBpZiAoIXRoaXMuZGIpIHtcbiAgICAgICAgICAgICQodGhpcy5vdXRwdXQpLnRleHQoXG4gICAgICAgICAgICAgICAgYEVycm9yOiBEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQhIERCVVJMOiAke3RoaXMuZGJ1cmx9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdCA9IHRoaXMuZGIuaXRlcmF0ZVN0YXRlbWVudHMocXVlcnkpO1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IHN0YXRlbWVudCBvZiBpdCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2x1bW5zID0gc3RhdGVtZW50LmdldENvbHVtbk5hbWVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhISBwcm9iYWJseSBhIFNFTEVDVFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGVtZW50LnN0ZXAoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHN0YXRlbWVudC5nZXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3djb3VudDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuc3FsID0gc3RhdGVtZW50LmdldE5vcm1hbGl6ZWRTUUwoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeCA9IG5zcWwuc3Vic3RyKDAsIDYpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudC5zdGVwKCk7IC8vIGV4ZWN1dGUgdGhlIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBkZXRlY3QgSU5TRVJUL1VQREFURS9ERUxFVEUgdG8gZ2l2ZSBmcmllbmRseSBmZWVkYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyBvbiByb3dzIG1vZGlmaWVkIC0gdW5mb3J0dW5hdGVseSwgdGhpcyB3b24ndCBjYXRjaCBzdWNoIHF1ZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhleSB1c2UgQ1RFcy4gIFRoZXJlIHNlZW1zIHRvIGJlIG5vIHJlbGlhYmxlIHdheSBvZiBrbm93aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBTUUxpdGUgcXVlcnkgYWN0dWFsbHkgbW9kaWZpZWQgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID09PSBcImluc2VydFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPT09IFwidXBkYXRlXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9PT0gXCJkZWxldGVcIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd2NvdW50OiB0aGlzLmRiLmdldFJvd3NNb2RpZmllZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaCh7IHN0YXR1czogXCJzdWNjZXNzXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZmFpbHVyZVwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzcWw6IGl0LmdldFJlbWFpbmluZ1NRTCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJmYWlsdXJlXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBxdWVyaWVzIHN1Ym1pdHRlZC5cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBhd2FpdCB0aGlzLm1hbmFnZV9zY3J1YmJlcih0aGlzLnNhdmVDb2RlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNsaWRlaXQpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5vbihcbiAgICAgICAgICAgICAgICAgICAgXCJzbGlkZWNoYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlaXQuYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5zbGlkZXIoXCJlbmFibGVcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gdXBkYXRlIHNjcnViYmVyICR7ZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICByZXNwRGl2LmlkID0gZGl2aWQ7XG4gICAgICAgIHRoaXMub3V0RGl2LmFwcGVuZENoaWxkKHJlc3BEaXYpO1xuICAgICAgICAkKHRoaXMub3V0RGl2KS5zaG93KCk7XG4gICAgICAgIC8vIFNvbWV0aW1lcyB3ZSBkb24ndCB3YW50IHRvIHNob3cgYSBidW5jaCBvZiBpbnRlcm1lZGlhdGUgcmVzdWx0c1xuICAgICAgICAvLyBsaWtlIHdoZW4gd2UgYXJlIGluY2x1ZGluZyBhIGJ1bmNoIG9mIHByZXZpb3VzIHN0YXRlbWVudHMgZnJvbVxuICAgICAgICAvLyBvdGhlciBhY3RpdmVjb2RlcyBJbiB0aGF0IGNhc2UgdGhlIHNob3dsYXN0c3FsIGZsYWcgY2FuIGJlIHNldFxuICAgICAgICAvLyBzbyB3ZSBvbmx5IHNob3cgdGhlIGxhc3QgcmVzdWx0XG4gICAgICAgIGxldCByZXN1bHRBcnJheSA9IHRoaXMucmVzdWx0cztcbiAgICAgICAgaWYgKHRoaXMuc2hvd0xhc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdEFycmF5ID0gdGhpcy5yZXN1bHRzLnNsaWNlKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCByIG9mIHJlc3VsdEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWNfc3FsX3Jlc3VsdFwiKTtcbiAgICAgICAgICAgIHJlc3BEaXYuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XG4gICAgICAgICAgICBpZiAoci5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIuY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFibGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKHRhYmxlRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IDM1MDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdEFycmF5Lmxlbmd0aCA+IDEpIG1heEhlaWdodCA9IDIwMDsgLy8gbWF4IGhlaWdodCBzbWFsbGVyIGlmIGxvdHMgb2YgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShyLCB0YWJsZURpdiwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm1zZyA9IHIucm93Y291bnQgIT09IDEgPyBcIiByb3dzIFwiIDogXCIgcm93IFwiO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXNnID0gXCJcIiArIHIucm93Y291bnQgKyBybXNnICsgXCJyZXR1cm5lZFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoci5yb3djb3VudCA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gbXNnICsgXCIgKG9ubHkgZmlyc3QgMTAwIHJvd3MgZGlzcGxheWVkKVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG1zZyArIFwiLlwiO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnRleHRDb250ZW50ID0gbXNnO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWNfc3FsX3Jlc3VsdF9zdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKG1lc3NhZ2VCb3gpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoci5yb3djb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZUJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcCA9IHIub3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBvcCA9IG9wICsgKG9wLmNoYXJBdChvcC5sZW5ndGggLSAxKSA9PT0gXCJlXCIgPyBcImQuXCIgOiBcImVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJtc2cgPSByLnJvd2NvdW50ICE9PSAxID8gXCIgcm93cyBcIiA6IFwiIHJvdyBcIjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC50ZXh0Q29udGVudCA9IFwiXCIgKyByLnJvd2NvdW50ICsgcm1zZyArIG9wO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWNfc3FsX3Jlc3VsdF9zdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKG1lc3NhZ2VCb3gpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC50ZXh0Q29udGVudCA9IFwiT3BlcmF0aW9uIHN1Y2NlZWRlZC5cIjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFjX3NxbF9yZXN1bHRfc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChtZXNzYWdlQm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnRleHRDb250ZW50ID0gci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3guc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhY19zcWxfcmVzdWx0X2ZhaWx1cmVcIik7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChtZXNzYWdlQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBoYW5kbGUgYXV0b2dyYWRpbmdcbiAgICAgICAgaWYgKHRoaXMuc3VmZml4KSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RSZXN1bHQgPSB0aGlzLmF1dG9ncmFkZShcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHNbdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXCJkb25lXCIpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvZ0N1cnJlbnRBbnN3ZXIoc2lkKSB7XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxuICAgICAgICAgICAgY29kZTogdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICAgICAgZXJyaW5mbzogdGhpcy5yZXN1bHRzW3RoaXMucmVzdWx0cy5sZW5ndGggLSAxXS5zdGF0dXMsXG4gICAgICAgICAgICB0b19zYXZlOiB0aGlzLnNhdmVDb2RlLFxuICAgICAgICAgICAgcHJlZml4OiB0aGlzLnByZXRleHQsXG4gICAgICAgICAgICBzdWZmaXg6IHRoaXMuc3VmZml4LFxuICAgICAgICAgICAgcGFydG5lcjogdGhpcy5wYXJ0bmVyLFxuICAgICAgICB9OyAvLyBMb2cgdGhlIHJ1biBldmVudFxuICAgICAgICBpZiAodHlwZW9mIHNpZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZGF0YS5zaWQgPSBzaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5sb2dSdW5FdmVudChkYXRhKTtcblxuICAgICAgICBpZiAodGhpcy51bml0X3Jlc3VsdHMpIHtcbiAgICAgICAgICAgIGxldCB1bml0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJ1bml0dGVzdFwiLFxuICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICBjb3Vyc2U6IGVCb29rQ29uZmlnLmNvdXJzZSxcbiAgICAgICAgICAgICAgICBhY3Q6IHRoaXMudW5pdF9yZXN1bHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2lkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdW5pdERhdGEuc2lkID0gc2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2dCb29rRXZlbnQodW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyRmVlZGJhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICQodGhpcy5vdXRwdXQpLnRleHQodGhpcy50ZXN0UmVzdWx0KTtcbiAgICAgICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXV0b2dyYWRlKHJlc3VsdF90YWJsZSkge1xuICAgICAgICB2YXIgdGVzdHMgPSB0aGlzLnN1ZmZpeC5zcGxpdCgvXFxuLyk7XG4gICAgICAgIHRoaXMucGFzc2VkID0gMDtcbiAgICAgICAgdGhpcy5mYWlsZWQgPSAwO1xuICAgICAgICAvLyBUZXN0cyBzaG91bGQgYmUgb2YgdGhlIGZvcm1cbiAgICAgICAgLy8gYXNzZXJ0IHJvdyxjb2wgb3BlciB2YWx1ZSBmb3IgZXhhbXBsZVxuICAgICAgICAvLyBhc3NlcnQgNCw0ID09IDNcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHRlc3RzID0gdGVzdHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5pbmRleE9mKFwiYXNzZXJ0XCIpID4gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCB0ZXN0IG9mIHRlc3RzKSB7XG4gICAgICAgICAgICBsZXQgd2xpc3QgPSB0ZXN0LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICB3bGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgbGV0IGxvYyA9IHdsaXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICBsZXQgb3BlciA9IHdsaXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICBsZXQgZXhwZWN0ZWQgPSB3bGlzdC5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGxldCBbcm93LCBjb2xdID0gbG9jLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnRlc3RPbmVBc3NlcnQoXG4gICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgICAgICBvcGVyLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIHJlc3VsdF90YWJsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwY3QgPSAoMTAwICogdGhpcy5wYXNzZWQpIC8gKHRoaXMucGFzc2VkICsgdGhpcy5mYWlsZWQpO1xuICAgICAgICBpZiAoaXNOYU4ocGN0KSkge1xuICAgICAgICAgICAgcGN0ID0gMC4wO1xuICAgICAgICB9XG4gICAgICAgIHBjdCA9IHBjdC50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHsgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pO1xuICAgICAgICByZXN1bHQgKz0gYFlvdSBwYXNzZWQgJHt0aGlzLnBhc3NlZH0gb3V0IG9mICR7XG4gICAgICAgICAgICB0aGlzLnBhc3NlZCArIHRoaXMuZmFpbGVkXG4gICAgICAgIH0gdGVzdHMgZm9yICR7cGN0fSVgO1xuICAgICAgICB0aGlzLnVuaXRfcmVzdWx0cyA9IGBwZXJjZW50OiR7cGN0fTpwYXNzZWQ6JHt0aGlzLnBhc3NlZH06ZmFpbGVkOiR7dGhpcy5mYWlsZWR9YDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGVzdE9uZUFzc2VydChyb3csIGNvbCwgb3BlciwgZXhwZWN0ZWQsIHJlc3VsdF90YWJsZSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcm93IGFuZCBjb2wgYXJlIGluIGJvdW5kc1xuICAgICAgICBsZXQgYWN0dWFsO1xuICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFjdHVhbCA9IHJlc3VsdF90YWJsZS52YWx1ZXNbcm93XVtjb2xdO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBgRmFpbGVkIE5vdCBlbm91Z2ggZGF0YSB0byBjaGVjayByb3cgJHtyb3d9IG9yIGNvbHVtbiAke2NvbH1gO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQrKztcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BlcmF0b3JzID0ge1xuICAgICAgICAgICAgXCI9PVwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQxID09IG9wZXJhbmQyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiIT1cIjogZnVuY3Rpb24gKG9wZXJhbmQxLCBvcGVyYW5kMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kMSAhPSBvcGVyYW5kMjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIj5cIjogZnVuY3Rpb24gKG9wZXJhbmQxLCBvcGVyYW5kMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kMSA+IG9wZXJhbmQyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiPFwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQxID4gb3BlcmFuZDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzID0gb3BlcmF0b3JzW29wZXJdKGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBgUGFzczogJHthY3R1YWx9ICR7b3Blcn0gJHtleHBlY3RlZH0gaW4gcm93ICR7cm93fSBjb2x1bW4gJHtyZXN1bHRfdGFibGUuY29sdW1uc1tjb2xdfWA7XG4gICAgICAgICAgICB0aGlzLnBhc3NlZCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gYEZhaWxlZCAke2FjdHVhbH0gJHtvcGVyfSAke2V4cGVjdGVkfSBpbiByb3cgJHtyb3d9IGNvbHVtbiAke3Jlc3VsdF90YWJsZS5jb2x1bW5zW2NvbF19YDtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKHRhYmxlRGF0YSwgY29udGFpbmVyLCBtYXhIZWlnaHQpIHtcbiAgICBsZXQgZGF0YSA9IHRhYmxlRGF0YS52YWx1ZXM7XG4gICAgbGV0IHRyaW1Sb3dzID0gdW5kZWZpbmVkO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBrbHVkZ2U6IG5vIGNvbHVtbiBoZWFkZXJzIHdpbGwgc2hvdyB1cCB1bmxlc3Mgd2UgZG8gdGhpc1xuICAgICAgICBkYXRhID0gW3RhYmxlRGF0YS5jb2x1bW5zLm1hcCgoZSkgPT4gbnVsbCldO1xuICAgICAgICB0cmltUm93cyA9IFswXTtcbiAgICB9XG5cbiAgICB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShjb250YWluZXIsIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgdHJpbVJvd3M6IHRyaW1Sb3dzLFxuICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgICBhdXRvUm93U2l6ZTogdHJ1ZSxcbiAgICAgICAgYXV0b0NvbHVtblNpemU6IHsgdXNlSGVhZGVyczogdHJ1ZSB9LFxuICAgICAgICByb3dIZWFkZXJzOiBmYWxzZSxcbiAgICAgICAgY29sSGVhZGVyczogdGFibGVEYXRhLmNvbHVtbnMsXG4gICAgICAgIGVkaXRvcjogZmFsc2UsXG4gICAgICAgIG1heFJvd3M6IDEwMCxcbiAgICAgICAgZmlsdGVyczogZmFsc2UsXG4gICAgICAgIGRyb3Bkb3duTWVudTogZmFsc2UsXG4gICAgICAgIGxpY2Vuc2VLZXk6IFwibm9uLWNvbW1lcmNpYWwtYW5kLWV2YWx1YXRpb25cIixcbiAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgaGVpZ2h0IGFuZCByZXNpemVcbiAgICBsZXQgYWN0dWFsSGVpZ2h0ID0gNDA7IC8vIGhlYWRlciBoZWlnaHQgKyBzbWFsbCBtYXJnaW5cbiAgICBpZiAodGFibGVEYXRhLnZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gYWN0dWFsSGVpZ2h0ICsgaG90LmdldFJvd0hlaWdodChpKTtcbiAgICAgICAgICAgIGlmIChhY3R1YWxIZWlnaHQgPiBtYXhIZWlnaHQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG90LnVwZGF0ZVNldHRpbmdzKHsgaGVpZ2h0OiBhY3R1YWxIZWlnaHQgfSk7XG5cbiAgICByZXR1cm4gaG90O1xufVxuIiwiaW1wb3J0IFJ1bmVzdG9uZUJhc2UgZnJvbSBcIi4uLy4uL2NvbW1vbi9qcy9ydW5lc3RvbmViYXNlLmpzXCI7XG5cbi8vIGZ1bmN0aW9uIHRvIGRpc3BsYXkgdGhlIGF1ZGlvIHRvdXJzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdWRpb1RvdXIgZXh0ZW5kcyBSdW5lc3RvbmVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihkaXZpZCwgY29kZSwgYm51bSwgYXVkaW9fdGV4dCkge1xuICAgICAgICAvLyBCdWcgRml4OiBJZiBhIGNsYXNzIGV4dGVuZHMgYW5vdGhlciBjbGFzcywgdGhpcyBpcyB1bmRlZmluZWQgVU5USUwgc3VwZXIgaXMgY2FsbGVkXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXVkaW9fdG91ciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXVkaW9fY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMud2luZG93Y29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8gPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZfYXVkaW8gPSBudWxsO1xuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BfYnV0dG9uID0gbnVsbDtcbiAgICAgICAgdGhpcy50b3VyQnV0dG9ucyA9IFtdO1xuICAgICAgICB0aGlzLmVsZW0gPSBudWxsOyAvLyBjdXJyZW50IGF1ZGlvIGVsZW1lbnQgcGxheWluZ1xuICAgICAgICB0aGlzLmN1cnJJbmRleCA9IG51bGw7IC8vIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgdGhpcy5sZW4gPSBudWxsOyAvLyBjdXJyZW50IGxlbmd0aCBvZiBhdWRpbyBmaWxlcyBmb3IgdG91clxuICAgICAgICB0aGlzLmJ1dHRvbkNvdW50ID0gbnVsbDsgLy8gbnVtYmVyIG9mIGF1ZGlvIHRvdXIgYnV0dG9uc1xuICAgICAgICB0aGlzLmFuYW1lID0gbnVsbDsgLy8gdGhlIGF1ZGlvIGZpbGUgbmFtZVxuICAgICAgICB0aGlzLmFoYXNoID0gbnVsbDsgLy8gaGFzaCBvZiB0aGUgYXVkaW8gZmlsZSBuYW1lIHRvIHRoZSBsaW5lcyB0byBoaWdobGlnaHRcbiAgICAgICAgdGhpcy50aGVEaXZpZCA9IG51bGw7IC8vIGRpdiBpZFxuICAgICAgICB0aGlzLmFmaWxlID0gbnVsbDsgLy8gZmlsZSBuYW1lIGZvciBhdWRpb1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTsgLy8gZmxhZyB0byBzYXkgaWYgcGxheWluZyBvciBub3RcbiAgICAgICAgdGhpcy50b3VyTmFtZSA9IFwiXCI7XG4gICAgICAgIC8vIFJlcGxhY2luZyBoYXMgYmVlbiBkb25lIGhlcmUgdG8gbWFrZSBzdXJlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgY29kZSBhcmUgZGlzcGxheWVkIGNvcnJlY3RseVxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlQWxsKFwiKmRvdWJsZXEqXCIsICdcIicpO1xuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlQWxsKFwiKnNpbmdsZXEqXCIsIFwiJ1wiKTtcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZUFsbChcIipvcGVuKlwiLCBcIihcIik7XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2VBbGwoXCIqY2xvc2UqXCIsIFwiKVwiKTtcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZUFsbChcIipubGluZSpcIiwgXCI8YnIvPlwiKTtcbiAgICAgICAgdmFyIGNvZGVBcnJheSA9IGNvZGUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHZhciBhdWRpb19oYXNoID0gW107XG4gICAgICAgIHZhciBidmFsID0gW107XG4gICAgICAgIHZhciBhdHlwZSA9IGF1ZGlvX3RleHQucmVwbGFjZUFsbChcIipkb3VibGVxKlwiLCAnXCInKTtcbiAgICAgICAgdmFyIGF1ZGlvX3R5cGUgPSBhdHlwZS5zcGxpdChcIiphdHlwZSpcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9fdHlwZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGF1ZGlvX2hhc2hbaV0gPSBhdWRpb190eXBlW2ldO1xuICAgICAgICAgICAgdmFyIGF3b3JkID0gYXVkaW9fdHlwZVtpXS5zcGxpdChcIjtcIik7XG4gICAgICAgICAgICBidmFsLnB1c2goYXdvcmRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdCA9XG4gICAgICAgICAgICBcIjxwcmU+PGRpdiBpZD0nXCIgK1xuICAgICAgICAgICAgZGl2aWQgK1xuICAgICAgICAgICAgXCJfbDEnPlwiICtcbiAgICAgICAgICAgIFwiMS4gICBcIiArXG4gICAgICAgICAgICBjb2RlQXJyYXlbMF0gK1xuICAgICAgICAgICAgXCI8L2Rpdj5cIjtcbiAgICAgICAgdmFyIG51bV9saW5lcyA9IGNvZGVBcnJheS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtX2xpbmVzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgOSkge1xuICAgICAgICAgICAgICAgIGZpcnN0ID1cbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgK1xuICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J1wiICtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWQgK1xuICAgICAgICAgICAgICAgICAgICBcIl9sXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgXCInPlwiICtcbiAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIFwiLiAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgY29kZUFycmF5W2ldICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDk5KSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCArXG4gICAgICAgICAgICAgICAgICAgIFwiPGRpdiBpZD0nXCIgK1xuICAgICAgICAgICAgICAgICAgICBkaXZpZCArXG4gICAgICAgICAgICAgICAgICAgIFwiX2xcIiArXG4gICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIic+XCIgK1xuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgXCIuICBcIiArXG4gICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheVtpXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9kaXY+XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0ID1cbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgK1xuICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J1wiICtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWQgK1xuICAgICAgICAgICAgICAgICAgICBcIl9sXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgXCInPlwiICtcbiAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheVtpXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9kaXY+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3QgPSBmaXJzdCArIFwiPC9wcmU+XCI7XG4gICAgICAgIC8vbGF5aW5nIG91dCB0aGUgSFRNTCBjb250ZW50XG4gICAgICAgIHZhciBiY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF1ZGlvX3R5cGUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgICAgIG5ld0J1dHRvbi5jbGFzc05hbWUgPSBcImJ0biBidG4tc3VjY2Vzc1wiO1xuICAgICAgICAgICAgbmV3QnV0dG9uLmlubmVySFRNTCA9IGJ2YWxbaV0ucmVwbGFjZSgvXFxcIi9nLCBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMudG91ckJ1dHRvbnMucHVzaChuZXdCdXR0b24pO1xuICAgICAgICAgICAgYmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdWRpb190b3VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hdWRpb190b3VyLmFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgdGhpcy5hdWRpb19jb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgIHRoaXMud2luZG93Y29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMud2luZG93Y29kZS5hbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICAkKHRoaXMud2luZG93Y29kZSkuaHRtbChmaXJzdCk7XG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLnByZXZfYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpby5jbGFzc05hbWUgPVxuICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLWZhc3QtYmFja3dhcmRcIjtcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLmNsYXNzTmFtZSA9XG4gICAgICAgICAgICBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tc3RlcC1iYWNrd2FyZFwiO1xuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLmNsYXNzTmFtZSA9IFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1wYXVzZVwiO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8uY2xhc3NOYW1lID1cbiAgICAgICAgICAgIFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1zdGVwLWZvcndhcmRcIjtcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLmNsYXNzTmFtZSA9XG4gICAgICAgICAgICBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tZmFzdC1mb3J3YXJkXCI7XG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgXCJoZWlnaHQ6IDIycHg7IHdpZHRoOiAyNXB4OyBib3JkZXItcmFkaXVzOiA0cHg7IG1hcmdpbi1yaWdodDoycHg7XCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0OiAyMnB4OyB3aWR0aDogMjVweDsgYm9yZGVyLXJhZGl1czogNHB4OyBtYXJnaW4tcmlnaHQ6MnB4O1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgXCJoZWlnaHQ6IDIycHg7IHdpZHRoOiAyNXB4OyBib3JkZXItcmFkaXVzOiA0cHg7IG1hcmdpbi1yaWdodDoycHg7XCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0OiAyMnB4OyB3aWR0aDogMjVweDsgYm9yZGVyLXJhZGl1czogNHB4OyBtYXJnaW4tcmlnaHQ6MnB4O1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubGFzdF9hdWRpby5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICBcImhlaWdodDogMjJweDsgd2lkdGg6IDI1cHg7IGJvcmRlci1yYWRpdXM6IDRweDsgbWFyZ2luLXJpZ2h0OjJweDtcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLm5hbWUgPSBcImZpcnN0X2F1ZGlvXCI7XG4gICAgICAgIHRoaXMucHJldl9hdWRpby5uYW1lID0gXCJwcmV2X2F1ZGlvXCI7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8ubmFtZSA9IFwicGF1c2VfYXVkaW9cIjtcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvLm5hbWUgPSBcIm5leHRfYXVkaW9cIjtcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLm5hbWUgPSBcImxhc3RfYXVkaW9cIjtcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpby50aXRsZSA9IFwiUGxheSBmaXJzdCBhdWRpbyBpbiB0b3VyXCI7XG4gICAgICAgIHRoaXMucHJldl9hdWRpby50aXRsZSA9IFwiUGxheSBwcmV2aW91cyBhdWRpbyBpbiB0b3VyXCI7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8udGl0bGUgPSBcIlBhdXNlIGN1cnJlbnQgYXVkaW9cIjtcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvLnRpdGxlID0gXCJQbGF5IG5leHQgYXVkaW8gaW4gdG91clwiO1xuICAgICAgICB0aGlzLmxhc3RfYXVkaW8udGl0bGUgPSBcIlBsYXkgbGFzdCBhdWRpbyBpbiB0b3VyXCI7XG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlBsYXkgZmlyc3QgYXVkaW8gaW4gdG91clwiKTtcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgICAgICAgXCJQbGF5IHByZXZpb3VzIGF1ZGlvIGluIHRvdXJcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQYXVzZSBhdWRpb1wiKTtcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQbGF5IG5leHQgYXVkaW8gaW4gdG91clwiKTtcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQbGF5IGxhc3QgYXVkaW8gaW4gdG91clwiKTtcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpby5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucHJldl9hdWRpby5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RfYXVkaW8uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc3RhdHVzLmNsYXNzTmFtZSA9IFwiYWxlcnQgYWxlcnQtaW5mb1wiO1xuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6IG5vbmU7XCIpO1xuICAgICAgICB0aGlzLnN0b3BfYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy5zdG9wX2J1dHRvbi5jbGFzc05hbWUgPSBcImJ0biBidG4tZGVmYXVsdFwiO1xuICAgICAgICB0aGlzLnN0b3BfYnV0dG9uLmlubmVySFRNTCA9IFwiU3RvcCB0b3VyXCI7XG4gICAgICAgICQodGhpcy5hdWRpb190b3VyKS5hcHBlbmQoXG4gICAgICAgICAgICB0aGlzLmF1ZGlvX2NvZGUsXG4gICAgICAgICAgICB0aGlzLndpbmRvd2NvZGUsXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIiksXG4gICAgICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLFxuICAgICAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLFxuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpbyxcbiAgICAgICAgICAgIHRoaXMubmV4dF9hdWRpbyxcbiAgICAgICAgICAgIHRoaXMubGFzdF9hdWRpbyxcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSxcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpLFxuICAgICAgICAgICAgdGhpcy50b3VyQnV0dG9ucyxcbiAgICAgICAgICAgIHRoaXMuc3RvcF9idXR0b25cbiAgICAgICAgKTtcbiAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLmFjX2NvZGVfZGl2XCIpLmFwcGVuZCh0aGlzLmF1ZGlvX3RvdXIpO1xuICAgICAgICAkKFwiI1wiICsgZGl2aWQgKyBcIiAuYWNfY29kZV9kaXZcIikuY3NzKFwid2lkdGhcIiwgXCIxMDAlXCIpO1xuICAgICAgICAkKFwiI1wiICsgZGl2aWQgKyBcIiAuQ29kZU1pcnJvci5jbS1zLWRlZmF1bHQudWktcmVzaXphYmxlXCIpLmhpZGUoKTtcbiAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLmFjX29wdC5idG4uYnRuLWRlZmF1bHQ6bGFzdC1jaGlsZFwiKS5oaWRlKCk7XG4gICAgICAgICQodGhpcy5zdG9wX2J1dHRvbikuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxheWluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9sb2cgY2hhbmdlIHRvIGRiXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Q6IFwiY2xvc2VXaW5kb3dcIixcbiAgICAgICAgICAgICAgICAgICAgZGl2X2lkOiBkaXZpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkKHRoaXMuYXVkaW9fdG91cikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgJChcbiAgICAgICAgICAgICAgICAgICAgXCIjXCIgKyBkaXZpZCArIFwiIC5Db2RlTWlycm9yLmNtLXMtZGVmYXVsdC51aS1yZXNpemFibGVcIlxuICAgICAgICAgICAgICAgICkuc2hvdygpO1xuICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZpZCArIFwiIC5hY19vcHQuYnRuLmJ0bi1kZWZhdWx0Omxhc3QtY2hpbGRcIikuc2hvdygpO1xuICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZpZCArIFwiIC5hY19jb2RlX2RpdlwiKS5jc3MoXCJ3aWR0aFwiLCBcIlwiKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAkKHRoaXMudG91ckJ1dHRvbnNbMF0pLmNsaWNrKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91cihkaXZpZCwgYXVkaW9faGFzaFswXSwgYmNvdW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAkKHRoaXMudG91ckJ1dHRvbnNbMV0pLmNsaWNrKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91cihkaXZpZCwgYXVkaW9faGFzaFsxXSwgYmNvdW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAkKHRoaXMudG91ckJ1dHRvbnNbMl0pLmNsaWNrKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91cihkaXZpZCwgYXVkaW9faGFzaFsyXSwgYmNvdW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAkKHRoaXMudG91ckJ1dHRvbnNbM10pLmNsaWNrKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91cihkaXZpZCwgYXVkaW9faGFzaFszXSwgYmNvdW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAkKHRoaXMudG91ckJ1dHRvbnNbNF0pLmNsaWNrKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91cihkaXZpZCwgYXVkaW9faGFzaFs0XSwgYmNvdW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIGdvIHRvIHRoZSBuZXh0IGF1ZGlvXG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdEF1ZGlvKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjbGljayB0byBnbyB0byB0aGUgbmV4dCBhdWRpb1xuICAgICAgICAkKHRoaXMucHJldl9hdWRpbykuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2QXVkaW8oKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIHBhdXNlIG9yIHBsYXkgdGhlIGF1ZGlvXG4gICAgICAgICQodGhpcy5wYXVzZV9hdWRpbykuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZUFuZFBsYXlBdWRpbyhkaXZpZCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjbGljayB0byBnbyB0byB0aGUgbmV4dCBhdWRpb1xuICAgICAgICAkKHRoaXMubmV4dF9hdWRpbykuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW8oKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIGdvIHRvIHRoZSBuZXh0IGF1ZGlvXG4gICAgICAgICQodGhpcy5sYXN0X2F1ZGlvKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RBdWRpbygpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIC8vIG1ha2UgdGhlIGltYWdlIGJ1dHRvbnMgbG9vayBkaXNhYmxlZFxuICAgICAgICAkKHRoaXMuZmlyc3RfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XG4gICAgICAgICQodGhpcy5wcmV2X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDAuMjUpO1xuICAgICAgICAkKHRoaXMucGF1c2VfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XG4gICAgICAgICQodGhpcy5uZXh0X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDAuMjUpO1xuICAgICAgICAkKHRoaXMubGFzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcbiAgICB9XG4gICAgdG91cihkaXZpZCwgYXVkaW9fdHlwZSwgYmNvdW50KSB7XG4gICAgICAgIC8vIHNldCBnbG9iYWxzXG4gICAgICAgIHRoaXMuYnV0dG9uQ291bnQgPSBiY291bnQ7XG4gICAgICAgIHRoaXMudGhlRGl2aWQgPSBkaXZpZDtcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG1hcmdpbi10b3A6IDdweDsgbWFyZ2luLWJvdHRvbTogM3B4O1wiXG4gICAgICAgICk7XG4gICAgICAgIC8vIGVuYWJsZSBwcmV2LCBwYXVzZS9wbGF5IGFuZCBuZXh0IGJ1dHRvbnMgYW5kIG1ha2UgdmlzaWJsZVxuICAgICAgICAkKHRoaXMuZmlyc3RfYXVkaW8pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLnByZXZfYXVkaW8pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQodGhpcy5uZXh0X2F1ZGlvKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQodGhpcy5sYXN0X2F1ZGlvKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAxLjApO1xuICAgICAgICAkKHRoaXMucHJldl9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAxLjApO1xuICAgICAgICAkKHRoaXMucGF1c2VfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMS4wKTtcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMS4wKTtcbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMS4wKTtcbiAgICAgICAgLy8gZGlzYWJsZSB0b3VyIGJ1dHRvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiY291bnQ7IGkrKylcbiAgICAgICAgICAgICQodGhpcy50b3VyQnV0dG9uc1tpXSkuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XG4gICAgICAgIHZhciBhdHlwZSA9IGF1ZGlvX3R5cGUuc3BsaXQoXCI7XCIpO1xuICAgICAgICB2YXIgbmFtZSA9IGF0eXBlWzBdLnJlcGxhY2VBbGwoJ1wiJywgXCIgXCIpO1xuICAgICAgICB0aGlzLnRvdXJOYW1lID0gbmFtZTtcbiAgICAgICAgJCh0aGlzLnN0YXR1cykuaHRtbCgkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zdGFydGluZ1wiLCBuYW1lKSk7XG4gICAgICAgIC8vbG9nIHRvdXIgdHlwZSB0byBkYlxuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7IGV2ZW50OiBcIkF1ZGlvXCIsIGFjdDogbmFtZSwgZGl2X2lkOiBkaXZpZCB9KTtcbiAgICAgICAgdmFyIG1heCA9IGF0eXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYWhhc2ggPSBbXTtcbiAgICAgICAgdGhpcy5hbmFtZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbWF4IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGF0eXBlW2ldLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIHZhciB0ZW1wX2xpbmUgPSB0ZW1wWzBdO1xuICAgICAgICAgICAgdmFyIHRlbXBfYW5hbWUgPSB0ZW1wWzFdO1xuICAgICAgICAgICAgdmFyIGFrZXkgPSB0ZW1wX2FuYW1lLnN1YnN0cmluZygxLCB0ZW1wX2FuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbG51bXMgPSB0ZW1wX2xpbmUuc3Vic3RyaW5nKDEsIHRlbXBfbGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgLy9hbGVydChcImFrZXk6XCIrYWtleStcImxudW06XCIrbG51bXMpO1xuICAgICAgICAgICAgLy8gc3RyKz1cIjxhdWRpbyBpZD1cIitha2V5K1wiIHByZWxvYWQ9J2F1dG8nPjxzb3VyY2Ugc3JjPSdodHRwOi8vaWNlLXdlYi5jYy5nYXRlY2guZWR1L2NlMjEvYXVkaW8vXCIrXG4gICAgICAgICAgICAvLyBha2V5K1wiLm1wMycgdHlwZT0nYXVkaW8vbXBlZyc+PHNvdXJjZSBzcmM9J2h0dHA6Ly9pY2Utd2ViLmNjLmdhdGVjaC5lZHUvY2UyMS9hdWRpby9cIitha2V5K1xuICAgICAgICAgICAgLy8gXCIub2dnJyB0eXBlPSdhdWRpby9vZ2cnPllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBhdWRpbyB0YWc8L2F1ZGlvPlwiO1xuICAgICAgICAgICAgLy92YXIgZGlyID1cbiAgICAgICAgICAgIC8vICAgIFwiaHR0cDovL21lZGlhLmludGVyYWN0aXZlcHl0aG9uLm9yZy9cIiArXG4gICAgICAgICAgICAvLyAgICBlQm9va0NvbmZpZy5iYXNlY291cnNlLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgICAgLy8gICAgXCIvYXVkaW8vXCI7XG4gICAgICAgICAgICB2YXIgZGlyID0gXCIuLi9fc3RhdGljL2F1ZGlvL1wiXG4gICAgICAgICAgICBzdHIgKz0gXCI8YXVkaW8gaWQ9XCIgKyBha2V5ICsgXCIgcHJlbG9hZD0nYXV0bycgPlwiO1xuICAgICAgICAgICAgc3RyICs9IFwiPHNvdXJjZSBzcmM9J1wiICsgZGlyICsgYWtleSArIFwiLndhdicgdHlwZT0nYXVkaW8vd2F2Jz5cIjtcbiAgICAgICAgICAgIHN0ciArPSBcIjxzb3VyY2Ugc3JjPSdcIiArIGRpciArIGFrZXkgKyBcIi5tcDMnIHR5cGU9J2F1ZGlvL21wZWcnPlwiO1xuICAgICAgICAgICAgc3RyICs9IFwiPHNvdXJjZSBzcmM9J1wiICsgZGlyICsgYWtleSArIFwiLndhdicgdHlwZT0nYXVkaW8vd2F2Jz5cIjtcbiAgICAgICAgICAgIHN0ciArPSBcIjxzb3VyY2Ugc3JjPSdcIiArIGRpciArIGFrZXkgKyBcIi5tcDMnIHR5cGU9J2F1ZGlvL21wZWcnPlwiO1xuICAgICAgICAgICAgc3RyICs9IFwiPGJyIC8+WW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIGF1ZGlvIHRhZzwvYXVkaW8+XCI7XG4gICAgICAgICAgICB0aGlzLmFoYXNoW2FrZXldID0gbG51bXM7XG4gICAgICAgICAgICB0aGlzLmFuYW1lLnB1c2goYWtleSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLmF1ZGlvX2NvZGUpLmh0bWwoc3RyKTtcbiAgICAgICAgdGhpcy5sZW4gPSB0aGlzLmFuYW1lLmxlbmd0aDsgLy8gc2V0IHRoZSBudW1iZXIgb2YgYXVkaW8gZmlsZSBpbiB0aGUgdG91clxuICAgICAgICB0aGlzLmN1cnJJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucGxheUN1cnJJbmRleEF1ZGlvKCk7XG4gICAgfVxuICAgIGhhbmRsZVBsYXlpbmcoKSB7XG4gICAgICAgIHRoaXMuZWxlbS5wYXVzZSgpO1xuICAgICAgICAvLyB1bmJpbmQgY3VycmVudCBlbmRlZFxuICAgICAgICAkKFwiI1wiICsgdGhpcy5hZmlsZSkudW5iaW5kKFwiZW5kZWRcIik7XG4gICAgICAgIC8vIHVuaGlnaGxpZ2h0IHRoZSBwcmV2IGxpbmVzXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHRMaW5lcyhcbiAgICAgICAgICAgIHRoaXMudGhlRGl2aWQsXG4gICAgICAgICAgICB0aGlzLmFoYXNoW3RoaXMuYW5hbWVbdGhpcy5jdXJySW5kZXhdXVxuICAgICAgICApO1xuICAgIH1cbiAgICBmaXJzdEF1ZGlvKCkge1xuICAgICAgICAvLyBpZiBhdWRpbyBpcyB0aGlzLnBsYXlpbmcgaGFuZGxlIGl0XG4gICAgICAgIHRoaXMuaGFuZGxlUGxheWluZygpO1xuICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcbiAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwiQXVkaW9cIixcbiAgICAgICAgICAgIGFjdDogXCJmaXJzdFwiLFxuICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gbW92ZSB0byB0aGUgZmlyc3QgYXVkaW9cbiAgICAgICAgdGhpcy5jdXJySW5kZXggPSAwO1xuICAgICAgICAvLyBzdGFydCBhdCB0aGUgZmlyc3QgYXVkaW9cbiAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcbiAgICB9XG4gICAgcHJldkF1ZGlvKCkge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHByZXZpb3VzIGF1ZGlvXG4gICAgICAgIGlmICh0aGlzLmN1cnJJbmRleCA+IDApIHtcbiAgICAgICAgICAgIC8vIGlmIGF1ZGlvIGlzIHRoaXMucGxheWluZyBoYW5kbGUgaXRcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUGxheWluZygpO1xuICAgICAgICAgICAgLy9sb2cgY2hhbmdlIHRvIGRiXG4gICAgICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwiQXVkaW9cIixcbiAgICAgICAgICAgICAgICBhY3Q6IFwicHJldlwiLFxuICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy50aGVEaXZpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbW92ZSB0byBwcmV2aW91cyB0byB0aGUgY3VycmVudCAoYnV0IHRoZSBjdXJyZW50IGluZGV4IGhhcyBtb3ZlZCB0byB0aGUgbmV4dClcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gdGhpcy5jdXJySW5kZXggLSAxO1xuICAgICAgICAgICAgLy8gc3RhcnQgYXQgdGhlIHByZXYgYXVkaW9cbiAgICAgICAgICAgIHRoaXMucGxheUN1cnJJbmRleEF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dEF1ZGlvKCkge1xuICAgICAgICAvLyBpZiBhdWRpbyBpcyB0aGlzLnBsYXlpbmcgaGFuZGxlIGl0XG4gICAgICAgIHRoaXMuaGFuZGxlUGxheWluZygpO1xuICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcbiAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwiQXVkaW9cIixcbiAgICAgICAgICAgIGFjdDogXCJuZXh0XCIsXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMudGhlRGl2aWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiBub3QgYXQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5jdXJySW5kZXggPCB0aGlzLmxlbiAtIDEpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBuZXh0IGF1ZGlvXG4gICAgICAgICAgICB0aGlzLmN1cnJJbmRleCA9IHRoaXMuY3VyckluZGV4ICsgMTtcbiAgICAgICAgICAgIHRoaXMucGxheUN1cnJJbmRleEF1ZGlvKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJySW5kZXggPT0gdGhpcy5sZW4gLSAxKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRvdXJFbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsYXN0QXVkaW8oKSB7XG4gICAgICAgIC8vIGlmIGF1ZGlvIGlzIHRoaXMucGxheWluZyBoYW5kbGUgaXRcbiAgICAgICAgdGhpcy5oYW5kbGVQbGF5aW5nKCk7XG4gICAgICAgIC8vbG9nIGNoYW5nZSB0byBkYlxuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxuICAgICAgICAgICAgYWN0OiBcImxhc3RcIixcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy50aGVEaXZpZCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG1vdmUgdG8gdGhlIGxhc3QgYXVkaW9cbiAgICAgICAgdGhpcy5jdXJySW5kZXggPSB0aGlzLmxlbiAtIDE7XG4gICAgICAgIC8vIHN0YXJ0IGF0IGxhc3RcbiAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcbiAgICB9XG4gICAgLy8gcGxheSB0aGUgYXVkaW8gYXQgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICBwbGF5Q3VyckluZGV4QXVkaW8oKSB7XG4gICAgICAgIC8vIHNldCB0aGlzLnBsYXlpbmcgdG8gZmFsc2VcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIHBsYXkgdGhlIGN1cnJlbnQgYXVkaW8gYW5kIGhpZ2hsaWdodCB0aGUgbGluZXNcbiAgICAgICAgdGhpcy5wbGF5YXVkaW8odGhpcy5jdXJySW5kZXgsIHRoaXMuYW5hbWUsIHRoaXMudGhlRGl2aWQsIHRoaXMuYWhhc2gpO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgdGhlIGVuZCBvZiB0aGUgdG91clxuICAgIGhhbmRsZVRvdXJFbmQoKSB7XG4gICAgICAgICQodGhpcy5zdGF0dXMpLmh0bWwoXCJUaGUgXCIgKyB0aGlzLnRvdXJOYW1lICsgXCIgaGFzIGVuZGVkLlwiKTtcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5jbGFzc05hbWUgPSBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tcGF1c2VcIjtcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby50aXRsZSA9IFwiUGF1c2UgYXVkaW9cIjtcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiUGF1c2UgYXVkaW9cIik7XG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQodGhpcy5wcmV2X2F1ZGlvKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAkKHRoaXMubGFzdF9hdWRpbykuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcbiAgICAgICAgJCh0aGlzLnByZXZfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XG4gICAgICAgICQodGhpcy5wYXVzZV9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XG4gICAgICAgICQodGhpcy5sYXN0X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDAuMjUpO1xuICAgICAgICAvLyBlbmFibGUgdGhlIHRvdXIgYnV0dG9uc1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYnV0dG9uQ291bnQ7IGorKylcbiAgICAgICAgICAgICQodGhpcy50b3VyQnV0dG9uc1tqXSkucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgIH1cbiAgICAvLyBvbmx5IGNhbGwgdGhpcyBvbmUgYWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgICBvdXRlckF1ZGlvKCkge1xuICAgICAgICAvLyB1bmJpbmQgZW5kZWRcbiAgICAgICAgJChcIiNcIiArIHRoaXMuYWZpbGUpLnVuYmluZChcImVuZGVkXCIpO1xuICAgICAgICAvLyBzZXQgdGhpcy5wbGF5aW5nIHRvIGZhbHNlXG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgICAgICAvLyB1bmhpZ2hsaWdodCBwcmV2aW91cyBsaW5lcyBmcm9tIHRoZSBsYXN0IGF1ZGlvXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHRMaW5lcyhcbiAgICAgICAgICAgIHRoaXMudGhlRGl2aWQsXG4gICAgICAgICAgICB0aGlzLmFoYXNoW3RoaXMuYW5hbWVbdGhpcy5jdXJySW5kZXhdXVxuICAgICAgICApO1xuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHRoaXMuY3VyckluZGV4IHRvIHBvaW50IHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICB0aGlzLmN1cnJJbmRleCsrO1xuICAgICAgICAvLyBpZiB0aGUgZW5kIG9mIHRoZSB0b3VyIHJlc2V0IHRoZSBidXR0b25zXG4gICAgICAgIGlmICh0aGlzLmN1cnJJbmRleCA9PSB0aGlzLmxlbikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUb3VyRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBub3QgZG9uZSB5ZXQgc28gcGxheSB0aGUgbmV4dCBhdWRpb1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBsYXkgdGhlIGF1ZGlvIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgICAgICB0aGlzLnBsYXlDdXJySW5kZXhBdWRpbygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHBsYXkgdGhlIGF1ZGlvIG5vdyB0aGF0IGl0IGlzIHJlYWR5XG4gICAgcGxheVdoZW5SZWFkeShhZmlsZSwgZGl2aWQsIGFoYXNoKSB7XG4gICAgICAgIC8vIHVuYmluZCBjdXJyZW50XG4gICAgICAgICQoXCIjXCIgKyBhZmlsZSkudW5iaW5kKFwiY2FucGxheXRocm91Z2hcIik7XG4gICAgICAgIHRoaXMuZWxlbS5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJpbiBwbGF5V2hlblJlYWR5IFwiICsgZWxlbS5kdXJhdGlvbik7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0TGluZXMoZGl2aWQsIGFoYXNoW2FmaWxlXSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8uY2xhc3NOYW1lID09PVxuICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXBhdXNlXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAkKHRoaXMuc3RhdHVzKS5odG1sKFxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3BsYXlpbmdcIiwgdGhpcy50b3VyTmFtZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAkKFwiI1wiICsgYWZpbGUpLmJpbmQoXG4gICAgICAgICAgICAgICAgXCJlbmRlZFwiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRlckF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5lbGVtLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoXCIjXCIgKyBhZmlsZSkuYmluZChcbiAgICAgICAgICAgICAgICBcImVuZGVkXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dGVyQXVkaW8oKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGxheSB0aGUgYXVkaW8gYXQgdGhlIHNwZWNpZmllZCBpbmRleCBpIGFuZCBzZXQgdGhlIGR1cmF0aW9uIGFuZCBoaWdobGlnaHQgdGhlIGxpbmVzXG4gICAgcGxheWF1ZGlvKGksIGFuYW1lLCBkaXZpZCwgYWhhc2gpIHtcbiAgICAgICAgdGhpcy5hZmlsZSA9IGFuYW1lW2ldO1xuICAgICAgICB0aGlzLmVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmFmaWxlKTtcbiAgICAgICAgLy8gaWYgdGhpcyBpc24ndCByZWFkeSB0byBwbGF5IHlldCAtIG5vIGR1cmF0aW9uIHlldCB0aGVuIHdhaXRcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImluIHBsYXlhdWRpbyBcIiArIGVsZW0uZHVyYXRpb24pO1xuICAgICAgICBpZiAoaXNOYU4odGhpcy5lbGVtLmR1cmF0aW9uKSB8fCB0aGlzLmVsZW0uZHVyYXRpb24gPT0gMCkge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBzdGF0dXNcbiAgICAgICAgICAgICQodGhpcy5zdGF0dXMpLmh0bWwoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbG9hZGluZ19hdWRpb1wiKSk7XG4gICAgICAgICAgICAkKFwiI1wiICsgdGhpcy5hZmlsZSkuYmluZChcbiAgICAgICAgICAgICAgICBcImNhbnBsYXl0aHJvdWdoXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlXaGVuUmVhZHkodGhpcy5hZmlsZSwgZGl2aWQsIGFoYXNoKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIHJlYWR5IHNvIHBsYXkgaXRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBsYXlXaGVuUmVhZHkodGhpcy5hZmlsZSwgZGl2aWQsIGFoYXNoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwYXVzZSBpZiB0aGlzLnBsYXlpbmcgYW5kIHBsYXkgaWYgcGF1c2VkXG4gICAgcGF1c2VBbmRQbGF5QXVkaW8oZGl2aWQpIHtcbiAgICAgICAgdmFyIGJ0biA9IHRoaXMucGF1c2VfYXVkaW87XG4gICAgICAgIC8vIGlmIHBhdXNlZCBhbmQgY2xpY2tlZCB0aGVuIGNvbnRpbnVlIGZyb20gY3VycmVudFxuICAgICAgICBpZiAodGhpcy5lbGVtLnBhdXNlZCkge1xuICAgICAgICAgICAgLy8gY2FsY3VhbHRlIHRoZSB0aW1lIGxlZnQgdG8gcGxheSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGxldCBjb3VudGVyID0gKHRoaXMuZWxlbS5kdXJhdGlvbiAtIHRoaXMuZWxlbS5jdXJyZW50VGltZSkgKiAxMDAwO1xuICAgICAgICAgICAgdGhpcy5lbGVtLnBsYXkoKTsgLy8gc3RhcnQgdGhlIGF1ZGlvIGZyb20gY3VycmVudCBzcG90XG4gICAgICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLmNsYXNzTmFtZSA9XG4gICAgICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXBhdXNlXCI7XG4gICAgICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnRpdGxlID0gJC5pMThuKFxuICAgICAgICAgICAgICAgIFwibXNnX2FjdGl2ZWNvZGVfcGF1c2VfY3VycmVudF9hdWRpb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcGF1c2VfYXVkaW9cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAkKHRoaXMuc3RhdHVzKS5odG1sKFxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3BsYXlpbmdcIiwgdGhpcy50b3VyTmFtZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcbiAgICAgICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxuICAgICAgICAgICAgICAgIGFjdDogXCJwbGF5XCIsXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYXVkaW8gd2FzIHRoaXMucGxheWluZyBwYXVzZSBpdFxuICAgICAgICBlbHNlIGlmICh0aGlzLnBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbS5wYXVzZSgpOyAvLyBwYXVzZSB0aGUgYXVkaW9cbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8uY2xhc3NOYW1lID0gXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXBsYXlcIjtcbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8udGl0bGUgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9wbGF5X3BhdXNlZF9hdWRpb1wiKTtcbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3BsYXlfcGF1c2VkX2F1ZGlvXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgJCh0aGlzLnN0YXR1cykuaHRtbChcbiAgICAgICAgICAgICAgICAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9hdWRpb19wYXVzZWRcIiwgdGhpcy50b3VyTmFtZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcbiAgICAgICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxuICAgICAgICAgICAgICAgIGFjdDogXCJwYXVzZVwiLFxuICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy50aGVEaXZpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHByb2Nlc3MgdGhlIGxpbmVzXG4gICAgcHJvY2Vzc0xpbmVzKGRpdmlkLCBsbnVtLCBjb2xvcikge1xuICAgICAgICB2YXIgY29tbWEgPSBsbnVtLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgaWYgKGNvbW1hLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEJhY2tncm91bmRGb3JMaW5lcyhkaXZpZCwgY29tbWFbaV0sIGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZEZvckxpbmVzKGRpdmlkLCBsbnVtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5oaWdobGlnaHQgdGhlIGxpbmVzIC0gc2V0IHRoZSBiYWNrZ3JvdW5kIGJhY2sgdG8gdHJhbnNwYXJlbnRcbiAgICB1bmhpZ2hsaWdodExpbmVzKGRpdmlkLCBsbnVtKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0xpbmVzKGRpdmlkLCBsbnVtLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIH1cbiAgICAvLyBoaWdobGlnaHQgdGhlIGxpbmVzIC0gc2V0IHRoZSBiYWNrZ3JvdW5kIHRvIGEgeWVsbG93IGNvbG9yXG4gICAgaGlnaGxpZ2h0TGluZXMoZGl2aWQsIGxudW0pIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzTGluZXMoZGl2aWQsIGxudW0sIFwiI2ZmZmY5OVwiKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBiYWNrZ3JvdW5kIHRvIHRoZSBwYXNzZWQgY29sb3JcbiAgICBzZXRCYWNrZ3JvdW5kRm9yTGluZXMoZGl2aWQsIGxudW0sIGNvbG9yKSB7XG4gICAgICAgIHZhciBoeXBoZW4gPSBsbnVtLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgdmFyIHN0cjtcbiAgICAgICAgLy8gaWYgYSByYW5nZSBvZiBsaW5lc1xuICAgICAgICBpZiAoaHlwaGVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBhcnNlSW50KGh5cGhlblswXSk7XG4gICAgICAgICAgICB2YXIgZW5kID0gcGFyc2VJbnQoaHlwaGVuWzFdKSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gc3RhcnQ7IGsgPCBlbmQ7IGsrKykge1xuICAgICAgICAgICAgICAgIC8vYWxlcnQoayk7XG4gICAgICAgICAgICAgICAgc3RyID0gXCIjXCIgKyBkaXZpZCArIFwiX2xcIiArIGs7XG4gICAgICAgICAgICAgICAgaWYgKCQoc3RyKS50ZXh0KCkgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAkKHN0cikuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vJChzdHIpLmVmZmVjdChcImhpZ2hsaWdodFwiLHt9LChkdXIqMTAwMCkrNDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2FsZXJ0KGxudW0pO1xuICAgICAgICAgICAgc3RyID0gXCIjXCIgKyBkaXZpZCArIFwiX2xcIiArIGxudW07XG4gICAgICAgICAgICAkKHN0cikuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBjb2xvcik7XG4gICAgICAgICAgICAvLyQoc3RyKS5lZmZlY3QoXCJoaWdobGlnaHRcIix7fSwoZHVyKjEwMDApKzQ1MDApO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwidmFyIHRlc3RTdHJpbmcgPSBgU3RhcnRpbmcgVGVzdHNcbkV4cGVjdGVkOiBBbnN3ZXIgICAgICAgICAgICAgICAgICAgQWN0dWFsOiBBbnN3ZXIgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgbWV0aG9kIHByaW50QW5zd2VyKCkgICAgICAgICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkV4cGVjdGVkOiA2IGxpbmUocykgb2YgdGV4dCAgICAgICAgQWN0dWFsOiAwIGxpbmUocykgb2YgdGV4dCAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgbWFpbiBtZXRob2QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXNzZWQ6IGZhbHNlXG5IZWxsbyBXb3JsZFxuRXhwZWN0ZWQ6IFN0cmluZyBTdHJpbmcgICAgICAgICAgICBBY3R1YWw6IFN0cmluZyBTdHJpbmcgICAgICAgICAgICBNZXNzYWdlOiBDaGVja2luZyBJbnN0YW5jZSBWYXJpYWJsZSBUeXBlKHMpICAgICAgICAgICAgICAgIFBhc3NlZDogdHJ1ZVxuRXhwZWN0ZWQ6IFF1ZXN0aW9uICAgICAgICAgICAgICAgICBBY3R1YWw6IFF1ZXN0aW9uICAgICAgICAgICAgICAgICBNZXNzYWdlOiBDaGVja2luZyBtZXRob2QgcHJpbnRRdWVzdGlvbigpICAgICAgICAgICAgICAgICAgIFBhc3NlZDogdHJ1ZVxuRGVidWdnaW5nIG91dHB1dFxuTW9yZSBkZWJ1ZyBvdXRwdXRcbkV4cGVjdGVkOiAyIFByaXZhdGUgICAgICAgICAgICAgICAgQWN0dWFsOiAyIFByaXZhdGUgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgUHJpdmF0ZSBJbnN0YW5jZSBWYXJpYWJsZShzKSAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkV4cGVjdGVkOiBwYXNzICAgICAgICAgICAgICAgICAgICAgQWN0dWFsOiBwYXNzICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkV4cGVjdGVkOiBmYWlsICAgICAgICAgICAgICAgICAgICAgQWN0dWFsOiBmYWlsICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgZGVmYXVsdCBjb25zdHJ1Y3RvciAgICAgICAgICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkVuZGluZyBUZXN0c1xuWW91IGdvdCA2IG91dCBvZiA3IGNvcnJlY3QuIDg1LjcxJWA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpVbml0VGVzdFBhcnNlciB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0LCBwYXJlbnRJZCkge1xuICAgICAgICBsZXQgcGF0dCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBcIkV4cGVjdGVkOlxcXFxzKyguKj8pQWN0dWFsOlxcXFxzKyguKj8pTWVzc2FnZTpcXFxccysoLio/KVBhc3NlZDpcXFxccysodHJ1ZXxmYWxzZSlcIixcbiAgICAgICAgICAgIFwiZ1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudGV4dFJlc3VsdHMgPSBcIlwiO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG91dHB1dC5tYXRjaEFsbChwYXR0KTtcbiAgICAgICAgbGV0IHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKFwidW5pdHRlc3QtcmVzdWx0c1wiKTtcbiAgICAgICAgbGV0IHRibCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcbiAgICAgICAgdGJsLmNsYXNzTGlzdC5hZGQoXCJhYy1mZWVkYmFja1wiKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRibCk7XG4gICAgICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtwYXJlbnRJZH1fdW5pdF9yZXN1bHRzYCk7XG4gICAgICAgIGxldCB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcbiAgICAgICAgdHIuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJhYy1mZWVkYmFja1wiPlJlc3VsdDwvdGg+PHRoIGNsYXNzPVwiYWMtZmVlZGJhY2tcIj5FeHBlY3RlZDwvdGg+PHRoIGNsYXNzPVwiYWMtZmVlZGJhY2tcIj5BY3R1YWw8L3RoPjx0aCBjbGFzcz1cImFjLWZlZWRiYWNrXCI+Tm90ZXM8L3RoPic7XG4gICAgICAgIHRibC5hcHBlbmRDaGlsZCh0cik7XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgbGV0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuICAgICAgICAgICAgbGV0IHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgICAgICAgdGQuY2xhc3NMaXN0LmFkZChcImFjLWZlZWRiYWNrXCIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGQuaW5uZXJIVE1MID0gXCJQYXNzXCI7XG4gICAgICAgICAgICAgICAgdGQuc3R5bGUgPVxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6IHJnYigxMzEsIDIxMSwgMTMwKTsgdGV4dC1hbGlnbjogY2VudGVyO1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZC5pbm5lckhUTUwgPSBcIkZhaWxcIjtcbiAgICAgICAgICAgICAgICB0ZC5zdHlsZSA9XG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyMiwgMTQyLCAxNTApOyB0ZXh0LWFsaWduOiBjZW50ZXI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG4gICAgICAgICAgICB0YmwuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgICAgICAgICAgdGQuaW5uZXJIVE1MID0gbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgdGQuY2xhc3NMaXN0LmFkZChcImFjLWZlZWRiYWNrXCIpO1xuICAgICAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRibC5hcHBlbmRDaGlsZCh0cik7XG4gICAgICAgICAgICB0aGlzLnRhYmxlID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy50ZXh0UmVzdWx0cyArPSBtYXRjaFswXSArIFwiXFxuXCI7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShtYXRjaFswXSwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoID0gb3V0cHV0Lm1hdGNoKFxuICAgICAgICAgICAgL1lvdSBnb3RcXHMrKFxcZCspIG91dCBvZiAoXFxkKykgY29ycmVjdC5cXHMrKFxcZCtcXC5cXGQrKSUvXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UobWF0Y2hbMF0sIFwiXCIpO1xuICAgICAgICAgICAgbGV0IHBjdFN0cmluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgcGN0U3RyaW5nLmlubmVySFRNTCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgdGhpcy5wY3RTdHJpbmcgPSBwY3RTdHJpbmc7XG4gICAgICAgICAgICB0aGlzLnBjdCA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgdGhpcy5wYXNzZWQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkID0gbWF0Y2hbMl0gLSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShcIlN0YXJ0aW5nIFRlc3RzXCIsIFwiXCIpO1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShcIkVuZGluZyBUZXN0c1wiLCBcIlwiKTtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIik7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8oPGJyPikrL2csIFwiPGJyPlwiKTtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2VBbGwoXCImbHQ7aW1nXCIsIFwiPGltZ1wiKTtcbiAgICAgICAgdGhpcy5zdGRvdXQgPSBvdXRwdXQ7XG4gICAgfVxufVxuXG4vLyBsZXQgeCA9IG5ldyBSZXN1bHRzVG9UYWJsZSh0ZXN0U3RyaW5nKTtcbi8vIGNvbnNvbGUubG9nKHguc3Rkb3V0KTtcbi8vIGNvbnNvbGUubG9nKHgudGFibGUpO1xuIiwiaW1wb3J0IHsgQWN0aXZlQ29kZSB9IGZyb20gXCIuL2FjdGl2ZWNvZGUuanNcIjtcbmltcG9ydCBNRDUgZnJvbSBcIi4vbWQ1LmpzXCI7XG5pbXBvcnQgSlVuaXRUZXN0UGFyc2VyIGZyb20gXCIuL2V4dHJhY3RVbml0UmVzdWx0cy5qc1wiO1xuaW1wb3J0IFwiLi4vLi4vY29kZWxlbnMvanMvcHl0dXRvci1lbWJlZC5idW5kbGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZUNvZGUgZXh0ZW5kcyBBY3RpdmVDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHZhciBvcmlnID0gJChvcHRzLm9yaWcpLmZpbmQoXCJ0ZXh0YXJlYVwiKVswXTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuc3RkaW4gPSAkKG9yaWcpLmRhdGEoXCJzdGRpblwiKTtcbiAgICAgICAgdGhpcy5kYXRhZmlsZSA9ICQob3JpZykuZGF0YShcImRhdGFmaWxlXCIpO1xuICAgICAgICB0aGlzLnNvdXJjZWZpbGUgPSAkKG9yaWcpLmRhdGEoXCJzb3VyY2VmaWxlXCIpO1xuICAgICAgICB0aGlzLmNvbXBpbGVhcmdzID0gdW5lc2NhcGVIdG1sKCQob3JpZykuZGF0YShcImNvbXBpbGVhcmdzXCIpKTtcbiAgICAgICAgdGhpcy5saW5rYXJncyA9IHVuZXNjYXBlSHRtbCgkKG9yaWcpLmRhdGEoXCJsaW5rYXJnc1wiKSk7XG4gICAgICAgIHRoaXMucnVuYXJncyA9IHVuZXNjYXBlSHRtbCgkKG9yaWcpLmRhdGEoXCJydW5hcmdzXCIpKTtcbiAgICAgICAgdGhpcy5pbnRlcnByZXRlcmFyZ3MgPSB1bmVzY2FwZUh0bWwoJChvcmlnKS5kYXRhKFwiaW50ZXJwcmV0ZXJhcmdzXCIpKTtcbiAgICAgICAgdGhpcy5BUElfS0VZID0gXCI2NzAzM3BWN2VVVXZxbzA3T0pESVY4VVowNDlhTEVLMVwiO1xuICAgICAgICB0aGlzLlVTRV9BUElfS0VZID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5KT0JFX1NFUlZFUiA9IGVCb29rQ29uZmlnLmpvYmVob3N0IHx8IGVCb29rQ29uZmlnLmhvc3Q7XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSBlQm9va0NvbmZpZy5wcm94eXVyaV9ydW5zIHx8IFwiL3J1bmVzdG9uZS9wcm94eS9qb2JlUnVuXCI7XG4gICAgICAgIHRoaXMuam9iZVB1dEZpbGVzID1cbiAgICAgICAgICAgIGVCb29rQ29uZmlnLnByb3h5dXJpX2ZpbGVzIHx8IFwiL3J1bmVzdG9uZS9wcm94eS9qb2JlUHVzaEZpbGUvXCI7XG4gICAgICAgIHRoaXMuam9iZUNoZWNrRmlsZXMgPVxuICAgICAgICAgICAgZUJvb2tDb25maWcucHJveHl1cmlfZmlsZXMgfHwgXCIvcnVuZXN0b25lL3Byb3h5L2pvYmVDaGVja0ZpbGUvXCI7XG4gICAgICAgIC8vIFRPRE86ICBzaG91bGQgYWRkIGEgcHJvcGVyIHB1dC9jaGVjayBpbiBwYXZlbWVudC50bXBsIGFzIHRoaXMgaXMgbWlzbGVhZGluZyBhbmQgd2lsbCBicmVhayBvbiBydW5lc3RvbmVcbiAgICAgICAgdGhpcy5kaXYyaWQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc3RkaW4pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSW5wdXRFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVFcnJvck91dHB1dCgpO1xuICAgIH1cbiAgICBvdXRwdXRmdW4oYSkge31cbiAgICBjcmVhdGVJbnB1dEVsZW1lbnQoKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgbGFiZWwuZm9yID0gdGhpcy5kaXZpZCArIFwiX3N0ZGluXCI7XG4gICAgICAgICQobGFiZWwpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfaW5wdXRfcHJnXCIpKTtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBpbnB1dC5pZCA9IHRoaXMuZGl2aWQgKyBcIl9zdGRpblwiO1xuICAgICAgICBpbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIGlucHV0LnNpemUgPSBcIjM1XCI7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy5zdGRpbjtcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICB0aGlzLnN0ZGluX2VsID0gaW5wdXQ7XG4gICAgfVxuICAgIGNyZWF0ZUVycm9yT3V0cHV0KCkge31cblxuICAgIC8qICBNYWluIHJ1blByb2cgbWV0aG9kIGZvciBsaXZlY29kZVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcnVuUHJvZyhub1VJLCBsb2dSZXN1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9nUmVzdWx0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5sb2dSZXN1bHRzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IGxvZ1Jlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub1VJICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgbm9VSSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucnVuU2V0dXAoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLnN1Ym1pdFRvSm9iZSgpO1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICQuaTE4bihgU2VydmVyIEVycm9yOiAke3Jlcy5zdGF0dXNUZXh0fWApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZmFpbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJ1blJlc3VsdHMgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSm9iZVJlc3BvbnNlKHJ1blJlc3VsdHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2VydmVyX2NvbW1fZXJyXCIpICsgZS50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGBmYWlsOiAke2V9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJzdWNjZXNzXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGU6XG4gICAgICogSW4gb3JkZXIgdG8gY2hlY2sgZm9yIHN1cHBsZW1lbnRhbCBmaWxlcyBpbiBqYXZhIGFuZCBkZWFsIHdpdGggYXN5bmNocm9uaWNpdHlcbiAgICAgKiBJIHNwbGl0IHRoZSBvcmlnaW5hbCBydW5Qcm9nIGludG8gdHdvIGZ1bmN0aW9uczogcnVuUHJvZyBhbmQgcnVuUHJvZ19jYWxsYmFja1xuICAgICAqL1xuICAgIGFzeW5jIHJ1blNldHVwKCkge1xuICAgICAgICB2YXIgc3RkaW47XG4gICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgIHZhciBzYXZlQ29kZSA9IFwiVHJ1ZVwiO1xuICAgICAgICB2YXIgc2ZpbGVtYXAgPSB7XG4gICAgICAgICAgICBqYXZhOiBcIlwiLFxuICAgICAgICAgICAgY3BwOiBcInRlc3QuY3BwXCIsXG4gICAgICAgICAgICBjOiBcInRlc3QuY1wiLFxuICAgICAgICAgICAgcHl0aG9uMzogXCJ0ZXN0LnB5XCIsXG4gICAgICAgICAgICBweXRob24yOiBcInRlc3QucHlcIixcbiAgICAgICAgICAgIG9jdGF2ZTogXCJvY3RhdGVzdC5tXCIsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzb3VyY2VmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgIHZhciB0ZXN0ZHJpdmVybmFtZSA9IFwiXCI7XG4gICAgICAgIHZhciBmaWxlX2NoZWNrcDtcblxuICAgICAgICAvLyBleHRyYWN0IHRoZSBjbGFzcyBuYW1lcyBzbyBmaWxlcyBjYW4gYmUgbmFtZWQgcHJvcGVybHlcbiAgICAgICAgaWYgKHRoaXMuc3VmZml4ICYmIHRoaXMubGFuZ3VhZ2UgPT0gXCJqYXZhXCIpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzdWZmaXggY29udGFpbnMgdW5pdCB0ZXN0IGNvZGUgYW5kIHNob3VsZCBpbmNsdWRlIGFuZCBpbXBvcnQgb2YganVuaXRcbiAgICAgICAgICAgIC8vIGltcG9ydCBzdGF0aWMgb3JnLmp1bml0LkFzc2VydC4qO1xuICAgICAgICAgICAgLy8gaW1wb3J0IG9yZy5qdW5pdC4qO1xuICAgICAgICAgICAgLy8gaW1wb3J0IGphdmEuaW8uKjtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1ZmZpeC5pbmRleE9mKFwiaW1wb3J0IG9yZy5qdW5pdFwiKSA8MCApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWlzc2luZyBpbXBvcnRzIGluIHVuaXQgdGVzdHM6XG4gICAgICAgICAgICAgICAgICAgICR7dGhpcy5zdWZmaXh9YCk7XG4gICAgICAgICAgICAgICAgLy8gYWxlcnQoXCJUaGUgdW5pdCB0ZXN0cyBmb3IgdGhpcyBwcm9ibGVtIGFyZSBpbmNvbXBsZXRlLCBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VmZml4ID0gYFxuICAgICAgICAgICAgICAgIGltcG9ydCBzdGF0aWMgb3JnLmp1bml0LkFzc2VydC4qO1xuICAgICAgICAgICAgICAgIGltcG9ydCBvcmcuanVuaXQuKjtcbiAgICAgICAgICAgICAgICBpbXBvcnQgamF2YS5pby4qO1xuICAgICAgICAgICAgICAgIGAgKyB0aGlzLnN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjbGFzc01hdGNoID0gbmV3IFJlZ0V4cCgvcHVibGljIGNsYXNzXFxzKyhcXHcrKVtcXHMre10vKTtcbiAgICAgICAgICAgIHNvdXJjZSA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKGZhbHNlKTtcbiAgICAgICAgICAgIGxldCBtID0gc291cmNlLm1hdGNoKGNsYXNzTWF0Y2gpO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VmaWxlbmFtZSA9IG1bMV0gKyBcIi5qYXZhXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgdW5pdCB0ZXN0IGNvZGVcbiAgICAgICAgICAgIG0gPSB0aGlzLnN1ZmZpeC5tYXRjaChjbGFzc01hdGNoKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgdGVzdGRyaXZlcm5hbWUgPSBtWzFdICsgXCIuamF2YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlID0gYXdhaXQgdGhpcy5idWlsZFByb2codHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgaXMgY29udmVydGlibGUgdG8gQmFzZTY0LiBJZiBub3QgdGhlbiBlcnJvciBvdXQgbm93XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBidG9hKHNvdXJjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGFsZXJ0KFxuICAgICAgICAgICAgICAgIFwiRXJyb3I6IEJhZCBDaGFyYWN0ZXJzIGluIHRoZSBhY3RpdmVjb2RlIHdpbmRvdy4gTGlrZWx5IGEgcXVvdGUgY2hhcmFjdGVyIHRoYXQgaGFzIGJlZW4gY29weS9wYXN0ZWQuIPCfmYFcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBhd2FpdCB0aGlzLm1hbmFnZV9zY3J1YmJlcihzYXZlQ29kZSk7XG5cbiAgICAgICAgLy8gYXNzZW1ibGUgcGFyYW1ldGVycyBmb3IgSk9CRVxuICAgICAgICB2YXIgcGFyYW1saXN0ID0gW1xuICAgICAgICAgICAgXCJjb21waWxlYXJnc1wiLFxuICAgICAgICAgICAgXCJsaW5rYXJnc1wiLFxuICAgICAgICAgICAgXCJydW5hcmdzXCIsXG4gICAgICAgICAgICBcImludGVycHJldGVyYXJnc1wiLFxuICAgICAgICAgICAgXCJtZW1vcnlsaW1pdFwiLFxuICAgICAgICBdO1xuICAgICAgICB2YXIgcGFyYW1vYmogPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcGFyYW0gb2YgcGFyYW1saXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpc1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICBwYXJhbW9ialtwYXJhbV0gPSBldmFsKHRoaXNbcGFyYW1dKTsgLy8gbmVlZHMgYSBsaXN0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFuZ3VhZ2UgPT09IFwib2N0YXZlXCIpIHtcbiAgICAgICAgICAgIHBhcmFtb2JqLm1lbW9yeWxpbWl0ID0gMjAwMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RkaW4pIHtcbiAgICAgICAgICAgIHN0ZGluID0gJCh0aGlzLnN0ZGluX2VsKS52YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc291cmNlZmlsZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VmaWxlID0gc2ZpbGVtYXBbdGhpcy5sYW5ndWFnZV07XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMub3V0cHV0KS5odG1sKCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2NvbXBpbGluZ19ydW5uaW5nXCIpKTtcbiAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICAgIHZhciBjb250ZW50LCBiYXNlNjQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGFmaWxlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGlkcyA9IHRoaXMuZGF0YWZpbGUuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSBpZHNbaV0udHJpbSgpO1xuICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGxldCBmaWxlRXh0ZW5zaW9uID0gZmlsZU5hbWUuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSA9PT0gbnVsbCB8fCBmaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJObyBmaWxlIHdpdGggZ2l2ZW4gaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBmaWxlIGlzIGluIGRiXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmZpbGVSZWFkZXIoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmaWxlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXkgYmUgdW5kZWZpbmVkIGF0IHRoaXMgcG9pbnQgaWYgZmlsZSBpcyBhbiBpbWFnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZUV4dGVuc2lvbiA9PT0gXCJqYXJcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdCh0aGlzLnBhcnNlSmF2YUNsYXNzZXMoY29udGVudCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoW1wianBnXCIsIFwicG5nXCIsIFwiZ2lmXCJdLmluZGV4T2YoZmlsZUV4dGVuc2lvbikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUudG9EYXRhVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0ID0gZmlsZS50b0RhdGFVUkwoXCJpbWFnZS9cIiArIGZpbGVFeHRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoYmFzZTY0LmluZGV4T2YoXCIsXCIpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGZpbGUuc3JjLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zcmMuaW5kZXhPZihcIixcIikgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaCh7IG5hbWU6IGZpbGVOYW1lLCBjb250ZW50OiBiYXNlNjQgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gY2xhc3NOYW1lIG9yIHVuIHJlY29nbml6ZWQgY2xhc3NOYW1lIGl0IGlzIHRyZWF0ZWQgYXMgYW4gaW5kaXZpZHVhbCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgYW55IHR5cGUgb2YgZmlsZSwgLnR4dCwgLmphdmEsIC5jc3YsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHsgbmFtZTogZmlsZU5hbWUsIGNvbnRlbnQ6IGNvbnRlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSBydW5uaW5nIHVuaXQgdGVzdHMgd2UgbmVlZCB0byBzdWJzdGl0dXRlIHRoZSB0ZXN0IGRyaXZlciBmb3IgdGhlIHN0dWRlbnRcbiAgICAgICAgLy8gY29kZSBhbmQgc2VuZCB0aGUgc3R1ZGVudCBjb2RlIGFzIGEgZmlsZS4gIFdlJ2xsIGRvIHRoYXQgaGVyZS5cbiAgICAgICAgdGhpcy5qdW5pdERyaXZlckNvZGUgPSBgXG4gICAgICAgIGltcG9ydCBvcmcuanVuaXQucnVubmVyLkpVbml0Q29yZTtcbiAgICAgICAgaW1wb3J0IG9yZy5qdW5pdC5ydW5uZXIuUmVzdWx0O1xuICAgICAgICBpbXBvcnQgb3JnLmp1bml0LnJ1bm5lci5ub3RpZmljYXRpb24uRmFpbHVyZTtcblxuICAgICAgICBwdWJsaWMgY2xhc3MgVGVzdFJ1bm5lciB7XG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgbWFpbihTdHJpbmdbXSBhcmdzKSB7XG4gICAgICAgICAgICAgICAgQ29kZVRlc3RIZWxwZXIucmVzZXRGaW5hbFJlc3VsdHMoKTtcbiAgICAgICAgICAgICAgICBSZXN1bHQgcmVzdWx0ID0gSlVuaXRDb3JlLnJ1bkNsYXNzZXMoJHt0ZXN0ZHJpdmVybmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICBcIi5qYXZhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLmNsYXNzXCJcbiAgICAgICAgICAgICAgICApfSk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLm91dC5wcmludGxuKENvZGVUZXN0SGVscGVyLmdldEZpbmFsUmVzdWx0cygpKTtcblxuICAgICAgICAgICAgICAgIGludCB0b3RhbCA9IHJlc3VsdC5nZXRSdW5Db3VudCgpO1xuICAgICAgICAgICAgICAgIGludCBmYWlscyA9IHJlc3VsdC5nZXRGYWlsdXJlQ291bnQoKTtcbiAgICAgICAgICAgICAgICBpbnQgY29yciAgPSB0b3RhbCAtIGZhaWxzO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihcIllvdSBnb3QgXCIgKyBjb3JyICsgXCIgb3V0IG9mIFwiICsgdG90YWwgKyBcIiBjb3JyZWN0LiBcIiArIFN0cmluZy5mb3JtYXQoXCIlLjJmXCIsICgxMDAuMCAqIGNvcnIgLyB0b3RhbCkpICsgXCIlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIGlmICh0aGlzLnN1ZmZpeCAmJiB0aGlzLmxhbmd1YWdlID09IFwiamF2YVwiKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKHsgbmFtZTogc291cmNlZmlsZW5hbWUsIGNvbnRlbnQ6IHNvdXJjZSB9KTtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goeyBuYW1lOiB0ZXN0ZHJpdmVybmFtZSwgY29udGVudDogdGhpcy5zdWZmaXggfSk7XG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLmp1bml0RHJpdmVyQ29kZTtcbiAgICAgICAgICAgIGlmIChwYXJhbW9iai5jb21waWxlYXJncykge1xuICAgICAgICAgICAgICAgIHBhcmFtb2JqLmNvbXBpbGVhcmdzLnB1c2goc291cmNlZmlsZW5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbW9iai5jb21waWxlYXJncyA9IFtzb3VyY2VmaWxlbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJ1bnNwZWMgPSB7XG4gICAgICAgICAgICBsYW5ndWFnZV9pZDogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgICAgIHNvdXJjZWNvZGU6IHNvdXJjZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtb2JqLFxuICAgICAgICAgICAgc291cmNlZmlsZW5hbWU6IHRoaXMuc291cmNlZmlsZSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RkaW4pIHtcbiAgICAgICAgICAgIHJ1bnNwZWMuaW5wdXQgPSBzdGRpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmpzb25fcnVuc3BlYyA9IEpTT04uc3RyaW5naWZ5KHsgcnVuX3NwZWM6IHJ1bnNwZWMgfSk7XG4gICAgICAgICAgICBmaWxlX2NoZWNrcCA9IFByb21pc2UucmVzb2x2ZShcInJlYWR5XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuc3BlY1tcImZpbGVfbGlzdFwiXSA9IFtdO1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gZmlsZXNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQgPSBmaWxlc1tpXS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRpdjJpZFtmaWxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICBcInJ1bmVzdG9uZVwiICsgTUQ1KGZpbGVOYW1lICsgZmlsZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJ1bnNwZWNbXCJmaWxlX2xpc3RcIl0ucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmRpdjJpZFtmaWxlTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNoZWNrRmlsZShmaWxlc1tpXSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5qc29uX3J1bnNwZWMgPSBKU09OLnN0cmluZ2lmeSh7IHJ1bl9zcGVjOiBydW5zcGVjIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXYyaWQgPSBpbnN0YW5jZS5kaXYyaWQ7XG4gICAgICAgICAgICBmaWxlX2NoZWNrcCA9IFByb21pc2UuYWxsKHByb21pc2VzKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVfY2hlY2twO1xuICAgIH1cblxuICAgIC8qIFN1Ym1pdCB0aGUgYXNzZW1ibGVkIGpvYiB0byB0aGUgSk9CRSBzZXJ2ZXIgYW5kIGF3YWl0IHRoZSByZXN1bHRzLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0VG9Kb2JlKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuanNvbl9ydW5zcGVjO1xuICAgICAgICBsZXQgaG9zdCA9IHRoaXMuSk9CRV9TRVJWRVIgKyB0aGlzLnJlc291cmNlO1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLm91dERpdikuc2hvdyh7IGR1cmF0aW9uOiA3MDAsIHF1ZXVlOiBmYWxzZSB9KTtcbiAgICAgICAgJCh0aGlzLmVyckRpdikucmVtb3ZlKCk7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuXG4gICAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgXCJDb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgXCJYLUFQSS1LRVlcIjogdGhpcy5BUElfS0VZLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChob3N0LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmV0Y2gocmVxdWVzdCk7XG5cbiAgICAgICAgLy8vJChcIiNcIiArIGRpdmlkICsgXCJfZXJyaW5mb1wiKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzSm9iZVJlc3BvbnNlKHJlc3VsdCkge1xuICAgICAgICB2YXIgbG9ncmVzdWx0O1xuICAgICAgICB2YXIgb2RpdiA9IHRoaXMub3V0cHV0O1xuICAgICAgICB0aGlzLnBhcnNlZE91dHB1dCA9IHt9O1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIGlmIChyZXN1bHQub3V0Y29tZSA9PT0gMTUpIHtcbiAgICAgICAgICAgIGxvZ3Jlc3VsdCA9IFwic3VjY2Vzc1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9ncmVzdWx0ID0gcmVzdWx0Lm91dGNvbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJpbmZvID0gbG9ncmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHJlc3VsdC5vdXRjb21lKSB7XG4gICAgICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRPdXRwdXQgPSBuZXcgSlVuaXRUZXN0UGFyc2VyKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3Rkb3V0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAkKG9kaXYpLmh0bWwodGhpcy5wYXJzZWRPdXRwdXQuc3Rkb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VkT3V0cHV0LnBjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZE91dHB1dC5wY3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkT3V0cHV0LnBhc3NlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRPdXRwdXQuZmFpbGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaXRfcmVzdWx0cyA9IGBwZXJjZW50OiR7dGhpcy5wYXJzZWRPdXRwdXQucGN0fTpwYXNzZWQ6JHt0aGlzLnBhcnNlZE91dHB1dC5wYXNzZWR9OmZhaWxlZDoke3RoaXMucGFyc2VkT3V0cHV0LmZhaWxlZH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIGNvbXBpbGVyIGVycm9yXG4gICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3dlcmVfY29tcGlsaW5nX2VyclwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKHJlc3VsdC5jbXBpbmZvKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6IC8vIHJ1biB0aW1lIGVycm9yXG4gICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKHJlc3VsdC5zdGRvdXQucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKHJlc3VsdC5zdGRlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTM6IC8vIHRpbWUgbGltaXRcbiAgICAgICAgICAgICAgICAkKG9kaXYpLmh0bWwocmVzdWx0LnN0ZG91dC5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXhjXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKHJlc3VsdC5zdGRlcnIucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2VydmVyX2VyclwiKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBoYW5kbGUgc2VydmVyIGJ1c3kgYW5kIHRpbWVvdXQgZXJyb3JzIHRvb1xuICAgIH1cblxuICAgIHJlbmRlckZlZWRiYWNrKCkge1xuICAgICAgICBsZXQgcmRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke3RoaXMuZGl2aWR9X3VuaXRfcmVzdWx0c2ApO1xuICAgICAgICBpZiAocmRpdikge1xuICAgICAgICAgICAgcmRpdi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJzZWRPdXRwdXQgJiYgdGhpcy5wYXJzZWRPdXRwdXQudGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0RGl2LmFwcGVuZENoaWxkKHRoaXMucGFyc2VkT3V0cHV0LnRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYCR7dGhpcy5kaXZpZH1fdW5pdF9yZXN1bHRzYCk7XG4gICAgICAgIGlmIChyZGl2KSB7XG4gICAgICAgICAgICByZGl2LmFwcGVuZENoaWxkKHRoaXMucGFyc2VkT3V0cHV0LnBjdFN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRKb2JlRXJyb3JNZXNzYWdlKGVycikge1xuICAgICAgICB2YXIgZXJySGVhZCA9ICQoXCI8aDM+XCIpLmh0bWwoXCJFcnJvclwiKTtcbiAgICAgICAgdmFyIGVDb250YWluZXIgPSB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVyckRpdiA9IGVDb250YWluZXI7XG4gICAgICAgIGVDb250YWluZXIuY2xhc3NOYW1lID0gXCJlcnJvciBhbGVydCBhbGVydC1kYW5nZXJcIjtcbiAgICAgICAgZUNvbnRhaW5lci5pZCA9IHRoaXMuZGl2aWQgKyBcIl9lcnJpbmZvXCI7XG4gICAgICAgIGVDb250YWluZXIuYXBwZW5kQ2hpbGQoZXJySGVhZFswXSk7XG4gICAgICAgIHZhciBlcnJUZXh0ID0gZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpKTtcbiAgICAgICAgZXJyVGV4dC5pbm5lckhUTUwgPSBlcnI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgZmlsZSBpcyBvbiBzZXJ2ZXJcbiAgICAgKiBQbGFjZXMgaXQgb24gc2VydmVyIGlmIGl0IGlzIG5vdCBvbiBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R7bmFtZSwgY29udGVudHN9fSBmaWxlICAgIEZpbGUgdG8gcGxhY2Ugb24gc2VydmVyXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHJlc29sdmUgcHJvbWlzZSByZXNvbHZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHJlamVjdCAgcHJvbWlzZSByZWplY3QgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBjaGVja0ZpbGUoZmlsZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBmaWxlX2lkID0gdGhpcy5kaXYyaWRbZmlsZS5uYW1lXTtcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5qb2JlQ2hlY2tGaWxlcyArIGZpbGVfaWQ7XG4gICAgICAgIHZhciBob3N0ID0gdGhpcy5KT0JFX1NFUlZFUiArIHJlc291cmNlO1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiSEVBRFwiLCBob3N0LCB0cnVlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1BUEktS0VZXCIsIHRoaXMuQVBJX0tFWSk7XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJlcnJvciBzZW5kaW5nIGZpbGVcIiArIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDg6XG4gICAgICAgICAgICAgICAgY2FzZSA0MDQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRmlsZSBub3Qgb24gU2VydmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hEYXRhRmlsZShmaWxlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJCYWQgUmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkZpbGUgYWxyZWFkeSBvbiBTZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgYSBmaWxlIG9uIGEgc2VydmVyXG4gICAgICovXG4gICAgcHVzaERhdGFGaWxlKGZpbGUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgIHZhciBleHRlbnNpb24gPSBmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUuaW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICAgICAgdmFyIGZpbGVfaWQgPSB0aGlzLmRpdjJpZFtmaWxlTmFtZV07XG4gICAgICAgIHZhciBjb250ZW50cyA9IGZpbGUuY29udGVudDtcbiAgICAgICAgLy8gRmlsZSB0eXBlcyBiZWluZyB1cGxvYWRlZCB0aGF0IGNvbWUgaW4gYWxyZWFkeSBpbiBiYXNlNjQgZm9ybWF0XG4gICAgICAgIHZhciBleHRlbnNpb25zID0gW1wiamFyXCIsIFwiemlwXCIsIFwicG5nXCIsIFwianBnXCIsIFwianBlZ1wiXTtcbiAgICAgICAgdmFyIGNvbnRlbnRzYjY0O1xuICAgICAgICBpZiAoZXh0ZW5zaW9ucy5pbmRleE9mKGV4dGVuc2lvbikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZW50c2I2NCA9IGJ0b2EoY29udGVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudHNiNjQgPSBjb250ZW50cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHsgZmlsZV9jb250ZW50czogY29udGVudHNiNjQgfSk7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHRoaXMuam9iZVB1dEZpbGVzICsgZmlsZV9pZDtcbiAgICAgICAgdmFyIGhvc3QgPSB0aGlzLkpPQkVfU0VSVkVSICsgcmVzb3VyY2U7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oXCJQVVRcIiwgaG9zdCwgdHJ1ZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlgtQVBJLUtFWVwiLCB0aGlzLkFQSV9LRVkpO1xuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRm9yYmlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDA6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQmFkIFJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN1Y2Nlc3NmdWxseSBzZW50IGZpbGUgXCIgKyB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZpbGUgXCIgKyBmaWxlTmFtZSArXCIsIFwiICsgZmlsZV9pZCArXCIgcGxhY2VkIG9uIHNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZXJyb3Igc2VuZGluZyBmaWxlXCIgKyB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZChkYXRhKTtcbiAgICB9XG5cbiAgICBhc3luYyBzaG93Q29kZWxlbnMoKSB7XG4gICAgICAgIGxldCBjbE1lc3MgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICBjbE1lc3MgPSBcIkJ1aWxkaW5nIHlvdXIgdmlzdWFsaXphdGlvblwiO1xuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5pbm5lckhUTUwgPSBjbE1lc3M7XG4gICAgICAgICAgICB0aGlzLmNsQnV0dG9uLmlubmVyVGV4dCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2hpZGVfY29kZWxlbnNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuY2xCdXR0b24uaW5uZXJUZXh0ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19pbl9jb2RlbGVuc1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2wgPSB0aGlzLmNvZGVsZW5zLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjbCkge1xuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5yZW1vdmVDaGlsZChjbCk7XG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLmlubmVySFRNTCA9IGNsTWVzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZSA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKGZhbHNlKTtcbiAgICAgICAgaWYgKGNvZGUubWF0Y2goL1N5c3RlbS5leGl0LykpIHtcbiAgICAgICAgICAgIGFsZXJ0KFxuICAgICAgICAgICAgICAgIFwiU29ycnkuLi4gU3lzdGVtLmV4aXQgYnJlYWtzIHRoZSB2aXN1YWxpemVyIHRlbXBvcmFyaWx5IHJlbW92aW5nXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9TeXN0ZW0uZXhpdFxcKFxcZCtcXCk7LywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG15VmFycyA9IHt9O1xuICAgICAgICBteVZhcnMuY29kZSA9IGNvZGU7XG4gICAgICAgIG15VmFycy5sYW5nID0gdGhpcy5sYW5ndWFnZTtcbiAgICAgICAgaWYgKHRoaXMuc3RkaW4pIHtcbiAgICAgICAgICAgIG15VmFycy5zdGRpbiA9ICQodGhpcy5zdGRpbl9lbCkudmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldERpdiA9IHRoaXMuY29kZWxlbnMuaWQ7XG5cbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcIi9ydW5lc3RvbmUvcHJveHkvcHl0dXRvcl90cmFjZVwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobXlWYXJzKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGxldCB2aXMgPSBhZGRWaXN1YWxpemVyVG9QYWdlKGRhdGEsIHRhcmdldERpdiwge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nSW5zdHJ1Y3Rpb246IDAsXG4gICAgICAgICAgICAgICAgZWRpdENvZGVCYXNlVVJMOiBudWxsLFxuICAgICAgICAgICAgICAgIGhpZGVDb2RlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYW5nOiBteVZhcnMubGFuZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbGV0IHRhcmdldERpdkVycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0RGl2KTtcbiAgICAgICAgICAgIHRhcmdldERpdkVycm9yLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgXCJTb3JyeSwgYW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgY3JlYXRpbmcgeW91ciB2aXN1YWxpemF0aW9uLlwiO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHZXQgVHJhY2UgRmFpbGVkIC0tIFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBcImNvZGVsZW5zXCIsXG4gICAgICAgICAgICBhY3Q6IFwidmlld1wiLFxuICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXBlcmF0ZXMgdGV4dCBpbnRvIG11bHRpcGxlIC5qYXZhIGZpbGVzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0IFN0cmluZyB3aXRoIG11bGlwbGUgamF2YSBjbGFzc2VzIG5lZWRlZCB0byBiZSBzZXBlcmF0ZWRcbiAgICAgKiBAcmV0dXJuIHthcnJheSBvZiBvYmplY3RzfSAgLm5hbWUgZ2l2ZXMgdGhlIG5hbWUgb2YgdGhlIGphdmEgZmlsZSB3aXRoIC5qYXZhIGV4dGVuc2lvblxuICAgICAqICAgICAgICAgICAgICAgICAgIC5jb250ZW50IGdpdmVzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZVxuICAgICAqL1xuICAgIHBhcnNlSmF2YUNsYXNzZXModGV4dCkge1xuICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhY2sgPSAwO1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgICAgIHZhciBpbXBvcnRJbmRleCA9IDA7XG4gICAgICAgIHZhciBlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ZXh0LmNoYXJBdChpKSAhPT0gXCJcXG5cIiAmJiBpIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0LmNoYXJBdChpKSA9PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICAgICAgICAgICh0ZXh0LmNoYXJBdChpKSAhPT0gXCIqXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmNoYXJBdChpICsgMSkgIT09IFwiL1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaSArIDEgPCB0ZXh0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0ZXh0LmNoYXJBdChpKSAhPT0gJ1wiJyAmJiBpIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGV4dC5jaGFyQXQoaSkgIT09IFwiJ1wiICYmIGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIHZhciBwQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB3aGlsZSAocENvdW50ID4gMCAmJiBpIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiB0ZXh0LmNoYXJBdChpKSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJBdChpKSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2srKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiBzdGFjayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHZhciB3b3JkcyA9IHRleHRcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZyhlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMsIHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHdvcmRzW3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAod29yZHNbd10gPT09IFwiZXh0ZW5kc1wiIHx8IHdvcmRzW3ddID09PSBcImltcGxlbWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gd29yZHNbdyAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUudHJpbSgpICsgXCIuamF2YVwiO1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGV4dC5zdWJzdHJpbmcoaW1wb3J0SW5kZXgsIGVuZEluZGV4KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGltcG9ydEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgICAgICAgICAgZW5kT2ZMYXN0Q29tbWVudEJlZm9yZUNsYXNzQmVnaW5zID0gZW5kSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5lc2NhcGVIdG1sKHNhZmUpIHtcbiAgICBpZiAoc2FmZSkge1xuICAgICAgICByZXR1cm4gc2FmZVxuICAgICAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgXCI8XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCBcIj5cIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mI3gyNzsvZywgXCInXCIpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqICBNRDUgKE1lc3NhZ2UtRGlnZXN0IEFsZ29yaXRobSlcbiAqICBodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby9cbiAqXG4gKiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1ENShzdHJpbmcpIHtcbiAgICBmdW5jdGlvbiBSb3RhdGVMZWZ0KGxWYWx1ZSwgaVNoaWZ0Qml0cykge1xuICAgICAgICByZXR1cm4gKGxWYWx1ZSA8PCBpU2hpZnRCaXRzKSB8IChsVmFsdWUgPj4+ICgzMiAtIGlTaGlmdEJpdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBZGRVbnNpZ25lZChsWCwgbFkpIHtcbiAgICAgICAgdmFyIGxYNCwgbFk0LCBsWDgsIGxZOCwgbFJlc3VsdDtcbiAgICAgICAgbFg4ID0gbFggJiAweDgwMDAwMDAwO1xuICAgICAgICBsWTggPSBsWSAmIDB4ODAwMDAwMDA7XG4gICAgICAgIGxYNCA9IGxYICYgMHg0MDAwMDAwMDtcbiAgICAgICAgbFk0ID0gbFkgJiAweDQwMDAwMDAwO1xuICAgICAgICBsUmVzdWx0ID0gKGxYICYgMHgzZmZmZmZmZikgKyAobFkgJiAweDNmZmZmZmZmKTtcbiAgICAgICAgaWYgKGxYNCAmIGxZNCkge1xuICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiAweDgwMDAwMDAwIF4gbFg4IF4gbFk4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsWDQgfCBsWTQpIHtcbiAgICAgICAgICAgIGlmIChsUmVzdWx0ICYgMHg0MDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsUmVzdWx0IF4gMHhjMDAwMDAwMCBeIGxYOCBeIGxZODtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiAweDQwMDAwMDAwIF4gbFg4IF4gbFk4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiBsWDggXiBsWTg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGKHgsIHksIHopIHtcbiAgICAgICAgcmV0dXJuICh4ICYgeSkgfCAofnggJiB6KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHKHgsIHksIHopIHtcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIKHgsIHksIHopIHtcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJKHgsIHksIHopIHtcbiAgICAgICAgcmV0dXJuIHkgXiAoeCB8IH56KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCBhYykge1xuICAgICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoRihiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCBhYykge1xuICAgICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoRyhiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCBhYykge1xuICAgICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoSChiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCBhYykge1xuICAgICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoSShiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb252ZXJ0VG9Xb3JkQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgIHZhciBsV29yZENvdW50O1xuICAgICAgICB2YXIgbE1lc3NhZ2VMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICB2YXIgbE51bWJlck9mV29yZHNfdGVtcDEgPSBsTWVzc2FnZUxlbmd0aCArIDg7XG4gICAgICAgIHZhciBsTnVtYmVyT2ZXb3Jkc190ZW1wMiA9XG4gICAgICAgICAgICAobE51bWJlck9mV29yZHNfdGVtcDEgLSAobE51bWJlck9mV29yZHNfdGVtcDEgJSA2NCkpIC8gNjQ7XG4gICAgICAgIHZhciBsTnVtYmVyT2ZXb3JkcyA9IChsTnVtYmVyT2ZXb3Jkc190ZW1wMiArIDEpICogMTY7XG4gICAgICAgIHZhciBsV29yZEFycmF5ID0gQXJyYXkobE51bWJlck9mV29yZHMgLSAxKTtcbiAgICAgICAgdmFyIGxCeXRlUG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgbEJ5dGVDb3VudCA9IDA7XG4gICAgICAgIHdoaWxlIChsQnl0ZUNvdW50IDwgbE1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudCAtIChsQnl0ZUNvdW50ICUgNCkpIC8gNDtcbiAgICAgICAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpICogODtcbiAgICAgICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gPVxuICAgICAgICAgICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfFxuICAgICAgICAgICAgICAgIChzdHJpbmcuY2hhckNvZGVBdChsQnl0ZUNvdW50KSA8PCBsQnl0ZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIGxCeXRlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBsV29yZENvdW50ID0gKGxCeXRlQ291bnQgLSAobEJ5dGVDb3VudCAlIDQpKSAvIDQ7XG4gICAgICAgIGxCeXRlUG9zaXRpb24gPSAobEJ5dGVDb3VudCAlIDQpICogODtcbiAgICAgICAgbFdvcmRBcnJheVtsV29yZENvdW50XSA9XG4gICAgICAgICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdIHwgKDB4ODAgPDwgbEJ5dGVQb3NpdGlvbik7XG4gICAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMgLSAyXSA9IGxNZXNzYWdlTGVuZ3RoIDw8IDM7XG4gICAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMgLSAxXSA9IGxNZXNzYWdlTGVuZ3RoID4+PiAyOTtcbiAgICAgICAgcmV0dXJuIGxXb3JkQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV29yZFRvSGV4KGxWYWx1ZSkge1xuICAgICAgICB2YXIgV29yZFRvSGV4VmFsdWUgPSBcIlwiLFxuICAgICAgICAgICAgV29yZFRvSGV4VmFsdWVfdGVtcCA9IFwiXCIsXG4gICAgICAgICAgICBsQnl0ZSxcbiAgICAgICAgICAgIGxDb3VudDtcbiAgICAgICAgZm9yIChsQ291bnQgPSAwOyBsQ291bnQgPD0gMzsgbENvdW50KyspIHtcbiAgICAgICAgICAgIGxCeXRlID0gKGxWYWx1ZSA+Pj4gKGxDb3VudCAqIDgpKSAmIDI1NTtcbiAgICAgICAgICAgIFdvcmRUb0hleFZhbHVlX3RlbXAgPSBcIjBcIiArIGxCeXRlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIFdvcmRUb0hleFZhbHVlID1cbiAgICAgICAgICAgICAgICBXb3JkVG9IZXhWYWx1ZSArXG4gICAgICAgICAgICAgICAgV29yZFRvSGV4VmFsdWVfdGVtcC5zdWJzdHIoV29yZFRvSGV4VmFsdWVfdGVtcC5sZW5ndGggLSAyLCAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV29yZFRvSGV4VmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVXRmOEVuY29kZShzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKTtcbiAgICAgICAgdmFyIHV0ZnRleHQgPSBcIlwiO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgc3RyaW5nLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuXG4gICAgICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA+IDEyNyAmJiBjIDwgMjA0OCkge1xuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiA2KSB8IDE5Mik7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgNjMpIHwgMTI4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjID4+IDEyKSB8IDIyNCk7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCk7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgNjMpIHwgMTI4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dGZ0ZXh0O1xuICAgIH1cblxuICAgIHZhciB4ID0gQXJyYXkoKTtcbiAgICB2YXIgaywgQUEsIEJCLCBDQywgREQsIGEsIGIsIGMsIGQ7XG4gICAgdmFyIFMxMSA9IDcsXG4gICAgICAgIFMxMiA9IDEyLFxuICAgICAgICBTMTMgPSAxNyxcbiAgICAgICAgUzE0ID0gMjI7XG4gICAgdmFyIFMyMSA9IDUsXG4gICAgICAgIFMyMiA9IDksXG4gICAgICAgIFMyMyA9IDE0LFxuICAgICAgICBTMjQgPSAyMDtcbiAgICB2YXIgUzMxID0gNCxcbiAgICAgICAgUzMyID0gMTEsXG4gICAgICAgIFMzMyA9IDE2LFxuICAgICAgICBTMzQgPSAyMztcbiAgICB2YXIgUzQxID0gNixcbiAgICAgICAgUzQyID0gMTAsXG4gICAgICAgIFM0MyA9IDE1LFxuICAgICAgICBTNDQgPSAyMTtcblxuICAgIHN0cmluZyA9IFV0ZjhFbmNvZGUoc3RyaW5nKTtcblxuICAgIHggPSBDb252ZXJ0VG9Xb3JkQXJyYXkoc3RyaW5nKTtcblxuICAgIGEgPSAweDY3NDUyMzAxO1xuICAgIGIgPSAweGVmY2RhYjg5O1xuICAgIGMgPSAweDk4YmFkY2ZlO1xuICAgIGQgPSAweDEwMzI1NDc2O1xuXG4gICAgZm9yIChrID0gMDsgayA8IHgubGVuZ3RoOyBrICs9IDE2KSB7XG4gICAgICAgIEFBID0gYTtcbiAgICAgICAgQkIgPSBiO1xuICAgICAgICBDQyA9IGM7XG4gICAgICAgIEREID0gZDtcbiAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIHhbayArIDBdLCBTMTEsIDB4ZDc2YWE0NzgpO1xuICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgeFtrICsgMV0sIFMxMiwgMHhlOGM3Yjc1Nik7XG4gICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCB4W2sgKyAyXSwgUzEzLCAweDI0MjA3MGRiKTtcbiAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIHhbayArIDNdLCBTMTQsIDB4YzFiZGNlZWUpO1xuICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgeFtrICsgNF0sIFMxMSwgMHhmNTdjMGZhZik7XG4gICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCB4W2sgKyA1XSwgUzEyLCAweDQ3ODdjNjJhKTtcbiAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIHhbayArIDZdLCBTMTMsIDB4YTgzMDQ2MTMpO1xuICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgeFtrICsgN10sIFMxNCwgMHhmZDQ2OTUwMSk7XG4gICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCB4W2sgKyA4XSwgUzExLCAweDY5ODA5OGQ4KTtcbiAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIHhbayArIDldLCBTMTIsIDB4OGI0NGY3YWYpO1xuICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgeFtrICsgMTBdLCBTMTMsIDB4ZmZmZjViYjEpO1xuICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgeFtrICsgMTFdLCBTMTQsIDB4ODk1Y2Q3YmUpO1xuICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgeFtrICsgMTJdLCBTMTEsIDB4NmI5MDExMjIpO1xuICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgeFtrICsgMTNdLCBTMTIsIDB4ZmQ5ODcxOTMpO1xuICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgeFtrICsgMTRdLCBTMTMsIDB4YTY3OTQzOGUpO1xuICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgeFtrICsgMTVdLCBTMTQsIDB4NDliNDA4MjEpO1xuICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgeFtrICsgMV0sIFMyMSwgMHhmNjFlMjU2Mik7XG4gICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCB4W2sgKyA2XSwgUzIyLCAweGMwNDBiMzQwKTtcbiAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIHhbayArIDExXSwgUzIzLCAweDI2NWU1YTUxKTtcbiAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIHhbayArIDBdLCBTMjQsIDB4ZTliNmM3YWEpO1xuICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgeFtrICsgNV0sIFMyMSwgMHhkNjJmMTA1ZCk7XG4gICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCB4W2sgKyAxMF0sIFMyMiwgMHgyNDQxNDUzKTtcbiAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIHhbayArIDE1XSwgUzIzLCAweGQ4YTFlNjgxKTtcbiAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIHhbayArIDRdLCBTMjQsIDB4ZTdkM2ZiYzgpO1xuICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgeFtrICsgOV0sIFMyMSwgMHgyMWUxY2RlNik7XG4gICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCB4W2sgKyAxNF0sIFMyMiwgMHhjMzM3MDdkNik7XG4gICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCB4W2sgKyAzXSwgUzIzLCAweGY0ZDUwZDg3KTtcbiAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIHhbayArIDhdLCBTMjQsIDB4NDU1YTE0ZWQpO1xuICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgeFtrICsgMTNdLCBTMjEsIDB4YTllM2U5MDUpO1xuICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgeFtrICsgMl0sIFMyMiwgMHhmY2VmYTNmOCk7XG4gICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCB4W2sgKyA3XSwgUzIzLCAweDY3NmYwMmQ5KTtcbiAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIHhbayArIDEyXSwgUzI0LCAweDhkMmE0YzhhKTtcbiAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIHhbayArIDVdLCBTMzEsIDB4ZmZmYTM5NDIpO1xuICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgeFtrICsgOF0sIFMzMiwgMHg4NzcxZjY4MSk7XG4gICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCB4W2sgKyAxMV0sIFMzMywgMHg2ZDlkNjEyMik7XG4gICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCB4W2sgKyAxNF0sIFMzNCwgMHhmZGU1MzgwYyk7XG4gICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCB4W2sgKyAxXSwgUzMxLCAweGE0YmVlYTQ0KTtcbiAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIHhbayArIDRdLCBTMzIsIDB4NGJkZWNmYTkpO1xuICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgeFtrICsgN10sIFMzMywgMHhmNmJiNGI2MCk7XG4gICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCB4W2sgKyAxMF0sIFMzNCwgMHhiZWJmYmM3MCk7XG4gICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCB4W2sgKyAxM10sIFMzMSwgMHgyODliN2VjNik7XG4gICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCB4W2sgKyAwXSwgUzMyLCAweGVhYTEyN2ZhKTtcbiAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIHhbayArIDNdLCBTMzMsIDB4ZDRlZjMwODUpO1xuICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgeFtrICsgNl0sIFMzNCwgMHg0ODgxZDA1KTtcbiAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIHhbayArIDldLCBTMzEsIDB4ZDlkNGQwMzkpO1xuICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgeFtrICsgMTJdLCBTMzIsIDB4ZTZkYjk5ZTUpO1xuICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgeFtrICsgMTVdLCBTMzMsIDB4MWZhMjdjZjgpO1xuICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgeFtrICsgMl0sIFMzNCwgMHhjNGFjNTY2NSk7XG4gICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCB4W2sgKyAwXSwgUzQxLCAweGY0MjkyMjQ0KTtcbiAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIHhbayArIDddLCBTNDIsIDB4NDMyYWZmOTcpO1xuICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgeFtrICsgMTRdLCBTNDMsIDB4YWI5NDIzYTcpO1xuICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgeFtrICsgNV0sIFM0NCwgMHhmYzkzYTAzOSk7XG4gICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCB4W2sgKyAxMl0sIFM0MSwgMHg2NTViNTljMyk7XG4gICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCB4W2sgKyAzXSwgUzQyLCAweDhmMGNjYzkyKTtcbiAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIHhbayArIDEwXSwgUzQzLCAweGZmZWZmNDdkKTtcbiAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIHhbayArIDFdLCBTNDQsIDB4ODU4NDVkZDEpO1xuICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgeFtrICsgOF0sIFM0MSwgMHg2ZmE4N2U0Zik7XG4gICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCB4W2sgKyAxNV0sIFM0MiwgMHhmZTJjZTZlMCk7XG4gICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCB4W2sgKyA2XSwgUzQzLCAweGEzMDE0MzE0KTtcbiAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIHhbayArIDEzXSwgUzQ0LCAweDRlMDgxMWExKTtcbiAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIHhbayArIDRdLCBTNDEsIDB4Zjc1MzdlODIpO1xuICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgeFtrICsgMTFdLCBTNDIsIDB4YmQzYWYyMzUpO1xuICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgeFtrICsgMl0sIFM0MywgMHgyYWQ3ZDJiYik7XG4gICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCB4W2sgKyA5XSwgUzQ0LCAweGViODZkMzkxKTtcbiAgICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFBKTtcbiAgICAgICAgYiA9IEFkZFVuc2lnbmVkKGIsIEJCKTtcbiAgICAgICAgYyA9IEFkZFVuc2lnbmVkKGMsIENDKTtcbiAgICAgICAgZCA9IEFkZFVuc2lnbmVkKGQsIEREKTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcCA9IFdvcmRUb0hleChhKSArIFdvcmRUb0hleChiKSArIFdvcmRUb0hleChjKSArIFdvcmRUb0hleChkKTtcblxuICAgIHJldHVybiB0ZW1wLnRvTG93ZXJDYXNlKCk7XG59XG4iLCJTay5idWlsdGluRmlsZXM9e1wiZmlsZXNcIjp7XCJzcmMvYnVpbHRpbi90aGlzLnB5XCI6XCJzID0gXFxcIlxcXCJcXFwiR3VyIE1yYSBicyBDbGd1YmEsIG9sIEd2eiBDcmdyZWZcXG5cXG5Pcm5oZ3ZzaHkgdmYgb3JnZ3JlIGd1bmEgaHR5bC5cXG5Sa2N5dnB2ZyB2ZiBvcmdncmUgZ3VuYSB2emN5dnB2Zy5cXG5GdnpjeXIgdmYgb3JnZ3JlIGd1bmEgcGJ6Y3lyay5cXG5QYnpjeXJrIHZmIG9yZ2dyZSBndW5hIHBiemN5dnBuZ3JxLlxcblN5bmcgdmYgb3JnZ3JlIGd1bmEgYXJmZ3JxLlxcbkZjbmVmciB2ZiBvcmdncmUgZ3VuYSBxcmFmci5cXG5Fcm5xbm92eXZnbCBwYmhhZ2YuXFxuRmNycHZueSBwbmZyZiBuZXJhJ2cgZmNycHZueSByYWJodHUgZ2Igb2VybnggZ3VyIGVoeXJmLlxcbk55Z3ViaHR1IGNlbnBndnBueXZnbCBvcm5nZiBjaGV2Z2wuXFxuUmVlYmVmIGZ1Ymh5cSBhcmlyZSBjbmZmIGZ2eXJhZ3lsLlxcbkhheXJmZiBya2N5dnB2Z3lsIGZ2eXJhcHJxLlxcblZhIGd1ciBzbnByIGJzIG56b3Z0aHZnbCwgZXJzaGZyIGd1ciBncnpjZ25ndmJhIGdiIHRocmZmLlxcbkd1cmVyIGZ1Ymh5cSBvciBiYXItLSBuYXEgY2Vyc3Jlbm95bCBiYXlsIGJhciAtLWJvaXZiaGYgam5sIGdiIHFiIHZnLlxcbk55Z3ViaHR1IGd1bmcgam5sIHpubCBhYmcgb3IgYm9pdmJoZiBuZyBzdmVmZyBoYXlyZmYgbGJoJ2VyIFFoZ3B1LlxcbkFiaiB2ZiBvcmdncmUgZ3VuYSBhcmlyZS5cXG5OeWd1Ymh0dSBhcmlyZSB2ZiBic2dyYSBvcmdncmUgZ3VuYSAqZXZ0dWcqIGFiai5cXG5WcyBndXIgdnpjeXJ6cmFnbmd2YmEgdmYgdW5lcSBnYiBya2N5bnZhLCB2ZydmIG4gb25xIHZxcm4uXFxuVnMgZ3VyIHZ6Y3lyenJhZ25ndmJhIHZmIHJuZmwgZ2IgcmtjeW52YSwgdmcgem5sIG9yIG4gdGJicSB2cXJuLlxcbkFuenJmY25wcmYgbmVyIGJhciB1YmF4dmF0IHRlcm5nIHZxcm4gLS0geXJnJ2YgcWIgemJlciBicyBndWJmciFcXFwiXFxcIlxcXCJcXG5cXG5kID0ge31cXG5mb3IgYyBpbiAoNjUsIDk3KTpcXG4gICAgZm9yIGkgaW4gcmFuZ2UoMjYpOlxcbiAgICAgICAgZFtjaHIoaStjKV0gPSBjaHIoKGkrMTMpICUgMjYgKyBjKVxcblxcbnByaW50KFxcXCJcXFwiLmpvaW4oW2QuZ2V0KGMsIGMpIGZvciBjIGluIHNdKSlcXG5cIixcInNyYy9saWIvQmFzZUhUVFBTZXJ2ZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiQmFzZUhUVFBTZXJ2ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9CYXN0aW9uLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIkJhc3Rpb25cXFwiKVxcblwiLFwic3JjL2xpYi9DR0lIVFRQU2VydmVyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIkNHSUhUVFBTZXJ2ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9Db25maWdQYXJzZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiQ29uZmlnUGFyc2VyXFxcIilcXG5cIixcInNyYy9saWIvQ29va2llLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIkNvb2tpZVxcXCIpXFxuXCIsXCJzcmMvbGliL0RvY1hNTFJQQ1NlcnZlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJEb2NYTUxSUENTZXJ2ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9IVE1MUGFyc2VyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIkhUTUxQYXJzZXJcXFwiKVxcblwiLFwic3JjL2xpYi9NaW1lV3JpdGVyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIk1pbWVXcml0ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9RdWV1ZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJRdWV1ZVxcXCIpXFxuXCIsXCJzcmMvbGliL1NpbXBsZUhUVFBTZXJ2ZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiU2ltcGxlSFRUUFNlcnZlclxcXCIpXFxuXCIsXCJzcmMvbGliL1NpbXBsZVhNTFJQQ1NlcnZlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJTaW1wbGVYTUxSUENTZXJ2ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9Tb2NrZXRTZXJ2ZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiU29ja2V0U2VydmVyXFxcIilcXG5cIixcInNyYy9saWIvU3RyaW5nSU8ucHlcIjpcInJcXFwiXFxcIlxcXCJGaWxlLWxpa2Ugb2JqZWN0cyB0aGF0IHJlYWQgZnJvbSBvciB3cml0ZSB0byBhIHN0cmluZyBidWZmZXIuXFxuXFxuVGhpcyBpbXBsZW1lbnRzIChuZWFybHkpIGFsbCBzdGRpbyBtZXRob2RzLlxcblxcbmYgPSBTdHJpbmdJTygpICAgICAgIyByZWFkeSBmb3Igd3JpdGluZ1xcbmYgPSBTdHJpbmdJTyhidWYpICAgIyByZWFkeSBmb3IgcmVhZGluZ1xcbmYuY2xvc2UoKSAgICAgICAgICAgIyBleHBsaWNpdGx5IHJlbGVhc2UgcmVzb3VyY2VzIGhlbGRcXG5mbGFnID0gZi5pc2F0dHkoKSAgICMgYWx3YXlzIGZhbHNlXFxucG9zID0gZi50ZWxsKCkgICAgICAjIGdldCBjdXJyZW50IHBvc2l0aW9uXFxuZi5zZWVrKHBvcykgICAgICAgICAjIHNldCBjdXJyZW50IHBvc2l0aW9uXFxuZi5zZWVrKHBvcywgbW9kZSkgICAjIG1vZGUgMDogYWJzb2x1dGU7IDE6IHJlbGF0aXZlOyAyOiByZWxhdGl2ZSB0byBFT0ZcXG5idWYgPSBmLnJlYWQoKSAgICAgICMgcmVhZCB1bnRpbCBFT0ZcXG5idWYgPSBmLnJlYWQobikgICAgICMgcmVhZCB1cCB0byBuIGJ5dGVzXFxuYnVmID0gZi5yZWFkbGluZSgpICAjIHJlYWQgdW50aWwgZW5kIG9mIGxpbmUgKCdcXFxcbicpIG9yIEVPRlxcbmxpc3QgPSBmLnJlYWRsaW5lcygpIyBsaXN0IG9mIGYucmVhZGxpbmUoKSByZXN1bHRzIHVudGlsIEVPRlxcbmYudHJ1bmNhdGUoW3NpemVdKSAgIyB0cnVuY2F0ZSBmaWxlIGF0IHRvIGF0IG1vc3Qgc2l6ZSAoZGVmYXVsdDogY3VycmVudCBwb3MpXFxuZi53cml0ZShidWYpICAgICAgICAjIHdyaXRlIGF0IGN1cnJlbnQgcG9zaXRpb25cXG5mLndyaXRlbGluZXMobGlzdCkgICMgZm9yIGxpbmUgaW4gbGlzdDogZi53cml0ZShsaW5lKVxcbmYuZ2V0dmFsdWUoKSAgICAgICAgIyByZXR1cm4gd2hvbGUgZmlsZSdzIGNvbnRlbnRzIGFzIGEgc3RyaW5nXFxuXFxuTm90ZXM6XFxuLSBVc2luZyBhIHJlYWwgZmlsZSBpcyBvZnRlbiBmYXN0ZXIgKGJ1dCBsZXNzIGNvbnZlbmllbnQpLlxcbi0gVGhlcmUncyBhbHNvIGEgbXVjaCBmYXN0ZXIgaW1wbGVtZW50YXRpb24gaW4gQywgY2FsbGVkIGNTdHJpbmdJTywgYnV0XFxuICBpdCdzIG5vdCBzdWJjbGFzc2FibGUuXFxuLSBmaWxlbm8oKSBpcyBsZWZ0IHVuaW1wbGVtZW50ZWQgc28gdGhhdCBjb2RlIHdoaWNoIHVzZXMgaXQgdHJpZ2dlcnNcXG4gIGFuIGV4Y2VwdGlvbiBlYXJseS5cXG4tIFNlZWtpbmcgZmFyIGJleW9uZCBFT0YgYW5kIHRoZW4gd3JpdGluZyB3aWxsIGluc2VydCByZWFsIG51bGxcXG4gIGJ5dGVzIHRoYXQgb2NjdXB5IHNwYWNlIGluIHRoZSBidWZmZXIuXFxuLSBUaGVyZSdzIGEgc2ltcGxlIHRlc3Qgc2V0IChzZWUgZW5kIG9mIHRoaXMgZmlsZSkuXFxuXFxcIlxcXCJcXFwiXFxuXFxuX19hbGxfXyA9IFtcXFwiU3RyaW5nSU9cXFwiXVxcblxcbmRlZiBfY29tcGxhaW5faWZjbG9zZWQoY2xvc2VkKTpcXG4gICAgaWYgY2xvc2VkOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiSS9PIG9wZXJhdGlvbiBvbiBjbG9zZWQgZmlsZVxcXCIpXFxuXFxuY2xhc3MgU3RyaW5nSU86XFxuICAgIFxcXCJcXFwiXFxcImNsYXNzIFN0cmluZ0lPKFtidWZmZXJdKVxcblxcbiAgICBXaGVuIGEgU3RyaW5nSU8gb2JqZWN0IGlzIGNyZWF0ZWQsIGl0IGNhbiBiZSBpbml0aWFsaXplZCB0byBhbiBleGlzdGluZ1xcbiAgICBzdHJpbmcgYnkgcGFzc2luZyB0aGUgc3RyaW5nIHRvIHRoZSBjb25zdHJ1Y3Rvci4gSWYgbm8gc3RyaW5nIGlzIGdpdmVuLFxcbiAgICB0aGUgU3RyaW5nSU8gd2lsbCBzdGFydCBlbXB0eS5cXG5cXG4gICAgVGhlIFN0cmluZ0lPIG9iamVjdCBjYW4gYWNjZXB0IGVpdGhlciBVbmljb2RlIG9yIDgtYml0IHN0cmluZ3MsIGJ1dFxcbiAgICBtaXhpbmcgdGhlIHR3byBtYXkgdGFrZSBzb21lIGNhcmUuIElmIGJvdGggYXJlIHVzZWQsIDgtYml0IHN0cmluZ3MgdGhhdFxcbiAgICBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQgYXMgNy1iaXQgQVNDSUkgKHRoYXQgdXNlIHRoZSA4dGggYml0KSB3aWxsIGNhdXNlXFxuICAgIGEgVW5pY29kZUVycm9yIHRvIGJlIHJhaXNlZCB3aGVuIGdldHZhbHVlKCkgaXMgY2FsbGVkLlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGJ1ZiA9ICcnKTpcXG4gICAgICAgICMgRm9yY2Ugc2VsZi5idWYgdG8gYmUgYSBzdHJpbmcgb3IgdW5pY29kZVxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoYnVmLCBzdHIpOlxcbiAgICAgICAgICAgIGJ1ZiA9IHN0cihidWYpXFxuICAgICAgICBzZWxmLmJ1ZiA9IGJ1ZlxcbiAgICAgICAgc2VsZi5sZW4gPSBsZW4oYnVmKVxcbiAgICAgICAgc2VsZi5idWZsaXN0ID0gW11cXG4gICAgICAgIHNlbGYucG9zID0gMFxcbiAgICAgICAgc2VsZi5jbG9zZWQgPSBGYWxzZVxcbiAgICAgICAgc2VsZi5zb2Z0c3BhY2UgPSAwXFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuICAgIGRlZiBuZXh0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQSBmaWxlIG9iamVjdCBpcyBpdHMgb3duIGl0ZXJhdG9yLCBmb3IgZXhhbXBsZSBpdGVyKGYpIHJldHVybnMgZlxcbiAgICAgICAgKHVubGVzcyBmIGlzIGNsb3NlZCkuIFdoZW4gYSBmaWxlIGlzIHVzZWQgYXMgYW4gaXRlcmF0b3IsIHR5cGljYWxseVxcbiAgICAgICAgaW4gYSBmb3IgbG9vcCAoZm9yIGV4YW1wbGUsIGZvciBsaW5lIGluIGY6IHByaW50IGxpbmUpLCB0aGUgbmV4dCgpXFxuICAgICAgICBtZXRob2QgaXMgY2FsbGVkIHJlcGVhdGVkbHkuIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgaW5wdXQgbGluZSxcXG4gICAgICAgIG9yIHJhaXNlcyBTdG9wSXRlcmF0aW9uIHdoZW4gRU9GIGlzIGhpdC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgciA9IHNlbGYucmVhZGxpbmUoKVxcbiAgICAgICAgaWYgbm90IHI6XFxuICAgICAgICAgICAgcmFpc2UgU3RvcEl0ZXJhdGlvblxcbiAgICAgICAgcmV0dXJuIHJcXG5cXG4gICAgZGVmIGNsb3NlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRnJlZSB0aGUgbWVtb3J5IGJ1ZmZlci5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgbm90IHNlbGYuY2xvc2VkOlxcbiAgICAgICAgICAgIHNlbGYuY2xvc2VkID0gVHJ1ZVxcbiAgICAgICAgICAgIHNlbGYuYnVmID0gTm9uZVxcbiAgICAgICAgICAgIHNlbGYucG9zID0gTm9uZVxcblxcbiAgICBkZWYgaXNhdHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJucyBGYWxzZSBiZWNhdXNlIFN0cmluZ0lPIG9iamVjdHMgYXJlIG5vdCBjb25uZWN0ZWQgdG8gYVxcbiAgICAgICAgdHR5LWxpa2UgZGV2aWNlLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG4gICAgZGVmIHNlZWsoc2VsZiwgcG9zLCBtb2RlID0gMCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgdGhlIGZpbGUncyBjdXJyZW50IHBvc2l0aW9uLlxcblxcbiAgICAgICAgVGhlIG1vZGUgYXJndW1lbnQgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDAgKGFic29sdXRlIGZpbGVcXG4gICAgICAgIHBvc2l0aW9uaW5nKTsgb3RoZXIgdmFsdWVzIGFyZSAxIChzZWVrIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50XFxuICAgICAgICBwb3NpdGlvbikgYW5kIDIgKHNlZWsgcmVsYXRpdmUgdG8gdGhlIGZpbGUncyBlbmQpLlxcblxcbiAgICAgICAgVGhlcmUgaXMgbm8gcmV0dXJuIHZhbHVlLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICBpZiBzZWxmLmJ1Zmxpc3Q6XFxuICAgICAgICAgICAgc2VsZi5idWYgKz0gJycuam9pbihzZWxmLmJ1Zmxpc3QpXFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0ID0gW11cXG4gICAgICAgIGlmIG1vZGUgPT0gMTpcXG4gICAgICAgICAgICBwb3MgKz0gc2VsZi5wb3NcXG4gICAgICAgIGVsaWYgbW9kZSA9PSAyOlxcbiAgICAgICAgICAgIHBvcyArPSBzZWxmLmxlblxcbiAgICAgICAgc2VsZi5wb3MgPSBtYXgoMCwgcG9zKVxcblxcbiAgICBkZWYgdGVsbChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgZmlsZSdzIGN1cnJlbnQgcG9zaXRpb24uXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICByZXR1cm4gc2VsZi5wb3NcXG5cXG4gICAgZGVmIHJlYWQoc2VsZiwgbiA9IC0xKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlYWQgYXQgbW9zdCBzaXplIGJ5dGVzIGZyb20gdGhlIGZpbGVcXG4gICAgICAgIChsZXNzIGlmIHRoZSByZWFkIGhpdHMgRU9GIGJlZm9yZSBvYnRhaW5pbmcgc2l6ZSBieXRlcykuXFxuXFxuICAgICAgICBJZiB0aGUgc2l6ZSBhcmd1bWVudCBpcyBuZWdhdGl2ZSBvciBvbWl0dGVkLCByZWFkIGFsbCBkYXRhIHVudGlsIEVPRlxcbiAgICAgICAgaXMgcmVhY2hlZC4gVGhlIGJ5dGVzIGFyZSByZXR1cm5lZCBhcyBhIHN0cmluZyBvYmplY3QuIEFuIGVtcHR5XFxuICAgICAgICBzdHJpbmcgaXMgcmV0dXJuZWQgd2hlbiBFT0YgaXMgZW5jb3VudGVyZWQgaW1tZWRpYXRlbHkuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIGlmIHNlbGYuYnVmbGlzdDpcXG4gICAgICAgICAgICBzZWxmLmJ1ZiArPSAnJy5qb2luKHNlbGYuYnVmbGlzdClcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QgPSBbXVxcbiAgICAgICAgaWYgbiBpcyBOb25lIG9yIG4gPCAwOlxcbiAgICAgICAgICAgIG5ld3BvcyA9IHNlbGYubGVuXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIG5ld3BvcyA9IG1pbihzZWxmLnBvcytuLCBzZWxmLmxlbilcXG4gICAgICAgIHIgPSBzZWxmLmJ1ZltzZWxmLnBvczpuZXdwb3NdXFxuICAgICAgICBzZWxmLnBvcyA9IG5ld3Bvc1xcbiAgICAgICAgcmV0dXJuIHJcXG5cXG4gICAgZGVmIHJlYWRsaW5lKHNlbGYsIGxlbmd0aD1Ob25lKTpcXG4gICAgICAgIHJcXFwiXFxcIlxcXCJSZWFkIG9uZSBlbnRpcmUgbGluZSBmcm9tIHRoZSBmaWxlLlxcblxcbiAgICAgICAgQSB0cmFpbGluZyBuZXdsaW5lIGNoYXJhY3RlciBpcyBrZXB0IGluIHRoZSBzdHJpbmcgKGJ1dCBtYXkgYmUgYWJzZW50XFxuICAgICAgICB3aGVuIGEgZmlsZSBlbmRzIHdpdGggYW4gaW5jb21wbGV0ZSBsaW5lKS4gSWYgdGhlIHNpemUgYXJndW1lbnQgaXNcXG4gICAgICAgIHByZXNlbnQgYW5kIG5vbi1uZWdhdGl2ZSwgaXQgaXMgYSBtYXhpbXVtIGJ5dGUgY291bnQgKGluY2x1ZGluZyB0aGVcXG4gICAgICAgIHRyYWlsaW5nIG5ld2xpbmUpIGFuZCBhbiBpbmNvbXBsZXRlIGxpbmUgbWF5IGJlIHJldHVybmVkLlxcblxcbiAgICAgICAgQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIG9ubHkgd2hlbiBFT0YgaXMgZW5jb3VudGVyZWQgaW1tZWRpYXRlbHkuXFxuXFxuICAgICAgICBOb3RlOiBVbmxpa2Ugc3RkaW8ncyBmZ2V0cygpLCB0aGUgcmV0dXJuZWQgc3RyaW5nIGNvbnRhaW5zIG51bGxcXG4gICAgICAgIGNoYXJhY3RlcnMgKCdcXFxcMCcpIGlmIHRoZXkgb2NjdXJyZWQgaW4gdGhlIGlucHV0LlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICBpZiBzZWxmLmJ1Zmxpc3Q6XFxuICAgICAgICAgICAgc2VsZi5idWYgKz0gJycuam9pbihzZWxmLmJ1Zmxpc3QpXFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0ID0gW11cXG4gICAgICAgIGkgPSBzZWxmLmJ1Zi5maW5kKCdcXFxcbicsIHNlbGYucG9zKVxcbiAgICAgICAgaWYgaSA8IDA6XFxuICAgICAgICAgICAgbmV3cG9zID0gc2VsZi5sZW5cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbmV3cG9zID0gaSsxXFxuICAgICAgICBpZiBsZW5ndGggaXMgbm90IE5vbmUgYW5kIGxlbmd0aCA+PSAwOlxcbiAgICAgICAgICAgIGlmIHNlbGYucG9zICsgbGVuZ3RoIDwgbmV3cG9zOlxcbiAgICAgICAgICAgICAgICBuZXdwb3MgPSBzZWxmLnBvcyArIGxlbmd0aFxcbiAgICAgICAgciA9IHNlbGYuYnVmW3NlbGYucG9zOm5ld3Bvc11cXG4gICAgICAgIHNlbGYucG9zID0gbmV3cG9zXFxuICAgICAgICByZXR1cm4gclxcblxcbiAgICBkZWYgcmVhZGxpbmVzKHNlbGYsIHNpemVoaW50ID0gMCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZWFkIHVudGlsIEVPRiB1c2luZyByZWFkbGluZSgpIGFuZCByZXR1cm4gYSBsaXN0IGNvbnRhaW5pbmcgdGhlXFxuICAgICAgICBsaW5lcyB0aHVzIHJlYWQuXFxuXFxuICAgICAgICBJZiB0aGUgb3B0aW9uYWwgc2l6ZWhpbnQgYXJndW1lbnQgaXMgcHJlc2VudCwgaW5zdGVhZCBvZiByZWFkaW5nIHVwXFxuICAgICAgICB0byBFT0YsIHdob2xlIGxpbmVzIHRvdGFsbGluZyBhcHByb3hpbWF0ZWx5IHNpemVoaW50IGJ5dGVzIChvciBtb3JlXFxuICAgICAgICB0byBhY2NvbW1vZGF0ZSBhIGZpbmFsIHdob2xlIGxpbmUpLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICB0b3RhbCA9IDBcXG4gICAgICAgIGxpbmVzID0gW11cXG4gICAgICAgIGxpbmUgPSBzZWxmLnJlYWRsaW5lKClcXG4gICAgICAgIHdoaWxlIGxpbmU6XFxuICAgICAgICAgICAgbGluZXMuYXBwZW5kKGxpbmUpXFxuICAgICAgICAgICAgdG90YWwgKz0gbGVuKGxpbmUpXFxuICAgICAgICAgICAgaWYgMCA8IHNpemVoaW50IDw9IHRvdGFsOlxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGxpbmUgPSBzZWxmLnJlYWRsaW5lKClcXG4gICAgICAgIHJldHVybiBsaW5lc1xcblxcbiAgICBkZWYgdHJ1bmNhdGUoc2VsZiwgc2l6ZT1Ob25lKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlRydW5jYXRlIHRoZSBmaWxlJ3Mgc2l6ZS5cXG5cXG4gICAgICAgIElmIHRoZSBvcHRpb25hbCBzaXplIGFyZ3VtZW50IGlzIHByZXNlbnQsIHRoZSBmaWxlIGlzIHRydW5jYXRlZCB0b1xcbiAgICAgICAgKGF0IG1vc3QpIHRoYXQgc2l6ZS4gVGhlIHNpemUgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXFxuICAgICAgICBUaGUgY3VycmVudCBmaWxlIHBvc2l0aW9uIGlzIG5vdCBjaGFuZ2VkIHVubGVzcyB0aGUgcG9zaXRpb25cXG4gICAgICAgIGlzIGJleW9uZCB0aGUgbmV3IGZpbGUgc2l6ZS5cXG5cXG4gICAgICAgIElmIHRoZSBzcGVjaWZpZWQgc2l6ZSBleGNlZWRzIHRoZSBmaWxlJ3MgY3VycmVudCBzaXplLCB0aGVcXG4gICAgICAgIGZpbGUgcmVtYWlucyB1bmNoYW5nZWQuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIGlmIHNpemUgaXMgTm9uZTpcXG4gICAgICAgICAgICBzaXplID0gc2VsZi5wb3NcXG4gICAgICAgIGVsaWYgc2l6ZSA8IDA6XFxuICAgICAgICAgICAgcmFpc2UgSU9FcnJvcigyMiwgXFxcIk5lZ2F0aXZlIHNpemUgbm90IGFsbG93ZWRcXFwiKVxcbiAgICAgICAgZWxpZiBzaXplIDwgc2VsZi5wb3M6XFxuICAgICAgICAgICAgc2VsZi5wb3MgPSBzaXplXFxuICAgICAgICBzZWxmLmJ1ZiA9IHNlbGYuZ2V0dmFsdWUoKVs6c2l6ZV1cXG4gICAgICAgIHNlbGYubGVuID0gc2l6ZVxcblxcbiAgICBkZWYgd3JpdGUoc2VsZiwgcyk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJXcml0ZSBhIHN0cmluZyB0byB0aGUgZmlsZS5cXG5cXG4gICAgICAgIFRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgaWYgbm90IHM6IHJldHVyblxcbiAgICAgICAgIyBGb3JjZSBzIHRvIGJlIGEgc3RyaW5nIG9yIHVuaWNvZGVcXG4gICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHMsIHN0cik6XFxuICAgICAgICAgICAgcyA9IHN0cihzKVxcbiAgICAgICAgc3BvcyA9IHNlbGYucG9zXFxuICAgICAgICBzbGVuID0gc2VsZi5sZW5cXG4gICAgICAgIGlmIHNwb3MgPT0gc2xlbjpcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QuYXBwZW5kKHMpXFxuICAgICAgICAgICAgc2VsZi5sZW4gPSBzZWxmLnBvcyA9IHNwb3MgKyBsZW4ocylcXG4gICAgICAgICAgICByZXR1cm5cXG4gICAgICAgIGlmIHNwb3MgPiBzbGVuOlxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdC5hcHBlbmQoJ1xcXFwwJyooc3BvcyAtIHNsZW4pKVxcbiAgICAgICAgICAgIHNsZW4gPSBzcG9zXFxuICAgICAgICBuZXdwb3MgPSBzcG9zICsgbGVuKHMpXFxuICAgICAgICBpZiBzcG9zIDwgc2xlbjpcXG4gICAgICAgICAgICBpZiBzZWxmLmJ1Zmxpc3Q6XFxuICAgICAgICAgICAgICAgIHNlbGYuYnVmICs9ICcnLmpvaW4oc2VsZi5idWZsaXN0KVxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdCA9IFtzZWxmLmJ1Zls6c3Bvc10sIHMsIHNlbGYuYnVmW25ld3BvczpdXVxcbiAgICAgICAgICAgIHNlbGYuYnVmID0gJydcXG4gICAgICAgICAgICBpZiBuZXdwb3MgPiBzbGVuOlxcbiAgICAgICAgICAgICAgICBzbGVuID0gbmV3cG9zXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdC5hcHBlbmQocylcXG4gICAgICAgICAgICBzbGVuID0gbmV3cG9zXFxuICAgICAgICBzZWxmLmxlbiA9IHNsZW5cXG4gICAgICAgIHNlbGYucG9zID0gbmV3cG9zXFxuXFxuICAgIGRlZiB3cml0ZWxpbmVzKHNlbGYsIGl0ZXJhYmxlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIldyaXRlIGEgc2VxdWVuY2Ugb2Ygc3RyaW5ncyB0byB0aGUgZmlsZS4gVGhlIHNlcXVlbmNlIGNhbiBiZSBhbnlcXG4gICAgICAgIGl0ZXJhYmxlIG9iamVjdCBwcm9kdWNpbmcgc3RyaW5ncywgdHlwaWNhbGx5IGEgbGlzdCBvZiBzdHJpbmdzLiBUaGVyZVxcbiAgICAgICAgaXMgbm8gcmV0dXJuIHZhbHVlLlxcblxcbiAgICAgICAgKFRoZSBuYW1lIGlzIGludGVuZGVkIHRvIG1hdGNoIHJlYWRsaW5lcygpOyB3cml0ZWxpbmVzKCkgZG9lcyBub3QgYWRkXFxuICAgICAgICBsaW5lIHNlcGFyYXRvcnMuKVxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICB3cml0ZSA9IHNlbGYud3JpdGVcXG4gICAgICAgIGZvciBsaW5lIGluIGl0ZXJhYmxlOlxcbiAgICAgICAgICAgIHdyaXRlKGxpbmUpXFxuXFxuICAgIGRlZiBmbHVzaChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZsdXNoIHRoZSBpbnRlcm5hbCBidWZmZXJcXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcblxcbiAgICBkZWYgZ2V0dmFsdWUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIFJldHJpZXZlIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIFxcXCJmaWxlXFxcIiBhdCBhbnkgdGltZSBiZWZvcmVcXG4gICAgICAgIHRoZSBTdHJpbmdJTyBvYmplY3QncyBjbG9zZSgpIG1ldGhvZCBpcyBjYWxsZWQuXFxuXFxuICAgICAgICBUaGUgU3RyaW5nSU8gb2JqZWN0IGNhbiBhY2NlcHQgZWl0aGVyIFVuaWNvZGUgb3IgOC1iaXQgc3RyaW5ncyxcXG4gICAgICAgIGJ1dCBtaXhpbmcgdGhlIHR3byBtYXkgdGFrZSBzb21lIGNhcmUuIElmIGJvdGggYXJlIHVzZWQsIDgtYml0XFxuICAgICAgICBzdHJpbmdzIHRoYXQgY2Fubm90IGJlIGludGVycHJldGVkIGFzIDctYml0IEFTQ0lJICh0aGF0IHVzZSB0aGVcXG4gICAgICAgIDh0aCBiaXQpIHdpbGwgY2F1c2UgYSBVbmljb2RlRXJyb3IgdG8gYmUgcmFpc2VkIHdoZW4gZ2V0dmFsdWUoKVxcbiAgICAgICAgaXMgY2FsbGVkLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICBpZiBzZWxmLmJ1Zmxpc3Q6XFxuICAgICAgICAgICAgc2VsZi5idWYgKz0gJycuam9pbihzZWxmLmJ1Zmxpc3QpXFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0ID0gW11cXG4gICAgICAgIHJldHVybiBzZWxmLmJ1ZlxcblwiLFwic3JjL2xpYi9Vc2VyRGljdC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJVc2VyRGljdFxcXCIpXFxuXCIsXCJzcmMvbGliL1VzZXJMaXN0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIlVzZXJMaXN0XFxcIilcXG5cIixcInNyYy9saWIvVXNlclN0cmluZy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJVc2VyU3RyaW5nXFxcIilcXG5cIixcInNyYy9saWIvX0xXUENvb2tpZUphci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJfTFdQQ29va2llSmFyXFxcIilcXG5cIixcInNyYy9saWIvX01vemlsbGFDb29raWVKYXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiX01vemlsbGFDb29raWVKYXJcXFwiKVxcblwiLFwic3JjL2xpYi9fX2Z1dHVyZV9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7X3NrX2ZhaWwuXyhcXFwiX19mdXR1cmVfX1xcXCIpXFxuXCIsXCJzcmMvbGliL19fcGhlbGxvX18uZm9vLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIl9fcGhlbGxvX18uZm9vXFxcIilcXG5cIixcInNyYy9saWIvX2FiY29sbC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJfYWJjb2xsXFxcIilcXG5cIixcInNyYy9saWIvX3NrX2ZhaWwucHlcIjpcImNsYXNzIE5vdEltcGxlbWVudGVkSW1wb3J0RXJyb3IoSW1wb3J0RXJyb3IsIE5vdEltcGxlbWVudGVkRXJyb3IpOiBwYXNzXFxuXFxuZGVmIF8obmFtZSk6XFxuICAgIG1zZyA9IFxcXCJ7fSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIuZm9ybWF0KG5hbWUpXFxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkSW1wb3J0RXJyb3IobXNnLCBuYW1lPW5hbWUpXFxuXCIsXCJzcmMvbGliL190aHJlYWRpbmdfbG9jYWwucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiX3RocmVhZGluZ19sb2NhbFxcXCIpXFxuXCIsXCJzcmMvbGliL2FiYy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJhYmNcXFwiKVxcblwiLFwic3JjL2xpYi9haWZjLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImFpZmNcXFwiKVxcblwiLFwic3JjL2xpYi9hbHRhaXIvX19pbml0X18ucHlcIjpcImltcG9ydCByYW5kb21cXG5cXG50cnk6XFxuICAgIGZyb20gdmVnYV9jYWxsZXIgaW1wb3J0IHJlbmRlcl9ncmFwaFxcbmV4Y2VwdDpcXG4gICAgcHJpbnQoXFxcIk1vY2sgcmVuZGVyXFxcIilcXG5cXG4gICAgZGVmIHJlbmRlcl9ncmFwaChqcyk6XFxuICAgICAgICBwcmludChqcylcXG5cXG5cXG5jbGFzcyBDaGFydDpcXG4gICAgIyBUT0RPIGFsbG93IGRhdGEgdG8gYmUgc3BlY2lmaWVkIGFzIGEgVVJMIHRvIGEgQ1NWIG9yIERCIG9yIGpzb25cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGRhdGEsIHRpdGxlPU5vbmUpOlxcbiAgICAgICAgc2VsZi50aXRsZSA9IHRpdGxlXFxuICAgICAgICBzZWxmLmRhdGFfaWQgPSByYW5kb20ucmFuZHJhbmdlKDEwMDAwMDAsIDUwMDAwMDApXFxuICAgICAgICBzZWxmLmRzbmFtZSA9IFxcXCJkYXRhLXt9XFxcIi5mb3JtYXQoc2VsZi5kYXRhX2lkKVxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShkYXRhLCBkaWN0KTpcXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSBEYXRhKCoqZGF0YSlcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5kYXRhID0gZGF0YVxcblxcbiAgICAgICAgc2VsZi5qc29uID0ge31cXG4gICAgICAgIHNlbGYuanNvbltcXFwiJHNjaGVtYVxcXCJdID0gXFxcImh0dHBzOi8vdmVnYS5naXRodWIuaW8vc2NoZW1hL3ZlZ2EtbGl0ZS92Mi41Lmpzb25cXFwiXFxuICAgICAgICBzZWxmLmpzb25bXFxcImRhdGFcXFwiXSA9IHt9XFxuICAgICAgICBpZiBzZWxmLnRpdGxlOlxcbiAgICAgICAgICAgIHNlbGYuanNvbltcXFwidGl0bGVcXFwiXSA9IHNlbGYudGl0bGVcXG5cXG4gICAgICAgIHNlbGYuanNvbltcXFwiZGF0YVxcXCJdID0ge1xcXCJ2YWx1ZXNcXFwiOiBzZWxmLmRhdGEudmFsc31cXG4gICAgICAgIHNlbGYuaXNfY29tcG9zaXRlID0gRmFsc2VcXG5cXG4gICAgIyBtYXJrIGNhbiBiZSBhIHNpbXBsZSBzdHJpbmcgb3IgYSBkaWN0aW9uYXJ5XFxuICAgICMgXFxcIm1hcmtcXFwiOiB7XFxcImNvbG9yXFxcIjogXFxcImdyZWVuXFxcIiwgXFxcIm9wYWNpdHlcXFwiOiAwLjIsIFxcXCJ0eXBlXFxcIjogXFxcInJlY3RcXFwifVxcblxcbiAgICBkZWYgbWFya19qc29uKHNlbGYsIG1hcmtfdHlwZSwgKiprd2FyZ3MpOlxcbiAgICAgICAgaWYga3dhcmdzOlxcbiAgICAgICAgICAgIHNlbGYuanNvbltcXFwibWFya1xcXCJdID0ge31cXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcIm1hcmtcXFwiXVtcXFwidHlwZVxcXCJdID0gbWFya190eXBlXFxuICAgICAgICAgICAgc2VsZi5qc29uW1xcXCJtYXJrXFxcIl0udXBkYXRlKGt3YXJncylcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5qc29uW1xcXCJtYXJrXFxcIl0gPSBtYXJrX3R5cGVcXG5cXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuICAgIGRlZiBtYXJrX2JhcihzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcImJhclxcXCIsICoqa3dhcmdzKVxcblxcbiAgICBkZWYgbWFya19wb2ludChzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcInBvaW50XFxcIiwgKiprd2FyZ3MpXFxuXFxuICAgIGRlZiBtYXJrX2xpbmUoc2VsZiwgKiprd2FyZ3MpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYubWFya19qc29uKFxcXCJsaW5lXFxcIiwgKiprd2FyZ3MpXFxuXFxuICAgIGRlZiBtYXJrX3JlY3Qoc2VsZiwgKiprd2FyZ3MpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYubWFya19qc29uKFxcXCJyZWN0XFxcIiwgKiprd2FyZ3MpXFxuXFxuICAgIGRlZiBtYXJrX2FyZWEoc2VsZiwgKiprd2FyZ3MpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYubWFya19qc29uKFxcXCJhcmVhXFxcIiwgKiprd2FyZ3MpXFxuXFxuICAgIGRlZiBtYXJrX3RpY2soc2VsZiwgKiprd2FyZ3MpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYubWFya19qc29uKFxcXCJ0aWNrXFxcIiwgKiprd2FyZ3MpXFxuXFxuICAgIGRlZiBlbmNvZGUoc2VsZiwgeD1cXFwiXFxcIiwgeT1cXFwiXFxcIiwgY29sb3I9XFxcIlxcXCIsIHNpemU9XFxcIlxcXCIsIHRvb2x0aXA9XFxcIlxcXCIpOlxcbiAgICAgICAgc2VsZi5lbmNvZGluZyA9IHt9XFxuICAgICAgICBpZiB4OlxcbiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoeCwgQXhpcyk6XFxuICAgICAgICAgICAgICAgIHNlbGYuZW5jb2RpbmdbXFxcInhcXFwiXSA9IHgudG9Kc29uKClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzZWxmLmVuY29kaW5nW1xcXCJ4XFxcIl0gPSBBeGlzKHgpLnRvSnNvbigpXFxuICAgICAgICBpZiB5OlxcbiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoeSwgQXhpcyk6XFxuICAgICAgICAgICAgICAgIHNlbGYuZW5jb2RpbmdbXFxcInlcXFwiXSA9IHkudG9Kc29uKClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzZWxmLmVuY29kaW5nW1xcXCJ5XFxcIl0gPSBBeGlzKHkpLnRvSnNvbigpXFxuXFxuICAgICAgICAjIFxcXCJjb2xvclxcXCI6IHtcXFwidHlwZVxcXCI6IFxcXCJub21pbmFsXFxcIiwgXFxcImZpZWxkXFxcIjogXFxcInNwZWNpZXNcXFwifVxcbiAgICAgICAgaWYgY29sb3I6XFxuICAgICAgICAgICAgZmllbGQsIHRwID0gX2dldF9uYW1lX3R5cGUoY29sb3IpXFxuICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwiY29sb3JcXFwiXSA9IGRpY3QodHlwZT10cCwgZmllbGQ9ZmllbGQpXFxuXFxuICAgICAgICAjIFxcXCJzaXplXFxcIjoge1xcXCJ0eXBlXFxcIjogXFxcInF1YW50aXRhdGl2ZVxcXCIsIFxcXCJmaWVsZFxcXCI6IFxcXCJBY2NlbGVyYXRpb25cXFwifVxcbiAgICAgICAgaWYgc2l6ZTpcXG4gICAgICAgICAgICBmaWVsZCwgdHAgPSBfZ2V0X25hbWVfdHlwZShzaXplKVxcbiAgICAgICAgICAgIHNlbGYuZW5jb2RpbmdbXFxcInNpemVcXFwiXSA9IGRpY3QodHlwZT10cCwgZmllbGQ9ZmllbGQpXFxuXFxuICAgICAgICBpZiB0b29sdGlwOlxcbiAgICAgICAgICAgIGZpZWxkLCB0cCA9IF9nZXRfbmFtZV90eXBlKHRvb2x0aXApXFxuICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwidG9vbHRpcFxcXCJdID0gZGljdCh0eXBlPXRwLCBmaWVsZD1maWVsZClcXG5cXG4gICAgICAgIHNlbGYuanNvbltcXFwiZW5jb2RpbmdcXFwiXSA9IHNlbGYuZW5jb2RpbmdcXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuICAgIGRlZiBpbnRlcmFjdGl2ZShzZWxmKTpcXG4gICAgICAgIGljb25maWcgPSB7XFxuICAgICAgICAgICAgXFxcInNlbGVjdG9yMDAyXFxcIjoge1xcbiAgICAgICAgICAgICAgICBcXFwidHlwZVxcXCI6IFxcXCJpbnRlcnZhbFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJiaW5kXFxcIjogXFxcInNjYWxlc1xcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJlbmNvZGluZ3NcXFwiOiBbXFxcInhcXFwiLCBcXFwieVxcXCJdLFxcbiAgICAgICAgICAgICAgICBcXFwib25cXFwiOiBcXFwiW21vdXNlZG93biwgd2luZG93Om1vdXNldXBdID4gd2luZG93Om1vdXNlbW92ZSFcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwidHJhbnNsYXRlXFxcIjogXFxcIlttb3VzZWRvd24sIHdpbmRvdzptb3VzZXVwXSA+IHdpbmRvdzptb3VzZW1vdmUhXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcInpvb21cXFwiOiBcXFwid2hlZWwhXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcIm1hcmtcXFwiOiB7XFxcImZpbGxcXFwiOiBcXFwiIzMzM1xcXCIsIFxcXCJmaWxsT3BhY2l0eVxcXCI6IDAuMTI1LCBcXFwic3Ryb2tlXFxcIjogXFxcIndoaXRlXFxcIn0sXFxuICAgICAgICAgICAgICAgIFxcXCJyZXNvbHZlXFxcIjogXFxcImdsb2JhbFxcXCIsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2VsZi5qc29uW1xcXCJzZWxlY3Rpb25cXFwiXSA9IGljb25maWdcXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuICAgIGRlZiBkaXNwbGF5KHNlbGYpOlxcbiAgICAgICAgcmVuZGVyX2dyYXBoKHNlbGYuanNvbilcXG5cXG4gICAgZGVmIF9fYWRkX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuYWRkX2xheWVyKG90aGVyLCBcXFwibGF5ZXJcXFwiKVxcblxcbiAgICBkZWYgX19hbmRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICByZXR1cm4gc2VsZi5hZGRfbGF5ZXIob3RoZXIsIFxcXCJ2Y29uY2F0XFxcIilcXG5cXG4gICAgZGVmIF9fb3JfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICByZXR1cm4gc2VsZi5hZGRfbGF5ZXIob3RoZXIsIFxcXCJoY29uY2F0XFxcIilcXG5cXG4gICAgZGVmIGFkZF9sYXllcihzZWxmLCBvdGhlciwgbG5hbWUpOlxcbiAgICAgICAgIyBtdWx0bGUgbGF5ZXJzIGFyZSBhZGRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBuZXcgZWxlbWVudCB0byB0aGVcXG4gICAgICAgICMgZXhpc3RpbmcgbGF5ZXIuICBJZiB0aGUgbGF5ZXIgZG9lcyBub3QgZXhpc3QgdGhlbiBpbml0aWFsaXplXFxuICAgICAgICAjIGl0IGZyb20gc2VsZi5cXG4gICAgICAgIGlmIGxuYW1lIG5vdCBpbiBzZWxmLmpzb246XFxuICAgICAgICAgICAgc2VsZi5qc29uW2xuYW1lXSA9IFtdXFxuICAgICAgICAgICAgc2VsZi5qc29uW1xcXCJkYXRhc2V0c1xcXCJdID0ge31cXG4gICAgICAgICAgICB0ZW1wID0ge31cXG4gICAgICAgICAgICB0ZW1wW1xcXCJkYXRhXFxcIl0gPSB7XFxcIm5hbWVcXFwiOiBzZWxmLmRzbmFtZX1cXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcImRhdGFzZXRzXFxcIl1bc2VsZi5kc25hbWVdID0gc2VsZi5qc29uW1xcXCJkYXRhXFxcIl1bXFxcInZhbHVlc1xcXCJdXFxuICAgICAgICAgICAgZGVsIHNlbGYuanNvbltcXFwiZGF0YVxcXCJdXFxuICAgICAgICAgICAgdGVtcFtcXFwiZW5jb2RpbmdcXFwiXSA9IHNlbGYuanNvbltcXFwiZW5jb2RpbmdcXFwiXVxcbiAgICAgICAgICAgIGRlbCBzZWxmLmpzb25bXFxcImVuY29kaW5nXFxcIl1cXG4gICAgICAgICAgICB0ZW1wW1xcXCJtYXJrXFxcIl0gPSBzZWxmLmpzb25bXFxcIm1hcmtcXFwiXVxcbiAgICAgICAgICAgIGRlbCBzZWxmLmpzb25bXFxcIm1hcmtcXFwiXVxcbiAgICAgICAgICAgIHNlbGYuanNvbltsbmFtZV0uYXBwZW5kKHRlbXApXFxuICAgICAgICB0ZW1wID0ge31cXG4gICAgICAgIHNlbGYuanNvbltcXFwiZGF0YXNldHNcXFwiXVtvdGhlci5kc25hbWVdID0gb3RoZXIuanNvbltcXFwiZGF0YVxcXCJdW1xcXCJ2YWx1ZXNcXFwiXVxcbiAgICAgICAgdGVtcFtcXFwiZGF0YVxcXCJdID0ge1xcXCJuYW1lXFxcIjogb3RoZXIuZHNuYW1lfVxcbiAgICAgICAgdGVtcFtcXFwiZW5jb2RpbmdcXFwiXSA9IG90aGVyLmpzb25bXFxcImVuY29kaW5nXFxcIl1cXG4gICAgICAgIHRlbXBbXFxcIm1hcmtcXFwiXSA9IG90aGVyLmpzb25bXFxcIm1hcmtcXFwiXVxcbiAgICAgICAgc2VsZi5qc29uW2xuYW1lXS5hcHBlbmQodGVtcClcXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuXFxuIyAgIFxcXCJkYXRhc2V0c1xcXCI6IHtcXG4jICAgICBcXFwiZGF0YS1lNTZlNDMzNTRkOWI4ZjJhYjBkMWU5MGNmMjdjZDQ3ZlxcXCI6IFtcXG4jICAgICAgIHtcXFwiYVxcXCI6IDQsIFxcXCJiXFxcIjogMSwgXFxcImNcXFwiOiBcXFwiclxcXCJ9LFxcbiMgICAgICAge1xcXCJhXFxcIjogNSwgXFxcImJcXFwiOiAyLCBcXFwiY1xcXCI6IFxcXCJnXFxcIn0sXFxuIyAgICAgICB7XFxcImFcXFwiOiA2LCBcXFwiYlxcXCI6IDMsIFxcXCJjXFxcIjogXFxcImJcXFwifVxcbiMgICAgIF0sXFxuIyAgICAgXFxcImRhdGEtYTRjMzA0N2ExNWJmOTM4MGMyZTYxNWNmODc2NDgzNjlcXFwiOiBbXFxuIyAgICAgICB7XFxcImFcXFwiOiAxLCBcXFwiYlxcXCI6IDQsIFxcXCJjXFxcIjogXFxcInJcXFwifSxcXG4jICAgICAgIHtcXFwiYVxcXCI6IDIsIFxcXCJiXFxcIjogNSwgXFxcImNcXFwiOiBcXFwiZ1xcXCJ9LFxcbiMgICAgICAge1xcXCJhXFxcIjogMywgXFxcImJcXFwiOiA2LCBcXFwiY1xcXCI6IFxcXCJiXFxcIn1cXG4jICAgICBdXFxuIyAgIH1cXG5cXG4jIFRPRE86ICBhZGQgYSByZWN0IG1hcmsgdHlwZSBmb3IgYSBoZWF0IG1hcFxcblxcblxcbmRlZiBfZ2V0X25hbWVfdHlwZShuYW1lKTpcXG4gICAgdHlwZWQgPSB7XFxcIlFcXFwiOiBcXFwicXVhbnRpdGF0aXZlXFxcIiwgXFxcIk9cXFwiOiBcXFwib3JkaW5hbFxcXCIsIFxcXCJOXFxcIjogXFxcIm5vbWluYWxcXFwiLCBcXFwiVFxcXCI6IFxcXCJ0ZW1wb3JhbFxcXCJ9XFxuICAgIG50ID0gbmFtZS5zcGxpdChcXFwiOlxcXCIpXFxuICAgIHRzdHJpbmcgPSBcXFwicXVhbnRpdGF0aXZlXFxcIlxcbiAgICBpZiBsZW4obnQpID09IDI6XFxuICAgICAgICB0c3RyaW5nID0gdHlwZWRbbnRbMV1dXFxuICAgIHJldHVybiBudFswXSwgdHN0cmluZ1xcblxcblxcbmNsYXNzIEF4aXM6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBuYW1lLCBiaW49RmFsc2UpOlxcbiAgICAgICAgc2VsZi5hZ2dyZWdhdGUgPSBOb25lXFxuICAgICAgICBzZWxmLm5hbWUsIHNlbGYudHlwZSA9IF9nZXRfbmFtZV90eXBlKG5hbWUpXFxuICAgICAgICBpZiBcXFwiKClcXFwiIGluIHNlbGYubmFtZTogICMgYWdncmVnYXRlIGZ1bmN0aW9uXFxuICAgICAgICAgICAgc2VsZi5hZ2dyZWdhdGUgPSBzZWxmLm5hbWUucmVwbGFjZShcXFwiKClcXFwiLCBcXFwiXFxcIilcXG4gICAgICAgICAgICBzZWxmLm5hbWUgPSBOb25lXFxuICAgICAgICBzZWxmLmJpbiA9IGJpblxcblxcbiAgICBkZWYgdG9Kc29uKHNlbGYpOlxcbiAgICAgICAganNvbiA9IHt9XFxuICAgICAgICBpZiBzZWxmLm5hbWU6XFxuICAgICAgICAgICAganNvbltcXFwiZmllbGRcXFwiXSA9IHNlbGYubmFtZVxcbiAgICAgICAgaWYgc2VsZi50eXBlOlxcbiAgICAgICAgICAgIGpzb25bXFxcInR5cGVcXFwiXSA9IHNlbGYudHlwZVxcbiAgICAgICAgaWYgc2VsZi5iaW46XFxuICAgICAgICAgICAganNvbltcXFwiYmluXFxcIl0gPSBUcnVlXFxuICAgICAgICBpZiBzZWxmLmFnZ3JlZ2F0ZTpcXG4gICAgICAgICAgICBqc29uW1xcXCJhZ2dyZWdhdGVcXFwiXSA9IHNlbGYuYWdncmVnYXRlXFxuXFxuICAgICAgICByZXR1cm4ganNvblxcblxcblxcbmNsYXNzIFgoQXhpcyk6XFxuICAgIHBhc3NcXG5cXG5cXG5jbGFzcyBZKEF4aXMpOlxcbiAgICBwYXNzXFxuXFxuXFxuY2xhc3MgRGF0YTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsICoqa3dhcmdzKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgaW5wdXQgY2FuIGJlIHRoZSBmb3JtIG9mIGEgc2VyaWVzIG9mIGtleXdvcmQgYXJncyB3aGVyZVxcbiAgICAgICAgdGhlIGtleXdvcmQgaXMgdGhlIGNvbHVtbiBuYW1lLCBvciBhIHNpbmdsZSBrZXl3b3JkIGRhdGFcXG4gICAgICAgIHRoYXQgaXMgYSBsaXN0IG9mIGpzb24gc3R5bGUgcmVjb3JkcyBhcyByb3dzLlxcbiAgICAgICAgY291bGQgYWxzbyBhY2NlcHQgYSBjc3YgZmlsZT8gb3Iga2V5d29yZHMgY29sdW1ucyBhbmQgcm93c1xcbiAgICAgICAgVGhpcyBhY2NlcHRzIGEgbG90IG1vcmUgb3B0aW9ucyB0aGF0IFxcXCJyZWFsIGFsdGFpclxcXCIgdG8gbWFrZSBpdCBlYXNpZXJcXG4gICAgICAgIHRvIHdvcmsgd2l0aCBub24tRGF0YUZyYW1lIGRhdGEgc2V0cy4gIEludGVybmFsbHk6XFxuICAgICAgICBzZWxmLmtleXMgY29udGFpbnMgdGhlIGxpc3Qgb2YgY29sdW1uIG5hbWVzXFxuICAgICAgICBzZWxmLnZhbHMgaXMgYSBsaXN0IG9mIGRpY3Rpb25hcmllcyBvZiB0aGUgZm9ybSBbe2NvbDE6dmFsMSwgY29sMjp2YWwyLCAuLi4gY29sbjp2YWxufSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sMTp2YWwzLCBjb2wyOnZhbDQsIC4uLiBjb2xuOnZhbG59LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2wxOnZhbDUsIGNvbDI6dmFsNiwgLi4uIGNvbG46dmFsbn1dXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgICMgdG9kbzogYWNjZXB0IGEgVVJMIGFzIHRoZSBhcmd1bWVudCB0byByZWFkIGEgQ1NWIG9yIEpTT04gZmlsZVxcbiAgICAgICAgaWYgbGVuKGt3YXJncykgPT0gMSBhbmQgXFxcImRhdGFcXFwiIGluIGt3YXJnczpcXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSBrd2FyZ3NbXFxcImRhdGFcXFwiXVxcbiAgICAgICAgICAgIHNlbGYua2V5cyA9IHNlbGYuZGF0YVswXS5rZXlzKClcXG4gICAgICAgICAgICBzZWxmLnZhbHMgPSBzZWxmLmRhdGFcXG4gICAgICAgIGVsaWYgbGVuKGt3YXJncykgPT0gMiBhbmQgKFxcXCJjb2x1bW5zXFxcIiBpbiBrd2FyZ3MpIGFuZCAoXFxcInJvd3NcXFwiIGluIGt3YXJncyk6XFxuICAgICAgICAgICAgc2VsZi5rZXlzID0ga3dhcmdzW1xcXCJjb2x1bW5zXFxcIl1cXG4gICAgICAgICAgICBzZWxmLnZhbHMgPSBbXVxcbiAgICAgICAgICAgIGZvciByIGluIGt3YXJnc1tcXFwicm93c1xcXCJdOlxcbiAgICAgICAgICAgICAgICBzZWxmLnZhbHMuYXBwZW5kKGRpY3QoemlwKHNlbGYua2V5cywgcikpKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBrZXlzID0ga3dhcmdzLmtleXMoKVxcbiAgICAgICAgICAgIHZhbHMgPSBbXVxcbiAgICAgICAgICAgIHByaW1hcnlfa2V5ID0gbGlzdChrZXlzKVswXVxcbiAgICAgICAgICAgIGZvciBpeCBpbiByYW5nZShsZW4oa3dhcmdzW3ByaW1hcnlfa2V5XSkpOlxcbiAgICAgICAgICAgICAgICBkID0ge31cXG4gICAgICAgICAgICAgICAgZm9yIGtleSBpbiBrZXlzOlxcbiAgICAgICAgICAgICAgICAgICAgZFtrZXldID0ga3dhcmdzW2tleV1baXhdXFxuICAgICAgICAgICAgICAgIHZhbHMuYXBwZW5kKGQpXFxuICAgICAgICAgICAgc2VsZi52YWxzID0gdmFsc1xcbiAgICAgICAgICAgIHNlbGYua2V5cyA9IGtleXNcXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICAjIGhlYWRlciA9IFxcXCJcXFxcdFxcXCIuam9pbihzZWxmLmtleXMpICsgXFxcIlxcXFxuXFxcIlxcbiAgICAgICAgaGVhZGVyID0gXFxcIlxcXCJcXG4gICAgICAgIGZvciBrZXkgaW4gc2VsZi5rZXlzOlxcbiAgICAgICAgICAgIGhlYWRlciArPSBrZXkuY2VudGVyKDEwKSArIFxcXCIgXFxcIlxcbiAgICAgICAgaGVhZGVyICs9IFxcXCJcXFxcblxcXCJcXG4gICAgICAgIHRlbXBsYXRlID0gXFxcIlxcXCJcXG4gICAgICAgIGZvciBrZXkgaW4gc2VsZi5rZXlzOlxcbiAgICAgICAgICAgIHRlbXBsYXRlICs9IFxcXCJ7XFxcIiArIGtleSArIFxcXCI6IDwxMH0gXFxcIlxcbiAgICAgICAgdGVtcGxhdGUgKz0gXFxcIlxcXFxuXFxcIlxcbiAgICAgICAgcmVzID0gXFxcIlxcXCJcXG4gICAgICAgIGZvciByb3cgaW4gc2VsZi52YWxzOlxcbiAgICAgICAgICAgIHJlcyArPSB0ZW1wbGF0ZS5mb3JtYXQoKipyb3cpXFxuXFxuICAgICAgICByZXR1cm4gaGVhZGVyICsgcmVzXFxuXFxuXFxuaWYgX19uYW1lX18gPT0gXFxcIl9fbWFpbl9fXFxcIjpcXG4gICAgZCA9IERhdGEoYT1bMywgNCwgNV0sIGI9WzEsIDIsIDNdLCBjPVtcXFwiclxcXCIsIFxcXCJnXFxcIiwgXFxcImJcXFwiXSlcXG4gICAgcHJpbnQoZClcXG4gICAgcHJpbnQoXFxuICAgICAgICB0eXBlKFxcbiAgICAgICAgICAgIENoYXJ0KHtcXFwiYVxcXCI6IGxpc3QoXFxcImFiY1xcXCIpLCBcXFwiYlxcXCI6IFsxLCAyLCAzXX0pLm1hcmtfYmFyKCkuZW5jb2RlKHg9XFxcImE6TlxcXCIsIHk9XFxcImJcXFwiKVxcbiAgICAgICAgKVxcbiAgICApXFxuICAgIGFhID0gKFxcbiAgICAgICAgQ2hhcnQoRGF0YShhPVszLCA0LCA1XSwgYj1bMSwgMiwgM10sIGM9W1xcXCJyXFxcIiwgXFxcImdcXFwiLCBcXFwiYlxcXCJdKSlcXG4gICAgICAgIC5tYXJrX3BvaW50KGNvbG9yPVxcXCJyZWRcXFwiKVxcbiAgICAgICAgLmVuY29kZSh4PVxcXCJiXFxcIiwgeT1cXFwiYVxcXCIsIGNvbG9yPVxcXCJjOk9cXFwiKVxcbiAgICApXFxuICAgIHByaW50KFxcXCJhYSA9IFxcXCIsIGFhKVxcbiAgICBhYS5kaXNwbGF5KClcXG5cXG4gICAgYmIgPSAoXFxuICAgICAgICBDaGFydChEYXRhKGE9WzEsIDIsIDNdLCBiPVs0LCA1LCA2XSwgYz1bXFxcInJcXFwiLCBcXFwiZ1xcXCIsIFxcXCJiXFxcIl0pKVxcbiAgICAgICAgLm1hcmtfbGluZSgpXFxuICAgICAgICAuZW5jb2RlKHg9XFxcImJcXFwiLCB5PVxcXCJhXFxcIiwgY29sb3I9XFxcImM6T1xcXCIpXFxuICAgIClcXG4gICAgcHJpbnQoXFxcImJiID0gXFxcIiwgYmIpXFxuICAgIGJiLmRpc3BsYXkoKVxcbiAgICBwcmludChcXFwiYWErYmJcXFwiLCAoYWEgKyBiYikuZGlzcGxheSgpKVxcbiAgICAjIENoYXJ0KERhdGEoYT1bMSwyLDMsMiwyLDQsNSw1LDYsNyw4LDgsOCw4LDgsOSwwLDBdKSkubWFya19iYXIoKS5lbmNvZGUoQXhpcygnYTpRJywgYmluPVRydWUpLHk9J2NvdW50KCknKVxcblxcblxcbiMgdG9kbzogc2VlIGlmIEkgY2FuIHdvcmsgd2l0aCB0aGUgcmVwciBvZiBhbiBvYmplY3QgdG8gZ2V0IHRoZSBiZWhhdmlvciB0aGF0IGFsdGFpciBnZXRzIGluIG5vdGVib29rc1xcbiMgdG9kbzogaW1wbGVtZW50IGEgQmluIG9iamVjdCB0byBzcGVjaWZpeSBtYXhiaW5zXFxuXCIsXCJzcmMvbGliL2FudGlncmF2aXR5LnB5XCI6XCJpbXBvcnQgd2ViYnJvd3NlclxcblxcbndlYmJyb3dzZXIub3BlbihcXFwiaHR0cHM6Ly94a2NkLmNvbS8zNTMvXFxcIilcXG5cIixcInNyYy9saWIvYW55ZGJtLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImFueWRibVxcXCIpXFxuXCIsXCJzcmMvbGliL2FzdC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJhc3RcXFwiKVxcblwiLFwic3JjL2xpYi9hc3luY2hhdC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJhc3luY2hhdFxcXCIpXFxuXCIsXCJzcmMvbGliL2FzeW5jb3JlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImFzeW5jb3JlXFxcIilcXG5cIixcInNyYy9saWIvYXRleGl0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImF0ZXhpdFxcXCIpXFxuXCIsXCJzcmMvbGliL2F1ZGlvZGV2LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImF1ZGlvZGV2XFxcIilcXG5cIixcInNyYy9saWIvYmFzZTY0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImJhc2U2NFxcXCIpXFxuXCIsXCJzcmMvbGliL2JkYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJiZGJcXFwiKVxcblwiLFwic3JjL2xpYi9iaW5oZXgucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiYmluaGV4XFxcIilcXG5cIixcInNyYy9saWIvYmlzZWN0LnB5XCI6XCJcXFwiXFxcIlxcXCJCaXNlY3Rpb24gYWxnb3JpdGhtcy5cXFwiXFxcIlxcXCJcXG5cXG5kZWYgaW5zb3J0X3JpZ2h0KGEsIHgsIGxvPTAsIGhpPU5vbmUpOlxcbiAgICBcXFwiXFxcIlxcXCJJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxcblxcbiAgICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXFxuXFxuICAgIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGxlbihhKSkgYm91bmQgdGhlXFxuICAgIHNsaWNlIG9mIGEgdG8gYmUgc2VhcmNoZWQuXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICBpZiBsbyA8IDA6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpXFxuICAgIGlmIGhpIGlzIE5vbmU6XFxuICAgICAgICBoaSA9IGxlbihhKVxcbiAgICB3aGlsZSBsbyA8IGhpOlxcbiAgICAgICAgbWlkID0gKGxvK2hpKS8vMlxcbiAgICAgICAgaWYgeCA8IGFbbWlkXTogaGkgPSBtaWRcXG4gICAgICAgIGVsc2U6IGxvID0gbWlkKzFcXG4gICAgYS5pbnNlcnQobG8sIHgpXFxuXFxuZGVmIGJpc2VjdF9yaWdodChhLCB4LCBsbz0wLCBoaT1Ob25lKTpcXG4gICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBpbmRleCB3aGVyZSB0byBpbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXFxuXFxuICAgIFRoZSByZXR1cm4gdmFsdWUgaSBpcyBzdWNoIHRoYXQgYWxsIGUgaW4gYVs6aV0gaGF2ZSBlIDw9IHgsIGFuZCBhbGwgZSBpblxcbiAgICBhW2k6XSBoYXZlIGUgPiB4LiAgU28gaWYgeCBhbHJlYWR5IGFwcGVhcnMgaW4gdGhlIGxpc3QsIGEuaW5zZXJ0KHgpIHdpbGxcXG4gICAgaW5zZXJ0IGp1c3QgYWZ0ZXIgdGhlIHJpZ2h0bW9zdCB4IGFscmVhZHkgdGhlcmUuXFxuXFxuICAgIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGxlbihhKSkgYm91bmQgdGhlXFxuICAgIHNsaWNlIG9mIGEgdG8gYmUgc2VhcmNoZWQuXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICBpZiBsbyA8IDA6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpXFxuICAgIGlmIGhpIGlzIE5vbmU6XFxuICAgICAgICBoaSA9IGxlbihhKVxcbiAgICB3aGlsZSBsbyA8IGhpOlxcbiAgICAgICAgbWlkID0gKGxvK2hpKS8vMlxcbiAgICAgICAgaWYgeCA8IGFbbWlkXTogaGkgPSBtaWRcXG4gICAgICAgIGVsc2U6IGxvID0gbWlkKzFcXG4gICAgcmV0dXJuIGxvXFxuXFxuZGVmIGluc29ydF9sZWZ0KGEsIHgsIGxvPTAsIGhpPU5vbmUpOlxcbiAgICBcXFwiXFxcIlxcXCJJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxcblxcbiAgICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSBsZWZ0IG9mIHRoZSBsZWZ0bW9zdCB4LlxcblxcbiAgICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBsZW4oYSkpIGJvdW5kIHRoZVxcbiAgICBzbGljZSBvZiBhIHRvIGJlIHNlYXJjaGVkLlxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgaWYgbG8gPCAwOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKVxcbiAgICBpZiBoaSBpcyBOb25lOlxcbiAgICAgICAgaGkgPSBsZW4oYSlcXG4gICAgd2hpbGUgbG8gPCBoaTpcXG4gICAgICAgIG1pZCA9IChsbytoaSkvLzJcXG4gICAgICAgIGlmIGFbbWlkXSA8IHg6IGxvID0gbWlkKzFcXG4gICAgICAgIGVsc2U6IGhpID0gbWlkXFxuICAgIGEuaW5zZXJ0KGxvLCB4KVxcblxcblxcbmRlZiBiaXNlY3RfbGVmdChhLCB4LCBsbz0wLCBoaT1Ob25lKTpcXG4gICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBpbmRleCB3aGVyZSB0byBpbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXFxuXFxuICAgIFRoZSByZXR1cm4gdmFsdWUgaSBpcyBzdWNoIHRoYXQgYWxsIGUgaW4gYVs6aV0gaGF2ZSBlIDwgeCwgYW5kIGFsbCBlIGluXFxuICAgIGFbaTpdIGhhdmUgZSA+PSB4LiAgU28gaWYgeCBhbHJlYWR5IGFwcGVhcnMgaW4gdGhlIGxpc3QsIGEuaW5zZXJ0KHgpIHdpbGxcXG4gICAgaW5zZXJ0IGp1c3QgYmVmb3JlIHRoZSBsZWZ0bW9zdCB4IGFscmVhZHkgdGhlcmUuXFxuXFxuICAgIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGxlbihhKSkgYm91bmQgdGhlXFxuICAgIHNsaWNlIG9mIGEgdG8gYmUgc2VhcmNoZWQuXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICBpZiBsbyA8IDA6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpXFxuICAgIGlmIGhpIGlzIE5vbmU6XFxuICAgICAgICBoaSA9IGxlbihhKVxcbiAgICB3aGlsZSBsbyA8IGhpOlxcbiAgICAgICAgbWlkID0gKGxvK2hpKS8vMlxcbiAgICAgICAgaWYgYVttaWRdIDwgeDogbG8gPSBtaWQrMVxcbiAgICAgICAgZWxzZTogaGkgPSBtaWRcXG4gICAgcmV0dXJuIGxvXFxuXFxuIyBPdmVyd3JpdGUgYWJvdmUgZGVmaW5pdGlvbnMgd2l0aCBhIGZhc3QgQyBpbXBsZW1lbnRhdGlvblxcbnRyeTpcXG4gICAgZnJvbSBfYmlzZWN0IGltcG9ydCAqXFxuZXhjZXB0IEltcG9ydEVycm9yOlxcbiAgICBwYXNzXFxuXFxuIyBDcmVhdGUgYWxpYXNlc1xcbmJpc2VjdCA9IGJpc2VjdF9yaWdodFxcbmluc29ydCA9IGluc29ydF9yaWdodFxcblwiLFwic3JjL2xpYi9ic2RkYi9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJic2RkYlxcXCIpXFxuXCIsXCJzcmMvbGliL2NQcm9maWxlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNQcm9maWxlXFxcIilcXG5cIixcInNyYy9saWIvY2dpLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNnaVxcXCIpXFxuXCIsXCJzcmMvbGliL2NnaXRiLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNnaXRiXFxcIilcXG5cIixcInNyYy9saWIvY2h1bmsucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY2h1bmtcXFwiKVxcblwiLFwic3JjL2xpYi9jbWQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY21kXFxcIilcXG5cIixcInNyYy9saWIvY29kZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb2RlXFxcIilcXG5cIixcInNyYy9saWIvY29kZWNzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvZGVjc1xcXCIpXFxuXCIsXCJzcmMvbGliL2NvZGVvcC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb2Rlb3BcXFwiKVxcblwiLFwic3JjL2xpYi9jb2xvcnN5cy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb2xvcnN5c1xcXCIpXFxuXCIsXCJzcmMvbGliL2NvbW1hbmRzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvbW1hbmRzXFxcIilcXG5cIixcInNyYy9saWIvY29tcGlsZWFsbC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb21waWxlYWxsXFxcIilcXG5cIixcInNyYy9saWIvY29tcGlsZXIvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY29tcGlsZXJcXFwiKVxcblwiLFwic3JjL2xpYi9jb25maWcvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY29uZmlnXFxcIilcXG5cIixcInNyYy9saWIvY29udGV4dGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb250ZXh0bGliXFxcIilcXG5cIixcInNyYy9saWIvY29va2llbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvb2tpZWxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL2NvcHkucHlcIjpcIlxcXCJcXFwiXFxcIlxcblRoaXMgZmlsZSB3YXMgbW9kaWZpZWQgZnJvbSBDUHl0aG9uLlxcbkNvcHlyaWdodCAoYykgMjAwMSwgMjAwMiwgMjAwMywgMjAwNCwgMjAwNSwgMjAwNiwgMjAwNywgMjAwOCwgMjAwOSwgMjAxMCxcXG4yMDExLCAyMDEyLCAyMDEzLCAyMDE0LCAyMDE1IFB5dGhvbiBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBBbGwgUmlnaHRzIFJlc2VydmVkXFxuXFxcIlxcXCJcXFwiXFxuaW1wb3J0IHR5cGVzXFxuY2xhc3MgRXJyb3IoRXhjZXB0aW9uKTpcXG4gICAgcGFzc1xcbmVycm9yID0gRXJyb3IgXFxuY2xhc3MgX0VtcHR5Q2xhc3M6XFxuICAgIHBhc3NcXG50cnk6XFxuICAgIGxvbmdcXG5leGNlcHQgTmFtZUVycm9yOlxcbiAgICBsb25nID0gaW50XFxudHJ5OlxcbiAgICBieXRlc1xcbmV4Y2VwdCBOYW1lRXJyb3I6XFxuICAgIGJ5dGVzID0gc3RyXFxuXFxuZGVmIGNoZWNrX25vdGltcGxlbWVudGVkX3N0YXRlKHgpOlxcbiAgICBnZXRzdGF0ZSA9IGdldGF0dHIoeCwgXFxcIl9fZ2V0c3RhdGVfX1xcXCIsIE5vbmUpXFxuICAgIHNldHN0YXRlID0gZ2V0YXR0cih4LCBcXFwiX19zZXRzdGF0ZV9fXFxcIiwgTm9uZSlcXG4gICAgaW5pdGFyZ3MgPSBnZXRhdHRyKHgsIFxcXCJfX2dldGluaXRhcmdzX19cXFwiLCBOb25lKVxcbiAgICBpZiBnZXRzdGF0ZSBvciBzZXRzdGF0ZSBvciBpbml0YXJnczpcXG4gICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIlNrdWxwdCBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBjb3B5aW5nIHdpdGggdXNlci1kZWZpbmVkIF9fZ2V0c3RhdGVfXywgX19zZXRzdGF0ZV9fIG9yIF9fZ2V0aW5pdGFyZ3NfXygpXFxcIilcXG5cXG5cXG5kZWYgY29weSh4KTpcXG4gICAgY2xzID0gdHlwZSh4KVxcbiAgICBpZiBjYWxsYWJsZSh4KTpcXG4gICAgICAgIHJldHVybiB4XFxuICAgIGNvcGllciA9IGdldGF0dHIoY2xzLCBcXFwiX19jb3B5X19cXFwiLCBOb25lKVxcbiAgICBpZiBjb3BpZXI6XFxuICAgICAgICByZXR1cm4gY29waWVyKHgpXFxuICAgIGlmIGNscyBpbiAodHlwZShOb25lKSwgaW50LCBmbG9hdCwgYm9vbCwgc3RyLCBieXRlcywgdHVwbGUsIHR5cGUsIGZyb3plbnNldCwgbG9uZyk6XFxuICAgICAgICByZXR1cm4geFxcbiAgICBpZiAoY2xzID09IGxpc3QpIG9yIChjbHMgPT0gZGljdCkgb3IgKGNscyA9PSBzZXQpIG9yIChjbHMgPT0gc2xpY2UpOlxcbiAgICAgICAgcmV0dXJuIGNscyh4KVxcbiAgICByZWR1Y3RvciA9IGdldGF0dHIoeCwgXFxcIl9fcmVkdWNlX2V4X19cXFwiLCBOb25lKVxcbiAgICBpZiByZWR1Y3RvcjpcXG4gICAgICAgIHJ2ID0gcmVkdWN0b3IoNClcXG4gICAgZWxzZTpcXG4gICAgICAgIHJlZHVjdG9yID0gZ2V0YXR0cih4LCBcXFwiX19yZWR1Y2VfX1xcXCIsIE5vbmUpXFxuICAgICAgICBpZiByZWR1Y3RvcjpcXG4gICAgICAgICAgICBydiA9IHJlZHVjdG9yKClcXG4gICAgICAgIGVsaWYgc3RyKGNscylbMTo2XSA9PSBcXFwiY2xhc3NcXFwiOlxcbiAgICAgICAgICAgIGNoZWNrX25vdGltcGxlbWVudGVkX3N0YXRlKHgpXFxuICAgICAgICAgICAgY29waWVyID0gX2NvcHlfaW5zdFxcbiAgICAgICAgICAgIHJldHVybiBjb3BpZXIoeClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmFpc2UgRXJyb3IoXFxcInVuKHNoYWxsb3cpY29weWFibGUgb2JqZWN0IG9mIHR5cGUgJXNcXFwiICUgY2xzKVxcbiAgICBpZiBpc2luc3RhbmNlKHJ2LCBzdHIpOlxcbiAgICAgICAgcmV0dXJuIHhcXG4gICAgcmV0dXJuIF9yZWNvbnN0cnVjdCh4LCBydiwgMClcXG5cXG5kZWYgX2NvcHlfaW5zdCh4KTpcXG4gICAgaWYgaGFzYXR0cih4LCAnX19jb3B5X18nKTpcXG4gICAgICAgIHJldHVybiB4Ll9fY29weV9fKClcXG4gICAgaWYgaGFzYXR0cih4LCAnX19nZXRpbml0YXJnc19fJyk6XFxuICAgICAgICBhcmdzID0geC5fX2dldGluaXRhcmdzX18oKVxcbiAgICAgICAgeSA9IHguX19jbGFzc19fKCphcmdzKVxcbiAgICBlbHNlOlxcbiAgICAgICAgeSA9IF9FbXB0eUNsYXNzKClcXG4gICAgICAgIHkuX19jbGFzc19fID0geC5fX2NsYXNzX19cXG4gICAgaWYgaGFzYXR0cih4LCAnX19nZXRzdGF0ZV9fJyk6XFxuICAgICAgICBzdGF0ZSA9IHguX19nZXRzdGF0ZV9fKClcXG4gICAgZWxzZTpcXG4gICAgICAgIHN0YXRlID0geC5fX2RpY3RfX1xcbiAgICBpZiBoYXNhdHRyKHksICdfX3NldHN0YXRlX18nKTpcXG4gICAgICAgIHkuX19zZXRzdGF0ZV9fKHN0YXRlKVxcbiAgICBlbHNlOlxcbiAgICAgICAgeS5fX2RpY3RfXy51cGRhdGUoc3RhdGUpXFxuICAgIHJldHVybiB5XFxuXFxuZCA9IF9kZWVwY29weV9kaXNwYXRjaCA9IHt9XFxuXFxuZGVmIGRlZXBjb3B5KHgsIG1lbW89Tm9uZSwgX25pbD1bXSk6XFxuICAgIFxcXCJcXFwiXFxcIkRlZXAgY29weSBvcGVyYXRpb24gb24gYXJiaXRyYXJ5IFB5dGhvbiBvYmplY3RzLlxcbiAgICBTZWUgdGhlIG1vZHVsZSdzIF9fZG9jX18gc3RyaW5nIGZvciBtb3JlIGluZm8uXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBpZiBtZW1vIGlzIE5vbmU6XFxuICAgICAgICBtZW1vID0ge31cXG4gICAgaWR4ID0gaWQoeClcXG4gICAgeSA9IG1lbW8uZ2V0KGlkeCwgX25pbClcXG4gICAgaWYgeSBpcyBub3QgX25pbDpcXG4gICAgICAgIHJldHVybiB5XFxuICAgIGNscyA9IHR5cGUoeClcXG4gICAgY29waWVyID0gX2RlZXBjb3B5X2Rpc3BhdGNoLmdldChjbHMpXFxuICAgIGlmIGNvcGllcjpcXG4gICAgICAgIHkgPSBjb3BpZXIoeCwgbWVtbylcXG4gICAgZWxzZTpcXG4gICAgICAgIHRyeTpcXG4gICAgICAgICAgICBpc3NjID0gaXNzdWJjbGFzcyhjbHMsIHR5cGUpXFxuICAgICAgICBleGNlcHQgVHlwZUVycm9yOiAjIGNscyBpcyBub3QgYSBjbGFzcyAob2xkIEJvb3N0OyBzZWUgU0YgIzUwMjA4NSlcXG4gICAgICAgICAgICBpc3NjID0gMFxcbiAgICAgICAgaWYgaXNzYzpcXG4gICAgICAgICAgICB5ID0gX2RlZXBjb3B5X2F0b21pYyh4LCBtZW1vKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBjb3BpZXIgPSBnZXRhdHRyKHgsIFxcXCJfX2RlZXBjb3B5X19cXFwiLCBOb25lKVxcbiAgICAgICAgICAgIGlmIGNvcGllcjpcXG4gICAgICAgICAgICAgICAgeSA9IGNvcGllcihtZW1vKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJlZHVjdG9yID0gZ2V0YXR0cih4LCBcXFwiX19yZWR1Y2VfZXhfX1xcXCIsIE5vbmUpXFxuICAgICAgICAgICAgICAgIGlmIHJlZHVjdG9yOlxcbiAgICAgICAgICAgICAgICAgICAgcnYgPSByZWR1Y3RvcigyKVxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgcnYgPSBOb25lXFxuICAgICAgICAgICAgICAgICAgICByZWR1Y3RvciA9IGdldGF0dHIoeCwgXFxcIl9fcmVkdWNlX19cXFwiLCBOb25lKVxcbiAgICAgICAgICAgICAgICAgICAgaWYgcmVkdWN0b3I6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcnYgPSByZWR1Y3RvcigpXFxuICAgICAgICAgICAgICAgICAgICBlbGlmIHN0cihjbHMpWzE6Nl0gPT0gXFxcImNsYXNzXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19ub3RpbXBsZW1lbnRlZF9zdGF0ZSh4KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcGllciA9IF9kZWVwY29weV9kaXNwYXRjaFtcXFwiSW5zdGFuY2VUeXBlXFxcIl1cXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gY29waWVyKHgsIG1lbW8pXFxuICAgICAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlIEVycm9yKFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwidW4oZGVlcCljb3B5YWJsZSBvYmplY3Qgb2YgdHlwZSAlc1xcXCIgJSBjbHMpXFxuICAgICAgICAgICAgICAgIGlmIHJ2IGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgICAgICAgICAgeSA9IF9yZWNvbnN0cnVjdCh4LCBydiwgMSwgbWVtbylcXG4gICAgbWVtb1tpZHhdID0geVxcbiAgICBfa2VlcF9hbGl2ZSh4LCBtZW1vKSAjIE1ha2Ugc3VyZSB4IGxpdmVzIGF0IGxlYXN0IGFzIGxvbmcgYXMgZFxcbiAgICByZXR1cm4geVxcblxcbmRlZiBfZGVlcGNvcHlfYXRvbWljKHgsIG1lbW8pOlxcbiAgICByZXR1cm4geFxcbmRbdHlwZShOb25lKV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuIyBkW3R5cGUoRWxsaXBzaXMpXSA9IF9kZWVwY29weV9hdG9taWNcXG5kW3R5cGUoTm90SW1wbGVtZW50ZWQpXSA9IF9kZWVwY29weV9hdG9taWNcXG5kW2ludF0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFtmbG9hdF0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFtib29sXSA9IF9kZWVwY29weV9hdG9taWNcXG5kW2NvbXBsZXhdID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbYnl0ZXNdID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbc3RyXSA9IF9kZWVwY29weV9hdG9taWNcXG4jIHRyeTpcXG4jIGRbdHlwZXMuQ29kZVR5cGVdID0gX2RlZXBjb3B5X2F0b21pY1xcbiMgZXhjZXB0IEF0dHJpYnV0ZUVycm9yOlxcbiMgICBwYXNzXFxuZFt0eXBlXSA9IF9kZWVwY29weV9hdG9taWNcXG4jIGRbdHlwZXMuQnVpbHRpbkZ1bmN0aW9uVHlwZV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFt0eXBlcy5GdW5jdGlvblR5cGVdID0gX2RlZXBjb3B5X2F0b21pY1xcbiMgZFt3ZWFrcmVmLnJlZl0gPSBfZGVlcGNvcHlfYXRvbWljXFxuXFxuZGVmIF9kZWVwY29weV9saXN0KHgsIG1lbW8pOlxcbiAgICB5ID0gW11cXG4gICAgbWVtb1tpZCh4KV0gPSB5XFxuICAgIGZvciBhIGluIHg6XFxuICAgICAgICB5LmFwcGVuZChkZWVwY29weShhLCBtZW1vKSlcXG4gICAgcmV0dXJuIHlcXG5kW2xpc3RdID0gX2RlZXBjb3B5X2xpc3RcXG5cXG5kZWYgX2RlZXBjb3B5X3NldCh4LCBtZW1vKTpcXG4gICAgcmVzdWx0ID0gc2V0KFtdKSAgIyBtYWtlIGVtcHR5IHNldFxcbiAgICBtZW1vW2lkKHgpXSA9IHJlc3VsdCAgIyByZWdpc3RlciB0aGlzIHNldCBpbiB0aGUgbWVtbyBmb3IgbG9vcCBjaGVja2luZ1xcbiAgICBmb3IgYSBpbiB4OiAgICMgZ28gdGhyb3VnaCBlbGVtZW50cyBvZiBzZXRcXG4gICAgICAgIHJlc3VsdC5hZGQoZGVlcGNvcHkoYSwgbWVtbykpICAjIGFkZCB0aGUgY29waWVkIGVsZW1lbnRzIGludG8gdGhlIG5ldyBzZXRcXG4gICAgcmV0dXJuIHJlc3VsdCAjIHJldHVybiB0aGUgbmV3IHNldFxcbmRbc2V0XSA9IF9kZWVwY29weV9zZXRcXG5cXG5kZWYgX2RlZXBjb3B5X2Zyb3plbnNldCh4LCBtZW1vKTpcXG4gICAgcmVzdWx0ID0gZnJvemVuc2V0KF9kZWVwY29weV9zZXQoeCxtZW1vKSkgXFxuICAgIG1lbW9baWQoeCldID0gcmVzdWx0IFxcbiAgICByZXR1cm4gcmVzdWx0XFxuZFtmcm96ZW5zZXRdID0gX2RlZXBjb3B5X2Zyb3plbnNldFxcblxcbmRlZiBfZGVlcGNvcHlfdHVwbGUoeCwgbWVtbyk6XFxuICAgIHkgPSBbZGVlcGNvcHkoYSwgbWVtbykgZm9yIGEgaW4geF1cXG4gICAgIyBXZSdyZSBub3QgZ29pbmcgdG8gcHV0IHRoZSB0dXBsZSBpbiB0aGUgbWVtbywgYnV0IGl0J3Mgc3RpbGwgaW1wb3J0YW50IHdlXFxuICAgICMgY2hlY2sgZm9yIGl0LCBpbiBjYXNlIHRoZSB0dXBsZSBjb250YWlucyByZWN1cnNpdmUgbXV0YWJsZSBzdHJ1Y3R1cmVzLlxcbiAgICB0cnk6XFxuICAgICAgICByZXR1cm4gbWVtb1tpZCh4KV1cXG4gICAgZXhjZXB0IEtleUVycm9yOlxcbiAgICAgICAgcGFzc1xcbiAgICBmb3IgaywgaiBpbiB6aXAoeCwgeSk6XFxuICAgICAgICBpZiBrIGlzIG5vdCBqOlxcbiAgICAgICAgICAgIHkgPSB0dXBsZSh5KVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgIGVsc2U6XFxuICAgICAgICB5ID0geFxcbiAgICByZXR1cm4geVxcbmRbdHVwbGVdID0gX2RlZXBjb3B5X3R1cGxlXFxuXFxuZGVmIF9kZWVwY29weV9kaWN0KHgsIG1lbW8pOlxcbiAgICB5ID0ge31cXG4gICAgbWVtb1tpZCh4KV0gPSB5XFxuICAgIGZvciBrZXksIHZhbHVlIGluIHguaXRlbXMoKTpcXG4gICAgICAgIHlbZGVlcGNvcHkoa2V5LCBtZW1vKV0gPSBkZWVwY29weSh2YWx1ZSwgbWVtbylcXG4gICAgcmV0dXJuIHlcXG5kW2RpY3RdID0gX2RlZXBjb3B5X2RpY3RcXG5cXG4jIGRlZiBfZGVlcGNvcHlfbWV0aG9kKHgsIG1lbW8pOiAjIENvcHkgaW5zdGFuY2UgbWV0aG9kc1xcbiMgICAgIHkgPSB0eXBlKHgpKHguaW1fZnVuYywgZGVlcGNvcHkoeC5pbV9zZWxmLCBtZW1vKSwgeC5pbV9jbGFzcyk7XFxuIyAgICAgcmV0dXJuIHlcXG5kW3R5cGVzLk1ldGhvZFR5cGVdID0gX2RlZXBjb3B5X2F0b21pY1xcblxcbmRlZiBfZGVlcGNvcHlfaW5zdCh4LCBtZW1vKTpcXG4gICAgaWYgaGFzYXR0cih4LCAnX19kZWVwY29weV9fJyk6XFxuICAgICAgICAgcmV0dXJuIHguX19kZWVwY29weV9fKG1lbW8pXFxuICAgIGlmIGhhc2F0dHIoeCwgJ19fZ2V0aW5pdGFyZ3NfXycpOlxcbiAgICAgICAgYXJncyA9IHguX19nZXRpbml0YXJnc19fKClcXG4gICAgICAgIGFyZ3MgPSBkZWVwY29weShhcmdzLCBtZW1vKVxcbiAgICAgICAgeSA9IHguX19jbGFzc19fKCphcmdzKVxcbiAgICBlbHNlOlxcbiAgICAgICAgeSA9IF9FbXB0eUNsYXNzKClcXG4gICAgICAgIHkuX19jbGFzc19fID0geC5fX2NsYXNzX19cXG4gICAgbWVtb1tpZCh4KV0gPSB5XFxuICAgIGlmIGhhc2F0dHIoeCwgJ19fZ2V0c3RhdGVfXycpOlxcbiAgICAgICAgc3RhdGUgPSB4Ll9fZ2V0c3RhdGVfXygpXFxuICAgIGVsc2U6XFxuICAgICAgICBzdGF0ZSA9IHguX19kaWN0X19cXG4gICAgc3RhdGUgPSBkZWVwY29weShzdGF0ZSwgbWVtbylcXG4gICAgaWYgaGFzYXR0cih5LCAnX19zZXRzdGF0ZV9fJyk6XFxuICAgICAgICB5Ll9fc2V0c3RhdGVfXyhzdGF0ZSlcXG4gICAgZWxzZTpcXG4gICAgICAgIHkuX19kaWN0X18udXBkYXRlKHN0YXRlKVxcbiAgICAgICAgcmV0dXJuIHlcXG5kW1xcXCJJbnN0YW5jZVR5cGVcXFwiXSA9IF9kZWVwY29weV9pbnN0XFxuXFxuZGVmIF9rZWVwX2FsaXZlKHgsIG1lbW8pOlxcbiAgICBcXFwiXFxcIlxcXCJLZWVwcyBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IHggaW4gdGhlIG1lbW8uXFxuICAgIEJlY2F1c2Ugd2UgcmVtZW1iZXIgb2JqZWN0cyBieSB0aGVpciBpZCwgd2UgaGF2ZVxcbiAgICB0byBhc3N1cmUgdGhhdCBwb3NzaWJseSB0ZW1wb3Jhcnkgb2JqZWN0cyBhcmUga2VwdFxcbiAgICBhbGl2ZSBieSByZWZlcmVuY2luZyB0aGVtLlxcbiAgICBXZSBzdG9yZSBhIHJlZmVyZW5jZSBhdCB0aGUgaWQgb2YgdGhlIG1lbW8sIHdoaWNoIHNob3VsZFxcbiAgICBub3JtYWxseSBub3QgYmUgdXNlZCB1bmxlc3Mgc29tZW9uZSB0cmllcyB0byBkZWVwY29weVxcbiAgICB0aGUgbWVtbyBpdHNlbGYuLi5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIHRyeTpcXG4gICAgICAgIG1lbW9baWQobWVtbyldLmFwcGVuZCh4KVxcbiAgICBleGNlcHQgS2V5RXJyb3I6XFxuICAgICAgICAjIGFoYSwgdGhpcyBpcyB0aGUgZmlyc3Qgb25lIDotKVxcbiAgICAgICAgbWVtb1tpZChtZW1vKV09W3hdXFxuXFxuZGVmIF9yZWNvbnN0cnVjdCh4LCBpbmZvLCBkZWVwLCBtZW1vPU5vbmUpOlxcbiAgICBpZiBpc2luc3RhbmNlKGluZm8sIHN0cik6XFxuICAgICAgICByZXR1cm4geFxcbiAgICBhc3NlcnQgaXNpbnN0YW5jZShpbmZvLCB0dXBsZSlcXG4gICAgaWYgbWVtbyBpcyBOb25lOlxcbiAgICAgICAgbWVtbyA9IHt9XFxuICAgIG4gPSBsZW4oaW5mbylcXG4gICAgYXNzZXJ0IG4gaW4gKDIsIDMsIDQsIDUpXFxuICAgIGNhbGxhYmxlLCBhcmdzID0gaW5mb1s6Ml1cXG4gICAgaWYgbiA+IDI6XFxuICAgICAgICBzdGF0ZSA9IGluZm9bMl1cXG4gICAgZWxzZTpcXG4gICAgICAgIHN0YXRlID0gTm9uZVxcbiAgICBpZiBuID4gMzpcXG4gICAgICAgIGxpc3RpdGVyID0gaW5mb1szXVxcbiAgICBlbHNlOlxcbiAgICAgICAgbGlzdGl0ZXIgPSBOb25lXFxuICAgIGlmIG4gPiA0OlxcbiAgICAgICAgZGljdGl0ZXIgPSBpbmZvWzRdXFxuICAgIGVsc2U6XFxuICAgICAgICBkaWN0aXRlciA9IE5vbmVcXG4gICAgaWYgZGVlcDpcXG4gICAgICAgIGFyZ3MgPSBkZWVwY29weShhcmdzLCBtZW1vKVxcbiAgICB5ID0gY2FsbGFibGUoKmFyZ3MpXFxuICAgIG1lbW9baWQoeCldID0geVxcblxcbiAgICBpZiBzdGF0ZSBpcyBub3QgTm9uZTpcXG4gICAgICAgIGlmIGRlZXA6XFxuICAgICAgICAgICAgc3RhdGUgPSBkZWVwY29weShzdGF0ZSwgbWVtbylcXG4gICAgICAgIGlmIGhhc2F0dHIoeSwgJ19fc2V0c3RhdGVfXycpOlxcbiAgICAgICAgICAgIHkuX19zZXRzdGF0ZV9fKHN0YXRlKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBpc2luc3RhbmNlKHN0YXRlLCB0dXBsZSkgYW5kIGxlbihzdGF0ZSkgPT0gMjpcXG4gICAgICAgICAgICAgICAgc3RhdGUsIHNsb3RzdGF0ZSA9IHN0YXRlXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgc2xvdHN0YXRlID0gTm9uZVxcbiAgICAgICAgICAgIGlmIHN0YXRlIGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgICAgICB5Ll9fZGljdF9fLnVwZGF0ZShzdGF0ZSlcXG4gICAgICAgICAgICBpZiBzbG90c3RhdGUgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgICAgIGZvciBrZXksIHZhbHVlIGluIHNsb3RzdGF0ZS5pdGVtcygpOlxcbiAgICAgICAgICAgICAgICAgICAgc2V0YXR0cih5LCBrZXksIHZhbHVlKVxcblxcbiAgICBpZiBsaXN0aXRlciBpcyBub3QgTm9uZTpcXG4gICAgICAgIGZvciBpdGVtIGluIGxpc3RpdGVyOlxcbiAgICAgICAgICAgIGlmIGRlZXA6XFxuICAgICAgICAgICAgICAgIGl0ZW0gPSBkZWVwY29weShpdGVtLCBtZW1vKVxcbiAgICAgICAgICAgIHkuYXBwZW5kKGl0ZW0pXFxuICAgIGlmIGRpY3RpdGVyIGlzIG5vdCBOb25lOlxcbiAgICAgICAgZm9yIGtleSwgdmFsdWUgaW4gZGljdGl0ZXI6XFxuICAgICAgICAgICAgaWYgZGVlcDpcXG4gICAgICAgICAgICAgICAga2V5ID0gZGVlcGNvcHkoa2V5LCBtZW1vKVxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZXBjb3B5KHZhbHVlLCBtZW1vKVxcbiAgICAgICAgICAgIHlba2V5XSA9IHZhbHVlXFxuICAgIHJldHVybiB5XFxuXFxuZGVsIGRcXG5cXG5kZWwgdHlwZXNcXG5cXG4jIEhlbHBlciBmb3IgaW5zdGFuY2UgY3JlYXRpb24gd2l0aG91dCBjYWxsaW5nIF9faW5pdF9fXFxuY2xhc3MgX0VtcHR5Q2xhc3M6XFxuICAgIHBhc3NcIixcInNyYy9saWIvY29weV9yZWcucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY29weV9yZWdcXFwiKVxcblwiLFwic3JjL2xpYi9jc3YucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY3N2XFxcIilcXG5cIixcInNyYy9saWIvY3R5cGVzL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImN0eXBlc1xcXCIpXFxuXCIsXCJzcmMvbGliL2N0eXBlcy9tYWNob2xpYi9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtYWNob2xpYlxcXCIpXFxuXCIsXCJzcmMvbGliL2N1cnNlcy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjdXJzZXNcXFwiKVxcblwiLFwic3JjL2xpYi9kYmhhc2gucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZGJoYXNoXFxcIilcXG5cIixcInNyYy9saWIvZGVjaW1hbC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkZWNpbWFsXFxcIilcXG5cIixcInNyYy9saWIvZGlmZmxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkaWZmbGliXFxcIilcXG5cIixcInNyYy9saWIvZGlyY2FjaGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZGlyY2FjaGVcXFwiKVxcblwiLFwic3JjL2xpYi9kaXMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZGlzXFxcIilcXG5cIixcInNyYy9saWIvZGlzdHV0aWxzL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImRpc3R1dGlsc1xcXCIpXFxuXCIsXCJzcmMvbGliL2Rpc3R1dGlscy9jb21tYW5kL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvbW1hbmRcXFwiKVxcblwiLFwic3JjL2xpYi9kaXN0dXRpbHMvdGVzdHMvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidGVzdHNcXFwiKVxcblwiLFwic3JjL2xpYi9kb2N0ZXN0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImRvY3Rlc3RcXFwiKVxcblwiLFwic3JjL2xpYi9kdW1iZGJtLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImR1bWJkYm1cXFwiKVxcblwiLFwic3JjL2xpYi9kdW1teV90aHJlYWQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZHVtbXlfdGhyZWFkXFxcIilcXG5cIixcInNyYy9saWIvZHVtbXlfdGhyZWFkaW5nLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImR1bW15X3RocmVhZGluZ1xcXCIpXFxuXCIsXCJzcmMvbGliL2VtYWlsL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImVtYWlsXFxcIilcXG5cIixcInNyYy9saWIvZW1haWwvbWltZS9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtaW1lXFxcIilcXG5cIixcInNyYy9saWIvZW1haWwvdGVzdC9kYXRhL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImRhdGFcXFwiKVxcblwiLFwic3JjL2xpYi9lbmNvZGluZ3MvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZW5jb2RpbmdzXFxcIilcXG5cIixcInNyYy9saWIvZmlsZWNtcC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJmaWxlY21wXFxcIilcXG5cIixcInNyYy9saWIvZmlsZWlucHV0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImZpbGVpbnB1dFxcXCIpXFxuXCIsXCJzcmMvbGliL2ZubWF0Y2gucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZm5tYXRjaFxcXCIpXFxuXCIsXCJzcmMvbGliL2Zvcm1hdHRlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJmb3JtYXR0ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9mcGZvcm1hdC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJmcGZvcm1hdFxcXCIpXFxuXCIsXCJzcmMvbGliL2ZyYWN0aW9ucy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJmcmFjdGlvbnNcXFwiKVxcblwiLFwic3JjL2xpYi9mdHBsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZnRwbGliXFxcIilcXG5cIixcInNyYy9saWIvZ2VuZXJpY3BhdGgucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZ2VuZXJpY3BhdGhcXFwiKVxcblwiLFwic3JjL2xpYi9nZXRvcHQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZ2V0b3B0XFxcIilcXG5cIixcInNyYy9saWIvZ2V0cGFzcy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJnZXRwYXNzXFxcIilcXG5cIixcInNyYy9saWIvZ2V0dGV4dC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJnZXR0ZXh0XFxcIilcXG5cIixcInNyYy9saWIvZ2xvYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJnbG9iXFxcIilcXG5cIixcInNyYy9saWIvZ3ppcC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJnemlwXFxcIilcXG5cIixcInNyYy9saWIvaGFzaGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJoYXNobGliXFxcIilcXG5cIixcInNyYy9saWIvaGVhcHEucHlcIjpcIlxcXCJcXFwiXFxcIkhlYXAgcXVldWUgYWxnb3JpdGhtIChhLmsuYS4gcHJpb3JpdHkgcXVldWUpLlxcblxcbkhlYXBzIGFyZSBhcnJheXMgZm9yIHdoaWNoIGFba10gPD0gYVsyKmsrMV0gYW5kIGFba10gPD0gYVsyKmsrMl0gZm9yXFxuYWxsIGssIGNvdW50aW5nIGVsZW1lbnRzIGZyb20gMC4gIEZvciB0aGUgc2FrZSBvZiBjb21wYXJpc29uLFxcbm5vbi1leGlzdGluZyBlbGVtZW50cyBhcmUgY29uc2lkZXJlZCB0byBiZSBpbmZpbml0ZS4gIFRoZSBpbnRlcmVzdGluZ1xcbnByb3BlcnR5IG9mIGEgaGVhcCBpcyB0aGF0IGFbMF0gaXMgYWx3YXlzIGl0cyBzbWFsbGVzdCBlbGVtZW50LlxcblxcblVzYWdlOlxcblxcbmhlYXAgPSBbXSAgICAgICAgICAgICMgY3JlYXRlcyBhbiBlbXB0eSBoZWFwXFxuaGVhcHB1c2goaGVhcCwgaXRlbSkgIyBwdXNoZXMgYSBuZXcgaXRlbSBvbiB0aGUgaGVhcFxcbml0ZW0gPSBoZWFwcG9wKGhlYXApICMgcG9wcyB0aGUgc21hbGxlc3QgaXRlbSBmcm9tIHRoZSBoZWFwXFxuaXRlbSA9IGhlYXBbMF0gICAgICAgIyBzbWFsbGVzdCBpdGVtIG9uIHRoZSBoZWFwIHdpdGhvdXQgcG9wcGluZyBpdFxcbmhlYXBpZnkoeCkgICAgICAgICAgICMgdHJhbnNmb3JtcyBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gbGluZWFyIHRpbWVcXG5pdGVtID0gaGVhcHJlcGxhY2UoaGVhcCwgaXRlbSkgIyBwb3BzIGFuZCByZXR1cm5zIHNtYWxsZXN0IGl0ZW0sIGFuZCBhZGRzXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgbmV3IGl0ZW07IHRoZSBoZWFwIHNpemUgaXMgdW5jaGFuZ2VkXFxuXFxuT3VyIEFQSSBkaWZmZXJzIGZyb20gdGV4dGJvb2sgaGVhcCBhbGdvcml0aG1zIGFzIGZvbGxvd3M6XFxuXFxuLSBXZSB1c2UgMC1iYXNlZCBpbmRleGluZy4gIFRoaXMgbWFrZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZVxcbiAgaW5kZXggZm9yIGEgbm9kZSBhbmQgdGhlIGluZGV4ZXMgZm9yIGl0cyBjaGlsZHJlbiBzbGlnaHRseSBsZXNzXFxuICBvYnZpb3VzLCBidXQgaXMgbW9yZSBzdWl0YWJsZSBzaW5jZSBQeXRob24gdXNlcyAwLWJhc2VkIGluZGV4aW5nLlxcblxcbi0gT3VyIGhlYXBwb3AoKSBtZXRob2QgcmV0dXJucyB0aGUgc21hbGxlc3QgaXRlbSwgbm90IHRoZSBsYXJnZXN0LlxcblxcblRoZXNlIHR3byBtYWtlIGl0IHBvc3NpYmxlIHRvIHZpZXcgdGhlIGhlYXAgYXMgYSByZWd1bGFyIFB5dGhvbiBsaXN0XFxud2l0aG91dCBzdXJwcmlzZXM6IGhlYXBbMF0gaXMgdGhlIHNtYWxsZXN0IGl0ZW0sIGFuZCBoZWFwLnNvcnQoKVxcbm1haW50YWlucyB0aGUgaGVhcCBpbnZhcmlhbnQhXFxuXFxcIlxcXCJcXFwiXFxuXFxuIyBPcmlnaW5hbCBjb2RlIGJ5IEtldmluIE8nQ29ubm9yLCBhdWdtZW50ZWQgYnkgVGltIFBldGVycyBhbmQgUmF5bW9uZCBIZXR0aW5nZXJcXG5cXG5fX2Fib3V0X18gPSBcXFwiXFxcIlxcXCJIZWFwIHF1ZXVlc1xcblxcbltleHBsYW5hdGlvbiBieSBGcmFuw6dvaXMgUGluYXJkXVxcblxcbkhlYXBzIGFyZSBhcnJheXMgZm9yIHdoaWNoIGFba10gPD0gYVsyKmsrMV0gYW5kIGFba10gPD0gYVsyKmsrMl0gZm9yXFxuYWxsIGssIGNvdW50aW5nIGVsZW1lbnRzIGZyb20gMC4gIEZvciB0aGUgc2FrZSBvZiBjb21wYXJpc29uLFxcbm5vbi1leGlzdGluZyBlbGVtZW50cyBhcmUgY29uc2lkZXJlZCB0byBiZSBpbmZpbml0ZS4gIFRoZSBpbnRlcmVzdGluZ1xcbnByb3BlcnR5IG9mIGEgaGVhcCBpcyB0aGF0IGFbMF0gaXMgYWx3YXlzIGl0cyBzbWFsbGVzdCBlbGVtZW50LlxcblxcblRoZSBzdHJhbmdlIGludmFyaWFudCBhYm92ZSBpcyBtZWFudCB0byBiZSBhbiBlZmZpY2llbnQgbWVtb3J5XFxucmVwcmVzZW50YXRpb24gZm9yIGEgdG91cm5hbWVudC4gIFRoZSBudW1iZXJzIGJlbG93IGFyZSBgaycsIG5vdCBhW2tdOlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxcblxcbiAgICAgICAgICAgICAgICAgIDEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXFxuXFxuICAgICAgICAgIDMgICAgICAgICAgICAgICA0ICAgICAgICAgICAgICAgIDUgICAgICAgICAgICAgICA2XFxuXFxuICAgICAgNyAgICAgICA4ICAgICAgIDkgICAgICAgMTAgICAgICAxMSAgICAgIDEyICAgICAgMTMgICAgICAxNFxcblxcbiAgICAxNSAxNiAgIDE3IDE4ICAgMTkgMjAgICAyMSAyMiAgIDIzIDI0ICAgMjUgMjYgICAyNyAyOCAgIDI5IDMwXFxuXFxuXFxuSW4gdGhlIHRyZWUgYWJvdmUsIGVhY2ggY2VsbCBgaycgaXMgdG9wcGluZyBgMiprKzEnIGFuZCBgMiprKzInLiAgSW5cXG5hIHVzdWFsIGJpbmFyeSB0b3VybmFtZW50IHdlIHNlZSBpbiBzcG9ydHMsIGVhY2ggY2VsbCBpcyB0aGUgd2lubmVyXFxub3ZlciB0aGUgdHdvIGNlbGxzIGl0IHRvcHMsIGFuZCB3ZSBjYW4gdHJhY2UgdGhlIHdpbm5lciBkb3duIHRoZSB0cmVlXFxudG8gc2VlIGFsbCBvcHBvbmVudHMgcy9oZSBoYWQuICBIb3dldmVyLCBpbiBtYW55IGNvbXB1dGVyIGFwcGxpY2F0aW9uc1xcbm9mIHN1Y2ggdG91cm5hbWVudHMsIHdlIGRvIG5vdCBuZWVkIHRvIHRyYWNlIHRoZSBoaXN0b3J5IG9mIGEgd2lubmVyLlxcblRvIGJlIG1vcmUgbWVtb3J5IGVmZmljaWVudCwgd2hlbiBhIHdpbm5lciBpcyBwcm9tb3RlZCwgd2UgdHJ5IHRvXFxucmVwbGFjZSBpdCBieSBzb21ldGhpbmcgZWxzZSBhdCBhIGxvd2VyIGxldmVsLCBhbmQgdGhlIHJ1bGUgYmVjb21lc1xcbnRoYXQgYSBjZWxsIGFuZCB0aGUgdHdvIGNlbGxzIGl0IHRvcHMgY29udGFpbiB0aHJlZSBkaWZmZXJlbnQgaXRlbXMsXFxuYnV0IHRoZSB0b3AgY2VsbCBcXFwid2luc1xcXCIgb3ZlciB0aGUgdHdvIHRvcHBlZCBjZWxscy5cXG5cXG5JZiB0aGlzIGhlYXAgaW52YXJpYW50IGlzIHByb3RlY3RlZCBhdCBhbGwgdGltZSwgaW5kZXggMCBpcyBjbGVhcmx5XFxudGhlIG92ZXJhbGwgd2lubmVyLiAgVGhlIHNpbXBsZXN0IGFsZ29yaXRobWljIHdheSB0byByZW1vdmUgaXQgYW5kXFxuZmluZCB0aGUgXFxcIm5leHRcXFwiIHdpbm5lciBpcyB0byBtb3ZlIHNvbWUgbG9zZXIgKGxldCdzIHNheSBjZWxsIDMwIGluIHRoZVxcbmRpYWdyYW0gYWJvdmUpIGludG8gdGhlIDAgcG9zaXRpb24sIGFuZCB0aGVuIHBlcmNvbGF0ZSB0aGlzIG5ldyAwIGRvd25cXG50aGUgdHJlZSwgZXhjaGFuZ2luZyB2YWx1ZXMsIHVudGlsIHRoZSBpbnZhcmlhbnQgaXMgcmUtZXN0YWJsaXNoZWQuXFxuVGhpcyBpcyBjbGVhcmx5IGxvZ2FyaXRobWljIG9uIHRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRyZWUuXFxuQnkgaXRlcmF0aW5nIG92ZXIgYWxsIGl0ZW1zLCB5b3UgZ2V0IGFuIE8obiBsbiBuKSBzb3J0LlxcblxcbkEgbmljZSBmZWF0dXJlIG9mIHRoaXMgc29ydCBpcyB0aGF0IHlvdSBjYW4gZWZmaWNpZW50bHkgaW5zZXJ0IG5ld1xcbml0ZW1zIHdoaWxlIHRoZSBzb3J0IGlzIGdvaW5nIG9uLCBwcm92aWRlZCB0aGF0IHRoZSBpbnNlcnRlZCBpdGVtcyBhcmVcXG5ub3QgXFxcImJldHRlclxcXCIgdGhhbiB0aGUgbGFzdCAwJ3RoIGVsZW1lbnQgeW91IGV4dHJhY3RlZC4gIFRoaXMgaXNcXG5lc3BlY2lhbGx5IHVzZWZ1bCBpbiBzaW11bGF0aW9uIGNvbnRleHRzLCB3aGVyZSB0aGUgdHJlZSBob2xkcyBhbGxcXG5pbmNvbWluZyBldmVudHMsIGFuZCB0aGUgXFxcIndpblxcXCIgY29uZGl0aW9uIG1lYW5zIHRoZSBzbWFsbGVzdCBzY2hlZHVsZWRcXG50aW1lLiAgV2hlbiBhbiBldmVudCBzY2hlZHVsZSBvdGhlciBldmVudHMgZm9yIGV4ZWN1dGlvbiwgdGhleSBhcmVcXG5zY2hlZHVsZWQgaW50byB0aGUgZnV0dXJlLCBzbyB0aGV5IGNhbiBlYXNpbHkgZ28gaW50byB0aGUgaGVhcC4gIFNvLCBhXFxuaGVhcCBpcyBhIGdvb2Qgc3RydWN0dXJlIGZvciBpbXBsZW1lbnRpbmcgc2NoZWR1bGVycyAodGhpcyBpcyB3aGF0IElcXG51c2VkIGZvciBteSBNSURJIHNlcXVlbmNlciA6LSkuXFxuXFxuVmFyaW91cyBzdHJ1Y3R1cmVzIGZvciBpbXBsZW1lbnRpbmcgc2NoZWR1bGVycyBoYXZlIGJlZW4gZXh0ZW5zaXZlbHlcXG5zdHVkaWVkLCBhbmQgaGVhcHMgYXJlIGdvb2QgZm9yIHRoaXMsIGFzIHRoZXkgYXJlIHJlYXNvbmFibHkgc3BlZWR5LFxcbnRoZSBzcGVlZCBpcyBhbG1vc3QgY29uc3RhbnQsIGFuZCB0aGUgd29yc3QgY2FzZSBpcyBub3QgbXVjaCBkaWZmZXJlbnRcXG50aGFuIHRoZSBhdmVyYWdlIGNhc2UuICBIb3dldmVyLCB0aGVyZSBhcmUgb3RoZXIgcmVwcmVzZW50YXRpb25zIHdoaWNoXFxuYXJlIG1vcmUgZWZmaWNpZW50IG92ZXJhbGwsIHlldCB0aGUgd29yc3QgY2FzZXMgbWlnaHQgYmUgdGVycmlibGUuXFxuXFxuSGVhcHMgYXJlIGFsc28gdmVyeSB1c2VmdWwgaW4gYmlnIGRpc2sgc29ydHMuICBZb3UgbW9zdCBwcm9iYWJseSBhbGxcXG5rbm93IHRoYXQgYSBiaWcgc29ydCBpbXBsaWVzIHByb2R1Y2luZyBcXFwicnVuc1xcXCIgKHdoaWNoIGFyZSBwcmUtc29ydGVkXFxuc2VxdWVuY2VzLCB3aGljaCBzaXplIGlzIHVzdWFsbHkgcmVsYXRlZCB0byB0aGUgYW1vdW50IG9mIENQVSBtZW1vcnkpLFxcbmZvbGxvd2VkIGJ5IGEgbWVyZ2luZyBwYXNzZXMgZm9yIHRoZXNlIHJ1bnMsIHdoaWNoIG1lcmdpbmcgaXMgb2Z0ZW5cXG52ZXJ5IGNsZXZlcmx5IG9yZ2FuaXNlZFsxXS4gIEl0IGlzIHZlcnkgaW1wb3J0YW50IHRoYXQgdGhlIGluaXRpYWxcXG5zb3J0IHByb2R1Y2VzIHRoZSBsb25nZXN0IHJ1bnMgcG9zc2libGUuICBUb3VybmFtZW50cyBhcmUgYSBnb29kIHdheVxcbnRvIHRoYXQuICBJZiwgdXNpbmcgYWxsIHRoZSBtZW1vcnkgYXZhaWxhYmxlIHRvIGhvbGQgYSB0b3VybmFtZW50LCB5b3VcXG5yZXBsYWNlIGFuZCBwZXJjb2xhdGUgaXRlbXMgdGhhdCBoYXBwZW4gdG8gZml0IHRoZSBjdXJyZW50IHJ1biwgeW91J2xsXFxucHJvZHVjZSBydW5zIHdoaWNoIGFyZSB0d2ljZSB0aGUgc2l6ZSBvZiB0aGUgbWVtb3J5IGZvciByYW5kb20gaW5wdXQsXFxuYW5kIG11Y2ggYmV0dGVyIGZvciBpbnB1dCBmdXp6aWx5IG9yZGVyZWQuXFxuXFxuTW9yZW92ZXIsIGlmIHlvdSBvdXRwdXQgdGhlIDAndGggaXRlbSBvbiBkaXNrIGFuZCBnZXQgYW4gaW5wdXQgd2hpY2hcXG5tYXkgbm90IGZpdCBpbiB0aGUgY3VycmVudCB0b3VybmFtZW50IChiZWNhdXNlIHRoZSB2YWx1ZSBcXFwid2luc1xcXCIgb3ZlclxcbnRoZSBsYXN0IG91dHB1dCB2YWx1ZSksIGl0IGNhbm5vdCBmaXQgaW4gdGhlIGhlYXAsIHNvIHRoZSBzaXplIG9mIHRoZVxcbmhlYXAgZGVjcmVhc2VzLiAgVGhlIGZyZWVkIG1lbW9yeSBjb3VsZCBiZSBjbGV2ZXJseSByZXVzZWQgaW1tZWRpYXRlbHlcXG5mb3IgcHJvZ3Jlc3NpdmVseSBidWlsZGluZyBhIHNlY29uZCBoZWFwLCB3aGljaCBncm93cyBhdCBleGFjdGx5IHRoZVxcbnNhbWUgcmF0ZSB0aGUgZmlyc3QgaGVhcCBpcyBtZWx0aW5nLiAgV2hlbiB0aGUgZmlyc3QgaGVhcCBjb21wbGV0ZWx5XFxudmFuaXNoZXMsIHlvdSBzd2l0Y2ggaGVhcHMgYW5kIHN0YXJ0IGEgbmV3IHJ1bi4gIENsZXZlciBhbmQgcXVpdGVcXG5lZmZlY3RpdmUhXFxuXFxuSW4gYSB3b3JkLCBoZWFwcyBhcmUgdXNlZnVsIG1lbW9yeSBzdHJ1Y3R1cmVzIHRvIGtub3cuICBJIHVzZSB0aGVtIGluXFxuYSBmZXcgYXBwbGljYXRpb25zLCBhbmQgSSB0aGluayBpdCBpcyBnb29kIHRvIGtlZXAgYSBgaGVhcCcgbW9kdWxlXFxuYXJvdW5kLiA6LSlcXG5cXG4tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblsxXSBUaGUgZGlzayBiYWxhbmNpbmcgYWxnb3JpdGhtcyB3aGljaCBhcmUgY3VycmVudCwgbm93YWRheXMsIGFyZVxcbm1vcmUgYW5ub3lpbmcgdGhhbiBjbGV2ZXIsIGFuZCB0aGlzIGlzIGEgY29uc2VxdWVuY2Ugb2YgdGhlIHNlZWtpbmdcXG5jYXBhYmlsaXRpZXMgb2YgdGhlIGRpc2tzLiAgT24gZGV2aWNlcyB3aGljaCBjYW5ub3Qgc2VlaywgbGlrZSBiaWdcXG50YXBlIGRyaXZlcywgdGhlIHN0b3J5IHdhcyBxdWl0ZSBkaWZmZXJlbnQsIGFuZCBvbmUgaGFkIHRvIGJlIHZlcnlcXG5jbGV2ZXIgdG8gZW5zdXJlIChmYXIgaW4gYWR2YW5jZSkgdGhhdCBlYWNoIHRhcGUgbW92ZW1lbnQgd2lsbCBiZSB0aGVcXG5tb3N0IGVmZmVjdGl2ZSBwb3NzaWJsZSAodGhhdCBpcywgd2lsbCBiZXN0IHBhcnRpY2lwYXRlIGF0XFxuXFxcInByb2dyZXNzaW5nXFxcIiB0aGUgbWVyZ2UpLiAgU29tZSB0YXBlcyB3ZXJlIGV2ZW4gYWJsZSB0byByZWFkXFxuYmFja3dhcmRzLCBhbmQgdGhpcyB3YXMgYWxzbyB1c2VkIHRvIGF2b2lkIHRoZSByZXdpbmRpbmcgdGltZS5cXG5CZWxpZXZlIG1lLCByZWFsIGdvb2QgdGFwZSBzb3J0cyB3ZXJlIHF1aXRlIHNwZWN0YWN1bGFyIHRvIHdhdGNoIVxcbkZyb20gYWxsIHRpbWVzLCBzb3J0aW5nIGhhcyBhbHdheXMgYmVlbiBhIEdyZWF0IEFydCEgOi0pXFxuXFxcIlxcXCJcXFwiXFxuXFxuX19hbGxfXyA9IFsnaGVhcHB1c2gnLCAnaGVhcHBvcCcsICdoZWFwaWZ5JywgJ2hlYXByZXBsYWNlJyxcXG4gICAgICAgICAgICdubGFyZ2VzdCcsICduc21hbGxlc3QnLCAnaGVhcHB1c2hwb3AnXVxcblxcblxcbmRlZiBoZWFwcHVzaChoZWFwLCBpdGVtKTpcXG4gICAgXFxcIlxcXCJcXFwiUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxcXCJcXFwiXFxcIlxcbiAgICBoZWFwLmFwcGVuZChpdGVtKVxcbiAgICBfc2lmdGRvd24oaGVhcCwgMCwgbGVuKGhlYXApIC0gMSlcXG5cXG5cXG5kZWYgaGVhcHBvcChoZWFwKTpcXG4gICAgXFxcIlxcXCJcXFwiUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxcXCJcXFwiXFxcIlxcbiAgICBsYXN0ZWx0ID0gaGVhcC5wb3AoKSAgICAjIHJhaXNlcyBhcHByb3ByaWF0ZSBJbmRleEVycm9yIGlmIGhlYXAgaXMgZW1wdHlcXG4gICAgaWYgaGVhcDpcXG4gICAgICAgIHJldHVybml0ZW0gPSBoZWFwWzBdXFxuICAgICAgICBoZWFwWzBdID0gbGFzdGVsdFxcbiAgICAgICAgX3NpZnR1cChoZWFwLCAwKVxcbiAgICAgICAgcmV0dXJuIHJldHVybml0ZW1cXG4gICAgcmV0dXJuIGxhc3RlbHRcXG5cXG5cXG5kZWYgaGVhcHJlcGxhY2UoaGVhcCwgaXRlbSk6XFxuICAgIFxcXCJcXFwiXFxcIlBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cXG5cXG4gICAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXFxuICAgIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkLXNpemUgaGVhcC4gIE5vdGUgdGhhdCB0aGUgdmFsdWVcXG4gICAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hICBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2VzIG9mXFxuICAgIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XFxuXFxuICAgICAgICBpZiBpdGVtID4gaGVhcFswXTpcXG4gICAgICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoaGVhcCwgaXRlbSlcXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIHJldHVybml0ZW0gPSBoZWFwWzBdICAgICMgcmFpc2VzIGFwcHJvcHJpYXRlIEluZGV4RXJyb3IgaWYgaGVhcCBpcyBlbXB0eVxcbiAgICBoZWFwWzBdID0gaXRlbVxcbiAgICBfc2lmdHVwKGhlYXAsIDApXFxuICAgIHJldHVybiByZXR1cm5pdGVtXFxuXFxuXFxuZGVmIGhlYXBwdXNocG9wKGhlYXAsIGl0ZW0pOlxcbiAgICBcXFwiXFxcIlxcXCJGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXFxcIlxcXCJcXFwiXFxuICAgIGlmIGhlYXAgYW5kIGhlYXBbMF0gPCBpdGVtOlxcbiAgICAgICAgaXRlbSwgaGVhcFswXSA9IGhlYXBbMF0sIGl0ZW1cXG4gICAgICAgIF9zaWZ0dXAoaGVhcCwgMClcXG4gICAgcmV0dXJuIGl0ZW1cXG5cXG5cXG5kZWYgaGVhcGlmeSh4KTpcXG4gICAgXFxcIlxcXCJcXFwiVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGxlbih4KSkgdGltZS5cXFwiXFxcIlxcXCJcXG4gICAgbiA9IGxlbih4KVxcbiAgICAjIFRyYW5zZm9ybSBib3R0b20tdXAuICBUaGUgbGFyZ2VzdCBpbmRleCB0aGVyZSdzIGFueSBwb2ludCB0byBsb29raW5nIGF0XFxuICAgICMgaXMgdGhlIGxhcmdlc3Qgd2l0aCBhIGNoaWxkIGluZGV4IGluLXJhbmdlLCBzbyBtdXN0IGhhdmUgMippICsgMSA8IG4sXFxuICAgICMgb3IgaSA8IChuLTEpLzIuICBJZiBuIGlzIGV2ZW4gPSAyKmosIHRoaXMgaXMgKDIqai0xKS8yID0gai0xLzIgc29cXG4gICAgIyBqLTEgaXMgdGhlIGxhcmdlc3QsIHdoaWNoIGlzIG4vLzIgLSAxLiAgSWYgbiBpcyBvZGQgPSAyKmorMSwgdGhpcyBpc1xcbiAgICAjICgyKmorMS0xKS8yID0gaiBzbyBqLTEgaXMgdGhlIGxhcmdlc3QsIGFuZCB0aGF0J3MgYWdhaW4gbi8vMi0xLlxcbiAgICBmb3IgaSBpbiByZXZlcnNlZChyYW5nZShuIC8vIDIpKTpcXG4gICAgICAgIF9zaWZ0dXAoeCwgaSlcXG5cXG5cXG5kZWYgX2hlYXBwb3BfbWF4KGhlYXApOlxcbiAgICBcXFwiXFxcIlxcXCJNYXhoZWFwIHZlcnNpb24gb2YgYSBoZWFwcG9wLlxcXCJcXFwiXFxcIlxcbiAgICBsYXN0ZWx0ID0gaGVhcC5wb3AoKSAgICAjIHJhaXNlcyBhcHByb3ByaWF0ZSBJbmRleEVycm9yIGlmIGhlYXAgaXMgZW1wdHlcXG4gICAgaWYgaGVhcDpcXG4gICAgICAgIHJldHVybml0ZW0gPSBoZWFwWzBdXFxuICAgICAgICBoZWFwWzBdID0gbGFzdGVsdFxcbiAgICAgICAgX3NpZnR1cF9tYXgoaGVhcCwgMClcXG4gICAgICAgIHJldHVybiByZXR1cm5pdGVtXFxuICAgIHJldHVybiBsYXN0ZWx0XFxuXFxuXFxuZGVmIF9oZWFwcmVwbGFjZV9tYXgoaGVhcCwgaXRlbSk6XFxuICAgIFxcXCJcXFwiXFxcIk1heGhlYXAgdmVyc2lvbiBvZiBhIGhlYXBwb3AgZm9sbG93ZWQgYnkgYSBoZWFwcHVzaC5cXFwiXFxcIlxcXCJcXG4gICAgcmV0dXJuaXRlbSA9IGhlYXBbMF0gICAgIyByYWlzZXMgYXBwcm9wcmlhdGUgSW5kZXhFcnJvciBpZiBoZWFwIGlzIGVtcHR5XFxuICAgIGhlYXBbMF0gPSBpdGVtXFxuICAgIF9zaWZ0dXBfbWF4KGhlYXAsIDApXFxuICAgIHJldHVybiByZXR1cm5pdGVtXFxuXFxuXFxuZGVmIF9oZWFwaWZ5X21heCh4KTpcXG4gICAgXFxcIlxcXCJcXFwiVHJhbnNmb3JtIGxpc3QgaW50byBhIG1heGhlYXAsIGluLXBsYWNlLCBpbiBPKGxlbih4KSkgdGltZS5cXFwiXFxcIlxcXCJcXG4gICAgbiA9IGxlbih4KVxcbiAgICBmb3IgaSBpbiByZXZlcnNlZChyYW5nZShuIC8vIDIpKTpcXG4gICAgICAgIF9zaWZ0dXBfbWF4KHgsIGkpXFxuXFxuIyAnaGVhcCcgaXMgYSBoZWFwIGF0IGFsbCBpbmRpY2VzID49IHN0YXJ0cG9zLCBleGNlcHQgcG9zc2libHkgZm9yIHBvcy4gIHBvc1xcbiMgaXMgdGhlIGluZGV4IG9mIGEgbGVhZiB3aXRoIGEgcG9zc2libHkgb3V0LW9mLW9yZGVyIHZhbHVlLiAgUmVzdG9yZSB0aGVcXG4jIGhlYXAgaW52YXJpYW50LlxcblxcblxcbmRlZiBfc2lmdGRvd24oaGVhcCwgc3RhcnRwb3MsIHBvcyk6XFxuICAgIG5ld2l0ZW0gPSBoZWFwW3Bvc11cXG4gICAgIyBGb2xsb3cgdGhlIHBhdGggdG8gdGhlIHJvb3QsIG1vdmluZyBwYXJlbnRzIGRvd24gdW50aWwgZmluZGluZyBhIHBsYWNlXFxuICAgICMgbmV3aXRlbSBmaXRzLlxcbiAgICB3aGlsZSBwb3MgPiBzdGFydHBvczpcXG4gICAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxXFxuICAgICAgICBwYXJlbnQgPSBoZWFwW3BhcmVudHBvc11cXG4gICAgICAgIGlmIG5ld2l0ZW0gPCBwYXJlbnQ6XFxuICAgICAgICAgICAgaGVhcFtwb3NdID0gcGFyZW50XFxuICAgICAgICAgICAgcG9zID0gcGFyZW50cG9zXFxuICAgICAgICAgICAgY29udGludWVcXG4gICAgICAgIGJyZWFrXFxuICAgIGhlYXBbcG9zXSA9IG5ld2l0ZW1cXG5cXG4jIFRoZSBjaGlsZCBpbmRpY2VzIG9mIGhlYXAgaW5kZXggcG9zIGFyZSBhbHJlYWR5IGhlYXBzLCBhbmQgd2Ugd2FudCB0byBtYWtlXFxuIyBhIGhlYXAgYXQgaW5kZXggcG9zIHRvby4gIFdlIGRvIHRoaXMgYnkgYnViYmxpbmcgdGhlIHNtYWxsZXIgY2hpbGQgb2ZcXG4jIHBvcyB1cCAoYW5kIHNvIG9uIHdpdGggdGhhdCBjaGlsZCdzIGNoaWxkcmVuLCBldGMpIHVudGlsIGhpdHRpbmcgYSBsZWFmLFxcbiMgdGhlbiB1c2luZyBfc2lmdGRvd24gdG8gbW92ZSB0aGUgb2RkYmFsbCBvcmlnaW5hbGx5IGF0IGluZGV4IHBvcyBpbnRvIHBsYWNlLlxcbiNcXG4jIFdlICpjb3VsZCogYnJlYWsgb3V0IG9mIHRoZSBsb29wIGFzIHNvb24gYXMgd2UgZmluZCBhIHBvcyB3aGVyZSBuZXdpdGVtIDw9XFxuIyBib3RoIGl0cyBjaGlsZHJlbiwgYnV0IHR1cm5zIG91dCB0aGF0J3Mgbm90IGEgZ29vZCBpZGVhLCBhbmQgZGVzcGl0ZSB0aGF0XFxuIyBtYW55IGJvb2tzIHdyaXRlIHRoZSBhbGdvcml0aG0gdGhhdCB3YXkuICBEdXJpbmcgYSBoZWFwIHBvcCwgdGhlIGxhc3QgYXJyYXlcXG4jIGVsZW1lbnQgaXMgc2lmdGVkIGluLCBhbmQgdGhhdCB0ZW5kcyB0byBiZSBsYXJnZSwgc28gdGhhdCBjb21wYXJpbmcgaXRcXG4jIGFnYWluc3QgdmFsdWVzIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QgdXN1YWxseSBkb2Vzbid0IHBheSAoPSB1c3VhbGx5IGRvZXNuJ3RcXG4jIGdldCB1cyBvdXQgb2YgdGhlIGxvb3AgZWFybHkpLiAgU2VlIEtudXRoLCBWb2x1bWUgMywgd2hlcmUgdGhpcyBpc1xcbiMgZXhwbGFpbmVkIGFuZCBxdWFudGlmaWVkIGluIGFuIGV4ZXJjaXNlLlxcbiNcXG4jIEN1dHRpbmcgdGhlICMgb2YgY29tcGFyaXNvbnMgaXMgaW1wb3J0YW50LCBzaW5jZSB0aGVzZSByb3V0aW5lcyBoYXZlIG5vXFxuIyB3YXkgdG8gZXh0cmFjdCBcXFwidGhlIHByaW9yaXR5XFxcIiBmcm9tIGFuIGFycmF5IGVsZW1lbnQsIHNvIHRoYXQgaW50ZWxsaWdlbmNlXFxuIyBpcyBsaWtlbHkgdG8gYmUgaGlkaW5nIGluIGN1c3RvbSBjb21wYXJpc29uIG1ldGhvZHMsIG9yIGluIGFycmF5IGVsZW1lbnRzXFxuIyBzdG9yaW5nIChwcmlvcml0eSwgcmVjb3JkKSB0dXBsZXMuICBDb21wYXJpc29ucyBhcmUgdGh1cyBwb3RlbnRpYWxseVxcbiMgZXhwZW5zaXZlLlxcbiNcXG4jIE9uIHJhbmRvbSBhcnJheXMgb2YgbGVuZ3RoIDEwMDAsIG1ha2luZyB0aGlzIGNoYW5nZSBjdXQgdGhlIG51bWJlciBvZlxcbiMgY29tcGFyaXNvbnMgbWFkZSBieSBoZWFwaWZ5KCkgYSBsaXR0bGUsIGFuZCB0aG9zZSBtYWRlIGJ5IGV4aGF1c3RpdmVcXG4jIGhlYXBwb3AoKSBhIGxvdCwgaW4gYWNjb3JkIHdpdGggdGhlb3J5LiAgSGVyZSBhcmUgdHlwaWNhbCByZXN1bHRzIGZyb20gM1xcbiMgcnVucyAoMyBqdXN0IHRvIGRlbW9uc3RyYXRlIGhvdyBzbWFsbCB0aGUgdmFyaWFuY2UgaXMpOlxcbiNcXG4jIENvbXBhcmVzIG5lZWRlZCBieSBoZWFwaWZ5ICAgICBDb21wYXJlcyBuZWVkZWQgYnkgMTAwMCBoZWFwcG9wc1xcbiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuIyAxODM3IGN1dCB0byAxNjYzICAgICAgICAgICAgICAgMTQ5OTYgY3V0IHRvIDg2ODBcXG4jIDE4NTUgY3V0IHRvIDE2NTkgICAgICAgICAgICAgICAxNDk2NiBjdXQgdG8gODY3OFxcbiMgMTg0NyBjdXQgdG8gMTY2MCAgICAgICAgICAgICAgIDE1MDI0IGN1dCB0byA4NzAzXFxuI1xcbiMgQnVpbGRpbmcgdGhlIGhlYXAgYnkgdXNpbmcgaGVhcHB1c2goKSAxMDAwIHRpbWVzIGluc3RlYWQgcmVxdWlyZWRcXG4jIDIxOTgsIDIxNDgsIGFuZCAyMjE5IGNvbXBhcmVzOiAgaGVhcGlmeSgpIGlzIG1vcmUgZWZmaWNpZW50LCB3aGVuXFxuIyB5b3UgY2FuIHVzZSBpdC5cXG4jXFxuIyBUaGUgdG90YWwgY29tcGFyZXMgbmVlZGVkIGJ5IGxpc3Quc29ydCgpIG9uIHRoZSBzYW1lIGxpc3RzIHdlcmUgODYyNyxcXG4jIDg2MjcsIGFuZCA4NjMyICh0aGlzIHNob3VsZCBiZSBjb21wYXJlZCB0byB0aGUgc3VtIG9mIGhlYXBpZnkoKSBhbmRcXG4jIGhlYXBwb3AoKSBjb21wYXJlcyk6ICBsaXN0LnNvcnQoKSBpcyAodW5zdXJwcmlzaW5nbHkhKSBtb3JlIGVmZmljaWVudFxcbiMgZm9yIHNvcnRpbmcuXFxuXFxuXFxuZGVmIF9zaWZ0dXAoaGVhcCwgcG9zKTpcXG4gICAgZW5kcG9zID0gbGVuKGhlYXApXFxuICAgIHN0YXJ0cG9zID0gcG9zXFxuICAgIG5ld2l0ZW0gPSBoZWFwW3Bvc11cXG4gICAgIyBCdWJibGUgdXAgdGhlIHNtYWxsZXIgY2hpbGQgdW50aWwgaGl0dGluZyBhIGxlYWYuXFxuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDEgICAgIyBsZWZ0bW9zdCBjaGlsZCBwb3NpdGlvblxcbiAgICB3aGlsZSBjaGlsZHBvcyA8IGVuZHBvczpcXG4gICAgICAgICMgU2V0IGNoaWxkcG9zIHRvIGluZGV4IG9mIHNtYWxsZXIgY2hpbGQuXFxuICAgICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMVxcbiAgICAgICAgaWYgcmlnaHRwb3MgPCBlbmRwb3MgYW5kIG5vdCBoZWFwW2NoaWxkcG9zXSA8IGhlYXBbcmlnaHRwb3NdOlxcbiAgICAgICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3NcXG4gICAgICAgICMgTW92ZSB0aGUgc21hbGxlciBjaGlsZCB1cC5cXG4gICAgICAgIGhlYXBbcG9zXSA9IGhlYXBbY2hpbGRwb3NdXFxuICAgICAgICBwb3MgPSBjaGlsZHBvc1xcbiAgICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMVxcbiAgICAjIFRoZSBsZWFmIGF0IHBvcyBpcyBlbXB0eSBub3cuICBQdXQgbmV3aXRlbSB0aGVyZSwgYW5kIGJ1YmJsZSBpdCB1cFxcbiAgICAjIHRvIGl0cyBmaW5hbCByZXN0aW5nIHBsYWNlIChieSBzaWZ0aW5nIGl0cyBwYXJlbnRzIGRvd24pLlxcbiAgICBoZWFwW3Bvc10gPSBuZXdpdGVtXFxuICAgIF9zaWZ0ZG93bihoZWFwLCBzdGFydHBvcywgcG9zKVxcblxcblxcbmRlZiBfc2lmdGRvd25fbWF4KGhlYXAsIHN0YXJ0cG9zLCBwb3MpOlxcbiAgICAnTWF4aGVhcCB2YXJpYW50IG9mIF9zaWZ0ZG93bidcXG4gICAgbmV3aXRlbSA9IGhlYXBbcG9zXVxcbiAgICAjIEZvbGxvdyB0aGUgcGF0aCB0byB0aGUgcm9vdCwgbW92aW5nIHBhcmVudHMgZG93biB1bnRpbCBmaW5kaW5nIGEgcGxhY2VcXG4gICAgIyBuZXdpdGVtIGZpdHMuXFxuICAgIHdoaWxlIHBvcyA+IHN0YXJ0cG9zOlxcbiAgICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDFcXG4gICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50cG9zXVxcbiAgICAgICAgaWYgcGFyZW50IDwgbmV3aXRlbTpcXG4gICAgICAgICAgICBoZWFwW3Bvc10gPSBwYXJlbnRcXG4gICAgICAgICAgICBwb3MgPSBwYXJlbnRwb3NcXG4gICAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgYnJlYWtcXG4gICAgaGVhcFtwb3NdID0gbmV3aXRlbVxcblxcblxcbmRlZiBfc2lmdHVwX21heChoZWFwLCBwb3MpOlxcbiAgICAnTWF4aGVhcCB2YXJpYW50IG9mIF9zaWZ0dXAnXFxuICAgIGVuZHBvcyA9IGxlbihoZWFwKVxcbiAgICBzdGFydHBvcyA9IHBvc1xcbiAgICBuZXdpdGVtID0gaGVhcFtwb3NdXFxuICAgICMgQnViYmxlIHVwIHRoZSBsYXJnZXIgY2hpbGQgdW50aWwgaGl0dGluZyBhIGxlYWYuXFxuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDEgICAgIyBsZWZ0bW9zdCBjaGlsZCBwb3NpdGlvblxcbiAgICB3aGlsZSBjaGlsZHBvcyA8IGVuZHBvczpcXG4gICAgICAgICMgU2V0IGNoaWxkcG9zIHRvIGluZGV4IG9mIGxhcmdlciBjaGlsZC5cXG4gICAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxXFxuICAgICAgICBpZiByaWdodHBvcyA8IGVuZHBvcyBhbmQgbm90IGhlYXBbcmlnaHRwb3NdIDwgaGVhcFtjaGlsZHBvc106XFxuICAgICAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvc1xcbiAgICAgICAgIyBNb3ZlIHRoZSBsYXJnZXIgY2hpbGQgdXAuXFxuICAgICAgICBoZWFwW3Bvc10gPSBoZWFwW2NoaWxkcG9zXVxcbiAgICAgICAgcG9zID0gY2hpbGRwb3NcXG4gICAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDFcXG4gICAgIyBUaGUgbGVhZiBhdCBwb3MgaXMgZW1wdHkgbm93LiAgUHV0IG5ld2l0ZW0gdGhlcmUsIGFuZCBidWJibGUgaXQgdXBcXG4gICAgIyB0byBpdHMgZmluYWwgcmVzdGluZyBwbGFjZSAoYnkgc2lmdGluZyBpdHMgcGFyZW50cyBkb3duKS5cXG4gICAgaGVhcFtwb3NdID0gbmV3aXRlbVxcbiAgICBfc2lmdGRvd25fbWF4KGhlYXAsIHN0YXJ0cG9zLCBwb3MpXFxuXFxuXFxuIyBBbGdvcml0aG0gbm90ZXMgZm9yIG5sYXJnZXN0KCkgYW5kIG5zbWFsbGVzdCgpXFxuIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuI1xcbiMgTWFrZSBhIHNpbmdsZSBwYXNzIG92ZXIgdGhlIGRhdGEgd2hpbGUga2VlcGluZyB0aGUgayBtb3N0IGV4dHJlbWUgdmFsdWVzXFxuIyBpbiBhIGhlYXAuICBNZW1vcnkgY29uc3VtcHRpb24gaXMgbGltaXRlZCB0byBrZWVwaW5nIGsgdmFsdWVzIGluIGEgbGlzdC5cXG4jXFxuIyBNZWFzdXJlZCBwZXJmb3JtYW5jZSBmb3IgcmFuZG9tIGlucHV0czpcXG4jXFxuIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyIG9mIGNvbXBhcmlzb25zXFxuIyAgICBuIGlucHV0cyAgICAgay1leHRyZW1lIHZhbHVlcyAgKGF2ZXJhZ2Ugb2YgNSB0cmlhbHMpICAgJSBtb3JlIHRoYW4gbWluKClcXG4jIC0tLS0tLS0tLS0tLS0gICAtLS0tLS0tLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAtLS0tLS0tLS0tLS0tLS0tLVxcbiMgICAgICAxLDAwMCAgICAgICAgICAgMTAwICAgICAgICAgICAgICAgICAgMywzMTcgICAgICAgICAgICAgICAyMzEuNyVcXG4jICAgICAxMCwwMDAgICAgICAgICAgIDEwMCAgICAgICAgICAgICAgICAgMTQsMDQ2ICAgICAgICAgICAgICAgIDQwLjUlXFxuIyAgICAxMDAsMDAwICAgICAgICAgICAxMDAgICAgICAgICAgICAgICAgMTA1LDc0OSAgICAgICAgICAgICAgICAgNS43JVxcbiMgIDEsMDAwLDAwMCAgICAgICAgICAgMTAwICAgICAgICAgICAgICAxLDAwNyw3NTEgICAgICAgICAgICAgICAgIDAuOCVcXG4jIDEwLDAwMCwwMDAgICAgICAgICAgIDEwMCAgICAgICAgICAgICAxMCwwMDksNDAxICAgICAgICAgICAgICAgICAwLjElXFxuI1xcbiMgVGhlb3JldGljYWwgbnVtYmVyIG9mIGNvbXBhcmlzb25zIGZvciBrIHNtYWxsZXN0IG9mIG4gcmFuZG9tIGlucHV0czpcXG4jXFxuIyBTdGVwICAgQ29tcGFyaXNvbnMgICAgICAgICAgICAgICAgICBBY3Rpb25cXG4jIC0tLS0gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiMgIDEgICAgIDEuNjYgKiBrICAgICAgICAgICAgICAgICAgICAgaGVhcGlmeSB0aGUgZmlyc3Qgay1pbnB1dHNcXG4jICAyICAgICBuIC0gayAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgcmVtYWluaW5nIGVsZW1lbnRzIHRvIHRvcCBvZiBoZWFwXFxuIyAgMyAgICAgayAqICgxICsgbGcyKGspKSAqIGxuKG4vaykgICByZXBsYWNlIHRoZSB0b3Btb3N0IHZhbHVlIG9uIHRoZSBoZWFwXFxuIyAgNCAgICAgayAqIGxnMihrKSAtIChrLzIpICAgICAgICAgICBmaW5hbCBzb3J0IG9mIHRoZSBrIG1vc3QgZXh0cmVtZSB2YWx1ZXNcXG4jXFxuIyBDb21iaW5pbmcgYW5kIHNpbXBsaWZ5aW5nIGZvciBhIHJvdWdoIGVzdGltYXRlIGdpdmVzOlxcbiNcXG4jICAgICAgICBjb21wYXJpc29ucyA9IG4gKyBrICogKGxvZyhrLCAyKSAqIGxvZyhuL2spICsgbG9nKGssIDIpICsgbG9nKG4vaykpXFxuI1xcbiMgQ29tcHV0aW5nIHRoZSBudW1iZXIgb2YgY29tcGFyaXNvbnMgZm9yIHN0ZXAgMzpcXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuIyAqIEZvciB0aGUgaS10aCBuZXcgdmFsdWUgZnJvbSB0aGUgaXRlcmFibGUsIHRoZSBwcm9iYWJpbGl0eSBvZiBiZWluZyBpbiB0aGVcXG4jICAgayBtb3N0IGV4dHJlbWUgdmFsdWVzIGlzIGsvaS4gIEZvciBleGFtcGxlLCB0aGUgcHJvYmFiaWxpdHkgb2YgdGhlIDEwMXN0XFxuIyAgIHZhbHVlIHNlZW4gYmVpbmcgaW4gdGhlIDEwMCBtb3N0IGV4dHJlbWUgdmFsdWVzIGlzIDEwMC8xMDEuXFxuIyAqIElmIHRoZSB2YWx1ZSBpcyBhIG5ldyBleHRyZW1lIHZhbHVlLCB0aGUgY29zdCBvZiBpbnNlcnRpbmcgaXQgaW50byB0aGVcXG4jICAgaGVhcCBpcyAxICsgbG9nKGssIDIpLlxcbiMgKiBUaGUgcHJvYmFiaWxpdHkgdGltZXMgdGhlIGNvc3QgZ2l2ZXM6XFxuIyAgICAgICAgICAgIChrL2kpICogKDEgKyBsb2coaywgMikpXFxuIyAqIFN1bW1pbmcgYWNyb3NzIHRoZSByZW1haW5pbmcgbi1rIGVsZW1lbnRzIGdpdmVzOlxcbiMgICAgICAgICAgICBzdW0oKGsvaSkgKiAoMSArIGxvZyhrLCAyKSkgZm9yIGkgaW4gcmFuZ2UoaysxLCBuKzEpKVxcbiMgKiBUaGlzIHJlZHVjZXMgdG86XFxuIyAgICAgICAgICAgIChIKG4pIC0gSChrKSkgKiBrICogKDEgKyBsb2coaywgMikpXFxuIyAqIFdoZXJlIEgobikgaXMgdGhlIG4tdGggaGFybW9uaWMgbnVtYmVyIGVzdGltYXRlZCBieTpcXG4jICAgICAgICAgICAgZ2FtbWEgPSAwLjU3NzIxNTY2NDlcXG4jICAgICAgICAgICAgSChuKSA9IGxvZyhuLCBlKSArIGdhbW1hICsgMSAvICgyICogbilcXG4jICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXJtb25pY19zZXJpZXNfKG1hdGhlbWF0aWNzKSNSYXRlX29mX2RpdmVyZ2VuY2VcXG4jICogU3Vic3RpdHV0aW5nIHRoZSBIKG4pIGZvcm11bGE6XFxuIyAgICAgICAgICAgIGNvbXBhcmlzb25zID0gayAqICgxICsgbG9nKGssIDIpKSAqIChsb2cobi9rLCBlKSArICgxL24gLSAxL2spIC8gMilcXG4jXFxuIyBXb3JzdC1jYXNlIGZvciBzdGVwIDM6XFxuIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuIyBJbiB0aGUgd29yc3QgY2FzZSwgdGhlIGlucHV0IGRhdGEgaXMgcmV2ZXJzZWQgc29ydGVkIHNvIHRoYXQgZXZlcnkgbmV3IGVsZW1lbnRcXG4jIG11c3QgYmUgaW5zZXJ0ZWQgaW4gdGhlIGhlYXA6XFxuI1xcbiMgICAgICAgICAgICAgY29tcGFyaXNvbnMgPSAxLjY2ICogayArIGxvZyhrLCAyKSAqIChuIC0gaylcXG4jXFxuIyBBbHRlcm5hdGl2ZSBBbGdvcml0aG1zXFxuIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuIyBPdGhlciBhbGdvcml0aG1zIHdlcmUgbm90IHVzZWQgYmVjYXVzZSB0aGV5OlxcbiMgMSkgVG9vayBtdWNoIG1vcmUgYXV4aWxpYXJ5IG1lbW9yeSxcXG4jIDIpIE1hZGUgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGRhdGEuXFxuIyAzKSBNYWRlIG1vcmUgY29tcGFyaXNvbnMgaW4gY29tbW9uIGNhc2VzIChzbWFsbCBrLCBsYXJnZSBuLCBzZW1pLXJhbmRvbSBpbnB1dCkuXFxuIyBTZWUgdGhlIG1vcmUgZGV0YWlsZWQgY29tcGFyaXNvbiBvZiBhcHByb2FjaCBhdDpcXG4jIGh0dHA6Ly9jb2RlLmFjdGl2ZXN0YXRlLmNvbS9yZWNpcGVzLzU3NzU3My1jb21wYXJlLWFsZ29yaXRobXMtZm9yLWhlYXBxc21hbGxlc3RcXG5cXG5kZWYgbnNtYWxsZXN0KG4sIGl0ZXJhYmxlLCBrZXk9Tm9uZSk6XFxuICAgIFxcXCJcXFwiXFxcIkZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxcblxcbiAgICBFcXVpdmFsZW50IHRvOiAgc29ydGVkKGl0ZXJhYmxlLCBrZXk9a2V5KVs6bl1cXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgICMgU2hvcnQtY3V0IGZvciBuPT0xIGlzIHRvIHVzZSBtaW4oKVxcbiAgICBpZiBuID09IDE6XFxuICAgICAgICBpdCA9IGl0ZXIoaXRlcmFibGUpXFxuICAgICAgICBzZW50aW5lbCA9IG9iamVjdCgpXFxuICAgICAgICByZXN1bHQgPSBtaW4oaXQsIGRlZmF1bHQ9c2VudGluZWwsIGtleT1rZXkpXFxuICAgICAgICByZXR1cm4gW10gaWYgcmVzdWx0IGlzIHNlbnRpbmVsIGVsc2UgW3Jlc3VsdF1cXG5cXG4gICAgIyBXaGVuIG4+PXNpemUsIGl0J3MgZmFzdGVyIHRvIHVzZSBzb3J0ZWQoKVxcbiAgICB0cnk6XFxuICAgICAgICBzaXplID0gbGVuKGl0ZXJhYmxlKVxcbiAgICBleGNlcHQgKFR5cGVFcnJvciwgQXR0cmlidXRlRXJyb3IpOlxcbiAgICAgICAgcGFzc1xcbiAgICBlbHNlOlxcbiAgICAgICAgaWYgbiA+PSBzaXplOlxcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWQoaXRlcmFibGUsIGtleT1rZXkpWzpuXVxcblxcbiAgICAjIFdoZW4ga2V5IGlzIG5vbmUsIHVzZSBzaW1wbGVyIGRlY29yYXRpb25cXG4gICAgaWYga2V5IGlzIE5vbmU6XFxuICAgICAgICBpdCA9IGl0ZXIoaXRlcmFibGUpXFxuICAgICAgICAjIHB1dCB0aGUgcmFuZ2UobikgZmlyc3Qgc28gdGhhdCB6aXAoKSBkb2Vzbid0XFxuICAgICAgICAjIGNvbnN1bWUgb25lIHRvbyBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGl0ZXJhdG9yXFxuICAgICAgICByZXN1bHQgPSBbKGVsZW0sIGkpIGZvciBpLCBlbGVtIGluIHppcChyYW5nZShuKSwgaXQpXVxcbiAgICAgICAgaWYgbm90IHJlc3VsdDpcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgICAgICBfaGVhcGlmeV9tYXgocmVzdWx0KVxcbiAgICAgICAgdG9wID0gcmVzdWx0WzBdWzBdXFxuICAgICAgICBvcmRlciA9IG5cXG4gICAgICAgIF9oZWFwcmVwbGFjZSA9IF9oZWFwcmVwbGFjZV9tYXhcXG4gICAgICAgIGZvciBlbGVtIGluIGl0OlxcbiAgICAgICAgICAgIGlmIGVsZW0gPCB0b3A6XFxuICAgICAgICAgICAgICAgIF9oZWFwcmVwbGFjZShyZXN1bHQsIChlbGVtLCBvcmRlcikpXFxuICAgICAgICAgICAgICAgIHRvcCwgX29yZGVyID0gcmVzdWx0WzBdXFxuICAgICAgICAgICAgICAgIG9yZGVyICs9IDFcXG4gICAgICAgIHJlc3VsdC5zb3J0KClcXG4gICAgICAgIHJldHVybiBbZWxlbSBmb3IgKGVsZW0sIG9yZGVyKSBpbiByZXN1bHRdXFxuXFxuICAgICMgR2VuZXJhbCBjYXNlLCBzbG93ZXN0IG1ldGhvZFxcbiAgICBpdCA9IGl0ZXIoaXRlcmFibGUpXFxuICAgIHJlc3VsdCA9IFsoa2V5KGVsZW0pLCBpLCBlbGVtKSBmb3IgaSwgZWxlbSBpbiB6aXAocmFuZ2UobiksIGl0KV1cXG4gICAgaWYgbm90IHJlc3VsdDpcXG4gICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgX2hlYXBpZnlfbWF4KHJlc3VsdClcXG4gICAgdG9wID0gcmVzdWx0WzBdWzBdXFxuICAgIG9yZGVyID0gblxcbiAgICBfaGVhcHJlcGxhY2UgPSBfaGVhcHJlcGxhY2VfbWF4XFxuICAgIGZvciBlbGVtIGluIGl0OlxcbiAgICAgICAgayA9IGtleShlbGVtKVxcbiAgICAgICAgaWYgayA8IHRvcDpcXG4gICAgICAgICAgICBfaGVhcHJlcGxhY2UocmVzdWx0LCAoaywgb3JkZXIsIGVsZW0pKVxcbiAgICAgICAgICAgIHRvcCwgX29yZGVyLCBfZWxlbSA9IHJlc3VsdFswXVxcbiAgICAgICAgICAgIG9yZGVyICs9IDFcXG4gICAgcmVzdWx0LnNvcnQoKVxcbiAgICByZXR1cm4gW2VsZW0gZm9yIChrLCBvcmRlciwgZWxlbSkgaW4gcmVzdWx0XVxcblxcblxcbmRlZiBubGFyZ2VzdChuLCBpdGVyYWJsZSwga2V5PU5vbmUpOlxcbiAgICBcXFwiXFxcIlxcXCJGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxcblxcbiAgICBFcXVpdmFsZW50IHRvOiAgc29ydGVkKGl0ZXJhYmxlLCBrZXk9a2V5LCByZXZlcnNlPVRydWUpWzpuXVxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgIyBTaG9ydC1jdXQgZm9yIG49PTEgaXMgdG8gdXNlIG1heCgpXFxuICAgIGlmIG4gPT0gMTpcXG4gICAgICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgICAgIHNlbnRpbmVsID0gb2JqZWN0KClcXG4gICAgICAgIHJlc3VsdCA9IG1heChpdCwgZGVmYXVsdD1zZW50aW5lbCwga2V5PWtleSlcXG4gICAgICAgIHJldHVybiBbXSBpZiByZXN1bHQgaXMgc2VudGluZWwgZWxzZSBbcmVzdWx0XVxcblxcbiAgICAjIFdoZW4gbj49c2l6ZSwgaXQncyBmYXN0ZXIgdG8gdXNlIHNvcnRlZCgpXFxuICAgIHRyeTpcXG4gICAgICAgIHNpemUgPSBsZW4oaXRlcmFibGUpXFxuICAgIGV4Y2VwdCAoVHlwZUVycm9yLCBBdHRyaWJ1dGVFcnJvcik6XFxuICAgICAgICBwYXNzXFxuICAgIGVsc2U6XFxuICAgICAgICBpZiBuID49IHNpemU6XFxuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZChpdGVyYWJsZSwga2V5PWtleSwgcmV2ZXJzZT1UcnVlKVs6bl1cXG5cXG4gICAgIyBXaGVuIGtleSBpcyBub25lLCB1c2Ugc2ltcGxlciBkZWNvcmF0aW9uXFxuICAgIGlmIGtleSBpcyBOb25lOlxcbiAgICAgICAgaXQgPSBpdGVyKGl0ZXJhYmxlKVxcbiAgICAgICAgcmVzdWx0ID0gWyhlbGVtLCBpKSBmb3IgaSwgZWxlbSBpbiB6aXAocmFuZ2UoMCwgLW4sIC0xKSwgaXQpXVxcbiAgICAgICAgaWYgbm90IHJlc3VsdDpcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgICAgICBoZWFwaWZ5KHJlc3VsdClcXG4gICAgICAgIHRvcCA9IHJlc3VsdFswXVswXVxcbiAgICAgICAgb3JkZXIgPSAtblxcbiAgICAgICAgX2hlYXByZXBsYWNlID0gaGVhcHJlcGxhY2VcXG4gICAgICAgIGZvciBlbGVtIGluIGl0OlxcbiAgICAgICAgICAgIGlmIHRvcCA8IGVsZW06XFxuICAgICAgICAgICAgICAgIF9oZWFwcmVwbGFjZShyZXN1bHQsIChlbGVtLCBvcmRlcikpXFxuICAgICAgICAgICAgICAgIHRvcCwgX29yZGVyID0gcmVzdWx0WzBdXFxuICAgICAgICAgICAgICAgIG9yZGVyIC09IDFcXG4gICAgICAgIHJlc3VsdC5zb3J0KHJldmVyc2U9VHJ1ZSlcXG4gICAgICAgIHJldHVybiBbZWxlbSBmb3IgKGVsZW0sIG9yZGVyKSBpbiByZXN1bHRdXFxuXFxuICAgICMgR2VuZXJhbCBjYXNlLCBzbG93ZXN0IG1ldGhvZFxcbiAgICBpdCA9IGl0ZXIoaXRlcmFibGUpXFxuICAgIHJlc3VsdCA9IFsoa2V5KGVsZW0pLCBpLCBlbGVtKSBmb3IgaSwgZWxlbSBpbiB6aXAocmFuZ2UoMCwgLW4sIC0xKSwgaXQpXVxcbiAgICBpZiBub3QgcmVzdWx0OlxcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICBoZWFwaWZ5KHJlc3VsdClcXG4gICAgdG9wID0gcmVzdWx0WzBdWzBdXFxuICAgIG9yZGVyID0gLW5cXG4gICAgX2hlYXByZXBsYWNlID0gaGVhcHJlcGxhY2VcXG4gICAgZm9yIGVsZW0gaW4gaXQ6XFxuICAgICAgICBrID0ga2V5KGVsZW0pXFxuICAgICAgICBpZiB0b3AgPCBrOlxcbiAgICAgICAgICAgIF9oZWFwcmVwbGFjZShyZXN1bHQsIChrLCBvcmRlciwgZWxlbSkpXFxuICAgICAgICAgICAgdG9wLCBfb3JkZXIsIF9lbGVtID0gcmVzdWx0WzBdXFxuICAgICAgICAgICAgb3JkZXIgLT0gMVxcbiAgICByZXN1bHQuc29ydChyZXZlcnNlPVRydWUpXFxuICAgIHJldHVybiBbZWxlbSBmb3IgKGssIG9yZGVyLCBlbGVtKSBpbiByZXN1bHRdXFxuXFxuXFxuIyBJZiBhdmFpbGFibGUsIHVzZSBDIGltcGxlbWVudGF0aW9uXFxudHJ5OlxcbiAgICBmcm9tIF9oZWFwcSBpbXBvcnQgKlxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcbnRyeTpcXG4gICAgZnJvbSBfaGVhcHEgaW1wb3J0IF9oZWFwcmVwbGFjZV9tYXhcXG5leGNlcHQgSW1wb3J0RXJyb3I6XFxuICAgIHBhc3NcXG50cnk6XFxuICAgIGZyb20gX2hlYXBxIGltcG9ydCBfaGVhcGlmeV9tYXhcXG5leGNlcHQgSW1wb3J0RXJyb3I6XFxuICAgIHBhc3NcXG50cnk6XFxuICAgIGZyb20gX2hlYXBxIGltcG9ydCBfaGVhcHBvcF9tYXhcXG5leGNlcHQgSW1wb3J0RXJyb3I6XFxuICAgIHBhc3NcXG5cXG5cXG5pZiBfX25hbWVfXyA9PSBcXFwiX19tYWluX19cXFwiOlxcblxcbiAgICBpbXBvcnQgZG9jdGVzdCAgIyBwcmFnbWE6IG5vIGNvdmVyXFxuICAgIHByaW50KGRvY3Rlc3QudGVzdG1vZCgpKSAgIyBwcmFnbWE6IG5vIGNvdmVyXFxuXCIsXCJzcmMvbGliL2htYWMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiaG1hY1xcXCIpXFxuXCIsXCJzcmMvbGliL2hvdHNob3QvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiaG90c2hvdFxcXCIpXFxuXCIsXCJzcmMvbGliL2h0bWxlbnRpdHlkZWZzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImh0bWxlbnRpdHlkZWZzXFxcIilcXG5cIixcInNyYy9saWIvaHRtbGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJodG1sbGliXFxcIilcXG5cIixcInNyYy9saWIvaHR0cGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJodHRwbGliXFxcIilcXG5cIixcInNyYy9saWIvaWRsZWxpYi9JY29ucy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJJY29uc1xcXCIpXFxuXCIsXCJzcmMvbGliL2lkbGVsaWIvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiaWRsZWxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL2lob29rcy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJpaG9va3NcXFwiKVxcblwiLFwic3JjL2xpYi9pbWFwbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImltYXBsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9pbWdoZHIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiaW1naGRyXFxcIilcXG5cIixcInNyYy9saWIvaW1wdXRpbC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJpbXB1dGlsXFxcIilcXG5cIixcInNyYy9saWIvaW8ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiaW9cXFwiKVxcblwiLFwic3JjL2xpYi9qc29uL3Rlc3RzL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRlc3RzXFxcIilcXG5cIixcInNyYy9saWIvbGliLWR5bmxvYWQvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibGliLWR5bmxvYWRcXFwiKVxcblwiLFwic3JjL2xpYi9saWItdGsvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibGliLXRrXFxcIilcXG5cIixcInNyYy9saWIvbGliMnRvMy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJsaWIydG8zXFxcIilcXG5cIixcInNyYy9saWIvbGliMnRvMy9maXhlcy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJmaXhlc1xcXCIpXFxuXCIsXCJzcmMvbGliL2xpYjJ0bzMvcGdlbjIvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicGdlbjJcXFwiKVxcblwiLFwic3JjL2xpYi9saWIydG8zL3Rlc3RzL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRlc3RzXFxcIilcXG5cIixcInNyYy9saWIvbGluZWNhY2hlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImxpbmVjYWNoZVxcXCIpXFxuXCIsXCJzcmMvbGliL2xvY2FsZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJsb2NhbGVcXFwiKVxcblwiLFwic3JjL2xpYi9sb2dnaW5nL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImxvZ2dpbmdcXFwiKVxcblwiLFwic3JjL2xpYi9tYWNwYXRoLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1hY3BhdGhcXFwiKVxcblwiLFwic3JjL2xpYi9tYWN1cmwycGF0aC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtYWN1cmwycGF0aFxcXCIpXFxuXCIsXCJzcmMvbGliL21haWxib3gucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWFpbGJveFxcXCIpXFxuXCIsXCJzcmMvbGliL21haWxjYXAucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWFpbGNhcFxcXCIpXFxuXCIsXCJzcmMvbGliL21hcmt1cGJhc2UucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWFya3VwYmFzZVxcXCIpXFxuXCIsXCJzcmMvbGliL21kNS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtZDVcXFwiKVxcblwiLFwic3JjL2xpYi9taGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtaGxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL21pbWV0b29scy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtaW1ldG9vbHNcXFwiKVxcblwiLFwic3JjL2xpYi9taW1ldHlwZXMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWltZXR5cGVzXFxcIilcXG5cIixcInNyYy9saWIvbWltaWZ5LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1pbWlmeVxcXCIpXFxuXCIsXCJzcmMvbGliL21vZHVsZWZpbmRlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtb2R1bGVmaW5kZXJcXFwiKVxcblwiLFwic3JjL2xpYi9tdWx0aWZpbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibXVsdGlmaWxlXFxcIilcXG5cIixcInNyYy9saWIvbXVsdGlwcm9jZXNzaW5nL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm11bHRpcHJvY2Vzc2luZ1xcXCIpXFxuXCIsXCJzcmMvbGliL211bHRpcHJvY2Vzc2luZy9kdW1teS9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkdW1teVxcXCIpXFxuXCIsXCJzcmMvbGliL211dGV4LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm11dGV4XFxcIilcXG5cIixcInNyYy9saWIvbmV0cmMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibmV0cmNcXFwiKVxcblwiLFwic3JjL2xpYi9uZXcucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibmV3XFxcIilcXG5cIixcInNyYy9saWIvbm50cGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJubnRwbGliXFxcIilcXG5cIixcInNyYy9saWIvbnRwYXRoLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm50cGF0aFxcXCIpXFxuXCIsXCJzcmMvbGliL250dXJsMnBhdGgucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibnR1cmwycGF0aFxcXCIpXFxuXCIsXCJzcmMvbGliL251bWJlcnMucHlcIjpcIk51bWJlciA9IChpbnQsIGZsb2F0LCBjb21wbGV4KVxcbkludGVncmFsID0gaW50XFxuQ29tcGxleCA9IGNvbXBsZXhcXG5cIixcInNyYy9saWIvb3Bjb2RlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm9wY29kZVxcXCIpXFxuXCIsXCJzcmMvbGliL29wdHBhcnNlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm9wdHBhcnNlXFxcIilcXG5cIixcInNyYy9saWIvb3MucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwib3NcXFwiKVxcblwiLFwic3JjL2xpYi9vczJlbXhwYXRoLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm9zMmVteHBhdGhcXFwiKVxcblwiLFwic3JjL2xpYi9wZGIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicGRiXFxcIilcXG5cIixcInNyYy9saWIvcGlja2xlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBpY2tsZVxcXCIpXFxuXCIsXCJzcmMvbGliL3BpY2tsZXRvb2xzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBpY2tsZXRvb2xzXFxcIilcXG5cIixcInNyYy9saWIvcGlwZXMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicGlwZXNcXFwiKVxcblwiLFwic3JjL2xpYi9wa2d1dGlsLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBrZ3V0aWxcXFwiKVxcblwiLFwic3JjL2xpYi9wbGF0Zm9ybS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwbGF0Zm9ybVxcXCIpXFxuXCIsXCJzcmMvbGliL3BsaXN0bGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBsaXN0bGliXFxcIilcXG5cIixcInNyYy9saWIvcG9wZW4yLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBvcGVuMlxcXCIpXFxuXCIsXCJzcmMvbGliL3BvcGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwb3BsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9wb3NpeGZpbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicG9zaXhmaWxlXFxcIilcXG5cIixcInNyYy9saWIvcG9zaXhwYXRoLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBvc2l4cGF0aFxcXCIpXFxuXCIsXCJzcmMvbGliL3BwcmludC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwcHJpbnRcXFwiKVxcblwiLFwic3JjL2xpYi9wcm9maWxlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInByb2ZpbGVcXFwiKVxcblwiLFwic3JjL2xpYi9wc3RhdHMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicHN0YXRzXFxcIilcXG5cIixcInNyYy9saWIvcHR5LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInB0eVxcXCIpXFxuXCIsXCJzcmMvbGliL3B5X2NvbXBpbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicHlfY29tcGlsZVxcXCIpXFxuXCIsXCJzcmMvbGliL3B5Y2xici5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJweWNsYnJcXFwiKVxcblwiLFwic3JjL2xpYi9weWRvYy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJweWRvY1xcXCIpXFxuXCIsXCJzcmMvbGliL3B5ZG9jX3RvcGljcy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJweWRvY190b3BpY3NcXFwiKVxcblwiLFwic3JjL2xpYi9weXRob25kcy9fX2luaXRfXy5weVwiOlwiXCIsXCJzcmMvbGliL3B5dGhvbmRzL2Jhc2ljL19faW5pdF9fLnB5XCI6XCJcXG4jX19hbGxfXyA9IFtcXFwic3RhY2tcXFwiXVxcblxcblxcbmZyb20gLnN0YWNrIGltcG9ydCBTdGFja1xcbmZyb20gLnF1ZXVlIGltcG9ydCBRdWV1ZVxcbmZyb20gLmRlcXVlIGltcG9ydCBEZXF1ZVxcblxcblxcblwiLFwic3JjL2xpYi9weXRob25kcy9iYXNpYy9kZXF1ZS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiNcXG4jIGRlcXVlLnB5XFxuXFxuXFxuY2xhc3MgRGVxdWU6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNFbXB0eShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zID09IFtdXFxuXFxuICAgIGRlZiBhZGRGcm9udChzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuYXBwZW5kKGl0ZW0pXFxuXFxuICAgIGRlZiBhZGRSZWFyKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgc2VsZi5pdGVtcy5pbnNlcnQoMCwgaXRlbSlcXG5cXG4gICAgZGVmIHJlbW92ZUZyb250KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHJlbW92ZVJlYXIoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcy5wb3AoMClcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuaXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL2Jhc2ljL3F1ZXVlLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgSW50cm9kdWN0aW9uIHRvIERhdGEgU3RydWN0dXJlcyBhbmQgQWxnb3JpdGhtcyBpbiBQeXRob25cXG4jIENvcHlyaWdodCAyMDA1XFxuI1xcbiMgcXVldWUucHlcXG5cXG5cXG5jbGFzcyBRdWV1ZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBpc0VtcHR5KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMgPT0gW11cXG5cXG4gICAgZGVmIGVucXVldWUoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmluc2VydCgwLCBpdGVtKVxcblxcbiAgICBkZWYgZGVxdWV1ZShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25kcy9iYXNpYy9zdGFjay5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiNcXG4jIHN0YWNrLnB5XFxuXFxuXFxuY2xhc3MgU3RhY2s6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNFbXB0eShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zID09IFtdXFxuXFxuICAgIGRlZiBwdXNoKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgc2VsZi5pdGVtcy5hcHBlbmQoaXRlbSlcXG5cXG4gICAgZGVmIHBvcChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiBwZWVrKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXNbbGVuKHNlbGYuaXRlbXMpIC0gMV1cXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuaXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL2dyYXBocy9fX2luaXRfXy5weVwiOlwiXFxuXFxuZnJvbSAuYWRqR3JhcGggaW1wb3J0IEdyYXBoXFxuZnJvbSAuYWRqR3JhcGggaW1wb3J0IFZlcnRleFxcbmZyb20gLnByaW9yaXR5UXVldWUgaW1wb3J0IFByaW9yaXR5UXVldWVcXG5cIixcInNyYy9saWIvcHl0aG9uZHMvZ3JhcGhzL2FkakdyYXBoLnB5XCI6XCIjXFxuIyAgYWRqR3JhcGhcXG4jXFxuIyAgQ3JlYXRlZCBieSBCcmFkIE1pbGxlciBvbiAyMDA1LTAyLTI0LlxcbiMgIENvcHlyaWdodCAoYykgMjAwNSBCcmFkIE1pbGxlciwgRGF2aWQgUmFudW0sIEx1dGhlciBDb2xsZWdlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiNcXG5cXG5pbXBvcnQgc3lzXFxuaW1wb3J0IG9zXFxuaW1wb3J0IHVuaXR0ZXN0XFxuXFxuY2xhc3MgR3JhcGg6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYudmVydGljZXMgPSB7fVxcbiAgICAgICAgc2VsZi5udW1WZXJ0aWNlcyA9IDBcXG4gICAgICAgIFxcbiAgICBkZWYgYWRkVmVydGV4KHNlbGYsa2V5KTpcXG4gICAgICAgIHNlbGYubnVtVmVydGljZXMgPSBzZWxmLm51bVZlcnRpY2VzICsgMVxcbiAgICAgICAgbmV3VmVydGV4ID0gVmVydGV4KGtleSlcXG4gICAgICAgIHNlbGYudmVydGljZXNba2V5XSA9IG5ld1ZlcnRleFxcbiAgICAgICAgcmV0dXJuIG5ld1ZlcnRleFxcbiAgICBcXG4gICAgZGVmIGdldFZlcnRleChzZWxmLG4pOlxcbiAgICAgICAgaWYgbiBpbiBzZWxmLnZlcnRpY2VzOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnZlcnRpY2VzW25dXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixuKTpcXG4gICAgICAgIHJldHVybiBuIGluIHNlbGYudmVydGljZXNcXG4gICAgXFxuICAgIGRlZiBhZGRFZGdlKHNlbGYsZix0LGNvc3Q9MCk6XFxuICAgICAgICAgICAgaWYgZiBub3QgaW4gc2VsZi52ZXJ0aWNlczpcXG4gICAgICAgICAgICAgICAgbnYgPSBzZWxmLmFkZFZlcnRleChmKVxcbiAgICAgICAgICAgIGlmIHQgbm90IGluIHNlbGYudmVydGljZXM6XFxuICAgICAgICAgICAgICAgIG52ID0gc2VsZi5hZGRWZXJ0ZXgodClcXG4gICAgICAgICAgICBzZWxmLnZlcnRpY2VzW2ZdLmFkZE5laWdoYm9yKHNlbGYudmVydGljZXNbdF0sY29zdClcXG4gICAgXFxuICAgIGRlZiBnZXRWZXJ0aWNlcyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBsaXN0KHNlbGYudmVydGljZXMua2V5cygpKVxcbiAgICAgICAgXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBpdGVyKHNlbGYudmVydGljZXMudmFsdWVzKCkpXFxuICAgICAgICAgICAgICAgIFxcbmNsYXNzIFZlcnRleDpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsbnVtKTpcXG4gICAgICAgIHNlbGYuaWQgPSBudW1cXG4gICAgICAgIHNlbGYuY29ubmVjdGVkVG8gPSB7fVxcbiAgICAgICAgc2VsZi5jb2xvciA9ICd3aGl0ZSdcXG4gICAgICAgIHNlbGYuZGlzdCA9IHN5cy5tYXhzaXplXFxuICAgICAgICBzZWxmLnByZWQgPSBOb25lXFxuICAgICAgICBzZWxmLmRpc2MgPSAwXFxuICAgICAgICBzZWxmLmZpbiA9IDBcXG5cXG4gICAgIyBkZWYgX19sdF9fKHNlbGYsbyk6XFxuICAgICMgICAgIHJldHVybiBzZWxmLmlkIDwgby5pZFxcbiAgICBcXG4gICAgZGVmIGFkZE5laWdoYm9yKHNlbGYsbmJyLHdlaWdodD0wKTpcXG4gICAgICAgIHNlbGYuY29ubmVjdGVkVG9bbmJyXSA9IHdlaWdodFxcbiAgICAgICAgXFxuICAgIGRlZiBzZXRDb2xvcihzZWxmLGNvbG9yKTpcXG4gICAgICAgIHNlbGYuY29sb3IgPSBjb2xvclxcbiAgICAgICAgXFxuICAgIGRlZiBzZXREaXN0YW5jZShzZWxmLGQpOlxcbiAgICAgICAgc2VsZi5kaXN0ID0gZFxcblxcbiAgICBkZWYgc2V0UHJlZChzZWxmLHApOlxcbiAgICAgICAgc2VsZi5wcmVkID0gcFxcblxcbiAgICBkZWYgc2V0RGlzY292ZXJ5KHNlbGYsZHRpbWUpOlxcbiAgICAgICAgc2VsZi5kaXNjID0gZHRpbWVcXG4gICAgICAgIFxcbiAgICBkZWYgc2V0RmluaXNoKHNlbGYsZnRpbWUpOlxcbiAgICAgICAgc2VsZi5maW4gPSBmdGltZVxcbiAgICAgICAgXFxuICAgIGRlZiBnZXRGaW5pc2goc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5maW5cXG4gICAgICAgIFxcbiAgICBkZWYgZ2V0RGlzY292ZXJ5KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZGlzY1xcbiAgICAgICAgXFxuICAgIGRlZiBnZXRQcmVkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucHJlZFxcbiAgICAgICAgXFxuICAgIGRlZiBnZXREaXN0YW5jZShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmRpc3RcXG4gICAgICAgIFxcbiAgICBkZWYgZ2V0Q29sb3Ioc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jb2xvclxcbiAgICBcXG4gICAgZGVmIGdldENvbm5lY3Rpb25zKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuY29ubmVjdGVkVG8ua2V5cygpXFxuICAgICAgICBcXG4gICAgZGVmIGdldFdlaWdodChzZWxmLG5icik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jb25uZWN0ZWRUb1tuYnJdXFxuICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzdHIoc2VsZi5pZCkgKyBcXFwiOmNvbG9yIFxcXCIgKyBzZWxmLmNvbG9yICsgXFxcIjpkaXNjIFxcXCIgKyBzdHIoc2VsZi5kaXNjKSArIFxcXCI6ZmluIFxcXCIgKyBzdHIoc2VsZi5maW4pICsgXFxcIjpkaXN0IFxcXCIgKyBzdHIoc2VsZi5kaXN0KSArIFxcXCI6cHJlZCBcXFxcblxcXFx0W1xcXCIgKyBzdHIoc2VsZi5wcmVkKSsgXFxcIl1cXFxcblxcXCJcXG4gICAgXFxuICAgIGRlZiBnZXRJZChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmlkXFxuXFxuY2xhc3MgYWRqR3JhcGhUZXN0cyh1bml0dGVzdC5UZXN0Q2FzZSk6XFxuICAgIGRlZiBzZXRVcChzZWxmKTpcXG4gICAgICAgIHNlbGYudEdyYXBoID0gR3JhcGgoKVxcbiAgICAgICAgXFxuICAgIGRlZiB0ZXN0TWFrZUdyYXBoKHNlbGYpOlxcbiAgICAgICAgZ0ZpbGUgPSBvcGVuKFxcXCJ0ZXN0LmRhdFxcXCIpXFxuICAgICAgICBmb3IgbGluZSBpbiBnRmlsZTpcXG4gICAgICAgICAgICBmVmVydGV4LCB0VmVydGV4ID0gbGluZS5zcGxpdCgnfCcpXFxuICAgICAgICAgICAgZlZlcnRleCA9IGludChmVmVydGV4KVxcbiAgICAgICAgICAgIHRWZXJ0ZXggPSBpbnQodFZlcnRleClcXG4gICAgICAgICAgICBzZWxmLnRHcmFwaC5hZGRFZGdlKGZWZXJ0ZXgsdFZlcnRleClcXG4gICAgICAgIGZvciBpIGluIHNlbGYudEdyYXBoOlxcbiAgICAgICAgICAgIGFkaiA9IGkuZ2V0QWRqKClcXG4gICAgICAgICAgICBmb3IgayBpbiBhZGo6XFxuICAgICAgICAgICAgICAgIHByaW50KGksIGspXFxuXFxuICAgICAgICBcXG5pZiBfX25hbWVfXyA9PSAnX19tYWluX18nOlxcbiAgICB1bml0dGVzdC5tYWluKClcXG4gICAgICAgICAgICAgIFxcblwiLFwic3JjL2xpYi9weXRob25kcy9ncmFwaHMvcHJpb3JpdHlRdWV1ZS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiMgXFxuaW1wb3J0IHVuaXR0ZXN0XFxuXFxuIyB0aGlzIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBoZWFwIHRha2VzIGtleSB2YWx1ZSBwYWlycyxcXG4jIHdlIHdpbGwgYXNzdW1lIHRoYXQgdGhlIGtleXMgYXJlIGFsbCBjb21wYXJhYmxlXFxuXFxuY2xhc3MgUHJpb3JpdHlRdWV1ZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5oZWFwQXJyYXkgPSBbKDAsMCldXFxuICAgICAgICBzZWxmLmN1cnJlbnRTaXplID0gMFxcblxcbiAgICBkZWYgYnVpbGRIZWFwKHNlbGYsYWxpc3QpOlxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IGxlbihhbGlzdClcXG4gICAgICAgIHNlbGYuaGVhcEFycmF5ID0gWygwLDApXVxcbiAgICAgICAgZm9yIGkgaW4gYWxpc3Q6XFxuICAgICAgICAgICAgc2VsZi5oZWFwQXJyYXkuYXBwZW5kKGkpXFxuICAgICAgICBpID0gbGVuKGFsaXN0KSAvLyAyICAgICAgICAgICAgXFxuICAgICAgICB3aGlsZSAoaSA+IDApOlxcbiAgICAgICAgICAgIHNlbGYucGVyY0Rvd24oaSlcXG4gICAgICAgICAgICBpID0gaSAtIDFcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgZGVmIHBlcmNEb3duKHNlbGYsaSk6XFxuICAgICAgICB3aGlsZSAoaSAqIDIpIDw9IHNlbGYuY3VycmVudFNpemU6XFxuICAgICAgICAgICAgbWMgPSBzZWxmLm1pbkNoaWxkKGkpXFxuICAgICAgICAgICAgaWYgc2VsZi5oZWFwQXJyYXlbaV1bMF0gPiBzZWxmLmhlYXBBcnJheVttY11bMF06XFxuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuaGVhcEFycmF5W2ldXFxuICAgICAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W2ldID0gc2VsZi5oZWFwQXJyYXlbbWNdXFxuICAgICAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W21jXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBtY1xcbiAgICAgICAgICAgICAgICBcXG4gICAgZGVmIG1pbkNoaWxkKHNlbGYsaSk6XFxuICAgICAgICBpZiBpKjIgPiBzZWxmLmN1cnJlbnRTaXplOlxcbiAgICAgICAgICAgIHJldHVybiAtMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBpKjIgKyAxID4gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkqMlxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaGVhcEFycmF5W2kqMl1bMF0gPCBzZWxmLmhlYXBBcnJheVtpKjIrMV1bMF06XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSoyXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSoyKzFcXG5cXG4gICAgZGVmIHBlcmNVcChzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgaSAvLyAyID4gMDpcXG4gICAgICAgICAgICBpZiBzZWxmLmhlYXBBcnJheVtpXVswXSA8IHNlbGYuaGVhcEFycmF5W2kvLzJdWzBdOlxcbiAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuaGVhcEFycmF5W2kvLzJdXFxuICAgICAgICAgICAgICAgc2VsZi5oZWFwQXJyYXlbaS8vMl0gPSBzZWxmLmhlYXBBcnJheVtpXVxcbiAgICAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W2ldID0gdG1wXFxuICAgICAgICAgICAgaSA9IGkvLzJcXG4gXFxuICAgIGRlZiBhZGQoc2VsZixrKTpcXG4gICAgICAgIHNlbGYuaGVhcEFycmF5LmFwcGVuZChrKVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IHNlbGYuY3VycmVudFNpemUgKyAxXFxuICAgICAgICBzZWxmLnBlcmNVcChzZWxmLmN1cnJlbnRTaXplKVxcblxcbiAgICBkZWYgZGVsTWluKHNlbGYpOlxcbiAgICAgICAgcmV0dmFsID0gc2VsZi5oZWFwQXJyYXlbMV1bMV1cXG4gICAgICAgIHNlbGYuaGVhcEFycmF5WzFdID0gc2VsZi5oZWFwQXJyYXlbc2VsZi5jdXJyZW50U2l6ZV1cXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSBzZWxmLmN1cnJlbnRTaXplIC0gMVxcbiAgICAgICAgc2VsZi5oZWFwQXJyYXkucG9wKClcXG4gICAgICAgIHNlbGYucGVyY0Rvd24oMSlcXG4gICAgICAgIHJldHVybiByZXR2YWxcXG4gICAgICAgIFxcbiAgICBkZWYgaXNFbXB0eShzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuY3VycmVudFNpemUgPT0gMDpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG4gICAgZGVmIGRlY3JlYXNlS2V5KHNlbGYsdmFsLGFtdCk6XFxuICAgICAgICAjIHRoaXMgaXMgYSBsaXR0bGUgd2llcmQsIGJ1dCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGhlYXAgdGhpbmcgdG8gZGVjcmVhc2UgYnlcXG4gICAgICAgICMgbG9va2luZyBhdCBpdHMgdmFsdWVcXG4gICAgICAgIGRvbmUgPSBGYWxzZVxcbiAgICAgICAgaSA9IDFcXG4gICAgICAgIG15S2V5ID0gMFxcbiAgICAgICAgd2hpbGUgbm90IGRvbmUgYW5kIGkgPD0gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICBpZiBzZWxmLmhlYXBBcnJheVtpXVsxXSA9PSB2YWw6XFxuICAgICAgICAgICAgICAgIGRvbmUgPSBUcnVlXFxuICAgICAgICAgICAgICAgIG15S2V5ID0gaVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGkgPSBpICsgMVxcbiAgICAgICAgaWYgbXlLZXkgPiAwOlxcbiAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W215S2V5XSA9IChhbXQsc2VsZi5oZWFwQXJyYXlbbXlLZXldWzFdKVxcbiAgICAgICAgICAgIHNlbGYucGVyY1VwKG15S2V5KVxcbiAgICAgICAgICAgIFxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsdnR4KTpcXG4gICAgICAgIGZvciBwYWlyIGluIHNlbGYuaGVhcEFycmF5OlxcbiAgICAgICAgICAgIGlmIHBhaXJbMV0gPT0gdnR4OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICBcXG5jbGFzcyBUZXN0QmluSGVhcCh1bml0dGVzdC5UZXN0Q2FzZSk6XFxuICAgIGRlZiBzZXRVcChzZWxmKTpcXG4gICAgICAgIHNlbGYudGhlSGVhcCA9IFByaW9yaXR5UXVldWUoKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoMiwneCcpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoMywneScpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoNSwneicpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoNiwnYScpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoNCwnZCcpKVxcblxcblxcbiAgICBkZWYgdGVzdEluc2VydChzZWxmKTpcXG4gICAgICAgIGFzc2VydCBzZWxmLnRoZUhlYXAuY3VycmVudFNpemUgPT0gNVxcblxcbiAgICBkZWYgdGVzdERlbG1pbihzZWxmKTpcXG4gICAgICAgIGFzc2VydCBzZWxmLnRoZUhlYXAuZGVsTWluKCkgPT0gJ3gnXFxuICAgICAgICBhc3NlcnQgc2VsZi50aGVIZWFwLmRlbE1pbigpID09ICd5J1xcbiAgICBcXG4gICAgZGVmIHRlc3REZWNLZXkoc2VsZik6XFxuICAgICAgICBzZWxmLnRoZUhlYXAuZGVjcmVhc2VLZXkoJ2QnLDEpXFxuICAgICAgICBhc3NlcnQgc2VsZi50aGVIZWFwLmRlbE1pbigpID09ICdkJ1xcbiAgICAgICAgXFxuaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzpcXG4gICAgdW5pdHRlc3QubWFpbigpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL3RyZWVzL19faW5pdF9fLnB5XCI6XCJcXG5mcm9tIC5iaW5hcnlUcmVlIGltcG9ydCBCaW5hcnlUcmVlXFxuZnJvbSAuYmFsYW5jZSBpbXBvcnQgQVZMVHJlZVxcbmZyb20gLmJzdCBpbXBvcnQgQmluYXJ5U2VhcmNoVHJlZVxcbmZyb20gLmJpbmhlYXAgaW1wb3J0IEJpbkhlYXBcXG5cXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZHMvdHJlZXMvYmFsYW5jZS5weVwiOlwiIyEvYmluL2VudiBweXRob24zLjFcXG4jIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgSW50cm9kdWN0aW9uIHRvIERhdGEgU3RydWN0dXJlcyBhbmQgQWxnb3JpdGhtcyBpbiBQeXRob25cXG4jIENvcHlyaWdodCAyMDA1LCAyMDEwXFxuIyBcXG5cXG5mcm9tIC5ic3QgaW1wb3J0IEJpbmFyeVNlYXJjaFRyZWUsIFRyZWVOb2RlXFxuXFxuY2xhc3MgQVZMVHJlZShCaW5hcnlTZWFyY2hUcmVlKTpcXG4gICAgJycnXFxuICAgIEF1dGhvcjogIEJyYWQgTWlsbGVyXFxuICAgIERhdGU6ICAxLzE1LzIwMDVcXG4gICAgRGVzY3JpcHRpb246ICBJbWxlbWVudCBhIGJpbmFyeSBzZWFyY2ggdHJlZSB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlXFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiAgXFxuICAgICAgICAgICAgICAgICAgX19jb250YWluc19fKHkpIDw9PT4geSBpbiB4XFxuICAgICAgICAgICAgICAgICAgX19nZXRpdGVtX18oeSkgPD09PiB4W3ldXFxuICAgICAgICAgICAgICAgICAgX19pbml0X18oKVxcbiAgICAgICAgICAgICAgICAgIF9fbGVuX18oKSA8PT0+IGxlbih4KVxcbiAgICAgICAgICAgICAgICAgIF9fc2V0aXRlbV9fKGssdikgPD09PiB4W2tdID0gdlxcbiAgICAgICAgICAgICAgICAgIGNsZWFyKClcXG4gICAgICAgICAgICAgICAgICBnZXQoaylcXG4gICAgICAgICAgICAgICAgICBoYXNfa2V5KGspXFxuICAgICAgICAgICAgICAgICAgaXRlbXMoKSBcXG4gICAgICAgICAgICAgICAgICBrZXlzKCkgXFxuICAgICAgICAgICAgICAgICAgdmFsdWVzKClcXG4gICAgICAgICAgICAgICAgICBwdXQoayx2KVxcbiAgICAnJydcXG5cXG5cXG4gICAgZGVmIF9wdXQoc2VsZixrZXksdmFsLGN1cnJlbnROb2RlKTpcXG4gICAgICAgIGlmIGtleSA8IGN1cnJlbnROb2RlLmtleTpcXG4gICAgICAgICAgICBpZiBjdXJyZW50Tm9kZS5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSx2YWwsY3VycmVudE5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmxlZnRDaGlsZCA9IFRyZWVOb2RlKGtleSx2YWwscGFyZW50PWN1cnJlbnROb2RlKVxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUJhbGFuY2UoY3VycmVudE5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBjdXJyZW50Tm9kZS5oYXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksdmFsLGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHRDaGlsZCA9IFRyZWVOb2RlKGtleSx2YWwscGFyZW50PWN1cnJlbnROb2RlKVxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUJhbGFuY2UoY3VycmVudE5vZGUucmlnaHRDaGlsZCkgICAgICAgICAgICAgICAgXFxuXFxuICAgIGRlZiB1cGRhdGVCYWxhbmNlKHNlbGYsbm9kZSk6XFxuICAgICAgICBpZiBub2RlLmJhbGFuY2VGYWN0b3IgPiAxIG9yIG5vZGUuYmFsYW5jZUZhY3RvciA8IC0xOlxcbiAgICAgICAgICAgIHNlbGYucmViYWxhbmNlKG5vZGUpXFxuICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICBpZiBub2RlLnBhcmVudCAhPSBOb25lOlxcbiAgICAgICAgICAgIGlmIG5vZGUuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuYmFsYW5jZUZhY3RvciArPSAxXFxuICAgICAgICAgICAgZWxpZiBub2RlLmlzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5iYWxhbmNlRmFjdG9yIC09IDFcXG5cXG4gICAgICAgICAgICBpZiBub2RlLnBhcmVudC5iYWxhbmNlRmFjdG9yICE9IDA6XFxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQmFsYW5jZShub2RlLnBhcmVudClcXG5cXG4gICAgZGVmIHJlYmFsYW5jZShzZWxmLG5vZGUpOlxcbiAgICAgICAgaWYgbm9kZS5iYWxhbmNlRmFjdG9yIDwgMDpcXG4gICAgICAgICAgICBpZiBub2RlLnJpZ2h0Q2hpbGQuYmFsYW5jZUZhY3RvciA+IDA6XFxuICAgICAgICAgICAgICAgICMgRG8gYW4gTFIgUm90YXRpb25cXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVSaWdodChub2RlLnJpZ2h0Q2hpbGQpXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlTGVmdChub2RlKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICMgc2luZ2xlIGxlZnRcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVMZWZ0KG5vZGUpXFxuICAgICAgICBlbGlmIG5vZGUuYmFsYW5jZUZhY3RvciA+IDA6XFxuICAgICAgICAgICAgaWYgbm9kZS5sZWZ0Q2hpbGQuYmFsYW5jZUZhY3RvciA8IDA6XFxuICAgICAgICAgICAgICAgICMgRG8gYW4gUkwgUm90YXRpb25cXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVMZWZ0KG5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZVJpZ2h0KG5vZGUpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgIyBzaW5nbGUgcmlnaHRcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVSaWdodChub2RlKVxcblxcbiAgICBkZWYgcm90YXRlTGVmdChzZWxmLHJvdFJvb3QpOlxcbiAgICAgICAgbmV3Um9vdCA9IHJvdFJvb3QucmlnaHRDaGlsZFxcbiAgICAgICAgcm90Um9vdC5yaWdodENoaWxkID0gbmV3Um9vdC5sZWZ0Q2hpbGRcXG4gICAgICAgIGlmIG5ld1Jvb3QubGVmdENoaWxkICE9IE5vbmU6XFxuICAgICAgICAgICAgbmV3Um9vdC5sZWZ0Q2hpbGQucGFyZW50ID0gcm90Um9vdFxcbiAgICAgICAgbmV3Um9vdC5wYXJlbnQgPSByb3RSb290LnBhcmVudFxcbiAgICAgICAgaWYgcm90Um9vdC5pc1Jvb3QoKTpcXG4gICAgICAgICAgICBzZWxmLnJvb3QgPSBuZXdSb290XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHJvdFJvb3QuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgcm90Um9vdC5wYXJlbnQubGVmdENoaWxkID0gbmV3Um9vdFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJvdFJvb3QucGFyZW50LnJpZ2h0Q2hpbGQgPSBuZXdSb290XFxuICAgICAgICBuZXdSb290LmxlZnRDaGlsZCA9IHJvdFJvb3RcXG4gICAgICAgIHJvdFJvb3QucGFyZW50ID0gbmV3Um9vdFxcbiAgICAgICAgcm90Um9vdC5iYWxhbmNlRmFjdG9yID0gcm90Um9vdC5iYWxhbmNlRmFjdG9yICsgMSAtIG1pbihuZXdSb290LmJhbGFuY2VGYWN0b3IsIDApXFxuICAgICAgICBuZXdSb290LmJhbGFuY2VGYWN0b3IgPSBuZXdSb290LmJhbGFuY2VGYWN0b3IgKyAxICsgbWF4KHJvdFJvb3QuYmFsYW5jZUZhY3RvciwgMClcXG5cXG5cXG4gICAgZGVmIHJvdGF0ZVJpZ2h0KHNlbGYscm90Um9vdCk6XFxuICAgICAgICBuZXdSb290ID0gcm90Um9vdC5sZWZ0Q2hpbGRcXG4gICAgICAgIHJvdFJvb3QubGVmdENoaWxkID0gbmV3Um9vdC5yaWdodENoaWxkXFxuICAgICAgICBpZiBuZXdSb290LnJpZ2h0Q2hpbGQgIT0gTm9uZTpcXG4gICAgICAgICAgICBuZXdSb290LnJpZ2h0Q2hpbGQucGFyZW50ID0gcm90Um9vdFxcbiAgICAgICAgbmV3Um9vdC5wYXJlbnQgPSByb3RSb290LnBhcmVudFxcbiAgICAgICAgaWYgcm90Um9vdC5pc1Jvb3QoKTpcXG4gICAgICAgICAgICBzZWxmLnJvb3QgPSBuZXdSb290XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHJvdFJvb3QuaXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHJvdFJvb3QucGFyZW50LnJpZ2h0Q2hpbGQgPSBuZXdSb290XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcm90Um9vdC5wYXJlbnQubGVmdENoaWxkID0gbmV3Um9vdFxcbiAgICAgICAgbmV3Um9vdC5yaWdodENoaWxkID0gcm90Um9vdFxcbiAgICAgICAgcm90Um9vdC5wYXJlbnQgPSBuZXdSb290XFxuICAgICAgICByb3RSb290LmJhbGFuY2VGYWN0b3IgPSByb3RSb290LmJhbGFuY2VGYWN0b3IgLSAxIC0gbWF4KG5ld1Jvb3QuYmFsYW5jZUZhY3RvciwgMClcXG4gICAgICAgIG5ld1Jvb3QuYmFsYW5jZUZhY3RvciA9IG5ld1Jvb3QuYmFsYW5jZUZhY3RvciAtIDEgKyBtaW4ocm90Um9vdC5iYWxhbmNlRmFjdG9yLCAwKVxcbiAgICAgICAgXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL3RyZWVzL2JpbmFyeVRyZWUucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBJbnRyb2R1Y3Rpb24gdG8gRGF0YSBTdHJ1Y3R1cmVzIGFuZCBBbGdvcml0aG1zIGluIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMDVcXG4jIFxcblxcbmNsYXNzIEJpbmFyeVRyZWU6XFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBBIHJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBCaW5hcnkgVHJlZVxcbiAgICBVc2luZyBsaW5rcyBhbmQgTm9kZXMgYXBwcm9hY2guXFxuICAgIFxcXCJcXFwiXFxcIiAgICBcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYscm9vdE9iaik6XFxuICAgICAgICBzZWxmLmtleSA9IHJvb3RPYmpcXG4gICAgICAgIHNlbGYubGVmdENoaWxkID0gTm9uZVxcbiAgICAgICAgc2VsZi5yaWdodENoaWxkID0gTm9uZVxcblxcbiAgICBkZWYgaW5zZXJ0TGVmdChzZWxmLG5ld05vZGUpOlxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQgPT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZCA9IEJpbmFyeVRyZWUobmV3Tm9kZSlcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgdCA9IEJpbmFyeVRyZWUobmV3Tm9kZSlcXG4gICAgICAgICAgICB0LmxlZnQgPSBzZWxmLmxlZnRDaGlsZFxcbiAgICAgICAgICAgIHNlbGYubGVmdENoaWxkID0gdFxcbiAgICBcXG4gICAgZGVmIGluc2VydFJpZ2h0KHNlbGYsbmV3Tm9kZSk6XFxuICAgICAgICBpZiBzZWxmLnJpZ2h0Q2hpbGQgPT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQgPSBCaW5hcnlUcmVlKG5ld05vZGUpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHQgPSBCaW5hcnlUcmVlKG5ld05vZGUpXFxuICAgICAgICAgICAgdC5yaWdodCA9IHNlbGYucmlnaHRDaGlsZFxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZCA9IHRcXG5cXG4gICAgZGVmIGlzTGVhZihzZWxmKTpcXG4gICAgICAgIHJldHVybiAoKG5vdCBzZWxmLmxlZnRDaGlsZCkgYW5kIChub3Qgc2VsZi5yaWdodENoaWxkKSlcXG5cXG4gICAgZGVmIGdldFJpZ2h0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkXFxuXFxuICAgIGRlZiBnZXRMZWZ0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5sZWZ0Q2hpbGRcXG5cXG4gICAgZGVmIHNldFJvb3RWYWwoc2VsZixvYmopOlxcbiAgICAgICAgc2VsZi5rZXkgPSBvYmpcXG5cXG4gICAgZGVmIGdldFJvb3RWYWwoc2VsZiwpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYua2V5XFxuXFxuICAgIGRlZiBpbm9yZGVyKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQuaW5vcmRlcigpXFxuICAgICAgICBwcmludChzZWxmLmtleSlcXG4gICAgICAgIGlmIHNlbGYucmlnaHRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQuaW5vcmRlcigpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXIoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmxlZnRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZC5wb3N0b3JkZXIoKVxcbiAgICAgICAgaWYgc2VsZi5yaWdodENoaWxkOlxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZC5wb3N0b3JkZXIoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5rZXkpXFxuXFxuXFxuICAgIGRlZiBwcmVvcmRlcihzZWxmKTpcXG4gICAgICAgIHByaW50KHNlbGYua2V5KVxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQucHJlb3JkZXIoKVxcbiAgICAgICAgaWYgc2VsZi5yaWdodENoaWxkOlxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZC5wcmVvcmRlcigpXFxuXFxuICAgIGRlZiBwcmludGV4cChzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYubGVmdENoaWxkOlxcbiAgICAgICAgICAgIHByaW50KCcoJylcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZC5wcmludGV4cCgpXFxuICAgICAgICBwcmludChzZWxmLmtleSlcXG4gICAgICAgIGlmIHNlbGYucmlnaHRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQucHJpbnRleHAoKVxcbiAgICAgICAgICAgIHByaW50KCcpJylcXG5cXG4gICAgZGVmIHBvc3RvcmRlcmV2YWwoc2VsZik6XFxuICAgICAgICBvcGVycyA9IHsnKyc6b3BlcmF0b3IuYWRkLCAnLSc6b3BlcmF0b3Iuc3ViLCAnKic6b3BlcmF0b3IubXVsLCAnLyc6b3BlcmF0b3IudHJ1ZWRpdn1cXG4gICAgICAgIHJlczEgPSBOb25lXFxuICAgICAgICByZXMyID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgcmVzMSA9IHNlbGYubGVmdENoaWxkLnBvc3RvcmRlcmV2YWwoKSAgIy8vIFxcXFxsYWJlbHtwZWxlZnR9XFxuICAgICAgICBpZiBzZWxmLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICAgICAgcmVzMiA9IHNlbGYucmlnaHRDaGlsZC5wb3N0b3JkZXJldmFsKCkgIy8vIFxcXFxsYWJlbHtwZXJpZ2h0fVxcbiAgICAgICAgaWYgcmVzMSBhbmQgcmVzMjpcXG4gICAgICAgICAgICByZXR1cm4gb3BlcnNbc2VsZi5rZXldKHJlczEscmVzMikgIy8vIFxcXFxsYWJlbHtwZWV2YWx9XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmtleVxcblxcbmRlZiBpbm9yZGVyKHRyZWUpOlxcbiAgICBpZiB0cmVlICE9IE5vbmU6XFxuICAgICAgICBpbm9yZGVyKHRyZWUuZ2V0TGVmdENoaWxkKCkpXFxuICAgICAgICBwcmludCh0cmVlLmdldFJvb3RWYWwoKSlcXG4gICAgICAgIGlub3JkZXIodHJlZS5nZXRSaWdodENoaWxkKCkpXFxuXFxuZGVmIHByaW50ZXhwKHRyZWUpOlxcbiAgICBpZiB0cmVlLmxlZnRDaGlsZDpcXG4gICAgICAgIHByaW50KCcoJylcXG4gICAgICAgIHByaW50ZXhwKHRyZWUuZ2V0TGVmdENoaWxkKCkpXFxuICAgIHByaW50KHRyZWUuZ2V0Um9vdFZhbCgpKVxcbiAgICBpZiB0cmVlLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICBwcmludGV4cCh0cmVlLmdldFJpZ2h0Q2hpbGQoKSlcXG4gICAgICAgIHByaW50KCcpJykgXFxuXFxuZGVmIHByaW50ZXhwKHRyZWUpOlxcbiAgICBzVmFsID0gXFxcIlxcXCJcXG4gICAgaWYgdHJlZTpcXG4gICAgICAgIHNWYWwgPSAnKCcgKyBwcmludGV4cCh0cmVlLmdldExlZnRDaGlsZCgpKVxcbiAgICAgICAgc1ZhbCA9IHNWYWwgKyBzdHIodHJlZS5nZXRSb290VmFsKCkpXFxuICAgICAgICBzVmFsID0gc1ZhbCArIHByaW50ZXhwKHRyZWUuZ2V0UmlnaHRDaGlsZCgpKSArICcpJ1xcbiAgICByZXR1cm4gc1ZhbFxcblxcbmRlZiBwb3N0b3JkZXJldmFsKHRyZWUpOlxcbiAgICBvcGVycyA9IHsnKyc6b3BlcmF0b3IuYWRkLCAnLSc6b3BlcmF0b3Iuc3ViLCAnKic6b3BlcmF0b3IubXVsLCAnLyc6b3BlcmF0b3IudHJ1ZWRpdn1cXG4gICAgcmVzMSA9IE5vbmVcXG4gICAgcmVzMiA9IE5vbmVcXG4gICAgaWYgdHJlZTpcXG4gICAgICAgIHJlczEgPSBwb3N0b3JkZXJldmFsKHRyZWUuZ2V0TGVmdENoaWxkKCkpICAjLy8gXFxcXGxhYmVse3BlbGVmdH1cXG4gICAgICAgIHJlczIgPSBwb3N0b3JkZXJldmFsKHRyZWUuZ2V0UmlnaHRDaGlsZCgpKSAjLy8gXFxcXGxhYmVse3BlcmlnaHR9XFxuICAgICAgICBpZiByZXMxIGFuZCByZXMyOlxcbiAgICAgICAgICAgIHJldHVybiBvcGVyc1t0cmVlLmdldFJvb3RWYWwoKV0ocmVzMSxyZXMyKSAjLy8gXFxcXGxhYmVse3BlZXZhbH1cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIHRyZWUuZ2V0Um9vdFZhbCgpXFxuXFxuZGVmIGhlaWdodCh0cmVlKTpcXG4gICAgaWYgdHJlZSA9PSBOb25lOlxcbiAgICAgICAgcmV0dXJuIC0xXFxuICAgIGVsc2U6XFxuICAgICAgICByZXR1cm4gMSArIG1heChoZWlnaHQodHJlZS5sZWZ0Q2hpbGQpLGhlaWdodCh0cmVlLnJpZ2h0Q2hpbGQpKVxcblxcbiMgdCA9IEJpbmFyeVRyZWUoNylcXG4jIHQuaW5zZXJ0TGVmdCgzKVxcbiMgdC5pbnNlcnRSaWdodCg5KVxcbiMgaW5vcmRlcih0KVxcbiMgaW1wb3J0IG9wZXJhdG9yXFxuIyB4ID0gQmluYXJ5VHJlZSgnKicpXFxuIyB4Lmluc2VydExlZnQoJysnKVxcbiMgbCA9IHguZ2V0TGVmdENoaWxkKClcXG4jIGwuaW5zZXJ0TGVmdCg0KVxcbiMgbC5pbnNlcnRSaWdodCg1KVxcbiMgeC5pbnNlcnRSaWdodCg3KVxcbiMgcHJpbnQocHJpbnRleHAoeCkpXFxuIyBwcmludChwb3N0b3JkZXJldmFsKHgpKVxcbiMgcHJpbnQoaGVpZ2h0KHgpKVxcblwiLFwic3JjL2xpYi9weXRob25kcy90cmVlcy9iaW5oZWFwLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgSW50cm9kdWN0aW9uIHRvIERhdGEgU3RydWN0dXJlcyBhbmQgQWxnb3JpdGhtcyBpbiBQeXRob25cXG4jIENvcHlyaWdodCAyMDA1XFxuIyBcXG5cXG4jIHRoaXMgaGVhcCB0YWtlcyBrZXkgdmFsdWUgcGFpcnMsIHdlIHdpbGwgYXNzdW1lIHRoYXQgdGhlIGtleXMgYXJlIGludGVnZXJzXFxuY2xhc3MgQmluSGVhcDpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5oZWFwTGlzdCA9IFswXVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IDBcXG5cXG5cXG4gICAgZGVmIGJ1aWxkSGVhcChzZWxmLGFsaXN0KTpcXG4gICAgICAgIGkgPSBsZW4oYWxpc3QpIC8vIDJcXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSBsZW4oYWxpc3QpXFxuICAgICAgICBzZWxmLmhlYXBMaXN0ID0gWzBdICsgYWxpc3RbOl1cXG4gICAgICAgIHByaW50KGxlbihzZWxmLmhlYXBMaXN0KSwgaSlcXG4gICAgICAgIHdoaWxlIChpID4gMCk6XFxuICAgICAgICAgICAgcHJpbnQoc2VsZi5oZWFwTGlzdCwgaSlcXG4gICAgICAgICAgICBzZWxmLnBlcmNEb3duKGkpXFxuICAgICAgICAgICAgaSA9IGkgLSAxXFxuICAgICAgICBwcmludChzZWxmLmhlYXBMaXN0LGkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgIGRlZiBwZXJjRG93bihzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgKGkgKiAyKSA8PSBzZWxmLmN1cnJlbnRTaXplOlxcbiAgICAgICAgICAgIG1jID0gc2VsZi5taW5DaGlsZChpKVxcbiAgICAgICAgICAgIGlmIHNlbGYuaGVhcExpc3RbaV0gPiBzZWxmLmhlYXBMaXN0W21jXTpcXG4gICAgICAgICAgICAgICAgdG1wID0gc2VsZi5oZWFwTGlzdFtpXVxcbiAgICAgICAgICAgICAgICBzZWxmLmhlYXBMaXN0W2ldID0gc2VsZi5oZWFwTGlzdFttY11cXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFwTGlzdFttY10gPSB0bXBcXG4gICAgICAgICAgICBpID0gbWNcXG4gICAgICAgICAgICAgICAgXFxuICAgIGRlZiBtaW5DaGlsZChzZWxmLGkpOlxcbiAgICAgICAgaWYgaSAqIDIgKyAxID4gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICByZXR1cm4gaSAqIDJcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgc2VsZi5oZWFwTGlzdFtpICogMl0gPCBzZWxmLmhlYXBMaXN0W2kgKiAyICsgMV06XFxuICAgICAgICAgICAgICAgIHJldHVybiBpICogMlxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJldHVybiBpICogMiArIDFcXG5cXG4gICAgZGVmIHBlcmNVcChzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgaSAvLyAyID4gMDpcXG4gICAgICAgICAgICBpZiBzZWxmLmhlYXBMaXN0W2ldIDwgc2VsZi5oZWFwTGlzdFtpLy8yXTpcXG4gICAgICAgICAgICAgICB0bXAgPSBzZWxmLmhlYXBMaXN0W2kgLy8gMl1cXG4gICAgICAgICAgICAgICBzZWxmLmhlYXBMaXN0W2kgLy8gMl0gPSBzZWxmLmhlYXBMaXN0W2ldXFxuICAgICAgICAgICAgICAgc2VsZi5oZWFwTGlzdFtpXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBpIC8vIDJcXG4gXFxuICAgIGRlZiBpbnNlcnQoc2VsZixrKTpcXG4gICAgICAgIHNlbGYuaGVhcExpc3QuYXBwZW5kKGspXFxuICAgICAgICBzZWxmLmN1cnJlbnRTaXplID0gc2VsZi5jdXJyZW50U2l6ZSArIDFcXG4gICAgICAgIHNlbGYucGVyY1VwKHNlbGYuY3VycmVudFNpemUpXFxuXFxuICAgIGRlZiBkZWxNaW4oc2VsZik6XFxuICAgICAgICByZXR2YWwgPSBzZWxmLmhlYXBMaXN0WzFdXFxuICAgICAgICBzZWxmLmhlYXBMaXN0WzFdID0gc2VsZi5oZWFwTGlzdFtzZWxmLmN1cnJlbnRTaXplXVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IHNlbGYuY3VycmVudFNpemUgLSAxXFxuICAgICAgICBzZWxmLmhlYXBMaXN0LnBvcCgpXFxuICAgICAgICBzZWxmLnBlcmNEb3duKDEpXFxuICAgICAgICByZXR1cm4gcmV0dmFsXFxuICAgICAgICBcXG4gICAgZGVmIGlzRW1wdHkoc2VsZik6XFxuICAgICAgICBpZiBjdXJyZW50U2l6ZSA9PSAwOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcblwiLFwic3JjL2xpYi9weXRob25kcy90cmVlcy9ic3QucHlcIjpcIiMhL2Jpbi9lbnYgcHl0aG9uMy4xXFxuIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNSwgMjAxMFxcbiMgXFxuXFxuY2xhc3MgQmluYXJ5U2VhcmNoVHJlZTpcXG4gICAgJycnXFxuICAgIEF1dGhvcjogIEJyYWQgTWlsbGVyXFxuICAgIERhdGU6ICAxLzE1LzIwMDVcXG4gICAgRGVzY3JpcHRpb246ICBJbWxlbWVudCBhIGJpbmFyeSBzZWFyY2ggdHJlZSB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlXFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiAgXFxuICAgICAgICAgICAgICAgICAgX19jb250YWluc19fKHkpIDw9PT4geSBpbiB4XFxuICAgICAgICAgICAgICAgICAgX19nZXRpdGVtX18oeSkgPD09PiB4W3ldXFxuICAgICAgICAgICAgICAgICAgX19pbml0X18oKVxcbiAgICAgICAgICAgICAgICAgIF9fbGVuX18oKSA8PT0+IGxlbih4KVxcbiAgICAgICAgICAgICAgICAgIF9fc2V0aXRlbV9fKGssdikgPD09PiB4W2tdID0gdlxcbiAgICAgICAgICAgICAgICAgIGNsZWFyKClcXG4gICAgICAgICAgICAgICAgICBnZXQoaylcXG4gICAgICAgICAgICAgICAgICBpdGVtcygpIFxcbiAgICAgICAgICAgICAgICAgIGtleXMoKSBcXG4gICAgICAgICAgICAgICAgICB2YWx1ZXMoKVxcbiAgICAgICAgICAgICAgICAgIHB1dChrLHYpXFxuICAgICAgICAgICAgICAgICAgaW5cXG4gICAgICAgICAgICAgICAgICBkZWwgPD09PiBcXG4gICAgJycnXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYucm9vdCA9IE5vbmVcXG4gICAgICAgIHNlbGYuc2l6ZSA9IDBcXG4gICAgXFxuICAgIGRlZiBwdXQoc2VsZixrZXksdmFsKTpcXG4gICAgICAgIGlmIHNlbGYucm9vdDpcXG4gICAgICAgICAgICBzZWxmLl9wdXQoa2V5LHZhbCxzZWxmLnJvb3QpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNlbGYucm9vdCA9IFRyZWVOb2RlKGtleSx2YWwpXFxuICAgICAgICBzZWxmLnNpemUgPSBzZWxmLnNpemUgKyAxXFxuXFxuICAgIGRlZiBfcHV0KHNlbGYsa2V5LHZhbCxjdXJyZW50Tm9kZSk6XFxuICAgICAgICBpZiBrZXkgPCBjdXJyZW50Tm9kZS5rZXk6XFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksdmFsLGN1cnJlbnROb2RlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQgPSBUcmVlTm9kZShrZXksdmFsLHBhcmVudD1jdXJyZW50Tm9kZSlcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wdXQoa2V5LHZhbCxjdXJyZW50Tm9kZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQgPSBUcmVlTm9kZShrZXksdmFsLHBhcmVudD1jdXJyZW50Tm9kZSlcXG4gICAgICAgICAgICBcXG4gICAgZGVmIF9fc2V0aXRlbV9fKHNlbGYsayx2KTpcXG4gICAgICAgIHNlbGYucHV0KGssdilcXG5cXG4gICAgZGVmIGdldChzZWxmLGtleSk6XFxuICAgICAgICBpZiBzZWxmLnJvb3Q6XFxuICAgICAgICAgICAgcmVzID0gc2VsZi5fZ2V0KGtleSxzZWxmLnJvb3QpXFxuICAgICAgICAgICAgaWYgcmVzOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnBheWxvYWRcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgXFxuICAgIGRlZiBfZ2V0KHNlbGYsa2V5LGN1cnJlbnROb2RlKTpcXG4gICAgICAgIGlmIG5vdCBjdXJyZW50Tm9kZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgZWxpZiBjdXJyZW50Tm9kZS5rZXkgPT0ga2V5OlxcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9kZVxcbiAgICAgICAgZWxpZiBrZXkgPCBjdXJyZW50Tm9kZS5rZXk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldChrZXksY3VycmVudE5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0KGtleSxjdXJyZW50Tm9kZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLGtleSk6XFxuICAgICAgICByZXMgPSBzZWxmLmdldChrZXkpXFxuICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgcmV0dXJuIHJlc1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGtleSBub3QgaW4gdHJlZScpXFxuICAgICAgICAgICAgXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixrZXkpOlxcbiAgICAgICAgaWYgc2VsZi5fZ2V0KGtleSxzZWxmLnJvb3QpOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgXFxuICAgIGRlZiBsZW5ndGgoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5zaXplXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuc2l6ZVxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yb290Ll9faXRlcl9fKClcXG4gICAgXFxuICAgIGRlZiBkZWxldGUoc2VsZixrZXkpOlxcbiAgICAgICAgaWYgc2VsZi5zaXplID4gMTpcXG4gICAgICAgICAgICBub2RlVG9SZW1vdmUgPSBzZWxmLl9nZXQoa2V5LHNlbGYucm9vdClcXG4gICAgICAgICAgICBpZiBub2RlVG9SZW1vdmU6XFxuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlKG5vZGVUb1JlbW92ZSlcXG4gICAgICAgICAgICAgICAgc2VsZi5zaXplID0gc2VsZi5zaXplLTFcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGtleSBub3QgaW4gdHJlZScpXFxuICAgICAgICBlbGlmIHNlbGYuc2l6ZSA9PSAxIGFuZCBzZWxmLnJvb3Qua2V5ID09IGtleTpcXG4gICAgICAgICAgICBzZWxmLnJvb3QgPSBOb25lXFxuICAgICAgICAgICAgc2VsZi5zaXplID0gc2VsZi5zaXplIC0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGtleSBub3QgaW4gdHJlZScpXFxuXFxuICAgIGRlZiBfX2RlbGl0ZW1fXyhzZWxmLGtleSk6XFxuICAgICAgICBzZWxmLmRlbGV0ZShrZXkpXFxuICAgIFxcbiAgICBkZWYgcmVtb3ZlKHNlbGYsY3VycmVudE5vZGUpOlxcbiAgICAgICAgaWYgY3VycmVudE5vZGUuaXNMZWFmKCk6ICNsZWFmXFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUgPT0gY3VycmVudE5vZGUucGFyZW50LmxlZnRDaGlsZDpcXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50LmxlZnRDaGlsZCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQucmlnaHRDaGlsZCA9IE5vbmVcXG4gICAgICAgIGVsaWYgY3VycmVudE5vZGUuaGFzQm90aENoaWxkcmVuKCk6ICNpbnRlcmlvclxcbiAgICAgICAgICAgIHN1Y2MgPSBjdXJyZW50Tm9kZS5maW5kU3VjY2Vzc29yKClcXG4gICAgICAgICAgICBzdWNjLnNwbGljZU91dCgpXFxuICAgICAgICAgICAgY3VycmVudE5vZGUua2V5ID0gc3VjYy5rZXlcXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXlsb2FkID0gc3VjYy5wYXlsb2FkXFxuICAgICAgICBlbHNlOiAjIHRoaXMgbm9kZSBoYXMgb25lIGNoaWxkXFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnROb2RlLmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQucGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQubGVmdENoaWxkID0gY3VycmVudE5vZGUubGVmdENoaWxkXFxuICAgICAgICAgICAgICAgIGVsaWYgY3VycmVudE5vZGUuaXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQucGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQucmlnaHRDaGlsZCA9IGN1cnJlbnROb2RlLmxlZnRDaGlsZFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZU5vZGVEYXRhKGN1cnJlbnROb2RlLmxlZnRDaGlsZC5rZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkLnBheWxvYWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkLmxlZnRDaGlsZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQucmlnaHRDaGlsZClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpZiBjdXJyZW50Tm9kZS5pc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHRDaGlsZC5wYXJlbnQgPSBjdXJyZW50Tm9kZS5wYXJlbnRcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnBhcmVudC5sZWZ0Q2hpbGQgPSBjdXJyZW50Tm9kZS5yaWdodENoaWxkXFxuICAgICAgICAgICAgICAgIGVsaWYgY3VycmVudE5vZGUuaXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yaWdodENoaWxkLnBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudFxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50LnJpZ2h0Q2hpbGQgPSBjdXJyZW50Tm9kZS5yaWdodENoaWxkXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlTm9kZURhdGEoY3VycmVudE5vZGUucmlnaHRDaGlsZC5rZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHRDaGlsZC5wYXlsb2FkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQubGVmdENoaWxkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQucmlnaHRDaGlsZClcXG5cXG4gICAgZGVmIGlub3JkZXIoc2VsZik6XFxuICAgICAgICBzZWxmLl9pbm9yZGVyKHNlbGYucm9vdClcXG5cXG4gICAgZGVmIF9pbm9yZGVyKHNlbGYsdHJlZSk6XFxuICAgICAgICBpZiB0cmVlICE9IE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlcih0cmVlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSlcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVyKHRyZWUucmlnaHRDaGlsZClcXG5cXG4gICAgZGVmIHBvc3RvcmRlcihzZWxmKTpcXG4gICAgICAgIHNlbGYuX3Bvc3RvcmRlcihzZWxmLnJvb3QpXFxuXFxuICAgIGRlZiBfcG9zdG9yZGVyKHNlbGYsIHRyZWUpOlxcbiAgICAgICAgaWYgdHJlZTpcXG4gICAgICAgICAgICBzZWxmLl9wb3N0b3JkZXIodHJlZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgIHNlbGYuX3Bvc3RvcmRlcih0cmVlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSkgICAgICAgICAgICBcXG5cXG4gICAgZGVmIHByZW9yZGVyKHNlbGYpOlxcbiAgICAgICAgc2VsZi5fcHJlb3JkZXIoc2VsZixzZWxmLnJvb3QpXFxuXFxuICAgIGRlZiBfcHJlb3JkZXIoc2VsZix0cmVlKTpcXG4gICAgICAgIGlmIHRyZWU6XFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXkpICAgICAgICAgICAgXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZXIodHJlZS5sZWZ0Q2hpbGQpXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZXIodHJlZS5yaWdodENoaWxkKVxcblxcbiAgICAgICAgICAgICAgICBcXG5jbGFzcyBUcmVlTm9kZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsa2V5LHZhbCxsZWZ0PU5vbmUscmlnaHQ9Tm9uZSxwYXJlbnQ9Tm9uZSk6XFxuICAgICAgICBzZWxmLmtleSA9IGtleVxcbiAgICAgICAgc2VsZi5wYXlsb2FkID0gdmFsXFxuICAgICAgICBzZWxmLmxlZnRDaGlsZCA9IGxlZnRcXG4gICAgICAgIHNlbGYucmlnaHRDaGlsZCA9IHJpZ2h0XFxuICAgICAgICBzZWxmLnBhcmVudCA9IHBhcmVudFxcbiAgICAgICAgc2VsZi5iYWxhbmNlRmFjdG9yID0gMFxcbiAgICAgICAgXFxuICAgIGRlZiBoYXNMZWZ0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5sZWZ0Q2hpbGRcXG5cXG4gICAgZGVmIGhhc1JpZ2h0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkXFxuICAgIFxcbiAgICBkZWYgaXNMZWZ0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnQgYW5kIHNlbGYucGFyZW50LmxlZnRDaGlsZCA9PSBzZWxmXFxuXFxuICAgIGRlZiBpc1JpZ2h0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnQgYW5kIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPT0gc2VsZlxcblxcbiAgICBkZWYgaXNSb290KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIG5vdCBzZWxmLnBhcmVudFxcblxcbiAgICBkZWYgaXNMZWFmKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIG5vdCAoc2VsZi5yaWdodENoaWxkIG9yIHNlbGYubGVmdENoaWxkKVxcblxcbiAgICBkZWYgaGFzQW55Q2hpbGRyZW4oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkIG9yIHNlbGYubGVmdENoaWxkXFxuXFxuICAgIGRlZiBoYXNCb3RoQ2hpbGRyZW4oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkIGFuZCBzZWxmLmxlZnRDaGlsZFxcbiAgICBcXG4gICAgZGVmIHJlcGxhY2VOb2RlRGF0YShzZWxmLGtleSx2YWx1ZSxsYyxyYyk6XFxuICAgICAgICBzZWxmLmtleSA9IGtleVxcbiAgICAgICAgc2VsZi5wYXlsb2FkID0gdmFsdWVcXG4gICAgICAgIHNlbGYubGVmdENoaWxkID0gbGNcXG4gICAgICAgIHNlbGYucmlnaHRDaGlsZCA9IHJjXFxuICAgICAgICBpZiBzZWxmLmhhc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgIHNlbGYubGVmdENoaWxkLnBhcmVudCA9IHNlbGZcXG4gICAgICAgIGlmIHNlbGYuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZC5wYXJlbnQgPSBzZWxmXFxuICAgICAgICBcXG4gICAgZGVmIGZpbmRTdWNjZXNzb3Ioc2VsZik6XFxuICAgICAgICBzdWNjID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi5oYXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgc3VjYyA9IHNlbGYucmlnaHRDaGlsZC5maW5kTWluKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgc2VsZi5wYXJlbnQ6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHN1Y2MgPSBzZWxmLnBhcmVudFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnQucmlnaHRDaGlsZCA9IE5vbmVcXG4gICAgICAgICAgICAgICAgICAgIHN1Y2MgPSBzZWxmLnBhcmVudC5maW5kU3VjY2Vzc29yKClcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPSBzZWxmXFxuICAgICAgICByZXR1cm4gc3VjY1xcblxcblxcbiAgICBkZWYgc3BsaWNlT3V0KHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5pc0xlYWYoKTpcXG4gICAgICAgICAgICBpZiBzZWxmLmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LmxlZnRDaGlsZCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5yaWdodENoaWxkID0gTm9uZVxcbiAgICAgICAgZWxpZiBzZWxmLmhhc0FueUNoaWxkcmVuKCk6XFxuICAgICAgICAgICAgaWYgc2VsZi5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5pc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnQubGVmdENoaWxkID0gc2VsZi5sZWZ0Q2hpbGRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPSBzZWxmLmxlZnRDaGlsZFxcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnRDaGlsZC5wYXJlbnQgPSBzZWxmLnBhcmVudFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LmxlZnRDaGlsZCA9IHNlbGYucmlnaHRDaGlsZFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnQucmlnaHRDaGlsZCA9IHNlbGYucmlnaHRDaGlsZFxcbiAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQucGFyZW50ID0gc2VsZi5wYXJlbnRcXG5cXG4gICAgZGVmIGZpbmRNaW4oc2VsZik6XFxuICAgICAgICBjdXJyZW50ID0gc2VsZlxcbiAgICAgICAgd2hpbGUgY3VycmVudC5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0Q2hpbGRcXG4gICAgICAgIHJldHVybiBjdXJyZW50XFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlRoZSBzdGFuZGFyZCBpbm9yZGVyIHRyYXZlcnNhbCBvZiBhIGJpbmFyeSB0cmVlLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZjpcXG4gICAgICAgICAgICBpZiBzZWxmLmhhc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBmb3IgZWxlbSBpbiBzZWxmLmxlZnRDaGlsZDpcXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1cXG4gICAgICAgICAgICB5aWVsZCBzZWxmLmtleVxcbiAgICAgICAgICAgIGlmIHNlbGYuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBmb3IgZWxlbSBpbiBzZWxmLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBlbGVtXFxuXFxuICAgICAgICAgICAgXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMyBpbXBvcnQgc3RhdGVtZW50XFxuXFxcIlxcXCJcXFwiXFxuXFxuZnJvbSBweXRob25kczMuYmFzaWMgaW1wb3J0IFN0YWNrLCBRdWV1ZSwgRGVxdWVcXG5mcm9tIHB5dGhvbmRzMy5ncmFwaHMgaW1wb3J0IEdyYXBoLCBWZXJ0ZXhcXG5mcm9tIHB5dGhvbmRzMy5zZWFyY2hpbmcgaW1wb3J0IEhhc2hUYWJsZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzIGltcG9ydCAoXFxuICAgIEJpbmFyeVRyZWUsXFxuICAgIEFWTFRyZWUsXFxuICAgIEJpbmFyeVNlYXJjaFRyZWUsXFxuICAgIEJpbmFyeUhlYXAsXFxuICAgIFByaW9yaXR5UXVldWUsXFxuKVxcblxcbl9fYWxsX18gPSBbXFxuICAgIFxcXCJTdGFja1xcXCIsXFxuICAgIFxcXCJRdWV1ZVxcXCIsXFxuICAgIFxcXCJEZXF1ZVxcXCIsXFxuICAgIFxcXCJHcmFwaFxcXCIsXFxuICAgIFxcXCJWZXJ0ZXhcXFwiLFxcbiAgICBcXFwiSGFzaFRhYmxlXFxcIixcXG4gICAgXFxcIkJpbmFyeVRyZWVcXFwiLFxcbiAgICBcXFwiQVZMVHJlZVxcXCIsXFxuICAgIFxcXCJCaW5hcnlTZWFyY2hUcmVlXFxcIixcXG4gICAgXFxcIkJpbmFyeUhlYXBcXFwiLFxcbiAgICBcXFwiQmluYXJ5VHJlZVxcXCIsXFxuICAgIFxcXCJQcmlvcml0eVF1ZXVlXFxcIixcXG5dXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9iYXNpYy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5iYXNpYyBpbXBvcnQgc3RhdGVtZW50XFxuXFxcIlxcXCJcXFwiXFxuZnJvbSBweXRob25kczMuYmFzaWMuc3RhY2sgaW1wb3J0IFN0YWNrXFxuZnJvbSBweXRob25kczMuYmFzaWMucXVldWUgaW1wb3J0IFF1ZXVlXFxuZnJvbSBweXRob25kczMuYmFzaWMuZGVxdWUgaW1wb3J0IERlcXVlXFxuZnJvbSBweXRob25kczMuYmFzaWMubGlua2VkX2xpc3QgaW1wb3J0IE9yZGVyZWRMaXN0XFxuZnJvbSBweXRob25kczMuYmFzaWMubGlua2VkX2xpc3QgaW1wb3J0IFVub3JkZXJlZExpc3RcXG5cXG5fX2FsbF9fID0gW1xcXCJTdGFja1xcXCIsIFxcXCJRdWV1ZVxcXCIsIFxcXCJEZXF1ZVxcXCIsIFxcXCJPcmRlcmVkTGlzdFxcXCIsIFxcXCJVbm9yZGVyZWRMaXN0XFxcIl1cXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2Jhc2ljL2RlcXVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIERlcXVlOlxcbiAgICBcXFwiXFxcIlxcXCJRdWV1ZSBpbXBsZW1lbnRhdGlvbiBhcyBhIGxpc3RcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyBkZXF1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgZGVxdWUgaXMgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgYm9vbChzZWxmLl9pdGVtcylcXG5cXG4gICAgZGVmIGFkZF9mcm9udChzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhbiBpdGVtIHRvIHRoZSBmcm9udCBvZiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zLmFwcGVuZChpdGVtKVxcblxcbiAgICBkZWYgYWRkX3JlYXIoc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaXRlbSB0byB0aGUgcmVhciBvZiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zLmluc2VydCgwLCBpdGVtKVxcblxcbiAgICBkZWYgcmVtb3ZlX2Zyb250KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGRlcXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5faXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHJlbW92ZV9yZWFyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgcmVhciBvZiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9pdGVtcy5wb3AoMClcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5faXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9iYXNpYy9saW5rZWRfbGlzdC5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5cXG5jbGFzcyBMaW5rZWRMaXN0Tm9kZTpcXG4gICAgXFxcIlxcXCJcXFwiQSBub2RlIG9mIGEgbGlua2VkIGxpc3RcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5vZGVfZGF0YSk6XFxuICAgICAgICBzZWxmLl9kYXRhID0gbm9kZV9kYXRhXFxuICAgICAgICBzZWxmLl9uZXh0ID0gTm9uZVxcblxcbiAgICBkZWYgZ2V0X2RhdGEoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgbm9kZSBkYXRhXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVxcblxcbiAgICBkZWYgc2V0X2RhdGEoc2VsZiwgbm9kZV9kYXRhKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBub2RlIGRhdGFcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2RhdGEgPSBub2RlX2RhdGFcXG5cXG4gICAgZGF0YSA9IHByb3BlcnR5KGdldF9kYXRhLCBzZXRfZGF0YSlcXG5cXG4gICAgZGVmIGdldF9uZXh0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG5leHQgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX25leHRcXG5cXG4gICAgZGVmIHNldF9uZXh0KHNlbGYsIG5vZGVfbmV4dCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbmV4dCBub2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9uZXh0ID0gbm9kZV9uZXh0XFxuXFxuICAgIG5leHQgPSBwcm9wZXJ0eShnZXRfbmV4dCwgc2V0X25leHQpXFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU3RyaW5nXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc3RyKHNlbGYuX2RhdGEpXFxuXFxuXFxuY2xhc3MgTGlua2VkTGlzdDpcXG4gICAgXFxcIlxcXCJcXFwiTGlua2VkIExpc3QgY2xhc3MgaW1wbGVtZW50YXRpb25cXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIGEgbGlua2VkIGxpc3RcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2hlYWQgPSBOb25lXFxuICAgICAgICBzZWxmLl9jb3VudCA9IDBcXG5cXG4gICAgZGVmIGlzX2VtcHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSXMgdGhlIGxpc3QgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9oZWFkIGlzIE5vbmVcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaXplIG9mIHRoZSBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY291bnRcXG5cXG4gICAgZGVmIF9fbGVuX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaXplIG9mIHRoZSBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY291bnRcXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJMaXN0IGFzIGEgc3RyaW5nXFxcIlxcXCJcXFwiXFxuICAgICAgICBsaXN0X3N0ciA9IFxcXCJbXFxcIlxcbiAgICAgICAgY3VycmVudCA9IHNlbGYuX2hlYWRcXG5cXG4gICAgICAgIHdoaWxlIGN1cnJlbnQ6XFxuICAgICAgICAgICAgbGlzdF9zdHIgKz0gc3RyKGN1cnJlbnQpXFxuICAgICAgICAgICAgaWYgY3VycmVudC5uZXh0OlxcbiAgICAgICAgICAgICAgICBsaXN0X3N0ciArPSBcXFwiLCBcXFwiXFxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFxcbiAgICAgICAgbGlzdF9zdHIgKz0gXFxcIl1cXFwiXFxuICAgICAgICByZXR1cm4gbGlzdF9zdHJcXG5cXG4gICAgZGVmIGFkZChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcGFzc1xcblxcbiAgICBkZWYgcmVtb3ZlKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBwYXNzXFxuXFxuICAgIGRlZiBzZWFyY2goc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2VhcmNoIGZvciBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBwYXNzXFxuXFxuXFxuY2xhc3MgVW5vcmRlcmVkTGlzdChMaW5rZWRMaXN0KTpcXG4gICAgXFxcIlxcXCJcXFwiVW5vcmRlcmVkIGxpbmtlZCBsaXN0IGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhbiB1bm9yZGVyZWQgbGlua2VkIGxpc3RcXFwiXFxcIlxcXCJcXG4gICAgICAgIExpbmtlZExpc3QuX19pbml0X18oc2VsZilcXG5cXG4gICAgZGVmIGFkZChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgbmV3X25vZGUgPSBMaW5rZWRMaXN0Tm9kZSh2YWx1ZSlcXG4gICAgICAgIG5ld19ub2RlLnNldF9uZXh0KHNlbGYuX2hlYWQpXFxuICAgICAgICBzZWxmLl9oZWFkID0gbmV3X25vZGVcXG4gICAgICAgIHNlbGYuX2NvdW50ID0gc2VsZi5fY291bnQgKyAxXFxuXFxuICAgIGRlZiByZW1vdmUoc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGEgbm9kZSB3aXRoIGEgc3BlY2lmaWMgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLl9oZWFkXFxuICAgICAgICBwcmV2ID0gTm9uZVxcblxcbiAgICAgICAgd2hpbGUgY3VycmVudDpcXG4gICAgICAgICAgICBpZiBjdXJyZW50LmRhdGEgPT0gdmFsdWU6XFxuICAgICAgICAgICAgICAgIGlmIHByZXYgaXMgTm9uZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hlYWQgPSBjdXJyZW50Lm5leHRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IGN1cnJlbnQubmV4dFxcbiAgICAgICAgICAgICAgICBzZWxmLl9jb3VudCA9IHNlbGYuX2NvdW50IC0gMVxcbiAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudFxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcInt9IGlzIG5vdCBpbiB0aGUgbGlzdFxcXCIuZm9ybWF0KHZhbHVlKSlcXG5cXG4gICAgZGVmIHNlYXJjaChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZWFyY2ggZm9yIGEgbm9kZSB3aXRoIGEgc3BlY2lmaWMgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLl9oZWFkXFxuXFxuICAgICAgICB3aGlsZSBjdXJyZW50OlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnQuZGF0YSA9PSB2YWx1ZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0XFxuICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG5cXG5jbGFzcyBPcmRlcmVkTGlzdChMaW5rZWRMaXN0KTpcXG4gICAgXFxcIlxcXCJcXFwiT3JkZXJlZCBsaW5rZWQgbGlzdCBpbXBsZW1lbnRhdGlvblxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgYW4gT3JkZXJlZCBsaW5rZWQgbGlzdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgTGlua2VkTGlzdC5fX2luaXRfXyhzZWxmKVxcblxcbiAgICBkZWYgYWRkKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhIG5ldyBub2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBjdXJyZW50ID0gc2VsZi5faGVhZFxcbiAgICAgICAgcHJldiA9IE5vbmVcXG4gICAgICAgIG5ld19ub2RlID0gTGlua2VkTGlzdE5vZGUodmFsdWUpXFxuXFxuICAgICAgICB3aGlsZSBjdXJyZW50IGFuZCBjdXJyZW50LmRhdGEgPCB2YWx1ZTpcXG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudFxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcXG5cXG4gICAgICAgIGlmIHByZXYgaXMgTm9uZTpcXG4gICAgICAgICAgICBuZXdfbm9kZS5uZXh0ID0gc2VsZi5faGVhZFxcbiAgICAgICAgICAgIHNlbGYuX2hlYWQgPSBuZXdfbm9kZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBuZXdfbm9kZS5uZXh0ID0gY3VycmVudFxcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld19ub2RlXFxuICAgICAgICBzZWxmLl9jb3VudCA9IHNlbGYuX2NvdW50ICsgMVxcblxcbiAgICBkZWYgcmVtb3ZlKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICAjIFRoaXMgaXMgYW4gZXhlcmNpc2VcXG4gICAgICAgIHBhc3NcXG5cXG4gICAgZGVmIHNlYXJjaChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZWFyY2ggZm9yIGEgbm9kZSB3aXRoIGEgc3BlY2lmaWMgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgICMgVGhpcyBpcyBhbiBleGVyY2lzZVxcbiAgICAgICAgcGFzc1xcblwiLFwic3JjL2xpYi9weXRob25kczMvYmFzaWMvcXVldWUucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuXFxuY2xhc3MgUXVldWU6XFxuICAgIFxcXCJcXFwiXFxcIlF1ZXVlIGltcGxlbWVudGF0aW9uIGFzIGEgbGlzdFxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgbmV3IHF1ZXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBpc19lbXB0eShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIG5vdCBib29sKHNlbGYuX2l0ZW1zKVxcblxcbiAgICBkZWYgZW5xdWV1ZShzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhbiBpdGVtIHRvIHRoZSBxdWV1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faXRlbXMuaW5zZXJ0KDAsIGl0ZW0pXFxuXFxuICAgIGRlZiBkZXF1ZXVlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgcXVldWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBxdWV1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLl9pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2Jhc2ljL3N0YWNrLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIFN0YWNrOlxcbiAgICBcXFwiXFxcIlxcXCJTdGFjayBpbXBsZW1lbnRhdGlvbiBhcyBhIGxpc3RcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyBzdGFja1xcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgc3RhY2sgaXMgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgYm9vbChzZWxmLl9pdGVtcylcXG5cXG4gICAgZGVmIHB1c2goc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaXRlbSB0byB0aGUgc3RhY2tcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zLmFwcGVuZChpdGVtKVxcblxcbiAgICBkZWYgcG9wKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgc3RhY2tcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgcGVlayhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCB0aGUgdmFsdWUgb2YgdGhlIHRvcCBpdGVtIGluIHRoZSBzdGFja1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2l0ZW1zWy0xXVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdGFja1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLl9pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2dyYXBocy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5ncmFwaHMgaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcbmZyb20gcHl0aG9uZHMzLmdyYXBocy5hZGphY2VuY3lfZ3JhcGggaW1wb3J0IEdyYXBoXFxuZnJvbSBweXRob25kczMuZ3JhcGhzLmFkamFjZW5jeV9ncmFwaCBpbXBvcnQgVmVydGV4XFxuXFxuX19hbGxfXyA9IFtcXFwiR3JhcGhcXFwiXVxcblwiLFwic3JjL2xpYi9weXRob25kczMvZ3JhcGhzL2FkamFjZW5jeV9ncmFwaC5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5pbXBvcnQgaGVhcHFcXG5pbXBvcnQgc3lzXFxuXFxuXFxuY2xhc3MgVmVydGV4OlxcbiAgICBcXFwiXFxcIlxcXCJHcmFwaCB2ZXJ0ZXggY2xhc3NcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgbmV3IHZlcnRleFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fa2V5ID0ga2V5XFxuICAgICAgICBzZWxmLl9uZWlnaGJvcnMgPSB7fVxcbiAgICAgICAgc2VsZi5fY29sb3IgPSBcXFwid2hpdGVcXFwiXFxuICAgICAgICBzZWxmLl9kaXN0YW5jZSA9IHN5cy5tYXhzaXplXFxuICAgICAgICBzZWxmLl9wcmV2aW91cyA9IE5vbmVcXG4gICAgICAgIHNlbGYuX2Rpc2NvdmVyeV90aW1lID0gMFxcbiAgICAgICAgc2VsZi5fY2xvc2luZ190aW1lID0gMFxcblxcbiAgICBkZWYgX19sdF9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkxlc3MgdGhhbiBvcGVyYXRvciByZXF1aXJlZCBmb3IgaGVhcGlmeVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYua2V5IDwgb3RoZXIua2V5XFxuXFxuICAgIGRlZiBnZXRfa2V5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHZlcnRleCBrZXlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9rZXlcXG5cXG4gICAga2V5ID0gcHJvcGVydHkoZ2V0X2tleSlcXG5cXG4gICAgZGVmIGdldF9uZWlnaGJvcihzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIGRpc3RhbmNlIChlZGdlIHdlaWdodCkgdG8gYW4gYWRqYWNlbnQgbm9kZSAobmVpZ2hib3IpXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fbmVpZ2hib3JzLmdldChvdGhlciwgTm9uZSlcXG5cXG4gICAgZGVmIHNldF9uZWlnaGJvcihzZWxmLCBvdGhlciwgd2VpZ2h0PTApOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHRoZSBkaXN0YW5jZSAoYWRkIGFuIGVkZ2UpIHRvIGFuIGFkamFjZW50IG5vZGUgKG5laWdoYm9yKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fbmVpZ2hib3JzW290aGVyXSA9IHdlaWdodFxcblxcbiAgICBkZWYgZ2V0X25laWdoYm9ycyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBhbGwgYWRqYWNlbnQgbm9kZXMgKG5laWdoYm9ycylcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9uZWlnaGJvcnMua2V5cygpXFxuXFxuICAgIGRlZiBnZXRfY29sb3Ioc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdmVydGV4IGNvbG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY29sb3JcXG5cXG4gICAgZGVmIHNldF9jb2xvcihzZWxmLCBjb2xvcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgdmVydGV4IGNvbG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9jb2xvciA9IGNvbG9yXFxuXFxuICAgIGNvbG9yID0gcHJvcGVydHkoZ2V0X2NvbG9yLCBzZXRfY29sb3IpXFxuXFxuICAgIGRlZiBnZXRfZGlzdGFuY2Uoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgZGlzdGFuY2VcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9kaXN0YW5jZVxcblxcbiAgICBkZWYgc2V0X2Rpc3RhbmNlKHNlbGYsIGRpc3RhbmNlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBkaXN0YW5jZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fZGlzdGFuY2UgPSBkaXN0YW5jZVxcblxcbiAgICBkaXN0YW5jZSA9IHByb3BlcnR5KGdldF9kaXN0YW5jZSwgc2V0X2Rpc3RhbmNlKVxcblxcbiAgICBkZWYgZ2V0X3ByZXZpb3VzKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHByZXZpb3VzXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcHJldmlvdXNcXG5cXG4gICAgZGVmIHNldF9wcmV2aW91cyhzZWxmLCBwcmV2aW91cyk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgcHJldmlvdXNcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3ByZXZpb3VzID0gcHJldmlvdXNcXG5cXG4gICAgcHJldmlvdXMgPSBwcm9wZXJ0eShnZXRfcHJldmlvdXMsIHNldF9wcmV2aW91cylcXG5cXG4gICAgZGVmIGdldF9kaXNjb3ZlcnlfdGltZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBkaXNjb3ZlcnkgdGltZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2Rpc2NvdmVyeV90aW1lXFxuXFxuICAgIGRlZiBzZXRfZGlzY292ZXJ5X3RpbWUoc2VsZiwgZGlzY292ZXJ5X3RpbWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IGRpc2NvdmVyeSB0aW1lXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9kaXNjb3ZlcnlfdGltZSA9IGRpc2NvdmVyeV90aW1lXFxuXFxuICAgIGRpc2NvdmVyeV90aW1lID0gcHJvcGVydHkoZ2V0X2Rpc2NvdmVyeV90aW1lLCBzZXRfZGlzY292ZXJ5X3RpbWUpXFxuXFxuICAgIGRlZiBnZXRfY2xvc2luZ190aW1lKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGNsb3NpbmcgdGltZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2Nsb3NpbmdfdGltZVxcblxcbiAgICBkZWYgc2V0X2Nsb3NpbmdfdGltZShzZWxmLCBjbG9zaW5nX3RpbWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IGNsb3NpbmcgdGltZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY2xvc2luZ190aW1lID0gY2xvc2luZ190aW1lXFxuXFxuICAgIGNsb3NpbmdfdGltZSA9IHByb3BlcnR5KGdldF9jbG9zaW5nX3RpbWUsIHNldF9jbG9zaW5nX3RpbWUpXFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIFxcXCJ7Ol44fXx7Ol44fXx7Ol44fXx7Ol44fXx7Ol44fXwge31cXFwiLmZvcm1hdChcXG4gICAgICAgICAgICBzZWxmLl9rZXksXFxuICAgICAgICAgICAgc2VsZi5fY29sb3IsXFxuICAgICAgICAgICAgc2VsZi5fZGlzdGFuY2UsXFxuICAgICAgICAgICAgc2VsZi5fZGlzY292ZXJ5X3RpbWUsXFxuICAgICAgICAgICAgc2VsZi5fY2xvc2luZ190aW1lLFxcbiAgICAgICAgICAgIHNlbGYuX3ByZXZpb3VzLFxcbiAgICAgICAgKVxcblxcblxcbmNsYXNzIEdyYXBoOlxcbiAgICBcXFwiXFxcIlxcXCJHcmFwaCBhcyBhbiBhZGphY2VuY3kgbWF0cml4XFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuX3ZlcnRpY2VzID0ge31cXG4gICAgICAgIHNlbGYuX2VkZ2VzID0ge31cXG4gICAgICAgIHNlbGYuX3RpbWUgPSAwXFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkl0ZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gaXRlcihzZWxmLl92ZXJ0aWNlcy52YWx1ZXMoKSlcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHcmFwaCdzIHNpemVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5fdmVydGljZXMpXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR3JhcGgncyBzaXplXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuX3ZlcnRpY2VzKVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJpbiBvcGVyYXRvciBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGtleSBpbiBzZWxmLl92ZXJ0aWNlc1xcblxcbiAgICBkZWYgZ2V0X3ZlcnRleChzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmluZCB0aGUgdmVydGV4IGluIHRoZSBncmFwaCBuYW1lZCB2ZXJ0X2tleVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZlcnRpY2VzLmdldChrZXksIE5vbmUpXFxuXFxuICAgIGRlZiBzZXRfdmVydGV4KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaW5zdGFuY2Ugb2YgVmVydGV4IHRvIHRoZSBncmFwaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fdmVydGljZXNba2V5XSA9IFZlcnRleChrZXkpXFxuXFxuICAgIGRlZiBhZGRfZWRnZShzZWxmLCBmcm9tX3ZlcnRleCwgdG9fdmVydGV4LCB3ZWlnaHQ9MCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSB3ZWlnaHRlZCBhbmQgZGlyZWN0ZWQgZWRnZSB0byB0aGUgZ3JhcGhcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGZyb21fdmVydGV4IG5vdCBpbiBzZWxmLl92ZXJ0aWNlczpcXG4gICAgICAgICAgICBzZWxmLnNldF92ZXJ0ZXgoZnJvbV92ZXJ0ZXgpXFxuICAgICAgICBpZiB0b192ZXJ0ZXggbm90IGluIHNlbGYuX3ZlcnRpY2VzOlxcbiAgICAgICAgICAgIHNlbGYuc2V0X3ZlcnRleCh0b192ZXJ0ZXgpXFxuICAgICAgICBzZWxmLl92ZXJ0aWNlc1tmcm9tX3ZlcnRleF0uc2V0X25laWdoYm9yKHNlbGYuX3ZlcnRpY2VzW3RvX3ZlcnRleF0sIHdlaWdodClcXG4gICAgICAgIHNlbGYuX2VkZ2VzWyhmcm9tX3ZlcnRleCwgdG9fdmVydGV4KV0gPSB3ZWlnaHRcXG5cXG4gICAgZGVmIGdldF92ZXJ0aWNlcyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgbGlzdCBvZiBhbGwgdmVydGljZXMgaW4gdGhlIGdyYXBoXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fdmVydGljZXMua2V5cygpXFxuXFxuICAgIGRlZiBnZXRfZWRnZXMoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIGVkZ2VzIGluIHRoZSBncmFwaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2VkZ2VzLmtleXMoKVxcblxcbiAgICBkZWYgcmVzZXRfZGlzdGFuY2VzKHNlbGYsIGRlZmF1bHRfZGlzdGFuY2U9c3lzLm1heHNpemUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVzZXQgZGlzdGFuY2VzIHRvIHRlc3QgRGlqa3N0cmEnc1xcXCJcXFwiXFxcIlxcbiAgICAgICAgZm9yIHZlcnRleCBpbiBzZWxmOlxcbiAgICAgICAgICAgIHZlcnRleC5kaXN0YW5jZSA9IGRlZmF1bHRfZGlzdGFuY2VcXG5cXG4gICAgZGVmIGJmcyhzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJCcmVhZHRoIEZpcnN0IFNlYXJjaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc3RhcnQuZGlzdGFuY2UgPSAwXFxuICAgICAgICBzdGFydC5wcmV2aW91cyA9IE5vbmVcXG4gICAgICAgIHZlcnRfcXVldWUgPSBbc3RhcnRdXFxuICAgICAgICB3aGlsZSB2ZXJ0X3F1ZXVlOlxcbiAgICAgICAgICAgIGN1cnJlbnRfdmVydCA9IHZlcnRfcXVldWUucG9wKDApXFxuICAgICAgICAgICAgZm9yIG5laWdoIGluIGN1cnJlbnRfdmVydC5nZXRfbmVpZ2hib3JzKCk6XFxuICAgICAgICAgICAgICAgIGlmIG5laWdoLmNvbG9yID09IFxcXCJ3aGl0ZVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICBuZWlnaC5jb2xvciA9IFxcXCJncmF5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2guZGlzdGFuY2UgPSBjdXJyZW50X3ZlcnQuZGlzdGFuY2UgKyAxXFxuICAgICAgICAgICAgICAgICAgICBuZWlnaC5wcmV2aW91cyA9IGN1cnJlbnRfdmVydFxcbiAgICAgICAgICAgICAgICAgICAgdmVydF9xdWV1ZS5hcHBlbmQobmVpZ2gpXFxuICAgICAgICAgICAgY3VycmVudF92ZXJ0LmNvbG9yID0gXFxcImJsYWNrXFxcIlxcblxcbiAgICBkZWYgZGZzKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRGVwdGggRmlyc3Qgc2VhcmNoXFxcIlxcXCJcXFwiXFxuICAgICAgICBmb3IgdmVydGV4IGluIHNlbGY6XFxuICAgICAgICAgICAgaWYgdmVydGV4LmNvbG9yID09IFxcXCJ3aGl0ZVxcXCI6XFxuICAgICAgICAgICAgICAgIHNlbGYuZGZzX3Zpc2l0KHZlcnRleClcXG5cXG4gICAgZGVmIGRmc192aXNpdChzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJERlMgaGVscGVyIGZ1bmN0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdGFydC5jb2xvciA9IFxcXCJncmF5XFxcIlxcbiAgICAgICAgc2VsZi5fdGltZSA9IHNlbGYuX3RpbWUgKyAxXFxuICAgICAgICBzdGFydC5kaXNjb3ZlcnlfdGltZSA9IHNlbGYuX3RpbWVcXG4gICAgICAgIGZvciBuZXh0X3ZlcnRleCBpbiBzdGFydC5nZXRfbmVpZ2hib3JzKCk6XFxuICAgICAgICAgICAgaWYgbmV4dF92ZXJ0ZXguY29sb3IgPT0gXFxcIndoaXRlXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dF92ZXJ0ZXguc2V0X3ByZXZpb3VzKHN0YXJ0KVxcbiAgICAgICAgICAgICAgICBzZWxmLmRmc192aXNpdChuZXh0X3ZlcnRleClcXG4gICAgICAgIHN0YXJ0LmNvbG9yID0gXFxcImJsYWNrXFxcIlxcbiAgICAgICAgc2VsZi5fdGltZSA9IHNlbGYuX3RpbWUgKyAxXFxuICAgICAgICBzdGFydC5jbG9zaW5nX3RpbWUgPSBzZWxmLl90aW1lXFxuXFxuICAgIGRlZiB0cmF2ZXJzZShzZWxmLCBzcmMsIGRzdCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJUcmF2ZXJzZSBhIGdyYXBoXFxcIlxcXCJcXFwiXFxuICAgICAgICBwYXRoID0gW11cXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLmdldF92ZXJ0ZXgoZHN0KVxcbiAgICAgICAgd2hpbGUgY3VycmVudDpcXG4gICAgICAgICAgICBwYXRoLmFwcGVuZChjdXJyZW50KVxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzXFxuICAgICAgICBwcmludChcXG4gICAgICAgICAgICBcXFwiUGF0aCBmcm9tIHt9IHRvIHt9ICh7fSk6IHt9XFxcIi5mb3JtYXQoXFxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChzcmMpLmtleSxcXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRfdmVydGV4KGRzdCkua2V5LFxcbiAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZHN0KS5kaXN0YW5jZSxcXG4gICAgICAgICAgICAgICAgXFxcIiBcXFwiLmpvaW4odmVydGV4LmtleSBmb3IgdmVydGV4IGluIHJldmVyc2VkKHBhdGgpKSxcXG4gICAgICAgICAgICApXFxuICAgICAgICApXFxuXFxuICAgIGRlZiBkaWprc3RyYShzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJEaWprc3RyYSdzIHNob3J0ZXN0IHBhdGggYWxnb3JpdGhtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdGFydC5kaXN0YW5jZSA9IDBcXG4gICAgICAgIG5vdF95ZXRfdmlzaXRlZCA9IFtbc3RhcnQuZGlzdGFuY2UsIHN0YXJ0XV1cXG4gICAgICAgIGhlYXBxLmhlYXBpZnkobm90X3lldF92aXNpdGVkKVxcbiAgICAgICAgd2hpbGUgbm90X3lldF92aXNpdGVkOlxcbiAgICAgICAgICAgIGN1cnJlbnRfdmVydGV4ID0gaGVhcHEuaGVhcHBvcChub3RfeWV0X3Zpc2l0ZWQpWzFdXFxuICAgICAgICAgICAgZm9yIG5leHRfdmVydGV4IGluIGN1cnJlbnRfdmVydGV4LmdldF9uZWlnaGJvcnMoKTpcXG4gICAgICAgICAgICAgICAgbmV3X2Rpc3RhbmNlID0gY3VycmVudF92ZXJ0ZXguZGlzdGFuY2UgKyBjdXJyZW50X3ZlcnRleC5nZXRfbmVpZ2hib3IoXFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3ZlcnRleFxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIGlmIG5ld19kaXN0YW5jZSA8IG5leHRfdmVydGV4LmRpc3RhbmNlOlxcbiAgICAgICAgICAgICAgICAgICAgbmV4dF92ZXJ0ZXguZGlzdGFuY2UgPSBuZXdfZGlzdGFuY2VcXG4gICAgICAgICAgICAgICAgICAgIG5leHRfdmVydGV4LnByZXZpb3VzID0gY3VycmVudF92ZXJ0ZXhcXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gRmFsc2VcXG4gICAgICAgICAgICAgICAgICAgIGZvciB2ZXJ0ZXggaW4gbm90X3lldF92aXNpdGVkOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHZlcnRleFsxXS5rZXkgPT0gbmV4dF92ZXJ0ZXgua2V5OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhbMF0gPSBuZXh0X3ZlcnRleC5kaXN0YW5jZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFwcS5oZWFwaWZ5KG5vdF95ZXRfdmlzaXRlZClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBUcnVlXFxuICAgICAgICAgICAgICAgICAgICBpZiBub3QgZm91bmQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdF95ZXRfdmlzaXRlZCwgW25leHRfdmVydGV4LmRpc3RhbmNlLCBuZXh0X3ZlcnRleF1cXG4gICAgICAgICAgICAgICAgICAgICAgICApXFxuXFxuICAgIGRlZiBiZWxsbWFuX2ZvcmQoc2VsZiwgc3RhcnQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQmVsbG1hbi1Gb3JkIHNob3J0ZXN0IHBhdGggYWxnb3JpdGhtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdGFydC5kaXN0YW5jZSA9IDBcXG4gICAgICAgIGZvciBfIGluIHJhbmdlKGxlbihzZWxmLl92ZXJ0aWNlcykpOlxcbiAgICAgICAgICAgIGZvciBlZGdlIGluIHNlbGYuX2VkZ2VzOlxcbiAgICAgICAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZWRnZVswXSkuZGlzdGFuY2UgKyBzZWxmLl9lZGdlc1tlZGdlXVxcbiAgICAgICAgICAgICAgICAgICAgPCBzZWxmLmdldF92ZXJ0ZXgoZWRnZVsxXSkuZGlzdGFuY2VcXG4gICAgICAgICAgICAgICAgKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChlZGdlWzFdKS5kaXN0YW5jZSA9IChcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZWRnZVswXSkuZGlzdGFuY2UgKyBzZWxmLl9lZGdlc1tlZGdlXVxcbiAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRfdmVydGV4KGVkZ2VbMV0pLnByZXZpb3VzID0gc2VsZi5nZXRfdmVydGV4KGVkZ2VbMF0pXFxuICAgICAgICBmb3IgZWRnZSBpbiBzZWxmLl9lZGdlczpcXG4gICAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChlZGdlWzBdKS5kaXN0YW5jZSArIHNlbGYuX2VkZ2VzW2VkZ2VdXFxuICAgICAgICAgICAgICAgIDwgc2VsZi5nZXRfdmVydGV4KGVkZ2VbMV0pLmRpc3RhbmNlXFxuICAgICAgICAgICAgKTpcXG4gICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZS13ZWlnaHQgY3ljbGVcXFwiKVxcblxcbiAgICBkZWYgcHJpbShzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQcmltJ3Mgc3Bhbm5pbmcgdHJlZSBhbGdvcml0aG1cXFwiXFxcIlxcXCJcXG4gICAgICAgIHN0YXJ0LmRpc3RhbmNlID0gMFxcbiAgICAgICAgbm90X2luX2FfdHJlZSA9IFtbdmVydGV4LmRpc3RhbmNlLCB2ZXJ0ZXhdIGZvciB2ZXJ0ZXggaW4gc2VsZl1cXG4gICAgICAgIGhlYXBxLmhlYXBpZnkobm90X2luX2FfdHJlZSlcXG4gICAgICAgIHdoaWxlIG5vdF9pbl9hX3RyZWU6XFxuICAgICAgICAgICAgY3VycmVudF92ZXJ0ZXggPSBoZWFwcS5oZWFwcG9wKG5vdF9pbl9hX3RyZWUpWzFdXFxuICAgICAgICAgICAgZm9yIG5leHRfdmVydGV4IGluIGN1cnJlbnRfdmVydGV4LmdldF9uZWlnaGJvcnMoKTpcXG4gICAgICAgICAgICAgICAgbmV3X2Rpc3RhbmNlID0gY3VycmVudF92ZXJ0ZXguZ2V0X25laWdoYm9yKG5leHRfdmVydGV4KVxcbiAgICAgICAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgICAgICAgICBhbnkoaXRlbVsxXSA9PSBuZXh0X3ZlcnRleCBmb3IgaXRlbSBpbiBub3RfaW5fYV90cmVlKVxcbiAgICAgICAgICAgICAgICAgICAgYW5kIG5ld19kaXN0YW5jZSA8IG5leHRfdmVydGV4LmRpc3RhbmNlXFxuICAgICAgICAgICAgICAgICk6XFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3ZlcnRleC5wcmV2aW91cyA9IGN1cnJlbnRfdmVydGV4XFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3ZlcnRleC5kaXN0YW5jZSA9IG5ld19kaXN0YW5jZVxcbiAgICAgICAgICAgICAgICAgICAgZm9yIGl0ZW0gaW4gbm90X2luX2FfdHJlZTpcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBpdGVtWzFdID09IG5leHRfdmVydGV4OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtWzBdID0gbmV3X2Rpc3RhbmNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBpZnkobm90X2luX2FfdHJlZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2ludHJvL19faW5pdF9fLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxucHl0aG9uZHMzLmludHJvIGltcG9ydCBzdGF0ZW1lbnRcXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHB5dGhvbmRzMy5pbnRyby5vb3AgaW1wb3J0IEZyYWN0aW9uXFxuXFxuX19hbGxfXyA9IFtcXFwiRnJhY3Rpb25cXFwiXVxcblwiLFwic3JjL2xpYi9weXRob25kczMvaW50cm8vb29wLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmRlZiBnY2QobnVtYmVyMSwgbnVtYmVyMik6XFxuICAgIFxcXCJcXFwiXFxcIkhlbHBlciBmdW5jdGlvbiB0byBzaW1wbGlmeSBmcmFjdGlvbnNcXFwiXFxcIlxcXCJcXG4gICAgaWYgbm90IGlzaW5zdGFuY2UobnVtYmVyMSwgaW50KSBvciBub3QgaXNpbnN0YW5jZShudW1iZXIyLCBpbnQpOlxcbiAgICAgICAgcmFpc2UgVHlwZUVycm9yKFxcXCJOdW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yIG11c3QgYmUgaW50ZWdlcnNcXFwiKVxcbiAgICB3aGlsZSBudW1iZXIxICUgbnVtYmVyMjpcXG4gICAgICAgIG51bWJlcjEsIG51bWJlcjIgPSBudW1iZXIyLCBudW1iZXIxICUgbnVtYmVyMlxcbiAgICByZXR1cm4gbnVtYmVyMlxcblxcblxcbmNsYXNzIEZyYWN0aW9uOlxcbiAgICBcXFwiXFxcIlxcXCJGcmFjdGlvbiBjbGFzc1xcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbmV3X251bWVyLCBuZXdfZGVub20pOlxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGNvbW1vbiA9IGdjZChuZXdfbnVtZXIsIG5ld19kZW5vbSlcXG4gICAgICAgIGV4Y2VwdCBUeXBlRXJyb3I6XFxuICAgICAgICAgICAgcmFpc2VcXG4gICAgICAgIHNlbGYuX251bWVyID0gbmV3X251bWVyIC8vIGNvbW1vblxcbiAgICAgICAgc2VsZi5fZGVub20gPSBuZXdfZGVub20gLy8gY29tbW9uXFxuXFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgbnVtZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgbnVtZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fbnVtZXJcXG5cXG4gICAgQG51bWVyLnNldHRlclxcbiAgICBkZWYgc2V0X251bWVyKHNlbGYsIG5ld19udW1lcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbnVtZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9udW1lciA9IG5ld19udW1lclxcblxcbiAgICBkZWYgZ2V0X2Rlbm9tKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGRlbmltaW5hdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fZGVub21cXG5cXG4gICAgZGVmIHNldF9kZW5vbShzZWxmLCBuZXdfZGVub20pOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IGRlbmltaW5hdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9kZW5vbSA9IG5ld19kZW5vbVxcblxcbiAgICAjIEFub3RoZXIgd2F5IHRvIGNyZWF0ZSBhbiBhdHRyaWJ1dGVcXG4gICAgZGVub20gPSBwcm9wZXJ0eShnZXRfZGVub20sIHNldF9kZW5vbSlcXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIHN0cmluZyB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fbnVtZXIgPiBzZWxmLl9kZW5vbTpcXG4gICAgICAgICAgICByZXR1cm4gXFxcInt9IHt9L3t9XFxcIi5mb3JtYXQoXFxuICAgICAgICAgICAgICAgIHNlbGYuX251bWVyIC8vIHNlbGYuX2Rlbm9tLCBzZWxmLl9udW1lciAlIHNlbGYuX2Rlbm9tLCBzZWxmLl9kZW5vbVxcbiAgICAgICAgICAgIClcXG4gICAgICAgIHJldHVybiBcXFwie30ve31cXFwiLmZvcm1hdChzZWxmLl9udW1lciwgc2VsZi5fZGVub20pXFxuXFxuICAgIGRlZiBfX3JlcHJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZyYWN0aW9uIHJlcHJlc2VudGF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gXFxcIkZyYWN0aW9uKHt9LCB7fSlcXFwiLmZvcm1hdChzZWxmLl9udW1lciwgc2VsZi5fZGVub20pXFxuXFxuICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRXF1YWxpdHkgY29tcGFyaXNvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX251bWVyICogb3RoZXIuZGVub20gPT0gb3RoZXIubnVtZXIgKiBzZWxmLl9kZW5vbVxcblxcbiAgICBkZWYgX19hZGRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgdHdvIGZyYWN0aW9uc1xcXCJcXFwiXFxcIlxcbiAgICAgICAgbmV3X251bWVyID0gc2VsZi5fbnVtZXIgKiBvdGhlci5kZW5vbSArIHNlbGYuX2Rlbm9tICogb3RoZXIubnVtZXJcXG4gICAgICAgIG5ld19kZW5vbSA9IHNlbGYuX2Rlbm9tICogb3RoZXIuZGVub21cXG4gICAgICAgIHJldHVybiBGcmFjdGlvbihuZXdfbnVtZXIsIG5ld19kZW5vbSlcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3NlYXJjaGluZy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5zZWFyY2ggaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcbmZyb20gcHl0aG9uZHMzLnNlYXJjaGluZy5oYXNoX3RhYmxlIGltcG9ydCBIYXNoVGFibGVcXG5cXG5fX2FsbF9fID0gW1xcXCJIYXNoVGFibGVcXFwiXVxcblwiLFwic3JjL2xpYi9weXRob25kczMvc2VhcmNoaW5nL2hhc2hfdGFibGUucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuXFxuY2xhc3MgSGFzaFRhYmxlOlxcbiAgICBcXFwiXFxcIlxcXCJIYXNoIFRhYmxlIGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBzaXplPTE2KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhIGhhc2ggdGFibGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3NpemUgPSBzaXplXFxuICAgICAgICBzZWxmLl9zbG90cyA9IFtOb25lXSAqIHNlbGYuX3NpemVcXG4gICAgICAgIHNlbGYuX2RhdGEgPSBbTm9uZV0gKiBzZWxmLl9zaXplXFxuXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTWFnaWMgX19nZXRfX1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0KGtleSlcXG5cXG4gICAgZGVmIF9fc2V0aXRlbV9fKHNlbGYsIGtleSwgZGF0YSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJNYWdpYyBfX3NldF9fXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLnB1dChrZXksIGRhdGEpXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTWFnaWMgX19sZW5fX1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NpemUgLSBzZWxmLl9zbG90cy5jb3VudChOb25lKVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJNYWdpbiBpblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGtleSBpbiBzZWxmLl9zbG90c1xcblxcbiAgICBkZWYgX2hhc2hfZnVuY3Rpb24oc2VsZiwga2V5LCBzaXplKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNpbXBsZSBoYXNoIGZ1bmN0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4ga2V5ICUgc2l6ZVxcblxcbiAgICBkZWYgX3JlaGFzaChzZWxmLCBvbGRfaGFzaCwgc2l6ZSwgc3RlcD0xKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNpbXBsZSByZWhhc2ggZnVuY3Rpb25cXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiAob2xkX2hhc2ggKyBzdGVwKSAlIHNpemVcXG5cXG4gICAgZGVmIGlzX2VtcHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIHRhYmxlIGlzIGVtcHR5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fc2l6ZSA9PSBzZWxmLl9zbG90cy5jb3VudChOb25lKVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRhYmxlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fc2l6ZSAtIHNlbGYuX3Nsb3RzLmNvdW50KE5vbmUpXFxuXFxuICAgIGRlZiBwdXQoc2VsZiwga2V5LCBkYXRhKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhbiBpdGVtIHRvIHRoZSB0YWJsZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaGFzaF92YWx1ZSA9IHNlbGYuX2hhc2hfZnVuY3Rpb24oa2V5LCBsZW4oc2VsZi5fc2xvdHMpKVxcblxcbiAgICAgICAgaWYgc2VsZi5fc2xvdHNbaGFzaF92YWx1ZV0gaXMgTm9uZTpcXG4gICAgICAgICAgICBzZWxmLl9zbG90c1toYXNoX3ZhbHVlXSA9IGtleVxcbiAgICAgICAgICAgIHNlbGYuX2RhdGFbaGFzaF92YWx1ZV0gPSBkYXRhXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHNlbGYuX3Nsb3RzW2hhc2hfdmFsdWVdID09IGtleTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fZGF0YVtoYXNoX3ZhbHVlXSA9IGRhdGEgICMgcmVwbGFjZVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGogPSAwXFxuICAgICAgICAgICAgICAgIG5leHRfc2xvdCA9IHNlbGYuX3JlaGFzaChoYXNoX3ZhbHVlLCBsZW4oc2VsZi5fc2xvdHMpLCBqKVxcbiAgICAgICAgICAgICAgICB3aGlsZSAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zbG90c1tuZXh0X3Nsb3RdIGlzIG5vdCBOb25lXFxuICAgICAgICAgICAgICAgICAgICBhbmQgc2VsZi5fc2xvdHNbbmV4dF9zbG90XSAhPSBrZXlcXG4gICAgICAgICAgICAgICAgICAgIGFuZCBqIDwgc2VsZi5fc2l6ZVxcbiAgICAgICAgICAgICAgICApOlxcbiAgICAgICAgICAgICAgICAgICAgaiA9IGogKyAxXFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3Nsb3QgPSBzZWxmLl9yZWhhc2goaGFzaF92YWx1ZSwgbGVuKHNlbGYuX3Nsb3RzKSwgailcXG5cXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5fc2xvdHNbbmV4dF9zbG90XSBpcyBOb25lOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2xvdHNbbmV4dF9zbG90XSA9IGtleVxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGF0YVtuZXh0X3Nsb3RdID0gZGF0YVxcbiAgICAgICAgICAgICAgICBlbGlmIGogPT0gc2VsZi5fc2l6ZTpcXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlIEV4Y2VwdGlvbihcXFwiSGFzaCBUYWJsZSBpcyBmdWxsXFxcIilcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RhdGFbbmV4dF9zbG90XSA9IGRhdGEgICMgcmVwbGFjZVxcblxcbiAgICBkZWYgZ2V0KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgYW4gaXRlbSBmcm9tIHRoZSB0YWJsZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc3RhcnRfc2xvdCA9IHNlbGYuX2hhc2hfZnVuY3Rpb24oa2V5LCBsZW4oc2VsZi5fc2xvdHMpKVxcbiAgICAgICAgcG9zaXRpb24gPSBzdGFydF9zbG90XFxuICAgICAgICBqID0gMFxcblxcbiAgICAgICAgd2hpbGUgc2VsZi5fc2xvdHNbcG9zaXRpb25dIGlzIG5vdCBOb25lIGFuZCBqIDwgc2VsZi5fc2l6ZTpcXG4gICAgICAgICAgICBpZiBzZWxmLl9zbG90c1twb3NpdGlvbl0gPT0ga2V5OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtwb3NpdGlvbl1cXG4gICAgICAgICAgICBqID0gaiArIDFcXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHNlbGYuX3JlaGFzaChzdGFydF9zbG90LCBsZW4oc2VsZi5fc2xvdHMpLCBqKVxcblxcbiAgICAgICAgcmFpc2UgS2V5RXJyb3IoXFxcInt9IGlzIG5vdCBpbiB0aGUgdGFibGVcXFwiLmZvcm1hdChrZXkpKVxcblwiLFwic3JjL2xpYi9weXRob25kczMvc29ydGluZy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5zb3J0aW5nIGltcG9ydCBzdGF0ZW1lbnRcXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgYnViYmxlX3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgc2VsZWN0X3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgaW5zZXJ0X3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgc2hlbGxfc29ydFxcbmZyb20gcHl0aG9uZHMzLnNvcnRpbmcuc29ydGluZ19hbGdvcml0aG1zIGltcG9ydCBtZXJnZV9zb3J0XFxuZnJvbSBweXRob25kczMuc29ydGluZy5zb3J0aW5nX2FsZ29yaXRobXMgaW1wb3J0IHF1aWNrX3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgaGVhcF9zb3J0XFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9zb3J0aW5nL3NvcnRpbmdfYWxnb3JpdGhtcy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5pbXBvcnQgaGVhcHFcXG5cXG5cXG5kZWYgYnViYmxlX3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiQnViYmxlIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgZm9yIGkgaW4gcmFuZ2UobGVuKGxzdCkgLSAxLCAwLCAtMSk6XFxuICAgICAgICBleGNoYW5nZXMgPSBGYWxzZVxcbiAgICAgICAgZm9yIGogaW4gcmFuZ2UoaSk6XFxuICAgICAgICAgICAgaWYgbHN0W2pdID4gbHN0W2ogKyAxXTpcXG4gICAgICAgICAgICAgICAgZXhjaGFuZ2VzID0gVHJ1ZVxcbiAgICAgICAgICAgICAgICBsc3Rbal0sIGxzdFtqICsgMV0gPSBsc3RbaiArIDFdLCBsc3Rbal1cXG4gICAgICAgIGlmIG5vdCBleGNoYW5nZXM6XFxuICAgICAgICAgICAgYnJlYWtcXG5cXG5cXG5kZWYgc2VsZWN0X3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiU2VsZWN0aW9uIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgZm9yIGksIGl0ZW0gaW4gZW51bWVyYXRlKGxzdCk6XFxuICAgICAgICBtaW5faWR4ID0gbGVuKGxzdCkgLSAxXFxuICAgICAgICBmb3IgaiBpbiByYW5nZShpLCBsZW4obHN0KSk6XFxuICAgICAgICAgICAgaWYgbHN0W2pdIDwgbHN0W21pbl9pZHhdOlxcbiAgICAgICAgICAgICAgICBtaW5faWR4ID0galxcbiAgICAgICAgaWYgbWluX2lkeCAhPSBpOlxcbiAgICAgICAgICAgIGxzdFttaW5faWR4XSwgbHN0W2ldID0gbHN0W2ldLCBsc3RbbWluX2lkeF1cXG5cXG5cXG5kZWYgaW5zZXJ0X3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiSW5zZXJ0aW9uIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKGxzdCkpOlxcbiAgICAgICAgY3VyX3ZhbCA9IGxzdFtpXVxcbiAgICAgICAgY3VyX3BvcyA9IGlcXG5cXG4gICAgICAgIHdoaWxlIGN1cl9wb3MgPiAwIGFuZCBsc3RbY3VyX3BvcyAtIDFdID4gY3VyX3ZhbDpcXG4gICAgICAgICAgICBsc3RbY3VyX3Bvc10gPSBsc3RbY3VyX3BvcyAtIDFdXFxuICAgICAgICAgICAgY3VyX3BvcyA9IGN1cl9wb3MgLSAxXFxuICAgICAgICBsc3RbY3VyX3Bvc10gPSBjdXJfdmFsXFxuXFxuXFxuZGVmIHNoZWxsX3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiU2hlbGwgc29ydFxcXCJcXFwiXFxcIlxcbiAgICBzdWJsaXN0X2NvdW50ID0gbGVuKGxzdCkgLy8gM1xcbiAgICB3aGlsZSBzdWJsaXN0X2NvdW50ID4gMDpcXG4gICAgICAgIGZvciBwb3Nfc3RhcnQgaW4gcmFuZ2Uoc3VibGlzdF9jb3VudCk6XFxuICAgICAgICAgICAgX2dhcF9pbnNlcnRfc29ydChsc3QsIHBvc19zdGFydCwgc3VibGlzdF9jb3VudClcXG4gICAgICAgIHN1Ymxpc3RfY291bnQgPSBzdWJsaXN0X2NvdW50IC8vIDJcXG5cXG5cXG5kZWYgX2dhcF9pbnNlcnRfc29ydChsc3QsIHN0YXJ0LCBnYXApOlxcbiAgICBcXFwiXFxcIlxcXCJTaGVsbCBzb3J0IGhlbHBlciBmdW5jdGlvblxcXCJcXFwiXFxcIlxcbiAgICBmb3IgaSBpbiByYW5nZShzdGFydCArIGdhcCwgbGVuKGxzdCksIGdhcCk6XFxuICAgICAgICBjdXJfdmFsID0gbHN0W2ldXFxuICAgICAgICBjdXJfcG9zID0gaVxcbiAgICAgICAgd2hpbGUgY3VyX3BvcyA+PSBnYXAgYW5kIGxzdFtjdXJfcG9zIC0gZ2FwXSA+IGN1cl92YWw6XFxuICAgICAgICAgICAgbHN0W2N1cl9wb3NdID0gbHN0W2N1cl9wb3MgLSBnYXBdXFxuICAgICAgICAgICAgY3VyX3BvcyA9IGN1cl9wb3MgLSBnYXBcXG4gICAgICAgIGxzdFtjdXJfcG9zXSA9IGN1cl92YWxcXG5cXG5cXG5kZWYgbWVyZ2Vfc29ydChsc3QpOlxcbiAgICBcXFwiXFxcIlxcXCJNZXJnZSBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIGlmIGxlbihsc3QpID4gMTpcXG4gICAgICAgIG1pZCA9IGxlbihsc3QpIC8vIDJcXG4gICAgICAgIGxlZnRfaGFsZiA9IGxzdFs6bWlkXVxcbiAgICAgICAgcmlnaHRfaGFsZiA9IGxzdFttaWQ6XVxcblxcbiAgICAgICAgbWVyZ2Vfc29ydChsZWZ0X2hhbGYpXFxuICAgICAgICBtZXJnZV9zb3J0KHJpZ2h0X2hhbGYpXFxuXFxuICAgICAgICBpLCBqLCBrID0gMCwgMCwgMFxcbiAgICAgICAgd2hpbGUgaSA8IGxlbihsZWZ0X2hhbGYpIGFuZCBqIDwgbGVuKHJpZ2h0X2hhbGYpOlxcbiAgICAgICAgICAgIGlmIGxlZnRfaGFsZltpXSA8PSByaWdodF9oYWxmW2pdOlxcbiAgICAgICAgICAgICAgICBsc3Rba10gPSBsZWZ0X2hhbGZbaV1cXG4gICAgICAgICAgICAgICAgaSA9IGkgKyAxXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgbHN0W2tdID0gcmlnaHRfaGFsZltqXVxcbiAgICAgICAgICAgICAgICBqID0gaiArIDFcXG4gICAgICAgICAgICBrID0gayArIDFcXG5cXG4gICAgICAgIHdoaWxlIGkgPCBsZW4obGVmdF9oYWxmKTpcXG4gICAgICAgICAgICBsc3Rba10gPSBsZWZ0X2hhbGZbaV1cXG4gICAgICAgICAgICBpID0gaSArIDFcXG4gICAgICAgICAgICBrID0gayArIDFcXG5cXG4gICAgICAgIHdoaWxlIGogPCBsZW4ocmlnaHRfaGFsZik6XFxuICAgICAgICAgICAgbHN0W2tdID0gcmlnaHRfaGFsZltqXVxcbiAgICAgICAgICAgIGogPSBqICsgMVxcbiAgICAgICAgICAgIGsgPSBrICsgMVxcblxcblxcbmRlZiBxdWlja19zb3J0KGxzdCk6XFxuICAgIFxcXCJcXFwiXFxcIlF1aWNrIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgX3F1aWNrX3NvcnRfaGVscChsc3QsIDAsIGxlbihsc3QpIC0gMSlcXG5cXG5cXG5kZWYgX3F1aWNrX3NvcnRfaGVscChsc3QsIG1hcmtfbCwgbWFya19yKTpcXG4gICAgXFxcIlxcXCJcXFwiUXVpY2sgc29ydCBoZWxwZXJcXFwiXFxcIlxcXCJcXG4gICAgaWYgbWFya19sIDwgbWFya19yOlxcbiAgICAgICAgc3BsaXQgPSBfcXVpY2tfc29ydF9wYXJ0KGxzdCwgbWFya19sLCBtYXJrX3IpXFxuICAgICAgICBfcXVpY2tfc29ydF9oZWxwKGxzdCwgbWFya19sLCBzcGxpdCAtIDEpXFxuICAgICAgICBfcXVpY2tfc29ydF9oZWxwKGxzdCwgc3BsaXQgKyAxLCBtYXJrX3IpXFxuXFxuXFxuZGVmIF9xdWlja19zb3J0X3BhcnQobHN0LCBtYXJrX2wsIG1hcmtfcik6XFxuICAgIFxcXCJcXFwiXFxcIlF1aWNrIHNvcnQgcGFydGl0aW9uXFxcIlxcXCJcXFwiXFxuICAgIHBpdm90X3ZhbCA9IGxzdFttYXJrX2xdXFxuICAgIG1hcmtfbF9jdXIgPSBtYXJrX2wgKyAxXFxuICAgIG1hcmtfcl9jdXIgPSBtYXJrX3JcXG4gICAgZG9uZSA9IEZhbHNlXFxuXFxuICAgIHdoaWxlIG5vdCBkb25lOlxcbiAgICAgICAgd2hpbGUgbWFya19sX2N1ciA8PSBtYXJrX3JfY3VyIGFuZCBsc3RbbWFya19sX2N1cl0gPD0gcGl2b3RfdmFsOlxcbiAgICAgICAgICAgIG1hcmtfbF9jdXIgPSBtYXJrX2xfY3VyICsgMVxcbiAgICAgICAgd2hpbGUgbWFya19sX2N1ciA8PSBtYXJrX3JfY3VyIGFuZCBsc3RbbWFya19yX2N1cl0gPj0gcGl2b3RfdmFsOlxcbiAgICAgICAgICAgIG1hcmtfcl9jdXIgPSBtYXJrX3JfY3VyIC0gMVxcbiAgICAgICAgaWYgbWFya19yX2N1ciA8IG1hcmtfbF9jdXI6XFxuICAgICAgICAgICAgZG9uZSA9IFRydWVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbHN0W21hcmtfbF9jdXJdLCBsc3RbbWFya19yX2N1cl0gPSBsc3RbbWFya19yX2N1cl0sIGxzdFttYXJrX2xfY3VyXVxcbiAgICBsc3RbbWFya19sXSwgbHN0W21hcmtfcl9jdXJdID0gbHN0W21hcmtfcl9jdXJdLCBsc3RbbWFya19sXVxcblxcbiAgICByZXR1cm4gbWFya19yX2N1clxcblxcblxcbmRlZiBoZWFwX3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiSGVhcCBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIHJlcyA9IFtdXFxuICAgIGhlYXBxLmhlYXBpZnkobHN0KVxcbiAgICB3aGlsZSBsc3Q6XFxuICAgICAgICByZXMuYXBwZW5kKGhlYXBxLmhlYXBwb3AobHN0KSlcXG4gICAgZm9yIGkgaW4gcmVzOlxcbiAgICAgICAgbHN0LmFwcGVuZChpKVxcblwiLFwic3JjL2xpYi9weXRob25kczMvdHJlZXMvX19pbml0X18ucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5weXRob25kczMudHJlZXMgaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmF2bF90cmVlIGltcG9ydCBBVkxUcmVlXFxuZnJvbSBweXRob25kczMudHJlZXMuYmluYXJ5X3NlYXJjaF90cmVlIGltcG9ydCBCaW5hcnlTZWFyY2hUcmVlXFxuZnJvbSBweXRob25kczMudHJlZXMuYmluYXJ5X2hlYXAgaW1wb3J0IEJpbmFyeUhlYXBcXG5mcm9tIHB5dGhvbmRzMy50cmVlcy5iaW5hcnlfdHJlZSBpbXBvcnQgQmluYXJ5VHJlZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLnByaW9yaXR5X3F1ZXVlIGltcG9ydCBQcmlvcml0eVF1ZXVlXFxuXFxuX19hbGxfXyA9IFtcXFwiQmluYXJ5VHJlZVxcXCIsIFxcXCJCaW5hcnlIZWFwXFxcIiwgXFxcIkJpbmFyeVNlYXJjaFRyZWVcXFwiLCBcXFwiQVZMVHJlZVxcXCIsIFxcXCJQcmlvcml0eVF1ZXVlXFxcIl1cXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL2F2bF90cmVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1LCAyMDEwXFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmJpbmFyeV9zZWFyY2hfdHJlZSBpbXBvcnQgQmluYXJ5U2VhcmNoVHJlZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmJpbmFyeV9zZWFyY2hfdHJlZSBpbXBvcnQgQmluYXJ5VHJlZU5vZGVcXG5cXG5cXG5jbGFzcyBBVkxUcmVlTm9kZShCaW5hcnlUcmVlTm9kZSk6XFxuICAgIFxcXCJcXFwiXFxcIkFWTCBUcmVlIE5vZGVcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGtleSwgdmFsLCBiYWxhbmNlX2ZhY3RvciwgbGVmdD1Ob25lLCByaWdodD1Ob25lLCBwYXJlbnQ9Tm9uZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgYW4gQVZMIHRyZWUgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUuX19pbml0X18oc2VsZiwga2V5LCB2YWwsIGxlZnQsIHJpZ2h0LCBwYXJlbnQpXFxuICAgICAgICBzZWxmLl9iYWxhbmNlX2ZhY3RvciA9IGJhbGFuY2VfZmFjdG9yXFxuXFxuICAgIGRlZiBnZXRfYmFsYW5jZV9mYWN0b3Ioc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIG5vZGUgYmFsYW5jZSBmYWN0b3JcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9iYWxhbmNlX2ZhY3RvclxcblxcbiAgICBkZWYgc2V0X2JhbGFuY2VfZmFjdG9yKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCB0aGUgbm9kZSBiYWxhbmNlIGZhY3RvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fYmFsYW5jZV9mYWN0b3IgPSB2YWx1ZVxcblxcbiAgICBiYWxhbmNlX2ZhY3RvciA9IHByb3BlcnR5KGdldF9iYWxhbmNlX2ZhY3Rvciwgc2V0X2JhbGFuY2VfZmFjdG9yKVxcblxcblxcbmNsYXNzIEFWTFRyZWUoQmluYXJ5U2VhcmNoVHJlZSk6XFxuICAgIFxcXCJcXFwiXFxcIkFWTCB0cmVlIGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhIG5ldyBBVkwgdHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgQmluYXJ5U2VhcmNoVHJlZS5fX2luaXRfXyhzZWxmKVxcblxcbiAgICBkZWYgcHV0KHNlbGYsIGtleSwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIG5ldyBub2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl9yb290OlxcbiAgICAgICAgICAgIHNlbGYuX3B1dChrZXksIHZhbHVlLCBzZWxmLl9yb290KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLl9yb290ID0gQVZMVHJlZU5vZGUoa2V5LCB2YWx1ZSwgMClcXG4gICAgICAgIHNlbGYuX3NpemUgPSBzZWxmLl9zaXplICsgMVxcblxcbiAgICBkZWYgX3B1dChzZWxmLCBrZXksIHZhbHVlLCBjdXJyZW50X25vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGEgbmV3IG5vZGUgdG8gdGhlIHRyZWUgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGtleSA8IGN1cnJlbnRfbm9kZS5rZXk6XFxuICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmdldF9jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksIHZhbHVlLCBjdXJyZW50X25vZGUuY2hpbGRfbGVmdClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdCA9IEFWTFRyZWVOb2RlKFxcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgMCwgcGFyZW50PWN1cnJlbnRfbm9kZVxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlX2JhbGFuY2UoY3VycmVudF9ub2RlLmNoaWxkX2xlZnQpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZS5nZXRfY2hpbGRfcmlnaHQoKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSwgdmFsdWUsIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQgPSBBVkxUcmVlTm9kZShcXG4gICAgICAgICAgICAgICAgICAgIGtleSwgdmFsdWUsIDAsIHBhcmVudD1jdXJyZW50X25vZGVcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZV9iYWxhbmNlKGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIHVwZGF0ZV9iYWxhbmNlKHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVXBkYXRlIHRoZSB0cmVlIGJhbGFuY2VcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vZGUuYmFsYW5jZV9mYWN0b3IgPiAxIG9yIG5vZGUuYmFsYW5jZV9mYWN0b3IgPCAtMTpcXG4gICAgICAgICAgICBzZWxmLnJlYmFsYW5jZShub2RlKVxcbiAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgaWYgbm9kZS5wYXJlbnQ6XFxuICAgICAgICAgICAgaWYgbm9kZS5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmJhbGFuY2VfZmFjdG9yICs9IDFcXG4gICAgICAgICAgICBlbGlmIG5vZGUuaXNfY2hpbGRfcmlnaHQoKTpcXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuYmFsYW5jZV9mYWN0b3IgLT0gMVxcblxcbiAgICAgICAgICAgIGlmIG5vZGUucGFyZW50LmJhbGFuY2VfZmFjdG9yICE9IDA6XFxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlX2JhbGFuY2Uobm9kZS5wYXJlbnQpXFxuXFxuICAgIGRlZiByZWJhbGFuY2Uoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZWJhbGFuY2UgdGhlIHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vZGUuYmFsYW5jZV9mYWN0b3IgPCAwOlxcbiAgICAgICAgICAgIGlmIG5vZGUuY2hpbGRfcmlnaHQuYmFsYW5jZV9mYWN0b3IgPiAwOlxcbiAgICAgICAgICAgICAgICAjIERvIGFuIExSIFJvdGF0aW9uXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlX3JpZ2h0KG5vZGUuY2hpbGRfcmlnaHQpXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlX2xlZnQobm9kZSlcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAjIHNpbmdsZSBsZWZ0XFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlX2xlZnQobm9kZSlcXG4gICAgICAgIGVsaWYgbm9kZS5iYWxhbmNlX2ZhY3RvciA+IDA6XFxuICAgICAgICAgICAgaWYgbm9kZS5jaGlsZF9sZWZ0LmJhbGFuY2VfZmFjdG9yIDwgMDpcXG4gICAgICAgICAgICAgICAgIyBEbyBhbiBSTCBSb3RhdGlvblxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZV9sZWZ0KG5vZGUuY2hpbGRfbGVmdClcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVfcmlnaHQobm9kZSlcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAjIHNpbmdsZSByaWdodFxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZV9yaWdodChub2RlKVxcblxcbiAgICBkZWYgcm90YXRlX2xlZnQoc2VsZiwgcm90YXRpb25fcm9vdCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJMZWZ0IHJvdGF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBuZXdfcm9vdCA9IHJvdGF0aW9uX3Jvb3QuY2hpbGRfcmlnaHRcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QuY2hpbGRfcmlnaHQgPSBuZXdfcm9vdC5jaGlsZF9sZWZ0XFxuICAgICAgICBpZiBuZXdfcm9vdC5jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIG5ld19yb290LmNoaWxkX2xlZnQucGFyZW50ID0gcm90YXRpb25fcm9vdFxcbiAgICAgICAgbmV3X3Jvb3QucGFyZW50ID0gcm90YXRpb25fcm9vdC5wYXJlbnRcXG4gICAgICAgIGlmIHJvdGF0aW9uX3Jvb3QuaXNfcm9vdCgpOlxcbiAgICAgICAgICAgIHNlbGYuX3Jvb3QgPSBuZXdfcm9vdFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiByb3RhdGlvbl9yb290LmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgcm90YXRpb25fcm9vdC5wYXJlbnQuY2hpbGRfbGVmdCA9IG5ld19yb290XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcm90YXRpb25fcm9vdC5wYXJlbnQuY2hpbGRfcmlnaHQgPSBuZXdfcm9vdFxcbiAgICAgICAgbmV3X3Jvb3QuY2hpbGRfbGVmdCA9IHJvdGF0aW9uX3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QucGFyZW50ID0gbmV3X3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IgPSAoXFxuICAgICAgICAgICAgcm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciArIDEgLSBtaW4obmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IsIDApXFxuICAgICAgICApXFxuICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciA9IChcXG4gICAgICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciArIDEgKyBtYXgocm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciwgMClcXG4gICAgICAgIClcXG5cXG4gICAgZGVmIHJvdGF0ZV9yaWdodChzZWxmLCByb3RhdGlvbl9yb290KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJpZ2h0IHJvdGF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBuZXdfcm9vdCA9IHJvdGF0aW9uX3Jvb3QuY2hpbGRfbGVmdFxcbiAgICAgICAgcm90YXRpb25fcm9vdC5jaGlsZF9sZWZ0ID0gbmV3X3Jvb3QuY2hpbGRfcmlnaHRcXG4gICAgICAgIGlmIG5ld19yb290LmNoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIG5ld19yb290LmNoaWxkX3JpZ2h0LnBhcmVudCA9IHJvdGF0aW9uX3Jvb3RcXG4gICAgICAgIG5ld19yb290LnBhcmVudCA9IHJvdGF0aW9uX3Jvb3QucGFyZW50XFxuICAgICAgICBpZiByb3RhdGlvbl9yb290LmlzX3Jvb3QoKTpcXG4gICAgICAgICAgICBzZWxmLl9yb290ID0gbmV3X3Jvb3RcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgcm90YXRpb25fcm9vdC5pc19jaGlsZF9yaWdodCgpOlxcbiAgICAgICAgICAgICAgICByb3RhdGlvbl9yb290LnBhcmVudC5jaGlsZF9yaWdodCA9IG5ld19yb290XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcm90YXRpb25fcm9vdC5wYXJlbnQuY2hpbGRfbGVmdCA9IG5ld19yb290XFxuICAgICAgICBuZXdfcm9vdC5jaGlsZF9yaWdodCA9IHJvdGF0aW9uX3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QucGFyZW50ID0gbmV3X3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IgPSAoXFxuICAgICAgICAgICAgcm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciAtIDEgLSBtYXgobmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IsIDApXFxuICAgICAgICApXFxuICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciA9IChcXG4gICAgICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciAtIDEgKyBtaW4ocm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciwgMClcXG4gICAgICAgIClcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL2JpbmFyeV9oZWFwLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIEJpbmFyeUhlYXA6XFxuICAgIFxcXCJcXFwiXFxcIk1pbmltYWwgQmluYXJ5IEhlYXBcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIGEgaGVhcFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faGVhcCA9IFtdXFxuXFxuICAgIGRlZiBfcGVyY191cChzZWxmLCBjdXJfaWR4KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIk1vdmUgYSBub2RlIHVwXFxcIlxcXCJcXFwiXFxuICAgICAgICB3aGlsZSAoY3VyX2lkeCAtIDEpIC8vIDIgPj0gMDpcXG4gICAgICAgICAgICBwYXJlbnRfaWR4ID0gKGN1cl9pZHggLSAxKSAvLyAyXFxuICAgICAgICAgICAgaWYgc2VsZi5faGVhcFtjdXJfaWR4XSA8IHNlbGYuX2hlYXBbcGFyZW50X2lkeF06XFxuICAgICAgICAgICAgICAgIHNlbGYuX2hlYXBbY3VyX2lkeF0sIHNlbGYuX2hlYXBbcGFyZW50X2lkeF0gPSAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9oZWFwW3BhcmVudF9pZHhdLFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGVhcFtjdXJfaWR4XSxcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIGN1cl9pZHggPSBwYXJlbnRfaWR4XFxuXFxuICAgIGRlZiBfcGVyY19kb3duKHNlbGYsIGN1cl9pZHgpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTW92ZSBhIG5vZGUgZG93blxcXCJcXFwiXFxcIlxcbiAgICAgICAgd2hpbGUgMiAqIGN1cl9pZHggKyAxIDwgbGVuKHNlbGYuX2hlYXApOlxcbiAgICAgICAgICAgIG1pbl9jaGlsZF9pZHggPSBzZWxmLl9nZXRfbWluX2NoaWxkKGN1cl9pZHgpXFxuICAgICAgICAgICAgaWYgc2VsZi5faGVhcFtjdXJfaWR4XSA+IHNlbGYuX2hlYXBbbWluX2NoaWxkX2lkeF06XFxuICAgICAgICAgICAgICAgIHNlbGYuX2hlYXBbY3VyX2lkeF0sIHNlbGYuX2hlYXBbbWluX2NoaWxkX2lkeF0gPSAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9oZWFwW21pbl9jaGlsZF9pZHhdLFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGVhcFtjdXJfaWR4XSxcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgIGN1cl9pZHggPSBtaW5fY2hpbGRfaWR4XFxuXFxuICAgIGRlZiBfZ2V0X21pbl9jaGlsZChzZWxmLCBwYXJlbnRfaWR4KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBhIHNtYWxsZXIgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIDIgKiBwYXJlbnRfaWR4ICsgMiA+IGxlbihzZWxmLl9oZWFwKSAtIDE6XFxuICAgICAgICAgICAgcmV0dXJuIDIgKiBwYXJlbnRfaWR4ICsgMVxcbiAgICAgICAgaWYgc2VsZi5faGVhcFsyICogcGFyZW50X2lkeCArIDFdIDwgc2VsZi5faGVhcFsyICogcGFyZW50X2lkeCArIDJdOlxcbiAgICAgICAgICAgIHJldHVybiAyICogcGFyZW50X2lkeCArIDFcXG4gICAgICAgIHJldHVybiAyICogcGFyZW50X2lkeCArIDJcXG5cXG4gICAgZGVmIGhlYXBpZnkoc2VsZiwgbm90X2FfaGVhcCwgc2hvd19kZXRhaWxzPUZhbHNlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkJ1aWxkIGEgaGVhcCBmcm9tIGFueSBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9oZWFwID0gbm90X2FfaGVhcFs6XVxcbiAgICAgICAgY3VyX2lkeCA9IGxlbihzZWxmLl9oZWFwKSAvLyAyIC0gMVxcbiAgICAgICAgd2hpbGUgY3VyX2lkeCA+PSAwOlxcbiAgICAgICAgICAgIHNlbGYuX3BlcmNfZG93bihjdXJfaWR4KVxcbiAgICAgICAgICAgIGN1cl9pZHggPSBjdXJfaWR4IC0gMVxcbiAgICAgICAgICAgIGlmIHNob3dfZGV0YWlsczpcXG4gICAgICAgICAgICAgICAgcHJpbnQoc2VsZi5faGVhcClcXG5cXG4gICAgZGVmIGluc2VydChzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhIG5ldyBpdGVtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9oZWFwLmFwcGVuZChpdGVtKVxcbiAgICAgICAgc2VsZi5fcGVyY191cChsZW4oc2VsZi5faGVhcCkgLSAxKVxcblxcbiAgICBkZWYgZGVsZXRlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW1cXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2hlYXBbMF0sIHNlbGYuX2hlYXBbLTFdID0gc2VsZi5faGVhcFstMV0sIHNlbGYuX2hlYXBbMF1cXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuX2hlYXAucG9wKClcXG4gICAgICAgIHNlbGYuX3BlcmNfZG93bigwKVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgaGVhcCBpcyBlbXB0eVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIG5vdCBib29sKHNlbGYuX2hlYXApXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGhlYXAgc2l6ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLl9oZWFwKVxcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkhlYXAgYXMgYSBzdHJpbmdcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzdHIoc2VsZi5faGVhcClcXG5cXG4gICAgZGVmIF9fY29udGFpbnNfXyhzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIl9fY29udGFpbnNfX2luIG1ldGhvZCBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGl0ZW0gaW4gc2VsZi5faGVhcFxcblwiLFwic3JjL2xpYi9weXRob25kczMvdHJlZXMvYmluYXJ5X3NlYXJjaF90cmVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1LCAyMDEwXFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIEJpbmFyeVRyZWVOb2RlOlxcbiAgICBcXFwiXFxcIlxcXCJCaW5hcnkgVHJlZSBOb2RlIGNsYXNzXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBrZXksIHZhbHVlLCBsZWZ0PU5vbmUsIHJpZ2h0PU5vbmUsIHBhcmVudD1Ob25lKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBuZXcgVHJlZSBOb2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9rZXkgPSBrZXlcXG4gICAgICAgIHNlbGYuX3ZhbHVlID0gdmFsdWVcXG4gICAgICAgIHNlbGYuX2NoaWxkX2xlZnQgPSBsZWZ0XFxuICAgICAgICBzZWxmLl9jaGlsZF9yaWdodCA9IHJpZ2h0XFxuICAgICAgICBzZWxmLl9wYXJlbnQgPSBwYXJlbnRcXG5cXG4gICAgZGVmIGdldF9jaGlsZF9sZWZ0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBub2RlJ3MgbGVmdCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX2xlZnRcXG5cXG4gICAgZGVmIHNldF9jaGlsZF9sZWZ0KHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQXNzaWduIHRoZSBub2RlJ3MgbGVmdCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY2hpbGRfbGVmdCA9IG5vZGVcXG5cXG4gICAgY2hpbGRfbGVmdCA9IHByb3BlcnR5KGdldF9jaGlsZF9sZWZ0LCBzZXRfY2hpbGRfbGVmdClcXG5cXG4gICAgZGVmIGdldF9jaGlsZF9yaWdodChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgbm9kZSdzIHJpZ2h0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY2hpbGRfcmlnaHRcXG5cXG4gICAgZGVmIHNldF9jaGlsZF9yaWdodChzZWxmLCBub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFzc2lnbiB0aGUgbm9kZSdzIHJpZ2h0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9jaGlsZF9yaWdodCA9IG5vZGVcXG5cXG4gICAgY2hpbGRfcmlnaHQgPSBwcm9wZXJ0eShnZXRfY2hpbGRfcmlnaHQsIHNldF9jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIGdldF9wYXJlbnQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIG5vZGUncyBwYXJlbnRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9wYXJlbnRcXG5cXG4gICAgZGVmIHNldF9wYXJlbnQoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBc3NpZ24gdGhlIG5vZGUncyBwYXJlbnRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3BhcmVudCA9IG5vZGVcXG5cXG4gICAgcGFyZW50ID0gcHJvcGVydHkoZ2V0X3BhcmVudCwgc2V0X3BhcmVudClcXG5cXG4gICAgZGVmIGlzX2NoaWxkX2xlZnQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBpcyBhIGxlZnQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9wYXJlbnQgYW5kIHNlbGYuX3BhcmVudC5jaGlsZF9sZWZ0ID09IHNlbGZcXG5cXG4gICAgZGVmIGlzX2NoaWxkX3JpZ2h0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIG5vZGUgaXMgYSByaWdodCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3BhcmVudCBhbmQgc2VsZi5fcGFyZW50LmNoaWxkX3JpZ2h0ID09IHNlbGZcXG5cXG4gICAgZGVmIGlzX3Jvb3Qoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBpcyBhIHRyZWUgcm9vdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIG5vdCBzZWxmLl9wYXJlbnRcXG5cXG4gICAgZGVmIGlzX2xlYWYoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBpcyBhIGxlYWZcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgKHNlbGYuX2NoaWxkX3JpZ2h0IG9yIHNlbGYuX2NoaWxkX2xlZnQpXFxuXFxuICAgIGRlZiBoYXNfYV9jaGlsZChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIHRoZSBub2RlIGhhcyBhbnkgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9jaGlsZF9yaWdodCBvciBzZWxmLl9jaGlsZF9sZWZ0XFxuXFxuICAgIGRlZiBoYXNfY2hpbGRyZW4oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBoYXMgYm90aCBjaGlsZHJlblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX3JpZ2h0IGFuZCBzZWxmLl9jaGlsZF9sZWZ0XFxuXFxuICAgIGRlZiBnZXRfa2V5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG5vZGUga2V5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fa2V5XFxuXFxuICAgIGRlZiBzZXRfa2V5KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbm9kZSBrZXlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2tleSA9IGtleVxcblxcbiAgICBrZXkgPSBwcm9wZXJ0eShnZXRfa2V5LCBzZXRfa2V5KVxcblxcbiAgICBkZWYgZ2V0X3ZhbHVlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG5vZGUgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl92YWx1ZVxcblxcbiAgICBkZWYgc2V0X3ZhbHVlKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBub2RlIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl92YWx1ZSA9IHZhbHVlXFxuXFxuICAgIHZhbHVlID0gcHJvcGVydHkoZ2V0X3ZhbHVlLCBzZXRfdmFsdWUpXFxuXFxuICAgIGRlZiByZXBsYWNlX3BheWxvYWQoc2VsZiwga2V5LCB2YWx1ZSwgbGVmdCwgcmlnaHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hhbmdlIG5vZGUgcGF5bG9hZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fa2V5ID0ga2V5XFxuICAgICAgICBzZWxmLl92YWx1ZSA9IHZhbHVlXFxuICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0ID0gbGVmdFxcbiAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQgPSByaWdodFxcbiAgICAgICAgaWYgc2VsZi5jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX2xlZnQucGFyZW50ID0gc2VsZlxcbiAgICAgICAgaWYgc2VsZi5jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wYXJlbnQgPSBzZWxmXFxuXFxuICAgIGRlZiBmaW5kX3N1Y2Nlc3NvcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZpbmQgdGhlIG5vZGUncyBzdWNjZXNzb3JcXFwiXFxcIlxcXCJcXG4gICAgICAgIHN1Y2Nlc3NvciA9IE5vbmVcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIHN1Y2Nlc3NvciA9IHNlbGYuX2NoaWxkX3JpZ2h0LmZpbmRfbWluKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgc2VsZi5fcGFyZW50OlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NvciA9IHNlbGYuX3BhcmVudFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX3JpZ2h0ID0gTm9uZVxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc29yID0gc2VsZi5fcGFyZW50LmZpbmRfc3VjY2Vzc29yKClcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3BhcmVudC5jaGlsZF9yaWdodCA9IHNlbGZcXG4gICAgICAgIHJldHVybiBzdWNjZXNzb3JcXG5cXG4gICAgZGVmIGZpbmRfbWluKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmluZCB0aGUgc21hbGxlc3Qgbm9kZSBpbiB0aGUgcmlnaHQgc3VidHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgY3VycmVudCA9IHNlbGZcXG4gICAgICAgIHdoaWxlIGN1cnJlbnQuY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZF9sZWZ0XFxuICAgICAgICByZXR1cm4gY3VycmVudFxcblxcbiAgICBkZWYgc3BsaWNlX291dChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNwbGljZSBvdXRcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuaXNfbGVhZigpOlxcbiAgICAgICAgICAgIGlmIHNlbGYuaXNfY2hpbGRfbGVmdCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfbGVmdCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfcmlnaHQgPSBOb25lXFxuICAgICAgICBlbGlmIHNlbGYuaGFzX2FfY2hpbGQoKTpcXG4gICAgICAgICAgICBpZiBzZWxmLmNoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNfY2hpbGRfbGVmdCgpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX2xlZnQgPSBzZWxmLl9jaGlsZF9sZWZ0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfcmlnaHQgPSBzZWxmLl9jaGlsZF9sZWZ0XFxuICAgICAgICAgICAgICAgIHNlbGYuX2NoaWxkX2xlZnQucGFyZW50ID0gc2VsZi5fcGFyZW50XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfbGVmdCA9IHNlbGYuX2NoaWxkX3JpZ2h0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfcmlnaHQgPSBzZWxmLl9jaGlsZF9yaWdodFxcbiAgICAgICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wYXJlbnQgPSBzZWxmLl9wYXJlbnRcXG5cXG4gICAgZGVmIF9faXRlcl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVGhlIHN0YW5kYXJkIGlub3JkZXIgdHJhdmVyc2FsIG9mIGEgYmluYXJ5IHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGY6XFxuICAgICAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICAgICAgZm9yIGVsZW0gaW4gc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1cXG4gICAgICAgICAgICB5aWVsZCBzZWxmLl9rZXlcXG4gICAgICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICAgICAgZm9yIGVsZW0gaW4gc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBlbGVtXFxuXFxuXFxuY2xhc3MgQmluYXJ5U2VhcmNoVHJlZTpcXG4gICAgXFxcIlxcXCJcXFwiQmluYXJ5IHNlYXJjaCB0cmVlIGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuX3Jvb3QgPSBOb25lXFxuICAgICAgICBzZWxmLl9zaXplID0gMFxcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlRyZWUgc2l6ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NpemVcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJUcmVlIHNpemVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9zaXplXFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkl0ZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcm9vdC5fX2l0ZXJfXygpXFxuXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiW10gZ2V0dGVyIG9wZXJhdG9yIG92ZXJyaWRlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXN1bHQgPSBzZWxmLmdldChrZXkpXFxuICAgICAgICBpZiByZXN1bHQ6XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICAgICAgcmFpc2UgS2V5RXJyb3IoXFxcIkVycm9yLCBrZXkgbm90IGluIHRyZWVcXFwiKVxcblxcbiAgICBkZWYgZ2V0X3Jvb3Qoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdHJlZSByb290XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcm9vdFxcblxcbiAgICBkZWYgc2V0X3Jvb3Qoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgdHJlZSByb290XFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9yb290ID0gbm9kZVxcblxcbiAgICByb290ID0gcHJvcGVydHkoZ2V0X3Jvb3QsIHNldF9yb290KVxcblxcbiAgICBkZWYgZ2V0KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXRyaWV2ZSBhIHZhbHVlIGJ5IHRoZSBrZXlcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX3Jvb3Q6XFxuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZi5fZ2V0KGtleSwgc2VsZi5fcm9vdClcXG4gICAgICAgICAgICBpZiByZXN1bHQ6XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWVcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcblxcbiAgICBkZWYgX2dldChzZWxmLCBrZXksIGN1cnJlbnRfbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXRyaWV2ZSBhIHZhbHVlIGJ5IHRoZSBrZXkgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vdCBjdXJyZW50X25vZGU6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIGlmIGN1cnJlbnRfbm9kZS5rZXkgPT0ga2V5OlxcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50X25vZGVcXG4gICAgICAgIGVsaWYga2V5IDwgY3VycmVudF9ub2RlLmtleTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0KGtleSwgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXQoa2V5LCBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiBfX3NldGl0ZW1fXyhzZWxmLCBrZXksIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIltdIHNldHRlciBvcGVyYXRvciBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5wdXQoa2V5LCB2YWx1ZSlcXG5cXG4gICAgZGVmIHB1dChzZWxmLCBrZXksIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fcm9vdDpcXG4gICAgICAgICAgICBzZWxmLl9wdXQoa2V5LCB2YWx1ZSwgc2VsZi5fcm9vdClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5fcm9vdCA9IEJpbmFyeVRyZWVOb2RlKGtleSwgdmFsdWUpXFxuICAgICAgICBzZWxmLl9zaXplID0gc2VsZi5fc2l6ZSArIDFcXG5cXG4gICAgZGVmIF9wdXQoc2VsZiwga2V5LCB2YWx1ZSwgY3VycmVudF9ub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBuZXcgbm9kZSAoaGVscGVyIGZ1bmN0aW9uKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYga2V5IDwgY3VycmVudF9ub2RlLmtleTpcXG4gICAgICAgICAgICBpZiBjdXJyZW50X25vZGUuY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSwgdmFsdWUsIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0KVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0ID0gQmluYXJ5VHJlZU5vZGUoXFxuICAgICAgICAgICAgICAgICAgICBrZXksIHZhbHVlLCBwYXJlbnQ9Y3VycmVudF9ub2RlXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wdXQoa2V5LCB2YWx1ZSwgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0KVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodCA9IEJpbmFyeVRyZWVOb2RlKFxcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgcGFyZW50PWN1cnJlbnRfbm9kZVxcbiAgICAgICAgICAgICAgICApXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZiwga2V5KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcImluIG9wZXJhdG9yIG92ZXJyaWRlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gYm9vbChzZWxmLl9nZXQoa2V5LCBzZWxmLl9yb290KSlcXG5cXG4gICAgZGVmIF9fZGVsaXRlbV9fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJkZWwgb3BlcmF0b3Igb3ZlcnJpZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuZGVsZXRlKGtleSlcXG5cXG4gICAgZGVmIGRlbGV0ZShzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGEgbm9kZSBieSBpdHMga2V5XFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl9zaXplID4gMTpcXG4gICAgICAgICAgICBub2RlX3RvX3JlbW92ZSA9IHNlbGYuX2dldChrZXksIHNlbGYuX3Jvb3QpXFxuICAgICAgICAgICAgaWYgbm9kZV90b19yZW1vdmU6XFxuICAgICAgICAgICAgICAgIHNlbGYuX2RlbGV0ZShub2RlX3RvX3JlbW92ZSlcXG4gICAgICAgICAgICAgICAgc2VsZi5fc2l6ZSA9IHNlbGYuX3NpemUgLSAxXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoXFxcIkVycm9yLCBrZXkgbm90IGluIHRyZWVcXFwiKVxcbiAgICAgICAgZWxpZiBzZWxmLl9zaXplID09IDEgYW5kIHNlbGYuX3Jvb3Qua2V5ID09IGtleTpcXG4gICAgICAgICAgICBzZWxmLl9yb290ID0gTm9uZVxcbiAgICAgICAgICAgIHNlbGYuX3NpemUgPSBzZWxmLl9zaXplIC0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcihcXFwiRXJyb3IsIGtleSBub3QgaW4gdHJlZVxcXCIpXFxuXFxuICAgIGRlZiBfZGVsZXRlKHNlbGYsIGN1cnJlbnRfbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZW1vdmUgYSBub2RlIGJ5IGl0cyBrZXkgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGN1cnJlbnRfbm9kZS5pc19sZWFmKCk6ICAjIHJlbW92aW5nIGEgbGVhZlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZSA9PSBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5wYXJlbnQuY2hpbGRfbGVmdCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX3JpZ2h0ID0gTm9uZVxcbiAgICAgICAgZWxpZiBjdXJyZW50X25vZGUuaGFzX2NoaWxkcmVuKCk6ICAjIHJlbW92aW5nIGEgbm9kZSB3aXRoIHR3byBjaGlsZHJlblxcbiAgICAgICAgICAgIHN1Y2Nlc3NvciA9IGN1cnJlbnRfbm9kZS5maW5kX3N1Y2Nlc3NvcigpXFxuICAgICAgICAgICAgc3VjY2Vzc29yLnNwbGljZV9vdXQoKVxcbiAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5rZXkgPSBzdWNjZXNzb3Iua2V5XFxuICAgICAgICAgICAgY3VycmVudF9ub2RlLnZhbHVlID0gc3VjY2Vzc29yLnZhbHVlXFxuICAgICAgICBlbHNlOiAgIyByZW1vdmluZyBhIG5vZGUgd2l0aCBvbmUgY2hpbGRcXG4gICAgICAgICAgICBpZiBjdXJyZW50X25vZGUuZ2V0X2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LnBhcmVudCA9IGN1cnJlbnRfbm9kZS5wYXJlbnRcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5wYXJlbnQuY2hpbGRfbGVmdCA9IGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0XFxuICAgICAgICAgICAgICAgIGVsaWYgY3VycmVudF9ub2RlLmlzX2NoaWxkX3JpZ2h0KCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdC5wYXJlbnQgPSBjdXJyZW50X25vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX3JpZ2h0ID0gY3VycmVudF9ub2RlLmNoaWxkX2xlZnRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5yZXBsYWNlX3BheWxvYWQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQua2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LnZhbHVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LmNoaWxkX2xlZnQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQuY2hpbGRfcmlnaHQsXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5wYXJlbnQgPSBjdXJyZW50X25vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX2xlZnQgPSBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHRcXG4gICAgICAgICAgICAgICAgZWxpZiBjdXJyZW50X25vZGUuaXNfY2hpbGRfcmlnaHQoKTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5wYXJlbnQgPSBjdXJyZW50X25vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX3JpZ2h0ID0gY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucmVwbGFjZV9wYXlsb2FkKFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5rZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0LnZhbHVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5jaGlsZF9sZWZ0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5jaGlsZF9yaWdodCxcXG4gICAgICAgICAgICAgICAgICAgIClcXG5cXG4gICAgZGVmIGlub3JkZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJJbi1vcmRlciB0cmVlIHRyYXZlcnNhbFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faW5vcmRlcihzZWxmLl9yb290KVxcblxcbiAgICBkZWYgX2lub3JkZXIoc2VsZiwgdHJlZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJJbi1vcmRlciB0cmVlIHRyYXZlcnNhbCAoaGVscGVyIGZ1bmN0aW9uKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgdHJlZTpcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVyKHRyZWUuY2hpbGRfbGVmdClcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVyKHRyZWUuY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQb3N0LW9yZGVyIHRyZWUgdHJhdmVyc2FsXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9wb3N0b3JkZXIoc2VsZi5fcm9vdClcXG5cXG4gICAgZGVmIF9wb3N0b3JkZXIoc2VsZiwgdHJlZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQb3N0LW9yZGVyIHRyZWUgdHJhdmVyc2FsIChoZWxwZXIgZnVuY3Rpb24pXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiB0cmVlOlxcbiAgICAgICAgICAgIHNlbGYuX3Bvc3RvcmRlcih0cmVlLmNoaWxkX2xlZnQpXFxuICAgICAgICAgICAgc2VsZi5fcG9zdG9yZGVyKHRyZWUuY2hpbGRfcmlnaHQpXFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXksIGVuZD1cXFwiIFxcXCIpXFxuXFxuICAgIGRlZiBwcmVvcmRlcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlByZS1vcmRlciB0cmVlIHRyYXZlcnNhbFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fcHJlb3JkZXIoc2VsZi5fcm9vdClcXG5cXG4gICAgZGVmIF9wcmVvcmRlcihzZWxmLCB0cmVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlByZS1vcmRlciB0cmVlIHRyYXZlcnNhbCAoaGVscGVyIGZ1bmN0aW9uKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgdHJlZTpcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgICAgICBzZWxmLl9wcmVvcmRlcih0cmVlLmNoaWxkX2xlZnQpXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZXIodHJlZS5jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIGNsZWFyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFsbCBub2Rlc1xcXCJcXFwiXFxcIlxcbiAgICAgICAgd2hpbGUgc2VsZi5fcm9vdDpcXG4gICAgICAgICAgICBzZWxmLmRlbGV0ZShzZWxmLl9yb290LmtleSlcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL2JpbmFyeV90cmVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcbmltcG9ydCBvcGVyYXRvclxcblxcblxcbmNsYXNzIEJpbmFyeVRyZWU6XFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBBIHJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBCaW5hcnkgVHJlZVxcbiAgICBVc2luZyBsaW5rcyBhbmQgTm9kZXMgYXBwcm9hY2guXFxuXFxuICAgIE1vZGlmaWVkIHRvIGFsbG93IGZvciB0cmVlcyB0byBiZSBjb25zdHJ1Y3RlZCBmcm9tIG90aGVyIHRyZWVzXFxuICAgIHJhdGhlciB0aGFuIGFsd2F5cyBjcmVhdGluZyBhIG5ldyB0cmVlIGluIHRoZSBpbnNlcnRfZmVmdCBvciBpbnNlcnRfcmlnaHRcXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyB0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9rZXkgPSBrZXlcXG4gICAgICAgIHNlbGYuX2NoaWxkX2xlZnQgPSBOb25lXFxuICAgICAgICBzZWxmLl9jaGlsZF9yaWdodCA9IE5vbmVcXG5cXG4gICAgZGVmIGdldF9yb290X3ZhbChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCByb290IGtleSB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2tleVxcblxcbiAgICBkZWYgc2V0X3Jvb3RfdmFsKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgcm9vdCBrZXkgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2tleSA9IGtleVxcblxcbiAgICByb290ID0gcHJvcGVydHkoZ2V0X3Jvb3RfdmFsLCBzZXRfcm9vdF92YWwpXFxuXFxuICAgIGRlZiBnZXRfY2hpbGRfbGVmdChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBsZWZ0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY2hpbGRfbGVmdFxcblxcbiAgICBkZWYgc2V0X2NoaWxkX2xlZnQoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbGVmdCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY2hpbGRfbGVmdCA9IG5vZGVcXG5cXG4gICAgY2hpbGRfbGVmdCA9IHByb3BlcnR5KGdldF9jaGlsZF9sZWZ0LCBzZXRfY2hpbGRfbGVmdClcXG5cXG4gICAgZGVmIGdldF9jaGlsZF9yaWdodChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCByaWdodCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX3JpZ2h0XFxuXFxuICAgIGRlZiBzZXRfY2hpbGRfcmlnaHQoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgcmlnaHQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2NoaWxkX3JpZ2h0ID0gbm9kZVxcblxcbiAgICBjaGlsZF9yaWdodCA9IHByb3BlcnR5KGdldF9jaGlsZF9yaWdodCwgc2V0X2NoaWxkX3JpZ2h0KVxcblxcbiAgICBkZWYgaXNfbGVhZihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIGEgbm9kZSBpcyBsZWFmXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gKG5vdCBzZWxmLl9jaGlsZF9sZWZ0KSBhbmQgKG5vdCBzZWxmLl9jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIGluc2VydF9sZWZ0KHNlbGYsIG5ld19ub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkluc2VydCBsZWZ0IHN1YnRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UobmV3X25vZGUsIEJpbmFyeVRyZWUpOlxcbiAgICAgICAgICAgIG5ld19zdWJ0cmVlID0gbmV3X25vZGVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbmV3X3N1YnRyZWUgPSBCaW5hcnlUcmVlKG5ld19ub2RlKVxcblxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBuZXdfc3VidHJlZS5zZXRfY2hpbGRfbGVmdChzZWxmLl9jaGlsZF9sZWZ0KVxcblxcbiAgICAgICAgc2VsZi5fY2hpbGRfbGVmdCA9IG5ld19zdWJ0cmVlXFxuXFxuICAgIGRlZiBpbnNlcnRfcmlnaHQoc2VsZiwgbmV3X25vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSW5zZXJ0IHJpZ2h0IHN1YnRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UobmV3X25vZGUsIEJpbmFyeVRyZWUpOlxcbiAgICAgICAgICAgIG5ld19zdWJ0cmVlID0gbmV3X25vZGVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbmV3X3N1YnRyZWUgPSBCaW5hcnlUcmVlKG5ld19ub2RlKVxcblxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgbmV3X3N1YnRyZWUuc2V0X2NoaWxkX3JpZ2h0KHNlbGYuX2NoaWxkX3JpZ2h0KVxcbiAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQgPSBuZXdfc3VidHJlZVxcblxcbiAgICBkZWYgcHJlb3JkZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQcmUtb3JkZXIgdHJlZSB0cmF2ZXJzYWxcXFwiXFxcIlxcXCJcXG4gICAgICAgIHByaW50KHNlbGYuX2tleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfbGVmdC5wcmVvcmRlcigpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wcmVvcmRlcigpXFxuXFxuICAgIGRlZiBpbm9yZGVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSW4tb3JkZXIgdHJlZSB0cmF2ZXJzYWxcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfbGVmdC5pbm9yZGVyKClcXG4gICAgICAgIHByaW50KHNlbGYuX2tleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX3JpZ2h0Lmlub3JkZXIoKVxcblxcbiAgICBkZWYgcG9zdG9yZGVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUG9zdC1vcmRlciB0cmVlIHRyYXZlcnNhbFxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0LnBvc3RvcmRlcigpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wb3N0b3JkZXIoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5fa2V5LCBlbmQ9XFxcIiBcXFwiKVxcblxcbiAgICBkZWYgcHJpbnRfZXhwKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUHJpbnQgYW4gZXhwcmVzc2lvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBwcmludChcXFwiKFxcXCIsIGVuZD1cXFwiIFxcXCIpXFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfbGVmdC5wcmludF9leHAoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5fa2V5LCBlbmQ9XFxcIiBcXFwiKVxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQucHJpbnRfZXhwKClcXG4gICAgICAgICAgICBwcmludChcXFwiKVxcXCIsIGVuZD1cXFwiIFxcXCIpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXJfZXZhbChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlBvc3RvcmRlciBldmFsdWF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBvcGVyYXRpb25zID0ge1xcbiAgICAgICAgICAgIFxcXCIrXFxcIjogb3BlcmF0b3IuYWRkLFxcbiAgICAgICAgICAgIFxcXCItXFxcIjogb3BlcmF0b3Iuc3ViLFxcbiAgICAgICAgICAgIFxcXCIqXFxcIjogb3BlcmF0b3IubXVsLFxcbiAgICAgICAgICAgIFxcXCIvXFxcIjogb3BlcmF0b3IudHJ1ZWRpdixcXG4gICAgICAgIH1cXG4gICAgICAgIHJlc3VsdF8xID0gTm9uZVxcbiAgICAgICAgcmVzdWx0XzIgPSBOb25lXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIHJlc3VsdF8xID0gc2VsZi5fY2hpbGRfbGVmdC5wb3N0b3JkZXJfZXZhbCgpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICByZXN1bHRfMiA9IHNlbGYuX2NoaWxkX3JpZ2h0LnBvc3RvcmRlcl9ldmFsKClcXG4gICAgICAgIGlmIHJlc3VsdF8xIGFuZCByZXN1bHRfMjpcXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uc1tzZWxmLl9rZXldKHJlc3VsdF8xLCByZXN1bHRfMilcXG4gICAgICAgIHJldHVybiBzZWxmLl9rZXlcXG5cXG4gICAgZGVmIGhlaWdodChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkhlaWdodCBvZiBhIHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vdCBzZWxmLl9rZXk6XFxuICAgICAgICAgICAgcmV0dXJuIC0xXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIGhlaWdodF9sZWZ0ID0gc2VsZi5fY2hpbGRfbGVmdC5oZWlnaHQoKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBoZWlnaHRfbGVmdCA9IC0xXFxuXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBoZWlnaHRfcmlnaHQgPSBzZWxmLl9jaGlsZF9yaWdodC5oZWlnaHQoKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBoZWlnaHRfcmlnaHQgPSAtMVxcblxcbiAgICAgICAgcmV0dXJuIDEgKyBtYXgoaGVpZ2h0X2xlZnQsIGhlaWdodF9yaWdodClcXG5cXG4gICAgZGVmIF9fbGVuX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaXplIG9mIGEgdHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuc2l6ZSgpXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ291bnQgbm9kZXMgaW4gYSB0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBub3Qgc2VsZi5fa2V5OlxcbiAgICAgICAgICAgIHJldHVybiAwXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIGNoaWxkcmVuX2xlZnQgPSBzZWxmLl9jaGlsZF9sZWZ0LnNpemUoKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBjaGlsZHJlbl9sZWZ0ID0gMFxcblxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgY2hpbGRyZW5fcmlnaHQgPSBzZWxmLl9jaGlsZF9yaWdodC5zaXplKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgY2hpbGRyZW5fcmlnaHQgPSAwXFxuXFxuICAgICAgICByZXR1cm4gMSArIGNoaWxkcmVuX2xlZnQgKyBjaGlsZHJlbl9yaWdodFxcblwiLFwic3JjL2xpYi9weXRob25kczMvdHJlZXMvcHJpb3JpdHlfcXVldWUucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuZnJvbSBweXRob25kczMudHJlZXMuYmluYXJ5X2hlYXAgaW1wb3J0IEJpbmFyeUhlYXBcXG5cXG5cXG5jbGFzcyBQcmlvcml0eVF1ZXVlKEJpbmFyeUhlYXApOlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgaGVhcCB0YWtlcyAoa2V5LCB2YWx1ZSkgcGFpcnMgd2hlcmUga2V5IHNpZ25pZmllcyBwcmlvcml0eVxcbiAgICBXZSB3aWxsIGFzc3VtZSB0aGF0IHRoZSBrZXlzIGFyZSBhbGwgY29tcGFyYWJsZS5cXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBjaGFuZ2VfcHJpb3JpdHkoc2VsZiwgbmV3X3ByaW9yaXR5LCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGFuZ2UgdGhlIHByaW9yaXR5XFxcIlxcXCJcXFwiXFxuICAgICAgICBrZXlfdG9fbW92ZSA9IDBcXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihzZWxmLl9oZWFwKSk6XFxuICAgICAgICAgICAgaWYgc2VsZi5faGVhcFtpXVsxXSA9PSB2YWx1ZTpcXG4gICAgICAgICAgICAgICAga2V5X3RvX21vdmUgPSBpXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBpZiBrZXlfdG9fbW92ZSA+IC0xOlxcbiAgICAgICAgICAgIHNlbGYuX2hlYXBba2V5X3RvX21vdmVdID0gKG5ld19wcmlvcml0eSwgc2VsZi5faGVhcFtrZXlfdG9fbW92ZV1bMV0pXFxuICAgICAgICAgICAgc2VsZi5fcGVyY191cChrZXlfdG9fbW92ZSlcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvX19pbml0X18ucHlcIjpcIlwiLFwic3JjL2xpYi9weXRob25lZC9hcmJvbGVzL19faW5pdF9fLnB5XCI6XCJcXG5cXG5cXG5mcm9tIC5hdmwgaW1wb3J0IEFyYm9sQVZMXFxuZnJvbSAuYWJiIGltcG9ydCBBcmJvbEJpbmFyaW9CdXNxdWVkYVxcbmZyb20gLm1vbnRpY3Vsb0JpbmFyaW8gaW1wb3J0IE1vbnRpY3Vsb0JpbmFyaW9cXG5cXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYXJib2xlcy9hYmIucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jXFxuI2FiYi5weVxcblxcbmNsYXNzIEFyYm9sQmluYXJpb0J1c3F1ZWRhOlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLnJhaXogPSBOb25lXFxuICAgICAgICBzZWxmLnRhbWFubyA9IDBcXG5cXG4gICAgZGVmIGFncmVnYXIoc2VsZixjbGF2ZSx2YWxvcik6XFxuICAgICAgICBpZiBzZWxmLnJhaXo6XFxuICAgICAgICAgICAgc2VsZi5fYWdyZWdhcihjbGF2ZSx2YWxvcixzZWxmLnJhaXopXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNlbGYucmFpeiA9IE5vZG9BcmJvbChjbGF2ZSx2YWxvcilcXG4gICAgICAgIHNlbGYudGFtYW5vID0gc2VsZi50YW1hbm8gKyAxXFxuXFxuICAgIGRlZiBfYWdyZWdhcihzZWxmLGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwpOlxcbiAgICAgICAgaWYgY2xhdmUgPCBub2RvQWN0dWFsLmNsYXZlOlxcbiAgICAgICAgICAgIGlmIG5vZG9BY3R1YWwudGllbmVIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgICAgIHNlbGYuX2FncmVnYXIoY2xhdmUsdmFsb3Isbm9kb0FjdHVhbC5oaWpvSXpxdWllcmRvKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbyA9IE5vZG9BcmJvbChjbGF2ZSx2YWxvcixwYWRyZT1ub2RvQWN0dWFsKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBub2RvQWN0dWFsLnRpZW5lSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICAgICAgICAgc2VsZi5fYWdyZWdhcihjbGF2ZSx2YWxvcixub2RvQWN0dWFsLmhpam9EZXJlY2hvKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8gPSBOb2RvQXJib2woY2xhdmUsdmFsb3IscGFkcmU9bm9kb0FjdHVhbClcXG4gXFxuICAgIGRlZiBfX3NldGl0ZW1fXyhzZWxmLGMsdik6XFxuICAgICAgICBzZWxmLmFncmVnYXIoYyx2KVxcblxcbiAgICBkZWYgb2J0ZW5lcihzZWxmLGNsYXZlKTpcXG4gICAgICAgIGlmIHNlbGYucmFpejpcXG4gICAgICAgICAgICByZXMgPSBzZWxmLl9vYnRlbmVyKGNsYXZlLHNlbGYucmFpeilcXG4gICAgICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuY2FyZ2FVdGlsXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG5cXG4gICAgZGVmIF9vYnRlbmVyKHNlbGYsY2xhdmUsbm9kb0FjdHVhbCk6XFxuICAgIFxcdGlmIG5vdCBub2RvQWN0dWFsOlxcbiAgICBcXHQgICAgcmV0dXJuIE5vbmVcXG4gICAgXFx0ZWxpZiBub2RvQWN0dWFsLmNsYXZlID09IGNsYXZlOlxcbiAgICBcXHQgICAgcmV0dXJuIG5vZG9BY3R1YWxcXG4gICAgXFx0ZWxpZiBjbGF2ZSA8IG5vZG9BY3R1YWwuY2xhdmU6XFxuICAgIFxcdCAgICByZXR1cm4gc2VsZi5fb2J0ZW5lcihjbGF2ZSxub2RvQWN0dWFsLmhpam9JenF1aWVyZG8pXFxuICAgIFxcdGVsc2U6XFxuICAgIFxcdCAgICByZXR1cm4gc2VsZi5fb2J0ZW5lcihjbGF2ZSxub2RvQWN0dWFsLmhpam9EZXJlY2hvKSAgICAgICAgXFxuXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLGNsYXZlKTpcXG4gICAgICAgIHJlcyA9IHNlbGYub2J0ZW5lcihjbGF2ZSkgXFxuICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgcmV0dXJuIHJlc1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGxhIGNsYXZlIG5vIGVzdMOhIGVuIGVsIMOhcmJvbCcpXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixjbGF2ZSk6XFxuICAgIFxcdGlmIHNlbGYuX29idGVuZXIoY2xhdmUsc2VsZi5yYWl6KTpcXG4gICAgXFx0ICAgIHJldHVybiBUcnVlXFxuICAgIFxcdGVsc2U6XFxuICAgIFxcdCAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgXFxuICAgIGRlZiBsb25naXR1ZChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnRhbWFub1xcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnRhbWFub1xcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yYWl6Ll9faXRlcl9fKClcXG5cXG4gICAgZGVmIGVsaW1pbmFyKHNlbGYsY2xhdmUpOlxcbiAgICAgICAgaWYgc2VsZi50YW1hbm8gPiAxOlxcbiAgICAgICAgICAgbm9kb0FFbGltaW5hciA9IHNlbGYuX29idGVuZXIoY2xhdmUsc2VsZi5yYWl6KVxcbiAgICBcXHQgICBpZiBub2RvQUVsaW1pbmFyOlxcbiAgICBcXHQgICAgICAgc2VsZi5yZW1vdmVyKG5vZG9BRWxpbWluYXIpXFxuICAgIFxcdCAgICAgICBzZWxmLnRhbWFubyA9IHNlbGYudGFtYW5vLTFcXG4gICAgXFx0ICAgZWxzZTpcXG4gICAgXFx0ICAgICAgIHJhaXNlIEtleUVycm9yKCdFcnJvciwgbGEgY2xhdmUgbm8gZXN0w6EgZW4gZWwgw6FyYm9sJylcXG4gICAgICAgIGVsaWYgc2VsZi50YW1hbm8gPT0gMSBhbmQgc2VsZi5yYWl6LmNsYXZlID09IGNsYXZlOlxcbiAgICBcXHQgICAgc2VsZi5yYWl6ID0gTm9uZVxcbiAgICBcXHQgICAgc2VsZi50YW1hbm8gPSBzZWxmLnRhbWFubyAtIDFcXG4gICAgICAgIGVsc2U6XFxuICAgIFxcdCAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGxhIGNsYXZlIG5vIGVzdMOhIGVuIGVsIMOhcmJvbCcpXFxuXFxuICAgIGRlZiBfX2RlbGl0ZW1fXyhzZWxmLGNsYXZlKTpcXG4gICAgICAgIHNlbGYuZWxpbWluYXIoY2xhdmUpXFxuXFxuICAgIGRlZiByZW1vdmVyKHNlbGYsbm9kb0FjdHVhbCk6XFxuICAgICAgICBpZiBub2RvQWN0dWFsLmVzSG9qYSgpOiAjaG9qYVxcbiAgICAgICAgICAgIGlmIG5vZG9BY3R1YWwgPT0gbm9kb0FjdHVhbC5wYWRyZS5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgICAgICBub2RvQWN0dWFsLnBhZHJlLmhpam9JenF1aWVyZG8gPSBOb25lXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvRGVyZWNobyA9IE5vbmVcXG4gICAgICAgIGVsaWYgbm9kb0FjdHVhbC50aWVuZUFtYm9zSGlqb3MoKTogI2ludGVyaW9yXFxuICAgICAgICAgICAgc3VjID0gbm9kb0FjdHVhbC5lbmNvbnRyYXJTdWNlc29yKClcXG4gICAgICAgICAgICBzdWMuZW1wYWxtYXIoKVxcbiAgICAgICAgICAgIG5vZG9BY3R1YWwuY2xhdmUgPSBzdWMuY2xhdmVcXG4gICAgICAgICAgICBub2RvQWN0dWFsLmNhcmdhVXRpbCA9IHN1Yy5jYXJnYVV0aWxcXG5cXG4gICAgICAgIGVsc2U6ICMgZXN0ZSBub2RvIHRpZW5lIHVuICgxKSBoaWpvXFxuICAgICAgICAgICAgaWYgbm9kb0FjdHVhbC50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgaWYgbm9kb0FjdHVhbC5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkby5wYWRyZSA9IG5vZG9BY3R1YWwucGFkcmVcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucGFkcmUuaGlqb0l6cXVpZXJkbyA9IG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgICAgICAgICBlbGlmIG5vZG9BY3R1YWwuZXNIaWpvRGVyZWNobygpOlxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5oaWpvSXpxdWllcmRvLnBhZHJlID0gbm9kb0FjdHVhbC5wYWRyZVxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvRGVyZWNobyA9IG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5yZWVtcGxhemFyRGF0b0RlTm9kbyhub2RvQWN0dWFsLmhpam9JenF1aWVyZG8uY2xhdmUsIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkby5jYXJnYVV0aWwsIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkby5oaWpvSXpxdWllcmRvLCBub2RvQWN0dWFsLmhpam9JenF1aWVyZG8uaGlqb0RlcmVjaG8pXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgbm9kb0FjdHVhbC5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8ucGFkcmUgPSBub2RvQWN0dWFsLnBhZHJlXFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLnBhZHJlLmhpam9JenF1aWVyZG8gPSBub2RvQWN0dWFsLmhpam9EZXJlY2hvXFxuICAgICAgICAgICAgICAgIGVsaWYgbm9kb0FjdHVhbC5lc0hpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLmhpam9EZXJlY2hvLnBhZHJlID0gbm9kb0FjdHVhbC5wYWRyZVxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvRGVyZWNobyA9IG5vZG9BY3R1YWwuaGlqb0RlcmVjaG9cXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucmVlbXBsYXphckRhdG9EZU5vZG8obm9kb0FjdHVhbC5oaWpvRGVyZWNoby5jbGF2ZSwgbm9kb0FjdHVhbC5oaWpvRGVyZWNoby5jYXJnYVV0aWwsIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8uaGlqb0l6cXVpZXJkbywgbm9kb0FjdHVhbC5oaWpvRGVyZWNoby5oaWpvRGVyZWNobylcXG5cXG4gICAgZGVmIGlub3JkZW4oc2VsZik6XFxuICAgICAgICBzZWxmLl9pbm9yZGVuKHNlbGYucmFpeilcXG5cXG4gICAgZGVmIF9pbm9yZGVuKHNlbGYsYXJib2wpOlxcbiAgICAgICAgaWYgYXJib2wgIT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVuKGFyYm9sLmhpam9JenF1aWVyZG8pXFxuICAgICAgICAgICAgcHJpbnQoYXJib2wuY2xhdmUpXFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlbihhcmJvbC5oaWpvRGVyZWNobylcXG5cXG4gICAgZGVmIHBvc3RvcmRlbihzZWxmKTpcXG4gICAgICAgIHNlbGYuX3Bvc3RvcmRlbihzZWxmLnJhaXopXFxuXFxuICAgIGRlZiBfcG9zdG9yZGVuKHNlbGYsIGFyYm9sKTpcXG4gICAgICAgIGlmIGFyYm9sOlxcbiAgICAgICAgICAgIHNlbGYuX3Bvc3RvcmRlbihhcmJvbC5oaWpvRGVyZWNobylcXG4gICAgICAgICAgICBzZWxmLl9wb3N0b3JkZW4oYXJib2wuaGlqb0l6cXVpZXJkbylcXG4gICAgICAgICAgICBwcmludChhcmJvbC5jbGF2ZSkgICAgICAgICAgICBcXG5cXG4gICAgZGVmIHByZW9yZGVuKHNlbGYpOlxcbiAgICAgICAgc2VsZi5fcHJlb3JkZW4oc2VsZixzZWxmLnJhaXopXFxuXFxuICAgIGRlZiBfcHJlb3JkZW4oc2VsZixhcmJvbCk6XFxuICAgICAgICBpZiBhcmJvbDpcXG4gICAgICAgICAgICBwcmludChhcmJvbC5jbGF2ZSkgICAgICAgICAgICBcXG4gICAgICAgICAgICBzZWxmLl9wcmVvcmRlbihhcmJvbC5oaWpvSXpxdWllcmRvKVxcbiAgICAgICAgICAgIHNlbGYuX3ByZW9yZGVuKGFyYm9sLmhpam9EZXJlY2hvKVxcblxcblxcbmNsYXNzIE5vZG9BcmJvbDpcXG4gICBkZWYgX19pbml0X18oc2VsZixjbGF2ZSx2YWxvcixpenF1aWVyZG89Tm9uZSxkZXJlY2hvPU5vbmUscGFkcmU9Tm9uZSk6XFxuICAgICAgICBzZWxmLmNsYXZlID0gY2xhdmVcXG4gICAgICAgIHNlbGYuY2FyZ2FVdGlsID0gdmFsb3JcXG4gICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkbyA9IGl6cXVpZXJkb1xcbiAgICAgICAgc2VsZi5oaWpvRGVyZWNobyA9IGRlcmVjaG9cXG4gICAgICAgIHNlbGYucGFkcmUgPSBwYWRyZVxcbiAgICAgICAgc2VsZi5mYWN0b3JFcXVpbGlicmlvID0gMFxcblxcbiAgICBkZWYgdGllbmVIaWpvSXpxdWllcmRvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0l6cXVpZXJkb1xcbiAgICAgICBcXG4gICAgZGVmIHRpZW5lSGlqb0RlcmVjaG8oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5oaWpvRGVyZWNob1xcblxcbiAgICBkZWYgZXNIaWpvSXpxdWllcmRvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucGFkcmUgYW5kIHNlbGYucGFkcmUuaGlqb0l6cXVpZXJkbyA9PSBzZWxmXFxuICAgIFxcbiAgICBkZWYgZXNIaWpvRGVyZWNobyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnBhZHJlIGFuZCBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID09IHNlbGZcXG5cXG4gICAgZGVmIGVzUmFpeihzZWxmKTpcXG4gICAgICAgIHJldHVybiBub3Qgc2VsZi5wYWRyZVxcblxcbiAgICBkZWYgZXNIb2phKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIG5vdCAoc2VsZi5oaWpvRGVyZWNobyBvciBzZWxmLmhpam9JenF1aWVyZG8pXFxuXFxuICAgIGRlZiB0aWVuZUFsZ3VuSGlqbyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmhpam9EZXJlY2hvIG9yIHNlbGYuaGlqb0l6cXVpZXJkb1xcblxcbiAgICBkZWYgdGllbmVBbWJvc0hpam9zKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0RlcmVjaG8gYW5kIHNlbGYuaGlqb0l6cXVpZXJkb1xcblxcbiAgICBkZWYgcmVlbXBsYXphckRhdG9EZU5vZG8oc2VsZixjbGF2ZSx2YWxvcixoaXpxLGhkZXIpOlxcbiAgICAgICAgc2VsZi5jbGF2ZSA9IGNsYXZlXFxuICAgICAgICBzZWxmLmNhcmdhVXRpbCA9IHZhbG9yXFxuICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8gPSBoaXpxXFxuICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gaGRlclxcbiAgICAgICAgaWYgc2VsZi50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8ucGFkcmUgPSBzZWxmXFxuICAgICAgICBpZiBzZWxmLnRpZW5lSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvLnBhZHJlID0gc2VsZiAgICBcXG5cXG4gICAgZGVmIGVuY29udHJhclN1Y2Vzb3Ioc2VsZik6XFxuICAgICAgICBzdWMgPSBOb25lXFxuICAgICAgICBpZiBzZWxmLnRpZW5lSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICBzdWMgPSBzZWxmLmhpam9EZXJlY2hvLmVuY29udHJhck1pbigpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHNlbGYucGFkcmU6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuZXNIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgICAgICBzdWMgPSBzZWxmLnBhZHJlXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID0gTm9uZVxcbiAgICAgICAgICAgICAgICAgICAgc3VjID0gc2VsZi5wYWRyZS5lbmNvbnRyYXJTdWNlc29yKClcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0RlcmVjaG8gPSBzZWxmXFxuICAgICAgICByZXR1cm4gc3VjXFxuXFxuICAgIGRlZiBlbXBhbG1hcihzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuZXNIb2phKCk6XFxuICAgICAgICAgICAgaWYgc2VsZi5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvSXpxdWllcmRvID0gTm9uZVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0RlcmVjaG8gPSBOb25lXFxuICAgICAgICBlbGlmIHNlbGYudGllbmVBbGd1bkhpam8oKTpcXG4gICAgICAgICAgICBpZiBzZWxmLnRpZW5lSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvSXpxdWllcmRvID0gc2VsZi5oaWpvSXpxdWllcmRvXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID0gc2VsZi5oaWpvSXpxdWllcmRvXFxuICAgICAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkby5wYWRyZSA9IHNlbGYucGFkcmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvSXpxdWllcmRvID0gc2VsZi5oaWpvRGVyZWNob1xcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvRGVyZWNobyA9IHNlbGYuaGlqb0RlcmVjaG9cXG4gICAgICAgICAgICAgICAgc2VsZi5oaWpvRGVyZWNoby5wYWRyZSA9IHNlbGYucGFkcmVcXG5cXG4gICAgZGVmIGVuY29udHJhck1pbihzZWxmKTpcXG4gICAgICAgIGFjdHVhbCA9IHNlbGZcXG4gICAgICAgIHdoaWxlIGFjdHVhbC50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICBhY3R1YWwgPSBhY3R1YWwuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgcmV0dXJuIGFjdHVhbFxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICBpZiBzZWxmOlxcbiAgICBcXHQgICAgaWYgc2VsZi50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgXFx0ICAgICAgICBmb3IgZWxlbSBpbiBzZWxmLmhpam9JenF1aWVyZG86XFxuICAgIFxcdFxcdCAgICB5aWVsZCBlbGVtXFxuICAgICAgICAgICAgeWllbGQgc2VsZi5jbGF2ZVxcbiAgICBcXHQgICAgaWYgc2VsZi50aWVuZUhpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgICAgIGZvciBlbGVtIGluIHNlbGYuaGlqb0RlcmVjaG86XFxuICAgIFxcdFxcdCAgICB5aWVsZCBlbGVtXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2FyYm9sZXMvYXJib2xCaW5hcmlvLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuIyBcXG4jYXJib2xCaW5hcmlvLnB5XFxuXFxuY2xhc3MgQXJib2xCaW5hcmlvOlxcbiAgICBkZWYgX19pbml0X18oc2VsZixvYmpldG9SYWl6KTpcXG4gICAgICAgIHNlbGYuY2xhdmUgPSBvYmpldG9SYWl6XFxuICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8gPSBOb25lXFxuICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gTm9uZVxcbiAgICBcXG4gICAgZGVmIGluc2VydGFySXpxdWllcmRvKHNlbGYsbnVldm9Ob2RvKTpcXG4gICAgICAgIGlmIHNlbGYuaGlqb0l6cXVpZXJkbyA9PSBOb25lOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkbyA9IEFyYm9sQmluYXJpbyhudWV2b05vZG8pXFxuICAgICAgICBlbHNlOiAgXFxuICAgICAgICAgICAgdCA9IEFyYm9sQmluYXJpbyhudWV2b05vZG8pXFxuICAgICAgICAgICAgdC5oaWpvSXpxdWllcmRvID0gc2VsZi5oaWpvSXpxdWllcmRvXFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvID0gdFxcblxcbiAgICBkZWYgaW5zZXJ0YXJEZXJlY2hvKHNlbGYsbnVldm9Ob2RvKTpcXG4gICAgICAgIGlmIHNlbGYuaGlqb0RlcmVjaG8gPT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gQXJib2xCaW5hcmlvKG51ZXZvTm9kbylcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgdCA9IEFyYm9sQmluYXJpbyhudWV2b05vZG8pXFxuICAgICAgICAgICAgdC5oaWpvRGVyZWNobyA9IHNlbGYuaGlqb0RlcmVjaG9cXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gdFxcblxcbiAgICBkZWYgZXNIb2phKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuICgobm90IHNlbGYuaGlqb0l6cXVpZXJkbykgYW5kIChub3Qgc2VsZi5oaWpvRGVyZWNobykpXFxuXFxuICAgIGRlZiBvYnRlbmVySGlqb0RlcmVjaG8oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5oaWpvRGVyZWNob1xcbiAgICBcXG4gICAgZGVmIG9idGVuZXJIaWpvSXpxdWllcmRvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0l6cXVpZXJkb1xcbiAgICBcXG4gICAgZGVmIGFzaWduYXJWYWxvclJhaXooc2VsZixvYmopOlxcbiAgICAgICAgc2VsZi5jbGF2ZSA9IG9ialxcblxcbiAgICBkZWYgb2J0ZW5lclZhbG9yUmFpeihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmNsYXZlXFxuXFxuICAgIGRlZiBpbm9yZGVuKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkby5pbm9yZGVuKClcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUpXFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8uaW5vcmRlbigpXFxuXFxuICAgIGRlZiBwb3N0b3JkZW4oc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmhpam9JenF1aWVyZG86XFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvLnBvc3RvcmRlbigpXFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8ucG9zdG9yZGVuKClcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUpXFxuXFxuICAgIGRlZiBwcmVvcmRlbihzZWxmKTpcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUpXFxuICAgICAgICBpZiBzZWxmLmhpam9JenF1aWVyZG86XFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvLnByZW9yZGVuKClcXG4gICAgICAgIGlmIHNlbGYuaGlqb0RlcmVjaG86XFxuICAgICAgICAgICAgc2VsZi5oaWpvRGVyZWNoby5wcmVvcmRlbigpXFxuXFxuICAgIGRlZiBpbXByaW1pckV4cHJlc2lvbihzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuaGlqb0l6cXVpZXJkbzpcXG4gICAgICAgICAgICBwcmludCgnKCcsIGVuZD0nICcpXFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvLmltcHJpbWlyRXhwcmVzaW9uKClcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUsIGVuZD0nICcpXFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8uaW1wcmltaXJFeHByZXNpb24oKVxcbiAgICAgICAgICAgIHByaW50KCcpJywgZW5kPScgJylcXG5cXG4gICAgZGVmIGV2YWxQb3N0b3JkZW4oc2VsZik6XFxuICAgICAgICBvcGVycyA9IHsnKyc6b3BlcmF0b3IuYWRkLCAnLSc6b3BlcmF0b3Iuc3ViLCAnKic6b3BlcmF0b3IubXVsLCAnLyc6b3BlcmF0b3IudHJ1ZWRpdn1cXG4gICAgICAgIHJlczEgPSBOb25lXFxuICAgICAgICByZXMyID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgIHJlczEgPSBzZWxmLmhpam9JenF1aWVyZG8uZXZhbFBvc3RvcmRlbigpICAjLy8gXFxcXGxhYmVse3BlbGVmdH1cXG4gICAgICAgIGlmIHNlbGYuaGlqb0RlcmVjaG86XFxuICAgICAgICAgICAgcmVzMiA9IHNlbGYuaGlqb0RlcmVjaG8uZXZhbFBvc3RvcmRlbigpICMvLyBcXFxcbGFiZWx7cGVyaWdodH1cXG4gICAgICAgIGlmIHJlczEgYW5kIHJlczI6XFxuICAgICAgICAgICAgcmV0dXJuIG9wZXJzW3NlbGYuY2xhdmVdKHJlczEscmVzMikgIy8vIFxcXFxsYWJlbHtwZWV2YWx9XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNsYXZlXFxuXFxuZGVmIGlub3JkZW4oYXJib2wpOlxcbiAgICBpZiBhcmJvbCAhPSBOb25lOlxcbiAgICAgICAgaW5vcmRlbihhcmJvbC5vYnRlbmVySGlqb0l6cXVpZXJkbygpKVxcbiAgICAgICAgcHJpbnQoYXJib2wub2J0ZW5lclZhbG9yUmFpeigpKVxcbiAgICAgICAgaW5vcmRlbihhcmJvbC5vYnRlbmVySGlqb0RlcmVjaG8oKSlcXG5cXG5kZWYgaW1wcmltaXJFeHByZXNpb24oYXJib2wpOlxcbiAgICBpZiBhcmJvbC5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgcHJpbnQoJygnLCBlbmQ9JyAnKVxcbiAgICAgICAgaW1wcmltaXJFeHByZXNpb24oYXJib2wub2J0ZW5lckhpam9JenF1aWVyZG8oKSlcXG4gICAgcHJpbnQoYXJib2wub2J0ZW5lclZhbG9yUmFpeigpLCBlbmQ9JyAnKVxcbiAgICBpZiBhcmJvbC5oaWpvRGVyZWNobzpcXG4gICAgICAgIGltcHJpbWlyRXhwcmVzaW9uKGFyYm9sLm9idGVuZXJIaWpvRGVyZWNobygpKVxcbiAgICAgICAgcHJpbnQoJyknLCBlbmQ9JyAnKSBcXG5cXG5kZWYgaW1wcmltaXJFeHByZXNpb24oYXJib2wpOlxcbiAgdmFsb3JDYWRlbmEgPSBcXFwiXFxcIlxcbiAgaWYgYXJib2w6XFxuICAgICAgdmFsb3JDYWRlbmEgPSAnKCcgKyBpbXByaW1pckV4cHJlc2lvbihhcmJvbC5vYnRlbmVySGlqb0l6cXVpZXJkbygpKVxcbiAgICAgIHZhbG9yQ2FkZW5hID0gdmFsb3JDYWRlbmEgKyBzdHIoYXJib2wub2J0ZW5lclZhbG9yUmFpeigpKVxcbiAgICAgIHZhbG9yQ2FkZW5hID0gdmFsb3JDYWRlbmEgKyBpbXByaW1pckV4cHJlc2lvbihhcmJvbC5vYnRlbmVySGlqb0RlcmVjaG8oKSkrJyknXFxuICByZXR1cm4gdmFsb3JDYWRlbmFcXG5cXG5kZWYgZXZhbFBvc3RvcmRlbihhcmJvbCk6XFxuICAgIG9wZXJhZG9yZXMgPSB7JysnOm9wZXJhdG9yLmFkZCwgJy0nOm9wZXJhdG9yLnN1YiwgJyonOm9wZXJhdG9yLm11bCwgJy8nOm9wZXJhdG9yLnRydWVkaXZ9XFxuICAgIHJlczEgPSBOb25lXFxuICAgIHJlczIgPSBOb25lXFxuICAgIGlmIGFyYm9sOlxcbiAgICAgICAgcmVzMSA9IGV2YWxQb3N0b3JkZW4oYXJib2wub2J0ZW5lckhpam9JenF1aWVyZG8oKSkgIy8vIFxcXFxsYWJlbHtwZWxlZnR9XFxuICAgICAgICByZXMyID0gZXZhbFBvc3RvcmRlbihhcmJvbC5vYnRlbmVySGlqb0RlcmVjaG8oKSkgICMvLyBcXFxcbGFiZWx7cGVyaWdodH1cXG4gICAgICAgIGlmIHJlczEgYW5kIHJlczI6XFxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhZG9yZXNbYXJib2wub2J0ZW5lclZhbG9yUmFpeigpXShyZXMxLHJlczIpICMvLyBcXFxcbGFiZWx7cGVldmFsfVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gYXJib2wub2J0ZW5lclZhbG9yUmFpeigpXFxuXFxuZGVmIGFsdHVyYShhcmJvbCk6XFxuICAgIGlmIGFyYm9sID09IE5vbmU6XFxuICAgICAgICByZXR1cm4gLTFcXG4gICAgZWxzZTpcXG4gICAgICAgIHJldHVybiAxICsgbWF4KGFsdHVyYShhcmJvbC5oaWpvSXpxdWllcmRvKSxhbHR1cmEoYXJib2wuaGlqb0RlcmVjaG8pKVxcblxcbnQgPSBBcmJvbEJpbmFyaW8oNylcXG50Lmluc2VydGFySXpxdWllcmRvKDMpXFxudC5pbnNlcnRhckRlcmVjaG8oOSlcXG5pbm9yZGVuKHQpXFxuaW1wb3J0IG9wZXJhdG9yXFxueCA9IEFyYm9sQmluYXJpbygnKicpXFxueC5pbnNlcnRhckl6cXVpZXJkbygnKycpXFxubCA9IHgub2J0ZW5lckhpam9JenF1aWVyZG8oKVxcbmwuaW5zZXJ0YXJJenF1aWVyZG8oNClcXG5sLmluc2VydGFyRGVyZWNobyg1KVxcbnguaW5zZXJ0YXJEZXJlY2hvKDcpXFxucHJpbnQoaW1wcmltaXJFeHByZXNpb24oeCkpXFxucHJpbnQoZXZhbFBvc3RvcmRlbih4KSlcXG5wcmludChhbHR1cmEoeCkpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2FyYm9sZXMvYXZsLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuI1xcbiNhdmwucHlcXG5cXG5mcm9tIC5hYmIgaW1wb3J0IEFyYm9sQmluYXJpb0J1c3F1ZWRhLCBOb2RvQXJib2xcXG5cXG5jbGFzcyBBcmJvbEFWTChBcmJvbEJpbmFyaW9CdXNxdWVkYSk6XFxuXFxuICAgIGRlZiBfYWdyZWdhcihzZWxmLGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwpOlxcbiAgICBcXHRpZiBjbGF2ZSA8IG5vZG9BY3R1YWwuY2xhdmU6XFxuICAgIFxcdCAgICBpZiBub2RvQWN0dWFsLnRpZW5lSGlqb0l6cXVpZXJkbygpOlxcbiAgICBcXHRcXHRzZWxmLl9hZ3JlZ2FyKGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbylcXG4gICAgXFx0ICAgIGVsc2U6XFxuICAgIFxcdFxcdG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbyA9IE5vZG9BcmJvbChjbGF2ZSx2YWxvcixwYWRyZT1ub2RvQWN0dWFsKVxcbiAgICBcXHRcXHRzZWxmLmFjdHVhbGl6YXJFcXVpbGlicmlvKG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbylcXG4gICAgXFx0ZWxzZTpcXG4gICAgXFx0ICAgIGlmIG5vZG9BY3R1YWwudGllbmVIaWpvRGVyZWNobygpOlxcbiAgICBcXHRcXHRzZWxmLl9hZ3JlZ2FyKGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8pXFxuICAgIFxcdCAgICBlbHNlOlxcbiAgICBcXHRcXHRub2RvQWN0dWFsLmhpam9EZXJlY2hvID0gTm9kb0FyYm9sKGNsYXZlLHZhbG9yLHBhZHJlPW5vZG9BY3R1YWwpXFxuICAgIFxcdFxcdHNlbGYuYWN0dWFsaXphckVxdWlsaWJyaW8obm9kb0FjdHVhbC5oaWpvRGVyZWNobylcXG5cXG4gICAgZGVmIGFjdHVhbGl6YXJFcXVpbGlicmlvKHNlbGYsbm9kbyk6XFxuICAgIFxcdGlmIG5vZG8uZmFjdG9yRXF1aWxpYnJpbyA+IDEgb3Igbm9kby5mYWN0b3JFcXVpbGlicmlvIDwgLTE6XFxuICAgIFxcdCAgICBzZWxmLnJlZXF1aWxpYnJhcihub2RvKSAgICBcXG4gICAgXFx0ICAgIHJldHVyblxcbiAgICBcXHRpZiBub2RvLnBhZHJlICE9IE5vbmU6XFxuICAgIFxcdCAgICBpZiBub2RvLmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICBcXHRcXHQgICAgbm9kby5wYWRyZS5mYWN0b3JFcXVpbGlicmlvICs9IDFcXG4gICAgXFx0ICAgIGVsaWYgbm9kby5lc0hpam9EZXJlY2hvKCk6XFxuICAgIFxcdFxcdCAgICBub2RvLnBhZHJlLmZhY3RvckVxdWlsaWJyaW8gLT0gMVxcblxcbiAgICBcXHQgICAgaWYgbm9kby5wYWRyZS5mYWN0b3JFcXVpbGlicmlvICE9IDA6XFxuICAgIFxcdFxcdCAgICBzZWxmLmFjdHVhbGl6YXJFcXVpbGlicmlvKG5vZG8ucGFkcmUpXFxuXFxuICAgIGRlZiByZWVxdWlsaWJyYXIoc2VsZixub2RvKTpcXG4gICAgICAgIGlmIG5vZG8uZmFjdG9yRXF1aWxpYnJpbyA8IDA6XFxuXFx0ICAgIGlmIG5vZG8uaGlqb0RlcmVjaG8uZmFjdG9yRXF1aWxpYnJpbyA+IDA6XFxuXFx0ICAgICAgICBzZWxmLnJvdGFyRGVyZWNoYShub2RvLmhpam9EZXJlY2hvKVxcblxcdCAgICAgICAgc2VsZi5yb3Rhckl6cXVpZXJkYShub2RvKVxcblxcdCAgICBlbHNlOlxcblxcdCAgICAgICAgc2VsZi5yb3Rhckl6cXVpZXJkYShub2RvKVxcbiAgICAgICAgZWxpZiBub2RvLmZhY3RvckVxdWlsaWJyaW8gPiAwOlxcblxcdCAgICBpZiBub2RvLmhpam9JenF1aWVyZG8uZmFjdG9yRXF1aWxpYnJpbyA8IDA6XFxuXFx0ICAgICAgICBzZWxmLnJvdGFySXpxdWllcmRhKG5vZG8uaGlqb0l6cXVpZXJkbylcXG5cXHQgICAgICAgIHNlbGYucm90YXJEZXJlY2hhKG5vZG8pXFxuXFx0ICAgICBlbHNlOlxcblxcdCAgICAgICAgc2VsZi5yb3RhckRlcmVjaGEobm9kbylcXG4gICAgICAgICAgIFxcbiAgICBkZWYgcm90YXJJenF1aWVyZGEoc2VsZixyb3RSYWl6KTpcXG4gICAgXFx0bnVldmFSYWl6ID0gcm90UmFpei5oaWpvRGVyZWNob1xcbiAgICBcXHRyb3RSYWl6Lmhpam9EZXJlY2hvID0gbnVldmFSYWl6Lmhpam9JenF1aWVyZG9cXG4gICAgXFx0aWYgbnVldmFSYWl6Lmhpam9JenF1aWVyZG8gIT0gTm9uZTpcXG4gICAgXFx0ICAgIG51ZXZhUmFpei5oaWpvSXpxdWllcmRvLnBhZHJlID0gcm90UmFpelxcbiAgICBcXHRudWV2YVJhaXoucGFkcmUgPSByb3RSYWl6LnBhZHJlXFxuICAgIFxcdGlmIHJvdFJhaXouZXNSYWl6KCk6XFxuICAgIFxcdCAgICBzZWxmLnJhaXogPSBudWV2YVJhaXpcXG4gICAgXFx0ZWxzZTpcXG4gICAgXFx0ICAgIGlmIHJvdFJhaXouZXNIaWpvSXpxdWllcmRvKCk6XFxuICAgIFxcdCAgICAgICAgcm90UmFpei5wYWRyZS5oaWpvSXpxdWllcmRvID0gbnVldmFSYWl6XFxuICAgIFxcdCAgICBlbHNlOlxcbiAgICBcXHQgICAgXFx0cm90UmFpei5wYWRyZS5oaWpvRGVyZWNobyA9IG51ZXZhUmFpelxcbiAgICBcXHRudWV2YVJhaXouaGlqb0l6cXVpZXJkbyA9IHJvdFJhaXpcXG4gICAgXFx0cm90UmFpei5wYWRyZSA9IG51ZXZhUmFpelxcbiAgICBcXHRyb3RSYWl6LmZhY3RvckVxdWlsaWJyaW8gPSByb3RSYWl6LmZhY3RvckVxdWlsaWJyaW8gKyAxIC0gbWluKG51ZXZhUmFpei5mYWN0b3JFcXVpbGlicmlvLCAwKVxcbiAgICBcXHRudWV2YVJhaXouZmFjdG9yRXF1aWxpYnJpbyA9IG51ZXZhUmFpei5mYWN0b3JFcXVpbGlicmlvICsgMSArIG1heChyb3RSYWl6LmZhY3RvckVxdWlsaWJyaW8sIDApXFxuXFxuICAgIGRlZiByb3RhckRlcmVjaGEoc2VsZixyb3RSYWl6KTpcXG4gICAgICAgIG51ZXZhUmFpeiA9IHJvdFJhaXouaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgcm90UmFpei5oaWpvSXpxdWllcmRvID0gbnVldmFSYWl6Lmhpam9EZXJlY2hvXFxuICAgICAgICBpZiBudWV2YVJhaXouaGlqb0RlcmVjaG8gIT0gTm9uZTpcXG4gICAgICAgICAgICBudWV2YVJhaXouaGlqb0RlcmVjaG8ucGFkcmUgPSByb3RSYWl6XFxuICAgICAgICBudWV2YVJhaXoucGFkcmUgPSByb3RSYWl6LnBhZHJlXFxuICAgICAgICBpZiByb3RSYWl6LmVzUmFpeigpOlxcbiAgICAgICAgICAgIHNlbGYucmFpeiA9IG51ZXZhUmFpelxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiByb3RSYWl6LmVzSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICAgICAgcm90UmFpei5wYWRyZS5oaWpvRGVyZWNobyA9IG51ZXZhUmFpelxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJvdFJhaXoucGFkcmUuaGlqb0l6cXVpZXJkbyA9IG51ZXZhUmFpelxcbiAgICAgICAgbnVldmFSYWl6Lmhpam9EZXJlY2hvID0gcm90UmFpelxcbiAgICAgICAgcm90UmFpei5wYWRyZSA9IG51ZXZhUmFpelxcbiAgICAgICAgcm90UmFpei5mYWN0b3JFcXVpbGlicmlvID0gcm90UmFpei5mYWN0b3JFcXVpbGlicmlvIC0gMSAtIG1heChudWV2YVJhaXouZmFjdG9yRXF1aWxpYnJpbywgMClcXG4gICAgICAgIG51ZXZhUmFpei5mYWN0b3JFcXVpbGlicmlvID0gbnVldmFSYWl6LmZhY3RvckVxdWlsaWJyaW8gLSAxICsgbWluKHJvdFJhaXouZmFjdG9yRXF1aWxpYnJpbywgMCkgIFxcblxcblwiLFwic3JjL2xpYi9weXRob25lZC9hcmJvbGVzL21vbnRpY3Vsb0JpbmFyaW8ucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jIFxcbiNtb250aWN1bG9CaW5hcmlvLnB5XFxuXFxuY2xhc3MgTW9udGljdWxvQmluYXJpbzpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5saXN0YU1vbnRpY3VsbyA9IFswXVxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSAwXFxuXFxuICAgIGRlZiBjb25zdHJ1aXJNb250aWN1bG8oc2VsZix1bmFMaXN0YSk6XFxuICAgICAgICBpID0gbGVuKHVuYUxpc3RhKSAvLyAyXFxuICAgICAgICBzZWxmLnRhbWFub0FjdHVhbCA9IGxlbih1bmFMaXN0YSlcXG4gICAgICAgIHNlbGYubGlzdGFNb250aWN1bG8gPSBbMF0gKyB1bmFMaXN0YVs6XVxcbiAgICAgICAgcHJpbnQobGVuKHNlbGYubGlzdGFNb250aWN1bG8pLCBpKVxcbiAgICAgICAgd2hpbGUgKGkgPiAwKTpcXG4gICAgICAgICAgICBwcmludChzZWxmLmxpc3RhTW9udGljdWxvLCBpKVxcbiAgICAgICAgICAgIHNlbGYuaW5maWx0QWJham8oaSlcXG4gICAgICAgICAgICBpID0gaSAtIDFcXG4gICAgICAgIHByaW50KHNlbGYubGlzdGFNb250aWN1bG8saSlcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgZGVmIGluZmlsdEFiYWpvKHNlbGYsaSk6XFxuICAgICAgICB3aGlsZSAoaSAqIDIpIDw9IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgIGhtID0gc2VsZi5oaWpvTWluKGkpXFxuICAgICAgICAgICAgaWYgc2VsZi5saXN0YU1vbnRpY3Vsb1tpXSA+IHNlbGYubGlzdGFNb250aWN1bG9baG1dOlxcbiAgICAgICAgICAgICAgICB0bXAgPSBzZWxmLmxpc3RhTW9udGljdWxvW2ldXFxuICAgICAgICAgICAgICAgIHNlbGYubGlzdGFNb250aWN1bG9baV0gPSBzZWxmLmxpc3RhTW9udGljdWxvW2htXVxcbiAgICAgICAgICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvW2htXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBobVxcbiAgICAgICAgICAgICAgICBcXG4gICAgZGVmIGhpam9NaW4oc2VsZixpKTpcXG4gICAgICAgIGlmIGkgKiAyICsgMSA+IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgIHJldHVybiBpICogMlxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBzZWxmLmxpc3RhTW9udGljdWxvW2kgKiAyXSA8IHNlbGYubGlzdGFNb250aWN1bG9baSAqIDIgKyAxXTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKiAyXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKiAyICsgMVxcblxcbiAgICBkZWYgaW5maWx0QXJyaWJhKHNlbGYsaSk6XFxuICAgICAgICB3aGlsZSBpIC8vIDIgPiAwOlxcbiAgICAgICAgICAgIGlmIHNlbGYubGlzdGFNb250aWN1bG9baV0gPCBzZWxmLmxpc3RhTW9udGljdWxvW2kvLzJdOlxcbiAgICAgICAgICAgICAgIHRtcCA9IHNlbGYubGlzdGFNb250aWN1bG9baSAvLyAyXVxcbiAgICAgICAgICAgICAgIHNlbGYubGlzdGFNb250aWN1bG9baSAvLyAyXSA9IHNlbGYubGlzdGFNb250aWN1bG9baV1cXG4gICAgICAgICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvW2ldID0gdG1wXFxuICAgICAgICAgICAgaSA9IGkgLy8gMlxcbiBcXG4gICAgZGVmIGluc2VydGFyKHNlbGYsayk6XFxuICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvLmFwcGVuZChrKVxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSBzZWxmLnRhbWFub0FjdHVhbCArIDFcXG4gICAgICAgIHNlbGYuaW5maWx0QXJyaWJhKHNlbGYudGFtYW5vQWN0dWFsKVxcblxcbiAgICBkZWYgZWxpbWluYXJNaW4oc2VsZik6XFxuICAgICAgICB2YWxvclNhY2FkbyA9IHNlbGYubGlzdGFNb250aWN1bG9bMV1cXG4gICAgICAgIHNlbGYubGlzdGFNb250aWN1bG9bMV0gPSBzZWxmLmxpc3RhTW9udGljdWxvW3NlbGYudGFtYW5vQWN0dWFsXVxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSBzZWxmLnRhbWFub0FjdHVhbCAtIDFcXG4gICAgICAgIHNlbGYubGlzdGFNb250aWN1bG8ucG9wKClcXG4gICAgICAgIHNlbGYuaW5maWx0QWJham8oMSlcXG4gICAgICAgIHJldHVybiB2YWxvclNhY2Fkb1xcbiAgICAgICAgXFxuICAgIGRlZiBlc3RhVmFjaW8oc2VsZik6XFxuICAgICAgICBpZiB0YW1hbm9BY3R1YWwgPT0gMDpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYmFzaWNhcy9fX2luaXRfXy5weVwiOlwiXFxuI19fYWxsX18gPSBbXFxcInBpbGFcXFwiXVxcblxcblxcbmZyb20gLnBpbGEgaW1wb3J0IFBpbGFcXG5mcm9tIC5jb2xhIGltcG9ydCBDb2xhXFxuZnJvbSAuY29sYWRvYmxlIGltcG9ydCBDb2xhRG9ibGVcXG5cXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYmFzaWNhcy9jb2xhLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuI1xcbiNjb2xhLnB5XFxuXFxuY2xhc3MgQ29sYTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgYWdyZWdhcihzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuaW5zZXJ0KDAsaXRlbSlcXG5cXG4gICAgZGVmIGF2YW56YXIoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgdGFtYW5vKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25lZC9iYXNpY2FzL2NvbGFkb2JsZS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiMgXFxuI2NvbGFkb2JsZS5weVxcblxcbmNsYXNzIENvbGFEb2JsZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgYWdyZWdhckZyZW50ZShzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuYXBwZW5kKGl0ZW0pXFxuXFxuICAgIGRlZiBhZ3JlZ2FyRmluYWwoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmluc2VydCgwLGl0ZW0pXFxuXFxuICAgIGRlZiByZW1vdmVyRnJlbnRlKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHJlbW92ZXJGaW5hbChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgwKVxcblxcbiAgICBkZWYgdGFtYW5vKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25lZC9iYXNpY2FzL3BpbGEucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jIFxcbiNwaWxhLnB5XFxuXFxuY2xhc3MgUGlsYTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgaW5jbHVpcihzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuYXBwZW5kKGl0ZW0pXFxuXFxuICAgIGRlZiBleHRyYWVyKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKClcXG5cXG4gICAgZGVmIGluc3BlY2Npb25hcihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zW2xlbihzZWxmLml0ZW1zKS0xXVxcblxcbiAgICBkZWYgdGFtYW5vKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25lZC9ncmFmb3MvX19pbml0X18ucHlcIjpcIlxcblxcbmZyb20gLmdyYWZvQWR5IGltcG9ydCBHcmFmb1xcbmZyb20gLmdyYWZvQWR5IGltcG9ydCBWZXJ0aWNlXFxuZnJvbSAuY29sYVByaW9yaWRhZCBpbXBvcnQgQ29sYVByaW9yaWRhZFxcblwiLFwic3JjL2xpYi9weXRob25lZC9ncmFmb3MvY29sYVByaW9yaWRhZC5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiMgXFxuI2NvbGFQcmlvcmlkYWQucHlcXG5cXG5jbGFzcyBDb2xhUHJpb3JpZGFkOlxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG8gPSBbKDAsMCldXFxuICAgICAgICBzZWxmLnRhbWFub0FjdHVhbCA9IDBcXG5cXG4gICAgZGVmIGNvbnN0cnVpck1vbnRpY3VsbyhzZWxmLHVuYUxpc3RhKTpcXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gbGVuKHVuYUxpc3RhKVxcbiAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvID0gWygwLDApXVxcbiAgICAgICAgZm9yIGkgaW4gdW5hTGlzdGE6XFxuICAgICAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvLmFwcGVuZChpKVxcbiAgICAgICAgaSA9IGxlbih1bmFMaXN0YSkgLy8gMiAgICAgICAgICAgIFxcbiAgICAgICAgd2hpbGUgKGkgPiAwKTpcXG4gICAgICAgICAgICBzZWxmLmluZmlsdEFiYWpvKGkpXFxuICAgICAgICAgICAgaSA9IGkgLSAxXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgIGRlZiBpbmZpbHRBYmFqbyhzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgKGkgKiAyKSA8PSBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICBobSA9IHNlbGYuaGlqb01pbihpKVxcbiAgICAgICAgICAgIGlmIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVswXSA+IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tobV1bMF06XFxuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVxcbiAgICAgICAgICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9baV0gPSBzZWxmLmFycmVnbG9Nb250aWN1bG9baG1dXFxuICAgICAgICAgICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tobV0gPSB0bXBcXG4gICAgICAgICAgICBpID0gaG1cXG4gICAgICAgICAgICAgICAgXFxuICAgIGRlZiBoaWpvTWluKHNlbGYsaSk6XFxuICAgICAgICBpZiBpKjIgPiBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICByZXR1cm4gLTFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgaSoyICsgMSA+IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gaSoyXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2kqMl1bMF0gPCBzZWxmLmFycmVnbG9Nb250aWN1bG9baSoyKzFdWzBdOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkqMlxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkqMisxXFxuXFxuICAgIGRlZiBpbmZpbHRBcnJpYmEoc2VsZixpKTpcXG4gICAgICAgIHdoaWxlIGkgLy8gMiA+IDA6XFxuICAgICAgICAgICAgaWYgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2ldWzBdIDwgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2kvLzJdWzBdOlxcbiAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpLy8yXVxcbiAgICAgICAgICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpLy8yXSA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVxcbiAgICAgICAgICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBpLy8yXFxuIFxcbiAgICBkZWYgaW5zZXJ0YXIoc2VsZixrKTpcXG4gICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsby5hcHBlbmQoaylcXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gc2VsZi50YW1hbm9BY3R1YWwgKyAxXFxuICAgICAgICBzZWxmLmluZmlsdEFycmliYShzZWxmLnRhbWFub0FjdHVhbClcXG5cXG4gICAgZGVmIGVsaW1pbmFyTWluKHNlbGYpOlxcbiAgICAgICAgdmFsb3JTYWNhZG8gPSBzZWxmLmFycmVnbG9Nb250aWN1bG9bMV1bMV1cXG4gICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1sxXSA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tzZWxmLnRhbWFub0FjdHVhbF1cXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gc2VsZi50YW1hbm9BY3R1YWwgLSAxXFxuICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG8ucG9wKClcXG4gICAgICAgIHNlbGYuaW5maWx0QWJham8oMSlcXG4gICAgICAgIHJldHVybiB2YWxvclNhY2Fkb1xcbiAgICAgICAgXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLnRhbWFub0FjdHVhbCA9PSAwOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcblxcbiAgICBkZWYgZGVjcmVtZW50YXJDbGF2ZShzZWxmLHZhbG9yLG51ZXZvKTpcXG4gICAgICAgIGhlY2hvID0gRmFsc2VcXG4gICAgICAgIGkgPSAxXFxuICAgICAgICBtaUNsYXZlID0gMFxcbiAgICAgICAgd2hpbGUgbm90IGhlY2hvIGFuZCBpIDw9IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgIGlmIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVsxXSA9PSB2YWxvcjpcXG4gICAgICAgICAgICAgICAgaGVjaG8gPSBUcnVlXFxuICAgICAgICAgICAgICAgIG1pQ2xhdmUgPSBpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaSA9IGkgKyAxXFxuICAgICAgICBpZiBtaUNsYXZlID4gMDpcXG4gICAgICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9bbWlDbGF2ZV0gPSAobnVldm8sc2VsZi5hcnJlZ2xvTW9udGljdWxvW21pQ2xhdmVdWzFdKVxcbiAgICAgICAgICAgIHNlbGYuaW5maWx0QXJyaWJhKG1pQ2xhdmUpXFxuICAgICAgICAgICAgXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZix2ZXJ0aWNlKTpcXG4gICAgICAgIGZvciBwYXJlamEgaW4gc2VsZi5hcnJlZ2xvTW9udGljdWxvOlxcbiAgICAgICAgICAgIGlmIHBhcmVqYVsxXSA9PSB2ZXJ0aWNlOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgcmV0dXJuIEZhbHNlICAgICBcXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZWQvZ3JhZm9zL2dyYWZvQWR5LnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuI1xcbiNncmFmb0FkeS5weVxcblxcblxcbmltcG9ydCBzeXNcXG5cXG5jbGFzcyBHcmFmbzpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5saXN0YVZlcnRpY2VzID0ge31cXG4gICAgICAgIHNlbGYubnVtVmVydGljZXMgPSAwXFxuICAgICAgICBcXG4gICAgZGVmIGFncmVnYXJWZXJ0aWNlKHNlbGYsY2xhdmUpOlxcbiAgICAgICAgc2VsZi5udW1WZXJ0aWNlcyA9IHNlbGYubnVtVmVydGljZXMgKyAxXFxuICAgICAgICBudWV2b1ZlcnRpY2UgPSBWZXJ0aWNlKGNsYXZlKVxcbiAgICAgICAgc2VsZi5saXN0YVZlcnRpY2VzW2NsYXZlXSA9IG51ZXZvVmVydGljZVxcbiAgICAgICAgcmV0dXJuIG51ZXZvVmVydGljZVxcbiAgICBcXG4gICAgZGVmIG9idGVuZXJWZXJ0aWNlKHNlbGYsbik6XFxuICAgICAgICBpZiBuIGluIHNlbGYubGlzdGFWZXJ0aWNlczpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5saXN0YVZlcnRpY2VzW25dXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixuKTpcXG4gICAgICAgIHJldHVybiBuIGluIHNlbGYubGlzdGFWZXJ0aWNlc1xcbiAgICBcXG4gICAgZGVmIGFncmVnYXJBcmlzdGEoc2VsZixkZSxhLGNvc3RvPTApOlxcbiAgICAgICAgICAgIGlmIGRlIG5vdCBpbiBzZWxmLmxpc3RhVmVydGljZXM6XFxuICAgICAgICAgICAgICAgIG52ID0gc2VsZi5hZ3JlZ2FyVmVydGljZShkZSlcXG4gICAgICAgICAgICBpZiBhIG5vdCBpbiBzZWxmLmxpc3RhVmVydGljZXM6XFxuICAgICAgICAgICAgICAgIG52ID0gc2VsZi5hZ3JlZ2FyVmVydGljZShhKVxcbiAgICAgICAgICAgIHNlbGYubGlzdGFWZXJ0aWNlc1tkZV0uYWdyZWdhclZlY2lubyhzZWxmLmxpc3RhVmVydGljZXNbYV0sY29zdG8pXFxuICAgIFxcbiAgICBkZWYgb2J0ZW5lclZlcnRpY2VzKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxpc3Qoc2VsZi5saXN0YVZlcnRpY2VzLmtleXMoKSlcXG4gICAgICAgIFxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gaXRlcihzZWxmLmxpc3RhVmVydGljZXMudmFsdWVzKCkpXFxuICAgICAgICAgICAgICAgIFxcbmNsYXNzIFZlcnRpY2U6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLGNsYXZlKTpcXG4gICAgICAgIHNlbGYuaWQgPSBjbGF2ZVxcbiAgICAgICAgc2VsZi5jb25lY3RhZG9BID0ge31cXG4gICAgICAgIHNlbGYuY29sb3IgPSAnYmxhbmNvJ1xcbiAgICAgICAgc2VsZi5kaXN0ID0gc3lzLm1heHNpemVcXG4gICAgICAgIHNlbGYucHJlZGVjZXNvciA9IE5vbmVcXG4gICAgICAgIHNlbGYuZGVzYyA9IDBcXG4gICAgICAgIHNlbGYuZmluID0gMFxcblxcbiAgICAjIGRlZiBfX2x0X18oc2VsZixvKTpcXG4gICAgIyAgICAgcmV0dXJuIHNlbGYuaWQgPCBvLmlkXFxuICAgIFxcbiAgICBkZWYgIGFncmVnYXJWZWNpbm8oc2VsZix2ZWNpbm8scG9uZGVyYWNpb249MCk6XFxuICAgICAgICBzZWxmLmNvbmVjdGFkb0FbdmVjaW5vXSA9IHBvbmRlcmFjaW9uXFxuICAgICAgICBcXG4gICAgZGVmIGFzaWduYXJDb2xvcihzZWxmLGNvbG9yKTpcXG4gICAgICAgIHNlbGYuY29sb3IgPSBjb2xvclxcbiAgICAgICAgXFxuICAgIGRlZiBhc2lnbmFyRGlzdGFuY2lhKHNlbGYsZCk6XFxuICAgICAgICBzZWxmLmRpc3QgPSBkXFxuXFxuICAgIGRlZiBhc2lnbmFyUHJlZGVjZXNvcihzZWxmLHApOlxcbiAgICAgICAgc2VsZi5wcmVkZWNlc29yID0gcFxcblxcbiAgICBkZWYgYXNpZ25hckRlc2N1YnJpbWllbnRvKHNlbGYsdGllbXBvRGVzY3VicmltaWVudG8pOlxcbiAgICAgICAgc2VsZi5kZXNjID0gdGllbXBvRGVzY3VicmltaWVudG9cXG4gICAgICAgIFxcbiAgICBkZWYgYXNpZ25hckZpbmFsaXphY2lvbihzZWxmLHRpZW1wb0ZpbmFsaXphY2lvbik6XFxuICAgICAgICBzZWxmLmZpbiA9IHRpZW1wb0ZpbmFsaXphY2lvblxcbiAgICAgICAgXFxuICAgIGRlZiBvYnRlbmVyRmluYWxpemFjaW9uKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZmluXFxuICAgICAgICBcXG4gICAgZGVmIG9idGVuZXJEZXNjdWJyaW1pZW50byhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmRlc2NcXG4gICAgICAgIFxcbiAgICBkZWYgb2J0ZW5lclByZWRlY2Vzb3Ioc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5wcmVkZWNlc29yXFxuICAgICAgICBcXG4gICAgZGVmIG9idGVuZXJEaXN0YW5jaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5kaXN0XFxuICAgICAgICBcXG4gICAgZGVmIG9idGVuZXJDb2xvcihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmNvbG9yXFxuICAgIFxcbiAgICBkZWYgb2J0ZW5lckNvbmV4aW9uZXMoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jb25lY3RhZG9BLmtleXMoKVxcbiAgICAgICAgXFxuICAgIGRlZiBvYnRlbmVyUG9uZGVyYWNpb24oc2VsZix2ZWNpbm8pOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuY29uZWN0YWRvQVt2ZWNpbm9dXFxuICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzdHIoc2VsZi5pZCkgKyBcXFwiOmNvbG9yIFxcXCIgKyBzZWxmLmNvbG9yICsgXFxcIjpkZXNjIFxcXCIgKyBzdHIoc2VsZi5kZXNjKSArIFxcXCI6ZmluIFxcXCIgKyBzdHIoc2VsZi5maW4pICsgXFxcIjpkaXN0YW5jaWEgXFxcIiArIHN0cihzZWxmLmRpc3QpICsgXFxcIjpwcmVkZWNlc29yIFxcXFxuXFxcXHRbXFxcIiArIHN0cihzZWxmLnByZWRlY2Vzb3IpKyBcXFwiXVxcXFxuXFxcIlxcbiAgICBcXG4gICAgZGVmIG9idGVuZXJJZChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmlkXFxuXCIsXCJzcmMvbGliL3F1b3ByaS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJxdW9wcmlcXFwiKVxcblwiLFwic3JjL2xpYi9yZXByLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInJlcHJcXFwiKVxcblwiLFwic3JjL2xpYi9yZXF1ZXN0cy5weVwiOlwiIyBtb3N0IHJlc3RyaWN0ZWQgdmVyc2lvblxcblxcXCJcXFwiXFxcIlxcblRoaXMgc29sdXRpb24gd29ya3MgaW4gcnVuZXN0b25lIC0gaG93ZXZlciBpdCBpcyBtdWNoIG1vcmUgbGltaXRlZC5cXG5BbiBlcnJvciBkb2VzIG5vdCBvY2N1ciBpbiB0aGUgc2FtZSB3YXkgaW4gdGhlIHRleHRib29rIGFzIGl0IGRvZXNcXG5mb3IgdGhlIGNvbW1hbmQgbGluZS4gU2luY2UgSFRUUEVycm9yIGlzIG5vdCBjdXJyZW50bHkgYXZhaWxhYmxlIGluXFxuUnVuZXN0b25lLCBJIGhhZCB0byBjaGFuZ2UgdGhlIGV4Y2VwdGlvbi5cXG5EZWNvZGUgYW5kIEVuY29kZSBhcmUgbm90IGF2YWlsYWJsZSBpbiBSdW5lc3RvbmUsIHNvIHRoZXJlIG1pZ2h0IGJlXFxuaXNzdWVzIHdpdGggcmVwb25zZXMuXFxuRG9lcyBub3QgdXNlIHRoZSBzdGF0dXMgYXR0cmlidXRlIGZvciB1cmxvcGVuLCB3b3VsZCBiZSBuaWNlIHRvIGhhdmVcXG50aGF0IGJhY2suXFxuRG9lcyBub3Qgd29yayBvbiByZWd1bGFyIHdlYiBwYWdlcyAobGlrZSBnb29nbGUgb3IgdGhlIG1pY2hpZ2FuIGRhaWx5KSBiZWNhdXNlIG9mIGNyb3NzLXNpdGUgc2NyaXB0aW5nIGxpbWl0cy5cXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHVybGxpYi5yZXF1ZXN0IGltcG9ydCB1cmxvcGVuXFxuaW1wb3J0IGpzb25cXG5cXG5jbGFzcyBSZXNwb25zZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGRhdGEsIHVybCk6XFxuICAgICAgICBzZWxmLnRleHQgPSBkYXRhXFxuICAgICAgICBzZWxmLnVybCA9IHVybFxcblxcbiAgICBkZWYganNvbihzZWxmKTpcXG4gICAgICAgIHRyeTpcXG4gICAgICAgICAgICByZXR1cm4ganNvbi5sb2FkcyhzZWxmLnRleHQpXFxuICAgICAgICBleGNlcHQ6XFxuICAgICAgICAgICAgcmV0dXJuIHtcXFwiZXJyb3JcXFwiOiBcXFwiUmVzcG9uc2Ugbm90IGludGVycHJldGFibGUgYXMganNvbi4gVHJ5IHByaW50aW5nIHRoZSAudGV4dCBhdHRyaWJ1dGVcXFwifVxcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBcXFwiPEEgUmVzcG9uc2Ugb2JqZWN0IGZvciB0aGUgZm9sbG93aW5nIHJlcXVlc3Q6IHt9PlxcXCIuZm9ybWF0KHNlbGYudXJsKVxcblxcblxcbnVybF9zdWJzID0ge1xcXCIgXFxcIjogXFxcIitcXFwiLFxcbiAgICAgICAgICAgIFxcXCIhXFxcIjogXFxcIiUyMVxcXCIsXFxuICAgICAgICAgICAgJ1xcXCInOiBcXFwiJTIyXFxcIixcXG4gICAgICAgICAgICBcXFwiI1xcXCI6IFxcXCIlMjNcXFwiLFxcbiAgICAgICAgICAgIFxcXCIkXFxcIjogXFxcIiUyNFxcXCIsXFxuICAgICAgICAgICAgXFxcIidcXFwiOiBcXFwiJTI3XFxcIixcXG4gICAgICAgICAgICBcXFwiKFxcXCI6IFxcXCIlMjhcXFwiLFxcbiAgICAgICAgICAgIFxcXCIpXFxcIjogXFxcIiUyOVxcXCIsXFxuICAgICAgICAgICAgXFxcIipcXFwiOiBcXFwiJTJBXFxcIixcXG4gICAgICAgICAgICBcXFwiK1xcXCI6IFxcXCIlMkJcXFwiLFxcbiAgICAgICAgICAgIFxcXCIsXFxcIjogXFxcIiUyQ1xcXCIsXFxuICAgICAgICAgICAgXFxcIi9cXFwiOiBcXFwiJTJGXFxcIixcXG4gICAgICAgICAgICBcXFwiOlxcXCI6IFxcXCIlM0FcXFwiLFxcbiAgICAgICAgICAgIFxcXCI7XFxcIjogXFxcIiUzQlxcXCIsXFxuICAgICAgICAgICAgXFxcIj1cXFwiOiBcXFwiJTNEXFxcIixcXG4gICAgICAgICAgICBcXFwiP1xcXCI6IFxcXCIlM0ZcXFwiLFxcbiAgICAgICAgICAgIFxcXCJAXFxcIjogXFxcIiU0MFxcXCIsXFxuICAgICAgICAgICAgXFxcIltcXFwiOiBcXFwiJTVCXFxcIixcXG4gICAgICAgICAgICBcXFwiXVxcXCI6IFxcXCIlNURcXFwiLFxcbiAgICAgICAgICAgIH1cXG5cXG5kZWYgX3N1YnN0KHMsIHN1YnN0aXR1dGlvbnM9dXJsX3N1YnMpOlxcbiAgICByZXMgPSBcXFwiXFxcIlxcbiAgICBmb3IgYyBpbiBzdHIocyk6XFxuICAgICAgICBpZiBjIGluIHN1YnN0aXR1dGlvbnM6XFxuICAgICAgICAgICAgcmVzICs9IHN1YnN0aXR1dGlvbnNbY11cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmVzICs9IGNcXG4gICAgcmV0dXJuIHJlc1xcblxcblxcbmRlZiByZXF1ZXN0VVJMKGJhc2V1cmwsIHBhcmFtcz17fSk6XFxuICAgIHRyeTpcXG4gICAgICAgIGlmIGxlbihwYXJhbXMpID09IDA6XFxuICAgICAgICAgICAgcmV0dXJuIGJhc2V1cmxcXG4gICAgICAgIGNvbXBsZXRlX3VybCA9IGJhc2V1cmwgKyBcXFwiP1xcXCJcXG4gICAgICAgIHBhaXJzID0gW1xcXCJ7fT17fVxcXCIuZm9ybWF0KF9zdWJzdChrKSwgX3N1YnN0KHBhcmFtc1trXSkpIGZvciBrIGluIHBhcmFtc11cXG4gICAgICAgIGNvbXBsZXRlX3VybCArPSBcXFwiJlxcXCIuam9pbihwYWlycylcXG4gICAgICAgIHJldHVybiBjb21wbGV0ZV91cmxcXG4gICAgZXhjZXB0OlxcbiAgICAgICAgcmV0dXJuIE5vbmVcXG5cXG5kZWYgZ2V0KGJhc2V1cmwsIHBhcmFtcz17fSk6XFxuICAgIGZ1bGxfdXJsID0gcmVxdWVzdFVSTChiYXNldXJsLCBwYXJhbXMpXFxuICAgIGlmIG5vdCBmdWxsX3VybDpcXG4gICAgICAgIHRleHRfZGF0YSA9IFxcXCI8aHRtbD48Ym9keT48aDE+aW52YWxpZCByZXF1ZXN0PC9oMT48L2JvZHk+PC9odG1sPlxcXCJcXG4gICAgICAgIGZ1bGxfdXJsID0gXFxcIkNvdWxkbuKAmXQgZ2VuZXJhdGUgYSB2YWxpZCBVUkxcXFwiXFxuICAgIGVsc2U6XFxuICAgICAgICBkYXRhID0gdXJsb3BlbihmdWxsX3VybClcXG4gICAgICAgIHRleHRfZGF0YSA9IGRhdGEucmVhZCgpLnN0cmlwKClcXG4gICAgICAgIGlmIGxlbih0ZXh0X2RhdGEpID09IDA6XFxuICAgICAgICAgICAgdGV4dF9kYXRhID0gXFxcIkZhaWxlZCB0byByZXRyaWV2ZSB0aGF0IFVSTFxcXCJcXG4gICAgcmV0dXJuIFJlc3BvbnNlKHRleHRfZGF0YSwgZnVsbF91cmwpXCIsXCJzcmMvbGliL3JlcXVlc3RzX3dpdGhfY2FjaGluZy5weVwiOlwiaW1wb3J0IHJlcXVlc3RzXFxuaW1wb3J0IGpzb25cXG5cXG5QRVJNQU5FTlRfQ0FDSEVfRk5BTUUgPSBcXFwicGVybWFuZW50X2NhY2hlLnR4dFxcXCJcXG5URU1QX0NBQ0hFX0ZOQU1FID0gXFxcInRoaXNfcGFnZV9jYWNoZS50eHRcXFwiXFxuXFxuZGVmIF93cml0ZV90b19maWxlKGNhY2hlLCBmbmFtZSk6XFxuICAgIHdpdGggb3BlbihmbmFtZSwgJ3cnKSBhcyBvdXRmaWxlOlxcbiAgICAgICAgb3V0ZmlsZS53cml0ZShqc29uLmR1bXBzKGNhY2hlLCBpbmRlbnQ9MikpXFxuXFxuZGVmIF9yZWFkX2Zyb21fZmlsZShmbmFtZSk6XFxuICAgIHRyeTpcXG4gICAgICAgIHdpdGggb3BlbihmbmFtZSwgJ3InKSBhcyBpbmZpbGU6XFxuICAgICAgICAgICAgcmVzID0gaW5maWxlLnJlYWQoKVxcbiAgICAgICAgICAgIHJldHVybiBqc29uLmxvYWRzKHJlcylcXG4gICAgZXhjZXB0OlxcbiAgICAgICAgcmV0dXJuIHt9XFxuXFxuZGVmIGFkZF90b19jYWNoZShjYWNoZV9maWxlLCBjYWNoZV9rZXksIGNhY2hlX3ZhbHVlKTpcXG4gICAgdGVtcF9jYWNoZSA9IF9yZWFkX2Zyb21fZmlsZShjYWNoZV9maWxlKVxcbiAgICB0ZW1wX2NhY2hlW2NhY2hlX2tleV0gPSBjYWNoZV92YWx1ZVxcbiAgICBfd3JpdGVfdG9fZmlsZSh0ZW1wX2NhY2hlLCBjYWNoZV9maWxlKVxcblxcbmRlZiBjbGVhcl9jYWNoZShjYWNoZV9maWxlPVRFTVBfQ0FDSEVfRk5BTUUpOlxcbiAgICBfd3JpdGVfdG9fZmlsZSh7fSwgY2FjaGVfZmlsZSlcXG5cXG5kZWYgbWFrZV9jYWNoZV9rZXkoYmFzZXVybCwgcGFyYW1zX2QsIHByaXZhdGVfa2V5cz1bXFxcImFwaV9rZXlcXFwiLCBcXFwiYXBpa2V5XFxcIl0pOlxcbiAgICBcXFwiXFxcIlxcXCJNYWtlcyBhIGxvbmcgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcXVlcnkuXFxuICAgIEFscGhhYmV0aXplIHRoZSBrZXlzIGZyb20gdGhlIHBhcmFtcyBkaWN0aW9uYXJ5IHNvIHdlIGdldCB0aGUgc2FtZSBvcmRlciBlYWNoIHRpbWUuXFxuICAgIE9taXQga2V5cyB3aXRoIHByaXZhdGUgaW5mby5cXFwiXFxcIlxcXCJcXG4gICAgYWxwaGFiZXRpemVkX2tleXMgPSBzb3J0ZWQocGFyYW1zX2Qua2V5cygpKVxcbiAgICByZXMgPSBbXVxcbiAgICBmb3IgayBpbiBhbHBoYWJldGl6ZWRfa2V5czpcXG4gICAgICAgIGlmIGsgbm90IGluIHByaXZhdGVfa2V5czpcXG4gICAgICAgICAgICByZXMuYXBwZW5kKFxcXCJ7fS17fVxcXCIuZm9ybWF0KGssIHBhcmFtc19kW2tdKSlcXG4gICAgcmV0dXJuIGJhc2V1cmwgKyBcXFwiX1xcXCIuam9pbihyZXMpXFxuXFxuZGVmIGdldChiYXNldXJsLCBwYXJhbXM9e30sIHByaXZhdGVfa2V5c190b19pZ25vcmU9W1xcXCJhcGlfa2V5XFxcIiwgXFxcImFwaWtleVxcXCJdLCBwZXJtYW5lbnRfY2FjaGVfZmlsZT1QRVJNQU5FTlRfQ0FDSEVfRk5BTUUsIHRlbXBfY2FjaGVfZmlsZT1URU1QX0NBQ0hFX0ZOQU1FKTpcXG4gICAgZnVsbF91cmwgPSByZXF1ZXN0cy5yZXF1ZXN0VVJMKGJhc2V1cmwsIHBhcmFtcylcXG4gICAgY2FjaGVfa2V5ID0gbWFrZV9jYWNoZV9rZXkoYmFzZXVybCwgcGFyYW1zLCBwcml2YXRlX2tleXNfdG9faWdub3JlKVxcbiAgICAjIExvYWQgdGhlIHBlcm1hbmVudCBhbmQgcGFnZS1zcGVjaWZpYyBjYWNoZXMgZnJvbSBmaWxlc1xcbiAgICBwZXJtYW5lbnRfY2FjaGUgPSBfcmVhZF9mcm9tX2ZpbGUocGVybWFuZW50X2NhY2hlX2ZpbGUpXFxuICAgIHRlbXBfY2FjaGUgPSBfcmVhZF9mcm9tX2ZpbGUodGVtcF9jYWNoZV9maWxlKVxcbiAgICBpZiBjYWNoZV9rZXkgaW4gdGVtcF9jYWNoZTpcXG4gICAgICAgIHByaW50KFxcXCJmb3VuZCBpbiBwYWdlLXNwZWNpZmljIGNhY2hlXFxcIilcXG4gICAgICAgICMgbWFrZSBhIFJlc3BvbnNlIG9iamVjdCBjb250YWluaW5nIHRleHQgZnJvbSB0aGUgY2hhbmdlLCBhbmQgdGhlIGZ1bGxfdXJsIHRoYXQgd291bGQgaGF2ZSBiZWVuIGZldGNoZWRcXG4gICAgICAgIHJldHVybiByZXF1ZXN0cy5SZXNwb25zZSh0ZW1wX2NhY2hlW2NhY2hlX2tleV0sIGZ1bGxfdXJsKVxcbiAgICBlbGlmIGNhY2hlX2tleSBpbiBwZXJtYW5lbnRfY2FjaGU6XFxuICAgICAgICBwcmludChcXFwiZm91bmQgaW4gcGVybWFuZW50X2NhY2hlXFxcIilcXG4gICAgICAgICMgbWFrZSBhIFJlc3BvbnNlIG9iamVjdCBjb250YWluaW5nIHRleHQgZnJvbSB0aGUgY2hhbmdlLCBhbmQgdGhlIGZ1bGxfdXJsIHRoYXQgd291bGQgaGF2ZSBiZWVuIGZldGNoZWRcXG4gICAgICAgIHJldHVybiByZXF1ZXN0cy5SZXNwb25zZShwZXJtYW5lbnRfY2FjaGVbY2FjaGVfa2V5XSwgZnVsbF91cmwpXFxuICAgIGVsc2U6XFxuICAgICAgICBwcmludChcXFwibmV3OyBhZGRpbmcgdG8gY2FjaGVcXFwiKVxcbiAgICAgICAgIyBhY3R1YWxseSByZXF1ZXN0IGl0XFxuICAgICAgICByZXNwID0gcmVxdWVzdHMuZ2V0KGJhc2V1cmwsIHBhcmFtcylcXG4gICAgICAgICMgc2F2ZSBpdFxcbiAgICAgICAgYWRkX3RvX2NhY2hlKHRlbXBfY2FjaGVfZmlsZSwgY2FjaGVfa2V5LCByZXNwLnRleHQpXFxuICAgICAgICByZXR1cm4gcmVzcFwiLFwic3JjL2xpYi9yZXhlYy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJyZXhlY1xcXCIpXFxuXCIsXCJzcmMvbGliL3JmYzgyMi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJyZmM4MjJcXFwiKVxcblwiLFwic3JjL2xpYi9ybGNvbXBsZXRlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJybGNvbXBsZXRlclxcXCIpXFxuXCIsXCJzcmMvbGliL3JvYm90cGFyc2VyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInJvYm90cGFyc2VyXFxcIilcXG5cIixcInNyYy9saWIvcnVucHkucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicnVucHlcXFwiKVxcblwiLFwic3JjL2xpYi9zY2hlZC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzY2hlZFxcXCIpXFxuXCIsXCJzcmMvbGliL3NldHMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2V0c1xcXCIpXFxuXCIsXCJzcmMvbGliL3NnbWxsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2dtbGxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL3NoYS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzaGFcXFwiKVxcblwiLFwic3JjL2xpYi9zaGVsdmUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2hlbHZlXFxcIilcXG5cIixcInNyYy9saWIvc2hsZXgucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2hsZXhcXFwiKVxcblwiLFwic3JjL2xpYi9zaHV0aWwucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2h1dGlsXFxcIilcXG5cIixcInNyYy9saWIvc2l0ZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzaXRlXFxcIilcXG5cIixcInNyYy9saWIvc210cGQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic210cGRcXFwiKVxcblwiLFwic3JjL2xpYi9zbXRwbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNtdHBsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9zbmRoZHIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic25kaGRyXFxcIilcXG5cIixcInNyYy9saWIvc29ja2V0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNvY2tldFxcXCIpXFxuXCIsXCJzcmMvbGliL3NxbGl0ZTMvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3FsaXRlM1xcXCIpXFxuXCIsXCJzcmMvbGliL3NyZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzcmVcXFwiKVxcblwiLFwic3JjL2xpYi9zcmVfY29tcGlsZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzcmVfY29tcGlsZVxcXCIpXFxuXCIsXCJzcmMvbGliL3NyZV9jb25zdGFudHMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3JlX2NvbnN0YW50c1xcXCIpXFxuXCIsXCJzcmMvbGliL3NyZV9wYXJzZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzcmVfcGFyc2VcXFwiKVxcblwiLFwic3JjL2xpYi9zc2wucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3NsXFxcIilcXG5cIixcInNyYy9saWIvc3RhdC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzdGF0XFxcIilcXG5cIixcInNyYy9saWIvc3RhdGlzdGljcy5weVwiOlwiXFxcIlxcXCJcXFwiXFxuQmFzaWMgc3RhdGlzdGljcyBtb2R1bGUuXFxuXFxuVGhpcyBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIGZvciBjYWxjdWxhdGluZyBzdGF0aXN0aWNzIG9mIGRhdGEsIGluY2x1ZGluZ1xcbmF2ZXJhZ2VzLCB2YXJpYW5jZSwgYW5kIHN0YW5kYXJkIGRldmlhdGlvbi5cXG5cXG5DYWxjdWxhdGluZyBhdmVyYWdlc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuPT09PT09PT09PT09PT09PT09ICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5GdW5jdGlvbiAgICAgICAgICAgIERlc2NyaXB0aW9uXFxuPT09PT09PT09PT09PT09PT09ICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5tZWFuICAgICAgICAgICAgICAgIEFyaXRobWV0aWMgbWVhbiAoYXZlcmFnZSkgb2YgZGF0YS5cXG5oYXJtb25pY19tZWFuICAgICAgIEhhcm1vbmljIG1lYW4gb2YgZGF0YS5cXG5tZWRpYW4gICAgICAgICAgICAgIE1lZGlhbiAobWlkZGxlIHZhbHVlKSBvZiBkYXRhLlxcbm1lZGlhbl9sb3cgICAgICAgICAgTG93IG1lZGlhbiBvZiBkYXRhLlxcbm1lZGlhbl9oaWdoICAgICAgICAgSGlnaCBtZWRpYW4gb2YgZGF0YS5cXG5tZWRpYW5fZ3JvdXBlZCAgICAgIE1lZGlhbiwgb3IgNTB0aCBwZXJjZW50aWxlLCBvZiBncm91cGVkIGRhdGEuXFxubW9kZSAgICAgICAgICAgICAgICBNb2RlIChtb3N0IGNvbW1vbiB2YWx1ZSkgb2YgZGF0YS5cXG49PT09PT09PT09PT09PT09PT0gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbkNhbGN1bGF0ZSB0aGUgYXJpdGhtZXRpYyBtZWFuIChcXFwidGhlIGF2ZXJhZ2VcXFwiKSBvZiBkYXRhOlxcblxcbj4+PiBtZWFuKFstMS4wLCAyLjUsIDMuMjUsIDUuNzVdKVxcbjIuNjI1XFxuXFxuXFxuQ2FsY3VsYXRlIHRoZSBzdGFuZGFyZCBtZWRpYW4gb2YgZGlzY3JldGUgZGF0YTpcXG5cXG4+Pj4gbWVkaWFuKFsyLCAzLCA0LCA1XSlcXG4zLjVcXG5cXG5cXG5DYWxjdWxhdGUgdGhlIG1lZGlhbiwgb3IgNTB0aCBwZXJjZW50aWxlLCBvZiBkYXRhIGdyb3VwZWQgaW50byBjbGFzcyBpbnRlcnZhbHNcXG5jZW50cmVkIG9uIHRoZSBkYXRhIHZhbHVlcyBwcm92aWRlZC4gRS5nLiBpZiB5b3VyIGRhdGEgcG9pbnRzIGFyZSByb3VuZGVkIHRvXFxudGhlIG5lYXJlc3Qgd2hvbGUgbnVtYmVyOlxcblxcbj4+PiBtZWRpYW5fZ3JvdXBlZChbMiwgMiwgMywgMywgMywgNF0pICAjZG9jdGVzdDogK0VMTElQU0lTXFxuMi44MzMzMzMzMzMzLi4uXFxuXFxuVGhpcyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgaW4gdGhpcyB3YXk6IHlvdSBoYXZlIHR3byBkYXRhIHBvaW50cyBpbiB0aGUgY2xhc3NcXG5pbnRlcnZhbCAxLjUtMi41LCB0aHJlZSBkYXRhIHBvaW50cyBpbiB0aGUgY2xhc3MgaW50ZXJ2YWwgMi41LTMuNSwgYW5kIG9uZSBpblxcbnRoZSBjbGFzcyBpbnRlcnZhbCAzLjUtNC41LiBUaGUgbWVkaWFuIG9mIHRoZXNlIGRhdGEgcG9pbnRzIGlzIDIuODMzMy4uLlxcblxcblxcbkNhbGN1bGF0aW5nIHZhcmlhYmlsaXR5IG9yIHNwcmVhZFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbj09PT09PT09PT09PT09PT09PSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuRnVuY3Rpb24gICAgICAgICAgICBEZXNjcmlwdGlvblxcbj09PT09PT09PT09PT09PT09PSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxucHZhcmlhbmNlICAgICAgICAgICBQb3B1bGF0aW9uIHZhcmlhbmNlIG9mIGRhdGEuXFxudmFyaWFuY2UgICAgICAgICAgICBTYW1wbGUgdmFyaWFuY2Ugb2YgZGF0YS5cXG5wc3RkZXYgICAgICAgICAgICAgIFBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGRhdGEuXFxuc3RkZXYgICAgICAgICAgICAgICBTYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGRhdGEuXFxuPT09PT09PT09PT09PT09PT09ICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5cXG5DYWxjdWxhdGUgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBzYW1wbGUgZGF0YTpcXG5cXG4+Pj4gc3RkZXYoWzIuNSwgMy4yNSwgNS41LCAxMS4yNSwgMTEuNzVdKSAgI2RvY3Rlc3Q6ICtFTExJUFNJU1xcbjQuMzg5NjE4NDM0NDQuLi5cXG5cXG5JZiB5b3UgaGF2ZSBwcmV2aW91c2x5IGNhbGN1bGF0ZWQgdGhlIG1lYW4sIHlvdSBjYW4gcGFzcyBpdCBhcyB0aGUgb3B0aW9uYWxcXG5zZWNvbmQgYXJndW1lbnQgdG8gdGhlIGZvdXIgXFxcInNwcmVhZFxcXCIgZnVuY3Rpb25zIHRvIGF2b2lkIHJlY2FsY3VsYXRpbmcgaXQ6XFxuXFxuPj4+IGRhdGEgPSBbMSwgMiwgMiwgNCwgNCwgNCwgNSwgNl1cXG4+Pj4gbXUgPSBtZWFuKGRhdGEpXFxuPj4+IHB2YXJpYW5jZShkYXRhLCBtdSlcXG4yLjVcXG5cXG5cXG5FeGNlcHRpb25zXFxuLS0tLS0tLS0tLVxcblxcbkEgc2luZ2xlIGV4Y2VwdGlvbiBpcyBkZWZpbmVkOiBTdGF0aXN0aWNzRXJyb3IgaXMgYSBzdWJjbGFzcyBvZiBWYWx1ZUVycm9yLlxcblxcblxcXCJcXFwiXFxcIlxcblxcbl9fYWxsX18gPSBbICdTdGF0aXN0aWNzRXJyb3InLFxcbiAgICAgICAgICAgICdwc3RkZXYnLCAncHZhcmlhbmNlJywgJ3N0ZGV2JywgJ3ZhcmlhbmNlJyxcXG4gICAgICAgICAgICAnbWVkaWFuJywgICdtZWRpYW5fbG93JywgJ21lZGlhbl9oaWdoJywgJ21lZGlhbl9ncm91cGVkJyxcXG4gICAgICAgICAgICAnbWVhbicsICdtb2RlJywgJ2hhcm1vbmljX21lYW4nLFxcbiAgICAgICAgICBdXFxuXFxuZnJvbSBjb2xsZWN0aW9ucyBpbXBvcnQgQ291bnRlclxcbmZyb20gbWF0aCBpbXBvcnQgc3FydFxcblxcbmRlZiBtZWFuKGRhdGEpOlxcbiAgICByZXR1cm4gc3VtKGRhdGEpIC8gbGVuKGRhdGEpXFxuXFxuZGVmIGhhcm1vbmljX21lYW4oZGF0YSk6XFxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcXG5cXG5cXG5kZWYgbWVkaWFuKGRhdGEpOlxcbiAgICBfZGF0YSA9IHNvcnRlZChkYXRhKVxcbiAgICBsID0gbGVuKF9kYXRhKVxcbiAgICBpZiBsICUgMiA9PSAwOlxcbiAgICAgICAgX21lZGlhbiA9IChfZGF0YVtsLy8yXSArIF9kYXRhW2wvLzItMV0pIC8gMlxcbiAgICBlbHNlOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzJdXFxuICAgIHJldHVybiBfbWVkaWFuXFxuXFxuZGVmIG1lZGlhbl9sb3coZGF0YSk6XFxuICAgIF9kYXRhID0gc29ydGVkKGRhdGEpXFxuICAgIGwgPSBsZW4oX2RhdGEpXFxuICAgIGlmIGwgJSAyID09IDA6XFxuICAgICAgICBfbWVkaWFuID0gX2RhdGFbbC8vMi0xXVxcbiAgICBlbHNlOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzJdXFxuICAgIHJldHVybiBfbWVkaWFuXFxuXFxuXFxuZGVmIG1lZGlhbl9oaWdoKGRhdGEpOlxcbiAgICBfZGF0YSA9IHNvcnRlZChkYXRhKVxcbiAgICBsID0gbGVuKF9kYXRhKVxcbiAgICBpZiBsICUgMiA9PSAwOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzJdXFxuICAgIGVsc2U6XFxuICAgICAgICBfbWVkaWFuID0gX2RhdGFbbC8vMl1cXG4gICAgcmV0dXJuIF9tZWRpYW5cXG5cXG5cXG5kZWYgbWVkaWFuX2dyb3VwZWQoZGF0YSk6XFxuICAgIHJldHVybiBtZWRpYW4oZGF0YSlcXG5cXG5kZWYgbW9kZShkYXRhKTpcXG4gICAgY291bnRlciA9IENvdW50ZXIoZGF0YSlcXG4gICAgbWF4X2NvdW50ID0gbWF4KGNvdW50ZXIudmFsdWVzKCkpXFxuICAgIF9tb2RlID0gW2sgZm9yIGssdiBpbiBjb3VudGVyLml0ZW1zKCkgaWYgdiA9PSBtYXhfY291bnRdXFxuICAgIGlmIGxlbihfbW9kZSkgPiAxOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiTm8gVW5pcXVlIE1vZGUsIGZvdW5kIHt9IGVxdWFsbHkgY29tbW9uIHZhbHVlc1xcXCIuZm9ybWF0KGxlbihfbW9kZSkpKVxcbiAgICBlbHNlOlxcbiAgICAgICAgcmV0dXJuIF9tb2RlWzBdXFxuXFxuXFxuZGVmIHZhcmlhbmNlKGRhdGEpOlxcbiAgICBhdmVyYWdlPW1lYW4oZGF0YSlcXG4gICAgX3ZhcmlhbmNlPTBcXG4gICAgZm9yIGQgaW4gZGF0YTpcXG4gICAgICAgIF92YXJpYW5jZSArPSAoKGF2ZXJhZ2UtZCkqKjIpXFxuICAgICAgICBmaW5hbF92YXJpYW5jZT1fdmFyaWFuY2UvbGVuKGRhdGEpXFxuICAgIHJldHVybiBmaW5hbF92YXJpYW5jZVxcblxcbmRlZiBwdmFyaWFuY2UoZGF0YSk6XFxuICAgIGF2ZXJhZ2U9bWVhbihkYXRhKVxcbiAgICBfdmFyaWFuY2U9MFxcbiAgICBmb3IgZCBpbiBkYXRhOlxcbiAgICAgICAgX3ZhcmlhbmNlICs9ICgoYXZlcmFnZS1kKSoqMilcXG4gICAgICAgIGZpbmFsX3ZhcmlhbmNlPV92YXJpYW5jZS9sZW4oZGF0YSlcXG4gICAgcmV0dXJuIGZpbmFsX3ZhcmlhbmNlXFxuXFxuZGVmIHZhcmlhbmNlKGRhdGEpOlxcbiAgICBhdmVyYWdlPW1lYW4oZGF0YSlcXG4gICAgX3ZhcmlhbmNlPTBcXG4gICAgZm9yIGQgaW4gZGF0YTpcXG4gICAgICAgIF92YXJpYW5jZSArPSAoKGF2ZXJhZ2UtZCkqKjIpXFxuICAgICAgICBmaW5hbF92YXJpYW5jZT1fdmFyaWFuY2UvKGxlbihkYXRhKSAtMSlcXG4gICAgcmV0dXJuIGZpbmFsX3ZhcmlhbmNlXFxuXFxuZGVmIHBzdGRldihkYXRhKTpcXG4gICAgcmV0dXJuIHNxcnQocHZhcmlhbmNlKGRhdGEpKVxcblxcbmRlZiBzdGRldihkYXRhKTpcXG4gICAgcmV0dXJuIHNxcnQodmFyaWFuY2UoZGF0YSkpXFxuXFxuXCIsXCJzcmMvbGliL3N0YXR2ZnMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3RhdHZmc1xcXCIpXFxuXCIsXCJzcmMvbGliL3N0cmluZ29sZC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzdHJpbmdvbGRcXFwiKVxcblwiLFwic3JjL2xpYi9zdHJpbmdwcmVwLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInN0cmluZ3ByZXBcXFwiKVxcblwiLFwic3JjL2xpYi9zdHJ1Y3QucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3RydWN0XFxcIilcXG5cIixcInNyYy9saWIvc3VicHJvY2Vzcy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzdWJwcm9jZXNzXFxcIilcXG5cIixcInNyYy9saWIvc3VuYXUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3VuYXVcXFwiKVxcblwiLFwic3JjL2xpYi9zdW5hdWRpby5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzdW5hdWRpb1xcXCIpXFxuXCIsXCJzcmMvbGliL3N5bWJvbC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzeW1ib2xcXFwiKVxcblwiLFwic3JjL2xpYi9zeW10YWJsZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzeW10YWJsZVxcXCIpXFxuXCIsXCJzcmMvbGliL3RhYm5hbm55LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRhYm5hbm55XFxcIilcXG5cIixcInNyYy9saWIvdGFyZmlsZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0YXJmaWxlXFxcIilcXG5cIixcInNyYy9saWIvdGVsbmV0bGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRlbG5ldGxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL3RlbXBmaWxlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRlbXBmaWxlXFxcIilcXG5cIixcInNyYy9saWIvdGVzdC9fX2luaXRfXy5weVwiOlwiX19hdXRob3JfXyA9ICdibWlsbGVyJ1xcblxcbmRlZiB0ZXN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgcGxhY2VzPTUpOlxcbiAgICBpZiBpc2luc3RhbmNlKGV4cGVjdGVkLGludCk6XFxuICAgICAgICBpZiBhY3R1YWwgPT0gZXhwZWN0ZWQ6XFxuICAgICAgICAgICAgcHJpbnQoJ1Bhc3MnKVxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgIGVsaWYgaXNpbnN0YW5jZShleHBlY3RlZCxmbG9hdCk6XFxuICAgICAgICBpZiBhYnMoYWN0dWFsLWV4cGVjdGVkKSA8IDEwKiooLXBsYWNlcyk6XFxuICAgICAgICAgICAgcHJpbnQoJ1Bhc3MnKVxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgIGVsc2U6XFxuICAgICAgICBpZiBhY3R1YWwgPT0gZXhwZWN0ZWQ6XFxuICAgICAgICAgICAgcHJpbnQoJ1Bhc3MnKVxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgIHByaW50KCdUZXN0IEZhaWxlZDogZXhwZWN0ZWQgJyArIHN0cihleHBlY3RlZCkgKyAnIGJ1dCBnb3QgJyArIHN0cihhY3R1YWwpKVxcbiAgICByZXR1cm4gRmFsc2VcXG5cXG5kZWYgdGVzdE5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpOlxcbiAgICBwYXNzXFxuXFxuXCIsXCJzcmMvbGliL3Rlc3QvYW5uX21vZHVsZS5weVwiOlwiXFxuXFxuXFxcIlxcXCJcXFwiXFxuVGhlIG1vZHVsZSBmb3IgdGVzdGluZyB2YXJpYWJsZSBhbm5vdGF0aW9ucy5cXG5FbXB0eSBsaW5lcyBhYm92ZSBhcmUgZm9yIGdvb2QgcmVhc29uICh0ZXN0aW5nIGZvciBjb3JyZWN0IGxpbmUgbnVtYmVycylcXG5cXFwiXFxcIlxcXCJcXG5cXG4jIGZyb20gdHlwaW5nIGltcG9ydCBPcHRpb25hbFxcbiMgZnJvbSBmdW5jdG9vbHMgaW1wb3J0IHdyYXBzXFxuXFxuX19hbm5vdGF0aW9uc19fWzFdID0gMlxcblxcbmNsYXNzIEM6XFxuXFxuICAgIHggPSA1OyAjeTogT3B0aW9uYWxbJ0MnXSA9IE5vbmVcXG5cXG4jIGZyb20gdHlwaW5nIGltcG9ydCBUdXBsZVxcbng6IGludCA9IDU7IHk6IHN0ciA9IHg7IyBmOiBUdXBsZVtpbnQsIGludF1cXG5cXG5jbGFzcyBNKHR5cGUpOlxcblxcbiAgICBfX2Fubm90YXRpb25zX19bJzEyMyddID0gMTIzXFxuICAgIG86IHR5cGUgPSBvYmplY3RcXG5cXG4ocGFycyk6IGJvb2wgPSBUcnVlXFxuXFxuY2xhc3MgRChDKTpcXG4gICAgajogc3RyID0gJ2hpJzsgazogc3RyPSAnYnllJ1xcblxcbiMgZnJvbSB0eXBlcyBpbXBvcnQgbmV3X2NsYXNzXFxuIyBoX2NsYXNzID0gbmV3X2NsYXNzKCdIJywgKEMsKSlcXG4jIGpfY2xhc3MgPSBuZXdfY2xhc3MoJ0onKVxcblxcbmNsYXNzIEYoKTpcXG4gICAgejogaW50ID0gNVxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgeCk6XFxuICAgICAgICBwYXNzXFxuXFxuY2xhc3MgWShGKTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc3VwZXIoRiwgc2VsZikuX19pbml0X18oMTIzKVxcblxcbmNsYXNzIE1ldGEodHlwZSk6XFxuICAgIGRlZiBfX25ld19fKG1ldGEsIG5hbWUsIGJhc2VzLCBuYW1lc3BhY2UpOlxcbiAgICAgICAgcmV0dXJuIHN1cGVyKCkuX19uZXdfXyhtZXRhLCBuYW1lLCBiYXNlcywgbmFtZXNwYWNlKVxcblxcbmNsYXNzIFMobWV0YWNsYXNzID0gTWV0YSk6XFxuICAgIHg6IHN0ciA9ICdzb21ldGhpbmcnXFxuICAgIHk6IHN0ciA9ICdzb21ldGhpbmcgZWxzZSdcXG5cXG4jIGRlZiBmb28oeDogaW50ID0gMTApOlxcbiMgICAgIGRlZiBiYXIoeTogTGlzdFtzdHJdKTpcXG4jICAgICAgICAgeDogc3RyID0gJ3llcydcXG4jICAgICBiYXIoKVxcblxcbiMgZGVmIGRlYyhmdW5jKTpcXG4jICAgICBAd3JhcHMoZnVuYylcXG4jICAgICBkZWYgd3JhcHBlcigqYXJncywgKiprd2FyZ3MpOlxcbiMgICAgICAgICByZXR1cm4gZnVuYygqYXJncywgKiprd2FyZ3MpXFxuIyAgICAgcmV0dXJuIHdyYXBwZXJcXG5cIixcInNyYy9saWIvdGVzdC9hbm5fbW9kdWxlMi5weVwiOlwiXFxcIlxcXCJcXFwiXFxuU29tZSBjb3JyZWN0IHN5bnRheCBmb3IgdmFyaWFibGUgYW5ub3RhdGlvbiBoZXJlLlxcbk1vcmUgZXhhbXBsZXMgYXJlIGluIHRlc3RfZ3JhbW1hciBhbmQgdGVzdF9wYXJzZXIuXFxuXFxcIlxcXCJcXFwiXFxuXFxuIyBmcm9tIHR5cGluZyBpbXBvcnQgbm9fdHlwZV9jaGVjaywgQ2xhc3NWYXJcXG5cXG5pOiBpbnQgPSAxXFxuajogaW50XFxueDogZmxvYXQgPSBpLzEwXFxuXFxuZGVmIGYoKTpcXG4gICAgIyBjbGFzcyBDOiAuLi5cXG4gICAgY2xhc3MgQzogcGFzc1xcbiAgICByZXR1cm4gQygpXFxuXFxuZigpLm5ld19hdHRyOiBvYmplY3QgPSBvYmplY3QoKVxcblxcbmNsYXNzIEM6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCB4OiBpbnQpIC0+IE5vbmU6XFxuICAgICAgICBzZWxmLnggPSB4XFxuXFxuYyA9IEMoNSlcXG5jLm5ld19hdHRyOiBpbnQgPSAxMFxcblxcbl9fYW5ub3RhdGlvbnNfXyA9IHt9XFxuXFxuXFxuIyBAbm9fdHlwZV9jaGVja1xcbiMgY2xhc3MgTlRDOlxcbiMgICAgIGRlZiBtZXRoKHNlbGYsIHBhcmFtOiBjb21wbGV4KSAtPiBOb25lOlxcbiMgICAgICAgICAuLi5cXG5cXG4jIGNsYXNzIENWOlxcbiMgICAgIHZhcjogQ2xhc3NWYXJbJ0NWJ11cXG5cXG4jIENWLnZhciA9IENWKClcXG5cIixcInNyYy9saWIvdGVzdC9hbm5fbW9kdWxlMy5weVwiOlwiXFxcIlxcXCJcXFwiXFxuQ29ycmVjdCBzeW50YXggZm9yIHZhcmlhYmxlIGFubm90YXRpb24gdGhhdCBzaG91bGQgZmFpbCBhdCBydW50aW1lXFxuaW4gYSBjZXJ0YWluIG1hbm5lci4gTW9yZSBleGFtcGxlcyBhcmUgaW4gdGVzdF9ncmFtbWFyIGFuZCB0ZXN0X3BhcnNlci5cXG5cXFwiXFxcIlxcXCJcXG5cXG5kZWYgZl9iYWRfYW5uKCk6XFxuICAgIF9fYW5ub3RhdGlvbnNfX1sxXSA9IDJcXG5cXG5jbGFzcyBDX09LOlxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgeDogaW50KSAtPiBOb25lOlxcbiAgICAgICAgc2VsZi54OiBub19zdWNoX25hbWUgPSB4ICAjIFRoaXMgb25lIGlzIE9LIGFzIHByb3Bvc2VkIGJ5IEd1aWRvXFxuXFxuY2xhc3MgRF9iYWRfYW5uOlxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgeDogaW50KSAtPiBOb25lOlxcbiAgICAgICAgc2ZlbC55OiBpbnQgPSAwXFxuXFxuZGVmIGdfYmFkX2FubigpOlxcbiAgICBub19zdWNoX25hbWUuYXR0cjogaW50ID0gMFxcblwiLFwic3JjL2xpYi90ZXN0L2JhZF9nZXRhdHRyLnB5XCI6XCJ4ID0gMVxcblxcbl9fZ2V0YXR0cl9fID0gXFxcIlN1cnByaXNlIVxcXCJcXG5fX2Rpcl9fID0gXFxcIlN1cnByaXNlIGFnYWluIVxcXCJcXG5cIixcInNyYy9saWIvdGVzdC9iYWRfZ2V0YXR0cjIucHlcIjpcImRlZiBfX2dldGF0dHJfXygpOlxcbiAgICBcXFwiQmFkIG9uZVxcXCJcXG5cXG54ID0gMVxcblxcbmRlZiBfX2Rpcl9fKGJhZF9zaWcpOlxcbiAgICByZXR1cm4gW11cXG5cIixcInNyYy9saWIvdGVzdC9iYWRfZ2V0YXR0cjMucHlcIjpcImRlZiBfX2dldGF0dHJfXyhuYW1lKTpcXG4gICAgZ2xvYmFsIF9fZ2V0YXR0cl9fXFxuICAgIGlmIG5hbWUgIT0gJ2RlbGdldGF0dHInOlxcbiAgICAgICAgcmFpc2UgQXR0cmlidXRlRXJyb3JcXG4gICAgZGVsIF9fZ2V0YXR0cl9fXFxuICAgIHJhaXNlIEF0dHJpYnV0ZUVycm9yXFxuXCIsXCJzcmMvbGliL3Rlc3QvZGVjaW1hbHRlc3RkYXRhL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImRlY2ltYWx0ZXN0ZGF0YVxcXCIpXFxuXCIsXCJzcmMvbGliL3Rlc3QvZ29vZF9nZXRhdHRyLnB5XCI6XCJ4ID0gMVxcblxcbmRlZiBfX2Rpcl9fKCk6XFxuICAgIHJldHVybiBbJ2EnLCAnYicsICdjJ11cXG5cXG5kZWYgX19nZXRhdHRyX18obmFtZSk6XFxuICAgIGlmIG5hbWUgPT0gXFxcInlvbG9cXFwiOlxcbiAgICAgICAgcmFpc2UgQXR0cmlidXRlRXJyb3IoXFxcIkRlcHJlY2F0ZWQsIHVzZSB3aGF0ZXZlciBpbnN0ZWFkXFxcIilcXG4gICAgcmV0dXJuIGZcXFwiVGhlcmUgaXMge25hbWV9XFxcIlxcblxcbnkgPSAyXFxuXCIsXCJzcmMvbGliL3Rlc3QvdGVzdF9zdXBwb3J0LnB5XCI6XCJcXFwiXFxcIlxcXCJTdXBwb3J0aW5nIGRlZmluaXRpb25zIGZvciB0aGUgUHl0aG9uIHJlZ3Jlc3Npb24gdGVzdHMuXFxcIlxcXCJcXFwiXFxuXFxuaWYgX19uYW1lX18gIT0gJ3Rlc3QudGVzdF9zdXBwb3J0JzpcXG4gICAgcmFpc2UgSW1wb3J0RXJyb3IoJ3Rlc3Rfc3VwcG9ydCBtdXN0IGJlIGltcG9ydGVkIGZyb20gdGhlIHRlc3QgcGFja2FnZScpXFxuXFxuaW1wb3J0IHVuaXR0ZXN0XFxuXFxuXFxuIyBkZWYgcnVuX3VuaXR0ZXN0KCpjbGFzc2VzKTpcXG4jICAgICBcXFwiXFxcIlxcXCJSdW4gdGVzdHMgZnJvbSB1bml0dGVzdC5UZXN0Q2FzZS1kZXJpdmVkIGNsYXNzZXMuXFxcIlxcXCJcXFwiXFxuIyAgICAgdmFsaWRfdHlwZXMgPSAodW5pdHRlc3QuVGVzdFN1aXRlLCB1bml0dGVzdC5UZXN0Q2FzZSlcXG4jICAgICBzdWl0ZSA9IHVuaXR0ZXN0LlRlc3RTdWl0ZSgpXFxuIyAgICAgZm9yIGNscyBpbiBjbGFzc2VzOlxcbiMgICAgICAgICBpZiBpc2luc3RhbmNlKGNscywgc3RyKTpcXG4jICAgICAgICAgICAgIGlmIGNscyBpbiBzeXMubW9kdWxlczpcXG4jICAgICAgICAgICAgICAgICBzdWl0ZS5hZGRUZXN0KHVuaXR0ZXN0LmZpbmRUZXN0Q2FzZXMoc3lzLm1vZHVsZXNbY2xzXSkpXFxuIyAgICAgICAgICAgICBlbHNlOlxcbiMgICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcInN0ciBhcmd1bWVudHMgbXVzdCBiZSBrZXlzIGluIHN5cy5tb2R1bGVzXFxcIilcXG4jICAgICAgICAgZWxpZiBpc2luc3RhbmNlKGNscywgdmFsaWRfdHlwZXMpOlxcbiMgICAgICAgICAgICAgc3VpdGUuYWRkVGVzdChjbHMpXFxuIyAgICAgICAgIGVsc2U6XFxuIyAgICAgICAgICAgICBzdWl0ZS5hZGRUZXN0KHVuaXR0ZXN0Lm1ha2VTdWl0ZShjbHMpKVxcbiMgICAgIF9ydW5fc3VpdGUoc3VpdGUpXFxuXFxuZGVmIHJ1bl91bml0dGVzdCgqY2xhc3Nlcyk6XFxuICAgIFxcXCJcXFwiXFxcIlJ1biB0ZXN0cyBmcm9tIHVuaXR0ZXN0LlRlc3RDYXNlLWRlcml2ZWQgY2xhc3Nlcy5cXFwiXFxcIlxcXCJcXG4gICAgZm9yIGNscyBpbiBjbGFzc2VzOlxcbiAgICAgICAgcHJpbnQgY2xzXFxuICAgICAgICBpZiBpc3N1YmNsYXNzKGNscywgdW5pdHRlc3QuVGVzdENhc2UpOlxcbiAgICAgICAgICAgIGNscygpLm1haW4oKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBwcmludCBcXFwiRG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggXFxcIiwgY2xzXFxuXCIsXCJzcmMvbGliL3RleHR3cmFwLnB5XCI6XCJcXFwiXFxcIlxcXCJUZXh0IHdyYXBwaW5nIGFuZCBmaWxsaW5nLlxcblxcXCJcXFwiXFxcIlxcblxcbiMgQ29weXJpZ2h0IChDKSAxOTk5LTIwMDEgR3JlZ29yeSBQLiBXYXJkLlxcbiMgQ29weXJpZ2h0IChDKSAyMDAyLCAyMDAzIFB5dGhvbiBTb2Z0d2FyZSBGb3VuZGF0aW9uLlxcbiMgV3JpdHRlbiBieSBHcmVnIFdhcmQgPGd3YXJkQHB5dGhvbi5uZXQ+XFxuXFxuaW1wb3J0IHJlLCBzdHJpbmdcXG5cXG5fX2FsbF9fID0gWydUZXh0V3JhcHBlcicsICd3cmFwJywgJ2ZpbGwnLCAnZGVkZW50JywgJ2luZGVudCcsICdzaG9ydGVuJ11cXG5cXG4jIEhhcmRjb2RlIHRoZSByZWNvZ25pemVkIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB0byB0aGUgVVMtQVNDSUlcXG4jIHdoaXRlc3BhY2UgY2hhcmFjdGVycy4gIFRoZSBtYWluIHJlYXNvbiBmb3IgZG9pbmcgdGhpcyBpcyB0aGF0XFxuIyBzb21lIFVuaWNvZGUgc3BhY2VzIChsaWtlIFxcXFx1MDBhMCkgYXJlIG5vbi1icmVha2luZyB3aGl0ZXNwYWNlcy5cXG5fd2hpdGVzcGFjZSA9ICdcXFxcdFxcXFxuXFxcXHgwYlxcXFx4MGNcXFxcciAnXFxuXFxuY2xhc3MgVGV4dFdyYXBwZXI6XFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBPYmplY3QgZm9yIHdyYXBwaW5nL2ZpbGxpbmcgdGV4dC4gIFRoZSBwdWJsaWMgaW50ZXJmYWNlIGNvbnNpc3RzIG9mXFxuICAgIHRoZSB3cmFwKCkgYW5kIGZpbGwoKSBtZXRob2RzOyB0aGUgb3RoZXIgbWV0aG9kcyBhcmUganVzdCB0aGVyZSBmb3JcXG4gICAgc3ViY2xhc3NlcyB0byBvdmVycmlkZSBpbiBvcmRlciB0byB0d2VhayB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuXFxuICAgIElmIHlvdSB3YW50IHRvIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGUgbWFpbiB3cmFwcGluZyBhbGdvcml0aG0sXFxuICAgIHlvdSdsbCBwcm9iYWJseSBoYXZlIHRvIG92ZXJyaWRlIF93cmFwX2NodW5rcygpLlxcbiAgICBTZXZlcmFsIGluc3RhbmNlIGF0dHJpYnV0ZXMgY29udHJvbCB2YXJpb3VzIGFzcGVjdHMgb2Ygd3JhcHBpbmc6XFxuICAgICAgd2lkdGggKGRlZmF1bHQ6IDcwKVxcbiAgICAgICAgdGhlIG1heGltdW0gd2lkdGggb2Ygd3JhcHBlZCBsaW5lcyAodW5sZXNzIGJyZWFrX2xvbmdfd29yZHNcXG4gICAgICAgIGlzIGZhbHNlKVxcbiAgICAgIGluaXRpYWxfaW5kZW50IChkZWZhdWx0OiBcXFwiXFxcIilcXG4gICAgICAgIHN0cmluZyB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBmaXJzdCBsaW5lIG9mIHdyYXBwZWRcXG4gICAgICAgIG91dHB1dC4gIENvdW50cyB0b3dhcmRzIHRoZSBsaW5lJ3Mgd2lkdGguXFxuICAgICAgc3Vic2VxdWVudF9pbmRlbnQgKGRlZmF1bHQ6IFxcXCJcXFwiKVxcbiAgICAgICAgc3RyaW5nIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gYWxsIGxpbmVzIHNhdmUgdGhlIGZpcnN0XFxuICAgICAgICBvZiB3cmFwcGVkIG91dHB1dDsgYWxzbyBjb3VudHMgdG93YXJkcyBlYWNoIGxpbmUncyB3aWR0aC5cXG4gICAgICBleHBhbmRfdGFicyAoZGVmYXVsdDogdHJ1ZSlcXG4gICAgICAgIEV4cGFuZCB0YWJzIGluIGlucHV0IHRleHQgdG8gc3BhY2VzIGJlZm9yZSBmdXJ0aGVyIHByb2Nlc3NpbmcuXFxuICAgICAgICBFYWNoIHRhYiB3aWxsIGJlY29tZSAwIC4uICd0YWJzaXplJyBzcGFjZXMsIGRlcGVuZGluZyBvbiBpdHMgcG9zaXRpb25cXG4gICAgICAgIGluIGl0cyBsaW5lLiAgSWYgZmFsc2UsIGVhY2ggdGFiIGlzIHRyZWF0ZWQgYXMgYSBzaW5nbGUgY2hhcmFjdGVyLlxcbiAgICAgIHRhYnNpemUgKGRlZmF1bHQ6IDgpXFxuICAgICAgICBFeHBhbmQgdGFicyBpbiBpbnB1dCB0ZXh0IHRvIDAgLi4gJ3RhYnNpemUnIHNwYWNlcywgdW5sZXNzXFxuICAgICAgICAnZXhwYW5kX3RhYnMnIGlzIGZhbHNlLlxcbiAgICAgIHJlcGxhY2Vfd2hpdGVzcGFjZSAoZGVmYXVsdDogdHJ1ZSlcXG4gICAgICAgIFJlcGxhY2UgYWxsIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdGV4dCBieSBzcGFjZXNcXG4gICAgICAgIGFmdGVyIHRhYiBleHBhbnNpb24uICBOb3RlIHRoYXQgaWYgZXhwYW5kX3RhYnMgaXMgZmFsc2UgYW5kXFxuICAgICAgICByZXBsYWNlX3doaXRlc3BhY2UgaXMgdHJ1ZSwgZXZlcnkgdGFiIHdpbGwgYmUgY29udmVydGVkIHRvIGFcXG4gICAgICAgIHNpbmdsZSBzcGFjZSFcXG4gICAgICBmaXhfc2VudGVuY2VfZW5kaW5ncyAoZGVmYXVsdDogZmFsc2UpXFxuICAgICAgICBFbnN1cmUgdGhhdCBzZW50ZW5jZS1lbmRpbmcgcHVuY3R1YXRpb24gaXMgYWx3YXlzIGZvbGxvd2VkXFxuICAgICAgICBieSB0d28gc3BhY2VzLiAgT2ZmIGJ5IGRlZmF1bHQgYmVjYXVzZSB0aGUgYWxnb3JpdGhtIGlzXFxuICAgICAgICAodW5hdm9pZGFibHkpIGltcGVyZmVjdC5cXG4gICAgICBicmVha19sb25nX3dvcmRzIChkZWZhdWx0OiB0cnVlKVxcbiAgICAgICAgQnJlYWsgd29yZHMgbG9uZ2VyIHRoYW4gJ3dpZHRoJy4gIElmIGZhbHNlLCB0aG9zZSB3b3JkcyB3aWxsIG5vdFxcbiAgICAgICAgYmUgYnJva2VuLCBhbmQgc29tZSBsaW5lcyBtaWdodCBiZSBsb25nZXIgdGhhbiAnd2lkdGgnLlxcbiAgICAgIGJyZWFrX29uX2h5cGhlbnMgKGRlZmF1bHQ6IHRydWUpXFxuICAgICAgICBBbGxvdyBicmVha2luZyBoeXBoZW5hdGVkIHdvcmRzLiBJZiB0cnVlLCB3cmFwcGluZyB3aWxsIG9jY3VyXFxuICAgICAgICBwcmVmZXJhYmx5IG9uIHdoaXRlc3BhY2VzIGFuZCByaWdodCBhZnRlciBoeXBoZW5zIHBhcnQgb2ZcXG4gICAgICAgIGNvbXBvdW5kIHdvcmRzLlxcbiAgICAgIGRyb3Bfd2hpdGVzcGFjZSAoZGVmYXVsdDogdHJ1ZSlcXG4gICAgICAgIERyb3AgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIGxpbmVzLlxcbiAgICAgIG1heF9saW5lcyAoZGVmYXVsdDogTm9uZSlcXG4gICAgICAgIFRydW5jYXRlIHdyYXBwZWQgbGluZXMuXFxuICAgICAgcGxhY2Vob2xkZXIgKGRlZmF1bHQ6ICcgWy4uLl0nKVxcbiAgICAgICAgQXBwZW5kIHRvIHRoZSBsYXN0IGxpbmUgb2YgdHJ1bmNhdGVkIHRleHQuXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICB1bmljb2RlX3doaXRlc3BhY2VfdHJhbnMgPSB7fVxcbiAgICAjIHVzcGFjZSA9IG9yZCgnICcpXFxuICAgIHVzcGFjZSA9ICcgJ1xcbiAgICBmb3IgeCBpbiBfd2hpdGVzcGFjZTpcXG4gICAgICAgICMgdW5pY29kZV93aGl0ZXNwYWNlX3RyYW5zW29yZCh4KV0gPSB1c3BhY2VcXG4gICAgICAgIHVuaWNvZGVfd2hpdGVzcGFjZV90cmFuc1t4XSA9IHVzcGFjZVxcblxcbiAgICAjIFRoaXMgZnVua3kgbGl0dGxlIHJlZ2V4IGlzIGp1c3QgdGhlIHRyaWNrIGZvciBzcGxpdHRpbmdcXG4gICAgIyB0ZXh0IHVwIGludG8gd29yZC13cmFwcGFibGUgY2h1bmtzLiAgRS5nLlxcbiAgICAjICAgXFxcIkhlbGxvIHRoZXJlIC0tIHlvdSBnb29mLWJhbGwsIHVzZSB0aGUgLWIgb3B0aW9uIVxcXCJcXG4gICAgIyBzcGxpdHMgaW50b1xcbiAgICAjICAgSGVsbG8vIC90aGVyZS8gLy0tLyAveW91LyAvZ29vZi0vYmFsbCwvIC91c2UvIC90aGUvIC8tYi8gL29wdGlvbiFcXG4gICAgIyAoYWZ0ZXIgc3RyaXBwaW5nIG91dCBlbXB0eSBzdHJpbmdzKS5cXG4gICAgd29yZHNlcF9yZSA9IHJlLmNvbXBpbGUoXFxuICAgICAgICByJyhcXFxccyt8JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGFueSB3aGl0ZXNwYWNlXFxuICAgICAgICByJ1teXFxcXHNcXFxcd10qXFxcXHcrW14wLTlcXFxcV10tKD89XFxcXHcrW14wLTlcXFxcV10pKScpICAjIGh5cGhlbmF0ZWQgd29yZHNcXG4gICAgZW1fZGFzaCA9IHJlLmNvbXBpbGUocicoXFxcXHMrfCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBhbnkgd2hpdGVzcGFjZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICByJ1teXFxcXHNcXFxcd10qXFxcXHcrW14wLTlcXFxcV10tKD89XFxcXHcrW14wLTlcXFxcV10pfCcgICAjIGh5cGhlbmF0ZWQgd29yZHNcXG4gICAgICAgICAgICAgICAgICAgICAgICAgcicoPyFeKS17Mix9KD89XFxcXHcpKScpICAgICAgICAgICAgICAgICAgICAgIyBlbS1kYXNoXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAjIFRoaXMgbGVzcyBmdW5reSBsaXR0bGUgcmVnZXgganVzdCBzcGxpdCBvbiByZWNvZ25pemVkIHNwYWNlcy4gRS5nLlxcbiAgICAjICAgXFxcIkhlbGxvIHRoZXJlIC0tIHlvdSBnb29mLWJhbGwsIHVzZSB0aGUgLWIgb3B0aW9uIVxcXCJcXG4gICAgIyBzcGxpdHMgaW50b1xcbiAgICAjICAgSGVsbG8vIC90aGVyZS8gLy0tLyAveW91LyAvZ29vZi1iYWxsLC8gL3VzZS8gL3RoZS8gLy1iLyAvb3B0aW9uIS9cXG4gICAgd29yZHNlcF9zaW1wbGVfcmUgPSByZS5jb21waWxlKHInKFxcXFxzKyknKVxcblxcblxcbiAgICAjIFhYWCB0aGlzIGlzIG5vdCBsb2NhbGUtIG9yIGNoYXJzZXQtYXdhcmUgLS0gc3RyaW5nLmxvd2VyY2FzZVxcbiAgICAjIGlzIFVTLUFTQ0lJIG9ubHkgKGFuZCB0aGVyZWZvcmUgRW5nbGlzaC1vbmx5KVxcbiAgICBzZW50ZW5jZV9lbmRfcmUgPSByZS5jb21waWxlKHInW2Etel0nICAgICAgICAgICAgICMgbG93ZXJjYXNlIGxldHRlclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHInW1xcXFwuXFxcXCFcXFxcP10nICAgICAgICAgICMgc2VudGVuY2UtZW5kaW5nIHB1bmN0LlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHInW1xcXFxcXFwiXFxcXCddPycgICAgICAgICAgICMgb3B0aW9uYWwgZW5kLW9mLXF1b3RlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcidcXFxcWicpICAgICAgICAgICAgICAgIyBlbmQgb2YgY2h1bmtcXG4gICAgc2VudGVuY2VfZW5kX3JlID0gcidbYS16XVtcXFxcLlxcXFwhXFxcXD9dW1xcXFxcXFwiXFxcXCddPydcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsXFxuICAgICAgICAgICAgICAgICB3aWR0aD03MCxcXG4gICAgICAgICAgICAgICAgIGluaXRpYWxfaW5kZW50PVxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgc3Vic2VxdWVudF9pbmRlbnQ9XFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgICBleHBhbmRfdGFicz1UcnVlLFxcbiAgICAgICAgICAgICAgICAgcmVwbGFjZV93aGl0ZXNwYWNlPVRydWUsXFxuICAgICAgICAgICAgICAgICBmaXhfc2VudGVuY2VfZW5kaW5ncz1GYWxzZSxcXG4gICAgICAgICAgICAgICAgIGJyZWFrX2xvbmdfd29yZHM9VHJ1ZSxcXG4gICAgICAgICAgICAgICAgIGRyb3Bfd2hpdGVzcGFjZT1UcnVlLFxcbiAgICAgICAgICAgICAgICAgYnJlYWtfb25faHlwaGVucz1UcnVlLFxcbiAgICAgICAgICAgICAgICAgdGFic2l6ZT04LFxcbiAgICAgICAgICAgICAgICAgbWF4X2xpbmVzPU5vbmUsXFxuICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0nIFsuLi5dJyk6XFxuICAgICAgICBzZWxmLndpZHRoID0gd2lkdGhcXG4gICAgICAgIHNlbGYuaW5pdGlhbF9pbmRlbnQgPSBpbml0aWFsX2luZGVudFxcbiAgICAgICAgc2VsZi5zdWJzZXF1ZW50X2luZGVudCA9IHN1YnNlcXVlbnRfaW5kZW50XFxuICAgICAgICBzZWxmLmV4cGFuZF90YWJzID0gZXhwYW5kX3RhYnNcXG4gICAgICAgIHNlbGYucmVwbGFjZV93aGl0ZXNwYWNlID0gcmVwbGFjZV93aGl0ZXNwYWNlXFxuICAgICAgICBzZWxmLmZpeF9zZW50ZW5jZV9lbmRpbmdzID0gZml4X3NlbnRlbmNlX2VuZGluZ3NcXG4gICAgICAgIHNlbGYuYnJlYWtfbG9uZ193b3JkcyA9IGJyZWFrX2xvbmdfd29yZHNcXG4gICAgICAgIHNlbGYuZHJvcF93aGl0ZXNwYWNlID0gZHJvcF93aGl0ZXNwYWNlXFxuICAgICAgICBzZWxmLmJyZWFrX29uX2h5cGhlbnMgPSBicmVha19vbl9oeXBoZW5zXFxuICAgICAgICBzZWxmLnRhYnNpemUgPSB0YWJzaXplXFxuICAgICAgICBzZWxmLm1heF9saW5lcyA9IG1heF9saW5lc1xcbiAgICAgICAgc2VsZi5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyXFxuXFxuXFxuICAgICMgLS0gUHJpdmF0ZSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgICMgKHBvc3NpYmx5IHVzZWZ1bCBmb3Igc3ViY2xhc3NlcyB0byBvdmVycmlkZSlcXG5cXG4gICAgZGVmIF9tdW5nZV93aGl0ZXNwYWNlKHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX211bmdlX3doaXRlc3BhY2UodGV4dCA6IHN0cmluZykgLT4gc3RyaW5nXFxuICAgICAgICBNdW5nZSB3aGl0ZXNwYWNlIGluIHRleHQ6IGV4cGFuZCB0YWJzIGFuZCBjb252ZXJ0IGFsbCBvdGhlclxcbiAgICAgICAgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHRvIHNwYWNlcy4gIEVnLiBcXFwiIGZvb1xcXFxcXFxcdGJhclxcXFxcXFxcblxcXFxcXFxcbmJhelxcXCJcXG4gICAgICAgIGJlY29tZXMgXFxcIiBmb28gICAgYmFyICBiYXpcXFwiLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLmV4cGFuZF90YWJzOlxcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LmV4cGFuZHRhYnMoc2VsZi50YWJzaXplKVxcbiAgICAgICAgaWYgc2VsZi5yZXBsYWNlX3doaXRlc3BhY2U6XFxuICAgICAgICAgICAgZm9yIGtleSwgdmFsIGluIHNlbGYudW5pY29kZV93aGl0ZXNwYWNlX3RyYW5zLml0ZW1zKCk6XFxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uoa2V5LCB2YWwpXFxuICAgICAgICByZXR1cm4gdGV4dFxcblxcblxcbiAgICBkZWYgX3NwbGl0KHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX3NwbGl0KHRleHQgOiBzdHJpbmcpIC0+IFtzdHJpbmddXFxuICAgICAgICBTcGxpdCB0aGUgdGV4dCB0byB3cmFwIGludG8gaW5kaXZpc2libGUgY2h1bmtzLiAgQ2h1bmtzIGFyZVxcbiAgICAgICAgbm90IHF1aXRlIHRoZSBzYW1lIGFzIHdvcmRzOyBzZWUgX3dyYXBfY2h1bmtzKCkgZm9yIGZ1bGxcXG4gICAgICAgIGRldGFpbHMuICBBcyBhbiBleGFtcGxlLCB0aGUgdGV4dFxcbiAgICAgICAgICBMb29rLCBnb29mLWJhbGwgLS0gdXNlIHRoZSAtYiBvcHRpb24hXFxuICAgICAgICBicmVha3MgaW50byB0aGUgZm9sbG93aW5nIGNodW5rczpcXG4gICAgICAgICAgJ0xvb2ssJywgJyAnLCAnZ29vZi0nLCAnYmFsbCcsICcgJywgJy0tJywgJyAnLFxcbiAgICAgICAgICAndXNlJywgJyAnLCAndGhlJywgJyAnLCAnLWInLCAnICcsICdvcHRpb24hJ1xcbiAgICAgICAgaWYgYnJlYWtfb25faHlwaGVucyBpcyBUcnVlLCBvciBpbjpcXG4gICAgICAgICAgJ0xvb2ssJywgJyAnLCAnZ29vZi1iYWxsJywgJyAnLCAnLS0nLCAnICcsXFxuICAgICAgICAgICd1c2UnLCAnICcsICd0aGUnLCAnICcsICctYicsICcgJywgb3B0aW9uISdcXG4gICAgICAgIG90aGVyd2lzZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5icmVha19vbl9oeXBoZW5zIGlzIFRydWU6XFxuICAgICAgICAgICAgY2h1bmtzID0gc2VsZi53b3Jkc2VwX3JlLnNwbGl0KHRleHQpXFxuICAgICAgICAgICAgaWYgXFxcIi0tXFxcIiBpbiB0ZXh0OlxcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBbaXRlbSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHN1Ymxpc3QgaW4gW3NlbGYuZW1fZGFzaC5zcGxpdChjaHVuaykgZm9yIGNodW5rIGluIGNodW5rc10gXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgaXRlbSBpbiBzdWJsaXN0XVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBjaHVua3MgPSBzZWxmLndvcmRzZXBfc2ltcGxlX3JlLnNwbGl0KHRleHQpXFxuICAgICAgICBjaHVua3MgPSBbYyBmb3IgYyBpbiBjaHVua3MgaWYgY11cXG4gICAgICAgIHJldHVybiBjaHVua3NcXG5cXG4gICAgZGVmIF9maXhfc2VudGVuY2VfZW5kaW5ncyhzZWxmLCBjaHVua3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX2ZpeF9zZW50ZW5jZV9lbmRpbmdzKGNodW5rcyA6IFtzdHJpbmddKVxcbiAgICAgICAgQ29ycmVjdCBmb3Igc2VudGVuY2UgZW5kaW5ncyBidXJpZWQgaW4gJ2NodW5rcycuICBFZy4gd2hlbiB0aGVcXG4gICAgICAgIG9yaWdpbmFsIHRleHQgY29udGFpbnMgXFxcIi4uLiBmb28uXFxcXFxcXFxuQmFyIC4uLlxcXCIsIG11bmdlX3doaXRlc3BhY2UoKVxcbiAgICAgICAgYW5kIHNwbGl0KCkgd2lsbCBjb252ZXJ0IHRoYXQgdG8gWy4uLiwgXFxcImZvby5cXFwiLCBcXFwiIFxcXCIsIFxcXCJCYXJcXFwiLCAuLi5dXFxuICAgICAgICB3aGljaCBoYXMgb25lIHRvbyBmZXcgc3BhY2VzOyB0aGlzIG1ldGhvZCBzaW1wbHkgY2hhbmdlcyB0aGUgb25lXFxuICAgICAgICBzcGFjZSB0byB0d28uXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIGkgPSAwXFxuICAgICAgICAjIHBhdHNlYXJjaCA9IHNlbGYuc2VudGVuY2VfZW5kX3JlLnNlYXJjaFxcbiAgICAgICAgd2hpbGUgaSA8IGxlbihjaHVua3MpLTE6XFxuICAgICAgICAgICAgaWYgY2h1bmtzW2krMV0gPT0gXFxcIiBcXFwiIGFuZCByZS5zZWFyY2goc2VsZi5zZW50ZW5jZV9lbmRfcmUsIGNodW5rc1tpXSkgYW5kIGNodW5rc1tpXVstMV0gaW4gXFxcIi4hP1xcXFxcXFwiXFxcXCdcXFwiOlxcbiAgICAgICAgICAgICAgICBjaHVua3NbaSsxXSA9IFxcXCIgIFxcXCJcXG4gICAgICAgICAgICAgICAgaSArPSAyXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaSArPSAxXFxuXFxuICAgIGRlZiBfaGFuZGxlX2xvbmdfd29yZChzZWxmLCByZXZlcnNlZF9jaHVua3MsIGN1cl9saW5lLCBjdXJfbGVuLCB3aWR0aCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJfaGFuZGxlX2xvbmdfd29yZChjaHVua3MgOiBbc3RyaW5nXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cl9saW5lIDogW3N0cmluZ10sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGVuIDogaW50LCB3aWR0aCA6IGludClcXG4gICAgICAgIEhhbmRsZSBhIGNodW5rIG9mIHRleHQgKG1vc3QgbGlrZWx5IGEgd29yZCwgbm90IHdoaXRlc3BhY2UpIHRoYXRcXG4gICAgICAgIGlzIHRvbyBsb25nIHRvIGZpdCBpbiBhbnkgbGluZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgIyBGaWd1cmUgb3V0IHdoZW4gaW5kZW50IGlzIGxhcmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgd2lkdGgsIGFuZCBtYWtlXFxuICAgICAgICAjIHN1cmUgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpcyBzdHJpcHBlZCBvZmYgb24gZXZlcnkgcGFzc1xcbiAgICAgICAgaWYgd2lkdGggPCAxOlxcbiAgICAgICAgICAgIHNwYWNlX2xlZnQgPSAxXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNwYWNlX2xlZnQgPSB3aWR0aCAtIGN1cl9sZW5cXG5cXG4gICAgICAgICMgSWYgd2UncmUgYWxsb3dlZCB0byBicmVhayBsb25nIHdvcmRzLCB0aGVuIGRvIHNvOiBwdXQgYXMgbXVjaFxcbiAgICAgICAgIyBvZiB0aGUgbmV4dCBjaHVuayBvbnRvIHRoZSBjdXJyZW50IGxpbmUgYXMgd2lsbCBmaXQuXFxuICAgICAgICBpZiBzZWxmLmJyZWFrX2xvbmdfd29yZHM6XFxuICAgICAgICAgICAgY3VyX2xpbmUuYXBwZW5kKHJldmVyc2VkX2NodW5rc1stMV1bOnNwYWNlX2xlZnRdKVxcbiAgICAgICAgICAgIHJldmVyc2VkX2NodW5rc1stMV0gPSByZXZlcnNlZF9jaHVua3NbLTFdW3NwYWNlX2xlZnQ6XVxcblxcbiAgICAgICAgIyBPdGhlcndpc2UsIHdlIGhhdmUgdG8gcHJlc2VydmUgdGhlIGxvbmcgd29yZCBpbnRhY3QuICBPbmx5IGFkZFxcbiAgICAgICAgIyBpdCB0byB0aGUgY3VycmVudCBsaW5lIGlmIHRoZXJlJ3Mgbm90aGluZyBhbHJlYWR5IHRoZXJlIC0tXFxuICAgICAgICAjIHRoYXQgbWluaW1pemVzIGhvdyBtdWNoIHdlIHZpb2xhdGUgdGhlIHdpZHRoIGNvbnN0cmFpbnQuXFxuICAgICAgICBlbGlmIG5vdCBjdXJfbGluZTpcXG4gICAgICAgICAgICBjdXJfbGluZS5hcHBlbmQocmV2ZXJzZWRfY2h1bmtzLnBvcCgpKVxcblxcbiAgICAgICAgIyBJZiB3ZSdyZSBub3QgYWxsb3dlZCB0byBicmVhayBsb25nIHdvcmRzLCBhbmQgdGhlcmUncyBhbHJlYWR5XFxuICAgICAgICAjIHRleHQgb24gdGhlIGN1cnJlbnQgbGluZSwgZG8gbm90aGluZy4gIE5leHQgdGltZSB0aHJvdWdoIHRoZVxcbiAgICAgICAgIyBtYWluIGxvb3Agb2YgX3dyYXBfY2h1bmtzKCksIHdlJ2xsIHdpbmQgdXAgaGVyZSBhZ2FpbiwgYnV0XFxuICAgICAgICAjIGN1cl9sZW4gd2lsbCBiZSB6ZXJvLCBzbyB0aGUgbmV4dCBsaW5lIHdpbGwgYmUgZW50aXJlbHlcXG4gICAgICAgICMgZGV2b3RlZCB0byB0aGUgbG9uZyB3b3JkIHRoYXQgd2UgY2FuJ3QgaGFuZGxlIHJpZ2h0IG5vdy5cXG5cXG4gICAgZGVmIF93cmFwX2NodW5rcyhzZWxmLCBjaHVua3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX3dyYXBfY2h1bmtzKGNodW5rcyA6IFtzdHJpbmddKSAtPiBbc3RyaW5nXVxcbiAgICAgICAgV3JhcCBhIHNlcXVlbmNlIG9mIHRleHQgY2h1bmtzIGFuZCByZXR1cm4gYSBsaXN0IG9mIGxpbmVzIG9mXFxuICAgICAgICBsZW5ndGggJ3NlbGYud2lkdGgnIG9yIGxlc3MuICAoSWYgJ2JyZWFrX2xvbmdfd29yZHMnIGlzIGZhbHNlLFxcbiAgICAgICAgc29tZSBsaW5lcyBtYXkgYmUgbG9uZ2VyIHRoYW4gdGhpcy4pICBDaHVua3MgY29ycmVzcG9uZCByb3VnaGx5XFxuICAgICAgICB0byB3b3JkcyBhbmQgdGhlIHdoaXRlc3BhY2UgYmV0d2VlbiB0aGVtOiBlYWNoIGNodW5rIGlzXFxuICAgICAgICBpbmRpdmlzaWJsZSAobW9kdWxvICdicmVha19sb25nX3dvcmRzJyksIGJ1dCBhIGxpbmUgYnJlYWsgY2FuXFxuICAgICAgICBjb21lIGJldHdlZW4gYW55IHR3byBjaHVua3MuICBDaHVua3Mgc2hvdWxkIG5vdCBoYXZlIGludGVybmFsXFxuICAgICAgICB3aGl0ZXNwYWNlOyBpZS4gYSBjaHVuayBpcyBlaXRoZXIgYWxsIHdoaXRlc3BhY2Ugb3IgYSBcXFwid29yZFxcXCIuXFxuICAgICAgICBXaGl0ZXNwYWNlIGNodW5rcyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2ZcXG4gICAgICAgIGxpbmVzLCBidXQgYXBhcnQgZnJvbSB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBsaW5lcyA9IFtdXFxuICAgICAgICBpZiBzZWxmLndpZHRoIDw9IDA6XFxuICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiaW52YWxpZCB3aWR0aCAlciAobXVzdCBiZSA+IDApXFxcIiAlIHNlbGYud2lkdGgpXFxuICAgICAgICBpZiBzZWxmLm1heF9saW5lcyBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICBpZiBzZWxmLm1heF9saW5lcyA+IDE6XFxuICAgICAgICAgICAgICAgIGluZGVudCA9IHNlbGYuc3Vic2VxdWVudF9pbmRlbnRcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBzZWxmLmluaXRpYWxfaW5kZW50XFxuICAgICAgICAgICAgaWYgbGVuKGluZGVudCkgKyBsZW4oc2VsZi5wbGFjZWhvbGRlci5sc3RyaXAoKSkgPiBzZWxmLndpZHRoOlxcbiAgICAgICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJwbGFjZWhvbGRlciB0b28gbGFyZ2UgZm9yIG1heCB3aWR0aFxcXCIpXFxuXFxuICAgICAgICAjIEFycmFuZ2UgaW4gcmV2ZXJzZSBvcmRlciBzbyBpdGVtcyBjYW4gYmUgZWZmaWNpZW50bHkgcG9wcGVkXFxuICAgICAgICAjIGZyb20gYSBzdGFjayBvZiBjaHVja3MuXFxuICAgICAgICBjaHVua3MucmV2ZXJzZSgpXFxuXFxuICAgICAgICB3aGlsZSBjaHVua3M6XFxuXFxuICAgICAgICAgICAgIyBTdGFydCB0aGUgbGlzdCBvZiBjaHVua3MgdGhhdCB3aWxsIG1ha2UgdXAgdGhlIGN1cnJlbnQgbGluZS5cXG4gICAgICAgICAgICAjIGN1cl9sZW4gaXMganVzdCB0aGUgbGVuZ3RoIG9mIGFsbCB0aGUgY2h1bmtzIGluIGN1cl9saW5lLlxcbiAgICAgICAgICAgIGN1cl9saW5lID0gW11cXG4gICAgICAgICAgICBjdXJfbGVuID0gMFxcblxcbiAgICAgICAgICAgICMgRmlndXJlIG91dCB3aGljaCBzdGF0aWMgc3RyaW5nIHdpbGwgcHJlZml4IHRoaXMgbGluZS5cXG4gICAgICAgICAgICBpZiBsaW5lczpcXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc2VsZi5zdWJzZXF1ZW50X2luZGVudFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGluZGVudCA9IHNlbGYuaW5pdGlhbF9pbmRlbnRcXG5cXG4gICAgICAgICAgICAjIE1heGltdW0gd2lkdGggZm9yIHRoaXMgbGluZS5cXG4gICAgICAgICAgICB3aWR0aCA9IHNlbGYud2lkdGggLSBsZW4oaW5kZW50KVxcblxcbiAgICAgICAgICAgICMgRmlyc3QgY2h1bmsgb24gbGluZSBpcyB3aGl0ZXNwYWNlIC0tIGRyb3AgaXQsIHVubGVzcyB0aGlzXFxuICAgICAgICAgICAgIyBpcyB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRleHQgKGllLiBubyBsaW5lcyBzdGFydGVkIHlldCkuXFxuICAgICAgICAgICAgaWYgc2VsZi5kcm9wX3doaXRlc3BhY2UgYW5kIGNodW5rc1stMV0uc3RyaXAoKSA9PSAnJyBhbmQgbGluZXM6XFxuICAgICAgICAgICAgICAgIGRlbCBjaHVua3NbLTFdXFxuXFxuICAgICAgICAgICAgd2hpbGUgY2h1bmtzOlxcbiAgICAgICAgICAgICAgICBsID0gbGVuKGNodW5rc1stMV0pXFxuXFxuICAgICAgICAgICAgICAgICMgQ2FuIGF0IGxlYXN0IHNxdWVlemUgdGhpcyBjaHVuayBvbnRvIHRoZSBjdXJyZW50IGxpbmUuXFxuICAgICAgICAgICAgICAgIGlmIGN1cl9sZW4gKyBsIDw9IHdpZHRoOlxcbiAgICAgICAgICAgICAgICAgICAgY3VyX2xpbmUuYXBwZW5kKGNodW5rcy5wb3AoKSlcXG4gICAgICAgICAgICAgICAgICAgIGN1cl9sZW4gKz0gbFxcblxcbiAgICAgICAgICAgICAgICAjIE5vcGUsIHRoaXMgbGluZSBpcyBmdWxsLlxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG5cXG4gICAgICAgICAgICAjIFRoZSBjdXJyZW50IGxpbmUgaXMgZnVsbCwgYW5kIHRoZSBuZXh0IGNodW5rIGlzIHRvbyBiaWcgdG9cXG4gICAgICAgICAgICAjIGZpdCBvbiAqYW55KiBsaW5lIChub3QganVzdCB0aGlzIG9uZSkuXFxuICAgICAgICAgICAgaWYgY2h1bmtzIGFuZCBsZW4oY2h1bmtzWy0xXSkgPiB3aWR0aDpcXG4gICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlX2xvbmdfd29yZChjaHVua3MsIGN1cl9saW5lLCBjdXJfbGVuLCB3aWR0aClcXG4gICAgICAgICAgICAgICAgY3VyX2xlbiA9IHN1bShtYXAobGVuLCBjdXJfbGluZSkpXFxuXFxuICAgICAgICAgICAgIyBJZiB0aGUgbGFzdCBjaHVuayBvbiB0aGlzIGxpbmUgaXMgYWxsIHdoaXRlc3BhY2UsIGRyb3AgaXQuXFxuICAgICAgICAgICAgaWYgc2VsZi5kcm9wX3doaXRlc3BhY2UgYW5kIGN1cl9saW5lIGFuZCBjdXJfbGluZVstMV0uc3RyaXAoKSA9PSAnJzpcXG4gICAgICAgICAgICAgICAgY3VyX2xlbiAtPSBsZW4oY3VyX2xpbmVbLTFdKVxcbiAgICAgICAgICAgICAgICBkZWwgY3VyX2xpbmVbLTFdXFxuXFxuICAgICAgICAgICAgaWYgY3VyX2xpbmU6XFxuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1heF9saW5lcyBpcyBOb25lIG9yXFxuICAgICAgICAgICAgICAgICAgICBsZW4obGluZXMpICsgMSA8IHNlbGYubWF4X2xpbmVzIG9yXFxuICAgICAgICAgICAgICAgICAgICAobm90IGNodW5rcyBvclxcbiAgICAgICAgICAgICAgICAgICAgIHNlbGYuZHJvcF93aGl0ZXNwYWNlIGFuZFxcbiAgICAgICAgICAgICAgICAgICAgIGxlbihjaHVua3MpID09IDEgYW5kXFxuICAgICAgICAgICAgICAgICAgICAgbm90IGNodW5rc1swXS5zdHJpcCgpKSBhbmQgY3VyX2xlbiA8PSB3aWR0aCk6XFxuICAgICAgICAgICAgICAgICAgICAjIENvbnZlcnQgY3VycmVudCBsaW5lIGJhY2sgdG8gYSBzdHJpbmcgYW5kIHN0b3JlIGl0IGluXFxuICAgICAgICAgICAgICAgICAgICAjIGxpc3Qgb2YgYWxsIGxpbmVzIChyZXR1cm4gdmFsdWUpLlxcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kKGluZGVudCArICcnLmpvaW4oY3VyX2xpbmUpKVxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgY3VyX2xpbmU6XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cl9saW5lWy0xXS5zdHJpcCgpIGFuZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGVuICsgbGVuKHNlbGYucGxhY2Vob2xkZXIpIDw9IHdpZHRoKTpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyX2xpbmUuYXBwZW5kKHNlbGYucGxhY2Vob2xkZXIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZChpbmRlbnQgKyAnJy5qb2luKGN1cl9saW5lKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGVuIC09IGxlbihjdXJfbGluZVstMV0pXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsIGN1cl9saW5lWy0xXVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBsaW5lczpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9saW5lID0gbGluZXNbLTFdLnJzdHJpcCgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4ocHJldl9saW5lKSArIGxlbihzZWxmLnBsYWNlaG9sZGVyKSA8PVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYud2lkdGgpOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbLTFdID0gcHJldl9saW5lICsgc2VsZi5wbGFjZWhvbGRlclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmQoaW5kZW50ICsgc2VsZi5wbGFjZWhvbGRlci5sc3RyaXAoKSlcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuXFxuICAgICAgICByZXR1cm4gbGluZXNcXG5cXG4gICAgZGVmIF9zcGxpdF9jaHVua3Moc2VsZiwgdGV4dCk6XFxuICAgICAgICB0ZXh0ID0gc2VsZi5fbXVuZ2Vfd2hpdGVzcGFjZSh0ZXh0KVxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NwbGl0KHRleHQpXFxuXFxuICAgICMgLS0gUHVibGljIGludGVyZmFjZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIGRlZiB3cmFwKHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwid3JhcCh0ZXh0IDogc3RyaW5nKSAtPiBbc3RyaW5nXVxcbiAgICAgICAgUmVmb3JtYXQgdGhlIHNpbmdsZSBwYXJhZ3JhcGggaW4gJ3RleHQnIHNvIGl0IGZpdHMgaW4gbGluZXMgb2ZcXG4gICAgICAgIG5vIG1vcmUgdGhhbiAnc2VsZi53aWR0aCcgY29sdW1ucywgYW5kIHJldHVybiBhIGxpc3Qgb2Ygd3JhcHBlZFxcbiAgICAgICAgbGluZXMuICBUYWJzIGluICd0ZXh0JyBhcmUgZXhwYW5kZWQgd2l0aCBzdHJpbmcuZXhwYW5kdGFicygpLFxcbiAgICAgICAgYW5kIGFsbCBvdGhlciB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgKGluY2x1ZGluZyBuZXdsaW5lKSBhcmVcXG4gICAgICAgIGNvbnZlcnRlZCB0byBzcGFjZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgY2h1bmtzID0gc2VsZi5fc3BsaXRfY2h1bmtzKHRleHQpXFxuICAgICAgICBpZiBzZWxmLmZpeF9zZW50ZW5jZV9lbmRpbmdzOlxcbiAgICAgICAgICAgIHNlbGYuX2ZpeF9zZW50ZW5jZV9lbmRpbmdzKGNodW5rcylcXG4gICAgICAgIHJldHVybiBzZWxmLl93cmFwX2NodW5rcyhjaHVua3MpXFxuXFxuICAgIGRlZiBmaWxsKHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiZmlsbCh0ZXh0IDogc3RyaW5nKSAtPiBzdHJpbmdcXG4gICAgICAgIFJlZm9ybWF0IHRoZSBzaW5nbGUgcGFyYWdyYXBoIGluICd0ZXh0JyB0byBmaXQgaW4gbGluZXMgb2Ygbm9cXG4gICAgICAgIG1vcmUgdGhhbiAnc2VsZi53aWR0aCcgY29sdW1ucywgYW5kIHJldHVybiBhIG5ldyBzdHJpbmdcXG4gICAgICAgIGNvbnRhaW5pbmcgdGhlIGVudGlyZSB3cmFwcGVkIHBhcmFncmFwaC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIFxcXCJcXFxcblxcXCIuam9pbihzZWxmLndyYXAodGV4dCkpXFxuXFxuXFxuIyAtLSBDb252ZW5pZW5jZSBpbnRlcmZhY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuZGVmIHdyYXAodGV4dCwgd2lkdGg9NzAsICoqa3dhcmdzKTpcXG4gICAgXFxcIlxcXCJcXFwiV3JhcCBhIHNpbmdsZSBwYXJhZ3JhcGggb2YgdGV4dCwgcmV0dXJuaW5nIGEgbGlzdCBvZiB3cmFwcGVkIGxpbmVzLlxcbiAgICBSZWZvcm1hdCB0aGUgc2luZ2xlIHBhcmFncmFwaCBpbiAndGV4dCcgc28gaXQgZml0cyBpbiBsaW5lcyBvZiBub1xcbiAgICBtb3JlIHRoYW4gJ3dpZHRoJyBjb2x1bW5zLCBhbmQgcmV0dXJuIGEgbGlzdCBvZiB3cmFwcGVkIGxpbmVzLiAgQnlcXG4gICAgZGVmYXVsdCwgdGFicyBpbiAndGV4dCcgYXJlIGV4cGFuZGVkIHdpdGggc3RyaW5nLmV4cGFuZHRhYnMoKSwgYW5kXFxuICAgIGFsbCBvdGhlciB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgKGluY2x1ZGluZyBuZXdsaW5lKSBhcmUgY29udmVydGVkIHRvXFxuICAgIHNwYWNlLiAgU2VlIFRleHRXcmFwcGVyIGNsYXNzIGZvciBhdmFpbGFibGUga2V5d29yZCBhcmdzIHRvIGN1c3RvbWl6ZVxcbiAgICB3cmFwcGluZyBiZWhhdmlvdXIuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICB3ID0gVGV4dFdyYXBwZXIod2lkdGg9d2lkdGgsICoqa3dhcmdzKVxcbiAgICByZXR1cm4gdy53cmFwKHRleHQpXFxuXFxuZGVmIGZpbGwodGV4dCwgd2lkdGg9NzAsICoqa3dhcmdzKTpcXG4gICAgXFxcIlxcXCJcXFwiRmlsbCBhIHNpbmdsZSBwYXJhZ3JhcGggb2YgdGV4dCwgcmV0dXJuaW5nIGEgbmV3IHN0cmluZy5cXG4gICAgUmVmb3JtYXQgdGhlIHNpbmdsZSBwYXJhZ3JhcGggaW4gJ3RleHQnIHRvIGZpdCBpbiBsaW5lcyBvZiBubyBtb3JlXFxuICAgIHRoYW4gJ3dpZHRoJyBjb2x1bW5zLCBhbmQgcmV0dXJuIGEgbmV3IHN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpcmVcXG4gICAgd3JhcHBlZCBwYXJhZ3JhcGguICBBcyB3aXRoIHdyYXAoKSwgdGFicyBhcmUgZXhwYW5kZWQgYW5kIG90aGVyXFxuICAgIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBjb252ZXJ0ZWQgdG8gc3BhY2UuICBTZWUgVGV4dFdyYXBwZXIgY2xhc3MgZm9yXFxuICAgIGF2YWlsYWJsZSBrZXl3b3JkIGFyZ3MgdG8gY3VzdG9taXplIHdyYXBwaW5nIGJlaGF2aW91ci5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIHcgPSBUZXh0V3JhcHBlcih3aWR0aD13aWR0aCwgKiprd2FyZ3MpXFxuICAgIHJldHVybiB3LmZpbGwodGV4dClcXG5cXG5kZWYgc2hvcnRlbih0ZXh0LCB3aWR0aCwgKiprd2FyZ3MpOlxcbiAgICBcXFwiXFxcIlxcXCJDb2xsYXBzZSBhbmQgdHJ1bmNhdGUgdGhlIGdpdmVuIHRleHQgdG8gZml0IGluIHRoZSBnaXZlbiB3aWR0aC5cXG4gICAgVGhlIHRleHQgZmlyc3QgaGFzIGl0cyB3aGl0ZXNwYWNlIGNvbGxhcHNlZC4gIElmIGl0IHRoZW4gZml0cyBpblxcbiAgICB0aGUgKndpZHRoKiwgaXQgaXMgcmV0dXJuZWQgYXMgaXMuICBPdGhlcndpc2UsIGFzIG1hbnkgd29yZHNcXG4gICAgYXMgcG9zc2libGUgYXJlIGpvaW5lZCBhbmQgdGhlbiB0aGUgcGxhY2Vob2xkZXIgaXMgYXBwZW5kZWQ6OlxcbiAgICAgICAgPj4+IHRleHR3cmFwLnNob3J0ZW4oXFxcIkhlbGxvICB3b3JsZCFcXFwiLCB3aWR0aD0xMilcXG4gICAgICAgICdIZWxsbyB3b3JsZCEnXFxuICAgICAgICA+Pj4gdGV4dHdyYXAuc2hvcnRlbihcXFwiSGVsbG8gIHdvcmxkIVxcXCIsIHdpZHRoPTExKVxcbiAgICAgICAgJ0hlbGxvIFsuLi5dJ1xcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgdyA9IFRleHRXcmFwcGVyKHdpZHRoPXdpZHRoLCBtYXhfbGluZXM9MSwgKiprd2FyZ3MpXFxuICAgIHJldHVybiB3LmZpbGwoJyAnLmpvaW4odGV4dC5zdHJpcCgpLnNwbGl0KCkpKVxcblxcblxcbiMgLS0gTG9vc2VseSByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiMgX3doaXRlc3BhY2Vfb25seV9yZSA9IHJlLmNvbXBpbGUoJ15bIFxcXFx0XSskJywgcmUuTVVMVElMSU5FKVxcbiMgX2xlYWRpbmdfd2hpdGVzcGFjZV9yZSA9IHJlLmNvbXBpbGUoJyheWyBcXFxcdF0qKSg/OlteIFxcXFx0XFxcXG5dKScsIHJlLk1VTFRJTElORSlcXG5cXG5kZWYgZGVkZW50KHRleHQpOlxcbiAgICBcXFwiXFxcIlxcXCJSZW1vdmUgYW55IGNvbW1vbiBsZWFkaW5nIHdoaXRlc3BhY2UgZnJvbSBldmVyeSBsaW5lIGluIGB0ZXh0YC5cXG4gICAgVGhpcyBjYW4gYmUgdXNlZCB0byBtYWtlIHRyaXBsZS1xdW90ZWQgc3RyaW5ncyBsaW5lIHVwIHdpdGggdGhlIGxlZnRcXG4gICAgZWRnZSBvZiB0aGUgZGlzcGxheSwgd2hpbGUgc3RpbGwgcHJlc2VudGluZyB0aGVtIGluIHRoZSBzb3VyY2UgY29kZVxcbiAgICBpbiBpbmRlbnRlZCBmb3JtLlxcbiAgICBOb3RlIHRoYXQgdGFicyBhbmQgc3BhY2VzIGFyZSBib3RoIHRyZWF0ZWQgYXMgd2hpdGVzcGFjZSwgYnV0IHRoZXlcXG4gICAgYXJlIG5vdCBlcXVhbDogdGhlIGxpbmVzIFxcXCIgIGhlbGxvXFxcIiBhbmQgXFxcIlxcXFxcXFxcdGhlbGxvXFxcIiBhcmVcXG4gICAgY29uc2lkZXJlZCB0byBoYXZlIG5vIGNvbW1vbiBsZWFkaW5nIHdoaXRlc3BhY2UuXFxuICAgIEVudGlyZWx5IGJsYW5rIGxpbmVzIGFyZSBub3JtYWxpemVkIHRvIGEgbmV3bGluZSBjaGFyYWN0ZXIuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICAjIExvb2sgZm9yIHRoZSBsb25nZXN0IGxlYWRpbmcgc3RyaW5nIG9mIHNwYWNlcyBhbmQgdGFicyBjb21tb24gdG9cXG4gICAgIyBhbGwgbGluZXMuXFxuICAgIG1hcmdpbiA9IE5vbmVcXG5cXG4gICAgaW5kZW50cyA9IHJlLmZpbmRhbGwocicoXlsgXFxcXHRdKikoPzpbXiBcXFxcdFxcXFxuXSknLHRleHQsIHJlLk1VTFRJTElORSlcXG4gICAgZm9yIGluZGVudCBpbiBpbmRlbnRzOlxcbiAgICAgICAgaWYgbWFyZ2luIGlzIE5vbmU6XFxuICAgICAgICAgICAgbWFyZ2luID0gaW5kZW50XFxuXFxuICAgICAgICAjIEN1cnJlbnQgbGluZSBtb3JlIGRlZXBseSBpbmRlbnRlZCB0aGFuIHByZXZpb3VzIHdpbm5lcjpcXG4gICAgICAgICMgbm8gY2hhbmdlIChwcmV2aW91cyB3aW5uZXIgaXMgc3RpbGwgb24gdG9wKS5cXG4gICAgICAgIGVsaWYgaW5kZW50LnN0YXJ0c3dpdGgobWFyZ2luKTpcXG4gICAgICAgICAgICBwYXNzXFxuXFxuICAgICAgICAjIEN1cnJlbnQgbGluZSBjb25zaXN0ZW50IHdpdGggYW5kIG5vIGRlZXBlciB0aGFuIHByZXZpb3VzIHdpbm5lcjpcXG4gICAgICAgICMgaXQncyB0aGUgbmV3IHdpbm5lci5cXG4gICAgICAgIGVsaWYgbWFyZ2luLnN0YXJ0c3dpdGgoaW5kZW50KTpcXG4gICAgICAgICAgICBtYXJnaW4gPSBpbmRlbnRcXG5cXG4gICAgICAgICMgRmluZCB0aGUgbGFyZ2VzdCBjb21tb24gd2hpdGVzcGFjZSBiZXR3ZWVuIGN1cnJlbnQgbGluZSBhbmQgcHJldmlvdXNcXG4gICAgICAgICMgd2lubmVyLlxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBmb3IgaSwgKHgsIHkpIGluIGVudW1lcmF0ZSh6aXAobWFyZ2luLCBpbmRlbnQpKTpcXG4gICAgICAgICAgICAgICAgaWYgeCAhPSB5OlxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gbWFyZ2luWzppXVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgIyBzYW5pdHkgY2hlY2sgKHRlc3RpbmcvZGVidWdnaW5nIG9ubHkpXFxuICAgIGlmIDAgYW5kIG1hcmdpbjpcXG4gICAgICAgIGZvciBsaW5lIGluIHRleHQuc3BsaXQoXFxcIlxcXFxuXFxcIik6XFxuICAgICAgICAgICAgYXNzZXJ0IG5vdCBsaW5lIG9yIGxpbmUuc3RhcnRzd2l0aChtYXJnaW4pLCBcXFxcXFxuICAgICAgICAgICAgICAgICAgIFxcXCJsaW5lID0gJXIsIG1hcmdpbiA9ICVyXFxcIiAlIChsaW5lLCBtYXJnaW4pXFxuXFxuICAgIGlmIG1hcmdpbjpcXG4gICAgICAgIGxpbmVzID0gW2xpbmVbbGVuKG1hcmdpbik6XSBcXG4gICAgICAgICAgICAgICAgICAgIGlmIGxpbmUuc3RyaXAoKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgbGluZS5zdHJpcCgpIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgbGluZSBpbiB0ZXh0LnNwbGl0KFxcXCJcXFxcblxcXCIpXVxcbiAgICAgICAgdGV4dCA9IFxcXCJcXFxcblxcXCIuam9pbihsaW5lcylcXG4gICAgcmV0dXJuIHRleHRcXG5cXG5cXG5kZWYgaW5kZW50KHRleHQsIHByZWZpeCwgcHJlZGljYXRlPU5vbmUpOlxcbiAgICBcXFwiXFxcIlxcXCJBZGRzICdwcmVmaXgnIHRvIHRoZSBiZWdpbm5pbmcgb2Ygc2VsZWN0ZWQgbGluZXMgaW4gJ3RleHQnLlxcbiAgICBJZiAncHJlZGljYXRlJyBpcyBwcm92aWRlZCwgJ3ByZWZpeCcgd2lsbCBvbmx5IGJlIGFkZGVkIHRvIHRoZSBsaW5lc1xcbiAgICB3aGVyZSAncHJlZGljYXRlKGxpbmUpJyBpcyBUcnVlLiBJZiAncHJlZGljYXRlJyBpcyBub3QgcHJvdmlkZWQsXFxuICAgIGl0IHdpbGwgZGVmYXVsdCB0byBhZGRpbmcgJ3ByZWZpeCcgdG8gYWxsIG5vbi1lbXB0eSBsaW5lcyB0aGF0IGRvIG5vdFxcbiAgICBjb25zaXN0IHNvbGVseSBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBpZiBwcmVkaWNhdGUgaXMgTm9uZTpcXG4gICAgICAgIGRlZiBwcmVkaWNhdGUobGluZSk6XFxuICAgICAgICAgICAgcmV0dXJuIGxpbmUuc3RyaXAoKVxcblxcbiAgICBkZWYgcHJlZml4ZWRfbGluZXMoKTpcXG4gICAgICAgIGZvciBsaW5lIGluIHRleHQuc3BsaXRsaW5lcyhUcnVlKTpcXG4gICAgICAgICAgICB5aWVsZCAocHJlZml4ICsgbGluZSBpZiBwcmVkaWNhdGUobGluZSkgZWxzZSBsaW5lKVxcbiAgICByZXR1cm4gJycuam9pbihwcmVmaXhlZF9saW5lcygpKVxcblxcblxcbmlmIF9fbmFtZV9fID09IFxcXCJfX21haW5fX1xcXCI6XFxuICAgICNwcmludCBkZWRlbnQoXFxcIlxcXFx0Zm9vXFxcXG5cXFxcdGJhclxcXCIpXFxuICAgICNwcmludCBkZWRlbnQoXFxcIiAgXFxcXHRoZWxsbyB0aGVyZVxcXFxuICBcXFxcdCAgaG93IGFyZSB5b3U/XFxcIilcXG4gICAgcHJpbnQoZGVkZW50KFxcXCJIZWxsbyB0aGVyZS5cXFxcbiAgVGhpcyBpcyBpbmRlbnRlZC5cXFwiKSlcIixcInNyYy9saWIvdGhpcy5weVwiOlwiXFxucHJpbnQoXFxcIlxcXCJcXFwiXFxuVGhlIFplbiBvZiBQeXRob24sIGJ5IFRpbSBQZXRlcnNcXG5cXG5CZWF1dGlmdWwgaXMgYmV0dGVyIHRoYW4gdWdseS5cXG5FeHBsaWNpdCBpcyBiZXR0ZXIgdGhhbiBpbXBsaWNpdC5cXG5TaW1wbGUgaXMgYmV0dGVyIHRoYW4gY29tcGxleC5cXG5Db21wbGV4IGlzIGJldHRlciB0aGFuIGNvbXBsaWNhdGVkLlxcbkZsYXQgaXMgYmV0dGVyIHRoYW4gbmVzdGVkLlxcblNwYXJzZSBpcyBiZXR0ZXIgdGhhbiBkZW5zZS5cXG5SZWFkYWJpbGl0eSBjb3VudHMuXFxuU3BlY2lhbCBjYXNlcyBhcmVuJ3Qgc3BlY2lhbCBlbm91Z2ggdG8gYnJlYWsgdGhlIHJ1bGVzLlxcbkFsdGhvdWdoIHByYWN0aWNhbGl0eSBiZWF0cyBwdXJpdHkuXFxuRXJyb3JzIHNob3VsZCBuZXZlciBwYXNzIHNpbGVudGx5LlxcblVubGVzcyBleHBsaWNpdGx5IHNpbGVuY2VkLlxcbkluIHRoZSBmYWNlIG9mIGFtYmlndWl0eSwgcmVmdXNlIHRoZSB0ZW1wdGF0aW9uIHRvIGd1ZXNzLlxcblRoZXJlIHNob3VsZCBiZSBvbmUtLSBhbmQgcHJlZmVyYWJseSBvbmx5IG9uZSAtLW9idmlvdXMgd2F5IHRvIGRvIGl0LlxcbkFsdGhvdWdoIHRoYXQgd2F5IG1heSBub3QgYmUgb2J2aW91cyBhdCBmaXJzdCB1bmxlc3MgeW91J3JlIER1dGNoLlxcbk5vdyBpcyBiZXR0ZXIgdGhhbiBuZXZlci5cXG5BbHRob3VnaCBuZXZlciBpcyBvZnRlbiBiZXR0ZXIgdGhhbiAqcmlnaHQqIG5vdy5cXG5JZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgaGFyZCB0byBleHBsYWluLCBpdCdzIGEgYmFkIGlkZWEuXFxuSWYgdGhlIGltcGxlbWVudGF0aW9uIGlzIGVhc3kgdG8gZXhwbGFpbiwgaXQgbWF5IGJlIGEgZ29vZCBpZGVhLlxcbk5hbWVzcGFjZXMgYXJlIG9uZSBob25raW5nIGdyZWF0IGlkZWEgLS0gbGV0J3MgZG8gbW9yZSBvZiB0aG9zZSFcXG5cXFwiXFxcIlxcXCJcXG4gICAgICApXFxuXCIsXCJzcmMvbGliL3RocmVhZGluZy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0aHJlYWRpbmdcXFwiKVxcblwiLFwic3JjL2xpYi90aW1laXQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidGltZWl0XFxcIilcXG5cIixcInNyYy9saWIvdG9haWZmLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRvYWlmZlxcXCIpXFxuXCIsXCJzcmMvbGliL3RyYWNlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRyYWNlXFxcIilcXG5cIixcInNyYy9saWIvdHJhY2ViYWNrLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRyYWNlYmFja1xcXCIpXFxuXCIsXCJzcmMvbGliL3R0eS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0dHlcXFwiKVxcblwiLFwic3JjL2xpYi90eXBlcy5weVwiOlwiXFxcIlxcXCJcXFwiXFxuVGhpcyBmaWxlIHdhcyBtb2RpZmllZCBmcm9tIENQeXRob24uXFxuQ29weXJpZ2h0IChjKSAyMDAxLCAyMDAyLCAyMDAzLCAyMDA0LCAyMDA1LCAyMDA2LCAyMDA3LCAyMDA4LCAyMDA5LCAyMDEwLFxcbjIwMTEsIDIwMTIsIDIwMTMsIDIwMTQsIDIwMTUgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb247IEFsbCBSaWdodHMgUmVzZXJ2ZWRcXG5cXFwiXFxcIlxcXCJcXG5cXFwiXFxcIlxcXCJEZWZpbmUgbmFtZXMgZm9yIGFsbCB0eXBlIHN5bWJvbHMga25vd24gaW4gdGhlIHN0YW5kYXJkIGludGVycHJldGVyLlxcblR5cGVzIHRoYXQgYXJlIHBhcnQgb2Ygb3B0aW9uYWwgbW9kdWxlcyAoZS5nLiBhcnJheSkgYXJlIG5vdCBsaXN0ZWQuXFxuXFxcIlxcXCJcXFwiXFxuaW1wb3J0IHN5c1xcblxcbiMgSXRlcmF0b3JzIGluIFB5dGhvbiBhcmVuJ3QgYSBtYXR0ZXIgb2YgdHlwZSBidXQgb2YgcHJvdG9jb2wuICBBIGxhcmdlXFxuIyBhbmQgY2hhbmdpbmcgbnVtYmVyIG9mIGJ1aWx0aW4gdHlwZXMgaW1wbGVtZW50ICpzb21lKiBmbGF2b3Igb2ZcXG4jIGl0ZXJhdG9yLiAgRG9uJ3QgY2hlY2sgdGhlIHR5cGUhICBVc2UgaGFzYXR0ciB0byBjaGVjayBmb3IgYm90aFxcbiMgXFxcIl9faXRlcl9fXFxcIiBhbmQgXFxcIm5leHRcXFwiIGF0dHJpYnV0ZXMgaW5zdGVhZC5cXG5NYXBwaW5nUHJveHlUeXBlID0gdHlwZSh0eXBlLl9fZGljdF9fKVxcbldyYXBwZXJEZXNjcmlwdG9yVHlwZSA9IHR5cGUob2JqZWN0Ll9faW5pdF9fKVxcbk1ldGhvZFdyYXBwZXJUeXBlID0gdHlwZShvYmplY3QoKS5fX3N0cl9fKVxcbk1ldGhvZERlc2NyaXB0b3JUeXBlID0gdHlwZShzdHIuam9pbilcXG5DbGFzc01ldGhvZERlc2NyaXB0b3JUeXBlID0gdHlwZShkaWN0Ll9fZGljdF9fWydmcm9ta2V5cyddKVxcblxcbk5vbmVUeXBlID0gdHlwZShOb25lKVxcblR5cGVUeXBlID0gdHlwZVxcbk9iamVjdFR5cGUgPSBvYmplY3RcXG5JbnRUeXBlID0gaW50XFxudHJ5OlxcbiAgICBMb25nVHlwZSA9IGxvbmdcXG5leGNlcHQ6IHBhc3NcXG5GbG9hdFR5cGUgPSBmbG9hdFxcbkJvb2xlYW5UeXBlID0gYm9vbFxcbnRyeTpcXG4gICAgQ29tcGxleFR5cGUgPSBjb21wbGV4XFxuZXhjZXB0IE5hbWVFcnJvcjpcXG4gICAgcGFzc1xcblN0cmluZ1R5cGUgPSBzdHJcXG5cXG4jIFN0cmluZ1R5cGVzIGlzIGFscmVhZHkgb3V0ZGF0ZWQuICBJbnN0ZWFkIG9mIHdyaXRpbmcgXFxcInR5cGUoeCkgaW5cXG4jIHR5cGVzLlN0cmluZ1R5cGVzXFxcIiwgeW91IHNob3VsZCB1c2UgXFxcImlzaW5zdGFuY2UoeCwgYmFzZXN0cmluZylcXFwiLiAgQnV0XFxuIyB3ZSBrZWVwIGFyb3VuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFB5dGhvbiAyLjIuXFxudHJ5OlxcbiAgICBVbmljb2RlVHlwZSA9IHVuaWNvZGVcXG4gICAgU3RyaW5nVHlwZXMgPSAoU3RyaW5nVHlwZSwgVW5pY29kZVR5cGUpXFxuZXhjZXB0IE5hbWVFcnJvcjpcXG4gICAgU3RyaW5nVHlwZXMgPSAoU3RyaW5nVHlwZSwpXFxuXFxuQnVmZmVyVHlwZSA9IGJ1ZmZlclxcblxcblR1cGxlVHlwZSA9IHR1cGxlXFxuTGlzdFR5cGUgPSBsaXN0XFxuRGljdFR5cGUgPSBEaWN0aW9uYXJ5VHlwZSA9IGRpY3RcXG5cXG5kZWYgX2YoKTogcGFzc1xcbkZ1bmN0aW9uVHlwZSA9IHR5cGUoX2YpXFxuTGFtYmRhVHlwZSA9IHR5cGUobGFtYmRhOiBOb25lKSAgICAgICAgICMgU2FtZSBhcyBGdW5jdGlvblR5cGVcXG4jQ29kZVR5cGUgPSB0eXBlKF9mLmZ1bmNfY29kZSlcXG5cXG5kZWYgX2coKTpcXG4gICAgeWllbGQgMVxcbkdlbmVyYXRvclR5cGUgPSB0eXBlKF9nKCkpXFxuXFxuY2xhc3MgX0M6XFxuICAgIGRlZiBfbShzZWxmKTogcGFzc1xcbkNsYXNzVHlwZSA9IHR5cGUoX0MpXFxuVW5ib3VuZE1ldGhvZFR5cGUgPSB0eXBlKF9DLl9tKSAgICAgICAgICMgU2FtZSBhcyBNZXRob2RUeXBlXFxuX3ggPSBfQygpXFxuSW5zdGFuY2VUeXBlID0gdHlwZShfeClcXG5NZXRob2RUeXBlID0gdHlwZShfeC5fbSlcXG5CdWlsdGluRnVuY3Rpb25UeXBlID0gdHlwZShsZW4pXFxuQnVpbHRpbk1ldGhvZFR5cGUgPSB0eXBlKFtdLmFwcGVuZCkgICAgICMgU2FtZSBhcyBCdWlsdGluRnVuY3Rpb25UeXBlXFxuXFxuTW9kdWxlVHlwZSA9IHR5cGUoc3lzKVxcbkZpbGVUeXBlID0gZmlsZVxcbnRyeTpcXG4gICAgWFJhbmdlVHlwZSA9IHhyYW5nZVxcbmV4Y2VwdCBOYW1lRXJyb3I6XFxuICAgIHBhc3NcXG5cXG4jIHRyeTpcXG4jICAgICByYWlzZSBUeXBlRXJyb3JcXG4jIGV4Y2VwdCBUeXBlRXJyb3I6XFxuIyAgICAgdGIgPSBzeXMuZXhjX2luZm8oKVsyXVxcbiMgICAgIFRyYWNlYmFja1R5cGUgPSB0eXBlKHRiKVxcbiMgICAgIEZyYW1lVHlwZSA9IHR5cGUodGIudGJfZnJhbWUpXFxuIyAgICAgZGVsIHRiXFxuXFxuU2xpY2VUeXBlID0gc2xpY2VcXG5FbGxpcHNpc1R5cGUgPSB0eXBlKEVsbGlwc2lzKVxcblxcbiMgRGljdFByb3h5VHlwZSA9IHR5cGUoVHlwZVR5cGUuX19kaWN0X18pXFxuTm90SW1wbGVtZW50ZWRUeXBlID0gdHlwZShOb3RJbXBsZW1lbnRlZClcXG5cXG4jIEZvciBKeXRob24sIHRoZSBmb2xsb3dpbmcgdHdvIHR5cGVzIGFyZSBpZGVudGljYWxcXG4jIEdldFNldERlc2NyaXB0b3JUeXBlID0gdHlwZShGdW5jdGlvblR5cGUuZnVuY19jb2RlKVxcbiMgTWVtYmVyRGVzY3JpcHRvclR5cGUgPSB0eXBlKEZ1bmN0aW9uVHlwZS5mdW5jX2dsb2JhbHMpXFxuXFxuZGVsIHN5cywgX2YsIF9nLCBfQywgX3ggICAgICAgICAgICAgICAgICAgICAgICAgICAjIE5vdCBmb3IgZXhwb3J0XFxuX19hbGxfXyA9IGxpc3QobiBmb3IgbiBpbiBnbG9iYWxzKCkgaWYgbls6MV0gIT0gJ18nKVxcblxcbkdlbmVyaWNBbGlhcyA9IHR5cGUodHlwZVtpbnRdKVwiLFwic3JjL2xpYi91bml0dGVzdC9fX2luaXRfXy5weVwiOlwiX19hdXRob3JfXyA9ICdibWlsbGVyJ1xcbicnJ1xcblRoaXMgaXMgdGhlIHN0YXJ0IG9mIHNvbWV0aGluZyB0aGF0IGJlaGF2ZXMgbGlrZVxcbnRoZSB1bml0dGVzdCBtb2R1bGUgZnJvbSBjcHl0aG9uLlxcblxcbicnJ1xcbmltcG9ydCByZVxcblxcbmNsYXNzIF9Bc3NlcnRSYWlzZXNDb250ZXh0KG9iamVjdCk6XFxuICAgIFxcXCJcXFwiXFxcIkEgY29udGV4dCBtYW5hZ2VyIHVzZWQgdG8gaW1wbGVtZW50IFRlc3RDYXNlLmFzc2VydFJhaXNlcyogbWV0aG9kcy5cXFwiXFxcIlxcXCJcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGV4cGVjdGVkLCB0ZXN0X2Nhc2UpOlxcbiAgICAgICAgc2VsZi50ZXN0X2Nhc2UgPSB0ZXN0X2Nhc2VcXG4gICAgICAgIHNlbGYuZXhwZWN0ZWQgPSBleHBlY3RlZFxcbiAgICAgICAgc2VsZi5leGNlcHRpb24gPSBOb25lXFxuXFxuICAgIGRlZiBfaXNfc3VidHlwZShzZWxmLCBleHBlY3RlZCwgYmFzZXR5cGUpOlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShleHBlY3RlZCwgdHVwbGUpOlxcbiAgICAgICAgICAgIHJldHVybiBhbGwoc2VsZi5faXNfc3VidHlwZShlLCBiYXNldHlwZSkgZm9yIGUgaW4gZXhwZWN0ZWQpXFxuICAgICAgICByZXR1cm4gaXNpbnN0YW5jZShleHBlY3RlZCwgdHlwZSkgYW5kIGlzc3ViY2xhc3MoZXhwZWN0ZWQsIGJhc2V0eXBlKVxcblxcbiAgICBkZWYgaGFuZGxlKHNlbGYsIGFyZ3MsIGt3YXJncyk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIElmIGFyZ3MgaXMgZW1wdHksIGFzc2VydFJhaXNlcyBpcyBiZWluZyB1c2VkIGFzIGFcXG4gICAgICAgIGNvbnRleHQgbWFuYWdlciwgc28gcmV0dXJuIHNlbGYuXFxuICAgICAgICBJZiBhcmdzIGlzIG5vdCBlbXB0eSwgY2FsbCBhIGNhbGxhYmxlIHBhc3NpbmcgcG9zaXRpb25hbCBhbmQga2V5d29yZFxcbiAgICAgICAgYXJndW1lbnRzLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAgaWYgbm90IHNlbGYuX2lzX3N1YnR5cGUoc2VsZi5leHBlY3RlZCwgQmFzZUV4Y2VwdGlvbik6XFxuICAgICAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvcignYXNzZXJ0UmFpc2VzKCkgYXJnIDEgbXVzdCBiZSBhbiBleGNlcHRpb24gdHlwZSBvciB0dXBsZSBvZiBleGNlcHRpb24gdHlwZXMnKVxcbiAgICAgICAgICAgIGlmIG5vdCBhcmdzOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICAgICAgICAgIGNhbGxhYmxlX29iaiA9IGFyZ3NbMF1cXG4gICAgICAgICAgICBhcmdzID0gYXJnc1sxOl1cXG4gICAgICAgICAgICB3aXRoIHNlbGY6XFxuICAgICAgICAgICAgICAgIGNhbGxhYmxlX29iaigqYXJncywgKiprd2FyZ3MpIFxcblxcbiAgICAgICAgZmluYWxseTpcXG4gICAgICAgICAgICAjIGJwby0yMzg5MDogbWFudWFsbHkgYnJlYWsgYSByZWZlcmVuY2UgY3ljbGVcXG4gICAgICAgICAgICBzZWxmID0gTm9uZVxcblxcbiAgICBkZWYgX19lbnRlcl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIF9fZXhpdF9fKHNlbGYsIGV4Y190eXBlLCBleGNfdmFsdWUsIHRiKTpcXG4gICAgICAgIHJlcyA9IFRydWVcXG4gICAgICAgIGZlZWRiYWNrID0gXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuZXhjZXB0aW9uID0gZXhjX3ZhbHVlXFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAgYWN0X2V4YyA9IGV4Y190eXBlLl9fbmFtZV9fXFxuICAgICAgICBleGNlcHQgQXR0cmlidXRlRXJyb3I6XFxuICAgICAgICAgICAgYWN0X2V4YyA9IHN0cihleGNfdHlwZSlcXG4gICAgICAgIHRyeTpcXG4gICAgICAgICAgICBleHBfZXhjID0gc2VsZi5leHBlY3RlZC5fX25hbWVfX1xcbiAgICAgICAgZXhjZXB0IEF0dHJpYnV0ZUVycm9yOlxcbiAgICAgICAgICAgIGV4cF9leGMgPSBzdHIoc2VsZi5leHBlY3RlZClcXG5cXG4gICAgICAgIGlmIGV4Y190eXBlIGlzIE5vbmU6XFxuICAgICAgICAgICAgcmVzID0gRmFsc2VcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJ7fSBub3QgcmFpc2VkXFxcIi5mb3JtYXQoZXhwX2V4YylcXG4gICAgICAgIGVsaWYgbm90IGlzc3ViY2xhc3MoZXhjX3R5cGUsIHNlbGYuZXhwZWN0ZWQpOlxcbiAgICAgICAgICAgIHJlcyA9IEZhbHNlXFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQge30gYnV0IGdvdCB7fVxcXCIuZm9ybWF0KGV4cF9leGMsIGFjdF9leGMpXFxuXFxuICAgICAgICBzZWxmLnRlc3RfY2FzZS5hcHBlbmRSZXN1bHQocmVzLCBhY3RfZXhjLCBleHBfZXhjLCBmZWVkYmFjaylcXG4gICAgICAgIHJldHVybiBUcnVlXFxuXFxuXFxuY2xhc3MgVGVzdENhc2Uob2JqZWN0KTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5udW1QYXNzZWQgPSAwXFxuICAgICAgICBzZWxmLm51bUZhaWxlZCA9IDBcXG4gICAgICAgIHNlbGYuYXNzZXJ0UGFzc2VkID0gMFxcbiAgICAgICAgc2VsZi5hc3NlcnRGYWlsZWQgPSAwXFxuICAgICAgICBzZWxmLnZlcmJvc2l0eSA9IDFcXG4gICAgICAgIHNlbGYudGxpc3QgPSBbXVxcbiAgICAgICAgdGVzdE5hbWVzID0ge31cXG4gICAgICAgIGZvciBuYW1lIGluIGRpcihzZWxmKTpcXG4gICAgICAgICAgICBpZiBuYW1lWzo0XSA9PSAndGVzdCcgYW5kIG5hbWUgbm90IGluIHRlc3ROYW1lczpcXG4gICAgICAgICAgICAgICAgc2VsZi50bGlzdC5hcHBlbmQoZ2V0YXR0cihzZWxmLG5hbWUpKVxcbiAgICAgICAgICAgICAgICB0ZXN0TmFtZXNbbmFtZV09VHJ1ZVxcblxcbiAgICBkZWYgc2V0VXAoc2VsZik6XFxuICAgICAgICBwYXNzXFxuXFxuICAgIGRlZiB0ZWFyRG93bihzZWxmKTpcXG4gICAgICAgIHBhc3NcXG4gICAgXFxuICAgIGRlZiBjbGVhbk5hbWUoc2VsZixmdW5jTmFtZSk6XFxuICAgICAgICByZXR1cm4gZnVuY05hbWUuX19mdW5jX18uX19uYW1lX19cXG5cXG4gICAgZGVmIG1haW4oc2VsZik6XFxuXFxuICAgICAgICBmb3IgZnVuYyBpbiBzZWxmLnRsaXN0OlxcbiAgICAgICAgICAgIGlmIHNlbGYudmVyYm9zaXR5ID4gMTpcXG4gICAgICAgICAgICAgICAgcHJpbnQoJ1J1bm5pbmcgJXMnICUgc2VsZi5jbGVhbk5hbWUoZnVuYykpXFxuICAgICAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgICAgICBzZWxmLnNldFVwKClcXG4gICAgICAgICAgICAgICAgc2VsZi5hc3NlcnRQYXNzZWQgPSAwXFxuICAgICAgICAgICAgICAgIHNlbGYuYXNzZXJ0RmFpbGVkID0gMFxcbiAgICAgICAgICAgICAgICBmdW5jKClcXG4gICAgICAgICAgICAgICAgc2VsZi50ZWFyRG93bigpXFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuYXNzZXJ0RmFpbGVkID09IDA6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLm51bVBhc3NlZCArPSAxXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLm51bUZhaWxlZCArPSAxXFxuICAgICAgICAgICAgICAgICAgICBwcmludCgnVGVzdHMgZmFpbGVkIGluICVzICcgJSBzZWxmLmNsZWFuTmFtZShmdW5jKSlcXG4gICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6XFxuICAgICAgICAgICAgICAgIHNlbGYuYXNzZXJ0RmFpbGVkICs9IDFcXG4gICAgICAgICAgICAgICAgc2VsZi5udW1GYWlsZWQgKz0gMVxcbiAgICAgICAgICAgICAgICBwcmludCgnVGVzdCB0aHJldyBleGNlcHRpb24gaW4gJXMgKCVzKScgJSAoc2VsZi5jbGVhbk5hbWUoZnVuYyksIGUpKVxcbiAgICAgICAgc2VsZi5zaG93U3VtbWFyeSgpXFxuXFxuICAgIGRlZiBhc3NlcnRFcXVhbChzZWxmLCBhY3R1YWwsIGV4cGVjdGVkLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhY3R1YWw9PWV4cGVjdGVkXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBlcXVhbCAlc1xcXCIgJSAoc3RyKGFjdHVhbCksc3RyKGV4cGVjdGVkKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYWN0dWFsICxleHBlY3RlZCwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnROb3RFcXVhbChzZWxmLCBhY3R1YWwsIGV4cGVjdGVkLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhY3R1YWwgIT0gZXhwZWN0ZWRcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIG5vdCBlcXVhbCAlc1xcXCIgJSAoc3RyKGFjdHVhbCksc3RyKGV4cGVjdGVkKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYWN0dWFsLCBleHBlY3RlZCwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRUcnVlKHNlbGYseCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYm9vbCh4KSBpcyBUcnVlXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBiZSBUcnVlXFxcIiAlIChzdHIoeCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIHgsIFRydWUsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0RmFsc2Uoc2VsZix4LCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBub3QgYm9vbCh4KVxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgRmFsc2VcXFwiICUgKHN0cih4KSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgeCwgRmFsc2UsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0SXMoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGEgaXMgYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgdGhlIHNhbWUgb2JqZWN0IGFzICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydElzTm90KHNlbGYsYSxiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhIGlzIG5vdCBiXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBub3QgYmUgdGhlIHNhbWUgb2JqZWN0IGFzICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydElzTm9uZShzZWxmLHgsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IHggaXMgTm9uZVxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgTm9uZVxcXCIgJSAoc3RyKHgpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCB4LCBOb25lLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydElzTm90Tm9uZShzZWxmLHgsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IHggaXMgbm90IE5vbmVcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIG5vdCBiZSBOb25lXFxcIiAlIChzdHIoeCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIHgsIE5vbmUsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0SW4oc2VsZiwgYSwgYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSBpbiBiXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBiZSBpbiAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnROb3RJbihzZWxmLCBhLCBiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhIG5vdCBpbiBiXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBub3QgYmUgaW4gJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0SXNJbnN0YW5jZShzZWxmLGEsYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gaXNpbnN0YW5jZShhLGIpXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBiZSBhbiBpbnN0YW5jZSBvZiAlc1xcXCIgJSAoc3RyKGEpLCBzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0Tm90SXNJbnN0YW5jZShzZWxmLGEsYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gbm90IGlzaW5zdGFuY2UoYSxiKVxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydFJlZ2V4KHNlbGYsIHRleHQsIGV4cGVjdGVkX3JlZ2V4LCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJGYWlsIHRoZSB0ZXN0IHVubGVzcyB0aGUgdGV4dCBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBpc2luc3RhbmNlKGV4cGVjdGVkX3JlZ2V4LCAoc3RyLCApKTogI2J5dGVzXFxuICAgICAgICAgICAgYXNzZXJ0IGV4cGVjdGVkX3JlZ2V4LCBcXFwiZXhwZWN0ZWRfcmVnZXggbXVzdCBub3QgYmUgZW1wdHkuXFxcIlxcbiAgICAgICAgICAgIGV4cGVjdGVkX3JlZ2V4ID0gcmUuY29tcGlsZShleHBlY3RlZF9yZWdleClcXG4gICAgICAgIGlmIG5vdCBleHBlY3RlZF9yZWdleC5zZWFyY2godGV4dCk6XFxuICAgICAgICAgICAgcmVzID0gRmFsc2VcXG4gICAgICAgICAgICBpZiBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiUmVnZXggZGlkbid0IG1hdGNoOiAlciBub3QgZm91bmQgaW4gJXJcXFwiICUgKFxcbiAgICAgICAgICAgICAgICAgICAgcmVwcihleHBlY3RlZF9yZWdleCksIHRleHQpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJlcyA9IFRydWVcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgdGV4dCwgZXhwZWN0ZWRfcmVnZXgsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0Tm90UmVnZXgoc2VsZiwgdGV4dCwgdW5leHBlY3RlZF9yZWdleCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmFpbCB0aGUgdGVzdCBpZiB0aGUgdGV4dCBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBpc2luc3RhbmNlKHVuZXhwZWN0ZWRfcmVnZXgsIChzdHIsICkpOiAjIGJ5dGVzXFxuICAgICAgICAgICAgdW5leHBlY3RlZF9yZWdleCA9IHJlLmNvbXBpbGUodW5leHBlY3RlZF9yZWdleClcXG4gICAgICAgIG1hdGNoID0gdW5leHBlY3RlZF9yZWdleC5zZWFyY2godGV4dClcXG4gICAgICAgIGlmIG1hdGNoOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gJ1JlZ2V4IG1hdGNoZWQ6ICVyIG1hdGNoZXMgJXIgaW4gJXInICUgKFxcbiAgICAgICAgICAgICAgICB0ZXh0W21hdGNoLnN0YXJ0KCkgOiBtYXRjaC5lbmQoKV0sXFxuICAgICAgICAgICAgICAgIHJlcHIodW5leHBlY3RlZF9yZWdleCksXFxuICAgICAgICAgICAgICAgIHRleHQpXFxuICAgICAgICAgICAgIyBfZm9ybWF0TWVzc2FnZSBlbnN1cmVzIHRoZSBsb25nTWVzc2FnZSBvcHRpb24gaXMgcmVzcGVjdGVkXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChub3QgYm9vbChtYXRjaCksIHRleHQsIHVuZXhwZWN0ZWRfcmVnZXgsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0QWxtb3N0RXF1YWwoc2VsZiwgYSwgYiwgcGxhY2VzPTcsIGZlZWRiYWNrPVxcXCJcXFwiLCBkZWx0YT1Ob25lKTpcXG5cXG4gICAgICAgIGlmIGRlbHRhIGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgIHJlcyA9IGFicyhhLWIpIDw9IGRlbHRhXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHBsYWNlcyBpcyBOb25lOlxcbiAgICAgICAgICAgICAgICBwbGFjZXMgPSA3XFxuICAgICAgICAgICAgcmVzID0gcm91bmQoYS1iLCBwbGFjZXMpID09IDBcXG4gICAgICAgIFxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gZXF1YWwgJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0Tm90QWxtb3N0RXF1YWwoc2VsZiwgYSwgYiwgcGxhY2VzPTcsIGZlZWRiYWNrPVxcXCJcXFwiLCBkZWx0YT1Ob25lKTpcXG5cXG4gICAgICAgIGlmIGRlbHRhIGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgIHJlcyA9IG5vdCAoYSA9PSBiKSBhbmQgYWJzKGEgLSBiKSA+IGRlbHRhXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHBsYWNlcyBpcyBOb25lOlxcbiAgICAgICAgICAgICAgICBwbGFjZXMgPSA3XFxuXFxuICAgICAgICAgICAgcmVzID0gcm91bmQoYS1iLCBwbGFjZXMpICE9IDBcXG5cXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIG5vdCBlcXVhbCAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRHcmVhdGVyKHNlbGYsYSxiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhID4gYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgZ3JlYXRlciB0aGFuICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydEdyZWF0ZXJFcXVhbChzZWxmLGEsYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSA+PSBiXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBiZSA+PSAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRMZXNzKHNlbGYsIGEsIGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGEgPCBiXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBiZSBsZXNzIHRoYW4gJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0TGVzc0VxdWFsKHNlbGYsYSxiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhIDw9IGJcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIDw9ICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFwcGVuZFJlc3VsdChzZWxmLHJlcyxhY3R1YWwsZXhwZWN0ZWQsZmVlZGJhY2spOlxcbiAgICAgICAgaWYgcmVzOlxcbiAgICAgICAgICAgIG1zZyA9ICdQYXNzJ1xcbiAgICAgICAgICAgIHNlbGYuYXNzZXJ0UGFzc2VkICs9IDFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbXNnID0gJ0ZhaWw6ICcgKyAgZmVlZGJhY2tcXG4gICAgICAgICAgICBwcmludChtc2cpXFxuICAgICAgICAgICAgc2VsZi5hc3NlcnRGYWlsZWQgKz0gMVxcblxcbiAgICBkZWYgYXNzZXJ0UmFpc2VzKHNlbGYsIGV4cGVjdGVkX2V4Y2VwdGlvbiwgKmFyZ3MsICoqa3dhcmdzKTpcXG4gICAgICAgIGNvbnRleHQgPSBfQXNzZXJ0UmFpc2VzQ29udGV4dChleHBlY3RlZF9leGNlcHRpb24sIHNlbGYpXFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuaGFuZGxlKGFyZ3MsIGt3YXJncylcXG4gICAgICAgIGZpbmFsbHk6XFxuICAgICAgICAgICAgIyBicG8tMjM4OTA6IG1hbnVhbGx5IGJyZWFrIGEgcmVmZXJlbmNlIGN5Y2xlXFxuICAgICAgICAgICAgY29udGV4dCA9IE5vbmVcXG5cXG4gICAgZGVmIGZhaWwoc2VsZiwgbXNnPU5vbmUpOlxcbiAgICAgICAgaWYgbXNnIGlzIE5vbmU6XFxuICAgICAgICAgICAgbXNnID0gJ0ZhaWwnXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIG1zZyA9ICdGYWlsOiAnICsgbXNnXFxuICAgICAgICBwcmludChtc2cpXFxuICAgICAgICBzZWxmLmFzc2VydEZhaWxlZCArPSAxXFxuXFxuICAgIGRlZiBzaG93U3VtbWFyeShzZWxmKTpcXG4gICAgICAgICMgZG9uJ3QgZGl2ZGUgYnkgemVyb1xcbiAgICAgICAgIyBwY3QgPSBzZWxmLm51bVBhc3NlZCAvIChzZWxmLm51bVBhc3NlZCtzZWxmLm51bUZhaWxlZCkgKiAxMDBcXG4gICAgICAgIHByaW50KFxcXCJSYW4gJWQgdGVzdHMsIHBhc3NlZDogJWQgZmFpbGVkOiAlZFxcXFxuXFxcIiAlIChzZWxmLm51bVBhc3NlZCtzZWxmLm51bUZhaWxlZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubnVtUGFzc2VkLCBzZWxmLm51bUZhaWxlZCkpXFxuXFxuXFxuXFxuZGVmIG1haW4odmVyYm9zaXR5PTEpOlxcbiAgICBnbG9iID0gZ2xvYmFscygpICMgZ2xvYmFscygpIHN0aWxsIG5lZWRzIHdvcmtcXG4gICAgZm9yIG5hbWUgaW4gZ2xvYjpcXG4gICAgICAgIGlmIHR5cGUoZ2xvYltuYW1lXSkgPT0gdHlwZSBhbmQgaXNzdWJjbGFzcyhnbG9iW25hbWVdLCBUZXN0Q2FzZSk6XFxuICAgICAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgICAgICB0YyA9IGdsb2JbbmFtZV0oKVxcbiAgICAgICAgICAgICAgICB0Yy52ZXJib3NpdHkgPSB2ZXJib3NpdHlcXG4gICAgICAgICAgICAgICAgdGMubWFpbigpXFxuICAgICAgICAgICAgZXhjZXB0OlxcbiAgICAgICAgICAgICAgICBwcmludChcXFwiVW5jYXVnaHQgRXJyb3IgaW46IFxcXCIsIG5hbWUpXFxuXCIsXCJzcmMvbGliL3VuaXR0ZXN0L2d1aS5weVwiOlwiaW1wb3J0IGRvY3VtZW50XFxuZnJvbSB1bml0dGVzdCBpbXBvcnQgVGVzdENhc2VcXG5mcm9tIHVybGxpYi5yZXF1ZXN0IGltcG9ydCB1cmxvcGVuXFxuZnJvbSB0aW1lIGltcG9ydCBzbGVlcFxcblxcblxcbmNsYXNzIFRlc3RDYXNlR3VpKFRlc3RDYXNlKTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgVGVzdENhc2UuX19pbml0X18oc2VsZilcXG4gICAgICAgIHNlbGYuY2xvc2VzdERpdiA9IGRvY3VtZW50LmN1cnJlbnREaXYoKVxcbiAgICAgICAgc2VsZi5kaXZpZCA9IGRvY3VtZW50LmN1cnJlbnRHcmFkaW5nQ29udGFpbmVyKClcXG4gICAgICAgIHNlbGYubXlkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLmRpdmlkKVxcbiAgICAgICAgIyBJZiB0aGVyZSBpcyBubyBkaXYgdGhlbiBjcmVhdGUgYSBkdW1teSB0byBhdm9pZCBlcnJvcnMgd2hlbiBydW5uaW5nXFxuICAgICAgICAjIGdyYWRpbmcgXFxcIm9mZiBzY3JlZW5cXFwiXFxuICAgICAgICBpZiBzZWxmLm15ZGl2IGlzIE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5teWRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpXFxuICAgICAgICAgICAgc2VsZi5teWRpdi5zZXRBdHRyaWJ1dGUoXFxcImlkXFxcIiwgc2VsZi5kaXZpZCArIFxcXCJfb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c1xcXCIpXFxuICAgICAgICAgICAgc2VsZi5teWRpdi5zZXRDU1MoXFxcImRpc3BsYXlcXFwiLCBcXFwibm9uZVxcXCIpXFxuICAgICAgICAgICAgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJib2R5XFxcIilbMF1cXG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHNlbGYubXlkaXYpXFxuICAgICAgICAgICAgc2VsZi51bml0X3Jlc3VsdHNfZGl2aWQgPSBzZWxmLmRpdmlkICsgXFxcIl9vZmZzY3JlZW5fdW5pdF9yZXN1bHRzXFxcIlxcblxcbiAgICAgICAgcmVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5kaXZpZCArIFxcXCJfdW5pdF9yZXN1bHRzXFxcIilcXG4gICAgICAgIGlmIHJlczpcXG4gICAgICAgICAgICBzZWxmLnJlc2RpdiA9IHJlc1xcbiAgICAgICAgICAgIHJlcy5pbm5lckhUTUwgPSBcXFwiXFxcIlxcbiAgICAgICAgICAgIHNlbGYudW5pdF9yZXN1bHRzX2RpdmlkID0gc2VsZi5kaXZpZCArIFxcXCJfdW5pdF9yZXN1bHRzXFxcIlxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLnJlc2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpXFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYuc2V0QXR0cmlidXRlKFxcXCJpZFxcXCIsIHNlbGYuZGl2aWQgKyBcXFwiX3VuaXRfcmVzdWx0c1xcXCIpXFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJ1bml0dGVzdC1yZXN1bHRzXFxcIilcXG4gICAgICAgICAgICBzZWxmLm15ZGl2LmFwcGVuZENoaWxkKHNlbGYucmVzZGl2KVxcbiAgICAgICAgICAgIHNlbGYudW5pdF9yZXN1bHRzX2RpdmlkID0gc2VsZi5kaXZpZCArIFxcXCJfdW5pdF9yZXN1bHRzXFxcIlxcblxcbiAgICBkZWYgbWFpbihzZWxmKTpcXG4gICAgICAgIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0YWJsZVxcXCIpXFxuICAgICAgICBzZWxmLnJlc1RhYmxlID0gdFxcbiAgICAgICAgeCA9IHNlbGYucmVzZGl2LmNsb3Nlc3QoXFxcIi50aW1lZENvbXBvbmVudFxcXCIpXFxuICAgICAgICBpZiB4OlxcbiAgICAgICAgICAgIHNlbGYuaXNfdGltZWQgPSBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNlbGYuaXNfdGltZWQgPSBGYWxzZVxcbiAgICAgICAgc2VsZi5yZXNkaXYuYXBwZW5kQ2hpbGQoc2VsZi5yZXNUYWJsZSlcXG4gICAgICAgIGlmIHNlbGYuaXNfdGltZWQ6XFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYuc2V0Q1NTKFxcXCJkaXNwbGF5XFxcIiwgXFxcIm5vbmVcXFwiKVxcblxcbiAgICAgICAgaGVhZGVycyA9IFtcXFwiUmVzdWx0XFxcIiwgXFxcIkFjdHVhbCBWYWx1ZVxcXCIsIFxcXCJFeHBlY3RlZCBWYWx1ZVxcXCIsIFxcXCJOb3Rlc1xcXCJdXFxuICAgICAgICByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0clxcXCIpXFxuICAgICAgICBmb3IgaXRlbSBpbiBoZWFkZXJzOlxcbiAgICAgICAgICAgIGhlYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0aFxcXCIpXFxuICAgICAgICAgICAgaGVhZC5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgXFxcImFjLWZlZWRiYWNrXFxcIilcXG4gICAgICAgICAgICBoZWFkLmlubmVySFRNTCA9IGl0ZW1cXG4gICAgICAgICAgICBoZWFkLnNldENTUyhcXFwidGV4dC1hbGlnblxcXCIsIFxcXCJjZW50ZXJcXFwiKVxcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChoZWFkKVxcbiAgICAgICAgc2VsZi5yZXNUYWJsZS5hcHBlbmRDaGlsZChyb3cpXFxuXFxuICAgICAgICBmb3IgZnVuYyBpbiBzZWxmLnRsaXN0OlxcbiAgICAgICAgICAgIHRyeTpcXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRVcCgpXFxuICAgICAgICAgICAgICAgIGZ1bmMoKVxcbiAgICAgICAgICAgICAgICBzZWxmLnRlYXJEb3duKClcXG4gICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6XFxuICAgICAgICAgICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KFxcXCJFcnJvclxcXCIsIE5vbmUsIE5vbmUsIHN0cihlKS5zcGxpdChcXFwib24gbGluZVxcXCIpWzBdKVxcbiAgICAgICAgICAgICAgICBzZWxmLm51bUZhaWxlZCArPSAxXFxuICAgICAgICBzZWxmLnNob3dTdW1tYXJ5KClcXG5cXG4gICAgZGVmIGdldE91dHB1dChzZWxmKTpcXG4gICAgICAgIHNsZWVwKDAuMilcXG4gICAgICAgICMgc2VsZi5kaXZpZCB3aWxsIGJlIHRoZSBncmFkaW5nV3JhcHBlciB3aGVuIGluIGdyYWRpbmcgbW9kZVxcbiAgICAgICAgaWYgc2VsZi5jbG9zZXN0RGl2ICE9IHNlbGYuZGl2aWQ6XFxuICAgICAgICAgICAgb3V0cHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcXG4gICAgICAgICAgICAgICAgXFxcIiN7fSAje31fc3Rkb3V0XFxcIi5mb3JtYXQoc2VsZi5kaXZpZCwgc2VsZi5jbG9zZXN0RGl2KVxcbiAgICAgICAgICAgIClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgb3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5kaXZpZCArIFxcXCJfc3Rkb3V0XFxcIilcXG4gICAgICAgIHJldHVybiBvdXRwdXQuaW5uZXJUZXh0XFxuXFxuICAgIGRlZiBnZXRFZGl0b3JUZXh0KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEN1cnJlbnRFZGl0b3JWYWx1ZSgpXFxuXFxuICAgIGRlZiBhcHBlbmRSZXN1bHQoc2VsZiwgcmVzLCBhY3R1YWwsIGV4cGVjdGVkLCBwYXJhbSk6XFxuICAgICAgICB0cmltQWN0dWFsID0gRmFsc2VcXG4gICAgICAgIGlmIGxlbihzdHIoYWN0dWFsKSkgPiAxNTpcXG4gICAgICAgICAgICB0cmltQWN0dWFsID0gVHJ1ZVxcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0eXBlKGFjdHVhbClcXG4gICAgICAgIHRyaW1FeHBlY3RlZCA9IEZhbHNlXFxuICAgICAgICBpZiBsZW4oc3RyKGV4cGVjdGVkKSkgPiAxNTpcXG4gICAgICAgICAgICB0cmltRXhwZWN0ZWQgPSBUcnVlXFxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlID0gdHlwZShleHBlY3RlZClcXG4gICAgICAgIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRyXFxcIilcXG4gICAgICAgIGVyciA9IEZhbHNlXFxuICAgICAgICBpZiByZXMgPT0gXFxcIkVycm9yXFxcIjpcXG4gICAgICAgICAgICBlcnIgPSBUcnVlXFxuICAgICAgICAgICAgbXNnID0gXFxcIkVycm9yOiAlc1xcXCIgJSBwYXJhbVxcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRkXFxcIilcXG4gICAgICAgICAgICBlcnJvckRhdGEuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuICAgICAgICAgICAgZXJyb3JEYXRhLmlubmVySFRNTCA9IFxcXCJFUlJPUlxcXCJcXG4gICAgICAgICAgICBlcnJvckRhdGEuc2V0Q1NTKFxcXCJiYWNrZ3JvdW5kLWNvbG9yXFxcIiwgXFxcIiNkZThlOTZcXFwiKVxcbiAgICAgICAgICAgIGVycm9yRGF0YS5zZXRDU1MoXFxcInRleHQtYWxpZ25cXFwiLCBcXFwiY2VudGVyXFxcIilcXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoZXJyb3JEYXRhKVxcbiAgICAgICAgZWxpZiByZXM6XFxuICAgICAgICAgICAgcGFzc2VkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGRcXFwiKVxcbiAgICAgICAgICAgIHBhc3NlZC5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgXFxcImFjLWZlZWRiYWNrXFxcIilcXG4gICAgICAgICAgICBwYXNzZWQuaW5uZXJIVE1MID0gXFxcIlBhc3NcXFwiXFxuICAgICAgICAgICAgcGFzc2VkLnNldENTUyhcXFwiYmFja2dyb3VuZC1jb2xvclxcXCIsIFxcXCIjODNkMzgyXFxcIilcXG4gICAgICAgICAgICBwYXNzZWQuc2V0Q1NTKFxcXCJ0ZXh0LWFsaWduXFxcIiwgXFxcImNlbnRlclxcXCIpXFxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHBhc3NlZClcXG4gICAgICAgICAgICBzZWxmLm51bVBhc3NlZCArPSAxXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGZhaWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0ZFxcXCIpXFxuICAgICAgICAgICAgZmFpbC5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgXFxcImFjLWZlZWRiYWNrXFxcIilcXG4gICAgICAgICAgICBmYWlsLmlubmVySFRNTCA9IFxcXCJGYWlsXFxcIlxcbiAgICAgICAgICAgIGZhaWwuc2V0Q1NTKFxcXCJiYWNrZ3JvdW5kLWNvbG9yXFxcIiwgXFxcIiNkZThlOTZcXFwiKVxcbiAgICAgICAgICAgIGZhaWwuc2V0Q1NTKFxcXCJ0ZXh0LWFsaWduXFxcIiwgXFxcImNlbnRlclxcXCIpXFxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGZhaWwpXFxuICAgICAgICAgICAgc2VsZi5udW1GYWlsZWQgKz0gMVxcblxcbiAgICAgICAgYWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGRcXFwiKVxcbiAgICAgICAgYWN0LnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBcXFwiYWMtZmVlZGJhY2tcXFwiKVxcbiAgICAgICAgaWYgdHJpbUFjdHVhbDpcXG4gICAgICAgICAgICBhY3RIVE1MID0gc3RyKGFjdHVhbClbOjVdICsgXFxcIi4uLlxcXCIgKyBzdHIoYWN0dWFsKVstNTpdXFxuICAgICAgICAgICAgaWYgYWN0dWFsVHlwZSA9PSBzdHI6XFxuICAgICAgICAgICAgICAgIGFjdEhUTUwgPSByZXByKGFjdEhUTUwpXFxuICAgICAgICAgICAgYWN0LmlubmVySFRNTCA9IGFjdEhUTUxcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgYWN0LmlubmVySFRNTCA9IHJlcHIoYWN0dWFsKVxcbiAgICAgICAgYWN0LnNldENTUyhcXFwidGV4dC1hbGlnblxcXCIsIFxcXCJjZW50ZXJcXFwiKVxcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKGFjdClcXG5cXG4gICAgICAgIGV4cGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRkXFxcIilcXG4gICAgICAgIGV4cGVjdC5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgXFxcImFjLWZlZWRiYWNrXFxcIilcXG5cXG4gICAgICAgIGlmIHRyaW1FeHBlY3RlZDpcXG4gICAgICAgICAgICBleHBlY3RlZEhUTUwgPSBzdHIoZXhwZWN0ZWQpWzo1XSArIFxcXCIuLi5cXFwiICsgc3RyKGV4cGVjdGVkKVstNTpdXFxuICAgICAgICAgICAgaWYgZXhwZWN0ZWRUeXBlID09IHN0cjpcXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRIVE1MID0gcmVwcihleHBlY3RlZEhUTUwpXFxuICAgICAgICAgICAgZXhwZWN0LmlubmVySFRNTCA9IGV4cGVjdGVkSFRNTFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBleHBlY3QuaW5uZXJIVE1MID0gcmVwcihleHBlY3RlZClcXG4gICAgICAgIGV4cGVjdC5zZXRDU1MoXFxcInRleHQtYWxpZ25cXFwiLCBcXFwiY2VudGVyXFxcIilcXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZChleHBlY3QpXFxuICAgICAgICBpbnAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0ZFxcXCIpXFxuICAgICAgICBpbnAuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuXFxuICAgICAgICBpZiBlcnI6XFxuICAgICAgICAgICAgaW5wLmlubmVySFRNTCA9IG1zZ1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpbnAuaW5uZXJIVE1MID0gcGFyYW1cXG4gICAgICAgIGlucC5zZXRDU1MoXFxcInRleHQtYWxpZ25cXFwiLCBcXFwiY2VudGVyXFxcIilcXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZChpbnApXFxuXFxuICAgICAgICBpZiB0cmltQWN0dWFsIG9yIHRyaW1FeHBlY3RlZDpcXG4gICAgICAgICAgICBleHBhbmRidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJidXR0b25cXFwiKVxcbiAgICAgICAgICAgIGV4cGFuZGJ1dHRvbi5pbm5lckhUTUwgPSBcXFwiRXhwYW5kIERpZmZlcmVuY2VzXFxcIlxcbiAgICAgICAgICAgIGV4cGFuZG1zZyA9IFxcXCJBY3R1YWw6IFxcXCIgKyBzdHIoYWN0dWFsKSArIFxcXCJcXFxcbkV4cGVjdGVkOiBcXFwiICsgc3RyKGV4cGVjdGVkKVxcbiAgICAgICAgICAgIGV4cGFuZGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIiwgZXhwYW5kbXNnKVxcbiAgICAgICAgICAgIGV4cGFuZGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwiYnV0dG9uXFxcIilcXG4gICAgICAgICAgICBleHBhbmRidXR0b24uc2V0QXR0cmlidXRlKFxcXCJvbmNsaWNrXFxcIiwgXFxcImFsZXJ0KHRoaXMudmFsdWUpXFxcIilcXG4gICAgICAgICAgICBleHBhbmRidXR0b24uc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJidG4gYnRuLWluZm9cXFwiKVxcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChleHBhbmRidXR0b24pXFxuXFxuICAgICAgICBzZWxmLnJlc1RhYmxlLmFwcGVuZENoaWxkKHJvdylcXG5cXG4gICAgZGVmIHNob3dTdW1tYXJ5KHNlbGYpOlxcbiAgICAgICAgcGN0ID0gZmxvYXQoc2VsZi5udW1QYXNzZWQpIC8gKHNlbGYubnVtUGFzc2VkICsgc2VsZi5udW1GYWlsZWQpICogMTAwXFxuICAgICAgICBwY3Rjb3JyZWN0ID0gKFxcbiAgICAgICAgICAgIFxcXCJwZXJjZW50OlxcXCJcXG4gICAgICAgICAgICArIHN0cihwY3QpXFxuICAgICAgICAgICAgKyBcXFwiOnBhc3NlZDpcXFwiXFxuICAgICAgICAgICAgKyBzdHIoc2VsZi5udW1QYXNzZWQpXFxuICAgICAgICAgICAgKyBcXFwiOmZhaWxlZDpcXFwiXFxuICAgICAgICAgICAgKyBzdHIoc2VsZi5udW1GYWlsZWQpXFxuICAgICAgICApXFxuICAgICAgICBwVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwicFxcXCIpXFxuICAgICAgICBpZiBub3Qgc2VsZi5pc190aW1lZDpcXG4gICAgICAgICAgICBwVGFnLmlubmVySFRNTCA9IFxcXCJZb3UgcGFzc2VkOiBcXFwiICsgc3RyKHBjdCkgKyBcXFwiJSBvZiB0aGUgdGVzdHNcXFwiXFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYuYXBwZW5kQ2hpbGQocFRhZylcXG4gICAgICAgIHRyeTpcXG4gICAgICAgICAgICBqc2V2YWwoXFxcIndpbmRvdy5lZExpc3RbJ3t9J10ucGN0X2NvcnJlY3QgPSB7fVxcXCIuZm9ybWF0KHNlbGYuY2xvc2VzdERpdiwgcGN0KSlcXG4gICAgICAgICAgICBqc2V2YWwoXFxuICAgICAgICAgICAgICAgIFxcXCJ3aW5kb3cuZWRMaXN0Wyd7fSddLnVuaXRfcmVzdWx0cyA9ICd7fSdcXFwiLmZvcm1hdChcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VzdERpdiwgcGN0Y29ycmVjdFxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIGpzZXZhbChcXG4gICAgICAgICAgICAgICAgXFxcIndpbmRvdy5lZExpc3RbJ3t9J10udW5pdF9yZXN1bHRzX2RpdmlkID0gJ3t9J1xcXCIuZm9ybWF0KFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZXN0RGl2LCBzZWxmLm15ZGl2LmdldEF0dHJpYnV0ZShcXFwiaWRcXFwiKVxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKVxcblxcbiAgICAgICAgZXhjZXB0OlxcbiAgICAgICAgICAgIHByaW50KFxcbiAgICAgICAgICAgICAgICBcXFwiZmFpbGVkIHRvIGZpbmQgb2JqZWN0IHRvIHJlY29yZCB1bml0dGVzdCByZXN1bHRzISB7fVxcXCIuZm9ybWF0KFxcbiAgICAgICAgICAgICAgICAgICAgcGN0Y29ycmVjdFxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKVxcblwiLFwic3JjL2xpYi91cmxsaWIyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInVybGxpYjJcXFwiKVxcblwiLFwic3JjL2xpYi91cmxwYXJzZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ1cmxwYXJzZVxcXCIpXFxuXCIsXCJzcmMvbGliL3VzZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidXNlclxcXCIpXFxuXCIsXCJzcmMvbGliL3V1LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInV1XFxcIilcXG5cIixcInNyYy9saWIvdXVpZC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ1dWlkXFxcIilcXG5cIixcInNyYy9saWIvd2FybmluZ3MucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwid2FybmluZ3NcXFwiKVxcblwiLFwic3JjL2xpYi93YXZlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIndhdmVcXFwiKVxcblwiLFwic3JjL2xpYi93ZWFrcmVmLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIndlYWtyZWZcXFwiKVxcblwiLFwic3JjL2xpYi93aGljaGRiLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIndoaWNoZGJcXFwiKVxcblwiLFwic3JjL2xpYi93c2dpcmVmL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIndzZ2lyZWZcXFwiKVxcblwiLFwic3JjL2xpYi94ZHJsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwieGRybGliXFxcIilcXG5cIixcInNyYy9saWIveG1sL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInhtbFxcXCIpXFxuXCIsXCJzcmMvbGliL3htbC9kb20vX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZG9tXFxcIilcXG5cIixcInNyYy9saWIveG1sL2V0cmVlL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImV0cmVlXFxcIilcXG5cIixcInNyYy9saWIveG1sL3BhcnNlcnMvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicGFyc2Vyc1xcXCIpXFxuXCIsXCJzcmMvbGliL3htbC9zYXgvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2F4XFxcIilcXG5cIixcInNyYy9saWIveG1sbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInhtbGxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL3htbHJwY2xpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ4bWxycGNsaWJcXFwiKVxcblwiLFwic3JjL2xpYi96aXBmaWxlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInppcGZpbGVcXFwiKVxcblwiLFwic3JjL2J1aWx0aW4vc3lzLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oaSl7dmFyIHQsbj17fSxlPVtdLHU9U2suZ2V0U3lzQXJndigpO2Zvcih0PTA7dDx1Lmxlbmd0aDsrK3QpZS5wdXNoKG5ldyBTay5idWlsdGluLnN0cih1W3RdKSk7bi5hcmd2PW5ldyBTay5idWlsdGlucy5saXN0KGUpLG4uY29weXJpZ2h0PW5ldyBTay5idWlsdGluLnN0cihcXFwiQ29weXJpZ2h0IDIwMDktMjAxMCBTY290dCBHcmFoYW0uXFxcXG5BbGwgUmlnaHRzIFJlc2VydmVkLlxcXFxuXFxcIiksU2suX19mdXR1cmVfXy5weXRob24zPyhuLnZlcnNpb249bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIzLjcoaXNoKSBbU2t1bHB0XVxcXCIpLG4udmVyc2lvbl9pbmZvPW5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5pbnRfKDMpLG5ldyBTay5idWlsdGluLmludF8oNyldKSk6KG4udmVyc2lvbj1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIjIuNyhpc2gpIFtTa3VscHRdXFxcIiksbi52ZXJzaW9uX2luZm89bmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmludF8oMiksbmV3IFNrLmJ1aWx0aW4uaW50Xyg3KV0pKSxuLm1heGludD1uZXcgU2suYnVpbHRpbi5pbnRfKE1hdGgucG93KDIsNTMpLTEpLG4ubWF4c2l6ZT1uZXcgU2suYnVpbHRpbi5pbnRfKE1hdGgucG93KDIsNTMpLTEpLG4ubW9kdWxlcz1Tay5zeXNtb2R1bGVzLG4ucGF0aD1Tay5yZWFsc3lzcGF0aCxuLmdldGRlZmF1bHRlbmNvZGluZz1uZXcgU2suYnVpbHRpbi5mdW5jKCgoKT0+bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ1dGYtOFxcXCIpKSksbi5nZXRFeGVjdXRpb25MaW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBudWxsPT09U2suZXhlY0xpbWl0P1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpuZXcgU2suYnVpbHRpbi5pbnRfKFNrLmV4ZWNMaW1pdCl9KSksbi5zZXRFeGVjdXRpb25MaW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihpKXtpZihudWxsPT09U2suZXhlY0xpbWl0KXRocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXFxcIkV4ZWN1dGlvbiBsaW1pdGluZyBpcyBub3QgZW5hYmxlZFxcXCIpO3ZvaWQgMCE9PWkmJihTay5leGVjTGltaXQ9U2suYnVpbHRpbi5hc251bSQoaSkpfSkpLG4ucmVzZXRUaW1lb3V0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7U2suZXhlY1N0YXJ0PW5ldyBEYXRlfSkpLG4uZ2V0WWllbGRMaW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBudWxsPT09U2sueWllbGRMaW1pdD9Tay5idWlsdGluLm5vbmUubm9uZSQ6bmV3IFNrLmJ1aWx0aW4uaW50XyhTay55aWVsZExpbWl0KX0pKSxuLnNldFlpZWxkTGltaXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oaSl7aWYobnVsbD09PVNrLnlpZWxkTGltaXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiWWllbGRpbmcgaXMgbm90IGVuYWJsZWRcXFwiKTt2b2lkIDAhPT1pJiYoU2sueWllbGRMaW1pdD1Tay5idWlsdGluLmFzbnVtJChpKSl9KSksbi5kZWJ1Zz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KSk7Y29uc3QgbD1Tay5idWlsdGluLm1ha2Vfc3RydWN0c2VxKFxcXCJzeXNcXFwiLFxcXCJmbG9hdF9pbmZvXFxcIix7bWF4OlxcXCJEQkxfTUFYIC0tIG1heGltdW0gcmVwcmVzZW50YWJsZSBmaW5pdGUgZmxvYXRcXFwiLG1heF9leHA6XFxcIkRCTF9NQVhfRVhQIC0tIG1heGltdW0gaW50IGUgc3VjaCB0aGF0IHJhZGl4KiooZS0xKSBpcyByZXByZXNlbnRhYmxlXFxcIixtYXhfMTBfZXhwOlxcXCJEQkxfTUFYXzEwX0VYUCAtLSBtYXhpbXVtIGludCBlIHN1Y2ggdGhhdCAxMCoqZSBpcyByZXByZXNlbnRhYmxlXFxcIixtaW46XFxcIkRCTF9NSU4gLS0gTWluaW11bSBwb3NpdGl2ZSBub3JtYWxpemVkIGZsb2F0XFxcIixtaW5fZXhwOlxcXCJEQkxfTUlOX0VYUCAtLSBtaW5pbXVtIGludCBlIHN1Y2ggdGhhdCByYWRpeCoqKGUtMSkgaXMgYSBub3JtYWxpemVkIGZsb2F0XFxcIixtaW5fMTBfZXhwOlxcXCJEQkxfTUlOXzEwX0VYUCAtLSBtaW5pbXVtIGludCBlIHN1Y2ggdGhhdCAxMCoqZSBpcyBhIG5vcm1hbGl6ZWRcXFwiLGRpZzpcXFwiREJMX0RJRyAtLSBkaWdpdHNcXFwiLG1hbnRfZGlnOlxcXCJEQkxfTUFOVF9ESUcgLS0gbWFudGlzc2EgZGlnaXRzXFxcIixlcHNpbG9uOlxcXCJEQkxfRVBTSUxPTiAtLSBEaWZmZXJlbmNlIGJldHdlZW4gMSBhbmQgdGhlIG5leHQgcmVwcmVzZW50YWJsZSBmbG9hdFxcXCIscmFkaXg6XFxcIkZMVF9SQURJWCAtLSByYWRpeCBvZiBleHBvbmVudFxcXCIscm91bmRzOlxcXCJGTFRfUk9VTkRTIC0tIHJvdW5kaW5nIG1vZGVcXFwifSk7bi5mbG9hdF9pbmZvPW5ldyBsKFtOdW1iZXIuTUFYX1ZBTFVFLE1hdGguZmxvb3IoTWF0aC5sb2cyKE51bWJlci5NQVhfVkFMVUUpKSxNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9WQUxVRSkpLE51bWJlci5NSU5fVkFMVUUsTWF0aC5jZWlsKE1hdGgubG9nMihOdW1iZXIuTUlOX1ZBTFVFKSksTWF0aC5jZWlsKE1hdGgubG9nMTAoTnVtYmVyLk1JTl9WQUxVRSkpLDE1LE1hdGgubG9nMihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksTnVtYmVyLkVQU0lMT04sMiwxXS5tYXAoKGk9PlNrLmZmaS5yZW1hcFRvUHkoaSkpKSk7Y29uc3Qgbz1Tay5idWlsdGluLm1ha2Vfc3RydWN0c2VxKFxcXCJzeXNcXFwiLFxcXCJpbnRfaW5mb1xcXCIse2JpdHNfcGVyX2RpZ2l0OlxcXCJzaXplIG9mIGEgZGlnaXQgaW4gYml0c1xcXCIsc2l6ZW9mX2RpZ2l0OlxcXCJzaXplIGluIGJ5dGVzIG9mIHRoZSBDIHR5cGUgdXNlZCB0byByZXByZXNlbnQgYSBkaWdpdFxcXCJ9KTtyZXR1cm4gbi5pbnRfaW5mbz1uZXcgbyhbMzAsNF0ubWFwKChpPT5Tay5mZmkucmVtYXBUb1B5KGkpKSkpLG4uX19zdGRvdXRfXz1uZXcgU2suYnVpbHRpbi5maWxlKG5ldyBTay5idWlsdGluLnN0cihcXFwiL2Rldi9zdGRvdXRcXFwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIndcXFwiKSksbi5fX3N0ZGluX189bmV3IFNrLmJ1aWx0aW4uZmlsZShuZXcgU2suYnVpbHRpbi5zdHIoXFxcIi9kZXYvc3RkaW5cXFwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcInJcXFwiKSksbi5zdGRvdXQ9bi5fX3N0ZG91dF9fLG4uc3RkaW49bi5fX3N0ZGluX18sbn07XCIsXCJzcmMvbGliL0pvQmFzZS5qc1wiOlwiY29uc3QgJGJ1aWx0aW5tb2R1bGU9KCk9PntTay5taXNjZXZhbC5wcmludF8oXFxcIldlbGNvbWUgdG8gSm9CYXNlXFxcXG5cXFwiKTtjb25zdCBlPVNrLkpvQmFzZSxvPXt9LHQ9W10scj1bXSxuPWUuZ2V0Q29udGV4dChcXFwid2ViZ2xcXFwiKSxhPW4uY3JlYXRlUHJvZ3JhbSgpLGM9bi5jcmVhdGVCdWZmZXIoKSxpPW4uY3JlYXRlU2hhZGVyKG4uVkVSVEVYX1NIQURFUikscz1uLmNyZWF0ZVNoYWRlcihuLkZSQUdNRU5UX1NIQURFUiksc3RyPWU9Pm5ldyBTay5idWlsdGluLnN0cihlKSxkZWY9ZT0+bmV3IFNrLmJ1aWx0aW4uZnVuYyhlKSxmbG9hdD1lPT5uZXcgU2suYnVpbHRpbi5mbG9hdF8oZSksaW50PWU9Pm5ldyBTay5idWlsdGluLmludF8oZSksYm9vbD1lPT5uZXcgU2suYnVpbHRpbi5ib29sKGUpLHR1cGxlPWU9Pm5ldyBTay5idWlsdGluLnR1cGxlKGUpLG51bWJlcj1lPT57aWYoU2suYnVpbHRpbi5jaGVja051bWJlcihlKSlyZXR1cm4gZS52O3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwibXVzdCBiZSByZWFsIG51bWJlciwgbm90IFxcXCIrZS50cCRuYW1lKX0sc3RyaW5nPWU9PntpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGUpKXJldHVybiBlLnY7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJtdXN0IGJlIHN0ciwgbm90IFxcXCIrZS50cCRuYW1lKX0scHJvcGVydHk9KC4uLmUpPT5jYWxsKFNrLmJ1aWx0aW5zLnByb3BlcnR5LC4uLmUpLGJ1aWxkPSguLi5lKT0+U2subWlzY2V2YWwuYnVpbGRDbGFzcyhvLC4uLmUpLGNhbGw9KC4uLmUpPT5Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kKC4uLmUpLGlzPSguLi5lKT0+U2suYnVpbHRpbi5pc2luc3RhbmNlKC4uLmUpLnYsd2FpdD1lPT5Tay5taXNjZXZhbC5wcm9taXNlVG9TdXNwZW5zaW9uKG5ldyBQcm9taXNlKGUpKSxvYmplY3Q9ZT0+e3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwibXVzdCBiZSBTaGFwZSBvciBjdXJzb3IsIG5vdCBcXFwiK2UudHAkbmFtZSl9LHBhdGg9ZT0+c3RyKFxcXCJodHRwczovL2pvYmFzZS5vcmcvQnJvd3Nlci9Kb0Jhc2UvXFxcIitlKSx3aWR0aD0oKT0+ZS53aWR0aC9kZXZpY2VQaXhlbFJhdGlvLGhlaWdodD0oKT0+ZS5oZWlnaHQvZGV2aWNlUGl4ZWxSYXRpbyx4PSgpPT5vLmN1cnNvci4keC13aWR0aCgpLzIseT0oKT0+aGVpZ2h0KCkvMi1vLmN1cnNvci4keSxibGFuaz0oKT0+e30sbW91c2VFbnRlcj0oKT0+by5jdXJzb3IuJGVudGVyPSEwLG1vdXNlTGVhdmU9KCk9Pm8uY3Vyc29yLiRsZWF2ZT0hMCxtb3VzZURvd249KCk9PntvLmN1cnNvci4kcHJlc3M9ITAsby5jdXJzb3IuJGhvbGQ9ITB9LG1vdXNlVXA9KCk9PntvLmN1cnNvci4kcmVsZWFzZT0hMCxvLmN1cnNvci4kaG9sZD0hMX0sbW91c2VNb3ZlPXQ9Pntjb25zdCByPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7by5jdXJzb3IuJHg9dC5jbGllbnRYLXIubGVmdCxvLmN1cnNvci4keT10LmNsaWVudFktci50b3Asby5jdXJzb3IuJG1vdmU9ITB9LGtleURvd249ZT0+e2NvbnN0IHQ9T2JqZWN0LmtleXMoby5rZXkuJGRhdGEpLmZpbmQoKHQ9Pm8ua2V5LiRkYXRhW3RdLmNvZGU9PWUuY29kZSkpLHI9by5rZXkuJGRhdGFbdF07ZS5yZXBlYXQ/KG8ua2V5LiRyZXBlYXQ9ITAsciYmKHIucmVwZWF0PSEwKSk6KG8ua2V5LiRwcmVzcz0hMCxyJiYoci5wcmVzcz0hMCkmJihyLmhvbGQ9ITApKX0sa2V5VXA9ZT0+e2NvbnN0IHQ9T2JqZWN0LmtleXMoby5rZXkuJGRhdGEpLmZpbmQoKHQ9Pm8ua2V5LiRkYXRhW3RdLmNvZGU9PWUuY29kZSkpLHI9by5rZXkuJGRhdGFbdF07by5rZXkuJHJlbGVhc2U9ITAsciYmKHIucmVsZWFzZT0hMCkmJihyLmhvbGQ9ITEpfSxjb2xsaWRlUG9seVBvaW50PShlLG8pPT5lLnJlZHVjZSgoKGUsdCxyLG4pPT57Y29uc3QgYT1uW3IrMT09bi5sZW5ndGg/MDpyKzFdO3JldHVybiBvWzBdPChhWzBdLXRbMF0pKihvWzFdLXRbMV0pLyhhWzFdLXRbMV0pK3RbMF0mJih0WzFdPm9bMV0mJmFbMV08b1sxXXx8dFsxXTxvWzFdJiZhWzFdPm9bMV0pPyFlOmV9KSwhMSksZ2V0UmVjdFBvbHk9ZT0+e2NvbnN0IG89ZS4kYW5jaG9yWzBdK2UuJHNpemVbMF0qZS4kc2NhbGVbMF0vMix0PWUuJGFuY2hvclsxXStlLiRzaXplWzFdKmUuJHNjYWxlWzFdLzI7cmV0dXJuKChlLG8sdCk9Pntjb25zdCByPU1hdGguY29zKG8qTWF0aC5QSS8xODApLG49TWF0aC5zaW4obypNYXRoLlBJLzE4MCk7cmV0dXJuIGUubWFwKChlPT5bZVswXSpyLWVbMV0qbit0WzBdLGVbMF0qbitlWzFdKnIrdFsxXV0pKX0pKFtbLW8sdF0sW28sdF0sW28sLXRdLFstbywtdF1dLGUuJGFuZ2xlLGUuJHBvcyl9LGNyZWF0ZUltYWdlPWU9Pntjb25zdCBvPW4uY3JlYXRlVGV4dHVyZSgpO3JldHVybiBuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxvKSxuLnRleEltYWdlMkQobi5URVhUVVJFXzJELDAsbi5SR0JBLG4uUkdCQSxuLlVOU0lHTkVEX0JZVEUsZSksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfV1JBUF9TLG4uQ0xBTVBfVE9fRURHRSksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfV1JBUF9ULG4uQ0xBTVBfVE9fRURHRSksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUlOX0ZJTFRFUixuLkxJTkVBUiksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUFHX0ZJTFRFUixuLkxJTkVBUiksb30scmVuZGVyVGV4dD1lPT57Y29uc3Qgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKSx0PW8uZ2V0Q29udGV4dChcXFwiMmRcXFwiKSxhPWUuJGZvbnRTaXplK1xcXCJweCBfXFxcIityLmluZGV4T2YoZS4kZm9udCk7dC5mb250PWE7Y29uc3QgYz10Lm1lYXN1cmVUZXh0KGUuJGNvbnRlbnQpLGk9Yy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0LWMuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LHM9dC5tZWFzdXJlVGV4dChcXFwiU3lcXFwiKSxkPXMuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50K3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7ZS4kc2l6ZVswXT1vLndpZHRoPWksZS4kc2l6ZVsxXT1vLmhlaWdodD1kLHQuZm9udD1hLHQuZmlsbFN0eWxlPVxcXCIjZmZmXFxcIix0LmZpbGxUZXh0KGUuJGNvbnRlbnQsMCxzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSxuLmRlbGV0ZVRleHR1cmUoZS4kdGV4dHVyZSksZS4kdGV4dHVyZT1jcmVhdGVJbWFnZShvKX0sbG9hZEZvbnQ9ZT0+bmV3IFByb21pc2UoKChvLHQpPT57aWYoci5pbmNsdWRlcyhlKSlyZXR1cm4gbygpO25ldyBGb250RmFjZShcXFwiX1xcXCIrci5sZW5ndGgsYHVybCgke2V9KWApLmxvYWQoKS50aGVuKCh0PT57ZG9jdW1lbnQuZm9udHMuYWRkKHQpLHIucHVzaChlKSxvKCl9KSkuY2F0Y2goKCgpPT57cmV0dXJuIHQoKG89YGZhaWxlZCB0byBsb2FkIGZvbnQ6IFxcXCIke2V9XFxcImAsbmV3IFNrLmJ1aWx0aW4uRmlsZU5vdEZvdW5kRXJyb3IobykpKTt2YXIgb30pKX0pKSxkcmF3U2hhcGU9KGUsbyx0LHIsYyxpKT0+e2NvbnN0IHM9b1swXSplLiRzY2FsZVswXSxkPW9bMV0qZS4kc2NhbGVbMV0sbD1lLiRhbmNob3JbMF0sdT1lLiRhbmNob3JbMV0sJD1lLiRwb3NbMF0scD1lLiRwb3NbMV0sbT1NYXRoLnNpbihlLiRhbmdsZSpNYXRoLlBJLzE4MCksZj1NYXRoLmNvcyhlLiRhbmdsZSpNYXRoLlBJLzE4MCk7dmFyIGgsXztoPVtzKmYscyptLDAsMCxkKi1tLGQqZiwwLDAsMCwwLDEsMCxsKmYrdSotbSskLGwqbSt1KmYrcCwwLDFdLF89ZS4kY29sb3Isbi51bmlmb3JtNGZ2KG4uZ2V0VW5pZm9ybUxvY2F0aW9uKGEsXFxcImNvbG9yXFxcIiksbmV3IEZsb2F0MzJBcnJheShfKSksbi51bmlmb3JtTWF0cml4NGZ2KG4uZ2V0VW5pZm9ybUxvY2F0aW9uKGEsXFxcIm9iamVjdFxcXCIpLCExLG5ldyBGbG9hdDMyQXJyYXkoaCkpLG4uYmluZEJ1ZmZlcihuLkFSUkFZX0JVRkZFUix0KSxuLnVuaWZvcm0xaShuLmdldFVuaWZvcm1Mb2NhdGlvbihhLFxcXCJpbWFnZVxcXCIpLGMpLG4uZHJhd0FycmF5cyhyLDAsaSl9LGQ9ZGVmKCgoZSx0KT0+e2lmKGlzKGUsby5SZWN0YW5nbGUpKXtpZihpcyh0LG8uUmVjdGFuZ2xlKSlyZXR1cm4gYm9vbCgocj1nZXRSZWN0UG9seShlKSxuPWdldFJlY3RQb2x5KHQpLGNvbGxpZGVQb2x5UG9pbnQocixuWzBdKXx8Y29sbGlkZVBvbHlQb2ludChuLHJbMF0pfHxyLmZpbmQoKChlLG8sdCk9PigoZSxvLHQpPT5lLmZpbmQoKChlLHIsbik9PigoZSxvLHQscik9Pntjb25zdCBuPShyWzFdLXRbMV0pKihvWzBdLWVbMF0pLShyWzBdLXRbMF0pKihvWzFdLWVbMV0pLGE9KChyWzBdLXRbMF0pKihlWzFdLXRbMV0pLShyWzFdLXRbMV0pKihlWzBdLXRbMF0pKS9uLGM9KChvWzBdLWVbMF0pKihlWzFdLXRbMV0pLShvWzFdLWVbMV0pKihlWzBdLXRbMF0pKS9uO3JldHVybiBhPj0wJiZhPD0xJiZjPj0wJiZjPD0xfSkobyx0LGUsbltyKzE9PW4ubGVuZ3RoPzA6cisxXSkpKSkobixlLHRbbysxPT10Lmxlbmd0aD8wOm8rMV0pKSkpKTtpZih0PT1vLmN1cnNvcilyZXR1cm4gYm9vbChjb2xsaWRlUG9seVBvaW50KGdldFJlY3RQb2x5KGUpLFt4KCkseSgpXSkpO29iamVjdCh0KX12YXIgcixuO2lmKGU9PW8uY3Vyc29yKXtpZihpcyh0LG8uUmVjdGFuZ2xlKSlyZXR1cm4gYm9vbChjb2xsaWRlUG9seVBvaW50KGdldFJlY3RQb2x5KHQpLFt4KCkseSgpXSkpO2lmKHQ9PW8uY3Vyc29yKXJldHVybiBTay5idWlsdGlucy5ib29sLnRydWUkO29iamVjdCh0KX1vYmplY3QoZSl9KSksbD17c2V0OihlLG8pPT57aWYoZS5vYiR0eXBlPT1sLmNsYXNzKW8uZm9yRWFjaCgoKG8sdCxyKT0+clt0XT10PGUuJGRhdGEubGVuZ3RoP2UuJGdldCgpW3RdOm8pKTtlbHNle2lmKCFTay5idWlsdGluLmNoZWNrU2VxdWVuY2UoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW5zLlR5cGVFcnJvcihcXFwiYXR0cmlidXRlIG11c3QgYmUgYSBzZXF1ZW5jZSBvZiB2YWx1ZXNcXFwiKTtvLmZvckVhY2goKChvLHQscik9PnJbdF09dDxlLnYubGVuZ3RoP2Uudlt0XS52Om8pKX1yZXR1cm4gb30sbmV3OihlLG8sLi4udCk9Pntjb25zdCByPWNhbGwobC5jbGFzcyk7cmV0dXJuIHIuJHBhcmVudD1lLHIuJGdldD1vLHIuJGRhdGE9dC5tYXAoKGU9Pih7bmFtZTplWzBdLHNldDplWzFdfSkpKSxyfSxjbGFzczpidWlsZCgoKGUsbyk9PntvLl9fZ2V0YXR0cl9fPWRlZigoKGUsbyk9Pntjb25zdCB0PWUuJGRhdGEuZmluZEluZGV4KChlPT5lLm5hbWU9PW8udikpO2lmKC0xIT10KXJldHVybiBmbG9hdChlLiRnZXQoKVt0XSl9KSksby5fX3NldGF0dHJfXz1kZWYoKChlLG8sdCk9Pntjb25zdCByPWUuJGRhdGEuZmluZCgoZT0+ZS5uYW1lPT1vLnYpKTtyJiZyLnNldChlLiRwYXJlbnQsdCl9KSksby5fX3N0cl9fPWRlZigoZT0+c3RyKGAoJHtlLiRnZXQoKS5qb2luKFxcXCIsIFxcXCIpfSlgKSkpLG8uX19yZXByX189ZGVmKChlPT5zdHIoYFske2UuJGdldCgpLmpvaW4oXFxcIiwgXFxcIil9XWApKSl9KSxcXFwiVmVjdG9yXFxcIil9LHU9e25ldzooZSxvLHQscixuKT0+e2UuJGNvbG9yPWwuc2V0KG4sWzAsMCwwLDFdKSxlLiRwb3M9W251bWJlcihvKSxudW1iZXIodCldLGUuJGFuZ2xlPW51bWJlcihyKSxlLiRhbmNob3I9WzAsMF0sZS4kc2NhbGU9WzEsMV19LGNsYXNzOmJ1aWxkKCgoZSx0KT0+e3QuY29sbGlkZXNfd2l0aD1kLHQubG9va19hdD1kZWYoKChlLHQpPT57Y29uc3Qgc2V0PShvLHQpPT57Y29uc3Qgcj1NYXRoLmF0YW4yKHQtZS4kcG9zWzFdLG8tZS4kcG9zWzBdKTtlLiRhbmdsZT0xODAqci9NYXRoLlBJfTt0PT1vLmN1cnNvcj9zZXQoeCgpLHkoKSk6aXModCx1LmNsYXNzKT9zZXQoLi4udC4kcG9zKTpvYmplY3QodCl9KSksdC5tb3ZlX3Rvd2FyZD1kZWYoKChlLHQscik9Pntjb25zdCBuPW51bWJlcihyKT8/MSxzZXQ9KG8sdCk9Pntjb25zdCByPW8tZS4kcG9zWzBdLGE9dC1lLiRwb3NbMV07TWF0aC5oeXBvdChyLGEpPG4/KGUuJHBvc1swXSs9cixlLiRwb3NbMV0rPWEpOihlLiRwb3NbMF0rPU1hdGguY29zKE1hdGguYXRhbjIoYSxyKSkqbixlLiRwb3NbMV0rPU1hdGguc2luKE1hdGguYXRhbjIoYSxyKSkqbil9O3Q9PW8uY3Vyc29yP3NldCh4KCkseSgpKTppcyh0LHUuY2xhc3MpP3NldCguLi50LiRwb3MpOm9iamVjdCh0KX0pKTtjb25zdCB4PShlLG8pPT5lLiRwb3NbMF09bnVtYmVyKG8pLHk9KGUsbyk9PmUuJHBvc1sxXT1udW1iZXIobyk7dC54PXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kcG9zWzBdKSkpLGRlZih4KSksdC55PXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kcG9zWzFdKSkpLGRlZih5KSksdC5wb3M9dC5wb3NpdGlvbj1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5lLiRwb3MpLFtcXFwieFxcXCIseF0sW1xcXCJ5XFxcIix5XSkpKSxkZWYoKChlLG8pPT5sLnNldChvLGUuJHBvcykpKSksdC50b3A9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiR0b3AoKSkpKSxkZWYoKChlLG8pPT5lLiRwb3NbMV0rPW8tZS4kdG9wKCkpKSksdC5sZWZ0PXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kbGVmdCgpKSkpLGRlZigoKGUsbyk9PmUuJHBvc1swXSs9by1lLiRsZWZ0KCkpKSksdC5ib3R0b209cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRib3R0b20oKSkpKSxkZWYoKChlLG8pPT5lLiRwb3NbMV0rPW8tZS4kYm90dG9tKCkpKSksdC5yaWdodD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHJpZ2h0KCkpKSksZGVmKCgoZSxvKT0+ZS4kcG9zWzBdKz1vLWUuJHJpZ2h0KCkpKSk7Y29uc3Qgc2NhbGVYPShlLG8pPT5lLiRzY2FsZVswXT1udW1iZXIobyksc2NhbGVZPShlLG8pPT5lLiRzY2FsZVsxXT1udW1iZXIobyk7dC5zY2FsZT1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5lLiRzY2FsZSksW1xcXCJ4XFxcIixzY2FsZVhdLFtcXFwieVxcXCIsc2NhbGVZXSkpKSxkZWYoKChlLG8pPT5sLnNldChvLGUuJHNjYWxlKSkpKTtjb25zdCBhbmNob3JYPShlLG8pPT5lLiRhbmNob3JbMF09bnVtYmVyKG8pLGFuY2hvclk9KGUsbyk9PmUuJGFuY2hvclsxXT1udW1iZXIobyk7dC5hbmNob3I9cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+ZS4kYW5jaG9yKSxbXFxcInhcXFwiLGFuY2hvclhdLFtcXFwieVxcXCIsYW5jaG9yWV0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRhbmNob3IpKSkpLHQuYW5nbGU9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRhbmdsZSkpKSxkZWYoKChlLG8pPT5lLiRhbmdsZT1udW1iZXIobykpKSk7Y29uc3QgcmVkPShlLG8pPT5lLiRjb2xvclswXT1udW1iZXIobyksZ3JlZW49KGUsbyk9PmUuJGNvbG9yWzFdPW51bWJlcihvKSxibHVlPShlLG8pPT5lLiRjb2xvclsyXT1udW1iZXIobyksYWxwaGE9KGUsbyk9PmUuJGNvbG9yWzNdPW51bWJlcihvKTt0LnJlZD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJGNvbG9yWzBdKSkpLGRlZihyZWQpKSx0LmdyZWVuPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kY29sb3JbMV0pKSksZGVmKGdyZWVuKSksdC5ibHVlPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kY29sb3JbMl0pKSksZGVmKGJsdWUpKSx0LmJsdWU9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRjb2xvclszXSkpKSxkZWYoYWxwaGEpKSx0LmNvbG9yPXByb3BlcnR5KGRlZigoZT0+bC5uZXcoZSwoKCk9PmUuJGNvbG9yKSxbXFxcInJlZFxcXCIscmVkXSxbXFxcImdyZWVuXFxcIixncmVlbl0sW1xcXCJibHVlXFxcIixibHVlXSxbXFxcImFscGhhXFxcIixhbHBoYV0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRjb2xvcikpKSl9KSxcXFwiU2hhcGVcXFwiKX07cmV0dXJuIG8uTUFOPXBhdGgoXFxcImltYWdlcy9tYW4ucG5nXFxcIiksby5DT0lOPXBhdGgoXFxcImltYWdlcy9jb2luLnBuZ1xcXCIpLG8uRU5FTVk9cGF0aChcXFwiaW1hZ2VzL2VuZW15LnBuZ1xcXCIpLG8uREVGQVVMVD1wYXRoKFxcXCJmb250cy9kZWZhdWx0LnR0ZlxcXCIpLG8uQ09ERT1wYXRoKFxcXCJmb250cy9jb2RlLnR0ZlxcXCIpLG8uUEVOQ0lMPXBhdGgoXFxcImZvbnRzL3BlbmNpbC50dGZcXFwiKSxvLlNFUklGPXBhdGgoXFxcImZvbnRzL3NlcmlmLnR0ZlxcXCIpLG8uSEFORFdSSVRJTkc9cGF0aChcXFwiZm9udHMvaGFuZHdyaXRpbmcudHRmXFxcIiksby5UWVBFV1JJVEVSPXBhdGgoXFxcImZvbnRzL3R5cGV3cml0ZXIudHRmXFxcIiksby5KT0lORUQ9cGF0aChcXFwiZm9udHMvam9pbmVkLnR0ZlxcXCIpLG8ud2luZG93PWNhbGwoYnVpbGQoKChlLG8pPT57Y29uc3QgaW5pdD0oZSxvLHQscixhKT0+e2UuJGNhcHRpb249c3RyaW5nKG8pLGUuJGNvbG9yPWwuc2V0KGEsWzEsMSwxXSksbi5jbGVhckNvbG9yKC4uLmUuJGNvbG9yLDEpfTtpbml0LiRkZWZhdWx0cz1bc3RyKFxcXCJKb0Jhc2VcXFwiKSxudWxsLG51bGwsdHVwbGUoKV0saW5pdC5jb192YXJuYW1lcz1bXFxcInNlbGZcXFwiLFxcXCJjYXB0aW9uXFxcIixcXFwid2lkdGhcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJjb2xvclxcXCJdLG8uX19pbml0X189ZGVmKGluaXQpLG8uY2xvc2U9ZGVmKChlPT5lLiRjbG9zZT0hMCkpLG8ubWF4aW1pemU9ZGVmKGJsYW5rKSxvLm1pbmltaXplPWRlZihibGFuayksby5mb2N1cz1kZWYoYmxhbmspLG8uY2FwdGlvbj1wcm9wZXJ0eShkZWYoKGU9PnN0cihlLiRjYXB0aW9uKSkpLGRlZigoKGUsbyk9PmUuJGNhcHRpb249c3RyaW5nKG8pKSkpO2NvbnN0IHJlZD0oZSxvKT0+e2UuJGNvbG9yWzBdPW51bWJlcihvKSxuLmNsZWFyQ29sb3IoLi4uZS4kY29sb3IsMSl9LGdyZWVuPShlLG8pPT57ZS4kY29sb3JbMV09bnVtYmVyKG8pLG4uY2xlYXJDb2xvciguLi5lLiRjb2xvciwxKX0sYmx1ZT0oZSxvKT0+e2UuJGNvbG9yWzJdPW51bWJlcihvKSxuLmNsZWFyQ29sb3IoLi4uZS4kY29sb3IsMSl9O28ucmVkPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kY29sb3JbMF0pKSksZGVmKHJlZCkpLG8uZ3JlZW49cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRjb2xvclsxXSkpKSxkZWYoZ3JlZW4pKSxvLmJsdWU9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRjb2xvclsyXSkpKSxkZWYoYmx1ZSkpLG8uY29sb3I9cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+ZS4kY29sb3IpLFtcXFwicmVkXFxcIixyZWRdLFtcXFwiZ3JlZW5cXFwiLGdyZWVuXSxbXFxcImJsdWVcXFwiLGJsdWVdKSkpLGRlZigoKGUsbyk9Pm4uY2xlYXJDb2xvciguLi5sLnNldChvLGUuJGNvbG9yKSwxKSkpKSxvLndpZHRoPXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHdpZHRoKCkpKSkpLG8uaGVpZ2h0PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KGhlaWdodCgpKSkpKSxvLnNpemU9cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+W3dpZHRoKCksaGVpZ2h0KCldKSxbXFxcInhcXFwiLGJsYW5rXSxbXFxcInlcXFwiLGJsYW5rXSkpKSxkZWYoKChlLG8pPT5sLnNldChvLG5ldyBBcnJheSgyKSkpKSksby50b3A9cHJvcGVydHkoZGVmKCgoKT0+ZmxvYXQoaGVpZ2h0KCkvMikpKSksby5ib3R0b209cHJvcGVydHkoZGVmKCgoKT0+ZmxvYXQoaGVpZ2h0KCkvLTIpKSkpLG8ubGVmdD1wcm9wZXJ0eShkZWYoKCgpPT5mbG9hdCh3aWR0aCgpLy0yKSkpKSxvLnJpZ2h0PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHdpZHRoKCkvMikpKSksby5yZXNpemU9cHJvcGVydHkoZGVmKChlPT5ib29sKGUuJHJlc2l6ZSkpKSl9KSxcXFwiV2luZG93XFxcIikpLG8uY3Vyc29yPWNhbGwoYnVpbGQoKChlLG8pPT57by54PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHgoKSkpKSksby55PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHkoKSkpKSksby5wb3M9by5wb3NpdGlvbj1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5beCgpLHkoKV0pLFtcXFwieFxcXCIsYmxhbmtdLFtcXFwieVxcXCIsYmxhbmtdKSkpLGRlZigoKGUsbyk9Pmwuc2V0KG8sbmV3IEFycmF5KDIpKSkpKSxvLm1vdmU9cHJvcGVydHkoZGVmKChlPT5ib29sKGUuJG1vdmUpKSkpLG8uZW50ZXI9cHJvcGVydHkoZGVmKChlPT5ib29sKGUuJGVudGVyKSkpKSxvLmxlYXZlPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRsZWF2ZSkpKSksby5wcmVzcz1wcm9wZXJ0eShkZWYoKGU9PmJvb2woZS4kcHJlc3MpKSkpLG8ucmVsZWFzZT1wcm9wZXJ0eShkZWYoKGU9PmJvb2woZS4kcmVsZWFzZSkpKSksby5ob2xkPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRob2xkKSkpKX0pLFxcXCJDdXJzb3JcXFwiKSksby5jdXJzb3IuJHg9MCxvLmN1cnNvci4keT0wLG8ua2V5PWNhbGwoYnVpbGQoKChlLG8pPT57by5fX2dldGF0dHJfXz1kZWYoKChlLG8pPT57Y29uc3QgdD1lLiRkYXRhW28udl07aWYodClyZXR1cm4gdC5ob2xkfHx0LnJlbGVhc2U/KHI9W3N0cihcXFwicHJlc3NcXFwiKSxib29sKHQucHJlc3MpLHN0cihcXFwicmVsZWFzZVxcXCIpLGJvb2wodC5yZWxlYXNlKSxzdHIoXFxcInJlcGVhdFxcXCIpLGJvb2wodC5yZXBlYXQpXSxuZXcgU2suYnVpbHRpbi5kaWN0KHIpKTpTay5idWlsdGluLmJvb2wuZmFsc2UkO3ZhciByfSkpLG8uaG9sZD1wcm9wZXJ0eShkZWYoKGU9Pntmb3IoY29uc3QgbyBpbiBlLiRkYXRhKWlmKGUuJGRhdGFbb10uaG9sZClyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO3JldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkfSkpKSxvLnByZXNzPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRwcmVzcykpKSksby5yZWxlYXNlPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRyZWxlYXNlKSkpKSxvLnJlcGVhdD1wcm9wZXJ0eShkZWYoKGU9PmJvb2woZS4kcmVwZWF0KSkpKX0pLFxcXCJLZXlcXFwiKSksby5rZXkuJGRhdGE9e3NwYWNlOntjb2RlOlxcXCJTcGFjZVxcXCJ9LGFwb3N0cm9waGU6e2NvZGU6XFxcIlF1b3RlXFxcIn0sY29tbWE6e2NvZGU6XFxcIkNvbW1hXFxcIn0sbWludXM6e2NvZGU6XFxcIk1pbnVzXFxcIn0scGVyaW9kOntjb2RlOlxcXCJQZXJpb2RcXFwifSxzbGFzaDp7Y29kZTpcXFwiU2xhc2hcXFwifSxfMDp7Y29kZTpcXFwiRGlnaXQwXFxcIn0sXzE6e2NvZGU6XFxcIkRpZ2l0MVxcXCJ9LF8yOntjb2RlOlxcXCJEaWdpdDJcXFwifSxfMzp7Y29kZTpcXFwiRGlnaXQzXFxcIn0sXzQ6e2NvZGU6XFxcIkRpZ2l0NFxcXCJ9LF81Ontjb2RlOlxcXCJEaWdpdDVcXFwifSxfNjp7Y29kZTpcXFwiRGlnaXQ2XFxcIn0sXzc6e2NvZGU6XFxcIkRpZ2l0N1xcXCJ9LF84Ontjb2RlOlxcXCJEaWdpdDhcXFwifSxfOTp7Y29kZTpcXFwiRGlnaXQ5XFxcIn0sc2VtaWNvbG9uOntjb2RlOlxcXCJTZW1pY29sb25cXFwifSxlcXVhbDp7Y29kZTpcXFwiRXF1YWxcXFwifSxhOntjb2RlOlxcXCJLZXlBXFxcIn0sYjp7Y29kZTpcXFwiS2V5QlxcXCJ9LGM6e2NvZGU6XFxcIktleUNcXFwifSxkOntjb2RlOlxcXCJLZXlEXFxcIn0sZTp7Y29kZTpcXFwiS2V5RVxcXCJ9LGY6e2NvZGU6XFxcIktleUZcXFwifSxnOntjb2RlOlxcXCJLZXlHXFxcIn0saDp7Y29kZTpcXFwiS2V5SFxcXCJ9LGk6e2NvZGU6XFxcIktleUlcXFwifSxqOntjb2RlOlxcXCJLZXlKXFxcIn0sazp7Y29kZTpcXFwiS2V5S1xcXCJ9LGw6e2NvZGU6XFxcIktleUxcXFwifSxtOntjb2RlOlxcXCJLZXlNXFxcIn0sbjp7Y29kZTpcXFwiS2V5TlxcXCJ9LG86e2NvZGU6XFxcIktleU9cXFwifSxwOntjb2RlOlxcXCJLZXlQXFxcIn0scTp7Y29kZTpcXFwiS2V5UVxcXCJ9LHI6e2NvZGU6XFxcIktleVJcXFwifSxzOntjb2RlOlxcXCJLZXlTXFxcIn0sdDp7Y29kZTpcXFwiS2V5VFxcXCJ9LHU6e2NvZGU6XFxcIktleVVcXFwifSx2Ontjb2RlOlxcXCJLZXlWXFxcIn0sdzp7Y29kZTpcXFwiS2V5V1xcXCJ9LHg6e2NvZGU6XFxcIktleVhcXFwifSx5Ontjb2RlOlxcXCJLZXlZXFxcIn0sejp7Y29kZTpcXFwiS2V5WlxcXCJ9LGxlZnRfYnJhY2tldDp7Y29kZTpcXFwiQnJhY2tldExlZnRcXFwifSxiYWNrc2xhc2g6e2NvZGU6XFxcIkJhY2tzbGFzaFxcXCJ9LHJpZ2h0X2JyYWNrZXQ6e2NvZGU6XFxcIkJyYWNrZXRSaWdodFxcXCJ9LGJhY2txdW90ZTp7Y29kZTpcXFwiQmFja3F1b3RlXFxcIn0sZXNjYXBlOntjb2RlOlxcXCJFc2NhcGVcXFwifSxlbnRlcjp7Y29kZTpcXFwiRW50ZXJcXFwifSx0YWI6e2NvZGU6XFxcIlRhYlxcXCJ9LGJhY2tzcGFjZTp7Y29kZTpcXFwiQmFja3NwYWNlXFxcIn0saW5zZXJ0Ontjb2RlOlxcXCJJbnNlcnRcXFwifSxkZWxldGU6e2NvZGU6XFxcIkRlbGV0ZVxcXCJ9LHJpZ2h0Ontjb2RlOlxcXCJBcnJvd1JpZ2h0XFxcIn0sbGVmdDp7Y29kZTpcXFwiQXJyb3dMZWZ0XFxcIn0sZG93bjp7Y29kZTpcXFwiQXJyb3dEb3duXFxcIn0sdXA6e2NvZGU6XFxcIkFycm93VXBcXFwifSxwYWdlX3VwOntjb2RlOlxcXCJQYWdlVXBcXFwifSxwYWdlX2Rvd246e2NvZGU6XFxcIlBhZ2VEb3duXFxcIn0saG9tZTp7Y29kZTpcXFwiSG9tZVxcXCJ9LGVuZDp7Y29kZTpcXFwiRW5kXFxcIn0sY2Fwc19sb2NrOntjb2RlOlxcXCJDYXBzTG9ja1xcXCJ9LHNjcm9sbF9sb2NrOntjb2RlOlxcXCJTY3JvbGxMb2NrXFxcIn0sbnVtX2xvY2s6e2NvZGU6XFxcIk51bUxvY2tcXFwifSxwcmludF9zY3JlZW46e2NvZGU6XFxcIlByaW50U2NyZWVuXFxcIn0scGF1c2U6e2NvZGU6XFxcIlBhdXNlXFxcIn0sZjE6e2NvZGU6XFxcIkYxXFxcIn0sZjI6e2NvZGU6XFxcIkYyXFxcIn0sZjM6e2NvZGU6XFxcIkYzXFxcIn0sZjQ6e2NvZGU6XFxcIkY0XFxcIn0sZjU6e2NvZGU6XFxcIkY1XFxcIn0sZjY6e2NvZGU6XFxcIkY2XFxcIn0sZjc6e2NvZGU6XFxcIkY3XFxcIn0sZjg6e2NvZGU6XFxcIkY4XFxcIn0sZjk6e2NvZGU6XFxcIkY5XFxcIn0sZjEwOntjb2RlOlxcXCJGMTBcXFwifSxmMTE6e2NvZGU6XFxcIkYxMVxcXCJ9LGYxMjp7Y29kZTpcXFwiRjEyXFxcIn0sZjEzOntjb2RlOlxcXCJGMTNcXFwifSxmMTQ6e2NvZGU6XFxcIkYxNFxcXCJ9LGYxNTp7Y29kZTpcXFwiRjE1XFxcIn0sZjE2Ontjb2RlOlxcXCJGMTZcXFwifSxmMTc6e2NvZGU6XFxcIkYxN1xcXCJ9LGYxODp7Y29kZTpcXFwiRjE4XFxcIn0sZjE5Ontjb2RlOlxcXCJGMTlcXFwifSxmMjA6e2NvZGU6XFxcIkYyMFxcXCJ9LGYyMTp7Y29kZTpcXFwiRjIxXFxcIn0sZjIyOntjb2RlOlxcXCJGMjJcXFwifSxmMjM6e2NvZGU6XFxcIkYyM1xcXCJ9LGYyNDp7Y29kZTpcXFwiRjI0XFxcIn0sZjI1Ontjb2RlOlxcXCJGMjVcXFwifSxwYWRfMDp7Y29kZTpcXFwiTnVtcGFkMFxcXCJ9LHBhZF8xOntjb2RlOlxcXCJOdW1wYWQxXFxcIn0scGFkXzI6e2NvZGU6XFxcIk51bXBhZDJcXFwifSxwYWRfMzp7Y29kZTpcXFwiTnVtcGFkM1xcXCJ9LHBhZF80Ontjb2RlOlxcXCJOdW1wYWQ0XFxcIn0scGFkXzU6e2NvZGU6XFxcIk51bXBhZDVcXFwifSxwYWRfNjp7Y29kZTpcXFwiTnVtcGFkNlxcXCJ9LHBhZF83Ontjb2RlOlxcXCJOdW1wYWQ3XFxcIn0scGFkXzg6e2NvZGU6XFxcIk51bXBhZDhcXFwifSxwYWRfOTp7Y29kZTpcXFwiTnVtcGFkOVxcXCJ9LGRlY2ltYWw6e2NvZGU6XFxcIk51bXBhZERlY2ltYWxcXFwifSxkaXZpZGU6e2NvZGU6XFxcIk51bXBhZERpdmlkZVxcXCJ9LG11bHRpcGx5Ontjb2RlOlxcXCJOdW1wYWRNdWx0aXBseVxcXCJ9LHN1YnRyYWN0Ontjb2RlOlxcXCJOdW1wYWRTdWJ0cmFjdFxcXCJ9LGFkZDp7Y29kZTpcXFwiTnVtcGFkQWRkXFxcIn0sZW50ZXI6e2NvZGU6XFxcIk51bXBhZEVudGVyXFxcIn0sZXF1YWw6e2NvZGU6XFxcIk51bXBhZEVxdWFsXFxcIn0sbGVmdF9zaGlmdDp7Y29kZTpcXFwiU2hpZnRMZWZ0XFxcIn0sbGVmdF9jdHJsOntjb2RlOlxcXCJDb250cm9sTGVmdFxcXCJ9LGxlZnRfYWx0Ontjb2RlOlxcXCJBbHRMZWZ0XFxcIn0sbGVmdF9zdXBlcjp7Y29kZTpcXFwiU3VwZXJMZWZ0XFxcIn0scmlnaHRfc2hpZnQ6e2NvZGU6XFxcIlNoaWZ0UmlnaHRcXFwifSxyaWdodF9jdHJsOntjb2RlOlxcXCJDb250cm9sUmlnaHRcXFwifSxyaWdodF9hbHQ6e2NvZGU6XFxcIkFsdFJpZ2h0XFxcIn0scmlnaHRfc3VwZXI6e2NvZGU6XFxcIlN1cGVyUmlnaHRcXFwifSxtZW51Ontjb2RlOlxcXCJNZW51XFxcIn19LG8uY2FtZXJhPWNhbGwoYnVpbGQoKChlLG8pPT57Y29uc3QgaW5pdD0oZSxvLHQpPT57ZS4kcG9zPVtudW1iZXIobyksbnVtYmVyKHQpXX07aW5pdC4kZGVmYXVsdHM9W2ludCgpLGludCgpXSxpbml0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInhcXFwiLFxcXCJ5XFxcIl0sby5fX2luaXRfXz1kZWYoaW5pdCk7Y29uc3QgeD0oZSxvKT0+ZS4kcG9zWzBdPW51bWJlcihvKSx5PShlLG8pPT5lLiRwb3NbMV09bnVtYmVyKG8pO28ueD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHBvc1swXSkpKSxkZWYoeCkpLG8ueT1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHBvc1sxXSkpKSxkZWYoeSkpLG8ucG9zPW8ucG9zaXRpb249cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+ZS4kcG9zKSxbXFxcInhcXFwiLHhdLFtcXFwieVxcXCIseV0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRwb3MpKSkpfSksXFxcIkNhbWVyYVxcXCIpKSxvLlJlY3RhbmdsZT1idWlsZCgoKGUsbyk9Pntjb25zdCBpbml0PShlLG8sdCxyLG4sYSxjKT0+e3UubmV3KGUsbyx0LGEsYyksZS4kc2l6ZT1bbnVtYmVyKHIpLG51bWJlcihuKV0sZS4kdG9wPSgpPT57cmV0dXJuKG89Z2V0UmVjdFBvbHkoZSkpLnJlZHVjZSgoKGUsbyk9Pm9bMV0+ZT9vWzFdOmUpLG9bMF1bMV0pO3ZhciBvfSxlLiRsZWZ0PSgpPT57cmV0dXJuKG89Z2V0UmVjdFBvbHkoZSkpLnJlZHVjZSgoKGUsbyk9Pm9bMF08ZT9vWzBdOmUpLG9bMF1bMF0pO3ZhciBvfSxlLiRib3R0b209KCk9PntyZXR1cm4obz1nZXRSZWN0UG9seShlKSkucmVkdWNlKCgoZSxvKT0+b1sxXTxlP29bMV06ZSksb1swXVsxXSk7dmFyIG99LGUuJHJpZ2h0PSgpPT57cmV0dXJuKG89Z2V0UmVjdFBvbHkoZSkpLnJlZHVjZSgoKGUsbyk9Pm9bMF0+ZT9vWzBdOmUpLG9bMF1bMF0pO3ZhciBvfX07aW5pdC4kZGVmYXVsdHM9W2ludCgpLGludCgpLGludCg1MCksaW50KDUwKSxpbnQoKSx0dXBsZSgpXSxpbml0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInhcXFwiLFxcXCJ5XFxcIixcXFwid2lkdGhcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJhbmdsZVxcXCIsXFxcImNvbG9yXFxcIl0sby5fX2luaXRfXz1kZWYoaW5pdCksby5kcmF3PWRlZigoZT0+ZHJhd1NoYXBlKGUsZS4kc2l6ZSxjLG4uVFJJQU5HTEVfU1RSSVAsITEsNCkpKTtjb25zdCB3aWR0aD0oZSxvKT0+ZS4kc2l6ZVswXT1udW1iZXIobyksaGVpZ2h0PShlLG8pPT5lLiRzaXplWzFdPW51bWJlcihvKTtvLndpZHRoPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kc2l6ZVswXSkpKSxkZWYod2lkdGgpKSxvLmhlaWdodD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHNpemVbMV0pKSksZGVmKGhlaWdodCkpLG8uc2l6ZT1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5lLiRzaXplKSxbXFxcIndpZHRoXFxcIix3aWR0aF0sW1xcXCJoZWlnaHRcXFwiLGhlaWdodF0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRzaXplKSkpKX0pLFxcXCJSZWN0YW5nbGVcXFwiLFt1LmNsYXNzXSksby5JbWFnZT1idWlsZCgoKGUscik9Pntjb25zdCBpbml0PShlLHIsbixhLGMsaSxzLGQpPT53YWl0KCgodSwkKT0+e2NhbGwoby5SZWN0YW5nbGUucHJvdG90eXBlLl9faW5pdF9fLGUsbixhLGkscyxjKTtjb25zdCBwPXQuZmluZCgoZT0+ZS5uYW1lPT1zdHJpbmcocikpKSxzZXQ9bz0+e2UuJHRleHR1cmU9by5zb3VyY2UsZS4kc2l6ZVswXXx8PW8ud2lkdGgsZS4kc2l6ZVsxXXx8PW8uaGVpZ2h0fTtpZihlLiRjb2xvcj1sLnNldChkLFsxLDEsMSwxXSkscClyZXR1cm4gc2V0KHApLHUoKTtjb25zdCBtPW5ldyBJbWFnZTttLmNyb3NzT3JpZ2luPVxcXCJhbm9ueW1vdXNcXFwiLG0uc3JjPXN0cmluZyhyKSxtLm9uZXJyb3I9KCk9PiQobmV3IFNrLmJ1aWx0aW4uRmlsZU5vdEZvdW5kRXJyb3IoYGZhaWxlZCB0byBsb2FkIGltYWdlOiBcXFwiJHtzdHJpbmcocil9XFxcImApKSxtLm9ubG9hZD0oKT0+e2NvbnN0IGU9e25hbWU6c3RyaW5nKHIpLHdpZHRoOm0ud2lkdGgsaGVpZ2h0Om0uaGVpZ2h0LHNvdXJjZTpjcmVhdGVJbWFnZShtKX07dC5wdXNoKGUpLHNldChlKSx1KCl9fSkpO2luaXQuJGRlZmF1bHRzPVtvLk1BTixpbnQoKSxpbnQoKSxpbnQoKSxpbnQoKSxpbnQoKSx0dXBsZSgpXSxpbml0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcIm5hbWVcXFwiLFxcXCJ4XFxcIixcXFwieVxcXCIsXFxcImFuZ2xlXFxcIixcXFwid2lkdGhcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJjb2xvclxcXCJdLHIuX19pbml0X189ZGVmKGluaXQpLHIuZHJhdz1kZWYoKGU9PntuLmFjdGl2ZVRleHR1cmUobi5URVhUVVJFMCksbi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsZS4kdGV4dHVyZSksZHJhd1NoYXBlKGUsZS4kc2l6ZSxjLG4uVFJJQU5HTEVfU1RSSVAsITAsNCl9KSl9KSxcXFwiSW1hZ2VcXFwiLFtvLlJlY3RhbmdsZV0pLG8uVGV4dD1idWlsZCgoKGUsdCk9Pntjb25zdCBpbml0PShlLHQscixuLGEsYyxpLHMpPT53YWl0KCgoZCxsKT0+e2NhbGwoby5SZWN0YW5nbGUucHJvdG90eXBlLl9faW5pdF9fLGUscixuLGludCgpLGludCgpLGMsaSksZS4kZm9udD1zdHJpbmcocyksZS4kZm9udFNpemU9bnVtYmVyKGEpLGUuJGNvbnRlbnQ9c3RyaW5nKHQpLGxvYWRGb250KGUuJGZvbnQpLnRoZW4oKCgpPT57cmVuZGVyVGV4dChlKSxkKCl9KSkuY2F0Y2gobCl9KSk7aW5pdC4kZGVmYXVsdHM9W3N0cihcXFwiVGV4dFxcXCIpLGludCgpLGludCgpLGludCg1MCksaW50KCksdHVwbGUoKSxvLkRFRkFVTFRdLGluaXQuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIixcXFwiY29udGVudFxcXCIsXFxcInhcXFwiLFxcXCJ5XFxcIixcXFwiZm9udF9zaXplXFxcIixcXFwiYW5nbGVcXFwiLFxcXCJjb2xvclxcXCIsXFxcImZvbnRcXFwiXSx0Ll9faW5pdF9fPWRlZihpbml0KSx0LmRyYXc9ZGVmKChlPT57bi5hY3RpdmVUZXh0dXJlKG4uVEVYVFVSRTApLG4uYmluZFRleHR1cmUobi5URVhUVVJFXzJELGUuJHRleHR1cmUpLGRyYXdTaGFwZShlLGUuJHNpemUsYyxuLlRSSUFOR0xFX1NUUklQLCEwLDQpfSkpLHQuY29udGVudD1wcm9wZXJ0eShkZWYoKGU9PnN0cihlLiRjb250ZW50KSkpLGRlZigoKGUsbyk9PntlLiRjb250ZW50PXN0cmluZyhvKSxyZW5kZXJUZXh0KGUpfSkpKSx0LmZvbnQ9cHJvcGVydHkoZGVmKChlPT5zdHIoZS4kZm9udCkpKSxkZWYoKChlLG8pPT53YWl0KCgodCxyKT0+e2xvYWRGb250KGUuJGZvbnQ9c3RyaW5nKG8pKS50aGVuKCgoKT0+e3JlbmRlclRleHQoZSksdCgpfSkpLmNhdGNoKHIpfSkpKSkpLHQuZm9udF9zaXplPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kZm9udF9zaXplKSkpLGRlZigoKGUsbyk9PntlLiRmb250X3NpemU9bnVtYmVyKG8pLHJlbmRlclRleHQoZSl9KSkpfSksXFxcIlRleHRcXFwiLFtvLlJlY3RhbmdsZV0pLG8ucmFuZG9tPWRlZigoKGUsbyk9Pntjb25zdCB0PU1hdGgubWluKG51bWJlcihlKSxudW1iZXIobykpO3JldHVybiBmbG9hdChNYXRoLnJhbmRvbSgpKihNYXRoLm1heChudW1iZXIoZSksbnVtYmVyKG8pKS10KSt0KX0pKSxvLnJ1bj1kZWYoKCgpPT53YWl0KCgocixpKT0+e2NvbnN0IHVwZGF0ZT0oKT0+e2NvbnN0IGZpbmFsPW89PntuLmRlbGV0ZUJ1ZmZlcihjKSxuLmRlbGV0ZVByb2dyYW0oYSksdC5mb3JFYWNoKChlPT5uLmRlbGV0ZVRleHR1cmUoZS5zb3VyY2UpKSksZC5kaXNjb25uZWN0KCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJtb3VzZWVudGVyXFxcIixtb3VzZUVudGVyKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIm1vdXNlbGVhdmVcXFwiLG1vdXNlTGVhdmUpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwibW91c2Vkb3duXFxcIixtb3VzZURvd24pLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwibW91c2V1cFxcXCIsbW91c2VVcCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJtb3VzZW1vdmVcXFwiLG1vdXNlTW92ZSksZS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJrZXlkb3duXFxcIixrZXlEb3duKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImtleXVwXFxcIixrZXlVcCksY2FuY2VsQW5pbWF0aW9uRnJhbWUocy5mcmFtZSksbz9pKG8pOnIoKX07aWYoby53aW5kb3cuJGNsb3NlfHxEYXRlLm5vdygpLVNrLmV4ZWNTdGFydD5Tay5leGVjTGltaXQpcmV0dXJuIGZpbmFsKCk7Y29uc3QgbD1vLmNhbWVyYS4kcG9zWzBdLHU9by5jYW1lcmEuJHBvc1sxXSwkPW5ldyBGbG9hdDMyQXJyYXkoWzIvd2lkdGgoKSwwLDAsMCwwLDIvaGVpZ2h0KCksMCwwLDAsMCwtMiwwLDIqLWwvd2lkdGgoKSwyKi11L2hlaWdodCgpLC0xLDFdKTtuLnVuaWZvcm1NYXRyaXg0ZnYobi5nZXRVbmlmb3JtTG9jYXRpb24oYSxcXFwiY2FtZXJhXFxcIiksITEsJCksbi5jbGVhcihuLkNPTE9SX0JVRkZFUl9CSVQpO3RyeXtzLm1haW4uJGQubG9vcCYmY2FsbChzLm1haW4uJGQubG9vcCl9Y2F0Y2gocCl7ZmluYWwocCl9by53aW5kb3cuJHJlc2l6ZT0hMSxvLmN1cnNvci4kbW92ZT0hMSxvLmN1cnNvci4kZW50ZXI9ITEsby5jdXJzb3IuJGxlYXZlPSExLG8uY3Vyc29yLiRwcmVzcz0hMSxvLmN1cnNvci4kcmVsZWFzZT0hMSxvLmtleS4kcHJlc3M9ITEsby5rZXkuJHJlbGVhc2U9ITEsby5rZXkuJHJlcGVhdD0hMTtmb3IoY29uc3QgZSBpbiBvLmtleS4kZGF0YSlvLmtleS4kZGF0YVtlXS5wcmVzcz0hMSxvLmtleS4kZGF0YVtlXS5yZWxlYXNlPSExLG8ua2V5LiRkYXRhW2VdLnJlcGVhdD0hMX0sbG9vcD0oKT0+e3MuZnJhbWU9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApLHVwZGF0ZSgpfSxzPXttYWluOlNrLmltcG9ydE1vZHVsZShcXFwiX19tYWluX19cXFwiLCExLCEwKSxmcmFtZTpyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCl9LGQ9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCgpPT57bi52aWV3cG9ydCgwLDAsZS53aWR0aCxlLmhlaWdodCksby53aW5kb3cuJHJlc2l6ZT0hMCx1cGRhdGUoKX0pKTtkLm9ic2VydmUoZSx7YXR0cmlidXRlczohMH0pfSkpKSksZS5hZGRFdmVudExpc3RlbmVyKFxcXCJtb3VzZWVudGVyXFxcIixtb3VzZUVudGVyKSxlLmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1vdXNlbGVhdmVcXFwiLG1vdXNlTGVhdmUpLGUuYWRkRXZlbnRMaXN0ZW5lcihcXFwibW91c2Vkb3duXFxcIixtb3VzZURvd24pLGUuYWRkRXZlbnRMaXN0ZW5lcihcXFwibW91c2V1cFxcXCIsbW91c2VVcCksZS5hZGRFdmVudExpc3RlbmVyKFxcXCJtb3VzZW1vdmVcXFwiLG1vdXNlTW92ZSksZS5hZGRFdmVudExpc3RlbmVyKFxcXCJrZXlkb3duXFxcIixrZXlEb3duKSxlLmFkZEV2ZW50TGlzdGVuZXIoXFxcImtleXVwXFxcIixrZXlVcCksZS50YWJJbmRleD0wLGUuZm9jdXMoKSxuLnNoYWRlclNvdXJjZShpLFxcXCJcXFxcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgdmVydGV4O1xcXFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBjb29yZGluYXRlO1xcXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgcG9zaXRpb247XFxcXG4gICAgICAgIFxcXFxuICAgICAgICB1bmlmb3JtIG1hdDQgY2FtZXJhO1xcXFxuICAgICAgICB1bmlmb3JtIG1hdDQgb2JqZWN0O1xcXFxuICAgICAgICBcXFxcbiAgICAgICAgdm9pZCBtYWluKHZvaWQpIHtcXFxcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gY2FtZXJhICogb2JqZWN0ICogdmVjNCh2ZXJ0ZXgsIDAsIDEpO1xcXFxuICAgICAgICAgICAgcG9zaXRpb24gPSBjb29yZGluYXRlO1xcXFxuICAgICAgICB9XFxcIiksbi5zaGFkZXJTb3VyY2UocyxcXFwiXFxcXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgcG9zaXRpb247XFxcXG5cXFxcbiAgICAgICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xcXFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyO1xcXFxuICAgICAgICB1bmlmb3JtIGludCBpbWFnZTtcXFxcblxcXFxuICAgICAgICB2b2lkIG1haW4odm9pZCkge1xcXFxuICAgICAgICAgICAgaWYgKGltYWdlID09IDEpIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChzYW1wbGVyLCBwb3NpdGlvbikgKiBjb2xvcjtcXFxcbiAgICAgICAgICAgIGVsc2UgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxcXG4gICAgICAgIH1cXFwiKSxuLmNvbXBpbGVTaGFkZXIoaSksbi5jb21waWxlU2hhZGVyKHMpLG4uYXR0YWNoU2hhZGVyKGEsaSksbi5hdHRhY2hTaGFkZXIoYSxzKSxuLmxpbmtQcm9ncmFtKGEpLG4udXNlUHJvZ3JhbShhKSxuLnVuaWZvcm0xaShuLmdldFVuaWZvcm1Mb2NhdGlvbihhLFxcXCJzYW1wbGVyXFxcIiksMCksbi5kZWxldGVTaGFkZXIoaSksbi5kZWxldGVTaGFkZXIocyksbi5iaW5kQnVmZmVyKG4uQVJSQVlfQlVGRkVSLGMpLG4uYnVmZmVyRGF0YShuLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KFstLjUsLjUsMCwwLC41LC41LDEsMCwtLjUsLS41LDAsMSwuNSwtLjUsMSwxXSksbi5TVEFUSUNfRFJBVyksbi52ZXJ0ZXhBdHRyaWJQb2ludGVyKG4uZ2V0QXR0cmliTG9jYXRpb24oYSxcXFwidmVydGV4XFxcIiksMixuLkZMT0FULCExLDE2LDApLG4udmVydGV4QXR0cmliUG9pbnRlcihuLmdldEF0dHJpYkxvY2F0aW9uKGEsXFxcImNvb3JkaW5hdGVcXFwiKSwyLG4uRkxPQVQsITEsMTYsOCksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDEpLG4uZW5hYmxlKG4uQkxFTkQpLG4uYmxlbmRGdW5jKG4uU1JDX0FMUEhBLG4uT05FX01JTlVTX1NSQ19BTFBIQSksbi5waXhlbFN0b3JlaShuLlVOUEFDS19BTElHTk1FTlQsMSksb307XCIsXCJzcmMvbGliL19zdHJwdGltZS5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUoKXtjb25zdCBlPVNrLmJ1aWx0aW4uaW50Xyx0PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCxpPVNrLmJ1aWx0aW4uc3RyLHM9U2suYnVpbHRpbi50dXBsZSxuPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSx7aXNUcnVlOmEscmljaENvbXBhcmVCb29sOnIsY2hhaW46bH09U2subWlzY2V2YWwse3R5cGVOYW1lOm8sc2V0VXBNb2R1bGVNZXRob2RzOl8sYnVpbGROYXRpdmVDbGFzczpjfT1Tay5hYnN0cix7VHlwZUVycm9yOm0sVmFsdWVFcnJvcjpkLEtleUVycm9yOmgsSW5kZXhFcnJvcjpmLGNoZWNrU3RyaW5nOnUsYXNudW0kOnd9PVNrLmJ1aWx0aW4se3JlbWFwVG9QeTpwLHJlbWFwVG9KczpnfT1Tay5mZmkse2dldEF0dHI6JCxzZXRBdHRyOnl9PVNrLmdlbmVyaWMsUz1sLGs9L15bMC05XSskLztmdW5jdGlvbiBfYXNfaW50ZWdlcihlKXtpZighay50ZXN0KGUpKXRocm93IG5ldyBkKGBpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSAxMDogJyR7ZX0nYCk7cmV0dXJuIHBhcnNlSW50KGUpfWNvbnN0IGI9LyhbXFxcXFxcXFwuXiQqKz9cXFxcKFxcXFwpe31cXFxcW1xcXFxdfF0pL2csdj0vXFxcXHMrL2c7bGV0IE89U2suaW1wb3J0TW9kdWxlKFxcXCJ0aW1lXFxcIiwhMSwhMCksej1Tay5pbXBvcnRNb2R1bGUoXFxcImRhdGV0aW1lXFxcIiwhMSwhMCk7Y29uc3QgTD1TKHosKGU9Pih6PWUuJGQsTykpLChlPT57Tz1lLiRkfSkpO3JldHVybiBTKEwsKCgpPT57ZnVuY3Rpb24gX3N0cmZ0aW1lKGUpe3JldHVybiB0PT5lLiRzdHJmdGltZSh0KS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gX3N0cmZ0aW1lX3RpbWV0dXBsZShlLHQpe3JldHVybiBPLnN0cmZ0aW1lLnRwJGNhbGwoW25ldyBpKGUpLHRdKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCl9Y29uc3QgbD1uZXcgaShcXFwiZnJvbW9yZGluYWxcXFwiKTtmdW5jdGlvbiBfc3RydWN0X3RpbWUodCl7cmV0dXJuIE8uc3RydWN0X3RpbWUudHAkY2FsbChbbmV3IHModC5tYXAoKHQ9Pm5ldyBlKHQpKSkpXSl9ZnVuY3Rpb24gX2xvY2FsaXplZF9tb250aCgpe2NvbnN0IGU9WygpPT5cXFwiXFxcIl07Zm9yKGxldCB0PTA7dDwxMjt0Kyspe2NvbnN0IGk9bmV3IGsoMjAwMSx0KzEsMSk7ZS5wdXNoKF9zdHJmdGltZShpKSl9cmV0dXJuIGV9ZnVuY3Rpb24gX2xvY2FsaXplZF9kYXkoKXtjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8Nzt0Kyspe2NvbnN0IGk9bmV3IGsoMjAwMSwxLHQrMSk7ZS5wdXNoKF9zdHJmdGltZShpKSl9cmV0dXJuIGV9Y29uc3QgUz17X19uYW1lX186bmV3IGkoXFxcIl9zdHJwdGltZVxcXCIpfSxrPXouZGF0ZSxMPXoudGltZWRlbHRhLEU9ei50aW1lem9uZTtmdW5jdGlvbiBfZ2V0bGFuZygpe3JldHVyblt0LHRdfWNsYXNzIExvY2FsZVRpbWV7Y29uc3RydWN0b3IoKXt0aGlzLmxhbmc9X2dldGxhbmcoKSx0aGlzLl9fY2FsY193ZWVrZGF5KCksdGhpcy5fX2NhbGNfbW9udGgoKSx0aGlzLl9fY2FsY19hbV9wbSgpLHRoaXMuX19jYWxjX3RpbWV6b25lKCksdGhpcy5fX2NhbGNfZGF0ZV90aW1lKCl9X19jYWxjX3dlZWtkYXkoKXt0aGlzLmFfd2Vla2RheT1fbG9jYWxpemVkX2RheSgpLm1hcCgoZT0+ZShcXFwiJWFcXFwiKSkpLHRoaXMuZl93ZWVrZGF5PV9sb2NhbGl6ZWRfZGF5KCkubWFwKChlPT5lKFxcXCIlQVxcXCIpKSl9X19jYWxjX21vbnRoKCl7dGhpcy5hX21vbnRoPV9sb2NhbGl6ZWRfbW9udGgoKS5tYXAoKGU9PmUoXFxcIiViXFxcIikpKSx0aGlzLmZfbW9udGg9X2xvY2FsaXplZF9tb250aCgpLm1hcCgoZT0+ZShcXFwiJUJcXFwiKSkpfV9fY2FsY19hbV9wbSgpe2NvbnN0IGU9W107WzEsMjJdLmZvckVhY2goKHQ9Pntjb25zdCBpPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiVwXFxcIixfc3RydWN0X3RpbWUoWzE5OTksMywxNyx0LDQ0LDU1LDIsNzYsMF0pKTtlLnB1c2goaSl9KSksdGhpcy5hbV9wbT1lfV9fY2FsY19kYXRlX3RpbWUoKXtjb25zdCBlPV9zdHJ1Y3RfdGltZShbMTk5OSwzLDE3LDIyLDQ0LDU1LDIsNzYsMF0pLGk9W3QsdCx0XTtpWzBdPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiVjXFxcIixlKSxpWzFdPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiV4XFxcIixlKSxpWzJdPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiVYXFxcIixlKTtjb25zdCBzPVtbXFxcIiVcXFwiLFxcXCIlJVxcXCJdLFt0aGlzLmZfd2Vla2RheVsyXSxcXFwiJUFcXFwiXSxbdGhpcy5mX21vbnRoWzNdLFxcXCIlQlxcXCJdLFt0aGlzLmFfd2Vla2RheVsyXSxcXFwiJWFcXFwiXSxbdGhpcy5hX21vbnRoWzNdLFxcXCIlYlxcXCJdLFt0aGlzLmFtX3BtWzFdLFxcXCIlcFxcXCJdLFtcXFwiMTk5OVxcXCIsXFxcIiVZXFxcIl0sW1xcXCI5OVxcXCIsXFxcIiV5XFxcIl0sW1xcXCIyMlxcXCIsXFxcIiVIXFxcIl0sW1xcXCI0NFxcXCIsXFxcIiVNXFxcIl0sW1xcXCI1NVxcXCIsXFxcIiVTXFxcIl0sW1xcXCI3NlxcXCIsXFxcIiVqXFxcIl0sW1xcXCIxN1xcXCIsXFxcIiVkXFxcIl0sW1xcXCIwM1xcXCIsXFxcIiVtXFxcIl0sW1xcXCIzXFxcIixcXFwiJW1cXFwiXSxbXFxcIjJcXFwiLFxcXCIld1xcXCJdLFtcXFwiMTBcXFwiLFxcXCIlSVxcXCJdXTtzLnB1c2goLi4udGhpcy50aW1lem9uZS5mbGF0KCkubWFwKChlPT5bZSxcXFwiJVpcXFwiXSkpKSxbWzAsXFxcIiVjXFxcIl0sWzEsXFxcIiV4XFxcIl0sWzIsXFxcIiVYXFxcIl1dLmZvckVhY2goKChbZSx0XSk9PntsZXQgbj1pW2VdO3MuZm9yRWFjaCgoKFtlLHRdKT0+e2UmJihuPW4ucmVwbGFjZShlLHQpKX0pKTtsZXQgYTthPV9zdHJmdGltZV90aW1ldHVwbGUodCxfc3RydWN0X3RpbWUoWzE5OTksMSwzLDEsMSwxLDYsMywwXSkpLmluY2x1ZGVzKFxcXCIwMFxcXCIpP1xcXCIlV1xcXCI6XFxcIiVVXFxcIixpW2VdPW4ucmVwbGFjZShcXFwiMTFcXFwiLGEpfSkpLHRoaXMuTENfZGF0ZV90aW1lPWlbMF0sdGhpcy5MQ19kYXRlPWlbMV0sdGhpcy5MQ190aW1lPWlbMl19X19jYWxjX3RpbWV6b25lKCl7dHJ5e08udHpzZXQudHAkY2FsbChbXSl9Y2F0Y2h7fXRoaXMudHpuYW1lPU8udHpuYW1lLnYubWFwKChlPT5lLnRvU3RyaW5nKCkpKSx0aGlzLmRheWxpZ2h0PXcoTy5kYXlsaWdodCk7Y29uc3QgZT1bdGhpcy50em5hbWVbMF0udG9Mb3dlckNhc2UoKSxcXFwidXRjXFxcIixcXFwiZ210XFxcIl07bGV0IHQ7dD10aGlzLmRheWxpZ2h0P1t0aGlzLnR6bmFtZVsxXS50b0xvd2VyQ2FzZSgpXTpbXSx0aGlzLnRpbWV6b25lPVtlLHRdfX1jbGFzcyBUaW1lUkV7Y29uc3RydWN0b3IoZT1udWxsKXt0aGlzLmxvY2FsZV90aW1lPWV8fG5ldyBMb2NhbGVUaW1lLE9iamVjdC5hc3NpZ24odGhpcyx7ZDpcXFwiKD88ZD4zWzAtMV18WzEtMl1cXFxcXFxcXGR8MFsxLTldfFsxLTldfCBbMS05XSlcXFwiLGY6XFxcIig/PGY+WzAtOV17MSw2fSlcXFwiLEg6XFxcIig/PEg+MlswLTNdfFswLTFdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLEk6XFxcIig/PEk+MVswLTJdfDBbMS05XXxbMS05XSlcXFwiLEc6XFxcIig/PEc+XFxcXFxcXFxkXFxcXFxcXFxkXFxcXFxcXFxkXFxcXFxcXFxkKVxcXCIsajpcXFwiKD88aj4zNlswLTZdfDNbMC01XVxcXFxcXFxcZHxbMS0yXVxcXFxcXFxcZFxcXFxcXFxcZHwwWzEtOV1cXFxcXFxcXGR8MDBbMS05XXxbMS05XVxcXFxcXFxcZHwwWzEtOV18WzEtOV0pXFxcIixtOlxcXCIoPzxtPjFbMC0yXXwwWzEtOV18WzEtOV0pXFxcIixNOlxcXCIoPzxNPlswLTVdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLFM6XFxcIig/PFM+NlswLTFdfFswLTVdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLFU6XFxcIig/PFU+NVswLTNdfFswLTRdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLHc6XFxcIig/PHc+WzAtNl0pXFxcIix1OlxcXCIoPzx1PlsxLTddKVxcXCIsVjpcXFwiKD88Vj41WzAtM118MFsxLTldfFsxLTRdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLHk6XFxcIig/PHk+XFxcXFxcXFxkXFxcXFxcXFxkKVxcXCIsWTpcXFwiKD88WT5cXFxcXFxcXGRcXFxcXFxcXGRcXFxcXFxcXGRcXFxcXFxcXGQpXFxcIix6OlxcXCIoPzx6PlsrLV1cXFxcXFxcXGRcXFxcXFxcXGQ6P1swLTVdXFxcXFxcXFxkKDo/WzAtNV1cXFxcXFxcXGQoXFxcXFxcXFwuXFxcXFxcXFxkezEsNn0pPyk/fFopXFxcIixBOnRoaXMuX19zZXFUb1JFKHRoaXMubG9jYWxlX3RpbWUuZl93ZWVrZGF5LFxcXCJBXFxcIiksYTp0aGlzLl9fc2VxVG9SRSh0aGlzLmxvY2FsZV90aW1lLmFfd2Vla2RheSxcXFwiYVxcXCIpLEI6dGhpcy5fX3NlcVRvUkUodGhpcy5sb2NhbGVfdGltZS5mX21vbnRoLnNsaWNlKDEpLFxcXCJCXFxcIiksYjp0aGlzLl9fc2VxVG9SRSh0aGlzLmxvY2FsZV90aW1lLmFfbW9udGguc2xpY2UoMSksXFxcImJcXFwiKSxwOnRoaXMuX19zZXFUb1JFKHRoaXMubG9jYWxlX3RpbWUuYW1fcG0sXFxcInBcXFwiKSxaOnRoaXMuX19zZXFUb1JFKHRoaXMubG9jYWxlX3RpbWUudGltZXpvbmUuZmxhdCgpLFxcXCJaXFxcIiksXFxcIiVcXFwiOlxcXCIlXFxcIn0pLHRoaXMuVz10aGlzLlUucmVwbGFjZShcXFwiVVxcXCIsXFxcIldcXFwiKSx0aGlzLng9dGhpcy5wYXR0ZXJuKHRoaXMubG9jYWxlX3RpbWUuTENfZGF0ZSksdGhpcy5YPXRoaXMucGF0dGVybih0aGlzLmxvY2FsZV90aW1lLkxDX3RpbWUpLHRoaXMuYz10aGlzLnBhdHRlcm4odGhpcy5sb2NhbGVfdGltZS5MQ19kYXRlX3RpbWUpfV9fc2VxVG9SRShlLHQpe2lmKChlPWUuc2xpY2UoMCkuc29ydCgoKGUsdCk9PnQubGVuZ3RoLWUubGVuZ3RoKSkpLmV2ZXJ5KChlPT5cXFwiXFxcIj09PWUpKSlyZXR1cm5cXFwiXFxcIjtyZXR1cm5gKD88JHt0fT4ke2UubWFwKChlPT5lKSkuam9pbihcXFwifFxcXCIpfSlgfXBhdHRlcm4oZSl7bGV0IHQ9XFxcIlxcXCI7Zm9yKGU9KGU9ZS5yZXBsYWNlKGIsXFxcIlxcXFxcXFxcJDFcXFwiKSkucmVwbGFjZSh2LFxcXCJcXFxcXFxcXHMrXFxcIik7ZS5pbmNsdWRlcyhcXFwiJVxcXCIpOyl7Y29uc3QgaT1lLmluZGV4T2YoXFxcIiVcXFwiKSsxLHM9dGhpc1tlW2ldXTtpZih2b2lkIDA9PT1zKXRocm93IG5ldyBoKGVbaV0pO3Q9YCR7dH0ke2Uuc2xpY2UoMCxpLTEpfSR7c31gLGU9ZS5zbGljZShpKzEpfXJldHVybiB0K2V9Y29tcGlsZShlKXtyZXR1cm4gbmV3IFJlZ0V4cChcXFwiXlxcXCIrdGhpcy5wYXR0ZXJuKGUpLFxcXCJpXFxcIil9fWxldCBDPW5ldyBUaW1lUkU7bGV0IFQ9e307ZnVuY3Rpb24gX3N0cnB0aW1lKGkscz1cXFwiJWEgJWIgJWQgJUg6JU06JVMgJVlcXFwiKXtmdW5jdGlvbiBfY2hlY2tTdHJpbmcoZSx0KXtpZihcXFwic3RyaW5nXFxcIiE9dHlwZW9mIGUmJiF1KGUpKXRocm93IG5ldyBtKGBzdHJwdGltZSgpIGFyZ3VtZW50ICR7dH0gbXVzdCBiZSBhIHN0ciwgbm90ICcke28oZSl9J2ApfV9jaGVja1N0cmluZyhpLDApLF9jaGVja1N0cmluZyhzLDEpLGk9aS50b1N0cmluZygpLHM9cy50b1N0cmluZygpO2xldCBuLF89Qy5sb2NhbGVfdGltZTtpZihPYmplY3Qua2V5cyhUKS5sZW5ndGg+NSYmKFQ9e30pLG49VFtzXSx2b2lkIDA9PT1uKXRyeXtuPUMuY29tcGlsZShzKX1jYXRjaChSKXtpZihSIGluc3RhbmNlb2YgaCl7bGV0IGU9Ui5hcmdzLnZbMF07dGhyb3dcXFwiXFxcXFxcXFxcXFwiPT1lJiYoZT1cXFwiJVxcXCIpLG5ldyBkKGAnJHtlfScgaXMgYSBiYWQgZGlyZWN0aXZlIGluIGZvcm1hdCAnJHtzfSdgKX1pZihSIGluc3RhbmNlb2YgZil0aHJvdyBuZXcgZChcXFwic3RyYXkgJSUgaW4gZm9ybWF0ICdcXFwiK3MrXFxcIidcXFwiKTt0aHJvdyBSfWNvbnN0IGM9aS5tYXRjaChuKTtpZihudWxsPT09Yyl0aHJvdyBuZXcgZChgdGltZSBkYXRhICcke2l9JyBkb2VzIG5vdCBtYXRjaCBmb3JtYXQgJyR7c30nYCk7aWYoaS5sZW5ndGghPT1jWzBdLmxlbmd0aCl0aHJvdyBuZXcgZChgdW5jb252ZXJ0ZWQgZGF0YSByZW1haW5zOiAke2kuc2xpY2UoY1swXS5sZW5ndGgpfWApO2xldCB3PXQscD10LGc9MSwkPTEseT0wLFM9MCxiPTAsdj0wLHo9LTEsTD10LEU9MCxBPXQsST10LE09dCxIPXQsWT10LGo9Yy5ncm91cHN8fHt9O2lmKE9iamVjdC5rZXlzKGopLmZvckVhY2goKGU9PntpZih2b2lkIDAhPT1qW2VdKWlmKFxcXCJ5XFxcIj09PWUpcD1fYXNfaW50ZWdlcihqLnkpLHArPXA8PTY4PzJlMzoxOTAwO2Vsc2UgaWYoXFxcIllcXFwiPT09ZSlwPV9hc19pbnRlZ2VyKGouWSk7ZWxzZSBpZihcXFwiR1xcXCI9PT1lKXc9X2FzX2ludGVnZXIoai5HKTtlbHNlIGlmKFxcXCJtXFxcIj09PWUpZz1fYXNfaW50ZWdlcihqLm0pO2Vsc2UgaWYoXFxcIkJcXFwiPT09ZSlnPV8uZl9tb250aC5pbmRleE9mKGouQi50b0xvd2VyQ2FzZSgpKTtlbHNlIGlmKFxcXCJiXFxcIj09PWUpZz1fLmFfbW9udGguaW5kZXhPZihqLmIudG9Mb3dlckNhc2UoKSk7ZWxzZSBpZihcXFwiZFxcXCI9PT1lKSQ9X2FzX2ludGVnZXIoai5kKTtlbHNlIGlmKFxcXCJIXFxcIj09PWUpeT1fYXNfaW50ZWdlcihqLkgpO2Vsc2UgaWYoXFxcIkhcXFwiPT09ZSl5PV9hc19pbnRlZ2VyKGouSCk7ZWxzZSBpZihcXFwiSVxcXCI9PT1lKXt5PV9hc19pbnRlZ2VyKGouSSk7Y29uc3QgZT0oai5wfHxcXFwiXFxcIikudG9Mb3dlckNhc2UoKTtbXFxcIlxcXCIsXy5hbV9wbVswXV0uaW5jbHVkZXMoZSk/MTI9PT15JiYoeT0wKTplPT09Xy5hbV9wbVsxXSYmMTIhPT15JiYoeSs9MTIpfWVsc2UgaWYoXFxcIk1cXFwiPT09ZSlTPV9hc19pbnRlZ2VyKGouTSk7ZWxzZSBpZihcXFwiU1xcXCI9PT1lKWI9X2FzX2ludGVnZXIoai5TKTtlbHNlIGlmKFxcXCJmXFxcIj09PWUpe2xldCBlPWouZjtlKz1cXFwiMFxcXCIucmVwZWF0KDYtZS5sZW5ndGgpLHY9X2FzX2ludGVnZXIoZSl9ZWxzZSBpZihcXFwiQVxcXCI9PT1lKUg9Xy5mX3dlZWtkYXkuaW5kZXhPZihqLkEudG9Mb3dlckNhc2UoKSk7ZWxzZSBpZihcXFwiYVxcXCI9PT1lKUg9Xy5hX3dlZWtkYXkuaW5kZXhPZihqLmEudG9Mb3dlckNhc2UoKSk7ZWxzZSBpZihcXFwid1xcXCI9PT1lKUg9X2FzX2ludGVnZXIoai53KSwwPT09SD9IPTY6SC09MTtlbHNlIGlmKFxcXCJ1XFxcIj09PWUpSD1fYXNfaW50ZWdlcihqLnUpLEgtPTE7ZWxzZSBpZihcXFwialxcXCI9PT1lKVk9X2FzX2ludGVnZXIoai5qKTtlbHNlIGlmKFtcXFwiVVxcXCIsXFxcIldcXFwiXS5pbmNsdWRlcyhlKSlJPV9hc19pbnRlZ2VyKGpbZV0pLE09XFxcIlVcXFwiPT09ZT82OjA7ZWxzZSBpZihcXFwiVlxcXCI9PT1lKUE9X2FzX2ludGVnZXIoai5WKTtlbHNlIGlmKFxcXCJ6XFxcIj09PWUpe2xldCBlPWouejtpZihcXFwiWlxcXCI9PT1lKUw9MDtlbHNle2lmKFxcXCI6XFxcIj09PWVbM10mJihlPWUuc2xpY2UoMCwzKStlLnNsaWNlKDQpLGUubGVuZ3RoPjUpKXtpZihcXFwiOlxcXCIhPT1lWzVdKXtjb25zdCBlPWBJbmNvbnNpc3RlbnQgdXNlIG9mIDogaW4gJHtqLnp9YDt0aHJvdyBuZXcgZChlKX1lPWUuc2xpY2UoMCw1KStlLnNsaWNlKDYpfWNvbnN0IHQ9X2FzX2ludGVnZXIoZS5zbGljZSgxLDMpKSxpPV9hc19pbnRlZ2VyKGUuc2xpY2UoMyw1KSkscz1fYXNfaW50ZWdlcihlLnNsaWNlKDUsNyl8fDApO0w9MzYwMCp0KzYwKmkrcztjb25zdCBuPWUuc2xpY2UoOCksYT1cXFwiMFxcXCIucmVwZWF0KDYtbi5sZW5ndGgpO0U9X2FzX2ludGVnZXIobithKSxlLnN0YXJ0c1dpdGgoXFxcIi1cXFwiKSYmKEw9LUwsRT0tRSl9fWVsc2UgaWYoXFxcIlpcXFwiPT09ZSl7bGV0IGU9ai5aLnRvTG93ZXJDYXNlKCksdD0wO2ZvcihsZXQgaSBvZiBfLnRpbWV6b25lKXtpZihpLmluY2x1ZGVzKGUpKXtjb25zdCBpPU8udHpuYW1lLnY7aWYocihpWzBdLGlbMV0sXFxcIkVxXFxcIikmJmEoTy5kYXlsaWdodCkmJiFbXFxcInV0Y1xcXCIsXFxcImdtdFxcXCJdLmluY2x1ZGVzKGUpKWJyZWFrO3o9dH10Kyt9fX0pKSxwPT09dCYmdyE9PXQpe2lmKEE9PT10fHxIPT09dCl0aHJvdyBuZXcgZChcXFwiSVNPIHllYXIgZGlyZWN0aXZlICclRycgbXVzdCBiZSB1c2VkIHdpdGggdGhlIElTTyB3ZWVrIGRpcmVjdGl2ZSAnJVYnIGFuZCBhIHdlZWtkYXkgZGlyZWN0aXZlICgnJUEnLCclYScsICcldycsIG9yICcldScpLlxcXCIpO2lmKFkhPT10KXRocm93IG5ldyBkKFxcXCJEYXkgb2YgdGhlIHllYXIgZGlyZWN0aXZlICclaicgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBJU08geWVhciBkaXJlY3RpdmUgJyVHJy5Vc2UgJyVZJyBpbnN0ZWFkLlxcXCIpfWVsc2UgaWYoST09PXQmJkEhPT10KXRocm93IG5ldyBkKEg9PT10P1xcXCJJU08gd2VlayBkaXJlY3RpdmUgJyVWJyBtdXN0IGJlIHVzZWQgd2l0aCB0aGUgSVNPIHllYXIgZGlyZWN0aXZlICclRycgYW5kIGEgd2Vla2RheSBkaXJlY3RpdmUgKCclQScsICclYScsICcldycsIG9yICcldScpLlxcXCI6XFxcIklTTyB3ZWVrIGRpcmVjdGl2ZSAnJVYnIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSB5ZWFyIGRpcmVjdGl2ZSAnJVknLiBVc2UgdGhlIElTTyB5ZWFyICclRycgaW5zdGVhZC5cXFwiKTtsZXQgVT0hMTtpZihwPT09dCYmMj09PWcmJjI5PT09JD8ocD0xOTA0LFU9ITApOnA9PT10JiYocD0xOTAwKSxZPT09dCYmSCE9PXQpe2lmKEkhPT10KXtZPWZ1bmN0aW9uIF9jYWxjX2p1bGlhbl9mcm9tX1Vfb3JfVyhlLHQsaSxzKXtsZXQgbj0obmV3IGsoZSwxLDEpLiR0b09yZGluYWwoKSs2KSU3O3JldHVybiBzfHwobj0obisxKSU3LGk9KGkrMSklNyksMD09PXQ/MStpLW46KDctbiklNys3Kih0LTEpKzEraX0ocCxJLEgsMD09PU0pfWVsc2UgdyE9PXQmJkEhPT10JiYoW3AsWV09ZnVuY3Rpb24gX2NhbGNfanVsaWFuX2Zyb21fVihlLHQsaSl7bGV0IHM9Nyp0K2ktKChuZXcgayhlLDEsNCkuJHRvT3JkaW5hbCgpJTd8fDcpKzMpO3JldHVybiBzPDEmJihzKz1uZXcgayhlLDEsMSkuJHRvT3JkaW5hbCgpLHMtPW5ldyBrKGUtPTEsMSwxKS4kdG9PcmRpbmFsKCkpLFtlLHNdfSh3LEEsSCsxKSk7aWYoWSE9PXQmJlk8PTApe3AtPTE7Y29uc3QgZT1mdW5jdGlvbiBfaXNfbGVhcChlKXtyZXR1cm4gZSU0PT0wJiYoZSUxMDAhPTB8fGUlNDAwPT0wKX0ocCk/MzY2OjM2NTtZKz1lfX1pZihZPT09dClZPW5ldyBrKHAsZywkKS4kdG9PcmRpbmFsKCktbmV3IGsocCwxLDEpLiR0b09yZGluYWwoKSsxO2Vsc2V7Y29uc3QgdD1mdW5jdGlvbiBfZnJvbW9yZGluYWwodCl7cmV0dXJuIGsudHAkZ2V0YXR0cihsKS50cCRjYWxsKFtuZXcgZSh0KV0pfShZLTErbmV3IGsocCwxLDEpLiR0b09yZGluYWwoKSk7cD10LiR5ZWFyLGc9dC4kbW9udGgsJD10LiRkYXl9SD09PXQmJihIPShuZXcgayhwLGcsJCkuJHRvT3JkaW5hbCgpKzYpJTcpO2NvbnN0IHg9ai5afHx0O3JldHVybiBVJiYocD0xOTAwKSxbW3AsZywkLHksUyxiLEgsWSx6LHgsTF0sdixFXX1yZXR1cm4gXyhcXFwiX3N0cnB0aW1lXFxcIixTLHtfc3RycHRpbWVfdGltZTp7JG1ldGg6ZnVuY3Rpb24gX3N0cnB0aW1lX3RpbWUodCxpPVxcXCIlYSAlYiAlZCAlSDolTTolUyAlWVxcXCIpe2xldCBuPV9zdHJwdGltZSh0LGkpWzBdLnNsaWNlKDAsMTEpO3JldHVybiBuPW4ubWFwKCgodCxpKT0+aTw5P25ldyBlKHQpOnAodCkpKSxPLnN0cnVjdF90aW1lLnRwJGNhbGwoW25ldyBzKG4pXSl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwiZGF0YV9zdHJpbmdcXFwiLFxcXCJmb3JtYXRcXFwiXSxEZWZhdWx0czpbXFxcIiVhICViICVkICVIOiVNOiVTICVZXFxcIl19fSxfc3RycHRpbWVfZGF0ZXRpbWU6eyRtZXRoOmZ1bmN0aW9uIF9zdHJwdGltZV9kYXRldGltZShzLHIsbD1cXFwiJWEgJWIgJWQgJUg6JU06JVMgJVlcXFwiKXtjb25zdFtvLF8sY109X3N0cnB0aW1lKHIsbCksW20sZF09by5zbGljZSgtMiksaD1vLnNsaWNlKDAsNik7bGV0IGYsdTtyZXR1cm4gaC5wdXNoKF8pLGgubWFwKCh0PT5uZXcgZSh0KSkpLGQhPT10JiYoZj1uZXcgTCgwLGQsYyksdT1hKG0pP25ldyBFKGYsbmV3IGkobSkpOm5ldyBFKGYpLGgucHVzaCh1KSksbihzLGgpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcImNsc1xcXCIsXFxcImRhdGFfc3RyaW5nXFxcIixcXFwiZm9ybWF0XFxcIl0sRGVmYXVsdHM6W1xcXCIlYSAlYiAlZCAlSDolTTolUyAlWVxcXCJdfX0sX3N0cnB0aW1lOnskbWV0aChpLG4pe2NvbnN0IGE9X3N0cnB0aW1lKGksbik7cmV0dXJuIGFbMF09bmV3IHMoYVswXS5tYXAoKGk9Pmk9PT10P2k6bmV3IGUoaSkpKSksYVsxXT1uZXcgZShhWzFdKSxhWzJdPW5ldyBlKGFbMl0pLG5ldyBzKGEpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcImRhdGFfc3RyaW5nXFxcIixcXFwiZm9ybWF0XFxcIl0sRGVmYXVsdHM6W1xcXCIlYSAlYiAlZCAlSDolTTolUyAlWVxcXCJdfX0sX2dldGxhbmc6eyRtZXRoOigpPT5wKF9nZXRsYW5nKCkpLCRmbGFnczp7Tm9BcmdzOiEwfX19KSxTLkxvY2FsZVRpbWU9YyhcXFwiX3N0cnB0aW1lLkxvY2FsZVRpbWVcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbigpe3RoaXMudj1uZXcgTG9jYWxlVGltZX0sc2xvdHM6e3RwJGdldGF0dHIoZSx0KXtyZXR1cm4gdGhpcy52Lmhhc093blByb3BlcnR5KGUudG9TdHJpbmcoKSk/cCh0aGlzLnZbZS50b1N0cmluZygpXSk6JC5jYWxsKHRoaXMsZSx0KX0sdHAkc2V0YXR0cihlLHQpe2lmKCF0aGlzLnYuaGFzT3duUHJvcGVydHkoZS50b1N0cmluZygpKSlyZXR1cm4geS5jYWxsKHRoaXMsZSx0KTt0aGlzLnZbZS50b1N0cmluZygpXT1nKHQpfX19KSxTfSkpfVwiLFwic3JjL2xpYi9hbHRhaXIvdmVnYV9jYWxsZXIuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihlKXt2YXIgbj17X19maWxlX186XFxcIi9zcmMvbGliL3ZlZ2FfY2FsbGVyLmpzXFxcIn07cmV0dXJuIG4uX19wYWNrYWdlX189U2suYnVpbHRpbi5ub25lLm5vbmUkLG4ucmVuZGVyX2dyYXBoPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXFxcInJlbmRlcl9ncmFwaFxcXCIsYXJndW1lbnRzLDEsMSk7bGV0IG49XFxcIiNcXFwiK1NrLmRpdmlkK1xcXCJfZ3JhcGhpY3NcXFwiO3RyeXt2ZWdhRW1iZWQobixTay5mZmkucmVtYXBUb0pzKGUpLHthY3Rpb25zOiEwfSl9Y2F0Y2goaSl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJFcnJvciBpbiBncmFwaCBzcGVjaWZpY2F0aW9uIHVuYWJsZSB0byByZW5kZXIgdGhlIGdyYXBoXFxcXG5cXFwiK2kubWVzc2FnZSl9fSkpLG59O1wiLFwic3JjL2xpYi9hcnJheS5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUoZSl7dmFyIG49e30sdD1bXFxcImNcXFwiLFxcXCJiXFxcIixcXFwiQlxcXCIsXFxcInVcXFwiLFxcXCJoXFxcIixcXFwiSFxcXCIsXFxcImlcXFwiLFxcXCJJXFxcIixcXFwibFxcXCIsXFxcIkxcXFwiLFxcXCJmXFxcIixcXFwiZFxcXCJdO3JldHVybiBuLl9fbmFtZV9fPW5ldyBTay5idWlsdGluLnN0cihcXFwiYXJyYXlcXFwiKSxuLmFycmF5PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobiwoZnVuY3Rpb24oZSxuKXtuLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbixpKXtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDMpLC0xPT10LmluZGV4T2YoU2suZmZpLnJlbWFwVG9KcyhuKSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiYmFkIHR5cGVjb2RlIChtdXN0IGJlIGMsIGIsIEIsIHUsIGgsIEgsIGksIEksIGwsIEwsIGYgb3IgZClcXFwiKTtpZihpJiYhU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGkpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiaXRlcmF0aW9uIG92ZXIgbm9uLXNlcXVlbmNlXFxcIik7aWYoZS4kZC5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihcXFwidHlwZWNvZGVcXFwiKSxuKSxlLiRkLm1wJGFzc19zdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJfX21vZHVsZV9fXFxcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJhcnJheVxcXCIpKSxlLnR5cGVjb2RlPW4sdm9pZCAwPT09aSllLmludGVybmFsSXRlcmFibGU9bmV3IFNrLmJ1aWx0aW4ubGlzdDtlbHNlIGlmKGkgaW5zdGFuY2VvZiBTay5idWlsdGluLmxpc3QpZS5pbnRlcm5hbEl0ZXJhYmxlPWk7ZWxzZXtlLmludGVybmFsSXRlcmFibGU9bmV3IFNrLmJ1aWx0aW4ubGlzdDtmb3IobGV0IG49U2suYWJzdHIuaXRlcihpKSx0PW4udHAkaXRlcm5leHQoKTt2b2lkIDAhPT10O3Q9bi50cCRpdGVybmV4dCgpKVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLmludGVybmFsSXRlcmFibGUuYXBwZW5kLFtlLmludGVybmFsSXRlcmFibGUsdF0pfX0pKSxuLl9fcmVwcl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe3ZhciBuPVNrLmZmaS5yZW1hcFRvSnMoZS50eXBlY29kZSksdD1cXFwiXFxcIjtyZXR1cm4gU2suZmZpLnJlbWFwVG9KcyhlLmludGVybmFsSXRlcmFibGUpLmxlbmd0aCYmKHQ9XFxcImNcXFwiPT1Tay5mZmkucmVtYXBUb0pzKGUudHlwZWNvZGUpP1xcXCIsICdcXFwiK1NrLmZmaS5yZW1hcFRvSnMoZS5pbnRlcm5hbEl0ZXJhYmxlKS5qb2luKFxcXCJcXFwiKStcXFwiJ1xcXCI6XFxcIiwgXFxcIitTay5mZmkucmVtYXBUb0pzKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLmludGVybmFsSXRlcmFibGUuX19yZXByX18sW2UuaW50ZXJuYWxJdGVyYWJsZV0pKSksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJhcnJheSgnXFxcIituK1xcXCInXFxcIit0K1xcXCIpXFxcIil9KSksbi5fX3N0cl9fPW4uX19yZXByX18sbi5fX2dldGF0dHJpYnV0ZV9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGUudHAkZ2V0YXR0cihuKX0pKSxuLmFwcGVuZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4pe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZS5pbnRlcm5hbEl0ZXJhYmxlLmFwcGVuZCxbZS5pbnRlcm5hbEl0ZXJhYmxlLG5dKSxTay5idWlsdGluLm5vbmUubm9uZSR9KSksbi5leHRlbmQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuKXtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJpdGVyYXRpb24gb3ZlciBub24tc2VxdWVuY2VcXFwiKTtmb3IobGV0IHQ9U2suYWJzdHIuaXRlcihuKSxpPXQudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9dC50cCRpdGVybmV4dCgpKVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLmludGVybmFsSXRlcmFibGUuYXBwZW5kLFtlLmludGVybmFsSXRlcmFibGUsaV0pfSkpfSksXFxcImFycmF5XFxcIixbXSksbn1cIixcInNyYy9saWIvY2FsZW5kYXIuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKGUpe2NvbnN0IHQ9e30se21pc2NldmFsOntjaGFpbjpufSxpbXBvcnRNb2R1bGU6cn09U2ssaW1wb3J0T3JTdXNwZW5kPWU9PnIoZSwhMSwhMCk7cmV0dXJuIG4oaW1wb3J0T3JTdXNwZW5kKFxcXCJkYXRldGltZVxcXCIpLChlPT4odC5kYXRldGltZT1lLGltcG9ydE9yU3VzcGVuZChcXFwiaXRlcnRvb2xzXFxcIikpKSwoZT0+KHQuaXRlclJlcGVhdD1lLiRkLnJlcGVhdCx0Lml0ZXJDaGFpbj1lLiRkLmNoYWluLGNhbGVuZGFyTW9kdWxlKHQpKSkpfWZ1bmN0aW9uIGNhbGVuZGFyTW9kdWxlKGUpe2NvbnN0e2Fic3RyOntzZXRVcE1vZHVsZU1ldGhvZHM6dCxudW1iZXJCaW5PcDpuLGl0ZXI6cixvYmplY3RHZXRJdGVtOm99LGJ1aWx0aW46e2Jvb2w6cyxib29sOnt0cnVlJDptLGZhbHNlJDpkfSxmdW5jOmwsaW50XzppLGxpc3Q6Yyxub25lOntub25lJDpmfSxzdHI6aCxzbGljZTp3LHR1cGxlOnkscmFuZ2U6dSxtYXg6XyxtaW46Zyxwcm9wZXJ0eTprLHByaW50OnAsZW51bWVyYXRlOiQsVmFsdWVFcnJvcjpifSxmZmk6e3JlbWFwVG9QeTpNfSxtaXNjZXZhbDp7aXNUcnVlOlQsaXRlcmF0b3I6QyxhcnJheUZyb21JdGVyYWJsZTpPLGJ1aWxkQ2xhc3M6TCxyaWNoQ29tcGFyZUJvb2w6eCxhc0luZGV4T3JUaHJvdzpGLG9iamVjdFJlcHI6SSxjYWxsc2ltQXJyYXk6QX0sZ2xvYmFsOnYsZ2xvYmFsOntzdHJmdGltZTpFfX09U2ssUz1uZXcgaSgwKSxIPW5ldyBpKDEpLEQ9bmV3IGkoMiksTj1uZXcgaSgzKSxSPW5ldyBpKDYpLGo9bmV3IGkoNyksSj1uZXcgaSg5KSxQPW5ldyBpKDEyKSxZPW5ldyBpKDEzKSxVPW5ldyBpKDI0KSx6PW5ldyBpKDYwKSxsZT0oZSx0KT0+eChlLHQsXFxcIkx0RVxcXCIpLGVxPShlLHQpPT54KGUsdCxcXFwiRXFcXFwiKSxtb2Q9KGUsdCk9Pm4oZSx0LFxcXCJNb2RcXFwiKSxhZGQ9KGUsdCk9Pm4oZSx0LFxcXCJBZGRcXFwiKSxzdWI9KGUsdCk9Pm4oZSx0LFxcXCJTdWJcXFwiKSxtdWw9KGUsdCk9Pm4oZSx0LFxcXCJNdWx0XFxcIiksaW5jPWU9PmFkZChlLEgpLGRlYz1lPT5zdWIoZSxIKSxtb2Q3PWU9Pm1vZChlLGopLGdldEE9KGUsdCk9PmUudHAkZ2V0YXR0cihuZXcgaCh0KSksY2FsbEE9KGUsdCwuLi5uKT0+QShlLnRwJGdldGF0dHIobmV3IGgodCkpLG4pO2Z1bmN0aW9uKml0ZXJKcyhlKXtjb25zdCB0PXIoZSk7bGV0IG47Zm9yKDtuPXQudHAkaXRlcm5leHQoKTspeWllbGQgbn1mdW5jdGlvbiBpdGVyRm4oZSx0KXtyZXR1cm4gZT1yKGUpLG5ldyBDKCgoKT0+e2NvbnN0IG49ZS50cCRpdGVybmV4dCgpO3JldHVybiBuJiZ0KG4pfSksITApfWZ1bmN0aW9uIG1ha2VQeU1ldGhvZChlLHQse2FyZ3M6bixuYW1lOnIsZG9jOm8sZGVmYXVsdHM6c30pe3QuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIiwuLi5ufHxbXV0sdC5jb19kb2NzdHJpbmc9bz9uZXcgaChvKTpmLHMmJih0LiRkZWZhdWx0cz1zKSx0LmNvX25hbWU9bmV3IGgociksdC5jb19xdWFsbmFtZT1uZXcgaChlK1xcXCIuXFxcIityKTtjb25zdCBtPW5ldyBsKHQpO3JldHVybiBtLiRtb2R1bGU9US5fX25hbWVfXyxtfWNvbnN0e2RhdGV0aW1lOkIsaXRlclJlcGVhdDpXLGl0ZXJDaGFpbjpxfT1lO2xldHtNSU5ZRUFSOkcsTUFYWUVBUjpYLGRhdGU6Vn09Qi4kZDtjb25zdCBLPWdldEEoaCxcXFwiY2VudGVyXFxcIikscHlDZW50ZXI9KGUsdCk9PkEoSyxbZSx0XSkscHlSU3RyaXA9ZT0+bmV3IGgoZS50b1N0cmluZygpLnRyaW1SaWdodCgpKTtHPUcudmFsdWVPZigpLFg9WC52YWx1ZU9mKCk7Y29uc3QgUT17X19uYW1lX186bmV3IGgoXFxcImNhbGVuZGFyXFxcIiksX19hbGxfXzpNKFtcXFwiSWxsZWdhbE1vbnRoRXJyb3JcXFwiLFxcXCJJbGxlZ2FsV2Vla2RheUVycm9yXFxcIixcXFwic2V0Zmlyc3R3ZWVrZGF5XFxcIixcXFwiZmlyc3R3ZWVrZGF5XFxcIixcXFwiaXNsZWFwXFxcIixcXFwibGVhcGRheXNcXFwiLFxcXCJ3ZWVrZGF5XFxcIixcXFwibW9udGhyYW5nZVxcXCIsXFxcIm1vbnRoY2FsZW5kYXJcXFwiLFxcXCJwcm1vbnRoXFxcIixcXFwibW9udGhcXFwiLFxcXCJwcmNhbFxcXCIsXFxcImNhbGVuZGFyXFxcIixcXFwidGltZWdtXFxcIixcXFwibW9udGhfbmFtZVxcXCIsXFxcIm1vbnRoX2FiYnJcXFwiLFxcXCJkYXlfbmFtZVxcXCIsXFxcImRheV9hYmJyXFxcIixcXFwiQ2FsZW5kYXJcXFwiLFxcXCJUZXh0Q2FsZW5kYXJcXFwiLFxcXCJIVE1MQ2FsZW5kYXJcXFwiLFxcXCJMb2NhbGVUZXh0Q2FsZW5kYXJcXFwiLFxcXCJMb2NhbGVIVE1MQ2FsZW5kYXJcXFwiLFxcXCJ3ZWVraGVhZGVyXFxcIl0pfTtmdW5jdGlvbiBtYWtlRXJyKGUsdCl7cmV0dXJuIEwoUSwoKGUsbik9PntuLl9faW5pdF9fPW5ldyBsKChmdW5jdGlvbiBfX2luaXRfXyhlLHQpe2UuJGF0dHI9dH0pKSxuLl9fc3RyX189bmV3IGwoKGZ1bmN0aW9uIF9fc3RyX18oZSl7cmV0dXJuIG5ldyBoKHQucmVwbGFjZShcXFwiJFxcXCIsSShlLiRhdHRyKSkpfSkpfSksZSxbYl0pfWNvbnN0IFo9bWFrZUVycihcXFwiSWxsZWdhbE1vbnRoRXJyb3JcXFwiLFxcXCJiYWQgbW9udGggJDsgbXVzdCBiZSAxLTEyXFxcIiksZWU9bWFrZUVycihcXFwiSWxsZWdhbFdlZWtkYXlFcnJvclxcXCIsXFxcImJhZCB3ZWVrZGF5IG51bWJlciAkOyBtdXN0IGJlIDAgKE1vbmRheSkgdG8gNiAoU3VuZGF5KVxcXCIpLHRlPVswLDMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBta0xvY2FsaXplZENscyhlLHQpe3QuX19pbml0X189bmV3IGwoKGZ1bmN0aW9uIF9faW5pdF9fKGUsdCl7ZS5mb3JtYXQ9dH0pKSx0Ll9fZ2V0aXRlbV9fPW5ldyBsKChmdW5jdGlvbiBfX2dldGl0ZW1fXyh0LG4pe2NvbnN0IHI9byhlLG4pO2lmKG4gaW5zdGFuY2VvZiB3KXtjb25zdCBlPVtdO2Zvcihjb25zdCBuIG9mIHIudmFsdWVPZigpKWUucHVzaChBKG4sW3QuZm9ybWF0XSkpO3JldHVybiBuZXcgYyhlKX1yZXR1cm4gQShyLFt0LmZvcm1hdF0pfSkpO2NvbnN0IG49bmV3IGkoZS52YWx1ZU9mKCkubGVuZ3RoKTt0Ll9fbGVuX189bmV3IGwoKGZ1bmN0aW9uIF9fbGVuX18oZSl7cmV0dXJuIG59KSl9Y29uc3QgYWU9bmV3IGgoXFxcInN0cmZ0aW1lXFxcIiksbmU9TChRLCgoZSx0KT0+e2xldCBuPVtuZXcgbCgoZT0+aC4kZW1wdHkpKV07Zm9yKGxldCByPTA7cjwxMjtyKyspe2NvbnN0IGU9bmV3IFYoMjAwMSxyKzEsMSk7bi5wdXNoKGUudHAkZ2V0YXR0cihhZSkpfW49bmV3IGMobiksdC5fbW9udGhzPW4sbWtMb2NhbGl6ZWRDbHMobix0KX0pLFxcXCJfbG9jYWxpemVkX21vbnRoXFxcIikscmU9TChRLCgoZSx0KT0+e2xldCBuPVtdO2ZvcihsZXQgcj0wO3I8NztyKyspe2NvbnN0IGU9bmV3IFYoMjAwMSwxLHIrMSk7bi5wdXNoKGUudHAkZ2V0YXR0cihhZSkpfW49bmV3IGMobiksdC5fZGF5cz1uLG1rTG9jYWxpemVkQ2xzKG4sdCl9KSxcXFwiX2xvY2FsaXplZF9kYXlcXFwiKSxvZT1BKHJlLFtuZXcgaChcXFwiJUFcXFwiKV0pLHNlPUEocmUsW25ldyBoKFxcXCIlYVxcXCIpXSksbWU9QShuZSxbbmV3IGgoXFxcIiVCXFxcIildKSxkZT1BKG5lLFtuZXcgaChcXFwiJWJcXFwiKV0pLFtpZSxjZSxmZSxoZSx3ZSx5ZSx1ZV09WzAsMSwyLDMsNCw1LDZdO2Z1bmN0aW9uIGlzbGVhcChlKXtyZXR1cm4oZT1GKGUpKSU0PT0wJiYoZSUxMDAhPTB8fGUlNDAwPT0wKX1mdW5jdGlvbiB3ZWVrZGF5KGUsdCxuKXtlPUYoZSksRzw9ZSYmZTw9WHx8KGU9MmUzK2UlNDAwKTtjb25zdCByPUEoVixbbmV3IGkoZSksdCxuXSk7cmV0dXJuIGNhbGxBKFYsXFxcIndlZWtkYXlcXFwiLHIpfWZ1bmN0aW9uIG1vbnRocmFuZ2UoZSx0KXtpZighbGUoSCx0KXx8IWxlKHQsUCkpdGhyb3cgQShaLFt0XSk7Y29uc3Qgbj13ZWVrZGF5KGUsdCxIKTt0PUYodCk7Y29uc3Qgcj10ZVt0XStOdW1iZXIoMj09PXQmJmlzbGVhcChlKSk7cmV0dXJuW24sbmV3IGkocildfWZ1bmN0aW9uIGl0ZXJ3ZWVrZGF5cyhlKXtyZXR1cm4gaXRlckZuKEEodSxbZS5md2QsYWRkKGUuZndkLGopXSksbW9kNyl9ZnVuY3Rpb24gaXRlcm1vbnRoZGF0ZXMoZSx0LG4pe3JldHVybiBpdGVyRm4oaXRlcm1vbnRoZGF5czMoZSx0LG4pLChlPT5BKFYsZS52YWx1ZU9mKCkpKSl9ZnVuY3Rpb24gaXRlcm1vbnRoZGF5cyhlLHQsbil7Y29uc3RbcixvXT1tb250aHJhbmdlKHQsbikscz1tb2Q3KHN1YihyLGUuZndkKSksbT1BKFcsW1Msc10pLGQ9QSh1LFtILGluYyhvKV0pLGw9bW9kNyhzdWIoZS5md2QsYWRkKHIsbykpKSxpPUEoVyxbUyxsXSk7cmV0dXJuIEEocSxbbSxkLGldKX1mdW5jdGlvbiBpdGVybW9udGhkYXlzMihlLHQsbil7cmV0dXJuIGl0ZXJGbihBKCQsW2l0ZXJtb250aGRheXMoZSx0LG4pLGUuZndkXSksKGU9Pntjb25zdFt0LG5dPWUudmFsdWVPZigpO3JldHVybiBuZXcgeShbbixtb2Q3KHQpXSl9KSl9ZnVuY3Rpb24gaXRlcm1vbnRoZGF5czMoZSx0LG4pe2NvbnN0IHltZEl0ZXI9KGUsdCxuKT0+aXRlckZuKG4sKG49Pm5ldyB5KFtlLHQsbl0pKSksW3Isb109bW9udGhyYW5nZSh0LG4pLHM9bW9kNyhzdWIocixlLmZ3ZCkpLG09bW9kNyhzdWIoZS5md2QsYWRkKHIsbykpKSxbZCxsXT1mdW5jdGlvbiBfcHJldm1vbnRoKGUsdCl7cmV0dXJuIGVxKHQsSCk/W2RlYyhlKSxQXTpbZSxkZWModCldfSh0LG4pLGM9aW5jKGZ1bmN0aW9uIF9tb250aGxlbihlLHQpe3JldHVybiB0PUYodCksbmV3IGkodGVbdF0rTnVtYmVyKDI9PT10JiZpc2xlYXAoZSkpKX0oZCxsKSksZj1BKHUsW3N1YihjLHMpLGNdKSxoPUEodSxbSCxpbmMobyldKSxbdyxfXT1mdW5jdGlvbiBfbmV4dG1vbnRoKGUsdCl7cmV0dXJuIGVxKHQsUCk/W2luYyhlKSxIXTpbZSxpbmModCldfSh0LG4pLGc9QSh1LFtILGluYyhtKV0pO3JldHVybiBBKHEsW3ltZEl0ZXIoZCxsLGYpLHltZEl0ZXIodCxuLGgpLHltZEl0ZXIodyxfLGcpXSl9ZnVuY3Rpb24gaXRlcm1vbnRoZGF5czQoZSx0LG4pe2NvbnN0IHI9aXRlcm1vbnRoZGF5czMoZSx0LG4pO2xldCBvPTA7cmV0dXJuIGl0ZXJGbihyLCh0PT5uZXcgeShbLi4udC52YWx1ZU9mKCksbW9kNyhhZGQoZS5md2QsbmV3IGkobysrKSkpXSkpKX1mdW5jdGlvbiBfbW9udGhJdGVyKGUsdCxuLHIpe2NvbnN0IG89TyhlKHQsbixyKSkscz1bXTtmb3IobGV0IG09MDttPG8ubGVuZ3RoO20rPTcpcy5wdXNoKG5ldyBjKG8uc2xpY2UobSxtKzcpKSk7cmV0dXJuIG5ldyBjKHMpfWZ1bmN0aW9uIG1vbnRoZGF0ZXNjYWxlbmRhcihlLHQsbil7cmV0dXJuIF9tb250aEl0ZXIoaXRlcm1vbnRoZGF0ZXMsZSx0LG4pfWZ1bmN0aW9uIG1vbnRoZGF5czJjYWxlbmRhcihlLHQsbil7cmV0dXJuIF9tb250aEl0ZXIoaXRlcm1vbnRoZGF5czIsZSx0LG4pfWZ1bmN0aW9uIG1vbnRoZGF5c2NhbGVuZGFyKGUsdCxuKXtyZXR1cm4gX21vbnRoSXRlcihpdGVybW9udGhkYXlzLGUsdCxuKX1mdW5jdGlvbiBfeWVhckl0ZXIoZSx0LG4scil7cj1GKHIpO2NvbnN0IG89W107Zm9yKGxldCBtPTE7bTwxMzttKyspby5wdXNoKGUodCxuLG5ldyBpKG0pKSk7Y29uc3Qgcz1bXTtmb3IobGV0IG09MDttPG8ubGVuZ3RoO20rPXIpcy5wdXNoKG5ldyBjKG8uc2xpY2UobSxtK3IpKSk7cmV0dXJuIG5ldyBjKHMpfWZ1bmN0aW9uIHllYXJkYXRlc2NhbGVuZGFyKGUsdCxuKXtyZXR1cm4gX3llYXJJdGVyKG1vbnRoZGF0ZXNjYWxlbmRhcixlLHQsbil9ZnVuY3Rpb24geWVhcmRheXMyY2FsZW5kYXIoZSx0LG4pe3JldHVybiBfeWVhckl0ZXIobW9udGhkYXlzMmNhbGVuZGFyLGUsdCxuKX1mdW5jdGlvbiB5ZWFyZGF5c2NhbGVuZGFyKGUsdCxuKXtyZXR1cm4gX3llYXJJdGVyKG1vbnRoZGF5c2NhbGVuZGFyLGUsdCxuKX1jb25zdCBfZT1MKFEsKChlLHQpPT57Y29uc3Qgbj1tYWtlUHlNZXRob2QuYmluZChudWxsLFxcXCJDYWxlbmRhclxcXCIpLHI9W1xcXCJmaXJzdHdlZWtkYXlcXFwiXSxvPVtcXFwieWVhclxcXCIsXFxcIm1vbnRoXFxcIl0scz1bXFxcInllYXJcXFwiLFxcXCJ3aWR0aFxcXCJdLG09e19faW5pdF9fOm4oKGZ1bmN0aW9uIF9faW5pdF9fKGUsdCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFxcXCJmd2RcXFwiLHtnZXQoKXtyZXR1cm4gbW9kNyh0aGlzLl9md2QpfSxzZXQoZSl7cmV0dXJuIHRoaXMuX2Z3ZD1lLCEwfX0pLGUuZndkPXQsZn0pLHtuYW1lOlxcXCJfX2luaXRfX1xcXCIsYXJnczpyLGRlZmF1bHRzOltTXX0pLGdldGZpcnN0d2Vla2RheTpuKChmdW5jdGlvbiBnZXRmaXJzdHdlZWtkYXkoZSl7cmV0dXJuIGUuZndkfSkse25hbWU6XFxcImdldGZpcnN0d2Vla2RheVxcXCJ9KSxzZXRmaXJzdHdlZWtkYXk6bigoZnVuY3Rpb24gc2V0Zmlyc3R3ZWVrZGF5KGUsdCl7cmV0dXJuIGUuZndkPXQsZn0pLHtuYW1lOlxcXCJzZXRmaXJzdHdlZWtkYXlcXFwiLGFyZ3M6cn0pLGl0ZXJ3ZWVrZGF5czpuKGl0ZXJ3ZWVrZGF5cyx7bmFtZTpcXFwiaXRlcndlZWtkYXlzXFxcIn0pLGl0ZXJtb250aGRhdGVzOm4oaXRlcm1vbnRoZGF0ZXMse25hbWU6XFxcIml0ZXJtb250aGRhdGVzXFxcIixhcmdzOm99KSxpdGVybW9udGhkYXlzOm4oaXRlcm1vbnRoZGF5cyx7bmFtZTpcXFwiaXRlcm1vbnRoZGF5c1xcXCIsYXJnczpvfSksaXRlcm1vbnRoZGF5czI6bihpdGVybW9udGhkYXlzMix7bmFtZTpcXFwiaXRlcm1vbnRoZGF5czJcXFwiLGFyZ3M6b30pLGl0ZXJtb250aGRheXMzOm4oaXRlcm1vbnRoZGF5czMse25hbWU6XFxcIml0ZXJtb250aGRheXMzXFxcIixhcmdzOm99KSxpdGVybW9udGhkYXlzNDpuKGl0ZXJtb250aGRheXM0LHtuYW1lOlxcXCJpdGVybW9udGhkYXlzNFxcXCIsYXJnczpvfSksbW9udGhkYXRlc2NhbGVuZGFyOm4obW9udGhkYXRlc2NhbGVuZGFyLHtuYW1lOlxcXCJtb250aGRhdGVzY2FsZW5kYXJcXFwiLGFyZ3M6b30pLG1vbnRoZGF5czJjYWxlbmRhcjpuKG1vbnRoZGF5czJjYWxlbmRhcix7bmFtZTpcXFwibW9udGhkYXlzMmNhbGVuZGFyXFxcIixhcmdzOm99KSxtb250aGRheXNjYWxlbmRhcjpuKG1vbnRoZGF5c2NhbGVuZGFyLHtuYW1lOlxcXCJtb250aGRheXNjYWxlbmRhclxcXCIsYXJnczpvfSkseWVhcmRhdGVzY2FsZW5kYXI6bih5ZWFyZGF0ZXNjYWxlbmRhcix7bmFtZTpcXFwieWVhcmRhdGVzY2FsZW5kYXJcXFwiLGFyZ3M6cyxkZWZhdWx0czpbTl19KSx5ZWFyZGF5czJjYWxlbmRhcjpuKHllYXJkYXlzMmNhbGVuZGFyLHtuYW1lOlxcXCJ5ZWFyZGF5czJjYWxlbmRhclxcXCIsYXJnczpzLGRlZmF1bHRzOltOXX0pLHllYXJkYXlzY2FsZW5kYXI6bih5ZWFyZGF5c2NhbGVuZGFyLHtuYW1lOlxcXCJ5ZWFyZGF5c2NhbGVuZGFyXFxcIixhcmdzOnMsZGVmYXVsdHM6W05dfSl9O20uZmlyc3R3ZWVrZGF5PW5ldyBrKG0uZ2V0Zmlyc3R3ZWVrZGF5LG0uc2V0Zmlyc3R3ZWVrZGF5KSxPYmplY3QuYXNzaWduKHQsbSl9KSxcXFwiQ2FsZW5kYXJcXFwiKTtmdW5jdGlvbiBkb1RleHRGb3JtYXR3ZWVrZGF5KGUsdCxuKXtsZXQgcjtyZXR1cm4gcj14KG4sSixcXFwiR3RFXFxcIik/b2U6c2UscHlDZW50ZXIobyhvKHIsdCksbmV3IHcoZixuKSksbil9ZnVuY3Rpb24gZG9UZXh0Rm9ybWF0bW9udGhuYW1lKGUsdCxuLHIscz0hMCl7bGV0IG09byhtZSxuKTtyZXR1cm4gVChzKSYmKG09bW9kKG5ldyBoKFxcXCIlcyAlclxcXCIpLG5ldyB5KFttLHRdKSkpLHB5Q2VudGVyKG0scil9Y29uc3QgZ2U9TChRLCgoZSx0KT0+e2NvbnN0IHR4dFByaW50PWU9PnAoW2VdLFtcXFwiZW5kXFxcIixoLiRlbXB0eV0pO2NvbnN0IG49ZG9UZXh0Rm9ybWF0d2Vla2RheTtmdW5jdGlvbiBmb3JtYXR3ZWVraGVhZGVyKGUsdCl7Y29uc3Qgbj1bXTtmb3IoY29uc3QgciBvZiBpdGVySnMoaXRlcndlZWtkYXlzKGUpKSluLnB1c2goY2FsbEEoZSxcXFwiZm9ybWF0d2Vla2RheVxcXCIscix0KS50b1N0cmluZygpKTtyZXR1cm4gbmV3IGgobi5qb2luKFxcXCIgXFxcIikpfWNvbnN0IHI9ZG9UZXh0Rm9ybWF0bW9udGhuYW1lO2NvbnN0IG89bWFrZVB5TWV0aG9kLmJpbmQobnVsbCxcXFwiVGV4dENhbGVuZGFyXFxcIikscz17cHJ3ZWVrOm8oKGZ1bmN0aW9uIHByd2VlayhlLHQsbil7dHh0UHJpbnQoY2FsbEEoZSxcXFwiZm9ybWF0d2Vla1xcXCIsdCxuKSl9KSx7bmFtZTpcXFwicHJ3ZWVrXFxcIixhcmdzOltcXFwidGhld2Vla1xcXCIsXFxcIndpZHRoXFxcIl19KSxmb3JtYXRkYXk6bygoZnVuY3Rpb24gZm9ybWF0ZGF5KGUsdCxuLHIpe2xldCBvO3JldHVybiBvPWVxKHQsUyk/aC4kZW1wdHk6bW9kKG5ldyBoKFxcXCIlMmlcXFwiKSx0KSxweUNlbnRlcihvLHIpfSkse25hbWU6XFxcImZvcm1hdGRheVxcXCIsYXJnczpbXFxcImRheVxcXCIsXFxcIndlZWtkYXlcXFwiLFxcXCJ3aWR0aFxcXCJdfSksZm9ybWF0d2VlazpvKChmdW5jdGlvbiBmb3JtYXR3ZWVrKGUsdCxuKXtjb25zdCByPVtdO2Zvcihjb25zdCBvIG9mIGl0ZXJKcyh0KSl7Y29uc3RbdCxzXT1vLnZhbHVlT2YoKTtyLnB1c2goY2FsbEEoZSxcXFwiZm9ybWF0ZGF5XFxcIix0LHMsbikudG9TdHJpbmcoKSl9cmV0dXJuIG5ldyBoKHIuam9pbihcXFwiIFxcXCIpKX0pLHtuYW1lOlxcXCJmb3JtYXR3ZWVrXFxcIixhcmdzOltcXFwidGhld2Vla1xcXCIsXFxcIndpZHRoXFxcIl19KSxmb3JtYXR3ZWVrZGF5Om8obix7bmFtZTpcXFwiZm9ybWF0d2Vla2RheVxcXCIsYXJnczpbXFxcImRheVxcXCIsXFxcIndpZHRoXFxcIl19KSxmb3JtYXR3ZWVraGVhZGVyOm8oZm9ybWF0d2Vla2hlYWRlcix7bmFtZTpcXFwiZm9ybWF0d2Vla2hlYWRlclxcXCIsYXJnczpbXFxcIndpZHRoXFxcIl19KSxmb3JtYXRtb250aG5hbWU6byhyLHtuYW1lOlxcXCJmb3JtYXRtb250aG5hbWVcXFwiLGFyZ3M6W1xcXCJ0aGV5ZWFyXFxcIixcXFwidGhlbW9udGhcXFwiLFxcXCJ3aWR0aFxcXCIsXFxcIndpdGh5ZWFyXFxcIl0sZGVmYXVsdHM6W21dfSkscHJtb250aDpvKChmdW5jdGlvbiBwcm1vbnRoKGUsdCxuLHIsbyl7dHh0UHJpbnQoY2FsbEEoZSxcXFwiZm9ybWF0bW9udGhcXFwiLHQsbixyLG8pKX0pLHtuYW1lOlxcXCJwcm1vbnRoXFxcIixhcmdzOltcXFwidGhleWVhclxcXCIsXFxcInRoZW1vbnRoXFxcIixcXFwid1xcXCIsXFxcImxcXFwiXSxkZWZhdWx0czpbUyxTXX0pLGZvcm1hdG1vbnRoOm8oKGZ1bmN0aW9uIGZvcm1hdG1vbnRoKGUsdCxuLHIsbyl7Y29uc3QgYWRkTmV3TGluZXM9ZT0+bmV3IGgoZStcXFwiXFxcXG5cXFwiLnJlcGVhdChvLnZhbHVlT2YoKSkpO3I9XyhbRCxyXSksbz1fKFtILG9dKTtsZXQgcz1jYWxsQShlLFxcXCJmb3JtYXRtb250aG5hbWVcXFwiLHQsbixkZWMobXVsKGosaW5jKHIpKSksITApO3M9cHlSU3RyaXAocykscz1hZGROZXdMaW5lcyhzKSxzPWFkZChzLHB5UlN0cmlwKGNhbGxBKGUsXFxcImZvcm1hdHdlZWtoZWFkZXJcXFwiLHIpKSkscz1hZGROZXdMaW5lcyhzKTtmb3IoY29uc3QgbSBvZiBpdGVySnMobW9udGhkYXlzMmNhbGVuZGFyKGUsdCxuKSkpcz1hZGQocyxweVJTdHJpcChjYWxsQShlLFxcXCJmb3JtYXR3ZWVrXFxcIixtLHIpKSkscz1hZGROZXdMaW5lcyhzKTtyZXR1cm4gc30pLHtuYW1lOlxcXCJmb3JtYXRtb250aFxcXCIsYXJnczpbXFxcInRoeWVhclxcXCIsXFxcInRoZW1vbnRoXFxcIixcXFwid1xcXCIsXFxcImxcXFwiXSxkZWZhdWx0czpbUyxTXX0pLGZvcm1hdHllYXI6bygoZnVuY3Rpb24gZm9ybWF0eWVhcihlLHQsbixyLG8scyl7bj1fKFtELG5dKSxyPV8oW0gscl0pLG89XyhbRCxvXSk7Y29uc3QgbT1kZWMobXVsKGluYyhuKSxqKSk7bGV0IGQ9XFxcIlxcXCI7Y29uc3QgYT1lPT5kKz1lO2EocHlSU3RyaXAocHlDZW50ZXIodC4kcigpLGFkZChtdWwobSxzKSxtdWwobyxkZWMocykpKSkpKSxhKFxcXCJcXFxcblxcXCIucmVwZWF0KHIpKTtjb25zdCBsPWZvcm1hdHdlZWtoZWFkZXIoZSxuKTtsZXQgZj0wO2Zvcihjb25zdCB3IG9mIGl0ZXJKcyh5ZWFyZGF5czJjYWxlbmRhcihlLHQscykpKXtjb25zdCBkPW5ldyBpKGYpLHk9aW5jKG11bChzLGQpKSxfPWcoW2luYyhtdWwocyxpbmMoZCkpKSxZXSksaz1BKHUsW3ksX10pO2EoXFxcIlxcXFxuXFxcIi5yZXBlYXQocikpO2NvbnN0IHA9aXRlckZuKGssKG49PmNhbGxBKGUsXFxcImZvcm1hdG1vbnRobmFtZVxcXCIsdCxuLG0sITEpKSk7YShweVJTdHJpcChmb3JtYXRzdHJpbmcocCxtLG8pKSksYShcXFwiXFxcXG5cXFwiLnJlcGVhdChyKSk7Y29uc3QgJD1pdGVyRm4oaywoZT0+bCkpO2EocHlSU3RyaXAoZm9ybWF0c3RyaW5nKCQsbSxvKSkpLGEoXFxcIlxcXFxuXFxcIi5yZXBlYXQocikpO2NvbnN0IGI9TWF0aC5tYXgoLi4udy52YWx1ZU9mKCkubWFwKChlPT5lLnZhbHVlT2YoKS5sZW5ndGgpKSk7Zm9yKGxldCB0PTA7dDxiO3QrKyl7Y29uc3Qgcz1bXTtmb3IobGV0IHIgb2Ygdy52YWx1ZU9mKCkpcj1yLnZhbHVlT2YoKSx0Pj1yLmxlbmd0aD9zLnB1c2goaC4kZW1wdHkpOnMucHVzaChjYWxsQShlLFxcXCJmb3JtYXR3ZWVrXFxcIixyW3RdLG4pKTthKHB5UlN0cmlwKGZvcm1hdHN0cmluZyhuZXcgYyhzKSxtLG8pKSksYShcXFwiXFxcXG5cXFwiLnJlcGVhdChyKSl9ZisrfXJldHVybiBuZXcgaChkKX0pLHtuYW1lOlxcXCJmb3JtYXR5ZWFyXFxcIixhcmdzOltcXFwidGhleWVhclxcXCIsXFxcIndcXFwiLFxcXCJsXFxcIixcXFwiY1xcXCIsXFxcIm1cXFwiXSxkZWZhdWx0czpbRCxILFIsTl19KSxwcnllYXI6bygoZnVuY3Rpb24gcHJ5ZWFyKGUsdCxuLHIsbyxzKXt0eHRQcmludChjYWxsQShlLFxcXCJmb3JtYXR5ZWFyXFxcIix0LG4scixvLHMpKX0pLHtuYW1lOlxcXCJwcnllYXJcXFwiLGFyZ3M6W1xcXCJ0aGV5ZWFyXFxcIixcXFwid1xcXCIsXFxcImxcXFwiLFxcXCJjXFxcIixcXFwibVxcXCJdLGRlZmF1bHRzOltTLFMsUixOXX0pfTtPYmplY3QuYXNzaWduKHQscyl9KSxcXFwiVGV4dENhbGVuZGFyXFxcIixbX2VdKTtmdW5jdGlvbiBkb0h0bWxGb3JtYXR3ZWVrZGF5KGUsdCl7cmV0dXJuIG5ldyBoKGA8dGggY2xhc3M9XFxcIiR7byhnZXRBKGUsXFxcImNzc2NsYXNzZXNfd2Vla2RheV9oZWFkXFxcIiksdCl9XFxcIj4ke28oc2UsdCl9PC90aD5gKX1mdW5jdGlvbiBkb0h0bWxGb3JtYXRtb250aG5hbWUoZSx0LG4scj0hMCl7bGV0IHM9XFxcIlxcXCIrbyhtZSxuKTtyZXR1cm4gVChyKSYmKHMrPVxcXCIgXFxcIit0KSxuZXcgaChgPHRyPjx0aCBjb2xzcGFuPVxcXCI3XFxcIiBjbGFzcz1cXFwiJHtnZXRBKGUsXFxcImNzc2NsYXNzX21vbnRoX2hlYWRcXFwiKX1cXFwiPiR7c308L3RoPjwvdHI+YCl9Y29uc3Qga2U9TChRLCgoZSx0KT0+e2NvbnN0IG49TShbXFxcIm1vblxcXCIsXFxcInR1ZVxcXCIsXFxcIndlZFxcXCIsXFxcInRodVxcXCIsXFxcImZyaVxcXCIsXFxcInNhdFxcXCIsXFxcInN1blxcXCJdKSxyPW4scz1uZXcgaChcXFwibm9kYXlcXFwiKSxkPW5ldyBoKFxcXCJtb250aFxcXCIpLGw9ZCxjPW5ldyBoKFxcXCJ5ZWFyXFxcIiksdz1jLHU9bmV3IGgoJzx0ZCBjbGFzcz1cXFwiJXNcXFwiPiZuYnNwOzwvdGQ+JyksZz1uZXcgaCgnPHRkIGNsYXNzPVxcXCIlc1xcXCI+JWQ8L3RkPicpO2NvbnN0IGs9ZG9IdG1sRm9ybWF0d2Vla2RheTtmdW5jdGlvbiBmb3JtYXR3ZWVraGVhZGVyKGUpe2xldCB0PVxcXCJcXFwiO2Zvcihjb25zdCBuIG9mIGl0ZXJKcyhpdGVyd2Vla2RheXMoZSkpKXQrPWNhbGxBKGUsXFxcImZvcm1hdHdlZWtkYXlcXFwiLG4pO3JldHVybiBuZXcgaChgPHRyPiR7dH08L3RyPmApfWNvbnN0IHA9ZG9IdG1sRm9ybWF0bW9udGhuYW1lO2NvbnN0ICQ9bWFrZVB5TWV0aG9kLmJpbmQobnVsbCxcXFwiSFRNTENhbGVuZGFyXFxcIiksYj17Zm9ybWF0ZGF5OiQoKGZ1bmN0aW9uIGZvcm1hdGRheShlLHQsbil7cmV0dXJuIGVxKHQsUyk/bW9kKHUsZ2V0QShlLFxcXCJjc3NjbGFzc19ub2RheVxcXCIpKTptb2QoZyxuZXcgeShbbyhnZXRBKGUsXFxcImNzc2NsYXNzZXNcXFwiKSxuKSx0XSkpfSkse25hbWU6XFxcImZvcm1hdGRheVxcXCIsYXJnczpbXFxcImRheVxcXCIsXFxcIndlZWtkYXlcXFwiXX0pLGZvcm1hdHdlZWs6JCgoZnVuY3Rpb24gZm9ybWF0d2VlayhlLHQpe2xldCBuPVxcXCJcXFwiO2Zvcihjb25zdCByIG9mIGl0ZXJKcyh0KSl7Y29uc3RbdCxvXT1yLnZhbHVlT2YoKTtuKz1jYWxsQShlLFxcXCJmb3JtYXRkYXlcXFwiLHQsbyl9cmV0dXJuIG5ldyBoKGA8dHI+JHtufTwvdHI+YCl9KSx7bmFtZTpcXFwiZm9ybWF0d2Vla1xcXCIsYXJnczpbXFxcInRoZXdlZWtcXFwiXX0pLGZvcm1hdHdlZWtkYXk6JChrLHtuYW1lOlxcXCJmb3JtYXR3ZWVrZGF5XFxcIixhcmdzOltcXFwiZGF5XFxcIl19KSxmb3JtYXR3ZWVraGVhZGVyOiQoZm9ybWF0d2Vla2hlYWRlcix7bmFtZTpcXFwiZm9ybWF0d2Vla2hlYWRlclxcXCJ9KSxmb3JtYXRtb250aG5hbWU6JChwLHtuYW1lOlxcXCJmb3JtYXRtb250aG5hbWVcXFwiLGFyZ3M6W1xcXCJ0aGV5ZWFyXFxcIixcXFwidGhlbW9udGhcXFwiLFxcXCJ3aXRoeWVhclxcXCJdLGRlZmF1bHRzOlttXX0pLGZvcm1hdG1vbnRoOiQoKGZ1bmN0aW9uIGZvcm1hdG1vbnRoKGUsdCxuLHI9ITApe2xldCBvPVxcXCJcXFwiO2NvbnN0IGE9ZT0+bys9ZStcXFwiXFxcXG5cXFwiO2EoYDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgY2xhc3M9XFxcIiR7Z2V0QShlLFxcXCJjc3NjbGFzc19tb250aFxcXCIpfVxcXCI+YCksYShjYWxsQShlLFxcXCJmb3JtYXRtb250aG5hbWVcXFwiLHQsbixyKSksYShmb3JtYXR3ZWVraGVhZGVyKGUpKTtmb3IoY29uc3QgcyBvZiBpdGVySnMobW9udGhkYXlzMmNhbGVuZGFyKGUsdCxuKSkpYShjYWxsQShlLFxcXCJmb3JtYXR3ZWVrXFxcIixzKSk7cmV0dXJuIGEoXFxcIjwvdGFibGU+XFxcIiksbmV3IGgobyl9KSx7bmFtZTpcXFwiZm9ybWF0bW9udGhcXFwiLGFyZ3M6W1xcXCJ0aHllYXJcXFwiLFxcXCJ0aGVtb250aFxcXCIsXFxcIndpdGh5ZWFyXFxcIl0sZGVmYXVsdHM6W21dfSksZm9ybWF0eWVhcjokKChmdW5jdGlvbiBmb3JtYXR5ZWFyKGUsdCxuKXtsZXQgcj1cXFwiXFxcIjtjb25zdCBhPWU9PnIrPWU7bj1fKFtuLEhdKS52YWx1ZU9mKCksYShgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiBjbGFzcz1cXFwiJHtnZXRBKGUsXFxcImNzc2NsYXNzX3llYXJcXFwiKX1cXFwiPmApLGEoXFxcIlxcXFxuXFxcIiksYShgPHRyPjx0aCBjb2xzcGFuPVxcXCIke259XFxcIiBjbGFzcz1cXFwiJHtnZXRBKGUsXFxcImNzc2NsYXNzX3llYXJfaGVhZFxcXCIpfVxcXCI+JHt0fTwvdGg+PC90cj5gKTtmb3IobGV0IG89MTtvPDEzO28rPW4pe2EoXFxcIjx0cj5cXFwiKTtjb25zdCByPU1hdGgubWluKG8rbiwxMyk7Zm9yKGxldCBuPW87bjxyO24rKylhKFxcXCI8dGQ+XFxcIiksYShjYWxsQShlLFxcXCJmb3JtYXRtb250aFxcXCIsdCxuZXcgaShuKSwhMSkpLGEoXFxcIjwvdGQ+XFxcIik7YShcXFwiPC90cj5cXFwiKX1yZXR1cm4gYShcXFwiPC90YWJsZT5cXFwiKSxuZXcgaChyKX0pLHtuYW1lOlxcXCJmb3JtYXR5ZWFyXFxcIixhcmdzOltcXFwidGhleWVhclxcXCIsXFxcIndpZHRoXFxcIl0sZGVmYXVsdHM6W05dfSksZm9ybWF0eWVhcnBhZ2U6JCgoZnVuY3Rpb24gZm9ybWF0eWVhcnBhZ2UoZSx0LG49MyxyPVxcXCJjYWxlbmRhci5jc3NcXFwiLG89bnVsbCl7bnVsbCE9PW8mJm8hPT1mfHwobz1uZXcgaChcXFwidXRmLThcXFwiKSk7bGV0IHM9XFxcIlxcXCI7Y29uc3QgYT1lPT5zKz1lO3JldHVybiBhKGA8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCIke299XFxcIj8+XFxcXG5gKSxhKCc8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXFxcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBTdHJpY3QvL0VOXFxcIiBcXFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtc3RyaWN0LmR0ZFxcXCI+XFxcXG4nKSxhKFxcXCI8aHRtbD5cXFxcblxcXCIpLGEoXFxcIjxoZWFkPlxcXFxuXFxcIiksYShgPG1ldGEgaHR0cC1lcXVpdj1cXFwiQ29udGVudC1UeXBlXFxcIiBjb250ZW50PVxcXCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9JHtvfVxcXCIgLz5cXFxcbmApLHIhPT1mJiZhKGA8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIHR5cGU9XFxcInRleHQvY3NzXFxcIiBocmVmPVxcXCIke3J9XFxcIiAvPlxcXFxuYCksYShgPHRpdGxlPkNhbGVuZGFyIGZvciAke3R9PC90aXRsZT5cXFxcbmApLGEoXFxcIjwvaGVhZD5cXFxcblxcXCIpLGEoXFxcIjxib2R5PlxcXFxuXFxcIiksYShjYWxsQShlLFxcXCJmb3JtYXR5ZWFyXFxcIix0LG4pKSxhKFxcXCI8L2JvZHk+XFxcXG5cXFwiKSxhKFxcXCI8L2h0bWw+XFxcXG5cXFwiKSxjYWxsQShoLFxcXCJlbmNvZGVcXFwiLG5ldyBoKHMpLG8sbmV3IGgoXFxcImlnbm9yZVxcXCIpKX0pLHtuYW1lOlxcXCJmb3JtYXR5ZWFycGFnZVxcXCIsYXJnczpbXFxcInRoZXllYXJcXFwiLFxcXCJ3aWR0aFxcXCIsXFxcImNzc1xcXCIsXFxcImVuY29kaW5nXFxcIl0sZGVmYXVsdHM6W04sbmV3IGgoXFxcImNhbGVuZGFyLmNzc1xcXCIpLG5ldyBoKFxcXCJ1dGYtOFxcXCIpXX0pLGNzc2NsYXNzZXM6bixjc3NjbGFzc2VzX3dlZWtkYXlfaGVhZDpyLGNzc2NsYXNzX25vZGF5OnMsY3NzY2xhc3NfbW9udGhfaGVhZDpkLGNzc2NsYXNzX21vbnRoOmwsY3NzY2xhc3NfeWVhcl9oZWFkOmMsY3NzY2xhc3NfeWVhcjp3fTtPYmplY3QuYXNzaWduKHQsYil9KSxcXFwiSFRNTENhbGVuZGFyXFxcIixbX2VdKTtmdW5jdGlvbiB3aXRoTG9jYWxlKGUsdCl7Y29uc3Qgbj1FLmxvY2FsaXplQnlJZGVudGlmaWVyKGUudG9TdHJpbmcoKSk7di5zdHJmdGltZT1uO3RyeXtyZXR1cm4gdCgpfWZpbmFsbHl7di5zdHJmdGltZT1FfX1mdW5jdGlvbiBsb2NhbEluaXQoZSx0KXtUKHQpfHwodD1uZXcgaChcXFwiZW5fVVNcXFwiKSksZS5sb2NhbGU9dH1jb25zdCBwZT1MKFEsKChlLHQpPT57Y29uc3Qgbj1tYWtlUHlNZXRob2QuYmluZChudWxsLFxcXCJMb2NhbGVUZXh0Q2FsZW5kYXJcXFwiKSxyPXtfX2luaXRfXzpuKChmdW5jdGlvbiBfX2luaXRfXyhlLHQsbil7cmV0dXJuIGNhbGxBKGdlLFxcXCJfX2luaXRfX1xcXCIsZSx0KSxsb2NhbEluaXQoZSxuKSxmfSkse25hbWU6XFxcIl9faW5pdF9fXFxcIixhcmdzOltcXFwiZmlyc3R3ZWVrZGF5XFxcIixcXFwibG9jYWxlXFxcIl0sZGVmYXVsdHM6W1MsZl19KSxmb3JtYXR3ZWVrZGF5Om4oKGZ1bmN0aW9uIGZvcm1hdHdlZWtkYXkoZSx0LG4pe3JldHVybiB3aXRoTG9jYWxlKGUubG9jYWxlLCgoKT0+ZG9UZXh0Rm9ybWF0d2Vla2RheSgwLHQsbikpKX0pLHtuYW1lOlxcXCJmb3JtYXR3ZWVrZGF5XFxcIixhcmdzOltcXFwiZGF5XFxcIixcXFwid2lkdGhcXFwiXX0pLGZvcm1hdG1vbnRobmFtZTpuKChmdW5jdGlvbiBmb3JtYXRtb250aG5hbWUoZSx0LG4scixvKXtyZXR1cm4gd2l0aExvY2FsZShlLmxvY2FsZSwoKCk9PmRvVGV4dEZvcm1hdG1vbnRobmFtZSgwLHQsbixyLG8pKSl9KSx7bmFtZTpcXFwiZm9ybWF0bW9udGhuYW1lXFxcIixhcmdzOltcXFwidGhleWVhclxcXCIsXFxcInRoZW1vbnRoXFxcIixcXFwid2lkdGhcXFwiLFxcXCJ3aXRoeWVhclxcXCJdLGRlZmF1bHRzOlttXX0pfTtPYmplY3QuYXNzaWduKHQscil9KSxcXFwiTG9jYWxlVGV4dENhbGVuZGFyXFxcIixbZ2VdKSwkZT1MKFEsKChlLHQpPT57Y29uc3Qgbj1tYWtlUHlNZXRob2QuYmluZChudWxsLFxcXCJMb2NhbGVIVE1MQ2FsZW5kYXJcXFwiKSxyPXtfX2luaXRfXzpuKChmdW5jdGlvbiBfX2luaXRfXyhlLHQsbil7cmV0dXJuIGNhbGxBKGtlLFxcXCJfX2luaXRfX1xcXCIsZSx0KSxsb2NhbEluaXQoZSxuKSxmfSkse25hbWU6XFxcIl9faW5pdF9fXFxcIixhcmdzOltcXFwiZmlyc3R3ZWVrZGF5XFxcIixcXFwibG9jYWxlXFxcIl0sZGVmYXVsdHM6W1MsZl19KSxmb3JtYXR3ZWVrZGF5Om4oKGZ1bmN0aW9uIGZvcm1hdHdlZWtkYXkoZSx0KXtyZXR1cm4gd2l0aExvY2FsZShlLmxvY2FsZSwoKCk9PmRvSHRtbEZvcm1hdHdlZWtkYXkoZSx0KSkpfSkse25hbWU6XFxcImZvcm1hdHdlZWtkYXlcXFwiLGFyZ3M6W1xcXCJkYXlcXFwiXX0pLGZvcm1hdG1vbnRobmFtZTpuKChmdW5jdGlvbiBmb3JtYXRtb250aG5hbWUoZSx0LG4scil7cmV0dXJuIHdpdGhMb2NhbGUoZS5sb2NhbGUsKCgpPT5kb0h0bWxGb3JtYXRtb250aG5hbWUoZSx0LG4scikpKX0pLHtuYW1lOlxcXCJmb3JtYXRtb250aG5hbWVcXFwiLGFyZ3M6W1xcXCJ0aGV5ZWFyXFxcIixcXFwidGhlbW9udGhcXFwiLFxcXCJ3aXRoeWVhclxcXCJdLGRlZmF1bHRzOlttXX0pfTtPYmplY3QuYXNzaWduKHQscil9KSxcXFwiTG9jYWxlSFRNTENhbGVuZGFyXFxcIixba2VdKSxiZT1BKGdlLFtdKTtPYmplY3QuYXNzaWduKFEse0lsbGVnYWxNb250aEVycm9yOlosSWxsZWdhbFdlZWtkYXlFcnJvcjplZSxkYXlfbmFtZTpvZSxtb250aF9uYW1lOm1lLGRheV9hYmJyOnNlLG1vbnRoX2FiYnI6ZGUsSmFudWFyeTpuZXcgaSgxKSxGZWJydWFyeTpuZXcgaSgyKSxtZGF5czpNKHRlKSxNT05EQVk6bmV3IGkoaWUpLFRVRVNEQVk6bmV3IGkoY2UpLFdFRE5FU0RBWTpuZXcgaShmZSksVEhVUlNEQVk6bmV3IGkoaGUpLEZSSURBWTpuZXcgaSh3ZSksU0FUVVJEQVk6bmV3IGkoeWUpLFNVTkRBWTpuZXcgaSh1ZSksQ2FsZW5kYXI6X2UsVGV4dENhbGVuZGFyOmdlLEhUTUxDYWxlbmRhcjprZSxMb2NhbGVUZXh0Q2FsZW5kYXI6cGUsTG9jYWxlSFRNTENhbGVuZGFyOiRlLGM6YmUsZmlyc3R3ZWVrZGF5OmdldEEoYmUsXFxcImdldGZpcnN0d2Vla2RheVxcXCIpLG1vbnRoY2FsZW5kYXI6Z2V0QShiZSxcXFwibW9udGhkYXlzY2FsZW5kYXJcXFwiKSxwcndlZWs6Z2V0QShiZSxcXFwicHJ3ZWVrXFxcIiksd2VlazpnZXRBKGJlLFxcXCJmb3JtYXR3ZWVrXFxcIiksd2Vla2hlYWRlcjpnZXRBKGJlLFxcXCJmb3JtYXR3ZWVraGVhZGVyXFxcIikscHJtb250aDpnZXRBKGJlLFxcXCJwcm1vbnRoXFxcIiksbW9udGg6Z2V0QShiZSxcXFwiZm9ybWF0bW9udGhcXFwiKSxjYWxlbmRhcjpnZXRBKGJlLFxcXCJmb3JtYXR5ZWFyXFxcIikscHJjYWw6Z2V0QShiZSxcXFwicHJ5ZWFyXFxcIil9KTtjb25zdCBNZT1uZXcgaSgyMCksVGU9UjtmdW5jdGlvbiBmb3JtYXRzdHJpbmcoZSx0LG4pe3R8fCh0PU1lKSxufHwobj1UZSksbj1tdWwobixuZXcgaChcXFwiIFxcXCIpKTtjb25zdCByPVtdO2Zvcihjb25zdCBvIG9mIGl0ZXJKcyhlKSlyLnB1c2gocHlDZW50ZXIobyx0KS50b1N0cmluZygpKTtyZXR1cm4gbmV3IGgoci5qb2luKG4udG9TdHJpbmcoKSkpfWNvbnN0IENlPWdldEEoVixcXFwidG9vcmRpbmFsXFxcIiksT2U9QShDZSxbbmV3IFYoMTk3MCwxLDEpXSk7cmV0dXJuIHQoXFxcImNhbGVuZGFyXFxcIixRLHtpc2xlYXA6eyRtZXRoOmU9PnMoaXNsZWFwKGUpKSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInllYXJcXFwiXX0sJGRvYzpcXFwiUmV0dXJuIFRydWUgZm9yIGxlYXAgeWVhcnMsIEZhbHNlIGZvciBub24tbGVhcCB5ZWFyc1xcXCJ9LGxlYXBkYXlzOnskbWV0aChlLHQpe2U9RihlKS0xLHQ9Rih0KS0xO2NvbnN0IG49TWF0aC5mbG9vcjtyZXR1cm4gbmV3IGkobih0LzQpLW4oZS80KS0obih0LzEwMCktbihlLzEwMCkpKyhuKHQvNDAwKS1uKGUvNDAwKSkpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9fSx3ZWVrZGF5OnskbWV0aDp3ZWVrZGF5LCRmbGFnczp7TmFtZWRBcmdzOltcXFwieWVhclxcXCIsXFxcIm1vbnRoXFxcIixcXFwiZGF5XFxcIl19LCRkb2M6XFxcIlJldHVybiB3ZWVrZGF5ICgwLTYgfiBNb24tU3VuKSBmb3IgeWVhciwgbW9udGggKDEtMTIpLCBkYXkgKDEtMzEpLlxcXCJ9LG1vbnRocmFuZ2U6eyRtZXRoOihlLHQpPT5uZXcgeShtb250aHJhbmdlKGUsdCkpLCRmbGFnczp7TmFtZWRBcmdzOltcXFwieWVhclxcXCIsXFxcIm1vbnRoXFxcIl19LCRkb2M6XFxcIlJldHVybiB3ZWVrZGF5ICgwLTYgfiBNb24tU3VuKSBhbmQgbnVtYmVyIG9mIGRheXMgKDI4LTMxKSBmb3IgeWVhciwgbW9udGguXFxcIn0sc2V0Zmlyc3R3ZWVrZGF5OnskbWV0aChlKXtjb25zdCB0PUYoZSk7aWYoIShpZTw9dCYmdDw9dWUpKXRocm93IEEoZWUsW2VdKTtiZS5md2Q9ZX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJmaXJzdHdlZWtkYXlcXFwiXX19LGZvcm1hdDp7JG1ldGg6ZnVuY3Rpb24gZm9ybWF0KGUsdCxuKXtyZXR1cm4gcChbZm9ybWF0c3RyaW5nKGUsdCxuKV0pLGZ9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwiY29sc1xcXCIsXFxcImNvbHdpZHRoXFxcIixcXFwic3BhY2luZ1xcXCJdLERlZmF1bHRzOltNZSxUZV19fSxmb3JtYXRzdHJpbmc6eyRtZXRoOmZvcm1hdHN0cmluZywkZmxhZ3M6e05hbWVkQXJnczpbXFxcImNvbHNcXFwiLFxcXCJjb2x3aWR0aFxcXCIsXFxcInNwYWNpbmdcXFwiXSxEZWZhdWx0czpbTWUsVGVdfX0sdGltZWdtOnskbWV0aChlKXtjb25zdFt0LG4scixvLHMsbV09ZS52YWx1ZU9mKCksZD1BKFYsW3QsbixIXSksbD1BKENlLFtkXSksaT1hZGQoc3ViKGwsT2UpLGRlYyhyKSksYz1hZGQobXVsKGksVSksbyksZj1hZGQobXVsKGMseikscyk7cmV0dXJuIGFkZChtdWwoZix6KSxtKX0sJGZsYWdzOntPbmVBcmc6ITB9fX0pLFF9XCIsXCJzcmMvbGliL2NlbGxib3RpY3MvX19pbml0X18uanNcIjpcIlxcXCJ1c2Ugc3RyaWN0XFxcIjtmdW5jdGlvbiBwcm9taXNlVG9QeShlKXtjb25zdCBuPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uO2xldCBpLHQ7cmV0dXJuIG4ucmVzdW1lPWZ1bmN0aW9uKCl7aWYodCl0aHJvdyB0O3JldHVybiBpfSxuLmRhdGE9e3R5cGU6XFxcIlNrLnByb21pc2VcXFwiLHByb21pc2U6ZS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gaT1lLGV9KSwoZnVuY3Rpb24oZSl7cmV0dXJuIHQ9ZSxlfSkpfSxufWZ1bmN0aW9uIHJlbWFwVG9QeShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFByb21pc2UmJihlPXByb21pc2VUb1B5KGUpKSxTay5mZmkucmVtYXBUb1B5KGUpfWZ1bmN0aW9uIHJlbWFwVG9Kc0Z1bmMoZSwuLi5uKXtyZXR1cm4gZnVuY3Rpb24oLi4uaSl7biYmU2suYnVpbHRpbi5weUNoZWNrQXJncyhlLm5hbWUsaSwuLi5uKSxpPWkuc2xpY2UoMSk7cmV0dXJuIHJlbWFwVG9QeShlKC4uLmkubWFwKChlPT5Tay5mZmkucmVtYXBUb0pzKGUpKSkpKX19dmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKGUpe3JldHVybiByZW1hcFRvUHkoUHJvbWlzZS5hbGwoW3J1bmVzdG9uZUNvbXBvbmVudHMucnVuZXN0b25lX2ltcG9ydChcXFwiYmxlXFxcIikscnVuZXN0b25lQ29tcG9uZW50cy5ydW5lc3RvbmVfaW1wb3J0KFxcXCJzaW1wbGVfc2Vuc29yXFxcIildKS50aGVuKCgoW2Usbl0pPT57Y29uc3QgaT17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJjZWxsYm90aWNzXFxcIil9LGdldF9zZWxmPWU9PmUmJmUuX19qc19jbGFzcztpLkpzUHJvcGVydHk9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhpLChmdW5jdGlvbihlLG4pe24uX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oLi4uZSl7U2suYnVpbHRpbi5weUNoZWNrQXJncyhcXFwiX19pbml0X19cXFwiLGUsMiwyKTtjb25zdFtuLGldPWU7bi5fX2pzX3Byb3BlcnR5PVNrLmZmaS5yZW1hcFRvSnMoaSl9KSksbi5fX2dldF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKC4uLmUpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXFxcIl9fZ2V0X19cXFwiLGUsMiwzKTtjb25zdFtuLGksdF09ZTtyZXR1cm4gcmVtYXBUb1B5KGdldF9zZWxmKGkpW24uX19qc19wcm9wZXJ0eV0pfSkpfSksXFxcIkpzUHJvcGVydHlcXFwiLFtdKTtjb25zdCBwcm9wX3dyYXA9ZT0+U2subWlzY2V2YWwuY2FsbHNpbShpLkpzUHJvcGVydHksbmV3IFNrLmJ1aWx0aW5zLnN0cihlKSksdD1lLmNlbGxfYm90X2JsZV9ndWkuY2VsbF9ib3RfYmxlO3QmJihpLkNlbGxCb3Q9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhpLChmdW5jdGlvbihlLG4pe24uX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7aWYoIXQucGFpcmVkKCkpdGhyb3dcXFwiVGhlIENlbGxCb3QgaXMgbm90IHBhaXJlZC4gQ2xpY2sgb24gdGhlIFBhaXIgYnV0dG9uIGJlZm9yZSBydW5uaW5nIHlvdXIgcHJvZ3JhbS5cXFwiO3JldHVybiByZW1hcFRvUHkodC5yZXNldEhhcmR3YXJlKCkudGhlbigoKCk9Pnt9KSkpfSkpLG4uSU5QVVQ9bmV3IFNrLmJ1aWx0aW4uaW50Xyh0LklOUFVUKSxuLk9VVFBVVD1uZXcgU2suYnVpbHRpbi5pbnRfKHQuT1VUUFVUKTtjb25zdCB3cmFwPShlLG4pPT5uZXcgU2suYnVpbHRpbi5mdW5jKHJlbWFwVG9Kc0Z1bmMoZSxuLG4pKTtuLnJlc2V0SGFyZHdhcmU9d3JhcCh0LnJlc2V0SGFyZHdhcmUsMSksbi5waW5Nb2RlPXdyYXAodC5waW5Nb2RlLDMpLG4uZGlnaXRhbFdyaXRlPXdyYXAodC5kaWdpdGFsV3JpdGUsMyksbi5kaWdpdGFsUmVhZD13cmFwKHQuZGlnaXRhbFJlYWQsMiksbi5sZWRjU2V0dXA9d3JhcCh0LmxlZGNTZXR1cCw0KSxuLmxlZGNBdHRhY2hQaW49d3JhcCh0LmxlZGNBdHRhY2hQaW4sMyksbi5sZWRjRGV0YWNoUGluPXdyYXAodC5sZWRjRGV0YWNoUGluLDIpLG4ubGVkY1dyaXRlPXdyYXAodC5sZWRjV3JpdGUsMyl9KSxcXFwiQ2VsbEJvdFxcXCIsW10pKTtjb25zdCBtZXRob2Rfd3JhcD0oZSxuKT0+bmV3IFNrLmJ1aWx0aW4uZnVuYygoKC4uLmkpPT5yZW1hcFRvSnNGdW5jKGdldF9zZWxmKGlbMF0pW2VdLG4sbikoLi4uaSkpKTtpLl9TZW5zb3I9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhpLChmdW5jdGlvbihlLG4pe24uc3RhcnQ9bWV0aG9kX3dyYXAoXFxcInN0YXJ0XFxcIiwxKSxuLnN0b3A9bWV0aG9kX3dyYXAoXFxcInN0b3BcXFwiLDEpfSksXFxcIl9TZW5zb3JcXFwiLFtdKSxpLl9YWVpTZW5zb3I9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhpLChmdW5jdGlvbihlLG4pe24ueD1wcm9wX3dyYXAoXFxcInhcXFwiKSxuLnk9cHJvcF93cmFwKFxcXCJ5XFxcIiksbi56PXByb3Bfd3JhcChcXFwielxcXCIpfSksXFxcIl9YWVpTZW5zb3JcXFwiLFtpLl9TZW5zb3JdKSxpLl9PcmllbnRhdGlvblNlbnNvcj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsbil7bi5xdWF0ZXJuaW9uPXByb3Bfd3JhcChcXFwicXVhdGVybmlvblxcXCIpfSksXFxcIl9PcmllbnRhdGlvblNlbnNvclxcXCIsW2kuX1NlbnNvcl0pO2NvbnN0IHNlbnNvcl9mYWN0b3J5PShlLG4sdCk9PmlbZV09U2subWlzY2V2YWwuYnVpbGRDbGFzcyhpLChmdW5jdGlvbihlLG4pe24uX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oLi4uZSl7U2suYnVpbHRpbi5weUNoZWNrQXJncyhcXFwiX19pbml0X19cXFwiLFtlXSwxLDEpLGVbMF0uX19qc19jbGFzcz1uZXcgdH0pKX0pLGUsW25dKTtyZXR1cm4gaS5BbWJpZW50TGlnaHRTZW5zb3I9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhpLChmdW5jdGlvbihlLGkpe2kuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oLi4uZSl7U2suYnVpbHRpbi5weUNoZWNrQXJncyhcXFwiX19pbml0X19cXFwiLFtlXSwxLDEpLGVbMF0uX19qc19jbGFzcz1uZXcgbi5TaW1wbGVBbWJpZW50TGlnaHRTZW5zb3J9KSksaS5pbGx1bWluYW5jZT1wcm9wX3dyYXAoXFxcImlsbHVtaW5hbmNlXFxcIil9KSxcXFwiQW1iaWVudExpZ2h0U2Vuc29yXFxcIixbaS5fU2Vuc29yXSksaS5HZW9sb2NhdGlvblNlbnNvcj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsaSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiguLi5lKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJfX2luaXRfX1xcXCIsW2VdLDEsMSksZVswXS5fX2pzX2NsYXNzPW5ldyBuLlNpbXBsZUdlb2xvY2F0aW9uU2Vuc29yfSkpLGkubGF0aXR1ZGU9cHJvcF93cmFwKFxcXCJsYXRpdHVkZVxcXCIpLGkubG9uZ2l0dWRlPXByb3Bfd3JhcChcXFwibG9uZ2l0dWRlXFxcIiksaS5hbHRpdHVkZT1wcm9wX3dyYXAoXFxcImFsdGl0dWRlXFxcIiksaS5hY2N1cmFjeT1wcm9wX3dyYXAoXFxcImFjY3VyYWN5XFxcIiksaS5hbHRpdHVkZUFjY3VyYWN5PXByb3Bfd3JhcChcXFwiYWx0aXR1ZGVBY2N1cmFjeVxcXCIpLGkuaGVhZGluZz1wcm9wX3dyYXAoXFxcImhlYWRpbmdcXFwiKSxpLnNwZWVkPXByb3Bfd3JhcChcXFwic3BlZWRcXFwiKX0pLFxcXCJHZW9sb2NhdGlvblNlbnNvclxcXCIsW2kuX1NlbnNvcl0pLHNlbnNvcl9mYWN0b3J5KFxcXCJBY2NlbGVyb21ldGVyXFxcIixpLl9YWVpTZW5zb3Isbi5TaW1wbGVBY2NlbGVyb21ldGVyKSxzZW5zb3JfZmFjdG9yeShcXFwiR3lyb3Njb3BlXFxcIixpLl9YWVpTZW5zb3Isbi5TaW1wbGVHeXJvc2NvcGUpLHNlbnNvcl9mYWN0b3J5KFxcXCJNYWduZXRvbWV0ZXJcXFwiLGkuX1hZWlNlbnNvcixuLlNpbXBsZU1hZ25ldG9tZXRlciksc2Vuc29yX2ZhY3RvcnkoXFxcIkxpbmVhckFjY2VsZXJhdGlvblNlbnNvclxcXCIsaS5fWFlaU2Vuc29yLG4uU2ltcGxlTGluZWFyQWNjZWxlcmF0aW9uU2Vuc29yKSxzZW5zb3JfZmFjdG9yeShcXFwiR3Jhdml0eVNlbnNvclxcXCIsaS5fWFlaU2Vuc29yLG4uU2ltcGxlR3Jhdml0eVNlbnNvciksc2Vuc29yX2ZhY3RvcnkoXFxcIkFic29sdXRlT3JpZW50YXRpb25TZW5zb3JcXFwiLGkuX09yaWVudGF0aW9uU2Vuc29yLG4uU2ltcGxlQWJzb2x1dGVPcmllbnRhdGlvblNlbnNvciksc2Vuc29yX2ZhY3RvcnkoXFxcIlJlbGF0aXZlT3JpZW50YXRpb25TZW5zb3JcXFwiLGkuX09yaWVudGF0aW9uU2Vuc29yLG4uU2ltcGxlUmVsYXRpdmVPcmllbnRhdGlvblNlbnNvciksaX0pKSl9O1wiLFwic3JjL2xpYi9jb2xsZWN0aW9ucy5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUodCl7Y29uc3QgZT17fTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFxcXCJrZXl3b3JkXFxcIiwhMSwhMCksKHQ9PihlLl9pc2tleXdvcmQ9dC4kZC5pc2tleXdvcmQsU2suaW1wb3J0TW9kdWxlKFxcXCJpdGVydG9vbHNcXFwiLCExLCEwKSkpLCh0PT4oZS5fY2hhaW49dC4kZC5jaGFpbixlLl9zdGFybWFwPXQuJGQuc3Rhcm1hcCxlLl9yZXBlYXQ9dC4kZC5yZXBlYXQsU2suaW1wb3J0TW9kdWxlKFxcXCJvcGVyYXRvclxcXCIsITEsITApKSksKHQ9PntlLl9pdGVtZ2V0dGVyPXQuJGQuaXRlbWdldHRlcn0pLCgoKT0+Y29sbGVjdGlvbnNfbW9kKGUpKSl9ZnVuY3Rpb24gY29sbGVjdGlvbnNfbW9kKHQpe2Z1bmN0aW9uIGNvdW50ZXJOdW1iZXJTbG90KGUpe3JldHVybiBmdW5jdGlvbihpKXtpZih2b2lkIDAhPT1pJiYhKGkgaW5zdGFuY2VvZiB0LkNvdW50ZXIpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCBzPW5ldyB0LkNvdW50ZXI7cmV0dXJuIGUuY2FsbCh0aGlzLHMsaSksc319ZnVuY3Rpb24gY291bnRlcklucGxhY2VTbG90KHQsZSl7cmV0dXJuIGZ1bmN0aW9uKGkpe2lmKCEoaSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJDb3VudGVyIFxcXCIrdCtcXFwiPSBcXFwiK1NrLmFic3RyLnR5cGVOYW1lKGkpK1xcXCIgaXMgbm90IHN1cHBvcnRlZFxcXCIpO3JldHVybiBlLmNhbGwodGhpcyxpKSx0aGlzLmtlZXAkcG9zaXRpdmUoKX19dC5fX2FsbF9fPW5ldyBTay5idWlsdGluLmxpc3QoW1xcXCJkZXF1ZVxcXCIsXFxcImRlZmF1bHRkaWN0XFxcIixcXFwibmFtZWR0dXBsZVxcXCIsXFxcIkNvdW50ZXJcXFwiLFxcXCJPcmRlcmVkRGljdFxcXCJdLm1hcCgodD0+bmV3IFNrLmJ1aWx0aW4uc3RyKHQpKSkpLHQuZGVmYXVsdGRpY3Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcXFwiY29sbGVjdGlvbnMuZGVmYXVsdGRpY3RcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBkZWZhdWx0ZGljdCh0LGUpe3RoaXMuZGVmYXVsdF9mYWN0b3J5PXQsU2suYnVpbHRpbi5kaWN0LmNhbGwodGhpcyxlKX0sYmFzZTpTay5idWlsdGluLmRpY3QsbWV0aG9kczp7Y29weTp7JG1ldGgoKXtyZXR1cm4gdGhpcy4kY29weSgpfSwkZmxhZ3M6e05vQXJnczohMH19LF9fY29weV9fOnskbWV0aCgpe3JldHVybiB0aGlzLiRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfX0sX19taXNzaW5nX186eyRtZXRoKHQpe2lmKFNrLmJ1aWx0aW4uY2hlY2tOb25lKHRoaXMuZGVmYXVsdF9mYWN0b3J5KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcihTay5taXNjZXZhbC5vYmplY3RSZXByKHQpKTt7Y29uc3QgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5kZWZhdWx0X2ZhY3RvcnksW10pO3JldHVybiB0aGlzLm1wJGFzc19zdWJzY3JpcHQodCxlKSxlfX0sJGZsYWdzOntPbmVBcmc6ITB9fX0sZ2V0c2V0czp7ZGVmYXVsdF9mYWN0b3J5OnskZ2V0KCl7cmV0dXJuIHRoaXMuZGVmYXVsdF9mYWN0b3J5fSwkc2V0KHQpe3Q9dHx8U2suYnVpbHRpbi5ub25lLm5vbmUkLHRoaXMuZGVmYXVsdF9mYWN0b3J5PXR9fX0sc2xvdHM6e3RwJGRvYzpcXFwiZGVmYXVsdGRpY3QoZGVmYXVsdF9mYWN0b3J5WywgLi4uXSkgLS1cXFxceDNlIGRpY3Qgd2l0aCBkZWZhdWx0IGZhY3RvcnlcXFxcblxcXFxuVGhlIGRlZmF1bHQgZmFjdG9yeSBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMgdG8gcHJvZHVjZVxcXFxuYSBuZXcgdmFsdWUgd2hlbiBhIGtleSBpcyBub3QgcHJlc2VudCwgaW4gX19nZXRpdGVtX18gb25seS5cXFxcbkEgZGVmYXVsdGRpY3QgY29tcGFyZXMgZXF1YWwgdG8gYSBkaWN0IHdpdGggdGhlIHNhbWUgaXRlbXMuXFxcXG5BbGwgcmVtYWluaW5nIGFyZ3VtZW50cyBhcmUgdHJlYXRlZCB0aGUgc2FtZSBhcyBpZiB0aGV5IHdlcmVcXFxcbnBhc3NlZCB0byB0aGUgZGljdCBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIGtleXdvcmQgYXJndW1lbnRzLlxcXFxuXFxcIix0cCRpbml0KHQsZSl7Y29uc3QgaT10LnNoaWZ0KCk7aWYodm9pZCAwPT09aSl0aGlzLmRlZmF1bHRfZmFjdG9yeT1Tay5idWlsdGluLm5vbmUubm9uZSQ7ZWxzZXtpZighU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGkpJiYhU2suYnVpbHRpbi5jaGVja05vbmUoaSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGNhbGxhYmxlXFxcIik7dGhpcy5kZWZhdWx0X2ZhY3Rvcnk9aX1yZXR1cm4gU2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS50cCRpbml0LmNhbGwodGhpcyx0LGUpfSwkcigpe2NvbnN0IHQ9U2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLmRlZmF1bHRfZmFjdG9yeSksZT1Tay5idWlsdGluLmRpY3QucHJvdG90eXBlLiRyLmNhbGwodGhpcykudjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJkZWZhdWx0ZGljdChcXFwiK3QrXFxcIiwgXFxcIitlK1xcXCIpXFxcIil9fSxwcm90bzp7JGNvcHkoKXtjb25zdCBlPVtdO3JldHVybiBTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIodGhpcyksKHQ9PntlLnB1c2godCksZS5wdXNoKHRoaXMubXAkc3Vic2NyaXB0KHQpKX0pKSxuZXcgdC5kZWZhdWx0ZGljdCh0aGlzLmRlZmF1bHRfZmFjdG9yeSxlKX19fSksdC5Db3VudGVyPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXFxcIkNvdW50ZXJcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBDb3VudGVyKCl7dGhpcy4kZD1uZXcgU2suYnVpbHRpbi5kaWN0LFNrLmJ1aWx0aW4uZGljdC5hcHBseSh0aGlzKX0sYmFzZTpTay5idWlsdGluLmRpY3QsbWV0aG9kczp7ZWxlbWVudHM6eyRmbGFnczp7Tm9BcmdzOiEwfSwkbWV0aCgpe2NvbnN0IGU9dC5fY2hhaW4udHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXFxcImZyb21faXRlcmFibGVcXFwiKSksaT10Ll9zdGFybWFwLHM9dC5fcmVwZWF0LG49U2subWlzY2V2YWwuY2FsbHNpbUFycmF5O3JldHVybiBuKGUsW24oaSxbcyxuKHRoaXMudHAkZ2V0YXR0cih0aGlzLnN0ciRpdGVtcykpXSldKX19LG1vc3RfY29tbW9uOnskZmxhZ3M6e05hbWVkQXJnczpbXFxcIm5cXFwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ub25lLm5vbmUkXX0sJG1ldGgodCl7Y29uc3QgZT10aGlzLnNxJGxlbmd0aCgpO3Q9U2suYnVpbHRpbi5jaGVja05vbmUodCl8fCh0PVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KHQpKT5lP2U6dDwwPzA6dDtjb25zdCBpPXRoaXMuJGl0ZW1zKCkuc29ydCgoKHQsZSk9PlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0WzFdLGVbMV0sXFxcIkx0XFxcIik/MTpTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodFsxXSxlWzFdLFxcXCJHdFxcXCIpPy0xOjApKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChpLnNsaWNlKDAsdCkubWFwKCh0PT5uZXcgU2suYnVpbHRpbi50dXBsZSh0KSkpKX19LHVwZGF0ZTp7JGZsYWdzOntGYXN0Q2FsbDohMH0sJG1ldGgodCxlKXtyZXR1cm4gU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJ1cGRhdGVcXFwiLHQsMCwxKSx0aGlzLmNvdW50ZXIkdXBkYXRlKHQsZSl9fSxzdWJ0cmFjdDp7JGZsYWdzOntGYXN0Q2FsbDohMH0sJG1ldGgodCxlKXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcInN1YnRyYWN0XFxcIix0LDAsMSk7Y29uc3QgaT10WzBdO2lmKHZvaWQgMCE9PWkpaWYoaSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdClmb3IobGV0IHM9U2suYWJzdHIuaXRlcihpKSxuPXMudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1uO249cy50cCRpdGVybmV4dCgpKXtjb25zdCB0PXRoaXMubXAkc3Vic2NyaXB0KG4pO3RoaXMubXAkYXNzX3N1YnNjcmlwdChuLFNrLmFic3RyLm51bWJlckJpbk9wKHQsaS5tcCRzdWJzY3JpcHQobiksXFxcIlN1YlxcXCIpKX1lbHNlIGZvcihsZXQgcz1Tay5hYnN0ci5pdGVyKGkpLG49cy50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PW47bj1zLnRwJGl0ZXJuZXh0KCkpe2NvbnN0IHQ9dGhpcy5tcCRzdWJzY3JpcHQobik7dGhpcy5tcCRhc3Nfc3Vic2NyaXB0KG4sU2suYWJzdHIubnVtYmVyQmluT3AodCx0aGlzLiRvbmUsXFxcIlN1YlxcXCIpKX1lPWV8fFtdO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgdD1uZXcgU2suYnVpbHRpbi5zdHIoZVtzXSksaT10aGlzLm1wJHN1YnNjcmlwdCh0KTt0aGlzLm1wJGFzc19zdWJzY3JpcHQodCxTay5hYnN0ci5udW1iZXJCaW5PcChpLGVbcysxXSxcXFwiU3ViXFxcIikpfXJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9fSxfX21pc3NpbmdfXzp7JG1ldGgodCl7cmV0dXJuIHRoaXMuJHplcm99LCRmbGFnczp7T25lQXJnOiEwfX0sY29weTp7JG1ldGgoKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuQ291bnRlcixbdGhpc10pfSwkZmxhZ3M6e05vQXJnczohMH19fSxnZXRzZXRzOntfX2RpY3RfXzpTay5nZW5lcmljLmdldFNldERpY3R9LHNsb3RzOnt0cCRkb2M6XFxcIkRpY3Qgc3ViY2xhc3MgZm9yIGNvdW50aW5nIGhhc2hhYmxlIGl0ZW1zLiAgU29tZXRpbWVzIGNhbGxlZCBhIGJhZ1xcXFxuICAgIG9yIG11bHRpc2V0LiAgRWxlbWVudHMgYXJlIHN0b3JlZCBhcyBkaWN0aW9uYXJ5IGtleXMgYW5kIHRoZWlyIGNvdW50c1xcXFxuICAgIGFyZSBzdG9yZWQgYXMgZGljdGlvbmFyeSB2YWx1ZXMuXFxcXG5cXFxcbiAgICA+Pj4gYyA9IENvdW50ZXIoJ2FiY2RlYWJjZGFiY2FiYScpICAjIGNvdW50IGVsZW1lbnRzIGZyb20gYSBzdHJpbmdcXFxcblxcXFxuICAgID4+PiBjLm1vc3RfY29tbW9uKDMpICAgICAgICAgICAgICAgICMgdGhyZWUgbW9zdCBjb21tb24gZWxlbWVudHNcXFxcbiAgICBbKCdhJywgNSksICgnYicsIDQpLCAoJ2MnLCAzKV1cXFxcbiAgICA+Pj4gc29ydGVkKGMpICAgICAgICAgICAgICAgICAgICAgICAjIGxpc3QgYWxsIHVuaXF1ZSBlbGVtZW50c1xcXFxuICAgIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cXFxcbiAgICA+Pj4gJycuam9pbihzb3J0ZWQoYy5lbGVtZW50cygpKSkgICAjIGxpc3QgZWxlbWVudHMgd2l0aCByZXBldGl0aW9uc1xcXFxuICAgICdhYWFhYWJiYmJjY2NkZGUnXFxcXG4gICAgPj4+IHN1bShjLnZhbHVlcygpKSAgICAgICAgICAgICAgICAgIyB0b3RhbCBvZiBhbGwgY291bnRzXFxcXG4gICAgMTVcXFxcblxcXFxuICAgID4+PiBjWydhJ10gICAgICAgICAgICAgICAgICAgICAgICAgICMgY291bnQgb2YgbGV0dGVyICdhJ1xcXFxuICAgIDVcXFxcbiAgICA+Pj4gZm9yIGVsZW0gaW4gJ3NoYXphbSc6ICAgICAgICAgICAjIHVwZGF0ZSBjb3VudHMgZnJvbSBhbiBpdGVyYWJsZVxcXFxuICAgIC4uLiAgICAgY1tlbGVtXSArPSAxICAgICAgICAgICAgICAgICMgYnkgYWRkaW5nIDEgdG8gZWFjaCBlbGVtZW50J3MgY291bnRcXFxcbiAgICA+Pj4gY1snYSddICAgICAgICAgICAgICAgICAgICAgICAgICAjIG5vdyB0aGVyZSBhcmUgc2V2ZW4gJ2EnXFxcXG4gICAgN1xcXFxuICAgID4+PiBkZWwgY1snYiddICAgICAgICAgICAgICAgICAgICAgICMgcmVtb3ZlIGFsbCAnYidcXFxcbiAgICA+Pj4gY1snYiddICAgICAgICAgICAgICAgICAgICAgICAgICAjIG5vdyB0aGVyZSBhcmUgemVybyAnYidcXFxcbiAgICAwXFxcXG5cXFxcbiAgICA+Pj4gZCA9IENvdW50ZXIoJ3NpbXNhbGFiaW0nKSAgICAgICAjIG1ha2UgYW5vdGhlciBjb3VudGVyXFxcXG4gICAgPj4+IGMudXBkYXRlKGQpICAgICAgICAgICAgICAgICAgICAgIyBhZGQgaW4gdGhlIHNlY29uZCBjb3VudGVyXFxcXG4gICAgPj4+IGNbJ2EnXSAgICAgICAgICAgICAgICAgICAgICAgICAgIyBub3cgdGhlcmUgYXJlIG5pbmUgJ2EnXFxcXG4gICAgOVxcXFxuXFxcXG4gICAgPj4+IGMuY2xlYXIoKSAgICAgICAgICAgICAgICAgICAgICAgIyBlbXB0eSB0aGUgY291bnRlclxcXFxuICAgID4+PiBjXFxcXG4gICAgQ291bnRlcigpXFxcXG5cXFxcbiAgICBOb3RlOiAgSWYgYSBjb3VudCBpcyBzZXQgdG8gemVybyBvciByZWR1Y2VkIHRvIHplcm8sIGl0IHdpbGwgcmVtYWluXFxcXG4gICAgaW4gdGhlIGNvdW50ZXIgdW50aWwgdGhlIGVudHJ5IGlzIGRlbGV0ZWQgb3IgdGhlIGNvdW50ZXIgaXMgY2xlYXJlZDpcXFxcblxcXFxuICAgID4+PiBjID0gQ291bnRlcignYWFhYmJjJylcXFxcbiAgICA+Pj4gY1snYiddIC09IDIgICAgICAgICAgICAgICAgICAgICAjIHJlZHVjZSB0aGUgY291bnQgb2YgJ2InIGJ5IHR3b1xcXFxuICAgID4+PiBjLm1vc3RfY29tbW9uKCkgICAgICAgICAgICAgICAgICMgJ2InIGlzIHN0aWxsIGluLCBidXQgaXRzIGNvdW50IGlzIHplcm9cXFxcbiAgICBbKCdhJywgMyksICgnYycsIDEpLCAoJ2InLCAwKV1cXFxcblxcXFxuXFxcIix0cCRpbml0KHQsZSl7cmV0dXJuIFNrLmFic3RyLmNoZWNrQXJnc0xlbih0aGlzLnRwanNfbmFtZSx0LDAsMSksdGhpcy5jb3VudGVyJHVwZGF0ZSh0LGUpfSwkcigpe2NvbnN0IHQ9dGhpcy5zaXplPjA/U2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS4kci5jYWxsKHRoaXMpLnY6XFxcIlxcXCI7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcXFwiKFxcXCIrdCtcXFwiKVxcXCIpfSx0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLG1wJGFzc19zdWJzY3JpcHQodCxlKXtyZXR1cm4gdm9pZCAwPT09ZT90aGlzLm1wJGxvb2t1cCh0KSYmU2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS5tcCRhc3Nfc3Vic2NyaXB0LmNhbGwodGhpcyx0LGUpOlNrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUubXAkYXNzX3N1YnNjcmlwdC5jYWxsKHRoaXMsdCxlKX0sdHAkYXNfbnVtYmVyOiEwLG5iJHBvc2l0aXZlOmNvdW50ZXJOdW1iZXJTbG90KChmdW5jdGlvbih0KXt0aGlzLiRpdGVtcygpLmZvckVhY2goKChbZSxpXSk9PntTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaSx0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZ0Lm1wJGFzc19zdWJzY3JpcHQoZSxpKX0pKX0pKSxuYiRuZWdhdGl2ZTpjb3VudGVyTnVtYmVyU2xvdCgoZnVuY3Rpb24odCl7dGhpcy4kaXRlbXMoKS5mb3JFYWNoKCgoW2UsaV0pPT57U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGksdGhpcy4kemVybyxcXFwiTHRcXFwiKSYmdC5tcCRhc3Nfc3Vic2NyaXB0KGUsU2suYWJzdHIubnVtYmVyQmluT3AodGhpcy4kemVybyxpLFxcXCJTdWJcXFwiKSl9KSl9KSksbmIkc3VidHJhY3Q6Y291bnRlck51bWJlclNsb3QoKGZ1bmN0aW9uKHQsZSl7dGhpcy4kaXRlbXMoKS5mb3JFYWNoKCgoW2ksc10pPT57Y29uc3Qgbj1Tay5hYnN0ci5udW1iZXJCaW5PcChzLGUubXAkc3Vic2NyaXB0KGkpLFxcXCJTdWJcXFwiKTtTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wobix0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZ0Lm1wJGFzc19zdWJzY3JpcHQoaSxuKX0pKSxlLiRpdGVtcygpLmZvckVhY2goKChbZSxpXSk9Pnt2b2lkIDA9PT10aGlzLm1wJGxvb2t1cChlKSYmU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGksdGhpcy4kemVybyxcXFwiTHRcXFwiKSYmdC5tcCRhc3Nfc3Vic2NyaXB0KGUsU2suYWJzdHIubnVtYmVyQmluT3AodGhpcy4kemVybyxpLFxcXCJTdWJcXFwiKSl9KSl9KSksbmIkYWRkOmNvdW50ZXJOdW1iZXJTbG90KChmdW5jdGlvbih0LGUpe3RoaXMuJGl0ZW1zKCkuZm9yRWFjaCgoKFtpLHNdKT0+e2NvbnN0IG49U2suYWJzdHIubnVtYmVyQmluT3AocyxlLm1wJHN1YnNjcmlwdChpKSxcXFwiQWRkXFxcIik7U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKG4sdGhpcy4kemVybyxcXFwiR3RcXFwiKSYmdC5tcCRhc3Nfc3Vic2NyaXB0KGksbil9KSksZS4kaXRlbXMoKS5mb3JFYWNoKCgoW2UsaV0pPT57dm9pZCAwPT09dGhpcy5tcCRsb29rdXAoZSkmJlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChpLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJnQubXAkYXNzX3N1YnNjcmlwdChlLGkpfSkpfSkpLG5iJGlucGxhY2VfYWRkOmNvdW50ZXJJbnBsYWNlU2xvdChcXFwiK1xcXCIsKGZ1bmN0aW9uKHQpe3QuJGl0ZW1zKCkuZm9yRWFjaCgoKFt0LGVdKT0+e2NvbnN0IGk9U2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKHRoaXMubXAkc3Vic2NyaXB0KHQpLGUsXFxcIkFkZFxcXCIpO3RoaXMubXAkYXNzX3N1YnNjcmlwdCh0LGkpfSkpfSkpLG5iJGlucGxhY2Vfc3VidHJhY3Q6Y291bnRlcklucGxhY2VTbG90KFxcXCItXFxcIiwoZnVuY3Rpb24odCl7dC4kaXRlbXMoKS5mb3JFYWNoKCgoW3QsZV0pPT57Y29uc3QgaT1Tay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AodGhpcy5tcCRzdWJzY3JpcHQodCksZSxcXFwiU3ViXFxcIik7dGhpcy5tcCRhc3Nfc3Vic2NyaXB0KHQsaSl9KSl9KSksbmIkb3I6Y291bnRlck51bWJlclNsb3QoKGZ1bmN0aW9uKHQsZSl7dGhpcy4kaXRlbXMoKS5mb3JFYWNoKCgoW2ksc10pPT57Y29uc3Qgbj1lLm1wJHN1YnNjcmlwdChpKSxyPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChzLG4sXFxcIkx0XFxcIik/bjpzO1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChyLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJnQubXAkYXNzX3N1YnNjcmlwdChpLHIpfSkpLGUuJGl0ZW1zKCkuZm9yRWFjaCgoKFtlLGldKT0+e3ZvaWQgMD09PXRoaXMubXAkbG9va3VwKGUpJiZTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaSx0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZ0Lm1wJGFzc19zdWJzY3JpcHQoZSxpKX0pKX0pKSxuYiRhbmQ6Y291bnRlck51bWJlclNsb3QoKGZ1bmN0aW9uKHQsZSl7dGhpcy4kaXRlbXMoKS5mb3JFYWNoKCgoW2ksc10pPT57Y29uc3Qgbj1lLm1wJHN1YnNjcmlwdChpKSxyPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChzLG4sXFxcIkx0XFxcIik/czpuO1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChyLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJnQubXAkYXNzX3N1YnNjcmlwdChpLHIpfSkpfSkpLG5iJGlucGxhY2VfYW5kOmNvdW50ZXJJbnBsYWNlU2xvdChcXFwiJlxcXCIsKGZ1bmN0aW9uKHQpe3RoaXMuJGl0ZW1zKCkuZm9yRWFjaCgoKFtlLGldKT0+e2NvbnN0IHM9dC5tcCRzdWJzY3JpcHQoZSk7U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHMsaSxcXFwiTHRcXFwiKSYmdGhpcy5tcCRhc3Nfc3Vic2NyaXB0KGUscyl9KSl9KSksbmIkaW5wbGFjZV9vcjpjb3VudGVySW5wbGFjZVNsb3QoXFxcInxcXFwiLChmdW5jdGlvbih0KXt0LiRpdGVtcygpLmZvckVhY2goKChbdCxlXSk9PntTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZSx0aGlzLm1wJHN1YnNjcmlwdCh0KSxcXFwiR3RcXFwiKSYmdGhpcy5tcCRhc3Nfc3Vic2NyaXB0KHQsZSl9KSl9KSksbmIkcmVmbGVjdGVkX2FuZDpudWxsLG5iJHJlZmxlY3RlZF9vcjpudWxsLG5iJHJlZmxlY3RlZF9hZGQ6bnVsbCxuYiRyZWZsZWN0ZWRfc3VidHJhY3Q6bnVsbH0scHJvdG86e2tlZXAkcG9zaXRpdmUoKXtyZXR1cm4gdGhpcy4kaXRlbXMoKS5mb3JFYWNoKCgoW3QsZV0pPT57U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGUsdGhpcy4kemVybyxcXFwiTHRFXFxcIikmJnRoaXMubXAkYXNzX3N1YnNjcmlwdCh0KX0pKSx0aGlzfSwkemVybzpuZXcgU2suYnVpbHRpbi5pbnRfKDApLCRvbmU6bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxzdHIkaXRlbXM6bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJpdGVtc1xcXCIpLGNvdW50ZXIkdXBkYXRlKHQsZSl7Y29uc3QgaT10WzBdO2lmKHZvaWQgMCE9PWkpaWYoU2suYnVpbHRpbi5jaGVja01hcHBpbmcoaSkpaWYodGhpcy5zcSRsZW5ndGgoKSlmb3IobGV0IHM9U2suYWJzdHIuaXRlcihpKSxuPXMudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1uO249cy50cCRpdGVybmV4dCgpKXtjb25zdCB0PXRoaXMubXAkc3Vic2NyaXB0KG4pO3RoaXMubXAkYXNzX3N1YnNjcmlwdChuLFNrLmFic3RyLm51bWJlckJpbk9wKHQsaS5tcCRzdWJzY3JpcHQobiksXFxcIkFkZFxcXCIpKX1lbHNlIHRoaXMudXBkYXRlJGNvbW1vbih0LHZvaWQgMCxcXFwidXBkYXRlXFxcIik7ZWxzZSBmb3IobGV0IHM9U2suYWJzdHIuaXRlcihpKSxuPXMudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1uO249cy50cCRpdGVybmV4dCgpKXtjb25zdCB0PXRoaXMubXAkc3Vic2NyaXB0KG4pO3RoaXMubXAkYXNzX3N1YnNjcmlwdChuLFNrLmFic3RyLm51bWJlckJpbk9wKHQsdGhpcy4kb25lLFxcXCJBZGRcXFwiKSl9aWYoZSYmZS5sZW5ndGgpaWYodGhpcy5zcSRsZW5ndGgoKSlmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrPTIpe2NvbnN0IHQ9bmV3IFNrLmJ1aWx0aW4uc3RyKGVbc10pLGk9dGhpcy5tcCRzdWJzY3JpcHQodCk7dGhpcy5tcCRhc3Nfc3Vic2NyaXB0KHQsU2suYWJzdHIubnVtYmVyQmluT3AoaSxlW3MrMV0sXFxcIkFkZFxcXCIpKX1lbHNlIHRoaXMudXBkYXRlJGNvbW1vbihbXSxlLFxcXCJ1cGRhdGVcXFwiKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfX0sY2xhc3NtZXRob2RzOntmcm9ta2V5czp7JG1ldGg6ZnVuY3Rpb24gZnJvbWtleXMoKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJDb3VudGVyLmZyb21rZXlzKCkgaXMgdW5kZWZpbmVkLiAgVXNlIENvdW50ZXIoaXRlcmFibGUpIGluc3RlYWQuXFxcIil9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn19fX0pLHQuT3JkZXJlZERpY3Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcXFwiY29sbGVjdGlvbnMuT3JkZXJlZERpY3RcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBPcmRlcmVkRGljdCgpe1NrLmJ1aWx0aW4uZGljdC5jYWxsKHRoaXMpfSxiYXNlOlNrLmJ1aWx0aW4uZGljdCxzbG90czp7dHAkZG9jOlxcXCJEaWN0aW9uYXJ5IHRoYXQgcmVtZW1iZXJzIGluc2VydGlvbiBvcmRlclxcXCIsJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcXFwiLi4uXFxcIik7dGhpcy5pbiRyZXByPSEwO2xldCB0PXRoaXMuJGl0ZW1zKCkubWFwKCgoW3QsZV0pPT5gKCR7U2subWlzY2V2YWwub2JqZWN0UmVwcih0KX0sICR7U2subWlzY2V2YWwub2JqZWN0UmVwcihlKX0pYCkpO3JldHVybiB0PTA9PT10Lmxlbmd0aD9cXFwiXFxcIjpcXFwiW1xcXCIrdC5qb2luKFxcXCIsIFxcXCIpK1xcXCJdXFxcIix0aGlzLmluJHJlcHI9ITEsbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1xcXCIoXFxcIit0K1xcXCIpXFxcIil9LHRwJHJpY2hjb21wYXJlKGUsaSl7aWYoXFxcIkVxXFxcIiE9PWkmJlxcXCJOZVxcXCIhPT1pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtpZighKGUgaW5zdGFuY2VvZiB0Lk9yZGVyZWREaWN0KSlyZXR1cm4gU2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS50cCRyaWNoY29tcGFyZS5jYWxsKHRoaXMsZSxpKTtjb25zdCBzPVxcXCJFcVxcXCI9PWksbj10aGlzLnNpemU7aWYobiE9PWUuc2l6ZSlyZXR1cm4hcztjb25zdCByPWUuJGl0ZW1zKCksYT10aGlzLiRpdGVtcygpO2ZvcihsZXQgdD0wO3Q8bjt0Kyspe2NvbnN0IGU9YVt0XSxpPXJbdF0sbj1lWzBdLG89aVswXTtpZihuIT09byYmIVNrLm1pc2NldmFsLmlzVHJ1ZShTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wobixvLFxcXCJFcVxcXCIpKSlyZXR1cm4hcztjb25zdCBsPWVbMV0saD1pWzFdO2lmKGwhPT1oJiYhU2subWlzY2V2YWwuaXNUcnVlKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChsLGgsXFxcIkVxXFxcIikpKXJldHVybiFzfXJldHVybiBzfX0sbWV0aG9kczp7cG9waXRlbTp7JGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJsYXN0XFxcIl0sRGVmYXVsdHM6W1NrLmJ1aWx0aW4uYm9vbC50cnVlJF19LCRtZXRoKHQpe2NvbnN0IGU9dGhpcy5nZXQkc2l6ZSgpO2lmKDA9PT1lKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKFxcXCJkaWN0aW9uYXJ5IGlzIGVtcHR5XFxcIik7Y29uc3RbaSxzXT10aGlzLiRpdGVtcygpW1NrLm1pc2NldmFsLmlzVHJ1ZSh0KT9lLTE6MF07cmV0dXJuIHRoaXMucG9wJGl0ZW0oaSksbmV3IFNrLmJ1aWx0aW4udHVwbGUoW2ksc10pfX0sbW92ZV90b19lbmQ6eyRmbGFnczp7TmFtZWRBcmdzOltcXFwia2V5XFxcIixcXFwibGFzdFxcXCJdLERlZmF1bHRzOltTay5idWlsdGluLmJvb2wudHJ1ZSRdfSwkbWV0aCh0LGUpe2xldCBpO2ZvcihsZXQgbiBpbiB0aGlzLmVudHJpZXMpe2NvbnN0IGU9dGhpcy5lbnRyaWVzW25dWzBdO2lmKGU9PT10fHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZSx0LFxcXCJFcVxcXCIpKXtpPW47YnJlYWt9fWlmKHZvaWQgMD09PWkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uS2V5RXJyb3IodCk7Y29uc3Qgcz10aGlzLmVudHJpZXNbaV07cmV0dXJuIGRlbGV0ZSB0aGlzLmVudHJpZXNbaV0sU2subWlzY2V2YWwuaXNUcnVlKGUpP3RoaXMuZW50cmllc1tpXT1zOnRoaXMuZW50cmllcz17W2ldOnMsLi4udGhpcy5lbnRyaWVzfSxTay5idWlsdGluLm5vbmUubm9uZSR9fX19KSx0LmRlcXVlPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXFxcImNvbGxlY3Rpb25zLmRlcXVlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gZGVxdWUodCxlLGkscyxuKXt0aGlzLmhlYWQ9aXx8MCx0aGlzLnRhaWw9c3x8MCx0aGlzLm1hc2s9bnx8MSx0aGlzLm1heGxlbj1lLHRoaXMudj10fHxuZXcgQXJyYXkoMil9LHNsb3RzOnt0cCRkb2M6XFxcImRlcXVlKFtpdGVyYWJsZVssIG1heGxlbl1dKSAtLVxcXFx4M2UgZGVxdWUgb2JqZWN0XFxcXG5cXFxcbkEgbGlzdC1saWtlIHNlcXVlbmNlIG9wdGltaXplZCBmb3IgZGF0YSBhY2Nlc3NlcyBuZWFyIGl0cyBlbmRwb2ludHMuXFxcIix0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRuZXc6U2suZ2VuZXJpYy5uZXcsdHAkaW5pdCh0LGUpe2xldFtpLHNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJkZXF1ZVxcXCIsW1xcXCJpdGVyYWJsZVxcXCIsXFxcIm1heGxlblxcXCJdLHQsZSk7aWYodm9pZCAwIT09cyYmIVNrLmJ1aWx0aW4uY2hlY2tOb25lKHMpKXtpZihzPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChzLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcixcXFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFxcXCIpLHM8MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJtYXhsZW4gbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTt0aGlzLm1heGxlbj1zfXRoaXMuJGNsZWFyKCksdm9pZCAwIT09aSYmdGhpcy4kZXh0ZW5kKGkpfSx0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRyaWNoY29tcGFyZShlLGkpe2lmKHRoaXM9PT1lJiZTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5KGkpKXJldHVybiEwO2lmKCEoZSBpbnN0YW5jZW9mIHQuZGVxdWUpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCBzPWUsbj10aGlzLnY7ZT1lLnY7Y29uc3Qgcj10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzayxhPXMudGFpbC1zLmhlYWQmcy5tYXNrO2xldCBvLGw9TWF0aC5tYXgocixhKTtpZihyPT09YSlmb3IobD0wO2w8ciYmbDxhJiYobz1Tay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woblt0aGlzLmhlYWQrbCZ0aGlzLm1hc2tdLGVbcy5oZWFkK2wmcy5tYXNrXSxcXFwiRXFcXFwiKSxvKTsrK2wpO2lmKGw+PXJ8fGw+PWEpc3dpdGNoKGkpe2Nhc2VcXFwiTHRcXFwiOnJldHVybiByPGE7Y2FzZVxcXCJMdEVcXFwiOnJldHVybiByPD1hO2Nhc2VcXFwiRXFcXFwiOnJldHVybiByPT09YTtjYXNlXFxcIk5vdEVxXFxcIjpyZXR1cm4gciE9PWE7Y2FzZVxcXCJHdFxcXCI6cmV0dXJuIHI+YTtjYXNlXFxcIkd0RVxcXCI6cmV0dXJuIHI+PWF9cmV0dXJuXFxcIkVxXFxcIiE9PWkmJihcXFwiTm90RXFcXFwiPT09aXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKG5bdGhpcy5oZWFkK2wmdGhpcy5tYXNrXSxlW3MuaGVhZCtsJnMubWFza10saSkpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBlKHRoaXMpfSwkcigpe2NvbnN0IHQ9W10sZT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztpZih0aGlzLiRlbnRlcmVkX3JlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcXFwiWy4uLl1cXFwiKTt0aGlzLiRlbnRlcmVkX3JlcHI9ITA7Zm9yKGxldCBzPTA7czxlO3MrKyl0LnB1c2goU2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLnZbdGhpcy5oZWFkK3MmdGhpcy5tYXNrXSkpO2NvbnN0IGk9U2suYWJzdHIudHlwZU5hbWUodGhpcyk7cmV0dXJuIHZvaWQgMCE9PXRoaXMubWF4bGVuP25ldyBTay5idWlsdGluLnN0cihpK1xcXCIoW1xcXCIrdC5maWx0ZXIoQm9vbGVhbikuam9pbihcXFwiLCBcXFwiKStcXFwiXSwgbWF4bGVuPVxcXCIrdGhpcy5tYXhsZW4rXFxcIilcXFwiKToodGhpcy4kZW50ZXJlZF9yZXByPXZvaWQgMCxuZXcgU2suYnVpbHRpbi5zdHIoaStcXFwiKFtcXFwiK3QuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXFxcIiwgXFxcIikrXFxcIl0pXFxcIikpfSx0cCRhc19udW1iZXI6ITAsbmIkYm9vbCgpe3JldHVybiAwIT0odGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2spfSx0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHNxJGNvbnRhaW5zKHQpe2ZvcihsZXQgZT10aGlzLnRwJGl0ZXIoKSxpPWUudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9ZS50cCRpdGVybmV4dCgpKWlmKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChpLHQsXFxcIkVxXFxcIikpcmV0dXJuITA7cmV0dXJuITF9LHNxJGNvbmNhdChlKXtpZighKGUgaW5zdGFuY2VvZiB0LmRlcXVlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImNhbiBvbmx5IGNvbmNhdGVuYXRlIGRlcXVlIChub3QgJ1xcXCIrU2suYWJzdHIudHlwZU5hbWUoZSkrXFxcIicpIHRvIGRlcXVlXFxcIik7Y29uc3QgaT10aGlzLiRjb3B5KCk7Zm9yKGxldCB0PWUudHAkaXRlcigpLHM9dC50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PXM7cz10LnRwJGl0ZXJuZXh0KCkpaS4kcHVzaChzKTtyZXR1cm4gaX0sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrfSxzcSRyZXBlYXQodCl7dD1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyh0LFxcXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ3t0cCRuYW1lfSdcXFwiKTtjb25zdCBlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrLGk9dGhpcy4kY29weSgpO2xldCBzO3Q8PTAmJmkuJGNsZWFyKCk7Zm9yKGxldCBuPTE7bjx0O24rKylmb3IobGV0IHQ9MDt0PGU7dCsrKXM9dGhpcy5oZWFkK3QmdGhpcy5tYXNrLGkuJHB1c2godGhpcy52W3NdKTtyZXR1cm4gaX0sbXAkc3Vic2NyaXB0KHQpe3Q9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3codCk7Y29uc3QgZT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztpZih0Pj1lfHx0PC1lKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXFxcImRlcXVlIGluZGV4IG91dCBvZiByYW5nZVxcXCIpO2NvbnN0IGk9KHQ+PTA/dGhpcy5oZWFkOnRoaXMudGFpbCkrdCZ0aGlzLm1hc2s7cmV0dXJuIHRoaXMudltpXX0sbXAkYXNzX3N1YnNjcmlwdCh0LGUpe3Q9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3codCk7Y29uc3QgaT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztpZih0Pj1pfHx0PC1pKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXFxcImRlcXVlIGluZGV4IG91dCBvZiByYW5nZVxcXCIpO3ZvaWQgMD09PWU/dGhpcy5kZWwkaXRlbSh0KTp0aGlzLnNldCRpdGVtKHQsZSl9LG5iJGlucGxhY2VfYWRkKHQpe3RoaXMubWF4bGVuPXZvaWQgMDtmb3IobGV0IGU9U2suYWJzdHIuaXRlcih0KSxpPWUudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9ZS50cCRpdGVybmV4dCgpKXRoaXMuJHB1c2goaSk7cmV0dXJuIHRoaXN9LG5iJGlucGxhY2VfbXVsdGlwbHkodCl7KHQ9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHQsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yLFxcXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ3t0cCRuYW1lfSdcXFwiKSk8PTAmJnRoaXMuJGNsZWFyKCk7Y29uc3QgZT10aGlzLiRjb3B5KCksaT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztmb3IobGV0IHM9MTtzPHQ7cysrKWZvcihsZXQgdD0wO3Q8aTt0Kyspe2NvbnN0IGk9dGhpcy5oZWFkK3QmdGhpcy5tYXNrO2UuJHB1c2godGhpcy52W2ldKX1yZXR1cm4gdGhpcy52PWUudix0aGlzLmhlYWQ9ZS5oZWFkLHRoaXMudGFpbD1lLnRhaWwsdGhpcy5tYXNrPWUubWFzayx0aGlzfX0sbWV0aG9kczp7YXBwZW5kOnskbWV0aCh0KXtyZXR1cm4gdGhpcy4kcHVzaCh0KSxTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkFkZCBhbiBlbGVtZW50IHRvIHRoZSByaWdodCBzaWRlIG9mIHRoZSBkZXF1ZS5cXFwifSxhcHBlbmRsZWZ0OnskbWV0aCh0KXtyZXR1cm4gdGhpcy4kcHVzaExlZnQodCksU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJBZGQgYW4gZWxlbWVudCB0byB0aGUgbGVmdCBzaWRlIG9mIHRoZSBkZXF1ZS5cXFwifSxjbGVhcjp7JG1ldGgoKXtyZXR1cm4gdGhpcy4kY2xlYXIoKSxTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgZGVxdWUuXFxcIn0sX19jb3B5X186eyRtZXRoKCl7cmV0dXJuIHRoaXMuJGNvcHkoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIGEgc2hhbGxvdyBjb3B5IG9mIGEgZGVxdWUuXFxcIn0sY29weTp7JG1ldGgoKXtyZXR1cm4gdGhpcy4kY29weSgpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gYSBzaGFsbG93IGNvcHkgb2YgYSBkZXF1ZS5cXFwifSxjb3VudDp7JG1ldGgodCl7Y29uc3QgZT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztsZXQgaT0wO2ZvcihsZXQgcz0wO3M8ZTtzKyspU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHRoaXMudlt0aGlzLmhlYWQrcyZ0aGlzLm1hc2tdLHQsXFxcIkVxXFxcIikmJmkrKztyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRC5jb3VudCh2YWx1ZSkgLT4gaW50ZWdlciAtLSByZXR1cm4gbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHZhbHVlXFxcIn0sZXh0ZW5kOnskbWV0aCh0KXtyZXR1cm4gdGhpcy4kZXh0ZW5kKHQpLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRXh0ZW5kIHRoZSByaWdodCBzaWRlIG9mIHRoZSBkZXF1ZSB3aXRoIGVsZW1lbnRzIGZyb20gdGhlIGl0ZXJhYmxlXFxcIn0sZXh0ZW5kbGVmdDp7JG1ldGgodCl7Zm9yKGxldCBlPVNrLmFic3RyLml0ZXIodCksaT1lLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09aTtpPWUudHAkaXRlcm5leHQoKSl0aGlzLiRwdXNoTGVmdChpKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJFeHRlbmQgdGhlIGxlZnQgc2lkZSBvZiB0aGUgZGVxdWUgd2l0aCBlbGVtZW50cyBmcm9tIHRoZSBpdGVyYWJsZVxcXCJ9LGluZGV4OnskbWV0aCh0LGUsaSl7Y29uc3Qgcz10aGlzLiRpbmRleCh0LGUsaSk7aWYodm9pZCAwIT09cylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhzKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIodCkrXFxcIiBpcyBub3QgaW4gZGVxdWVcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkQuaW5kZXgodmFsdWUsIFtzdGFydCwgW3N0b3BdXSkgLT4gaW50ZWdlciAtLSByZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUuXFxcXG5SYWlzZXMgVmFsdWVFcnJvciBpZiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQuXFxcIn0saW5zZXJ0OnskbWV0aCh0LGUpe3Q9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3codCxcXFwiaW50ZWdlciBhcmd1bWVudCBleHBlY3RlZCwgZ290IHt0cCRuYW1lfVxcXCIpO2NvbnN0IGk9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7aWYodm9pZCAwIT09dGhpcy5tYXhsZW4mJmk+PXRoaXMubWF4bGVuKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXFxcImRlcXVlIGFscmVhZHkgYXQgaXRzIG1heGltdW0gc2l6ZVxcXCIpO3Q+aSYmKHQ9aSksdDw9LWkmJih0PTApO2NvbnN0IHM9KHQ+PTA/dGhpcy5oZWFkOnRoaXMudGFpbCkrdCZ0aGlzLm1hc2s7bGV0IG49dGhpcy50YWlsO2Zvcih0aGlzLnRhaWw9dGhpcy50YWlsKzEmdGhpcy5tYXNrO24hPT1zOyl7Y29uc3QgdD1uLTEmdGhpcy5tYXNrO3RoaXMudltuXT10aGlzLnZbdF0sbj10fXJldHVybiB0aGlzLnZbc109ZSx0aGlzLmhlYWQ9PT10aGlzLnRhaWwmJnRoaXMuJHJlc2l6ZSh0aGlzLnYubGVuZ3RoLHRoaXMudi5sZW5ndGg8PDEpLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkQuaW5zZXJ0KGluZGV4LCBvYmplY3QpIC0tIGluc2VydCBvYmplY3QgYmVmb3JlIGluZGV4XFxcIn0scG9wOnskbWV0aCgpe3JldHVybiB0aGlzLiRwb3AoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmVtb3ZlIGFuZCByZXR1cm4gdGhlIHJpZ2h0bW9zdCBlbGVtZW50LlxcXCJ9LHBvcGxlZnQ6eyRtZXRoKCl7cmV0dXJuIHRoaXMuJHBvcExlZnQoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGxlZnRtb3N0IGVsZW1lbnQuXFxcIn0scmVtb3ZlOnskbWV0aCh0KXtjb25zdCBlPXRoaXMuJGluZGV4KHQpO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihTay5taXNjZXZhbC5vYmplY3RSZXByKHQpK1xcXCIgaXMgbm90IGluIGRlcXVlXFxcIik7bGV0IGk9dGhpcy5oZWFkK2UmdGhpcy5tYXNrO2Zvcig7aSE9PXRoaXMudGFpbDspe2NvbnN0IHQ9aSsxJnRoaXMubWFzazt0aGlzLnZbaV09dGhpcy52W3RdLGk9dH10aGlzLnRhaWw9dGhpcy50YWlsLTEmdGhpcy5tYXNrO3ZhciBzPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO3M8dGhpcy5tYXNrPj4+MSYmdGhpcy4kcmVzaXplKHMsdGhpcy52Lmxlbmd0aD4+PjEpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJELnJlbW92ZSh2YWx1ZSkgLS0gcmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdmFsdWUuXFxcIn0sX19yZXZlcnNlZF9fOnskbWV0aCgpe3JldHVybiBuZXcgaSh0aGlzKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRC5fX3JldmVyc2VkX18oKSAtLSByZXR1cm4gYSByZXZlcnNlIGl0ZXJhdG9yIG92ZXIgdGhlIGRlcXVlXFxcIn0scmV2ZXJzZTp7JG1ldGgoKXtjb25zdCB0PXRoaXMuaGVhZCxlPXRoaXMudGFpbCxpPXRoaXMubWFzayxzPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2ZvcihsZXQgbj0wO248fn4ocy8yKTtuKyspe2NvbnN0IHM9ZS1uLTEmaSxyPXQrbiZpLGE9dGhpcy52W3NdO3RoaXMudltzXT10aGlzLnZbcl0sdGhpcy52W3JdPWF9cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRC5yZXZlcnNlKCkgLS0gcmV2ZXJzZSAqSU4gUExBQ0UqXFxcIn0scm90YXRlOnskbWV0aCh0KXt0PXZvaWQgMD09PXQ/MTpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQodCxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2NvbnN0IGU9dGhpcy5oZWFkLGk9dGhpcy50YWlsO2lmKDA9PT10fHxlPT09aSlyZXR1cm4gdGhpcztpZih0aGlzLmhlYWQ9ZS10JnRoaXMubWFzayx0aGlzLnRhaWw9aS10JnRoaXMubWFzayx0PjApZm9yKGxldCBzPTE7czw9dDtzKyspe2NvbnN0IHQ9ZS1zJnRoaXMubWFzayxuPWktcyZ0aGlzLm1hc2s7dGhpcy52W3RdPXRoaXMudltuXSx0aGlzLnZbbl09dm9pZCAwfWVsc2UgZm9yKGxldCBzPTA7cz50O3MtLSl7Y29uc3QgdD1pLXMmdGhpcy5tYXNrLG49ZS1zJnRoaXMubWFzazt0aGlzLnZbdF09dGhpcy52W25dLHRoaXMudltuXT12b2lkIDB9cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJvdGF0ZSB0aGUgZGVxdWUgbiBzdGVwcyB0byB0aGUgcmlnaHQgKGRlZmF1bHQgbj0xKS4gIElmIG4gaXMgbmVnYXRpdmUsIHJvdGF0ZXMgbGVmdC5cXFwifX0sY2xhc3NtZXRob2RzOlNrLmdlbmVyaWMuY2xhc3NHZXRJdGVtLGdldHNldHM6e21heGxlbjp7JGdldCgpe3JldHVybiB2b2lkIDA9PT10aGlzLm1heGxlbj9Tay5idWlsdGluLm5vbmUubm9uZSQ6bmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLm1heGxlbil9LCRkb2M6XFxcIm1heGltdW0gc2l6ZSBvZiBhIGRlcXVlIG9yIE5vbmUgaWYgdW5ib3VuZGVkXFxcIn19LHByb3RvOnskY2xlYXIoKXt0aGlzLmhlYWQ9MCx0aGlzLnRhaWw9MCx0aGlzLm1hc2s9MSx0aGlzLnY9bmV3IEFycmF5KDIpfSwkY29weSgpe3JldHVybiBuZXcgdC5kZXF1ZSh0aGlzLnYuc2xpY2UoMCksdGhpcy5tYXhsZW4sdGhpcy5oZWFkLHRoaXMudGFpbCx0aGlzLm1hc2spfSwkZXh0ZW5kKHQpe2ZvcihsZXQgZT1Tay5hYnN0ci5pdGVyKHQpLGk9ZS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWk7aT1lLnRwJGl0ZXJuZXh0KCkpdGhpcy4kcHVzaChpKX0sc2V0JGl0ZW0odCxlKXtjb25zdCBpPSh0Pj0wP3RoaXMuaGVhZDp0aGlzLnRhaWwpK3QmdGhpcy5tYXNrO3RoaXMudltpXT1lfSxkZWwkaXRlbSh0KXtsZXQgZT0odD49MD90aGlzLmhlYWQ6dGhpcy50YWlsKSt0JnRoaXMubWFzaztmb3IoO2UhPT10aGlzLnRhaWw7KXtjb25zdCB0PWUrMSZ0aGlzLm1hc2s7dGhpcy52W2VdPXRoaXMudlt0XSxlPXR9Y29uc3QgaT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzazt0aGlzLnRhaWw9dGhpcy50YWlsLTEmdGhpcy5tYXNrLGk8dGhpcy5tYXNrPj4+MSYmdGhpcy4kcmVzaXplKGksdGhpcy52Lmxlbmd0aD4+PjEpfSwkcHVzaCh0KXt0aGlzLnZbdGhpcy50YWlsXT10LHRoaXMudGFpbD10aGlzLnRhaWwrMSZ0aGlzLm1hc2ssdGhpcy5oZWFkPT09dGhpcy50YWlsJiZ0aGlzLiRyZXNpemUodGhpcy52Lmxlbmd0aCx0aGlzLnYubGVuZ3RoPDwxKTtjb25zdCBlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO3JldHVybiB2b2lkIDAhPT10aGlzLm1heGxlbiYmZT50aGlzLm1heGxlbiYmdGhpcy4kcG9wTGVmdCgpLHRoaXN9LCRwdXNoTGVmdCh0KXt0aGlzLmhlYWQ9dGhpcy5oZWFkLTEmdGhpcy5tYXNrLHRoaXMudlt0aGlzLmhlYWRdPXQsdGhpcy5oZWFkPT09dGhpcy50YWlsJiZ0aGlzLiRyZXNpemUodGhpcy52Lmxlbmd0aCx0aGlzLnYubGVuZ3RoPDwxKTtjb25zdCBlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO3JldHVybiB2b2lkIDAhPT10aGlzLm1heGxlbiYmZT50aGlzLm1heGxlbiYmdGhpcy4kcG9wKCksdGhpc30sJHBvcCgpe2lmKHRoaXMuaGVhZD09PXRoaXMudGFpbCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFxcXCJwb3AgZnJvbSBhbiBlbXB0eSBkZXF1ZVxcXCIpO3RoaXMudGFpbD10aGlzLnRhaWwtMSZ0aGlzLm1hc2s7Y29uc3QgdD10aGlzLnZbdGhpcy50YWlsXTt0aGlzLnZbdGhpcy50YWlsXT12b2lkIDA7Y29uc3QgZT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztyZXR1cm4gZTx0aGlzLm1hc2s+Pj4xJiZ0aGlzLiRyZXNpemUoZSx0aGlzLnYubGVuZ3RoPj4+MSksdH0sJHBvcExlZnQoKXtpZih0aGlzLmhlYWQ9PT10aGlzLnRhaWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcXFwicG9wIGZyb20gYW4gZW1wdHkgZGVxdWVcXFwiKTtjb25zdCB0PXRoaXMudlt0aGlzLmhlYWRdO3RoaXMudlt0aGlzLmhlYWRdPXZvaWQgMCx0aGlzLmhlYWQ9dGhpcy5oZWFkKzEmdGhpcy5tYXNrO2NvbnN0IGU9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7cmV0dXJuIGU8dGhpcy5tYXNrPj4+MSYmdGhpcy4kcmVzaXplKGUsdGhpcy52Lmxlbmd0aD4+PjEpLHR9LCRyZXNpemUodCxlKXtjb25zdCBpPXRoaXMuaGVhZCxzPXRoaXMubWFzaztpZih0aGlzLmhlYWQ9MCx0aGlzLnRhaWw9dCx0aGlzLm1hc2s9ZS0xLDA9PT1pKXJldHVybiB2b2lkKHRoaXMudi5sZW5ndGg9ZSk7Y29uc3Qgbj1uZXcgQXJyYXkoZSk7Zm9yKGxldCByPTA7cjx0O3IrKyluW3JdPXRoaXMudltpK3Imc107dGhpcy52PW59LCRpbmRleCh0LGUsaSl7Y29uc3Qgcz10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztlPXZvaWQgMD09PWU/MDpTay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhlKSxpPXZvaWQgMD09PWk/czpTay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhpKTtjb25zdCBuPXRoaXMuaGVhZCxyPXRoaXMubWFzayxhPXRoaXMudjtpPWk+PTA/aTppPC1zPzA6cytpO2ZvcihsZXQgbz1lPj0wP2U6ZTwtcz8wOnMrZTtvPGk7bysrKWlmKGFbbitvJnJdPT09dClyZXR1cm4gb30sc2skYXNhcnJheSgpe2NvbnN0IHQ9W10sZT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztmb3IobGV0IGk9MDtpPGU7KytpKXtjb25zdCBlPXRoaXMuaGVhZCtpJnRoaXMubWFzazt0LnB1c2godGhpcy52W2VdKX1yZXR1cm4gdH19fSk7Y29uc3QgZT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIl9jb2xsZWN0aW9ucy5fZGVxdWVfaXRlcmF0b3JcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBfZGVxdWVfaXRlcmF0b3IodCl7dGhpcy4kaW5kZXg9MCx0aGlzLmRxPXQudix0aGlzLiRsZW5ndGg9dC50YWlsLXQuaGVhZCZ0Lm1hc2ssdGhpcy4kaGVhZD10LmhlYWQsdGhpcy4kdGFpbD10LnRhaWwsdGhpcy4kbWFzaz10Lm1hc2t9LGl0ZXJuZXh0KCl7aWYodGhpcy4kaW5kZXg+PXRoaXMuJGxlbmd0aClyZXR1cm47Y29uc3QgdD0odGhpcy4kaW5kZXg+PTA/dGhpcy4kaGVhZDp0aGlzLiR0YWlsKSt0aGlzLiRpbmRleCZ0aGlzLiRtYXNrO3JldHVybiB0aGlzLiRpbmRleCsrLHRoaXMuZHFbdF19LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzp7JG1ldGg6ZnVuY3Rpb24gX19sZW5ndGhfaGludF9fKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy4kbGVuZ3RoLXRoaXMuJGluZGV4KX0sJGZsYWdzOntOb0FyZ3M6ITB9fX19KSxpPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiX2NvbGxlY3Rpb25zLl9kZXF1ZV9yZXZlcnNlX2l0ZXJhdG9yXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gX2RlcXVlX3JldmVyc2VfaXRlcmF0b3IodCl7dGhpcy4kaW5kZXg9KHQudGFpbC10LmhlYWQmdC5tYXNrKS0xLHRoaXMuZHE9dC52LHRoaXMuJGhlYWQ9dC5oZWFkLHRoaXMuJG1hc2s9dC5tYXNrfSxpdGVybmV4dCgpe2lmKHRoaXMuJGluZGV4PDApcmV0dXJuO2NvbnN0IHQ9dGhpcy4kaGVhZCt0aGlzLiRpbmRleCZ0aGlzLiRtYXNrO3JldHVybiB0aGlzLiRpbmRleC0tLHRoaXMuZHFbdF19LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJSZXZlcnNlTGVuZ3RoSGludE1ldGhvZERlZn19KSxzPW5ldyBSZWdFeHAoL15bMC05XS4qLyksbj1uZXcgUmVnRXhwKC9eWzAtOV9dLiovKSxyPW5ldyBSZWdFeHAoL15cXFxcdyokLyksYT0vLC9nLG89L1xcXFxzKy87ZnVuY3Rpb24gbmFtZWR0dXBsZShlLGksbCxoLGMpe2lmKGU9ZS50cCRzdHIoKSxTay5taXNjZXZhbC5pc1RydWUoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuX2lza2V5d29yZCxbZV0pKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJUeXBlIG5hbWVzIGFuZCBmaWVsZCBuYW1lcyBjYW5ub3QgYmUgYSBrZXl3b3JkOiAnXFxcIitTay5taXNjZXZhbC5vYmplY3RSZXByKGUpK1xcXCInXFxcIik7Y29uc3QgdT1lLiRqc3N0cigpO2lmKHMudGVzdCh1KXx8IXIudGVzdCh1KXx8IXUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiVHlwZSBuYW1lcyBhbmQgZmllbGQgbmFtZXMgbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVyczogJ1xcXCIrdStcXFwiJ1xcXCIpO2xldCBtLGQ7aWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhpKSltPWkuJGpzc3RyKCkucmVwbGFjZShhLFxcXCIgXFxcIikuc3BsaXQobyksMT09bS5sZW5ndGgmJlxcXCJcXFwiPT09bVswXSYmKG09W10pLGQ9bS5tYXAoKHQ9Pm5ldyBTay5idWlsdGluLnN0cih0KSkpO2Vsc2V7bT1bXSxkPVtdO2ZvcihsZXQgdD1Tay5hYnN0ci5pdGVyKGkpLGU9dC50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWU7ZT10LnRwJGl0ZXJuZXh0KCkpZT1lLnRwJHN0cigpLGQucHVzaChlKSxtLnB1c2goZS4kanNzdHIoKSl9bGV0IHA9bmV3IFNldDtpZihTay5taXNjZXZhbC5pc1RydWUobCkpZm9yKGxldCBzPTA7czxtLmxlbmd0aDtzKyspKFNrLm1pc2NldmFsLmlzVHJ1ZShTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5faXNrZXl3b3JkLFtkW3NdXSkpfHxuLnRlc3QobVtzXSl8fCFyLnRlc3QobVtzXSl8fCFtW3NdfHxwLmhhcyhtW3NdKSkmJihtW3NdPVxcXCJfXFxcIitzLGRbc109bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJfXFxcIitzKSkscC5hZGQobVtzXSk7ZWxzZSBmb3IobGV0IHM9MDtzPG0ubGVuZ3RoO3MrKyl7aWYoU2subWlzY2V2YWwuaXNUcnVlKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0Ll9pc2tleXdvcmQsW2Rbc11dKSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiVHlwZSBuYW1lcyBhbmQgZmllbGQgbmFtZXMgY2Fubm90IGJlIGEga2V5d29yZDogJ1xcXCIrbVtzXStcXFwiJ1xcXCIpO2lmKG4udGVzdChtW3NdKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJGaWVsZCBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlOiAnXFxcIittW3NdK1xcXCInXFxcIik7aWYoIXIudGVzdChtW3NdKXx8IW1bc10pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiVHlwZSBuYW1lcyBhbmQgZmllbGQgbmFtZXMgbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVyczogJ1xcXCIrbVtzXStcXFwiJ1xcXCIpO2lmKHAuaGFzKG1bc10pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkVuY291bnRlcmVkIGR1cGxpY2F0ZSBmaWVsZCBuYW1lOiAnXFxcIittW3NdK1xcXCInXFxcIik7cC5hZGQobVtzXSl9Y29uc3QgJD1uZXcgU2suYnVpbHRpbi50dXBsZShkKSxrPVtdO2xldCBiPVtdO2lmKCFTay5idWlsdGluLmNoZWNrTm9uZShoKSl7aWYoYj1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShoKSxiLmxlbmd0aD5tLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIkdvdCBtb3JlIGRlZmF1bHQgdmFsdWVzIHRoYW4gZmllbGQgbmFtZXNcXFwiKTtmb3IobGV0IHQ9MCxlPWQubGVuZ3RoLWIubGVuZ3RoO2U8ZC5sZW5ndGg7dCsrLGUrKylrLnB1c2goZFtlXSksay5wdXNoKGJbdF0pfWNvbnN0IGY9bmV3IFNrLmJ1aWx0aW4uZGljdChrKTtmdW5jdGlvbiBfbWFrZSh0LGUpe3JldHVybiB0LnByb3RvdHlwZS50cCRuZXcoU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZSkpfWZ1bmN0aW9uIF9hc2RpY3QodCl7Y29uc3QgZT1bXTtmb3IobGV0IGk9MDtpPHQuX2ZpZWxkcy52Lmxlbmd0aDtpKyspZS5wdXNoKHQuX2ZpZWxkcy52W2ldKSxlLnB1c2godC52W2ldKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZGljdChlKX1mdW5jdGlvbiBfcmVwbGFjZSh0LGUpe2NvbnN0IGk9KHQ9bmV3IFNrLmJ1aWx0aW4uZGljdCh0KSkudHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXFxcInBvcFxcXCIpKSxzPVNrLmFic3RyLmdhdHRyKGUsbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJfbWFrZVxcXCIpKSxuPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSxyPW4ocyxbbihTay5idWlsdGluLm1hcF8sW2ksJCxlXSldKTtpZih0LnNxJGxlbmd0aCgpKXtjb25zdCBlPXQuc2skYXNhcnJheSgpO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkdvdCB1bmV4cGVjdGQgZmllbGQgbmFtZXM6IFtcXFwiK2UubWFwKCh0PT5cXFwiJ1xcXCIrdC4kanNzdHIoKStcXFwiJ1xcXCIpKStcXFwiXVxcXCIpfXJldHVybiByfV9tYWtlLmNvX3Zhcm5hbWVzPVtcXFwiX2Nsc1xcXCIsXFxcIml0ZXJhYmxlXFxcIl0sX2FzZGljdC5jb192YXJuYW1lcz1bXFxcInNlbGZcXFwiXSxfcmVwbGFjZS5jb19rd2FyZ3M9MSxfcmVwbGFjZS5jb192YXJuYW1lcz1bXFxcIl9zZWxmXFxcIl07Y29uc3QgUz17fTtmb3IobGV0IHM9MDtzPG0ubGVuZ3RoO3MrKylTW2Rbc10uJG1hbmdsZWRdPW5ldyBTay5idWlsdGluLnByb3BlcnR5KG5ldyB0Ll9pdGVtZ2V0dGVyKFtuZXcgU2suYnVpbHRpbi5pbnRfKHMpXSksdm9pZCAwLHZvaWQgMCxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIkFsaWFzIGZvciBmaWVsZCBudW1iZXIgXFxcIitzKSk7cmV0dXJuIFNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3ModSx7Y29uc3RydWN0b3I6ZnVuY3Rpb24gTmFtZWRUdXBsZSgpe30sYmFzZTpTay5idWlsdGluLnR1cGxlLHNsb3RzOnt0cCRkb2M6dStcXFwiKFxcXCIrbS5qb2luKFxcXCIsIFxcXCIpK1xcXCIpXFxcIix0cCRuZXcodCxlKXt0PVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJfX25ld19fXFxcIixtLHQsZSxiKTtjb25zdCBpPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBTay5idWlsdGluLnR1cGxlLmNhbGwoaSx0KSxpfSwkcigpe2NvbnN0IHQ9dGhpcy52Lm1hcCgoKHQsZSk9Pm1bZV0rXFxcIj1cXFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIodCkpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1xcXCIoXFxcIit0LmpvaW4oXFxcIiwgXFxcIikrXFxcIilcXFwiKX19LGZsYWdzOntzayRrbGFzczohMH0scHJvdG86T2JqZWN0LmFzc2lnbih7X19tb2R1bGVfXzpTay5idWlsdGluLmNoZWNrTm9uZShjKT9Tay5nbG9iYWxzLl9fbmFtZV9fOmMsX19zbG90c19fOm5ldyBTay5idWlsdGluLnR1cGxlLF9maWVsZHM6JCxfZmllbGRfZGVmYXVsdHM6ZixfbWFrZTpuZXcgU2suYnVpbHRpbi5jbGFzc21ldGhvZChuZXcgU2suYnVpbHRpbi5mdW5jKF9tYWtlKSksX2FzZGljdDpuZXcgU2suYnVpbHRpbi5mdW5jKF9hc2RpY3QpLF9yZXBsYWNlOm5ldyBTay5idWlsdGluLmZ1bmMoX3JlcGxhY2UpfSxTKX0pfXJldHVybiBuYW1lZHR1cGxlLmNvX2FyZ2NvdW50PTIsbmFtZWR0dXBsZS5jb19rd29ubHlhcmdjb3VudD0zLG5hbWVkdHVwbGUuJGt3ZGVmcz1bU2suYnVpbHRpbi5ib29sLmZhbHNlJCxTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ub25lLm5vbmUkXSxuYW1lZHR1cGxlLmNvX3Zhcm5hbWVzPVtcXFwidHlwZW5hbWVcXFwiLFxcXCJmaWVsZF9uYW1lc1xcXCIsXFxcInJlbmFtZVxcXCIsXFxcImRlZmF1bHRzXFxcIixcXFwibW9kdWxlXFxcIl0sdC5uYW1lZHR1cGxlPW5ldyBTay5idWlsdGluLmZ1bmMobmFtZWR0dXBsZSksdH1cIixcInNyYy9saWIvZGF0ZXRpbWUuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKCl7Y29uc3R7aXNUcnVlOnQscmljaENvbXBhcmVCb29sOmUsYXNJbmRleE9yVGhyb3c6bixhc0luZGV4U2l6ZWQ6aSxvYmplY3RSZXByOnMsb3BBbGxvd3NFcXVhbGl0eTpvLGNhbGxzaW1BcnJheTpyLGNhbGxzaW1PclN1c3BlbmRBcnJheTphfT1Tay5taXNjZXZhbCx7bnVtYmVyQmluT3A6JCx0eXBlTmFtZTpjLGJ1aWxkTmF0aXZlQ2xhc3M6aCxjaGVja0FyZ3NMZW46bSxvYmplY3RIYXNoOnUsY29weUtleXdvcmRzVG9OYW1lZEFyZ3M6bH09U2suYWJzdHIse2ludF86ZixmbG9hdF86ZCxzdHI6dyxieXRlczpfLHR1cGxlOnAsYm9vbDp7dHJ1ZSQ6Z30sbm9uZTp7bm9uZSQ6eX0sTm90SW1wbGVtZW50ZWQ6e05vdEltcGxlbWVudGVkJDpifSxUeXBlRXJyb3I6eixWYWx1ZUVycm9yOnYsT3ZlcmZsb3dFcnJvcjpNLFplcm9EaXZpc2lvbkVycm9yOkEsTm90SW1wbGVtZW50ZWRFcnJvcjp4LGNoZWNrTnVtYmVyOk4sY2hlY2tGbG9hdDpTLGNoZWNrU3RyaW5nOmssY2hlY2tJbnQ6Tyxhc251bSQ6SSxyb3VuZDpFLGdldGF0dHI6VH09U2suYnVpbHRpbix7cmVtYXBUb1B5OkQscmVtYXBUb0pzOlJ9PVNrLmZmaSxpbnRSb3VuZD10PT5FKHQpLm5iJGludCgpLHE9JCxDPW5ldyB3KFxcXCJhdXRvXFxcIiksVT1uZXcgdyhcXFwidXRjb2Zmc2V0XFxcIiksWT1uZXcgdyhcXFwidHpuYW1lXFxcIiksaj1uZXcgdyhcXFwiYXNfaW50ZWdlcl9yYXRpb1xcXCIpLEY9bmV3IHcoXFxcImRzdFxcXCIpLEg9bmV3IHcoXFxcImlzb2Zvcm1hdFxcXCIpLEo9bmV3IHcoXFxcInJlcGxhY2VcXFwiKSxCPW5ldyB3KFxcXCJmcm9tdGltZXN0YW1wXFxcIiksRz1uZXcgdyhcXFwiZnJvbW9yZGluYWxcXFwiKSxMPW5ldyB3KFxcXCJ1dGNmcm9tdGltZXN0YW1wXFxcIiksWD1uZXcgdyhcXFwic3RyZnRpbWVcXFwiKSxQPW5ldyB3KFxcXCJmcm9tdXRjXFxcIiksVz1uZXcgZigwKSxaPW5ldyBkKDApLEs9bmV3IGYoNyksVj1uZXcgZig2MCksUT1uZXcgZigzNjAwKSx0dD1uZXcgZigxZTMpLGV0PW5ldyBmKDFlNiksbnQ9bmV3IGQoMWU2KSxpdD1uZXcgZig4NjQwMCksc3Q9bmV3IGQoODY0MDApO2xldCBvdD1udWxsO2Z1bmN0aW9uIHB5RGl2TW9kKHQsZSl7cmV0dXJuIHEodCxlLFxcXCJEaXZNb2RcXFwiKS52fWZ1bmN0aW9uICRkaXZNb2QodCxlKXtpZihcXFwibnVtYmVyXFxcIiE9dHlwZW9mIHR8fFxcXCJudW1iZXJcXFwiIT10eXBlb2YgZSlyZXR1cm4gdD1KU0JJLkJpZ0ludCh0KSxlPUpTQkkuQmlnSW50KGUpLFtKU0JJLnRvTnVtYmVyKEpTQkkuZGl2aWRlKHQsZSkpLEpTQkkudG9OdW1iZXIoSlNCSS5yZW1haW5kZXIodCxlKSldO2lmKDA9PT1lKXRocm93IG5ldyBBKFxcXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXFxcIik7cmV0dXJuW01hdGguZmxvb3IodC9lKSx0LU1hdGguZmxvb3IodC9lKSplXX1mdW5jdGlvbiBtb2RmKHQpe2NvbnN0IGU9KHQ9SSh0KSk8MD8tMToxO3JldHVybiB0PU1hdGguYWJzKHQpLFtuZXcgZChlKih0LU1hdGguZmxvb3IodCkpKSxuZXcgZChlKk1hdGguZmxvb3IodCkpXX1mdW5jdGlvbiBfZCh0LGU9XFxcIjBcXFwiLG49Mil7cmV0dXJuIHQudG9TdHJpbmcoKS5wYWRTdGFydChuLGUpfWNvbnN0IHJ0PS9eWzAtOV0rJC87ZnVuY3Rpb24gX2FzX2ludGVnZXIodCl7aWYoIXJ0LnRlc3QodCkpdGhyb3cgbmV3IEVycm9yO3JldHVybiBwYXJzZUludCh0KX1mdW5jdGlvbiBfYXNfaW50X3JhdGlvKHQpe2xldCBlPXIodC50cCRnZXRhdHRyKGopKTtpZighKGUgaW5zdGFuY2VvZiBwKSl0aHJvdyBuZXcgeihcXFwidW5leHBlY3RlZCByZXR1cm4gdHlwZSBmcm9tIGFzX2ludGVnZXJfcmF0aW8oKTogZXhwZWN0ZWQgdHVwbGUsIGdvdCAnXFxcIitjKGUpK1xcXCInXFxcIik7aWYoZT1lLnYsMiE9PWUubGVuZ3RoKXRocm93IG5ldyB2KFxcXCJhc19pbnRlZ2VyX3JhdGlvKCkgbXVzdCByZXR1cm4gYSAyLXR1cGxlXFxcIik7cmV0dXJuIGV9cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmltcG9ydE1vZHVsZShcXFwidGltZVxcXCIsITEsITApLChhPT57Y29uc3QgJD1hLiRkLEU9e19fbmFtZV9fOm5ldyB3KFxcXCJkYXRldGltZVxcXCIpLF9fYWxsX186bmV3IFNrLmJ1aWx0aW4ubGlzdChbXFxcImRhdGVcXFwiLFxcXCJkYXRldGltZVxcXCIsXFxcInRpbWVcXFwiLFxcXCJ0aW1lZGVsdGFcXFwiLFxcXCJ0aW1lem9uZVxcXCIsXFxcInR6aW5mb1xcXCIsXFxcIk1JTllFQVJcXFwiLFxcXCJNQVhZRUFSXFxcIl0ubWFwKCh0PT5uZXcgdyh0KSkpKX07ZnVuY3Rpb24gX2NtcCh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKHRbbl0hPT1lW25dKXJldHVybiB0W25dPmVbbl0/MTotMTtyZXR1cm4gMH1mdW5jdGlvbiBfZG9fY29tcGFyZSh0LGUsbil7Y29uc3QgaT10LiRjbXAoZSxuKTtzd2l0Y2gobil7Y2FzZVxcXCJMdFxcXCI6cmV0dXJuIGk8MDtjYXNlXFxcIkx0RVxcXCI6cmV0dXJuIGk8PTA7Y2FzZVxcXCJFcVxcXCI6cmV0dXJuIDA9PT1pO2Nhc2VcXFwiTm90RXFcXFwiOnJldHVybiAwIT09aTtjYXNlXFxcIkd0XFxcIjpyZXR1cm4gaT4wO2Nhc2VcXFwiR3RFXFxcIjpyZXR1cm4gaT49MH19Y29uc3Qgaj05OTk5O0UuTUlOWUVBUj1uZXcgZigxKSxFLk1BWFlFQVI9bmV3IGYoaik7Y29uc3QgcnQ9MzY1MjA1OSxhdD1bLTEsMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLCR0PVstMV07bGV0IGN0PTA7ZnVuY3Rpb24gX2lzX2xlYXAodCl7cmV0dXJuIHQlND09MCYmKHQlMTAwIT0wfHx0JTQwMD09MCl9ZnVuY3Rpb24gX2RheXNfYmVmb3JlX3llYXIodCl7Y29uc3QgZT10LTE7cmV0dXJuIDM2NSplK01hdGguZmxvb3IoZS80KS1NYXRoLmZsb29yKGUvMTAwKStNYXRoLmZsb29yKGUvNDAwKX1mdW5jdGlvbiBfZGF5c19iZWZvcmVfbW9udGgodCxlKXtyZXR1cm4gJHRbZV0rKGU+MiYmX2lzX2xlYXAodCkpfWZ1bmN0aW9uIF95bWQyb3JkKHQsZSxuKXtyZXR1cm4gX2RheXNfYmVmb3JlX3llYXIodCkrX2RheXNfYmVmb3JlX21vbnRoKHQsZSkrbn1hdC5zbGljZSgxKS5mb3JFYWNoKCh0PT57JHQucHVzaChjdCksY3QrPXR9KSk7Y29uc3QgaHQ9X2RheXNfYmVmb3JlX3llYXIoNDAxKSxtdD1fZGF5c19iZWZvcmVfeWVhcigxMDEpLHV0PV9kYXlzX2JlZm9yZV95ZWFyKDUpO2Z1bmN0aW9uIF9vcmQyeW1kKHQpe2lmKCh0PW4odCkpPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBNKFxcXCJQeXRob24gaW50IHRvbyBsYXJnZSB0byBjb252ZXJ0IHRvIGpzIG51bWJlclxcXCIpO2lmKHQ8MSl0aHJvdyBuZXcgdihcXFwib3JkaW5hbCBtdXN0IGJlID49IDFcXFwiKTtsZXQgZSxpLHMsbzt0LT0xLFtlLHRdPSRkaXZNb2QodCxodCk7bGV0IHI9NDAwKmUrMTtpZihbaSx0XT0kZGl2TW9kKHQsbXQpLFtzLHRdPSRkaXZNb2QodCx1dCksW28sdF09JGRpdk1vZCh0LDM2NSkscis9MTAwKmkrNCpzK28sND09PW98fDQ9PT1pKXJldHVybltyLTEsMTIsMzFdLm1hcCgodD0+bmV3IGYodCkpKTtjb25zdCBhPTM9PT1vJiYoMjQhPT1zfHwzPT09aSk7bGV0ICQ9dCs1MD4+NSxjPSR0WyRdKygkPjImJmEpO3JldHVybiBjPnQmJigkLT0xLGMtPWF0WyRdKygyPT09JCYmYSkpLFtyLCQsKHQtPWMpKzFdLm1hcCgodD0+bmV3IGYodCkpKX1jb25zdCBsdD1bbnVsbCxcXFwiSmFuXFxcIixcXFwiRmViXFxcIixcXFwiTWFyXFxcIixcXFwiQXByXFxcIixcXFwiTWF5XFxcIixcXFwiSnVuXFxcIixcXFwiSnVsXFxcIixcXFwiQXVnXFxcIixcXFwiU2VwXFxcIixcXFwiT2N0XFxcIixcXFwiTm92XFxcIixcXFwiRGVjXFxcIl0sZnQ9W251bGwsXFxcIk1vblxcXCIsXFxcIlR1ZVxcXCIsXFxcIldlZFxcXCIsXFxcIlRodVxcXCIsXFxcIkZyaVxcXCIsXFxcIlNhdFxcXCIsXFxcIlN1blxcXCJdO2Z1bmN0aW9uIF9idWlsZF9zdHJ1Y3RfdGltZSh0LGUsbixpLHMsbyxyKXtjb25zdCBhPShfeW1kMm9yZCh0LGUsbikrNiklNyxjPV9kYXlzX2JlZm9yZV9tb250aCh0LGUpK247cmV0dXJuICQuc3RydWN0X3RpbWUudHAkY2FsbChbbmV3IHAoW3QsZSxuLGkscyxvLGEsYyxyXS5tYXAoKHQ9Pm5ldyBmKHQpKSkpXSl9Y29uc3QgZHQ9e2hvdXJzOnQ9Pl9kKHQpLG1pbnV0ZXM6KHQsZSk9Pl9kKHQpK1xcXCI6XFxcIitfZChlKSxzZWNvbmRzOih0LGUsbik9Pl9kKHQpK1xcXCI6XFxcIitfZChlKStcXFwiOlxcXCIrX2QobiksbWlsbGlzZWNvbmRzOih0LGUsbixpKT0+X2QodCkrXFxcIjpcXFwiK19kKGUpK1xcXCI6XFxcIitfZChuKStcXFwiLlxcXCIrX2QoaSxcXFwiMFxcXCIsMyksbWljcm9zZWNvbmRzOih0LGUsbixpKT0+X2QodCkrXFxcIjpcXFwiK19kKGUpK1xcXCI6XFxcIitfZChuKStcXFwiLlxcXCIrX2QoaSxcXFwiMFxcXCIsNil9O2Z1bmN0aW9uIF9mb3JtYXRfdGltZSh0LGUsbixpLHM9XFxcImF1dG9cXFwiKXtpZihcXFwic3RyaW5nXFxcIiE9dHlwZW9mIHMmJiFrKHMpKXRocm93IG5ldyB6KFxcXCJtdXN0IGJlIHN0ciwgbm90IFxcXCIrYyhzKSk7XFxcImF1dG9cXFwiPT09KHM9cy50b1N0cmluZygpKT9zPWk/XFxcIm1pY3Jvc2Vjb25kc1xcXCI6XFxcInNlY29uZHNcXFwiOlxcXCJtaWxsaXNlY29uZHNcXFwiPT09cyYmKGk9TWF0aC5mbG9vcihpLzFlMykpO2xldCBvPWR0W3NdO2lmKHZvaWQgMD09PW8pdGhyb3cgbmV3IHYoXFxcIlVua25vd24gdGltZXNwZWMgdmFsdWVcXFwiKTtyZXR1cm4gbyh0LGUsbixpKX1mdW5jdGlvbiBfZm9ybWF0X29mZnNldCh0KXtsZXQgZSxuPVxcXCJcXFwiO2lmKHQhPT15KXtsZXQgaSxzLG87cmV0dXJuIHQuJGRheXM8MD8oZT1cXFwiLVxcXCIsdD1uZXcgd3QoLXQuJGRheXMsLXQuJHNlY3MsLXQuJG1pY3JvKSk6ZT1cXFwiK1xcXCIsW2ksc109cHlEaXZNb2QodCxwdCksW3Msb109cHlEaXZNb2QocyxndCksbis9ZStgJHtfZChpKX06JHtfZChzKX1gLChvLiRzZWNzfHxvLiRtaWNybykmJihuKz1cXFwiOlxcXCIrX2Qoby4kc2VjcyxcXFwiMFxcXCIsMiksby4kbWljcm8mJihuKz1cXFwiLlxcXCIrX2Qoby4kbWljcm8sXFxcIjBcXFwiLDYpKSksbn19ZnVuY3Rpb24gX3dyYXBfc3RyZnRpbWUodCxlLG4pe2xldCBpPW51bGwscz1udWxsLG89bnVsbCxhPVtdLGM9MDtjb25zdCBoPWUubGVuZ3RoO2Zvcig7YzxoOyl7bGV0IG49ZVtjXTtpZihjKz0xLFxcXCIlXFxcIj09PW4paWYoYzxoKWlmKG49ZVtjXSxjKz0xLFxcXCJmXFxcIj09PW4pbnVsbD09PWkmJihpPV9kKHQuJG1pY3JvfHwwLFxcXCIwXFxcIiw2KSksYS5wdXNoKGkpO2Vsc2UgaWYoXFxcInpcXFwiPT09bil7aWYobnVsbD09PXMpe3M9XFxcIlxcXCI7Y29uc3QgZT10LnRwJGdldGF0dHIoVSk7aWYodm9pZCAwIT09ZSl7bGV0IHQ9cihlKTtpZih0IT09eSl7bGV0IGUsbixpLG89XFxcIitcXFwiO3QuJGRheXM8MCYmKHQ9bmV3IHd0KC10LiRkYXlzLC10LiRzZWNzLC10LiRtaWNybyksbz1cXFwiLVxcXCIpLFtlLGldPXB5RGl2TW9kKHQscHQpLFtuLGldPXB5RGl2TW9kKGksZ3QpLGU9ZSxuPW47Y29uc3Qgcj1pLiRzZWNzLGE9dC4kbWljcm87cz1hP28rX2QoZSkrX2QobikrX2QocikrXFxcIi5cXFwiK19kKGEsXFxcIjBcXFwiLDYpOnI/bytfZChlKStfZChuKStfZChyKTpvK19kKGUpK19kKG4pfX19YS5wdXNoKHMpfWVsc2UgaWYoXFxcIlpcXFwiPT09bil7aWYobnVsbD09PW8pe289XFxcIlxcXCI7Y29uc3QgZT10LnRwJGdldGF0dHIoWSk7aWYodm9pZCAwIT09ZSl7bGV0IHQ9cihlKTtpZih0IT09eSl7Y29uc3QgZT10LnRwJGdldGF0dHIoSik7aWYobz1yKGUsW25ldyB3KFxcXCIlXFxcIiksbmV3IHcoXFxcIiUlXFxcIildKSwhayhvKSl0aHJvdyBuZXcgeihcXFwidHpuYW1lLnJlcGxhY2UoKSBkaWQgbm90IHJldHVybiBhIHN0cmluZ1xcXCIpfX19YS5wdXNoKG8pfWVsc2UgYS5wdXNoKFxcXCIlXFxcIixuKTtlbHNlIGEucHVzaChcXFwiJVxcXCIpO2Vsc2UgYS5wdXNoKG4pfXJldHVybiBhPWEuam9pbihcXFwiXFxcIiksJC5zdHJmdGltZS50cCRjYWxsKFtuZXcgdyhhKSxuXSl9ZnVuY3Rpb24gX3BhcnNlX2lzb2Zvcm1hdF9kYXRlKHQpe2NvbnN0IGU9X2FzX2ludGVnZXIodC5zbGljZSgwLDQpKTtpZihcXFwiLVxcXCIhPT10WzRdKXRocm93IG5ldyB2KFxcXCJJbnZhbGlkIGRhdGUgc2VwYXJhdG9yOiBcXFwiK3RbNF0pO2NvbnN0IG49X2FzX2ludGVnZXIodC5zbGljZSg1LDcpKTtpZihcXFwiLVxcXCIhPT10WzddKXRocm93IG5ldyB2KFxcXCJJbnZhbGlkIGRhdGUgc2VwYXJhdG9yOiBcXFwiK3RbN10pO3JldHVybltlLG4sX2FzX2ludGVnZXIodC5zbGljZSg4LDEwKSldLm1hcCgodD0+bmV3IGYodCkpKX1mdW5jdGlvbiBfcGFyc2VfaGhfbW1fc3NfZmYodCl7Y29uc3QgZT10Lmxlbmd0aCxuPVswLDAsMCwwXTtsZXQgaT0wO2ZvcihsZXQgcz0wO3M8MztzKyspe2lmKGUtaTwyKXRocm93IG5ldyB2KFxcXCJJbmNvbXBsZXRlIHRpbWUgY29tcG9uZW50XFxcIik7bltzXT1fYXNfaW50ZWdlcih0LnNsaWNlKGksaSsyKSksaSs9Mjtjb25zdCBvPXQuc3Vic3RyKGksMSk7aWYoIW98fHM+PTIpYnJlYWs7aWYoXFxcIjpcXFwiIT09byl0aHJvdyBuZXcgdihcXFwiSW52YWxpZCB0aW1lIHNlcGFyYXRvcjogXFxcIitvKTtpKz0xfWlmKGk8ZSl7aWYoXFxcIi5cXFwiIT09dFtpXSl0aHJvdyBuZXcgdihcXFwiSW52YWxpZCBtaWNyb3NlY29uZCBjb21wb25lbnRcXFwiKTt7aSs9MTtjb25zdCBzPWUtaTtpZigzIT09cyYmNiE9PXMpdGhyb3cgbmV3IHYoXFxcIkludmFsaWQgbWljcm9zZWNvbmQgY29tcG9uZW50XFxcIik7blszXT1fYXNfaW50ZWdlcih0LnNsaWNlKGkpKSwzPT09cyYmKG5bM10qPTFlMyl9fXJldHVybiBufWZ1bmN0aW9uIF9wYXJzZV9pc29mb3JtYXRfdGltZSh0KXtpZih0Lmxlbmd0aDwyKXRocm93IG5ldyB2KFxcXCJJc29mb3JtYXQgdGltZSB0b28gc2hvcnRcXFwiKTtjb25zdCBlPXQuaW5kZXhPZihcXFwiLVxcXCIpKzF8fHQuaW5kZXhPZihcXFwiK1xcXCIpKzE7bGV0IG4saT1fcGFyc2VfaGhfbW1fc3NfZmYoZT4wP3Quc2xpY2UoMCxlLTEpOnQpLHM9eTtpZihlPjApe2lmKG49dC5zbGljZShlKSwhWzUsOCwxNV0uaW5jbHVkZXMobi5sZW5ndGgpKXRocm93IG5ldyB2KFxcXCJNYWxmb3JtZWQgdGltZSB6b25lIHN0cmluZ1xcXCIpO2NvbnN0IGk9X3BhcnNlX2hoX21tX3NzX2ZmKG4pO2lmKGkuZXZlcnkoKHQ9PjA9PT10KSkpcz1TdC5wcm90b3R5cGUudXRjO2Vsc2V7Y29uc3Qgbj1cXFwiLVxcXCI9PT10W2UtMV0/LTE6MSxvPW5ldyB3dCgwLG4qKDM2MDAqaVswXSs2MCppWzFdK2lbMl0pLG4qaVszXSk7cz1uZXcgU3Qobyl9fXJldHVybiBpPWkubWFwKCh0PT5uZXcgZih0KSkpLGkucHVzaChzKSxpfWZ1bmN0aW9uIF9jaGVja190em5hbWUodCl7aWYodCE9PXkmJiFrKHQpKXRocm93IG5ldyB6KFxcXCJ0emluZm8udHpuYW1lKCkgbXVzdCByZXR1cm4gTm9uZSBvciBzdHJpbmcsIG5vdCAnXFxcIitjKHQpK1xcXCInXFxcIil9ZnVuY3Rpb24gX2NoZWNrX3V0Y19vZmZzZXQodCxuKXtpZihuIT09eSl7aWYoIShuIGluc3RhbmNlb2Ygd3QpKXRocm93IG5ldyB6KGB0emluZm8uJHt0fSgpIG11c3QgcmV0dXJuIE5vbmUgb3IgdGltZWRlbHRhLCBub3QgJyR7YyhuKX0nYCk7aWYoIWUoenQsbixcXFwiTHRcXFwiKXx8IWUobixfdCxcXFwiTHRcXFwiKSl0aHJvdyBuZXcgdihgJHt0fSgpPSR7bi50b1N0cmluZygpfSwgbXVzdCBiZSBzdHJpY3RseSBiZXR3ZWVuIC10aW1lZGVsdGEoaG91cnM9MjQpIGFuZCB0aW1lZGVsdGEoaG91cnM9MjQpYCl9fWZ1bmN0aW9uIF9jaGVja19kYXRlX2ZpZWxkcyh0LGU9bnVsbCxpPW51bGwpe2lmKG51bGw9PT1lfHxudWxsPT09aSl7dGhyb3cgbmV3IHooYGZ1bmN0aW9uIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgJyR7bnVsbD09PWk/XFxcImRheVxcXCI6XFxcIm1vbnRoXFxcIn0nIChwb3MgJHtudWxsPT09aT9cXFwiM1xcXCI6XFxcIjJcXFwifSlgKX1pZih0PW4odCksZT1uKGUpLGk9bihpKSwhKDE8PXQmJnQ8PWopKXRocm93IG5ldyB2KFxcXCJ5ZWFyIG11c3QgYmUgaW4gMS4uOTk5OVxcXCIsbmV3IGYodCkpO2lmKCEoMTw9ZSYmZTw9MTIpKXRocm93IG5ldyB2KFxcXCJtb250aCBtdXN0IGJlIGluIDEuLjEyXFxcIixuZXcgZihlKSk7Y29uc3Qgcz1mdW5jdGlvbiBfZGF5c19pbl9tb250aCh0LGUpe3JldHVybiAyPT09ZSYmX2lzX2xlYXAodCk/Mjk6YXRbZV19KHQsZSk7aWYoISgxPD1pJiZpPD1zKSl0aHJvdyBuZXcgdihcXFwiZGF5IG11c3QgYmUgaW4gMS4uXFxcIitzLG5ldyBmKGkpKTtyZXR1cm5bdCxlLGldfWZ1bmN0aW9uIF9jaGVja190aW1lX2ZpZWxkcyh0LGUsaSxzLG8pe2lmKHQ9bih0KSxlPW4oZSksaT1uKGkpLHM9bihzKSxvPW4obyksISgwPD10JiZ0PD0yMykpdGhyb3cgbmV3IHYoXFxcImhvdXIgbXVzdCBiZSBpbiAwLi4yM1xcXCIsbmV3IGYodCkpO2lmKCEoMDw9ZSYmZTw9NTkpKXRocm93IG5ldyB2KFxcXCJtaW51dGUgbXVzdCBiZSBpbiAwLi41OVxcXCIsbmV3IGYoZSkpO2lmKCEoMDw9aSYmaTw9NTkpKXRocm93IG5ldyB2KFxcXCJzZWNvbmQgbXVzdCBiZSBpbiAwLi41OVxcXCIsbmV3IGYoaSkpO2lmKCEoMDw9cyYmczw9OTk5OTk5KSl0aHJvdyBuZXcgdihcXFwibWljcm9zZWNvbmQgbXVzdCBiZSBpbiAwLi45OTk5OTlcXFwiLG5ldyBmKHMpKTtpZigwIT09byYmMSE9PW8pdGhyb3cgbmV3IHYoXFxcImZvbGQgbXVzdCBiZSBlaXRoZXIgMCBvciAxXFxcIixuZXcgZihvKSk7cmV0dXJuW3QsZSxpLHMsb119ZnVuY3Rpb24gX2NoZWNrX3R6aW5mb19hcmcodCl7aWYodCE9PXkmJiEodCBpbnN0YW5jZW9mIE10KSl0aHJvdyBuZXcgeihcXFwidHppbmZvIGFyZ3VtZW50IG11c3QgYmUgTm9uZSBvciBvZiBhIHR6aW5mbyBzdWJjbGFzc1xcXCIpfWZ1bmN0aW9uIF9kaXZpZGVfYW5kX3JvdW5kKHQsZSl7bGV0W24saV09JGRpdk1vZCh0LGUpO3JldHVybiBpKj0yLCgoZT4wP2k+ZTppPGUpfHxpPT09ZSYmTWF0aC5hYnMobiklMj09MSkmJihuKz0xKSxufWNvbnN0IHd0PUUudGltZWRlbHRhPWgoXFxcImRhdGV0aW1lLnRpbWVkZWx0YVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHRpbWVkZWx0YSh0PTAsZT0wLG49MCl7bGV0IGkscztpZihbaSxuXT0kZGl2TW9kKG4sMWU2KSxlKz1pLFtzLGVdPSRkaXZNb2QoZSw4NjQwMCksdCs9cyx0aGlzLiRkYXlzPXQsdGhpcy4kc2Vjcz1lLHRoaXMuJG1pY3JvPW4sdGhpcy4kaGFzaGNvZGU9LTEsTWF0aC5hYnModCk+OTk5OTk5OTk5KXRocm93IG5ldyBNKGBkYXlzPSR7dH07IG11c3QgaGF2ZSBtYWduaXR1ZGUgPD0gOTk5OTk5OTk5YCl9LHNsb3RzOnt0cCRuZXcodCxlKXtsZXQgaSxzLG8scixhLCQsYyxbaCxtLHUsZCx3LF8scF09bChcXFwidGltZWRlbHRhXFxcIixbXFxcImRheXNcXFwiLFxcXCJzZWNvbmRzXFxcIixcXFwibWljcm9zZWNvbmRzXFxcIixcXFwibWlsbGlzZWNvbmRzXFxcIixcXFwibWludXRlc1xcXCIsXFxcImhvdXJzXFxcIixcXFwid2Vla3NcXFwiXSx0LGUsbmV3IEFycmF5KDcpLmZpbGwoVykpO2k9cz1vPVcsaD1xKGgscShwLEssXFxcIk11bHRcXFwiKSxcXFwiQWRkXFxcIiksbT1xKG0scShxKHcsVixcXFwiTXVsdFxcXCIpLHEoXyxRLFxcXCJNdWx0XFxcIiksXFxcIkFkZFxcXCIpLFxcXCJBZGRcXFwiKSx1PXEodSxxKGQsdHQsXFxcIk11bHRcXFwiKSxcXFwiQWRkXFxcIiksUyhoKT8oW3IsaF09bW9kZihoKSxbYSwkXT1tb2RmKHEocixzdCxcXFwiTXVsdFxcXCIpKSxzPW5ldyBmKCQpLGk9bmV3IGYoaCkpOihhPVosaT1oKSxTKG0pPyhbYyxtXT1tb2RmKG0pLG09bmV3IGYobSksYz1xKGMsYSxcXFwiQWRkXFxcIikpOmM9YSxbaCxtXT1weURpdk1vZChtLGl0KSxpPXEoaSxoLFxcXCJBZGRcXFwiKSxzPXEocyxuZXcgZihtKSxcXFwiQWRkXFxcIik7Y29uc3QgZz1xKGMsbnQsXFxcIk11bHRcXFwiKTtpZihTKHUpPyh1PWludFJvdW5kKHEodSxnLFxcXCJBZGRcXFwiKSksW20sdV09cHlEaXZNb2QodSxldCksW2gsbV09cHlEaXZNb2QobSxpdCksaT1xKGksaCxcXFwiQWRkXFxcIikscz1xKHMsbSxcXFwiQWRkXFxcIikpOih1PW5ldyBmKHUpLFttLHVdPXB5RGl2TW9kKHUsZXQpLFtoLG1dPXB5RGl2TW9kKG0saXQpLGk9cShpLGgsXFxcIkFkZFxcXCIpLHM9cShzLG0sXFxcIkFkZFxcXCIpLHU9aW50Um91bmQocSh1LGcsXFxcIkFkZFxcXCIpKSksW20sb109cHlEaXZNb2QodSxldCkscz1xKHMsbSxcXFwiQWRkXFxcIiksW2gsc109cHlEaXZNb2QocyxpdCksaT1xKGksaCxcXFwiQWRkXFxcIiksaT1uKGkpLHM9bihzKSxvPW4obyksTWF0aC5hYnMoaSk+OTk5OTk5OTk5KXRocm93IG5ldyBNKFxcXCJ0aW1lZGVsdGEgIyBvZiBkYXlzIGlzIHRvbyBsYXJnZTogXFxcIitoLnRvU3RyaW5nKCkpO2lmKHRoaXM9PT13dC5wcm90b3R5cGUpcmV0dXJuIG5ldyB3dChpLHMsbyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIHd0LmNhbGwodCxpLHMsbyksdH19LCRyKCl7Y29uc3QgdD1bXTtyZXR1cm4gdGhpcy4kZGF5cyYmdC5wdXNoKGBkYXlzPSR7dGhpcy4kZGF5c31gKSx0aGlzLiRzZWNzJiZ0LnB1c2goYHNlY29uZHM9JHt0aGlzLiRzZWNzfWApLHRoaXMuJG1pY3JvJiZ0LnB1c2goYG1pY3Jvc2Vjb25kcz0ke3RoaXMuJG1pY3JvfWApLHQubGVuZ3RofHx0LnB1c2goXFxcIjBcXFwiKSxuZXcgdyhgJHt0aGlzLnRwJG5hbWV9KCR7dC5qb2luKFxcXCIsIFxcXCIpfSlgKX0sdHAkc3RyKCl7Y29uc3QgdD10aGlzLiRzZWNzJTYwO2xldCBlPU1hdGguZmxvb3IodGhpcy4kc2Vjcy82MCk7Y29uc3Qgbj1NYXRoLmZsb29yKGUvNjApO2UlPTYwO2xldCBpPWAke259OiR7X2QoZSl9OiR7X2QodCl9YDtpZih0aGlzLiRkYXlzKXtpPWAke3RoaXMuJGRheXN9IGRheSR7ZnVuY3Rpb24gcGx1cmFsKHQpe3JldHVybiAxIT09TWF0aC5hYnModCk/XFxcInNcXFwiOlxcXCJcXFwifSh0aGlzLiRkYXlzKX0sIGAraX1yZXR1cm4gdGhpcy4kbWljcm8mJihpKz1gLiR7X2QodGhpcy4kbWljcm8sXFxcIjBcXFwiLDYpfWApLG5ldyB3KGkpfSx0cCRhc19udW1iZXI6ITAsbmIkYWRkKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygd3Q/bmV3IHd0KHRoaXMuJGRheXMrdC4kZGF5cyx0aGlzLiRzZWNzK3QuJHNlY3MsdGhpcy4kbWljcm8rdC4kbWljcm8pOmJ9LG5iJHN1YnRyYWN0KHQpe3JldHVybiB0IGluc3RhbmNlb2Ygd3Q/bmV3IHd0KHRoaXMuJGRheXMtdC4kZGF5cyx0aGlzLiRzZWNzLXQuJHNlY3MsdGhpcy4kbWljcm8tdC4kbWljcm8pOmJ9LG5iJHBvc2l0aXZlKCl7cmV0dXJuIHRoaXN9LG5iJG5lZ2F0aXZlKCl7cmV0dXJuIG5ldyB3dCgtdGhpcy4kZGF5cywtdGhpcy4kc2VjcywtdGhpcy4kbWljcm8pfSxuYiRhYnMoKXtyZXR1cm4gdGhpcy4kZGF5czwwP3RoaXMubmIkbmVnYXRpdmUoKTp0aGlzfSxuYiRtdWx0aXBseSh0KXtpZihPKHQpKXJldHVybiB0PWkodCxNKSxuZXcgd3QodGhpcy4kZGF5cyp0LHRoaXMuJHNlY3MqdCx0aGlzLiRtaWNybyp0KTtpZihTKHQpKXtjb25zdCBlPXRoaXMuJHRvTWljcm9zZWNzKCk7bGV0W3Msb109X2FzX2ludF9yYXRpbyh0KTtyZXR1cm4gcz1pKHMsTSksbz1uKG8pLG5ldyB3dCgwLDAsX2RpdmlkZV9hbmRfcm91bmQoZSpzLG8pKX1yZXR1cm4gYn0sbmIkZmxvb3JfZGl2aWRlKHQpe2NvbnN0IGU9dGhpcy4kdG9NaWNyb3NlY3MoKTtpZih0IGluc3RhbmNlb2Ygd3Qpe2NvbnN0IG49dC4kdG9NaWNyb3NlY3MoKTtpZigwPT09bil0aHJvdyBuZXcgQShcXFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1xcXCIpO3JldHVybiBuZXcgZihNYXRoLmZsb29yKGUvbikpfWlmKE8odCkpe2lmKDA9PT0odD1pKHQsTSkpKXRocm93IG5ldyBBKFxcXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXFxcIik7cmV0dXJuIG5ldyB3dCgwLDAsTWF0aC5mbG9vcihlL3QpKX1yZXR1cm4gYn0sbmIkZGl2aWRlKHQpe2NvbnN0IGU9dGhpcy4kdG9NaWNyb3NlY3MoKTtpZih0IGluc3RhbmNlb2Ygd3Qpe2lmKDA9PT10LiR0b01pY3Jvc2VjcygpKXRocm93IG5ldyBBKFxcXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXFxcIik7cmV0dXJuIG5ldyBkKGUvdC4kdG9NaWNyb3NlY3MoKSl9aWYoTyh0KSlyZXR1cm4gdD1uKHQpLG5ldyB3dCgwLDAsX2RpdmlkZV9hbmRfcm91bmQoZSx0KSk7aWYoUyh0KSl7bGV0W3Msb109X2FzX2ludF9yYXRpbyh0KTtyZXR1cm4gcz1uKHMpLG89aShvLE0pLG5ldyB3dCgwLDAsX2RpdmlkZV9hbmRfcm91bmQobyplLHMpKX1yZXR1cm4gYn0sbmIkcmVtYWluZGVyKHQpe2lmKCEodCBpbnN0YW5jZW9mIHd0KSlyZXR1cm4gYjtjb25zdCBlPXRoaXMuJHRvTWljcm9zZWNzKCksbj10LiR0b01pY3Jvc2VjcygpO2lmKDA9PT1uKXRocm93IG5ldyBBKFxcXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXFxcIik7Y29uc3QgaT1lLU1hdGguZmxvb3IoZS9uKSpuO3JldHVybiBuZXcgd3QoMCwwLGkpfSxuYiRkaXZtb2QodCl7aWYoISh0IGluc3RhbmNlb2Ygd3QpKXJldHVybiBiO2NvbnN0IGU9dGhpcy4kdG9NaWNyb3NlY3MoKSxuPXQuJHRvTWljcm9zZWNzKCksW2ksc109JGRpdk1vZChlLG4pO3JldHVybiBuZXcgcChbbmV3IGYoaSksbmV3IHd0KDAsMCxzKV0pfSx0cCRyaWNoY29tcGFyZSh0LGUpe3JldHVybiB0IGluc3RhbmNlb2Ygd3Q/X2RvX2NvbXBhcmUodGhpcyx0LGUpOmJ9LHRwJGhhc2goKXtyZXR1cm4tMT09PXRoaXMuJGhhc2hjb2RlJiYodGhpcy4kaGFzaGNvZGU9dShuZXcgcCh0aGlzLiRnZXRTdGF0ZSgpLm1hcCgodD0+bmV3IGYodCkpKSkpKSx0aGlzLiRoYXNoY29kZX0sbmIkYm9vbCgpe3JldHVybiAwIT09dGhpcy4kZGF5c3x8MCE9PXRoaXMuJHNlY3N8fDAhPT10aGlzLiRtaWNyb319LG1ldGhvZHM6e3RvdGFsX3NlY29uZHM6eyRtZXRoKCl7cmV0dXJuIG5ldyBkKCgoODY0MDAqdGhpcy4kZGF5cyt0aGlzLiRzZWNzKSoxMCoqNit0aGlzLiRtaWNybykvMTAqKjYpfSwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcXFwiVG90YWwgc2Vjb25kcyBpbiB0aGUgZHVyYXRpb24uXFxcIn0sX19yZWR1Y2VfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IHAoW3RoaXMub2IkdHlwZSxuZXcgcCh0aGlzLiRnZXRTdGF0ZSgpLm1hcCgodD0+RCh0KSkpKV0pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJfX3JlZHVjZV9fKCkgLT4gKGNscywgc3RhdGUpXFxcIn19LGdldHNldHM6e2RheXM6eyRnZXQoKXtyZXR1cm4gbmV3IGYodGhpcy4kZGF5cyl9LCRkb2M6XFxcIk51bWJlciBvZiBkYXlzLlxcXCJ9LHNlY29uZHM6eyRnZXQoKXtyZXR1cm4gbmV3IGYodGhpcy4kc2Vjcyl9LCRkb2M6XFxcIk51bWJlciBvZiBzZWNvbmRzICg+PSAwIGFuZCBsZXNzIHRoYW4gMSBkYXkpLlxcXCJ9LG1pY3Jvc2Vjb25kczp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRtaWNybyl9LCRkb2M6XFxcIk51bWJlciBvZiBtaWNyb3NlY29uZHMgKD49IDAgYW5kIGxlc3MgdGhhbiAxIHNlY29uZCkuXFxcIn19LHByb3RvOnskdG9NaWNyb3NlY3MoKXtyZXR1cm4gMWU2Kig4NjQwMCp0aGlzLiRkYXlzK3RoaXMuJHNlY3MpK3RoaXMuJG1pY3JvfSwkY21wKHQpe3JldHVybiBfY21wKHRoaXMuJGdldFN0YXRlKCksdC4kZ2V0U3RhdGUoKSl9LCRnZXRTdGF0ZSgpe3JldHVyblt0aGlzLiRkYXlzLHRoaXMuJHNlY3MsdGhpcy4kbWljcm9dfX19KTt3dC5wcm90b3R5cGUubWluPW5ldyB3dCgtOTk5OTk5OTk5KSx3dC5wcm90b3R5cGUubWF4PW5ldyB3dCg5OTk5OTk5OTksODYzOTksOTk5OTk5KSx3dC5wcm90b3R5cGUucmVzb2x1dGlvbj1uZXcgd3QoMCwwLDEpO2NvbnN0IF90PW5ldyB3dCgxKSxwdD1uZXcgd3QoMCwzNjAwKSxndD1uZXcgd3QoMCw2MCkseXQ9bmV3IHd0KDAsMSksYnQ9bmV3IHd0KDApLHp0PW5ldyB3dCgtMSksdnQ9RS5kYXRlPWgoXFxcImRhdGV0aW1lLmRhdGVcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBkYXRlKHQsZSxuKXt0aGlzLiR5ZWFyPXQsdGhpcy4kbW9udGg9ZSx0aGlzLiRkYXk9bix0aGlzLiRoYXNoY29kZT0tMX0sc2xvdHM6e3RwJG5ldyh0LGUpe2xldCBuLFtpLHMsb109bChcXFwiZGF0ZVxcXCIsW1xcXCJ5ZWFyXFxcIixcXFwibW9udGhcXFwiLFxcXCJkYXlcXFwiXSx0LGUsW251bGwsbnVsbF0pO2lmKG51bGw9PT1zJiZpIGluc3RhbmNlb2YgXyYmND09PShuPWkudmFsdWVPZigpKS5sZW5ndGgmJjE8PW5bMl0mJm5bMl08PTEyKXtjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB0LiRzZXRTdGF0ZShuKSx0fWlmKFtpLHMsb109X2NoZWNrX2RhdGVfZmllbGRzKGkscyxvKSx0aGlzPT09dnQucHJvdG90eXBlKXJldHVybiBuZXcgdnQoaSxzLG8pO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB2dC5jYWxsKHQsaSxzLG8pLHR9fSwkcigpe3JldHVybiBuZXcgdyhgJHt0aGlzLnRwJG5hbWV9KCR7dGhpcy4keWVhcn0sICR7dGhpcy4kbW9udGh9LCAke3RoaXMuJGRheX0pYCl9LHRwJHN0cigpe3JldHVybiB0aGlzLnRwJGdldGF0dHIoSCkudHAkY2FsbChbXSl9LHRwJHJpY2hjb21wYXJlKHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiB2dD9fZG9fY29tcGFyZSh0aGlzLHQsZSk6Yn0sdHAkaGFzaCgpe3JldHVybi0xPT09dGhpcy4kaGFzaGNvZGUmJih0aGlzLiRoYXNoY29kZT11KHRoaXMuJGdldFN0YXRlKCkpKSx0aGlzLiRoYXNoY29kZX0sdHAkYXNfbnVtYmVyOiEwLG5iJGFkZCh0KXtpZih0IGluc3RhbmNlb2Ygd3Qpe2NvbnN0IGU9dGhpcy4kdG9PcmRpbmFsKCkrdC4kZGF5cztpZigwPGUmJmU8PXJ0KXJldHVybiB0aGlzLm9iJHR5cGUudHAkZ2V0YXR0cihHKS50cCRjYWxsKFtuZXcgZihlKV0pO3Rocm93IG5ldyBNKFxcXCJyZXN1bHQgb3V0IG9mIHJhbmdlXFxcIil9cmV0dXJuIGJ9LG5iJHN1YnRyYWN0KHQpe2lmKHQgaW5zdGFuY2VvZiB3dClyZXR1cm4gcSh0aGlzLG5ldyB3dCgtdC4kZGF5cyksXFxcIkFkZFxcXCIpO2lmKHQgaW5zdGFuY2VvZiB2dCl7Y29uc3QgZT10aGlzLiR0b09yZGluYWwoKSxuPXQuJHRvT3JkaW5hbCgpO3JldHVybiBuZXcgd3QoZS1uKX1yZXR1cm4gYn0sbmIkcmVmbGVjdGVkX3N1YnRyYWN0Om51bGx9LGNsYXNzbWV0aG9kczp7ZnJvbXRpbWVzdGFtcDp7JG1ldGg6ZnVuY3Rpb24gZnJvbXRpbWVzdGFtcCh0KXtjb25zdFtlLG4saV09JC5sb2NhbHRpbWUudHAkY2FsbChbdF0pLnY7cmV0dXJuIHRoaXMudHAkY2FsbChbZSxuLGldKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwidGltZXN0YW1wIC0+IGxvY2FsIGRhdGUgZnJvbSBhIFBPU0lYIHRpbWVzdGFtcCAobGlrZSB0aW1lLnRpbWUoKSkuXFxcIn0sZnJvbW9yZGluYWw6eyRtZXRoOmZ1bmN0aW9uIGZyb21vcmRpbmFsKHQpe3JldHVybiB0aGlzLnRwJGNhbGwoX29yZDJ5bWQodCkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJpbnQgLT4gZGF0ZSBjb3JyZXNwb25kaW5nIHRvIGEgcHJvbGVwdGljIEdyZWdvcmlhbiBvcmRpbmFsLlxcXCJ9LGZyb21pc29jYWxlbmRhcjp7JG1ldGg6ZnVuY3Rpb24gZnJvbWlzb2NhbGVuZGFyKHQsZSxpKXtpZih0PW4odCksZT1uKGUpLGk9bihpKSwhKDE8PXQmJnQ8PWopKXRocm93IG5ldyB2KGBZZWFyIGlzIG91dCBvZiByYW5nZTogJHt0fWApO2xldCBzLG87aWYoISgwPGUmJmU8NTMpJiYocz0hMCw1Mz09PWUmJihvPV95bWQyb3JkKHQsMSwxKSU3LCg0PT09b3x8Mz09PW8mJl9pc19sZWFwKHQpKSYmKHM9ITEpKSxzKSl0aHJvdyBuZXcgdihgSW52YWxpZCB3ZWVrOiAke2V9YCk7aWYoISgwPGkmJmk8OCkpdGhyb3cgbmV3IHYoYEludmFsaWQgd2Vla2RheTogJHtpfSAocmFuZ2UgaXMgWzEsIDddKWApO2NvbnN0IHI9NyooZS0xKSsoaS0xKSxhPV9pc293ZWVrMW1vbmRheSh0KStyO3JldHVybiB0aGlzLnRwJGNhbGwoX29yZDJ5bWQoYSkpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInllYXJcXFwiLFxcXCJ3ZWVrXFxcIixcXFwiZGF5XFxcIl19LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiaW50IC0+IGRhdGUgY29ycmVzcG9uZGluZyB0byBhIHByb2xlcHRpYyBHcmVnb3JpYW4gb3JkaW5hbC5cXFwifSxmcm9taXNvZm9ybWF0OnskbWV0aDpmdW5jdGlvbiBmcm9taXNvZm9ybWF0KHQpe2lmKCFrKHQpKXRocm93IG5ldyB6KFxcXCJmcm9taXNvZm9ybWF0OiBhcmd1bWVudCBtdXN0IGJlIHN0clxcXCIpO3Q9dC50b1N0cmluZygpO3RyeXtpZigxMCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcjtyZXR1cm4gdGhpcy50cCRjYWxsKF9wYXJzZV9pc29mb3JtYXRfZGF0ZSh0KSl9Y2F0Y2goZSl7dGhyb3cgbmV3IHYoXFxcIkludmFsaWQgaXNvZm9ybWF0IHN0cmluZzogJ1xcXCIrdCtcXFwiJ1xcXCIpfX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwic3RyIC0+IENvbnN0cnVjdCBhIGRhdGUgZnJvbSB0aGUgb3V0cHV0IG9mIGRhdGUuaXNvZm9ybWF0KClcXFwifSx0b2RheTp7JG1ldGg6ZnVuY3Rpb24gdG9kYXkoKXtjb25zdCB0PSQudGltZS50cCRjYWxsKFtdKTtyZXR1cm4gdGhpcy50cCRnZXRhdHRyKEIpLnRwJGNhbGwoW3RdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiQ3VycmVudCBkYXRlIG9yIGRhdGV0aW1lOiAgc2FtZSBhcyBzZWxmLl9fY2xhc3NfXy5mcm9tdGltZXN0YW1wKHRpbWUudGltZSgpKS5cXFwifX0sbWV0aG9kczp7Y3RpbWU6eyRtZXRoOmZ1bmN0aW9uIGN0aW1lKCl7Y29uc3QgdD10aGlzLiR0b09yZGluYWwoKSU3fHw3LGU9ZnRbdF0sbj1sdFt0aGlzLiRtb250aF07cmV0dXJuIG5ldyB3KGAke2V9ICR7bn0gJHtfZCh0aGlzLiRkYXksXFxcIiBcXFwiLDIpfSAwMDowMDowMCAke19kKHRoaXMuJHllYXIsXFxcIjBcXFwiLDQpfWApfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gY3RpbWUoKSBzdHlsZSBzdHJpbmcuXFxcIn0sc3RyZnRpbWU6eyRtZXRoOmZ1bmN0aW9uIHN0cmZ0aW1lKHQpe2lmKCFrKHQpKXRocm93IG5ldyB6KFxcXCJtdXN0IGJlIHN0ciwgbm90IFxcXCIrYyh0KSk7cmV0dXJuIF93cmFwX3N0cmZ0aW1lKHRoaXMsdD10LnRvU3RyaW5nKCksdGhpcy4kdGltZXR1cGxlKCkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJmb3JtYXQgLT4gc3RyZnRpbWUoKSBzdHlsZSBzdHJpbmcuXFxcIn0sX19mb3JtYXRfXzp7JG1ldGg6ZnVuY3Rpb24gX19mb3JtYXRfXyh0KXtpZighayh0KSl0aHJvdyBuZXcgeihcXFwibXVzdCBiZSBzdHIsIG5vdCBcXFwiK2ModCkpO3JldHVybiB0IT09dy4kZW1wdHk/dGhpcy50cCRnZXRhdHRyKFgpLnRwJGNhbGwoW3RdKTp0aGlzLnRwJHN0cigpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJGb3JtYXRzIHNlbGYgd2l0aCBzdHJmdGltZS5cXFwifSx0aW1ldHVwbGU6eyRtZXRoOmZ1bmN0aW9uIHRpbWV0dXBsZSgpe3JldHVybiB0aGlzLiR0aW1ldHVwbGUoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHRpbWUgdHVwbGUsIGNvbXBhdGlibGUgd2l0aCB0aW1lLmxvY2FsdGltZSgpLlxcXCJ9LGlzb2NhbGVuZGFyOnskbWV0aDpmdW5jdGlvbiBpc29jYWxlbmRhcigpe2xldCB0PXRoaXMuJHllYXIsZT1faXNvd2VlazFtb25kYXkodCk7Y29uc3Qgbj1feW1kMm9yZCh0aGlzLiR5ZWFyLHRoaXMuJG1vbnRoLHRoaXMuJGRheSk7bGV0W2ksc109JGRpdk1vZChuLWUsNyk7cmV0dXJuIGk8MD8odC09MSxlPV9pc293ZWVrMW1vbmRheSh0KSxbaSxzXT0kZGl2TW9kKG4tZSw3KSk6aT49NTImJm4+PV9pc293ZWVrMW1vbmRheSh0KzEpJiYodCs9MSxpPTApLG5ldyBBdChuZXcgZih0KSxuZXcgZihpKzEpLG5ldyBmKHMrMSkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gYSAzLXR1cGxlIGNvbnRhaW5pbmcgSVNPIHllYXIsIHdlZWsgbnVtYmVyLCBhbmQgd2Vla2RheS5cXFwifSxpc29mb3JtYXQ6eyRtZXRoOmZ1bmN0aW9uIGlzb2Zvcm1hdCgpe3JldHVybiB0aGlzLiRpc29mb3JtYXQoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQsIFlZWVktTU0tREQuXFxcIn0saXNvd2Vla2RheTp7JG1ldGg6ZnVuY3Rpb24gaXNvd2Vla2RheSgpe3JldHVybiBuZXcgZih0aGlzLiR0b09yZGluYWwoKSU3fHw3KX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHRoZSBkYXkgb2YgdGhlIHdlZWsgcmVwcmVzZW50ZWQgYnkgdGhlIGRhdGUuXFxcXG5Nb25kYXkgPT0gMSAuLi4gU3VuZGF5ID09IDdcXFwifSx0b29yZGluYWw6eyRtZXRoOmZ1bmN0aW9uIHRvb3JkaW5hbCgpe3JldHVybiBuZXcgZih0aGlzLiR0b09yZGluYWwoKSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBwcm9sZXB0aWMgR3JlZ29yaWFuIG9yZGluYWwuICBKYW51YXJ5IDEgb2YgeWVhciAxIGlzIGRheSAxLlxcXCJ9LHdlZWtkYXk6eyRtZXRoOmZ1bmN0aW9uIHdlZWtkYXkoKXtyZXR1cm4gbmV3IGYoKHRoaXMuJHRvT3JkaW5hbCgpKzYpJTcpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gdGhlIGRheSBvZiB0aGUgd2VlayByZXByZXNlbnRlZCBieSB0aGUgZGF0ZS5cXFxcbk1vbmRheSA9PSAwIC4uLiBTdW5kYXkgPT0gNlxcXCJ9LHJlcGxhY2U6eyRtZXRoOmZ1bmN0aW9uIHJlcGxhY2UodCxlLG4pe3JldHVybiB0PT09eSYmKHQ9bmV3IGYodGhpcy4keWVhcikpLGU9PT15JiYoZT1uZXcgZih0aGlzLiRtb250aCkpLG49PT15JiYobj1uZXcgZih0aGlzLiRkYXkpKSx0aGlzLm9iJHR5cGUudHAkY2FsbChbdCxlLG5dKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ5ZWFyXFxcIixcXFwibW9udGhcXFwiLFxcXCJkYXlcXFwiXSxEZWZhdWx0czpbeSx5LHldfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBkYXRlIHdpdGggbmV3IHNwZWNpZmllZCBmaWVsZHMuXFxcIn0sX19yZWR1Y2VfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IHAoW3RoaXMub2IkdHlwZSxuZXcgcChbdGhpcy4kZ2V0U3RhdGUoKV0pXSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIl9fcmVkdWNlX18oKSAtPiAoY2xzLCBzdGF0ZSlcXFwifX0sZ2V0c2V0czp7eWVhcjp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiR5ZWFyKX0sJGRvYzpcXFwieWVhciAoMS05OTk5KVxcXCJ9LG1vbnRoOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJG1vbnRoKX0sJGRvYzpcXFwibW9udGggKDEtMTIpXFxcIn0sZGF5OnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJGRheSl9LCRkb2M6XFxcImRheSAoMS0zMSlcXFwifX0scHJvdG86eyRjbXAodCl7cmV0dXJuIF9jbXAoW3RoaXMuJHllYXIsdGhpcy4kbW9udGgsdGhpcy4kZGF5XSxbdC4keWVhcix0LiRtb250aCx0LiRkYXldKX0sJGdldFN0YXRlKCl7Y29uc3RbdCxlXT0kZGl2TW9kKHRoaXMuJHllYXIsMjU2KTtyZXR1cm4gbmV3IF8oW3QsZSx0aGlzLiRtb250aCx0aGlzLiRkYXldKX0sJHNldFN0YXRlKHQpe2NvbnN0W2UsbixpLHNdPXQsbz0yNTYqZStuO3RoaXMuJHllYXI9byx0aGlzLiRtb250aD1pLHRoaXMuJGRheT1zfSwkdG9PcmRpbmFsKCl7cmV0dXJuIF95bWQyb3JkKHRoaXMuJHllYXIsdGhpcy4kbW9udGgsdGhpcy4kZGF5KX0sJGlzb2Zvcm1hdCgpe3JldHVybiBuZXcgdyhgJHtfZCh0aGlzLiR5ZWFyLFxcXCIwXFxcIiw0KX0tJHtfZCh0aGlzLiRtb250aCxcXFwiMFxcXCIsMil9LSR7X2QodGhpcy4kZGF5LFxcXCIwXFxcIiwyKX1gKX0sJHRpbWV0dXBsZSgpe3JldHVybiBfYnVpbGRfc3RydWN0X3RpbWUodGhpcy4keWVhcix0aGlzLiRtb250aCx0aGlzLiRkYXksdGhpcy4kaG91cnx8MCx0aGlzLiRtaW58fDAsdGhpcy4kc2VjfHwwLC0xKX0sJHN0cmZ0aW1lKHQ9XFxcIlxcXCIpe3JldHVybiBfd3JhcF9zdHJmdGltZSh0aGlzLHQudG9TdHJpbmcoKSx0aGlzLiR0aW1ldHVwbGUoKSl9fX0pO3Z0LnByb3RvdHlwZS5taW49bmV3IHZ0KDEsMSwxKSx2dC5wcm90b3R5cGUubWF4PW5ldyB2dCg5OTk5LDEyLDMxKSx2dC5wcm90b3R5cGUucmVzb2x1dGlvbj1uZXcgd3QoMSk7Y29uc3QgTXQ9RS50emluZm89aChcXFwiZGF0ZXRpbWUudHppbmZvXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gdHppbmZvKCl7fSxtZXRob2RzOnt0em5hbWU6eyRtZXRoOmZ1bmN0aW9uIHR6bmFtZSh0KXt0aHJvdyBuZXcgeChcXFwidHppbmZvIHN1YmNsYXNzIG11c3Qgb3ZlcnJpZGUgdHpuYW1lKClcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiZGF0ZXRpbWUgLT4gc3RyaW5nIG5hbWUgb2YgdGltZSB6b25lLlxcXCJ9LHV0Y29mZnNldDp7JG1ldGg6ZnVuY3Rpb24gdXRjb2Zmc2V0KHQpe3Rocm93IG5ldyB4KFxcXCJ0emluZm8gc3ViY2xhc3MgbXVzdCBvdmVycmlkZSB1dGNvZmZzZXQoKVxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJkYXRldGltZSAtPiB0aW1lZGVsdGEgc2hvd2luZyBvZmZzZXQgZnJvbSBVVEMsIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0aW5nIFdlc3Qgb2YgVVRDXFxcIn0sZHN0OnskbWV0aDpmdW5jdGlvbiBkc3QodCl7dGhyb3cgbmV3IHgoXFxcInR6aW5mbyBzdWJjbGFzcyBtdXN0IG92ZXJyaWRlIGRzdCgpXFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcImRhdGV0aW1lIC0+IERTVCBvZmZzZXQgYXMgdGltZWRlbHRhIHBvc2l0aXZlIGVhc3Qgb2YgVVRDLlxcXCJ9LGZyb211dGM6eyRtZXRoOmZ1bmN0aW9uIGZyb211dGMoZSl7aWYoIShlIGluc3RhbmNlb2YgTnQpKXRocm93IG5ldyB6KFxcXCJmcm9tdXRjKCkgcmVxdWlyZXMgYSBkYXRldGltZSBhcmd1bWVudFxcXCIpO2lmKGUuJHR6aW5mbyE9PXRoaXMpdGhyb3cgbmV3IHYoXFxcImR0LnR6aW5mbyBpcyBub3Qgc2VsZlxcXCIpO2NvbnN0IG49cihlLnRwJGdldGF0dHIoVSkpO2lmKG49PT15KXRocm93IG5ldyB2KFxcXCJmcm9tdXRjKCkgcmVxdWlyZXMgYSBub24tTm9uZSB1dGNvZmZzZXQoKSByZXN1bHRcXFwiKTtsZXQgaT1yKGUudHAkZ2V0YXR0cihGKSk7aWYoaT09PXkpdGhyb3cgbmV3IHYoXFxcImZyb211dGMoKSByZXF1aXJlcyBhIG5vbi1Ob25lIGRzdCgpIHJlc3VsdFxcXCIpO2NvbnN0IHM9cShuLGksXFxcIlN1YlxcXCIpO2lmKHQocykmJihlPXEoZSxzLFxcXCJBZGRcXFwiKSxpPXIoZS50cCRnZXRhdHRyKEYpKSxpPT09eSkpdGhyb3cgbmV3IHYoXFxcImZyb211dGMoKTogZHQuZHN0IGdhdmUgaW5jb25zaXN0ZW50IHJlc3VsdHM7IGNhbm5vdCBjb252ZXJ0XFxcIik7cmV0dXJuIHEoZSxpLFxcXCJBZGRcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiZGF0ZXRpbWUgaW4gVVRDIC0+IGRhdGV0aW1lIGluIGxvY2FsIHRpbWUuXFxcIn0sX19yZWR1Y2VfXzp7JG1ldGgoKXtsZXQgZSxuO2NvbnN0IGk9VCh0aGlzLG5ldyB3KFxcXCJfX2dldGluaXRhcmdzX19cXFwiKSx5KTtlPWkhPT15P3IoaSxbXSk6bmV3IHA7Y29uc3Qgcz1UKHRoaXMsbmV3IHcoXFxcIl9fZ2V0c3RhdGVfX1xcXCIpLHkpO3JldHVybiBzIT09eT9uPXIocyxbXSk6KG49VCh0aGlzLG5ldyB3KFxcXCJfX2RpY3RfX1xcXCIpLHkpLG49dChuKT9uOnkpLG5ldyBwKG49PT15P1t0aGlzLm9iJHR5cGUsZV06W3RoaXMub2IkdHlwZSxlLG5dKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiLT4gKGNscywgc3RhdGUpXFxcIn19fSksQXQ9aChcXFwiZGF0ZXRpbWUuSXNvQ2FsZW5kYXJEYXRlXFxcIix7YmFzZTpwLGNvbnN0cnVjdG9yOmZ1bmN0aW9uIElzb0NhbGVuZGFyRGF0ZSh0LGUsbil7dGhpcy55PXQsdGhpcy53PWUsdGhpcy53ZD1uLHAuY2FsbCh0aGlzLFt0LGUsbl0pfSxzbG90czp7dHAkbmV3KHQsZSl7Y29uc3RbbixpLHNdPWwoXFxcIklzb0NhbGVuZGFyRGF0ZVxcXCIsW1xcXCJ5ZWFyXFxcIixcXFwid2Vla1xcXCIsXFxcIndlZWtkYXlcXFwiXSx0LGUpO3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihuLGkscyl9LCRyKCl7cmV0dXJuIG5ldyB3KGAke3RoaXMudHAkbmFtZX0oeWVhcj0ke3RoaXMueX0sIHdlZWs9JHt0aGlzLnd9LCB3ZWVrZGF5PSR7dGhpcy53ZH0pYCl9fSxnZXRzZXRzOnt5ZWFyOnskZ2V0KCl7cmV0dXJuIHRoaXMueX19LHdlZWs6eyRnZXQoKXtyZXR1cm4gdGhpcy53fX0sd2Vla2RheTp7JGdldCgpe3JldHVybiB0aGlzLndkfX19fSkseHQ9RS50aW1lPWgoXFxcImRhdGV0aW1lLnRpbWVcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiB0aW1lKHQ9MCxlPTAsbj0wLGk9MCxzPW51bGwsbz0wKXt0aGlzLiRob3VyPXQsdGhpcy4kbWluPWUsdGhpcy4kc2VjPW4sdGhpcy4kbWljcm89aSx0aGlzLiR0emluZm89c3x8eSx0aGlzLiRmb2xkPW8sdGhpcy4kaGFzaGNvZGU9LTF9LHNsb3RzOnt0cCRuZXcodCxlKXttKFxcXCJ0aW1lXFxcIix0LDAsNSk7bGV0IG4sW2kscyxvLHIsYSwkXT1sKFxcXCJ0aW1lXFxcIixbXFxcImhvdXJcXFwiLFxcXCJtaW51dGVcXFwiLFxcXCJzZWNvbmRcXFwiLFxcXCJtaWNyb3NlY29uZFxcXCIsXFxcInR6aW5mb1xcXCIsXFxcImZvbGRcXFwiXSx0LGUsW1csVyxXLFcseSxXXSk7aWYoaSBpbnN0YW5jZW9mIF8mJjY9PT0obj1pLnZhbHVlT2YoKSkubGVuZ3RoJiYoMTI3Jm5bMF0pPDI0KXtjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB0LiRzZXRTdGF0ZShuLHM9PT1XP3k6cyksdH1pZihbaSxzLG8sciwkXT1fY2hlY2tfdGltZV9maWVsZHMoaSxzLG8sciwkKSxfY2hlY2tfdHppbmZvX2FyZyhhKSx0aGlzPT09eHQucHJvdG90eXBlKXJldHVybiBuZXcgeHQoaSxzLG8scixhLCQpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB4dC5jYWxsKHQsaSxzLG8scixhLCQpLHR9fSx0cCRyaWNoY29tcGFyZSh0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgeHQ/X2RvX2NvbXBhcmUodGhpcyx0LGUpOmJ9LHRwJGhhc2goKXtpZigtMT09PXRoaXMuJGhhc2hjb2RlKXtjb25zdCBlPXRoaXMuJGZvbGQ/cih0aGlzLnRwJGdldGF0dHIoSiksW10sW1xcXCJmb2xkXFxcIixXXSk6dGhpcyxuPXIoZS50cCRnZXRhdHRyKFUpKTtpZih0KG4pKXtsZXRbdCxlXT1weURpdk1vZChuZXcgd3QoMCwzNjAwKnRoaXMuJGhvdXIrNjAqdGhpcy4kbWluKS5uYiRzdWJ0cmFjdChuKSxwdCk7ZT1lLm5iJGZsb29yX2RpdmlkZShndCksMDw9dCYmdDw9MjQ/KHQ9SSh0KSxlPUkoZSksdGhpcy4kaGFzaGNvZGU9dShuZXcgeHQodCxlLHRoaXMuJHNlYyx0aGlzLiRtaWNybykpKTp0aGlzLiRoYXNoY29kZT11KG5ldyBwKFt0LGUsbmV3IGYodGhpcy4kc2VjKSxuZXcgZih0aGlzLiRtaWNybyldKSl9ZWxzZSB0aGlzLiRoYXNoY29kZT11KGUuJGdldFN0YXRlKClbMF0pfXJldHVybiB0aGlzLiRoYXNoY29kZX0sJHIoKXtsZXQgdDtyZXR1cm4gdD0wIT09dGhpcy4kbWljcm8/YCwgJHt0aGlzLiRzZWN9LCAke3RoaXMuJG1pY3JvfWA6MCE9PXRoaXMuJHNlYz9gLCAke3RoaXMuJHNlY31gOlxcXCJcXFwiLHQ9YCR7dGhpcy50cCRuYW1lfSgke3RoaXMuJGhvdXJ9LCAke3RoaXMuJG1pbn0ke3R9KWAsdGhpcy4kdHppbmZvIT09eSYmKHQ9dC5zbGljZSgwLC0xKStcXFwiLCB0emluZm89XFxcIitzKHRoaXMuJHR6aW5mbykrXFxcIilcXFwiKSx0aGlzLiRmb2xkJiYodD10LnNsaWNlKDAsLTEpK1xcXCIsIGZvbGQ9MSlcXFwiKSxuZXcgdyh0KX0sdHAkc3RyKCl7cmV0dXJuIHRoaXMudHAkZ2V0YXR0cihIKS50cCRjYWxsKFtdKX19LG1ldGhvZHM6e2lzb2Zvcm1hdDp7JG1ldGg6ZnVuY3Rpb24gaXNvZm9ybWF0KHQpe2xldCBlPV9mb3JtYXRfdGltZSh0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsdGhpcy4kbWljcm8sdCk7Y29uc3Qgbj10aGlzLiR0enN0cigpO3JldHVybiBuJiYoZSs9biksbmV3IHcoZSl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwidGltZXNwZWNcXFwiXSxEZWZhdWx0czpbQ119LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQsIFtISFs6TU1bOlNTWy5tbW1bdXV1XV1dXV1bK0hIOk1NXS5cXFxcblxcXFxudGltZXNwZWMgc3BlY2lmaWVzIHdoYXQgY29tcG9uZW50cyBvZiB0aGUgdGltZSB0byBpbmNsdWRlLlxcXFxuXFxcIn0sc3RyZnRpbWU6eyRtZXRoOmZ1bmN0aW9uIHN0cmZ0aW1lKHQpe2lmKCFrKHQpKXRocm93IG5ldyB6KFxcXCJtdXN0IGJlIHN0ciwgbm90IFxcXCIrYyh0KSk7cmV0dXJuIF93cmFwX3N0cmZ0aW1lKHRoaXMsdD10LnRvU3RyaW5nKCksbmV3IHAoWzE5MDAsMSwxLHRoaXMuJGhvdXIsdGhpcy4kbWluLHRoaXMuJHNlYywwLDEsLTFdLm1hcCgodD0+bmV3IGYodCkpKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJmb3JtYXQgLT4gc3RyZnRpbWUoKSBzdHlsZSBzdHJpbmcuXFxcIn0sX19mb3JtYXRfXzp7JG1ldGg6ZnVuY3Rpb24gX19mb3JtYXRfXyh0KXtpZighayh0KSl0aHJvdyBuZXcgeihcXFwibXVzdCBiZSBzdHIsIG5vdCBcXFwiK2ModCkpO3JldHVybiB0IT09dy4kZW1wdHk/dGhpcy50cCRnZXRhdHRyKFgpLnRwJGNhbGwoW3RdKTp0aGlzLnRwJHN0cigpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJGb3JtYXRzIHNlbGYgd2l0aCBzdHJmdGltZS5cXFwifSx1dGNvZmZzZXQ6eyRtZXRoOmZ1bmN0aW9uIHV0Y29mZnNldCgpe2lmKHRoaXMuJHR6aW5mbz09PXkpcmV0dXJuIHk7Y29uc3QgdD10aGlzLiR0emluZm8udHAkZ2V0YXR0cihVKSxlPXIodCxbeV0pO3JldHVybiBfY2hlY2tfdXRjX29mZnNldChcXFwidXRjb2Zmc2V0XFxcIixlKSxlfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gc2VsZi50emluZm8udXRjb2Zmc2V0KHNlbGYpLlxcXCJ9LHR6bmFtZTp7JG1ldGg6ZnVuY3Rpb24gdHpuYW1lKCl7aWYodGhpcy4kdHppbmZvPT09eSlyZXR1cm4geTtjb25zdCB0PXRoaXMuJHR6aW5mby50cCRnZXRhdHRyKFkpLGU9cih0LFt5XSk7cmV0dXJuIF9jaGVja190em5hbWUoZSksZX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHNlbGYudHppbmZvLnR6bmFtZShzZWxmKS5cXFwifSxkc3Q6eyRtZXRoOmZ1bmN0aW9uIGRzdCgpe2lmKHRoaXMuJHR6aW5mbz09PXkpcmV0dXJuIHk7Y29uc3QgdD10aGlzLiR0emluZm8udHAkZ2V0YXR0cihGKSxlPXIodCxbeV0pO3JldHVybiBfY2hlY2tfdXRjX29mZnNldChcXFwiZHN0XFxcIixlKSxlfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gc2VsZi50emluZm8uZHN0KHNlbGYpLlxcXCJ9LHJlcGxhY2U6eyRtZXRoOmZ1bmN0aW9uIHJlcGxhY2UodCxlKXttKFxcXCJyZXBsYWNlXFxcIix0LDAsNSk7bGV0W24saSxzLG8scixhXT1sKFxcXCJyZXBsYWNlXFxcIixbXFxcImhvdXJcXFwiLFxcXCJtaW51dGVcXFwiLFxcXCJzZWNvbmRcXFwiLFxcXCJtaWNyb3NlY29uZFxcXCIsXFxcInR6aW5mb1xcXCIsXFxcImZvbGRcXFwiXSx0LGUsW3kseSx5LHksZyx5XSk7cmV0dXJuIG49PT15JiYobj1uZXcgZih0aGlzLiRob3VyKSksaT09PXkmJihpPW5ldyBmKHRoaXMuJG1pbikpLHM9PT15JiYocz1uZXcgZih0aGlzLiRzZWMpKSxvPT09eSYmKG89bmV3IGYodGhpcy4kbWljcm8pKSxyPT09ZyYmKHI9dGhpcy4kdHppbmZvKSxhPT09eSYmKGE9bmV3IGYodGhpcy4kZm9sZCkpLHRoaXMub2IkdHlwZS50cCRjYWxsKFtuLGkscyxvLHJdLFtcXFwiZm9sZFxcXCIsYV0pfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiB0aW1lIHdpdGggbmV3IHNwZWNpZmllZCBmaWVsZHMuXFxcIn0sX19yZWR1Y2VfZXhfXzp7JG1ldGgodCl7cmV0dXJuIG5ldyBwKFt0aGlzLm9iJHR5cGUsbmV3IHAodGhpcy4kZ2V0U3RhdGUoUih0KSkpXSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIl9fcmVkdWNlX2V4X18ocHJvdG8pIC0+IChjbHMsIHN0YXRlKVxcXCJ9LF9fcmVkdWNlX186eyRtZXRoKCl7cmV0dXJuIHRoaXMudHAkZ2V0YXR0cihuZXcgdyhcXFwiX19yZWR1Y2VfZXhfX1xcXCIpKS50cCRjYWxsKFtuZXcgZigyKV0pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJfX3JlZHVjZV9fKCkgLT4gKGNscywgc3RhdGUpXFxcIn19LGNsYXNzbWV0aG9kczp7ZnJvbWlzb2Zvcm1hdDp7JG1ldGg6ZnVuY3Rpb24gZnJvbWlzb2Zvcm1hdCh0KXtpZighayh0KSl0aHJvdyBuZXcgeihcXFwiZnJvbWlzb2Zvcm1hdDogYXJndW1lbnQgbXVzdCBiZSBzdHJcXFwiKTt0PXQudG9TdHJpbmcoKTt0cnl7cmV0dXJuIHRoaXMudHAkY2FsbChfcGFyc2VfaXNvZm9ybWF0X3RpbWUodCkpfWNhdGNoe3Rocm93IG5ldyB2KFxcXCJJbnZhbGlkIGlzb2ZybWF0IHN0cmluZzogJ1xcXCIrdCtcXFwiJ1xcXCIpfX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwic3RyaW5nIC0+IHRpbWUgZnJvbSB0aW1lLmlzb2Zvcm1hdCgpIG91dHB1dFxcXCJ9fSxnZXRzZXRzOntob3VyOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJGhvdXIpfX0sbWludXRlOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJG1pbil9fSxzZWNvbmQ6eyRnZXQoKXtyZXR1cm4gbmV3IGYodGhpcy4kc2VjKX19LG1pY3Jvc2Vjb25kOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJG1pY3JvKX19LHR6aW5mbzp7JGdldCgpe3JldHVybiB0aGlzLiR0emluZm99fSxmb2xkOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJGZvbGQpfX19LHByb3RvOnskY21wKHQsbil7Y29uc3Qgcz10aGlzLiR0emluZm8sbz10LiR0emluZm87bGV0IGEsJCxjO2lmKGE9JD15LHM9PT1vP2M9ITA6KGE9cih0aGlzLnRwJGdldGF0dHIoVSkpLCQ9cih0LnRwJGdldGF0dHIoVSkpLGM9ZShhLCQsXFxcIkVxXFxcIikpLGMpcmV0dXJuIF9jbXAoW3RoaXMuJGhvdXIsdGhpcy4kbWluLHRoaXMuJHNlYyx0aGlzLiRtaWNyb10sW3QuJGhvdXIsdC4kbWluLHQuJHNlYyx0LiRtaWNyb10pO2lmKGE9PT15fHwkPT09eSl7aWYoXFxcIkVxXFxcIj09PW58fFxcXCJOb3RFcVxcXCI9PT1uKXJldHVybiAyO3Rocm93IG5ldyB6KFxcXCJjYW5ub3QgY29tcGFyZSBuYWl2ZSBhbmQgYXdhcmUgdGltZXNcXFwiKX1jb25zdCBoPTYwKnRoaXMuJGhvdXIrdGhpcy4kbWluLWkoYS5uYiRmbG9vcl9kaXZpZGUoZ3QpKSxtPTYwKnQuJGhvdXIrdC4kbWluLWkoJC5uYiRmbG9vcl9kaXZpZGUoZ3QpKTtyZXR1cm4gX2NtcChbaCx0aGlzLiRzZWMsdGhpcy4kbWljcm9dLFttLHQuJHNlYyx0LiRtaWNyb10pfSwkdHpzdHIoKXtyZXR1cm4gX2Zvcm1hdF9vZmZzZXQocih0aGlzLnRwJGdldGF0dHIoVSkpKX0sJGdldFN0YXRlKHQ9Myl7bGV0W2Usbl09JGRpdk1vZCh0aGlzLiRtaWNybywyNTYpLFtpLHNdPSRkaXZNb2QoZSwyNTYpLG89dGhpcy4kaG91cjt0aGlzLiRmb2xkJiZ0PjMmJihvKz0xMjgpO2NvbnN0IHI9bmV3IF8oW28sdGhpcy4kbWluLHRoaXMuJHNlYyxpLHMsbl0pO3JldHVybiB0aGlzLiR0emluZm89PT15P1tyXTpbcix0aGlzLiR0emluZm9dfSwkc2V0U3RhdGUodCxlKXtjb25zdFtuLGkscyxvLHIsYV09dDtuPjEyNz8odGhpcy4kZm9sZD0xLHRoaXMuJGhvdXI9bi0xMjgpOih0aGlzLiRmb2xkPTAsdGhpcy4kaG91cj1uKSx0aGlzLiRtaW49aSx0aGlzLiRzZWM9cyx0aGlzLiRtaWNybz0obzw8OHxyKTw8OHxhLHRoaXMuJHR6aW5mbz1lfX19KTt4dC5wcm90b3R5cGUubWluPW5ldyB4dCgwLDAsMCkseHQucHJvdG90eXBlLm1heD1uZXcgeHQoMjMsNTksNTksOTk5OTk5KSx4dC5wcm90b3R5cGUucmVzb2x1dGlvbj1uZXcgd3Q7Y29uc3QgTnQ9RS5kYXRldGltZT1oKFxcXCJkYXRldGltZS5kYXRldGltZVxcXCIse2Jhc2U6dnQsY29uc3RydWN0b3I6ZnVuY3Rpb24gZGF0ZXRpbWUodCxlLG4saT0wLHM9MCxvPTAscj0wLGE9bnVsbCwkPTApe3RoaXMuJHllYXI9dCx0aGlzLiRtb250aD1lLHRoaXMuJGRheT1uLHRoaXMuJGhvdXI9aSx0aGlzLiRtaW49cyx0aGlzLiRzZWM9byx0aGlzLiRtaWNybz1yLHRoaXMuJHR6aW5mbz1hfHx5LHRoaXMuJGZvbGQ9JCx0aGlzLiRoYXNoY29kZT0tMX0sc2xvdHM6e3RwJG5ldyh0LGUpe20oXFxcImRhdGV0aW1lXFxcIix0LDAsOSk7bGV0IG4sW2kscyxvLHIsYSwkLGMsaCx1XT1sKFxcXCJ0aW1lXFxcIixbXFxcInllYXJcXFwiLFxcXCJtb250aFxcXCIsXFxcImRheVxcXCIsXFxcImhvdXJcXFwiLFxcXCJtaW51dGVcXFwiLFxcXCJzZWNvbmRcXFwiLFxcXCJtaWNyb3NlY29uZFxcXCIsXFxcInR6aW5mb1xcXCIsXFxcImZvbGRcXFwiXSx0LGUsW251bGwsbnVsbCxXLFcsVyxXLHksV10pO2lmKGkgaW5zdGFuY2VvZiBfJiYxMD09PShuPWkudmFsdWVPZigpKS5sZW5ndGgmJigxMjcmblsyXSk8PTEyKXtjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB0LiRzZXRTdGF0ZShuLG51bGw9PT1zP3k6cyksdH1pZihbaSxzLG9dPV9jaGVja19kYXRlX2ZpZWxkcyhpLHMsbyksW3IsYSwkLGMsdV09X2NoZWNrX3RpbWVfZmllbGRzKHIsYSwkLGMsdSksX2NoZWNrX3R6aW5mb19hcmcoaCksdGhpcz09PU50LnByb3RvdHlwZSlyZXR1cm4gbmV3IE50KGkscyxvLHIsYSwkLGMsaCx1KTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gTnQuY2FsbCh0LGkscyxvLHIsYSwkLGMsaCx1KSx0fX0sJHIoKXtjb25zdCB0PVt0aGlzLiR5ZWFyLHRoaXMuJG1vbnRoLHRoaXMuJGRheSx0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsdGhpcy4kbWljcm9dOzA9PT10W3QubGVuZ3RoLTFdJiZ0LnBvcCgpLDA9PT10W3QubGVuZ3RoLTFdJiZ0LnBvcCgpO2xldCBlPWAke3RoaXMudHAkbmFtZX0oJHt0LmpvaW4oXFxcIiwgXFxcIil9KWA7cmV0dXJuIHRoaXMuJHR6aW5mbyE9PXkmJihlPWUuc2xpY2UoMCwtMSkrXFxcIiwgdHppbmZvPVxcXCIrcyh0aGlzLiR0emluZm8pK1xcXCIpXFxcIiksdGhpcy4kZm9sZCYmKGU9ZS5zbGljZSgwLC0xKStcXFwiLCBmb2xkPTEpXFxcIiksbmV3IHcoZSl9LHRwJHN0cigpe3JldHVybiB0aGlzLnRwJGdldGF0dHIoSCkudHAkY2FsbChbXSxbXFxcInNlcFxcXCIsbmV3IHcoXFxcIiBcXFwiKV0pfSx0cCRyaWNoY29tcGFyZSh0LGUpe2lmKHQgaW5zdGFuY2VvZiBOdClyZXR1cm4gX2RvX2NvbXBhcmUodGhpcyx0LGUpO2lmKCEodCBpbnN0YW5jZW9mIHZ0KSlyZXR1cm4gYjtpZihcXFwiRXFcXFwiPT09ZXx8XFxcIk5vdEVxXFxcIj09PWUpcmV0dXJuXFxcIk5vdEVxXFxcIj09PWU7dGhyb3cgbmV3IHooYGNhbid0IGNvbXBhcmUgJyR7Yyh0aGlzKX0nIHRvICcke2ModCl9J2ApfSx0cCRhc19udW1iZXI6ITAsbmIkYWRkKHQpe2lmKCEodCBpbnN0YW5jZW9mIHd0KSlyZXR1cm4gYjtsZXQgZT1uZXcgd3QodGhpcy4kdG9PcmRpbmFsKCksMzYwMCp0aGlzLiRob3VyKzYwKnRoaXMuJG1pbit0aGlzLiRzZWMsdGhpcy4kbWljcm8pO2U9cShlLHQsXFxcIkFkZFxcXCIpO2xldFtuLGldPSRkaXZNb2QoZS4kc2VjcywzNjAwKSxbcyxvXT0kZGl2TW9kKGksNjApO2lmKDA8ZS4kZGF5cyYmZS4kZGF5czw9cnQpcmV0dXJuIHRoaXMub2IkdHlwZS50cCRnZXRhdHRyKG5ldyB3KFxcXCJjb21iaW5lXFxcIikpLnRwJGNhbGwoW3Z0LnRwJGNhbGwoX29yZDJ5bWQoZS4kZGF5cykpLG5ldyB4dChuLHMsbyxlLiRtaWNybyx0aGlzLiR0emluZm8pXSk7dGhyb3cgbmV3IE0oXFxcInJlc3VsdCBvdXQgb2YgcmFuZ2VcXFwiKX0sbmIkc3VidHJhY3QodCl7aWYoISh0IGluc3RhbmNlb2YgTnQpKXJldHVybiB0IGluc3RhbmNlb2Ygd3Q/dGhpcy5uYiRhZGQodC5uYiRuZWdhdGl2ZSgpKTpiO2NvbnN0IG49dGhpcy4kdG9PcmRpbmFsKCksaT10LiR0b09yZGluYWwoKSxzPXRoaXMuJHNlYys2MCp0aGlzLiRtaW4rMzYwMCp0aGlzLiRob3VyLG89dC4kc2VjKzYwKnQuJG1pbiszNjAwKnQuJGhvdXIsYT1uZXcgd3Qobi1pLHMtbyx0aGlzLiRtaWNyby10LiRtaWNybyk7aWYodGhpcy4kdHppbmZvPT09dC4kdHppbmZvKXJldHVybiBhO2NvbnN0ICQ9cih0aGlzLnRwJGdldGF0dHIoVSkpLGM9cih0LnRwJGdldGF0dHIoVSkpO2lmKGUoJCxjLFxcXCJFcVxcXCIpKXJldHVybiBhO2lmKCQ9PT15fHxjPT09eSl0aHJvdyBuZXcgeihcXFwiY2Fubm90IG1peCBuYWl2ZSBhbmQgdGltZXpvbmUtYXdhcmUgdGltZVxcXCIpO3JldHVybiBhLm5iJGFkZChjKS5uYiRzdWJ0cmFjdCgkKX0sbmIkcmVmbGVjdGVkX3N1YnRyYWN0Om51bGwsdHAkaGFzaCgpe2lmKC0xPT09dGhpcy4kaGFzaGNvZGUpe2NvbnN0IHQ9dGhpcy4kZm9sZD9yKHRoaXMudHAkZ2V0YXR0cihKKSxbXSxbXFxcImZvbGRcXFwiLFddKTp0aGlzLGU9cih0LnRwJGdldGF0dHIoVSkpO2lmKGU9PT15KXRoaXMuJGhhc2hjb2RlPXUodC4kZ2V0U3RhdGUoKVswXSk7ZWxzZXtjb25zdCB0PV95bWQyb3JkKHRoaXMuJHllYXIsdGhpcy4kbW9udGgsdGhpcy4kZGF5KSxuPTM2MDAqdGhpcy4kaG91cis2MCp0aGlzLiRtaW4rdGhpcy4kc2VjO3RoaXMuJGhhc2hjb2RlPXUobmV3IHd0KHQsbix0aGlzLiRtaWNybykubmIkc3VidHJhY3QoZSkpfX1yZXR1cm4gdGhpcy4kaGFzaGNvZGV9fSxtZXRob2RzOntkYXRlOnskbWV0aDpmdW5jdGlvbiBfZGF0ZSgpe3JldHVybiBuZXcgdnQodGhpcy4keWVhcix0aGlzLiRtb250aCx0aGlzLiRkYXkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gZGF0ZSBvYmplY3Qgd2l0aCBzYW1lIHllYXIsIG1vbnRoIGFuZCBkYXkuXFxcIn0sdGltZTp7JG1ldGg6ZnVuY3Rpb24gX3RpbWUoKXtyZXR1cm4gbmV3IHh0KHRoaXMuJGhvdXIsdGhpcy4kbWluLHRoaXMuJHNlYyx0aGlzLiRtaWNybyx5LHRoaXMuJGZvbGQpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gdGltZSBvYmplY3Qgd2l0aCBzYW1lIHRpbWUgYnV0IHdpdGggdHppbmZvPU5vbmUuXFxcIn0sdGltZXR6OnskbWV0aDpmdW5jdGlvbiB0aW1ldHooKXtyZXR1cm4gbmV3IHh0KHRoaXMuJGhvdXIsdGhpcy4kbWluLHRoaXMuJHNlYyx0aGlzLiRtaWNybyx0aGlzLiR0emluZm8sdGhpcy4kZm9sZCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiB0aW1lIG9iamVjdCB3aXRoIHNhbWUgdGltZSBhbmQgdHppbmZvLlxcXCJ9LGN0aW1lOnskbWV0aDpmdW5jdGlvbiBjdGltZSgpe2NvbnN0IHQ9dGhpcy4kdG9PcmRpbmFsKCklN3x8NyxlPWZ0W3RdLG49bHRbdGhpcy4kbW9udGhdO3JldHVybiBuZXcgdyhgJHtlfSAke259ICR7X2QodGhpcy4kZGF5LFxcXCIgXFxcIiwyKX0gJHtfZCh0aGlzLiRob3VyLFxcXCIwXFxcIiwyKX06JHtfZCh0aGlzLiRtaW4sXFxcIjBcXFwiLDIpfToke19kKHRoaXMuJHNlYyxcXFwiMFxcXCIsMil9ICR7X2QodGhpcy4keWVhcixcXFwiMFxcXCIsNCl9YCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBjdGltZSgpIHN0eWxlIHN0cmluZy5cXFwifSx0aW1ldHVwbGU6eyRtZXRoOmZ1bmN0aW9uIHRpbWV0dXBsZSgpe2xldCBlPXIodGhpcy50cCRnZXRhdHRyKEYpKTtyZXR1cm4gZT1lPT09eT8tMTp0KGUpPzE6MCxfYnVpbGRfc3RydWN0X3RpbWUodGhpcy4keWVhcix0aGlzLiRtb250aCx0aGlzLiRkYXksdGhpcy4kaG91cix0aGlzLiRtaW4sdGhpcy4kc2VjLGUpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gdGltZSB0dXBsZSwgY29tcGF0aWJsZSB3aXRoIHRpbWUubG9jYWx0aW1lKCkuXFxcIn0sdGltZXN0YW1wOnskbWV0aDpmdW5jdGlvbiB0aW1lc3RhbXAoKXtpZih0aGlzLiR0emluZm89PT15KXtsZXQgdD10aGlzLiRta1RpbWUoKTtyZXR1cm4gdD1JKHQpLG5ldyBkKHQrdGhpcy4kbWljcm8vMWU2KX17Y29uc3QgdD1xKHRoaXMsa3QsXFxcIlN1YlxcXCIpO3JldHVybiBuZXcgZCgoKDg2NDAwKnQuJGRheXMrdC4kc2VjcykqMTAqKjYrdC4kbWljcm8pLzEwKio2KX19LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBQT1NJWCB0aW1lc3RhbXAgYXMgZmxvYXQuXFxcIn0sdXRjdGltZXR1cGxlOnskbWV0aDpmdW5jdGlvbiB1dGN0aW1ldHVwbGUoKXtjb25zdCBlPXIodGhpcy50cCRnZXRhdHRyKFUpKTtsZXQgbj10aGlzO3JldHVybiB0KGUpJiYobj1xKG4sZSxcXFwiU3ViXFxcIikpLF9idWlsZF9zdHJ1Y3RfdGltZShuLiR5ZWFyLG4uJG1vbnRoLG4uJGRheSxuLiRob3VyLG4uJG1pbixuLiRzZWMsMCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBVVEMgdGltZSB0dXBsZSwgY29tcGF0aWJsZSB3aXRoIHRpbWUubG9jYWx0aW1lKCkuXFxcIn0saXNvZm9ybWF0OnskbWV0aDpmdW5jdGlvbiBpc29mb3JtYXQodCxlKXtpZighayh0KSl0aHJvdyBuZXcgeihcXFwic2VwIG11c3QgYmUgc3RyLCBub3QgXFxcIitjKHQpKTtsZXQgbj1gJHtfZCh0aGlzLiR5ZWFyLFxcXCIwXFxcIiw0KX0tJHtfZCh0aGlzLiRtb250aCxcXFwiMFxcXCIsMil9LSR7X2QodGhpcy4kZGF5LFxcXCIwXFxcIiwyKX1gK3QudG9TdHJpbmcoKTtuKz1fZm9ybWF0X3RpbWUodGhpcy4kaG91cix0aGlzLiRtaW4sdGhpcy4kc2VjLHRoaXMuJG1pY3JvLGUpO2NvbnN0IGk9X2Zvcm1hdF9vZmZzZXQocih0aGlzLnRwJGdldGF0dHIoVSkpKTtyZXR1cm4gaSYmKG4rPWkpLG5ldyB3KG4pfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInNlcFxcXCIsXFxcInRpbWVzcGVjXFxcIl0sRGVmYXVsdHM6W25ldyB3KFxcXCJUXFxcIiksQ119LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiW3NlcF0gLT4gc3RyaW5nIGluIElTTyA4NjAxIGZvcm1hdCwgWVlZWS1NTS1ERFRbSEhbOk1NWzpTU1subW1tW3V1dV1dXV1dWytISDpNTV0uXFxcXG5zZXAgaXMgdXNlZCB0byBzZXBhcmF0ZSB0aGUgeWVhciBmcm9tIHRoZSB0aW1lLCBhbmQgZGVmYXVsdHMgdG8gJ1QnLlxcXFxudGltZXNwZWMgc3BlY2lmaWVzIHdoYXQgY29tcG9uZW50cyBvZiB0aGUgdGltZSB0byBpbmNsdWRlIChhbGxvd2VkIHZhbHVlcyBhcmUgJ2F1dG8nLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJywgJ21pbGxpc2Vjb25kcycsIGFuZCAnbWljcm9zZWNvbmRzJykuXFxcXG5cXFwifSx1dGNvZmZzZXQ6eyRtZXRoOmZ1bmN0aW9uIHV0Y29mZnNldCgpe2lmKHRoaXMuJHR6aW5mbz09PXkpcmV0dXJuIHk7Y29uc3QgdD10aGlzLiR0emluZm8udHAkZ2V0YXR0cihVKSxlPXIodCxbdGhpc10pO3JldHVybiBfY2hlY2tfdXRjX29mZnNldChcXFwidXRjb2Zmc2V0XFxcIixlKSxlfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gc2VsZi50emluZm8udXRjb2Zmc2V0KHNlbGYpLlxcXCJ9LHR6bmFtZTp7JG1ldGg6ZnVuY3Rpb24gdHpuYW1lKCl7aWYodGhpcy4kdHppbmZvPT09eSlyZXR1cm4geTtjb25zdCB0PXRoaXMuJHR6aW5mby50cCRnZXRhdHRyKFkpLGU9cih0LFt0aGlzXSk7cmV0dXJuIF9jaGVja190em5hbWUoZSksZX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHNlbGYudHppbmZvLnR6bmFtZShzZWxmKS5cXFwifSxkc3Q6eyRtZXRoOmZ1bmN0aW9uIGRzdCgpe2lmKHRoaXMuJHR6aW5mbz09PXkpcmV0dXJuIHk7Y29uc3QgdD10aGlzLiR0emluZm8udHAkZ2V0YXR0cihGKSxlPXIodCxbdGhpc10pO3JldHVybiBfY2hlY2tfdXRjX29mZnNldChcXFwiZHN0XFxcIixlKSxlfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gc2VsZi50emluZm8uZHN0KHNlbGYpLlxcXCJ9LHJlcGxhY2U6eyRtZXRoOmZ1bmN0aW9uIHJlcGxhY2UodCxlKXttKFxcXCJyZXBsYWNlXFxcIix0LDAsOCk7bGV0W24saSxzLG8scixhLCQsYyxoXT1sKFxcXCJyZXBsYWNlXFxcIixbXFxcInllYXJcXFwiLFxcXCJtb250aFxcXCIsXFxcImRheVxcXCIsXFxcImhvdXJcXFwiLFxcXCJtaW51dGVcXFwiLFxcXCJzZWNvbmRcXFwiLFxcXCJtaWNyb3NlY29uZFxcXCIsXFxcInR6aW5mb1xcXCIsXFxcImZvbGRcXFwiXSx0LGUsW3kseSx5LHkseSx5LHksZyx5XSk7cmV0dXJuIG49PT15JiYobj1uZXcgZih0aGlzLiR5ZWFyKSksaT09PXkmJihpPW5ldyBmKHRoaXMuJG1vbnRoKSkscz09PXkmJihzPW5ldyBmKHRoaXMuJGRheSkpLG89PT15JiYobz1uZXcgZih0aGlzLiRob3VyKSkscj09PXkmJihyPW5ldyBmKHRoaXMuJG1pbikpLGE9PT15JiYoYT1uZXcgZih0aGlzLiRzZWMpKSwkPT09eSYmKCQ9bmV3IGYodGhpcy4kbWljcm8pKSxjPT09ZyYmKGM9dGhpcy4kdHppbmZvKSxoPT09eSYmKGg9bmV3IGYodGhpcy4kZm9sZCkpLHRoaXMub2IkdHlwZS50cCRjYWxsKFtuLGkscyxvLHIsYSwkLGNdLFtcXFwiZm9sZFxcXCIsaF0pfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBkYXRldGltZSB3aXRoIG5ldyBzcGVjaWZpZWQgZmllbGRzLlxcXCJ9LGFzdGltZXpvbmU6eyRtZXRoOmZ1bmN0aW9uIGFzdGltZXpvbmUodCl7aWYodD09PXkpdD10aGlzLiRsb2NhbFRpbWV6b25lKCk7ZWxzZSBpZighKHQgaW5zdGFuY2VvZiBNdCkpdGhyb3cgbmV3IHooXFxcInR6IGFyZ3VtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgdHppbmZvXFxcIik7bGV0IGUsbj10aGlzLiR0emluZm87aWYobj09PXk/KG49dGhpcy4kbG9jYWxUaW1lem9uZSgpLGU9cihuLnRwJGdldGF0dHIoVSksW3RoaXNdKSk6KGU9cihuLnRwJGdldGF0dHIoVSksW3RoaXNdKSxlPT09eSYmKG49cih0aGlzLnRwJGdldGF0dHIoSiksW10sW1xcXCJ0emluZm9cXFwiLHldKS4kbG9jYWxUaW1lem9uZSgpLGU9cihuLnRwJGdldGF0dHIoVSksW3RoaXNdKSkpLHQ9PT1uKXJldHVybiB0aGlzO2NvbnN0IGk9cih0aGlzLm5iJHN1YnRyYWN0KGUpLnRwJGdldGF0dHIoSiksW10sW1xcXCJ0emluZm9cXFwiLHRdKTtyZXR1cm4gdC50cCRnZXRhdHRyKFApLnRwJGNhbGwoW2ldKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ0elxcXCJdLERlZmF1bHRzOlt5XX0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJ0eiAtPiBjb252ZXJ0IHRvIGxvY2FsIHRpbWUgaW4gbmV3IHRpbWV6b25lIHR6XFxcXG5cXFwifSxfX3JlZHVjZV9leF9fOnskbWV0aCh0KXtyZXR1cm4gbmV3IHAoW3RoaXMub2IkdHlwZSxuZXcgcCh0aGlzLiRnZXRTdGF0ZShSKHQpKSldKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiX19yZWR1Y2VfZXhfXyhwcm90bykgLT4gKGNscywgc3RhdGUpXFxcIn0sX19yZWR1Y2VfXzp7JG1ldGgoKXtyZXR1cm4gdGhpcy50cCRnZXRhdHRyKG5ldyB3KFxcXCJfX3JlZHVjZV9leF9fXFxcIikpLnRwJGNhbGwoW25ldyBmKDIpXSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIl9fcmVkdWNlX18oKSAtPiAoY2xzLCBzdGF0ZSlcXFwifX0sY2xhc3NtZXRob2RzOntub3c6eyRtZXRoOmZ1bmN0aW9uIG5vdyh0KXtjb25zdCBlPSQudGltZS50cCRjYWxsKFtdKTtyZXR1cm4gdGhpcy50cCRnZXRhdHRyKEIpLnRwJGNhbGwoW2UsdF0pfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInR6XFxcIl0sRGVmYXVsdHM6W3ldfSwkdGV4dHNpZzpcXFwiKCR0eXBlLCAvLCB0ej1Ob25lKVxcXCIsJGRvYzpcXFwiUmV0dXJucyBuZXcgZGF0ZXRpbWUgb2JqZWN0IHJlcHJlc2VudGluZyBjdXJyZW50IHRpbWUgbG9jYWwgdG8gdHouXFxcXG5cXFxcbiAgdHpcXFxcbiAgICBUaW1lem9uZSBvYmplY3QuXFxcXG5cXFxcbklmIG5vIHR6IGlzIHNwZWNpZmllZCwgdXNlcyBsb2NhbCB0aW1lem9uZS5cXFwifSx1dGNub3c6eyRtZXRoOmZ1bmN0aW9uIHV0Y25vdygpe2NvbnN0IHQ9JC50aW1lLnRwJGNhbGwoW10pO3JldHVybiB0aGlzLnRwJGdldGF0dHIoTCkudHAkY2FsbChbdF0pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gYSBuZXcgZGF0ZXRpbWUgcmVwcmVzZW50aW5nIFVUQyBkYXkgYW5kIHRpbWUuXFxcIn0sZnJvbXRpbWVzdGFtcDp7JG1ldGg6ZnVuY3Rpb24gZnJvbXRpbWVzdGFtcCh0LGUpe3JldHVybiBfY2hlY2tfdHppbmZvX2FyZyhlKSx0aGlzLnByb3RvdHlwZS4kZnJvbXRpbWVzdGFtcC5jYWxsKHRoaXMsdCxlIT09eSxlKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ0aW1lc3RhbXBcXFwiLFxcXCJ0elxcXCJdLERlZmF1bHRzOlt5XX0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJ0aW1lc3RhbXBbLCB0el0gLT4gdHoncyBsb2NhbCB0aW1lIGZyb20gUE9TSVggdGltZXN0YW1wLlxcXCJ9LHV0Y2Zyb210aW1lc3RhbXA6eyRtZXRoOmZ1bmN0aW9uIHV0Y2Zyb210aW1lc3RhbXAodCl7cmV0dXJuIHRoaXMucHJvdG90eXBlLiRmcm9tdGltZXN0YW1wLmNhbGwodGhpcyx0LCEwLHkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJDb25zdHJ1Y3QgYSBuYWl2ZSBVVEMgZGF0ZXRpbWUgZnJvbSBhIFBPU0lYIHRpbWVzdGFtcC5cXFwifSxzdHJwdGltZTp7JG1ldGg6ZnVuY3Rpb24gc3RycHRpbWUodCxlKXtyZXR1cm4gbnVsbD09PW90P1NrLm1pc2NldmFsLmNoYWluKFNrLmltcG9ydE1vZHVsZShcXFwiX3N0cnB0aW1lXFxcIiwhMSwhMCksKG49PihvdD1uLnRwJGdldGF0dHIobmV3IHcoXFxcIl9zdHJwdGltZV9kYXRldGltZVxcXCIpKSxvdC50cCRjYWxsKFt0aGlzLHQsZV0pKSkpOm90LnRwJGNhbGwoW3RoaXMsdCxlXSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJzdHJpbmcsIGZvcm1hdCAtPiBuZXcgZGF0ZXRpbWUgcGFyc2VkIGZyb20gYSBzdHJpbmcgKGxpa2UgdGltZS5zdHJwdGltZSgpKS5cXFwifSxjb21iaW5lOnskbWV0aDpmdW5jdGlvbiBjb21iaW5lKHQsZSxuKXtpZighKHQgaW5zdGFuY2VvZiB2dCkpdGhyb3cgbmV3IHooXFxcImRhdGUgYXJndW1lbnQgbXVzdCBiZSBhIGRhdGUgaW5zdGFuY2VcXFwiKTtpZighKGUgaW5zdGFuY2VvZiB4dCkpdGhyb3cgbmV3IHooXFxcInRpbWUgYXJndW1lbnQgbXVzdCBiZSBhIHRpbWUgaW5zdGFuY2VcXFwiKTtuPT09ZyYmKG49ZS4kdHppbmZvKTtjb25zdCBpPVt0LiR5ZWFyLHQuJG1vbnRoLHQuJGRheSxlLiRob3VyLGUuJG1pbixlLiRzZWMsZS4kbWljcm9dLm1hcCgodD0+bmV3IGYodCkpKTtyZXR1cm4gaS5wdXNoKG4pLHRoaXMudHAkY2FsbChpLFtcXFwiZm9sZFxcXCIsbmV3IGYoZS4kZm9sZCldKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJkYXRlXFxcIixcXFwidGltZVxcXCIsXFxcInR6aW5mb1xcXCJdLERlZmF1bHRzOltnXX0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJkYXRlLCB0aW1lIC0+IGRhdGV0aW1lIHdpdGggc2FtZSBkYXRlIGFuZCB0aW1lIGZpZWxkc1xcXCJ9LGZyb21pc29mb3JtYXQ6eyRtZXRoOmZ1bmN0aW9uIGZyb21pc29mb3JtYXQodCl7aWYoIWsodCkpdGhyb3cgbmV3IHooXFxcImZyb21pc29mb3JtYXQ6IGFyZ3VtZW50IG11c3QgYmUgc3RyXFxcIik7Y29uc3QgZT0odD10LnRvU3RyaW5nKCkpLnNsaWNlKDAsMTApLG49dC5zbGljZSgxMSk7bGV0IGksczt0cnl7aT1fcGFyc2VfaXNvZm9ybWF0X2RhdGUoZSl9Y2F0Y2gobyl7dGhyb3cgbmV3IHYoXFxcIkludmFsaWQgaXNvZm9ybWF0IHN0cmluZzogJ1xcXCIrdCtcXFwiJ1xcXCIpfWlmKG4pdHJ5e3M9X3BhcnNlX2lzb2Zvcm1hdF90aW1lKG4pfWNhdGNoKG8pe3Rocm93IG5ldyB2KFxcXCJJbnZhbGlkIGlzb2Zvcm1hdCBzdHJpbmc6ICdcXFwiK3QrXFxcIidcXFwiKX1lbHNlIHM9W1csVyxXLFcseV07cmV0dXJuIHRoaXMudHAkY2FsbChpLmNvbmNhdChzKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcInN0cmluZyAtPiBkYXRldGltZSBmcm9tIGRhdGV0aW1lLmlzb2Zvcm1hdCgpIG91dHB1dFxcXCJ9fSxnZXRzZXRzOntob3VyOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJGhvdXIpfX0sbWludXRlOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJG1pbil9fSxzZWNvbmQ6eyRnZXQoKXtyZXR1cm4gbmV3IGYodGhpcy4kc2VjKX19LG1pY3Jvc2Vjb25kOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJG1pY3JvKX19LHR6aW5mbzp7JGdldCgpe3JldHVybiB0aGlzLiR0emluZm99fSxmb2xkOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJGZvbGQpfX19LHByb3RvOnskY21wKG4saSl7Y29uc3Qgcz10aGlzLiR0emluZm8sbz1uLiR0emluZm87bGV0IGEsJCxjO2lmKGE9JD15LHM9PT1vKWM9ITA7ZWxzZXtpZihhPXIodGhpcy50cCRnZXRhdHRyKFUpKSwkPXIobi50cCRnZXRhdHRyKFUpKSxcXFwiRXFcXFwiPT09aXx8XFxcIk5vdEVxXFxcIj09PWkpe2NvbnN0IHQ9cih0aGlzLnRwJGdldGF0dHIoSiksW10sW1xcXCJmb2xkXFxcIixuZXcgZihOdW1iZXIoIXRoaXMuJGZvbGQpKV0pO2lmKGUoYSxyKHQudHAkZ2V0YXR0cihVKSksXFxcIk5vdEVxXFxcIikpcmV0dXJuIDI7Y29uc3QgaT1yKG4udHAkZ2V0YXR0cihKKSxbXSxbXFxcImZvbGRcXFwiLG5ldyBmKE51bWJlcighbi4kZm9sZCkpXSk7aWYoZSgkLHIoaS50cCRnZXRhdHRyKFUpKSxcXFwiTm90RXFcXFwiKSlyZXR1cm4gMn1jPWUoYSwkLFxcXCJFcVxcXCIpfWlmKGMpcmV0dXJuIF9jbXAoW3RoaXMuJHllYXIsdGhpcy4kbW9udGgsdGhpcy4kZGF5LHRoaXMuJGhvdXIsdGhpcy4kbWluLHRoaXMuJHNlYyx0aGlzLiRtaWNyb10sW24uJHllYXIsbi4kbW9udGgsbi4kZGF5LG4uJGhvdXIsbi4kbWluLG4uJHNlYyxuLiRtaWNyb10pO2lmKGE9PT15fHwkPT09eSl7aWYoXFxcIkVxXFxcIj09PWl8fFxcXCJOb3RFcVxcXCI9PT1pKXJldHVybiAyO3Rocm93IG5ldyB6KFxcXCJjYW5ub3QgY29tcGFyZSBuYWl2ZSBhbmQgYXdhcmUgZGF0ZXRpbWVzXFxcIil9Y29uc3QgaD10aGlzLm5iJHN1YnRyYWN0KG4pO3JldHVybiBoLiRkYXlzPDA/LTE6dChoKT8xOjB9LCRta1RpbWUoKXtjb25zdCB0PW5ldyBOdCgxOTcwLDEsMSksZT10aGlzLm5iJHN1YnRyYWN0KHQpLm5iJGZsb29yX2RpdmlkZSh5dCk7ZnVuY3Rpb24gbG9jYWwoZSl7Y29uc3RbbixpLHMsbyxyLGFdPSQubG9jYWx0aW1lLnRwJGNhbGwoW2VdKS52O3JldHVybiBOdC50cCRjYWxsKFtuLGkscyxvLHIsYV0pLm5iJHN1YnRyYWN0KHQpLm5iJGZsb29yX2RpdmlkZSh5dCl9bGV0IG4saSxzPWxvY2FsKGUpLm5iJHN1YnRyYWN0KGUpLG89ZS5uYiRzdWJ0cmFjdChzKSxyPWxvY2FsKG8pO2lmKHIub2IkZXEoZSkpe2lmKG49by5uYiRhZGQoW25ldyBmKC04NjQwMCksbmV3IGYoODY0MDApXVt0aGlzLiRmb2xkXSksaT1sb2NhbChuKS5uYiRzdWJ0cmFjdChuKSxzLm9iJGVxKGkpKXJldHVybiBvfWVsc2UgaT1yLm5iJHN1YnRyYWN0KG8pO249ZS5uYiRzdWJ0cmFjdChpKTtpZihsb2NhbChuKS5vYiRlcShlKSlyZXR1cm4gbjtpZihyLm9iJGVxKGUpKXJldHVybiBvO2NvbnN0IGE9by5vYiRnZShuKT9vOm47cmV0dXJuW2Esbz09PWE/bjpvXVt0aGlzLiRmb2xkXX0sJGZyb210aW1lc3RhbXAodCxuLHMpe2xldCBvO2lmKCFOKHQpKXRocm93IG5ldyB6KFxcXCJhIG51bWJlciBpcyByZXF1aXJlZCwgKGdvdCAnXFxcIitjKHQpK1xcXCInXFxcIik7W28sdF09bW9kZih0KTtsZXQgYT1pbnRSb3VuZChxKG8sbnQsXFxcIk11bHRcXFwiKSk7YT1hLnYsdD10LnYsYT49MWU2Pyh0Kz0xLGEtPTFlNik6YTwwJiYodC09MSxhKz0xZTYpLHQ9bmV3IGYodCksTnVtYmVyLmlzSW50ZWdlcihhKXx8KGE9TWF0aC50cnVuYyhhKSksYT1uZXcgZihhKTtjb25zdCBoPW4/JC5nbXRpbWU6JC5sb2NhbHRpbWU7ZnVuY3Rpb24gY29udmVydGVyKHQpe3JldHVybiBoLnRwJGNhbGwoW3RdKS52fWxldFttLHUsbCxkLF8scF09Y29udmVydGVyKHQpO3A9bmV3IGYoTWF0aC5taW4oaShwKSw1OSkpO2xldCBnPXIodGhpcyxbbSx1LGwsZCxfLHAsYSxzXSk7aWYocz09PXkpe2NvbnN0IG49ODY0MDA7W20sdSxsLGQsXyxwXT1jb252ZXJ0ZXIocSh0LG5ldyBmKG4pLFxcXCJTdWJcXFwiKSk7Y29uc3QgaT1yKHRoaXMsW20sdSxsLGQsXyxwLGEsc10pLG89cShxKGcsaSxcXFwiU3ViXFxcIiksbmV3IHd0KDAsbiksXFxcIlN1YlxcXCIpO2lmKG8uJGRheXM8MCl7W20sdSxsLGQsXyxwXT1jb252ZXJ0ZXIocSh0LHEobyx5dCxcXFwiRmxvb3JEaXZcXFwiKSxcXFwiQWRkXFxcIikpO2NvbnN0IG49cih0aGlzLFttLHUsbCxkLF8scCxhLHNdKTtlKG4sZyxcXFwiRXFcXFwiKSYmKGcuJGZvbGQ9MSl9fWVsc2UgZz1yKHMudHAkZ2V0YXR0cihuZXcgdyhcXFwiZnJvbXV0Y1xcXCIpKSxbZ10pO3JldHVybiBnfSwkbG9jYWxUaW1lem9uZSgpe2xldCB0O3Q9dGhpcy4kdHppbmZvPT09eT90aGlzLiRta1RpbWUoKTp0aGlzLm5iJHN1YnRyYWN0KGt0KS5uYiRmbG9vcl9kaXZpZGUoeXQpO2NvbnN0IGU9JC5sb2NhbHRpbWUudHAkY2FsbChbdF0pLG49KE50LnRwJGNhbGwoZS52LnNsaWNlKDAsNikpLGUudHAkZ2V0YXR0cihuZXcgdyhcXFwidG1fZ210b2ZmXFxcIikpKSxpPWUudHAkZ2V0YXR0cihuZXcgdyhcXFwidG1fem9uZVxcXCIpKTtyZXR1cm4gbmV3IFN0KHd0LnRwJGNhbGwoW1csbl0pLGkpfSwkZ2V0U3RhdGUodD0zKXtsZXRbZSxuXT0kZGl2TW9kKHRoaXMuJHllYXIsMjU2KSxbaSxzXT0kZGl2TW9kKHRoaXMuJG1pY3JvLDI1NiksW28scl09JGRpdk1vZChpLDI1NiksYT10aGlzLiRtb250aDt0aGlzLiRmb2xkJiZ0PjMmJihhKz0xMjgpO2NvbnN0ICQ9bmV3IF8oW2UsbixhLHRoaXMuJGRheSx0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsbyxyLHNdKTtyZXR1cm4gdGhpcy4kdHppbmZvPT09eT9bJF06WyQsdGhpcy4kdHppbmZvXX0sJHNldFN0YXRlKHQsZSl7Y29uc3RbbixpLHMsbyxyLGEsJCxjLGgsbV09dDtzPjEyNz8odGhpcy4kZm9sZD0xLHRoaXMuJG1vbnRoPXMtMTI4KToodGhpcy4kZm9sZD0wLHRoaXMuJG1vbnRoPXMpLHRoaXMuJHllYXI9MjU2Km4raSx0aGlzLiRkYXk9byx0aGlzLiRob3VyPXIsdGhpcy4kbWluPWEsdGhpcy4kc2VjPSQsdGhpcy4kbWljcm89KGM8PDh8aCk8PDh8bSx0aGlzLiR0emluZm89ZX19fSk7ZnVuY3Rpb24gX2lzb3dlZWsxbW9uZGF5KHQpe2NvbnN0IGU9X3ltZDJvcmQodCwxLDEpLG49KGUrNiklNztsZXQgaT1lLW47cmV0dXJuIG4+MyYmKGkrPTcpLGl9TnQucHJvdG90eXBlLm1pbj1uZXcgTnQoMSwxLDEpLE50LnByb3RvdHlwZS5tYXg9bmV3IE50KDk5OTksMTIsMzEsMjMsNTksNTksOTk5OTk5KSxOdC5wcm90b3R5cGUucmVzb2x1dGlvbj1uZXcgd3QoMCwwLDEpO2NvbnN0IFN0PUUudGltZXpvbmU9aChcXFwiZGF0ZXRpbWUudGltZXpvbmVcXFwiLHtiYXNlOk10LGNvbnN0cnVjdG9yOmZ1bmN0aW9uIHRpbWV6b25lKHQsbil7aWYodGhpcy4kb2Zmc2V0PXQsdGhpcy4kbmFtZT1ufHx5LCFlKHRoaXMuJG1pbm9mZnNldCx0LFxcXCJMdEVcXFwiKXx8IWUodGhpcy4kbWF4b2Zmc2V0LHQsXFxcIkd0RVxcXCIpKXRocm93IG5ldyB2KFxcXCJvZmZzZXQgbXVzdCBiZSBhIHRpbWVkZWx0YSBzdHJpY3RseSBiZXR3ZWVuIC10aW1lZGVsdGEoaG91cnM9MjQpIGFuZCB0aW1lZGVsdGEoaG91cnM9MjQpLlxcXCIpfSxzbG90czp7dHAkbmV3KGUsbil7bGV0W2ksc109bChcXFwidGltZXpvbmVcXFwiLFtcXFwib2Zmc2V0XFxcIixcXFwibmFtZVxcXCJdLGUsbixbbnVsbF0pO2lmKCEoaSBpbnN0YW5jZW9mIHd0KSl0aHJvdyBuZXcgeihcXFwib2Zmc2V0IG11c3QgYmUgYSB0aW1lZGVsdGFcXFwiKTtpZihudWxsPT09cyl7aWYoIXQoaSkpcmV0dXJuIHRoaXMudXRjO3M9eX1lbHNlIGlmKCFrKHMpKXRocm93IG5ldyB6KFxcXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZih0aGlzPT09U3QucHJvdG90eXBlKXJldHVybiBuZXcgU3QoaSxzKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gU3QuY2FsbCh0LGkscyksdH19LHRwJHJpY2hjb21wYXJlKHQsbil7aWYoISh0IGluc3RhbmNlb2YgU3QpKXJldHVybiBiO2NvbnN0IGk9ZSh0aGlzLiRvZmZzZXQsdC4kb2Zmc2V0LFxcXCJFcVxcXCIpO3JldHVyblxcXCJOb3RFcVxcXCI9PT1uPyFpOlxcXCJFcVxcXCI9PT1ufHxpJiZvKG4pP2k6Yn0sJHIoKXtyZXR1cm4gdGhpcz09PXRoaXMudXRjP25ldyB3KFxcXCJkYXRldGltZS50aW1lem9uZS51dGNcXFwiKTp0aGlzLiRuYW1lPT09eT9uZXcgdyhgJHt0aGlzLnRwJG5hbWV9KCR7cyh0aGlzLiRvZmZzZXQpfSlgKTpuZXcgdyhgJHt0aGlzLnRwJG5hbWV9KCR7cyh0aGlzLiRvZmZzZXQpfSwgJHtzKHRoaXMuJG5hbWUpfSlgKX0sdHAkc3RyKCl7cmV0dXJuIHRoaXMudHAkZ2V0YXR0cihZKS50cCRjYWxsKFt5XSl9LHRwJGhhc2goKXtyZXR1cm4gdSh0aGlzLiRvZmZzZXQpfX0sbWV0aG9kczp7dHpuYW1lOnskbWV0aDpmdW5jdGlvbiB0em5hbWUodCl7aWYodCBpbnN0YW5jZW9mIE50fHx0PT09eSlyZXR1cm4gdGhpcy4kbmFtZT09PXk/dGhpcy4kbmFtZUZyb21PZmYodGhpcy4kb2Zmc2V0KTp0aGlzLiRuYW1lO3Rocm93IG5ldyB6KFxcXCJ0em5hbWUoKSBhcmd1bWVudCBtdXN0IGJlIGEgZGF0ZXRpbWUgaW5zdGFuY2Ugb3IgTm9uZVxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJJZiBuYW1lIGlzIHNwZWNpZmllZCB3aGVuIHRpbWV6b25lIGlzIGNyZWF0ZWQsIHJldHVybnMgdGhlIG5hbWUuICBPdGhlcndpc2UgcmV0dXJucyBvZmZzZXQgYXMgJ1VUQygrfC0pSEg6TU0nLlxcXCJ9LHV0Y29mZnNldDp7JG1ldGg6ZnVuY3Rpb24gdXRjb2Zmc2V0KHQpe2lmKHQgaW5zdGFuY2VvZiBOdHx8dD09PXkpcmV0dXJuIHRoaXMuJG9mZnNldDt0aHJvdyBuZXcgeihcXFwidXRjb2Zmc2V0KCkgYXJndW1lbnQgbXVzdCBiZSBhIGRhdGV0aW1lIGluc3RhbmNlIG9yIE5vbmVcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIGZpeGVkIG9mZnNldC5cXFwifSxkc3Q6eyRtZXRoOmZ1bmN0aW9uIGRzdCh0KXtpZih0IGluc3RhbmNlb2YgTnR8fHQ9PT15KXJldHVybiB5O3Rocm93IG5ldyB6KFxcXCJkc3QoKSBhcmd1bWVudCBtdXN0IGJlIGEgZGF0ZXRpbWUgaW5zdGFuY2Ugb3IgTm9uZVxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gTm9uZS5cXFwifSxmcm9tdXRjOnskbWV0aDpmdW5jdGlvbiBmcm9tdXRjKHQpe2lmKHQgaW5zdGFuY2VvZiBOdCl7aWYodC4kdHppbmZvIT09dGhpcyl0aHJvdyBuZXcgdihcXFwiZnJvbXV0YzogZHQudHppbmZvIGlzIG5vdCBzZWxmXFxcIik7cmV0dXJuIHEodCx0aGlzLiRvZmZzZXQsXFxcIkFkZFxcXCIpfXRocm93IG5ldyB6KFxcXCJmcm9tdXRjKCkgYXJndW1lbnQgbXVzdCBiZSBhIGRhdGV0aW1lIGluc3RhbmNlIG9yIE5vbmVcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiZGF0ZXRpbWUgaW4gVVRDIC0+IGRhdGV0aW1lIGluIGxvY2FsIHRpbWUuXFxcIn0sX19nZXRpbml0YXJnc19fOnskbWV0aCgpe3JldHVybiB0aGlzLiRuYW1lPT09eT9uZXcgcChbdGhpcy4kb2Zmc2V0XSk6bmV3IHAoW3RoaXMuJG9mZnNldCx0aGlzLiRuYW1lXSl9LCRmbGFnczp7Tm9BcmdzOiEwfX19LHByb3RvOnskbWF4b2Zmc2V0Om5ldyB3dCgwLDg2Mzk5LDk5OTk5OSksJG1pbm9mZnNldDpuZXcgd3QoLTEsMCwxKSwkbmFtZUZyb21PZmYobil7aWYoIXQobikpcmV0dXJuIG5ldyB3KFxcXCJVVENcXFwiKTtsZXQgaSxzLG8scixhLCQ7cmV0dXJuIGUobixidCxcXFwiTHRcXFwiKT8oaT1cXFwiLVxcXCIsbj1uLm5iJG5lZ2F0aXZlKCkpOmk9XFxcIitcXFwiLFtzLG9dPXB5RGl2TW9kKG4scHQpLFtyLG9dPXB5RGl2TW9kKG8sZ3QpLGE9by4kc2VjcywkPW8uJG1pY3JvLG5ldyB3KCQ/YFVUQyR7aX0ke19kKHMpfToke19kKHIpfToke19kKGEpfS4ke19kKCQsXFxcIjBcXFwiLDYpfWA6YT9gVVRDJHtpfSR7X2Qocyl9OiR7X2Qocil9OiR7X2QoYSl9YDpgVVRDJHtpfSR7X2Qocyl9OiR7X2Qocil9YCl9fX0pO1N0LnByb3RvdHlwZS51dGM9bmV3IFN0KG5ldyB3dCgwKSksU3QucHJvdG90eXBlLm1pbj1uZXcgU3QobmV3IHd0KDAsLTg2MzQwLDApKSxTdC5wcm90b3R5cGUubWF4PW5ldyBTdChuZXcgd3QoMCw4NjM0MCwwKSk7Y29uc3Qga3Q9bmV3IE50KDE5NzAsMSwxLDAsMCwwLDAsU3QucHJvdG90eXBlLnV0Yyk7cmV0dXJuIEV9KSl9XCIsXCJzcmMvbGliL2RvY3VtZW50LmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7dmFyIGUsdD17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJkb2N1bWVudFxcXCIpfTtyZXR1cm4gdC5nZXRFbGVtZW50QnlJZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXt2YXIgZT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChuLnYpO3JldHVybiBlP1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LkVsZW1lbnQsW2VdKTpTay5idWlsdGluLm5vbmUubm9uZSR9KSksdC5jcmVhdGVFbGVtZW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobi52KTtpZihlKXJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5FbGVtZW50LFtlXSl9KSksdC5nZXRFbGVtZW50c0J5VGFnTmFtZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtmb3IodmFyIGU9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUobi52KSxpPVtdLHI9ZS5sZW5ndGgtMTtyPj0wO3ItLSlpLnB1c2goU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuRWxlbWVudCxbZVtyXV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChpKX0pKSx0LmdldEVsZW1lbnRzQnlDbGFzc05hbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Zm9yKHZhciBlPWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobi52KSxpPVtdLHI9MDtyPGUubGVuZ3RoO3IrKylpLnB1c2goU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuRWxlbWVudCxbZVtyXV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChpKX0pKSx0LmdldEVsZW1lbnRzQnlOYW1lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2Zvcih2YXIgZT1kb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuLnYpLGk9W10scj0wO3I8ZS5sZW5ndGg7cisrKWkucHVzaChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5FbGVtZW50LFtlW3JdXSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGkpfSkpLHQucXVlcnlTZWxlY3Rvcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKG4udik7cmV0dXJuIGU/U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuRWxlbWVudCxbZV0pOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSx0LnF1ZXJ5U2VsZWN0b3JBbGw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Zm9yKHZhciBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwobi52KSxpPVtdLHI9MDtyPGUubGVuZ3RoO3IrKylpLnB1c2goU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuRWxlbWVudCxbZVtyXV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChpKX0pKSx0LmdldEN1cnJlbnRFZGl0b3JWYWx1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PVNrLmRpdmlkJiZ2b2lkIDAhPT13aW5kb3cuZWRMaXN0KXtpZihTay5ncmFkZUNvbnRhaW5lciE9U2suZGl2aWQpe3ZhciBuPVNrLmdyYWRlQ29udGFpbmVyK1xcXCIgXFxcIitTay5kaXZpZDtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHdpbmRvdy5lZExpc3Rbbl0uZWRpdG9yLmdldFZhbHVlKCkpfXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIod2luZG93LmVkTGlzdFtTay5kaXZpZF0uZWRpdG9yLmdldFZhbHVlKCkpfXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFxcXCJDYW4ndCBmaW5kIGVkaXRvciBmb3IgdGhpcyBkaXZcXFwiKX0pKSx0LmN1cnJlbnREaXY9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1Tay5kaXZpZClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmRpdmlkKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcXFwiVGhlcmUgaXMgbm8gdmFsdWUgc2V0IGZvciBkaXZpZFxcXCIpfSkpLHQuY3VycmVudENvdXJzZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWVCb29rQ29uZmlnKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoZUJvb2tDb25maWcuY291cnNlKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcXFwiVGhlcmUgaXMgbm8gY291cnNlXFxcIil9KSksdC5jdXJyZW50R3JhZGluZ0NvbnRhaW5lcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PVNrLmdyYWRlQ29udGFpbmVyKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suZ3JhZGVDb250YWluZXIpO2lmKG51bGwhPVNrLmRpdmlkKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suZGl2aWQpO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFxcXCJUaGVyZSBpcyBubyB2YWx1ZSBzZXQgZm9yIGdyYWRpbmdcXFwiKX0pKSxlPWZ1bmN0aW9uKG4sZSl7ZS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUpe24udj1lLG4uaW5uZXJIVE1MPWUuaW5uZXJIVE1MLG4uaW5uZXJUZXh0PWUuaW5uZXJUZXh0LHZvaWQgMCE9PWUudmFsdWUmJihuLnZhbHVlPWUudmFsdWUsU2suYWJzdHIub2JqZWN0U2V0SXRlbShuLiRkLG5ldyBTay5idWlsdGluLnN0cihcXFwidmFsdWVcXFwiKSxuZXcgU2suYnVpbHRpbi5zdHIobi52YWx1ZSkpKSx2b2lkIDAhPT1lLmNoZWNrZWQmJihuLmNoZWNrZWQ9ZS5jaGVja2VkLFNrLmFic3RyLm9iamVjdFNldEl0ZW0obi4kZCxuZXcgU2suYnVpbHRpbi5zdHIoXFxcImNoZWNrZWRcXFwiKSxTay5idWlsdGluLmJvb2wobi5jaGVja2VkKSkpLFNrLmFic3RyLm9iamVjdFNldEl0ZW0obi4kZCxuZXcgU2suYnVpbHRpbi5zdHIoXFxcImlubmVySFRNTFxcXCIpLG5ldyBTay5idWlsdGluLnN0cihuLmlubmVySFRNTCkpLFNrLmFic3RyLm9iamVjdFNldEl0ZW0obi4kZCxuZXcgU2suYnVpbHRpbi5zdHIoXFxcImlubmVyVGV4dFxcXCIpLG5ldyBTay5idWlsdGluLnN0cihuLmlubmVyVGV4dCkpfSkpLGUuX19zZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixlLHQpe1xcXCJpbm5lckhUTUxcXFwiPT09KGU9U2suZmZpLnJlbWFwVG9KcyhlKSkmJihuLmlubmVySFRNTD10LG4udi5pbm5lckhUTUw9dC52LFNrLmFic3RyLm9iamVjdFNldEl0ZW0obi4kZCxuZXcgU2suYnVpbHRpbi5zdHIoXFxcImlubmVySFRNTFxcXCIpLHQpKSxcXFwiaW5uZXJUZXh0XFxcIj09PWUmJihuLmlubmVyVGV4dD10LG4udi5pbm5lclRleHQ9dC52LFNrLmFic3RyLm9iamVjdFNldEl0ZW0obi4kZCxuZXcgU2suYnVpbHRpbi5zdHIoXFxcImlubmVyVGV4dFxcXCIpLHQpKX0pKSxlLmFwcGVuZENoaWxkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sZSl7bi52LmFwcGVuZENoaWxkKGUudil9KSksZS5yZW1vdmVDaGlsZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUpe24udi5yZW1vdmVDaGlsZChlLnYpfSkpLGUuY2xvc2VzdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUpe3ZhciBpPW4udi5jbG9zZXN0KGUudik7cmV0dXJuIGk/U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuRWxlbWVudCxbaV0pOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSxlLmdldENTUz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIobi52LnN0eWxlW2Uudl0pfSkpLGUuc2V0Q1NTPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sZSx0KXtuLnYuc3R5bGVbZS52XT10LnZ9KSksZS5nZXRBdHRyaWJ1dGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixlKXt2YXIgdD1uLnYuZ2V0QXR0cmlidXRlKGUudik7cmV0dXJuIHQ/bmV3IFNrLmJ1aWx0aW4uc3RyKHQpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSxlLnNldEF0dHJpYnV0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUsdCl7bi52LnNldEF0dHJpYnV0ZShlLnYsdC52KX0pKSxlLmdldFByb3BlcnR5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi52W2Uudl07cmV0dXJuIHQ/bmV3IFNrLmJ1aWx0aW4uc3RyKHQpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSxlLl9fc3RyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIGNvbnNvbGUubG9nKG4udi50YWdOYW1lKSxuZXcgU2suYnVpbHRpbi5zdHIobi52LnRhZ05hbWUpfSkpLGUuX19yZXByX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcXFwiW0RPTSBFbGVtZW50XVxcXCIpfSkpfSx0LkVsZW1lbnQ9U2subWlzY2V2YWwuYnVpbGRDbGFzcyh0LGUsXFxcIkVsZW1lbnRcXFwiLFtdKSx0fTtcIixcInNyYy9saWIvZnVuY3Rvb2xzLmpzXCI6XCJmdW5jdGlvbiAkYnVpbHRpbm1vZHVsZSgpe2NvbnN0IHQ9e307cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmltcG9ydE1vZHVsZShcXFwiY29sbGVjdGlvbnNcXFwiLCExLCEwKSwoZT0+KHQuX25hbWVkdHVwbGU9ZS4kZC5uYW1lZHR1cGxlLGZ1bmN0b29sc19tb2QodCkpKSl9ZnVuY3Rpb24gZnVuY3Rvb2xzX21vZCh0KXtjb25zdHtvYmplY3Q6ZSxpbnRfOm4sc3RyOnIsbGlzdDpzLHR1cGxlOmEsZGljdDppLG5vbmU6e25vbmUkOm99LGJvb2w6e2ZhbHNlJDpjfSxOb3RJbXBsZW1lbnRlZDp7Tm90SW1wbGVtZW50ZWQkOl99LGJvb2w6bCxmdW5jOnAsbWV0aG9kOnUsVHlwZUVycm9yOmgsUnVudGltZUVycm9yOmQsVmFsdWVFcnJvcjpmLE5vdEltcGxlbWVudGVkRXJyb3I6bSxBdHRyaWJ1dGVFcnJyb3I6dyxPdmVyZmxvd0Vycm9yOmcsY2hlY2tOb25lOiQsY2hlY2tCb29sOnksY2hlY2tDYWxsYWJsZTprLGNoZWNrQ2xhc3M6Yn09U2suYnVpbHRpbix7Y2FsbHNpbUFycmF5OngsY2FsbHNpbU9yU3VzcGVuZEFycmF5OkEsaXRlckZvcjpTLGNoYWluOkUsaXNJbmRleDp2LGFzSW5kZXhTaXplZDpOLGlzVHJ1ZTpQLHJpY2hDb21wYXJlQm9vbDpqLG9iamVjdFJlcHI6Un09U2subWlzY2V2YWwse3JlbWFwVG9QeTp6fT1Tay5mZmkse2J1aWxkTmF0aXZlQ2xhc3M6cSxzZXRVcE1vZHVsZU1ldGhvZHM6VCxrZXl3b3JkQXJyYXlGcm9tUHlEaWN0Okksa2V5d29yZEFycmF5VG9QeURpY3Q6RCxvYmplY3RIYXNoOkMsbG9va3VwU3BlY2lhbDpNLGNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzOlcsdHlwZU5hbWU6RixpdGVyOlUsZ2F0dHI6T309U2suYWJzdHIse2dldFNldERpY3Q6RyxnZXRBdHRyOkIsc2V0QXR0cjpLfT1Tay5nZW5lcmljO2Z1bmN0aW9uIHByb3h5RmFpbCh0KXtyZXR1cm4gbmV3IHAoKCgpPT57dGhyb3cgbmV3IG0odCtcXFwiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gc2t1bHB0XFxcIil9KSl9T2JqZWN0LmFzc2lnbih0LHtfX25hbWVfXzpuZXcgcihcXFwiZnVuY3Rvb2xzXFxcIiksX19kb2NfXzpuZXcgcihcXFwiVG9vbHMgZm9yIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgYW5kIGNhbGxhYmxlIG9iamVjdHNcXFwiKSxfX2FsbF9fOm5ldyBzKFtcXFwidXBkYXRlX3dyYXBwZXJcXFwiLFxcXCJ3cmFwc1xcXCIsXFxcIldSQVBQRVJfQVNTSUdOTUVOVFNcXFwiLFxcXCJXUkFQUEVSX1VQREFURVNcXFwiLFxcXCJ0b3RhbF9vcmRlcmluZ1xcXCIsXFxcImNtcF90b19rZXlcXFwiLFxcXCJjYWNoZVxcXCIsXFxcImxydV9jYWNoZVxcXCIsXFxcInJlZHVjZVxcXCIsXFxcInBhcnRpYWxcXFwiLFxcXCJwYXJ0aWFsbWV0aG9kXFxcIixcXFwic2luZ2xlZGlzcGF0Y2hcXFwiLFxcXCJzaW5nbGVkaXNwYXRjaG1ldGhvZFxcXCIsXFxcImNhY2hlZF9wcm9wZXJ0eVxcXCJdLm1hcCgodD0+bmV3IHIodCkpKSksV1JBUFBFUl9BU1NJR05NRU5UUzpuZXcgYShbXFxcIl9fbW9kdWxlX19cXFwiLFxcXCJfX25hbWVfX1xcXCIsXFxcIl9fcXVhbG5hbWVfX1xcXCIsXFxcIl9fZG9jX19cXFwiLFxcXCJfX2Fubm90YXRpb25zX19cXFwiXS5tYXAoKHQ9Pm5ldyByKHQpKSkpLFdSQVBQRVJfVVBEQVRFUzpuZXcgYShbbmV3IHIoXFxcIl9fZGljdF9fXFxcIildKSxzaW5nbGVkaXNwYXRjaDpwcm94eUZhaWwoXFxcInNpbmdsZWRpc3BhdGNoXFxcIiksc2luZ2xlZGlzcGF0Y2htZXRob2Q6cHJveHlGYWlsKFxcXCJzaW5nbGVkaXNwYXRjaG1ldGhvZFxcXCIpLGNhY2hlZF9wcm9wZXJ0eTpwcm94eUZhaWwoXFxcImNhY2hlZF9wcm9wZXJ0eVxcXCIpfSk7Y29uc3QgTD1uZXcgcihcXFwiY2FjaGVfcGFyYW1ldGVyc1xcXCIpO2Z1bmN0aW9uIF9scnVfY2FjaGUoZSxuKXtpZihufHwobj1jKSx2KGUpKShlPU4oZSxnKSk8MCYmKGU9MCk7ZWxzZXtpZihrKGUpJiZ5KG4pKXtjb25zdCByPWUscz1uZXcgVihyLGU9MTI4LG4pO3JldHVybiBzLnRwJHNldGF0dHIoTCxuZXcgcCgoKCk9Pnooe21heHNpemU6ZSx0eXBlZDpufSkpKSksQSh0LnVwZGF0ZV93cmFwcGVyLFtzLHJdKX1pZighJChlKSl0aHJvdyBuZXcgaChcXFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gaW50ZWdlciwgYSBjYWxsYWJsZSwgb3IgTm9uZVxcXCIpfXJldHVybiBuZXcgcCgocj0+e2NvbnN0IHM9bmV3IFYocixlLG4pO3JldHVybiBzLnRwJHNldGF0dHIoTCxuZXcgcCgoKCk9Pnooe21heHNpemU6ZSx0eXBlZDpufSkpKSksQSh0LnVwZGF0ZV93cmFwcGVyLFtzLHJdKX0pKX1jb25zdCBIPXQuX0NhY2hlSW5mbz14KHQuX25hbWVkdHVwbGUsW1xcXCJDYWNoZUluZm9cXFwiLFtcXFwiaGl0c1xcXCIsXFxcIm1pc3Nlc1xcXCIsXFxcIm1heHNpemVcXFwiLFxcXCJjdXJyc2l6ZVxcXCJdXS5tYXAoKHQ9PnoodCkpKSxbXFxcIm1vZHVsZVxcXCIsbmV3IHIoXFxcImZ1bmN0b29sc1xcXCIpXSksVj1xKFxcXCJmdW5jdG9vbHMuX2xydV9jYWNoZV93cmFwcGVyXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gX2xydV9jYWNoZV93cmFwcGVyKHQsZSxuLHIpe2lmKCFrKHQpKXRocm93IG5ldyBoKFxcXCJ0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBjYWxsYWJsZVxcXCIpO2xldCBzO2lmKCQoZSkpcz1pbmZpbml0ZV9scnVfY2FjaGVfd3JhcHBlcixlPS0xO2Vsc2V7aWYoIXYoZSkpdGhyb3cgbmV3IGgoXFxcIm1heHNpemUgc2hvdWxkIGJlIGludGVnZXIgb3IgTm9uZVxcXCIpOyhlPU4oZSxnKSk8MCYmKGU9MCkscz0wPT09ZT91bmNhY2hlZF9scnVfY2FjaGVfd3JhcHBlcjpib3VuZGVkX2xydV9jYWNoZV93cmFwcGVyfXRoaXMucm9vdD17fSx0aGlzLnJvb3QucHJldj10aGlzLnJvb3QubmV4dD10aGlzLnJvb3QsdGhpcy53cmFwcGVyPXMsdGhpcy5tYXhzaXplPWUsdGhpcy50eXBlZD1uLHRoaXMuY2FjaGU9bmV3IGkoW10pLHRoaXMuZnVuYz10LHRoaXMubWlzc2VzPXRoaXMuaGl0cz0wLHRoaXMuJGQ9bmV3IGkoW10pfSxzbG90czp7dHAkbmV3KHQsZSl7Y29uc3RbbixyLHMsYV09VyhcXFwiX2xydV9jYWNoZV93cmFwcGVyXFxcIixbXFxcInVzZXJfZnVuY3Rpb25cXFwiLFxcXCJtYXhzaXplXFxcIixcXFwidHlwZWRcXFwiLFxcXCJjYWNoZV9pbmZvX3R5cGVcXFwiXSx0LGUpO3JldHVybiBuZXcgVihuLHIscyxhKX0sdHAkY2FsbCh0LGUpe3JldHVybiB0aGlzLndyYXBwZXIodCxlKX0sdHAkZGVzY3JfZ2V0KHQsZSl7cmV0dXJuIG51bGw9PT10P3RoaXM6bmV3IHUodGhpcyx0KX0sdHAkZG9jOlxcXCJDcmVhdGUgYSBjYWNoZWQgY2FsbGFibGUgdGhhdCB3cmFwcyBhbm90aGVyIGZ1bmN0aW9uLlxcXFxuXFxcXG51c2VyX2Z1bmN0aW9uOiAgICAgIHRoZSBmdW5jdGlvbiBiZWluZyBjYWNoZWRcXFxcblxcXFxubWF4c2l6ZTogIDAgICAgICAgICBmb3Igbm8gY2FjaGluZ1xcXFxuICAgICAgICAgIE5vbmUgICAgICBmb3IgdW5saW1pdGVkIGNhY2hlIHNpemVcXFxcbiAgICAgICAgICBuICAgICAgICAgZm9yIGEgYm91bmRlZCBjYWNoZVxcXFxuXFxcXG50eXBlZDogICAgRmFsc2UgICAgIGNhY2hlIGYoMykgYW5kIGYoMy4wKSBhcyBpZGVudGljYWwgY2FsbHNcXFxcbiAgICAgICAgICBUcnVlICAgICAgY2FjaGUgZigzKSBhbmQgZigzLjApIGFzIGRpc3RpbmN0IGNhbGxzXFxcXG5cXFxcbmNhY2hlX2luZm9fdHlwZTogICAgbmFtZWR0dXBsZSBjbGFzcyB3aXRoIHRoZSBmaWVsZHM6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRzIG1pc3NlcyBjdXJyc2l6ZSBtYXhzaXplXFxcXG5cXFwifSxtZXRob2RzOntjYWNoZV9pbmZvOnskbWV0aCgpe3JldHVybiBBKEgsW3RoaXMuaGl0cyx0aGlzLm1pc3NlcywtMT09PXRoaXMubWF4c2l6ZT9vOnRoaXMubWF4c2l6ZSx0aGlzLmNhY2hlLmdldCRzaXplKCldLm1hcCgodD0+eih0KSkpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XFxcIlJlcG9ydCBjYWNoZSBzdGF0aXN0aWNzXFxcIn0sY2FjaGVfY2xlYXI6eyRtZXRoKCl7cmV0dXJuIHRoaXMuaGl0cz10aGlzLm1pc3Nlcz0wLHRoaXMucm9vdD17fSx0aGlzLnJvb3QubmV4dD10aGlzLnJvb3QucHJldj10aGlzLnJvb3QsQSh0aGlzLmNhY2hlLnRwJGdldGF0dHIobmV3IHIoXFxcImNsZWFyXFxcIiksITApKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XFxcIkNsZWFyIHRoZSBjYWNoZSBhbmQgY2FjaGUgc3RhdGlzdGljc1xcXCJ9LF9fZGVlcGNvcHlfXzp7JG1ldGgodCl7cmV0dXJuIHRoaXN9LCRmbGFnczp7T25lQXJnOiEwfX0sX19jb3B5X186eyRtZXRoKCl7cmV0dXJuIHRoaXN9LCRmbGFnczp7Tm9BcmdzOiEwfX19LGdldHNldHM6e19fZGljdF9fOkd9fSk7ZnVuY3Rpb24gaW5maW5pdGVfbHJ1X2NhY2hlX3dyYXBwZXIodCxlKXtjb25zdCBuPV9tYWtlX2tleSh0LGUsdGhpcy50eXBlZCkscj10aGlzLmNhY2hlLm1wJGxvb2t1cChuKTtyZXR1cm4gdm9pZCAwIT09cj8odGhpcy5oaXRzKysscik6KHRoaXMubWlzc2VzKyssRShBKHRoaXMuZnVuYyx0LGUpLCh0PT4odGhpcy5jYWNoZS5tcCRhc3Nfc3Vic2NyaXB0KG4sdCksdCkpKSl9ZnVuY3Rpb24gdW5jYWNoZWRfbHJ1X2NhY2hlX3dyYXBwZXIodCxlKXtyZXR1cm4gdGhpcy5taXNzZXMrKyxBKHRoaXMuZnVuYyx0LGUpfWZ1bmN0aW9uIGJvdW5kZWRfbHJ1X2NhY2hlX3dyYXBwZXIodCxlKXtjb25zdCBuPV9tYWtlX2tleSh0LGUsdGhpcy50eXBlZCkscj10aGlzLmNhY2hlLm1wJGxvb2t1cChuKTtpZih2b2lkIDAhPT1yKXtjb25zdHtyZXN1bHQ6dH09cjtyZXR1cm4gbHJ1X2NhY2hlX2V4dHJhY3RfbGluayhyKSxscnVfY2FjaGVfYXBwZW5kX2xpbmsodGhpcyxyKSx0aGlzLmhpdHMrKyx0fXJldHVybiB0aGlzLm1pc3NlcysrLEUoQSh0aGlzLmZ1bmMsdCxlKSwodD0+e2lmKHZvaWQgMCE9PXRoaXMuY2FjaGUubXAkbG9va3VwKG4pKXJldHVybiB0O2lmKHRoaXMuY2FjaGUuZ2V0JHNpemUoKTx0aGlzLm1heHNpemV8fHRoaXMucm9vdC5uZXh0PT09dGhpcy5yb290KXtjb25zdCBlPXtrZXk6bixyZXN1bHQ6dH07cmV0dXJuIHRoaXMuY2FjaGUubXAkYXNzX3N1YnNjcmlwdChuLGUpLGxydV9jYWNoZV9hcHBlbmRfbGluayh0aGlzLGUpLHR9Y29uc3QgZT10aGlzLnJvb3QubmV4dDtscnVfY2FjaGVfZXh0cmFjdF9saW5rKGUpO2lmKHZvaWQgMD09PXRoaXMuY2FjaGUucG9wJGl0ZW0oZS5rZXkpKXRocm93IGZ1bmN0aW9uIGxydV9jYWNoZV9wcmVwZW5kX2xpbmsodCxlKXtjb25zdCBuPXQucm9vdCxyPW4ubmV4dDtyLnByZXY9bi5uZXh0PWUsZS5wcmV2PW4sZS5uZXh0PXJ9KHRoaXMsZSksbmV3IGQoXFxcImNhY2hlZCBpdGVtIHJlbW92ZWQgdW5leHBlY3RlZGx5XFxcIik7cmV0dXJuIGUua2V5PW4sZS5yZXN1bHQ9dCx0aGlzLmNhY2hlLm1wJGFzc19zdWJzY3JpcHQobixlKSxscnVfY2FjaGVfYXBwZW5kX2xpbmsodGhpcyxlKSx0fSkpfWZ1bmN0aW9uIGxydV9jYWNoZV9leHRyYWN0X2xpbmsodCl7Y29uc3R7cHJldjplLG5leHQ6bn09dDtlLm5leHQ9dC5uZXh0LG4ucHJldj10LnByZXZ9ZnVuY3Rpb24gbHJ1X2NhY2hlX2FwcGVuZF9saW5rKHQsZSl7Y29uc3Qgbj10LnJvb3Qscj1uLnByZXY7ci5uZXh0PW4ucHJldj1lLGUucHJldj1yLGUubmV4dD1ufWNvbnN0IEo9cShcXFwiX0hhY2hlZFNlcVxcXCIse2Jhc2U6cyxjb25zdHJ1Y3RvcjpmdW5jdGlvbiBfSGFjaGVkU2VxKHQpe3RoaXMuJGhhc2h2YWw9QyhuZXcgYSh0KSkscy5jYWxsKHRoaXMsdCl9LHNsb3RzOnt0cCRoYXNoKCl7cmV0dXJuIHRoaXMuJGhhc2h2YWx9fX0pLFE9bmV3IGUsWD1uZXcgU2V0KFtuLHJdKTtmdW5jdGlvbiBfbWFrZV9rZXkodCxlLG4pe2NvbnN0IHM9dC5zbGljZSgwKSxpPVtdO2lmKGUmJmUubGVuZ3RoKXtzLnB1c2goUSk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kz0yKXtjb25zdCBuPWVbdCsxXTtpLnB1c2gobikscy5wdXNoKG5ldyBhKFtuZXcgcihlW3RdKSxuXSkpfX1pZihQKG4pKXMucHVzaCguLi50Lm1hcCgodD0+dC5vYiR0eXBlKSksLi4uaS5tYXAoKHQ9PnQub2IkdHlwZSkpKTtlbHNlIGlmKDE9PT1zLmxlbmd0aCYmWC5oYXMoc1swXS5vYiR0eXBlKSlyZXR1cm4gc1swXTtyZXR1cm4gbmV3IEoocyl9ZnVuY3Rpb24gcGFydGlhbF9hZGp1c3RfYXJnc19rd2FyZ3ModCxlKXtpZih0PXRoaXMuYXJnX2Fyci5jb25jYXQodCksZSl7ZT1EKGUpO2NvbnN0IHQ9dGhpcy5rd2RpY3QuZGljdCRjb3B5KCk7dC5kaWN0JG1lcmdlKGUpLGU9SSh0KX1lbHNlIGU9SSh0aGlzLmt3ZGljdCk7cmV0dXJue2FyZ3M6dCxrd2FyZ3M6ZX19ZnVuY3Rpb24gcGFydGlhbF9uZXcodCxlKXtpZih0Lmxlbmd0aDwxKXRocm93IG5ldyBoKFxcXCJ0eXBlICdwYXJ0aWFsJyB0YWtlcyBhdCBsZWFzdCAxIGFyZ3VtZW50XFxcIik7bGV0IG4scixzPXQuc2hpZnQoKTtpZihzIGluc3RhbmNlb2YgdGhpcy5zayRidWlsdGluQmFzZSl7Y29uc3QgdD1zO3M9dC5mbixuPXQuYXJnX2FycixyPXQua3dkaWN0fXRoaXMuY2hlY2skZnVuYyhzKSxuJiYodD1uLmNvbmNhdCh0KSk7bGV0IGE9RChlPWV8fFtdKTtpZihyKXtjb25zdCB0PXIuZGljdCRjb3B5KCk7dC5kaWN0JG1lcmdlKGEpLGE9dH1pZih0aGlzLnNrJGJ1aWx0aW5CYXNlPT09dGhpcy5jb25zdHJ1Y3RvcilyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Iocyx0LGEpO3tjb25zdCBlPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB0aGlzLnNrJGJ1aWx0aW5CYXNlLmNhbGwoZSxzLHQsYSksZX19ZnVuY3Rpb24gcGFydGlhbF9yZXByKCl7aWYodGhpcy5pbiRyZXByKXJldHVybiBuZXcgcihcXFwiLi4uXFxcIik7dGhpcy5pbiRyZXByPSEwO2NvbnN0IHQ9W1IodGhpcy5mbildO3JldHVybiB0aGlzLmFyZ19hcnIuZm9yRWFjaCgoZT0+e3QucHVzaChSKGUpKX0pKSx0aGlzLmt3ZGljdC4kaXRlbXMoKS5mb3JFYWNoKCgoW2Usbl0pPT57dC5wdXNoKGUudG9TdHJpbmcoKStcXFwiPVxcXCIrUihuKSl9KSksdGhpcy5pbiRyZXByPSExLG5ldyByKHRoaXMudHAkbmFtZStcXFwiKFxcXCIrdC5qb2luKFxcXCIsIFxcXCIpK1xcXCIpXFxcIil9dC5wYXJ0aWFsPXEoXFxcImZ1bmN0b29scy5wYXJ0aWFsXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gcGFydGlhbCh0LGUsbil7dGhpcy5mbj10LHRoaXMuYXJnX2Fycj1lLHRoaXMuYXJnX3R1cD1uZXcgYShlKSx0aGlzLmt3ZGljdD1uLHRoaXMuaW4kcmVwcj0hMSx0aGlzLiRkPW5ldyBpKFtdKX0sc2xvdHM6e3RwJG5ldzpwYXJ0aWFsX25ldyx0cCRjYWxsKHQsZSl7cmV0dXJuKHthcmdzOnQsa3dhcmdzOmV9PXRoaXMuYWRqJGFyZ3Nfa3dzKHQsZSkpLHRoaXMuZm4udHAkY2FsbCh0LGUpfSx0cCRkb2M6XFxcInBhcnRpYWwoZnVuYywgKmFyZ3MsICoqa2V5d29yZHMpIC0gbmV3IGZ1bmN0aW9uIHdpdGggcGFydGlhbCBhcHBsaWNhdGlvblxcXFxuICAgIG9mIHRoZSBnaXZlbiBhcmd1bWVudHMgYW5kIGtleXdvcmRzLlxcXFxuXFxcIiwkcjpwYXJ0aWFsX3JlcHIsdHAkZ2V0YXR0cjpCLHRwJHNldGF0dHI6S30sZ2V0c2V0czp7ZnVuYzp7JGdldCgpe3JldHVybiB0aGlzLmZufSwkZG9jOlxcXCJmdW5jdGlvbiBvYmplY3QgdG8gdXNlIGluIGZ1dHVyZSBwYXJ0aWFsIGNhbGxzXFxcIn0sYXJnczp7JGdldCgpe3JldHVybiB0aGlzLmFyZ190dXB9LCRkb2M6XFxcInR1cGxlIG9mIGFyZ3VtZW50cyB0byBmdXR1cmUgcGFydGlhbCBjYWxsc1xcXCJ9LGtleXdvcmRzOnskZ2V0KCl7cmV0dXJuIHRoaXMua3dkaWN0fSwkZG9jOlxcXCJkaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHRvIGZ1dHVyZSBwYXJ0aWFsIGNhbGxzXFxcIn0sX19kaWN0X186R30sbWV0aG9kczp7fSxjbGFzc21ldGhvZHM6U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW0scHJvdG86e2FkaiRhcmdzX2t3czpwYXJ0aWFsX2FkanVzdF9hcmdzX2t3YXJncyxjaGVjayRmdW5jKHQpe2lmKCFrKHQpKXRocm93IG5ldyBoKFxcXCJ0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBjYWxsYWJsZVxcXCIpfX19KSx0LnBhcnRpYWxtZXRob2Q9cShcXFwiZnVuY3Rvb2xzLnBhcnRpYWxtZXRob2RcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBwYXJ0aWFsbWV0aG9kKHQsZSxuKXt0aGlzLmZuPXQsdGhpcy5hcmdfYXJyPWUsdGhpcy5hcmdfdHVwPW5ldyBhKGUpLHRoaXMua3dkaWN0PW59LHNsb3RzOnt0cCRuZXc6cGFydGlhbF9uZXcsdHAkZG9jOlxcXCJNZXRob2QgZGVzY3JpcHRvciB3aXRoIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgdGhlIGdpdmVuIGFyZ3VtZW50c1xcXFxuICAgIGFuZCBrZXl3b3Jkcy5cXFxcblxcXFxuICAgIFN1cHBvcnRzIHdyYXBwaW5nIGV4aXN0aW5nIGRlc2NyaXB0b3JzIGFuZCBoYW5kbGVzIG5vbi1kZXNjcmlwdG9yXFxcXG4gICAgY2FsbGFibGVzIGFzIGluc3RhbmNlIG1ldGhvZHMuXFxcXG4gICAgXFxcIiwkcjpwYXJ0aWFsX3JlcHIsdHAkZGVzY3JfZ2V0KGUsbil7bGV0IHI7aWYodGhpcy5mbi50cCRkZXNjcl9nZXQpe2NvbnN0IHM9dGhpcy5mbi50cCRkZXNjcl9nZXQoZSxuKTtpZihzIT09dGhpcy5mbil7aWYoIWsocykpdGhyb3cgbmV3IGgoXFxcInR5cGUgJ3BhcnRpYWwnIHJlcXVpcmVzIGEgY2FsbGFibGVcXFwiKTtyPW5ldyB0LnBhcnRpYWwocyx0aGlzLmFyZ19hcnIuc2xpY2UoMCksdGhpcy5rd2RpY3QuZGljdCRjb3B5KCkpO2NvbnN0IGU9TShzLHRoaXMuc3RyJHNlbGYpO3ZvaWQgMCE9PWUmJnIudHAkc2V0YXR0cih0aGlzLnN0ciRzZWxmLGUpfX1yZXR1cm4gdm9pZCAwPT09ciYmKHI9dGhpcy5tYWtlJHVuYm91bmQoKS50cCRkZXNjcl9nZXQoZSxuKSkscn19LG1ldGhvZHM6e19tYWtlX3VuYm91bmRfbWV0aG9kOnskbWV0aCgpe3JldHVybiB0aGlzLm1ha2UkdW5ib3VuZCgpfSwkZmxhZ3M6e05vQXJnczohMH19fSxjbGFzc21ldGhvZHM6U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW0sZ2V0c2V0czp7ZnVuYzp7JGdldCgpe3JldHVybiB0aGlzLmZufSwkZG9jOlxcXCJmdW5jdGlvbiBvYmplY3QgdG8gdXNlIGluIGZ1dHVyZSBwYXJ0aWFsIGNhbGxzXFxcIn0sYXJnczp7JGdldCgpe3JldHVybiB0aGlzLmFyZ190dXB9LCRkb2M6XFxcInR1cGxlIG9mIGFyZ3VtZW50cyB0byBmdXR1cmUgcGFydGlhbCBjYWxsc1xcXCJ9LGtleXdvcmRzOnskZ2V0KCl7cmV0dXJuIHRoaXMua3dkaWN0fSwkZG9jOlxcXCJkaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHRvIGZ1dHVyZSBwYXJ0aWFsIGNhbGxzXFxcIn0sX19kaWN0X186R30scHJvdG86e3N0ciRzZWxmOm5ldyByKFxcXCJfX3NlbGZfX1xcXCIpLG1ha2UkdW5ib3VuZCgpe2NvbnN0IHQ9dGhpcztmdW5jdGlvbiBfbWV0aG9kKGUsbil7Y29uc3Qgcj1lLnNoaWZ0KCk7cmV0dXJuKHthcmdzOmUsa3dhcmdzOm59PXQuYWRqJGFyZ3Nfa3dzKGUsbikpLGUudW5zaGlmdChyKSxBKHQuZm4sZSxuKX1yZXR1cm4gX21ldGhvZC5jb19mYXN0Y2FsbD0hMCxuZXcgcChfbWV0aG9kKX0sYWRqJGFyZ3Nfa3dzOnBhcnRpYWxfYWRqdXN0X2FyZ3Nfa3dhcmdzLGNoZWNrJGZ1bmModCl7aWYoIWsodCkmJnZvaWQgMD09PXQudHAkZGVzY3JfZ2V0KXRocm93IG5ldyBoKFIodCkrXFxcIiBpcyBub3QgY2FsbGFibGUgb3IgYSBkZXNjcmlwdG9yXFxcIil9fX0pO2NvbnN0IFk9e19fbHRfXzpyLiRsdCxfX2xlX186ci4kbGUsX19ndF9fOnIuJGd0LF9fZ2VfXzpyLiRnZX07ZnVuY3Rpb24gZnJvbV9zbG90KHQsZSl7Y29uc3Qgbj1ZW3RdO2Z1bmN0aW9uIGNvbXBhcmVfc2xvdCh0LHIpe2xldCBzPXgodC50cCRnZXRhdHRyKG4pLFtyXSk7cmV0dXJuIHM9PT1fP3M6KHM9UChzKSxuZXcgbChlKHMsdCxyKSkpfXJldHVybiBjb21wYXJlX3Nsb3QuY29fbmFtZT1uLGNvbXBhcmVfc2xvdH1jb25zdCBaPWZyb21fc2xvdChcXFwiX19sdF9fXFxcIiwoKHQsZSxuKT0+IXQmJmooZSxuLFxcXCJOb3RFcVxcXCIpKSksdHQ9ZnJvbV9zbG90KFxcXCJfX2x0X19cXFwiLCgodCxlLG4pPT50fHxqKGUsbixcXFwiRXFcXFwiKSkpLGV0PWZyb21fc2xvdChcXFwiX19sdF9fXFxcIiwodD0+IXQpKSxudD1mcm9tX3Nsb3QoXFxcIl9fbGVfX1xcXCIsKCh0LGUsbik9PiF0fHxqKGUsbixcXFwiRXFcXFwiKSkpLHJ0PWZyb21fc2xvdChcXFwiX19sZV9fXFxcIiwoKHQsZSxuKT0+dCYmaihlLG4sXFxcIk5vdEVxXFxcIikpKSxzdD1mcm9tX3Nsb3QoXFxcIl9fbGVfX1xcXCIsKHQ9PiF0KSksYXQ9ZnJvbV9zbG90KFxcXCJfX2d0X19cXFwiLCgodCxlLG4pPT4hdCYmaihlLG4sXFxcIk5vdEVxXFxcIikpKSxpdD1mcm9tX3Nsb3QoXFxcIl9fZ3RfX1xcXCIsKCh0LGUsbik9PnR8fGooZSxuLFxcXCJFcVxcXCIpKSksb3Q9ZnJvbV9zbG90KFxcXCJfX2d0X19cXFwiLCh0PT4hdCkpLGN0PWZyb21fc2xvdChcXFwiX19nZV9fXFxcIiwoKHQsZSxuKT0+IXR8fGooZSxuLFxcXCJFcVxcXCIpKSksX3Q9ZnJvbV9zbG90KFxcXCJfX2dlX19cXFwiLCgodCxlLG4pPT50JiZqKGUsbixcXFwiTm90RXFcXFwiKSkpLGx0PWZyb21fc2xvdChcXFwiX19nZV9fXFxcIiwodD0+IXQpKSxwdD17X19sdF9fOntfX2d0X186bmV3IHAoWiksX19sZV9fOm5ldyBwKHR0KSxfX2dlX186bmV3IHAoZXQpfSxfX2xlX186e19fZ2VfXzpuZXcgcChudCksX19sdF9fOm5ldyBwKHJ0KSxfX2d0X186bmV3IHAoc3QpfSxfX2d0X186e19fbHRfXzpuZXcgcChhdCksX19nZV9fOm5ldyBwKGl0KSxfX2xlX186bmV3IHAob3QpfSxfX2dlX186e19fbGVfXzpuZXcgcChjdCksX19ndF9fOm5ldyBwKF90KSxfX2x0X186bmV3IHAobHQpfX0sdXQ9e19fbHRfXzpcXFwib2IkbHRcXFwiLF9fbGVfXzpcXFwib2IkbGVcXFwiLF9fZ3RfXzpcXFwib2IkZ3RcXFwiLF9fZ2VfXzpcXFwib2IkZ2VcXFwifTtjb25zdCBodD1uZXcgbigwKSxkdD1xKFxcXCJmdW5jdG9vbHMuS2V5V3JhcHBlclxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHQsZSl7dGhpcy5jbXA9dCx0aGlzLm9iaj1lfSxzbG90czp7dHAkY2FsbCh0LGUpe2NvbnN0W25dPVcoXFxcIktcXFwiLFtcXFwib2JqXFxcIl0sdCxlLFtdKTtyZXR1cm4gbmV3IGR0KHRoaXMuY21wLG4pfSx0cCRyaWNoY29tcGFyZSh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGR0KSl0aHJvdyBuZXcgaChcXFwib3RoZXIgYXJndW1lbnQgbXVzdCBiZSBLIGluc3RhbmNlXFxcIik7Y29uc3Qgbj10aGlzLm9iaixyPXQub2JqO2lmKCFufHwhcil0aHJvdyBuZXcgdyhcXFwib2JqZWN0XFxcIik7Y29uc3Qgcz1BKHRoaXMuY21wLFtuLHJdKTtyZXR1cm4gRShzLCh0PT5qKHQsaHQsZSkpKX0sdHAkZ2V0YXR0cjpCLHRwJGhhc2g6b30sZ2V0c2V0czp7b2JqOnskZ2V0KCl7cmV0dXJuIHRoaXMub2JqfHxvfSwkc2V0KHQpe3RoaXMub2JqPXR9LCRkb2M6XFxcIlZhbHVlIHdyYXBwZWQgYnkgYSBrZXkgZnVuY3Rpb24uXFxcIn19fSksZnQ9bmV3IHIoXFxcInVwZGF0ZVxcXCIpLG10PW5ldyByKFxcXCJfX3dyYXBwZWRfX1xcXCIpO3JldHVybiBUKFxcXCJmdW5jdG9vbHNcXFwiLHQse2NhY2hlOnskbWV0aDpmdW5jdGlvbiBjYWNoZSh0KXtyZXR1cm4gQShfbHJ1X2NhY2hlKG8pLFt0XSl9LCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOidTaW1wbGUgbGlnaHR3ZWlnaHQgdW5ib3VuZGVkIGNhY2hlLiAgU29tZXRpbWVzIGNhbGxlZCBcXFwibWVtb2l6ZVxcXCIuJywkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHVzZXJfZnVuY3Rpb24sIC8pXFxcIn0sbHJ1X2NhY2hlOnskbWV0aDpfbHJ1X2NhY2hlLCRmbGFnczp7TmFtZWRBcmdzOltcXFwibWF4c2l6ZVxcXCIsXFxcInR5cGVkXFxcIl0sRGVmYXVsdHM6W25ldyBuKDEyOCksY119LCRkb2M6XFxcIkxlYXN0LXJlY2VudGx5LXVzZWQgY2FjaGUgZGVjb3JhdG9yLlxcXFxuXFxcXG5JZiAqbWF4c2l6ZSogaXMgc2V0IHRvIE5vbmUsIHRoZSBMUlUgZmVhdHVyZXMgYXJlIGRpc2FibGVkIGFuZCB0aGUgY2FjaGVcXFxcbmNhbiBncm93IHdpdGhvdXQgYm91bmQuXFxcXG5cXFxcbklmICp0eXBlZCogaXMgVHJ1ZSwgYXJndW1lbnRzIG9mIGRpZmZlcmVudCB0eXBlcyB3aWxsIGJlIGNhY2hlZCBzZXBhcmF0ZWx5LlxcXFxuRm9yIGV4YW1wbGUsIGYoMy4wKSBhbmQgZigzKSB3aWxsIGJlIHRyZWF0ZWQgYXMgZGlzdGluY3QgY2FsbHMgd2l0aFxcXFxuZGlzdGluY3QgcmVzdWx0cy5cXFxcblxcXFxuQXJndW1lbnRzIHRvIHRoZSBjYWNoZWQgZnVuY3Rpb24gbXVzdCBiZSBoYXNoYWJsZS5cXFxcblxcXFxuVmlldyB0aGUgY2FjaGUgc3RhdGlzdGljcyBuYW1lZCB0dXBsZSAoaGl0cywgbWlzc2VzLCBtYXhzaXplLCBjdXJyc2l6ZSlcXFxcbndpdGggZi5jYWNoZV9pbmZvKCkuICBDbGVhciB0aGUgY2FjaGUgYW5kIHN0YXRpc3RpY3Mgd2l0aCBmLmNhY2hlX2NsZWFyKCkuXFxcXG5BY2Nlc3MgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb24gd2l0aCBmLl9fd3JhcHBlZF9fLlxcXFxuXFxcXG5TZWU6ICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX3JlcGxhY2VtZW50X3BvbGljaWVzI0xlYXN0X3JlY2VudGx5X3VzZWRfKExSVSlcXFwifSxjbXBfdG9fa2V5OnskbWV0aDpmdW5jdGlvbiBjbXBfdG9fa2V5KHQpe3JldHVybiBuZXcgZHQodCl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwibXljbXBcXFwiXSxEZWZhdWx0czpbXX0sJGRvYzpcXFwiQ29udmVydCBhIGNtcD0gZnVuY3Rpb24gaW50byBhIGtleT0gZnVuY3Rpb24uXFxcIiwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGNtcCwgLylcXFwifSxyZWR1Y2U6eyRtZXRoOmZ1bmN0aW9uIHJlZHVjZSh0LGUsbil7Y29uc3Qgcj1VKGUpO2xldCBzO3JldHVybiBuPW58fHIudHAkaXRlcm5leHQoITApLEUobiwoZT0+e2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IGgoXFxcInJlZHVjZSgpIG9mIGVtcHR5IHNlcXVlbmNlIHdpdGggbm8gaW5pdGlhbCB2YWx1ZVxcXCIpO3JldHVybiBzPWUsUyhyLChlPT5FKEEodCxbcyxlXSksKHQ9PntzPXR9KSkpKX0pLCgoKT0+cykpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjN9LCRkb2M6XFxcInJlZHVjZShmdW5jdGlvbiwgc2VxdWVuY2VbLCBpbml0aWFsXSkgLT4gdmFsdWVcXFxcblxcXFxuQXBwbHkgYSBmdW5jdGlvbiBvZiB0d28gYXJndW1lbnRzIGN1bXVsYXRpdmVseSB0byB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSxcXFxcbmZyb20gbGVmdCB0byByaWdodCwgc28gYXMgdG8gcmVkdWNlIHRoZSBzZXF1ZW5jZSB0byBhIHNpbmdsZSB2YWx1ZS5cXFxcbkZvciBleGFtcGxlLCByZWR1Y2UobGFtYmRhIHgsIHk6IHgreSwgWzEsIDIsIDMsIDQsIDVdKSBjYWxjdWxhdGVzXFxcXG4oKCgoMSsyKSszKSs0KSs1KS4gIElmIGluaXRpYWwgaXMgcHJlc2VudCwgaXQgaXMgcGxhY2VkIGJlZm9yZSB0aGUgaXRlbXNcXFxcbm9mIHRoZSBzZXF1ZW5jZSBpbiB0aGUgY2FsY3VsYXRpb24sIGFuZCBzZXJ2ZXMgYXMgYSBkZWZhdWx0IHdoZW4gdGhlXFxcXG5zZXF1ZW5jZSBpcyBlbXB0eS5cXFwiLCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgZnVuY3Rpb24sIHNlcXVlbmNlWywgaW5pdGlhbF0sIC8pXFxcIn0sdG90YWxfb3JkZXJpbmc6eyRtZXRoOmZ1bmN0aW9uIHRvdGFsX29yZGVyaW5nKHQpe2NvbnN0IG49W107aWYoIWIodCkpdGhyb3cgbmV3IGgoXFxcInRvdGFsIG9yZGVyaW5nIG9ubHkgc3VwcG9ydGVkIGZvciB0eXBlIG9iamVjdHMgbm90ICdcXFwiK0YodCkrXFxcIidcXFwiKTtpZihPYmplY3Qua2V5cyhwdCkuZm9yRWFjaCgocj0+e2NvbnN0IHM9dXRbcl07dC5wcm90b3R5cGVbc10hPT1lLnByb3RvdHlwZVtzXSYmbi5wdXNoKHIpfSkpLCFuLmxlbmd0aCl0aHJvdyBuZXcgZihcXFwibXVzdCBkZWZpbmUgYXRsZWFzdCBvbmUgb3JkZXJpbmcgb3BlcmF0aW9uOiA8LCA+LCA8PSwgPj1cXFwiKTtjb25zdCByPW5bMF07cmV0dXJuIE9iamVjdC5lbnRyaWVzKHB0W3JdKS5mb3JFYWNoKCgoW2Uscl0pPT57bi5pbmNsdWRlcyhlKXx8dC50cCRzZXRhdHRyKFlbZV0scil9KSksdH0sJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XFxcIkNsYXNzIGRlY29yYXRvciB0aGF0IGZpbGxzIGluIG1pc3Npbmcgb3JkZXJpbmcgbWV0aG9kc1xcXCJ9LHVwZGF0ZV93cmFwcGVyOnskbWV0aDpmdW5jdGlvbiB1cGRhdGVfd3JhcHBlcih0LGUsbixyKXtsZXQgcyxhPVUobik7Zm9yKGxldCBpPWEudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9YS50cCRpdGVybmV4dCgpKXZvaWQgMCE9PShzPWUudHAkZ2V0YXR0cihpKSkmJnQudHAkc2V0YXR0cihpLHMpO2E9VShyKTtmb3IobGV0IG89YS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PW87bz1hLnRwJGl0ZXJuZXh0KCkpe3M9ZS50cCRnZXRhdHRyKG8pfHxuZXcgaShbXSk7Y29uc3Qgbj1PKHQsbykscj1PKG4sZnQpO3gocixbc10pfXJldHVybiB0LnRwJHNldGF0dHIobXQsZSksdH0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ3cmFwcGVyXFxcIixcXFwid3JhcHBlZFxcXCIsXFxcImFzc2lnbmVkXFxcIixcXFwidXBkYXRlZFxcXCJdLERlZmF1bHRzOlt0LldSQVBQRVJfQVNTSUdOTUVOVFMsdC5XUkFQUEVSX1VQREFURVNdfSwkZG9jOlxcXCJVcGRhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIHRvIGxvb2sgbGlrZSB0aGUgd3JhcHBlZCBmdW5jdGlvblxcXFxuXFxcXG4gICAgICAgd3JhcHBlciBpcyB0aGUgZnVuY3Rpb24gdG8gYmUgdXBkYXRlZFxcXFxuICAgICAgIHdyYXBwZWQgaXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXFxcXG4gICAgICAgYXNzaWduZWQgaXMgYSB0dXBsZSBuYW1pbmcgdGhlIGF0dHJpYnV0ZXMgYXNzaWduZWQgZGlyZWN0bHlcXFxcbiAgICAgICBmcm9tIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIChkZWZhdWx0cyB0b1xcXFxuICAgICAgIGZ1bmN0b29scy5XUkFQUEVSX0FTU0lHTk1FTlRTKVxcXFxuICAgICAgIHVwZGF0ZWQgaXMgYSB0dXBsZSBuYW1pbmcgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHdyYXBwZXIgdGhhdFxcXFxuICAgICAgIGFyZSB1cGRhdGVkIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIGZyb20gdGhlIHdyYXBwZWRcXFxcbiAgICAgICBmdW5jdGlvbiAoZGVmYXVsdHMgdG8gZnVuY3Rvb2xzLldSQVBQRVJfVVBEQVRFUylcXFxcbiAgICBcXFwiLCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgLywgd3JhcHBlciwgd3JhcHBlZCwgYXNzaWduZWQ9KCdfX21vZHVsZV9fJywgJ19fbmFtZV9fJywgJ19fcXVhbG5hbWVfXycsICdfX2RvY19fJywgJ19fYW5ub3RhdGlvbnNfXycpLCB1cGRhdGVkPSgnX19kaWN0X18nLCkpXFxcIn0sd3JhcHM6eyRtZXRoOmZ1bmN0aW9uIHdyYXBzKGUsbixyKXtjb25zdCBzPVtcXFwid3JhcHBlZFxcXCIsZSxcXFwiYXNzaWduZWRcXFwiLG4sXFxcInVwZGF0ZWRcXFwiLHJdO3JldHVybiBBKHQucGFydGlhbCxbdC51cGRhdGVfd3JhcHBlcl0scyl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwid3JhcHBlZFxcXCIsXFxcImFzc2lnbmVkXFxcIixcXFwidXBkYXRlZFxcXCJdLERlZmF1bHRzOlt0LldSQVBQRVJfQVNTSUdOTUVOVFMsdC5XUkFQUEVSX1VQREFURVNdfSwkZG9jOlxcXCJEZWNvcmF0b3IgZmFjdG9yeSB0byBhcHBseSB1cGRhdGVfd3JhcHBlcigpIHRvIGEgd3JhcHBlciBmdW5jdGlvblxcXFxuXFxcXG4gICAgICAgUmV0dXJucyBhIGRlY29yYXRvciB0aGF0IGludm9rZXMgdXBkYXRlX3dyYXBwZXIoKSB3aXRoIHRoZSBkZWNvcmF0ZWRcXFxcbiAgICAgICBmdW5jdGlvbiBhcyB0aGUgd3JhcHBlciBhcmd1bWVudCBhbmQgdGhlIGFyZ3VtZW50cyB0byB3cmFwcygpIGFzIHRoZVxcXFxuICAgICAgIHJlbWFpbmluZyBhcmd1bWVudHMuIERlZmF1bHQgYXJndW1lbnRzIGFyZSBhcyBmb3IgdXBkYXRlX3dyYXBwZXIoKS5cXFxcbiAgICAgICBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2ltcGxpZnkgYXBwbHlpbmcgcGFydGlhbCgpIHRvXFxcXG4gICAgICAgdXBkYXRlX3dyYXBwZXIoKS5cXFxcbiAgICBcXFwiLCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgLywgd3JhcHBlZCwgYXNzaWduZWQ9KCdfX21vZHVsZV9fJywgJ19fbmFtZV9fJywgJ19fcXVhbG5hbWVfXycsICdfX2RvY19fJywgJ19fYW5ub3RhdGlvbnNfXycpLCB1cGRhdGVkPSgnX19kaWN0X18nLCkpXFxcIn19KSx0fVwiLFwic3JjL2xpYi9pbWFnZS5qc1wiOlwidmFyIEltYWdlTW9kLCRidWlsdGlubW9kdWxlO0ltYWdlTW9kfHwoKEltYWdlTW9kPXt9KS5jYW52YXNMaWI9W10pLCRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKGUpe3ZhciBuLHQsaSxhLHUsbCxyLHM9e19fbmFtZV9fOm5ldyBTay5idWlsdGluLnN0cihcXFwiaW1hZ2VcXFwiKX07cmV0dXJuIHMuSW1hZ2U9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhzLChmdW5jdGlvbihlLG4pe3U9ZnVuY3Rpb24oZSl7ZS53aWR0aD1lLmltYWdlLndpZHRoLGUuaGVpZ2h0PWUuaW1hZ2UuaGVpZ2h0LGUuZGVsYXk9MCxlLnVwZGF0ZUNvdW50PTAsZS51cGRhdGVJbnRlcnZhbD0xLGUubGFzdHg9MCxlLmxhc3R5PTAsZS5jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIiksZS5jYW52YXMuaGVpZ2h0PWUuaGVpZ2h0LGUuY2FudmFzLndpZHRoPWUud2lkdGgsZS5jdHg9ZS5jYW52YXMuZ2V0Q29udGV4dChcXFwiMmRcXFwiKSxlLmN0eC5kcmF3SW1hZ2UoZS5pbWFnZSwwLDApLGUuaW1hZ2VkYXRhPWUuY3R4LmdldEltYWdlRGF0YSgwLDAsZS53aWR0aCxlLmhlaWdodCl9LG4uX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuKXt2YXIgdDtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpO3RyeXtlLmltYWdlPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNrLmZmaS5yZW1hcFRvSnMobikpLG51bGw9PWUuaW1hZ2UmJihlLmltYWdlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWZpbGVuYW1lPVxcXCIke1NrLmZmaS5yZW1hcFRvSnMobil9XFxcIl1gKSksdShlKX1jYXRjaChpKXtlLmltYWdlPW51bGx9aWYobnVsbD09ZS5pbWFnZSlyZXR1cm4odD1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbikucmVzdW1lPWZ1bmN0aW9uKCl7aWYodC5kYXRhLmVycm9yKXRocm93IG5ldyBTay5idWlsdGluLklPRXJyb3IodC5kYXRhLmVycm9yLm1lc3NhZ2UpfSx0LmRhdGE9e3R5cGU6XFxcIlNrLnByb21pc2VcXFwiLHByb21pc2U6bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsaSl7dmFyIGE9bmV3IEltYWdlO2EuY3Jvc3NPcmlnaW49XFxcIlxcXCIsYS5vbmVycm9yPWZ1bmN0aW9uKCl7aShFcnJvcihcXFwiRmFpbGVkIHRvIGxvYWQgVVJMOiBcXFwiK2Euc3JjKSl9LGEub25sb2FkPWZ1bmN0aW9uKCl7ZS5pbWFnZT10aGlzLHUoZSksdCgpfSxhLnNyYz1yKG4pfSkpfSx0fSkpLHI9ZnVuY3Rpb24oZSl7bGV0IG49U2suZmZpLnJlbWFwVG9KcyhlKTt0cnl7bGV0IGU9U2sucmVhZChuKTtyZXR1cm5gZGF0YTppbWFnZS8ke24uc3Vic3RyaW5nKG4ubGFzdEluZGV4T2YoXFxcIi5cXFwiKSsxKX07YmFzZTY0LCAke2V9YH1jYXRjaCh1KXtjb25zb2xlLmxvZyhgJHtufSBpcyBub3QgaW4gdGhlIGRhdGFiYXNlICR7dX1gKX12YXIgdCxpLGE9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFNrLmltYWdlUHJveHk/U2suaW1hZ2VQcm94eTpmdW5jdGlvbihlKXtyZXR1cm4odD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIikpLmhyZWY9aSx3aW5kb3cubG9jYXRpb24uaG9zdCE9PXQuaG9zdD9Tay5pbWFnZVByb3h5K1xcXCIvXFxcIitlOmV9O3JldHVybiBpPWEoaT1Tay5mZmkucmVtYXBUb0pzKGUpKX0sbD1mdW5jdGlvbihlLG4sdCl7aWYobjwwfHx0PDB8fG4+PWUud2lkdGh8fHQ+PWUuaGVpZ2h0KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlBpeGVsIGluZGV4IG91dCBvZiByYW5nZS5cXFwiKX07dmFyIHNldGRlbGF5PWZ1bmN0aW9uKGUsbix0KXt2YXIgaTtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRkZWxheVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDMpLGUuZGVsYXk9U2suZmZpLnJlbWFwVG9KcyhuKSxpPVNrLmJ1aWx0aW4uYXNudW0kKHQpLGUudXBkYXRlSW50ZXJ2YWw9aXx8MX07bi5zZXRfZGVsYXk9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXRkZWxheSksbi5zZXREZWxheT1uZXcgU2suYnVpbHRpbi5mdW5jKHNldGRlbGF5KTt2YXIgZ2V0cGl4ZWxzPWZ1bmN0aW9uKGUpe3ZhciBuLHQ9W107Zm9yKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHBpeGVsc1xcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLG49MDtuPGUuaW1hZ2UuaGVpZ2h0KmUuaW1hZ2Uud2lkdGg7bisrKXRbbl09U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUuZ2V0UGl4ZWwsW2UsbiVlLmltYWdlLndpZHRoLE1hdGguZmxvb3Iobi9lLmltYWdlLndpZHRoKV0pO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZSh0KX07bi5nZXRfcGl4ZWxzPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0cGl4ZWxzKSxuLmdldFBpeGVscz1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHBpeGVscyksbi5nZXREYXRhPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe3ZhciBuLHQsaSxhLHUscixzLGM9W107Zm9yKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldERhdGFcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxuPTA7bjxlLmltYWdlLmhlaWdodCplLmltYWdlLndpZHRoO24rKyl0PW4lZS5pbWFnZS53aWR0aCxpPU1hdGguZmxvb3Iobi9lLmltYWdlLndpZHRoKSxsKGUsdCxpKSxzPTQqaSplLndpZHRoKzQqdCxhPWUuaW1hZ2VkYXRhLmRhdGFbc10sdT1lLmltYWdlZGF0YS5kYXRhW3MrMV0scj1lLmltYWdlZGF0YS5kYXRhW3MrMl0sY1tuXT1uZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50XyhhKSxuZXcgU2suYnVpbHRpbi5pbnRfKHUpLG5ldyBTay5idWlsdGluLmludF8ocildKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChjKX0pKTt2YXIgZ2V0cGl4ZWw9ZnVuY3Rpb24oZSxuLHQpe3ZhciBpLGEsdSxyO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRwaXhlbFxcXCIsYXJndW1lbnRzLmxlbmd0aCwzLDMpLG49U2suYnVpbHRpbi5hc251bSQobiksdD1Tay5idWlsdGluLmFzbnVtJCh0KSxsKGUsbix0KSxyPTQqdCplLndpZHRoKzQqbixpPWUuaW1hZ2VkYXRhLmRhdGFbcl0sdT1lLmltYWdlZGF0YS5kYXRhW3IrMV0sYT1lLmltYWdlZGF0YS5kYXRhW3IrMl0sU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHMuUGl4ZWwsW2ksdSxhLG4sdF0pfTtuLmdldF9waXhlbD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHBpeGVsKSxuLmdldFBpeGVsPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0cGl4ZWwpLGE9ZnVuY3Rpb24oZSxuLHQpe3ZhciBpPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uO3JldHVybiBpLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LGkuZGF0YT17dHlwZTpcXFwiU2sucHJvbWlzZVxcXCIscHJvbWlzZTpuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxhKXtlLnVwZGF0ZUNvdW50KyssZS51cGRhdGVDb3VudCVlLnVwZGF0ZUludGVydmFsPT0wPyhlLmxhc3R4K2UudXBkYXRlSW50ZXJ2YWw+PWUud2lkdGg/ZS5sYXN0Q3R4LnB1dEltYWdlRGF0YShlLmltYWdlZGF0YSxlLmxhc3RVbHgsZS5sYXN0VWx5LDAsZS5sYXN0eSxlLndpZHRoLDIpOmUubGFzdHkrZS51cGRhdGVJbnRlcnZhbD49ZS5oZWlnaHQ/ZS5sYXN0Q3R4LnB1dEltYWdlRGF0YShlLmltYWdlZGF0YSxlLmxhc3RVbHgsZS5sYXN0VWx5LGUubGFzdHgsMCwyLGUuaGVpZ2h0KTplLmxhc3RDdHgucHV0SW1hZ2VEYXRhKGUuaW1hZ2VkYXRhLGUubGFzdFVseCxlLmxhc3RVbHksTWF0aC5taW4obixlLmxhc3R4KSxNYXRoLm1pbih0LGUubGFzdHkpLE1hdGgubWF4KE1hdGguYWJzKG4tZS5sYXN0eCksMSksTWF0aC5tYXgoTWF0aC5hYnModC1lLmxhc3R5KSwxKSksZS5sYXN0eD1uLGUubGFzdHk9dCxlLmRlbGF5PjA/d2luZG93LnNldFRpbWVvdXQoaSxlLmRlbGF5KTppKCkpOmkoKX0pKX0saX07dmFyIHNldHBpeGVsPWZ1bmN0aW9uKGUsbix0LGkpe3ZhciB1O3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRwaXhlbFxcXCIsYXJndW1lbnRzLmxlbmd0aCw0LDQpLG49U2suYnVpbHRpbi5hc251bSQobiksdD1Tay5idWlsdGluLmFzbnVtJCh0KSxsKGUsbix0KSx1PTQqdCplLndpZHRoKzQqbixlLmltYWdlZGF0YS5kYXRhW3VdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShpLmdldFJlZCxbaV0pKSxlLmltYWdlZGF0YS5kYXRhW3UrMV09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGkuZ2V0R3JlZW4sW2ldKSksZS5pbWFnZWRhdGEuZGF0YVt1KzJdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShpLmdldEJsdWUsW2ldKSksZS5pbWFnZWRhdGEuZGF0YVt1KzNdPTI1NSxhKGUsbix0KX07bi5zZXRfcGl4ZWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXRwaXhlbCksbi5zZXRQaXhlbD1uZXcgU2suYnVpbHRpbi5mdW5jKHNldHBpeGVsKTt2YXIgc2V0cGl4ZWxhdD1mdW5jdGlvbihlLG4sdCl7dmFyIGksdSxyO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRwaXhlbGF0XFxcIixhcmd1bWVudHMubGVuZ3RoLDMsMyksaT0obj1Tay5idWlsdGluLmFzbnVtJChuKSklZS5pbWFnZS53aWR0aCx1PU1hdGguZmxvb3Iobi9lLmltYWdlLndpZHRoKSxsKGUsaSx1KSxyPTQqdSplLndpZHRoKzQqaSxlLmltYWdlZGF0YS5kYXRhW3JdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LmdldFJlZCxbdF0pKSxlLmltYWdlZGF0YS5kYXRhW3IrMV09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuZ2V0R3JlZW4sW3RdKSksZS5pbWFnZWRhdGEuZGF0YVtyKzJdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LmdldEJsdWUsW3RdKSksZS5pbWFnZWRhdGEuZGF0YVtyKzNdPTI1NSxhKGUsaSx1KX07bi5zZXRfcGl4ZWxfYXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXRwaXhlbGF0KSxuLnNldFBpeGVsQXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXRwaXhlbGF0KTt2YXIgdXBkYXRlcGl4ZWw9ZnVuY3Rpb24oZSxuKXt2YXIgdCxpLHU7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInVwZGF0ZXBpeGVsXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksdD1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5nZXRYLFtuXSkpLGk9U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uZ2V0WSxbbl0pKSxsKGUsdCxpKSx1PTQqaSplLndpZHRoKzQqdCxlLmltYWdlZGF0YS5kYXRhW3VdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLmdldFJlZCxbbl0pKSxlLmltYWdlZGF0YS5kYXRhW3UrMV09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uZ2V0R3JlZW4sW25dKSksZS5pbWFnZWRhdGEuZGF0YVt1KzJdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLmdldEJsdWUsW25dKSksZS5pbWFnZWRhdGEuZGF0YVt1KzNdPTI1NSxhKGUsdCxpKX07bi51cGRhdGVfcGl4ZWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyh1cGRhdGVwaXhlbCksbi51cGRhdGVQaXhlbD1uZXcgU2suYnVpbHRpbi5mdW5jKHVwZGF0ZXBpeGVsKTt2YXIgZ2V0aGVpZ2h0PWZ1bmN0aW9uKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRoZWlnaHRcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxuZXcgU2suYnVpbHRpbi5pbnRfKGUuaGVpZ2h0KX07bi5nZXRfaGVpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0aGVpZ2h0KSxuLmdldEhlaWdodD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldGhlaWdodCk7dmFyIGdldHdpZHRoPWZ1bmN0aW9uKGUsbil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHdpZHRoXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksbmV3IFNrLmJ1aWx0aW4uaW50XyhlLndpZHRoKX07bi5nZXRfd2lkdGg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXR3aWR0aCksbi5nZXRXaWR0aD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHdpZHRoKSxuLl9fZ2V0YXR0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbil7cmV0dXJuXFxcImhlaWdodFxcXCI9PT0obj1Tay5mZmkucmVtYXBUb0pzKG4pKT9Tay5idWlsdGluLmFzc2skKGUuaGVpZ2h0KTpcXFwid2lkdGhcXFwiPT09bj9Tay5idWlsdGluLmFzc2skKGUud2lkdGgpOnZvaWQgMH0pKSxuLl9fc2V0YXR0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbix0KXt0aHJvd1xcXCJoZWlnaHRcXFwiPT09KG49U2suZmZpLnJlbWFwVG9KcyhuKSl8fFxcXCJ3aWR0aFxcXCI9PT1uP25ldyBTay5idWlsdGluLkV4Y2VwdGlvbihcXFwiQ2Fubm90IGNoYW5nZSBoZWlnaHQgb3Igd2lkdGggdGhleSBjYW4gb25seSBiZSBzZXQgb24gY3JlYXRpb25cXFwiKTpuZXcgU2suYnVpbHRpbi5FeGNlcHRpb24oXFxcIlVua25vd24gYXR0cmlidXRlOiBcXFwiK24pfSkpLG4uZHJhdz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4sdCxpKXt2YXIgYTtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZHJhd1xcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDQpLChhPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKS5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSxhLmRhdGE9e3R5cGU6XFxcIlNrLnByb21pc2VcXFwiLHByb21pc2U6bmV3IFByb21pc2UoKGZ1bmN0aW9uKGEsdSl7dmFyIGw7bj1Tay5idWlsdGluLmFzbnVtJChuKSx0PVNrLmJ1aWx0aW4uYXNudW0kKHQpLGk9U2suYnVpbHRpbi5hc251bSQoaSksbD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5nZXRXaW4sW25dKS5nZXRDb250ZXh0KFxcXCIyZFxcXCIpLHZvaWQgMD09PXQmJih0PTAsaT0wKSxlLmxhc3RVbHg9dCxlLmxhc3RVbHk9aSxlLmxhc3RDdHg9bCxsLnB1dEltYWdlRGF0YShlLmltYWdlZGF0YSx0LGkpLGUuZGVsYXk+MD93aW5kb3cuc2V0VGltZW91dChhLGUuZGVsYXkpOndpbmRvdy5zZXRUaW1lb3V0KGEsMjAwKX0pKX0sYX0pKX0pLFxcXCJJbWFnZVxcXCIsW10pLGk9ZnVuY3Rpb24oZSxuKXtuLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbix0KXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLmxlbmd0aCwzLDMpLGUud2lkdGg9U2suYnVpbHRpbi5hc251bSQobiksZS5oZWlnaHQ9U2suYnVpbHRpbi5hc251bSQodCksZS5jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIiksZS5jdHg9ZS5jYW52YXMuZ2V0Q29udGV4dChcXFwiMmRcXFwiKSxlLmNhbnZhcy5oZWlnaHQ9ZS5oZWlnaHQsZS5jYW52YXMud2lkdGg9ZS53aWR0aCxlLmltYWdlZGF0YT1lLmN0eC5nZXRJbWFnZURhdGEoMCwwLGUud2lkdGgsZS5oZWlnaHQpfSkpfSxzLkVtcHR5SW1hZ2U9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhzLGksXFxcIkVtcHR5SW1hZ2VcXFwiLFtzLkltYWdlXSksdD1mdW5jdGlvbihlLG4pe24uX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuLHQsaSxhLHUpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIl9faW5pdF9fXFxcIixhcmd1bWVudHMubGVuZ3RoLDQsNiksZS5yZWQ9U2suYnVpbHRpbi5hc251bSQobiksZS5ncmVlbj1Tay5idWlsdGluLmFzbnVtJCh0KSxlLmJsdWU9U2suYnVpbHRpbi5hc251bSQoaSksZS54PVNrLmJ1aWx0aW4uYXNudW0kKGEpLGUueT1Tay5idWlsdGluLmFzbnVtJCh1KX0pKTt2YXIgZ2V0cmVkPWZ1bmN0aW9uKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRyZWRcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLmFzc2skKGUucmVkKX07bi5nZXRfcmVkPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0cmVkKSxuLmdldFJlZD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHJlZCk7dmFyIGdldGdyZWVuPWZ1bmN0aW9uKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRncmVlblxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4uYXNzayQoZS5ncmVlbil9O24uZ2V0X2dyZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0Z3JlZW4pLG4uZ2V0R3JlZW49bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXRncmVlbik7dmFyIGdldGJsdWU9ZnVuY3Rpb24oZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldGJsdWVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLmFzc2skKGUuYmx1ZSl9O24uZ2V0X2JsdWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXRibHVlKSxuLmdldEJsdWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXRibHVlKTt2YXIgZ2V0eD1mdW5jdGlvbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0eFxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4uYXNzayQoZS54KX07bi5nZXRfeD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHgpLG4uZ2V0WD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHgpO3ZhciBnZXR5PWZ1bmN0aW9uKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXR5XFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5hc3NrJChlLnkpfTtuLmdldF95PW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0eSksbi5nZXRZPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0eSk7dmFyIHNldHJlZD1mdW5jdGlvbihlLG4pe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNldHJlZFxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLGUucmVkPVNrLmJ1aWx0aW4uYXNudW0kKG4pfTtuLnNldF9yZWQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXRyZWQpLG4uc2V0UmVkPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0cmVkKTt2YXIgc2V0Z3JlZW49ZnVuY3Rpb24oZSxuKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRncmVlblxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLGUuZ3JlZW49U2suYnVpbHRpbi5hc251bSQobil9O24uc2V0X2dyZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0Z3JlZW4pLG4uc2V0R3JlZW49bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXRncmVlbik7dmFyIHNldGJsdWU9ZnVuY3Rpb24oZSxuKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRibHVlXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksZS5ibHVlPVNrLmJ1aWx0aW4uYXNudW0kKG4pfTtuLnNldF9ibHVlPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0Ymx1ZSksbi5zZXRCbHVlPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0Ymx1ZSksbi5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4pe3JldHVyblxcXCJyZWRcXFwiPT09KG49U2suZmZpLnJlbWFwVG9KcyhuKSk/U2suYnVpbHRpbi5hc3NrJChlLnJlZCk6XFxcImdyZWVuXFxcIj09PW4/U2suYnVpbHRpbi5hc3NrJChlLmdyZWVuKTpcXFwiYmx1ZVxcXCI9PT1uP1NrLmJ1aWx0aW4uYXNzayQoZS5ibHVlKTp2b2lkIDB9KSksbi5fX3NldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4sdCl7XFxcInJlZFxcXCIhPT0obj1Tay5mZmkucmVtYXBUb0pzKG4pKSYmXFxcImdyZWVuXFxcIiE9PW4mJlxcXCJibHVlXFxcIiE9PW58fChlW25dPVNrLmJ1aWx0aW4uYXNudW0kKHQpKX0pKTt2YXIgc2V0eD1mdW5jdGlvbihlLG4pe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNldHhcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxlLng9U2suYnVpbHRpbi5hc251bSQobil9O24uc2V0X3g9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXR4KSxuLnNldFg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXR4KTt2YXIgc2V0eT1mdW5jdGlvbihlLG4pe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNldHlcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxlLnk9U2suYnVpbHRpbi5hc251bSQobil9O24uc2V0X3k9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXR5KSxuLnNldFk9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXR5KSxuLl9fZ2V0aXRlbV9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIDA9PT0obj1Tay5idWlsdGluLmFzbnVtJChuKSk/ZS5yZWQ6MT09bj9lLmdyZWVuOjI9PW4/ZS5ibHVlOnZvaWQgMH0pKSxuLl9fc3RyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7cmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoXFxcIltcXFwiK2UucmVkK1xcXCIsXFxcIitlLmdyZWVuK1xcXCIsXFxcIitlLmJsdWUrXFxcIl1cXFwiKX0pKSxuLmdldENvbG9yVHVwbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuLHQpe30pKSxuLnNldFJhbmdlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbil7ZS5tYXg9U2suYnVpbHRpbi5hc251bSQobil9KSl9LHMuUGl4ZWw9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhzLHQsXFxcIlBpeGVsXFxcIixbXSksbj1mdW5jdGlvbihlLG4pe24uX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuLHQpe3ZhciBpLGEsdTtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDMpLHZvaWQgMD09PShpPUltYWdlTW9kLmNhbnZhc0xpYltTay5jYW52YXNdKT8oYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKSx1PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNrLmNhbnZhcyksZS50aGVTY3JlZW49YSx1LmFwcGVuZENoaWxkKGEpLEltYWdlTW9kLmNhbnZhc0xpYltTay5jYW52YXNdPWEsSW1hZ2VNb2QuY2FudmFzTGliW1NrLmNhbnZhc109ZS50aGVTY3JlZW4pOihlLnRoZVNjcmVlbj1pLGUudGhlU2NyZWVuLmhlaWdodD1lLnRoZVNjcmVlbi5oZWlnaHQpLHZvaWQgMCE9PW4/KGUudGhlU2NyZWVuLmhlaWdodD10LnYsZS50aGVTY3JlZW4ud2lkdGg9bi52KTooU2suYXZhaWxhYmxlSGVpZ2h0JiYoZS50aGVTY3JlZW4uaGVpZ2h0PVNrLmF2YWlsYWJsZUhlaWdodCksU2suYXZhaWxhYmxlV2lkdGgmJihlLnRoZVNjcmVlbi53aWR0aD1Tay5hdmFpbGFibGVXaWR0aCkpLGUudGhlU2NyZWVuLnN0eWxlLmRpc3BsYXk9XFxcImJsb2NrXFxcIn0pKSxuLmdldFdpbj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtyZXR1cm4gZS50aGVTY3JlZW59KSksbi5leGl0b25jbGljaz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXt2YXIgbj1lLnRoZVNjcmVlbi5pZDtlLnRoZVNjcmVlbi5vbmNsaWNrPWZ1bmN0aW9uKCl7ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobikuc3R5bGUuZGlzcGxheT1cXFwibm9uZVxcXCIsZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobikub25jbGljaz1udWxsLGRlbGV0ZSBJbWFnZU1vZC5jYW52YXNMaWJbbl19fSkpfSxzLkltYWdlV2luPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MocyxuLFxcXCJJbWFnZVdpblxcXCIsW10pLHN9O1wiLFwic3JjL2xpYi9pdGVydG9vbHMuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbih0KXt2YXIgZT17fTtmdW5jdGlvbiBjb21iaW5hdGlvbnNOZXcodCxlLGkpe2xldCByLHM7W3Isc109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3ModC50cCRuYW1lLFtcXFwiaXRlcmFibGVcXFwiLFxcXCJyXFxcIl0sZSxpLFtdKTtjb25zdCBuPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKHIpO2lmKHM9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHMsU2suYnVpbHRpbi5PdmVyRmxvd0Vycm9yKSxzPDApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiciBtdXN0IGJlIG5vbi1uZWdhdGl2ZVxcXCIpO2lmKHRoaXM9PT10KXJldHVybiBuZXcgdC5jb25zdHJ1Y3RvcihuLHMpO3tjb25zdCBlPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB0LmNvbnN0cnVjdG9yLmNhbGwoZSxuLHMpLGV9fXJldHVybiBlLmFjY3VtdWxhdGU9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuYWNjdW11bGF0ZVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGFjY3VtdWxhdGUodCxlLGkpe3RoaXMuaXRlcj10LHRoaXMuZnVuYz1lLHRoaXMudG90YWw9aSx0aGlzLnRwJGl0ZXJuZXh0PSgpPT4odGhpcy50b3RhbD1Tay5idWlsdGluLmNoZWNrTm9uZSh0aGlzLnRvdGFsKT90aGlzLml0ZXIudHAkaXRlcm5leHQoKTp0aGlzLnRvdGFsLHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsdGhpcy50b3RhbCl9LGl0ZXJuZXh0KHQpe2xldCBlPXRoaXMuaXRlci50cCRpdGVybmV4dCgpO2lmKHZvaWQgMCE9PWUpcmV0dXJuIHRoaXMudG90YWw9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMuZnVuYyxbdGhpcy50b3RhbCxlXSksdGhpcy50b3RhbH0sc2xvdHM6e3RwJGRvYzpcXFwiYWNjdW11bGF0ZShpdGVyYWJsZVssIGZ1bmMsIGluaXRpYWxdKSAtLVxcXFx4M2UgYWNjdW11bGF0ZSBvYmplY3RcXFxcblxcXFxuUmV0dXJuIHNlcmllcyBvZiBhY2N1bXVsYXRlZCBzdW1zIChvciBvdGhlciBiaW5hcnkgZnVuY3Rpb24gcmVzdWx0cykuXFxcIix0cCRuZXcodCxpKXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcImFjY3VtdWxhdGVcXFwiLHQsMCwyKTtsZXRbcixzLG5dPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJhY2N1bXVsYXRlXFxcIixbXFxcIml0ZXJhYmxlXFxcIixcXFwiZnVuY1xcXCIsXFxcImluaXRpYWxcXFwiXSx0LGksW1NrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLm5vbmUubm9uZSRdKTtpZihyPVNrLmFic3RyLml0ZXIocikscz1Tay5idWlsdGluLmNoZWNrTm9uZShzKT9uZXcgU2suYnVpbHRpbi5mdW5jKCgodCxlKT0+U2suYWJzdHIubnVtYmVyQmluT3AodCxlLFxcXCJBZGRcXFwiKSkpOnMsdGhpcz09PWUuYWNjdW11bGF0ZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLmFjY3VtdWxhdGUocixzLG4pO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmFjY3VtdWxhdGUuY2FsbCh0LHIscyxuKSx0fX19fSksZS5jaGFpbj1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5jaGFpblxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGNoYWluKHQpe3RoaXMuaXRlcmFibGVzPXQsdGhpcy5jdXJyZW50X2l0PW51bGwsdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsdGhpcy5jdXJyZW50X2l0PXRoaXMuaXRlcmFibGVzLnRwJGl0ZXJuZXh0KCksdm9pZCAwIT09dGhpcy5jdXJyZW50X2l0KXJldHVybiB0aGlzLmN1cnJlbnRfaXQ9U2suYWJzdHIuaXRlcih0aGlzLmN1cnJlbnRfaXQpLHRoaXMudHAkaXRlcm5leHQoKTt0aGlzLnRwJGl0ZXJuZXh0PSgpPT57fX19LGl0ZXJuZXh0KHQpe2xldCBlO2Zvcig7dm9pZCAwPT09ZTspe2lmKGU9dGhpcy5jdXJyZW50X2l0LnRwJGl0ZXJuZXh0KCksdm9pZCAwIT09ZSlyZXR1cm4gZTtpZih0aGlzLmN1cnJlbnRfaXQ9dGhpcy5pdGVyYWJsZXMudHAkaXRlcm5leHQoKSx2b2lkIDA9PT10aGlzLmN1cnJlbnRfaXQpcmV0dXJuIHZvaWQodGhpcy50cCRpdGVybmV4dD0oKT0+e30pO3RoaXMuY3VycmVudF9pdD1Tay5hYnN0ci5pdGVyKHRoaXMuY3VycmVudF9pdCl9fSxzbG90czp7dHAkZG9jOlxcXCJjaGFpbigqaXRlcmFibGVzKSAtLVxcXFx4M2UgY2hhaW4gb2JqZWN0XFxcXG5cXFxcblJldHVybiBhIGNoYWluIG9iamVjdCB3aG9zZSAuX19uZXh0X18oKSBtZXRob2QgcmV0dXJucyBlbGVtZW50cyBmcm9tIHRoZVxcXFxuZmlyc3QgaXRlcmFibGUgdW50aWwgaXQgaXMgZXhoYXVzdGVkLCB0aGVuIGVsZW1lbnRzIGZyb20gdGhlIG5leHRcXFxcbml0ZXJhYmxlLCB1bnRpbCBhbGwgb2YgdGhlIGl0ZXJhYmxlcyBhcmUgZXhoYXVzdGVkLlxcXCIsdHAkbmV3KHQsaSl7aWYoU2suYWJzdHIuY2hlY2tOb0t3YXJncyhcXFwiY2hhaW5cXFwiLGkpLHQ9bmV3IFNrLmJ1aWx0aW4udHVwbGUodC5zbGljZSgwKSkudHAkaXRlcigpLHRoaXM9PT1lLmNoYWluLnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuY2hhaW4odCk7e2NvbnN0IGk9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuY2hhaW4uY2FsbChpLHQpLGl9fX0sY2xhc3NtZXRob2RzOk9iamVjdC5hc3NpZ24oe2Zyb21faXRlcmFibGU6eyRtZXRoKHQpe2NvbnN0IGk9U2suYWJzdHIuaXRlcih0KTtyZXR1cm4gbmV3IGUuY2hhaW4oaSl9LCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlxcXCJjaGFpbi5mcm9tX2l0ZXJhYmxlKGl0ZXJhYmxlKSAtLVxcXFx4M2UgY2hhaW4gb2JqZWN0XFxcXG5cXFxcbkFsdGVybmF0ZSBjaGFpbigpIGNvbnN0cnVjdG9yIHRha2luZyBhIHNpbmdsZSBpdGVyYWJsZSBhcmd1bWVudFxcXFxudGhhdCBldmFsdWF0ZXMgbGF6aWx5LlxcXCIsJHRleHRzaWc6bnVsbH19LFNrLmdlbmVyaWMuY2xhc3NHZXRJdGVtKX0pLGUuY29tYmluYXRpb25zPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmNvbWJpbmF0aW9uc1xcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGNvbWJpbmF0aW9ucyh0LGUpe3RoaXMucG9vbD10LHRoaXMucj1lLHRoaXMuaW5kaWNlcz1uZXcgQXJyYXkoZSkuZmlsbCgpLm1hcCgoKHQsZSk9PmUpKSx0aGlzLm49dC5sZW5ndGgsdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKCEodGhpcy5yPnRoaXMubikpcmV0dXJuIHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsbmV3IFNrLmJ1aWx0aW4udHVwbGUodGhpcy5wb29sLnNsaWNlKDAsdGhpcy5yKSl9fSxpdGVybmV4dCh0KXtsZXQgZSxpPSExO2ZvcihlPXRoaXMuci0xO2U+PTA7ZS0tKWlmKHRoaXMuaW5kaWNlc1tlXSE9ZSt0aGlzLm4tdGhpcy5yKXtpPSEwO2JyZWFrfWlmKCFpKXJldHVybiB2b2lkKHRoaXMucj0wKTt0aGlzLmluZGljZXNbZV0rKztmb3IobGV0IHM9ZSsxO3M8dGhpcy5yO3MrKyl0aGlzLmluZGljZXNbc109dGhpcy5pbmRpY2VzW3MtMV0rMTtjb25zdCByPXRoaXMuaW5kaWNlcy5tYXAoKHQ9PnRoaXMucG9vbFt0XSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShyKX0sc2xvdHM6e3RwJGRvYzpcXFwiY29tYmluYXRpb25zKGl0ZXJhYmxlLCByKSAtLVxcXFx4M2UgY29tYmluYXRpb25zIG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gc3VjY2Vzc2l2ZSByLWxlbmd0aCBjb21iaW5hdGlvbnMgb2YgZWxlbWVudHMgaW4gdGhlIGl0ZXJhYmxlLlxcXFxuXFxcXG5jb21iaW5hdGlvbnMocmFuZ2UoNCksIDMpIC0tXFxcXHgzZSAoMCwxLDIpLCAoMCwxLDMpLCAoMCwyLDMpLCAoMSwyLDMpXFxcIix0cCRuZXcodCxpKXtyZXR1cm4gY29tYmluYXRpb25zTmV3LmNhbGwodGhpcyxlLmNvbWJpbmF0aW9ucy5wcm90b3R5cGUsdCxpKX19fSksZS5jb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5jb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGNvbWJpbmF0aW9uc193aXRoX3JlcGxhY2VtZW50KHQsZSl7dGhpcy5wb29sPXQsdGhpcy5yPWUsdGhpcy5pbmRpY2VzPW5ldyBBcnJheShlKS5maWxsKDApLHRoaXMubj10Lmxlbmd0aCx0aGlzLnRwJGl0ZXJuZXh0PSgpPT57aWYodGhpcy5yJiYhdGhpcy5uKXJldHVybjt0aGlzLnRwJGl0ZXJuZXh0PXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRwJGl0ZXJuZXh0O2NvbnN0IHQ9dGhpcy5pbmRpY2VzLm1hcCgodD0+dGhpcy5wb29sW3RdKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKHQpfX0saXRlcm5leHQodCl7bGV0IGUsaT0hMTtmb3IoZT10aGlzLnItMTtlPj0wO2UtLSlpZih0aGlzLmluZGljZXNbZV0hPXRoaXMubi0xKXtpPSEwO2JyZWFrfWlmKCFpKXJldHVybiB2b2lkKHRoaXMucj0wKTtjb25zdCByPXRoaXMuaW5kaWNlc1tlXSsxO2ZvcihsZXQgbj1lO248dGhpcy5yO24rKyl0aGlzLmluZGljZXNbbl09cjtjb25zdCBzPXRoaXMuaW5kaWNlcy5tYXAoKHQ9PnRoaXMucG9vbFt0XSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShzKX0sc2xvdHM6e3RwJGRvYzpcXFwiY29tYmluYXRpb25zX3dpdGhfcmVwbGFjZW1lbnQoaXRlcmFibGUsIHIpIC0tXFxcXHgzZSBjb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudCBvYmplY3RcXFxcblxcXFxuUmV0dXJuIHN1Y2Nlc3NpdmUgci1sZW5ndGggY29tYmluYXRpb25zIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYWJsZVxcXFxuYWxsb3dpbmcgaW5kaXZpZHVhbCBlbGVtZW50cyB0byBoYXZlIHN1Y2Nlc3NpdmUgcmVwZWF0cy5cXFxcbmNvbWJpbmF0aW9uc193aXRoX3JlcGxhY2VtZW50KCdBQkMnLCAyKSAtLVxcXFx4M2UgQUEgQUIgQUMgQkIgQkMgQ0NcXFwiLHRwJG5ldyh0LGkpe3JldHVybiBjb21iaW5hdGlvbnNOZXcuY2FsbCh0aGlzLGUuY29tYmluYXRpb25zX3dpdGhfcmVwbGFjZW1lbnQucHJvdG90eXBlLHQsaSl9fX0pLGUuY29tcHJlc3M9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuY29tcHJlc3NcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBjb21wcmVzcyh0LGUpe3RoaXMuZGF0YT10LHRoaXMuc2VsZWN0b3JzPWV9LGl0ZXJuZXh0KCl7bGV0IHQ9dGhpcy5kYXRhLnRwJGl0ZXJuZXh0KCksZT10aGlzLnNlbGVjdG9ycy50cCRpdGVybmV4dCgpO2Zvcig7dm9pZCAwIT09dCYmdm9pZCAwIT09ZTspe2lmKFNrLm1pc2NldmFsLmlzVHJ1ZShlKSlyZXR1cm4gdDt0PXRoaXMuZGF0YS50cCRpdGVybmV4dCgpLGU9dGhpcy5zZWxlY3RvcnMudHAkaXRlcm5leHQoKX19LHNsb3RzOnt0cCRkb2M6XFxcImNvbXByZXNzKGRhdGEsIHNlbGVjdG9ycykgLS1cXFxceDNlIGl0ZXJhdG9yIG92ZXIgc2VsZWN0ZWQgZGF0YVxcXFxuXFxcXG5SZXR1cm4gZGF0YSBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRydWUgc2VsZWN0b3IgZWxlbWVudHMuXFxcXG5Gb3JtcyBhIHNob3J0ZXIgaXRlcmF0b3IgZnJvbSBzZWxlY3RlZCBkYXRhIGVsZW1lbnRzIHVzaW5nIHRoZVxcXFxuc2VsZWN0b3JzIHRvIGNob29zZSB0aGUgZGF0YSBlbGVtZW50cy5cXFwiLHRwJG5ldyh0LGkpe2xldCByLHM7aWYoW3Isc109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcImNvbXByZXNzXFxcIixbXFxcImRhdGFcXFwiLFxcXCJzZWxlY3RvcnNcXFwiXSx0LGksW10pLHI9U2suYWJzdHIuaXRlcihyKSxzPVNrLmFic3RyLml0ZXIocyksdGhpcz09PWUuY291bnQucHJvdG90eXBlKXJldHVybiBuZXcgZS5jb21wcmVzcyhyLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmNvbXByZXNzLmNhbGwodCxyLHMpLHR9fX19KSxlLmNvdW50PVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmNvdW50XFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gY291bnQodCxlKXt0aGlzLnN0YXJ0PXQsdGhpcy5zdGVwPWV9LGl0ZXJuZXh0KCl7Y29uc3QgdD10aGlzLnN0YXJ0O3JldHVybiB0aGlzLnN0YXJ0PVNrLmFic3RyLm51bWJlckJpbk9wKHRoaXMuc3RhcnQsdGhpcy5zdGVwLFxcXCJBZGRcXFwiKSx0fSxzbG90czp7dHAkZG9jOlxcXCJjb3VudChzdGFydD0wLCBzdGVwPTEpIC0tXFxcXHgzZSBjb3VudCBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGEgY291bnQgb2JqZWN0IHdob3NlIC5fX25leHRfXygpIG1ldGhvZCByZXR1cm5zIGNvbnNlY3V0aXZlIHZhbHVlcy5cXFxcbkVxdWl2YWxlbnQgdG86XFxcXG5cXFxcbiAgICBkZWYgY291bnQoZmlyc3R2YWw9MCwgc3RlcD0xKTpcXFxcbiAgICAgICAgeCA9IGZpcnN0dmFsXFxcXG4gICAgICAgIHdoaWxlIDE6XFxcXG4gICAgICAgICAgICB5aWVsZCB4XFxcXG4gICAgICAgICAgICB4ICs9IHN0ZXBcXFxcblxcXCIsdHAkbmV3KHQsaSl7Y29uc3RbcixzXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwiY291bnRcXFwiLFtcXFwic3RhcnRcXFwiLFxcXCJzdGVwXFxcIl0sdCxpLFtuZXcgU2suYnVpbHRpbi5pbnRfKDApLG5ldyBTay5idWlsdGluLmludF8oMSldKTtpZighU2suYnVpbHRpbi5jaGVja051bWJlcihyKSYmIVNrLmJ1aWx0aW4uY2hlY2tDb21wbGV4KHIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiYSBudW1iZXIgaXMgcmVxdWlyZWRcXFwiKTtpZighU2suYnVpbHRpbi5jaGVja051bWJlcihzKSYmIVNrLmJ1aWx0aW4uY2hlY2tDb21wbGV4KHMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiYSBudW1iZXIgaXMgcmVxdWlyZWRcXFwiKTtpZih0aGlzPT09ZS5jb3VudC5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLmNvdW50KHIscyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuY291bnQuY2FsbCh0LHIscyksdH19LCRyKCl7Y29uc3QgdD1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMuc3RhcnQpO2xldCBlPVNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5zdGVwKTtyZXR1cm4gZT1cXFwiMVxcXCI9PT1lP1xcXCJcXFwiOlxcXCIsIFxcXCIrZSxuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXFxcIihcXFwiK3QrZStcXFwiKVxcXCIpfX19KSxlLmN5Y2xlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmN5Y2xlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gY3ljbGUodCl7dGhpcy5pdGVyPXQsdGhpcy5zYXZlZD1bXSx0aGlzLmNvbnN1bWVkPSExLHRoaXMuaT0wLHRoaXMubGVuZ3RofSxpdGVybmV4dCgpe2xldCB0O2lmKCF0aGlzLmNvbnN1bWVkKXtpZih0PXRoaXMuaXRlci50cCRpdGVybmV4dCgpLHZvaWQgMCE9PXQpcmV0dXJuIHRoaXMuc2F2ZWQucHVzaCh0KSx0O2lmKHRoaXMuY29uc3VtZWQ9ITAsdGhpcy5sZW5ndGg9dGhpcy5zYXZlZC5sZW5ndGgsIXRoaXMubGVuZ3RoKXJldHVybn1yZXR1cm4gdD10aGlzLnNhdmVkW3RoaXMuaV0sdGhpcy5pPSh0aGlzLmkrMSkldGhpcy5sZW5ndGgsdH0sc2xvdHM6e3RwJGRvYzpcXFwiY3ljbGUoaXRlcmFibGUpIC0tXFxcXHgzZSBjeWNsZSBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGVsZW1lbnRzIGZyb20gdGhlIGl0ZXJhYmxlIHVudGlsIGl0IGlzIGV4aGF1c3RlZC5cXFxcblRoZW4gcmVwZWF0IHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXFxcIix0cCRuZXcodCxpKXtTay5hYnN0ci5jaGVja09uZUFyZyhcXFwiY3ljbGVcXFwiLHQsaSk7Y29uc3Qgcj1Tay5hYnN0ci5pdGVyKHRbMF0pO2lmKHRoaXM9PT1lLmN5Y2xlLnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuY3ljbGUocik7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuY3ljbGUuY2FsbCh0LHIpLHR9fX19KSxlLmRyb3B3aGlsZT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5kcm9wd2hpbGVcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBkcm9wd2hpbGUodCxlKXt0aGlzLnByZWRpY2F0ZT10LHRoaXMuaXRlcj1lLHRoaXMucGFzc2VkfSxpdGVybmV4dCgpe2xldCB0PXRoaXMuaXRlci50cCRpdGVybmV4dCgpO2Zvcig7dm9pZCAwPT09dGhpcy5wYXNzZWQmJnZvaWQgMCE9PXQ7KXtjb25zdCBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLnByZWRpY2F0ZSxbdF0pO2lmKCFTay5taXNjZXZhbC5pc1RydWUoZSkpcmV0dXJuIHRoaXMucGFzc2VkPSEwLHQ7dD10aGlzLml0ZXIudHAkaXRlcm5leHQoKX1yZXR1cm4gdH0sc2xvdHM6e3RwJGRvYzpcXFwiZHJvcHdoaWxlKHByZWRpY2F0ZSwgaXRlcmFibGUpIC0tXFxcXHgzZSBkcm9wd2hpbGUgb2JqZWN0XFxcXG5cXFxcbkRyb3AgaXRlbXMgZnJvbSB0aGUgaXRlcmFibGUgd2hpbGUgcHJlZGljYXRlKGl0ZW0pIGlzIHRydWUuXFxcXG5BZnRlcndhcmRzLCByZXR1cm4gZXZlcnkgZWxlbWVudCB1bnRpbCB0aGUgaXRlcmFibGUgaXMgZXhoYXVzdGVkLlxcXCIsdHAkbmV3KHQsaSl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcXFwiZHJvcHdoaWxlXFxcIixpKSxTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcImRyb3B3aGlsZVxcXCIsdCwyLDIpO2NvbnN0IHI9dFswXSxzPVNrLmFic3RyLml0ZXIodFsxXSk7aWYodGhpcz09PWUuZHJvcHdoaWxlLnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuZHJvcHdoaWxlKHIscyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuZHJvcHdoaWxlLmNhbGwodCxyLHMpLHR9fX19KSxlLmZpbHRlcmZhbHNlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmZpbHRlcmZhbHNlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gZmlsdGVyZmFsc2UodCxlKXt0aGlzLnByZWRpY2F0ZT10LHRoaXMuaXRlcj1lfSxpdGVybmV4dCh0KXtsZXQgZT10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtpZih2b2lkIDA9PT1lKXJldHVybjtsZXQgaT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5wcmVkaWNhdGUsW2VdKTtmb3IoO1NrLm1pc2NldmFsLmlzVHJ1ZShpKTspe2lmKGU9dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCksdm9pZCAwPT09ZSlyZXR1cm47aT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5wcmVkaWNhdGUsW2VdKX1yZXR1cm4gZX0sc2xvdHM6e3RwJGRvYzpcXFwiZmlsdGVyZmFsc2UoZnVuY3Rpb24gb3IgTm9uZSwgc2VxdWVuY2UpIC0tXFxcXHgzZSBmaWx0ZXJmYWxzZSBvYmplY3RcXFxcblxcXFxuUmV0dXJuIHRob3NlIGl0ZW1zIG9mIHNlcXVlbmNlIGZvciB3aGljaCBmdW5jdGlvbihpdGVtKSBpcyBmYWxzZS5cXFxcbklmIGZ1bmN0aW9uIGlzIE5vbmUsIHJldHVybiB0aGUgaXRlbXMgdGhhdCBhcmUgZmFsc2UuXFxcIix0cCRuZXcodCxpKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFxcXCJmaWx0ZXJmYWxzZVxcXCIsaSksU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJmaWx0ZXJmYWxzZVxcXCIsdCwyLDIpO2NvbnN0IHI9U2suYnVpbHRpbi5jaGVja05vbmUodFswXSk/U2suYnVpbHRpbi5ib29sOnRbMF0scz1Tay5hYnN0ci5pdGVyKHRbMV0pO2lmKHRoaXM9PT1lLmZpbHRlcmZhbHNlLnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuZmlsdGVyZmFsc2UocixzKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS5maWx0ZXJmYWxzZS5jYWxsKHQscixzKSx0fX19fSksZS5fZ3JvdXBlcj1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5fZ3JvdXBlclxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIF9ncm91cGVyKHQsZSl7dGhpcy5ncm91cGJ5PXQsdGhpcy50Z3RrZXk9dC50Z3RrZXksdGhpcy5pZD10LmlkfSxpdGVybmV4dCh0KXtjb25zdCBlPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLmdyb3VwYnkuY3VycmtleSx0aGlzLnRndGtleSxcXFwiRXFcXFwiKTtpZih0aGlzLmdyb3VwYnkuaWQ9PT10aGlzLmlkJiZlKXtsZXQgdD10aGlzLmdyb3VwYnkuY3VycnZhbDtyZXR1cm4gdGhpcy5ncm91cGJ5LmN1cnJ2YWw9dGhpcy5ncm91cGJ5Lml0ZXIudHAkaXRlcm5leHQoKSx2b2lkIDAhPT10aGlzLmdyb3VwYnkuY3VycnZhbCYmKHRoaXMuZ3JvdXBieS5jdXJya2V5PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLmdyb3VwYnkua2V5ZixbdGhpcy5ncm91cGJ5LmN1cnJ2YWxdKSksdH19fSksZS5ncm91cGJ5PVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmdyb3VwYnlcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBncm91cGJ5KHQsZSl7dGhpcy5pdGVyPXQsdGhpcy5rZXlmPWUsdGhpcy5jdXJydmFsLHRoaXMuY3VycmtleT10aGlzLnRndGtleT1uZXcgU2suYnVpbHRpbi5vYmplY3QsdGhpcy5pZH0saXRlcm5leHQodCl7dGhpcy5pZD1uZXcgT2JqZWN0O2xldCBpPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLmN1cnJrZXksdGhpcy50Z3RrZXksXFxcIkVxXFxcIik7Zm9yKDtpOyl7aWYodGhpcy5jdXJydmFsPXRoaXMuaXRlci50cCRpdGVybmV4dCgpLHZvaWQgMD09PXRoaXMuY3VycnZhbClyZXR1cm47dGhpcy5jdXJya2V5PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLmtleWYsW3RoaXMuY3VycnZhbF0pLGk9U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHRoaXMuY3VycmtleSx0aGlzLnRndGtleSxcXFwiRXFcXFwiKX10aGlzLnRndGtleT10aGlzLmN1cnJrZXk7Y29uc3Qgcj1uZXcgZS5fZ3JvdXBlcih0aGlzKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3RoaXMuY3VycmtleSxyXSl9LHNsb3RzOnt0cCRkb2M6XFxcImdyb3VwYnkoaXRlcmFibGUsIGtleT1Ob25lKSAtPiBtYWtlIGFuIGl0ZXJhdG9yIHRoYXQgcmV0dXJucyBjb25zZWN1dGl2ZVxcXFxua2V5cyBhbmQgZ3JvdXBzIGZyb20gdGhlIGl0ZXJhYmxlLiAgSWYgdGhlIGtleSBmdW5jdGlvbiBpcyBub3Qgc3BlY2lmaWVkIG9yXFxcXG5pcyBOb25lLCB0aGUgZWxlbWVudCBpdHNlbGYgaXMgdXNlZCBmb3IgZ3JvdXBpbmcuXFxcXG5cXFwiLHRwJG5ldyh0LGkpe2xldCByLHM7aWYoW3Isc109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcImdyb3VwYnlcXFwiLFtcXFwiaXRlcmFibGVcXFwiLFxcXCJrZXlcXFwiXSx0LGksW1NrLmJ1aWx0aW4ubm9uZS5ub25lJF0pLHI9U2suYWJzdHIuaXRlcihyKSxzPVNrLmJ1aWx0aW4uY2hlY2tOb25lKHMpP25ldyBTay5idWlsdGluLmZ1bmMoKHQ9PnQpKTpzLHRoaXM9PT1lLmdyb3VwYnkucHJvdG90eXBlKXJldHVybiBuZXcgZS5ncm91cGJ5KHIscyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuZ3JvdXBieS5jYWxsKHQscixzKSx0fX19fSksZS5pc2xpY2U9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuaXNsaWNlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gaXNsaWNlKHQsZSxpLHIpe3RoaXMuaXRlcj10LHRoaXMucHJldml0PWUsdGhpcy5zdG9wPWksdGhpcy5zdGVwPXIsdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsISh0aGlzLnByZXZpdD49dGhpcy5zdG9wKSl7Zm9yKGxldCB0PTA7dDx0aGlzLnByZXZpdDt0KyspdGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCk7cmV0dXJuIHRoaXMuaXRlci50cCRpdGVybmV4dCgpfWZvcihsZXQgdD0wO3Q8dGhpcy5zdG9wO3QrKyl0aGlzLml0ZXIudHAkaXRlcm5leHQoKX19LGl0ZXJuZXh0KHQpe2lmKCEodGhpcy5wcmV2aXQrdGhpcy5zdGVwPj10aGlzLnN0b3ApKXtmb3IobGV0IHQ9dGhpcy5wcmV2aXQrMTt0PHRoaXMucHJldml0K3RoaXMuc3RlcDt0KyspdGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCk7cmV0dXJuIHRoaXMucHJldml0Kz10aGlzLnN0ZXAsdGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCl9Zm9yKGxldCBlPXRoaXMucHJldml0KzE7ZTx0aGlzLnN0b3A7ZSsrKXRoaXMucHJldml0Kz10aGlzLnN0ZXAsdGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCl9LHNsb3RzOnt0cCRkb2M6XFxcImlzbGljZShpdGVyYWJsZSwgc3RvcCkgLS1cXFxceDNlIGlzbGljZSBvYmplY3RcXFxcbmlzbGljZShpdGVyYWJsZSwgc3RhcnQsIHN0b3BbLCBzdGVwXSkgLS1cXFxceDNlIGlzbGljZSBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGFuIGl0ZXJhdG9yIHdob3NlIG5leHQoKSBtZXRob2QgcmV0dXJucyBzZWxlY3RlZCB2YWx1ZXMgZnJvbSBhblxcXFxuaXRlcmFibGUuICBJZiBzdGFydCBpcyBzcGVjaWZpZWQsIHdpbGwgc2tpcCBhbGwgcHJlY2VkaW5nIGVsZW1lbnRzO1xcXFxub3RoZXJ3aXNlLCBzdGFydCBkZWZhdWx0cyB0byB6ZXJvLiAgU3RlcCBkZWZhdWx0cyB0byBvbmUuICBJZlxcXFxuc3BlY2lmaWVkIGFzIGFub3RoZXIgdmFsdWUsIHN0ZXAgZGV0ZXJtaW5lcyBob3cgbWFueSB2YWx1ZXMgYXJlIFxcXFxuc2tpcHBlZCBiZXR3ZWVuIHN1Y2Nlc3NpdmUgY2FsbHMuICBXb3JrcyBsaWtlIGEgc2xpY2UoKSBvbiBhIGxpc3RcXFxcbmJ1dCByZXR1cm5zIGFuIGl0ZXJhdG9yLlxcXCIsdHAkbmV3KHQsaSl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcXFwiaXNsaWNlXFxcIixpKSxTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcImlzbGljZVxcXCIsdCwyLDQpO2NvbnN0IHI9U2suYWJzdHIuaXRlcih0WzBdKTtsZXQgcz10WzFdLG49dFsyXSxvPXRbM107aWYodm9pZCAwPT09bj8obj1zLHM9U2suYnVpbHRpbi5ub25lLm5vbmUkLG89U2suYnVpbHRpbi5ub25lLm5vbmUkKTp2b2lkIDA9PT1vJiYobz1Tay5idWlsdGluLm5vbmUubm9uZSQpLCFTay5idWlsdGluLmNoZWNrTm9uZShuKSYmIVNrLm1pc2NldmFsLmlzSW5kZXgobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiU3RvcCBmb3IgaXNsaWNlKCkgbXVzdCBiZSBOb25lIG9yIGFuIGludGVnZXI6IDAgPD0geCA8PSBzeXMubWF4c2l6ZS5cXFwiKTtpZihuPVNrLmJ1aWx0aW4uY2hlY2tOb25lKG4pP051bWJlci5NQVhfU0FGRV9JTlRFR0VSOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChuKSxuPDB8fG4+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiU3RvcCBmb3IgaXNsaWNlKCkgbXVzdCBiZSBOb25lIG9yIGFuIGludGVnZXI6IDAgPD0geCA8PSBzeXMubWF4c2l6ZS5cXFwiKTtpZighU2suYnVpbHRpbi5jaGVja05vbmUocykmJiFTay5taXNjZXZhbC5pc0luZGV4KHMpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkluZGljZXMgZm9yIGlzbGljZSgpIG11c3QgYmUgTm9uZSBvciBhbiBpbnRlZ2VyOiAwIDw9IHggPD0gc3lzLm1heHNpemUuXFxcIik7aWYocz1Tay5idWlsdGluLmNoZWNrTm9uZShzKT8wOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChzKSxzPDB8fHM+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiSW5kaWNlcyBmb3IgaXNsaWNlKCkgbXVzdCBiZSBOb25lIG9yIGFuIGludGVnZXI6IDAgPD0geCA8PSBzeXMubWF4c2l6ZS5cXFwiKTtpZighU2suYnVpbHRpbi5jaGVja05vbmUobykmJiFTay5taXNjZXZhbC5pc0luZGV4KG8pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlN0ZXAgZm9yIGlzbGljZSgpIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIE5vbmVcXFwiKTtpZihvPVNrLmJ1aWx0aW4uY2hlY2tOb25lKG8pPzE6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKG8pLG88PTB8fG8+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiU3RlcCBmb3IgaXNsaWNlKCkgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgTm9uZS5cXFwiKTtpZih0aGlzPT09ZS5pc2xpY2UucHJvdG90eXBlKXJldHVybiBuZXcgZS5pc2xpY2UocixzLG4sbyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuaXNsaWNlLmNhbGwodCxyLHMsbixvKSx0fX19fSksZS5wZXJtdXRhdGlvbnM9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMucGVybXV0YXRpb25zXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gcGVybXV0YXRpb25zKHQsZSl7dGhpcy5wb29sPXQsdGhpcy5yPWU7Y29uc3QgaT10Lmxlbmd0aDt0aGlzLmluZGljZXM9bmV3IEFycmF5KGkpLmZpbGwoKS5tYXAoKCh0LGUpPT5lKSksdGhpcy5jeWNsZXM9bmV3IEFycmF5KGUpLmZpbGwoKS5tYXAoKCh0LGUpPT5pLWUpKSx0aGlzLm49aSx0aGlzLnRwJGl0ZXJuZXh0PSgpPT57aWYoISh0aGlzLnI+dGhpcy5uKSlyZXR1cm4gdGhpcy50cCRpdGVybmV4dD10aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS50cCRpdGVybmV4dCxuZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLnBvb2wuc2xpY2UoMCx0aGlzLnIpKX19LGl0ZXJuZXh0KHQpe2ZvcihsZXQgZT10aGlzLnItMTtlPj0wO2UtLSl7aWYodGhpcy5jeWNsZXNbZV0tLSwwIT10aGlzLmN5Y2xlc1tlXSl7Y29uc3QgdD10aGlzLmN5Y2xlc1tlXTtbdGhpcy5pbmRpY2VzW2VdLHRoaXMuaW5kaWNlc1t0aGlzLm4tdF1dPVt0aGlzLmluZGljZXNbdGhpcy5uLXRdLHRoaXMuaW5kaWNlc1tlXV07Y29uc3QgaT10aGlzLmluZGljZXMubWFwKCh0PT50aGlzLnBvb2xbdF0pKS5zbGljZSgwLHRoaXMucik7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKGkpfXRoaXMuaW5kaWNlcy5wdXNoKHRoaXMuaW5kaWNlcy5zcGxpY2UoZSwxKVswXSksdGhpcy5jeWNsZXNbZV09dGhpcy5uLWV9dGhpcy5yPTB9LHNsb3RzOnt0cCRkb2M6XFxcInBlcm11dGF0aW9ucyhpdGVyYWJsZVssIHJdKSAtLVxcXFx4M2UgcGVybXV0YXRpb25zIG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gc3VjY2Vzc2l2ZSByLWxlbmd0aCBwZXJtdXRhdGlvbnMgb2YgZWxlbWVudHMgaW4gdGhlIGl0ZXJhYmxlLlxcXFxuXFxcXG5wZXJtdXRhdGlvbnMocmFuZ2UoMyksIDIpIC0tXFxcXHgzZSAoMCwxKSwgKDAsMiksICgxLDApLCAoMSwyKSwgKDIsMCksICgyLDEpXFxcIix0cCRuZXcodCxpKXtsZXQgcixzO1tyLHNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJwZXJtdXRhdGlvbnNcXFwiLFtcXFwiaXRlcmFibGVcXFwiLFxcXCJyXFxcIl0sdCxpLFtTay5idWlsdGluLm5vbmUubm9uZSRdKTtjb25zdCBuPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKHIpO2lmKHM9U2suYnVpbHRpbi5jaGVja05vbmUocyk/bi5sZW5ndGg6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHMsU2suYnVpbHRpbi5PdmVyRmxvd0Vycm9yKSxzPDApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiciBtdXN0IGJlIG5vbi1uZWdhdGl2ZVxcXCIpO2lmKHRoaXM9PT1lLnBlcm11dGF0aW9ucy5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLnBlcm11dGF0aW9ucyhuLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLnBlcm11dGF0aW9ucy5jYWxsKHQsbixzKSx0fX19fSksZS5wcm9kdWN0PVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnByb2R1Y3RcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBwcm9kdWN0KHQpe3RoaXMucG9vbHM9dCx0aGlzLm49dC5sZW5ndGgsdGhpcy5pbmRpY2VzPUFycmF5KHQubGVuZ3RoKS5maWxsKDApLHRoaXMucG9vbF9zaXplcz10Lm1hcCgodD0+dC5sZW5ndGgpKSx0aGlzLnRwJGl0ZXJuZXh0PSgpPT57dGhpcy50cCRpdGVybmV4dD10aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS50cCRpdGVybmV4dDtjb25zdCB0PXRoaXMuaW5kaWNlcy5tYXAoKCh0LGUpPT50aGlzLnBvb2xzW2VdW3RoaXMuaW5kaWNlc1tlXV0pKTtpZighdC5zb21lKCh0PT52b2lkIDA9PT10KSkpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKHQpO3RoaXMubj0wfX0saXRlcm5leHQodCl7bGV0IGU9dGhpcy5uLTE7Zm9yKDtlPj0wJiZlPHRoaXMubjspdGhpcy5pbmRpY2VzW2VdKyssdGhpcy5pbmRpY2VzW2VdPj10aGlzLnBvb2xfc2l6ZXNbZV0/KHRoaXMuaW5kaWNlc1tlXT0tMSxlLS0pOmUrKztpZih0aGlzLm4mJiF0aGlzLmluZGljZXMuZXZlcnkoKHQ9Pi0xPT09dCkpKXtjb25zdCB0PXRoaXMuaW5kaWNlcy5tYXAoKCh0LGUpPT50aGlzLnBvb2xzW2VdW3RoaXMuaW5kaWNlc1tlXV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUodCl9dGhpcy5uPTB9LHNsb3RzOnt0cCRkb2M6XFxcInByb2R1Y3QoKml0ZXJhYmxlcywgcmVwZWF0PTEpIC0tXFxcXHgzZSBwcm9kdWN0IG9iamVjdFxcXFxuXFxcXG5DYXJ0ZXNpYW4gcHJvZHVjdCBvZiBpbnB1dCBpdGVyYWJsZXMuICBFcXVpdmFsZW50IHRvIG5lc3RlZCBmb3ItbG9vcHMuXFxcXG5cXFxcbkZvciBleGFtcGxlLCBwcm9kdWN0KEEsIEIpIHJldHVybnMgdGhlIHNhbWUgYXM6ICAoKHgseSkgZm9yIHggaW4gQSBmb3IgeSBpbiBCKS5cXFxcblRoZSBsZWZ0bW9zdCBpdGVyYXRvcnMgYXJlIGluIHRoZSBvdXRlcm1vc3QgZm9yLWxvb3AsIHNvIHRoZSBvdXRwdXQgdHVwbGVzXFxcXG5jeWNsZSBpbiBhIG1hbm5lciBzaW1pbGFyIHRvIGFuIG9kb21ldGVyICh3aXRoIHRoZSByaWdodG1vc3QgZWxlbWVudCBjaGFuZ2luZ1xcXFxub24gZXZlcnkgaXRlcmF0aW9uKS5cXFxcblxcXFxuVG8gY29tcHV0ZSB0aGUgcHJvZHVjdCBvZiBhbiBpdGVyYWJsZSB3aXRoIGl0c2VsZiwgc3BlY2lmeSB0aGUgbnVtYmVyXFxcXG5vZiByZXBldGl0aW9ucyB3aXRoIHRoZSBvcHRpb25hbCByZXBlYXQga2V5d29yZCBhcmd1bWVudC4gRm9yIGV4YW1wbGUsXFxcXG5wcm9kdWN0KEEsIHJlcGVhdD00KSBtZWFucyB0aGUgc2FtZSBhcyBwcm9kdWN0KEEsIEEsIEEsIEEpLlxcXFxuXFxcXG5wcm9kdWN0KCdhYicsIHJhbmdlKDMpKSAtLVxcXFx4M2UgKCdhJywwKSAoJ2EnLDEpICgnYScsMikgKCdiJywwKSAoJ2InLDEpICgnYicsMilcXFxcbnByb2R1Y3QoKDAsMSksICgwLDEpLCAoMCwxKSkgLS1cXFxceDNlICgwLDAsMCkgKDAsMCwxKSAoMCwxLDApICgwLDEsMSkgKDEsMCwwKSAuLi5cXFwiLHRwJG5ldyh0LGkpe2xldFtyXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwicHJvZHVjdFxcXCIsW1xcXCJyZXBlYXRcXFwiXSxbXSxpLFtuZXcgU2suYnVpbHRpbi5pbnRfKDEpXSk7aWYocj1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQocixTay5idWlsdGluLk92ZXJGbG93RXJyb3IpLHI8MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJyZXBlYXQgYXJndW1lbnQgY2Fubm90IGJlIG5lZ2F0aXZlXFxcIik7Y29uc3Qgcz1bXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylzLnB1c2goU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUodFtlXSkpO2NvbnN0IG49W10uY29uY2F0KC4uLkFycmF5KHIpLmZpbGwocykpO2lmKHRoaXM9PT1lLnByb2R1Y3QucHJvdG90eXBlKXJldHVybiBuZXcgZS5wcm9kdWN0KG4pO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLnByb2R1Y3QuY2FsbCh0LG4pLHR9fX19KSxlLnJlcGVhdD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5yZXBlYXRcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiByZXBlYXQodCxlKXt0aGlzLm9iamVjdD10LHRoaXMudGltZXM9ZSx2b2lkIDA9PT1lJiYodGhpcy50cCRpdGVybmV4dD0oKT0+dGhpcy5vYmplY3QpfSxpdGVybmV4dCh0KXtyZXR1cm4gdGhpcy50aW1lcy0tID4wP3RoaXMub2JqZWN0OnZvaWQgMH0sc2xvdHM6e3RwJGRvYzpcXFwicmVwZWF0KG9iamVjdCBbLHRpbWVzXSkgLT4gY3JlYXRlIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG9iamVjdFxcXFxuZm9yIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLiAgSWYgbm90IHNwZWNpZmllZCwgcmV0dXJucyB0aGUgb2JqZWN0XFxcXG5lbmRsZXNzbHkuXFxcIix0cCRuZXcodCxpKXtsZXQgcixzO2lmKFtyLHNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJyZXBlYXRcXFwiLFtcXFwib2JqZWN0XFxcIixcXFwidGltZXNcXFwiXSx0LGksW251bGxdKSxzPW51bGwhPT1zP1NrLm1pc2NldmFsLmFzSW5kZXhTaXplZChzLFNrLmJ1aWx0aW4uT3ZlckZsb3dFcnJvcik6dm9pZCAwLHRoaXM9PT1lLnJlcGVhdC5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLnJlcGVhdChyLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLnJlcGVhdC5jYWxsKHQscixzKSx0fX0sJHIoKXtjb25zdCB0PVNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5vYmplY3QpLGU9dm9pZCAwPT09dGhpcy50aW1lcz9cXFwiXFxcIjpcXFwiLCBcXFwiKyh0aGlzLnRpbWVzPj0wP3RoaXMudGltZXM6MCk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcXFwiKFxcXCIrdCtlK1xcXCIpXFxcIil9fSxtZXRob2RzOntfX2xlbmdodF9oaW50X186eyRtZXRoKCl7aWYodm9pZCAwPT09dGhpcy50aW1lcyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImxlbigpIG9mIHVuc2l6ZWQgb2JqZWN0XFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy50aW1lcyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsfX19KSxlLnN0YXJtYXA9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuc3Rhcm1hcFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHN0YXJtYXAodCxlKXt0aGlzLmZ1bmM9dCx0aGlzLml0ZXI9ZX0saXRlcm5leHQodCl7Y29uc3QgZT10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtpZih2b2lkIDA9PT1lKXJldHVybjtjb25zdCBpPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGUpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5mdW5jLGkpfSxzbG90czp7dHAkbmV3KHQsaSl7bGV0IHIscztpZihbcixzXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwic3Rhcm1hcFxcXCIsW1xcXCJmdW5jXFxcIixcXFwiaXRlcmFibGVcXFwiXSx0LGksW10pLHM9U2suYWJzdHIuaXRlcihzKSxyPVNrLmJ1aWx0aW4uY2hlY2tOb25lKHIpP1NrLmJ1aWx0aW4uYm9vbDpyLHRoaXM9PT1lLnN0YXJtYXAucHJvdG90eXBlKXJldHVybiBuZXcgZS5zdGFybWFwKHIscyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuc3Rhcm1hcC5jYWxsKHQscixzKSx0fX19fSksZS50YWtld2hpbGU9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMudGFrZXdoaWxlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gdGFrZXdoaWxlKHQsZSl7dGhpcy5wcmVkaWNhdGU9dCx0aGlzLml0ZXI9ZX0saXRlcm5leHQoKXtjb25zdCB0PXRoaXMuaXRlci50cCRpdGVybmV4dCgpO2lmKHZvaWQgMCE9PXQpe2NvbnN0IGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMucHJlZGljYXRlLFt0XSk7aWYoU2subWlzY2V2YWwuaXNUcnVlKGUpKXJldHVybiB0O3RoaXMudHAkaXRlcm5leHQ9KCk9Pnt9fX0sc2xvdHM6e3RwJGRvYzpcXFwidGFrZXdoaWxlKHByZWRpY2F0ZSwgaXRlcmFibGUpIC0tXFxcXHgzZSB0YWtld2hpbGUgb2JqZWN0XFxcXG5cXFxcblJldHVybiBzdWNjZXNzaXZlIGVudHJpZXMgZnJvbSBhbiBpdGVyYWJsZSBhcyBsb25nIGFzIHRoZSBcXFxcbnByZWRpY2F0ZSBldmFsdWF0ZXMgdG8gdHJ1ZSBmb3IgZWFjaCBlbnRyeS5cXFwiLHRwJG5ldyh0LGkpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXFxcInRha2V3aGlsZVxcXCIsaSksU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJ0YWtld2hpbGVcXFwiLHQsMiwyKTtjb25zdCByPXRbMF0scz1Tay5hYnN0ci5pdGVyKHRbMV0pO2lmKHRoaXM9PT1lLnRha2V3aGlsZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLnRha2V3aGlsZShyLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLnRha2V3aGlsZS5jYWxsKHQscixzKSx0fX19fSksZS50ZWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ0ZWUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKX0pKSxlLnppcF9sb25nZXN0PVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnppcF9sb25nZXN0XFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gemlwX2xvbmdlc3QodCxlKXt0aGlzLml0ZXJzPXQsdGhpcy5maWxsdmFsdWU9ZSx0aGlzLmFjdGl2ZT10aGlzLml0ZXJzLmxlbmd0aH0saXRlcm5leHQodCl7aWYoIXRoaXMuYWN0aXZlKXJldHVybjtsZXQgaTtjb25zdCByPVtdO2ZvcihsZXQgcz0wO3M8dGhpcy5pdGVycy5sZW5ndGg7cysrKXtpZihpPXRoaXMuaXRlcnNbc10udHAkaXRlcm5leHQoKSx2b2lkIDA9PT1pKXtpZih0aGlzLmFjdGl2ZS0tLCF0aGlzLmFjdGl2ZSlyZXR1cm47dGhpcy5pdGVyc1tzXT1uZXcgZS5yZXBlYXQodGhpcy5maWxsdmFsdWUpLGk9dGhpcy5maWxsdmFsdWV9ci5wdXNoKGkpfXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShyKX0sc2xvdHM6e3RwJGRvYzpcXFwiemlwX2xvbmdlc3QoaXRlcjEgWyxpdGVyMiBbLi4uXV0sIFtmaWxsdmFsdWU9Tm9uZV0pIC0tXFxcXHgzZSB6aXBfbG9uZ2VzdCBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGEgemlwX2xvbmdlc3Qgb2JqZWN0IHdob3NlIC5fX25leHRfXygpIG1ldGhvZCByZXR1cm5zIGEgdHVwbGUgd2hlcmVcXFxcbnRoZSBpLXRoIGVsZW1lbnQgY29tZXMgZnJvbSB0aGUgaS10aCBpdGVyYWJsZSBhcmd1bWVudC4gIFRoZSAuX19uZXh0X18oKVxcXFxubWV0aG9kIGNvbnRpbnVlcyB1bnRpbCB0aGUgbG9uZ2VzdCBpdGVyYWJsZSBpbiB0aGUgYXJndW1lbnQgc2VxdWVuY2VcXFxcbmlzIGV4aGF1c3RlZCBhbmQgdGhlbiBpdCByYWlzZXMgU3RvcEl0ZXJhdGlvbi4gIFdoZW4gdGhlIHNob3J0ZXIgaXRlcmFibGVzXFxcXG5hcmUgZXhoYXVzdGVkLCB0aGUgZmlsbHZhbHVlIGlzIHN1YnN0aXR1dGVkIGluIHRoZWlyIHBsYWNlLiAgVGhlIGZpbGx2YWx1ZVxcXFxuZGVmYXVsdHMgdG8gTm9uZSBvciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGEga2V5d29yZCBhcmd1bWVudC5cXFxcblxcXCIsdHAkbmV3KHQsaSl7Y29uc3Rbcl09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcInppcF9sb25nZXN0XFxcIixbXFxcImZpbGx2YWx1ZVxcXCJdLFtdLGksW1NrLmJ1aWx0aW4ubm9uZS5ub25lJF0pLHM9W107Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspcy5wdXNoKFNrLmFic3RyLml0ZXIodFtlXSkpO2lmKHRoaXM9PT1lLnppcF9sb25nZXN0LnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuemlwX2xvbmdlc3QocyxyKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS56aXBfbG9uZ2VzdC5jYWxsKHQscyxyKSx0fX19fSksZS5fX2RvY19fPW5ldyBTay5idWlsdGluLnN0cihcXFwiQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIHB5dGhvbiBpdGVydG9vbHMgbW9kdWxlIGluIFNrdWxwdFxcXCIpLGUuX19wYWNrYWdlX189bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJcXFwiKSxlfTtcIixcInNyYy9saWIvanNvbi9fX2luaXRfXy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKHQpe1xcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgZT17fSxkdW1wc19mPWZ1bmN0aW9uKHQpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXFxcImR1bXBzXFxcIixhcmd1bWVudHMsMSwxLzAsITAsITEpO3ZhciBlLG4saSx1PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxmPW5ldyBTay5idWlsdGlucy5kaWN0KHQpLGE9ITE7cmV0dXJuIGU9e2FzY2lpOiEwLHNlcGFyYXRvcnM6e2l0ZW1fc2VwYXJhdG9yOlxcXCIsIFxcXCIsa2V5X3NlcGFyYXRvcjpcXFwiOiBcXFwifX0sZj1Tay5mZmkucmVtYXBUb0pzKGYpLG49U2suZmZpLnJlbWFwVG9Kcyh1WzBdKSxcXFwiYm9vbGVhblxcXCI9PXR5cGVvZiBmLmVuc3VyZV9hc2NpaSYmITE9PT1mLmVuc3VyZV9hc2NpaSYmKGUuYXNjaWk9ITEpLFxcXCJib29sZWFuXFxcIj09dHlwZW9mIGYuc29ydF9rZXlzJiZmLnNvcnRfa2V5cyYmKGE9ITApLGF8fChlLmNtcD1mdW5jdGlvbih0LGUpe3JldHVybiAwfSksXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBmLnNlcGFyYXRvcnMmJjI9PWYuc2VwYXJhdG9ycy5sZW5ndGgmJihlLnNlcGFyYXRvcnMuaXRlbV9zZXBhcmF0b3I9Zi5zZXBhcmF0b3JzWzBdLGUuc2VwYXJhdG9ycy5rZXlfc2VwYXJhdG9yPWYuc2VwYXJhdG9yc1sxXSksZi5pbmRlbnQmJihlLnNwYWNlPWYuaW5kZW50KSxmLmRlZmF1bHQsaT1zdHJpbmdpZnkobixlKSxuZXcgU2suYnVpbHRpbi5zdHIoaSl9O2R1bXBzX2YuY29fa3dhcmdzPSEwLGUuZHVtcHM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhkdW1wc19mKTt2YXIgbG9hZHNfZj1mdW5jdGlvbih0KXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJsb2Fkc1xcXCIsYXJndW1lbnRzLDEsMS8wLCEwLCExKTt2YXIgZSxuLGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLHU9bmV3IFNrLmJ1aWx0aW5zLmRpY3QodCk7cmV0dXJuIHU9U2suZmZpLnJlbWFwVG9Kcyh1KSxlPWlbMF0udixuPUpTT04ucGFyc2UoZSksU2suZmZpLnJlbWFwVG9QeShuKX07cmV0dXJuIGxvYWRzX2YuY29fa3dhcmdzPSEwLGUubG9hZHM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhsb2Fkc19mKSxlfTshZnVuY3Rpb24gcih0LGUsbil7ZnVuY3Rpb24gbyh1LGYpe2lmKCFlW3VdKXtpZighdFt1XSl7dmFyIGE9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmEpcmV0dXJuIGEodSwhMCk7aWYoaSlyZXR1cm4gaSh1LCEwKTt2YXIgcz1uZXcgRXJyb3IoXFxcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXFxcIit1K1xcXCInXFxcIik7dGhyb3cgcy5jb2RlPVxcXCJNT0RVTEVfTk9UX0ZPVU5EXFxcIixzfXZhciBjPWVbdV09e2V4cG9ydHM6e319O3RbdV1bMF0uY2FsbChjLmV4cG9ydHMsKGZ1bmN0aW9uKGUpe3JldHVybiBvKHRbdV1bMV1bZV18fGUpfSksYyxjLmV4cG9ydHMscix0LGUsbil9cmV0dXJuIGVbdV0uZXhwb3J0c31mb3IodmFyIGk9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsdT0wO3U8bi5sZW5ndGg7dSsrKW8oblt1XSk7cmV0dXJuIG99KHsxOltmdW5jdGlvbih0LGUsbil7dmFyIGk9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBKU09OP0pTT046dChcXFwianNvbmlmeVxcXCIpO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2V8fChlPXt9KSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKGU9e2NtcDplfSk7dmFyIG4sYT1lLmNtcCYmKG49ZS5jbXAsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHU9e2tleTplLHZhbHVlOnRbZV19LGY9e2tleTppLHZhbHVlOnRbaV19O3JldHVybiBuKHUsZil9fSk7cmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeSh0KXtpZihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVybiBpLnN0cmluZ2lmeSh0KTtpZih1KHQpKXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bisrKWUucHVzaChzdHJpbmdpZnkodFtuXSkpO3JldHVyblxcXCJbXFxcIitlLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCJ9dmFyIHM9Zih0KS5zb3J0KGEmJmEodCkpO2ZvcihlPVtdLG49MDtuPHMubGVuZ3RoO24rKyl7dmFyIGM9c1tuXTtlLnB1c2goc3RyaW5naWZ5KGMpK1xcXCI6XFxcIitzdHJpbmdpZnkodFtjXSkpfXJldHVyblxcXCJ7XFxcIitlLmpvaW4oXFxcIixcXFwiKStcXFwifVxcXCJ9KHQpfTt2YXIgdT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cXFwiW29iamVjdCBBcnJheV1cXFwiPT09e30udG9TdHJpbmcuY2FsbCh0KX0sZj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odCl7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbj1bXTtmb3IodmFyIGkgaW4gdCllLmNhbGwodCxpKSYmbi5wdXNoKGkpO3JldHVybiBufX0se2pzb25pZnk6Mn1dLDI6W2Z1bmN0aW9uKHQsZSxuKXtuLnBhcnNlPXQoXFxcIi4vbGliL3BhcnNlXFxcIiksbi5zdHJpbmdpZnk9dChcXFwiLi9saWIvc3RyaW5naWZ5XFxcIil9LHtcXFwiLi9saWIvcGFyc2VcXFwiOjMsXFxcIi4vbGliL3N0cmluZ2lmeVxcXCI6NH1dLDM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgaSx1LGYsYSxzPXsnXFxcIic6J1xcXCInLFxcXCJcXFxcXFxcXFxcXCI6XFxcIlxcXFxcXFxcXFxcIixcXFwiL1xcXCI6XFxcIi9cXFwiLGI6XFxcIlxcXFxiXFxcIixmOlxcXCJcXFxcZlxcXCIsbjpcXFwiXFxcXG5cXFwiLHI6XFxcIlxcXFxyXFxcIix0OlxcXCJcXFxcdFxcXCJ9LGVycm9yPWZ1bmN0aW9uKHQpe3Rocm93e25hbWU6XFxcIlN5bnRheEVycm9yXFxcIixtZXNzYWdlOnQsYXQ6aSx0ZXh0OmZ9fSxuZXh0PWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0IT09dSYmZXJyb3IoXFxcIkV4cGVjdGVkICdcXFwiK3QrXFxcIicgaW5zdGVhZCBvZiAnXFxcIit1K1xcXCInXFxcIiksdT1mLmNoYXJBdChpKSxpKz0xLHV9LG51bWJlcj1mdW5jdGlvbigpe3ZhciB0LGU9XFxcIlxcXCI7Zm9yKFxcXCItXFxcIj09PXUmJihlPVxcXCItXFxcIixuZXh0KFxcXCItXFxcIikpO3U+PVxcXCIwXFxcIiYmdTw9XFxcIjlcXFwiOyllKz11LG5leHQoKTtpZihcXFwiLlxcXCI9PT11KWZvcihlKz1cXFwiLlxcXCI7bmV4dCgpJiZ1Pj1cXFwiMFxcXCImJnU8PVxcXCI5XFxcIjspZSs9dTtpZihcXFwiZVxcXCI9PT11fHxcXFwiRVxcXCI9PT11KWZvcihlKz11LG5leHQoKSxcXFwiLVxcXCIhPT11JiZcXFwiK1xcXCIhPT11fHwoZSs9dSxuZXh0KCkpO3U+PVxcXCIwXFxcIiYmdTw9XFxcIjlcXFwiOyllKz11LG5leHQoKTtpZih0PStlLGlzRmluaXRlKHQpKXJldHVybiB0O2Vycm9yKFxcXCJCYWQgbnVtYmVyXFxcIil9LHN0cmluZz1mdW5jdGlvbigpe3ZhciB0LGUsbixpPVxcXCJcXFwiO2lmKCdcXFwiJz09PXUpZm9yKDtuZXh0KCk7KXtpZignXFxcIic9PT11KXJldHVybiBuZXh0KCksaTtpZihcXFwiXFxcXFxcXFxcXFwiPT09dSlpZihuZXh0KCksXFxcInVcXFwiPT09dSl7Zm9yKG49MCxlPTA7ZTw0JiYodD1wYXJzZUludChuZXh0KCksMTYpLGlzRmluaXRlKHQpKTtlKz0xKW49MTYqbit0O2krPVN0cmluZy5mcm9tQ2hhckNvZGUobil9ZWxzZXtpZihcXFwic3RyaW5nXFxcIiE9dHlwZW9mIHNbdV0pYnJlYWs7aSs9c1t1XX1lbHNlIGkrPXV9ZXJyb3IoXFxcIkJhZCBzdHJpbmdcXFwiKX0sd2hpdGU9ZnVuY3Rpb24oKXtmb3IoO3UmJnU8PVxcXCIgXFxcIjspbmV4dCgpfTthPWZ1bmN0aW9uKCl7c3dpdGNoKHdoaXRlKCksdSl7Y2FzZVxcXCJ7XFxcIjpyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdCxlPXt9O2lmKFxcXCJ7XFxcIj09PXUpe2lmKG5leHQoXFxcIntcXFwiKSx3aGl0ZSgpLFxcXCJ9XFxcIj09PXUpcmV0dXJuIG5leHQoXFxcIn1cXFwiKSxlO2Zvcig7dTspe2lmKHQ9c3RyaW5nKCksd2hpdGUoKSxuZXh0KFxcXCI6XFxcIiksT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXFxcIicrdCsnXFxcIicpLGVbdF09YSgpLHdoaXRlKCksXFxcIn1cXFwiPT09dSlyZXR1cm4gbmV4dChcXFwifVxcXCIpLGU7bmV4dChcXFwiLFxcXCIpLHdoaXRlKCl9fWVycm9yKFxcXCJCYWQgb2JqZWN0XFxcIil9KCk7Y2FzZVxcXCJbXFxcIjpyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1bXTtpZihcXFwiW1xcXCI9PT11KXtpZihuZXh0KFxcXCJbXFxcIiksd2hpdGUoKSxcXFwiXVxcXCI9PT11KXJldHVybiBuZXh0KFxcXCJdXFxcIiksdDtmb3IoO3U7KXtpZih0LnB1c2goYSgpKSx3aGl0ZSgpLFxcXCJdXFxcIj09PXUpcmV0dXJuIG5leHQoXFxcIl1cXFwiKSx0O25leHQoXFxcIixcXFwiKSx3aGl0ZSgpfX1lcnJvcihcXFwiQmFkIGFycmF5XFxcIil9KCk7Y2FzZSdcXFwiJzpyZXR1cm4gc3RyaW5nKCk7Y2FzZVxcXCItXFxcIjpyZXR1cm4gbnVtYmVyKCk7ZGVmYXVsdDpyZXR1cm4gdT49XFxcIjBcXFwiJiZ1PD1cXFwiOVxcXCI/bnVtYmVyKCk6ZnVuY3Rpb24oKXtzd2l0Y2godSl7Y2FzZVxcXCJ0XFxcIjpyZXR1cm4gbmV4dChcXFwidFxcXCIpLG5leHQoXFxcInJcXFwiKSxuZXh0KFxcXCJ1XFxcIiksbmV4dChcXFwiZVxcXCIpLCEwO2Nhc2VcXFwiZlxcXCI6cmV0dXJuIG5leHQoXFxcImZcXFwiKSxuZXh0KFxcXCJhXFxcIiksbmV4dChcXFwibFxcXCIpLG5leHQoXFxcInNcXFwiKSxuZXh0KFxcXCJlXFxcIiksITE7Y2FzZVxcXCJuXFxcIjpyZXR1cm4gbmV4dChcXFwiblxcXCIpLG5leHQoXFxcInVcXFwiKSxuZXh0KFxcXCJsXFxcIiksbmV4dChcXFwibFxcXCIpLG51bGx9ZXJyb3IoXFxcIlVuZXhwZWN0ZWQgJ1xcXCIrdStcXFwiJ1xcXCIpfSgpfX0sZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIGY9dCxpPTAsdT1cXFwiIFxcXCIsbj1hKCksd2hpdGUoKSx1JiZlcnJvcihcXFwiU3ludGF4IGVycm9yXFxcIiksXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGU/ZnVuY3Rpb24gd2Fsayh0LG4pe3ZhciBpLHUsZj10W25dO2lmKGYmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgZilmb3IoaSBpbiBmKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLGkpJiYodm9pZCAwIT09KHU9d2FsayhmLGkpKT9mW2ldPXU6ZGVsZXRlIGZbaV0pO3JldHVybiBlLmNhbGwodCxuLGYpfSh7XFxcIlxcXCI6bn0sXFxcIlxcXCIpOm59fSx7fV0sNDpbZnVuY3Rpb24odCxlLG4pe3ZhciBpLHUsZixhPS9bXFxcXFxcXFxcXFxcXFxcIlxcXFx4MDAtXFxcXHgxZlxcXFx4N2YtXFxcXHg5ZlxcXFx1MDBhZFxcXFx1MDYwMC1cXFxcdTA2MDRcXFxcdTA3MGZcXFxcdTE3YjRcXFxcdTE3YjVcXFxcdTIwMGMtXFxcXHUyMDBmXFxcXHUyMDI4LVxcXFx1MjAyZlxcXFx1MjA2MC1cXFxcdTIwNmZcXFxcdWZlZmZcXFxcdWZmZjAtXFxcXHVmZmZmXS9nLHM9e1xcXCJcXFxcYlxcXCI6XFxcIlxcXFxcXFxcYlxcXCIsXFxcIlxcXFx0XFxcIjpcXFwiXFxcXFxcXFx0XFxcIixcXFwiXFxcXG5cXFwiOlxcXCJcXFxcXFxcXG5cXFwiLFxcXCJcXFxcZlxcXCI6XFxcIlxcXFxcXFxcZlxcXCIsXFxcIlxcXFxyXFxcIjpcXFwiXFxcXFxcXFxyXFxcIiwnXFxcIic6J1xcXFxcXFxcXFxcIicsXFxcIlxcXFxcXFxcXFxcIjpcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCJ9O2Z1bmN0aW9uIHF1b3RlKHQpe3JldHVybiBhLmxhc3RJbmRleD0wLGEudGVzdCh0KT8nXFxcIicrdC5yZXBsYWNlKGEsKGZ1bmN0aW9uKHQpe3ZhciBlPXNbdF07cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBlP2U6XFxcIlxcXFxcXFxcdVxcXCIrKFxcXCIwMDAwXFxcIit0LmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9KSkrJ1xcXCInOidcXFwiJyt0KydcXFwiJ31mdW5jdGlvbiBzdHIodCxlKXt2YXIgbixhLHMsYyxsLHA9aSx5PWVbdF07c3dpdGNoKHkmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgeSYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHkudG9KU09OJiYoeT15LnRvSlNPTih0KSksXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGYmJih5PWYuY2FsbChlLHQseSkpLHR5cGVvZiB5KXtjYXNlXFxcInN0cmluZ1xcXCI6cmV0dXJuIHF1b3RlKHkpO2Nhc2VcXFwibnVtYmVyXFxcIjpyZXR1cm4gaXNGaW5pdGUoeSk/U3RyaW5nKHkpOlxcXCJudWxsXFxcIjtjYXNlXFxcImJvb2xlYW5cXFwiOmNhc2VcXFwibnVsbFxcXCI6cmV0dXJuIFN0cmluZyh5KTtjYXNlXFxcIm9iamVjdFxcXCI6aWYoIXkpcmV0dXJuXFxcIm51bGxcXFwiO2lmKGkrPXUsbD1bXSxcXFwiW29iamVjdCBBcnJheV1cXFwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh5KSl7Zm9yKGM9eS5sZW5ndGgsbj0wO248YztuKz0xKWxbbl09c3RyKG4seSl8fFxcXCJudWxsXFxcIjtyZXR1cm4gcz0wPT09bC5sZW5ndGg/XFxcIltdXFxcIjppP1xcXCJbXFxcXG5cXFwiK2krbC5qb2luKFxcXCIsXFxcXG5cXFwiK2kpK1xcXCJcXFxcblxcXCIrcCtcXFwiXVxcXCI6XFxcIltcXFwiK2wuam9pbihcXFwiLFxcXCIpK1xcXCJdXFxcIixpPXAsc31pZihmJiZcXFwib2JqZWN0XFxcIj09dHlwZW9mIGYpZm9yKGM9Zi5sZW5ndGgsbj0wO248YztuKz0xKVxcXCJzdHJpbmdcXFwiPT10eXBlb2YoYT1mW25dKSYmKHM9c3RyKGEseSkpJiZsLnB1c2gocXVvdGUoYSkrKGk/XFxcIjogXFxcIjpcXFwiOlxcXCIpK3MpO2Vsc2UgZm9yKGEgaW4geSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSxhKSYmKHM9c3RyKGEseSkpJiZsLnB1c2gocXVvdGUoYSkrKGk/XFxcIjogXFxcIjpcXFwiOlxcXCIpK3MpO3JldHVybiBzPTA9PT1sLmxlbmd0aD9cXFwie31cXFwiOmk/XFxcIntcXFxcblxcXCIraStsLmpvaW4oXFxcIixcXFxcblxcXCIraSkrXFxcIlxcXFxuXFxcIitwK1xcXCJ9XFxcIjpcXFwie1xcXCIrbC5qb2luKFxcXCIsXFxcIikrXFxcIn1cXFwiLGk9cCxzfX1lLmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciBhO2lmKGk9XFxcIlxcXCIsdT1cXFwiXFxcIixcXFwibnVtYmVyXFxcIj09dHlwZW9mIG4pZm9yKGE9MDthPG47YSs9MSl1Kz1cXFwiIFxcXCI7ZWxzZVxcXCJzdHJpbmdcXFwiPT10eXBlb2YgbiYmKHU9bik7aWYoZj1lLGUmJlxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiBlJiYoXFxcIm9iamVjdFxcXCIhPXR5cGVvZiBlfHxcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGUubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXFxcIkpTT04uc3RyaW5naWZ5XFxcIik7cmV0dXJuIHN0cihcXFwiXFxcIix7XFxcIlxcXCI6dH0pfX0se31dLDU6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgaSx1LGY9ZS5leHBvcnRzPXt9O2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXFxcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcXFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFxcXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcXFwiKX1mdW5jdGlvbiBydW5UaW1lb3V0KHQpe2lmKGk9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KHQsMCk7aWYoKGk9PT1kZWZhdWx0U2V0VGltb3V0fHwhaSkmJnNldFRpbWVvdXQpcmV0dXJuIGk9c2V0VGltZW91dCxzZXRUaW1lb3V0KHQsMCk7dHJ5e3JldHVybiBpKHQsMCl9Y2F0Y2goZSl7dHJ5e3JldHVybiBpLmNhbGwobnVsbCx0LDApfWNhdGNoKGUpe3JldHVybiBpLmNhbGwodGhpcyx0LDApfX19IWZ1bmN0aW9uKCl7dHJ5e2k9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpkZWZhdWx0U2V0VGltb3V0fWNhdGNoKHQpe2k9ZGVmYXVsdFNldFRpbW91dH10cnl7dT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDpkZWZhdWx0Q2xlYXJUaW1lb3V0fWNhdGNoKHQpe3U9ZGVmYXVsdENsZWFyVGltZW91dH19KCk7dmFyIGEscz1bXSxjPSExLGw9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7YyYmYSYmKGM9ITEsYS5sZW5ndGg/cz1hLmNvbmNhdChzKTpsPS0xLHMubGVuZ3RoJiZkcmFpblF1ZXVlKCkpfWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZighYyl7dmFyIHQ9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO2M9ITA7Zm9yKHZhciBlPXMubGVuZ3RoO2U7KXtmb3IoYT1zLHM9W107KytsPGU7KWEmJmFbbF0ucnVuKCk7bD0tMSxlPXMubGVuZ3RofWE9bnVsbCxjPSExLGZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dCh0KXtpZih1PT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQodCk7aWYoKHU9PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhdSkmJmNsZWFyVGltZW91dClyZXR1cm4gdT1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHQpO3RyeXtyZXR1cm4gdSh0KX1jYXRjaChlKXt0cnl7cmV0dXJuIHUuY2FsbChudWxsLHQpfWNhdGNoKGUpe3JldHVybiB1LmNhbGwodGhpcyx0KX19fSh0KX19ZnVuY3Rpb24gSXRlbSh0LGUpe3RoaXMuZnVuPXQsdGhpcy5hcnJheT1lfWZ1bmN0aW9uIG5vb3AoKXt9Zi5uZXh0VGljaz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyllW24tMV09YXJndW1lbnRzW25dO3MucHVzaChuZXcgSXRlbSh0LGUpKSwxIT09cy5sZW5ndGh8fGN8fHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSl9LEl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LGYudGl0bGU9XFxcImJyb3dzZXJcXFwiLGYuYnJvd3Nlcj0hMCxmLmVudj17fSxmLmFyZ3Y9W10sZi52ZXJzaW9uPVxcXCJcXFwiLGYudmVyc2lvbnM9e30sZi5vbj1ub29wLGYuYWRkTGlzdGVuZXI9bm9vcCxmLm9uY2U9bm9vcCxmLm9mZj1ub29wLGYucmVtb3ZlTGlzdGVuZXI9bm9vcCxmLnJlbW92ZUFsbExpc3RlbmVycz1ub29wLGYuZW1pdD1ub29wLGYucHJlcGVuZExpc3RlbmVyPW5vb3AsZi5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3AsZi5saXN0ZW5lcnM9ZnVuY3Rpb24odCl7cmV0dXJuW119LGYuYmluZGluZz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXFxcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXFxcIil9LGYuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXFxcIi9cXFwifSxmLmNoZGlyPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcXFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXFxcIil9LGYudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LHt9XSw2OltmdW5jdGlvbih0LGUsbil7KGZ1bmN0aW9uKG4pe3ZhciBpPXQoXFxcImpzb24tc3RhYmxlLXN0cmluZ2lmeVxcXCIpO24uYnJvd3Nlcj93aW5kb3cuc3RyaW5naWZ5PWk6ZS5leHBvcnRzPWl9KS5jYWxsKHRoaXMsdChcXFwiX3Byb2Nlc3NcXFwiKSl9LHtfcHJvY2Vzczo1LFxcXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcXFwiOjF9XX0se30sWzZdKTtcIixcInNyYy9saWIvanNvbi9zdHJpbmdpZnkuanNcIjpcIiFmdW5jdGlvbiByKHQsZSxuKXtmdW5jdGlvbiBvKHUsZil7aWYoIWVbdV0pe2lmKCF0W3VdKXt2YXIgYz1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyh1LCEwKTtpZihpKXJldHVybiBpKHUsITApO3ZhciBhPW5ldyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK3UrXFxcIidcXFwiKTt0aHJvdyBhLmNvZGU9XFxcIk1PRFVMRV9OT1RfRk9VTkRcXFwiLGF9dmFyIHM9ZVt1XT17ZXhwb3J0czp7fX07dFt1XVswXS5jYWxsKHMuZXhwb3J0cywoZnVuY3Rpb24oZSl7cmV0dXJuIG8odFt1XVsxXVtlXXx8ZSl9KSxzLHMuZXhwb3J0cyxyLHQsZSxuKX1yZXR1cm4gZVt1XS5leHBvcnRzfWZvcih2YXIgaT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSx1PTA7dTxuLmxlbmd0aDt1KyspbyhuW3VdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgaT1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIEpTT04/SlNPTjp0KFxcXCJqc29uaWZ5XFxcIik7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYoZT17Y21wOmV9KTt2YXIgbixjPWUuY21wJiYobj1lLmNtcCxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxpKXt2YXIgdT17a2V5OmUsdmFsdWU6dFtlXX0sZj17a2V5OmksdmFsdWU6dFtpXX07cmV0dXJuIG4odSxmKX19KTtyZXR1cm4gZnVuY3Rpb24gc3RyaW5naWZ5KHQpe2lmKFxcXCJvYmplY3RcXFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuIGkuc3RyaW5naWZ5KHQpO2lmKHUodCkpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspZS5wdXNoKHN0cmluZ2lmeSh0W25dKSk7cmV0dXJuXFxcIltcXFwiK2Uuam9pbihcXFwiLFxcXCIpK1xcXCJdXFxcIn12YXIgYT1mKHQpLnNvcnQoYyYmYyh0KSk7Zm9yKGU9W10sbj0wO248YS5sZW5ndGg7bisrKXt2YXIgcz1hW25dO2UucHVzaChzdHJpbmdpZnkocykrXFxcIjpcXFwiK3N0cmluZ2lmeSh0W3NdKSl9cmV0dXJuXFxcIntcXFwiK2Uuam9pbihcXFwiLFxcXCIpK1xcXCJ9XFxcIn0odCl9O3ZhciB1PUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVyblxcXCJbb2JqZWN0IEFycmF5XVxcXCI9PT17fS50b1N0cmluZy5jYWxsKHQpfSxmPU9iamVjdC5rZXlzfHxmdW5jdGlvbih0KXt2YXIgZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5fHxmdW5jdGlvbigpe3JldHVybiEwfSxuPVtdO2Zvcih2YXIgaSBpbiB0KWUuY2FsbCh0LGkpJiZuLnB1c2goaSk7cmV0dXJuIG59fSx7anNvbmlmeToyfV0sMjpbZnVuY3Rpb24odCxlLG4pe24ucGFyc2U9dChcXFwiLi9saWIvcGFyc2VcXFwiKSxuLnN0cmluZ2lmeT10KFxcXCIuL2xpYi9zdHJpbmdpZnlcXFwiKX0se1xcXCIuL2xpYi9wYXJzZVxcXCI6MyxcXFwiLi9saWIvc3RyaW5naWZ5XFxcIjo0fV0sMzpbZnVuY3Rpb24odCxlLG4pe3ZhciBpLHUsZixjLGE9eydcXFwiJzonXFxcIicsXFxcIlxcXFxcXFxcXFxcIjpcXFwiXFxcXFxcXFxcXFwiLFxcXCIvXFxcIjpcXFwiL1xcXCIsYjpcXFwiXFxcXGJcXFwiLGY6XFxcIlxcXFxmXFxcIixuOlxcXCJcXFxcblxcXCIscjpcXFwiXFxcXHJcXFwiLHQ6XFxcIlxcXFx0XFxcIn0sZXJyb3I9ZnVuY3Rpb24odCl7dGhyb3d7bmFtZTpcXFwiU3ludGF4RXJyb3JcXFwiLG1lc3NhZ2U6dCxhdDppLHRleHQ6Zn19LG5leHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQhPT11JiZlcnJvcihcXFwiRXhwZWN0ZWQgJ1xcXCIrdCtcXFwiJyBpbnN0ZWFkIG9mICdcXFwiK3UrXFxcIidcXFwiKSx1PWYuY2hhckF0KGkpLGkrPTEsdX0sbnVtYmVyPWZ1bmN0aW9uKCl7dmFyIHQsZT1cXFwiXFxcIjtmb3IoXFxcIi1cXFwiPT09dSYmKGU9XFxcIi1cXFwiLG5leHQoXFxcIi1cXFwiKSk7dT49XFxcIjBcXFwiJiZ1PD1cXFwiOVxcXCI7KWUrPXUsbmV4dCgpO2lmKFxcXCIuXFxcIj09PXUpZm9yKGUrPVxcXCIuXFxcIjtuZXh0KCkmJnU+PVxcXCIwXFxcIiYmdTw9XFxcIjlcXFwiOyllKz11O2lmKFxcXCJlXFxcIj09PXV8fFxcXCJFXFxcIj09PXUpZm9yKGUrPXUsbmV4dCgpLFxcXCItXFxcIiE9PXUmJlxcXCIrXFxcIiE9PXV8fChlKz11LG5leHQoKSk7dT49XFxcIjBcXFwiJiZ1PD1cXFwiOVxcXCI7KWUrPXUsbmV4dCgpO2lmKHQ9K2UsaXNGaW5pdGUodCkpcmV0dXJuIHQ7ZXJyb3IoXFxcIkJhZCBudW1iZXJcXFwiKX0sc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIHQsZSxuLGk9XFxcIlxcXCI7aWYoJ1xcXCInPT09dSlmb3IoO25leHQoKTspe2lmKCdcXFwiJz09PXUpcmV0dXJuIG5leHQoKSxpO2lmKFxcXCJcXFxcXFxcXFxcXCI9PT11KWlmKG5leHQoKSxcXFwidVxcXCI9PT11KXtmb3Iobj0wLGU9MDtlPDQmJih0PXBhcnNlSW50KG5leHQoKSwxNiksaXNGaW5pdGUodCkpO2UrPTEpbj0xNipuK3Q7aSs9U3RyaW5nLmZyb21DaGFyQ29kZShuKX1lbHNle2lmKFxcXCJzdHJpbmdcXFwiIT10eXBlb2YgYVt1XSlicmVhaztpKz1hW3VdfWVsc2UgaSs9dX1lcnJvcihcXFwiQmFkIHN0cmluZ1xcXCIpfSx3aGl0ZT1mdW5jdGlvbigpe2Zvcig7dSYmdTw9XFxcIiBcXFwiOyluZXh0KCl9O2M9ZnVuY3Rpb24oKXtzd2l0Y2god2hpdGUoKSx1KXtjYXNlXFxcIntcXFwiOnJldHVybiBmdW5jdGlvbigpe3ZhciB0LGU9e307aWYoXFxcIntcXFwiPT09dSl7aWYobmV4dChcXFwie1xcXCIpLHdoaXRlKCksXFxcIn1cXFwiPT09dSlyZXR1cm4gbmV4dChcXFwifVxcXCIpLGU7Zm9yKDt1Oyl7aWYodD1zdHJpbmcoKSx3aGl0ZSgpLG5leHQoXFxcIjpcXFwiKSxPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpJiZlcnJvcignRHVwbGljYXRlIGtleSBcXFwiJyt0KydcXFwiJyksZVt0XT1jKCksd2hpdGUoKSxcXFwifVxcXCI9PT11KXJldHVybiBuZXh0KFxcXCJ9XFxcIiksZTtuZXh0KFxcXCIsXFxcIiksd2hpdGUoKX19ZXJyb3IoXFxcIkJhZCBvYmplY3RcXFwiKX0oKTtjYXNlXFxcIltcXFwiOnJldHVybiBmdW5jdGlvbigpe3ZhciB0PVtdO2lmKFxcXCJbXFxcIj09PXUpe2lmKG5leHQoXFxcIltcXFwiKSx3aGl0ZSgpLFxcXCJdXFxcIj09PXUpcmV0dXJuIG5leHQoXFxcIl1cXFwiKSx0O2Zvcig7dTspe2lmKHQucHVzaChjKCkpLHdoaXRlKCksXFxcIl1cXFwiPT09dSlyZXR1cm4gbmV4dChcXFwiXVxcXCIpLHQ7bmV4dChcXFwiLFxcXCIpLHdoaXRlKCl9fWVycm9yKFxcXCJCYWQgYXJyYXlcXFwiKX0oKTtjYXNlJ1xcXCInOnJldHVybiBzdHJpbmcoKTtjYXNlXFxcIi1cXFwiOnJldHVybiBudW1iZXIoKTtkZWZhdWx0OnJldHVybiB1Pj1cXFwiMFxcXCImJnU8PVxcXCI5XFxcIj9udW1iZXIoKTpmdW5jdGlvbigpe3N3aXRjaCh1KXtjYXNlXFxcInRcXFwiOnJldHVybiBuZXh0KFxcXCJ0XFxcIiksbmV4dChcXFwiclxcXCIpLG5leHQoXFxcInVcXFwiKSxuZXh0KFxcXCJlXFxcIiksITA7Y2FzZVxcXCJmXFxcIjpyZXR1cm4gbmV4dChcXFwiZlxcXCIpLG5leHQoXFxcImFcXFwiKSxuZXh0KFxcXCJsXFxcIiksbmV4dChcXFwic1xcXCIpLG5leHQoXFxcImVcXFwiKSwhMTtjYXNlXFxcIm5cXFwiOnJldHVybiBuZXh0KFxcXCJuXFxcIiksbmV4dChcXFwidVxcXCIpLG5leHQoXFxcImxcXFwiKSxuZXh0KFxcXCJsXFxcIiksbnVsbH1lcnJvcihcXFwiVW5leHBlY3RlZCAnXFxcIit1K1xcXCInXFxcIil9KCl9fSxlLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgbjtyZXR1cm4gZj10LGk9MCx1PVxcXCIgXFxcIixuPWMoKSx3aGl0ZSgpLHUmJmVycm9yKFxcXCJTeW50YXggZXJyb3JcXFwiKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZT9mdW5jdGlvbiB3YWxrKHQsbil7dmFyIGksdSxmPXRbbl07aWYoZiYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBmKWZvcihpIGluIGYpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGYsaSkmJih2b2lkIDAhPT0odT13YWxrKGYsaSkpP2ZbaV09dTpkZWxldGUgZltpXSk7cmV0dXJuIGUuY2FsbCh0LG4sZil9KHtcXFwiXFxcIjpufSxcXFwiXFxcIik6bn19LHt9XSw0OltmdW5jdGlvbih0LGUsbil7dmFyIGksdSxmLGM9L1tcXFxcXFxcXFxcXFxcXFwiXFxcXHgwMC1cXFxceDFmXFxcXHg3Zi1cXFxceDlmXFxcXHUwMGFkXFxcXHUwNjAwLVxcXFx1MDYwNFxcXFx1MDcwZlxcXFx1MTdiNFxcXFx1MTdiNVxcXFx1MjAwYy1cXFxcdTIwMGZcXFxcdTIwMjgtXFxcXHUyMDJmXFxcXHUyMDYwLVxcXFx1MjA2ZlxcXFx1ZmVmZlxcXFx1ZmZmMC1cXFxcdWZmZmZdL2csYT17XFxcIlxcXFxiXFxcIjpcXFwiXFxcXFxcXFxiXFxcIixcXFwiXFxcXHRcXFwiOlxcXCJcXFxcXFxcXHRcXFwiLFxcXCJcXFxcblxcXCI6XFxcIlxcXFxcXFxcblxcXCIsXFxcIlxcXFxmXFxcIjpcXFwiXFxcXFxcXFxmXFxcIixcXFwiXFxcXHJcXFwiOlxcXCJcXFxcXFxcXHJcXFwiLCdcXFwiJzonXFxcXFxcXFxcXFwiJyxcXFwiXFxcXFxcXFxcXFwiOlxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIn07ZnVuY3Rpb24gcXVvdGUodCl7cmV0dXJuIGMubGFzdEluZGV4PTAsYy50ZXN0KHQpPydcXFwiJyt0LnJlcGxhY2UoYywoZnVuY3Rpb24odCl7dmFyIGU9YVt0XTtyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIGU/ZTpcXFwiXFxcXFxcXFx1XFxcIisoXFxcIjAwMDBcXFwiK3QuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KX0pKSsnXFxcIic6J1xcXCInK3QrJ1xcXCInfWZ1bmN0aW9uIHN0cih0LGUpe3ZhciBuLGMsYSxzLGwscD1pLHk9ZVt0XTtzd2l0Y2goeSYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiB5JiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgeS50b0pTT04mJih5PXkudG9KU09OKHQpKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZiYmKHk9Zi5jYWxsKGUsdCx5KSksdHlwZW9mIHkpe2Nhc2VcXFwic3RyaW5nXFxcIjpyZXR1cm4gcXVvdGUoeSk7Y2FzZVxcXCJudW1iZXJcXFwiOnJldHVybiBpc0Zpbml0ZSh5KT9TdHJpbmcoeSk6XFxcIm51bGxcXFwiO2Nhc2VcXFwiYm9vbGVhblxcXCI6Y2FzZVxcXCJudWxsXFxcIjpyZXR1cm4gU3RyaW5nKHkpO2Nhc2VcXFwib2JqZWN0XFxcIjppZigheSlyZXR1cm5cXFwibnVsbFxcXCI7aWYoaSs9dSxsPVtdLFxcXCJbb2JqZWN0IEFycmF5XVxcXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHkpKXtmb3Iocz15Lmxlbmd0aCxuPTA7bjxzO24rPTEpbFtuXT1zdHIobix5KXx8XFxcIm51bGxcXFwiO3JldHVybiBhPTA9PT1sLmxlbmd0aD9cXFwiW11cXFwiOmk/XFxcIltcXFxcblxcXCIraStsLmpvaW4oXFxcIixcXFxcblxcXCIraSkrXFxcIlxcXFxuXFxcIitwK1xcXCJdXFxcIjpcXFwiW1xcXCIrbC5qb2luKFxcXCIsXFxcIikrXFxcIl1cXFwiLGk9cCxhfWlmKGYmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgZilmb3Iocz1mLmxlbmd0aCxuPTA7bjxzO24rPTEpXFxcInN0cmluZ1xcXCI9PXR5cGVvZihjPWZbbl0pJiYoYT1zdHIoYyx5KSkmJmwucHVzaChxdW90ZShjKSsoaT9cXFwiOiBcXFwiOlxcXCI6XFxcIikrYSk7ZWxzZSBmb3IoYyBpbiB5KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh5LGMpJiYoYT1zdHIoYyx5KSkmJmwucHVzaChxdW90ZShjKSsoaT9cXFwiOiBcXFwiOlxcXCI6XFxcIikrYSk7cmV0dXJuIGE9MD09PWwubGVuZ3RoP1xcXCJ7fVxcXCI6aT9cXFwie1xcXFxuXFxcIitpK2wuam9pbihcXFwiLFxcXFxuXFxcIitpKStcXFwiXFxcXG5cXFwiK3ArXFxcIn1cXFwiOlxcXCJ7XFxcIitsLmpvaW4oXFxcIixcXFwiKStcXFwifVxcXCIsaT1wLGF9fWUuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dmFyIGM7aWYoaT1cXFwiXFxcIix1PVxcXCJcXFwiLFxcXCJudW1iZXJcXFwiPT10eXBlb2Ygbilmb3IoYz0wO2M8bjtjKz0xKXUrPVxcXCIgXFxcIjtlbHNlXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBuJiYodT1uKTtpZihmPWUsZSYmXFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIGUmJihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIGV8fFxcXCJudW1iZXJcXFwiIT10eXBlb2YgZS5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcXFwiSlNPTi5zdHJpbmdpZnlcXFwiKTtyZXR1cm4gc3RyKFxcXCJcXFwiLHtcXFwiXFxcIjp0fSl9fSx7fV0sNTpbZnVuY3Rpb24odCxlLG4pe3ZhciBpLHUsZj1lLmV4cG9ydHM9e307ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcXFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFxcXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXFxcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFxcXCIpfWZ1bmN0aW9uIHJ1blRpbWVvdXQodCl7aWYoaT09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQodCwwKTtpZigoaT09PWRlZmF1bHRTZXRUaW1vdXR8fCFpKSYmc2V0VGltZW91dClyZXR1cm4gaT1zZXRUaW1lb3V0LHNldFRpbWVvdXQodCwwKTt0cnl7cmV0dXJuIGkodCwwKX1jYXRjaChlKXt0cnl7cmV0dXJuIGkuY2FsbChudWxsLHQsMCl9Y2F0Y2goZSl7cmV0dXJuIGkuY2FsbCh0aGlzLHQsMCl9fX0hZnVuY3Rpb24oKXt0cnl7aT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OmRlZmF1bHRTZXRUaW1vdXR9Y2F0Y2godCl7aT1kZWZhdWx0U2V0VGltb3V0fXRyeXt1PVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OmRlZmF1bHRDbGVhclRpbWVvdXR9Y2F0Y2godCl7dT1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0oKTt2YXIgYyxhPVtdLHM9ITEsbD0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtzJiZjJiYocz0hMSxjLmxlbmd0aD9hPWMuY29uY2F0KGEpOmw9LTEsYS5sZW5ndGgmJmRyYWluUXVldWUoKSl9ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKCFzKXt2YXIgdD1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7cz0hMDtmb3IodmFyIGU9YS5sZW5ndGg7ZTspe2ZvcihjPWEsYT1bXTsrK2w8ZTspYyYmY1tsXS5ydW4oKTtsPS0xLGU9YS5sZW5ndGh9Yz1udWxsLHM9ITEsZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KHQpe2lmKHU9PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dCh0KTtpZigodT09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCF1KSYmY2xlYXJUaW1lb3V0KXJldHVybiB1PWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQodCk7dHJ5e3JldHVybiB1KHQpfWNhdGNoKGUpe3RyeXtyZXR1cm4gdS5jYWxsKG51bGwsdCl9Y2F0Y2goZSl7cmV0dXJuIHUuY2FsbCh0aGlzLHQpfX19KHQpfX1mdW5jdGlvbiBJdGVtKHQsZSl7dGhpcy5mdW49dCx0aGlzLmFycmF5PWV9ZnVuY3Rpb24gbm9vcCgpe31mLm5leHRUaWNrPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSlmb3IodmFyIG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWVbbi0xXT1hcmd1bWVudHNbbl07YS5wdXNoKG5ldyBJdGVtKHQsZSkpLDEhPT1hLmxlbmd0aHx8c3x8cnVuVGltZW91dChkcmFpblF1ZXVlKX0sSXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sZi50aXRsZT1cXFwiYnJvd3NlclxcXCIsZi5icm93c2VyPSEwLGYuZW52PXt9LGYuYXJndj1bXSxmLnZlcnNpb249XFxcIlxcXCIsZi52ZXJzaW9ucz17fSxmLm9uPW5vb3AsZi5hZGRMaXN0ZW5lcj1ub29wLGYub25jZT1ub29wLGYub2ZmPW5vb3AsZi5yZW1vdmVMaXN0ZW5lcj1ub29wLGYucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3AsZi5lbWl0PW5vb3AsZi5wcmVwZW5kTGlzdGVuZXI9bm9vcCxmLnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcCxmLmxpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm5bXX0sZi5iaW5kaW5nPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcXFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcXFwiKX0sZi5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cXFwiL1xcXCJ9LGYuY2hkaXI9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFxcXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcXFwiKX0sZi51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0se31dLDY6W2Z1bmN0aW9uKHQsZSxuKXsoZnVuY3Rpb24obil7dmFyIGk9dChcXFwianNvbi1zdGFibGUtc3RyaW5naWZ5XFxcIik7bi5icm93c2VyP3dpbmRvdy5zdHJpbmdpZnk9aTplLmV4cG9ydHM9aX0pLmNhbGwodGhpcyx0KFxcXCJfcHJvY2Vzc1xcXCIpKX0se19wcm9jZXNzOjUsXFxcImpzb24tc3RhYmxlLXN0cmluZ2lmeVxcXCI6MX1dfSx7fSxbNl0pO1wiLFwic3JjL2xpYi9rZXl3b3JkLmpzXCI6XCJmdW5jdGlvbiAkYnVpbHRpbm1vZHVsZSgpe2NvbnN0e2ZmaTp7cmVtYXBUb1B5OnR9LGJ1aWx0aW46e2Zyb3plbnNldDplLHN0cjpzfX09U2ssaT1uZXcgcyhcXFwia2V5d29yZFxcXCIpLG49dChbXFxcImlza2V5d29yZFxcXCIsXFxcImlzc29mdGtleXdvcmRcXFwiLFxcXCJrd2xpc3RcXFwiLFxcXCJzb2Z0a3dsaXN0XFxcIl0pLG89dChbXFxcIkZhbHNlXFxcIixcXFwiTm9uZVxcXCIsXFxcIlRydWVcXFwiLFxcXCJhbmRcXFwiLFxcXCJhc1xcXCIsXFxcImFzc2VydFxcXCIsXFxcImFzeW5jXFxcIixcXFwiYXdhaXRcXFwiLFxcXCJicmVha1xcXCIsXFxcImNsYXNzXFxcIixcXFwiY29udGludWVcXFwiLFxcXCJkZWZcXFwiLFxcXCJkZWxcXFwiLFxcXCJlbGlmXFxcIixcXFwiZWxzZVxcXCIsXFxcImV4Y2VwdFxcXCIsXFxcImZpbmFsbHlcXFwiLFxcXCJmb3JcXFwiLFxcXCJmcm9tXFxcIixcXFwiZ2xvYmFsXFxcIixcXFwiaWZcXFwiLFxcXCJpbXBvcnRcXFwiLFxcXCJpblxcXCIsXFxcImlzXFxcIixcXFwibGFtYmRhXFxcIixcXFwibm9ubG9jYWxcXFwiLFxcXCJub3RcXFwiLFxcXCJvclxcXCIsXFxcInBhc3NcXFwiLFxcXCJyYWlzZVxcXCIsXFxcInJldHVyblxcXCIsXFxcInRyeVxcXCIsXFxcIndoaWxlXFxcIixcXFwid2l0aFxcXCIsXFxcInlpZWxkXFxcIl0pLGE9dChbXFxcIl9cXFwiLFxcXCJjYXNlXFxcIixcXFwibWF0Y2hcXFwiXSk7cmV0dXJue19fbmFtZV9fOmksX19hbGxfXzpuLGt3bGlzdDpvLHNvZnRrd2xpc3Q6YSxpc2tleXdvcmQ6bmV3IGUobykudHAkZ2V0YXR0cihzLiRjb250YWlucyksaXNzb2Z0a2V5d29yZDpuZXcgZShhKS50cCRnZXRhdHRyKHMuJGNvbnRhaW5zKX19XCIsXCJzcmMvbGliL21hdGguanNcIjpcImNvbnN0ICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9e3BpOm5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLlBJKSxlOm5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLkUpLHRhdTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oMipNYXRoLlBJKSxuYW46bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE5hTiksaW5mOm5ldyBTay5idWlsdGluLmZsb2F0XygxLzApfTtjb25zdCBnZXRfc2lnbj1mdW5jdGlvbihlKXtyZXR1cm4gZT1lP2U8MD8tMToxOjEvZTwwPy0xOjF9O2Z1bmN0aW9uIGZhY3RvcmlhbChlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtsZXQgdD1Tay5idWlsdGluLmFzbnVtJChlKTtpZigoZT1NYXRoLmZsb29yKHQpKSE9dCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJmYWN0b3JpYWwoKSBvbmx5IGFjY2VwdHMgaW50ZWdyYWwgdmFsdWVzXFxcIik7aWYoZTwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImZhY3RvcmlhbCgpIG5vdCBkZWZpbmVkIGZvciBuZWdhdGl2ZSBudW1iZXJzXFxcIik7bGV0IG49MTtmb3IobGV0IGk9MjtpPD1lJiZpPD0xODtpKyspbio9aTtpZihlPD0xOClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhuKTtuPUpTQkkuQmlnSW50KG4pO2ZvcihsZXQgaT0xOTtpPD1lO2krKyluPUpTQkkubXVsdGlwbHkobixKU0JJLkJpZ0ludChpKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8obil9ZnVuY3Rpb24gX2djZF9pbnRlcm5hbChlLHQpe2xldCBuO3JldHVyblxcXCJudW1iZXJcXFwiPT10eXBlb2YgZSYmXFxcIm51bWJlclxcXCI9PXR5cGVvZiB0PyhuPWZ1bmN0aW9uIF9nY2QoZSx0KXtyZXR1cm4gMD09dD9lOl9nY2QodCxlJXQpfShlPU1hdGguYWJzKGUpLHQ9TWF0aC5hYnModCkpLG49bjwwPy1uOm4pOihuPWZ1bmN0aW9uIF9iaWdnY2QoZSx0KXtyZXR1cm4gSlNCSS5lcXVhbCh0LEpTQkkuX19aRVJPKT9lOl9iaWdnY2QodCxKU0JJLnJlbWFpbmRlcihlLHQpKX0oZT1KU0JJLkJpZ0ludChlKSx0PUpTQkkuQmlnSW50KHQpKSxKU0JJLmxlc3NUaGFuKG4sSlNCSS5fX1pFUk8pJiYobj1KU0JJLm11bHRpcGx5KG4sSlNCSS5CaWdJbnQoLTEpKSkpLG59cmV0dXJuIFNrLmFic3RyLnNldFVwTW9kdWxlTWV0aG9kcyhcXFwibWF0aFxcXCIsdCx7YWNvczp7JG1ldGg6ZnVuY3Rpb24gYWNvcyhlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hY29zKFNrLmJ1aWx0aW4uYXNudW0kKGUpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGFyYyBjb3NpbmUgKG1lYXN1cmVkIGluIHJhZGlhbnMpIG9mIHguXFxcIn0sYWNvc2g6eyRtZXRoOmZ1bmN0aW9uIGFjb3NoKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9KGU9U2suYnVpbHRpbi5hc251bSQoZSkpK01hdGguc3FydChlKmUtMSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmxvZyh0KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGludmVyc2UgaHlwZXJib2xpYyBjb3NpbmUgb2YgeC5cXFwifSxhc2luOnskbWV0aDpmdW5jdGlvbiBhc2luKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmFzaW4oU2suYnVpbHRpbi5hc251bSQoZSkpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYXJjIHNpbmUgKG1lYXN1cmVkIGluIHJhZGlhbnMpIG9mIHguXFxcIn0sYXNpbmg6eyRtZXRoOmZ1bmN0aW9uIGFzaW5oKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9KGU9U2suYnVpbHRpbi5hc251bSQoZSkpK01hdGguc3FydChlKmUrMSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmxvZyh0KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGludmVyc2UgaHlwZXJib2xpYyBzaW5lIG9mIHguXFxcIn0sYXRhbjp7JG1ldGg6ZnVuY3Rpb24gYXRhbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hdGFuKFNrLmJ1aWx0aW4uYXNudW0kKGUpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGFyYyB0YW5nZW50IChtZWFzdXJlZCBpbiByYWRpYW5zKSBvZiB4LlxcXCJ9LGF0YW4yOnskbWV0aDpmdW5jdGlvbiBhdGFuMihlLHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hdGFuMihTay5idWlsdGluLmFzbnVtJChlKSxTay5idWlsdGluLmFzbnVtJCh0KSkpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYXJjIHRhbmdlbnQgKG1lYXN1cmVkIGluIHJhZGlhbnMpIG9mIHkveC5cXFxcblxcXFxuVW5saWtlIGF0YW4oeS94KSwgdGhlIHNpZ25zIG9mIGJvdGggeCBhbmQgeSBhcmUgY29uc2lkZXJlZC5cXFwifSxhdGFuaDp7JG1ldGg6ZnVuY3Rpb24gYXRhbmgoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7Y29uc3QgdD0oMSsoZT1Tay5idWlsdGluLmFzbnVtJChlKSkpLygxLWUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5sb2codCkvMil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGludmVyc2UgaHlwZXJib2xpYyB0YW5nZW50IG9mIHguXFxcIn0sY2VpbDp7JG1ldGg6ZnVuY3Rpb24gY2VpbChlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJcXFwiLFxcXCJyZWFsIG51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7Y29uc3QgdD1Tay5idWlsdGluLmFzbnVtJChlKTtyZXR1cm4gU2suX19mdXR1cmVfXy5jZWlsX2Zsb29yX2ludD9uZXcgU2suYnVpbHRpbi5pbnRfKE1hdGguY2VpbCh0KSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguY2VpbCh0KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGNlaWxpbmcgb2YgeCBhcyBhbiBJbnRlZ3JhbC5cXFxcblxcXFxuVGhpcyBpcyB0aGUgc21hbGxlc3QgaW50ZWdlciA+PSB4LlxcXCJ9LGNvbWI6eyRtZXRoOmZ1bmN0aW9uIGNvbWIoZSx0KXtsZXQgbj1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhlKSxpPVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KHQpO2lmKG48MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJuIG11c3QgYmUgYW4gbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZihpPDApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiayBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZihpPmUpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7ZT1uZXcgU2suYnVpbHRpbi5pbnRfKG4pLHQ9bmV3IFNrLmJ1aWx0aW4uaW50XyhpKTtsZXQgcj1Tay5mZmkucmVtYXBUb0pzKGUubmIkc3VidHJhY3QodCkpO2lmKHI8aSYmKGk9ciksMD09PWkpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMSk7aWYoaT5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFxcXCJtaW4obiAtIGssIGspIG11c3Qgbm90IGV4Y2VlZCBcXFwiK051bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtjb25zdCB1PW5ldyBTay5idWlsdGluLmludF8oMSk7bGV0IGw9ZTtmb3IobGV0IG89MTtvPGk7bysrKWU9ZS5uYiRzdWJ0cmFjdCh1KSxyPW5ldyBTay5idWlsdGluLmludF8obysxKSxsPWwubmIkbXVsdGlwbHkoZSksbD1sLm5iJGZsb29yX2RpdmlkZShyKTtyZXR1cm4gbH0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIG4sIGs9Tm9uZSwgLylcXFwiLCRkb2M6XFxcIk51bWJlciBvZiB3YXlzIHRvIGNob29zZSBrIGl0ZW1zIGZyb20gbiBpdGVtcyB3aXRob3V0IHJlcGV0aXRpb24gYW5kIHdpdGggb3JkZXIuXFxcXG5cXFxcbkV2YWx1YXRlcyB0byBuISAvIChuIC0gaykhIHdoZW4gayA8PSBuIGFuZCBldmFsdWF0ZXNcXFxcbnRvIHplcm8gd2hlbiBrID4gbi5cXFxcblxcXFxuSWYgayBpcyBub3Qgc3BlY2lmaWVkIG9yIGlzIE5vbmUsIHRoZW4gayBkZWZhdWx0cyB0byBuXFxcXG5hbmQgdGhlIGZ1bmN0aW9uIHJldHVybnMgbiEuXFxcXG5cXFxcblJhaXNlcyBUeXBlRXJyb3IgaWYgZWl0aGVyIG9mIHRoZSBhcmd1bWVudHMgYXJlIG5vdCBpbnRlZ2Vycy5cXFxcblJhaXNlcyBWYWx1ZUVycm9yIGlmIGVpdGhlciBvZiB0aGUgYXJndW1lbnRzIGFyZSBuZWdhdGl2ZS5cXFwifSxjb3B5c2lnbjp7JG1ldGg6ZnVuY3Rpb24gY29weXNpZ24oZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtjb25zdCBuPVNrLmJ1aWx0aW4uYXNudW0kKHQpLGk9U2suYnVpbHRpbi5hc251bSQoZSkscj1nZXRfc2lnbihpKSpnZXRfc2lnbihuKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkqcil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIGEgZmxvYXQgd2l0aCB0aGUgbWFnbml0dWRlIChhYnNvbHV0ZSB2YWx1ZSkgb2YgeCBidXQgdGhlIHNpZ24gb2YgeS5cXFxcblxcXFxuT24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydCBzaWduZWQgemVyb3MsIGNvcHlzaWduKDEuMCwgLTAuMClcXFxcbnJldHVybnMgLTEuMC5cXFxcblxcXCJ9LGNvczp7JG1ldGg6ZnVuY3Rpb24gY29zKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmNvcyhTay5idWlsdGluLmFzbnVtJChlKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBjb3NpbmUgb2YgeCAobWVhc3VyZWQgaW4gcmFkaWFucykuXFxcIn0sY29zaDp7JG1ldGg6ZnVuY3Rpb24gY29zaChlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxlPVNrLmJ1aWx0aW4uYXNudW0kKGUpO2NvbnN0IHQ9TWF0aC5FLG49TWF0aC5wb3codCxlKSxpPShuKzEvbikvMjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiB4LlxcXCJ9LGRlZ3JlZXM6eyRtZXRoOmZ1bmN0aW9uIGRlZ3JlZXMoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PTE4MC9NYXRoLlBJKlNrLmJ1aWx0aW4uYXNudW0kKGUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJDb252ZXJ0IGFuZ2xlIHggZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXFxcIn0sZXJmOnskbWV0aDpmdW5jdGlvbiBlcmYoZSl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5lcmYoKSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiRXJyb3IgZnVuY3Rpb24gYXQgeC5cXFwifSxlcmZjOnskbWV0aDpmdW5jdGlvbiBlcmZjKGUpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm1hdGguZXJmYygpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJDb21wbGVtZW50YXJ5IGVycm9yIGZ1bmN0aW9uIGF0IHguXFxcIn0sZXhwOnskbWV0aDpmdW5jdGlvbiBleHAoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IHQ9ZS52O2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgdCYmKHQ9ZS5uYiRmbG9hdCgpLnYpLHQ9PTEvMHx8dD09LTEvMHx8aXNOYU4odCkpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmV4cCh0KSk7Y29uc3Qgbj1NYXRoLmV4cCh0KTtpZighaXNGaW5pdGUobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcXFwibWF0aCByYW5nZSBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gZSByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIHguXFxcIn0sZXhwbTE6eyRtZXRoOmZ1bmN0aW9uIGV4cG0xKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9U2suYnVpbHRpbi5hc251bSQoZSk7aWYoTWF0aC5hYnModCk8Ljcpe2NvbnN0IGU9TWF0aC5leHAodCk7aWYoMT09ZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHQpO3tjb25zdCBuPShlLTEpKnQvTWF0aC5sb2coZSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhuKX19e2NvbnN0IGU9TWF0aC5leHAodCktMTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGUpfX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBleHAoeCktMS5cXFxcblxcXFxuVGhpcyBmdW5jdGlvbiBhdm9pZHMgdGhlIGxvc3Mgb2YgcHJlY2lzaW9uIGludm9sdmVkIGluIHRoZSBkaXJlY3QgZXZhbHVhdGlvbiBvZiBleHAoeCktMSBmb3Igc21hbGwgeC5cXFwifSxmYWJzOnskbWV0aDpmdW5jdGlvbiBmYWJzKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2xldCB0PWUudjtyZXR1cm4gSlNCSS5fX2lzQmlnSW50KHQpJiYodD1lLm5iJGZsb2F0KCkudiksdD1NYXRoLmFicyh0KSxuZXcgU2suYnVpbHRpbi5mbG9hdF8odCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBmbG9hdCB4LlxcXCJ9LGZhY3RvcmlhbDp7JG1ldGg6ZmFjdG9yaWFsLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJGaW5kIHghLlxcXFxuXFxcXG5SYWlzZSBhIFZhbHVlRXJyb3IgaWYgeCBpcyBuZWdhdGl2ZSBvciBub24taW50ZWdyYWwuXFxcIn0sZmxvb3I6eyRtZXRoOmZ1bmN0aW9uIGZsb29yKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5fX2Z1dHVyZV9fLmNlaWxfZmxvb3JfaW50P25ldyBTay5idWlsdGluLmludF8oTWF0aC5mbG9vcihTay5idWlsdGluLmFzbnVtJChlKSkpOm5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmZsb29yKFNrLmJ1aWx0aW4uYXNudW0kKGUpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGZsb29yIG9mIHggYXMgYW4gSW50ZWdyYWwuXFxcXG5cXFxcblRoaXMgaXMgdGhlIGxhcmdlc3QgaW50ZWdlciA8PSB4LlxcXCJ9LGZtb2Q6eyRtZXRoOmZ1bmN0aW9uIGZtb2QoZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtsZXQgbj1lLnYsaT10LnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBuJiYobj1lLm5iJGZsb2F0KCkudiksXFxcIm51bWJlclxcXCIhPXR5cGVvZiBpJiYoaT10Lm5iJGZsb2F0KCkudiksKGk9PTEvMHx8aT09LTEvMCkmJmlzRmluaXRlKG4pKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obik7Y29uc3Qgcj1uJWk7aWYoaXNOYU4ocikmJiFpc05hTihuKSYmIWlzTmFOKGkpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhyKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIHksIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gZm1vZCh4LCB5KSwgYWNjb3JkaW5nIHRvIHBsYXRmb3JtIEMuXFxcXG5cXFxcbnggJSB5IG1heSBkaWZmZXIuXFxcIn0sZnJleHA6eyRtZXRoOmZ1bmN0aW9uIGZyZXhwKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9U2suYnVpbHRpbi5hc251bSQoZSksbj1bdCwwXTtpZigwIT09dCYmTnVtYmVyLmlzRmluaXRlKHQpKXtjb25zdCBlPU1hdGguYWJzKHQpO2xldCBpPU1hdGgubWF4KC0xMDIzLE1hdGguZmxvb3IoTWF0aC5sb2cyKGUpKSsxKSxyPWUqTWF0aC5wb3coMiwtaSk7Zm9yKDtyPC41OylyKj0yLGktLTtmb3IoO3I+PTE7KXIqPS41LGkrKzt0PDAmJihyPS1yKSxuWzBdPXIsblsxXT1pfXJldHVybiBuWzBdPW5ldyBTay5idWlsdGluLmZsb2F0XyhuWzBdKSxuWzFdPW5ldyBTay5idWlsdGluLmludF8oblsxXSksbmV3IFNrLmJ1aWx0aW4udHVwbGUobil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIG1hbnRpc3NhIGFuZCBleHBvbmVudCBvZiB4LCBhcyBwYWlyIChtLCBlKS5cXFxcblxcXFxubSBpcyBhIGZsb2F0IGFuZCBlIGlzIGFuIGludCwgc3VjaCB0aGF0IHggPSBtICogMi4qKmUuXFxcXG5JZiB4IGlzIDAsIG0gYW5kIGUgYXJlIGJvdGggMC4gIEVsc2UgMC41IDw9IGFicyhtKSA8IDEuMC5cXFwifSxmc3VtOnskbWV0aDpmdW5jdGlvbiBmc3VtKGUpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCInXFxcIitTay5hYnN0ci50eXBlTmFtZShlKStcXFwiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXFxcIik7bGV0IHQsbixpLHI9W107Zm9yKGxldCBsPShlPVNrLmFic3RyLml0ZXIoZSkpLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09bDtsPWUudHAkaXRlcm5leHQoKSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiXFxcIixcXFwicmVhbCBudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIobCkpLHQ9MDtsZXQgZT1sLnY7XFxcIm51bWJlclxcXCIhPXR5cGVvZiBlJiYoZT1sLm5iJGZsb2F0KCkudiksbD1lO2ZvcihsZXQgdT0wLG89ci5sZW5ndGg7dTxvO3UrKyl7bGV0IGU9clt1XTtpZihNYXRoLmFicyhsKTxNYXRoLmFicyhlKSl7bGV0IHQ9bDtsPWUsZT10fW49bCtlLGk9ZS0obi1sKSxpJiYoclt0XT1pLHQrKyksbD1ufXI9ci5zbGljZSgwLHQpLmNvbmNhdChbbF0pfWNvbnN0IHU9ci5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdH0pLDApO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHNlcSwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBhbiBhY2N1cmF0ZSBmbG9hdGluZyBwb2ludCBzdW0gb2YgdmFsdWVzIGluIHRoZSBpdGVyYWJsZSBzZXEuXFxcXG5cXFxcbkFzc3VtZXMgSUVFRS03NTQgZmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYy5cXFwifSxnYW1tYTp7JG1ldGg6ZnVuY3Rpb24gZ2FtbWEoZSl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5nYW1tYSgpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJHYW1tYSBmdW5jdGlvbiBhdCB4LlxcXCJ9LGdjZDp7JG1ldGg6ZnVuY3Rpb24gZ2NkKGUsdCl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiYVxcXCIsXFxcImludGVnZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tJbnQoZSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImJcXFwiLFxcXCJpbnRlZ2VyXFxcIixTay5idWlsdGluLmNoZWNrSW50KHQpKTtjb25zdCBuPV9nY2RfaW50ZXJuYWwoU2suYnVpbHRpbi5hc251bSQoZSksU2suYnVpbHRpbi5hc251bSQodCkpO3JldHVyblxcXCJudW1iZXJcXFwiPT10eXBlb2Ygbj9uZXcgU2suYnVpbHRpbi5pbnRfKG4pOm5ldyBTay5idWlsdGluLmludF8obi50b1N0cmluZygpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIHksIC8pXFxcIiwkZG9jOlxcXCJncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiB4IGFuZCB5XFxcIn0saHlwb3Q6eyRtZXRoOmZ1bmN0aW9uIGh5cG90KGUsdCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInlcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIodCkpLGU9U2suYnVpbHRpbi5hc251bSQoZSksdD1Tay5idWlsdGluLmFzbnVtJCh0KSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5zcXJ0KGUqZSt0KnQpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIHksIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSwgc3FydCh4KnggKyB5KnkpLlxcXCJ9LGlzY2xvc2U6eyRtZXRoOmZ1bmN0aW9uIGlzY2xvc2UoZSx0KXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcImlzY2xvc2VcXFwiLGUsMiwyKTtjb25zdCBuPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJpc2Nsb3NlXFxcIixbXFxcInJlbF90b2xcXFwiLFxcXCJhYnNfdG9sXFxcIl0sW10sdCxbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDFlLTkpLG5ldyBTay5idWlsdGluLmZsb2F0XygwKV0pLGk9ZVswXSxyPWVbMV0sdT1uWzBdLGw9blsxXTtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJhXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGkpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJiXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHIpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyZWxfdG9sXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJhYnNfdG9sXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGwpKTtjb25zdCBvPVNrLmJ1aWx0aW4uYXNudW0kKGkpLGE9U2suYnVpbHRpbi5hc251bSQocikscz1Tay5idWlsdGluLmFzbnVtJCh1KSxiPVNrLmJ1aWx0aW4uYXNudW0kKGwpO2lmKHM8MHx8YjwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcInRvbGVyYW5jZXMgbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTtpZihvPT1hKXJldHVybiBTay5idWlsdGluLmJvb2wudHJ1ZSQ7aWYobz09MS8wfHxvPT0tMS8wfHxhPT0xLzB8fGE9PS0xLzApcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7Y29uc3QgYz1NYXRoLmFicyhhLW8pLG09Yzw9TWF0aC5hYnMocyphKXx8Yzw9TWF0aC5hYnMocypvKXx8Yzw9YjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbChtKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCAvLCBhLCBiLCAqLCByZWxfdG9sPTFlLTA5LCBhYnNfdG9sPTAuMClcXFwiLCRkb2M6J0RldGVybWluZSB3aGV0aGVyIHR3byBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFyZSBjbG9zZSBpbiB2YWx1ZS5cXFxcblxcXFxuICByZWxfdG9sXFxcXG4gICAgbWF4aW11bSBkaWZmZXJlbmNlIGZvciBiZWluZyBjb25zaWRlcmVkIFxcXCJjbG9zZVxcXCIsIHJlbGF0aXZlIHRvIHRoZVxcXFxuICAgIG1hZ25pdHVkZSBvZiB0aGUgaW5wdXQgdmFsdWVzXFxcXG4gIGFic190b2xcXFxcbiAgICBtYXhpbXVtIGRpZmZlcmVuY2UgZm9yIGJlaW5nIGNvbnNpZGVyZWQgXFxcImNsb3NlXFxcIiwgcmVnYXJkbGVzcyBvZiB0aGVcXFxcbiAgICBtYWduaXR1ZGUgb2YgdGhlIGlucHV0IHZhbHVlc1xcXFxuXFxcXG5SZXR1cm4gVHJ1ZSBpZiBhIGlzIGNsb3NlIGluIHZhbHVlIHRvIGIsIGFuZCBGYWxzZSBvdGhlcndpc2UuXFxcXG5cXFxcbkZvciB0aGUgdmFsdWVzIHRvIGJlIGNvbnNpZGVyZWQgY2xvc2UsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlbVxcXFxubXVzdCBiZSBzbWFsbGVyIHRoYW4gYXQgbGVhc3Qgb25lIG9mIHRoZSB0b2xlcmFuY2VzLlxcXFxuXFxcXG4taW5mLCBpbmYgYW5kIE5hTiBiZWhhdmUgc2ltaWxhcmx5IHRvIHRoZSBJRUVFIDc1NCBTdGFuZGFyZC4gIFRoYXRcXFxcbmlzLCBOYU4gaXMgbm90IGNsb3NlIHRvIGFueXRoaW5nLCBldmVuIGl0c2VsZi4gIGluZiBhbmQgLWluZiBhcmVcXFxcbm9ubHkgY2xvc2UgdG8gdGhlbXNlbHZlcy4nfSxpc2Zpbml0ZTp7JG1ldGg6ZnVuY3Rpb24gaXNmaW5pdGUoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7Y29uc3QgdD1Tay5idWlsdGluLmFzbnVtJChlKTtyZXR1cm4gU2suYnVpbHRpbi5jaGVja0ludChlKXx8aXNGaW5pdGUodCk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gVHJ1ZSBpZiB4IGlzIG5laXRoZXIgYW4gaW5maW5pdHkgbm9yIGEgTmFOLCBhbmQgRmFsc2Ugb3RoZXJ3aXNlLlxcXCJ9LGlzaW5mOnskbWV0aDpmdW5jdGlvbiBpc2luZihlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PVNrLmJ1aWx0aW4uYXNudW0kKGUpO3JldHVybiBTay5idWlsdGluLmNoZWNrSW50KGUpfHxpc0Zpbml0ZSh0KXx8aXNOYU4odCk/U2suYnVpbHRpbi5ib29sLmZhbHNlJDpTay5idWlsdGluLmJvb2wudHJ1ZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gVHJ1ZSBpZiB4IGlzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW5maW5pdHksIGFuZCBGYWxzZSBvdGhlcndpc2UuXFxcIn0saXNuYW46eyRtZXRoOmZ1bmN0aW9uIGlzbmFuKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9U2suYnVpbHRpbi5hc251bSQoZSk7cmV0dXJuIGlzTmFOKHQpP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIFRydWUgaWYgeCBpcyBhIE5hTiAobm90IGEgbnVtYmVyKSwgYW5kIEZhbHNlIG90aGVyd2lzZS5cXFwifSxpc3FydDp7JG1ldGg6ZnVuY3Rpb24gaXNxcnQoZSl7bGV0IHQ9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coZSk7aWYodDwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImlzcXJ0KCkgYXJndW1lbnQgbXVzdCBiZSBub25uZWdhdGl2ZVxcXCIpO3JldHVybiAwPT10P25ldyBTay5idWlsdGluLmludF8oMCk6XFxcIm51bWJlclxcXCI9PXR5cGVvZiB0P25ldyBTay5idWlsdGluLmludF8oTWF0aC5mbG9vcihNYXRoLnNxcnQodCkpKTpmdW5jdGlvbiBiaWdpbnRfaXNxcnQoZSl7bGV0IHQ9ZS50b1N0cmluZygyKS5sZW5ndGg7dD1NYXRoLmZsb29yKCh0LTEpLzIpO2xldCBuPXQudG9TdHJpbmcoMikubGVuZ3RoO2NvbnN0IGk9SlNCSS5CaWdJbnQoMSkscj1KU0JJLkJpZ0ludCgyKSx1PUpTQkkuQmlnSW50KHQpLGw9SlNCSS5tdWx0aXBseShyLHUpO2xldCBvPWksYT1KU0JJLkJpZ0ludCgwKTtmb3IoO24+MDspe24tLTtsZXQgdD1hO2E9SlNCSS5zaWduZWRSaWdodFNoaWZ0KHUsSlNCSS5CaWdJbnQobikpO2NvbnN0IHI9SlNCSS5zdWJ0cmFjdChKU0JJLnN1YnRyYWN0KGEsdCksaSkscz1KU0JJLmxlZnRTaGlmdChvLHIpLGI9SlNCSS5hZGQoSlNCSS5zdWJ0cmFjdChKU0JJLnN1YnRyYWN0KGwsdCksYSksaSksYz1KU0JJLnNpZ25lZFJpZ2h0U2hpZnQoZSxiKTtvPUpTQkkuYWRkKHMsSlNCSS5kaXZpZGUoYyxvKSl9bGV0IHM9bztyZXR1cm4gSlNCSS5ncmVhdGVyVGhhbihKU0JJLm11bHRpcGx5KHMscyksZSkmJihzPUpTQkkuc3VidHJhY3QocyxpKSksSlNCSS5sZXNzVGhhbk9yRXF1YWwocyxKU0JJLkJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpJiYocz1OdW1iZXIocykpLG5ldyBTay5idWlsdGluLmludF8ocyl9KHQpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBuLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHNxdWFyZSByb290IG9mIHRoZSBpbnB1dC5cXFwifSxsY206eyRtZXRoOmZ1bmN0aW9uIGxjbSguLi5lKXtmdW5jdGlvbiBhYnMoZSl7cmV0dXJuXFxcIm51bWJlclxcXCI9PXR5cGVvZiBlP25ldyBTay5idWlsdGluLmludF8oTWF0aC5hYnMoZSkpOkpTQkkubGVzc1RoYW4oZSxKU0JJLl9fWkVSTyk/bmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLnVuYXJ5TWludXMoZSkpOm5ldyBTay5idWlsdGluLmludF8oZSl9Y29uc3QgdD1lLmxlbmd0aDtpZigwPT09dClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygxKTtsZXQgbjtmb3Iobj0wO248dDsrK24pZVtuXT1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhlW25dKTtsZXQgaSxyPWVbMF07aWYoMT09PXQpcmV0dXJuIGFicyhyKTtmb3Iobj0xO248dDsrK24pe2lmKGk9ZVtuXSwwPT09aSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygwKTtpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mIHImJlxcXCJudW1iZXJcXFwiPT10eXBlb2YgaSl7bGV0IGU9ci9fZ2NkX2ludGVybmFsKHIsaSkqaTtlPU1hdGguYWJzKGUpLHI9ZT5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUj9KU0JJLkJpZ0ludChyKTplfWVsc2Ugcj1KU0JJLkJpZ0ludChyKTtcXFwibnVtYmVyXFxcIiE9dHlwZW9mIHImJihpPUpTQkkuQmlnSW50KGkpLHI9SlNCSS5tdWx0aXBseShKU0JJLmRpdmlkZShyLF9nY2RfaW50ZXJuYWwocixpKSksaSkpfXJldHVybiBhYnMocil9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsICppbnRlZ2VycywgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlIG9mIHRoZSBzcGVjaWZpZWQgaW50ZWdlciBhcmd1bWVudHMuIElmIGFsbCBhcmd1bWVudHMgYXJlIG5vbnplcm8sIHRoZW4gdGhlIHJldHVybmVkIHZhbHVlIGlzIHRoZSBzbWFsbGVzdCBwb3NpdGl2ZSBpbnRlZ2VyIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiBhbGwgYXJndW1lbnRzLiBJZiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBpcyB6ZXJvLCB0aGVuIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyAwLiBsY20oKSB3aXRob3V0IGFyZ3VtZW50cyByZXR1cm5zIDEuXFxcIn0sbGRleHA6eyRtZXRoOmZ1bmN0aW9uIGxkZXhwKGUsdCl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiaVxcXCIsXFxcImludGVnZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tJbnQodCkpO2xldCBuPWUudjtcXFwibnVtYmVyXFxcIiE9dHlwZW9mIG4mJihuPWUubmIkZmxvYXQoKS52KTtjb25zdCBpPVNrLmJ1aWx0aW4uYXNudW0kKHQpO2lmKG49PTEvMHx8bj09LTEvMHx8MD09bnx8aXNOYU4obikpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhuKTtjb25zdCByPW4qTWF0aC5wb3coMixpKTtpZighaXNGaW5pdGUocikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcXFwibWF0aCByYW5nZSBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCBpLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHggKiAoMioqaSkuXFxcXG5cXFxcblRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIGludmVyc2Ugb2YgZnJleHAoKS5cXFwifSxsZ2FtbWE6eyRtZXRoOmZ1bmN0aW9uIGxnYW1tYShlKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtYXRoLmxnYW1tYSgpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJOYXR1cmFsIGxvZ2FyaXRobSBvZiBhYnNvbHV0ZSB2YWx1ZSBvZiBHYW1tYSBmdW5jdGlvbiBhdCB4LlxcXCJ9LGxvZzp7JG1ldGg6ZnVuY3Rpb24gbG9nKGUsdCl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IG4saSxyPVNrLmJ1aWx0aW4uYXNudW0kKGUpO2lmKHI8PTApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtpZih2b2lkIDA9PT10P249TWF0aC5FOihTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJiYXNlXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKSxuPVNrLmJ1aWx0aW4uYXNudW0kKHQpKSxuPD0wKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoU2suYnVpbHRpbi5jaGVja0Zsb2F0KGUpfHxyPE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKWk9TWF0aC5sb2cocikvTWF0aC5sb2cobik7ZWxzZXtyPW5ldyBTay5idWlsdGluLnN0cihlKS4kanNzdHIoKTtjb25zdCB0PXIubGVuZ3RoLHU9cGFyc2VGbG9hdChcXFwiMC5cXFwiK3IpO2k9KHQqTWF0aC5sb2coMTApK01hdGgubG9nKHUpKS9NYXRoLmxvZyhuKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwibG9nKHgsIFtiYXNlPWVdKVxcXFxuUmV0dXJuIHRoZSBsb2dhcml0aG0gb2YgeCB0byB0aGUgZ2l2ZW4gYmFzZS5cXFxcblxcXFxuSWYgdGhlIGJhc2Ugbm90IHNwZWNpZmllZCwgcmV0dXJucyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gKGJhc2UgZSkgb2YgeC5cXFwifSxsb2cxMDp7JG1ldGg6ZnVuY3Rpb24gbG9nMTAoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IHQsbj1Tay5idWlsdGluLmFzbnVtJChlKTtpZihuPD0wKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoU2suYnVpbHRpbi5jaGVja0Zsb2F0KGUpfHxuPE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXQ9TWF0aC5sb2cxMChuKTtlbHNle249bmV3IFNrLmJ1aWx0aW4uc3RyKGUpLiRqc3N0cigpO2NvbnN0IGk9bi5sZW5ndGgscj1wYXJzZUZsb2F0KFxcXCIwLlxcXCIrbik7dD1pK01hdGgubG9nMTAocil9cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYmFzZSAxMCBsb2dhcml0aG0gb2YgeC5cXFwifSxsb2cxcDp7JG1ldGg6ZnVuY3Rpb24gbG9nMXAoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IHQ9ZS52O2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgdCYmKHQ9ZS5uYiRmbG9hdCgpLnYpLHQ8PS0xKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoMD09dClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHQpO2lmKE1hdGguYWJzKHQpPE51bWJlci5FUFNJTE9OLzIpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KTtpZigtLjU8PXQmJnQ8PTEpe2NvbnN0IGU9MSt0LG49TWF0aC5sb2coZSktKGUtMS10KS9lO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obil9e2NvbnN0IGU9TWF0aC5sb2coMSt0KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGUpfX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMSt4IChiYXNlIGUpLlxcXFxuXFxcXG5UaGUgcmVzdWx0IGlzIGNvbXB1dGVkIGluIGEgd2F5IHdoaWNoIGlzIGFjY3VyYXRlIGZvciB4IG5lYXIgemVyby5cXFwifSxsb2cyOnskbWV0aDpmdW5jdGlvbiBsb2cyKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2xldCB0LG49U2suYnVpbHRpbi5hc251bSQoZSk7aWYobjw9MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJtYXRoIGRvbWFpbiBlcnJvclxcXCIpO2lmKFNrLmJ1aWx0aW4uY2hlY2tGbG9hdChlKXx8bjxOdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0PU1hdGgubG9nMihuKTtlbHNle249bmV3IFNrLmJ1aWx0aW4uc3RyKGUpLiRqc3N0cigpO2NvbnN0IGk9bi5sZW5ndGgscj1wYXJzZUZsb2F0KFxcXCIwLlxcXCIrbik7dD1pKk1hdGgubG9nMigxMCkrTWF0aC5sb2cyKHIpfXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGJhc2UgMiBsb2dhcml0aG0gb2YgeC5cXFwifSxtb2RmOnskbWV0aDpmdW5jdGlvbiBtb2RmKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2xldCB0PVNrLmJ1aWx0aW4uYXNudW0kKGUpO2lmKCFpc0Zpbml0ZSh0KSl7aWYodD09MS8wKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KV0pO2lmKHQ9PS0xLzApcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8oLTApLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KV0pO2lmKGlzTmFOKHQpKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHQpLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KV0pfWNvbnN0IG49Z2V0X3NpZ24odCk7dD1NYXRoLmFicyh0KTtjb25zdCBpPW4qTWF0aC5mbG9vcih0KSxyPW4qKHQtTWF0aC5mbG9vcih0KSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8ociksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkpXSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGZyYWN0aW9uYWwgYW5kIGludGVnZXIgcGFydHMgb2YgeC5cXFxcblxcXFxuQm90aCByZXN1bHRzIGNhcnJ5IHRoZSBzaWduIG9mIHggYW5kIGFyZSBmbG9hdHMuXFxcIn0scGVybTp7JG1ldGg6ZnVuY3Rpb24gcGVybShlLHQpe2lmKHZvaWQgMD09PXR8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKHQpKXJldHVybiBmYWN0b3JpYWwoZSk7aWYoZT1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhlKSx0PVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KHQpLGU8MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJuIG11c3QgYmUgYW4gbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZih0PDApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiayBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZih0PmUpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7aWYoMD09PXQpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMSk7aWYodD5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFxcXCJrIG11c3Qgbm90IGV4Y2VlZCBcXFwiK051bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtjb25zdCBuPW5ldyBTay5idWlsdGluLmludF8oMSk7bGV0IGk9ZT1uZXcgU2suYnVpbHRpbi5pbnRfKGUpO2ZvcihsZXQgcj0xO3I8dDtyKyspZT1lLm5iJHN1YnRyYWN0KG4pLGk9aS5uYiRtdWx0aXBseShlKTtyZXR1cm4gaX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIG4sIGs9Tm9uZSwgLylcXFwiLCRkb2M6XFxcIidOdW1iZXIgb2Ygd2F5cyB0byBjaG9vc2UgayBpdGVtcyBmcm9tIG4gaXRlbXMgd2l0aG91dCByZXBldGl0aW9uIGFuZCB3aXRoIG9yZGVyLlxcXFxuXFxcXG5FdmFsdWF0ZXMgdG8gbiEgLyAobiAtIGspISB3aGVuIGsgPD0gbiBhbmQgZXZhbHVhdGVzXFxcXG50byB6ZXJvIHdoZW4gayA+IG4uXFxcXG5cXFxcbklmIGsgaXMgbm90IHNwZWNpZmllZCBvciBpcyBOb25lLCB0aGVuIGsgZGVmYXVsdHMgdG8gblxcXFxuYW5kIHRoZSBmdW5jdGlvbiByZXR1cm5zIG4hLlxcXFxuXFxcXG5SYWlzZXMgVHlwZUVycm9yIGlmIGVpdGhlciBvZiB0aGUgYXJndW1lbnRzIGFyZSBub3QgaW50ZWdlcnMuXFxcXG5SYWlzZXMgVmFsdWVFcnJvciBpZiBlaXRoZXIgb2YgdGhlIGFyZ3VtZW50cyBhcmUgbmVnYXRpdmUuJ1xcXCJ9LHByb2Q6eyRtZXRoOmZ1bmN0aW9uIHByb2QoZSx0KXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcInByb2RcXFwiLGUsMSwxKSxlPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJwcm9kXFxcIixbbnVsbCxcXFwic3RhcnRcXFwiXSxlLHQsW25ldyBTay5idWlsdGluLmludF8oMSldKTtjb25zdCBuPVNrLmFic3RyLml0ZXIoZVswXSk7bGV0IGkscj1lWzFdO3JldHVybiBpPXIuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmludF8/ZnVuY3Rpb24gZmFzdFByb2RJbnQoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihuLChlPT57aWYoZS5jb25zdHJ1Y3RvciE9PVNrLmJ1aWx0aW4uaW50XylyZXR1cm4gZS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRfPyhyPXIubmIkZmxvYXQoKS5uYiRtdWx0aXBseShlKSxuZXcgU2subWlzY2V2YWwuQnJlYWsoXFxcImZsb2F0XFxcIikpOihyPVNrLmFic3RyLm51bWJlckJpbk9wKHIsZSxcXFwiTXVsdFxcXCIpLG5ldyBTay5taXNjZXZhbC5CcmVhayhcXFwic2xvd1xcXCIpKTtyPXIubmIkbXVsdGlwbHkoZSl9KSl9KCk6ci5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRfP1xcXCJmbG9hdFxcXCI6XFxcInNsb3dcXFwiLFNrLm1pc2NldmFsLmNoYWluKGksKGU9PlxcXCJmbG9hdFxcXCI9PT1lP2Z1bmN0aW9uIGZhc3RQcm9kRmxvYXQoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihuLChlPT57aWYoZS5jb25zdHJ1Y3RvciE9PVNrLmJ1aWx0aW4uZmxvYXRfJiZlLmNvbnN0cnVjdG9yIT09U2suYnVpbHRpbi5pbnRfKXJldHVybiByPVNrLmFic3RyLm51bWJlckJpbk9wKHIsZSxcXFwiTXVsdFxcXCIpLG5ldyBTay5taXNjZXZhbC5CcmVhayhcXFwic2xvd1xcXCIpO3I9ci5uYiRtdWx0aXBseShlKX0pKX0oKTplKSwoZT0+e2lmKFxcXCJzbG93XFxcIj09PWUpcmV0dXJuIGZ1bmN0aW9uIHNsb3dQcm9kKCl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IobiwoZT0+e3I9U2suYWJzdHIubnVtYmVyQmluT3AocixlLFxcXCJNdWx0XFxcIil9KSl9KCl9KSwoKCk9PnIpKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBpdGVyYWJsZSwgLywgKiwgc3RhcnQ9MSlcXFwiLCRkb2M6XFxcIkNhbGN1bGF0ZSB0aGUgcHJvZHVjdCBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBpbnB1dCBpdGVyYWJsZS4gVGhlIGRlZmF1bHQgc3RhcnQgdmFsdWUgZm9yIHRoZSBwcm9kdWN0IGlzIDEuXFxcXG5cXFxcbldoZW4gdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCByZXR1cm4gdGhlIHN0YXJ0IHZhbHVlLiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHNwZWNpZmljYWxseSBmb3IgdXNlIHdpdGggbnVtZXJpYyB2YWx1ZXMgYW5kIG1heSByZWplY3Qgbm9uLW51bWVyaWMgdHlwZXMuXFxcIn0scG93OnskbWV0aDpmdW5jdGlvbiBwb3coZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtsZXQgbj1lLnYsaT10LnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBuJiYobj1lLm5iJGZsb2F0KCkudiksXFxcIm51bWJlclxcXCIhPXR5cGVvZiBpJiYoaT10Lm5iJGZsb2F0KCkudiksMD09biYmaTwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoMT09bilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDEpO2lmKE51bWJlci5pc0Zpbml0ZShuKSYmTnVtYmVyLmlzRmluaXRlKGkpJiZuPDAmJiFOdW1iZXIuaXNJbnRlZ2VyKGkpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoLTE9PW4mJihpPT0tMS8wfHxpPT0xLzApKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oMSk7Y29uc3Qgcj1NYXRoLnBvdyhuLGkpO2lmKCFOdW1iZXIuaXNGaW5pdGUobil8fCFOdW1iZXIuaXNGaW5pdGUoaSkpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhyKTtpZihyPT0xLzB8fHI9PS0xLzApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcXFwibWF0aCByYW5nZSBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHgqKnkgKHggdG8gdGhlIHBvd2VyIG9mIHkpLlxcXCJ9LHJhZGlhbnM6eyRtZXRoOmZ1bmN0aW9uIHJhZGlhbnMoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiZGVnXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PU1hdGguUEkvMTgwKlNrLmJ1aWx0aW4uYXNudW0kKGUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJDb252ZXJ0IGFuZ2xlIHggZnJvbSBkZWdyZWVzIHRvIHJhZGlhbnMuXFxcIn0scmVtYWluZGVyOnskbWV0aDpmdW5jdGlvbiByZW1haW5kZXIoZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtsZXQgbj1lLnYsaT10LnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBuJiYobj1lLm5iJGZsb2F0KCkudiksXFxcIm51bWJlclxcXCIhPXR5cGVvZiBpJiYoaT10Lm5iJGZsb2F0KCkudiksaXNGaW5pdGUobikmJmlzRmluaXRlKGkpKXtsZXQgZSx0LHIsdSxsO2lmKDA9PWkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtpZihlPU1hdGguYWJzKG4pLHQ9TWF0aC5hYnMoaSksdT1lJXQscj10LXUsdTxyKWw9dTtlbHNlIGlmKHU+cilsPS1yO2Vsc2V7aWYodSE9cil0aHJvdyBuZXcgU2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcjtsPXUtLjUqKGUtdSkldCoyfXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oZ2V0X3NpZ24obikqbCl9aWYoaXNOYU4obikpcmV0dXJuIGU7aWYoaXNOYU4oaSkpcmV0dXJuIHQ7aWYobj09MS8wfHxuPT0tMS8wKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoaSE9MS8wJiZpIT0tMS8wKXRocm93IG5ldyBTay5idWlsdGluLkFzc2VydGlvbkVycm9yO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiRGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHRoZSBjbG9zZXN0IGludGVnZXIgbXVsdGlwbGUgb2YgeS5cXFxcblxcXFxuUmV0dXJuIHggLSBuKnkgd2hlcmUgbip5IGlzIHRoZSBjbG9zZXN0IGludGVnZXIgbXVsdGlwbGUgb2YgeS5cXFxcbkluIHRoZSBjYXNlIHdoZXJlIHggaXMgZXhhY3RseSBoYWxmd2F5IGJldHdlZW4gdHdvIG11bHRpcGxlcyBvZlxcXFxueSwgdGhlIG5lYXJlc3QgZXZlbiB2YWx1ZSBvZiBuIGlzIHVzZWQuIFRoZSByZXN1bHQgaXMgYWx3YXlzIGV4YWN0LlxcXCJ9LHNpbjp7JG1ldGg6ZnVuY3Rpb24gc2luKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLnNpbihTay5idWlsdGluLmFzbnVtJChlKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBzaW5lIG9mIHggKG1lYXN1cmVkIGluIHJhZGlhbnMpLlxcXCJ9LHNpbmg6eyRtZXRoOmZ1bmN0aW9uIHNpbmgoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSksZT1Tay5idWlsdGluLmFzbnVtJChlKTtjb25zdCB0PU1hdGguRSxuPU1hdGgucG93KHQsZSksaT0obi0xL24pLzI7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIHguXFxcIn0sc3FydDp7JG1ldGg6ZnVuY3Rpb24gc3FydChlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PVNrLmJ1aWx0aW4uYXNudW0kKGUpO2lmKHQ8MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJtYXRoIGRvbWFpbiBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5zcXJ0KHQpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgc3F1YXJlIHJvb3Qgb2YgeC5cXFwifSx0YW46eyRtZXRoOmZ1bmN0aW9uIHRhbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC50YW4oU2suYnVpbHRpbi5hc251bSQoZSkpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgdGFuZ2VudCBvZiB4IChtZWFzdXJlZCBpbiByYWRpYW5zKS5cXFwifSx0YW5oOnskbWV0aDpmdW5jdGlvbiB0YW5oKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9U2suYnVpbHRpbi5hc251bSQoZSk7aWYoMD09PXQpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KTtjb25zdCBuPU1hdGguRSxpPU1hdGgucG93KG4sdCkscj0xL2ksdT0oaS1yKS8yLygoaStyKS8yKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHUpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgeC5cXFwifSx0cnVuYzp7JG1ldGg6ZnVuY3Rpb24gdHJ1bmMoZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLFNrLmJ1aWx0aW4uY2hlY2tJbnQoZSk/ZTpuZXcgU2suYnVpbHRpbi5pbnRfKDB8U2suYnVpbHRpbi5hc251bSQoZSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiVHJ1bmNhdGVzIHRoZSBSZWFsIHggdG8gdGhlIG5lYXJlc3QgSW50ZWdyYWwgdG93YXJkIDAuXFxcXG5cXFxcblVzZXMgdGhlIF9fdHJ1bmNfXyBtYWdpYyBtZXRob2QuXFxcIn19KSx0fTtcIixcInNyYy9saWIvb3BlcmF0b3IuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKGUpe2NvbnN0e2J1aWx0aW46e3N0cjp0LHR1cGxlOmEsbGlzdDpyLGludF86byxib29sOm4sVHlwZUVycm9yOnMsVmFsdWVFcnJvcjppLG5vbmU6e25vbmUkOm19LE5vdEltcGxlbWVudGVkOntOb3RJbXBsZW1lbnRlZCQ6ZH0sYWJzOmwsbGVuOmgsY2hlY2tTdHJpbmc6dSxjaGVja0ludDpjfSxhYnN0cjp7YnVpbGROYXRpdmVDbGFzczpNLGNoZWNrTm9Ld2FyZ3M6YixjaGVja0FyZ3NMZW46ZyxjaGVja09uZUFyZzpmLG51bWJlclVuYXJ5T3A6cCxudW1iZXJCaW5PcDpBLG51bWJlcklucGxhY2VCaW5PcDprLG9iamVjdEdldEl0ZW06JCxvYmplY3REZWxJdGVtOl8sb2JqZWN0U2V0SXRlbTp3LHNlcXVlbmNlQ29uY2F0OnYsc2VxdWVuY2VDb250YWluczp4LHNlcXVlbmNlR2V0Q291bnRPZjpqLHNlcXVlbmNlR2V0SW5kZXhPZjpPLHNlcXVlbmNlSW5QbGFjZUNvbmNhdDpJLHR5cGVOYW1lOlMsbG9va3VwU3BlY2lhbDp5LGdhdHRyOnEsc2V0VXBNb2R1bGVNZXRob2RzOlJ9LG1pc2NldmFsOntyaWNoQ29tcGFyZUJvb2w6Qixhc0luZGV4T3JUaHJvdzpOLGNoYWluOkUsY2FsbHNpbUFycmF5OlQsY2FsbHNpbU9yU3VzcGVuZEFycmF5OkMsb2JqZWN0UmVwcjpEfSxnZW5lcmljOntnZXRBdHRyOkd9fT1TayxMPVtcXFwiYWJzXFxcIixcXFwiYWRkXFxcIixcXFwiYW5kX1xcXCIsXFxcImNvbmNhdFxcXCIsXFxcImNvbnRhaW5zXFxcIixcXFwiZGVsaXRlbVxcXCIsXFxcImVxXFxcIixcXFwiZmxvb3JkaXZcXFwiLFxcXCJnZVxcXCIsXFxcImdldGl0ZW1cXFwiLFxcXCJndFxcXCIsXFxcImlhZGRcXFwiLFxcXCJpYW5kXFxcIixcXFwiaWNvbmNhdFxcXCIsXFxcImlmbG9vcmRpdlxcXCIsXFxcImlsc2hpZnRcXFwiLFxcXCJpbWF0bXVsXFxcIixcXFwiaW1vZFxcXCIsXFxcImltdWxcXFwiLFxcXCJpbmRleFxcXCIsXFxcImludlxcXCIsXFxcImludmVydFxcXCIsXFxcImlvclxcXCIsXFxcImlwb3dcXFwiLFxcXCJpcnNoaWZ0XFxcIixcXFwiaXN1YlxcXCIsXFxcIml0cnVlZGl2XFxcIixcXFwiaXhvclxcXCIsXFxcImxlXFxcIixcXFwibHNoaWZ0XFxcIixcXFwibHRcXFwiLFxcXCJtYXRtdWxcXFwiLFxcXCJtb2RcXFwiLFxcXCJtdWxcXFwiLFxcXCJuZVxcXCIsXFxcIm5lZ1xcXCIsXFxcIm5vdF9cXFwiLFxcXCJvcl9cXFwiLFxcXCJwb3NcXFwiLFxcXCJwb3dcXFwiLFxcXCJyc2hpZnRcXFwiLFxcXCJzZXRpdGVtXFxcIixcXFwic3ViXFxcIixcXFwidHJ1ZWRpdlxcXCIsXFxcInhvclxcXCJdLEY9W1xcXCJhdHRyZ2V0dGVyXFxcIixcXFwiY291bnRPZlxcXCIsXFxcImluZGV4T2ZcXFwiLFxcXCJpc19cXFwiLFxcXCJpc19ub3RcXFwiLFxcXCJpdGVtZ2V0dGVyXFxcIixcXFwibGVuZ3RoX2hpbnRcXFwiLFxcXCJtZXRob2RjYWxsZXJcXFwiLFxcXCJ0cnV0aFxcXCIsLi4uTF0uc29ydCgpLFA9e19fbmFtZV9fOm5ldyB0KFxcXCJvcGVyYXRvclxcXCIpLF9fZG9jX186bmV3IHQoXFxcIk9wZXJhdG9yIGludGVyZmFjZS5cXFxcblxcXFxuVGhpcyBtb2R1bGUgZXhwb3J0cyBhIHNldCBvZiBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgaW4gamF2YXNjcmlwdCBjb3JyZXNwb25kaW5nXFxcXG50byB0aGUgaW50cmluc2ljIG9wZXJhdG9ycyBvZiBQeXRob24uICBGb3IgZXhhbXBsZSwgb3BlcmF0b3IuYWRkKHgsIHkpXFxcXG5pcyBlcXVpdmFsZW50IHRvIHRoZSBleHByZXNzaW9uIHgreS4gIFRoZSBmdW5jdGlvbiBuYW1lcyBhcmUgdGhvc2VcXFxcbnVzZWQgZm9yIHNwZWNpYWwgbWV0aG9kczsgdmFyaWFudHMgd2l0aG91dCBsZWFkaW5nIGFuZCB0cmFpbGluZ1xcXFxuJ19fJyBhcmUgYWxzbyBwcm92aWRlZCBmb3IgY29udmVuaWVuY2UuXFxcIiksX19hbGxfXzpuZXcgcihGLm1hcCgoZT0+bmV3IHQoZSkpKSl9O1AuaXRlbWdldHRlcj1NKFxcXCJvcGVyYXRvci5pdGVtZ2V0dGVyXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gaXRlbWdldHRlcihlKXt0aGlzLml0ZW1zPWUsdGhpcy5vbmVpdGVtPTE9PT1lLmxlbmd0aCx0aGlzLml0ZW09ZVswXSx0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOkcsdHAkbmV3OihlLHQpPT4oYihcXFwiaXRlbWdldHRlclxcXCIsdCksZyhcXFwiaXRlbWdldHRlclxcXCIsZSwxKSxuZXcgUC5pdGVtZ2V0dGVyKGUpKSx0cCRjYWxsKGUsdCl7ZihcXFwiaXRlbWdldHRlclxcXCIsZSx0KTtjb25zdCByPWVbMF07cmV0dXJuIHRoaXMub25laXRlbT8kKHIsdGhpcy5pdGVtLCEwKTpuZXcgYSh0aGlzLml0ZW1zLm1hcCgoZT0+JChyLGUpKSkpfSx0cCRkb2M6XFxcIlJldHVybiBhIGNhbGxhYmxlIG9iamVjdCB0aGF0IGZldGNoZXMgdGhlIGdpdmVuIGl0ZW0ocykgZnJvbSBpdHMgb3BlcmFuZC5cXFxcbiAgICAgICAgICAgIEFmdGVyIGYgPSBpdGVtZ2V0dGVyKDIpLCB0aGUgY2FsbCBmKHIpIHJldHVybnMgclsyXS5cXFxcbiAgICAgICAgICAgIEFmdGVyIGcgPSBpdGVtZ2V0dGVyKDIsIDUsIDMpLCB0aGUgY2FsbCBnKHIpIHJldHVybnMgKHJbMl0sIHJbNV0sIHJbM10pXFxcIiwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IHQodGhpcy50cCRuYW1lK1xcXCIoLi4uKVxcXCIpO3RoaXMuaW4kcmVwcj0hMDtjb25zdCBlPXRoaXMudHAkbmFtZStcXFwiKFxcXCIrdGhpcy5pdGVtcy5tYXAoKGU9PkQoZSkpKS5qb2luKFxcXCIsIFxcXCIpK1xcXCIpXFxcIjtyZXR1cm4gdGhpcy5pbiRyZXByPSExLGV9fX0pLFAuYXR0cmdldHRlcj1NKFxcXCJvcGVyYXRvci5hdHRyZ2V0dGVyXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gYXR0cmdldHRlcihlKXt0aGlzLmF0dHJzPWUsdGhpcy5vbmVhdHRyPTE9PT1lLmxlbmd0aCx0aGlzLmF0dHI9ZVswXSx0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOkcsdHAkbmV3KGUsYSl7YihcXFwiYXR0cmdldHRlclxcXCIsYSksZyhcXFwiYXR0cmdldHRlclxcXCIsZSwxKTtjb25zdCByPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bysrKXtjb25zdCBhPWVbb107aWYoIXUoYSkpdGhyb3cgbmV3IHMoXFxcImF0dHJpYnV0ZSBuYW1lIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtjb25zdCBuPWEudG9TdHJpbmcoKTtuLmluY2x1ZGVzKFxcXCIuXFxcIik/ci5wdXNoKG4uc3BsaXQoXFxcIi5cXFwiKS5tYXAoKGU9Pm5ldyB0KGUpKSkpOnIucHVzaChbYV0pfXJldHVybiBuZXcgUC5hdHRyZ2V0dGVyKHIpfSx0cCRjYWxsKGUsdCl7ZihcXFwiYXR0cmdldHRlclxcXCIsZSx0KTtjb25zdCByPWVbMF07aWYodGhpcy5vbmVhdHRyKXJldHVybiB0aGlzLmF0dHIucmVkdWNlKCgoZSx0KT0+cShlLHQpKSxyKTtjb25zdCBvPXRoaXMuYXR0cnMubWFwKChlPT5lLnJlZHVjZSgoKGUsdCk9PnEoZSx0KSkscikpKTtyZXR1cm4gbmV3IGEobyl9LHRwJGRvYzpcXFwiYXR0cmdldHRlcihhdHRyLCAuLi4pIC0tXFxcXHgzZSBhdHRyZ2V0dGVyIG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gYSBjYWxsYWJsZSBvYmplY3QgdGhhdCBmZXRjaGVzIHRoZSBnaXZlbiBhdHRyaWJ1dGUocykgZnJvbSBpdHMgb3BlcmFuZC5cXFxcbkFmdGVyIGYgPSBhdHRyZ2V0dGVyKCduYW1lJyksIHRoZSBjYWxsIGYocikgcmV0dXJucyByLm5hbWUuXFxcXG5BZnRlciBnID0gYXR0cmdldHRlcignbmFtZScsICdkYXRlJyksIHRoZSBjYWxsIGcocikgcmV0dXJucyAoci5uYW1lLCByLmRhdGUpLlxcXFxuQWZ0ZXIgaCA9IGF0dHJnZXR0ZXIoJ25hbWUuZmlyc3QnLCAnbmFtZS5sYXN0JyksIHRoZSBjYWxsIGgocikgcmV0dXJuc1xcXFxuKHIubmFtZS5maXJzdCwgci5uYW1lLmxhc3QpLlxcXCIsJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyB0KHRoaXMudHAkbmFtZStcXFwiKC4uLilcXFwiKTt0aGlzLmluJHJlcHI9ITA7Y29uc3QgZT10aGlzLnRwJG5hbWUrXFxcIihcXFwiK3RoaXMuaXRlbXMubWFwKChlPT5EKGUpKSkuam9pbihcXFwiLCBcXFwiKStcXFwiKVxcXCI7cmV0dXJuIHRoaXMuaW4kcmVwcj0hMSxlfX19KSxQLm1ldGhvZGNhbGxlcj1NKFxcXCJvcGVyYXRvci5tZXRob2RjYWxsZXJcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBtZXRob2RjYWxsZXIoZSx0LGEpe3RoaXMuJG5hbWU9ZSx0aGlzLmFyZ3M9dCx0aGlzLmt3YXJncz1hfHxbXSx0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOkcsdHAkbmV3KGUsdCl7ZyhcXFwibWV0aG9kY2FsbGVyXFxcIixlLDEpO2NvbnN0IGE9ZVswXTtpZighdShhKSl0aHJvdyBuZXcgcyhcXFwibWV0aG9kIG5hbWUgbXVzdCBiZSBhIHN0cmluZ1xcXCIpO3JldHVybiBuZXcgUC5tZXRob2RjYWxsZXIoYSxlLnNsaWNlKDEpLHQpfSx0cCRjYWxsKGUsdCl7ZihcXFwibWV0aG9kY2FsbGVyXFxcIixlLHQpO2NvbnN0IGE9ZVswXTtyZXR1cm4gRShxKGEsdGhpcy4kbmFtZSwhMCksKGU9PkMoZSx0aGlzLmFyZ3MsdGhpcy5rd2FyZ3MpKSl9LHRwJGRvYzpcXFwibWV0aG9kY2FsbGVyKG5hbWUsIC4uLikgLS1cXFxceDNlIG1ldGhvZGNhbGxlciBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGEgY2FsbGFibGUgb2JqZWN0IHRoYXQgY2FsbHMgdGhlIGdpdmVuIG1ldGhvZCBvbiBpdHMgb3BlcmFuZC5cXFxcbkFmdGVyIGYgPSBtZXRob2RjYWxsZXIoJ25hbWUnKSwgdGhlIGNhbGwgZihyKSByZXR1cm5zIHIubmFtZSgpLlxcXFxuQWZ0ZXIgZyA9IG1ldGhvZGNhbGxlcignbmFtZScsICdkYXRlJywgZm9vPTEpLCB0aGUgY2FsbCBnKHIpIHJldHVybnNcXFxcbnIubmFtZSgnZGF0ZScsIGZvbz0xKS5cXFwiLCRyKCl7aWYodGhpcy5pbiRyZXByKXJldHVybiBuZXcgdCh0aGlzLnRwJG5hbWUrXFxcIiguLi4pXFxcIik7dGhpcy5pbiRyZXByPSEwO2xldCBlPVtEKHRoaXMuJG5hbWUpXTtlLnB1c2goLi4udGhpcy5hcmdzLm1hcCgoZT0+RChlKSkpKTtmb3IobGV0IHQ9MDt0PHRoaXMua3dhcmdzLmxlbmd0aDt0Kz0yKWUucHVzaCh0aGlzLmt3YXJnc1t0XStcXFwiPVxcXCIrRCh0aGlzLmt3YXJnc1t0KzFdKSk7cmV0dXJuIGU9dGhpcy50cCRuYW1lK1xcXCIoXFxcIitlLmpvaW4oXFxcIiwgXFxcIikrXFxcIilcXFwiLHRoaXMuaW4kcmVwcj0hMSxlfX19KTtjb25zdCBVPXsxOnskZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCAvKVxcXCJ9LDI6eyRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCJ9LDM6eyRmbGFnczp7TWluQXJnczozLE1heEFyZ3M6M30sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCBjLCAvKVxcXCJ9fTtmdW5jdGlvbiBtYWtlTW9kdWxlTWV0aG9kKGUsdCl7cmV0dXJueyRtZXRoOmUsJGRvYzp0LC4uLlVbZS5sZW5ndGhdfX1mdW5jdGlvbiBzYW1lQXMoZSl7cmV0dXJuXFxcIlNhbWUgYXMgXFxcIitlK1xcXCIuXFxcIn1yZXR1cm4gUihcXFwib3BlcmF0b3JcXFwiLFAse2x0Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJMdFxcXCIpKSksc2FtZUFzKFxcXCJhIDwgYlxcXCIpKSxsZTptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+bihCKGUsdCxcXFwiTHRFXFxcIikpKSxzYW1lQXMoXFxcImEgPD0gYlxcXCIpKSxlcTptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+bihCKGUsdCxcXFwiRXFcXFwiKSkpLHNhbWVBcyhcXFwiYSA9PSBiXFxcIikpLG5lOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJOb3RFcVxcXCIpKSksc2FtZUFzKFxcXCJhICE9IGJcXFwiKSksZ2U6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9Pm4oQihlLHQsXFxcIkd0RVxcXCIpKSksc2FtZUFzKFxcXCJhID49IGJcXFwiKSksZ3Q6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9Pm4oQihlLHQsXFxcIkd0XFxcIikpKSxzYW1lQXMoXFxcImEgPiBiXFxcIikpLG5vdF86bWFrZU1vZHVsZU1ldGhvZCgoZT0+cChlLFxcXCJOb3RcXFwiKSksc2FtZUFzKFxcXCJub3QgYVxcXCIpKSx0cnV0aDptYWtlTW9kdWxlTWV0aG9kKChlPT5uKGUpKSxcXFwiUmV0dXJuIFRydWUgaWYgYSBpcyB0cnVlLCBGYWxzZSBvdGhlcndpc2UuXFxcIiksaXNfOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJJc1xcXCIpKSksc2FtZUFzKFxcXCJhIGlzIGJcXFwiKSksaXNfbm90Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJJc05vdFxcXCIpKSksc2FtZUFzKFxcXCJhIGlzIG5vdCBiXFxcIikpLGFiczptYWtlTW9kdWxlTWV0aG9kKChlPT5sKGUpKSxzYW1lQXMoXFxcImFicyhhKVxcXCIpKSxhZGQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJBZGRcXFwiKSksc2FtZUFzKFxcXCJhICsgYlxcXCIpKSxhbmRfOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5BKGUsdCxcXFwiQml0QW5kXFxcIikpLHNhbWVBcyhcXFwiYSAmIGJcXFwiKSksZmxvb3JkaXY6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJGbG9vckRpdlxcXCIpKSxzYW1lQXMoXFxcImEgLy8gYlxcXCIpKSxpbmRleDptYWtlTW9kdWxlTWV0aG9kKChlPT5uZXcgbyhOKGUpKSksc2FtZUFzKFxcXCJhLl9faW5kZXhfXygpXFxcIikpLGludjptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIkludmVydFxcXCIpKSxzYW1lQXMoXFxcIn5hXFxcIikpLGludmVydDptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIkludmVydFxcXCIpKSxzYW1lQXMoXFxcIn5hXFxcIikpLGxzaGlmdDptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+QShlLHQsXFxcIkxTaGlmdFxcXCIpKSxzYW1lQXMoXFxcImEgPDwgYlxcXCIpKSxtb2Q6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJNb2RcXFwiKSksc2FtZUFzKFxcXCJhICUgYlxcXCIpKSxtdWw6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJNdWx0XFxcIikpLHNhbWVBcyhcXFwiYSAqIGJcXFwiKSksbWF0bXVsOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5BKGUsdCxcXFwiTWF0TXVsdFxcXCIpKSxzYW1lQXMoXFxcImEgQCBiXFxcIikpLG5lZzptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIlVTdWJcXFwiKSksc2FtZUFzKFxcXCItYVxcXCIpKSxvcl86bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJCaXRPclxcXCIpKSxzYW1lQXMoXFxcImEgfCBiXFxcIikpLHBvczptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIlVBZGRcXFwiKSksc2FtZUFzKFxcXCIrYVxcXCIpKSxwb3c6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJQb3dcXFwiKSksc2FtZUFzKFxcXCJhICoqIGJcXFwiKSkscnNoaWZ0Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5BKGUsdCxcXFwiUlNoaWZ0XFxcIikpLHNhbWVBcyhcXFwiYSA+PiBiXFxcIikpLHN1YjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+QShlLHQsXFxcIlN1YlxcXCIpKSxzYW1lQXMoXFxcImEgLSBiXFxcIikpLHRydWVkaXY6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJEaXZcXFwiKSksc2FtZUFzKFxcXCJhIC8gYlxcXCIpKSx4b3I6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJCaXRYb3JcXFwiKSksc2FtZUFzKFxcXCJhIF4gYlxcXCIpKSxjb25jYXQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PnYoZSx0KSksc2FtZUFzKFxcXCJhICsgYiwgZm9yIGEgYW5kIGIgc2VxdWVuY2VzXFxcIikpLGNvbnRhaW5zOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5FKHgoZSx0KSxuKSksc2FtZUFzKFxcXCJiIGluIGEgKG5vdGUgcmV2ZXJzZWQgb3BlcmFuZHMpXFxcIikpLGNvdW50T2Y6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmooZSx0KSksXFxcIlJldHVybiB0aGVudW1iZXIgb2YgdGltZXMgYiBvY2N1cnMgaW4gYS5cXFwiKSxkZWxpdGVtOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5FKF8oZSx0LCEwKSwoKCk9Pm0pKSksc2FtZUFzKFxcXCJkZWwgYVtiXVxcXCIpKSxnZXRpdGVtOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT4kKGUsdCwhMCkpLHNhbWVBcyhcXFwiYVtiXVxcXCIpKSxpbmRleE9mOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5PKGUsdCkpLFxcXCJSZXR1cm4gdGhlIGZpcnN0IGluZGV4IG9mIGIgaW4gYVxcXCIpLHNldGl0ZW06bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCxhKT0+RSh3KGUsdCxhLCEwKSwoKCk9Pm0pKSksc2FtZUFzKFxcXCJhW2JdID0gY1xcXCIpKSxsZW5ndGhfaGludDp7JG1ldGg6ZnVuY3Rpb24gbGVuZ3RoX2hpbnQoZSxhKXtpZih2b2lkIDA9PT1hKWE9bmV3IG8oMCk7ZWxzZSBpZighYyhhKSl0aHJvdyBuZXcgcyhcXFwiJ1xcXCIrUyhhKStcXFwiJyBvYmplY3QgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGFuIGludGVnZXJcXFwiKTt0cnl7cmV0dXJuIGgoZSl9Y2F0Y2gobSl7aWYoIShtIGluc3RhbmNlb2YgcykpdGhyb3cgbX1jb25zdCByPXkoZSx0LiRsZW5ndGhfaGludCk7aWYodm9pZCAwPT09cilyZXR1cm4gYTtsZXQgbjt0cnl7bj1UKHIsW10pfWNhdGNoKG0pe2lmKCEobSBpbnN0YW5jZW9mIHMpKXRocm93IG07cmV0dXJuIGF9aWYobj09PWQpcmV0dXJuIGE7aWYoIWMobikpdGhyb3cgbmV3IHMoXFxcIl9fbGVuZ3RoX2hpbnRfXyBtdXN0IGJlIGFuIGludGVnZXIsIG5vdCBcXFwiK1MobikpO2lmKG4ubmIkaXNuZWdhdGl2ZSgpKXRocm93IG5ldyBpKFxcXCJfX2xlbmd0aF9oaW50X18oKSBzaG91bGQgcmV0dXJuID49IDBcXFwiKTtyZXR1cm4gbn0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIG9iaiwgZGVmYXVsdD0wLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIGFuIGVzdGltYXRlIG9mIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gb2JqLlxcXFxuXFxcXG5UaGlzIGlzIHVzZWZ1bCBmb3IgcHJlc2l6aW5nIGNvbnRhaW5lcnMgd2hlbiBidWlsZGluZyBmcm9tIGFuIGl0ZXJhYmxlLlxcXFxuXFxcXG5JZiB0aGUgb2JqZWN0IHN1cHBvcnRzIGxlbigpLCB0aGUgcmVzdWx0IHdpbGwgYmUgZXhhY3QuXFxcXG5PdGhlcndpc2UsIGl0IG1heSBvdmVyLSBvciB1bmRlci1lc3RpbWF0ZSBieSBhbiBhcmJpdHJhcnkgYW1vdW50LlxcXFxuVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGludGVnZXIgPj0gMC5cXFwifSxpYWRkOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5rKGUsdCxcXFwiQWRkXFxcIikpLHNhbWVBcyhcXFwiYSArPSBiXFxcIikpLGlhbmQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJCaXRBbmRcXFwiKSksc2FtZUFzKFxcXCJhICY9IGJcXFwiKSksaWNvbmNhdDptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+SShlLHQpKSxzYW1lQXMoXFxcImEgKz0gYiwgZm9yIGEgYW5kIGIgc2VxdWVuY2VzXFxcIikpLGlmbG9vcmRpdjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+ayhlLHQsXFxcIkZsb29yRGl2XFxcIikpLHNhbWVBcyhcXFwiYSAvLz0gYlxcXCIpKSxpbHNoaWZ0Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5rKGUsdCxcXFwiTFNoaWZ0XFxcIikpLHNhbWVBcyhcXFwiYSA8PD0gYlxcXCIpKSxpbW9kOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5rKGUsdCxcXFwiTW9kXFxcIikpLHNhbWVBcyhcXFwiYSAlPSBiXFxcIikpLGltdWw6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJNdWx0XFxcIikpLHNhbWVBcyhcXFwiYSAqPSBiXFxcIikpLGltYXRtdWw6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJNYXRNdWx0XFxcIikpLHNhbWVBcyhcXFwiYSBAPSBiXFxcIikpLGlvcjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+ayhlLHQsXFxcIkJpdE9yXFxcIikpLHNhbWVBcyhcXFwiYSB8PSBiXFxcIikpLGlwb3c6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJQb3dcXFwiKSksc2FtZUFzKFxcXCJhICoqPSBiXFxcIikpLGlyc2hpZnQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJSU2hpZnRcXFwiKSksc2FtZUFzKFxcXCJhID4+PSBiXFxcIikpLGlzdWI6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJTdWJcXFwiKSksc2FtZUFzKFxcXCJhIC09IGJcXFwiKSksaXRydWVkaXY6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJEaXZcXFwiKSksc2FtZUFzKFxcXCJhIC89IGJcXFwiKSksaXhvcjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+ayhlLHQsXFxcIkJpdFhvclxcXCIpKSxzYW1lQXMoXFxcImEgXj0gYlxcXCIpKX0pLEwuZm9yRWFjaCgoZT0+e1BbYF9fJHtlLnJlcGxhY2UoXFxcIl9cXFwiLFxcXCJcXFwiKX1fX2BdPVBbZV19KSksUC5kaXY9UC50cnVlZGl2LFAuX19kaXZfXz1QLmRpdixQfVwiLFwic3JjL2xpYi9wbGF0Zm9ybS5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG4pe3ZhciBlPXt9LGk9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3cmJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93Lm5hdmlnYXRvcjtyZXR1cm4gZS5weXRob25faW1wbGVtZW50YXRpb249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicHl0aG9uX2ltcGxlbWVudGF0aW9uXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMCksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJTa3VscHRcXFwiKX0pKSxlLm5vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwibm9kZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApLG5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIil9KSksZS52ZXJzaW9uPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInZlcnNpb25cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIlxcXCIpfSkpLGUucHl0aG9uX3ZlcnNpb249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicHl0aG9uX3ZlcnNpb25cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPVNrLl9fZnV0dXJlX18ucHl0aG9uX3ZlcnNpb24/XFxcIjMuMi4wXFxcIjpcXFwiMi43LjBcXFwiLG5ldyBTay5idWlsdGluLnN0cihuKX0pKSxlLnN5c3RlbT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3ZhciBuO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzeXN0ZW1cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPWk/d2luZG93Lm5hdmlnYXRvci5hcHBDb2RlTmFtZTpcXFwiXFxcIixuZXcgU2suYnVpbHRpbi5zdHIobil9KSksZS5tYWNoaW5lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm1hY2hpbmVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPWk/d2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybTpcXFwiXFxcIixuZXcgU2suYnVpbHRpbi5zdHIobil9KSksZS5yZWxlYXNlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInJlbGVhc2VcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPWk/d2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uOlxcXCJcXFwiLG5ldyBTay5idWlsdGluLnN0cihuKX0pKSxlLmFyY2hpdGVjdHVyZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJhcmNoaXRlY3R1cmVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCI2NGJpdFxcXCIpLG5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIildKX0pKSxlLnByb2Nlc3Nvcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJwcm9jZXNzb3JcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIlxcXCIpfSkpLGV9O1wiLFwic3JjL2xpYi9wcm9jZXNzaW5nLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7dmFyIGksZSx0LHUsbyxzLGwsYz17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJwcm9jZXNzaW5nXFxcIil9LHI9W10sdj0hMCxmPW51bGw7Yy5wcm9jZXNzaW5nPW51bGwsYy5wPW51bGwsYy5YPW5ldyBTay5idWlsdGluLmludF8oMCksYy5ZPW5ldyBTay5idWlsdGluLmludF8oMSksYy5aPW5ldyBTay5idWlsdGluLmludF8oMiksYy5SPW5ldyBTay5idWlsdGluLmludF8oMyksYy5HPW5ldyBTay5idWlsdGluLmludF8oNCksYy5CPW5ldyBTay5idWlsdGluLmludF8oNSksYy5BPW5ldyBTay5idWlsdGluLmludF8oNiksYy5VPW5ldyBTay5idWlsdGluLmludF8oNyksYy5WPW5ldyBTay5idWlsdGluLmludF8oOCksYy5OWD1uZXcgU2suYnVpbHRpbi5pbnRfKDkpLGMuTlk9bmV3IFNrLmJ1aWx0aW4uaW50XygxMCksYy5OWj1uZXcgU2suYnVpbHRpbi5pbnRfKDExKSxjLkVER0U9bmV3IFNrLmJ1aWx0aW4uaW50XygxMiksYy5TUj1uZXcgU2suYnVpbHRpbi5pbnRfKDEzKSxjLlNHPW5ldyBTay5idWlsdGluLmludF8oMTQpLGMuU0I9bmV3IFNrLmJ1aWx0aW4uaW50XygxNSksYy5TQT1uZXcgU2suYnVpbHRpbi5pbnRfKDE2KSxjLlNXPW5ldyBTay5idWlsdGluLmludF8oMTcpLGMuVFg9bmV3IFNrLmJ1aWx0aW4uaW50XygxOCksYy5UWT1uZXcgU2suYnVpbHRpbi5pbnRfKDE5KSxjLlRaPW5ldyBTay5idWlsdGluLmludF8oMjApLGMuVlg9bmV3IFNrLmJ1aWx0aW4uaW50XygyMSksYy5WWT1uZXcgU2suYnVpbHRpbi5pbnRfKDIyKSxjLlZaPW5ldyBTay5idWlsdGluLmludF8oMjMpLGMuVlc9bmV3IFNrLmJ1aWx0aW4uaW50XygyNCksYy5BUj1uZXcgU2suYnVpbHRpbi5pbnRfKDI1KSxjLkFHPW5ldyBTay5idWlsdGluLmludF8oMjYpLGMuQUI9bmV3IFNrLmJ1aWx0aW4uaW50XygyNyksYy5EUj1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuREc9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxjLkRCPW5ldyBTay5idWlsdGluLmludF8oNSksYy5EQT1uZXcgU2suYnVpbHRpbi5pbnRfKDYpLGMuU1BSPW5ldyBTay5idWlsdGluLmludF8oMjgpLGMuU1BHPW5ldyBTay5idWlsdGluLmludF8oMjkpLGMuU1BCPW5ldyBTay5idWlsdGluLmludF8oMzApLGMuU0hJTkU9bmV3IFNrLmJ1aWx0aW4uaW50XygzMSksYy5FUj1uZXcgU2suYnVpbHRpbi5pbnRfKDMyKSxjLkVHPW5ldyBTay5idWlsdGluLmludF8oMzMpLGMuRUI9bmV3IFNrLmJ1aWx0aW4uaW50XygzNCksYy5CRUVOX0xJVD1uZXcgU2suYnVpbHRpbi5pbnRfKDM1KSxjLlZFUlRFWF9GSUVMRF9DT1VOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDM2KSxjLkNFTlRFUj1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuUkFESVVTPW5ldyBTay5idWlsdGluLmludF8oMiksYy5DT1JORVJTPW5ldyBTay5idWlsdGluLmludF8oMSksYy5DT1JORVI9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkRJQU1FVEVSPW5ldyBTay5idWlsdGluLmludF8oMyksYy5CQVNFTElORT1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuVE9QPW5ldyBTay5idWlsdGluLmludF8oMTAxKSxjLkJPVFRPTT1uZXcgU2suYnVpbHRpbi5pbnRfKDEwMiksYy5OT1JNQUw9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLk5PUk1BTElaRUQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLklNQUdFPW5ldyBTay5idWlsdGluLmludF8oMiksYy5NT0RFTD1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGMuU0hBUEU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1KSxjLkFNQklFTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkRJUkVDVElPTkFMPW5ldyBTay5idWlsdGluLmludF8oMSksYy5TUE9UPW5ldyBTay5idWlsdGluLmludF8oMyksYy5SR0I9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkFSR0I9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLkhTQj1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuQUxQSEE9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxjLkNNWUs9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1KSxjLlRJRkY9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLlRBUkdBPW5ldyBTay5idWlsdGluLmludF8oMSksYy5KUEVHPW5ldyBTay5idWlsdGluLmludF8oMiksYy5HSUY9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxjLk1JVEVSPW5ldyBTay5idWlsdGluLnN0cihcXFwibWl0ZXJcXFwiKSxjLkJFVkVMPW5ldyBTay5idWlsdGluLnN0cihcXFwiYmV2ZWxcXFwiKSxjLlJPVU5EPW5ldyBTay5idWlsdGluLnN0cihcXFwicm91bmRcXFwiKSxjLlNRVUFSRT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcImJ1dHRcXFwiKSxjLlBST0pFQ1Q9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJzcXVhcmVcXFwiKSxjLlAyRD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGMuSkFWQTJEPW5ldyBTay5idWlsdGluLmludF8oMSksYy5XRUJHTD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuUDNEPW5ldyBTay5idWlsdGluLmludF8oMiksYy5PUEVOR0w9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLlBERj1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuRFhGPW5ldyBTay5idWlsdGluLmludF8oMCksYy5PVEhFUj1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuV0lORE9XUz1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGMuTUFYT1NYPW5ldyBTay5idWlsdGluLmludF8oMiksYy5MSU5VWD1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuRVBTSUxPTj1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMWUtNCksYy5NQVhfRkxPQVQ9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDM0MDI4MjM1ZTMxKSxjLk1JTl9GTE9BVD1uZXcgU2suYnVpbHRpbi5mbG9hdF8oLTM0MDI4MjM1ZTMxKSxjLk1BWF9JTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygyMTQ3NDgzNjQ3KSxjLk1JTl9JTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygtMjE0NzQ4MzY0OCksYy5IQUxGX1BJPW5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLlBJLzIpLGMuVEhJUkRfUEk9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguUEkvMyksYy5QST1uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5QSSksYy5UV09fUEk9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDIqTWF0aC5QSSksYy5UQVU9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDIqTWF0aC5QSSksYy5RVUFSVEVSX1BJPW5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLlBJLzQpLGMuREVHX1RPX1JBRD1uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5QSS8xODApLGMuUkFEX1RPX0RFRz1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMTgwL01hdGguUEkpLGMuV0hJVEVTUEFDRT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIiBcXFxcdFxcXFxuXFxcXHJcXFxcZsKgXFxcIiksYy5QT0lOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuUE9JTlRTPW5ldyBTay5idWlsdGluLmludF8oMiksYy5MSU5FPW5ldyBTay5idWlsdGluLmludF8oNCksYy5MSU5FUz1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGMuVFJJQU5HTEU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg4KSxjLlRSSUFOR0xFUz1uZXcgU2suYnVpbHRpbi5pbnRfKDkpLGMuVFJJQU5HTEVfRkFOPW5ldyBTay5idWlsdGluLmludF8oMTEpLGMuVFJJQU5HTEVfU1RSSVA9bmV3IFNrLmJ1aWx0aW4uaW50XygxMCksYy5RVUFEPW5ldyBTay5idWlsdGluLmludF8oMTYpLGMuUVVBRFM9bmV3IFNrLmJ1aWx0aW4uaW50XygxNiksYy5RVUFEX1NUUklQPW5ldyBTay5idWlsdGluLmludF8oMTcpLGMuUE9MWUdPTj1uZXcgU2suYnVpbHRpbi5pbnRfKDIwKSxjLlBBVEg9bmV3IFNrLmJ1aWx0aW4uaW50XygyMSksYy5SRUNUPW5ldyBTay5idWlsdGluLmludF8oMzApLGMuRUxMSVBTRT1uZXcgU2suYnVpbHRpbi5pbnRfKDMxKSxjLkFSQz1uZXcgU2suYnVpbHRpbi5pbnRfKDMyKSxjLlNQSEVSRT1uZXcgU2suYnVpbHRpbi5pbnRfKDQwKSxjLkJPWD1uZXcgU2suYnVpbHRpbi5pbnRfKDQxKSxjLkdST1VQPW5ldyBTay5idWlsdGluLmludF8oMCksYy5QUklNSVRJVkU9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkdFT01FVFJZPW5ldyBTay5idWlsdGluLmludF8oMyksYy5WRVJURVg9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkJFWklFUl9WRVJURVg9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkNVUlZFX1ZFUlRFWD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuQlJFQUs9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxjLkNMT1NFU0hBUEU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxjLlJFUExBQ0U9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkJMRU5EPW5ldyBTay5idWlsdGluLmludF8oMSksYy5BREQ9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLlNVQlRSQUNUPW5ldyBTay5idWlsdGluLmludF8oNCksYy5MSUdIVEVTVD1uZXcgU2suYnVpbHRpbi5pbnRfKDgpLGMuREFSS0VTVD1uZXcgU2suYnVpbHRpbi5pbnRfKDE2KSxjLkRJRkZFUkVOQ0U9bmV3IFNrLmJ1aWx0aW4uaW50XygzMiksYy5FWENMVVNJT049bmV3IFNrLmJ1aWx0aW4uaW50Xyg2NCksYy5NVUxUSVBMWT1uZXcgU2suYnVpbHRpbi5pbnRfKDEyOCksYy5TQ1JFRU49bmV3IFNrLmJ1aWx0aW4uaW50XygyNTYpLGMuT1ZFUkxBWT1uZXcgU2suYnVpbHRpbi5pbnRfKDUxMiksYy5IQVJEX0xJR0hUPW5ldyBTay5idWlsdGluLmludF8oMTAyNCksYy5TT0ZUX0xJR0hUPW5ldyBTay5idWlsdGluLmludF8oMjA0OCksYy5ET0RHRT1uZXcgU2suYnVpbHRpbi5pbnRfKDQwOTYpLGMuQlVSTj1uZXcgU2suYnVpbHRpbi5pbnRfKDgxOTIpLGMuQUxQSEFfTUFTSz1uZXcgU2suYnVpbHRpbi5pbnRfKDQyNzgxOTAwODApLGMuUkVEX01BU0s9bmV3IFNrLmJ1aWx0aW4uaW50XygxNjcxMTY4MCksYy5HUkVFTl9NQVNLPW5ldyBTay5idWlsdGluLmludF8oNjUyODApLGMuQkxVRV9NQVNLPW5ldyBTay5idWlsdGluLmludF8oMjU1KSxjLkNVU1RPTT1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuT1JUSE9HUkFQSElDPW5ldyBTay5idWlsdGluLmludF8oMiksYy5QRVJTUEVDVElWRT1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuQVJST1c9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJkZWZhdWx0XFxcIiksYy5DUk9TUz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcImNyb3NzaGFpclxcXCIpLGMuSEFORD1uZXcgU2suYnVpbHRpbi5zdHIoXFxcInBvaW50ZXJcXFwiKSxjLk1PVkU9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJtb3ZlXFxcIiksYy5URVhUPW5ldyBTay5idWlsdGluLnN0cihcXFwidGV4dFxcXCIpLGMuV0FJVD1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIndhaXRcXFwiKSxjLk5PQ1VSU09SPVNrLmJ1aWx0aW4uYXNzayQoXFxcInVybCgnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBUC8vL3dBQUFDSDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUNSQUVBT3c9PScpLCBhdXRvXFxcIiksYy5ESVNBQkxFX09QRU5HTF8yWF9TTU9PVEg9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkVOQUJMRV9PUEVOR0xfMlhfU01PT1RIPW5ldyBTay5idWlsdGluLmludF8oLTEpLGMuRU5BQkxFX09QRU5HTF80WF9TTU9PVEg9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLkVOQUJMRV9OQVRJVkVfRk9OVFM9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxjLkRJU0FCTEVfREVQVEhfVEVTVD1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGMuRU5BQkxFX0RFUFRIX1RFU1Q9bmV3IFNrLmJ1aWx0aW4uaW50XygtNCksYy5FTkFCTEVfREVQVEhfU09SVD1uZXcgU2suYnVpbHRpbi5pbnRfKDUpLGMuRElTQUJMRV9ERVBUSF9TT1JUPW5ldyBTay5idWlsdGluLmludF8oLTUpLGMuRElTQUJMRV9PUEVOR0xfRVJST1JfUkVQT1JUPW5ldyBTay5idWlsdGluLmludF8oNiksYy5FTkFCTEVfT1BFTkdMX0VSUk9SX1JFUE9SVD1uZXcgU2suYnVpbHRpbi5pbnRfKC02KSxjLkVOQUJMRV9BQ0NVUkFURV9URVhUVVJFUz1uZXcgU2suYnVpbHRpbi5pbnRfKDcpLGMuRElTQUJMRV9BQ0NVUkFURV9URVhUVVJFUz1uZXcgU2suYnVpbHRpbi5pbnRfKC03KSxjLkhJTlRfQ09VTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxMCksYy5PUEVOPW5ldyBTay5idWlsdGluLmludF8oMSksYy5DTE9TRT1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuQkxVUj1uZXcgU2suYnVpbHRpbi5pbnRfKDExKSxjLkdSQVk9bmV3IFNrLmJ1aWx0aW4uaW50XygxMiksYy5JTlZFUlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxMyksYy5PUEFRVUU9bmV3IFNrLmJ1aWx0aW4uaW50XygxNCksYy5QT1NURVJJWkU9bmV3IFNrLmJ1aWx0aW4uaW50XygxNSksYy5USFJFU0hPTEQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxNiksYy5FUk9ERT1uZXcgU2suYnVpbHRpbi5pbnRfKDE3KSxjLkRJTEFURT1uZXcgU2suYnVpbHRpbi5pbnRfKDE4KSxjLkJBQ0tTUEFDRT1uZXcgU2suYnVpbHRpbi5pbnRfKDgpLGMuVEFCPW5ldyBTay5idWlsdGluLmludF8oOSksYy5FTlRFUj1uZXcgU2suYnVpbHRpbi5pbnRfKDEwKSxjLlJFVFVSTj1uZXcgU2suYnVpbHRpbi5pbnRfKDEzKSxjLkVTQz1uZXcgU2suYnVpbHRpbi5pbnRfKDI3KSxjLkRFTEVURT1uZXcgU2suYnVpbHRpbi5pbnRfKDEyNyksYy5DT0RFRD1uZXcgU2suYnVpbHRpbi5pbnRfKDY1NTM1KSxjLlNISUZUPW5ldyBTay5idWlsdGluLmludF8oMTYpLGMuQ09OVFJPTD1uZXcgU2suYnVpbHRpbi5pbnRfKDE3KSxjLkFMVD1uZXcgU2suYnVpbHRpbi5pbnRfKDE4KSxjLkNBUFNMSz1uZXcgU2suYnVpbHRpbi5pbnRfKDIwKSxjLlBHVVA9bmV3IFNrLmJ1aWx0aW4uaW50XygzMyksYy5QR0ROPW5ldyBTay5idWlsdGluLmludF8oMzQpLGMuRU5EPW5ldyBTay5idWlsdGluLmludF8oMzUpLGMuSE9NRT1uZXcgU2suYnVpbHRpbi5pbnRfKDM2KSxjLkxFRlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygzNyksYy5VUD1uZXcgU2suYnVpbHRpbi5pbnRfKDM4KSxjLlJJR0hUPW5ldyBTay5idWlsdGluLmludF8oMzkpLGMuRE9XTj1uZXcgU2suYnVpbHRpbi5pbnRfKDQwKSxjLkYxPW5ldyBTay5idWlsdGluLmludF8oMTEyKSxjLkYyPW5ldyBTay5idWlsdGluLmludF8oMTEzKSxjLkYzPW5ldyBTay5idWlsdGluLmludF8oMTE0KSxjLkY0PW5ldyBTay5idWlsdGluLmludF8oMTE1KSxjLkY1PW5ldyBTay5idWlsdGluLmludF8oMTE2KSxjLkY2PW5ldyBTay5idWlsdGluLmludF8oMTE3KSxjLkY3PW5ldyBTay5idWlsdGluLmludF8oMTE4KSxjLkY4PW5ldyBTay5idWlsdGluLmludF8oMTE5KSxjLkY5PW5ldyBTay5idWlsdGluLmludF8oMTIwKSxjLkYxMD1uZXcgU2suYnVpbHRpbi5pbnRfKDEyMSksYy5GMTE9bmV3IFNrLmJ1aWx0aW4uaW50XygxMjIpLGMuRjEyPW5ldyBTay5idWlsdGluLmludF8oMTIzKSxjLk5VTUxLPW5ldyBTay5idWlsdGluLmludF8oMTQ0KSxjLk1FVEE9bmV3IFNrLmJ1aWx0aW4uaW50XygxNTcpLGMuSU5TRVJUPW5ldyBTay5idWlsdGluLmludF8oMTU1KSxjLlNJTkNPU19MRU5HVEg9bmV3IFNrLmJ1aWx0aW4uaW50Xyg3MjApLGMuUFJFQ0lTSU9OQj1uZXcgU2suYnVpbHRpbi5pbnRfKDE1KSxjLlBSRUNJU0lPTkY9bmV3IFNrLmJ1aWx0aW4uaW50XygzMjc2OCksYy5QUkVDX01BWFZBTD1uZXcgU2suYnVpbHRpbi5pbnRfKDMyNzY3KSxjLlBSRUNfQUxQSEFfU0hJRlQ9bmV3IFNrLmJ1aWx0aW4uaW50Xyg5KSxjLlBSRUNfUkVEX1NISUZUPW5ldyBTay5idWlsdGluLmludF8oMSksYy5OT1JNQUxfTU9ERV9BVVRPPW5ldyBTay5idWlsdGluLmludF8oMCksYy5OT1JNQUxfTU9ERV9TSEFQRT1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGMuTk9STUFMX01PREVfVkVSVEVYPW5ldyBTay5idWlsdGluLmludF8oMiksYy5NQVhfTElHSFRTPW5ldyBTay5idWlsdGluLmludF8oOCksYy5saW5lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe2MucHJvY2Vzc2luZy5saW5lKG4udixpLnYsZS52LHQudil9KSksYy5lbGxpcHNlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe2MucHJvY2Vzc2luZy5lbGxpcHNlKG4udixpLnYsZS52LHQudil9KSksYy5jaXJjbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe2MucHJvY2Vzc2luZy5lbGxpcHNlKG4udixpLnYsZS52LGUudil9KSksYy50ZXh0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtjLnByb2Nlc3NpbmcudGV4dChuLnYsaS52LGUudil9KSksYy5wb2ludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe2MucHJvY2Vzc2luZy5wb2ludChuLnYsaS52KX0pKSxjLmFyYz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLmFyYyhuLnYsaS52LGUudix0LnYsdS52LG8udil9KSksYy5xdWFkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCl7Yy5wcm9jZXNzaW5nLnF1YWQobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudil9KSksYy5yZWN0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB1P2MucHJvY2Vzc2luZy5yZWN0KG4udixpLnYsZS52LHQudik6Yy5wcm9jZXNzaW5nLnJlY3Qobi52LGkudixlLnYsdC52LHUudil9KSksYy50cmlhbmdsZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLnRyaWFuZ2xlKG4udixpLnYsZS52LHQudix1LnYsby52KX0pKSxjLmJlemllcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyxzLGwscix2LGYsUyl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiByP2MucHJvY2Vzc2luZy5iZXppZXIobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudik6Yy5wcm9jZXNzaW5nLmJlemllcihuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudix2LnYsZi52LFMudil9KSksYy5hbHBoYT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYWxwaGEobi52KSk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYWxwaGEobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYWxwaGEobi52LGkudixlLnYpKX0pKSxjLmFtYmllbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3NpbmcuYW1iaWVudChuLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcuYW1iaWVudChuLnYsaS52KTpjLnByb2Nlc3NpbmcuYW1iaWVudChuLnYsaS52LGUudil9KSksYy5hbWJpZW50TGlnaHQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1LG8pe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9jLnByb2Nlc3NpbmcuYW1iaWVudExpZ2h0KG4udixpLnYsZS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHU/Yy5wcm9jZXNzaW5nLmFtYmllbnRMaWdodChuLnYsaS52LGUudix0LnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygbz9jLnByb2Nlc3NpbmcuYW1iaWVudExpZ2h0KG4udixpLnYsZS52LHQudix1LnYpOmMucHJvY2Vzc2luZy5hbWJpZW50TGlnaHQobi52LGkudixlLnYsdC52LHUudixvLnYpfSkpLGMuYmVnaW5DYW1lcmE9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3NpbmcuYmVnaW5DYW1lcmEoKX0pKSxjLmJlZ2luU2hhcGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuJiYobj1jLlBPTFlHT04pLGMucHJvY2Vzc2luZy5iZWdpblNoYXBlKG4udil9KSksYy5iZXppZXJEZXRhaWw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7bj1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIG4/bi52OjIwLGMucHJvY2Vzc2luZy5iZXppZXJEZXRhaWwobil9KSksYy5iZXppZXJQb2ludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe2MucHJvY2Vzc2luZy5iZXppZXJQb2ludChuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmJlemllclRhbmdlbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtjLnByb2Nlc3NpbmcuYmV6aWVyVGFuZ2VudChuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmJlemllclZlcnRleD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyxzLGwscil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBzP2MucHJvY2Vzc2luZy5iZXppZXJWZXJ0ZXgobi52LGkudixlLnYsdC52LHUudixvLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgbD9jLnByb2Nlc3NpbmcuYmV6aWVyVmVydGV4KG4udixpLnYsZS52LHQudix1LnYsby52LHMudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiByP2MucHJvY2Vzc2luZy5iZXppZXJWZXJ0ZXgobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudik6Yy5wcm9jZXNzaW5nLmJlemllclZlcnRleChuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudil9KSksYy5ibGVuZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyxzLGwscix2KXtuIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRffHxuIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8/Yy5wcm9jZXNzaW5nLmJsZW5kKG4udixpLnYsZS52LHQudix1LnYsby52LHMudixsLnYsci52KTpjLnByb2Nlc3NpbmcuYmxlbmQobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYsdi52KX0pKSxjLmJsZW5kQ29sb3I9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3ZhciB0PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLmNvbG9yLFtuZXcgU2suYnVpbHRpbi5pbnRfKDApLG5ldyBTay5idWlsdGluLmludF8oMCksbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0pO3JldHVybiB0LnY9Yy5wcm9jZXNzaW5nLmJsZW5kQ29sb3Iobi52LGkudixlLnYpLHR9KSksYy5icmlnaHRuZXNzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5icmlnaHRuZXNzKG4udikpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLmJyaWdodG5lc3Mobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYnJpZ2h0bmVzcyhuLnYsaS52LGUudikpfSkpLGMuY2FtZXJhPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCxyKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG4/Yy5wcm9jZXNzaW5nLmNhbWVyYSgpOmMucHJvY2Vzc2luZy5jYW1lcmEobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYpfSkpLGMuY29uc3RyYWluPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5jb25zdHJhaW4obi52LGkudixlLnYpKX0pKSxjLmNvcHk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1LG8scyxsLHIpe24gaW5zdGFuY2VvZiBTay5idWlsdGluLmludF98fG4gaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0Xz9jLnByb2Nlc3NpbmcuY29weShuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52KTpjLnByb2Nlc3NpbmcuY29weShuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudil9KSksYy5jcmVhdGVGb250PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe3ZhciB1PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBGb250KTtyZXR1cm4gdS52PVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcuY3JlYXRlRm9udChuLnYsaS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLmNyZWF0ZUZvbnQobi52LGkudixlLnYpOmMucHJvY2Vzc2luZy5jcmVhdGVGb250KG4udixpLnYsZS52LHQudiksdX0pKSxjLmNyZWF0ZUdyYXBoaWNzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe3ZhciB1PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBHcmFwaGljcyk7cmV0dXJuIHUudj1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLmNyZWF0ZUdyYXBoaWNzKG4udixpLnYsZS52KTpjLnByb2Nlc3NpbmcuY3JlYXRlR3JhcGhpY3Mobi52LGkudixlLnYsdC52KSx1fSkpLGMuY3JlYXRlSW1hZ2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3ZhciB0PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBJbWFnZSk7cmV0dXJuIHQudj1jLnByb2Nlc3NpbmcuY3JlYXRlSW1hZ2Uobi52LGkudixlLnYpLHR9KSksYy5jdXJzb3I9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygbj9jLnByb2Nlc3NpbmcuY3Vyc29yKCk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5jdXJzb3Iobi52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLmN1cnNvcihuLnYsaS52KTpjLnByb2Nlc3NpbmcuY3Vyc29yKG4udixpLnYsZS52KX0pKSxjLmN1cnZlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCxyLHYsZixTKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHI/Yy5wcm9jZXNzaW5nLmN1cnZlKG4udixpLnYsZS52LHQudix1LnYsby52LHMudixsLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygdj9jLnByb2Nlc3NpbmcuY3VydmUobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZj9jLnByb2Nlc3NpbmcuY3VydmUobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYsdi52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFM/Yy5wcm9jZXNzaW5nLmN1cnZlKG4udixpLnYsZS52LHQudix1LnYsby52LHMudixsLnYsci52LHYudixmLnYpOmMucHJvY2Vzc2luZy5jdXJ2ZShuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudix2LnYsZi52LFMudil9KSksYy5jdXJ2ZURldGFpbD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcuY3VydmVEZXRhaWwobi52KX0pKSxjLmN1cnZlUG9pbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtjLnByb2Nlc3NpbmcuY3VydmVQb2ludChuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmN1cnZlVGFuZ2VudD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe2MucHJvY2Vzc2luZy5jdXJ2ZVRhbmdlbnQobi52LGkudixlLnYsdC52LHUudil9KSksYy5jdXJ2ZVRpZ2h0bmVzcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcuY3VydmVUaWdodG5lc3Mobi52KX0pKSxjLmN1cnZlVmVydGV4PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLmN1cnZlVmVydGV4KG4udixpLnYpOmMucHJvY2Vzc2luZy5jdXJ2ZVZlcnRleChuLnYsaS52LGUudil9KSksYy5kYXk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcuZGF5KCkpfSkpLGMuZGVncmVlcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5kZWdyZWVzKG4udikpfSkpLGMuZGlyZWN0aW9uYWxMaWdodD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLmRpcmVjdGlvbmFsTGlnaHQobi52LGkudixlLnYsdC52LHUudixvLnYpfSkpLGMuZGlzdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB1P25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuZGlzdChuLnYsaS52LGUudix0LnYpKTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG8/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5kaXN0KG4udixpLnYsZS52LHQudix1LnYpKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLmRpc3Qobi52LGkudixlLnYsdC52LHUudixvLnYpKX0pKSxjLmVtaXNzaXZlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLmVtaXNzaXZlKG4udik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP2MucHJvY2Vzc2luZy5lbWlzc2l2ZShuLnYsaS52KTpjLnByb2Nlc3NpbmcuZW1pc3NpdmUobi52LGkudixlLnYpfSkpLGMuZW5kQ2FtZXJhPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLmVuZENhbWVyYSgpfSkpLGMuZW5kU2hhcGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuP2MucHJvY2Vzc2luZy5lbmRTaGFwZSgpOmMucHJvY2Vzc2luZy5lbmRTaGFwZShuLnYpfSkpLGMuZmlsdGVyPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5maWx0ZXIobi52KTpjLnByb2Nlc3NpbmcuZmlsdGVyKG4udixpLnYpfSkpLGMuZnJ1c3R1bT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLmZydXN0dW0obixpLGUsdCx1LG8pfSkpLGMuaGludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcuaGludChuKX0pKSxjLmhvdXI9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcuaG91cigpKX0pKSxjLmh1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5odWUobi52KSl9KSksYy5pbWFnZU1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLmltYWdlTW9kZShuLnYpfSkpLGMubGVycD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcubGVycChuLnYsaS52LGUudikpfSkpLGMubGVycENvbG9yPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXt2YXIgdD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5jb2xvcixbbmV3IFNrLmJ1aWx0aW4uaW50XygwKSxuZXcgU2suYnVpbHRpbi5pbnRfKDApLG5ldyBTay5idWlsdGluLmludF8oMCldKTtyZXR1cm4gdC52PWMucHJvY2Vzc2luZy5sZXJwQ29sb3Iobi52LGkudixlLnYpLHR9KSksYy5saWdodEZhbGxvZmY9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe2MucHJvY2Vzc2luZy5saWdodEZhbGxvZmYobi52LGkudixlLnYpfSkpLGMubGlnaHRzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLmxpZ2h0cygpfSkpLGMubGlnaHRTcGVjdWxhcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7Yy5wcm9jZXNzaW5nLmxpZ2h0U3BlY3VsYXIobi52LGkudixlLnYpfSkpLGMubG9hZEJ5dGVzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGMucHJvY2Vzc2luZy5sb2FkQnl0ZXMobi52KSl9KSksYy5sb2FkRm9udD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXt2YXIgaT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QRm9udCk7cmV0dXJuIGkudj1jLnByb2Nlc3NpbmcubG9hZEZvbnQobi52KSxpfSkpLGMubG9hZFNoYXBlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QU2hhcGVTVkcsW25ldyBTay5idWlsdGluLnN0cihcXFwic3RyaW5nXFxcIiksbl0pfSkpLGMubG9hZFN0cmluZ3M9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYy5wcm9jZXNzaW5nLmxvYWRTdHJpbmdzKG4udikpfSkpLGMubWFnPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5tYWcobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcubWFnKG4udixpLnYsZS52KSl9KSksYy5tYXA9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5tYXAobi52LGkudixlLnYsdC52LHUudikpfSkpLGMubWlsbGlzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLm1pbGxpcygpKX0pKSxjLm1pbnV0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5taW51dGUoKSl9KSksYy5tb2RlbFg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLm1vZGVsWChuLnYsaS52LGUudikpfSkpLGMubW9kZWxZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5tb2RlbFkobi52LGkudixlLnYpKX0pKSxjLm1vZGVsWj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcubW9kZWxaKG4udixpLnYsZS52KSl9KSksYy5tb250aD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5tb250aCgpKX0pKSxjLm5vQ3Vyc29yPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vQ3Vyc29yKCl9KSksYy5ub2lzZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3Npbmcubm9pc2Uobi52KSk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3Npbmcubm9pc2Uobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3Npbmcubm9pc2Uobi52LGkudixlLnYpKX0pKSxjLm5vaXNlRGV0YWlsPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7Yy5wcm9jZXNzaW5nLm5vaXNlRGV0YWlsKG4udixpLnYpfSkpLGMubm9pc2VTZWVkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLm5vaXNlU2VlZChuLnYpKX0pKSxjLm5vTGlnaHRzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vTGlnaHRzKCl9KSksYy5ub3JtPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5ub3JtKG4udixpLnYsZS52KSl9KSksYy5ub3JtYWw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe2MucHJvY2Vzc2luZy5ub3JtYWwobi52LGkudixlLnYpfSkpLGMubm9UaW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vVGludCgpfSkpLGMub3J0aG89bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1LG8pe2MucHJvY2Vzc2luZy5vcnRobyhuLnYsaS52LGUudix0LnYsdS52LG8udil9KSksYy5wZXJzcGVjdGl2ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG4/Yy5wcm9jZXNzaW5nLnBlcnNwZWN0aXZlKCk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5wZXJzcGVjdGl2ZShuLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcucGVyc3BlY3RpdmUobi52LGkudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0P2MucHJvY2Vzc2luZy5wZXJzcGVjdGl2ZShuLnYsaS52LGUudik6Yy5wcm9jZXNzaW5nLnBlcnNwZWN0aXZlKG4udixpLnYsZS52LHQudil9KSksYy5wb2ludExpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvKXtjLnByb2Nlc3NpbmcucG9pbnRMaWdodChuLnYsaS52LGUudix0LnYsdS52LG8udil9KSksYy5wcmludENhbWVyYT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2MucHJvY2Vzc2luZy5wcmludENhbWVyYSgpfSkpLGMucHJpbnRsbj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcucHJpbnRsbihuLnYpfSkpLGMucHJpbnRQcm9qZWN0aW9uPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnByaW50UHJvamVjdGlvbigpfSkpLGMucmFkaWFucz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5yYWRpYW5zKG4udikpfSkpLGMucmFuZG9tU2VlZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5yYW5kb21TZWVkKG4udikpfSkpLGMucmFuZG9tPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcucmFuZG9tKCkpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnJhbmRvbShuLnYpKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnJhbmRvbShuLnYsaS52KSl9KSksYy5yZXF1ZXN0SW1hZ2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXt2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QSW1hZ2UpO3JldHVybiBlLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5yZXF1ZXN0SW1hZ2Uobi52KTpjLnByb2Nlc3NpbmcucmVxdWVzdEltYWdlKG4udixpLnYpLGV9KSksYy5zYXR1cmF0aW9uPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNhdHVyYXRpb24obi52KSl9KSksYy5zYXZlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5zYXZlKG4udil9KSksYy5zYXZlRnJhbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuP2MucHJvY2Vzc2luZy5zYXZlRnJhbWUoKTpjLnByb2Nlc3Npbmcuc2F2ZUZyYW1lKG4udil9KSksYy5zYXZlU3RyaW5ncz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe2MucHJvY2Vzc2luZy5zYXZlU3RyaW5ncyhuLnYsaS52KX0pKSxjLnNjcmVlblg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNjcmVlblgobi52LGkudixlLnYpKX0pKSxjLnNjcmVlblk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNjcmVlblkobi52LGkudixlLnYpKX0pKSxjLnNjcmVlblo9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNjcmVlbloobi52LGkudixlLnYpKX0pKSxjLnNlY29uZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5zZWNvbmQoKSl9KSksYy5zaGFwZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3Npbmcuc2hhcGUobi52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLnNoYXBlKG4udixpLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9jLnByb2Nlc3Npbmcuc2hhcGUobi52LGkudixlLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdT9jLnByb2Nlc3Npbmcuc2hhcGUobi52LGkudixlLnYsdC52KTpjLnByb2Nlc3Npbmcuc2hhcGUobi52LGkudixlLnYsdC52LHUudil9KSksYy5zaGFwZU1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnNoYXBlTW9kZShuLnYpfSkpLGMuc2hpbmluZXNzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5zaGluaW5lc3Mobi52KX0pKSxjLnNwZWN1bGFyPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLnNwZWN1bGFyKG4udik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP2MucHJvY2Vzc2luZy5zcGVjdWxhcihuLnYsaS52KTpjLnByb2Nlc3Npbmcuc3BlY3VsYXIobi52LGkudixlLnYpfSkpLGMuc3BvdExpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCl7Yy5wcm9jZXNzaW5nLnNwb3RMaWdodChuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52KX0pKSxjLnNxPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNxKG4pKX0pKSxjLnN0YXR1cz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3Npbmcuc3RhdHVzKG4udil9KSksYy50ZXh0QWxpZ249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLnRleHRBbGlnbihuLnYpOmMucHJvY2Vzc2luZy50ZXh0QWxpZ24obi52LGkudil9KSksYy50ZXh0QXNjZW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcudGV4dEFzY2VudCgpKX0pKSxjLnRleHREZXNjZW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcudGV4dERlc2NlbnQoKSl9KSksYy50ZXh0Rm9udD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3NpbmcudGV4dEZvbnQobi52KTpjLnByb2Nlc3NpbmcudGV4dEZvbnQobi52LGkudil9KSksYy50ZXh0TGVhZGluZz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcudGV4dExlYWRpbmcobi52KX0pKSxjLnRleHRNb2RlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy50ZXh0TW9kZShuLnYpfSkpLGMudGV4dFNpemU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnRleHRTaXplKG4udil9KSksYy50ZXh0dXJlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy50ZXh0dXJlKG4udil9KSksYy50ZXh0dXJlTW9kZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcudGV4dHVyZU1vZGUobi52KX0pKSxjLnRleHRXaWR0aD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy50ZXh0V2lkdGgobi52KSl9KSksYy50aW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3NpbmcudGludChuLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcudGludChuLnYsaS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLnRpbnQobi52LGkudixlLnYpOmMucHJvY2Vzc2luZy50aW50KG4udixpLnYsZS52LHQudil9KSksYy51cGRhdGVQaXhlbHM9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3NpbmcudXBkYXRlUGl4ZWxzKCl9KSksYy52ZXJ0ZXg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLnZlcnRleChuLnYsaS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLnZlcnRleChuLnYsaS52LGUudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB1P2MucHJvY2Vzc2luZy52ZXJ0ZXgobi52LGkudixlLnYsdC52KTpjLnByb2Nlc3NpbmcudmVydGV4KG4udixpLnYsZS52LHQudix1LnYpfSkpLGMueWVhcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy55ZWFyKCkpfSkpLGMuYm94PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5ib3gobi52KX0pKSxjLnNwaGVyZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3Npbmcuc3BoZXJlKG4udil9KSksYy5zcGhlcmVEZXRhaWw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLnNwaGVyZURldGFpbChuLnYpOmMucHJvY2Vzc2luZy5zcGhlcmVEZXRhaWwobi52LGkudil9KSksYy5iYWNrZ3JvdW5kPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGkmJihpPWkudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBlJiYoZT1lLnYpLGMucHJvY2Vzc2luZy5iYWNrZ3JvdW5kKG4udixpLGUpfSkpLGMuZmlsbD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGkmJihpPWkudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBlJiYoZT1lLnYpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgdCYmKHQ9dC52KSxjLnByb2Nlc3NpbmcuZmlsbChuLnYsaSxlLHQpfSkpLGMuc3Ryb2tlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgaSYmKGk9aS52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGUmJihlPWUudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB0JiYodD10LnYpLGMucHJvY2Vzc2luZy5zdHJva2Uobi52LGksZSx0KX0pKSxjLm5vU3Ryb2tlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vU3Ryb2tlKCl9KSksYy5jb2xvck1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtpPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT8yNTU6aS52LFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZSYmKGU9ZS52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHQmJih0PXQudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB1JiYodT11LnYpLGMucHJvY2Vzc2luZy5jb2xvck1vZGUobi52LGksZSx0LHUpfSkpLGMubm9GaWxsPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vRmlsbCgpfSkpLGMubG9vcD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKG51bGw9PT1jLnByb2Nlc3NpbmcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJsb29wKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBydW4oKVxcXCIpO3Y9ITAsYy5wcm9jZXNzaW5nLmxvb3AoKX0pKSxjLm5vTG9vcD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKG51bGw9PT1jLnByb2Nlc3NpbmcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJub0xvb3AoKSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHJ1bigpXFxcIik7dj0hMSxjLnByb2Nlc3Npbmcubm9Mb29wKCl9KSksYy5mcmFtZVJhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLmZyYW1lUmF0ZShuLnYpfSkpLGMud2lkdGg9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLmhlaWdodD1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMucmVuZGVyTW9kZT1jLlAyRCxjLnNpemU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9Yy5QMkQpLGMucHJvY2Vzc2luZy5zaXplKG4udixpLnYsZS52KSxjLndpZHRoPW5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLndpZHRoKSxjLmhlaWdodD1uZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5oZWlnaHQpLGMucmVuZGVyTW9kZT1lfSkpLGMuZXhpdHA9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3NpbmcuZXhpdCgpfSkpLGMubW91c2VYPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLm1vdXNlWCl9KSksYy5tb3VzZVk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcubW91c2VZKX0pKSxjLnBtb3VzZVg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcucG1vdXNlWCl9KSksYy5wbW91c2VZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLnBtb3VzZVkpfSkpLGMucmVjdE1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnJlY3RNb2RlKG4udil9KSksYy5zdHJva2VXZWlnaHQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnN0cm9rZVdlaWdodChuLnYpfSkpLGMuc21vb3RoPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnNtb290aCgpfSkpLGMubm9TbW9vdGg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3Npbmcubm9TbW9vdGgoKX0pKSxjLmVsbGlwc2VNb2RlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5lbGxpcHNlTW9kZShuLnYpfSkpLGMuc3Ryb2tlQ2FwPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5zdHJva2VDYXAobi52KX0pKSxjLnN0cm9rZUpvaW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnN0cm9rZUpvaW4obi52KX0pKSxjLnJvdGF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3Npbmcucm90YXRlKG4udil9KSksYy5yb3RhdGVYPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5yb3RhdGVYKG4udil9KSksYy5yb3RhdGVZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5yb3RhdGVZKG4udil9KSksYy5yb3RhdGVaPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5yb3RhdGVaKG4udil9KSksYy5zY2FsZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7aT1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/MTppLnYsZT1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/MTplLnYsYy5wcm9jZXNzaW5nLnNjYWxlKG4udixpLGUpfSkpLGMudHJhbnNsYXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtpPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT8xOmkudixlPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT8xOmUudixjLnByb2Nlc3NpbmcudHJhbnNsYXRlKG4udixpLGUpfSkpLGMucG9wTWF0cml4PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnBvcE1hdHJpeCgpfSkpLGMucHVzaE1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2MucHJvY2Vzc2luZy5wdXNoTWF0cml4KCl9KSksYy5hcHBseU1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3ZhciBuLGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDAsMTYpO2ZvcihuPTA7bjxpLmxlbmd0aDtuKyspaVtuXT1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGlbbl0/MDppW25dLnY7Yy5wcm9jZXNzaW5nLmFwcGx5TWF0cml4LmFwcGx5KGMucHJvY2Vzc2luZyxpKX0pKSxjLnJlc2V0TWF0cml4PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnJlc2V0TWF0cml4KCl9KSksYy5wcmludE1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5mZmkucmVtYXBUb1B5KGMucHJvY2Vzc2luZy5wcmludE1hdHJpeCgpKX0pKSxjLnJ1bj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3ZhciBuPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNrLmNhbnZhcyk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFxcXCJQcm9jZXNzaW5nIG1vZHVsZTogQ2FudmFzIGVsZW1lbnQgbm90IHNwZWNpZmllZFxcXCIpO2lmKHdpbmRvdy5Qcm9jZXNzaW5nLmxvZ2dlcj17bG9nOmZ1bmN0aW9uKG4pe1NrLm1pc2NldmFsLnByaW50XyhuKX19LChmPXdpbmRvdy5Qcm9jZXNzaW5nLmdldEluc3RhbmNlQnlJZChTay5jYW52YXMpKSYmZi5leGl0KCksYy5wPW5ldyB3aW5kb3cuUHJvY2Vzc2luZyhuLChmdW5jdGlvbiBza2V0Y2hQcm9jKG4pe2MucHJvY2Vzc2luZz1uLG4uZHJhdz1mdW5jdGlvbigpe3ZhciBpPSExO2Zvcih2YXIgZSBpbiByKTA9PT1yW2VdLndpZHRoJiYoaT0hMCk7aWYoITA9PT1pKXJldHVybiEwPT09dj92b2lkIDA6dm9pZCBuLmxvb3AoKTtpZighMT09PXYmJm4ubm9Mb29wKCksYy5mcmFtZUNvdW50PW4uZnJhbWVDb3VudCxTay5nbG9iYWxzLmRyYXcpdHJ5e1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5nbG9iYWxzLmRyYXcpfWNhdGNoKHQpe1NrLnVuY2F1Z2h0RXhjZXB0aW9uKHQpfX07dmFyIGk9W1xcXCJzZXR1cFxcXCIsXFxcIm1vdXNlTW92ZWRcXFwiLFxcXCJtb3VzZUNsaWNrZWRcXFwiLFxcXCJtb3VzZURyYWdnZWRcXFwiLFxcXCJtb3VzZU1vdmVkXFxcIixcXFwibW91c2VPdXRcXFwiLFxcXCJtb3VzZU92ZXJcXFwiLFxcXCJtb3VzZVByZXNzZWRcXFwiLFxcXCJtb3VzZVJlbGVhc2VkXFxcIixcXFwia2V5UHJlc3NlZFxcXCIsXFxcImtleVJlbGVhc2VkXFxcIixcXFwia2V5VHlwZWRcXFwiXTtmb3IodmFyIGUgaW4gaSlTay5nbG9iYWxzW2lbZV1dJiYobltpW2VdXT1uZXcgRnVuY3Rpb24oXFxcInRyeSB7U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KFNrLmdsb2JhbHNbJ1xcXCIraVtlXStcXFwiJ10pO30gY2F0Y2goZSkge1NrLnVuY2F1Z2h0RXhjZXB0aW9uKGUpO31cXFwiKSl9KSksMD09PWMud2lkdGgudiYmMD09PWMuaGVpZ2h0LnYpe3ZhciBpPW4ub2Zmc2V0V2lkdGgsZT1uLm9mZnNldEhlaWdodDtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5zaXplLFtuZXcgU2suYnVpbHRpbi5pbnRfKGkpLG5ldyBTay5idWlsdGluLmludF8oZSksYy5yZW5kZXJNb2RlXSl9fSkpLHM9ZnVuY3Rpb24obixpKXtpLl9fZ2V0YXR0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuXFxcInhcXFwiPT09KGk9U2suZmZpLnJlbWFwVG9KcyhpKSk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3NpbmcubW91c2VYKTpcXFwieVxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLm1vdXNlWSk6XFxcInB4XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3NpbmcucG1vdXNlWCk6XFxcInB5XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3NpbmcucG1vdXNlWSk6XFxcInByZXNzZWRcXFwiPT09aT9uZXcgU2suYnVpbHRpbi5ib29sKGMucHJvY2Vzc2luZy5fX21vdXNlUHJlc3NlZCk6XFxcImJ1dHRvblxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLm1vdXNlQnV0dG9uKTp2b2lkIDB9KSl9LGMuTW91c2U9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLHMsXFxcIk1vdXNlXFxcIixbXSksYy5tb3VzZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5Nb3VzZSksbz1mdW5jdGlvbihuLGkpe2kuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtyZXR1cm5cXFwia2V5XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP25ldyBTay5idWlsdGluLnN0cihjLnByb2Nlc3Npbmcua2V5LnRvU3RyaW5nKCkpOlxcXCJrZXlDb2RlXFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3Npbmcua2V5Q29kZSk6XFxcImtleVByZXNzZWRcXFwiPT09aT9uZXcgU2suYnVpbHRpbi5zdHIoYy5wcm9jZXNzaW5nLmtleVByZXNzZWQpOnZvaWQgMH0pKX0sYy5LZXlib2FyZD1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsbyxcXFwiS2V5Ym9hcmRcXFwiLFtdKSxjLmtleWJvYXJkPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLktleWJvYXJkKSx1PWZ1bmN0aW9uKG4saSl7aS5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVyblxcXCJmcmFtZUNvdW50XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLmZyYW1lQ291bnQpOlxcXCJmcmFtZVJhdGVcXFwiPT09aT9Tay5idWlsdGluLmFzc2skKGMucHJvY2Vzc2luZy5mcmFtZVJhdGUpOlxcXCJoZWlnaHRcXFwiPT09aT9Tay5idWlsdGluLmFzc2skKGMucHJvY2Vzc2luZy5oZWlnaHQpOlxcXCJ3aWR0aFxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLndpZHRoKTpcXFwib25saW5lXFxcIj09PWk/bmV3IFNrLmJ1aWx0aW4uYm9vbChjLnByb2Nlc3Npbmcub25saW5lKTpcXFwiZm9jdXNlZFxcXCI9PT1pP25ldyBTay5idWlsdGluLmJvb2woYy5wcm9jZXNzaW5nLmZvY3VzZWQpOnZvaWQgMH0pKX0sYy5FbnZpcm9ubWVudD1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsdSxcXFwiRW52aXJvbm1lbnRcXFwiLFtdKSxjLmVudmlyb25tZW50PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLkVudmlyb25tZW50KSx0PWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtuLnBpeGVscz1udWxsfSkpLGkuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtyZXR1cm5cXFwiaGVpZ2h0XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLmhlaWdodCk6XFxcIndpZHRoXFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3Npbmcud2lkdGgpOihcXFwicGl4ZWxzXFxcIj09PWkmJm51bGw9PW4ucGl4ZWxzJiYobi5waXhlbHM9bmV3IFNrLmJ1aWx0aW4ubGlzdChjLnByb2Nlc3NpbmcucGl4ZWxzLnRvQXJyYXkoKSkpLG4ucGl4ZWxzKX0pKX0sYy5TY3JlZW49U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLHQsXFxcIlNjcmVlblxcXCIsW10pLGMuc2NyZWVuPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlNjcmVlbiksYy5sb2FkUGl4ZWxzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLmxvYWRQaXhlbHMoKX0pKSxlPWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZSYmKGU9ZS52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHQmJih0PXQudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB1JiYodT11LnYpLG4udj1jLnByb2Nlc3NpbmcuY29sb3IoaS52LGUsdCx1KX0pKX0sYy5jb2xvcj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsZSxcXFwiY29sb3JcXFwiLFtdKSxjLnJlZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcucmVkKG4udikpfSkpLGMuZ3JlZW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLmdyZWVuKG4udikpfSkpLGMuYmx1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcuYmx1ZShuLnYpKX0pKSxpPWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBjLnByb2Nlc3NpbmcuUEltYWdlOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9uZXcgYy5wcm9jZXNzaW5nLlBJbWFnZShpLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9uZXcgYy5wcm9jZXNzaW5nLlBJbWFnZShpLnYsZS52KTpuZXcgYy5wcm9jZXNzaW5nLlBJbWFnZShpLnYsZS52LHQudil9KSksaS5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVyblxcXCJ3aWR0aFxcXCI9PT0oaT1Tay5mZmkucmVtYXBUb0pzKGkpKT9Tay5idWlsdGluLmFzc2skKG4udi53aWR0aCk6XFxcImhlaWdodFxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQobi52LmhlaWdodCk6dm9pZCAwfSkpfSxjLmxvYWRJbWFnZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXt2YXIgaT1jLnByb2Nlc3NpbmcubG9hZEltYWdlKG4udik7ci5wdXNoKGkpO3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBJbWFnZSk7cmV0dXJuIGUudj1pLGV9KSksYy5pbWFnZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9jLnByb2Nlc3NpbmcuaW1hZ2Uobi52LGkudixlLnYpOmMucHJvY2Vzc2luZy5pbWFnZShuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmdldD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3ZhciBlPWMucHJvY2Vzc2luZy5nZXQobi52LGkudik7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLmNvbG9yLFtuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5yZWQoZSkpLG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLmdyZWVuKGUpKSxuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5ibHVlKGUpKV0pfSkpLGMuc2V0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtjLnByb2Nlc3Npbmcuc2V0KG4udixpLnYsZS52KX0pKSxsPWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBjLnByb2Nlc3NpbmcuUFZlY3RvcjpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/bmV3IGMucHJvY2Vzc2luZy5QVmVjdG9yKGkudixlLnYpOm5ldyBjLnByb2Nlc3NpbmcuUFZlY3RvcihpLnYsZS52LHQudil9KSksaS5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVyblxcXCJ4XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQobi52LngpOlxcXCJ5XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChuLnYueSk6XFxcInpcXFwiPT09aT9Tay5idWlsdGluLmFzc2skKG4udi56KTp2b2lkIDB9KSksaS5nZXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7dmFyIGk9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMuUFZlY3Rvcik7cmV0dXJuIGkudj1uLnYuZ2V0KCksaX0pKSxpLnNldD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/bi52LnNldChpLnYsZS52KTpuLnYuc2V0KGkudixlLnYsdC52KX0pKSxpLm1hZz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gU2suYnVpbHRpbi5hc3NrJChuLnYubWFnKCkpfSkpLGkuYWRkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7dmFyIGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMuUFZlY3Rvcik7cmV0dXJuIGUudj1uLnYuYWRkKGkudiksZX0pKSxpLnN1Yj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBWZWN0b3IpO3JldHVybiBlLnY9bi52LnN1YihpLnYpLGV9KSksaS5tdWx0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7dmFyIGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMuUFZlY3Rvcik7cmV0dXJuIGUudj1uLnYubXVsdChpLnYpLGV9KSksaS5kaXY9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXt2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QVmVjdG9yKTtyZXR1cm4gZS52PW4udi5kaXYoaS52KSxlfSkpLGkuZGlzdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVybiBTay5idWlsdGluLmFzc2skKG4udi5kaXN0KGkudikpfSkpLGkuZG90PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe3JldHVyblxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9Tay5idWlsdGluLmFzc2skKG4udi5kb3QoaS52KSk6U2suYnVpbHRpbi5hc3NrJChuLnYuZG90KGkudixlLnYsdC52KSl9KSksaS5jcm9zcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBWZWN0b3IpO3JldHVybiBlLnY9bi52LmNyb3NzKGkudiksZX0pKSxpLm5vcm1hbGl6ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtuLnYubm9ybWFsaXplKCl9KSksaS5saW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe24udi5saW1pdChpLnYpfSkpLGkuYW5nbGVCZXR3ZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuIFNrLmJ1aWx0aW4uYXNzayQobi52LmFuZ2xlQmV0d2VlbihpLnYpKX0pKSxpLmFycmF5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KG4udi5hcnJheSgpKX0pKX07cmV0dXJuIGMuUEZvbnQ9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLChmdW5jdGlvbihuLGkpe2kuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBjLnByb2Nlc3NpbmcuUEZvbnQ6bmV3IGMucHJvY2Vzc2luZy5QVmVjdG9yKGkudil9KSksaS5saXN0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KG4udi5saXN0KCkpfSkpfSksXFxcIlBGb250XFxcIixbXSksYy5QR3JhcGhpY3M9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLChmdW5jdGlvbihuLGkpe2kuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCl7bi52PVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9uZXcgYy5wcm9jZXNzaW5nLlBWZWN0b3I6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0P25ldyBjLnByb2Nlc3NpbmcuUFZlY3RvcihpLnYsZS52KTpuZXcgYy5wcm9jZXNzaW5nLlBWZWN0b3IoaS52LGUudix0LnYpfSkpLGkuYmVnaW5EcmF3PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe24udi5iZWdpbkRyYXcoKX0pKSxpLmVuZERyYXc9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7bi52LmVuZERyYXcoKX0pKX0pLFxcXCJQR3JhcGhpY3NcXFwiLFtdKSxjLlBTaGFwZVNWRz1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsKGZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP251bGw6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP25ldyBjLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGkudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0P25ldyBjLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGkudixlLnYpOm5ldyBjLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGkudixlLnYsdC52KX0pKSxpLl9fZ2V0YXR0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuXFxcIndpZHRoXFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQobi52LndpZHRoKTpcXFwiaGVpZ2h0XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChuLnYuaGVpZ2h0KTp2b2lkIDB9KSksaS5pc1Zpc2libGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2wobi52LmlzVmlzaWJsZSgpKX0pKSxpLnNldFZpc2libGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtuLnYuc2V0VmlzaWJsZShpLnYpfSkpLGkuZGlzYWJsZVN0eWxlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe24udi5kaXNhYmxlU3R5bGUoKX0pKSxpLmVuYWJsZVN0eWxlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe24udi5lbmFibGVTdHlsZSgpfSkpLGkuZ2V0Q2hpbGQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXt2YXIgZT1uLnYuZ2V0Q2hpbGQoaS52KTtpZihudWxsIT1lKXt2YXIgdD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QU2hhcGVTVkcpO3JldHVybiB0LnY9ZSx0fXJldHVybiBudWxsfSkpLGkudHJhbnNsYXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9uLnYudHJhbnNsYXRlKGkudixlLnYpOm4udi50cmFuc2xhdGUoaS52LGUudix0LnYpfSkpLGkucm90YXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7bi52LnJvdGF0ZShpLnYpfSkpLGkucm90YXRlWD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe24udi5yb3RhdGVYKGkudil9KSksaS5yb3RhdGVZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7bi52LnJvdGF0ZVkoaS52KX0pKSxpLnJvdGF0ZVo9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtuLnYucm90YXRlWihpLnYpfSkpLGkuc2NhbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP24udi5zY2FsZShpLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9uLnYuc2NhbGUoaS52LGUudik6bi52LnNjYWxlKGkudixlLnYsdC52KX0pKX0pLFxcXCJQU2hhcGVTVkdcXFwiLFtdKSxjLlBWZWN0b3I9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLGwsXFxcIlBWZWN0b3JcXFwiLFtdKSxjLlBJbWFnZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsaSxcXFwiUEltYWdlXFxcIixbXSksY307XCIsXCJzcmMvbGliL3JhbmRvbS5qc1wiOlwidmFyIE1lcnNlbm5lVHdpc3Rlcj1mdW5jdGlvbihuKXtudWxsPT1uJiYobj0obmV3IERhdGUpLmdldFRpbWUoKSksdGhpcy5OPTYyNCx0aGlzLk09Mzk3LHRoaXMuTUFUUklYX0E9MjU2NzQ4MzYxNSx0aGlzLlVQUEVSX01BU0s9MjE0NzQ4MzY0OCx0aGlzLkxPV0VSX01BU0s9MjE0NzQ4MzY0Nyx0aGlzLm10PW5ldyBBcnJheSh0aGlzLk4pLHRoaXMubXRpPXRoaXMuTisxLHRoaXMuaW5pdF9nZW5yYW5kKG4pfTtNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmluaXRfZ2VucmFuZD1mdW5jdGlvbihuKXtmb3IodGhpcy5tdFswXT1uPj4+MCx0aGlzLm10aT0xO3RoaXMubXRpPHRoaXMuTjt0aGlzLm10aSsrKW49dGhpcy5tdFt0aGlzLm10aS0xXV50aGlzLm10W3RoaXMubXRpLTFdPj4+MzAsdGhpcy5tdFt0aGlzLm10aV09KDE4MTI0MzMyNTMqKCg0Mjk0OTAxNzYwJm4pPj4+MTYpPDwxNikrMTgxMjQzMzI1MyooNjU1MzUmbikrdGhpcy5tdGksdGhpcy5tdFt0aGlzLm10aV0+Pj49MH0sTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5pbml0X2J5X2FycmF5PWZ1bmN0aW9uKG4sdCl7dmFyIGksZSxyO2Zvcih0aGlzLmluaXRfZ2VucmFuZCgxOTY1MDIxOCksaT0xLGU9MCxyPXRoaXMuTj50P3RoaXMuTjp0O3I7ci0tKXt2YXIgdT10aGlzLm10W2ktMV1edGhpcy5tdFtpLTFdPj4+MzA7dGhpcy5tdFtpXT0odGhpcy5tdFtpXV4oMTY2NDUyNSooKDQyOTQ5MDE3NjAmdSk+Pj4xNik8PDE2KSsxNjY0NTI1Kig2NTUzNSZ1KSkrbltlXStlLHRoaXMubXRbaV0+Pj49MCxlKyssKytpPj10aGlzLk4mJih0aGlzLm10WzBdPXRoaXMubXRbdGhpcy5OLTFdLGk9MSksZT49dCYmKGU9MCl9Zm9yKHI9dGhpcy5OLTE7cjtyLS0pe3U9dGhpcy5tdFtpLTFdXnRoaXMubXRbaS0xXT4+PjMwO3RoaXMubXRbaV09KHRoaXMubXRbaV1eKDE1NjYwODM5NDEqKCg0Mjk0OTAxNzYwJnUpPj4+MTYpPDwxNikrMTU2NjA4Mzk0MSooNjU1MzUmdSkpLWksdGhpcy5tdFtpXT4+Pj0wLCsraT49dGhpcy5OJiYodGhpcy5tdFswXT10aGlzLm10W3RoaXMuTi0xXSxpPTEpfXRoaXMubXRbMF09MjE0NzQ4MzY0OH0sTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5nZW5yYW5kX2ludDMyPWZ1bmN0aW9uKCl7dmFyIG4sdD1uZXcgQXJyYXkoMCx0aGlzLk1BVFJJWF9BKTtpZih0aGlzLm10aT49dGhpcy5OKXt2YXIgaTtmb3IodGhpcy5tdGk9PXRoaXMuTisxJiZ0aGlzLmluaXRfZ2VucmFuZCg1NDg5KSxpPTA7aTx0aGlzLk4tdGhpcy5NO2krKyluPXRoaXMubXRbaV0mdGhpcy5VUFBFUl9NQVNLfHRoaXMubXRbaSsxXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFtpXT10aGlzLm10W2krdGhpcy5NXV5uPj4+MV50WzEmbl07Zm9yKDtpPHRoaXMuTi0xO2krKyluPXRoaXMubXRbaV0mdGhpcy5VUFBFUl9NQVNLfHRoaXMubXRbaSsxXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFtpXT10aGlzLm10W2krKHRoaXMuTS10aGlzLk4pXV5uPj4+MV50WzEmbl07bj10aGlzLm10W3RoaXMuTi0xXSZ0aGlzLlVQUEVSX01BU0t8dGhpcy5tdFswXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFt0aGlzLk4tMV09dGhpcy5tdFt0aGlzLk0tMV1ebj4+PjFedFsxJm5dLHRoaXMubXRpPTB9cmV0dXJuIG49dGhpcy5tdFt0aGlzLm10aSsrXSxuXj1uPj4+MTEsbl49bjw8NyYyNjM2OTI4NjQwLG5ePW48PDE1JjQwMjI3MzA3NTIsKG5ePW4+Pj4xOCk+Pj4wfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfaW50MzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW5yYW5kX2ludDMyKCk+Pj4xfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW5yYW5kX2ludDMyKCkqKDEvNDI5NDk2NzI5NSl9LE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VucmFuZF9pbnQzMigpKigxLzQyOTQ5NjcyOTYpfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDM9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5nZW5yYW5kX2ludDMyKCkrLjUpKigxLzQyOTQ5NjcyOTYpfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVzNTM9ZnVuY3Rpb24oKXtyZXR1cm4oNjcxMDg4NjQqKHRoaXMuZ2VucmFuZF9pbnQzMigpPj4+NSkrKHRoaXMuZ2VucmFuZF9pbnQzMigpPj4+NikpKigxLzkwMDcxOTkyNTQ3NDA5OTIpfTt2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7dmFyIHQ9e30saT1uZXcgTWVyc2VubmVUd2lzdGVyLGU9dm9pZCAwO3Quc2VlZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2VlZFxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLG49U2suYnVpbHRpbi5hc251bSQobiksaT1hcmd1bWVudHMubGVuZ3RoPjA/bmV3IE1lcnNlbm5lVHdpc3RlcihuKTpuZXcgTWVyc2VubmVUd2lzdGVyLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSx0LnJhbmRvbT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kb21cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oaS5nZW5yYW5kX3JlczUzKCkpfSkpO3ZhciB0b0ludD1mdW5jdGlvbihuKXtyZXR1cm4gMHxufSxyYW5kcmFuZ2U9ZnVuY3Rpb24obix0LGUpe3ZhciByLHUscztpZighU2suYnVpbHRpbi5jaGVja0ludChuKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJub24taW50ZWdlciBmaXJzdCBhcmd1bWVudCBmb3IgcmFuZHJhbmdlKClcXFwiKTtpZih2b2lkIDA9PT10KXJldHVybiBzPXRvSW50KGkuZ2VucmFuZF9yZXM1MygpKm4pLG5ldyBTay5idWlsdGluLmludF8ocyk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQodCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibm9uLWludGVnZXIgc3RvcCBmb3IgcmFuZHJhbmdlKClcXFwiKTtpZih2b2lkIDA9PT1lJiYoZT0xKSxyPXQtbiwxPT1lJiZyPjApcmV0dXJuIHM9bit0b0ludChpLmdlbnJhbmRfcmVzNTMoKSpyKSxuZXcgU2suYnVpbHRpbi5pbnRfKHMpO2lmKDE9PWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZW1wdHkgcmFuZ2UgZm9yIHJhbmRyYW5nZSgpIChcXFwiK24rXFxcIiwgXFxcIit0K1xcXCIsIFxcXCIrcitcXFwiKVxcXCIpO2lmKCFTay5idWlsdGluLmNoZWNrSW50KGUpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm5vbi1pbnRlZ2VyIHN0ZXAgZm9yIHJhbmRyYW5nZSgpXFxcIik7aWYoZT4wKXU9dG9JbnQoKHIrZS0xKS9lKTtlbHNle2lmKCEoZTwwKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJ6ZXJvIHN0ZXAgZm9yIHJhbmRyYW5nZSgpXFxcIik7dT10b0ludCgocitlKzEpL2UpfWlmKHU8PTApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZW1wdHkgcmFuZ2UgZm9yIHJhbmRyYW5nZSgpXFxcIik7cmV0dXJuIHM9bitlKnRvSW50KGkuZ2VucmFuZF9yZXM1MygpKnUpLG5ldyBTay5idWlsdGluLmludF8ocyl9O3QucmFuZGludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kaW50XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksbj1Tay5idWlsdGluLmFzbnVtJChuKSx0PVNrLmJ1aWx0aW4uYXNudW0kKHQpLHJhbmRyYW5nZShuLHQrMSl9KSksdC5yYW5kcmFuZ2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGkpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kcmFuZ2VcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwzKSxuPVNrLmJ1aWx0aW4uYXNudW0kKG4pLHQ9U2suYnVpbHRpbi5hc251bSQodCksaT1Tay5idWlsdGluLmFzbnVtJChpKSxyYW5kcmFuZ2Uobix0LGkpfSkpLHQudW5pZm9ybT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInVuaWZvcm1cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxuPVNrLmJ1aWx0aW4uYXNudW0kKG4pLHQ9U2suYnVpbHRpbi5hc251bSQodCk7dmFyIGU9aS5nZW5yYW5kX3JlczUzKCk7Y29uc3Qgcj1uK2UqKHQtbik7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhyKX0pKSx0LnRyaWFuZ3VsYXI9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUpe3ZhciByLHUscztyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwidHJpYW5ndWxhclxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDMpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImxvd1xcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihuKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiaGlnaFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcih0KSksKG49U2suYnVpbHRpbi5hc251bSQobikpPih0PVNrLmJ1aWx0aW4uYXNudW0kKHQpKSYmKHM9bixuPXQsdD1zKSx2b2lkIDA9PT1lfHxlPT09U2suYnVpbHRpbi5ub25lLm5vbmUkP2U9KHQtbikvMjooU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwibW9kZVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSksZT1Tay5idWlsdGluLmFzbnVtJChlKSksdT0ocj1pLmdlbnJhbmRfcmVzNTMoKSk8KGUtbikvKHQtbik/bitNYXRoLnNxcnQocioodC1uKSooZS1uKSk6dC1NYXRoLnNxcnQoKDEtcikqKHQtbikqKHQtZSkpLG5ldyBTay5idWlsdGluLmZsb2F0Xyh1KX0pKTt2YXIgbm9ybWFsU2FtcGxlPWZ1bmN0aW9uKG4sdCl7dmFyIHIsdSxzLGgsbDtyZXR1cm4gdm9pZCAwIT09ZT8obD1lLGU9dm9pZCAwKToocj1pLmdlbnJhbmRfcmVzNTMoKSx1PWkuZ2VucmFuZF9yZXM1MygpLHM9TWF0aC5zcXJ0KC0yKk1hdGgubG9nKHIpKSxoPTIqTWF0aC5QSSp1LGw9cypNYXRoLmNvcyhoKSxlPXMqTWF0aC5zaW4oaCkpLG4rdCpsfTtyZXR1cm4gdC5nYXVzcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnYXVzc1xcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcIm11XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKG4pKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJzaWdtYVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcih0KSksbj1Tay5idWlsdGluLmFzbnVtJChuKSx0PVNrLmJ1aWx0aW4uYXNudW0kKHQpLG5ldyBTay5idWlsdGluLmZsb2F0Xyhub3JtYWxTYW1wbGUobix0KSl9KSksdC5ub3JtYWx2YXJpYXRlPXQuZ2F1c3MsdC5sb2dub3JtdmFyaWF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJsb2dub3JtdmFyaWF0ZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcIm11XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKG4pKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJzaWdtYVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcih0KSksbj1Tay5idWlsdGluLmFzbnVtJChuKSx0PVNrLmJ1aWx0aW4uYXNudW0kKHQpLG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmV4cChub3JtYWxTYW1wbGUobix0KSkpfSkpLHQuZXhwb3ZhcmlhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZXhwb3ZhcmlhdGVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJsYW1iZFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihuKSksbj1Tay5idWlsdGluLmFzbnVtJChuKTt2YXIgdD1pLmdlbnJhbmRfcmVzNTMoKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC1NYXRoLmxvZyh0KS9uKX0pKSx0LmNob2ljZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJjaG9pY2VcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJzZXFcXFwiLFxcXCJzZXF1ZW5jZVxcXCIsU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKG4pKSx2b2lkIDAhPT1uLnNxJGxlbmd0aCl7dmFyIHQ9bmV3IFNrLmJ1aWx0aW4uaW50Xyh0b0ludChpLmdlbnJhbmRfcmVzNTMoKSpuLnNxJGxlbmd0aCgpKSk7cmV0dXJuIG4ubXAkc3Vic2NyaXB0KHQpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwib2JqZWN0IGhhcyBubyBsZW5ndGhcXFwiKX0pKSx0LnNodWZmbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2h1ZmZsZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJzZXF1ZW5jZVxcXCIsU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKG4pKSxuLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5saXN0KXtjb25zdCB1PW4udjtmb3IodmFyIHQ9dS5sZW5ndGgtMTt0PjA7dC09MSl7dmFyIGU9dVtyPXRvSW50KGkuZ2VucmFuZF9yZXM1MygpKih0KzEpKV07dVtyXT11W3RdLHVbdF09ZX19ZWxzZXtpZih2b2lkIDA9PT1uLnNxJGxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIm9iamVjdCBoYXMgbm8gbGVuZ3RoXFxcIik7aWYodm9pZCAwPT09bi5tcCRhc3Nfc3Vic2NyaXB0KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwib2JqZWN0IGlzIGltbXV0YWJsZVxcXCIpO2Zvcih0PW4uc3EkbGVuZ3RoKCktMTt0PjA7dC09MSl7dmFyIHI9bmV3IFNrLmJ1aWx0aW4uaW50Xyh0b0ludChpLmdlbnJhbmRfcmVzNTMoKSoodCsxKSkpO3Q9bmV3IFNrLmJ1aWx0aW4uaW50Xyh0KTtlPW4ubXAkc3Vic2NyaXB0KHIpO24ubXAkYXNzX3N1YnNjcmlwdChyLG4ubXAkc3Vic2NyaXB0KHQpKSxuLm1wJGFzc19zdWJzY3JpcHQodCxlKX19cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSx0LnNhbXBsZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe3ZhciBlLHIsdSxzLGg7Zm9yKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNhbXBsZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInBvcHVsYXRpb25cXFwiLFxcXCJpdGVyYWJsZVxcXCIsU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKG4pKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJrXFxcIixcXFwiaW50ZWdlclxcXCIsU2suYnVpbHRpbi5jaGVja0ludCh0KSksdD1Tay5idWlsdGluLmFzbnVtJCh0KSxoPVtdLGU9MCxzPSh1PVNrLmFic3RyLml0ZXIobikpLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09cztlKysscz11LnRwJGl0ZXJuZXh0KCkpcj1NYXRoLmZsb29yKGkuZ2VucmFuZF9yZXM1MygpKihlKzEpKSxlPHQ/KHI8ZSYmKGhbZV09aFtyXSksaFtyXT1zKTpyPHQmJihoW3JdPXMpO2lmKGU8dCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJzYW1wbGUgbGFyZ2VyIHRoYW4gcG9wdWxhdGlvblxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGgpfSkpLHR9O1wiLFwic3JjL2xpYi9yZS5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG5hbWUpe3ZhciBtb2Q9e19fbmFtZV9fOm5ldyBTay5idWlsdGluLnN0cihcXFwicmVcXFwiKX0sdmFsaWRHcm91cHMsY29udmVydCxnZXRGbGFncyxfc3BsaXQsX2ZpbmRhbGwsbWF0Y2hvYmosX3NlYXJjaCxfbWF0Y2gscmVnZXhvYmo7cmV0dXJuIG1vZC5JPTIsbW9kLklHTk9SRUNBU0U9Mixtb2QuTT04LG1vZC5NVUxUSUxJTkU9OCx2YWxpZEdyb3Vwcz1bXFxcIig/OlxcXCIsXFxcIig/PVxcXCIsXFxcIig/IVxcXCJdLGNvbnZlcnQ9ZnVuY3Rpb24obil7dmFyIHQsZTtpZih0PW4ubWF0Y2goL1xcXFwoXFxcXD8uL2cpKWZvcihlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoLTE9PXZhbGlkR3JvdXBzLmluZGV4T2YodFtlXSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiRGlzYWxsb3dlZCBncm91cCBpbiBwYXR0ZXJuOiAnXFxcIit0W2VdK1xcXCInXFxcIik7cmV0dXJuIG4ucmVwbGFjZShcXFwiL1xcXFxcXFxcL2dcXFwiLFxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcIiksbi5yZXBsYWNlKC8oW15cXFxcXFxcXF0peywoPyFbXlxcXFxbXSpcXFxcXSkvZyxcXFwiJDF7MCxcXFwiKX0sZ2V0RmxhZ3M9ZnVuY3Rpb24obil7dmFyIHQ9XFxcImdcXFwiO3JldHVybihuJm1vZC5JR05PUkVDQVNFKT09bW9kLklHTk9SRUNBU0UmJih0Kz1cXFwiaVxcXCIpLChuJm1vZC5NVUxUSUxJTkUpPT1tb2QuTVVMVElMSU5FJiYodCs9XFxcIm1cXFwiKSx0fSxfc3BsaXQ9ZnVuY3Rpb24obix0LGUscil7dmFyIGwsdSxzLGEsbyxjLGIsZixrO2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNwbGl0XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsNCksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyh0KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInN0cmluZyBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYodm9pZCAwPT09ZSYmKGU9MCksIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJtYXhzcGxpdCBtdXN0IGJlIGEgbnVtYmVyXFxcIik7aWYodm9pZCAwPT09ciYmKHI9MCksIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIocikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJmbGFncyBtdXN0IGJlIGEgbnVtYmVyXFxcIik7Zm9yKGU9U2suYnVpbHRpbi5hc251bSQoZSksbD1Tay5mZmkudW53cmFwbyhuKSx1PVNrLmZmaS51bndyYXBvKHQpLHM9IShudWxsPT09KGw9Y29udmVydChsKSkubWF0Y2goL15cXFxcKC4qXFxcXCkkLykpLGE9Z2V0RmxhZ3Mociksbz1uZXcgUmVnRXhwKGwsYSksYz1bXSxmPTAsaz0wO251bGwhPShiPW8uZXhlYyh1KSkmJmIuaW5kZXghPT1vLmxhc3RJbmRleCYmKGMucHVzaChuZXcgU2suYnVpbHRpbi5zdHIodS5zdWJzdHJpbmcoZixiLmluZGV4KSkpLHMmJmMucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoYlswXSkpLGY9by5sYXN0SW5kZXgsays9MSwhKGUmJms+PWUpKTspO3JldHVybiBjLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKHUuc3Vic3RyaW5nKGYpKSksbmV3IFNrLmJ1aWx0aW4ubGlzdChjKX0sX3NwbGl0LmNvX3Zhcm5hbWVzPVtcXFwicGF0dGVyblxcXCIsXFxcInN0cmluZ1xcXCIsXFxcIm1heHNwbGl0XFxcIixcXFwiZmxhZ3NcXFwiXSxfc3BsaXQuJGRlZmF1bHRzPVtuZXcgU2suYnVpbHRpbi5pbnRfKDApLG5ldyBTay5idWlsdGluLmludF8oMCldLG1vZC5zcGxpdD1uZXcgU2suYnVpbHRpbi5mdW5jKF9zcGxpdCksX2ZpbmRhbGw9ZnVuY3Rpb24obix0LGUpe3ZhciByLGwsdSxzLGEsbztpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJmaW5kYWxsXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMyksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyh0KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInN0cmluZyBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYodm9pZCAwPT09ZSYmKGU9MCksIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJmbGFncyBtdXN0IGJlIGEgbnVtYmVyXFxcIik7aWYocj1Tay5mZmkudW53cmFwbyhuKSxsPVNrLmZmaS51bndyYXBvKHQpLHI9Y29udmVydChyKSx1PWdldEZsYWdzKGUpLHM9bmV3IFJlZ0V4cChyLHUpLHIubWF0Y2goL1xcXFwkLykpe3ZhciBjPW5ldyBSZWdFeHAoL1xcXFxuJC8pO2wubWF0Y2goYykmJihsPWwuc2xpY2UoMCwtMSkpfWZvcihhPVtdO251bGwhPShvPXMuZXhlYyhsKSk7KXtpZihvLmxlbmd0aDwyKWEucHVzaChuZXcgU2suYnVpbHRpbi5zdHIob1swXSkpO2Vsc2UgaWYoMj09by5sZW5ndGgpYS5wdXNoKG5ldyBTay5idWlsdGluLnN0cihvWzFdKSk7ZWxzZXtmb3IodmFyIGI9W10sZj0xO2Y8by5sZW5ndGg7ZisrKWIucHVzaChuZXcgU2suYnVpbHRpbi5zdHIob1tmXSkpO2EucHVzaChuZXcgU2suYnVpbHRpbi50dXBsZShiKSl9by5pbmRleD09PXMubGFzdEluZGV4JiYocy5sYXN0SW5kZXgrPTEpfXJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGEpfSxfZmluZGFsbC5jb192YXJuYW1lcz1bXFxcInBhdHRlcm5cXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJmbGFnc1xcXCJdLF9maW5kYWxsLiRkZWZhdWx0cz1bbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0sbW9kLmZpbmRhbGw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhfZmluZGFsbCksbWF0Y2hvYmo9ZnVuY3Rpb24obix0KXt0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCxlLHIpe3JldHVybiBuLnRoZW1hdGNoPXQsbi5yZT1lLG4uc3RyaW5nPXIsU2suYnVpbHRpbi5ub25lLm5vbmUkfSkpLHQuZ3JvdXBzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3ZhciB0PW4udGhlbWF0Y2gudi5zbGljZSgxKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUodCl9KSksdC5ncm91cD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe2lmKCh0PXZvaWQgMD09PXQ/MDpTay5idWlsdGluLmFzbnVtJCh0KSk+PW4udGhlbWF0Y2gudi5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcXFwiSW5kZXggb3V0IG9mIHJhbmdlOiBcXFwiK3QpO3JldHVybiBuLnRoZW1hdGNoLnZbdF19KSl9LG1vZC5NYXRjaE9iamVjdD1Tay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCxtYXRjaG9iaixcXFwiTWF0Y2hPYmplY3RcXFwiLFtdKSxtb2QuX2ZpbmRyZT1mdW5jdGlvbihyZXMsc3RyaW5nKXt2YXIgbWF0Y2hlcyxzaXRlbSxyZXR2YWw7cmVzPXJlcy5yZXBsYWNlKC8oW15cXFxcXFxcXF0peywoPyFbXlxcXFxbXSpcXFxcXSkvZyxcXFwiJDF7MCxcXFwiKTt2YXIgcmU9ZXZhbChyZXMpLHBhdHQ9bmV3IFJlZ0V4cChcXFwiXFxcXG4kXFxcIiksc3RyPVNrLmZmaS5yZW1hcFRvSnMoc3RyaW5nKTtpZihtYXRjaGVzPXN0ci5tYXRjaChwYXR0KT9zdHIuc2xpY2UoMCwtMSkubWF0Y2gocmUpOnN0ci5tYXRjaChyZSkscmV0dmFsPW5ldyBTay5idWlsdGluLmxpc3QsbnVsbD09bWF0Y2hlcylyZXR1cm4gcmV0dmFsO2Zvcih2YXIgaT0wO2k8bWF0Y2hlcy5sZW5ndGg7KytpKXNpdGVtPW5ldyBTay5idWlsdGluLnN0cihtYXRjaGVzW2ldKSxyZXR2YWwudi5wdXNoKHNpdGVtKTtyZXR1cm4gcmV0dmFsfSxfc2VhcmNoPWZ1bmN0aW9uKG4sdCxlKXt2YXIgcjtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZWFyY2hcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwzKSwhU2suYnVpbHRpbi5jaGVja1N0cmluZyhuKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInBhdHRlcm4gbXVzdCBiZSBhIHN0cmluZ1xcXCIpO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHQpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwic3RyaW5nIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZih2b2lkIDA9PT1lJiYoZT0wKSwhU2suYnVpbHRpbi5jaGVja051bWJlcihlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImZsYWdzIG11c3QgYmUgYSBudW1iZXJcXFwiKTtyPVxcXCIvXFxcIituLnYucmVwbGFjZSgvXFxcXC8vZyxcXFwiXFxcXFxcXFwvXFxcIikrXFxcIi9cXFwiO2NvbnN0IGw9bW9kLl9maW5kcmUocix0KTtyZXR1cm4gbC52Lmxlbmd0aDwxP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobW9kLk1hdGNoT2JqZWN0LFtsLG4sdF0pfSxfc2VhcmNoLmNvX3Zhcm5hbWVzPVtcXFwicGF0dGVyblxcXCIsXFxcInN0cmluZ1xcXCIsXFxcImZsYWdzXFxcIl0sX3NlYXJjaC4kZGVmYXVsdHM9W25ldyBTay5idWlsdGluLmludF8oMCldLG1vZC5zZWFyY2g9bmV3IFNrLmJ1aWx0aW4uZnVuYyhfc2VhcmNoKSxfbWF0Y2g9ZnVuY3Rpb24obix0LGUpe3ZhciByO2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm1hdGNoXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMyksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyh0KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInN0cmluZyBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYodm9pZCAwPT09ZSYmKGU9MCksIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJmbGFncyBtdXN0IGJlIGEgbnVtYmVyXFxcIik7Y29uc3QgbD1Tay5mZmkucmVtYXBUb0pzKG4pO3I9XFxcIi9eXFxcIitsLnJlcGxhY2UoL1xcXFwvL2csXFxcIlxcXFxcXFxcL1xcXCIpK1xcXCIvXFxcIjtjb25zdCB1PW1vZC5fZmluZHJlKHIsdCk7cmV0dXJuIFNrLmZmaS5yZW1hcFRvSnModSkubGVuZ3RoPDE/U2suYnVpbHRpbi5ub25lLm5vbmUkOlNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShtb2QuTWF0Y2hPYmplY3QsW3Usbix0XSl9LF9tYXRjaC5jb192YXJuYW1lcz1bXFxcInBhdHRlcm5cXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJmbGFnc1xcXCJdLF9tYXRjaC4kZGVmYXVsdHM9W25ldyBTay5idWlsdGluLmludF8oMCldLG1vZC5tYXRjaD1uZXcgU2suYnVpbHRpbi5mdW5jKF9tYXRjaCkscmVnZXhvYmo9ZnVuY3Rpb24obix0KXt2YXIgZSxyLGwsdSxzLGE7dC5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSl7cmV0dXJuIG4ucmU9dCxuLmZsYWdzPXZvaWQgMD09PWU/MDplLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSxhPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3ZhciB0PVxcXCJyZS5jb21waWxlKCdcXFwiK1NrLmZmaS5yZW1hcFRvSnMobi5yZSkrXFxcIicpXFxcIjtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeSh0LnN1YnN0cmluZygwLDIxMikpfSkpLHQuX19zdHJfXz1hLHQuX19yZXByX189YSxlPWZ1bmN0aW9uKG4sdCxlKXt2YXIgcj1Tay5mZmkucmVtYXBUb0pzKG4pLGw9bnVsbD09dD8wOlNrLmZmaS5yZW1hcFRvSnModCksdT1udWxsPT1lP3IubGVuZ3RoOlNrLmZmaS5yZW1hcFRvSnMoZSk7cmV0dXJuXFxcIl5cXFwiPT1sJiYobD1yLmluZGV4T2YoXFxcIlxcXFxuXFxcIikrMSksbnVsbD09PXUmJih1PXIubGVuZ3RoKSxTay5mZmkucmVtYXBUb1B5KHIuc3Vic3RyaW5nKGwsdSkpfSwocj1mdW5jdGlvbihuLHQscixsKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZWFyY2hcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiw0KTt2YXIgdT1lKHQscixsKTtyZXR1cm4gX3NlYXJjaChuLnJlLHUsbi5mbGFncyl9KS5jb192YXJuYW1lcz1bXFxcInNlbGZcXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJwb3NcXFwiLFxcXCJlbmRwb3NcXFwiXSxyLiRkZWZhdWx0cz1bbmV3IFNrLmJ1aWx0aW4uaW50XygwKSxTay5idWlsdGluLm5vbmUubm9uZSRdLHQuc2VhcmNoPW5ldyBTay5idWlsdGluLmZ1bmMociksKGw9ZnVuY3Rpb24obix0LHIsbCl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwibWF0Y2hcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiw0KTt2YXIgdT1lKHQscixsKTtyZXR1cm4gX21hdGNoKG4ucmUsdSxuLmZsYWdzKX0pLmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInN0cmluZ1xcXCIsXFxcInBvc1xcXCIsXFxcImVuZHBvc1xcXCJdLGwuJGRlZmF1bHRzPVtuZXcgU2suYnVpbHRpbi5pbnRfKDApLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0sdC5tYXRjaD1uZXcgU2suYnVpbHRpbi5mdW5jKGwpLCh1PWZ1bmN0aW9uKG4sdCxlKXtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzcGxpdFxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDMpLHZvaWQgMD09PWUmJihlPTApLCFTay5idWlsdGluLmNoZWNrSW50KGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwibWF4c3BsaXQgbXVzdCBiZSBhbiBpbnRlZ2VyXFxcIik7cmV0dXJuIF9zcGxpdChuLnJlLHQsZSxuLmZsYWdzKX0pLmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInN0cmluZ1xcXCIsXFxcIm1heHNwbGl0XFxcIl0sdS4kZGVmYXVsdHM9W25ldyBTay5idWlsdGluLmludF8oMCldLHQuc3BsaXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyh1KSwocz1mdW5jdGlvbihuLHQscixsKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJmaW5kYWxsXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsNCk7dmFyIHU9ZSh0LHIsbCk7cmV0dXJuIF9maW5kYWxsKG4ucmUsdSxuLmZsYWdzKX0pLmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInN0cmluZ1xcXCIsXFxcInBvc1xcXCIsXFxcImVuZHBvc1xcXCJdLHMuJGRlZmF1bHRzPVtuZXcgU2suYnVpbHRpbi5pbnRfKDApLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0sdC5maW5kYWxsPW5ldyBTay5idWlsdGluLmZ1bmMocyl9LG1vZC5SZWdleE9iamVjdD1Tay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCxyZWdleG9iaixcXFwiUmVnZXhPYmplY3RcXFwiLFtdKSxtb2QuY29tcGlsZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImNvbXBpbGVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwyKSwhU2suYnVpbHRpbi5jaGVja1N0cmluZyhuKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInBhdHRlcm4gbXVzdCBiZSBhIHN0cmluZ1xcXCIpO2lmKHZvaWQgMD09PXQmJih0PTApLCFTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiZmxhZ3MgbXVzdCBiZSBhIG51bWJlclxcXCIpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobW9kLlJlZ2V4T2JqZWN0LFtuLHRdKX0pKSxtb2QucHVyZ2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXt9KSksbW9kfTtcIixcInNyYy9saWIvc2lnbmFsLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7dmFyIGk9e307cmV0dXJuIGkuU0lHX0RGTD1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGkuU0lHX0lHTj1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGkuQ1RSTF9DX0VWRU5UPW5ldyBTay5idWlsdGluLmludF8oMCksaS5DVFJMX0JSRUFLX0VWRU5UPW5ldyBTay5idWlsdGluLmludF8oMCksaS5OU0lHPW5ldyBTay5idWlsdGluLmludF8oMjMpLGkuU0lHSFVQPW5ldyBTay5idWlsdGluLmludF8oMSksaS5TSUdOSU5UPW5ldyBTay5idWlsdGluLmludF8oMiksaS5TSUdJTEw9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxpLlNJR0ZQRT1uZXcgU2suYnVpbHRpbi5pbnRfKDgpLGkuU0lHS0lMTD1uZXcgU2suYnVpbHRpbi5pbnRfKDkpLGkuU0lHU0VHVj1uZXcgU2suYnVpbHRpbi5pbnRfKDExKSxpLlNJR1RFUk09bmV3IFNrLmJ1aWx0aW4uaW50XygxNSksaS5TSUdCUkVBSz1uZXcgU2suYnVpbHRpbi5pbnRfKDIxKSxpLlNJR0FCUlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygyMiksaS5wYXVzZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInBhdXNlXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMCk7dmFyIG49bmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb247cmV0dXJuIG4ucmVzdW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sbi5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOm5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe2lmKG51bGwhPVNrLnNpZ25hbHMmJlNrLnNpZ25hbHMuYWRkRXZlbnRMaXN0ZW5lcil7U2suc2lnbmFscy5hZGRFdmVudExpc3RlbmVyKChmdW5jdGlvbiBoYW5kbGVTaWduYWwoaSl7U2suc2lnbmFscy5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZVNpZ25hbCksbigpfSkpfWVsc2UgY29uc29sZS53YXJuKFxcXCJzaWduYWwucGF1c2UoKSBub3Qgc3VwcG9ydGVkXFxcIiksU2subWlzY2V2YWwucHJpbnRfKFxcXCJzaWduYWwucGF1c2UoKSBub3Qgc3VwcG9ydGVkXFxcIiksbigpfSkpfSxufSkpLGkuc2lnbmFsPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2lnbmFsLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkLlxcXCIpfSkpLGl9O1wiLFwic3JjL2xpYi9zdHJpbmcuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihpKXt2YXIgdD17fTtyZXR1cm4gdC5hc2NpaV9sb3dlcmNhc2U9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxcXCIpLHQuYXNjaWlfdXBwZXJjYXNlPW5ldyBTay5idWlsdGluLnN0cihcXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcXFwiKSx0LmFzY2lpX2xldHRlcnM9bmV3IFNrLmJ1aWx0aW4uc3RyKHQuYXNjaWlfbG93ZXJjYXNlLnYrdC5hc2NpaV91cHBlcmNhc2UudiksdC5sb3dlcmNhc2U9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxcXCIpLHQudXBwZXJjYXNlPW5ldyBTay5idWlsdGluLnN0cihcXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcXFwiKSx0LmxldHRlcnM9bmV3IFNrLmJ1aWx0aW4uc3RyKHQubG93ZXJjYXNlLnYrdC51cHBlcmNhc2UudiksdC5kaWdpdHM9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIwMTIzNDU2Nzg5XFxcIiksdC5oZXhkaWdpdHM9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIwMTIzNDU2Nzg5YWJjZGVmQUJDREVGXFxcIiksdC5vY3RkaWdpdHM9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIwMTIzNDU2N1xcXCIpLHQucHVuY3R1YXRpb249bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIhXFxcXFxcXCIjJCUmJygpKissLS4vOjs8PT4/QFtcXFxcXFxcXF1eX2B7fH1+XFxcIiksdC53aGl0ZXNwYWNlPW5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcXHRcXFxcblxcXFx2XFxcXGZcXFxcciBcXFwiKSx0LnByaW50YWJsZT1uZXcgU2suYnVpbHRpbi5zdHIodC5kaWdpdHMudit0LmxldHRlcnMudit0LnB1bmN0dWF0aW9uLnYrXFxcIiBcXFxcdFxcXFxuXFxcXHJcXFxcdlxcXFxmXFxcIiksdC5zcGxpdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiguLi5pKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5zcGxpdCxpKX0pKSx0LmNhcGl0YWxpemU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oaSl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLnN0ci5wcm90b3R5cGUuY2FwaXRhbGl6ZSxbaV0pfSkpLHQuam9pbj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihpLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIiBcXFwiKSksU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5qb2luLFt0LGldKX0pKSx0LmNhcHdvcmRzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGksbil7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiY2Fwd29yZHNcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwyKSwhU2suYnVpbHRpbi5jaGVja1N0cmluZyhpKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInMgbXVzdCBiZSBhIHN0cmluZ1xcXCIpO2lmKHZvaWQgMD09PW4mJihuPW5ldyBTay5idWlsdGluLnN0cihcXFwiIFxcXCIpKSwhU2suYnVpbHRpbi5jaGVja1N0cmluZyhuKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInNlcCBtdXN0IGJlIGEgc3RyaW5nXFxcIik7Zm9yKHZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LnNwbGl0LFtpLG5dKS52LHI9W10sbD0wO2w8ZS5sZW5ndGg7bCsrKXt2YXIgcz1lW2xdLHU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuY2FwaXRhbGl6ZSxbc10pO3IucHVzaCh1KX1yZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuam9pbixbbmV3IFNrLmJ1aWx0aW4ubGlzdChyKSxuXSl9KSksdH07XCIsXCJzcmMvbGliL3RpbWUuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbih0KXt2YXIgZT17fTtlLl9fcGFja2FnZV9fPW5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIik7dmFyIG49U2suYnVpbHRpbi5tYWtlX3N0cnVjdHNlcShcXFwidGltZVxcXCIsXFxcInN0cnVjdF90aW1lXFxcIix7dG1feWVhcjpcXFwieWVhciwgZm9yIGV4YW1wbGUsIDE5OTNcXFwiLHRtX21vbjpcXFwibW9udGggb2YgeWVhciwgcmFuZ2UgWzEsIDEyXVxcXCIsdG1fbWRheTpcXFwiZGF5IG9mIG1vbnRoLCByYW5nZSBbMSwgMzFdXFxcIix0bV9ob3VyOlxcXCJob3VycywgcmFuZ2UgWzAsIDIzXVxcXCIsdG1fbWluOlxcXCJtaW51dGVzLCByYW5nZSBbMCwgNTldXFxcIix0bV9zZWM6XFxcInNlY29uZHMsIHJhbmdlIFswLCA2MV1cXFwiLHRtX3dkYXk6XFxcImRheSBvZiB3ZWVrLCByYW5nZSBbMCwgNl0sIE1vbmRheSBpcyAwXFxcIix0bV95ZGF5OlxcXCJkYXkgb2YgeWVhciwgcmFuZ2UgWzEsIDM2Nl1cXFwiLHRtX2lzZHN0OlxcXCIxIGlmIHN1bW1lciB0aW1lIGlzIGluIGVmZmVjdCwgMCBpZiBub3QsIGFuZCAtMSBpZiB1bmtub3duXFxcIn0se3RtX3pvbmU6XFxcImFiYnJldmlhdGlvbiBvZiB0aW1lem9uZSBuYW1lXFxcIix0bV9nbXRvZmY6XFxcIm9mZnNldCBmcm9tIFVUQyBpbiBzZWNvbmRzXFxcIn0pO2Z1bmN0aW9uIGNoZWNrX3N0cnVjdF90aW1lKHQpe2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiUmVxdWlyZWQgYXJndW1lbnQgJ3N0cnVjdF90aW1lJyBtdXN0IGJlIG9mIHR5cGU6ICdzdHJ1Y3RfdGltZSdcXFwiKTt2YXIgZSxpPXQudi5sZW5ndGgsdT10LnY7Zm9yKGU9MDtlPGk7KytlKWlmKCFTay5idWlsdGluLmNoZWNrSW50KHVbZV0pKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwic3RydWN0X3RpbWUgbWF5IG9ubHkgY29udGFpbiBpbnRlZ2Vyc1xcXCIpO3JldHVybiEwfWZ1bmN0aW9uIHBhZExlZnQodCxlLG4pe3ZhciBpPXQudG9TdHJpbmcoKTtyZXR1cm4gQXJyYXkoZS1pLmxlbmd0aCsxKS5qb2luKG58fFxcXCIgXFxcIikraX1mdW5jdGlvbiBnZXREYXlPZlllYXIodCxlKXt2YXIgbj0oZT1lfHwhMSk/dC5nZXRVVENNb250aCgpOnQuZ2V0TW9udGgoKSxpPWU/dC5nZXRVVENEYXRlKCk6dC5nZXREYXRlKCksdT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XVtuXStpO3JldHVybiBuPjEmJmZ1bmN0aW9uIGlzTGVhcFllYXIodCl7cmV0dXJuIDA9PSgzJnQpJiYodCUxMDAhPTB8fHQlNDAwPT0wKX0oZT90LmdldFVUQ0Z1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpKSYmdSsrLHV9ZnVuY3Rpb24gc3RkVGltZXpvbmVPZmZzZXQoKXt2YXIgdD1uZXcgRGF0ZSgyMDAyLDAsMSksZT1uZXcgRGF0ZSgyMDAyLDYsMSk7cmV0dXJuIE1hdGgubWF4KHQuZ2V0VGltZXpvbmVPZmZzZXQoKSxlLmdldFRpbWV6b25lT2Zmc2V0KCkpfWZ1bmN0aW9uIGRzdCh0KXtyZXR1cm4gdC5nZXRUaW1lem9uZU9mZnNldCgpPHN0ZFRpbWV6b25lT2Zmc2V0KCl9ZnVuY3Rpb24gdGltZVpvbmVOYW1lKHQpe3ZhciBlLG49L1xcXFwoKC4qKVxcXFwpLy5leGVjKHQudG9TdHJpbmcoKSk7aWYobnVsbCE9U2suZ2xvYmFsLm5hdmlnYXRvciYmKGU9U2suZ2xvYmFsLm5hdmlnYXRvci51c2VyTGFuZ3VhZ2V8fFNrLmdsb2JhbC5uYXZpZ2F0b3IubGFuZ3VhZ2UpLG4mJm4ubGVuZ3RoPjEpcmV0dXJuIG5bMV07aWYodm9pZCAwPT09ZSlyZXR1cm4gbnVsbDt0cnl7cmV0dXJuKG49dC50b0xvY2FsZVN0cmluZyhlLHt0aW1lWm9uZU5hbWU6XFxcInNob3J0XFxcIn0pLnNwbGl0KFxcXCIgXFxcIikpW24ubGVuZ3RoLTFdfWNhdGNoKGkpe3JldHVybiBudWxsfX1mdW5jdGlvbiBmcm9tX3NlY29uZHModCxlKXt2YXIgaT1uZXcgRGF0ZTtpZih0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJzZWNzXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTt2YXIgdT1Tay5idWlsdGluLmFzbnVtJCh0KTtpLnNldFRpbWUoMWUzKnUpfXJldHVybiBmdW5jdGlvbiBkYXRlX3RvX3N0cnVjdF90aW1lKHQsZSl7bGV0IGk7aWYoZT1lfHwhMSlpPVtuZXcgU2suYnVpbHRpbi5zdHIoXFxcIlVUQ1xcXCIpLG5ldyBTay5idWlsdGluLmludF8oMCldO2Vsc2V7dmFyIHU9LXQuZ2V0VGltZXpvbmVPZmZzZXQoKS82MCxyPSh1PDA/XFxcIi1cXFwiOlxcXCIrXFxcIikrKFxcXCJcXFwiK01hdGguYWJzKHUpKS5wYWRTdGFydCgyLFxcXCIwXFxcIik7aT1bbmV3IFNrLmJ1aWx0aW4uc3RyKHIpLG5ldyBTay5idWlsdGluLmludF8oMzYwMCp1KV19cmV0dXJuIG5ldyBuKFtTay5idWlsdGluLmFzc2skKGU/dC5nZXRVVENGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKSksU2suYnVpbHRpbi5hc3NrJCgoZT90LmdldFVUQ01vbnRoKCk6dC5nZXRNb250aCgpKSsxKSxTay5idWlsdGluLmFzc2skKGU/dC5nZXRVVENEYXRlKCk6dC5nZXREYXRlKCkpLFNrLmJ1aWx0aW4uYXNzayQoZT90LmdldFVUQ0hvdXJzKCk6dC5nZXRIb3VycygpKSxTay5idWlsdGluLmFzc2skKGU/dC5nZXRVVENNaW51dGVzKCk6dC5nZXRNaW51dGVzKCkpLFNrLmJ1aWx0aW4uYXNzayQoZT90LmdldFVUQ1NlY29uZHMoKTp0LmdldFNlY29uZHMoKSksU2suYnVpbHRpbi5hc3NrJCgoKGU/dC5nZXRVVENEYXkoKTp0LmdldERheSgpKSs2KSU3KSxTay5idWlsdGluLmFzc2skKGdldERheU9mWWVhcih0LGUpKSxTay5idWlsdGluLmFzc2skKGU/MDpkc3QodCk/MTowKV0saSl9KGksZSl9ZS5zdHJ1Y3RfdGltZT1uLGUudGltZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJ0aW1lXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMCksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKERhdGUubm93KCkvMWUzKX0pKSxlLnNsZWVwPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzbGVlcFxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImRlbGF5XFxcIixcXFwiZmxvYXRcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIodCkpLG5ldyBTay5taXNjZXZhbC5wcm9taXNlVG9TdXNwZW5zaW9uKG5ldyBQcm9taXNlKChmdW5jdGlvbihlKXtTay5zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UoU2suYnVpbHRpbi5ub25lLm5vbmUkKX0pLDFlMypTay5mZmkucmVtYXBUb0pzKHQpKX0pKSl9KSksZS5sb2NhbHRpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImxvY2FsdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLGZyb21fc2Vjb25kcyh0LCExKX0pKSxlLmdtdGltZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ210aW1lXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMSksZnJvbV9zZWNvbmRzKHQsITApfSkpO3ZhciBpPVtcXFwiSmFuXFxcIixcXFwiRmViXFxcIixcXFwiTWFyXFxcIixcXFwiQXByXFxcIixcXFwiTWF5XFxcIixcXFwiSnVuXFxcIixcXFwiSnVsXFxcIixcXFwiQXVnXFxcIixcXFwiU2VwXFxcIixcXFwiT2N0XFxcIixcXFwiTm92XFxcIixcXFwiRGVjXFxcIl0sdT1bXFxcIk1vblxcXCIsXFxcIlR1ZVxcXCIsXFxcIldlZFxcXCIsXFxcIlRodVxcXCIsXFxcIkZyaVxcXCIsXFxcIlNhdFxcXCIsXFxcIlN1blxcXCJdO2Z1bmN0aW9uIGFzY3RpbWVfZih0KXtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJhc2N0aW1lXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMSksIXR8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKHQpP3Q9ZnJvbV9zZWNvbmRzKCk6dCBpbnN0YW5jZW9mIG58fCh0PW5ldyBuKHQpKSx0IGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSYmOT09dC52Lmxlbmd0aCl7dmFyIGU9W107cmV0dXJuIGUucHVzaCh1W1NrLmJ1aWx0aW4uYXNudW0kKHQudls2XSldKSxlLnB1c2goaVtTay5idWlsdGluLmFzbnVtJCh0LnZbMV0pLTFdKSxlLnB1c2gocGFkTGVmdChTay5idWlsdGluLmFzbnVtJCh0LnZbMl0pLnRvU3RyaW5nKCksMixcXFwiMFxcXCIpKSxlLnB1c2gocGFkTGVmdChTay5idWlsdGluLmFzbnVtJCh0LnZbM10pLnRvU3RyaW5nKCksMixcXFwiMFxcXCIpK1xcXCI6XFxcIitwYWRMZWZ0KFNrLmJ1aWx0aW4uYXNudW0kKHQudls0XSkudG9TdHJpbmcoKSwyLFxcXCIwXFxcIikrXFxcIjpcXFwiK3BhZExlZnQoU2suYnVpbHRpbi5hc251bSQodC52WzVdKS50b1N0cmluZygpLDIsXFxcIjBcXFwiKSksZS5wdXNoKHBhZExlZnQoU2suYnVpbHRpbi5hc251bSQodC52WzBdKS50b1N0cmluZygpLDQsXFxcIjBcXFwiKSksbmV3IFNrLmJ1aWx0aW4uc3RyKGUuam9pbihcXFwiIFxcXCIpKX19ZnVuY3Rpb24gbWt0aW1lX2YodCl7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwibWt0aW1lXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksdCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUmJjk9PXQudi5sZW5ndGgpe3ZhciBlPW5ldyBEYXRlKFNrLmJ1aWx0aW4uYXNudW0kKHQudlswXSksU2suYnVpbHRpbi5hc251bSQodC52WzFdKS0xLFNrLmJ1aWx0aW4uYXNudW0kKHQudlsyXSksU2suYnVpbHRpbi5hc251bSQodC52WzNdKSxTay5idWlsdGluLmFzbnVtJCh0LnZbNF0pLFNrLmJ1aWx0aW4uYXNudW0kKHQudls1XSkpO3JldHVybiBTay5idWlsdGluLmFzc2skKGUuZ2V0VGltZSgpLzFlMyx2b2lkIDApfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwibWt0aW1lKCkgcmVxdWlyZXMgYSBzdHJ1Y3RfdGltZSBvciA5LXR1cGxlXFxcIil9ZS5hc2N0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMoYXNjdGltZV9mKSxlLmN0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJjdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLGFzY3RpbWVfZihmcm9tX3NlY29uZHModCkpfSkpLGUubWt0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMobWt0aW1lX2YpLGUudGltZXpvbmU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg2MCpzdGRUaW1lem9uZU9mZnNldCgpKSxlLmFsdHpvbmU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg2MCpmdW5jdGlvbiBhbHRUaW1lem9uZU9mZnNldCgpe3ZhciB0PW5ldyBEYXRlKDIwMDIsMCwxKSxlPW5ldyBEYXRlKDIwMDIsNiwxKTtyZXR1cm4gTWF0aC5taW4odC5nZXRUaW1lem9uZU9mZnNldCgpLGUuZ2V0VGltZXpvbmVPZmZzZXQoKSl9KCkpLGUuZGF5bGlnaHQ9bmV3IFNrLmJ1aWx0aW4uaW50XyhmdW5jdGlvbiBkYXlsaWdodF9jaGVjaygpe2NvbnN0IHQ9bmV3IERhdGUoMjAwMiwwLDEpLGU9bmV3IERhdGUoMjAwMiw2LDEpO3JldHVybiB0LmdldFRpbWV6b25lT2Zmc2V0KCkhPWUuZ2V0VGltZXpvbmVPZmZzZXQoKX0oKT8xOjApLGUudHpuYW1lPW5ldyBTay5idWlsdGluLnR1cGxlKGZ1bmN0aW9uIHRpbWVab25lTmFtZXMoKXt2YXIgdD1uZXcgRGF0ZSgyMDAyLDAsMSksZT1uZXcgRGF0ZSgyMDAyLDYsMSk7cmV0dXJuIGRzdCh0KT9bbmV3IFNrLmJ1aWx0aW4uc3RyKHRpbWVab25lTmFtZShlKSksbmV3IFNrLmJ1aWx0aW4uc3RyKHRpbWVab25lTmFtZSh0KSldOltuZXcgU2suYnVpbHRpbi5zdHIodGltZVpvbmVOYW1lKHQpKSxuZXcgU2suYnVpbHRpbi5zdHIodGltZVpvbmVOYW1lKGUpKV19KCkpLGUuYWNjZXB0MmR5ZWFyPVNrLmJ1aWx0aW4uYXNzayQoMSksZS5jbG9jaz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3ZhciB0PTA7cmV0dXJuIHQ9U2suZ2xvYmFsLnBlcmZvcm1hbmNlJiZTay5nbG9iYWwucGVyZm9ybWFuY2Uubm93P3BlcmZvcm1hbmNlLm5vdygpLzFlMzoobmV3IERhdGUpLmdldFRpbWUoKS8xZTMsbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHQpfSkpLGUuc3RyZnRpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gc3RyZnRpbWVfZih0LGUpe3ZhciBpO2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInN0cmZ0aW1lXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMiksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcodCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJmb3JtYXQgbXVzdCBiZSBhIHN0cmluZ1xcXCIpO3JldHVybiBlP2UgaW5zdGFuY2VvZiBufHwoZT1uZXcgbihlKSk6ZT1mcm9tX3NlY29uZHMoKSxjaGVja19zdHJ1Y3RfdGltZShlKSxpPVNrLmZmaS5yZW1hcFRvSnModCksU2suZmZpLnJlbWFwVG9QeShTay5nbG9iYWwuc3RyZnRpbWUoaSxuZXcgRGF0ZSgxZTMqbWt0aW1lX2YoZSkudikpKX0pKSxlLnR6c2V0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uIHR6c2V0X2YoKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ0aW1lLnR6c2V0KCkgaXMgbm90IHlldCBpbXBsZW1lbnRlZFxcXCIpfSkpO2xldCByPW51bGw7cmV0dXJuIGUuc3RycHRpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gc3RycHRpbWVfZiguLi50KXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic3RycHRpbWVcXFwiLHQubGVuZ3RoLDEsMiksbnVsbD09PXI/U2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFxcXCJfc3RycHRpbWVcXFwiLCExLCEwKSwoZT0+KHI9ZS50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcXFwiX3N0cnB0aW1lX3RpbWVcXFwiKSksci50cCRjYWxsKHQpKSkpOnIudHAkY2FsbCh0KX0pKSxlfTtcIixcInNyYy9saWIvdG9rZW4uanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihuKXt2YXIgZT17fTtlLl9fZmlsZV9fPW5ldyBTay5idWlsdGluLnN0cihcXFwiL3NyYy9saWIvdG9rZW4ucHlcXFwiKTtjb25zdCB0PVtdO2ZvcihsZXQgaSBpbiBTay50b2tlbi50b2tfbmFtZSl7Y29uc3Qgbj1Tay50b2tlbi50b2tfbmFtZVtpXS5zbGljZSgyKSxrPXBhcnNlSW50KGksMTApO3QucHVzaChTay5mZmkucmVtYXBUb1B5KGspKSx0LnB1c2goU2suZmZpLnJlbWFwVG9QeShuKSksZVtuXT1Tay5mZmkucmVtYXBUb1B5KGspfXJldHVybiBlLnRva19uYW1lPW5ldyBTay5idWlsdGluLmRpY3QodCksZS5JU1RFUk1JTkFMPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJJU1RFUk1JTkFMXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2sudG9rZW4uSVNURVJNSU5BTChTay5mZmkucmVtYXBUb0pzKG4pKX0pKSxlLklTTk9OVEVSTUlOQUw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIklTTk9OVEVSTUlOQUxcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay50b2tlbi5JU05PTlRFUk1JTkFMKFNrLmZmaS5yZW1hcFRvSnMobikpfSkpLGUuSVNFT0Y9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIklTRU9GXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2sudG9rZW4uSVNFT0YoU2suZmZpLnJlbWFwVG9KcyhuKSl9KSksZX07XCIsXCJzcmMvbGliL3Rva2VuaXplLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oZSl7dmFyIGk9e307cmV0dXJuIGkudG9rZW5pemU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwidG9rZW5pemVcXFwiLDEsMSksU2suYnVpbHRpbi5jaGVja0Z1bmN0aW9uKGUpO2NvbnN0IGk9W107cmV0dXJuIFNrLl90b2tlbml6ZShcXFwiPHN0ZGluPlxcXCIsKGZ1bmN0aW9uIGpzUmVhZGxpbmUoKXtjb25zdCBpPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlKTtyZXR1cm4gU2suZmZpLnJlbWFwVG9KcyhpKX0pLFxcXCJVVEYtOFxcXCIsKGZ1bmN0aW9uIHJlY2VpdmVUb2tlbihlKXtpLnB1c2gobmV3IFNrLmJ1aWx0aW4udHVwbGUoW1NrLmZmaS5yZW1hcFRvUHkoZS50eXBlKSxTay5mZmkucmVtYXBUb1B5KGUuc3RyaW5nKSxuZXcgU2suYnVpbHRpbi50dXBsZShbU2suZmZpLnJlbWFwVG9QeShlLnN0YXJ0WzBdKSxTay5mZmkucmVtYXBUb1B5KGUuc3RhcnRbMV0pXSksbmV3IFNrLmJ1aWx0aW4udHVwbGUoW1NrLmZmaS5yZW1hcFRvUHkoZS5lbmRbMF0pLFNrLmZmaS5yZW1hcFRvUHkoZS5lbmRbMV0pXSksU2suZmZpLnJlbWFwVG9QeShlLmxpbmUpXSkpfSkpLG5ldyBTay5idWlsdGluLmxpc3QoaSl9KSksaX07XCIsXCJzcmMvbGliL3R1cnRsZS5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKGUpe1xcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgdD1mdW5jdGlvbiBnZXRDb25maWd1cmVkVGFyZ2V0KCl7dmFyIGUsdDtmb3IodD1cXFwic3RyaW5nXFxcIj09dHlwZW9mKGU9U2suVHVydGxlR3JhcGhpY3MmJlNrLlR1cnRsZUdyYXBoaWNzLnRhcmdldHx8XFxcInR1cnRsZVxcXCIpP2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpOmU7dC5maXJzdENoaWxkOyl0LnJlbW92ZUNoaWxkKHQuZmlyc3RDaGlsZCk7cmV0dXJuIHR9KCk7cmV0dXJuIHQudHVydGxlSW5zdGFuY2U/dC50dXJ0bGVJbnN0YW5jZS5yZXNldCgpOnQudHVydGxlSW5zdGFuY2U9ZnVuY3Rpb24gZ2VuZXJhdGVUdXJ0bGVNb2R1bGUoZSl7dmFyIHQsbixyLGkscyxhLG8sbCx1PXtfX25hbWVfXzpuZXcgU2suYnVpbHRpbi5zdHIoXFxcInR1cnRsZVxcXCIpfSxjPSEwLGg9MWUzLzMwLGQ9e30sZj17fSxfPXt0YXJnZXQ6XFxcInR1cnRsZVxcXCIsd2lkdGg6NDAwLGhlaWdodDo0MDAsd29ybGRXaWR0aDowLHdvcmxkSGVpZ2h0OjAsYW5pbWF0ZTohMCxidWZmZXJTaXplOjAsYWxsb3dVbmRvOiEwLGFzc2V0czp7fX07ZnVuY3Rpb24gZ2V0QXNzZXQoZSl7dmFyIHQ9aS5hc3NldHMsbj1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgdD90KGUpOnRbZV07cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBuP25ldyBQcm9taXNlKChmdW5jdGlvbih0LHIpe3ZhciBzPW5ldyBJbWFnZTtzLm9ubG9hZD1mdW5jdGlvbigpe2kuYXNzZXRzW2VdPXRoaXMsdChzKX0scy5vbmVycm9yPWZ1bmN0aW9uKCl7cihuZXcgRXJyb3IoXFxcIk1pc3NpbmcgYXNzZXQ6IFxcXCIrbikpfSxzLnNyYz1ufSkpOm5ldyBJbnN0YW50UHJvbWlzZSh2b2lkIDAsbil9ZnVuY3Rpb24gSW5zdGFudFByb21pc2UoZSx0KXt0aGlzLmxhc3RSZXN1bHQ9dCx0aGlzLmxhc3RFcnJvcj1lfWZ1bmN0aW9uIEZyYW1lTWFuYWdlcigpe3RoaXMucmVzZXQoKX1mdW5jdGlvbiBnZXRGcmFtZU1hbmFnZXIoKXtyZXR1cm4gb3x8KG89bmV3IEZyYW1lTWFuYWdlciksb31mdW5jdGlvbiBNb3VzZUhhbmRsZXIoKXt2YXIgZT10aGlzO2Zvcih2YXIgdCBpbiB0aGlzLl90YXJnZXQ9Z2V0VGFyZ2V0KCksdGhpcy5fbWFuYWdlcnM9e30sdGhpcy5faGFuZGxlcnM9e21vdXNlZG93bjpmdW5jdGlvbih0KXtlLm9uRXZlbnQoXFxcIm1vdXNlZG93blxcXCIsdCl9LG1vdXNldXA6ZnVuY3Rpb24odCl7ZS5vbkV2ZW50KFxcXCJtb3VzZXVwXFxcIix0KX0sbW91c2Vtb3ZlOmZ1bmN0aW9uKHQpe2Uub25FdmVudChcXFwibW91c2Vtb3ZlXFxcIix0KX19LHRoaXMuX2hhbmRsZXJzKXRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKHQsdGhpcy5faGFuZGxlcnNbdF0pfWZ1bmN0aW9uIEV2ZW50TWFuYWdlcihlLHQpe3RoaXMuX3R5cGU9ZSx0aGlzLl90YXJnZXQ9dCx0aGlzLl9oYW5kbGVycz12b2lkIDAsZnVuY3Rpb24gZ2V0TW91c2VIYW5kbGVyKCl7cmV0dXJuIGF8fChhPW5ldyBNb3VzZUhhbmRsZXIpLGF9KCkuYWRkTWFuYWdlcihlLHRoaXMpfWZ1bmN0aW9uIFR1cnRsZShlKXtpZihnZXRGcmFtZU1hbmFnZXIoKS5hZGRUdXJ0bGUodGhpcyksdGhpcy5fc2NyZWVuPWdldFNjcmVlbigpLHRoaXMuX21hbmFnZXJzPXt9LHRoaXMuX3NoYXBlPWUudiwhZC5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9zaGFwZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiU2hhcGU6J1xcXCIrdGhpcy5fc2hhcGUrXFxcIicgbm90IGluIGRlZmF1bHQgc2hhcGUsIHBsZWFzZSBjaGVjayBzaGFwZSBhZ2FpbiFcXFwiKTt0aGlzLnJlc2V0KCl9ZnVuY3Rpb24gU2NyZWVuKCl7dmFyIGUsdDt0aGlzLl9mcmFtZXM9MSx0aGlzLl9kZWxheT12b2lkIDAsdGhpcy5fYmdjb2xvcj1cXFwibm9uZVxcXCIsdGhpcy5fbW9kZT1cXFwic3RhbmRhcmRcXFwiLHRoaXMuX21hbmFnZXJzPXt9LHRoaXMuX2tleUxvZ2dlcj17fSxlPShpLndvcmxkV2lkdGh8fGkud2lkdGh8fGdldFdpZHRoKCkpLzIsdD0oaS53b3JsZEhlaWdodHx8aS5oZWlnaHR8fGdldEhlaWdodCgpKS8yLHRoaXMuc2V0VXBXb3JsZCgtZSwtdCxlLHQpfWZ1bmN0aW9uIGVuc3VyZUFub255bW91cygpe3JldHVybiBzfHwocz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodS5UdXJ0bGUpKSxzLmluc3RhbmNlfWZ1bmN0aW9uIGdldFRhcmdldCgpe3JldHVybiBlfWZ1bmN0aW9uIGdldFNjcmVlbigpe3JldHVybiByfHwocj1uZXcgU2NyZWVuKSxyfWZ1bmN0aW9uIGdldFdpZHRoKCl7cmV0dXJuIDB8KHImJnIuX3dpZHRofHxpLndpZHRofHxnZXRUYXJnZXQoKS5jbGllbnRXaWR0aHx8Xy53aWR0aCl9ZnVuY3Rpb24gZ2V0SGVpZ2h0KCl7cmV0dXJuIDB8KHImJnIuX2hlaWdodHx8aS5oZWlnaHR8fGdldFRhcmdldCgpLmNsaWVudEhlaWdodHx8Xy5oZWlnaHQpfWZ1bmN0aW9uIGNyZWF0ZUxheWVyKGUsdCl7dmFyIG4scj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKSxpPWdldFdpZHRoKCkscz1nZXRIZWlnaHQoKSxhPWdldFRhcmdldCgpLmZpcnN0Q2hpbGQ/LXMrXFxcInB4XFxcIjpcXFwiMFxcXCI7cmV0dXJuIHIud2lkdGg9aSxyLmhlaWdodD1zLHIuc3R5bGUucG9zaXRpb249XFxcInJlbGF0aXZlXFxcIixyLnN0eWxlLmRpc3BsYXk9XFxcImJsb2NrXFxcIixyLnN0eWxlLnNldFByb3BlcnR5KFxcXCJtYXJnaW4tdG9wXFxcIixhKSxyLnN0eWxlLnNldFByb3BlcnR5KFxcXCJ6LWluZGV4XFxcIixlKSx0JiYoci5zdHlsZS5kaXNwbGF5PVxcXCJub25lXFxcIiksZ2V0VGFyZ2V0KCkuYXBwZW5kQ2hpbGQociksKG49ci5nZXRDb250ZXh0KFxcXCIyZFxcXCIpKS5saW5lQ2FwPVxcXCJyb3VuZFxcXCIsbi5saW5lSm9pbj1cXFwicm91bmRcXFwiLGFwcGx5V29ybGQoZ2V0U2NyZWVuKCksbiksbn1mdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZSgpe3QmJigod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUpKHQpLHQ9dm9pZCAwKSxuJiYod2luZG93LmNsZWFyVGltZW91dChuKSxuPXZvaWQgMCl9ZnVuY3Rpb24gYXBwbHlXb3JsZChlLHQpe3ZhciBuPWUubGx4LHI9KGUubGx5LGUudXJ4LGUudXJ5KSxpPWUueFNjYWxlLHM9ZS55U2NhbGU7dCYmKGNsZWFyTGF5ZXIodCksdC5yZXN0b3JlKCksdC5zYXZlKCksdC5zY2FsZSgxL2ksMS9zKSx0LnRyYW5zbGF0ZSgtbiwtcikpfWZ1bmN0aW9uIHB1c2hVbmRvKGUpe3ZhciB0LG4scjtpZihpLmFsbG93VW5kbyYmZS5fYnVmZmVyU2l6ZSl7Zm9yKGUuX3VuZG9CdWZmZXJ8fChlLl91bmRvQnVmZmVyPVtdKTtlLl91bmRvQnVmZmVyLmxlbmd0aD5lLl9idWZmZXJTaXplOyllLl91bmRvQnVmZmVyLnNoaWZ0KCk7Zm9yKG49e30sdD1cXFwieCB5IGFuZ2xlIHJhZGlhbnMgY29sb3IgZmlsbCBkb3duIGZpbGxpbmcgc2hvd24gc2hhcGUgc2l6ZVxcXCIuc3BsaXQoXFxcIiBcXFwiKSxyPTA7cjx0Lmxlbmd0aDtyKyspblt0W3JdXT1lW1xcXCJfXFxcIit0W3JdXTtyZXR1cm4gZS5fdW5kb0J1ZmZlci5wdXNoKG4pLGUuYWRkVXBkYXRlKChmdW5jdGlvbigpe24uZmlsbEJ1ZmZlcj10aGlzLmZpbGxCdWZmZXI/dGhpcy5maWxsQnVmZmVyLnNsaWNlKCk6dm9pZCAwLGUuX3BhcGVyJiZlLl9wYXBlci5jYW52YXMmJihuLmltYWdlPWUuX3BhcGVyLmNhbnZhcy50b0RhdGFVUkwoKSl9KSwhMSl9fWUuaGFzQXR0cmlidXRlKFxcXCJ0YWJpbmRleFxcXCIpfHxlLnNldEF0dHJpYnV0ZShcXFwidGFiaW5kZXhcXFwiLDApLGYuRkxPQVQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhlKX0sZi5DT0xPUj1mdW5jdGlvbihlKXtpZihcXFwic3RyaW5nXFxcIj09dHlwZW9mIGUpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihlKTtmb3IodmFyIHQ9MDt0PDM7dCsrKWVbdF09U2suYnVpbHRpbi5hc3NrJChlW3RdKTtyZXR1cm4gND09PWUubGVuZ3RoJiYoZVszXT1uZXcgU2suYnVpbHRpbi5mbG9hdF8oZVszXSkpLG5ldyBTay5idWlsdGluLnR1cGxlKGUpfSxmLlRVUlRMRV9MSVNUPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxuPTA7bjxlLmxlbmd0aDtuKyspdC5wdXNoKGVbbl0uc2tJbnN0YW5jZSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKHQpfSxkLmFycm93PVtbLTEwLDBdLFsxMCwwXSxbMCwxMF1dLGQuc3F1YXJlPVtbMTAsLTEwXSxbMTAsMTBdLFstMTAsMTBdLFstMTAsLTEwXV0sZC50cmlhbmdsZT1bWzEwLC01Ljc3XSxbMCwxMS41NV0sWy0xMCwtNS43N11dLGQuY2xhc3NpYz1bWzAsMF0sWy01LC05XSxbMCwtN10sWzUsLTldXSxkLnR1cnRsZT1bWzAsMTZdLFstMiwxNF0sWy0xLDEwXSxbLTQsN10sWy03LDldLFstOSw4XSxbLTYsNV0sWy03LDFdLFstNSwtM10sWy04LC02XSxbLTYsLThdLFstNCwtNV0sWzAsLTddLFs0LC01XSxbNiwtOF0sWzgsLTZdLFs1LC0zXSxbNywxXSxbNiw1XSxbOSw4XSxbNyw5XSxbNCw3XSxbMSwxMF0sWzIsMTRdXSxkLmNpcmNsZT1bWzEwLDBdLFs5LjUxLDMuMDldLFs4LjA5LDUuODhdLFs1Ljg4LDguMDldLFszLjA5LDkuNTFdLFswLDEwXSxbLTMuMDksOS41MV0sWy01Ljg4LDguMDldLFstOC4wOSw1Ljg4XSxbLTkuNTEsMy4wOV0sWy0xMCwwXSxbLTkuNTEsLTMuMDldLFstOC4wOSwtNS44OF0sWy01Ljg4LC04LjA5XSxbLTMuMDksLTkuNTFdLFstMCwtMTBdLFszLjA5LC05LjUxXSxbNS44OCwtOC4wOV0sWzguMDksLTUuODhdLFs5LjUxLC0zLjA5XV0saT1mdW5jdGlvbigpe3ZhciBlO2ZvcihlIGluIFNrLlR1cnRsZUdyYXBoaWNzfHwoU2suVHVydGxlR3JhcGhpY3M9e30pLF8pU2suVHVydGxlR3JhcGhpY3MuaGFzT3duUHJvcGVydHkoZSl8fChTay5UdXJ0bGVHcmFwaGljc1tlXT1fW2VdKTtyZXR1cm4gU2suVHVydGxlR3JhcGhpY3N9KCksSW5zdGFudFByb21pc2UucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oZSl7aWYodGhpcy5sYXN0RXJyb3IpcmV0dXJuIHRoaXM7dHJ5e3RoaXMubGFzdFJlc3VsdD1lKHRoaXMubGFzdFJlc3VsdCl9Y2F0Y2godCl7dGhpcy5sYXN0UmVzdWx0PXZvaWQgMCx0aGlzLmxhc3RFcnJvcj10fXJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlP3RoaXMubGFzdFJlc3VsdDp0aGlzfSxJbnN0YW50UHJvbWlzZS5wcm90b3R5cGUuY2F0Y2g9ZnVuY3Rpb24oZSl7aWYodGhpcy5sYXN0RXJyb3IpdHJ5e3RoaXMubGFzdFJlc3VsdD1lKHRoaXMubGFzdEVycm9yKSx0aGlzLmxhc3RFcnJvcj12b2lkIDB9Y2F0Y2godCl7dGhpcy5sYXN0UmVzdWx0PXZvaWQgMCx0aGlzLmxhc3RFcnJvcj10fXJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlP3RoaXMubGFzdFJlc3VsdDp0aGlzfSxmdW5jdGlvbihlKXt2YXIgcixzO2Z1bmN0aW9uIGFuaW1hdGlvbkZyYW1lKGUpe3JldHVybiBpLmFuaW1hdGU/IWUmJnI/cjpmdW5jdGlvbih0KXtyZXR1cm4gbj13aW5kb3cuc2V0VGltZW91dCh0LGV8fGgpfTpmdW5jdGlvbihlKXtlKCl9fShzPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpJiYocj1mdW5jdGlvbihlKXtyZXR1cm4gdD1zKGUpfSksZS53aWxsUmVuZGVyTmV4dD1mdW5jdGlvbigpe3JldHVybiEoIXRoaXMuX2J1ZmZlcnx8dGhpcy5fZnJhbWVDb3VudCsxIT09dGhpcy5mcmFtZUJ1ZmZlcigpKX0sZS50dXJ0bGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3R1cnRsZXN9LGUuYWRkVHVydGxlPWZ1bmN0aW9uKGUpe3RoaXMuX3R1cnRsZXMucHVzaChlKX0sZS5yZXNldD1mdW5jdGlvbigpe2lmKHRoaXMuX3R1cnRsZXMpZm9yKHZhciBlPXRoaXMuX3R1cnRsZXMubGVuZ3RoOy0tZT49MDspdGhpcy5fdHVydGxlc1tlXS5yZXNldCgpO3RoaXMuX3R1cnRsZXM9W10sdGhpcy5fZnJhbWVzPVtdLHRoaXMuX2ZyYW1lQ291bnQ9MCx0aGlzLl9idWZmZXI9MSx0aGlzLl9yYXRlPTAsdGhpcy5fYW5pbWF0aW9uRnJhbWU9YW5pbWF0aW9uRnJhbWUoKX0sZS5hZGRGcmFtZT1mdW5jdGlvbihlLHQpe3JldHVybiB0JiYodGhpcy5fZnJhbWVDb3VudCs9MSksdGhpcy5mcmFtZXMoKS5wdXNoKGUpLCFpLmFuaW1hdGV8fHRoaXMuX2J1ZmZlciYmdGhpcy5fZnJhbWVDb3VudD09PXRoaXMuZnJhbWVCdWZmZXIoKT90aGlzLnVwZGF0ZSgpOm5ldyBJbnN0YW50UHJvbWlzZX0sZS5mcmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZnJhbWVzfSxlLmZyYW1lQnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVyblxcXCJudW1iZXJcXFwiPT10eXBlb2YgZSYmKHRoaXMuX2J1ZmZlcj0wfGUsZSYmZTw9dGhpcy5fZnJhbWVDb3VudCk/dGhpcy51cGRhdGUoKTp0aGlzLl9idWZmZXJ9LGUucmVmcmVzaEludGVydmFsPWZ1bmN0aW9uKGUpe3JldHVyblxcXCJudW1iZXJcXFwiPT10eXBlb2YgZSYmKHRoaXMuX3JhdGU9MHxlLHRoaXMuX2FuaW1hdGlvbkZyYW1lPWFuaW1hdGlvbkZyYW1lKGUpKSx0aGlzLl9yYXRlfSxlLnVwZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9mcmFtZXMmJnRoaXMuX2ZyYW1lcy5sZW5ndGg/dGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTpuZXcgSW5zdGFudFByb21pc2V9LGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKCl7dmFyIGUsdCxuPXRoaXMuX2ZyYW1lcyxyPXRoaXMuX2FuaW1hdGlvbkZyYW1lLGk9dGhpcy5fdHVydGxlcyxzPWdldFNjcmVlbigpLnNwcml0ZUxheWVyKCk7cmV0dXJuIHRoaXMuX2ZyYW1lcz1bXSx0aGlzLl9mcmFtZUNvdW50PTAsbmV3IFByb21pc2UoKGZ1bmN0aW9uKGEpe3IoKGZ1bmN0aW9uIHBhaW50KCl7Zm9yKHQ9MDt0PG4ubGVuZ3RoO3QrKyluW3RdJiZuW3RdKCk7Zm9yKGNsZWFyTGF5ZXIocyksdD0wO3Q8aS5sZW5ndGg7dCsrKShlPWlbdF0pLmdldFN0YXRlKCkuc2hvd24mJmRyYXdUdXJ0bGUoZS5nZXRTdGF0ZSgpLHMpO2EoKX0pKX0pKX19KEZyYW1lTWFuYWdlci5wcm90b3R5cGUpLChsPU1vdXNlSGFuZGxlci5wcm90b3R5cGUpLm9uRXZlbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGkscyxhLG89dGhpcy5fbWFuYWdlcnNbZV0sbD10aGlzLl9tYW5hZ2Vycy5tb3VzZW1vdmUsdT0hMTtmdW5jdGlvbiBjb21wdXRlQ29vcmRpbmF0ZXMoKXtpZighdSl7dmFyIGU9Z2V0U2NyZWVuKCksYT1lLnNwcml0ZUxheWVyKCkuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO249dC5jbGllbnRYLWEubGVmdHwwLHI9dC5jbGllbnRZLWEudG9wfDAsaT1uKmUueFNjYWxlK2UubGx4LHM9ciplLnlTY2FsZStlLnVyeSx1PSEwfX1pZigoXFxcIm1vdXNlZG93blxcXCI9PT1lfHxcXFwibW91c2V1cFxcXCI9PT1lKSYmbCYmbC5sZW5ndGgpZm9yKGNvbXB1dGVDb29yZGluYXRlcygpLGE9bC5sZW5ndGg7LS1hPj0wOylsW2FdLnRlc3QobixyLGkscykmJmxbYV0uY2FuTW92ZShcXFwibW91c2Vkb3duXFxcIj09PWUpO2lmKG8mJm8ubGVuZ3RoKWZvcihjb21wdXRlQ29vcmRpbmF0ZXMoKSxhPW8ubGVuZ3RoOy0tYT49MDspKFxcXCJtb3VzZW1vdmVcXFwiPT09ZSYmb1thXS5jYW5Nb3ZlKCkmJm9bYV0udGVzdChuLHIsaSxzKXx8XFxcIm1vdXNlZG93blxcXCI9PT1lJiZvW2FdLnRlc3QobixyLGkscykpJiZvW2FdLnRyaWdnZXIoW2ksc10pfSxsLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5fbWFuYWdlcnM9e319LGwuYWRkTWFuYWdlcj1mdW5jdGlvbihlLHQpe3RoaXMuX21hbmFnZXJzW2VdfHwodGhpcy5fbWFuYWdlcnNbZV09W10pLHRoaXMuX21hbmFnZXJzW2VdLnB1c2godCl9LGZ1bmN0aW9uKGUpe2UucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9oYW5kbGVycz12b2lkIDB9LGUuY2FuTW92ZT1mdW5jdGlvbihlKXtyZXR1cm4hKCF0aGlzLl90YXJnZXR8fCF0aGlzLl90YXJnZXQuaGl0VGVzdCkmJih2b2lkIDAhPT1lJiYodGhpcy5fdGFyZ2V0LmhpdFRlc3QuaGl0PWUpLHRoaXMuX3RhcmdldC5oaXRUZXN0LmhpdCl9LGUudGVzdD1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5fdGFyZ2V0JiZ0aGlzLl90YXJnZXQuaGl0VGVzdD90aGlzLl90YXJnZXQuaGl0VGVzdChlLHQsbixyKTohIXRoaXMuX3RhcmdldH0sZS50cmlnZ2VyPWZ1bmN0aW9uKGUpe3ZhciB0LG49dGhpcy5faGFuZGxlcnM7aWYobiYmbi5sZW5ndGgpZm9yKHQ9MDt0PG4ubGVuZ3RoO3QrKyluW3RdLmFwcGx5KHt9LGUpfSxlLmFkZEhhbmRsZXI9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLl9oYW5kbGVycztpZighdCYmbiYmbi5sZW5ndGgpZm9yKDtuLnNoaWZ0KCk7KTtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZT8obnx8KG49dGhpcy5faGFuZGxlcnM9W10pLG4ucHVzaChlKSk6biYmIW4ubGVuZ3RoJiZ0aGlzLnJlc2V0KCl9fShFdmVudE1hbmFnZXIucHJvdG90eXBlKSxUdXJ0bGUuUkFESUFOUz0yKk1hdGguUEksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gY2lyY2xlUm90YXRlKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5hZGRVcGRhdGUodm9pZCAwLCExLHthbmdsZTp0LHJhZGlhbnM6bn0pfX1mdW5jdGlvbiBjaXJjbGVTZWdtZW50KGUsdCxuLHIsaSxzKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS50cmFuc2xhdGUodCxuLHIsaSxzLCEwKX19ZS5oaXRUZXN0PWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPWdldFNjcmVlbigpLmhpdFRlc3RMYXllcigpO2NsZWFyTGF5ZXIoaSksZHJhd1R1cnRsZSh0aGlzLmdldFN0YXRlKCksaSk7dmFyIHM9aS5nZXRJbWFnZURhdGEoZSx0LDEsMSkuZGF0YTtyZXR1cm4gc1szXXx8c1swXXx8c1sxXXx8c1syXX0sZS5hZGRVcGRhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMuZ2V0U3RhdGUoKSxpPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyxuPzI6Myk7cmV0dXJuIGdldEZyYW1lTWFuYWdlcigpLmFkZEZyYW1lKChmdW5jdGlvbigpe2lmKGUmJmUuYXBwbHkocixpKSxuKWZvcih2YXIgdCBpbiBuKXJbdF09blt0XX0pLHQpfSxlLmdldFN0YXRlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gdGhpcy5fc3RhdGV8fCh0aGlzLl9zdGF0ZT17eDp0aGlzLl94LHk6dGhpcy5feSxhbmdsZTp0aGlzLl9hbmdsZSxyYWRpYW5zOnRoaXMuX3JhZGlhbnMsc2hhcGU6dGhpcy5fc2hhcGUsY29sb3I6dGhpcy5fY29sb3IsZmlsbDp0aGlzLl9maWxsLGZpbGxpbmc6dGhpcy5fZmlsbGluZyxzaXplOnRoaXMuX3NpemUsc3BlZWQ6dGhpcy5fY29tcHV0ZWRfc3BlZWQsZG93bjp0aGlzLl9kb3duLHNob3duOnRoaXMuX3Nob3duLGNvbG9yTW9kZTp0aGlzLl9jb2xvck1vZGUsY29udGV4dDpmdW5jdGlvbigpe3JldHVybiBlLmdldFBhcGVyKCl9fSksdGhpcy5fc3RhdGV9LGUudHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCxuLHIsaSxzKXt2YXIgYT10aGlzO3JldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoZSx0LG4scixpLHMsYSl7dmFyIG8sbD1lLl9jb21wdXRlZF9zcGVlZCx1PWdldFNjcmVlbigpLGM9TWF0aC5hYnModS54U2NhbGUpLGg9TWF0aC5hYnModS55U2NhbGUpLGQ9dCxmPW4sXz1NYXRoLnNxcnQocipyKmMraSppKmgpLGc9bD9NYXRoLnJvdW5kKE1hdGgubWF4KDEsXy9sKSk6MSxwPXIvZyxtPWkvZyx2PWdldEZyYW1lTWFuYWdlcigpLndpbGxSZW5kZXJOZXh0KCk/UHJvbWlzZS5yZXNvbHZlKCk6bmV3IEluc3RhbnRQcm9taXNlLHk9ISghbCYmYSk7Zm9yKGUuYWRkVXBkYXRlKChmdW5jdGlvbigpe3RoaXMuZmlsbGluZyYmdGhpcy5maWxsQnVmZmVyLnB1c2goe3g6dGhpcy54LHk6dGhpcy55LHN0cm9rZTp0aGlzLmRvd24sY29sb3I6dGhpcy5jb2xvcixzaXplOnRoaXMuc2l6ZX0pfSksITEpLG89MDtvPGc7bysrKWQ9dCtwKihvKzEpLGY9bittKihvKzEpLHY9di50aGVuKHBhcnRpYWxUcmFuc2xhdGUoZSxkLGYscyx5KSkscz0hMTtyZXR1cm4gdi50aGVuKChmdW5jdGlvbigpe3JldHVyblt0K3IsbitpXX0pKX0odGhpcyxlLHQsbixyLGkscykudGhlbigoZnVuY3Rpb24oZSl7YS5feD1lWzBdLGEuX3k9ZVsxXX0pKX0sZS5yb3RhdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXM7cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZShlLHQsbixyKXt2YXIgaSxzPWUuX2NvbXB1dGVkX3NwZWVkLGE9bi9lLl9mdWxsQ2lyY2xlKjM2MCxvPXM/TWF0aC5yb3VuZChNYXRoLm1heCgxLE1hdGguYWJzKGEpL3MpKToxLGw9bi9vLHU9e30sYz0hKCFzJiZyKSxoPWdldEZyYW1lTWFuYWdlcigpLndpbGxSZW5kZXJOZXh0KCk/UHJvbWlzZS5yZXNvbHZlKCk6bmV3IEluc3RhbnRQcm9taXNlO2ZvcihpPTA7aTxvO2krKyljYWxjdWxhdGVIZWFkaW5nKGUsdCtsKihpKzEpLHUpLGg9aC50aGVuKHBhcnRpYWxSb3RhdGUoZSx1LmFuZ2xlLHUucmFkaWFucyxjKSk7cmV0dXJuIGgudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gY2FsY3VsYXRlSGVhZGluZyhlLHQrbil9KSl9KHRoaXMsZSx0LG4pLnRoZW4oKGZ1bmN0aW9uKGUpe3IuX2FuZ2xlPWUuYW5nbGUsci5fcmFkaWFucz1lLnJhZGlhbnN9KSl9LGUucXVldWVNb3ZlQnk9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9TWF0aC5jb3MobikqcixzPU1hdGguc2luKG4pKnI7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGUsdCxpLHMsITApfSxlLnF1ZXVlVHVyblRvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKHQlPXRoaXMuX2Z1bGxDaXJjbGUpPDAmJih0Kz10aGlzLl9mdWxsQ2lyY2xlKSx0aGlzLnJvdGF0ZShlLHQtZSl9LGUuZ2V0TWFuYWdlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fbWFuYWdlcnNbZV18fCh0aGlzLl9tYW5hZ2Vyc1tlXT1uZXcgRXZlbnRNYW5hZ2VyKGUsdGhpcykpLHRoaXMuX21hbmFnZXJzW2VdfSxlLmdldFBhcGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhcGVyfHwodGhpcy5fcGFwZXI9Y3JlYXRlTGF5ZXIoMikpfSxlLnJlc2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMuX3g9MCx0aGlzLl95PTAsdGhpcy5fcmFkaWFucz0wLHRoaXMuX2FuZ2xlPTAsdGhpcy5fc2hvd249ITAsdGhpcy5fZG93bj0hMCx0aGlzLl9jb2xvcj1cXFwiYmxhY2tcXFwiLHRoaXMuX2ZpbGw9XFxcImJsYWNrXFxcIix0aGlzLl9zaXplPTEsdGhpcy5fZmlsbGluZz0hMSx0aGlzLl91bmRvQnVmZmVyPVtdLHRoaXMuX3NwZWVkPTMsdGhpcy5fY29tcHV0ZWRfc3BlZWQ9Nix0aGlzLl9jb2xvck1vZGU9MSx0aGlzLl9zdGF0ZT12b2lkIDAsdGhpcy5fbWFuYWdlcnMpdGhpcy5fbWFuYWdlcnNbZV0ucmVzZXQoKTt0aGlzLl9pc1JhZGlhbnM9ITEsdGhpcy5fZnVsbENpcmNsZT0zNjAsdGhpcy5fYnVmZmVyU2l6ZT1cXFwibnVtYmVyXFxcIj09dHlwZW9mIGkuYnVmZmVyU2l6ZT9pLmJ1ZmZlclNpemU6MCxyZW1vdmVMYXllcih0aGlzLl9wYXBlciksdGhpcy5fcGFwZXI9dm9pZCAwfSxlLiRkZWdyZWVzPWZ1bmN0aW9uKGUpe3JldHVybiBlPVxcXCJudW1iZXJcXFwiPT10eXBlb2YgZT9NYXRoLmFicyhlKTozNjAsdGhpcy5faXNSYWRpYW5zPSExLGUmJnRoaXMuX2Z1bGxDaXJjbGU/dGhpcy5fYW5nbGU9dGhpcy5fYW5nbGUvdGhpcy5fZnVsbENpcmNsZSplOnRoaXMuX2FuZ2xlPXRoaXMuX3JhZGlhbnM9MCx0aGlzLl9mdWxsQ2lyY2xlPWUsdGhpcy5hZGRVcGRhdGUodm9pZCAwLCExLHthbmdsZTp0aGlzLl9hbmdsZSxyYWRpYW5zOnRoaXMuX3JhZGlhbnN9KX0sZS4kZGVncmVlcy5taW5BcmdzPTAsZS4kZGVncmVlcy5jb192YXJuYW1lcz1bXFxcImZ1bGxjaXJjbGVcXFwiXSxlLiRkZWdyZWVzLnJldHVyblR5cGU9Zi5GTE9BVCxlLiRyYWRpYW5zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzUmFkaWFuc3x8KHRoaXMuX2lzUmFkaWFucz0hMCx0aGlzLl9hbmdsZT10aGlzLl9yYWRpYW5zLHRoaXMuX2Z1bGxDaXJjbGU9VHVydGxlLlJBRElBTlMpLHRoaXMuX2FuZ2xlfSxlLiRyYWRpYW5zLnJldHVyblR5cGU9Zi5GTE9BVCxlLiRwb3NpdGlvbj1lLiRwb3M9ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy4keGNvcigpLHRoaXMuJHljb3IoKV19LGUuJHBvc2l0aW9uLnJldHVyblR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8oZVswXSksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGVbMV0pXSl9LGUuJHRvd2FyZHM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRDb29yZGluYXRlcyhlLHQpO3JldHVybihNYXRoLlBJK01hdGguYXRhbjIodGhpcy5feS1uLnksdGhpcy5feC1uLngpKSoodGhpcy5fZnVsbENpcmNsZS9UdXJ0bGUuUkFESUFOUyl9LGUuJHRvd2FyZHMuY29fdmFybmFtZXM9W1xcXCJ4XFxcIixcXFwieVxcXCJdLGUuJHRvd2FyZHMubWluQXJncz0xLGUuJHRvd2FyZHMucmV0dXJuVHlwZT1mLkZMT0FULGUuJGRpc3RhbmNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49Z2V0Q29vcmRpbmF0ZXMoZSx0KSxyPW4ueC10aGlzLl94LGk9bi55LXRoaXMuX3k7cmV0dXJuIE1hdGguc3FydChyKnIraSppKX0sZS4kZGlzdGFuY2UuY29fdmFybmFtZXM9W1xcXCJ4XFxcIixcXFwieVxcXCJdLGUuJGRpc3RhbmNlLm1pbkFyZ3M9MSxlLiRkaXN0YW5jZS5yZXR1cm5UeXBlPWYuRkxPQVQsZS4kaGVhZGluZz1mdW5jdGlvbigpe3JldHVybiBNYXRoLmFicyh0aGlzLl9hbmdsZSk8MWUtMTM/MDp0aGlzLl9hbmdsZX0sZS4kaGVhZGluZy5yZXR1cm5UeXBlPWYuRkxPQVQsZS4keGNvcj1mdW5jdGlvbigpe3JldHVybiBNYXRoLmFicyh0aGlzLl94KTwxZS0xMz8wOnRoaXMuX3h9LGUuJHhjb3IucmV0dXJuVHlwZT1mLkZMT0FULGUuJHljb3I9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5hYnModGhpcy5feSk8MWUtMTM/MDp0aGlzLl95fSxlLiR5Y29yLnJldHVyblR5cGU9Zi5GTE9BVCxlLiRmb3J3YXJkPWUuJGZkPWZ1bmN0aW9uKGUpe3JldHVybiBwdXNoVW5kbyh0aGlzKSx0aGlzLnF1ZXVlTW92ZUJ5KHRoaXMuX3gsdGhpcy5feSx0aGlzLl9yYWRpYW5zLGUpfSxlLiRmb3J3YXJkLmNvX3Zhcm5hbWVzPWUuJGZkLmNvX3Zhcm5hbWVzPVtcXFwiZGlzdGFuY2VcXFwiXSxlLiR1bmRvPWZ1bmN0aW9uKCl7IWZ1bmN0aW9uIHBvcFVuZG8oZSl7dmFyIHQ7aWYoZS5fYnVmZmVyU2l6ZSYmZS5fdW5kb0J1ZmZlciYmKHQ9ZS5fdW5kb0J1ZmZlci5wb3AoKSkpe2Zvcih2YXIgbiBpbiB0KVxcXCJpbWFnZVxcXCIhPT1uJiZcXFwiZmlsbEJ1ZmZlclxcXCIhPT1uJiYoZVtcXFwiX1xcXCIrbl09dFtuXSk7ZS5hZGRVcGRhdGUoKGZ1bmN0aW9uKCl7dC5pbWFnZSYmKGcuc3JjPXQuaW1hZ2UpLGNsZWFyTGF5ZXIodGhpcy5jb250ZXh0KCksITEsZyksZGVsZXRlIHQuaW1hZ2V9KSwhMCx0KX19KHRoaXMpfSxlLiR1bmRvYnVmZmVyZW50cmllcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91bmRvQnVmZmVyLmxlbmd0aH0sZS4kc2V0dW5kb2J1ZmZlcj1mdW5jdGlvbihlKXt0aGlzLl9idWZmZXJTaXplPVxcXCJudW1iZXJcXFwiPT10eXBlb2YgZT9NYXRoLm1pbihNYXRoLmFicyhlKSwxZTMpOjB9LGUuJHNldHVuZG9idWZmZXIuY29fdmFybmFtZXM9W1xcXCJzaXplXFxcIl0sZS4kYmFja3dhcmQ9ZS4kYmFjaz1lLiRiaz1mdW5jdGlvbihlKXtyZXR1cm4gcHVzaFVuZG8odGhpcyksdGhpcy5xdWV1ZU1vdmVCeSh0aGlzLl94LHRoaXMuX3ksdGhpcy5fcmFkaWFucywtZSl9LGUuJGJhY2t3YXJkLmNvX3Zhcm5hbWVzPWUuJGJhY2suY29fdmFybmFtZXM9ZS4kYmsuY29fdmFybmFtZXM9W1xcXCJkaXN0YW5jZVxcXCJdLGUuJGdvdG9fJHJ3JD1lLiRzZXRwb3M9ZS4kc2V0cG9zaXRpb249ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRDb29yZGluYXRlcyhlLHQpO3JldHVybiBwdXNoVW5kbyh0aGlzKSx0aGlzLnRyYW5zbGF0ZSh0aGlzLl94LHRoaXMuX3ksbi54LXRoaXMuX3gsbi55LXRoaXMuX3ksITApfSxlLiRnb3RvXyRydyQuY29fdmFybmFtZXM9ZS4kc2V0cG9zLmNvX3Zhcm5hbWVzPWUuJHNldHBvc2l0aW9uLmNvX3Zhcm5hbWVzPVtcXFwieFxcXCIsXFxcInlcXFwiXSxlLiRnb3RvXyRydyQubWluQXJncz1lLiRzZXRwb3MubWluQXJncz1lLiRzZXRwb3NpdGlvbi5taW5BcmdzPTEsZS4kc2V0eD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50cmFuc2xhdGUodGhpcy5feCx0aGlzLl95LGUtdGhpcy5feCwwLCEwKX0sZS4kc2V0eC5jb192YXJuYW1lcz1bXFxcInhcXFwiXSxlLiRzZXR5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZSh0aGlzLl94LHRoaXMuX3ksMCxlLXRoaXMuX3ksITApfSxlLiRzZXR5LmNvX3Zhcm5hbWVzPVtcXFwieVxcXCJdLGUuJGhvbWU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpcy5fYW5nbGU7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLGUudHJhbnNsYXRlKHRoaXMuX3gsdGhpcy5feSwtdGhpcy5feCwtdGhpcy5feSwhMCkudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIGUucXVldWVUdXJuVG8odCwwKX0pKS50aGVuKChmdW5jdGlvbihlKXt9KSl9LGUuJHJpZ2h0PWUuJHJ0PWZ1bmN0aW9uKGUpe3JldHVybiBwdXNoVW5kbyh0aGlzKSx0aGlzLnJvdGF0ZSh0aGlzLl9hbmdsZSwtZSl9LGUuJHJpZ2h0LmNvX3Zhcm5hbWVzPWUuJHJ0LmNvX3Zhcm5hbWVzPVtcXFwiYW5nbGVcXFwiXSxlLiRsZWZ0PWUuJGx0PWZ1bmN0aW9uKGUpe3JldHVybiBwdXNoVW5kbyh0aGlzKSx0aGlzLnJvdGF0ZSh0aGlzLl9hbmdsZSxlKX0sZS4kbGVmdC5jb192YXJuYW1lcz1lLiRsdC5jb192YXJuYW1lcz1bXFxcImFuZ2xlXFxcIl0sZS4kc2V0aGVhZGluZz1lLiRzZXRoPWZ1bmN0aW9uKGUpe3JldHVybiBwdXNoVW5kbyh0aGlzKSx0aGlzLnF1ZXVlVHVyblRvKHRoaXMuX2FuZ2xlLGUpfSxlLiRzZXRoZWFkaW5nLmNvX3Zhcm5hbWVzPWUuJHNldGguY29fdmFybmFtZXM9W1xcXCJhbmdsZVxcXCJdLGUuJGNpcmNsZT1mdW5jdGlvbihlLHQsbil7dmFyIHIsaSxzLGEsbyxsLHUsYyxoLGQ9dGhpcyxmPXRoaXMuX3gsXz10aGlzLl95LGc9dGhpcy5fYW5nbGUscD17fSxtPTEvZ2V0U2NyZWVuKCkubGluZVNjYWxlLHY9ITA7Zm9yKHB1c2hVbmRvKHRoaXMpLHZvaWQgMD09PXQmJih0PWQuX2Z1bGxDaXJjbGUpLHZvaWQgMD09PW4mJihpPU1hdGguYWJzKHQpL2QuX2Z1bGxDaXJjbGUsbj0xKyhNYXRoLm1pbigxMStNYXRoLmFicyhlKm0pLzYsNTkpKml8MCkpLGE9LjUqKHM9dC9uKSxvPTIqZSpNYXRoLnNpbihzKk1hdGguUEkvZC5fZnVsbENpcmNsZSksZTwwPyhvPS1vLHM9LXMsYT0tYSxyPWctdCk6cj1nK3QsaD1nZXRGcmFtZU1hbmFnZXIoKS53aWxsUmVuZGVyTmV4dCgpP1Byb21pc2UucmVzb2x2ZSgpOm5ldyBJbnN0YW50UHJvbWlzZSxnKz1hLGw9MDtsPG47bCsrKWNhbGN1bGF0ZUhlYWRpbmcoZCxnK3MqbCxwKSx1PU1hdGguY29zKHAucmFkaWFucykqbyxjPU1hdGguc2luKHAucmFkaWFucykqbyxoPWgudGhlbihjaXJjbGVSb3RhdGUoZCxwLmFuZ2xlLHAucmFkaWFucykpLnRoZW4oY2lyY2xlU2VnbWVudChkLGYsXyx1LGMsdikpLGYrPXUsXys9Yyx2PSExO3JldHVybiBoLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGNhbGN1bGF0ZUhlYWRpbmcoZCxyLHApLGQuX2FuZ2xlPXAuYW5nbGUsZC5fcmFkaWFucz1wLnJhZGlhbnMsZC5hZGRVcGRhdGUodm9pZCAwLCEwLHApfSkpfSxlLiRjaXJjbGUuY29fdmFybmFtZXM9W1xcXCJyYWRpdXNcXFwiLFxcXCJleHRlbnRcXFwiLFxcXCJzdGVwc1xcXCJdLGUuJGNpcmNsZS5taW5BcmdzPTEsZS4kcGVudXA9ZS4kdXA9ZS4kcHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZG93bj0hMSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsITEse2Rvd246ITF9KX0sZS4kcGVuZG93bj1lLiRkb3duPWUuJHBkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rvd249ITAsdGhpcy5hZGRVcGRhdGUodm9pZCAwLCExLHtkb3duOiEwfSl9LGUuJGlzZG93bj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kb3dufSxlLiRzcGVlZD1mdW5jdGlvbihlKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGUpcmV0dXJuIHRoaXMuX3NwZWVkO2NvbnN0IHQ9e2Zhc3Rlc3Q6MCxmYXN0OjEwLG5vcm1hbDo2LHNsb3c6MyxzbG93ZXN0OjF9O2lmKGUgaW4gdCYmKGU9dFtlXSksXFxcIm51bWJlclxcXCIhPXR5cGVvZiBlKXtpZihcXFwic3RyaW5nXFxcIj09dHlwZW9mIGUpe2NvbnN0IGU9T2JqZWN0LmtleXModCkuam9pbihcXFwiLCBcXFwiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInNwZWVkIHN0cmluZyBleHBlY3RlZCBvbmUgb2YgXFxcIitlKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInNwZWVkIGV4cGVjdGVkIGEgc3RyaW5nIG9yIG51bWJlclxcXCIpfXJldHVybiBlPWU+LjUmJmU8MTAuNT9Tay5idWlsdGluLmFzbnVtJChTay5idWlsdGluLnJvdW5kKFNrLmJ1aWx0aW4uYXNzayQoZSkpKTowLHRoaXMuX3NwZWVkPWUsdGhpcy5fY29tcHV0ZWRfc3BlZWQ9MiplLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCwhMSx7c3BlZWQ6dGhpcy5fY29tcHV0ZWRfc3BlZWR9KX0sZS4kc3BlZWQubWluQXJncz0wLGUuJHNwZWVkLmNvX3Zhcm5hbWVzPVtcXFwic3BlZWRcXFwiXSxlLiRwZW5jb2xvcj1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdm9pZCAwIT09ZT8odGhpcy5fY29sb3I9Y3JlYXRlQ29sb3IodGhpcy5fY29sb3JNb2RlLGUsdCxuLHIpLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCx0aGlzLl9zaG93bix7Y29sb3I6dGhpcy5fY29sb3J9KSk6aGV4VG9SR0IodGhpcy5fY29sb3IpfSxlLiRwZW5jb2xvci5jb192YXJuYW1lcz1bXFxcInJcXFwiLFxcXCJnXFxcIixcXFwiYlxcXCIsXFxcImFcXFwiXSxlLiRwZW5jb2xvci5taW5BcmdzPTAsZS4kcGVuY29sb3IucmV0dXJuVHlwZT1mLkNPTE9SLGUuJGZpbGxjb2xvcj1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdm9pZCAwIT09ZT8odGhpcy5fZmlsbD1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsZSx0LG4sciksdGhpcy5hZGRVcGRhdGUodm9pZCAwLHRoaXMuX3Nob3duLHtmaWxsOnRoaXMuX2ZpbGx9KSk6aGV4VG9SR0IodGhpcy5fZmlsbCl9LGUuJGZpbGxjb2xvci5jb192YXJuYW1lcz1bXFxcInJcXFwiLFxcXCJnXFxcIixcXFwiYlxcXCIsXFxcImFcXFwiXSxlLiRmaWxsY29sb3IubWluQXJncz0wLGUuJGZpbGxjb2xvci5yZXR1cm5UeXBlPWYuQ09MT1IsZS4kY29sb3I9ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHZvaWQgMCE9PWU/KHZvaWQgMD09PXR8fHZvaWQgMCE9PW4/KHRoaXMuX2NvbG9yPWNyZWF0ZUNvbG9yKHRoaXMuX2NvbG9yTW9kZSxlLHQsbixyKSx0aGlzLl9maWxsPXRoaXMuX2NvbG9yKToodGhpcy5fY29sb3I9Y3JlYXRlQ29sb3IodGhpcy5fY29sb3JNb2RlLGUpLHRoaXMuX2ZpbGw9Y3JlYXRlQ29sb3IodGhpcy5fY29sb3JNb2RlLHQpKSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsdGhpcy5fc2hvd24se2NvbG9yOnRoaXMuX2NvbG9yLGZpbGw6dGhpcy5fZmlsbH0pKTpbdGhpcy4kcGVuY29sb3IoKSx0aGlzLiRmaWxsY29sb3IoKV19LGUuJGNvbG9yLm1pbkFyZ3M9MCxlLiRjb2xvci5jb192YXJuYW1lcz1bXFxcImNvbG9yXFxcIixcXFwiZmlsbFxcXCIsXFxcImJcXFwiLFxcXCJhXFxcIl0sZS4kY29sb3IucmV0dXJuVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW2YuQ09MT1IoZVswXSksZi5DT0xPUihlWzFdKV0pfSxlLiRmaWxsPWZ1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpe2lmKChlPSEhZSk9PT10aGlzLl9maWxsaW5nKXJldHVybjtyZXR1cm4gdGhpcy5fZmlsbGluZz1lLGU/KHB1c2hVbmRvKHRoaXMpLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCwhMSx7ZmlsbGluZzohMCxmaWxsQnVmZmVyOlt7eDp0aGlzLl94LHk6dGhpcy5feX1dfSkpOihwdXNoVW5kbyh0aGlzKSx0aGlzLmFkZFVwZGF0ZSgoZnVuY3Rpb24oKXt0aGlzLmZpbGxCdWZmZXIucHVzaCh0aGlzKSxkcmF3RmlsbC5jYWxsKHRoaXMpfSksITAse2ZpbGxpbmc6ITEsZmlsbEJ1ZmZlcjp2b2lkIDB9KSl9cmV0dXJuIHRoaXMuX2ZpbGxpbmd9LGUuJGZpbGwuY29fdmFybmFtZXM9W1xcXCJmbGFnXFxcIl0sZS4kZmlsbC5taW5BcmdzPTAsZS4kYmVnaW5fZmlsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRmaWxsKCEwKX0sZS4kZW5kX2ZpbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZmlsbCghMSl9LGUuJHN0YW1wPWZ1bmN0aW9uKCl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMuYWRkVXBkYXRlKChmdW5jdGlvbigpe2RyYXdUdXJ0bGUodGhpcyx0aGlzLmNvbnRleHQoKSl9KSwhMCl9LGUuJGRvdD1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBwdXNoVW5kbyh0aGlzKSxlPVxcXCJudW1iZXJcXFwiPT10eXBlb2YoZT1Tay5idWlsdGluLmFzbnVtJChlKSk/TWF0aC5tYXgoMSwwfE1hdGguYWJzKGUpKTpNYXRoLm1heCh0aGlzLl9zaXplKzQsMip0aGlzLl9zaXplKSx0PXZvaWQgMCE9PXQ/Y3JlYXRlQ29sb3IodGhpcy5fY29sb3JNb2RlLHQsbixyLGkpOnRoaXMuX2NvbG9yLHRoaXMuYWRkVXBkYXRlKGRyYXdEb3QsITAsdm9pZCAwLGUsdCl9LGUuJGRvdC5jb192YXJuYW1lcz1bXFxcInNpemVcXFwiLFxcXCJjb2xvclxcXCIsXFxcImdcXFwiLFxcXCJiXFxcIixcXFwiYVxcXCJdLGUuJHdyaXRlPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLHMsYSxvLGwsdT10aGlzO3JldHVybiBwdXNoVW5kbyh0aGlzKSxlPVN0cmluZyhlKSxyJiZyLmNvbnN0cnVjdG9yPT09QXJyYXkmJihzPVxcXCJzdHJpbmdcXFwiPT10eXBlb2YgclswXT9yWzBdOlxcXCJBcmlhbFxcXCIsYT1TdHJpbmcoclsxXXx8XFxcIjEycHRcXFwiKSxvPVxcXCJzdHJpbmdcXFwiPT10eXBlb2YgclsyXT9yWzJdOlxcXCJub3JtYWxcXFwiLC9eXFxcXGQrJC8udGVzdChhKSYmKGErPVxcXCJwdFxcXCIpLHI9W28sYSxzXS5qb2luKFxcXCIgXFxcIikpLG58fChuPVxcXCJsZWZ0XFxcIiksaT10aGlzLmFkZFVwZGF0ZShkcmF3VGV4dCwhMCx2b2lkIDAsZSxuLHIpLCF0fHxcXFwibGVmdFxcXCIhPT1uJiZcXFwiY2VudGVyXFxcIiE9PW58fChsPWZ1bmN0aW9uIG1lYXN1cmVUZXh0KGUsdCl7cmV0dXJuIHQmJihwLmZvbnQ9dCkscC5tZWFzdXJlVGV4dChlKS53aWR0aH0oZSxyKSxcXFwiY2VudGVyXFxcIj09PW4mJihsLz0yKSxpPWkudGhlbigoZnVuY3Rpb24oKXt2YXIgZT11LmdldFN0YXRlKCk7cmV0dXJuIHUudHJhbnNsYXRlKGUueCxlLnksbCwwLCEwKX0pKSksaX0sZS4kd3JpdGUuY29fdmFybmFtZXM9W1xcXCJtZXNzYWdlXFxcIixcXFwibW92ZVxcXCIsXFxcImFsaWduXFxcIixcXFwiZm9udFxcXCJdLGUuJHdyaXRlLm1pbkFyZ3M9MSxlLiRwZW5zaXplPWUuJHdpZHRoPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lPyh0aGlzLl9zaXplPWUsdGhpcy5hZGRVcGRhdGUodm9pZCAwLHRoaXMuX3Nob3duLHtzaXplOmV9KSk6dGhpcy5fc2l6ZX0sZS4kcGVuc2l6ZS5taW5BcmdzPWUuJHdpZHRoLm1pbkFyZ3M9MCxlLiRwZW5zaXplLmNvX3Zhcm5hbWVzPWUuJHdpZHRoLmNvX3Zhcm5hbWVzPVtcXFwid2lkdGhcXFwiXSxlLiRzaG93dHVydGxlPWUuJHN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Nob3duPSEwLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCwhMCx7c2hvd246ITB9KX0sZS4kaGlkZXR1cnRsZT1lLiRodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaG93bj0hMSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsITAse3Nob3duOiExfSl9LGUuJGlzdmlzaWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaG93bn0sZS4kc2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmRbZV0/KHRoaXMuX3NoYXBlPWUsdGhpcy5hZGRVcGRhdGUodm9pZCAwLHRoaXMuX3Nob3duLHtzaGFwZTplfSkpOnRoaXMuX3NoYXBlfSxlLiRzaGFwZS5taW5BcmdzPTAsZS4kc2hhcGUuY29fdmFybmFtZXM9W1xcXCJuYW1lXFxcIl0sZS4kd2luZG93X3dpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjcmVlbi4kd2luZG93X3dpZHRoKCl9LGUuJHdpbmRvd19oZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NyZWVuLiR3aW5kb3dfaGVpZ2h0KCl9LGUuJHRyYWNlcj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9zY3JlZW4uJHRyYWNlcihlLHQpfSxlLiR0cmFjZXIubWluQXJncz0wLGUuJHRyYWNlci5jb192YXJuYW1lcz1bXFxcIm5cXFwiLFxcXCJkZWxheVxcXCJdLGUuJHVwZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JlZW4uJHVwZGF0ZSgpfSxlLiRkZWxheT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fc2NyZWVuLiRkZWxheShlKX0sZS4kZGVsYXkubWluQXJncz0wLGUuJGRlbGF5LmNvX3Zhcm5hbWVzPVtcXFwiZGVsYXlcXFwiXSxlLiRyZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc2V0KCksdGhpcy4kY2xlYXIoKX0sZS4kbWFpbmxvb3A9ZS4kZG9uZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JlZW4uJG1haW5sb29wKCl9LGUuJGNsZWFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWRkVXBkYXRlKChmdW5jdGlvbigpe2NsZWFyTGF5ZXIodGhpcy5jb250ZXh0KCkpfSksITApfSxlLiRkb3QubWluQXJncz0wLGUuJG9uY2xpY2s9ZnVuY3Rpb24oZSx0LG4pe3RoaXMuZ2V0TWFuYWdlcihcXFwibW91c2Vkb3duXFxcIikuYWRkSGFuZGxlcihlLG4pfSxlLiRvbmNsaWNrLm1pbkFyZ3M9MSxlLiRvbmNsaWNrLmNvX3Zhcm5hbWVzPVtcXFwibWV0aG9kXFxcIixcXFwiYnRuXFxcIixcXFwiYWRkXFxcIl0sZS4kb25yZWxlYXNlPWZ1bmN0aW9uKGUsdCxuKXt0aGlzLmdldE1hbmFnZXIoXFxcIm1vdXNldXBcXFwiKS5hZGRIYW5kbGVyKGUsbil9LGUuJG9ucmVsZWFzZS5taW5BcmdzPTEsZS4kb25yZWxlYXNlLmNvX3Zhcm5hbWVzPVtcXFwibWV0aG9kXFxcIixcXFwiYnRuXFxcIixcXFwiYWRkXFxcIl0sZS4kb25kcmFnPWZ1bmN0aW9uKGUsdCxuKXt0aGlzLmdldE1hbmFnZXIoXFxcIm1vdXNlbW92ZVxcXCIpLmFkZEhhbmRsZXIoZSxuKX0sZS4kb25kcmFnLm1pbkFyZ3M9MSxlLiRvbmRyYWcuY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXSxlLiRnZXRzY3JlZW49ZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHUuU2NyZWVuKX0sZS4kZ2V0c2NyZWVuLmlzU2s9ITAsZS4kY2xvbmU9ZnVuY3Rpb24oKXt2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkodS5UdXJ0bGUpO3JldHVybiBlLmluc3RhbmNlLl94PXRoaXMuX3gsZS5pbnN0YW5jZS5feT10aGlzLl95LGUuaW5zdGFuY2UuX2FuZ2xlPXRoaXMuX2FuZ2xlLGUuaW5zdGFuY2UuX3JhZGlhbnM9dGhpcy5fcmFkaWFucyxlLmluc3RhbmNlLl9zaGFwZT10aGlzLl9zaGFwZSxlLmluc3RhbmNlLl9jb2xvcj10aGlzLl9jb2xvcixlLmluc3RhbmNlLl9maWxsPXRoaXMuX2ZpbGwsZS5pbnN0YW5jZS5fZmlsbGluZz10aGlzLl9maWxsaW5nLGUuaW5zdGFuY2UuX3NpemU9dGhpcy5fc2l6ZSxlLmluc3RhbmNlLl9jb21wdXRlZF9zcGVlZD10aGlzLl9jb21wdXRlZF9zcGVlZCxlLmluc3RhbmNlLl9kb3duPXRoaXMuX2Rvd24sZS5pbnN0YW5jZS5fc2hvd249dGhpcy5fc2hvd24sZS5pbnN0YW5jZS5fY29sb3JNb2RlPXRoaXMuX2NvbG9yTW9kZSxlLmluc3RhbmNlLl9pc1JhZGlhbnM9dGhpcy5faXNSYWRpYW5zLGUuaW5zdGFuY2UuX2Z1bGxDaXJjbGU9dGhpcy5fZnVsbENpcmNsZSxlLmluc3RhbmNlLl9idWZmZXJTaXplPXRoaXMuX2J1ZmZlclNpemUsZS5pbnN0YW5jZS5fdW5kb0J1ZmZlcj10aGlzLl91bmRvQnVmZmVyLGUuX2Nsb25lZEZyb209dGhpcyxlfSxlLiRjbG9uZS5yZXR1cm5UeXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSxlLiRnZXR0dXJ0bGU9ZS4kZ2V0cGVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2tJbnN0YW5jZX0sZS4kZ2V0dHVydGxlLmlzU2s9ITB9KFR1cnRsZS5wcm90b3R5cGUpLGZ1bmN0aW9uKGUpe2Uuc3ByaXRlTGF5ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ByaXRlc3x8KHRoaXMuX3Nwcml0ZXM9Y3JlYXRlTGF5ZXIoMykpfSxlLmJnTGF5ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYmFja2dyb3VuZHx8KHRoaXMuX2JhY2tncm91bmQ9Y3JlYXRlTGF5ZXIoMSkpfSxlLmhpdFRlc3RMYXllcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9oaXRUZXN0fHwodGhpcy5faGl0VGVzdD1jcmVhdGVMYXllcigwLCEwKSl9LGUuZ2V0TWFuYWdlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fbWFuYWdlcnNbZV18fCh0aGlzLl9tYW5hZ2Vyc1tlXT1uZXcgRXZlbnRNYW5hZ2VyKGUsdGhpcykpLHRoaXMuX21hbmFnZXJzW2VdfSxlLnJlc2V0PWZ1bmN0aW9uKCl7dmFyIGU7Zm9yKGUgaW4gdGhpcy5fa2V5TGlzdGVuZXJzPXZvaWQgMCx0aGlzLl9rZXlMb2dnZXIpd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5fa2V5TG9nZ2VyW2VdKSx3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2tleUxvZ2dlcltlXSksZGVsZXRlIHRoaXMuX2tleUxvZ2dlcltlXTtmb3IoZSBpbiB0aGlzLl9rZXlEb3duTGlzdGVuZXImJihnZXRUYXJnZXQoKS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJrZXlkb3duXFxcIix0aGlzLl9rZXlEb3duTGlzdGVuZXIpLHRoaXMuX2tleURvd25MaXN0ZW5lcj12b2lkIDApLHRoaXMuX2tleVVwTGlzdGVuZXImJihnZXRUYXJnZXQoKS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJrZXl1cFxcXCIsdGhpcy5fa2V5VXBMaXN0ZW5lciksdGhpcy5fa2V5VXBMaXN0ZW5lcj12b2lkIDApLHRoaXMuX3RpbWVyJiYod2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lciksdGhpcy5fdGltZXI9dm9pZCAwKSx0aGlzLl9tYW5hZ2Vycyl0aGlzLl9tYW5hZ2Vyc1tlXS5yZXNldCgpO3RoaXMuX21vZGU9XFxcInN0YW5kYXJkXFxcIixyZW1vdmVMYXllcih0aGlzLl9zcHJpdGVzKSx0aGlzLl9zcHJpdGVzPXZvaWQgMCxyZW1vdmVMYXllcih0aGlzLl9iYWNrZ3JvdW5kKSx0aGlzLl9iYWNrZ3JvdW5kPXZvaWQgMH0sZS5zZXRVcFdvcmxkPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXRoaXM7aS5sbHg9ZSxpLmxseT10LGkudXJ4PW4saS51cnk9cixpLnhTY2FsZT0obi1lKS9nZXRXaWR0aCgpLGkueVNjYWxlPS0xKihyLXQpL2dldEhlaWdodCgpLGkubGluZVNjYWxlPU1hdGgubWluKE1hdGguYWJzKGkueFNjYWxlKSxNYXRoLmFicyhpLnlTY2FsZSkpfSxlLiRzZXR1cD1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gaXNOYU4ocGFyc2VGbG9hdChlKSkmJihlPWdldFdpZHRoKCkpLGlzTmFOKHBhcnNlRmxvYXQodCkpJiYodD1nZXRIZWlnaHQoKSksZTw9MSYmKGU9Z2V0V2lkdGgoKSplKSx0PD0xJiYodD1nZXRIZWlnaHQoKSp0KSx0aGlzLl93aWR0aD1lLHRoaXMuX2hlaWdodD10LHRoaXMuX3hPZmZzZXQ9dm9pZCAwPT09bnx8aXNOYU4ocGFyc2VJbnQobikpPzA6cGFyc2VJbnQobiksdGhpcy5feU9mZnNldD12b2lkIDA9PT1yfHxpc05hTihwYXJzZUludChyKSk/MDpwYXJzZUludChyKSxcXFwid29ybGRcXFwiPT09dGhpcy5fbW9kZT90aGlzLl9zZXR3b3JsZGNvb3JkaW5hdGVzKHRoaXMubGx4LHRoaXMubGx5LHRoaXMudXJ4LHRoaXMudXJ5KTp0aGlzLl9zZXR3b3JsZGNvb3JkaW5hdGVzKC1lLzIsLXQvMixlLzIsdC8yKX0sZS4kc2V0dXAubWluQXJncz0wLGUuJHNldHVwLmNvX3Zhcm5hbWVzPVtcXFwid2lkdGhcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJzdGFydHhcXFwiLFxcXCJzdGFydHlcXFwiXSxlLiRyZWdpc3Rlcl9zaGFwZT1lLiRhZGRzaGFwZT1mdW5jdGlvbihlLHQpe2lmKCF0KXJldHVybiBnZXRBc3NldChlKS50aGVuKChmdW5jdGlvbih0KXtkW2VdPXR9KSk7ZFtlXT10fSxlLiRyZWdpc3Rlcl9zaGFwZS5taW5BcmdzPTEsZS4kcmVnaXN0ZXJfc2hhcGUuY29fdmFybmFtZXM9W1xcXCJuYW1lXFxcIixcXFwic2hhcGVcXFwiXSxlLiRnZXRzaGFwZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXMoZCl9LGUuJHRyYWNlcj1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDAhPT1lfHx2b2lkIDAhPT10PyhcXFwibnVtYmVyXFxcIj09dHlwZW9mIHQmJih0aGlzLl9kZWxheT10LGdldEZyYW1lTWFuYWdlcigpLnJlZnJlc2hJbnRlcnZhbCh0KSksXFxcIm51bWJlclxcXCI9PXR5cGVvZiBlPyh0aGlzLl9mcmFtZXM9ZSxnZXRGcmFtZU1hbmFnZXIoKS5mcmFtZUJ1ZmZlcihlKSk6dm9pZCAwKTp0aGlzLl9mcmFtZXN9LGUuJHRyYWNlci5jb192YXJuYW1lcz1bXFxcImZyYW1lc1xcXCIsXFxcImRlbGF5XFxcIl0sZS4kdHJhY2VyLm1pbkFyZ3M9MCxlLiRkZWxheT1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZT90aGlzLiR0cmFjZXIodm9pZCAwLGUpOnZvaWQgMD09PXRoaXMuX2RlbGF5P2g6dGhpcy5fZGVsYXl9LGUuJGRlbGF5LmNvX3Zhcm5hbWVzPVtcXFwiZGVsYXlcXFwiXSxlLl9zZXR3b3JsZGNvb3JkaW5hdGVzPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBnZXRGcmFtZU1hbmFnZXIoKS50dXJ0bGVzKCksdGhpcy5zZXRVcFdvcmxkKGUsdCxuLHIpLHRoaXMuX3Nwcml0ZXMmJmFwcGx5V29ybGQodGhpcyx0aGlzLl9zcHJpdGVzKSx0aGlzLl9iYWNrZ3JvdW5kJiZhcHBseVdvcmxkKHRoaXMsdGhpcy5fYmFja2dyb3VuZCksdGhpcy4kY2xlYXIoKX0sZS4kc2V0d29ybGRjb29yZGluYXRlcz1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5fbW9kZT1cXFwid29ybGRcXFwiLHRoaXMuX3NldHdvcmxkY29vcmRpbmF0ZXMoZSx0LG4scil9LGUuJHNldHdvcmxkY29vcmRpbmF0ZXMuY29fdmFybmFtZXM9W1xcXCJsbHhcXFwiLFxcXCJsbHlcXFwiLFxcXCJ1cnhcXFwiLFxcXCJ1cnlcXFwiXSxlLm1pbkFyZ3M9NCxlLiRjbGVhcj1lLiRjbGVhcnNjcmVlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc2V0KCksdGhpcy4kcmVzZXQoKX0sZS4kdXBkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGdldEZyYW1lTWFuYWdlcigpLnVwZGF0ZSgpfSxlLiRyZXNldD1lLiRyZXNldHNjcmVlbj1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1nZXRGcmFtZU1hbmFnZXIoKS50dXJ0bGVzKCk7cmV0dXJuIGdldEZyYW1lTWFuYWdlcigpLmFkZEZyYW1lKChmdW5jdGlvbigpe2FwcGx5V29ybGQoZSxlLl9zcHJpdGVzKSxhcHBseVdvcmxkKGUsZS5fYmFja2dyb3VuZCk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdFtuXS5yZXNldCgpLGFwcGx5V29ybGQoZSx0W25dLl9wYXBlcil9KSwhMCl9LGUuJHdpbmRvd193aWR0aD1mdW5jdGlvbigpe3JldHVybiBnZXRXaWR0aCgpfSxlLiR3aW5kb3dfaGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIGdldEhlaWdodCgpfSxlLiRkZWxheS5taW5BcmdzPTAsZS4kdHVydGxlcz1mdW5jdGlvbigpe3JldHVybiBnZXRGcmFtZU1hbmFnZXIoKS50dXJ0bGVzKCl9LGUuJHR1cnRsZXMucmV0dXJuVHlwZT1mLlRVUlRMRV9MSVNULGUuJGJncGljPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBlPyh0PXRoaXMsZ2V0QXNzZXQoZSkudGhlbigoZnVuY3Rpb24oZSl7Y2xlYXJMYXllcih0LmJnTGF5ZXIoKSx2b2lkIDAsZSl9KSkpOnRoaXMuX2JncGljfSxlLiRiZ3BpYy5taW5BcmdzPTAsZS4kYmdwaWMuY29fdmFybmFtZXM9W1xcXCJuYW1lXFxcIl0sZS4kYmdjb2xvcj1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdm9pZCAwIT09ZT8odGhpcy5fYmdjb2xvcj1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsZSx0LG4sciksdm9pZCBjbGVhckxheWVyKHRoaXMuYmdMYXllcigpLHRoaXMuX2JnY29sb3IpKTpoZXhUb1JHQih0aGlzLl9iZ2NvbG9yKX0sZS4kYmdjb2xvci5taW5BcmdzPTAsZS4kYmdjb2xvci5jb192YXJuYW1lcz1bXFxcImNvbG9yXFxcIixcXFwiZ1xcXCIsXFxcImJcXFwiLFxcXCJhXFxcIl0sZS4kYmdjb2xvci5yZXR1cm5UeXBlPWYuQ09MT1IsZS4kY29sb3Jtb2RlPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lPyh0aGlzLl9jb2xvck1vZGU9MjU1PT09ZT8yNTU6MSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsdGhpcy5fc2hvd24se2NvbG9yTW9kZTp0aGlzLl9jb2xvck1vZGV9KSk6dGhpcy5fY29sb3JNb2RlfSxlLiRjb2xvcm1vZGUubWluQXJncz0wLGUuJGNvbG9ybW9kZS5jb192YXJuYW1lcz1bXFxcImNtb2RlXFxcIl0sZS4kY29sb3Jtb2RlLnJldHVyblR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIDI1NT09PWU/bmV3IFNrLmJ1aWx0aW4uaW50XygyNTUpOm5ldyBTay5idWlsdGluLmZsb2F0XygxKX0sZS4kbWFpbmxvb3A9ZS4kZG9uZT1mdW5jdGlvbigpe30sZS4kYnllPWZ1bmN0aW9uKCl7cmV0dXJuIFNrLlR1cnRsZUdyYXBoaWNzLnJlc2V0KCl9LGUuJGV4aXRvbmNsaWNrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2V4aXRPbkNsaWNrPSEwLHRoaXMuZ2V0TWFuYWdlcihcXFwibW91c2Vkb3duXFxcIikuYWRkSGFuZGxlcigoZnVuY3Rpb24oKXtyZXNldFR1cnRsZSgpfSksITEpfSxlLiRvbmNsaWNrPWZ1bmN0aW9uKGUsdCxuKXt0aGlzLl9leGl0T25DbGlja3x8dGhpcy5nZXRNYW5hZ2VyKFxcXCJtb3VzZWRvd25cXFwiKS5hZGRIYW5kbGVyKGUsbil9LGUuJG9uY2xpY2subWluQXJncz0xLGUuJG9uY2xpY2suY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXTt2YXIgdD17ODovXmJhY2soc3BhY2UpPyQvaSw5Oi9edGFiJC9pLDEzOi9eKGVudGVyfHJldHVybikkL2ksMTY6L15zaGlmdCQvaSwxNzovXihjdHJsfGNvbnRyb2wpJC9pLDE4Oi9eYWx0JC9pLDI3Oi9eZXNjKGFwZSk/JC9pLDMyOi9ec3BhY2UkL2ksMzM6L15wYWdlW1xcXFxzXFxcXC1dP3VwJC9pLDM0Oi9ecGFnZVtcXFxcc1xcXFwtXT9kb3duJC9pLDM1Oi9eZW5kJC9pLDM2Oi9eaG9tZSQvaSwzNzovXmxlZnQoW1xcXFxzXFxcXC1dP2Fycm93KT8kL2ksMzg6L151cChbXFxcXHNcXFxcLV0/YXJyb3cpPyQvaSwzOTovXnJpZ2h0KFtcXFxcc1xcXFwtXT9hcnJvdyk/JC9pLDQwOi9eZG93bihbXFxcXHNcXFxcLV0/YXJyb3cpPyQvaSw0NTovXmluc2VydCQvaSw0NjovXmRlbChldGUpPyQvaX07ZS5fY3JlYXRlS2V5UmVwZWF0ZXI9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO24uX2tleUxvZ2dlclt0XT13aW5kb3cuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtuLl9rZXlMaXN0ZW5lcnNbZV0oKSxuLl9rZXlMb2dnZXJbdF09d2luZG93LnNldEludGVydmFsKChmdW5jdGlvbigpe24uX2tleUxpc3RlbmVyc1tlXSgpfSksNTApfSksMzMzKX0sZS5fY3JlYXRlS2V5RG93bkxpc3RlbmVyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLl9rZXlEb3duTGlzdGVuZXJ8fCh0aGlzLl9rZXlEb3duTGlzdGVuZXI9ZnVuY3Rpb24obil7aWYoZm9jdXNUdXJ0bGUoKSl7dmFyIHIsaSxzPW4uY2hhckNvZGV8fG4ua2V5Q29kZSxhPVN0cmluZy5mcm9tQ2hhckNvZGUocykudG9Mb3dlckNhc2UoKTtpZighZS5fa2V5TG9nZ2VyW3NdKWZvcihyIGluIGUuX2tleUxpc3RlbmVycylpZihpPXIubGVuZ3RoPjEmJnRbc10mJnRbc10udGVzdChyKSxyPT09YXx8aSl7ZS5fa2V5TGlzdGVuZXJzW3JdKCksZS5fY3JlYXRlS2V5UmVwZWF0ZXIocixzKSxuLnByZXZlbnREZWZhdWx0KCk7YnJlYWt9fX0sZ2V0VGFyZ2V0KCkuYWRkRXZlbnRMaXN0ZW5lcihcXFwia2V5ZG93blxcXCIsdGhpcy5fa2V5RG93bkxpc3RlbmVyKSl9LGUuX2NyZWF0ZUtleVVwTGlzdGVuZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuX2tleVVwTGlzdGVuZXJ8fCh0aGlzLl9rZXlVcExpc3RlbmVyPWZ1bmN0aW9uKHQpe3ZhciBuPWUuX2tleUxvZ2dlclt0LmNoYXJDb2RlfHx0LmtleUNvZGVdO3ZvaWQgMCE9PW4mJih0LnByZXZlbnREZWZhdWx0KCksd2luZG93LmNsZWFySW50ZXJ2YWwobiksd2luZG93LmNsZWFyVGltZW91dChuKSxkZWxldGUgZS5fa2V5TG9nZ2VyW3QuY2hhckNvZGV8fHQua2V5Q29kZV0pfSxnZXRUYXJnZXQoKS5hZGRFdmVudExpc3RlbmVyKFxcXCJrZXl1cFxcXCIsdGhpcy5fa2V5VXBMaXN0ZW5lcikpfSxlLiR0aXRsZT1mdW5jdGlvbihlKXtkb2N1bWVudC50aXRsZT1lfSxlLiR0aXRsZS5taW5BcmdzPTEsZS4kdGl0bGUuY29fdmFybmFtZXM9W1xcXCJ0aXRsZVxcXCJdLGUuJGxpc3Rlbj1mdW5jdGlvbigpe3RoaXMuX2NyZWF0ZUtleVVwTGlzdGVuZXIoKSx0aGlzLl9jcmVhdGVLZXlEb3duTGlzdGVuZXIoKX0sZS4kb25rZXk9ZnVuY3Rpb24oZSx0KXtpZihcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgdCl7dmFyIG49ZTtlPXQsdD1ufXQ9U3RyaW5nKHQpLnRvTG93ZXJDYXNlKCksZSYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGU/KHRoaXMuX2tleUxpc3RlbmVyc3x8KHRoaXMuX2tleUxpc3RlbmVycz17fSksdGhpcy5fa2V5TGlzdGVuZXJzW3RdPWUpOmRlbGV0ZSB0aGlzLl9rZXlMaXN0ZW5lcnNbdF19LGUuJG9ua2V5Lm1pbkFyZ3M9MixlLiRvbmtleS5jb192YXJuYW1lcz1bXFxcIm1ldGhvZFxcXCIsXFxcImtleVZhbHVlXFxcIl0sZS4kb25zY3JlZW5jbGljaz1mdW5jdGlvbihlLHQsbil7dGhpcy5nZXRNYW5hZ2VyKFxcXCJtb3VzZWRvd25cXFwiKS5hZGRIYW5kbGVyKGUsbil9LGUuJG9uc2NyZWVuY2xpY2subWluQXJncz0xLGUuJG9uc2NyZWVuY2xpY2suY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXSxlLiRvbnRpbWVyPWZ1bmN0aW9uKGUsdCl7dGhpcy5fdGltZXImJih3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSx0aGlzLl90aW1lcj12b2lkIDApLGUmJlxcXCJudW1iZXJcXFwiPT10eXBlb2YgdCYmKHRoaXMuX3RpbWVyPXdpbmRvdy5zZXRUaW1lb3V0KGUsTWF0aC5tYXgoMCwwfHQpKSl9LGUuJG9udGltZXIubWluQXJncz0wLGUuJG9udGltZXIuY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJpbnRlcnZhbFxcXCJdfShTY3JlZW4ucHJvdG90eXBlKTt2YXIgZz1uZXcgSW1hZ2U7ZnVuY3Rpb24gcmVtb3ZlTGF5ZXIoZSl7ZSYmZS5jYW52YXMmJmUuY2FudmFzLnBhcmVudE5vZGUmJmUuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZS5jYW52YXMpfWZ1bmN0aW9uIGNsZWFyTGF5ZXIoZSx0LG4pe2UmJihlLnNhdmUoKSxlLnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCksdD8oZS5maWxsU3R5bGU9dCxlLmZpbGxSZWN0KDAsMCxlLmNhbnZhcy53aWR0aCxlLmNhbnZhcy5oZWlnaHQpKTplLmNsZWFyUmVjdCgwLDAsZS5jYW52YXMud2lkdGgsZS5jYW52YXMuaGVpZ2h0KSxuJiZlLmRyYXdJbWFnZShuLDAsMCksZS5yZXN0b3JlKCkpfWZ1bmN0aW9uIGRyYXdUdXJ0bGUoZSx0KXt2YXIgbixyLGkscz1kW2Uuc2hhcGVdLGE9Z2V0U2NyZWVuKCksbz0oZ2V0V2lkdGgoKSxnZXRIZWlnaHQoKSxhLnhTY2FsZSksbD1hLnlTY2FsZTtpZih0KXtpZihuPU1hdGguY29zKGUucmFkaWFucykvbyxyPU1hdGguc2luKGUucmFkaWFucykvbCxpPU1hdGguYXRhbjIocixuKS1NYXRoLlBJLzIsdC5zYXZlKCksdC50cmFuc2xhdGUoZS54LGUueSksdC5zY2FsZShvLGwpLHMubm9kZU5hbWUpe3ZhciB1PXMubmF0dXJhbFdpZHRoLGM9cy5uYXR1cmFsSGVpZ2h0O3QuZHJhd0ltYWdlKHMsMCwwLHUsYywtdS8yLC1jLzIsdSxjKX1lbHNle3Qucm90YXRlKGkpLHQuYmVnaW5QYXRoKCksdC5saW5lV2lkdGg9MSx0LnN0cm9rZVN0eWxlPWUuY29sb3IsdC5maWxsU3R5bGU9ZS5maWxsLHQubW92ZVRvKC1zWzBdWzBdLHNbMF1bMV0pO2Zvcih2YXIgaD0xO2g8cy5sZW5ndGg7aCsrKXQubGluZVRvKC1zW2hdWzBdLHNbaF1bMV0pO3QuY2xvc2VQYXRoKCksdC5maWxsKCksdC5zdHJva2UoKX10LnJlc3RvcmUoKX19ZnVuY3Rpb24gZHJhd0RvdChlLHQpe3ZhciBuPXRoaXMuY29udGV4dCgpLHI9Z2V0U2NyZWVuKCksaT1yLnhTY2FsZSxzPXIueVNjYWxlO24mJihuLmJlZ2luUGF0aCgpLG4ubW92ZVRvKHRoaXMueCx0aGlzLnkpLGUqPU1hdGgubWluKE1hdGguYWJzKGkpLE1hdGguYWJzKHMpKSxuLmFyYyh0aGlzLngsdGhpcy55LGUvMiwwLFR1cnRsZS5SQURJQU5TKSxuLmNsb3NlUGF0aCgpLG4uZmlsbFN0eWxlPXR8fHRoaXMuY29sb3Isbi5maWxsKCkpfXZhciBwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImNhbnZhc1xcXCIpLmdldENvbnRleHQoXFxcIjJkXFxcIik7ZnVuY3Rpb24gZHJhd1RleHQoZSx0LG4pe3ZhciByPXRoaXMuY29udGV4dCgpO3ImJihyLnNhdmUoKSxuJiYoci5mb250PW4pLHQmJnQubWF0Y2goL14obGVmdHxyaWdodHxjZW50ZXIpJC8pJiYoci50ZXh0QWxpZ249dCksci5zY2FsZSgxLC0xKSxyLmZpbGxTdHlsZT10aGlzLmZpbGwsci5maWxsVGV4dChlLHRoaXMueCwtdGhpcy55KSxyLnJlc3RvcmUoKSl9ZnVuY3Rpb24gZHJhd0xpbmUoZSx0LG4pe3ZhciByPXRoaXMuY29udGV4dCgpO3ImJih0JiYoci5iZWdpblBhdGgoKSxyLm1vdmVUbyh0aGlzLngsdGhpcy55KSksci5saW5lV2lkdGg9dGhpcy5zaXplKmdldFNjcmVlbigpLmxpbmVTY2FsZSxyLnN0cm9rZVN0eWxlPXRoaXMuY29sb3Isci5saW5lVG8oZS54LGUueSksci5zdHJva2UoKSl9ZnVuY3Rpb24gZHJhd0ZpbGwoKXt2YXIgZSx0PXRoaXMuY29udGV4dCgpLG49dGhpcy5maWxsQnVmZmVyO2lmKHQmJm4mJm4ubGVuZ3RoKXtmb3IodC5zYXZlKCksdC5iZWdpblBhdGgoKSx0Lm1vdmVUbyhuWzBdLngsblswXS55KSxlPTE7ZTxuLmxlbmd0aDtlKyspdC5saW5lVG8obltlXS54LG5bZV0ueSk7Zm9yKHQuY2xvc2VQYXRoKCksdC5maWxsU3R5bGU9dGhpcy5maWxsLHQuZmlsbCgpLGU9MTtlPG4ubGVuZ3RoO2UrKyluW2VdLnN0cm9rZSYmKHQuYmVnaW5QYXRoKCksdC5tb3ZlVG8obltlLTFdLngsbltlLTFdLnkpLHQubGluZVdpZHRoPW5bZV0uc2l6ZSpnZXRTY3JlZW4oKS5saW5lU2NhbGUsdC5zdHJva2VTdHlsZT1uW2VdLmNvbG9yLHQubGluZVRvKG5bZV0ueCxuW2VdLnkpLHQuc3Ryb2tlKCkpO3QucmVzdG9yZSgpfX1mdW5jdGlvbiBwYXJ0aWFsVHJhbnNsYXRlKGUsdCxuLHIsaSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuYWRkVXBkYXRlKChmdW5jdGlvbihlKXt0aGlzLmRvd24mJmRyYXdMaW5lLmNhbGwodGhpcyxlLHIpfSksaSx7eDp0LHk6bn0scil9fWZ1bmN0aW9uIHBhcnRpYWxSb3RhdGUoZSx0LG4scil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuYWRkVXBkYXRlKHZvaWQgMCxyLHthbmdsZTp0LHJhZGlhbnM6bn0pfX1mdW5jdGlvbiBnZXRDb29yZGluYXRlcyhlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1lJiYoZS55fHxlLl95fHxlWzFdKXx8MCxlPWUmJihlLnh8fGUuX3h8fGVbMF0pfHwwKSx7eDplLHk6dH19ZnVuY3Rpb24gaGV4VG9SR0IoZSl7dmFyIHQsbixyO3JldHVybih0PS9ecmdiYT9cXFxcKChcXFxcZCspLChcXFxcZCspLChcXFxcZCspKD86LChbLlxcXFxkXSspKT9cXFxcKSQvLmV4ZWMoZSkpPyhyPVtwYXJzZUludCh0WzFdKSxwYXJzZUludCh0WzJdKSxwYXJzZUludCh0WzNdKV0sdFs0XSYmci5wdXNoKHBhcnNlRmxvYXQodFs0XSkpKTovXiM/W2EtZlxcXFxkXXszfXxbYS1mXFxcXGRdezZ9JC9pLmV4ZWMoZSk/KDQ9PT1lLmxlbmd0aCYmKGU9ZS5yZXBsYWNlKC9eIz8oW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkkL2ksKGZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0K3QrbituK3Ircn0pKSksbj0vXiM/KFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pJC9pLmV4ZWMoZSkscj1bcGFyc2VJbnQoblsxXSwxNikscGFyc2VJbnQoblsyXSwxNikscGFyc2VJbnQoblszXSwxNildKTpyPWUscn1mdW5jdGlvbiBjcmVhdGVDb2xvcihlLHQsbixyLGkpe3ZhciBzO2lmKHZvaWQgMCE9PW4mJih0PVt0LG4scixpXSksdC5jb25zdHJ1Y3Rvcj09PUFycmF5JiZ0Lmxlbmd0aCl7aWYoMjU1PT09ZSlmb3Iocz0wO3M8MztzKyspe2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgdFtzXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJiYWQgY29sb3Igc2VxdWVuY2VcXFwiKTt0W3NdPU1hdGgubWF4KDAsTWF0aC5taW4oMjU1LHBhcnNlSW50KHRbc10pKSl9ZWxzZSBmb3Iocz0wO3M8MztzKyspe2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgdFtzXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJiYWQgY29sb3Igc2VxdWVuY2VcXFwiKTtpZighKHRbc108PTEpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImJhZCBjb2xvciBzZXF1ZW5jZVxcXCIpO3Rbc109TWF0aC5tYXgoMCxNYXRoLm1pbigyNTUscGFyc2VJbnQoMjU1KnRbc10pKSl9XFxcIm51bWJlclxcXCI9PXR5cGVvZiB0W3NdPyh0WzNdPU1hdGgubWF4KDAsTWF0aC5taW4oMSx0W3NdKSksdD1cXFwicmdiYShcXFwiK3Quam9pbihcXFwiLFxcXCIpK1xcXCIpXFxcIik6dD1cXFwicmdiKFxcXCIrdC5zbGljZSgwLDMpLmpvaW4oXFxcIixcXFwiKStcXFwiKVxcXCJ9ZWxzZXtpZihcXFwic3RyaW5nXFxcIiE9dHlwZW9mIHR8fHQubWF0Y2goL1xcXFxzKnVybFxcXFxzKlxcXFwoL2kpKXJldHVyblxcXCJibGFja1xcXCI7dD10LnJlcGxhY2UoL1xcXFxzKy9nLFxcXCJcXFwiKX1yZXR1cm4gdH1mdW5jdGlvbiBjYWxjdWxhdGVIZWFkaW5nKGUsdCxuKXt2YXIgcj1lLl9hbmdsZXx8MCxpPWUuX3JhZGlhbnN8fDA7cmV0dXJuIG58fChuPXt9KSxcXFwibnVtYmVyXFxcIj09dHlwZW9mIHQmJihlLl9pc1JhZGlhbnM/cj1pPXQlVHVydGxlLlJBRElBTlM6ZS5fZnVsbENpcmNsZT9pPShyPXQlZS5fZnVsbENpcmNsZSkvZS5fZnVsbENpcmNsZSpUdXJ0bGUuUkFESUFOUzpyPWk9MCxyPDAmJihyKz1lLl9mdWxsQ2lyY2xlLGkrPVR1cnRsZS5SQURJQU5TKSksbi5hbmdsZT1yLG4ucmFkaWFucz1pLG59ZnVuY3Rpb24gcHl0aG9uVG9KYXZhc2NyaXB0RnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoZSl9KSk7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB0JiZuLnVuc2hpZnQodCksU2subWlzY2V2YWwuYXBwbHlBc3luYyh2b2lkIDAsZSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxuKS5jYXRjaChTay51bmNhdWdodEV4Y2VwdGlvbil9fWZ1bmN0aW9uIGFkZE1vZHVsZU1ldGhvZChlLHQsbixyKXt2YXIgaSxzPW4ucmVwbGFjZSgvXlxcXFwkLyxcXFwiXFxcIiksYT1zLnJlcGxhY2UoL19cXFxcJFthLXpdK1xcXFwkJC9pLFxcXCJcXFwiKSxvPWUucHJvdG90eXBlW25dLmxlbmd0aCxsPWUucHJvdG90eXBlW25dLm1pbkFyZ3MsdT1lLnByb3RvdHlwZVtuXS5jb192YXJuYW1lc3x8W10sYz1lLnByb3RvdHlwZVtuXS5yZXR1cm5UeXBlLGg9ZS5wcm90b3R5cGVbbl0uaXNTazt2b2lkIDA9PT1sJiYobD1vKSwoaT1mdW5jdGlvbigpe3ZhciBlLHQsaSxzLHUsZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCksZj1yP3IoKTpkLnNoaWZ0KCkuaW5zdGFuY2U7aWYoZC5sZW5ndGg8bHx8ZC5sZW5ndGg+byl0aHJvdyB1PWw9PT1vP1xcXCJleGFjdGx5IFxcXCIrbzpcXFwiYmV0d2VlbiBcXFwiK2wrXFxcIiBhbmQgXFxcIitvLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihhK1xcXCIoKSB0YWtlcyBcXFwiK3UrXFxcIiBwb3NpdGlvbmFsIGFyZ3VtZW50KHMpIChcXFwiK2QubGVuZ3RoK1xcXCIgZ2l2ZW4pXFxcIik7Zm9yKGU9ZC5sZW5ndGg7LS1lPj0wOyl2b2lkIDAhPT1kW2VdJiYoZFtlXWluc3RhbmNlb2YgU2suYnVpbHRpbi5mdW5jP2RbZV09cHl0aG9uVG9KYXZhc2NyaXB0RnVuY3Rpb24oZFtlXSk6ZFtlXWluc3RhbmNlb2YgU2suYnVpbHRpbi5tZXRob2Q/ZFtlXT1weXRob25Ub0phdmFzY3JpcHRGdW5jdGlvbihkW2VdLmltX2Z1bmMsZFtlXS5pbV9zZWxmKTpkW2VdJiZkW2VdLiRkIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0JiZkW2VdLmluc3RhbmNlP2RbZV09ZFtlXS5pbnN0YW5jZTpkW2VdPVNrLmZmaS5yZW1hcFRvSnMoZFtlXSkpO3ZhciBfPWQuc2xpY2UoMCk7Zm9yKGQ9W10sZT1fLmxlbmd0aDtlPj0wOy0tZSludWxsIT09X1tlXSYmKGRbZV09X1tlXSk7dHJ5e3Q9ZltuXS5hcHBseShmLGQpfWNhdGNoKGcpe3Rocm93IHdpbmRvdyYmd2luZG93LmNvbnNvbGUmJih3aW5kb3cuY29uc29sZS5sb2coXFxcIndyYXBwZWQgbWV0aG9kIGZhaWxlZFxcXCIpLHdpbmRvdy5jb25zb2xlLmxvZyhnLnN0YWNrKSksZ31yZXR1cm4gdCBpbnN0YW5jZW9mIEluc3RhbnRQcm9taXNlJiYodD10Lmxhc3RSZXN1bHQpLHQgaW5zdGFuY2VvZiBQcm9taXNlPyh0PXQuY2F0Y2goKGZ1bmN0aW9uKGUpe3Rocm93IHdpbmRvdyYmd2luZG93LmNvbnNvbGUmJih3aW5kb3cuY29uc29sZS5sb2coXFxcInByb21pc2UgZmFpbGVkXFxcIiksd2luZG93LmNvbnNvbGUubG9nKGUuc3RhY2spKSxlfSkpLChpPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKS5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09cz9Tay5idWlsdGluLm5vbmUubm9uZSQ6U2suZmZpLnJlbWFwVG9QeShzKX0saS5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOnQudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIHM9ZSxlfSkpfSxpKTp2b2lkIDA9PT10P1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpoP3Q6XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGM/Yyh0KTpTay5mZmkucmVtYXBUb1B5KHQpfSkuY29fbmFtZT1uZXcgU2suYnVpbHRpbi5zdHIoYSksaS5jb192YXJuYW1lcz11LnNsaWNlKCksaS4kZGVmYXVsdHM9W107Zm9yKHZhciBkPWw7ZDx1Lmxlbmd0aDtkKyspaS4kZGVmYXVsdHMucHVzaChTay5idWlsdGluLm5vbmUubm9uZSQpO3J8fGkuY29fdmFybmFtZXMudW5zaGlmdChcXFwic2VsZlxcXCIpLHRbc109bmV3IFNrLmJ1aWx0aW4uZnVuYyhpKX1mdW5jdGlvbiBpbml0VHVydGxlKGUsdCl7U2suYnVpbHRpbi5weUNoZWNrQXJncyhcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cywyLDMsITEsITEpLGUuaW5zdGFuY2U9bmV3IFR1cnRsZSh0KSxlLmluc3RhbmNlLnNrSW5zdGFuY2U9ZX1mb3IodmFyIG0gaW4gaW5pdFR1cnRsZS5jb192YXJuYW1lcz1bXFxcInNlbGZcXFwiLFxcXCJzaGFwZVxcXCJdLGluaXRUdXJ0bGUuY29fbmFtZT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIlR1cnRsZVxcXCIpLGluaXRUdXJ0bGUuY29fYXJnY291bnQ9Mixpbml0VHVydGxlLiRkZWZhdWx0cz1bU2suYnVpbHRpbi5ub25lLm5vbmUkLG5ldyBTay5idWlsdGluLnN0cihcXFwiY2xhc3NpY1xcXCIpXSxUdXJ0bGUucHJvdG90eXBlKS9eXFxcXCRbYS16X10rLy50ZXN0KG0pJiZhZGRNb2R1bGVNZXRob2QoVHVydGxlLHUsbSxlbnN1cmVBbm9ueW1vdXMpO2Z1bmN0aW9uIGZvY3VzVHVydGxlKGUpe3JldHVybiB2b2lkIDAhPT1lJiYoKGM9ISFlKT9nZXRUYXJnZXQoKS5mb2N1cygpOmdldFRhcmdldCgpLmJsdXIoKSksY31mdW5jdGlvbiByZXNldFR1cnRsZSgpe2ZvcihjYW5jZWxBbmltYXRpb25GcmFtZSgpLGdldFNjcmVlbigpLnJlc2V0KCksZ2V0RnJhbWVNYW5hZ2VyKCkucmVzZXQoKTtlLmZpcnN0Q2hpbGQ7KWUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTthJiZhLnJlc2V0KCkscj12b2lkIDAscz12b2lkIDAsYT12b2lkIDB9cmV0dXJuIGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJG1haW5sb29wXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJGRvbmVcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkYnllXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJHRyYWNlclxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiR1cGRhdGVcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkZGVsYXlcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkd2luZG93X3dpZHRoXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJHdpbmRvd19oZWlnaHRcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkdGl0bGVcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkb25rZXlcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkbGlzdGVuXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJHJlZ2lzdGVyX3NoYXBlXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJGNsZWFyc2NyZWVuXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJGJnY29sb3JcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkYmdwaWNcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkc2V0d29ybGRjb29yZGluYXRlc1xcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRvbnRpbWVyXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJG9uc2NyZWVuY2xpY2tcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkZXhpdG9uY2xpY2tcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkcmVzZXRzY3JlZW5cXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkc2V0dXBcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkdHVydGxlc1xcXCIsZ2V0U2NyZWVuKSx1LlR1cnRsZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKHUsKGZ1bmN0aW9uIFR1cnRsZVdyYXBwZXIoZSx0KXtmb3IodmFyIG4gaW4gdC5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGluaXRUdXJ0bGUpLFR1cnRsZS5wcm90b3R5cGUpL15cXFxcJFthLXpfXSsvLnRlc3QobikmJmFkZE1vZHVsZU1ldGhvZChUdXJ0bGUsdCxuKX0pLFxcXCJUdXJ0bGVcXFwiLFtdKSx1LlNjcmVlbj1Tay5taXNjZXZhbC5idWlsZENsYXNzKHUsKGZ1bmN0aW9uIFNjcmVlbldyYXBwZXIoZSx0KXtmb3IodmFyIG4gaW4gdC5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtlLmluc3RhbmNlPWdldFNjcmVlbigpfSkpLFNjcmVlbi5wcm90b3R5cGUpL15cXFxcJFthLXpfXSsvLnRlc3QobikmJmFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdCxuKX0pLFxcXCJTY3JlZW5cXFwiLFtdKSx7c2tNb2R1bGU6dSxyZXNldDpyZXNldFR1cnRsZSxzdG9wOmZ1bmN0aW9uIHN0b3BUdXJ0bGUoKXtjYW5jZWxBbmltYXRpb25GcmFtZSgpLGEmJmEucmVzZXQoKSxyPXZvaWQgMCxzPXZvaWQgMCxhPXZvaWQgMH0sZm9jdXM6Zm9jdXNUdXJ0bGUsVHVydGxlOlR1cnRsZSxTY3JlZW46U2NyZWVufX0odCksU2suVHVydGxlR3JhcGhpY3MubW9kdWxlPXQudHVydGxlSW5zdGFuY2Uuc2tNb2R1bGUsU2suVHVydGxlR3JhcGhpY3MucmVzZXQ9dC50dXJ0bGVJbnN0YW5jZS5yZXNldCxTay5UdXJ0bGVHcmFwaGljcy5zdG9wPXQudHVydGxlSW5zdGFuY2Uuc3RvcCxTay5UdXJ0bGVHcmFwaGljcy5mb2N1cz10LnR1cnRsZUluc3RhbmNlLmZvY3VzLFNrLlR1cnRsZUdyYXBoaWNzLnJhdz17VHVydGxlOnQudHVydGxlSW5zdGFuY2UuVHVydGxlLFNjcmVlbjp0LnR1cnRsZUluc3RhbmNlLlNjcmVlbn0sdC50dXJ0bGVJbnN0YW5jZS5za01vZHVsZX07XCIsXCJzcmMvbGliL3VybGxpYi9fX2luaXRfXy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG4pe3JldHVybnt9fTtcIixcInNyYy9saWIvdXJsbGliL3JlcXVlc3QvX19pbml0X18uanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihuKXt2YXIgZT17fTtlLlJlc3BvbnNlPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoZSwoZnVuY3Rpb24obixlKXtlLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sZSl7bi5kYXRhJD1lLnJlc3BvbnNlVGV4dCxuLmxpbmVMaXN0PW4uZGF0YSQuc3BsaXQoXFxcIlxcXFxuXFxcIiksbi5saW5lTGlzdD1uLmxpbmVMaXN0LnNsaWNlKDAsLTEpO2Zvcih2YXIgaT0wO2k8bi5saW5lTGlzdC5sZW5ndGg7aSsrKW4ubGluZUxpc3RbaV09bi5saW5lTGlzdFtpXStcXFwiXFxcXG5cXFwiO24uY3VycmVudExpbmU9MCxuLnBvcyQ9MH0pKSxlLl9fc3RyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoXFxcIjxSZXNwb25zZT5cXFwiKX0pKSxlLl9faXRlcl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3ZhciBlPW4ubGluZUxpc3Q7cmV0dXJuIFNrLmJ1aWx0aW4ubWFrZUdlbmVyYXRvcigoZnVuY3Rpb24oKXtpZighKHRoaXMuJGluZGV4Pj10aGlzLiRsaW5lcy5sZW5ndGgpKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kbGluZXNbdGhpcy4kaW5kZXgrK10pfSkseyRvYmo6biwkaW5kZXg6MCwkbGluZXM6ZX0pfSkpLGUucmVhZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUpe2lmKG4uY2xvc2VkKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkkvTyBvcGVyYXRpb24gb24gY2xvc2VkIGZpbGVcXFwiKTt2YXIgaT1uLmRhdGEkLmxlbmd0aDt2b2lkIDA9PT1lJiYoZT1pKTt2YXIgdD1uZXcgU2suYnVpbHRpbi5zdHIobi5kYXRhJC5zdWJzdHIobi5wb3MkLGUpKTtyZXR1cm4gbi5wb3MkKz1lLG4ucG9zJD49aSYmKG4ucG9zJD1pKSx0fSkpLGUucmVhZGxpbmU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixlKXt2YXIgaT1cXFwiXFxcIjtyZXR1cm4gbi5jdXJyZW50TGluZTxuLmxpbmVMaXN0Lmxlbmd0aCYmKGk9bi5saW5lTGlzdFtuLmN1cnJlbnRMaW5lXSxuLmN1cnJlbnRMaW5lKyspLG5ldyBTay5idWlsdGluLnN0cihpKX0pKSxlLnJlYWRsaW5lcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUpe2Zvcih2YXIgaT1bXSx0PW4uY3VycmVudExpbmU7dDxuLmxpbmVMaXN0Lmxlbmd0aDt0KyspaS5wdXNoKG5ldyBTay5idWlsdGluLnN0cihuLmxpbmVMaXN0W3RdKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoaSl9KSl9KSxcXFwiUmVzcG9uc2VcXFwiLFtdKTtyZXR1cm4gZS51cmxvcGVuPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSx0KXt2YXIgcjtyPWZ1bmN0aW9uKG4pe3ZhciBlO2lmKCFTay5qc29ucFNpdGVzKXJldHVybiExO2ZvcihlPTA7ZTxTay5qc29ucFNpdGVzLmxlbmd0aDtlKyspaWYobi5zdGFydHNXaXRoKFNrLmpzb25wU2l0ZXNbZV0pKXJldHVybiEwO3JldHVybiExfShuLnYpP25ldyBQcm9taXNlKChmdW5jdGlvbihpLHQpe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpO3Iuc3JjPW4uditcXFwiJmNhbGxiYWNrPVNrLmpzb25wY2FsbGJhY2tcXFwiLHIub25lcnJvcj1mdW5jdGlvbihuKXt0KFxcXCJBbiBlcnJvciBvY2N1cmVkIGdldHRpbmcgdGhlIGRhdGFcXFwiKX0sU2suanNvbnBjYWxsYmFjaz1mdW5jdGlvbihuKXt2YXIgdD17cmVzcG9uc2VUZXh0OkpTT04uc3RyaW5naWZ5KG4pfTtpKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLlJlc3BvbnNlLFt0XSkpfTt0cnl7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyKX1jYXRjaChzKXtjb25zb2xlLmxvZyhcXFwiY2F1Z2h0IGVycm9yIGluIHVybG9wZW5cXFwiK3MpfX0pKTpuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxyKXt2YXIgcz1uZXcgWE1MSHR0cFJlcXVlc3Q7cy5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkZW5kXFxcIiwoZnVuY3Rpb24obil7dChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZS5SZXNwb25zZSxbc10pKX0pKSxpPyhzLm9wZW4oXFxcIlBPU1RcXFwiLG4udikscy5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJDb250ZW50LXR5cGVcXFwiLFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiKSxzLnNlbmQoaS52KSk6KHMub3BlbihcXFwiR0VUXFxcIixuLnYpLHMuc2VuZChudWxsKSl9KSk7dmFyIHMsdT1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbjtyZXR1cm4gdS5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gc30sdS5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOnIudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIHM9bixufSksKGZ1bmN0aW9uKG4pe3JldHVybiBzPVxcXCJcXFwiLG59KSl9LHV9KSksZX07XCIsXCJzcmMvbGliL3dlYmJyb3dzZXIuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihuKXt2YXIgZT17fSx0PVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93JiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3I7ZnVuY3Rpb24gb3Blbl90YWIobil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInVybFxcXCIsXFxcInN0cmluZ1xcXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyhuKSksdD8obj1uLiRqc3N0cigpLHdpbmRvdy5vcGVuKG4sXFxcIl9ibGFua1xcXCIpLFNrLmJ1aWx0aW4uYm9vbC50cnVlJCk6U2suYnVpbHRpbi5ib29sLmZhbHNlJH1yZXR1cm4gZS5fX25hbWVfXz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIndlYmJyb3dzZXJcXFwiKSxlLm9wZW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gb3BlbihuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwib3BlblxcXCIsYXJndW1lbnRzLmxlbmd0aCsxLDEsMyksb3Blbl90YWIobil9KSksZS5vcGVuX25ldz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBvcGVuX25ldyhuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwib3Blbl9uZXdcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxvcGVuX3RhYihuKX0pKSxlLm9wZW5fbmV3X3RhYj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBvcGVuX25ld190YWIobil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3X3RhYlxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLG9wZW5fdGFiKG4pfSkpLGUuRGVmYXVsdEJyb3dzZXI9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhlLChmdW5jdGlvbiBkZmxicm93c2VyKG4sZSl7ZS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBfX2luaXRfXyhuKXtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSkpLGUub3Blbj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBvcGVuKG4sZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiw0KSxvcGVuX3RhYihlKX0pKSxlLm9wZW5fbmV3PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uIG9wZW5fbmV3KG4sZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksb3Blbl90YWIoZSl9KSksZS5vcGVuX25ld190YWI9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gb3Blbl9uZXdfdGFiKG4sZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3X3RhYlxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLG9wZW5fdGFiKGUpfSkpfSksXFxcIkRlZmF1bHRCcm93c2VyXFxcIixbXSksZS5nZXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldFxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLkRlZmF1bHRCcm93c2VyLFtdKX0pKSxlfTtcIixcInNyYy9saWIvd2ViZ2wvX19pbml0X18uanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihuKXt2YXIgdD17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ3ZWJnbFxcXCIpfSxtYWtlRmFpbEhUTUw9ZnVuY3Rpb24obil7cmV0dXJuJzx0YWJsZSBzdHlsZT1cXFwiYmFja2dyb3VuZC1jb2xvcjogIzhDRTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcXFwiPjx0cj48dGQgYWxpZ249XFxcImNlbnRlclxcXCI+PGRpdiBzdHlsZT1cXFwiZGlzcGxheTogdGFibGUtY2VsbDsgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXFwiPjxkaXYgc3R5bGU9XFxcIlxcXCI+JytuK1xcXCI8L2Rpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT5cXFwifSxlPSdUaGlzIHBhZ2UgcmVxdWlyZXMgYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgV2ViR0wuPGJyLz48YSBocmVmPVxcXCJodHRwOi8vZ2V0LndlYmdsLm9yZ1xcXCI+Q2xpY2sgaGVyZSB0byB1cGdyYWRlIHlvdXIgYnJvd3Nlci48L2E+JztyZXR1cm4gdC5Db250ZXh0PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3ModCwoZnVuY3Rpb24obix0KXt0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCl7dmFyIGk9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodC52KSxyPWZ1bmN0aW9uKG4sdCl7dmFyIGk9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobik7aWYodHx8KHQ9aS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiY2FudmFzXFxcIilbMF0pLHQpe3ZhciByPWZ1bmN0aW9uKG4pe2Zvcih2YXIgdD1bXFxcIndlYmdsXFxcIixcXFwiZXhwZXJpbWVudGFsLXdlYmdsXFxcIixcXFwid2Via2l0LTNkXFxcIixcXFwibW96LXdlYmdsXFxcIl0sZT1udWxsLGk9MDtpPHQubGVuZ3RoOysraSl7dHJ5e2U9bi5nZXRDb250ZXh0KHRbaV0pfWNhdGNoKHIpe31pZihlKWJyZWFrfWlmKGUpe2Z1bmN0aW9uIHJldHVybkZhbHNlKCl7cmV0dXJuITF9bi5vbnNlbGVjdHN0YXJ0PXJldHVybkZhbHNlLG4ub25tb3VzZWRvd249cmV0dXJuRmFsc2V9cmV0dXJuIGV9KHQpO2lmKCFyKXt2YXIgdT1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oXFxcXHcrXFxcXC8uKj8gKS9nKSxhPXt9O3RyeXtmb3IodmFyIG89MDtvPHUubGVuZ3RoOysrbyl7Zm9yKHZhciBsPXVbb10ubWF0Y2goLyhcXFxcdyspL2cpLGM9W10sZj0xO2Y8bC5sZW5ndGg7KytmKWMucHVzaChwYXJzZUludChsW2ZdKSk7YVtsWzBdXT1jfX1jYXRjaChzKXt9YS5DaHJvbWUmJihhLkNocm9tZVswXT43fHw3PT1hLkNocm9tZVswXSYmYS5DaHJvbWVbMV0+MHx8Nz09YS5DaHJvbWVbMF0mJjA9PWEuQ2hyb21lWzFdJiZhLkNocm9tZVsyXT49NTIxKT9pLmlubmVySFRNTD1tYWtlRmFpbEhUTUwoJ0l0IGRvZXNuXFxcXCd0IGFwcGVhciB5b3VyIGNvbXB1dGVyIGNhbiBzdXBwb3J0IFdlYkdMLjxici8+PGEgaHJlZj1cXFwiaHR0cDovL2dldC53ZWJnbC5vcmdcXFwiPkNsaWNrIGhlcmUgZm9yIG1vcmUgaW5mb3JtYXRpb24uPC9hPicpOmkuaW5uZXJIVE1MPW1ha2VGYWlsSFRNTChlKX1yZXR1cm4gcn1pLmlubmVySFRNTD1tYWtlRmFpbEhUTUwoZSl9KHQudixpKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXFxcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBXZWJHTC5cXFwiKTtmb3IodmFyIHUgaW4gbi5nbD1yLHIuX19wcm90b19fKWlmKFxcXCJudW1iZXJcXFwiPT10eXBlb2Ygci5fX3Byb3RvX19bdV0pU2suYWJzdHIub2JqZWN0U2V0SXRlbShuLiRkLG5ldyBTay5idWlsdGluLnN0cih1KSxyLl9fcHJvdG9fX1t1XSk7ZWxzZSBpZihcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygci5fX3Byb3RvX19bdV0pc3dpdGNoKHUpe2Nhc2VcXFwiYnVmZmVyRGF0YVxcXCI6Y2FzZVxcXCJjbGVhckNvbG9yXFxcIjpjYXNlXFxcImRyYXdBcnJheXNcXFwiOmNhc2VcXFwiZ2V0QXR0cmliTG9jYXRpb25cXFwiOmNhc2VcXFwiZ2V0VW5pZm9ybUxvY2F0aW9uXFxcIjpjYXNlXFxcInNoYWRlclNvdXJjZVxcXCI6Y2FzZVxcXCJ1bmlmb3JtTWF0cml4NGZ2XFxcIjpjYXNlXFxcInZlcnRleEF0dHJpYlBvaW50ZXJcXFwiOmNhc2VcXFwidmlld3BvcnRcXFwiOmJyZWFrO2RlZmF1bHQ6IWZ1bmN0aW9uKHQpe1NrLmFic3RyLm9iamVjdFNldEl0ZW0obi4kZCxuZXcgU2suYnVpbHRpbi5zdHIodSksbmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXt2YXIgbj1yLl9fcHJvdG9fX1t0XTtyZXR1cm4gbi5hcHBseShyLGFyZ3VtZW50cyl9KSkpfSh1KX1yLmNsZWFyQ29sb3IoMTAwLzI1NSwxNDkvMjU1LDIzNy8yNTUsMSksci5jbGVhcihyLkNPTE9SX0JVRkZFUl9CSVQpfSkpLHQudHAkZ2V0YXR0cj1Tay5nZW5lcmljLmdldEF0dHIsdC5idWZmZXJEYXRhPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCxlLGkpe24uZ2wuYnVmZmVyRGF0YSh0LGUudixpKX0pKSx0LmNsZWFyQ29sb3I9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUsaSxyKXtuLmdsLmNsZWFyQ29sb3IoU2suYnVpbHRpbi5hc251bSQodCksU2suYnVpbHRpbi5hc251bSQoZSksU2suYnVpbHRpbi5hc251bSQoaSksU2suYnVpbHRpbi5hc251bSQocikpfSkpLHQuZ2V0QXR0cmliTG9jYXRpb249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUpe3JldHVybiBuLmdsLmdldEF0dHJpYkxvY2F0aW9uKHQsZS52KX0pKSx0LmdldFVuaWZvcm1Mb2NhdGlvbj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSl7cmV0dXJuIG4uZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZS52KX0pKSx0LnNoYWRlclNvdXJjZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSl7bi5nbC5zaGFkZXJTb3VyY2UodCxlLnYpfSkpLHQuZHJhd0FycmF5cz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSxpKXtuLmdsLmRyYXdBcnJheXMoU2suYnVpbHRpbi5hc251bSQodCksU2suYnVpbHRpbi5hc251bSQoZSksU2suYnVpbHRpbi5hc251bSQoaSkpfSkpLHQudmVydGV4QXR0cmliUG9pbnRlcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSxpLHIsdSxhKXtuLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIodCxTay5idWlsdGluLmFzbnVtJChlKSxTay5idWlsdGluLmFzbnVtJChpKSxyLFNrLmJ1aWx0aW4uYXNudW0kKHUpLFNrLmJ1aWx0aW4uYXNudW0kKGEpKX0pKSx0LnZpZXdwb3J0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCxlLGkscil7bi5nbC52aWV3cG9ydChTay5idWlsdGluLmFzbnVtJCh0KSxTay5idWlsdGluLmFzbnVtJChlKSxTay5idWlsdGluLmFzbnVtJChpKSxTay5idWlsdGluLmFzbnVtJChyKSl9KSksdC51bmlmb3JtTWF0cml4NGZ2PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCxlLGkpe24uZ2wudW5pZm9ybU1hdHJpeDRmdihTay5idWlsdGluLmFzbnVtJCh0KSxlLGkudil9KSksdC5zZXREcmF3RnVuYz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe3ZhciBlPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3NldEludGVydmFsKChmdW5jdGlvbigpe1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LFtuLChuZXcgRGF0ZSkuZ2V0VGltZSgpLWVdKX0pLDFlMy82MCl9KSl9KSxcXFwiQ29udGV4dFxcXCIsW10pLHQuRmxvYXQzMkFycmF5PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3ModCwoZnVuY3Rpb24obix0KXt0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCl7bi52PVxcXCJudW1iZXJcXFwiPT10eXBlb2YgdD9uZXcgRmxvYXQzMkFycmF5KHQpOm5ldyBGbG9hdDMyQXJyYXkoU2suZmZpLnJlbWFwVG9Kcyh0KSl9KSksdC5fX3JlcHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtmb3IodmFyIHQ9W10sZT0wO2U8bi52Lmxlbmd0aDsrK2UpdC5wdXNoKG4udltlXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcXFwiW1xcXCIrdC5qb2luKFxcXCIsIFxcXCIpK1xcXCJdXFxcIil9KSl9KSxcXFwiRmxvYXQzMkFycmF5XFxcIixbXSksdC5NYXRyaXg0eDQ9U2subWlzY2V2YWwuYnVpbGRDbGFzcyh0LChmdW5jdGlvbihuLHQpe3QuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0KXtuLnY9bmV3IEZsb2F0MzJBcnJheShTay5mZmkucmVtYXBUb0pzKHQpKX0pKSx0LmlkZW50aXR5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3ZhciB0PW4udjt0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09MSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09MSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTF9KSksdC5wZXJzcGVjdGl2ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSxpLHIpe3ZhciB1PU1hdGgudGFuKC41Kk1hdGguUEktU2suYnVpbHRpbi5hc251bSQodCkqTWF0aC5QSS8xODAqLjUpLGE9U2suYnVpbHRpbi5hc251bSQoZSksbz1Tay5idWlsdGluLmFzbnVtJChpKSxsPVNrLmJ1aWx0aW4uYXNudW0kKHIpLGM9MS8oby1sKSxmPW4udjtmWzBdPXUvYSxmWzFdPTAsZlsyXT0wLGZbM109MCxmWzRdPTAsZls1XT11LGZbNl09MCxmWzddPTAsZls4XT0wLGZbOV09MCxmWzEwXT0obytsKSpjLGZbMTFdPS0xLGZbMTJdPTAsZlsxM109MCxmWzE0XT1vKmwqYyoyLGZbMTVdPTB9KSksdC50cmFuc2xhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0KXt2YXIgZT1uLnYsaT1Tay5mZmkucmVtYXBUb0pzKHQpO2VbMF09MSxlWzFdPTAsZVsyXT0wLGVbM109MCxlWzRdPTAsZVs1XT0xLGVbNl09MCxlWzddPTAsZVs4XT0wLGVbOV09MCxlWzEwXT0xLGVbMTFdPTAsZVsxMl09aVswXSxlWzEzXT1pWzFdLGVbMTRdPWlbMl0sZVsxNV09MX0pKSx0Ll9fcmVwcl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2Zvcih2YXIgdD1bXSxlPTA7ZTxuLnYubGVuZ3RoOysrZSl0LnB1c2gobi52W2VdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJbXFxcIit0LmpvaW4oXFxcIiwgXFxcIikrXFxcIl1cXFwiKX0pKX0pLFxcXCJNYXRyaXg0eDRcXFwiLFtdKSx0fTtcIixcInNyYy9saWIvd2ViZ2wvbWF0aC5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKGUpe3ZhciBuPXt9O3JldHVybiBuLk1hdDQ0PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobiwoZnVuY3Rpb24oZSx0KXt0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LmxvYWRJZGVudGl0eSxbZV0pLGUuc3RhY2s9W119KSksdC5wdXNoPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe2Uuc3RhY2sucHVzaChlLmVsZW1lbnRzLnNsaWNlKDApKX0pKSx0LnBvcD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtlLmVsZW1lbnRzPWUuc3RhY2sucG9wKCl9KSksdC5sb2FkSWRlbnRpdHk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7ZS5lbGVtZW50cz1bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV19KSksdC50cmFuc2Zvcm0zPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsdCl7dmFyIGw9ZS5lbGVtZW50cztyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uVmVjMyxbbFswXSp0LngrbFs0XSp0LnkrbFs4XSp0LnosbFsxXSp0LngrbFs1XSp0LnkrbFs5XSp0LnosbFsyXSp0LngrbFs2XSp0LnkrbFsxMF0qdC56XSl9KSksdC5zY2FsZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4sdCxsKXtyZXR1cm4gZS5lbGVtZW50c1swXSo9bixlLmVsZW1lbnRzWzFdKj1uLGUuZWxlbWVudHNbMl0qPW4sZS5lbGVtZW50c1szXSo9bixlLmVsZW1lbnRzWzRdKj10LGUuZWxlbWVudHNbNV0qPXQsZS5lbGVtZW50c1s2XSo9dCxlLmVsZW1lbnRzWzddKj10LGUuZWxlbWVudHNbOF0qPWwsZS5lbGVtZW50c1s5XSo9bCxlLmVsZW1lbnRzWzEwXSo9bCxlLmVsZW1lbnRzWzExXSo9bCxlfSkpLHQudHJhbnNsYXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbix0LGwpe3JldHVybiBlLmVsZW1lbnRzWzEyXSs9ZS5lbGVtZW50c1swXSpuK2UuZWxlbWVudHNbNF0qdCtlLmVsZW1lbnRzWzhdKmwsZS5lbGVtZW50c1sxM10rPWUuZWxlbWVudHNbMV0qbitlLmVsZW1lbnRzWzVdKnQrZS5lbGVtZW50c1s5XSpsLGUuZWxlbWVudHNbMTRdKz1lLmVsZW1lbnRzWzJdKm4rZS5lbGVtZW50c1s2XSp0K2UuZWxlbWVudHNbMTBdKmwsZS5lbGVtZW50c1sxNV0rPWUuZWxlbWVudHNbM10qbitlLmVsZW1lbnRzWzddKnQrZS5lbGVtZW50c1sxMV0qbCxlfSkpLHQucm90YXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsdCxsLHMsbSl7dmFyIGksYSxjLHUscixmLG8sayxTLHksYix2PU1hdGguc3FydChsKmwrcypzK20qbSksXz1NYXRoLnNpbih0Kk1hdGguUEkvMTgwKSx3PU1hdGguY29zKHQqTWF0aC5QSS8xODApO3Y+MCYmKGk9KGwvPXYpKmwsYT0ocy89dikqcyxjPShtLz12KSptLHU9bCpzLHI9cyptLGY9bSpsLG89bCpfLGs9cypfLFM9bSpfLHk9MS13LChiPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLk1hdDQ0KSkuZWxlbWVudHNbMF09eSppK3csYi5lbGVtZW50c1sxXT15KnUtUyxiLmVsZW1lbnRzWzJdPXkqZitrLGIuZWxlbWVudHNbM109MCxiLmVsZW1lbnRzWzRdPXkqdStTLGIuZWxlbWVudHNbNV09eSphK3csYi5lbGVtZW50c1s2XT15KnItbyxiLmVsZW1lbnRzWzddPTAsYi5lbGVtZW50c1s4XT15KmYtayxiLmVsZW1lbnRzWzldPXkqcitvLGIuZWxlbWVudHNbMTBdPXkqYyt3LGIuZWxlbWVudHNbMTFdPTAsYi5lbGVtZW50c1sxMl09MCxiLmVsZW1lbnRzWzEzXT0wLGIuZWxlbWVudHNbMTRdPTAsYi5lbGVtZW50c1sxNV09MSxiPWIubXVsdGlwbHkoZSksZS5lbGVtZW50cz1iLmVsZW1lbnRzKTtyZXR1cm4gZX0pKSx0Lm11bHRpcGx5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBsPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLk1hdDQ0KSxzPTA7czw0O3MrKylsLmVsZW1lbnRzWzQqcyswXT1lLmVsZW1lbnRzWzQqcyswXSp0LmVsZW1lbnRzWzBdK2UuZWxlbWVudHNbNCpzKzFdKnQuZWxlbWVudHNbNF0rZS5lbGVtZW50c1s0KnMrMl0qdC5lbGVtZW50c1s4XStlLmVsZW1lbnRzWzQqcyszXSp0LmVsZW1lbnRzWzEyXSxsLmVsZW1lbnRzWzQqcysxXT1lLmVsZW1lbnRzWzQqcyswXSp0LmVsZW1lbnRzWzFdK2UuZWxlbWVudHNbNCpzKzFdKnQuZWxlbWVudHNbNV0rZS5lbGVtZW50c1s0KnMrMl0qdC5lbGVtZW50c1s5XStlLmVsZW1lbnRzWzQqcyszXSp0LmVsZW1lbnRzWzEzXSxsLmVsZW1lbnRzWzQqcysyXT1lLmVsZW1lbnRzWzQqcyswXSp0LmVsZW1lbnRzWzJdK2UuZWxlbWVudHNbNCpzKzFdKnQuZWxlbWVudHNbNl0rZS5lbGVtZW50c1s0KnMrMl0qdC5lbGVtZW50c1sxMF0rZS5lbGVtZW50c1s0KnMrM10qdC5lbGVtZW50c1sxNF0sbC5lbGVtZW50c1s0KnMrM109ZS5lbGVtZW50c1s0KnMrMF0qdC5lbGVtZW50c1szXStlLmVsZW1lbnRzWzQqcysxXSp0LmVsZW1lbnRzWzddK2UuZWxlbWVudHNbNCpzKzJdKnQuZWxlbWVudHNbMTFdK2UuZWxlbWVudHNbNCpzKzNdKnQuZWxlbWVudHNbMTVdO3JldHVybiBlLmVsZW1lbnRzPWwuZWxlbWVudHMsZX0pKSx0Lmxvb2tBdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLHQsbCxzLG0saSxhLGMsdSxyKXt2YXIgZj1bdC1tLGwtaSxzLWFdLG89TWF0aC5zcXJ0KGZbMF0qZlswXStmWzFdKmZbMV0rZlsyXSpmWzJdKTtvJiYoZlswXS89byxmWzFdLz1vLGZbMl0vPW8pO3ZhciBrPVtjLHUscl0sUz1bXTtTWzBdPWtbMV0qZlsyXS1rWzJdKmZbMV0sU1sxXT0ta1swXSpmWzJdK2tbMl0qZlswXSxTWzJdPWtbMF0qZlsxXS1rWzFdKmZbMF0sa1swXT1mWzFdKlNbMl0tZlsyXSpTWzFdLGtbMV09LWZbMF0qU1syXStmWzJdKlNbMF0sa1syXT1mWzBdKlNbMV0tZlsxXSpTWzBdLChvPU1hdGguc3FydChTWzBdKlNbMF0rU1sxXSpTWzFdK1NbMl0qU1syXSkpJiYoU1swXS89byxTWzFdLz1vLFNbMl0vPW8pLChvPU1hdGguc3FydChrWzBdKmtbMF0ra1sxXSprWzFdK2tbMl0qa1syXSkpJiYoa1swXS89byxrWzFdLz1vLGtbMl0vPW8pO3ZhciB5PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLk1hdDQ0KTtyZXR1cm4geS5lbGVtZW50c1swXT1TWzBdLHkuZWxlbWVudHNbNF09U1sxXSx5LmVsZW1lbnRzWzhdPVNbMl0seS5lbGVtZW50c1sxMl09MCx5LmVsZW1lbnRzWzFdPWtbMF0seS5lbGVtZW50c1s1XT1rWzFdLHkuZWxlbWVudHNbOV09a1syXSx5LmVsZW1lbnRzWzEzXT0wLHkuZWxlbWVudHNbMl09ZlswXSx5LmVsZW1lbnRzWzZdPWZbMV0seS5lbGVtZW50c1sxMF09ZlsyXSx5LmVsZW1lbnRzWzE0XT0wLHkuZWxlbWVudHNbM109MCx5LmVsZW1lbnRzWzddPTAseS5lbGVtZW50c1sxMV09MCx5LmVsZW1lbnRzWzE1XT0xLHk9eS5tdWx0aXBseShlKSxlLmVsZW1lbnRzPXkuZWxlbWVudHMsZS50cmFuc2xhdGUoLXQsLWwsLXMpLGV9KSl9KSxcXFwiTWF0NDRcXFwiLFtdKSxuLk1hdDMzPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobiwoZnVuY3Rpb24oZSxuKXtuLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLmxvYWRJZGVudGl0eSxbZV0pfSkpLG4ubG9hZElkZW50aXR5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe2UuZWxlbWVudHM9WzEsMCwwLDAsMSwwLDAsMCwxXX0pKX0pLFxcXCJNYXQzM1xcXCIsW10pLG4uVmVjMz1Tay5taXNjZXZhbC5idWlsZENsYXNzKG4sKGZ1bmN0aW9uKGUsdCl7dC5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4sdCxsKXtlLng9bixlLnk9dCxlLno9bH0pKSx0Ll9fc3ViX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSx0KXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uVmVjMyxbZS54LXQueCxlLnktdC55LGUuei10LnpdKX0pKX0pLFxcXCJWZWMzXFxcIixbXSksbi5jcm9zcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLHQpe3JldHVybiBTay5hc3NlcnRzLmFzc2VydChlIGluc3RhbmNlb2Ygbi5WZWMzJiZ0IGluc3RhbmNlb2Ygbi5WZWMzKSxTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5WZWMzLFtlLnkqdC56LWUueip0LnksZS56KnQueC1lLngqdC56LGUueCp0LnktZS55KnQueF0pfSkpLG59O1wiLFwic3JjL2xpYi93ZWJnbC9tYXRyaXg0LmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7dmFyIHI9e30sdD1uZXcgRmxvYXQzMkFycmF5KDMpLGE9bmV3IEZsb2F0MzJBcnJheSgzKSx1PW5ldyBGbG9hdDMyQXJyYXkoMyksZT0obmV3IEZsb2F0MzJBcnJheSg0KSxuZXcgRmxvYXQzMkFycmF5KDQpLG5ldyBGbG9hdDMyQXJyYXkoNCksbmV3IEZsb2F0MzJBcnJheSgxNiksbmV3IEZsb2F0MzJBcnJheSgxNiksbmV3IEZsb2F0MzJBcnJheSgxNiksZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9MCxhPXIubGVuZ3RoLHU9MDt1PGE7Kyt1KXQrPXJbdV0qclt1XTtpZigodD1NYXRoLnNxcnQodCkpPjFlLTUpZm9yKHU9MDt1PGE7Kyt1KW5bdV09clt1XS90O2Vsc2UgZm9yKHU9MDt1PGE7Kyt1KW5bdV09MDtyZXR1cm4gbn0pLGNyb3NzPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gblswXT1yWzFdKnRbMl0tclsyXSp0WzFdLG5bMV09clsyXSp0WzBdLXJbMF0qdFsyXSxuWzJdPXJbMF0qdFsxXS1yWzFdKnRbMF0sbn0sZG90PWZ1bmN0aW9uKG4scil7cmV0dXJuIG5bMF0qclswXStuWzFdKnJbMV0rblsyXSpyWzJdfTtyZXR1cm4gci5sb29rQXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixyLGksbyl7dmFyIHY9YSxmPXUsbD1lKHQsZnVuY3Rpb24obixyLHQpe2Zvcih2YXIgYT1yLmxlbmd0aCx1PTA7dTxhOysrdSluW3VdPXJbdV0tdFt1XTtyZXR1cm4gbn0odCxyLnYsaS52KSksYz1lKHYsY3Jvc3ModixvLnYsbCkpLHc9Y3Jvc3MoZixsLGMpLGg9bi52O3JldHVybiBoWzBdPWNbMF0saFsxXT13WzBdLGhbMl09bFswXSxoWzNdPTAsaFs0XT1jWzFdLGhbNV09d1sxXSxoWzZdPWxbMV0saFs3XT0wLGhbOF09Y1syXSxoWzldPXdbMl0saFsxMF09bFsyXSxoWzExXT0wLGhbMTJdPS1kb3QoYyxyLnYpLGhbMTNdPS1kb3QodyxyLnYpLGhbMTRdPS1kb3QobCxyLnYpLGhbMTVdPTEsbn0pKSxyLnBlcnNwZWN0aXZlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4scix0LGEsdSl7dmFyIGU9TWF0aC50YW4oLjUqTWF0aC5QSS1yKk1hdGguUEkvMTgwKi41KSxpPTEvKGEtdSksbz1uLnY7cmV0dXJuIG9bMF09ZS90LG9bMV09MCxvWzJdPTAsb1szXT0wLG9bNF09MCxvWzVdPWUsb1s2XT0wLG9bN109MCxvWzhdPTAsb1s5XT0wLG9bMTBdPShhK3UpKmksb1sxMV09LTEsb1sxMl09MCxvWzEzXT0wLG9bMTRdPWEqdSppKjIsb1sxNV09MCxufSkpLHIucm90YXRpb25ZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4scil7dmFyIHQ9bi52LGE9TWF0aC5jb3MocipNYXRoLlBJLzE4MCksdT1NYXRoLnNpbihyKk1hdGguUEkvMTgwKTtyZXR1cm4gdFswXT1hLHRbMV09MCx0WzJdPS11LHRbM109MCx0WzRdPTAsdFs1XT0xLHRbNl09MCx0WzddPTAsdFs4XT11LHRbOV09MCx0WzEwXT1hLHRbMTFdPTAsdFsxMl09MCx0WzEzXT0wLHRbMTRdPTAsdFsxNV09MSxufSkpLHIuaWRlbnRpdHk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7dmFyIHI9bi52O3JldHVybiByWzBdPTEsclsxXT0wLHJbMl09MCxyWzNdPTAscls0XT0wLHJbNV09MSxyWzZdPTAscls3XT0wLHJbOF09MCxyWzldPTAsclsxMF09MSxyWzExXT0wLHJbMTJdPTAsclsxM109MCxyWzE0XT0wLHJbMTVdPTEsbn0pKSxyLm11bD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHIsdCl7dmFyIGE9bi52LHU9ci52LGU9dC52LGk9dVswXSxvPXVbMV0sdj11WzJdLGY9dVszXSxsPXVbNF0sYz11WzVdLHc9dVs2XSxoPXVbN10seT11WzhdLEE9dVs5XSxGPXVbMTBdLGI9dVsxMV0saz11WzEyXSxNPXVbMTNdLHM9dVsxNF0sUz11WzE1XSxJPWVbMF0sUD1lWzFdLHA9ZVsyXSxkPWVbM10sZz1lWzRdLG09ZVs1XSxxPWVbNl0sWT1lWzddLCQ9ZVs4XSxqPWVbOV0seD1lWzEwXSx6PWVbMTFdLEI9ZVsxMl0sQz1lWzEzXSxEPWVbMTRdLEU9ZVsxNV07cmV0dXJuIGFbMF09aSpJK28qZyt2KiQrZipCLGFbMV09aSpQK28qbSt2KmorZipDLGFbMl09aSpwK28qcSt2KngrZipELGFbM109aSpkK28qWSt2KnorZipFLGFbNF09bCpJK2MqZyt3KiQraCpCLGFbNV09bCpQK2MqbSt3KmoraCpDLGFbNl09bCpwK2MqcSt3KngraCpELGFbN109bCpkK2MqWSt3KnoraCpFLGFbOF09eSpJK0EqZytGKiQrYipCLGFbOV09eSpQK0EqbStGKmorYipDLGFbMTBdPXkqcCtBKnErRip4K2IqRCxhWzExXT15KmQrQSpZK0YqeitiKkUsYVsxMl09aypJK00qZytzKiQrUypCLGFbMTNdPWsqUCtNKm0rcypqK1MqQyxhWzE0XT1rKnArTSpxK3MqeCtTKkQsYVsxNV09aypkK00qWStzKnorUypFLG59KSksci5pbnZlcnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixyKXt2YXIgdD1uLnYsYT1yLnYsdT1hWzBdLGU9YVsxXSxpPWFbMl0sbz1hWzNdLHY9YVs0XSxmPWFbNV0sbD1hWzZdLGM9YVs3XSx3PWFbOF0saD1hWzldLHk9YVsxMF0sQT1hWzExXSxGPWFbMTJdLGI9YVsxM10saz1hWzE0XSxNPWFbMTVdLHM9eSpNLFM9aypBLEk9bCpNLFA9aypjLHA9bCpBLGQ9eSpjLGc9aSpNLG09aypvLHE9aSpBLFk9eSpvLCQ9aSpjLGo9bCpvLHg9dypiLHo9RipoLEI9dipiLEM9RipmLEQ9dipoLEU9dypmLEc9dSpiLEg9RiplLEo9dSpoLEs9dyplLEw9dSpmLE49diplLE89cypmK1AqaCtwKmItKFMqZitJKmgrZCpiKSxRPVMqZStnKmgrWSpiLShzKmUrbSpoK3EqYiksUj1JKmUrbSpmKyQqYi0oUCplK2cqZitqKmIpLFQ9ZCplK3EqZitqKmgtKHAqZStZKmYrJCpoKSxVPTEvKHUqTyt2KlErdypSK0YqVCk7cmV0dXJuIHRbMF09VSpPLHRbMV09VSpRLHRbMl09VSpSLHRbM109VSpULHRbNF09VSooUyp2K0kqdytkKkYtKHMqditQKncrcCpGKSksdFs1XT1VKihzKnUrbSp3K3EqRi0oUyp1K2cqdytZKkYpKSx0WzZdPVUqKFAqdStnKnYraipGLShJKnUrbSp2KyQqRikpLHRbN109VSoocCp1K1kqdiskKnctKGQqdStxKnYraip3KSksdFs4XT1VKih4KmMrQypBK0QqTS0oeipjK0IqQStFKk0pKSx0WzldPVUqKHoqbytHKkErSypNLSh4Km8rSCpBK0oqTSkpLHRbMTBdPVUqKEIqbytIKmMrTCpNLShDKm8rRypjK04qTSkpLHRbMTFdPVUqKEUqbytKKmMrTipBLShEKm8rSypjK0wqQSkpLHRbMTJdPVUqKEIqeStFKmsreipsLShEKmsreCpsK0MqeSkpLHRbMTNdPVUqKEoqayt4KmkrSCp5LShHKnkrSyprK3oqaSkpLHRbMTRdPVUqKEcqbCtOKmsrQyppLShMKmsrQippK0gqbCkpLHRbMTVdPVUqKEwqeStEKmkrSypsLShKKmwrTip5K0UqaSkpLG59KSksci50cmFuc3Bvc2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9bi52LGE9ci52LHU9MDt1PDQ7Kyt1KWZvcih2YXIgZT0wO2U8NDsrK2UpdFs0KnUrZV09YVs0KmUrdV07cmV0dXJuIHR9KSkscn07XCIsXCJzcmMvbGliL3dlYmdsL21vZGVscy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKHQpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRNb2R1bGUoXFxcIndlYmdsXFxcIiwhMSwhMCksKGU9Pntjb25zdCBuPWUuJGQ7dmFyIHI9e30sQnVmZmVyPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZXx8bi5BUlJBWV9CVUZGRVIsaT1uLmNyZWF0ZUJ1ZmZlcigpO2lmKHRoaXMudGFyZ2V0PXIsdGhpcy5idWY9aSx0aGlzLnNldCh0KSx0aGlzLm51bUNvbXBvbmVudHNfPXQubnVtQ29tcG9uZW50cyx0aGlzLm51bUVsZW1lbnRzXz10Lm51bUVsZW1lbnRzLHRoaXMudG90YWxDb21wb25lbnRzXz10aGlzLm51bUNvbXBvbmVudHNfKnRoaXMubnVtRWxlbWVudHNfLHQuYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXRoaXMudHlwZV89bi5GTE9BVDtlbHNlIGlmKHQuYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSl0aGlzLnR5cGVfPW4uVU5TSUdORURfQllURTtlbHNlIGlmKHQuYnVmZmVyIGluc3RhbmNlb2YgSW50OEFycmF5KXRoaXMudHlwZV89bi5fQllURTtlbHNlIGlmKHQuYnVmZmVyIGluc3RhbmNlb2YgVWludDE2QXJyYXkpdGhpcy50eXBlXz1uLlVOU0lHTkVEX1NIT1JUO2Vsc2V7aWYoISh0LmJ1ZmZlciBpbnN0YW5jZW9mIEludDE2QXJyYXkpKXRocm93XFxcInVuaGFuZGxlZCB0eXBlOlxcXCIrdHlwZW9mIHQuYnVmZmVyO3RoaXMudHlwZV89bi5TSE9SVH19O3JldHVybiBCdWZmZXIucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtuLmJpbmRCdWZmZXIodGhpcy50YXJnZXQsdGhpcy5idWYpLG4uYnVmZmVyRGF0YSh0aGlzLnRhcmdldCx0LmJ1ZmZlcixuLlNUQVRJQ19EUkFXKX0sQnVmZmVyLnByb3RvdHlwZS50eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHlwZV99LEJ1ZmZlci5wcm90b3R5cGUubnVtQ29tcG9uZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bUNvbXBvbmVudHNffSxCdWZmZXIucHJvdG90eXBlLm51bUVsZW1lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtRWxlbWVudHNffSxCdWZmZXIucHJvdG90eXBlLnRvdGFsQ29tcG9uZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvdGFsQ29tcG9uZW50c199LEJ1ZmZlci5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmfSxCdWZmZXIucHJvdG90eXBlLnN0cmlkZT1mdW5jdGlvbigpe3JldHVybiAwfSxCdWZmZXIucHJvdG90eXBlLm9mZnNldD1mdW5jdGlvbigpe3JldHVybiAwfSxyLk1vZGVsPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MociwoZnVuY3Rpb24oZSxyKXtyLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUscixpLGYpe2UuYnVmZmVycz17fTt2YXIgc2V0QnVmZmVyPWZ1bmN0aW9uKHQscil7dmFyIGk9XFxcImluZGljZXNcXFwiPT10P24uRUxFTUVOVF9BUlJBWV9CVUZGRVI6bi5BUlJBWV9CVUZGRVI7bGV0IGY9ZS5idWZmZXJzW3RdO2Y/Zi5zZXQocik6Zj1uZXcgQnVmZmVyKHIsaSksZS5idWZmZXJzW3RdPWZ9O2Zvcih0IGluIGkpc2V0QnVmZmVyKHQsaVt0XSk7dmFyIG89e30scz0wO2Zvcih2YXIgdSBpbiBmKW9bdV09cysrO2UubW9kZT1uLlRSSUFOR0xFUyxlLnRleHR1cmVzPWYudixlLnRleHR1cmVVbml0cz1vLGUuc2hhZGVyPXJ9KSksci5kcmF3UHJlcD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbih0LGUpe3ZhciByPXQuc2hhZGVyLGk9dC5idWZmZXJzLGY9dC50ZXh0dXJlcztmb3IodmFyIG8gaW4gZT1Tay5mZmkucmVtYXBUb0pzKGUpLFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShyLnVzZSxbcl0pLGkpe3ZhciBzPWlbb107aWYoXFxcImluZGljZXNcXFwiPT1vKW4uYmluZEJ1ZmZlcihuLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHMuYnVmZmVyKCkpO2Vsc2V7dmFyIHU9ci5hdHRyaWJbb107dSYmdShzKX19Zm9yKHZhciBhIGluIGYpe3ZhciBtPXQudGV4dHVyZVVuaXRzW2FdO3Iuc2V0VW5pZm9ybSRpbXBsKHIsZixtKSxmW2FdLmJpbmRUb1VuaXQobSl9Zm9yKHZhciBwIGluIGUpci5zZXRVbmlmb3JtJGltcGwocixwLGVbcF0pfSkpLHIuZHJhdz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbih0LGUscil7dmFyIGk9dC5zaGFkZXI7ZT1Tay5mZmkucmVtYXBUb0pzKGUpO2ZvcihsZXQgbiBpbiBlKWkuc2V0VW5pZm9ybSRpbXBsKGksbixlW25dKTtpZihyKWZvcih2YXIgZiBpbiByKXt2YXIgbz10LnRleHR1cmVVbml0c1tmXTtpLnNldFVuaWZvcm0kaW1wbChpLGYsbykscltmXS5iaW5kVG9Vbml0KG8pfXZhciBzPXQuYnVmZmVycztuLmRyYXdFbGVtZW50cyh0Lm1vZGUscy5pbmRpY2VzLnRvdGFsQ29tcG9uZW50cygpLG4uVU5TSUdORURfU0hPUlQsMCl9KSl9KSxcXFwiTW9kZWxcXFwiLFtdKSxyfSkpfTtcIixcInNyYy9saWIvd2ViZ2wvcHJpbWl0aXZlcy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKHQpe3ZhciBuPXt9LEF0dHJpYkJ1ZmZlcj1mdW5jdGlvbih0LG4sZSl7ZT1lfHxcXFwiRmxvYXQzMkFycmF5XFxcIjt2YXIgcj13aW5kb3dbZV07bi5sZW5ndGg/KHRoaXMuYnVmZmVyPW5ldyByKG4pLG49dGhpcy5idWZmZXIubGVuZ3RoL3QsdGhpcy5jdXJzb3I9bik6KHRoaXMuYnVmZmVyPW5ldyByKHQqbiksdGhpcy5jdXJzb3I9MCksdGhpcy5udW1Db21wb25lbnRzPXQsdGhpcy5udW1FbGVtZW50cz1uLHRoaXMudHlwZT1lfTtyZXR1cm4gQXR0cmliQnVmZmVyLnByb3RvdHlwZS5zdHJpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sQXR0cmliQnVmZmVyLnByb3RvdHlwZS5vZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sQXR0cmliQnVmZmVyLnByb3RvdHlwZS5nZXRFbGVtZW50PWZ1bmN0aW9uKHQpe2Zvcih2YXIgbj10KnRoaXMubnVtQ29tcG9uZW50cyxlPVtdLHI9MDtyPHRoaXMubnVtQ29tcG9uZW50czsrK3IpZS5wdXNoKHRoaXMuYnVmZmVyW24rcl0pO3JldHVybiBlfSxBdHRyaWJCdWZmZXIucHJvdG90eXBlLnNldEVsZW1lbnQ9ZnVuY3Rpb24odCxuKXtmb3IodmFyIGU9dCp0aGlzLm51bUNvbXBvbmVudHMscj0wO3I8dGhpcy5udW1Db21wb25lbnRzOysrcil0aGlzLmJ1ZmZlcltlK3JdPW5bcl19LEF0dHJpYkJ1ZmZlci5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXR0cmliQnVmZmVyKHRoaXMubnVtQ29tcG9uZW50cyx0aGlzLm51bUVsZW1lbnRzLHRoaXMudHlwZSk7cmV0dXJuIHQucHVzaEFycmF5KHRoaXMpLHR9LEF0dHJpYkJ1ZmZlci5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0KXt0aGlzLnNldEVsZW1lbnQodGhpcy5jdXJzb3IrKyx0KX0sQXR0cmliQnVmZmVyLnByb3RvdHlwZS5wdXNoQXJyYXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTA7bjx0Lm51bUVsZW1lbnRzOysrbil0aGlzLnB1c2godC5nZXRFbGVtZW50KG4pKX0sQXR0cmliQnVmZmVyLnByb3RvdHlwZS5wdXNoQXJyYXlXaXRoT2Zmc2V0PWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlPTA7ZTx0Lm51bUVsZW1lbnRzOysrZSl7Zm9yKHZhciByPXQuZ2V0RWxlbWVudChlKSxvPTA7bzxuLmxlbmd0aDsrK28pcltvXSs9bltvXTt0aGlzLnB1c2gocil9fSxBdHRyaWJCdWZmZXIucHJvdG90eXBlLmNvbXB1dGVFeHRlbnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubnVtRWxlbWVudHMsbj10aGlzLm51bUNvbXBvbmVudHMsZT10aGlzLmdldEVsZW1lbnQoMCkscj10aGlzLmdldEVsZW1lbnQoMCksbz0xO288dDsrK28pZm9yKHZhciBzPXRoaXMuZ2V0RWxlbWVudChvKSx1PTA7dTxuOysrdSllW3VdPU1hdGgubWluKGVbdV0sc1t1XSksclt1XT1NYXRoLm1heChyW3VdLHNbdV0pO3JldHVybnttaW46ZSxtYXg6cn19LG4uY3JlYXRlQ3ViZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbih0KXtmb3IodmFyIG49W1szLDcsNSwxXSxbMCw0LDYsMl0sWzYsNywzLDJdLFswLDEsNSw0XSxbNSw3LDYsNF0sWzIsMywxLDBdXSxlPXQvMixyPVtbLWUsLWUsLWVdLFsrZSwtZSwtZV0sWy1lLCtlLC1lXSxbK2UsK2UsLWVdLFstZSwtZSwrZV0sWytlLC1lLCtlXSxbLWUsK2UsK2VdLFsrZSwrZSwrZV1dLG89W1sxLDAsMF0sWy0xLDAsMF0sWzAsMSwwXSxbMCwtMSwwXSxbMCwwLDFdLFswLDAsLTFdXSxzPVtbMCwwXSxbMSwwXSxbMSwxXSxbMCwxXV0sdT1uZXcgQXR0cmliQnVmZmVyKDMsMjQpLGk9bmV3IEF0dHJpYkJ1ZmZlcigzLDI0KSxoPW5ldyBBdHRyaWJCdWZmZXIoMiwyNCkscD1uZXcgQXR0cmliQnVmZmVyKDMsMTIsXFxcIlVpbnQxNkFycmF5XFxcIiksbT0wO208NjsrK20pe2Zvcih2YXIgZj1uW21dLGE9MDthPDQ7KythKXt2YXIgbD1yW2ZbYV1dLGM9b1ttXSx5PXNbYV07dS5wdXNoKGwpLGkucHVzaChjKSxoLnB1c2goeSl9dmFyIHY9NCptO3AucHVzaChbdiswLHYrMSx2KzJdKSxwLnB1c2goW3YrMCx2KzIsdiszXSl9cmV0dXJue3Bvc2l0aW9uOnUsbm9ybWFsOmksdGV4Q29vcmQ6aCxpbmRpY2VzOnB9fSkpLG59O1wifX0iLCIoZnVuY3Rpb24oKXsvKlxuIHVuaWNvZGVfaGFjay5qc1xuICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDEyICBNYXJjZWxvIEdpYnNvbiBkZSBDYXN0cm8gR29uw6dhbHZlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIENvcHlpbmcgYW5kIGRpc3RyaWJ1dGlvbiBvZiB0aGlzIGZpbGUsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gICAgYXJlIHBlcm1pdHRlZCBpbiBhbnkgbWVkaXVtIHdpdGhvdXQgcm95YWx0eSBwcm92aWRlZCB0aGUgY29weXJpZ2h0XG4gICAgbm90aWNlIGFuZCB0aGlzIG5vdGljZSBhcmUgcHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIG9mZmVyZWQgYXMtaXMsXG4gICAgd2l0aG91dCBhbnkgd2FycmFudHkuXG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciAkanNjb21wPSRqc2NvbXB8fHt9OyRqc2NvbXAuc2NvcGU9e307JGpzY29tcC5BU1NVTUVfRVM1PSExOyRqc2NvbXAuQVNTVU1FX05PX05BVElWRV9NQVA9ITE7JGpzY29tcC5BU1NVTUVfTk9fTkFUSVZFX1NFVD0hMTskanNjb21wLlNJTVBMRV9GUk9VTkRfUE9MWUZJTEw9ITE7JGpzY29tcC5JU09MQVRFX1BPTFlGSUxMUz0hMTskanNjb21wLkZPUkNFX1BPTFlGSUxMX1BST01JU0U9ITE7JGpzY29tcC5GT1JDRV9QT0xZRklMTF9QUk9NSVNFX1dIRU5fTk9fVU5IQU5ETEVEX1JFSkVDVElPTj0hMTskanNjb21wLmRlZmluZVByb3BlcnR5PSRqc2NvbXAuQVNTVU1FX0VTNXx8XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnRpZXM/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKEUsUSxiKXtpZihFPT1BcnJheS5wcm90b3R5cGV8fEU9PU9iamVjdC5wcm90b3R5cGUpcmV0dXJuIEU7RVtRXT1iLnZhbHVlO3JldHVybiBFfTtcbiRqc2NvbXAuZ2V0R2xvYmFsPWZ1bmN0aW9uKEUpe0U9W1wib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzJiZnbG9iYWxUaGlzLEUsXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93LFwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmLFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWwmJmdsb2JhbF07Zm9yKHZhciBRPTA7UTxFLmxlbmd0aDsrK1Epe3ZhciBiPUVbUV07aWYoYiYmYi5NYXRoPT1NYXRoKXJldHVybiBifXRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgZ2xvYmFsIG9iamVjdFwiKTt9OyRqc2NvbXAuZ2xvYmFsPSRqc2NvbXAuZ2V0R2xvYmFsKHRoaXMpOyRqc2NvbXAuSVNfU1lNQk9MX05BVElWRT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT09dHlwZW9mIFN5bWJvbChcInhcIik7JGpzY29tcC5UUlVTVF9FUzZfUE9MWUZJTExTPSEkanNjb21wLklTT0xBVEVfUE9MWUZJTExTfHwkanNjb21wLklTX1NZTUJPTF9OQVRJVkU7JGpzY29tcC5wb2x5ZmlsbHM9e307XG4kanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbD17fTskanNjb21wLlBPTFlGSUxMX1BSRUZJWD1cIiRqc2NwJFwiO3ZhciAkanNjb21wJGxvb2t1cFBvbHlmaWxsZWRWYWx1ZT1mdW5jdGlvbihFLFEpe3ZhciBiPSRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW1FdO2lmKG51bGw9PWIpcmV0dXJuIEVbUV07Yj1FW2JdO3JldHVybiB2b2lkIDAhPT1iP2I6RVtRXX07JGpzY29tcC5wb2x5ZmlsbD1mdW5jdGlvbihFLFEsYixmKXtRJiYoJGpzY29tcC5JU09MQVRFX1BPTFlGSUxMUz8kanNjb21wLnBvbHlmaWxsSXNvbGF0ZWQoRSxRLGIsZik6JGpzY29tcC5wb2x5ZmlsbFVuaXNvbGF0ZWQoRSxRLGIsZikpfTtcbiRqc2NvbXAucG9seWZpbGxVbmlzb2xhdGVkPWZ1bmN0aW9uKEUsUSxiLGYpe2I9JGpzY29tcC5nbG9iYWw7RT1FLnNwbGl0KFwiLlwiKTtmb3IoZj0wO2Y8RS5sZW5ndGgtMTtmKyspe3ZhciBlPUVbZl07aWYoIShlIGluIGIpKXJldHVybjtiPWJbZV19RT1FW0UubGVuZ3RoLTFdO2Y9YltFXTtRPVEoZik7USE9ZiYmbnVsbCE9USYmJGpzY29tcC5kZWZpbmVQcm9wZXJ0eShiLEUse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpRfSl9O1xuJGpzY29tcC5wb2x5ZmlsbElzb2xhdGVkPWZ1bmN0aW9uKEUsUSxiLGYpe3ZhciBlPUUuc3BsaXQoXCIuXCIpO0U9MT09PWUubGVuZ3RoO2Y9ZVswXTtmPSFFJiZmIGluICRqc2NvbXAucG9seWZpbGxzPyRqc2NvbXAucG9seWZpbGxzOiRqc2NvbXAuZ2xvYmFsO2Zvcih2YXIgZz0wO2c8ZS5sZW5ndGgtMTtnKyspe3ZhciBrPWVbZ107aWYoIShrIGluIGYpKXJldHVybjtmPWZba119ZT1lW2UubGVuZ3RoLTFdO2I9JGpzY29tcC5JU19TWU1CT0xfTkFUSVZFJiZcImVzNlwiPT09Yj9mW2VdOm51bGw7UT1RKGIpO251bGwhPVEmJihFPyRqc2NvbXAuZGVmaW5lUHJvcGVydHkoJGpzY29tcC5wb2x5ZmlsbHMsZSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlF9KTpRIT09YiYmKHZvaWQgMD09PSRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW2VdJiYoJGpzY29tcC5wcm9wZXJ0eVRvUG9seWZpbGxTeW1ib2xbZV09JGpzY29tcC5JU19TWU1CT0xfTkFUSVZFPyRqc2NvbXAuZ2xvYmFsLlN5bWJvbChlKTpcbiRqc2NvbXAuUE9MWUZJTExfUFJFRklYK2UpLCRqc2NvbXAuZGVmaW5lUHJvcGVydHkoZiwkanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbFtlXSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOlF9KSkpfTskanNjb21wLnBvbHlmaWxsKFwiQXJyYXkucHJvdG90eXBlLmZsYXRcIixmdW5jdGlvbihFKXtyZXR1cm4gRT9FOmZ1bmN0aW9uKFEpe1E9dm9pZCAwPT09UT8xOlE7Zm9yKHZhciBiPVtdLGY9MDtmPHRoaXMubGVuZ3RoO2YrKyl7dmFyIGU9dGhpc1tmXTtBcnJheS5pc0FycmF5KGUpJiYwPFE/KGU9QXJyYXkucHJvdG90eXBlLmZsYXQuY2FsbChlLFEtMSksYi5wdXNoLmFwcGx5KGIsZSkpOmIucHVzaChlKX1yZXR1cm4gYn19LFwiZXM5XCIsXCJlczVcIik7XG4kanNjb21wLnBvbHlmaWxsKFwiQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXCIsZnVuY3Rpb24oRSl7cmV0dXJuIEU/RTpmdW5jdGlvbihRLGIpe3ZhciBmPXRoaXM7ZiBpbnN0YW5jZW9mIFN0cmluZyYmKGY9U3RyaW5nKGYpKTt2YXIgZT1mLmxlbmd0aDtiPWJ8fDA7Zm9yKDA+YiYmKGI9TWF0aC5tYXgoYitlLDApKTtiPGU7YisrKXt2YXIgZz1mW2JdO2lmKGc9PT1RfHxPYmplY3QuaXMoZyxRKSlyZXR1cm4hMH1yZXR1cm4hMX19LFwiZXM3XCIsXCJlczNcIik7JGpzY29tcC5vd25zPWZ1bmN0aW9uKEUsUSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChFLFEpfTskanNjb21wLnBvbHlmaWxsKFwiT2JqZWN0LmVudHJpZXNcIixmdW5jdGlvbihFKXtyZXR1cm4gRT9FOmZ1bmN0aW9uKFEpe3ZhciBiPVtdLGY7Zm9yKGYgaW4gUSkkanNjb21wLm93bnMoUSxmKSYmYi5wdXNoKFtmLFFbZl1dKTtyZXR1cm4gYn19LFwiZXM4XCIsXCJlczNcIik7XG4kanNjb21wLmFycmF5SXRlcmF0b3JJbXBsPWZ1bmN0aW9uKEUpe3ZhciBRPTA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIFE8RS5sZW5ndGg/e2RvbmU6ITEsdmFsdWU6RVtRKytdfTp7ZG9uZTohMH19fTskanNjb21wLmFycmF5SXRlcmF0b3I9ZnVuY3Rpb24oRSl7cmV0dXJue25leHQ6JGpzY29tcC5hcnJheUl0ZXJhdG9ySW1wbChFKX19OyRqc2NvbXAuaW5pdFN5bWJvbD1mdW5jdGlvbigpe307JGpzY29tcC5pdGVyYXRvclByb3RvdHlwZT1mdW5jdGlvbihFKXtFPXtuZXh0OkV9O0VbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtyZXR1cm4gRX07XG4kanNjb21wLnBvbHlmaWxsKFwiT2JqZWN0LmZyb21FbnRyaWVzXCIsZnVuY3Rpb24oRSl7cmV0dXJuIEU/RTpmdW5jdGlvbihRKXt2YXIgYj17fTtpZighKFN5bWJvbC5pdGVyYXRvciBpbiBRKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiXCIrUStcIiBpcyBub3QgaXRlcmFibGVcIik7UT1RW1N5bWJvbC5pdGVyYXRvcl0uY2FsbChRKTtmb3IodmFyIGY9US5uZXh0KCk7IWYuZG9uZTtmPVEubmV4dCgpKXtmPWYudmFsdWU7aWYoT2JqZWN0KGYpIT09Zil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmFibGUgZm9yIGZyb21FbnRyaWVzIHNob3VsZCB5aWVsZCBvYmplY3RzXCIpO2JbZlswXV09ZlsxXX1yZXR1cm4gYn19LFwiZXNfMjAxOVwiLFwiZXMzXCIpO1xuJGpzY29tcC5jaGVja1N0cmluZ0FyZ3M9ZnVuY3Rpb24oRSxRLGIpe2lmKG51bGw9PUUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSAndGhpcycgdmFsdWUgZm9yIFN0cmluZy5wcm90b3R5cGUuXCIrYitcIiBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZFwiKTtpZihRIGluc3RhbmNlb2YgUmVnRXhwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCB0byBTdHJpbmcucHJvdG90eXBlLlwiK2IrXCIgbXVzdCBub3QgYmUgYSByZWd1bGFyIGV4cHJlc3Npb25cIik7cmV0dXJuIEUrXCJcIn07JGpzY29tcC5zdHJpbmdQYWRkaW5nPWZ1bmN0aW9uKEUsUSl7RT12b2lkIDAhPT1FP1N0cmluZyhFKTpcIiBcIjtyZXR1cm4gMDxRJiZFP0UucmVwZWF0KE1hdGguY2VpbChRL0UubGVuZ3RoKSkuc3Vic3RyaW5nKDAsUSk6XCJcIn07XG4kanNjb21wLnBvbHlmaWxsKFwiU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydFwiLGZ1bmN0aW9uKEUpe3JldHVybiBFP0U6ZnVuY3Rpb24oUSxiKXt2YXIgZj0kanNjb21wLmNoZWNrU3RyaW5nQXJncyh0aGlzLG51bGwsXCJwYWRTdGFydFwiKTtyZXR1cm4gJGpzY29tcC5zdHJpbmdQYWRkaW5nKGIsUS1mLmxlbmd0aCkrZn19LFwiZXM4XCIsXCJlczNcIik7JGpzY29tcC5wb2x5ZmlsbChcIk9iamVjdC52YWx1ZXNcIixmdW5jdGlvbihFKXtyZXR1cm4gRT9FOmZ1bmN0aW9uKFEpe3ZhciBiPVtdLGY7Zm9yKGYgaW4gUSkkanNjb21wLm93bnMoUSxmKSYmYi5wdXNoKFFbZl0pO3JldHVybiBifX0sXCJlczhcIixcImVzM1wiKTtcbiRqc2NvbXAuaXRlcmF0b3JGcm9tQXJyYXk9ZnVuY3Rpb24oRSxRKXtFIGluc3RhbmNlb2YgU3RyaW5nJiYoRSs9XCJcIik7dmFyIGI9MCxmPSExLGU9e25leHQ6ZnVuY3Rpb24oKXtpZighZiYmYjxFLmxlbmd0aCl7dmFyIGc9YisrO3JldHVybnt2YWx1ZTpRKGcsRVtnXSksZG9uZTohMX19Zj0hMDtyZXR1cm57ZG9uZTohMCx2YWx1ZTp2b2lkIDB9fX07ZVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBlfTskanNjb21wLnBvbHlmaWxsKFwiQXJyYXkucHJvdG90eXBlLnZhbHVlc1wiLGZ1bmN0aW9uKEUpe3JldHVybiBFP0U6ZnVuY3Rpb24oKXtyZXR1cm4gJGpzY29tcC5pdGVyYXRvckZyb21BcnJheSh0aGlzLGZ1bmN0aW9uKFEsYil7cmV0dXJuIGJ9KX19LFwiZXM4XCIsXCJlczNcIik7XG4oZnVuY3Rpb24oRSl7ZnVuY3Rpb24gUShmKXtpZihiW2ZdKXJldHVybiBiW2ZdLmV4cG9ydHM7dmFyIGU9YltmXT17aTpmLGw6ITEsZXhwb3J0czp7fX07RVtmXS5jYWxsKGUuZXhwb3J0cyxlLGUuZXhwb3J0cyxRKTtlLmw9ITA7cmV0dXJuIGUuZXhwb3J0c312YXIgYj17fTtRLm09RTtRLmM9YjtRLmQ9ZnVuY3Rpb24oZixlLGcpe1EubyhmLGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZixlLHtlbnVtZXJhYmxlOiEwLGdldDpnfSl9O1Eucj1mdW5jdGlvbihmKXtcInVuZGVmaW5lZFwiIT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZixTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX07US50PWZ1bmN0aW9uKGYsZSl7ZSYxJiYoZj1RKGYpKTtpZihlJjh8fGUmNCYmXCJvYmplY3RcIj09PXR5cGVvZiBmJiZmJiZmLl9fZXNNb2R1bGUpcmV0dXJuIGY7XG52YXIgZz1PYmplY3QuY3JlYXRlKG51bGwpO1EucihnKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZyxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTpmfSk7aWYoZSYyJiZcInN0cmluZ1wiIT10eXBlb2YgZilmb3IodmFyIGsgaW4gZilRLmQoZyxrLGZ1bmN0aW9uKHApe3JldHVybiBmW3BdfS5iaW5kKG51bGwsaykpO3JldHVybiBnfTtRLm49ZnVuY3Rpb24oZil7dmFyIGU9ZiYmZi5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGZbXCJkZWZhdWx0XCJdfTpmdW5jdGlvbigpe3JldHVybiBmfTtRLmQoZSxcImFcIixlKTtyZXR1cm4gZX07US5vPWZ1bmN0aW9uKGYsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLGUpfTtRLnA9XCJcIjtyZXR1cm4gUShRLnM9MSl9KShbZnVuY3Rpb24oRSxRKXtRPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e1E9UXx8KG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKSgpfWNhdGNoKGIpe1wib2JqZWN0XCI9PT1cbnR5cGVvZiB3aW5kb3cmJihRPXdpbmRvdyl9RS5leHBvcnRzPVF9LGZ1bmN0aW9uKEUsUSxiKXtiKDIpO1NrLmdsb2JhbC5zdHJmdGltZT1iKDMpO2IoNCk7Yig2KTtiKDcpO2IoOSk7YigxMCk7YigxMSk7YigxMik7YigxMyk7YigxNCk7YigxNSk7YigxNik7YigxNyk7YigxOCk7W1NrLmJ1aWx0aW4ub2JqZWN0LFNrLmJ1aWx0aW4udHlwZV0uZm9yRWFjaChmPT57U2suYWJzdHIuc2V0VXBTbG90cyhmKTtTay5hYnN0ci5zZXRVcE1ldGhvZHMoZik7U2suYWJzdHIuc2V0VXBHZXRTZXRzKGYpO1NrLmFic3RyLnNldFVwQ2xhc3NNZXRob2RzKGYpfSk7YigxOSk7YigyMCk7YigyMSk7W1NrLmJ1aWx0aW4uc3RyLFNrLmJ1aWx0aW4ubm9uZSxTay5idWlsdGluLk5vdEltcGxlbWVudGVkLFNrLmJ1aWx0aW4ub2JqZWN0XS5mb3JFYWNoKGY9PntmPWYucHJvdG90eXBlO2YuX19kb2NfXz1mLmhhc093blByb3BlcnR5KFwidHAkZG9jXCIpP25ldyBTay5idWlsdGluLnN0cihmLnRwJGRvYyk6U2suYnVpbHRpbi5ub25lLm5vbmUkfSk7XG5iKDIyKTtiKDIzKTtiKDI0KTtiKDI1KTtiKDI2KTtiKDI3KTtiKDI4KTtiKDI5KTtiKDMxKTtiKDMyKTtiKDMzKTtiKDM0KTtiKDM1KTtiKDM2KTtiKDM3KTtiKDM4KTtiKDM5KTtiKDQwKTtiKDQxKTtiKDQyKTtiKDQzKTtiKDQ0KTtiKDQ1KTtiKDQ2KTtiKDQ3KTtiKDQ4KTtiKDQ5KTtiKDUwKTtiKDUxKTtiKDUyKTtiKDUzKTtiKDY2KTtiKDU0KTtiKDU1KTtiKDU2KTtiKDU3KTtiKDU4KTtiKDU5KTtiKDYwKTtiKDYxKTtiKDYyKTtiKDYzKTtiKDY0KTtiKDY1KX0sZnVuY3Rpb24oRSxRLGIpeyhmdW5jdGlvbihmKXt2YXIgZT17YnVpbGQ6e2dpdGhhc2g6XCJkNThkYzExYzViZjAyZjVjOTM0MDIwYWVmYTQwMjlkNWE5MGRlYjM0XCIsZGF0ZTpcIjIwMjMtMDItMDJUMDE6MDk6MTMuNTYwWlwifX07ZS5nbG9iYWw9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBmP2Y6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3c/d2luZG93Ont9O2UuZXhwb3J0U3ltYm9sPVxuZnVuY3Rpb24oZyxrKXtnPWcuc3BsaXQoXCIuXCIpO3ZhciBwPWUuZ2xvYmFsLGg7Zm9yKGg9MDtoPGcubGVuZ3RoLTE7aCsrKXt2YXIgYT1nW2hdO3A9cC5oYXNPd25Qcm9wZXJ0eShhKT9wW2FdOnBbYV09e319XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBrJiYoYT1nW2hdLHBbYV09ayl9O2UuaXNBcnJheUxpa2U9ZnVuY3Rpb24oZyl7cmV0dXJuIGcgaW5zdGFuY2VvZiBBcnJheXx8ZyYmZy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBnLmxlbmd0aD8hMDohMX07ZS5qc19iZWF1dGlmeT1mdW5jdGlvbihnKXtyZXR1cm4gZ307ZS5leHBvcnRTeW1ib2woXCJTa1wiLGUpO2UuZXhwb3J0U3ltYm9sKFwiU2suZ2xvYmFsXCIsZS5nbG9iYWwpO2UuZXhwb3J0U3ltYm9sKFwiU2suYnVpbGRcIixlLmJ1aWxkKTtlLmV4cG9ydFN5bWJvbChcIlNrLmV4cG9ydFN5bWJvbFwiLGUuZXhwb3J0U3ltYm9sKTtlLmV4cG9ydFN5bWJvbChcIlNrLmlzQXJyYXlMaWtlXCIsZS5pc0FycmF5TGlrZSk7ZS5leHBvcnRTeW1ib2woXCJTay5qc19iZWF1dGlmeVwiLFxuZS5qc19iZWF1dGlmeSl9KS5jYWxsKHRoaXMsYigwKSl9LGZ1bmN0aW9uKEUsUSl7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihkLGwscil7ZnVuY3Rpb24gdihOLEEsSCx4KXtmb3IodmFyIEI9XCJcIixGPW51bGwsSj0hMSxQPU4ubGVuZ3RoLFc9ITEsY2E9MDtjYTxQO2NhKyspe3ZhciBoYT1OLmNoYXJDb2RlQXQoY2EpO2lmKCEwPT09SilpZig0NT09PWhhKUY9XCJcIjtlbHNlIGlmKDk1PT09aGEpRj1cIiBcIjtlbHNlIGlmKDQ4PT09aGEpRj1cIjBcIjtlbHNlIGlmKDU4PT09aGEpVyYmaChcIltXQVJOSU5HXSBkZXRlY3RlZCB1c2Ugb2YgdW5zdXBwb3J0ZWQgJTo6IG9yICU6OjogbW9kaWZpZXJzIHRvIHN0cmZ0aW1lXCIpLFc9ITA7ZWxzZXtzd2l0Y2goaGEpe2Nhc2UgMzc6Qis9XCIlXCI7YnJlYWs7Y2FzZSA2NTpCKz1ILmRheXNbQS5nZXREYXkoKV07YnJlYWs7Y2FzZSA2NjpCKz1ILm1vbnRoc1tBLmdldE1vbnRoKCldO2JyZWFrO2Nhc2UgNjc6Qis9ZihNYXRoLmZsb29yKEEuZ2V0RnVsbFllYXIoKS9cbjEwMCksRik7YnJlYWs7Y2FzZSA2ODpCKz12KEguZm9ybWF0cy5ELEEsSCx4KTticmVhaztjYXNlIDcwOkIrPXYoSC5mb3JtYXRzLkYsQSxILHgpO2JyZWFrO2Nhc2UgNzI6Qis9ZihBLmdldEhvdXJzKCksRik7YnJlYWs7Y2FzZSA3MzpCKz1mKGcoQS5nZXRIb3VycygpKSxGKTticmVhaztjYXNlIDc2OkIrPWUoTWF0aC5mbG9vcih4JTFFMykpO2JyZWFrO2Nhc2UgNzc6Qis9ZihBLmdldE1pbnV0ZXMoKSxGKTticmVhaztjYXNlIDgwOkIrPTEyPkEuZ2V0SG91cnMoKT9ILmFtOkgucG07YnJlYWs7Y2FzZSA4MjpCKz12KEguZm9ybWF0cy5SLEEsSCx4KTticmVhaztjYXNlIDgzOkIrPWYoQS5nZXRTZWNvbmRzKCksRik7YnJlYWs7Y2FzZSA4NDpCKz12KEguZm9ybWF0cy5ULEEsSCx4KTticmVhaztjYXNlIDg1OkIrPWYoayhBLFwic3VuZGF5XCIpLEYpO2JyZWFrO2Nhc2UgODc6Qis9ZihrKEEsXCJtb25kYXlcIiksRik7YnJlYWs7Y2FzZSA4ODpCKz12KEguZm9ybWF0cy5YLEEsSCx4KTticmVhaztcbmNhc2UgODk6Qis9QS5nZXRGdWxsWWVhcigpO2JyZWFrO2Nhc2UgOTA6dyYmMD09PXQ/Qis9XCJHTVRcIjooRj1BLnRvU3RyaW5nKCkubWF0Y2goL1xcKChbXFx3XFxzXSspXFwpLyksQis9RiYmRlsxXXx8XCJcIik7YnJlYWs7Y2FzZSA5NzpCKz1ILnNob3J0RGF5c1tBLmdldERheSgpXTticmVhaztjYXNlIDk4OkIrPUguc2hvcnRNb250aHNbQS5nZXRNb250aCgpXTticmVhaztjYXNlIDk5OkIrPXYoSC5mb3JtYXRzLmMsQSxILHgpO2JyZWFrO2Nhc2UgMTAwOkIrPWYoQS5nZXREYXRlKCksRik7YnJlYWs7Y2FzZSAxMDE6Qis9ZihBLmdldERhdGUoKSxudWxsPT1GP1wiIFwiOkYpO2JyZWFrO2Nhc2UgMTA0OkIrPUguc2hvcnRNb250aHNbQS5nZXRNb250aCgpXTticmVhaztjYXNlIDEwNjpGPW5ldyBEYXRlKEEuZ2V0RnVsbFllYXIoKSwwLDEpO0Y9TWF0aC5jZWlsKChBLmdldFRpbWUoKS1GLmdldFRpbWUoKSkvODY0RTUpO0IrPWUoRik7YnJlYWs7Y2FzZSAxMDc6Qis9ZihBLmdldEhvdXJzKCksbnVsbD09XG5GP1wiIFwiOkYpO2JyZWFrO2Nhc2UgMTA4OkIrPWYoZyhBLmdldEhvdXJzKCkpLG51bGw9PUY/XCIgXCI6Rik7YnJlYWs7Y2FzZSAxMDk6Qis9ZihBLmdldE1vbnRoKCkrMSxGKTticmVhaztjYXNlIDExMDpCKz1cIlxcblwiO2JyZWFrO2Nhc2UgMTExOkY9QS5nZXREYXRlKCk7Qj1ILm9yZGluYWxTdWZmaXhlcz9CKyhTdHJpbmcoRikrKEgub3JkaW5hbFN1ZmZpeGVzW0YtMV18fHAoRikpKTpCKyhTdHJpbmcoRikrcChGKSk7YnJlYWs7Y2FzZSAxMTI6Qis9MTI+QS5nZXRIb3VycygpP0guQU06SC5QTTticmVhaztjYXNlIDExNDpCKz12KEguZm9ybWF0cy5yLEEsSCx4KTticmVhaztjYXNlIDExNTpCKz1NYXRoLmZsb29yKHgvMUUzKTticmVhaztjYXNlIDExNjpCKz1cIlxcdFwiO2JyZWFrO2Nhc2UgMTE3OkY9QS5nZXREYXkoKTtCKz0wPT09Rj83OkY7YnJlYWs7Y2FzZSAxMTg6Qis9dihILmZvcm1hdHMudixBLEgseCk7YnJlYWs7Y2FzZSAxMTk6Qis9QS5nZXREYXkoKTticmVhaztjYXNlIDEyMDpCKz1cbnYoSC5mb3JtYXRzLngsQSxILHgpO2JyZWFrO2Nhc2UgMTIxOkIrPShcIlwiK0EuZ2V0RnVsbFllYXIoKSkuc2xpY2UoMik7YnJlYWs7Y2FzZSAxMjI6dyYmMD09PXQ/Qis9Vz9cIiswMDowMFwiOlwiKzAwMDBcIjooRj0wIT09dD90LzZFNDotQS5nZXRUaW1lem9uZU9mZnNldCgpLEo9Vz9cIjpcIjpcIlwiLGhhPU1hdGguYWJzKEYlNjApLEIrPSgwPkY/XCItXCI6XCIrXCIpK2YoTWF0aC5mbG9vcihNYXRoLmFicyhGLzYwKSkpK0orZihoYSkpO2JyZWFrO2RlZmF1bHQ6SiYmKEIrPVwiJVwiKSxCKz1OW2NhXX1GPW51bGw7Sj0hMX1lbHNlIDM3PT09aGE/Sj0hMDpCKz1OW2NhXX1yZXR1cm4gQn12YXIgcT1kfHxjLHQ9bHx8MCx3PXJ8fCExLEM9MCxELEw9ZnVuY3Rpb24oTixBKXtpZihBKXt2YXIgSD1BLmdldFRpbWUoKTtpZih3KXt2YXIgeD02RTQqKEEuZ2V0VGltZXpvbmVPZmZzZXQoKXx8MCk7QT1uZXcgRGF0ZShIK3grdCk7NkU0KihBLmdldFRpbWV6b25lT2Zmc2V0KCl8fDApIT09eCYmKEE9NkU0KihBLmdldFRpbWV6b25lT2Zmc2V0KCl8fFxuMCksQT1uZXcgRGF0ZShIK0ErdCkpfX1lbHNlIEg9RGF0ZS5ub3coKSxIPkM/KEM9SCxEPW5ldyBEYXRlKEMpLEg9Qyx3JiYoRD1uZXcgRGF0ZShDKzZFNCooRC5nZXRUaW1lem9uZU9mZnNldCgpfHwwKSt0KSkpOkg9QyxBPUQ7cmV0dXJuIHYoTixBLHEsSCl9O0wubG9jYWxpemU9ZnVuY3Rpb24oTil7cmV0dXJuIG5ldyBiKE58fHEsdCx3KX07TC5sb2NhbGl6ZUJ5SWRlbnRpZmllcj1mdW5jdGlvbihOKXt2YXIgQT1hW05dO3JldHVybiBBP0wubG9jYWxpemUoQSk6KGgoJ1tXQVJOSU5HXSBObyBsb2NhbGUgZm91bmQgd2l0aCBpZGVudGlmaWVyIFwiJytOKydcIi4nKSxMKX07TC50aW1lem9uZT1mdW5jdGlvbihOKXt2YXIgQT10LEg9dyx4PXR5cGVvZiBOO2lmKFwibnVtYmVyXCI9PT14fHxcInN0cmluZ1wiPT09eClIPSEwLFwic3RyaW5nXCI9PT14PyhBPVwiLVwiPT09TlswXT8tMToxLHg9cGFyc2VJbnQoTi5zbGljZSgxLDMpLDEwKSxOPXBhcnNlSW50KE4uc2xpY2UoMyw1KSwxMCksQT1BKig2MCpcbngrTikqNkU0KTpcIm51bWJlclwiPT09eCYmKEE9NkU0Kk4pO3JldHVybiBuZXcgYihxLEEsSCl9O0wudXRjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBiKHEsdCwhMCl9O3JldHVybiBMfWZ1bmN0aW9uIGYoZCxsKXtpZihcIlwiPT09bHx8OTxkKXJldHVybiBkO251bGw9PWwmJihsPVwiMFwiKTtyZXR1cm4gbCtkfWZ1bmN0aW9uIGUoZCl7cmV0dXJuIDk5PGQ/ZDo5PGQ/XCIwXCIrZDpcIjAwXCIrZH1mdW5jdGlvbiBnKGQpe3JldHVybiAwPT09ZD8xMjoxMjxkP2QtMTI6ZH1mdW5jdGlvbiBrKGQsbCl7bD1sfHxcInN1bmRheVwiO3ZhciByPWQuZ2V0RGF5KCk7XCJtb25kYXlcIj09PWwmJigwPT09cj9yPTY6ci0tKTtsPURhdGUuVVRDKGQuZ2V0RnVsbFllYXIoKSwwLDEpO2Q9RGF0ZS5VVEMoZC5nZXRGdWxsWWVhcigpLGQuZ2V0TW9udGgoKSxkLmdldERhdGUoKSk7cmV0dXJuIE1hdGguZmxvb3IoKE1hdGguZmxvb3IoKGQtbCkvODY0RTUpKzctcikvNyl9ZnVuY3Rpb24gcChkKXt2YXIgbD1kJTEwO2QlPTEwMDtcbmlmKDExPD1kJiYxMz49ZHx8MD09PWx8fDQ8PWwpcmV0dXJuXCJ0aFwiO3N3aXRjaChsKXtjYXNlIDE6cmV0dXJuXCJzdFwiO2Nhc2UgMjpyZXR1cm5cIm5kXCI7Y2FzZSAzOnJldHVyblwicmRcIn19ZnVuY3Rpb24gaChkKXtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKGQpfXZhciBhPXtkZV9ERTp7ZGF5czpcIlNvbm50YWcgTW9udGFnIERpZW5zdGFnIE1pdHR3b2NoIERvbm5lcnN0YWcgRnJlaXRhZyBTYW1zdGFnXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlNvIE1vIERpIE1pIERvIEZyIFNhXCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcIkphbnVhciBGZWJydWFyIE1cXHUwMGU0cnogQXByaWwgTWFpIEp1bmkgSnVsaSBBdWd1c3QgU2VwdGVtYmVyIE9rdG9iZXIgTm92ZW1iZXIgRGV6ZW1iZXJcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJKYW4gRmViIE1cXHUwMGU0ciBBcHIgTWFpIEp1biBKdWwgQXVnIFNlcCBPa3QgTm92IERlelwiLnNwbGl0KFwiIFwiKSxcbkFNOlwiQU1cIixQTTpcIlBNXCIsYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQuJW0uJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LGVuX0NBOntkYXlzOlwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY1wiLnNwbGl0KFwiIFwiKSxvcmRpbmFsU3VmZml4ZXM6XCJzdCBuZCByZCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCBzdCBuZCByZCB0aCB0aCB0aCB0aCB0aCB0aCB0aCBzdFwiLnNwbGl0KFwiIFwiKSxcbkFNOlwiQU1cIixQTTpcIlBNXCIsYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQvJW0vJXlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJXJcIix4OlwiJURcIn19LGVuX1VTOntkYXlzOlwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY1wiLnNwbGl0KFwiIFwiKSxvcmRpbmFsU3VmZml4ZXM6XCJzdCBuZCByZCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCB0aCBzdCBuZCByZCB0aCB0aCB0aCB0aCB0aCB0aCB0aCBzdFwiLnNwbGl0KFwiIFwiKSxcbkFNOlwiQU1cIixQTTpcIlBNXCIsYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJW0vJWQvJXlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJXJcIix4OlwiJURcIn19LGVzX01YOntkYXlzOlwiZG9taW5nbyBsdW5lcyBtYXJ0ZXMgbWlcXHUwMGU5cmNvbGVzIGp1ZXZlcyB2aWVybmVzIHNcXHUwMGUxYmFkb1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJkb20gbHVuIG1hciBtaVxcdTAwZTkganVlIHZpZSBzXFx1MDBlMWJcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiZW5lcm87ZmVicmVybzttYXJ6bzthYnJpbDttYXlvO2p1bmlvO2p1bGlvO2Fnb3N0bztzZXB0aWVtYnJlO29jdHVicmU7bm92aWVtYnJlOyBkaWNpZW1icmVcIi5zcGxpdChcIjtcIiksc2hvcnRNb250aHM6XCJlbmUgZmViIG1hciBhYnIgbWF5IGp1biBqdWwgYWdvIHNlcCBvY3Qgbm92IGRpY1wiLnNwbGl0KFwiIFwiKSxBTTpcIkFNXCIsUE06XCJQTVwiLFxuYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQvJW0vJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LGZyX0ZSOntkYXlzOlwiZGltYW5jaGUgbHVuZGkgbWFyZGkgbWVyY3JlZGkgamV1ZGkgdmVuZHJlZGkgc2FtZWRpXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcImRpbS4gbHVuLiBtYXIuIG1lci4gamV1LiB2ZW4uIHNhbS5cIi5zcGxpdChcIiBcIiksbW9udGhzOlwiamFudmllciBmXFx1MDBlOXZyaWVyIG1hcnMgYXZyaWwgbWFpIGp1aW4ganVpbGxldCBhb1xcdTAwZmJ0IHNlcHRlbWJyZSBvY3RvYnJlIG5vdmVtYnJlIGRcXHUwMGU5Y2VtYnJlXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiamFudi4gZlxcdTAwZTl2ci4gbWFycyBhdnJpbCBtYWkganVpbiBqdWlsLiBhb1xcdTAwZmJ0IHNlcHQuIG9jdC4gbm92LiBkXFx1MDBlOWMuXCIuc3BsaXQoXCIgXCIpLEFNOlwiQU1cIixcblBNOlwiUE1cIixhbTpcImFtXCIscG06XCJwbVwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC8lbS8lWVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0saXRfSVQ6e2RheXM6XCJkb21lbmljYSBsdW5lZFxcdTAwZWMgbWFydGVkXFx1MDBlYyBtZXJjb2xlZFxcdTAwZWMgZ2lvdmVkXFx1MDBlYyB2ZW5lcmRcXHUwMGVjIHNhYmF0b1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJkb20gbHVuIG1hciBtZXIgZ2lvIHZlbiBzYWJcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiZ2VubmFpbyBmZWJicmFpbyBtYXJ6byBhcHJpbGUgbWFnZ2lvIGdpdWdubyBsdWdsaW8gYWdvc3RvIHNldHRlbWJyZSBvdHRvYnJlIG5vdmVtYnJlIGRpY2VtYnJlXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwicHIgbWFnIGdpdSBsdWcgYWdvIHNldCBvdHQgbm92IGRpY1wiLnNwbGl0KFwiIFwiKSxBTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixcbnBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQvJW0vJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LG5sX05MOntkYXlzOlwiem9uZGFnIG1hYW5kYWcgZGluc2RhZyB3b2Vuc2RhZyBkb25kZXJkYWcgdnJpamRhZyB6YXRlcmRhZ1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJ6byBtYSBkaSB3byBkbyB2ciB6YVwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJqYW51YXJpIGZlYnJ1YXJpIG1hYXJ0IGFwcmlsIG1laSBqdW5pIGp1bGkgYXVndXN0dXMgc2VwdGVtYmVyIG9rdG9iZXIgbm92ZW1iZXIgZGVjZW1iZXJcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJqYW4gZmViIG1ydCBhcHIgbWVpIGp1biBqdWwgYXVnIHNlcCBva3Qgbm92IGRlY1wiLnNwbGl0KFwiIFwiKSxBTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsXG5EOlwiJWQtJW0tJXlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LHB0X0JSOntkYXlzOlwiZG9taW5nbyBzZWd1bmRhIHRlclxcdTAwZTdhIHF1YXJ0YSBxdWludGEgc2V4dGEgc1xcdTAwZTFiYWRvXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIkRvbSBTZWcgVGVyIFF1YSBRdWkgU2V4IFNcXHUwMGUxYlwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJqYW5laXJvIGZldmVyZWlybyBtYXJcXHUwMGU3byBhYnJpbCBtYWlvIGp1bmhvIGp1bGhvIGFnb3N0byBzZXRlbWJybyBvdXR1YnJvIG5vdmVtYnJvIGRlemVtYnJvXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiSmFuIEZldiBNYXIgQWJyIE1haSBKdW4gSnVsIEFnbyBTZXQgT3V0IE5vdiBEZXpcIi5zcGxpdChcIiBcIiksQU06XCJBTVwiLFBNOlwiUE1cIixhbTpcImFtXCIscG06XCJwbVwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC0lbS0lWVwiLEY6XCIlWS0lbS0lZFwiLFxuUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVUXCIseDpcIiVEXCJ9fSxydV9SVTp7ZGF5czpcIlxcdTA0MTJcXHUwNDNlXFx1MDQ0MVxcdTA0M2FcXHUwNDQwXFx1MDQzNVxcdTA0NDFcXHUwNDM1XFx1MDQzZFxcdTA0NGNcXHUwNDM1IFxcdTA0MWZcXHUwNDNlXFx1MDQzZFxcdTA0MzVcXHUwNDM0XFx1MDQzNVxcdTA0M2JcXHUwNDRjXFx1MDQzZFxcdTA0MzhcXHUwNDNhIFxcdTA0MTJcXHUwNDQyXFx1MDQzZVxcdTA0NDBcXHUwNDNkXFx1MDQzOFxcdTA0M2EgXFx1MDQyMVxcdTA0NDBcXHUwNDM1XFx1MDQzNFxcdTA0MzAgXFx1MDQyN1xcdTA0MzVcXHUwNDQyXFx1MDQzMlxcdTA0MzVcXHUwNDQwXFx1MDQzMyBcXHUwNDFmXFx1MDQ0ZlxcdTA0NDJcXHUwNDNkXFx1MDQzOFxcdTA0NDZcXHUwNDMwIFxcdTA0MjFcXHUwNDQzXFx1MDQzMVxcdTA0MzFcXHUwNDNlXFx1MDQ0MlxcdTA0MzBcIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiXFx1MDQxMlxcdTA0NDEgXFx1MDQxZlxcdTA0M2QgXFx1MDQxMlxcdTA0NDIgXFx1MDQyMVxcdTA0NDAgXFx1MDQyN1xcdTA0NDIgXFx1MDQxZlxcdTA0NDIgXFx1MDQyMVxcdTA0MzFcIi5zcGxpdChcIiBcIiksXG5tb250aHM6XCJcXHUwNDJmXFx1MDQzZFxcdTA0MzJcXHUwNDMwXFx1MDQ0MFxcdTA0NGMgXFx1MDQyNFxcdTA0MzVcXHUwNDMyXFx1MDQ0MFxcdTA0MzBcXHUwNDNiXFx1MDQ0YyBcXHUwNDFjXFx1MDQzMFxcdTA0NDBcXHUwNDQyIFxcdTA0MTBcXHUwNDNmXFx1MDQ0MFxcdTA0MzVcXHUwNDNiXFx1MDQ0YyBcXHUwNDFjXFx1MDQzMFxcdTA0MzkgXFx1MDQxOFxcdTA0NGVcXHUwNDNkXFx1MDQ0YyBcXHUwNDE4XFx1MDQ0ZVxcdTA0M2JcXHUwNDRjIFxcdTA0MTBcXHUwNDMyXFx1MDQzM1xcdTA0NDNcXHUwNDQxXFx1MDQ0MiBcXHUwNDIxXFx1MDQzNVxcdTA0M2RcXHUwNDQyXFx1MDQ0ZlxcdTA0MzFcXHUwNDQwXFx1MDQ0YyBcXHUwNDFlXFx1MDQzYVxcdTA0NDJcXHUwNDRmXFx1MDQzMVxcdTA0NDBcXHUwNDRjIFxcdTA0MWRcXHUwNDNlXFx1MDQ0ZlxcdTA0MzFcXHUwNDQwXFx1MDQ0YyBcXHUwNDE0XFx1MDQzNVxcdTA0M2FcXHUwNDMwXFx1MDQzMVxcdTA0NDBcXHUwNDRjXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiXFx1MDQ0ZlxcdTA0M2RcXHUwNDMyIFxcdTA0NDRcXHUwNDM1XFx1MDQzMiBcXHUwNDNjXFx1MDQzMFxcdTA0NDAgXFx1MDQzMFxcdTA0M2ZcXHUwNDQwIFxcdTA0M2NcXHUwNDMwXFx1MDQzOSBcXHUwNDM4XFx1MDQ0ZVxcdTA0M2QgXFx1MDQzOFxcdTA0NGVcXHUwNDNiIFxcdTA0MzBcXHUwNDMyXFx1MDQzMyBcXHUwNDQxXFx1MDQzNVxcdTA0M2QgXFx1MDQzZVxcdTA0M2FcXHUwNDQyIFxcdTA0M2RcXHUwNDNlXFx1MDQ0ZiBcXHUwNDM0XFx1MDQzNVxcdTA0M2FcIi5zcGxpdChcIiBcIiksXG5BTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYXCIsRDpcIiVkLiVtLiV5XCIsRjpcIiVZLSVtLSVkXCIsUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVUXCIseDpcIiVEXCJ9fSx0cl9UUjp7ZGF5czpcIlBhemFyIFBhemFydGVzaSBTYWxcXHUwMTMxIFxcdTAwYzdhclxcdTAxNWZhbWJhIFBlclxcdTAxNWZlbWJlIEN1bWEgQ3VtYXJ0ZXNpXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlBheiBQenQgU2FsIFxcdTAwYzdyXFx1MDE1ZiBQclxcdTAxNWYgQ3VtIEN0c1wiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJPY2FrIFxcdTAxNWV1YmF0IE1hcnQgTmlzYW4gTWF5XFx1MDEzMXMgSGF6aXJhbiBUZW1tdXogQVxcdTAxMWZ1c3RvcyBFeWxcXHUwMGZjbCBFa2ltIEthc1xcdTAxMzFtIEFyYWxcXHUwMTMxa1wiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcIk9jYSBcXHUwMTVldWIgTWFyIE5pcyBNYXkgSGF6IFRlbSBBXFx1MDExZnUgRXlsIEVraSBLYXMgQXJhXCIuc3BsaXQoXCIgXCIpLFxuQU06XCJcXHUwMGQ2XFx1MDBkNlwiLFBNOlwiXFx1MDBkNlNcIixhbTpcIlxcdTAwZDZcXHUwMGQ2XCIscG06XCJcXHUwMGQ2U1wiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC0lbS0lWVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0semhfQ046e2RheXM6XCJcXHU2NjFmXFx1NjcxZlxcdTY1ZTUgXFx1NjYxZlxcdTY3MWZcXHU0ZTAwIFxcdTY2MWZcXHU2NzFmXFx1NGU4YyBcXHU2NjFmXFx1NjcxZlxcdTRlMDkgXFx1NjYxZlxcdTY3MWZcXHU1NmRiIFxcdTY2MWZcXHU2NzFmXFx1NGU5NCBcXHU2NjFmXFx1NjcxZlxcdTUxNmRcIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiXFx1NjVlNVxcdTRlMDBcXHU0ZThjXFx1NGUwOVxcdTU2ZGJcXHU0ZTk0XFx1NTE2ZFwiLnNwbGl0KFwiXCIpLG1vbnRoczpcIlxcdTRlMDBcXHU2NzA4XFx1NGVmZCBcXHU0ZThjXFx1NjcwOFxcdTRlZmQgXFx1NGUwOVxcdTY3MDhcXHU0ZWZkIFxcdTU2ZGJcXHU2NzA4XFx1NGVmZCBcXHU0ZTk0XFx1NjcwOFxcdTRlZmQgXFx1NTE2ZFxcdTY3MDhcXHU0ZWZkIFxcdTRlMDNcXHU2NzA4XFx1NGVmZCBcXHU1MTZiXFx1NjcwOFxcdTRlZmQgXFx1NGU1ZFxcdTY3MDhcXHU0ZWZkIFxcdTUzNDFcXHU2NzA4XFx1NGVmZCBcXHU1MzQxXFx1NGUwMFxcdTY3MDhcXHU0ZWZkIFxcdTUzNDFcXHU0ZThjXFx1NjcwOFxcdTRlZmRcIi5zcGxpdChcIiBcIiksXG5zaG9ydE1vbnRoczpcIlxcdTRlMDBcXHU2NzA4IFxcdTRlOGNcXHU2NzA4IFxcdTRlMDlcXHU2NzA4IFxcdTU2ZGJcXHU2NzA4IFxcdTRlOTRcXHU2NzA4IFxcdTUxNmRcXHU2NzA4IFxcdTRlMDNcXHU2NzA4IFxcdTUxNmJcXHU2NzA4IFxcdTRlNWRcXHU2NzA4IFxcdTUzNDFcXHU2NzA4IFxcdTUzNDFcXHU0ZTAwXFx1NjcwOCBcXHU1MzQxXFx1NGU4Y1xcdTY3MDhcIi5zcGxpdChcIiBcIiksQU06XCJcXHU0ZTBhXFx1NTM0OFwiLFBNOlwiXFx1NGUwYlxcdTUzNDhcIixhbTpcIlxcdTRlMGFcXHU1MzQ4XCIscG06XCJcXHU0ZTBiXFx1NTM0OFwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC8lbS8leVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlclwiLHg6XCIlRFwifX19LGM9YS5lbl9VUyxtPW5ldyBiKGMsMCwhMSk7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBFKXZhciBuPUUuZXhwb3J0cz1tO2Vsc2Ugbj1mdW5jdGlvbigpe3JldHVybiB0aGlzfHwoMCxldmFsKShcInRoaXNcIil9KCksXG5uLnN0cmZ0aW1lPW07XCJmdW5jdGlvblwiIT09dHlwZW9mIERhdGUubm93JiYoRGF0ZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9KX0pKCl9LGZ1bmN0aW9uKEUsUSxiKXtFPWIoNSk7Y29uc3QgZj1Tay5nbG9iYWwuSlNCST12b2lkIDAhPT1Tay5nbG9iYWwuQmlnSW50P3t9OkU7dm9pZCAwPT09U2suZ2xvYmFsLkJpZ0ludD8oZi5fX2lzQmlnSW50fHwoZi5fX2lzQmlnSW50PWU9PmUgaW5zdGFuY2VvZiBmKSxmLnBvd2VybW9kPShlLGcsayk9Pntjb25zdCBwPWYuQmlnSW50KDEpO2xldCBoPXA7Zm9yKGc9Zi5ncmVhdGVyVGhhbihnLGYuX19aRVJPKT9nOmYudW5hcnlNaW51cyhnKTtmLmdyZWF0ZXJUaGFuKGcsZi5fX1pFUk8pOylmLmJpdHdpc2VBbmQoZyxwKSYmKGg9Zi5yZW1haW5kZXIoZi5tdWx0aXBseShoLGUpLGspKSxnPWYuc2lnbmVkUmlnaHRTaGlmdChnLHApLGU9Zi5yZW1haW5kZXIoZi5tdWx0aXBseShlLGUpLGspO3JldHVybiBofSk6T2JqZWN0LmFzc2lnbihmLFxue0JpZ0ludDpTay5nbG9iYWwuQmlnSW50LHRvTnVtYmVyOmU9Pk51bWJlcihlKSx0b1N0cmluZzplPT5lLnRvU3RyaW5nKCksX19pc0JpZ0ludDplPT5cImJpZ2ludFwiPT09dHlwZW9mIGUsdW5hcnlNaW51czplPT4tZSxiaXR3aXNlTm90OmU9Pn5lLGJpdHdpc2VBbmQ6KGUsZyk9PmUmZyxiaXR3aXNlT3I6KGUsZyk9PmV8ZyxiaXR3aXNlWG9yOihlLGcpPT5lXmcsZXhwb25lbnRpYXRlOihlLGcpPT57Y29uc3Qgaz1mLkJpZ0ludCgxKTtsZXQgcD1rO2ZvcihnPWc+Zi5fX1pFUk8/ZzotZztnPmYuX19aRVJPOylnJmsmJihwKj1lKSxnPj49ayxlKj1lO3JldHVybiBwfSxwb3dlcm1vZDooZSxnLGspPT57Y29uc3QgcD1mLkJpZ0ludCgxKTtsZXQgaD1wO2ZvcihnPWc+Zi5fX1pFUk8/ZzotZztnPmYuX19aRVJPOylnJnAmJihoPWgqZSVrKSxnPj49cCxlPWUqZSVrO3JldHVybiBofSxtdWx0aXBseTooZSxnKT0+ZSpnLGRpdmlkZTooZSxnKT0+ZS9nLHJlbWFpbmRlcjooZSxnKT0+ZSVnLGFkZDooZSxcbmcpPT5lK2csc3VidHJhY3Q6KGUsZyk9PmUtZyxsZWZ0U2hpZnQ6KGUsZyk9PmU8PGcsc2lnbmVkUmlnaHRTaGlmdDooZSxnKT0+ZT4+Zyx1bnNpZ25lZFJpZ2h0U2hpZnQ6KGUsZyk9PmU+Pj5nLGxlc3NUaGFuOihlLGcpPT5lPGcsbGVzc1RoYW5PckVxdWFsOihlLGcpPT5lPD1nLGdyZWF0ZXJUaGFuOihlLGcpPT5lPmcsZ3JlYXRlclRoYW5PckVxdWFsOihlLGcpPT5lPj1nLGVxdWFsOihlLGcpPT5lPT09Zyxub3RFcXVhbDooZSxnKT0+ZSE9PWd9KTtmLl9fWkVSTz1mLkJpZ0ludCgwKTtmLl9fTUFYX1NBRkU9Zi5CaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO2YuX19NSU5fU0FGRT1mLkJpZ0ludCgtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO2YubnVtYmVySWZTYWZlPWU9PmYubGVzc1RoYW4oZSxmLl9fTUFYX1NBRkUpJiZmLmdyZWF0ZXJUaGFuKGUsZi5fX01JTl9TQUZFKT9mLnRvTnVtYmVyKGUpOmV9LGZ1bmN0aW9uKEUsUSxiKXsoZnVuY3Rpb24oZixlKXtFLmV4cG9ydHM9XG5lKCl9KSh0aGlzLGZ1bmN0aW9uKCl7dmFyIGY9TWF0aC5pbXVsLGU9TWF0aC5jbHozMixnPU1hdGguYWJzLGs9TWF0aC5tYXgscD1NYXRoLmZsb29yO2NsYXNzIGggZXh0ZW5kcyBBcnJheXtjb25zdHJ1Y3RvcihhLGMpe2lmKHN1cGVyKGEpLHRoaXMuc2lnbj1jLGE+aC5fX2tNYXhMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXhpbXVtIEJpZ0ludCBzaXplIGV4Y2VlZGVkXCIpO31zdGF0aWMgQmlnSW50KGEpe3ZhciBjPU51bWJlci5pc0Zpbml0ZTtpZihcIm51bWJlclwiPT10eXBlb2YgYSl7aWYoMD09PWEpcmV0dXJuIGguX196ZXJvKCk7aWYoaC5fX2lzT25lRGlnaXRJbnQoYSkpcmV0dXJuIDA+YT9oLl9fb25lRGlnaXQoLWEsITApOmguX19vbmVEaWdpdChhLCExKTtpZighYyhhKXx8cChhKSE9PWEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIFwiK2ErXCIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBCaWdJbnQgYmVjYXVzZSBpdCBpcyBub3QgYW4gaW50ZWdlclwiKTtcbnJldHVybiBoLl9fZnJvbURvdWJsZShhKX1pZihcInN0cmluZ1wiPT10eXBlb2YgYSl7Yz1oLl9fZnJvbVN0cmluZyhhKTtpZihudWxsPT09Yyl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJDYW5ub3QgY29udmVydCBcIithK1wiIHRvIGEgQmlnSW50XCIpO3JldHVybiBjfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYSlyZXR1cm4hMD09PWE/aC5fX29uZURpZ2l0KDEsITEpOmguX196ZXJvKCk7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe2lmKGEuY29uc3RydWN0b3I9PT1oKXJldHVybiBhO2E9aC5fX3RvUHJpbWl0aXZlKGEpO3JldHVybiBoLkJpZ0ludChhKX10aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgXCIrYStcIiB0byBhIEJpZ0ludFwiKTt9dG9EZWJ1Z1N0cmluZygpe2NvbnN0IGE9W1wiQmlnSW50W1wiXTtmb3IoY29uc3QgYyBvZiB0aGlzKWEucHVzaCgoYz8oYz4+PjApLnRvU3RyaW5nKDE2KTpjKStcIiwgXCIpO3JldHVybiBhLnB1c2goXCJdXCIpLGEuam9pbihcIlwiKX10b1N0cmluZyhhKXthPVxudm9pZCAwPT09YT8xMDphO2lmKDI+YXx8MzY8YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRvU3RyaW5nKCkgcmFkaXggYXJndW1lbnQgbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2XCIpO3JldHVybiAwPT09dGhpcy5sZW5ndGg/XCIwXCI6MD09KGEmYS0xKT9oLl9fdG9TdHJpbmdCYXNlUG93ZXJPZlR3byh0aGlzLGEpOmguX190b1N0cmluZ0dlbmVyaWModGhpcyxhLCExKX1zdGF0aWMgdG9OdW1iZXIoYSl7dmFyIGM9YS5sZW5ndGg7aWYoMD09PWMpcmV0dXJuIDA7aWYoMT09PWMpe3ZhciBtPWEuX191bnNpZ25lZERpZ2l0KDApO3JldHVybiBhLnNpZ24/LW06bX12YXIgbj1hLl9fZGlnaXQoYy0xKSxkPWguX19jbHozMChuKTttPTMwKmMtZDtpZigxMDI0PG0pcmV0dXJuIGEuc2lnbj8tSW5maW5pdHk6MS8wOy0tbTtsZXQgbD1jLTE7dmFyIHI9ZCszO2Q9KDMyPT09cj8wOm48PHIpPj4+MTI7Y29uc3Qgdj1yLTEyO2M9MTI8PXI/MDpuPDwyMCtyO3I9MjArcjtmb3IoMDx2JiYwPGwmJihsLS0sXG5uPWEuX19kaWdpdChsKSxkfD1uPj4+MzAtdixjPW48PHYrMixyPXYrMik7MDxyJiYwPGw7KWwtLSxuPWEuX19kaWdpdChsKSxjfD0zMDw9cj9uPDxyLTMwOm4+Pj4zMC1yLHItPTMwO249aC5fX2RlY2lkZVJvdW5kaW5nKGEscixsLG4pO2lmKCgxPT09bnx8MD09PW4mJjE9PSgxJmMpKSYmKGM9YysxPj4+MCwwPT09YyYmKGQrKywwIT1kPj4+MjAmJihkPTAsbSsrLDEwMjM8bSkpKSlyZXR1cm4gYS5zaWduPy1JbmZpbml0eToxLzA7YT1hLnNpZ24/LTIxNDc0ODM2NDg6MDtyZXR1cm4gbT1tKzEwMjM8PDIwLGguX19rQml0Q29udmVyc2lvbkludHNbMV09YXxtfGQsaC5fX2tCaXRDb252ZXJzaW9uSW50c1swXT1jLGguX19rQml0Q29udmVyc2lvbkRvdWJsZVswXX1zdGF0aWMgdW5hcnlNaW51cyhhKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuIGE7Y29uc3QgYz1hLl9fY29weSgpO3JldHVybiBjLnNpZ249IWEuc2lnbixjfXN0YXRpYyBiaXR3aXNlTm90KGEpe3JldHVybiBhLnNpZ24/aC5fX2Fic29sdXRlU3ViT25lKGEpLl9fdHJpbSgpOlxuaC5fX2Fic29sdXRlQWRkT25lKGEsITApfXN0YXRpYyBleHBvbmVudGlhdGUoYSxjKXtpZihjLnNpZ24pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFeHBvbmVudCBtdXN0IGJlIHBvc2l0aXZlXCIpO2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gaC5fX29uZURpZ2l0KDEsITEpO2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gYTtpZigxPT09YS5sZW5ndGgmJjE9PT1hLl9fZGlnaXQoMCkpcmV0dXJuIGEuc2lnbiYmMD09KDEmYy5fX2RpZ2l0KDApKT9oLnVuYXJ5TWludXMoYSk6YTtpZigxPGMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7Yz1jLl9fdW5zaWduZWREaWdpdCgwKTtpZigxPT09YylyZXR1cm4gYTtpZihjPj1oLl9fa01heExlbmd0aEJpdHMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCaWdJbnQgdG9vIGJpZ1wiKTtpZigxPT09YS5sZW5ndGgmJjI9PT1hLl9fZGlnaXQoMCkpe3ZhciBtPTErKDB8Yy8zMCk7YT1uZXcgaChtLGEuc2lnbiYmMCE9KDEmYykpO1xuYS5fX2luaXRpYWxpemVEaWdpdHMoKTtyZXR1cm4gYS5fX3NldERpZ2l0KG0tMSwxPDxjJTMwKSxhfW09bnVsbDtsZXQgbj1hOzAhPSgxJmMpJiYobT1hKTtmb3IoYz4+PTE7MCE9PWM7Yz4+PTEpbj1oLm11bHRpcGx5KG4sbiksMCE9KDEmYykmJihudWxsPT09bT9tPW46bT1oLm11bHRpcGx5KG0sbikpO3JldHVybiBtfXN0YXRpYyBtdWx0aXBseShhLGMpe2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gYTtpZigwPT09Yy5sZW5ndGgpcmV0dXJuIGM7dmFyIG09YS5sZW5ndGgrYy5sZW5ndGg7MzA8PWEuX19jbHptc2QoKStjLl9fY2x6bXNkKCkmJm0tLTttPW5ldyBoKG0sYS5zaWduIT09Yy5zaWduKTttLl9faW5pdGlhbGl6ZURpZ2l0cygpO2ZvcihsZXQgbj0wO248YS5sZW5ndGg7bisrKWguX19tdWx0aXBseUFjY3VtdWxhdGUoYyxhLl9fZGlnaXQobiksbSxuKTtyZXR1cm4gbS5fX3RyaW0oKX1zdGF0aWMgZGl2aWRlKGEsYyl7aWYoMD09PWMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRGl2aXNpb24gYnkgemVyb1wiKTtcbmlmKDA+aC5fX2Fic29sdXRlQ29tcGFyZShhLGMpKXJldHVybiBoLl9femVybygpO2NvbnN0IG09YS5zaWduIT09Yy5zaWduLG49Yy5fX3Vuc2lnbmVkRGlnaXQoMCk7aWYoMT09PWMubGVuZ3RoJiYzMjc2Nz49bil7aWYoMT09PW4pcmV0dXJuIG09PT1hLnNpZ24/YTpoLnVuYXJ5TWludXMoYSk7YT1oLl9fYWJzb2x1dGVEaXZTbWFsbChhLG4sbnVsbCl9ZWxzZSBhPWguX19hYnNvbHV0ZURpdkxhcmdlKGEsYywhMCwhMSk7cmV0dXJuIGEuc2lnbj1tLGEuX190cmltKCl9c3RhdGljIHJlbWFpbmRlcihhLGMpe2lmKDA9PT1jLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7aWYoMD5oLl9fYWJzb2x1dGVDb21wYXJlKGEsYykpcmV0dXJuIGE7Y29uc3QgbT1jLl9fdW5zaWduZWREaWdpdCgwKTtpZigxPT09Yy5sZW5ndGgmJjMyNzY3Pj1tKXtpZigxPT09bSlyZXR1cm4gaC5fX3plcm8oKTtjPWguX19hYnNvbHV0ZU1vZFNtYWxsKGEsbSk7cmV0dXJuIDA9PT1cbmM/aC5fX3plcm8oKTpoLl9fb25lRGlnaXQoYyxhLnNpZ24pfWM9aC5fX2Fic29sdXRlRGl2TGFyZ2UoYSxjLCExLCEwKTtyZXR1cm4gYy5zaWduPWEuc2lnbixjLl9fdHJpbSgpfXN0YXRpYyBhZGQoYSxjKXtjb25zdCBtPWEuc2lnbjtyZXR1cm4gbT09PWMuc2lnbj9oLl9fYWJzb2x1dGVBZGQoYSxjLG0pOjA8PWguX19hYnNvbHV0ZUNvbXBhcmUoYSxjKT9oLl9fYWJzb2x1dGVTdWIoYSxjLG0pOmguX19hYnNvbHV0ZVN1YihjLGEsIW0pfXN0YXRpYyBzdWJ0cmFjdChhLGMpe2NvbnN0IG09YS5zaWduO3JldHVybiBtPT09Yy5zaWduPzA8PWguX19hYnNvbHV0ZUNvbXBhcmUoYSxjKT9oLl9fYWJzb2x1dGVTdWIoYSxjLG0pOmguX19hYnNvbHV0ZVN1YihjLGEsIW0pOmguX19hYnNvbHV0ZUFkZChhLGMsbSl9c3RhdGljIGxlZnRTaGlmdChhLGMpe3JldHVybiAwPT09Yy5sZW5ndGh8fDA9PT1hLmxlbmd0aD9hOmMuc2lnbj9oLl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoYSxjKTpoLl9fbGVmdFNoaWZ0QnlBYnNvbHV0ZShhLFxuYyl9c3RhdGljIHNpZ25lZFJpZ2h0U2hpZnQoYSxjKXtyZXR1cm4gMD09PWMubGVuZ3RofHwwPT09YS5sZW5ndGg/YTpjLnNpZ24/aC5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoYSxjKTpoLl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoYSxjKX1zdGF0aWMgdW5zaWduZWRSaWdodFNoaWZ0KCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkJpZ0ludHMgaGF2ZSBubyB1bnNpZ25lZCByaWdodCBzaGlmdDsgdXNlID4+IGluc3RlYWRcIik7fXN0YXRpYyBsZXNzVGhhbihhLGMpe3JldHVybiAwPmguX19jb21wYXJlVG9CaWdJbnQoYSxjKX1zdGF0aWMgbGVzc1RoYW5PckVxdWFsKGEsYyl7cmV0dXJuIDA+PWguX19jb21wYXJlVG9CaWdJbnQoYSxjKX1zdGF0aWMgZ3JlYXRlclRoYW4oYSxjKXtyZXR1cm4gMDxoLl9fY29tcGFyZVRvQmlnSW50KGEsYyl9c3RhdGljIGdyZWF0ZXJUaGFuT3JFcXVhbChhLGMpe3JldHVybiAwPD1oLl9fY29tcGFyZVRvQmlnSW50KGEsYyl9c3RhdGljIGVxdWFsKGEsYyl7aWYoYS5zaWduIT09XG5jLnNpZ258fGEubGVuZ3RoIT09Yy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBtPTA7bTxhLmxlbmd0aDttKyspaWYoYS5fX2RpZ2l0KG0pIT09Yy5fX2RpZ2l0KG0pKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBub3RFcXVhbChhLGMpe3JldHVybiFoLmVxdWFsKGEsYyl9c3RhdGljIGJpdHdpc2VBbmQoYSxjKXtpZighYS5zaWduJiYhYy5zaWduKXJldHVybiBoLl9fYWJzb2x1dGVBbmQoYSxjKS5fX3RyaW0oKTtpZihhLnNpZ24mJmMuc2lnbil7Y29uc3QgbT1rKGEubGVuZ3RoLGMubGVuZ3RoKSsxO2E9aC5fX2Fic29sdXRlU3ViT25lKGEsbSk7Yz1oLl9fYWJzb2x1dGVTdWJPbmUoYyk7cmV0dXJuIGE9aC5fX2Fic29sdXRlT3IoYSxjLGEpLGguX19hYnNvbHV0ZUFkZE9uZShhLCEwLGEpLl9fdHJpbSgpfWEuc2lnbiYmKFthLGNdPVtjLGFdKTtyZXR1cm4gaC5fX2Fic29sdXRlQW5kTm90KGEsaC5fX2Fic29sdXRlU3ViT25lKGMpKS5fX3RyaW0oKX1zdGF0aWMgYml0d2lzZVhvcihhLFxuYyl7aWYoIWEuc2lnbiYmIWMuc2lnbilyZXR1cm4gaC5fX2Fic29sdXRlWG9yKGEsYykuX190cmltKCk7aWYoYS5zaWduJiZjLnNpZ24pe3ZhciBtPWsoYS5sZW5ndGgsYy5sZW5ndGgpO2E9aC5fX2Fic29sdXRlU3ViT25lKGEsbSk7Yz1oLl9fYWJzb2x1dGVTdWJPbmUoYyk7cmV0dXJuIGguX19hYnNvbHV0ZVhvcihhLGMsYSkuX190cmltKCl9bT1rKGEubGVuZ3RoLGMubGVuZ3RoKSsxO2Euc2lnbiYmKFthLGNdPVtjLGFdKTtjPWguX19hYnNvbHV0ZVN1Yk9uZShjLG0pO3JldHVybiBjPWguX19hYnNvbHV0ZVhvcihjLGEsYyksaC5fX2Fic29sdXRlQWRkT25lKGMsITAsYykuX190cmltKCl9c3RhdGljIGJpdHdpc2VPcihhLGMpe2NvbnN0IG09ayhhLmxlbmd0aCxjLmxlbmd0aCk7aWYoIWEuc2lnbiYmIWMuc2lnbilyZXR1cm4gaC5fX2Fic29sdXRlT3IoYSxjKS5fX3RyaW0oKTtpZihhLnNpZ24mJmMuc2lnbilyZXR1cm4gYT1oLl9fYWJzb2x1dGVTdWJPbmUoYSxtKSxjPWguX19hYnNvbHV0ZVN1Yk9uZShjKSxcbmE9aC5fX2Fic29sdXRlQW5kKGEsYyxhKSxoLl9fYWJzb2x1dGVBZGRPbmUoYSwhMCxhKS5fX3RyaW0oKTthLnNpZ24mJihbYSxjXT1bYyxhXSk7Yz1oLl9fYWJzb2x1dGVTdWJPbmUoYyxtKTtyZXR1cm4gYz1oLl9fYWJzb2x1dGVBbmROb3QoYyxhLGMpLGguX19hYnNvbHV0ZUFkZE9uZShjLCEwLGMpLl9fdHJpbSgpfXN0YXRpYyBhc0ludE4oYSxjKXtpZigwPT09Yy5sZW5ndGgpcmV0dXJuIGM7aWYoYT1wKGEpLDA+YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWU6IG5vdCAoY29udmVydGlibGUgdG8pIGEgc2FmZSBpbnRlZ2VyXCIpO2lmKDA9PT1hKXJldHVybiBoLl9femVybygpO2lmKGE+PWguX19rTWF4TGVuZ3RoQml0cylyZXR1cm4gYztjb25zdCBtPTB8KGErMjkpLzMwO2lmKGMubGVuZ3RoPG0pcmV0dXJuIGM7Y29uc3Qgbj1jLl9fdW5zaWduZWREaWdpdChtLTEpLGQ9MTw8KGEtMSklMzA7aWYoYy5sZW5ndGg9PT1tJiZuPGQpcmV0dXJuIGM7aWYoKG4mZCkhPT1cbmQpcmV0dXJuIGguX190cnVuY2F0ZVRvTkJpdHMoYSxjKTtpZighYy5zaWduKXJldHVybiBoLl9fdHJ1bmNhdGVBbmRTdWJGcm9tUG93ZXJPZlR3byhhLGMsITApO2lmKDA9PShuJmQtMSkpe2ZvcihsZXQgbD1tLTI7MDw9bDtsLS0paWYoMCE9PWMuX19kaWdpdChsKSlyZXR1cm4gaC5fX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oYSxjLCExKTtyZXR1cm4gYy5sZW5ndGg9PT1tJiZuPT09ZD9jOmguX190cnVuY2F0ZVRvTkJpdHMoYSxjKX1yZXR1cm4gaC5fX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oYSxjLCExKX1zdGF0aWMgYXNVaW50TihhLGMpe2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gYztpZihhPXAoYSksMD5hKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB2YWx1ZTogbm90IChjb252ZXJ0aWJsZSB0bykgYSBzYWZlIGludGVnZXJcIik7aWYoMD09PWEpcmV0dXJuIGguX196ZXJvKCk7aWYoYy5zaWduKXtpZihhPmguX19rTWF4TGVuZ3RoQml0cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO1xucmV0dXJuIGguX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGEsYywhMSl9aWYoYT49aC5fX2tNYXhMZW5ndGhCaXRzKXJldHVybiBjO2NvbnN0IG09MHwoYSsyOSkvMzA7aWYoYy5sZW5ndGg8bSlyZXR1cm4gYztjb25zdCBuPWElMzA7cmV0dXJuIGMubGVuZ3RoIT1tfHwwIT09biYmMCE9Yy5fX2RpZ2l0KG0tMSk+Pj5uP2guX190cnVuY2F0ZVRvTkJpdHMoYSxjKTpjfXN0YXRpYyBBREQoYSxjKXtpZihhPWguX190b1ByaW1pdGl2ZShhKSxjPWguX190b1ByaW1pdGl2ZShjKSxcInN0cmluZ1wiPT10eXBlb2YgYSlyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYyYmKGM9Yy50b1N0cmluZygpKSxhK2M7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGMpcmV0dXJuIGEudG9TdHJpbmcoKStjO2lmKGE9aC5fX3RvTnVtZXJpYyhhKSxjPWguX190b051bWVyaWMoYyksaC5fX2lzQmlnSW50KGEpJiZoLl9faXNCaWdJbnQoYykpcmV0dXJuIGguYWRkKGEsYyk7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEmJlwibnVtYmVyXCI9PVxudHlwZW9mIGMpcmV0dXJuIGErYzt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IG1peCBCaWdJbnQgYW5kIG90aGVyIHR5cGVzLCB1c2UgZXhwbGljaXQgY29udmVyc2lvbnNcIik7fXN0YXRpYyBMVChhLGMpe3JldHVybiBoLl9fY29tcGFyZShhLGMsMCl9c3RhdGljIExFKGEsYyl7cmV0dXJuIGguX19jb21wYXJlKGEsYywxKX1zdGF0aWMgR1QoYSxjKXtyZXR1cm4gaC5fX2NvbXBhcmUoYSxjLDIpfXN0YXRpYyBHRShhLGMpe3JldHVybiBoLl9fY29tcGFyZShhLGMsMyl9c3RhdGljIEVRKGEsYyl7Zm9yKDs7KXtpZihoLl9faXNCaWdJbnQoYSkpcmV0dXJuIGguX19pc0JpZ0ludChjKT9oLmVxdWFsKGEsYyk6aC5FUShjLGEpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXtpZihoLl9faXNCaWdJbnQoYykpcmV0dXJuIGguX19lcXVhbFRvTnVtYmVyKGMsYSk7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGMpcmV0dXJuIGE9PWM7Yz1oLl9fdG9QcmltaXRpdmUoYyl9ZWxzZSBpZihcInN0cmluZ1wiPT1cbnR5cGVvZiBhKXtpZihoLl9faXNCaWdJbnQoYykpcmV0dXJuIGE9aC5fX2Zyb21TdHJpbmcoYSksbnVsbCE9PWEmJmguZXF1YWwoYSxjKTtpZihcIm9iamVjdFwiIT10eXBlb2YgYylyZXR1cm4gYT09YztjPWguX190b1ByaW1pdGl2ZShjKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYSl7aWYoaC5fX2lzQmlnSW50KGMpKXJldHVybiBoLl9fZXF1YWxUb051bWJlcihjLCthKTtpZihcIm9iamVjdFwiIT10eXBlb2YgYylyZXR1cm4gYT09YztjPWguX190b1ByaW1pdGl2ZShjKX1lbHNlIGlmKFwic3ltYm9sXCI9PXR5cGVvZiBhKXtpZihoLl9faXNCaWdJbnQoYykpcmV0dXJuITE7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGMpcmV0dXJuIGE9PWM7Yz1oLl9fdG9QcmltaXRpdmUoYyl9ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgYSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGMmJmMuY29uc3RydWN0b3IhPT1oKXJldHVybiBhPT1jO2E9aC5fX3RvUHJpbWl0aXZlKGEpfWVsc2UgcmV0dXJuIGE9PWN9fXN0YXRpYyBORShhLFxuYyl7cmV0dXJuIWguRVEoYSxjKX1zdGF0aWMgX196ZXJvKCl7cmV0dXJuIG5ldyBoKDAsITEpfXN0YXRpYyBfX29uZURpZ2l0KGEsYyl7Yz1uZXcgaCgxLGMpO3JldHVybiBjLl9fc2V0RGlnaXQoMCxhKSxjfV9fY29weSgpe2NvbnN0IGE9bmV3IGgodGhpcy5sZW5ndGgsdGhpcy5zaWduKTtmb3IobGV0IGM9MDtjPHRoaXMubGVuZ3RoO2MrKylhW2NdPXRoaXNbY107cmV0dXJuIGF9X190cmltKCl7bGV0IGE9dGhpcy5sZW5ndGgsYz10aGlzW2EtMV07Zm9yKDswPT09YzspYS0tLGM9dGhpc1thLTFdLHRoaXMucG9wKCk7cmV0dXJuIDA9PT1hJiYodGhpcy5zaWduPSExKSx0aGlzfV9faW5pdGlhbGl6ZURpZ2l0cygpe2ZvcihsZXQgYT0wO2E8dGhpcy5sZW5ndGg7YSsrKXRoaXNbYV09MH1zdGF0aWMgX19kZWNpZGVSb3VuZGluZyhhLGMsbSxuKXtpZigwPGMpcmV0dXJuLTE7aWYoMD5jKWM9LWMtMTtlbHNle2lmKDA9PT1tKXJldHVybi0xO20tLTtuPWEuX19kaWdpdChtKTtjPTI5fWM9XG4xPDxjO2lmKDA9PShuJmMpKXJldHVybi0xO2lmKC0tYywwIT0obiZjKSlyZXR1cm4gMTtmb3IoOzA8bTspaWYobS0tLDAhPT1hLl9fZGlnaXQobSkpcmV0dXJuIDE7cmV0dXJuIDB9c3RhdGljIF9fZnJvbURvdWJsZShhKXtoLl9fa0JpdENvbnZlcnNpb25Eb3VibGVbMF09YTt2YXIgYz0oMjA0NyZoLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjApLTEwMjMsbT0oMHxjLzMwKSsxO2E9bmV3IGgobSwwPmEpO2xldCBuPTEwNDg1NzUmaC5fX2tCaXRDb252ZXJzaW9uSW50c1sxXXwxMDQ4NTc2LGQ9aC5fX2tCaXRDb252ZXJzaW9uSW50c1swXTtjJT0zMDtsZXQgbDtpZigyMD5jKXt2YXIgcj0yMC1jO2w9ciszMjtjPW4+Pj5yO249bjw8MzItcnxkPj4+cjtkPDw9MzItcn1lbHNlIDIwPT09Yz8obD0zMixjPW4sbj1kKToocj1jLTIwLGw9MzItcixjPW48PHJ8ZD4+PjMyLXIsbj1kPDxyKSxkPTA7YS5fX3NldERpZ2l0KG0tMSxjKTtmb3IobS09MjswPD1tO20tLSkwPGw/KGwtPTMwLGM9XG5uPj4+MixuPW48PDMwfGQ+Pj4yLGQ8PD0zMCk6Yz0wLGEuX19zZXREaWdpdChtLGMpO3JldHVybiBhLl9fdHJpbSgpfXN0YXRpYyBfX2lzV2hpdGVzcGFjZShhKXtyZXR1cm4hISgxMz49YSYmOTw9YSl8fCgxNTk+PWE/MzI9PWE6MTMxMDcxPj1hPzE2MD09YXx8NTc2MD09YToxOTY2MDc+PWE/KGEmPTEzMTA3MSwxMD49YXx8NDA9PWF8fDQxPT1hfHw0Nz09YXx8OTU9PWF8fDQwOTY9PWEpOjY1Mjc5PT1hKX1zdGF0aWMgX19mcm9tU3RyaW5nKGEsYyl7Yz12b2lkIDA9PT1jPzA6YztsZXQgbT0wO2NvbnN0IG49YS5sZW5ndGg7bGV0IGQ9MDtpZihkPT09bilyZXR1cm4gaC5fX3plcm8oKTtsZXQgbD1hLmNoYXJDb2RlQXQoZCk7Zm9yKDtoLl9faXNXaGl0ZXNwYWNlKGwpOyl7aWYoKytkPT09bilyZXR1cm4gaC5fX3plcm8oKTtsPWEuY2hhckNvZGVBdChkKX1pZig0Mz09PWwpe2lmKCsrZD09PW4pcmV0dXJuIG51bGw7bD1hLmNoYXJDb2RlQXQoZCk7bT0xfWVsc2UgaWYoNDU9PT1sKXtpZigrK2Q9PT1cbm4pcmV0dXJuIG51bGw7bD1hLmNoYXJDb2RlQXQoZCk7bT0tMX1pZigwPT09Yyl7aWYoYz0xMCw0OD09PWwpe2lmKCsrZD09PW4pcmV0dXJuIGguX196ZXJvKCk7aWYobD1hLmNoYXJDb2RlQXQoZCksODg9PT1sfHwxMjA9PT1sKXtpZihjPTE2LCsrZD09PW4pcmV0dXJuIG51bGw7bD1hLmNoYXJDb2RlQXQoZCl9ZWxzZSBpZig3OT09PWx8fDExMT09PWwpe2lmKGM9OCwrK2Q9PT1uKXJldHVybiBudWxsO2w9YS5jaGFyQ29kZUF0KGQpfWVsc2UgaWYoNjY9PT1sfHw5OD09PWwpe2lmKGM9MiwrK2Q9PT1uKXJldHVybiBudWxsO2w9YS5jaGFyQ29kZUF0KGQpfX19ZWxzZSBpZigxNj09PWMmJjQ4PT09bCl7aWYoKytkPT09bilyZXR1cm4gaC5fX3plcm8oKTtpZihsPWEuY2hhckNvZGVBdChkKSw4OD09PWx8fDEyMD09PWwpe2lmKCsrZD09PW4pcmV0dXJuIG51bGw7bD1hLmNoYXJDb2RlQXQoZCl9fWlmKDAhPW0mJjEwIT09YylyZXR1cm4gbnVsbDtmb3IoOzQ4PT09bDspe2lmKCsrZD09PVxubilyZXR1cm4gaC5fX3plcm8oKTtsPWEuY2hhckNvZGVBdChkKX12YXIgcj1uLWQ7bGV0IHY9aC5fX2tNYXhCaXRzUGVyQ2hhcltjXTt2YXIgcT1oLl9fa0JpdHNQZXJDaGFyVGFibGVNdWx0aXBsaWVyLTE7aWYocj4xMDczNzQxODI0L3YpcmV0dXJuIG51bGw7cj1uZXcgaCgwfCgodipyK3E+Pj5oLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdCkrMjkpLzMwLCExKTtjb25zdCB0PTEwPmM/YzoxMCx3PTEwPGM/Yy0xMDowO2lmKDA9PShjJmMtMSkpe3Y+Pj1oLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdDtjPVtdO3ZhciBDPVtdLEQ9ITE7ZG97Zm9yKHZhciBMPTAsTj0wOzspe2lmKGwtNDg+Pj4wPHQpcT1sLTQ4O2Vsc2UgaWYoKDMyfGwpLTk3Pj4+MDx3KXE9KDMyfGwpLTg3O2Vsc2V7RD0hMDticmVha31pZihOKz12LEw9TDw8dnxxLCsrZD09PW4pe0Q9ITA7YnJlYWt9aWYobD1hLmNoYXJDb2RlQXQoZCksMzA8Tit2KWJyZWFrfWMucHVzaChMKTtDLnB1c2goTil9d2hpbGUoIUQpO2guX19maWxsRnJvbVBhcnRzKHIsXG5jLEMpfWVsc2V7ci5fX2luaXRpYWxpemVEaWdpdHMoKTtDPSExO0Q9MDtkb3tMPTA7Zm9yKE49MTs7KXtpZihsLTQ4Pj4+MDx0KXE9bC00ODtlbHNlIGlmKCgzMnxsKS05Nz4+PjA8dylxPSgzMnxsKS04NztlbHNle0M9ITA7YnJlYWt9Y29uc3QgQT1OKmM7aWYoMTA3Mzc0MTgyMzxBKWJyZWFrO2lmKE49QSxMPUwqYytxLEQrKywrK2Q9PT1uKXtDPSEwO2JyZWFrfWw9YS5jaGFyQ29kZUF0KGQpfXE9MzAqaC5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO3IuX19pbnBsYWNlTXVsdGlwbHlBZGQoTixMLDB8KHYqRCtxPj4+aC5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQpLzMwKX13aGlsZSghQyl9aWYoZCE9PW4pe2lmKCFoLl9faXNXaGl0ZXNwYWNlKGwpKXJldHVybiBudWxsO2ZvcihkKys7ZDxuO2QrKylpZihsPWEuY2hhckNvZGVBdChkKSwhaC5fX2lzV2hpdGVzcGFjZShsKSlyZXR1cm4gbnVsbH1yZXR1cm4gci5zaWduPS0xPT1tLHIuX190cmltKCl9c3RhdGljIF9fZmlsbEZyb21QYXJ0cyhhLFxuYyxtKXtsZXQgbj0wLGQ9MCxsPTA7Zm9yKGxldCByPWMubGVuZ3RoLTE7MDw9cjtyLS0pe2NvbnN0IHY9Y1tyXSxxPW1bcl07ZHw9djw8bDtsKz1xOzMwPT09bD8oYS5fX3NldERpZ2l0KG4rKyxkKSxsPTAsZD0wKTozMDxsJiYoYS5fX3NldERpZ2l0KG4rKywxMDczNzQxODIzJmQpLGwtPTMwLGQ9dj4+PnEtbCl9aWYoMCE9PWQpe2lmKG4+PWEubGVuZ3RoKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2EuX19zZXREaWdpdChuKyssZCl9Zm9yKDtuPGEubGVuZ3RoO24rKylhLl9fc2V0RGlnaXQobiwwKX1zdGF0aWMgX190b1N0cmluZ0Jhc2VQb3dlck9mVHdvKGEsYyl7Y29uc3QgbT1hLmxlbmd0aDt2YXIgbj1jLTE7bj0oODUmbj4+PjEpKyg4NSZuKTtuPSg1MSZuPj4+MikrKDUxJm4pO249KDE1Jm4+Pj40KSsoMTUmbik7LS1jO2NvbnN0IGQ9YS5fX2RpZ2l0KG0tMSk7dmFyIGw9aC5fX2NsejMwKGQpLHI9MHwoMzAqbS1sK24tMSkvbjtpZihhLnNpZ24mJnIrKywyNjg0MzU0NTY8XG5yKXRocm93IEVycm9yKFwic3RyaW5nIHRvbyBsb25nXCIpO2w9QXJyYXkocik7LS1yO3ZhciB2PTAscT0wO2ZvcihsZXQgdD0wO3Q8bS0xO3QrKyl7Y29uc3Qgdz1hLl9fZGlnaXQodCk7dj0odnx3PDxxKSZjO2xbci0tXT1oLl9fa0NvbnZlcnNpb25DaGFyc1t2XTtxPW4tcTt2PXc+Pj5xO2ZvcihxPTMwLXE7cT49bjspbFtyLS1dPWguX19rQ29udmVyc2lvbkNoYXJzW3YmY10sdj4+Pj1uLHEtPW59bFtyLS1dPWguX19rQ29udmVyc2lvbkNoYXJzWyh2fGQ8PHEpJmNdO2Zvcih2PWQ+Pj5uLXE7MCE9PXY7KWxbci0tXT1oLl9fa0NvbnZlcnNpb25DaGFyc1t2JmNdLHY+Pj49bjtpZihhLnNpZ24mJihsW3ItLV09XCItXCIpLC0xIT1yKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiBsLmpvaW4oXCJcIil9c3RhdGljIF9fdG9TdHJpbmdHZW5lcmljKGEsYyxtKXt2YXIgbj1hLmxlbmd0aDtpZigwPT09bilyZXR1cm5cIlwiO2lmKDE9PT1uKXJldHVybiBjPWEuX191bnNpZ25lZERpZ2l0KDApLnRvU3RyaW5nKGMpLFxuITE9PT1tJiZhLnNpZ24mJihjPVwiLVwiK2MpLGM7dmFyIGQ9MzAqbi1oLl9fY2x6MzAoYS5fX2RpZ2l0KG4tMSkpO249aC5fX2tNYXhCaXRzUGVyQ2hhcltjXS0xO2QqPWguX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI7bj0oMHwoZCsobi0xKSkvbikrMT4+MTtkPWguZXhwb25lbnRpYXRlKGguX19vbmVEaWdpdChjLCExKSxoLl9fb25lRGlnaXQobiwhMSkpO3ZhciBsPWQuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1kLmxlbmd0aCYmMzI3Njc+PWwpe2Q9bmV3IGgoYS5sZW5ndGgsITEpO2QuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIHI9MDtmb3IobGV0IHY9MiphLmxlbmd0aC0xOzA8PXY7di0tKXI9cjw8MTV8YS5fX2hhbGZEaWdpdCh2KSxkLl9fc2V0SGFsZkRpZ2l0KHYsMHxyL2wpLHI9MHxyJWw7bD1yLnRvU3RyaW5nKGMpfWVsc2UgbD1oLl9fYWJzb2x1dGVEaXZMYXJnZShhLGQsITAsITApLGQ9bC5xdW90aWVudCxsPWwucmVtYWluZGVyLl9fdHJpbSgpLGw9aC5fX3RvU3RyaW5nR2VuZXJpYyhsLFxuYywhMCk7ZC5fX3RyaW0oKTtmb3IoYz1oLl9fdG9TdHJpbmdHZW5lcmljKGQsYywhMCk7bC5sZW5ndGg8bjspbD1cIjBcIitsO3JldHVybiExPT09bSYmYS5zaWduJiYoYz1cIi1cIitjKSxjK2x9c3RhdGljIF9fdW5lcXVhbFNpZ24oYSl7cmV0dXJuIGE/LTE6MX1zdGF0aWMgX19hYnNvbHV0ZUdyZWF0ZXIoYSl7cmV0dXJuIGE/LTE6MX1zdGF0aWMgX19hYnNvbHV0ZUxlc3MoYSl7cmV0dXJuIGE/MTotMX1zdGF0aWMgX19jb21wYXJlVG9CaWdJbnQoYSxjKXtjb25zdCBtPWEuc2lnbjtpZihtIT09Yy5zaWduKXJldHVybiBoLl9fdW5lcXVhbFNpZ24obSk7YT1oLl9fYWJzb2x1dGVDb21wYXJlKGEsYyk7cmV0dXJuIDA8YT9oLl9fYWJzb2x1dGVHcmVhdGVyKG0pOjA+YT9oLl9fYWJzb2x1dGVMZXNzKG0pOjB9c3RhdGljIF9fY29tcGFyZVRvTnVtYmVyKGEsYyl7aWYoaC5fX2lzT25lRGlnaXRJbnQoYykpe2NvbnN0IG09YS5zaWduLG49MD5jO2lmKG0hPT1uKXJldHVybiBoLl9fdW5lcXVhbFNpZ24obSk7XG5pZigwPT09YS5sZW5ndGgpe2lmKG4pdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIDA9PT1jPzA6LTF9aWYoMTxhLmxlbmd0aClyZXR1cm4gaC5fX2Fic29sdXRlR3JlYXRlcihtKTtjPWcoYyk7YT1hLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gYT5jP2guX19hYnNvbHV0ZUdyZWF0ZXIobSk6YTxjP2guX19hYnNvbHV0ZUxlc3MobSk6MH1yZXR1cm4gaC5fX2NvbXBhcmVUb0RvdWJsZShhLGMpfXN0YXRpYyBfX2NvbXBhcmVUb0RvdWJsZShhLGMpe2lmKGMhPT1jKXJldHVybiBjO2lmKGM9PT0xLzApcmV0dXJuLTE7aWYoLUluZmluaXR5PT09YylyZXR1cm4gMTtjb25zdCBtPWEuc2lnbjtpZihtIT09MD5jKXJldHVybiBoLl9fdW5lcXVhbFNpZ24obSk7aWYoMD09PWMpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IHNob3VsZCBiZSBoYW5kbGVkIGVsc2V3aGVyZVwiKTtpZigwPT09YS5sZW5ndGgpcmV0dXJuLTE7aC5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdPVxuYztjPTIwNDcmaC5fX2tCaXRDb252ZXJzaW9uSW50c1sxXT4+PjIwO2lmKDIwNDc9PWMpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IGhhbmRsZWQgZWxzZXdoZXJlXCIpO3ZhciBuPWMtMTAyMztpZigwPm4pcmV0dXJuIGguX19hYnNvbHV0ZUdyZWF0ZXIobSk7Yz1hLmxlbmd0aDt2YXIgZD1hLl9fZGlnaXQoYy0xKSxsPWguX19jbHozMChkKSxyPTMwKmMtbDtuKz0xO2lmKHI8bilyZXR1cm4gaC5fX2Fic29sdXRlTGVzcyhtKTtpZihyPm4pcmV0dXJuIGguX19hYnNvbHV0ZUdyZWF0ZXIobSk7bj0xMDQ4NTc2fDEwNDg1NzUmaC5fX2tCaXRDb252ZXJzaW9uSW50c1sxXTtsZXQgdj1oLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdO2w9MjktbDtpZihsIT09KDB8KHItMSklMzApKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2lmKDIwPmwpe3ZhciBxPTIwLWw7bD1xKzMyO3I9bj4+PnE7bj1uPDwzMi1xfHY+Pj5xO3Y8PD0zMi1xfWVsc2UgMjA9PT1sPyhsPTMyLFxucj1uLG49dik6KHE9bC0yMCxsPTMyLXEscj1uPDxxfHY+Pj4zMi1xLG49djw8cSksdj0wO2lmKGQ+Pj49MCxyPj4+PTAsZD5yKXJldHVybiBoLl9fYWJzb2x1dGVHcmVhdGVyKG0pO2lmKGQ8cilyZXR1cm4gaC5fX2Fic29sdXRlTGVzcyhtKTtmb3IoYy09MjswPD1jO2MtLSl7MDxsPyhsLT0zMCxyPW4+Pj4yLG49bjw8MzB8dj4+PjIsdjw8PTMwKTpyPTA7ZD1hLl9fdW5zaWduZWREaWdpdChjKTtpZihkPnIpcmV0dXJuIGguX19hYnNvbHV0ZUdyZWF0ZXIobSk7aWYoZDxyKXJldHVybiBoLl9fYWJzb2x1dGVMZXNzKG0pfWlmKDAhPT1ufHwwIT09dil7aWYoMD09PWwpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIGguX19hYnNvbHV0ZUxlc3MobSl9cmV0dXJuIDB9c3RhdGljIF9fZXF1YWxUb051bWJlcihhLGMpe3JldHVybiBoLl9faXNPbmVEaWdpdEludChjKT8wPT09Yz8wPT09YS5sZW5ndGg6MT09PWEubGVuZ3RoJiZhLnNpZ249PT0wPmMmJmEuX191bnNpZ25lZERpZ2l0KDApPT09XG5nKGMpOjA9PT1oLl9fY29tcGFyZVRvRG91YmxlKGEsYyl9c3RhdGljIF9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLGMpe3JldHVybiAwPT09Yz8wPmE6MT09PWM/MD49YToyPT09Yz8wPGE6Mz09PWM/MDw9YTp2b2lkIDB9c3RhdGljIF9fY29tcGFyZShhLGMsbSl7aWYoYT1oLl9fdG9QcmltaXRpdmUoYSksYz1oLl9fdG9QcmltaXRpdmUoYyksXCJzdHJpbmdcIj09dHlwZW9mIGEmJlwic3RyaW5nXCI9PXR5cGVvZiBjKXN3aXRjaChtKXtjYXNlIDA6cmV0dXJuIGE8YztjYXNlIDE6cmV0dXJuIGE8PWM7Y2FzZSAyOnJldHVybiBhPmM7Y2FzZSAzOnJldHVybiBhPj1jfWlmKGguX19pc0JpZ0ludChhKSYmXCJzdHJpbmdcIj09dHlwZW9mIGMpcmV0dXJuIGM9aC5fX2Zyb21TdHJpbmcoYyksbnVsbCE9PWMmJmguX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGguX19jb21wYXJlVG9CaWdJbnQoYSxjKSxtKTtpZihcInN0cmluZ1wiPT10eXBlb2YgYSYmaC5fX2lzQmlnSW50KGMpKXJldHVybiBhPWguX19mcm9tU3RyaW5nKGEpLFxubnVsbCE9PWEmJmguX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGguX19jb21wYXJlVG9CaWdJbnQoYSxjKSxtKTtpZihhPWguX190b051bWVyaWMoYSksYz1oLl9fdG9OdW1lcmljKGMpLGguX19pc0JpZ0ludChhKSl7aWYoaC5fX2lzQmlnSW50KGMpKXJldHVybiBoLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChoLl9fY29tcGFyZVRvQmlnSW50KGEsYyksbSk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIGguX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGguX19jb21wYXJlVG9OdW1iZXIoYSxjKSxtKX1pZihcIm51bWJlclwiIT10eXBlb2YgYSl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtpZihoLl9faXNCaWdJbnQoYykpcmV0dXJuIGguX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGguX19jb21wYXJlVG9OdW1iZXIoYyxhKSwyXm0pO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBjKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO1xucmV0dXJuIDA9PT1tP2E8YzoxPT09bT9hPD1jOjI9PT1tP2E+YzozPT09bT9hPj1jOnZvaWQgMH1fX2Nsem1zZCgpe3JldHVybiBoLl9fY2x6MzAodGhpcy5fX2RpZ2l0KHRoaXMubGVuZ3RoLTEpKX1zdGF0aWMgX19hYnNvbHV0ZUFkZChhLGMsbSl7aWYoYS5sZW5ndGg8Yy5sZW5ndGgpcmV0dXJuIGguX19hYnNvbHV0ZUFkZChjLGEsbSk7aWYoMD09PWEubGVuZ3RoKXJldHVybiBhO2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gYS5zaWduPT09bT9hOmgudW5hcnlNaW51cyhhKTt2YXIgbj1hLmxlbmd0aDsoMD09PWEuX19jbHptc2QoKXx8Yy5sZW5ndGg9PT1hLmxlbmd0aCYmMD09PWMuX19jbHptc2QoKSkmJm4rKzttPW5ldyBoKG4sbSk7bGV0IGQ9bj0wO2Zvcig7ZDxjLmxlbmd0aDtkKyspe2NvbnN0IGw9YS5fX2RpZ2l0KGQpK2MuX19kaWdpdChkKStuO249bD4+PjMwO20uX19zZXREaWdpdChkLDEwNzM3NDE4MjMmbCl9Zm9yKDtkPGEubGVuZ3RoO2QrKyljPWEuX19kaWdpdChkKStuLFxubj1jPj4+MzAsbS5fX3NldERpZ2l0KGQsMTA3Mzc0MTgyMyZjKTtyZXR1cm4gZDxtLmxlbmd0aCYmbS5fX3NldERpZ2l0KGQsbiksbS5fX3RyaW0oKX1zdGF0aWMgX19hYnNvbHV0ZVN1YihhLGMsbSl7aWYoMD09PWEubGVuZ3RoKXJldHVybiBhO2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gYS5zaWduPT09bT9hOmgudW5hcnlNaW51cyhhKTttPW5ldyBoKGEubGVuZ3RoLG0pO2xldCBuPTAsZD0wO2Zvcig7ZDxjLmxlbmd0aDtkKyspe2NvbnN0IGw9YS5fX2RpZ2l0KGQpLWMuX19kaWdpdChkKS1uO249MSZsPj4+MzA7bS5fX3NldERpZ2l0KGQsMTA3Mzc0MTgyMyZsKX1mb3IoO2Q8YS5sZW5ndGg7ZCsrKWM9YS5fX2RpZ2l0KGQpLW4sbj0xJmM+Pj4zMCxtLl9fc2V0RGlnaXQoZCwxMDczNzQxODIzJmMpO3JldHVybiBtLl9fdHJpbSgpfXN0YXRpYyBfX2Fic29sdXRlQWRkT25lKGEsYyxtKXttPXZvaWQgMD09PW0/bnVsbDptO2NvbnN0IG49YS5sZW5ndGg7bnVsbD09PW0/bT1uZXcgaChuLFxuYyk6bS5zaWduPWM7Yz0xO2ZvcihsZXQgZD0wO2Q8bjtkKyspe2NvbnN0IGw9YS5fX2RpZ2l0KGQpK2M7Yz1sPj4+MzA7bS5fX3NldERpZ2l0KGQsMTA3Mzc0MTgyMyZsKX1yZXR1cm4gMCE9YyYmbS5fX3NldERpZ2l0R3JvdyhuLDEpLG19c3RhdGljIF9fYWJzb2x1dGVTdWJPbmUoYSxjKXtjb25zdCBtPWEubGVuZ3RoO2M9Y3x8bTtjb25zdCBuPW5ldyBoKGMsITEpO2xldCBkPTE7Zm9yKGxldCBsPTA7bDxtO2wrKyl7Y29uc3Qgcj1hLl9fZGlnaXQobCktZDtkPTEmcj4+PjMwO24uX19zZXREaWdpdChsLDEwNzM3NDE4MjMmcil9aWYoMCE9ZCl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtmb3IoYT1tO2E8YzthKyspbi5fX3NldERpZ2l0KGEsMCk7cmV0dXJuIG59c3RhdGljIF9fYWJzb2x1dGVBbmQoYSxjLG0pe209dm9pZCAwPT09bT9udWxsOm07dmFyIG49YS5sZW5ndGgsZD1jLmxlbmd0aDtsZXQgbD1kO248ZCYmKGw9bixuPWEsYT1jLGM9bik7bj1sO251bGw9PT1cbm0/bT1uZXcgaChuLCExKTpuPW0ubGVuZ3RoO2ZvcihkPTA7ZDxsO2QrKyltLl9fc2V0RGlnaXQoZCxhLl9fZGlnaXQoZCkmYy5fX2RpZ2l0KGQpKTtmb3IoO2Q8bjtkKyspbS5fX3NldERpZ2l0KGQsMCk7cmV0dXJuIG19c3RhdGljIF9fYWJzb2x1dGVBbmROb3QoYSxjLG0pe209dm9pZCAwPT09bT9udWxsOm07Y29uc3Qgbj1hLmxlbmd0aDt2YXIgZD1jLmxlbmd0aDtsZXQgbD1kO248ZCYmKGw9bik7ZD1uO251bGw9PT1tP209bmV3IGgoZCwhMSk6ZD1tLmxlbmd0aDtsZXQgcj0wO2Zvcig7cjxsO3IrKyltLl9fc2V0RGlnaXQocixhLl9fZGlnaXQocikmfmMuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKW0uX19zZXREaWdpdChyLGEuX19kaWdpdChyKSk7Zm9yKDtyPGQ7cisrKW0uX19zZXREaWdpdChyLDApO3JldHVybiBtfXN0YXRpYyBfX2Fic29sdXRlT3IoYSxjLG0pe209dm9pZCAwPT09bT9udWxsOm07bGV0IG49YS5sZW5ndGg7dmFyIGQ9Yy5sZW5ndGg7bGV0IGw9ZDtpZihuPFxuZCl7bD1uO3ZhciByPWE7YT1jO249ZDtjPXJ9ZD1uO251bGw9PT1tP209bmV3IGgoZCwhMSk6ZD1tLmxlbmd0aDtmb3Iocj0wO3I8bDtyKyspbS5fX3NldERpZ2l0KHIsYS5fX2RpZ2l0KHIpfGMuX19kaWdpdChyKSk7Zm9yKDtyPG47cisrKW0uX19zZXREaWdpdChyLGEuX19kaWdpdChyKSk7Zm9yKDtyPGQ7cisrKW0uX19zZXREaWdpdChyLDApO3JldHVybiBtfXN0YXRpYyBfX2Fic29sdXRlWG9yKGEsYyxtKXttPXZvaWQgMD09PW0/bnVsbDptO2xldCBuPWEubGVuZ3RoO3ZhciBkPWMubGVuZ3RoO2xldCBsPWQ7aWYobjxkKXtsPW47dmFyIHI9YTthPWM7bj1kO2M9cn1kPW47bnVsbD09PW0/bT1uZXcgaChkLCExKTpkPW0ubGVuZ3RoO2ZvcihyPTA7cjxsO3IrKyltLl9fc2V0RGlnaXQocixhLl9fZGlnaXQocileYy5fX2RpZ2l0KHIpKTtmb3IoO3I8bjtyKyspbS5fX3NldERpZ2l0KHIsYS5fX2RpZ2l0KHIpKTtmb3IoO3I8ZDtyKyspbS5fX3NldERpZ2l0KHIsMCk7cmV0dXJuIG19c3RhdGljIF9fYWJzb2x1dGVDb21wYXJlKGEsXG5jKXt2YXIgbT1hLmxlbmd0aC1jLmxlbmd0aDtpZigwIT1tKXJldHVybiBtO2ZvcihtPWEubGVuZ3RoLTE7MDw9bSYmYS5fX2RpZ2l0KG0pPT09Yy5fX2RpZ2l0KG0pOyltLS07cmV0dXJuIDA+bT8wOmEuX191bnNpZ25lZERpZ2l0KG0pPmMuX191bnNpZ25lZERpZ2l0KG0pPzE6LTF9c3RhdGljIF9fbXVsdGlwbHlBY2N1bXVsYXRlKGEsYyxtLG4pe2lmKDAhPT1jKXt2YXIgZD0zMjc2NyZjLGw9Yz4+PjE1LHI9Yz0wO2ZvcihsZXQgdyxDPTA7QzxhLmxlbmd0aDtDKyssbisrKXt3PW0uX19kaWdpdChuKTt2YXIgdj1hLl9fZGlnaXQoQykscT0zMjc2NyZ2LHQ9dj4+PjE1O3Y9aC5fX2ltdWwocSxkKTtxPWguX19pbXVsKHEsbCk7Y29uc3QgRD1oLl9faW11bCh0LGQpO3Q9aC5fX2ltdWwodCxsKTt3Kz1yK3YrYztjPXc+Pj4zMDt3Jj0xMDczNzQxODIzO3crPSgoMzI3NjcmcSk8PDE1KSsoKDMyNzY3JkQpPDwxNSk7Yys9dz4+PjMwO3I9dCsocT4+PjE1KSsoRD4+PjE1KTttLl9fc2V0RGlnaXQobixcbjEwNzM3NDE4MjMmdyl9Zm9yKDswIT1jfHwwIT09cjtuKyspYT1tLl9fZGlnaXQobiksYSs9YytyLHI9MCxjPWE+Pj4zMCxtLl9fc2V0RGlnaXQobiwxMDczNzQxODIzJmEpfX1zdGF0aWMgX19pbnRlcm5hbE11bHRpcGx5QWRkKGEsYyxtLG4sZCl7bGV0IGw9MDtmb3IobGV0IHE9MDtxPG47cSsrKXt2YXIgcj1hLl9fZGlnaXQocSksdj1oLl9faW11bCgzMjc2NyZyLGMpO3I9aC5fX2ltdWwocj4+PjE1LGMpO3Y9disoKDMyNzY3JnIpPDwxNSkrbCttO209dj4+PjMwO2w9cj4+PjE1O2QuX19zZXREaWdpdChxLDEwNzM3NDE4MjMmdil9aWYoZC5sZW5ndGg+bilmb3IoZC5fX3NldERpZ2l0KG4rKyxtK2wpO248ZC5sZW5ndGg7KWQuX19zZXREaWdpdChuKyssMCk7ZWxzZSBpZigwIT09bStsKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO31fX2lucGxhY2VNdWx0aXBseUFkZChhLGMsbSl7bT50aGlzLmxlbmd0aCYmKG09dGhpcy5sZW5ndGgpO2NvbnN0IG49MzI3NjcmYTthPj4+PVxuMTU7bGV0IGQ9MDtmb3IobGV0IHE9MDtxPG07cSsrKXt2YXIgbD10aGlzLl9fZGlnaXQocSkscj0zMjc2NyZsLHY9bD4+PjE1O2w9aC5fX2ltdWwocixuKTtyPWguX19pbXVsKHIsYSk7Y29uc3QgdD1oLl9faW11bCh2LG4pO3Y9aC5fX2ltdWwodixhKTtsPWMrbCtkO2Q9bD4+PjMwO2wmPTEwNzM3NDE4MjM7bCs9KCgzMjc2NyZyKTw8MTUpKygoMzI3NjcmdCk8PDE1KTtkKz1sPj4+MzA7Yz12KyhyPj4+MTUpKyh0Pj4+MTUpO3RoaXMuX19zZXREaWdpdChxLDEwNzM3NDE4MjMmbCl9aWYoMCE9ZHx8MCE9PWMpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7fXN0YXRpYyBfX2Fic29sdXRlRGl2U21hbGwoYSxjLG0pe209dm9pZCAwPT09bT9udWxsOm07bnVsbD09PW0mJihtPW5ldyBoKGEubGVuZ3RoLCExKSk7bGV0IG49MDtmb3IobGV0IGQsbD0yKmEubGVuZ3RoLTE7MDw9bDtsLT0yKXtkPShuPDwxNXxhLl9faGFsZkRpZ2l0KGwpKT4+PjA7Y29uc3Qgcj0wfGQvYztuPTB8XG5kJWM7ZD0objw8MTV8YS5fX2hhbGZEaWdpdChsLTEpKT4+PjA7Y29uc3Qgdj0wfGQvYztuPTB8ZCVjO20uX19zZXREaWdpdChsPj4+MSxyPDwxNXx2KX1yZXR1cm4gbX1zdGF0aWMgX19hYnNvbHV0ZU1vZFNtYWxsKGEsYyl7bGV0IG09MDtmb3IobGV0IG49MiphLmxlbmd0aC0xOzA8PW47bi0tKW09MHwoKG08PDE1fGEuX19oYWxmRGlnaXQobikpPj4+MCklYztyZXR1cm4gbX1zdGF0aWMgX19hYnNvbHV0ZURpdkxhcmdlKGEsYyxtLG4pe2NvbnN0IGQ9Yy5fX2hhbGZEaWdpdExlbmd0aCgpLGw9Yy5sZW5ndGg7dmFyIHI9YS5fX2hhbGZEaWdpdExlbmd0aCgpLWQ7bGV0IHY9bnVsbDttJiYodj1uZXcgaChyKzI+Pj4xLCExKSx2Ll9faW5pdGlhbGl6ZURpZ2l0cygpKTtjb25zdCBxPW5ldyBoKGQrMj4+PjEsITEpO3EuX19pbml0aWFsaXplRGlnaXRzKCk7Y29uc3QgdD1oLl9fY2x6MTUoYy5fX2hhbGZEaWdpdChkLTEpKTswPHQmJihjPWguX19zcGVjaWFsTGVmdFNoaWZ0KGMsdCwwKSk7XG5hPWguX19zcGVjaWFsTGVmdFNoaWZ0KGEsdCwxKTtjb25zdCB3PWMuX19oYWxmRGlnaXQoZC0xKTtsZXQgQz0wO2ZvcihsZXQgRCxMPXI7MDw9TDtMLS0pe0Q9MzI3Njc7cj1hLl9faGFsZkRpZ2l0KEwrZCk7aWYociE9PXcpe3I9KHI8PDE1fGEuX19oYWxmRGlnaXQoTCtkLTEpKT4+PjA7RD0wfHIvdztyPTB8ciV3O2NvbnN0IE49Yy5fX2hhbGZEaWdpdChkLTIpLEE9YS5fX2hhbGZEaWdpdChMK2QtMik7Zm9yKDtoLl9faW11bChELE4pPj4+MD4ocjw8MTZ8QSk+Pj4wJiYoRC0tLHIrPXcsISgzMjc2NzxyKSk7KTt9aC5fX2ludGVybmFsTXVsdGlwbHlBZGQoYyxELDAsbCxxKTtyPWEuX19pbnBsYWNlU3ViKHEsTCxkKzEpOzAhPT1yJiYocj1hLl9faW5wbGFjZUFkZChjLEwsZCksYS5fX3NldEhhbGZEaWdpdChMK2QsMzI3NjcmYS5fX2hhbGZEaWdpdChMK2QpK3IpLEQtLSk7bSYmKDEmTD9DPUQ8PDE1OnYuX19zZXREaWdpdChMPj4+MSxDfEQpKX1pZihuKXJldHVybiBhLl9faW5wbGFjZVJpZ2h0U2hpZnQodCksXG5tP3txdW90aWVudDp2LHJlbWFpbmRlcjphfTphO2lmKG0pcmV0dXJuIHY7dGhyb3cgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKTt9c3RhdGljIF9fY2x6MTUoYSl7cmV0dXJuIGguX19jbHozMChhKS0xNX1fX2lucGxhY2VBZGQoYSxjLG0pe2xldCBuPTA7Zm9yKGxldCBkPTA7ZDxtO2QrKyl7Y29uc3QgbD10aGlzLl9faGFsZkRpZ2l0KGMrZCkrYS5fX2hhbGZEaWdpdChkKStuO249bD4+PjE1O3RoaXMuX19zZXRIYWxmRGlnaXQoYytkLDMyNzY3JmwpfXJldHVybiBufV9faW5wbGFjZVN1YihhLGMsbSl7bGV0IG49MDtpZigxJmMpe2M+Pj0xO2Zvcih2YXIgZD10aGlzLl9fZGlnaXQoYyksbD0zMjc2NyZkLHI9MDtyPG0tMT4+PjE7cisrKXt2YXIgdj1hLl9fZGlnaXQocik7ZD0oZD4+PjE1KS0oMzI3NjcmdiktbjtuPTEmZD4+PjE1O3RoaXMuX19zZXREaWdpdChjK3IsKDMyNzY3JmQpPDwxNXwzMjc2NyZsKTtkPXRoaXMuX19kaWdpdChjK3IrMSk7bD0oMzI3NjcmZCktKHY+Pj4xNSktbjtuPVxuMSZsPj4+MTV9dj1hLl9fZGlnaXQocik7Y29uc3QgcT0oZD4+PjE1KS0oMzI3NjcmdiktbjtuPTEmcT4+PjE1O3RoaXMuX19zZXREaWdpdChjK3IsKDMyNzY3JnEpPDwxNXwzMjc2NyZsKTtpZihjK3IrMT49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgYm91bmRzXCIpOzA9PSgxJm0pJiYoZD10aGlzLl9fZGlnaXQoYytyKzEpLGw9KDMyNzY3JmQpLSh2Pj4+MTUpLW4sbj0xJmw+Pj4xNSx0aGlzLl9fc2V0RGlnaXQoYythLmxlbmd0aCwxMDczNzA5MDU2JmR8MzI3NjcmbCkpfWVsc2V7Yz4+PTE7Zm9yKGw9MDtsPGEubGVuZ3RoLTE7bCsrKWQ9dGhpcy5fX2RpZ2l0KGMrbCksdj1hLl9fZGlnaXQobCkscj0oMzI3NjcmZCktKDMyNzY3JnYpLW4sbj0xJnI+Pj4xNSxkPShkPj4+MTUpLSh2Pj4+MTUpLW4sbj0xJmQ+Pj4xNSx0aGlzLl9fc2V0RGlnaXQoYytsLCgzMjc2NyZkKTw8MTV8MzI3Njcmcik7cj10aGlzLl9fZGlnaXQoYytsKTthPWEuX19kaWdpdChsKTtcbmQ9KDMyNzY3JnIpLSgzMjc2NyZhKS1uO249MSZkPj4+MTU7dj0wOzA9PSgxJm0pJiYodj0ocj4+PjE1KS0oYT4+PjE1KS1uLG49MSZ2Pj4+MTUpO3RoaXMuX19zZXREaWdpdChjK2wsKDMyNzY3JnYpPDwxNXwzMjc2NyZkKX1yZXR1cm4gbn1fX2lucGxhY2VSaWdodFNoaWZ0KGEpe2lmKDAhPT1hKXt2YXIgYz10aGlzLl9fZGlnaXQoMCk+Pj5hLG09dGhpcy5sZW5ndGgtMTtmb3IobGV0IG49MDtuPG07bisrKXtjb25zdCBkPXRoaXMuX19kaWdpdChuKzEpO3RoaXMuX19zZXREaWdpdChuLDEwNzM3NDE4MjMmZDw8MzAtYXxjKTtjPWQ+Pj5hfXRoaXMuX19zZXREaWdpdChtLGMpfX1zdGF0aWMgX19zcGVjaWFsTGVmdFNoaWZ0KGEsYyxtKXtjb25zdCBuPWEubGVuZ3RoLGQ9bmV3IGgobittLCExKTtpZigwPT09Yyl7Zm9yKGM9MDtjPG47YysrKWQuX19zZXREaWdpdChjLGEuX19kaWdpdChjKSk7cmV0dXJuIDA8bSYmZC5fX3NldERpZ2l0KG4sMCksZH1sZXQgbD0wO2ZvcihsZXQgcj0wO3I8XG5uO3IrKyl7Y29uc3Qgdj1hLl9fZGlnaXQocik7ZC5fX3NldERpZ2l0KHIsMTA3Mzc0MTgyMyZ2PDxjfGwpO2w9dj4+PjMwLWN9cmV0dXJuIDA8bSYmZC5fX3NldERpZ2l0KG4sbCksZH1zdGF0aWMgX19sZWZ0U2hpZnRCeUFic29sdXRlKGEsYyl7dmFyIG09aC5fX3RvU2hpZnRBbW91bnQoYyk7aWYoMD5tKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7Yz0wfG0vMzA7dmFyIG49bSUzMDtjb25zdCBkPWEubGVuZ3RoLGw9MCE9PW4mJjAhPWEuX19kaWdpdChkLTEpPj4+MzAtbjt2YXIgcj1kK2MrKGw/MTowKTttPW5ldyBoKHIsYS5zaWduKTtpZigwPT09bil7Zm9yKG49MDtuPGM7bisrKW0uX19zZXREaWdpdChuLDApO2Zvcig7bjxyO24rKyltLl9fc2V0RGlnaXQobixhLl9fZGlnaXQobi1jKSl9ZWxzZXtyPTA7Zm9yKHZhciB2PTA7djxjO3YrKyltLl9fc2V0RGlnaXQodiwwKTtmb3Iodj0wO3Y8ZDt2Kyspe2NvbnN0IHE9YS5fX2RpZ2l0KHYpO20uX19zZXREaWdpdCh2K1xuYywxMDczNzQxODIzJnE8PG58cik7cj1xPj4+MzAtbn1pZihsKW0uX19zZXREaWdpdChkK2Mscik7ZWxzZSBpZigwIT09cil0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTt9cmV0dXJuIG0uX190cmltKCl9c3RhdGljIF9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoYSxjKXt2YXIgbT1hLmxlbmd0aCxuPWEuc2lnbixkPWguX190b1NoaWZ0QW1vdW50KGMpO2lmKDA+ZClyZXR1cm4gaC5fX3JpZ2h0U2hpZnRCeU1heGltdW0obik7Yz0wfGQvMzA7dmFyIGw9ZCUzMCxyPW0tYztpZigwPj1yKXJldHVybiBoLl9fcmlnaHRTaGlmdEJ5TWF4aW11bShuKTtkPSExO2lmKG4paWYoMCE9KGEuX19kaWdpdChjKSYoMTw8bCktMSkpZD0hMDtlbHNlIGZvcih2YXIgdj0wO3Y8Yzt2KyspaWYoMCE9PWEuX19kaWdpdCh2KSl7ZD0hMDticmVha31kJiYwPT09bCYmMD09fmEuX19kaWdpdChtLTEpJiZyKys7bj1uZXcgaChyLG4pO2lmKDA9PT1sKWZvcihuLl9fc2V0RGlnaXQoci0xLDApLGw9YztsPFxubTtsKyspbi5fX3NldERpZ2l0KGwtYyxhLl9fZGlnaXQobCkpO2Vsc2V7cj1hLl9fZGlnaXQoYyk+Pj5sO209bS1jLTE7Zm9yKHY9MDt2PG07disrKXtjb25zdCBxPWEuX19kaWdpdCh2K2MrMSk7bi5fX3NldERpZ2l0KHYsMTA3Mzc0MTgyMyZxPDwzMC1sfHIpO3I9cT4+Pmx9bi5fX3NldERpZ2l0KG0scil9cmV0dXJuIGQmJihuPWguX19hYnNvbHV0ZUFkZE9uZShuLCEwLG4pKSxuLl9fdHJpbSgpfXN0YXRpYyBfX3JpZ2h0U2hpZnRCeU1heGltdW0oYSl7cmV0dXJuIGE/aC5fX29uZURpZ2l0KDEsITApOmguX196ZXJvKCl9c3RhdGljIF9fdG9TaGlmdEFtb3VudChhKXtpZigxPGEubGVuZ3RoKXJldHVybi0xO2E9YS5fX3Vuc2lnbmVkRGlnaXQoMCk7cmV0dXJuIGE+aC5fX2tNYXhMZW5ndGhCaXRzPy0xOmF9c3RhdGljIF9fdG9QcmltaXRpdmUoYSxjKXtjPXZvaWQgMD09PWM/XCJkZWZhdWx0XCI6YztpZihcIm9iamVjdFwiIT10eXBlb2YgYXx8YS5jb25zdHJ1Y3Rvcj09PWgpcmV0dXJuIGE7XG5jb25zdCBtPWFbU3ltYm9sLnRvUHJpbWl0aXZlXTtpZihtKXthPW0oYyk7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGEpcmV0dXJuIGE7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7fWlmKGM9YS52YWx1ZU9mKWlmKGM9Yy5jYWxsKGEpLFwib2JqZWN0XCIhPXR5cGVvZiBjKXJldHVybiBjO2lmKGM9YS50b1N0cmluZylpZihhPWMuY2FsbChhKSxcIm9iamVjdFwiIT10eXBlb2YgYSlyZXR1cm4gYTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTt9c3RhdGljIF9fdG9OdW1lcmljKGEpe3JldHVybiBoLl9faXNCaWdJbnQoYSk/YTorYX1zdGF0aWMgX19pc0JpZ0ludChhKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuY29uc3RydWN0b3I9PT1ofXN0YXRpYyBfX3RydW5jYXRlVG9OQml0cyhhLGMpe3ZhciBtPTB8KGErMjkpLzMwO2NvbnN0IG49XG5uZXcgaChtLGMuc2lnbik7LS1tO2ZvcihsZXQgZD0wO2Q8bTtkKyspbi5fX3NldERpZ2l0KGQsYy5fX2RpZ2l0KGQpKTtjPWMuX19kaWdpdChtKTswIT1hJTMwJiYoYT0zMi1hJTMwLGM9Yzw8YT4+PmEpO3JldHVybiBuLl9fc2V0RGlnaXQobSxjKSxuLl9fdHJpbSgpfXN0YXRpYyBfX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oYSxjLG0pe3ZhciBuPU1hdGgubWluLGQ9MHwoYSsyOSkvMzA7bT1uZXcgaChkLG0pO2xldCBsPTA7LS1kO3ZhciByPTA7Zm9yKG49bihkLGMubGVuZ3RoKTtsPG47bCsrKXtjb25zdCB2PTAtYy5fX2RpZ2l0KGwpLXI7cj0xJnY+Pj4zMDttLl9fc2V0RGlnaXQobCwxMDczNzQxODIzJnYpfWZvcig7bDxkO2wrKyltLl9fc2V0RGlnaXQobCwwfDEwNzM3NDE4MjMmLXIpO2M9ZDxjLmxlbmd0aD9jLl9fZGlnaXQoZCk6MDthJT0zMDswPT1hP3I9MC1jLXImMTA3Mzc0MTgyMzooYT0zMi1hLGM9Yzw8YT4+PmEsYT0xPDwzMi1hLHI9YS1jLXIsciY9YS0xKTtcbnJldHVybiBtLl9fc2V0RGlnaXQoZCxyKSxtLl9fdHJpbSgpfV9fZGlnaXQoYSl7cmV0dXJuIHRoaXNbYV19X191bnNpZ25lZERpZ2l0KGEpe3JldHVybiB0aGlzW2FdPj4+MH1fX3NldERpZ2l0KGEsYyl7dGhpc1thXT0wfGN9X19zZXREaWdpdEdyb3coYSxjKXt0aGlzW2FdPTB8Y31fX2hhbGZEaWdpdExlbmd0aCgpe2NvbnN0IGE9dGhpcy5sZW5ndGg7cmV0dXJuIDMyNzY3Pj10aGlzLl9fdW5zaWduZWREaWdpdChhLTEpPzIqYS0xOjIqYX1fX2hhbGZEaWdpdChhKXtyZXR1cm4gMzI3NjcmdGhpc1thPj4+MV0+Pj4xNSooMSZhKX1fX3NldEhhbGZEaWdpdChhLGMpe2NvbnN0IG09YT4+PjEsbj10aGlzLl9fZGlnaXQobSk7dGhpcy5fX3NldERpZ2l0KG0sMSZhPzMyNzY3Jm58Yzw8MTU6MTA3MzcwOTA1NiZufDMyNzY3JmMpfXN0YXRpYyBfX2RpZ2l0UG93KGEsYyl7bGV0IG09MTtmb3IoOzA8YzspMSZjJiYobSo9YSksYz4+Pj0xLGEqPWE7cmV0dXJuIG19c3RhdGljIF9faXNPbmVEaWdpdEludChhKXtyZXR1cm4oMTA3Mzc0MTgyMyZcbmEpPT09YX19cmV0dXJuIGguX19rTWF4TGVuZ3RoPTMzNTU0NDMyLGguX19rTWF4TGVuZ3RoQml0cz1oLl9fa01heExlbmd0aDw8NSxoLl9fa01heEJpdHNQZXJDaGFyPVswLDAsMzIsNTEsNjQsNzUsODMsOTAsOTYsMTAyLDEwNywxMTEsMTE1LDExOSwxMjIsMTI2LDEyOCwxMzEsMTM0LDEzNiwxMzksMTQxLDE0MywxNDUsMTQ3LDE0OSwxNTEsMTUzLDE1NCwxNTYsMTU4LDE1OSwxNjAsMTYyLDE2MywxNjUsMTY2XSxoLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdD01LGguX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI9MTw8aC5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQsaC5fX2tDb252ZXJzaW9uQ2hhcnM9XCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5zcGxpdChcIlwiKSxoLl9fa0JpdENvbnZlcnNpb25CdWZmZXI9bmV3IEFycmF5QnVmZmVyKDgpLGguX19rQml0Q29udmVyc2lvbkRvdWJsZT1uZXcgRmxvYXQ2NEFycmF5KGguX19rQml0Q29udmVyc2lvbkJ1ZmZlciksXG5oLl9fa0JpdENvbnZlcnNpb25JbnRzPW5ldyBJbnQzMkFycmF5KGguX19rQml0Q29udmVyc2lvbkJ1ZmZlciksaC5fX2NsejMwPWU/ZnVuY3Rpb24oYSl7cmV0dXJuIGUoYSktMn06ZnVuY3Rpb24oYSl7dmFyIGM9TWF0aC5MTjIsbT1NYXRoLmxvZztyZXR1cm4gMD09PWE/MzA6MHwyOS0oMHxtKGE+Pj4wKS9jKX0saC5fX2ltdWw9Znx8ZnVuY3Rpb24oYSxjKXtyZXR1cm4gMHxhKmN9LGh9KX0sZnVuY3Rpb24oRSxRKXtbLi4uXCJhYmNcIl0uZmxhdCgpfSxmdW5jdGlvbihFLFEsYil7KGZ1bmN0aW9uKGYsZSl7KGZ1bmN0aW9uKGcsayl7ZnVuY3Rpb24gcChEKXtkZWxldGUgdltEXX1mdW5jdGlvbiBoKEQpe2lmKHEpc2V0VGltZW91dChoLDAsRCk7ZWxzZXt2YXIgTD12W0RdO2lmKEwpe3E9ITA7dHJ5e3ZhciBOPUwuY2FsbGJhY2ssQT1MLmFyZ3M7c3dpdGNoKEEubGVuZ3RoKXtjYXNlIDA6TigpO2JyZWFrO2Nhc2UgMTpOKEFbMF0pO2JyZWFrO2Nhc2UgMjpOKEFbMF0sQVsxXSk7YnJlYWs7XG5jYXNlIDM6TihBWzBdLEFbMV0sQVsyXSk7YnJlYWs7ZGVmYXVsdDpOLmFwcGx5KGssQSl9fWZpbmFsbHl7cChEKSxxPSExfX19fWZ1bmN0aW9uIGEoKXt3PWZ1bmN0aW9uKEQpe2UubmV4dFRpY2soZnVuY3Rpb24oKXtoKEQpfSl9fWZ1bmN0aW9uIGMoKXtpZihnLnBvc3RNZXNzYWdlJiYhZy5pbXBvcnRTY3JpcHRzKXt2YXIgRD0hMCxMPWcub25tZXNzYWdlO2cub25tZXNzYWdlPWZ1bmN0aW9uKCl7RD0hMX07Zy5wb3N0TWVzc2FnZShcIlwiLFwiKlwiKTtnLm9ubWVzc2FnZT1MO3JldHVybiBEfX1mdW5jdGlvbiBtKCl7dmFyIEQ9XCJzZXRJbW1lZGlhdGUkXCIrTWF0aC5yYW5kb20oKStcIiRcIixMPWZ1bmN0aW9uKE4pe04uc291cmNlPT09ZyYmXCJzdHJpbmdcIj09PXR5cGVvZiBOLmRhdGEmJjA9PT1OLmRhdGEuaW5kZXhPZihEKSYmaCgrTi5kYXRhLnNsaWNlKEQubGVuZ3RoKSl9O2cuYWRkRXZlbnRMaXN0ZW5lcj9nLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsTCwhMSk6Zy5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLFxuTCk7dz1mdW5jdGlvbihOKXtnLnBvc3RNZXNzYWdlKEQrTixcIipcIil9fWZ1bmN0aW9uIG4oKXt2YXIgRD1uZXcgTWVzc2FnZUNoYW5uZWw7RC5wb3J0MS5vbm1lc3NhZ2U9ZnVuY3Rpb24oTCl7aChMLmRhdGEpfTt3PWZ1bmN0aW9uKEwpe0QucG9ydDIucG9zdE1lc3NhZ2UoTCl9fWZ1bmN0aW9uIGQoKXt2YXIgRD10LmRvY3VtZW50RWxlbWVudDt3PWZ1bmN0aW9uKEwpe3ZhciBOPXQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtOLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2goTCk7Ti5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbDtELnJlbW92ZUNoaWxkKE4pO049bnVsbH07RC5hcHBlbmRDaGlsZChOKX19ZnVuY3Rpb24gbCgpe3c9ZnVuY3Rpb24oRCl7c2V0VGltZW91dChoLDAsRCl9fWlmKCFnLnNldEltbWVkaWF0ZSl7dmFyIHI9MSx2PXt9LHE9ITEsdD1nLmRvY3VtZW50LHcsQz1PYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihnKTtDPUMmJlxuQy5zZXRUaW1lb3V0P0M6ZztcIltvYmplY3QgcHJvY2Vzc11cIj09PXt9LnRvU3RyaW5nLmNhbGwoZy5wcm9jZXNzKT9hKCk6YygpP20oKTpnLk1lc3NhZ2VDaGFubmVsP24oKTp0JiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpP2QoKTpsKCk7Qy5zZXRJbW1lZGlhdGU9ZnVuY3Rpb24oRCl7XCJmdW5jdGlvblwiIT09dHlwZW9mIEQmJihEPW5ldyBGdW5jdGlvbihcIlwiK0QpKTtmb3IodmFyIEw9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxOPTA7TjxMLmxlbmd0aDtOKyspTFtOXT1hcmd1bWVudHNbTisxXTt2W3JdPXtjYWxsYmFjazpELGFyZ3M6TH07dyhyKTtyZXR1cm4gcisrfTtDLmNsZWFySW1tZWRpYXRlPXB9fSkoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBzZWxmP1widW5kZWZpbmVkXCI9PT10eXBlb2YgZj90aGlzOmY6c2VsZil9KS5jYWxsKHRoaXMsYigwKSxiKDgpKX0sZnVuY3Rpb24oRSxRKXtmdW5jdGlvbiBiKCl7dGhyb3cgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO1xufWZ1bmN0aW9uIGYoKXt0aHJvdyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKTt9ZnVuY3Rpb24gZSh2KXtpZihjPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dCh2LDApO2lmKChjPT09Ynx8IWMpJiZzZXRUaW1lb3V0KXJldHVybiBjPXNldFRpbWVvdXQsc2V0VGltZW91dCh2LDApO3RyeXtyZXR1cm4gYyh2LDApfWNhdGNoKHEpe3RyeXtyZXR1cm4gYy5jYWxsKG51bGwsdiwwKX1jYXRjaCh0KXtyZXR1cm4gYy5jYWxsKHRoaXMsdiwwKX19fWZ1bmN0aW9uIGcodil7aWYobT09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHYpO2lmKChtPT09Znx8IW0pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG09Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dCh2KTt0cnl7cmV0dXJuIG0odil9Y2F0Y2gocSl7dHJ5e3JldHVybiBtLmNhbGwobnVsbCx2KX1jYXRjaCh0KXtyZXR1cm4gbS5jYWxsKHRoaXMsdil9fX1mdW5jdGlvbiBrKCl7ZCYmbCYmKGQ9XG4hMSxsLmxlbmd0aD9uPWwuY29uY2F0KG4pOnI9LTEsbi5sZW5ndGgmJnAoKSl9ZnVuY3Rpb24gcCgpe2lmKCFkKXt2YXIgdj1lKGspO2Q9ITA7Zm9yKHZhciBxPW4ubGVuZ3RoO3E7KXtsPW47Zm9yKG49W107KytyPHE7KWwmJmxbcl0ucnVuKCk7cj0tMTtxPW4ubGVuZ3RofWw9bnVsbDtkPSExO2codil9fWZ1bmN0aW9uIGgodixxKXt0aGlzLmZ1bj12O3RoaXMuYXJyYXk9cX1mdW5jdGlvbiBhKCl7fUU9RS5leHBvcnRzPXt9O3RyeXt2YXIgYz1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OmJ9Y2F0Y2godil7Yz1ifXRyeXt2YXIgbT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDpmfWNhdGNoKHYpe209Zn12YXIgbj1bXSxkPSExLGwscj0tMTtFLm5leHRUaWNrPWZ1bmN0aW9uKHYpe3ZhciBxPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoMTxhcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspcVt0LVxuMV09YXJndW1lbnRzW3RdO24ucHVzaChuZXcgaCh2LHEpKTsxIT09bi5sZW5ndGh8fGR8fGUocCl9O2gucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O0UudGl0bGU9XCJicm93c2VyXCI7RS5icm93c2VyPSEwO0UuZW52PXt9O0UuYXJndj1bXTtFLnZlcnNpb249XCJcIjtFLnZlcnNpb25zPXt9O0Uub249YTtFLmFkZExpc3RlbmVyPWE7RS5vbmNlPWE7RS5vZmY9YTtFLnJlbW92ZUxpc3RlbmVyPWE7RS5yZW1vdmVBbGxMaXN0ZW5lcnM9YTtFLmVtaXQ9YTtFLnByZXBlbmRMaXN0ZW5lcj1hO0UucHJlcGVuZE9uY2VMaXN0ZW5lcj1hO0UubGlzdGVuZXJzPWZ1bmN0aW9uKHYpe3JldHVybltdfTtFLmJpbmRpbmc9ZnVuY3Rpb24odil7dGhyb3cgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKTt9O0UuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O0UuY2hkaXI9ZnVuY3Rpb24odil7dGhyb3cgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG59O0UudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKEUsUSl7U2suYXNzZXJ0cz17fTtTay5hc3NlcnRzLmFzc2VydD1mdW5jdGlvbihiLGYpe3JldHVybiBifTtTay5leHBvcnRTeW1ib2woXCJTay5hc3NlcnRzLmFzc2VydFwiLFNrLmFzc2VydHMuYXNzZXJ0KTtTay5hc3NlcnRzLmZhaWw9ZnVuY3Rpb24oYil7fTtTay5leHBvcnRTeW1ib2woXCJTay5hc3NlcnRzLmZhaWxcIixTay5hc3NlcnRzLmZhaWwpfSxmdW5jdGlvbihFLFEpe1NrLmJvb2xfY2hlY2s9ZnVuY3Rpb24oYixmKXtpZih2b2lkIDA9PT1ifHxudWxsPT09Ynx8XCJib29sZWFuXCIhPT10eXBlb2YgYil0aHJvdyBFcnJvcihcIm11c3Qgc3BlY2lmeSBcIitmK1wiIGFuZCBpdCBtdXN0IGJlIGEgYm9vbGVhblwiKTt9O1NrLnB5dGhvbjI9e3ByaW50X2Z1bmN0aW9uOiExLGRpdmlzaW9uOiExLGFic29sdXRlX2ltcG9ydDpudWxsLHVuaWNvZGVfbGl0ZXJhbHM6ITEscHl0aG9uMzohMSxjbGFzc19yZXByOiExLGluaGVyaXRfZnJvbV9vYmplY3Q6ITEsXG5zdXBlcl9hcmdzOiExLG9jdGFsX251bWJlcl9saXRlcmFsOiExLGJhbmtlcnNfcm91bmRpbmc6ITEscHl0aG9uX3ZlcnNpb246ITEsZHVuZGVyX3JvdW5kOiExLGV4Y2VwdGlvbnM6ITEsbm9fbG9uZ190eXBlOiExLGNlaWxfZmxvb3JfaW50OiExLHNpbGVudF9vY3RhbF9saXRlcmFsOiEwfTtTay5weXRob24zPXtwcmludF9mdW5jdGlvbjohMCxkaXZpc2lvbjohMCxhYnNvbHV0ZV9pbXBvcnQ6bnVsbCx1bmljb2RlX2xpdGVyYWxzOiEwLHB5dGhvbjM6ITAsY2xhc3NfcmVwcjohMCxpbmhlcml0X2Zyb21fb2JqZWN0OiEwLHN1cGVyX2FyZ3M6ITAsb2N0YWxfbnVtYmVyX2xpdGVyYWw6ITAsYmFua2Vyc19yb3VuZGluZzohMCxweXRob25fdmVyc2lvbjohMCxkdW5kZXJfcm91bmQ6ITAsZXhjZXB0aW9uczohMCxub19sb25nX3R5cGU6ITAsY2VpbF9mbG9vcl9pbnQ6ITAsc2lsZW50X29jdGFsX2xpdGVyYWw6ITF9O1NrLmNvbmZpZ3VyZT1mdW5jdGlvbihiKXtTay5vdXRwdXQ9Yi5vdXRwdXR8fFxuU2sub3V0cHV0O1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5vdXRwdXQpO1NrLmZpbGV3cml0ZXI9Yi5maWxld3JpdGVyfHxTay5maWxld3JpdGVyO1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5maWxld3JpdGVyKTtTay5kZWJ1Z291dD1iLmRlYnVnb3V0fHxTay5kZWJ1Z291dDtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suZGVidWdvdXQpO1NrLnVuY2F1Z2h0RXhjZXB0aW9uPWIudW5jYXVnaHRFeGNlcHRpb258fFNrLnVuY2F1Z2h0RXhjZXB0aW9uO1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay51bmNhdWdodEV4Y2VwdGlvbik7U2sucmVhZD1iLnJlYWR8fFNrLnJlYWQ7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLnJlYWQpO1NrLm5vbnJlYWRvcGVuPWIubm9ucmVhZG9wZW58fCExO1NrLmFzc2VydHMuYXNzZXJ0KFwiYm9vbGVhblwiPT09dHlwZW9mIFNrLm5vbnJlYWRvcGVuKTtcblNrLmZpbGVvcGVuPWIuZmlsZW9wZW58fHZvaWQgMDtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suZmlsZW9wZW58fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgU2suZmlsZW9wZW4pO1NrLmZpbGV3cml0ZT1iLmZpbGV3cml0ZXx8dm9pZCAwO1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5maWxld3JpdGV8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgU2suZmlsZXdyaXRlKTtTay50aW1lb3V0TXNnPWIudGltZW91dE1zZ3x8U2sudGltZW91dE1zZztTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2sudGltZW91dE1zZyk7U2suZXhwb3J0U3ltYm9sKFwiU2sudGltZW91dE1zZ1wiLFNrLnRpbWVvdXRNc2cpO1NrLnN5c2FyZ3Y9Yi5zeXNhcmd2fHxTay5zeXNhcmd2O1NrLmFzc2VydHMuYXNzZXJ0KFNrLmlzQXJyYXlMaWtlKFNrLnN5c2FyZ3YpKTtTay5fX2Z1dHVyZV9fPWIuX19mdXR1cmVfX3x8U2sucHl0aG9uMztTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18ucHJpbnRfZnVuY3Rpb24sXG5cIlNrLl9fZnV0dXJlX18ucHJpbnRfZnVuY3Rpb25cIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLmRpdmlzaW9uLFwiU2suX19mdXR1cmVfXy5kaXZpc2lvblwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18udW5pY29kZV9saXRlcmFscyxcIlNrLl9fZnV0dXJlX18udW5pY29kZV9saXRlcmFsc1wiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uY2xhc3NfcmVwcixcIlNrLl9fZnV0dXJlX18uY2xhc3NfcmVwclwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uaW5oZXJpdF9mcm9tX29iamVjdCxcIlNrLl9fZnV0dXJlX18uaW5oZXJpdF9mcm9tX29iamVjdFwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uc3VwZXJfYXJncyxcIlNrLl9fZnV0dXJlX18uc3VwZXJfYXJnc1wiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18ub2N0YWxfbnVtYmVyX2xpdGVyYWwsXCJTay5fX2Z1dHVyZV9fLm9jdGFsX251bWJlcl9saXRlcmFsXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nLFxuXCJTay5fX2Z1dHVyZV9fLmJhbmtlcnNfcm91bmRpbmdcIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLnB5dGhvbl92ZXJzaW9uLFwiU2suX19mdXR1cmVfXy5weXRob25fdmVyc2lvblwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uZHVuZGVyX3JvdW5kLFwiU2suX19mdXR1cmVfXy5kdW5kZXJfcm91bmRcIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLmV4Y2VwdGlvbnMsXCJTay5fX2Z1dHVyZV9fLmV4Y2VwdGlvbnNcIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLm5vX2xvbmdfdHlwZSxcIlNrLl9fZnV0dXJlX18ubm9fbG9uZ190eXBlXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5jZWlsX2Zsb29yX2ludCxcIlNrLl9fZnV0dXJlX18uY2VpbF9mbG9vcl9pbnRcIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLnNpbGVudF9vY3RhbF9saXRlcmFsLFwiU2suX19mdXR1cmVfXy5zaWxlbnRfb2N0YWxfbGl0ZXJhbFwiKTtTay5pbWFnZVByb3h5PWIuaW1hZ2VQcm94eXx8XG5cImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC8zMjB4XCI7U2suYXNzZXJ0cy5hc3NlcnQoXCJzdHJpbmdcIj09PXR5cGVvZiBTay5pbWFnZVByb3h5fHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suaW1hZ2VQcm94eSk7U2suaW5wdXRmdW49Yi5pbnB1dGZ1bnx8U2suaW5wdXRmdW47U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLmlucHV0ZnVuKTtTay5pbnB1dGZ1blRha2VzUHJvbXB0PWIuaW5wdXRmdW5UYWtlc1Byb21wdHx8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2suaW5wdXRmdW5UYWtlc1Byb21wdCk7U2sucmV0YWluR2xvYmFscz1iLnJldGFpbmdsb2JhbHN8fGIucmV0YWluR2xvYmFsc3x8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2sucmV0YWluR2xvYmFscyk7U2suZGVidWdnaW5nPWIuZGVidWdnaW5nfHwhMTtTay5hc3NlcnRzLmFzc2VydChcImJvb2xlYW5cIj09PXR5cGVvZiBTay5kZWJ1Z2dpbmcpO1xuU2sua2lsbGFibGVXaGlsZT1iLmtpbGxhYmxlV2hpbGV8fCExO1NrLmFzc2VydHMuYXNzZXJ0KFwiYm9vbGVhblwiPT09dHlwZW9mIFNrLmtpbGxhYmxlV2hpbGUpO1NrLmtpbGxhYmxlRm9yPWIua2lsbGFibGVGb3J8fCExO1NrLmFzc2VydHMuYXNzZXJ0KFwiYm9vbGVhblwiPT09dHlwZW9mIFNrLmtpbGxhYmxlRm9yKTtTay5zaWduYWxzPWIuc2lnbmFscztTay5zaWduYWxzPSEwPT09U2suc2lnbmFscz97bGlzdGVuZXJzOltdLGFkZEV2ZW50TGlzdGVuZXIoZil7U2suc2lnbmFscy5saXN0ZW5lcnMucHVzaChmKX0scmVtb3ZlRXZlbnRMaXN0ZW5lcihmKXtmPVNrLnNpZ25hbHMubGlzdGVuZXJzLmluZGV4T2YoZik7MDw9ZiYmU2suc2lnbmFscy5saXN0ZW5lcnMuc3BsaWNlKGYsMSl9LHNpZ25hbChmLGUpe2Zvcih2YXIgZz0wO2c8U2suc2lnbmFscy5saXN0ZW5lcnMubGVuZ3RoO2crKylTay5zaWduYWxzLmxpc3RlbmVyc1tnXS5jYWxsKG51bGwsZixlKX19Om51bGw7U2suYXNzZXJ0cy5hc3NlcnQoXCJvYmplY3RcIj09PVxudHlwZW9mIFNrLnNpZ25hbHMpO1NrLmJyZWFrcG9pbnRzPWIuYnJlYWtwb2ludHN8fGZ1bmN0aW9uKCl7cmV0dXJuITB9O1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5icmVha3BvaW50cyk7U2suc2V0VGltZW91dD1iLnNldFRpbWVvdXQ7dm9pZCAwPT09U2suc2V0VGltZW91dCYmKFNrLnNldFRpbWVvdXQ9XCJmdW5jdGlvblwiPT09dHlwZW9mIHNldFRpbWVvdXQ/ZnVuY3Rpb24oZixlKXtzZXRUaW1lb3V0KGYsZSl9OmZ1bmN0aW9uKGYsZSl7ZigpfSk7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLnNldFRpbWVvdXQpO1wiZXhlY0xpbWl0XCJpbiBiJiYoU2suZXhlY0xpbWl0PWIuZXhlY0xpbWl0KTtcInlpZWxkTGltaXRcImluIGImJihTay55aWVsZExpbWl0PWIueWllbGRMaW1pdCk7Yi5zeXNwYXRoJiYoU2suc3lzcGF0aD1iLnN5c3BhdGgsU2suYXNzZXJ0cy5hc3NlcnQoU2suaXNBcnJheUxpa2UoU2suc3lzcGF0aCkpLFNrLnJlYWxzeXNwYXRoPVxudm9pZCAwLFNrLnN5c21vZHVsZXM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSkpO1NrLm1pc2NldmFsLnNvZnRzcGFjZV89ITE7U2suc3dpdGNoX3ZlcnNpb24oU2suX19mdXR1cmVfXy5weXRob24zKTtTay5idWlsdGluLnN0ci4kbmV4dD1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19uZXh0X19cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFwibmV4dFwiKTtTay5zZXR1cE9wZXJhdG9ycyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO1NrLnNldHVwRHVuZGVyTWV0aG9kcyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO1NrLnNldHVwT2JqZWN0cyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO1NrLnRva2VuLnNldHVwVG9rZW5zKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmNvbmZpZ3VyZVwiLFNrLmNvbmZpZ3VyZSk7U2sudW5jYXVnaHRFeGNlcHRpb249ZnVuY3Rpb24oYil7dGhyb3cgYjt9O1NrLnVuY2F1Z2h0RXhjZXB0aW9uPWZ1bmN0aW9uKGIpe3Rocm93IGI7XG59O1NrLmV4cG9ydFN5bWJvbChcIlNrLnVuY2F1Z2h0RXhjZXB0aW9uXCIsU2sudW5jYXVnaHRFeGNlcHRpb24pO1NrLnRpbWVvdXRNc2c9ZnVuY3Rpb24oKXtyZXR1cm5cIlByb2dyYW0gZXhjZWVkZWQgcnVuIHRpbWUgbGltaXQuXCJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnRpbWVvdXRNc2dcIixTay50aW1lb3V0TXNnKTtTay5leGVjTGltaXQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1NrLnlpZWxkTGltaXQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1NrLm91dHB1dD1mdW5jdGlvbihiKXt9O1NrLnJlYWQ9ZnVuY3Rpb24oYil7aWYodm9pZCAwPT09U2suYnVpbHRpbkZpbGVzKXRocm93XCJza3VscHQtc3RkbGliLmpzIGhhcyBub3QgYmVlbiBsb2FkZWRcIjtpZih2b2lkIDA9PT1Tay5idWlsdGluRmlsZXMuZmlsZXNbYl0pdGhyb3dcIkZpbGUgbm90IGZvdW5kOiAnXCIrYitcIidcIjtyZXR1cm4gU2suYnVpbHRpbkZpbGVzLmZpbGVzW2JdfTtTay5zeXNhcmd2PVtdO1NrLmdldFN5c0FyZ3Y9ZnVuY3Rpb24oKXtyZXR1cm4gU2suc3lzYXJndn07XG5Tay5leHBvcnRTeW1ib2woXCJTay5nZXRTeXNBcmd2XCIsU2suZ2V0U3lzQXJndik7U2suc3lzcGF0aD1bXTtTay5pbkJyb3dzZXI9dm9pZCAwIT09U2suZ2xvYmFsLmRvY3VtZW50O1NrLmRlYnVnb3V0PWZ1bmN0aW9uKGIpe307KGZ1bmN0aW9uKCl7dm9pZCAwIT09U2suZ2xvYmFsLndyaXRlPyhTay5vdXRwdXQ9U2suZ2xvYmFsLndyaXRlLFNrLmZpbGV3cml0ZXI9U2suZ2xvYmFsLndyaXRlKTp2b2lkIDAhPT1Tay5nbG9iYWwuY29uc29sZSYmdm9pZCAwIT09U2suZ2xvYmFsLmNvbnNvbGUubG9nPyhTay5vdXRwdXQ9ZnVuY3Rpb24oYil7U2suZ2xvYmFsLmNvbnNvbGUubG9nKGIpfSxTay5maWxld3JpdGVyPVNrLm91dHB1dCk6dm9pZCAwIT09U2suZ2xvYmFsLnByaW50JiYoU2sub3V0cHV0PVNrLmdsb2JhbC5wcmludCxTay5maWxld3JpdGVyPVNrLm91dHB1dCk7dm9pZCAwIT09U2suZ2xvYmFsLmNvbnNvbGUmJnZvaWQgMCE9PVNrLmdsb2JhbC5jb25zb2xlLmxvZz9Tay5kZWJ1Z291dD1cbmZ1bmN0aW9uKGIpe1NrLmdsb2JhbC5jb25zb2xlLmxvZyhiKX06dm9pZCAwIT09U2suZ2xvYmFsLnByaW50JiYoU2suZGVidWdvdXQ9U2suZ2xvYmFsLnByaW50KX0pKCk7U2suaW5wdXRmdW49ZnVuY3Rpb24oYil7cmV0dXJuIHdpbmRvdy5wcm9tcHQoYil9O1NrLnNldHVwX21ldGhvZF9tYXBwaW5ncz1mdW5jdGlvbigpe307U2suc2V0dXBEaWN0SXRlcmF0b3JzPWZ1bmN0aW9uKGIpe307U2suc3dpdGNoX3ZlcnNpb249ZnVuY3Rpb24oYil7Y29uc3QgZj17ZmxvYXRfOnttZXRob2RfbmFtZXM6W1wiX19yb3VuZF9fXCJdLDI6WyExXSwzOlshMF19LGludF86e21ldGhvZF9uYW1lczpbXCJfX3JvdW5kX19cIl0sMjpbITFdLDM6WyEwXX0sbGlzdDp7bWV0aG9kX25hbWVzOltcImNsZWFyXCIsXCJjb3B5XCIsXCJzb3J0XCJdLDI6WyExLCExLCEwXSwzOlshMCwhMCwhMF19LGRpY3Q6e21ldGhvZF9uYW1lczpbXCJoYXNfa2V5XCIsXCJrZXlzXCIsXCJpdGVtc1wiLFwidmFsdWVzXCJdLDI6WyEwLCEwLCEwLCEwXSwzOlshMSxcbiEwLCEwLCEwXX19O2ZvcihsZXQgcCBpbiBmKXtjb25zdCBoPVNrLmJ1aWx0aW5bcF0sYT1mW3BdLm1ldGhvZF9uYW1lczt2YXIgZT1mW3BdWzNdO2lmKGImJnZvaWQgMD09PWgucHkzJG1ldGhvZHMpYnJlYWs7ZWxzZSBpZih2b2lkIDA9PT1oLnB5MyRtZXRob2RzKXtoLnB5MyRtZXRob2RzPXt9O2Zvcih2YXIgZz0wO2c8YS5sZW5ndGg7ZysrKXt2YXIgaz1hW2ddO2VbZ10mJihoLnB5MyRtZXRob2RzW2tdPWgucHJvdG90eXBlW2tdLmQkZGVmKX19Yj9nPWgucHkzJG1ldGhvZHM6KGU9ZltwXVsyXSxnPWgucHkyJG1ldGhvZHMpO2ZvcihrPTA7azxhLmxlbmd0aDtrKyspe2NvbnN0IGM9YVtrXTtkZWxldGUgaC5wcm90b3R5cGVbY107ZVtrXSYmKGgucHJvdG90eXBlW2NdPW5ldyBTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yKGgsZ1tjXSkpfX19O1NrLmV4cG9ydFN5bWJvbChcIlNrLl9fZnV0dXJlX19cIixTay5fX2Z1dHVyZV9fKTtTay5leHBvcnRTeW1ib2woXCJTay5pbnB1dGZ1blwiLFxuU2suaW5wdXRmdW4pfSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoZCxsLHIpe2lmKGQuaGFzT3duUHJvcGVydHkobCkpe2NvbnN0IHY9ZFtsXTt2IGluc3RhbmNlb2YgU2suYnVpbHRpbi5mdW5jJiYoZFtsXT1uZXcgU2suYnVpbHRpbltyXSh2KSl9fWZ1bmN0aW9uIGYoZCl7cmV0dXJuIHRoaXMucHJvdG90eXBlW2QuJG1hbmdsZWRdfWZ1bmN0aW9uIGUoZCl7ZD1kLiRtYW5nbGVkO2NvbnN0IGw9dGhpcy5wcm90b3R5cGUudHAkbXJvO2ZvcihsZXQgcj0wO3I8bC5sZW5ndGg7KytyKXtjb25zdCB2PWxbcl0ucHJvdG90eXBlO2lmKHYuaGFzT3duUHJvcGVydHkoZCkpcmV0dXJuIHZbZF19fWZ1bmN0aW9uIGcoZCxsLHIsdil7Y29uc3QgcT1rKHIpLHQ9bC5wcm90b3R5cGU7U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZShkLGwscSx2KTtkPW5ldyBTay5idWlsdGluLnN0cihkKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LHtzayRwcm90b3R5cGljYWw6e3ZhbHVlOiEwLHdyaXRhYmxlOiEwfSxcbnRwJGJhc2VzOnt2YWx1ZTpyLHdyaXRhYmxlOiEwfSx0cCRtcm86e3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9LGh0JHR5cGU6e3ZhbHVlOiEwLHdyaXRhYmxlOiEwfSxodCRuYW1lOnt2YWx1ZTpkLHdyaXRhYmxlOiEwfSxodCRxdWFsbmFtZTp7dmFsdWU6ZCx3cml0YWJsZTohMH19KTt0LnRwJG1ybz1sLiRidWlsZE1STygpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGwseyR0eXBlTG9va3VwOnt2YWx1ZTp0LnNrJHByb3RvdHlwaWNhbD9mOmUsd3JpdGFibGU6ITB9LHNrJGtsYXNzOnt2YWx1ZTohMCx3cml0YWJsZTohMH19KX1mdW5jdGlvbiBrKGQpe2Z1bmN0aW9uIGwodyl7cmV0dXJuIHcuc2skc29saWRCYXNlfHx3LnNrJHNvbGlkU2xvdEJhc2U/dzpsKHcucHJvdG90eXBlLnRwJGJhc2UpfTA9PT1kLmxlbmd0aCYmZC5wdXNoKFNrLmJ1aWx0aW4ub2JqZWN0KTtsZXQgcix2LHEsdDtmb3IobGV0IHc9MDt3PGQubGVuZ3RoO3crKyl7dD1kW3ddO2lmKCFTay5idWlsdGluLmNoZWNrQ2xhc3ModCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFzZXMgbXVzdCBiZSAndHlwZScgb2JqZWN0c1wiKTtcbmlmKHQuc2skdW5hY2NlcHRhYmxlQmFzZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlICdcIit0LnByb3RvdHlwZS50cCRuYW1lK1wiJyBpcyBub3QgYW4gYWNjZXB0YWJsZSBiYXNlIHR5cGVcIik7cT1sKHQpO2lmKHZvaWQgMD09PXYpdj1xLHI9dDtlbHNlIGlmKCF2LiRpc1N1YlR5cGUocSkpaWYocS4kaXNTdWJUeXBlKHYpKXY9cSxyPXQ7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJtdWx0aXBsZSBiYXNlcyBoYXZlIGluc3RhbmNlIGxheW91dCBjb25mbGljdHNcIik7fXJldHVybiByfWZ1bmN0aW9uIHAoZCxsKXtjb25zdCByPWwucHJvdG90eXBlLHY9ci5zayRuc2xvdHN8fDA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJzayRuc2xvdHNcIix7dmFsdWU6ditkLmxlbmd0aCx3cml0YWJsZTohMH0pO2QubGVuZ3RoJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobCxcInNrJHNvbGlkU2xvdEJhc2VcIix7dmFsdWU6ITAsd3JpdGFibGU6ITB9KTtkLmZvckVhY2goKHEsXG50KT0+e3QrPXY7cltxLiRtYW5nbGVkXT1uZXcgU2suYnVpbHRpbi5nZXRzZXRfZGVzY3JpcHRvcihsLHskZ2V0KCl7Y29uc3Qgdz10aGlzLiRzW3RdO2lmKHZvaWQgMD09PXcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IocSk7cmV0dXJuIHd9LCRzZXQodyl7dGhpcy4kc1t0XT13fX0pfSl9ZnVuY3Rpb24gaChkKXtmb3IoO251bGwhPT1kLnByb3RvdHlwZS50cCRiYXNlOyl7aWYodm9pZCAwPT09ZC5zayRrbGFzcyYmZC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJfX2RpY3RfX1wiKSlyZXR1cm4gZD1kLnByb3RvdHlwZS5fX2RpY3RfXyxTay5idWlsdGluLmNoZWNrRGF0YURlc2NyKGQpP2Q6dm9pZCAwO2Q9ZC5wcm90b3R5cGUudHAkYmFzZX19ZnVuY3Rpb24gYShkLGwscil7aWYodm9pZCAwPT09ZC5zayRrbGFzcyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBzZXQgXCIrZC5wcm90b3R5cGUudHAkbmFtZStcIi5cIityLiRqc3N0cigpKTtpZih2b2lkIDA9PT1cbmwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgZGVsZXRlIFwiK2QucHJvdG90eXBlLnRwJG5hbWUrXCIuXCIrci4kanNzdHIoKSk7fWZ1bmN0aW9uIGMoZCxsKXtkPShuZXcgU2suYnVpbHRpbi5zdXBlcl8oZCxkKSkudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kaW5pdHN1YmNsYXNzKTtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZCxbXSxsKX1mdW5jdGlvbiBtKGQpe2NvbnN0IGw9ZC5wcm90b3R5cGU7T2JqZWN0LmtleXMobCkuZm9yRWFjaChyPT57Y29uc3Qgdj1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGxbcl0sU2suYnVpbHRpbi5zdHIuJHNldG5hbWUpO2lmKHZvaWQgMCE9PXYpdHJ5e1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh2LFtkLG5ldyBTay5idWlsdGluLnN0cihyKV0pfWNhdGNoKHEpe3Rocm93IHI9bmV3IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKFwiRXJyb3IgY2FsbGluZyBfX3NldF9uYW1lX18gb24gJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGxbcl0pK1xuXCInIGluc3RhbmNlICdcIityK1wiJyBpbiAnXCIrZC5wcm90b3R5cGUudHAkbmFtZStcIidcIiksci4kY2F1c2U9cSxyO319KX12b2lkIDA9PT1Tay5idWlsdGluJiYoU2suYnVpbHRpbj17fSk7U2suYnVpbHRpbi50eXBlPWZ1bmN0aW9uKGQpe3RoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLnR5cGUmJlNrLmFzc2VydHMuZmFpbChcImNhbGxpbmcgbmV3IFNrLmJ1aWx0aW4udHlwZSBpcyBub3Qgc2FmZVwiKTtyZXR1cm4gZC5vYiR0eXBlfTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTay5idWlsdGluLnR5cGUucHJvdG90eXBlLHtjYWxsOnt2YWx1ZTpGdW5jdGlvbi5wcm90b3R5cGUuY2FsbH0sYXBwbHk6e3ZhbHVlOkZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseX0sdHAkc2xvdHM6e3ZhbHVlOnt0cCRkb2M6XCJ0eXBlKG9iamVjdF9vcl9uYW1lLCBiYXNlcywgZGljdClcXG50eXBlKG9iamVjdCkgLT4gdGhlIG9iamVjdCdzIHR5cGVcXG50eXBlKG5hbWUsIGJhc2VzLCBkaWN0KSAtPiBhIG5ldyB0eXBlXCIsXG50cCRjYWxsOmZ1bmN0aW9uKGQsbCl7aWYodGhpcz09PVNrLmJ1aWx0aW4udHlwZSl7aWYoMT09PWQubGVuZ3RoJiYodm9pZCAwPT09bHx8IWwubGVuZ3RoKSlyZXR1cm4gZFswXS5vYiR0eXBlO2lmKDMhPT1kLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgdGFrZXMgMSBvciAzIGFyZ3VtZW50c1wiKTt9bGV0IHI9dGhpcy5wcm90b3R5cGUudHAkbmV3KGQsbCk7aWYoci4kaXNTdXNwZW5zaW9uKXJldHVybiBTay5taXNjZXZhbC5jaGFpbihyLHY9PntyPXY7aWYoci5vYiR0eXBlLiRpc1N1YlR5cGUodGhpcykpcmV0dXJuIHIudHAkaW5pdChkLGwpfSwoKT0+cik7aWYoci5vYiR0eXBlLiRpc1N1YlR5cGUodGhpcykpe2NvbnN0IHY9ci50cCRpbml0KGQsbCk7cmV0dXJuIHZvaWQgMCE9PXYmJnYuJGlzU3VzcGVuc2lvbj9Tay5taXNjZXZhbC5jaGFpbih2LCgpPT5yKTpyfXJldHVybiByfSx0cCRuZXc6ZnVuY3Rpb24oZCxsKXtpZigzIT09ZC5sZW5ndGgpe2lmKDE9PT1cbmQubGVuZ3RoJiYodm9pZCAwPT09bHx8IWwubGVuZ3RoKSlyZXR1cm4gZFswXS5vYiR0eXBlO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUoKSB0YWtlcyAxIG9yIDMgYXJndW1lbnRzXCIpO31jb25zdCByPWRbMF07dmFyIHY9ZFsxXTtjb25zdCBxPWRbMl07aWYoXCJkaWN0XCIhPT1xLnRwJG5hbWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZSgpIGFyZ3VtZW50IDMgbXVzdCBiZSBkaWN0LCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUocSkpO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUoKSBhcmd1bWVudCAxIG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUocikpO2NvbnN0IHQ9ci4kanNzdHIoKTtpZihcInR1cGxlXCIhPT12LnRwJG5hbWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZSgpIGFyZ3VtZW50IDIgbXVzdCBiZSB0dXBsZSwgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUodikpO3Y9di5zayRhc2FycmF5KCk7ZD1mdW5jdGlvbigpe3RoaXMuc2skaGFzRGljdCYmKHRoaXMuJGQ9bmV3IFNrLmJ1aWx0aW4uZGljdCk7dGhpcy4kcz1bXX07Zyh0LGQsdix0aGlzLmNvbnN0cnVjdG9yKTtjb25zdCB3PWQucHJvdG90eXBlO1NrLmdsb2JhbHMmJih3Ll9fbW9kdWxlX189U2suZ2xvYmFscy5fX25hbWVfXyk7dy5fX2RvY19fPVNrLmJ1aWx0aW4ubm9uZS5ub25lJDt2PXEucXVpY2skbG9va3VwKFNrLmJ1aWx0aW4uc3RyLiRzbG90cyk7bGV0IEM9dm9pZCAwPT09dixEPXZvaWQgMCE9PWQuJHR5cGVMb29rdXAoU2suYnVpbHRpbi5zdHIuJGRpY3QpLEw7dm9pZCAwIT09diYmKEw9bmV3IFNldCx2PVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcodik/W3ZdOlNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKHYpLHYuZm9yRWFjaChOPT57aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoTikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19zbG90c19fIGl0ZW1zIG11c3QgYmUgc3RyaW5ncywgbm90ICdcIitcblNrLmFic3RyLnR5cGVOYW1lKE4pK1wiJ1wiKTtpZighTi4kaXNJZGVudGlmaWVyKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19zbG90c19fIG11c3QgYmUgaWRlbnRpZmllcnNcIik7aWYoTj09PVNrLmJ1aWx0aW4uc3RyLiRkaWN0KXtpZihEKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fZGljdF9fIHNsb3QgZGlzYWxsb3dlZDogd2UgYWxyZWFkeSBnb3Qgb25lXCIpO0M9ITB9ZWxzZSBMLmFkZChTay5tYW5nbGVOYW1lKHIsTikpfSksdj1bLi4uTF0uc29ydCgoTixBKT0+Ti50b1N0cmluZygpLmxvY2FsZUNvbXBhcmUoQS50b1N0cmluZygpKSkscCh2LGQpKTtDJiYhRCYmKHcuX19kaWN0X189bmV3IFNrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3IoZCxuKSxEPSEwKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3LHtodCRzbG90czp7dmFsdWU6dnx8bnVsbCx3cml0YWJsZTohMH0sc2skaGFzRGljdDp7dmFsdWU6RCx3cml0YWJsZTohMH19KTtxLiRpdGVtcygpLmZvckVhY2goTj0+XG57dmFyIFtBLEhdPU47aWYoTCYmTC5oYXMoQSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIidcIitBLnRvU3RyaW5nKCkrXCInIGluIF9fc2xvdHNfXyBjb25mbGljdHMgd2l0aCBjbGFzcyB2YXJpYWJsZVwiKTt3W0EuJG1hbmdsZWRdPUh9KTtpZih3Lmhhc093blByb3BlcnR5KFwiX19xdWFsbmFtZV9fXCIpKXt2PXcuX19xdWFsbmFtZV9fO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHYpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUgX19xdWFsbmFtZV9fIG11c3QgYmUgYSBzdHIsIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUodikrXCInXCIpO3cuaHQkcXVhbG5hbWU9dn12PWQucHJvdG90eXBlO2IodixcIl9faW5pdF9zdWJjbGFzc19fXCIsXCJjbGFzc21ldGhvZFwiKTtiKHYsXCJfX25ld19fXCIsXCJzdGF0aWNtZXRob2RcIik7Yih2LFwiX19jbGFzc19nZXRpdGVtX19cIixcImNsYXNzbWV0aG9kXCIpO2QuJGFsbG9jYXRlU2xvdHMoKTttKGQpO2MoZCxsKTtyZXR1cm4gZH0sXG50cCRpbml0OmZ1bmN0aW9uKGQsbCl7aWYoZCYmMT09ZC5sZW5ndGgmJmwmJmwubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUuX19pbml0X18oKSB0YWtlcyBubyBrZXl3b3JkIGFyZ3VtZW50c1wiKTtpZigzIT1kLmxlbmd0aCYmMSE9ZC5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZS5fX2luaXRfXygpIHRha2VzIDEgb3IgMyBhcmd1bWVudHNcIik7cmV0dXJuIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRpbml0LmNhbGwodGhpcyxbXSl9LHRwJGdldGF0dHI6ZnVuY3Rpb24oZCxsKXt2YXIgcj10aGlzLm9iJHR5cGU7Y29uc3Qgdj1yLiR0eXBlTG9va3VwKGQpO2xldCBxO2lmKHZvaWQgMCE9PXYmJihxPXYudHAkZGVzY3JfZ2V0LHZvaWQgMCE9PXEmJnZvaWQgMCE9PXYudHAkZGVzY3Jfc2V0KSlyZXR1cm4gbD1xLmNhbGwodix0aGlzLHIsbCk7ZD10aGlzLiR0eXBlTG9va3VwKGQpO2lmKHZvaWQgMCE9PWQpcmV0dXJuIHI9XG5kLnRwJGRlc2NyX2dldCx2b2lkIDAhPT1yP2w9ci5jYWxsKGQsbnVsbCx0aGlzLGwpOmQ7aWYodm9pZCAwIT09cSlyZXR1cm4gbD1xLmNhbGwodix0aGlzLHIsbCk7aWYodm9pZCAwIT09dilyZXR1cm4gdn0sdHAkc2V0YXR0cjpmdW5jdGlvbihkLGwscil7aWYoIXRoaXMuc2ska2xhc3Mpe2lmKHZvaWQgMCE9PWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3Qgc2V0IGF0dHJpYnV0ZXMgb2YgYnVpbHQtaW4vZXh0ZW5zaW9uIHR5cGUgJ1wiK3RoaXMucHJvdG90eXBlLnRwJG5hbWUrXCInXCIpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IGRlbGV0ZSBhdHRyaWJ1dGVzIG9uIHR5cGUgb2JqZWN0ICdcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiJ1wiKTt9Y29uc3Qgdj10aGlzLm9iJHR5cGUuJHR5cGVMb29rdXAoZCk7aWYodm9pZCAwIT09dil7Y29uc3QgcT12LnRwJGRlc2NyX3NldDtpZihxKXJldHVybiBxLmNhbGwodix0aGlzLGwscil9cj1kLiRtYW5nbGVkO1xuaWYodm9pZCAwPT09bClpZihsPXRoaXMucHJvdG90eXBlLGwuaGFzT3duUHJvcGVydHkocikpZGVsZXRlIGxbcl0sZD1Tay5kdW5kZXJUb1NrdWxwdFtyXSx2b2lkIDAhPT1kJiYoZGVsZXRlIHRoaXMucHJvdG90eXBlW2RdLGwuc2skcHJvdG90eXBpY2FsfHx0aGlzLiRhbGxvY2F0ZUdldHRlclNsb3QocikpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCJ0eXBlIG9iamVjdCAnXCIrdGhpcy5wcm90b3R5cGUudHAkbmFtZStcIicgaGFzIG5vIGF0dHJpYnV0ZSAnXCIrZC4kanNzdHIoKStcIidcIik7ZWxzZSB0aGlzLnByb3RvdHlwZVtyXT1sLHIgaW4gU2suZHVuZGVyVG9Ta3VscHQmJnRoaXMuJGFsbG9jYXRlU2xvdChyLGwpfSwkcjpmdW5jdGlvbigpe2xldCBkPXRoaXMucHJvdG90eXBlLl9fbW9kdWxlX18sbD1cIlwiLHI9XCJjbGFzc1wiO2QmJlNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZCk/bD1kLnYrXCIuXCI6ZD1udWxsO2R8fHRoaXMuc2ska2xhc3N8fFNrLl9fZnV0dXJlX18uY2xhc3NfcmVwcnx8XG4ocj1cInR5cGVcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxcIityK1wiICdcIitsK3RoaXMucHJvdG90eXBlLnRwJG5hbWUrXCInPlwiKX19LHdyaXRhYmxlOiEwfSx0cCRtZXRob2RzOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSx0cCRjbGFzc21ldGhvZHM6e3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9LHRwJGdldHNldHM6e3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9LHNrJHR5cGU6e3ZhbHVlOiEwfSwkaXNTdWJUeXBlOnt2YWx1ZTpmdW5jdGlvbihkKXtyZXR1cm4gdGhpcz09PWR8fHRoaXMucHJvdG90eXBlIGluc3RhbmNlb2YgZHx8IXRoaXMucHJvdG90eXBlLnNrJHByb3RvdHlwaWNhbCYmdGhpcy5wcm90b3R5cGUudHAkbXJvLmluY2x1ZGVzKGQpfX0sJGFsbG9jYXRlU2xvdDp7dmFsdWU6ZnVuY3Rpb24oZCxsKXtkPVNrLnNsb3RzW2RdO2NvbnN0IHI9ZC4kc2xvdF9uYW1lLHY9dGhpcy5wcm90b3R5cGU7di5oYXNPd25Qcm9wZXJ0eShyKSYmZGVsZXRlIHZbcl07T2JqZWN0LmRlZmluZVByb3BlcnR5KHYsXG5yLHt2YWx1ZTpkLiRzbG90X2Z1bmMobCksd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSl9fSwkYWxsb2NhdGVTbG90czp7dmFsdWU6ZnVuY3Rpb24oKXtjb25zdCBkPXRoaXMucHJvdG90eXBlO3RoaXMucHJvdG90eXBlLnNrJHByb3RvdHlwaWNhbD9PYmplY3Qua2V5cyhkKS5mb3JFYWNoKGw9PntsIGluIFNrLnNsb3RzJiZ0aGlzLiRhbGxvY2F0ZVNsb3QobCxkW2xdKX0pOk9iamVjdC5rZXlzKFNrLnNsb3RzKS5mb3JFYWNoKGw9PntkLmhhc093blByb3BlcnR5KGwpP3RoaXMuJGFsbG9jYXRlU2xvdChsLGRbbF0pOnRoaXMuJGFsbG9jYXRlR2V0dGVyU2xvdChsKX0pO2QuaGFzT3duUHJvcGVydHkoXCJfX2VxX19cIikmJiFkLmhhc093blByb3BlcnR5KFwiX19oYXNoX19cIikmJihkLnRwJGhhc2g9ZC5fX2hhc2hfXz1Tay5idWlsdGluLm5vbmUubm9uZSQpfX0sJGFsbG9jYXRlR2V0dGVyU2xvdDp7dmFsdWU6ZnVuY3Rpb24oZCl7Y29uc3QgbD1Tay5zbG90c1tkXS4kc2xvdF9uYW1lLFxucj10aGlzLnByb3RvdHlwZTtyLmhhc093blByb3BlcnR5KGwpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkocixsLHtjb25maWd1cmFibGU6ITAsZ2V0KCl7Y29uc3Qgdj1yLnRwJG1ybztmb3IobGV0IHE9MTtxPHYubGVuZ3RoO3ErKyl7Y29uc3QgdD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZbcV0ucHJvdG90eXBlLGwpO2lmKHZvaWQgMCE9PXQmJnQudmFsdWUpcmV0dXJuIHQudmFsdWV9fX0pfX0sJHR5cGVMb29rdXA6e3ZhbHVlOmZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLnByb3RvdHlwZS5zayRwcm90b3R5cGljYWw/dGhpcy5wcm90b3R5cGVbZC4kbWFuZ2xlZF06ZS5jYWxsKHRoaXMsZCl9LHdyaXRhYmxlOiEwfSwkbXJvTWVyZ2U6e3ZhbHVlOmZ1bmN0aW9uKGQpe3RoaXMucHJvdG90eXBlLnNrJHByb3RvdHlwaWNhbD0hMDtsZXQgbDtjb25zdCByPVtdO2Zvcig7Oyl7Zm9yKGw9MDtsPGQubGVuZ3RoOysrbCl7dmFyIHY9ZFtsXTtpZigwIT09di5sZW5ndGgpYnJlYWt9aWYobD09PVxuZC5sZW5ndGgpcmV0dXJuIHI7dmFyIHE9W107Zm9yKGw9MDtsPGQubGVuZ3RoOysrbClpZih2PWRbbF0sMCE9PXYubGVuZ3RoKXtjb25zdCB0PXZbMF07dj0wO2E6Zm9yKDt2PGQubGVuZ3RoOysrdil7Y29uc3Qgdz1kW3ZdO2ZvcihsZXQgQz0xO0M8dy5sZW5ndGg7KytDKWlmKHdbQ109PT10KWJyZWFrIGF9dj09PWQubGVuZ3RoJiZxLnB1c2godCl9aWYoMD09PXEubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIkluY29uc2lzdGVudCBwcmVjZWRlbmNlcyBpbiB0eXBlIGhpZXJhcmNoeVwiKTtxPXFbMF07ci5sZW5ndGgmJnRoaXMucHJvdG90eXBlLnNrJHByb3RvdHlwaWNhbCYmT2JqZWN0LmdldFByb3RvdHlwZU9mKHJbci5sZW5ndGgtMV0ucHJvdG90eXBlKSE9PXEucHJvdG90eXBlJiYodGhpcy5wcm90b3R5cGUuc2skcHJvdG90eXBpY2FsPSExKTtyLnB1c2gocSk7Zm9yKGw9MDtsPGQubGVuZ3RoOysrbCl2PWRbbF0sMDx2Lmxlbmd0aCYmdlswXT09PXEmJnYuc3BsaWNlKDAsXG4xKX19fSwkYnVpbGRNUk86e3ZhbHVlOmZ1bmN0aW9uKCl7Y29uc3QgZD1bW3RoaXNdXSxsPXRoaXMucHJvdG90eXBlLnRwJGJhc2VzO2Zvcih2YXIgcj0wO3I8bC5sZW5ndGg7KytyKWQucHVzaChbLi4ubFtyXS5wcm90b3R5cGUudHAkbXJvXSk7cj1bXTtmb3IobGV0IHY9MDt2PGwubGVuZ3RoOysrdilyLnB1c2gobFt2XSk7ZC5wdXNoKHIpO3JldHVybiB0aGlzLiRtcm9NZXJnZShkKX19LHNrJGF0dHJFcnJvcjp7dmFsdWUoKXtyZXR1cm5cInR5cGUgb2JqZWN0ICdcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiJ1wifSx3cml0YWJsZTohMH19KTtTay5idWlsdGluLnR5cGUucHJvdG90eXBlLnRwJGdldHNldHM9e19fYmFzZV9fOnskZ2V0KCl7cmV0dXJuIHRoaXMucHJvdG90eXBlLnRwJGJhc2V8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LF9fYmFzZXNfXzp7JGdldCgpe3ZvaWQgMD09PXRoaXMuc2skdHVwbGVfYmFzZXMmJih0aGlzLnNrJHR1cGxlX2Jhc2VzPW5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMucHJvdG90eXBlLnRwJGJhc2VzKSk7XG5yZXR1cm4gdGhpcy5zayR0dXBsZV9iYXNlc319LF9fbXJvX186eyRnZXQoKXt2b2lkIDA9PT10aGlzLnNrJHR1cGxlX21ybyYmKHRoaXMuc2skdHVwbGVfbXJvPW5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMucHJvdG90eXBlLnRwJG1ybykpO3JldHVybiB0aGlzLnNrJHR1cGxlX21yb319LF9fZGljdF9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLm1hcHBpbmdwcm94eSh0aGlzLnByb3RvdHlwZSl9fSxfX2RvY19fOnskZ2V0KCl7Y29uc3QgZD10aGlzLiR0eXBlTG9va3VwKFNrLmJ1aWx0aW4uc3RyLiRkb2MpO3JldHVybiBkP3ZvaWQgMCE9PWQudHAkZGVzY3JfZ2V0P3RoaXM9PT1Tay5idWlsdGluLnR5cGU/bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMucHJvdG90eXBlLnRwJGRvYyk6ZC50cCRkZXNjcl9nZXQobnVsbCx0aGlzKTp0aGlzLnByb3RvdHlwZS5fX2RvY19fOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJHNldChkKXthKHRoaXMsZCxTay5idWlsdGluLnN0ci4kZG9jKTtcbnRoaXMucHJvdG90eXBlLl9fZG9jX189ZH19LF9fbmFtZV9fOnskZ2V0KCl7bGV0IGQ9dGhpcy5wcm90b3R5cGUuaHQkbmFtZTtpZih2b2lkIDAhPT1kKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoZCk7ZD10aGlzLnByb3RvdHlwZS50cCRuYW1lO2QuaW5jbHVkZXMoXCIuXCIpJiYoZD1kLnNsaWNlKGQubGFzdEluZGV4T2YoXCIuXCIpKzEpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGQpfSwkc2V0KGQpe2EodGhpcyxkLFNrLmJ1aWx0aW4uc3RyLiRuYW1lKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhkKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4gb25seSBhc3NpZ24gc3RyaW5nIHRvIFwiK3RoaXMucHJvdG90eXBlLnRwJG5hbWUrXCIuX19uYW1lX18sIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInXCIpO3RoaXMucHJvdG90eXBlLmh0JG5hbWU9ZDt0aGlzLnByb3RvdHlwZS50cCRuYW1lPWQuJGpzc3RyKCl9fSxfX3F1YWxuYW1lX186eyRnZXQoKXtyZXR1cm4gdGhpcy5wcm90b3R5cGUuaHQkcXVhbG5hbWV8fFxuU2suYWJzdHIubG9va3VwU3BlY2lhbCh0aGlzLFNrLmJ1aWx0aW4uc3RyLiRuYW1lKX0sJHNldChkKXthKHRoaXMsZCxTay5idWlsdGluLnN0ci4kbmFtZSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgYXNzaWduIHN0cmluZyB0byBcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiLl9fcXVhbG5hbWVfXywgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZShkKStcIidcIik7dGhpcy5wcm90b3R5cGUuaHQkcXVhbG5hbWU9ZH19LF9fbW9kdWxlX186eyRnZXQoKXtjb25zdCBkPXRoaXMucHJvdG90eXBlLGw9ZC5fX21vZHVsZV9fO3JldHVybiBsJiZsLm9iJHR5cGUhPT1Tay5idWlsdGluLmdldHNldF9kZXNjcmlwdG9yP2w6ZC50cCRuYW1lLmluY2x1ZGVzKFwiLlwiKT9uZXcgU2suYnVpbHRpbi5zdHIoZC50cCRuYW1lLnNsaWNlKDAsZC50cCRuYW1lLmxhc3RJbmRleE9mKFwiLlwiKSkpOm5ldyBTay5idWlsdGluLnN0cihcImJ1aWx0aW5zXCIpfSxcbiRzZXQoZCl7YSh0aGlzLGQsU2suYnVpbHRpbi5zdHIuJG1vZHVsZSk7dGhpcy5wcm90b3R5cGUuX19tb2R1bGVfXz1kfX19O1NrLmJ1aWx0aW4udHlwZS5wcm90b3R5cGUudHAkbWV0aG9kcz17bXJvOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMuJGJ1aWxkTVJPKCkpfSwkZmxhZ3M6e05vQXJnczohMH19LF9fZGlyX186eyRtZXRoOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZChxKXtxIGluIFNrLnJlc2VydmVkV29yZHNffHwocT1Tay51bmZpeFJlc2VydmVkKHEpLC0xIT09cS5pbmRleE9mKFwiJFwiKXx8bC5oYXMocSl8fChsLmFkZChxKSxyLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKHEpKSkpfWNvbnN0IGw9bmV3IFNldCxyPVtdO2lmKHRoaXMucHJvdG90eXBlLnNrJHByb3RvdHlwaWNhbClmb3IodmFyIHYgaW4gdGhpcy5wcm90b3R5cGUpZCh2KTtlbHNle3Y9dGhpcy5wcm90b3R5cGUudHAkbXJvO2ZvcihsZXQgcT0wO3E8di5sZW5ndGg7cSsrKXtjb25zdCB0PVxuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModltxXS5wcm90b3R5cGUpO2ZvcihsZXQgdz0wO3c8dC5sZW5ndGg7dysrKWQodFt3XSl9fXJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHIpfSwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIlNwZWNpYWxpemVkIF9fZGlyX18gaW1wbGVtZW50YXRpb24gZm9yIHR5cGVzLlwifX07U2suYnVpbHRpbi50eXBlLnRwJGNsYXNzbWV0aG9kcz17X19wcmVwYXJlX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3QoW10pfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfX19O2NvbnN0IG49eyRnZXQoKXtjb25zdCBkPWgodGhpcy5vYiR0eXBlKTtyZXR1cm4gdm9pZCAwIT09ZD9kLnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSk6U2suZ2VuZXJpYy5nZXRTZXREaWN0LiRnZXQuY2FsbCh0aGlzKX0sJHNldChkKXtjb25zdCBsPWgodGhpcy5vYiR0eXBlKTtpZih2b2lkIDAhPT1sKXJldHVybiBsLnRwJGRlc2NyX3NldCh0aGlzLGQpO2lmKHZvaWQgMD09PVxuZCl0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3QoW10pO2Vsc2UgcmV0dXJuIFNrLmdlbmVyaWMuZ2V0U2V0RGljdC4kc2V0LmNhbGwodGhpcyxkKX0sJGRvYzpcImRpY3Rpb25hcnkgZm9yIGluc3RhbmNlIHZhcmlhYmxlcyAoaWYgZGVmaW5lZClcIiwkbmFtZTpcIl9fZGljdF9fXCJ9fSxmdW5jdGlvbihFLFEpe1NrLmdlbmVyaWM9e307U2suZ2VuZXJpYy5nZXRBdHRyPWZ1bmN0aW9uKGIsZil7bGV0IGU7Y29uc3QgZz10aGlzLm9iJHR5cGUsaz1nLiR0eXBlTG9va3VwKGIpO2lmKHZvaWQgMCE9PWsmJihlPWsudHAkZGVzY3JfZ2V0LHZvaWQgMCE9PWUmJnZvaWQgMCE9PWsudHAkZGVzY3Jfc2V0KSlyZXR1cm4gZS5jYWxsKGssdGhpcyxnLGYpO2NvbnN0IHA9dGhpcy4kZDtpZih2b2lkIDAhPT1wJiYoYj1wLnF1aWNrJGxvb2t1cChiKSx2b2lkIDAhPT1iKSlyZXR1cm4gYjtpZih2b2lkIDAhPT1lKXJldHVybiBlLmNhbGwoayx0aGlzLGcsZik7aWYodm9pZCAwIT09aylyZXR1cm4ga307U2suZXhwb3J0U3ltYm9sKFwiU2suZ2VuZXJpYy5nZXRBdHRyXCIsXG5Tay5nZW5lcmljLmdldEF0dHIpO1NrLmdlbmVyaWMuc2V0QXR0cj1mdW5jdGlvbihiLGYsZSl7dmFyIGc9dGhpcy5vYiR0eXBlLiR0eXBlTG9va3VwKGIpO2lmKHZvaWQgMCE9PWcmJm51bGwhPT1nKXtjb25zdCBrPWcudHAkZGVzY3Jfc2V0O2lmKGspcmV0dXJuIGsuY2FsbChnLHRoaXMsZixlKX1lPXRoaXMuJGQ7aWYodm9pZCAwIT09ZSlpZihlLm1wJGFzc19zdWJzY3JpcHQpe2lmKHZvaWQgMCE9PWYpcmV0dXJuIGUubXAkYXNzX3N1YnNjcmlwdChiLGYpO3RyeXtyZXR1cm4gZS5tcCRhc3Nfc3Vic2NyaXB0KGIpfWNhdGNoKGspe2lmKGsgaW5zdGFuY2VvZiBTay5idWlsdGluLktleUVycm9yKXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiJyBvYmplY3QgaGFzIG5vIGF0dHJpYnV0ZSAnXCIrYi4kanNzdHIoKStcIidcIik7dGhyb3cgazt9fWVsc2UgaWYoXCJvYmplY3RcIj09PXR5cGVvZiBlKXtnPWIuJG1hbmdsZWQ7aWYodm9pZCAwIT09XG5mKXtlW2ddPWY7cmV0dXJufWlmKHZvaWQgMCE9PWVbZ10pe2RlbGV0ZSBlW2ddO3JldHVybn19dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IodGhpcy5zayRhdHRyRXJyb3IoKStcIiBoYXMgbm8gYXR0cmlidXRlICdcIitiLiRqc3N0cigpK1wiJ1wiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmdlbmVyaWMuc2V0QXR0clwiLFNrLmdlbmVyaWMuc2V0QXR0cik7U2suZ2VuZXJpYy5uZXc9ZnVuY3Rpb24oYil7cmV0dXJuIGZ1bmN0aW9uKGYsZSl7aWYodGhpcy5jb25zdHJ1Y3Rvcj09PWIpcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yO2Y9bmV3IHRoaXMuY29uc3RydWN0b3I7Yi5jYWxsKGYpO3JldHVybiBmfX07U2suZ2VuZXJpYy5uZXdNZXRob2REZWY9eyRtZXRoKGIsZil7Y29uc3QgZT10aGlzLnByb3RvdHlwZTtpZigxPmIubGVuZ3RoKXRocm93IGI9ZS50cCRuYW1lLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihiK1wiLl9fbmV3X18oKTogbm90IGVub3VnaCBhcmd1bWVudHNcIik7XG52YXIgZz1iLnNoaWZ0KCk7aWYodm9pZCAwPT09Zy5zayR0eXBlKXRocm93IGI9ZS50cCRuYW1lLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihiK1wiX19uZXdfXyhYKTogWCBpcyBub3QgYSB0eXBlIG9iamVjdCAoXCIrU2suYWJzdHIudHlwZU5hbWUoZykrXCIpXCIpO2lmKCFnLiRpc1N1YlR5cGUodGhpcykpdGhyb3cgYj1lLnRwJG5hbWUsZz1nLnByb3RvdHlwZS50cCRuYW1lLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihiK1wiLl9fbmV3X18oXCIrZytcIik6IFwiK2crXCIgaXMgbm90IGEgc3VidHlwZSBvZiBcIitiKTtjb25zdCBrPWcucHJvdG90eXBlLnNrJHN0YXRpY05ldy5wcm90b3R5cGU7aWYoay50cCRuZXchPT1lLnRwJG5ldyl0aHJvdyBiPWUudHAkbmFtZSxnPWcucHJvdG90eXBlLnRwJG5hbWUsbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGIrXCIuX19uZXdfXyhcIitnK1wiKSBpcyBub3Qgc2FmZSwgdXNlIFwiK2sudHAkbmFtZStcIi5fX25ld19fKClcIik7cmV0dXJuIGUudHAkbmV3LmNhbGwoZy5wcm90b3R5cGUsXG5iLGYpfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpcIigkdHlwZSwgKmFyZ3MsICoqa3dhcmdzKVwiLCRuYW1lOlwiX19uZXdfX1wifTtTay5nZW5lcmljLnNlbGZJdGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O1NrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXlDaGVja1NpemU9ZnVuY3Rpb24oKXtpZih0aGlzLiRzZXEubGVuZ3RoIT09dGhpcy4kb3JpZy5nZXQkc2l6ZSgpKXtjb25zdCBiPXRoaXMudHAkbmFtZS5zcGxpdChcIl9cIilbMF07dGhyb3cgbmV3IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKGIrXCIgY2hhbmdlZCBzaXplIGR1cmluZyBpdGVyYXRpb25cIik7fWlmKCEodGhpcy4kaW5kZXg+PXRoaXMuJHNlcS5sZW5ndGgpKXJldHVybiB0aGlzLiRzZXFbdGhpcy4kaW5kZXgrK119O1NrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXk9ZnVuY3Rpb24oKXtjb25zdCBiPXRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXTt2b2lkIDA9PT1iJiYodGhpcy50cCRpdGVybmV4dD0oKT0+e30pO1xucmV0dXJuIGJ9O1NrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWY9eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy4kc2VxLmxlbmd0aC10aGlzLiRpbmRleCl9LCRmbGFnczp7Tm9BcmdzOiEwfX07U2suZ2VuZXJpYy5pdGVyUmV2ZXJzZUxlbmd0aEhpbnRNZXRob2REZWY9eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy4kaW5kZXgpfSwkZmxhZ3M6e05vQXJnczohMH19O1NrLmdlbmVyaWMuZ2V0U2V0RGljdD17JGdldCgpe3JldHVybiB0aGlzLiRkfSwkc2V0KGIpe2lmKHZvaWQgMD09PWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IGRlbGV0ZSBfX2RpY3RfX1wiKTtpZihiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXRoaXMuJGQ9YjtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fZGljdF9fIG11c3QgYmUgc2V0IHRvIGEgZGljdGlvbmFyeSwgbm90IGEgJ1wiK1xuU2suYWJzdHIudHlwZU5hbWUoYikrXCInXCIpO30sJGRvYzpcImRpY3Rpb25hcnkgZm9yIGluc3RhbmNlIHZhcmlhYmxlcyAoaWYgZGVmaW5lZClcIiwkbmFtZTpcIl9fZGljdF9fXCJ9O1NrLmdlbmVyaWMuc2VxQ29tcGFyZT1mdW5jdGlvbihiLGYpe2lmKHRoaXM9PT1iJiZTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5KGYpKXJldHVybiEwO2lmKCEoYiBpbnN0YW5jZW9mIHRoaXMuc2skYnVpbHRpbkJhc2UpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCBlPXRoaXMudjtiPWIudjtsZXQgZztpZihlLmxlbmd0aCE9PWIubGVuZ3RoJiYoXCJFcVwiPT09Znx8XCJOb3RFcVwiPT09ZikpcmV0dXJuXCJFcVwiPT09Zj8hMTohMDtmb3IoZz0wO2c8ZS5sZW5ndGgmJmc8Yi5sZW5ndGgmJihlW2ddPT09YltnXXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGVbZ10sYltnXSxcIkVxXCIpKTsrK2cpO2NvbnN0IGs9ZS5sZW5ndGgscD1iLmxlbmd0aDtpZihnPj1cbmt8fGc+PXApc3dpdGNoKGYpe2Nhc2UgXCJMdFwiOnJldHVybiBrPHA7Y2FzZSBcIkx0RVwiOnJldHVybiBrPD1wO2Nhc2UgXCJFcVwiOnJldHVybiBrPT09cDtjYXNlIFwiTm90RXFcIjpyZXR1cm4gayE9PXA7Y2FzZSBcIkd0XCI6cmV0dXJuIGs+cDtjYXNlIFwiR3RFXCI6cmV0dXJuIGs+PXA7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoKX1yZXR1cm5cIkVxXCI9PT1mPyExOlwiTm90RXFcIj09PWY/ITA6U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGVbZ10sYltnXSxmKX07U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW09e19fY2xhc3NfZ2V0aXRlbV9fOnskbWV0aChiKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uR2VuZXJpY0FsaWFzKHRoaXMsYil9LCRmbGFnczp7T25lQXJnOiEwfX19fSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3M9ZnVuY3Rpb24oYixmLGUsZyxrLHApe2Y9Zi5sZW5ndGg7dm9pZCAwPT09ZyYmKGc9SW5maW5pdHkpO2smJi0tZjtwJiYtLWY7aWYoZjxlfHxmPmcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKChlPT09XG5nP2IrXCIoKSB0YWtlcyBleGFjdGx5IFwiK2UrXCIgYXJndW1lbnRzXCI6ZjxlP2IrXCIoKSB0YWtlcyBhdCBsZWFzdCBcIitlK1wiIGFyZ3VtZW50c1wiOjA8ZT9iK1wiKCkgdGFrZXMgYXQgbW9zdCBcIitnK1wiIGFyZ3VtZW50c1wiOmIrXCIoKSB0YWtlcyBubyBhcmd1bWVudHNcIikrKFwiIChcIitmK1wiIGdpdmVuKVwiKSk7fTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLnB5Q2hlY2tBcmdzXCIsU2suYnVpbHRpbi5weUNoZWNrQXJncyk7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbj1mdW5jdGlvbihiLGYsZSxnLGsscCl7dm9pZCAwPT09ZyYmKGc9SW5maW5pdHkpO2smJi0tZjtwJiYtLWY7aWYoZjxlfHxmPmcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKChlPT09Zz9iK1wiKCkgdGFrZXMgZXhhY3RseSBcIitlK1wiIGFyZ3VtZW50c1wiOmY8ZT9iK1wiKCkgdGFrZXMgYXQgbGVhc3QgXCIrZStcIiBhcmd1bWVudHNcIjpiK1wiKCkgdGFrZXMgYXQgbW9zdCBcIitnK1wiIGFyZ3VtZW50c1wiKSsoXCIgKFwiK2YrXCIgZ2l2ZW4pXCIpKTtcbn07U2suYnVpbHRpbi5weUNoZWNrVHlwZT1mdW5jdGlvbihiLGYsZSl7aWYoIWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGIrXCIgbXVzdCBiZSBhIFwiK2YpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5weUNoZWNrVHlwZVwiLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUpO1NrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZT1mdW5jdGlvbihiKXtyZXR1cm4gbnVsbCE9YiYmdm9pZCAwIT09Yi5tcCRzdWJzY3JpcHR9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZVwiLFNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZSk7U2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlPWZ1bmN0aW9uKGIpe3JldHVybiB2b2lkIDA9PT1iPyExOmIudHAkaXRlcj92b2lkIDAhPT1iLnRwJGl0ZXIoKS50cCRpdGVybmV4dDp2b2lkIDAhPT1iLm1wJHN1YnNjcmlwdH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlXCIsU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKTtcblNrLmJ1aWx0aW4uY2hlY2tDYWxsYWJsZT1mdW5jdGlvbihiKXtyZXR1cm4gbnVsbCE9YiYmdm9pZCAwIT09Yi50cCRjYWxsfTtTay5idWlsdGluLmNoZWNrTnVtYmVyPWZ1bmN0aW9uKGIpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYnx8YiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8YiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRffHxiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmd9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tOdW1iZXJcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKTtTay5idWlsdGluLmNoZWNrQ29tcGxleD1mdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uY29tcGxleH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0NvbXBsZXhcIixTay5idWlsdGluLmNoZWNrQ29tcGxleCk7U2suYnVpbHRpbi5jaGVja0ludD1mdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8XG5cIm51bWJlclwiPT09dHlwZW9mIGImJk51bWJlci5pc0ludGVnZXIoYil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tJbnRcIixTay5idWlsdGluLmNoZWNrSW50KTtTay5idWlsdGluLmNoZWNrRmxvYXQ9ZnVuY3Rpb24oYil7cmV0dXJuIGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0X307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0Zsb2F0XCIsU2suYnVpbHRpbi5jaGVja0Zsb2F0KTtTay5idWlsdGluLmNoZWNrU3RyaW5nPWZ1bmN0aW9uKGIpe3JldHVybiBiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tTdHJpbmdcIixTay5idWlsdGluLmNoZWNrU3RyaW5nKTtTay5idWlsdGluLmNoZWNrQnl0ZXM9ZnVuY3Rpb24oYil7cmV0dXJuIGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzfTtTay5idWlsdGluLmNoZWNrQ2xhc3M9ZnVuY3Rpb24oYil7cmV0dXJuIGIgaW5zdGFuY2VvZiBTay5idWlsdGluLnR5cGV9O1xuU2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0NsYXNzXCIsU2suYnVpbHRpbi5jaGVja0NsYXNzKTtTay5idWlsdGluLmNoZWNrQm9vbD1mdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0Jvb2xcIixTay5idWlsdGluLmNoZWNrQm9vbCk7U2suYnVpbHRpbi5jaGVja05vbmU9ZnVuY3Rpb24oYil7cmV0dXJuIGI9PT1Tay5idWlsdGluLm5vbmUubm9uZSR9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tOb25lXCIsU2suYnVpbHRpbi5jaGVja05vbmUpO1NrLmJ1aWx0aW4uY2hlY2tGdW5jdGlvbj1mdW5jdGlvbihiKXtyZXR1cm4gbnVsbCE9YiYmdm9pZCAwIT09Yi50cCRjYWxsfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrRnVuY3Rpb25cIixTay5idWlsdGluLmNoZWNrRnVuY3Rpb24pO1NrLmJ1aWx0aW4uY2hlY2tEYXRhRGVzY3I9ZnVuY3Rpb24oYil7cmV0dXJuIGImJlxudm9pZCAwIT09Yi50cCRkZXNjcl9zZXR9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tEYXRhRGVzY3JcIixTay5idWlsdGluLmNoZWNrRGF0YURlc2NyKTtTay5idWlsdGluLmNoZWNrQW55U2V0PWZ1bmN0aW9uKGIpe3JldHVybiBiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zZXR8fGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmZyb3plbnNldH07U2suYnVpbHRpbi5jaGVja01hcHBpbmc9ZnVuY3Rpb24oYil7cmV0dXJuIGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3R8fG51bGwhPWImJnZvaWQgMCE9PWIubXAkc3Vic2NyaXB0JiZ2b2lkIDAhPT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsU2suYnVpbHRpbi5zdHIuJGtleXMpfX0sZnVuY3Rpb24oRSxRKXtmdW5jdGlvbiBiKGQsbCl7c3dpdGNoKGwpe2Nhc2UgXCJBZGRcIjpyZXR1cm4gZC5uYiRhZGQ7Y2FzZSBcIlN1YlwiOnJldHVybiBkLm5iJHN1YnRyYWN0O2Nhc2UgXCJNdWx0XCI6cmV0dXJuIGQubmIkbXVsdGlwbHk7Y2FzZSBcIk1hdE11bHRcIjppZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpcmV0dXJuIGQubmIkbWF0cml4X211bHRpcGx5O1xuY2FzZSBcIkRpdlwiOnJldHVybiBkLm5iJGRpdmlkZTtjYXNlIFwiRmxvb3JEaXZcIjpyZXR1cm4gZC5uYiRmbG9vcl9kaXZpZGU7Y2FzZSBcIk1vZFwiOnJldHVybiBkLm5iJHJlbWFpbmRlcjtjYXNlIFwiRGl2TW9kXCI6cmV0dXJuIGQubmIkZGl2bW9kO2Nhc2UgXCJQb3dcIjpyZXR1cm4gZC5uYiRwb3dlcjtjYXNlIFwiTFNoaWZ0XCI6cmV0dXJuIGQubmIkbHNoaWZ0O2Nhc2UgXCJSU2hpZnRcIjpyZXR1cm4gZC5uYiRyc2hpZnQ7Y2FzZSBcIkJpdEFuZFwiOnJldHVybiBkLm5iJGFuZDtjYXNlIFwiQml0WG9yXCI6cmV0dXJuIGQubmIkeG9yO2Nhc2UgXCJCaXRPclwiOnJldHVybiBkLm5iJG9yfX1mdW5jdGlvbiBmKGQsbCl7c3dpdGNoKGwpe2Nhc2UgXCJBZGRcIjpyZXR1cm4gZC5uYiRyZWZsZWN0ZWRfYWRkO2Nhc2UgXCJTdWJcIjpyZXR1cm4gZC5uYiRyZWZsZWN0ZWRfc3VidHJhY3Q7Y2FzZSBcIk11bHRcIjpyZXR1cm4gZC5uYiRyZWZsZWN0ZWRfbXVsdGlwbHk7Y2FzZSBcIk1hdE11bHRcIjppZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpcmV0dXJuIGQubmIkcmVmbGVjdGVkX21hdHJpeF9tdWx0aXBseTtcbmNhc2UgXCJEaXZcIjpyZXR1cm4gZC5uYiRyZWZsZWN0ZWRfZGl2aWRlO2Nhc2UgXCJGbG9vckRpdlwiOnJldHVybiBkLm5iJHJlZmxlY3RlZF9mbG9vcl9kaXZpZGU7Y2FzZSBcIk1vZFwiOnJldHVybiBkLm5iJHJlZmxlY3RlZF9yZW1haW5kZXI7Y2FzZSBcIkRpdk1vZFwiOnJldHVybiBkLm5iJHJlZmxlY3RlZF9kaXZtb2Q7Y2FzZSBcIlBvd1wiOnJldHVybiBkLm5iJHJlZmxlY3RlZF9wb3dlcjtjYXNlIFwiTFNoaWZ0XCI6cmV0dXJuIGQubmIkcmVmbGVjdGVkX2xzaGlmdDtjYXNlIFwiUlNoaWZ0XCI6cmV0dXJuIGQubmIkcmVmbGVjdGVkX3JzaGlmdDtjYXNlIFwiQml0QW5kXCI6cmV0dXJuIGQubmIkcmVmbGVjdGVkX2FuZDtjYXNlIFwiQml0WG9yXCI6cmV0dXJuIGQubmIkcmVmbGVjdGVkX3hvcjtjYXNlIFwiQml0T3JcIjpyZXR1cm4gZC5uYiRyZWZsZWN0ZWRfb3J9fWZ1bmN0aW9uIGUoZCxsKXtzd2l0Y2gobCl7Y2FzZSBcIkFkZFwiOnJldHVybiBkLm5iJGlucGxhY2VfYWRkO2Nhc2UgXCJTdWJcIjpyZXR1cm4gZC5uYiRpbnBsYWNlX3N1YnRyYWN0O1xuY2FzZSBcIk11bHRcIjpyZXR1cm4gZC5uYiRpbnBsYWNlX211bHRpcGx5O2Nhc2UgXCJNYXRNdWx0XCI6aWYoU2suX19mdXR1cmVfXy5weXRob24zKXJldHVybiBkLm5iJGlucGxhY2VfbWF0cml4X211bHRpcGx5O2Nhc2UgXCJEaXZcIjpyZXR1cm4gZC5uYiRpbnBsYWNlX2RpdmlkZTtjYXNlIFwiRmxvb3JEaXZcIjpyZXR1cm4gZC5uYiRpbnBsYWNlX2Zsb29yX2RpdmlkZTtjYXNlIFwiTW9kXCI6cmV0dXJuIGQubmIkaW5wbGFjZV9yZW1haW5kZXI7Y2FzZSBcIlBvd1wiOnJldHVybiBkLm5iJGlucGxhY2VfcG93ZXI7Y2FzZSBcIkxTaGlmdFwiOnJldHVybiBkLm5iJGlucGxhY2VfbHNoaWZ0O2Nhc2UgXCJSU2hpZnRcIjpyZXR1cm4gZC5uYiRpbnBsYWNlX3JzaGlmdDtjYXNlIFwiQml0QW5kXCI6cmV0dXJuIGQubmIkaW5wbGFjZV9hbmQ7Y2FzZSBcIkJpdE9yXCI6cmV0dXJuIGQubmIkaW5wbGFjZV9vcjtjYXNlIFwiQml0WG9yXCI6cmV0dXJuIGQubmIkaW5wbGFjZV94b3J9fWZ1bmN0aW9uIGcoZCxsLHIpe2NvbnN0IHY9XG5sLmNvbnN0cnVjdG9yLHE9ZC5jb25zdHJ1Y3RvcjtsZXQgdDtsZXQgdz0hMTtpZih2IT09cSYmdm9pZCAwPT09di5zayRiYXNlQ2xhc3MmJmwgaW5zdGFuY2VvZiBxKWlmKHQ9ZihsLHIpLHZvaWQgMD09PXQpdz0hMDtlbHNlIGlmKHQhPT1mKGQscikpe3c9ITA7dmFyIEM9dC5jYWxsKGwsZCk7aWYoQyE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKXJldHVybiBDfUM9YihkLHIpO2lmKHZvaWQgMCE9PUMmJihDPUMuY2FsbChkLGwpLEMhPT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCl8fCF3JiZ2IT09cSYmKHR8fCh0PWYobCxyKSksdm9pZCAwIT09dCYmKEM9dC5jYWxsKGwsZCksQyE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKSkpcmV0dXJuIEN9ZnVuY3Rpb24gayhkLGwscil7dmFyIHY9ZShkLHIpO3JldHVybiB2b2lkIDAhPT12JiYodj12LmNhbGwoZCxsKSx2IT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpP1xudjpnKGQsbCxyKX1mdW5jdGlvbiBwKGQpe24uZm9yRWFjaChsPT57dmFyIFtyLHZdPWw7ZFt2XT1mdW5jdGlvbihxKXtyZXR1cm4gdGhpcy50cCRyaWNoY29tcGFyZShxLHIpfX0pfWZ1bmN0aW9uIGgoZCl7Y29uc3QgbD1Tay5yZWZsZWN0ZWROdW1iZXJTbG90cztPYmplY3Qua2V5cyhsKS5mb3JFYWNoKHI9PntpZih2b2lkIDAhPT1kW3JdKXtjb25zdCB2PWxbcl0scT12LnJlZmxlY3RlZCx0PWRbcV07dm9pZCAwIT09dD9udWxsPT09dCYmZGVsZXRlIGRbcV06ZFtxXT12LnNsb3R8fGRbcl19fSl9ZnVuY3Rpb24gYShkKXtjb25zdCBsPVNrLnNlcXVlbmNlQW5kTWFwcGluZ1Nsb3RzO09iamVjdC5rZXlzKGwpLmZvckVhY2gocj0+e3ZvaWQgMCE9PWRbcl0mJmxbcl0uZm9yRWFjaCh2PT57ZFt2XT1kW3JdfSl9KX1Tay5hYnN0cj17fTtTay5hYnN0ci50eXBlTmFtZT1mdW5jdGlvbihkKXtpZihudWxsIT1kJiZ2b2lkIDAhPT1kLnRwJG5hbWUpe2xldCBsPWQuaHQkbmFtZTtpZih2b2lkIDAhPT1cbmwpcmV0dXJuIGwudG9TdHJpbmcoKTtsPWQudHAkbmFtZTtsLmluY2x1ZGVzKFwiLlwiKSYmKGw9bC5zbGljZShsLmxhc3RJbmRleE9mKFwiLlwiKSsxKSk7cmV0dXJuIGx9U2suYXNzZXJ0cy5mYWlsKGQrXCIgcGFzc2VkIHRvIHR5cGVOYW1lXCIpO3JldHVyblwiPGludmFsaWQgdHlwZT5cIn07Y29uc3QgYz17QWRkOlwiK1wiLFN1YjpcIi1cIixNdWx0OlwiKlwiLE1hdE11bHQ6XCJAXCIsRGl2OlwiL1wiLEZsb29yRGl2OlwiLy9cIixNb2Q6XCIlXCIsRGl2TW9kOlwiZGl2bW9kKClcIixQb3c6XCIqKiBvciBwb3coKVwiLExTaGlmdDpcIjw8XCIsUlNoaWZ0OlwiPj5cIixCaXRBbmQ6XCImXCIsQml0WG9yOlwiXlwiLEJpdE9yOlwifFwifSxtPXtVQWRkOlwiK1wiLFVTdWI6XCItXCIsSW52ZXJ0OlwiflwifTtTay5hYnN0ci5udW1iZXJCaW5PcD1mdW5jdGlvbihkLGwscil7dmFyIHY7aWYoISh2PWcoZCxsLHIpKSl0aHJvdyBkPVNrLmFic3RyLnR5cGVOYW1lKGQpLGw9U2suYWJzdHIudHlwZU5hbWUobCksbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmFuZCB0eXBlKHMpIGZvciBcIitcbmNbcl0rXCI6ICdcIitkK1wiJyBhbmQgJ1wiK2wrXCInXCIpO3JldHVybiB2fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJCaW5PcFwiLFNrLmFic3RyLm51bWJlckJpbk9wKTtTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3A9ZnVuY3Rpb24oZCxsLHIpe3ZhciB2O2lmKCEodj1rKGQsbCxyKSkpdGhyb3cgZD1Tay5hYnN0ci50eXBlTmFtZShkKSxsPVNrLmFic3RyLnR5cGVOYW1lKGwpLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhbmQgdHlwZShzKSBmb3IgXCIrY1tyXStcIj06ICdcIitkK1wiJyBhbmQgJ1wiK2wrXCInXCIpO3JldHVybiB2fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3BcIixTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3ApO1NrLmFic3RyLm51bWJlclVuYXJ5T3A9ZnVuY3Rpb24oZCxsKXtpZihcIk5vdFwiPT09bClyZXR1cm4gU2subWlzY2V2YWwuaXNUcnVlKGQpP1NrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ6U2suYnVpbHRpbi5ib29sLnRydWUkO1xuYjp7c3dpdGNoKGwpe2Nhc2UgXCJVU3ViXCI6dmFyIHI9ZC5uYiRuZWdhdGl2ZTticmVhayBiO2Nhc2UgXCJVQWRkXCI6cj1kLm5iJHBvc2l0aXZlO2JyZWFrIGI7Y2FzZSBcIkludmVydFwiOnI9ZC5uYiRpbnZlcnQ7YnJlYWsgYn1yPXZvaWQgMH1yPXZvaWQgMCE9PXI/ci5jYWxsKGQpOnZvaWQgMDtpZighcil0aHJvdyBkPVNrLmFic3RyLnR5cGVOYW1lKGQpLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImJhZCBvcGVyYW5kIHR5cGUgZm9yIHVuYXJ5IFwiK21bbF0rXCI6ICdcIitkK1wiJ1wiKTtyZXR1cm4gcn07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIubnVtYmVyVW5hcnlPcFwiLFNrLmFic3RyLm51bWJlclVuYXJ5T3ApO1NrLmFic3RyLmZpeFNlcUluZGV4Xz1mdW5jdGlvbihkLGwpe2w9U2suYnVpbHRpbi5hc251bSQobCk7MD5sJiZkLnNxJGxlbmd0aCYmKGwrPWQuc3EkbGVuZ3RoKCkpO3JldHVybiBsfTtTay5hYnN0ci5zZXF1ZW5jZUNvbnRhaW5zPWZ1bmN0aW9uKGQsbCxyKXtpZihkLnNxJGNvbnRhaW5zKXJldHVybiBkLnNxJGNvbnRhaW5zKGwsXG5yKTtkPVNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihkKSxmdW5jdGlvbih2KXtyZXR1cm4gdj09PWx8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh2LGwsXCJFcVwiKT9uZXcgU2subWlzY2V2YWwuQnJlYWsoITApOiExfSwhMSk7cmV0dXJuIHI/ZDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coZCl9O1NrLmFic3RyLnNlcXVlbmNlQ29uY2F0PWZ1bmN0aW9uKGQsbCl7aWYoZC5zcSRjb25jYXQpcmV0dXJuIGQuc3EkY29uY2F0KGwpO2lmKFNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZShkKSYmU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGwpJiYobD1nKGQsbCxcIkFkZFwiKSx2b2lkIDAhPT1sKSlyZXR1cm4gbDt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInIG9iamVjdCBjYW4ndCBiZSBjb25jYXRlbmF0ZWRcIik7fTtTay5hYnN0ci5zZXF1ZW5jZUluUGxhY2VDb25jYXQ9ZnVuY3Rpb24oZCxcbmwpe2lmKGQuc3EkaW5wbGFjZV9jb25jYXQpcmV0dXJuIGQuc3EkaW5wbGFjZV9jb25jYXQobCk7aWYoZC5zcSRjb25jYXQpcmV0dXJuIGQuc3EkY29uY2F0KGwpO2lmKFNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZShkKSYmU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGwpJiYobD1rKGQsbCxcIkFkZFwiKSx2b2lkIDAhPT1sKSlyZXR1cm4gbDt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInIG9iamVjdCBjYW4ndCBiZSBjb25jYXRlbmF0ZWRcIik7fTtTay5hYnN0ci5zZXF1ZW5jZUdldEluZGV4T2Y9ZnVuY3Rpb24oZCxsKXtpZihkLmluZGV4KXJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZC5pbmRleCxbZCxsXSk7bGV0IHI9MDtmb3IobGV0IHY9U2suYWJzdHIuaXRlcihkKSxxPXYudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1xO3E9di50cCRpdGVybmV4dCgpKXtpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wobCxxLFxuXCJFcVwiKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhyKTtyKz0xfXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzZXF1ZW5jZS5pbmRleCh4KTogeCBub3QgaW4gc2VxdWVuY2VcIik7fTtTay5hYnN0ci5zZXF1ZW5jZUdldENvdW50T2Y9ZnVuY3Rpb24oZCxsKXtpZihkLmNvdW50KXJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZC5jb3VudCxbZCxsXSk7bGV0IHI9MDtmb3IobGV0IHY9U2suYWJzdHIuaXRlcihkKSxxPXYudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1xO3E9di50cCRpdGVybmV4dCgpKVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChsLHEsXCJFcVwiKSYmKHIrPTEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHIpfTtTay5hYnN0ci5zZXF1ZW5jZUdldEl0ZW09ZnVuY3Rpb24oZCxsLHIpe1wibnVtYmVyXCI9PT10eXBlb2YgbCYmKGw9bmV3IFNrLmJ1aWx0aW4uaW50XyhsKSk7cmV0dXJuIFNrLmFic3RyLm9iamVjdEdldEl0ZW0oZCxsLHIpfTtcblNrLmFic3RyLnNlcXVlbmNlU2V0SXRlbT1mdW5jdGlvbihkLGwscix2KXtcIm51bWJlclwiPT09dHlwZW9mIGwmJihsPW5ldyBTay5idWlsdGluLmludF8obCkpO3JldHVybiBTay5hYnN0ci5vYmplY3RTZXRJdGVtKGQsbCxyLHYpfTtTay5hYnN0ci5zZXF1ZW5jZURlbEl0ZW09ZnVuY3Rpb24oZCxsLHIpe3JldHVybiBTay5hYnN0ci5vYmplY3REZWxJdGVtKGQsbCxyKX07U2suYWJzdHIuc2VxdWVuY2VHZXRTbGljZT1mdW5jdGlvbihkLGwscil7cmV0dXJuIFNrLmFic3RyLm9iamVjdEdldEl0ZW0oZCxuZXcgU2suYnVpbHRpbi5zbGljZShsLHIpKX07U2suYWJzdHIuc2VxdWVuY2VEZWxTbGljZT1mdW5jdGlvbihkLGwscil7cmV0dXJuIFNrLmFic3RyLm9iamVjdERlbEl0ZW0oZCxuZXcgU2suYnVpbHRpbi5zbGljZShsLHIpKX07U2suYWJzdHIuc2VxdWVuY2VTZXRTbGljZT1mdW5jdGlvbihkLGwscix2KXtyZXR1cm4gU2suYWJzdHIub2JqZWN0U2V0SXRlbShkLG5ldyBTay5idWlsdGluLnNsaWNlKGwsXG5yKSl9O1NrLmFic3RyLnNlcXVlbmNlVW5wYWNrPWZ1bmN0aW9uKGQsbCxyLHYpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoZCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IHVucGFjayBub24taXRlcmFibGUgXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCIgb2JqZWN0XCIpO2NvbnN0IHE9U2suYWJzdHIuaXRlcihkKSx0PVtdO2xldCB3PTAsQzswPGwmJihDPVNrLm1pc2NldmFsLml0ZXJGb3IocSxEPT57dC5wdXNoKEQpO2lmKCsrdz09PWwpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVha30pKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oQywoKT0+e2lmKHQubGVuZ3RoPGwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5vdCBlbm91Z2ggdmFsdWVzIHRvIHVucGFjayAoZXhwZWN0ZWQgYXQgbGVhc3QgXCIrcitcIiwgZ290IFwiK3QubGVuZ3RoK1wiKVwiKTtpZighdilyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4ocS50cCRpdGVybmV4dCghMCksXG5MPT57aWYodm9pZCAwIT09TCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwidG9vIG1hbnkgdmFsdWVzIHRvIHVucGFjayAoZXhwZWN0ZWQgXCIrbCtcIilcIik7cmV0dXJuIHR9KTtjb25zdCBEPVtdO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKHEsTD0+e0QucHVzaChMKX0pLCgpPT57Y29uc3QgTD1ELmxlbmd0aCtsLXI7aWYoMD5MKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJub3QgZW5vdWdoIHZhbHVlcyB0byB1bnBhY2sgKGV4cGVjdGVkIGF0IGxlYXN0IFwiK3IrXCIsIGdvdCBcIisocitMKStcIilcIik7dC5wdXNoKG5ldyBTay5idWlsdGluLmxpc3QoRC5zbGljZSgwLEwpKSk7dC5wdXNoKC4uLkQuc2xpY2UoTCkpO3JldHVybiB0fSl9KX07U2suYWJzdHIubWFwcGluZ1VucGFja0ludG9LZXl3b3JkQXJyYXk9ZnVuY3Rpb24oZCxsLHIpe2lmKGwgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpbC4kaXRlbXMoKS5mb3JFYWNoKHE9Plxue3ZhciBbdCx3XT1xO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHQpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcigoci4kcXVhbG5hbWU/ci4kcXVhbG5hbWUrXCIoKSBcIjpcIlwiKStcImtleXdvcmRzIG11c3QgYmUgc3RyaW5nc1wiKTtkLnB1c2godC52KTtkLnB1c2godyl9KTtlbHNle3ZhciB2PVNrLmFic3RyLmxvb2t1cFNwZWNpYWwobCxTay5idWlsdGluLnN0ci4ka2V5cyk7aWYodm9pZCAwPT09dil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJPYmplY3QgaXMgbm90IGEgbWFwcGluZ1wiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHYpLHE9PlNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihxKSx0PT57aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcodCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKChyLiRxdWFsbmFtZT9yLiRxdWFsbmFtZStcIigpIFwiOlwiXCIpK1wia2V5d29yZHMgbXVzdCBiZSBzdHJpbmdzXCIpO1xucmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGwubXAkc3Vic2NyaXB0KHQsITApLHc9PntkLnB1c2godC52KTtkLnB1c2godyl9KX0pKX19O1NrLmFic3RyLmtleXdvcmRBcnJheUZyb21QeURpY3Q9ZnVuY3Rpb24oZCl7Y29uc3QgbD1bXTtkLiRpdGVtcygpLmZvckVhY2gocj0+e3ZhciBbdixxXT1yO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHYpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImtleXdvcmRzIG11c3QgYmUgc3RyaW5nc1wiKTtsLnB1c2godi50b1N0cmluZygpKTtsLnB1c2gocSl9KTtyZXR1cm4gbH07U2suYWJzdHIua2V5d29yZEFycmF5VG9QeURpY3Q9ZnVuY3Rpb24oZCl7Y29uc3QgbD1uZXcgU2suYnVpbHRpbi5kaWN0O2ZvcihsZXQgcj0wO3I8ZC5sZW5ndGg7cis9MilsLm1wJGFzc19zdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc3RyKGRbcl0pLGRbcisxXSk7cmV0dXJuIGx9O1NrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzPWZ1bmN0aW9uKGQsXG5sLHIsdixxKXt2PXZ8fFtdO3ZhciB0PXIubGVuZ3RoK3YubGVuZ3RoLzI7aWYodD5sLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoZCtcIigpIGV4cGVjdGVkIGF0IG1vc3QgXCIrbC5sZW5ndGgrXCIgYXJndW1lbnRzIChcIit0K1wiIGdpdmVuKVwiKTtpZih2Lmxlbmd0aHx8dm9pZCAwIT09cSl7aWYodD09PWwubGVuZ3RoJiYhdi5sZW5ndGgpcmV0dXJuIHI7aWYoMD09PXQmJmwubGVuZ3RoPT09KHEmJnEubGVuZ3RoKSlyZXR1cm4gcX1lbHNlIHJldHVybiByO3I9ci5zbGljZSgwKTtmb3IodD0wO3Q8di5sZW5ndGg7dCs9Mil7Y29uc3Qgdz12W3RdLEM9dlt0KzFdLEQ9bC5pbmRleE9mKHcpO2lmKDA8PUQpe2lmKHZvaWQgMCE9PXJbRF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGQrXCIoKSBnb3QgbXVsdGlwbGUgdmFsdWVzIGZvciBhcmd1bWVudCAnXCIrdytcIidcIik7cltEXT1DfWVsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGQrXCIoKSBnb3QgYW4gdW5leHBlY3RlZCBrZXl3b3JkIGFyZ3VtZW50ICdcIitcbncrXCInXCIpO31pZihxKXt2PWwubGVuZ3RoO2Zvcih0PXYtMTswPD10O3QtLSl2b2lkIDA9PT1yW3RdJiYoclt0XT1xW3EubGVuZ3RoLTEtKHYtMS10KV0pO2w9bC5maWx0ZXIoKHcsQyk9PnZvaWQgMD09PXJbQ10pO2lmKGwubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihkK1wiKCkgbWlzc2luZyBcIitsLmxlbmd0aCtcIiByZXF1aXJlZCBwb3NpdGlvbmFsIGFyZ3VtZW50czogXCIrbC5qb2luKFwiLCBcIikpO31yZXR1cm4gcn07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3NcIixTay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyk7U2suYWJzdHIuY2hlY2tOb0t3YXJncz1mdW5jdGlvbihkLGwpe2lmKGwmJmwubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihkK1wiKCkgdGFrZXMgbm8ga2V5d29yZCBhcmd1bWVudHNcIik7fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5jaGVja05vS3dhcmdzXCIsU2suYWJzdHIuY2hlY2tOb0t3YXJncyk7XG5Tay5hYnN0ci5jaGVja05vQXJncz1mdW5jdGlvbihkLGwscil7aWYobD1sLmxlbmd0aCsocj9yLmxlbmd0aDowKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoZCtcIigpIHRha2VzIG5vIGFyZ3VtZW50cyAoXCIrbCtcIiBnaXZlbilcIik7fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5jaGVja05vQXJnc1wiLFNrLmFic3RyLmNoZWNrTm9BcmdzKTtTay5hYnN0ci5jaGVja09uZUFyZz1mdW5jdGlvbihkLGwscil7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhkLHIpO2lmKDEhPT1sLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoZCtcIigpIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50IChcIitsLmxlbmd0aCtcIiBnaXZlbilcIik7fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5jaGVja09uZUFyZ1wiLFNrLmFic3RyLmNoZWNrT25lQXJnKTtTay5hYnN0ci5jaGVja0FyZ3NMZW49ZnVuY3Rpb24oZCxsLHIsdil7bD1sLmxlbmd0aDt2b2lkIDA9PT12JiYodj1JbmZpbml0eSk7XG5pZihsPHJ8fGw+dil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoKHI9PT12P2QrXCIoKSB0YWtlcyBleGFjdGx5IFwiK3IrXCIgYXJndW1lbnRzXCI6bDxyP2QrXCIoKSB0YWtlcyBhdCBsZWFzdCBcIityK1wiIGFyZ3VtZW50c1wiOmQrXCIoKSB0YWtlcyBhdCBtb3N0IFwiK3YrXCIgYXJndW1lbnRzXCIpKyhcIiAoXCIrbCtcIiBnaXZlbilcIikpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuY2hlY2tBcmdzTGVuXCIsU2suYWJzdHIuY2hlY2tBcmdzTGVuKTtTay5hYnN0ci5vYmplY3RGb3JtYXQ9ZnVuY3Rpb24oZCxsKXtpZih2b2lkIDA9PT1sKWw9U2suYnVpbHRpbi5zdHIuJGVtcHR5c3RyO2Vsc2UgaWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcobCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiRm9ybWF0IHNwZWNpZmllciBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUobCkpO2Q9U2suYWJzdHIubG9va3VwU3BlY2lhbChkLFNrLmJ1aWx0aW4uc3RyLiRmb3JtYXQpO1xubD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZCxbbF0pO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGwpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fZm9ybWF0X18gbXVzdCByZXR1cm4gYSBzdHIsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShsKSk7cmV0dXJuIGx9O1NrLmFic3RyLm9iamVjdEhhc2g9ZnVuY3Rpb24oZCl7Y29uc3QgbD1kLnRwJGhhc2g7aWYodm9pZCAwIT09bCl7aWYoU2suYnVpbHRpbi5jaGVja05vbmUobCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5oYXNoYWJsZSB0eXBlOiAnXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInXCIpO3JldHVybiBkLnRwJGhhc2goKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBKYXZhc2NyaXB0IHR5cGVcIik7fTtTay5hYnN0ci5vYmplY3RBZGQ9ZnVuY3Rpb24oZCxsKXtpZihkLm5iJGFkZClyZXR1cm4gZC5uYiRhZGQobCk7ZD1Tay5hYnN0ci50eXBlTmFtZShkKTtcbmw9U2suYWJzdHIudHlwZU5hbWUobCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmFuZCB0eXBlKHMpIGZvciArOiAnXCIrZCtcIicgYW5kICdcIitsK1wiJ1wiKTt9O1NrLmFic3RyLm9iamVjdE5lZ2F0aXZlPWZ1bmN0aW9uKGQpe2lmKGQubmIkbmVnYXRpdmUpcmV0dXJuIGQubmIkbmVnYXRpdmUoKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJiYWQgb3BlcmFuZCB0eXBlIGZvciB1bmFyeSAtOiAnXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInXCIpO307U2suYWJzdHIub2JqZWN0UG9zaXRpdmU9ZnVuY3Rpb24oZCl7aWYoZC5uYiRwb3NpdGl2ZSlyZXR1cm4gZC5uYiRwb3NpdGl2ZSgpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImJhZCBvcGVyYW5kIHR5cGUgZm9yIHVuYXJ5ICs6ICdcIitTay5hYnN0ci50eXBlTmFtZShkKStcIidcIik7fTtTay5hYnN0ci5vYmplY3REZWxJdGVtPWZ1bmN0aW9uKGQsbCxyKXtpZihkLm1wJGFzc19zdWJzY3JpcHQpcmV0dXJuIGQubXAkYXNzX3N1YnNjcmlwdChsLFxudm9pZCAwLHIpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShkKStcIicgb2JqZWN0IGRvZXMgbm90IHN1cHBvcnQgaXRlbSBkZWxldGlvblwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLm9iamVjdERlbEl0ZW1cIixTay5hYnN0ci5vYmplY3REZWxJdGVtKTtTay5hYnN0ci5vYmplY3RHZXRJdGVtPWZ1bmN0aW9uKGQsbCxyKXtpZihkLm1wJHN1YnNjcmlwdClyZXR1cm4gZC5tcCRzdWJzY3JpcHQobCxyKTtpZihTay5idWlsdGluLmNoZWNrQ2xhc3MoZCkpe2lmKGQ9PT1Tay5idWlsdGluLnR5cGUpcmV0dXJuIG5ldyBTay5idWlsdGluLkdlbmVyaWNBbGlhcyhkLGwpO2NvbnN0IHY9U2suYWJzdHIudHlwZUxvb2t1cChkLFNrLmJ1aWx0aW4uc3RyLiRjbGFzc19nZXRpdGVtKTtpZih2b2lkIDAhPT12KXJldHVybiBkPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh2LFtsXSkscj9kOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhkKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrXG5Tay5hYnN0ci50eXBlTmFtZShkKStcIicgZG9lcyBub3Qgc3VwcG9ydCBpbmRleGluZ1wiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLm9iamVjdEdldEl0ZW1cIixTay5hYnN0ci5vYmplY3RHZXRJdGVtKTtTay5hYnN0ci5vYmplY3RTZXRJdGVtPWZ1bmN0aW9uKGQsbCxyLHYpe2lmKGQubXAkYXNzX3N1YnNjcmlwdClyZXR1cm4gZC5tcCRhc3Nfc3Vic2NyaXB0KGwscix2KTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInIGRvZXMgbm90IHN1cHBvcnQgaXRlbSBhc3NpZ25tZW50XCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIub2JqZWN0U2V0SXRlbVwiLFNrLmFic3RyLm9iamVjdFNldEl0ZW0pO1NrLmFic3RyLmdhdHRyPWZ1bmN0aW9uKGQsbCxyKXtyPWQudHAkZ2V0YXR0cihsLHIpO2lmKHZvaWQgMD09PXIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoZC5zayRhdHRyRXJyb3IoKStcIiBoYXMgbm8gYXR0cmlidXRlICdcIitcbmwuJGpzc3RyKCkrXCInXCIpO3JldHVybiByLiRpc1N1c3BlbnNpb24/U2subWlzY2V2YWwuY2hhaW4ocixmdW5jdGlvbih2KXtpZih2b2lkIDA9PT12KXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKGQuc2skYXR0ckVycm9yKCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSAnXCIrbC4kanNzdHIoKStcIidcIik7cmV0dXJuIHZ9KTpyfTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5nYXR0clwiLFNrLmFic3RyLmdhdHRyKTtTay5hYnN0ci5zYXR0cj1mdW5jdGlvbihkLGwscix2KXtyZXR1cm4gZC50cCRzZXRhdHRyKGwscix2KX07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuc2F0dHJcIixTay5hYnN0ci5zYXR0cik7U2suYWJzdHIuaXRlcm5leHQ9ZnVuY3Rpb24oZCxsKXtyZXR1cm4gZC50cCRpdGVybmV4dChsKX07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuaXRlcm5leHRcIixTay5hYnN0ci5pdGVybmV4dCk7U2suYWJzdHIuaXRlcj1mdW5jdGlvbihkKXtpZihkLnRwJGl0ZXIpe2Q9XG5kLnRwJGl0ZXIoKTtpZihkLnRwJGl0ZXJuZXh0KXJldHVybiBkO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIml0ZXIoKSByZXR1cm5lZCBub24taXRlcmF0b3Igb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInXCIpO31pZihkLm1wJHN1YnNjcmlwdClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2VxX2l0ZXJfKGQpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShkKStcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLml0ZXJcIixTay5hYnN0ci5pdGVyKTtTay5hYnN0ci5sb29rdXBTcGVjaWFsPWZ1bmN0aW9uKGQsbCl7dmFyIHI9ZC5vYiR0eXBlO2lmKHZvaWQgMD09PXIpU2suYXNzZXJ0cy5mYWlsKFwiamF2YXNjcmlwdCBvYmplY3Qgc2VudCB0byBsb29rdXBTcGVjaWFsXCIpO2Vsc2UgaWYobD1yLiR0eXBlTG9va3VwKGwpLHZvaWQgMCE9PWwpcmV0dXJuIHZvaWQgMCE9PVxubC50cCRkZXNjcl9nZXQmJihsPWwudHAkZGVzY3JfZ2V0KGQscikpLGx9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLmxvb2t1cFNwZWNpYWxcIixTay5hYnN0ci5sb29rdXBTcGVjaWFsKTtTay5hYnN0ci50eXBlTG9va3VwPWZ1bmN0aW9uKGQsbCl7bD1kLiR0eXBlTG9va3VwKGwpO3JldHVybiB2b2lkIDAhPT1sJiZsLnRwJGRlc2NyX2dldD9sLnRwJGRlc2NyX2dldChudWxsLGQpOmx9O1NrLmFic3RyLm1hcmtVbmhhc2hhYmxlPWZ1bmN0aW9uKGQpe2Q9ZC5wcm90b3R5cGU7ZC5fX2hhc2hfXz1Tay5idWlsdGluLm5vbmUubm9uZSQ7ZC50cCRoYXNoPVNrLmJ1aWx0aW4ubm9uZS5ub25lJH07U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZT1mdW5jdGlvbihkLGwscix2KXt2PXZ8fFNrLmJ1aWx0aW4udHlwZTtyPXZvaWQgMD09PXI/U2suYnVpbHRpbi5vYmplY3Q6cjtjb25zdCBxPW51bGwhPT1yP3IucHJvdG90eXBlOm51bGw7T2JqZWN0LnNldFByb3RvdHlwZU9mKGwsdi5wcm90b3R5cGUpO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKGwucHJvdG90eXBlLHEpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGwucHJvdG90eXBlLHtzayRvYmplY3Q6e3ZhbHVlOmwsd3JpdGFibGU6ITB9LG9iJHR5cGU6e3ZhbHVlOmwsd3JpdGFibGU6ITB9LHRwJG5hbWU6e3ZhbHVlOmQsd3JpdGFibGU6ITB9LHRwJGJhc2U6e3ZhbHVlOnIsd3JpdGFibGU6ITB9fSl9O1NrLmFic3RyLnNldFVwQnVpbHRpbk1ybz1mdW5jdGlvbihkKXtsZXQgbD1kLnByb3RvdHlwZS50cCRiYXNlO2NvbnN0IHI9bnVsbD09PWw/W106W2xdO2lmKGw9PT1Tay5idWlsdGluLm9iamVjdHx8bnVsbD09PWwpT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsXCJzayRiYXNlQ2xhc3NcIix7dmFsdWU6ITAsd3JpdGFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZC5wcm90b3R5cGUsXCJzayRidWlsdGluQmFzZVwiLHt2YWx1ZTpkLHdyaXRhYmxlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGQsXCJzayRzb2xpZEJhc2VcIix7dmFsdWU6ITAsXG53cml0YWJsZTohMH0pO2NvbnN0IHY9W2RdO2Zvcig7bnVsbCE9PWw7KXYucHVzaChsKSxsPWwucHJvdG90eXBlLnRwJGJhc2U7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZC5wcm90b3R5cGUse3NrJHByb3RvdHlwaWNhbDp7dmFsdWU6ITAsd3JpdGFibGU6ITB9LHRwJGJhc2VzOnt2YWx1ZTpyLHdyaXRhYmxlOiEwfSx0cCRtcm86e3ZhbHVlOnYsd3JpdGFibGU6ITB9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGQsXCIkdHlwZUxvb2t1cFwiLHt2YWx1ZTpmdW5jdGlvbihxKXtyZXR1cm4gdGhpcy5wcm90b3R5cGVbcS4kbWFuZ2xlZF19LHdyaXRhYmxlOiEwfSl9O1NrLmFic3RyLnNldFVwR2V0U2V0cz1mdW5jdGlvbihkLGwpe2lmKHZvaWQgMCE9PVNrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3Ipe3ZhciByPWQucHJvdG90eXBlO2w9bHx8ci50cCRnZXRzZXRzfHx7fTtPYmplY3QuZW50cmllcyhsKS5mb3JFYWNoKHY9Pnt2YXIgW3EsdF09djt0LiRuYW1lPXE7cltxXT1uZXcgU2suYnVpbHRpbi5nZXRzZXRfZGVzY3JpcHRvcihkLFxudCl9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcInRwJGdldHNldHNcIix7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pfX07U2suYWJzdHIuc2V0VXBNZXRob2RzPWZ1bmN0aW9uKGQsbCl7aWYodm9pZCAwIT09U2suYnVpbHRpbi5tZXRob2RfZGVzY3JpcHRvcil7dmFyIHI9ZC5wcm90b3R5cGU7bD1sfHxyLnRwJG1ldGhvZHN8fHt9O09iamVjdC5lbnRyaWVzKGwpLmZvckVhY2godj0+e3ZhciBbcSx0XT12O3QuJG5hbWU9cTtyW3FdPW5ldyBTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yKGQsdCl9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcInRwJG1ldGhvZHNcIix7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pfX07U2suYWJzdHIuc2V0VXBDbGFzc01ldGhvZHM9ZnVuY3Rpb24oZCxsKXtpZih2b2lkIDAhPT1Tay5idWlsdGluLmNsYXNzbWV0aG9kX2Rlc2NyaXB0b3Ipe3ZhciByPWQucHJvdG90eXBlO2w9bHx8ci50cCRjbGFzc21ldGhvZHN8fHt9O09iamVjdC5lbnRyaWVzKGwpLmZvckVhY2godj0+XG57dmFyIFtxLHRdPXY7dC4kbmFtZT1xO3JbcV09bmV3IFNrLmJ1aWx0aW4uY2xhc3NtZXRob2RfZGVzY3JpcHRvcihkLHQpfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJ0cCRjbGFzc21ldGhvZHNcIix7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pfX07Y29uc3Qgbj1PYmplY3QuZW50cmllcyh7RXE6XCJvYiRlcVwiLE5vdEVxOlwib2IkbmVcIixHdDpcIm9iJGd0XCIsR3RFOlwib2IkZ2VcIixMdDpcIm9iJGx0XCIsTHRFOlwib2IkbGVcIn0pO1NrLmFic3RyLnNldFVwU2xvdHM9ZnVuY3Rpb24oZCxsKXtmdW5jdGlvbiByKHcsQyl7cVt3XT1uZXcgU2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3IoZCxTay5zbG90c1t3XSxDKX1mdW5jdGlvbiB2KHcsQyl7XCJzdHJpbmdcIj09PXR5cGVvZiB3P3IodyxDKTp3LmZvckVhY2goRD0+e3IoRCxDKX0pfWlmKHZvaWQgMCE9PVNrLmJ1aWx0aW4ud3JhcHBlcl9kZXNjcmlwdG9yKXt2YXIgcT1kLnByb3RvdHlwZTtsPWx8fHEudHAkc2xvdHN8fHt9O2wudHAkbmV3PT09XG5Tay5nZW5lcmljLm5ldyYmKGwudHAkbmV3PVNrLmdlbmVyaWMubmV3KGQpKTtsLnRwJHJpY2hjb21wYXJlJiZwKGwpO2wudHAkYXNfbnVtYmVyJiZoKGwpO2wudHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZyYmYShsKTtPYmplY3QuZW50cmllcyhsKS5mb3JFYWNoKHc9Pnt2YXIgW0MsRF09dztPYmplY3QuZGVmaW5lUHJvcGVydHkocSxDLHt2YWx1ZTpELHdyaXRhYmxlOiEwfSl9KTtsLnRwJG5ldyYmKHEuX19uZXdfXz1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoU2suZ2VuZXJpYy5uZXdNZXRob2REZWYsZCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHEsXCJzayRzdGF0aWNOZXdcIix7dmFsdWU6ZCx3cml0YWJsZTohMH0pKTtTay5zdWJTbG90cy5tYWluX3Nsb3RzLmZvckVhY2godz0+e3ZhciBbQyxEXT13O3c9bFtDXTt2b2lkIDAhPT13JiZ2KEQsdyl9KTt2YXIgdD1sLnRwJGhhc2g7dm9pZCAwIT09dCYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiB0P3IoXCJfX2hhc2hfX1wiLHQpOnQ9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/XG5xLl9faGFzaF9fPXQ6U2suYXNzZXJ0cy5mYWlsKFwiaW52YWxpZCB0cCRoYXNoXCIpKTtsLnRwJGFzX251bWJlciYmU2suc3ViU2xvdHMubnVtYmVyX3Nsb3RzLmZvckVhY2godz0+e3ZhciBbQyxEXT13O3c9bFtDXTt2b2lkIDAhPT13JiZ2KEQsdyl9KTtsLnRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmcmJlNrLnN1YlNsb3RzLnNlcXVlbmNlX2FuZF9tYXBwaW5nX3Nsb3RzLmZvckVhY2godz0+e3ZhciBbQyxEXT13O3c9bFtDXTt2b2lkIDAhPT13JiZ2KEQsdyl9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkocSxcInRwJHNsb3RzXCIse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KX19O1NrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3M9ZnVuY3Rpb24oZCxsKXtsPWx8fHt9O1NrLmFzc2VydHMuYXNzZXJ0KGwuaGFzT3duUHJvcGVydHkoXCJjb25zdHJ1Y3RvclwiKSxcIkEgY29uc3RydWN0b3IgaXMgcmVxdWlyZWQgdG8gYnVpbGQgYSBuYXRpdmUgY2xhc3NcIik7bGV0IHI9bC5jb25zdHJ1Y3RvcjtTay5hYnN0ci5zZXRVcEluaGVyaXRhbmNlKGQsXG5yLGwuYmFzZSxsLm1ldGEpO1NrLmFic3RyLnNldFVwQnVpbHRpbk1ybyhyKTtjb25zdCB2PXIucHJvdG90eXBlO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHYse3RwJHNsb3RzOnt2YWx1ZTpsLnNsb3RzLHdyaXRhYmxlOiEwfSx0cCRnZXRzZXRzOnt2YWx1ZTpsLmdldHNldHMsd3JpdGFibGU6ITB9LHRwJG1ldGhvZHM6e3ZhbHVlOmwubWV0aG9kcyx3cml0YWJsZTohMH0sdHAkY2xhc3NtZXRob2RzOnt2YWx1ZTpsLmNsYXNzbWV0aG9kcyx3cml0YWJsZTohMH19KTtTay5hYnN0ci5zZXRVcFNsb3RzKHIsbC5zbG90c3x8e30pO1NrLmFic3RyLnNldFVwTWV0aG9kcyhyLGwubWV0aG9kcyk7U2suYWJzdHIuc2V0VXBHZXRTZXRzKHIsbC5nZXRzZXRzKTtTay5hYnN0ci5zZXRVcENsYXNzTWV0aG9kcyhyLGwuY2xhc3NtZXRob2RzKTtPYmplY3QuZW50cmllcyhsLnByb3RvfHx7fSkuZm9yRWFjaChxPT57dmFyIFt0LHddPXE7T2JqZWN0LmRlZmluZVByb3BlcnR5KHYsdCx7dmFsdWU6dyxcbndyaXRhYmxlOiEwLGVudW1lcmFibGU6ISh0LmluY2x1ZGVzKFwiJFwiKXx8dCBpbiBPYmplY3QucHJvdG90eXBlKX0pfSk7T2JqZWN0LmVudHJpZXMobC5mbGFnc3x8e30pLmZvckVhY2gocT0+e3ZhciBbdCx3XT1xO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLHQse3ZhbHVlOncsd3JpdGFibGU6ITB9KX0pO3ZvaWQgMCE9PVNrLmJ1aWx0aW4uc3RyJiZ2Lmhhc093blByb3BlcnR5KFwidHAkZG9jXCIpJiYhdi5oYXNPd25Qcm9wZXJ0eShcIl9fZG9jX19cIikmJihkPXYudHAkZG9jfHxudWxsLHYuX19kb2NfXz1cInN0cmluZ1wiPT09dHlwZW9mIGQ/bmV3IFNrLmJ1aWx0aW4uc3RyKGQpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7cmV0dXJuIHJ9O1NrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcz1mdW5jdGlvbihkLGwpe1NrLmFzc2VydHMuYXNzZXJ0KGwuaGFzT3duUHJvcGVydHkoXCJjb25zdHJ1Y3RvclwiKSxcIm11c3QgcHJvdmlkZSBhIGNvbnN0cnVjdG9yXCIpO2wuc2xvdHM9bC5zbG90c3x8e307bC5zbG90cy50cCRpdGVyPVxuU2suZ2VuZXJpYy5zZWxmSXRlcjtsLnNsb3RzLnRwJGl0ZXJuZXh0PWwuc2xvdHMudHAkaXRlcm5leHR8fGwuaXRlcm5leHQ7bC5zbG90cy50cCRnZXRhdHRyPWwuc2xvdHMudHAkZ2V0YXR0cnx8U2suZ2VuZXJpYy5nZXRBdHRyO2Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhkLGwpO1NrLmFic3RyLmJ1aWx0JGl0ZXJhdG9ycy5wdXNoKGQpO3JldHVybiBkfTtTay5hYnN0ci5idWlsdCRpdGVyYXRvcnM9W107U2suYWJzdHIuc2V0VXBNb2R1bGVNZXRob2RzPWZ1bmN0aW9uKGQsbCxyKXtPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKHY9Pnt2YXIgW3EsdF09djt0LiRuYW1lPXQuJG5hbWV8fHE7bFtxXT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QodCxudWxsLGQpfSl9O1NrLmFic3RyLnN1cGVyQ29uc3RydWN0b3I9ZnVuY3Rpb24oZCxsLHIpe3ZhciB2PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtkLnByb3RvdHlwZS50cCRiYXNlLmFwcGx5KGwsdil9fSxcbmZ1bmN0aW9uKEUsUSl7ZnVuY3Rpb24gYihnKXtjb25zdCBrPWcucHJvdG90eXBlLHA9ay50cCRiYXNlO2lmKG51bGw9PXApcmV0dXJuITE7Y29uc3QgaD1wLnByb3RvdHlwZTtyZXR1cm4gcC5zayRzb2xpZFNsb3RCYXNlfHxnLnNrJHNvbGlkU2xvdEJhc2V8fGguc2skaGFzRGljdCE9PWsuc2skaGFzRGljdHx8cC5zayRzb2xpZEJhc2UmJnAhPT1Tay5idWlsdGluLm1vZHVsZT8hMTohMH1mdW5jdGlvbiBmKGcsayl7Zz1nLnByb3RvdHlwZTtrPWsucHJvdG90eXBlO2NvbnN0IHA9Zy5odCRzbG90cyxoPWsuaHQkc2xvdHM7cmV0dXJuIGcuc2skaGFzRGljdCE9PWsuc2skaGFzRGljdD8hMTpwPT09aD8hMDpwJiZoP3AubGVuZ3RoPT09aC5sZW5ndGgmJnAuZXZlcnkoKGEsYyk9PmE9PT1oW2NdKToocCYmKHAubGVuZ3RofHxudWxsKSk9PT0oaCYmKGgubGVuZ3RofHxudWxsKSl9Y29uc3QgZT1uZXcgV2Vha01hcDtTay5idWlsdGluLm9iamVjdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwib2JqZWN0XCIsXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5vYmplY3QsXCJiYWQgY2FsbCB0byBvYmplY3QsIHVzZSAnbmV3J1wiKX0sYmFzZTpudWxsLHNsb3RzOnt0cCRuZXcoZyxrKXtpZihnLmxlbmd0aHx8ayYmay5sZW5ndGgpe2lmKHRoaXMudHAkbmV3IT09U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLnRwJG5ldyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvYmplY3QuX19uZXdfXygpIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50ICh0aGUgdHlwZSB0byBpbnN0YW50aWF0ZSlcIik7aWYodGhpcy50cCRpbml0PT09U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLnRwJGluaXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKCkgdGFrZXMgbm8gYXJndW1lbnRzXCIpO31yZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3J9LHRwJGluaXQoZyxrKXtpZihnLmxlbmd0aHx8XG5rJiZrLmxlbmd0aCl7aWYodGhpcy50cCRpbml0IT09U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLnRwJGluaXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwib2JqZWN0Ll9faW5pdF9fKCkgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQgKHRoZSBpbnN0YW5jZSB0byBpbml0aWFsaXplKVwiKTtpZih0aGlzLnRwJG5ldz09PVNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRuZXcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiLl9faW5pdF9fKCkgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQgKHRoZSBpbnN0YW5jZSB0byBpbml0aWFsaXplKVwiKTt9fSx0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRzZXRhdHRyOlNrLmdlbmVyaWMuc2V0QXR0ciwkcigpe2NvbnN0IGc9U2suYWJzdHIubG9va3VwU3BlY2lhbCh0aGlzLFNrLmJ1aWx0aW4uc3RyLiRtb2R1bGUpO2xldCBrPVwiXCI7ZyYmU2suYnVpbHRpbi5jaGVja1N0cmluZyhnKSYmXG4oaz1nLnYrXCIuXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8XCIraytTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIiBvYmplY3Q+XCIpfSx0cCRzdHIoKXtyZXR1cm4gdGhpcy4kcigpfSx0cCRoYXNoKCl7bGV0IGc9ZS5nZXQodGhpcyk7aWYodm9pZCAwIT09ZylyZXR1cm4gZztnPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUi1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUi8yKTtlLnNldCh0aGlzLGcpO3JldHVybiBnfSx0cCRyaWNoY29tcGFyZShnLGspe3N3aXRjaChrKXtjYXNlIFwiRXFcIjpnPXRoaXM9PT1nfHxTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDticmVhaztjYXNlIFwiTm90RXFcIjpnPXRoaXMub2IkZXEoZyxcIkVxXCIpO2chPT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCYmKGc9IVNrLm1pc2NldmFsLmlzVHJ1ZShnKSk7YnJlYWs7ZGVmYXVsdDpnPVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfXJldHVybiBnfSxcbnRwJGRvYzpcIlRoZSBtb3N0IGJhc2UgdHlwZVwifSxnZXRzZXRzOntfX2NsYXNzX186eyRnZXQoKXtyZXR1cm4gdGhpcy5vYiR0eXBlfSwkc2V0KGcpe2lmKHZvaWQgMD09PWcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgZGVsZXRlIF9fY2xhc3NfXyBhdHRyaWJ1dGVcIik7aWYoIVNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhnKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2NsYXNzX18gbXVzdCBiZSBzZXQgdG8gYSBjbGFzcywgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZShnKStcIicgb2JqZWN0XCIpO2NvbnN0IGs9dGhpcy5vYiR0eXBlO2lmKCEoay4kaXNTdWJUeXBlKFNrLmJ1aWx0aW4ubW9kdWxlKSYmZy4kaXNTdWJUeXBlKFNrLmJ1aWx0aW4ubW9kdWxlKXx8dm9pZCAwIT09ay5wcm90b3R5cGUuaHQkdHlwZSYmdm9pZCAwIT09Zy5wcm90b3R5cGUuaHQkdHlwZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiIF9fY2xhc3NfXyBhc3NpZ25tZW50IG9ubHkgc3VwcG9ydGVkIGZvciBoZWFwIHR5cGVzIG9yIE1vZHVsZVR5cGUgc3ViY2xhc3Nlc1wiKTtcbntsZXQgcD1rLGg9Zztmb3IoO2IocCk7KXA9cC5wcm90b3R5cGUudHAkYmFzZTtmb3IoO2IoaCk7KWg9aC5wcm90b3R5cGUudHAkYmFzZTtpZihwIT09aCYmKHAucHJvdG90eXBlLnRwJGJhc2UhPT1oLnByb3RvdHlwZS50cCRiYXNlfHwhZihwLGgpKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2NsYXNzX18gYXNzaWdubWVudDogJ1wiK2cucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdCBsYXlvdXQgZGlmZmVycyBmcm9tICdcIitrLnByb3RvdHlwZS50cCRuYW1lK1wiJ1wiKTt9T2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsZy5wcm90b3R5cGUpfSwkZG9jOlwidGhlIG9iamVjdCdzIGNsYXNzXCJ9fSxtZXRob2RzOntfX2Rpcl9fOnskbWV0aDpmdW5jdGlvbigpe2xldCBnPVtdO2lmKHRoaXMuJGQpaWYodGhpcy4kZCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdClnPXRoaXMuJGQuc2skYXNhcnJheSgpO2Vsc2UgZm9yKHZhciBrIGluIHRoaXMuJGQpZy5wdXNoKG5ldyBTay5idWlsdGluLnN0cihrKSk7XG5rPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLnR5cGUucHJvdG90eXBlLl9fZGlyX18sW3RoaXMub2IkdHlwZV0pO2cucHVzaCguLi5rLnYpO2sudj1nO3JldHVybiBrfSwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIkRlZmF1bHQgZGlyKCkgaW1wbGVtZW50YXRpb24uXCJ9LF9fZm9ybWF0X186eyRtZXRoKGcpe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGcpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fZm9ybWF0X18oKSBhcmd1bWVudCBtdXN0IGJlIHN0ciwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGcpKTtpZihnIT09U2suYnVpbHRpbi5zdHIuJGVtcHR5KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgZm9ybWF0IHN0cmluZyBwYXNzZWQgdG8gJHtTay5hYnN0ci50eXBlTmFtZSh0aGlzKX0uX19mb3JtYXRfX2ApO3JldHVybiB0aGlzLnRwJHN0cigpfSwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkRlZmF1bHQgb2JqZWN0IGZvcm1hdHRlci5cIn19LFxuY2xhc3NtZXRob2RzOntfX2luaXRfc3ViY2xhc3NfXzp7JG1ldGgoZyl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntGYXN0Q2FsbDohMCxOb0t3YXJnczohMH19fSxwcm90bzp7dmFsdWVPZjpPYmplY3QucHJvdG90eXBlLnZhbHVlT2YsdG9TdHJpbmcoKXtyZXR1cm4gdGhpcy50cCRzdHIoKS52fSxoYXNPd25Qcm9wZXJ0eTpPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LGh0JHR5cGU6dm9pZCAwLHNrJGF0dHJFcnJvcigpe3JldHVyblwiJ1wiK3RoaXMudHAkbmFtZStcIicgb2JqZWN0XCJ9fX0pO1NrLmFic3RyLnNldFVwSW5oZXJpdGFuY2UoXCJ0eXBlXCIsU2suYnVpbHRpbi50eXBlLFNrLmJ1aWx0aW4ub2JqZWN0KTtTay5hYnN0ci5zZXRVcEJ1aWx0aW5Ncm8oU2suYnVpbHRpbi50eXBlKX0sZnVuY3Rpb24oRSxRKXtmdW5jdGlvbiBiKHEsdCx3KXtTay5hYnN0ci5jaGVja05vQXJncyh0aGlzLiRuYW1lLHQsdyk7cT10aGlzLmNhbGwocSk7cmV0dXJuIHZvaWQgMD09PVxucT9Tay5idWlsdGluLm5vbmUubm9uZSQ6cX1mdW5jdGlvbiBmKHEsdCx3KXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLHQsdyk7cT10aGlzLmNhbGwocSx0WzBdKTtyZXR1cm4gdm9pZCAwPT09cT9Tay5idWlsdGluLm5vbmUubm9uZSQ6cX1mdW5jdGlvbiBlKHEsdCx3KXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsdyk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMuJG5hbWUsdCwxLDIpO3E9dGhpcy5jYWxsKHEsLi4udCk7cmV0dXJuIHZvaWQgMD09PXE/U2suYnVpbHRpbi5ub25lLm5vbmUkOnF9ZnVuY3Rpb24gZyhxLHQsdyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyh0aGlzLiRuYW1lLHcpO1NrLmFic3RyLmNoZWNrQXJnc0xlbih0aGlzLiRuYW1lLHQsMiwyKTt0aGlzLmNhbGwocSx0WzBdLHRbMV0pO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9ZnVuY3Rpb24gayhxLHQsdyl7cT1mLmNhbGwodGhpcyxxLHQsdyk7cmV0dXJuIHE9PT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJD9cbnE6bmV3IFNrLmJ1aWx0aW4uYm9vbChxKX1mdW5jdGlvbiBwKHEsdCl7cmV0dXJuIGZ1bmN0aW9uKHcsQyxEKXt3PXEuY2FsbCh0aGlzLHcsQyxEKTtyZXR1cm4gdCh3KX19ZnVuY3Rpb24gaChxKXtyZXR1cm4gZnVuY3Rpb24oKXtjb25zdCB0PXEudHAkZGVzY3JfZ2V0P3EudHAkZGVzY3JfZ2V0KHRoaXMpOnE7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LFtdKX19ZnVuY3Rpb24gYShxLHQsdyxDKXtyZXR1cm4gZnVuY3Rpb24oRCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIEw9RC50cCRkZXNjcl9nZXQ/RC50cCRkZXNjcl9nZXQodGhpcyk6RDtMPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShMLFtdKTtpZighdChMKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IocStcIiBzaG91bGQgcmV0dXJuIFwiK3crXCIgKHJldHVybmVkIFwiK1NrLmFic3RyLnR5cGVOYW1lKEwpK1wiKVwiKTtyZXR1cm4gdm9pZCAwIT09Qz9DKEwpOkx9fX1mdW5jdGlvbiBjKHEpe3JldHVybiBmdW5jdGlvbih0KXtjb25zdCB3PVxucS50cCRkZXNjcl9nZXQ/cS50cCRkZXNjcl9nZXQodGhpcyk6cTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHcsW3RdKX19ZnVuY3Rpb24gbShxLHQpe2xldCB3PXRoaXMub2IkdHlwZS4kdHlwZUxvb2t1cChTay5idWlsdGluLnN0ci4kZ2V0YXR0cmlidXRlKTtpZih3IGluc3RhbmNlb2YgU2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3IpcmV0dXJuIHcuZCR3cmFwcGVkLmNhbGwodGhpcyxxLHQpO3cudHAkZGVzY3JfZ2V0JiYodz13LnRwJGRlc2NyX2dldCh0aGlzKSk7Y29uc3QgQz1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHcsW3FdKSxEPT57aWYoIShEIGluc3RhbmNlb2YgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcikpdGhyb3cgRDt9KTtyZXR1cm4gdD9DOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhDKX1mdW5jdGlvbiBuKHEsdCx3KXtyZXR1cm4gZnVuY3Rpb24oQyl7cmV0dXJuIGZ1bmN0aW9uKEQsXG5MLE4pe2xldCBBO3ZvaWQgMD09PUw/KEE9dCx3PW51bGwpOkE9cTtsZXQgSD10aGlzLm9iJHR5cGUuJHR5cGVMb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKEEpKTtpZihIIGluc3RhbmNlb2YgU2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3IpcmV0dXJuIEguZCR3cmFwcGVkLmNhbGwodGhpcyxELEwpO0gudHAkZGVzY3JfZ2V0JiYoSD1ILnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSxOKSk7aWYodm9pZCAwIT09SClEPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShILHZvaWQgMD09PUw/W0RdOltELExdKTtlbHNle2lmKHcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiJyBvYmplY3QgXCIrdyk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoQSk7fXJldHVybiBOP0Q6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KEQpfX19ZnVuY3Rpb24gZChxLHQpe2xldCB3PVxucS5vYiR0eXBlO2Zvcig7dyYmdm9pZCAwIT09dy5zayRrbGFzczspdz13LnByb3RvdHlwZS50cCRiYXNlO2lmKHcmJncucHJvdG90eXBlLnRwJHNldGF0dHIhPT10KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IGFwcGx5IHRoaXMgXCIrdC4kbmFtZStcIiB0byBcIitTay5hYnN0ci50eXBlTmFtZShxKStcIiBvYmplY3RcIik7fVNrLnNsb3RzPU9iamVjdC5jcmVhdGUobnVsbCk7RT1Tay5zbG90cztTay5zbG90cy5fX2luaXRfXz17JG5hbWU6XCJfX2luaXRfX1wiLCRzbG90X25hbWU6XCJ0cCRpbml0XCIsJHNsb3RfZnVuYzpmdW5jdGlvbihxKXtyZXR1cm4gZnVuY3Rpb24odCx3KXtjb25zdCBDPXEudHAkZGVzY3JfZ2V0P3EudHAkZGVzY3JfZ2V0KHRoaXMpOnE7dD1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoQyx0LHcpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0LEQ9PntpZighU2suYnVpbHRpbi5jaGVja05vbmUoRCkmJnZvaWQgMCE9PUQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19pbml0X18oKSBzaG91bGQgcmV0dXJuIE5vbmUsIG5vdCBcIitcblNrLmFic3RyLnR5cGVOYW1lKEQpKTt9KX19LCR3cmFwcGVyOmZ1bmN0aW9uKHEsdCx3KXt0aGlzLmNhbGwocSx0LHcpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCAqYXJncywgKiprd2FyZ3MpXCIsJGZsYWdzOntGYXN0Q2FsbDohMH0sJGRvYzpcIkluaXRpYWxpemUgc2VsZi4gIFNlZSBoZWxwKHR5cGUoc2VsZikpIGZvciBhY2N1cmF0ZSBzaWduYXR1cmUuXCJ9O0UuX19uZXdfXz17JG5hbWU6XCJfX25ld19fXCIsJHNsb3RfbmFtZTpcInRwJG5ld1wiLCRzbG90X2Z1bmM6ZnVuY3Rpb24ocSl7Y29uc3QgdD1mdW5jdGlvbih3LEMpe2xldCBEPXE7cS50cCRkZXNjcl9nZXQmJihEPXEudHAkZGVzY3JfZ2V0KG51bGwsdGhpcy5jb25zdHJ1Y3RvcikpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoRCxbdGhpcy5jb25zdHJ1Y3RvciwuLi53XSxDKX07dC5zayRzdGF0aWNfbmV3PSExO3JldHVybiB0fSwkd3JhcHBlcjpudWxsLFxuJHRleHRzaWc6XCIoJHNlbGYsIC8sICphcmdzLCAqKmt3YXJncylcIiwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkZG9jOlwiQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgb2JqZWN0LlwifTtFLl9fY2FsbF9fPXskbmFtZTpcIl9fY2FsbF9fXCIsJHNsb3RfbmFtZTpcInRwJGNhbGxcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKHEpe3JldHVybiBmdW5jdGlvbih0LHcpe2NvbnN0IEM9cS50cCRkZXNjcl9nZXQ/cS50cCRkZXNjcl9nZXQodGhpcyk6cTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KEMsdCx3KX19LCR3cmFwcGVyOmZ1bmN0aW9uKHEsdCx3KXtxPXEudHAkY2FsbCh0LHcpO3JldHVybiB2b2lkIDA9PT1xP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpxfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgKmFyZ3MsICoqa3dhcmdzKVwiLCRmbGFnczp7RmFzdENhbGw6ITB9LCRkb2M6XCJDYWxsIHNlbGYgYXMgYSBmdW5jdGlvbi5cIn07RS5fX3JlcHJfXz17JG5hbWU6XCJfX3JlcHJfX1wiLCRzbG90X25hbWU6XCIkclwiLFxuJHNsb3RfZnVuYzphKFwiX19yZXByX19cIixTay5idWlsdGluLmNoZWNrU3RyaW5nLFwic3RyXCIpLCR3cmFwcGVyOmIsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJSZXR1cm4gcmVwcihzZWxmKS5cIn07RS5fX3N0cl9fPXskbmFtZTpcIl9fc3RyX19cIiwkc2xvdF9uYW1lOlwidHAkc3RyXCIsJHNsb3RfZnVuYzphKFwiX19zdHJfX1wiLFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcsXCJzdHJcIiksJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIlJldHVybiBzdHIoc2VsZikuXCJ9O3ZhciBsPWEoXCJfX2hhc2hfX1wiLFNrLmJ1aWx0aW4uY2hlY2tJbnQsXCJpbnRcIixxPT5cIm51bWJlclwiPT09dHlwZW9mIHEudj9xLnY6cS50cCRoYXNoKCkpO0UuX19oYXNoX189eyRuYW1lOlwiX19oYXNoX19cIiwkc2xvdF9uYW1lOlwidHAkaGFzaFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24ocSl7cmV0dXJuIHE9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/XG5Tay5idWlsdGluLm5vbmUubm9uZSQ6bChxKX0sJHdyYXBwZXI6cChiLHE9Pm5ldyBTay5idWlsdGluLmludF8ocSkpLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiUmV0dXJuIGhhc2goc2VsZikuXCJ9O0UuX19nZXRhdHRyaWJ1dGVfXz17JG5hbWU6XCJfX2dldGF0dHJpYnV0ZV9fXCIsJHNsb3RfbmFtZTpcInRwJGdldGF0dHJcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKHEpe3JldHVybiBmdW5jdGlvbih0LHcpe2xldCBDPXRoaXMub2IkdHlwZS4kdHlwZUxvb2t1cChTay5idWlsdGluLnN0ci4kZ2V0YXR0cik7aWYodm9pZCAwPT09QylyZXR1cm4gbS5jYWxsKHRoaXMsdCx3KTtjb25zdCBEPVNrLm1pc2NldmFsLmNoYWluKG0uY2FsbCh0aGlzLHQsdyksTD0+U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PntpZih2b2lkIDAhPT1MKXJldHVybiBMO0MudHAkZGVzY3JfZ2V0JiYoQz1DLnRwJGRlc2NyX2dldCh0aGlzKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShDLFxuW3RdKX0sZnVuY3Rpb24oTil7aWYoIShOIGluc3RhbmNlb2YgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcikpdGhyb3cgTjt9KSk7cmV0dXJuIHc/RDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coRCl9fSwkd3JhcHBlcjpmdW5jdGlvbihxLHQsdyl7U2suYWJzdHIuY2hlY2tPbmVBcmcodGhpcy4kbmFtZSx0LHcpO3Q9dFswXTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyh0KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhdHRyaWJ1dGUgbmFtZSBtdXN0IGJlIHN0cmluZywgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZSh0KStcIidcIik7dz10aGlzLmNhbGwocSx0KTtpZih2b2lkIDA9PT13KXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFNrLmFic3RyLnR5cGVOYW1lKHEpK1wiIGhhcyBubyBhdHRyaWJ1dGUgXCIrdC4kanNzdHIoKSk7cmV0dXJuIHd9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuYW1lLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSxcbiRkb2M6XCJSZXR1cm4gZ2V0YXR0cihzZWxmLCBuYW1lKS5cIn07RS5fX2dldGF0dHJfXz17JG5hbWU6XCJfX2dldGF0dHJfX1wiLCRzbG90X25hbWU6XCJ0cCRnZXRhdHRyXCIsJHNsb3RfZnVuYzpFLl9fZ2V0YXR0cmlidXRlX18uJHNsb3RfZnVuYywkd3JhcHBlcjpudWxsLCR0ZXh0c2lnOlwiKCRzZWxmLCBuYW1lLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIGdldGF0dHIoc2VsZiwgbmFtZSkuXCJ9O0UuX19zZXRhdHRyX189eyRuYW1lOlwiX19zZXRhdHRyX19cIiwkc2xvdF9uYW1lOlwidHAkc2V0YXR0clwiLCRzbG90X2Z1bmM6bihcIl9fc2V0YXR0cl9fXCIsXCJfX2RlbGF0dHJfX1wiKSwkd3JhcHBlcjpmdW5jdGlvbihxLHQsdyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyh0aGlzLiRuYW1lLHcpO1NrLmFic3RyLmNoZWNrQXJnc0xlbih0aGlzLiRuYW1lLHQsMiwyKTtkKHEsdGhpcyk7dGhpcy5jYWxsKHEsdFswXSx0WzFdKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkdGV4dHNpZzpcIigkc2VsZiwgbmFtZSwgdmFsdWUsIC8pXCIsXG4kZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCRkb2M6XCJJbXBsZW1lbnQgc2V0YXR0cihzZWxmLCBuYW1lLCB2YWx1ZSkuXCJ9O0UuX19kZWxhdHRyX189eyRuYW1lOlwiX19kZWxhdHRyX19cIiwkc2xvdF9uYW1lOlwidHAkc2V0YXR0clwiLCRzbG90X2Z1bmM6RS5fX3NldGF0dHJfXy4kc2xvdF9mdW5jLCR3cmFwcGVyOmZ1bmN0aW9uKHEsdCx3KXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLHQsdyk7ZChxLHRoaXMpO3RoaXMuY2FsbChxLHRbMF0pO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuYW1lLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IGRlbGF0dHIoc2VsZiwgbmFtZSkuXCJ9O0UuX19nZXRfXz17JG5hbWU6XCJfX2dldF9fXCIsJHNsb3RfbmFtZTpcInRwJGRlc2NyX2dldFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24ocSl7cmV0dXJuIGZ1bmN0aW9uKHQsdyxDKXtudWxsPT09dCYmKHQ9U2suYnVpbHRpbi5ub25lLm5vbmUkKTtcbm51bGw9PXcmJih3PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7Y29uc3QgRD1xLnRwJGRlc2NyX2dldD9xLnRwJGRlc2NyX2dldCh0aGlzKTpxO3Q9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KEQsW3Qsd10pO3JldHVybiBDP3Q6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHQpfX0sJHdyYXBwZXI6ZnVuY3Rpb24ocSx0LHcpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy4kbmFtZSx3KTtTay5hYnN0ci5jaGVja0FyZ3NMZW4odGhpcy4kbmFtZSx0LDEsMik7dz10WzBdO3Q9dFsxXTt3PT09U2suYnVpbHRpbi5ub25lLm5vbmUkJiYodz1udWxsKTt0PT09U2suYnVpbHRpbi5ub25lLm5vbmUkJiYodD1udWxsKTtpZihudWxsPT09dCYmbnVsbD09PXcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19nZXRfXyhOb25lLCBOb25lKSBpcyBpbnZhbGlkXCIpO3JldHVybiB0aGlzLmNhbGwocSx3LHQpfSwkdGV4dHNpZzpcIigkc2VsZiwgaW5zdGFuY2UsIG93bmVyLCAvKVwiLFxuJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkZG9jOlwiUmV0dXJuIGFuIGF0dHJpYnV0ZSBvZiBpbnN0YW5jZSwgd2hpY2ggaXMgb2YgdHlwZSBvd25lci5cIn07RS5fX3NldF9fPXskbmFtZTpcIl9fc2V0X19cIiwkc2xvdF9uYW1lOlwidHAkZGVzY3Jfc2V0XCIsJHNsb3RfZnVuYzpuKFwiX19zZXRfX1wiLFwiX19kZWxldGVfX1wiKSwkd3JhcHBlcjpnLCR0ZXh0c2lnOlwiKCRzZWxmLCBpbnN0YW5jZSwgdmFsdWUsIC8pXCIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkZG9jOlwiU2V0IGFuIGF0dHJpYnV0ZSBvZiBpbnN0YW5jZSB0byB2YWx1ZS5cIn07RS5fX2RlbGV0ZV9fPXskbmFtZTpcIl9fZGVsZXRlX19cIiwkc2xvdF9uYW1lOlwidHAkZGVzY3Jfc2V0XCIsJHNsb3RfZnVuYzpFLl9fc2V0X18uJHNsb3RfZnVuYywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCBpbnN0YW5jZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkRlbGV0ZSBhbiBhdHRyaWJ1dGUgb2YgaW5zdGFuY2UuXCJ9O1xuRS5fX2VxX189eyRuYW1lOlwiX19lcV9fXCIsJHNsb3RfbmFtZTpcIm9iJGVxXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmssJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY9PXZhbHVlLlwifTtFLl9fZ2VfXz17JG5hbWU6XCJfX2dlX19cIiwkc2xvdF9uYW1lOlwib2IkZ2VcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6aywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZj49dmFsdWUuXCJ9O0UuX19ndF9fPXskbmFtZTpcIl9fZ3RfX1wiLCRzbG90X25hbWU6XCJvYiRndFwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjprLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmPnZhbHVlLlwifTtFLl9fbGVfXz17JG5hbWU6XCJfX2xlX19cIiwkc2xvdF9uYW1lOlwib2IkbGVcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6aywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsXG4kZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmPD12YWx1ZS5cIn07RS5fX2x0X189eyRuYW1lOlwiX19sdF9fXCIsJHNsb3RfbmFtZTpcIm9iJGx0XCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmssJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY8dmFsdWUuXCJ9O0UuX19uZV9fPXskbmFtZTpcIl9fbmVfX1wiLCRzbG90X25hbWU6XCJvYiRuZVwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjprLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmIT12YWx1ZS5cIn07RS5fX2l0ZXJfXz17JG5hbWU6XCJfX2l0ZXJfX1wiLCRzbG90X25hbWU6XCJ0cCRpdGVyXCIsJHNsb3RfZnVuYzpoLCR3cmFwcGVyOmIsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJJbXBsZW1lbnQgaXRlcihzZWxmKS5cIn07RS5fX25leHRfXz17JG5hbWU6XCJfX25leHRfX1wiLFxuJHNsb3RfbmFtZTpcInRwJGl0ZXJuZXh0XCIsJHNsb3RfZnVuYzpmdW5jdGlvbihxKXtyZXR1cm4gZnVuY3Rpb24odCl7Y29uc3Qgdz1xLnRwJGRlc2NyX2dldD9xLnRwJGRlc2NyX2dldCh0aGlzKTpxLEM9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh3LFtdKSxEPT57aWYoRCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbil0aGlzLmdpJHJldD1ELiR2YWx1ZTtlbHNlIHRocm93IEQ7fSk7cmV0dXJuIHQ/QzpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coQyl9fSwkd3JhcHBlcjpmdW5jdGlvbihxLHQsdyl7U2suYWJzdHIuY2hlY2tOb0FyZ3ModGhpcy4kbmFtZSx0LHcpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihxLnRwJGl0ZXJuZXh0KCEwKSxDPT57aWYodm9pZCAwPT09Qyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uO3JldHVybiBDfSl9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLFxuJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJJbXBsZW1lbnQgbmV4dChzZWxmKS5cIn07RS5fX2xlbl9fPXskbmFtZTpcIl9fbGVuX19cIiwkc2xvdF9uYW1lOlwic3EkbGVuZ3RoXCIsJHNsb3RfZnVuYzpmdW5jdGlvbihxKXtyZXR1cm4gZnVuY3Rpb24odCl7Y29uc3Qgdz1xLnRwJGRlc2NyX2dldD9xLnRwJGRlc2NyX2dldCh0aGlzKTpxO2lmKHQpcmV0dXJuIHQ9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHcsW10pLFNrLm1pc2NldmFsLmNoYWluKHQsQz0+U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coQykpO3Q9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHcsW10pO3JldHVybiBTay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyh0KX19LCR3cmFwcGVyOnAoYixxPT5uZXcgU2suYnVpbHRpbi5pbnRfKHEpKSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBsZW4oc2VsZikuXCJ9O0UuX19jb250YWluc19fPXskbmFtZTpcIl9fY29udGFpbnNfX1wiLFxuJHNsb3RfbmFtZTpcInNxJGNvbnRhaW5zXCIsJHNsb3RfZnVuYzpmdW5jdGlvbihxKXtyZXR1cm4gZnVuY3Rpb24odCx3KXtjb25zdCBDPXEudHAkZGVzY3JfZ2V0P3EudHAkZGVzY3JfZ2V0KHRoaXMpOnE7dD1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoQyxbdF0pO3Q9U2subWlzY2V2YWwuY2hhaW4odCxEPT5Tay5taXNjZXZhbC5pc1RydWUoRCkpO3JldHVybiB0LiRpc1N1c3BlbnNpb24/dz90OlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyh0KTp0fX0sJHdyYXBwZXI6cChmLHE9Pm5ldyBTay5idWlsdGluLmJvb2wocSkpLCR0ZXh0c2lnOlwiKCRzZWxmLCBrZXksIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4ga2V5IGluIHNlbGYuXCJ9O0UuX19nZXRpdGVtX189eyRuYW1lOlwiX19nZXRpdGVtX19cIiwkc2xvdF9uYW1lOlwibXAkc3Vic2NyaXB0XCIsJHNsb3RfZnVuYzpmdW5jdGlvbihxKXtyZXR1cm4gZnVuY3Rpb24odCx3KXtjb25zdCBDPVxucS50cCRkZXNjcl9nZXQ/cS50cCRkZXNjcl9nZXQodGhpcyk6cTt0PVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShDLFt0XSk7cmV0dXJuIHc/dDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3codCl9fSwkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCBrZXksIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZltrZXldLlwifTtFLl9fc2V0aXRlbV9fPXskbmFtZTpcIl9fc2V0aXRlbV9fXCIsJHNsb3RfbmFtZTpcIm1wJGFzc19zdWJzY3JpcHRcIiwkc2xvdF9mdW5jOm4oXCJfX3NldGl0ZW1fX1wiLFwiX19kZWxpdGVtX19cIixcImRvZXMgbm90IHN1cHBvcnQgaXRlbSBhc3NpZ25tZW50XCIpLCR3cmFwcGVyOmcsJHRleHRzaWc6XCIoJHNlbGYsIGtleSwgdmFsdWUsIC8pXCIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkZG9jOlwiU2V0IHNlbGZba2V5XSB0byB2YWx1ZS5cIn07RS5fX2RlbGl0ZW1fXz17JG5hbWU6XCJfX2RlbGl0ZW1fX1wiLFxuJHNsb3RfbmFtZTpcIm1wJGFzc19zdWJzY3JpcHRcIiwkc2xvdF9mdW5jOkUuX19zZXRpdGVtX18uJHNsb3RfZnVuYywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCBrZXksIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJEZWxldGUgc2VsZltrZXldLlwifTtFLl9fYWRkX189eyRuYW1lOlwiX19hZGRfX1wiLCRzbG90X25hbWU6XCJuYiRhZGRcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZit2YWx1ZS5cIn07RS5fX3JhZGRfXz17JG5hbWU6XCJfX3JhZGRfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfYWRkXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlK3NlbGYuXCJ9O0UuX19pYWRkX189eyRuYW1lOlwiX19pYWRkX19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9hZGRcIixcbiRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmKz12YWx1ZS5cIn07RS5fX3N1Yl9fPXskbmFtZTpcIl9fc3ViX19cIiwkc2xvdF9uYW1lOlwibmIkc3VidHJhY3RcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZi12YWx1ZS5cIn07RS5fX3JzdWJfXz17JG5hbWU6XCJfX3JzdWJfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUtc2VsZi5cIn07RS5fX2ltdWxfXz17JG5hbWU6XCJfX2ltdWxfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX211bHRpcGx5XCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsXG4kdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZio9dmFsdWUuXCJ9O0UuX19tdWxfXz17JG5hbWU6XCJfX211bF9fXCIsJHNsb3RfbmFtZTpcIm5iJG11bHRpcGx5XCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGYqdmFsdWUuXCJ9O0UuX19ybXVsX189eyRuYW1lOlwiX19ybXVsX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX211bHRpcGx5XCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlKnNlbGYuXCJ9O0UuX19pc3ViX189eyRuYW1lOlwiX19pc3ViX19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9zdWJ0cmFjdFwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIixcbiRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGYtPXZhbHVlLlwifTtFLl9fbW9kX189eyRuYW1lOlwiX19tb2RfX1wiLCRzbG90X25hbWU6XCJuYiRyZW1haW5kZXJcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZiV2YWx1ZS5cIn07RS5fX3Jtb2RfXz17JG5hbWU6XCJfX3Jtb2RfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfcmVtYWluZGVyXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlJXNlbGYuXCJ9O0UuX19pbW9kX189eyRuYW1lOlwiX19pbW9kX19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9yZW1haW5kZXJcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LFxuJGRvYzpcIkltcGxlbWVudCB2YWx1ZSU9c2VsZi5cIn07RS5fX2Rpdm1vZF9fPXskbmFtZTpcIl9fZGl2bW9kX19cIiwkc2xvdF9uYW1lOlwibmIkZGl2bW9kXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIGRpdm1vZChzZWxmLCB2YWx1ZSkuXCJ9O0UuX19yZGl2bW9kX189eyRuYW1lOlwiX19yZGl2bW9kX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX2Rpdm1vZFwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBkaXZtb2QodmFsdWUsIHNlbGYpXCJ9O0UuX19wb3NfXz17JG5hbWU6XCJfX3Bvc19fXCIsJHNsb3RfbmFtZTpcIm5iJHBvc2l0aXZlXCIsJHNsb3RfZnVuYzpoLCR3cmFwcGVyOmIsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCIrc2VsZlwifTtcbkUuX19uZWdfXz17JG5hbWU6XCJfX25lZ19fXCIsJHNsb3RfbmFtZTpcIm5iJG5lZ2F0aXZlXCIsJHNsb3RfZnVuYzpoLCR3cmFwcGVyOmIsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCItc2VsZlwifTtFLl9fYWJzX189eyRuYW1lOlwiX19hYnNfX1wiLCRzbG90X25hbWU6XCJuYiRhYnNcIiwkc2xvdF9mdW5jOmgsJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcImFicyhzZWxmKVwifTtFLl9fYm9vbF9fPXskbmFtZTpcIl9fYm9vbF9fXCIsJHNsb3RfbmFtZTpcIm5iJGJvb2xcIiwkc2xvdF9mdW5jOmEoXCJfX2Jvb2xfX1wiLFNrLmJ1aWx0aW4uY2hlY2tCb29sLFwiYm9vbFwiLHE9PjAhPT1xLnYpLCR3cmFwcGVyOnAoYixxPT5uZXcgU2suYnVpbHRpbi5ib29sKHEpKSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcInNlbGYgIT0gMFwifTtFLl9faW52ZXJ0X189eyRuYW1lOlwiX19pbnZlcnRfX1wiLFxuJHNsb3RfbmFtZTpcIm5iJGludmVydFwiLCRzbG90X2Z1bmM6aCwkd3JhcHBlcjpiLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwifnNlbGZcIn07RS5fX2xzaGlmdF9fPXskbmFtZTpcIl9fbHNoaWZ0X19cIiwkc2xvdF9uYW1lOlwibmIkbHNoaWZ0XCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY8PHZhbHVlLlwifTtFLl9fcmxzaGlmdF9fPXskbmFtZTpcIl9fcmxzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9sc2hpZnRcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWU8PHNlbGYuXCJ9O0UuX19yc2hpZnRfXz17JG5hbWU6XCJfX3JzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJzaGlmdFwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLFxuJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY+PnZhbHVlLlwifTtFLl9fcnJzaGlmdF9fPXskbmFtZTpcIl9fcnJzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9yc2hpZnRcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWU+PnNlbGYuXCJ9O0UuX19pbHNoaWZ0X189eyRuYW1lOlwiX19pbHNoaWZ0X19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9sc2hpZnRcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZjw8PXZhbHVlLlwifTtFLl9faXJzaGlmdF9fPXskbmFtZTpcIl9faXJzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2VfcnNoaWZ0XCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsXG4kdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZj0+PnZhbHVlLlwifTtFLl9fYW5kX189eyRuYW1lOlwiX19hbmRfX1wiLCRzbG90X25hbWU6XCJuYiRhbmRcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZiZ2YWx1ZS5cIn07RS5fX3JhbmRfXz17JG5hbWU6XCJfX3JhbmRfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZlbGN0ZWRfYW5kXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlJnNlbGYuXCJ9O0UuX19pYW5kX189eyRuYW1lOlwiX19pYW5kX19cIiwkc2xvdF9uYW1lOlwibmIkYW5kXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSxcbiRkb2M6XCJJbXBsZW1lbnQgc2VsZiY9dmFsdWUuXCJ9O0UuX194b3JfXz17JG5hbWU6XCJfX3hvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJHhvclwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmXnZhbHVlLlwifTtFLl9fcnhvcl9fPXskbmFtZTpcIl9fcnhvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF94b3JcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWVec2VsZi5cIn07RS5fX2l4b3JfXz17JG5hbWU6XCJfX2l4b3JfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX3hvclwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmXj12YWx1ZS5cIn07RS5fX29yX189XG57JG5hbWU6XCJfX29yX19cIiwkc2xvdF9uYW1lOlwibmIkb3JcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZnx2YWx1ZS5cIn07RS5fX3Jvcl9fPXskbmFtZTpcIl9fcm9yX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX29yXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlfHNlbGYuXCJ9O0UuX19pb3JfXz17JG5hbWU6XCJfX2lvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2Vfb3JcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZnw9dmFsdWUuXCJ9O0UuX19pbnRfXz17JG5hbWU6XCJfX2ludF9fXCIsJHNsb3RfbmFtZTpcIm5iJGludFwiLCRzbG90X2Z1bmM6YShcIl9faW50X19cIixcblNrLmJ1aWx0aW4uY2hlY2tJbnQsXCJpbnRcIiksJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcImludChzZWxmKVwifTtFLl9fZmxvYXRfXz17JG5hbWU6XCJfX2Zsb2F0X19cIiwkc2xvdF9uYW1lOlwibmIkZmxvYXRcIiwkc2xvdF9mdW5jOmEoXCJfX2Zsb2F0X19cIixTay5idWlsdGluLmNoZWNrRmxvYXQsXCJmbG9hdFwiKSwkd3JhcHBlcjpiLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiZmxvYXQoc2VsZilcIn07RS5fX2Zsb29yZGl2X189eyRuYW1lOlwiX19mbG9vcmRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJGZsb29yX2RpdmlkZVwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmLy92YWx1ZS5cIn07RS5fX3JmbG9vcmRpdl9fPXskbmFtZTpcIl9fcmZsb29yZGl2X19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZVwiLFxuJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlLy9zZWxmLlwifTtFLl9faWZsb29yZGl2X189eyRuYW1lOlwiX19pZmxvb3JkaXZfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX2Zsb29yX2RpdmlkZVwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmLy89dmFsdWUuXCJ9O0UuX190cnVlZGl2X189eyRuYW1lOlwiX190cnVlZGl2X19cIiwkc2xvdF9uYW1lOlwibmIkZGl2aWRlXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGYvdmFsdWUuXCJ9O0UuX19ydHJ1ZWRpdl9fPXskbmFtZTpcIl9fcnRydWVkaXZfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfZGl2aWRlXCIsXG4kc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUvc2VsZi5cIn07RS5fX2l0cnVlZGl2X189eyRuYW1lOlwiX19pdHJ1ZWRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2VfZGl2aWRlXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGYvPXZhbHVlLlwifTtFLl9faW5kZXhfXz17JG5hbWU6XCJfX2luZGV4X19cIiwkc2xvdF9uYW1lOlwibmIkaW5kZXhcIiwkc2xvdF9mdW5jOmEoXCJfX2luZGV4X19cIixTay5idWlsdGluLmNoZWNrSW50LFwiaW50XCIscT0+cS52KSwkd3JhcHBlcjpwKGIscT0+bmV3IFNrLmJ1aWx0aW4uaW50XyhxKSksJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZiBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciwgaWYgc2VsZiBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIGFuIGluZGV4IGludG8gYSBsaXN0LlwifTtcbkUuX19wb3dfXz17JG5hbWU6XCJfX3Bvd19fXCIsJHNsb3RfbmFtZTpcIm5iJHBvd2VyXCIsJHNsb3RfZnVuYzpmdW5jdGlvbihxKXtyZXR1cm4gZnVuY3Rpb24odCx3KXtjb25zdCBDPXEudHAkZGVzY3JfZ2V0P3EudHAkZGVzY3JfZ2V0KHRoaXMpOnE7cmV0dXJuIHZvaWQgMD09dz9Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoQyxbdF0pOlNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShDLFt0LHddKX19LCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCBtb2Q9Tm9uZSwgLylcIiwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCRkb2M6XCJSZXR1cm4gcG93KHNlbGYsIHZhbHVlLCBtb2QpLlwifTtFLl9fcnBvd19fPXskbmFtZTpcIl9fcnBvd19fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9wb3dlclwiLCRzbG90X2Z1bmM6RS5fX3Bvd19fLiRzbG90X2Z1bmMsJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIG1vZD1Ob25lLCAvKVwiLCRmbGFnczp7TWluQXJnczoxLFxuTWF4QXJnczoyfSwkZG9jOlwiUmV0dXJuIHBvdyh2YWx1ZSwgc2VsZiwgbW9kKS5cIn07RS5fX2lwb3dfXz17JG5hbWU6XCJfX2lwb3dfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX3Bvd2VyXCIsJHNsb3RfZnVuYzpFLl9fcG93X18uJHNsb3RfZnVuYywkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgbW9kPU5vbmUsIC8pXCIsJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkZG9jOlwiSW1wbGVtZW50ICoqPVwifTtFLl9fbWF0bXVsX189eyRuYW1lOlwiX19tYXRtdWxfX1wiLCRzbG90X25hbWU6XCJuYiRtYXRyaXhfbXVsdGlwbHlcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZkB2YWx1ZS5cIn07RS5fX3JtYXRtdWxfXz17JG5hbWU6XCJfX3JtYXRtdWxfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfbWF0cml4X211bHRpcGx5XCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsXG4kdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWVAc2VsZi5cIn07RS5fX2ltYXRtdWxfXz17JG5hbWU6XCJfX2ltYXRtdWxfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX21hdHJpeF9tdWx0aXBseVwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmQD12YWx1ZS5cIn07RS5fX2xvbmdfXz17JG5hbWU6XCJfX2xvbmdfX1wiLCRzbG90X25hbWU6XCJuYiRsb25nXCIsJHNsb3RfZnVuYzphKFwiX19sb25nX19cIixTay5idWlsdGluLmNoZWNrSW50LFwiaW50XCIpLCR3cmFwcGVyOmIsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJpbnQoc2VsZilcIn07dmFyIHIsdj17bmV4dDp7JG5hbWU6XCJuZXh0XCIsJHNsb3RfbmFtZTpcInRwJGl0ZXJuZXh0XCIsJHNsb3RfZnVuYzpFLl9fbmV4dF9fLiRzbG90X2Z1bmMsXG4kd3JhcHBlcjpFLl9fbmV4dF9fLiR3cmFwcGVyLCR0ZXh0c2lnOkUuX19uZXh0X18uJHRleHRzaWcsJGZsYWdzOkUuX19uZXh0X18uJGZsYWdzfSxfX25vbnplcm9fXzp7JG5hbWU6XCJfX25vbnplcm9fX1wiLCRzbG90X25hbWU6XCJuYiRib29sXCIsJHNsb3RfZnVuYzphKFwiX19ub256ZXJvX19cIixTay5idWlsdGluLmNoZWNrSW50LFwiaW50XCIscT0+MCE9PXEudiksJHdyYXBwZXI6cChiLHE9Pm5ldyBTay5idWlsdGluLmJvb2wocSkpLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwieC5fX25vbnplcm9fXygpIDw9PT4geCAhPSAwXCJ9LF9fZGl2X186eyRuYW1lOlwiX19kaXZfX1wiLCRzbG90X25hbWU6XCJuYiRkaXZpZGVcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgb3RoZXIvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwieC5fX2Rpdl9fKHkpIDw9PT4geC95XCJ9LF9fcmRpdl9fOnskbmFtZTpcIl9fcmRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9kaXZpZGVcIixcbiRzbG90X2Z1bmM6Yywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCBvdGhlci8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJ4Ll9fcmRpdl9fKHkpIDw9PT4geC95XCJ9LF9faWRpdl9fOnskbmFtZTpcIl9faWRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2VfZGl2aWRlXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIG90aGVyLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcImltcGxlbWVudCBzZWxmIC89IG90aGVyXCJ9fTtTay5zdWJTbG90cz17bWFpbl9zbG90czpPYmplY3QuZW50cmllcyh7dHAkaW5pdDpcIl9faW5pdF9fXCIsdHAkY2FsbDpcIl9fY2FsbF9fXCIsJHI6XCJfX3JlcHJfX1wiLHRwJHN0cjpcIl9fc3RyX19cIix0cCRnZXRhdHRyOlwiX19nZXRhdHRyaWJ1dGVfX1wiLHRwJHNldGF0dHI6W1wiX19zZXRhdHRyX19cIixcIl9fZGVsYXR0cl9fXCJdLG9iJGVxOlwiX19lcV9fXCIsb2IkbmU6XCJfX25lX19cIixvYiRsdDpcIl9fbHRfX1wiLG9iJGxlOlwiX19sZV9fXCIsXG5vYiRndDpcIl9fZ3RfX1wiLG9iJGdlOlwiX19nZV9fXCIsdHAkZGVzY3JfZ2V0OlwiX19nZXRfX1wiLHRwJGRlc2NyX3NldDpbXCJfX3NldF9fXCIsXCJfX2RlbGV0ZV9fXCJdLHRwJGl0ZXI6XCJfX2l0ZXJfX1wiLHRwJGl0ZXJuZXh0OlwiX19uZXh0X19cIn0pLG51bWJlcl9zbG90czpPYmplY3QuZW50cmllcyh7bmIkYWJzOlwiX19hYnNfX1wiLG5iJG5lZ2F0aXZlOlwiX19uZWdfX1wiLG5iJHBvc2l0aXZlOlwiX19wb3NfX1wiLG5iJGludDpcIl9faW50X19cIixuYiRsb25nOlwiX19sb25nX19cIixuYiRmbG9hdDpcIl9fZmxvYXRfX1wiLG5iJGFkZDpcIl9fYWRkX19cIixuYiRyZWZsZWN0ZWRfYWRkOlwiX19yYWRkX19cIixuYiRpbnBsYWNlX2FkZDpcIl9faWFkZF9fXCIsbmIkc3VidHJhY3Q6XCJfX3N1Yl9fXCIsbmIkcmVmbGVjdGVkX3N1YnRyYWN0OlwiX19yc3ViX19cIixuYiRpbnBsYWNlX3N1YnRyYWN0OlwiX19pc3ViX19cIixuYiRtdWx0aXBseTpcIl9fbXVsX19cIixuYiRyZWZsZWN0ZWRfbXVsdGlwbHk6XCJfX3JtdWxfX1wiLG5iJGlucGxhY2VfbXVsdGlwbHk6XCJfX2ltdWxfX1wiLFxubmIkZmxvb3JfZGl2aWRlOlwiX19mbG9vcmRpdl9fXCIsbmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZTpcIl9fcmZsb29yZGl2X19cIixuYiRpbnBsYWNlX2Zsb29yX2RpdmlkZTpcIl9faWZsb29yZGl2X19cIixuYiRpbnZlcnQ6XCJfX2ludmVydF9fXCIsbmIkcmVtYWluZGVyOlwiX19tb2RfX1wiLG5iJHJlZmxlY3RlZF9yZW1haW5kZXI6XCJfX3Jtb2RfX1wiLG5iJGlucGxhY2VfcmVtYWluZGVyOlwiX19pbW9kX19cIixuYiRkaXZtb2Q6XCJfX2Rpdm1vZF9fXCIsbmIkcmVmbGVjdGVkX2Rpdm1vZDpcIl9fcmRpdm1vZF9fXCIsbmIkcG93ZXI6XCJfX3Bvd19fXCIsbmIkcmVmbGVjdGVkX3Bvd2VyOlwiX19ycG93X19cIixuYiRpbnBsYWNlX3Bvd2VyOlwiX19pcG93X19cIixuYiRkaXZpZGU6XCJfX3RydWVkaXZfX1wiLG5iJHJlZmxlY3RlZF9kaXZpZGU6XCJfX3J0cnVlZGl2X19cIixuYiRpbnBsYWNlX2RpdmlkZTpcIl9faXRydWVkaXZfX1wiLG5iJGJvb2w6XCJfX2Jvb2xfX1wiLG5iJGFuZDpcIl9fYW5kX19cIixuYiRyZWZsZWN0ZWRfYW5kOlwiX19yYW5kX19cIixcbm5iJGlucGxhY2VfYW5kOlwiX19pYW5kX19cIixuYiRvcjpcIl9fb3JfX1wiLG5iJHJlZmxlY3RlZF9vcjpcIl9fcm9yX19cIixuYiRpbnBsYWNlX29yOlwiX19pb3JfX1wiLG5iJHhvcjpcIl9feG9yX19cIixuYiRyZWZsZWN0ZWRfeG9yOlwiX19yeG9yX19cIixuYiRpbnBsYWNlX3hvcjpcIl9faXhvcl9fXCIsbmIkbHNoaWZ0OlwiX19sc2hpZnRfX1wiLG5iJHJlZmxlY3RlZF9sc2hpZnQ6XCJfX3Jsc2hpZnRfX1wiLG5iJHJzaGlmdDpcIl9fcnNoaWZ0X19cIixuYiRyZWZsZWN0ZWRfcnNoaWZ0OlwiX19ycnNoaWZ0X19cIixuYiRpbnBsYWNlX2xzaGlmdDpcIl9faWxzaGlmdF9fXCIsbmIkaW5wbGFjZV9yc2hpZnQ6XCJfX2lyc2hpZnRfX1wiLG5iJG1hdHJpeF9tdWx0aXBseTpcIl9fbWF0bXVsX19cIixuYiRyZWZsZWN0ZWRfbWF0cml4X211bHRpcGx5OlwiX19ybWF0bXVsX19cIixuYiRpbnBsYWNlX21hdHJpeF9tdWx0aXBseTpcIl9faW1hdG11bF9fXCJ9KSxzZXF1ZW5jZV9hbmRfbWFwcGluZ19zbG90czpPYmplY3QuZW50cmllcyh7c3EkbGVuZ3RoOlwiX19sZW5fX1wiLFxuc3EkY29udGFpbnM6XCJfX2NvbnRhaW5zX19cIixtcCRzdWJzY3JpcHQ6XCJfX2dldGl0ZW1fX1wiLG1wJGFzc19zdWJzY3JpcHQ6W1wiX19zZXRpdGVtX19cIixcIl9fZGVsaXRlbV9fXCJdLG5iJGFkZDpcIl9fYWRkX19cIixuYiRtdWx0aXBseTpcIl9fbXVsX19cIixuYiRyZWZsZWN0ZWRfbXVsdGlwbHk6XCJfX3JtdWxfX1wiLG5iJGlucGxhY2VfYWRkOlwiX19pYWRkX19cIixuYiRpbnBsYWNlX211bHRpcGx5OlwiX19pbXVsX19cIn0pfTtTay5yZWZsZWN0ZWROdW1iZXJTbG90cz17bmIkYWRkOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfYWRkXCJ9LG5iJHN1YnRyYWN0OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIixzbG90OmZ1bmN0aW9uKHEpe3JldHVybiBxIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9xLm5iJHN1YnRyYWN0KHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkbXVsdGlwbHk6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9tdWx0aXBseVwifSxcbm5iJGRpdmlkZTp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX2RpdmlkZVwiLHNsb3Q6ZnVuY3Rpb24ocSl7cmV0dXJuIHEgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP3EubmIkZGl2aWRlKHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkZmxvb3JfZGl2aWRlOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlXCIsc2xvdDpmdW5jdGlvbihxKXtyZXR1cm4gcSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/cS5uYiRmbG9vcl9kaXZpZGUodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRyZW1haW5kZXI6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9yZW1haW5kZXJcIixzbG90OmZ1bmN0aW9uKHEpe3JldHVybiBxIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9xLm5iJHJlbWFpbmRlcih0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19LFxubmIkZGl2bW9kOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfZGl2bW9kXCIsc2xvdDpmdW5jdGlvbihxKXtyZXR1cm4gcSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/cS5uYiRkaXZtb2QodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRwb3dlcjp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX3Bvd2VyXCIsc2xvdDpmdW5jdGlvbihxLHQpe3JldHVybiBxIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9xLm5iJHBvd2VyKHRoaXMsdCk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRhbmQ6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9hbmRcIn0sbmIkb3I6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9vclwifSxuYiR4b3I6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF94b3JcIn0sbmIkbHNoaWZ0OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfbHNoaWZ0XCIsc2xvdDpmdW5jdGlvbihxKXtyZXR1cm4gcSBpbnN0YW5jZW9mXG50aGlzLmNvbnN0cnVjdG9yP3EubmIkbHNoaWZ0KHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkcnNoaWZ0OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfcnNoaWZ0XCIsc2xvdDpmdW5jdGlvbihxKXtyZXR1cm4gcSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/cS5uYiRyc2hpZnQodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRtYXRyaXhfbXVsdGlwbHk6e3JlZmxlY3RlZDpcIm5iJHJlZmxleHRlZF9tYXRyaXhfbXVsdGlwbHlcIixzbG90OmZ1bmN0aW9uKHEpe3JldHVybiBxIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9xLm5iJG1hdHJpeF9tdWx0aXBseSh0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19fTtTay5zZXF1ZW5jZUFuZE1hcHBpbmdTbG90cz17c3EkY29uY2F0OltcIm5iJGFkZFwiXSxzcSRyZXBlYXQ6W1wibmIkbXVsdGlwbHlcIixcIm5iJHJlZmxlY3RlZF9tdWx0aXBseVwiXSxcbm1wJGxlbmd0aDpbXCJzcSRsZW5ndGhcIl0sc3EkaW5wbGFjZV9yZXBlYXQ6W1wibmIkaW5wbGFjZV9tdWx0aXBseVwiXSxzcSRpbnBsYWNlX2NvbmNhdDpbXCJuYiRpbnBsYWNlX2FkZFwiXX07U2suZHVuZGVyVG9Ta3VscHQ9e19fcmVwcl9fOlwiJHJcIixfX3N0cl9fOlwidHAkc3RyXCIsX19pbml0X186XCJ0cCRpbml0XCIsX19uZXdfXzpcInRwJG5ld1wiLF9faGFzaF9fOlwidHAkaGFzaFwiLF9fY2FsbF9fOlwidHAkY2FsbFwiLF9faXRlcl9fOlwidHAkaXRlclwiLF9fbmV4dF9fOlwidHAkaXRlcm5leHRcIixfX2VxX186XCJvYiRlcVwiLF9fbmVfXzpcIm9iJG5lXCIsX19sdF9fOlwib2IkbHRcIixfX2xlX186XCJvYiRsZVwiLF9fZ3RfXzpcIm9iJGd0XCIsX19nZV9fOlwib2IkZ2VcIixfX2Fic19fOlwibmIkYWJzXCIsX19uZWdfXzpcIm5iJG5lZ2F0aXZlXCIsX19wb3NfXzpcIm5iJHBvc2l0aXZlXCIsX19pbnRfXzpcIm5iJGludFwiLF9fZmxvYXRfXzpcIm5iJGZsb2F0XCIsX19hZGRfXzpcIm5iJGFkZFwiLF9fcmFkZF9fOlwibmIkcmVmbGVjdGVkX2FkZFwiLFxuX19pYWRkX186XCJuYiRpbnBsYWNlX2FkZFwiLF9fc3ViX186XCJuYiRzdWJ0cmFjdFwiLF9fcnN1Yl9fOlwibmIkcmVmbGVjdGVkX3N1YnRyYWN0XCIsX19pc3ViX186XCJuYiRpbnBsYWNlX3N1YnRyYWN0XCIsX19tdWxfXzpcIm5iJG11bHRpcGx5XCIsX19ybXVsX186XCJuYiRyZWZsZWN0ZWRfbXVsdGlwbHlcIixfX2ltdWxfXzpcIm5iJGlucGxhY2VfbXVsdGlwbHlcIixfX3RydWVkaXZfXzpcIm5iJGRpdmlkZVwiLF9fcnRydWVkaXZfXzpcIm5iJHJlZmxlY3RlZF9kaXZpZGVcIixfX2l0cnVlZGl2X186XCJuYiRpbnBsYWNlX2RpdmlkZVwiLF9fZmxvb3JkaXZfXzpcIm5iJGZsb29yX2RpdmlkZVwiLF9fcmZsb29yZGl2X186XCJuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlXCIsX19pZmxvb3JkaXZfXzpcIm5iJGlucGxhY2VfZmxvb3JfZGl2aWRlXCIsX19pbnZlcnRfXzpcIm5iJGludmVydFwiLF9fbW9kX186XCJuYiRyZW1haW5kZXJcIixfX3Jtb2RfXzpcIm5iJHJlZmxlY3RlZF9yZW1haW5kZXJcIixfX2ltb2RfXzpcIm5iJGlucGxhY2VfcmVtYWluZGVyXCIsXG5fX2Rpdm1vZF9fOlwibmIkZGl2bW9kXCIsX19yZGl2bW9kX186XCJuYiRyZWZsZWN0ZWRfZGl2bW9kXCIsX19wb3dfXzpcIm5iJHBvd2VyXCIsX19ycG93X186XCJuYiRyZWZsZWN0ZWRfcG93ZXJcIixfX2lwb3dfXzpcIm5iJGlucGxhY2VfcG93ZXJcIixfX2Jvb2xfXzpcIm5iJGJvb2xcIixfX2xvbmdfXzpcIm5iJGxvbmdcIixfX2xzaGlmdF9fOlwibmIkbHNoaWZ0XCIsX19ybHNoaWZ0X186XCJuYiRyZWZsZWN0ZWRfbHNoaWZ0XCIsX19pbHNoaWZ0X186XCJuYiRpbnBsYWNlX2xzaGlmdFwiLF9fcnNoaWZ0X186XCJuYiRyc2hpZnRcIixfX3Jyc2hpZnRfXzpcIm5iJHJlZmxlY3RlZF9yc2hpZnRcIixfX2lyc2hpZnRfXzpcIm5iJGlucGxhY2VfcnNoaWZ0XCIsX19hbmRfXzpcIm5iJGFuZFwiLF9fcmFuZF9fOlwibmIkcmVmbGVjdGVkX2FuZFwiLF9faWFuZF9fOlwibmIkaW5wbGFjZV9hbmRcIixfX29yX186XCJuYiRvclwiLF9fcm9yX186XCJuYiRyZWZsZWN0ZWRfb3JcIixfX2lvcl9fOlwibmIkaW5wbGFjZV9vclwiLF9feG9yX186XCJuYiR4b3JcIixcbl9fcnhvcl9fOlwibmIkcmVmbGVjdGVkX3hvclwiLF9faXhvcl9fOlwibmIkaW5wbGFjZV94b3JcIixfX21hdG11bF9fOlwibmIkbWF0cml4X211bHRpcGx5XCIsX19ybWF0bXVsX186XCJuYiRyZWZsZWN0ZWRfbWF0cml4X211bHRpcGx5XCIsX19pbWF0bXVsX186XCJuYiRpbnBsYWNlX21hdHJpeF9tdWx0aXBseVwiLF9fZ2V0X186XCJ0cCRkZXNjcl9nZXRcIixfX3NldF9fOlwidHAkZGVzY3Jfc2V0XCIsX19kZWxldGVfXzpcInRwJGRlc2NyX3NldFwiLF9fZ2V0YXR0cmlidXRlX186XCJ0cCRnZXRhdHRyXCIsX19nZXRhdHRyX186XCJ0cCRnZXRhdHRyXCIsX19zZXRhdHRyX186XCJ0cCRzZXRhdHRyXCIsX19kZWxhdHRyX186XCJ0cCRzZXRhdHRyXCIsX19sZW5fXzpcInNxJGxlbmd0aFwiLF9fY29udGFpbnNfXzpcInNxJGNvbnRhaW5zXCIsX19nZXRpdGVtX186XCJtcCRzdWJzY3JpcHRcIixfX3NldGl0ZW1fXzpcIm1wJGFzc19zdWJzY3JpcHRcIixfX2RlbGl0ZW1fXzpcIm1wJGFzc19zdWJzY3JpcHRcIn07U2suZXhwb3J0U3ltYm9sKFwiU2suc2V0dXBEdW5kZXJNZXRob2RzXCIsXG5Tay5zZXR1cER1bmRlck1ldGhvZHMpO1NrLnNldHVwRHVuZGVyTWV0aG9kcz1mdW5jdGlvbihxKXtmdW5jdGlvbiB0KEIsRixKKXtmb3IobGV0IFA9MDtQPEIubGVuZ3RoO1ArKyl7Y29uc3QgVz1CW1BdLnByb3RvdHlwZTtXLmhhc093blByb3BlcnR5KEopfHwoV1tKXT1XW0ZdLGRlbGV0ZSBXW0ZdKX19dmFyIHc9U2suc2xvdHM7aWYoIXF8fHZvaWQgMCE9PXIpe3ZhciBDPVNrLmFic3RyLmJ1aWx0JGl0ZXJhdG9ycyxEPVtTay5idWlsdGluLmludF8sU2suYnVpbHRpbi5sbmcsU2suYnVpbHRpbi5mbG9hdF8sU2suYnVpbHRpbi5jb21wbGV4XSxMPVNrLnN1YlNsb3RzLm51bWJlcl9zbG90cyxOPVNrLnN1YlNsb3RzLm1haW5fc2xvdHMsQT1OLmZpbmRJbmRleChCPT5cInRwJGl0ZXJuZXh0XCI9PT1CWzBdKSxIPUwuZmluZEluZGV4KEI9PlwibmIkYm9vbFwiPT09QlswXSkseD1Tay5kdW5kZXJUb1NrdWxwdDtpZihxKXt4Ll9fYm9vbF9fPVwibmIkYm9vbFwiO3guX19uZXh0X189XCJ0cCRpdGVybmV4dFwiO1xuZGVsZXRlIHguX19ub256ZXJvX187ZGVsZXRlIHguX19kaXZfXztkZWxldGUgeC5fX3JkaXZfXztkZWxldGUgeC5fX2lkaXZfXztkZWxldGUgeC5uZXh0O2ZvcihsZXQgQiBpbiByKXdbQl09cltCXTtmb3IobGV0IEIgaW4gdilkZWxldGUgd1tCXTtmb3IocT0wO3E8RC5sZW5ndGg7cSsrKXc9RFtxXS5wcm90b3R5cGUsZGVsZXRlIHcuX19kaXZfXyxkZWxldGUgdy5fX3JkaXZfXztOW0FdWzFdPVwiX19uZXh0X19cIjtMW0hdWzFdPVwiX19ib29sX19cIjt0KEMsXCJuZXh0XCIsXCJfX25leHRfX1wiKTt0KEQsXCJfX2Jvb2xfX1wiLFwiX19ub256ZXJvX19cIil9ZWxzZXt2b2lkIDA9PT1yJiYody5weTMkc2xvdHM9e19fbmV4dF9fOncuX19uZXh0X199LHI9dy5weTMkc2xvdHMpO3gubmV4dD1cInRwJGl0ZXJuZXh0XCI7eC5fX25vbnplcm9fXz1cIm5iJGJvb2xcIjt4Ll9fZGl2X189XCJuYiRkaXZpZGVcIjt4Ll9fcmRpdl9fPVwibmIkcmVmbGVjdGVkX2RpdmlkZVwiO3guX19pZGl2X189XCJuYiRpbnBsYWNlX2RpdmlkZVwiO1xuZGVsZXRlIHguX19ib29sX187ZGVsZXRlIHguX19uZXh0X187Zm9yKGxldCBCIGluIHYpd1tCXT12W0JdO2ZvcihsZXQgQiBpbiByKWRlbGV0ZSB3W0JdO05bQV1bMV09XCJuZXh0XCI7TFtIXVsxXT1cIl9fbm9uemVyb19fXCI7dChDLFwiX19uZXh0X19cIixcIm5leHRcIik7dChELFwiX19ub256ZXJvX19cIixcIl9fYm9vbF9fXCIpO2ZvcihDPTA7QzxELmxlbmd0aDtDKyspTD1EW0NdLE49TC5wcm90b3R5cGUsTi5oYXNPd25Qcm9wZXJ0eShcIl9fZGl2X19cIil8fChOLl9fZGl2X189bmV3IFNrLmJ1aWx0aW4ud3JhcHBlcl9kZXNjcmlwdG9yKEwsdi5fX2Rpdl9fLE4ubmIkZGl2aWRlKSxOLl9fcmRpdl9fPW5ldyBTay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcihMLHYuX19yZGl2X18sU2sucmVmbGVjdGVkTnVtYmVyU2xvdHMubmIkZGl2aWRlLnNsb3QpKX19fX0sZnVuY3Rpb24oRSxRKXtmdW5jdGlvbiBiKHAsaCxhKXtyZXR1cm4gU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhwLHtjb25zdHJ1Y3RvcjphLmNvbnN0cnVjdG9yLFxuc2xvdHM6T2JqZWN0LmFzc2lnbih7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsJHI6Z30sYS5zbG90cyksZ2V0c2V0czpPYmplY3QuYXNzaWduKGEuZ2V0c2V0c3x8e30saykscHJvdG86T2JqZWN0LmFzc2lnbihhLnByb3RvfHx7fSx7ZCRyZXByX25hbWU6aHx8cCxkJGNoZWNrOmYsZCRzZXRfY2hlY2s6ZX0pLGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pfWZ1bmN0aW9uIGYocCl7aWYobnVsbD09cClyZXR1cm4gdGhpcztpZighcC5vYiR0eXBlLiRpc1N1YlR5cGUodGhpcy5kJHR5cGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyByZXF1aXJlcyBhICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IGJ1dCByZWNlaXZlZCBhICdcIitTay5hYnN0ci50eXBlTmFtZShwKStcIicgb2JqZWN0XCIpO31mdW5jdGlvbiBlKHApe2lmKCFwLm9iJHR5cGUuJGlzU3ViVHlwZSh0aGlzLmQkdHlwZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrXG50aGlzLmQkbmFtZStcIicgcmVxdWlyZXMgYSAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdCBidXQgcmVjZWl2ZWQgYSAnXCIrU2suYWJzdHIudHlwZU5hbWUocCkrXCInIG9iamVjdFwiKTt9ZnVuY3Rpb24gZygpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8XCIrdGhpcy5kJHJlcHJfbmFtZStcIiAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0cz5cIil9Y29uc3Qgaz17X19kb2NfXzp7JGdldCgpe3JldHVybiB0aGlzLmQkZGVmLiRkb2M/bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuZCRkZWYuJGRvYyk6U2suYnVpbHRpbi5ub25lLm5vbmUkfX0sX19vYmpjbGFzc19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuZCR0eXBlfX0sX19uYW1lX186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuZCRuYW1lKX19fTtFPXtfX3RleHRfc2lnbmF0dXJlX186eyRnZXQoKXtyZXR1cm4gdGhpcy5kJGRlZi4kdGV4dHNpZz9cbm5ldyBTay5idWlsdGluLnN0cih0aGlzLmQkZGVmLiR0ZXh0c2lnKTpTay5idWlsdGluLm5vbmUubm9uZSR9fX07U2suYnVpbHRpbi5nZXRzZXRfZGVzY3JpcHRvcj1iKFwiZ2V0c2V0X2Rlc2NyaXB0b3JcIix2b2lkIDAse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHAsaCl7dGhpcy5kJGRlZj1oO3RoaXMuJGdldD1oLiRnZXQ7dGhpcy4kc2V0PWguJHNldDt0aGlzLmQkdHlwZT1wO3RoaXMuZCRuYW1lPWguJG5hbWV9LHNsb3RzOnt0cCRkZXNjcl9nZXQocCxoLGEpe2lmKGg9dGhpcy5kJGNoZWNrKHApKXJldHVybiBoO2lmKHZvaWQgMCE9PXRoaXMuJGdldClyZXR1cm4gcD10aGlzLiRnZXQuY2FsbChwKSxhP3A6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHApO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiZ2V0c2V0X2Rlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdHMgaXMgbm90IHJlYWRhYmxlXCIpO1xufSx0cCRkZXNjcl9zZXQocCxoLGEpe3RoaXMuZCRzZXRfY2hlY2socCk7aWYodm9pZCAwIT09dGhpcy4kc2V0KXJldHVybiBwPXRoaXMuJHNldC5jYWxsKHAsaCksYT9wOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhwKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcImF0dHJpYnV0ZSAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0cyBpcyByZWFkb25seVwiKTt9fX0pO1NrLmJ1aWx0aW4ubWV0aG9kX2Rlc2NyaXB0b3I9YihcIm1ldGhvZF9kZXNjcmlwdG9yXCIsXCJtZXRob2RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocCxoKXt0aGlzLmQkZGVmPWg7dGhpcy4kbWV0aD1oLiRtZXRoO3RoaXMuZCR0eXBlPXA7dGhpcy5kJG5hbWU9aC4kbmFtZXx8XCI8bmF0aXZlIEpTPlwiO3RoaXMuJGZsYWdzPXA9aC4kZmxhZ3N8fHt9O3AuRmFzdENhbGwmJnAuTm9Ld2FyZ3M/dGhpcy50cCRjYWxsPVxudGhpcy4kbWV0aG9kRmFzdENhbGxOb0t3YXJnczpwLkZhc3RDYWxsP3RoaXMudHAkY2FsbD10aGlzLiRtZXRob2RGYXN0Q2FsbDpwLk5vQXJncz90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kQ2FsbE5vQXJnczpwLk9uZUFyZz90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kQ2FsbE9uZUFyZzpwLk5hbWVkQXJncz90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kQ2FsbE5hbWVkQXJnczp2b2lkIDAhPT1wLk1pbkFyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJG1ldGhvZENhbGxNaW5BcmdzOih0aGlzLmZ1bmNfY29kZT1oLiRtZXRoLHRoaXMudHAkY2FsbD10aGlzLiRkZWZhdWx0Q2FsbCx0aGlzLiRtZW1vaXNlRmxhZ3M9U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS4kbWVtb2lzZUZsYWdzLHRoaXMuJHJlc29sdmVBcmdzPVNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUuJHJlc29sdmVBcmdzKX0sc2xvdHM6e3RwJGNhbGwocCxoKXtyZXR1cm4gdGhpcy50cCRjYWxsKHAsaCl9LHRwJGRlc2NyX2dldChwLFxuaCl7bGV0IGE7cmV0dXJuKGE9dGhpcy5kJGNoZWNrKHApKT9hOm5ldyBTay5idWlsdGluLnNrX21ldGhvZCh0aGlzLmQkZGVmLHApfX0sZ2V0c2V0czpFLHByb3RvOnskbWV0aG9kRmFzdENhbGwocCxoKXtjb25zdCBhPXAuc2hpZnQoKTt0aGlzLm0kY2hlY2tzZWxmKGEpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYSxwLGgpfSwkbWV0aG9kRmFzdENhbGxOb0t3YXJncyhwLGgpe2NvbnN0IGE9cC5zaGlmdCgpO3RoaXMubSRjaGVja3NlbGYoYSk7U2suYWJzdHIuY2hlY2tOb0t3YXJncyh0aGlzLmQkbmFtZSxoKTtyZXR1cm4gdGhpcy4kbWV0aC5jYWxsKGEscCl9LCRtZXRob2RDYWxsTm9BcmdzKHAsaCl7Y29uc3QgYT1wLnNoaWZ0KCk7dGhpcy5tJGNoZWNrc2VsZihhKTtTay5hYnN0ci5jaGVja05vQXJncyh0aGlzLmQkbmFtZSxwLGgpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYSl9LCRtZXRob2RDYWxsT25lQXJnKHAsaCl7Y29uc3QgYT1wLnNoaWZ0KCk7dGhpcy5tJGNoZWNrc2VsZihhKTtcblNrLmFic3RyLmNoZWNrT25lQXJnKHRoaXMuZCRuYW1lLHAsaCk7cmV0dXJuIHRoaXMuJG1ldGguY2FsbChhLHBbMF0pfSwkbWV0aG9kQ2FsbE5hbWVkQXJncyhwLGgpe2NvbnN0IGE9cC5zaGlmdCgpO3RoaXMubSRjaGVja3NlbGYoYSk7cD1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyh0aGlzLmQkbmFtZSx0aGlzLiRmbGFncy5OYW1lZEFyZ3MscCxoLHRoaXMuJGZsYWdzLkRlZmF1bHRzKTtyZXR1cm4gdGhpcy4kbWV0aC5jYWxsKGEsLi4ucCl9LCRtZXRob2RDYWxsTWluQXJncyhwLGgpe2NvbnN0IGE9cC5zaGlmdCgpO3RoaXMubSRjaGVja3NlbGYoYSk7U2suYWJzdHIuY2hlY2tOb0t3YXJncyh0aGlzLmQkbmFtZSxoKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4odGhpcy5kJG5hbWUscCx0aGlzLiRmbGFncy5NaW5BcmdzLHRoaXMuJGZsYWdzLk1heEFyZ3MpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYSwuLi5wKX0sJGRlZmF1bHRDYWxsKHAsaCl7dGhpcy5tJGNoZWNrc2VsZihwWzBdKTtcbnJldHVybiBTay5idWlsdGluLmZ1bmMucHJvdG90eXBlLnRwJGNhbGwuY2FsbCh0aGlzLHAsaCl9LG0kY2hlY2tzZWxmKHApe2lmKHZvaWQgMD09PXApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IG5lZWRzIGFuIGFyZ3VtZW50XCIpO3RoaXMuZCRjaGVjayhwKX19fSk7U2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3I9YihcIndyYXBwZXJfZGVzY3JpcHRvclwiLFwic2xvdCB3cmFwcGVyXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHAsaCxhKXt0aGlzLmQkZGVmPWg7dGhpcy5kJHR5cGU9cDt0aGlzLmQkbmFtZT1hLiRuYW1lPWguJG5hbWU7dGhpcy5kJHdyYXBwZWQ9YX0sc2xvdHM6e3RwJGRlc2NyX2dldChwLGgpe2xldCBhO3JldHVybihhPXRoaXMuZCRjaGVjayhwKSk/YTpuZXcgU2suYnVpbHRpbi5tZXRob2Rfd3JhcHBlcih0aGlzLHApfSxcbnRwJGNhbGwocCxoKXtpZigxPnAubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdCBuZWVkcyBhbiBhcmd1bWVudFwiKTtjb25zdCBhPXAuc2hpZnQoKTtpZighYS5vYiR0eXBlLiRpc1N1YlR5cGUodGhpcy5kJHR5cGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyByZXF1aXJlcyBhICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IGJ1dCByZWNlaXZlZCBhICdcIitTay5hYnN0ci50eXBlTmFtZShhKStcIidcIik7cmV0dXJuIHRoaXMucmF3JGNhbGwoYSxwLGgpfX0scHJvdG86e3JhdyRjYWxsKHAsaCxhKXt0aGlzLmQkd3JhcHBlZC4kbmFtZT10aGlzLmQkbmFtZTtyZXR1cm4gdGhpcy5kJGRlZi4kd3JhcHBlci5jYWxsKHRoaXMuZCR3cmFwcGVkLFxucCxoLGEpfX19KTtTay5idWlsdGluLm1ldGhvZF93cmFwcGVyPWIoXCJtZXRob2Rfd3JhcHBlclwiLHZvaWQgMCx7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocCxoKXt0aGlzLm0kZGVzY3I9cDt0aGlzLm0kc2VsZj1oO3RoaXMuZCRkZWY9cC5kJGRlZjt0aGlzLmQkbmFtZT1wLmQkbmFtZTt0aGlzLmQkdHlwZT1wLmQkdHlwZX0sc2xvdHM6e3RwJGNhbGwocCxoKXtyZXR1cm4gdGhpcy5tJGRlc2NyLnJhdyRjYWxsKHRoaXMubSRzZWxmLHAsaCl9LHRwJHJpY2hjb21wYXJlKHAsaCl7aWYoXCJFcVwiIT09aCYmXCJOb3RFcVwiIT09aHx8IShwIGluc3RhbmNlb2YgU2suYnVpbHRpbi5tZXRob2Rfd3JhcHBlcikpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO3A9dGhpcy5tJHNlbGY9PT1wLm0kc2VsZiYmdGhpcy5tJGRlc2NyPT09cC5tJGRlc2NyO3JldHVyblwiRXFcIj09PWg/cDohcH0sJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPG1ldGhvZC13cmFwcGVyICdcIitcbnRoaXMuZCRuYW1lK1wiJyBvZiBcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzLm0kc2VsZikrXCIgb2JqZWN0PlwiKX19LGdldHNldHM6e19fc2VsZl9fOnskZ2V0KCl7cmV0dXJuIHRoaXMubSRzZWxmfX19fSk7U2suYnVpbHRpbi5jbGFzc21ldGhvZF9kZXNjcmlwdG9yPWIoXCJjbGFzc21ldGhvZF9kZXNjcmlwdG9yXCIsXCJtZXRob2RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocCxoKXt0aGlzLmQkZGVmPWg7dGhpcy4kbWV0aD1oLiRtZXRoO3RoaXMuZCR0eXBlPXA7dGhpcy5kJG5hbWU9aC4kbmFtZXx8XCI8bmF0aXZlIEpTPlwifSxzbG90czp7dHAkY2FsbChwLGgpe2lmKDE+cC5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IG5lZWRzIGFuIGFyZ3VtZW50XCIpO2NvbnN0IGE9cC5zaGlmdCgpO3JldHVybiB0aGlzLnRwJGRlc2NyX2dldChudWxsLFxuYSkudHAkY2FsbChwLGgpfSx0cCRkZXNjcl9nZXQocCxoLGEpe2lmKHZvaWQgMD09PWgpaWYobnVsbCE9PXApaD1ofHxwLm9iJHR5cGU7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZXNjcmlwdG9yICdcIit0aGlzLmQkbmFtZStcIicgZm9yIHR5cGUgJ1wiK3RoaXMuZCR0eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJyBuZWVkcyBhbiBvYmplY3Qgb3IgYSB0eXBlXCIpO2lmKCFoLm9iJHR5cGUuJGlzU3ViVHlwZShTay5idWlsdGluLnR5cGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBmb3IgdHlwZSAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG5lZWRzIGEgdHlwZSBub3QgYSAnXCIrU2suYWJzdHIudHlwZU5hbWUoaCkrXCInIGFzIGFyZyAyXCIpO2lmKCFoLiRpc1N1YlR5cGUodGhpcy5kJHR5cGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1xuXCInIHJlcXVpcmVzIGEgJ1wiK3RoaXMuZCR0eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJyBvYmplY3QgYnV0IHJlY2VpdmVkIGEgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGgpK1wiJyBvYmplY3RcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnNrX21ldGhvZCh0aGlzLmQkZGVmLGgpfX0sZ2V0c2V0czpFfSk7W1NrLmJ1aWx0aW4ubWV0aG9kX2Rlc2NyaXB0b3IsU2suYnVpbHRpbi5nZXRzZXRfZGVzY3JpcHRvcixTay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcixTay5idWlsdGluLm1ldGhvZF93cmFwcGVyLFNrLmJ1aWx0aW4uY2xhc3NtZXRob2RfZGVzY3JpcHRvcl0uZm9yRWFjaChwPT57U2suYWJzdHIuc2V0VXBTbG90cyhwKTtTay5hYnN0ci5zZXRVcE1ldGhvZHMocCk7U2suYWJzdHIuc2V0VXBHZXRTZXRzKHApfSl9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi5za19tZXRob2Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImJ1aWx0aW5fZnVuY3Rpb25fb3JfbWV0aG9kXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsXG5mLGUpe3RoaXMuJG1ldGg9Yi4kbWV0aC5iaW5kKGYpO3RoaXMuJGRvYz1iLiRkb2M7dGhpcy4kc2VsZj1mfHxudWxsO3RoaXMuJG1vZHVsZT1lP25ldyBTay5idWlsdGluLnN0cihlKTpudWxsO3RoaXMuJG5hbWU9Yi4kbmFtZXx8Yi4kbWV0aC5uYW1lfHxcIjxuYXRpdmUgSlM+XCI7dGhpcy5tJGRlZj1iO3RoaXMuJHRleHRzaWc9Yi4kdGV4dHNpZzt0aGlzLiRmbGFncz1iPWIuJGZsYWdzfHx7fTtiLkZhc3RDYWxsJiZiLk5vS3dhcmdzP3RoaXMudHAkY2FsbD10aGlzLiRmYXN0Q2FsbE5vS3dhcmdzOmIuRmFzdENhbGw/dGhpcy50cCRjYWxsPXRoaXMuJG1ldGg6Yi5Ob0FyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJGNhbGxOb0FyZ3M6Yi5PbmVBcmc/dGhpcy50cCRjYWxsPXRoaXMuJGNhbGxPbmVBcmc6Yi5OYW1lZEFyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJGNhbGxOYW1lZEFyZ3M6dm9pZCAwIT09Yi5NaW5BcmdzP3RoaXMudHAkY2FsbD10aGlzLiRjYWxsTWluQXJnczoodGhpcy5mdW5jX2NvZGU9XG50aGlzLiRtZXRoLHRoaXMudHAkY2FsbD10aGlzLiRkZWZhdWx0Q2FsbE1ldGhvZCl9LHByb3RvOnskZmFzdENhbGxOb0t3YXJncyhiLGYpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy4kbmFtZSxmKTtyZXR1cm4gdGhpcy4kbWV0aChiKX0sJGNhbGxOb0FyZ3MoYixmKXtTay5hYnN0ci5jaGVja05vQXJncyh0aGlzLiRuYW1lLGIsZik7cmV0dXJuIHRoaXMuJG1ldGgoKX0sJGNhbGxPbmVBcmcoYixmKXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLGIsZik7cmV0dXJuIHRoaXMuJG1ldGgoYlswXSl9LCRjYWxsTmFtZWRBcmdzKGIsZil7Yj1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyh0aGlzLiRuYW1lLHRoaXMuJGZsYWdzLk5hbWVkQXJncyxiLGYsdGhpcy4kZmxhZ3MuRGVmYXVsdHMpO3JldHVybiB0aGlzLiRtZXRoKC4uLmIpfSwkY2FsbE1pbkFyZ3MoYixmKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsZik7U2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMuJG5hbWUsXG5iLHRoaXMuJGZsYWdzLk1pbkFyZ3MsdGhpcy4kZmxhZ3MuTWF4QXJncyk7cmV0dXJuIHRoaXMuJG1ldGgoLi4uYil9LCRkZWZhdWx0Q2FsbE1ldGhvZChiLGYpe3JldHVybiBudWxsIT09dGhpcy4kc2VsZj9Tay5idWlsdGluLmZ1bmMucHJvdG90eXBlLnRwJGNhbGwuY2FsbCh0aGlzLFt0aGlzLiRzZWxmLC4uLmJdLGYpOlNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUudHAkY2FsbC5jYWxsKHRoaXMsYixmKX0sJG1lbW9pc2VGbGFncygpe3JldHVybiBTay5idWlsdGluLmZ1bmMucHJvdG90eXBlLiRtZW1vaXNlRmxhZ3MuY2FsbCh0aGlzKX0sJHJlc29sdmVBcmdzKCl7cmV0dXJuIFNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUuJHJlc29sdmVBcmdzLmNhbGwodGhpcyl9fSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLCRyKCl7cmV0dXJuIG51bGw9PT10aGlzLiRzZWxmP25ldyBTay5idWlsdGluLnN0cihcIjxidWlsdC1pbiBmdW5jdGlvbiBcIitcbnRoaXMuJG5hbWUrXCI+XCIpOm5ldyBTay5idWlsdGluLnN0cihcIjxidWlsdC1pbiBtZXRob2QgXCIrdGhpcy4kbmFtZStcIiBvZiBcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzLiRzZWxmKStcIiBvYmplY3Q+XCIpfSx0cCRjYWxsKGIsZil7cmV0dXJuIHRoaXMudHAkY2FsbChiLGYpfSx0cCRyaWNoY29tcGFyZShiLGYpe2lmKFwiRXFcIiE9PWYmJlwiTm90RXFcIiE9PWZ8fCEoYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2tfbWV0aG9kKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Yj10aGlzLiRzZWxmPT09Yi4kc2VsZiYmdGhpcy5tJGRlZi4kbWV0aD09PWIubSRkZWYuJG1ldGg7cmV0dXJuXCJFcVwiPT09Zj9iOiFifX0sZ2V0c2V0czp7X19tb2R1bGVfXzp7JGdldCgpe3JldHVybiB0aGlzLiRtb2R1bGV8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJHNldChiKXt0aGlzLiRtb2R1bGU9Yj1ifHxTay5idWlsdGluLm5vbmUubm9uZSR9fSxfX2RvY19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuJGRvYz9cbm5ldyBTay5idWlsdGluLnN0cih0aGlzLiRkb2MpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LF9fbmFtZV9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLiRuYW1lKX19LF9fdGV4dF9zaWduYXR1cmVfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kdGV4dHNpZyl9fSxfX3NlbGZfXzp7JGdldCgpe3JldHVybiB0aGlzLiRzZWxmfHxTay5zeXNNb2R1bGVzLm1wJGxvb2t1cCh0aGlzLiRtb2R1bGUpfHxTay5idWlsdGluLm5vbmUubm9uZSR9fX19KX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLm5vbmU9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIk5vbmVUeXBlXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sc2xvdHM6e3RwJG5ldyhiLGYpe1NrLmFic3RyLmNoZWNrTm9BcmdzKFwiTm9uZVR5cGVcIixiLGYpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIk5vbmVcIil9LFxudHAkYXNfbnVtYmVyOiEwLG5iJGJvb2woKXtyZXR1cm4hMX19LHByb3RvOnt2YWx1ZU9mKCl7cmV0dXJuIG51bGx9fSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KTtTay5idWlsdGluLm5vbmUubm9uZSQ9T2JqZWN0LmNyZWF0ZShTay5idWlsdGluLm5vbmUucHJvdG90eXBlLHt2Ont2YWx1ZTpudWxsLGVudW1lcmFibGU6ITB9fSk7U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiTm90SW1wbGVtZW50ZWRUeXBlXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfSxzbG90czp7JHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiTm90SW1wbGVtZW50ZWRcIil9LHRwJG5ldyhiLGYpe1NrLmFic3RyLmNoZWNrTm9BcmdzKFwiTm90SW1wbGVtZW50ZWRUeXBlXCIsYixmKTtyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxcbmZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pO1NrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkPU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5wcm90b3R5cGUse3Y6e3ZhbHVlOm51bGwsZW51bWVyYWJsZTohMH19KTtFPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJlbGxpcHNpc1wiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLkVsbGlwc2lzfSxzbG90czp7dHAkbmV3KGIsZil7U2suYWJzdHIuY2hlY2tOb0FyZ3MoXCJlbGxpcHNpc1wiLGIsZik7cmV0dXJuIFNrLmJ1aWx0aW4uRWxsaXBzaXN9LCRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIkVsbGlwc2lzXCIpfX0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSk7U2suYnVpbHRpbi5FbGxpcHNpcz1PYmplY3QuY3JlYXRlKEUucHJvdG90eXBlLHt2Ont2YWx1ZTpcIi4uLlwifX0pfSxmdW5jdGlvbihFLFEpe2NvbnN0IGI9L14oPzooLik/KFs8Pj1cXF5dKSk/KFtcXCtcXC1cXHNdKT8oIyk/KDApPyhcXGQrKT8oLHxfKT8oPzpcXC4oXFxkKykpPyhbYmNkZUVmRmdHbm9zeFglXSk/JC87XG5Tay5mb3JtYXR0aW5nPXt9O2xldCBmPWZ1bmN0aW9uKGEsYyxtLG4pe1NrLmFzc2VydHMuYXNzZXJ0KFwic3RyaW5nXCI9PT10eXBlb2YgYyk7aWYoYVs2XSl7dmFyIGQ9cGFyc2VJbnQoYVs2XSwxMCk7bj1hWzJdfHwoYVs1XT9cIj1cIjpuP1wiPlwiOlwiPFwiKTtsZXQgbD1kLShjLmxlbmd0aCsobT9tLmxlbmd0aDowKSk7aWYoMD49bClyZXR1cm4gbStjO2Q9KGFbMV18fChhWzVdP1wiMFwiOlwiIFwiKSkucmVwZWF0KGwpO3N3aXRjaChuKXtjYXNlIFwiPVwiOmlmKFwic1wiPT09YVs5XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiJz0nIGFsaWdubWVudCBub3QgYWxsb3dlZCBpbiBzdHJpbmcgZm9ybWF0IHNwZWNpZmllclwiKTtyZXR1cm4gbStkK2M7Y2FzZSBcIj5cIjpyZXR1cm4gZCttK2M7Y2FzZSBcIjxcIjpyZXR1cm4gbStjK2Q7Y2FzZSBcIl5cIjpyZXR1cm4gYT1NYXRoLmZsb29yKGwvMiksZC5zdWJzdHJpbmcoMCxhKSttK2MrZC5zdWJzdHJpbmcoYSl9fXJldHVybiBtK2N9LGU9ZnVuY3Rpb24oYSxcbmMpe3JldHVybiBjP1wiLVwiOlwiK1wiPT09YVszXT9cIitcIjpcIiBcIj09PWFbM10/XCIgXCI6XCJcIn07Y29uc3QgZz0vXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxrPS9cXEIoPz0oW0EtWmEtejAtOV17NH0pKyg/IVtBLVphLXowLTldKSkvZztsZXQgcD1mdW5jdGlvbihhLGMsbSl7U2suYXNzZXJ0cy5hc3NlcnQoYyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8YyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKTtpZihhWzhdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJQcmVjaXNpb24gbm90IGFsbG93ZWQgaW4gaW50ZWdlciBmb3JtYXRcIik7dmFyIG49Yy5zdHIkKG0sITEpO2M9Yy5uYiRpc25lZ2F0aXZlKCk7Yz1lKGEsYyk7YVs0XSYmKDE2PT09bT9jKz1cIjB4XCI6OD09PW0/Yys9XCIwb1wiOjI9PT1tJiYoYys9XCIwYlwiKSk7Y29uc3QgZD1hWzldO1wiWFwiPT09ZCYmKG49bi50b1VwcGVyQ2FzZSgpKTtpZihcIm5cIj09PWFbOV0pbj0oK24pLnRvTG9jYWxlU3RyaW5nKCk7ZWxzZSBpZihhWzddKXtuPVxubi5zcGxpdChcIi5cIik7Y29uc3QgbD1hWzddO2lmKFwiLFwiPT09bCYmMTAhPT1tKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoYENhbm5vdCBzcGVjaWZ5ICcsJyB3aXRoICcke2R9J2ApO25bMF09blswXS5yZXBsYWNlKDEwPT09bT9nOmssbCk7bj1uLmpvaW4oXCIuXCIpfXJldHVybiBmKGEsbixjLCEwKX0saD1mdW5jdGlvbihhLGMsbSl7aWYoIWMpcmV0dXJuIGEuc3RyJCgxMCwhMCk7Yz1jLm1hdGNoKGIpO2lmKCFjKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJJbnZhbGlkIGZvcm1hdCBzcGVjaWZpZXJcIik7dmFyIG49Y1s5XTtufHwobj1tP1wiZ1wiOlwiZFwiKTtpZigtMT09KG0/XCJmRmVFZ0clXCI6XCJiY2RveFhuZkZlRWdHJVwiKS5pbmRleE9mKG4pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJVbmtub3duIGZvcm1hdCBjb2RlICdcIitjWzldK1wiJyBmb3Igb2JqZWN0IG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTtzd2l0Y2gobil7Y2FzZSBcImRcIjpjYXNlIFwiblwiOnJldHVybiBwKGMsXG5hLDEwKTtjYXNlIFwieFwiOmNhc2UgXCJYXCI6cmV0dXJuIHAoYyxhLDE2KTtjYXNlIFwib1wiOnJldHVybiBwKGMsYSw4KTtjYXNlIFwiYlwiOnJldHVybiBwKGMsYSwyKTtjYXNlIFwiY1wiOmlmKGNbM10pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIlNpZ24gbm90IGFsbG93ZWQgd2l0aCBpbnRlZ2VyIGZvcm1hdCBzcGVjaWZpZXIgJ2MnXCIpO2lmKGNbNF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkFsdGVybmF0ZSBmb3JtIG5vdCBhbGxvd2VkIHdpdGggaW50ZWdlciBmb3JtYXQgc3BlY2lmaWVyICdjJ1wiKTtpZihjWzddKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSAnLCcgd2l0aCAnYydcIik7aWYoY1s4XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgJywnIHdpdGggJ2MnXCIpO3JldHVybiBmKGMsU3RyaW5nLmZyb21Db2RlUG9pbnQoU2suYnVpbHRpbi5hc251bSQoYSkpLFwiXCIsITApO1xuY2FzZSBcImZcIjpjYXNlIFwiRlwiOmNhc2UgXCJlXCI6Y2FzZSBcIkVcIjpjYXNlIFwiZ1wiOmNhc2UgXCJHXCI6e2lmKGNbNF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkFsdGVybmF0ZSBmb3JtICgjKSBub3QgYWxsb3dlZCBpbiBmbG9hdCBmb3JtYXQgc3BlY2lmaWVyXCIpO209U2suYnVpbHRpbi5hc251bSQoYSk7XCJzdHJpbmdcIj09PXR5cGVvZiBtJiYobT1OdW1iZXIobSkpO2lmKEluZmluaXR5PT09bSlyZXR1cm4gZihjLFwiaW5mXCIsXCJcIiwhMCk7aWYoLUluZmluaXR5PT09bSlyZXR1cm4gZihjLFwiaW5mXCIsXCItXCIsITApO2lmKGlzTmFOKG0pKXJldHVybiBmKGMsXCJuYW5cIixcIlwiLCEwKTthPSExOzA+bSYmKG09LW0sYT0hMCk7dmFyIGQ9W1widG9FeHBvbmVudGlhbFwiLFwidG9GaXhlZFwiLFwidG9QcmVjaXNpb25cIl1bXCJlZmdcIi5pbmRleE9mKG4udG9Mb3dlckNhc2UoKSldO2xldCBsPWNbOF0/cGFyc2VJbnQoY1s4XSwxMCk6NjttPW1bZF0obCk7LTEhPT1cIkVGR1wiLmluZGV4T2YobikmJihtPW0udG9VcHBlckNhc2UoKSk7XG5pZihcImdcIj09PW4udG9Mb3dlckNhc2UoKXx8IWNbOV0pe2lmKGQ9bS5tYXRjaCgvXFwuKFxcZCpbMS05XSk/KDArKSQvKSl7bGV0IFsscix2XT1kO209bS5zbGljZSgwLHI/LXYubGVuZ3RoOi0odi5sZW5ndGgrMSkpfS0xIT1tLmluZGV4T2YoXCIuXCIpfHxjWzldfHwobSs9XCIuMFwiKX1cImVcIj09PW4udG9Mb3dlckNhc2UoKSYmKG09bS5yZXBsYWNlKC9eKFstK10/WzAtOV0qXFwuP1swLTldK1tlRV1bLStdPykoWzAtOV0pPyQvLFwiJDEwJDJcIikpO2NbN10mJihuPW0udG9TdHJpbmcoKS5zcGxpdChcIi5cIiksblswXT1uWzBdLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csXCIsXCIpLG09bi5qb2luKFwiLlwiKSk7cmV0dXJuIGYoYyxtLGUoYyxhKSwhMCl9Y2FzZSBcIiVcIjppZihjWzRdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBbHRlcm5hdGUgZm9ybSAoIykgbm90IGFsbG93ZWQgd2l0aCBmb3JtYXQgc3BlY2lmaWVyICclJ1wiKTthPVNrLmJ1aWx0aW4uYXNudW0kKGEpO1wic3RyaW5nXCI9PT1cbnR5cGVvZiBhJiYoYT1OdW1iZXIoYSkpO2lmKEluZmluaXR5PT09YSlyZXR1cm4gZihjLFwiaW5mJVwiLFwiXCIsITApO2lmKC1JbmZpbml0eT09PWEpcmV0dXJuIGYoYyxcImluZiVcIixcIi1cIiwhMCk7aWYoaXNOYU4oYSkpcmV0dXJuIGYoYyxcIm5hbiVcIixcIlwiLCEwKTtuPSExOzA+YSYmKGE9LWEsbj0hMCk7bT1jWzhdP3BhcnNlSW50KGNbOF0sMTApOjY7YT0oMTAwKmEpLnRvRml4ZWQobSkrXCIlXCI7cmV0dXJuIGYoYyxhLGUoYyxuKSwhMCk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiVW5rbm93biBmb3JtYXQgY29kZSAnXCIrY1s5XStcIidcIik7fX07U2suZm9ybWF0dGluZy5ta051bWJlcl9fZm9ybWF0X189YT0+ZnVuY3Rpb24oYyl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZm9ybWF0KCkgYXJndW1lbnQgMiBtdXN0IGJlIHN0ciwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGMpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGgodGhpcyxcbmMuJGpzc3RyKCksYSkpfTtTay5mb3JtYXR0aW5nLmZvcm1hdD1mdW5jdGlvbihhLGMpe2M9Y3x8W107Y29uc3QgbT17fTtmb3IobGV0IGQ9MDtkPGMubGVuZ3RoO2QrPTIpbVtjW2RdXT1jW2QrMV07Zm9yKGxldCBkIGluIGEpbVtkXT1hW2RdO2xldCBuPTA7YT10aGlzLnYucmVwbGFjZSgveygoKD86XFxkKyl8KD86XFx3KykpPygoPzpcXC4oXFx3KykpfCg/OlxcWygoPzpcXGQrKXwoPzpcXHcrKSlcXF0pPykpPyg/OiEoW3JzXSkpPyg/OjooW159XSopKT99L2csZnVuY3Rpb24oZCxsLHIsdixxLHQsdyxDLEQsTCl7bGV0IE47aWYodm9pZCAwIT09dCYmXCJcIiE9PXQpZD1tW3JdLE49ZC5jb25zdHJ1Y3Rvcj09PUFycmF5P2RbdF06L15cXGQrJC8udGVzdCh0KT9Tay5hYnN0ci5vYmplY3RHZXRJdGVtKGQsbmV3IFNrLmJ1aWx0aW4uaW50XyhwYXJzZUludCh0LDEwKSksITEpOlNrLmFic3RyLm9iamVjdEdldEl0ZW0oZCxuZXcgU2suYnVpbHRpbi5zdHIodCksITEpLG4rKztlbHNlIGlmKHZvaWQgMCE9PVxucSYmXCJcIiE9PXEpTj1Tay5hYnN0ci5nYXR0cihtW3J8fG4rK10sbmV3IFNrLmJ1aWx0aW4uc3RyKHEpKTtlbHNlIGlmKHZvaWQgMCE9PXImJlwiXCIhPT1yKU49bVtyXTtlbHNlIGlmKHZvaWQgMD09PWx8fFwiXCI9PT1sKU49bVtuXSxuKys7ZWxzZSBpZihsIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRffHxsIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF98fGwgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZ3x8L15cXGQrJC8udGVzdChsKSlOPW1bbF0sbisrO2lmKFwic1wiPT09dylOPW5ldyBTay5idWlsdGluLnN0cihOKTtlbHNlIGlmKFwiclwiPT09dylOPVNrLmJ1aWx0aW4ucmVwcihOKTtlbHNlIGlmKFwiXCIhPT13JiZ2b2lkIDAhPT13KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJVbmtub3duIGNvbnZlcnNpb24gc3BlY2lmaWVyIFwiK3cpO3JldHVybiBTay5hYnN0ci5vYmplY3RGb3JtYXQoTixuZXcgU2suYnVpbHRpbi5zdHIoQykpLiRqc3N0cigpfSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihhKX07XG5Tay5mb3JtYXR0aW5nLmZvcm1hdFN0cmluZz1mdW5jdGlvbihhKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJmb3JtYXQoKSBhcmd1bWVudCAyIG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkpO2E9YS4kanNzdHIoKS5tYXRjaChiKTtpZihhWzldJiZcInNcIiE9PWFbOV0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIlVua25vd24gZm9ybWF0IGNvZGUgJ1wiK2FbOV0rXCInIGZvciBvYmplY3Qgb2YgdHlwZSAnc3RyJ1wiKTtpZihhWzNdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJTaWduIG5vdCBhbGxvd2VkIGluIHN0cmluZyBmb3JtYXQgc3BlY2lmaWVyXCIpO2lmKGFbNF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkFsdGVybmF0ZSBmb3JtICgjKSBub3QgYWxsb3dlZCB3aXRoIHN0cmluZyBmb3JtYXQgc3BlY2lmaWVyXCIpO2lmKGFbN10pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkNhbm5vdCBzcGVjaWZ5ICcsJyB3aXRoICdzJ1wiKTtcbmxldCBjPXRoaXMudjthWzhdJiYoYz1jLnN1YnN0cmluZygwLGFbOF0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGYoYSxjLFwiXCIsITEpKX19LGZ1bmN0aW9uKEUsUSl7ZnVuY3Rpb24gYihxKXtsZXQgdDtjb25zdCB3PVtdO2ZvcihsZXQgQz0wO0M8cS5sZW5ndGg7QysrKXQ9cS5jaGFyQXQoQyksbi50ZXN0KHQpP3cucHVzaCh0KTpcIlxcXFwwMDBcIj09PXQ/dy5wdXNoKFwiXFxcXDAwMFwiKTp3LnB1c2goXCJcXFxcXCIrdCk7cmV0dXJuIHcuam9pbihcIlwiKX1mdW5jdGlvbiBmKHEsdCx3KXt0PVNrLmJ1aWx0aW4uY2hlY2tOb25lKHQpP251bGw6cS5nZXQkdGd0KHQpO2lmKG51bGwhPT10JiYhdC5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImVtcHR5IHNlcGFyYXRvclwiKTtxPXEudjt2YXIgQz0wO2lmKG51bGw9PT10KXt2YXIgRD0vW1xcc1xceGEwXSsvZztDPXEubGVuZ3RoO3E9cS5yZXBsYWNlKGwsXCJcIik7Qy09cS5sZW5ndGh9ZWxzZSBEPXQucmVwbGFjZShkLFwiXFxcXCQxXCIpLFxuRD1uZXcgUmVnRXhwKEQsXCJnXCIpO2NvbnN0IEw9W107bGV0IE49MCxBPTAsSDtmb3Iodz0wPnc/SW5maW5pdHk6dztudWxsIT0oSD1ELmV4ZWMocSkpJiZBPHcmJkguaW5kZXghPT1ELmxhc3RJbmRleDspTC5wdXNoKE4rQyksTC5wdXNoKEguaW5kZXgrQyksTj1ELmxhc3RJbmRleCxBKz0xO2lmKG51bGwhPT10fHxxLmxlbmd0aC1OKUwucHVzaChOK0MpLEwucHVzaChxLmxlbmd0aCtDKTtyZXR1cm4gTH1mdW5jdGlvbiBlKHEsdCl7cmV0dXJuIGZ1bmN0aW9uKHcpe2lmKHZvaWQgMD09PXd8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKHcpKXc9cTtlbHNlIGlmKHcgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cil3PWIody52KSx3PW5ldyBSZWdFeHAodCh3KSxcImdcIik7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzdHJpcCBhcmcgbXVzdCBiZSBOb25lIG9yIHN0clwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5yZXBsYWNlKHcsXCJcIikpfX1mdW5jdGlvbiBnKHEpe3JldHVybiBmdW5jdGlvbih0KXt0PVxudGhpcy5nZXQkdGd0KHQpO2NvbnN0IHc9dGhpcy52O2xldCBDO2lmKHEpe2lmKEM9dy5sYXN0SW5kZXhPZih0KSwwPkMpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5zdHIoXCJcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpLG5ldyBTay5idWlsdGluLnN0cih3KV0pfWVsc2UgaWYoQz13LmluZGV4T2YodCksMD5DKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKHcpLG5ldyBTay5idWlsdGluLnN0cihcIlwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXCJcIildKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLnN0cih3LnN1YnN0cmluZygwLEMpKSxuZXcgU2suYnVpbHRpbi5zdHIodCksbmV3IFNrLmJ1aWx0aW4uc3RyKHcuc3Vic3RyaW5nKEMrdC5sZW5ndGgpKV0pfX1mdW5jdGlvbiBrKHEsdCl7cmV0dXJuIGZ1bmN0aW9uKHcsQyl7dz1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQodyxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO1xuaWYodm9pZCAwPT09QylDPVwiIFwiO2Vsc2UgaWYoQyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyJiYxPT09Qy5zcSRsZW5ndGgoKSlDPUMudjtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInRoZSBmaWxsIGNoYXJhY3RlciBtdXN0IGJlIGEgc3RyIG9mIGxlbmd0aCAxXCIpO3ZhciBEPXRoaXMuc3EkbGVuZ3RoKCk7aWYoRD49dylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudik7aWYodClyZXR1cm4gRD13LUQsdz1NYXRoLmZsb29yKEQvMikrKEQmdyYxKSxDPUMucmVwZWF0KHcpK3RoaXMuditDLnJlcGVhdChELXcpLG5ldyBTay5idWlsdGluLnN0cihDKTtDPUMucmVwZWF0KHctRCk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihxP0MrdGhpcy52OnRoaXMuditDKX19ZnVuY3Rpb24gcChxLHQsdyl7KHtzdGFydDp0LGVuZDp3fT1Tay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydChxLHQsdykpO2lmKHEuJGhhc0FzdHJhbENvZGVQb2ludHMoKSl7Y29uc3QgQz1cbnEuY29kZXBvaW50c1t0XTt0PXZvaWQgMD09PUM/dCtxLnYubGVuZ3RoLXEuY29kZXBvaW50cy5sZW5ndGg6Qzt3PXEuY29kZXBvaW50c1t3XTt3PXZvaWQgMD09PXc/cS52Lmxlbmd0aDp3fXJldHVybntzdGFydDp0LGVuZDp3fX1mdW5jdGlvbiBoKHEpe3JldHVybiBmdW5jdGlvbih0LHcsQyl7dD10aGlzLmdldCR0Z3QodCk7KHtzdGFydDp3LGVuZDpDfT1wKHRoaXMsdyxDKSk7aWYoQzx3KXJldHVybi0xO0MtPXQubGVuZ3RoO3Q9cT90aGlzLnYubGFzdEluZGV4T2YodCxDKTp0aGlzLnYuaW5kZXhPZih0LHcpO3Q9dD49dyYmdDw9Qz90Oi0xO2lmKHRoaXMuY29kZXBvaW50cyl7Qz10aGlzLnNxJGxlbmd0aCgpO3c9LTE7Zm9yKGxldCBEPTA7RDxDO0QrKyl0PT10aGlzLmNvZGVwb2ludHNbRF0mJih3PUQpfWVsc2Ugdz10O3JldHVybiB3fX1mdW5jdGlvbiBhKHEsdCl7cmV0dXJuIGZ1bmN0aW9uKHcsQyxEKXtpZighKHcgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cnx8dyBpbnN0YW5jZW9mXG5Tay5idWlsdGluLnR1cGxlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IocStcIiBmaXJzdCBhcmcgbXVzdCBiZSBzdHIgb3IgYSB0dXBsZSBvZiBzdHIsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZSh3KSk7KHtzdGFydDpDLGVuZDpEfT1wKHRoaXMsQyxEKSk7aWYoQz5EKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO0M9dGhpcy52LnNsaWNlKEMsRCk7aWYodyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpe2ZvcihsZXQgTD1Tay5hYnN0ci5pdGVyKHcpLE49TC50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PU47Tj1MLnRwJGl0ZXJuZXh0KCkpe2lmKCEoTiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0dXBsZSBmb3IgXCIrcStcIiBtdXN0IG9ubHkgY29udGFpbiBzdHIsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShOKSk7aWYodChDLE4udikpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJH1yZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJH1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0KEMsXG53LnYpKX19dmFyIGM9L15bMC05ISNfXS8sbT1PYmplY3QuY3JlYXRlKG51bGwpO1NrLmJ1aWx0aW4uc3RyPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJzdHJcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocSl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyLFwiYmFkIGNhbGwgdG8gc3RyIC0gdXNlICduZXcnXCIpO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgcSlpZih2b2lkIDA9PT1xKXE9XCJcIjtlbHNlIGlmKG51bGw9PT1xKXE9XCJOb25lXCI7ZWxzZXtpZih2b2lkIDAhPT1xLnRwJHN0cilyZXR1cm4gcS50cCRzdHIoKTtpZihcIm51bWJlclwiPT09dHlwZW9mIHEpcT1OdW1iZXIuaXNGaW5pdGUocSk/U3RyaW5nKHEpOlN0cmluZyhxKS5yZXBsYWNlKFwiSW5maW5pdHlcIixcImluZlwiKS5yZXBsYWNlKFwiTmFOXCIsXCJuYW5cIik7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb3VsZCBub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUocSkrXG5cIicgdG8gc3RyXCIpO312YXIgdD1tW3FdO2lmKHZvaWQgMCE9PXQpcmV0dXJuIHQ7bVtxXT10aGlzO3Q9dm9pZCAwPT09dltxXT9xOnErXCJfJHJ3JFwiO3RoaXMuJG1hbmdsZWQ9dDt0aGlzLiRzYXZlZEtleUhhc2g9cS5yZXBsYWNlKGMsXCIhJCZcIik7dGhpcy52PXF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGRvYzpcInN0cihvYmplY3Q9JycpIC0+IHN0clxcbnN0cihieXRlc19vcl9idWZmZXJbLCBlbmNvZGluZ1ssIGVycm9yc11dKSAtPiBzdHJcXG5cXG5DcmVhdGUgYSBuZXcgc3RyaW5nIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBvYmplY3QuIElmIGVuY29kaW5nIG9yXFxuZXJyb3JzIGlzIHNwZWNpZmllZCwgdGhlbiB0aGUgb2JqZWN0IG11c3QgZXhwb3NlIGEgZGF0YSBidWZmZXJcXG50aGF0IHdpbGwgYmUgZGVjb2RlZCB1c2luZyB0aGUgZ2l2ZW4gZW5jb2RpbmcgYW5kIGVycm9yIGhhbmRsZXIuXFxuT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygb2JqZWN0Ll9fc3RyX18oKSAoaWYgZGVmaW5lZClcXG5vciByZXByKG9iamVjdCkuXFxuZW5jb2RpbmcgZGVmYXVsdHMgdG8gc3lzLmdldGRlZmF1bHRlbmNvZGluZygpLlxcbmVycm9ycyBkZWZhdWx0cyB0byAnc3RyaWN0Jy5cIixcbnRwJG5ldyhxLHQpe3Q9dHx8W107aWYodGhpcyE9PVNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZSlyZXR1cm4gdGhpcy4kc3VidHlwZV9uZXcocSx0KTtpZigxPj1xLmxlbmd0aCYmIXQubGVuZ3RoKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIocVswXSk7aWYoU2suX19mdXR1cmVfXy5weXRob24zKXtjb25zdCBbdyxDLERdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwic3RyXCIsW1wib2JqZWN0XCIsXCJlbmNvZGluZ1wiLFwiZXJyb3JzXCJdLHEsdCk7aWYodm9pZCAwPT09d3x8dm9pZCAwPT09QyYmdm9pZCAwPT09RClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHcpO1NrLmJ1aWx0aW4uYnl0ZXMuY2hlY2skZW5jb2RlQXJncyhcInN0clwiLEMsRCk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tCeXRlcyh3KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZWNvZGluZyB0byBzdHI6IG5lZWQgYSBieXRlcy1saWtlIG9iamVjdCwgXCIrU2suYWJzdHIudHlwZU5hbWUodykrXCIgZm91bmRcIik7XG5yZXR1cm4gU2suYnVpbHRpbi5ieXRlcy4kZGVjb2RlLmNhbGwodyxDLEQpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN0ciB0YWtlcyBhdCBtb3N0IG9uZSBhcmd1bWVudCAoXCIrKHEubGVuZ3RoK3QubGVuZ3RoKStcIiBnaXZlbilcIik7fSwkcigpe2xldCBxPVwiJ1wiOy0xIT09dGhpcy52LmluZGV4T2YoXCInXCIpJiYtMT09PXRoaXMudi5pbmRleE9mKCdcIicpJiYocT0nXCInKTtjb25zdCB0PXRoaXMudi5sZW5ndGg7bGV0IHc9cTtmb3IobGV0IEw9MDtMPHQ7TCsrKXt2YXIgQz10aGlzLnYuY2hhckF0KEwpO3ZhciBEPXRoaXMudi5jaGFyQ29kZUF0KEwpO0M9PT1xfHxcIlxcXFxcIj09PUM/dys9XCJcXFxcXCIrQzpcIlxcdFwiPT09Qz93Kz1cIlxcXFx0XCI6XCJcXG5cIj09PUM/dys9XCJcXFxcblwiOlwiXFxyXCI9PT1DP3crPVwiXFxcXHJcIjooMjU1PEQmJjU1Mjk2PkR8fDU3MzQ0PD1EKSYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMz93Kz1cIlxcXFx1XCIrKFwiMDAwXCIrRC50b1N0cmluZygxNikpLnNsaWNlKC00KTo1NTI5Njw9RCYmXG4hU2suX19mdXR1cmVfXy5weXRob24zPyhDPXRoaXMudi5jb2RlUG9pbnRBdChMKSxMKyssQz1DLnRvU3RyaW5nKDE2KSxEPVwiMDAwMDAwMFwiK0MudG9TdHJpbmcoMTYpLHc9NDxDLmxlbmd0aD93KyhcIlxcXFxVXCIrRC5zbGljZSgtOCkpOncrKFwiXFxcXHVcIitELnNsaWNlKC00KSkpOjI1NTxEJiYhU2suX19mdXR1cmVfXy5weXRob24zP3crPVwiXFxcXHVmZmZkXCI6XCIgXCI+Q3x8MTI3PD1EJiYhU2suX19mdXR1cmVfXy5weXRob24zPyhDPUMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNiksMj5DLmxlbmd0aCYmKEM9XCIwXCIrQyksdys9XCJcXFxceFwiK0MpOncrPUN9cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih3K3EpfSx0cCRzdHIoKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uc3RyP3RoaXM6bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudil9LHRwJGl0ZXIoKXtyZXR1cm4gbmV3IHIodGhpcyl9LHRwJHJpY2hjb21wYXJlKHEsdCl7aWYoIShxIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtcbnN3aXRjaCh0KXtjYXNlIFwiTHRcIjpyZXR1cm4gdGhpcy52PHEudjtjYXNlIFwiTHRFXCI6cmV0dXJuIHRoaXMudjw9cS52O2Nhc2UgXCJFcVwiOnJldHVybiB0aGlzLnY9PT1xLnY7Y2FzZSBcIk5vdEVxXCI6cmV0dXJuIHRoaXMudiE9PXEudjtjYXNlIFwiR3RcIjpyZXR1cm4gdGhpcy52PnEudjtjYXNlIFwiR3RFXCI6cmV0dXJuIHRoaXMudj49cS52fX0sbXAkc3Vic2NyaXB0KHEpe2xldCB0O2lmKFNrLm1pc2NldmFsLmlzSW5kZXgocSkpe3E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTt0PXRoaXMuc3EkbGVuZ3RoKCk7MD5xJiYocSs9dCk7aWYoMD5xfHxxPj10KXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXCJzdHJpbmcgaW5kZXggb3V0IG9mIHJhbmdlXCIpO3JldHVybiB0aGlzLmNvZGVwb2ludHM/bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5zdWJzdHJpbmcodGhpcy5jb2RlcG9pbnRzW3FdLHRoaXMuY29kZXBvaW50c1txKzFdKSk6XG5uZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LmNoYXJBdChxKSl9aWYocSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2xpY2Upe2xldCB3PVwiXCI7dD10aGlzLnNxJGxlbmd0aCgpO3RoaXMuY29kZXBvaW50cz9xLnNzc2l0ZXIkKHQsQz0+e3crPXRoaXMudi5zdWJzdHJpbmcodGhpcy5jb2RlcG9pbnRzW0NdLHRoaXMuY29kZXBvaW50c1tDKzFdKX0pOnEuc3NzaXRlciQodCxDPT57dys9dGhpcy52LmNoYXJBdChDKX0pO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodyl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic3RyaW5nIGluZGljZXMgbXVzdCBiZSBpbnRlZ2Vycywgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKHEpKTt9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLiRoYXNBc3RyYWxDb2RlUG9pbnRzKCk/dGhpcy5jb2RlcG9pbnRzLmxlbmd0aDp0aGlzLnYubGVuZ3RofSxzcSRjb25jYXQocSl7aWYoIShxIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbm5vdCBjb25jYXRlbmF0ZSAnc3RyJyBhbmQgJ1wiK1xuU2suYWJzdHIudHlwZU5hbWUocSkrXCInIG9iamVjdHNcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYrcS52KX0sc3EkcmVwZWF0KHEpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KHEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUocSkrXCInXCIpO3E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtpZihxKnRoaXMudi5sZW5ndGg+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcjtsZXQgdD1cIlwiO2ZvcihsZXQgdz0wO3c8cTt3KyspdCs9dGhpcy52O3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodCl9LHNxJGNvbnRhaW5zKHEpe2lmKCEocSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInaW4gPHN0cmluZz4nIHJlcXVpcmVzIHN0cmluZyBhcyBsZWZ0IG9wZXJhbmQgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUocSkpO3JldHVybi0xIT09dGhpcy52LmluZGV4T2YocS52KX0sdHAkYXNfbnVtYmVyOiEwLG5iJHJlbWFpbmRlcjpmdW5jdGlvbihxKXt2YXIgdDtjb25zdCB3PXRoaXMuc2skYnVpbHRpbkJhc2U7cS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4udHVwbGV8fHEgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3R8fHEgaW5zdGFuY2VvZiBTay5idWlsdGluLm1hcHBpbmdwcm94eXx8KHE9bmV3IFNrLmJ1aWx0aW4udHVwbGUoW3FdKSk7dmFyIEM9MDt2YXIgRD10aGlzLiRqc3N0cigpLnJlcGxhY2UoLyUoXFwoW2EtekEtWjAtOV0rXFwpKT8oWyMwICtcXC1dKyk/KFxcKnxbMC05XSspPyhcXC4oXFwqfFswLTldKykpP1tobExdPyhbZGlvdXhYZUVmRmdHY3JzYiVdKS9nLGZ1bmN0aW9uKEwsTixBLEgseCxCLEYpe3ZhciBKLFAsVyxjYSxoYTtIPVNrLmJ1aWx0aW4uYXNudW0kKEgpO3g9U2suYnVpbHRpbi5hc251bSQoeCk7dm9pZCAwIT09TiYmXCJcIiE9PU58fFwiJVwiPT1GfHxcbihKPUMrKyk7XCJcIj09PXgmJih4PXZvaWQgMCk7dmFyIG9hPVA9Vz1jYT1oYT0hMTtBJiYoLTEhPT1BLmluZGV4T2YoXCItXCIpP2NhPSEwOi0xIT09QS5pbmRleE9mKFwiMFwiKSYmKGhhPSEwKSwtMSE9PUEuaW5kZXhPZihcIitcIik/UD0hMDotMSE9PUEuaW5kZXhPZihcIiBcIikmJihXPSEwKSxvYT0tMSE9PUEuaW5kZXhPZihcIiNcIikpO3gmJih4PXBhcnNlSW50KHguc3Vic3RyKDEpLDEwKSk7QT1mdW5jdGlvbihpYSxiYSl7dmFyIGphO2JhPVNrLmJ1aWx0aW4uYXNudW0kKGJhKTt2YXIgbmE9ITE7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBpYSl7MD5pYSYmKGlhPS1pYSxuYT0hMCk7dmFyIGZhPWlhLnRvU3RyaW5nKGJhKX1lbHNlIGlhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8/KGZhPWlhLnN0ciQoYmEsITEpLDI8ZmEubGVuZ3RoJiZcIi4wXCI9PT1mYS5zdWJzdHIoLTIpJiYoZmE9ZmEuc3Vic3RyKDAsZmEubGVuZ3RoLTIpKSxuYT1pYS5uYiRpc25lZ2F0aXZlKCkpOmlhIGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uaW50Xz8oZmE9aWEuc3RyJChiYSwhMSksbmE9aWEubmIkaXNuZWdhdGl2ZSgpKTppYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nJiYoZmE9aWEuc3RyJChiYSwhMSksbmE9aWEubmIkaXNuZWdhdGl2ZSgpKTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1mYSxcInVuaGFuZGxlZCBudW1iZXIgZm9ybWF0XCIpO2lhPSExO2lmKHgpZm9yKGphPWZhLmxlbmd0aDtqYTx4OysramEpZmE9XCIwXCIrZmEsaWE9ITA7amE9XCJcIjtuYT9qYT1cIi1cIjpQP2phPVwiK1wiK2phOlcmJihqYT1cIiBcIitqYSk7b2EmJigxNj09PWJhP2phKz1cIjB4XCI6OCE9PWJhfHxpYXx8XCIwXCI9PT1mYXx8KGphKz1cIjBcIikpO3JldHVybltqYSxmYV19O0w9ZnVuY3Rpb24oaWEpe3ZhciBiYT1pYVswXTtpYT1pYVsxXTtpZihIKXtIPXBhcnNlSW50KEgsMTApO3ZhciBqYT1pYS5sZW5ndGgrYmEubGVuZ3RoO2lmKGhhKWZvcig7amE8SDsrK2phKWlhPVwiMFwiK2lhO2Vsc2UgaWYoY2Epe2Zvcig7amE8SDsrK2phKWlhKz1cblwiIFwiO1NrLl9fZnV0dXJlX18ucHl0aG9uMyYmKGlhKz1iYSxiYT1cIlwiKX1lbHNlIGZvcig7amE8SDsrK2phKWJhPVwiIFwiK2JhfXJldHVybiBiYStpYX07aWYocS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4udHVwbGUpTj1xLnZbSl07ZWxzZSBpZih2b2lkIDAhPT1xLm1wJHN1YnNjcmlwdCYmdm9pZCAwIT09TilOPU4uc3Vic3RyaW5nKDEsTi5sZW5ndGgtMSksTj1xLm1wJHN1YnNjcmlwdChuZXcgdyhOKSk7ZWxzZSBpZihxLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5kaWN0fHxxLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5saXN0KU49cTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKHEudHAkbmFtZStcIiBpbnN0YW5jZSBoYXMgbm8gYXR0cmlidXRlICdtcCRzdWJzY3JpcHQnXCIpO2lmKFwiZFwiPT09Rnx8XCJpXCI9PT1GKXt2YXIga2E9QShOLDEwKTtpZih2b2lkIDA9PT1rYVsxXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCIlXCIrRitcIiBmb3JtYXQ6IGEgbnVtYmVyIGlzIHJlcXVpcmVkLCBub3QgXCIrXG5Tay5hYnN0ci50eXBlTmFtZShOKSk7Rj1rYVsxXTtrYVsxXT0tMSE9PUYuaW5kZXhPZihcIi5cIik/cGFyc2VJbnQoRiwxMCkudG9TdHJpbmcoKTpGO3JldHVybiBMKGthKX1pZihcIm9cIj09PUYpcmV0dXJuIEwoQShOLDgpKTtpZihcInhcIj09PUYpcmV0dXJuIEwoQShOLDE2KSk7aWYoXCJYXCI9PT1GKXJldHVybiBMKEEoTiwxNikpLnRvVXBwZXJDYXNlKCk7aWYoXCJmXCI9PT1GfHxcIkZcIj09PUZ8fFwiZVwiPT09Rnx8XCJFXCI9PT1GfHxcImdcIj09PUZ8fFwiR1wiPT09Ril7a2E9U2suYnVpbHRpbi5hc251bSQoTik7XCJzdHJpbmdcIj09PXR5cGVvZiBrYSYmKGthPU51bWJlcihrYSkpO2lmKEluZmluaXR5PT09a2EpcmV0dXJuXCJpbmZcIjtpZigtSW5maW5pdHk9PT1rYSlyZXR1cm5cIi1pbmZcIjtpZihpc05hTihrYSkpcmV0dXJuXCJuYW5cIjtKPVtcInRvRXhwb25lbnRpYWxcIixcInRvRml4ZWRcIixcInRvUHJlY2lzaW9uXCJdW1wiZWZnXCIuaW5kZXhPZihGLnRvTG93ZXJDYXNlKCkpXTtpZih2b2lkIDA9PT14fHxcIlwiPT09eClpZihcImVcIj09PVxuRnx8XCJFXCI9PT1GKXg9NjtlbHNlIGlmKFwiZlwiPT09Rnx8XCJGXCI9PT1GKXg9U2suX19mdXR1cmVfXy5weXRob24zPzY6NztKPWthW0pdKHgpO1NrLmJ1aWx0aW4uY2hlY2tGbG9hdChOKSYmMD09PWthJiYtSW5maW5pdHk9PT0xL2thJiYoSj1cIi1cIitKKTtTay5fX2Z1dHVyZV9fLnB5dGhvbjMmJig3PD1KLmxlbmd0aCYmXCIwLjAwMDBcIj09Si5zbGljZSgwLDYpJiYodD1wYXJzZUZsb2F0KEopLEo9dC50b0V4cG9uZW50aWFsKCkpLFwiLVwiPT1KLmNoYXJBdChKLmxlbmd0aC0yKSYmKEo9Si5zbGljZSgwLEoubGVuZ3RoLTEpK1wiMFwiK0ouY2hhckF0KEoubGVuZ3RoLTEpKSk7LTEhPT1cIkVGR1wiLmluZGV4T2YoRikmJihKPUoudG9VcHBlckNhc2UoKSk7cmV0dXJuIEwoW1wiXCIsSl0pfWlmKFwiY1wiPT09Ril7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBOKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKE4pO2lmKE4gaW5zdGFuY2VvZiBTay5idWlsdGluLmludF98fE4gaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XylyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShOLnYpO1xuaWYoTiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKE4uc3RyJCgxMCwhMSlbMF0pO2lmKE4uY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnN0cilyZXR1cm4gTi52LnN1YnN0cigwLDEpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFuIGludGVnZXIgaXMgcmVxdWlyZWRcIik7fWlmKFwiclwiPT09RilyZXR1cm4gRj1Tay5idWlsdGluLnJlcHIoTikseD9GLnYuc3Vic3RyKDAseCk6Ri52O2lmKFwic1wiPT09RiYmdz09PVNrLmJ1aWx0aW4uc3RyKXtGPW5ldyBTay5idWlsdGluLnN0cihOKTtGPUYuJGpzc3RyKCk7aWYoeClyZXR1cm4gRi5zdWJzdHIoMCx4KTtIJiYoRj1MKFtcIiBcIixGXSkpO3JldHVybiBGfWlmKFwiYlwiPT09Rnx8XCJzXCI9PT1GKXtpZih3PT09U2suYnVpbHRpbi5zdHIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInVuc3VwcG9ydGVkIGZvcm1hdCBjaGFyYWN0ZXIgJ2InXCIpO2lmKCEoTiBpbnN0YW5jZW9mXG5Tay5idWlsdGluLmJ5dGVzKSYmdm9pZCAwPT09KGthPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoTixTay5idWlsdGluLnN0ci4kYnl0ZXMpKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCIlYiByZXF1aXJlcyBhIGJ5dGVzLWxpa2Ugb2JqZWN0LCBvciBhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIF9fYnl0ZXNfXywgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZShOKStcIidcIik7dm9pZCAwIT09a2EmJihOPW5ldyBTay5idWlsdGluLmJ5dGVzKE4pKTtGPU4uJGpzc3RyKCk7aWYoeClyZXR1cm4gRi5zdWJzdHIoMCx4KTtIJiYoRj1MKFtcIiBcIixGXSkpO3JldHVybiBGfWlmKFwiJVwiPT09RilyZXR1cm5cIiVcIn0pO2lmKHEgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlJiZDPHEuc3EkbGVuZ3RoKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibm90IGFsbCBhcmd1bWVudHMgY29udmVydGVkIGR1cmluZyBzdHJpbmcgZm9ybWF0dGluZ1wiKTtyZXR1cm4gbmV3IHcoRCl9fSxcbnByb3RvOnt0b1N0cmluZygpe3JldHVybiB0aGlzLnZ9LCRzdWJ0eXBlX25ldyhxLHQpe2NvbnN0IHc9bmV3IHRoaXMuY29uc3RydWN0b3I7cT1Tay5idWlsdGluLnN0ci5wcm90b3R5cGUudHAkbmV3KHEsdCk7dy4kbWFuZ2xlZD1xLiRtYW5nbGVkO3cuJHNhdmVkS2V5SGFzaD1xLiRzYXZlZEtleUhhc2g7dy52PXEudjtyZXR1cm4gd30sJGpzc3RyKCl7cmV0dXJuIHRoaXMudn0sJGhhc0FzdHJhbENvZGVQb2ludHMoKXtpZihudWxsPT09dGhpcy5jb2RlcG9pbnRzKXJldHVybiExO2lmKHZvaWQgMCE9PXRoaXMuY29kZXBvaW50cylyZXR1cm4hMDtmb3IodmFyIHE9MDtxPHRoaXMudi5sZW5ndGg7cSsrKXtsZXQgdD10aGlzLnYuY2hhckNvZGVBdChxKTtpZig1NTI5Njw9dCYmNTczNDQ+dCl7dGhpcy5jb2RlcG9pbnRzPVtdO2ZvcihxPTA7cTx0aGlzLnYubGVuZ3RoO3ErKyl0aGlzLmNvZGVwb2ludHMucHVzaChxKSx0PXRoaXMudi5jaGFyQ29kZUF0KHEpLDU1Mjk2PD10JiY1NjMyMD5cbnQmJnErKztyZXR1cm4hMH19dGhpcy5jb2RlcG9pbnRzPW51bGw7cmV0dXJuITF9LHNrJGFzYXJyYXkoKXtjb25zdCBxPVtdO2lmKHRoaXMuJGhhc0FzdHJhbENvZGVQb2ludHMoKSl7dmFyIHQ9dGhpcy5jb2RlcG9pbnRzO2ZvcihsZXQgdz0wO3c8dC5sZW5ndGg7dysrKXEucHVzaChuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnN1YnN0cmluZyh0W3ddLHRbdysxXSkpKX1lbHNlIGZvcih0PTA7dDx0aGlzLnYubGVuZ3RoO3QrKylxLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudlt0XSkpO3JldHVybiBxfSxmaW5kJGxlZnQ6aCghMSksZmluZCRyaWdodDpoKCEwKSxnZXQkdGd0KHEpe2lmKHEgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cilyZXR1cm4gcS52O3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImEgc3RyIGluc3RhbmNlIGlzIHJlcXVpcmVkIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUocSkrXCInXCIpO30sdmFsdWVPZigpe3JldHVybiB0aGlzLnZ9LCRpc0lkZW50aWZpZXIoKXtyZXR1cm4gU2sudG9rZW4uaXNJZGVudGlmaWVyKHRoaXMudil9fSxcbm1ldGhvZHM6e2VuY29kZTp7JG1ldGg6ZnVuY3Rpb24ocSx0KXsoe2VuY29kaW5nOnEsZXJyb3JzOnR9PVNrLmJ1aWx0aW4uYnl0ZXMuY2hlY2skZW5jb2RlQXJncyhcImVuY29kZVwiLHEsdCkpO3E9U2suYnVpbHRpbi5ieXRlcy5zdHIkZW5jb2RlKHRoaXMscSx0KTtyZXR1cm4gU2suX19mdXR1cmVfXy5weXRob24zP3E6bmV3IFNrLmJ1aWx0aW4uc3RyKHEuJGpzc3RyKCkpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJlbmNvZGluZ1wiLFwiZXJyb3JzXCJdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPSdzdHJpY3QnKVwiLCRkb2M6XCJFbmNvZGUgdGhlIHN0cmluZyB1c2luZyB0aGUgY29kZWMgcmVnaXN0ZXJlZCBmb3IgZW5jb2RpbmcuXFxuXFxuICBlbmNvZGluZ1xcbiAgICBUaGUgZW5jb2RpbmcgaW4gd2hpY2ggdG8gZW5jb2RlIHRoZSBzdHJpbmcuXFxuICBlcnJvcnNcXG4gICAgVGhlIGVycm9yIGhhbmRsaW5nIHNjaGVtZSB0byB1c2UgZm9yIGVuY29kaW5nIGVycm9ycy5cXG4gICAgVGhlIGRlZmF1bHQgaXMgJ3N0cmljdCcgbWVhbmluZyB0aGF0IGVuY29kaW5nIGVycm9ycyByYWlzZSBhXFxuICAgIFVuaWNvZGVFbmNvZGVFcnJvci4gIE90aGVyIHBvc3NpYmxlIHZhbHVlcyBhcmUgJ2lnbm9yZScsICdyZXBsYWNlJyBhbmRcXG4gICAgJ3htbGNoYXJyZWZyZXBsYWNlJyBhcyB3ZWxsIGFzIGFueSBvdGhlciBuYW1lIHJlZ2lzdGVyZWQgd2l0aFxcbiAgICBjb2RlY3MucmVnaXN0ZXJfZXJyb3IgdGhhdCBjYW4gaGFuZGxlIFVuaWNvZGVFbmNvZGVFcnJvcnMuXCJ9LFxucmVwbGFjZTp7JG1ldGgocSx0LHcpe3E9dGhpcy5nZXQkdGd0KHEpO3Q9dGhpcy5nZXQkdGd0KHQpO3c9dm9pZCAwPT09dz8tMTpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQodyxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO3E9bmV3IFJlZ0V4cChiKHEpLFwiZ1wiKTtpZigwPncpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYucmVwbGFjZShxLHQpKTtsZXQgQz0wO3E9dGhpcy52LnJlcGxhY2UocSxEPT5DKys8dz90OkQpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIocSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJHNlbGYsIG9sZCwgbmV3LCBjb3VudD0tMSwgLylcIiwkZG9jOlwiUmV0dXJuIGEgY29weSB3aXRoIGFsbCBvY2N1cnJlbmNlcyBvZiBzdWJzdHJpbmcgb2xkIHJlcGxhY2VkIGJ5IG5ldy5cXG5cXG4gIGNvdW50XFxuICAgIE1heGltdW0gbnVtYmVyIG9mIG9jY3VycmVuY2VzIHRvIHJlcGxhY2UuXFxuICAgIC0xICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgcmVwbGFjZSBhbGwgb2NjdXJyZW5jZXMuXFxuXFxuSWYgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGNvdW50IGlzIGdpdmVuLCBvbmx5IHRoZSBmaXJzdCBjb3VudCBvY2N1cnJlbmNlcyBhcmVcXG5yZXBsYWNlZC5cIn0sXG5zcGxpdDp7JG1ldGg6ZnVuY3Rpb24ocSx0KXt0PVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh0LFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7cT1mKHRoaXMscSx0KTt0PVtdO2ZvcihsZXQgdz0wO3c8cS5sZW5ndGg7dysrKXQucHVzaChuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnN1YnN0cmluZyhxW3ddLHFbKyt3XSkpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0KX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wic2VwXCIsXCJtYXhzcGxpdFwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ub25lLm5vbmUkLC0xXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIHNlcD1Ob25lLCBtYXhzcGxpdD0tMSlcIiwkZG9jOlwiUmV0dXJuIGEgbGlzdCBvZiB0aGUgd29yZHMgaW4gdGhlIHN0cmluZywgdXNpbmcgc2VwIGFzIHRoZSBkZWxpbWl0ZXIgc3RyaW5nLlxcblxcbiAgc2VwXFxuICAgIFRoZSBkZWxpbWl0ZXIgYWNjb3JkaW5nIHdoaWNoIHRvIHNwbGl0IHRoZSBzdHJpbmcuXFxuICAgIE5vbmUgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyBzcGxpdCBhY2NvcmRpbmcgdG8gYW55IHdoaXRlc3BhY2UsXFxuICAgIGFuZCBkaXNjYXJkIGVtcHR5IHN0cmluZ3MgZnJvbSB0aGUgcmVzdWx0LlxcbiAgbWF4c3BsaXRcXG4gICAgTWF4aW11bSBudW1iZXIgb2Ygc3BsaXRzIHRvIGRvLlxcbiAgICAtMSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIG5vIGxpbWl0LlwifSxcbnJzcGxpdDp7JG1ldGg6ZnVuY3Rpb24ocSx0KXt0PVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh0LFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7cT1mKHRoaXMscSwtMSk7dmFyIHc9MD50PzA6MioocS5sZW5ndGgvMi10KTt0PVtdO2ZvcigwPj13P3c9MDp0LnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5zbGljZSgwLHFbdy0xXSkpKTt3PHEubGVuZ3RoO3crKyl0LnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5zdWJzdHJpbmcocVt3XSxxWysrd10pKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QodCl9LCRmbGFnczp7TmFtZWRBcmdzOltcInNlcFwiLFwibWF4c3BsaXRcIl0sRGVmYXVsdHM6W1NrLmJ1aWx0aW4ubm9uZS5ub25lJCwtMV19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBzZXA9Tm9uZSwgbWF4c3BsaXQ9LTEpXCIsJGRvYzpcIlJldHVybiBhIGxpc3Qgb2YgdGhlIHdvcmRzIGluIHRoZSBzdHJpbmcsIHVzaW5nIHNlcCBhcyB0aGUgZGVsaW1pdGVyIHN0cmluZy5cXG5cXG4gIHNlcFxcbiAgICBUaGUgZGVsaW1pdGVyIGFjY29yZGluZyB3aGljaCB0byBzcGxpdCB0aGUgc3RyaW5nLlxcbiAgICBOb25lICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgc3BsaXQgYWNjb3JkaW5nIHRvIGFueSB3aGl0ZXNwYWNlLFxcbiAgICBhbmQgZGlzY2FyZCBlbXB0eSBzdHJpbmdzIGZyb20gdGhlIHJlc3VsdC5cXG4gIG1heHNwbGl0XFxuICAgIE1heGltdW0gbnVtYmVyIG9mIHNwbGl0cyB0byBkby5cXG4gICAgLTEgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyBubyBsaW1pdC5cXG5cXG5TcGxpdHMgYXJlIGRvbmUgc3RhcnRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIGFuZCB3b3JraW5nIHRvIHRoZSBmcm9udC5cIn0sXG5qb2luOnskbWV0aChxKXtjb25zdCB0PVtdO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIocSksdz0+e2lmKCEodyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZXF1ZW5jZSBpdGVtIFwiK3QubGVuZ3RoK1wiOiBleHBlY3RlZCBzdHIsIFwiK1NrLmFic3RyLnR5cGVOYW1lKHcpK1wiIGZvdW5kXCIpO3QucHVzaCh3LnYpfSksKCk9Pm5ldyBTay5idWlsdGluLnN0cih0LmpvaW4odGhpcy52KSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGl0ZXJhYmxlLCAvKVwiLCRkb2M6XCJDb25jYXRlbmF0ZSBhbnkgbnVtYmVyIG9mIHN0cmluZ3MuXFxuXFxuVGhlIHN0cmluZyB3aG9zZSBtZXRob2QgaXMgY2FsbGVkIGlzIGluc2VydGVkIGluIGJldHdlZW4gZWFjaCBnaXZlbiBzdHJpbmcuXFxuVGhlIHJlc3VsdCBpcyByZXR1cm5lZCBhcyBhIG5ldyBzdHJpbmcuXFxuXFxuRXhhbXBsZTogJy4nLmpvaW4oWydhYicsICdwcScsICdycyddKSAtPiAnYWIucHEucnMnXCJ9LFxuY2FwaXRhbGl6ZTp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0aGlzLnYuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIGEgY2FwaXRhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxcblxcbk1vcmUgc3BlY2lmaWNhbGx5LCBtYWtlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaGF2ZSB1cHBlciBjYXNlIGFuZCB0aGUgcmVzdCBsb3dlclxcbmNhc2UuXCJ9LHRpdGxlOnskbWV0aDpmdW5jdGlvbigpe2NvbnN0IHE9dGhpcy52LnJlcGxhY2UoL1thLXpdW2Etel0qL2dpLHQ9PnRbMF0udG9VcHBlckNhc2UoKSt0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHEpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBhIHZlcnNpb24gb2YgdGhlIHN0cmluZyB3aGVyZSBlYWNoIHdvcmQgaXMgdGl0bGVjYXNlZC5cXG5cXG5Nb3JlIHNwZWNpZmljYWxseSwgd29yZHMgc3RhcnQgd2l0aCB1cHBlcmNhc2VkIGNoYXJhY3RlcnMgYW5kIGFsbCByZW1haW5pbmdcXG5jYXNlZCBjaGFyYWN0ZXJzIGhhdmUgbG93ZXIgY2FzZS5cIn0sXG5jZW50ZXI6eyRtZXRoOmsoITEsITApLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJHNlbGYsIHdpZHRoLCBmaWxsY2hhcj0nICcsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNlbnRlcmVkIHN0cmluZyBvZiBsZW5ndGggd2lkdGguXFxuXFxuUGFkZGluZyBpcyBkb25lIHVzaW5nIHRoZSBzcGVjaWZpZWQgZmlsbCBjaGFyYWN0ZXIgKGRlZmF1bHQgaXMgYSBzcGFjZSkuXCJ9LGNvdW50OnskbWV0aDpmdW5jdGlvbihxLHQsdyl7cT10aGlzLmdldCR0Z3QocSk7KHtzdGFydDp0LGVuZDp3fT1wKHRoaXMsdCx3KSk7aWYodzx0KXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKDApO3E9cS5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZyxcIlxcXFwkJlwiKTtxPW5ldyBSZWdFeHAocSxcImdcIik7cmV0dXJuKHQ9dGhpcy52LnNsaWNlKHQsdykubWF0Y2gocSkpP25ldyBTay5idWlsdGluLmludF8odC5sZW5ndGgpOm5ldyBTay5idWlsdGluLmludF8oMCl9LCRmbGFnczp7TWluQXJnczoxLFxuTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLmNvdW50KHN1YlssIHN0YXJ0WywgZW5kXV0pIC0+IGludFxcblxcblJldHVybiB0aGUgbnVtYmVyIG9mIG5vbi1vdmVybGFwcGluZyBvY2N1cnJlbmNlcyBvZiBzdWJzdHJpbmcgc3ViIGluXFxuc3RyaW5nIFNbc3RhcnQ6ZW5kXS4gIE9wdGlvbmFsIGFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZVxcbmludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlwifSxleHBhbmR0YWJzOnskbWV0aDpmdW5jdGlvbihxKXtpZihTay5idWlsdGluLmNoZWNrSW50KHEpKXE9U2suYnVpbHRpbi5hc251bSQocSk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhbiBpbnRlZ2VyIGlzIHJlcXVpcmVkLCBnb3QgdHlwZVwiK1NrLmFic3RyLnR5cGVOYW1lKHEpKTtjb25zdCB0PUFycmF5KHErMSkuam9pbihcIiBcIiksdz10aGlzLnYucmVwbGFjZSgvKFteXFxyXFxuXFx0XSopXFx0L2csKEMsRCk9PkQrdC5zbGljZShELmxlbmd0aCVxKSk7XG5yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHcpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJ0YWJzaXplXCJdLERlZmF1bHRzOls4XX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIHRhYnNpemU9OClcIiwkZG9jOlwiUmV0dXJuIGEgY29weSB3aGVyZSBhbGwgdGFiIGNoYXJhY3RlcnMgYXJlIGV4cGFuZGVkIHVzaW5nIHNwYWNlcy5cXG5cXG5JZiB0YWJzaXplIGlzIG5vdCBnaXZlbiwgYSB0YWIgc2l6ZSBvZiA4IGNoYXJhY3RlcnMgaXMgYXNzdW1lZC5cIn0sZmluZDp7JG1ldGg6ZnVuY3Rpb24ocSx0LHcpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuZmluZCRsZWZ0KHEsdCx3KSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5maW5kKHN1YlssIHN0YXJ0WywgZW5kXV0pIC0+IGludFxcblxcblJldHVybiB0aGUgbG93ZXN0IGluZGV4IGluIFMgd2hlcmUgc3Vic3RyaW5nIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gU1tzdGFydDplbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmV0dXJuIC0xIG9uIGZhaWx1cmUuXCJ9LFxucGFydGl0aW9uOnskbWV0aDpnKCExKSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIHNlcCwgLylcIiwkZG9jOlwiUGFydGl0aW9uIHRoZSBzdHJpbmcgaW50byB0aHJlZSBwYXJ0cyB1c2luZyB0aGUgZ2l2ZW4gc2VwYXJhdG9yLlxcblxcblRoaXMgd2lsbCBzZWFyY2ggZm9yIHRoZSBzZXBhcmF0b3IgaW4gdGhlIHN0cmluZy4gIElmIHRoZSBzZXBhcmF0b3IgaXMgZm91bmQsXFxucmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgcGFydCBiZWZvcmUgdGhlIHNlcGFyYXRvciwgdGhlIHNlcGFyYXRvclxcbml0c2VsZiwgYW5kIHRoZSBwYXJ0IGFmdGVyIGl0LlxcblxcbklmIHRoZSBzZXBhcmF0b3IgaXMgbm90IGZvdW5kLCByZXR1cm5zIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBzdHJpbmdcXG5hbmQgdHdvIGVtcHR5IHN0cmluZ3MuXCJ9LGluZGV4OnskbWV0aDpmdW5jdGlvbihxLHQsdyl7cT10aGlzLmZpbmQkbGVmdChxLHQsdyk7aWYoLTE9PT1xKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzdWJzdHJpbmcgbm90IGZvdW5kXCIpO1xucmV0dXJuIG5ldyBTay5idWlsdGluLmludF8ocSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5pbmRleChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGxvd2VzdCBpbmRleCBpbiBTIHdoZXJlIHN1YnN0cmluZyBzdWIgaXMgZm91bmQsIFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBTW3N0YXJ0OmVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciB3aGVuIHRoZSBzdWJzdHJpbmcgaXMgbm90IGZvdW5kLlwifSxsanVzdDp7JG1ldGg6ayghMSwhMSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkc2VsZiwgd2lkdGgsIGZpbGxjaGFyPScgJywgLylcIiwkZG9jOlwiUmV0dXJuIGEgbGVmdC1qdXN0aWZpZWQgc3RyaW5nIG9mIGxlbmd0aCB3aWR0aC5cXG5cXG5QYWRkaW5nIGlzIGRvbmUgdXNpbmcgdGhlIHNwZWNpZmllZCBmaWxsIGNoYXJhY3RlciAoZGVmYXVsdCBpcyBhIHNwYWNlKS5cIn0sXG5sb3dlcjp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi50b0xvd2VyQ2FzZSgpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IG9mIHRoZSBzdHJpbmcgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cIn0sbHN0cmlwOnskbWV0aDplKC9eXFxzKy9nLHE9PlwiXltcIitxK1wiXStcIiksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgY2hhcnM9Tm9uZSwgLylcIiwkZG9jOlwiUmV0dXJuIGEgY29weSBvZiB0aGUgc3RyaW5nIHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQuXFxuXFxuSWYgY2hhcnMgaXMgZ2l2ZW4gYW5kIG5vdCBOb25lLCByZW1vdmUgY2hhcmFjdGVycyBpbiBjaGFycyBpbnN0ZWFkLlwifSxyZmluZDp7JG1ldGgocSx0LHcpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuZmluZCRyaWdodChxLHQsdykpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LFxuJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5yZmluZChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGhpZ2hlc3QgaW5kZXggaW4gUyB3aGVyZSBzdWJzdHJpbmcgc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBTW3N0YXJ0OmVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SZXR1cm4gLTEgb24gZmFpbHVyZS5cIn0scmluZGV4OnskbWV0aDpmdW5jdGlvbihxLHQsdyl7cT10aGlzLmZpbmQkcmlnaHQocSx0LHcpO2lmKC0xPT09cSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwic3Vic3RyaW5nIG5vdCBmb3VuZFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhxKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLnJpbmRleChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGhpZ2hlc3QgaW5kZXggaW4gUyB3aGVyZSBzdWJzdHJpbmcgc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBTW3N0YXJ0OmVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciB3aGVuIHRoZSBzdWJzdHJpbmcgaXMgbm90IGZvdW5kLlwifSxcbnJqdXN0OnskbWV0aDprKCEwLCExKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRzZWxmLCB3aWR0aCwgZmlsbGNoYXI9JyAnLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSByaWdodC1qdXN0aWZpZWQgc3RyaW5nIG9mIGxlbmd0aCB3aWR0aC5cXG5cXG5QYWRkaW5nIGlzIGRvbmUgdXNpbmcgdGhlIHNwZWNpZmllZCBmaWxsIGNoYXJhY3RlciAoZGVmYXVsdCBpcyBhIHNwYWNlKS5cIn0scnN0cmlwOnskbWV0aDplKC9cXHMrJC9nLHE9PlwiW1wiK3ErXCJdKyRcIiksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgY2hhcnM9Tm9uZSwgLylcIiwkZG9jOlwiUmV0dXJuIGEgY29weSBvZiB0aGUgc3RyaW5nIHdpdGggdHJhaWxpbmcgd2hpdGVzcGFjZSByZW1vdmVkLlxcblxcbklmIGNoYXJzIGlzIGdpdmVuIGFuZCBub3QgTm9uZSwgcmVtb3ZlIGNoYXJhY3RlcnMgaW4gY2hhcnMgaW5zdGVhZC5cIn0scnBhcnRpdGlvbjp7JG1ldGg6ZyghMCksJGZsYWdzOntPbmVBcmc6ITB9LFxuJHRleHRzaWc6XCIoJHNlbGYsIHNlcCwgLylcIiwkZG9jOlwiUGFydGl0aW9uIHRoZSBzdHJpbmcgaW50byB0aHJlZSBwYXJ0cyB1c2luZyB0aGUgZ2l2ZW4gc2VwYXJhdG9yLlxcblxcblRoaXMgd2lsbCBzZWFyY2ggZm9yIHRoZSBzZXBhcmF0b3IgaW4gdGhlIHN0cmluZywgc3RhcnRpbmcgYXQgdGhlIGVuZC4gSWZcXG50aGUgc2VwYXJhdG9yIGlzIGZvdW5kLCByZXR1cm5zIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSBwYXJ0IGJlZm9yZSB0aGVcXG5zZXBhcmF0b3IsIHRoZSBzZXBhcmF0b3IgaXRzZWxmLCBhbmQgdGhlIHBhcnQgYWZ0ZXIgaXQuXFxuXFxuSWYgdGhlIHNlcGFyYXRvciBpcyBub3QgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdHdvIGVtcHR5IHN0cmluZ3NcXG5hbmQgdGhlIG9yaWdpbmFsIHN0cmluZy5cIn0sc3BsaXRsaW5lczp7JG1ldGg6ZnVuY3Rpb24ocSl7cT1Tay5taXNjZXZhbC5pc1RydWUocSk7Y29uc3QgdD10aGlzLnYsdz1bXSxDPXQubGVuZ3RoO3ZhciBEPVxuMDtmb3IobGV0IE49MDtOPEM7TisrKXt2YXIgTD10LmNoYXJBdChOKTtpZihcIlxcblwiPT09dC5jaGFyQXQoTisxKSYmXCJcXHJcIj09PUwpTD1OKzIsRD10LnNsaWNlKEQsTCkscXx8KEQ9RC5yZXBsYWNlKC8oXFxyfFxcbikvZyxcIlwiKSksdy5wdXNoKG5ldyBTay5idWlsdGluLnN0cihEKSksRD1MO2Vsc2UgaWYoXCJcXG5cIj09PUwmJlwiXFxyXCIhPT10LmNoYXJBdChOLTEpfHxcIlxcclwiPT09TClMPU4rMSxEPXQuc2xpY2UoRCxMKSxxfHwoRD1ELnJlcGxhY2UoLyhcXHJ8XFxuKS9nLFwiXCIpKSx3LnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKEQpKSxEPUx9RDxDJiYoRD10LnNsaWNlKEQsQykscXx8KEQ9RC5yZXBsYWNlKC8oXFxyfFxcbikvZyxcIlwiKSksdy5wdXNoKG5ldyBTay5idWlsdGluLnN0cihEKSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHcpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJrZWVwZW5kc1wiXSxEZWZhdWx0czpbITFdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywga2VlcGVuZHM9RmFsc2UpXCIsJGRvYzpcIlJldHVybiBhIGxpc3Qgb2YgdGhlIGxpbmVzIGluIHRoZSBzdHJpbmcsIGJyZWFraW5nIGF0IGxpbmUgYm91bmRhcmllcy5cXG5cXG5MaW5lIGJyZWFrcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgbGlzdCB1bmxlc3Mga2VlcGVuZHMgaXMgZ2l2ZW4gYW5kXFxudHJ1ZS5cIn0sXG5zdHJpcDp7JG1ldGg6ZSgvXlxccyt8XFxzKyQvZyxxPT5cIl5bXCIrcStcIl0rfFtcIitxK1wiXSskXCIpLCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6XCIoJHNlbGYsIGNoYXJzPU5vbmUsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgb2YgdGhlIHN0cmluZyB3aXRoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgcmVtb3ZlLlxcblxcbklmIGNoYXJzIGlzIGdpdmVuIGFuZCBub3QgTm9uZSwgcmVtb3ZlIGNoYXJhY3RlcnMgaW4gY2hhcnMgaW5zdGVhZC5cIn0sc3dhcGNhc2U6eyRtZXRoKCl7Y29uc3QgcT10aGlzLnYucmVwbGFjZSgvW2Etel0vZ2ksdD0+e2NvbnN0IHc9dC50b0xvd2VyQ2FzZSgpO3JldHVybiB3PT09dD90LnRvVXBwZXJDYXNlKCk6d30pO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIocSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiQ29udmVydCB1cHBlcmNhc2UgY2hhcmFjdGVycyB0byBsb3dlcmNhc2UgYW5kIGxvd2VyY2FzZSBjaGFyYWN0ZXJzIHRvIHVwcGVyY2FzZS5cIn0sXG51cHBlcjp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi50b1VwcGVyQ2FzZSgpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IG9mIHRoZSBzdHJpbmcgY29udmVydGVkIHRvIHVwcGVyY2FzZS5cIn0sc3RhcnRzd2l0aDp7JG1ldGg6YShcInN0YXJ0c3dpdGhcIiwocSx0KT0+MD09PXEuaW5kZXhPZih0KSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLnN0YXJ0c3dpdGgocHJlZml4Wywgc3RhcnRbLCBlbmRdXSkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIFMgc3RhcnRzIHdpdGggdGhlIHNwZWNpZmllZCBwcmVmaXgsIEZhbHNlIG90aGVyd2lzZS5cXG5XaXRoIG9wdGlvbmFsIHN0YXJ0LCB0ZXN0IFMgYmVnaW5uaW5nIGF0IHRoYXQgcG9zaXRpb24uXFxuV2l0aCBvcHRpb25hbCBlbmQsIHN0b3AgY29tcGFyaW5nIFMgYXQgdGhhdCBwb3NpdGlvbi5cXG5wcmVmaXggY2FuIGFsc28gYmUgYSB0dXBsZSBvZiBzdHJpbmdzIHRvIHRyeS5cIn0sXG5lbmRzd2l0aDp7JG1ldGg6YShcImVuZHN3aXRoXCIsKHEsdCk9Pi0xIT09cS5pbmRleE9mKHQscS5sZW5ndGgtdC5sZW5ndGgpKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlMuZW5kc3dpdGgoc3VmZml4Wywgc3RhcnRbLCBlbmRdXSkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIFMgZW5kcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3VmZml4LCBGYWxzZSBvdGhlcndpc2UuXFxuV2l0aCBvcHRpb25hbCBzdGFydCwgdGVzdCBTIGJlZ2lubmluZyBhdCB0aGF0IHBvc2l0aW9uLlxcbldpdGggb3B0aW9uYWwgZW5kLCBzdG9wIGNvbXBhcmluZyBTIGF0IHRoYXQgcG9zaXRpb24uXFxuc3VmZml4IGNhbiBhbHNvIGJlIGEgdHVwbGUgb2Ygc3RyaW5ncyB0byB0cnkuXCJ9LGlzYXNjaWk6eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3QodGhpcy52KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIixcbiRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSBBU0NJSSwgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkFTQ0lJIGNoYXJhY3RlcnMgaGF2ZSBjb2RlIHBvaW50cyBpbiB0aGUgcmFuZ2UgVSswMDAwLVUrMDA3Ri5cXG5FbXB0eSBzdHJpbmcgaXMgQVNDSUkgdG9vLlwifSxpc2xvd2VyOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudi5sZW5ndGgmJi9bYS16XS8udGVzdCh0aGlzLnYpJiYhL1tBLVpdLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBsb3dlcmNhc2Ugc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgbG93ZXJjYXNlIGlmIGFsbCBjYXNlZCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIGxvd2VyY2FzZSBhbmRcXG50aGVyZSBpcyBhdCBsZWFzdCBvbmUgY2FzZWQgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuXCJ9LFxuaXN1cHBlcjp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0aGlzLnYubGVuZ3RoJiYhL1thLXpdLy50ZXN0KHRoaXMudikmJi9bQS1aXS8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGFuIHVwcGVyY2FzZSBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyB1cHBlcmNhc2UgaWYgYWxsIGNhc2VkIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcmUgdXBwZXJjYXNlIGFuZFxcbnRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjYXNlZCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0saXN0aXRsZTp7JG1ldGg6ZnVuY3Rpb24oKXtjb25zdCBxPXRoaXMudjtsZXQgdD0hMSx3PSExLEM7Zm9yKGxldCBEPTA7RDxxLmxlbmd0aDtEKyspaWYoQz1xLmNoYXJBdChEKSwhL1thLXpdLy50ZXN0KEMpJiYvW0EtWl0vLnRlc3QoQykpe2lmKHcpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7XG50PXc9ITB9ZWxzZSBpZigvW2Etel0vLnRlc3QoQykmJiEvW0EtWl0vLnRlc3QoQykpe2lmKCF3KXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO3Q9ITB9ZWxzZSB3PSExO3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHQpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSB0aXRsZS1jYXNlZCBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5JbiBhIHRpdGxlLWNhc2VkIHN0cmluZywgdXBwZXItIGFuZCB0aXRsZS1jYXNlIGNoYXJhY3RlcnMgbWF5IG9ubHlcXG5mb2xsb3cgdW5jYXNlZCBjaGFyYWN0ZXJzIGFuZCBsb3dlcmNhc2UgY2hhcmFjdGVycyBvbmx5IGNhc2VkIG9uZXMuXCJ9LGlzc3BhY2U6eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woL15cXHMrJC8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLFxuJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSB3aGl0ZXNwYWNlIHN0cmluZywgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkEgc3RyaW5nIGlzIHdoaXRlc3BhY2UgaWYgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcmUgd2hpdGVzcGFjZSBhbmQgdGhlcmVcXG5pcyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuXCJ9LGlzZGlnaXQ6eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woL15cXGQrJC8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgZGlnaXQgc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgYSBkaWdpdCBzdHJpbmcgaWYgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcmUgZGlnaXRzIGFuZCB0aGVyZVxcbmlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0sXG5pc251bWVyaWM6eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2wodGhpcy52Lmxlbmd0aCYmIS9bXjAtOV0vLnRlc3QodGhpcy52KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIG51bWVyaWMgc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgbnVtZXJpYyBpZiBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSBudW1lcmljIGFuZCB0aGVyZSBpcyBhdFxcbmxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0saXNhbHBoYTp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0aGlzLnYubGVuZ3RoJiYhL1teYS16QS1aXS8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGFuIGFscGhhYmV0aWMgc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgYWxwaGFiZXRpYyBpZiBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSBhbHBoYWJldGljIGFuZCB0aGVyZVxcbmlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0sXG5pc2FsbnVtOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudi5sZW5ndGgmJiEvW15hLXpBLVowLTldLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYW4gYWxwaGEtbnVtZXJpYyBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyBhbHBoYS1udW1lcmljIGlmIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIGFscGhhLW51bWVyaWMgYW5kXFxudGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxpc2lkZW50aWZpZXI6eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGlzSWRlbnRpZmllcigpP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzonUmV0dXJuIFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFB5dGhvbiBpZGVudGlmaWVyLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuVXNlIGtleXdvcmQuaXNrZXl3b3JkKCkgdG8gdGVzdCBmb3IgcmVzZXJ2ZWQgaWRlbnRpZmllcnMgc3VjaCBhcyBcImRlZlwiIGFuZFxcblwiY2xhc3NcIi4nfSxcbnpmaWxsOnskbWV0aDpmdW5jdGlvbihxKXtxPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChxLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7bGV0IHQ9XCJcIjtxLT10aGlzLnYubGVuZ3RoO2NvbnN0IHc9XCIrXCI9PT10aGlzLnZbMF18fFwiLVwiPT09dGhpcy52WzBdPzE6MDtmb3IobGV0IEM9MDtDPHE7QysrKXQrPVwiMFwiO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnN1YnN0cigwLHcpK3QrdGhpcy52LnN1YnN0cih3KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgd2lkdGgsIC8pXCIsJGRvYzpcIlBhZCBhIG51bWVyaWMgc3RyaW5nIHdpdGggemVyb3Mgb24gdGhlIGxlZnQsIHRvIGZpbGwgYSBmaWVsZCBvZiB0aGUgZ2l2ZW4gd2lkdGguXFxuXFxuVGhlIHN0cmluZyBpcyBuZXZlciB0cnVuY2F0ZWQuXCJ9LGZvcm1hdDp7JG1ldGg6U2suZm9ybWF0dGluZy5mb3JtYXQsJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5mb3JtYXQoKmFyZ3MsICoqa3dhcmdzKSAtPiBzdHJcXG5cXG5SZXR1cm4gYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiBTLCB1c2luZyBzdWJzdGl0dXRpb25zIGZyb20gYXJncyBhbmQga3dhcmdzLlxcblRoZSBzdWJzdGl0dXRpb25zIGFyZSBpZGVudGlmaWVkIGJ5IGJyYWNlcyAoJ3snIGFuZCAnfScpLlwifSxcbl9fZm9ybWF0X186eyRtZXRoOlNrLmZvcm1hdHRpbmcuZm9ybWF0U3RyaW5nLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgZm9ybWF0X3NwZWMsIC8pXCIsJGRvYzpcIlJldHVybiBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcgYXMgZGVzY3JpYmVkIGJ5IGZvcm1hdF9zcGVjLlwifSxfX2dldG5ld2FyZ3NfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUobmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOm51bGx9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uc3RyXCIsU2suYnVpbHRpbi5zdHIpO3ZhciBuPS9eW0EtWmEtejAtOV0rJC8sZD0vKFsuKis/PXxcXFxcXFwvKClcXFtcXF1cXHtcXH1eJF0pL2csbD0vXltcXHNcXHhhMF0rLztTay5idWlsdGluLnN0ci4kcHkyZGVjb2RlPW5ldyBTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yKFNrLmJ1aWx0aW4uc3RyLHskbmFtZTpcImRlY29kZVwiLFxuJG1ldGgocSx0KXtjb25zdCB3PW5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudik7cmV0dXJuIFNrLmJ1aWx0aW4uYnl0ZXMuJGRlY29kZS5jYWxsKHcscSx0KX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wiZW5jb2RpbmdcIixcImVycm9yc1wiXX19KTt2YXIgcj1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJzdHJfaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocSl7dGhpcy4kaW5kZXg9MDtxLiRoYXNBc3RyYWxDb2RlUG9pbnRzKCk/KHRoaXMuJHNlcT1xLmNvZGVwb2ludHMsdGhpcy50cCRpdGVybmV4dD0oKT0+e2NvbnN0IHQ9dGhpcy4kc2VxW3RoaXMuJGluZGV4XTtpZih2b2lkIDAhPT10KXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIocS52LnN1YnN0cmluZyh0LHRoaXMuJHNlcVsrK3RoaXMuJGluZGV4XSkpfSk6KHRoaXMuJHNlcT1xLnYsdGhpcy50cCRpdGVybmV4dD0oKT0+e2NvbnN0IHQ9dGhpcy4kc2VxW3RoaXMuJGluZGV4KytdO2lmKHZvaWQgMCE9PXQpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0KX0pfSxcbml0ZXJuZXh0KCl7cmV0dXJuIHRoaXMudHAkaXRlcm5leHQoKX0sbWV0aG9kczp7X19sZW5ndGhfaGludF9fOlNrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWZ9LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pLHY9e2Fic3RyYWN0OiEwLGFzOiEwLGJvb2xlYW46ITAsYnJlYWs6ITAsYnl0ZTohMCxjYXNlOiEwLGNhdGNoOiEwLGNoYXI6ITAsY2xhc3M6ITAsY29udGludWU6ITAsY29uc3Q6ITAsZGVidWdnZXI6ITAsZGVmYXVsdDohMCxkZWxldGU6ITAsZG86ITAsZG91YmxlOiEwLGVsc2U6ITAsZW51bTohMCxleHBvcnQ6ITAsZXh0ZW5kczohMCxmYWxzZTohMCxmaW5hbDohMCxmaW5hbGx5OiEwLGZsb2F0OiEwLGZvcjohMCxmdW5jdGlvbjohMCxnb3RvOiEwLGlmOiEwLGltcGxlbWVudHM6ITAsaW1wb3J0OiEwLGluOiEwLGluc3RhbmNlb2Y6ITAsaW50OiEwLGludGVyZmFjZTohMCxpczohMCxsb25nOiEwLG5hbWVzcGFjZTohMCxuYXRpdmU6ITAsXG5uZXc6ITAsbnVsbDohMCxwYWNrYWdlOiEwLHByaXZhdGU6ITAscHJvdGVjdGVkOiEwLHB1YmxpYzohMCxyZXR1cm46ITAsc2hvcnQ6ITAsc3RhdGljOiEwLHN1cGVyOiEwLHN3aXRjaDohMCxzeW5jaHJvbml6ZWQ6ITAsdGhpczohMCx0aHJvdzohMCx0aHJvd3M6ITAsdHJhbnNpZW50OiEwLHRydWU6ITAsdHJ5OiEwLHR5cGVvZjohMCx1c2U6ITAsdmFyOiEwLHZvaWQ6ITAsdm9sYXRpbGU6ITAsd2hpbGU6ITAsd2l0aDohMCxjb25zdHJ1Y3RvcjohMCxfX2RlZmluZUdldHRlcl9fOiEwLF9fZGVmaW5lU2V0dGVyX186ITAsYXBwbHk6ITAsYXJndW1lbnRzOiEwLGNhbGw6ITAsY2FsbGVyOiEwLGV2YWw6ITAsaGFzT3duUHJvcGVydHk6ITAsaXNQcm90b3R5cGVPZjohMCxfX2xvb2t1cEdldHRlcl9fOiEwLF9fbG9va3VwU2V0dGVyX186ITAsX19ub1N1Y2hNZXRob2RfXzohMCxwcm9wZXJ0eUlzRW51bWVyYWJsZTohMCxwcm90b3R5cGU6ITAsdG9Tb3VyY2U6ITAsdG9Mb2NhbGVTdHJpbmc6ITAsXG50b1N0cmluZzohMCx1bndhdGNoOiEwLHZhbHVlT2Y6ITAsd2F0Y2g6ITAsbGVuZ3RoOiEwLG5hbWU6ITB9O1NrLmJ1aWx0aW4uc3RyLnJlc2VydmVkV29yZHNfPXZ9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi5mdW5jPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJmdW5jdGlvblwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihiLGYsZSxnKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mdW5jLFwiYnVpbHRpbiBmdW5jIHNob3VsZCBiZSBjYWxsZWQgYXMgYSBjbGFzcyB3aXRoIGBuZXdgXCIpO3RoaXMuZnVuY19jb2RlPWI7dGhpcy5mdW5jX2dsb2JhbHM9Znx8bnVsbDt0aGlzLiRuYW1lPWIuY29fbmFtZSYmYi5jb19uYW1lLnZ8fGIubmFtZXx8XCI8bmF0aXZlIEpTPlwiO3RoaXMuJGQ9U2suYnVpbHRpbi5kaWN0P25ldyBTay5idWlsdGluLmRpY3Q6dm9pZCAwO3RoaXMuJGRvYz1iLmNvX2RvY3N0cmluZ3x8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMuJG1vZHVsZT1cblNrLmdsb2JhbHMmJlNrLmdsb2JhbHMuX19uYW1lX198fFNrLmJ1aWx0aW4ubm9uZS5ub25lJDt0aGlzLiRxdWFsbmFtZT1iLmNvX3F1YWxuYW1lJiZiLmNvX3F1YWxuYW1lLnZ8fHRoaXMuJG5hbWU7aWYodm9pZCAwIT09Zylmb3IobGV0IGsgaW4gZyllW2tdPWdba107dGhpcy5mdW5jX2Nsb3N1cmU9ZTt0aGlzLmZ1bmNfYW5ub3RhdGlvbnM9bnVsbDt0aGlzLiRtZW1vaXNlRmxhZ3MoKTt0aGlzLm1lbW9pc2VkPWIuY29fZmFzdGNhbGx8fG51bGw7dGhpcy50cCRjYWxsPWIuY29fZmFzdGNhbGw/Yi5iaW5kKHRoaXMpOlNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUudHAkY2FsbC5iaW5kKHRoaXMpfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkZGVzY3JfZ2V0KGIsZil7cmV0dXJuIG51bGw9PT1iP3RoaXM6bmV3IFNrLmJ1aWx0aW4ubWV0aG9kKHRoaXMsYil9LCRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxmdW5jdGlvbiBcIit0aGlzLiRxdWFsbmFtZStcblwiPlwiKX0sdHAkY2FsbChiLGYpe3RoaXMubWVtb2lzZWR8fCh0aGlzLiRtZW1vaXNlRmxhZ3MoKSx0aGlzLm1lbW9pc2VkPSEwKTtpZih2b2lkIDA9PT10aGlzLmNvX2FyZ2NvdW50JiZ2b2lkIDA9PT10aGlzLmNvX3Zhcm5hbWVzJiYhdGhpcy5jb19rd2FyZ3MmJiF0aGlzLmZ1bmNfY2xvc3VyZSl7aWYoZiYmMCE9PWYubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgdGFrZXMgbm8ga2V5d29yZCBhcmd1bWVudHNcIik7cmV0dXJuIHRoaXMuZnVuY19jb2RlLmFwcGx5KHRoaXMuZnVuY19nbG9iYWxzLGIpfWI9dGhpcy4kcmVzb2x2ZUFyZ3MoYixmKTt0aGlzLmZ1bmNfY2xvc3VyZSYmYi5wdXNoKHRoaXMuZnVuY19jbG9zdXJlKTtyZXR1cm4gdGhpcy5mdW5jX2NvZGUuYXBwbHkodGhpcy5mdW5jX2dsb2JhbHMsYil9fSxnZXRzZXRzOntfX25hbWVfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kbmFtZSl9LCRzZXQoYil7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19uYW1lX18gbXVzdCBiZSBzZXQgdG8gYSBzdHJpbmcgb2JqZWN0XCIpO1xudGhpcy4kbmFtZT1iLiRqc3N0cigpfX0sX19xdWFsbmFtZV9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLiRxdWFsbmFtZSl9LCRzZXQoYil7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19xdWFsbmFtZV9fIG11c3QgYmUgc2V0IHRvIGEgc3RyaW5nIG9iamVjdFwiKTt0aGlzLiRxdWFsbmFtZT1iLiRqc3N0cigpfX0sX19kaWN0X186U2suZ2VuZXJpYy5nZXRTZXREaWN0LF9fYW5ub3RhdGlvbnNfXzp7JGdldCgpe251bGw9PT10aGlzLmZ1bmNfYW5ub3RhdGlvbnM/dGhpcy5mdW5jX2Fubm90YXRpb25zPW5ldyBTay5idWlsdGluLmRpY3QoW10pOkFycmF5LmlzQXJyYXkodGhpcy5mdW5jX2Fubm90YXRpb25zKSYmKHRoaXMuZnVuY19hbm5vdGF0aW9ucz1Tay5hYnN0ci5rZXl3b3JkQXJyYXlUb1B5RGljdCh0aGlzLmZ1bmNfYW5ub3RhdGlvbnMpKTtyZXR1cm4gdGhpcy5mdW5jX2Fubm90YXRpb25zfSxcbiRzZXQoYil7aWYodm9pZCAwPT09Ynx8U2suYnVpbHRpbi5jaGVja05vbmUoYikpdGhpcy5mdW5jX2Fubm90YXRpb25zPW5ldyBTay5idWlsdGluLmRpY3QoW10pO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCl0aGlzLmZ1bmNfYW5ub3RhdGlvbnM9YjtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fYW5ub3RhdGlvbnNfXyBtdXN0IGJlIHNldCB0byBhIGRpY3Qgb2JqZWN0XCIpO319LF9fZGVmYXVsdHNfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLiRkZWZhdWx0cyl9fSxfX2RvY19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuJGRvY30sJHNldChiKXt0aGlzLiRkb2M9Ynx8U2suYnVpbHRpbi5ub25lLm5vbmUkfX0sX19tb2R1bGVfXzp7JGdldCgpe3JldHVybiB0aGlzLiRtb2R1bGV9LCRzZXQoYil7dGhpcy4kbW9kdWxlPWJ8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19fSxwcm90bzp7JG1lbW9pc2VGbGFncygpe3RoaXMuY29fdmFybmFtZXM9XG50aGlzLmZ1bmNfY29kZS5jb192YXJuYW1lczt0aGlzLmNvX2FyZ2NvdW50PXRoaXMuZnVuY19jb2RlLmNvX2FyZ2NvdW50O3ZvaWQgMD09PXRoaXMuY29fYXJnY291bnQmJnRoaXMuY29fdmFybmFtZXMmJih0aGlzLmNvX2FyZ2NvdW50PXRoaXMuY29fdmFybmFtZXMubGVuZ3RoKTt0aGlzLmNvX2t3b25seWFyZ2NvdW50PXRoaXMuZnVuY19jb2RlLmNvX2t3b25seWFyZ2NvdW50fHwwO3RoaXMuY29fdmFyYXJncz10aGlzLmZ1bmNfY29kZS5jb192YXJhcmdzO3RoaXMuY29fa3dhcmdzPXRoaXMuZnVuY19jb2RlLmNvX2t3YXJnczt0aGlzLiRkZWZhdWx0cz10aGlzLmZ1bmNfY29kZS4kZGVmYXVsdHN8fFtdO3RoaXMuJGt3ZGVmcz10aGlzLmZ1bmNfY29kZS4ka3dkZWZzfHxbXX0sJHJlc29sdmVBcmdzOmZ1bmN0aW9uKGIsZil7dmFyIGU9dGhpcy5jb19hcmdjb3VudDt2b2lkIDA9PT1lJiYoZT10aGlzLmNvX3Zhcm5hbWVzP3RoaXMuY29fdmFybmFtZXMubGVuZ3RoOmIubGVuZ3RoKTtcbnZhciBnPXRoaXMuY29fdmFybmFtZXN8fFtdLGs9dGhpcy5jb19rd29ubHlhcmdjb3VudHx8MDtsZXQgcD1lK2s7aWYoISgwIT09a3x8dGhpcy5jb19rd2FyZ3N8fGYmJjAhPT1mLmxlbmd0aHx8dGhpcy5jb192YXJhcmdzKSl7aWYoYi5sZW5ndGg9PWUpcmV0dXJuIGI7aWYoMD09PWIubGVuZ3RoJiZ0aGlzLiRkZWZhdWx0cyYmdGhpcy4kZGVmYXVsdHMubGVuZ3RoPT09ZSl7Zm9yKGc9MDtnIT10aGlzLiRkZWZhdWx0cy5sZW5ndGg7ZysrKWJbZ109dGhpcy4kZGVmYXVsdHNbZ107cmV0dXJuIGJ9fWxldCBoO3RoaXMuY29fa3dhcmdzJiYoaD1bXSk7dmFyIGE9Yi5sZW5ndGg7bGV0IGM9Yi5sZW5ndGg8PWU/YjpiLnNsaWNlKDAsZSk7aWYodGhpcy5jb192YXJhcmdzKWI9Yi5sZW5ndGg+Yy5sZW5ndGg/Yi5zbGljZShjLmxlbmd0aCk6W10sY1twXT1uZXcgU2suYnVpbHRpbi50dXBsZShiKTtlbHNlIGlmKGE+ZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYCR7dGhpcy4kbmFtZX1cIigpIHRha2VzICR7ZX0gcG9zaXRpb25hbCAkezE9PVxuZT9cImFyZ3VtZW50XCI6XCJhcmd1bWVudHNcIn0gYnV0ICR7YX0gJHsxPT1hP1wid2FzXCI6XCJ3ZXJlXCJ9IGdpdmVuYCk7aWYoZil7aWYodGhpcy5mdW5jX2NvZGUubm9fa3cpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHRoaXMuJG5hbWUrXCIoKSB0YWtlcyBubyBrZXl3b3JkIGFyZ3VtZW50c1wiKTtmb3IoYj0wO2I8Zi5sZW5ndGg7Yis9Mil7YT1mW2JdO3ZhciBtPWZbYisxXSxuPWcuaW5kZXhPZihhKTtpZigwPD1uKXtpZih2b2lkIDAhPT1jW25dKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgZ290IG11bHRpcGxlIHZhbHVlcyBmb3IgYXJndW1lbnQgJ1wiK2ErXCInXCIpO2Nbbl09bX1lbHNlIGlmKGgpaC5wdXNoKG5ldyBTay5idWlsdGluLnN0cihhKSxtKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgZ290IGFuIHVuZXhwZWN0ZWQga2V5d29yZCBhcmd1bWVudCAnXCIrYStcIidcIik7fX1mPXRoaXMuJGRlZmF1bHRzfHxcbltdO2I9MDthPVtdO209ITE7Zm9yKG49ZS1mLmxlbmd0aDtiPG47YisrKXZvaWQgMD09PWNbYl0mJihhLnB1c2goZ1tiXSksdm9pZCAwPT09Z1tiXSYmKG09ITApKTtpZigwIT1hLmxlbmd0aCYmKHRoaXMuY29fYXJnY291bnR8fHRoaXMuY29fdmFybmFtZXMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgbWlzc2luZyBcIithLmxlbmd0aCtcIiByZXF1aXJlZCBhcmd1bWVudFwiKygxPT1hLmxlbmd0aD9cIlwiOlwic1wiKSsobT9cIlwiOlwiOiBcIithLm1hcChkPT5cIidcIitkK1wiJ1wiKS5qb2luKFwiLCBcIikpKTtmb3IoO2I8ZTtiKyspdm9pZCAwPT09Y1tiXSYmKGNbYl09ZltiLW5dKTtpZigwPGspe2s9W107Zj10aGlzLiRrd2RlZnM7Zm9yKGI9ZTtiPHA7YisrKXZvaWQgMD09PWNbYl0mJih2b2lkIDAhPT1mW2ItZV0/Y1tiXT1mW2ItZV06ay5wdXNoKGdbYl0pKTtpZigwIT09ay5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHRoaXMuJG5hbWUrXCIoKSBtaXNzaW5nIFwiK1xuay5sZW5ndGgrXCIgcmVxdWlyZWQga2V5d29yZCBhcmd1bWVudFwiKygxPT1rLmxlbmd0aD9cIlwiOlwic1wiKStcIjogXCIray5qb2luKFwiLCBcIikpO31pZih0aGlzLmZ1bmNfY2xvc3VyZSYmZylmb3IoZT1jLmxlbmd0aDtlPGcubGVuZ3RoO2UrKyljLnB1c2godm9pZCAwKTtoJiZjLnVuc2hpZnQoaCk7cmV0dXJuIGN9fX0pfSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4uYXNudW0kPWZ1bmN0aW9uKGcpe3JldHVybiB2b2lkIDA9PT1nfHxudWxsPT09Z3x8XCJudW1iZXJcIj09PXR5cGVvZiBnP2c6ZyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50Xz9cIm51bWJlclwiPT09dHlwZW9mIGcudj9nLnY6Zy52LnRvU3RyaW5nKCk6ZyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfP2cudjpnPT09U2suYnVpbHRpbi5ub25lLm5vbmUkP251bGw6Z307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5hc251bSRcIixTay5idWlsdGluLmFzbnVtJCk7U2suYnVpbHRpbi5hc3NrJD1mdW5jdGlvbihnKXtyZXR1cm4gMD09PVxuZyUxP25ldyBTay5idWlsdGluLmludF8oZyk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGcpfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmFzc2skXCIsU2suYnVpbHRpbi5hc3NrJCk7U2suYnVpbHRpbi5hc251bSRub2Zsb2F0PWZ1bmN0aW9uKGcpe2lmKHZvaWQgMD09PWd8fG51bGw9PT1nKXJldHVybiBnO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZylnPWcudG9TdHJpbmcoKTtlbHNlIGlmKGcgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pZz1nLnYudG9TdHJpbmcoKTtlbHNlIGlmKGcgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XylnPWcudi50b1N0cmluZygpO2Vsc2V7aWYoZz09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJClyZXR1cm4gbnVsbDtyZXR1cm59aWYoMD5nLmluZGV4T2YoXCIuXCIpJiYwPmcuaW5kZXhPZihcImVcIikmJjA+Zy5pbmRleE9mKFwiRVwiKSlyZXR1cm4gZzt2YXIgaz0wO2lmKDA8PWcuaW5kZXhPZihcImVcIikpe3ZhciBwPWcuc3Vic3RyKDAsZy5pbmRleE9mKFwiZVwiKSk7XG5rPWcuc3Vic3RyKGcuaW5kZXhPZihcImVcIikrMSl9ZWxzZSAwPD1nLmluZGV4T2YoXCJFXCIpPyhwPWcuc3Vic3RyKDAsZy5pbmRleE9mKFwiZVwiKSksaz1nLnN1YnN0cihnLmluZGV4T2YoXCJFXCIpKzEpKTpwPWc7az1wYXJzZUludChrLDEwKTtnPXAuaW5kZXhPZihcIi5cIik7aWYoMD5nKXtpZigwPD1rKXtmb3IoOzA8ay0tOylwKz1cIjBcIjtyZXR1cm4gcH1yZXR1cm4gcC5sZW5ndGg+LWs/cC5zdWJzdHIoMCxwLmxlbmd0aCtrKTowfXA9MD09PWc/cC5zdWJzdHIoMSk6ZzxwLmxlbmd0aD9wLnN1YnN0cigwLGcpK3Auc3Vic3RyKGcrMSk6cC5zdWJzdHIoMCxnKTtmb3IoZys9aztnPnAubGVuZ3RoOylwKz1cIjBcIjtyZXR1cm4gcD0wPj1nPzA6cC5zdWJzdHIoMCxnKX07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5hc251bSRub2Zsb2F0XCIsU2suYnVpbHRpbi5hc251bSRub2Zsb2F0KTtTay5idWlsdGluLnJvdW5kPWZ1bmN0aW9uKGcsayl7aWYodm9pZCAwPT09Zyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIGZsb2F0IGlzIHJlcXVpcmVkXCIpO1xuaWYoIVNrLl9fZnV0dXJlX18uZHVuZGVyX3JvdW5kKXtpZighU2suYnVpbHRpbi5jaGVja051bWJlcihnKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIGZsb2F0IGlzIHJlcXVpcmVkXCIpO2lmKGcucm91bmQkKXJldHVybiBnLnJvdW5kJChrKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihTay5hYnN0ci50eXBlTmFtZShnKStcIiBpbnN0YW5jZSBoYXMgbm8gYXR0cmlidXRlICdfX2Zsb2F0X18nXCIpO31pZih2b2lkIDAhPT1rJiYhU2suYnVpbHRpbi5jaGVja05vbmUoaykmJiFTay5taXNjZXZhbC5pc0luZGV4KGspKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShrKStcIicgb2JqZWN0IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpbmRleFwiKTtnPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoZyxTay5idWlsdGluLnN0ci4kcm91bmQpO2lmKHZvaWQgMCE9PWcpcmV0dXJuIHZvaWQgMCE9PWs/U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGcsXG5ba10pOlNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShnLFtdKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIGZsb2F0IGlzIHJlcXVpcmVkXCIpO307U2suYnVpbHRpbi5sZW49ZnVuY3Rpb24oZyl7aWYoZy5zcSRsZW5ndGgpZz1nLnNxJGxlbmd0aCghMCk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvYmplY3Qgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoZykrXCInIGhhcyBubyBsZW4oKVwiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZyxrPT5uZXcgU2suYnVpbHRpbi5pbnRfKGspKX07U2suYnVpbHRpbi5taW49ZnVuY3Rpb24oZyxrKXtsZXQgcDtjb25zdCBoPWcubGVuZ3RoO2lmKCFoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm1pbiBleHBlY3RlZCAxIGFyZ3VtZW50LCBnb3QgMFwiKTtjb25zdCBbYSxjXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcIm1pblwiLFtcImRlZmF1bHRcIixcImtleVwiXSxbXSxrLFtudWxsLFxuU2suYnVpbHRpbi5ub25lLm5vbmUkXSk7aWYoMTxoJiZudWxsIT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBhIGRlZmF1bHQgZm9yIG1pbigpIHdpdGggbXVsdGlwbGUgcG9zaXRpb25hbCBhcmd1bWVudHNcIik7cD0xPT1oP1NrLmFic3RyLml0ZXIoZ1swXSk6U2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi50dXBsZShnKSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGMpJiYhU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShjKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTtsZXQgbTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4ocC50cCRpdGVybmV4dCghMCksbj0+e209bjtpZih2b2lkIDAhPT1tKXJldHVybiBTay5idWlsdGluLmNoZWNrTm9uZShjKT9Tay5taXNjZXZhbC5pdGVyRm9yKHAsZD0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChkLFxubSxcIkx0XCIpJiYobT1kKX0pOlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShjLFttXSksZD0+U2subWlzY2V2YWwuaXRlckZvcihwLGw9PlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShjLFtsXSkscj0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChyLGQsXCJMdFwiKSYmKG09bCxkPXIpfSkpKX0sKCk9PntpZih2b2lkIDA9PT1tKXtpZihudWxsPT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibWluKCkgYXJnIGlzIGFuIGVtcHR5IHNlcXVlbmNlXCIpO209YX1yZXR1cm4gbX0pfTtTay5idWlsdGluLm1heD1mdW5jdGlvbihnLGspe2xldCBwO2NvbnN0IGg9Zy5sZW5ndGg7aWYoIWgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibWF4IGV4cGVjdGVkIDEgYXJndW1lbnQsIGdvdCAwXCIpO2NvbnN0IFthLGNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwibWF4XCIsXG5bXCJkZWZhdWx0XCIsXCJrZXlcIl0sW10sayxbbnVsbCxTay5idWlsdGluLm5vbmUubm9uZSRdKTtpZigxPGgmJm51bGwhPT1hKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGEgZGVmYXVsdCBmb3IgbWF4KCkgd2l0aCBtdWx0aXBsZSBwb3NpdGlvbmFsIGFyZ3VtZW50c1wiKTtwPTE9PT1oP1NrLmFic3RyLml0ZXIoZ1swXSk6U2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi50dXBsZShnKSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGMpJiYhU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShjKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTtsZXQgbTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4ocC50cCRpdGVybmV4dCghMCksbj0+e209bjtpZih2b2lkIDAhPT1tKXJldHVybiBTay5idWlsdGluLmNoZWNrTm9uZShjKT9Tay5taXNjZXZhbC5pdGVyRm9yKHAsXG5kPT57U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGQsbSxcIkd0XCIpJiYobT1kKX0pOlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShjLFttXSksZD0+U2subWlzY2V2YWwuaXRlckZvcihwLGw9PlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShjLFtsXSkscj0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChyLGQsXCJHdFwiKSYmKG09bCxkPXIpfSkpKX0sKCk9PntpZih2b2lkIDA9PT1tKXtpZihudWxsPT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibWF4KCkgYXJnIGlzIGFuIGVtcHR5IHNlcXVlbmNlXCIpO209YX1yZXR1cm4gbX0pfTtTay5idWlsdGluLm1pbi5jb19mYXN0Y2FsbD1Tay5idWlsdGluLm1heC5jb19mYXN0Y2FsbD0xO1NrLmJ1aWx0aW4uYW55PWZ1bmN0aW9uKGcpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoZyksXG5mdW5jdGlvbihrKXtpZihTay5taXNjZXZhbC5pc1RydWUoaykpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayhTay5idWlsdGluLmJvb2wudHJ1ZSQpfSksaz0+a3x8U2suYnVpbHRpbi5ib29sLmZhbHNlJCl9O1NrLmJ1aWx0aW4uYWxsPWZ1bmN0aW9uKGcpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoZyksZnVuY3Rpb24oayl7aWYoIVNrLm1pc2NldmFsLmlzVHJ1ZShrKSlyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrKFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQpfSksaz0+a3x8U2suYnVpbHRpbi5ib29sLnRydWUkKX07U2suYnVpbHRpbi5zdW09ZnVuY3Rpb24oZyxrKXtmdW5jdGlvbiBwKCl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoYyxuPT57aWYobi5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uaW50XyltPW0ubmIkYWRkKG4pO2Vsc2V7aWYobi5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRfKXJldHVybiBtPVxubS5uYiRmbG9hdCgpLm5iJGFkZChuKSxuZXcgU2subWlzY2V2YWwuQnJlYWsoXCJmbG9hdFwiKTttPVNrLmFic3RyLm51bWJlckJpbk9wKG0sbixcIkFkZFwiKTtyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrKFwic2xvd1wiKX19KX1mdW5jdGlvbiBoKCl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoYyxuPT57aWYobi5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRffHxuLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5pbnRfKW09bS5uYiRhZGQobik7ZWxzZSByZXR1cm4gbT1Tay5hYnN0ci5udW1iZXJCaW5PcChtLG4sXCJBZGRcIiksbmV3IFNrLm1pc2NldmFsLkJyZWFrKFwic2xvd1wiKX0pfWZ1bmN0aW9uIGEoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihjLG49PnttPVNrLmFic3RyLm51bWJlckJpbk9wKG0sbixcIkFkZFwiKX0pfWNvbnN0IGM9U2suYWJzdHIuaXRlcihnKTtpZih2b2lkIDA9PT1rKXZhciBtPW5ldyBTay5idWlsdGluLmludF8oMCk7ZWxzZXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGspKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN1bSgpIGNhbid0IHN1bSBzdHJpbmdzIFt1c2UgJycuam9pbihzZXEpIGluc3RlYWRdXCIpO1xubT1rfWc9dm9pZCAwPT09a3x8ay5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uaW50Xz9wKCk6ay5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRfP1wiZmxvYXRcIjpcInNsb3dcIjtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZyxuPT5cImZsb2F0XCI9PT1uP2goKTpuLG49PntpZihcInNsb3dcIj09PW4pcmV0dXJuIGEoKX0sKCk9Pm0pfTtTay5idWlsdGluLnppcD1mdW5jdGlvbigpe3ZhciBnLGs7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoW10pO3ZhciBwPVtdO2ZvcihrPTA7azxhcmd1bWVudHMubGVuZ3RoO2srKylpZihTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYXJndW1lbnRzW2tdKSlwLnB1c2goU2suYWJzdHIuaXRlcihhcmd1bWVudHNba10pKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFyZ3VtZW50IFwiK2srXCIgbXVzdCBzdXBwb3J0IGl0ZXJhdGlvblwiKTt2YXIgaD1bXTtmb3IoZz0hMTshZzspe3ZhciBhPVxuW107Zm9yKGs9MDtrPGFyZ3VtZW50cy5sZW5ndGg7aysrKXt2YXIgYz1wW2tdLnRwJGl0ZXJuZXh0KCk7aWYodm9pZCAwPT09Yyl7Zz0hMDticmVha31hLnB1c2goYyl9Z3x8aC5wdXNoKG5ldyBTay5idWlsdGluLnR1cGxlKGEpKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChoKX07U2suYnVpbHRpbi5hYnM9ZnVuY3Rpb24oZyl7aWYoZy5uYiRhYnMpcmV0dXJuIGcubmIkYWJzKCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFkIG9wZXJhbmQgdHlwZSBmb3IgYWJzKCk6ICdcIitTay5hYnN0ci50eXBlTmFtZShnKStcIidcIik7fTtTay5idWlsdGluLmZhYnM9ZnVuY3Rpb24oZyl7cmV0dXJuIFNrLmJ1aWx0aW4uYWJzKGcpfTtTay5idWlsdGluLm9yZD1mdW5jdGlvbihnKXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGcpKXtpZigxIT09Zy52Lmxlbmd0aCYmMSE9PWcuc3EkbGVuZ3RoKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwib3JkKCkgZXhwZWN0ZWQgYSBjaGFyYWN0ZXIsIGJ1dCBzdHJpbmcgb2YgbGVuZ3RoIFwiK1xuZy52Lmxlbmd0aCtcIiBmb3VuZFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhnLnYuY29kZVBvaW50QXQoMCkpfWlmKFNrLmJ1aWx0aW4uY2hlY2tCeXRlcyhnKSl7aWYoMSE9PWcuc3EkbGVuZ3RoKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwib3JkKCkgZXhwZWN0ZWQgYSBjaGFyYWN0ZXIsIGJ1dCBzdHJpbmcgb2YgbGVuZ3RoIFwiK2cudi5sZW5ndGgrXCIgZm91bmRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZy52WzBdKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvcmQoKSBleHBlY3RlZCBhIHN0cmluZyBvZiBsZW5ndGggMSwgYnV0IFwiK1NrLmFic3RyLnR5cGVOYW1lKGcpK1wiIGZvdW5kXCIpO307U2suYnVpbHRpbi5jaHI9ZnVuY3Rpb24oZyl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQoZykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTtnPVNrLmJ1aWx0aW4uYXNudW0kKGcpO2lmKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl7aWYoMD5cbmd8fDExMTQxMTI8PWcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImNocigpIGFyZyBub3QgaW4gcmFuZ2UoMHgxMTAwMDApXCIpO31lbHNlIGlmKDA+Z3x8MjU2PD1nKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjaHIoKSBhcmcgbm90IGluIHJhbmdlKDI1NilcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTdHJpbmcuZnJvbUNvZGVQb2ludChnKSl9O1NrLmJ1aWx0aW4udW5pY2hyPWZ1bmN0aW9uKGcpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXCJ1bmljaHJcIixhcmd1bWVudHMubGVuZ3RoLDEsMSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQoZykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTtnPVNrLmJ1aWx0aW4uYXNudW0kKGcpO3RyeXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFN0cmluZy5mcm9tQ29kZVBvaW50KGcpKX1jYXRjaChrKXtpZihrIGluc3RhbmNlb2YgUmFuZ2VFcnJvcil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKGsubWVzc2FnZSk7XG50aHJvdyBrO319O1NrLmJ1aWx0aW4uaW50MnN0cl89ZnVuY3Rpb24oZyxrLHApe2xldCBoPWcubmIkaW5kZXgoKSxhO2g9XCJudW1iZXJcIj09PXR5cGVvZiBoPyhhPTA+aCk/LWg6aDooYT1KU0JJLmxlc3NUaGFuKGgsSlNCSS5fX1pFUk8pKT9KU0JJLnVuYXJ5TWludXMoaCk6aDtsZXQgYz1oLnRvU3RyaW5nKGspO2M9YT9cIi1cIitwK2M6cCtjOzIhPT1rJiYhU2suX19mdXR1cmVfXy5weXRob24zJiYoZyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nfHxKU0JJLl9faXNCaWdJbnQoaCkpJiYoYys9XCJMXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYyl9O1NrLmJ1aWx0aW4uaGV4PWZ1bmN0aW9uKGcpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGcpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImhleCgpIGFyZ3VtZW50IGNhbid0IGJlIGNvbnZlcnRlZCB0byBoZXhcIik7cmV0dXJuIFNrLmJ1aWx0aW4uaW50MnN0cl8oZywxNixcIjB4XCIpfTtTay5idWlsdGluLm9jdD1mdW5jdGlvbihnKXtpZighU2subWlzY2V2YWwuaXNJbmRleChnKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvY3QoKSBhcmd1bWVudCBjYW4ndCBiZSBjb252ZXJ0ZWQgdG8gaGV4XCIpO1xucmV0dXJuIFNrLl9fZnV0dXJlX18ub2N0YWxfbnVtYmVyX2xpdGVyYWw/U2suYnVpbHRpbi5pbnQyc3RyXyhnLDgsXCIwb1wiKTpTay5idWlsdGluLmludDJzdHJfKGcsOCxcIjBcIil9O1NrLmJ1aWx0aW4uYmluPWZ1bmN0aW9uKGcpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGcpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShnKStcIicgb2JqZWN0IGNhbid0IGJlIGludGVycHJldGVkIGFzIGFuIGluZGV4XCIpO3JldHVybiBTay5idWlsdGluLmludDJzdHJfKGcsMixcIjBiXCIpfTtTay5idWlsdGluLmRpcj1mdW5jdGlvbihnKXtpZih2b2lkIDAhPT1nKXJldHVybiBnPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoZyxTay5idWlsdGluLnN0ci4kZGlyKSxTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZyxbXSksaz0+U2suYnVpbHRpbi5zb3J0ZWQoaykpO3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJza3VscHQgZG9lcyBub3QgeWV0IHN1cHBvcnQgZGlyIHdpdGggbm8gYXJnc1wiKTtcbn07U2suYnVpbHRpbi5yZXByPWZ1bmN0aW9uKGcpe3JldHVybiBnLiRyKCl9O1NrLmJ1aWx0aW4uYXNjaWk9ZnVuY3Rpb24oZyl7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGcuJHIoKSxrPT57bGV0IHAsaDtmb3IoaD0wO2g8ay52Lmxlbmd0aDtoKyspaWYoMTI3PD1rLnYuY2hhckNvZGVBdChoKSl7cD1rLnYuc3Vic3RyKDAsaCk7YnJlYWt9aWYoIXApcmV0dXJuIGs7Zm9yKDtoPGsudi5sZW5ndGg7aCsrKXt2YXIgYT1rLnYuY2hhckF0KGgpLGM9ay52LmNoYXJDb2RlQXQoaCk7MTI3PGMmJjI1NT49Yz8oYT1jLnRvU3RyaW5nKDE2KSwyPmEubGVuZ3RoJiYoYT1cIjBcIithKSxwKz1cIlxcXFx4XCIrYSk6MTI3PGMmJjU1Mjk2PmN8fDU3MzQ0PD1jP3ArPVwiXFxcXHVcIisoXCIwMDBcIitjLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpOjU1Mjk2PD1jPyhhPWsudi5jb2RlUG9pbnRBdChoKSxoKyssYT1hLnRvU3RyaW5nKDE2KSxjPVwiMDAwMDAwMFwiK2EudG9TdHJpbmcoMTYpLHA9NDxhLmxlbmd0aD9wKyhcIlxcXFxVXCIrXG5jLnNsaWNlKC04KSk6cCsoXCJcXFxcdVwiK2Muc2xpY2UoLTQpKSk6cCs9YX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHApfSl9O1NrLmJ1aWx0aW4ub3Blbj1mdW5jdGlvbihnLGsscCl7dm9pZCAwPT09ayYmKGs9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiclwiKSk7aWYoL1xcKy8udGVzdChrLnYpKXRocm93XCJ0b2RvOyBoYXZlbid0IGltcGxlbWVudGVkIHJlYWQvd3JpdGUgbW9kZVwiO2lmKChcIndcIj09PWsudnx8XCJ3YlwiPT09ay52fHxcImFcIj09PWsudnx8XCJhYlwiPT09ay52KSYmIVNrLm5vbnJlYWRvcGVuKXRocm93XCJ0b2RvOyBoYXZlbid0IGltcGxlbWVudGVkIG5vbi1yZWFkIG9wZW5zXCI7cmV0dXJuIG5ldyBTay5idWlsdGluLmZpbGUoZyxrLHApfTtTay5idWlsdGluLmlzaW5zdGFuY2U9ZnVuY3Rpb24oZyxrKXtpZighKFNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhrKXx8ayBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImlzaW5zdGFuY2UoKSBhcmcgMiBtdXN0IGJlIGEgY2xhc3MsIHR5cGUsIG9yIHR1cGxlIG9mIGNsYXNzZXMgYW5kIHR5cGVzXCIpO1xudmFyIHA9Zy5vYiR0eXBlO2lmKHA9PT1rKXJldHVybiBTay5idWlsdGluLmJvb2wudHJ1ZSQ7aWYoIShrIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkpe2lmKHAuJGlzU3ViVHlwZShrKSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO2c9Zy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRjbGFzcyk7cmV0dXJuIGchPXAmJlNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhnKSYmZy4kaXNTdWJUeXBlKGspP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfWZvcihwPTA7cDxrLnYubGVuZ3RoOysrcClpZihTay5taXNjZXZhbC5pc1RydWUoU2suYnVpbHRpbi5pc2luc3RhbmNlKGcsay52W3BdKSkpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJDtyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJH07U2suYnVpbHRpbi5oYXNoPWZ1bmN0aW9uKGcpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKFNrLmFic3RyLm9iamVjdEhhc2goZykpfTtTay5idWlsdGluLmdldGF0dHI9XG5mdW5jdGlvbihnLGsscCl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoaykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYXR0cmlidXRlIG5hbWUgbXVzdCBiZSBzdHJpbmdcIik7Y29uc3QgaD1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+Zy50cCRnZXRhdHRyKGssITApLGE9PntpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBhO30pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihoLGE9PntpZih2b2lkIDA9PT1hKXtpZih2b2lkIDAhPT1wKXJldHVybiBwO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKGcuc2skYXR0ckVycm9yKCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKGspKTt9cmV0dXJuIGF9KX07U2suYnVpbHRpbi5zZXRhdHRyPWZ1bmN0aW9uKGcsayxwKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhrKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhdHRyaWJ1dGUgbmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcbnJldHVybiBTay5taXNjZXZhbC5jaGFpbihnLnRwJHNldGF0dHIoayxwLCEwKSwoKT0+U2suYnVpbHRpbi5ub25lLm5vbmUkKX07U2suYnVpbHRpbi5yYXdfaW5wdXQ9ZnVuY3Rpb24oZyl7dmFyIGs9Zz9nOlwiXCI7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmltcG9ydE1vZHVsZShcInN5c1wiLCExLCEwKSxmdW5jdGlvbihwKXtyZXR1cm4gU2suaW5wdXRmdW5UYWtlc1Byb21wdD9Tay5idWlsdGluLmZpbGUuJHJlYWRsaW5lKHAuJGQuc3RkaW4sbnVsbCxrKTpTay5taXNjZXZhbC5jaGFpbih2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHAuJGQuc3Rkb3V0LndyaXRlLFtwLiRkLnN0ZG91dCxuZXcgU2suYnVpbHRpbi5zdHIoayldKX0sZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHAuJGQuc3RkaW4ucmVhZGxpbmUsW3AuJGQuc3RkaW5dKX0pfSl9O1NrLmJ1aWx0aW4uaW5wdXQ9XG5Tay5idWlsdGluLnJhd19pbnB1dDtTay5idWlsdGluLmpzZXZhbD1mdW5jdGlvbihnKXtnPVNrLmdsb2JhbC5ldmFsKFNrLmZmaS5yZW1hcFRvSnMoZykpO3JldHVybiBTay5mZmkucmVtYXBUb1B5KGcpfTtTay5idWlsdGluLmpzbWlsbGlzPWZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwianNtaWxsaXMgaXMgZGVwcmVjYXRlZFwiKTtyZXR1cm4obmV3IERhdGUpLnZhbHVlT2YoKX07Y29uc3QgYj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiY29kZVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihnLGspe3RoaXMuY29tcGlsZWQ9azt0aGlzLmNvZGU9ay5jb2RlO3RoaXMuZmlsZW5hbWU9Z30sc2xvdHM6e3RwJG5ldyhnLGspe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IGEgY29kZSBvYmplY3QgaW4gc2t1bHB0XCIpO30sJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGNvZGUgb2JqZWN0IDxtb2R1bGU+LCBmaWxlIFwiK1xudGhpcy5maWxlbmFtZStcIj5cIil9fX0pO1NrLmJ1aWx0aW4uY29tcGlsZT1mdW5jdGlvbihnLGsscCxoLGEsYyl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcInNvdXJjZVwiLFwic3RyXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyhnKSk7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcImZpbGVuYW1lXCIsXCJzdHJcIixTay5idWlsdGluLmNoZWNrU3RyaW5nKGspKTtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwibW9kZVwiLFwic3RyXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyhwKSk7Zz1nLiRqc3N0cigpO2s9ay4kanNzdHIoKTtwPXAuJGpzc3RyKCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmNvbXBpbGUoZyxrLHAsITApLG09Pm5ldyBiKGssbSkpfTtTay5idWlsdGluLmV4ZWM9ZnVuY3Rpb24oZyxrLHApe2xldCBoPWsmJmsuX19maWxlX187aD12b2lkIDAhPT1oJiZTay5idWlsdGluLmNoZWNrU3RyaW5nKGgpP2gudG9TdHJpbmcoKTpcIjxzdHJpbmc+XCI7aWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhnKSlnPVxuU2suY29tcGlsZShnLiRqc3N0cigpLGgsXCJleGVjXCIsITApO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBnKWc9U2suY29tcGlsZShnLGgsXCJleGVjXCIsITApO2Vsc2UgaWYoIShnIGluc3RhbmNlb2YgYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZXhlYygpIGFyZyAxIG11c3QgYmUgYSBzdHJpbmcsIGJ5dGVzIG9yIGNvZGUgb2JqZWN0XCIpO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMD09PWt8fGsuY29uc3RydWN0b3I9PT1PYmplY3QsXCJpbnRlcm5hbCBjYWxscyB0byBleGVjIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhIGphdmFzY3JpcHQgb2JqZWN0IGZvciBnbG9iYWxzXCIpO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMD09PXB8fHAuY29uc3RydWN0b3I9PT1PYmplY3QsXCJpbnRlcm5hbCBjYWxscyB0byBleGVjIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhIGphdmFzY3JpcHQgb2JqZWN0IGZvciBsb2NhbHNcIik7Y29uc3QgYT1Tay5nbG9iYWxzO2s9a3x8YTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZyxcbmM9PlNrLmdsb2JhbC5ldmFsKGMuY29kZSkoayxwKSxjPT57U2suZ2xvYmFscz1hO3JldHVybiBjfSl9O1NrLmJ1aWx0aW4uZXZhbD1mdW5jdGlvbihnLGsscCl7aWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhnKSlnPWcuJGpzc3RyKCk7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrQnl0ZXMoZykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImJ5dGVzIGZvciBldmFsIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gc2t1bHB0XCIpO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZyl7Zz1nLnRyaW0oKTt2YXIgaD1Tay5wYXJzZShcIj9cIixnKTtoPVNrLmFzdEZyb21QYXJzZShoLmNzdCxcIj9cIixoLmZsYWdzKTtpZigxPGguYm9keS5sZW5ndGh8fCEoaC5ib2R5WzBdaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5FeHByKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImludmFsaWQgc3ludGF4XCIpO2c9XCJfX2ZpbmFsX3Jlc19fID0gXCIrZ31lbHNlIGlmKCEoZyBpbnN0YW5jZW9mXG5iKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJldmFsKCkgYXJnIDEgbXVzdCBiZSBhIHN0cmluZywgYnl0ZXMgb3IgY29kZSBvYmplY3RcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmJ1aWx0aW4uZXhlYyhnLGsscCksYT0+e2NvbnN0IGM9YS5fX2ZpbmFsX3Jlc19ffHxTay5idWlsdGluLm5vbmUubm9uZSQ7ZGVsZXRlIGEuX19maW5hbF9yZXNfXztyZXR1cm4gY30pfTtTay5idWlsdGluLm1hcD1mdW5jdGlvbihnLGspe3ZhciBwPVtdLGgsYTtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFwibWFwXCIsYXJndW1lbnRzLmxlbmd0aCwyKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBjPVtdO3ZhciBtPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpLnNsaWNlKDEpO2ZvcihhPTA7YTxtLmxlbmd0aDthKyspe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUobVthXSkpe3ZhciBuPXBhcnNlSW50KGEsMTApKzI7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYXJndW1lbnQgXCIrXG5uK1wiIHRvIG1hcCgpIG11c3Qgc3VwcG9ydCBpdGVyYXRpb25cIik7fW1bYV09U2suYWJzdHIuaXRlcihtW2FdKX1mb3IoOzspe3ZhciBkPVtdO2ZvcihhPWg9MDthPG0ubGVuZ3RoO2ErKyluPW1bYV0udHAkaXRlcm5leHQoKSx2b2lkIDA9PT1uPyhkLnB1c2goU2suYnVpbHRpbi5ub25lLm5vbmUkKSxoKyspOmQucHVzaChuKTtpZihoIT09bS5sZW5ndGgpYy5wdXNoKGQpO2Vsc2UgYnJlYWt9az1uZXcgU2suYnVpbHRpbi5saXN0KGMpfWlmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoaykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGspK1wiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoayksZnVuY3Rpb24obCl7aWYoZz09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJClsIGluc3RhbmNlb2YgQXJyYXkmJihsPW5ldyBTay5idWlsdGluLnR1cGxlKGwpKSxcbnAucHVzaChsKTtlbHNlIHJldHVybiBsIGluc3RhbmNlb2YgQXJyYXl8fChsPVtsXSksU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGcsbCksZnVuY3Rpb24ocil7cC5wdXNoKHIpfSl9KSxmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHApfSl9O1NrLmJ1aWx0aW4ucmVkdWNlPWZ1bmN0aW9uKGcsayxwKXtpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGspKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShrKStcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTtrPVNrLmFic3RyLml0ZXIoayk7aWYodm9pZCAwPT09cCYmKHA9ay50cCRpdGVybmV4dCgpLHZvaWQgMD09PXApKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInJlZHVjZSgpIG9mIGVtcHR5IHNlcXVlbmNlIHdpdGggbm8gaW5pdGlhbCB2YWx1ZVwiKTt2YXIgaD1wO2ZvcihwPWsudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1cbnA7cD1rLnRwJGl0ZXJuZXh0KCkpaD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZyxbaCxwXSk7cmV0dXJuIGh9O1NrLmJ1aWx0aW4uc29ydGVkPWZ1bmN0aW9uKGcsayxwLGgpe2c9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZywhMCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGcsYT0+e2E9bmV3IFNrLmJ1aWx0aW4ubGlzdChhKTthLmxpc3Qkc29ydChrLHAsaCk7cmV0dXJuIGF9KX07U2suYnVpbHRpbi5maWx0ZXI9ZnVuY3Rpb24oZyxrKXt2YXIgcDtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFwiZmlsdGVyXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpO2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoaykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGspK1wiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO3ZhciBoPWZ1bmN0aW9uKCl7cmV0dXJuW119O3ZhciBhPWZ1bmN0aW9uKGQsbCl7ZC5wdXNoKGwpO3JldHVybiBkfTtcbnZhciBjPWZ1bmN0aW9uKGQpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGQpfTtrLm9iJHR5cGU9PT1Tay5idWlsdGluLnN0cj8oaD1mdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJcIil9LGE9ZnVuY3Rpb24oZCxsKXtyZXR1cm4gZC5zcSRjb25jYXQobCl9LGM9ZnVuY3Rpb24oZCl7cmV0dXJuIGR9KTprLm9iJHR5cGU9PT1Tay5idWlsdGluLnR1cGxlJiYoYz1mdW5jdGlvbihkKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoZCl9KTt2YXIgbT1oKCk7dmFyIG49U2suYWJzdHIuaXRlcihrKTtmb3IocD1uLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09cDtwPW4udHAkaXRlcm5leHQoKSloPWc9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/bmV3IFNrLmJ1aWx0aW4uYm9vbChwKTpTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZyxbcF0pLFNrLm1pc2NldmFsLmlzVHJ1ZShoKSYmKG09YShtLHApKTtyZXR1cm4gYyhtKX07U2suYnVpbHRpbi5oYXNhdHRyPWZ1bmN0aW9uKGcsXG5rKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhrKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJoYXNhdHRyKCk6IGF0dHJpYnV0ZSBuYW1lIG11c3QgYmUgc3RyaW5nXCIpO2NvbnN0IHA9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PmcudHAkZ2V0YXR0cihrLCEwKSxoPT57aWYoIShoIGluc3RhbmNlb2YgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcikpdGhyb3cgaDt9KTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4ocCxoPT52b2lkIDA9PT1oP1NrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ6U2suYnVpbHRpbi5ib29sLnRydWUkKX07U2suYnVpbHRpbi5wb3c9ZnVuY3Rpb24oZyxrLHApe2lmKHZvaWQgMD09PXB8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKHApKXJldHVybiBTay5hYnN0ci5udW1iZXJCaW5PcChnLGssXCJQb3dcIik7aWYoIShTay5idWlsdGluLmNoZWNrSW50KGcpJiZTay5idWlsdGluLmNoZWNrSW50KGspJiZTay5idWlsdGluLmNoZWNrSW50KHApKSl7aWYoU2suYnVpbHRpbi5jaGVja0Zsb2F0KGcpfHxcblNrLmJ1aWx0aW4uY2hlY2tDb21wbGV4KGcpKXJldHVybiBnLm5iJHBvd2VyKGsscCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmFuZCB0eXBlKHMpIGZvciAqKiBvciBwb3coKTogJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGcpK1wiJywgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGspK1wiJywgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHApK1wiJ1wiKTt9cmV0dXJuIGcubmIkcG93ZXIoayxwKX07U2suYnVpbHRpbi5xdWl0PWZ1bmN0aW9uKGcpe2c9KG5ldyBTay5idWlsdGluLnN0cihnKSkudjt0aHJvdyBuZXcgU2suYnVpbHRpbi5TeXN0ZW1FeGl0KGcpO307U2suYnVpbHRpbi5pc3N1YmNsYXNzPWZ1bmN0aW9uKGcsayl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhnKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpc3N1YmNsYXNzKCkgYXJnIDEgbXVzdCBiZSBhIGNsYXNzXCIpO3ZhciBwPVNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhrKTtpZighKHB8fFxuayBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImlzc3ViY2xhc3MoKSBhcmcgMiBtdXN0IGJlIGEgY2xhc3Mgb3IgdHVwbGUgb2YgY2xhc3Nlc1wiKTtpZihwKXJldHVybiBnLiRpc1N1YlR5cGUoayk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7Zm9yKHA9MDtwPGsudi5sZW5ndGg7KytwKWlmKFNrLm1pc2NldmFsLmlzVHJ1ZShTay5idWlsdGluLmlzc3ViY2xhc3MoZyxrLnZbcF0pKSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO3JldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkfTtTay5idWlsdGluLmdsb2JhbHM9ZnVuY3Rpb24oKXt2YXIgZyxrPW5ldyBTay5idWlsdGluLmRpY3QoW10pO2ZvcihnIGluIFNrLmdsb2JhbHMpe3ZhciBwPVNrLnVuZml4UmVzZXJ2ZWQoZyk7ay5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihwKSxTay5nbG9iYWxzW2ddKX1yZXR1cm4ga307XG5Tay5idWlsdGluLmRpdm1vZD1mdW5jdGlvbihnLGspe3JldHVybiBTay5hYnN0ci5udW1iZXJCaW5PcChnLGssXCJEaXZNb2RcIil9O1NrLmJ1aWx0aW4uZm9ybWF0PWZ1bmN0aW9uKGcsayl7cmV0dXJuIFNrLmFic3RyLm9iamVjdEZvcm1hdChnLGspfTtjb25zdCBmPW5ldyBXZWFrTWFwO2xldCBlPTA7U2suYnVpbHRpbi5pZD1mdW5jdGlvbihnKXtjb25zdCBrPWYuZ2V0KGcpO2lmKHZvaWQgMCE9PWspcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oayk7Zi5zZXQoZyxlKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhlKyspfTtTay5idWlsdGluLmJ5dGVhcnJheT1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJieXRlYXJyYXkgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uY2FsbGFibGU9ZnVuY3Rpb24oZyl7cmV0dXJuIFNrLmJ1aWx0aW4uY2hlY2tDYWxsYWJsZShnKT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6XG5Tay5idWlsdGluLmJvb2wuZmFsc2UkfTtTay5idWlsdGluLmRlbGF0dHI9ZnVuY3Rpb24oZyxrKXtyZXR1cm4gU2suYnVpbHRpbi5zZXRhdHRyKGcsayx2b2lkIDApfTtTay5idWlsdGluLmV4ZWNmaWxlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImV4ZWNmaWxlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7fTtTay5idWlsdGluLmhlbHA9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiaGVscCBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5pdGVyPWZ1bmN0aW9uKGcsayl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP1NrLmFic3RyLml0ZXIoZyk6U2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi5jYWxsYWJsZV9pdGVyXyhnLGspKX07U2suYnVpbHRpbi5sb2NhbHM9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwibG9jYWxzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG59O1NrLmJ1aWx0aW4ubWVtb3J5dmlldz1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJtZW1vcnl2aWV3IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7fTtTay5idWlsdGluLm5leHRfPWZ1bmN0aW9uKGcsayl7aWYoIWcudHAkaXRlcm5leHQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGcpK1wiJyBvYmplY3QgaXMgbm90IGFuIGl0ZXJhdG9yXCIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihnLnRwJGl0ZXJuZXh0KCEwKSxwPT57aWYodm9pZCAwPT09cCl7aWYoaylyZXR1cm4gaztwPWcuZ2kkcmV0O2lmKHZvaWQgMCE9PXAmJnAhPT1Tay5idWlsdGluLm5vbmUubm9uZSQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbihwKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uO31yZXR1cm4gcH0pfTtTay5idWlsdGluLnJlbG9hZD1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJyZWxvYWQgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTtcbn07U2suYnVpbHRpbi52YXJzPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcInZhcnMgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uYXBwbHlfPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImFwcGx5IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7fTtTay5idWlsdGluLmJ1ZmZlcj1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJidWZmZXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uY29lcmNlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImNvZXJjZSBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5pbnRlcm49ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiaW50ZXJuIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG59fSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoVCxZKXtZPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3RoaXMuaHQkdHlwZSYmcC5jYWxsKFkpO1kuYXJncz1uZXcgU2suYnVpbHRpbi50dXBsZShULnNsaWNlKDApKTtyZXR1cm4gWX1mdW5jdGlvbiBmKFQsWSl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhTay5hYnN0ci50eXBlTmFtZSh0aGlzKSxZKTt0aGlzLmFyZ3M9bmV3IFNrLmJ1aWx0aW4udHVwbGUoVC5zbGljZSgwKSl9ZnVuY3Rpb24gZSgpe3JldHVybiAxPj10aGlzLmFyZ3Mudi5sZW5ndGg/bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuYXJncy52WzBdKTp0aGlzLmFyZ3MuJHIoKX1mdW5jdGlvbiBnKFQsWSxkYSxxYSxwYSx6KXtwYXx8KHBhPVtdKTtjb25zdCB1PXFhP3t9OntzayRzb2xpZEJhc2U6ITF9O2RhPXt0cCRpbml0OnFhfHxmLHRwJGRvYzpkYX07eiYmKGRhLnRwJHN0cj16KTtyZXR1cm4gU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhZLHtiYXNlOlQsY29uc3RydWN0b3I6ZnVuY3Rpb24oLi4ueSl7VC5hcHBseSh0aGlzLFxueSk7cGEuZm9yRWFjaCgoRyxLKT0+e3RoaXNbXCIkXCIrR109U2suZmZpLnJlbWFwVG9QeSh5W0tdKX0pfSxzbG90czpkYSxnZXRzZXRzOk9iamVjdC5mcm9tRW50cmllcyhwYS5tYXAoeT0+W3kseyRnZXQoKXtyZXR1cm4gdGhpc1tcIiRcIit5XXx8U2suYnVpbHRpbi5ub25lLm5vbmUkfSwkc2V0KEcpe3RoaXNbXCIkXCIreV09R3x8U2suYnVpbHRpbi5ub25lLm5vbmUkfX1dKSksZmxhZ3M6dX0pfWZ1bmN0aW9uIGsoVCxZLGRhKXtjb25zdCBxYT1ULnByb3RvdHlwZS50cCRpbml0O2RhPXt0cCRkb2M6ZGEsdHAkaW5pdDpxYX07cWE9PT1mJiYoZGEudHAkbmV3PWIpO3JldHVybiBTay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFkse2Jhc2U6VCxjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5wYSl7VC5hcHBseSh0aGlzLHBhKX0sc2xvdHM6ZGEsZmxhZ3M6e3NrJHNvbGlkQmFzZTohMX19KX1jb25zdCBwPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJCYXNlRXhjZXB0aW9uXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHFhKFksXG4uLi5kYSl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIHFhLFwiYmFkIGNhbGwgdG8gZXhjZXB0aW9uIGNvbnN0cnVjdG9yLCB1c2UgJ25ldydcIik7XCJzdHJpbmdcIj09PXR5cGVvZiBZJiYoWT1uZXcgU2suYnVpbHRpbi5zdHIoWSkpO3RoaXMuYXJncz1uZXcgU2suYnVpbHRpbi50dXBsZShZP1tZXTpbXSk7dGhpcy50cmFjZWJhY2s9Mjw9ZGEubGVuZ3RoP1t7ZmlsZW5hbWU6ZGFbMF18fFwiPHVua25vd24+XCIsbGluZW5vOmRhWzFdfV06W107dGhpcy5jb250ZXh0PXRoaXMuY2F1c2U9bnVsbDt0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3R9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRkb2M6XCJDb21tb24gYmFzZSBjbGFzcyBmb3IgYWxsIGV4Y2VwdGlvbnNcIix0cCRuZXc6Yix0cCRpbml0OmYsJHIoKXtsZXQgWT10aGlzLnRwJG5hbWU7WSs9XCIoXCIrdGhpcy5hcmdzLnYubWFwKGRhPT5Tay5taXNjZXZhbC5vYmplY3RSZXByKGRhKSkuam9pbihcIiwgXCIpK1xuXCIpXCI7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihZKX0sdHAkc3RyOmV9LGdldHNldHM6e2FyZ3M6eyRnZXQoKXtyZXR1cm4gdGhpcy5hcmdzfSwkc2V0KFkpe2lmKHZvaWQgMD09PVkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYXJncyBtYXkgbm90IGJlIGRlbGV0ZWRcIik7dGhpcy5hcmdzPW5ldyBTay5idWlsdGluLnR1cGxlKFkpfX0sX19jYXVzZV9fOnskZ2V0KCl7cmV0dXJuIHRoaXMuJGNhdXNlfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRzZXQoWSl7aWYoIShTay5idWlsdGluLmNoZWNrTm9uZShZKXx8WSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikpdGhyb3cgbmV3IG5hKFwiZXhjZXB0aW9uIGNhdXNlIG11c3QgYmUgTm9uZSBvciBkZXJpdmUgZnJvbSBCYXNlRXhjZXB0aW9uXCIpO3RoaXMuJGNhdXNlPVl9fSxfX2RpY3RfXzpTay5nZW5lcmljLmdldFNldERpY3R9LHByb3RvOnt0b1N0cmluZygpe2xldCBZPXRoaXMudHAkbmFtZTtZKz1cIjogXCIrXG50aGlzLnRwJHN0cigpLnY7cmV0dXJuIFk9MCE9PXRoaXMudHJhY2ViYWNrLmxlbmd0aD9ZKyhcIiBvbiBsaW5lIFwiK3RoaXMudHJhY2ViYWNrWzBdLmxpbmVubyk6WStcIiBhdCA8dW5rbm93bj5cIn19fSk7RT1rKHAsXCJTeXN0ZW1FeGl0XCIsXCJSZXF1ZXN0IHRvIGV4aXQgZnJvbSB0aGUgaW50ZXJwcmV0ZXIuXCIpO1E9ayhwLFwiS2V5Ym9hcmRJbnRlcnJ1cHRcIixcIlByb2dyYW0gaW50ZXJydXB0ZWQgYnkgdXNlci5cIik7Y29uc3QgaD1rKHAsXCJHZW5lcmF0b3JFeGl0XCIsXCJSZXF1ZXN0IHRoYXQgYSBnZW5lcmF0b3IgZXhpdC5cIiksYT1rKHAsXCJFeGNlcHRpb25cIixcIkNvbW1vbiBiYXNlIGNsYXNzIGZvciBhbGwgbm9uLWV4aXQgZXhjZXB0aW9ucy5cIiksYz1nKGEsXCJTdG9wSXRlcmF0aW9uXCIsXCJTaWduYWwgdGhlIGVuZCBmcm9tIGl0ZXJhdG9yLl9fbmV4dF9fKCkuXCIsZnVuY3Rpb24oWSxkYSl7Zi5jYWxsKHRoaXMsWSxkYSk7dGhpcy4kdmFsdWU9WVswXXx8U2suYnVpbHRpbi5ub25lLm5vbmUkfSxcbltcInZhbHVlXCJdKSxtPWsoYSxcIlN0b3BBc3luY0l0ZXJhdGlvblwiLFwiU2lnbmFsIHRoZSBlbmQgZnJvbSBpdGVyYXRvci5fX2FuZXh0X18oKS5cIiksbj1rKGEsXCJBcml0aG1ldGljRXJyb3JcIixcIkJhc2UgY2xhc3MgZm9yIGFyaXRobWV0aWMgZXJyb3JzLlwiKSxkPWsobixcIkZsb2F0aW5nUG9pbnRFcnJvclwiLFwiRmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9uIGZhaWxlZC5cIiksbD1rKG4sXCJPdmVyZmxvd0Vycm9yXCIsXCJSZXN1bHQgdG9vIGxhcmdlIHRvIGJlIHJlcHJlc2VudGVkLlwiKSxyPWsobixcIlplcm9EaXZpc2lvbkVycm9yXCIsXCJTZWNvbmQgYXJndW1lbnQgdG8gYSBkaXZpc2lvbiBvciBtb2R1bG8gb3BlcmF0aW9uIHdhcyB6ZXJvLlwiKSx2PWsoYSxcIkFzc2VydGlvbkVycm9yXCIsXCJBc3NlcnRpb24gZmFpbGVkLlwiKSxxPWsoYSxcIkF0dHJpYnV0ZUVycm9yXCIsXCJBdHRyaWJ1dGUgbm90IGZvdW5kLlwiKSx0PWsoYSxcIkJ1ZmZlckVycm9yXCIsXCJCdWZmZXIgZXJyb3IuXCIpLHc9ayhhLFwiRU9GRXJyb3JcIixcblwiUmVhZCBiZXlvbmQgZW5kIG9mIGZpbGUuXCIpLEM9ZyhhLFwiSW1wb3J0RXJyb3JcIixcIkltcG9ydCBjYW4ndCBmaW5kIG1vZHVsZSwgb3IgY2FuJ3QgZmluZCBuYW1lIGluIG1vZHVsZS5cIixmdW5jdGlvbihZLGRhKXtmLmNhbGwodGhpcyxZKTtjb25zdCBbcWEscGFdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiSW1wb3J0RXJyb3JcIixbXCJuYW1lXCIsXCJwYXRoXCJdLFtdLGRhKTt0aGlzLiRuYW1lPXFhO3RoaXMuJHBhdGg9cGE7MT09PVkubGVuZ3RoJiYodGhpcy4kbXNnPVlbMF0pfSxbXCJtc2dcIixcIm5hbWVcIixcInBhdGhcIl0sZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5jaGVja1N0cmluZyh0aGlzLiRtc2cpP3RoaXMuJG1zZzplLmNhbGwodGhpcyl9KSxEPWsoQyxcIk1vZHVsZU5vdEZvdW5kRXJyb3JcIixcIk1vZHVsZSBub3QgZm91bmQuXCIpLEw9ayhhLFwiTG9va3VwRXJyb3JcIixcIkJhc2UgY2xhc3MgZm9yIGxvb2t1cCBlcnJvcnMuXCIpLE49ayhMLFwiSW5kZXhFcnJvclwiLFwiU2VxdWVuY2UgaW5kZXggb3V0IG9mIHJhbmdlLlwiKSxcbkE9ZyhMLFwiS2V5RXJyb3JcIixcIk1hcHBpbmcga2V5IG5vdCBmb3VuZC5cIixudWxsLG51bGwsZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMuYXJncy52Lmxlbmd0aD90aGlzLmFyZ3MudlswXS4kcigpOmUuY2FsbCh0aGlzKX0pLEg9ayhhLFwiTWVtb3J5RXJyb3JcIixcIk91dCBvZiBtZW1vcnkuXCIpLHg9ayhhLFwiTmFtZUVycm9yXCIsXCJOYW1lIG5vdCBmb3VuZCBnbG9iYWxseS5cIiksQj1rKHgsXCJVbmJvdW5kTG9jYWxFcnJvclwiLFwiTG9jYWwgbmFtZSByZWZlcmVuY2VkIGJ1dCBub3QgYm91bmQgdG8gYSB2YWx1ZS5cIiksRj1nKGEsXCJPU0Vycm9yXCIsXCJCYXNlIGNsYXNzIGZvciBJL08gcmVsYXRlZCBlcnJvcnMuXCIsZnVuY3Rpb24oWSxkYSl7Zi5jYWxsKHRoaXMsWSxkYSl9KSxKPWsoRixcIkZpbGVOb3RGb3VuZEVycm9yXCIsXCJGaWxlIG5vdCBmb3VuZC5cIiksUD1rKEYsXCJUaW1lb3V0RXJyb3JcIixcIlRpbWVvdXQgZXhwaXJlZC5cIiksVz1rKGEsXCJSZWZlcmVuY2VFcnJvclwiLFwiV2VhayByZWYgcHJveHkgdXNlZCBhZnRlciByZWZlcmVudCB3ZW50IGF3YXkuXCIpLFxuY2E9ayhhLFwiUnVudGltZUVycm9yXCIsXCJVbnNwZWNpZmllZCBydW4tdGltZSBlcnJvci5cIiksaGE9ayhjYSxcIk5vdEltcGxlbWVudGVkRXJyb3JcIixcIk1ldGhvZCBvciBmdW5jdGlvbiBoYXNuJ3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXCIpLG9hPWsoY2EsXCJSZWN1cnNpb25FcnJvclwiLFwiUmVjdXJzaW9uIGxpbWl0IGV4Y2VlZGVkLlwiKSxrYT1nKGEsXCJTeW50YXhFcnJvclwiLFwiSW52YWxpZCBzeW50YXguXCIsZnVuY3Rpb24oWSxkYSl7Zi5jYWxsKHRoaXMsWSxkYSk7MTw9WS5sZW5ndGgmJih0aGlzLiRtc2c9WVswXSk7Mj09PVkubGVuZ3RoJiYoWT0obmV3IFNrLmJ1aWx0aW4udHVwbGUoWVsxXSkpLnYsdGhpcy4kZmlsZW5hbWU9WVswXSx0aGlzLiRsaW5lbm89WVsxXSx0aGlzLiRvZmZzZXQ9WVsyXSx0aGlzLiR0ZXh0PVlbM10pfSxbXCJtc2dcIixcImZpbGVuYW1lXCIsXCJsaW5lbm9cIixcIm9mZnNldFwiLFwidGV4dFwiXSxmdW5jdGlvbigpe3JldHVybiBlLmNhbGwodGhpcyl9KSxpYT1rKGthLFwiSW5kZW50YXRpb25FcnJvclwiLFxuXCJJbXByb3BlciBpbmRlbnRhdGlvbi5cIiksYmE9ayhpYSxcIlRhYkVycm9yXCIsXCJJbXByb3BlciBtaXh0dXJlIG9mIHNwYWNlcyBhbmQgdGFicy5cIiksamE9ayhhLFwiU3lzdGVtRXJyb3JcIixcIkludGVybmFsIGVycm9yIGluIHRoZSBTa3VscHQgaW50ZXJwcmV0ZXIuXCIpLG5hPWsoYSxcIlR5cGVFcnJvclwiLFwiSW5hcHByb3ByaWF0ZSBhcmd1bWVudCB0eXBlLlwiKSxmYT1rKGEsXCJWYWx1ZUVycm9yXCIsXCJJbmFwcHJvcHJpYXRlIGFyZ3VtZW50IHZhbHVlIChvZiBjb3JyZWN0IHR5cGUpLlwiKSxWPWsoZmEsXCJVbmljb2RlRXJyb3JcIixcIlVuaWNvZGUgcmVsYXRlZCBlcnJvci5cIiksbGE9ayhWLFwiVW5pY29kZURlY29kZUVycm9yXCIsXCJVbmljb2RlIGRlY29kaW5nIGVycm9yLlwiKSxPPWsoVixcIlVuaWNvZGVFbmNvZGVFcnJvclwiLFwiVW5pY29kZSBlbmNvZGluZyBlcnJvci5cIik7T2JqZWN0LmFzc2lnbihTay5idWlsdGluLHtCYXNlRXhjZXB0aW9uOnAsU3lzdGVtRXhpdDpFLEtleWJvYXJkSW50ZXJydXB0OlEsXG5HZW5lcmF0b3JFeGl0OmgsRXhjZXB0aW9uOmEsU3RvcEl0ZXJhdGlvbjpjLFN0b3BBc3luY0l0ZXJhdGlvbjptLEFyaXRobWV0aWNFcnJvcjpuLEZsb2F0aW5nUG9pbnRFcnJvcjpkLE92ZXJmbG93RXJyb3I6bCxaZXJvRGl2aXNpb25FcnJvcjpyLEFzc2VydGlvbkVycm9yOnYsQXR0cmlidXRlRXJyb3I6cSxCdWZmZXJFcnJvcjp0LEVPRkVycm9yOncsSW1wb3J0RXJyb3I6QyxNb2R1bGVOb3RGb3VuZEVycm9yOkQsTG9va3VwRXJyb3I6TCxJbmRleEVycm9yOk4sS2V5RXJyb3I6QSxNZW1vcnlFcnJvcjpILE5hbWVFcnJvcjp4LFVuYm91bmRMb2NhbEVycm9yOkIsT1NFcnJvcjpGLElPRXJyb3I6RixGaWxlTm90Rm91bmRFcnJvcjpKLFRpbWVvdXRFcnJvcjpQLFJlZmVyZW5jZUVycm9yOlcsUnVudGltZUVycm9yOmNhLE5vdEltcGxlbWVudGVkRXJyb3I6aGEsUmVjdXJzaW9uRXJyb3I6b2EsU3ludGF4RXJyb3I6a2EsSW5kZW50YXRpb25FcnJvcjppYSxUYWJFcnJvcjpiYSxTeXN0ZW1FcnJvcjpqYSxcblR5cGVFcnJvcjpuYSxWYWx1ZUVycm9yOmZhLFVuaWNvZGVFcnJvcjpWLFVuaWNvZGVEZWNvZGVFcnJvcjpsYSxVbmljb2RlRW5jb2RlRXJyb3I6T30pO1NrLmJ1aWx0aW4uU3VzcGVuc2lvbkVycm9yPWsoYSxcIlN1c3BlbnNpb25FcnJvclwiLFwiVW5zdXBwb3J0ZWQgU3VzcGVuc2lvbiBpbiBjb2RlLlwiKTtTay5idWlsdGluLkV4dGVybmFsRXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIkV4dGVybmFsRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uWSl7dGhpcy5uYXRpdmVFcnJvcj1ZWzBdO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHRoaXMubmF0aXZlRXJyb3IpJiYoWVswXT10aGlzLm5hdGl2ZUVycm9yLnRvU3RyaW5nKCksWVswXS5zdGFydHNXaXRoKFwiUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsXCIpKSlyZXR1cm4gWVswXT1cIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIsbmV3IG9hKC4uLlkpO2EuYXBwbHkodGhpcyxZKX0sYmFzZTphfSk7U2suYnVpbHRpbi5nZXRFeGNJbmZvPVxuZnVuY3Rpb24oWSl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtZLm9iJHR5cGV8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxZLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0pfX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLm1ldGhvZD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwibWV0aG9kXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZil7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWV0aG9kLFwiYmFkIGNhbGwgdG8gbWV0aG9kIGNvbnN0cnVjdG9yLCB1c2UgJ25ldydcIik7dGhpcy5pbV9mdW5jPWI7dGhpcy5pbV9zZWxmPWY7dGhpcy5pbV9jYWxsPWIudHAkY2FsbH0sc2xvdHM6eyRyKCl7bGV0IGI9dGhpcy5pbV9mdW5jLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJHF1YWxuYW1lKXx8dGhpcy5pbV9mdW5jLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJG5hbWUpO2I9YiYmYi52fHxcIj9cIjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGJvdW5kIG1ldGhvZCBcIitcbmIrXCIgb2YgXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLmltX3NlbGYpK1wiPlwiKX0sdHAkaGFzaCgpe2NvbnN0IGI9U2suYWJzdHIub2JqZWN0SGFzaCh0aGlzLmltX3NlbGYpLGY9U2suYWJzdHIub2JqZWN0SGFzaCh0aGlzLmltX2Z1bmMpO3JldHVybiBiK2Z9LHRwJGNhbGwoYixmKXt2YXIgZT10aGlzLmltX2NhbGw7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcy5pbV9mdW5jKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTtiPVt0aGlzLmltX3NlbGYsLi4uYl07cmV0dXJuIGUuY2FsbCh0aGlzLmltX2Z1bmMsYixmKX0sdHAkbmV3KGIsZil7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcIm1ldGhvZFwiLGYpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcIm1ldGhvZFwiLGIsMiwyKTtmPWJbMF07Yj1iWzFdO2lmKCFTay5idWlsdGluLmNoZWNrQ2FsbGFibGUoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBjYWxsYWJsZVwiKTtcbmlmKFNrLmJ1aWx0aW4uY2hlY2tOb25lKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNlbGYgbXVzdCBub3QgYmUgTm9uZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubWV0aG9kKGYsYil9LHRwJHJpY2hjb21wYXJlKGIsZil7aWYoXCJFcVwiIT1mJiZcIk5vdEVxXCIhPWZ8fCEoYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWV0aG9kKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7bGV0IGU7dHJ5e2U9U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHRoaXMuaW1fc2VsZixiLmltX3NlbGYsXCJFcVwiLCExKSYmdGhpcy5pbV9mdW5jPT1iLmltX2Z1bmN9Y2F0Y2goZyl7ZT0hMX1yZXR1cm5cIkVxXCI9PWY/ZTohZX0sdHAkZGVzY3JfZ2V0KGIsZil7cmV0dXJuIHRoaXN9LHRwJGdldGF0dHIoYixmKXtjb25zdCBlPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwodGhpcyxiKTtyZXR1cm4gdm9pZCAwIT09ZT9lOnRoaXMuaW1fZnVuYy50cCRnZXRhdHRyKGIsXG5mKX19LGdldHNldHM6e19fZnVuY19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuaW1fZnVuY319LF9fc2VsZl9fOnskZ2V0KCl7cmV0dXJuIHRoaXMuaW1fc2VsZn19LF9fZG9jX186eyRnZXQoKXtyZXR1cm4gdGhpcy5pbV9mdW5jLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGRvYyl9fX0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSl9LGZ1bmN0aW9uKEUsUSl7ZnVuY3Rpb24gYihwKXtpZihudWxsIT09cCYmdm9pZCAwIT09cCl7aWYocC5uYiRpbmRleClyZXR1cm4gcC5uYiRpbmRleCgpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgcCYmTnVtYmVyLmlzSW50ZWdlcihwKSlyZXR1cm4gcH19ZnVuY3Rpb24gZihwLGgpe2NvbnN0IGE9YihwKTtpZih2b2lkIDAhPT1hKXJldHVybiBhO2g9KGh8fFwiJ3t0cCRuYW1lfScgb2JqZWN0IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyXCIpLnJlcGxhY2UoXCJ7dHAkbmFtZX1cIixTay5hYnN0ci50eXBlTmFtZShwKSk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGgpO1xufWZ1bmN0aW9uIGUoKXtjb25zdCBwPShTay5nbG9iYWwubmF2aWdhdG9yfHx7fSkudXNlckFnZW50fHxcIlwiO3JldHVybi0xPHAuaW5kZXhPZihcIk1TSUUgXCIpfHwtMTxwLmluZGV4T2YoXCJUcmlkZW50L1wiKX1mdW5jdGlvbiBnKHAsaCl7bGV0IGE9cDtoLmZvckVhY2goYz0+e2M9Yy5vYiR0eXBlO2lmKCFhLiRpc1N1YlR5cGUoYykpaWYoYy4kaXNTdWJUeXBlKGEpKWE9YztlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm1ldGFjbGFzcyBjb25mbGljdDogdGhlIG1ldGFjbGFzcyBvZiBhIGRlcml2ZWQgY2xhc3MgbXVzdCBiZSBhIChub24tc3RyaWN0KSBzdWJjbGFzcyBvZiB0aGUgbWV0YWNsYXNzZXMgb2YgYWxsIGl0cyBiYXNlc1wiKTt9KTtyZXR1cm4gYX1mdW5jdGlvbiBrKHAsaCxhLGMsbSl7Y29uc3Qgbj1wLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJHByZXBhcmUpO2xldCBkLGw9bnVsbDtpZih2b2lkIDA9PT1uKXJldHVybltsLGRdO2w9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4sXG5baCxhXSxjKTtpZighU2suYnVpbHRpbi5jaGVja01hcHBpbmcobCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKG0/cC5wcm90b3R5cGUudHAkbmFtZTpcIjxtZXRhY2xhc3M+Ll9fcHJlcGFyZV9fKCkgbXVzdCByZXR1cm4gYSBtYXBwaW5nIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUobCkrXCInXCIpO2Q9e2dldChyLHYpe3RyeXtyZXR1cm4gU2suYWJzdHIub2JqZWN0R2V0SXRlbShyLG5ldyBTay5idWlsdGluLnN0cihTay51bmZpeFJlc2VydmVkKHYpKSl9Y2F0Y2gocSl7aWYoIShxIGluc3RhbmNlb2YgU2suYnVpbHRpbi5LZXlFcnJvcikpdGhyb3cgcTt9fSxzZXQocix2LHEpe1NrLmFic3RyLm9iamVjdFNldEl0ZW0ocixuZXcgU2suYnVpbHRpbi5zdHIoU2sudW5maXhSZXNlcnZlZCh2KSkscSk7cmV0dXJuITB9fTtyZXR1cm5bbCxkXX1Tay5taXNjZXZhbD17fTtTay5taXNjZXZhbC5TdXNwZW5zaW9uPWZ1bmN0aW9uKHAsaCxhKXt0aGlzLiRpc1N1c3BlbnNpb249ITA7XG52b2lkIDAhPT1wJiZ2b2lkIDAhPT1oJiYodGhpcy5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gcChoLnJlc3VtZSgpKX0pO3RoaXMuY2hpbGQ9aDt0aGlzLm9wdGlvbmFsPXZvaWQgMCE9PWgmJmgub3B0aW9uYWw7dGhpcy5kYXRhPXZvaWQgMD09PWEmJnZvaWQgMCE9PWg/aC5kYXRhOmF9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLlN1c3BlbnNpb25cIixTay5taXNjZXZhbC5TdXNwZW5zaW9uKTtTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3c9ZnVuY3Rpb24ocCxoKXtmb3IoO3AgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uOyl7aWYoIXAub3B0aW9uYWwpe2g9bmV3IFNrLmJ1aWx0aW4uU3VzcGVuc2lvbkVycm9yKGh8fFwiQ2Fubm90IGNhbGwgYSBmdW5jdGlvbiB0aGF0IGJsb2NrcyBvciBzdXNwZW5kcyBoZXJlXCIpO2NvbnN0IGE9W107Zm9yKDtudWxsIT1wOylwLiRsaW5lbm8mJmEucHVzaCh7ZmlsZW5hbWU6cC4kZmlsZW5hbWUsXG5saW5lbm86cC4kbGluZW5vLGNvbG5vOnAuJGNvbG5vfSkscD1wLmNoaWxkO2EucmV2ZXJzZSgpO2gudHJhY2ViYWNrLnB1c2goLi4uYSk7dGhyb3cgaDt9cD1wLnJlc3VtZSgpfXJldHVybiBwfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3dcIixTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3cpO1NrLm1pc2NldmFsLmlzSW5kZXg9ZnVuY3Rpb24ocCl7cmV0dXJuIG51bGwhPT1wJiZ2b2lkIDAhPT1wJiYodm9pZCAwIT09cC5uYiRpbmRleHx8XCJudW1iZXJcIj09PXR5cGVvZiBwJiZOdW1iZXIuaXNJbnRlZ2VyKHApKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuaXNJbmRleFwiLFNrLm1pc2NldmFsLmlzSW5kZXgpO1NrLm1pc2NldmFsLmFzSW5kZXg9YjtTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQ9ZnVuY3Rpb24ocCxoLGEpe2E9ZihwLGEpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlyZXR1cm4gYTtcbmlmKG51bGw9PWgpcmV0dXJuIEpTQkkubGVzc1RoYW4oYSxKU0JJLl9fWkVSTyk/LU51bWJlci5NQVhfU0FGRV9JTlRFR0VSOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSO3Rocm93IG5ldyBoKFwiY2Fubm90IGZpdCAnXCIrU2suYWJzdHIudHlwZU5hbWUocCkrXCInIGludG8gYW4gaW5kZXgtc2l6ZWQgaW50ZWdlclwiKTt9O1NrLm1pc2NldmFsLmFzSW5kZXhPclRocm93PWY7U2subWlzY2V2YWwuYXBwbHlTbGljZT1mdW5jdGlvbihwLGgsYSxjKXtyZXR1cm4gU2suYWJzdHIub2JqZWN0R2V0SXRlbShwLG5ldyBTay5idWlsdGluLnNsaWNlKGgsYSxudWxsKSxjKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuYXBwbHlTbGljZVwiLFNrLm1pc2NldmFsLmFwcGx5U2xpY2UpO1NrLm1pc2NldmFsLmFzc2lnblNsaWNlPWZ1bmN0aW9uKHAsaCxhLGMsbSl7aD1uZXcgU2suYnVpbHRpbi5zbGljZShoLGEpO3JldHVybiBudWxsPT09Yz9Tay5hYnN0ci5vYmplY3REZWxJdGVtKHAsaCk6U2suYWJzdHIub2JqZWN0U2V0SXRlbShwLFxuaCxjLG0pfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5hc3NpZ25TbGljZVwiLFNrLm1pc2NldmFsLmFzc2lnblNsaWNlKTtTay5taXNjZXZhbC5hcnJheUZyb21Bcmd1bWVudHM9ZnVuY3Rpb24ocCl7dmFyIGg7aWYoMSE9cC5sZW5ndGgpcmV0dXJuIHA7dmFyIGE9cFswXTthIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zZXQ/YT1hLnRwJGl0ZXIoKS4kb2JqOmEgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QmJihhPVNrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUua2V5cy5mdW5jX2NvZGUoYSkpO2lmKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmxpc3R8fGEgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKXJldHVybiBhLnY7aWYoU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGEpKXtwPVtdO2E9U2suYWJzdHIuaXRlcihhKTtmb3IoaD1hLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09aDtoPWEudHAkaXRlcm5leHQoKSlwLnB1c2goaCk7cmV0dXJuIHB9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1xuU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIG9iamVjdCBpcyBub3QgaXRlcmFibGVcIik7fTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5hcnJheUZyb21Bcmd1bWVudHNcIixTay5taXNjZXZhbC5hcnJheUZyb21Bcmd1bWVudHMpO1NrLm1pc2NldmFsLml0ZXJhdG9yPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcIml0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHAsaCl7dGhpcy50cCRpdGVybmV4dD1oP3A6ZnVuY3Rpb24oYSl7bGV0IGM9cCgpO3JldHVybiBhfHx2b2lkIDA9PT1jfHwhYy4kaXNTdXNwZW5zaW9uP2M6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGMpfX0saXRlcm5leHQ6ZnVuY3Rpb24ocCl7cmV0dXJuIHRoaXMudHAkaXRlcm5leHQocCl9LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pO1NrLm1pc2NldmFsLnN3YXBwZWRPcF89e0VxOlwiRXFcIixOb3RFcTpcIk5vdEVxXCIsTHQ6XCJHdFwiLEx0RTpcIkd0RVwiLEd0OlwiTHRcIixcbkd0RTpcIkx0RVwifTtTay5taXNjZXZhbC5vcFN5bWJvbHM9e0VxOlwiPT1cIixOb3RFcTpcIiE9XCIsTHQ6XCI8XCIsTHRFOlwiPD1cIixHdDpcIj5cIixHdEU6XCI+PVwiLElzOlwiaXNcIixJc05vdDpcImlzIG5vdFwiLEluXzpcImluXCIsTm90SW46XCJub3QgaW5cIn07U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sPWZ1bmN0aW9uKHAsaCxhLGMpe1NrLmFzc2VydHMuYXNzZXJ0KHAuc2skb2JqZWN0JiZoLnNrJG9iamVjdCxcIkpTIG9iamVjdCBwYXNzZWQgdG8gcmljaENvbXBhcmVCb29sXCIpO3ZhciBtPXAub2IkdHlwZSxuPWgub2IkdHlwZSxkPW4hPT1tJiZ2b2lkIDA9PT1uLnNrJGJhc2VDbGFzcyYmbi4kaXNTdWJUeXBlKG0pO2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMmJm0hPT1uJiYoXCJHdEVcIj09PWF8fFwiR3RcIj09PWF8fFwiTHRFXCI9PT1hfHxcIkx0XCI9PT1hKSl7dmFyIGw9W1NrLmJ1aWx0aW4uZmxvYXRfLFNrLmJ1aWx0aW4uaW50XyxTay5idWlsdGluLmxuZyxTay5idWlsdGluLmJvb2xdO2NvbnN0IHY9W1NrLmJ1aWx0aW4uZGljdCxcblNrLmJ1aWx0aW4uZW51bWVyYXRlLFNrLmJ1aWx0aW4uZmlsdGVyXyxTay5idWlsdGluLmxpc3QsU2suYnVpbHRpbi5tYXBfLFNrLmJ1aWx0aW4uc3RyLFNrLmJ1aWx0aW4udHVwbGUsU2suYnVpbHRpbi56aXBfXTt2YXIgcj1sLmluZGV4T2YobSk7bT12LmluZGV4T2YobSk7bD1sLmluZGV4T2Yobik7bj12LmluZGV4T2Yobik7aWYocD09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJClzd2l0Y2goYSl7Y2FzZSBcIkx0XCI6cmV0dXJuITA7Y2FzZSBcIkx0RVwiOnJldHVybiEwO2Nhc2UgXCJHdFwiOnJldHVybiExO2Nhc2UgXCJHdEVcIjpyZXR1cm4hMX1pZihoPT09U2suYnVpbHRpbi5ub25lLm5vbmUkKXN3aXRjaChhKXtjYXNlIFwiTHRcIjpyZXR1cm4hMTtjYXNlIFwiTHRFXCI6cmV0dXJuITE7Y2FzZSBcIkd0XCI6cmV0dXJuITA7Y2FzZSBcIkd0RVwiOnJldHVybiEwfWlmKC0xIT09ciYmLTEhPT1uKXN3aXRjaChhKXtjYXNlIFwiTHRcIjpyZXR1cm4hMDtjYXNlIFwiTHRFXCI6cmV0dXJuITA7Y2FzZSBcIkd0XCI6cmV0dXJuITE7XG5jYXNlIFwiR3RFXCI6cmV0dXJuITF9aWYoLTEhPT1tJiYtMSE9PWwpc3dpdGNoKGEpe2Nhc2UgXCJMdFwiOnJldHVybiExO2Nhc2UgXCJMdEVcIjpyZXR1cm4hMTtjYXNlIFwiR3RcIjpyZXR1cm4hMDtjYXNlIFwiR3RFXCI6cmV0dXJuITB9aWYoLTEhPT1tJiYtMSE9PW4pc3dpdGNoKGEpe2Nhc2UgXCJMdFwiOnJldHVybiBtPG47Y2FzZSBcIkx0RVwiOnJldHVybiBtPD1uO2Nhc2UgXCJHdFwiOnJldHVybiBtPm47Y2FzZSBcIkd0RVwiOnJldHVybiBtPj1ufX1pZihcIklzXCI9PT1hKXJldHVybiBwPT09aDtpZihcIklzTm90XCI9PT1hKXJldHVybiBwIT09aDtpZihcIkluXCI9PT1hKXJldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5hYnN0ci5zZXF1ZW5jZUNvbnRhaW5zKGgscCxjKSxTay5taXNjZXZhbC5pc1RydWUpO2lmKFwiTm90SW5cIj09PWEpcmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmFic3RyLnNlcXVlbmNlQ29udGFpbnMoaCxwLGMpLGZ1bmN0aW9uKHYpe3JldHVybiFTay5taXNjZXZhbC5pc1RydWUodil9KTtcbm49e0VxOlwib2IkZXFcIixOb3RFcTpcIm9iJG5lXCIsR3Q6XCJvYiRndFwiLEd0RTpcIm9iJGdlXCIsTHQ6XCJvYiRsdFwiLEx0RTpcIm9iJGxlXCJ9O3I9blthXTtpZihkJiYoYz1uW1NrLm1pc2NldmFsLnN3YXBwZWRPcF9bYV1dLChjPWhbY10ocCkpIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpfHwoYz1wW3JdKGgpKSE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfHwhZCYmKGM9bltTay5taXNjZXZhbC5zd2FwcGVkT3BfW2FdXSwoYz1oW2NdKHApKSE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKSlyZXR1cm4gU2subWlzY2V2YWwuaXNUcnVlKGMpO2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpe2lmKGQ9U2suYWJzdHIubG9va3VwU3BlY2lhbChwLFNrLmJ1aWx0aW4uc3RyLiRjbXApKXRyeXtjPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShkLFtoXSk7aWYoU2suYnVpbHRpbi5jaGVja051bWJlcihjKSl7Yz1cblNrLmJ1aWx0aW4uYXNudW0kKGMpO2lmKFwiRXFcIj09PWEpcmV0dXJuIDA9PT1jO2lmKFwiTm90RXFcIj09PWEpcmV0dXJuIDAhPT1jO2lmKFwiTHRcIj09PWEpcmV0dXJuIDA+YztpZihcIkd0XCI9PT1hKXJldHVybiAwPGM7aWYoXCJMdEVcIj09PWEpcmV0dXJuIDA+PWM7aWYoXCJHdEVcIj09PWEpcmV0dXJuIDA8PWN9aWYoYyE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBhcmlzb24gZGlkIG5vdCByZXR1cm4gYW4gaW50XCIpO31jYXRjaCh2KXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wYXJpc29uIGRpZCBub3QgcmV0dXJuIGFuIGludFwiKTt9aWYoZD1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGgsU2suYnVpbHRpbi5zdHIuJGNtcCkpdHJ5e2M9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGQsW3BdKTtpZihTay5idWlsdGluLmNoZWNrTnVtYmVyKGMpKXtjPVNrLmJ1aWx0aW4uYXNudW0kKGMpO1xuaWYoXCJFcVwiPT09YSlyZXR1cm4gMD09PWM7aWYoXCJOb3RFcVwiPT09YSlyZXR1cm4gMCE9PWM7aWYoXCJMdFwiPT09YSlyZXR1cm4gMDxjO2lmKFwiR3RcIj09PWEpcmV0dXJuIDA+YztpZihcIkx0RVwiPT09YSlyZXR1cm4gMDw9YztpZihcIkd0RVwiPT09YSlyZXR1cm4gMD49Y31pZihjIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGFyaXNvbiBkaWQgbm90IHJldHVybiBhbiBpbnRcIik7fWNhdGNoKHYpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBhcmlzb24gZGlkIG5vdCByZXR1cm4gYW4gaW50XCIpO31pZihwPT09U2suYnVpbHRpbi5ub25lLm5vbmUkJiZoPT09U2suYnVpbHRpbi5ub25lLm5vbmUkKXtpZihcIkVxXCI9PT1hKXJldHVybiBwLnY9PT1oLnY7aWYoXCJOb3RFcVwiPT09YSlyZXR1cm4gcC52IT09aC52O2lmKFwiR3RcIj09PWEpcmV0dXJuIHAudj5oLnY7aWYoXCJHdEVcIj09PWEpcmV0dXJuIHAudj49XG5oLnY7aWYoXCJMdFwiPT09YSlyZXR1cm4gcC52PGgudjtpZihcIkx0RVwiPT09YSlyZXR1cm4gcC52PD1oLnZ9fWlmKFwiRXFcIj09PWEpcmV0dXJuIHA9PT1oO2lmKFwiTm90RXFcIj09PWEpcmV0dXJuIHAhPT1oO3A9U2suYWJzdHIudHlwZU5hbWUocCk7aD1Tay5hYnN0ci50eXBlTmFtZShoKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2subWlzY2V2YWwub3BTeW1ib2xzW2FdK1wiJyBub3Qgc3VwcG9ydGVkIGJldHdlZW4gaW5zdGFuY2VzIG9mICdcIitwK1wiJyBhbmQgJ1wiK2grXCInXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sXCIsU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKTtTay5taXNjZXZhbC5vYmplY3RSZXByPWZ1bmN0aW9uKHApe1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMCE9PXAsXCJ0cnlpbmcgdG8gcmVwciB1bmRlZmluZWRcIik7aWYobnVsbCE9PXAmJnAuJHIpcmV0dXJuIHAuJHIoKS52O3RyeXtyZXR1cm4obmV3IFNrLmJ1aWx0aW4uc3RyKHApKS52fWNhdGNoKGgpe2lmKGggaW5zdGFuY2VvZlxuU2suYnVpbHRpbi5UeXBlRXJyb3IpcmV0dXJuXCI8dW5rbm93bj5cIjt0aHJvdyBoO319O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLm9iamVjdFJlcHJcIixTay5taXNjZXZhbC5vYmplY3RSZXByKTtTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5PWZ1bmN0aW9uKHApe3N3aXRjaChwKXtjYXNlIFwiTHRFXCI6Y2FzZSBcIkVxXCI6Y2FzZSBcIkd0RVwiOnJldHVybiEwfXJldHVybiExfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5XCIsU2subWlzY2V2YWwub3BBbGxvd3NFcXVhbGl0eSk7U2subWlzY2V2YWwuaXNUcnVlPWZ1bmN0aW9uKHApe3JldHVybiEwPT09cHx8cD09PVNrLmJ1aWx0aW4uYm9vbC50cnVlJD8hMDohMT09PXB8fHA9PT1Tay5idWlsdGluLmJvb2wuZmFsc2UkfHxudWxsPT09cHx8dm9pZCAwPT09cD8hMTpwLm5iJGJvb2w/cC5uYiRib29sKCk6cC5zcSRsZW5ndGg/MCE9PXAuc3EkbGVuZ3RoKCk6ISFwfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5pc1RydWVcIixcblNrLm1pc2NldmFsLmlzVHJ1ZSk7U2subWlzY2V2YWwuc29mdHNwYWNlXz0hMTtTay5taXNjZXZhbC5wcmludF89ZnVuY3Rpb24ocCl7U2subWlzY2V2YWwuc29mdHNwYWNlXyYmKFwiXFxuXCIhPT1wJiZTay5vdXRwdXQoXCIgXCIpLFNrLm1pc2NldmFsLnNvZnRzcGFjZV89ITEpO3ZhciBoPW5ldyBTay5idWlsdGluLnN0cihwKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFwic3lzXCIsITEsITApLGZ1bmN0aW9uKGEpe3JldHVybiBTay5taXNjZXZhbC5hcHBseShhLiRkLnN0ZG91dC53cml0ZSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxbYS4kZC5zdGRvdXQsaF0pfSxmdW5jdGlvbigpe3ZhciBhOyhhPTA9PT1oLnYubGVuZ3RoKXx8KGE9aC52W2gudi5sZW5ndGgtMV0sYT0hKFwiXFxuXCI9PT1hfHxcIlxcdFwiPT09YXx8XCJcXHJcIj09PWEpKTtpZihhfHxcIiBcIj09PWgudltoLnYubGVuZ3RoLTFdKVNrLm1pc2NldmFsLnNvZnRzcGFjZV89ITB9KX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwucHJpbnRfXCIsXG5Tay5taXNjZXZhbC5wcmludF8pO1NrLm1pc2NldmFsLmxvYWRuYW1lPWZ1bmN0aW9uKHAsaCl7aD1oW3BdO2lmKHZvaWQgMCE9PWgpcmV0dXJuIGg7aD1Tay5idWlsdGluc1twXTtpZih2b2lkIDAhPT1oKXJldHVybiBoO3Rocm93IG5ldyBTay5idWlsdGluLk5hbWVFcnJvcihcIm5hbWUgJ1wiK1NrLnVuZml4UmVzZXJ2ZWQocCkrXCInIGlzIG5vdCBkZWZpbmVkXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwubG9hZG5hbWVcIixTay5taXNjZXZhbC5sb2FkbmFtZSk7U2subWlzY2V2YWwuY2FsbD1mdW5jdGlvbihwLGgsYSxjLG0pe209QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDQpO3JldHVybiBTay5taXNjZXZhbC5hcHBseShwLGgsYSxjLG0pfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsXCIsU2subWlzY2V2YWwuY2FsbCk7U2subWlzY2V2YWwuY2FsbEFzeW5jPWZ1bmN0aW9uKHAsaCxhLGMsbSxuKXtuPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyxcbjUpO3JldHVybiBTay5taXNjZXZhbC5hcHBseUFzeW5jKHAsaCxhLGMsbSxuKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2FsbEFzeW5jXCIsU2subWlzY2V2YWwuY2FsbEFzeW5jKTtTay5taXNjZXZhbC5jYWxsT3JTdXNwZW5kPWZ1bmN0aW9uKHAsaCxhLGMsbSl7bT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsNCk7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKHAsaCxhLGMsbSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxPclN1c3BlbmRcIixTay5taXNjZXZhbC5jYWxsT3JTdXNwZW5kKTtTay5taXNjZXZhbC5jYWxsc2ltPWZ1bmN0aW9uKHAsaCl7aD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5KHAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsaCl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxzaW1cIixTay5taXNjZXZhbC5jYWxsc2ltKTtcblNrLm1pc2NldmFsLmNhbGxzaW1BcnJheT1mdW5jdGlvbihwLGgsYSl7aD1ofHxbXTtyZXR1cm4gU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShwLGgsYSkpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltQXJyYXlcIixTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkpO1NrLm1pc2NldmFsLmNhbGxzaW1Bc3luYz1mdW5jdGlvbihwLGgsYSl7YT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5QXN5bmMocCxoLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGEpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltQXN5bmNcIixTay5taXNjZXZhbC5jYWxsc2ltQXN5bmMpO1NrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQ9ZnVuY3Rpb24ocCxoKXtoPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyxcbjEpO3JldHVybiBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGgpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kXCIsU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZCk7U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5PWZ1bmN0aW9uKHAsaCxhKXtoPWh8fFtdO3JldHVybiB2b2lkIDAhPT1wJiZwLnRwJGNhbGw/cC50cCRjYWxsKGgsYSk6U2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQocCx2b2lkIDAsdm9pZCAwLGEsaCl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheVwiLFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSk7U2subWlzY2V2YWwuYXBwbHk9ZnVuY3Rpb24ocCxoLGEsYyxtKXtwPVNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKHAsaCxhLGMsbSk7cmV0dXJuIHAgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uP1NrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhwKTpcbnB9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFwcGx5XCIsU2subWlzY2V2YWwuYXBwbHkpO1NrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlPWZ1bmN0aW9uKHAsaCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGEsYyl7dHJ5eyhmdW5jdGlvbiBkKG4pe3RyeXtmb3IodmFyIGw9ZnVuY3Rpb24oKXt0cnl7ZChuLnJlc3VtZSgpKX1jYXRjaCh3KXtjKHcpfX0scj1mdW5jdGlvbih3KXt0cnl7bi5kYXRhLnJlc3VsdD13LGwoKX1jYXRjaChDKXtjKEMpfX0sdj1mdW5jdGlvbih3KXt0cnl7bi5kYXRhLmVycm9yPXcsbCgpfWNhdGNoKEMpe2MoQyl9fTtuIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbjspe3ZhciBxPWgmJihoW24uZGF0YS50eXBlXXx8aFtcIipcIl0pO2lmKHEpe3ZhciB0PXEobik7aWYodCl7dC50aGVuKGQsYyk7cmV0dXJufX1pZihcIlNrLnByb21pc2VcIj09bi5kYXRhLnR5cGUpe24uZGF0YS5wcm9taXNlLnRoZW4ocix2KTtyZXR1cm59aWYoXCJTay55aWVsZFwiPT1cbm4uZGF0YS50eXBlKXtTay5nbG9iYWwuc2V0SW1tZWRpYXRlKGwpO3JldHVybn1pZihcIlNrLmRlbGF5XCI9PW4uZGF0YS50eXBlKXtTay5nbG9iYWwuc2V0SW1tZWRpYXRlKGwpO3JldHVybn1pZihuLm9wdGlvbmFsKW49bi5yZXN1bWUoKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlN1c3BlbnNpb25FcnJvcihcIlVuaGFuZGxlZCBub24tb3B0aW9uYWwgc3VzcGVuc2lvbiBvZiB0eXBlICdcIituLmRhdGEudHlwZStcIidcIik7fWEobil9Y2F0Y2godyl7Yyh3KX19KShwKCkpfWNhdGNoKG0pe2MobSl9fSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlXCIsU2subWlzY2V2YWwuYXN5bmNUb1Byb21pc2UpO1NrLm1pc2NldmFsLmFwcGx5QXN5bmM9ZnVuY3Rpb24ocCxoLGEsYyxtLG4pe3JldHVybiBTay5taXNjZXZhbC5hc3luY1RvUHJvbWlzZShmdW5jdGlvbigpe3JldHVybiBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChoLGEsYyxtLG4pfSxwKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuYXBwbHlBc3luY1wiLFxuU2subWlzY2V2YWwuYXBwbHlBc3luYyk7U2subWlzY2V2YWwuY2hhaW49ZnVuY3Rpb24ocCxoKXtmb3IodmFyIGE9MSxjPXAsbSxuOzspe2lmKGE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGM7aWYoYyYmYy4kaXNTdXNwZW5zaW9uKWJyZWFrO2M9YXJndW1lbnRzW2FdKGMpO2ErK31uPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtYSk7Zm9yKG09MDttPGFyZ3VtZW50cy5sZW5ndGgtYTttKyspblttXT1hcmd1bWVudHNbYSttXTttPTA7cmV0dXJuIGZ1bmN0aW9uIHIobCl7Zm9yKDttPG4ubGVuZ3RoOyl7aWYobCBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLlN1c3BlbnNpb24pcmV0dXJuIG5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKHIsbCk7bD1uW21dKGwpO20rK31yZXR1cm4gbH0oYyl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNoYWluXCIsU2subWlzY2V2YWwuY2hhaW4pO1NrLm1pc2NldmFsLnRyeUNhdGNoPWZ1bmN0aW9uKHAsaCl7dHJ5e3ZhciBhPXAoKX1jYXRjaChjKXtyZXR1cm4gaChjKX1yZXR1cm4gYSBpbnN0YW5jZW9mXG5Tay5taXNjZXZhbC5TdXNwZW5zaW9uPyhwPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKHZvaWQgMCxhKSxwLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiBTay5taXNjZXZhbC50cnlDYXRjaChhLnJlc3VtZSxoKX0scCk6YX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwudHJ5Q2F0Y2hcIixTay5taXNjZXZhbC50cnlDYXRjaCk7U2subWlzY2V2YWwuaXRlckZvcj1mdW5jdGlvbihwLGgsYSl7dmFyIGM9YSxtPWZ1bmN0aW9uKG4pe2M9bjtyZXR1cm4gbiBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLkJyZWFrP246cC50cCRpdGVybmV4dCghMCl9O3JldHVybiBmdW5jdGlvbiBsKGQpe2Zvcig7dm9pZCAwIT09ZDspe2lmKGQgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uKXJldHVybiBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbihsLGQpO2lmKGQ9PT1Tay5taXNjZXZhbC5CcmVha3x8ZCBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLkJyZWFrKXJldHVybiBkLmJyVmFsdWU7XG5kPVNrLm1pc2NldmFsLmNoYWluKGgoZCxjKSxtKX1yZXR1cm4gY30ocC50cCRpdGVybmV4dCghMCkpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5pdGVyRm9yXCIsU2subWlzY2V2YWwuaXRlckZvcik7U2subWlzY2V2YWwuaXRlckFycmF5PWZ1bmN0aW9uKHAsaCxhKXtTay5hc3NlcnRzLmFzc2VydChBcnJheS5pc0FycmF5KHApLFwiaXRlckFyZ3MgcmVxdWlyZXMgYW4gYXJyYXlcIik7bGV0IGM9MDtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcih7dHAkaXRlcm5leHQ6KCk9PnBbYysrXX0saCxhKX07U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGU9ZnVuY3Rpb24ocCxoKXtpZih2b2lkIDA9PT1wKXJldHVybltdO2lmKHZvaWQgMD09PXAuaHQkdHlwZSYmdm9pZCAwIT09cC5zayRhc2FycmF5KXJldHVybiBwLnNrJGFzYXJyYXkoKTtjb25zdCBhPVtdO3A9U2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHApLGM9PnthLnB1c2goYyl9KSxcbigpPT5hKTtyZXR1cm4gaD9wOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhwKX07U2subWlzY2V2YWwuQnJlYWs9ZnVuY3Rpb24ocCl7aWYoISh0aGlzIGluc3RhbmNlb2YgU2subWlzY2V2YWwuQnJlYWspKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsocCk7dGhpcy5iclZhbHVlPXB9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLkJyZWFrXCIsU2subWlzY2V2YWwuQnJlYWspO1NrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kPWZ1bmN0aW9uKHAsaCxhLGMsbSl7dmFyIG47aWYobnVsbD09cHx8cD09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUocCkrXCInIG9iamVjdCBpcyBub3QgY2FsbGFibGVcIik7XCJmdW5jdGlvblwiPT09dHlwZW9mIHAmJnZvaWQgMD09PXAudHAkY2FsbCYmKHA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhwKSk7dmFyIGQ9cC50cCRjYWxsO2lmKHZvaWQgMCE9PVxuZCl7aWYoYSlmb3IoYT1hLnRwJGl0ZXIoKSxuPWEudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1uO249YS50cCRpdGVybmV4dCgpKW0ucHVzaChuKTtpZihoKWZvcihhPVNrLmFic3RyLml0ZXIoaCksbj1hLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09bjtuPWEudHAkaXRlcm5leHQoKSl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiRnVuY3Rpb24ga2V5d29yZHMgbXVzdCBiZSBzdHJpbmdzXCIpO2MucHVzaChuLnYpO2MucHVzaChTay5hYnN0ci5vYmplY3RHZXRJdGVtKGgsbiwhMSkpfXJldHVybiBkLmNhbGwocCxtLGMsaCl9ZD1wLl9fY2FsbF9fO2lmKHZvaWQgMCE9PWQpcmV0dXJuIG0udW5zaGlmdChwKSxTay5taXNjZXZhbC5hcHBseShkLGgsYSxjLG0pO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShwKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kXCIsXG5Tay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZCk7U2subWlzY2V2YWwucHJvbWlzZVRvU3VzcGVuc2lvbj1mdW5jdGlvbihwKXt2YXIgaD1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbjtoLnJlc3VtZT1mdW5jdGlvbigpe2lmKGguZGF0YS5lcnJvcil0aHJvdyBoLmRhdGEuZXJyb3I7cmV0dXJuIGguZGF0YS5yZXN1bHR9O2guZGF0YT17dHlwZTpcIlNrLnByb21pc2VcIixwcm9taXNlOnB9O3JldHVybiBofTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5wcm9taXNlVG9TdXNwZW5zaW9uXCIsU2subWlzY2V2YWwucHJvbWlzZVRvU3VzcGVuc2lvbik7U2subWlzY2V2YWwuYnVpbGRDbGFzcz1mdW5jdGlvbihwLGgsYSxjLG0sbil7YT1uZXcgU2suYnVpbHRpbi5zdHIoYSk7Y29uc3QgZD1uZXcgU2suYnVpbHRpbi50dXBsZShjKTtuPW58fFtdO2M9Y3x8W107bGV0IGw7dmFyIHI9ITA7Y29uc3Qgdj1uLmluZGV4T2YoXCJtZXRhY2xhc3NcIik7LTE8dj8obD1uW3YrMV0sblt2XT1uW24ubGVuZ3RoLVxuMl0sblt2KzFdPW5bbi5sZW5ndGgtMV0sbi5wb3AoKSxuLnBvcCgpLHI9U2suYnVpbHRpbi5jaGVja0NsYXNzKGwpKTpsPWMubGVuZ3RoP2NbMF0ub2IkdHlwZTpTay5idWlsdGluLnR5cGU7ciYmKGw9ZyhsLGMpKTtsZXQgcT1udWxsO2whPT1Tay5idWlsdGluLnR5cGUmJihbcSx3XT1rKGwsYSxkLG4scikpO2M9ITE7bGV0IHQ9e307aWYobnVsbD09PXEpcT1uZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtlbHNlIGlmKHEuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmRpY3R8fGUoKSl7dmFyIHc9U2suYWJzdHIuaXRlcihTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkocS50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRrZXlzKSkpO2ZvcihyPXcudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1yO3I9dy50cCRpdGVybmV4dCgpKVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcocikmJih0W3IudG9TdHJpbmcoKV09cS5tcCRzdWJzY3JpcHQocikpfWVsc2UgdD1uZXcgUHJveHkocSx3KSxjPSEwO3AuX19uYW1lX18mJlxuKHQuX19tb2R1bGVfXz1wLl9fbmFtZV9fKTtoKHAsdCx2b2lkIDA9PT1tP3t9Om0pO2N8fE9iamVjdC5rZXlzKHQpLmZvckVhY2goQz0+e1NrLmFic3RyLm9iamVjdFNldEl0ZW0ocSxuZXcgU2suYnVpbHRpbi5zdHIoQyksdFtDXSl9KTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGwsW2EsZCxxXSxuKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuYnVpbGRDbGFzc1wiLFNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MpfSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4uY2FsbGFibGVfaXRlcl89U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiY2FsbGFibGVfaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYixmKXtpZighU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIml0ZXIodiwgdyk6IHYgbXVzdCBiZSBjYWxsYWJsZVwiKTt0aGlzLiRjYWxsYWJsZT1iO3RoaXMuJHNlbnRpbmVsPWY7XG50aGlzLiRmbGFnPSExfSxpdGVybmV4dChiKXtpZighMCE9PXRoaXMuJGZsYWcpe2lmKGIpcmV0dXJuIGI9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHRoaXMuJGNhbGxhYmxlLFtdKSxTay5taXNjZXZhbC5jaGFpbihiLGY9PntpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZix0aGlzLiRzZW50aW5lbCxcIkVxXCIsITApKXRoaXMuJGZsYWc9ITA7ZWxzZSByZXR1cm4gZn0pO2I9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMuJGNhbGxhYmxlLFtdKTtpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYix0aGlzLiRzZW50aW5lbCxcIkVxXCIsITEpKXRoaXMuJGZsYWc9ITA7ZWxzZSByZXR1cm4gYn19LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pO1NrLmJ1aWx0aW4uc2VxX2l0ZXJfPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcIml0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWJ9LFxuaXRlcm5leHQoYil7bGV0IGY7Zj1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+dGhpcy4kc2VxLm1wJHN1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuJGluZGV4KyspLGIpLGU9PntpZihlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5JbmRleEVycm9yfHxlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uKXRoaXMuZ2kkcmV0PWUuJHZhbHVlfHxTay5idWlsdGluLm5vbmUubm9uZSQ7ZWxzZSB0aHJvdyBlO30pO3JldHVybiBiP2Y6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGYpfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186eyRmbGFnczp7Tm9BcmdzOiEwfSwkbWV0aCgpe2lmKHRoaXMuJHNlcS5zcSRsZW5ndGgpcmV0dXJuIHRoaXMuJHNlcS5zcSRsZW5ndGgoKS10aGlzLiRpbmRleDt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwibGVuIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcy4kc2VxKSk7XG59fX0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jYWxsYWJsZV9pdGVyX1wiLFNrLmJ1aWx0aW4uY2FsbGFibGVfaXRlcl8pfSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4ubGlzdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwibGlzdFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihlKXt2b2lkIDA9PT1lP2U9W106QXJyYXkuaXNBcnJheShlKXx8KGU9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZSkpO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmxpc3QsXCJiYWQgY2FsbCB0byBsaXN0LCB1c2UgJ25ldycgd2l0aCBhbiBBcnJheSBvZiBweXRob24gb2JqZWN0c1wiKTt0aGlzLnY9ZTt0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGhhc2g6U2suYnVpbHRpbi5ub25lLm5vbmUkLFxudHAkZG9jOlwiQnVpbHQtaW4gbXV0YWJsZSBzZXF1ZW5jZS5cXG5cXG5JZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGNvbnN0cnVjdG9yIGNyZWF0ZXMgYSBuZXcgZW1wdHkgbGlzdC5cXG5UaGUgYXJndW1lbnQgbXVzdCBiZSBhbiBpdGVyYWJsZSBpZiBzcGVjaWZpZWQuXCIsdHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoZSxnKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwibGlzdFwiLGcpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcImxpc3RcIixlLDAsMSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGVbMF0sITApLGs9Pnt0aGlzLnY9a30pfSwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiWy4uLl1cIik7dGhpcy5pbiRyZXByPSEwO2NvbnN0IGU9dGhpcy52Lm1hcChnPT5Tay5taXNjZXZhbC5vYmplY3RSZXByKGcpKTt0aGlzLmluJHJlcHI9ITE7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIltcIitcbmUuam9pbihcIiwgXCIpK1wiXVwiKX0sdHAkcmljaGNvbXBhcmU6U2suZ2VuZXJpYy5zZXFDb21wYXJlLHRwJGl0ZXIoKXtyZXR1cm4gbmV3IGIodGhpcyl9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLnYubGVuZ3RofSxzcSRjb25jYXQoZSl7aWYoIShlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4gb25seSBjb25jYXRlbmF0ZSBsaXN0IHRvIGxpc3RcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QodGhpcy52LmNvbmNhdChlLnYpKX0sc3EkY29udGFpbnMoZSl7Zm9yKGxldCBnPXRoaXMudHAkaXRlcigpLGs9Zy50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWs7az1nLnRwJGl0ZXJuZXh0KCkpaWYoaz09PWV8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChrLGUsXCJFcVwiKSlyZXR1cm4hMDtyZXR1cm4hMX0sc3EkcmVwZWF0KGUpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAnXCIrXG5Tay5hYnN0ci50eXBlTmFtZShlKStcIidcIik7ZT1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZSxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2lmKGUqdGhpcy52Lmxlbmd0aD5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yO2NvbnN0IGc9W107Zm9yKGxldCBrPTA7azxlO2srKylmb3IobGV0IHA9MDtwPHRoaXMudi5sZW5ndGg7cCsrKWcucHVzaCh0aGlzLnZbcF0pO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGcpfSxtcCRzdWJzY3JpcHQoZSl7aWYoU2subWlzY2V2YWwuaXNJbmRleChlKSlyZXR1cm4gZT1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZSxTay5idWlsdGluLkluZGV4RXJyb3IpLGU9dGhpcy5saXN0JGluUmFuZ2UoZSxcImxpc3QgaW5kZXggb3V0IG9mIHJhbmdlXCIpLHRoaXMudltlXTtpZihlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zbGljZSl7Y29uc3QgZz1bXTtlLnNzc2l0ZXIkKHRoaXMudi5sZW5ndGgsXG5rPT57Zy5wdXNoKHRoaXMudltrXSl9KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChnKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJsaXN0IGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBzbGljZXMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShlKSk7fSxtcCRhc3Nfc3Vic2NyaXB0KGUsZyl7dm9pZCAwPT09Zz90aGlzLmRlbCRzdWJzY3JpcHQoZSk6dGhpcy5hc3Mkc3Vic2NyaXB0KGUsZyl9LHNxJGlucGxhY2VfY29uY2F0KGUpe3JldHVybiBlPT09dGhpcz8odGhpcy52LnB1c2goLi4udGhpcy52KSx0aGlzKTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoZSksZz0+e3RoaXMudi5wdXNoKGcpfSksKCk9PnRoaXMpfSxzcSRpbnBsYWNlX3JlcGVhdChlKXtpZighU2subWlzY2V2YWwuaXNJbmRleChlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ1wiK1xuU2suYWJzdHIudHlwZU5hbWUoZSkrXCInXCIpO2U9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGUsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtjb25zdCBnPXRoaXMudi5sZW5ndGg7aWYoMD49ZSl0aGlzLnYubGVuZ3RoPTA7ZWxzZSBpZihlKmc+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcjtmb3IobGV0IGs9MTtrPGU7aysrKWZvcihsZXQgcD0wO3A8ZztwKyspdGhpcy52LnB1c2godGhpcy52W3BdKTtyZXR1cm4gdGhpc319LG1ldGhvZHM6e19fcmV2ZXJzZWRfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IGYodGhpcyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBsaXN0LlwifSxjbGVhcjp7JG1ldGgoKXt0aGlzLnYubGVuZ3RoPTA7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLFxuJGRvYzpcIlJlbW92ZSBhbGwgaXRlbXMgZnJvbSBsaXN0LlwifSxjb3B5OnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMudi5zbGljZSgwKSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBsaXN0LlwifSxhcHBlbmQ6eyRtZXRoKGUpe3RoaXMudi5wdXNoKGUpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgb2JqZWN0LCAvKVwiLCRkb2M6XCJBcHBlbmQgb2JqZWN0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXCJ9LGluc2VydDp7JG1ldGgoZSxnKXtlPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChlLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7KHtzdGFydDplfT1Tay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydCh0aGlzLGUpKTt0aGlzLnYuc3BsaWNlKGUsMCxnKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSxcbiRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJHNlbGYsIGluZGV4LCBvYmplY3QsIC8pXCIsJGRvYzpcIkluc2VydCBvYmplY3QgYmVmb3JlIGluZGV4LlwifSxleHRlbmQ6eyRtZXRoKGUpe3JldHVybiBlPT09dGhpcz8odGhpcy52LnB1c2goLi4udGhpcy52KSxTay5idWlsdGluLm5vbmUubm9uZSQpOlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihlKSxnPT57dGhpcy52LnB1c2goZyl9KSwoKT0+U2suYnVpbHRpbi5ub25lLm5vbmUkKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBpdGVyYWJsZSwgLylcIiwkZG9jOlwiRXh0ZW5kIGxpc3QgYnkgYXBwZW5kaW5nIGVsZW1lbnRzIGZyb20gdGhlIGl0ZXJhYmxlLlwifSxwb3A6eyRtZXRoKGUpe2U9dm9pZCAwPT09ZT90aGlzLnYubGVuZ3RoLTE6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGUsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtlPXRoaXMubGlzdCRpblJhbmdlKGUsXG5cInBvcCBpbmRleCBvdXQgb2YgcmFuZ2VcIik7Y29uc3QgZz10aGlzLnZbZV07dGhpcy52LnNwbGljZShlLDEpO3JldHVybiBnfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBpbmRleD0tMSwgLylcIiwkZG9jOlwiUmVtb3ZlIGFuZCByZXR1cm4gaXRlbSBhdCBpbmRleCAoZGVmYXVsdCBsYXN0KS5cXG5cXG5SYWlzZXMgSW5kZXhFcnJvciBpZiBsaXN0IGlzIGVtcHR5IG9yIGluZGV4IGlzIG91dCBvZiByYW5nZS5cIn0scmVtb3ZlOnskbWV0aChlKXtlPXRoaXMubGlzdCRpbmRleE9mKGUpO2lmKC0xPT09ZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibGlzdC5yZW1vdmUoeCk6IHggbm90IGluIGxpc3RcIik7dGhpcy52LnNwbGljZShlLDEpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGRvYzpcIlJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHZhbHVlLlxcblxcblJhaXNlcyBWYWx1ZUVycm9yIGlmIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudC5cIn0sXG5zb3J0OnskbWV0aChlLGcpe2lmKGUubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNvcnQoKSB0YWtlcyBubyBwb3NpdGlvbmFsIGFyZ3VtZW50c1wiKTtjb25zdCBbayxwXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcInNvcnRcIixbXCJrZXlcIixcInJldmVyc2VcIl0sZSxnLFtTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ib29sLmZhbHNlJF0pO3JldHVybiB0aGlzLmxpc3Qkc29ydCh2b2lkIDAsayxwKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8sICosIGtleT1Ob25lLCByZXZlcnNlPUZhbHNlKVwiLCRkb2M6XCJTdGFibGUgc29ydCAqSU4gUExBQ0UqLlwifSxpbmRleDp7JG1ldGgoZSxnLGspe2lmKHZvaWQgMCE9PWcmJiFTay5taXNjZXZhbC5pc0luZGV4KGcpfHx2b2lkIDAhPT1rJiYhU2subWlzY2V2YWwuaXNJbmRleChrKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpO1xuZz10aGlzLmxpc3QkaW5kZXhPZihlLGcsayk7aWYoLTE9PT1nKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoU2subWlzY2V2YWwub2JqZWN0UmVwcihlKStcIiBpcyBub3QgaW4gbGlzdFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhnKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIHN0YXJ0PTAsIHN0b3A9c3lzLm1heHNpemUsIC8pXCIsJGRvYzpcIlJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZS5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciBpZiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQuXCJ9LGNvdW50OnskbWV0aChlKXtsZXQgZz0wO2NvbnN0IGs9dGhpcy52Lmxlbmd0aDtmb3IobGV0IHA9MDtwPGs7cCsrKWlmKHRoaXMudltwXT09PWV8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLnZbcF0sZSxcIkVxXCIpKWcrPTE7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZyl9LCRmbGFnczp7T25lQXJnOiEwfSxcbiR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZG9jOlwiUmV0dXJuIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB2YWx1ZS5cIn0scmV2ZXJzZTp7JG1ldGgoKXt0aGlzLmxpc3QkcmV2ZXJzZSgpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV2ZXJzZSAqSU4gUExBQ0UqLlwifX0sY2xhc3NtZXRob2RzOlNrLmdlbmVyaWMuY2xhc3NHZXRJdGVtLHByb3RvOntzayRhc2FycmF5KCl7cmV0dXJuIHRoaXMudi5zbGljZSgwKX0sbGlzdCRzb3J0OmZ1bmN0aW9uKGUsZyxrKXtjb25zdCBwPW51bGwhPWcmJmchPT1Tay5idWlsdGluLm5vbmUubm9uZSQ7dmFyIGg9bnVsbCE9ZSYmZSE9PVNrLmJ1aWx0aW4ubm9uZS5ub25lJDtsZXQgYTtpZih2b2lkIDA9PT1rKWE9ITE7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrSW50KGspKWE9U2subWlzY2V2YWwuaXNUcnVlKGspO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTtcbms9bmV3IFNrLmJ1aWx0aW4udGltU29ydCh0aGlzKTt0aGlzLnY9W107Y29uc3QgYz1uZXcgU2suYnVpbHRpbi5pbnRfKDApO2lmKHApe2subHQ9aD9mdW5jdGlvbihtLG4pe209U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUsW21bMF0sblswXV0pO3JldHVybiBTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wobSxjLFwiTHRcIil9OmZ1bmN0aW9uKG0sbil7cmV0dXJuIFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChtWzBdLG5bMF0sXCJMdFwiKX07Zm9yKGxldCBtPTA7bTxrLmxpc3RsZW5ndGg7bSsrKXtoPWsubGlzdC52W21dO2NvbnN0IG49U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGcsW2hdKTtrLmxpc3QudlttXT1bbixoXX19ZWxzZSBoJiYoay5sdD1mdW5jdGlvbihtLG4pe209U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUsW20sbl0pO3JldHVybiBTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wobSxjLFwiTHRcIil9KTthJiZrLmxpc3QubGlzdCRyZXZlcnNlKCk7ay5zb3J0KCk7XG5hJiZrLmxpc3QubGlzdCRyZXZlcnNlKCk7aWYocClmb3IoZz0wO2c8ay5saXN0bGVuZ3RoO2crKyloPWsubGlzdC52W2ddWzFdLGsubGlzdC52W2ddPWg7Zz0wPHRoaXMuc3EkbGVuZ3RoKCk7dGhpcy52PWsubGlzdC52O2lmKGcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImxpc3QgbW9kaWZpZWQgZHVyaW5nIHNvcnRcIik7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sbGlzdCRpblJhbmdlKGUsZyl7MD5lJiYoZSs9dGhpcy52Lmxlbmd0aCk7aWYoMDw9ZSYmZTx0aGlzLnYubGVuZ3RoKXJldHVybiBlO3Rocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoZyk7fSxsaXN0JGluZGV4T2YoZSxnLGspe2Zvcih7c3RhcnQ6ZyxlbmQ6a309U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxnLGspO2c8ayYmZzx0aGlzLnYubGVuZ3RoO2crKylpZih0aGlzLnZbZ109PT1lfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy52W2ddLGUsXCJFcVwiKSlyZXR1cm4gZztcbnJldHVybi0xfSxsaXN0JHJldmVyc2UoKXt0aGlzLnYucmV2ZXJzZSgpfSxhc3Mkc3Vic2NyaXB0KGUsZyl7aWYoU2subWlzY2V2YWwuaXNJbmRleChlKSl0aGlzLmFzcyRpbmRleChlLGcpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2xpY2Upe2NvbnN0IHtzdGFydDprLHN0b3A6cCxzdGVwOmh9PWUuc2xpY2UkaW5kaWNlcyh0aGlzLnYubGVuZ3RoKTsxPT09aD90aGlzLmFzcyRzbGljZShrLHAsZyk6dGhpcy5hc3MkZXh0X3NsaWNlKGUsZyl9ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJsaXN0IGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBzbGljZXMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShlKSk7fSxhc3MkaW5kZXgoZSxnKXtlPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChlLFNrLmJ1aWx0aW4uSW5kZXhFcnJvcik7ZT10aGlzLmxpc3QkaW5SYW5nZShlLFwibGlzdCBhc3NpZ25tZW50IGluZGV4IG91dCBvZiByYW5nZVwiKTt0aGlzLnZbZV09XG5nfSxhc3Mkc2xpY2UoZSxnLGspe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoaykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgYXNzaWduIGFuIGl0ZXJhYmxlXCIpO2s9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoayk7dGhpcy52LnNwbGljZShlLGctZSwuLi5rKX0sYXNzJGV4dF9zbGljZShlLGcpe2NvbnN0IGs9W107ZS5zc3NpdGVyJCh0aGlzLnYubGVuZ3RoLHA9PntrLnB1c2gocCl9KTtpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGcpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm11c3QgYXNzaWduIGl0ZXJhYmxlIHRvIGV4dGVuZGVkIHNsaWNlXCIpO2U9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZyk7aWYoay5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiYXR0ZW1wdCB0byBhc3NpZ24gc2VxdWVuY2Ugb2Ygc2l6ZSBcIitlLmxlbmd0aCtcIiB0byBleHRlbmRlZCBzbGljZSBvZiBzaXplIFwiK1xuay5sZW5ndGgpO2ZvcihnPTA7ZzxrLmxlbmd0aDtnKyspdGhpcy52LnNwbGljZShrW2ddLDEsZVtnXSl9LGRlbCRzdWJzY3JpcHQoZSl7aWYoU2subWlzY2V2YWwuaXNJbmRleChlKSl0aGlzLmRlbCRpbmRleChlKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBTay5idWlsdGluLnNsaWNlKXtjb25zdCB7c3RhcnQ6ZyxzdG9wOmssc3RlcDpwfT1lLnNsaWNlJGluZGljZXModGhpcy52Lmxlbmd0aCk7MT09PXA/dGhpcy5kZWwkc2xpY2UoZyxrKTp0aGlzLmRlbCRleHRfc2xpY2UoZSwwPHA/MTowKX1lbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImxpc3QgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZSkpO30sZGVsJGluZGV4KGUpe2U9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGUsU2suYnVpbHRpbi5JbmRleEVycm9yKTtlPXRoaXMubGlzdCRpblJhbmdlKGUsXCJsaXN0IGFzc2lnbm1lbnQgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xudGhpcy52LnNwbGljZShlLDEpfSxkZWwkc2xpY2UoZSxnKXt0aGlzLnYuc3BsaWNlKGUsZy1lKX0sZGVsJGV4dF9zbGljZShlLGcpe2xldCBrPTA7ZS5zc3NpdGVyJCh0aGlzLnYubGVuZ3RoLHA9Pnt0aGlzLnYuc3BsaWNlKHAtaywxKTtrKz1nfSl9LHZhbHVlT2YoKXtyZXR1cm4gdGhpcy52fX19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmxpc3RcIixTay5idWlsdGluLmxpc3QpO1NrLmJ1aWx0aW4ubGlzdC5weTIkbWV0aG9kcz17c29ydDp7JG5hbWU6XCJzb3J0XCIsJG1ldGgoZSxnKXtjb25zdCBbayxwLGhdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwic29ydFwiLFtcImNtcFwiLFwia2V5XCIsXCJyZXZlcnNlXCJdLGUsZyxbU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLmJvb2wuZmFsc2UkXSk7cmV0dXJuIHRoaXMubGlzdCRzb3J0KGsscCxoKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGNtcD1Ob25lLCBrZXk9Tm9uZSwgcmV2ZXJzZT1GYWxzZSlcIixcbiRkb2M6XCJTdGFibGUgc29ydCAqSU4gUExBQ0UqLlwifX07dmFyIGI9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwibGlzdF9pdGVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihlKXt0aGlzLiRpbmRleD0wO3RoaXMuJHNlcT1lLnZ9LGl0ZXJuZXh0OlNrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXksbWV0aG9kczp7X19sZW5ndGhfaGludF9fOlNrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWZ9LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pLGY9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwibGlzdF9yZXZlcnNlaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZSl7dGhpcy4kaW5kZXg9ZS52Lmxlbmd0aC0xO3RoaXMuJHNlcT1lLnZ9LGl0ZXJuZXh0KCl7Y29uc3QgZT10aGlzLiRzZXFbdGhpcy4kaW5kZXgtLV07aWYodm9pZCAwPT09ZSl0aGlzLnRwJGl0ZXJuZXh0PSgpPT57fTtlbHNlIHJldHVybiBlfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyUmV2ZXJzZUxlbmd0aEhpbnRNZXRob2REZWZ9LFxuZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSl9LGZ1bmN0aW9uKEUsUSxiKXtmdW5jdGlvbiBmKHgpe3ZhciBCPXgucmVwbGFjZShELFwiXCIpLnJlcGxhY2UoTCxcIl9cIikudG9Mb3dlckNhc2UoKTtCPUNbQl07cmV0dXJuIHZvaWQgMD09PUI/eDpCfWZ1bmN0aW9uIGUoeCxCLEYpe2lmKHZvaWQgMD09PUIpQj1cInV0Zi04XCI7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKEIpKUI9Qi4kanNzdHIoKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih4K1wiKCkgYXJndW1lbnQgXCIrKFwiYnl0ZXNzdHJcIi5pbmNsdWRlcyh4KT8yOjEpK1wiIG11c3QgYmUgc3RyIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShCKSk7aWYodm9pZCAwPT09RilGPVwic3RyaWN0XCI7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKEYpKUY9Ri4kanNzdHIoKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih4K1wiKCkgYXJndW1lbnQgXCIrKFwiYnl0ZXNzdHJcIi5pbmNsdWRlcyh4KT9cbjM6MikrXCIgbXVzdCBiZSBzdHIgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKEYpKTtyZXR1cm57ZW5jb2Rpbmc6QixlcnJvcnM6Rn19ZnVuY3Rpb24gZyh4LEIsRil7eD14LiRqc3N0cigpO0I9ZihCKTtpZihcInN0cmljdFwiIT09RiYmXCJpZ25vcmVcIiE9PUYmJlwicmVwbGFjZVwiIT09Ril0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiJ1wiK0YrXCInIGVycm9yIGhhbmRsaW5nIG5vdCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcIik7aWYoXCJhc2NpaVwiPT09Qil7Qj1bXTtmb3IoSiBpbiB4KXtjb25zdCBQPXguY2hhckNvZGVBdChKKTtpZigxMjc8UCl7aWYoXCJzdHJpY3RcIj09PUYpdGhyb3cgRj1rKFApLG5ldyBTay5idWlsdGluLlVuaWNvZGVFbmNvZGVFcnJvcihcIidhc2NpaScgY29kZWMgY2FuJ3QgZW5jb2RlIGNoYXJhY3RlciAnXCIrRitcIicgaW4gcG9zaXRpb24gXCIrSitcIjogb3JkaW5hbCBub3QgaW4gcmFuZ2UoMTI4KVwiKTtcInJlcGxhY2VcIj09PUYmJkIucHVzaCg2Myl9ZWxzZSBCLnB1c2goUCl9dmFyIEo9XG5uZXcgVWludDhBcnJheShCKX1lbHNlIGlmKFwidXRmLThcIj09PUIpSj1OLmVuY29kZSh4KTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLkxvb2t1cEVycm9yKFwidW5rbm93biBlbmNvZGluZzogXCIrQik7cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKEopfWZ1bmN0aW9uIGsoeCl7dmFyIEI9MjY1Pj14P1wiXFxcXHhcIjpcIlxcXFx1XCI7eD14LnRvU3RyaW5nKDE2KTszPT09eC5sZW5ndGgmJih4PXguc2xpY2UoMSwzKSk7cmV0dXJuIHg9MT09PXgubGVuZ3RoP0IrXCIwXCIreDpCK3h9ZnVuY3Rpb24gcCh4LEIpeyh7ZW5jb2Rpbmc6eCxlcnJvcnM6Qn09ZShcImRlY29kZVwiLHgsQikpO3g9Zih4KTtpZihcInN0cmljdFwiIT09QiYmXCJpZ25vcmVcIiE9PUImJlwicmVwbGFjZVwiIT09Qil0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiJ1wiK0IrXCInIGVycm9yIGhhbmRsaW5nIG5vdCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcIik7aWYoXCJhc2NpaVwiPT09eCl7eD10aGlzLnY7dmFyIEY9XCJcIjtcbmZvcihsZXQgSj0wO0o8eC5sZW5ndGg7SisrKXtjb25zdCBQPXhbSl07aWYoMTI3PFApe2lmKFwic3RyaWN0XCI9PT1CKXRocm93IG5ldyBTay5idWlsdGluLlVuaWNvZGVEZWNvZGVFcnJvcihcIidhc2NpaScgY29kZWMgY2FuJ3QgZGVjb2RlIGJ5dGUgMHhcIitQLnRvU3RyaW5nKDE2KStcIiBpbiBwb3NpdGlvbiBcIitKK1wiOiBvcmRpbmFsIG5vdCBpbiByYW5nZSgxMjgpXCIpO1wicmVwbGFjZVwiPT09QiYmKEYrPVN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzMpKX1lbHNlIEYrPVN0cmluZy5mcm9tQ2hhckNvZGUoUCl9eD1GfWVsc2UgaWYoXCJ1dGYtOFwiPT09eClhOmlmKHg9dGhpcy52LEY9QixCPUEuZGVjb2RlKHgpLFwicmVwbGFjZVwiPT09Ril4PUI7ZWxzZXtpZihcInN0cmljdFwiPT09Ril7Rj1CLmluZGV4T2YoXCJcXHVmZmZkXCIpO2lmKC0xPT09Ril7eD1CO2JyZWFrIGF9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yKFwiJ3V0Zi04JyBjb2RlYyBjYW4ndCBkZWNvZGUgYnl0ZSAweFwiK1xueFtGXS50b1N0cmluZygxNikrXCIgaW4gcG9zaXRpb24gXCIrRitcIjogaW52YWxpZCBzdGFydCBieXRlXCIpO314PUIucmVwbGFjZSgvXFx1ZmZmZC9nLFwiXCIpfWVsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTG9va3VwRXJyb3IoXCJ1bmtub3duIGVuY29kaW5nOiBcIit4KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHgpfWZ1bmN0aW9uIGgoeCxCKXtyZXR1cm4gZnVuY3Rpb24oRixKLFApe2lmKCEoRiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXN8fEYgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoeCtcIiBmaXJzdCBhcmcgbXVzdCBiZSBieXRlcyBvciBhIHR1cGxlIG9mIGJ5dGVzLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoRikpOyh7c3RhcnQ6SixlbmQ6UH09U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxKLFApKTtpZihQPEopcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7Sj10aGlzLnYuc3ViYXJyYXkoSixcblApO2lmKEYgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKXtmb3IobGV0IFc9U2suYWJzdHIuaXRlcihGKSxjYT1XLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09Y2E7Y2E9Vy50cCRpdGVybmV4dCgpKWlmKGNhPXRoaXMuZ2V0JHJhdyhjYSksQihKLGNhKSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO3JldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkfXJldHVybiBCKEosRi52KT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH19ZnVuY3Rpb24gYSh4KXtyZXR1cm4gZnVuY3Rpb24oQixGLEope0I9dGhpcy5nZXQkdGd0KEIpOyh7c3RhcnQ6RixlbmQ6Sn09U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxGLEopKTtyZXR1cm4gSjxGPy0xOlwibnVtYmVyXCI9PT10eXBlb2YgQj8oQj14P3RoaXMudi5sYXN0SW5kZXhPZihCLEotMSk6dGhpcy52LmluZGV4T2YoQixGKSxCPj1GJiZCPEo/QjotMSk6eD90aGlzLmZpbmQkc3VicmlnaHQoQixcbkYsSik6dGhpcy5maW5kJHN1YmxlZnQoQixGLEopfX1mdW5jdGlvbiBjKHgpe3JldHVybiBmdW5jdGlvbihCKXtCPXRoaXMuZ2V0JHJhdyhCKTtsZXQgRjtpZih4KXtpZihGPXRoaXMuZmluZCRzdWJyaWdodChCLDAsdGhpcy52Lmxlbmd0aCksMD5GKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uYnl0ZXMsbmV3IFNrLmJ1aWx0aW4uYnl0ZXMsdGhpc10pfWVsc2UgaWYoRj10aGlzLmZpbmQkc3VibGVmdChCLDAsdGhpcy52Lmxlbmd0aCksMD5GKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbdGhpcyxuZXcgU2suYnVpbHRpbi5ieXRlcyxuZXcgU2suYnVpbHRpbi5ieXRlc10pO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KDAsRikpLG5ldyBTay5idWlsdGluLmJ5dGVzKEIpLG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShGK0IubGVuZ3RoKSldKX19ZnVuY3Rpb24gbSh4LFxuQil7cmV0dXJuIGZ1bmN0aW9uKEYpe3ZhciBKPXZvaWQgMD09PUZ8fEY9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/bmV3IFVpbnQ4QXJyYXkoWzksMTAsMTEsMTIsMTMsMzIsMTMzXSk6dGhpcy5nZXQkcmF3KEYpO0Y9MDt2YXIgUD10aGlzLnYubGVuZ3RoO2lmKHgpZm9yKDtGPFAmJkouaW5jbHVkZXModGhpcy52W0ZdKTspRisrO2lmKEIpZm9yKDtQPkYmJkouaW5jbHVkZXModGhpcy52W1AtMV0pOylQLS07Sj1uZXcgVWludDhBcnJheShQLUYpO2ZvcihQPTA7UDxKLmxlbmd0aDtQKyspSltQXT10aGlzLnZbUCtGXTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoSil9fWZ1bmN0aW9uIG4oeCxCLEYpe3JldHVybiBmdW5jdGlvbihKLFApe2lmKHZvaWQgMD09PVApUD0zMjtlbHNlIGlmKFAgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzJiYxPT1QLnYubGVuZ3RoKVA9UC52WzBdO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHgrXCIoKSBhcmd1bWVudCAyIG11c3QgYmUgYSBieXRlIHN0cmluZyBvZiBsZW5ndGggMSwgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUoUCkpO2NvbnN0IFc9dGhpcy52Lmxlbmd0aDtKPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChKLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoSjw9VylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52KTtjb25zdCBjYT1uZXcgVWludDhBcnJheShKKTtsZXQgaGEsb2E7Rj8oaGE9TWF0aC5mbG9vcigoSi1XKS8yKSxvYT0oSi1XKSUyP2hhKzE6aGEpOkI/KGhhPUotVyxvYT0wKTooaGE9MCxvYT1KLVcpO2NhLmZpbGwoUCwwLGhhKTtmb3IobGV0IGthPTA7a2E8VztrYSsrKWNhW2thK2hhXT10aGlzLnZba2FdO2NhLmZpbGwoUCxKLW9hKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoY2EpfX1mdW5jdGlvbiBkKHgpe3JldHVybiA5PD14JiYxMz49eHx8MzI9PT14fWZ1bmN0aW9uIGwoeCl7cmV0dXJuIDk3PD14JiYxMjI+PXh9ZnVuY3Rpb24gcih4KXtyZXR1cm4gNjU8PXgmJjkwPj14fWZ1bmN0aW9uIHYoeCl7cmV0dXJuIDQ4PD14JiZcbjU3Pj14fWZ1bmN0aW9uIHEoeCxCKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMudi5sZW5ndGg/Qj9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJDp0aGlzLnYuZXZlcnkoRj0+eChGKSk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9fWZ1bmN0aW9uIHQoeCxCKXtyZXR1cm4gZnVuY3Rpb24oKXtsZXQgRj0hMTtmb3IobGV0IEo9MDtKPHRoaXMudi5sZW5ndGg7SisrKXtpZihCKHRoaXMudltKXSkpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7IUYmJngodGhpcy52W0pdKSYmKEY9ITApfXJldHVybiBGP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfX1mdW5jdGlvbiB3KHgpe3JldHVybiBmdW5jdGlvbigpe2NvbnN0IEI9bmV3IFVpbnQ4QXJyYXkodGhpcy52Lmxlbmd0aCk7Zm9yKGxldCBGPTA7Rjx0aGlzLnYubGVuZ3RoO0YrKylCW0ZdPXgodGhpcy52W0ZdKTtcbnJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhCKX19YigzMCk7Y29uc3QgQz17dXRmOlwidXRmLThcIix1dGY4OlwidXRmLThcIix1dGZfODpcInV0Zi04XCIsYXNjaWk6XCJhc2NpaVwifTt2YXIgRD0vXFxzKy9nLEw9L1tfLV0rL2c7Y29uc3QgTj1uZXcgVGV4dEVuY29kZXIsQT1uZXcgVGV4dERlY29kZXI7U2suYnVpbHRpbi5ieXRlcz1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiYnl0ZXNcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oeCl7aWYoISh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ieXRlcykpdGhyb3cgbmV3IFR5cGVFcnJvcihcImJ5dGVzIGlzIGEgY29uc3RydWN0b3IgdXNlICduZXcnXCIpO2lmKHZvaWQgMD09PXgpdGhpcy52PW5ldyBVaW50OEFycmF5O2Vsc2UgaWYoeCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdGhpcy52PXg7ZWxzZSBpZihBcnJheS5pc0FycmF5KHgpKVNrLmFzc2VydHMuYXNzZXJ0KHguZXZlcnkoQj0+MDw9QiYmMjU1Pj1CKSxcImJhZCBpbnRlcm5hbCBjYWxsIHRvIGJ5dGVzIHdpdGggYXJyYXlcIiksXG50aGlzLnY9bmV3IFVpbnQ4QXJyYXkoeCk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIHgpe2xldCBCO2NvbnN0IEY9bmV3IFVpbnQ4QXJyYXkoeC5sZW5ndGgpLEo9eC5sZW5ndGg7Zm9yKGxldCBQPTA7UDxKO1ArKyl7Qj14LmNoYXJDb2RlQXQoUCk7aWYoMjU1PEIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yKFwiaW52YWxpZCBzdHJpbmcgYXQgaW5kZXggXCIrUCtcIiAocG9zc2libHkgY29udGFpbnMgYSB1bmljb2RlIGNoYXJhY3RlcilcIik7RltQXT1CfXRoaXMudj1GfWVsc2UgaWYoXCJudW1iZXJcIj09PXR5cGVvZiB4KXRoaXMudj1uZXcgVWludDhBcnJheSh4KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYGJhZCBpbnRlcm5hbCBhcmd1bWVudCB0byBieXRlcyBjb25zdHJ1Y3RvciAoZ290ICcke3R5cGVvZiB4fSc6ICR7eH0pYCk7fSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkZG9jOlwiYnl0ZXMoaXRlcmFibGVfb2ZfaW50cykgLT4gYnl0ZXNcXG5ieXRlcyhzdHJpbmcsIGVuY29kaW5nWywgZXJyb3JzXSkgLT4gYnl0ZXNcXG5ieXRlcyhieXRlc19vcl9idWZmZXIpIC0+IGltbXV0YWJsZSBjb3B5IG9mIGJ5dGVzX29yX2J1ZmZlclxcbmJ5dGVzKGludCkgLT4gYnl0ZXMgb2JqZWN0IG9mIHNpemUgZ2l2ZW4gYnkgdGhlIHBhcmFtZXRlciBpbml0aWFsaXplZCB3aXRoIG51bGwgYnl0ZXNcXG5ieXRlcygpIC0+IGVtcHR5IGJ5dGVzIG9iamVjdFxcblxcbkNvbnN0cnVjdCBhbiBpbW11dGFibGUgYXJyYXkgb2YgYnl0ZXMgZnJvbTpcXG4gIC0gYW4gaXRlcmFibGUgeWllbGRpbmcgaW50ZWdlcnMgaW4gcmFuZ2UoMjU2KVxcbiAgLSBhIHRleHQgc3RyaW5nIGVuY29kZWQgdXNpbmcgdGhlIHNwZWNpZmllZCBlbmNvZGluZ1xcbiAgLSBhbnkgb2JqZWN0IGltcGxlbWVudGluZyB0aGUgYnVmZmVyIEFQSS5cXG4gIC0gYW4gaW50ZWdlclwiLFxudHAkbmV3KHgsQil7aWYodGhpcyE9PVNrLmJ1aWx0aW4uYnl0ZXMucHJvdG90eXBlKXJldHVybiB0aGlzLiRzdWJ0eXBlX25ldyh4LEIpO0I9Qnx8W107bGV0IEY7aWYoMT49eC5sZW5ndGgmJjA9PT0rQi5sZW5ndGgpeD14WzBdO2Vsc2V7W3gsQixGXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcImJ5dGVzXCIsW251bGwsXCJweVNvdXJjZVwiLFwiZXJyb3JzXCJdLHgsQik7KHtlbmNvZGluZzpCLGVycm9yczpGfT1lKFwiYnl0ZXNcIixCLEYpKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyh4KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJlbmNvZGluZyBvciBlcnJvcnMgd2l0aG91dCBhIHN0cmluZyBhcmd1bWVudFwiKTtyZXR1cm4gZyh4LEIsRil9aWYodm9pZCAwPT09eClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXM7aWYodm9pZCAwIT09KEI9U2suYWJzdHIubG9va3VwU3BlY2lhbCh4LFNrLmJ1aWx0aW4uc3RyLiRieXRlcykpKXJldHVybiB4PVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShCLFxuW10pLFNrLm1pc2NldmFsLmNoYWluKHgsSj0+e2lmKCFTay5idWlsdGluLmNoZWNrQnl0ZXMoSikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19ieXRlc19fIHJldHVybmVkIG5vbi1ieXRlcyAodHlwZSBcIitTay5hYnN0ci50eXBlTmFtZShKKStcIilcIik7cmV0dXJuIEp9KTtpZihTay5taXNjZXZhbC5pc0luZGV4KHgpKXt4PVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh4LFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoMD54KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJuZWdhdGl2ZSBjb3VudFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoeCl9aWYoU2suYnVpbHRpbi5jaGVja0J5dGVzKHgpKXJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyh4LnYpO2lmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoeCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic3RyaW5nIGFyZ3VtZW50IHdpdGhvdXQgYW4gZW5jb2RpbmdcIik7aWYoU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKHgpKXtsZXQgSj1cbltdO3g9U2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHgpLFA9PntQPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChQKTtpZigwPlB8fDI1NTxQKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJieXRlcyBtdXN0IGJlIGluIHJhbmdlKDAsIDI1NilcIik7Si5wdXNoKFApfSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHgsKCk9Pm5ldyBTay5idWlsdGluLmJ5dGVzKEopKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW5ub3QgY29udmVydCAnXCIrU2suYWJzdHIudHlwZU5hbWUoeCkrXCInIG9iamVjdCBpbnRvIGJ5dGVzXCIpO30sJHIoKXtsZXQgeCxCPVwiJ1wiO2NvbnN0IEY9LTEhPT10aGlzLnYuaW5kZXhPZigzNCk7bGV0IEo9XCJcIjtmb3IobGV0IFA9MDtQPHRoaXMudi5sZW5ndGg7UCsrKWlmKHg9dGhpcy52W1BdLDk+eHx8MTA8eCYmMTM+eHx8MTM8eCYmMzI+eHx8MTI2PHgpSis9ayh4KTtlbHNlIGlmKDk9PT14fHwxMD09PXh8fDEzPT09eHx8Mzk9PT1cbnh8fDkyPT09eClzd2l0Y2goeCl7Y2FzZSA5OkorPVwiXFxcXHRcIjticmVhaztjYXNlIDEwOkorPVwiXFxcXG5cIjticmVhaztjYXNlIDEzOkorPVwiXFxcXHJcIjticmVhaztjYXNlIDM5OkY/Sis9XCJcXFxcJ1wiOihKKz1cIidcIixCPSdcIicpO2JyZWFrO2Nhc2UgOTI6Sis9XCJcXFxcXFxcXFwifWVsc2UgSis9U3RyaW5nLmZyb21DaGFyQ29kZSh4KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiYlwiK0IrSitCKX0sdHAkc3RyKCl7cmV0dXJuIHRoaXMuJHIoKX0sdHAkaXRlcigpe3JldHVybiBuZXcgSCh0aGlzKX0sdHAkcmljaGNvbXBhcmUoeCxCKXtpZih0aGlzPT09eCYmU2subWlzY2V2YWwub3BBbGxvd3NFcXVhbGl0eShCKSlyZXR1cm4hMDtpZighKHggaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3QgRj10aGlzLnY7eD14LnY7aWYoRi5sZW5ndGghPT14Lmxlbmd0aCYmKFwiRXFcIj09PUJ8fFwiTm90RXFcIj09PUIpKXJldHVyblwiRXFcIj09PVxuQj8hMTohMDtsZXQgSjtjb25zdCBQPU1hdGgubWluKEYubGVuZ3RoLHgubGVuZ3RoKTtmb3IoSj0wO0o8UCYmRltKXT09PXhbSl07SisrKTtzd2l0Y2goQil7Y2FzZSBcIkx0XCI6cmV0dXJuIEo9PT1QJiZGLmxlbmd0aDx4Lmxlbmd0aHx8RltKXTx4W0pdO2Nhc2UgXCJMdEVcIjpyZXR1cm4gSj09PVAmJkYubGVuZ3RoPD14Lmxlbmd0aHx8RltKXTw9eFtKXTtjYXNlIFwiRXFcIjpyZXR1cm4gSj09PVA7Y2FzZSBcIk5vdEVxXCI6cmV0dXJuIEo8UDtjYXNlIFwiR3RcIjpyZXR1cm4gSj09PVAmJkYubGVuZ3RoPngubGVuZ3RofHxGW0pdPnhbSl07Y2FzZSBcIkd0RVwiOnJldHVybiBKPT09UCYmRi5sZW5ndGg+PXgubGVuZ3RofHxGW0pdPj14W0pdfX0sdHAkaGFzaCgpe3JldHVybihuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kanNzdHIoKSkpLnRwJGhhc2goKX0sdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCxtcCRzdWJzY3JpcHQoeCl7aWYoU2subWlzY2V2YWwuaXNJbmRleCh4KSl7bGV0IEI9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHgsXG5Tay5idWlsdGluLkluZGV4RXJyb3IpO2lmKHZvaWQgMCE9PUIpezA+QiYmKEI9dGhpcy52Lmxlbmd0aCtCKTtpZigwPkJ8fEI+PXRoaXMudi5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcImluZGV4IG91dCBvZiByYW5nZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLnZbQl0pfX1lbHNlIGlmKHggaW5zdGFuY2VvZiBTay5idWlsdGluLnNsaWNlKXtjb25zdCBCPVtdO3guc3NzaXRlciQodGhpcy52Lmxlbmd0aCxGPT57Qi5wdXNoKHRoaXMudltGXSl9KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMobmV3IFVpbnQ4QXJyYXkoQikpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImJ5dGUgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIHNsaWNlcywgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKHgpKTt9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLnYubGVuZ3RofSxzcSRjb25jYXQoeCl7aWYoISh4IGluc3RhbmNlb2YgU2suYnVpbHRpbi5ieXRlcykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgY29uY2F0IFwiK1xuU2suYWJzdHIudHlwZU5hbWUoeCkrXCIgdG8gYnl0ZXNcIik7Y29uc3QgQj1uZXcgVWludDhBcnJheSh0aGlzLnYubGVuZ3RoK3gudi5sZW5ndGgpO2xldCBGO2ZvcihGPTA7Rjx0aGlzLnYubGVuZ3RoO0YrKylCW0ZdPXRoaXMudltGXTtmb3IobGV0IEo9MDtKPHgudi5sZW5ndGg7SisrLEYrKylCW0ZdPXgudltKXTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoQil9LHNxJHJlcGVhdCh4KXtpZighU2subWlzY2V2YWwuaXNJbmRleCh4KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHgpK1wiJ1wiKTt4PVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh4LFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7Y29uc3QgQj14KnRoaXMudi5sZW5ndGg7aWYoQj5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yO2lmKDA+PVxueClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXM7eD1uZXcgVWludDhBcnJheShCKTtsZXQgRj0wO2Zvcig7RjxCOylmb3IobGV0IEo9MDtKPHRoaXMudi5sZW5ndGg7SisrKXhbRisrXT10aGlzLnZbSl07cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKHgpfSxzcSRjb250YWlucyh4KXtyZXR1cm4tMSE9PXRoaXMuZmluZCRsZWZ0KHgpfSx0cCRhc19udW1iZXI6ITAsbmIkcmVtYWluZGVyOlNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5uYiRyZW1haW5kZXJ9LHByb3RvOnskanNzdHIoKXtsZXQgeD1cIlwiO2ZvcihsZXQgQj0wO0I8dGhpcy52Lmxlbmd0aDtCKyspeCs9U3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnZbQl0pO3JldHVybiB4fSxnZXQkdGd0KHgpe2lmKHggaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKXJldHVybiB4LnY7eD1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyh4LFwiYXJndW1lbnQgc2hvdWxkIGJlIGludGVnZXIgb3IgYnl0ZXMtbGlrZSBvYmplY3QsIG5vdCB7dHAkbmFtZX1cIik7XG5pZigwPnh8fDI1NTx4KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJieXRlcyBtdXN0IGJlIGluIHJhbmdlKDAsIDI1NilcIik7cmV0dXJuIHh9LGdldCRyYXcoeCl7aWYoeCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXMpcmV0dXJuIHgudjt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIGJ5dGVzLWxpa2Ugb2JqZWN0IGlzIHJlcXVpcmVkLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHgpK1wiJ1wiKTt9LGdldCRzcGxpdEFyZ3M6ZnVuY3Rpb24oeCxCKXtCPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChCLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7Qj0wPkI/SW5maW5pdHk6Qjt4PVNrLmJ1aWx0aW4uY2hlY2tOb25lKHgpP251bGw6dGhpcy5nZXQkcmF3KHgpO2lmKG51bGwhPT14JiYheC5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImVtcHR5IHNlcGFyYXRvclwiKTtyZXR1cm57c2VwOngsbWF4c3BsaXQ6Qn19LGZpbmQkbGVmdDphKCExKSxcbmZpbmQkcmlnaHQ6YSghMCksZmluZCRzdWJsZWZ0OmZ1bmN0aW9uKHgsQixGKXtGPUYteC5sZW5ndGgrMTtsZXQgSj1CO2Zvcig7SjxGOyl7aWYoeC5ldmVyeSgoUCxXKT0+UD09PXRoaXMudltKK1ddKSlyZXR1cm4gSjtKKyt9cmV0dXJuLTF9LGZpbmQkc3VicmlnaHQoeCxCLEYpe2xldCBKPUYteC5sZW5ndGg7Zm9yKDtKPj1COyl7aWYoeC5ldmVyeSgoUCxXKT0+UD09PXRoaXMudltKK1ddKSlyZXR1cm4gSjtKLS19cmV0dXJuLTF9LCRzdWJ0eXBlX25ldyh4LEIpe2NvbnN0IEY9bmV3IHRoaXMuY29uc3RydWN0b3I7eD1Tay5idWlsdGluLmJ5dGVzLnByb3RvdHlwZS50cCRuZXcoeCxCKTtGLnY9eC52O3JldHVybiBGfSxzayRhc2FycmF5KCl7Y29uc3QgeD1bXTt0aGlzLnYuZm9yRWFjaChCPT57eC5wdXNoKG5ldyBTay5idWlsdGluLmludF8oQikpfSk7cmV0dXJuIHh9LHZhbHVlT2YoKXtyZXR1cm4gdGhpcy52fX0sZmxhZ3M6e3N0ciRlbmNvZGU6ZywkZGVjb2RlOnAsY2hlY2skZW5jb2RlQXJnczplfSxcbm1ldGhvZHM6e19fZ2V0bmV3YXJnc19fOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpudWxsfSxjYXBpdGFsaXplOnskbWV0aCgpe2NvbnN0IHg9dGhpcy52Lmxlbmd0aDtpZigwPT09eClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52KTtjb25zdCBCPW5ldyBVaW50OEFycmF5KHgpO2xldCBGPXRoaXMudlswXTtCWzBdPWwoRik/Ri0zMjpGO2ZvcihsZXQgSj0xO0o8eDtKKyspRj10aGlzLnZbSl0sQltKXT1yKEYpP0YrMzI6RjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoQil9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmNhcGl0YWxpemUoKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gYSBjb3B5IG9mIEIgd2l0aCBvbmx5IGl0cyBmaXJzdCBjaGFyYWN0ZXIgY2FwaXRhbGl6ZWQgKEFTQ0lJKVxcbmFuZCB0aGUgcmVzdCBsb3dlci1jYXNlZC5cIn0sXG5jZW50ZXI6eyRtZXRoOm4oXCJjZW50ZXJcIiwhMSwhMCksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmNlbnRlcih3aWR0aFssIGZpbGxjaGFyXSkgLT4gY29weSBvZiBCXFxuXFxuUmV0dXJuIEIgY2VudGVyZWQgaW4gYSBzdHJpbmcgb2YgbGVuZ3RoIHdpZHRoLiAgUGFkZGluZyBpc1xcbmRvbmUgdXNpbmcgdGhlIHNwZWNpZmllZCBmaWxsIGNoYXJhY3RlciAoZGVmYXVsdCBpcyBhIHNwYWNlKS5cIn0sY291bnQ6eyRtZXRoKHgsQixGKXt4PXRoaXMuZ2V0JHRndCh4KTsoe3N0YXJ0OkIsZW5kOkZ9PVNrLmJ1aWx0aW4uc2xpY2Uuc3RhcnRFbmQkd3J0KHRoaXMsQixGKSk7bGV0IEo9MDtpZihcIm51bWJlclwiPT09dHlwZW9mIHgpZm9yKDtCPEY7QisrKXRoaXMudltCXT09PXgmJkorKztlbHNle0Y9Ri14Lmxlbmd0aCsxO2ZvcihsZXQgUD1CO1A8RjtQKyspeC5ldmVyeSgoVyxjYSk9Plc9PT10aGlzLnZbUCtjYV0pJiYoSisrLFArPXgubGVuZ3RoLTEpfXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEopfSxcbiRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5jb3VudChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIG51bWJlciBvZiBub24tb3ZlcmxhcHBpbmcgb2NjdXJyZW5jZXMgb2Ygc3Vic2VjdGlvbiBzdWIgaW5cXG5ieXRlcyBCW3N0YXJ0OmVuZF0uICBPcHRpb25hbCBhcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWRcXG5hcyBpbiBzbGljZSBub3RhdGlvbi5cIn0sZGVjb2RlOnskbWV0aDpwLCRmbGFnczp7TmFtZWRBcmdzOltcImVuY29kaW5nXCIsXCJlcnJvcnNcIl19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBlbmNvZGluZz0ndXRmLTgnLCBlcnJvcnM9J3N0cmljdCcpXCIsJGRvYzpcIkRlY29kZSB0aGUgYnl0ZXMgdXNpbmcgdGhlIGNvZGVjIHJlZ2lzdGVyZWQgZm9yIGVuY29kaW5nLlxcblxcbiAgZW5jb2RpbmdcXG4gICAgVGhlIGVuY29kaW5nIHdpdGggd2hpY2ggdG8gZGVjb2RlIHRoZSBieXRlcy5cXG4gIGVycm9yc1xcbiAgICBUaGUgZXJyb3IgaGFuZGxpbmcgc2NoZW1lIHRvIHVzZSBmb3IgdGhlIGhhbmRsaW5nIG9mIGRlY29kaW5nIGVycm9ycy5cXG4gICAgVGhlIGRlZmF1bHQgaXMgJ3N0cmljdCcgbWVhbmluZyB0aGF0IGRlY29kaW5nIGVycm9ycyByYWlzZSBhXFxuICAgIFVuaWNvZGVEZWNvZGVFcnJvci4gT3RoZXIgcG9zc2libGUgdmFsdWVzIGFyZSAnaWdub3JlJyBhbmQgJ3JlcGxhY2UnXFxuICAgIGFzIHdlbGwgYXMgYW55IG90aGVyIG5hbWUgcmVnaXN0ZXJlZCB3aXRoIGNvZGVjcy5yZWdpc3Rlcl9lcnJvciB0aGF0XFxuICAgIGNhbiBoYW5kbGUgVW5pY29kZURlY29kZUVycm9ycy5cIn0sXG5lbmRzd2l0aDp7JG1ldGg6aChcImVuZHN3aXRoXCIsKHgsQik9Pntjb25zdCBGPXgubGVuZ3RoLUIubGVuZ3RoO3JldHVybiAwPD1GJiZCLmV2ZXJ5KChKLFApPT5KPT09eFtGK1BdKX0pLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5lbmRzd2l0aChzdWZmaXhbLCBzdGFydFssIGVuZF1dKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgQiBlbmRzIHdpdGggdGhlIHNwZWNpZmllZCBzdWZmaXgsIEZhbHNlIG90aGVyd2lzZS5cXG5XaXRoIG9wdGlvbmFsIHN0YXJ0LCB0ZXN0IEIgYmVnaW5uaW5nIGF0IHRoYXQgcG9zaXRpb24uXFxuV2l0aCBvcHRpb25hbCBlbmQsIHN0b3AgY29tcGFyaW5nIEIgYXQgdGhhdCBwb3NpdGlvbi5cXG5zdWZmaXggY2FuIGFsc28gYmUgYSB0dXBsZSBvZiBieXRlcyB0byB0cnkuXCJ9LGV4cGFuZHRhYnM6eyRtZXRoKHgpe3g9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHgsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yLFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZCAoZ290IHR5cGUge3RwJG5hbX0pXCIpO1xuY29uc3QgQj1bXTtsZXQgRj0wO2ZvcihsZXQgUD0wO1A8dGhpcy52Lmxlbmd0aDtQKyspe3ZhciBKPXRoaXMudltQXTs5PT09Sj8oSj14LUYleCxCLnB1c2goLi4uQXJyYXkoSikuZmlsbCgzMikpLEYrPUopOjEwPT09Snx8MTM9PT1KPyhCLnB1c2goSiksRj0wKTooQi5wdXNoKEopLEYrKyl9cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKG5ldyBVaW50OEFycmF5KEIpKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1widGFic2l6ZVwiXSxEZWZhdWx0czpbOF19LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuZXhwYW5kdGFicyh0YWJzaXplPTgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aGVyZSBhbGwgdGFiIGNoYXJhY3RlcnMgYXJlIGV4cGFuZGVkIHVzaW5nIHNwYWNlcy5cXG5JZiB0YWJzaXplIGlzIG5vdCBnaXZlbiwgYSB0YWIgc2l6ZSBvZiA4IGNoYXJhY3RlcnMgaXMgYXNzdW1lZC5cIn0sZmluZDp7JG1ldGg6ZnVuY3Rpb24oeCxCLEYpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuZmluZCRsZWZ0KHgsXG5CLEYpKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmZpbmQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBsb3dlc3QgaW5kZXggaW4gQiB3aGVyZSBzdWJzZWN0aW9uIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gQltzdGFydCxlbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmV0dXJuIC0xIG9uIGZhaWx1cmUuXCJ9LGhleDp7JG1ldGgoKXtsZXQgeD1cIlwiO2ZvcihsZXQgQj0wO0I8dGhpcy52Lmxlbmd0aDtCKyspeCs9dGhpcy52W0JdLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLFwiMFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHgpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5oZXgoKSAtPiBzdHJpbmdcXG5cXG5DcmVhdGUgYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgbnVtYmVycyBmcm9tIGEgYnl0ZXMgb2JqZWN0LlxcbkV4YW1wbGU6IGInXFxcXHhiOVxcXFx4MDFcXFxceGVmJy5oZXgoKSAtPiAnYjkwMWVmJy5cIn0sXG5pbmRleDp7JG1ldGg6ZnVuY3Rpb24oeCxCLEYpe3g9dGhpcy5maW5kJGxlZnQoeCxCLEYpO2lmKC0xPT09eCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwic3Vic2VjdGlvbiBub3QgZm91bmRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oeCl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5pbmRleChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGxvd2VzdCBpbmRleCBpbiBCIHdoZXJlIHN1YnNlY3Rpb24gc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBCW3N0YXJ0LGVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciB3aGVuIHRoZSBzdWJzZWN0aW9uIGlzIG5vdCBmb3VuZC5cIn0saXNhbG51bTp7JG1ldGg6cSh4PT52KHgpfHxcbmwoeCl8fHIoeCkpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmlzYWxudW0oKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgYWxsIGNoYXJhY3RlcnMgaW4gQiBhcmUgYWxwaGFudW1lcmljXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2FscGhhOnskbWV0aDpxKHg9PjY1PD14JiY5MD49eHx8OTc8PXgmJjEyMj49eCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNhbHBoYSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiBCIGFyZSBhbHBoYWJldGljXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2FzY2lpOnskbWV0aDpxKHg9PjA8PXgmJjEyNz49eCwhMCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNhc2NpaSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBCIGlzIGVtcHR5IG9yIGFsbCBjaGFyYWN0ZXJzIGluIEIgYXJlIEFTQ0lJLFxcbkZhbHNlIG90aGVyd2lzZS5cIn0sXG5pc2RpZ2l0OnskbWV0aDpxKHYpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmlzZGlnaXQoKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgYWxsIGNoYXJhY3RlcnMgaW4gQiBhcmUgZGlnaXRzXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2xvd2VyOnskbWV0aDp0KGwsciksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNsb3dlcigpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2FzZWQgY2hhcmFjdGVycyBpbiBCIGFyZSBsb3dlcmNhc2UgYW5kIHRoZXJlIGlzXFxuYXQgbGVhc3Qgb25lIGNhc2VkIGNoYXJhY3RlciBpbiBCLCBGYWxzZSBvdGhlcndpc2UuXCJ9LGlzc3BhY2U6eyRtZXRoOnEoZCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNzcGFjZSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiBCIGFyZSB3aGl0ZXNwYWNlXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxcbmlzdGl0bGU6eyRtZXRoOmZ1bmN0aW9uKCl7bGV0IHg9ITEsQj0hMTtmb3IobGV0IEY9MDtGPHRoaXMudi5sZW5ndGg7RisrKXtjb25zdCBKPXRoaXMudltGXTtpZihyKEopKXtpZih4KXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO0I9eD0hMH1lbHNlIGlmKGwoSikpe2lmKCF4KXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO0I9ITB9ZWxzZSB4PSExfXJldHVybiBCP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5pc3RpdGxlKCkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIEIgaXMgYSB0aXRsZWNhc2VkIHN0cmluZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXFxuY2hhcmFjdGVyIGluIEIsIGkuZS4gdXBwZXJjYXNlIGNoYXJhY3RlcnMgbWF5IG9ubHkgZm9sbG93IHVuY2FzZWRcXG5jaGFyYWN0ZXJzIGFuZCBsb3dlcmNhc2UgY2hhcmFjdGVycyBvbmx5IGNhc2VkIG9uZXMuIFJldHVybiBGYWxzZVxcbm90aGVyd2lzZS5cIn0sXG5pc3VwcGVyOnskbWV0aDp0KHIsbCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXN1cHBlcigpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2FzZWQgY2hhcmFjdGVycyBpbiBCIGFyZSB1cHBlcmNhc2UgYW5kIHRoZXJlIGlzXFxuYXQgbGVhc3Qgb25lIGNhc2VkIGNoYXJhY3RlciBpbiBCLCBGYWxzZSBvdGhlcndpc2UuXCJ9LGpvaW46eyRtZXRoKHgpe2NvbnN0IEI9W107bGV0IEY9MDtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHgpLEo9PntpZighKEogaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZXF1ZW5jZSBpdGVtIFwiK0YrXCI6IGV4cGVjdGVkIGEgYnl0ZXMtbGlrZSBvYmplY3QsIFwiK1NrLmFic3RyLnR5cGVOYW1lKEopK1wiIGZvdW5kXCIpO0YrKztCLmxlbmd0aCYmQi5wdXNoKC4uLnRoaXMudik7Qi5wdXNoKC4uLkoudil9KSxcbigpPT5uZXcgU2suYnVpbHRpbi5ieXRlcyhuZXcgVWludDhBcnJheShCKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGl0ZXJhYmxlX29mX2J5dGVzLCAvKVwiLCRkb2M6XCJDb25jYXRlbmF0ZSBhbnkgbnVtYmVyIG9mIGJ5dGVzIG9iamVjdHMuXFxuXFxuVGhlIGJ5dGVzIHdob3NlIG1ldGhvZCBpcyBjYWxsZWQgaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiBlYWNoIHBhaXIuXFxuXFxuVGhlIHJlc3VsdCBpcyByZXR1cm5lZCBhcyBhIG5ldyBieXRlcyBvYmplY3QuXFxuXFxuRXhhbXBsZTogYicuJy5qb2luKFtiJ2FiJywgYidwcScsIGIncnMnXSkgLT4gYidhYi5wcS5ycycuXCJ9LGxqdXN0OnskbWV0aDpuKFwibGp1c3RcIiwhMSwhMSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmxqdXN0KHdpZHRoWywgZmlsbGNoYXJdKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gQiBsZWZ0IGp1c3RpZmllZCBpbiBhIHN0cmluZyBvZiBsZW5ndGggd2lkdGguIFBhZGRpbmcgaXNcXG5kb25lIHVzaW5nIHRoZSBzcGVjaWZpZWQgZmlsbCBjaGFyYWN0ZXIgKGRlZmF1bHQgaXMgYSBzcGFjZSkuXCJ9LFxubG93ZXI6eyRtZXRoOncoeD0+cih4KT94KzMyOngpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmxvd2VyKCkgLT4gY29weSBvZiBCXFxuXFxuUmV0dXJuIGEgY29weSBvZiBCIHdpdGggYWxsIEFTQ0lJIGNoYXJhY3RlcnMgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cIn0sbHN0cmlwOnskbWV0aDptKCEwLCExKSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBieXRlcz1Ob25lLCAvKVwiLCRkb2M6XCJTdHJpcCBsZWFkaW5nIGJ5dGVzIGNvbnRhaW5lZCBpbiB0aGUgYXJndW1lbnQuXFxuXFxuSWYgdGhlIGFyZ3VtZW50IGlzIG9taXR0ZWQgb3IgTm9uZSwgc3RyaXAgbGVhZGluZyAgQVNDSUkgd2hpdGVzcGFjZS5cIn0scGFydGl0aW9uOnskbWV0aDpjKCExKSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIHNlcCwgLylcIiwkZG9jOlwiUGFydGl0aW9uIHRoZSBieXRlcyBpbnRvIHRocmVlIHBhcnRzIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXFxuXFxuVGhpcyB3aWxsIHNlYXJjaCBmb3IgdGhlIHNlcGFyYXRvciBzZXAgaW4gdGhlIGJ5dGVzLiBJZiB0aGUgc2VwYXJhdG9yIGlzIGZvdW5kLFxcbnJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhcnQgYmVmb3JlIHRoZSBzZXBhcmF0b3IsIHRoZSBzZXBhcmF0b3JcXG5pdHNlbGYsIGFuZCB0aGUgcGFydCBhZnRlciBpdC5cXG5cXG5JZiB0aGUgc2VwYXJhdG9yIGlzIG5vdCBmb3VuZCwgcmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgYnl0ZXNcXG5vYmplY3QgYW5kIHR3byBlbXB0eSBieXRlcyBvYmplY3RzLlwifSxcbnJlcGxhY2U6eyRtZXRoKHgsQixGKXt4PXRoaXMuZ2V0JHJhdyh4KTtCPXRoaXMuZ2V0JHJhdyhCKTtGPXZvaWQgMD09PUY/LTE6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKEYsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtGPTA+Rj9JbmZpbml0eTpGO2NvbnN0IEo9W107bGV0IFA9MDtmb3IodmFyIFc9MDtXPHRoaXMudi5sZW5ndGgmJlA8Rjspe2NvbnN0IGNhPXRoaXMuZmluZCRzdWJsZWZ0KHgsVyx0aGlzLnYubGVuZ3RoKTtpZigtMT09PWNhKWJyZWFrO2Zvcig7VzxjYTtXKyspSi5wdXNoKHRoaXMudltXXSk7Si5wdXNoKC4uLkIpO1c9Y2EreC5sZW5ndGg7UCsrfWZvcihXO1c8dGhpcy52Lmxlbmd0aDtXKyspSi5wdXNoKHRoaXMudltXXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKG5ldyBVaW50OEFycmF5KEopKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkc2VsZiwgb2xkLCBuZXcsIGNvdW50PS0xLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IHdpdGggYWxsIG9jY3VycmVuY2VzIG9mIHN1YnN0cmluZyBvbGQgcmVwbGFjZWQgYnkgbmV3LlxcblxcbiAgY291bnRcXG4gICAgTWF4aW11bSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgdG8gcmVwbGFjZS5cXG4gICAgLTEgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyByZXBsYWNlIGFsbCBvY2N1cnJlbmNlcy5cXG5cXG5JZiB0aGUgb3B0aW9uYWwgYXJndW1lbnQgY291bnQgaXMgZ2l2ZW4sIG9ubHkgdGhlIGZpcnN0IGNvdW50IG9jY3VycmVuY2VzIGFyZVxcbnJlcGxhY2VkLlwifSxcbnJmaW5kOnskbWV0aCh4LEIsRil7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5maW5kJHJpZ2h0KHgsQixGKSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5yZmluZChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGhpZ2hlc3QgaW5kZXggaW4gQiB3aGVyZSBzdWJzZWN0aW9uIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gQltzdGFydCxlbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmV0dXJuIC0xIG9uIGZhaWx1cmUuXCJ9LHJpbmRleDp7JG1ldGg6ZnVuY3Rpb24oeCxCLEYpe3g9dGhpcy5maW5kJHJpZ2h0KHgsQixGKTtpZigtMT09PXgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInN1YnNlY3Rpb24gbm90IGZvdW5kXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHgpfSxcbiRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5yaW5kZXgoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBoaWdoZXN0IGluZGV4IGluIEIgd2hlcmUgc3Vic2VjdGlvbiBzdWIgaXMgZm91bmQsXFxuc3VjaCB0aGF0IHN1YiBpcyBjb250YWluZWQgd2l0aGluIEJbc3RhcnQsZW5kXS4gIE9wdGlvbmFsXFxuYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlxcblxcblJhaXNlIFZhbHVlRXJyb3Igd2hlbiB0aGUgc3Vic2VjdGlvbiBpcyBub3QgZm91bmQuXCJ9LHJqdXN0OnskbWV0aDpuKFwicmp1c3RcIiwhMCwhMSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLnJqdXN0KHdpZHRoWywgZmlsbGNoYXJdKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gQiByaWdodCBqdXN0aWZpZWQgaW4gYSBzdHJpbmcgb2YgbGVuZ3RoIHdpZHRoLiBQYWRkaW5nIGlzXFxuZG9uZSB1c2luZyB0aGUgc3BlY2lmaWVkIGZpbGwgY2hhcmFjdGVyIChkZWZhdWx0IGlzIGEgc3BhY2UpXCJ9LFxucnBhcnRpdGlvbjp7JG1ldGg6YyghMCksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBzZXAsIC8pXCIsJGRvYzpcIlBhcnRpdGlvbiB0aGUgYnl0ZXMgaW50byB0aHJlZSBwYXJ0cyB1c2luZyB0aGUgZ2l2ZW4gc2VwYXJhdG9yLlxcblxcblRoaXMgd2lsbCBzZWFyY2ggZm9yIHRoZSBzZXBhcmF0b3Igc2VwIGluIHRoZSBieXRlcywgc3RhcnRpbmcgYXQgdGhlIGVuZC4gSWZcXG50aGUgc2VwYXJhdG9yIGlzIGZvdW5kLCByZXR1cm5zIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSBwYXJ0IGJlZm9yZSB0aGVcXG5zZXBhcmF0b3IsIHRoZSBzZXBhcmF0b3IgaXRzZWxmLCBhbmQgdGhlIHBhcnQgYWZ0ZXIgaXQuXFxuXFxuSWYgdGhlIHNlcGFyYXRvciBpcyBub3QgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdHdvIGVtcHR5IGJ5dGVzXFxub2JqZWN0cyBhbmQgdGhlIG9yaWdpbmFsIGJ5dGVzIG9iamVjdC5cIn0scnNwbGl0OnskbWV0aDpmdW5jdGlvbih4LEIpeyh7c2VwOngsXG5tYXhzcGxpdDpCfT10aGlzLmdldCRzcGxpdEFyZ3MoeCxCKSk7Y29uc3QgRj1bXTtsZXQgSj0wLFA9dGhpcy52Lmxlbmd0aDtpZihudWxsIT09eCl7Zm9yKDswPD1QJiZKPEI7KXtjb25zdCBXPXRoaXMuZmluZCRzdWJyaWdodCh4LDAsUCk7aWYoLTE9PT1XKWJyZWFrO0YucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoVyt4Lmxlbmd0aCxQKSkpO1A9VztKKyt9Ri5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheSgwLFApKSl9ZWxzZXtmb3IoUC0tO0o8Qjspe2Zvcig7ZCh0aGlzLnZbUF0pOylQLS07aWYoMD5QKWJyZWFrO3g9UCsxO2ZvcihQLS07MDw9UCYmIWQodGhpcy52W1BdKTspUC0tO0YucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoUCsxLHgpKSk7SisrfWlmKDA8PVApe2Zvcig7ZCh0aGlzLnZbUF0pOylQLS07MDw9UCYmRi5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheSgwLFxuUCsxKSkpfX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChGLnJldmVyc2UoKSl9LCRmbGFnczp7TmFtZWRBcmdzOltcInNlcFwiLFwibWF4c3BsaXRcIl0sRGVmYXVsdHM6W1NrLmJ1aWx0aW4ubm9uZS5ub25lJCwtMV19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBzZXA9Tm9uZSwgbWF4c3BsaXQ9LTEpXCIsJGRvYzpcIlJldHVybiBhIGxpc3Qgb2YgdGhlIHNlY3Rpb25zIGluIHRoZSBieXRlcywgdXNpbmcgc2VwIGFzIHRoZSBkZWxpbWl0ZXIuXFxuXFxuICBzZXBcXG4gICAgVGhlIGRlbGltaXRlciBhY2NvcmRpbmcgd2hpY2ggdG8gc3BsaXQgdGhlIGJ5dGVzLlxcbiAgICBOb25lICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgc3BsaXQgb24gQVNDSUkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXFxuICAgIChzcGFjZSwgdGFiLCByZXR1cm4sIG5ld2xpbmUsIGZvcm1mZWVkLCB2ZXJ0aWNhbCB0YWIpLlxcbiAgbWF4c3BsaXRcXG4gICAgTWF4aW11bSBudW1iZXIgb2Ygc3BsaXRzIHRvIGRvLlxcbiAgICAtMSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIG5vIGxpbWl0LlxcblxcblNwbGl0dGluZyBpcyBkb25lIHN0YXJ0aW5nIGF0IHRoZSBlbmQgb2YgdGhlIGJ5dGVzIGFuZCB3b3JraW5nIHRvIHRoZSBmcm9udC5cIn0sXG5yc3RyaXA6eyRtZXRoOm0oITEsITApLCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6XCIoJHNlbGYsIGJ5dGVzPU5vbmUsIC8pXCIsJGRvYzpcIlN0cmlwIHRyYWlsaW5nIGJ5dGVzIGNvbnRhaW5lZCBpbiB0aGUgYXJndW1lbnQuXFxuXFxuSWYgdGhlIGFyZ3VtZW50IGlzIG9taXR0ZWQgb3IgTm9uZSwgc3RyaXAgdHJhaWxpbmcgQVNDSUkgd2hpdGVzcGFjZS5cIn0sc3BsaXQ6eyRtZXRoOmZ1bmN0aW9uKHgsQil7KHtzZXA6eCxtYXhzcGxpdDpCfT10aGlzLmdldCRzcGxpdEFyZ3MoeCxCKSk7Y29uc3QgRj1bXSxKPXRoaXMudi5sZW5ndGg7bGV0IFA9MCxXPTA7aWYobnVsbCE9PXgpe2Zvcig7VzxKJiZQPEI7KXtjb25zdCBjYT10aGlzLmZpbmQkc3VibGVmdCh4LFcsSik7aWYoLTE9PT1jYSlicmVhaztGLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KFcsY2EpKSk7Vz1jYSt4Lmxlbmd0aDtQKyt9Ri5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShXLFxuSikpKX1lbHNle2Zvcig7UDxCOyl7Zm9yKDtkKHRoaXMudltXXSk7KVcrKztpZihXPT09SilicmVhazt4PVc7Zm9yKFcrKztXPEomJiFkKHRoaXMudltXXSk7KVcrKztGLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KHgsVykpKTtQKyt9aWYoVzxKKXtmb3IoO2QodGhpcy52W1ddKTspVysrO1c8SiYmRi5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShXLEopKSl9fXJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KEYpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJzZXBcIixcIm1heHNwbGl0XCJdLERlZmF1bHRzOltTay5idWlsdGluLm5vbmUubm9uZSQsLTFdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgc2VwPU5vbmUsIG1heHNwbGl0PS0xKVwiLCRkb2M6XCJSZXR1cm4gYSBsaXN0IG9mIHRoZSBzZWN0aW9ucyBpbiB0aGUgYnl0ZXMsIHVzaW5nIHNlcCBhcyB0aGUgZGVsaW1pdGVyLlxcblxcbiAgc2VwXFxuICAgIFRoZSBkZWxpbWl0ZXIgYWNjb3JkaW5nIHdoaWNoIHRvIHNwbGl0IHRoZSBieXRlcy5cXG4gICAgTm9uZSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIHNwbGl0IG9uIEFTQ0lJIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xcbiAgICAoc3BhY2UsIHRhYiwgcmV0dXJuLCBuZXdsaW5lLCBmb3JtZmVlZCwgdmVydGljYWwgdGFiKS5cXG4gIG1heHNwbGl0XFxuICAgIE1heGltdW0gbnVtYmVyIG9mIHNwbGl0cyB0byBkby5cXG4gICAgLTEgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyBubyBsaW1pdC5cIn0sXG5zcGxpdGxpbmVzOnskbWV0aCh4KXt4PVNrLm1pc2NldmFsLmlzVHJ1ZSh4KTtjb25zdCBCPVtdO2xldCBGPTA7bGV0IEo9MDtjb25zdCBQPXRoaXMudi5sZW5ndGg7Zm9yKDtKPFA7KXt2YXIgVz10aGlzLnZbSl07aWYoMTM9PT1XKXtjb25zdCBjYT0xMD09PXRoaXMudltKKzFdO1c9eD9jYT9KKzI6SisxOko7Qi5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShGLFcpKSk7Sj1GPWNhP0orMjpKKzF9ZWxzZSAxMD09PVc/KFc9eD9KKzE6SixCLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KEYsVykpKSxKPUY9SisxKTpKKyt9RjxQJiZCLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KEYsUCkpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChCKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wia2VlcGVuZHNcIl0sRGVmYXVsdHM6WyExXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIGtlZXBlbmRzPUZhbHNlKVwiLCRkb2M6XCJSZXR1cm4gYSBsaXN0IG9mIHRoZSBsaW5lcyBpbiB0aGUgYnl0ZXMsIGJyZWFraW5nIGF0IGxpbmUgYm91bmRhcmllcy5cXG5cXG5MaW5lIGJyZWFrcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgbGlzdCB1bmxlc3Mga2VlcGVuZHMgaXMgZ2l2ZW4gYW5kXFxudHJ1ZS5cIn0sXG5zdGFydHN3aXRoOnskbWV0aDpoKFwic3RhcnRzd2l0aFwiLCh4LEIpPT5CLmxlbmd0aDw9eC5sZW5ndGgmJkIuZXZlcnkoKEYsSik9PkY9PT14W0pdKSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLnN0YXJ0c3dpdGgocHJlZml4Wywgc3RhcnRbLCBlbmRdXSkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIEIgc3RhcnRzIHdpdGggdGhlIHNwZWNpZmllZCBwcmVmaXgsIEZhbHNlIG90aGVyd2lzZS5cXG5XaXRoIG9wdGlvbmFsIHN0YXJ0LCB0ZXN0IEIgYmVnaW5uaW5nIGF0IHRoYXQgcG9zaXRpb24uXFxuV2l0aCBvcHRpb25hbCBlbmQsIHN0b3AgY29tcGFyaW5nIEIgYXQgdGhhdCBwb3NpdGlvbi5cXG5wcmVmaXggY2FuIGFsc28gYmUgYSB0dXBsZSBvZiBieXRlcyB0byB0cnkuXCJ9LHN0cmlwOnskbWV0aDptKCEwLCEwKSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBieXRlcz1Ob25lLCAvKVwiLCRkb2M6XCJTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBieXRlcyBjb250YWluZWQgaW4gdGhlIGFyZ3VtZW50LlxcblxcbklmIHRoZSBhcmd1bWVudCBpcyBvbWl0dGVkIG9yIE5vbmUsIHN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2UuXCJ9LFxuc3dhcGNhc2U6eyRtZXRoOncoeD0+cih4KT94KzMyOmwoeCk/eC0zMjp4KSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5zd2FwY2FzZSgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aXRoIHVwcGVyY2FzZSBBU0NJSSBjaGFyYWN0ZXJzIGNvbnZlcnRlZFxcbnRvIGxvd2VyY2FzZSBBU0NJSSBhbmQgdmljZSB2ZXJzYS5cIn0sdGl0bGU6eyRtZXRoKCl7Y29uc3QgeD10aGlzLnYubGVuZ3RoLEI9bmV3IFVpbnQ4QXJyYXkoeCk7bGV0IEY9ITE7Zm9yKGxldCBKPTA7Sjx4O0orKyl7Y29uc3QgUD10aGlzLnZbSl07cihQKT8oQltKXT1GP1ArMzI6UCxGPSEwKTpsKFApPyhCW0pdPUY/UDpQLTMyLEY9ITApOihCW0pdPVAsRj0hMSl9cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKEIpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi50aXRsZSgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIHRpdGxlY2FzZWQgdmVyc2lvbiBvZiBCLCBpLmUuIEFTQ0lJIHdvcmRzIHN0YXJ0IHdpdGggdXBwZXJjYXNlXFxuY2hhcmFjdGVycywgYWxsIHJlbWFpbmluZyBjYXNlZCBjaGFyYWN0ZXJzIGhhdmUgbG93ZXJjYXNlLlwifSxcbnVwcGVyOnskbWV0aDp3KHg9PmwoeCk/eC0zMjp4KSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi51cHBlcigpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aXRoIGFsbCBBU0NJSSBjaGFyYWN0ZXJzIGNvbnZlcnRlZCB0byB1cHBlcmNhc2UuXCJ9LHpmaWxsOnskbWV0aCh4KXt4PVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh4LFNrLmJ1aWx0aW4uSW5kZXhFcnJvcik7Y29uc3QgQj14LXRoaXMudi5sZW5ndGg7aWYoMD49QilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52KTtjb25zdCBGPW5ldyBVaW50OEFycmF5KHgpO2xldCBKPTAsUDtpZig0Mz09PXRoaXMudlswXXx8NDU9PT10aGlzLnZbMF0pRlswXT10aGlzLnZbMF0sSisrO0YuZmlsbCg0OCxKLEorQik7UD1KO2ZvcihKKz1CO0o8eDtKKyssUCsrKUZbSl09dGhpcy52W1BdO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhGKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsXG4kZG9jOlwiQi56ZmlsbCh3aWR0aCkgLT4gY29weSBvZiBCXFxuXFxuUGFkIGEgbnVtZXJpYyBzdHJpbmcgQiB3aXRoIHplcm9zIG9uIHRoZSBsZWZ0LCB0byBmaWxsIGEgZmllbGRcXG5vZiB0aGUgc3BlY2lmaWVkIHdpZHRoLiAgQiBpcyBuZXZlciB0cnVuY2F0ZWQuXCJ9fSxjbGFzc21ldGhvZHM6e2Zyb21oZXg6eyRtZXRoOmZ1bmN0aW9uKHgpe2Z1bmN0aW9uIEIoaGEpe2ZvcihsZXQgb2E9VztvYTxoYTtvYSs9Mil7bGV0IGthPXguc3Vic3RyKG9hLDIpO2lmKCFKLnRlc3Qoa2EpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJub24taGV4YWRlY2ltYWwgbnVtYmVyIGZvdW5kIGluIGZyb21oZXgoKSBhcmcgYXQgcG9zaXRpb24gXCIrKG9hKzEpKTtQLnB1c2gocGFyc2VJbnQoa2EsMTYpKX19aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoeCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZnJvbWhleCgpIGFyZ3VtZW50IG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoeCkpO1xueD14LiRqc3N0cigpO2NvbnN0IEY9L1xccysvZyxKPS9eW2FiY2RlZkFCQ0RFRjAxMjM0NTY3ODldezJ9JC8sUD1bXTtsZXQgVz0wLGNhO2Zvcig7bnVsbCE9PShjYT1GLmV4ZWMoeCkpOylCKGNhLmluZGV4KSxXPUYubGFzdEluZGV4O0IoeC5sZW5ndGgpO3JldHVybiBuZXcgdGhpcyhQKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCR0eXBlLCBzdHJpbmcsIC8pXCIsJGRvYzpcIkNyZWF0ZSBhIGJ5dGVzIG9iamVjdCBmcm9tIGEgc3RyaW5nIG9mIGhleGFkZWNpbWFsIG51bWJlcnMuXFxuXFxuU3BhY2VzIGJldHdlZW4gdHdvIG51bWJlcnMgYXJlIGFjY2VwdGVkLlxcbkV4YW1wbGU6IGJ5dGVzLmZyb21oZXgoJ0I5IDAxRUYnKSAtPiBiJ1xcXFxcXFxceGI5XFxcXFxcXFx4MDFcXFxcXFxcXHhlZicuXCJ9fX0pO3ZhciBIPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImJ5dGVzX2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHgpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPXgudn0saXRlcm5leHQoKXtjb25zdCB4PVxudGhpcy4kc2VxW3RoaXMuJGluZGV4KytdO2lmKHZvaWQgMCE9PXgpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oeCl9LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJMZW5ndGhIaW50V2l0aEFycmF5TWV0aG9kRGVmfSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmJ5dGVzXCIsU2suYnVpbHRpbi5ieXRlcyl9LGZ1bmN0aW9uKEUsUSxiKXsoZnVuY3Rpb24oZil7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGcoKXt9ZnVuY3Rpb24gaygpe312YXIgcD1TdHJpbmcuZnJvbUNoYXJDb2RlLGg9e30udG9TdHJpbmcsYT1oLmNhbGwoZS5TaGFyZWRBcnJheUJ1ZmZlciksYz1oKCksbT1lLlVpbnQ4QXJyYXksbj1tfHxBcnJheSxkPW0/QXJyYXlCdWZmZXI6bixsPWQuaXNWaWV3fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJsZW5ndGhcImluIHR9LHI9aC5jYWxsKGQucHJvdG90eXBlKTtkPWsucHJvdG90eXBlO1xudmFyIHY9ZS5UZXh0RW5jb2RlcixxPW5ldyAobT9VaW50MTZBcnJheTpuKSgzMik7Zy5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQpe2lmKCFsKHQpKXt2YXIgdz1oLmNhbGwodCk7aWYodyE9PXImJnchPT1hJiZ3IT09Yyl0aHJvdyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnZGVjb2RlJyBvbiAnVGV4dERlY29kZXInOiBUaGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTt0PW0/bmV3IG4odCk6dHx8W119Zm9yKHZhciBDPXc9XCJcIixEPTAsTD10Lmxlbmd0aHwwLE49TC0zMnwwLEEsSCx4PTAsQj0wLEYsSj0wLFA9LTE7RDxMOyl7Zm9yKEE9RDw9Tj8zMjpMLUR8MDtKPEE7RD1EKzF8MCxKPUorMXwwKXtIPXRbRF0mMjU1O3N3aXRjaChIPj40KXtjYXNlIDE1OkY9dFtEPUQrMXwwXSYyNTU7aWYoMiE9PUY+PjZ8fDI0NzxIKXtEPUQtMXwwO2JyZWFrfXg9KEgmNyk8PDZ8RiY2MztCPTU7SD0yNTY7Y2FzZSAxNDpGPVxudFtEPUQrMXwwXSYyNTUseDw8PTYseHw9KEgmMTUpPDw2fEYmNjMsQj0yPT09Rj4+Nj9CKzR8MDoyNCxIPUgrMjU2Jjc2ODtjYXNlIDEzOmNhc2UgMTI6Rj10W0Q9RCsxfDBdJjI1NSx4PDw9Nix4fD0oSCYzMSk8PDZ8RiY2MyxCPUIrN3wwLEQ8TCYmMj09PUY+PjYmJng+PkImJjExMTQxMTI+eD8oSD14LHg9eC02NTUzNnwwLDA8PXgmJihQPSh4Pj4xMCkrNTUyOTZ8MCxIPSh4JjEwMjMpKzU2MzIwfDAsMzE+Sj8ocVtKXT1QLEo9SisxfDAsUD0tMSk6KEY9UCxQPUgsSD1GKSkpOihIPj49OCxEPUQtSC0xfDAsSD02NTUzMykseD1CPTAsQT1EPD1OPzMyOkwtRHwwO2RlZmF1bHQ6cVtKXT1IO2NvbnRpbnVlO2Nhc2UgMTE6Y2FzZSAxMDpjYXNlIDk6Y2FzZSA4On1xW0pdPTY1NTMzfUMrPXAocVswXSxxWzFdLHFbMl0scVszXSxxWzRdLHFbNV0scVs2XSxxWzddLHFbOF0scVs5XSxxWzEwXSxxWzExXSxxWzEyXSxxWzEzXSxxWzE0XSxxWzE1XSxxWzE2XSxxWzE3XSxxWzE4XSxxWzE5XSxxWzIwXSxcbnFbMjFdLHFbMjJdLHFbMjNdLHFbMjRdLHFbMjVdLHFbMjZdLHFbMjddLHFbMjhdLHFbMjldLHFbMzBdLHFbMzFdKTszMj5KJiYoQz1DLnNsaWNlKDAsSi0zMnwwKSk7aWYoRDxMKXtpZihxWzBdPVAsSj1+UD4+PjMxLFA9LTEsQy5sZW5ndGg8dy5sZW5ndGgpY29udGludWV9ZWxzZS0xIT09UCYmKEMrPXAoUCkpO3crPUM7Qz1cIlwifXJldHVybiB3fTtkLmVuY29kZT1mdW5jdGlvbih0KXt0PXZvaWQgMD09PXQ/XCJcIjpcIlwiK3Q7dmFyIHc9dC5sZW5ndGh8MCxDPW5ldyBuKCh3PDwxKSs4fDApLEQsTD0wLE49IW07Zm9yKEQ9MDtEPHc7RD1EKzF8MCxMPUwrMXwwKXt2YXIgQT10LmNoYXJDb2RlQXQoRCl8MDtpZigxMjc+PUEpQ1tMXT1BO2Vsc2V7aWYoMjA0Nz49QSlDW0xdPTE5MnxBPj42O2Vsc2V7YTp7aWYoNTUyOTY8PUEpaWYoNTYzMTk+PUEpe3ZhciBIPXQuY2hhckNvZGVBdChEPUQrMXwwKXwwO2lmKDU2MzIwPD1IJiY1NzM0Mz49SCl7QT0oQTw8MTApK0gtNTY2MTM4ODh8MDtpZig2NTUzNTxcbkEpe0NbTF09MjQwfEE+PjE4O0NbTD1MKzF8MF09MTI4fEE+PjEyJjYzO0NbTD1MKzF8MF09MTI4fEE+PjYmNjM7Q1tMPUwrMXwwXT0xMjh8QSY2Mztjb250aW51ZX1icmVhayBhfUE9NjU1MzN9ZWxzZSA1NzM0Mz49QSYmKEE9NjU1MzMpOyFOJiZEPDwxPEwmJkQ8PDE8KEwtN3wwKSYmKE49ITAsSD1uZXcgbigzKncpLEguc2V0KEMpLEM9SCl9Q1tMXT0yMjR8QT4+MTI7Q1tMPUwrMXwwXT0xMjh8QT4+NiY2M31DW0w9TCsxfDBdPTEyOHxBJjYzfX1yZXR1cm4gbT9DLnN1YmFycmF5KDAsTCk6Qy5zbGljZSgwLEwpfTt2fHwoZS5UZXh0RGVjb2Rlcj1nLGUuVGV4dEVuY29kZXI9ayl9KShcInVuZGVmaW5lZFwiPT10eXBlb2YgZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj90aGlzOnNlbGY6Zil9KS5jYWxsKHRoaXMsYigwKSl9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi50dXBsZT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwidHVwbGVcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZil7dm9pZCAwPT09XG5mP2Y9W106QXJyYXkuaXNBcnJheShmKXx8KGY9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZikpO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlLFwiYmFkIGNhbGwgdG8gdHVwbGUsIHVzZSAnbmV3JyB3aXRoIGFuIEFycmF5IG9mIHB5dGhvbiBvYmplY3RzXCIpO3RoaXMudj1mO3RoaXMuaW4kcmVwcj0hMX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkZG9jOlwiQnVpbHQtaW4gaW1tdXRhYmxlIHNlcXVlbmNlLlxcblxcbklmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgY29uc3RydWN0b3IgcmV0dXJucyBhbiBlbXB0eSB0dXBsZS5cXG5JZiBpdGVyYWJsZSBpcyBzcGVjaWZpZWQgdGhlIHR1cGxlIGlzIGluaXRpYWxpemVkIGZyb20gaXRlcmFibGUncyBpdGVtcy5cXG5cXG5JZiB0aGUgYXJndW1lbnQgaXMgYSB0dXBsZSwgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgc2FtZSBvYmplY3QuXCIsXG4kcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiKC4uLilcIik7dGhpcy5pbiRyZXByPSEwO2xldCBmPXRoaXMudi5tYXAoZT0+U2subWlzY2V2YWwub2JqZWN0UmVwcihlKSk7dGhpcy5pbiRyZXByPSExO2Y9Zi5qb2luKFwiLCBcIik7MT09PXRoaXMudi5sZW5ndGgmJihmKz1cIixcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIihcIitmK1wiKVwiKX0sdHAkbmV3KGYsZSl7aWYodGhpcyE9PVNrLmJ1aWx0aW4udHVwbGUucHJvdG90eXBlKXJldHVybiB0aGlzLiRzdWJ0eXBlX25ldyhmLGUpO1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJ0dXBsZVwiLGUpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcInR1cGxlXCIsZiwwLDEpO2Y9ZlswXTtyZXR1cm4gdm9pZCAwPT09Zj9uZXcgU2suYnVpbHRpbi50dXBsZShbXSk6Zi5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4udHVwbGU/ZjpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShmLFxuITApLGc9Pm5ldyBTay5idWlsdGluLnR1cGxlKGcpKX0sdHAkaGFzaCgpe2xldCBmLGU9MzQzMDAwOCxnPTEwMDAwMDM7Y29uc3Qgaz10aGlzLnYubGVuZ3RoO2ZvcihsZXQgcD0wO3A8azsrK3Ape2Y9U2suYWJzdHIub2JqZWN0SGFzaCh0aGlzLnZbcF0pO2lmKC0xPT09ZilyZXR1cm4tMTtlPShlXmYpKmc7Zys9ODI1MjAraytrfWUrPTk3NTMxOy0xPT09ZSYmKGU9LTIpO3JldHVybiBlfDB9LHRwJHJpY2hjb21wYXJlOlNrLmdlbmVyaWMuc2VxQ29tcGFyZSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBiKHRoaXMpfSxtcCRzdWJzY3JpcHQoZil7aWYoU2subWlzY2V2YWwuaXNJbmRleChmKSl7Zj1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZik7MD5mJiYoZj10aGlzLnYubGVuZ3RoK2YpO2lmKDA+Znx8Zj49dGhpcy52Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFwidHVwbGUgaW5kZXggb3V0IG9mIHJhbmdlXCIpO3JldHVybiB0aGlzLnZbZl19aWYoZiBpbnN0YW5jZW9mXG5Tay5idWlsdGluLnNsaWNlKXtjb25zdCBlPVtdO2Yuc3NzaXRlciQodGhpcy52Lmxlbmd0aCxnPT57ZS5wdXNoKHRoaXMudltnXSl9KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoZSl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHVwbGUgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIHNsaWNlcywgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGYpKTt9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLnYubGVuZ3RofSxzcSRyZXBlYXQoZil7Zj1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZixTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2lmKDE9PT1mJiZ0aGlzLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi50dXBsZSlyZXR1cm4gdGhpcztjb25zdCBlPVtdO2ZvcihsZXQgZz0wO2c8ZjtnKyspZm9yKGxldCBrPTA7azx0aGlzLnYubGVuZ3RoO2srKyllLnB1c2godGhpcy52W2tdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoZSl9LHNxJGNvbmNhdChmKXtpZighKGYgaW5zdGFuY2VvZlxuU2suYnVpbHRpbi50dXBsZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgY29uY2F0ZW5hdGUgdHVwbGUgKG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCInKSB0byB0dXBsZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUodGhpcy52LmNvbmNhdChmLnYpKX0sc3EkY29udGFpbnMoZil7Zm9yKGxldCBlPXRoaXMudHAkaXRlcigpLGc9ZS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWc7Zz1lLnRwJGl0ZXJuZXh0KCkpaWYoZz09PWZ8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChnLGYsXCJFcVwiKSlyZXR1cm4hMDtyZXR1cm4hMX19LHByb3RvOnskc3VidHlwZV9uZXcoZixlKXtlPW5ldyB0aGlzLmNvbnN0cnVjdG9yO2Y9U2suYnVpbHRpbi50dXBsZS5wcm90b3R5cGUudHAkbmV3KGYpO2Uudj1mLnY7cmV0dXJuIGV9LHNrJGFzYXJyYXkoKXtyZXR1cm4gdGhpcy52LnNsaWNlKDApfSx2YWx1ZU9mKCl7cmV0dXJuIHRoaXMudn19LG1ldGhvZHM6e19fZ2V0bmV3YXJnc19fOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLnYuc2xpY2UoMCkpfSxcbiRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOm51bGx9LGluZGV4OnskbWV0aChmLGUsZyl7aWYodm9pZCAwIT09ZSYmIVNrLm1pc2NldmFsLmlzSW5kZXgoZSl8fHZvaWQgMCE9PWcmJiFTay5taXNjZXZhbC5pc0luZGV4KGcpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNsaWNlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBoYXZlIGFuIF9faW5kZXhfXyBtZXRob2RcIik7KHtzdGFydDplLGVuZDpnfT1Tay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydCh0aGlzLGUsZykpO2NvbnN0IGs9dGhpcy52O2Zvcig7ZTxnO2UrKylpZihrW2VdPT09Znx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGtbZV0sZixcIkVxXCIpKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGUpO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJ0dXBsZS5pbmRleCh4KTogeCBub3QgaW4gdHVwbGVcIik7fSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LFxuJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCBzdGFydD0wLCBzdG9wPXN5cy5tYXhzaXplLCAvKVwiLCRkb2M6XCJSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUuXFxuXFxuUmFpc2VzIFZhbHVlRXJyb3IgaWYgdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50LlwifSxjb3VudDp7JG1ldGgoZil7Y29uc3QgZT10aGlzLnYubGVuZ3RoLGc9dGhpcy52O2xldCBrPTA7Zm9yKGxldCBwPTA7cDxlOysrcClpZihnW3BdPT09Znx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGdbcF0sZixcIkVxXCIpKWsrPTE7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oayl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGRvYzpcIlJldHVybiBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdmFsdWUuXCJ9fSxjbGFzc21ldGhvZHM6U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLnR1cGxlXCIsU2suYnVpbHRpbi50dXBsZSk7dmFyIGI9XG5Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJ0dXBsZV9pdGVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihmKXt0aGlzLiRpbmRleD0wO3RoaXMuJHNlcT1mLnNrJGFzYXJyYXkoKX0saXRlcm5leHQ6U2suZ2VuZXJpYy5pdGVyTmV4dFdpdGhBcnJheSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSl9LGZ1bmN0aW9uKEUsUSl7ZnVuY3Rpb24gYih0KXtsZXQgdz10LiRzYXZlZEtleUhhc2g7cmV0dXJuIHZvaWQgMCE9PXc/dzp3PVNrLmFic3RyLm9iamVjdEhhc2godCl9ZnVuY3Rpb24gZih0KXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2V0KFNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKHQpKX1mdW5jdGlvbiBlKHQsdyl7Zm9yKGxldCBDPVNrLmFic3RyLml0ZXIodCksRD1DLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09RDtEPUMudHAkaXRlcm5leHQoKSlpZighU2suYWJzdHIuc2VxdWVuY2VDb250YWlucyh3LFxuRCkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gZyh0LHcsQyl7Y29uc3QgRD17Y29uc3RydWN0b3I6ZnVuY3Rpb24oTCl7aWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IGNyZWF0ZSAnXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCInIGluc3RhbmNlc1wiKTt0aGlzLmRpY3Q9TDt0aGlzLmluJHJlcHI9ITF9fTtELnNsb3RzPU9iamVjdC5hc3NpZ24odyxoKTtELm1ldGhvZHM9e2lzZGlzam9pbnQ6eyRtZXRoKEwpe2NvbnN0IE49Zih0aGlzKTtyZXR1cm4gTi5pc2Rpc2pvaW50LiRtZXRoLmNhbGwoTixMKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSB2aWV3IGFuZCB0aGUgZ2l2ZW4gaXRlcmFibGUgaGF2ZSBhIG51bGwgaW50ZXJzZWN0aW9uLlwifSxfX3JldmVyc2VkX186eyRtZXRoOkMsJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiBhIHJldmVyc2UgaXRlcmF0b3Igb3ZlciB0aGUgZGljdCBrZXlzLlwifX07XG5ELmZsYWdzPXtzayRhY2NlcHRhYmxlX2FzX2Jhc2U6ITF9O1wiZGljdF92YWx1ZXNcIj09PXQmJihkZWxldGUgRC5zbG90cy50cCRhc19udW1iZXIsZGVsZXRlIEQuc2xvdHMudHAkcmljaGNvbXBhcmUpO3JldHVybiBTay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKHQsRCl9ZnVuY3Rpb24gayh0LHcsQyl7cmV0dXJuIFNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyh0LHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihEKXt0aGlzLiRpbmRleD0wO3RoaXMuJG9yaWc9RDt0aGlzLnRwJGl0ZXJuZXh0PSgpPT57dGhpcy4kc2VxPUQuJGl0ZW1zKCk7dGhpcy4kdmVyc2lvbj1ELiR2ZXJzaW9uO0MmJih0aGlzLiRzZXE9dGhpcy4kc2VxLnJldmVyc2UoKSk7dGhpcy50cCRpdGVybmV4dD10aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS50cCRpdGVybmV4dDtyZXR1cm4gdGhpcy50cCRpdGVybmV4dCgpfX0saXRlcm5leHQ6dyxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sXG5mbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH0scHJvdG86e25leHQkaXRlbTpwfX0pfWZ1bmN0aW9uIHAoKXtpZih0aGlzLiR2ZXJzaW9uIT09dGhpcy4kb3JpZy4kdmVyc2lvbil7aWYodGhpcy4kc2VxLmxlbmd0aCE9PXRoaXMuJG9yaWcuZ2V0JHNpemUoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5SdW50aW1lRXJyb3IoXCJkaWN0IGNoYW5nZWQgc2l6ZSBkdXJpbmcgaXRlcmF0aW9uXCIpO3Rocm93IG5ldyBTay5idWlsdGluLlJ1bnRpbWVFcnJvcihcImRpY3Rpb25hcnkga2V5cyBjaGFuZ2VkIGR1cmluZyBpdGVyYXRpb25cIik7fXJldHVybiB0aGlzLiRzZXFbdGhpcy4kaW5kZXgrK119U2suYnVpbHRpbi5kaWN0PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJkaWN0XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PVtdKTtTay5hc3NlcnRzLmFzc2VydChBcnJheS5pc0FycmF5KHQpJiYwPT09dC5sZW5ndGglMiYmdGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCxcblwiYmFkIGNhbGwgdG8gZGljdCBjb25zdHJ1Y3RvclwiKTt0aGlzLnNpemU9MDt0aGlzLmVudHJpZXM9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmJ1Y2tldHM9e307Zm9yKGxldCB3PTA7dzx0Lmxlbmd0aDt3Kz0yKXRoaXMuc2V0JGl0ZW0odFt3XSx0W3crMV0pO3RoaXMuaW4kcmVwcj0hMTt0aGlzLiR2ZXJzaW9uPTB9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGFzX251bWJlcjohMCx0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRkb2M6XCJkaWN0KCkgLT4gbmV3IGVtcHR5IGRpY3Rpb25hcnlcXG5kaWN0KG1hcHBpbmcpIC0+IG5ldyBkaWN0aW9uYXJ5IGluaXRpYWxpemVkIGZyb20gYSBtYXBwaW5nIG9iamVjdCdzXFxuICAgIChrZXksIHZhbHVlKSBwYWlyc1xcbmRpY3QoaXRlcmFibGUpIC0+IG5ldyBkaWN0aW9uYXJ5IGluaXRpYWxpemVkIGFzIGlmIHZpYTpcXG4gICAgZCA9IHt9XFxuICAgIGZvciBrLCB2IGluIGl0ZXJhYmxlOlxcbiAgICAgICAgZFtrXSA9IHZcXG5kaWN0KCoqa3dhcmdzKSAtPiBuZXcgZGljdGlvbmFyeSBpbml0aWFsaXplZCB3aXRoIHRoZSBuYW1lPXZhbHVlIHBhaXJzXFxuICAgIGluIHRoZSBrZXl3b3JkIGFyZ3VtZW50IGxpc3QuICBGb3IgZXhhbXBsZTogIGRpY3Qob25lPTEsIHR3bz0yKVwiLFxuJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcInsuLi59XCIpO3RoaXMuaW4kcmVwcj0hMDtjb25zdCB0PXRoaXMuJGl0ZW1zKCkubWFwKHc9Pnt2YXIgW0MsRF09dztyZXR1cm4gU2subWlzY2V2YWwub2JqZWN0UmVwcihDKStcIjogXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcihEKX0pO3RoaXMuaW4kcmVwcj0hMTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwie1wiK3Quam9pbihcIiwgXCIpK1wifVwiKX0sdHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQodCx3KXtyZXR1cm4gdGhpcy51cGRhdGUkY29tbW9uKHQsdyxcImRpY3RcIil9LHRwJGl0ZXIoKXtyZXR1cm4gbmV3IG4odGhpcyl9LHRwJHJpY2hjb21wYXJlKHQsdyl7bGV0IEM7aWYoISh0IGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXx8XCJFcVwiIT09dyYmXCJOb3RFcVwiIT09dylyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7aWYodD09PXRoaXMpQz0hMDtlbHNlIGlmKHRoaXMuc2l6ZSE9PVxudC5zaXplKUM9ITE7ZWxzZXtsZXQgRDtDPXRoaXMuJGl0ZW1zKCkuZXZlcnkoTD0+e3ZhciBbTixBXT1MO0Q9dC5tcCRsb29rdXAoTik7cmV0dXJuIHZvaWQgMCE9PUQmJihEPT09QXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKEEsRCxcIkVxXCIpKX0pfXJldHVyblwiRXFcIj09PXc/QzohQ30sbmIkb3IodCl7aWYoISh0IGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3Qgdz10aGlzLmRpY3QkY29weSgpO3cuZGljdCRtZXJnZSh0KTtyZXR1cm4gd30sbmIkcmVmbGVjdGVkX29yKHQpe2lmKCEodCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO3Q9dC5kaWN0JGNvcHkoKTt0LmRpY3QkbWVyZ2UodGhpcyk7cmV0dXJuIHR9LG5iJGlucGxhY2Vfb3IodCl7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHRoaXMudXBkYXRlJG9uZWFyZyh0KSxcbigpPT50aGlzKX0sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMuZ2V0JHNpemUoKX0sc3EkY29udGFpbnModCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMubXAkbG9va3VwKHQpfSxtcCRzdWJzY3JpcHQodCx3KXt2YXIgQz10aGlzLm1wJGxvb2t1cCh0KTtpZih2b2lkIDAhPT1DKXJldHVybiBDO0M9U2suYWJzdHIubG9va3VwU3BlY2lhbCh0aGlzLFNrLmJ1aWx0aW4uc3RyLiRtaXNzaW5nKTtpZih2b2lkIDAhPT1DKXJldHVybiB0PVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShDLFt0XSksdz90OlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyh0KTt0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcih0KTt9LG1wJGFzc19zdWJzY3JpcHQodCx3KXtpZih2b2lkIDA9PT13KXtpZih2b2lkIDA9PT10aGlzLnBvcCRpdGVtKHQpKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKHQpO31lbHNlIHRoaXMuc2V0JGl0ZW0odCx3KX19LG1ldGhvZHM6e19fcmV2ZXJzZWRfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IHIodGhpcyl9LFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiBhIHJldmVyc2UgaXRlcmF0b3Igb3ZlciB0aGUgZGljdCBrZXlzLlwifSxnZXQ6eyRtZXRoKHQsdyl7cmV0dXJuIHRoaXMubXAkbG9va3VwKHQpfHx3fHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJHNlbGYsIGtleSwgZGVmYXVsdD1Ob25lLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIHZhbHVlIGZvciBrZXkgaWYga2V5IGlzIGluIHRoZSBkaWN0aW9uYXJ5LCBlbHNlIGRlZmF1bHQuXCJ9LHNldGRlZmF1bHQ6eyRtZXRoKHQsdyl7bGV0IEM7Y29uc3QgRD1iKHQpO0M9XCJzdHJpbmdcIj09PXR5cGVvZiBEP3RoaXMuZW50cmllc1tEXTp0aGlzLmdldCRidWNrZXRfaXRlbSh0LEQpO2lmKHZvaWQgMCE9PUMpcmV0dXJuIENbMV07dz13fHxTay5idWlsdGluLm5vbmUubm9uZSQ7XCJzdHJpbmdcIj09PXR5cGVvZiBEP3RoaXMuZW50cmllc1tEXT1bdCx3XTpcbnRoaXMuc2V0JGJ1Y2tldF9pdGVtKHQsdyxEKTt0aGlzLnNpemUrKzt0aGlzLiR2ZXJzaW9uKys7cmV0dXJuIHd9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJHNlbGYsIGtleSwgZGVmYXVsdD1Ob25lLCAvKVwiLCRkb2M6XCJJbnNlcnQga2V5IHdpdGggYSB2YWx1ZSBvZiBkZWZhdWx0IGlmIGtleSBpcyBub3QgaW4gdGhlIGRpY3Rpb25hcnkuXFxuXFxuUmV0dXJuIHRoZSB2YWx1ZSBmb3Iga2V5IGlmIGtleSBpcyBpbiB0aGUgZGljdGlvbmFyeSwgZWxzZSBkZWZhdWx0LlwifSxwb3A6eyRtZXRoKHQsdyl7Y29uc3QgQz10aGlzLnBvcCRpdGVtKHQpO2lmKHZvaWQgMCE9PUMpcmV0dXJuIENbMV07aWYodm9pZCAwIT09dylyZXR1cm4gdzt0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcih0KTt9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5wb3Aoa1ssZF0pIC0+IHYsIHJlbW92ZSBzcGVjaWZpZWQga2V5IGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXFxuSWYga2V5IGlzIG5vdCBmb3VuZCwgZCBpcyByZXR1cm5lZCBpZiBnaXZlbiwgb3RoZXJ3aXNlIEtleUVycm9yIGlzIHJhaXNlZFwifSxcbnBvcGl0ZW06eyRtZXRoKCl7Y29uc3QgdD10aGlzLmdldCRzaXplKCk7aWYoMD09PXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uS2V5RXJyb3IoXCJwb3BpdGVtKCk6IGRpY3Rpb25hcnkgaXMgZW1wdHlcIik7Y29uc3QgW3csQ109dGhpcy4kaXRlbXMoKVt0LTFdO3RoaXMucG9wJGl0ZW0odyk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt3LENdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQucG9waXRlbSgpIC0+IChrLCB2KSwgcmVtb3ZlIGFuZCByZXR1cm4gc29tZSAoa2V5LCB2YWx1ZSkgcGFpciBhcyBhXFxuMi10dXBsZTsgYnV0IHJhaXNlIEtleUVycm9yIGlmIEQgaXMgZW1wdHkuXCJ9LGtleXM6eyRtZXRoKCl7cmV0dXJuIG5ldyBhKHRoaXMpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5rZXlzKCkgLT4gYSBzZXQtbGlrZSBvYmplY3QgcHJvdmlkaW5nIGEgdmlldyBvbiBEJ3Mga2V5c1wifSxpdGVtczp7JG1ldGgoKXtyZXR1cm4gbmV3IG0odGhpcyl9LFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuaXRlbXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyBpdGVtc1wifSx2YWx1ZXM6eyRtZXRoKCl7cmV0dXJuIG5ldyBjKHRoaXMpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC52YWx1ZXMoKSAtPiBhbiBvYmplY3QgcHJvdmlkaW5nIGEgdmlldyBvbiBEJ3MgdmFsdWVzXCJ9LHVwZGF0ZTp7JG1ldGgodCx3KXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy51cGRhdGUkY29tbW9uKHQsdyxcInVwZGF0ZVwiKSwoKT0+U2suYnVpbHRpbi5ub25lLm5vbmUkKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC51cGRhdGUoW0UsIF0qKkYpIC0+IE5vbmUuICBVcGRhdGUgRCBmcm9tIGRpY3QvaXRlcmFibGUgRSBhbmQgRi5cXG5JZiBFIGlzIHByZXNlbnQgYW5kIGhhcyBhIC5rZXlzKCkgbWV0aG9kLCB0aGVuIGRvZXM6ICBmb3IgayBpbiBFOiBEW2tdID0gRVtrXVxcbklmIEUgaXMgcHJlc2VudCBhbmQgbGFja3MgYSAua2V5cygpIG1ldGhvZCwgdGhlbiBkb2VzOiAgZm9yIGssIHYgaW4gRTogRFtrXSA9IHZcXG5JbiBlaXRoZXIgY2FzZSwgdGhpcyBpcyBmb2xsb3dlZCBieTogZm9yIGsgaW4gRjogIERba10gPSBGW2tdXCJ9LFxuY2xlYXI6eyRtZXRoKCl7dGhpcy5zaXplPTA7dGhpcy4kdmVyc2lvbisrO3RoaXMuZW50cmllcz1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuYnVja2V0cz17fX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuY2xlYXIoKSAtPiBOb25lLiAgUmVtb3ZlIGFsbCBpdGVtcyBmcm9tIEQuXCJ9LGNvcHk6eyRtZXRoKCl7cmV0dXJuIHRoaXMuZGljdCRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELmNvcHkoKSAtPiBhIHNoYWxsb3cgY29weSBvZiBEXCJ9fSxjbGFzc21ldGhvZHM6T2JqZWN0LmFzc2lnbih7ZnJvbWtleXM6eyRtZXRoOmZ1bmN0aW9uKHQsdyl7dz13fHxTay5idWlsdGluLm5vbmUubm9uZSQ7bGV0IEM9dGhpcz09PVNrLmJ1aWx0aW4uZGljdD9uZXcgdGhpczp0aGlzLnRwJGNhbGwoW10sW10pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihDLEQ9PntDPUQ7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcih0KSxcbkw9PkMubXAkYXNzX3N1YnNjcmlwdChMLHcsITApKX0sKCk9PkMpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCR0eXBlLCBpdGVyYWJsZSwgdmFsdWU9Tm9uZSwgLylcIiwkZG9jOlwiQ3JlYXRlIGEgbmV3IGRpY3Rpb25hcnkgd2l0aCBrZXlzIGZyb20gaXRlcmFibGUgYW5kIHZhbHVlcyBzZXQgdG8gdmFsdWUuXCJ9fSxTay5nZW5lcmljLmNsYXNzR2V0SXRlbSkscHJvdG86e3F1aWNrJGxvb2t1cDpmdW5jdGlvbih0KXt0PXRoaXMuZW50cmllc1t0LiRzYXZlZEtleUhhc2hdO2lmKHZvaWQgMCE9PXQpcmV0dXJuIHRbMV19LG1wJGxvb2t1cDpmdW5jdGlvbih0KXtjb25zdCB3PWIodCk7dD1cInN0cmluZ1wiPT09dHlwZW9mIHc/dGhpcy5lbnRyaWVzW3ddOnRoaXMuZ2V0JGJ1Y2tldF9pdGVtKHQsdyk7aWYodm9pZCAwIT09dClyZXR1cm4gdFsxXX0sZ2V0JHNpemUoKXtyZXR1cm4gdGhpcy5zaXplfSxzayRhc2FycmF5KCl7cmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5lbnRyaWVzKS5tYXAodD0+XG50WzBdKX0sdXBkYXRlJGNvbW1vbjpmdW5jdGlvbih0LHcsQyl7U2suYWJzdHIuY2hlY2tBcmdzTGVuKEMsdCwwLDEpO3Q9dFswXTtsZXQgRDt2b2lkIDAhPT10JiYoRD10aGlzLnVwZGF0ZSRvbmVhcmcodCkpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihELCgpPT57aWYodylmb3IobGV0IEw9MDtMPHcubGVuZ3RoO0wrPTIpdGhpcy5zZXQkaXRlbShuZXcgU2suYnVpbHRpbi5zdHIod1tMXSksd1tMKzFdKX0pfSx1cGRhdGUkb25lYXJnKHQpe3JldHVybiB0IGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0fHx2b2lkIDAhPT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKHQsU2suYnVpbHRpbi5zdHIuJGtleXMpP3RoaXMuZGljdCRtZXJnZSh0KTp0aGlzLmRpY3QkbWVyZ2Vfc2VxKHQpfSxkaWN0JGNvcHkoKXtjb25zdCB0PW5ldyBTay5idWlsdGluLmRpY3QoW10pO3Quc2l6ZT10aGlzLnNpemU7dmFyIHc9T2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKTtmb3IodmFyIEMgaW4gdyl7dmFyIEQ9XG53W0NdWzFdO3QuZW50cmllc1t3W0NdWzBdXT1bRFswXSxEWzFdXX1mb3IobGV0IEwgaW4gdGhpcy5idWNrZXRzKWZvcihDPXRoaXMuYnVja2V0c1tMXSx0LmJ1Y2tldHNbTF09dz1bXSxEPTA7RDxDLmxlbmd0aDtEKyspdy5wdXNoKHQuZW50cmllc1tcIiNcIitMK1wiX1wiK0RdKTtyZXR1cm4gdH0sJGl0ZW1zKCl7cmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5lbnRyaWVzKX0sc2V0JGl0ZW06ZnVuY3Rpb24odCx3KXtjb25zdCBDPWIodCk7bGV0IEQ7XCJzdHJpbmdcIj09PXR5cGVvZiBDPyhEPXRoaXMuZW50cmllc1tDXSx2b2lkIDA9PT1EPyh0aGlzLmVudHJpZXNbQ109W3Qsd10sdGhpcy5zaXplKyssdGhpcy4kdmVyc2lvbisrKTpEWzFdPXcpOihEPXRoaXMuZ2V0JGJ1Y2tldF9pdGVtKHQsQyksdm9pZCAwPT09RD8odGhpcy5zZXQkYnVja2V0X2l0ZW0odCx3LEMpLHRoaXMuc2l6ZSsrLHRoaXMuJHZlcnNpb24rKyk6RFsxXT13KX0sZ2V0JGJ1Y2tldF9pdGVtOmZ1bmN0aW9uKHQsdyl7dz1cbnRoaXMuYnVja2V0c1t3XTtpZih2b2lkIDAhPT13KWZvcihsZXQgRD0wO0Q8dy5sZW5ndGg7RCsrKXt2YXIgQz13W0RdO2lmKHZvaWQgMCE9PUMmJihDWzBdPT09dHx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHQsQ1swXSxcIkVxXCIpKSlyZXR1cm4gQ319LHBvcCRidWNrZXRfaXRlbTpmdW5jdGlvbih0LHcpe2NvbnN0IEM9dGhpcy5idWNrZXRzW3ddO2xldCBEO2lmKHZvaWQgMCE9PUMpZm9yKGxldCBMPTA7TDxDLmxlbmd0aDtMKyspaWYoRD1DW0xdLHZvaWQgMCE9PUQmJihEWzBdPT09dHx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHQsRFswXSxcIkVxXCIpKSlyZXR1cm4gZGVsZXRlIHRoaXMuZW50cmllc1tcIiNcIit3K1wiX1wiK0xdLENbTF09dm9pZCAwLEMuZXZlcnkoTj0+dm9pZCAwPT09TikmJmRlbGV0ZSB0aGlzLmJ1Y2tldHNbd10sRH0sc2V0JGJ1Y2tldF9pdGVtOmZ1bmN0aW9uKHQsdyxDKXtsZXQgRD10aGlzLmJ1Y2tldHNbQ107dD1bdCx3XTt2b2lkIDA9PT1EPyh0aGlzLmJ1Y2tldHNbQ109XG5bdF0sQz1cIiNcIitDK1wiXzBcIik6KHc9RC5pbmRleE9mKHZvaWQgMCksLTEhPT13PyhDPVwiI1wiK0MrXCJfXCIrdyxEW3ddPXQpOihDPVwiI1wiK0MrXCJfXCIrRC5sZW5ndGgsRC5wdXNoKHQpKSk7dGhpcy5lbnRyaWVzW0NdPXR9LHBvcCRpdGVtOmZ1bmN0aW9uKHQpe2NvbnN0IHc9Yih0KTtcInN0cmluZ1wiPT09dHlwZW9mIHc/KHQ9dGhpcy5lbnRyaWVzW3ddLGRlbGV0ZSB0aGlzLmVudHJpZXNbd10pOnQ9dGhpcy5wb3AkYnVja2V0X2l0ZW0odCx3KTtpZih2b2lkIDAhPT10KXJldHVybiB0aGlzLnNpemUtLSx0aGlzLiR2ZXJzaW9uKyssdH0sZGljdCRtZXJnZTpmdW5jdGlvbih0KXtpZih0LnRwJGl0ZXI9PT1Tay5idWlsdGluLmRpY3QucHJvdG90eXBlLnRwJGl0ZXIpe3ZhciB3PXQudHAkaXRlcigpO2ZvcihsZXQgQz13LnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09QztDPXcudHAkaXRlcm5leHQoKSl7Y29uc3QgRD10Lm1wJHN1YnNjcmlwdChDKTt0aGlzLnNldCRpdGVtKEMsRCl9fWVsc2V7dz1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKHQsXG5Tay5idWlsdGluLnN0ci4ka2V5cyk7aWYodm9pZCAwPT09dyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUodCkrXCInIG9iamVjdCBpcyBub3QgYSBtYXBwaW5nXCIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkodyksQz0+U2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKEMpLEQ9PlNrLm1pc2NldmFsLmNoYWluKFNrLmFic3RyLm9iamVjdEdldEl0ZW0odCxELCEwKSxMPT57dGhpcy5zZXQkaXRlbShELEwpfSkpKX19LGRpY3QkbWVyZ2Vfc2VxOmZ1bmN0aW9uKHQpe2xldCB3PTA7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcih0KSxDPT57aWYoIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShDKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW5ub3QgY29udmVydCBkaWN0aW9uYXJ5IHVwZGF0ZSBzZXF1ZW5jZSBlbGVtZW50ICNcIitcbncrXCIgdG8gYSBzZXF1ZW5jZVwiKTtDPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKEMpO2lmKDIhPT1DLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiZGljdGlvbmFyeSB1cGRhdGUgc2VxdWVuY2UgZWxlbWVudCAjXCIrdytcIiBoYXMgbGVuZ3RoIFwiK0MubGVuZ3RoK1wiOyAyIGlzIHJlcXVpcmVkXCIpO3RoaXMuc2V0JGl0ZW0oQ1swXSxDWzFdKTt3Kyt9KX19fSk7Y29uc3QgaD17dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfbnVtYmVyOiEwLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkaGFzaDpTay5idWlsdGluLm5vbmUubm9uZSQsJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIi4uLlwiKTt0aGlzLmluJHJlcHI9ITA7bGV0IHQ9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUodGhpcyk7dD10Lm1hcCh3PT5Tay5taXNjZXZhbC5vYmplY3RSZXByKHcpKTt0aGlzLmluJHJlcHI9ITE7XG5yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKFtcIit0LmpvaW4oXCIsIFwiKStcIl0pXCIpfSx0cCRyaWNoY29tcGFyZSh0LHcpe2lmKCEoU2suYnVpbHRpbi5jaGVja0FueVNldCh0KXx8dCBpbnN0YW5jZW9mIGF8fHQgaW5zdGFuY2VvZiBtKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3QgQz10aGlzLnNxJGxlbmd0aCgpLEQ9dC5zcSRsZW5ndGgoKTtzd2l0Y2godyl7Y2FzZSBcIk5vdEVxXCI6Y2FzZSBcIkVxXCI6bGV0IEw7dGhpcz09PXQ/TD0hMDpDPT09RCYmKEw9ZSh0aGlzLHQpKTtyZXR1cm5cIk5vdEVxXCI9PT13PyFMOkw7Y2FzZSBcIkx0XCI6cmV0dXJuIEM8RCYmZSh0aGlzLHQpO2Nhc2UgXCJMdEVcIjpyZXR1cm4gQzw9RCYmZSh0aGlzLHQpO2Nhc2UgXCJHdFwiOnJldHVybiBDPkQmJmUodCx0aGlzKTtjYXNlIFwiR3RFXCI6cmV0dXJuIEM+PUQmJmUodCx0aGlzKX19LG5iJHN1YnRyYWN0KHQpe2NvbnN0IHc9XG5mKHRoaXMpO3JldHVybiB3LmRpZmZlcmVuY2UuJG1ldGguY2FsbCh3LHQpfSxuYiRhbmQodCl7Y29uc3Qgdz1mKHRoaXMpO3JldHVybiB3LmludGVyc2VjdGlvbi4kbWV0aC5jYWxsKHcsdCl9LG5iJG9yKHQpe2NvbnN0IHc9Zih0aGlzKTtyZXR1cm4gdy51bmlvbi4kbWV0aC5jYWxsKHcsdCl9LG5iJHhvcih0KXtjb25zdCB3PWYodGhpcyk7cmV0dXJuIHcuc3ltbWV0cmljX2RpZmZlcmVuY2UuJG1ldGguY2FsbCh3LHQpfSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy5kaWN0LmdldCRzaXplKCl9fTt2YXIgYT1nKFwiZGljdF9rZXlzXCIse3NxJGNvbnRhaW5zKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRpY3QubXAkbG9va3VwKHQpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBuKHRoaXMuZGljdCl9fSxmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLmRpY3QpfSksYz1nKFwiZGljdF92YWx1ZXNcIix7dHAkaXRlcigpe3JldHVybiBuZXcgbCh0aGlzLmRpY3QpfX0sZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHEodGhpcy5kaWN0KX0pLFxubT1nKFwiZGljdF9pdGVtc1wiLHtzcSRjb250YWlucyh0KXtpZighKHQgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlJiYyPT09dC5zcSRsZW5ndGgoKSkpcmV0dXJuITE7dmFyIHc9dC5tcCRzdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uaW50XygwKSk7dD10Lm1wJHN1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5pbnRfKDEpKTt3PXRoaXMuZGljdC5tcCRsb29rdXAodyk7cmV0dXJuIHZvaWQgMD09PXc/ITE6dz09PXR8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh3LHQsXCJFcVwiKX0sdHAkaXRlcigpe3JldHVybiBuZXcgZCh0aGlzLmRpY3QpfX0sZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHYodGhpcy5kaWN0KX0pLG49ayhcImRpY3Rfa2V5aXRlcmF0b3JcIixmdW5jdGlvbigpe2NvbnN0IHQ9dGhpcy5uZXh0JGl0ZW0oKTtyZXR1cm4gdCYmdFswXX0pLGQ9ayhcImRpY3RfaXRlbWl0ZXJhdG9yXCIsZnVuY3Rpb24oKXtjb25zdCB0PXRoaXMubmV4dCRpdGVtKCk7cmV0dXJuIHQmJm5ldyBTay5idWlsdGluLnR1cGxlKFt0WzBdLFxudFsxXV0pfSksbD1rKFwiZGljdF92YWx1ZWl0ZXJhdG9yXCIsZnVuY3Rpb24oKXtjb25zdCB0PXRoaXMubmV4dCRpdGVtKCk7cmV0dXJuIHQmJnRbMV19KSxyPWsoXCJkaWN0X3JldmVyc2VrZXlpdGVyYXRvclwiLG4ucHJvdG90eXBlLnRwJGl0ZXJuZXh0LCEwKSx2PWsoXCJkaWN0X3JldmVyc2VpdGVtaXRlcmF0b3JcIixkLnByb3RvdHlwZS50cCRpdGVybmV4dCwhMCkscT1rKFwiZGljdF9yZXZlcnNldmFsdWVpdGVyYXRvclwiLGwucHJvdG90eXBlLnRwJGl0ZXJuZXh0LCEwKTtTay5idWlsdGluLmRpY3QucHkyJG1ldGhvZHM9e2hhc19rZXk6eyRuYW1lOlwiaGFzX2tleVwiLCRmbGFnczp7T25lQXJnOiEwfSwkbWV0aCh0KXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0aGlzLnNxJGNvbnRhaW5zKHQpKX0sJGRvYzpcIkQuaGFzX2tleShrKSAtPiBUcnVlIGlmIEQgaGFzIGEga2V5IGssIGVsc2UgRmFsc2VcIn0sa2V5czp7JG5hbWU6XCJrZXlzXCIsJG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLnNrJGFzYXJyYXkoKSl9LFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQua2V5cygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGtleXNcIn0saXRlbXM6eyRuYW1lOlwiaXRlbXNcIiwkbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMuJGl0ZW1zKCkubWFwKHQ9Pnt2YXIgW3csQ109dDtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3csQ10pfSkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5pdGVtcygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGl0ZW1zXCJ9LHZhbHVlczp7JG5hbWU6XCJ2YWx1ZXNcIiwkbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMuJGl0ZW1zKCkubWFwKHQ9PntbLHRdPXQ7cmV0dXJuIHR9KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELnZhbHVlcygpIC0+IGFuIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyB2YWx1ZXNcIn19fSxcbmZ1bmN0aW9uKEUsUSl7ZnVuY3Rpb24gYihmLGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGYse2VudHJpZXM6e2dldDooKT0+e2NvbnN0IGc9T2JqZWN0LmNyZWF0ZShudWxsKTtPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKGs9Pnt2YXIgW3AsaF09aztwPVNrLnVuZml4UmVzZXJ2ZWQocCk7cC5pbmNsdWRlcyhcIiRcIil8fChwPW5ldyBTay5idWlsdGluLnN0cihwKSxnW3AuJHNhdmVkS2V5SGFzaF09W3AsaF0pfSk7cmV0dXJuIGd9LGNvbmZpZ3VyYWJsZTohMH0sc2l6ZTp7Z2V0OigpPT5PYmplY3Qua2V5cyhlKS5tYXAoZz0+U2sudW5maXhSZXNlcnZlZChnKSkuZmlsdGVyKGc9PiFnLmluY2x1ZGVzKFwiJFwiKSkubGVuZ3RoLGNvbmZpZ3VyYWJsZTohMH19KX1Tay5idWlsdGluLm1hcHBpbmdwcm94eT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwibWFwcGluZ3Byb3h5XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGYpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLm1hcHBpbmdwcm94eSxcblwiYmFkIGNhbGwgdG8gbWFwcGluZyBwcm94eSwgdXNlICduZXcnXCIpO3RoaXMubWFwcGluZz1uZXcgU2suYnVpbHRpbi5kaWN0KFtdKTt2b2lkIDAhPT1mJiZiKHRoaXMubWFwcGluZyxmKX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkaGFzaDpTay5idWlsdGluLm5vbmUubm9uZSQsdHAkbmV3KGYsZSl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcIm1hcHBpbmdwcm94eVwiLGUpO1NrLmFic3RyLmNoZWNrT25lQXJnKFwibWFwcGluZ3Byb3h5XCIsZixlKTtmPWZbMF07aWYoIVNrLmJ1aWx0aW4uY2hlY2tNYXBwaW5nKGYpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm1hcHBpbmdwcm94eSgpIGFyZ3VtZW50IG11c3QgYmUgYSBtYXBwaW5nLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZikpO2U9bmV3IFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5O2UubWFwcGluZz1mO3JldHVybiBlfSx0cCRyaWNoY29tcGFyZShmLFxuZSl7cmV0dXJuIFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLm1hcHBpbmcsZixlKX0sdHAkc3RyKCl7cmV0dXJuIHRoaXMubWFwcGluZy50cCRzdHIoKX0sJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwibWFwcGluZ3Byb3h5KFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5tYXBwaW5nKStcIilcIil9LG1wJHN1YnNjcmlwdChmLGUpe3JldHVybiB0aGlzLm1hcHBpbmcubXAkc3Vic2NyaXB0KGYsZSl9LHNxJGNvbnRhaW5zKGYpe3JldHVybiB0aGlzLm1hcHBpbmcuc3EkY29udGFpbnMoZil9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLm1hcHBpbmcuc3EkbGVuZ3RoKCl9LHRwJGl0ZXIoKXtyZXR1cm4gdGhpcy5tYXBwaW5nLnRwJGl0ZXIoKX0sdHAkYXNfbnVtYmVyOiEwLG5iJG9yKGYpe2YgaW5zdGFuY2VvZiBTay5idWlsdGluLm1hcHBpbmdwcm94eSYmKGY9Zi5tYXBwaW5nKTtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AodGhpcy5tYXBwaW5nLGYsXCJCaXRPclwiKX0sXG5uYiRyZWZsZWN0ZWRfb3IoZil7ZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5JiYoZj1mLm1hcHBpbmcpO3JldHVybiBTay5hYnN0ci5udW1iZXJCaW5PcChmLHRoaXMubWFwcGluZyxcIkJpdE9yXCIpfSxuYiRpbnBsYWNlX29yKGYpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIid8PScgaXMgbm90IHN1cHBvcnRlZCBieSBcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIjsgdXNlICd8JyBpbnN0ZWFkXCIpO319LG1ldGhvZHM6e2dldDp7JG1ldGgoZixlKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMubWFwcGluZy50cCRnZXRhdHRyKHRoaXMuc3RyJGdldCksZixlKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5nZXQoa1ssZF0pIC0+IERba10gaWYgayBpbiBELCBlbHNlIGQuICBkIGRlZmF1bHRzIHRvIE5vbmUuXCJ9LGtleXM6eyRtZXRoKCl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLm1hcHBpbmcudHAkZ2V0YXR0cih0aGlzLnN0ciRrZXlzKSxcbltdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQua2V5cygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGtleXNcIn0saXRlbXM6eyRtZXRoKCl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLm1hcHBpbmcudHAkZ2V0YXR0cih0aGlzLnN0ciRpdGVtcyksW10pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5pdGVtcygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGl0ZW1zXCJ9LHZhbHVlczp7JG1ldGgoKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMubWFwcGluZy50cCRnZXRhdHRyKHRoaXMuc3RyJHZhbHVlcyksW10pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC52YWx1ZXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyB2YWx1ZXNcIn0sY29weTp7JG1ldGgoKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMubWFwcGluZy50cCRnZXRhdHRyKHRoaXMuc3RyJGNvcHkpLFxuW10pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5jb3B5KCkgLT4gYSBzaGFsbG93IGNvcHkgb2YgRFwifX0sY2xhc3NtZXRob2RzOlNrLmdlbmVyaWMuY2xhc3NHZXRJdGVtLHByb3RvOntzdHIkZ2V0Om5ldyBTay5idWlsdGluLnN0cihcImdldFwiKSxzdHIkY29weTpuZXcgU2suYnVpbHRpbi5zdHIoXCJjb3B5XCIpLHN0ciRrZXlzOm5ldyBTay5idWlsdGluLnN0cihcImtleXNcIiksc3RyJGl0ZW1zOm5ldyBTay5idWlsdGluLnN0cihcIml0ZW1zXCIpLHN0ciR2YWx1ZXM6bmV3IFNrLmJ1aWx0aW4uc3RyKFwidmFsdWVzXCIpLG1wJGxvb2t1cChmKXtyZXR1cm4gdGhpcy5tYXBwaW5nLm1wJGxvb2t1cChmKX19LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pfSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4ucHJvcGVydHk9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInByb3BlcnR5XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZixlLGcpe3RoaXMucHJvcCRnZXQ9XG5ifHxTay5idWlsdGluLm5vbmUubm9uZSQ7dGhpcy5wcm9wJHNldD1mfHxTay5idWlsdGluLm5vbmUubm9uZSQ7dGhpcy5wcm9wJGRlbD1lfHxTay5idWlsdGluLm5vbmUubm9uZSQ7dGhpcy5wcm9wJGRvYz1nfHxiJiZiLiRkb2N8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJG5ldzpTay5nZW5lcmljLm5ldyx0cCRpbml0KGIsZil7Yj1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcInByb3BlcnR5XCIsW1wiZmdldFwiLFwiZnNldFwiLFwiZmRlbFwiLFwiZG9jXCJdLGIsZixBcnJheSg0KS5maWxsKFNrLmJ1aWx0aW4ubm9uZS5ub25lJCkpO3RoaXMucHJvcCRnZXQ9YlswXTt0aGlzLnByb3Akc2V0PWJbMV07dGhpcy5wcm9wJGRlbD1iWzJdO1NrLmJ1aWx0aW4uY2hlY2tOb25lKGJbM10pP1NrLmJ1aWx0aW4uY2hlY2tOb25lKGJbMF0pfHwodGhpcy5wcm9wJGRvYz1iWzBdLiRkb2N8fGJbM10pOnRoaXMucHJvcCRkb2M9XG5iWzNdfSx0cCRkb2M6XCJQcm9wZXJ0eSBhdHRyaWJ1dGUuXFxuXFxuICBmZ2V0XFxuICAgIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGdldHRpbmcgYW4gYXR0cmlidXRlIHZhbHVlXFxuICBmc2V0XFxuICAgIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHNldHRpbmcgYW4gYXR0cmlidXRlIHZhbHVlXFxuICBmZGVsXFxuICAgIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGRlbCdpbmcgYW4gYXR0cmlidXRlXFxuICBkb2NcXG4gICAgZG9jc3RyaW5nXFxuXFxuVHlwaWNhbCB1c2UgaXMgdG8gZGVmaW5lIGEgbWFuYWdlZCBhdHRyaWJ1dGUgeDpcXG5cXG5jbGFzcyBDKG9iamVjdCk6XFxuICAgIGRlZiBnZXR4KHNlbGYpOiByZXR1cm4gc2VsZi5feFxcbiAgICBkZWYgc2V0eChzZWxmLCB2YWx1ZSk6IHNlbGYuX3ggPSB2YWx1ZVxcbiAgICBkZWYgZGVseChzZWxmKTogZGVsIHNlbGYuX3hcXG4gICAgeCA9IHByb3BlcnR5KGdldHgsIHNldHgsIGRlbHgsICdJJ20gdGhlICd4JyBwcm9wZXJ0eS4nKVxcblxcbkRlY29yYXRvcnMgbWFrZSBkZWZpbmluZyBuZXcgcHJvcGVydGllcyBvciBtb2RpZnlpbmcgZXhpc3Rpbmcgb25lcyBlYXN5OlxcblxcbmNsYXNzIEMob2JqZWN0KTpcXG4gICAgQHByb3BlcnR5XFxuICAgIGRlZiB4KHNlbGYpOlxcbiAgICAgICAgJ0kgYW0gdGhlICd4JyBwcm9wZXJ0eS4nXFxuICAgICAgICByZXR1cm4gc2VsZi5feFxcbiAgICBAeC5zZXR0ZXJcXG4gICAgZGVmIHgoc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgc2VsZi5feCA9IHZhbHVlXFxuICAgIEB4LmRlbGV0ZXJcXG4gICAgZGVmIHgoc2VsZik6XFxuICAgICAgICBkZWwgc2VsZi5feFwiLFxudHAkZGVzY3JfZ2V0KGIsZixlKXtpZihudWxsPT09YilyZXR1cm4gdGhpcztpZih2b2lkIDA9PT10aGlzLnByb3AkZ2V0KXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwidW5yZWFkYWJsZSBhdHRyaWJ1dGVcIik7Yj1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkodGhpcy5wcm9wJGdldCxbYl0pO3JldHVybiBlP2I6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGIpfSx0cCRkZXNjcl9zZXQoYixmLGUpe2xldCBnO2c9bnVsbD09Zj90aGlzLnByb3AkZGVsOnRoaXMucHJvcCRzZXQ7aWYoU2suYnVpbHRpbi5jaGVja05vbmUoZykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCJjYW4ndCBcIisobnVsbD09Zj9cImRlbGV0ZVwiOlwic2V0XCIpK1wiIGF0dHJpYnV0ZVwiKTtpZighZy50cCRjYWxsKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShnKStcIicgaXMgbm90IGNhbGxhYmxlXCIpO1xuYj1udWxsPT1mP2cudHAkY2FsbChbYl0pOmcudHAkY2FsbChbYixmXSk7cmV0dXJuIGU/YjpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coYil9fSxtZXRob2RzOntnZXR0ZXI6eyRtZXRoKGIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5wcm9wZXJ0eShiLHRoaXMucHJvcCRzZXQsdGhpcy5wcm9wJGRlbCx0aGlzLnByb3AkZG9jKX0sJGZsYWdzOntPbmVBcmc6ITB9fSxzZXR0ZXI6eyRtZXRoKGIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5wcm9wZXJ0eSh0aGlzLnByb3AkZ2V0LGIsdGhpcy5wcm9wJGRlbCx0aGlzLnByb3AkZG9jKX0sJGZsYWdzOntPbmVBcmc6ITB9fSxkZWxldGVyOnskbWV0aChiKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucHJvcGVydHkodGhpcy5wcm9wJGdldCx0aGlzLnByb3Akc2V0LGIsdGhpcy5wcm9wJGRvYyl9LCRmbGFnczp7T25lQXJnOiEwfX19LGdldHNldHM6e2ZnZXQ6eyRnZXQoKXtyZXR1cm4gdGhpcy5wcm9wJGdldH19LGZzZXQ6eyRnZXQoKXtyZXR1cm4gdGhpcy5wcm9wJHNldH19LFxuZmRlbDp7JGdldCgpe3JldHVybiB0aGlzLnByb3AkZGVsfX0sX19kb2NfXzp7JGdldCgpe3JldHVybiB0aGlzLnByb3AkZG9jfSwkc2V0KGIpe3RoaXMucHJvcCRkb2M9Yj1ifHxTay5idWlsdGluLm5vbmUubm9uZSR9fX19KTtTay5idWlsdGluLmNsYXNzbWV0aG9kPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJjbGFzc21ldGhvZFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihiKXt0aGlzLmNtJGNhbGxhYmxlPWI7dGhpcy4kZD1uZXcgU2suYnVpbHRpbi5kaWN0fSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYixmKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwiY2xhc3NtZXRob2RcIixmKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJjbGFzc21ldGhvZFwiLGIsMSwxKTt0aGlzLmNtJGNhbGxhYmxlPWJbMF19LHRwJGRvYzpcImNsYXNzbWV0aG9kKGZ1bmN0aW9uKSAtPiBtZXRob2RcXG5cXG5Db252ZXJ0IGEgZnVuY3Rpb24gdG8gYmUgYSBjbGFzcyBtZXRob2QuXFxuXFxuQSBjbGFzcyBtZXRob2QgcmVjZWl2ZXMgdGhlIGNsYXNzIGFzIGltcGxpY2l0IGZpcnN0IGFyZ3VtZW50LFxcbmp1c3QgbGlrZSBhbiBpbnN0YW5jZSBtZXRob2QgcmVjZWl2ZXMgdGhlIGluc3RhbmNlLlxcblRvIGRlY2xhcmUgYSBjbGFzcyBtZXRob2QsIHVzZSB0aGlzIGlkaW9tOlxcblxcbiAgY2xhc3MgQzpcXG4gICAgICBAY2xhc3NtZXRob2RcXG4gICAgICBkZWYgZihjbHMsIGFyZzEsIGFyZzIsIC4uLik6XFxuICAgICAgICAgIC4uLlxcblxcbkl0IGNhbiBiZSBjYWxsZWQgZWl0aGVyIG9uIHRoZSBjbGFzcyAoZS5nLiBDLmYoKSkgb3Igb24gYW4gaW5zdGFuY2VcXG4oZS5nLiBDKCkuZigpKS4gIFRoZSBpbnN0YW5jZSBpcyBpZ25vcmVkIGV4Y2VwdCBmb3IgaXRzIGNsYXNzLlxcbklmIGEgY2xhc3MgbWV0aG9kIGlzIGNhbGxlZCBmb3IgYSBkZXJpdmVkIGNsYXNzLCB0aGUgZGVyaXZlZCBjbGFzc1xcbm9iamVjdCBpcyBwYXNzZWQgYXMgdGhlIGltcGxpZWQgZmlyc3QgYXJndW1lbnQuXFxuXFxuQ2xhc3MgbWV0aG9kcyBhcmUgZGlmZmVyZW50IHRoYW4gQysrIG9yIEphdmEgc3RhdGljIG1ldGhvZHMuXFxuSWYgeW91IHdhbnQgdGhvc2UsIHNlZSB0aGUgc3RhdGljbWV0aG9kIGJ1aWx0aW4uXCIsXG50cCRkZXNjcl9nZXQoYixmLGUpe2NvbnN0IGc9dGhpcy5jbSRjYWxsYWJsZTtpZih2b2lkIDA9PT1nKXRocm93IG5ldyBTay5idWlsdGluLlJ1bnRpbWVFcnJvcihcInVuaW5pdGlhbGl6ZWQgY2xhc3NtZXRob2Qgb2JqZWN0XCIpO3ZvaWQgMD09PWYmJihmPWIub2IkdHlwZSk7cmV0dXJuKGI9Zy50cCRkZXNjcl9nZXQpP2IuY2FsbChnLGYsZSk6bmV3IFNrLmJ1aWx0aW4ubWV0aG9kKGcsZil9fSxnZXRzZXRzOntfX2Z1bmNfXzp7JGdldCgpe3JldHVybiB0aGlzLmNtJGNhbGxhYmxlfX0sX19kaWN0X186U2suZ2VuZXJpYy5nZXRTZXREaWN0fX0pO1NrLmJ1aWx0aW4uc3RhdGljbWV0aG9kPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJzdGF0aWNtZXRob2RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYil7dGhpcy5zbSRjYWxsYWJsZT1iO3RoaXMuJGQ9bmV3IFNrLmJ1aWx0aW4uZGljdH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJG5ldzpTay5nZW5lcmljLm5ldyxcbnRwJGluaXQoYixmKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic3RhdGljbWV0aG9kXCIsZik7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwic3RhdGljbWV0aG9kXCIsYiwxLDEpO3RoaXMuc20kY2FsbGFibGU9YlswXX0sdHAkZG9jOlwic3RhdGljbWV0aG9kKGZ1bmN0aW9uKSAtPiBtZXRob2RcXG5cXG5Db252ZXJ0IGEgZnVuY3Rpb24gdG8gYmUgYSBzdGF0aWMgbWV0aG9kLlxcblxcbkEgc3RhdGljIG1ldGhvZCBkb2VzIG5vdCByZWNlaXZlIGFuIGltcGxpY2l0IGZpcnN0IGFyZ3VtZW50LlxcblRvIGRlY2xhcmUgYSBzdGF0aWMgbWV0aG9kLCB1c2UgdGhpcyBpZGlvbTpcXG5cXG4gICAgIGNsYXNzIEM6XFxuICAgICAgICAgQHN0YXRpY21ldGhvZFxcbiAgICAgICAgIGRlZiBmKGFyZzEsIGFyZzIsIC4uLik6XFxuICAgICAgICAgICAgIC4uLlxcblxcbkl0IGNhbiBiZSBjYWxsZWQgZWl0aGVyIG9uIHRoZSBjbGFzcyAoZS5nLiBDLmYoKSkgb3Igb24gYW4gaW5zdGFuY2VcXG4oZS5nLiBDKCkuZigpKS4gIFRoZSBpbnN0YW5jZSBpcyBpZ25vcmVkIGV4Y2VwdCBmb3IgaXRzIGNsYXNzLlxcblxcblN0YXRpYyBtZXRob2RzIGluIFB5dGhvbiBhcmUgc2ltaWxhciB0byB0aG9zZSBmb3VuZCBpbiBKYXZhIG9yIEMrKy5cXG5Gb3IgYSBtb3JlIGFkdmFuY2VkIGNvbmNlcHQsIHNlZSB0aGUgY2xhc3NtZXRob2QgYnVpbHRpbi5cIixcbnRwJGRlc2NyX2dldChiLGYpe2lmKHZvaWQgMD09PXRoaXMuc20kY2FsbGFibGUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKFwidW5pbml0aWFsaXplZCBzdGF0aWNtZXRob2Qgb2JqZWN0XCIpO3JldHVybiB0aGlzLnNtJGNhbGxhYmxlfX0sZ2V0c2V0czp7X19mdW5jX186eyRnZXQoKXtyZXR1cm4gdGhpcy5zbSRjYWxsYWJsZX19LF9fZGljdF9fOlNrLmdlbmVyaWMuZ2V0U2V0RGljdH19KX0sZnVuY3Rpb24oRSxRKXtmdW5jdGlvbiBiKEEsSCl7cmV0dXJuIGZ1bmN0aW9uKHgpe2lmKCEoeCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2xldCBCPXRoaXMudjt4PXgudjtpZihcIm51bWJlclwiPT09dHlwZW9mIEImJlwibnVtYmVyXCI9PT10eXBlb2YgeCl7Y29uc3QgRj1BKEIseCk7aWYobShGKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhGKX1CPWQoQik7eD1kKHgpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEgoQixcbngpKX19ZnVuY3Rpb24gZihBLEgpe3JldHVybiBmdW5jdGlvbih4KXtpZighKHggaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtsZXQgQj10aGlzLnY7eD14LnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBCJiZcIm51bWJlclwiPT09dHlwZW9mIHgpcmV0dXJuIEEoQix4KTtCPWQoQik7eD1kKHgpO3JldHVybiBIKEIseCl9fWZ1bmN0aW9uIGUoQSxIKXtyZXR1cm4gZnVuY3Rpb24oKXtsZXQgeD10aGlzLnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiB4KXtjb25zdCBCPUEoeCk7aWYodm9pZCAwIT09QilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhCKTt4PWQoeCl9cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oSCh4KSl9fWZ1bmN0aW9uIGcoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLnYpfWZ1bmN0aW9uIGsoQSxIKXtyZXR1cm4gZnVuY3Rpb24oeCl7aWYoISh4IGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7XG5sZXQgQj10aGlzLnY7eD14LnY7aWYoMD09PXgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgQiYmXCJudW1iZXJcIj09PXR5cGVvZiB4KXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEEoQix4KSk7Qj1kKEIpO3g9ZCh4KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLm51bWJlcklmU2FmZShIKEIseCkpKX19ZnVuY3Rpb24gcChBLEgpe3JldHVybiBmdW5jdGlvbih4KXtpZighKHggaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtpZih4Lm5iJGlzbmVnYXRpdmUoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibmVnYXRpdmUgc2hpZnQgY291bnRcIik7bGV0IEI9dGhpcy52O2lmKDA9PT1CKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKDApO1xueD14LnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBCJiZcIm51bWJlclwiPT09dHlwZW9mIHgmJjUzPngpe2NvbnN0IEY9QShCLHgpO2lmKHZvaWQgMCE9PUYpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oRil9Qj1kKEIpO3g9ZCh4KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhIKEIseCkpfX1mdW5jdGlvbiBoKEEsSCl7cmV0dXJuIGZ1bmN0aW9uKHgpe2lmKCEoeCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2xldCBCPXRoaXMudjt4PXgudjtpZihcIm51bWJlclwiPT09dHlwZW9mIEImJlwibnVtYmVyXCI9PT10eXBlb2YgeCYmTWF0aC5hYnMoQik8TWF0aC5wb3coMiwzMSkmJk1hdGguYWJzKHgpPE1hdGgucG93KDIsMzEpKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEEoQix4KSk7Qj1kKEIpO3g9ZCh4KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLm51bWJlcklmU2FmZShIKEIsXG54KSkpfX1mdW5jdGlvbiBhKEEpe3JldHVybiBKU0JJLmxlc3NUaGFuKEEsSlNCSS5fX1pFUk8pP0pTQkkudW5hcnlNaW51cyhBKTpBfWZ1bmN0aW9uIGMoQSxIKXtpZihKU0JJLmdyZWF0ZXJUaGFuT3JFcXVhbChKU0JJLmJpdHdpc2VYb3IoQSxIKSxKU0JJLl9fWkVSTykpcmV0dXJuIEpTQkkuZGl2aWRlKEEsSCk7QT1KU0JJLmxlc3NUaGFuKEEsSlNCSS5fX1pFUk8pP0pTQkkuYWRkKEEscSk6SlNCSS5zdWJ0cmFjdChBLHEpO3JldHVybiBKU0JJLnN1YnRyYWN0KEpTQkkuZGl2aWRlKEEsSCkscSl9ZnVuY3Rpb24gbShBKXtyZXR1cm4gQTw9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVImJkE+PS1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUn1mdW5jdGlvbiBuKEEpe3JldHVybiBBPD1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUiYmQT49LU51bWJlci5NQVhfU0FGRV9JTlRFR0VSPytBOkpTQkkuQmlnSW50KEEpfWZ1bmN0aW9uIGQoQSl7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBBP0pTQkkuQmlnSW50KEEpOlxuQX1Tay5idWlsdGluLmludF89U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImludFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihBKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfLFwiYmFkIGNhbGwgdG8gaW50IHVzZSAnbmV3J1wiKTtsZXQgSDtpZihcIm51bWJlclwiPT09dHlwZW9mIEEpe2lmKC02PEEmJjI1Nz5BKXJldHVybiBMW0FdO0g9QX1lbHNlIGlmKEpTQkkuX19pc0JpZ0ludChBKSlIPUE7ZWxzZXtpZih2b2lkIDA9PT1BKXJldHVybiBOO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgQSlIPW4oQSk7ZWxzZXtpZihBLm5iJGludClyZXR1cm4gQS5uYiRpbnQoKTtTay5hc3NlcnRzLmZhaWwoXCJiYWQgYXJndW1lbnQgdG8gaW50IGNvbnN0cnVjdG9yXCIpfX10aGlzLnY9SH0sc2xvdHM6e3RwJGFzX251bWJlcjohMCx0cCRkb2M6XCJpbnQoeD0wKSAtPiBpbnRlZ2VyXFxuaW50KHgsIGJhc2U9MTApIC0+IGludGVnZXJcXG5cXG5Db252ZXJ0IGEgbnVtYmVyIG9yIHN0cmluZyB0byBhbiBpbnRlZ2VyLCBvciByZXR1cm4gMCBpZiBubyBhcmd1bWVudHNcXG5hcmUgZ2l2ZW4uICBJZiB4IGlzIGEgbnVtYmVyLCByZXR1cm4geC5fX2ludF9fKCkuICBGb3IgZmxvYXRpbmcgcG9pbnRcXG5udW1iZXJzLCB0aGlzIHRydW5jYXRlcyB0b3dhcmRzIHplcm8uXFxuXFxuSWYgeCBpcyBub3QgYSBudW1iZXIgb3IgaWYgYmFzZSBpcyBnaXZlbiwgdGhlbiB4IG11c3QgYmUgYSBzdHJpbmcsXFxuYnl0ZXMsIG9yIGJ5dGVhcnJheSBpbnN0YW5jZSByZXByZXNlbnRpbmcgYW4gaW50ZWdlciBsaXRlcmFsIGluIHRoZVxcbmdpdmVuIGJhc2UuICBUaGUgbGl0ZXJhbCBjYW4gYmUgcHJlY2VkZWQgYnkgJysnIG9yICctJyBhbmQgYmUgc3Vycm91bmRlZFxcbmJ5IHdoaXRlc3BhY2UuICBUaGUgYmFzZSBkZWZhdWx0cyB0byAxMC4gIFZhbGlkIGJhc2VzIGFyZSAwIGFuZCAyLTM2LlxcbkJhc2UgMCBtZWFucyB0byBpbnRlcnByZXQgdGhlIGJhc2UgZnJvbSB0aGUgc3RyaW5nIGFzIGFuIGludGVnZXIgbGl0ZXJhbC5cXG4+Pj4gaW50KCcwYjEwMCcsIGJhc2U9MClcXG40XCIsXG4kcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvU3RyaW5nKCkpfSx0cCRoYXNoKCl7Y29uc3QgQT10aGlzLnY7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBBP0E6SlNCSS50b051bWJlcihKU0JJLnJlbWFpbmRlcihBLEpTQkkuX19NQVhfU0FGRSkpfSx0cCRuZXcoQSxIKXsxPT09QS5sZW5ndGgrKEg/SC5sZW5ndGg6MCk/KEg9QVswXSxBPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk6KEE9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJpbnRcIixbbnVsbCxcImJhc2VcIl0sQSxILFtOLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0pLEg9QVswXSxBPUFbMV0pO0E9QSE9PVNrLmJ1aWx0aW4ubm9uZS5ub25lJD9Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhBKTpudWxsO2lmKEggaW5zdGFuY2VvZiBTay5idWlsdGluLnN0ciludWxsPT09QSYmKEE9MTApLEg9bmV3IFNrLmJ1aWx0aW4uaW50XyhTay5zdHIybnVtYmVyKEgudixBKSk7ZWxzZXtpZihudWxsIT09QSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpbnQoKSBjYW4ndCBjb252ZXJ0IG5vbi1zdHJpbmcgd2l0aCBleHBsaWNpdCBiYXNlXCIpO1xuaWYoSC5uYiRpbnQpSD1ILm5iJGludCgpO2Vsc2UgaWYoQT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKEgsU2suYnVpbHRpbi5zdHIuJHRydW5jKSl7QT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoQSxbXSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQoQSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFNrLmJ1aWx0aW4uc3RyLiR0cnVuYy4kanNzdHIoKStcIiByZXR1cm5lZCBub24tSW50ZWdyYWwgKHR5cGUgXCIrU2suYWJzdHIudHlwZU5hbWUoSCkrXCIpXCIpO0g9bmV3IFNrLmJ1aWx0aW4uaW50XyhBLnYpfWVsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaW50KCkgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgYSBieXRlcy1saWtlIG9iamVjdCBvciBhIG51bWJlciwgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZShIKStcIidcIik7fWlmKHRoaXM9PT1Tay5idWlsdGluLmludF8ucHJvdG90eXBlKXJldHVybiBIO0E9bmV3IHRoaXMuY29uc3RydWN0b3I7QS52PUgudjtcbnJldHVybiBBfSx0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cixvYiRlcTpmKChBLEgpPT5BPT1ILEpTQkkuZXF1YWwpLG9iJG5lOmYoKEEsSCk9PkEhPUgsSlNCSS5ub3RFcXVhbCksb2IkZ3Q6ZigoQSxIKT0+QT5ILEpTQkkuZ3JlYXRlclRoYW4pLG9iJGdlOmYoKEEsSCk9PkE+PUgsSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwpLG9iJGx0OmYoKEEsSCk9PkE8SCxKU0JJLmxlc3NUaGFuKSxvYiRsZTpmKChBLEgpPT5BPD1ILEpTQkkubGVzc1RoYW5PckVxdWFsKSxuYiRpbnQ6ZyxuYiRpbmRleCgpe3JldHVybiB0aGlzLnZ9LG5iJGZsb2F0KCl7dmFyIEE9dGhpcy52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgQSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKEEpO0E9cGFyc2VGbG9hdChKU0JJLnRvTnVtYmVyKEEpKTtpZihJbmZpbml0eT09PUF8fC1JbmZpbml0eT09PUEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcImludCB0b28gbGFyZ2UgdG8gY29udmVydCB0byBmbG9hdFwiKTtcbnJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oQSl9LG5iJGlzbmVnYXRpdmUoKXtjb25zdCBBPXRoaXMudjtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIEE/MD5BOkpTQkkubGVzc1RoYW4oQSxKU0JJLl9fWkVSTyl9LG5iJGlzcG9zaXRpdmUoKXtjb25zdCBBPXRoaXMudjtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIEE/MDw9QTpKU0JJLmdyZWF0ZXJUaGFuT3JFcXVhbChBLEpTQkkuX19aRVJPKX0sbmIkYm9vbCgpe3JldHVybiAwIT09dGhpcy52fSxuYiRwb3NpdGl2ZTpnLG5iJG5lZ2F0aXZlOmUoQT0+LUEsSlNCSS51bmFyeU1pbnVzKSxuYiRhZGQ6YigoQSxIKT0+QStILChBLEgpPT5KU0JJLm51bWJlcklmU2FmZShKU0JJLmFkZChBLEgpKSksbmIkc3VidHJhY3Q6YigoQSxIKT0+QS1ILChBLEgpPT5KU0JJLm51bWJlcklmU2FmZShKU0JJLnN1YnRyYWN0KEEsSCkpKSxuYiRtdWx0aXBseTpiKChBLEgpPT5BKkgsKEEsSCk9PkE9PT1KU0JJLl9fWkVST3x8SD09PUpTQkkuX19aRVJPP1xuMDpKU0JJLm11bHRpcGx5KEEsSCkpLG5iJGRpdmlkZTpmdW5jdGlvbihBKXtpZighU2suX19mdXR1cmVfXy5weXRob24zKXJldHVybiB0aGlzLm5iJGZsb29yX2RpdmlkZShBKTtpZighKEEgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDt2YXIgSD10aGlzLnYseD1BLnY7aWYoMD09PXgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgSCYmXCJudW1iZXJcIj09PXR5cGVvZiB4KXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oSC94KTtIPWQoSCk7eD1kKHgpO0E9SlNCSS5sZXNzVGhhbihKU0JJLmJpdHdpc2VYb3IoSCx4KSxKU0JJLl9fWkVSTyk7aWYoSlNCSS5lcXVhbChILEpTQkkuX19aRVJPKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKEE/LTA6MCk7SD1hKEgpO3g9YSh4KTtpZihKU0JJLmdyZWF0ZXJUaGFuT3JFcXVhbChILFxuSlNCSS5tdWx0aXBseSh0LHgpKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50L2ludCB0b28gbGFyZ2UgdG8gcmVwcmVzZW50IGFzIGEgZmxvYXRcIik7dmFyIEI9SC50b1N0cmluZygyKS5sZW5ndGgteC50b1N0cmluZygyKS5sZW5ndGgsRj1KU0JJLkJpZ0ludCgwPkI/LUI6Qik7aWYoMDw9QiYmSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwoSCxKU0JJLm11bHRpcGx5KEpTQkkuZXhwb25lbnRpYXRlKHYsRikseCkpfHwwPkImJkpTQkkuZ3JlYXRlclRoYW5PckVxdWFsKEpTQkkubXVsdGlwbHkoSCxKU0JJLmV4cG9uZW50aWF0ZSh2LEYpKSx4KSlCKz0xO0I9TWF0aC5tYXgoQixyKS1sO0g9SlNCSS5sZWZ0U2hpZnQoSCxKU0JJLkJpZ0ludChNYXRoLm1heCgtQiwwKSkpO3g9SlNCSS5sZWZ0U2hpZnQoeCxKU0JJLkJpZ0ludChNYXRoLm1heChCLDApKSk7Rj1KU0JJLmRpdmlkZShILHgpO0g9SlNCSS5yZW1haW5kZXIoSCx4KTtIPUpTQkkubXVsdGlwbHkodixIKTtcbmlmKEpTQkkuZ3JlYXRlclRoYW4oSCx4KXx8SlNCSS5lcXVhbChILHgpJiZKU0JJLmVxdWFsKEpTQkkucmVtYWluZGVyKEYsdikscSkpRj1KU0JJLmFkZChGLHEpO0Y9SlNCSS50b051bWJlcihGKTtpZihJbmZpbml0eT09PUZ8fC1JbmZpbml0eT09PUYpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcImludC9pbnQgdG9vIGxhcmdlIHRvIHJlcHJlc2VudCBhcyBhIGZsb2F0XCIpO3g9RipNYXRoLnBvdygyLEIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oQT8teDp4KX0sbmIkZmxvb3JfZGl2aWRlOmsoKEEsSCk9Pk1hdGguZmxvb3IoQS9IKSxjKSxuYiRyZW1haW5kZXI6aygoQSxIKT0+QS1NYXRoLmZsb29yKEEvSCkqSCwoQSxIKT0+SlNCSS5zdWJ0cmFjdChBLEpTQkkubXVsdGlwbHkoSCxjKEEsSCkpKSksbmIkZGl2bW9kKEEpe2NvbnN0IEg9dGhpcy5uYiRmbG9vcl9kaXZpZGUoQSk7QT10aGlzLm5iJHJlbWFpbmRlcihBKTtyZXR1cm4gSD09PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfHxcbkE9PT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJD9Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDpuZXcgU2suYnVpbHRpbi50dXBsZShbSCxBXSl9LG5iJGFuZDpoKChBLEgpPT5BJkgsSlNCSS5iaXR3aXNlQW5kKSxuYiRvcjpoKChBLEgpPT5BfEgsSlNCSS5iaXR3aXNlT3IpLG5iJHhvcjpoKChBLEgpPT5BXkgsSlNCSS5iaXR3aXNlWG9yKSxuYiRhYnM6ZShNYXRoLmFicyxhKSxuYiRsc2hpZnQ6cCgoQSxIKT0+e0E9MipBKkNbSF07aWYobShBKSlyZXR1cm4gQX0sSlNCSS5sZWZ0U2hpZnQpLG5iJHJzaGlmdDpwKChBLEgpPT57TWF0aC5mbG9vcihBL0NbSCsxXSl9LChBLEgpPT5KU0JJLm51bWJlcklmU2FmZShKU0JJLnNpZ25lZFJpZ2h0U2hpZnQoQSxIKSkpLG5iJGludmVydDplKEE9Pk1hdGguYWJzKEEpPE1hdGgucG93KDIsMzEpP35BOnZvaWQgMCxBPT5KU0JJLm51bWJlcklmU2FmZShKU0JJLmJpdHdpc2VOb3QoQSkpKSxcbm5iJHBvd2VyKEEsSCl7bGV0IHg7dm9pZCAwIT09SCYmU2suYnVpbHRpbi5jaGVja05vbmUoSCkmJihIPXZvaWQgMCk7aWYoIShBIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfJiYodm9pZCAwPT09SHx8SCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCBCPUEubmIkaXNuZWdhdGl2ZSgpO2lmKEImJnZvaWQgMD09PUgpcmV0dXJuIHRoaXMubmIkZmxvYXQoKS5uYiRwb3dlcihBLm5iJGZsb2F0KCkpO2xldCBGPXRoaXMudjtBPUEudjtpZihcIm51bWJlclwiPT09dHlwZW9mIEYmJlwibnVtYmVyXCI9PT10eXBlb2YgQSl7Y29uc3QgSj1NYXRoLnBvdyhGLEEpO2lmKG0oSikmJih4PW5ldyBTay5idWlsdGluLmludF8oSiksdm9pZCAwPT09SCkpcmV0dXJuIHh9aWYodm9pZCAwIT09SCl7aWYoQil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwicG93KCkgMm5kIGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZSB3aGVuIDNyZCBhcmd1bWVudCBzcGVjaWZpZWRcIik7XG5pZigwPT09SC52KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJwb3coKSAzcmQgYXJndW1lbnQgY2Fubm90IGJlIDBcIik7cmV0dXJuIHZvaWQgMCE9PXg/eC5uYiRyZW1haW5kZXIoSCk6bmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLnBvd2VybW9kKGQoRiksZChBKSxkKEgudikpKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLmV4cG9uZW50aWF0ZShkKEYpLGQoQSkpKX0sbmIkbG9uZygpe3JldHVybiBuZXcgU2suYnVpbHRpbi5sbmcodGhpcy52KX19LGdldHNldHM6e3JlYWw6eyRnZXQ6ZywkZG9jOlwidGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9LGltYWc6eyRnZXQoKXtyZXR1cm4gTn0sJGRvYzpcInRoZSBpbWFnaW5hcnkgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9fSxtZXRob2RzOntjb25qdWdhdGU6eyRtZXRoOmcsJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybnMgc2VsZiwgdGhlIGNvbXBsZXggY29uanVnYXRlIG9mIGFueSBpbnQuXCJ9LFxuYml0X2xlbmd0aDp7JG1ldGgoKXtsZXQgQT10aGlzLnY7aWYoMD09PUEpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7QT1cIm51bWJlclwiPT09dHlwZW9mIEE/TWF0aC5hYnMoQSk6YShBKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhBLnRvU3RyaW5nKDIpLmxlbmd0aCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiTnVtYmVyIG9mIGJpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCBzZWxmIGluIGJpbmFyeS5cXG5cXG4+Pj4gYmluKDM3KVxcbicwYjEwMDEwMSdcXG4+Pj4gKDM3KS5iaXRfbGVuZ3RoKClcXG42XCJ9LHRvX2J5dGVzOnskbWV0aCgpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFwiKTt9LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBsZW5ndGgsIGJ5dGVvcmRlciwgKiwgc2lnbmVkPUZhbHNlKVwiLCRkb2M6XCJSZXR1cm4gYW4gYXJyYXkgb2YgYnl0ZXMgcmVwcmVzZW50aW5nIGFuIGludGVnZXIuXFxuXFxuICBsZW5ndGhcXG4gICAgTGVuZ3RoIG9mIGJ5dGVzIG9iamVjdCB0byB1c2UuICBBbiBPdmVyZmxvd0Vycm9yIGlzIHJhaXNlZCBpZiB0aGVcXG4gICAgaW50ZWdlciBpcyBub3QgcmVwcmVzZW50YWJsZSB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2YgYnl0ZXMuXFxuICBieXRlb3JkZXJcXG4gICAgVGhlIGJ5dGUgb3JkZXIgdXNlZCB0byByZXByZXNlbnQgdGhlIGludGVnZXIuICBJZiBieXRlb3JkZXIgaXMgJ2JpZycsXFxuICAgIHRoZSBtb3N0IHNpZ25pZmljYW50IGJ5dGUgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYnl0ZSBhcnJheS4gIElmXFxuICAgIGJ5dGVvcmRlciBpcyAnbGl0dGxlJywgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBpcyBhdCB0aGUgZW5kIG9mIHRoZVxcbiAgICBieXRlIGFycmF5LiAgVG8gcmVxdWVzdCB0aGUgbmF0aXZlIGJ5dGUgb3JkZXIgb2YgdGhlIGhvc3Qgc3lzdGVtLCB1c2VcXG4gICAgYHN5cy5ieXRlb3JkZXInIGFzIHRoZSBieXRlIG9yZGVyIHZhbHVlLlxcbiAgc2lnbmVkXFxuICAgIERldGVybWluZXMgd2hldGhlciB0d28ncyBjb21wbGVtZW50IGlzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyLlxcbiAgICBJZiBzaWduZWQgaXMgRmFsc2UgYW5kIGEgbmVnYXRpdmUgaW50ZWdlciBpcyBnaXZlbiwgYW4gT3ZlcmZsb3dFcnJvclxcbiAgICBpcyByYWlzZWQuXCJ9LFxuX190cnVuY19fOnskbWV0aDpnLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJUcnVuY2F0aW5nIGFuIEludGVncmFsIHJldHVybnMgaXRzZWxmLlwifSxfX2Zsb29yX186eyRtZXRoOmcsJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkZsb29yaW5nIGFuIEludGVncmFsIHJldHVybnMgaXRzZWxmLlwifSxfX2NlaWxfXzp7JG1ldGg6ZywkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQ2VpbGluZyBvZiBhbiBJbnRlZ3JhbCByZXR1cm5zIGl0c2VsZi5cIn0sX19yb3VuZF9fOnskbWV0aChBKXtyZXR1cm4gdGhpcy5yb3VuZCQoQSl9LCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUm91bmRpbmcgYW4gSW50ZWdyYWwgcmV0dXJucyBpdHNlbGYuXFxuUm91bmRpbmcgd2l0aCBhbiBuZGlnaXRzIGFyZ3VtZW50IGFsc28gcmV0dXJucyBhbiBpbnRlZ2VyLlwifSxfX2dldG5ld2FyZ3NfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmludF8odGhpcy52KV0pfSxcbiRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sX19mb3JtYXRfXzp7JG1ldGg6U2suZm9ybWF0dGluZy5ta051bWJlcl9fZm9ybWF0X18oITEpLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgZm9ybWF0X3NwZWMsIC8pXCIsJGRvYzpTay5idWlsdGluLm5vbmUubm9uZSR9fSxwcm90bzp7c3RyJChBLEgpe0E9dm9pZCAwPT09QXx8MTA9PT1BP3RoaXMudi50b1N0cmluZygpOnRoaXMudi50b1N0cmluZyhBKTtIfHx2b2lkIDA9PT1IfHxcIi1cIj09PUFbMF0mJihBPUEuc3Vic3RyaW5nKDEpKTtyZXR1cm4gQX0scm91bmQkKEEpe0E9dm9pZCAwPT09QT8wOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChBKTt2YXIgSD10aGlzLnY7aWYoMDw9QSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhIKTtpZihcIm51bWJlclwiIT09dHlwZW9mIEgpe3t2YXIgeD1BOyhBPUpTQkkubGVzc1RoYW4oSCxKU0JJLl9fWkVSTykpJiZcbihIPUpTQkkudW5hcnlNaW51cyhIKSk7eD1KU0JJLmV4cG9uZW50aWF0ZShKU0JJLkJpZ0ludCgxMCksSlNCSS51bmFyeU1pbnVzKEpTQkkuQmlnSW50KHgpKSk7bGV0IEI9SlNCSS5kaXZpZGUoSCx4KTtIPUpTQkkucmVtYWluZGVyKEgseCk7SD1KU0JJLm11bHRpcGx5KEgsdik7SlNCSS5ncmVhdGVyVGhhbihILHgpP0I9SlNCSS5hZGQoQixxKTpKU0JJLmVxdWFsKEgseCkmJihTay5fX2Z1dHVyZV9fLmJhbmtlcnNfcm91bmRpbmc/SlNCSS5lcXVhbChKU0JJLnJlbWFpbmRlcihCLHYpLHEpJiYoQj1KU0JJLmFkZChCLHEpKTpCPUpTQkkuYWRkKEIscSkpO0I9SlNCSS5tdWx0aXBseShCLHgpO0EmJihCPUpTQkkudW5hcnlNaW51cyhCKSk7QT1uZXcgU2suYnVpbHRpbi5pbnRfKEIpfXJldHVybiBBfUE9TWF0aC5wb3coMTAsLUEpO2lmKEEvMTA+TWF0aC5hYnMoSCkpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7aWYoIVNrLl9fZnV0dXJlX18uYmFua2Vyc19yb3VuZGluZylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhNYXRoLnJvdW5kKEgvXG5BKSpBKTtILz1BO3g9TWF0aC5yb3VuZChIKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygoLjU9PT0oMDxIP0g6LUgpJTE/MD09PXglMj94OngtMTp4KSpBKX0sdmFsdWVPZigpe3JldHVybiB0aGlzLnZ9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uaW50X1wiLFNrLmJ1aWx0aW4uaW50Xyk7Y29uc3QgbD1NYXRoLmxvZzIoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO0U9SlNCSS5CaWdJbnQoTWF0aC5mbG9vcihNYXRoLmxvZzIoTnVtYmVyLk1BWF9WQUxVRSkpKTtjb25zdCByPU1hdGguY2VpbChNYXRoLmxvZzIoTnVtYmVyLk1JTl9WQUxVRSkpLHY9SlNCSS5CaWdJbnQoMikscT1KU0JJLkJpZ0ludCgxKSx0PUpTQkkuc3VidHJhY3QoSlNCSS5leHBvbmVudGlhdGUodixFKSxKU0JJLmV4cG9uZW50aWF0ZSh2LEpTQkkuc3VidHJhY3QoRSxKU0JJLmFkZChKU0JJLkJpZ0ludChsKSxxKSkpKSx3PS9fKD89W15fXSkvZztTay5zdHIybnVtYmVyPWZ1bmN0aW9uKEEsSCl7dmFyIHg9XG5BLEI9ITEsRjtBPUEucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKTtcIi1cIj09PUEuY2hhckF0KDApJiYoQj0hMCxBPUEuc3Vic3RyaW5nKDEpKTtcIitcIj09PUEuY2hhckF0KDApJiYoQT1BLnN1YnN0cmluZygxKSk7aWYobnVsbD09PUh8fHZvaWQgMD09PUgpSD0xMDtpZigoMj5IfHwzNjxIKSYmMCE9PUgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImludCgpIGJhc2UgbXVzdCBiZSA+PSAyIGFuZCA8PSAzNlwiKTtcInN0cmluZ1wiPT09dHlwZW9mIEgmJihIPU51bWJlcihIKSk7aWYoXCIweFwiPT09QS5zdWJzdHJpbmcoMCwyKS50b0xvd2VyQ2FzZSgpKWlmKDE2PT09SHx8MD09PUgpQT1BLnN1YnN0cmluZygyKSxIPTE2O2Vsc2V7aWYoMzQ+SCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiaW52YWxpZCBsaXRlcmFsIGZvciBpbnQoKSB3aXRoIGJhc2UgXCIrSCtcIjogJ1wiK3grXCInXCIpO31lbHNlIGlmKFwiMGJcIj09PUEuc3Vic3RyaW5nKDAsMikudG9Mb3dlckNhc2UoKSlpZigyPT09XG5IfHwwPT09SClBPUEuc3Vic3RyaW5nKDIpLEg9MjtlbHNle2lmKDEyPkgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImludmFsaWQgbGl0ZXJhbCBmb3IgaW50KCkgd2l0aCBiYXNlIFwiK0grXCI6ICdcIit4K1wiJ1wiKTt9ZWxzZSBpZihcIjBvXCI9PT1BLnN1YnN0cmluZygwLDIpLnRvTG93ZXJDYXNlKCkpaWYoOD09PUh8fDA9PT1IKUE9QS5zdWJzdHJpbmcoMiksSD04O2Vsc2V7aWYoMjU+SCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiaW52YWxpZCBsaXRlcmFsIGZvciBpbnQoKSB3aXRoIGJhc2UgXCIrSCtcIjogJ1wiK3grXCInXCIpO31lbHNlIGlmKFwiMFwiPT09QS5jaGFyQXQoMCkpe2lmKFwiMFwiPT09QSlyZXR1cm4gMDtpZig4PT09SHx8MD09PUgpSD04fTA9PT1IJiYoSD0xMCk7aWYoLTEhPT1BLmluZGV4T2YoXCJfXCIpKXtpZigtMSE9PUEuaW5kZXhPZihcIl9fXCIpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitcbkgrXCI6ICdcIit4K1wiJ1wiKTtBPTEwIT09SD9BLnJlcGxhY2UodyxcIlwiKTpBLmNoYXJBdCgwKStBLnN1YnN0cmluZygxKS5yZXBsYWNlKHcsXCJcIil9aWYoMD09PUEubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitIK1wiOiAnXCIreCtcIidcIik7Zm9yKEY9MDtGPEEubGVuZ3RoO0YrPTEpe3ZhciBKPUEuY2hhckNvZGVBdChGKTt2YXIgUD1IOzQ4PD1KJiY1Nz49Sj9QPUotNDg6NjU8PUomJjkwPj1KP1A9Si02NSsxMDo5Nzw9SiYmMTIyPj1KJiYoUD1KLTk3KzEwKTtpZihQPj1IKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitIK1wiOiAnXCIreCtcIidcIik7fUImJihBPVwiLVwiK0EpO1A9cGFyc2VJbnQoQSxIKTtpZihtKFApKXJldHVybiBQO3g9ITE7XCItXCI9PT1BWzBdJiYoeD0hMCxBPUEuc3Vic3RyaW5nKDEpKTtIPUpTQkkuQmlnSW50KEgpO1xuQj1xO0Y9SlNCSS5fX1pFUk87Zm9yKEo9QS5sZW5ndGgtMTswPD1KO0otLSlQPUEuY2hhckNvZGVBdChKKSw0ODw9UCYmNTc+PVA/UC09NDg6NjU8PVAmJjkwPj1QP1A9UC02NSsxMDo5Nzw9UCYmMTIyPj1QJiYoUD1QLTk3KzEwKSxQPUpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoUCksQiksRj1KU0JJLmFkZChGLFApLEI9SlNCSS5tdWx0aXBseShCLEgpO3gmJihGPUpTQkkubXVsdGlwbHkoRixKU0JJLkJpZ0ludCgtMSkpKTtyZXR1cm4gQT1GfTtTay5idWlsdGluLmludF8ucHkyJG1ldGhvZHM9e307U2subG9uZ0Zyb21TdHI9ZnVuY3Rpb24oQSxIKXtpZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8obihBKSk7QT1Tay5zdHIybnVtYmVyKEEsSCk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxuZyhBKX07U2suZXhwb3J0U3ltYm9sKFwiU2subG9uZ0Zyb21TdHJcIixTay5sb25nRnJvbVN0cik7U2suYnVpbHRpbi5pbnRfLndpdGhpblRocmVzaG9sZD1cbm07U2suYnVpbHRpbi5pbnRfLnN0cmluZ1RvTnVtYmVyT3JCaWc9bjtjb25zdCBDPVsuNSwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMjA0OCw0MDk2LDgxOTIsMTYzODQsMzI3NjgsNjU1MzYsMTMxMDcyLDI2MjE0NCw1MjQyODgsMTA0ODU3NiwyMDk3MTUyLDQxOTQzMDQsODM4ODYwOCwxNjc3NzIxNiwzMzU1NDQzMiw2NzEwODg2NCwxMzQyMTc3MjgsMjY4NDM1NDU2LDUzNjg3MDkxMiwxMDczNzQxODI0LDIxNDc0ODM2NDgsNDI5NDk2NzI5Niw4NTg5OTM0NTkyLDE3MTc5ODY5MTg0LDM0MzU5NzM4MzY4LDY4NzE5NDc2NzM2LDEzNzQzODk1MzQ3MiwyNzQ4Nzc5MDY5NDQsNTQ5NzU1ODEzODg4LDEwOTk1MTE2Mjc3NzYsMjE5OTAyMzI1NTU1Miw0Mzk4MDQ2NTExMTA0LDg3OTYwOTMwMjIyMDgsMTc1OTIxODYwNDQ0MTYsMzUxODQzNzIwODg4MzIsNzAzNjg3NDQxNzc2NjQsMHg4MDAwMDAwMDAwMDAsMjgxNDc0OTc2NzEwNjU2LDU2Mjk0OTk1MzQyMTMxMiwweDQwMDAwMDAwMDAwMDAsXG4weDgwMDAwMDAwMDAwMDAsNDUwMzU5OTYyNzM3MDQ5Niw5MDA3MTk5MjU0NzQwOTkyXTtTay5idWlsdGluLmxuZz1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwibG9uZ1wiLHtiYXNlOlNrLmJ1aWx0aW4uaW50Xyxjb25zdHJ1Y3RvcjpmdW5jdGlvbihBKXtBPVNrLmJ1aWx0aW4uaW50Xy5jYWxsKHRoaXMsQSk7dm9pZCAwIT09QSYmKHRoaXMudj1BLnYpfSxzbG90czp7JHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi50b1N0cmluZygpK1wiTFwiKX0sdHAkYXNfbnVtYmVyOiEwLG5iJG5lZ2F0aXZlKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxuZyhELm5iJG5lZ2F0aXZlLmNhbGwodGhpcykudil9LG5iJHBvc2l0aXZlKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxuZyhELm5iJHBvc2l0aXZlLmNhbGwodGhpcykudil9fX0pO2NvbnN0IEQ9U2suYnVpbHRpbi5pbnRfLnByb3RvdHlwZSxMPVtdO2ZvcihFPS01OzI1Nz5FO0UrKylMW0VdPU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5pbnRfLnByb3RvdHlwZSxcbnt2Ont2YWx1ZTpFfX0pO2NvbnN0IE49TFswXX0sZnVuY3Rpb24oRSxRKXtjb25zdCBiPVNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGU7U2suYnVpbHRpbi5ib29sPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJib29sXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGYpe3JldHVybiBTay5taXNjZXZhbC5pc1RydWUoZik/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9LGJhc2U6U2suYnVpbHRpbi5pbnRfLHNsb3RzOnt0cCRkb2M6XCJib29sKHgpIC0+IGJvb2xcXG5cXG5SZXR1cm5zIFRydWUgd2hlbiB0aGUgYXJndW1lbnQgeCBpcyB0cnVlLCBGYWxzZSBvdGhlcndpc2UuXFxuVGhlIGJ1aWx0aW5zIFRydWUgYW5kIEZhbHNlIGFyZSB0aGUgb25seSB0d28gaW5zdGFuY2VzIG9mIHRoZSBjbGFzcyBib29sLlxcblRoZSBjbGFzcyBib29sIGlzIGEgc3ViY2xhc3Mgb2YgdGhlIGNsYXNzIGludCwgYW5kIGNhbm5vdCBiZSBzdWJjbGFzc2VkLlwiLHRwJG5ldyhmLGUpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJib29sXCIsXG5lKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJib29sXCIsZiwwLDEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKGZbMF0pfSwkcigpe3JldHVybiB0aGlzLnY/dGhpcy5zdHIkVHJ1ZTp0aGlzLnN0ciRGYWxzZX0sdHAkYXNfbnVtYmVyOiEwLG5iJGFuZChmKXtyZXR1cm4gZi5vYiR0eXBlPT09U2suYnVpbHRpbi5ib29sP25ldyBTay5idWlsdGluLmJvb2wodGhpcy52JmYudik6Yi5uYiRhbmQuY2FsbCh0aGlzLGYpfSxuYiRvcihmKXtyZXR1cm4gZi5vYiR0eXBlPT09U2suYnVpbHRpbi5ib29sP25ldyBTay5idWlsdGluLmJvb2wodGhpcy52fGYudik6Yi5uYiRvci5jYWxsKHRoaXMsZil9LG5iJHhvcihmKXtyZXR1cm4gZi5vYiR0eXBlPT09U2suYnVpbHRpbi5ib29sP25ldyBTay5idWlsdGluLmJvb2wodGhpcy52XmYudik6Yi5uYiR4b3IuY2FsbCh0aGlzLGYpfX0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9LG1ldGhvZHM6e19fZm9ybWF0X186eyRtZXRoKCl7cmV0dXJuIHRoaXMuJHIoKX0sXG4kZmxhZ3M6e09uZUFyZzohMH19fSxwcm90bzp7c3RyJEZhbHNlOm5ldyBTay5idWlsdGluLnN0cihcIkZhbHNlXCIpLHN0ciRUcnVlOm5ldyBTay5idWlsdGluLnN0cihcIlRydWVcIiksdmFsdWVPZigpe3JldHVybiEhdGhpcy52fX19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmJvb2xcIixTay5idWlsdGluLmJvb2wpO1NrLmJ1aWx0aW4uYm9vbC50cnVlJD1PYmplY3QuY3JlYXRlKFNrLmJ1aWx0aW4uYm9vbC5wcm90b3R5cGUse3Y6e3ZhbHVlOjEsZW51bWVyYWJsZTohMH19KTtTay5idWlsdGluLmJvb2wuZmFsc2UkPU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5ib29sLnByb3RvdHlwZSx7djp7dmFsdWU6MCxlbnVtZXJhYmxlOiEwfX0pfSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHRoaXMudil9ZnVuY3Rpb24gZihkKXtyZXR1cm4gZnVuY3Rpb24obCl7Y29uc3Qgcj10aGlzLnY7bD1sLnY7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBsKWlmKEpTQkkuX19pc0JpZ0ludChsKSl7aWYobD1cbnBhcnNlRmxvYXQoSlNCSS50b051bWJlcihsKSksSW5maW5pdHk9PWx8fC1JbmZpbml0eT09bCl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50IHRvbyBsYXJnZSB0byBjb252ZXJ0IHRvIGZsb2F0XCIpO31lbHNlIHJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtyZXR1cm4gZChyLGwpfX1mdW5jdGlvbiBlKGQsbCl7cmV0dXJuIGZ1bmN0aW9uKHIpe2NvbnN0IHY9dGhpcy52O3I9ci52O2lmKFwibnVtYmVyXCIhPT10eXBlb2Ygcil7aWYoIUpTQkkuX19pc0JpZ0ludChyKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7aWYodm9pZCAwIT09bClyZXR1cm4gbCh2LHIpfXJldHVybiBkKHYscil9fWZ1bmN0aW9uIGcoZCl7Y29uc3QgbD1mKGQpO3JldHVybiBmdW5jdGlvbihyLHYpe2lmKHZvaWQgMCE9PXYmJiFTay5idWlsdGluLmNoZWNrTm9uZSh2KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJwb3coKSAzcmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzXCIpO1xucmV0dXJuIGwuY2FsbCh0aGlzLHIpfX1mdW5jdGlvbiBrKGQsbCl7aWYoMD09PWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIpO3JldHVybiBJbmZpbml0eT09PWQ/SW5maW5pdHk9PT1sfHwtSW5maW5pdHk9PT1kP25ldyBTay5idWlsdGluLmZsb2F0XyhOYU4pOjA+bD9uZXcgU2suYnVpbHRpbi5mbG9hdF8oLUluZmluaXR5KTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oSW5maW5pdHkpOi1JbmZpbml0eT09PWQ/SW5maW5pdHk9PT1sfHwtSW5maW5pdHk9PT1kP25ldyBTay5idWlsdGluLmZsb2F0XyhOYU4pOjA+bD9uZXcgU2suYnVpbHRpbi5mbG9hdF8oSW5maW5pdHkpOm5ldyBTay5idWlsdGluLmZsb2F0XygtSW5maW5pdHkpOm5ldyBTay5idWlsdGluLmZsb2F0XyhkL2wpfWZ1bmN0aW9uIHAoZCxsKXtpZihJbmZpbml0eT09PWR8fC1JbmZpbml0eT09PWQpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhOYU4pO1xuaWYoMD09PWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIpO3JldHVybiBJbmZpbml0eT09PWw/MD5kP25ldyBTay5idWlsdGluLmZsb2F0XygtMSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApOi1JbmZpbml0eT09PWw/MD5kfHwwIT09ZD9uZXcgU2suYnVpbHRpbi5mbG9hdF8oMCk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC0xKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5mbG9vcihkL2wpKX1mdW5jdGlvbiBoKGQsbCl7aWYoMD09PWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIpO2lmKDA9PT1kKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oMCk7aWYoSW5maW5pdHk9PT1sKXJldHVybiBJbmZpbml0eT09PWR8fC1JbmZpbml0eT09PXRoaXMudj9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTmFOKTpcbjA8ZD9uZXcgU2suYnVpbHRpbi5mbG9hdF8oZCk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKEluZmluaXR5KTtsZXQgcj1kJWw7MD5kPzA8bCYmMD5yJiYocis9bCk6MD5sJiYwIT09ciYmKHIrPWwpOzA9PT1yJiYoMD5sP3I9LTA6LUluZmluaXR5PT09SW5maW5pdHkvciYmKHI9MCkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocil9ZnVuY3Rpb24gYShkLGwpe2lmKDA+ZCYmMCE9PWwlMSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibmVnYXRpdmUgbnVtYmVyIGNhbm5vdCBiZSByYWlzZWQgdG8gYSBmcmFjdGlvbmFsIHBvd2VyXCIpO2lmKDA9PT1kJiYwPmwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCIwLjAgY2Fubm90IGJlIHJhaXNlZCB0byBhIG5lZ2F0aXZlIHBvd2VyXCIpO2NvbnN0IHI9TWF0aC5wb3coZCxsKTtpZihJbmZpbml0eT09PU1hdGguYWJzKHIpJiZJbmZpbml0eSE9PU1hdGguYWJzKGQpJiZJbmZpbml0eSE9PU1hdGguYWJzKGwpKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3IoXCJOdW1lcmljYWwgcmVzdWx0IG91dCBvZiByYW5nZVwiKTtcbnJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocil9Y29uc3QgYz1PYmplY3QuY3JlYXRlKG51bGwse0luZmluaXR5Ont2YWx1ZTozMTQxNTl9LFwiLUluZmluaXR5XCI6e3ZhbHVlOi0zMTQxNTl9LE5hTjp7dmFsdWU6MH19KTtTay5idWlsdGluLmZsb2F0Xz1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiZmxvYXRcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZCl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfLFwiYmFkIGNhbGwgdG8gZmxvYXQgdXNlICduZXcnXCIpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZCl0aGlzLnY9ZDtlbHNlIGlmKHZvaWQgMD09PWQpdGhpcy52PTA7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGQpdGhpcy52PXBhcnNlRmxvYXQoZCk7ZWxzZXtpZihkLm5iJGZsb2F0KXJldHVybiBkLm5iJGZsb2F0KCk7U2suYXNzZXJ0cy5mYWlsKFwiYmFkIGFyZ3VtZW50IHRvIGZsb2F0IGNvbnN0cnVjdG9yXCIpfX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLFxudHAkYXNfbnVtYmVyOiEwLHRwJGRvYzpcIkNvbnZlcnQgYSBzdHJpbmcgb3IgbnVtYmVyIHRvIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCBpZiBwb3NzaWJsZS5cIix0cCRoYXNoKCl7Y29uc3QgZD10aGlzLnY7bGV0IGw9Y1tkXTtpZih2b2lkIDAhPT1sKXJldHVybiBsO2w9TnVtYmVyLmlzSW50ZWdlcihkKT90aGlzLm5iJGludCgpLnRwJGhhc2goKTpNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVItTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIvMik7cmV0dXJuIGNbdGhpcy52XT1sfSwkcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy5zdHIkKDEwLCEwKSl9LHRwJG5ldyhkLGwpe2lmKGwmJmwubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImZsb2F0KCkgdGFrZXMgbm8ga2V5d29yZCBhcmd1bWVudHNcIik7aWYoZCYmMTxkLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJmbG9hdCBleHBlY3RlZCBhdCBtb3N0IDEgYXJndW1lbnRzLCBnb3QgXCIrXG5kLmxlbmd0aCk7ZD1kWzBdO2lmKHZvaWQgMD09PWQpdmFyIHI9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApO2Vsc2UgaWYoZC5uYiRmbG9hdClyPWQubmIkZmxvYXQoKTtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZCkpe3I9ZC52O2Q9cjtpZigtMSE9PXIuaW5kZXhPZihcIl9cIikpe2lmKG0udGVzdChyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY291bGQgbm90IGNvbnZlcnQgc3RyaW5nIHRvIGZsb2F0OiAnXCIrcitcIidcIik7ZD1yLmNoYXJBdCgwKStyLnN1YnN0cmluZygxKS5yZXBsYWNlKG4sXCJcIil9aWYoci5tYXRjaCgvXi1pbmYkL2kpKXZhciB2PS1JbmZpbml0eTtlbHNlIHIubWF0Y2goL15bK10/aW5mJC9pKT92PUluZmluaXR5OnIubWF0Y2goL15bLStdP25hbiQvaSk/dj1OYU46aXNOYU4oZCl8fCh2PXBhcnNlRmxvYXQoZCksTnVtYmVyLmlzTmFOKHYpJiYodj12b2lkIDApKTtpZih2b2lkIDA9PT12KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb3VsZCBub3QgY29udmVydCBzdHJpbmcgdG8gZmxvYXQ6IFwiK1xuU2subWlzY2V2YWwub2JqZWN0UmVwcihuZXcgU2suYnVpbHRpbi5zdHIocikpKTtyPW5ldyBTay5idWlsdGluLmZsb2F0Xyh2KX1pZih2b2lkIDA9PT1yKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImZsb2F0KCkgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhIG51bWJlclwiKTtpZih0aGlzPT09U2suYnVpbHRpbi5mbG9hdF8ucHJvdG90eXBlKXJldHVybiByO3Y9bmV3IHRoaXMuY29uc3RydWN0b3I7di52PXIudjtyZXR1cm4gdn0sbmIkaW50KCl7bGV0IGQ9dGhpcy52O2lmKCFOdW1iZXIuaXNGaW5pdGUoZCkpe2lmKEluZmluaXR5PT09ZHx8LUluZmluaXR5PT09ZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiY2Fubm90IGNvbnZlcnQgZmxvYXQgaW5maW5pdHkgdG8gaW50ZWdlclwiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY2Fubm90IGNvbnZlcnQgZmxvYXQgTmFOIHRvIGludGVnZXJcIik7fWQ9MD5kP01hdGguY2VpbChkKTpcbk1hdGguZmxvb3IoZCk7cmV0dXJuIFNrLmJ1aWx0aW4uaW50Xy53aXRoaW5UaHJlc2hvbGQoZCk/bmV3IFNrLmJ1aWx0aW4uaW50XyhkKTpuZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkuQmlnSW50KGQpKX0sbmIkZmxvYXQ6YixuYiRsb25nKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxuZyh0aGlzLm5iJGludCgpLnYpfSxuYiRhZGQ6ZigoZCxsKT0+bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGQrbCkpLG5iJHN1YnRyYWN0OmYoKGQsbCk9Pm5ldyBTay5idWlsdGluLmZsb2F0XyhkLWwpKSxuYiRyZWZsZWN0ZWRfc3VidHJhY3Q6ZigoZCxsKT0+bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGwtZCkpLG5iJG11bHRpcGx5OmYoKGQsbCk9Pm5ldyBTay5idWlsdGluLmZsb2F0XyhkKmwpKSxuYiRkaXZpZGU6ZihrKSxuYiRyZWZsZWN0ZWRfZGl2aWRlOmYoKGQsbCk9PmsobCxkKSksbmIkZmxvb3JfZGl2aWRlOmYocCksbmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZTpmKChkLGwpPT5wKGwsZCkpLG5iJHJlbWFpbmRlcjpmKGgpLFxubmIkcmVmbGVjdGVkX3JlbWFpbmRlcjpmKChkLGwpPT5oKGwsZCkpLG5iJGRpdm1vZDpmKChkLGwpPT5uZXcgU2suYnVpbHRpbi50dXBsZShbcChkLGwpLGgoZCxsKV0pKSxuYiRyZWZsZWN0ZWRfZGl2bW9kOmYoKGQsbCk9Pm5ldyBTay5idWlsdGluLnR1cGxlKFtwKGwsZCksaChsLGQpXSkpLG5iJHBvd2VyOmcoYSksbmIkcmVmbGVjdGVkX3Bvd2VyOmcoKGQsbCk9PmEobCxkKSksbmIkYWJzKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmFicyh0aGlzLnYpKX0sbmIkbmVnYXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC10aGlzLnYpfSxuYiRwb3NpdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy52KX0sbmIkYm9vbCgpe3JldHVybiAwIT09dGhpcy52fSxuYiRpc25lZ2F0aXZlKCl7cmV0dXJuIDA+dGhpcy52fSxuYiRpc3Bvc2l0aXZlKCl7cmV0dXJuIDA8PXRoaXMudn0sb2IkZXE6ZSgoZCxsKT0+ZD09bCxKU0JJLkVRKSxcbm9iJG5lOmUoKGQsbCk9PmQhPWwsSlNCSS5ORSksb2IkZ3Q6ZSgoZCxsKT0+ZD5sLEpTQkkuR1QpLG9iJGdlOmUoKGQsbCk9PmQ+PWwsSlNCSS5HRSksb2IkbHQ6ZSgoZCxsKT0+ZDxsLEpTQkkuTFQpLG9iJGxlOmUoKGQsbCk9PmQ8PWwsSlNCSS5MRSl9LGdldHNldHM6e3JlYWw6eyRnZXQ6YiwkZG9jOlwidGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9LGltYWc6eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApfSwkZG9jOlwidGhlIGltYWdpbmFyeSBwYXJ0IG9mIGEgY29tcGxleCBudW1iZXJcIn19LG1ldGhvZHM6e2Nvbmp1Z2F0ZTp7JG1ldGg6YiwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBzZWxmLCB0aGUgY29tcGxleCBjb25qdWdhdGUgb2YgYW55IGZsb2F0LlwifSxfX3RydW5jX186eyRtZXRoKCl7cmV0dXJuIHRoaXMubmIkaW50KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIixcbiRkb2M6XCJSZXR1cm4gdGhlIEludGVncmFsIGNsb3Nlc3QgdG8geCBiZXR3ZWVuIDAgYW5kIHguXCJ9LF9fcm91bmRfXzp7JG1ldGgoZCl7cmV0dXJuIHRoaXMucm91bmQkKGQpfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuZGlnaXRzPU5vbmUsIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgSW50ZWdyYWwgY2xvc2VzdCB0byB4LCByb3VuZGluZyBoYWxmIHRvd2FyZCBldmVuLlxcblxcbldoZW4gYW4gYXJndW1lbnQgaXMgcGFzc2VkLCB3b3JrIGxpa2UgYnVpbHQtaW4gcm91bmQoeCwgbmRpZ2l0cykuXCJ9LGFzX2ludGVnZXJfcmF0aW86eyRtZXRoKCl7aWYoIU51bWJlci5pc0Zpbml0ZSh0aGlzLnYpKXtpZihOdW1iZXIuaXNOYU4odGhpcy52KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY2Fubm90IGNvbnZlcnQgTmFOIHRvIGludGVnZXIgcmF0aW9cIik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcImNhbm5vdCBjb252ZXJ0IEluZmluaXR5IHRvIGludGVnZXIgcmF0aW9cIik7XG59dmFyIGQ9dGhpcy52O3ZhciBsPVtkLDBdO2lmKDAhPT1kKXt2YXIgcj1NYXRoLmFicyhkKSx2PU1hdGgubWF4KC0xMDIzLE1hdGguZmxvb3IoTWF0aC5sb2cyKHIpKSsxKTtmb3Iocio9TWF0aC5wb3coMiwtdik7LjU+cjspcio9Mix2LS07Zm9yKDsxPD1yOylyKj0uNSx2Kys7MD5kJiYocj0tcik7bFswXT1yO2xbMV09dn1kPWw7bGV0IFtxLHRdPWQ7Zm9yKGQ9MDszMDA+ZCYmcSE9TWF0aC5mbG9vcihxKTtkKyspcSo9Mix0LS07ZD1uZXcgU2suYnVpbHRpbi5pbnRfKE1hdGguYWJzKHQpKTt2PW5ldyBTay5idWlsdGluLmludF8ocSk7bD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpOzA8dD92PXYubmIkbHNoaWZ0KGQpOmw9bC5uYiRsc2hpZnQoZCk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt2LGxdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gaW50ZWdlciByYXRpby5cXG5cXG5SZXR1cm4gYSBwYWlyIG9mIGludGVnZXJzLCB3aG9zZSByYXRpbyBpcyBleGFjdGx5IGVxdWFsIHRvIHRoZSBvcmlnaW5hbCBmbG9hdFxcbmFuZCB3aXRoIGEgcG9zaXRpdmUgZGVub21pbmF0b3IuXFxuXFxuUmFpc2UgT3ZlcmZsb3dFcnJvciBvbiBpbmZpbml0aWVzIGFuZCBhIFZhbHVlRXJyb3Igb24gTmFOcy5cXG5cXG4+Pj4gKDEwLjApLmFzX2ludGVnZXJfcmF0aW8oKVxcbigxMCwgMSlcXG4+Pj4gKDAuMCkuYXNfaW50ZWdlcl9yYXRpbygpXFxuKDAsIDEpXFxuPj4+ICgtLjI1KS5hc19pbnRlZ2VyX3JhdGlvKClcXG4oLTEsIDQpXCJ9LFxuaXNfaW50ZWdlcjp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbChOdW1iZXIuaXNJbnRlZ2VyKHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBmbG9hdCBpcyBhbiBpbnRlZ2VyLlwifSxfX2dldG5ld2FyZ3NfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3RoaXNdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6U2suYnVpbHRpbi5ub25lLm5vbmUkfSxfX2Zvcm1hdF9fOnskbWV0aDpTay5mb3JtYXR0aW5nLm1rTnVtYmVyX19mb3JtYXRfXyghMCksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBmb3JtYXRfc3BlYywgLylcIiwkZG9jOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LHByb3RvOnt2YWx1ZU9mKCl7cmV0dXJuIHRoaXMudn19fSk7Y29uc3QgbT0vX1tlRV18W2VFXV98XFwuX3xfXFwufFsrLV1ffF9fLyxcbm49L18oPz1bXl9dKS9nO1NrLmJ1aWx0aW4uZmxvYXRfLlB5RmxvYXRfQ2hlY2s9ZnVuY3Rpb24oZCl7cmV0dXJuIHZvaWQgMD09PWQ/ITE6U2suYnVpbHRpbi5jaGVja051bWJlcihkKXx8U2suYnVpbHRpbi5jaGVja0Zsb2F0KGQpfHxkLm9iJHR5cGUuJGlzU3ViVHlwZShTay5idWlsdGluLmZsb2F0Xyk/ITA6ITF9O1NrLmJ1aWx0aW4uZmxvYXRfLnByb3RvdHlwZS50b0ZpeGVkPWZ1bmN0aW9uKGQpe2Q9U2suYnVpbHRpbi5hc251bSQoZCk7cmV0dXJuIHRoaXMudi50b0ZpeGVkKGQpfTtTay5idWlsdGluLmZsb2F0Xy5wcm90b3R5cGUucm91bmQkPWZ1bmN0aW9uKGQpe3ZhciBsPVNrLmJ1aWx0aW4uYXNudW0kKHRoaXMpO3ZhciByPXZvaWQgMD09PWQ/MDpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZCk7aWYoU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nKXtsKj1NYXRoLnBvdygxMCxyKTt2YXIgdj1NYXRoLnJvdW5kKGwpO3I9KC41PT09KDA8bD9sOi1sKSUxPzA9PT12JVxuMj92OnYtMTp2KS9NYXRoLnBvdygxMCxyKTtyZXR1cm4gdm9pZCAwPT09ZD9uZXcgU2suYnVpbHRpbi5pbnRfKHIpOm5ldyBTay5idWlsdGluLmZsb2F0XyhyKX1kPU1hdGgucG93KDEwLHIpO3I9TWF0aC5yb3VuZChsKmQpL2Q7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhyKX07U2suYnVpbHRpbi5mbG9hdF8ucHJvdG90eXBlLnN0ciQ9ZnVuY3Rpb24oZCxsKXtpZihpc05hTih0aGlzLnYpKXJldHVyblwibmFuXCI7dm9pZCAwPT09bCYmKGw9ITApO2lmKEluZmluaXR5PT10aGlzLnYpcmV0dXJuXCJpbmZcIjtpZigtSW5maW5pdHk9PXRoaXMudiYmbClyZXR1cm5cIi1pbmZcIjtpZigtSW5maW5pdHk9PXRoaXMudiYmIWwpcmV0dXJuXCJpbmZcIjtsPWw/dGhpcy52Ok1hdGguYWJzKHRoaXMudik7aWYodm9pZCAwPT09ZHx8MTA9PT1kKXt2YXIgcj1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/bC50b1ByZWNpc2lvbigxNik6bC50b1ByZWNpc2lvbigxMik7dmFyIHY9ci5pbmRleE9mKFwiLlwiKTtkPVxubC50b1N0cmluZygpLnNsaWNlKDAsdik7dj1sLnRvU3RyaW5nKCkuc2xpY2Uodik7ZC5tYXRjaCgvXi0/MCQvKSYmdi5zbGljZSgxKS5tYXRjaCgvXjB7NCx9LykmJihyPTEyPnIubGVuZ3RoP2wudG9FeHBvbmVudGlhbCgpOmwudG9FeHBvbmVudGlhbCgxMSkpO2lmKDA+ci5pbmRleE9mKFwiZVwiKSYmMDw9ci5pbmRleE9mKFwiLlwiKSl7Zm9yKDtcIjBcIj09ci5jaGFyQXQoci5sZW5ndGgtMSk7KXI9ci5zdWJzdHJpbmcoMCxyLmxlbmd0aC0xKTtcIi5cIj09ci5jaGFyQXQoci5sZW5ndGgtMSkmJihyKz1cIjBcIil9cj1yLnJlcGxhY2UoL1xcLjArZS8sXCJlXCIsXCJpXCIpO3I9ci5yZXBsYWNlKC8oZVstK10pKFsxLTldKSQvLFwiJDEwJDJcIik7cj1yLnJlcGxhY2UoLzArKGUuKikvLFwiJDFcIil9ZWxzZSByPWwudG9TdHJpbmcoZCk7MD09PXRoaXMudiYmLUluZmluaXR5PT09MS90aGlzLnYmJihyPVwiLVwiK3IpOzA+ci5pbmRleE9mKFwiLlwiKSYmMD5yLmluZGV4T2YoXCJFXCIpJiYwPnIuaW5kZXhPZihcImVcIikmJihyKz1cblwiLjBcIik7cmV0dXJuIHJ9O1NrLmJ1aWx0aW4uZmxvYXRfLnB5MiRtZXRob2RzPXt9fSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoZCl7bGV0IGw9ZC52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgbClyZXR1cm4gbDtkLm5iJGZsb2F0JiYobD1kLm5iJGZsb2F0KCkpO2lmKHZvaWQgMD09PWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYSBmbG9hdCBpcyByZXF1aXJlZFwiKTtyZXR1cm4gbC52fWZ1bmN0aW9uIGYoZCxsLHIpe2lmKHI9PT1Tay5idWlsdGluLmNvbXBsZXgucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi5jb21wbGV4KGQsbCk7cj1uZXcgci5jb25zdHJ1Y3RvcjtTay5idWlsdGluLmNvbXBsZXguY2FsbChyLGQsbCk7cmV0dXJuIHJ9ZnVuY3Rpb24gZShkLGwpe3JldHVybiBmdW5jdGlvbihyKXtjb25zdCB2PXRoaXMucmVhbCxxPXRoaXMuaW1hZzt2YXIgdD1yLnJlYWw7Y29uc3Qgdz1yLnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiB0KXI9ci5pbWFnO2Vsc2UgaWYoXCJudW1iZXJcIj09PVxudHlwZW9mIHcpdD13LHI9MDtlbHNlIGlmKEpTQkkuX19pc0JpZ0ludCh3KSl7aWYodm9pZCAwPT09bCl7aWYodD1wYXJzZUZsb2F0KEpTQkkudG9OdW1iZXIodykpLEluZmluaXR5PT10fHwtSW5maW5pdHk9PXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcImludCB0b28gbGFyZ2UgdG8gY29udmVydCB0byBmbG9hdFwiKTt9ZWxzZSB0PXcudG9TdHJpbmcoKTtyPTB9ZWxzZSByZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7cmV0dXJuIGQodixxLHQscil9fWZ1bmN0aW9uIGcoZCxsLHIsdil7dmFyIHE9TWF0aC5hYnMocik7Y29uc3QgdD1NYXRoLmFicyh2KTtpZihxPj10KXtpZigwPT09cSl0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImNvbXBsZXggZGl2aXNpb24gYnkgemVyb1wiKTtxPXYvcjtyKz12KnE7dj0oZCtsKnEpL3I7ZD0obC1kKnEpL3J9ZWxzZSB0Pj1xPyhxPXIvdixyPXIqcSt2LFNrLmFzc2VydHMuYXNzZXJ0KDAhPT1cbnYpLHY9KGQqcStsKS9yLGQ9KGwqcS1kKS9yKTpkPXY9TmFOO3JldHVybiBuZXcgU2suYnVpbHRpbi5jb21wbGV4KHYsZCl9ZnVuY3Rpb24gayhkLGwscix2KXtpZigwPT09ciYmMD09PXYpe3Y9MTt2YXIgcT0wfWVsc2UgaWYoMD09PWQmJjA9PT1sKXtpZigwIT09dnx8MD5yKXRocm93IG5ldyBTay5idWlsdGluLlplcm9EaXZpc2lvbkVycm9yKFwiY29tcGxleCBkaXZpc2lvbiBieSB6ZXJvXCIpO3E9dj0wfWVsc2V7Y29uc3QgdD1NYXRoLmh5cG90KGQsbCk7cT1NYXRoLnBvdyh0LHIpO2Q9TWF0aC5hdGFuMihsLGQpO3IqPWQ7MCE9PXYmJihxLz1NYXRoLmV4cChkKnYpLHIrPXYqTWF0aC5sb2codCkpO3Y9cSpNYXRoLmNvcyhyKTtxKj1NYXRoLnNpbihyKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleCh2LHEpfWZ1bmN0aW9uIHAoZCxsLHIpe2xldCB2PTE7dmFyIHE9bmV3IFNrLmJ1aWx0aW4uY29tcGxleCgxLDApO2ZvcihkPW5ldyBTay5idWlsdGluLmNvbXBsZXgoZCxsKTswPFxudiYmcj49djspciZ2JiYocT1uZXcgU2suYnVpbHRpbi5jb21wbGV4KHEucmVhbCpkLnJlYWwtcS5pbWFnKmQuaW1hZyxxLnJlYWwqZC5pbWFnK2QucmVhbCpxLmltYWcpKSx2PDw9MSxkPW5ldyBTay5idWlsdGluLmNvbXBsZXgoZC5yZWFsKmQucmVhbC1kLmltYWcqZC5pbWFnLDIqZC5yZWFsKmQuaW1hZyk7cmV0dXJuIHF9ZnVuY3Rpb24gaChkLGwscix2LHEpe3E9ITE7c3dpdGNoKGwpe2Nhc2UgXCJlXCI6Y2FzZSBcImZcIjpjYXNlIFwiZ1wiOmJyZWFrO2Nhc2UgXCJFXCI6cT0hMDtsPVwiZVwiO2JyZWFrO2Nhc2UgXCJGXCI6cT0hMDtsPVwiZlwiO2JyZWFrO2Nhc2UgXCJyXCI6aWYoMCE9PXIpdGhyb3cgRXJyb3IoXCJCYWQgaW50ZXJuYWxsIGNhbGxcIik7cj0xNztsPVwiZ1wiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJCYWQgaW50ZXJuYWxsIGNhbGxcIik7fWlmKGlzTmFOKGQpKWQ9XCJuYW5cIjtlbHNlIGlmKEluZmluaXR5PT09ZClkPVwiaW5mXCI7ZWxzZSBpZigtSW5maW5pdHk9PT1kKWQ9XCItaW5mXCI7ZWxzZXt2JlxuaC5QeV9EVFNGX0FERF9ET1RfMCYmKGw9XCJnXCIpO3ZhciB0PVwiJVwiKyh2JmguUHlfRFRTRl9BTFQ/XCIjXCI6XCJcIik7bnVsbCE9ciYmKHQ9dCtcIi5cIityKTt0PW5ldyBTay5idWlsdGluLnN0cih0K2wpO2Q9dC5uYiRyZW1haW5kZXIobmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGQpKTtkPWQudn12JmguUHlfRFRTRl9TSUdOJiZcIi1cIiE9PWRbMF0mJihkPVwiK1wiK2QpO3EmJihkPWQudG9VcHBlckNhc2UoKSk7cmV0dXJuIGR9U2suYnVpbHRpbi5jb21wbGV4PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJjb21wbGV4XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGQsbCl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uY29tcGxleCxcImJhZCBjYWxsIHRvIGNvbXBsZXggY29uc3RydWN0b3IsIHVzZSAnbmV3J1wiKTt0aGlzLnJlYWw9ZDt0aGlzLmltYWc9bH0sc2xvdHM6e3RwJGFzX251bWJlcjohMCx0cCRkb2M6XCJDcmVhdGUgYSBjb21wbGV4IG51bWJlciBmcm9tIGEgcmVhbCBwYXJ0IGFuZCBhbiBvcHRpb25hbCBpbWFnaW5hcnkgcGFydC5cXG5cXG5UaGlzIGlzIGVxdWl2YWxlbnQgdG8gKHJlYWwgKyBpbWFnKjFqKSB3aGVyZSBpbWFnIGRlZmF1bHRzIHRvIDAuXCIsXG50cCRoYXNoKCl7dmFyIGQ9KG5ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLnJlYWwpKS50cCRoYXNoKCk7ZD0xMDAzKihuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy5pbWFnKSkudHAkaGFzaCgpK2Q7cmV0dXJuIFNrLmJ1aWx0aW4uaW50Xy53aXRoaW5UaHJlc2hvbGQoZCk/ZDoobmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLkJpZ0ludChkKSkpLnRwJGhhc2goKX0sdHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkbmV3KGQsbCl7ZD1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcImNvbXBsZXhcIixbXCJyZWFsXCIsXCJpbWFnXCJdLGQsbCxbbnVsbCxudWxsXSk7e3ZhciByPWRbMV0sdjtsZXQgdD1sPSExO3ZhciBxPWRbMF07aWYobnVsbCE9cSYmcS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uY29tcGxleCYmbnVsbD09cilsPXE7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKHEpKXtpZihudWxsIT1yKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBsZXgoKSBjYW4ndCB0YWtlIHNlY29uZCBhcmcgaWYgZmlyc3QgaXMgYSBzdHJpbmdcIik7XG5sPVNrLmJ1aWx0aW4uY29tcGxleC5jb21wbGV4X3N1YnR5cGVfZnJvbV9zdHJpbmcocSx0aGlzKX1lbHNle2lmKG51bGwhPXImJlNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcocikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGxleCgpIHNlY29uZCBhcmcgY2FuJ3QgYmUgYSBzdHJpbmdcIik7bnVsbD09cT9kPW51bGw6KGQ9U2suYWJzdHIubG9va3VwU3BlY2lhbChxLFNrLmJ1aWx0aW4uc3RyLiRjb21wbGV4KSxkPXZvaWQgMCE9PWQ/U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGQsW10pOm51bGwpO2lmKG51bGwhPWQmJmQhPT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCl7aWYoIWEoZCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19jb21wbGV4X18gc2hvdWxkIHJldHVybiBhIGNvbXBsZXggb2JqZWN0XCIpO3E9ZH1pZihudWxsIT1xJiZ2b2lkIDA9PT1xLm5iJGZsb2F0KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBsZXgoKSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyLCBub3QgJ1wiK1xuU2suYWJzdHIudHlwZU5hbWUocSkrXCInXCIpO2lmKG51bGwhPXImJnZvaWQgMD09PXIubmIkZmxvYXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGxleCgpIHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHEpK1wiJ1wiKTtudWxsPT1xP3E9ZD0wOmEocSk/KGQ9cS5yZWFsLHE9cS5pbWFnLGw9ITApOihkPWIocSkscT0wKTtudWxsPT1yP3I9dj0wOmEocik/KHY9ci5yZWFsLHI9ci5pbWFnLHQ9ITApOih2PWIocikscj0wKTshMD09PXQmJihkLT1yKTshMD09PWwmJih2Kz1xKTtsPWYoZCx2LHRoaXMpfX1yZXR1cm4gbH0sdHAkcmljaGNvbXBhcmUoZCxsKXtpZihcIkVxXCIhPT1sJiZcIk5vdEVxXCIhPT1sKXtpZihTay5idWlsdGluLmNoZWNrTnVtYmVyKGQpfHxhKGQpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm5vIG9yZGVyaW5nIHJlbGF0aW9uIGlzIGRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVyc1wiKTtcbnJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH1yZXR1cm4gZShmdW5jdGlvbihyLHYscSx0KXtyPXI9PXEmJnY9PXQ7cmV0dXJuXCJFcVwiPT09bD9yOiFyfSwhMCkuY2FsbCh0aGlzLGQpfSwkcigpe3t2YXIgZCxsO2xldCBxPWQ9XCJcIjt2YXIgcj10aGlzLnJlYWw7dmFyIHY9dGhpcy5pbWFnO2lmKGw9MD09PXIpbD0xPT0ocj8wPnI/LTE6MTowPjEvcj8tMToxKTtsPyhyPVwiXCIsbD1oKHYsXCJnXCIsbnVsbCwwLG51bGwpKToocj1kPWgocixcImdcIixudWxsLDAsbnVsbCksbD1oKHYsXCJnXCIsbnVsbCxoLlB5X0RUU0ZfU0lHTixudWxsKSwwPT09diYmLUluZmluaXR5PT09MS92JiZsJiZcIi1cIiE9PWxbMF0mJihsPVwiLVwiK2wpLGQ9XCIoXCIscT1cIilcIik7dj1uZXcgU2suYnVpbHRpbi5zdHIoXCJcIitkK3IrbCtcImpcIitxKX1yZXR1cm4gdn0sbmIkaW50KCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBjb21wbGV4IHRvIGludFwiKTt9LFxubmIkbG9uZygpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgY29tcGxleCB0byBsb25nXCIpO30sbmIkZmxvYXQoKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IGNvbXBsZXggdG8gZmxvYXRcIik7fSxuYiRwb3NpdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5jb21wbGV4KHRoaXMucmVhbCx0aGlzLmltYWcpfSxuYiRuZWdhdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5jb21wbGV4KC10aGlzLnJlYWwsLXRoaXMuaW1hZyl9LG5iJGJvb2woKXtyZXR1cm4gdGhpcy5yZWFsfHx0aGlzLmltYWd9LG5iJGFkZDplKChkLGwscix2KT0+bmV3IFNrLmJ1aWx0aW4uY29tcGxleChkK3IsbCt2KSksbmIkc3VidHJhY3Q6ZSgoZCxsLHIsdik9Pm5ldyBTay5idWlsdGluLmNvbXBsZXgoZC1yLGwtdikpLG5iJHJlZmxlY3RlZF9zdWJ0cmFjdDplKChkLGwscix2KT0+bmV3IFNrLmJ1aWx0aW4uY29tcGxleChyLWQsdi1cbmwpKSxuYiRtdWx0aXBseTplKChkLGwscix2KT0+bmV3IFNrLmJ1aWx0aW4uY29tcGxleChyKmQtdipsLGQqditsKnIpKSxuYiRkaXZpZGU6ZShnKSxuYiRyZWZsZWN0ZWRfZGl2aWRlOmUoKGQsbCxyLHYpPT5nKHIsdixkLGwpKSxuYiRmbG9vcl9kaXZpZGUoZCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgdGFrZSBmbG9vciBvZiBjb21wbGV4IG51bWJlci5cIik7fSxuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlKGQpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IHRha2UgZmxvb3Igb2YgY29tcGxleCBudW1iZXIuXCIpO30sbmIkcmVtYWluZGVyKGQpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG1vZCBjb21wbGV4IG51bWJlcnMuXCIpO30sbmIkcmVmbGVjdGVkX3JlbWFpbmRlcihkKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtb2QgY29tcGxleCBudW1iZXJzLlwiKTt9LG5iJGRpdm1vZChkKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCB0YWtlIGZsb29yIG9yIG1vZCBvZiBjb21wbGV4IG51bWJlci5cIik7XG59LG5iJHBvd2VyKGQsbCl7aWYobnVsbCE9bCYmIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGwpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb21wbGV4IG1vZHVsb1wiKTtyZXR1cm4gbi5jYWxsKHRoaXMsZCl9LG5iJGFicygpe3ZhciBkPXRoaXMucmVhbDtjb25zdCBsPXRoaXMuaW1hZztpZighTnVtYmVyLmlzRmluaXRlKGQpfHwhTnVtYmVyLmlzRmluaXRlKGwpKXJldHVybiBJbmZpbml0eT09PWR8fC1JbmZpbml0eT09PWQ/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguYWJzKGQpKTpJbmZpbml0eT09PWx8fC1JbmZpbml0eT09PWw/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguYWJzKGwpKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oTmFOKTtkPU1hdGguaHlwb3QoZCxsKTtpZighTnVtYmVyLmlzRmluaXRlKGQpKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3IoXCJhYnNvbHV0ZSB2YWx1ZSB0b28gbGFyZ2VcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhkKX19LFxuZ2V0c2V0czp7cmVhbDp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy5yZWFsKX0sJGRvYzpcInRoZSByZWFsIHBhcnQgb2YgYSBjb21wbGV4IG51bWJlclwifSxpbWFnOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLmltYWcpfSwkZG9jOlwidGhlIGltYWdpbmFyeSBwYXJ0IG9mIGEgY29tcGxleCBudW1iZXJcIn19LG1ldGhvZHM6e2Nvbmp1Z2F0ZTp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleCh0aGlzLnJlYWwsLXRoaXMuaW1hZyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJjb21wbGV4LmNvbmp1Z2F0ZSgpIC0+IGNvbXBsZXhcXG5cXG5SZXR1cm4gdGhlIGNvbXBsZXggY29uanVnYXRlIG9mIGl0cyBhcmd1bWVudC4gKDMtNGopLmNvbmp1Z2F0ZSgpID09IDMrNGouXCJ9LF9fZ2V0bmV3YXJnc19fOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHRoaXMucmVhbCksXG5uZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy5pbWFnKV0pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sX19mb3JtYXRfXzp7JG1ldGgoZCl7aWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhkKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiX19mb3JtYXRfXyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGNvbXBsZXggdHlwZS5cIik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19mb3JtYXRfXyByZXF1aXJlcyBzdHJcIik7fSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiY29tcGxleC5fX2Zvcm1hdF9fKCkgLT4gc3RyXFxuXFxuQ29udmVydCB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gZm9ybWF0X3NwZWMuXCJ9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY29tcGxleFwiLFNrLmJ1aWx0aW4uY29tcGxleCk7Y29uc3QgYT1Tay5idWlsdGluLmNoZWNrQ29tcGxleCxcbmM9L19bZUVdfFtlRV1ffFxcLl98X1xcLnxbKy1dX3xfanxqXy8sbT0vXyg/PVteX10pL2c7U2suYnVpbHRpbi5jb21wbGV4LmNvbXBsZXhfc3VidHlwZV9mcm9tX3N0cmluZz1mdW5jdGlvbihkLGwpe2w9bHx8U2suYnVpbHRpbi5jb21wbGV4LnByb3RvdHlwZTt2YXIgcj0wLHY9MCxxPSExO2lmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZCkpZD1Tay5mZmkucmVtYXBUb0pzKGQpO2Vsc2UgaWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBkKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm92aWRlZCB1bnN1cHBvcnRlZCBzdHJpbmctYWxpa2UgYXJndW1lbnRcIik7aWYoLTEhPT1kLmluZGV4T2YoXCJcXHgwMFwiKXx8MD09PWQubGVuZ3RofHxcIlwiPT09ZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY29tcGxleCgpIGFyZyBpcyBhIG1hbGZvcm1lZCBzdHJpbmdcIik7dmFyIHQ9MDtkPWQucmVwbGFjZSgvaW5mfGluZmluaXR5L2dpLFwiSW5maW5pdHlcIik7Zm9yKGQ9ZC5yZXBsYWNlKC9uYW4vZ2ksXCJOYU5cIik7XCIgXCI9PT1cbmRbdF07KXQrKztpZihcIihcIj09PWRbdF0pZm9yKHE9ITAsdCsrO1wiIFwiPT09ZFt0XTspdCsrO2lmKC0xIT09ZC5pbmRleE9mKFwiX1wiKSl7aWYoYy50ZXN0KGQpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb3VsZCBub3QgY29udmVydCBzdHJpbmcgdG8gY29tcGxleDogJ1wiK2QrXCInXCIpO2Q9ZC5jaGFyQXQoMCkrZC5zdWJzdHJpbmcoMSkucmVwbGFjZShtLFwiXCIpfXZhciB3PS9eKD86WystXT8oPzooPzooPzpcXGQqXFwuXFxkKyl8KD86XFxkK1xcLj8pKSg/OltlRV1bKy1dP1xcZCspP3xOYU58SW5maW5pdHkpKS87dmFyIEM9ZC5zdWJzdHIodCk7dmFyIEQ9Qy5tYXRjaCh3KTtpZihudWxsIT09RClpZih0Kz1EWzBdLmxlbmd0aCxcImpcIj09PWRbdF18fFwiSlwiPT09ZFt0XSl2PXBhcnNlRmxvYXQoRFswXSksdCsrO2Vsc2UgaWYoXCIrXCI9PT1kW3RdfHxcIi1cIj09PWRbdF0pe3I9cGFyc2VGbG9hdChEWzBdKTtEPWQuc3Vic3RyKHQpLm1hdGNoKHcpO251bGwhPT1EPyh2PXBhcnNlRmxvYXQoRFswXSksXG50Kz1EWzBdLmxlbmd0aCk6KHY9XCIrXCI9PT1kW3RdPzE6LTEsdCsrKTtpZihcImpcIiE9PWRbdF0mJlwiSlwiIT09ZFt0XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY29tcGxleCgpIGFyZyBpcyBtYWxmb3JtZWQgc3RyaW5nXCIpO3QrK31lbHNlIHI9cGFyc2VGbG9hdChEWzBdKTtlbHNlIEQ9RD1DLm1hdGNoKC9eKFsrLV0/W2pKXSkvKSxudWxsIT09RCYmKHY9MT09PURbMF0ubGVuZ3RoPzE6XCIrXCI9PT1EWzBdWzBdPzE6LTEsdCs9RFswXS5sZW5ndGgpO2Zvcig7XCIgXCI9PT1kW3RdOyl0Kys7aWYocSl7aWYoXCIpXCIhPT1kW3RdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb21wbGV4KCkgYXJnIGlzIG1hbGZvcm1lZCBzdHJpbmdcIik7Zm9yKHQrKztcIiBcIj09PWRbdF07KXQrK31pZihkLmxlbmd0aCE9PXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImNvbXBsZXgoKSBhcmcgaXMgbWFsZm9ybWVkIHN0cmluZ1wiKTtyZXR1cm4gZihyLHYsbCl9O2NvbnN0IG49XG5lKChkLGwscix2KT0+e2NvbnN0IHE9cnwwO3JldHVybiAwPT09diYmcj09PXE/KDEwMDxxfHwtMTAwPnE/ZD1rKGQsbCxxLDApOjA8cT9kPXAoZCxsLHEpOihkPXAoZCxsLC1xKSxkPWcoMSwwLGQucmVhbCxkLmltYWcpKSxkKTprKGQsbCxyLHYpfSk7aC5QeV9EVFNGX1NJR049MTtoLlB5X0RUU0ZfQUREX0RPVF8wPTI7aC5QeV9EVFNGX0FMVD00O2guUHlfRFRTVF9GSU5JVEU9MDtoLlB5X0RUU1RfSU5GSU5JVEU9MTtoLlB5X0RUU1RfTkFOPTJ9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi5zbGljZT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwic2xpY2VcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYixmLGUpe3ZvaWQgMD09PWYmJnZvaWQgMD09PWUmJihmPWIsYj1Tay5idWlsdGluLm5vbmUubm9uZSQpO3ZvaWQgMD09PWYmJihmPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7dm9pZCAwPT09ZSYmKGU9U2suYnVpbHRpbi5ub25lLm5vbmUkKTt0aGlzLnN0YXJ0PWI7dGhpcy5zdG9wPVxuZjt0aGlzLnN0ZXA9ZX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGRvYzpcInNsaWNlKHN0b3ApXFxuc2xpY2Uoc3RhcnQsIHN0b3BbLCBzdGVwXSlcXG5cXG5DcmVhdGUgYSBzbGljZSBvYmplY3QuICBUaGlzIGlzIHVzZWQgZm9yIGV4dGVuZGVkIHNsaWNpbmcgKGUuZy4gYVswOjEwOjJdKS5cIix0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRuZXcoYixmKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic2xpY2VcIixmKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJzbGljZVwiLGIsMSwzKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2xpY2UoLi4uYil9LCRyKCl7Y29uc3QgYj1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMuc3RhcnQpLGY9U2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLnN0b3ApLGU9U2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLnN0ZXApO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJzbGljZShcIitiK1wiLCBcIitmK1wiLCBcIitlK1wiKVwiKX0sXG50cCRyaWNoY29tcGFyZShiLGYpe2lmKGIub2IkdHlwZSE9PVNrLmJ1aWx0aW4uc2xpY2UpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IGU9bmV3IFNrLmJ1aWx0aW4udHVwbGUoW3RoaXMuc3RhcnQsdGhpcy5zdG9wLHRoaXMuc3RlcF0pO2I9bmV3IFNrLmJ1aWx0aW4udHVwbGUoW2Iuc3RhcnQsYi5zdG9wLGIuc3RlcF0pO3JldHVybiBlLnRwJHJpY2hjb21wYXJlKGIsZil9fSxnZXRzZXRzOntzdGFydDp7JGdldCgpe3JldHVybiB0aGlzLnN0YXJ0fX0sc3RlcDp7JGdldCgpe3JldHVybiB0aGlzLnN0ZXB9fSxzdG9wOnskZ2V0KCl7cmV0dXJuIHRoaXMuc3RvcH19fSxtZXRob2RzOntpbmRpY2VzOnskbWV0aDpmdW5jdGlvbihiKXtiPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChiLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoMD5iKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImxlbmd0aCBzaG91bGQgbm90IGJlIG5lZ2F0aXZlXCIpO1xuY29uc3Qge3N0YXJ0OmYsc3RvcDplLHN0ZXA6Z309dGhpcy5zbGljZSRpbmRpY2VzKGIpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50XyhmKSxuZXcgU2suYnVpbHRpbi5pbnRfKGUpLG5ldyBTay5idWlsdGluLmludF8oZyldKX0sJGRvYzpcIlMuaW5kaWNlcyhsZW4pIC0+IChzdGFydCwgc3RvcCwgc3RyaWRlKVxcblxcbkFzc3VtaW5nIGEgc2VxdWVuY2Ugb2YgbGVuZ3RoIGxlbiwgY2FsY3VsYXRlIHRoZSBzdGFydCBhbmQgc3RvcFxcbmluZGljZXMsIGFuZCB0aGUgc3RyaWRlIGxlbmd0aCBvZiB0aGUgZXh0ZW5kZWQgc2xpY2UgZGVzY3JpYmVkIGJ5XFxuUy4gT3V0IG9mIGJvdW5kcyBpbmRpY2VzIGFyZSBjbGlwcGVkIGluIGEgbWFubmVyIGNvbnNpc3RlbnQgd2l0aCB0aGVcXG5oYW5kbGluZyBvZiBub3JtYWwgc2xpY2VzLlwiLCR0ZXh0c2lnOm51bGwsJGZsYWdzOntPbmVBcmc6ITB9fX0scHJvdG86e3NsaWNlJGFzX2luZGljZXMoYil7bGV0IGY7dmFyIGU9XG5iP2c9PlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChnLG51bGwsXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgTm9uZSBvciBoYXZlIGFuIF9faW5kZXhfXyBtZXRob2RcIik6Zz0+U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coZyxcInNsaWNlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBOb25lIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKTtpZihTay5idWlsdGluLmNoZWNrTm9uZSh0aGlzLnN0ZXApKWY9MTtlbHNlIGlmKGY9ZSh0aGlzLnN0ZXApLDA9PT1mKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzbGljZSBzdGVwIGNhbm5vdCBiZSB6ZXJvXCIpO2I9U2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5zdGFydCk/bnVsbDplKHRoaXMuc3RhcnQpO2U9U2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5zdG9wKT9udWxsOmUodGhpcy5zdG9wKTtyZXR1cm57c3RhcnQ6YixzdG9wOmUsc3RlcDpmfX0sJHdydChiLGYsZSxnLGspe2s9az9wPT5KU0JJLl9faXNCaWdJbnQocCk/XG5KU0JJLmFkZChwLEpTQkkuQmlnSW50KGIpKTpwK2I6cD0+cCtiOzA8Zz8obnVsbD09PWY/Zj0wOjA+ZiYmKGY9ayhmKSwwPmYmJihmPTApKSxudWxsPT09ZT9lPWI6ZT5iP2U9YjowPmUmJihlPWsoZSkpKToobnVsbD09PWY/Zj1iLTE6Zj49Yj9mPWItMTowPmYmJihmPWsoZikpLG51bGw9PT1lP2U9LTE6MD5lJiYoZT1rKGUpLDA+ZSYmKGU9LTEpKSk7cmV0dXJue3N0YXJ0OmYsc3RvcDplLHN0ZXA6Z319LHNsaWNlJGluZGljZXMoYixmKXtsZXQge3N0YXJ0OmUsc3RvcDpnLHN0ZXA6a309dGhpcy5zbGljZSRhc19pbmRpY2VzKCEwLGYpO3JldHVybiB0aGlzLiR3cnQoYixlLGcsayxmKX0sc3NzaXRlciQoYixmKXtsZXQge3N0YXJ0OmUsc3RvcDpnLHN0ZXA6a309dGhpcy5zbGljZSRpbmRpY2VzKGIsITApO2lmKDA8aylmb3IoYj1lO2I8ZztiKz1rKWYoYik7ZWxzZSBmb3IoYj1lO2I+ZztiKz1rKWYoYil9fSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KTtTay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydD1cbmZ1bmN0aW9uKGIsZixlKXtiPWIuc3EkbGVuZ3RoKCk7dm9pZCAwPT09Znx8U2suYnVpbHRpbi5jaGVja05vbmUoZik/Zj0wOihmPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChmLG51bGwsXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpLDA+ZiYmKGYrPWIsMD5mJiYoZj0wKSkpO3ZvaWQgMD09PWV8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGUpP2U9YjooZT1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZSxudWxsLFwic2xpY2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKSwwPmU/KGUrPWIsMD5lJiYoZT0wKSk6ZT5iJiYoZT1iKSk7cmV0dXJue3N0YXJ0OmYsZW5kOmV9fX0sZnVuY3Rpb24oRSxRKXtmdW5jdGlvbiBiKGcpe3JldHVybiBmdW5jdGlvbihrKXtyZXR1cm4gU2suYnVpbHRpbi5jaGVja0FueVNldChrKT9nLmNhbGwodGhpcyxrKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19XG5mdW5jdGlvbiBmKGcpe2cgaW5zdGFuY2VvZiBTay5idWlsdGluLnNldCYmZy50cCRoYXNoPT09U2suYnVpbHRpbi5ub25lLm5vbmUkJiYoZz1uZXcgU2suYnVpbHRpbi5mcm96ZW5zZXQoU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZykpKTtyZXR1cm4gZ31FPXt9O1NrLmJ1aWx0aW4uc2V0PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJzZXRcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZyl7dm9pZCAwPT09Zz9nPVtdOkFycmF5LmlzQXJyYXkoZyl8fChnPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGcpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zZXQsXCJCYWQgY2FsbCB0byBzZXQgLSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIEFycmF5IGFuZCAnbmV3J1wiKTtjb25zdCBrPVtdO2ZvcihsZXQgcD0wO3A8Zy5sZW5ndGg7cCsrKWsucHVzaChnW3BdKSxrLnB1c2goITApO3RoaXMudj1uZXcgU2suYnVpbHRpbi5kaWN0KGspO3RoaXMuaW4kcmVwcj1cbiExfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfbnVtYmVyOiEwLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkaGFzaDpTay5idWlsdGluLm5vbmUubm9uZSQsdHAkZG9jOlwic2V0KCkgLT4gbmV3IGVtcHR5IHNldCBvYmplY3RcXG5zZXQoaXRlcmFibGUpIC0+IG5ldyBzZXQgb2JqZWN0XFxuXFxuQnVpbGQgYW4gdW5vcmRlcmVkIGNvbGxlY3Rpb24gb2YgdW5pcXVlIGVsZW1lbnRzLlwiLHRwJGluaXQoZyxrKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic2V0XCIsayk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwic2V0XCIsZywwLDEpO3RoaXMuc2V0JGNsZWFyKCk7cmV0dXJuKGc9Z1swXSkmJnRoaXMuc2V0JHVwZGF0ZShnKX0sdHAkbmV3OlNrLmdlbmVyaWMubmV3LCRyKCl7aWYodGhpcy5pbiRyZXByKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCIoLi4uKVwiKTt0aGlzLmluJHJlcHI9ITA7Y29uc3QgZz10aGlzLnNrJGFzYXJyYXkoKS5tYXAoaz0+XG5Tay5taXNjZXZhbC5vYmplY3RSZXByKGspKTt0aGlzLmluJHJlcHI9ITE7cmV0dXJuIFNrLl9fZnV0dXJlX18ucHl0aG9uMz8wPT09Zy5sZW5ndGg/bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKClcIik6dGhpcy5vYiR0eXBlIT09U2suYnVpbHRpbi5zZXQ/bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKHtcIitnLmpvaW4oXCIsIFwiKStcIn0pXCIpOm5ldyBTay5idWlsdGluLnN0cihcIntcIitnLmpvaW4oXCIsIFwiKStcIn1cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKFtcIitnLmpvaW4oXCIsIFwiKStcIl0pXCIpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBlKHRoaXMpfSx0cCRyaWNoY29tcGFyZShnLGspe2lmKCFTay5idWlsdGluLmNoZWNrQW55U2V0KGcpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtzd2l0Y2goayl7Y2FzZSBcIk5vdEVxXCI6Y2FzZSBcIkVxXCI6cmV0dXJuIGc9XG50aGlzPT09Zz8hMDp0aGlzLmdldCRzaXplKCkhPT1nLmdldCRzaXplKCk/ITE6U2subWlzY2V2YWwuaXNUcnVlKHRoaXMuc2V0JGlzc3Vic2V0KGcpKSxcIkVxXCI9PT1rP2c6IWc7Y2FzZSBcIkx0RVwiOnJldHVybiB0aGlzPT09Z3x8U2subWlzY2V2YWwuaXNUcnVlKHRoaXMuc2V0JGlzc3Vic2V0KGcpKTtjYXNlIFwiR3RFXCI6cmV0dXJuIHRoaXM9PT1nfHxTay5taXNjZXZhbC5pc1RydWUoZy5zZXQkaXNzdWJzZXQodGhpcykpO2Nhc2UgXCJMdFwiOnJldHVybiB0aGlzLmdldCRzaXplKCk8Zy5nZXQkc2l6ZSgpJiZTay5taXNjZXZhbC5pc1RydWUodGhpcy5zZXQkaXNzdWJzZXQoZykpO2Nhc2UgXCJHdFwiOnJldHVybiB0aGlzLmdldCRzaXplKCk+Zy5nZXQkc2l6ZSgpJiZTay5taXNjZXZhbC5pc1RydWUoZy5zZXQkaXNzdWJzZXQodGhpcykpfX0sbmIkc3VidHJhY3Q6YihmdW5jdGlvbihnKXtyZXR1cm4gdGhpcy5kaWZmZXJlbmNlLiRtZXRoLmNhbGwodGhpcyxnKX0pLG5iJGFuZDpiKGZ1bmN0aW9uKGcpe3JldHVybiB0aGlzLmludGVyc2VjdGlvbi4kbWV0aC5jYWxsKHRoaXMsXG5nKX0pLG5iJG9yOmIoZnVuY3Rpb24oZyl7cmV0dXJuIHRoaXMudW5pb24uJG1ldGguY2FsbCh0aGlzLGcpfSksbmIkeG9yOmIoZnVuY3Rpb24oZyl7cmV0dXJuIHRoaXMuc3ltbWV0cmljX2RpZmZlcmVuY2UuJG1ldGguY2FsbCh0aGlzLGcpfSksbmIkaW5wbGFjZV9zdWJ0cmFjdDpiKGZ1bmN0aW9uKGcpe2c9PT10aGlzJiYoZz1nLnNldCRjb3B5KCkpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLmRpZmZlcmVuY2VfdXBkYXRlLiRtZXRoLmNhbGwodGhpcyxnKSwoKT0+dGhpcyl9KSxuYiRpbnBsYWNlX2FuZDpiKGZ1bmN0aW9uKGcpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLmludGVyc2VjdGlvbl91cGRhdGUuJG1ldGguY2FsbCh0aGlzLGcpLCgpPT50aGlzKX0pLG5iJGlucGxhY2Vfb3I6YihmdW5jdGlvbihnKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy51cGRhdGUuJG1ldGguY2FsbCh0aGlzLGcpLCgpPT50aGlzKX0pLG5iJGlucGxhY2VfeG9yOmIoZnVuY3Rpb24oZyl7Zz09PVxudGhpcyYmKGc9Zy5zZXQkY29weSgpKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy5zeW1tZXRyaWNfZGlmZmVyZW5jZV91cGRhdGUuJG1ldGguY2FsbCh0aGlzLGcpLCgpPT50aGlzKX0pLHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLmdldCRzaXplKCl9LHNxJGNvbnRhaW5zKGcpe2c9ZihnKTtyZXR1cm4gdGhpcy52LnNxJGNvbnRhaW5zKGcpfX0sbWV0aG9kczp7YWRkOnskbWV0aChnKXt0aGlzLnNldCRhZGQoZyk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkFkZCBhbiBlbGVtZW50IHRvIGEgc2V0LlxcblxcblRoaXMgaGFzIG5vIGVmZmVjdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHByZXNlbnQuXCJ9LGNsZWFyOnskbWV0aCgpe3RoaXMuc2V0JGNsZWFyKCk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGlzIHNldC5cIn0sXG5jb3B5OnskbWV0aCgpe3JldHVybiB0aGlzLnNldCRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gYSBzaGFsbG93IGNvcHkgb2YgYSBzZXQuXCJ9LGRpc2NhcmQ6eyRtZXRoKGcpe2c9ZihnKTt0aGlzLnNldCRkaXNjYXJkKGcpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgc2V0IGlmIGl0IGlzIGEgbWVtYmVyLlxcblxcbklmIHRoZSBlbGVtZW50IGlzIG5vdCBhIG1lbWJlciwgZG8gbm90aGluZy5cIn0sZGlmZmVyZW5jZTp7JG1ldGgoLi4uZyl7Y29uc3Qgaz10aGlzLnNldCRjb3B5KCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheShnLHA9Pmsuc2V0JGRpZmZlcmVuY2VfdXBkYXRlKHApKSwoKT0+ayl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gdGhlIGRpZmZlcmVuY2Ugb2YgdHdvIG9yIG1vcmUgc2V0cyBhcyBhIG5ldyBzZXQuXFxuXFxuKGkuZS4gYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGluIHRoaXMgc2V0IGJ1dCBub3QgdGhlIG90aGVycy4pXCJ9LFxuZGlmZmVyZW5jZV91cGRhdGU6eyRtZXRoKC4uLmcpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyQXJyYXkoZyxrPT50aGlzLnNldCRkaWZmZXJlbmNlX3VwZGF0ZShrKSksKCk9PlNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZW1vdmUgYWxsIGVsZW1lbnRzIG9mIGFub3RoZXIgc2V0IGZyb20gdGhpcyBzZXQuXCJ9LGludGVyc2VjdGlvbjp7JG1ldGgoLi4uZyl7cmV0dXJuIHRoaXMuc2V0JGludGVyc2VjdGlvbl9tdWx0aSguLi5nKX0sJGZsYWdzOntNaW5BcmdzOjB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBzZXRzIGFzIGEgbmV3IHNldC5cXG5cXG4oaS5lLiBhbGwgZWxlbWVudHMgdGhhdCBhcmUgaW4gYm90aCBzZXRzLilcIn0saW50ZXJzZWN0aW9uX3VwZGF0ZTp7JG1ldGgoLi4uZyl7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHRoaXMuc2V0JGludGVyc2VjdGlvbl9tdWx0aSguLi5nKSxcbms9Pnt0aGlzLnN3YXAkYm9kaWVzKGspO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KX0sJGZsYWdzOntNaW5BcmdzOjB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlVwZGF0ZSBhIHNldCB3aXRoIHRoZSBpbnRlcnNlY3Rpb24gb2YgaXRzZWxmIGFuZCBhbm90aGVyLlwifSxpc2Rpc2pvaW50OnskbWV0aChnKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGcpLGs9PntpZih0aGlzLnNxJGNvbnRhaW5zKGspKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoU2suYnVpbHRpbi5ib29sLmZhbHNlJCl9KSxrPT5rfHxTay5idWlsdGluLmJvb2wudHJ1ZSQpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdHdvIHNldHMgaGF2ZSBhIG51bGwgaW50ZXJzZWN0aW9uLlwifSxpc3N1YnNldDp7JG1ldGgoZyl7U2suYnVpbHRpbi5jaGVja0FueVNldChnKXx8KGc9dGhpcy5zZXQkbWFrZV9iYXNldHlwZShnKSk7XG5yZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZyxrPT50aGlzLnNldCRpc3N1YnNldChrKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXBvcnQgd2hldGhlciBhbm90aGVyIHNldCBjb250YWlucyB0aGlzIHNldC5cIn0saXNzdXBlcnNldDp7JG1ldGgoZyl7U2suYnVpbHRpbi5jaGVja0FueVNldChnKXx8KGc9dGhpcy5zZXQkbWFrZV9iYXNldHlwZShnKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGcsaz0+ay5zZXQkaXNzdWJzZXQodGhpcykpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmVwb3J0IHdoZXRoZXIgdGhpcyBzZXQgY29udGFpbnMgYW5vdGhlciBzZXQuXCJ9LHBvcDp7JG1ldGgoKXtpZigwPT09dGhpcy5nZXQkc2l6ZSgpKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKFwicG9wIGZyb20gYW4gZW1wdHkgc2V0XCIpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy52LnBvcGl0ZW0sW3RoaXMudl0pLnZbMF19LFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlbW92ZSBhbmQgcmV0dXJuIGFuIGFyYml0cmFyeSBzZXQgZWxlbWVudC5cXG5SYWlzZXMgS2V5RXJyb3IgaWYgdGhlIHNldCBpcyBlbXB0eS5cIn0scmVtb3ZlOnskbWV0aChnKXtjb25zdCBrPWYoZyk7aWYodGhpcy52Lm1wJGxvb2t1cChrKSlyZXR1cm4gdGhpcy52Lm1wJGFzc19zdWJzY3JpcHQoayksU2suYnVpbHRpbi5ub25lLm5vbmUkO3Rocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKGcpO30sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlbW92ZSBhbiBlbGVtZW50IGZyb20gYSBzZXQ7IGl0IG11c3QgYmUgYSBtZW1iZXIuXFxuXFxuSWYgdGhlIGVsZW1lbnQgaXMgbm90IGEgbWVtYmVyLCByYWlzZSBhIEtleUVycm9yLlwifSxzeW1tZXRyaWNfZGlmZmVyZW5jZTp7JG1ldGgoZyl7bGV0IGs7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHRoaXMuc2V0JG1ha2VfYmFzZXR5cGUoZykscD0+XG57az1wO3JldHVybiBrLnNldCRzeW1tZXRyaWNfZGlmZl91cGRhdGUodGhpcyl9LCgpPT5rKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiB0aGUgc3ltbWV0cmljIGRpZmZlcmVuY2Ugb2YgdHdvIHNldHMgYXMgYSBuZXcgc2V0LlxcblxcbihpLmUuIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBpbiBleGFjdGx5IG9uZSBvZiB0aGUgc2V0cy4pXCJ9LHN5bW1ldHJpY19kaWZmZXJlbmNlX3VwZGF0ZTp7JG1ldGgoZyl7U2suYnVpbHRpbi5jaGVja0FueVNldChnKXx8KGc9dGhpcy5zZXQkbWFrZV9iYXNldHlwZShnKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGcsaz0+dGhpcy5zZXQkc3ltbWV0cmljX2RpZmZfdXBkYXRlKGspLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiVXBkYXRlIGEgc2V0IHdpdGggdGhlIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIGl0c2VsZiBhbmQgYW5vdGhlci5cIn0sXG51bmlvbjp7JG1ldGgoLi4uZyl7Y29uc3Qgaz10aGlzLnNldCRjb3B5KCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheShnLHA9Pmsuc2V0JHVwZGF0ZShwKSksKCk9PmspfSwkZmxhZ3M6e01pbkFyZ3M6MH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIHRoZSB1bmlvbiBvZiBzZXRzIGFzIGEgbmV3IHNldC5cXG5cXG4oaS5lLiBhbGwgZWxlbWVudHMgdGhhdCBhcmUgaW4gZWl0aGVyIHNldC4pXCJ9LHVwZGF0ZTp7JG1ldGgoLi4uZyl7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheShnLGs9PnRoaXMuc2V0JHVwZGF0ZShrKSksKCk9PlNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJVcGRhdGUgYSBzZXQgd2l0aCB0aGUgdW5pb24gb2YgaXRzZWxmIGFuZCBvdGhlcnMuXCJ9fSxjbGFzc21ldGhvZHM6U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW0scHJvdG86T2JqZWN0LmFzc2lnbihFLFxue3NrJGFzYXJyYXkoKXtyZXR1cm4gdGhpcy52LnNrJGFzYXJyYXkoKX0sZ2V0JHNpemUoKXtyZXR1cm4gdGhpcy52LnNxJGxlbmd0aCgpfSxzZXQkYWRkKGcpe3RoaXMudi5tcCRhc3Nfc3Vic2NyaXB0KGcsITApfSxzZXQkbWFrZV9iYXNldHlwZShnKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZywhMCksaz0+bmV3IHRoaXMuc2skYnVpbHRpbkJhc2UoaykpfSxzZXQkZGlzY2FyZChnKXtyZXR1cm4gdGhpcy52LnBvcCRpdGVtKGcpfSxzZXQkY2xlYXIoKXt0aGlzLnY9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSl9LHNldCRjb3B5KCl7Y29uc3QgZz1uZXcgdGhpcy5zayRidWlsdGluQmFzZTtnLnY9dGhpcy52LmRpY3QkY29weSgpO3JldHVybiBnfSxzZXQkZGlmZmVyZW5jZV91cGRhdGUoZyl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihnKSxrPT57dGhpcy5zZXQkZGlzY2FyZChrKX0pfSxzZXQkaW50ZXJzZWN0aW9uKGcpe2NvbnN0IGs9XG5uZXcgdGhpcy5zayRidWlsdGluQmFzZTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGcpLHA9Pnt0aGlzLnNxJGNvbnRhaW5zKHApJiZrLnNldCRhZGQocCl9KSwoKT0+ayl9LHNldCRpbnRlcnNlY3Rpb25fbXVsdGkoLi4uZyl7aWYoIWcubGVuZ3RoKXJldHVybiB0aGlzLnNldCRjb3B5KCk7bGV0IGs9dGhpcztyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckFycmF5KGcscD0+U2subWlzY2V2YWwuY2hhaW4oay5zZXQkaW50ZXJzZWN0aW9uKHApLGg9PntrPWh9KSksKCk9PmspfSxzZXQkaXNzdWJzZXQoZyl7Y29uc3Qgaz10aGlzLmdldCRzaXplKCkscD1nLmdldCRzaXplKCk7aWYoaz5wKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO2ZvcihsZXQgaD10aGlzLnRwJGl0ZXIoKSxhPWgudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1hO2E9aC50cCRpdGVybmV4dCgpKWlmKCFnLnNxJGNvbnRhaW5zKGEpKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO1xucmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJH0sc2V0JHN5bW1ldHJpY19kaWZmX3VwZGF0ZShnKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGcpLGs9Pnt2b2lkIDA9PT10aGlzLnNldCRkaXNjYXJkKGspJiZ0aGlzLnNldCRhZGQoayl9KX0sc2V0JHVwZGF0ZShnKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGcpLGs9Pnt0aGlzLnNldCRhZGQoayl9KX0sc3dhcCRib2RpZXMoZyl7dGhpcy52PWcudn19KX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uc2V0XCIsU2suYnVpbHRpbi5zZXQpO1E9U2suYnVpbHRpbi5zZXQucHJvdG90eXBlO1NrLmJ1aWx0aW4uZnJvemVuc2V0PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJmcm96ZW5zZXRcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZyl7dm9pZCAwPT09Zz9nPVtdOkFycmF5LmlzQXJyYXkoZyl8fChnPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGcpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uZnJvemVuc2V0LFwiYmFkIGNhbGwgdG8gZnJvemVuIHNldCAtIG11c3QgYmUgY2FsbGVkIHdpdGggJ25ldydcIik7Y29uc3Qgaz1bXTtmb3IobGV0IHA9MDtwPGcubGVuZ3RoO3ArKylrLnB1c2goZ1twXSksay5wdXNoKCEwKTt0aGlzLnY9bmV3IFNrLmJ1aWx0aW4uZGljdChrKTt0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19udW1iZXI6ITAsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRkb2M6XCJmcm96ZW5zZXQoKSAtPiBlbXB0eSBmcm96ZW5zZXQgb2JqZWN0XFxuZnJvemVuc2V0KGl0ZXJhYmxlKSAtPiBmcm96ZW5zZXQgb2JqZWN0XFxuXFxuQnVpbGQgYW4gaW1tdXRhYmxlIHVub3JkZXJlZCBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBlbGVtZW50cy5cIix0cCRoYXNoKCl7bGV0IGc9MTkyNzg2ODIzNztjb25zdCBrPXRoaXMuc2skYXNhcnJheSgpO2cqPWsubGVuZ3RoKzE7Zm9yKGxldCBwPTA7cDxrLmxlbmd0aDtwKyspe2NvbnN0IGg9XG5Tay5hYnN0ci5vYmplY3RIYXNoKGtbcF0pO2dePTM2NDQ3OTgxNjcqKGheaDw8MTZeODk4Njk3NDcpfXJldHVybiA2OTA2OSpnKzkwNzEzMzkyM30sdHAkbmV3KGcsayl7aWYodGhpcyE9PVNrLmJ1aWx0aW4uZnJvemVuc2V0LnByb3RvdHlwZSlyZXR1cm4gdGhpcy4kc3VidHlwZV9uZXcoZyxrKTtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwiZnJvemVuc2V0XCIsayk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwiZnJvemVuc2V0XCIsZywwLDEpO2c9Z1swXTtyZXR1cm4gdm9pZCAwIT09ZyYmZy5vYiR0eXBlPT09U2suYnVpbHRpbi5mcm96ZW5zZXQ/ZzpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShnLCEwKSxwPT5wLmxlbmd0aD9uZXcgU2suYnVpbHRpbi5mcm96ZW5zZXQocCk6U2suYnVpbHRpbi5mcm96ZW5zZXQuJGVtcHR5c2V0KX0sJHI6US4kcix0cCRpdGVyOlEudHAkaXRlcix0cCRyaWNoY29tcGFyZTpRLnRwJHJpY2hjb21wYXJlLG5iJHN1YnRyYWN0OlEubmIkc3VidHJhY3QsXG5uYiRhbmQ6US5uYiRhbmQsbmIkb3I6US5uYiRvcixuYiR4b3I6US5uYiR4b3Isc3EkbGVuZ3RoOlEuc3EkbGVuZ3RoLHNxJGNvbnRhaW5zOlEuc3EkY29udGFpbnN9LG1ldGhvZHM6e2NvcHk6T2JqZWN0LmFzc2lnbih7fSxRLmNvcHkuZCRkZWYseyRtZXRoKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3I9PT10aGlzLnNrJGJ1aWx0aW5CYXNlP3RoaXM6bmV3IFNrLmJ1aWx0aW4uZnJvemVuc2V0KHRoaXMuc2skYXNhcnJheSgpKX19KSxkaWZmZXJlbmNlOlEuZGlmZmVyZW5jZS5kJGRlZixpbnRlcnNlY3Rpb246US5pbnRlcnNlY3Rpb24uZCRkZWYsaXNkaXNqb2ludDpRLmlzZGlzam9pbnQuZCRkZWYsaXNzdWJzZXQ6US5pc3N1YnNldC5kJGRlZixpc3N1cGVyc2V0OlEuaXNzdXBlcnNldC5kJGRlZixzeW1tZXRyaWNfZGlmZmVyZW5jZTpRLnN5bW1ldHJpY19kaWZmZXJlbmNlLmQkZGVmLHVuaW9uOlEudW5pb24uZCRkZWZ9LGNsYXNzbWV0aG9kczpTay5nZW5lcmljLmNsYXNzR2V0SXRlbSxcbnByb3RvOk9iamVjdC5hc3NpZ24oeyRzdWJ0eXBlX25ldyhnLGspe2NvbnN0IHA9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmJ1aWx0aW4uZnJvemVuc2V0LnByb3RvdHlwZS50cCRuZXcoZyksaD0+e3Audj1oLnY7cmV0dXJuIHB9KX19LEUpfSk7U2suYnVpbHRpbi5mcm96ZW5zZXQuJGVtcHR5c2V0PW5ldyBTay5idWlsdGluLmZyb3plbnNldChbXSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5mcm96ZW5zZXRcIixTay5idWlsdGluLmZyb3plbnNldCk7dmFyIGU9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwic2V0X2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGcpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWcuc2skYXNhcnJheSgpO3RoaXMuJG9yaWc9Z30saXRlcm5leHQ6U2suZ2VuZXJpYy5pdGVyTmV4dFdpdGhBcnJheUNoZWNrU2l6ZSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sXG5mbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLnByaW50PWZ1bmN0aW9uKGIsZil7bGV0IFtlLGcsa109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJwcmludFwiLFtcInNlcFwiLFwiZW5kXCIsXCJmaWxlXCIsXCJmbHVzaFwiXSxbXSxmKTtpZih2b2lkIDA9PT1lfHxTay5idWlsdGluLmNoZWNrTm9uZShlKSllPVwiIFwiO2Vsc2UgaWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhlKSllPWUuJGpzc3RyKCk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZXAgbXVzdCBiZSBOb25lIG9yIGEgc3RyaW5nLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZSkpO2lmKHZvaWQgMD09PWd8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGcpKWc9XCJcXG5cIjtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZykpZz1nLiRqc3N0cigpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZW5kIG11c3QgYmUgTm9uZSBvciBhIHN0cmluZywgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUoZykpO2xldCBwO2lmKHZvaWQgMCE9PWsmJiFTay5idWlsdGluLmNoZWNrTm9uZShrKSYmKHA9U2suYWJzdHIubG9va3VwU3BlY2lhbChrLFNrLmJ1aWx0aW4uc3RyLiR3cml0ZSksdm9pZCAwPT09cCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoaykrXCInIG9iamVjdCBoYXMgbm8gYXR0cmlidXRlICd3cml0ZSdcIik7Y29uc3QgaD1uZXcgU2suYnVpbHRpbi5zdHIoYi5tYXAoYT0+KG5ldyBTay5idWlsdGluLnN0cihhKSkudG9TdHJpbmcoKSkuam9pbihlKStnKTtpZih2b2lkIDAhPT1wKVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShwLFtoXSk7ZWxzZSByZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFwic3lzXCIsITEsITApLGE9PihwPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYS4kZC5zdGRvdXQsU2suYnVpbHRpbi5zdHIuJHdyaXRlKSkmJlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShwLFxuW2hdKSl9O1NrLmJ1aWx0aW4ucHJpbnQuY29fZmFzdGNhbGw9MX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLm1vZHVsZT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwibW9kdWxlXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7dGhpcy4kZD17fX0sc2xvdHM6e3RwJGRvYzpcIkNyZWF0ZSBhIG1vZHVsZSBvYmplY3QuXFxuXFxuVGhlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzsgdGhlIG9wdGlvbmFsIGRvYyBhcmd1bWVudCBjYW4gaGF2ZSBhbnkgdHlwZS5cIix0cCRnZXRhdHRyKGIsZil7dmFyIGU9dGhpcy4kZFtiLiRtYW5nbGVkXTtpZih2b2lkIDAhPT1lKXJldHVybiBlO2U9dGhpcy5vYiR0eXBlLiR0eXBlTG9va3VwKGIpO2lmKHZvaWQgMCE9PWUpe2NvbnN0IGs9ZS50cCRkZXNjcl9nZXQ7cmV0dXJuIGs/ay5jYWxsKGUsdGhpcyx0aGlzLm9iJHR5cGUsZik6ZX1jb25zdCBnPXRoaXMuJGQuX19nZXRhdHRyX187aWYodm9pZCAwIT09ZylyZXR1cm4gZT1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+XG5Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZyxbYl0pLGs9PntpZighKGsgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBrO30pLGY/ZTpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coZSl9LHRwJHNldGF0dHI6U2suZ2VuZXJpYy5zZXRBdHRyLHRwJG5ldzpTay5nZW5lcmljLm5ldyx0cCRpbml0KGIsZil7Y29uc3QgW2UsZ109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJtb2R1bGVcIixbXCJuYW1lXCIsXCJkb2NcIl0sYixmLFtTay5idWlsdGluLm5vbmUubm9uZSRdKTtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwibW9kdWxlXCIsXCJzdHJpbmdcIixlKTt0aGlzLmluaXQkZGljdChlLGcpfSwkcigpe2xldCBiPXRoaXMuZ2V0JG5hbWUoKTtpZih2b2lkIDAhPT1iKXt2YXIgZj10aGlzLmdldCRtb2RfcmVwcmYoKTtpZih2b2lkIDAhPT1mKXJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZixcblt0aGlzXSl9Yj12b2lkIDA9PT1iP1wiJz8nXCI6YjtmPXRoaXMuZnJvbSRmaWxlKCk7Zj12b2lkIDA9PT1mP3RoaXMuZW1wdHlfb3IkbG9hZGVyKCk6ZjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPG1vZHVsZSBcIitiK2YrXCI+XCIpfX0sZ2V0c2V0czp7X19kaWN0X186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5KHRoaXMuJGQpfX19LG1ldGhvZHM6e19fZGlyX186eyRtZXRoKCl7Y29uc3QgYj10aGlzLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGRpY3QpO2lmKCFTay5idWlsdGluLmNoZWNrTWFwcGluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2RpY3RfXyBpcyBub3QgYSBkaWN0aW9uYXJ5XCIpO2NvbnN0IGY9Yi5tcCRsb29rdXAoU2suYnVpbHRpbi5zdHIuJGRpcik7cmV0dXJuIHZvaWQgMCE9PWY/U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGYsW10pOm5ldyBTay5idWlsdGluLmxpc3QoU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoYikpfSxcbiRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiX19kaXJfXygpIC0+IGxpc3RcXG5zcGVjaWFsaXplZCBkaXIoKSBpbXBsZW1lbnRhdGlvblwifX0scHJvdG86e3NrJGhhc0RpY3Q6ITAsaW5pdCRkaWN0KGIsZil7dGhpcy4kZC5fX25hbWVfXz1iO3RoaXMuJGQuX19kb2NfXz1mO3RoaXMuJGQuX19wYWNrYWdlX189U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMuJGQuX19zcGVjX189U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMuJGQuX19sb2FkZXJfXz1Tay5idWlsdGluLm5vbmUubm9uZSR9LHNrJGF0dHJFcnJvcigpe2xldCBiPXRoaXMuZ2V0JG5hbWUoKTtiPXZvaWQgMD09PWI/XCJtb2R1bGVcIjpcIm1vZHVsZSBcIitiO3RoaXMuJGluaXRpYWxpemluZyYmKGI9XCIobW9zdCBsaWtlbHkgZHVlIHRvIGEgY2lyY3VsYXIgaW1wb3J0KSBwYXJ0aWFsbHkgaW5pdGlhbGl6ZWQgXCIrYik7cmV0dXJuIGJ9LGdldCRuYW1lKCl7Y29uc3QgYj10aGlzLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJG5hbWUpO1xucmV0dXJuIGImJlNrLm1pc2NldmFsLm9iamVjdFJlcHIoYil9LGZyb20kZmlsZSgpe2NvbnN0IGI9dGhpcy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRmaWxlKTtyZXR1cm4gYiYmXCIgZnJvbSBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKGIpfSxlbXB0eV9vciRsb2FkZXIoKXtpZih0aGlzLiRqcyYmdGhpcy4kanMuaW5jbHVkZXMoXCIkYnVpbHRpbm1vZHVsZVwiKSlyZXR1cm5cIiAoYnVpbHQtaW4pXCI7Y29uc3QgYj10aGlzLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGxvYWRlcik7cmV0dXJuIHZvaWQgMD09PWJ8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGIpP1wiXCI6XCIgKFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIoYikrXCIpXCJ9LGdldCRtb2RfcmVwcmYoKXtjb25zdCBiPXRoaXMudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kbG9hZGVyKTtyZXR1cm4gYiYmYi50cCRnZXRhdHRyKHRoaXMuc3RyJG1vZF9yZXByKX0sc3RyJG1vZF9yZXByOm5ldyBTay5idWlsdGluLnN0cihcIm1vZHVsZV9yZXByXCIpfX0pO1xuU2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5tb2R1bGVcIixTay5idWlsdGluLm1vZHVsZSl9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi5zdHJ1Y3RzZXFfdHlwZXM9e307U2suYnVpbHRpbi5tYWtlX3N0cnVjdHNlcT1mdW5jdGlvbihiLGYsZSxnLGspe2c9dm9pZCAwPT09Zz97fTpnO2s9dm9pZCAwPT09az9udWxsOms7Y29uc3QgcD1iK1wiLlwiK2YsaD1bXSxhPXt9O09iamVjdC5rZXlzKGUpLmZvckVhY2goKGQsbCk9PntoLnB1c2goZCk7YVtkXT17JGdldCgpe3JldHVybiB0aGlzLnZbbF19LCRkb2M6ZVtkXX19KTtjb25zdCBjPWgubGVuZ3RoO2xldCBtPWM7T2JqZWN0LmtleXMoZykuZm9yRWFjaCgoZCxsKT0+e2FbZF09eyRnZXQoKXtyZXR1cm4gdGhpcy4kaGlkZGVuW2xdfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRkb2M6Z1tkXX07bSsrfSk7dmFyIG49U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhwLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihkLGwpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZlxubik7U2suYnVpbHRpbi50dXBsZS5jYWxsKHRoaXMsZCk7dGhpcy4kaGlkZGVuPWx8fFtdfSxiYXNlOlNrLmJ1aWx0aW4udHVwbGUsc2xvdHM6e3RwJG5ldyhkLGwpe1NrLmFic3RyLmNoZWNrT25lQXJnKHAsZCxsKTtkPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGRbMF0pO2lmKGQubGVuZ3RoPGMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHArXCIoKSB0YWtlcyBhbiBhdCBsZWFzdCBcIitjK1wiLXNlcXVlbmNlIChcIitkLmxlbmd0aCtcIi1zZXF1ZW5jZSBnaXZlbilcIik7aWYoZC5sZW5ndGg+bSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IocCtcIigpIHRha2VzIGFuIGF0IG1vc3QgXCIrbStcIi1zZXF1ZW5jZSAoXCIrZC5sZW5ndGgrXCItc2VxdWVuY2UgZ2l2ZW4pXCIpO3JldHVybiBuZXcgbihkLnNsaWNlKDAsYyksZC5zbGljZShjKSl9LHRwJGRvYzprP2s6U2suYnVpbHRpbi5ub25lLm5vbmUkLCRyKCl7dmFyIGQ7aWYoMD09PXRoaXMudi5sZW5ndGgpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihwK1xuXCIoKVwiKTt2YXIgbD1bXTtmb3IoZD0wO2Q8aC5sZW5ndGg7KytkKWxbZF09aFtkXStcIj1cIitTay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMudltkXSk7ZD1sLmpvaW4oXCIsIFwiKTsxPT09dGhpcy52Lmxlbmd0aCYmKGQrPVwiLFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHArXCIoXCIrZCtcIilcIil9fSxtZXRob2RzOntfX3JlZHVjZV9fOnskbWV0aCgpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJfX3JlZHVjZV9fIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTt9LCRmbGFnczp7Tm9BcmdzOiEwfX19LGdldHNldHM6YSxwcm90bzp7bnVtX3NlcXVlbmNlX2ZpZWxkczpuZXcgU2suYnVpbHRpbi5pbnRfKGMpfX0pO3JldHVybiBufTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLm1ha2Vfc3RydWN0c2VxXCIsU2suYnVpbHRpbi5tYWtlX3N0cnVjdHNlcSl9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi5nZW5lcmF0b3I9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiZ2VuZXJhdG9yXCIsXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oYixmLGUsZyxrKXt2YXIgcDtpZihiKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmdlbmVyYXRvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcImJhZCBpbnRlcm5hbCBjYWxsIHRvIGdlbmVyYXRvciwgdXNlICduZXcnXCIpO3RoaXMuZnVuY19jb2RlPWI7dGhpcy5mdW5jX2dsb2JhbHM9Znx8bnVsbDt0aGlzLmdpJHJ1bm5pbmc9ITE7dGhpcy5naSRyZXN1bWVhdD0wO3RoaXMuZ2kkc2VudHZhbHVlPVNrLmJ1aWx0aW4ubm9uZS5ub25lJDt0aGlzLmdpJGxvY2Fscz17fTt0aGlzLmdpJGNlbGxzPXt9O2lmKDA8ZS5sZW5ndGgpZm9yKGY9MDtmPGIuY29fdmFybmFtZXMubGVuZ3RoOysrZil0aGlzLmdpJGxvY2Fsc1tiLmNvX3Zhcm5hbWVzW2ZdXT1lW2ZdO2lmKHZvaWQgMCE9PWspZm9yKHAgaW4gaylnW3BdPWtbcF07dGhpcy5mdW5jX2Nsb3N1cmU9Z319LHNsb3RzOnskcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8Z2VuZXJhdG9yIG9iamVjdCBcIitcbnRoaXMuZnVuY19jb2RlLmNvX25hbWUuditcIj5cIil9fSxpdGVybmV4dChiLGYpe3ZhciBlPXRoaXM7aWYodGhpcy5naSRydW5uaW5nKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJnZW5lcmF0b3IgYWxyZWFkeSBleGVjdXRpbmdcIik7dGhpcy5naSRydW5uaW5nPSEwO3ZvaWQgMD09PWYmJihmPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7dGhpcy5naSRzZW50dmFsdWU9ZjtmPVt0aGlzXTt0aGlzLmZ1bmNfY2xvc3VyZSYmZi5wdXNoKHRoaXMuZnVuY19jbG9zdXJlKTtyZXR1cm4gZnVuY3Rpb24gcChrKXtpZihrIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbil7aWYoYilyZXR1cm4gbmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb24ocCxrKTtrPVNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhrKX1lLmdpJHJ1bm5pbmc9ITE7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09ayk7aWYoQXJyYXkuaXNBcnJheShrKSlyZXR1cm4gZS5naSRyZXN1bWVhdD1cbmtbMF0saz1rWzFdO2UuZ2kkcmV0PWt9KHRoaXMuZnVuY19jb2RlLmFwcGx5KHRoaXMuZnVuY19nbG9iYWxzLGYpKX0sbWV0aG9kczp7c2VuZDp7JG1ldGgoYil7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHRoaXMudHAkaXRlcm5leHQoITAsYiksZj0+e2lmKHZvaWQgMD09PWYpdGhyb3cgZj10aGlzLmdpJHJldCx2b2lkIDAhPT1mJiZmIT09U2suYnVpbHRpbi5ub25lLm5vbmUkP25ldyBTay5idWlsdGluLlN0b3BJdGVyYXRpb24oZik6bmV3IFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbjtyZXR1cm4gZn0pfSwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcInNlbmQoYXJnKSAtPiBzZW5kICdhcmcnIGludG8gZ2VuZXJhdG9yLFxcbnJldHVybiBuZXh0IHlpZWxkZWQgdmFsdWUgb3IgcmFpc2UgU3RvcEl0ZXJhdGlvbi5cIn19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5nZW5lcmF0b3JcIixTay5idWlsdGluLmdlbmVyYXRvcik7U2suYnVpbHRpbi5tYWtlR2VuZXJhdG9yPWZ1bmN0aW9uKGIsXG5mKXt2YXIgZSxnPW5ldyBTay5idWlsdGluLmdlbmVyYXRvcihudWxsLG51bGwsbnVsbCk7Zy50cCRpdGVybmV4dD1iO2ZvcihlIGluIGYpZi5oYXNPd25Qcm9wZXJ0eShlKSYmKGdbZV09ZltlXSk7cmV0dXJuIGd9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ubWFrZUdlbmVyYXRvclwiLFNrLmJ1aWx0aW4ubWFrZUdlbmVyYXRvcil9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi5maWxlPWZ1bmN0aW9uKGIsZixlKXt2YXIgZztpZighKHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmZpbGUpKXJldHVybiBuZXcgU2suYnVpbHRpbi5maWxlKGIsZixlKTt0aGlzLm1vZGU9Zjt0aGlzLm5hbWU9U2suZmZpLnJlbWFwVG9KcyhiKTt0aGlzLmNsb3NlZD0hMTtpZihcIi9kZXYvc3Rkb3V0XCI9PT10aGlzLm5hbWUpdGhpcy5kYXRhJD1Tay5idWlsdGluLm5vbmUubm9uZSQsdGhpcy5maWxlbm89MTtlbHNlIGlmKFwiL2Rldi9zdGRpblwiPT09dGhpcy5uYW1lKXRoaXMuZmlsZW5vPTA7ZWxzZSBpZihcIi9kZXYvc3RkZXJyXCI9PT1cbnRoaXMubmFtZSl0aGlzLmZpbGVubz0yO2Vsc2V7aWYoXCJ3XCI9PT1Tay5mZmkucmVtYXBUb0pzKHRoaXMubW9kZSkpdGhpcy5maWxlbm89U2suYnVpbHRpbi5maWxlLmN1cnJlbnRGaWxlbm8rKztlbHNlIGZvcihnIGluIHRoaXMuZmlsZW5vPVNrLmluQnJvd3Nlcj8xMDoxMSx0aGlzLmRhdGEkPVNrLnJlYWQoYi52KSx0aGlzLmxpbmVMaXN0PXRoaXMuZGF0YSQuc3BsaXQoXCJcXG5cIiksdGhpcy5saW5lTGlzdD10aGlzLmxpbmVMaXN0LnNsaWNlKDAsLTEpLHRoaXMubGluZUxpc3QpdGhpcy5saW5lTGlzdFtnXSs9XCJcXG5cIjt0aGlzLmN1cnJlbnRMaW5lPTB9dGhpcy5wb3MkPTA7U2suZmlsZW9wZW4mJjEwPD10aGlzLmZpbGVubyYmU2suZmlsZW9wZW4odGhpcyk7cmV0dXJuIHRoaXN9O1NrLmJ1aWx0aW4uZmlsZS5jdXJyZW50RmlsZW5vPTEyO1NrLmFic3RyLnNldFVwSW5oZXJpdGFuY2UoXCJmaWxlXCIsU2suYnVpbHRpbi5maWxlLFNrLmJ1aWx0aW4ub2JqZWN0KTtTay5hYnN0ci5zZXRVcEJ1aWx0aW5Ncm8oU2suYnVpbHRpbi5maWxlKTtcblNrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuJHI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPFwiKyh0aGlzLmNsb3NlZD9cImNsb3NlZFwiOlwib3BlblwiKStcImZpbGUgJ1wiK3RoaXMubmFtZStcIicsIG1vZGUgJ1wiK1NrLmZmaS5yZW1hcFRvSnModGhpcy5tb2RlKStcIic+XCIpfTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnRwJGl0ZXI9ZnVuY3Rpb24oKXt2YXIgYj17dHAkaXRlcjpmdW5jdGlvbigpe3JldHVybiBifSwkb2JqOnRoaXMsJGluZGV4OnRoaXMuY3VycmVudExpbmUsJGxpbmVzOnRoaXMubGluZUxpc3QsdHAkaXRlcm5leHQ6ZnVuY3Rpb24oKXtpZighKGIuJGluZGV4Pj1iLiRsaW5lcy5sZW5ndGgpKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYi4kbGluZXNbYi4kaW5kZXgrK10pfX07cmV0dXJuIGJ9O1NrLmFic3RyLnNldFVwU2xvdHMoU2suYnVpbHRpbi5maWxlKTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLl9fZW50ZXJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIpe3JldHVybiBifSk7XG5Tay5idWlsdGluLmZpbGUucHJvdG90eXBlLl9fZXhpdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYil7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLmZpbGUucHJvdG90eXBlLmNsb3NlLFtiXSl9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLmNsb3NlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYil7Yi5jbG9zZWQ9ITA7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuZmx1c2g9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihiKXt9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLmZpbGVubz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLmZpbGVub30pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuaXNhdHR5PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYil7cmV0dXJuITF9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnJlYWQ9XG5uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZil7dmFyIGU9Yi5kYXRhJC5sZW5ndGg7aWYoYi5jbG9zZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkkvTyBvcGVyYXRpb24gb24gY2xvc2VkIGZpbGVcIik7dmFyIGc9dm9pZCAwPT09Zj9lOlNrLmZmaS5yZW1hcFRvSnMoZik7Zz1uZXcgU2suYnVpbHRpbi5zdHIoYi5kYXRhJC5zdWJzdHIoYi5wb3MkLGcpKTtiLnBvcyQ9dm9pZCAwPT09Zj9lOmIucG9zJCtTay5mZmkucmVtYXBUb0pzKGYpO2IucG9zJD49ZSYmKGIucG9zJD1lKTtyZXR1cm4gZ30pO1NrLmJ1aWx0aW4uZmlsZS4kcmVhZGxpbmU9ZnVuY3Rpb24oYixmLGUpe2lmKDA9PT1iLmZpbGVubyl7Yj1Tay5mZmkucmVtYXBUb0pzKGUpO2I9U2suaW5wdXRmdW4oYj9iOlwiXCIpO2lmKGIgaW5zdGFuY2VvZiBQcm9taXNlfHxiJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi50aGVuKXt2YXIgZz1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbjtnLnJlc3VtZT1mdW5jdGlvbigpe2lmKGcuZGF0YS5lcnJvcil0aHJvdyBnLmRhdGEuZXJyb3I7XG5yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGcuZGF0YS5yZXN1bHQpfTtnLmRhdGE9e3R5cGU6XCJTay5wcm9taXNlXCIscHJvbWlzZTpifTtyZXR1cm4gZ31yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGIpfWY9XCJcIjtiLmN1cnJlbnRMaW5lPGIubGluZUxpc3QubGVuZ3RoJiYoZj1iLmxpbmVMaXN0W2IuY3VycmVudExpbmVdLGIuY3VycmVudExpbmUrKyk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihmKX07U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS5yZWFkbGluZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZil7cmV0dXJuIFNrLmJ1aWx0aW4uZmlsZS4kcmVhZGxpbmUoYixmLHZvaWQgMCl9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnJlYWRsaW5lcz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZil7aWYoMD09PWIuZmlsZW5vKXJldHVybiBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwicmVhZGxpbmVzIGlucyd0IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlIHdlYiBkb2Vzbid0IHN1cHBvcnQgQ3RybCtEXCIpO1xudmFyIGU9W107Zm9yKGY9Yi5jdXJyZW50TGluZTtmPGIubGluZUxpc3QubGVuZ3RoO2YrKyllLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKGIubGluZUxpc3RbZl0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChlKX0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuc2Vlaz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZixlKXtmPVNrLmZmaS5yZW1hcFRvSnMoZik7dm9pZCAwPT09ZSYmKGU9MCk7MD09PWU/Yi5wb3MkPWY6MT09ZT9iLnBvcyQ9Yi5kYXRhJC5sZW5ndGgrZjoyPT1lJiYoYi5wb3MkPWIuZGF0YSQubGVuZ3RoK2YpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnRlbGw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihiKXtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShiLnBvcyQpfSk7U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS50cnVuY2F0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsXG5mKXtTay5hc3NlcnRzLmZhaWwoKX0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUud3JpdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihiLGYpe3ZhciBlPVNrLmZmaS5yZW1hcFRvSnMoYi5tb2RlKTtTay5mZmkucmVtYXBUb0pzKGYpO2lmKFwid1wiPT09ZXx8XCJ3YlwiPT09ZXx8XCJhXCI9PT1lfHxcImFiXCI9PT1lKWlmKFNrLmZpbGV3cml0ZSl7aWYoYi5jbG9zZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkkvTyBvcGVyYXRpb24gb24gY2xvc2VkIGZpbGVcIik7MT09PWIuZmlsZW5vP1NrLm91dHB1dChTay5mZmkucmVtYXBUb0pzKGYpKTpTay5maWxld3JpdGUoYixmKX1lbHNlIDE9PT1iLmZpbGVubz9Tay5vdXRwdXQoU2suZmZpLnJlbWFwVG9KcyhmKSk6U2suYXNzZXJ0cy5mYWlsKCk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uZmlsZVwiLFNrLmJ1aWx0aW4uZmlsZSl9LGZ1bmN0aW9uKEUsUSl7U2suZmZpPVxuU2suZmZpfHx7fTtTay5mZmkucmVtYXBUb1B5PWZ1bmN0aW9uKGIpe3ZhciBmO2lmKG51bGw9PT1ifHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGIpcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtpZihiLm9iJHR5cGV8fGIgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uKXJldHVybiBiO2lmKFwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKSl7dmFyIGU9W107Zm9yKGY9MDtmPGIubGVuZ3RoOysrZillLnB1c2goU2suZmZpLnJlbWFwVG9QeShiW2ZdKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoZSl9aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiKXtlPVtdO2ZvcihmIGluIGIpZS5wdXNoKFNrLmZmaS5yZW1hcFRvUHkoZikpLGUucHVzaChTay5mZmkucmVtYXBUb1B5KGJbZl0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZGljdChlKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihiKTtcbmlmKFwibnVtYmVyXCI9PT10eXBlb2YgYilyZXR1cm4gU2suYnVpbHRpbi5hc3NrJChiKTtpZihcImJvb2xlYW5cIj09PXR5cGVvZiBiKXJldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKGIpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYilyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBuZXcgU2suYnVpbHRpbi5mdW5jKGIpO1NrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCByZW1hcCB0eXBlIFwiK3R5cGVvZiBiKX07U2suZXhwb3J0U3ltYm9sKFwiU2suZmZpLnJlbWFwVG9QeVwiLFNrLmZmaS5yZW1hcFRvUHkpO1NrLmZmaS5yZW1hcFRvSnM9ZnVuY3Rpb24oYil7dmFyIGYsZTtpZihiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXt2YXIgZz17fTtiLiRpdGVtcygpLmZvckVhY2goaz0+e3ZhciBbcCxoXT1rO2U9U2suZmZpLnJlbWFwVG9KcyhwKTtnW2VdPVNrLmZmaS5yZW1hcFRvSnMoaCl9KTtyZXR1cm4gZ31pZihiIGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4ubGlzdHx8YiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpe2c9W107Zm9yKGY9MDtmPGIudi5sZW5ndGg7KytmKWcucHVzaChTay5mZmkucmVtYXBUb0pzKGIudltmXSkpO3JldHVybiBnfWlmKGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmJvb2wpcmV0dXJuIGIudj8hMDohMTtpZihiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRffHxiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF98fGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZylyZXR1cm4gU2suYnVpbHRpbi5hc251bSQoYik7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBifHxcImJvb2xlYW5cIj09PXR5cGVvZiBifHxcInN0cmluZ1wiPT09dHlwZW9mIGIpcmV0dXJuIGI7aWYodm9pZCAwIT09YilyZXR1cm4gYi52fTtTay5leHBvcnRTeW1ib2woXCJTay5mZmkucmVtYXBUb0pzXCIsU2suZmZpLnJlbWFwVG9Kcyk7U2suZmZpLmNhbGxiYWNrPWZ1bmN0aW9uKGIpe3JldHVybiB2b2lkIDA9PT1iP2I6ZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuYXBwbHkoYixcbnZvaWQgMCx2b2lkIDAsdm9pZCAwLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSl9fTtTay5leHBvcnRTeW1ib2woXCJTay5mZmkuY2FsbGJhY2tcIixTay5mZmkuY2FsbGJhY2spO1NrLmZmaS5zdGR3cmFwPWZ1bmN0aW9uKGIsZil7Yj1uZXcgYjtiLnY9ZjtyZXR1cm4gYn07U2suZXhwb3J0U3ltYm9sKFwiU2suZmZpLnN0ZHdyYXBcIixTay5mZmkuc3Rkd3JhcCk7U2suZmZpLmJhc2ljd3JhcD1mdW5jdGlvbihiKXtpZihiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRffHxiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF98fGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZylyZXR1cm4gU2suYnVpbHRpbi5hc251bSQoYik7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBifHxcImJvb2xlYW5cIj09PXR5cGVvZiBiKXJldHVybiBiO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGIpO1NrLmFzc2VydHMuZmFpbChcInVuZXhwZWN0ZWQgdHlwZSBmb3IgYmFzaWN3cmFwXCIpfTtcblNrLmV4cG9ydFN5bWJvbChcIlNrLmZmaS5iYXNpY3dyYXBcIixTay5mZmkuYmFzaWN3cmFwKTtTay5mZmkudW53cmFwbz1mdW5jdGlvbihiKXtpZih2b2lkIDAhPT1iKXJldHVybiBiLnZ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmZmaS51bndyYXBvXCIsU2suZmZpLnVud3JhcG8pO1NrLmZmaS51bndyYXBuPWZ1bmN0aW9uKGIpe3JldHVybiBudWxsPT09Yj9udWxsOmIudn07U2suZXhwb3J0U3ltYm9sKFwiU2suZmZpLnVud3JhcG5cIixTay5mZmkudW53cmFwbil9LGZ1bmN0aW9uKEUsUSl7ZnVuY3Rpb24gYihrLHAsaCl7az12b2lkIDA9PT1rP2s6U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coayk7cD12b2lkIDA9PT1wP3A6U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3cocCk7aD12b2lkIDA9PT1oP2g6U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coaCk7aWYodm9pZCAwPT09cCYmdm9pZCAwPT09aClwPWssaz0wLGg9MTtlbHNlIGlmKHZvaWQgMD09PWgpaD0xO2Vsc2UgaWYoMD09PWgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInJhbmdlKCkgc3RlcCBhcmd1bWVudCBtdXN0IG5vdCBiZSB6ZXJvXCIpO1xuY29uc3QgYT1bXTtpZihcIm51bWJlclwiPT09dHlwZW9mIGsmJlwibnVtYmVyXCI9PT10eXBlb2YgcCYmXCJudW1iZXJcIj09PXR5cGVvZiBoKWlmKDA8aClmb3IodmFyIGM9aztjPHA7Yys9aClhLnB1c2gobmV3IFNrLmJ1aWx0aW4uaW50XyhjKSk7ZWxzZSBmb3IoYz1rO2M+cDtjKz1oKWEucHVzaChuZXcgU2suYnVpbHRpbi5pbnRfKGMpKTtlbHNle2s9Yz1KU0JJLkJpZ0ludChrKTtoPUpTQkkuQmlnSW50KGgpO3A9SlNCSS5CaWdJbnQocCk7aWYoSlNCSS5ncmVhdGVyVGhhbihoLEpTQkkuX19aRVJPKSlmb3IoO0pTQkkubGVzc1RoYW4oYyxwKTspYS5wdXNoKG5ldyBTay5idWlsdGluLmludF8oZihjKSkpLGM9SlNCSS5hZGQoYyxoKTtlbHNlIGZvcig7SlNCSS5ncmVhdGVyVGhhbihjLHApOylhLnB1c2gobmV3IFNrLmJ1aWx0aW4uaW50XyhmKGMpKSksYz1KU0JJLmFkZChjLGgpO2s9ZihrKTtoPWYoaCk7cD1mKHApfXJldHVybiBuZXcgU2suYnVpbHRpbi5yYW5nZV8oayxwLGgsYSl9ZnVuY3Rpb24gZihrKXtyZXR1cm4gSlNCSS5sZXNzVGhhbihrLFxuSlNCSS5fX01BWF9TQUZFKSYmSlNCSS5ncmVhdGVyVGhhbihrLEpTQkkuX19NSU5fU0FGRSk/SlNCSS50b051bWJlcihrKTprfVNrLmJ1aWx0aW4ucmFuZ2VfPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJyYW5nZVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihrLHAsaCxhKXt0aGlzLnN0YXJ0PWs7dGhpcy5zdG9wPXA7dGhpcy5zdGVwPWg7dGhpcy52PWF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGRvYzpcInJhbmdlKHN0b3ApIC0+IHJhbmdlIG9iamVjdFxcbnJhbmdlKHN0YXJ0LCBzdG9wWywgc3RlcF0pIC0+IHJhbmdlIG9iamVjdFxcblxcblJldHVybiBhbiBvYmplY3QgdGhhdCBwcm9kdWNlcyBhIHNlcXVlbmNlIG9mIGludGVnZXJzIGZyb20gc3RhcnQgKGluY2x1c2l2ZSlcXG50byBzdG9wIChleGNsdXNpdmUpIGJ5IHN0ZXAuICByYW5nZShpLCBqKSBwcm9kdWNlcyBpLCBpKzEsIGkrMiwgLi4uLCBqLTEuXFxuc3RhcnQgZGVmYXVsdHMgdG8gMCwgYW5kIHN0b3AgaXMgb21pdHRlZCEgIHJhbmdlKDQpIHByb2R1Y2VzIDAsIDEsIDIsIDMuXFxuVGhlc2UgYXJlIGV4YWN0bHkgdGhlIHZhbGlkIGluZGljZXMgZm9yIGEgbGlzdCBvZiA0IGVsZW1lbnRzLlxcbldoZW4gc3RlcCBpcyBnaXZlbiwgaXQgc3BlY2lmaWVzIHRoZSBpbmNyZW1lbnQgKG9yIGRlY3JlbWVudCkuXCIsXG50cCRuZXcoayxwKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwicmFuZ2VcIixwKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJyYW5nZVwiLGssMSwzKTtyZXR1cm4gYihrWzBdLGtbMV0sa1syXSl9LCRyKCl7bGV0IGs9XCJyYW5nZShcIit0aGlzLnN0YXJ0K1wiLCBcIit0aGlzLnN0b3A7MSE9dGhpcy5zdGVwJiYoays9XCIsIFwiK3RoaXMuc3RlcCk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihrK1wiKVwiKX0sdHAkcmljaGNvbXBhcmUoayxwKXtpZihcIkVxXCIhPT1wJiZcIk5vdEVxXCIhPT1wfHxrLm9iJHR5cGUhPT1Tay5idWlsdGluLnJhbmdlXylyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7az1uZXcgU2suYnVpbHRpbi5saXN0KGsudik7cmV0dXJuKG5ldyBTay5idWlsdGluLmxpc3QodGhpcy52KSkudHAkcmljaGNvbXBhcmUoayxwKX0sdHAkaXRlcigpe3JldHVybiBuZXcgZSh0aGlzKX0sbmIkYm9vbCgpe3JldHVybiAwIT09dGhpcy52Lmxlbmd0aH0sc3EkY29udGFpbnMoayl7Y29uc3QgcD1cbnRoaXMudjtmb3IobGV0IGg9MDtoPHAubGVuZ3RoO2grKylpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woayxwW2hdLFwiRXFcIikpcmV0dXJuITA7cmV0dXJuITF9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLnYubGVuZ3RofSxtcCRzdWJzY3JpcHQoayl7aWYoU2subWlzY2V2YWwuaXNJbmRleChrKSl7az1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoayk7MD5rJiYoaz10aGlzLnYubGVuZ3RoK2spO2lmKDA+a3x8az49dGhpcy52Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFwicmFuZ2Ugb2JqZWN0IGluZGV4IG91dCBvZiByYW5nZVwiKTtyZXR1cm4gdGhpcy52W2tdfWlmKGsuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnNsaWNlKXtjb25zdCBwPVtdLGg9dGhpcy52O2suc3NzaXRlciQoaC5sZW5ndGgsbj0+e3AucHVzaChoW25dKX0pO2xldCB7c3RhcnQ6YSxzdG9wOmMsc3RlcDptfT1rLnNsaWNlJGluZGljZXMoaC5sZW5ndGgpO2E9U2subWlzY2V2YWwuYXNJbmRleChoW2FdKXx8XG50aGlzLnN0YXJ0O2M9U2subWlzY2V2YWwuYXNJbmRleChoW2NdKXx8dGhpcy5zdG9wO209XCJudW1iZXJcIj09PXR5cGVvZiB0aGlzLnN0ZXA/bSp0aGlzLnN0ZXA6SlNCSS5tdWx0aXBseSh0aGlzLnN0ZXAsSlNCSS5CaWdJbnQobSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5yYW5nZV8oYSxjLG0scCl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwicmFuZ2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIHNsaWNlcywgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGspKTt9fSxnZXRzZXRzOntzdGFydDp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuc3RhcnQpfX0sc3RlcDp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuc3RlcCl9fSxzdG9wOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5zdG9wKX19fSxtZXRob2RzOntfX3JldmVyc2VkX186eyRtZXRoKCl7cmV0dXJuIG5ldyBnKHRoaXMpfSwkZmxhZ3M6e05vQXJnczohMH0sXG4kdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gYSByZXZlcnNlIGl0ZXJhdG9yLlwifSxjb3VudDp7JG1ldGgoayl7bGV0IHA9MDtmb3IobGV0IGg9MDtoPHRoaXMudi5sZW5ndGg7aCsrKVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChrLHRoaXMudltoXSxcIkVxXCIpJiZwKys7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8ocCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJyYW5nZW9iamVjdC5jb3VudCh2YWx1ZSkgLT4gaW50ZWdlciAtLSByZXR1cm4gbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHZhbHVlXCJ9LGluZGV4OnskbWV0aChrKXtmb3IobGV0IHA9MDtwPHRoaXMudi5sZW5ndGg7cCsrKWlmKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChrLHRoaXMudltwXSxcIkVxXCIpKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHApO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoU2subWlzY2V2YWwub2JqZWN0UmVwcihrKStcImlzIG5vdCBpbiByYW5nZVwiKTtcbn0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcInJhbmdlb2JqZWN0LmluZGV4KHZhbHVlLCBbc3RhcnQsIFtzdG9wXV0pIC0+IGludGVnZXIgLS0gcmV0dXJuIGluZGV4IG9mIHZhbHVlLlxcblJhaXNlIFZhbHVlRXJyb3IgaWYgdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50LlwifX0scHJvdG86e3NrJGFzYXJyYXkoKXtyZXR1cm4gdGhpcy52LnNsaWNlKDApfX0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSk7dmFyIGU9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwicmFuZ2VfaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oayl7dGhpcy4kaW5kZXg9MDt0aGlzLiRzZXE9ay52fSxpdGVybmV4dCgpe3JldHVybiB0aGlzLiRzZXFbdGhpcy4kaW5kZXgrK119LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJMZW5ndGhIaW50V2l0aEFycmF5TWV0aG9kRGVmfSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KSxnPVxuU2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwicmFuZ2VfcmV2ZXJzZWl0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGspe3RoaXMuJHNlcT1rLnY7dGhpcy4kaW5kZXg9dGhpcy4kc2VxLmxlbmd0aC0xfSxpdGVybmV4dCgpe3JldHVybiB0aGlzLiRzZXFbdGhpcy4kaW5kZXgtLV19LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJSZXZlcnNlTGVuZ3RoSGludE1ldGhvZERlZn0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSk7U2suYnVpbHRpbi5yYW5nZT1Tay5idWlsdGluLnhyYW5nZT1mdW5jdGlvbihrLHAsaCl7az1iKGsscCxoKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChrLnYpfX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLmVudW1lcmF0ZT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJlbnVtZXJhdGVcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYixmKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmVudW1lcmF0ZSkpdGhyb3cgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnZW51bWVyYXRlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3JcIik7XG50aGlzLiRpdGVyYWJsZT1iO3RoaXMuJGluZGV4PWY7cmV0dXJuIHRoaXN9LGl0ZXJuZXh0KGIpe2NvbnN0IGY9U2subWlzY2V2YWwuY2hhaW4odGhpcy4kaXRlcmFibGUudHAkaXRlcm5leHQoYiksZT0+e2lmKHZvaWQgMCE9PWUpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuJGluZGV4KyspLGVdKX0pO3JldHVybiBiP2Y6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGYpfSxzbG90czp7dHAkZG9jOlwiUmV0dXJuIGFuIGVudW1lcmF0ZSBvYmplY3QuXFxuXFxuICBpdGVyYWJsZVxcbiAgICBhbiBvYmplY3Qgc3VwcG9ydGluZyBpdGVyYXRpb25cXG5cXG5UaGUgZW51bWVyYXRlIG9iamVjdCB5aWVsZHMgcGFpcnMgY29udGFpbmluZyBhIGNvdW50IChmcm9tIHN0YXJ0LCB3aGljaFxcbmRlZmF1bHRzIHRvIHplcm8pIGFuZCBhIHZhbHVlIHlpZWxkZWQgYnkgdGhlIGl0ZXJhYmxlIGFyZ3VtZW50LlxcblxcbmVudW1lcmF0ZSBpcyB1c2VmdWwgZm9yIG9idGFpbmluZyBhbiBpbmRleGVkIGxpc3Q6XFxuICAgICgwLCBzZXFbMF0pLCAoMSwgc2VxWzFdKSwgKDIsIHNlcVsyXSksIC4uLlwiLFxudHAkbmV3KGIsZil7bGV0IFtlLGddPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiZW51bWVyYXRlXCIsW1wiaXRlcmFibGVcIixcInN0YXJ0XCJdLGIsZixbbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0pO2U9U2suYWJzdHIuaXRlcihlKTtnPVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGcpO2lmKHRoaXM9PT1Tay5idWlsdGluLmVudW1lcmF0ZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBTay5idWlsdGluLmVudW1lcmF0ZShlLGcpO2I9bmV3IHRoaXMuY29uc3RydWN0b3I7U2suYnVpbHRpbi5lbnVtZXJhdGUuY2FsbChiLGUsZyk7cmV0dXJuIGJ9fSxjbGFzc21ldGhvZHM6U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmVudW1lcmF0ZVwiLFNrLmJ1aWx0aW4uZW51bWVyYXRlKX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLmZpbHRlcl89U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiZmlsdGVyXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsXG5mKXt0aGlzLiRmdW5jPWI7dGhpcy4kaXRlcmFibGU9Zn0saXRlcm5leHQoYil7Y29uc3QgZj1Tay5taXNjZXZhbC5pdGVyRm9yKHRoaXMuJGl0ZXJhYmxlLGU9PlNrLm1pc2NldmFsLmNoYWluKHRoaXMuY2hlY2skZmlsdGVyKGUpLGc9Pmc/bmV3IFNrLm1pc2NldmFsLkJyZWFrKGcpOnZvaWQgMCkpO3JldHVybiBiP2Y6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGYpfSxzbG90czp7dHAkZG9jOlwiUmV0dXJuIGFuIGl0ZXJhdG9yIHlpZWxkaW5nIHRob3NlIGl0ZW1zIG9mIGl0ZXJhYmxlIGZvciB3aGljaCBmdW5jdGlvbihpdGVtKVxcbmlzIHRydWUuIElmIGZ1bmN0aW9uIGlzIE5vbmUsIHJldHVybiB0aGUgaXRlbXMgdGhhdCBhcmUgdHJ1ZS5cIix0cCRuZXcoYixmKXtsZXQgW2UsZ109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJmaWx0ZXJcIixbXCJwcmVkaWNhdGVcIixcIml0ZXJhYmxlXCJdLGIsZixbXSk7ZT1Tay5idWlsdGluLmNoZWNrTm9uZShlKT9cbm51bGw6ZTtnPVNrLmFic3RyLml0ZXIoZyk7aWYodGhpcz09PVNrLmJ1aWx0aW4uZmlsdGVyXy5wcm90b3R5cGUpcmV0dXJuIG5ldyBTay5idWlsdGluLmZpbHRlcl8oZSxnKTtiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO1NrLmJ1aWx0aW4uZmlsdGVyXy5jYWxsKGIsZSxnKTtyZXR1cm4gYn19LHByb3RvOntjaGVjayRmaWx0ZXIoYil7bGV0IGY7Zj1udWxsPT09dGhpcy4kZnVuYz9iOlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLiRmdW5jLFtiXSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGYsZT0+U2subWlzY2V2YWwuaXNUcnVlKGUpP2I6dm9pZCAwKX19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5maWx0ZXJfXCIsU2suYnVpbHRpbi5maWx0ZXJfKX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLm1hcF89U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwibWFwXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZil7dGhpcy4kZnVuYz1iO3RoaXMuJGl0ZXJzPVxuZn0saXRlcm5leHQoYil7Y29uc3QgZj1bXSxlPVNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheSh0aGlzLiRpdGVycyxnPT5Tay5taXNjZXZhbC5jaGFpbihnLnRwJGl0ZXJuZXh0KGIpLGs9PntpZih2b2lkIDA9PT1rKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoITApO2YucHVzaChrKX0pKSxnPT5nP3ZvaWQgMDpTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkodGhpcy4kZnVuYyxmKSk7cmV0dXJuIGI/ZTpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coZSl9LHNsb3RzOnt0cCRkb2M6XCJtYXAoZnVuYywgKml0ZXJhYmxlcykgLS1cXHgzZSBtYXAgb2JqZWN0XFxuXFxuTWFrZSBhbiBpdGVyYXRvciB0aGF0IGNvbXB1dGVzIHRoZSBmdW5jdGlvbiB1c2luZyBhcmd1bWVudHMgZnJvbVxcbmVhY2ggb2YgdGhlIGl0ZXJhYmxlcy4gIFN0b3BzIHdoZW4gdGhlIHNob3J0ZXN0IGl0ZXJhYmxlIGlzIGV4aGF1c3RlZC5cIix0cCRuZXcoYixcbmYpe3RoaXM9PT1Tay5idWlsdGluLm1hcF8ucHJvdG90eXBlJiZTay5hYnN0ci5jaGVja05vS3dhcmdzKFwibWFwXCIsZik7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwibWFwXCIsYiwyKTtmPWJbMF07Y29uc3QgZT1bXTtmb3IobGV0IGc9MTtnPGIubGVuZ3RoO2crKyllLnB1c2goU2suYWJzdHIuaXRlcihiW2ddKSk7aWYodGhpcz09PVNrLmJ1aWx0aW4ubWFwXy5wcm90b3R5cGUpcmV0dXJuIG5ldyBTay5idWlsdGluLm1hcF8oZixlKTtiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO1NrLmJ1aWx0aW4ubWFwXy5jYWxsKGIsZixlKTtyZXR1cm4gYn19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5tYXBfXCIsU2suYnVpbHRpbi5tYXBfKX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLnJldmVyc2VkPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcInJldmVyc2VkXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIpe3RoaXMuJGlkeD1iLnNxJGxlbmd0aCgpLTE7dGhpcy4kc2VxPWI7cmV0dXJuIHRoaXN9LFxuaXRlcm5leHQoYil7aWYoISgwPnRoaXMuJGlkeCkpe3ZhciBmPVNrLm1pc2NldmFsLnRyeUNhdGNoKCgpPT5Tay5hYnN0ci5vYmplY3RHZXRJdGVtKHRoaXMuJHNlcSxuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuJGlkeC0tKSxiKSxlPT57aWYoZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uSW5kZXhFcnJvcil0aGlzLiRpZHg9LTE7ZWxzZSB0aHJvdyBlO30pO3JldHVybiBiP2Y6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGYpfX0sc2xvdHM6e3RwJGRvYzpcIlJldHVybiBhIHJldmVyc2UgaXRlcmF0b3Igb3ZlciB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBzZXF1ZW5jZS5cIix0cCRuZXcoYixmKXt0aGlzPT09U2suYnVpbHRpbi5yZXZlcnNlZC5wcm90b3R5cGUmJlNrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJyZXZlcnNlZFwiLGYpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcInJldmVyc2VkXCIsYiwxLDEpO2I9YlswXTtmPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYixcblNrLmJ1aWx0aW4uc3RyLiRyZXZlcnNlZCk7aWYodm9pZCAwIT09ZilyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGYsW10pO2lmKCFTay5idWlsdGluLmNoZWNrU2VxdWVuY2UoYil8fHZvaWQgMD09PVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYixTay5idWlsdGluLnN0ci4kbGVuKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoYikrXCInIG9iamVjdCBpcyBub3QgYSBzZXF1ZW5jZVwiKTtpZih0aGlzPT09U2suYnVpbHRpbi5yZXZlcnNlZC5wcm90b3R5cGUpcmV0dXJuIG5ldyBTay5idWlsdGluLnJldmVyc2VkKGIpO2Y9bmV3IHRoaXMuY29uc3RydWN0b3I7U2suYnVpbHRpbi5yZXZlcnNlZC5jYWxsKGYsYik7cmV0dXJuIGZ9fSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIDA8PXRoaXMuJGlkeD9uZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuJGlkeCk6bmV3IFNrLmJ1aWx0aW4uaW50XygwKX0sXG4kZmxhZ3M6e05vQXJnczohMH19fX0pfSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4uemlwXz1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJ6aXBcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYil7dGhpcy4kaXRlcnM9YjswPT09Yi5sZW5ndGgmJih0aGlzLnRwJGl0ZXJuZXh0PSgpPT57fSl9LGl0ZXJuZXh0KGIpe2NvbnN0IGY9W10sZT1Tay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyQXJyYXkodGhpcy4kaXRlcnMsZz0+U2subWlzY2V2YWwuY2hhaW4oZy50cCRpdGVybmV4dChiKSxrPT57aWYodm9pZCAwPT09aylyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrKCEwKTtmLnB1c2goayl9KSksZz0+Zz92b2lkIDA6bmV3IFNrLmJ1aWx0aW4udHVwbGUoZikpO3JldHVybiBiP2U6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGUpfSxzbG90czp7dHAkZG9jOlwiemlwKGl0ZXIxIFssaXRlcjIgWy4uLl1dKSAtLVxceDNlIHppcCBvYmplY3RcXG5cXG5SZXR1cm4gYSB6aXAgb2JqZWN0IHdob3NlIC5fX25leHRfXygpIG1ldGhvZCByZXR1cm5zIGEgdHVwbGUgd2hlcmVcXG50aGUgaS10aCBlbGVtZW50IGNvbWVzIGZyb20gdGhlIGktdGggaXRlcmFibGUgYXJndW1lbnQuICBUaGUgLl9fbmV4dF9fKClcXG5tZXRob2QgY29udGludWVzIHVudGlsIHRoZSBzaG9ydGVzdCBpdGVyYWJsZSBpbiB0aGUgYXJndW1lbnQgc2VxdWVuY2VcXG5pcyBleGhhdXN0ZWQgYW5kIHRoZW4gaXQgcmFpc2VzIFN0b3BJdGVyYXRpb24uXCIsXG50cCRuZXcoYixmKXt0aGlzPT09U2suYnVpbHRpbi56aXBfLnByb3RvdHlwZSYmU2suYWJzdHIuY2hlY2tOb0t3YXJncyhcInppcFwiLGYpO2Y9W107Zm9yKGxldCBlPTA7ZTxiLmxlbmd0aDtlKyspdHJ5e2YucHVzaChTay5hYnN0ci5pdGVyKGJbZV0pKX1jYXRjaChnKXtpZihnIGluc3RhbmNlb2YgU2suYnVpbHRpbi5UeXBlRXJyb3IpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiemlwIGFyZ3VtZW50ICNcIisoZSsxKStcIiBtdXN0IHN1cHBvcnQgaXRlcmF0aW9uXCIpO3Rocm93IGc7fWlmKHRoaXM9PT1Tay5idWlsdGluLnppcF8ucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi56aXBfKGYpO2I9bmV3IHRoaXMuY29uc3RydWN0b3I7U2suYnVpbHRpbi56aXBfLmNhbGwoYixmKTtyZXR1cm4gYn19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi56aXBfXCIsU2suYnVpbHRpbi56aXBfKX0sZnVuY3Rpb24oRSxRKXt2YXIgYj17VF9FTkRNQVJLRVI6MCxUX05BTUU6MSxcblRfTlVNQkVSOjIsVF9TVFJJTkc6MyxUX05FV0xJTkU6NCxUX0lOREVOVDo1LFRfREVERU5UOjYsVF9MUEFSOjcsVF9SUEFSOjgsVF9MU1FCOjksVF9SU1FCOjEwLFRfQ09MT046MTEsVF9DT01NQToxMixUX1NFTUk6MTMsVF9QTFVTOjE0LFRfTUlOVVM6MTUsVF9TVEFSOjE2LFRfU0xBU0g6MTcsVF9WQkFSOjE4LFRfQU1QRVI6MTksVF9MRVNTOjIwLFRfR1JFQVRFUjoyMSxUX0VRVUFMOjIyLFRfRE9UOjIzLFRfUEVSQ0VOVDoyNCxUX0xCUkFDRToyNSxUX1JCUkFDRToyNixUX0VRRVFVQUw6MjcsVF9OT1RFUVVBTDoyOCxUX0xFU1NFUVVBTDoyOSxUX0dSRUFURVJFUVVBTDozMCxUX1RJTERFOjMxLFRfQ0lSQ1VNRkxFWDozMixUX0xFRlRTSElGVDozMyxUX1JJR0hUU0hJRlQ6MzQsVF9ET1VCTEVTVEFSOjM1LFRfUExVU0VRVUFMOjM2LFRfTUlORVFVQUw6MzcsVF9TVEFSRVFVQUw6MzgsVF9TTEFTSEVRVUFMOjM5LFRfUEVSQ0VOVEVRVUFMOjQwLFRfQU1QRVJFUVVBTDo0MSxUX1ZCQVJFUVVBTDo0MixcblRfQ0lSQ1VNRkxFWEVRVUFMOjQzLFRfTEVGVFNISUZURVFVQUw6NDQsVF9SSUdIVFNISUZURVFVQUw6NDUsVF9ET1VCTEVTVEFSRVFVQUw6NDYsVF9ET1VCTEVTTEFTSDo0NyxUX0RPVUJMRVNMQVNIRVFVQUw6NDgsVF9BVDo0OSxUX0FURVFVQUw6NTAsVF9SQVJST1c6NTEsVF9FTExJUFNJUzo1MixUX09QOjUzLFRfQVdBSVQ6NTQsVF9BU1lOQzo1NSxUX0VSUk9SVE9LRU46NTYsVF9OVF9PRkZTRVQ6MjU2LFRfTl9UT0tFTlM6NjAsVF9DT01NRU5UOjU3LFRfTkw6NTgsVF9FTkNPRElORzo1OX07RT17XCIhPVwiOmIuVF9OT1RFUVVBTCxcIiVcIjpiLlRfUEVSQ0VOVCxcIiU9XCI6Yi5UX1BFUkNFTlRFUVVBTCxcIiZcIjpiLlRfQU1QRVIsXCImPVwiOmIuVF9BTVBFUkVRVUFMLFwiKFwiOmIuVF9MUEFSLFwiKVwiOmIuVF9SUEFSLFwiKlwiOmIuVF9TVEFSLFwiKipcIjpiLlRfRE9VQkxFU1RBUixcIioqPVwiOmIuVF9ET1VCTEVTVEFSRVFVQUwsXCIqPVwiOmIuVF9TVEFSRVFVQUwsXCIrXCI6Yi5UX1BMVVMsXCIrPVwiOmIuVF9QTFVTRVFVQUwsXG5cIixcIjpiLlRfQ09NTUEsXCItXCI6Yi5UX01JTlVTLFwiLT1cIjpiLlRfTUlORVFVQUwsXCItPlwiOmIuVF9SQVJST1csXCIuXCI6Yi5UX0RPVCxcIi4uLlwiOmIuVF9FTExJUFNJUyxcIi9cIjpiLlRfU0xBU0gsXCIvL1wiOmIuVF9ET1VCTEVTTEFTSCxcIi8vPVwiOmIuVF9ET1VCTEVTTEFTSEVRVUFMLFwiLz1cIjpiLlRfU0xBU0hFUVVBTCxcIjpcIjpiLlRfQ09MT04sXCI7XCI6Yi5UX1NFTUksXCI8XCI6Yi5UX0xFU1MsXCI8PFwiOmIuVF9MRUZUU0hJRlQsXCI8PD1cIjpiLlRfTEVGVFNISUZURVFVQUwsXCI8PVwiOmIuVF9MRVNTRVFVQUwsXCI9XCI6Yi5UX0VRVUFMLFwiPT1cIjpiLlRfRVFFUVVBTCxcIj5cIjpiLlRfR1JFQVRFUixcIj49XCI6Yi5UX0dSRUFURVJFUVVBTCxcIj4+XCI6Yi5UX1JJR0hUU0hJRlQsXCI+Pj1cIjpiLlRfUklHSFRTSElGVEVRVUFMLFwiQFwiOmIuVF9BVCxcIkA9XCI6Yi5UX0FURVFVQUwsXCJbXCI6Yi5UX0xTUUIsXCJdXCI6Yi5UX1JTUUIsXCJeXCI6Yi5UX0NJUkNVTUZMRVgsXCJePVwiOmIuVF9DSVJDVU1GTEVYRVFVQUwsXCJ7XCI6Yi5UX0xCUkFDRSxcblwifFwiOmIuVF9WQkFSLFwifD1cIjpiLlRfVkJBUkVRVUFMLFwifVwiOmIuVF9SQlJBQ0UsXCJ+XCI6Yi5UX1RJTERFfTt2YXIgZj17fTsoZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gYilmW2JbZV1dPWV9KSgpO1tcInRva19uYW1lXCIsXCJJU1RFUk1JTkFMXCIsXCJJU05PTlRFUk1JTkFMXCIsXCJJU0VPRlwiXS5jb25jYXQoT2JqZWN0LmtleXMoZikubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBmW2VdfSkpO1NrLnRva2VuPXt9O1NrLnRva2VuLnRva2Vucz1iO1NrLnRva2VuLnRva19uYW1lPWY7U2sudG9rZW4uRVhBQ1RfVE9LRU5fVFlQRVM9RTtTay50b2tlbi5JU1RFUk1JTkFMPWZ1bmN0aW9uKGUpe3JldHVybiBlPGIuVF9OVF9PRkZTRVR9O1NrLnRva2VuLklTTk9OVEVSTUlOQUw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU+PWIuVF9OVF9PRkZTRVR9O1NrLnRva2VuLklTRU9GPWZ1bmN0aW9uKGUpe3JldHVybiBlPT1iLlRfRU5ETUFSS0VSfTtTay5leHBvcnRTeW1ib2woXCJTay50b2tlblwiLFNrLnRva2VuKTtTay5leHBvcnRTeW1ib2woXCJTay50b2tlbi50b2tlbnNcIixcblNrLnRva2VuLnRva2Vucyk7U2suZXhwb3J0U3ltYm9sKFwiU2sudG9rZW4udG9rX25hbWVcIixTay50b2tlbi50b2tfbmFtZSk7U2suZXhwb3J0U3ltYm9sKFwiU2sudG9rZW4uRVhBQ1RfVE9LRU5fVFlQRVNcIik7U2suZXhwb3J0U3ltYm9sKFwiU2sudG9rZW4uSVNURVJNSU5BTFwiLFNrLnRva2VuLklTVEVSTUlOQUwpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLklTTk9OVEVSTUlOQUxcIixTay50b2tlbi5JU05PTlRFUk1JTkFMKTtTay5leHBvcnRTeW1ib2woXCJTay50b2tlbi5JU0VPRlwiLFNrLnRva2VuLklTRU9GKX0sZnVuY3Rpb24oRSxRKXtTay5PcE1hcD17XCIoXCI6U2sudG9rZW4udG9rZW5zLlRfTFBBUixcIilcIjpTay50b2tlbi50b2tlbnMuVF9SUEFSLFwiW1wiOlNrLnRva2VuLnRva2Vucy5UX0xTUUIsXCJdXCI6U2sudG9rZW4udG9rZW5zLlRfUlNRQixcIjpcIjpTay50b2tlbi50b2tlbnMuVF9DT0xPTixcIixcIjpTay50b2tlbi50b2tlbnMuVF9DT01NQSxcIjtcIjpTay50b2tlbi50b2tlbnMuVF9TRU1JLFxuXCIrXCI6U2sudG9rZW4udG9rZW5zLlRfUExVUyxcIi1cIjpTay50b2tlbi50b2tlbnMuVF9NSU5VUyxcIipcIjpTay50b2tlbi50b2tlbnMuVF9TVEFSLFwiL1wiOlNrLnRva2VuLnRva2Vucy5UX1NMQVNILFwifFwiOlNrLnRva2VuLnRva2Vucy5UX1ZCQVIsXCImXCI6U2sudG9rZW4udG9rZW5zLlRfQU1QRVIsXCI8XCI6U2sudG9rZW4udG9rZW5zLlRfTEVTUyxcIj5cIjpTay50b2tlbi50b2tlbnMuVF9HUkVBVEVSLFwiPVwiOlNrLnRva2VuLnRva2Vucy5UX0VRVUFMLFwiLlwiOlNrLnRva2VuLnRva2Vucy5UX0RPVCxcIiVcIjpTay50b2tlbi50b2tlbnMuVF9QRVJDRU5ULFwiYFwiOlNrLnRva2VuLnRva2Vucy5UX0JBQ0tRVU9URSxcIntcIjpTay50b2tlbi50b2tlbnMuVF9MQlJBQ0UsXCJ9XCI6U2sudG9rZW4udG9rZW5zLlRfUkJSQUNFLFwiQFwiOlNrLnRva2VuLnRva2Vucy5UX0FULFwiQD1cIjpTay50b2tlbi50b2tlbnMuVF9BVEVRVUFMLFwiPT1cIjpTay50b2tlbi50b2tlbnMuVF9FUUVRVUFMLFwiIT1cIjpTay50b2tlbi50b2tlbnMuVF9OT1RFUVVBTCxcblwiPD5cIjpTay50b2tlbi50b2tlbnMuVF9OT1RFUVVBTCxcIjw9XCI6U2sudG9rZW4udG9rZW5zLlRfTEVTU0VRVUFMLFwiPj1cIjpTay50b2tlbi50b2tlbnMuVF9HUkVBVEVSRVFVQUwsXCJ+XCI6U2sudG9rZW4udG9rZW5zLlRfVElMREUsXCJeXCI6U2sudG9rZW4udG9rZW5zLlRfQ0lSQ1VNRkxFWCxcIjw8XCI6U2sudG9rZW4udG9rZW5zLlRfTEVGVFNISUZULFwiPj5cIjpTay50b2tlbi50b2tlbnMuVF9SSUdIVFNISUZULFwiKipcIjpTay50b2tlbi50b2tlbnMuVF9ET1VCTEVTVEFSLFwiKz1cIjpTay50b2tlbi50b2tlbnMuVF9QTFVTRVFVQUwsXCItPVwiOlNrLnRva2VuLnRva2Vucy5UX01JTkVRVUFMLFwiKj1cIjpTay50b2tlbi50b2tlbnMuVF9TVEFSRVFVQUwsXCIvPVwiOlNrLnRva2VuLnRva2Vucy5UX1NMQVNIRVFVQUwsXCIlPVwiOlNrLnRva2VuLnRva2Vucy5UX1BFUkNFTlRFUVVBTCxcIiY9XCI6U2sudG9rZW4udG9rZW5zLlRfQU1QRVJFUVVBTCxcInw9XCI6U2sudG9rZW4udG9rZW5zLlRfVkJBUkVRVUFMLFwiXj1cIjpTay50b2tlbi50b2tlbnMuVF9DSVJDVU1GTEVYRVFVQUwsXG5cIjw8PVwiOlNrLnRva2VuLnRva2Vucy5UX0xFRlRTSElGVEVRVUFMLFwiPj49XCI6U2sudG9rZW4udG9rZW5zLlRfUklHSFRTSElGVEVRVUFMLFwiKio9XCI6U2sudG9rZW4udG9rZW5zLlRfRE9VQkxFU1RBUkVRVUFMLFwiLy9cIjpTay50b2tlbi50b2tlbnMuVF9ET1VCTEVTTEFTSCxcIi8vPVwiOlNrLnRva2VuLnRva2Vucy5UX0RPVUJMRVNMQVNIRVFVQUwsXCItPlwiOlNrLnRva2VuLnRva2Vucy5UX1JBUlJPVyxcIi4uLlwiOlNrLnRva2VuLnRva2Vucy5UX0VMTElQU0lTfTtTay5QYXJzZVRhYmxlcz17c3ltOnthbmRfZXhwcjoyNTcsYW5kX3Rlc3Q6MjU4LGFubmFzc2lnbjoyNTksYXJnbGlzdDoyNjAsYXJndW1lbnQ6MjYxLGFyaXRoX2V4cHI6MjYyLGFzc2VydF9zdG10OjI2Myxhc3luY19mdW5jZGVmOjI2NCxhc3luY19zdG10OjI2NSxhdG9tOjI2NixhdG9tX2V4cHI6MjY3LGF1Z2Fzc2lnbjoyNjgsYnJlYWtfc3RtdDoyNjksY2xhc3NkZWY6MjcwLGNvbXBfZm9yOjI3MSxjb21wX2lmOjI3Mixjb21wX2l0ZXI6MjczLFxuY29tcF9vcDoyNzQsY29tcGFyaXNvbjoyNzUsY29tcG91bmRfc3RtdDoyNzYsY29udGludWVfc3RtdDoyNzcsZGVidWdnZXJfc3RtdDoyNzgsZGVjb3JhdGVkOjI3OSxkZWNvcmF0b3I6MjgwLGRlY29yYXRvcnM6MjgxLGRlbF9zdG10OjI4MixkaWN0b3JzZXRtYWtlcjoyODMsZG90dGVkX2FzX25hbWU6Mjg0LGRvdHRlZF9hc19uYW1lczoyODUsZG90dGVkX25hbWU6Mjg2LGVuY29kaW5nX2RlY2w6Mjg3LGV2YWxfaW5wdXQ6Mjg4LGV4Y2VwdF9jbGF1c2U6Mjg5LGV4cHI6MjkwLGV4cHJfc3RtdDoyOTEsZXhwcmxpc3Q6MjkyLGZhY3RvcjoyOTMsZmlsZV9pbnB1dDoyOTQsZmxvd19zdG10OjI5NSxmb3Jfc3RtdDoyOTYsZnVuY2RlZjoyOTcsZ2xvYmFsX3N0bXQ6Mjk4LGlmX3N0bXQ6Mjk5LGltcG9ydF9hc19uYW1lOjMwMCxpbXBvcnRfYXNfbmFtZXM6MzAxLGltcG9ydF9mcm9tOjMwMixpbXBvcnRfbmFtZTozMDMsaW1wb3J0X3N0bXQ6MzA0LGxhbWJkZWY6MzA1LGxhbWJkZWZfbm9jb25kOjMwNixcbm5vbmxvY2FsX3N0bXQ6MzA3LG5vdF90ZXN0OjMwOCxvcl90ZXN0OjMwOSxwYXJhbWV0ZXJzOjMxMCxwYXNzX3N0bXQ6MzExLHBvd2VyOjMxMixwcmludF9zdG10OjMxMyxyYWlzZV9zdG10OjMxNCxyZXR1cm5fc3RtdDozMTUsc2hpZnRfZXhwcjozMTYsc2ltcGxlX3N0bXQ6MzE3LHNpbmdsZV9pbnB1dDoyNTYsc2xpY2VvcDozMTgsc21hbGxfc3RtdDozMTksc3Rhcl9leHByOjMyMCxzdG10OjMyMSxzdWJzY3JpcHQ6MzIyLHN1YnNjcmlwdGxpc3Q6MzIzLHN1aXRlOjMyNCx0ZXJtOjMyNSx0ZXN0OjMyNix0ZXN0X25vY29uZDozMjcsdGVzdGxpc3Q6MzI4LHRlc3RsaXN0X2NvbXA6MzI5LHRlc3RsaXN0X3N0YXJfZXhwcjozMzAsdGZwZGVmOjMzMSx0cmFpbGVyOjMzMix0cnlfc3RtdDozMzMsdHlwZWRhcmdzbGlzdDozMzQsdmFyYXJnc2xpc3Q6MzM1LHZmcGRlZjozMzYsd2hpbGVfc3RtdDozMzcsd2l0aF9pdGVtOjMzOCx3aXRoX3N0bXQ6MzM5LHhvcl9leHByOjM0MCx5aWVsZF9hcmc6MzQxLFxueWllbGRfZXhwcjozNDIseWllbGRfc3RtdDozNDN9LG51bWJlcjJzeW1ib2w6ezI1NjpcInNpbmdsZV9pbnB1dFwiLDI1NzpcImFuZF9leHByXCIsMjU4OlwiYW5kX3Rlc3RcIiwyNTk6XCJhbm5hc3NpZ25cIiwyNjA6XCJhcmdsaXN0XCIsMjYxOlwiYXJndW1lbnRcIiwyNjI6XCJhcml0aF9leHByXCIsMjYzOlwiYXNzZXJ0X3N0bXRcIiwyNjQ6XCJhc3luY19mdW5jZGVmXCIsMjY1OlwiYXN5bmNfc3RtdFwiLDI2NjpcImF0b21cIiwyNjc6XCJhdG9tX2V4cHJcIiwyNjg6XCJhdWdhc3NpZ25cIiwyNjk6XCJicmVha19zdG10XCIsMjcwOlwiY2xhc3NkZWZcIiwyNzE6XCJjb21wX2ZvclwiLDI3MjpcImNvbXBfaWZcIiwyNzM6XCJjb21wX2l0ZXJcIiwyNzQ6XCJjb21wX29wXCIsMjc1OlwiY29tcGFyaXNvblwiLDI3NjpcImNvbXBvdW5kX3N0bXRcIiwyNzc6XCJjb250aW51ZV9zdG10XCIsMjc4OlwiZGVidWdnZXJfc3RtdFwiLDI3OTpcImRlY29yYXRlZFwiLDI4MDpcImRlY29yYXRvclwiLDI4MTpcImRlY29yYXRvcnNcIiwyODI6XCJkZWxfc3RtdFwiLDI4MzpcImRpY3RvcnNldG1ha2VyXCIsXG4yODQ6XCJkb3R0ZWRfYXNfbmFtZVwiLDI4NTpcImRvdHRlZF9hc19uYW1lc1wiLDI4NjpcImRvdHRlZF9uYW1lXCIsMjg3OlwiZW5jb2RpbmdfZGVjbFwiLDI4ODpcImV2YWxfaW5wdXRcIiwyODk6XCJleGNlcHRfY2xhdXNlXCIsMjkwOlwiZXhwclwiLDI5MTpcImV4cHJfc3RtdFwiLDI5MjpcImV4cHJsaXN0XCIsMjkzOlwiZmFjdG9yXCIsMjk0OlwiZmlsZV9pbnB1dFwiLDI5NTpcImZsb3dfc3RtdFwiLDI5NjpcImZvcl9zdG10XCIsMjk3OlwiZnVuY2RlZlwiLDI5ODpcImdsb2JhbF9zdG10XCIsMjk5OlwiaWZfc3RtdFwiLDMwMDpcImltcG9ydF9hc19uYW1lXCIsMzAxOlwiaW1wb3J0X2FzX25hbWVzXCIsMzAyOlwiaW1wb3J0X2Zyb21cIiwzMDM6XCJpbXBvcnRfbmFtZVwiLDMwNDpcImltcG9ydF9zdG10XCIsMzA1OlwibGFtYmRlZlwiLDMwNjpcImxhbWJkZWZfbm9jb25kXCIsMzA3Olwibm9ubG9jYWxfc3RtdFwiLDMwODpcIm5vdF90ZXN0XCIsMzA5Olwib3JfdGVzdFwiLDMxMDpcInBhcmFtZXRlcnNcIiwzMTE6XCJwYXNzX3N0bXRcIiwzMTI6XCJwb3dlclwiLDMxMzpcInByaW50X3N0bXRcIixcbjMxNDpcInJhaXNlX3N0bXRcIiwzMTU6XCJyZXR1cm5fc3RtdFwiLDMxNjpcInNoaWZ0X2V4cHJcIiwzMTc6XCJzaW1wbGVfc3RtdFwiLDMxODpcInNsaWNlb3BcIiwzMTk6XCJzbWFsbF9zdG10XCIsMzIwOlwic3Rhcl9leHByXCIsMzIxOlwic3RtdFwiLDMyMjpcInN1YnNjcmlwdFwiLDMyMzpcInN1YnNjcmlwdGxpc3RcIiwzMjQ6XCJzdWl0ZVwiLDMyNTpcInRlcm1cIiwzMjY6XCJ0ZXN0XCIsMzI3OlwidGVzdF9ub2NvbmRcIiwzMjg6XCJ0ZXN0bGlzdFwiLDMyOTpcInRlc3RsaXN0X2NvbXBcIiwzMzA6XCJ0ZXN0bGlzdF9zdGFyX2V4cHJcIiwzMzE6XCJ0ZnBkZWZcIiwzMzI6XCJ0cmFpbGVyXCIsMzMzOlwidHJ5X3N0bXRcIiwzMzQ6XCJ0eXBlZGFyZ3NsaXN0XCIsMzM1OlwidmFyYXJnc2xpc3RcIiwzMzY6XCJ2ZnBkZWZcIiwzMzc6XCJ3aGlsZV9zdG10XCIsMzM4Olwid2l0aF9pdGVtXCIsMzM5Olwid2l0aF9zdG10XCIsMzQwOlwieG9yX2V4cHJcIiwzNDE6XCJ5aWVsZF9hcmdcIiwzNDI6XCJ5aWVsZF9leHByXCIsMzQzOlwieWllbGRfc3RtdFwifSxkZmFzOnsyNTY6W1tbWzEsMV0sXG5bMiwxXSxbMywyXV0sW1swLDFdXSxbWzIsMV1dXSx7MjoxLDQ6MSw1OjEsNjoxLDc6MSw4OjEsOToxLDEwOjEsMTE6MSwxMjoxLDEzOjEsMTQ6MSwxNToxLDE2OjEsMTc6MSwxODoxLDE5OjEsMjA6MSwyMToxLDIyOjEsMjM6MSwyNDoxLDI1OjEsMjY6MSwyNzoxLDI4OjEsMjk6MSwzMDoxLDMxOjEsMzI6MSwzMzoxLDM0OjEsMzU6MSwzNjoxLDM3OjEsMzg6MSwzOToxLDQwOjEsNDE6MSw0MjoxLDQzOjF9XSwyNTc6W1tbWzQ0LDFdXSxbWzQ1LDBdLFswLDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI1ODpbW1tbNDYsMV1dLFtbNDcsMF0sWzAsMV1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI1OTpbW1tbNDgsMV1dLFtbNDksMl1dLFtbNTAsM10sWzAsMl1dLFtbNDksNF1dLFtbMCw0XV1dLHs0ODoxfV0sXG4yNjA6W1tbWzUxLDFdXSxbWzUyLDJdLFswLDFdXSxbWzUxLDFdLFswLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxLDUzOjF9XSwyNjE6W1tbWzQ5LDFdLFsxNSwyXSxbNTMsMl1dLFtbNTAsMl0sWzU0LDNdLFswLDFdXSxbWzQ5LDNdXSxbWzAsM11dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjEsNTM6MX1dLDI2MjpbW1tbNTUsMV1dLFtbMzAsMF0sWzQzLDBdLFswLDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI2MzpbW1tbMjQsMV1dLFtbNDksMl1dLFtbNTIsM10sWzAsMl1dLFtbNDksNF1dLFtbMCw0XV1dLHsyNDoxfV0sMjY0OltbW1sxMCwxXV0sW1s1NiwyXV0sW1swLDJdXV0sezEwOjF9XSxcbjI2NTpbW1tbMTAsMV1dLFtbNTcsMl0sWzU2LDJdLFs1OCwyXV0sW1swLDJdXV0sezEwOjF9XSwyNjY6W1tbWzYsMV0sWzI1LDFdLFszMywxXSxbOSwxXSxbMTEsMV0sWzEyLDJdLFszNSwzXSxbMzgsNF0sWzE5LDFdLFs3LDVdXSxbWzAsMV1dLFtbNTksMV0sWzYwLDZdXSxbWzYxLDFdLFs2Miw3XSxbNjMsN11dLFtbNjQsMV0sWzYzLDhdXSxbWzcsNV0sWzAsNV1dLFtbNTksMV1dLFtbNjEsMV1dLFtbNjQsMV1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjU6MSwzMzoxLDM1OjEsMzg6MX1dLDI2NzpbW1tbMjksMV0sWzY1LDJdXSxbWzY1LDJdXSxbWzY2LDJdLFswLDJdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDI1OjEsMjk6MSwzMzoxLDM1OjEsMzg6MX1dLDI2ODpbW1tbNjcsMV0sWzY4LDFdLFs2OSwxXSxbNzAsMV0sWzcxLDFdLFs3MiwxXSxbNzMsMV0sWzc0LDFdLFs3NSwxXSxbNzYsMV0sWzc3LDFdLFs3OCwxXSxbNzksMV1dLFtbMCwxXV1dLHs2NzoxLFxuNjg6MSw2OToxLDcwOjEsNzE6MSw3MjoxLDczOjEsNzQ6MSw3NToxLDc2OjEsNzc6MSw3ODoxLDc5OjF9XSwyNjk6W1tbWzM5LDFdXSxbWzAsMV1dXSx7Mzk6MX1dLDI3MDpbW1tbMTMsMV1dLFtbMjUsMl1dLFtbNDgsM10sWzM1LDRdXSxbWzgwLDVdXSxbWzYxLDZdLFs4MSw3XV0sW1swLDVdXSxbWzQ4LDNdXSxbWzYxLDZdXV0sezEzOjF9XSwyNzE6W1tbWzEwLDFdLFszNCwyXV0sW1szNCwyXV0sW1s4MiwzXV0sW1s4Myw0XV0sW1s4NCw1XV0sW1s4NSw2XSxbMCw1XV0sW1swLDZdXV0sezEwOjEsMzQ6MX1dLDI3MjpbW1tbMzcsMV1dLFtbODYsMl1dLFtbODUsM10sWzAsMl1dLFtbMCwzXV1dLHszNzoxfV0sMjczOltbW1s4NywxXSxbNTQsMV1dLFtbMCwxXV1dLHsxMDoxLDM0OjEsMzc6MX1dLDI3NDpbW1tbODgsMV0sWzg5LDFdLFs4LDJdLFs5MCwxXSxbODgsMV0sWzgzLDFdLFs5MSwxXSxbOTIsM10sWzkzLDFdLFs5NCwxXV0sW1swLDFdXSxbWzgzLDFdXSxbWzgsMV0sWzAsM11dXSxcbns4OjEsODM6MSw4ODoxLDg5OjEsOTA6MSw5MToxLDkyOjEsOTM6MSw5NDoxfV0sMjc1OltbW1s5NSwxXV0sW1s5NiwwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyNzY6W1tbWzk3LDFdLFs5OCwxXSxbNTgsMV0sWzk5LDFdLFs1NywxXSxbMTAwLDFdLFs1NiwxXSxbMTAxLDFdLFsxMDIsMV1dLFtbMCwxXV1dLHs0OjEsMTA6MSwxMzoxLDIwOjEsMjE6MSwzNDoxLDM3OjEsNDE6MSw0MjoxfV0sMjc3OltbW1s0MCwxXV0sW1swLDFdXV0sezQwOjF9XSwyNzg6W1tbWzE3LDFdXSxbWzAsMV1dXSx7MTc6MX1dLDI3OTpbW1tbMTAzLDFdXSxbWzU2LDJdLFsxMDQsMl0sWzk5LDJdXSxbWzAsMl1dXSx7NDE6MX1dLDI4MDpbW1tbNDEsMV1dLFtbMTA1LDJdXSxbWzIsNF0sWzM1LDNdXSxbWzYxLDVdLFs4MSw2XV0sW1swLDRdXSxbWzIsNF1dLFtbNjEsNV1dXSx7NDE6MX1dLDI4MTpbW1tbMTA2LFxuMV1dLFtbMTA2LDFdLFswLDFdXV0sezQxOjF9XSwyODI6W1tbWzI3LDFdXSxbWzgyLDJdXSxbWzAsMl1dXSx7Mjc6MX1dLDI4MzpbW1tbNDksMV0sWzEwNywyXSxbNTMsM11dLFtbNDgsNF0sWzU0LDVdLFs1Miw2XSxbMCwxXV0sW1s1NCw1XSxbNTIsNl0sWzAsMl1dLFtbOTUsN11dLFtbNDksN11dLFtbMCw1XV0sW1s0OSw4XSxbMTA3LDhdLFswLDZdXSxbWzU0LDVdLFs1Miw5XSxbMCw3XV0sW1s1Miw2XSxbMCw4XV0sW1s0OSwxMF0sWzUzLDExXSxbMCw5XV0sW1s0OCwxMl1dLFtbOTUsMTNdXSxbWzQ5LDEzXV0sW1s1Miw5XSxbMCwxM11dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjEsNTM6MX1dLDI4NDpbW1tbMTA1LDFdXSxbWzEwOCwyXSxbMCwxXV0sW1syNSwzXV0sW1swLDNdXV0sezI1OjF9XSwyODU6W1tbWzEwOSwxXV0sW1s1MiwwXSxbMCwxXV1dLHsyNToxfV0sMjg2OltbW1syNSxcbjFdXSxbWzExMCwwXSxbMCwxXV1dLHsyNToxfV0sMjg3OltbW1syNSwxXV0sW1swLDFdXV0sezI1OjF9XSwyODg6W1tbWzExMSwxXV0sW1syLDFdLFsxMTIsMl1dLFtbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyODk6W1tbWzExMywxXV0sW1s0OSwyXSxbMCwxXV0sW1sxMDgsM10sWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzAsNF1dXSx7MTEzOjF9XSwyOTA6W1tbWzExNCwxXV0sW1sxMTUsMF0sWzAsMV1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMjkxOltbW1sxMTYsMV1dLFtbMTE3LDJdLFs1MCwzXSxbMTE4LDRdLFswLDFdXSxbWzExMSw0XSxbNjIsNF1dLFtbMTE2LDVdLFs2Miw1XV0sW1swLDRdXSxbWzUwLDNdLFswLDVdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSxcbjE1OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyOTI6W1tbWzk1LDFdLFsxMDcsMV1dLFtbNTIsMl0sWzAsMV1dLFtbOTUsMV0sWzEwNywxXSxbMCwyXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTU6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI5MzpbW1tbMTE5LDJdLFszMCwxXSxbMjIsMV0sWzQzLDFdXSxbWzEyMCwyXV0sW1swLDJdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI5NDpbW1tbMiwwXSxbMTEyLDFdLFsxMjEsMF1dLFtbMCwxXV1dLHsyOjEsNDoxLDU6MSw2OjEsNzoxLDg6MSw5OjEsMTA6MSwxMToxLDEyOjEsMTM6MSwxNDoxLDE1OjEsMTY6MSwxNzoxLDE4OjEsMTk6MSwyMDoxLDIxOjEsMjI6MSwyMzoxLDI0OjEsMjU6MSwyNjoxLDI3OjEsMjg6MSwyOToxLDMwOjEsMzE6MSwzMjoxLDMzOjEsXG4zNDoxLDM1OjEsMzY6MSwzNzoxLDM4OjEsMzk6MSw0MDoxLDQxOjEsNDI6MSw0MzoxLDExMjoxfV0sMjk1OltbW1sxMjIsMV0sWzEyMywxXSxbMTI0LDFdLFsxMjUsMV0sWzEyNiwxXV0sW1swLDFdXV0sezU6MSwyMzoxLDMxOjEsMzk6MSw0MDoxfV0sMjk2OltbW1szNCwxXV0sW1s4MiwyXV0sW1s4MywzXV0sW1sxMTEsNF1dLFtbNDgsNV1dLFtbODAsNl1dLFtbMTI3LDddLFswLDZdXSxbWzQ4LDhdXSxbWzgwLDldXSxbWzAsOV1dXSx7MzQ6MX1dLDI5NzpbW1tbNCwxXV0sW1syNSwyXV0sW1sxMjgsM11dLFtbNDgsNF0sWzEyOSw1XV0sW1s4MCw2XV0sW1s0OSw3XV0sW1swLDZdXSxbWzQ4LDRdXV0sezQ6MX1dLDI5ODpbW1tbMjYsMV1dLFtbMjUsMl1dLFtbNTIsMV0sWzAsMl1dXSx7MjY6MX1dLDI5OTpbW1tbMzcsMV1dLFtbNDksMl1dLFtbNDgsM11dLFtbODAsNF1dLFtbMTI3LDVdLFsxMzAsMV0sWzAsNF1dLFtbNDgsNl1dLFtbODAsN11dLFtbMCw3XV1dLHszNzoxfV0sMzAwOltbW1syNSxcbjFdXSxbWzEwOCwyXSxbMCwxXV0sW1syNSwzXV0sW1swLDNdXV0sezI1OjF9XSwzMDE6W1tbWzEzMSwxXV0sW1s1MiwyXSxbMCwxXV0sW1sxMzEsMV0sWzAsMl1dXSx7MjU6MX1dLDMwMjpbW1tbMzYsMV1dLFtbMTA1LDJdLFsxOSwzXSxbMTEwLDNdXSxbWzMyLDRdXSxbWzEwNSwyXSxbMTksM10sWzMyLDRdLFsxMTAsM11dLFtbMTMyLDVdLFsxNSw1XSxbMzUsNl1dLFtbMCw1XV0sW1sxMzIsN11dLFtbNjEsNV1dXSx7MzY6MX1dLDMwMzpbW1tbMzIsMV1dLFtbMTMzLDJdXSxbWzAsMl1dXSx7MzI6MX1dLDMwNDpbW1tbMTM0LDFdLFsxMzUsMV1dLFtbMCwxXV1dLHszMjoxLDM2OjF9XSwzMDU6W1tbWzE0LDFdXSxbWzQ4LDJdLFsxMzYsM11dLFtbNDksNF1dLFtbNDgsMl1dLFtbMCw0XV1dLHsxNDoxfV0sMzA2OltbW1sxNCwxXV0sW1s0OCwyXSxbMTM2LDNdXSxbWzg2LDRdXSxbWzQ4LDJdXSxbWzAsNF1dXSx7MTQ6MX1dLDMwNzpbW1tbMTgsMV1dLFtbMjUsMl1dLFtbNTIsMV0sWzAsMl1dXSxcbnsxODoxfV0sMzA4OltbW1s4LDFdLFsxMzcsMl1dLFtbNDYsMl1dLFtbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzA5OltbW1sxMzgsMV1dLFtbMTM5LDBdLFswLDFdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMTA6W1tbWzM1LDFdXSxbWzYxLDJdLFsxNDAsM11dLFtbMCwyXV0sW1s2MSwyXV1dLHszNToxfV0sMzExOltbW1syOCwxXV0sW1swLDFdXV0sezI4OjF9XSwzMTI6W1tbWzE0MSwxXV0sW1s1MywyXSxbMCwxXV0sW1sxMjAsM11dLFtbMCwzXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyNToxLDI5OjEsMzM6MSwzNToxLDM4OjF9XSwzMTM6W1tbWzE2LDFdXSxbWzQ5LDJdLFsxNDIsM10sWzAsMV1dLFtbNTIsNF0sWzAsMl1dLFtbNDksNV1dLFtbNDksMl0sWzAsNF1dLFxuW1s1Miw2XSxbMCw1XV0sW1s0OSw3XV0sW1s1Miw4XSxbMCw3XV0sW1s0OSw3XSxbMCw4XV1dLHsxNjoxfV0sMzE0OltbW1s1LDFdXSxbWzQ5LDJdLFswLDFdXSxbWzM2LDNdLFs1MiwzXSxbMCwyXV0sW1s0OSw0XV0sW1s1Miw1XSxbMCw0XV0sW1s0OSw2XV0sW1swLDZdXV0sezU6MX1dLDMxNTpbW1tbMjMsMV1dLFtbMTExLDJdLFswLDFdXSxbWzAsMl1dXSx7MjM6MX1dLDMxNjpbW1tbMTQzLDFdXSxbWzE0NCwwXSxbMTQyLDBdLFswLDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMxNzpbW1tbMTQ1LDFdXSxbWzIsMl0sWzE0NiwzXV0sW1swLDJdXSxbWzE0NSwxXSxbMiwyXV1dLHs1OjEsNjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTY6MSwxNzoxLDE4OjEsMTk6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNToxLFxuMzY6MSwzODoxLDM5OjEsNDA6MSw0MzoxfV0sMzE4OltbW1s0OCwxXV0sW1s0OSwyXSxbMCwxXV0sW1swLDJdXV0sezQ4OjF9XSwzMTk6W1tbWzE0NywxXSxbMTQ4LDFdLFsxNDksMV0sWzE1MCwxXSxbMTUxLDFdLFsxNTIsMV0sWzE1MywxXSxbMTU0LDFdLFsxNTUsMV0sWzE1NiwxXV0sW1swLDFdXV0sezU6MSw2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTU6MSwxNjoxLDE3OjEsMTg6MSwxOToxLDIyOjEsMjM6MSwyNDoxLDI1OjEsMjY6MSwyNzoxLDI4OjEsMjk6MSwzMDoxLDMxOjEsMzI6MSwzMzoxLDM1OjEsMzY6MSwzODoxLDM5OjEsNDA6MSw0MzoxfV0sMzIwOltbW1sxNSwxXV0sW1s5NSwyXV0sW1swLDJdXV0sezE1OjF9XSwzMjE6W1tbWzEsMV0sWzMsMV1dLFtbMCwxXV1dLHs0OjEsNToxLDY6MSw3OjEsODoxLDk6MSwxMDoxLDExOjEsMTI6MSwxMzoxLDE0OjEsMTU6MSwxNjoxLDE3OjEsMTg6MSwxOToxLDIwOjEsMjE6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsXG4yNzoxLDI4OjEsMjk6MSwzMDoxLDMxOjEsMzI6MSwzMzoxLDM0OjEsMzU6MSwzNjoxLDM3OjEsMzg6MSwzOToxLDQwOjEsNDE6MSw0MjoxLDQzOjF9XSwzMjI6W1tbWzQ5LDFdLFs0OCwyXV0sW1s0OCwyXSxbMCwxXV0sW1s0OSwzXSxbMTU3LDRdLFswLDJdXSxbWzE1Nyw0XSxbMCwzXV0sW1swLDRdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MSw0ODoxfV0sMzIzOltbW1sxNTgsMV1dLFtbNTIsMl0sWzAsMV1dLFtbMTU4LDFdLFswLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MSw0ODoxfV0sMzI0OltbW1sxLDFdLFsyLDJdXSxbWzAsMV1dLFtbMTU5LDNdXSxbWzEyMSw0XV0sW1sxNjAsMV0sWzEyMSw0XV1dLHsyOjEsNToxLDY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE2OjEsXG4xNzoxLDE4OjEsMTk6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNToxLDM2OjEsMzg6MSwzOToxLDQwOjEsNDM6MX1dLDMyNTpbW1tbMTIwLDFdXSxbWzE2MSwwXSxbMTUsMF0sWzE2MiwwXSxbNDEsMF0sWzE2MywwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMjY6W1tbWzg0LDFdLFsxNjQsMl1dLFtbMzcsM10sWzAsMV1dLFtbMCwyXV0sW1s4NCw0XV0sW1sxMjcsNV1dLFtbNDksMl1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzI3OltbW1sxNjUsMV0sWzg0LDFdXSxbWzAsMV1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sXG4zMjg6W1tbWzQ5LDFdXSxbWzUyLDJdLFswLDFdXSxbWzQ5LDFdLFswLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMyOTpbW1tbNDksMV0sWzEwNywxXV0sW1s1NCwyXSxbNTIsM10sWzAsMV1dLFtbMCwyXV0sW1s0OSw0XSxbMTA3LDRdLFswLDNdXSxbWzUyLDNdLFswLDRdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzMwOltbW1s0OSwxXSxbMTA3LDFdXSxbWzUyLDJdLFswLDFdXSxbWzQ5LDFdLFsxMDcsMV0sWzAsMl1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMzE6W1tbWzI1LDFdXSxbWzQ4LDJdLFswLDFdXSxbWzQ5LDNdXSxbWzAsM11dXSx7MjU6MX1dLFxuMzMyOltbW1szNSwxXSxbMTEwLDJdLFszOCwzXV0sW1s2MSw0XSxbODEsNV1dLFtbMjUsNF1dLFtbMTY2LDZdXSxbWzAsNF1dLFtbNjEsNF1dLFtbNjQsNF1dXSx7MzU6MSwzODoxLDExMDoxfV0sMzMzOltbW1syMCwxXV0sW1s0OCwyXV0sW1s4MCwzXV0sW1sxNjcsNF0sWzE2OCw1XV0sW1s0OCw2XV0sW1s0OCw3XV0sW1s4MCw4XV0sW1s4MCw5XV0sW1sxNjcsNF0sWzEyNywxMF0sWzE2OCw1XSxbMCw4XV0sW1swLDldXSxbWzQ4LDExXV0sW1s4MCwxMl1dLFtbMTY4LDVdLFswLDEyXV1dLHsyMDoxfV0sMzM0OltbW1sxNSwxXSxbMTY5LDJdLFs1MywzXV0sW1sxNjksNF0sWzUyLDVdLFswLDFdXSxbWzUwLDZdLFs1Miw3XSxbMCwyXV0sW1sxNjksOF1dLFtbNTIsNV0sWzAsNF1dLFtbMTY5LDldLFs1MywzXSxbMCw1XV0sW1s0OSwxMF1dLFtbMTUsMTFdLFsxNjksMl0sWzUzLDNdLFswLDddXSxbWzUyLDEyXSxbMCw4XV0sW1s1MCwxM10sWzUyLDVdLFswLDldXSxbWzUyLDddLFswLDEwXV0sXG5bWzE2OSwxNF0sWzUyLDE1XSxbMCwxMV1dLFtbMCwxMl1dLFtbNDksNF1dLFtbNTIsMTVdLFswLDE0XV0sW1sxNjksMTZdLFs1MywzXSxbMCwxNV1dLFtbNTAsMTddLFs1MiwxNV0sWzAsMTZdXSxbWzQ5LDE0XV1dLHsxNToxLDI1OjEsNTM6MX1dLDMzNTpbW1tbMTUsMV0sWzUzLDJdLFsxNzAsM11dLFtbMTcwLDVdLFs1Miw0XSxbMCwxXV0sW1sxNzAsNl1dLFtbNTAsN10sWzUyLDhdLFswLDNdXSxbWzUzLDJdLFsxNzAsOV0sWzAsNF1dLFtbNTIsNF0sWzAsNV1dLFtbNTIsMTBdLFswLDZdXSxbWzQ5LDExXV0sW1sxNSwxMl0sWzUzLDJdLFsxNzAsM10sWzAsOF1dLFtbNTAsMTNdLFs1Miw0XSxbMCw5XV0sW1swLDEwXV0sW1s1Miw4XSxbMCwxMV1dLFtbNTIsMTVdLFsxNzAsMTRdLFswLDEyXV0sW1s0OSw1XV0sW1s1MiwxNV0sWzAsMTRdXSxbWzUzLDJdLFsxNzAsMTZdLFswLDE1XV0sW1s1MCwxN10sWzUyLDE1XSxbMCwxNl1dLFtbNDksMTRdXV0sezE1OjEsMjU6MSw1MzoxfV0sMzM2OltbW1syNSxcbjFdXSxbWzAsMV1dXSx7MjU6MX1dLDMzNzpbW1tbMjEsMV1dLFtbNDksMl1dLFtbNDgsM11dLFtbODAsNF1dLFtbMTI3LDVdLFswLDRdXSxbWzQ4LDZdXSxbWzgwLDddXSxbWzAsN11dXSx7MjE6MX1dLDMzODpbW1tbNDksMV1dLFtbMTA4LDJdLFswLDFdXSxbWzk1LDNdXSxbWzAsM11dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzM5OltbW1s0MiwxXV0sW1sxNzEsMl1dLFtbNDgsM10sWzUyLDFdXSxbWzgwLDRdXSxbWzAsNF1dXSx7NDI6MX1dLDM0MDpbW1tbMTcyLDFdXSxbWzE3MywwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzNDE6W1tbWzExMSwyXSxbMzYsMV1dLFtbNDksMl1dLFtbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSxcbjMwOjEsMzM6MSwzNToxLDM2OjEsMzg6MSw0MzoxfV0sMzQyOltbW1szMSwxXV0sW1sxNzQsMl0sWzAsMV1dLFtbMCwyXV1dLHszMToxfV0sMzQzOltbW1s2MiwxXV0sW1swLDFdXV0sezMxOjF9XX0sc3RhdGVzOltbW1sxLDFdLFsyLDFdLFszLDJdXSxbWzAsMV1dLFtbMiwxXV1dLFtbWzQ0LDFdXSxbWzQ1LDBdLFswLDFdXV0sW1tbNDYsMV1dLFtbNDcsMF0sWzAsMV1dXSxbW1s0OCwxXV0sW1s0OSwyXV0sW1s1MCwzXSxbMCwyXV0sW1s0OSw0XV0sW1swLDRdXV0sW1tbNTEsMV1dLFtbNTIsMl0sWzAsMV1dLFtbNTEsMV0sWzAsMl1dXSxbW1s0OSwxXSxbMTUsMl0sWzUzLDJdXSxbWzUwLDJdLFs1NCwzXSxbMCwxXV0sW1s0OSwzXV0sW1swLDNdXV0sW1tbNTUsMV1dLFtbMzAsMF0sWzQzLDBdLFswLDFdXV0sW1tbMjQsMV1dLFtbNDksMl1dLFtbNTIsM10sWzAsMl1dLFtbNDksNF1dLFtbMCw0XV1dLFtbWzEwLDFdXSxbWzU2LDJdXSxbWzAsMl1dXSxbW1sxMCwxXV0sW1s1NywyXSxbNTYsXG4yXSxbNTgsMl1dLFtbMCwyXV1dLFtbWzYsMV0sWzI1LDFdLFszMywxXSxbOSwxXSxbMTEsMV0sWzEyLDJdLFszNSwzXSxbMzgsNF0sWzE5LDFdLFs3LDVdXSxbWzAsMV1dLFtbNTksMV0sWzYwLDZdXSxbWzYxLDFdLFs2Miw3XSxbNjMsN11dLFtbNjQsMV0sWzYzLDhdXSxbWzcsNV0sWzAsNV1dLFtbNTksMV1dLFtbNjEsMV1dLFtbNjQsMV1dXSxbW1syOSwxXSxbNjUsMl1dLFtbNjUsMl1dLFtbNjYsMl0sWzAsMl1dXSxbW1s2NywxXSxbNjgsMV0sWzY5LDFdLFs3MCwxXSxbNzEsMV0sWzcyLDFdLFs3MywxXSxbNzQsMV0sWzc1LDFdLFs3NiwxXSxbNzcsMV0sWzc4LDFdLFs3OSwxXV0sW1swLDFdXV0sW1tbMzksMV1dLFtbMCwxXV1dLFtbWzEzLDFdXSxbWzI1LDJdXSxbWzQ4LDNdLFszNSw0XV0sW1s4MCw1XV0sW1s2MSw2XSxbODEsN11dLFtbMCw1XV0sW1s0OCwzXV0sW1s2MSw2XV1dLFtbWzEwLDFdLFszNCwyXV0sW1szNCwyXV0sW1s4MiwzXV0sW1s4Myw0XV0sW1s4NCw1XV0sW1s4NSxcbjZdLFswLDVdXSxbWzAsNl1dXSxbW1szNywxXV0sW1s4NiwyXV0sW1s4NSwzXSxbMCwyXV0sW1swLDNdXV0sW1tbODcsMV0sWzU0LDFdXSxbWzAsMV1dXSxbW1s4OCwxXSxbODksMV0sWzgsMl0sWzkwLDFdLFs4OCwxXSxbODMsMV0sWzkxLDFdLFs5MiwzXSxbOTMsMV0sWzk0LDFdXSxbWzAsMV1dLFtbODMsMV1dLFtbOCwxXSxbMCwzXV1dLFtbWzk1LDFdXSxbWzk2LDBdLFswLDFdXV0sW1tbOTcsMV0sWzk4LDFdLFs1OCwxXSxbOTksMV0sWzU3LDFdLFsxMDAsMV0sWzU2LDFdLFsxMDEsMV0sWzEwMiwxXV0sW1swLDFdXV0sW1tbNDAsMV1dLFtbMCwxXV1dLFtbWzE3LDFdXSxbWzAsMV1dXSxbW1sxMDMsMV1dLFtbNTYsMl0sWzEwNCwyXSxbOTksMl1dLFtbMCwyXV1dLFtbWzQxLDFdXSxbWzEwNSwyXV0sW1syLDRdLFszNSwzXV0sW1s2MSw1XSxbODEsNl1dLFtbMCw0XV0sW1syLDRdXSxbWzYxLDVdXV0sW1tbMTA2LDFdXSxbWzEwNiwxXSxbMCwxXV1dLFtbWzI3LDFdXSxbWzgyLDJdXSxcbltbMCwyXV1dLFtbWzQ5LDFdLFsxMDcsMl0sWzUzLDNdXSxbWzQ4LDRdLFs1NCw1XSxbNTIsNl0sWzAsMV1dLFtbNTQsNV0sWzUyLDZdLFswLDJdXSxbWzk1LDddXSxbWzQ5LDddXSxbWzAsNV1dLFtbNDksOF0sWzEwNyw4XSxbMCw2XV0sW1s1NCw1XSxbNTIsOV0sWzAsN11dLFtbNTIsNl0sWzAsOF1dLFtbNDksMTBdLFs1MywxMV0sWzAsOV1dLFtbNDgsMTJdXSxbWzk1LDEzXV0sW1s0OSwxM11dLFtbNTIsOV0sWzAsMTNdXV0sW1tbMTA1LDFdXSxbWzEwOCwyXSxbMCwxXV0sW1syNSwzXV0sW1swLDNdXV0sW1tbMTA5LDFdXSxbWzUyLDBdLFswLDFdXV0sW1tbMjUsMV1dLFtbMTEwLDBdLFswLDFdXV0sW1tbMjUsMV1dLFtbMCwxXV1dLFtbWzExMSwxXV0sW1syLDFdLFsxMTIsMl1dLFtbMCwyXV1dLFtbWzExMywxXV0sW1s0OSwyXSxbMCwxXV0sW1sxMDgsM10sWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzAsNF1dXSxbW1sxMTQsMV1dLFtbMTE1LDBdLFswLDFdXV0sW1tbMTE2LDFdXSxcbltbMTE3LDJdLFs1MCwzXSxbMTE4LDRdLFswLDFdXSxbWzExMSw0XSxbNjIsNF1dLFtbMTE2LDVdLFs2Miw1XV0sW1swLDRdXSxbWzUwLDNdLFswLDVdXV0sW1tbOTUsMV0sWzEwNywxXV0sW1s1MiwyXSxbMCwxXV0sW1s5NSwxXSxbMTA3LDFdLFswLDJdXV0sW1tbMTE5LDJdLFszMCwxXSxbMjIsMV0sWzQzLDFdXSxbWzEyMCwyXV0sW1swLDJdXV0sW1tbMiwwXSxbMTEyLDFdLFsxMjEsMF1dLFtbMCwxXV1dLFtbWzEyMiwxXSxbMTIzLDFdLFsxMjQsMV0sWzEyNSwxXSxbMTI2LDFdXSxbWzAsMV1dXSxbW1szNCwxXV0sW1s4MiwyXV0sW1s4MywzXV0sW1sxMTEsNF1dLFtbNDgsNV1dLFtbODAsNl1dLFtbMTI3LDddLFswLDZdXSxbWzQ4LDhdXSxbWzgwLDldXSxbWzAsOV1dXSxbW1s0LDFdXSxbWzI1LDJdXSxbWzEyOCwzXV0sW1s0OCw0XSxbMTI5LDVdXSxbWzgwLDZdXSxbWzQ5LDddXSxbWzAsNl1dLFtbNDgsNF1dXSxbW1syNiwxXV0sW1syNSwyXV0sW1s1MiwxXSxbMCwyXV1dLFtbWzM3LFxuMV1dLFtbNDksMl1dLFtbNDgsM11dLFtbODAsNF1dLFtbMTI3LDVdLFsxMzAsMV0sWzAsNF1dLFtbNDgsNl1dLFtbODAsN11dLFtbMCw3XV1dLFtbWzI1LDFdXSxbWzEwOCwyXSxbMCwxXV0sW1syNSwzXV0sW1swLDNdXV0sW1tbMTMxLDFdXSxbWzUyLDJdLFswLDFdXSxbWzEzMSwxXSxbMCwyXV1dLFtbWzM2LDFdXSxbWzEwNSwyXSxbMTksM10sWzExMCwzXV0sW1szMiw0XV0sW1sxMDUsMl0sWzE5LDNdLFszMiw0XSxbMTEwLDNdXSxbWzEzMiw1XSxbMTUsNV0sWzM1LDZdXSxbWzAsNV1dLFtbMTMyLDddXSxbWzYxLDVdXV0sW1tbMzIsMV1dLFtbMTMzLDJdXSxbWzAsMl1dXSxbW1sxMzQsMV0sWzEzNSwxXV0sW1swLDFdXV0sW1tbMTQsMV1dLFtbNDgsMl0sWzEzNiwzXV0sW1s0OSw0XV0sW1s0OCwyXV0sW1swLDRdXV0sW1tbMTQsMV1dLFtbNDgsMl0sWzEzNiwzXV0sW1s4Niw0XV0sW1s0OCwyXV0sW1swLDRdXV0sW1tbMTgsMV1dLFtbMjUsMl1dLFtbNTIsMV0sWzAsMl1dXSxbW1s4LFxuMV0sWzEzNywyXV0sW1s0NiwyXV0sW1swLDJdXV0sW1tbMTM4LDFdXSxbWzEzOSwwXSxbMCwxXV1dLFtbWzM1LDFdXSxbWzYxLDJdLFsxNDAsM11dLFtbMCwyXV0sW1s2MSwyXV1dLFtbWzI4LDFdXSxbWzAsMV1dXSxbW1sxNDEsMV1dLFtbNTMsMl0sWzAsMV1dLFtbMTIwLDNdXSxbWzAsM11dXSxbW1sxNiwxXV0sW1s0OSwyXSxbMTQyLDNdLFswLDFdXSxbWzUyLDRdLFswLDJdXSxbWzQ5LDVdXSxbWzQ5LDJdLFswLDRdXSxbWzUyLDZdLFswLDVdXSxbWzQ5LDddXSxbWzUyLDhdLFswLDddXSxbWzQ5LDddLFswLDhdXV0sW1tbNSwxXV0sW1s0OSwyXSxbMCwxXV0sW1szNiwzXSxbNTIsM10sWzAsMl1dLFtbNDksNF1dLFtbNTIsNV0sWzAsNF1dLFtbNDksNl1dLFtbMCw2XV1dLFtbWzIzLDFdXSxbWzExMSwyXSxbMCwxXV0sW1swLDJdXV0sW1tbMTQzLDFdXSxbWzE0NCwwXSxbMTQyLDBdLFswLDFdXV0sW1tbMTQ1LDFdXSxbWzIsMl0sWzE0NiwzXV0sW1swLDJdXSxbWzE0NSwxXSxbMiwyXV1dLFxuW1tbNDgsMV1dLFtbNDksMl0sWzAsMV1dLFtbMCwyXV1dLFtbWzE0NywxXSxbMTQ4LDFdLFsxNDksMV0sWzE1MCwxXSxbMTUxLDFdLFsxNTIsMV0sWzE1MywxXSxbMTU0LDFdLFsxNTUsMV0sWzE1NiwxXV0sW1swLDFdXV0sW1tbMTUsMV1dLFtbOTUsMl1dLFtbMCwyXV1dLFtbWzEsMV0sWzMsMV1dLFtbMCwxXV1dLFtbWzQ5LDFdLFs0OCwyXV0sW1s0OCwyXSxbMCwxXV0sW1s0OSwzXSxbMTU3LDRdLFswLDJdXSxbWzE1Nyw0XSxbMCwzXV0sW1swLDRdXV0sW1tbMTU4LDFdXSxbWzUyLDJdLFswLDFdXSxbWzE1OCwxXSxbMCwyXV1dLFtbWzEsMV0sWzIsMl1dLFtbMCwxXV0sW1sxNTksM11dLFtbMTIxLDRdXSxbWzE2MCwxXSxbMTIxLDRdXV0sW1tbMTIwLDFdXSxbWzE2MSwwXSxbMTUsMF0sWzE2MiwwXSxbNDEsMF0sWzE2MywwXSxbMCwxXV1dLFtbWzg0LDFdLFsxNjQsMl1dLFtbMzcsM10sWzAsMV1dLFtbMCwyXV0sW1s4NCw0XV0sW1sxMjcsNV1dLFtbNDksMl1dXSxbW1sxNjUsMV0sXG5bODQsMV1dLFtbMCwxXV1dLFtbWzQ5LDFdXSxbWzUyLDJdLFswLDFdXSxbWzQ5LDFdLFswLDJdXV0sW1tbNDksMV0sWzEwNywxXV0sW1s1NCwyXSxbNTIsM10sWzAsMV1dLFtbMCwyXV0sW1s0OSw0XSxbMTA3LDRdLFswLDNdXSxbWzUyLDNdLFswLDRdXV0sW1tbNDksMV0sWzEwNywxXV0sW1s1MiwyXSxbMCwxXV0sW1s0OSwxXSxbMTA3LDFdLFswLDJdXV0sW1tbMjUsMV1dLFtbNDgsMl0sWzAsMV1dLFtbNDksM11dLFtbMCwzXV1dLFtbWzM1LDFdLFsxMTAsMl0sWzM4LDNdXSxbWzYxLDRdLFs4MSw1XV0sW1syNSw0XV0sW1sxNjYsNl1dLFtbMCw0XV0sW1s2MSw0XV0sW1s2NCw0XV1dLFtbWzIwLDFdXSxbWzQ4LDJdXSxbWzgwLDNdXSxbWzE2Nyw0XSxbMTY4LDVdXSxbWzQ4LDZdXSxbWzQ4LDddXSxbWzgwLDhdXSxbWzgwLDldXSxbWzE2Nyw0XSxbMTI3LDEwXSxbMTY4LDVdLFswLDhdXSxbWzAsOV1dLFtbNDgsMTFdXSxbWzgwLDEyXV0sW1sxNjgsNV0sWzAsMTJdXV0sW1tbMTUsMV0sXG5bMTY5LDJdLFs1MywzXV0sW1sxNjksNF0sWzUyLDVdLFswLDFdXSxbWzUwLDZdLFs1Miw3XSxbMCwyXV0sW1sxNjksOF1dLFtbNTIsNV0sWzAsNF1dLFtbMTY5LDldLFs1MywzXSxbMCw1XV0sW1s0OSwxMF1dLFtbMTUsMTFdLFsxNjksMl0sWzUzLDNdLFswLDddXSxbWzUyLDEyXSxbMCw4XV0sW1s1MCwxM10sWzUyLDVdLFswLDldXSxbWzUyLDddLFswLDEwXV0sW1sxNjksMTRdLFs1MiwxNV0sWzAsMTFdXSxbWzAsMTJdXSxbWzQ5LDRdXSxbWzUyLDE1XSxbMCwxNF1dLFtbMTY5LDE2XSxbNTMsM10sWzAsMTVdXSxbWzUwLDE3XSxbNTIsMTVdLFswLDE2XV0sW1s0OSwxNF1dXSxbW1sxNSwxXSxbNTMsMl0sWzE3MCwzXV0sW1sxNzAsNV0sWzUyLDRdLFswLDFdXSxbWzE3MCw2XV0sW1s1MCw3XSxbNTIsOF0sWzAsM11dLFtbNTMsMl0sWzE3MCw5XSxbMCw0XV0sW1s1Miw0XSxbMCw1XV0sW1s1MiwxMF0sWzAsNl1dLFtbNDksMTFdXSxbWzE1LDEyXSxbNTMsMl0sWzE3MCwzXSxbMCw4XV0sXG5bWzUwLDEzXSxbNTIsNF0sWzAsOV1dLFtbMCwxMF1dLFtbNTIsOF0sWzAsMTFdXSxbWzUyLDE1XSxbMTcwLDE0XSxbMCwxMl1dLFtbNDksNV1dLFtbNTIsMTVdLFswLDE0XV0sW1s1MywyXSxbMTcwLDE2XSxbMCwxNV1dLFtbNTAsMTddLFs1MiwxNV0sWzAsMTZdXSxbWzQ5LDE0XV1dLFtbWzI1LDFdXSxbWzAsMV1dXSxbW1syMSwxXV0sW1s0OSwyXV0sW1s0OCwzXV0sW1s4MCw0XV0sW1sxMjcsNV0sWzAsNF1dLFtbNDgsNl1dLFtbODAsN11dLFtbMCw3XV1dLFtbWzQ5LDFdXSxbWzEwOCwyXSxbMCwxXV0sW1s5NSwzXV0sW1swLDNdXV0sW1tbNDIsMV1dLFtbMTcxLDJdXSxbWzQ4LDNdLFs1MiwxXV0sW1s4MCw0XV0sW1swLDRdXV0sW1tbMTcyLDFdXSxbWzE3MywwXSxbMCwxXV1dLFtbWzExMSwyXSxbMzYsMV1dLFtbNDksMl1dLFtbMCwyXV1dLFtbWzMxLDFdXSxbWzE3NCwyXSxbMCwxXV0sW1swLDJdXV0sW1tbNjIsMV1dLFtbMCwxXV1dXSxsYWJlbHM6W1swLFwiRU1QVFlcIl0sWzMxNyxcbm51bGxdLFs0LG51bGxdLFsyNzYsbnVsbF0sWzEsXCJkZWZcIl0sWzEsXCJyYWlzZVwiXSxbMSxcIlRydWVcIl0sWzMsbnVsbF0sWzEsXCJub3RcIl0sWzEsXCJudWxsXCJdLFs1NSxudWxsXSxbMixudWxsXSxbMjUsbnVsbF0sWzEsXCJjbGFzc1wiXSxbMSxcImxhbWJkYVwiXSxbMTYsbnVsbF0sWzEsXCJwcmludFwiXSxbMSxcImRlYnVnZ2VyXCJdLFsxLFwibm9ubG9jYWxcIl0sWzUyLG51bGxdLFsxLFwidHJ5XCJdLFsxLFwid2hpbGVcIl0sWzMxLG51bGxdLFsxLFwicmV0dXJuXCJdLFsxLFwiYXNzZXJ0XCJdLFsxLG51bGxdLFsxLFwiZ2xvYmFsXCJdLFsxLFwiZGVsXCJdLFsxLFwicGFzc1wiXSxbNTQsbnVsbF0sWzE1LG51bGxdLFsxLFwieWllbGRcIl0sWzEsXCJpbXBvcnRcIl0sWzEsXCJGYWxzZVwiXSxbMSxcImZvclwiXSxbNyxudWxsXSxbMSxcImZyb21cIl0sWzEsXCJpZlwiXSxbOSxudWxsXSxbMSxcImJyZWFrXCJdLFsxLFwiY29udGludWVcIl0sWzQ5LG51bGxdLFsxLFwid2l0aFwiXSxbMTQsbnVsbF0sWzMxNixudWxsXSxbMTksbnVsbF0sWzMwOCxudWxsXSxcblsxLFwiYW5kXCJdLFsxMSxudWxsXSxbMzI2LG51bGxdLFsyMixudWxsXSxbMjYxLG51bGxdLFsxMixudWxsXSxbMzUsbnVsbF0sWzI3MSxudWxsXSxbMzI1LG51bGxdLFsyOTcsbnVsbF0sWzMzOSxudWxsXSxbMjk2LG51bGxdLFsyNixudWxsXSxbMjgzLG51bGxdLFs4LG51bGxdLFszNDIsbnVsbF0sWzMyOSxudWxsXSxbMTAsbnVsbF0sWzI2NixudWxsXSxbMzMyLG51bGxdLFs0NSxudWxsXSxbMzgsbnVsbF0sWzQwLG51bGxdLFs1MCxudWxsXSxbNDYsbnVsbF0sWzQxLG51bGxdLFs0MixudWxsXSxbMzYsbnVsbF0sWzQzLG51bGxdLFs0OCxudWxsXSxbNDQsbnVsbF0sWzM3LG51bGxdLFszOSxudWxsXSxbMzI0LG51bGxdLFsyNjAsbnVsbF0sWzI5MixudWxsXSxbMSxcImluXCJdLFszMDksbnVsbF0sWzI3MyxudWxsXSxbMzI3LG51bGxdLFsyNzIsbnVsbF0sWzI4LG51bGxdLFsyMSxudWxsXSxbMjcsbnVsbF0sWzI5LG51bGxdLFsxLFwiaXNcIl0sWzMwLG51bGxdLFsyMCxudWxsXSxbMjkwLFxubnVsbF0sWzI3NCxudWxsXSxbMzMzLG51bGxdLFsyOTksbnVsbF0sWzI3MCxudWxsXSxbMzM3LG51bGxdLFsyNzksbnVsbF0sWzI2NSxudWxsXSxbMjgxLG51bGxdLFsyNjQsbnVsbF0sWzI4NixudWxsXSxbMjgwLG51bGxdLFszMjAsbnVsbF0sWzEsXCJhc1wiXSxbMjg0LG51bGxdLFsyMyxudWxsXSxbMzI4LG51bGxdLFswLG51bGxdLFsxLFwiZXhjZXB0XCJdLFszNDAsbnVsbF0sWzE4LG51bGxdLFszMzAsbnVsbF0sWzI2OCxudWxsXSxbMjU5LG51bGxdLFszMTIsbnVsbF0sWzI5MyxudWxsXSxbMzIxLG51bGxdLFsyNjksbnVsbF0sWzI3NyxudWxsXSxbMzE0LG51bGxdLFszMTUsbnVsbF0sWzM0MyxudWxsXSxbMSxcImVsc2VcIl0sWzMxMCxudWxsXSxbNTEsbnVsbF0sWzEsXCJlbGlmXCJdLFszMDAsbnVsbF0sWzMwMSxudWxsXSxbMjg1LG51bGxdLFszMDMsbnVsbF0sWzMwMixudWxsXSxbMzM1LG51bGxdLFsyNzUsbnVsbF0sWzI1OCxudWxsXSxbMSxcIm9yXCJdLFszMzQsbnVsbF0sWzI2NyxudWxsXSxcblszNCxudWxsXSxbMjYyLG51bGxdLFszMyxudWxsXSxbMzE5LG51bGxdLFsxMyxudWxsXSxbMjk1LG51bGxdLFsyNjMsbnVsbF0sWzI5MSxudWxsXSxbMzExLG51bGxdLFszMDcsbnVsbF0sWzMxMyxudWxsXSxbMjgyLG51bGxdLFsyOTgsbnVsbF0sWzMwNCxudWxsXSxbMjc4LG51bGxdLFszMTgsbnVsbF0sWzMyMixudWxsXSxbNSxudWxsXSxbNixudWxsXSxbNDcsbnVsbF0sWzE3LG51bGxdLFsyNCxudWxsXSxbMzA1LG51bGxdLFszMDYsbnVsbF0sWzMyMyxudWxsXSxbMjg5LG51bGxdLFsxLFwiZmluYWxseVwiXSxbMzMxLG51bGxdLFszMzYsbnVsbF0sWzMzOCxudWxsXSxbMjU3LG51bGxdLFszMixudWxsXSxbMzQxLG51bGxdXSxrZXl3b3Jkczp7RmFsc2U6MzMsXCJudWxsXCI6OSxUcnVlOjYsYW5kOjQ3LGFzOjEwOCxhc3NlcnQ6MjQsXCJicmVha1wiOjM5LFwiY2xhc3NcIjoxMyxcImNvbnRpbnVlXCI6NDAsXCJkZWJ1Z2dlclwiOjE3LGRlZjo0LGRlbDoyNyxlbGlmOjEzMCxcImVsc2VcIjoxMjcsZXhjZXB0OjExMyxcblwiZmluYWxseVwiOjE2OCxcImZvclwiOjM0LGZyb206MzYsZ2xvYmFsOjI2LFwiaWZcIjozNyxcImltcG9ydFwiOjMyLFwiaW5cIjo4Myxpczo5MixsYW1iZGE6MTQsbm9ubG9jYWw6MTgsbm90Ojgsb3I6MTM5LHBhc3M6MjgscHJpbnQ6MTYscmFpc2U6NSxcInJldHVyblwiOjIzLFwidHJ5XCI6MjAsXCJ3aGlsZVwiOjIxLFwid2l0aFwiOjQyLHlpZWxkOjMxfSx0b2tlbnM6ezA6MTEyLDE6MjUsMjoxMSwzOjcsNDoyLDU6MTU5LDY6MTYwLDc6MzUsODo2MSw5OjM4LDEwOjY0LDExOjQ4LDEyOjUyLDEzOjE0NiwxNDo0MywxNTozMCwxNjoxNSwxNzoxNjIsMTg6MTE1LDE5OjQ1LDIwOjk0LDIxOjg5LDIyOjUwLDIzOjExMCwyNDoxNjMsMjU6MTIsMjY6NTksMjc6OTAsMjg6ODgsMjk6OTEsMzA6OTMsMzE6MjIsMzI6MTczLDMzOjE0NCwzNDoxNDIsMzU6NTMsMzY6NzQsMzc6NzgsMzg6NjgsMzk6NzksNDA6NjksNDE6NzIsNDI6NzMsNDM6NzUsNDQ6NzcsNDU6NjcsNDY6NzEsNDc6MTYxLDQ4Ojc2LDQ5OjQxLDUwOjcwLFxuNTE6MTI5LDUyOjE5LDU0OjI5LDU1OjEwfSxzdGFydDoyNTZ9fSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoZSxnKXt0aGlzLmZpbGVuYW1lPWU7dGhpcy5ncmFtbWFyPWc7dGhpcy5wX2ZsYWdzPTA7cmV0dXJuIHRoaXN9ZnVuY3Rpb24gZihlLGcpe3ZvaWQgMD09PWcmJihnPVwiZmlsZV9pbnB1dFwiKTtlPW5ldyBiKGUsU2suUGFyc2VUYWJsZXMpO1wiZmlsZV9pbnB1dFwiPT09Zz9lLnNldHVwKFNrLlBhcnNlVGFibGVzLnN5bS5maWxlX2lucHV0KTpTay5hc3NlcnRzLmZhaWwoXCJ0b2RvO1wiKTtyZXR1cm4gZX1iLkZVVFVSRV9QUklOVF9GVU5DVElPTj1cInByaW50X2Z1bmN0aW9uXCI7Yi5GVVRVUkVfVU5JQ09ERV9MSVRFUkFMUz1cInVuaWNvZGVfbGl0ZXJhbHNcIjtiLkZVVFVSRV9ESVZJU0lPTj1cImRpdmlzaW9uXCI7Yi5GVVRVUkVfQUJTT0xVVEVfSU1QT1JUPVwiYWJzb2x1dGVfaW1wb3J0XCI7Yi5GVVRVUkVfV0lUSF9TVEFURU1FTlQ9XCJ3aXRoX3N0YXRlbWVudFwiO2IuRlVUVVJFX05FU1RFRF9TQ09QRVM9XG5cIm5lc3RlZF9zY29wZXNcIjtiLkZVVFVSRV9HRU5FUkFUT1JTPVwiZ2VuZXJhdG9yc1wiO2IuQ09fRlVUVVJFX1BSSU5UX0ZVTkNUSU9OPTY1NTM2O2IuQ09fRlVUVVJFX1VOSUNPREVfTElURVJBTFM9MTMxMDcyO2IuQ09fRlVUVVJFX0RJVklTT049ODE5MjtiLkNPX0ZVVFVSRV9BQlNPTFVURV9JTVBPUlQ9MTYzODQ7Yi5DT19GVVRVUkVfV0lUSF9TVEFURU1FTlQ9MzI3Njg7Yi5wcm90b3R5cGUuc2V0dXA9ZnVuY3Rpb24oZSl7ZT1lfHx0aGlzLmdyYW1tYXIuc3RhcnQ7dGhpcy5zdGFjaz1be2RmYTp0aGlzLmdyYW1tYXIuZGZhc1tlXSxzdGF0ZTowLG5vZGU6e3R5cGU6ZSx2YWx1ZTpudWxsLGNvbnRleHQ6bnVsbCxjaGlsZHJlbjpbXX19XTt0aGlzLnVzZWRfbmFtZXM9e319O2IucHJvdG90eXBlLmFkZHRva2VuPWZ1bmN0aW9uKGUsZyxrKXt2YXIgcCxoPXRoaXMuY2xhc3NpZnkoZSxnLGspO2E6Zm9yKDs7KXt2YXIgYT10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdO3ZhciBjPVxuYS5kZmFbMF07dmFyIG09Y1thLnN0YXRlXTtmb3IocD0wO3A8bS5sZW5ndGg7KytwKXt2YXIgbj1tW3BdWzBdO3ZhciBkPW1bcF1bMV07dmFyIGw9dGhpcy5ncmFtbWFyLmxhYmVsc1tuXVswXTtpZihoPT09bil7U2suYXNzZXJ0cy5hc3NlcnQoMjU2PmwpO3RoaXMuc2hpZnQoZSxnLGQsayk7Zm9yKGs9ZDsxPT09Y1trXS5sZW5ndGgmJjA9PT1jW2tdWzBdWzBdJiZjW2tdWzBdWzFdPT09azspe3RoaXMucG9wKCk7aWYoMD09PXRoaXMuc3RhY2subGVuZ3RoKXJldHVybiEwO2E9dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtrPWEuc3RhdGU7Yz1hLmRmYVswXX1yZXR1cm4hMX1pZigyNTY8PWwmJihuPXRoaXMuZ3JhbW1hci5kZmFzW2xdLG49blsxXSxuLmhhc093blByb3BlcnR5KGgpKSl7dGhpcy5wdXNoKGwsdGhpcy5ncmFtbWFyLmRmYXNbbF0sZCxrKTtjb250aW51ZSBhfX1iOntjPVswLGEuc3RhdGVdO2ZvcihhPW0ubGVuZ3RoO2EtLTspaWYobVthXVswXT09PWNbMF0mJlxubVthXVsxXT09PWNbMV0pe209ITA7YnJlYWsgYn1tPSExfWlmKG0pe2lmKHRoaXMucG9wKCksMD09PXRoaXMuc3RhY2subGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidG9vIG11Y2ggaW5wdXRcIix0aGlzLmZpbGVuYW1lKTt9ZWxzZSB0aHJvdyBlPWtbMF1bMF0sbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJiYWQgaW5wdXRcIix0aGlzLmZpbGVuYW1lLGUsayk7fX07Yi5wcm90b3R5cGUuY2xhc3NpZnk9ZnVuY3Rpb24oZSxnLGspe2lmKGU9PT1Tay50b2tlbi50b2tlbnMuVF9OQU1FKXt0aGlzLnVzZWRfbmFtZXNbZ109ITA7dmFyIHA9dGhpcy5ncmFtbWFyLmtleXdvcmRzLmhhc093blByb3BlcnR5KGcpJiZ0aGlzLmdyYW1tYXIua2V5d29yZHNbZ107XCJwcmludFwiPT09ZyYmKHRoaXMucF9mbGFncyZiLkNPX0ZVVFVSRV9QUklOVF9GVU5DVElPTnx8ITA9PT1Tay5fX2Z1dHVyZV9fLnByaW50X2Z1bmN0aW9uKSYmKHA9ITEpO2lmKHApcmV0dXJuIHB9cD10aGlzLmdyYW1tYXIudG9rZW5zLmhhc093blByb3BlcnR5KGUpJiZcbnRoaXMuZ3JhbW1hci50b2tlbnNbZV07aWYoIXApe2c9XCIjXCIrZTtmb3IobGV0IGggaW4gU2sudG9rZW4udG9rZW5zKWlmKFNrLnRva2VuLnRva2Vuc1toXT09ZSl7Zz1oO2JyZWFrfXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYmFkIHRva2VuIFwiK2csdGhpcy5maWxlbmFtZSxrWzBdWzBdLGspO31yZXR1cm4gcH07Yi5wcm90b3R5cGUuc2hpZnQ9ZnVuY3Rpb24oZSxnLGsscCl7dmFyIGg9dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXS5kZmEsYT10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGU7YS5jaGlsZHJlbi5wdXNoKHt0eXBlOmUsdmFsdWU6ZyxsaW5lbm86cFswXVswXSxjb2xfb2Zmc2V0OnBbMF1bMV0sY2hpbGRyZW46bnVsbH0pO3RoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV09e2RmYTpoLHN0YXRlOmssbm9kZTphfX07Yi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLGcsayxwKXtlPXt0eXBlOmUsdmFsdWU6bnVsbCxsaW5lbm86cFswXVswXSxcbmNvbF9vZmZzZXQ6cFswXVsxXSxjaGlsZHJlbjpbXX07dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXT17ZGZhOnRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV0uZGZhLHN0YXRlOmssbm9kZTp0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGV9O3RoaXMuc3RhY2sucHVzaCh7ZGZhOmcsc3RhdGU6MCxub2RlOmV9KX07Yi5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGFjay5wb3AoKS5ub2RlO2lmKGUpaWYoMCE9PXRoaXMuc3RhY2subGVuZ3RoKXt2YXIgZz10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGU7Zy5jaGlsZHJlbi5wdXNoKGUpfWVsc2UgdGhpcy5yb290bm9kZT1lLHRoaXMucm9vdG5vZGUudXNlZF9uYW1lcz10aGlzLnVzZWRfbmFtZXN9O1NrLnBhcnNlPWZ1bmN0aW9uKGUsZyl7dmFyIGs9U2sudG9rZW4udG9rZW5zLlRfQ09NTUVOVCxwPVNrLnRva2VuLnRva2Vucy5UX05MLGg9U2sudG9rZW4udG9rZW5zLlRfT1AsXG5hPVNrLnRva2VuLnRva2Vucy5UX0VORE1BUktFUixjPVNrLnRva2VuLnRva2Vucy5UX0VOQ09ESU5HLG09ITEsbj1mKGUpO1NrLl90b2tlbml6ZShlLGZ1bmN0aW9uKGQpe3ZhciBsPWQuc3BsaXQoXCJcXG5cIikucmV2ZXJzZSgpLm1hcChmdW5jdGlvbihyKXtyZXR1cm4gcitcIlxcblwifSk7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoMD09PWwubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLkV4Y2VwdGlvbihcIkVPRlwiKTtyZXR1cm4gbC5wb3AoKX19KGcpLFwidXRmLThcIixmdW5jdGlvbihkKXt2YXIgbD1udWxsO2QudHlwZSE9PWsmJmQudHlwZSE9PXAmJmQudHlwZSE9PWMmJihkLnR5cGU9PT1oJiYobD1Tay5PcE1hcFtkLnN0cmluZ10pLG4uYWRkdG9rZW4obHx8ZC50eXBlLGQuc3RyaW5nLFtkLnN0YXJ0LGQuZW5kLGQubGluZV0pLGQudHlwZT09PWEmJihtPSEwKSl9KTtpZighbSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImluY29tcGxldGUgaW5wdXRcIix0aGlzLmZpbGVuYW1lKTtcbnJldHVybntjc3Q6bi5yb290bm9kZSxmbGFnczpuLnBfZmxhZ3N9fTtTay5wYXJzZVRyZWVEdW1wPWZ1bmN0aW9uKGUsZyl7dmFyIGs7Zz1nfHxcIlwiO3ZhciBwPVwiXCIrZztpZigyNTY8PWUudHlwZSlmb3IocCs9U2suUGFyc2VUYWJsZXMubnVtYmVyMnN5bWJvbFtlLnR5cGVdK1wiXFxuXCIsaz0wO2s8ZS5jaGlsZHJlbi5sZW5ndGg7KytrKXArPVNrLnBhcnNlVHJlZUR1bXAoZS5jaGlsZHJlbltrXSxnK1wiICBcIik7ZWxzZSBwKz1Tay50b2tlbi50b2tfbmFtZVtlLnR5cGVdK1wiOiBcIisobmV3IFNrLmJ1aWx0aW4uc3RyKGUudmFsdWUpKS4kcigpLnYrXCJcXG5cIjtyZXR1cm4gcH07U2suZXhwb3J0U3ltYm9sKFwiU2suUGFyc2VyXCIsYik7U2suZXhwb3J0U3ltYm9sKFwiU2sucGFyc2VcIixTay5wYXJzZSk7U2suZXhwb3J0U3ltYm9sKFwiU2sucGFyc2VUcmVlRHVtcFwiLFNrLnBhcnNlVHJlZUR1bXApfSxmdW5jdGlvbihFLFEpe1NrLmFzdG5vZGVzPXt9O1NrLmFzdG5vZGVzLkxvYWQ9ZnVuY3Rpb24oKXt9O1xuU2suYXN0bm9kZXMuU3RvcmU9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkRlbD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQXVnTG9hZD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQXVnU3RvcmU9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlBhcmFtPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5BbmQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLk9yPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5BZGQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlN1Yj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTXVsdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTWF0TXVsdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuRGl2PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Nb2Q9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlBvdz1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTFNoaWZ0PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5SU2hpZnQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkJpdE9yPVxuZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkJpdFhvcj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQml0QW5kPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5GbG9vckRpdj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuSW52ZXJ0PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Ob3Q9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlVBZGQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlVTdWI9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkVxPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Ob3RFcT1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTHQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkx0RT1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuR3Q9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkd0RT1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuSXM9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLklzTm90PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Jbj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTm90SW49XG5mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTW9kdWxlPWZ1bmN0aW9uKGIsZil7dGhpcy5ib2R5PWI7dGhpcy5kb2NzdHJpbmc9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuSW50ZXJhY3RpdmU9ZnVuY3Rpb24oYil7dGhpcy5ib2R5PWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkV4cHJlc3Npb249ZnVuY3Rpb24oYil7dGhpcy5ib2R5PWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlN1aXRlPWZ1bmN0aW9uKGIpe3RoaXMuYm9keT1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZj1mdW5jdGlvbihiLGYsZSxnLGsscCxoLGEpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1oJiZ2b2lkIDAhPT1oKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YSYmdm9pZCAwIT09YSk7dGhpcy5uYW1lPWI7dGhpcy5hcmdzPWY7dGhpcy5ib2R5PWU7dGhpcy5kZWNvcmF0b3JfbGlzdD1nO3RoaXMucmV0dXJucz1rO3RoaXMuZG9jc3RyaW5nPXA7dGhpcy5saW5lbm89aDt0aGlzLmNvbF9vZmZzZXQ9XG5hO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmPWZ1bmN0aW9uKGIsZixlLGcsayxwLGgsYSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWgmJnZvaWQgMCE9PWgpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1hJiZ2b2lkIDAhPT1hKTt0aGlzLm5hbWU9Yjt0aGlzLmFyZ3M9Zjt0aGlzLmJvZHk9ZTt0aGlzLmRlY29yYXRvcl9saXN0PWc7dGhpcy5yZXR1cm5zPWs7dGhpcy5kb2NzdHJpbmc9cDt0aGlzLmxpbmVubz1oO3RoaXMuY29sX29mZnNldD1hO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5DbGFzc0RlZj1mdW5jdGlvbihiLGYsZSxnLGsscCxoLGEpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1oJiZ2b2lkIDAhPT1oKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YSYmdm9pZCAwIT09YSk7dGhpcy5uYW1lPWI7dGhpcy5iYXNlcz1mO3RoaXMua2V5d29yZHM9ZTt0aGlzLmJvZHk9Zzt0aGlzLmRlY29yYXRvcl9saXN0PWs7dGhpcy5kb2NzdHJpbmc9XG5wO3RoaXMubGluZW5vPWg7dGhpcy5jb2xfb2Zmc2V0PWE7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlJldHVybj1mdW5jdGlvbihiLGYsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLnZhbHVlPWI7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRGVsZXRlPWZ1bmN0aW9uKGIsZixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMudGFyZ2V0cz1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFzc2lnbj1mdW5jdGlvbihiLGYsZSxnKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PVxuZyk7dGhpcy50YXJnZXRzPWI7dGhpcy52YWx1ZT1mO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWc7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkF1Z0Fzc2lnbj1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy50YXJnZXQ9Yjt0aGlzLm9wPWY7dGhpcy52YWx1ZT1lO3RoaXMubGluZW5vPWc7dGhpcy5jb2xfb2Zmc2V0PWs7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFubkFzc2lnbj1mdW5jdGlvbihiLGYsZSxnLGsscCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWsmJnZvaWQgMCE9PWspO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1wJiZ2b2lkIDAhPT1wKTt0aGlzLnRhcmdldD1iO3RoaXMuYW5ub3RhdGlvbj1mO3RoaXMudmFsdWU9ZTt0aGlzLnNpbXBsZT1nO3RoaXMubGluZW5vPWs7dGhpcy5jb2xfb2Zmc2V0PXA7cmV0dXJuIHRoaXN9O1xuU2suYXN0bm9kZXMuRm9yPWZ1bmN0aW9uKGIsZixlLGcsayxwKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PXAmJnZvaWQgMCE9PXApO3RoaXMudGFyZ2V0PWI7dGhpcy5pdGVyPWY7dGhpcy5ib2R5PWU7dGhpcy5vcmVsc2U9Zzt0aGlzLmxpbmVubz1rO3RoaXMuY29sX29mZnNldD1wO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Bc3luY0Zvcj1mdW5jdGlvbihiLGYsZSxnLGsscCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWsmJnZvaWQgMCE9PWspO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1wJiZ2b2lkIDAhPT1wKTt0aGlzLnRhcmdldD1iO3RoaXMuaXRlcj1mO3RoaXMuYm9keT1lO3RoaXMub3JlbHNlPWc7dGhpcy5saW5lbm89azt0aGlzLmNvbF9vZmZzZXQ9cDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuV2hpbGU9ZnVuY3Rpb24oYixmLGUsZyxrKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmXG52b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy50ZXN0PWI7dGhpcy5ib2R5PWY7dGhpcy5vcmVsc2U9ZTt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1rO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JZj1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy50ZXN0PWI7dGhpcy5ib2R5PWY7dGhpcy5vcmVsc2U9ZTt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1rO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5XaXRoPWZ1bmN0aW9uKGIsZixlLGcpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7dGhpcy5pdGVtcz1iO3RoaXMuYm9keT1mO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PVxuZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQXN5bmNXaXRoPWZ1bmN0aW9uKGIsZixlLGcpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7dGhpcy5pdGVtcz1iO3RoaXMuYm9keT1mO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWc7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlJhaXNlPWZ1bmN0aW9uKGIsZixlLGcsayxwKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PXAmJnZvaWQgMCE9PXApO3RoaXMuZXhjPWI7dGhpcy5jYXVzZT1mO3RoaXMuaW5zdD1lO3RoaXMudGJhY2s9Zzt0aGlzLmxpbmVubz1rO3RoaXMuY29sX29mZnNldD1wO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Ucnk9ZnVuY3Rpb24oYixmLGUsZyxrLHApe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1rJiZ2b2lkIDAhPT1rKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XG5wJiZ2b2lkIDAhPT1wKTt0aGlzLmJvZHk9Yjt0aGlzLmhhbmRsZXJzPWY7dGhpcy5vcmVsc2U9ZTt0aGlzLmZpbmFsYm9keT1nO3RoaXMubGluZW5vPWs7dGhpcy5jb2xfb2Zmc2V0PXA7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFzc2VydD1mdW5jdGlvbihiLGYsZSxnKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO3RoaXMudGVzdD1iO3RoaXMubXNnPWY7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuSW1wb3J0PWZ1bmN0aW9uKGIsZixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMubmFtZXM9Yjt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JbXBvcnRGcm9tPWZ1bmN0aW9uKGIsXG5mLGUsZyxrKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWsmJnZvaWQgMCE9PWspO3RoaXMubW9kdWxlPWI7dGhpcy5uYW1lcz1mO3RoaXMubGV2ZWw9ZTt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1rO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5HbG9iYWw9ZnVuY3Rpb24oYixmLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7dGhpcy5uYW1lcz1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk5vbmxvY2FsPWZ1bmN0aW9uKGIsZixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMubmFtZXM9Yjt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1cbmU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkV4cHI9ZnVuY3Rpb24oYixmLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7dGhpcy52YWx1ZT1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlBhc3M9ZnVuY3Rpb24oYixmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkJyZWFrPWZ1bmN0aW9uKGIsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Db250aW51ZT1cbmZ1bmN0aW9uKGIsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5QcmludD1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy5kZXN0PWI7dGhpcy52YWx1ZXM9Zjt0aGlzLm5sPWU7dGhpcy5saW5lbm89Zzt0aGlzLmNvbF9vZmZzZXQ9aztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRGVidWdnZXI9ZnVuY3Rpb24oYixmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkJvb2xPcD1cbmZ1bmN0aW9uKGIsZixlLGcpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7dGhpcy5vcD1iO3RoaXMudmFsdWVzPWY7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQmluT3A9ZnVuY3Rpb24oYixmLGUsZyxrKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWsmJnZvaWQgMCE9PWspO3RoaXMubGVmdD1iO3RoaXMub3A9Zjt0aGlzLnJpZ2h0PWU7dGhpcy5saW5lbm89Zzt0aGlzLmNvbF9vZmZzZXQ9aztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuVW5hcnlPcD1mdW5jdGlvbihiLGYsZSxnKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO3RoaXMub3A9Yjt0aGlzLm9wZXJhbmQ9XG5mO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWc7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkxhbWJkYT1mdW5jdGlvbihiLGYsZSxnKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO3RoaXMuYXJncz1iO3RoaXMuYm9keT1mO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWc7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLklmRXhwPWZ1bmN0aW9uKGIsZixlLGcsayl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1rJiZ2b2lkIDAhPT1rKTt0aGlzLnRlc3Q9Yjt0aGlzLmJvZHk9Zjt0aGlzLm9yZWxzZT1lO3RoaXMubGluZW5vPWc7dGhpcy5jb2xfb2Zmc2V0PWs7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkRpY3Q9ZnVuY3Rpb24oYixmLGUsZyl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PVxuZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO3RoaXMua2V5cz1iO3RoaXMudmFsdWVzPWY7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuU2V0PWZ1bmN0aW9uKGIsZixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMuZWx0cz1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkxpc3RDb21wPWZ1bmN0aW9uKGIsZixlLGcpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7dGhpcy5lbHQ9Yjt0aGlzLmdlbmVyYXRvcnM9Zjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1nO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5TZXRDb21wPWZ1bmN0aW9uKGIsXG5mLGUsZyl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTt0aGlzLmVsdD1iO3RoaXMuZ2VuZXJhdG9ycz1mO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWc7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkRpY3RDb21wPWZ1bmN0aW9uKGIsZixlLGcsayl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1rJiZ2b2lkIDAhPT1rKTt0aGlzLmtleT1iO3RoaXMudmFsdWU9Zjt0aGlzLmdlbmVyYXRvcnM9ZTt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1rO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5HZW5lcmF0b3JFeHA9ZnVuY3Rpb24oYixmLGUsZyl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTt0aGlzLmVsdD1cbmI7dGhpcy5nZW5lcmF0b3JzPWY7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQXdhaXQ9ZnVuY3Rpb24oYixmLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7dGhpcy52YWx1ZT1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLllpZWxkPWZ1bmN0aW9uKGIsZixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMudmFsdWU9Yjt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5ZaWVsZEZyb209ZnVuY3Rpb24oYixmLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XG5lJiZ2b2lkIDAhPT1lKTt0aGlzLnZhbHVlPWI7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ29tcGFyZT1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy5sZWZ0PWI7dGhpcy5vcHM9Zjt0aGlzLmNvbXBhcmF0b3JzPWU7dGhpcy5saW5lbm89Zzt0aGlzLmNvbF9vZmZzZXQ9aztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ2FsbD1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy5mdW5jPWI7dGhpcy5hcmdzPWY7dGhpcy5rZXl3b3Jkcz1lO3RoaXMubGluZW5vPWc7dGhpcy5jb2xfb2Zmc2V0PWs7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk51bT1mdW5jdGlvbihiLFxuZixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMubj1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlN0cj1mdW5jdGlvbihiLGYsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLnM9Yjt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Gb3JtYXR0ZWRWYWx1ZT1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy52YWx1ZT1iO3RoaXMuY29udmVyc2lvbj1mO3RoaXMuZm9ybWF0X3NwZWM9ZTt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1cbms7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkpvaW5lZFN0cj1mdW5jdGlvbihiLGYsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLnZhbHVlcz1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkJ5dGVzPWZ1bmN0aW9uKGIsZixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMucz1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk5hbWVDb25zdGFudD1mdW5jdGlvbihiLGYsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLnZhbHVlPWI7dGhpcy5saW5lbm89XG5mO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5FbGxpcHNpcz1mdW5jdGlvbihiLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1iKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ29uc3RhbnQ9ZnVuY3Rpb24oYixmLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7dGhpcy52YWx1ZT1iO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkF0dHJpYnV0ZT1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy52YWx1ZT1cbmI7dGhpcy5hdHRyPWY7dGhpcy5jdHg9ZTt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1rO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5TdWJzY3JpcHQ9ZnVuY3Rpb24oYixmLGUsZyxrKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWsmJnZvaWQgMCE9PWspO3RoaXMudmFsdWU9Yjt0aGlzLnNsaWNlPWY7dGhpcy5jdHg9ZTt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1rO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5TdGFycmVkPWZ1bmN0aW9uKGIsZixlLGcpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7dGhpcy52YWx1ZT1iO3RoaXMuY3R4PWY7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuTmFtZT1mdW5jdGlvbihiLGYsZSxnKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XG5lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZyYmdm9pZCAwIT09Zyk7dGhpcy5pZD1iO3RoaXMuY3R4PWY7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuTGlzdD1mdW5jdGlvbihiLGYsZSxnKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO3RoaXMuZWx0cz1iO3RoaXMuY3R4PWY7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuVHVwbGU9ZnVuY3Rpb24oYixmLGUsZyl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTt0aGlzLmVsdHM9Yjt0aGlzLmN0eD1mO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWc7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlNsaWNlPVxuZnVuY3Rpb24oYixmLGUpe3RoaXMubG93ZXI9Yjt0aGlzLnVwcGVyPWY7dGhpcy5zdGVwPWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkV4dFNsaWNlPWZ1bmN0aW9uKGIpe3RoaXMuZGltcz1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JbmRleD1mdW5jdGlvbihiKXt0aGlzLnZhbHVlPWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLmNvbXByZWhlbnNpb249ZnVuY3Rpb24oYixmLGUsZyl7dGhpcy50YXJnZXQ9Yjt0aGlzLml0ZXI9Zjt0aGlzLmlmcz1lO3RoaXMuaXNfYXN5bmM9ZztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlcj1mdW5jdGlvbihiLGYsZSxnLGspe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ayYmdm9pZCAwIT09ayk7dGhpcy50eXBlPWI7dGhpcy5uYW1lPWY7dGhpcy5ib2R5PWU7dGhpcy5saW5lbm89Zzt0aGlzLmNvbF9vZmZzZXQ9aztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuYXJndW1lbnRzXz1cbmZ1bmN0aW9uKGIsZixlLGcsayxwKXt0aGlzLmFyZ3M9Yjt0aGlzLnZhcmFyZz1mO3RoaXMua3dvbmx5YXJncz1lO3RoaXMua3dfZGVmYXVsdHM9Zzt0aGlzLmt3YXJnPWs7dGhpcy5kZWZhdWx0cz1wO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5hcmc9ZnVuY3Rpb24gYihiLGYpe3RoaXMuYXJnPWI7dGhpcy5hbm5vdGF0aW9uPWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLmtleXdvcmQ9ZnVuY3Rpb24oYixmKXt0aGlzLmFyZz1iO3RoaXMudmFsdWU9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuYWxpYXM9ZnVuY3Rpb24oYixmKXt0aGlzLm5hbWU9Yjt0aGlzLmFzbmFtZT1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy53aXRoaXRlbT1mdW5jdGlvbihiLGYpe3RoaXMuY29udGV4dF9leHByPWI7dGhpcy5vcHRpb25hbF92YXJzPWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk1vZHVsZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJNb2R1bGVcIjtTay5hc3Rub2Rlcy5Nb2R1bGUucHJvdG90eXBlLl9maWVsZHM9XG5bXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJkb2NzdHJpbmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kb2NzdHJpbmd9XTtTay5hc3Rub2Rlcy5JbnRlcmFjdGl2ZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJJbnRlcmFjdGl2ZVwiO1NrLmFzdG5vZGVzLkludGVyYWN0aXZlLnByb3RvdHlwZS5fZmllbGRzPVtcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fV07U2suYXN0bm9kZXMuRXhwcmVzc2lvbi5wcm90b3R5cGUuX2FzdG5hbWU9XCJFeHByZXNzaW9uXCI7U2suYXN0bm9kZXMuRXhwcmVzc2lvbi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLlN1aXRlLnByb3RvdHlwZS5fYXN0bmFtZT1cIlN1aXRlXCI7U2suYXN0bm9kZXMuU3VpdGUucHJvdG90eXBlLl9maWVsZHM9W1wiYm9keVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmJvZHl9XTtTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZi5wcm90b3R5cGUuX2FzdG5hbWU9XG5cIkZ1bmN0aW9uRGVmXCI7U2suYXN0bm9kZXMuRnVuY3Rpb25EZWYucHJvdG90eXBlLl9maWVsZHM9W1wibmFtZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm5hbWV9LFwiYXJnc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmFyZ3N9LFwiYm9keVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmJvZHl9LFwiZGVjb3JhdG9yX2xpc3RcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kZWNvcmF0b3JfbGlzdH0sXCJyZXR1cm5zXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIucmV0dXJuc30sXCJkb2NzdHJpbmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kb2NzdHJpbmd9XTtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFzeW5jRnVuY3Rpb25EZWZcIjtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmLnByb3RvdHlwZS5fZmllbGRzPVtcIm5hbWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5uYW1lfSxcImFyZ3NcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hcmdzfSxcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fSxcblwiZGVjb3JhdG9yX2xpc3RcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kZWNvcmF0b3JfbGlzdH0sXCJyZXR1cm5zXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIucmV0dXJuc30sXCJkb2NzdHJpbmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kb2NzdHJpbmd9XTtTay5hc3Rub2Rlcy5DbGFzc0RlZi5wcm90b3R5cGUuX2FzdG5hbWU9XCJDbGFzc0RlZlwiO1NrLmFzdG5vZGVzLkNsYXNzRGVmLnByb3RvdHlwZS5fZmllbGRzPVtcIm5hbWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5uYW1lfSxcImJhc2VzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYmFzZXN9LFwia2V5d29yZHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5rZXl3b3Jkc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJkZWNvcmF0b3JfbGlzdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRlY29yYXRvcl9saXN0fSxcImRvY3N0cmluZ1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRvY3N0cmluZ31dO1NrLmFzdG5vZGVzLlJldHVybi5wcm90b3R5cGUuX2FzdG5hbWU9XG5cIlJldHVyblwiO1NrLmFzdG5vZGVzLlJldHVybi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuRGVsZXRlLnByb3RvdHlwZS5fYXN0bmFtZT1cIkRlbGV0ZVwiO1NrLmFzdG5vZGVzLkRlbGV0ZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0c31dO1NrLmFzdG5vZGVzLkFzc2lnbi5wcm90b3R5cGUuX2FzdG5hbWU9XCJBc3NpZ25cIjtTay5hc3Rub2Rlcy5Bc3NpZ24ucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0c1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRhcmdldHN9LFwidmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLkF1Z0Fzc2lnbi5wcm90b3R5cGUuX2FzdG5hbWU9XCJBdWdBc3NpZ25cIjtTay5hc3Rub2Rlcy5BdWdBc3NpZ24ucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0fSxcblwib3BcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcH0sXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuQW5uQXNzaWduLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFubkFzc2lnblwiO1NrLmFzdG5vZGVzLkFubkFzc2lnbi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi50YXJnZXR9LFwiYW5ub3RhdGlvblwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmFubm90YXRpb259LFwidmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX0sXCJzaW1wbGVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5zaW1wbGV9XTtTay5hc3Rub2Rlcy5Gb3IucHJvdG90eXBlLl9hc3RuYW1lPVwiRm9yXCI7U2suYXN0bm9kZXMuRm9yLnByb3RvdHlwZS5fZmllbGRzPVtcInRhcmdldFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRhcmdldH0sXCJpdGVyXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuaXRlcn0sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXG5cIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX1dO1NrLmFzdG5vZGVzLkFzeW5jRm9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFzeW5jRm9yXCI7U2suYXN0bm9kZXMuQXN5bmNGb3IucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0fSxcIml0ZXJcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVyfSxcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fSxcIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX1dO1NrLmFzdG5vZGVzLldoaWxlLnByb3RvdHlwZS5fYXN0bmFtZT1cIldoaWxlXCI7U2suYXN0bm9kZXMuV2hpbGUucHJvdG90eXBlLl9maWVsZHM9W1widGVzdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRlc3R9LFwiYm9keVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmJvZHl9LFwib3JlbHNlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIub3JlbHNlfV07U2suYXN0bm9kZXMuSWYucHJvdG90eXBlLl9hc3RuYW1lPVwiSWZcIjtcblNrLmFzdG5vZGVzLklmLnByb3RvdHlwZS5fZmllbGRzPVtcInRlc3RcIixmdW5jdGlvbihiKXtyZXR1cm4gYi50ZXN0fSxcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fSxcIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX1dO1NrLmFzdG5vZGVzLldpdGgucHJvdG90eXBlLl9hc3RuYW1lPVwiV2l0aFwiO1NrLmFzdG5vZGVzLldpdGgucHJvdG90eXBlLl9maWVsZHM9W1wiaXRlbXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVtc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLkFzeW5jV2l0aC5wcm90b3R5cGUuX2FzdG5hbWU9XCJBc3luY1dpdGhcIjtTay5hc3Rub2Rlcy5Bc3luY1dpdGgucHJvdG90eXBlLl9maWVsZHM9W1wiaXRlbXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVtc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLlJhaXNlLnByb3RvdHlwZS5fYXN0bmFtZT1cIlJhaXNlXCI7XG5Tay5hc3Rub2Rlcy5SYWlzZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJleGNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5leGN9LFwiY2F1c2VcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jYXVzZX0sXCJpbnN0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuaW5zdH0sXCJ0YmFja1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRiYWNrfV07U2suYXN0bm9kZXMuVHJ5LnByb3RvdHlwZS5fYXN0bmFtZT1cIlRyeVwiO1NrLmFzdG5vZGVzLlRyeS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJoYW5kbGVyc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmhhbmRsZXJzfSxcIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX0sXCJmaW5hbGJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5maW5hbGJvZHl9XTtTay5hc3Rub2Rlcy5Bc3NlcnQucHJvdG90eXBlLl9hc3RuYW1lPVwiQXNzZXJ0XCI7U2suYXN0bm9kZXMuQXNzZXJ0LnByb3RvdHlwZS5fZmllbGRzPVtcInRlc3RcIixcbmZ1bmN0aW9uKGIpe3JldHVybiBiLnRlc3R9LFwibXNnXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubXNnfV07U2suYXN0bm9kZXMuSW1wb3J0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkltcG9ydFwiO1NrLmFzdG5vZGVzLkltcG9ydC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm5hbWVzfV07U2suYXN0bm9kZXMuSW1wb3J0RnJvbS5wcm90b3R5cGUuX2FzdG5hbWU9XCJJbXBvcnRGcm9tXCI7U2suYXN0bm9kZXMuSW1wb3J0RnJvbS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJtb2R1bGVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5tb2R1bGV9LFwibmFtZXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5uYW1lc30sXCJsZXZlbFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmxldmVsfV07U2suYXN0bm9kZXMuR2xvYmFsLnByb3RvdHlwZS5fYXN0bmFtZT1cIkdsb2JhbFwiO1NrLmFzdG5vZGVzLkdsb2JhbC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm5hbWVzfV07XG5Tay5hc3Rub2Rlcy5Ob25sb2NhbC5wcm90b3R5cGUuX2FzdG5hbWU9XCJOb25sb2NhbFwiO1NrLmFzdG5vZGVzLk5vbmxvY2FsLnByb3RvdHlwZS5fZmllbGRzPVtcIm5hbWVzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmFtZXN9XTtTay5hc3Rub2Rlcy5FeHByLnByb3RvdHlwZS5fYXN0bmFtZT1cIkV4cHJcIjtTay5hc3Rub2Rlcy5FeHByLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9XTtTay5hc3Rub2Rlcy5QYXNzLnByb3RvdHlwZS5fYXN0bmFtZT1cIlBhc3NcIjtTay5hc3Rub2Rlcy5QYXNzLnByb3RvdHlwZS5fZmllbGRzPVtdO1NrLmFzdG5vZGVzLkJyZWFrLnByb3RvdHlwZS5fYXN0bmFtZT1cIkJyZWFrXCI7U2suYXN0bm9kZXMuQnJlYWsucHJvdG90eXBlLl9maWVsZHM9W107U2suYXN0bm9kZXMuQ29udGludWUucHJvdG90eXBlLl9hc3RuYW1lPVwiQ29udGludWVcIjtTay5hc3Rub2Rlcy5Db250aW51ZS5wcm90b3R5cGUuX2ZpZWxkcz1bXTtcblNrLmFzdG5vZGVzLlByaW50LnByb3RvdHlwZS5fYXN0bmFtZT1cIlByaW50XCI7U2suYXN0bm9kZXMuUHJpbnQucHJvdG90eXBlLl9maWVsZHM9W1wiZGVzdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRlc3R9LFwidmFsdWVzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWVzfSxcIm5sXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmx9XTtTay5hc3Rub2Rlcy5EZWJ1Z2dlci5wcm90b3R5cGUuX2FzdG5hbWU9XCJEZWJ1Z2dlclwiO1NrLmFzdG5vZGVzLkRlYnVnZ2VyLnByb3RvdHlwZS5fZmllbGRzPVtdO1NrLmFzdG5vZGVzLkJvb2xPcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJCb29sT3BcIjtTay5hc3Rub2Rlcy5Cb29sT3AucHJvdG90eXBlLl9maWVsZHM9W1wib3BcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcH0sXCJ2YWx1ZXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZXN9XTtTay5hc3Rub2Rlcy5CaW5PcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJCaW5PcFwiO1NrLmFzdG5vZGVzLkJpbk9wLnByb3RvdHlwZS5fZmllbGRzPVxuW1wibGVmdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmxlZnR9LFwib3BcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcH0sXCJyaWdodFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnJpZ2h0fV07U2suYXN0bm9kZXMuVW5hcnlPcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJVbmFyeU9wXCI7U2suYXN0bm9kZXMuVW5hcnlPcC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJvcFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9wfSxcIm9wZXJhbmRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcGVyYW5kfV07U2suYXN0bm9kZXMuTGFtYmRhLnByb3RvdHlwZS5fYXN0bmFtZT1cIkxhbWJkYVwiO1NrLmFzdG5vZGVzLkxhbWJkYS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJhcmdzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYXJnc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLklmRXhwLnByb3RvdHlwZS5fYXN0bmFtZT1cIklmRXhwXCI7U2suYXN0bm9kZXMuSWZFeHAucHJvdG90eXBlLl9maWVsZHM9W1widGVzdFwiLFxuZnVuY3Rpb24oYil7cmV0dXJuIGIudGVzdH0sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJvcmVsc2VcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcmVsc2V9XTtTay5hc3Rub2Rlcy5EaWN0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkRpY3RcIjtTay5hc3Rub2Rlcy5EaWN0LnByb3RvdHlwZS5fZmllbGRzPVtcImtleXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5rZXlzfSxcInZhbHVlc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlc31dO1NrLmFzdG5vZGVzLlNldC5wcm90b3R5cGUuX2FzdG5hbWU9XCJTZXRcIjtTay5hc3Rub2Rlcy5TZXQucHJvdG90eXBlLl9maWVsZHM9W1wiZWx0c1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmVsdHN9XTtTay5hc3Rub2Rlcy5MaXN0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJMaXN0Q29tcFwiO1NrLmFzdG5vZGVzLkxpc3RDb21wLnByb3RvdHlwZS5fZmllbGRzPVtcImVsdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmVsdH0sXCJnZW5lcmF0b3JzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuZ2VuZXJhdG9yc31dO1xuU2suYXN0bm9kZXMuU2V0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJTZXRDb21wXCI7U2suYXN0bm9kZXMuU2V0Q29tcC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5lbHR9LFwiZ2VuZXJhdG9yc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmdlbmVyYXRvcnN9XTtTay5hc3Rub2Rlcy5EaWN0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJEaWN0Q29tcFwiO1NrLmFzdG5vZGVzLkRpY3RDb21wLnByb3RvdHlwZS5fZmllbGRzPVtcImtleVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmtleX0sXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfSxcImdlbmVyYXRvcnNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5nZW5lcmF0b3JzfV07U2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwLnByb3RvdHlwZS5fYXN0bmFtZT1cIkdlbmVyYXRvckV4cFwiO1NrLmFzdG5vZGVzLkdlbmVyYXRvckV4cC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5lbHR9LFxuXCJnZW5lcmF0b3JzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuZ2VuZXJhdG9yc31dO1NrLmFzdG5vZGVzLkF3YWl0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkF3YWl0XCI7U2suYXN0bm9kZXMuQXdhaXQucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLllpZWxkLnByb3RvdHlwZS5fYXN0bmFtZT1cIllpZWxkXCI7U2suYXN0bm9kZXMuWWllbGQucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLllpZWxkRnJvbS5wcm90b3R5cGUuX2FzdG5hbWU9XCJZaWVsZEZyb21cIjtTay5hc3Rub2Rlcy5ZaWVsZEZyb20ucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLkNvbXBhcmUucHJvdG90eXBlLl9hc3RuYW1lPVwiQ29tcGFyZVwiO1NrLmFzdG5vZGVzLkNvbXBhcmUucHJvdG90eXBlLl9maWVsZHM9XG5bXCJsZWZ0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubGVmdH0sXCJvcHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcHN9LFwiY29tcGFyYXRvcnNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jb21wYXJhdG9yc31dO1NrLmFzdG5vZGVzLkNhbGwucHJvdG90eXBlLl9hc3RuYW1lPVwiQ2FsbFwiO1NrLmFzdG5vZGVzLkNhbGwucHJvdG90eXBlLl9maWVsZHM9W1wiZnVuY1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmZ1bmN9LFwiYXJnc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmFyZ3N9LFwia2V5d29yZHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5rZXl3b3Jkc31dO1NrLmFzdG5vZGVzLk51bS5wcm90b3R5cGUuX2FzdG5hbWU9XCJOdW1cIjtTay5hc3Rub2Rlcy5OdW0ucHJvdG90eXBlLl9maWVsZHM9W1wiblwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm59XTtTay5hc3Rub2Rlcy5TdHIucHJvdG90eXBlLl9hc3RuYW1lPVwiU3RyXCI7U2suYXN0bm9kZXMuU3RyLnByb3RvdHlwZS5fZmllbGRzPVtcInNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5zfV07XG5Tay5hc3Rub2Rlcy5Gb3JtYXR0ZWRWYWx1ZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJGb3JtYXR0ZWRWYWx1ZVwiO1NrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwiY29udmVyc2lvblwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmNvbnZlcnNpb259LFwiZm9ybWF0X3NwZWNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5mb3JtYXRfc3BlY31dO1NrLmFzdG5vZGVzLkpvaW5lZFN0ci5wcm90b3R5cGUuX2FzdG5hbWU9XCJKb2luZWRTdHJcIjtTay5hc3Rub2Rlcy5Kb2luZWRTdHIucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWVzfV07U2suYXN0bm9kZXMuQnl0ZXMucHJvdG90eXBlLl9hc3RuYW1lPVwiQnl0ZXNcIjtTay5hc3Rub2Rlcy5CeXRlcy5wcm90b3R5cGUuX2ZpZWxkcz1bXCJzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuc31dO1NrLmFzdG5vZGVzLk5hbWVDb25zdGFudC5wcm90b3R5cGUuX2FzdG5hbWU9XG5cIk5hbWVDb25zdGFudFwiO1NrLmFzdG5vZGVzLk5hbWVDb25zdGFudC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuRWxsaXBzaXMucHJvdG90eXBlLl9hc3RuYW1lPVwiRWxsaXBzaXNcIjtTay5hc3Rub2Rlcy5FbGxpcHNpcy5wcm90b3R5cGUuX2ZpZWxkcz1bXTtTay5hc3Rub2Rlcy5Db25zdGFudC5wcm90b3R5cGUuX2FzdG5hbWU9XCJDb25zdGFudFwiO1NrLmFzdG5vZGVzLkNvbnN0YW50LnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9XTtTay5hc3Rub2Rlcy5BdHRyaWJ1dGUucHJvdG90eXBlLl9hc3RuYW1lPVwiQXR0cmlidXRlXCI7U2suYXN0bm9kZXMuQXR0cmlidXRlLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwiYXR0clwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmF0dHJ9LFwiY3R4XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuY3R4fV07XG5Tay5hc3Rub2Rlcy5TdWJzY3JpcHQucHJvdG90eXBlLl9hc3RuYW1lPVwiU3Vic2NyaXB0XCI7U2suYXN0bm9kZXMuU3Vic2NyaXB0LnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwic2xpY2VcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5zbGljZX0sXCJjdHhcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jdHh9XTtTay5hc3Rub2Rlcy5TdGFycmVkLnByb3RvdHlwZS5fYXN0bmFtZT1cIlN0YXJyZWRcIjtTay5hc3Rub2Rlcy5TdGFycmVkLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwiY3R4XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuY3R4fV07U2suYXN0bm9kZXMuTmFtZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJOYW1lXCI7U2suYXN0bm9kZXMuTmFtZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJpZFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlkfSxcImN0eFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmN0eH1dO1NrLmFzdG5vZGVzLkxpc3QucHJvdG90eXBlLl9hc3RuYW1lPVxuXCJMaXN0XCI7U2suYXN0bm9kZXMuTGlzdC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuZWx0c30sXCJjdHhcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jdHh9XTtTay5hc3Rub2Rlcy5UdXBsZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJUdXBsZVwiO1NrLmFzdG5vZGVzLlR1cGxlLnByb3RvdHlwZS5fZmllbGRzPVtcImVsdHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5lbHRzfSxcImN0eFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmN0eH1dO1NrLmFzdG5vZGVzLkxvYWQucHJvdG90eXBlLl9hc3RuYW1lPVwiTG9hZFwiO1NrLmFzdG5vZGVzLkxvYWQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuU3RvcmUucHJvdG90eXBlLl9hc3RuYW1lPVwiU3RvcmVcIjtTay5hc3Rub2Rlcy5TdG9yZS5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5EZWwucHJvdG90eXBlLl9hc3RuYW1lPVwiRGVsXCI7U2suYXN0bm9kZXMuRGVsLnByb3RvdHlwZS5faXNlbnVtPSEwO1xuU2suYXN0bm9kZXMuQXVnTG9hZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJBdWdMb2FkXCI7U2suYXN0bm9kZXMuQXVnTG9hZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5BdWdTdG9yZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJBdWdTdG9yZVwiO1NrLmFzdG5vZGVzLkF1Z1N0b3JlLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLlBhcmFtLnByb3RvdHlwZS5fYXN0bmFtZT1cIlBhcmFtXCI7U2suYXN0bm9kZXMuUGFyYW0ucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuU2xpY2UucHJvdG90eXBlLl9hc3RuYW1lPVwiU2xpY2VcIjtTay5hc3Rub2Rlcy5TbGljZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJsb3dlclwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmxvd2VyfSxcInVwcGVyXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudXBwZXJ9LFwic3RlcFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnN0ZXB9XTtTay5hc3Rub2Rlcy5FeHRTbGljZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJFeHRTbGljZVwiO1xuU2suYXN0bm9kZXMuRXh0U2xpY2UucHJvdG90eXBlLl9maWVsZHM9W1wiZGltc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRpbXN9XTtTay5hc3Rub2Rlcy5JbmRleC5wcm90b3R5cGUuX2FzdG5hbWU9XCJJbmRleFwiO1NrLmFzdG5vZGVzLkluZGV4LnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9XTtTay5hc3Rub2Rlcy5BbmQucHJvdG90eXBlLl9hc3RuYW1lPVwiQW5kXCI7U2suYXN0bm9kZXMuQW5kLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLk9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIk9yXCI7U2suYXN0bm9kZXMuT3IucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuQWRkLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFkZFwiO1NrLmFzdG5vZGVzLkFkZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5TdWIucHJvdG90eXBlLl9hc3RuYW1lPVwiU3ViXCI7U2suYXN0bm9kZXMuU3ViLnByb3RvdHlwZS5faXNlbnVtPSEwO1xuU2suYXN0bm9kZXMuTXVsdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJNdWx0XCI7U2suYXN0bm9kZXMuTXVsdC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5NYXRNdWx0LnByb3RvdHlwZS5fYXN0bmFtZT1cIk1hdE11bHRcIjtTay5hc3Rub2Rlcy5NYXRNdWx0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkRpdi5wcm90b3R5cGUuX2FzdG5hbWU9XCJEaXZcIjtTay5hc3Rub2Rlcy5EaXYucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTW9kLnByb3RvdHlwZS5fYXN0bmFtZT1cIk1vZFwiO1NrLmFzdG5vZGVzLk1vZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Qb3cucHJvdG90eXBlLl9hc3RuYW1lPVwiUG93XCI7U2suYXN0bm9kZXMuUG93LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkxTaGlmdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJMU2hpZnRcIjtTay5hc3Rub2Rlcy5MU2hpZnQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuUlNoaWZ0LnByb3RvdHlwZS5fYXN0bmFtZT1cblwiUlNoaWZ0XCI7U2suYXN0bm9kZXMuUlNoaWZ0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkJpdE9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIkJpdE9yXCI7U2suYXN0bm9kZXMuQml0T3IucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuQml0WG9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIkJpdFhvclwiO1NrLmFzdG5vZGVzLkJpdFhvci5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5CaXRBbmQucHJvdG90eXBlLl9hc3RuYW1lPVwiQml0QW5kXCI7U2suYXN0bm9kZXMuQml0QW5kLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkZsb29yRGl2LnByb3RvdHlwZS5fYXN0bmFtZT1cIkZsb29yRGl2XCI7U2suYXN0bm9kZXMuRmxvb3JEaXYucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuSW52ZXJ0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkludmVydFwiO1NrLmFzdG5vZGVzLkludmVydC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Ob3QucHJvdG90eXBlLl9hc3RuYW1lPVxuXCJOb3RcIjtTay5hc3Rub2Rlcy5Ob3QucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuVUFkZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJVQWRkXCI7U2suYXN0bm9kZXMuVUFkZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5VU3ViLnByb3RvdHlwZS5fYXN0bmFtZT1cIlVTdWJcIjtTay5hc3Rub2Rlcy5VU3ViLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkVxLnByb3RvdHlwZS5fYXN0bmFtZT1cIkVxXCI7U2suYXN0bm9kZXMuRXEucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTm90RXEucHJvdG90eXBlLl9hc3RuYW1lPVwiTm90RXFcIjtTay5hc3Rub2Rlcy5Ob3RFcS5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5MdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJMdFwiO1NrLmFzdG5vZGVzLkx0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkx0RS5wcm90b3R5cGUuX2FzdG5hbWU9XCJMdEVcIjtTay5hc3Rub2Rlcy5MdEUucHJvdG90eXBlLl9pc2VudW09XG4hMDtTay5hc3Rub2Rlcy5HdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJHdFwiO1NrLmFzdG5vZGVzLkd0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkd0RS5wcm90b3R5cGUuX2FzdG5hbWU9XCJHdEVcIjtTay5hc3Rub2Rlcy5HdEUucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuSXMucHJvdG90eXBlLl9hc3RuYW1lPVwiSXNcIjtTay5hc3Rub2Rlcy5Jcy5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Jc05vdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJJc05vdFwiO1NrLmFzdG5vZGVzLklzTm90LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkluLnByb3RvdHlwZS5fYXN0bmFtZT1cIkluXCI7U2suYXN0bm9kZXMuSW4ucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTm90SW4ucHJvdG90eXBlLl9hc3RuYW1lPVwiTm90SW5cIjtTay5hc3Rub2Rlcy5Ob3RJbi5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5jb21wcmVoZW5zaW9uLnByb3RvdHlwZS5fYXN0bmFtZT1cblwiY29tcHJlaGVuc2lvblwiO1NrLmFzdG5vZGVzLmNvbXByZWhlbnNpb24ucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0fSxcIml0ZXJcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVyfSxcImlmc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlmc30sXCJpc19hc3luY1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlzX2FzeW5jfV07U2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlci5wcm90b3R5cGUuX2FzdG5hbWU9XCJFeGNlcHRIYW5kbGVyXCI7U2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlci5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0eXBlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudHlwZX0sXCJuYW1lXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmFtZX0sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLmFyZ3VtZW50c18ucHJvdG90eXBlLl9hc3RuYW1lPVwiYXJndW1lbnRzXCI7U2suYXN0bm9kZXMuYXJndW1lbnRzXy5wcm90b3R5cGUuX2ZpZWxkcz1cbltcImFyZ3NcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hcmdzfSxcInZhcmFyZ1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhcmFyZ30sXCJrd29ubHlhcmdzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIua3dvbmx5YXJnc30sXCJrd19kZWZhdWx0c1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmt3X2RlZmF1bHRzfSxcImt3YXJnXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIua3dhcmd9LFwiZGVmYXVsdHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kZWZhdWx0c31dO1NrLmFzdG5vZGVzLmFyZy5wcm90b3R5cGUuX2FzdG5hbWU9XCJhcmdcIjtTay5hc3Rub2Rlcy5hcmcucHJvdG90eXBlLl9maWVsZHM9W1wiYXJnXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYXJnfSxcImFubm90YXRpb25cIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hbm5vdGF0aW9ufV07U2suYXN0bm9kZXMua2V5d29yZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJrZXl3b3JkXCI7U2suYXN0bm9kZXMua2V5d29yZC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJhcmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hcmd9LFxuXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuYWxpYXMucHJvdG90eXBlLl9hc3RuYW1lPVwiYWxpYXNcIjtTay5hc3Rub2Rlcy5hbGlhcy5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmFtZX0sXCJhc25hbWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hc25hbWV9XTtTay5hc3Rub2Rlcy53aXRoaXRlbS5wcm90b3R5cGUuX2FzdG5hbWU9XCJ3aXRoaXRlbVwiO1NrLmFzdG5vZGVzLndpdGhpdGVtLnByb3RvdHlwZS5fZmllbGRzPVtcImNvbnRleHRfZXhwclwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmNvbnRleHRfZXhwcn0sXCJvcHRpb25hbF92YXJzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIub3B0aW9uYWxfdmFyc31dO1NrLmV4cG9ydFN5bWJvbChcIlNrLmFzdG5vZGVzXCIsU2suYXN0bm9kZXMpfSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoeix1LHkpe3RoaXMuY19lbmNvZGluZz16O3RoaXMuY19maWxlbmFtZT11O3RoaXMuY19mbGFncz1cbnl8fDB9ZnVuY3Rpb24gZih6KXtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT16LFwibm9kZSBtdXN0IGJlIGRlZmluZWRcIik7cmV0dXJuIG51bGw9PT16LmNoaWxkcmVuPzA6ei5jaGlsZHJlbi5sZW5ndGh9ZnVuY3Rpb24gZSh6LHUpe1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMCE9PXosXCJub2RlIG11c3QgYmUgZGVmaW5lZFwiKTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT11LFwiaW5kZXggb2YgY2hpbGQgbXVzdCBiZSBzcGVjaWZpZWRcIik7cmV0dXJuIHouY2hpbGRyZW5bdV19ZnVuY3Rpb24gZyh6LHUpe1NrLmFzc2VydHMuYXNzZXJ0KHoudHlwZT09PXUsXCJub2RlIHdhc24ndCBleHBlY3RlZCB0eXBlXCIpfWZ1bmN0aW9uIGsoeix1LHkpe3Rocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKHksei5jX2ZpbGVuYW1lLHUubGluZW5vKTt9ZnVuY3Rpb24gcCh6KXtTay5hc3NlcnRzLmFzc2VydChcInN0cmluZ1wiPT09dHlwZW9mIHosXCJleHBlY3Rpbmcgc3RyaW5nLCBnb3QgXCIrdHlwZW9mIHopO1xucmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih6KX1mdW5jdGlvbiBoKHope3ZhciB1LHk7c3dpdGNoKHoudHlwZSl7Y2FzZSBPLnNpbmdsZV9pbnB1dDppZihlKHosMCkudHlwZT09PVQuVF9ORVdMSU5FKWJyZWFrO2Vsc2UgcmV0dXJuIGgoZSh6LDApKTtjYXNlIE8uZmlsZV9pbnB1dDpmb3IodT15PTA7dTxmKHopOysrdSl7dmFyIEc9ZSh6LHUpO0cudHlwZT09PU8uc3RtdCYmKHkrPWgoRykpfXJldHVybiB5O2Nhc2UgTy5zdG10OnJldHVybiBoKGUoeiwwKSk7Y2FzZSBPLmNvbXBvdW5kX3N0bXQ6cmV0dXJuIDE7Y2FzZSBPLnNpbXBsZV9zdG10OnJldHVybiBNYXRoLmZsb29yKGYoeikvMik7Y2FzZSBPLnN1aXRlOmlmKDE9PT1mKHopKXJldHVybiBoKGUoeiwwKSk7eT0wO2Zvcih1PTI7dTxmKHopLTE7Kyt1KXkrPWgoZSh6LHUpKTtyZXR1cm4geTtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcIk5vbi1zdGF0ZW1lbnQgZm91bmRcIil9cmV0dXJuIDB9ZnVuY3Rpb24gYSh6LHUseSxHKXt5IGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uc3RyJiYoeT15LnYpO2lmKFwiTm9uZVwiPT09eSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImFzc2lnbm1lbnQgdG8gTm9uZVwiLHouY19maWxlbmFtZSxHKTtpZihcIlRydWVcIj09PXl8fFwiRmFsc2VcIj09PXkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhc3NpZ25tZW50IHRvIFRydWUgb3IgRmFsc2UgaXMgZm9yYmlkZGVuXCIsei5jX2ZpbGVuYW1lLEcpO31mdW5jdGlvbiBjKHosdSx5LEcpe3ZhciBLO1NrLmFzc2VydHMuYXNzZXJ0KHkhPT1Tay5hc3Rub2Rlcy5BdWdTdG9yZSYmeSE9PVNrLmFzdG5vZGVzLkF1Z0xvYWQsXCJjb250ZXh0IG5vdCBBdWdTdG9yZSBvciBBdWdMb2FkXCIpO3ZhciBJPUs9bnVsbDtzd2l0Y2godS5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5BdHRyaWJ1dGU6Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOnk9PT1Tay5hc3Rub2Rlcy5TdG9yZSYmYSh6LEcsdS5hdHRyLEcubGluZW5vKTt1LmN0eD15O2JyZWFrO1xuY2FzZSBTay5hc3Rub2Rlcy5TdGFycmVkOnUuY3R4PXk7Yyh6LHUudmFsdWUseSxHKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlN1YnNjcmlwdDp1LmN0eD15O2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdDp1LmN0eD15O0s9dS5lbHRzO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuVHVwbGU6aWYoMD09PXUuZWx0cy5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJjYW4ndCBhc3NpZ24gdG8gKClcIix6LmNfZmlsZW5hbWUsRy5saW5lbm8pO3UuY3R4PXk7Sz11LmVsdHM7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5MYW1iZGE6ST1cImxhbWJkYVwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ2FsbDpJPVwiZnVuY3Rpb24gY2FsbFwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQm9vbE9wOmNhc2UgU2suYXN0bm9kZXMuQmluT3A6Y2FzZSBTay5hc3Rub2Rlcy5VbmFyeU9wOkk9XCJvcGVyYXRvclwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOkk9XCJnZW5lcmF0b3IgZXhwcmVzc2lvblwiO1xuYnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZDpJPVwieWllbGQgZXhwcmVzc2lvblwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdENvbXA6ST1cImxpc3QgY29tcHJlaGVuc2lvblwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU2V0Q29tcDpJPVwic2V0IGNvbXByZWhlbnNpb25cIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRpY3RDb21wOkk9XCJkaWN0IGNvbXByZWhlbnNpb25cIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRpY3Q6Y2FzZSBTay5hc3Rub2Rlcy5TZXQ6Y2FzZSBTay5hc3Rub2Rlcy5OdW06Y2FzZSBTay5hc3Rub2Rlcy5TdHI6ST1cImxpdGVyYWxcIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudDpJPVwiVHJ1ZSwgRmFsc2Ugb3IgTm9uZVwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ29tcGFyZTpJPVwiY29tcGFyaXNvblwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuUmVwcjpJPVwicmVwclwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSWZFeHA6ST1cImNvbmRpdGlvbmFsIGV4cHJlc3Npb25cIjtcbmJyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGV4cHJlc3Npb24gaW4gYXNzaWdubWVudFwiKX1pZihJKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiY2FuJ3QgXCIrKHk9PT1Tay5hc3Rub2Rlcy5TdG9yZT9cImFzc2lnbiB0b1wiOlwiZGVsZXRlXCIpK1wiIFwiK0ksei5jX2ZpbGVuYW1lLEcubGluZW5vKTtpZihLKWZvcih1PTA7dTxLLmxlbmd0aDsrK3UpYyh6LEtbdV0seSxHKX1mdW5jdGlvbiBtKHope2lmKHZvaWQgMD09PWRhW3oudHlwZV0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJpbnZhbGlkIHN5bnRheFwiLHoudHlwZSx6LmxpbmVubyk7cmV0dXJuIGRhW3oudHlwZV19ZnVuY3Rpb24gbih6LHUpe3JldHVybiB6LnZhbHVlP25ldyBTay5idWlsdGluLnN0cih6LnZhbHVlKTpuZXcgU2suYnVpbHRpbi5zdHIoeil9ZnVuY3Rpb24gZCh6LHUpe2codSxPLmNvbXBfb3ApO2lmKDE9PT1mKHUpKXN3aXRjaCh1PWUodSwwKSx1LnR5cGUpe2Nhc2UgVC5UX0xFU1M6cmV0dXJuIFNrLmFzdG5vZGVzLkx0O1xuY2FzZSBULlRfR1JFQVRFUjpyZXR1cm4gU2suYXN0bm9kZXMuR3Q7Y2FzZSBULlRfRVFFUVVBTDpyZXR1cm4gU2suYXN0bm9kZXMuRXE7Y2FzZSBULlRfTEVTU0VRVUFMOnJldHVybiBTay5hc3Rub2Rlcy5MdEU7Y2FzZSBULlRfR1JFQVRFUkVRVUFMOnJldHVybiBTay5hc3Rub2Rlcy5HdEU7Y2FzZSBULlRfTk9URVFVQUw6cmV0dXJuIFNrLmFzdG5vZGVzLk5vdEVxO2Nhc2UgVC5UX05BTUU6aWYoXCJpblwiPT09dS52YWx1ZSlyZXR1cm4gU2suYXN0bm9kZXMuSW47aWYoXCJpc1wiPT09dS52YWx1ZSlyZXR1cm4gU2suYXN0bm9kZXMuSXN9ZWxzZSBpZigyPT09Zih1KSYmZSh1LDApLnR5cGU9PT1ULlRfTkFNRSl7aWYoXCJpblwiPT09ZSh1LDEpLnZhbHVlKXJldHVybiBTay5hc3Rub2Rlcy5Ob3RJbjtpZihcImlzXCI9PT1lKHUsMCkudmFsdWUpcmV0dXJuIFNrLmFzdG5vZGVzLklzTm90fVNrLmFzc2VydHMuZmFpbChcImludmFsaWQgY29tcF9vcFwiKX1mdW5jdGlvbiBsKHosdSl7eiYmKHoubGluZW5vPVxudS5saW5lbm8sei5jb2xfb2Zmc2V0PXUuY29sX29mZnNldCx6LmVuZF9saW5lbm89dS5lbmRfbGluZW5vLHouZW5kX2NvbF9vZmZzZXQ9dS5lbmRfY29sX29mZnNldCk7cmV0dXJuIHp9ZnVuY3Rpb24gcih6LHUpe3ZhciB5LEc9W107U2suYXNzZXJ0cy5hc3NlcnQodS50eXBlPT09Ty50ZXN0bGlzdHx8dS50eXBlPT09Ty50ZXN0bGlzdF9zdGFyX2V4cHJ8fHUudHlwZT09PU8ubGlzdG1ha2VyfHx1LnR5cGU9PT1PLnRlc3RsaXN0X2NvbXB8fHUudHlwZT09PU8udGVzdGxpc3Rfc2FmZXx8dS50eXBlPT09Ty50ZXN0bGlzdDEsXCJub2RlIHR5cGUgbXVzdCBiZSBsaXN0bGlrZVwiKTtmb3IoeT0wO3k8Zih1KTt5Kz0yKVNrLmFzc2VydHMuYXNzZXJ0KGUodSx5KS50eXBlPT09Ty50ZXN0fHxlKHUseSkudHlwZT09PU8ub2xkX3Rlc3R8fGUodSx5KS50eXBlPT09Ty5zdGFyX2V4cHIpLEdbeS8yXT1WKHosZSh1LHkpKTtyZXR1cm4gR31mdW5jdGlvbiB2KHosdSl7dmFyIHk7Zyh1LE8uc3VpdGUpO1xudmFyIEc9W107dmFyIEs9MDtpZihlKHUsMCkudHlwZT09PU8uc2ltcGxlX3N0bXQpe3U9ZSh1LDApO3ZhciBJPWYodSktMTtlKHUsSS0xKS50eXBlPT09VC5UX1NFTUkmJi0tSTtmb3IoeT0wO3k8STt5Kz0yKUdbSysrXT1sYSh6LGUodSx5KSl9ZWxzZSBmb3IoeT0yO3k8Zih1KS0xOysreSl7ST1lKHUseSk7ZyhJLE8uc3RtdCk7dmFyIE09aChJKTtpZigxPT09TSlHW0srK109bGEoeixJKTtlbHNlIGZvcihJPWUoSSwwKSxnKEksTy5zaW1wbGVfc3RtdCksTT0wO008ZihJKTtNKz0yKXtpZigwPT09ZihlKEksTSkpKXtTay5hc3NlcnRzLmFzc2VydChNKzE9PT1mKEkpKTticmVha31HW0srK109bGEoeixlKEksTSkpfX1Tay5hc3NlcnRzLmFzc2VydChLPT09aCh1KSk7cmV0dXJuIEd9ZnVuY3Rpb24gcSh6LHUseSl7dmFyIEc7Zyh1LE8uZXhwcmxpc3QpO3ZhciBLPVtdO2ZvcihHPTA7RzxmKHUpO0crPTIpe3ZhciBJPVYoeixlKHUsRykpO0tbRy8yXT1JO3kmJmMoeixJLHksZSh1LEcpKX1yZXR1cm4gS31cbmZ1bmN0aW9uIHQoeix1KXthOmZvcig7Oylzd2l0Y2godS50eXBlKXtjYXNlIE8uaW1wb3J0X2FzX25hbWU6ej1udWxsO3ZhciB5PXAoZSh1LDApLnZhbHVlKTszPT09Zih1KSYmKHo9ZSh1LDIpLnZhbHVlKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKHksbnVsbD09ej9udWxsOnAoeikpO2Nhc2UgTy5kb3R0ZWRfYXNfbmFtZTppZigxPT09Zih1KSl7dT1lKHUsMCk7Y29udGludWUgYX1lbHNlIHJldHVybiB6PXQoeixlKHUsMCkpLFNrLmFzc2VydHMuYXNzZXJ0KCF6LmFzbmFtZSksei5hc25hbWU9cChlKHUsMikudmFsdWUpLHo7Y2FzZSBPLmRvdHRlZF9uYW1lOmlmKDE9PT1mKHUpKXJldHVybiBuZXcgU2suYXN0bm9kZXMuYWxpYXMocChlKHUsMCkudmFsdWUpLG51bGwpO3o9XCJcIjtmb3IoeT0wO3k8Zih1KTt5Kz0yKXorPWUodSx5KS52YWx1ZStcIi5cIjtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKHAoei5zdWJzdHIoMCx6Lmxlbmd0aC0xKSksbnVsbCk7Y2FzZSBULlRfU1RBUjpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKHAoXCIqXCIpLFxubnVsbCk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInVuZXhwZWN0ZWQgaW1wb3J0IG5hbWVcIix6LmNfZmlsZW5hbWUsdS5saW5lbm8pO319ZnVuY3Rpb24gdyh6LHUpe1NrLmFzc2VydHMuYXNzZXJ0KHUudHlwZT09Ty50ZXN0bGlzdF9jb21wfHx1LnR5cGU9PU8uYXJndW1lbnQpO3JldHVybiBXKHosdSwwKX1mdW5jdGlvbiBDKHosdSl7aWYoZSh1LDApLnR5cGU9PT1ULlRfTUlOVVMmJjI9PT1mKHUpKXt2YXIgeT1lKHUsMSk7aWYoeS50eXBlPT09Ty5mYWN0b3ImJjE9PT1mKHkpJiYoeT1lKHksMCkseS50eXBlPT09Ty5wb3dlciYmMT09PWYoeSkpKXt2YXIgRz1lKHksMCk7aWYoRy50eXBlPT09Ty5hdG9tJiYoeT1lKEcsMCkseS50eXBlPT09VC5UX05VTUJFUikpcmV0dXJuIHkudmFsdWU9XCItXCIreS52YWx1ZSxuYSh6LEcpfX16PVYoeixlKHUsMSkpO3N3aXRjaChlKHUsMCkudHlwZSl7Y2FzZSBULlRfUExVUzpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlVuYXJ5T3AoU2suYXN0bm9kZXMuVUFkZCxcbnosdS5saW5lbm8sdS5jb2xfb2Zmc2V0KTtjYXNlIFQuVF9NSU5VUzpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlVuYXJ5T3AoU2suYXN0bm9kZXMuVVN1Yix6LHUubGluZW5vLHUuY29sX29mZnNldCk7Y2FzZSBULlRfVElMREU6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5VbmFyeU9wKFNrLmFzdG5vZGVzLkludmVydCx6LHUubGluZW5vLHUuY29sX29mZnNldCl9U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGZhY3RvclwiKX1mdW5jdGlvbiBEKHosdSx5LEcpe3ZhciBLLEksTTtnKHUsTy5hcmdsaXN0KTtmb3IoSz1NPUk9MDtLPGYodSk7SysrKXt2YXIgUj1lKHUsSyk7Ui50eXBlPT1PLmFyZ3VtZW50JiYoMT09ZihSKT9JKys6ZShSLDEpLnR5cGU9PU8uY29tcF9mb3I/KEkrKyxHfHxrKHosUixcImludmFsaWQgc3ludGF4XCIpLDE8Zih1KSYmayh6LFIsXCJHZW5lcmF0b3IgZXhwcmVzc2lvbiBtdXN0IGJlIHBhcmVudGhlc2l6ZWRcIikpOmUoUiwwKS50eXBlPT1ULlRfU1RBUj9JKys6TSsrKX12YXIgVT1cbltdO3ZhciBTPVtdO2ZvcihLPUc9TT1JPTA7SzxmKHUpO0srKylpZihSPWUodSxLKSxSLnR5cGU9PU8uYXJndW1lbnQpe3ZhciBaPWUoUiwwKTtpZigxPT1mKFIpKXtNJiYoRz9rKHosWixcInBvc2l0aW9uYWwgYXJndW1lbnQgZm9sbG93cyBrZXl3b3JkIGFyZ3VtZW50IHVucGFja2luZ1wiKTprKHosWixcInBvc2l0aW9uYWwgYXJndW1lbnQgZm9sbG93cyBrZXl3b3JkIGFyZ3VtZW50XCIpKTt2YXIgWD1WKHosWik7aWYoIVgpcmV0dXJuIG51bGw7VVtJKytdPVh9ZWxzZSBpZihaLnR5cGU9PVQuVF9TVEFSKXtpZihHKXJldHVybiBrKHosWixcIml0ZXJhYmxlIGFyZ3VtZW50IHVucGFja2luZyBmb2xsb3dzIGtleXdvcmQgYXJndW1lbnQgdW5wYWNraW5nXCIpLG51bGw7WD1WKHosZShSLDEpKTtpZighWClyZXR1cm4gbnVsbDtSPW5ldyBTay5hc3Rub2Rlcy5TdGFycmVkKFgsU2suYXN0bm9kZXMuTG9hZCxaLmxpbmVubyxaLmNvbF9vZmZzZXQpO1VbSSsrXT1SfWVsc2UgaWYoWi50eXBlPT1ULlRfRE9VQkxFU1RBUil7SysrO1xuWD1WKHosZShSLDEpKTtpZighWClyZXR1cm4gbnVsbDtSPW5ldyBTay5hc3Rub2Rlcy5rZXl3b3JkKG51bGwsWCk7U1tNKytdPVI7RysrfWVsc2UgaWYoZShSLDEpLnR5cGU9PU8uY29tcF9mb3Ipe1g9dyh6LFIpO2lmKCFYKXJldHVybiBudWxsO1VbSSsrXT1YfWVsc2V7dmFyIGFhO1g9Vih6LFopO2lmKCFYKXJldHVybiBudWxsO2lmKFguY29uc3RydWN0b3I9PT1Tay5hc3Rub2Rlcy5MYW1iZGEpcmV0dXJuIGsoeixaLFwibGFtYmRhIGNhbm5vdCBjb250YWluIGFzc2lnbm1lbnRcIiksbnVsbDtpZihYLmNvbnN0cnVjdG9yIT09U2suYXN0bm9kZXMuTmFtZSlyZXR1cm4gayh6LFosXCJrZXl3b3JkIGNhbid0IGJlIGFuIGV4cHJlc3Npb25cIiksbnVsbDtpZihhKHosWC5pZCxSLDEpKXJldHVybiBudWxsO3ZhciBtYT1YLmlkO2ZvcihhYT0wO2FhPE07YWErKylpZigoWD1TW2FhXS5hcmcpJiZYPT09bWEpcmV0dXJuIGsoeixaLFwia2V5d29yZCBhcmd1bWVudCByZXBlYXRlZFwiKSxudWxsO1g9XG5WKHosZShSLDIpKTtpZighWClyZXR1cm4gbnVsbDtSPW5ldyBTay5hc3Rub2Rlcy5rZXl3b3JkKG1hLFgpO1NbTSsrXT1SfX1yZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkNhbGwoeSxVLFMseS5saW5lbm8seS5jb2xfb2Zmc2V0KX1mdW5jdGlvbiBMKHosdSx5KXtnKHUsTy50cmFpbGVyKTtpZihlKHUsMCkudHlwZT09VC5UX0xQQVIpcmV0dXJuIDI9PWYodSk/bmV3IFNrLmFzdG5vZGVzLkNhbGwoeSxudWxsLG51bGwsdS5saW5lbm8sdS5jb2xfb2Zmc2V0KTpEKHosZSh1LDEpLHksITApO2lmKGUodSwwKS50eXBlPT1ULlRfRE9UKXt2YXIgRz1uKGUodSwxKSk7cmV0dXJuIEc/bmV3IFNrLmFzdG5vZGVzLkF0dHJpYnV0ZSh5LEcsU2suYXN0bm9kZXMuTG9hZCx1LmxpbmVubyx1LmNvbF9vZmZzZXQpOm51bGx9ZyhlKHUsMCksVC5UX0xTUUIpO2coZSh1LDIpLFQuVF9SU1FCKTt1PWUodSwxKTtpZigxPT1mKHUpKXJldHVybihHPWphKHosZSh1LDApKSk/bmV3IFNrLmFzdG5vZGVzLlN1YnNjcmlwdCh5LFxuRyxTay5hc3Rub2Rlcy5Mb2FkLHUubGluZW5vLHUuY29sX29mZnNldCk6bnVsbDt2YXIgSyxJPTEsTT1bXTtmb3IoSz0wO0s8Zih1KTtLKz0yKXtHPWphKHosZSh1LEspKTtpZighRylyZXR1cm4gbnVsbDtHLmtpbmQhPVkuSW5kZXhfa2luZCYmKEk9MCk7TVtLLzJdPUd9aWYoIUkpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5TdWJzY3JpcHQoeSxuZXcgU2suYXN0bm9kZXMuRXh0U2xpY2UoTSksU2suYXN0bm9kZXMuTG9hZCx1LmxpbmVubyx1LmNvbF9vZmZzZXQpO3o9W107Zm9yKEs9MDtLPE0ubGVuZ3RoOysrSylHPU1bS10sU2suYXNzZXJ0cy5hc3NlcnQoRy5raW5kPT1ZLkluZGV4X2tpbmQmJkcudi5JbmRleC52YWx1ZSkseltLXT1HLnYuSW5kZXgudmFsdWU7Rz1uZXcgU2suYXN0bm9kZXMuVHVwbGUoeixTay5hc3Rub2Rlcy5Mb2FkLHUubGluZW5vLHUuY29sX29mZnNldCk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5TdWJzY3JpcHQoeSxuZXcgU2suYXN0bm9kZXMuSW5kZXgoRyksXG5Tay5hc3Rub2Rlcy5Mb2FkLHUubGluZW5vLHUuY29sX29mZnNldCl9ZnVuY3Rpb24gTih6LHUpe2codSxPLmZsb3dfc3RtdCk7dmFyIHk9ZSh1LDApO3N3aXRjaCh5LnR5cGUpe2Nhc2UgTy5icmVha19zdG10OnJldHVybiBuZXcgU2suYXN0bm9kZXMuQnJlYWsodS5saW5lbm8sdS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KTtjYXNlIE8uY29udGludWVfc3RtdDpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkNvbnRpbnVlKHUubGluZW5vLHUuY29sX29mZnNldCx1LmVuZF9saW5lbm8sdS5lbmRfY29sX29mZnNldCk7Y2FzZSBPLnlpZWxkX3N0bXQ6cmV0dXJuKHo9Vih6LGUoeSwwKSkpP25ldyBTay5hc3Rub2Rlcy5FeHByKHosdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KTpudWxsO2Nhc2UgTy5yZXR1cm5fc3RtdDppZigxPT1mKHkpKXJldHVybiBuZXcgU2suYXN0bm9kZXMuUmV0dXJuKG51bGwsdS5saW5lbm8sXG51LmNvbF9vZmZzZXQsdS5lbmRfbGluZW5vLHUuZW5kX2NvbF9vZmZzZXQpO3ZhciBHPWhhKHosZSh5LDEpKTtyZXR1cm4gRz9uZXcgU2suYXN0bm9kZXMuUmV0dXJuKEcsdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KTpudWxsO2Nhc2UgTy5yYWlzZV9zdG10OmlmKDE9PWYoeSkpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5SYWlzZShudWxsLG51bGwsbnVsbCxudWxsLHUubGluZW5vLHUuY29sX29mZnNldCx1LmVuZF9saW5lbm8sdS5lbmRfY29sX29mZnNldCk7aWYoMjw9Zih5KSl7dmFyIEs9bnVsbDtHPVYoeixlKHksMSkpO3ZhciBJPW51bGwsTT1udWxsOzQ9PWYoeSkmJlwiZnJvbVwiPT1lKHksMikudmFsdWU/KFNrLl9fZnV0dXJlX18ucHl0aG9uM3x8ayh6LGUoeSwyKSxcInJhaXNlIC4uLiBmcm9tIC4uLiBpcyBub3QgYXZhaWxhYmxlIGluIFB5dGhvbiAyXCIpLEs9Vih6LGUoeSwzKSkpOjQ8PWYoeSkmJlwiLFwiPT1lKHksMikudmFsdWUmJihTay5fX2Z1dHVyZV9fLnB5dGhvbjMmJlxuayh6LHUsXCJPbGQgcmFpc2Ugc3ludGF4IGlzIG5vdCBhdmFpbGFibGUgaW4gUHl0aG9uIDNcIiksST1WKHosZSh5LDMpKSw2PT1mKHkpJiYoTT1WKHosZSh5LDUpKSkpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuUmFpc2UoRyxLLEksTSx1LmxpbmVubyx1LmNvbF9vZmZzZXQsdS5lbmRfbGluZW5vLHUuZW5kX2NvbF9vZmZzZXQpfWRlZmF1bHQ6cmV0dXJuIFNrLmFzc2VydHMuZmFpbChcInVuZXhwZWN0ZWQgZmxvd19zdG10OiBcIix5LnR5cGUpLG51bGx9fWZ1bmN0aW9uIEEoeix1KXt2YXIgeT1udWxsO1NrLmFzc2VydHMuYXNzZXJ0KHUudHlwZT09PU8udGZwZGVmfHx1LnR5cGU9PT1PLnZmcGRlZik7dmFyIEc9ZSh1LDApO2EoeixHLEcudmFsdWUsRy5saW5lbm8pO0c9cChHLnZhbHVlKTszPT1mKHUpJiZlKHUsMSkudHlwZT09PVQuVF9DT0xPTiYmKHk9Vih6LGUodSwyKSkpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuYXJnKEcseSx1LmxpbmVubyx1LmNvbF9vZmZzZXQpfWZ1bmN0aW9uIEgoeixcbnUseSxHLEspe3ZhciBJPXksTT0wO0d8fGsoeixlKHUseSksXCJuYW1lZCBhcmd1bWVudHMgbXVzdCBmb2xsb3cgYmFyZSAqXCIpO2ZvcihTay5hc3NlcnRzLmFzc2VydChLKTtJPGYodSk7KXt2YXIgUj1lKHUsSSk7c3dpdGNoKFIudHlwZSl7Y2FzZSBPLnZmcGRlZjpjYXNlIE8udGZwZGVmOkkrMTxmKHUpJiZlKHUsSSsxKS50eXBlPT1ULlRfRVFVQUw/KEtbTV09Vih6LGUodSxJKzIpKSxJKz0yKTpLW01dPW51bGw7dmFyIFU9Mz09ZihSKT9WKHosZShSLDIpKTpudWxsO1I9ZShSLDApO2EoeixSLFIudmFsdWUsUi5saW5lbm8pO3k9cChSLnZhbHVlKTtHW00rK109bmV3IFNrLmFzdG5vZGVzLmFyZyh5LFUsUi5saW5lbm8sUi5jb2xfb2Zmc2V0KTtJKz0yO2JyZWFrO2Nhc2UgVC5UX0RPVUJMRVNUQVI6cmV0dXJuIEk7ZGVmYXVsdDprKHosUixcInVuZXhwZWN0ZWQgbm9kZVwiKX19cmV0dXJuIEl9ZnVuY3Rpb24geCh6LHUpe3ZhciB5LEcsSyxJPVtdLE09W10sUj1bXSxVPVtdLFM9bnVsbCxcblo9bnVsbDtpZih1LnR5cGU9PT1PLnBhcmFtZXRlcnMpe2lmKDI9PT1mKHUpKXJldHVybiBuZXcgU2suYXN0bm9kZXMuYXJndW1lbnRzXyhbXSxudWxsLFtdLFtdLG51bGwsW10pO3U9ZSh1LDEpfVNrLmFzc2VydHMuYXNzZXJ0KHUudHlwZT09PU8udmFyYXJnc2xpc3R8fHUudHlwZT09PU8udHlwZWRhcmdzbGlzdCk7Zm9yKHk9Rz1LPTA7SzxmKHUpOyl7dmFyIFg9ZSh1LEspO3N3aXRjaChYLnR5cGUpe2Nhc2UgTy50ZnBkZWY6Y2FzZSBPLnZmcGRlZjppZihLKzE8Zih1KSYmZSh1LEsrMSkudHlwZT09VC5UX0VRVUFMKXtNW0crK109Vih6LGUodSxLKzIpKTtLKz0yO3ZhciBhYT0xfWVsc2UgaWYoYWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJub24tZGVmYXVsdCBhcmd1bWVudCBmb2xsb3dzIGRlZmF1bHQgYXJndW1lbnRcIix6LmNfZmlsZW5hbWUsdS5saW5lbm8pO0lbeSsrXT1BKHosWCk7Sys9MjticmVhaztjYXNlIFQuVF9TVEFSOmlmKEsrMT49Zih1KXx8SysyPT1cbmYodSkmJmUodSxLKzEpLnR5cGU9PVQuVF9DT01NQSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5hbWVkIGFyZ3VtZW50cyBtdXN0IGZvbGxvdyBiYXJlICpcIix6LmNfZmlsZW5hbWUsdS5saW5lbm8pO1g9ZSh1LEsrMSk7WC50eXBlPT1ULlRfQ09NTUE/KEsrPTIsSz1IKHosdSxLLFIsVSkpOihTPUEoeixYKSxLKz0zLEs8Zih1KSYmKGUodSxLKS50eXBlPT1PLnRmcGRlZnx8ZSh1LEspLnR5cGU9PU8udmZwZGVmKSYmKEs9SCh6LHUsSyxSLFUpKSk7YnJlYWs7Y2FzZSBULlRfRE9VQkxFU1RBUjpYPWUodSxLKzEpO1NrLmFzc2VydHMuYXNzZXJ0KFgudHlwZT09Ty50ZnBkZWZ8fFgudHlwZT09Ty52ZnBkZWYpO1o9QSh6LFgpO0srPTM7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmV4cGVjdGVkIG5vZGUgaW4gdmFyYXJnc2xpc3RcIik7cmV0dXJufX1yZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFyZ3VtZW50c18oSSxTLFIsVSxaLE0pfWZ1bmN0aW9uIEIoeixcbnUseSxHKXt2YXIgSz1HP2UodSwxKTp1LEk9bnVsbCxNPTEsUj1udWxsO2lmKEcmJjU+ei5jX2ZlYXR1cmVfdmVyc2lvbilyZXR1cm4gayh6LEssXCJBc3luYyBmdW5jdGlvbnMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIFB5dGhvbiAzLjUgYW5kIGdyZWF0ZXJcIiksbnVsbDtnKEssTy5mdW5jZGVmKTt2YXIgVT1uKGUoSyxNKSk7aWYoYSh6LFUsZShLLE0pLDApKXJldHVybiBudWxsO3ZhciBTPXgoeixlKEssTSsxKSk7aWYoIVMpcmV0dXJuIG51bGw7aWYoZShLLE0rMikudHlwZT09VC5UX1JBUlJPVyl7ST1WKHosZShLLE0rMykpO2lmKCFJKXJldHVybiBudWxsO00rPTJ9aWYoZShLLE0rMykudHlwZT09VC5UX1RZUEVfQ09NTUVOVCl7Uj1ULlRfTkVXX1RZUEVfQ09NTUVOVChlKEssTSszKSk7aWYoIVIpcmV0dXJuIG51bGw7TSs9MX12YXIgWj12KHosZShLLE0rMykpO2lmKCFaKXJldHVybiBudWxsO2lmKDE8ZihlKEssTSszKSkmJihNPWUoZShLLE0rMyksMSksTS50eXBlPT1ULlRfVFlQRV9DT01NRU5UKSl7aWYobnVsbCE9XG5SKXJldHVybiBrKHosSyxcIkNhbm5vdCBoYXZlIHR3byB0eXBlIGNvbW1lbnRzIG9uIGRlZlwiKSxudWxsO1I9VC5UX05FV19UWVBFX0NPTU1FTlQoTSk7aWYoIVIpcmV0dXJuIG51bGx9cmV0dXJuIEc/bmV3IFNrLmFzdG5vZGVzLkFzeW5jRnVuY3Rpb25EZWYoVSxTLFoseSxJLFIsdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHZvaWQgMCx2b2lkIDApOm5ldyBTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZihVLFMsWix5LEksUixLLmxpbmVubyxLLmNvbF9vZmZzZXQsdm9pZCAwLHZvaWQgMCl9ZnVuY3Rpb24gRih6LHUseSl7Zyh1LE8uY2xhc3NkZWYpO2lmKDQ9PWYodSkpe3ZhciBHPXYoeixlKHUsMykpO3ZhciBLPW4oZSh1LDEpLnZhbHVlKTthKHosZSh1LDMpLEssdS5saW5lbm8pO3JldHVybiBuZXcgU2suYXN0bm9kZXMuQ2xhc3NEZWYoSyxbXSxbXSxHLHksbnVsbCx1LmxpbmVubyx1LmNvbF9vZmZzZXQpfWlmKGUodSwzKS50eXBlPT09VC5UX1JQQVIpcmV0dXJuIEc9dih6LGUodSw1KSksSz1cbm4oZSh1LDEpLnZhbHVlKSxhKHosZSh1LDMpLEssZSh1LDMpLmxpbmVubyksbmV3IFNrLmFzdG5vZGVzLkNsYXNzRGVmKEssW10sW10sRyx5LG51bGwsdS5saW5lbm8sdS5jb2xfb2Zmc2V0KTtLPW4oZSh1LDEpKTtLPW5ldyBTay5hc3Rub2Rlcy5OYW1lKEssU2suYXN0bm9kZXMuTG9hZCx1LmxpbmVubyx1LmNvbF9vZmZzZXQpO3ZhciBJPUQoeixlKHUsMyksSywhMSk7Rz12KHosZSh1LDYpKTtLPW4oZSh1LDEpLnZhbHVlKTthKHosZSh1LDEpLEssZSh1LDEpLmxpbmVubyk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5DbGFzc0RlZihLLEkuYXJncyxJLmtleXdvcmRzLEcseSxudWxsLHUubGluZW5vLHUuY29sX29mZnNldCl9ZnVuY3Rpb24gSih6LHUpe2Z1bmN0aW9uIHkoWCxhYSl7Zm9yKFg9MDs7KXtnKGFhLE8uY29tcF9pdGVyKTtpZihlKGFhLDApLnR5cGU9PT1PLmNvbXBfZm9yKXJldHVybiBYO2FhPWUoYWEsMCk7ZyhhYSxPLmNvbXBfaWYpO1grKztpZigyPT09ZihhYSkpcmV0dXJuIFg7XG5hYT1lKGFhLDIpfX12YXIgRzt2YXIgSz1mdW5jdGlvbihYLGFhKXtYPTA7YTpmb3IoOzspe1grKztnKGFhLE8uY29tcF9mb3IpO2lmKDU9PT1mKGFhKSlhYT1lKGFhLDQpO2Vsc2UgcmV0dXJuIFg7Yjpmb3IoOzspe2coYWEsTy5jb21wX2l0ZXIpO2FhPWUoYWEsMCk7aWYoYWEudHlwZT09PU8uY29tcF9mb3IpY29udGludWUgYTtlbHNlIGlmKGFhLnR5cGU9PT1PLmNvbXBfaWYpaWYoMz09PWYoYWEpKXthYT1lKGFhLDIpO2NvbnRpbnVlIGJ9ZWxzZSByZXR1cm4gWDticmVha31icmVha31Tay5hc3NlcnRzLmZhaWwoXCJsb2dpYyBlcnJvciBpbiBjb3VudENvbXBGb3JzXCIpfSh6LHUpO3ZhciBJPVtdO2ZvcihHPTA7RzxLOysrRyl7Zyh1LE8uY29tcF9mb3IpO3ZhciBNPWUodSwxKTt2YXIgUj1xKHosTSxTay5hc3Rub2Rlcy5TdG9yZSk7dmFyIFU9Vih6LGUodSwzKSk7dmFyIFM9MT09PWYoTSk/bmV3IFNrLmFzdG5vZGVzLmNvbXByZWhlbnNpb24oUlswXSxVLFtdKTpuZXcgU2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbihuZXcgU2suYXN0bm9kZXMuVHVwbGUoUixcblNrLmFzdG5vZGVzLlN0b3JlLHUubGluZW5vLHUuY29sX29mZnNldCksVSxbXSk7aWYoNT09PWYodSkpe3U9ZSh1LDQpO3ZhciBaPXkoeix1KTtNPVtdO2ZvcihSPTA7UjxaOysrUilnKHUsTy5jb21wX2l0ZXIpLHU9ZSh1LDApLGcodSxPLmNvbXBfaWYpLFU9Vih6LGUodSwxKSksTVtSXT1VLDM9PT1mKHUpJiYodT1lKHUsMikpO3UudHlwZT09PU8uY29tcF9pdGVyJiYodT1lKHUsMCkpO1MuaWZzPU19SVtHXT1TfXJldHVybiBJfWZ1bmN0aW9uIFAoeix1KXt2YXIgeT1bXTthOnt2YXIgRz11O3ZhciBLPTA7Yjpmb3IoOzspe3ZhciBJPTA7SysrO2coRyxPLmNvbXBfZm9yKTtlKEcsMCkudHlwZT09VC5UX0FTWU5DJiYoST0xKTtpZihmKEcpPT01K0kpRz1lKEcsNCtJKTtlbHNlIGJyZWFrIGE7Yzpmb3IoOzspe2coRyxPLmNvbXBfaXRlcik7Rz1lKEcsMCk7aWYoRy50eXBlPT09Ty5jb21wX2Zvciljb250aW51ZSBiO2Vsc2UgaWYoRy50eXBlPT09Ty5jb21wX2lmKWlmKDM9PT1mKEcpKXtHPVxuZShHLDIpO2NvbnRpbnVlIGN9ZWxzZSBicmVhayBhO2JyZWFrfWJyZWFrfUs9dm9pZCAwfWZvcihHPTA7RzxLO0crKyl7dmFyIE09MDtlKHUsMCkudHlwZT09VC5UX0FTWU5DJiYoTT0xKTt2YXIgUj1lKHUsMStNKTt2YXIgVT1xKHosUixTay5hc3Rub2Rlcy5TdG9yZSk7aWYoIVUpcmV0dXJuIG51bGw7ST1WKHosZSh1LDMrTSkpO2lmKCFJKXJldHVybiBudWxsO3ZhciBTPVVbMF07VT0xPT1mKFIpP25ldyBTay5hc3Rub2Rlcy5jb21wcmVoZW5zaW9uKFMsSSxudWxsLE0pOm5ldyBTay5hc3Rub2Rlcy5jb21wcmVoZW5zaW9uKG5ldyBTay5hc3Rub2Rlcy5UdXBsZShVLFNrLmFzdG5vZGVzLlN0b3JlLFMubGluZW5vLFMuY29sX29mZnNldCxSLmVuZF9saW5lbm8sUi5lbmRfY29sX29mZnNldCksSSxudWxsLE0pO2lmKGYodSk9PTUrTSl7Uz1bXTt1PWUodSw0K00pO2E6Zm9yKEk9dSxNPTA7Oyl7ZyhJLE8uY29tcF9pdGVyKTtpZihlKEksMCkudHlwZT09Ty5jb21wX2Zvcil7Uj1NO2JyZWFrIGF9ST1cbmUoSSwwKTtnKEksTy5jb21wX2lmKTtNKys7aWYoMj09ZihJKSl7Uj1NO2JyZWFrIGF9ST1lKEksMil9aWYoLTE9PVIpcmV0dXJuIG51bGw7Zm9yKE09MDtNPFI7TSsrKXtnKHUsTy5jb21wX2l0ZXIpO3U9ZSh1LDApO2codSxPLmNvbXBfaWYpO0k9Vih6LGUodSwxKSk7aWYoIUkpcmV0dXJuIG51bGw7U1tNXT1JOzM9PWYodSkmJih1PWUodSwyKSl9dS50eXBlPT1PLmNvbXBfaXRlciYmKHU9ZSh1LDApKTtVLmlmcz1TfXlbR109VX1yZXR1cm4geX1mdW5jdGlvbiBXKHosdSx5KXtTay5hc3NlcnRzLmFzc2VydCgxPGYodSkpO3ZhciBHPWUodSwwKTt2YXIgSz1WKHosRyk7aWYoSy5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQpcmV0dXJuIGsoeixHLFwiaXRlcmFibGUgdW5wYWNraW5nIGNhbm5vdCBiZSB1c2VkIGluIGNvbXByZWhlbnNpb25cIiksbnVsbDt6PVAoeixlKHUsMSkpO3JldHVybiAwPT15P25ldyBTay5hc3Rub2Rlcy5HZW5lcmF0b3JFeHAoSyx6LHUubGluZW5vLFxudS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KToxPT15P25ldyBTay5hc3Rub2Rlcy5MaXN0Q29tcChLLHosdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KToyPT15P25ldyBTay5hc3Rub2Rlcy5TZXRDb21wKEsseix1LmxpbmVubyx1LmNvbF9vZmZzZXQsdS5lbmRfbGluZW5vLHUuZW5kX2NvbF9vZmZzZXQpOm51bGx9ZnVuY3Rpb24gY2Eoeix1KXtnKHUsTy5hdWdhc3NpZ24pO3U9ZSh1LDApO3N3aXRjaCh1LnZhbHVlLmNoYXJBdCgwKSl7Y2FzZSBcIitcIjpyZXR1cm4gU2suYXN0bm9kZXMuQWRkO2Nhc2UgXCItXCI6cmV0dXJuIFNrLmFzdG5vZGVzLlN1YjtjYXNlIFwiL1wiOnJldHVyblwiL1wiPT09dS52YWx1ZS5jaGFyQXQoMSk/U2suYXN0bm9kZXMuRmxvb3JEaXY6U2suYXN0bm9kZXMuRGl2O2Nhc2UgXCIlXCI6cmV0dXJuIFNrLmFzdG5vZGVzLk1vZDtjYXNlIFwiPFwiOnJldHVybiBTay5hc3Rub2Rlcy5MU2hpZnQ7Y2FzZSBcIj5cIjpyZXR1cm4gU2suYXN0bm9kZXMuUlNoaWZ0O1xuY2FzZSBcIiZcIjpyZXR1cm4gU2suYXN0bm9kZXMuQml0QW5kO2Nhc2UgXCJeXCI6cmV0dXJuIFNrLmFzdG5vZGVzLkJpdFhvcjtjYXNlIFwifFwiOnJldHVybiBTay5hc3Rub2Rlcy5CaXRPcjtjYXNlIFwiKlwiOnJldHVyblwiKlwiPT09dS52YWx1ZS5jaGFyQXQoMSk/U2suYXN0bm9kZXMuUG93OlNrLmFzdG5vZGVzLk11bHQ7Y2FzZSBcIkBcIjppZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpcmV0dXJuIFNrLmFzdG5vZGVzLk1hdE11bHQ7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJpbnZhbGlkIGF1Z2Fzc2lnblwiKX19ZnVuY3Rpb24gaGEoeix1KXtTay5hc3NlcnRzLmFzc2VydCgwPGYodSkpO3UudHlwZT09PU8udGVzdGxpc3RfY29tcD8xPGYodSkmJlNrLmFzc2VydHMuYXNzZXJ0KGUodSwxKS50eXBlIT09Ty5jb21wX2Zvcik6U2suYXNzZXJ0cy5hc3NlcnQodS50eXBlPT09Ty50ZXN0bGlzdHx8dS50eXBlPT09Ty50ZXN0bGlzdF9zdGFyX2V4cHIpO3JldHVybiAxPT09Zih1KT9WKHosZSh1LDApKTpcbm5ldyBTay5hc3Rub2Rlcy5UdXBsZShyKHosdSksU2suYXN0bm9kZXMuTG9hZCx1LmxpbmVubyx1LmNvbF9vZmZzZXQpfWZ1bmN0aW9uIG9hKHosdSl7Zyh1LE8uZXhwcl9zdG10KTtpZigxPT09Zih1KSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkV4cHIoaGEoeixlKHUsMCkpLHUubGluZW5vLHUuY29sX29mZnNldCk7aWYoZSh1LDEpLnR5cGU9PT1PLmF1Z2Fzc2lnbil7dmFyIHk9ZSh1LDApO3ZhciBHPWhhKHoseSk7Yyh6LEcsU2suYXN0bm9kZXMuU3RvcmUseSk7c3dpdGNoKEcuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuTmFtZTp2YXIgSz1HLmlkO2Eoeix5LEssdS5saW5lbm8pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOmNhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYXVnbWVudGVkIGFzc2lnbm1lbnQgdG8gZ2VuZXJhdG9yIGV4cHJlc3Npb24gbm90IHBvc3NpYmxlXCIsXG56LmNfZmlsZW5hbWUsdS5saW5lbm8pO2Nhc2UgU2suYXN0bm9kZXMuWWllbGQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhdWdtZW50ZWQgYXNzaWdubWVudCB0byB5aWVsZCBleHByZXNzaW9uIG5vdCBwb3NzaWJsZVwiLHouY19maWxlbmFtZSx1LmxpbmVubyk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImlsbGVnYWwgZXhwcmVzc2lvbiBmb3IgYXVnbWVudGVkIGFzc2lnbm1lbnRcIix6LmNfZmlsZW5hbWUsdS5saW5lbm8pO315PWUodSwyKTtLPXkudHlwZT09PU8udGVzdGxpc3Q/aGEoeix5KTpWKHoseSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5BdWdBc3NpZ24oRyxjYSh6LGUodSwxKSksSyx1LmxpbmVubyx1LmNvbF9vZmZzZXQpfWlmKGUodSwxKS50eXBlPT09Ty5hbm5hc3NpZ24pe2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJBbm5vdGF0ZWQgYXNzaWdubWVudCBpcyBub3Qgc3VwcG9ydGVkIGluIFB5dGhvbiAyXCIsXG56LmNfZmlsZW5hbWUsdS5saW5lbm8pO3k9ZSh1LDApO3ZhciBJPWUodSwxKTt2YXIgTT0xO2ZvcihHPXk7MT09ZihHKTspRz1lKEcsMCk7MDxmKEcpJiZlKEcsMCkudHlwZT09VC5UX0xQQVImJihNPTApO0c9aGEoeix5KTtzd2l0Y2goRy5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOks9Ry5pZDthKHoseSxLLHUubGluZW5vKTtjKHosRyxTay5hc3Rub2Rlcy5TdG9yZSx5KTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkF0dHJpYnV0ZTpLPUcuYXR0cjthKHoseSxLLHUubGluZW5vKTtjKHosRyxTay5hc3Rub2Rlcy5TdG9yZSx5KTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlN1YnNjcmlwdDpjKHosRyxTay5hc3Rub2Rlcy5TdG9yZSx5KTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkxpc3Q6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJvbmx5IHNpbmdsZSB0YXJnZXQgKG5vdCBsaXN0KSBjYW4gYmUgYW5ub3RhdGVkXCIsei5jX2ZpbGVuYW1lLHUubGluZW5vKTtcbmNhc2UgU2suYXN0bm9kZXMuVHVwbGU6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJvbmx5IHNpbmdsZSB0YXJnZXQgKG5vdCB0dXBsZSkgY2FuIGJlIGFubm90YXRlZFwiLHouY19maWxlbmFtZSx1LmxpbmVubyk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImlsbGVnYWwgdGFyZ2V0IGZvciBhbm5vdGF0aW9uXCIsei5jX2ZpbGVuYW1lLHUubGluZW5vKTt9Ry5jb25zdHJ1Y3RvciE9U2suYXN0bm9kZXMuTmFtZSYmKE09MCk7eT1lKEksMSk7Sz1WKHoseSk7aWYoMj09ZihJKSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkFubkFzc2lnbihHLEssbnVsbCxNLHUubGluZW5vLHUuY29sX29mZnNldCk7eT1lKEksMyk7ej1WKHoseSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Bbm5Bc3NpZ24oRyxLLHosTSx1LmxpbmVubyx1LmNvbF9vZmZzZXQpfWcoZSh1LDEpLFQuVF9FUVVBTCk7TT1bXTtmb3IoRz0wO0c8Zih1KS0yO0crPTIpe3k9ZSh1LEcpO2lmKHkudHlwZT09PVxuTy55aWVsZF9leHByKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYXNzaWdubWVudCB0byB5aWVsZCBleHByZXNzaW9uIG5vdCBwb3NzaWJsZVwiLHouY19maWxlbmFtZSx1LmxpbmVubyk7eT1oYSh6LHkpO2Moeix5LFNrLmFzdG5vZGVzLlN0b3JlLGUodSxHKSk7TVtHLzJdPXl9eT1lKHUsZih1KS0xKTt6PXkudHlwZT09PU8udGVzdGxpc3Rfc3Rhcl9leHByP2hhKHoseSk6Vih6LHkpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuQXNzaWduKE0seix1LmxpbmVubyx1LmNvbF9vZmZzZXQpfWZ1bmN0aW9uIGthKHosdSx5LEcsSyl7U2suYXNzZXJ0cy5hc3NlcnQoeT49dSk7U2suYXNzZXJ0cy5hc3NlcnQoXCJ7XCI9PXouY2hhckF0KHUtMSkpO1NrLmFzc2VydHMuYXNzZXJ0KFwifVwiPT16LmNoYXJBdCh5KXx8XCIhXCI9PXouY2hhckF0KHkpfHxcIjpcIj09ei5jaGFyQXQoeSkpO3o9ei5zdWJzdHJpbmcodSx5KTsvXlxccyokLy50ZXN0KHopJiZrKEcsSyxcImYtc3RyaW5nOiBlbXB0eSBleHByZXNzaW9uIG5vdCBhbGxvd2VkXCIpO1xudHJ5e2xldCBNPVNrLnBhcnNlKFwiPGZzdHJpbmc+XCIsXCIoXCIreitcIilcIik7dmFyIEk9U2suYXN0RnJvbVBhcnNlKE0uY3N0LFwiPGZzdHJpbmc+XCIsTS5mbGFncyl9Y2F0Y2goTSl7dGhyb3cgTS50cmFjZWJhY2smJk0udHJhY2ViYWNrWzBdJiYoST1NLnRyYWNlYmFja1swXSxJLmxpbmVubz0oSS5saW5lbm98fDEpLTErSy5saW5lbm8sSS5maWxlbmFtZT1HLmNfZmlsZW5hbWUpLE07fVNrLmFzc2VydHMuYXNzZXJ0KDE9PUkuYm9keS5sZW5ndGgmJkkuYm9keVswXS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLkV4cHIpO3JldHVybiBJLmJvZHlbMF0udmFsdWV9ZnVuY3Rpb24gaWEoeix1LHksRyxLLEksTSl7U2suYXNzZXJ0cy5hc3NlcnQoXCJ7XCI9PXouY2hhckF0KHUpKTt1Kys7dmFyIFI9dTtsZXQgVT1udWxsLFM9MCxaPTAsWCxhYSxtYT0oKT0+ayhJLE0sXCJmLXN0cmluZzogZXhwZWN0aW5nICd9J1wiKTtmb3IoU2suYXNzZXJ0cy5hc3NlcnQodTw9eSk7dTx5O3UrKyl7bGV0IGVhPXouY2hhckF0KHUpO1xuXCJcXFxcXCI9PWVhJiZrKEksTSxcImYtc3RyaW5nIGV4cHJlc3Npb24gcGFydCBjYW5ub3QgaW5jbHVkZSBhIGJhY2tzbGFzaFwiKTtpZihVKWVhPT1VJiYoMz09Uz91KzI8eSYmei5jaGFyQXQodSsxKT09ZWEmJnouY2hhckF0KHUrMik9PWVhJiYodSs9MixVPVM9MCk6Uz1VPTApO2Vsc2UgaWYoXCInXCI9PWVhfHwnXCInPT1lYSl1KzI8eSYmei5jaGFyQXQodSsxKT09ZWEmJnouY2hhckF0KHUrMik9PWVhPyhTPTMsdSs9Mik6Uz0xLFU9ZWE7ZWxzZSBpZihcIltcIj09ZWF8fFwie1wiPT1lYXx8XCIoXCI9PWVhKVorKztlbHNlIGlmKDAhPVomJihcIl1cIj09ZWF8fFwifVwiPT1lYXx8XCIpXCI9PWVhKSlaLS07ZWxzZSBpZihcIiNcIj09ZWEpayhJLE0sXCJmLXN0cmluZyBleHByZXNzaW9uIHBhcnQgY2Fubm90IGluY2x1ZGUgJyMnXCIpO2Vsc2UgaWYoISgwIT1afHxcIiFcIiE9ZWEmJlwiOlwiIT1lYSYmXCJ9XCIhPWVhfHxcIiFcIj09ZWEmJnUrMTx5JiZcIj1cIj09ei5jaGFyQXQodSsxKSkpYnJlYWt9VSYmayhJLE0sXCJmLXN0cmluZzogdW50ZXJtaW5hdGVkIHN0cmluZ1wiKTtcblomJmsoSSxNLFwiZi1zdHJpbmc6IG1pc21hdGNoZWQgJygnLCAneycsIG9yICdbJ1wiKTtSPWthKHosUix1LEksTSk7XCIhXCI9PXouY2hhckF0KHUpJiYodSsrLHU+PXkmJm1hKCksYWE9ei5jaGFyQXQodSksdSsrLFwic1wiIT1hYSYmXCJyXCIhPWFhJiZcImFcIiE9YWEmJmsoSSxNLFwiZi1zdHJpbmc6IGludmFsaWQgY29udmVyc2lvbiBjaGFyYWN0ZXI6IGV4cGVjdGVkICdzJywgJ3InLCBvciAnYSdcIikpO3U+PXkmJm1hKCk7XCI6XCI9PXouY2hhckF0KHUpJiYodSsrLHU+PXkmJm1hKCksW1gsdV09YmEoeix1LHksRyxLKzEsSSxNKSk7KHU+PXl8fFwifVwiIT16LmNoYXJBdCh1KSkmJm1hKCk7dSsrO3JldHVybltuZXcgU2suYXN0bm9kZXMuRm9ybWF0dGVkVmFsdWUoUixhYSxYLE0ubGluZW5vLE0uY29sX29mZnNldCksdV19ZnVuY3Rpb24gYmEoeix1LHksRyxLLEksTSl7bGV0IFI9W10sVT1TPT57aWYoLTEhPT1TLmluZGV4T2YoXCJ9XCIpKXtpZigvKF58W159XSl9KH19KSooJHxbXn1dKS8udGVzdChTKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImYtc3RyaW5nOiBzaW5nbGUgJ30nIGlzIG5vdCBhbGxvd2VkXCIsXG5JLmNfZmlsZW5hbWUsTS5saW5lbm8sTS5jb2xfb2Zmc2V0KTtTPVMucmVwbGFjZSgvfX0vZyxcIn1cIil9Ui5wdXNoKG5ldyBTay5hc3Rub2Rlcy5TdHIobmV3IFNrLmJ1aWx0aW4uc3RyKFMpLE0ubGluZW5vLE0uY29sX29mZnNldCxJLmVuZF9saW5lbm8sTS5lbmRfY29sX29mZnNldCkpfTtmb3IoO3U8eTspe2xldCBTPXouaW5kZXhPZihcIntcIix1KTtpZigwIT09Syl7bGV0IFo9ei5pbmRleE9mKFwifVwiLHUpOy0xIT09WiYmKC0xPT09Uz95PVo6Uz5aJiYoUz0tMSx5PVopKX1pZigtMT09PVMpe1Uoei5zdWJzdHJpbmcodSx5KSk7dT15O2JyZWFrfWVsc2UgaWYoUysxPHkmJlwie1wiPT09ei5jaGFyQXQoUysxKSlVKHouc3Vic3RyaW5nKHUsUysxKSksdT1TKzI7ZWxzZXtVKHouc3Vic3RyaW5nKHUsUykpO3U9UztsZXQgW1osWF09aWEoeixTLHksRyxLLEksTSk7Ui5wdXNoKFopO3U9WH19cmV0dXJuW25ldyBTay5hc3Rub2Rlcy5Kb2luZWRTdHIoUixNLmxpbmVubyxNLmNvbF9vZmZzZXQpLFxudV19ZnVuY3Rpb24gamEoeix1KXt2YXIgeSxHO2codSxPLnN1YnNjcmlwdCk7dmFyIEs9ZSh1LDApO3ZhciBJPXk9Rz1udWxsO2lmKEsudHlwZT09PVQuVF9ET1QpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5FbGxpcHNpcztpZigxPT09Zih1KSYmSy50eXBlPT09Ty50ZXN0KXJldHVybiBuZXcgU2suYXN0bm9kZXMuSW5kZXgoVih6LEspKTtLLnR5cGU9PT1PLnRlc3QmJihHPVYoeixLKSk7Sy50eXBlPT09VC5UX0NPTE9OPzE8Zih1KSYmKEs9ZSh1LDEpLEsudHlwZT09PU8udGVzdCYmKHk9Vih6LEspKSk6MjxmKHUpJiYoSz1lKHUsMiksSy50eXBlPT09Ty50ZXN0JiYoeT1WKHosSykpKTtLPWUodSxmKHUpLTEpO0sudHlwZT09PU8uc2xpY2VvcCYmKDE9PT1mKEspPyhLPWUoSywwKSxJPW5ldyBTay5hc3Rub2Rlcy5OYW1lQ29uc3RhbnQoU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmFzdG5vZGVzLkxvYWQsSy5saW5lbm8sSy5jb2xfb2Zmc2V0KSk6KEs9ZShLLDEpLEsudHlwZT09PU8udGVzdCYmXG4oST1WKHosSykpKSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5TbGljZShHLHksSSl9ZnVuY3Rpb24gbmEoeix1KXt2YXIgeT1lKHUsMCk7c3dpdGNoKHkudHlwZSl7Y2FzZSBULlRfTkFNRTp2YXIgRz15LnZhbHVlO2lmKDQ8PUcubGVuZ3RoJiY1Pj1HLmxlbmd0aCl7aWYoXCJOb25lXCI9PT1HKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50KFNrLmJ1aWx0aW4ubm9uZS5ub25lJCx1LmxpbmVubyx1LmNvbF9vZmZzZXQpO2lmKFwiVHJ1ZVwiPT09RylyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudChTay5idWlsdGluLmJvb2wudHJ1ZSQsdS5saW5lbm8sdS5jb2xfb2Zmc2V0KTtpZihcIkZhbHNlXCI9PT1HKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50KFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQsdS5saW5lbm8sdS5jb2xfb2Zmc2V0KX16PW4oRyx6KTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk5hbWUoeixTay5hc3Rub2Rlcy5Mb2FkLHUubGluZW5vLFxudS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KTtjYXNlIFQuVF9TVFJJTkc6eT1bXTtmb3IodmFyIEs9MDtLPGYodSk7KytLKXt2YXIgST1lKHUsSykudmFsdWU7dmFyIE09ejt2YXIgUj1lKHUsSyk7dmFyIFU9STt2YXIgUz1VLmNoYXJBdCgwKTtmb3IodmFyIFo9ITEsWD1JPSExOzspe2lmKFwidVwiIT09UyYmXCJVXCIhPT1TKWlmKFwiclwiPT09U3x8XCJSXCI9PT1TKVo9ITA7ZWxzZSBpZihcImJcIj09PVN8fFwiQlwiPT09UylYPSEwO2Vsc2UgaWYoXCJmXCI9PT1TfHxcIkZcIj09PVMpST0hMDtlbHNlIGJyZWFrO1U9VS5zdWJzdHIoMSk7Uz1VLmNoYXJBdCgwKX1Tay5hc3NlcnRzLmFzc2VydChcIidcIj09PVN8fCdcIic9PT1TJiZVLmNoYXJBdChVLmxlbmd0aC0xKT09PVMpO1U9VS5zdWJzdHIoMSxVLmxlbmd0aC0yKTs0PD1VLmxlbmd0aCYmVS5jaGFyQXQoMCk9PT1TJiZVLmNoYXJBdCgxKT09PVMmJihTay5hc3NlcnRzLmFzc2VydChVLmNoYXJBdChVLmxlbmd0aC0xKT09PVMmJlxuVS5jaGFyQXQoVS5sZW5ndGgtMik9PT1TKSxVPVUuc3Vic3RyKDIsVS5sZW5ndGgtNCkpO2lmKFp8fC0xPT09VS5pbmRleE9mKFwiXFxcXFwiKSl7aWYoWClmb3IoUz0wO1M8VS5sZW5ndGg7UysrKTEyNzxVLmNoYXJDb2RlQXQoUykmJmsoTSxSLFwiYnl0ZXMgY2FuIG9ubHkgY29udGFpbiBBU0NJSSBsaXRlcmFsIGNoYXJhY3RlcnNcIik7TT1bcChVKSxJLFhdfWVsc2V7Wj1VO3ZhciBhYT1aLmxlbmd0aCxtYT1cIlwiO2ZvcihVPTA7VTxhYTsrK1UpUz1aLmNoYXJBdChVKSxcIlxcXFxcIj09PVM/KCsrVSxTPVouY2hhckF0KFUpLFwiblwiPT09Uz9tYSs9XCJcXG5cIjpcIlxcXFxcIj09PVM/bWErPVwiXFxcXFwiOlwidFwiPT09Uz9tYSs9XCJcXHRcIjpcInJcIj09PVM/bWErPVwiXFxyXCI6XCJiXCI9PT1TP21hKz1cIlxcYlwiOlwiZlwiPT09Uz9tYSs9XCJcXGZcIjpcInZcIj09PVM/bWErPVwiXFx2XCI6XCIwXCI9PT1TP21hKz1cIlxceDAwXCI6J1wiJz09PVM/bWErPSdcIic6XCInXCI9PT1TP21hKz1cIidcIjpcIlxcblwiIT09UyYmKFwieFwiPT09Uz8oVSsyPj1hYSYmayhNLFIsXCJUcnVuY2F0ZWQgXFxcXHhOTiBlc2NhcGVcIiksXG5tYSs9U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChaLnN1YnN0cihVKzEsMiksMTYpKSxVKz0yKTpYfHxcInVcIiE9PVM/WHx8XCJVXCIhPT1TP21hKz1cIlxcXFxcIitTOihVKzg+PWFhJiZrKE0sUixcIlRydW5jYXRlZCBcXFxcVVhYWFhYWFhYIGVzY2FwZVwiKSxtYSs9U3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoWi5zdWJzdHIoVSsxLDgpLDE2KSksVSs9OCk6KFUrND49YWEmJmsoTSxSLFwiVHJ1bmNhdGVkIFxcXFx1WFhYWCBlc2NhcGVcIiksbWErPVN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoWi5zdWJzdHIoVSsxLDQpLDE2KSksVSs9NCkpKTpYJiYxMjc8Uy5jaGFyQ29kZUF0KDApP2soTSxSLFwiYnl0ZXMgY2FuIG9ubHkgY29udGFpbiBBU0NJSSBsaXRlcmFsIGNoYXJhY3RlcnNcIik6bWErPVM7TT1tYTtNPVtwKE0pLEksWF19ST1NO009SVswXTtSPUlbMV07ST1JWzJdOzAhPUsmJkchPT1JJiZrKHosdSxcImNhbm5vdCBtaXggYnl0ZXMgYW5kIG5vbmJ5dGVzIGxpdGVyYWxzXCIpO0c9STtcbmlmKFIpe2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJpbnZhbGlkIHN0cmluZyAoZi1zdHJpbmdzIGFyZSBub3Qgc3VwcG9ydGVkIGluIFB5dGhvbiAyKVwiLHouY19maWxlbmFtZSxlKHUsSykubGluZW5vKTt2YXIgZWE9TS4kanNzdHIoKTtbZWFdPWJhKGVhLDAsZWEubGVuZ3RoLCExLDAseixlKHUsSykpO3kucHVzaC5hcHBseSh5LGVhLnZhbHVlcyk7ZWE9bnVsbH1lbHNlIGVhP2VhLnM9ZWEucy5zcSRjb25jYXQoTSk6KGVhPW5ldyAoRz9Tay5hc3Rub2Rlcy5CeXRlczpTay5hc3Rub2Rlcy5TdHIpKE0sdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHouZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KSx5LnB1c2goZWEpKX11PTE9PT15Lmxlbmd0aCYmeVswXS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0cj95WzBdOm5ldyBTay5hc3Rub2Rlcy5Kb2luZWRTdHIoeSx1LmxpbmVubyx1LmNvbF9vZmZzZXQsei5lbmRfbGluZW5vLFxudS5lbmRfY29sX29mZnNldCk7cmV0dXJuIHU7Y2FzZSBULlRfTlVNQkVSOno9U2suYXN0bm9kZXMuTnVtO0c9eS52YWx1ZTtHPUcucmVwbGFjZShwYSxcIlwiKTtLPUdbRy5sZW5ndGgtMV07aWYoXCJqXCI9PT1LfHxcIkpcIj09PUspRz1uZXcgU2suYnVpbHRpbi5jb21wbGV4KDAscGFyc2VGbG9hdChHLnNsaWNlKDAsLTEpKSk7ZWxzZSBpZihxYS50ZXN0KEcpKUc9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHBhcnNlRmxvYXQoRykpO2Vsc2V7XCIwXCI9PT1HWzBdJiZcIjBcIiE9PUcmJjY1PkcuY2hhckNvZGVBdCgxKSYmKEc9XCIwb1wiK0cuc3Vic3RyaW5nKDEpKTt5PSEwO2lmKFwibFwiPT09S3x8XCJMXCI9PT1LKUc9Ry5zbGljZSgwLC0xKSx5PSExO0s9TnVtYmVyKEcpO0c9Sz5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUj95P25ldyBTay5idWlsdGluLmludF8oSlNCSS5CaWdJbnQoRykpOm5ldyBTay5idWlsdGluLmxuZyhKU0JJLkJpZ0ludChHKSk6eT9uZXcgU2suYnVpbHRpbi5pbnRfKEspOm5ldyBTay5idWlsdGluLmxuZyhLKX1yZXR1cm4gbmV3IHooRyxcbnUubGluZW5vLHUuY29sX29mZnNldCk7Y2FzZSBULlRfRUxMSVBTSVM6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5FbGxpcHNpcyh1LmxpbmVubyx1LmNvbF9vZmZzZXQsdS5lbmRfbGluZW5vLHUuZW5kX2NvbF9vZmZzZXQpO2Nhc2UgVC5UX0xQQVI6cmV0dXJuIHk9ZSh1LDEpLHkudHlwZT09VC5UX1JQQVI/bmV3IFNrLmFzdG5vZGVzLlR1cGxlKFtdLFNrLmFzdG5vZGVzLkxvYWQsdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KTp5LnR5cGU9PU8ueWllbGRfZXhwcj9WKHoseSk6MT09Zih5KT9oYSh6LHkpOmUoeSwxKS50eXBlPT1PLmNvbXBfZm9yP2wodyh6LHkpLHUpOmwoaGEoeix5KSx1KTtjYXNlIFQuVF9MU1FCOnk9ZSh1LDEpO2lmKHkudHlwZT09VC5UX1JTUUIpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5MaXN0KFtdLFNrLmFzdG5vZGVzLkxvYWQsdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KTtcbmcoeSxPLnRlc3RsaXN0X2NvbXApO2lmKDE9PWYoeSl8fGUoeSwxKS50eXBlPT1ULlRfQ09NTUEpcmV0dXJuKHo9cih6LHkpKT9uZXcgU2suYXN0bm9kZXMuTGlzdCh6LFNrLmFzdG5vZGVzLkxvYWQsdS5saW5lbm8sdS5jb2xfb2Zmc2V0LHUuZW5kX2xpbmVubyx1LmVuZF9jb2xfb2Zmc2V0KTpudWxsO0c9eTtTay5hc3NlcnRzLmFzc2VydChHLnR5cGU9PU8udGVzdGxpc3RfY29tcCk7ej1XKHosRywxKTtyZXR1cm4gbCh6LHUpO2Nhc2UgVC5UX0xCUkFDRTp5PWUodSwxKTtpZih5LnR5cGU9PVQuVF9SQlJBQ0UpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5EaWN0KG51bGwsbnVsbCx1LmxpbmVubyx1LmNvbF9vZmZzZXQsdS5lbmRfbGluZW5vLHUuZW5kX2NvbF9vZmZzZXQpO0c9ZSh5LDApLnR5cGU9PVQuVF9ET1VCTEVTVEFSO2lmKDE9PWYoeSl8fDE8Zih5KSYmZSh5LDEpLnR5cGU9PVQuVF9DT01NQSl7Rz15O0s9W107U2suYXNzZXJ0cy5hc3NlcnQoRy50eXBlPT09Ty5kaWN0b3JzZXRtYWtlcik7XG5mb3IoeT0wO3k8ZihHKTt5Kz0yKWVhPVYoeixlKEcseSkpLEtbeS8yXT1lYTt6PW5ldyBTay5hc3Rub2Rlcy5TZXQoSyxHLmxpbmVubyxHLmNvbF9vZmZzZXQpfWVsc2UgaWYoMTxmKHkpJiZlKHksMSkudHlwZT09Ty5jb21wX2ZvcilHPXksU2suYXNzZXJ0cy5hc3NlcnQoRy50eXBlPT09Ty5kaWN0b3JzZXRtYWtlciksU2suYXNzZXJ0cy5hc3NlcnQoMTxmKEcpKSx5PVYoeixlKEcsMCkpLHo9Sih6LGUoRywxKSksej1uZXcgU2suYXN0bm9kZXMuU2V0Q29tcCh5LHosRy5saW5lbm8sRy5jb2xfb2Zmc2V0KTtlbHNlIGlmKGYoeSk+My1HJiZlKHksMy1HKS50eXBlPT1PLmNvbXBfZm9yKXtpZihHKXJldHVybiBrKHosdSxcImRpY3QgdW5wYWNraW5nIGNhbm5vdCBiZSB1c2VkIGluIGRpY3QgY29tcHJlaGVuc2lvblwiKSxudWxsO0c9eTtTay5hc3NlcnRzLmFzc2VydCgzPGYoRykpO2coZShHLDEpLFQuVF9DT0xPTik7eT1WKHosZShHLDApKTtLPVYoeixlKEcsMikpO3o9Sih6LGUoRywzKSk7XG56PW5ldyBTay5hc3Rub2Rlcy5EaWN0Q29tcCh5LEsseixHLmxpbmVubyxHLmNvbF9vZmZzZXQpfWVsc2V7Rz15O0s9W107ZWE9W107Zm9yKEk9eT0wO0k8ZihHKTtJKyspTT16LFI9RyxYPUksZShSLFgpLnR5cGU9PVQuVF9ET1VCTEVTVEFSPyhTay5hc3NlcnRzLmFzc2VydCgyPD1mKFIpLVgpLEk9VihNLGUoUixYKzEpKSxNPXtrZXk6bnVsbCx2YWx1ZTpJLGk6WCsyfSk6KFNrLmFzc2VydHMuYXNzZXJ0KDM8PWYoUiktWCksKEk9VihNLGUoUixYKSkpPyhVPUksZyhlKFIsWCsxKSxULlRfQ09MT04pLE09KEk9VihNLGUoUixYKzIpKSk/e2tleTpVLHZhbHVlOkksaTpYKzN9OiExKTpNPTApLEk9TS5pLEtbeV09TS5rZXksZWFbeV09TS52YWx1ZSx5Kys7ej1uZXcgU2suYXN0bm9kZXMuRGljdChLLGVhLEcubGluZW5vLEcuY29sX29mZnNldCxHLmVuZF9saW5lbm8sRy5lbmRfY29sX29mZnNldCl9cmV0dXJuIGwoeix1KTtkZWZhdWx0OnJldHVybiBTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgYXRvbSBcIitcbnkudHlwZSksbnVsbH19ZnVuY3Rpb24gZmEoeix1KXt2YXIgeSxHPTA7Zyh1LE8uYXRvbV9leHByKTt2YXIgSz1mKHUpO2UodSwwKS50eXBlPT09VC5UX0FXQUlUJiYoRz0xLFNrLmFzc2VydHMuYXNzZXJ0KDE8SykpO3ZhciBJPW5hKHosZSh1LEcpKTtpZighSSlyZXR1cm4gbnVsbDtpZigxPT09SylyZXR1cm4gSTtpZihHJiYyPT09SylyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkF3YWl0KEksdS5saW5lbm8sdS5jb2xfb2Zmc2V0KTtmb3IoeT1HKzE7eTxLO3krKyl7dmFyIE09ZSh1LHkpO2lmKE0udHlwZSE9PU8udHJhaWxlcilicmVhaztNPUwoeixNLEkpO2lmKCFNKXJldHVybiBudWxsO00ubGluZW5vPUkubGluZW5vO00uY29sX29mZnNldD1JLmNvbF9vZmZzZXQ7ST1NfXJldHVybiBHP25ldyBTay5hc3Rub2Rlcy5Bd2FpdChJLHUubGluZSx1LmNvbF9vZmZzZXQpOkl9ZnVuY3Rpb24gVih6LHUpe2E6Zm9yKDs7KXtzd2l0Y2godS50eXBlKXtjYXNlIE8udGVzdDpjYXNlIE8udGVzdF9ub2NvbmQ6aWYoZSh1LFxuMCkudHlwZT09PU8ubGFtYmRlZnx8ZSh1LDApLnR5cGU9PT1PLmxhbWJkZWZfbm9jb25kKXt2YXIgeT1lKHUsMCk7Mz09PWYoeSk/KHU9bmV3IFNrLmFzdG5vZGVzLmFyZ3VtZW50c18oW10sbnVsbCxudWxsLFtdKSx6PVYoeixlKHksMikpKToodT14KHosZSh5LDEpKSx6PVYoeixlKHksMykpKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkxhbWJkYSh1LHoseS5saW5lbm8seS5jb2xfb2Zmc2V0KX1pZigxPGYodSkpcmV0dXJuIFNrLmFzc2VydHMuYXNzZXJ0KDU9PT1mKHUpKSxuZXcgU2suYXN0bm9kZXMuSWZFeHAoVih6LGUodSwyKSksVih6LGUodSwwKSksVih6LGUodSw0KSksdS5saW5lbm8sdS5jb2xfb2Zmc2V0KTtjYXNlIE8ub3JfdGVzdDpjYXNlIE8uYW5kX3Rlc3Q6aWYoMT09PWYodSkpe3U9ZSh1LDApO2NvbnRpbnVlIGF9dmFyIEc9W107Zm9yKHk9MDt5PGYodSk7eSs9MilHW3kvMl09Vih6LGUodSx5KSk7aWYoXCJhbmRcIj09PWUodSwxKS52YWx1ZSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkJvb2xPcChTay5hc3Rub2Rlcy5BbmQsXG5HLHUubGluZW5vLHUuY29sX29mZnNldCk7U2suYXNzZXJ0cy5hc3NlcnQoXCJvclwiPT09ZSh1LDEpLnZhbHVlKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkJvb2xPcChTay5hc3Rub2Rlcy5PcixHLHUubGluZW5vLHUuY29sX29mZnNldCk7Y2FzZSBPLm5vdF90ZXN0OmlmKDE9PT1mKHUpKXt1PWUodSwwKTtjb250aW51ZSBhfWVsc2UgcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5VbmFyeU9wKFNrLmFzdG5vZGVzLk5vdCxWKHosZSh1LDEpKSx1LmxpbmVubyx1LmNvbF9vZmZzZXQpO2Nhc2UgTy5jb21wYXJpc29uOmlmKDE9PT1mKHUpKXt1PWUodSwwKTtjb250aW51ZSBhfWVsc2V7dmFyIEs9W107Rz1bXTtmb3IoeT0xO3k8Zih1KTt5Kz0yKUtbKHktMSkvMl09ZCh6LGUodSx5KSksR1soeS0xKS8yXT1WKHosZSh1LHkrMSkpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuQ29tcGFyZShWKHosZSh1LDApKSxLLEcsdS5saW5lbm8sdS5jb2xfb2Zmc2V0KX1jYXNlIE8uc3Rhcl9leHByOnJldHVybiBnKHUsXG5PLnN0YXJfZXhwciksbmV3IFNrLmFzdG5vZGVzLlN0YXJyZWQoVih6LGUodSwxKSksU2suYXN0bm9kZXMuTG9hZCx1LmxpbmVubyx1LmNvbF9vZmZzZXQpO2Nhc2UgTy5leHByOmNhc2UgTy54b3JfZXhwcjpjYXNlIE8uYW5kX2V4cHI6Y2FzZSBPLnNoaWZ0X2V4cHI6Y2FzZSBPLmFyaXRoX2V4cHI6Y2FzZSBPLnRlcm06aWYoMT09PWYodSkpe3U9ZSh1LDApO2NvbnRpbnVlIGF9dmFyIEk9dSxNPW5ldyBTay5hc3Rub2Rlcy5CaW5PcChWKHosZShJLDApKSxtKGUoSSwxKSksVih6LGUoSSwyKSksSS5saW5lbm8sSS5jb2xfb2Zmc2V0KSxSPShmKEkpLTEpLzI7Zm9yKHU9MTt1PFI7Kyt1KXk9ZShJLDIqdSsxKSxHPW0oeSksSz1WKHosZShJLDIqdSsyKSksTT1uZXcgU2suYXN0bm9kZXMuQmluT3AoTSxHLEsseS5saW5lbm8seS5jb2xfb2Zmc2V0KTtyZXR1cm4gTTtjYXNlIE8ueWllbGRfZXhwcjpyZXR1cm4gRz0hMSxLPW51bGwsMTxmKHUpJiYoeT1lKHUsMSkpLHkmJihLPWUoeSxmKHkpLVxuMSksMj09Zih5KT8oRz0hMCxLPVYoeixLKSk6Sz1oYSh6LEspKSxHP25ldyBTay5hc3Rub2Rlcy5ZaWVsZEZyb20oSyx1LmxpbmVubyx1LmNvbF9vZmZzZXQpOm5ldyBTay5hc3Rub2Rlcy5ZaWVsZChLLHUubGluZW5vLHUuY29sX29mZnNldCk7Y2FzZSBPLmZhY3RvcjppZigxPT09Zih1KSl7dT1lKHUsMCk7Y29udGludWUgYX1yZXR1cm4gQyh6LHUpO2Nhc2UgTy5wb3dlcjpyZXR1cm4geT11LGcoeSxPLnBvd2VyKSx1PWZhKHosZSh5LDApKSwxIT09Zih5KSYmZSh5LGYoeSktMSkudHlwZT09PU8uZmFjdG9yJiYoej1WKHosZSh5LGYoeSktMSkpLHU9bmV3IFNrLmFzdG5vZGVzLkJpbk9wKHUsU2suYXN0bm9kZXMuUG93LHoseS5saW5lbm8seS5jb2xfb2Zmc2V0KSksdTtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBleHByXCIsXCJuLnR5cGU6ICVkXCIsdS50eXBlKX1icmVha319ZnVuY3Rpb24gbGEoeix1KXt1LnR5cGU9PT1PLnN0bXQmJihTay5hc3NlcnRzLmFzc2VydCgxPT09XG5mKHUpKSx1PWUodSwwKSk7dS50eXBlPT09Ty5zaW1wbGVfc3RtdCYmKFNrLmFzc2VydHMuYXNzZXJ0KDE9PT1oKHUpKSx1PWUodSwwKSk7aWYodS50eXBlPT09Ty5zbWFsbF9zdG10KXN3aXRjaCh1PWUodSwwKSx1LnR5cGUpe2Nhc2UgTy5leHByX3N0bXQ6cmV0dXJuIG9hKHosdSk7Y2FzZSBPLmRlbF9zdG10OnZhciB5PXU7Zyh5LE8uZGVsX3N0bXQpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuRGVsZXRlKHEoeixlKHksMSksU2suYXN0bm9kZXMuRGVsKSx5LmxpbmVubyx5LmNvbF9vZmZzZXQpO2Nhc2UgTy5wYXNzX3N0bXQ6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5QYXNzKHUubGluZW5vLHUuY29sX29mZnNldCk7Y2FzZSBPLmZsb3dfc3RtdDpyZXR1cm4gTih6LHUpO2Nhc2UgTy5pbXBvcnRfc3RtdDp2YXIgRz11LEs7ZyhHLE8uaW1wb3J0X3N0bXQpO3ZhciBJPUcubGluZW5vO3U9Ry5jb2xfb2Zmc2V0O0c9ZShHLDApO2lmKEcudHlwZT09PU8uaW1wb3J0X25hbWUpe0c9ZShHLDEpO1xuZyhHLE8uZG90dGVkX2FzX25hbWVzKTt2YXIgTT1bXTtmb3IoSz0wO0s8ZihHKTtLKz0yKU1bSy8yXT10KHosZShHLEspKTt6PW5ldyBTay5hc3Rub2Rlcy5JbXBvcnQoTSxJLHUpfWVsc2UgaWYoRy50eXBlPT09Ty5pbXBvcnRfZnJvbSl7dmFyIFI9bnVsbDt5PTA7Zm9yKE09MTtNPGYoRyk7KytNKWlmKGUoRyxNKS50eXBlPT09Ty5kb3R0ZWRfbmFtZSl7Uj10KHosZShHLE0pKTtNKys7YnJlYWt9ZWxzZSBpZihlKEcsTSkudHlwZT09PVQuVF9ET1QpeSsrO2Vsc2UgaWYoZShHLE0pLnR5cGU9PT1ULlRfRUxMSVBTSVMpeSs9MztlbHNlIGJyZWFrOysrTTtzd2l0Y2goZShHLE0pLnR5cGUpe2Nhc2UgVC5UX1NUQVI6Rz1lKEcsTSk7YnJlYWs7Y2FzZSBULlRfTFBBUjpHPWUoRyxNKzEpO2YoRyk7YnJlYWs7Y2FzZSBPLmltcG9ydF9hc19uYW1lczpHPWUoRyxNKTtNPWYoRyk7aWYoMD09PU0lMil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInRyYWlsaW5nIGNvbW1hIG5vdCBhbGxvd2VkIHdpdGhvdXQgc3Vycm91bmRpbmcgcGFyZW50aGVzZXNcIixcbnouY19maWxlbmFtZSxHLmxpbmVubyk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgbm9kZS10eXBlIGluIGZyb20taW1wb3J0XCIsei5jX2ZpbGVuYW1lLEcubGluZW5vKTt9TT1bXTtpZihHLnR5cGU9PT1ULlRfU1RBUilNWzBdPXQoeixHKTtlbHNlIGZvcihLPTA7SzxmKEcpO0srPTIpTVtLLzJdPXQoeixlKEcsSykpO3o9Uj9SLm5hbWUudjpcIlwiO3o9bmV3IFNrLmFzdG5vZGVzLkltcG9ydEZyb20ocCh6KSxNLHksSSx1KX1lbHNlIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidW5rbm93biBpbXBvcnQgc3RhdGVtZW50XCIsei5jX2ZpbGVuYW1lLEcubGluZW5vKTtyZXR1cm4gejtjYXNlIE8uZ2xvYmFsX3N0bXQ6ej11O3U9W107Zyh6LE8uZ2xvYmFsX3N0bXQpO2Zvcih5PTE7eTxmKHopO3krPTIpdVsoeS0xKS8yXT1wKGUoeix5KS52YWx1ZSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5HbG9iYWwodSx6LmxpbmVubyxcbnouY29sX29mZnNldCk7Y2FzZSBPLm5vbmxvY2FsX3N0bXQ6ayh6LHUsXCJOb3QgaW1wbGVtZW50ZWQ6IG5vbmxvY2FsXCIpO2JyZWFrO2Nhc2UgTy5hc3NlcnRfc3RtdDpyZXR1cm4geT11LGcoeSxPLmFzc2VydF9zdG10KSwyPT09Zih5KT96PW5ldyBTay5hc3Rub2Rlcy5Bc3NlcnQoVih6LGUoeSwxKSksbnVsbCx5LmxpbmVubyx5LmNvbF9vZmZzZXQpOjQ9PT1mKHkpP3o9bmV3IFNrLmFzdG5vZGVzLkFzc2VydChWKHosZSh5LDEpKSxWKHosZSh5LDMpKSx5LmxpbmVubyx5LmNvbF9vZmZzZXQpOihTay5hc3NlcnRzLmZhaWwoXCJpbXByb3BlciBudW1iZXIgb2YgcGFydHMgdG8gYXNzZXJ0IHN0bXRcIiksej12b2lkIDApLHo7Y2FzZSBPLnByaW50X3N0bXQ6eT11O1NrLl9fZnV0dXJlX18ucHJpbnRfZnVuY3Rpb24mJmsoeix5LFwiTWlzc2luZyBwYXJlbnRoZXNlcyBpbiBjYWxsIHRvICdwcmludCdcIik7Rz0xO0k9bnVsbDtnKHksTy5wcmludF9zdG10KTsyPD1mKHkpJiZlKHksMSkudHlwZT09PVxuVC5UX1JJR0hUU0hJRlQmJihJPVYoeixlKHksMikpLEc9NCk7dT1bXTtmb3IoUj0wO0c8Zih5KTtHKz0yLCsrUil1W1JdPVYoeixlKHksRykpO3o9ZSh5LGYoeSktMSkudHlwZT09PVQuVF9DT01NQT8hMTohMDtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlByaW50KEksdSx6LHkubGluZW5vLHkuY29sX29mZnNldCk7Y2FzZSBPLmRlYnVnZ2VyX3N0bXQ6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5EZWJ1Z2dlcih1LmxpbmVubyx1LmNvbF9vZmZzZXQpO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIHNtYWxsX3N0bXRcIil9ZWxzZSBzd2l0Y2goeT1lKHUsMCksZyh1LE8uY29tcG91bmRfc3RtdCkseS50eXBlKXtjYXNlIE8uaWZfc3RtdDpnKHksTy5pZl9zdG10KTtpZig0PT09Zih5KSl6PW5ldyBTay5hc3Rub2Rlcy5JZihWKHosZSh5LDEpKSx2KHosZSh5LDMpKSxbXSx5LmxpbmVubyx5LmNvbF9vZmZzZXQpO2Vsc2UgaWYodT1lKHksNCkudmFsdWUuY2hhckF0KDIpLFwic1wiPT09XG51KXo9bmV3IFNrLmFzdG5vZGVzLklmKFYoeixlKHksMSkpLHYoeixlKHksMykpLHYoeixlKHksNikpLHkubGluZW5vLHkuY29sX29mZnNldCk7ZWxzZSBpZihcImlcIj09PXUpe0k9Zih5KS00O0c9ITE7dT1bXTtlKHksSSsxKS50eXBlPT09VC5UX05BTUUmJlwic1wiPT09ZSh5LEkrMSkudmFsdWUuY2hhckF0KDIpJiYoRz0hMCxJLT0zKTtJLz00O0cmJih1PVtuZXcgU2suYXN0bm9kZXMuSWYoVih6LGUoeSxmKHkpLTYpKSx2KHosZSh5LGYoeSktNCkpLHYoeixlKHksZih5KS0xKSksZSh5LGYoeSktNikubGluZW5vLGUoeSxmKHkpLTYpLmNvbF9vZmZzZXQpXSxJLS0pO2ZvcihSPTA7UjxJOysrUilHPTUrNCooSS1SLTEpLHU9W25ldyBTay5hc3Rub2Rlcy5JZihWKHosZSh5LEcpKSx2KHosZSh5LEcrMikpLHUsZSh5LEcpLmxpbmVubyxlKHksRykuY29sX29mZnNldCldO3o9bmV3IFNrLmFzdG5vZGVzLklmKFYoeixlKHksMSkpLHYoeixlKHksMykpLHUseS5saW5lbm8seS5jb2xfb2Zmc2V0KX1lbHNlIFNrLmFzc2VydHMuZmFpbChcInVuZXhwZWN0ZWQgdG9rZW4gaW4gJ2lmJyBzdGF0ZW1lbnRcIiksXG56PXZvaWQgMDtyZXR1cm4gejtjYXNlIE8ud2hpbGVfc3RtdDpyZXR1cm4gZyh5LE8ud2hpbGVfc3RtdCksND09PWYoeSk/ej1uZXcgU2suYXN0bm9kZXMuV2hpbGUoVih6LGUoeSwxKSksdih6LGUoeSwzKSksW10seS5saW5lbm8seS5jb2xfb2Zmc2V0KTo3PT09Zih5KT96PW5ldyBTay5hc3Rub2Rlcy5XaGlsZShWKHosZSh5LDEpKSx2KHosZSh5LDMpKSx2KHosZSh5LDYpKSx5LmxpbmVubyx5LmNvbF9vZmZzZXQpOihTay5hc3NlcnRzLmZhaWwoXCJ3cm9uZyBudW1iZXIgb2YgdG9rZW5zIGZvciAnd2hpbGUnIHN0bXRcIiksej12b2lkIDApLHo7Y2FzZSBPLmZvcl9zdG10OnJldHVybiB1PVtdLGcoeSxPLmZvcl9zdG10KSw5PT09Zih5KSYmKHU9dih6LGUoeSw4KSkpLEc9ZSh5LDEpLEk9cSh6LEcsU2suYXN0bm9kZXMuU3RvcmUpLEk9MT09PWYoRyk/SVswXTpuZXcgU2suYXN0bm9kZXMuVHVwbGUoSSxTay5hc3Rub2Rlcy5TdG9yZSx5LmxpbmVubyx5LmNvbF9vZmZzZXQpLG5ldyBTay5hc3Rub2Rlcy5Gb3IoSSxcbmhhKHosZSh5LDMpKSx2KHosZSh5LDUpKSx1LHkubGluZW5vLHkuY29sX29mZnNldCk7Y2FzZSBPLnRyeV9zdG10OnU9W107Sz1mKHkpO0k9KEstMykvMztSPVtdO009bnVsbDtnKHksTy50cnlfc3RtdCk7Rz12KHosZSh5LDIpKTtpZihlKHksSy0zKS50eXBlPT09VC5UX05BTUUpXCJmaW5hbGx5XCI9PT1lKHksSy0zKS52YWx1ZT8oOTw9SyYmZSh5LEstNikudHlwZT09PVQuVF9OQU1FJiYoUj12KHosZSh5LEstNCkpLEktLSksTT12KHosZSh5LEstMSkpKTpSPXYoeixlKHksSy0xKSksSS0tO2Vsc2UgaWYoZSh5LEstMykudHlwZSE9PU8uZXhjZXB0X2NsYXVzZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm1hbGZvcm1lZCAndHJ5JyBzdGF0ZW1lbnRcIix6LmNfZmlsZW5hbWUseS5saW5lbm8pO2lmKDA8SSlmb3IoSz0wO0s8STtLKyspe3ZhciBVPUs7dmFyIFM9eixaPWUoeSwzKzMqSyksWD1lKHksNSszKkspO2coWixPLmV4Y2VwdF9jbGF1c2UpO2coWCxPLnN1aXRlKTtcbmlmKDE9PT1mKFopKXZhciBhYT1uZXcgU2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlcihudWxsLG51bGwsdihTLFgpLFoubGluZW5vLFouY29sX29mZnNldCk7ZWxzZSAyPT09ZihaKT9hYT1uZXcgU2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlcihWKFMsZShaLDEpKSxudWxsLHYoUyxYKSxaLmxpbmVubyxaLmNvbF9vZmZzZXQpOjQ9PT1mKFopPyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMmJlwiLFwiPT1lKFosMikudmFsdWUmJmsoUyxaLFwiT2xkLXN0eWxlICdleGNlcHQnIGNsYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDNcIiksVihTLGUoWiwxKSksYWE9VihTLGUoWiwzKSksYyhTLGFhLFNrLmFzdG5vZGVzLlN0b3JlLGUoWiwzKSksYWE9bmV3IFNrLmFzdG5vZGVzLkV4Y2VwdEhhbmRsZXIoVihTLGUoWiwxKSksYWEsdihTLFgpLFoubGluZW5vLFouY29sX29mZnNldCkpOihTay5hc3NlcnRzLmZhaWwoXCJ3cm9uZyBudW1iZXIgb2YgY2hpbGRyZW4gZm9yIGV4Y2VwdCBjbGF1c2VcIiksXG5hYT12b2lkIDApO3VbVV09YWF9U2suYXNzZXJ0cy5hc3NlcnQoISFNfHwwIT11Lmxlbmd0aCk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5UcnkoRyx1LFIsTSx5LmxpbmVubyx5LmNvbF9vZmZzZXQpO2Nhc2UgTy53aXRoX3N0bXQ6dT1bXTtnKHksTy53aXRoX3N0bXQpO2ZvcihJPTE7STxmKHkpLTI7SSs9MilHPXZvaWQgMCxNPXosSz1lKHksSSksZyhLLE8ud2l0aF9pdGVtKSxSPVYoTSxlKEssMCkpLDM9PWYoSykmJihHPVYoTSxlKEssMikpLGMoTSxHLFNrLmFzdG5vZGVzLlN0b3JlLEspKSxHPW5ldyBTay5hc3Rub2Rlcy53aXRoaXRlbShSLEcpLHVbKEktMSkvMl09Rzt6PXYoeixlKHksZih5KS0xKSk7ej1uZXcgU2suYXN0bm9kZXMuV2l0aCh1LHoseS5saW5lbm8seS5jb2xfb2Zmc2V0KTtyZXR1cm4gejtjYXNlIE8uZnVuY2RlZjpyZXR1cm4gQih6LHksW10sITEpO2Nhc2UgTy5jbGFzc2RlZjpyZXR1cm4gRih6LHksW10pO2Nhc2UgTy5kZWNvcmF0ZWQ6ST1udWxsO2coeSxPLmRlY29yYXRlZCk7XG5HPWUoeSwwKTtnKEcsTy5kZWNvcmF0b3JzKTt1PVtdO2ZvcihSPTA7UjxmKEcpOysrUil7TT11O0s9UjtVPXo7YWE9ZShHLFIpO2coYWEsTy5kZWNvcmF0b3IpO2coZShhYSwwKSxULlRfQVQpO2coZShhYSxmKGFhKS0xKSxULlRfTkVXTElORSk7dmFyIG1hLGVhPWUoYWEsMSk7ZyhlYSxPLmRvdHRlZF9uYW1lKTtTPWVhLmxpbmVubztaPWVhLmNvbF9vZmZzZXQ7WD1wKGUoZWEsMCkudmFsdWUpO3ZhciByYT1uZXcgU2suYXN0bm9kZXMuTmFtZShYLFNrLmFzdG5vZGVzLkxvYWQsUyxaKTtmb3IobWE9MjttYTxmKGVhKTttYSs9MilYPXAoZShlYSxtYSkudmFsdWUpLHJhPW5ldyBTay5hc3Rub2Rlcy5BdHRyaWJ1dGUocmEsWCxTay5hc3Rub2Rlcy5Mb2FkLFMsWik7Uz1yYTtVPTM9PT1mKGFhKT9TOjU9PT1mKGFhKT9uZXcgU2suYXN0bm9kZXMuQ2FsbChTLFtdLFtdLGFhLmxpbmVubyxhYS5jb2xfb2Zmc2V0KTpEKFUsZShhYSwzKSxTKTtNW0tdPVV9U2suYXNzZXJ0cy5hc3NlcnQoZSh5LFxuMSkudHlwZT09Ty5mdW5jZGVmfHxlKHksMSkudHlwZT09Ty5hc3luY19mdW5jZGVmfHxlKHksMSkudHlwZT09Ty5jbGFzc2RlZik7ZSh5LDEpLnR5cGU9PU8uZnVuY2RlZj8oST1lKHksMSksST1CKHosSSx1LCExKSk6ZSh5LDEpLnR5cGU9PU8uY2xhc3NkZWY/ST1GKHosZSh5LDEpLHUpOmUoeSwxKS50eXBlPT1PLmFzeW5jX2Z1bmNkZWYmJihJPWUoeSwxKSxnKEksTy5hc3luY19mdW5jZGVmKSxnKGUoSSwwKSxULlRfTkFNRSksU2suYXNzZXJ0cy5hc3NlcnQoKFwiYXN5bmNcIj09PWUoSSwwKSkudmFsdWUpLGcoZShJLDEpLE8uZnVuY2RlZiksST1CKHosSSx1LCEwKSk7SSYmKEkubGluZW5vPXkubGluZW5vLEkuY29sX29mZnNldD15LmNvbF9vZmZzZXQpO3JldHVybiBJO2Nhc2UgTy5hc3luY19zdG10Omsoeix5LFwiTm90IGltcGxlbWVudGVkOiBhc3luY1wiKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuYXNzZXJ0KFwidW5oYW5kbGVkIGNvbXBvdW5kX3N0bXRcIil9fXZhciBPPVNrLlBhcnNlVGFibGVzLnN5bSxcblQ9U2sudG9rZW4udG9rZW5zLFk9e1NsaWNlX2tpbmQ6MSxFeHRTbGljZV9raW5kOjIsSW5kZXhfa2luZDozfSxkYT17fTtkYVtULlRfVkJBUl09U2suYXN0bm9kZXMuQml0T3I7ZGFbVC5UX0NJUkNVTUZMRVhdPVNrLmFzdG5vZGVzLkJpdFhvcjtkYVtULlRfQU1QRVJdPVNrLmFzdG5vZGVzLkJpdEFuZDtkYVtULlRfTEVGVFNISUZUXT1Tay5hc3Rub2Rlcy5MU2hpZnQ7ZGFbVC5UX1JJR0hUU0hJRlRdPVNrLmFzdG5vZGVzLlJTaGlmdDtkYVtULlRfUExVU109U2suYXN0bm9kZXMuQWRkO2RhW1QuVF9NSU5VU109U2suYXN0bm9kZXMuU3ViO2RhW1QuVF9TVEFSXT1Tay5hc3Rub2Rlcy5NdWx0O2RhW1QuVF9TTEFTSF09U2suYXN0bm9kZXMuRGl2O2RhW1QuVF9ET1VCTEVTTEFTSF09U2suYXN0bm9kZXMuRmxvb3JEaXY7ZGFbVC5UX1BFUkNFTlRdPVNrLmFzdG5vZGVzLk1vZDtTay5zZXR1cE9wZXJhdG9ycz1mdW5jdGlvbih6KXt6P2RhW1QuVF9BVF09U2suYXN0bm9kZXMuTWF0TXVsdDpcbmRhW1QuVF9BVF0mJmRlbGV0ZSBkYVtULlRfQVRdfTtTay5leHBvcnRTeW1ib2woXCJTay5zZXR1cE9wZXJhdG9yc1wiLFNrLnNldHVwT3BlcmF0b3JzKTtjb25zdCBxYT1uZXcgUmVnRXhwKFNrLl90b2tlbml6ZS5GbG9hdG51bWJlcikscGE9L18vZztTay5hc3RGcm9tUGFyc2U9ZnVuY3Rpb24oeix1LHkpe3ZhciBHLEs9bmV3IGIoXCJ1dGYtOFwiLHUseSksST1bXSxNPTA7c3dpdGNoKHoudHlwZSl7Y2FzZSBPLmZpbGVfaW5wdXQ6Zm9yKEc9MDtHPGYoeiktMTsrK0cpe3ZhciBSPWUoeixHKTtpZihSLnR5cGUhPT1ULlRfTkVXTElORSlpZihnKFIsTy5zdG10KSx5PWgoUiksMT09PXkpSVtNKytdPWxhKEssUik7ZWxzZSBmb3IoUj1lKFIsMCksZyhSLE8uc2ltcGxlX3N0bXQpLHU9MDt1PHk7Kyt1KUlbTSsrXT1sYShLLGUoUiwyKnUpKX1yZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk1vZHVsZShJKTtjYXNlIE8uZXZhbF9pbnB1dDpTay5hc3NlcnRzLmZhaWwoXCJ0b2RvO1wiKTtjYXNlIE8uc2luZ2xlX2lucHV0OlNrLmFzc2VydHMuZmFpbChcInRvZG87XCIpO1xuZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ0b2RvO1wiKX19O1NrLmFzdER1bXA9ZnVuY3Rpb24oeil7dmFyIHU9ZnVuY3Rpb24oRyl7dmFyIEssST1cIlwiO2ZvcihLPTA7SzxHOysrSylJKz1cIiBcIjtyZXR1cm4gSX0seT1mdW5jdGlvbihHLEspe3ZhciBJO2lmKG51bGw9PT1HKXJldHVybiBLK1wiTm9uZVwiO2lmKEcucHJvdG90eXBlJiZ2b2lkIDAhPT1HLnByb3RvdHlwZS5fYXN0bmFtZSYmRy5wcm90b3R5cGUuX2lzZW51bSlyZXR1cm4gSytHLnByb3RvdHlwZS5fYXN0bmFtZStcIigpXCI7aWYodm9pZCAwIT09Ry5fYXN0bmFtZSl7dmFyIE09dShHLl9hc3RuYW1lLmxlbmd0aCsxKTt2YXIgUj1bXTtmb3IoST0wO0k8Ry5fZmllbGRzLmxlbmd0aDtJKz0yKXt2YXIgVT1HLl9maWVsZHNbSV07dmFyIFM9Ry5fZmllbGRzW0krMV0oRyk7dmFyIFo9dShVLmxlbmd0aCsxKTtSLnB1c2goW1UseShTLEsrTStaKV0pfVM9W107Zm9yKEk9MDtJPFIubGVuZ3RoOysrSSlaPVJbSV0sUy5wdXNoKFpbMF0rXCI9XCIrXG5aWzFdLnJlcGxhY2UoL15cXHMrLyxcIlwiKSk7ST1TLmpvaW4oXCIsXFxuXCIrSytNKTtyZXR1cm4gSytHLl9hc3RuYW1lK1wiKFwiK0krXCIpXCJ9aWYoU2suaXNBcnJheUxpa2UoRykpe009W107Zm9yKEk9MDtJPEcubGVuZ3RoOysrSSlSPUdbSV0sTS5wdXNoKHkoUixLK1wiIFwiKSk7Rz1NLmpvaW4oXCIsXFxuXCIpO3JldHVybiBLK1wiW1wiK0cucmVwbGFjZSgvXlxccysvLFwiXCIpK1wiXVwifUc9ITA9PT1HP1wiVHJ1ZVwiOiExPT09Rz9cIkZhbHNlXCI6RyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nP0cudHAkc3RyKCkudjpHIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHI/Ry4kcigpLnY6XCJcIitHO3JldHVybiBLK0d9O3JldHVybiB5KHosXCJcIil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFzdEZyb21QYXJzZVwiLFNrLmFzdEZyb21QYXJzZSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYXN0RHVtcFwiLFNrLmFzdER1bXApfSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoaCxhLGMpe3RoaXMuX19uYW1lPWg7dGhpcy5fX2ZsYWdzPWE7XG50aGlzLl9fc2NvcGU9YT4+MTEmNzt0aGlzLl9fbmFtZXNwYWNlcz1jfHxbXX1mdW5jdGlvbiBmKGgsYSxjLG0sbil7dGhpcy5zeW1GbGFncz17fTt0aGlzLm5hbWU9YTt0aGlzLnZhcm5hbWVzPVtdO3RoaXMuY2hpbGRyZW49W107dGhpcy5ibG9ja1R5cGU9Yzt0aGlzLnJldHVybnNWYWx1ZT10aGlzLnZhcmtleXdvcmRzPXRoaXMudmFyYXJncz10aGlzLmdlbmVyYXRvcj10aGlzLmNoaWxkSGFzRnJlZT10aGlzLmhhc0ZyZWU9dGhpcy5pc05lc3RlZD0hMTt0aGlzLmxpbmVubz1uO3RoaXMudGFibGU9aDtoLmN1ciYmKGguY3VyLm5lc3RlZHx8XCJmdW5jdGlvblwiPT09aC5jdXIuYmxvY2tUeXBlKSYmKHRoaXMuaXNOZXN0ZWQ9ITApO20uc2NvcGVJZD1wKys7aC5zdHNzW20uc2NvcGVJZF09dGhpczt0aGlzLnN5bWJvbHM9e319ZnVuY3Rpb24gZShoKXt0aGlzLmZpbGVuYW1lPWg7dGhpcy50b3A9dGhpcy5jdXI9bnVsbDt0aGlzLnN0YWNrPVtdO3RoaXMuY3VyQ2xhc3M9dGhpcy5nbG9iYWw9XG5udWxsO3RoaXMudG1wbmFtZT0wO3RoaXMuc3Rzcz17fX1mdW5jdGlvbiBnKGgsYSl7dmFyIGM7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyloKGFbY10pfWZ1bmN0aW9uIGsoaCxhKXtmb3IodmFyIGMgaW4gYSloW2NdPWFbY119U2suZXhwb3J0U3ltYm9sKFwiU2suU1lNVEFCX0NPTlNUU1wiLHtERUZfR0xPQkFMOjEsREVGX0xPQ0FMOjIsREVGX1BBUkFNOjQsVVNFOjgsREVGX1NUQVI6MTYsREVGX0RPVUJMRVNUQVI6MzIsREVGX0lOVFVQTEU6NjQsREVGX0ZSRUU6MTI4LERFRl9GUkVFX0dMT0JBTDoyNTYsREVGX0ZSRUVfQ0xBU1M6NTEyLERFRl9JTVBPUlQ6MTAyNCxERUZfQk9VTkQ6MTAzMCxTQ09QRV9PRkY6MTEsU0NPUEVfTUFTSzo3LExPQ0FMOjEsR0xPQkFMX0VYUExJQ0lUOjIsR0xPQkFMX0lNUExJQ0lUOjMsRlJFRTo0LENFTEw6NSxPUFRfSU1QT1JUX1NUQVI6MSxPUFRfRVhFQzoyLE9QVF9CQVJFX0VYRUM6NCxPUFRfVE9QTEVWRUw6OCxHRU5FUkFUT1I6MixHRU5FUkFUT1JfRVhQUkVTU0lPTjoyLFxuTW9kdWxlQmxvY2s6XCJtb2R1bGVcIixGdW5jdGlvbkJsb2NrOlwiZnVuY3Rpb25cIixDbGFzc0Jsb2NrOlwiY2xhc3NcIn0pO2IucHJvdG90eXBlLmdldF9uYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19uYW1lfTtiLnByb3RvdHlwZS5pc19yZWZlcmVuY2VkPWZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5fX2ZsYWdzJjgpfTtiLnByb3RvdHlwZS5pc19wYXJhbWV0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLl9fZmxhZ3MmNCl9O2IucHJvdG90eXBlLmlzX2dsb2JhbD1mdW5jdGlvbigpe3JldHVybiAzPT09dGhpcy5fX3Njb3BlfHwyPT10aGlzLl9fc2NvcGV9O2IucHJvdG90eXBlLmlzX2RlY2xhcmVkX2dsb2JhbD1mdW5jdGlvbigpe3JldHVybiAyPT10aGlzLl9fc2NvcGV9O2IucHJvdG90eXBlLmlzX2xvY2FsPWZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5fX2ZsYWdzJjEwMzApfTtiLnByb3RvdHlwZS5pc19mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuIDQ9PXRoaXMuX19zY29wZX07XG5iLnByb3RvdHlwZS5pc19pbXBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEhKHRoaXMuX19mbGFncyYxMDI0KX07Yi5wcm90b3R5cGUuaXNfYXNzaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLl9fZmxhZ3MmMil9O2IucHJvdG90eXBlLmlzX25hbWVzcGFjZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fbmFtZXNwYWNlcyYmMDx0aGlzLl9fbmFtZXNwYWNlcy5sZW5ndGh9O2IucHJvdG90eXBlLmdldF9uYW1lc3BhY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19uYW1lc3BhY2VzfTt2YXIgcD0wO2YucHJvdG90eXBlLmdldF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmxvY2tUeXBlfTtmLnByb3RvdHlwZS5nZXRfbmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9O2YucHJvdG90eXBlLmdldF9saW5lbm89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lbm99O2YucHJvdG90eXBlLmlzX25lc3RlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmVzdGVkfTtcbmYucHJvdG90eXBlLmhhc19jaGlsZHJlbj1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuY2hpbGRyZW4ubGVuZ3RofTtmLnByb3RvdHlwZS5nZXRfaWRlbnRpZmllcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oKXtyZXR1cm4hMH0pfTtmLnByb3RvdHlwZS5sb29rdXA9ZnVuY3Rpb24oaCl7aWYodGhpcy5zeW1ib2xzLmhhc093blByb3BlcnR5KGgpKWg9dGhpcy5zeW1ib2xzW2hdO2Vsc2V7dmFyIGE9dGhpcy5zeW1GbGFnc1toXTt2YXIgYz10aGlzLl9fY2hlY2tfY2hpbGRyZW4oaCk7aD10aGlzLnN5bWJvbHNbaF09bmV3IGIoaCxhLGMpfXJldHVybiBofTtmLnByb3RvdHlwZS5fX2NoZWNrX2NoaWxkcmVuPWZ1bmN0aW9uKGgpe3ZhciBhLGM9W107Zm9yKGE9MDthPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOysrYSl7dmFyIG09dGhpcy5jaGlsZHJlblthXTttLm5hbWU9PT1oJiZjLnB1c2gobSl9cmV0dXJuIGN9O2YucHJvdG90eXBlLl9pZGVudHNNYXRjaGluZz1cbmZ1bmN0aW9uKGgpe3ZhciBhLGM9W107Zm9yKGEgaW4gdGhpcy5zeW1GbGFncyl0aGlzLnN5bUZsYWdzLmhhc093blByb3BlcnR5KGEpJiZoKHRoaXMuc3ltRmxhZ3NbYV0pJiZjLnB1c2goYSk7Yy5zb3J0KCk7cmV0dXJuIGN9O2YucHJvdG90eXBlLmdldF9wYXJhbWV0ZXJzPWZ1bmN0aW9uKCl7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT10aGlzLmdldF90eXBlKCksXCJnZXRfcGFyYW1ldGVycyBvbmx5IHZhbGlkIGZvciBmdW5jdGlvbiBzY29wZXNcIik7dGhpcy5fZnVuY1BhcmFtc3x8KHRoaXMuX2Z1bmNQYXJhbXM9dGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oaCl7cmV0dXJuIGgmNH0pKTtyZXR1cm4gdGhpcy5fZnVuY1BhcmFtc307Zi5wcm90b3R5cGUuZ2V0X2xvY2Fscz1mdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09dGhpcy5nZXRfdHlwZSgpLFwiZ2V0X2xvY2FscyBvbmx5IHZhbGlkIGZvciBmdW5jdGlvbiBzY29wZXNcIik7dGhpcy5fZnVuY0xvY2Fsc3x8XG4odGhpcy5fZnVuY0xvY2Fscz10aGlzLl9pZGVudHNNYXRjaGluZyhmdW5jdGlvbihoKXtyZXR1cm4gaCYxMDMwfSkpO3JldHVybiB0aGlzLl9mdW5jTG9jYWxzfTtmLnByb3RvdHlwZS5nZXRfZ2xvYmFscz1mdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09dGhpcy5nZXRfdHlwZSgpLFwiZ2V0X2dsb2JhbHMgb25seSB2YWxpZCBmb3IgZnVuY3Rpb24gc2NvcGVzXCIpO3RoaXMuX2Z1bmNHbG9iYWxzfHwodGhpcy5fZnVuY0dsb2JhbHM9dGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oaCl7aD1oPj4xMSY3O3JldHVybiAzPT1ofHwyPT1ofSkpO3JldHVybiB0aGlzLl9mdW5jR2xvYmFsc307Zi5wcm90b3R5cGUuZ2V0X2ZyZWVzPWZ1bmN0aW9uKCl7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT10aGlzLmdldF90eXBlKCksXCJnZXRfZnJlZXMgb25seSB2YWxpZCBmb3IgZnVuY3Rpb24gc2NvcGVzXCIpO3RoaXMuX2Z1bmNGcmVlc3x8KHRoaXMuX2Z1bmNGcmVlcz1cbnRoaXMuX2lkZW50c01hdGNoaW5nKGZ1bmN0aW9uKGgpe3JldHVybiA0PT0oaD4+MTEmNyl9KSk7cmV0dXJuIHRoaXMuX2Z1bmNGcmVlc307Zi5wcm90b3R5cGUuZ2V0X21ldGhvZHM9ZnVuY3Rpb24oKXt2YXIgaDtTay5hc3NlcnRzLmFzc2VydChcImNsYXNzXCI9PXRoaXMuZ2V0X3R5cGUoKSxcImdldF9tZXRob2RzIG9ubHkgdmFsaWQgZm9yIGNsYXNzIHNjb3Blc1wiKTtpZighdGhpcy5fY2xhc3NNZXRob2RzKXt2YXIgYT1bXTtmb3IoaD0wO2g8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytoKWEucHVzaCh0aGlzLmNoaWxkcmVuW2hdLm5hbWUpO2Euc29ydCgpO3RoaXMuX2NsYXNzTWV0aG9kcz1hfXJldHVybiB0aGlzLl9jbGFzc01ldGhvZHN9O2YucHJvdG90eXBlLmdldFNjb3BlPWZ1bmN0aW9uKGgpe2g9dGhpcy5zeW1GbGFnc1toXTtyZXR1cm4gdm9pZCAwPT09aD8wOmg+PjExJjd9O2UucHJvdG90eXBlLmdldFN0c0ZvckFzdD1mdW5jdGlvbihoKXtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1cbmguc2NvcGVJZCxcImFzdCB3YXNuJ3QgYWRkZWQgdG8gc3Q/XCIpO2g9dGhpcy5zdHNzW2guc2NvcGVJZF07U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09aCxcInVua25vd24gc3ltIHRhYiBlbnRyeVwiKTtyZXR1cm4gaH07ZS5wcm90b3R5cGUuU0VRU3RtdD1mdW5jdGlvbihoKXt2YXIgYSxjO2lmKG51bGwhPT1oKXtTay5hc3NlcnRzLmFzc2VydChTay5pc0FycmF5TGlrZShoKSxcIlNFUTogbm9kZXMgaXNuJ3QgYXJyYXk/IGdvdCBcIitoLnRvU3RyaW5nKCkpO3ZhciBtPWgubGVuZ3RoO2ZvcihjPTA7YzxtOysrYykoYT1oW2NdKSYmdGhpcy52aXNpdFN0bXQoYSl9fTtlLnByb3RvdHlwZS5TRVFFeHByPWZ1bmN0aW9uKGgpe3ZhciBhLGM7aWYobnVsbCE9PWgpe1NrLmFzc2VydHMuYXNzZXJ0KFNrLmlzQXJyYXlMaWtlKGgpLFwiU0VROiBub2RlcyBpc24ndCBhcnJheT8gZ290IFwiK2gudG9TdHJpbmcoKSk7dmFyIG09aC5sZW5ndGg7Zm9yKGM9MDtjPG07KytjKShhPWhbY10pJiZ0aGlzLnZpc2l0RXhwcihhKX19O1xuZS5wcm90b3R5cGUuZW50ZXJCbG9jaz1mdW5jdGlvbihoLGEsYyxtKXtoPVNrLmZpeFJlc2VydmVkKGgpO3ZhciBuPW51bGw7dGhpcy5jdXImJihuPXRoaXMuY3VyLHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cikpO3RoaXMuY3VyPW5ldyBmKHRoaXMsaCxhLGMsbSk7XCJ0b3BcIj09PWgmJih0aGlzLmdsb2JhbD10aGlzLmN1ci5zeW1GbGFncyk7biYmbi5jaGlsZHJlbi5wdXNoKHRoaXMuY3VyKX07ZS5wcm90b3R5cGUuZXhpdEJsb2NrPWZ1bmN0aW9uKCl7dGhpcy5jdXI9bnVsbDswPHRoaXMuc3RhY2subGVuZ3RoJiYodGhpcy5jdXI9dGhpcy5zdGFjay5wb3AoKSl9O2UucHJvdG90eXBlLnZpc2l0UGFyYW1zPWZ1bmN0aW9uKGgsYSl7dmFyIGM7Zm9yKGM9MDtjPGgubGVuZ3RoOysrYylpZihhPWhbY10sYS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLmFyZyl0aGlzLmFkZERlZihhLmFyZyw0LGEubGluZW5vKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW52YWxpZCBleHByZXNzaW9uIGluIHBhcmFtZXRlciBsaXN0XCIsXG50aGlzLmZpbGVuYW1lKTt9O2UucHJvdG90eXBlLnZpc2l0QW5ub3RhdGlvbnM9ZnVuY3Rpb24oaCxhKXtoLnBvc29ubHlhcmdzJiZ0aGlzLnZpc2l0QXJnQW5ub3RhdGlvbnMoaC5wb3Nvbmx5YXJncyk7aC5hcmdzJiZ0aGlzLnZpc2l0QXJnQW5ub3RhdGlvbnMoaC5hcmdzKTtoLnZhcmFyZyYmaC52YXJhcmcuYW5ub3RhdGlvbiYmdGhpcy52aXNpdEV4cHIoaC52YXJhcmcuYW5ub3RhdGlvbik7aC5rd2FyZyYmaC5rd2FyZy5hbm5vdGF0aW9uJiZ0aGlzLnZpc2l0RXhwcihoLmt3YXJnLmFubm90YXRpb24pO2gua3dvbmx5YXJncyYmdGhpcy52aXNpdEFyZ0Fubm90YXRpb25zKGgua3dvbmx5YXJncyk7YSYmdGhpcy52aXNpdEV4cHIoYSl9O2UucHJvdG90eXBlLnZpc2l0QXJnQW5ub3RhdGlvbnM9ZnVuY3Rpb24oaCl7Zm9yKGxldCBhPTA7YTxoLmxlbmd0aDthKyspe2NvbnN0IGM9aFthXTtjLmFubm90YXRpb24mJnRoaXMudmlzaXRFeHByKGMuYW5ub3RhdGlvbil9fTtlLnByb3RvdHlwZS52aXNpdEFyZ3VtZW50cz1cbmZ1bmN0aW9uKGgsYSl7aC5hcmdzJiZ0aGlzLnZpc2l0UGFyYW1zKGguYXJncywhMCk7aC5rd29ubHlhcmdzJiZ0aGlzLnZpc2l0UGFyYW1zKGgua3dvbmx5YXJncywhMCk7aC52YXJhcmcmJih0aGlzLmFkZERlZihoLnZhcmFyZy5hcmcsNCxhKSx0aGlzLmN1ci52YXJhcmdzPSEwKTtoLmt3YXJnJiYodGhpcy5hZGREZWYoaC5rd2FyZy5hcmcsNCxhKSx0aGlzLmN1ci52YXJrZXl3b3Jkcz0hMCl9O2UucHJvdG90eXBlLm5ld1RtcG5hbWU9ZnVuY3Rpb24oaCl7dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwiX1tcIisgKyt0aGlzLnRtcG5hbWUrXCJdXCIpLDIsaCl9O2UucHJvdG90eXBlLmFkZERlZj1mdW5jdGlvbihoLGEsYyl7dmFyIG09U2subWFuZ2xlTmFtZSh0aGlzLmN1ckNsYXNzLGgpLnY7bT1Tay5maXhSZXNlcnZlZChtKTt2YXIgbj10aGlzLmN1ci5zeW1GbGFnc1ttXTtpZih2b2lkIDAhPT1uKXtpZihhJjQmJm4mNCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImR1cGxpY2F0ZSBhcmd1bWVudCAnXCIrXG5oLnYrXCInIGluIGZ1bmN0aW9uIGRlZmluaXRpb25cIix0aGlzLmZpbGVuYW1lLGMpO258PWF9ZWxzZSBuPWE7dGhpcy5jdXIuc3ltRmxhZ3NbbV09bjthJjQ/dGhpcy5jdXIudmFybmFtZXMucHVzaChtKTphJjEmJihuPWEsaD10aGlzLmdsb2JhbFttXSx2b2lkIDAhPT1oJiYobnw9aCksdGhpcy5nbG9iYWxbbV09bil9O2UucHJvdG90eXBlLnZpc2l0U2xpY2U9ZnVuY3Rpb24oaCl7dmFyIGE7c3dpdGNoKGguY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuU2xpY2U6aC5sb3dlciYmdGhpcy52aXNpdEV4cHIoaC5sb3dlcik7aC51cHBlciYmdGhpcy52aXNpdEV4cHIoaC51cHBlcik7aC5zdGVwJiZ0aGlzLnZpc2l0RXhwcihoLnN0ZXApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRXh0U2xpY2U6Zm9yKGE9MDthPGguZGltcy5sZW5ndGg7KythKXRoaXMudmlzaXRTbGljZShoLmRpbXNbYV0pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSW5kZXg6dGhpcy52aXNpdEV4cHIoaC52YWx1ZSl9fTtcbmUucHJvdG90eXBlLnZpc2l0U3RtdD1mdW5jdGlvbihoKXt2YXIgYTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1oLFwidmlzaXRTdG10IGNhbGxlZCB3aXRoIHVuZGVmaW5lZFwiKTtzd2l0Y2goaC5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZjp0aGlzLmFkZERlZihoLm5hbWUsMixoLmxpbmVubyk7aC5hcmdzLmRlZmF1bHRzJiZ0aGlzLlNFUUV4cHIoaC5hcmdzLmRlZmF1bHRzKTtoLmRlY29yYXRvcl9saXN0JiZ0aGlzLlNFUUV4cHIoaC5kZWNvcmF0b3JfbGlzdCk7dGhpcy52aXNpdEFubm90YXRpb25zKGguYXJncyxoLnJldHVybnMpO3RoaXMuZW50ZXJCbG9jayhoLm5hbWUudixcImZ1bmN0aW9uXCIsaCxoLmxpbmVubyk7dGhpcy52aXNpdEFyZ3VtZW50cyhoLmFyZ3MsaC5saW5lbm8pO3RoaXMuU0VRU3RtdChoLmJvZHkpO3RoaXMuZXhpdEJsb2NrKCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5DbGFzc0RlZjp0aGlzLmFkZERlZihoLm5hbWUsMixoLmxpbmVubyk7XG50aGlzLlNFUUV4cHIoaC5iYXNlcyk7aC5kZWNvcmF0b3JfbGlzdCYmdGhpcy5TRVFFeHByKGguZGVjb3JhdG9yX2xpc3QpO3RoaXMuZW50ZXJCbG9jayhoLm5hbWUudixcImNsYXNzXCIsaCxoLmxpbmVubyk7dGhpcy5jdXJDbGFzcz1oLm5hbWU7dGhpcy5TRVFTdG10KGguYm9keSk7dGhpcy5leGl0QmxvY2soKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlJldHVybjpoLnZhbHVlJiYodGhpcy52aXNpdEV4cHIoaC52YWx1ZSksdGhpcy5jdXIucmV0dXJuc1ZhbHVlPSEwKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbGV0ZTp0aGlzLlNFUUV4cHIoaC50YXJnZXRzKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkFzc2lnbjp0aGlzLlNFUUV4cHIoaC50YXJnZXRzKTt0aGlzLnZpc2l0RXhwcihoLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkFubkFzc2lnbjppZihoLnRhcmdldC5jb25zdHJ1Y3Rvcj09U2suYXN0bm9kZXMuTmFtZSl7dmFyIGM9aC50YXJnZXQ7dmFyIG09U2subWFuZ2xlTmFtZSh0aGlzLmN1ckNsYXNzLFxuYy5pZCkudjttPVNrLmZpeFJlc2VydmVkKG0pO2M9dGhpcy5jdXIuc3ltRmxhZ3NbbV07aWYoYyYyMDQ5JiZ0aGlzLmdsb2JhbCE9dGhpcy5jdXIuc3ltRmxhZ3MmJmguc2ltcGxlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYW5ub3RhdGVkIG5hbWUgJ1wiK20rXCInIGNhbid0IGJlIGdsb2JhbFwiLHRoaXMuZmlsZW5hbWUsaC5saW5lbm8pO2guc2ltcGxlP3RoaXMuYWRkRGVmKG5ldyBTay5idWlsdGluLnN0cihtKSw0MDk4LGgubGluZW5vKTpoLnZhbHVlJiZ0aGlzLmFkZERlZihuZXcgU2suYnVpbHRpbi5zdHIobSksMixoLmxpbmVubyl9ZWxzZSB0aGlzLnZpc2l0RXhwcihoLnRhcmdldCk7dGhpcy52aXNpdEV4cHIoaC5hbm5vdGF0aW9uKTtoLnZhbHVlJiZ0aGlzLnZpc2l0RXhwcihoLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkF1Z0Fzc2lnbjp0aGlzLnZpc2l0RXhwcihoLnRhcmdldCk7dGhpcy52aXNpdEV4cHIoaC52YWx1ZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5QcmludDpoLmRlc3QmJlxudGhpcy52aXNpdEV4cHIoaC5kZXN0KTt0aGlzLlNFUUV4cHIoaC52YWx1ZXMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRm9yOnRoaXMudmlzaXRFeHByKGgudGFyZ2V0KTt0aGlzLnZpc2l0RXhwcihoLml0ZXIpO3RoaXMuU0VRU3RtdChoLmJvZHkpO2gub3JlbHNlJiZ0aGlzLlNFUVN0bXQoaC5vcmVsc2UpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuV2hpbGU6dGhpcy52aXNpdEV4cHIoaC50ZXN0KTt0aGlzLlNFUVN0bXQoaC5ib2R5KTtoLm9yZWxzZSYmdGhpcy5TRVFTdG10KGgub3JlbHNlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLklmOnRoaXMudmlzaXRFeHByKGgudGVzdCk7dGhpcy5TRVFTdG10KGguYm9keSk7aC5vcmVsc2UmJnRoaXMuU0VRU3RtdChoLm9yZWxzZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5SYWlzZTpoLmV4YyYmKHRoaXMudmlzaXRFeHByKGguZXhjKSxoLmluc3QmJih0aGlzLnZpc2l0RXhwcihoLmluc3QpLGgudGJhY2smJnRoaXMudmlzaXRFeHByKGgudGJhY2spKSxcbmguY2F1c2UmJnRoaXMudmlzaXRFeHByKGguY2F1c2UpKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkFzc2VydDp0aGlzLnZpc2l0RXhwcihoLnRlc3QpO2gubXNnJiZ0aGlzLnZpc2l0RXhwcihoLm1zZyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5JbXBvcnQ6Y2FzZSBTay5hc3Rub2Rlcy5JbXBvcnRGcm9tOnRoaXMudmlzaXRBbGlhcyhoLm5hbWVzLGgubGluZW5vKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkdsb2JhbDp2YXIgbj1oLm5hbWVzLmxlbmd0aDtmb3IoYT0wO2E8bjsrK2Epe209U2subWFuZ2xlTmFtZSh0aGlzLmN1ckNsYXNzLGgubmFtZXNbYV0pLnY7bT1Tay5maXhSZXNlcnZlZChtKTtjPXRoaXMuY3VyLnN5bUZsYWdzW21dO2lmKGMmMTApe2lmKGMmMil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5hbWUgJ1wiK20rXCInIGlzIGFzc2lnbmVkIHRvIGJlZm9yZSBnbG9iYWwgZGVjbGFyYXRpb25cIix0aGlzLmZpbGVuYW1lLGgubGluZW5vKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5hbWUgJ1wiK1xubStcIicgaXMgdXNlZCBwcmlvciB0byBnbG9iYWwgZGVjbGFyYXRpb25cIix0aGlzLmZpbGVuYW1lLGgubGluZW5vKTt9dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKG0pLDEsaC5saW5lbm8pfWJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRXhwcjp0aGlzLnZpc2l0RXhwcihoLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlBhc3M6Y2FzZSBTay5hc3Rub2Rlcy5CcmVhazpjYXNlIFNrLmFzdG5vZGVzLkNvbnRpbnVlOmNhc2UgU2suYXN0bm9kZXMuRGVidWdnZXI6YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5XaXRoOmcodGhpcy52aXNpdF93aXRoaXRlbS5iaW5kKHRoaXMpLGguaXRlbXMpO2codGhpcy52aXNpdFN0bXQuYmluZCh0aGlzKSxoLmJvZHkpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuVHJ5OnRoaXMuU0VRU3RtdChoLmJvZHkpO3RoaXMudmlzaXRFeGNlcHRoYW5kbGVycyhoLmhhbmRsZXJzKTt0aGlzLlNFUVN0bXQoaC5vcmVsc2UpO3RoaXMuU0VRU3RtdChoLmZpbmFsYm9keSk7XG5icmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcIlVuaGFuZGxlZCB0eXBlIFwiK2guY29uc3RydWN0b3IubmFtZStcIiBpbiB2aXNpdFN0bXRcIil9fTtlLnByb3RvdHlwZS52aXNpdF93aXRoaXRlbT1mdW5jdGlvbihoKXt0aGlzLnZpc2l0RXhwcihoLmNvbnRleHRfZXhwcik7aC5vcHRpb25hbF92YXJzJiZ0aGlzLnZpc2l0RXhwcihoLm9wdGlvbmFsX3ZhcnMpfTtlLnByb3RvdHlwZS52aXNpdEV4cHI9ZnVuY3Rpb24oaCl7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09aCxcInZpc2l0RXhwciBjYWxsZWQgd2l0aCB1bmRlZmluZWRcIik7c3dpdGNoKGguY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuQm9vbE9wOnRoaXMuU0VRRXhwcihoLnZhbHVlcyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5CaW5PcDp0aGlzLnZpc2l0RXhwcihoLmxlZnQpO3RoaXMudmlzaXRFeHByKGgucmlnaHQpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuVW5hcnlPcDp0aGlzLnZpc2l0RXhwcihoLm9wZXJhbmQpO1xuYnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5MYW1iZGE6dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwibGFtYmRhXCIpLDIsaC5saW5lbm8pO2guYXJncy5kZWZhdWx0cyYmdGhpcy5TRVFFeHByKGguYXJncy5kZWZhdWx0cyk7dGhpcy5lbnRlckJsb2NrKFwibGFtYmRhXCIsXCJmdW5jdGlvblwiLGgsaC5saW5lbm8pO3RoaXMudmlzaXRBcmd1bWVudHMoaC5hcmdzLGgubGluZW5vKTt0aGlzLnZpc2l0RXhwcihoLmJvZHkpO3RoaXMuZXhpdEJsb2NrKCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5JZkV4cDp0aGlzLnZpc2l0RXhwcihoLnRlc3QpO3RoaXMudmlzaXRFeHByKGguYm9keSk7dGhpcy52aXNpdEV4cHIoaC5vcmVsc2UpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGljdDp0aGlzLlNFUUV4cHIoaC5rZXlzKTt0aGlzLlNFUUV4cHIoaC52YWx1ZXMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGljdENvbXA6Y2FzZSBTay5hc3Rub2Rlcy5TZXRDb21wOnRoaXMudmlzaXRDb21wcmVoZW5zaW9uKGguZ2VuZXJhdG9ycyxcbjApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdENvbXA6dGhpcy5uZXdUbXBuYW1lKGgubGluZW5vKTt0aGlzLnZpc2l0RXhwcihoLmVsdCk7dGhpcy52aXNpdENvbXByZWhlbnNpb24oaC5nZW5lcmF0b3JzLDApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnRoaXMudmlzaXRHZW5leHAoaCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZEZyb206Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZDpoLnZhbHVlJiZ0aGlzLnZpc2l0RXhwcihoLnZhbHVlKTt0aGlzLmN1ci5nZW5lcmF0b3I9ITA7aWYodGhpcy5jdXIucmV0dXJuc1ZhbHVlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ3JldHVybicgd2l0aCBhcmd1bWVudCBpbnNpZGUgZ2VuZXJhdG9yXCIsdGhpcy5maWxlbmFtZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Db21wYXJlOnRoaXMudmlzaXRFeHByKGgubGVmdCk7dGhpcy5TRVFFeHByKGguY29tcGFyYXRvcnMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ2FsbDp0aGlzLnZpc2l0RXhwcihoLmZ1bmMpO1xuaWYoaC5hcmdzKWZvcihsZXQgYSBvZiBoLmFyZ3MpYS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQ/dGhpcy52aXNpdEV4cHIoYS52YWx1ZSk6dGhpcy52aXNpdEV4cHIoYSk7aWYoaC5rZXl3b3Jkcylmb3IobGV0IGEgb2YgaC5rZXl3b3Jkcyl0aGlzLnZpc2l0RXhwcihhLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLk51bTpjYXNlIFNrLmFzdG5vZGVzLlN0cjpjYXNlIFNrLmFzdG5vZGVzLkJ5dGVzOmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSm9pbmVkU3RyOmZvcihsZXQgYSBvZiBoLnZhbHVlcyl0aGlzLnZpc2l0RXhwcihhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlOnRoaXMudmlzaXRFeHByKGgudmFsdWUpO2guZm9ybWF0X3NwZWMmJnRoaXMudmlzaXRFeHByKGguZm9ybWF0X3NwZWMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOnRoaXMudmlzaXRFeHByKGgudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OnRoaXMudmlzaXRFeHByKGgudmFsdWUpO1xudGhpcy52aXNpdFNsaWNlKGguc2xpY2UpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTmFtZTp0aGlzLmFkZERlZihoLmlkLGguY3R4PT09U2suYXN0bm9kZXMuTG9hZD84OjIsaC5saW5lbm8pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50OmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdDpjYXNlIFNrLmFzdG5vZGVzLlR1cGxlOmNhc2UgU2suYXN0bm9kZXMuU2V0OnRoaXMuU0VRRXhwcihoLmVsdHMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3RhcnJlZDp0aGlzLnZpc2l0RXhwcihoLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkVsbGlwc2lzOmJyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwiVW5oYW5kbGVkIHR5cGUgXCIraC5jb25zdHJ1Y3Rvci5uYW1lK1wiIGluIHZpc2l0RXhwclwiKX19O2UucHJvdG90eXBlLnZpc2l0Q29tcHJlaGVuc2lvbj1mdW5jdGlvbihoLGEpe3ZhciBjLG09aC5sZW5ndGg7Zm9yKGM9YTtjPG07KytjKWE9aFtjXSx0aGlzLnZpc2l0RXhwcihhLnRhcmdldCksXG50aGlzLnZpc2l0RXhwcihhLml0ZXIpLHRoaXMuU0VRRXhwcihhLmlmcyl9O2UucHJvdG90eXBlLnZpc2l0QWxpYXM9ZnVuY3Rpb24oaCxhKXt2YXIgYyxtO2ZvcihtPTA7bTxoLmxlbmd0aDsrK20pe3ZhciBuPWhbbV07dmFyIGQ9Yz1udWxsPT09bi5hc25hbWU/bi5uYW1lLnY6bi5hc25hbWUudjtuPWMuaW5kZXhPZihcIi5cIik7LTEhPT1uJiYoZD1jLnN1YnN0cigwLG4pKTtpZihcIipcIiE9PWMpdGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKGQpLDEwMjQsYSk7ZWxzZSBpZihcIm1vZHVsZVwiIT09dGhpcy5jdXIuYmxvY2tUeXBlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW1wb3J0ICogb25seSBhbGxvd2VkIGF0IG1vZHVsZSBsZXZlbFwiLHRoaXMuZmlsZW5hbWUpO319O2UucHJvdG90eXBlLnZpc2l0R2VuZXhwPWZ1bmN0aW9uKGgpe3ZhciBhPWguZ2VuZXJhdG9yc1swXTt0aGlzLnZpc2l0RXhwcihhLml0ZXIpO3RoaXMuZW50ZXJCbG9jayhcImdlbmV4cHJcIixcImZ1bmN0aW9uXCIsXG5oLGgubGluZW5vKTt0aGlzLmN1ci5nZW5lcmF0b3I9ITA7dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwiLjBcIiksNCxoLmxpbmVubyk7dGhpcy52aXNpdEV4cHIoYS50YXJnZXQpO3RoaXMuU0VRRXhwcihhLmlmcyk7dGhpcy52aXNpdENvbXByZWhlbnNpb24oaC5nZW5lcmF0b3JzLDEpO3RoaXMudmlzaXRFeHByKGguZWx0KTt0aGlzLmV4aXRCbG9jaygpfTtlLnByb3RvdHlwZS52aXNpdEV4Y2VwdGhhbmRsZXJzPWZ1bmN0aW9uKGgpe3ZhciBhLGM7Zm9yKGE9MDtjPWhbYV07KythKWMudHlwZSYmdGhpcy52aXNpdEV4cHIoYy50eXBlKSxjLm5hbWUmJnRoaXMudmlzaXRFeHByKGMubmFtZSksdGhpcy5TRVFTdG10KGMuYm9keSl9O2UucHJvdG90eXBlLmFuYWx5emVCbG9jaz1mdW5jdGlvbihoLGEsYyxtKXt2YXIgbj17fTt2YXIgZD17fSxsPXt9LHI9e30sdj17fTtcImNsYXNzXCI9PWguYmxvY2tUeXBlJiYoayhsLG0pLGEmJmsocixhKSk7Zm9yKHQgaW4gaC5zeW1GbGFncyl7dmFyIHE9XG5oLnN5bUZsYWdzW3RdO3RoaXMuYW5hbHl6ZU5hbWUoaCxkLHQscSxhLG4sYyxtKX1cImNsYXNzXCIhPT1oLmJsb2NrVHlwZSYmKFwiZnVuY3Rpb25cIj09PWguYmxvY2tUeXBlJiZrKHIsbiksYSYmayhyLGEpLGsobCxtKSk7bj17fTt2YXIgdD1oLmNoaWxkcmVuLmxlbmd0aDtmb3IocT0wO3E8dDsrK3EpaWYobT1oLmNoaWxkcmVuW3FdLHRoaXMuYW5hbHl6ZUNoaWxkQmxvY2sobSxyLHYsbCxuKSxtLmhhc0ZyZWV8fG0uY2hpbGRIYXNGcmVlKWguY2hpbGRIYXNGcmVlPSEwO2sodixuKTtcImZ1bmN0aW9uXCI9PT1oLmJsb2NrVHlwZSYmdGhpcy5hbmFseXplQ2VsbHMoZCx2KTthPXRoaXMudXBkYXRlU3ltYm9scyhoLnN5bUZsYWdzLGQsYSx2LFwiY2xhc3NcIj09PWguYmxvY2tUeXBlKTtoLmhhc0ZyZWU9aC5oYXNGcmVlfHxhO2soYyx2KX07ZS5wcm90b3R5cGUuYW5hbHl6ZUNoaWxkQmxvY2s9ZnVuY3Rpb24oaCxhLGMsbSxuKXt2YXIgZD17fTtrKGQsYSk7YT17fTtrKGEsYyk7Yz17fTtrKGMsbSk7XG50aGlzLmFuYWx5emVCbG9jayhoLGQsYSxjKTtrKG4sYSl9O2UucHJvdG90eXBlLmFuYWx5emVDZWxscz1mdW5jdGlvbihoLGEpe3ZhciBjO2ZvcihjIGluIGgpe3ZhciBtPWhbY107MT09PW0mJnZvaWQgMCE9PWFbY10mJihoW2NdPTUsZGVsZXRlIGFbY10pfX07ZS5wcm90b3R5cGUudXBkYXRlU3ltYm9scz1mdW5jdGlvbihoLGEsYyxtLG4pe3ZhciBkLGw9ITE7Zm9yKGQgaW4gaCl7dmFyIHI9aFtkXTt2YXIgdj1hW2RdO3J8PXY8PDExO2hbZF09cn1mb3IoZCBpbiBtKWE9aFtkXSx2b2lkIDAhPT1hP24mJmEmMTAzMSYmKGF8PTUxMixoW2RdPWEpOnZvaWQgMCE9PWNbZF0mJihoW2RdPTgxOTIsbD0hMCk7cmV0dXJuIGx9O2UucHJvdG90eXBlLmFuYWx5emVOYW1lPWZ1bmN0aW9uKGgsYSxjLG0sbixkLGwscil7aWYobSYxKXtpZihtJjQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJuYW1lICdcIitjK1wiJyBpcyBsb2NhbCBhbmQgZ2xvYmFsXCIsdGhpcy5maWxlbmFtZSxoLmxpbmVubyk7XG5hW2NdPTI7cltjXT1udWxsO24mJnZvaWQgMCE9PW5bY10mJmRlbGV0ZSBuW2NdfWVsc2UgbSYxMDMwPyhhW2NdPTEsZFtjXT1udWxsLGRlbGV0ZSByW2NdKTpuJiZ2b2lkIDAhPT1uW2NdPyhhW2NdPTQsaC5oYXNGcmVlPSEwLGxbY109bnVsbCk6KHImJnZvaWQgMCE9PXJbY118fCFoLmlzTmVzdGVkfHwoaC5oYXNGcmVlPSEwKSxhW2NdPTMpfTtlLnByb3RvdHlwZS5hbmFseXplPWZ1bmN0aW9uKCl7dGhpcy5hbmFseXplQmxvY2sodGhpcy50b3AsbnVsbCx7fSx7fSl9O1NrLnN5bWJvbHRhYmxlPWZ1bmN0aW9uKGgsYSl7dmFyIGM9bmV3IGUoYSk7Yy5lbnRlckJsb2NrKFwidG9wXCIsXCJtb2R1bGVcIixoLDApO2MudG9wPWMuY3VyO2ZvcihhPTA7YTxoLmJvZHkubGVuZ3RoOysrYSljLnZpc2l0U3RtdChoLmJvZHlbYV0pO2MuZXhpdEJsb2NrKCk7Yy5hbmFseXplKCk7cmV0dXJuIGN9O1NrLmR1bXBTeW10YWI9ZnVuY3Rpb24oaCl7dmFyIGE9ZnVuY3Rpb24obil7cmV0dXJuIG4/XCJUcnVlXCI6XG5cIkZhbHNlXCJ9LGM9ZnVuY3Rpb24obil7dmFyIGQsbD1bXTtmb3IoZD0wO2Q8bi5sZW5ndGg7KytkKWwucHVzaCgobmV3IFNrLmJ1aWx0aW4uc3RyKG5bZF0pKS4kcigpLnYpO3JldHVyblwiW1wiK2wuam9pbihcIiwgXCIpK1wiXVwifSxtPWZ1bmN0aW9uKG4sZCl7dmFyIGwscjt2b2lkIDA9PT1kJiYoZD1cIlwiKTt2YXIgdj1kK1wiU3ltX3R5cGU6IFwiK24uZ2V0X3R5cGUoKStcIlxcblwiO3YrPWQrXCJTeW1fbmFtZTogXCIrbi5nZXRfbmFtZSgpK1wiXFxuXCI7dis9ZCtcIlN5bV9saW5lbm86IFwiK24uZ2V0X2xpbmVubygpK1wiXFxuXCI7dis9ZCtcIlN5bV9uZXN0ZWQ6IFwiK2Eobi5pc19uZXN0ZWQoKSkrXCJcXG5cIjt2Kz1kK1wiU3ltX2hhc2NoaWxkcmVuOiBcIithKG4uaGFzX2NoaWxkcmVuKCkpK1wiXFxuXCI7XCJjbGFzc1wiPT09bi5nZXRfdHlwZSgpP3YrPWQrXCJDbGFzc19tZXRob2RzOiBcIitjKG4uZ2V0X21ldGhvZHMoKSkrXCJcXG5cIjpcImZ1bmN0aW9uXCI9PT1uLmdldF90eXBlKCkmJih2Kz1kK1wiRnVuY19wYXJhbXM6IFwiK2Mobi5nZXRfcGFyYW1ldGVycygpKStcblwiXFxuXCIsdis9ZCtcIkZ1bmNfbG9jYWxzOiBcIitjKG4uZ2V0X2xvY2FscygpKStcIlxcblwiLHYrPWQrXCJGdW5jX2dsb2JhbHM6IFwiK2Mobi5nZXRfZ2xvYmFscygpKStcIlxcblwiLHYrPWQrXCJGdW5jX2ZyZWVzOiBcIitjKG4uZ2V0X2ZyZWVzKCkpK1wiXFxuXCIpO3YrPWQrXCItLSBJZGVudGlmaWVycyAtLVxcblwiO3ZhciBxPW4uZ2V0X2lkZW50aWZpZXJzKCk7dmFyIHQ9cS5sZW5ndGg7Zm9yKHI9MDtyPHQ7KytyKXt2YXIgdz1uLmxvb2t1cChxW3JdKTt2Kz1kK1wibmFtZTogXCIrdy5nZXRfbmFtZSgpK1wiXFxuXCI7dis9ZCtcIiAgaXNfcmVmZXJlbmNlZDogXCIrYSh3LmlzX3JlZmVyZW5jZWQoKSkrXCJcXG5cIjt2Kz1kK1wiICBpc19pbXBvcnRlZDogXCIrYSh3LmlzX2ltcG9ydGVkKCkpK1wiXFxuXCI7dis9ZCtcIiAgaXNfcGFyYW1ldGVyOiBcIithKHcuaXNfcGFyYW1ldGVyKCkpK1wiXFxuXCI7dis9ZCtcIiAgaXNfZ2xvYmFsOiBcIithKHcuaXNfZ2xvYmFsKCkpK1wiXFxuXCI7dis9ZCtcIiAgaXNfZGVjbGFyZWRfZ2xvYmFsOiBcIithKHcuaXNfZGVjbGFyZWRfZ2xvYmFsKCkpK1xuXCJcXG5cIjt2Kz1kK1wiICBpc19sb2NhbDogXCIrYSh3LmlzX2xvY2FsKCkpK1wiXFxuXCI7dis9ZCtcIiAgaXNfZnJlZTogXCIrYSh3LmlzX2ZyZWUoKSkrXCJcXG5cIjt2Kz1kK1wiICBpc19hc3NpZ25lZDogXCIrYSh3LmlzX2Fzc2lnbmVkKCkpK1wiXFxuXCI7dis9ZCtcIiAgaXNfbmFtZXNwYWNlOiBcIithKHcuaXNfbmFtZXNwYWNlKCkpK1wiXFxuXCI7dmFyIEM9dy5nZXRfbmFtZXNwYWNlcygpO3ZhciBEPUMubGVuZ3RoO3YrPWQrXCIgIG5hbWVzcGFjZXM6IFtcXG5cIjt2YXIgTD1bXTtmb3IobD0wO2w8RDsrK2wpdz1DW2xdLEwucHVzaChtKHcsZCtcIiAgICBcIikpO3YrPUwuam9pbihcIlxcblwiKTt2Kz1kK1wiICBdXFxuXCJ9cmV0dXJuIHZ9O3JldHVybiBtKGgudG9wLFwiXCIpfTtTay5leHBvcnRTeW1ib2woXCJTay5zeW1ib2x0YWJsZVwiLFNrLnN5bWJvbHRhYmxlKTtTay5leHBvcnRTeW1ib2woXCJTay5kdW1wU3ltdGFiXCIsU2suZHVtcFN5bXRhYil9LGZ1bmN0aW9uKEUsUSl7ZnVuY3Rpb24gYihhLGMsbSxuLGQpe3RoaXMuZmlsZW5hbWU9XG5hO3RoaXMuc3Q9Yzt0aGlzLmZsYWdzPW07dGhpcy5jYW5TdXNwZW5kPW47dGhpcy5pbnRlcmFjdGl2ZT0hMTt0aGlzLm5lc3RsZXZlbD0wO3RoaXMudT1udWxsO3RoaXMuc3RhY2s9W107dGhpcy5yZXN1bHQ9W107dGhpcy5hbGxVbml0cz1bXTt0aGlzLnNvdXJjZT1kP2Quc3BsaXQoXCJcXG5cIik6ITF9ZnVuY3Rpb24gZigpe3RoaXMubmFtZT10aGlzLnN0ZT1udWxsO3RoaXMuZG9lc1N1c3BlbmQ9dGhpcy5jYW5TdXNwZW5kPSExO3RoaXMucHJpdmF0ZV89bnVsbDt0aGlzLmxpbmVubz10aGlzLmZpcnN0bGluZW5vPTA7dGhpcy5saW5lbm9TZXQ9ITE7dGhpcy5sb2NhbG5hbWVzPVtdO3RoaXMubG9jYWx0ZW1wcz1bXTt0aGlzLnRlbXBzVG9TYXZlPVtdO3RoaXMuYmxvY2tudW09MDt0aGlzLmJsb2Nrcz1bXTt0aGlzLmN1cmJsb2NrPTA7dGhpcy5jb25zdHM9e307dGhpcy5zY29wZW5hbWU9bnVsbDt0aGlzLnN1ZmZpeENvZGU9dGhpcy5zd2l0Y2hDb2RlPXRoaXMudmFyRGVjbHNDb2RlPXRoaXMucHJlZml4Q29kZT1cblwiXCI7dGhpcy5icmVha0Jsb2Nrcz1bXTt0aGlzLmNvbnRpbnVlQmxvY2tzPVtdO3RoaXMuZXhjZXB0QmxvY2tzPVtdO3RoaXMuZmluYWxseUJsb2Nrcz1bXX1mdW5jdGlvbiBlKGEpe3JldHVybiB2b2lkIDA9PT1wW2FdP2E6YStcIl8kcnckXCJ9ZnVuY3Rpb24gZyhhLGMpe3ZhciBtPWMudjtpZihudWxsPT09YXx8bnVsbD09PW18fFwiX1wiIT09bS5jaGFyQXQoMCl8fFwiX1wiIT09bS5jaGFyQXQoMSl8fFwiX1wiPT09bS5jaGFyQXQobS5sZW5ndGgtMSkmJlwiX1wiPT09bS5jaGFyQXQobS5sZW5ndGgtMikpcmV0dXJuIGM7dmFyIG49YS52O24ucmVwbGFjZSgvXy9nLFwiXCIpO2lmKFwiXCI9PT1uKXJldHVybiBjO249YS52O24ucmVwbGFjZSgvXl8qLyxcIlwiKTtyZXR1cm4gbj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfXCIrbittKX12YXIgaztTay5nZW5zeW1jb3VudD0wO2YucHJvdG90eXBlLmFjdGl2YXRlU2NvcGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2s9ZnVuY3Rpb24oKXt2YXIgYyxtPWEuYmxvY2tzW2EuY3VyYmxvY2tdO1xuaWYobnVsbD09PW0uX25leHQpZm9yKGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7KytjKW0ucHVzaChhcmd1bWVudHNbY10pfX07Yi5wcm90b3R5cGUuZ2V0U291cmNlTGluZT1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzLnNvdXJjZSk7cmV0dXJuIHRoaXMuc291cmNlW2EtMV19O2IucHJvdG90eXBlLmFubm90YXRlU291cmNlPWZ1bmN0aW9uKGEpe3ZhciBjO2lmKHRoaXMuc291cmNlKXt2YXIgbT1hLmxpbmVubzt2YXIgbj1hLmNvbF9vZmZzZXQ7ayhcIlxcbi8vXFxuLy8gbGluZSBcIixtLFwiOlxcbi8vIFwiLHRoaXMuZ2V0U291cmNlTGluZShtKSxcIlxcbi8vIFwiKTtmb3IoYz0wO2M8bjsrK2MpayhcIiBcIik7ayhcIl5cXG4vL1xcblwiKTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1hLmxpbmVubyYmdm9pZCAwIT09YS5jb2xfb2Zmc2V0KTtrKFwiJGN1cnJMaW5lTm8gPSBcIixtLFwiO1xcbiRjdXJyQ29sTm8gPSBcIixuLFwiO1xcblxcblwiKX19O2IucHJvdG90eXBlLmdlbnN5bT1mdW5jdGlvbihhKXtyZXR1cm4gYT1cblwiJFwiKyhhfHxcIlwiKStTay5nZW5zeW1jb3VudCsrfTtiLnByb3RvdHlwZS5uaWNlTmFtZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZW5zeW0oYS5yZXBsYWNlKFwiPFwiLFwiXCIpLnJlcGxhY2UoXCI+XCIsXCJcIikucmVwbGFjZShcIiBcIixcIl9cIikpfTt2YXIgcD1Tay5idWlsdGluLnN0ci5yZXNlcnZlZFdvcmRzXztiLnByb3RvdHlwZS5tYWtlQ29uc3RhbnQ9ZnVuY3Rpb24oYSl7dmFyIGMsbT1cIlwiO2ZvcihjPTA7Yzxhcmd1bWVudHMubGVuZ3RoOysrYyltKz1hcmd1bWVudHNbY107Zm9yKG4gaW4gdGhpcy51LmNvbnN0cylpZih0aGlzLnUuY29uc3RzLmhhc093blByb3BlcnR5KG4pJiYoYz10aGlzLnUuY29uc3RzW25dLGM9PW0pKXJldHVybiBuO3ZhciBuPXRoaXMudS5zY29wZW5hbWUrXCIuXCIrdGhpcy5nZW5zeW0oXCJjb25zdFwiKTt0aGlzLnUuY29uc3RzW25dPW07cmV0dXJuIG59O2IucHJvdG90eXBlLl9ncj1mdW5jdGlvbihhLGMpe3ZhciBtLG49dGhpcy5nZW5zeW0oYSk7dGhpcy51LmxvY2FsdGVtcHMucHVzaChuKTtcbmsoXCJ2YXIgXCIsbixcIj1cIik7Zm9yKG09MTttPGFyZ3VtZW50cy5sZW5ndGg7KyttKWsoYXJndW1lbnRzW21dKTtrKFwiO1wiKTtyZXR1cm4gbn07Yi5wcm90b3R5cGUub3V0cHV0SW50ZXJydXB0VGVzdD1mdW5jdGlvbigpe3ZhciBhPVwiXCI7aWYobnVsbCE9PVNrLmV4ZWNMaW1pdHx8bnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kKWErPVwidmFyICRkYXRlTm93ID0gRGF0ZS5ub3coKTtcIixudWxsIT09U2suZXhlY0xpbWl0JiYoYSs9XCJpZiAoJGRhdGVOb3cgLSBTay5leGVjU3RhcnQgPiBTay5leGVjTGltaXQpIHt0aHJvdyBuZXcgU2suYnVpbHRpbi5UaW1lb3V0RXJyb3IoU2sudGltZW91dE1zZygpKX1cIiksbnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kJiYoYT1hK1wiaWYgKCEkd2FraW5nICYmICgkZGF0ZU5vdyAtIFNrLmxhc3RZaWVsZCA+IFNrLnlpZWxkTGltaXQpKSB7dmFyICRzdXNwID0gJHNhdmVTdXNwZW5zaW9uKHtkYXRhOiB7dHlwZTogJ1NrLnlpZWxkJ30sIHJlc3VtZTogZnVuY3Rpb24oKSB7fX0sICdcIitcbih0aGlzLmZpbGVuYW1lK1wiJywkY3VyckxpbmVObywkY3VyckNvbE5vKTtcIiksYSs9XCIkc3VzcC4kYmxrID0gJGJsazskc3VzcC5vcHRpb25hbCA9IHRydWU7cmV0dXJuICRzdXNwO30kd2FraW5nID0gZmFsc2U7XCIsdGhpcy51LmRvZXNTdXNwZW5kPSEwKTtyZXR1cm4gYX07Yi5wcm90b3R5cGUuX2p1bXBmYWxzZT1mdW5jdGlvbihhLGMpe2E9dGhpcy5fZ3IoXCJqZmFsc2VcIixcIihcIixhLFwiPT09ZmFsc2V8fCFTay5taXNjZXZhbC5pc1RydWUoXCIsYSxcIikpXCIpO2soXCJpZihcIixhLFwiKXsvKnRlc3QgZmFpbGVkICovJGJsaz1cIixjLFwiO2NvbnRpbnVlO31cIil9O2IucHJvdG90eXBlLl9qdW1wdW5kZWY9ZnVuY3Rpb24oYSxjKXtrKFwiaWYoXCIsYSxcIj09PXVuZGVmaW5lZCl7JGJsaz1cIixjLFwiO2NvbnRpbnVlO31cIil9O2IucHJvdG90eXBlLl9qdW1wbm90dW5kZWY9ZnVuY3Rpb24oYSxjKXtrKFwiaWYoXCIsYSxcIiE9PXVuZGVmaW5lZCl7JGJsaz1cIixjLFwiO2NvbnRpbnVlO31cIil9O2IucHJvdG90eXBlLl9qdW1wdHJ1ZT1cbmZ1bmN0aW9uKGEsYyl7YT10aGlzLl9ncihcImp0cnVlXCIsXCIoXCIsYSxcIj09PXRydWV8fFNrLm1pc2NldmFsLmlzVHJ1ZShcIixhLFwiKSlcIik7ayhcImlmKFwiLGEsXCIpey8qdGVzdCBwYXNzZWQgKi8kYmxrPVwiLGMsXCI7Y29udGludWU7fVwiKX07Yi5wcm90b3R5cGUuX2p1bXA9ZnVuY3Rpb24oYSl7bnVsbD09PXRoaXMudS5ibG9ja3NbdGhpcy51LmN1cmJsb2NrXS5fbmV4dCYmKGsoXCIkYmxrPVwiLGEsXCI7XCIpLHRoaXMudS5ibG9ja3NbdGhpcy51LmN1cmJsb2NrXS5fbmV4dD1hKX07Yi5wcm90b3R5cGUuX2NoZWNrU3VzcGVuc2lvbj1mdW5jdGlvbihhKXtpZih0aGlzLnUuY2FuU3VzcGVuZCl7dmFyIGM9dGhpcy5uZXdCbG9jayhcImZ1bmN0aW9uIHJldHVybiBvciByZXN1bWUgc3VzcGVuc2lvblwiKTt0aGlzLl9qdW1wKGMpO3RoaXMuc2V0QmxvY2soYyk7YT1hfHx7bGluZW5vOlwiJGN1cnJMaW5lTm9cIixjb2xfb2Zmc2V0OlwiJGN1cnJDb2xOb1wifTtrKFwiaWYgKCRyZXQgJiYgJHJldC4kaXNTdXNwZW5zaW9uKSB7IHJldHVybiAkc2F2ZVN1c3BlbnNpb24oJHJldCwnXCIrXG50aGlzLmZpbGVuYW1lK1wiJyxcIithLmxpbmVubytcIixcIithLmNvbF9vZmZzZXQrXCIpOyB9XCIpO3RoaXMudS5kb2VzU3VzcGVuZD0hMDt0aGlzLnUudGVtcHNUb1NhdmU9dGhpcy51LnRlbXBzVG9TYXZlLmNvbmNhdCh0aGlzLnUubG9jYWx0ZW1wcyl9ZWxzZSBrKFwiaWYgKCRyZXQgJiYgJHJldC4kaXNTdXNwZW5zaW9uKSB7ICRyZXQgPSBTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coJHJldCk7IH1cIil9O2IucHJvdG90eXBlLmN1bnBhY2tzdGFyc3RvYXJyYXk9ZnVuY3Rpb24oYSxjKXtpZighYXx8MD09YS5sZW5ndGgpcmV0dXJuXCJbXVwiO2xldCBtPSExO2ZvcihsZXQgbiBvZiBhKXtpZihjJiZtKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiRXh0ZW5kZWQgYXJndW1lbnQgdW5wYWNraW5nIGlzIG5vdCBwZXJtaXR0ZWQgaW4gUHl0aG9uIDJcIik7bi5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQmJihtPSEwKX1pZihtKXtjPXRoaXMuX2dyKFwidW5wYWNrXCIsXG5cIltdXCIpO2ZvcihsZXQgbiBvZiBhKW4uY29uc3RydWN0b3IhPT1Tay5hc3Rub2Rlcy5TdGFycmVkP2soYyxcIi5wdXNoKFwiLHRoaXMudmV4cHIobiksXCIpO1wiKTooayhcIiRyZXQgPSBTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoXCIsdGhpcy52ZXhwcihuLnZhbHVlKSxcIiksIGZ1bmN0aW9uKGUpIHsgXCIsYyxcIi5wdXNoKGUpOyB9KTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCkpO3JldHVybiBjfXJldHVyblwiW1wiK2EubWFwKG49PnRoaXMudmV4cHIobikpLmpvaW4oXCIsXCIpK1wiXVwifTtiLnByb3RvdHlwZS5jdW5wYWNra3dzdG9hcnJheT1mdW5jdGlvbihhLGMpe3ZhciBtPVwidW5kZWZpbmVkXCI7aWYoYSYmMDxhLmxlbmd0aCl7bGV0IG49ITE7bT1bXTtmb3IobGV0IGQgb2YgYSl7aWYobiYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMyl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBZHZhbmNlZCB1bnBhY2tpbmcgb2YgZnVuY3Rpb24gYXJndW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIik7XG5kLmFyZz8obS5wdXNoKFwiJ1wiK2QuYXJnLnYrXCInXCIpLG0ucHVzaCh0aGlzLnZleHByKGQudmFsdWUpKSk6bj0hMH1tPVwiW1wiK20uam9pbihcIixcIikrXCJdXCI7aWYobil7bT10aGlzLl9ncihcImtleXdvcmRBcmdzXCIsbSk7Zm9yKGxldCBkIG9mIGEpZC5hcmd8fChrKFwiJHJldCA9IFNrLmFic3RyLm1hcHBpbmdVbnBhY2tJbnRvS2V5d29yZEFycmF5KFwiLG0sXCIsXCIsdGhpcy52ZXhwcihkLnZhbHVlKSxcIixcIixjLFwiKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCkpfX1yZXR1cm4gbX07Yi5wcm90b3R5cGUuY3R1cGxlbGlzdG9yc2V0PWZ1bmN0aW9uKGEsYyxtKXt2YXIgbjtTay5hc3NlcnRzLmFzc2VydChcInR1cGxlXCI9PT1tfHxcImxpc3RcIj09PW18fFwic2V0XCI9PT1tKTt2YXIgZD0hMTtmb3Iobj0wO248YS5lbHRzLmxlbmd0aDtuKyspaWYoYS5lbHRzW25dLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuU3RhcnJlZCl7ZD0hMDt2YXIgbD1uO2JyZWFrfWlmKGEuY3R4PT09U2suYXN0bm9kZXMuU3RvcmUpe2lmKGQpe2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhc3NpZ25tZW50IHVucGFja2luZyB3aXRoIHN0YXJzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIixcbnRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO2ZvcihuPWwrMTtuPGEuZWx0cy5sZW5ndGg7bisrKWlmKGEuZWx0c1tuXS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJtdWx0aXBsZSBzdGFycmVkIGV4cHJlc3Npb25zIGluIGFzc2lnbm1lbnRcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTt9bT1kP2w6YS5lbHRzLmxlbmd0aDtrKFwiJHJldCA9IFNrLmFic3RyLnNlcXVlbmNlVW5wYWNrKFwiK2MrXCIsXCIrbStcIixcIisoZD9hLmVsdHMubGVuZ3RoLTE6bSkrXCIsIFwiK2QrXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oKTtjPXRoaXMuX2dyKFwiaXRlbXNcIixcIiRyZXRcIik7Zm9yKG49MDtuPGEuZWx0cy5sZW5ndGg7KytuKW49PT1sP3RoaXMudmV4cHIoYS5lbHRzW25dLnZhbHVlLGMrXCJbXCIrbitcIl1cIik6dGhpcy52ZXhwcihhLmVsdHNbbl0sYytcIltcIituK1wiXVwiKX1lbHNlIGlmKGEuY3R4PT09U2suYXN0bm9kZXMuTG9hZHx8XCJzZXRcIj09PVxubSl7aWYoZCl7aWYoIVNrLl9fZnV0dXJlX18ucHl0aG9uMyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIkxpc3QgcGFja2luZyB3aXRoIHN0YXJzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIik7cmV0dXJuIHRoaXMuX2dyKFwibG9hZFwiK20sXCJuZXcgU2suYnVpbHRpbnNbJ1wiLG0sXCInXShcIix0aGlzLmN1bnBhY2tzdGFyc3RvYXJyYXkoYS5lbHRzKSxcIilcIil9aWYoXCJ0dXBsZVwiPT09bSl7ZD0hMDtjPVtdO2ZvcihuPTA7bjxhLmVsdHMubGVuZ3RoOysrbilsPXRoaXMudmV4cHIoYS5lbHRzW25dKSxkJiYtMT09bC5pbmRleE9mKFwiJGNvbnN0XCIpJiYoZD0hMSksYy5wdXNoKGwpO2lmKGQpcmV0dXJuIHRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4udHVwbGUoW1wiK2MrXCJdKVwiKTtmb3Iobj0wO248Yy5sZW5ndGg7KytuKWNbbl09dGhpcy5fZ3IoXCJlbGVtXCIsY1tuXSk7cmV0dXJuIHRoaXMuX2dyKFwibG9hZFwiK20sXCJuZXcgU2suYnVpbHRpbnNbJ1wiLG0sXCInXShbXCIsXG5jLFwiXSlcIil9Yz1bXTtmb3Iobj0wO248YS5lbHRzLmxlbmd0aDsrK24pYy5wdXNoKHRoaXMuX2dyKFwiZWxlbVwiLHRoaXMudmV4cHIoYS5lbHRzW25dKSkpO3JldHVybiB0aGlzLl9ncihcImxvYWRcIittLFwibmV3IFNrLmJ1aWx0aW5zWydcIixtLFwiJ10oW1wiLGMsXCJdKVwiKX19O2IucHJvdG90eXBlLmNzdWJkaWN0PWZ1bmN0aW9uKGEsYyxtKXtjb25zdCBuPVtdO2Zvcig7YzxtO2MrKyluLnB1c2godGhpcy52ZXhwcihhLmtleXNbY10pKSxuLnB1c2godGhpcy52ZXhwcihhLnZhbHVlc1tjXSkpO3JldHVybiB0aGlzLl9ncihcImxvYWRkaWN0XCIsXCJuZXcgU2suYnVpbHRpbnNbJ2RpY3QnXShbXCIsbixcIl0pXCIpfTtiLnByb3RvdHlwZS5jZGljdD1mdW5jdGlvbihhKXtsZXQgYz0wO3ZhciBtO2NvbnN0IG49YS52YWx1ZXM/YS52YWx1ZXMubGVuZ3RoOjA7bGV0IGQ9MCxsO2ZvcihsZXQgcj0wO3I8bjtyKyspKG09bnVsbD09PWEua2V5c1tyXSk/KGQmJihtPXRoaXMuY3N1YmRpY3QoYSxyLWQsciksYz9cbmsobCxcIi5kaWN0JG1lcmdlKFwiLG0sXCIpO1wiKToobD1tLGM9MSksZD0wKSwwPT09YyYmKGw9dGhpcy5fZ3IoXCJsb2FkZGljdFwiLFwibmV3IFNrLmJ1aWx0aW5zLmRpY3QoW10pXCIpLGM9MSksbT10aGlzLnZleHByKGEudmFsdWVzW3JdKSxrKFwiJHJldCA9IFwiLGwsXCIuZGljdCRtZXJnZShcIixtLFwiKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpKTpkKys7ZCYmKG09dGhpcy5jc3ViZGljdChhLG4tZCxuKSxjP2sobCxcIi5kaWN0JG1lcmdlKFwiLG0sXCIpO1wiKToobD1tLGM9MSkpOzA9PT1jJiYobD10aGlzLl9ncihcImxvYWRkaWN0XCIsXCJuZXcgU2suYnVpbHRpbnMuZGljdChbXSlcIikpO3JldHVybiBsfTtiLnByb3RvdHlwZS5jbGlzdGNvbXA9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkxpc3RDb21wKTt2YXIgYz10aGlzLl9ncihcIl9jb21wclwiLFwibmV3IFNrLmJ1aWx0aW5zWydsaXN0J10oW10pXCIpO3JldHVybiB0aGlzLmNjb21wZ2VuKFwibGlzdFwiLFxuYyxhLmdlbmVyYXRvcnMsMCxhLmVsdCxudWxsLGEpfTtiLnByb3RvdHlwZS5jZGljdGNvbXA9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkRpY3RDb21wKTt2YXIgYz10aGlzLl9ncihcIl9kY29tcHJcIixcIm5ldyBTay5idWlsdGlucy5kaWN0KFtdKVwiKTtyZXR1cm4gdGhpcy5jY29tcGdlbihcImRpY3RcIixjLGEuZ2VuZXJhdG9ycywwLGEudmFsdWUsYS5rZXksYSl9O2IucHJvdG90eXBlLmNzZXRjb21wPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5TZXRDb21wKTt2YXIgYz10aGlzLl9ncihcIl9zZXRjb21wclwiLFwibmV3IFNrLmJ1aWx0aW5zLnNldChbXSlcIik7cmV0dXJuIHRoaXMuY2NvbXBnZW4oXCJzZXRcIixjLGEuZ2VuZXJhdG9ycywwLGEuZWx0LG51bGwsYSl9O2IucHJvdG90eXBlLmNjb21wZ2VuPWZ1bmN0aW9uKGEsYyxtLG4sZCxsLHIpe3ZhciB2PXRoaXMubmV3QmxvY2soYStcIiBjb21wIHN0YXJ0XCIpLFxucT10aGlzLm5ld0Jsb2NrKGErXCIgY29tcCBza2lwXCIpLHQ9dGhpcy5uZXdCbG9jayhhK1wiIGNvbXAgYW5jaG9yXCIpLHc9bVtuXSxDPXRoaXMudmV4cHIody5pdGVyKTtDPXRoaXMuX2dyKFwiaXRlclwiLFwiU2suYWJzdHIuaXRlcihcIixDLFwiKVwiKTt2YXIgRDt0aGlzLl9qdW1wKHYpO3RoaXMuc2V0QmxvY2sodik7ayhcIiRyZXQgPSBTay5hYnN0ci5pdGVybmV4dChcIixDLFwiLCB0cnVlKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKHIpO0M9dGhpcy5fZ3IoXCJuZXh0XCIsXCIkcmV0XCIpO3RoaXMuX2p1bXB1bmRlZihDLHQpO3RoaXMudmV4cHIody50YXJnZXQsQyk7dmFyIEw9dy5pZnM/dy5pZnMubGVuZ3RoOjA7Zm9yKEQ9MDtEPEw7KytEKUM9dGhpcy52ZXhwcih3Lmlmc1tEXSksdGhpcy5fanVtcGZhbHNlKEMsdik7KytuPG0ubGVuZ3RoJiZ0aGlzLmNjb21wZ2VuKGEsYyxtLG4sZCxsLHIpO24+PW0ubGVuZ3RoJiYobT10aGlzLnZleHByKGQpLFwiZGljdFwiPT09YT8oYT10aGlzLnZleHByKGwpLGsoYyxcblwiLm1wJGFzc19zdWJzY3JpcHQoXCIsYSxcIixcIixtLFwiKTtcIikpOlwibGlzdFwiPT09YT9rKGMsXCIudi5wdXNoKFwiLG0sXCIpO1wiKTpcInNldFwiPT09YSYmayhjLFwiLnYubXAkYXNzX3N1YnNjcmlwdChcIixtLFwiLCB0cnVlKTtcIiksdGhpcy5fanVtcChxKSx0aGlzLnNldEJsb2NrKHEpKTt0aGlzLl9qdW1wKHYpO3RoaXMuc2V0QmxvY2sodCk7cmV0dXJuIGN9O2IucHJvdG90eXBlLmN5aWVsZD1mdW5jdGlvbihhKXtpZih0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jayl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIid5aWVsZCcgb3V0c2lkZSBmdW5jdGlvblwiLHRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO3ZhciBjPVwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7YS52YWx1ZSYmKGM9dGhpcy52ZXhwcihhLnZhbHVlKSk7YT10aGlzLm5ld0Jsb2NrKFwiYWZ0ZXIgeWllbGRcIik7ayhcInJldHVybiBbLypyZXN1bWUqL1wiLGEsXCIsLypyZXQqL1wiLGMsXCJdO1wiKTtcbnRoaXMuc2V0QmxvY2soYSk7cmV0dXJuXCIkZ2VuLmdpJHNlbnR2YWx1ZVwifTtiLnByb3RvdHlwZS5jeWllbGRmcm9tPWZ1bmN0aW9uKGEpe2lmKHRoaXMudS5zdGUuYmxvY2tUeXBlIT09U2suU1lNVEFCX0NPTlNUUy5GdW5jdGlvbkJsb2NrKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ3lpZWxkJyBvdXRzaWRlIGZ1bmN0aW9uXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7dmFyIGM9dGhpcy52ZXhwcihhLnZhbHVlKTtjPXRoaXMuX2dyKFwiaXRlclwiLFwiU2suYWJzdHIuaXRlcihcIixjLFwiKVwiKTtrKFwiJGdlbi5cIitjK1wiPVwiLGMsXCI7XCIpO3ZhciBtPXRoaXMubmV3QmxvY2soXCJhZnRlciBpdGVyXCIpLG49dGhpcy5uZXdCbG9jayhcImFmdGVyIHlpZWxkIGZyb21cIik7dGhpcy5fanVtcChtKTt0aGlzLnNldEJsb2NrKG0pO3ZhciBkPXRoaXMuZ2Vuc3ltKFwicmV0dmFsXCIpO2soYyxcIj0kZ2VuLlwiLGMsXCI7XCIpO2soXCJ2YXIgXCIsZCxcIjtcIik7ayhcImlmICgkZ2VuLmdpJHNlbnR2YWx1ZSA9PT0gU2suYnVpbHRpbi5ub25lLm5vbmUkIHx8IFwiK1xuYytcIi5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5nZW5lcmF0b3IpIHtcIik7ayhcIiRyZXQ9XCIsYyxcIi50cCRpdGVybmV4dCh0cnVlLCAkZ2VuLmdpJHNlbnR2YWx1ZSk7XCIpO2soXCJ9IGVsc2Uge1wiKTt2YXIgbD10aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLnN0cignc2VuZCcpO1wiKTtrKFwiJHJldD1Tay5taXNjZXZhbC50cnlDYXRjaChcIik7ayhcImZ1bmN0aW9uKCl7XCIpO2soXCJyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KFNrLmFic3RyLmdhdHRyKFwiLGMsXCIsXCIsbCxcIiksIFskZ2VuLmdpJHNlbnR2YWx1ZV0pO30sXCIpO2soXCJmdW5jdGlvbiAoZSkgeyBcIik7ayhcImlmIChlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uKSB7IFwiKTtrKGMsXCIuZ2kkcmV0ID0gZS4kdmFsdWU7XCIpO2soXCJyZXR1cm4gdW5kZWZpbmVkO1wiKTtrKFwifSBlbHNlIHsgdGhyb3cgZTsgfVwiKTtrKFwifVwiKTtrKFwiKTtcIik7ayhcIn1cIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO1xuayhkLFwiPSRyZXQ7XCIpO2soXCJpZihcIixkLFwiPT09dW5kZWZpbmVkKSB7XCIpO2soXCIkZ2VuLmdpJHNlbnR2YWx1ZT0kZ2VuLlwiK2MrXCIuZ2kkcmV0O1wiKTtrKFwiJGJsaz1cIixuLFwiO2NvbnRpbnVlO1wiKTtrKFwifVwiKTtrKFwicmV0dXJuIFsvKnJlc3VtZSovXCIsbSxcIiwvKnJldCovXCIsZCxcIl07XCIpO3RoaXMuc2V0QmxvY2sobik7cmV0dXJuXCIkZ2VuLmdpJHNlbnR2YWx1ZVwifTtiLnByb3RvdHlwZS5jY29tcGFyZT1mdW5jdGlvbihhKXt2YXIgYztTay5hc3NlcnRzLmFzc2VydChhLm9wcy5sZW5ndGg9PT1hLmNvbXBhcmF0b3JzLmxlbmd0aCk7dmFyIG09dGhpcy52ZXhwcihhLmxlZnQpO3ZhciBuPWEub3BzLmxlbmd0aDt2YXIgZD10aGlzLm5ld0Jsb2NrKFwiZG9uZVwiKTt2YXIgbD10aGlzLl9ncihcImNvbXBhcmVyZXNcIixcIm51bGxcIik7Zm9yKGM9MDtjPG47KytjKXt2YXIgcj10aGlzLnZleHByKGEuY29tcGFyYXRvcnNbY10pO2NvbnN0IHY9YS5vcHNbY107dj09PVNrLmFzdG5vZGVzLklzP2soXCIkcmV0ID0gXCIsXG5tLFwiPT09XCIscixcIjtcIik6dj09PVNrLmFzdG5vZGVzLklzTm90P2soXCIkcmV0ID0gXCIsbSxcIiE9PVwiLHIsXCI7XCIpOihrKFwiJHJldCA9IFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChcIixtLFwiLFwiLHIsXCIsJ1wiLHYucHJvdG90eXBlLl9hc3RuYW1lLFwiJywgdHJ1ZSk7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbihhKSk7ayhsLFwiPVNrLmJ1aWx0aW4uYm9vbCgkcmV0KTtcIik7dGhpcy5fanVtcGZhbHNlKFwiJHJldFwiLGQpO209cn10aGlzLl9qdW1wKGQpO3RoaXMuc2V0QmxvY2soZCk7cmV0dXJuIGx9O2IucHJvdG90eXBlLmNjYWxsPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMudmV4cHIoYS5mdW5jKTtsZXQgbT10aGlzLmN1bnBhY2tzdGFyc3RvYXJyYXkoYS5hcmdzLCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO3ZhciBuPXRoaXMuY3VucGFja2t3c3RvYXJyYXkoYS5rZXl3b3JkcyxjKTtpZihhLmtleXdvcmRzJiYwPGEua2V5d29yZHMubGVuZ3RoKXtsZXQgZD0hMTtuPVtdO2ZvcihsZXQgbCBvZiBhLmtleXdvcmRzKXtpZihkJiZcbiFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJBZHZhbmNlZCB1bnBhY2tpbmcgb2YgZnVuY3Rpb24gYXJndW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIik7bC5hcmc/KG4ucHVzaChcIidcIitsLmFyZy52K1wiJ1wiKSxuLnB1c2godGhpcy52ZXhwcihsLnZhbHVlKSkpOmQ9ITB9bj1cIltcIituLmpvaW4oXCIsXCIpK1wiXVwiO2lmKGQpe249dGhpcy5fZ3IoXCJrZXl3b3JkQXJnc1wiLG4pO2ZvcihsZXQgbCBvZiBhLmtleXdvcmRzKWwuYXJnfHwoayhcIiRyZXQgPSBTay5hYnN0ci5tYXBwaW5nVW5wYWNrSW50b0tleXdvcmRBcnJheShcIixuLFwiLFwiLHRoaXMudmV4cHIobC52YWx1ZSksXCIsXCIsYyxcIik7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbigpKX19U2suX19mdXR1cmVfXy5zdXBlcl9hcmdzJiZhLmZ1bmMuaWQmJlwic3VwZXJcIj09PWEuZnVuYy5pZC52JiZcIltdXCI9PT1tJiYodGhpcy51LnRlbXBzVG9TYXZlLnB1c2goXCIkc3VwXCIpLGsoJ2lmICh0eXBlb2YgJHN1cCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0aHJvdyBuZXcgU2suYnVpbHRpbi5SdW50aW1lRXJyb3IoXCJzdXBlcigpOiBubyBhcmd1bWVudHNcIikgfTsnKSxcbm09XCJbJGdibC5fX2NsYXNzX18sJHN1cF1cIik7ayhcIiRyZXQgPSAoXCIsYyxcIi50cCRjYWxsKT9cIixjLFwiLnRwJGNhbGwoXCIsbSxcIixcIixuLFwiKSA6IFNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKFwiLGMsXCIsdW5kZWZpbmVkLHVuZGVmaW5lZCxcIixuLFwiLFwiLG0sXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7cmV0dXJuIHRoaXMuX2dyKFwiY2FsbFwiLFwiJHJldFwiKX07Yi5wcm90b3R5cGUuY3NsaWNlPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5TbGljZSk7aWYoU2suX19mdXR1cmVfXy5weXRob24zKXt2YXIgYz1hLmxvd2VyP3RoaXMudmV4cHIoYS5sb3dlcik6XCJTay5idWlsdGluLm5vbmUubm9uZSRcIjt2YXIgbT1hLnVwcGVyP3RoaXMudmV4cHIoYS51cHBlcik6XCJTay5idWlsdGluLm5vbmUubm9uZSRcIn1lbHNlIGM9YS5sb3dlcj90aGlzLnZleHByKGEubG93ZXIpOmEuc3RlcD9cIlNrLmJ1aWx0aW4ubm9uZS5ub25lJFwiOlwibmV3IFNrLmJ1aWx0aW4uaW50XygwKVwiLFxubT1hLnVwcGVyP3RoaXMudmV4cHIoYS51cHBlcik6YS5zdGVwP1wiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI6XCJuZXcgU2suYnVpbHRpbi5pbnRfKDIxNDc0ODM2NDcpXCI7YT1hLnN0ZXA/dGhpcy52ZXhwcihhLnN0ZXApOlwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7cmV0dXJuIHRoaXMuX2dyKFwic2xpY2VcIixcIm5ldyBTay5idWlsdGluc1snc2xpY2UnXShcIixjLFwiLFwiLG0sXCIsXCIsYSxcIilcIil9O2IucHJvdG90eXBlLmVzbGljZT1mdW5jdGlvbihhKXt2YXIgYztTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgQXJyYXkpO3ZhciBtPVtdO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspbS5wdXNoKHRoaXMudnNsaWNlc3ViKGFbY10pKTtyZXR1cm4gdGhpcy5fZ3IoXCJleHRzbGljZVwiLFwibmV3IFNrLmJ1aWx0aW5zWyd0dXBsZSddKFtcIixtLFwiXSlcIil9O2IucHJvdG90eXBlLnZzbGljZXN1Yj1mdW5jdGlvbihhKXtzd2l0Y2goYS5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5JbmRleDp2YXIgYz1cbnRoaXMudmV4cHIoYS52YWx1ZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5TbGljZTpjPXRoaXMuY3NsaWNlKGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRWxsaXBzaXM6U2suYXNzZXJ0cy5mYWlsKFwidG9kbyBjb21waWxlLmpzIEVsbGlwc2lzO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkV4dFNsaWNlOmM9dGhpcy5lc2xpY2UoYS5kaW1zKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgc3Vic2NyaXB0IGtpbmRcIil9cmV0dXJuIGN9O2IucHJvdG90eXBlLnZzbGljZT1mdW5jdGlvbihhLGMsbSxuKXthPXRoaXMudnNsaWNlc3ViKGEpO3JldHVybiB0aGlzLmNoYW5kbGVzdWJzY3IoYyxtLGEsbil9O2IucHJvdG90eXBlLmNoYW5kbGVzdWJzY3I9ZnVuY3Rpb24oYSxjLG0sbil7aWYoYT09PVNrLmFzdG5vZGVzLkxvYWR8fGE9PT1Tay5hc3Rub2Rlcy5BdWdMb2FkKXJldHVybiBrKFwiJHJldCA9IFNrLmFic3RyLm9iamVjdEdldEl0ZW0oXCIsYyxcIixcIixtLFwiLCB0cnVlKTtcIiksXG50aGlzLl9jaGVja1N1c3BlbnNpb24oKSx0aGlzLl9ncihcImxzdWJzY3JcIixcIiRyZXRcIik7YT09PVNrLmFzdG5vZGVzLlN0b3JlfHxhPT09U2suYXN0bm9kZXMuQXVnU3RvcmU/KGsoXCIkcmV0ID0gU2suYWJzdHIub2JqZWN0U2V0SXRlbShcIixjLFwiLFwiLG0sXCIsXCIsbixcIiwgdHJ1ZSk7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbigpKTphPT09U2suYXN0bm9kZXMuRGVsP2soXCJTay5hYnN0ci5vYmplY3REZWxJdGVtKFwiLGMsXCIsXCIsbSxcIik7XCIpOlNrLmFzc2VydHMuZmFpbChcImhhbmRsZXN1YnNjciBmYWlsXCIpfTtiLnByb3RvdHlwZS5jYm9vbG9wPWZ1bmN0aW9uKGEpe3ZhciBjLG07U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkJvb2xPcCk7dmFyIG49YS5vcD09PVNrLmFzdG5vZGVzLkFuZD90aGlzLl9qdW1wZmFsc2U6dGhpcy5fanVtcHRydWU7dmFyIGQ9dGhpcy5uZXdCbG9jayhcImVuZCBvZiBib29sb3BcIik7dmFyIGw9YS52YWx1ZXM7dmFyIHI9bC5sZW5ndGg7XG5mb3IoYz0wO2M8cjsrK2MpYT10aGlzLnZleHByKGxbY10pLDA9PT1jJiYobT10aGlzLl9ncihcImJvb2xvcHN1Y2NcIixhKSksayhtLFwiPVwiLGEsXCI7XCIpLG4uY2FsbCh0aGlzLGEsZCk7dGhpcy5fanVtcChkKTt0aGlzLnNldEJsb2NrKGQpO3JldHVybiBtfTtiLnByb3RvdHlwZS5jam9pbmVkc3RyPWZ1bmN0aW9uKGEpe2xldCBjO1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5Kb2luZWRTdHIpO2ZvcihsZXQgbSBvZiBhLnZhbHVlcylhPXRoaXMudmV4cHIobSksYz9rKGMsXCI9XCIsYyxcIi5zcSRjb25jYXQoXCIsYSxcIik7XCIpOmM9dGhpcy5fZ3IoXCJqb2luZWRzdHJcIixhKTtjfHwoYz1cIlNrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0clwiKTtyZXR1cm4gY307Yi5wcm90b3R5cGUuY2Zvcm1hdHRlZHZhbHVlPWZ1bmN0aW9uKGEpe2xldCBjPXRoaXMudmV4cHIoYS52YWx1ZSk7c3dpdGNoKGEuY29udmVyc2lvbil7Y2FzZSBcInNcIjpjPXRoaXMuX2dyKFwidmFsdWVcIixcIm5ldyBTay5idWlsdGluLnN0cihcIixcbmMsXCIpXCIpO2JyZWFrO2Nhc2UgXCJhXCI6Yz10aGlzLl9ncihcInZhbHVlXCIsXCJTay5idWlsdGluLmFzY2lpKFwiLGMsXCIpXCIpO2JyZWFrO2Nhc2UgXCJyXCI6Yz10aGlzLl9ncihcInZhbHVlXCIsXCJTay5idWlsdGluLnJlcHIoXCIsYyxcIilcIil9YT1hLmZvcm1hdF9zcGVjP3RoaXMudmV4cHIoYS5mb3JtYXRfc3BlYyk6XCJTay5idWlsdGluLnN0ci4kZW1wdHlzdHJcIjtyZXR1cm4gdGhpcy5fZ3IoXCJmb3JtYXR0ZWRcIixcIlNrLmFic3RyLm9iamVjdEZvcm1hdChcIitjK1wiLFwiK2ErXCIpXCIpfTtiLnByb3RvdHlwZS52ZXhwcj1mdW5jdGlvbihhLGMsbSxuKXt2YXIgZDthLmxpbmVubz50aGlzLnUubGluZW5vJiYodGhpcy51LmxpbmVubz1hLmxpbmVubyx0aGlzLnUubGluZW5vU2V0PSExKTtzd2l0Y2goYS5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5Cb29sT3A6cmV0dXJuIHRoaXMuY2Jvb2xvcChhKTtjYXNlIFNrLmFzdG5vZGVzLkJpbk9wOnJldHVybiB0aGlzLl9ncihcImJpbm9wXCIsXCJTay5hYnN0ci5udW1iZXJCaW5PcChcIixcbnRoaXMudmV4cHIoYS5sZWZ0KSxcIixcIix0aGlzLnZleHByKGEucmlnaHQpLFwiLCdcIixhLm9wLnByb3RvdHlwZS5fYXN0bmFtZSxcIicpXCIpO2Nhc2UgU2suYXN0bm9kZXMuVW5hcnlPcDpyZXR1cm4gdGhpcy5fZ3IoXCJ1bmFyeW9wXCIsXCJTay5hYnN0ci5udW1iZXJVbmFyeU9wKFwiLHRoaXMudmV4cHIoYS5vcGVyYW5kKSxcIiwnXCIsYS5vcC5wcm90b3R5cGUuX2FzdG5hbWUsXCInKVwiKTtjYXNlIFNrLmFzdG5vZGVzLkxhbWJkYTpyZXR1cm4gdGhpcy5jbGFtYmRhKGEpO2Nhc2UgU2suYXN0bm9kZXMuSWZFeHA6cmV0dXJuIHRoaXMuY2lmZXhwKGEpO2Nhc2UgU2suYXN0bm9kZXMuRGljdDpyZXR1cm4gdGhpcy5jZGljdChhKTtjYXNlIFNrLmFzdG5vZGVzLkxpc3RDb21wOnJldHVybiB0aGlzLmNsaXN0Y29tcChhKTtjYXNlIFNrLmFzdG5vZGVzLkRpY3RDb21wOnJldHVybiB0aGlzLmNkaWN0Y29tcChhKTtjYXNlIFNrLmFzdG5vZGVzLlNldENvbXA6cmV0dXJuIHRoaXMuY3NldGNvbXAoYSk7Y2FzZSBTay5hc3Rub2Rlcy5HZW5lcmF0b3JFeHA6cmV0dXJuIHRoaXMuY2dlbmV4cChhKTtcbmNhc2UgU2suYXN0bm9kZXMuWWllbGQ6cmV0dXJuIHRoaXMuY3lpZWxkKGEpO2Nhc2UgU2suYXN0bm9kZXMuWWllbGRGcm9tOnJldHVybiB0aGlzLmN5aWVsZGZyb20oYSk7Y2FzZSBTay5hc3Rub2Rlcy5Db21wYXJlOnJldHVybiB0aGlzLmNjb21wYXJlKGEpO2Nhc2UgU2suYXN0bm9kZXMuQ2FsbDpyZXR1cm4gYz10aGlzLmNjYWxsKGEpLHRoaXMuYW5ub3RhdGVTb3VyY2UoYSksYztjYXNlIFNrLmFzdG5vZGVzLk51bTppZihcIm51bWJlclwiPT09dHlwZW9mIGEubilyZXR1cm4gYS5uO2lmKGEubiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKXJldHVybiB0aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLmxuZygnXCIrYS5uLnYudG9TdHJpbmcoKStcIicpXCIpO2lmKGEubiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XylyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGEubi52P3RoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uaW50XyhcIithLm4uditcIilcIik6dGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5pbnRfKCdcIitcbmEubi52LnRvU3RyaW5nKCkrXCInKVwiKTtpZihhLm4gaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XylyZXR1cm4gYT0wPT09YS5uLnYmJi1JbmZpbml0eT09PTEvYS5uLnY/XCItMFwiOmEubi52LHRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uZmxvYXRfKFwiK2ErXCIpXCIpO2lmKGEubiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uY29tcGxleClyZXR1cm4gdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5jb21wbGV4KFwiKygwPT09YS5uLnJlYWwmJi1JbmZpbml0eT09PTEvYS5uLnJlYWw/XCItMFwiOmEubi5yZWFsKStcIiwgXCIrKDA9PT1hLm4uaW1hZyYmLUluZmluaXR5PT09MS9hLm4uaW1hZz9cIi0wXCI6YS5uLmltYWcpK1wiKVwiKTtTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgTnVtIHR5cGVcIik7Y2FzZSBTay5hc3Rub2Rlcy5CeXRlczppZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpe2M9W107YT1hLnMuJGpzc3RyKCk7Zm9yKG09MDttPGEubGVuZ3RoO20rKyljLnB1c2goYS5jaGFyQ29kZUF0KG0pKTtcbnJldHVybiB0aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLmJ5dGVzKFtcIixjLmpvaW4oXCIsIFwiKSxcIl0pXCIpfWNhc2UgU2suYXN0bm9kZXMuU3RyOmM9dGhpcy5tYWtlQ29uc3RhbnQ7YT1hLnMuJGpzc3RyKCk7bT0nXCInO2ZvcihkPTA7ZDxhLmxlbmd0aDtkKyspbj1hLmNoYXJDb2RlQXQoZCksbT0xMD09bj9tK1wiXFxcXG5cIjo5Mj09bj9tK1wiXFxcXFxcXFxcIjozND09bnx8MzI+bnx8MTI3PD1uJiYyNTY+bj9tKyhcIlxcXFx4XCIrKFwiMFwiK24udG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpKToyNTY8PW4/bSsoXCJcXFxcdVwiKyhcIjAwMFwiK24udG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpKTptK2EuY2hhckF0KGQpO2E9bSsnXCInO3JldHVybiBjLmNhbGwodGhpcyxcIm5ldyBTay5idWlsdGluLnN0cihcIixhLFwiKVwiKTtjYXNlIFNrLmFzdG5vZGVzLkF0dHJpYnV0ZTphLmN0eCE9PVNrLmFzdG5vZGVzLkF1Z0xvYWQmJmEuY3R4IT09U2suYXN0bm9kZXMuQXVnU3RvcmUmJihkPXRoaXMudmV4cHIoYS52YWx1ZSkpO1xubj1hLmF0dHIuJHIoKS52O249bi5zdWJzdHJpbmcoMSxuLmxlbmd0aC0xKTtuPWcodGhpcy51LnByaXZhdGVfLG5ldyBTay5idWlsdGluLnN0cihuKSkudjtuPXRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uc3RyKCdcIituK1wiJylcIik7c3dpdGNoKGEuY3R4KXtjYXNlIFNrLmFzdG5vZGVzLkF1Z0xvYWQ6cmV0dXJuIGsoXCIkcmV0ID0gXCIsbSxcIi50cCRnZXRhdHRyKFwiLG4sXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oYSksayhcIlxcbmlmICgkcmV0ID09PSB1bmRlZmluZWQpIHtcIiksayhcIlxcbnRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiLG0sJy5zayRhdHRyRXJyb3IoKSArIFwiIGhhcyBubyBhdHRyaWJ1dGUgXFwnXCIgKyAnLG4sJy4kanNzdHIoKSArIFwiXFwnXCIpOycpLGsoXCJcXG59O1wiKSx0aGlzLl9ncihcImxhdHRyXCIsXCIkcmV0XCIpO2Nhc2UgU2suYXN0bm9kZXMuTG9hZDpyZXR1cm4gayhcIiRyZXQgPSBcIixkLFwiLnRwJGdldGF0dHIoXCIsbixcIiwgdHJ1ZSk7XCIpLFxudGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpLGsoXCJcXG5pZiAoJHJldCA9PT0gdW5kZWZpbmVkKSB7XCIpLGsoXCJcXG50aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcIixkLCcuc2skYXR0ckVycm9yKCkgKyBcIiBoYXMgbm8gYXR0cmlidXRlIFxcJ1wiICsgJyxuLCcuJGpzc3RyKCkgKyBcIlxcJ1wiKTsnKSxrKFwiXFxufTtcIiksdGhpcy5fZ3IoXCJsYXR0clwiLFwiJHJldFwiKTtjYXNlIFNrLmFzdG5vZGVzLkF1Z1N0b3JlOmsoXCIkcmV0ID0gdW5kZWZpbmVkO1wiKTtrKFwiaWYoXCIsYyxcIiE9PXVuZGVmaW5lZCl7XCIpO2soXCIkcmV0ID0gXCIsbSxcIi50cCRzZXRhdHRyKFwiLG4sXCIsXCIsYyxcIiwgdHJ1ZSk7XCIpO2soXCJ9XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlN0b3JlOmsoXCIkcmV0ID0gXCIsZCxcIi50cCRzZXRhdHRyKFwiLG4sXCIsXCIsYyxcIiwgdHJ1ZSk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbDprKFwiJHJldCA9IFwiLFxuZCxcIi50cCRzZXRhdHRyKFwiLG4sXCIsIHVuZGVmaW5lZCwgdHJ1ZSk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgYXR0cmlidXRlIGV4cHJlc3Npb25cIil9YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5TdWJzY3JpcHQ6c3dpdGNoKGEuY3R4KXtjYXNlIFNrLmFzdG5vZGVzLkF1Z0xvYWQ6cmV0dXJuIGsoXCIkcmV0ID0gU2suYWJzdHIub2JqZWN0R2V0SXRlbShcIixtLFwiLFwiLG4sXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oYSksdGhpcy5fZ3IoXCJnaXRlbVwiLFwiJHJldFwiKTtjYXNlIFNrLmFzdG5vZGVzLkxvYWQ6Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTpjYXNlIFNrLmFzdG5vZGVzLkRlbDpyZXR1cm4gdGhpcy52c2xpY2UoYS5zbGljZSxhLmN0eCx0aGlzLnZleHByKGEudmFsdWUpLGMpO2Nhc2UgU2suYXN0bm9kZXMuQXVnU3RvcmU6ayhcIiRyZXQ9dW5kZWZpbmVkO1wiKTtrKFwiaWYoXCIsYyxcIiE9PXVuZGVmaW5lZCl7XCIpO1xuayhcIiRyZXQ9U2suYWJzdHIub2JqZWN0U2V0SXRlbShcIixtLFwiLFwiLG4sXCIsXCIsYyxcIiwgdHJ1ZSlcIik7ayhcIn1cIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwiaW52YWxpZCBzdWJzY3JpcHQgZXhwcmVzc2lvblwiKX1icmVhaztjYXNlIFNrLmFzdG5vZGVzLk5hbWU6cmV0dXJuIHRoaXMubmFtZW9wKGEuaWQsYS5jdHgsYyk7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lQ29uc3RhbnQ6aWYoYS5jdHg9PT1Tay5hc3Rub2Rlcy5TdG9yZXx8YS5jdHg9PT1Tay5hc3Rub2Rlcy5BdWdTdG9yZXx8YS5jdHg9PT1Tay5hc3Rub2Rlcy5EZWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJjYW4gbm90IGFzc2lnbiB0byBhIGNvbnN0YW50IG5hbWVcIik7c3dpdGNoKGEudmFsdWUpe2Nhc2UgU2suYnVpbHRpbi5ub25lLm5vbmUkOnJldHVyblwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7Y2FzZSBTay5idWlsdGluLmJvb2wudHJ1ZSQ6cmV0dXJuXCJTay5idWlsdGluLmJvb2wudHJ1ZSRcIjtcbmNhc2UgU2suYnVpbHRpbi5ib29sLmZhbHNlJDpyZXR1cm5cIlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSRcIjtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgbmFtZWQgY29uc3RhbnRcIil9YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5MaXN0OnJldHVybiB0aGlzLmN0dXBsZWxpc3RvcnNldChhLGMsXCJsaXN0XCIpO2Nhc2UgU2suYXN0bm9kZXMuVHVwbGU6cmV0dXJuIHRoaXMuY3R1cGxlbGlzdG9yc2V0KGEsYyxcInR1cGxlXCIpO2Nhc2UgU2suYXN0bm9kZXMuU2V0OnJldHVybiB0aGlzLmN0dXBsZWxpc3RvcnNldChhLGMsXCJzZXRcIik7Y2FzZSBTay5hc3Rub2Rlcy5TdGFycmVkOnN3aXRjaChhLmN0eCl7Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInN0YXJyZWQgYXNzaWdubWVudCB0YXJnZXQgbXVzdCBiZSBpbiBhIGxpc3Qgb3IgdHVwbGVcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTtkZWZhdWx0OnRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiY2FuJ3QgdXNlIHN0YXJyZWQgZXhwcmVzc2lvbiBoZXJlXCIsXG50aGlzLmZpbGVuYW1lLGEubGluZW5vKTt9Y2FzZSBTay5hc3Rub2Rlcy5Kb2luZWRTdHI6cmV0dXJuIHRoaXMuY2pvaW5lZHN0cihhKTtjYXNlIFNrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlOnJldHVybiB0aGlzLmNmb3JtYXR0ZWR2YWx1ZShhKTtjYXNlIFNrLmFzdG5vZGVzLkVsbGlwc2lzOnJldHVybiB0aGlzLm1ha2VDb25zdGFudChcIlNrLmJ1aWx0aW4uRWxsaXBzaXNcIik7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgY2FzZSBcIithLmNvbnN0cnVjdG9yLm5hbWUrXCIgdmV4cHJcIil9fTtiLnByb3RvdHlwZS52c2VxZXhwcj1mdW5jdGlvbihhLGMpe3ZhciBtO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMD09PWN8fGEubGVuZ3RoPT09Yy5sZW5ndGgpO3ZhciBuPVtdO2ZvcihtPTA7bTxhLmxlbmd0aDsrK20pbi5wdXNoKHRoaXMudmV4cHIoYVttXSx2b2lkIDA9PT1jP3ZvaWQgMDpjW21dKSk7cmV0dXJuIG59O2IucHJvdG90eXBlLmNhbm5hc3NpZ249ZnVuY3Rpb24oYSl7dmFyIGM9XG5hLnRhcmdldDtsZXQgbT1hLnZhbHVlO20mJihtPXRoaXMudmV4cHIoYS52YWx1ZSksdGhpcy52ZXhwcihjLG0pKTtzd2l0Y2goYy5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOiFhLnNpbXBsZXx8dGhpcy51LnN0ZS5ibG9ja1R5cGUhPT1Tay5TWU1UQUJfQ09OU1RTLkNsYXNzQmxvY2smJnRoaXMudS5zdGUuYmxvY2tUeXBlIT1Tay5TWU1UQUJfQ09OU1RTLk1vZHVsZUJsb2NrfHwodGhpcy51Lmhhc0Fubm90YXRpb25zPSEwLGE9dGhpcy52ZXhwcihhLmFubm90YXRpb24pLGM9ZShnKHRoaXMudS5wcml2YXRlXyxjLmlkKS52KSxjPXRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uc3RyKCdcIitjK1wiJylcIiksdGhpcy5jaGFuZGxlc3Vic2NyKFNrLmFzdG5vZGVzLlN0b3JlLFwiJGxvYy5fX2Fubm90YXRpb25zX19cIixjLGEpKX19O2IucHJvdG90eXBlLmNhdWdhc3NpZ249ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkF1Z0Fzc2lnbik7XG52YXIgYz1hLnRhcmdldDtzd2l0Y2goYy5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5BdHRyaWJ1dGU6dmFyIG09dGhpcy52ZXhwcihjLnZhbHVlKTtjPW5ldyBTay5hc3Rub2Rlcy5BdHRyaWJ1dGUoYy52YWx1ZSxjLmF0dHIsU2suYXN0bm9kZXMuQXVnTG9hZCxjLmxpbmVubyxjLmNvbF9vZmZzZXQpO3ZhciBuPXRoaXMudmV4cHIoYyx2b2lkIDAsbSk7dmFyIGQ9dGhpcy52ZXhwcihhLnZhbHVlKTthPXRoaXMuX2dyKFwiaW5wbGJpbm9wYXR0clwiLFwiU2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKFwiLG4sXCIsXCIsZCxcIiwnXCIsYS5vcC5wcm90b3R5cGUuX2FzdG5hbWUsXCInKVwiKTtjLmN0eD1Tay5hc3Rub2Rlcy5BdWdTdG9yZTtyZXR1cm4gdGhpcy52ZXhwcihjLGEsbSk7Y2FzZSBTay5hc3Rub2Rlcy5TdWJzY3JpcHQ6bT10aGlzLnZleHByKGMudmFsdWUpO3ZhciBsPXRoaXMudnNsaWNlc3ViKGMuc2xpY2UpO2M9bmV3IFNrLmFzdG5vZGVzLlN1YnNjcmlwdChjLnZhbHVlLGwsXG5Tay5hc3Rub2Rlcy5BdWdMb2FkLGMubGluZW5vLGMuY29sX29mZnNldCk7bj10aGlzLnZleHByKGMsdm9pZCAwLG0sbCk7ZD10aGlzLnZleHByKGEudmFsdWUpO2E9dGhpcy5fZ3IoXCJpbnBsYmlub3BzdWJzY3JcIixcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChcIixuLFwiLFwiLGQsXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFwiJylcIik7Yy5jdHg9U2suYXN0bm9kZXMuQXVnU3RvcmU7cmV0dXJuIHRoaXMudmV4cHIoYyxhLG0sbCk7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOnJldHVybiBtPXRoaXMubmFtZW9wKGMuaWQsU2suYXN0bm9kZXMuTG9hZCksZD10aGlzLnZleHByKGEudmFsdWUpLGE9dGhpcy5fZ3IoXCJpbnBsYmlub3BcIixcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChcIixtLFwiLFwiLGQsXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFwiJylcIiksdGhpcy5uYW1lb3AoYy5pZCxTay5hc3Rub2Rlcy5TdG9yZSxhKTtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlIGluIGF1Z2Fzc2lnblwiKX19O1xuYi5wcm90b3R5cGUuZXhwckNvbnN0YW50PWZ1bmN0aW9uKGEpe3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLk51bTpyZXR1cm4gU2subWlzY2V2YWwuaXNUcnVlKGEubik/MTowO2Nhc2UgU2suYXN0bm9kZXMuU3RyOnJldHVybiBTay5taXNjZXZhbC5pc1RydWUoYS5zKT8xOjA7ZGVmYXVsdDpyZXR1cm4tMX19O2IucHJvdG90eXBlLm5ld0Jsb2NrPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMudS5ibG9ja251bSsrO3RoaXMudS5ibG9ja3NbY109W107dGhpcy51LmJsb2Nrc1tjXS5fbmFtZT1hfHxcIjx1bm5hbWVkPlwiO3RoaXMudS5ibG9ja3NbY10uX25leHQ9bnVsbDtyZXR1cm4gY307Yi5wcm90b3R5cGUuc2V0QmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO3RoaXMudS5jdXJibG9jaz1hfTtiLnByb3RvdHlwZS5wdXNoQnJlYWtCbG9jaz1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCgwPD1hJiZcbmE8dGhpcy51LmJsb2NrbnVtKTt0aGlzLnUuYnJlYWtCbG9ja3MucHVzaChhKX07Yi5wcm90b3R5cGUucG9wQnJlYWtCbG9jaz1mdW5jdGlvbigpe3RoaXMudS5icmVha0Jsb2Nrcy5wb3AoKX07Yi5wcm90b3R5cGUucHVzaENvbnRpbnVlQmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO3RoaXMudS5jb250aW51ZUJsb2Nrcy5wdXNoKGEpfTtiLnByb3RvdHlwZS5wb3BDb250aW51ZUJsb2NrPWZ1bmN0aW9uKCl7dGhpcy51LmNvbnRpbnVlQmxvY2tzLnBvcCgpfTtiLnByb3RvdHlwZS5wdXNoRXhjZXB0QmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO3RoaXMudS5leGNlcHRCbG9ja3MucHVzaChhKX07Yi5wcm90b3R5cGUucG9wRXhjZXB0QmxvY2s9ZnVuY3Rpb24oKXt0aGlzLnUuZXhjZXB0QmxvY2tzLnBvcCgpfTtiLnByb3RvdHlwZS5wdXNoRmluYWxseUJsb2NrPVxuZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGg9PT10aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoKTt0aGlzLnUuZmluYWxseUJsb2Nrcy5wdXNoKHtibGs6YSxicmVha0RlcHRoOnRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGh9KX07Yi5wcm90b3R5cGUucG9wRmluYWxseUJsb2NrPWZ1bmN0aW9uKCl7dGhpcy51LmZpbmFsbHlCbG9ja3MucG9wKCl9O2IucHJvdG90eXBlLnBlZWtGaW5hbGx5QmxvY2s9ZnVuY3Rpb24oKXtyZXR1cm4gMDx0aGlzLnUuZmluYWxseUJsb2Nrcy5sZW5ndGg/dGhpcy51LmZpbmFsbHlCbG9ja3NbdGhpcy51LmZpbmFsbHlCbG9ja3MubGVuZ3RoLTFdOnZvaWQgMH07Yi5wcm90b3R5cGUuc2V0dXBFeGNlcHQ9ZnVuY3Rpb24oYSl7ayhcIiRleGMucHVzaChcIixhLFwiKTtcIil9O2IucHJvdG90eXBlLmVuZEV4Y2VwdD1mdW5jdGlvbigpe2soXCIkZXhjLnBvcCgpO1wiKX07XG5iLnByb3RvdHlwZS5vdXRwdXRMb2NhbHM9ZnVuY3Rpb24oYSl7dmFyIGMsbT17fTtmb3IoYz0wO2EuYXJnbmFtZXMmJmM8YS5hcmduYW1lcy5sZW5ndGg7KytjKW1bYS5hcmduYW1lc1tjXV09ITA7YS5sb2NhbG5hbWVzLnNvcnQoKTt2YXIgbj1bXTtmb3IoYz0wO2M8YS5sb2NhbG5hbWVzLmxlbmd0aDsrK2Mpe3ZhciBkPWEubG9jYWxuYW1lc1tjXTt2b2lkIDA9PT1tW2RdJiYobi5wdXNoKGQpLG1bZF09ITApfXJldHVybiAwPG4ubGVuZ3RoP1widmFyIFwiK24uam9pbihcIixcIikrXCI7IC8qIGxvY2FscyAqL1wiOlwiXCJ9O2IucHJvdG90eXBlLm91dHB1dFN1c3BlbnNpb25IZWxwZXJzPWZ1bmN0aW9uKGEpe3ZhciBjLG09W10sbj1hLmxvY2FsbmFtZXMuY29uY2F0KGEudGVtcHNUb1NhdmUpLGQ9e30sbD1hLnN0ZS5ibG9ja1R5cGU9PT1Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2smJmEuc3RlLmNoaWxkSGFzRnJlZSxyPSgwPG4ubGVuZ3RoP1widmFyIFwiK24uam9pbihcIixcIikrXCI7XCI6XCJcIikrXG5cInZhciAkd2FrZUZyb21TdXNwZW5zaW9uID0gZnVuY3Rpb24oKSB7dmFyIHN1c3AgPSBcIithLnNjb3BlbmFtZStcIi4kd2FraW5nU3VzcGVuc2lvbjsgXCIrYS5zY29wZW5hbWUrXCIuJHdha2luZ1N1c3BlbnNpb24gPSB1bmRlZmluZWQ7JGJsaz1zdXNwLiRibGs7ICRsb2M9c3VzcC4kbG9jOyAkZ2JsPXN1c3AuJGdibDsgJGV4Yz1zdXNwLiRleGM7ICRlcnI9c3VzcC4kZXJyOyAkcG9zdGZpbmFsbHk9c3VzcC4kcG9zdGZpbmFsbHk7JGN1cnJMaW5lTm89c3VzcC4kbGluZW5vOyAkY3VyckNvbE5vPXN1c3AuJGNvbG5vOyBTay5sYXN0WWllbGQ9RGF0ZS5ub3coKTtcIisobD9cIiRjZWxsPXN1c3AuJGNlbGw7XCI6XCJcIik7Zm9yKGM9MDtjPG4ubGVuZ3RoO2MrKyl7dmFyIHY9bltjXTt2b2lkIDA9PT1kW3ZdJiYocis9ditcIj1zdXNwLiR0bXBzLlwiK3YrXCI7XCIsZFt2XT0hMCl9cis9XCJ0cnkgeyAkcmV0PXN1c3AuY2hpbGQucmVzdW1lKCk7IH0gY2F0Y2goZXJyKSB7IGlmICghKGVyciBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikpIHsgZXJyID0gbmV3IFNrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvcihlcnIpOyB9IGVyci50cmFjZWJhY2sucHVzaCh7bGluZW5vOiAkY3VyckxpbmVObywgY29sbm86ICRjdXJyQ29sTm8sIGZpbGVuYW1lOiAnXCIrXG50aGlzLmZpbGVuYW1lK1wiJ30pOyBpZigkZXhjLmxlbmd0aD4wKSB7ICRlcnI9ZXJyOyAkYmxrPSRleGMucG9wKCk7IH0gZWxzZSB7IHRocm93IGVycjsgfSB9fTtcIjtyKz1cInZhciAkc2F2ZVN1c3BlbnNpb24gPSBmdW5jdGlvbigkY2hpbGQsICRmaWxlbmFtZSwgJGxpbmVubywgJGNvbG5vKSB7dmFyIHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpOyBzdXNwLmNoaWxkPSRjaGlsZDtzdXNwLnJlc3VtZT1mdW5jdGlvbigpe1wiK2Euc2NvcGVuYW1lK1wiLiR3YWtpbmdTdXNwZW5zaW9uPXN1c3A7IHJldHVybiBcIithLnNjb3BlbmFtZStcIihcIisoYS5zdGUuZ2VuZXJhdG9yP1wiJGdlblwiOlwiXCIpK1wiKTsgfTtzdXNwLmRhdGE9c3VzcC5jaGlsZC5kYXRhO3N1c3AuJGJsaz0kYmxrO3N1c3AuJGxvYz0kbG9jO3N1c3AuJGdibD0kZ2JsO3N1c3AuJGV4Yz0kZXhjO3N1c3AuJGVycj0kZXJyO3N1c3AuJHBvc3RmaW5hbGx5PSRwb3N0ZmluYWxseTtzdXNwLiRmaWxlbmFtZT0kZmlsZW5hbWU7c3VzcC4kbGluZW5vPSRsaW5lbm87c3VzcC4kY29sbm89JGNvbG5vO3N1c3Aub3B0aW9uYWw9c3VzcC5jaGlsZC5vcHRpb25hbDtcIitcbihsP1wic3VzcC4kY2VsbD0kY2VsbDtcIjpcIlwiKTtkPXt9O2ZvcihjPTA7YzxuLmxlbmd0aDtjKyspdj1uW2NdLHZvaWQgMD09PWRbdl0mJihtLnB1c2goJ1wiJyt2KydcIjonK3YpLGRbdl09ITApO3JldHVybiByKz1cInN1c3AuJHRtcHM9e1wiK20uam9pbihcIixcIikrXCJ9O3JldHVybiBzdXNwO307XCJ9O2IucHJvdG90eXBlLm91dHB1dEFsbFVuaXRzPWZ1bmN0aW9uKCl7dmFyIGEsYyxtPVwiXCI7Zm9yKGM9MDtjPHRoaXMuYWxsVW5pdHMubGVuZ3RoOysrYyl7dmFyIG49dGhpcy5hbGxVbml0c1tjXTttKz1uLnByZWZpeENvZGU7bSs9dGhpcy5vdXRwdXRMb2NhbHMobik7bi5kb2VzU3VzcGVuZCYmKG0rPXRoaXMub3V0cHV0U3VzcGVuc2lvbkhlbHBlcnMobikpO20rPW4udmFyRGVjbHNDb2RlO20rPW4uc3dpdGNoQ29kZTt2YXIgZD1uLmJsb2Nrczt2YXIgbD1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihhPTA7YTxkLmxlbmd0aDsrK2Epe3ZhciByPWE7aWYoIShyIGluIGwpKWZvcig7OylpZihsW3JdPVxuITAsbSs9XCJjYXNlIFwiK3IrXCI6IC8qIC0tLSBcIitkW3JdLl9uYW1lK1wiIC0tLSAqL1wiLG0rPWRbcl0uam9pbihcIlwiKSxudWxsIT09ZFtyXS5fbmV4dClpZihkW3JdLl9uZXh0IGluIGwpe20rPVwiLyoganVtcCAqLyBjb250aW51ZTtcIjticmVha31lbHNlIG0rPVwiLyogYWxsb3dpbmcgY2FzZSBmYWxsdGhyb3VnaCAqL1wiLHI9ZFtyXS5fbmV4dDtlbHNle20rPVwidGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3lzdGVtRXJyb3IoJ2ludGVybmFsIGVycm9yOiB1bnRlcm1pbmF0ZWQgYmxvY2snKTtcIjticmVha319bSs9bi5zdWZmaXhDb2RlfXJldHVybiBtfTtiLnByb3RvdHlwZS5jaWY9ZnVuY3Rpb24oYSl7dmFyIGM7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLklmKTt2YXIgbT10aGlzLmV4cHJDb25zdGFudChhLnRlc3QpO2lmKDA9PT1tKWEub3JlbHNlJiYwPGEub3JlbHNlLmxlbmd0aCYmdGhpcy52c2Vxc3RtdChhLm9yZWxzZSk7ZWxzZSBpZigxPT09bSl0aGlzLnZzZXFzdG10KGEuYm9keSk7XG5lbHNle3ZhciBuPXRoaXMubmV3QmxvY2soXCJlbmQgb2YgaWZcIik7YS5vcmVsc2UmJjA8YS5vcmVsc2UubGVuZ3RoJiYoYz10aGlzLm5ld0Jsb2NrKFwibmV4dCBicmFuY2ggb2YgaWZcIikpO209dGhpcy52ZXhwcihhLnRlc3QpO2Eub3JlbHNlJiYwPGEub3JlbHNlLmxlbmd0aD8odGhpcy5fanVtcGZhbHNlKG0sYyksdGhpcy52c2Vxc3RtdChhLmJvZHkpLHRoaXMuX2p1bXAobiksdGhpcy5zZXRCbG9jayhjKSx0aGlzLnZzZXFzdG10KGEub3JlbHNlKSk6KHRoaXMuX2p1bXBmYWxzZShtLG4pLHRoaXMudnNlcXN0bXQoYS5ib2R5KSk7dGhpcy5fanVtcChuKTt0aGlzLnNldEJsb2NrKG4pfX07Yi5wcm90b3R5cGUuY3doaWxlPWZ1bmN0aW9uKGEpe2lmKDA9PT10aGlzLmV4cHJDb25zdGFudChhLnRlc3QpKWEub3JlbHNlJiZ0aGlzLnZzZXFzdG10KGEub3JlbHNlKTtlbHNle3ZhciBjPXRoaXMubmV3QmxvY2soXCJ3aGlsZSB0ZXN0XCIpO3RoaXMuX2p1bXAoYyk7dGhpcy5zZXRCbG9jayhjKTtcbnZhciBtPXRoaXMubmV3QmxvY2soXCJhZnRlciB3aGlsZVwiKTt2YXIgbj0wPGEub3JlbHNlLmxlbmd0aD90aGlzLm5ld0Jsb2NrKFwid2hpbGUgb3JlbHNlXCIpOm51bGw7dmFyIGQ9dGhpcy5uZXdCbG9jayhcIndoaWxlIGJvZHlcIik7dGhpcy5hbm5vdGF0ZVNvdXJjZShhKTt0aGlzLl9qdW1wZmFsc2UodGhpcy52ZXhwcihhLnRlc3QpLG4/bjptKTt0aGlzLl9qdW1wKGQpO3RoaXMucHVzaEJyZWFrQmxvY2sobSk7dGhpcy5wdXNoQ29udGludWVCbG9jayhjKTt0aGlzLnNldEJsb2NrKGQpOyhTay5kZWJ1Z2dpbmd8fFNrLmtpbGxhYmxlV2hpbGUpJiZ0aGlzLnUuY2FuU3VzcGVuZCYmKGQ9dGhpcy5uZXdCbG9jayhcImRlYnVnIGJyZWFrcG9pbnQgZm9yIGxpbmUgXCIrYS5saW5lbm8pLGsoXCJpZiAoU2suYnJlYWtwb2ludHMoJ1wiK3RoaXMuZmlsZW5hbWUrXCInLFwiK2EubGluZW5vK1wiLFwiK2EuY29sX29mZnNldCtcIikpIHtcIixcInZhciAkc3VzcCA9ICRzYXZlU3VzcGVuc2lvbih7ZGF0YToge3R5cGU6ICdTay5kZWxheSd9LCByZXN1bWU6IGZ1bmN0aW9uKCkge319LCAnXCIrXG50aGlzLmZpbGVuYW1lK1wiJyxcIithLmxpbmVubytcIixcIithLmNvbF9vZmZzZXQrXCIpO1wiLFwiJHN1c3AuJGJsayA9IFwiK2QrXCI7XCIsXCIkc3VzcC5vcHRpb25hbCA9IHRydWU7XCIsXCJyZXR1cm4gJHN1c3A7XCIsXCJ9XCIpLHRoaXMuX2p1bXAoZCksdGhpcy5zZXRCbG9jayhkKSx0aGlzLnUuZG9lc1N1c3BlbmQ9ITApO3RoaXMudnNlcXN0bXQoYS5ib2R5KTt0aGlzLl9qdW1wKGMpO3RoaXMucG9wQ29udGludWVCbG9jaygpO3RoaXMucG9wQnJlYWtCbG9jaygpOzA8YS5vcmVsc2UubGVuZ3RoJiYodGhpcy5zZXRCbG9jayhuKSx0aGlzLnZzZXFzdG10KGEub3JlbHNlKSx0aGlzLl9qdW1wKG0pKTt0aGlzLnNldEJsb2NrKG0pfX07Yi5wcm90b3R5cGUuY2Zvcj1mdW5jdGlvbihhKXt2YXIgYz10aGlzLm5ld0Jsb2NrKFwiZm9yIHN0YXJ0XCIpLG09dGhpcy5uZXdCbG9jayhcImZvciBjbGVhbnVwXCIpLG49dGhpcy5uZXdCbG9jayhcImZvciBlbmRcIik7dGhpcy5wdXNoQnJlYWtCbG9jayhuKTt0aGlzLnB1c2hDb250aW51ZUJsb2NrKGMpO1xudmFyIGQ9dGhpcy52ZXhwcihhLml0ZXIpO2lmKHRoaXMudS5zdGUuZ2VuZXJhdG9yKXt2YXIgbD1cIiRsb2MuXCIrdGhpcy5nZW5zeW0oXCJpdGVyXCIpO2sobCxcIj1Tay5hYnN0ci5pdGVyKFwiLGQsXCIpO1wiKX1lbHNlIGw9dGhpcy5fZ3IoXCJpdGVyXCIsXCJTay5hYnN0ci5pdGVyKFwiLGQsXCIpXCIpLHRoaXMudS50ZW1wc1RvU2F2ZS5wdXNoKGwpO3RoaXMuX2p1bXAoYyk7dGhpcy5zZXRCbG9jayhjKTtrKFwiJHJldCA9IFNrLmFic3RyLml0ZXJuZXh0KFwiLGwsdGhpcy51LmNhblN1c3BlbmQ/XCIsIHRydWVcIjpcIiwgZmFsc2VcIixcIik7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTtsPXRoaXMuX2dyKFwibmV4dFwiLFwiJHJldFwiKTt0aGlzLl9qdW1wdW5kZWYobCxtKTt0aGlzLnZleHByKGEudGFyZ2V0LGwpOyhTay5kZWJ1Z2dpbmd8fFNrLmtpbGxhYmxlRm9yKSYmdGhpcy51LmNhblN1c3BlbmQmJihsPXRoaXMubmV3QmxvY2soXCJkZWJ1ZyBicmVha3BvaW50IGZvciBsaW5lIFwiK2EubGluZW5vKSxrKFwiaWYgKFNrLmJyZWFrcG9pbnRzKCdcIitcbnRoaXMuZmlsZW5hbWUrXCInLFwiK2EubGluZW5vK1wiLFwiK2EuY29sX29mZnNldCtcIikpIHtcIixcInZhciAkc3VzcCA9ICRzYXZlU3VzcGVuc2lvbih7ZGF0YToge3R5cGU6ICdTay5kZWxheSd9LCByZXN1bWU6IGZ1bmN0aW9uKCkge319LCAnXCIrdGhpcy5maWxlbmFtZStcIicsXCIrYS5saW5lbm8rXCIsXCIrYS5jb2xfb2Zmc2V0K1wiKTtcIixcIiRzdXNwLiRibGsgPSBcIitsK1wiO1wiLFwiJHN1c3Aub3B0aW9uYWwgPSB0cnVlO1wiLFwicmV0dXJuICRzdXNwO1wiLFwifVwiKSx0aGlzLl9qdW1wKGwpLHRoaXMuc2V0QmxvY2sobCksdGhpcy51LmRvZXNTdXNwZW5kPSEwKTt0aGlzLnZzZXFzdG10KGEuYm9keSk7dGhpcy5fanVtcChjKTt0aGlzLnNldEJsb2NrKG0pO3RoaXMucG9wQ29udGludWVCbG9jaygpO3RoaXMucG9wQnJlYWtCbG9jaygpO3RoaXMudnNlcXN0bXQoYS5vcmVsc2UpO3RoaXMuX2p1bXAobik7dGhpcy5zZXRCbG9jayhuKX07Yi5wcm90b3R5cGUuY3JhaXNlPWZ1bmN0aW9uKGEpe2lmKGEuZXhjKXt2YXIgYz1cbnRoaXMuX2dyKFwiZXhjXCIsdGhpcy52ZXhwcihhLmV4YykpLG09dGhpcy5uZXdCbG9jayhcImV4Y2VwdGlvbiBub3cgaW5zdGFudGlhdGVkXCIpLG49dGhpcy5fZ3IoXCJpc2NsYXNzXCIsYytcIi5wcm90b3R5cGUgaW5zdGFuY2VvZiBTay5idWlsdGluLkJhc2VFeGNlcHRpb25cIik7dGhpcy5fanVtcGZhbHNlKG4sbSk7YS5pbnN0PyhuPXRoaXMuX2dyKFwiaW5zdFwiLHRoaXMudmV4cHIoYS5pbnN0KSksayhcImlmKCEoXCIsbixcIiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKSB7XCIsbixcIj0gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW1wiLG4sXCJdKTtcIixcIn1cIiksayhcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoXCIsYyxcIixcIixuLFwiLnYpO1wiKSk6ayhcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kKFwiLGMsXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7ayhjLFwiPSRyZXQ7XCIpO3RoaXMuX2p1bXAobSk7dGhpcy5zZXRCbG9jayhtKTtrKFwiaWYgKFwiLGMsXG5cIiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikge3Rocm93IFwiLGMsXCI7fSBlbHNlIHt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoJ2V4Y2VwdGlvbnMgbXVzdCBkZXJpdmUgZnJvbSBCYXNlRXhjZXB0aW9uJyk7fTtcIil9ZWxzZSBrKFwidGhyb3cgJGVycjtcIil9O2IucHJvdG90eXBlLm91dHB1dEZpbmFsbHlDYXNjYWRlPWZ1bmN0aW9uKGEpe2lmKDA9PXRoaXMudS5maW5hbGx5QmxvY2tzLmxlbmd0aClrKFwiaWYoJHBvc3RmaW5hbGx5IT09dW5kZWZpbmVkKSB7IGlmICgkcG9zdGZpbmFsbHkucmV0dXJuaW5nKSB7IHJldHVybiAkcG9zdGZpbmFsbHkucmV0dXJuaW5nOyB9IGVsc2UgeyAkYmxrPSRwb3N0ZmluYWxseS5nb3RvQmxvY2s7ICRwb3N0ZmluYWxseT11bmRlZmluZWQ7IGNvbnRpbnVlOyB9IH1cIik7ZWxzZXt2YXIgYz10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTtrKFwiaWYoJHBvc3RmaW5hbGx5IT09dW5kZWZpbmVkKSB7XCIsXCJpZiAoJHBvc3RmaW5hbGx5LnJldHVybmluZ1wiLFxuYy5icmVha0RlcHRoPT1hLmJyZWFrRGVwdGg/XCJ8fCAkcG9zdGZpbmFsbHkuaXNCcmVha1wiOlwiXCIsXCIpIHtcIixcIiRibGs9XCIsYy5ibGssXCI7Y29udGludWU7XCIsXCJ9IGVsc2Uge1wiLFwiJGJsaz0kcG9zdGZpbmFsbHkuZ290b0Jsb2NrOyRwb3N0ZmluYWxseT11bmRlZmluZWQ7Y29udGludWU7XCIsXCJ9XCIsXCJ9XCIpfX07Yi5wcm90b3R5cGUuY3RyeT1mdW5jdGlvbihhKXt2YXIgYyxtPWEuaGFuZGxlcnMubGVuZ3RoO2lmKGEuZmluYWxib2R5KXt2YXIgbj10aGlzLm5ld0Jsb2NrKFwiZmluYWxib2R5XCIpO3ZhciBkPXRoaXMubmV3QmxvY2soXCJmaW5hbGV4aFwiKTt2YXIgbD10aGlzLl9ncihcImZpbmFsbHlfcmVyYWlzZVwiLFwidW5kZWZpbmVkXCIpO3RoaXMudS50ZW1wc1RvU2F2ZS5wdXNoKGwpO3RoaXMucHVzaEZpbmFsbHlCbG9jayhuKTt2YXIgcj10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTt0aGlzLnNldHVwRXhjZXB0KGQpfXZhciB2PVtdO2ZvcihjPTA7YzxtOysrYyl2LnB1c2godGhpcy5uZXdCbG9jayhcImV4Y2VwdF9cIitcbmMrXCJfXCIpKTt2YXIgcT10aGlzLm5ld0Jsb2NrKFwidW5oYW5kbGVkXCIpO3ZhciB0PXRoaXMubmV3QmxvY2soXCJvcmVsc2VcIik7dmFyIHc9dGhpcy5uZXdCbG9jayhcImVuZFwiKTswIT12Lmxlbmd0aCYmdGhpcy5zZXR1cEV4Y2VwdCh2WzBdKTt0aGlzLnZzZXFzdG10KGEuYm9keSk7MCE9di5sZW5ndGgmJnRoaXMuZW5kRXhjZXB0KCk7dGhpcy5fanVtcCh0KTtmb3IoYz0wO2M8bTsrK2Mpe3RoaXMuc2V0QmxvY2sodltjXSk7dmFyIEM9YS5oYW5kbGVyc1tjXTtpZighQy50eXBlJiZjPG0tMSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImRlZmF1bHQgJ2V4Y2VwdDonIG11c3QgYmUgbGFzdFwiLHRoaXMuZmlsZW5hbWUsQy5saW5lbm8pO2lmKEMudHlwZSl7dmFyIEQ9dGhpcy52ZXhwcihDLnR5cGUpO3ZhciBMPWM9PW0tMT9xOnZbYysxXTtEPXRoaXMuX2dyKFwiaW5zdGFuY2VcIixcIlNrLm1pc2NldmFsLmlzVHJ1ZShTay5idWlsdGluLmlzaW5zdGFuY2UoJGVyciwgXCIsRCxcIikpXCIpO1xudGhpcy5fanVtcGZhbHNlKEQsTCl9Qy5uYW1lJiZ0aGlzLnZleHByKEMubmFtZSxcIiRlcnJcIik7dGhpcy52c2Vxc3RtdChDLmJvZHkpO3RoaXMuX2p1bXAodyl9dGhpcy5zZXRCbG9jayhxKTtrKFwidGhyb3cgJGVycjtcIik7dGhpcy5zZXRCbG9jayh0KTt0aGlzLnZzZXFzdG10KGEub3JlbHNlKTt0aGlzLl9qdW1wKHcpO3RoaXMuc2V0QmxvY2sodyk7YS5maW5hbGJvZHkmJih0aGlzLmVuZEV4Y2VwdCgpLHRoaXMuX2p1bXAobiksdGhpcy5zZXRCbG9jayhkKSxrKGwsXCI9JGVycjtcIiksdGhpcy5fanVtcChuKSx0aGlzLnNldEJsb2NrKG4pLHRoaXMucG9wRmluYWxseUJsb2NrKCksdGhpcy52c2Vxc3RtdChhLmZpbmFsYm9keSksayhcImlmKFwiLGwsXCIhPT11bmRlZmluZWQpIHsgdGhyb3cgXCIsbCxcIjt9XCIpLHRoaXMub3V0cHV0RmluYWxseUNhc2NhZGUocikpfTtiLnByb3RvdHlwZS5jd2l0aD1mdW5jdGlvbihhLGMpe3ZhciBtPXRoaXMubmV3QmxvY2soXCJ3aXRoZXhoXCIpLG49dGhpcy5uZXdCbG9jayhcIndpdGh0aWR5dXBcIiksXG5kPXRoaXMubmV3QmxvY2soXCJ3aXRoY2FycnlvblwiKTt2YXIgbD10aGlzLl9ncihcIm1nclwiLHRoaXMudmV4cHIoYS5pdGVtc1tjXS5jb250ZXh0X2V4cHIpKTtrKFwiJHJldCA9IFNrLmFic3RyLmxvb2t1cFNwZWNpYWwoXCIsbCxcIixTay5idWlsdGluLnN0ci4kZXhpdCk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTt2YXIgcj10aGlzLl9ncihcImV4aXRcIixcIiRyZXRcIik7dGhpcy51LnRlbXBzVG9TYXZlLnB1c2gocik7ayhcIiRyZXQgPSBTay5hYnN0ci5sb29rdXBTcGVjaWFsKFwiLGwsXCIsU2suYnVpbHRpbi5zdHIuJGVudGVyKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2soXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KCRyZXQpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7bD10aGlzLl9ncihcInZhbHVlXCIsXCIkcmV0XCIpO3RoaXMucHVzaEZpbmFsbHlCbG9jayhuKTt2YXIgdj10aGlzLnUuZmluYWxseUJsb2Nrc1t0aGlzLnUuZmluYWxseUJsb2Nrcy5sZW5ndGgtXG4xXTt0aGlzLnNldHVwRXhjZXB0KG0pO2EuaXRlbXNbY10ub3B0aW9uYWxfdmFycyYmdGhpcy5uYW1lb3AoYS5pdGVtc1tjXS5vcHRpb25hbF92YXJzLmlkLFNrLmFzdG5vZGVzLlN0b3JlLGwpO2MrMTxhLml0ZW1zLmxlbmd0aD90aGlzLmN3aXRoKGEsYysxKTp0aGlzLnZzZXFzdG10KGEuYm9keSk7dGhpcy5lbmRFeGNlcHQoKTt0aGlzLl9qdW1wKG4pO3RoaXMuc2V0QmxvY2sobSk7ayhcIiRyZXQgPSBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChcIixyLFwiLHVuZGVmaW5lZCxTay5idWlsdGluLmdldEV4Y0luZm8oJGVyciksdW5kZWZpbmVkLFtdKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO3RoaXMuX2p1bXB0cnVlKFwiJHJldFwiLGQpO2soXCJ0aHJvdyAkZXJyO1wiKTt0aGlzLnNldEJsb2NrKG4pO3RoaXMucG9wRmluYWxseUJsb2NrKCk7ayhcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoXCIscixcIixbU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLm5vbmUubm9uZSRdKTtcIik7XG50aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7dGhpcy5vdXRwdXRGaW5hbGx5Q2FzY2FkZSh2KTt0aGlzLl9qdW1wKGQpO3RoaXMuc2V0QmxvY2soZCl9O2IucHJvdG90eXBlLmNhc3NlcnQ9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy52ZXhwcihhLnRlc3QpLG09dGhpcy5uZXdCbG9jayhcImVuZFwiKTt0aGlzLl9qdW1wdHJ1ZShjLG0pO2soXCJ0aHJvdyBuZXcgU2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcihcIixhLm1zZz90aGlzLnZleHByKGEubXNnKTpcIlwiLFwiKTtcIik7dGhpcy5zZXRCbG9jayhtKX07Yi5wcm90b3R5cGUuY2ltcG9ydGFzPWZ1bmN0aW9uKGEsYyxtKXthPWEudjt2YXIgbj1hLmluZGV4T2YoXCIuXCIpLGQ9bTtpZigtMSE9PW4pZm9yKGE9YS5zdWJzdHIobisxKTstMSE9PW47KW49YS5pbmRleE9mKFwiLlwiKSxtPS0xIT09bj9hLnN1YnN0cigwLG4pOmEsZD10aGlzLl9ncihcImxhdHRyXCIsXCJTay5hYnN0ci5nYXR0cihcIixkLFwiLCBuZXcgU2suYnVpbHRpbi5zdHIoJ1wiLG0sXCInKSlcIiksYT1cbmEuc3Vic3RyKG4rMSk7cmV0dXJuIHRoaXMubmFtZW9wKGMsU2suYXN0bm9kZXMuU3RvcmUsZCl9O2IucHJvdG90eXBlLmNpbXBvcnQ9ZnVuY3Rpb24oYSl7dmFyIGMsbT1hLm5hbWVzLmxlbmd0aDtmb3IoYz0wO2M8bTsrK2Mpe3ZhciBuPWEubmFtZXNbY107ayhcIiRyZXQgPSBTay5idWlsdGluLl9faW1wb3J0X18oXCIsbi5uYW1lLiRyKCkudixcIiwkZ2JsLCRsb2MsW10sXCIsU2suX19mdXR1cmVfXy5hYnNvbHV0ZV9pbXBvcnQ/MDotMSxcIik7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTt2YXIgZD10aGlzLl9ncihcIm1vZHVsZVwiLFwiJHJldFwiKTtpZihuLmFzbmFtZSl0aGlzLmNpbXBvcnRhcyhuLm5hbWUsbi5hc25hbWUsZCk7ZWxzZXt2YXIgbD1uLm5hbWU7bj1sLnYuaW5kZXhPZihcIi5cIik7LTEhPT1uJiYobD1uZXcgU2suYnVpbHRpbi5zdHIobC52LnN1YnN0cigwLG4pKSk7dGhpcy5uYW1lb3AobCxTay5hc3Rub2Rlcy5TdG9yZSxkKX19fTtiLnByb3RvdHlwZS5jZnJvbWltcG9ydD1cbmZ1bmN0aW9uKGEpe3ZhciBjLG09YS5uYW1lcy5sZW5ndGg7dmFyIG49W107dmFyIGQ9YS5sZXZlbDswIT1kfHxTay5fX2Z1dHVyZV9fLmFic29sdXRlX2ltcG9ydHx8KGQ9LTEpO2ZvcihjPTA7YzxtOysrYyluW2NdPVwiJ1wiK2EubmFtZXNbY10ubmFtZS52K1wiJ1wiO2soXCIkcmV0ID0gU2suYnVpbHRpbi5fX2ltcG9ydF9fKFwiLGEubW9kdWxlLiRyKCkudixcIiwkZ2JsLCRsb2MsW1wiLG4sXCJdLFwiLGQsXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7ZD10aGlzLl9ncihcIm1vZHVsZVwiLFwiJHJldFwiKTtmb3IoYz0wO2M8bTsrK2Mpe249YS5uYW1lc1tjXTt2YXIgbD1cIidcIituLm5hbWUuditcIidcIjtpZigwPT09YyYmXCIqXCI9PT1uLm5hbWUudil7U2suYXNzZXJ0cy5hc3NlcnQoMT09PW0pO2soXCJTay5pbXBvcnRTdGFyKFwiLGQsXCIsJGxvYywgJGdibCk7XCIpO2JyZWFrfXZhciByPXRoaXMuX2dyKFwiaXRlbVwiLFwiU2suYWJzdHIuZ2F0dHIoXCIsZCxcIiwgbmV3IFNrLmJ1aWx0aW4uc3RyKFwiLGwsXCIpLCB1bmRlZmluZWQpXCIpO1xubD1uLm5hbWU7bi5hc25hbWUmJihsPW4uYXNuYW1lKTt0aGlzLm5hbWVvcChsLFNrLmFzdG5vZGVzLlN0b3JlLHIpfX07Yi5wcm90b3R5cGUuYnVpbGRjb2Rlb2JqPWZ1bmN0aW9uKGEsYyxtLG4sZCxsKXt2YXIgcj1bXSx2LHE9W10sdD1bXSx3PVtdLEM9bnVsbCxEPW51bGw7bSYmKHE9dGhpcy52c2VxZXhwcihtKSk7biYmbi5kZWZhdWx0cyYmKHQ9dGhpcy52c2VxZXhwcihuLmRlZmF1bHRzKSk7bT10aGlzLmNhbm5vdGF0aW9ucyhuLGEucmV0dXJucyk7biYmbi5rd19kZWZhdWx0cyYmKHc9bi5rd19kZWZhdWx0cy5tYXAoUD0+UD90aGlzLnZleHByKFApOlwidW5kZWZpbmVkXCIpKTtuJiZuLnZhcmFyZyYmKEM9bi52YXJhcmcpO24mJm4ua3dhcmcmJihEPW4ua3dhcmcpO2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMmJm4mJm4ua3dvbmx5YXJncyYmMCE9bi5rd29ubHlhcmdzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIktleXdvcmQtb25seSBhcmd1bWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIik7XG52YXIgTD10aGlzLmVudGVyU2NvcGUoYyxhLGEubGluZW5vLHRoaXMuY2FuU3VzcGVuZCk7dmFyIE49dGhpcy51LnN0ZS5nZW5lcmF0b3I7dmFyIEE9dGhpcy51LnN0ZS5oYXNGcmVlO3ZhciBIPXRoaXMudS5zdGUuY2hpbGRIYXNGcmVlO3ZhciB4PXRoaXMubmV3QmxvY2soXCJjb2Rlb2JqIGVudHJ5XCIpO3RoaXMudS5wcmVmaXhDb2RlPVwidmFyIFwiK0wrXCI9KGZ1bmN0aW9uIFwiK3RoaXMubmljZU5hbWUoYy52KStcIiQoXCI7dmFyIEI9W107aWYoTil7aWYoRCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihjLnYrXCIoKToga2V5d29yZCBhcmd1bWVudHMgaW4gZ2VuZXJhdG9ycyBub3Qgc3VwcG9ydGVkXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7aWYoQyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihjLnYrXCIoKTogdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBnZW5lcmF0b3JzIG5vdCBzdXBwb3J0ZWRcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTtCLnB1c2goXCIkZ2VuXCIpfWVsc2V7RCYmXG4oQi5wdXNoKFwiJGt3YVwiKSx0aGlzLnUudGVtcHNUb1NhdmUucHVzaChcIiRrd2FcIikpO2Zvcih2PTA7biYmdjxuLmFyZ3MubGVuZ3RoOysrdilCLnB1c2godGhpcy5uYW1lb3Aobi5hcmdzW3ZdLmFyZyxTay5hc3Rub2Rlcy5QYXJhbSkpO2Zvcih2PTA7biYmbi5rd29ubHlhcmdzJiZ2PG4ua3dvbmx5YXJncy5sZW5ndGg7Kyt2KUIucHVzaCh0aGlzLm5hbWVvcChuLmt3b25seWFyZ3Nbdl0uYXJnLFNrLmFzdG5vZGVzLlBhcmFtKSk7QyYmQi5wdXNoKHRoaXMubmFtZW9wKG4udmFyYXJnLmFyZyxTay5hc3Rub2Rlcy5QYXJhbSkpfWxldCBGPSFOO0EmJihGfHxCLnB1c2goXCIkZnJlZVwiKSx0aGlzLnUudGVtcHNUb1NhdmUucHVzaChcIiRmcmVlXCIpKTt0aGlzLnUucHJlZml4Q29kZT1GP3RoaXMudS5wcmVmaXhDb2RlK1wiJHBvc2FyZ3MsJGt3YXJnc1wiOnRoaXMudS5wcmVmaXhDb2RlK0Iuam9pbihcIixcIik7dGhpcy51LnByZWZpeENvZGUrPVwiKXtcIjtOJiYodGhpcy51LnByZWZpeENvZGUrPVwiXFxuLy8gZ2VuZXJhdG9yXFxuXCIpO1xuQSYmKHRoaXMudS5wcmVmaXhDb2RlKz1cIlxcbi8vIGhhcyBmcmVlXFxuXCIpO0gmJih0aGlzLnUucHJlZml4Q29kZSs9XCJcXG4vLyBoYXMgY2VsbFxcblwiKTtGJiYodGhpcy51LnByZWZpeENvZGUrPVwiXFxuLy8gZmFzdCBjYWxsXFxuXCIpO3ZhciBKPVwie31cIjtOJiYoeD1cIiRnZW4uZ2kkcmVzdW1lYXRcIixKPVwiJGdlbi5naSRsb2NhbHNcIik7dj1cIiwkY2VsbD17fVwiO0gmJk4mJih2PVwiLCRjZWxsPSRnZW4uZ2kkY2VsbHNcIik7dGhpcy51LnZhckRlY2xzQ29kZSs9XCJ2YXIgJGJsaz1cIit4K1wiLCRleGM9W10sJGxvYz1cIitKK3YrXCIsJGdibD1cIisoRj9cInRoaXMgJiYgdGhpcy5mdW5jX2dsb2JhbHNcIjpcInRoaXNcIikrKEYmJkE/XCIsJGZyZWU9dGhpcyAmJiB0aGlzLmZ1bmNfY2xvc3VyZVwiOlwiXCIpK1wiLCRlcnI9dW5kZWZpbmVkLCRyZXQ9dW5kZWZpbmVkLCRwb3N0ZmluYWxseT11bmRlZmluZWQsJGN1cnJMaW5lTm89dW5kZWZpbmVkLCRjdXJyQ29sTm89dW5kZWZpbmVkO1wiO251bGwhPT1Tay5leGVjTGltaXQmJih0aGlzLnUudmFyRGVjbHNDb2RlKz1cblwiaWYgKHR5cGVvZiBTay5leGVjU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7U2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKX1cIik7bnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kJiYodGhpcy51LnZhckRlY2xzQ29kZSs9XCJpZiAodHlwZW9mIFNrLmxhc3RZaWVsZCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5sYXN0WWllbGQgPSBEYXRlLm5vdygpfVwiKTt0aGlzLnUudmFyRGVjbHNDb2RlKz1cInZhciAkd2FraW5nPWZhbHNlOyBpZiAoXCIrTCtcIi4kd2FraW5nU3VzcGVuc2lvbiE9PXVuZGVmaW5lZCkgeyAkd2FrZUZyb21TdXNwZW5zaW9uKCk7ICR3YWtpbmc9dHJ1ZTsgfSBlbHNlIHtcIjtpZihGKXt0aGlzLnUudmFyRGVjbHNDb2RlPUR8fEN8fG4mJm4ua3dvbmx5YXJncyYmMCE9PW4ua3dvbmx5YXJncy5sZW5ndGg/dGhpcy51LnZhckRlY2xzQ29kZStcIlxcbnZhciAkYXJncyA9IHRoaXMuJHJlc29sdmVBcmdzKCRwb3NhcmdzLCRrd2FyZ3MpXFxuXCI6dGhpcy51LnZhckRlY2xzQ29kZStcbihcInZhciAkYXJncyA9ICgoISRrd2FyZ3MgfHwgJGt3YXJncy5sZW5ndGg9PT0wKSAmJiAkcG9zYXJncy5sZW5ndGg9PT1cIitCLmxlbmd0aCtcIikgPyAkcG9zYXJncyA6IHRoaXMuJHJlc29sdmVBcmdzKCRwb3NhcmdzLCRrd2FyZ3MpXCIpO3Y9RD8xOjA7Zm9yKHg9MDt4PEIubGVuZ3RoO3grKyl0aGlzLnUudmFyRGVjbHNDb2RlKz1cIixcIisoeD09PXY/XCIkc3VwID0gXCI6XCJcIikrQlt4XStcIj0kYXJnc1tcIit4K1wiXVwiO3RoaXMudS52YXJEZWNsc0NvZGUrPVwiO1xcblwifWlmKE4mJjA8dC5sZW5ndGgpZm9yKHg9bi5hcmdzLmxlbmd0aC10Lmxlbmd0aCx2PTA7djx0Lmxlbmd0aDsrK3YpQj10aGlzLm5hbWVvcChuLmFyZ3Nbdit4XS5hcmcsU2suYXN0bm9kZXMuUGFyYW0pLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiaWYoXCIrQitcIj09PXVuZGVmaW5lZClcIitCK1wiPVwiK0wrXCIuJGRlZmF1bHRzW1wiK3YrXCJdO1wiO2Zvcih2PTA7biYmdjxuLmFyZ3MubGVuZ3RoOysrdilCPW4uYXJnc1t2XS5hcmcsdGhpcy5pc0NlbGwoQikmJlxuKEI9ZShnKHRoaXMudS5wcml2YXRlXyxCKS52KSx0aGlzLnUudmFyRGVjbHNDb2RlKz1cIiRjZWxsLlwiK0IrXCI9XCIrQitcIjtcIik7Zm9yKHY9MDtuJiZuLmt3b25seWFyZ3MmJnY8bi5rd29ubHlhcmdzLmxlbmd0aDsrK3YpQj1uLmt3b25seWFyZ3Nbdl0uYXJnLHRoaXMuaXNDZWxsKEIpJiYoQj1lKGcodGhpcy51LnByaXZhdGVfLEIpLnYpLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGNlbGwuXCIrQitcIj1cIitCK1wiO1wiKTtDJiZ0aGlzLmlzQ2VsbChDLmFyZykmJih2PWUoZyh0aGlzLnUucHJpdmF0ZV8sQy5hcmcpLnYpLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGNlbGwuXCIrditcIj1cIit2K1wiO1wiKTtEJiYodGhpcy51LmxvY2FsbmFtZXMucHVzaChELmFyZy52KSx0aGlzLnUudmFyRGVjbHNDb2RlKz1ELmFyZy52K1wiPW5ldyBTay5idWlsdGluc1snZGljdCddKCRrd2EpO1wiLHRoaXMuaXNDZWxsKEQuYXJnKSYmKHY9ZShnKHRoaXMudS5wcml2YXRlXyxELmFyZykudiksdGhpcy51LnZhckRlY2xzQ29kZSs9XG5cIiRjZWxsLlwiK3YrXCI9XCIrditcIjtcIikpO3RoaXMudS52YXJEZWNsc0NvZGUrPVwifVwiO1NrLl9fZnV0dXJlX18ucHl0aG9uMyYmbCYmKHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGdibC5fX2NsYXNzX189JGdibC5cIitsLnYrXCI7XCIpO3RoaXMudS5zd2l0Y2hDb2RlPVwid2hpbGUodHJ1ZSl7dHJ5e1wiO3RoaXMudS5zd2l0Y2hDb2RlKz10aGlzLm91dHB1dEludGVycnVwdFRlc3QoKTt0aGlzLnUuc3dpdGNoQ29kZSs9XCJzd2l0Y2goJGJsayl7XCI7dGhpcy51LnN1ZmZpeENvZGU9XCJ9IH1jYXRjaChlcnIpeyBpZiAoIShlcnIgaW5zdGFuY2VvZiBTay5idWlsdGluLkJhc2VFeGNlcHRpb24pKSB7IGVyciA9IG5ldyBTay5idWlsdGluLkV4dGVybmFsRXJyb3IoZXJyKTsgfSBlcnIudHJhY2ViYWNrLnB1c2goe2xpbmVubzogJGN1cnJMaW5lTm8sIGNvbG5vOiAkY3VyckNvbE5vLCBmaWxlbmFtZTogJ1wiK3RoaXMuZmlsZW5hbWUrXCInfSk7IGlmICgkZXhjLmxlbmd0aD4wKSB7ICRlcnIgPSBlcnI7ICRibGs9JGV4Yy5wb3AoKTsgY29udGludWU7IH0gZWxzZSB7IHRocm93IGVycjsgfX0gfX0pO1wiO1xuZC5jYWxsKHRoaXMsTCk7aWYobil7Zm9yKGxldCBQIG9mIG4uYXJncylyLnB1c2goUC5hcmcudik7Zm9yKGxldCBQIG9mIG4ua3dvbmx5YXJnc3x8W10pci5wdXNoKFAuYXJnLnYpO3RoaXMudS5hcmduYW1lcz1yfXRoaXMuZXhpdFNjb3BlKCk7MDx0Lmxlbmd0aCYmayhMLFwiLiRkZWZhdWx0cz1bXCIsdC5qb2luKFwiLFwiKSxcIl07XCIpO24mJm4ua3dvbmx5YXJncyYmMDxuLmt3b25seWFyZ3MubGVuZ3RoJiYoayhMLFwiLmNvX2FyZ2NvdW50PVwiLG4uYXJncy5sZW5ndGgsXCI7XCIpLGsoTCxcIi5jb19rd29ubHlhcmdjb3VudD1cIixuLmt3b25seWFyZ3MubGVuZ3RoLFwiO1wiKSxrKEwsXCIuJGt3ZGVmcz1bXCIsdy5qb2luKFwiLFwiKSxcIl07XCIpKTswPHIubGVuZ3RoP2soTCxcIi5jb192YXJuYW1lcz1bJ1wiLHIuam9pbihcIicsJ1wiKSxcIiddO1wiKTprKEwsXCIuY29fdmFybmFtZXM9W107XCIpO2soTCxcIi5jb19kb2NzdHJpbmc9XCIsdGhpcy5jRG9jc3RyaW5nT2ZDb2RlKGEpLFwiO1wiKTtEJiZrKEwsXCIuY29fa3dhcmdzPTE7XCIpO1xuQyYmayhMLFwiLmNvX3ZhcmFyZ3M9MTtcIik7Tnx8ayhMLFwiLmNvX2Zhc3RjYWxsPTE7XCIpO2E9XCJcIjtBJiYoYT1cIiwkY2VsbFwiLChkPXRoaXMudS5zdGUuaGFzRnJlZSkmJihhKz1cIiwkZnJlZVwiKSk7aWYoTilyZXR1cm4gbiYmMDxuLmFyZ3MubGVuZ3RoP3RoaXMuX2dyKFwiZ2VuZXJcIixcIm5ldyBTay5idWlsdGluc1snZnVuY3Rpb24nXSgoZnVuY3Rpb24oKXt2YXIgJG9yaWdhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiXCIsYy52LCdcIixhcmd1bWVudHMubGVuZ3RoLCcsbi5hcmdzLmxlbmd0aC10Lmxlbmd0aCxcIixcIixuLmFyZ3MubGVuZ3RoLFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW5zWydnZW5lcmF0b3InXShcIixMLFwiLCRnYmwsJG9yaWdhcmdzXCIsYSxcIik7fSkpXCIpOnRoaXMuX2dyKFwiZ2VuZXJcIixcIm5ldyBTay5idWlsdGluc1snZnVuY3Rpb24nXSgoZnVuY3Rpb24oKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJcIixcbmMudixcIlxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApO3JldHVybiBuZXcgU2suYnVpbHRpbnNbJ2dlbmVyYXRvciddKFwiLEwsXCIsJGdibCxbXVwiLGEsXCIpO30pKVwiKTtpZigwPHEubGVuZ3RoKXtrKFwiJHJldCA9IG5ldyBTay5idWlsdGluc1snZnVuY3Rpb24nXShcIixMLFwiLCRnYmxcIixhLFwiKTtcIik7Zm9yKGxldCBQIG9mIHEucmV2ZXJzZSgpKWsoXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KFwiLFAsXCIsWyRyZXRdKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCk7Yz10aGlzLl9ncihcImZ1bmNvYmpcIixcIiRyZXRcIil9ZWxzZSBjPXRoaXMuX2dyKFwiZnVuY29ialwiLFwibmV3IFNrLmJ1aWx0aW5zWydmdW5jdGlvbiddKFwiLEwsXCIsJGdibFwiLGEsXCIpXCIpO20mJmsoYyxcIi5mdW5jX2Fubm90YXRpb25zPVwiLG0sXCI7XCIpO3JldHVybiBjfTtiLnByb3RvdHlwZS5jYXJnYW5ub3RhdGlvbj1mdW5jdGlvbihhLGMsbSl7YyYmKGE9Zyh0aGlzLnUucHJpdmF0ZV8sYSkudixtLnB1c2goYCcke2F9J2ApLFxubS5wdXNoKHRoaXMudmV4cHIoYykpKX07Yi5wcm90b3R5cGUuY2FyZ2Fubm90YXRpb25zPWZ1bmN0aW9uKGEsYyl7aWYoYSlmb3IobGV0IG09MDttPGEubGVuZ3RoO20rKyl7Y29uc3Qgbj1hW21dO3RoaXMuY2FyZ2Fubm90YXRpb24obi5hcmcsbi5hbm5vdGF0aW9uLGMpfX07Y29uc3QgaD1uZXcgU2suYnVpbHRpbi5zdHIoXCJyZXR1cm5cIik7Yi5wcm90b3R5cGUuY2Fubm90YXRpb25zPWZ1bmN0aW9uKGEsYyl7Y29uc3QgbT1bXTthJiYodGhpcy5jYXJnYW5ub3RhdGlvbnMoYS5wb3Nvbmx5YXJncyxtKSx0aGlzLmNhcmdhbm5vdGF0aW9ucyhhLmFyZ3MsbSksYS52YXJhcmcmJmEudmFyYXJnLmFubm90YXRpb24mJnRoaXMuY2FyZ2Fubm90YXRpb24oYS52YXJhcmcuYXJnLGEudmFyYXJnLmFubm90YXRpb24sbSksdGhpcy5jYXJnYW5ub3RhdGlvbnMoYS5rd29ubHlhcmdzLG0pLGEua3dhcmcmJmEua3dhcmcuYW5ub3RhdGlvbiYmdGhpcy5jYXJnYW5ub3RhdGlvbihhLmt3YXJnLmFyZyxcbmEua3dhcmcuYW5ub3RhdGlvbixtKSk7YyYmdGhpcy5jYXJnYW5ub3RhdGlvbihoLGMsbSk7aWYoMCE9PW0ubGVuZ3RoKXJldHVyblwiW1wiK20uam9pbihcIixcIikrXCJdXCJ9O2IucHJvdG90eXBlLm1heWJlQ0RvY3N0cmluZ09mQm9keT1mdW5jdGlvbihhKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuIG51bGw7YT1hWzBdO2lmKGEuY29uc3RydWN0b3IhPT1Tay5hc3Rub2Rlcy5FeHByKXJldHVybiBudWxsO2E9YS52YWx1ZTtyZXR1cm4gYS5jb25zdHJ1Y3RvciE9PVNrLmFzdG5vZGVzLlN0cj9udWxsOnRoaXMudmV4cHIoYSl9O2IucHJvdG90eXBlLmNEb2NzdHJpbmdPZkNvZGU9ZnVuY3Rpb24oYSl7c3dpdGNoKGEuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuQXN5bmNGdW5jdGlvbkRlZjpjYXNlIFNrLmFzdG5vZGVzLkZ1bmN0aW9uRGVmOnJldHVybiB0aGlzLm1heWJlQ0RvY3N0cmluZ09mQm9keShhLmJvZHkpfHxcIlNrLmJ1aWx0aW4ubm9uZS5ub25lJFwiO2Nhc2UgU2suYXN0bm9kZXMuTGFtYmRhOmNhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnJldHVyblwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7XG5kZWZhdWx0OlNrLmFzc2VydHMuZmFpbChgdW5leHBlY3RlZCBub2RlIGtpbmQgJHthLmNvbnN0cnVjdG9yLm5hbWV9YCl9fTtiLnByb3RvdHlwZS5jZnVuY3Rpb249ZnVuY3Rpb24oYSxjKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuRnVuY3Rpb25EZWYpO2M9dGhpcy5idWlsZGNvZGVvYmooYSxhLm5hbWUsYS5kZWNvcmF0b3JfbGlzdCxhLmFyZ3MsZnVuY3Rpb24obSl7dGhpcy52c2Vxc3RtdChhLmJvZHkpO2soXCJyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1wiKX0sYyk7dGhpcy5uYW1lb3AoYS5uYW1lLFNrLmFzdG5vZGVzLlN0b3JlLGMpfTtiLnByb3RvdHlwZS5jbGFtYmRhPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5MYW1iZGEpO3JldHVybiB0aGlzLmJ1aWxkY29kZW9iaihhLG5ldyBTay5idWlsdGluLnN0cihcIjxsYW1iZGE+XCIpLG51bGwsYS5hcmdzLGZ1bmN0aW9uKGMpe2M9dGhpcy52ZXhwcihhLmJvZHkpO1xuayhcInJldHVybiBcIixjLFwiO1wiKX0pfTtiLnByb3RvdHlwZS5jaWZleHA9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5uZXdCbG9jayhcIm5leHQgb2YgaWZleHBcIiksbT10aGlzLm5ld0Jsb2NrKFwiZW5kIG9mIGlmZXhwXCIpLG49dGhpcy5fZ3IoXCJyZXNcIixcIm51bGxcIiksZD10aGlzLnZleHByKGEudGVzdCk7dGhpcy5fanVtcGZhbHNlKGQsYyk7ayhuLFwiPVwiLHRoaXMudmV4cHIoYS5ib2R5KSxcIjtcIik7dGhpcy5fanVtcChtKTt0aGlzLnNldEJsb2NrKGMpO2sobixcIj1cIix0aGlzLnZleHByKGEub3JlbHNlKSxcIjtcIik7dGhpcy5fanVtcChtKTt0aGlzLnNldEJsb2NrKG0pO3JldHVybiBufTtiLnByb3RvdHlwZS5jZ2VuZXhwZ2VuPWZ1bmN0aW9uKGEsYyxtKXt2YXIgbj10aGlzLm5ld0Jsb2NrKFwic3RhcnQgZm9yIFwiK2MpLGQ9dGhpcy5uZXdCbG9jayhcInNraXAgZm9yIFwiK2MpO3RoaXMubmV3QmxvY2soXCJpZiBjbGVhbnVwIGZvciBcIitjKTt2YXIgbD10aGlzLm5ld0Jsb2NrKFwiZW5kIGZvciBcIitjKSxcbnI9YVtjXTtpZigwPT09Yyl2YXIgdj1cIiRsb2MuJGl0ZXIwXCI7ZWxzZXt2YXIgcT10aGlzLnZleHByKHIuaXRlcik7dj1cIiRsb2MuXCIrdGhpcy5nZW5zeW0oXCJpdGVyXCIpO2sodixcIj1cIixcIlNrLmFic3RyLml0ZXIoXCIscSxcIik7XCIpfXRoaXMuX2p1bXAobik7dGhpcy5zZXRCbG9jayhuKTt0aGlzLmFubm90YXRlU291cmNlKG0pO2soXCIkcmV0ID0gU2suYWJzdHIuaXRlcm5leHQoXCIsdix0aGlzLnUuY2FuU3VzcGVuZD9cIiwgdHJ1ZVwiOlwiLCBmYWxzZVwiLFwiKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKG0pO3E9dGhpcy5fZ3IoXCJuZXh0XCIsXCIkcmV0XCIpO3RoaXMuX2p1bXB1bmRlZihxLGwpO3RoaXMudmV4cHIoci50YXJnZXQscSk7dmFyIHQ9ci5pZnM/ci5pZnMubGVuZ3RoOjA7Zm9yKHY9MDt2PHQ7Kyt2KXRoaXMuYW5ub3RhdGVTb3VyY2Uoci5pZnNbdl0pLHE9dGhpcy52ZXhwcihyLmlmc1t2XSksdGhpcy5fanVtcGZhbHNlKHEsbik7KytjPGEubGVuZ3RoJiZ0aGlzLmNnZW5leHBnZW4oYSxcbmMsbSk7Yz49YS5sZW5ndGgmJih0aGlzLmFubm90YXRlU291cmNlKG0pLGE9dGhpcy52ZXhwcihtKSxrKFwicmV0dXJuIFtcIixkLFwiLypyZXN1bWUqLyxcIixhLFwiLypyZXQqL107XCIpLHRoaXMuc2V0QmxvY2soZCkpO3RoaXMuX2p1bXAobik7dGhpcy5zZXRCbG9jayhsKTsxPT09YyYmayhcInJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XCIpfTtiLnByb3RvdHlwZS5jZ2VuZXhwPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuYnVpbGRjb2Rlb2JqKGEsbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGdlbmV4cHI+XCIpLG51bGwsbnVsbCxmdW5jdGlvbihtKXt0aGlzLmNnZW5leHBnZW4oYS5nZW5lcmF0b3JzLDAsYS5lbHQpfSk7Yz10aGlzLl9ncihcImdlbmVyXCIsXCJTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoXCIsYyxcIik7XCIpO2soYyxcIi5naSRsb2NhbHMuJGl0ZXIwPVNrLmFic3RyLml0ZXIoXCIsdGhpcy52ZXhwcihhLmdlbmVyYXRvcnNbMF0uaXRlciksXCIpO1wiKTtyZXR1cm4gY307Yi5wcm90b3R5cGUuY2NsYXNzPVxuZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkNsYXNzRGVmKTt2YXIgYz10aGlzLnZzZXFleHByKGEuZGVjb3JhdG9yX2xpc3QpO3ZhciBtPXRoaXMudnNlcWV4cHIoYS5iYXNlcyk7bGV0IG49dGhpcy5jdW5wYWNra3dzdG9hcnJheShhLmtleXdvcmRzKTt2YXIgZD10aGlzLmVudGVyU2NvcGUoYS5uYW1lLGEsYS5saW5lbm8pO3ZhciBsPXRoaXMubmV3QmxvY2soXCJjbGFzcyBlbnRyeVwiKTt0aGlzLnUucHJlZml4Q29kZT1cInZhciBcIitkK1wiPShmdW5jdGlvbiAkXCIrYS5uYW1lLnYrXCIkY2xhc3Nfb3V0ZXIoJGdsb2JhbHMsJGxvY2FscywkY2VsbCl7dmFyICRnYmw9JGdsb2JhbHMsJGxvYz0kbG9jYWxzLCRmcmVlPSRnbG9iYWxzO1wiO3RoaXMudS5zd2l0Y2hDb2RlKz1cIihmdW5jdGlvbiAkXCIrYS5uYW1lLnYrXCIkX2Nsb3N1cmUoJGNlbGwpe1wiO3RoaXMudS5zd2l0Y2hDb2RlKz1cInZhciAkYmxrPVwiK2wrXCIsJGV4Yz1bXSwkcmV0PXVuZGVmaW5lZCwkcG9zdGZpbmFsbHk9dW5kZWZpbmVkLCRjdXJyTGluZU5vPXVuZGVmaW5lZCwkY3VyckNvbE5vPXVuZGVmaW5lZDtcIjtcbm51bGwhPT1Tay5leGVjTGltaXQmJih0aGlzLnUuc3dpdGNoQ29kZSs9XCJpZiAodHlwZW9mIFNrLmV4ZWNTdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5leGVjU3RhcnQgPSBEYXRlLm5vdygpfVwiKTtudWxsIT09U2sueWllbGRMaW1pdCYmdGhpcy51LmNhblN1c3BlbmQmJih0aGlzLnUuc3dpdGNoQ29kZSs9XCJpZiAodHlwZW9mIFNrLmxhc3RZaWVsZCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5sYXN0WWllbGQgPSBEYXRlLm5vdygpfVwiKTt0aGlzLnUuc3dpdGNoQ29kZSs9XCJ3aGlsZSh0cnVlKXt0cnl7XCI7dGhpcy51LnN3aXRjaENvZGUrPXRoaXMub3V0cHV0SW50ZXJydXB0VGVzdCgpO3RoaXMudS5zd2l0Y2hDb2RlKz1cInN3aXRjaCgkYmxrKXtcIjt0aGlzLnUuc3VmZml4Q29kZT1cIn19Y2F0Y2goZXJyKXsgaWYgKCEoZXJyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uKSkgeyBlcnIgPSBuZXcgU2suYnVpbHRpbi5FeHRlcm5hbEVycm9yKGVycik7IH0gZXJyLnRyYWNlYmFjay5wdXNoKHtsaW5lbm86ICRjdXJyTGluZU5vLCBjb2xubzogJGN1cnJDb2xObywgZmlsZW5hbWU6ICdcIitcbnRoaXMuZmlsZW5hbWUrXCInfSk7IGlmICgkZXhjLmxlbmd0aD4wKSB7ICRlcnIgPSBlcnI7ICRibGs9JGV4Yy5wb3AoKTsgY29udGludWU7IH0gZWxzZSB7IHRocm93IGVycjsgfX19XCI7dGhpcy51LnN1ZmZpeENvZGUrPVwifSkuY2FsbChudWxsLCAkY2VsbCk7fSk7XCI7dGhpcy51LnByaXZhdGVfPWEubmFtZTt0aGlzLmNib2R5KGEuYm9keSxhLm5hbWUpO2soXCJyZXR1cm47XCIpO3RoaXMuZXhpdFNjb3BlKCk7ayhcIiRyZXQgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKCRnYmwsXCIsZCxcIixcIixhLm5hbWUuJHIoKS52LFwiLFtcIixtLFwiXSwgJGNlbGwsIFwiLG4sXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oKTtmb3IobGV0IHIgb2YgYy5yZXZlcnNlKCkpayhcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoXCIscixcIiwgWyRyZXRdKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCk7dGhpcy5uYW1lb3AoYS5uYW1lLFNrLmFzdG5vZGVzLlN0b3JlLFwiJHJldFwiKX07Yi5wcm90b3R5cGUuY2NvbnRpbnVlPVxuZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5wZWVrRmluYWxseUJsb2NrKCk7aWYoMD09dGhpcy51LmNvbnRpbnVlQmxvY2tzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIidjb250aW51ZScgb3V0c2lkZSBsb29wXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7YT10aGlzLnUuY29udGludWVCbG9ja3NbdGhpcy51LmNvbnRpbnVlQmxvY2tzLmxlbmd0aC0xXTtTay5hc3NlcnRzLmFzc2VydCh0aGlzLnUuYnJlYWtCbG9ja3MubGVuZ3RoPT09dGhpcy51LmNvbnRpbnVlQmxvY2tzLmxlbmd0aCk7YyYmYy5icmVha0RlcHRoPT10aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoP2soXCIkcG9zdGZpbmFsbHk9e2lzQnJlYWs6dHJ1ZSxnb3RvQmxvY2s6XCIsYSxcIn07XCIpOnRoaXMuX2p1bXAoYSl9O2IucHJvdG90eXBlLmNicmVhaz1mdW5jdGlvbihhKXt2YXIgYz10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTtpZigwPT09dGhpcy51LmJyZWFrQmxvY2tzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIidicmVhaycgb3V0c2lkZSBsb29wXCIsXG50aGlzLmZpbGVuYW1lLGEubGluZW5vKTthPXRoaXMudS5icmVha0Jsb2Nrc1t0aGlzLnUuYnJlYWtCbG9ja3MubGVuZ3RoLTFdO2MmJmMuYnJlYWtEZXB0aD09dGhpcy51LmJyZWFrQmxvY2tzLmxlbmd0aD9rKFwiJHBvc3RmaW5hbGx5PXtpc0JyZWFrOnRydWUsZ290b0Jsb2NrOlwiLGEsXCJ9O1wiKTp0aGlzLl9qdW1wKGEpfTtiLnByb3RvdHlwZS52c3RtdD1mdW5jdGlvbihhLGMpe3RoaXMudS5saW5lbm89YS5saW5lbm87dGhpcy51LmxpbmVub1NldD0hMTt0aGlzLnUubG9jYWx0ZW1wcz1bXTtpZihTay5kZWJ1Z2dpbmcmJnRoaXMudS5jYW5TdXNwZW5kKXt2YXIgbT10aGlzLm5ld0Jsb2NrKFwiZGVidWcgYnJlYWtwb2ludCBmb3IgbGluZSBcIithLmxpbmVubyk7ayhcImlmIChTay5icmVha3BvaW50cygnXCIrdGhpcy5maWxlbmFtZStcIicsXCIrYS5saW5lbm8rXCIsXCIrYS5jb2xfb2Zmc2V0K1wiKSkge1wiLFwidmFyICRzdXNwID0gJHNhdmVTdXNwZW5zaW9uKHtkYXRhOiB7dHlwZTogJ1NrLmRlYnVnJ30sIHJlc3VtZTogZnVuY3Rpb24oKSB7fX0sICdcIitcbnRoaXMuZmlsZW5hbWUrXCInLFwiK2EubGluZW5vK1wiLFwiK2EuY29sX29mZnNldCtcIik7XCIsXCIkc3VzcC4kYmxrID0gXCIrbStcIjtcIixcIiRzdXNwLm9wdGlvbmFsID0gdHJ1ZTtcIixcInJldHVybiAkc3VzcDtcIixcIn1cIik7dGhpcy5fanVtcChtKTt0aGlzLnNldEJsb2NrKG0pO3RoaXMudS5kb2VzU3VzcGVuZD0hMH10aGlzLmFubm90YXRlU291cmNlKGEpO3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLkZ1bmN0aW9uRGVmOnRoaXMuY2Z1bmN0aW9uKGEsYyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5DbGFzc0RlZjp0aGlzLmNjbGFzcyhhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlJldHVybjppZih0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jayl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIidyZXR1cm4nIG91dHNpZGUgZnVuY3Rpb25cIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTttPWEudmFsdWU/dGhpcy52ZXhwcihhLnZhbHVlKTpcblwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7MD09dGhpcy51LmZpbmFsbHlCbG9ja3MubGVuZ3RoP2soXCJyZXR1cm4gXCIsbSxcIjtcIik6KGsoXCIkcG9zdGZpbmFsbHk9e3JldHVybmluZzpcIixtLFwifTtcIiksdGhpcy5fanVtcCh0aGlzLnBlZWtGaW5hbGx5QmxvY2soKS5ibGspKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbGV0ZTp0aGlzLnZzZXFleHByKGEudGFyZ2V0cyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Bc3NpZ246dmFyIG49YS50YXJnZXRzLmxlbmd0aDttPXRoaXMudmV4cHIoYS52YWx1ZSk7Zm9yKGM9MDtjPG47KytjKXRoaXMudmV4cHIoYS50YXJnZXRzW2NdLG0pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQW5uQXNzaWduOnJldHVybiB0aGlzLmNhbm5hc3NpZ24oYSk7Y2FzZSBTay5hc3Rub2Rlcy5BdWdBc3NpZ246cmV0dXJuIHRoaXMuY2F1Z2Fzc2lnbihhKTtjYXNlIFNrLmFzdG5vZGVzLlByaW50OnRoaXMuY3ByaW50KGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRm9yOnJldHVybiB0aGlzLmNmb3IoYSk7XG5jYXNlIFNrLmFzdG5vZGVzLldoaWxlOnJldHVybiB0aGlzLmN3aGlsZShhKTtjYXNlIFNrLmFzdG5vZGVzLklmOnJldHVybiB0aGlzLmNpZihhKTtjYXNlIFNrLmFzdG5vZGVzLlJhaXNlOnJldHVybiB0aGlzLmNyYWlzZShhKTtjYXNlIFNrLmFzdG5vZGVzLlRyeTpyZXR1cm4gdGhpcy5jdHJ5KGEpO2Nhc2UgU2suYXN0bm9kZXMuV2l0aDpyZXR1cm4gdGhpcy5jd2l0aChhLDApO2Nhc2UgU2suYXN0bm9kZXMuQXNzZXJ0OnJldHVybiB0aGlzLmNhc3NlcnQoYSk7Y2FzZSBTay5hc3Rub2Rlcy5JbXBvcnQ6cmV0dXJuIHRoaXMuY2ltcG9ydChhKTtjYXNlIFNrLmFzdG5vZGVzLkltcG9ydEZyb206cmV0dXJuIHRoaXMuY2Zyb21pbXBvcnQoYSk7Y2FzZSBTay5hc3Rub2Rlcy5HbG9iYWw6YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5FeHByOnRoaXMudmV4cHIoYS52YWx1ZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5QYXNzOmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQnJlYWs6dGhpcy5jYnJlYWsoYSk7XG5icmVhaztjYXNlIFNrLmFzdG5vZGVzLkNvbnRpbnVlOnRoaXMuY2NvbnRpbnVlKGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGVidWdnZXI6ayhcImRlYnVnZ2VyO1wiKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlIGluIHZzdG10OiBcIitKU09OLnN0cmluZ2lmeShhKSl9fTtiLnByb3RvdHlwZS52c2Vxc3RtdD1mdW5jdGlvbihhKXt2YXIgYztmb3IoYz0wO2M8YS5sZW5ndGg7KytjKXRoaXMudnN0bXQoYVtjXSl9O2IucHJvdG90eXBlLmlzQ2VsbD1mdW5jdGlvbihhKXthPWUoZyh0aGlzLnUucHJpdmF0ZV8sYSkudik7cmV0dXJuIHRoaXMudS5zdGUuZ2V0U2NvcGUoYSk9PT1Tay5TWU1UQUJfQ09OU1RTLkNFTEx9O2IucHJvdG90eXBlLm5hbWVvcD1mdW5jdGlvbihhLGMsbSl7aWYoKGM9PT1Tay5hc3Rub2Rlcy5TdG9yZXx8Yz09PVNrLmFzdG5vZGVzLkF1Z1N0b3JlfHxjPT09U2suYXN0bm9kZXMuRGVsKSYmXCJfX2RlYnVnX19cIj09PWEudil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImNhbiBub3QgYXNzaWduIHRvIF9fZGVidWdfX1wiLFxudGhpcy5maWxlbmFtZSx0aGlzLnUubGluZW5vKTtTay5hc3NlcnRzLmFzc2VydChcIk5vbmVcIiE9PWEudik7aWYoXCJOb3RJbXBsZW1lbnRlZFwiPT09YS52KXJldHVyblwiU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCRcIjt2YXIgbj1nKHRoaXMudS5wcml2YXRlXyxhKS52O249ZShuKTt2YXIgZD0zO3ZhciBsPXRoaXMudS5zdGUuZ2V0U2NvcGUobik7dmFyIHI9bnVsbDtzd2l0Y2gobCl7Y2FzZSBTay5TWU1UQUJfQ09OU1RTLkZSRUU6cj1cIiRmcmVlXCI7ZD0yO2JyZWFrO2Nhc2UgU2suU1lNVEFCX0NPTlNUUy5DRUxMOnI9XCIkY2VsbFwiO2Q9MjticmVhaztjYXNlIFNrLlNZTVRBQl9DT05TVFMuTE9DQUw6dGhpcy51LnN0ZS5ibG9ja1R5cGUhPT1Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2t8fHRoaXMudS5zdGUuZ2VuZXJhdG9yfHwoZD0wKTticmVhaztjYXNlIFNrLlNZTVRBQl9DT05TVFMuR0xPQkFMX0lNUExJQ0lUOnRoaXMudS5zdGUuYmxvY2tUeXBlPT09XG5Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2smJihkPTEpO2JyZWFrO2Nhc2UgU2suU1lNVEFCX0NPTlNUUy5HTE9CQUxfRVhQTElDSVQ6ZD0xfVNrLmFzc2VydHMuYXNzZXJ0KGx8fFwiX1wiPT09YS52LmNoYXJBdCgxKSk7YT1uO3RoaXMudS5zdGUuZ2VuZXJhdG9yfHx0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jaz9uPVwiJGxvYy5cIituOigwPT09ZHx8Mz09PWQpJiZ0aGlzLnUubG9jYWxuYW1lcy5wdXNoKG4pO3N3aXRjaChkKXtjYXNlIDA6c3dpdGNoKGMpe2Nhc2UgU2suYXN0bm9kZXMuTG9hZDpjYXNlIFNrLmFzdG5vZGVzLlBhcmFtOnJldHVybiBrKFwiaWYgKFwiLG4sXCIgPT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgU2suYnVpbHRpbi5VbmJvdW5kTG9jYWxFcnJvcignbG9jYWwgdmFyaWFibGUgXFxcXCdcIixuLFwiXFxcXCcgcmVmZXJlbmNlZCBiZWZvcmUgYXNzaWdubWVudCcpOyB9XFxuXCIpLG47Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTprKG4sXG5cIj1cIixtLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbDprKFwiZGVsZXRlIFwiLG4sXCI7XCIpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkXCIpfWJyZWFrO2Nhc2UgMzpzd2l0Y2goYyl7Y2FzZSBTay5hc3Rub2Rlcy5Mb2FkOnJldHVybiB0aGlzLl9ncihcImxvYWRuYW1lXCIsbixcIiE9PXVuZGVmaW5lZD9cIixuLFwiOlNrLm1pc2NldmFsLmxvYWRuYW1lKCdcIixhLFwiJywkZ2JsKTtcIik7Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTprKG4sXCI9XCIsbSxcIjtcIik7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EZWw6ayhcImRlbGV0ZSBcIixuLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlBhcmFtOnJldHVybiBuO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkXCIpfWJyZWFrO2Nhc2UgMTpzd2l0Y2goYyl7Y2FzZSBTay5hc3Rub2Rlcy5Mb2FkOnJldHVybiB0aGlzLl9ncihcImxvYWRnYmxcIixcIlNrLm1pc2NldmFsLmxvYWRuYW1lKCdcIixhLFwiJywkZ2JsKVwiKTtjYXNlIFNrLmFzdG5vZGVzLlN0b3JlOmsoXCIkZ2JsLlwiLFxuYSxcIj1cIixtLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbDprKFwiZGVsZXRlICRnYmwuXCIsYSk7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgY2FzZSBpbiBuYW1lIG9wX2dsb2JhbFwiKX1icmVhaztjYXNlIDI6c3dpdGNoKGMpe2Nhc2UgU2suYXN0bm9kZXMuTG9hZDpyZXR1cm4gcitcIi5cIithO2Nhc2UgU2suYXN0bm9kZXMuU3RvcmU6ayhyLFwiLlwiLGEsXCI9XCIsbSxcIjtcIik7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5QYXJhbTpyZXR1cm4gYTtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlIGluIG5hbWUgb3BfZGVyZWZcIil9YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgY2FzZVwiKX19O2IucHJvdG90eXBlLmVudGVyU2NvcGU9ZnVuY3Rpb24oYSxjLG0sbil7dmFyIGQ9bmV3IGY7ZC5zdGU9dGhpcy5zdC5nZXRTdHNGb3JBc3QoYyk7ZC5uYW1lPWE7ZC5maXJzdGxpbmVubz1tO2QuY2FuU3VzcGVuZD1ufHxcbiExO3RoaXMudSYmdGhpcy51LnByaXZhdGVfJiYoZC5wcml2YXRlXz10aGlzLnUucHJpdmF0ZV8pO3RoaXMuc3RhY2sucHVzaCh0aGlzLnUpO3RoaXMuYWxsVW5pdHMucHVzaChkKTthPXRoaXMuZ2Vuc3ltKFwic2NvcGVcIik7ZC5zY29wZW5hbWU9YTt0aGlzLnU9ZDt0aGlzLnUuYWN0aXZhdGVTY29wZSgpO3RoaXMubmVzdGxldmVsKys7cmV0dXJuIGF9O2IucHJvdG90eXBlLmV4aXRTY29wZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMudTt0aGlzLm5lc3RsZXZlbC0tOyh0aGlzLnU9MDw9dGhpcy5zdGFjay5sZW5ndGgtMT90aGlzLnN0YWNrLnBvcCgpOm51bGwpJiZ0aGlzLnUuYWN0aXZhdGVTY29wZSgpO2lmKFwiPG1vZHVsZT5cIiE9PWEubmFtZS52KXt2YXIgYz1hLm5hbWUuJHIoKS52O2M9Yy5zdWJzdHJpbmcoMSxjLmxlbmd0aC0xKTtrKGEuc2NvcGVuYW1lLFwiLmNvX25hbWU9bmV3IFNrLmJ1aWx0aW5zWydzdHInXSgnXCIsYyxcIicpO1wiKTt0aGlzLnN0YWNrLmxlbmd0aCYmXCJjbGFzc1wiPT1cbnRoaXMudS5zdGUuYmxvY2tUeXBlJiZrKGEuc2NvcGVuYW1lLFwiLmNvX3F1YWxuYW1lPW5ldyBTay5idWlsdGluc1snc3RyJ10oJ1wiK3RoaXMudS5uYW1lLnYrXCIuXCIrYytcIicpO1wiKX1mb3IodmFyIG0gaW4gYS5jb25zdHMpYS5jb25zdHMuaGFzT3duUHJvcGVydHkobSkmJihhLnN1ZmZpeENvZGUrPW0rXCIgPSBcIithLmNvbnN0c1ttXStcIjtcIil9O2IucHJvdG90eXBlLmNib2R5PWZ1bmN0aW9uKGEsYyl7dmFyIG09MDtjb25zdCBuPXRoaXMubWF5YmVDRG9jc3RyaW5nT2ZCb2R5KGEpO251bGwhPT1uJiYoayhcIiRsb2MuX19kb2NfXyA9IFwiLG4sXCI7XCIpLG09MSk7Zm9yKDttPGEubGVuZ3RoOysrbSl0aGlzLnZzdG10KGFbbV0sYyk7dGhpcy51Lmhhc0Fubm90YXRpb25zJiYodGhpcy51LnZhckRlY2xzQ29kZSs9XCIkbG9jLl9fYW5ub3RhdGlvbnNfXyB8fCAoJGxvYy5fX2Fubm90YXRpb25zX18gPSBuZXcgU2suYnVpbHRpbi5kaWN0KCkpO1wiKX07Yi5wcm90b3R5cGUuY3ByaW50PWZ1bmN0aW9uKGEpe3ZhciBjO1xuU2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLlByaW50KTthLmRlc3QmJnRoaXMudmV4cHIoYS5kZXN0KTt2YXIgbT1hLnZhbHVlcy5sZW5ndGg7Zm9yKGM9MDtjPG07KytjKWsoXCIkcmV0ID0gU2subWlzY2V2YWwucHJpbnRfKFwiLFwibmV3IFNrLmJ1aWx0aW5zWydzdHInXShcIix0aGlzLnZleHByKGEudmFsdWVzW2NdKSxcIikudik7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTthLm5sJiYoayhcIiRyZXQgPSBTay5taXNjZXZhbC5wcmludF8oXCIsJ1wiXFxcXG5cIik7JyksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpKX07Yi5wcm90b3R5cGUuY21vZD1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmVudGVyU2NvcGUobmV3IFNrLmJ1aWx0aW4uc3RyKFwiPG1vZHVsZT5cIiksYSwwLHRoaXMuY2FuU3VzcGVuZCksbT10aGlzLm5ld0Jsb2NrKFwibW9kdWxlIGVudHJ5XCIpO3RoaXMudS5wcmVmaXhDb2RlPVwidmFyIFwiK2MrXCI9KGZ1bmN0aW9uKCRmb3JjZWdibCwgJGZvcmNlbG9jKXtcIjtcbnRoaXMudS52YXJEZWNsc0NvZGU9XCJ2YXIgJGdibCA9ICRmb3JjZWdibCB8fCB7fSwgJGJsaz1cIittK1wiLCRleGM9W10sJGxvYz0kZm9yY2Vsb2MgfHwgJGdibCwkY2VsbD17fSwkZXJyPXVuZGVmaW5lZDt2YXIgJHJldD11bmRlZmluZWQsJHBvc3RmaW5hbGx5PXVuZGVmaW5lZCwkY3VyckxpbmVObz11bmRlZmluZWQsJGN1cnJDb2xObz11bmRlZmluZWQ7XCI7bnVsbCE9PVNrLmV4ZWNMaW1pdCYmKHRoaXMudS52YXJEZWNsc0NvZGUrPVwiaWYgKHR5cGVvZiBTay5leGVjU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7U2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKX1cIik7bnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kJiYodGhpcy51LnZhckRlY2xzQ29kZSs9XCJpZiAodHlwZW9mIFNrLmxhc3RZaWVsZCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5sYXN0WWllbGQgPSBEYXRlLm5vdygpfVwiKTt0aGlzLnUudmFyRGVjbHNDb2RlKz1cInZhciAkd2FraW5nPWZhbHNlOyBpZiAoXCIrYytcblwiLiR3YWtpbmdTdXNwZW5zaW9uIT09dW5kZWZpbmVkKSB7ICR3YWtlRnJvbVN1c3BlbnNpb24oKTsgJHdha2luZz10cnVlOyB9aWYgKFNrLnJldGFpbkdsb2JhbHMpIHsgICAgaWYgKFNrLmdsb2JhbHMpIHsgJGdibCA9IFNrLmdsb2JhbHM7IFNrLmdsb2JhbHMgPSAkZ2JsOyAkbG9jID0gJGdibDsgfSAgICBlbHNlIHsgU2suZ2xvYmFscyA9ICRnYmw7IH19IGVsc2UgeyBTay5nbG9iYWxzID0gJGdibDsgfVwiO3RoaXMudS5zd2l0Y2hDb2RlPVwid2hpbGUodHJ1ZSl7dHJ5e1wiO3RoaXMudS5zd2l0Y2hDb2RlKz10aGlzLm91dHB1dEludGVycnVwdFRlc3QoKTt0aGlzLnUuc3dpdGNoQ29kZSs9XCJzd2l0Y2goJGJsayl7XCI7dGhpcy51LnN1ZmZpeENvZGU9XCJ9XCI7dGhpcy51LnN1ZmZpeENvZGUrPVwifWNhdGNoKGVycil7IGlmICghKGVyciBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikpIHsgZXJyID0gbmV3IFNrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvcihlcnIpOyB9IGVyci50cmFjZWJhY2sucHVzaCh7bGluZW5vOiAkY3VyckxpbmVObywgY29sbm86ICRjdXJyQ29sTm8sIGZpbGVuYW1lOiAnXCIrXG50aGlzLmZpbGVuYW1lK1wiJ30pOyBpZiAoJGV4Yy5sZW5ndGg+MCkgeyAkZXJyID0gZXJyOyAkYmxrPSRleGMucG9wKCk7IGNvbnRpbnVlOyB9IGVsc2UgeyB0aHJvdyBlcnI7IH19IH0gfSk7XCI7c3dpdGNoKGEuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuTW9kdWxlOnRoaXMuY2JvZHkoYS5ib2R5KTtrKFwicmV0dXJuICRsb2M7XCIpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidG9kbzsgdW5oYW5kbGVkIGNhc2UgaW4gY29tcGlsZXJNb2RcIil9dGhpcy5leGl0U2NvcGUoKTt0aGlzLnJlc3VsdC5wdXNoKHRoaXMub3V0cHV0QWxsVW5pdHMoKSk7cmV0dXJuIGN9O1NrLmNvbXBpbGU9ZnVuY3Rpb24oYSxjLG0sbil7bT1Tay5fX2Z1dHVyZV9fO1NrLl9fZnV0dXJlX189T2JqZWN0LmNyZWF0ZShTay5fX2Z1dHVyZV9fKTt2YXIgZD1Tay5wYXJzZShjLGEpLGw9U2suYXN0RnJvbVBhcnNlKGQuY3N0LGMsZC5mbGFncyk7ZD1kLmZsYWdzO3ZhciByPVNrLnN5bWJvbHRhYmxlKGwsXG5jKTthPW5ldyBiKGMscixkLG4sYSk7bj1hLmNtb2QobCk7U2suX19mdXR1cmVfXz1tO3JldHVybntmdW5jbmFtZTpcIiRjb21waWxlZG1vZFwiLGNvZGU6YHZhciAkY29tcGlsZWRtb2QgPSBmdW5jdGlvbigpIHske2EucmVzdWx0LmpvaW4oXCJcIil9XFxucmV0dXJuICR7bn07fSgpO1xcbiRjb21waWxlZG1vZDtgLGZpbGVuYW1lOmN9fTtTay5leHBvcnRTeW1ib2woXCJTay5jb21waWxlXCIsU2suY29tcGlsZSk7U2sucmVzZXRDb21waWxlcj1mdW5jdGlvbigpe1NrLmdlbnN5bWNvdW50PTB9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnJlc2V0Q29tcGlsZXJcIixTay5yZXNldENvbXBpbGVyKTtTay5maXhSZXNlcnZlZD1lO1NrLmV4cG9ydFN5bWJvbChcIlNrLmZpeFJlc2VydmVkXCIsU2suZml4UmVzZXJ2ZWQpO1NrLnVuZml4UmVzZXJ2ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvX1xcJHJ3XFwkJC8sXCJcIil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnVuZml4UmVzZXJ2ZWRcIixTay51bmZpeFJlc2VydmVkKTtcblNrLm1hbmdsZU5hbWU9ZztTay5leHBvcnRTeW1ib2woXCJTay5tYW5nbGVOYW1lXCIsU2subWFuZ2xlTmFtZSk7U2sucmVzZXJ2ZWRXb3Jkc189cDtTay5leHBvcnRTeW1ib2woXCJTay5yZXNlcnZlZFdvcmRzX1wiLFNrLnJlc2VydmVkV29yZHNfKX0sZnVuY3Rpb24oRSxRKXtTay5zeXNtb2R1bGVzPW5ldyBTay5idWlsdGluLmRpY3QoW10pO1NrLnJlYWxzeXNwYXRoPXZvaWQgMDtTay5pbXBvcnRTZWFyY2hQYXRoRm9yTmFtZT1mdW5jdGlvbihiLGYsZSl7dmFyIGc9Yi5yZXBsYWNlKC9cXC4vZyxcIi9cIiksaz1mdW5jdGlvbihwLGgpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC50cnlDYXRjaChmdW5jdGlvbigpe3JldHVybiBTay5yZWFkKHApfSxmdW5jdGlvbihhKXt9KSxmdW5jdGlvbihhKXtpZih2b2lkIDAhPT1hKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoe2ZpbGVuYW1lOnAsY29kZTphLHBhY2thZ2VQYXRoOmh9KX0pfTt2b2lkIDA9PT1lJiYoZT1Tay5yZWFsc3lzcGF0aCk7XG5yZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihlLnRwJGl0ZXIoKSxmdW5jdGlvbihwKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oayhwLnYrXCIvXCIrZytmLCExKSxmdW5jdGlvbihoKXtyZXR1cm4gaD9oOmsocC52K1wiL1wiK2crXCIvX19pbml0X19cIitmLHAuditcIi9cIitnKX0pfSl9O1NrLmltcG9ydFNldFVwUGF0aD1mdW5jdGlvbihiKXtpZighU2sucmVhbHN5c3BhdGgpe3ZhciBmPVtuZXcgU2suYnVpbHRpbi5zdHIoXCJzcmMvYnVpbHRpblwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXCJzcmMvbGliXCIpLG5ldyBTay5idWlsdGluLnN0cihcIi5cIildO2ZvcihiPTA7YjxTay5zeXNwYXRoLmxlbmd0aDsrK2IpZi5wdXNoKG5ldyBTay5idWlsdGluLnN0cihTay5zeXNwYXRoW2JdKSk7U2sucmVhbHN5c3BhdGg9bmV3IFNrLmJ1aWx0aW4ubGlzdChmKX19O1NrLmltcG9ydE1vZHVsZUludGVybmFsXz1mdW5jdGlvbihiLGYsZSxnLGsscCxoKXt2YXIgYSxjLG0sbixkPW51bGwsbD12b2lkIDAhPT1rP1xuay50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRuYW1lKTp2b2lkIDAscj12b2lkIDAhPT1sP2wuditcIi5cIjpcIlwiLHY9dm9pZCAwIT09az9rLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJHBhdGgpOnZvaWQgMDtTay5pbXBvcnRTZXRVcFBhdGgoaCk7aWYoayYmIWwpe2lmKHApcmV0dXJuO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBdHRlbXB0ZWQgdG8gaW1wb3J0IHJlbGF0aXZlIHRvIGludmFsaWQgcGFja2FnZSAobm8gbmFtZSlcIik7fXZvaWQgMD09PWUmJihlPXIrYik7dmFyIHE9Yi5zcGxpdChcIi5cIik7aWYoMTxxLmxlbmd0aCl7dmFyIHQ9cS5zbGljZSgwLHEubGVuZ3RoLTEpLmpvaW4oXCIuXCIpO2Q9U2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKHQsZix2b2lkIDAsdm9pZCAwLGsscCxoKX12YXIgdz1Tay5taXNjZXZhbC5jaGFpbihkLGZ1bmN0aW9uKEMpe2Q9QztjPVNrLnN5c21vZHVsZXMucXVpY2skbG9va3VwKG5ldyBTay5idWlsdGluLnN0cihlKSk7cmV0dXJuIHZvaWQgMCE9PVxuYz9kfHxjOlNrLm1pc2NldmFsLmNoYWluKHZvaWQgMCxmdW5jdGlvbigpe3ZhciBEPWI7aWYoMTxxLmxlbmd0aCl7aWYoIWQpcmV0dXJuO209U2suc3lzbW9kdWxlcy5tcCRzdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc3RyKHIrdCkpO0Q9cVtxLmxlbmd0aC0xXTt2PW0udHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kcGF0aCl9bj1uZXcgU2suYnVpbHRpbi5tb2R1bGU7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBnKXthPWIrXCIucHlcIjt2YXIgTD1Tay5jb21waWxlKGcsYSxcImV4ZWNcIixoKX1lbHNlIEw9U2subWlzY2V2YWwuY2hhaW4odm9pZCAwLGZ1bmN0aW9uKCl7aWYoU2sub25CZWZvcmVJbXBvcnQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5vbkJlZm9yZUltcG9ydClyZXR1cm4gU2sub25CZWZvcmVJbXBvcnQoYil9LGZ1bmN0aW9uKE4pe2lmKCExPT09Til0aHJvdyBuZXcgU2suYnVpbHRpbi5JbXBvcnRFcnJvcihcIkltcG9ydGluZyBcIitiK1wiIGlzIG5vdCBhbGxvd2VkXCIpO2lmKFwic3RyaW5nXCI9PT1cbnR5cGVvZiBOKXRocm93IG5ldyBTay5idWlsdGluLkltcG9ydEVycm9yKE4pO3JldHVybiBTay5pbXBvcnRTZWFyY2hQYXRoRm9yTmFtZShELFwiLmpzXCIsdil9LGZ1bmN0aW9uKE4pe3JldHVybiBOP3tmdW5jbmFtZTpcIiRidWlsdGlubW9kdWxlXCIsY29kZTpOLmNvZGUsZmlsZW5hbWU6Ti5maWxlbmFtZSxwYWNrYWdlUGF0aDpOLnBhY2thZ2VQYXRofTpTay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRTZWFyY2hQYXRoRm9yTmFtZShELFwiLnB5XCIsdiksZnVuY3Rpb24oQSl7aWYoTj1BKXJldHVybiBTay5jb21waWxlKE4uY29kZSxOLmZpbGVuYW1lLFwiZXhlY1wiLGgpfSxmdW5jdGlvbihBKXtpZihBKXJldHVybiBBLnBhY2thZ2VQYXRoPU4ucGFja2FnZVBhdGgsQX0pfSk7cmV0dXJuIEx9LGZ1bmN0aW9uKEQpe2lmKEQpe3ZhciBMPW4uJGpzPUQuY29kZTtudWxsPT1hJiYoYT1ELmZpbGVuYW1lKTtudWxsIT1Tay5kYXRlU2V0JiZTay5kYXRlU2V0fHwoTD1cIlNrLmV4ZWNTdGFydCA9IFNrLmxhc3RZaWVsZCA9IG5ldyBEYXRlKCk7XFxuXCIrXG5ELmNvZGUsU2suZGF0ZVNldD0hMCk7aWYoZil7dmFyIE49ZnVuY3Rpb24oRil7dmFyIEosUD1Tay5qc19iZWF1dGlmeShGKS5zcGxpdChcIlxcblwiKTtmb3IoSj0xO0o8PVAubGVuZ3RoOysrSil7dmFyIFc9KFwiXCIrSikubGVuZ3RoO2ZvcihGPVwiXCI7NT5XOysrVylGKz1cIiBcIjtQW0otMV09XCIvKiBcIitGK0orXCIgKi8gXCIrUFtKLTFdfXJldHVybiBQLmpvaW4oXCJcXG5cIil9O0w9TihMKTtTay5kZWJ1Z291dChMKX1cIiRjb21waWxlZG1vZFwiIT09RC5mdW5jbmFtZSYmKEwrPVwiXFxuXCIrRC5mdW5jbmFtZStcIjtcIik7dmFyIEE9bmV3IFNrLmJ1aWx0aW4uc3RyKGUpLEg9bmV3IFNrLmJ1aWx0aW4uc3RyKGIpO1NrLnN5c21vZHVsZXMubXAkYXNzX3N1YnNjcmlwdChBLG4pO2smJmsudHAkc2V0YXR0cihILG4pO3ZhciB4PVNrLmdsb2JhbC5ldmFsKEwpO24uaW5pdCRkaWN0KEEsU2suYnVpbHRpbi5ub25lLm5vbmUkKTtuLiRkLl9fcGFja2FnZV9fPUQucGFja2FnZVBhdGg/QTp0P25ldyBTay5idWlsdGluLnN0cihyK1xudCk6bD9sOlNrLmJ1aWx0aW4ubm9uZS5ub25lJDtELnBhY2thZ2VQYXRoJiYobi4kZC5fX3BhdGhfXz1uZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKEQucGFja2FnZVBhdGgpXSkpO0QuZmlsZW5hbWUmJlwiJGJ1aWx0aW5tb2R1bGVcIiE9PUQuZnVuY25hbWUmJihuLiRkLl9fZmlsZV9fPW5ldyBTay5idWlsdGluLnN0cihELmZpbGVuYW1lKSk7dmFyIEI9ayYmay4kaW5pdGlhbGl6aW5nO24uJGluaXRpYWxpemluZz0hMDtrJiYhQiYmKGsuJGluaXRpYWxpemluZz0hMCk7cmV0dXJuIFNrLm1pc2NldmFsLnRyeUNhdGNoKCgpPT5Tay5taXNjZXZhbC5jaGFpbih4KG4uJGQpLEY9PntuLiRpbml0aWFsaXppbmc9ITE7ayYmIUImJihrLiRpbml0aWFsaXppbmc9ITEpO3JldHVybiBGfSksRj0+e3RyeXtTay5hYnN0ci5vYmplY3REZWxJdGVtKFNrLnN5c21vZHVsZXMsQSl9Y2F0Y2goSil7fWlmKGspdHJ5e2sudHAkc2V0YXR0cihILHZvaWQgMCl9Y2F0Y2goSil7fW4uJGluaXRpYWxpemluZz1cbiExO2smJiFCJiYoay4kaW5pdGlhbGl6aW5nPSExKTt0aHJvdyBGO30pfX0sZnVuY3Rpb24oRCl7dmFyIEw7aWYodm9pZCAwPT09RCl7aWYocCYmIWQpcmV0dXJuO3Rocm93IG5ldyBTay5idWlsdGluLk1vZHVsZU5vdEZvdW5kRXJyb3IoXCJObyBtb2R1bGUgbmFtZWQgXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcihuZXcgU2suYnVpbHRpbi5zdHIoYikpKTt9aWYoRCE9PW4uJGQpe2ZvcihMIGluIG4uJGQpRFtMXXx8KERbTF09bi4kZFtMXSk7bi4kZD1EfWlmKFNrLm9uQWZ0ZXJJbXBvcnQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5vbkFmdGVySW1wb3J0KXRyeXtTay5vbkFmdGVySW1wb3J0KGIpfWNhdGNoKE4pe31yZXR1cm4gZD8obS50cCRzZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihxW3EubGVuZ3RoLTFdKSxuKSxkKTpufSl9KTtyZXR1cm4gaD93OlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyh3KX07U2suaW1wb3J0TW9kdWxlPWZ1bmN0aW9uKGIsXG5mLGUpe3JldHVybiBTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oYixmLHZvaWQgMCx2b2lkIDAsdm9pZCAwLCExLGUpfTtTay5pbXBvcnRNYWluPWZ1bmN0aW9uKGIsZixlKXtTay5kYXRlU2V0PSExO1NrLmZpbGVzTG9hZGVkPSExO1NrLnN5c21vZHVsZXM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7U2sucmVhbHN5c3BhdGg9dm9pZCAwO1NrLnJlc2V0Q29tcGlsZXIoKTtyZXR1cm4gU2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKGIsZixcIl9fbWFpbl9fXCIsdm9pZCAwLHZvaWQgMCwhMSxlKX07U2suaW1wb3J0TWFpbldpdGhCb2R5PWZ1bmN0aW9uKGIsZixlLGcpe1NrLmRhdGVTZXQ9ITE7U2suZmlsZXNMb2FkZWQ9ITE7U2suc3lzbW9kdWxlcz1uZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtTay5yZWFsc3lzcGF0aD12b2lkIDA7U2sucmVzZXRDb21waWxlcigpO3JldHVybiBTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oYixmLFwiX19tYWluX19cIixlLHZvaWQgMCwhMSxnKX07U2suaW1wb3J0QnVpbHRpbldpdGhCb2R5PVxuZnVuY3Rpb24oYixmLGUsZyl7cmV0dXJuIFNrLmltcG9ydE1vZHVsZUludGVybmFsXyhiLGYsXCJfX2J1aWx0aW5fXy5cIitiLGUsdm9pZCAwLCExLGcpfTtTay5idWlsdGluLl9faW1wb3J0X189ZnVuY3Rpb24oYixmLGUsZyxrKXtiPWIudG9TdHJpbmcoKTt2YXIgcD1Tay5nbG9iYWxzLGg7bnVsbD09ayYmKGs9U2suX19mdXR1cmVfXy5hYnNvbHV0ZV9pbXBvcnQ/MDotMSk7aWYoMCE9PWsmJmYuX19wYWNrYWdlX18mJmYuX19wYWNrYWdlX18hPT1Tay5idWlsdGluLm5vbmUubm9uZSQpe2lmKChoPWYuX19wYWNrYWdlX18udikmJjA8ayl7Zj1oLnNwbGl0KFwiLlwiKTtpZihrLTE+PWYubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLkltcG9ydEVycm9yKFwiQXR0ZW1wdGVkIHJlbGF0aXZlIGltcG9ydCBiZXlvbmQgdG9wbGV2ZWwgcGFja2FnZVwiKTtmLmxlbmd0aC09ay0xO2g9Zi5qb2luKFwiLlwiKX12YXIgYT1Tay5zeXNtb2R1bGVzLnF1aWNrJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoaCkpfWlmKDA8XG5rJiZ2b2lkIDA9PT1hKXRocm93IG5ldyBTay5idWlsdGluLkltcG9ydEVycm9yKFwiQXR0ZW1wdGVkIHJlbGF0aXZlIGltcG9ydCBpbiBub24tcGFja2FnZVwiKTtiLnNwbGl0KFwiLlwiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odm9pZCAwLGZ1bmN0aW9uKCl7aWYoMCE9PWsmJnZvaWQgMCE9PWEpcmV0dXJuXCJcIj09PWI/YTpTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oYix2b2lkIDAsaCtcIi5cIitiLHZvaWQgMCxhLC0xPT1rLCEwKX0sZnVuY3Rpb24oYyl7cmV0dXJuIHZvaWQgMD09PWM/KGg9YT12b2lkIDAsU2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKGIsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLCExLCEwKSk6Y30sZnVuY3Rpb24oYyl7aWYoZyYmMCE9PWcubGVuZ3RoKXtjPVtudWxsXTtjb25zdCBtPVNrLnN5c21vZHVsZXMubXAkc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cigoaHx8XCJcIikrKGgmJmI/XCIuXCI6XCJcIikrYikpO2ZvcihsZXQgbj0wO248Zy5sZW5ndGg7bisrKXtjb25zdCBkPVxuZ1tuXTtcIipcIiE9PWQmJnZvaWQgMD09PW0udHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoZCkpJiZjLnB1c2goKCk9PlNrLmltcG9ydE1vZHVsZUludGVybmFsXyhkLHZvaWQgMCx2b2lkIDAsdm9pZCAwLG0sITAsITApKX1yZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oLi4uYyxmdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KG0pO3JldHVybiBtfSl9cmV0dXJuIGN9LGZ1bmN0aW9uKGMpe3AhPT1Tay5nbG9iYWxzJiYoU2suZ2xvYmFscz1wKTtyZXR1cm4gY30pfTtTay5pbXBvcnRTdGFyPWZ1bmN0aW9uKGIsZixlKXtpZihlPWIudHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXCJfX2FsbF9fXCIpKSlmb3IobGV0IGc9U2suYWJzdHIuaXRlcihlKSxrPWcudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1rO2s9Zy50cCRpdGVybmV4dCgpKWZbay52XT1Tay5hYnN0ci5nYXR0cihiLGspO2Vsc2V7ZT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiLiRkKTtmb3IobGV0IGcgaW4gZSlcIl9cIiE9XG5lW2ddLmNoYXJBdCgwKSYmKGZbZVtnXV09Yi4kZFtlW2ddXSl9fTtTay5leHBvcnRTeW1ib2woXCJTay5pbXBvcnRNYWluXCIsU2suaW1wb3J0TWFpbik7U2suZXhwb3J0U3ltYm9sKFwiU2suaW1wb3J0TWFpbldpdGhCb2R5XCIsU2suaW1wb3J0TWFpbldpdGhCb2R5KTtTay5leHBvcnRTeW1ib2woXCJTay5pbXBvcnRCdWlsdGluV2l0aEJvZHlcIixTay5pbXBvcnRCdWlsdGluV2l0aEJvZHkpO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uX19pbXBvcnRfX1wiLFNrLmJ1aWx0aW4uX19pbXBvcnRfXyk7U2suZXhwb3J0U3ltYm9sKFwiU2suaW1wb3J0U3RhclwiLFNrLmltcG9ydFN0YXIpfSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4udGltU29ydD1mdW5jdGlvbihiLGYpe3RoaXMubGlzdD1uZXcgU2suYnVpbHRpbi5saXN0KGIudik7dGhpcy5NSU5fR0FMTE9QPTc7dGhpcy5saXN0bGVuZ3RoPWY/ZjpiLnNxJGxlbmd0aCgpfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmx0PWZ1bmN0aW9uKGIsXG5mKXtyZXR1cm4gU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGIsZixcIkx0XCIpfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmxlPWZ1bmN0aW9uKGIsZil7cmV0dXJuIXRoaXMubHQoZixiKX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5zZXRpdGVtPWZ1bmN0aW9uKGIsZil7dGhpcy5saXN0LnZbYl09Zn07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5iaW5hcnlfc29ydD1mdW5jdGlvbihiLGYpe3ZhciBlO2ZvcihlPWIuYmFzZStmO2U8Yi5iYXNlK2IubGVuO2UrKyl7dmFyIGc9Yi5iYXNlO3ZhciBrPWU7Zm9yKGY9Yi5nZXRpdGVtKGspO2c8azspe3ZhciBwPWcrKGstZz4+MSk7dGhpcy5sdChmLGIuZ2V0aXRlbShwKSk/az1wOmc9cCsxfVNrLmFzc2VydHMuYXNzZXJ0KGc9PT1rKTtmb3IocD1lO3A+ZztwLS0pYi5zZXRpdGVtKHAsYi5nZXRpdGVtKHAtMSkpO2Iuc2V0aXRlbShnLGYpfX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5jb3VudF9ydW49XG5mdW5jdGlvbihiKXt2YXIgZjtpZigxPj1iLmxlbil7dmFyIGU9Yi5sZW47dmFyIGc9ITF9ZWxzZSBpZihlPTIsdGhpcy5sdChiLmdldGl0ZW0oYi5iYXNlKzEpLGIuZ2V0aXRlbShiLmJhc2UpKSlmb3IoZz0hMCxmPWIuYmFzZSsyO2Y8Yi5iYXNlK2IubGVuO2YrKylpZih0aGlzLmx0KGIuZ2V0aXRlbShmKSxiLmdldGl0ZW0oZi0xKSkpZSsrO2Vsc2UgYnJlYWs7ZWxzZSBmb3IoZz0hMSxmPWIuYmFzZSsyO2Y8Yi5iYXNlK2IubGVuJiYhdGhpcy5sdChiLmdldGl0ZW0oZiksYi5nZXRpdGVtKGYtMSkpO2YrKyllKys7cmV0dXJue3J1bjpuZXcgU2suYnVpbHRpbi5saXN0U2xpY2UoYi5saXN0LGIuYmFzZSxlKSxkZXNjZW5kaW5nOmd9fTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLnNvcnQ9ZnVuY3Rpb24oKXt2YXIgYixmPW5ldyBTay5idWlsdGluLmxpc3RTbGljZSh0aGlzLmxpc3QsMCx0aGlzLmxpc3RsZW5ndGgpO2lmKCEoMj5mLmxlbikpe3RoaXMubWVyZ2VfaW5pdCgpO2ZvcihiPVxudGhpcy5tZXJnZV9jb21wdXRlX21pbnJ1bihmLmxlbik7MDxmLmxlbjspe3ZhciBlPXRoaXMuY291bnRfcnVuKGYpO2UuZGVzY2VuZGluZyYmZS5ydW4ucmV2ZXJzZSgpO2lmKGUucnVuLmxlbjxiKXt2YXIgZz1lLnJ1bi5sZW47ZS5ydW4ubGVuPWI8Zi5sZW4/YjpmLmxlbjt0aGlzLmJpbmFyeV9zb3J0KGUucnVuLGcpfWYuYWR2YW5jZShlLnJ1bi5sZW4pO3RoaXMucGVuZGluZy5wdXNoKGUucnVuKTt0aGlzLm1lcmdlX2NvbGxhcHNlKCl9U2suYXNzZXJ0cy5hc3NlcnQoZi5iYXNlPT10aGlzLmxpc3RsZW5ndGgpO3RoaXMubWVyZ2VfZm9yY2VfY29sbGFwc2UoKTtTay5hc3NlcnRzLmFzc2VydCgxPT10aGlzLnBlbmRpbmcubGVuZ3RoKTtTay5hc3NlcnRzLmFzc2VydCgwPT09dGhpcy5wZW5kaW5nWzBdLmJhc2UpO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMucGVuZGluZ1swXS5sZW49PXRoaXMubGlzdGxlbmd0aCl9fTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmdhbGxvcD1mdW5jdGlvbihiLFxuZixlLGcpe3ZhciBrO1NrLmFzc2VydHMuYXNzZXJ0KDA8PWUmJmU8Zi5sZW4pO3ZhciBwPXRoaXM7Zz1nP2Z1bmN0aW9uKG0sbil7cmV0dXJuIHAubGUobSxuKX06ZnVuY3Rpb24obSxuKXtyZXR1cm4gcC5sdChtLG4pfTt2YXIgaD1mLmJhc2UrZTt2YXIgYT0wO3ZhciBjPTE7aWYoZyhmLmdldGl0ZW0oaCksYikpe2ZvcihrPWYubGVuLWU7YzxrOylpZihnKGYuZ2V0aXRlbShoK2MpLGIpKXthPWM7dHJ5e2M9KGM8PDEpKzF9Y2F0Y2gobSl7Yz1rfX1lbHNlIGJyZWFrO2M+ayYmKGM9ayk7YSs9ZTtjKz1lfWVsc2V7Zm9yKGs9ZSsxO2M8ayYmIWcoZi5nZXRpdGVtKGgtYyksYik7KXthPWM7dHJ5e2M9KGM8PDEpKzF9Y2F0Y2gobSl7Yz1rfX1jPmsmJihjPWspO2g9ZS1hO2E9ZS1jO2M9aH1Tay5hc3NlcnRzLmFzc2VydCgtMTw9YTxjPD1mLmxlbik7Zm9yKGErPTE7YTxjOyllPWErKGMtYT4+MSksZyhmLmdldGl0ZW0oZi5iYXNlK2UpLGIpP2E9ZSsxOmM9ZTtTay5hc3NlcnRzLmFzc2VydChhPT1cbmMpO3JldHVybiBjfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2luaXQ9ZnVuY3Rpb24oKXt0aGlzLm1pbl9nYWxsb3A9dGhpcy5NSU5fR0FMTE9QO3RoaXMucGVuZGluZz1bXX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5tZXJnZV9sbz1mdW5jdGlvbihiLGYpe3ZhciBlLGcsaztTay5hc3NlcnRzLmFzc2VydCgwPGIubGVuJiYwPGYubGVuJiZiLmJhc2UrYi5sZW49PWYuYmFzZSk7dmFyIHA9dGhpcy5taW5fZ2FsbG9wO3ZhciBoPWIuYmFzZTtiPWIuY29weWl0ZW1zKCk7dHJ5e2lmKHRoaXMuc2V0aXRlbShoLGYucG9wbGVmdCgpKSxoKyssMSE9Yi5sZW4mJjAhPT1mLmxlbilmb3IoOzspe2ZvcihnPWU9MDs7KWlmKHRoaXMubHQoZi5nZXRpdGVtKGYuYmFzZSksYi5nZXRpdGVtKGIuYmFzZSkpKXt0aGlzLnNldGl0ZW0oaCxmLnBvcGxlZnQoKSk7aCsrO2lmKDA9PT1mLmxlbilyZXR1cm47ZysrO2U9MDtpZihnPj1wKWJyZWFrfWVsc2V7dGhpcy5zZXRpdGVtKGgsXG5iLnBvcGxlZnQoKSk7aCsrO2lmKDE9PWIubGVuKXJldHVybjtlKys7Zz0wO2lmKGU+PXApYnJlYWt9Zm9yKHArPTE7Oyl7dGhpcy5taW5fZ2FsbG9wPXAtPTE8cDtlPXRoaXMuZ2FsbG9wKGYuZ2V0aXRlbShmLmJhc2UpLGIsMCwhMCk7Zm9yKGs9Yi5iYXNlO2s8Yi5iYXNlK2U7aysrKXRoaXMuc2V0aXRlbShoLGIuZ2V0aXRlbShrKSksaCsrO2IuYWR2YW5jZShlKTtpZigxPj1iLmxlbilyZXR1cm47dGhpcy5zZXRpdGVtKGgsZi5wb3BsZWZ0KCkpO2grKztpZigwPT09Zi5sZW4pcmV0dXJuO2c9dGhpcy5nYWxsb3AoYi5nZXRpdGVtKGIuYmFzZSksZiwwLCExKTtmb3Ioaz1mLmJhc2U7azxmLmJhc2UrZztrKyspdGhpcy5zZXRpdGVtKGgsZi5nZXRpdGVtKGspKSxoKys7Zi5hZHZhbmNlKGcpO2lmKDA9PT1mLmxlbilyZXR1cm47dGhpcy5zZXRpdGVtKGgsYi5wb3BsZWZ0KCkpO2grKztpZigxPT1iLmxlbilyZXR1cm47aWYoZTx0aGlzLk1JTl9HQUxMT1AmJmc8dGhpcy5NSU5fR0FMTE9QKWJyZWFrO1xucCsrO3RoaXMubWluX2dhbGxvcD1wfX19ZmluYWxseXtTay5hc3NlcnRzLmFzc2VydCgwPD1iLmxlbiYmMDw9Zi5sZW4pO2ZvcihrPWYuYmFzZTtrPGYuYmFzZStmLmxlbjtrKyspdGhpcy5zZXRpdGVtKGgsZi5nZXRpdGVtKGspKSxoKys7Zm9yKGs9Yi5iYXNlO2s8Yi5iYXNlK2IubGVuO2srKyl0aGlzLnNldGl0ZW0oaCxiLmdldGl0ZW0oaykpLGgrK319O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfaGk9ZnVuY3Rpb24oYixmKXt2YXIgZSxnLGs7U2suYXNzZXJ0cy5hc3NlcnQoMDxiLmxlbiYmMDxmLmxlbiYmYi5iYXNlK2IubGVuPT1mLmJhc2UpO3ZhciBwPXRoaXMubWluX2dhbGxvcDt2YXIgaD1mLmJhc2UrZi5sZW47Zj1mLmNvcHlpdGVtcygpO3RyeXtpZihoLS0sdGhpcy5zZXRpdGVtKGgsYi5wb3ByaWdodCgpKSwwIT09Yi5sZW4mJjEhPWYubGVuKWZvcig7Oyl7Zm9yKGc9ZT0wOzspe3ZhciBhPWIuZ2V0aXRlbShiLmJhc2UrYi5sZW4tMSk7dmFyIGM9Zi5nZXRpdGVtKGYuYmFzZStcbmYubGVuLTEpO2lmKHRoaXMubHQoYyxhKSl7aC0tO3RoaXMuc2V0aXRlbShoLGEpO2IubGVuLS07aWYoMD09PWIubGVuKXJldHVybjtlKys7Zz0wO2lmKGU+PXApYnJlYWt9ZWxzZXtoLS07dGhpcy5zZXRpdGVtKGgsYyk7Zi5sZW4tLTtpZigxPT1mLmxlbilyZXR1cm47ZysrO2U9MDtpZihnPj1wKWJyZWFrfX1mb3IocCs9MTs7KXt0aGlzLm1pbl9nYWxsb3A9cC09MTxwO2M9Zi5nZXRpdGVtKGYuYmFzZStmLmxlbi0xKTt2YXIgbT10aGlzLmdhbGxvcChjLGIsYi5sZW4tMSwhMCk7ZT1iLmxlbi1tO2ZvcihrPWIuYmFzZStiLmxlbi0xO2s+Yi5iYXNlK20tMTtrLS0paC0tLHRoaXMuc2V0aXRlbShoLGIuZ2V0aXRlbShrKSk7Yi5sZW4tPWU7aWYoMD09PWIubGVuKXJldHVybjtoLS07dGhpcy5zZXRpdGVtKGgsZi5wb3ByaWdodCgpKTtpZigxPT1mLmxlbilyZXR1cm47YT1iLmdldGl0ZW0oYi5iYXNlK2IubGVuLTEpO209dGhpcy5nYWxsb3AoYSxmLGYubGVuLTEsITEpO2c9Zi5sZW4tbTtcbmZvcihrPWYuYmFzZStmLmxlbi0xO2s+Zi5iYXNlK20tMTtrLS0paC0tLHRoaXMuc2V0aXRlbShoLGYuZ2V0aXRlbShrKSk7Zi5sZW4tPWc7aWYoMT49Zi5sZW4pcmV0dXJuO2gtLTt0aGlzLnNldGl0ZW0oaCxiLnBvcHJpZ2h0KCkpO2lmKDA9PT1iLmxlbilyZXR1cm47aWYoZTx0aGlzLk1JTl9HQUxMT1AmJmc8dGhpcy5NSU5fR0FMTE9QKWJyZWFrO3ArKzt0aGlzLm1pbl9nYWxsb3A9cH19fWZpbmFsbHl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9Yi5sZW4mJjA8PWYubGVuKTtmb3Ioaz1iLmJhc2UrYi5sZW4tMTtrPmIuYmFzZS0xO2stLSloLS0sdGhpcy5zZXRpdGVtKGgsYi5nZXRpdGVtKGspKTtmb3Ioaz1mLmJhc2UrZi5sZW4tMTtrPmYuYmFzZS0xO2stLSloLS0sdGhpcy5zZXRpdGVtKGgsZi5nZXRpdGVtKGspKX19O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfYXQ9ZnVuY3Rpb24oYil7MD5iJiYoYj10aGlzLnBlbmRpbmcubGVuZ3RoK2IpO3ZhciBmPXRoaXMucGVuZGluZ1tiXTtcbnZhciBlPXRoaXMucGVuZGluZ1tiKzFdO1NrLmFzc2VydHMuYXNzZXJ0KDA8Zi5sZW4mJjA8ZS5sZW4pO1NrLmFzc2VydHMuYXNzZXJ0KGYuYmFzZStmLmxlbj09ZS5iYXNlKTt0aGlzLnBlbmRpbmdbYl09bmV3IFNrLmJ1aWx0aW4ubGlzdFNsaWNlKHRoaXMubGlzdCxmLmJhc2UsZi5sZW4rZS5sZW4pO3RoaXMucGVuZGluZy5zcGxpY2UoYisxLDEpO2I9dGhpcy5nYWxsb3AoZS5nZXRpdGVtKGUuYmFzZSksZiwwLCEwKTtmLmFkdmFuY2UoYik7MCE9PWYubGVuJiYoZS5sZW49dGhpcy5nYWxsb3AoZi5nZXRpdGVtKGYuYmFzZStmLmxlbi0xKSxlLGUubGVuLTEsITEpLDAhPT1lLmxlbiYmKGYubGVuPD1lLmxlbj90aGlzLm1lcmdlX2xvKGYsZSk6dGhpcy5tZXJnZV9oaShmLGUpKSl9O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfY29sbGFwc2U9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5wZW5kaW5nOzE8Yi5sZW5ndGg7KWlmKDM8PWIubGVuZ3RoJiZiW2IubGVuZ3RoLVxuM10ubGVuPD1iW2IubGVuZ3RoLTJdLmxlbitiW2IubGVuZ3RoLTFdLmxlbiliW2IubGVuZ3RoLTNdLmxlbjxiW2IubGVuZ3RoLTFdLmxlbj90aGlzLm1lcmdlX2F0KC0zKTp0aGlzLm1lcmdlX2F0KC0yKTtlbHNlIGlmKGJbYi5sZW5ndGgtMl0ubGVuPD1iW2IubGVuZ3RoLTFdLmxlbil0aGlzLm1lcmdlX2F0KC0yKTtlbHNlIGJyZWFrfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2ZvcmNlX2NvbGxhcHNlPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPXRoaXMucGVuZGluZzsxPGIubGVuZ3RoOykzPD1iLmxlbmd0aCYmYltiLmxlbmd0aC0zXS5sZW48YltiLmxlbmd0aC0xXS5sZW4/dGhpcy5tZXJnZV9hdCgtMyk6dGhpcy5tZXJnZV9hdCgtMil9O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfY29tcHV0ZV9taW5ydW49ZnVuY3Rpb24oYil7Zm9yKHZhciBmPTA7NjQ8PWI7KWZ8PWImMSxiPj49MTtyZXR1cm4gYitmfTtTay5idWlsdGluLmxpc3RTbGljZT1mdW5jdGlvbihiLFxuZixlKXt0aGlzLmxpc3Q9Yjt0aGlzLmJhc2U9Zjt0aGlzLmxlbj1lfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUuY29weWl0ZW1zPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5iYXNlLGY9dGhpcy5iYXNlK3RoaXMubGVuO1NrLmFzc2VydHMuYXNzZXJ0KDA8PWI8PWYpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0U2xpY2UobmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLmxpc3Qudi5zbGljZShiLGYpKSwwLHRoaXMubGVuKX07U2suYnVpbHRpbi5saXN0U2xpY2UucHJvdG90eXBlLmFkdmFuY2U9ZnVuY3Rpb24oYil7dGhpcy5iYXNlKz1iO3RoaXMubGVuLT1iO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMuYmFzZTw9dGhpcy5saXN0LnNxJGxlbmd0aCgpKX07U2suYnVpbHRpbi5saXN0U2xpY2UucHJvdG90eXBlLmdldGl0ZW09ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMubGlzdC52W2JdfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUuc2V0aXRlbT1mdW5jdGlvbihiLGYpe3RoaXMubGlzdC52W2JdPVxuZn07U2suYnVpbHRpbi5saXN0U2xpY2UucHJvdG90eXBlLnBvcGxlZnQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmxpc3Qudlt0aGlzLmJhc2VdO3RoaXMuYmFzZSsrO3RoaXMubGVuLS07cmV0dXJuIGJ9O1NrLmJ1aWx0aW4ubGlzdFNsaWNlLnByb3RvdHlwZS5wb3ByaWdodD1mdW5jdGlvbigpe3RoaXMubGVuLS07cmV0dXJuIHRoaXMubGlzdC52W3RoaXMuYmFzZSt0aGlzLmxlbl19O1NrLmJ1aWx0aW4ubGlzdFNsaWNlLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKCl7Zm9yKHZhciBiLGYsZT10aGlzLmxpc3QsZz10aGlzLmJhc2Usaz1nK3RoaXMubGVuLTE7ZzxrOyliPWUudltrXSxmPWUudltnXSxlLnZbZ109YixlLnZba109ZixnKyssay0tfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmxpc3RTbGljZVwiLFNrLmJ1aWx0aW4ubGlzdFNsaWNlKTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLnRpbVNvcnRcIixTay5idWlsdGluLnRpbVNvcnQpfSxmdW5jdGlvbihFLFEpe1NrLmJ1aWx0aW4uc3VwZXJfPVxuU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInN1cGVyXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZil7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3VwZXJfLFwiYmFkIGNhbGwgdG8gc3VwZXIsIHVzZSAnbmV3J1wiKTt0aGlzLnR5cGU9Yjt0aGlzLm9iaj1mO2lmKHZvaWQgMCE9PWImJiFTay5idWlsdGluLmNoZWNrQ2xhc3MoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibXVzdCBiZSB0eXBlLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYikpO3RoaXMub2JqX3R5cGU9dm9pZCAwIT09dGhpcy5vYmo/dGhpcy4kc3VwZXJjaGVjayhiLHRoaXMub2JqKTpudWxsfSxzbG90czp7dHAkZG9jOlwic3VwZXIoKSAtPiBzYW1lIGFzIHN1cGVyKF9fY2xhc3NfXywgPGZpcnN0IGFyZ3VtZW50PilcXG5zdXBlcih0eXBlKSAtPiB1bmJvdW5kIHN1cGVyIG9iamVjdFxcbnN1cGVyKHR5cGUsIG9iaikgLT4gYm91bmQgc3VwZXIgb2JqZWN0OyByZXF1aXJlcyBpc2luc3RhbmNlKG9iaiwgdHlwZSlcXG5zdXBlcih0eXBlLCB0eXBlMikgLT4gYm91bmQgc3VwZXIgb2JqZWN0OyByZXF1aXJlcyBpc3N1YmNsYXNzKHR5cGUyLCB0eXBlKVxcblR5cGljYWwgdXNlIHRvIGNhbGwgYSBjb29wZXJhdGl2ZSBzdXBlcmNsYXNzIG1ldGhvZDpcXG5jbGFzcyBDKEIpOlxcbiAgICBkZWYgbWV0aChzZWxmLCBhcmcpOlxcbiAgICAgICAgc3VwZXIoKS5tZXRoKGFyZylcXG5UaGlzIHdvcmtzIGZvciBjbGFzcyBtZXRob2RzIHRvbzpcXG5jbGFzcyBDKEIpOlxcbiAgICBAY2xhc3NtZXRob2RcXG4gICAgZGVmIGNtZXRoKGNscywgYXJnKTpcXG4gICAgICAgIHN1cGVyKCkuY21ldGgoYXJnKVxcblwiLFxudHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYixmKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic3VwZXJcIixmKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJzdXBlclwiLGIsMSwyKTtmPWJbMF07Yj1iWzFdO2lmKCFTay5idWlsdGluLmNoZWNrQ2xhc3MoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibXVzdCBiZSB0eXBlLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZikpO3RoaXMub2JqPWI7dGhpcy50eXBlPWY7bnVsbCE9dGhpcy5vYmomJih0aGlzLm9ial90eXBlPXRoaXMuJHN1cGVyY2hlY2soZix0aGlzLm9iaikpfSwkcigpe3JldHVybiB0aGlzLm9iaj9uZXcgU2suYnVpbHRpbi5zdHIoXCI8c3VwZXI6IDxjbGFzcyAnXCIrdGhpcy50eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJz4sIDxcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzLm9iaikrXCIgb2JqZWN0Pj5cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFwiPHN1cGVyOiA8Y2xhc3MgJ1wiK3RoaXMudHlwZS5wcm90b3R5cGUudHAkbmFtZStcblwiJz4sIE5VTEw+XCIpfSx0cCRnZXRhdHRyKGIsZil7bGV0IGU9dGhpcy5vYmpfdHlwZTtpZihudWxsPT1lKXJldHVybiBTay5nZW5lcmljLmdldEF0dHIuY2FsbCh0aGlzLGIsZik7dmFyIGc9ZS5wcm90b3R5cGUudHAkbXJvO2NvbnN0IGs9Zy5sZW5ndGg7aWYoYj09PVNrLmJ1aWx0aW4uc3RyLiRjbGFzcylyZXR1cm4gU2suZ2VuZXJpYy5nZXRBdHRyLmNhbGwodGhpcyxiLGYpO2xldCBwO2ZvcihwPTA7cCsxPGsmJnRoaXMudHlwZSE9PWdbcF07cCsrKTtwKys7aWYocD49aylyZXR1cm4gU2suZ2VuZXJpYy5nZXRBdHRyLmNhbGwodGhpcyxiLGYpO2I9Yi4kbWFuZ2xlZDtsZXQgaDtmb3IoO3A8azspe2Y9Z1twXS5wcm90b3R5cGU7Zi5oYXNPd25Qcm9wZXJ0eShiKSYmKGg9ZltiXSk7aWYodm9pZCAwIT09aClyZXR1cm4gZz1oLnRwJGRlc2NyX2dldCx2b2lkIDAhPT1nJiYoaD1nLmNhbGwoaCx0aGlzLm9iaj09PWU/bnVsbDp0aGlzLm9iaixlKSksaDtwKyt9fSx0cCRkZXNjcl9nZXQoYixcbmYsZSl7aWYobnVsbD09PWJ8fG51bGwhPXRoaXMub2JqKXJldHVybiB0aGlzO2lmKHRoaXMub2IkdHlwZSE9PVNrLmJ1aWx0aW4uc3VwZXJfKXJldHVybiBiPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLm9iJHR5cGUsW3RoaXMudHlwZSxiXSksZT9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKTtlPXRoaXMuJHN1cGVyY2hlY2sodGhpcy50eXBlLGIpO2Y9bmV3IFNrLmJ1aWx0aW4uc3VwZXJfO2YudHlwZT10aGlzLnR5cGU7Zi5vYmo9YjtmLm9ial90eXBlPWU7cmV0dXJuIGZ9fSxnZXRzZXRzOntfX3RoaXNjbGFzc19fOnskZ2V0KCl7cmV0dXJuIHRoaXMudHlwZX0sJGRvYzpcInRoZSBjbGFzcyBpbnZva2luZyBzdXBlcigpXCJ9LF9fc2VsZl9fOnskZ2V0KCl7cmV0dXJuIHRoaXMub2JqfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRkb2M6XCJ0aGUgaW5zdGFuY2UgaW52b2tpbmcgc3VwZXIoKTsgbWF5IGJlIE5vbmVcIn0sX19zZWxmX2NsYXNzX186eyRnZXQoKXtyZXR1cm4gdGhpcy5vYmpfdHlwZXx8XG5Tay5idWlsdGluLm5vbmUubm9uZSR9LCRkb2M6XCJ0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgaW52b2tpbmcgc3VwZXIoKTsgbWF5IGJlIE5vbmVcIn19LHByb3RvOnskc3VwZXJjaGVjayhiLGYpe2lmKFNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhmKSYmZi4kaXNTdWJUeXBlKGIpKXJldHVybiBmO2lmKGYub2IkdHlwZS4kaXNTdWJUeXBlKGIpKXJldHVybiBmLm9iJHR5cGU7e2NvbnN0IGU9Zi50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRjbGFzcyk7aWYodm9pZCAwIT09ZSYmZSE9PWYub2IkdHlwZSYmU2suYnVpbHRpbi5jaGVja0NsYXNzKGUpJiZlLiRpc1N1YlR5cGUoYikpcmV0dXJuIGV9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic3VwZXIodHlwZSwgb2JqKTogb2JqIG11c3QgYmUgYW4gaW5zdGFuY2Ugb3Igc3VidHlwZSBvZiB0eXBlXCIpO319fSl9LGZ1bmN0aW9uKEUsUSl7U2suYnVpbHRpbi5HZW5lcmljQWxpYXM9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInR5cGVzLkdlbmVyaWNBbGlhc1wiLFxue2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZil7dGhpcy4kb3JpZ2luPWI7ZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGV8fChmPW5ldyBTay5idWlsdGluLnR1cGxlKFtmXSkpO3RoaXMuJGFyZ3M9Zjt0aGlzLiRwYXJhbXM9bnVsbH0sc2xvdHM6e3RwJG5ldyhiLGYpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJHZW5lcmljQWxpYXNcIixmKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJHZW5lcmljQWxpYXNcIixiLDIsMik7cmV0dXJuIG5ldyBTay5idWlsdGluLkdlbmVyaWNBbGlhcyhiWzBdLGJbMV0pfSx0cCRnZXRhdHRyKGIsZil7cmV0dXJuIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikmJiF0aGlzLmF0dHIkZXhjLmluY2x1ZGVzKGIpP3RoaXMuJG9yaWdpbi50cCRnZXRhdHRyKGIsZik6U2suZ2VuZXJpYy5nZXRBdHRyLmNhbGwodGhpcyxiLGYpfSwkcigpe2NvbnN0IGI9dGhpcy5nYSRyZXByKHRoaXMuJG9yaWdpbik7bGV0IGY9XCJcIjt0aGlzLiRhcmdzLnYuZm9yRWFjaCgoZSxnKT0+XG57Zis9MDxnP1wiLCBcIjpcIlwiO2YrPXRoaXMuZ2EkcmVwcihlKX0pO2Z8fChmPVwiKClcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihiK1wiW1wiK2YrXCJdXCIpfSx0cCRkb2M6XCJSZXByZXNlbnQgYSBQRVAgNTg1IGdlbmVyaWMgdHlwZVxcblxcbkUuZy4gZm9yIHQgPSBsaXN0W2ludF0sIHQub3JpZ2luIGlzIGxpc3QgYW5kIHQuYXJncyBpcyAoaW50LCkuXCIsdHAkaGFzaCgpe2NvbnN0IGI9U2suYWJzdHIub2JqZWN0SGFzaCh0aGlzLiRvcmlnaW4pO2lmKC0xPT1iKXJldHVybi0xO2NvbnN0IGY9U2suYWJzdHIub2JqZWN0SGFzaCh0aGlzLiRhcmdzKTtyZXR1cm4tMT09Zj8tMTpiXmZ9LHRwJGNhbGwoYixmKXtiPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLiRvcmlnaW4sYixmKTt0cnl7Yi50cCRzZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcIl9fb3JpZ19jbGFzc19fXCIpLHRoaXMpfWNhdGNoKGUpe2lmKCEoZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3J8fGUgaW5zdGFuY2VvZlxuU2suYnVpbHRpbi5UeXBlRXJyb3IpKXRocm93IGU7fXJldHVybiBifSx0cCRyaWNoY29tcGFyZShiLGYpe2lmKCEoYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uR2VuZXJpY0FsaWFzKXx8XCJFcVwiIT09ZiYmXCJOb3RFcVwiIT09ZilyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3QgZT1Tay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy4kb3JpZ2luLGIuJG9yaWdpbixcIkVxXCIpO2lmKCFlKXJldHVyblwiRXFcIj09PWY/ZTohZTtiPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLiRhcmdzLGIuJGFyZ3MsXCJFcVwiKTtyZXR1cm5cIkVxXCI9PT1mP2I6IWJ9LHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsbXAkc3Vic2NyaXB0KGIpe251bGw9PT10aGlzLiRwYXJhbXMmJnRoaXMubWskcGFyYW1zKCk7aWYoMD09PXRoaXMuJHBhcmFtcy5zcSRsZW5ndGgoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJUaGVyZSBhcmUgbm8gdHlwZSB2YXJpYWJsZXMgbGVmdCBpbiBcIitcblNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcykpO319LG1ldGhvZHM6e19fbXJvX2VudHJpZXNfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3RoaXMuJG9yaWdpbl0pfSwkZmxhZ3M6e05vQXJnczohMH19LF9faW5zdGFuY2VjaGVja19fOnskbWV0aChiKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpc2luc3RhbmNlKCkgYXJndW1lbnQgMiBjYW5ub3QgYmUgYSBwYXJhbWV0ZXJpemVkIGdlbmVyaWNcIik7fSwkZmxhZ3M6e09uZUFyZzohMH19LF9fc3ViY2xhc3NjaGVja19fOnskbWV0aChiKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpc3N1YmNsYXNzKCkgYXJndW1lbnQgMiBjYW5ub3QgYmUgYSBwYXJhbWV0ZXJpemVkIGdlbmVyaWNcIik7fSwkZmxhZ3M6e09uZUFyZzohMH19fSxnZXRzZXRzOntfX3BhcmFtZXRlcnNfXzp7JGdldCgpe251bGw9PT10aGlzLiRwYXJhbXMmJnRoaXMubWskcGFyYW1zKCk7cmV0dXJuIHRoaXMuJHBhcmFtc30sXG4kZG9jOlwiVHlwZSB2YXJpYWJsZXMgaW4gdGhlIEdlbmVyaWNBbGlhcy5cIn0sX19vcmlnaW5fXzp7JGdldCgpe3JldHVybiB0aGlzLiRvcmlnaW59fSxfX2FyZ3NfXzp7JGdldCgpe3JldHVybiB0aGlzLiRhcmdzfX19LHByb3RvOnttayRwYXJhbXMoKXtjb25zdCBiPVtdO3RoaXMuJGFyZ3Mudi5mb3JFYWNoKGY9Pnt0aGlzLmlzJHR5cGV2YXIoZikmJjA+dGhpcy50dXBsZSRpbmRleChiLGYpJiZiLnB1c2goZil9KTt0aGlzLiRwYXJhbXM9bmV3IFNrLmJ1aWx0aW4udHVwbGUoYil9LHR1cGxlJGluZGV4KGIsZil7cmV0dXJuIGIuaW5kZXhPZihmKX0saXMkdHlwZXZhcihiKXtpZihcIlR5cGVWYXJcIiE9PWIudHAkbmFtZSlyZXR1cm4hMTtiPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYixTay5idWlsdGluLnN0ci4kbW9kdWxlKTtpZih2b2lkIDA9PT1iKXRocm93IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKFwiZm91bmQgb2JqZWN0IHdpdGhvdWdodCBhIF9fbW9kdWxlX19cIik7cmV0dXJuXCJ0eXBpbmdcIj09PVxuYi50b1N0cmluZygpfSxnYSRyZXByKGIpe2lmKGI9PT1Tay5idWlsdGluLkVsbGlwc2lzKXJldHVyblwiLi4uXCI7aWYoU2suYWJzdHIubG9va3VwU3BlY2lhbChiLHRoaXMuc3RyJG9yaWcpJiZTay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsdGhpcy5zdHIkYXJncykpcmV0dXJuIFNrLm1pc2NldmFsLm9iamVjdFJlcHIoYik7Y29uc3QgZj1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsU2suYnVpbHRpbi5zdHIuJHF1YWxuYW1lKTtpZih2b2lkIDA9PT1mKXJldHVybiBTay5taXNjZXZhbC5vYmplY3RSZXByKGIpO2NvbnN0IGU9U2suYWJzdHIubG9va3VwU3BlY2lhbChiLFNrLmJ1aWx0aW4uc3RyLiRtb2R1bGUpO3JldHVybiB2b2lkIDA9PT1lfHxTay5idWlsdGluLmNoZWNrTm9uZShlKT9Tay5taXNjZXZhbC5vYmplY3RSZXByKGIpOlwiYnVpbHRpbnNcIj09PWUudG9TdHJpbmcoKT9mLnRvU3RyaW5nKCk6ZS50b1N0cmluZygpK1wiLlwiK2YudG9TdHJpbmcoKX0sc3RyJG9yaWc6bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19vcmlnaW5fX1wiKSxcbnN0ciRhcmdzOm5ldyBTay5idWlsdGluLnN0cihcIl9fYXJnc19fXCIpLGF0dHIkZXhjOlwiX19vcmlnaW5fXyBfX2FyZ3NfXyBfX3BhcmFtZXRlcnNfXyBfX21yb19lbnRyaWVzX18gX19yZWR1Y2VfZXhfXyBfX3JlZHVjZV9fXCIuc3BsaXQoXCIgXCIpLm1hcChiPT5uZXcgU2suYnVpbHRpbi5zdHIoYikpfX0pfSxmdW5jdGlvbihFLFEpe2Z1bmN0aW9uIGIoZyxrKXtsZXQgcD12b2lkIDA7aWYodm9pZCAwPT09Z3x8U2suYnVpbHRpbi5jaGVja05vbmUoZykpZz12b2lkIDA7ZWxzZSBpZihnIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXA9e30sZy4kaXRlbXMoKS5mb3JFYWNoKGg9Pnt2YXIgW2EsY109aDtTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpJiYocFthLiRtYW5nbGVkXT1jKX0pO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGsrXCIgbXVzdCBiZSBhIGRpY3Qgb3IgTm9uZSwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGcpKTtyZXR1cm4gcH1mdW5jdGlvbiBmKGcsXG5rKXtpZih2b2lkIDAhPT1nJiYhU2suYnVpbHRpbi5jaGVja05vbmUoZykpZm9yKGxldCBwIGluIGspZy5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihTay51bmZpeFJlc2VydmVkKHApKSxrW3BdKX1Tay5idWlsdGlucz17cm91bmQ6bnVsbCxsZW46bnVsbCxtaW46bnVsbCxtYXg6bnVsbCxzdW06bnVsbCxhYnM6bnVsbCxmYWJzOm51bGwsb3JkOm51bGwsY2hyOm51bGwsaGV4Om51bGwsb2N0Om51bGwsYmluOm51bGwsZGlyOm51bGwscmVwcjpudWxsLG9wZW46bnVsbCxpc2luc3RhbmNlOm51bGwsaGFzaDpudWxsLGdldGF0dHI6bnVsbCxoYXNhdHRyOm51bGwsaWQ6bnVsbCxzb3J0ZWQ6bnVsbCxhbnk6bnVsbCxhbGw6bnVsbCxlbnVtZXJhdGU6U2suYnVpbHRpbi5lbnVtZXJhdGUsZmlsdGVyOlNrLmJ1aWx0aW4uZmlsdGVyXyxtYXA6U2suYnVpbHRpbi5tYXBfLHJhbmdlOlNrLmJ1aWx0aW4ucmFuZ2VfLHJldmVyc2VkOlNrLmJ1aWx0aW4ucmV2ZXJzZWQsemlwOlNrLmJ1aWx0aW4uemlwXyxcbkJhc2VFeGNlcHRpb246U2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uLEF0dHJpYnV0ZUVycm9yOlNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IsVmFsdWVFcnJvcjpTay5idWlsdGluLlZhbHVlRXJyb3IsRXhjZXB0aW9uOlNrLmJ1aWx0aW4uRXhjZXB0aW9uLFplcm9EaXZpc2lvbkVycm9yOlNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IsQXNzZXJ0aW9uRXJyb3I6U2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcixJbXBvcnRFcnJvcjpTay5idWlsdGluLkltcG9ydEVycm9yLE1vZHVsZU5vdEZvdW5kRXJyb3I6U2suYnVpbHRpbi5Nb2R1bGVOb3RGb3VuZEVycm9yLEluZGVudGF0aW9uRXJyb3I6U2suYnVpbHRpbi5JbmRlbnRhdGlvbkVycm9yLEluZGV4RXJyb3I6U2suYnVpbHRpbi5JbmRleEVycm9yLExvb2t1cEVycm9yOlNrLmJ1aWx0aW4uTG9va3VwRXJyb3IsS2V5RXJyb3I6U2suYnVpbHRpbi5LZXlFcnJvcixUeXBlRXJyb3I6U2suYnVpbHRpbi5UeXBlRXJyb3IsVW5pY29kZURlY29kZUVycm9yOlNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yLFxuVW5pY29kZUVuY29kZUVycm9yOlNrLmJ1aWx0aW4uVW5pY29kZUVuY29kZUVycm9yLE5hbWVFcnJvcjpTay5idWlsdGluLk5hbWVFcnJvcixVbmJvdW5kTG9jYWxFcnJvcjpTay5idWlsdGluLlVuYm91bmRMb2NhbEVycm9yLElPRXJyb3I6U2suYnVpbHRpbi5JT0Vycm9yLE5vdEltcGxlbWVudGVkRXJyb3I6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yLFN5c3RlbUV4aXQ6U2suYnVpbHRpbi5TeXN0ZW1FeGl0LE92ZXJmbG93RXJyb3I6U2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yLE9wZXJhdGlvbkVycm9yOlNrLmJ1aWx0aW4uT3BlcmF0aW9uRXJyb3IsTmVnYXRpdmVQb3dlckVycm9yOlNrLmJ1aWx0aW4uTmVnYXRpdmVQb3dlckVycm9yLFJ1bnRpbWVFcnJvcjpTay5idWlsdGluLlJ1bnRpbWVFcnJvcixSZWN1cnNpb25FcnJvcjpTay5idWlsdGluLlJlY3Vyc2lvbkVycm9yLFN0b3BJdGVyYXRpb246U2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uLFN5bnRheEVycm9yOlNrLmJ1aWx0aW4uU3ludGF4RXJyb3IsXG5TeXN0ZW1FcnJvcjpTay5idWlsdGluLlN5c3RlbUVycm9yLEtleWJvYXJkSW50ZXJydXB0OlNrLmJ1aWx0aW4uS2V5Ym9hcmRJbnRlcnJ1cHQsZmxvYXRfJHJ3JDpTay5idWlsdGluLmZsb2F0XyxpbnRfJHJ3JDpTay5idWlsdGluLmludF8sYm9vbDpTay5idWlsdGluLmJvb2wsY29tcGxleDpTay5idWlsdGluLmNvbXBsZXgsZGljdDpTay5idWlsdGluLmRpY3QsZmlsZTpTay5idWlsdGluLmZpbGUsZnJvemVuc2V0OlNrLmJ1aWx0aW4uZnJvemVuc2V0LFwiZnVuY3Rpb25cIjpTay5idWlsdGluLmZ1bmMsZ2VuZXJhdG9yOlNrLmJ1aWx0aW4uZ2VuZXJhdG9yLGxpc3Q6U2suYnVpbHRpbi5saXN0LGxvbmdfJHJ3JDpTay5idWlsdGluLmxuZyxtZXRob2Q6U2suYnVpbHRpbi5tZXRob2Qsb2JqZWN0OlNrLmJ1aWx0aW4ub2JqZWN0LHNsaWNlOlNrLmJ1aWx0aW4uc2xpY2Usc3RyOlNrLmJ1aWx0aW4uc3RyLHNldDpTay5idWlsdGluLnNldCx0dXBsZTpTay5idWlsdGluLnR1cGxlLHR5cGU6U2suYnVpbHRpbi50eXBlLFxuaW5wdXQ6bnVsbCxyYXdfaW5wdXQ6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnJhd19pbnB1dCksc2V0YXR0cjpudWxsLGpzZXZhbDpTay5idWlsdGluLmpzZXZhbCxqc21pbGxpczpTay5idWlsdGluLmpzbWlsbGlzLHF1aXQ6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnF1aXQpLGV4aXQ6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnF1aXQpLHByaW50Om51bGwsZGl2bW9kOm51bGwsZm9ybWF0Om51bGwsZ2xvYmFsczpudWxsLGlzc3ViY2xhc3M6bnVsbCxpdGVyOm51bGwsZXhlY2ZpbGU6U2suYnVpbHRpbi5leGVjZmlsZSxoZWxwOlNrLmJ1aWx0aW4uaGVscCxtZW1vcnl2aWV3OlNrLmJ1aWx0aW4ubWVtb3J5dmlldyxyZWxvYWQ6U2suYnVpbHRpbi5yZWxvYWQsc3VwZXJfJHJ3JDpTay5idWlsdGluLnN1cGVyXyx1bmljaHI6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnVuaWNociksdmFyczpTay5idWlsdGluLnZhcnMsYXBwbHlfJHJ3JDpTay5idWlsdGluLmFwcGx5XyxcbmJ1ZmZlcjpTay5idWlsdGluLmJ1ZmZlcixjb2VyY2U6U2suYnVpbHRpbi5jb2VyY2UsaW50ZXJuOlNrLmJ1aWx0aW4uaW50ZXJuLHByb3BlcnR5OlNrLmJ1aWx0aW4ucHJvcGVydHksY2xhc3NtZXRob2Q6U2suYnVpbHRpbi5jbGFzc21ldGhvZCxzdGF0aWNtZXRob2Q6U2suYnVpbHRpbi5zdGF0aWNtZXRob2QsRWxsaXBzaXM6U2suYnVpbHRpbi5FbGxpcHNpc307RT1Tay5idWlsdGluLm5vbmUubm9uZSQ7UT1uZXcgU2suYnVpbHRpbi50dXBsZTtjb25zdCBlPW5ldyBTay5idWlsdGluLmludF8oMCk7U2suYWJzdHIuc2V0VXBNb2R1bGVNZXRob2RzKFwiYnVpbHRpbnNcIixTay5idWlsdGlucyx7X19pbXBvcnRfXzp7JG1ldGgoZyxrLHAsaCxhKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhnKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2ltcG9ydF9fKCkgYXJndW1lbnQgMSBtdXN0IGJlIHN0ciwgbm90IFwiK2cudHAkbmFtZSk7aWYoZz09PVNrLmJ1aWx0aW4uc3RyLiRlbXB0eSYmXG4wPT09YS52KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJFbXB0eSBtb2R1bGUgbmFtZVwiKTtrPWIoayxcImdsb2JhbHNcIil8fHt9O2g9U2suZmZpLnJlbWFwVG9KcyhoKTthPVNrLmZmaS5yZW1hcFRvSnMoYSk7cmV0dXJuIFNrLmJ1aWx0aW4uX19pbXBvcnRfXyhnLGssdm9pZCAwLGgsYSl9LCRmbGFnczp7TmFtZWRBcmdzOltcIm5hbWVcIixcImdsb2JhbHNcIixcImxvY2Fsc1wiLFwiZnJvbWxpc3RcIixcImxldmVsXCJdLERlZmF1bHRzOltFLEUsUSxlXX0sJHRleHRzaWc6bnVsbCwkZG9jOlwiX19pbXBvcnRfXyhuYW1lLCBnbG9iYWxzPU5vbmUsIGxvY2Fscz1Ob25lLCBmcm9tbGlzdD0oKSwgbGV2ZWw9MCkgLT4gbW9kdWxlXFxuXFxuSW1wb3J0IGEgbW9kdWxlLiBCZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgZm9yIHVzZSBieSB0aGUgUHl0aG9uXFxuaW50ZXJwcmV0ZXIgYW5kIG5vdCBmb3IgZ2VuZXJhbCB1c2UsIGl0IGlzIGJldHRlciB0byB1c2VcXG5pbXBvcnRsaWIuaW1wb3J0X21vZHVsZSgpIHRvIHByb2dyYW1tYXRpY2FsbHkgaW1wb3J0IGEgbW9kdWxlLlxcblxcblRoZSBnbG9iYWxzIGFyZ3VtZW50IGlzIG9ubHkgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNvbnRleHQ7XFxudGhleSBhcmUgbm90IG1vZGlmaWVkLiAgVGhlIGxvY2FscyBhcmd1bWVudCBpcyB1bnVzZWQuICBUaGUgZnJvbWxpc3RcXG5zaG91bGQgYmUgYSBsaXN0IG9mIG5hbWVzIHRvIGVtdWxhdGUgYGBmcm9tIG5hbWUgaW1wb3J0IC4uLicnLCBvciBhblxcbmVtcHR5IGxpc3QgdG8gZW11bGF0ZSBgYGltcG9ydCBuYW1lJycuXFxuV2hlbiBpbXBvcnRpbmcgYSBtb2R1bGUgZnJvbSBhIHBhY2thZ2UsIG5vdGUgdGhhdCBfX2ltcG9ydF9fKCdBLkInLCAuLi4pXFxucmV0dXJucyBwYWNrYWdlIEEgd2hlbiBmcm9tbGlzdCBpcyBlbXB0eSwgYnV0IGl0cyBzdWJtb2R1bGUgQiB3aGVuXFxuZnJvbWxpc3QgaXMgbm90IGVtcHR5LiAgVGhlIGxldmVsIGFyZ3VtZW50IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG9cXG5wZXJmb3JtIGFic29sdXRlIG9yIHJlbGF0aXZlIGltcG9ydHM6IDAgaXMgYWJzb2x1dGUsIHdoaWxlIGEgcG9zaXRpdmUgbnVtYmVyXFxuaXMgdGhlIG51bWJlciBvZiBwYXJlbnQgZGlyZWN0b3JpZXMgdG8gc2VhcmNoIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IG1vZHVsZS5cIn0sXG5hYnM6eyRtZXRoOlNrLmJ1aWx0aW4uYWJzLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB4LCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBhcmd1bWVudC5cIn0sYWxsOnskbWV0aDpTay5idWlsdGluLmFsbCwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaXRlcmFibGUsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIGJvb2woeCkgaXMgVHJ1ZSBmb3IgYWxsIHZhbHVlcyB4IGluIHRoZSBpdGVyYWJsZS5cXG5cXG5JZiB0aGUgaXRlcmFibGUgaXMgZW1wdHksIHJldHVybiBUcnVlLlwifSxhbnk6eyRtZXRoOlNrLmJ1aWx0aW4uYW55LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBpdGVyYWJsZSwgLylcIiwkZG9jOlwiUmV0dXJuIFRydWUgaWYgYm9vbCh4KSBpcyBUcnVlIGZvciBhbnkgeCBpbiB0aGUgaXRlcmFibGUuXFxuXFxuSWYgdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCByZXR1cm4gRmFsc2UuXCJ9LFxuYXNjaWk6eyRtZXRoOlNrLmJ1aWx0aW4uYXNjaWksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIGFuIEFTQ0lJLW9ubHkgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxcblxcbkFzIHJlcHIoKSwgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYW5cXG5vYmplY3QsIGJ1dCBlc2NhcGUgdGhlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgcmV0dXJuZWQgYnlcXG5yZXByKCkgdXNpbmcgXFxcXFxcXFx4LCBcXFxcXFxcXHUgb3IgXFxcXFxcXFxVIGVzY2FwZXMuIFRoaXMgZ2VuZXJhdGVzIGEgc3RyaW5nIHNpbWlsYXJcXG50byB0aGF0IHJldHVybmVkIGJ5IHJlcHIoKSBpbiBQeXRob24gMi5cIn0sYmluOnskbWV0aDpTay5idWlsdGluLmJpbiwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgbnVtYmVyLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxcblxcbiAgID4+PiBiaW4oMjc5NjIwMilcXG4gICAnMGIxMDEwMTAxMDEwMTAxMDEwMTAxMDEwJ1wifSxcbmNhbGxhYmxlOnskbWV0aDpTay5idWlsdGluLmNhbGxhYmxlLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiB3aGV0aGVyIHRoZSBvYmplY3QgaXMgY2FsbGFibGUgKGkuZS4sIHNvbWUga2luZCBvZiBmdW5jdGlvbikuXFxuXFxuTm90ZSB0aGF0IGNsYXNzZXMgYXJlIGNhbGxhYmxlLCBhcyBhcmUgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBhXFxuX19jYWxsX18oKSBtZXRob2QuXCJ9LGNocjp7JG1ldGg6U2suYnVpbHRpbi5jaHIsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGksIC8pXCIsJGRvYzpcIlJldHVybiBhIFVuaWNvZGUgc3RyaW5nIG9mIG9uZSBjaGFyYWN0ZXIgd2l0aCBvcmRpbmFsIGk7IDAgPD0gaSA8PSAweDEwZmZmZi5cIn0sY29tcGlsZTp7JG1ldGg6U2suYnVpbHRpbi5jb21waWxlLCRmbGFnczp7TWluQXJnczozLE1heEFyZ3M6Nn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgLywgc291cmNlLCBmaWxlbmFtZSwgbW9kZSwgZmxhZ3M9MCxcXG4gICAgICAgIGRvbnRfaW5oZXJpdD1GYWxzZSwgb3B0aW1pemU9LTEpXCIsXG4kZG9jOlwiQ29tcGlsZSBzb3VyY2UgaW50byBhIGNvZGUgb2JqZWN0IHRoYXQgY2FuIGJlIGV4ZWN1dGVkIGJ5IGV4ZWMoKSBvciBldmFsKCkuXFxuXFxuVGhlIHNvdXJjZSBjb2RlIG1heSByZXByZXNlbnQgYSBQeXRob24gbW9kdWxlLCBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbi5cXG5UaGUgZmlsZW5hbWUgd2lsbCBiZSB1c2VkIGZvciBydW4tdGltZSBlcnJvciBtZXNzYWdlcy5cXG5UaGUgbW9kZSBtdXN0IGJlICdleGVjJyB0byBjb21waWxlIGEgbW9kdWxlLCAnc2luZ2xlJyB0byBjb21waWxlIGFcXG5zaW5nbGUgKGludGVyYWN0aXZlKSBzdGF0ZW1lbnQsIG9yICdldmFsJyB0byBjb21waWxlIGFuIGV4cHJlc3Npb24uXFxuVGhlIGZsYWdzIGFyZ3VtZW50LCBpZiBwcmVzZW50LCBjb250cm9scyB3aGljaCBmdXR1cmUgc3RhdGVtZW50cyBpbmZsdWVuY2VcXG50aGUgY29tcGlsYXRpb24gb2YgdGhlIGNvZGUuXFxuVGhlIGRvbnRfaW5oZXJpdCBhcmd1bWVudCwgaWYgdHJ1ZSwgc3RvcHMgdGhlIGNvbXBpbGF0aW9uIGluaGVyaXRpbmdcXG50aGUgZWZmZWN0cyBvZiBhbnkgZnV0dXJlIHN0YXRlbWVudHMgaW4gZWZmZWN0IGluIHRoZSBjb2RlIGNhbGxpbmdcXG5jb21waWxlOyBpZiBhYnNlbnQgb3IgZmFsc2UgdGhlc2Ugc3RhdGVtZW50cyBkbyBpbmZsdWVuY2UgdGhlIGNvbXBpbGF0aW9uLFxcbmluIGFkZGl0aW9uIHRvIGFueSBmZWF0dXJlcyBleHBsaWNpdGx5IHNwZWNpZmllZC5cIn0sXG5kZWxhdHRyOnskbWV0aDpTay5idWlsdGluLmRlbGF0dHIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIG5hbWUsIC8pXCIsJGRvYzpcIkRlbGV0ZXMgdGhlIG5hbWVkIGF0dHJpYnV0ZSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXFxuXFxuZGVsYXR0cih4LCAneScpIGlzIGVxdWl2YWxlbnQgdG8gYGBkZWwgeC55JydcIn0sZGlyOnskbWV0aDpTay5idWlsdGluLmRpciwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOm51bGwsJGRvYzpcImRpcihbb2JqZWN0XSkgLT4gbGlzdCBvZiBzdHJpbmdzXFxuXFxuSWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHJldHVybiB0aGUgbmFtZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUuXFxuRWxzZSwgcmV0dXJuIGFuIGFscGhhYmV0aXplZCBsaXN0IG9mIG5hbWVzIGNvbXByaXNpbmcgKHNvbWUgb2YpIHRoZSBhdHRyaWJ1dGVzXFxub2YgdGhlIGdpdmVuIG9iamVjdCwgYW5kIG9mIGF0dHJpYnV0ZXMgcmVhY2hhYmxlIGZyb20gaXQuXFxuSWYgdGhlIG9iamVjdCBzdXBwbGllcyBhIG1ldGhvZCBuYW1lZCBfX2Rpcl9fLCBpdCB3aWxsIGJlIHVzZWQ7IG90aGVyd2lzZVxcbnRoZSBkZWZhdWx0IGRpcigpIGxvZ2ljIGlzIHVzZWQgYW5kIHJldHVybnM6XFxuICBmb3IgYSBtb2R1bGUgb2JqZWN0OiB0aGUgbW9kdWxlJ3MgYXR0cmlidXRlcy5cXG4gIGZvciBhIGNsYXNzIG9iamVjdDogIGl0cyBhdHRyaWJ1dGVzLCBhbmQgcmVjdXJzaXZlbHkgdGhlIGF0dHJpYnV0ZXNcXG4gICAgb2YgaXRzIGJhc2VzLlxcbiAgZm9yIGFueSBvdGhlciBvYmplY3Q6IGl0cyBhdHRyaWJ1dGVzLCBpdHMgY2xhc3MncyBhdHRyaWJ1dGVzLCBhbmRcXG4gICAgcmVjdXJzaXZlbHkgdGhlIGF0dHJpYnV0ZXMgb2YgaXRzIGNsYXNzJ3MgYmFzZSBjbGFzc2VzLlwifSxcbmRpdm1vZDp7JG1ldGg6U2suYnVpbHRpbi5kaXZtb2QsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB4LCB5LCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIHR1cGxlICh4Ly95LCB4JXkpLiAgSW52YXJpYW50OiBkaXYqeSArIG1vZCA9PSB4LlwifSxldmFsXyRydyQ6eyRuYW1lOlwiZXZhbFwiLCRtZXRoOmZ1bmN0aW9uKGcsayxwKXtjb25zdCBoPWIoayxcImdsb2JhbHNcIiksYT1iKHAsXCJsb2NhbHNcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmJ1aWx0aW4uZXZhbChnLGgsYSksYz0+e2YoayxoKTtmKHAsYSk7cmV0dXJuIGN9KX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBzb3VyY2UsIGdsb2JhbHM9Tm9uZSwgbG9jYWxzPU5vbmUsIC8pXCIsJGRvYzpcIkV2YWx1YXRlIHRoZSBnaXZlbiBzb3VyY2UgaW4gdGhlIGNvbnRleHQgb2YgZ2xvYmFscyBhbmQgbG9jYWxzLlxcblxcblRoZSBzb3VyY2UgbWF5IGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFB5dGhvbiBleHByZXNzaW9uXFxub3IgYSBjb2RlIG9iamVjdCBhcyByZXR1cm5lZCBieSBjb21waWxlKCkuXFxuVGhlIGdsb2JhbHMgbXVzdCBiZSBhIGRpY3Rpb25hcnkgYW5kIGxvY2FscyBjYW4gYmUgYW55IG1hcHBpbmcsXFxuZGVmYXVsdGluZyB0byB0aGUgY3VycmVudCBnbG9iYWxzIGFuZCBsb2NhbHMuXFxuSWYgb25seSBnbG9iYWxzIGlzIGdpdmVuLCBsb2NhbHMgZGVmYXVsdHMgdG8gaXQuXCJ9LFxuZXhlYzp7JG1ldGg6ZnVuY3Rpb24oZyxrLHApe2NvbnN0IGg9YihrLFwiZ2xvYmFsc1wiKSxhPWIocCxcImxvY2Fsc1wiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suYnVpbHRpbi5leGVjKGcsaCxhKSxjPT57ZihrLGgpO2YocCxhKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJG1vZHVsZSwgc291cmNlLCBnbG9iYWxzPU5vbmUsIGxvY2Fscz1Ob25lLCAvKVwiLCRkb2M6XCJFeGVjdXRlIHRoZSBnaXZlbiBzb3VyY2UgaW4gdGhlIGNvbnRleHQgb2YgZ2xvYmFscyBhbmQgbG9jYWxzLlxcblxcblRoZSBzb3VyY2UgbWF5IGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBvbmUgb3IgbW9yZSBQeXRob24gc3RhdGVtZW50c1xcbm9yIGEgY29kZSBvYmplY3QgYXMgcmV0dXJuZWQgYnkgY29tcGlsZSgpLlxcblRoZSBnbG9iYWxzIG11c3QgYmUgYSBkaWN0aW9uYXJ5IGFuZCBsb2NhbHMgY2FuIGJlIGFueSBtYXBwaW5nLFxcbmRlZmF1bHRpbmcgdG8gdGhlIGN1cnJlbnQgZ2xvYmFscyBhbmQgbG9jYWxzLlxcbklmIG9ubHkgZ2xvYmFscyBpcyBnaXZlbiwgbG9jYWxzIGRlZmF1bHRzIHRvIGl0LlwifSxcbmZvcm1hdDp7JG1ldGg6U2suYnVpbHRpbi5mb3JtYXQsJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB2YWx1ZSwgZm9ybWF0X3NwZWM9JycsIC8pXCIsJGRvYzpcIlJldHVybiB2YWx1ZS5fX2Zvcm1hdF9fKGZvcm1hdF9zcGVjKVxcblxcbmZvcm1hdF9zcGVjIGRlZmF1bHRzIHRvIHRoZSBlbXB0eSBzdHJpbmcuXFxuU2VlIHRoZSBGb3JtYXQgU3BlY2lmaWNhdGlvbiBNaW5pLUxhbmd1YWdlIHNlY3Rpb24gb2YgaGVscCgnRk9STUFUVElORycpIGZvclxcbmRldGFpbHMuXCJ9LGdldGF0dHI6eyRtZXRoOlNrLmJ1aWx0aW4uZ2V0YXR0ciwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcImdldGF0dHIob2JqZWN0LCBuYW1lWywgZGVmYXVsdF0pIC0+IHZhbHVlXFxuXFxuR2V0IGEgbmFtZWQgYXR0cmlidXRlIGZyb20gYW4gb2JqZWN0OyBnZXRhdHRyKHgsICd5JykgaXMgZXF1aXZhbGVudCB0byB4LnkuXFxuV2hlbiBhIGRlZmF1bHQgYXJndW1lbnQgaXMgZ2l2ZW4sIGl0IGlzIHJldHVybmVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBkb2Vzbid0XFxuZXhpc3Q7IHdpdGhvdXQgaXQsIGFuIGV4Y2VwdGlvbiBpcyByYWlzZWQgaW4gdGhhdCBjYXNlLlwifSxcbmdsb2JhbHM6eyRtZXRoOlNrLmJ1aWx0aW4uZ2xvYmFscywkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2NvcGUncyBnbG9iYWwgdmFyaWFibGVzLlxcblxcbk5PVEU6IFVwZGF0ZXMgdG8gdGhpcyBkaWN0aW9uYXJ5ICp3aWxsKiBhZmZlY3QgbmFtZSBsb29rdXBzIGluIHRoZSBjdXJyZW50XFxuZ2xvYmFsIHNjb3BlIGFuZCB2aWNlLXZlcnNhLlwifSxoYXNhdHRyOnskbWV0aDpTay5idWlsdGluLmhhc2F0dHIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIG5hbWUsIC8pXCIsJGRvYzpcIlJldHVybiB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxcblxcblRoaXMgaXMgZG9uZSBieSBjYWxsaW5nIGdldGF0dHIob2JqLCBuYW1lKSBhbmQgY2F0Y2hpbmcgQXR0cmlidXRlRXJyb3IuXCJ9LFxuaGFzaDp7JG1ldGg6U2suYnVpbHRpbi5oYXNoLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgaGFzaCB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9iamVjdC5cXG5cXG5Ud28gb2JqZWN0cyB0aGF0IGNvbXBhcmUgZXF1YWwgbXVzdCBhbHNvIGhhdmUgdGhlIHNhbWUgaGFzaCB2YWx1ZSwgYnV0IHRoZVxcbnJldmVyc2UgaXMgbm90IG5lY2Vzc2FyaWx5IHRydWUuXCJ9LGhleDp7JG1ldGg6U2suYnVpbHRpbi5oZXgsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG51bWJlciwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxcblxcbiAgID4+PiBoZXgoMTI2NDg0MzApXFxuICAgJzB4YzBmZmVlJ1wifSxpZDp7JG1ldGg6U2suYnVpbHRpbi5pZCwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgb2JqLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGlkZW50aXR5IG9mIGFuIG9iamVjdC5cXG5cXG5UaGlzIGlzIGd1YXJhbnRlZWQgdG8gYmUgdW5pcXVlIGFtb25nIHNpbXVsdGFuZW91c2x5IGV4aXN0aW5nIG9iamVjdHMuXFxuKENQeXRob24gdXNlcyB0aGUgb2JqZWN0J3MgbWVtb3J5IGFkZHJlc3MuKVwifSxcbmlucHV0OnskbWV0aDpTay5idWlsdGluLmlucHV0LCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6XCIoJG1vZHVsZSwgcHJvbXB0PU5vbmUsIC8pXCIsJGRvYzpcIlJlYWQgYSBzdHJpbmcgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIFRoZSB0cmFpbGluZyBuZXdsaW5lIGlzIHN0cmlwcGVkLlxcblxcblRoZSBwcm9tcHQgc3RyaW5nLCBpZiBnaXZlbiwgaXMgcHJpbnRlZCB0byBzdGFuZGFyZCBvdXRwdXQgd2l0aG91dCBhXFxudHJhaWxpbmcgbmV3bGluZSBiZWZvcmUgcmVhZGluZyBpbnB1dC5cXG5cXG5JZiB0aGUgdXNlciBoaXRzIEVPRiAoKm5peDogQ3RybC1ELCBXaW5kb3dzOiBDdHJsLVorUmV0dXJuKSwgcmFpc2UgRU9GRXJyb3IuXFxuT24gKm5peCBzeXN0ZW1zLCByZWFkbGluZSBpcyB1c2VkIGlmIGF2YWlsYWJsZS5cIn0saXNpbnN0YW5jZTp7JG1ldGg6U2suYnVpbHRpbi5pc2luc3RhbmNlLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgb2JqLCBjbGFzc19vcl90dXBsZSwgLylcIixcbiRkb2M6XCJSZXR1cm4gd2hldGhlciBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyBvciBvZiBhIHN1YmNsYXNzIHRoZXJlb2YuXFxuXFxuQSB0dXBsZSwgYXMgaW4gYGBpc2luc3RhbmNlKHgsIChBLCBCLCAuLi4pKWBgLCBtYXkgYmUgZ2l2ZW4gYXMgdGhlIHRhcmdldCB0b1xcbmNoZWNrIGFnYWluc3QuIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgYGlzaW5zdGFuY2UoeCwgQSkgb3IgaXNpbnN0YW5jZSh4LCBCKVxcbm9yIC4uLmBgIGV0Yy5cIn0saXNzdWJjbGFzczp7JG1ldGg6U2suYnVpbHRpbi5pc3N1YmNsYXNzLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgY2xzLCBjbGFzc19vcl90dXBsZSwgLylcIiwkZG9jOlwiUmV0dXJuIHdoZXRoZXIgJ2NscycgaXMgYSBkZXJpdmVkIGZyb20gYW5vdGhlciBjbGFzcyBvciBpcyB0aGUgc2FtZSBjbGFzcy5cXG5cXG5BIHR1cGxlLCBhcyBpbiBgYGlzc3ViY2xhc3MoeCwgKEEsIEIsIC4uLikpYGAsIG1heSBiZSBnaXZlbiBhcyB0aGUgdGFyZ2V0IHRvXFxuY2hlY2sgYWdhaW5zdC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBgaXNzdWJjbGFzcyh4LCBBKSBvciBpc3N1YmNsYXNzKHgsIEIpXFxub3IgLi4uYGAgZXRjLlwifSxcbml0ZXI6eyRtZXRoOlNrLmJ1aWx0aW4uaXRlciwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGl0ZXJhYmxlIC8pXCIsJGRvYzpcIml0ZXIoaXRlcmFibGUpIC0+IGl0ZXJhdG9yXFxuaXRlcihjYWxsYWJsZSwgc2VudGluZWwpIC0+IGl0ZXJhdG9yXFxuXFxuR2V0IGFuIGl0ZXJhdG9yIGZyb20gYW4gb2JqZWN0LiAgSW4gdGhlIGZpcnN0IGZvcm0sIHRoZSBhcmd1bWVudCBtdXN0XFxuc3VwcGx5IGl0cyBvd24gaXRlcmF0b3IsIG9yIGJlIGEgc2VxdWVuY2UuXFxuSW4gdGhlIHNlY29uZCBmb3JtLCB0aGUgY2FsbGFibGUgaXMgY2FsbGVkIHVudGlsIGl0IHJldHVybnMgdGhlIHNlbnRpbmVsLlwifSxsZW46eyRtZXRoOlNrLmJ1aWx0aW4ubGVuLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIGEgY29udGFpbmVyLlwifSxsb2NhbHM6eyRtZXRoOlNrLmJ1aWx0aW4ubG9jYWxzLFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIC8pXCIsJGRvYzpcIlJldHVybiBhIGRpY3Rpb25hcnkgY29udGFpbmluZyB0aGUgY3VycmVudCBzY29wZSdzIGxvY2FsIHZhcmlhYmxlcy5cXG5cXG5OT1RFOiBXaGV0aGVyIG9yIG5vdCB1cGRhdGVzIHRvIHRoaXMgZGljdGlvbmFyeSB3aWxsIGFmZmVjdCBuYW1lIGxvb2t1cHMgaW5cXG50aGUgbG9jYWwgc2NvcGUgYW5kIHZpY2UtdmVyc2EgaXMgKmltcGxlbWVudGF0aW9uIGRlcGVuZGVudCogYW5kIG5vdFxcbmNvdmVyZWQgYnkgYW55IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGd1YXJhbnRlZXMuXCJ9LG1heDp7JG1ldGg6U2suYnVpbHRpbi5tYXgsJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwibWF4KGl0ZXJhYmxlLCAqWywgZGVmYXVsdD1vYmosIGtleT1mdW5jXSkgLT4gdmFsdWVcXG5tYXgoYXJnMSwgYXJnMiwgKmFyZ3MsICpbLCBrZXk9ZnVuY10pIC0+IHZhbHVlXFxuXFxuV2l0aCBhIHNpbmdsZSBpdGVyYWJsZSBhcmd1bWVudCwgcmV0dXJuIGl0cyBiaWdnZXN0IGl0ZW0uIFRoZVxcbmRlZmF1bHQga2V5d29yZC1vbmx5IGFyZ3VtZW50IHNwZWNpZmllcyBhbiBvYmplY3QgdG8gcmV0dXJuIGlmXFxudGhlIHByb3ZpZGVkIGl0ZXJhYmxlIGlzIGVtcHR5LlxcbldpdGggdHdvIG9yIG1vcmUgYXJndW1lbnRzLCByZXR1cm4gdGhlIGxhcmdlc3QgYXJndW1lbnQuXCJ9LFxubWluOnskbWV0aDpTay5idWlsdGluLm1pbiwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJtaW4oaXRlcmFibGUsICpbLCBkZWZhdWx0PW9iaiwga2V5PWZ1bmNdKSAtPiB2YWx1ZVxcbm1pbihhcmcxLCBhcmcyLCAqYXJncywgKlssIGtleT1mdW5jXSkgLT4gdmFsdWVcXG5cXG5XaXRoIGEgc2luZ2xlIGl0ZXJhYmxlIGFyZ3VtZW50LCByZXR1cm4gaXRzIHNtYWxsZXN0IGl0ZW0uIFRoZVxcbmRlZmF1bHQga2V5d29yZC1vbmx5IGFyZ3VtZW50IHNwZWNpZmllcyBhbiBvYmplY3QgdG8gcmV0dXJuIGlmXFxudGhlIHByb3ZpZGVkIGl0ZXJhYmxlIGlzIGVtcHR5LlxcbldpdGggdHdvIG9yIG1vcmUgYXJndW1lbnRzLCByZXR1cm4gdGhlIHNtYWxsZXN0IGFyZ3VtZW50LlwifSxuZXh0OnskbmFtZTpcIm5leHRcIiwkbWV0aDpTay5idWlsdGluLm5leHRfLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6bnVsbCwkZG9jOlwibmV4dChpdGVyYXRvclssIGRlZmF1bHRdKVxcblxcblJldHVybiB0aGUgbmV4dCBpdGVtIGZyb20gdGhlIGl0ZXJhdG9yLiBJZiBkZWZhdWx0IGlzIGdpdmVuIGFuZCB0aGUgaXRlcmF0b3JcXG5pcyBleGhhdXN0ZWQsIGl0IGlzIHJldHVybmVkIGluc3RlYWQgb2YgcmFpc2luZyBTdG9wSXRlcmF0aW9uLlwifSxcbm9jdDp7JG1ldGg6U2suYnVpbHRpbi5vY3QsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG51bWJlciwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBvY3RhbCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxcblxcbiAgID4+PiBvY3QoMzQyMzkxKVxcbiAgICcwbzEyMzQ1NjcnXCJ9LG9wZW46eyRtZXRoOlNrLmJ1aWx0aW4ub3BlbiwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIm9wZW4obmFtZVssIG1vZGVbLCBidWZmZXJpbmddXSkgLT4gZmlsZSBvYmplY3RcXG5cXG5PcGVuIGEgZmlsZSB1c2luZyB0aGUgZmlsZSgpIHR5cGUsIHJldHVybnMgYSBmaWxlIG9iamVjdC4gIFRoaXMgaXMgdGhlXFxucHJlZmVycmVkIHdheSB0byBvcGVuIGEgZmlsZS4gIFNlZSBmaWxlLl9fZG9jX18gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24uXCJ9LG9yZDp7JG1ldGg6U2suYnVpbHRpbi5vcmQsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGMsIC8pXCIsXG4kZG9jOlwiUmV0dXJuIHRoZSBVbmljb2RlIGNvZGUgcG9pbnQgZm9yIGEgb25lLWNoYXJhY3RlciBzdHJpbmcuXCJ9LHBvdzp7JG1ldGg6U2suYnVpbHRpbi5wb3csJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB4LCB5LCB6PU5vbmUsIC8pXCIsJGRvYzpcIkVxdWl2YWxlbnQgdG8geCoqeSAod2l0aCB0d28gYXJndW1lbnRzKSBvciB4Kip5ICUgeiAod2l0aCB0aHJlZSBhcmd1bWVudHMpXFxuXFxuU29tZSB0eXBlcywgc3VjaCBhcyBpbnRzLCBhcmUgYWJsZSB0byB1c2UgYSBtb3JlIGVmZmljaWVudCBhbGdvcml0aG0gd2hlblxcbmludm9rZWQgdXNpbmcgdGhlIHRocmVlIGFyZ3VtZW50IGZvcm0uXCJ9LHByaW50OnskbWV0aDpTay5idWlsdGluLnByaW50LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcInByaW50KHZhbHVlLCAuLi4sIHNlcD0nICcsIGVuZD0nXFxcXG4nLCBmaWxlPXN5cy5zdGRvdXQsIGZsdXNoPUZhbHNlKVxcblxcblByaW50cyB0aGUgdmFsdWVzIHRvIGEgc3RyZWFtLCBvciB0byBzeXMuc3Rkb3V0IGJ5IGRlZmF1bHQuXFxuT3B0aW9uYWwga2V5d29yZCBhcmd1bWVudHM6XFxuZmlsZTogIGEgZmlsZS1saWtlIG9iamVjdCAoc3RyZWFtKTsgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgc3lzLnN0ZG91dC5cXG5zZXA6ICAgc3RyaW5nIGluc2VydGVkIGJldHdlZW4gdmFsdWVzLCBkZWZhdWx0IGEgc3BhY2UuXFxuZW5kOiAgIHN0cmluZyBhcHBlbmRlZCBhZnRlciB0aGUgbGFzdCB2YWx1ZSwgZGVmYXVsdCBhIG5ld2xpbmUuXFxuZmx1c2g6IHdoZXRoZXIgdG8gZm9yY2libHkgZmx1c2ggdGhlIHN0cmVhbS5cIn0sXG5yZXByOnskbWV0aDpTay5idWlsdGluLnJlcHIsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBjYW5vbmljYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXFxuXFxuRm9yIG1hbnkgb2JqZWN0IHR5cGVzLCBpbmNsdWRpbmcgbW9zdCBidWlsdGlucywgZXZhbChyZXByKG9iaikpID09IG9iai5cIn0scm91bmQ6eyRtZXRoOlNrLmJ1aWx0aW4ucm91bmQsJGZsYWdzOntOYW1lZEFyZ3M6W1wibnVtYmVyXCIsXCJuZGlnaXRzXCJdfSwkdGV4dHNpZzpcIigkbW9kdWxlLCAvLCBudW1iZXIsIG5kaWdpdHM9Tm9uZSlcIiwkZG9jOlwiUm91bmQgYSBudW1iZXIgdG8gYSBnaXZlbiBwcmVjaXNpb24gaW4gZGVjaW1hbCBkaWdpdHMuXFxuXFxuVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGlmIG5kaWdpdHMgaXMgb21pdHRlZCBvciBOb25lLiAgT3RoZXJ3aXNlXFxudGhlIHJldHVybiB2YWx1ZSBoYXMgdGhlIHNhbWUgdHlwZSBhcyB0aGUgbnVtYmVyLiAgbmRpZ2l0cyBtYXkgYmUgbmVnYXRpdmUuXCJ9LFxuc2V0YXR0cjp7JG1ldGg6U2suYnVpbHRpbi5zZXRhdHRyLCRmbGFnczp7TWluQXJnczozLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJG1vZHVsZSwgb2JqLCBuYW1lLCB2YWx1ZSwgLylcIiwkZG9jOlwiU2V0cyB0aGUgbmFtZWQgYXR0cmlidXRlIG9uIHRoZSBnaXZlbiBvYmplY3QgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cXG5cXG5zZXRhdHRyKHgsICd5JywgdikgaXMgZXF1aXZhbGVudCB0byBgYHgueSA9IHYnJ1wifSxzb3J0ZWQ6eyRtZXRoOlNrLmJ1aWx0aW4uc29ydGVkLCRmbGFnczp7TmFtZWRBcmdzOltudWxsLFwiY21wXCIsXCJrZXlcIixcInJldmVyc2VcIl0sRGVmYXVsdHM6W1NrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ib29sLmZhbHNlJF19LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGl0ZXJhYmxlLCAvLCAqLCBrZXk9Tm9uZSwgcmV2ZXJzZT1GYWxzZSlcIiwkZG9jOlwiUmV0dXJuIGEgbmV3IGxpc3QgY29udGFpbmluZyBhbGwgaXRlbXMgZnJvbSB0aGUgaXRlcmFibGUgaW4gYXNjZW5kaW5nIG9yZGVyLlxcblxcbkEgY3VzdG9tIGtleSBmdW5jdGlvbiBjYW4gYmUgc3VwcGxpZWQgdG8gY3VzdG9taXplIHRoZSBzb3J0IG9yZGVyLCBhbmQgdGhlXFxucmV2ZXJzZSBmbGFnIGNhbiBiZSBzZXQgdG8gcmVxdWVzdCB0aGUgcmVzdWx0IGluIGRlc2NlbmRpbmcgb3JkZXIuXCJ9LFxuc3VtOnskbWV0aDpTay5idWlsdGluLnN1bSwkZmxhZ3M6e05hbWVkQXJnczpbbnVsbCxcInN0YXJ0XCJdLERlZmF1bHRzOltuZXcgU2suYnVpbHRpbi5pbnRfKDApXX0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaXRlcmFibGUsIC8sIHN0YXJ0PTApXCIsJGRvYzpcIlJldHVybiB0aGUgc3VtIG9mIGEgJ3N0YXJ0JyB2YWx1ZSAoZGVmYXVsdDogMCkgcGx1cyBhbiBpdGVyYWJsZSBvZiBudW1iZXJzXFxuXFxuV2hlbiB0aGUgaXRlcmFibGUgaXMgZW1wdHksIHJldHVybiB0aGUgc3RhcnQgdmFsdWUuXFxuVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCBzcGVjaWZpY2FsbHkgZm9yIHVzZSB3aXRoIG51bWVyaWMgdmFsdWVzIGFuZCBtYXlcXG5yZWplY3Qgbm9uLW51bWVyaWMgdHlwZXMuXCJ9LHZhcnM6eyRtZXRoOlNrLmJ1aWx0aW4udmFycywkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOm51bGwsJGRvYzpcInZhcnMoW29iamVjdF0pIC0+IGRpY3Rpb25hcnlcXG5cXG5XaXRob3V0IGFyZ3VtZW50cywgZXF1aXZhbGVudCB0byBsb2NhbHMoKS5cXG5XaXRoIGFuIGFyZ3VtZW50LCBlcXVpdmFsZW50IHRvIG9iamVjdC5fX2RpY3RfXy5cIn19KTtcblNrLnNldHVwT2JqZWN0cz1mdW5jdGlvbihnKXtnPyhTay5idWlsdGlucy5maWx0ZXI9U2suYnVpbHRpbi5maWx0ZXJfLFNrLmJ1aWx0aW5zLm1hcD1Tay5idWlsdGluLm1hcF8sU2suYnVpbHRpbnMuemlwPVNrLmJ1aWx0aW4uemlwXyxTay5idWlsdGlucy5yYW5nZT1Tay5idWlsdGluLnJhbmdlXyxkZWxldGUgU2suYnVpbHRpbnMucmVkdWNlLGRlbGV0ZSBTay5idWlsdGlucy54cmFuZ2UsZGVsZXRlIFNrLmJ1aWx0aW5zLlN0YW5kYXJkRXJyb3IsZGVsZXRlIFNrLmJ1aWx0aW5zLnVuaWNvZGUsZGVsZXRlIFNrLmJ1aWx0aW5zLmJhc2VzdHJpbmcsZGVsZXRlIFNrLmJ1aWx0aW5zLmxvbmdfJHJ3JCxTay5idWlsdGluLmludF8ucHJvdG90eXBlLiRyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYudG9TdHJpbmcoKSl9LGRlbGV0ZSBTay5idWlsdGluLmludF8ucHJvdG90eXBlLnRwJHN0cixkZWxldGUgU2suYnVpbHRpbi5ib29sLnByb3RvdHlwZS50cCRzdHIsXG5kZWxldGUgU2suYnVpbHRpbnMucmF3X2lucHV0LGRlbGV0ZSBTay5idWlsdGlucy51bmljaHIsZGVsZXRlIFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5kZWNvZGUsU2suYnVpbHRpbnMuYnl0ZXM9U2suYnVpbHRpbi5ieXRlcyxTay5idWlsdGlucy5hc2NpaT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4uYXNjaWksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIGFuIEFTQ0lJLW9ubHkgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxcblxcbkFzIHJlcHIoKSwgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYW5cXG5vYmplY3QsIGJ1dCBlc2NhcGUgdGhlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgcmV0dXJuZWQgYnlcXG5yZXByKCkgdXNpbmcgXFxcXFxcXFx4LCBcXFxcXFxcXHUgb3IgXFxcXFxcXFxVIGVzY2FwZXMuIFRoaXMgZ2VuZXJhdGVzIGEgc3RyaW5nIHNpbWlsYXJcXG50byB0aGF0IHJldHVybmVkIGJ5IHJlcHIoKSBpbiBQeXRob24gMi5cIn0sXG5udWxsLFwiYnVpbHRpbnNcIikpOihTay5idWlsdGlucy5yYW5nZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ucmFuZ2UsJG5hbWU6XCJyYW5nZVwiLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M319LHZvaWQgMCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLnhyYW5nZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ueHJhbmdlLCRuYW1lOlwieHJhbmdlXCIsJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfX0sbnVsbCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLnJlZHVjZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ucmVkdWNlLCRuYW1lOlwicmVkdWNlXCIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczozfX0sbnVsbCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLmZpbHRlcj1uZXcgU2suYnVpbHRpbi5mdW5jKFNrLmJ1aWx0aW4uZmlsdGVyKSxTay5idWlsdGlucy5tYXA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLm1hcCksXG5Tay5idWlsdGlucy56aXA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnppcCksU2suYnVpbHRpbnMuU3RhbmRhcmRFcnJvcj1Tay5idWlsdGluLkV4Y2VwdGlvbixTay5idWlsdGlucy51bmljb2RlPVNrLmJ1aWx0aW4uc3RyLFNrLmJ1aWx0aW5zLmJhc2VzdHJpbmc9U2suYnVpbHRpbi5zdHIsU2suYnVpbHRpbnMubG9uZ18kcnckPVNrLmJ1aWx0aW4ubG5nLFNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGUuJHI9ZnVuY3Rpb24oKXtjb25zdCBrPXRoaXMudjtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGs/bmV3IFNrLmJ1aWx0aW4uc3RyKGsudG9TdHJpbmcoKSk6bmV3IFNrLmJ1aWx0aW4uc3RyKGsudG9TdHJpbmcoKStcIkxcIil9LFNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGUudHAkc3RyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYudG9TdHJpbmcoKSl9LFNrLmJ1aWx0aW4uYm9vbC5wcm90b3R5cGUudHAkc3RyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJHIoKX0sXG5Tay5idWlsdGlucy5yYXdfaW5wdXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnJhd19pbnB1dCksU2suYnVpbHRpbnMudW5pY2hyPW5ldyBTay5idWlsdGluLmZ1bmMoU2suYnVpbHRpbi51bmljaHIpLFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5kZWNvZGU9U2suYnVpbHRpbi5zdHIuJHB5MmRlY29kZSxkZWxldGUgU2suYnVpbHRpbnMuYnl0ZXMsZGVsZXRlIFNrLmJ1aWx0aW5zLmFzY2lpKX07U2suZXhwb3J0U3ltYm9sKFwiU2suc2V0dXBPYmplY3RzXCIsU2suc2V0dXBPYmplY3RzKTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluc1wiLFNrLmJ1aWx0aW5zKX0sZnVuY3Rpb24oRSxRKXtTay5idWlsdGluLnN0ci4kZW1wdHk9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpO1NrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0cj1Tay5idWlsdGluLnN0ci4kZW1wdHk7U2suYnVpbHRpbi5zdHIuJHV0Zjg9bmV3IFNrLmJ1aWx0aW4uc3RyKFwidXRmLThcIik7U2suYnVpbHRpbi5zdHIuJGFzY2lpPVxubmV3IFNrLmJ1aWx0aW4uc3RyKFwiYXNjaWlcIik7U2suYnVpbHRpbi5zdHIuJGRlZmF1bHRfZmFjdG9yeT1uZXcgU2suYnVpbHRpbi5zdHIoXCJkZWZhdWx0X2ZhY3RvcnlcIik7U2suYnVpbHRpbi5zdHIuJGltYWc9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiaW1hZ1wiKTtTay5idWlsdGluLnN0ci4kcmVhbD1uZXcgU2suYnVpbHRpbi5zdHIoXCJyZWFsXCIpO1NrLmJ1aWx0aW4uc3RyLiRhYnM9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19hYnNfX1wiKTtTay5idWlsdGluLnN0ci4kYnl0ZXM9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19ieXRlc19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRjYWxsPW5ldyBTay5idWlsdGluLnN0cihcIl9fY2FsbF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRjbGFzcz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2NsYXNzX19cIik7U2suYnVpbHRpbi5zdHIuJGNsYXNzX2dldGl0ZW09bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19jbGFzc19nZXRpdGVtX19cIik7U2suYnVpbHRpbi5zdHIuJGNtcD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2NtcF9fXCIpO1xuU2suYnVpbHRpbi5zdHIuJGNvbXBsZXg9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19jb21wbGV4X19cIik7U2suYnVpbHRpbi5zdHIuJGNvbnRhaW5zPW5ldyBTay5idWlsdGluLnN0cihcIl9fY29udGFpbnNfX1wiKTtTay5idWlsdGluLnN0ci4kY29weT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2NvcHlfX1wiKTtTay5idWlsdGluLnN0ci4kZGljdD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2RpY3RfX1wiKTtTay5idWlsdGluLnN0ci4kZGlyPW5ldyBTay5idWlsdGluLnN0cihcIl9fZGlyX19cIik7U2suYnVpbHRpbi5zdHIuJGRvYz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2RvY19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRlbnRlcj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2VudGVyX19cIik7U2suYnVpbHRpbi5zdHIuJGVxPW5ldyBTay5idWlsdGluLnN0cihcIl9fZXFfX1wiKTtTay5idWlsdGluLnN0ci4kZXhpdD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2V4aXRfX1wiKTtTay5idWlsdGluLnN0ci4kaW5kZXg9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19pbmRleF9fXCIpO1xuU2suYnVpbHRpbi5zdHIuJGluaXQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19pbml0X19cIik7U2suYnVpbHRpbi5zdHIuJGluaXRzdWJjbGFzcz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2luaXRfc3ViY2xhc3NfX1wiKTtTay5idWlsdGluLnN0ci4kaW50Xz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2ludF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRpdGVyPW5ldyBTay5idWlsdGluLnN0cihcIl9faXRlcl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRmaWxlPW5ldyBTay5idWlsdGluLnN0cihcIl9fZmlsZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRmbG9hdF89bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19mbG9hdF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRmb3JtYXQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19mb3JtYXRfX1wiKTtTay5idWlsdGluLnN0ci4kZ2U9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19nZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRnZXRhdHRyPW5ldyBTay5idWlsdGluLnN0cihcIl9fZ2V0YXR0cl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRnZXRhdHRyaWJ1dGU9XG5uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2dldGF0dHJpYnV0ZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRnZXRpdGVtPW5ldyBTay5idWlsdGluLnN0cihcIl9fZ2V0aXRlbV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRndD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2d0X19cIik7U2suYnVpbHRpbi5zdHIuJGtleXM9bmV3IFNrLmJ1aWx0aW4uc3RyKFwia2V5c1wiKTtTay5idWlsdGluLnN0ci4kbGU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRsZW49bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sZW5fX1wiKTtTay5idWlsdGluLnN0ci4kbGVuZ3RoX2hpbnQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sZW5ndGhfaGludF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRsb2FkZXI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sb2FkZXJfX1wiKTtTay5idWlsdGluLnN0ci4kbHQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sdF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRtb2R1bGU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19tb2R1bGVfX1wiKTtcblNrLmJ1aWx0aW4uc3RyLiRtaXNzaW5nPW5ldyBTay5idWlsdGluLnN0cihcIl9fbWlzc2luZ19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRuYW1lPW5ldyBTay5idWlsdGluLnN0cihcIl9fbmFtZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRuZT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX25lX19cIik7U2suYnVpbHRpbi5zdHIuJG5ldz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX25ld19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRuZXh0PW5ldyBTay5idWlsdGluLnN0cihcIl9fbmV4dF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRwYXRoPW5ldyBTay5idWlsdGluLnN0cihcIl9fcGF0aF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRwcmVwYXJlPW5ldyBTay5idWlsdGluLnN0cihcIl9fcHJlcGFyZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRxdWFsbmFtZT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3F1YWxuYW1lX19cIik7U2suYnVpbHRpbi5zdHIuJHJlcHI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19yZXByX19cIik7U2suYnVpbHRpbi5zdHIuJHJldmVyc2VkPVxubmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19yZXZlcnNlZF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRyb3VuZD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3JvdW5kX19cIik7U2suYnVpbHRpbi5zdHIuJHNldGF0dHI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19zZXRhdHRyX19cIik7U2suYnVpbHRpbi5zdHIuJHNldGl0ZW09bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19zZXRpdGVtX19cIik7U2suYnVpbHRpbi5zdHIuJHNsb3RzPW5ldyBTay5idWlsdGluLnN0cihcIl9fc2xvdHNfX1wiKTtTay5idWlsdGluLnN0ci4kc3RyPW5ldyBTay5idWlsdGluLnN0cihcIl9fc3RyX19cIik7U2suYnVpbHRpbi5zdHIuJHNldG5hbWU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19zZXRfbmFtZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiR0cnVuYz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3RydW5jX19cIik7U2suYnVpbHRpbi5zdHIuJHdyaXRlPW5ldyBTay5idWlsdGluLnN0cihcIndyaXRlXCIpO1NrLm1pc2NldmFsLm9wMm1ldGhvZF89e0VxOlNrLmJ1aWx0aW4uc3RyLiRlcSxcbk5vdEVxOlNrLmJ1aWx0aW4uc3RyLiRuZSxHdDpTay5idWlsdGluLnN0ci4kZ3QsR3RFOlNrLmJ1aWx0aW4uc3RyLiRnZSxMdDpTay5idWlsdGluLnN0ci4kbHQsTHRFOlNrLmJ1aWx0aW4uc3RyLiRsZX19LGZ1bmN0aW9uKEUsUSxiKXtmdW5jdGlvbiBmKGJhLGphLG5hLGZhLFYpe3RoaXMudHlwZT1iYTt0aGlzLnN0cmluZz1qYTt0aGlzLnN0YXJ0PW5hO3RoaXMuZW5kPWZhO3RoaXMubGluZT1WfWZ1bmN0aW9uIGUoYmEpe3JldHVyblwiKFwiK0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcInxcIikrXCIpXCJ9ZnVuY3Rpb24gZyhiYSl7cmV0dXJuIGUuYXBwbHkobnVsbCxhcmd1bWVudHMpK1wiP1wifWZ1bmN0aW9uIGsoYmEsamEpe2Zvcih2YXIgbmE9YmEubGVuZ3RoO25hLS07KWlmKGJhW25hXT09PWphKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHAoYmEpe2JhPWJhLm5vcm1hbGl6ZShcIk5GS0NcIik7cmV0dXJuIHgudGVzdChiYSl9ZnVuY3Rpb24gaCgpe3JldHVyblwiIEZSIFJGIEJyIEJSIEZyIHIgQiBSIGIgYlIgZiByYiByQiBGIFJmIFUgckYgdSBSQiBiciBmUiBmciByZiBSYlwiLnNwbGl0KFwiIFwiKX1cbmZ1bmN0aW9uIGEoYmEpe2JhP2RlbGV0ZSBTay50b2tlbi5FWEFDVF9UT0tFTl9UWVBFU1tcIjw+XCJdOlNrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTW1wiPD5cIl09U2sudG9rZW4udG9rZW5zLlRfTk9URVFVQUw7Sj1PYmplY3Qua2V5cyhTay50b2tlbi5FWEFDVF9UT0tFTl9UWVBFUykuc29ydCgpO1A9ZS5hcHBseSh0aGlzLEoucmV2ZXJzZSgpLm1hcChmdW5jdGlvbihqYSl7cmV0dXJuIGphJiZsLnRlc3QoamEpP2phLnJlcGxhY2UoZCxcIlxcXFwkJlwiKTpqYX0pKTtXPWUoXCJcXFxccj9cXFxcblwiLFApfWIucihRKTtFPXtDYzpcIlxcXFwwLVxcXFx4MUZcXFxceDdGLVxcXFx4OUZcIixDZjpcIlxcXFx4QURcXFxcdTA2MDAtXFxcXHUwNjA1XFxcXHUwNjFDXFxcXHUwNkREXFxcXHUwNzBGXFxcXHUwOEUyXFxcXHUxODBFXFxcXHUyMDBCLVxcXFx1MjAwRlxcXFx1MjAyQS1cXFxcdTIwMkVcXFxcdTIwNjAtXFxcXHUyMDY0XFxcXHUyMDY2LVxcXFx1MjA2RlxcXFx1RkVGRlxcXFx1RkZGOS1cXFxcdUZGRkJcIixDbzpcIlxcXFx1RTAwMC1cXFxcdUY4RkZcIixDczpcIlxcXFx1RDgwMC1cXFxcdURGRkZcIixMbDpcImEtelxcXFx4QjVcXFxceERGLVxcXFx4RjZcXFxceEY4LVxcXFx4RkZcXFxcdTAxMDFcXFxcdTAxMDNcXFxcdTAxMDVcXFxcdTAxMDdcXFxcdTAxMDlcXFxcdTAxMEJcXFxcdTAxMERcXFxcdTAxMEZcXFxcdTAxMTFcXFxcdTAxMTNcXFxcdTAxMTVcXFxcdTAxMTdcXFxcdTAxMTlcXFxcdTAxMUJcXFxcdTAxMURcXFxcdTAxMUZcXFxcdTAxMjFcXFxcdTAxMjNcXFxcdTAxMjVcXFxcdTAxMjdcXFxcdTAxMjlcXFxcdTAxMkJcXFxcdTAxMkRcXFxcdTAxMkZcXFxcdTAxMzFcXFxcdTAxMzNcXFxcdTAxMzVcXFxcdTAxMzdcXFxcdTAxMzhcXFxcdTAxM0FcXFxcdTAxM0NcXFxcdTAxM0VcXFxcdTAxNDBcXFxcdTAxNDJcXFxcdTAxNDRcXFxcdTAxNDZcXFxcdTAxNDhcXFxcdTAxNDlcXFxcdTAxNEJcXFxcdTAxNERcXFxcdTAxNEZcXFxcdTAxNTFcXFxcdTAxNTNcXFxcdTAxNTVcXFxcdTAxNTdcXFxcdTAxNTlcXFxcdTAxNUJcXFxcdTAxNURcXFxcdTAxNUZcXFxcdTAxNjFcXFxcdTAxNjNcXFxcdTAxNjVcXFxcdTAxNjdcXFxcdTAxNjlcXFxcdTAxNkJcXFxcdTAxNkRcXFxcdTAxNkZcXFxcdTAxNzFcXFxcdTAxNzNcXFxcdTAxNzVcXFxcdTAxNzdcXFxcdTAxN0FcXFxcdTAxN0NcXFxcdTAxN0UtXFxcXHUwMTgwXFxcXHUwMTgzXFxcXHUwMTg1XFxcXHUwMTg4XFxcXHUwMThDXFxcXHUwMThEXFxcXHUwMTkyXFxcXHUwMTk1XFxcXHUwMTk5LVxcXFx1MDE5QlxcXFx1MDE5RVxcXFx1MDFBMVxcXFx1MDFBM1xcXFx1MDFBNVxcXFx1MDFBOFxcXFx1MDFBQVxcXFx1MDFBQlxcXFx1MDFBRFxcXFx1MDFCMFxcXFx1MDFCNFxcXFx1MDFCNlxcXFx1MDFCOVxcXFx1MDFCQVxcXFx1MDFCRC1cXFxcdTAxQkZcXFxcdTAxQzZcXFxcdTAxQzlcXFxcdTAxQ0NcXFxcdTAxQ0VcXFxcdTAxRDBcXFxcdTAxRDJcXFxcdTAxRDRcXFxcdTAxRDZcXFxcdTAxRDhcXFxcdTAxREFcXFxcdTAxRENcXFxcdTAxRERcXFxcdTAxREZcXFxcdTAxRTFcXFxcdTAxRTNcXFxcdTAxRTVcXFxcdTAxRTdcXFxcdTAxRTlcXFxcdTAxRUJcXFxcdTAxRURcXFxcdTAxRUZcXFxcdTAxRjBcXFxcdTAxRjNcXFxcdTAxRjVcXFxcdTAxRjlcXFxcdTAxRkJcXFxcdTAxRkRcXFxcdTAxRkZcXFxcdTAyMDFcXFxcdTAyMDNcXFxcdTAyMDVcXFxcdTAyMDdcXFxcdTAyMDlcXFxcdTAyMEJcXFxcdTAyMERcXFxcdTAyMEZcXFxcdTAyMTFcXFxcdTAyMTNcXFxcdTAyMTVcXFxcdTAyMTdcXFxcdTAyMTlcXFxcdTAyMUJcXFxcdTAyMURcXFxcdTAyMUZcXFxcdTAyMjFcXFxcdTAyMjNcXFxcdTAyMjVcXFxcdTAyMjdcXFxcdTAyMjlcXFxcdTAyMkJcXFxcdTAyMkRcXFxcdTAyMkZcXFxcdTAyMzFcXFxcdTAyMzMtXFxcXHUwMjM5XFxcXHUwMjNDXFxcXHUwMjNGXFxcXHUwMjQwXFxcXHUwMjQyXFxcXHUwMjQ3XFxcXHUwMjQ5XFxcXHUwMjRCXFxcXHUwMjREXFxcXHUwMjRGLVxcXFx1MDI5M1xcXFx1MDI5NS1cXFxcdTAyQUZcXFxcdTAzNzFcXFxcdTAzNzNcXFxcdTAzNzdcXFxcdTAzN0ItXFxcXHUwMzdEXFxcXHUwMzkwXFxcXHUwM0FDLVxcXFx1MDNDRVxcXFx1MDNEMFxcXFx1MDNEMVxcXFx1MDNENS1cXFxcdTAzRDdcXFxcdTAzRDlcXFxcdTAzREJcXFxcdTAzRERcXFxcdTAzREZcXFxcdTAzRTFcXFxcdTAzRTNcXFxcdTAzRTVcXFxcdTAzRTdcXFxcdTAzRTlcXFxcdTAzRUJcXFxcdTAzRURcXFxcdTAzRUYtXFxcXHUwM0YzXFxcXHUwM0Y1XFxcXHUwM0Y4XFxcXHUwM0ZCXFxcXHUwM0ZDXFxcXHUwNDMwLVxcXFx1MDQ1RlxcXFx1MDQ2MVxcXFx1MDQ2M1xcXFx1MDQ2NVxcXFx1MDQ2N1xcXFx1MDQ2OVxcXFx1MDQ2QlxcXFx1MDQ2RFxcXFx1MDQ2RlxcXFx1MDQ3MVxcXFx1MDQ3M1xcXFx1MDQ3NVxcXFx1MDQ3N1xcXFx1MDQ3OVxcXFx1MDQ3QlxcXFx1MDQ3RFxcXFx1MDQ3RlxcXFx1MDQ4MVxcXFx1MDQ4QlxcXFx1MDQ4RFxcXFx1MDQ4RlxcXFx1MDQ5MVxcXFx1MDQ5M1xcXFx1MDQ5NVxcXFx1MDQ5N1xcXFx1MDQ5OVxcXFx1MDQ5QlxcXFx1MDQ5RFxcXFx1MDQ5RlxcXFx1MDRBMVxcXFx1MDRBM1xcXFx1MDRBNVxcXFx1MDRBN1xcXFx1MDRBOVxcXFx1MDRBQlxcXFx1MDRBRFxcXFx1MDRBRlxcXFx1MDRCMVxcXFx1MDRCM1xcXFx1MDRCNVxcXFx1MDRCN1xcXFx1MDRCOVxcXFx1MDRCQlxcXFx1MDRCRFxcXFx1MDRCRlxcXFx1MDRDMlxcXFx1MDRDNFxcXFx1MDRDNlxcXFx1MDRDOFxcXFx1MDRDQVxcXFx1MDRDQ1xcXFx1MDRDRVxcXFx1MDRDRlxcXFx1MDREMVxcXFx1MDREM1xcXFx1MDRENVxcXFx1MDREN1xcXFx1MDREOVxcXFx1MDREQlxcXFx1MDRERFxcXFx1MDRERlxcXFx1MDRFMVxcXFx1MDRFM1xcXFx1MDRFNVxcXFx1MDRFN1xcXFx1MDRFOVxcXFx1MDRFQlxcXFx1MDRFRFxcXFx1MDRFRlxcXFx1MDRGMVxcXFx1MDRGM1xcXFx1MDRGNVxcXFx1MDRGN1xcXFx1MDRGOVxcXFx1MDRGQlxcXFx1MDRGRFxcXFx1MDRGRlxcXFx1MDUwMVxcXFx1MDUwM1xcXFx1MDUwNVxcXFx1MDUwN1xcXFx1MDUwOVxcXFx1MDUwQlxcXFx1MDUwRFxcXFx1MDUwRlxcXFx1MDUxMVxcXFx1MDUxM1xcXFx1MDUxNVxcXFx1MDUxN1xcXFx1MDUxOVxcXFx1MDUxQlxcXFx1MDUxRFxcXFx1MDUxRlxcXFx1MDUyMVxcXFx1MDUyM1xcXFx1MDUyNVxcXFx1MDUyN1xcXFx1MDUyOVxcXFx1MDUyQlxcXFx1MDUyRFxcXFx1MDUyRlxcXFx1MDU2MC1cXFxcdTA1ODhcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZELVxcXFx1MTBGRlxcXFx1MTNGOC1cXFxcdTEzRkRcXFxcdTFDODAtXFxcXHUxQzg4XFxcXHUxRDAwLVxcXFx1MUQyQlxcXFx1MUQ2Qi1cXFxcdTFENzdcXFxcdTFENzktXFxcXHUxRDlBXFxcXHUxRTAxXFxcXHUxRTAzXFxcXHUxRTA1XFxcXHUxRTA3XFxcXHUxRTA5XFxcXHUxRTBCXFxcXHUxRTBEXFxcXHUxRTBGXFxcXHUxRTExXFxcXHUxRTEzXFxcXHUxRTE1XFxcXHUxRTE3XFxcXHUxRTE5XFxcXHUxRTFCXFxcXHUxRTFEXFxcXHUxRTFGXFxcXHUxRTIxXFxcXHUxRTIzXFxcXHUxRTI1XFxcXHUxRTI3XFxcXHUxRTI5XFxcXHUxRTJCXFxcXHUxRTJEXFxcXHUxRTJGXFxcXHUxRTMxXFxcXHUxRTMzXFxcXHUxRTM1XFxcXHUxRTM3XFxcXHUxRTM5XFxcXHUxRTNCXFxcXHUxRTNEXFxcXHUxRTNGXFxcXHUxRTQxXFxcXHUxRTQzXFxcXHUxRTQ1XFxcXHUxRTQ3XFxcXHUxRTQ5XFxcXHUxRTRCXFxcXHUxRTREXFxcXHUxRTRGXFxcXHUxRTUxXFxcXHUxRTUzXFxcXHUxRTU1XFxcXHUxRTU3XFxcXHUxRTU5XFxcXHUxRTVCXFxcXHUxRTVEXFxcXHUxRTVGXFxcXHUxRTYxXFxcXHUxRTYzXFxcXHUxRTY1XFxcXHUxRTY3XFxcXHUxRTY5XFxcXHUxRTZCXFxcXHUxRTZEXFxcXHUxRTZGXFxcXHUxRTcxXFxcXHUxRTczXFxcXHUxRTc1XFxcXHUxRTc3XFxcXHUxRTc5XFxcXHUxRTdCXFxcXHUxRTdEXFxcXHUxRTdGXFxcXHUxRTgxXFxcXHUxRTgzXFxcXHUxRTg1XFxcXHUxRTg3XFxcXHUxRTg5XFxcXHUxRThCXFxcXHUxRThEXFxcXHUxRThGXFxcXHUxRTkxXFxcXHUxRTkzXFxcXHUxRTk1LVxcXFx1MUU5RFxcXFx1MUU5RlxcXFx1MUVBMVxcXFx1MUVBM1xcXFx1MUVBNVxcXFx1MUVBN1xcXFx1MUVBOVxcXFx1MUVBQlxcXFx1MUVBRFxcXFx1MUVBRlxcXFx1MUVCMVxcXFx1MUVCM1xcXFx1MUVCNVxcXFx1MUVCN1xcXFx1MUVCOVxcXFx1MUVCQlxcXFx1MUVCRFxcXFx1MUVCRlxcXFx1MUVDMVxcXFx1MUVDM1xcXFx1MUVDNVxcXFx1MUVDN1xcXFx1MUVDOVxcXFx1MUVDQlxcXFx1MUVDRFxcXFx1MUVDRlxcXFx1MUVEMVxcXFx1MUVEM1xcXFx1MUVENVxcXFx1MUVEN1xcXFx1MUVEOVxcXFx1MUVEQlxcXFx1MUVERFxcXFx1MUVERlxcXFx1MUVFMVxcXFx1MUVFM1xcXFx1MUVFNVxcXFx1MUVFN1xcXFx1MUVFOVxcXFx1MUVFQlxcXFx1MUVFRFxcXFx1MUVFRlxcXFx1MUVGMVxcXFx1MUVGM1xcXFx1MUVGNVxcXFx1MUVGN1xcXFx1MUVGOVxcXFx1MUVGQlxcXFx1MUVGRFxcXFx1MUVGRi1cXFxcdTFGMDdcXFxcdTFGMTAtXFxcXHUxRjE1XFxcXHUxRjIwLVxcXFx1MUYyN1xcXFx1MUYzMC1cXFxcdTFGMzdcXFxcdTFGNDAtXFxcXHUxRjQ1XFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY2MC1cXFxcdTFGNjdcXFxcdTFGNzAtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUY4N1xcXFx1MUY5MC1cXFxcdTFGOTdcXFxcdTFGQTAtXFxcXHUxRkE3XFxcXHUxRkIwLVxcXFx1MUZCNFxcXFx1MUZCNlxcXFx1MUZCN1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzZcXFxcdTFGQzdcXFxcdTFGRDAtXFxcXHUxRkQzXFxcXHUxRkQ2XFxcXHUxRkQ3XFxcXHUxRkUwLVxcXFx1MUZFN1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjZcXFxcdTFGRjdcXFxcdTIxMEFcXFxcdTIxMEVcXFxcdTIxMEZcXFxcdTIxMTNcXFxcdTIxMkZcXFxcdTIxMzRcXFxcdTIxMzlcXFxcdTIxM0NcXFxcdTIxM0RcXFxcdTIxNDYtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTg0XFxcXHUyQzMwLVxcXFx1MkM1RVxcXFx1MkM2MVxcXFx1MkM2NVxcXFx1MkM2NlxcXFx1MkM2OFxcXFx1MkM2QVxcXFx1MkM2Q1xcXFx1MkM3MVxcXFx1MkM3M1xcXFx1MkM3NFxcXFx1MkM3Ni1cXFxcdTJDN0JcXFxcdTJDODFcXFxcdTJDODNcXFxcdTJDODVcXFxcdTJDODdcXFxcdTJDODlcXFxcdTJDOEJcXFxcdTJDOERcXFxcdTJDOEZcXFxcdTJDOTFcXFxcdTJDOTNcXFxcdTJDOTVcXFxcdTJDOTdcXFxcdTJDOTlcXFxcdTJDOUJcXFxcdTJDOURcXFxcdTJDOUZcXFxcdTJDQTFcXFxcdTJDQTNcXFxcdTJDQTVcXFxcdTJDQTdcXFxcdTJDQTlcXFxcdTJDQUJcXFxcdTJDQURcXFxcdTJDQUZcXFxcdTJDQjFcXFxcdTJDQjNcXFxcdTJDQjVcXFxcdTJDQjdcXFxcdTJDQjlcXFxcdTJDQkJcXFxcdTJDQkRcXFxcdTJDQkZcXFxcdTJDQzFcXFxcdTJDQzNcXFxcdTJDQzVcXFxcdTJDQzdcXFxcdTJDQzlcXFxcdTJDQ0JcXFxcdTJDQ0RcXFxcdTJDQ0ZcXFxcdTJDRDFcXFxcdTJDRDNcXFxcdTJDRDVcXFxcdTJDRDdcXFxcdTJDRDlcXFxcdTJDREJcXFxcdTJDRERcXFxcdTJDREZcXFxcdTJDRTFcXFxcdTJDRTNcXFxcdTJDRTRcXFxcdTJDRUNcXFxcdTJDRUVcXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHVBNjQxXFxcXHVBNjQzXFxcXHVBNjQ1XFxcXHVBNjQ3XFxcXHVBNjQ5XFxcXHVBNjRCXFxcXHVBNjREXFxcXHVBNjRGXFxcXHVBNjUxXFxcXHVBNjUzXFxcXHVBNjU1XFxcXHVBNjU3XFxcXHVBNjU5XFxcXHVBNjVCXFxcXHVBNjVEXFxcXHVBNjVGXFxcXHVBNjYxXFxcXHVBNjYzXFxcXHVBNjY1XFxcXHVBNjY3XFxcXHVBNjY5XFxcXHVBNjZCXFxcXHVBNjZEXFxcXHVBNjgxXFxcXHVBNjgzXFxcXHVBNjg1XFxcXHVBNjg3XFxcXHVBNjg5XFxcXHVBNjhCXFxcXHVBNjhEXFxcXHVBNjhGXFxcXHVBNjkxXFxcXHVBNjkzXFxcXHVBNjk1XFxcXHVBNjk3XFxcXHVBNjk5XFxcXHVBNjlCXFxcXHVBNzIzXFxcXHVBNzI1XFxcXHVBNzI3XFxcXHVBNzI5XFxcXHVBNzJCXFxcXHVBNzJEXFxcXHVBNzJGLVxcXFx1QTczMVxcXFx1QTczM1xcXFx1QTczNVxcXFx1QTczN1xcXFx1QTczOVxcXFx1QTczQlxcXFx1QTczRFxcXFx1QTczRlxcXFx1QTc0MVxcXFx1QTc0M1xcXFx1QTc0NVxcXFx1QTc0N1xcXFx1QTc0OVxcXFx1QTc0QlxcXFx1QTc0RFxcXFx1QTc0RlxcXFx1QTc1MVxcXFx1QTc1M1xcXFx1QTc1NVxcXFx1QTc1N1xcXFx1QTc1OVxcXFx1QTc1QlxcXFx1QTc1RFxcXFx1QTc1RlxcXFx1QTc2MVxcXFx1QTc2M1xcXFx1QTc2NVxcXFx1QTc2N1xcXFx1QTc2OVxcXFx1QTc2QlxcXFx1QTc2RFxcXFx1QTc2RlxcXFx1QTc3MS1cXFxcdUE3NzhcXFxcdUE3N0FcXFxcdUE3N0NcXFxcdUE3N0ZcXFxcdUE3ODFcXFxcdUE3ODNcXFxcdUE3ODVcXFxcdUE3ODdcXFxcdUE3OENcXFxcdUE3OEVcXFxcdUE3OTFcXFxcdUE3OTMtXFxcXHVBNzk1XFxcXHVBNzk3XFxcXHVBNzk5XFxcXHVBNzlCXFxcXHVBNzlEXFxcXHVBNzlGXFxcXHVBN0ExXFxcXHVBN0EzXFxcXHVBN0E1XFxcXHVBN0E3XFxcXHVBN0E5XFxcXHVBN0FGXFxcXHVBN0I1XFxcXHVBN0I3XFxcXHVBN0I5XFxcXHVBN0JCXFxcXHVBN0JEXFxcXHVBN0JGXFxcXHVBN0MzXFxcXHVBN0M4XFxcXHVBN0NBXFxcXHVBN0Y2XFxcXHVBN0ZBXFxcXHVBQjMwLVxcXFx1QUI1QVxcXFx1QUI2MC1cXFxcdUFCNjhcXFxcdUFCNzAtXFxcXHVBQkJGXFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZGNDEtXFxcXHVGRjVBXCIsXG5MbTpcIlxcXFx1MDJCMC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDM3NFxcXFx1MDM3QVxcXFx1MDU1OVxcXFx1MDY0MFxcXFx1MDZFNVxcXFx1MDZFNlxcXFx1MDdGNFxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDgxQVxcXFx1MDgyNFxcXFx1MDgyOFxcXFx1MDk3MVxcXFx1MEU0NlxcXFx1MEVDNlxcXFx1MTBGQ1xcXFx1MTdEN1xcXFx1MTg0M1xcXFx1MUFBN1xcXFx1MUM3OC1cXFxcdTFDN0RcXFxcdTFEMkMtXFxcXHUxRDZBXFxcXHUxRDc4XFxcXHUxRDlCLVxcXFx1MURCRlxcXFx1MjA3MVxcXFx1MjA3RlxcXFx1MjA5MC1cXFxcdTIwOUNcXFxcdTJDN0NcXFxcdTJDN0RcXFxcdTJENkZcXFxcdTJFMkZcXFxcdTMwMDVcXFxcdTMwMzEtXFxcXHUzMDM1XFxcXHUzMDNCXFxcXHUzMDlEXFxcXHUzMDlFXFxcXHUzMEZDLVxcXFx1MzBGRVxcXFx1QTAxNVxcXFx1QTRGOC1cXFxcdUE0RkRcXFxcdUE2MENcXFxcdUE2N0ZcXFxcdUE2OUNcXFxcdUE2OURcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzcwXFxcXHVBNzg4XFxcXHVBN0Y4XFxcXHVBN0Y5XFxcXHVBOUNGXFxcXHVBOUU2XFxcXHVBQTcwXFxcXHVBQUREXFxcXHVBQUYzXFxcXHVBQUY0XFxcXHVBQjVDLVxcXFx1QUI1RlxcXFx1QUI2OVxcXFx1RkY3MFxcXFx1RkY5RVxcXFx1RkY5RlwiLFxuTG86XCJcXFxceEFBXFxcXHhCQVxcXFx1MDFCQlxcXFx1MDFDMC1cXFxcdTAxQzNcXFxcdTAyOTRcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUVGLVxcXFx1MDVGMlxcXFx1MDYyMC1cXFxcdTA2M0ZcXFxcdTA2NDEtXFxcXHUwNjRBXFxcXHUwNjZFXFxcXHUwNjZGXFxcXHUwNjcxLVxcXFx1MDZEM1xcXFx1MDZENVxcXFx1MDZFRVxcXFx1MDZFRlxcXFx1MDZGQS1cXFxcdTA2RkNcXFxcdTA2RkZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJGXFxcXHUwNzRELVxcXFx1MDdBNVxcXFx1MDdCMVxcXFx1MDdDQS1cXFxcdTA3RUFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDg2MC1cXFxcdTA4NkFcXFxcdTA4QTAtXFxcXHUwOEI0XFxcXHUwOEI2LVxcXFx1MDhDN1xcXFx1MDkwNC1cXFxcdTA5MzlcXFxcdTA5M0RcXFxcdTA5NTBcXFxcdTA5NTgtXFxcXHUwOTYxXFxcXHUwOTcyLVxcXFx1MDk4MFxcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkRcXFxcdTA5Q0VcXFxcdTA5RENcXFxcdTA5RERcXFxcdTA5REYtXFxcXHUwOUUxXFxcXHUwOUYwXFxcXHUwOUYxXFxcXHUwOUZDXFxcXHUwQTA1LVxcXFx1MEEwQVxcXFx1MEEwRlxcXFx1MEExMFxcXFx1MEExMy1cXFxcdTBBMjhcXFxcdTBBMkEtXFxcXHUwQTMwXFxcXHUwQTMyXFxcXHUwQTMzXFxcXHUwQTM1XFxcXHUwQTM2XFxcXHUwQTM4XFxcXHUwQTM5XFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE3Mi1cXFxcdTBBNzRcXFxcdTBBODUtXFxcXHUwQThEXFxcXHUwQThGLVxcXFx1MEE5MVxcXFx1MEE5My1cXFxcdTBBQThcXFxcdTBBQUEtXFxcXHUwQUIwXFxcXHUwQUIyXFxcXHUwQUIzXFxcXHUwQUI1LVxcXFx1MEFCOVxcXFx1MEFCRFxcXFx1MEFEMFxcXFx1MEFFMFxcXFx1MEFFMVxcXFx1MEFGOVxcXFx1MEIwNS1cXFxcdTBCMENcXFxcdTBCMEZcXFxcdTBCMTBcXFxcdTBCMTMtXFxcXHUwQjI4XFxcXHUwQjJBLVxcXFx1MEIzMFxcXFx1MEIzMlxcXFx1MEIzM1xcXFx1MEIzNS1cXFxcdTBCMzlcXFxcdTBCM0RcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYxXFxcXHUwQjcxXFxcXHUwQjgzXFxcXHUwQjg1LVxcXFx1MEI4QVxcXFx1MEI4RS1cXFxcdTBCOTBcXFxcdTBCOTItXFxcXHUwQjk1XFxcXHUwQjk5XFxcXHUwQjlBXFxcXHUwQjlDXFxcXHUwQjlFXFxcXHUwQjlGXFxcXHUwQkEzXFxcXHUwQkE0XFxcXHUwQkE4LVxcXFx1MEJBQVxcXFx1MEJBRS1cXFxcdTBCQjlcXFxcdTBCRDBcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzM5XFxcXHUwQzNEXFxcXHUwQzU4LVxcXFx1MEM1QVxcXFx1MEM2MFxcXFx1MEM2MVxcXFx1MEM4MFxcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JEXFxcXHUwQ0RFXFxcXHUwQ0UwXFxcXHUwQ0UxXFxcXHUwQ0YxXFxcXHUwQ0YyXFxcXHUwRDA0LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDNBXFxcXHUwRDNEXFxcXHUwRDRFXFxcXHUwRDU0LVxcXFx1MEQ1NlxcXFx1MEQ1Ri1cXFxcdTBENjFcXFxcdTBEN0EtXFxcXHUwRDdGXFxcXHUwRDg1LVxcXFx1MEQ5NlxcXFx1MEQ5QS1cXFxcdTBEQjFcXFxcdTBEQjMtXFxcXHUwREJCXFxcXHUwREJEXFxcXHUwREMwLVxcXFx1MERDNlxcXFx1MEUwMS1cXFxcdTBFMzBcXFxcdTBFMzJcXFxcdTBFMzNcXFxcdTBFNDAtXFxcXHUwRTQ1XFxcXHUwRTgxXFxcXHUwRTgyXFxcXHUwRTg0XFxcXHUwRTg2LVxcXFx1MEU4QVxcXFx1MEU4Qy1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTctXFxcXHUwRUIwXFxcXHUwRUIyXFxcXHUwRUIzXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVEQy1cXFxcdTBFREZcXFxcdTBGMDBcXFxcdTBGNDAtXFxcXHUwRjQ3XFxcXHUwRjQ5LVxcXFx1MEY2Q1xcXFx1MEY4OC1cXFxcdTBGOENcXFxcdTEwMDAtXFxcXHUxMDJBXFxcXHUxMDNGXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1QS1cXFxcdTEwNURcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNkUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4RVxcXFx1MTEwMC1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTQwMS1cXFxcdTE2NkNcXFxcdTE2NkYtXFxcXHUxNjdGXFxcXHUxNjgxLVxcXFx1MTY5QVxcXFx1MTZBMC1cXFxcdTE2RUFcXFxcdTE2RjEtXFxcXHUxNkY4XFxcXHUxNzAwLVxcXFx1MTcwQ1xcXFx1MTcwRS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NkNcXFxcdTE3NkUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdCM1xcXFx1MTdEQ1xcXFx1MTgyMC1cXFxcdTE4NDJcXFxcdTE4NDQtXFxcXHUxODc4XFxcXHUxODgwLVxcXFx1MTg4NFxcXFx1MTg4Ny1cXFxcdTE4QThcXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBQlxcXFx1MTlCMC1cXFxcdTE5QzlcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQTIwLVxcXFx1MUE1NFxcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUJCQS1cXFxcdTFCRTVcXFxcdTFDMDAtXFxcXHUxQzIzXFxcXHUxQzRELVxcXFx1MUM0RlxcXFx1MUM1QS1cXFxcdTFDNzdcXFxcdTFDRTktXFxcXHUxQ0VDXFxcXHUxQ0VFLVxcXFx1MUNGM1xcXFx1MUNGNVxcXFx1MUNGNlxcXFx1MUNGQVxcXFx1MjEzNS1cXFxcdTIxMzhcXFxcdTJEMzAtXFxcXHUyRDY3XFxcXHUyRDgwLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUzMDA2XFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkZcXFxcdTMxMDUtXFxcXHUzMTJGXFxcXHUzMTMxLVxcXFx1MzE4RVxcXFx1MzFBMC1cXFxcdTMxQkZcXFxcdTMxRjAtXFxcXHUzMUZGXFxcXHUzNDAwLVxcXFx1NERCRlxcXFx1NEUwMC1cXFxcdTlGRkNcXFxcdUEwMDAtXFxcXHVBMDE0XFxcXHVBMDE2LVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RjdcXFxcdUE1MDAtXFxcXHVBNjBCXFxcXHVBNjEwLVxcXFx1QTYxRlxcXFx1QTYyQVxcXFx1QTYyQlxcXFx1QTY2RVxcXFx1QTZBMC1cXFxcdUE2RTVcXFxcdUE3OEZcXFxcdUE3RjdcXFxcdUE3RkItXFxcXHVBODAxXFxcXHVBODAzLVxcXFx1QTgwNVxcXFx1QTgwNy1cXFxcdUE4MEFcXFxcdUE4MEMtXFxcXHVBODIyXFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4Mi1cXFxcdUE4QjNcXFxcdUE4RjItXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOEZEXFxcXHVBOEZFXFxcXHVBOTBBLVxcXFx1QTkyNVxcXFx1QTkzMC1cXFxcdUE5NDZcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTg0LVxcXFx1QTlCMlxcXFx1QTlFMC1cXFxcdUE5RTRcXFxcdUE5RTctXFxcXHVBOUVGXFxcXHVBOUZBLVxcXFx1QTlGRVxcXFx1QUEwMC1cXFxcdUFBMjhcXFxcdUFBNDAtXFxcXHVBQTQyXFxcXHVBQTQ0LVxcXFx1QUE0QlxcXFx1QUE2MC1cXFxcdUFBNkZcXFxcdUFBNzEtXFxcXHVBQTc2XFxcXHVBQTdBXFxcXHVBQTdFLVxcXFx1QUFBRlxcXFx1QUFCMVxcXFx1QUFCNVxcXFx1QUFCNlxcXFx1QUFCOS1cXFxcdUFBQkRcXFxcdUFBQzBcXFxcdUFBQzJcXFxcdUFBREJcXFxcdUFBRENcXFxcdUFBRTAtXFxcXHVBQUVBXFxcXHVBQUYyXFxcXHVBQjAxLVxcXFx1QUIwNlxcXFx1QUIwOS1cXFxcdUFCMEVcXFxcdUFCMTEtXFxcXHVBQjE2XFxcXHVBQjIwLVxcXFx1QUIyNlxcXFx1QUIyOC1cXFxcdUFCMkVcXFxcdUFCQzAtXFxcXHVBQkUyXFxcXHVBQzAwLVxcXFx1RDdBM1xcXFx1RDdCMC1cXFxcdUQ3QzZcXFxcdUQ3Q0ItXFxcXHVEN0ZCXFxcXHVGOTAwLVxcXFx1RkE2RFxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMURcXFxcdUZCMUYtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjY2LVxcXFx1RkY2RlxcXFx1RkY3MS1cXFxcdUZGOURcXFxcdUZGQTAtXFxcXHVGRkJFXFxcXHVGRkMyLVxcXFx1RkZDN1xcXFx1RkZDQS1cXFxcdUZGQ0ZcXFxcdUZGRDItXFxcXHVGRkQ3XFxcXHVGRkRBLVxcXFx1RkZEQ1wiLFxuTHQ6XCJcXFxcdTAxQzVcXFxcdTAxQzhcXFxcdTAxQ0JcXFxcdTAxRjJcXFxcdTFGODgtXFxcXHUxRjhGXFxcXHUxRjk4LVxcXFx1MUY5RlxcXFx1MUZBOC1cXFxcdTFGQUZcXFxcdTFGQkNcXFxcdTFGQ0NcXFxcdTFGRkNcIixMdTpcIkEtWlxcXFx4QzAtXFxcXHhENlxcXFx4RDgtXFxcXHhERVxcXFx1MDEwMFxcXFx1MDEwMlxcXFx1MDEwNFxcXFx1MDEwNlxcXFx1MDEwOFxcXFx1MDEwQVxcXFx1MDEwQ1xcXFx1MDEwRVxcXFx1MDExMFxcXFx1MDExMlxcXFx1MDExNFxcXFx1MDExNlxcXFx1MDExOFxcXFx1MDExQVxcXFx1MDExQ1xcXFx1MDExRVxcXFx1MDEyMFxcXFx1MDEyMlxcXFx1MDEyNFxcXFx1MDEyNlxcXFx1MDEyOFxcXFx1MDEyQVxcXFx1MDEyQ1xcXFx1MDEyRVxcXFx1MDEzMFxcXFx1MDEzMlxcXFx1MDEzNFxcXFx1MDEzNlxcXFx1MDEzOVxcXFx1MDEzQlxcXFx1MDEzRFxcXFx1MDEzRlxcXFx1MDE0MVxcXFx1MDE0M1xcXFx1MDE0NVxcXFx1MDE0N1xcXFx1MDE0QVxcXFx1MDE0Q1xcXFx1MDE0RVxcXFx1MDE1MFxcXFx1MDE1MlxcXFx1MDE1NFxcXFx1MDE1NlxcXFx1MDE1OFxcXFx1MDE1QVxcXFx1MDE1Q1xcXFx1MDE1RVxcXFx1MDE2MFxcXFx1MDE2MlxcXFx1MDE2NFxcXFx1MDE2NlxcXFx1MDE2OFxcXFx1MDE2QVxcXFx1MDE2Q1xcXFx1MDE2RVxcXFx1MDE3MFxcXFx1MDE3MlxcXFx1MDE3NFxcXFx1MDE3NlxcXFx1MDE3OFxcXFx1MDE3OVxcXFx1MDE3QlxcXFx1MDE3RFxcXFx1MDE4MVxcXFx1MDE4MlxcXFx1MDE4NFxcXFx1MDE4NlxcXFx1MDE4N1xcXFx1MDE4OS1cXFxcdTAxOEJcXFxcdTAxOEUtXFxcXHUwMTkxXFxcXHUwMTkzXFxcXHUwMTk0XFxcXHUwMTk2LVxcXFx1MDE5OFxcXFx1MDE5Q1xcXFx1MDE5RFxcXFx1MDE5RlxcXFx1MDFBMFxcXFx1MDFBMlxcXFx1MDFBNFxcXFx1MDFBNlxcXFx1MDFBN1xcXFx1MDFBOVxcXFx1MDFBQ1xcXFx1MDFBRVxcXFx1MDFBRlxcXFx1MDFCMS1cXFxcdTAxQjNcXFxcdTAxQjVcXFxcdTAxQjdcXFxcdTAxQjhcXFxcdTAxQkNcXFxcdTAxQzRcXFxcdTAxQzdcXFxcdTAxQ0FcXFxcdTAxQ0RcXFxcdTAxQ0ZcXFxcdTAxRDFcXFxcdTAxRDNcXFxcdTAxRDVcXFxcdTAxRDdcXFxcdTAxRDlcXFxcdTAxREJcXFxcdTAxREVcXFxcdTAxRTBcXFxcdTAxRTJcXFxcdTAxRTRcXFxcdTAxRTZcXFxcdTAxRThcXFxcdTAxRUFcXFxcdTAxRUNcXFxcdTAxRUVcXFxcdTAxRjFcXFxcdTAxRjRcXFxcdTAxRjYtXFxcXHUwMUY4XFxcXHUwMUZBXFxcXHUwMUZDXFxcXHUwMUZFXFxcXHUwMjAwXFxcXHUwMjAyXFxcXHUwMjA0XFxcXHUwMjA2XFxcXHUwMjA4XFxcXHUwMjBBXFxcXHUwMjBDXFxcXHUwMjBFXFxcXHUwMjEwXFxcXHUwMjEyXFxcXHUwMjE0XFxcXHUwMjE2XFxcXHUwMjE4XFxcXHUwMjFBXFxcXHUwMjFDXFxcXHUwMjFFXFxcXHUwMjIwXFxcXHUwMjIyXFxcXHUwMjI0XFxcXHUwMjI2XFxcXHUwMjI4XFxcXHUwMjJBXFxcXHUwMjJDXFxcXHUwMjJFXFxcXHUwMjMwXFxcXHUwMjMyXFxcXHUwMjNBXFxcXHUwMjNCXFxcXHUwMjNEXFxcXHUwMjNFXFxcXHUwMjQxXFxcXHUwMjQzLVxcXFx1MDI0NlxcXFx1MDI0OFxcXFx1MDI0QVxcXFx1MDI0Q1xcXFx1MDI0RVxcXFx1MDM3MFxcXFx1MDM3MlxcXFx1MDM3NlxcXFx1MDM3RlxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOEFcXFxcdTAzOENcXFxcdTAzOEVcXFxcdTAzOEZcXFxcdTAzOTEtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNBQlxcXFx1MDNDRlxcXFx1MDNEMi1cXFxcdTAzRDRcXFxcdTAzRDhcXFxcdTAzREFcXFxcdTAzRENcXFxcdTAzREVcXFxcdTAzRTBcXFxcdTAzRTJcXFxcdTAzRTRcXFxcdTAzRTZcXFxcdTAzRThcXFxcdTAzRUFcXFxcdTAzRUNcXFxcdTAzRUVcXFxcdTAzRjRcXFxcdTAzRjdcXFxcdTAzRjlcXFxcdTAzRkFcXFxcdTAzRkQtXFxcXHUwNDJGXFxcXHUwNDYwXFxcXHUwNDYyXFxcXHUwNDY0XFxcXHUwNDY2XFxcXHUwNDY4XFxcXHUwNDZBXFxcXHUwNDZDXFxcXHUwNDZFXFxcXHUwNDcwXFxcXHUwNDcyXFxcXHUwNDc0XFxcXHUwNDc2XFxcXHUwNDc4XFxcXHUwNDdBXFxcXHUwNDdDXFxcXHUwNDdFXFxcXHUwNDgwXFxcXHUwNDhBXFxcXHUwNDhDXFxcXHUwNDhFXFxcXHUwNDkwXFxcXHUwNDkyXFxcXHUwNDk0XFxcXHUwNDk2XFxcXHUwNDk4XFxcXHUwNDlBXFxcXHUwNDlDXFxcXHUwNDlFXFxcXHUwNEEwXFxcXHUwNEEyXFxcXHUwNEE0XFxcXHUwNEE2XFxcXHUwNEE4XFxcXHUwNEFBXFxcXHUwNEFDXFxcXHUwNEFFXFxcXHUwNEIwXFxcXHUwNEIyXFxcXHUwNEI0XFxcXHUwNEI2XFxcXHUwNEI4XFxcXHUwNEJBXFxcXHUwNEJDXFxcXHUwNEJFXFxcXHUwNEMwXFxcXHUwNEMxXFxcXHUwNEMzXFxcXHUwNEM1XFxcXHUwNEM3XFxcXHUwNEM5XFxcXHUwNENCXFxcXHUwNENEXFxcXHUwNEQwXFxcXHUwNEQyXFxcXHUwNEQ0XFxcXHUwNEQ2XFxcXHUwNEQ4XFxcXHUwNERBXFxcXHUwNERDXFxcXHUwNERFXFxcXHUwNEUwXFxcXHUwNEUyXFxcXHUwNEU0XFxcXHUwNEU2XFxcXHUwNEU4XFxcXHUwNEVBXFxcXHUwNEVDXFxcXHUwNEVFXFxcXHUwNEYwXFxcXHUwNEYyXFxcXHUwNEY0XFxcXHUwNEY2XFxcXHUwNEY4XFxcXHUwNEZBXFxcXHUwNEZDXFxcXHUwNEZFXFxcXHUwNTAwXFxcXHUwNTAyXFxcXHUwNTA0XFxcXHUwNTA2XFxcXHUwNTA4XFxcXHUwNTBBXFxcXHUwNTBDXFxcXHUwNTBFXFxcXHUwNTEwXFxcXHUwNTEyXFxcXHUwNTE0XFxcXHUwNTE2XFxcXHUwNTE4XFxcXHUwNTFBXFxcXHUwNTFDXFxcXHUwNTFFXFxcXHUwNTIwXFxcXHUwNTIyXFxcXHUwNTI0XFxcXHUwNTI2XFxcXHUwNTI4XFxcXHUwNTJBXFxcXHUwNTJDXFxcXHUwNTJFXFxcXHUwNTMxLVxcXFx1MDU1NlxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwQzdcXFxcdTEwQ0RcXFxcdTEzQTAtXFxcXHUxM0Y1XFxcXHUxQzkwLVxcXFx1MUNCQVxcXFx1MUNCRC1cXFxcdTFDQkZcXFxcdTFFMDBcXFxcdTFFMDJcXFxcdTFFMDRcXFxcdTFFMDZcXFxcdTFFMDhcXFxcdTFFMEFcXFxcdTFFMENcXFxcdTFFMEVcXFxcdTFFMTBcXFxcdTFFMTJcXFxcdTFFMTRcXFxcdTFFMTZcXFxcdTFFMThcXFxcdTFFMUFcXFxcdTFFMUNcXFxcdTFFMUVcXFxcdTFFMjBcXFxcdTFFMjJcXFxcdTFFMjRcXFxcdTFFMjZcXFxcdTFFMjhcXFxcdTFFMkFcXFxcdTFFMkNcXFxcdTFFMkVcXFxcdTFFMzBcXFxcdTFFMzJcXFxcdTFFMzRcXFxcdTFFMzZcXFxcdTFFMzhcXFxcdTFFM0FcXFxcdTFFM0NcXFxcdTFFM0VcXFxcdTFFNDBcXFxcdTFFNDJcXFxcdTFFNDRcXFxcdTFFNDZcXFxcdTFFNDhcXFxcdTFFNEFcXFxcdTFFNENcXFxcdTFFNEVcXFxcdTFFNTBcXFxcdTFFNTJcXFxcdTFFNTRcXFxcdTFFNTZcXFxcdTFFNThcXFxcdTFFNUFcXFxcdTFFNUNcXFxcdTFFNUVcXFxcdTFFNjBcXFxcdTFFNjJcXFxcdTFFNjRcXFxcdTFFNjZcXFxcdTFFNjhcXFxcdTFFNkFcXFxcdTFFNkNcXFxcdTFFNkVcXFxcdTFFNzBcXFxcdTFFNzJcXFxcdTFFNzRcXFxcdTFFNzZcXFxcdTFFNzhcXFxcdTFFN0FcXFxcdTFFN0NcXFxcdTFFN0VcXFxcdTFFODBcXFxcdTFFODJcXFxcdTFFODRcXFxcdTFFODZcXFxcdTFFODhcXFxcdTFFOEFcXFxcdTFFOENcXFxcdTFFOEVcXFxcdTFFOTBcXFxcdTFFOTJcXFxcdTFFOTRcXFxcdTFFOUVcXFxcdTFFQTBcXFxcdTFFQTJcXFxcdTFFQTRcXFxcdTFFQTZcXFxcdTFFQThcXFxcdTFFQUFcXFxcdTFFQUNcXFxcdTFFQUVcXFxcdTFFQjBcXFxcdTFFQjJcXFxcdTFFQjRcXFxcdTFFQjZcXFxcdTFFQjhcXFxcdTFFQkFcXFxcdTFFQkNcXFxcdTFFQkVcXFxcdTFFQzBcXFxcdTFFQzJcXFxcdTFFQzRcXFxcdTFFQzZcXFxcdTFFQzhcXFxcdTFFQ0FcXFxcdTFFQ0NcXFxcdTFFQ0VcXFxcdTFFRDBcXFxcdTFFRDJcXFxcdTFFRDRcXFxcdTFFRDZcXFxcdTFFRDhcXFxcdTFFREFcXFxcdTFFRENcXFxcdTFFREVcXFxcdTFFRTBcXFxcdTFFRTJcXFxcdTFFRTRcXFxcdTFFRTZcXFxcdTFFRThcXFxcdTFFRUFcXFxcdTFFRUNcXFxcdTFFRUVcXFxcdTFFRjBcXFxcdTFFRjJcXFxcdTFFRjRcXFxcdTFFRjZcXFxcdTFFRjhcXFxcdTFFRkFcXFxcdTFFRkNcXFxcdTFFRkVcXFxcdTFGMDgtXFxcXHUxRjBGXFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyOC1cXFxcdTFGMkZcXFxcdTFGMzgtXFxcXHUxRjNGXFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1RlxcXFx1MUY2OC1cXFxcdTFGNkZcXFxcdTFGQjgtXFxcXHUxRkJCXFxcXHUxRkM4LVxcXFx1MUZDQlxcXFx1MUZEOC1cXFxcdTFGREJcXFxcdTFGRTgtXFxcXHUxRkVDXFxcXHUxRkY4LVxcXFx1MUZGQlxcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwQi1cXFxcdTIxMERcXFxcdTIxMTAtXFxcXHUyMTEyXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExRFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyQS1cXFxcdTIxMkRcXFxcdTIxMzAtXFxcXHUyMTMzXFxcXHUyMTNFXFxcXHUyMTNGXFxcXHUyMTQ1XFxcXHUyMTgzXFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkM2MFxcXFx1MkM2Mi1cXFxcdTJDNjRcXFxcdTJDNjdcXFxcdTJDNjlcXFxcdTJDNkJcXFxcdTJDNkQtXFxcXHUyQzcwXFxcXHUyQzcyXFxcXHUyQzc1XFxcXHUyQzdFLVxcXFx1MkM4MFxcXFx1MkM4MlxcXFx1MkM4NFxcXFx1MkM4NlxcXFx1MkM4OFxcXFx1MkM4QVxcXFx1MkM4Q1xcXFx1MkM4RVxcXFx1MkM5MFxcXFx1MkM5MlxcXFx1MkM5NFxcXFx1MkM5NlxcXFx1MkM5OFxcXFx1MkM5QVxcXFx1MkM5Q1xcXFx1MkM5RVxcXFx1MkNBMFxcXFx1MkNBMlxcXFx1MkNBNFxcXFx1MkNBNlxcXFx1MkNBOFxcXFx1MkNBQVxcXFx1MkNBQ1xcXFx1MkNBRVxcXFx1MkNCMFxcXFx1MkNCMlxcXFx1MkNCNFxcXFx1MkNCNlxcXFx1MkNCOFxcXFx1MkNCQVxcXFx1MkNCQ1xcXFx1MkNCRVxcXFx1MkNDMFxcXFx1MkNDMlxcXFx1MkNDNFxcXFx1MkNDNlxcXFx1MkNDOFxcXFx1MkNDQVxcXFx1MkNDQ1xcXFx1MkNDRVxcXFx1MkNEMFxcXFx1MkNEMlxcXFx1MkNENFxcXFx1MkNENlxcXFx1MkNEOFxcXFx1MkNEQVxcXFx1MkNEQ1xcXFx1MkNERVxcXFx1MkNFMFxcXFx1MkNFMlxcXFx1MkNFQlxcXFx1MkNFRFxcXFx1MkNGMlxcXFx1QTY0MFxcXFx1QTY0MlxcXFx1QTY0NFxcXFx1QTY0NlxcXFx1QTY0OFxcXFx1QTY0QVxcXFx1QTY0Q1xcXFx1QTY0RVxcXFx1QTY1MFxcXFx1QTY1MlxcXFx1QTY1NFxcXFx1QTY1NlxcXFx1QTY1OFxcXFx1QTY1QVxcXFx1QTY1Q1xcXFx1QTY1RVxcXFx1QTY2MFxcXFx1QTY2MlxcXFx1QTY2NFxcXFx1QTY2NlxcXFx1QTY2OFxcXFx1QTY2QVxcXFx1QTY2Q1xcXFx1QTY4MFxcXFx1QTY4MlxcXFx1QTY4NFxcXFx1QTY4NlxcXFx1QTY4OFxcXFx1QTY4QVxcXFx1QTY4Q1xcXFx1QTY4RVxcXFx1QTY5MFxcXFx1QTY5MlxcXFx1QTY5NFxcXFx1QTY5NlxcXFx1QTY5OFxcXFx1QTY5QVxcXFx1QTcyMlxcXFx1QTcyNFxcXFx1QTcyNlxcXFx1QTcyOFxcXFx1QTcyQVxcXFx1QTcyQ1xcXFx1QTcyRVxcXFx1QTczMlxcXFx1QTczNFxcXFx1QTczNlxcXFx1QTczOFxcXFx1QTczQVxcXFx1QTczQ1xcXFx1QTczRVxcXFx1QTc0MFxcXFx1QTc0MlxcXFx1QTc0NFxcXFx1QTc0NlxcXFx1QTc0OFxcXFx1QTc0QVxcXFx1QTc0Q1xcXFx1QTc0RVxcXFx1QTc1MFxcXFx1QTc1MlxcXFx1QTc1NFxcXFx1QTc1NlxcXFx1QTc1OFxcXFx1QTc1QVxcXFx1QTc1Q1xcXFx1QTc1RVxcXFx1QTc2MFxcXFx1QTc2MlxcXFx1QTc2NFxcXFx1QTc2NlxcXFx1QTc2OFxcXFx1QTc2QVxcXFx1QTc2Q1xcXFx1QTc2RVxcXFx1QTc3OVxcXFx1QTc3QlxcXFx1QTc3RFxcXFx1QTc3RVxcXFx1QTc4MFxcXFx1QTc4MlxcXFx1QTc4NFxcXFx1QTc4NlxcXFx1QTc4QlxcXFx1QTc4RFxcXFx1QTc5MFxcXFx1QTc5MlxcXFx1QTc5NlxcXFx1QTc5OFxcXFx1QTc5QVxcXFx1QTc5Q1xcXFx1QTc5RVxcXFx1QTdBMFxcXFx1QTdBMlxcXFx1QTdBNFxcXFx1QTdBNlxcXFx1QTdBOFxcXFx1QTdBQS1cXFxcdUE3QUVcXFxcdUE3QjAtXFxcXHVBN0I0XFxcXHVBN0I2XFxcXHVBN0I4XFxcXHVBN0JBXFxcXHVBN0JDXFxcXHVBN0JFXFxcXHVBN0MyXFxcXHVBN0M0LVxcXFx1QTdDN1xcXFx1QTdDOVxcXFx1QTdGNVxcXFx1RkYyMS1cXFxcdUZGM0FcIixcbk06XCJcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUwNDgzLVxcXFx1MDQ4OVxcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA2MTAtXFxcXHUwNjFBXFxcXHUwNjRCLVxcXFx1MDY1RlxcXFx1MDY3MFxcXFx1MDZENi1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU0XFxcXHUwNkU3XFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZFRFxcXFx1MDcxMVxcXFx1MDczMC1cXFxcdTA3NEFcXFxcdTA3QTYtXFxcXHUwN0IwXFxcXHUwN0VCLVxcXFx1MDdGM1xcXFx1MDdGRFxcXFx1MDgxNi1cXFxcdTA4MTlcXFxcdTA4MUItXFxcXHUwODIzXFxcXHUwODI1LVxcXFx1MDgyN1xcXFx1MDgyOS1cXFxcdTA4MkRcXFxcdTA4NTktXFxcXHUwODVCXFxcXHUwOEQzLVxcXFx1MDhFMVxcXFx1MDhFMy1cXFxcdTA5MDNcXFxcdTA5M0EtXFxcXHUwOTNDXFxcXHUwOTNFLVxcXFx1MDk0RlxcXFx1MDk1MS1cXFxcdTA5NTdcXFxcdTA5NjJcXFxcdTA5NjNcXFxcdTA5ODEtXFxcXHUwOTgzXFxcXHUwOUJDXFxcXHUwOUJFLVxcXFx1MDlDNFxcXFx1MDlDN1xcXFx1MDlDOFxcXFx1MDlDQi1cXFxcdTA5Q0RcXFxcdTA5RDdcXFxcdTA5RTJcXFxcdTA5RTNcXFxcdTA5RkVcXFxcdTBBMDEtXFxcXHUwQTAzXFxcXHUwQTNDXFxcXHUwQTNFLVxcXFx1MEE0MlxcXFx1MEE0N1xcXFx1MEE0OFxcXFx1MEE0Qi1cXFxcdTBBNERcXFxcdTBBNTFcXFxcdTBBNzBcXFxcdTBBNzFcXFxcdTBBNzVcXFxcdTBBODEtXFxcXHUwQTgzXFxcXHUwQUJDXFxcXHUwQUJFLVxcXFx1MEFDNVxcXFx1MEFDNy1cXFxcdTBBQzlcXFxcdTBBQ0ItXFxcXHUwQUNEXFxcXHUwQUUyXFxcXHUwQUUzXFxcXHUwQUZBLVxcXFx1MEFGRlxcXFx1MEIwMS1cXFxcdTBCMDNcXFxcdTBCM0NcXFxcdTBCM0UtXFxcXHUwQjQ0XFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCLVxcXFx1MEI0RFxcXFx1MEI1NS1cXFxcdTBCNTdcXFxcdTBCNjJcXFxcdTBCNjNcXFxcdTBCODJcXFxcdTBCQkUtXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0RcXFxcdTBCRDdcXFxcdTBDMDAtXFxcXHUwQzA0XFxcXHUwQzNFLVxcXFx1MEM0NFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzYyXFxcXHUwQzYzXFxcXHUwQzgxLVxcXFx1MEM4M1xcXFx1MENCQ1xcXFx1MENCRS1cXFxcdTBDQzRcXFxcdTBDQzYtXFxcXHUwQ0M4XFxcXHUwQ0NBLVxcXFx1MENDRFxcXFx1MENENVxcXFx1MENENlxcXFx1MENFMlxcXFx1MENFM1xcXFx1MEQwMC1cXFxcdTBEMDNcXFxcdTBEM0JcXFxcdTBEM0NcXFxcdTBEM0UtXFxcXHUwRDQ0XFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENERcXFxcdTBENTdcXFxcdTBENjJcXFxcdTBENjNcXFxcdTBEODEtXFxcXHUwRDgzXFxcXHUwRENBXFxcXHUwRENGLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERjJcXFxcdTBERjNcXFxcdTBFMzFcXFxcdTBFMzQtXFxcXHUwRTNBXFxcXHUwRTQ3LVxcXFx1MEU0RVxcXFx1MEVCMVxcXFx1MEVCNC1cXFxcdTBFQkNcXFxcdTBFQzgtXFxcXHUwRUNEXFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjM1XFxcXHUwRjM3XFxcXHUwRjM5XFxcXHUwRjNFXFxcXHUwRjNGXFxcXHUwRjcxLVxcXFx1MEY4NFxcXFx1MEY4NlxcXFx1MEY4N1xcXFx1MEY4RC1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDJCLVxcXFx1MTAzRVxcXFx1MTA1Ni1cXFxcdTEwNTlcXFxcdTEwNUUtXFxcXHUxMDYwXFxcXHUxMDYyLVxcXFx1MTA2NFxcXFx1MTA2Ny1cXFxcdTEwNkRcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyLVxcXFx1MTA4RFxcXFx1MTA4RlxcXFx1MTA5QS1cXFxcdTEwOURcXFxcdTEzNUQtXFxcXHUxMzVGXFxcXHUxNzEyLVxcXFx1MTcxNFxcXFx1MTczMi1cXFxcdTE3MzRcXFxcdTE3NTJcXFxcdTE3NTNcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3QjQtXFxcXHUxN0QzXFxcXHUxN0REXFxcXHUxODBCLVxcXFx1MTgwRFxcXFx1MTg4NVxcXFx1MTg4NlxcXFx1MThBOVxcXFx1MTkyMC1cXFxcdTE5MkJcXFxcdTE5MzAtXFxcXHUxOTNCXFxcXHUxQTE3LVxcXFx1MUExQlxcXFx1MUE1NS1cXFxcdTFBNUVcXFxcdTFBNjAtXFxcXHUxQTdDXFxcXHUxQTdGXFxcXHUxQUIwLVxcXFx1MUFDMFxcXFx1MUIwMC1cXFxcdTFCMDRcXFxcdTFCMzQtXFxcXHUxQjQ0XFxcXHUxQjZCLVxcXFx1MUI3M1xcXFx1MUI4MC1cXFxcdTFCODJcXFxcdTFCQTEtXFxcXHUxQkFEXFxcXHUxQkU2LVxcXFx1MUJGM1xcXFx1MUMyNC1cXFxcdTFDMzdcXFxcdTFDRDAtXFxcXHUxQ0QyXFxcXHUxQ0Q0LVxcXFx1MUNFOFxcXFx1MUNFRFxcXFx1MUNGNFxcXFx1MUNGNy1cXFxcdTFDRjlcXFxcdTFEQzAtXFxcXHUxREY5XFxcXHUxREZCLVxcXFx1MURGRlxcXFx1MjBEMC1cXFxcdTIwRjBcXFxcdTJDRUYtXFxcXHUyQ0YxXFxcXHUyRDdGXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MzAyQS1cXFxcdTMwMkZcXFxcdTMwOTlcXFxcdTMwOUFcXFxcdUE2NkYtXFxcXHVBNjcyXFxcXHVBNjc0LVxcXFx1QTY3RFxcXFx1QTY5RVxcXFx1QTY5RlxcXFx1QTZGMFxcXFx1QTZGMVxcXFx1QTgwMlxcXFx1QTgwNlxcXFx1QTgwQlxcXFx1QTgyMy1cXFxcdUE4MjdcXFxcdUE4MkNcXFxcdUE4ODBcXFxcdUE4ODFcXFxcdUE4QjQtXFxcXHVBOEM1XFxcXHVBOEUwLVxcXFx1QThGMVxcXFx1QThGRlxcXFx1QTkyNi1cXFxcdUE5MkRcXFxcdUE5NDctXFxcXHVBOTUzXFxcXHVBOTgwLVxcXFx1QTk4M1xcXFx1QTlCMy1cXFxcdUE5QzBcXFxcdUE5RTVcXFxcdUFBMjktXFxcXHVBQTM2XFxcXHVBQTQzXFxcXHVBQTRDXFxcXHVBQTREXFxcXHVBQTdCLVxcXFx1QUE3RFxcXFx1QUFCMFxcXFx1QUFCMi1cXFxcdUFBQjRcXFxcdUFBQjdcXFxcdUFBQjhcXFxcdUFBQkVcXFxcdUFBQkZcXFxcdUFBQzFcXFxcdUFBRUItXFxcXHVBQUVGXFxcXHVBQUY1XFxcXHVBQUY2XFxcXHVBQkUzLVxcXFx1QUJFQVxcXFx1QUJFQ1xcXFx1QUJFRFxcXFx1RkIxRVxcXFx1RkUwMC1cXFxcdUZFMEZcXFxcdUZFMjAtXFxcXHVGRTJGXCIsXG5NYzpcIlxcXFx1MDkwM1xcXFx1MDkzQlxcXFx1MDkzRS1cXFxcdTA5NDBcXFxcdTA5NDktXFxcXHUwOTRDXFxcXHUwOTRFXFxcXHUwOTRGXFxcXHUwOTgyXFxcXHUwOTgzXFxcXHUwOUJFLVxcXFx1MDlDMFxcXFx1MDlDN1xcXFx1MDlDOFxcXFx1MDlDQlxcXFx1MDlDQ1xcXFx1MDlEN1xcXFx1MEEwM1xcXFx1MEEzRS1cXFxcdTBBNDBcXFxcdTBBODNcXFxcdTBBQkUtXFxcXHUwQUMwXFxcXHUwQUM5XFxcXHUwQUNCXFxcXHUwQUNDXFxcXHUwQjAyXFxcXHUwQjAzXFxcXHUwQjNFXFxcXHUwQjQwXFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCXFxcXHUwQjRDXFxcXHUwQjU3XFxcXHUwQkJFXFxcXHUwQkJGXFxcXHUwQkMxXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0NcXFxcdTBCRDdcXFxcdTBDMDEtXFxcXHUwQzAzXFxcXHUwQzQxLVxcXFx1MEM0NFxcXFx1MEM4MlxcXFx1MEM4M1xcXFx1MENCRVxcXFx1MENDMC1cXFxcdTBDQzRcXFxcdTBDQzdcXFxcdTBDQzhcXFxcdTBDQ0FcXFxcdTBDQ0JcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBEMDJcXFxcdTBEMDNcXFxcdTBEM0UtXFxcXHUwRDQwXFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENENcXFxcdTBENTdcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEQ0YtXFxcXHUwREQxXFxcXHUwREQ4LVxcXFx1MERERlxcXFx1MERGMlxcXFx1MERGM1xcXFx1MEYzRVxcXFx1MEYzRlxcXFx1MEY3RlxcXFx1MTAyQlxcXFx1MTAyQ1xcXFx1MTAzMVxcXFx1MTAzOFxcXFx1MTAzQlxcXFx1MTAzQ1xcXFx1MTA1NlxcXFx1MTA1N1xcXFx1MTA2Mi1cXFxcdTEwNjRcXFxcdTEwNjctXFxcXHUxMDZEXFxcXHUxMDgzXFxcXHUxMDg0XFxcXHUxMDg3LVxcXFx1MTA4Q1xcXFx1MTA4RlxcXFx1MTA5QS1cXFxcdTEwOUNcXFxcdTE3QjZcXFxcdTE3QkUtXFxcXHUxN0M1XFxcXHUxN0M3XFxcXHUxN0M4XFxcXHUxOTIzLVxcXFx1MTkyNlxcXFx1MTkyOS1cXFxcdTE5MkJcXFxcdTE5MzBcXFxcdTE5MzFcXFxcdTE5MzMtXFxcXHUxOTM4XFxcXHUxQTE5XFxcXHUxQTFBXFxcXHUxQTU1XFxcXHUxQTU3XFxcXHUxQTYxXFxcXHUxQTYzXFxcXHUxQTY0XFxcXHUxQTZELVxcXFx1MUE3MlxcXFx1MUIwNFxcXFx1MUIzNVxcXFx1MUIzQlxcXFx1MUIzRC1cXFxcdTFCNDFcXFxcdTFCNDNcXFxcdTFCNDRcXFxcdTFCODJcXFxcdTFCQTFcXFxcdTFCQTZcXFxcdTFCQTdcXFxcdTFCQUFcXFxcdTFCRTdcXFxcdTFCRUEtXFxcXHUxQkVDXFxcXHUxQkVFXFxcXHUxQkYyXFxcXHUxQkYzXFxcXHUxQzI0LVxcXFx1MUMyQlxcXFx1MUMzNFxcXFx1MUMzNVxcXFx1MUNFMVxcXFx1MUNGN1xcXFx1MzAyRVxcXFx1MzAyRlxcXFx1QTgyM1xcXFx1QTgyNFxcXFx1QTgyN1xcXFx1QTg4MFxcXFx1QTg4MVxcXFx1QThCNC1cXFxcdUE4QzNcXFxcdUE5NTJcXFxcdUE5NTNcXFxcdUE5ODNcXFxcdUE5QjRcXFxcdUE5QjVcXFxcdUE5QkFcXFxcdUE5QkJcXFxcdUE5QkUtXFxcXHVBOUMwXFxcXHVBQTJGXFxcXHVBQTMwXFxcXHVBQTMzXFxcXHVBQTM0XFxcXHVBQTREXFxcXHVBQTdCXFxcXHVBQTdEXFxcXHVBQUVCXFxcXHVBQUVFXFxcXHVBQUVGXFxcXHVBQUY1XFxcXHVBQkUzXFxcXHVBQkU0XFxcXHVBQkU2XFxcXHVBQkU3XFxcXHVBQkU5XFxcXHVBQkVBXFxcXHVBQkVDXCIsXG5NZTpcIlxcXFx1MDQ4OFxcXFx1MDQ4OVxcXFx1MUFCRVxcXFx1MjBERC1cXFxcdTIwRTBcXFxcdTIwRTItXFxcXHUyMEU0XFxcXHVBNjcwLVxcXFx1QTY3MlwiLE1uOlwiXFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MDQ4My1cXFxcdTA0ODdcXFxcdTA1OTEtXFxcXHUwNUJEXFxcXHUwNUJGXFxcXHUwNUMxXFxcXHUwNUMyXFxcXHUwNUM0XFxcXHUwNUM1XFxcXHUwNUM3XFxcXHUwNjEwLVxcXFx1MDYxQVxcXFx1MDY0Qi1cXFxcdTA2NUZcXFxcdTA2NzBcXFxcdTA2RDYtXFxcXHUwNkRDXFxcXHUwNkRGLVxcXFx1MDZFNFxcXFx1MDZFN1xcXFx1MDZFOFxcXFx1MDZFQS1cXFxcdTA2RURcXFxcdTA3MTFcXFxcdTA3MzAtXFxcXHUwNzRBXFxcXHUwN0E2LVxcXFx1MDdCMFxcXFx1MDdFQi1cXFxcdTA3RjNcXFxcdTA3RkRcXFxcdTA4MTYtXFxcXHUwODE5XFxcXHUwODFCLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJEXFxcXHUwODU5LVxcXFx1MDg1QlxcXFx1MDhEMy1cXFxcdTA4RTFcXFxcdTA4RTMtXFxcXHUwOTAyXFxcXHUwOTNBXFxcXHUwOTNDXFxcXHUwOTQxLVxcXFx1MDk0OFxcXFx1MDk0RFxcXFx1MDk1MS1cXFxcdTA5NTdcXFxcdTA5NjJcXFxcdTA5NjNcXFxcdTA5ODFcXFxcdTA5QkNcXFxcdTA5QzEtXFxcXHUwOUM0XFxcXHUwOUNEXFxcXHUwOUUyXFxcXHUwOUUzXFxcXHUwOUZFXFxcXHUwQTAxXFxcXHUwQTAyXFxcXHUwQTNDXFxcXHUwQTQxXFxcXHUwQTQyXFxcXHUwQTQ3XFxcXHUwQTQ4XFxcXHUwQTRCLVxcXFx1MEE0RFxcXFx1MEE1MVxcXFx1MEE3MFxcXFx1MEE3MVxcXFx1MEE3NVxcXFx1MEE4MVxcXFx1MEE4MlxcXFx1MEFCQ1xcXFx1MEFDMS1cXFxcdTBBQzVcXFxcdTBBQzdcXFxcdTBBQzhcXFxcdTBBQ0RcXFxcdTBBRTJcXFxcdTBBRTNcXFxcdTBBRkEtXFxcXHUwQUZGXFxcXHUwQjAxXFxcXHUwQjNDXFxcXHUwQjNGXFxcXHUwQjQxLVxcXFx1MEI0NFxcXFx1MEI0RFxcXFx1MEI1NVxcXFx1MEI1NlxcXFx1MEI2MlxcXFx1MEI2M1xcXFx1MEI4MlxcXFx1MEJDMFxcXFx1MEJDRFxcXFx1MEMwMFxcXFx1MEMwNFxcXFx1MEMzRS1cXFxcdTBDNDBcXFxcdTBDNDYtXFxcXHUwQzQ4XFxcXHUwQzRBLVxcXFx1MEM0RFxcXFx1MEM1NVxcXFx1MEM1NlxcXFx1MEM2MlxcXFx1MEM2M1xcXFx1MEM4MVxcXFx1MENCQ1xcXFx1MENCRlxcXFx1MENDNlxcXFx1MENDQ1xcXFx1MENDRFxcXFx1MENFMlxcXFx1MENFM1xcXFx1MEQwMFxcXFx1MEQwMVxcXFx1MEQzQlxcXFx1MEQzQ1xcXFx1MEQ0MS1cXFxcdTBENDRcXFxcdTBENERcXFxcdTBENjJcXFxcdTBENjNcXFxcdTBEODFcXFxcdTBEQ0FcXFxcdTBERDItXFxcXHUwREQ0XFxcXHUwREQ2XFxcXHUwRTMxXFxcXHUwRTM0LVxcXFx1MEUzQVxcXFx1MEU0Ny1cXFxcdTBFNEVcXFxcdTBFQjFcXFxcdTBFQjQtXFxcXHUwRUJDXFxcXHUwRUM4LVxcXFx1MEVDRFxcXFx1MEYxOFxcXFx1MEYxOVxcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOVxcXFx1MEY3MS1cXFxcdTBGN0VcXFxcdTBGODAtXFxcXHUwRjg0XFxcXHUwRjg2XFxcXHUwRjg3XFxcXHUwRjhELVxcXFx1MEY5N1xcXFx1MEY5OS1cXFxcdTBGQkNcXFxcdTBGQzZcXFxcdTEwMkQtXFxcXHUxMDMwXFxcXHUxMDMyLVxcXFx1MTAzN1xcXFx1MTAzOVxcXFx1MTAzQVxcXFx1MTAzRFxcXFx1MTAzRVxcXFx1MTA1OFxcXFx1MTA1OVxcXFx1MTA1RS1cXFxcdTEwNjBcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyXFxcXHUxMDg1XFxcXHUxMDg2XFxcXHUxMDhEXFxcXHUxMDlEXFxcXHUxMzVELVxcXFx1MTM1RlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN0I0XFxcXHUxN0I1XFxcXHUxN0I3LVxcXFx1MTdCRFxcXFx1MTdDNlxcXFx1MTdDOS1cXFxcdTE3RDNcXFxcdTE3RERcXFxcdTE4MEItXFxcXHUxODBEXFxcXHUxODg1XFxcXHUxODg2XFxcXHUxOEE5XFxcXHUxOTIwLVxcXFx1MTkyMlxcXFx1MTkyN1xcXFx1MTkyOFxcXFx1MTkzMlxcXFx1MTkzOS1cXFxcdTE5M0JcXFxcdTFBMTdcXFxcdTFBMThcXFxcdTFBMUJcXFxcdTFBNTZcXFxcdTFBNTgtXFxcXHUxQTVFXFxcXHUxQTYwXFxcXHUxQTYyXFxcXHUxQTY1LVxcXFx1MUE2Q1xcXFx1MUE3My1cXFxcdTFBN0NcXFxcdTFBN0ZcXFxcdTFBQjAtXFxcXHUxQUJEXFxcXHUxQUJGXFxcXHUxQUMwXFxcXHUxQjAwLVxcXFx1MUIwM1xcXFx1MUIzNFxcXFx1MUIzNi1cXFxcdTFCM0FcXFxcdTFCM0NcXFxcdTFCNDJcXFxcdTFCNkItXFxcXHUxQjczXFxcXHUxQjgwXFxcXHUxQjgxXFxcXHUxQkEyLVxcXFx1MUJBNVxcXFx1MUJBOFxcXFx1MUJBOVxcXFx1MUJBQi1cXFxcdTFCQURcXFxcdTFCRTZcXFxcdTFCRThcXFxcdTFCRTlcXFxcdTFCRURcXFxcdTFCRUYtXFxcXHUxQkYxXFxcXHUxQzJDLVxcXFx1MUMzM1xcXFx1MUMzNlxcXFx1MUMzN1xcXFx1MUNEMC1cXFxcdTFDRDJcXFxcdTFDRDQtXFxcXHUxQ0UwXFxcXHUxQ0UyLVxcXFx1MUNFOFxcXFx1MUNFRFxcXFx1MUNGNFxcXFx1MUNGOFxcXFx1MUNGOVxcXFx1MURDMC1cXFxcdTFERjlcXFxcdTFERkItXFxcXHUxREZGXFxcXHUyMEQwLVxcXFx1MjBEQ1xcXFx1MjBFMVxcXFx1MjBFNS1cXFxcdTIwRjBcXFxcdTJDRUYtXFxcXHUyQ0YxXFxcXHUyRDdGXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MzAyQS1cXFxcdTMwMkRcXFxcdTMwOTlcXFxcdTMwOUFcXFxcdUE2NkZcXFxcdUE2NzQtXFxcXHVBNjdEXFxcXHVBNjlFXFxcXHVBNjlGXFxcXHVBNkYwXFxcXHVBNkYxXFxcXHVBODAyXFxcXHVBODA2XFxcXHVBODBCXFxcXHVBODI1XFxcXHVBODI2XFxcXHVBODJDXFxcXHVBOEM0XFxcXHVBOEM1XFxcXHVBOEUwLVxcXFx1QThGMVxcXFx1QThGRlxcXFx1QTkyNi1cXFxcdUE5MkRcXFxcdUE5NDctXFxcXHVBOTUxXFxcXHVBOTgwLVxcXFx1QTk4MlxcXFx1QTlCM1xcXFx1QTlCNi1cXFxcdUE5QjlcXFxcdUE5QkNcXFxcdUE5QkRcXFxcdUE5RTVcXFxcdUFBMjktXFxcXHVBQTJFXFxcXHVBQTMxXFxcXHVBQTMyXFxcXHVBQTM1XFxcXHVBQTM2XFxcXHVBQTQzXFxcXHVBQTRDXFxcXHVBQTdDXFxcXHVBQUIwXFxcXHVBQUIyLVxcXFx1QUFCNFxcXFx1QUFCN1xcXFx1QUFCOFxcXFx1QUFCRVxcXFx1QUFCRlxcXFx1QUFDMVxcXFx1QUFFQ1xcXFx1QUFFRFxcXFx1QUFGNlxcXFx1QUJFNVxcXFx1QUJFOFxcXFx1QUJFRFxcXFx1RkIxRVxcXFx1RkUwMC1cXFxcdUZFMEZcXFxcdUZFMjAtXFxcXHVGRTJGXCIsXG5OZDpcIjAtOVxcXFx1MDY2MC1cXFxcdTA2NjlcXFxcdTA2RjAtXFxcXHUwNkY5XFxcXHUwN0MwLVxcXFx1MDdDOVxcXFx1MDk2Ni1cXFxcdTA5NkZcXFxcdTA5RTYtXFxcXHUwOUVGXFxcXHUwQTY2LVxcXFx1MEE2RlxcXFx1MEFFNi1cXFxcdTBBRUZcXFxcdTBCNjYtXFxcXHUwQjZGXFxcXHUwQkU2LVxcXFx1MEJFRlxcXFx1MEM2Ni1cXFxcdTBDNkZcXFxcdTBDRTYtXFxcXHUwQ0VGXFxcXHUwRDY2LVxcXFx1MEQ2RlxcXFx1MERFNi1cXFxcdTBERUZcXFxcdTBFNTAtXFxcXHUwRTU5XFxcXHUwRUQwLVxcXFx1MEVEOVxcXFx1MEYyMC1cXFxcdTBGMjlcXFxcdTEwNDAtXFxcXHUxMDQ5XFxcXHUxMDkwLVxcXFx1MTA5OVxcXFx1MTdFMC1cXFxcdTE3RTlcXFxcdTE4MTAtXFxcXHUxODE5XFxcXHUxOTQ2LVxcXFx1MTk0RlxcXFx1MTlEMC1cXFxcdTE5RDlcXFxcdTFBODAtXFxcXHUxQTg5XFxcXHUxQTkwLVxcXFx1MUE5OVxcXFx1MUI1MC1cXFxcdTFCNTlcXFxcdTFCQjAtXFxcXHUxQkI5XFxcXHUxQzQwLVxcXFx1MUM0OVxcXFx1MUM1MC1cXFxcdTFDNTlcXFxcdUE2MjAtXFxcXHVBNjI5XFxcXHVBOEQwLVxcXFx1QThEOVxcXFx1QTkwMC1cXFxcdUE5MDlcXFxcdUE5RDAtXFxcXHVBOUQ5XFxcXHVBOUYwLVxcXFx1QTlGOVxcXFx1QUE1MC1cXFxcdUFBNTlcXFxcdUFCRjAtXFxcXHVBQkY5XFxcXHVGRjEwLVxcXFx1RkYxOVwiLFxuTmw6XCJcXFxcdTE2RUUtXFxcXHUxNkYwXFxcXHUyMTYwLVxcXFx1MjE4MlxcXFx1MjE4NS1cXFxcdTIxODhcXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDI5XFxcXHUzMDM4LVxcXFx1MzAzQVxcXFx1QTZFNi1cXFxcdUE2RUZcIixObzpcIlxcXFx4QjJcXFxceEIzXFxcXHhCOVxcXFx4QkMtXFxcXHhCRVxcXFx1MDlGNC1cXFxcdTA5RjlcXFxcdTBCNzItXFxcXHUwQjc3XFxcXHUwQkYwLVxcXFx1MEJGMlxcXFx1MEM3OC1cXFxcdTBDN0VcXFxcdTBENTgtXFxcXHUwRDVFXFxcXHUwRDcwLVxcXFx1MEQ3OFxcXFx1MEYyQS1cXFxcdTBGMzNcXFxcdTEzNjktXFxcXHUxMzdDXFxcXHUxN0YwLVxcXFx1MTdGOVxcXFx1MTlEQVxcXFx1MjA3MFxcXFx1MjA3NC1cXFxcdTIwNzlcXFxcdTIwODAtXFxcXHUyMDg5XFxcXHUyMTUwLVxcXFx1MjE1RlxcXFx1MjE4OVxcXFx1MjQ2MC1cXFxcdTI0OUJcXFxcdTI0RUEtXFxcXHUyNEZGXFxcXHUyNzc2LVxcXFx1Mjc5M1xcXFx1MkNGRFxcXFx1MzE5Mi1cXFxcdTMxOTVcXFxcdTMyMjAtXFxcXHUzMjI5XFxcXHUzMjQ4LVxcXFx1MzI0RlxcXFx1MzI1MS1cXFxcdTMyNUZcXFxcdTMyODAtXFxcXHUzMjg5XFxcXHUzMkIxLVxcXFx1MzJCRlxcXFx1QTgzMC1cXFxcdUE4MzVcIixQYzpcIl9cXFxcdTIwM0ZcXFxcdTIwNDBcXFxcdTIwNTRcXFxcdUZFMzNcXFxcdUZFMzRcXFxcdUZFNEQtXFxcXHVGRTRGXFxcXHVGRjNGXCIsXG5QZDpcIlxcXFwtXFxcXHUwNThBXFxcXHUwNUJFXFxcXHUxNDAwXFxcXHUxODA2XFxcXHUyMDEwLVxcXFx1MjAxNVxcXFx1MkUxN1xcXFx1MkUxQVxcXFx1MkUzQVxcXFx1MkUzQlxcXFx1MkU0MFxcXFx1MzAxQ1xcXFx1MzAzMFxcXFx1MzBBMFxcXFx1RkUzMVxcXFx1RkUzMlxcXFx1RkU1OFxcXFx1RkU2M1xcXFx1RkYwRFwiLFBlOlwiXFxcXClcXFxcXVxcXFx9XFxcXHUwRjNCXFxcXHUwRjNEXFxcXHUxNjlDXFxcXHUyMDQ2XFxcXHUyMDdFXFxcXHUyMDhFXFxcXHUyMzA5XFxcXHUyMzBCXFxcXHUyMzJBXFxcXHUyNzY5XFxcXHUyNzZCXFxcXHUyNzZEXFxcXHUyNzZGXFxcXHUyNzcxXFxcXHUyNzczXFxcXHUyNzc1XFxcXHUyN0M2XFxcXHUyN0U3XFxcXHUyN0U5XFxcXHUyN0VCXFxcXHUyN0VEXFxcXHUyN0VGXFxcXHUyOTg0XFxcXHUyOTg2XFxcXHUyOTg4XFxcXHUyOThBXFxcXHUyOThDXFxcXHUyOThFXFxcXHUyOTkwXFxcXHUyOTkyXFxcXHUyOTk0XFxcXHUyOTk2XFxcXHUyOTk4XFxcXHUyOUQ5XFxcXHUyOURCXFxcXHUyOUZEXFxcXHUyRTIzXFxcXHUyRTI1XFxcXHUyRTI3XFxcXHUyRTI5XFxcXHUzMDA5XFxcXHUzMDBCXFxcXHUzMDBEXFxcXHUzMDBGXFxcXHUzMDExXFxcXHUzMDE1XFxcXHUzMDE3XFxcXHUzMDE5XFxcXHUzMDFCXFxcXHUzMDFFXFxcXHUzMDFGXFxcXHVGRDNFXFxcXHVGRTE4XFxcXHVGRTM2XFxcXHVGRTM4XFxcXHVGRTNBXFxcXHVGRTNDXFxcXHVGRTNFXFxcXHVGRTQwXFxcXHVGRTQyXFxcXHVGRTQ0XFxcXHVGRTQ4XFxcXHVGRTVBXFxcXHVGRTVDXFxcXHVGRTVFXFxcXHVGRjA5XFxcXHVGRjNEXFxcXHVGRjVEXFxcXHVGRjYwXFxcXHVGRjYzXCIsXG5QZjpcIlxcXFx4QkJcXFxcdTIwMTlcXFxcdTIwMURcXFxcdTIwM0FcXFxcdTJFMDNcXFxcdTJFMDVcXFxcdTJFMEFcXFxcdTJFMERcXFxcdTJFMURcXFxcdTJFMjFcIixQaTpcIlxcXFx4QUJcXFxcdTIwMThcXFxcdTIwMUJcXFxcdTIwMUNcXFxcdTIwMUZcXFxcdTIwMzlcXFxcdTJFMDJcXFxcdTJFMDRcXFxcdTJFMDlcXFxcdTJFMENcXFxcdTJFMUNcXFxcdTJFMjBcIixQbzpcIiEtIyUtJ1xcXFwqLFxcXFwuXFxcXC86O1xcXFw/QFxcXFx4QTFcXFxceEE3XFxcXHhCNlxcXFx4QjdcXFxceEJGXFxcXHUwMzdFXFxcXHUwMzg3XFxcXHUwNTVBLVxcXFx1MDU1RlxcXFx1MDU4OVxcXFx1MDVDMFxcXFx1MDVDM1xcXFx1MDVDNlxcXFx1MDVGM1xcXFx1MDVGNFxcXFx1MDYwOVxcXFx1MDYwQVxcXFx1MDYwQ1xcXFx1MDYwRFxcXFx1MDYxQlxcXFx1MDYxRVxcXFx1MDYxRlxcXFx1MDY2QS1cXFxcdTA2NkRcXFxcdTA2RDRcXFxcdTA3MDAtXFxcXHUwNzBEXFxcXHUwN0Y3LVxcXFx1MDdGOVxcXFx1MDgzMC1cXFxcdTA4M0VcXFxcdTA4NUVcXFxcdTA5NjRcXFxcdTA5NjVcXFxcdTA5NzBcXFxcdTA5RkRcXFxcdTBBNzZcXFxcdTBBRjBcXFxcdTBDNzdcXFxcdTBDODRcXFxcdTBERjRcXFxcdTBFNEZcXFxcdTBFNUFcXFxcdTBFNUJcXFxcdTBGMDQtXFxcXHUwRjEyXFxcXHUwRjE0XFxcXHUwRjg1XFxcXHUwRkQwLVxcXFx1MEZENFxcXFx1MEZEOVxcXFx1MEZEQVxcXFx1MTA0QS1cXFxcdTEwNEZcXFxcdTEwRkJcXFxcdTEzNjAtXFxcXHUxMzY4XFxcXHUxNjZFXFxcXHUxNkVCLVxcXFx1MTZFRFxcXFx1MTczNVxcXFx1MTczNlxcXFx1MTdENC1cXFxcdTE3RDZcXFxcdTE3RDgtXFxcXHUxN0RBXFxcXHUxODAwLVxcXFx1MTgwNVxcXFx1MTgwNy1cXFxcdTE4MEFcXFxcdTE5NDRcXFxcdTE5NDVcXFxcdTFBMUVcXFxcdTFBMUZcXFxcdTFBQTAtXFxcXHUxQUE2XFxcXHUxQUE4LVxcXFx1MUFBRFxcXFx1MUI1QS1cXFxcdTFCNjBcXFxcdTFCRkMtXFxcXHUxQkZGXFxcXHUxQzNCLVxcXFx1MUMzRlxcXFx1MUM3RVxcXFx1MUM3RlxcXFx1MUNDMC1cXFxcdTFDQzdcXFxcdTFDRDNcXFxcdTIwMTZcXFxcdTIwMTdcXFxcdTIwMjAtXFxcXHUyMDI3XFxcXHUyMDMwLVxcXFx1MjAzOFxcXFx1MjAzQi1cXFxcdTIwM0VcXFxcdTIwNDEtXFxcXHUyMDQzXFxcXHUyMDQ3LVxcXFx1MjA1MVxcXFx1MjA1M1xcXFx1MjA1NS1cXFxcdTIwNUVcXFxcdTJDRjktXFxcXHUyQ0ZDXFxcXHUyQ0ZFXFxcXHUyQ0ZGXFxcXHUyRDcwXFxcXHUyRTAwXFxcXHUyRTAxXFxcXHUyRTA2LVxcXFx1MkUwOFxcXFx1MkUwQlxcXFx1MkUwRS1cXFxcdTJFMTZcXFxcdTJFMThcXFxcdTJFMTlcXFxcdTJFMUJcXFxcdTJFMUVcXFxcdTJFMUZcXFxcdTJFMkEtXFxcXHUyRTJFXFxcXHUyRTMwLVxcXFx1MkUzOVxcXFx1MkUzQy1cXFxcdTJFM0ZcXFxcdTJFNDFcXFxcdTJFNDMtXFxcXHUyRTRGXFxcXHUyRTUyXFxcXHUzMDAxLVxcXFx1MzAwM1xcXFx1MzAzRFxcXFx1MzBGQlxcXFx1QTRGRVxcXFx1QTRGRlxcXFx1QTYwRC1cXFxcdUE2MEZcXFxcdUE2NzNcXFxcdUE2N0VcXFxcdUE2RjItXFxcXHVBNkY3XFxcXHVBODc0LVxcXFx1QTg3N1xcXFx1QThDRVxcXFx1QThDRlxcXFx1QThGOC1cXFxcdUE4RkFcXFxcdUE4RkNcXFxcdUE5MkVcXFxcdUE5MkZcXFxcdUE5NUZcXFxcdUE5QzEtXFxcXHVBOUNEXFxcXHVBOURFXFxcXHVBOURGXFxcXHVBQTVDLVxcXFx1QUE1RlxcXFx1QUFERVxcXFx1QUFERlxcXFx1QUFGMFxcXFx1QUFGMVxcXFx1QUJFQlxcXFx1RkUxMC1cXFxcdUZFMTZcXFxcdUZFMTlcXFxcdUZFMzBcXFxcdUZFNDVcXFxcdUZFNDZcXFxcdUZFNDktXFxcXHVGRTRDXFxcXHVGRTUwLVxcXFx1RkU1MlxcXFx1RkU1NC1cXFxcdUZFNTdcXFxcdUZFNUYtXFxcXHVGRTYxXFxcXHVGRTY4XFxcXHVGRTZBXFxcXHVGRTZCXFxcXHVGRjAxLVxcXFx1RkYwM1xcXFx1RkYwNS1cXFxcdUZGMDdcXFxcdUZGMEFcXFxcdUZGMENcXFxcdUZGMEVcXFxcdUZGMEZcXFxcdUZGMUFcXFxcdUZGMUJcXFxcdUZGMUZcXFxcdUZGMjBcXFxcdUZGM0NcXFxcdUZGNjFcXFxcdUZGNjRcXFxcdUZGNjVcIixcblBzOlwiXFxcXChcXFxcW1xcXFx7XFxcXHUwRjNBXFxcXHUwRjNDXFxcXHUxNjlCXFxcXHUyMDFBXFxcXHUyMDFFXFxcXHUyMDQ1XFxcXHUyMDdEXFxcXHUyMDhEXFxcXHUyMzA4XFxcXHUyMzBBXFxcXHUyMzI5XFxcXHUyNzY4XFxcXHUyNzZBXFxcXHUyNzZDXFxcXHUyNzZFXFxcXHUyNzcwXFxcXHUyNzcyXFxcXHUyNzc0XFxcXHUyN0M1XFxcXHUyN0U2XFxcXHUyN0U4XFxcXHUyN0VBXFxcXHUyN0VDXFxcXHUyN0VFXFxcXHUyOTgzXFxcXHUyOTg1XFxcXHUyOTg3XFxcXHUyOTg5XFxcXHUyOThCXFxcXHUyOThEXFxcXHUyOThGXFxcXHUyOTkxXFxcXHUyOTkzXFxcXHUyOTk1XFxcXHUyOTk3XFxcXHUyOUQ4XFxcXHUyOURBXFxcXHUyOUZDXFxcXHUyRTIyXFxcXHUyRTI0XFxcXHUyRTI2XFxcXHUyRTI4XFxcXHUyRTQyXFxcXHUzMDA4XFxcXHUzMDBBXFxcXHUzMDBDXFxcXHUzMDBFXFxcXHUzMDEwXFxcXHUzMDE0XFxcXHUzMDE2XFxcXHUzMDE4XFxcXHUzMDFBXFxcXHUzMDFEXFxcXHVGRDNGXFxcXHVGRTE3XFxcXHVGRTM1XFxcXHVGRTM3XFxcXHVGRTM5XFxcXHVGRTNCXFxcXHVGRTNEXFxcXHVGRTNGXFxcXHVGRTQxXFxcXHVGRTQzXFxcXHVGRTQ3XFxcXHVGRTU5XFxcXHVGRTVCXFxcXHVGRTVEXFxcXHVGRjA4XFxcXHVGRjNCXFxcXHVGRjVCXFxcXHVGRjVGXFxcXHVGRjYyXCIsXG5TYzpcIlxcXFwkXFxcXHhBMi1cXFxceEE1XFxcXHUwNThGXFxcXHUwNjBCXFxcXHUwN0ZFXFxcXHUwN0ZGXFxcXHUwOUYyXFxcXHUwOUYzXFxcXHUwOUZCXFxcXHUwQUYxXFxcXHUwQkY5XFxcXHUwRTNGXFxcXHUxN0RCXFxcXHUyMEEwLVxcXFx1MjBCRlxcXFx1QTgzOFxcXFx1RkRGQ1xcXFx1RkU2OVxcXFx1RkYwNFxcXFx1RkZFMFxcXFx1RkZFMVxcXFx1RkZFNVxcXFx1RkZFNlwiLFNrOlwiXFxcXF5gXFxcXHhBOFxcXFx4QUZcXFxceEI0XFxcXHhCOFxcXFx1MDJDMi1cXFxcdTAyQzVcXFxcdTAyRDItXFxcXHUwMkRGXFxcXHUwMkU1LVxcXFx1MDJFQlxcXFx1MDJFRFxcXFx1MDJFRi1cXFxcdTAyRkZcXFxcdTAzNzVcXFxcdTAzODRcXFxcdTAzODVcXFxcdTFGQkRcXFxcdTFGQkYtXFxcXHUxRkMxXFxcXHUxRkNELVxcXFx1MUZDRlxcXFx1MUZERC1cXFxcdTFGREZcXFxcdTFGRUQtXFxcXHUxRkVGXFxcXHUxRkZEXFxcXHUxRkZFXFxcXHUzMDlCXFxcXHUzMDlDXFxcXHVBNzAwLVxcXFx1QTcxNlxcXFx1QTcyMFxcXFx1QTcyMVxcXFx1QTc4OVxcXFx1QTc4QVxcXFx1QUI1QlxcXFx1QUI2QVxcXFx1QUI2QlxcXFx1RkJCMi1cXFxcdUZCQzFcXFxcdUZGM0VcXFxcdUZGNDBcXFxcdUZGRTNcIixTbTpcIlxcXFwrPC0+XFxcXHx+XFxcXHhBQ1xcXFx4QjFcXFxceEQ3XFxcXHhGN1xcXFx1MDNGNlxcXFx1MDYwNi1cXFxcdTA2MDhcXFxcdTIwNDRcXFxcdTIwNTJcXFxcdTIwN0EtXFxcXHUyMDdDXFxcXHUyMDhBLVxcXFx1MjA4Q1xcXFx1MjExOFxcXFx1MjE0MC1cXFxcdTIxNDRcXFxcdTIxNEJcXFxcdTIxOTAtXFxcXHUyMTk0XFxcXHUyMTlBXFxcXHUyMTlCXFxcXHUyMUEwXFxcXHUyMUEzXFxcXHUyMUE2XFxcXHUyMUFFXFxcXHUyMUNFXFxcXHUyMUNGXFxcXHUyMUQyXFxcXHUyMUQ0XFxcXHUyMUY0LVxcXFx1MjJGRlxcXFx1MjMyMFxcXFx1MjMyMVxcXFx1MjM3Q1xcXFx1MjM5Qi1cXFxcdTIzQjNcXFxcdTIzREMtXFxcXHUyM0UxXFxcXHUyNUI3XFxcXHUyNUMxXFxcXHUyNUY4LVxcXFx1MjVGRlxcXFx1MjY2RlxcXFx1MjdDMC1cXFxcdTI3QzRcXFxcdTI3QzctXFxcXHUyN0U1XFxcXHUyN0YwLVxcXFx1MjdGRlxcXFx1MjkwMC1cXFxcdTI5ODJcXFxcdTI5OTktXFxcXHUyOUQ3XFxcXHUyOURDLVxcXFx1MjlGQlxcXFx1MjlGRS1cXFxcdTJBRkZcXFxcdTJCMzAtXFxcXHUyQjQ0XFxcXHUyQjQ3LVxcXFx1MkI0Q1xcXFx1RkIyOVxcXFx1RkU2MlxcXFx1RkU2NC1cXFxcdUZFNjZcXFxcdUZGMEJcXFxcdUZGMUMtXFxcXHVGRjFFXFxcXHVGRjVDXFxcXHVGRjVFXFxcXHVGRkUyXFxcXHVGRkU5LVxcXFx1RkZFQ1wiLFxuU286XCJcXFxceEE2XFxcXHhBOVxcXFx4QUVcXFxceEIwXFxcXHUwNDgyXFxcXHUwNThEXFxcXHUwNThFXFxcXHUwNjBFXFxcXHUwNjBGXFxcXHUwNkRFXFxcXHUwNkU5XFxcXHUwNkZEXFxcXHUwNkZFXFxcXHUwN0Y2XFxcXHUwOUZBXFxcXHUwQjcwXFxcXHUwQkYzLVxcXFx1MEJGOFxcXFx1MEJGQVxcXFx1MEM3RlxcXFx1MEQ0RlxcXFx1MEQ3OVxcXFx1MEYwMS1cXFxcdTBGMDNcXFxcdTBGMTNcXFxcdTBGMTUtXFxcXHUwRjE3XFxcXHUwRjFBLVxcXFx1MEYxRlxcXFx1MEYzNFxcXFx1MEYzNlxcXFx1MEYzOFxcXFx1MEZCRS1cXFxcdTBGQzVcXFxcdTBGQzctXFxcXHUwRkNDXFxcXHUwRkNFXFxcXHUwRkNGXFxcXHUwRkQ1LVxcXFx1MEZEOFxcXFx1MTA5RVxcXFx1MTA5RlxcXFx1MTM5MC1cXFxcdTEzOTlcXFxcdTE2NkRcXFxcdTE5NDBcXFxcdTE5REUtXFxcXHUxOUZGXFxcXHUxQjYxLVxcXFx1MUI2QVxcXFx1MUI3NC1cXFxcdTFCN0NcXFxcdTIxMDBcXFxcdTIxMDFcXFxcdTIxMDMtXFxcXHUyMTA2XFxcXHUyMTA4XFxcXHUyMTA5XFxcXHUyMTE0XFxcXHUyMTE2XFxcXHUyMTE3XFxcXHUyMTFFLVxcXFx1MjEyM1xcXFx1MjEyNVxcXFx1MjEyN1xcXFx1MjEyOVxcXFx1MjEyRVxcXFx1MjEzQVxcXFx1MjEzQlxcXFx1MjE0QVxcXFx1MjE0Q1xcXFx1MjE0RFxcXFx1MjE0RlxcXFx1MjE4QVxcXFx1MjE4QlxcXFx1MjE5NS1cXFxcdTIxOTlcXFxcdTIxOUMtXFxcXHUyMTlGXFxcXHUyMUExXFxcXHUyMUEyXFxcXHUyMUE0XFxcXHUyMUE1XFxcXHUyMUE3LVxcXFx1MjFBRFxcXFx1MjFBRi1cXFxcdTIxQ0RcXFxcdTIxRDBcXFxcdTIxRDFcXFxcdTIxRDNcXFxcdTIxRDUtXFxcXHUyMUYzXFxcXHUyMzAwLVxcXFx1MjMwN1xcXFx1MjMwQy1cXFxcdTIzMUZcXFxcdTIzMjItXFxcXHUyMzI4XFxcXHUyMzJCLVxcXFx1MjM3QlxcXFx1MjM3RC1cXFxcdTIzOUFcXFxcdTIzQjQtXFxcXHUyM0RCXFxcXHUyM0UyLVxcXFx1MjQyNlxcXFx1MjQ0MC1cXFxcdTI0NEFcXFxcdTI0OUMtXFxcXHUyNEU5XFxcXHUyNTAwLVxcXFx1MjVCNlxcXFx1MjVCOC1cXFxcdTI1QzBcXFxcdTI1QzItXFxcXHUyNUY3XFxcXHUyNjAwLVxcXFx1MjY2RVxcXFx1MjY3MC1cXFxcdTI3NjdcXFxcdTI3OTQtXFxcXHUyN0JGXFxcXHUyODAwLVxcXFx1MjhGRlxcXFx1MkIwMC1cXFxcdTJCMkZcXFxcdTJCNDVcXFxcdTJCNDZcXFxcdTJCNEQtXFxcXHUyQjczXFxcXHUyQjc2LVxcXFx1MkI5NVxcXFx1MkI5Ny1cXFxcdTJCRkZcXFxcdTJDRTUtXFxcXHUyQ0VBXFxcXHUyRTUwXFxcXHUyRTUxXFxcXHUyRTgwLVxcXFx1MkU5OVxcXFx1MkU5Qi1cXFxcdTJFRjNcXFxcdTJGMDAtXFxcXHUyRkQ1XFxcXHUyRkYwLVxcXFx1MkZGQlxcXFx1MzAwNFxcXFx1MzAxMlxcXFx1MzAxM1xcXFx1MzAyMFxcXFx1MzAzNlxcXFx1MzAzN1xcXFx1MzAzRVxcXFx1MzAzRlxcXFx1MzE5MFxcXFx1MzE5MVxcXFx1MzE5Ni1cXFxcdTMxOUZcXFxcdTMxQzAtXFxcXHUzMUUzXFxcXHUzMjAwLVxcXFx1MzIxRVxcXFx1MzIyQS1cXFxcdTMyNDdcXFxcdTMyNTBcXFxcdTMyNjAtXFxcXHUzMjdGXFxcXHUzMjhBLVxcXFx1MzJCMFxcXFx1MzJDMC1cXFxcdTMzRkZcXFxcdTREQzAtXFxcXHU0REZGXFxcXHVBNDkwLVxcXFx1QTRDNlxcXFx1QTgyOC1cXFxcdUE4MkJcXFxcdUE4MzZcXFxcdUE4MzdcXFxcdUE4MzlcXFxcdUFBNzctXFxcXHVBQTc5XFxcXHVGREZEXFxcXHVGRkU0XFxcXHVGRkU4XFxcXHVGRkVEXFxcXHVGRkVFXFxcXHVGRkZDXFxcXHVGRkZEXCIsXG5abDpcIlxcXFx1MjAyOFwiLFpwOlwiXFxcXHUyMDI5XCIsWnM6XCIgXFxcXHhBMFxcXFx1MTY4MFxcXFx1MjAwMC1cXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBcIn07RS5DPUUuQ2MrRS5DZitFLkNzK0UuQ287RS5MPUUuTHUrRS5MbCtFLkx0K0UuTG0rRS5NbitFLkxvO0UuTEM9RS5MdStFLkxsK0UuTHQ7RS5NPUUuTW4rRS5NYytFLk1lO0UuTj1FLk5kK0UuTmwrRS5ObztFLlA9RS5QYytFLlBkK0UuUHMrRS5QZStFLlBpK0UuUGYrRS5QbztFLlM9RS5TbStFLlNjK0UuU2srRS5TbztFLlo9RS5acytFLlpsK0UuWnA7RS53PVwiX1wiK0UuTCtFLk47RS5iPVwiKD86W1wiK0UudytcIl0oPzpbXlwiK0UudytcIl18JCl8KD86XnxbXlwiK0UudytcIl0pW1wiK0UudytcIl0pXCI7RS5iT3V0PVwiKD89W15cIitFLncrXCJdfCQpXCI7RS5iSW49XCIoPzpefFteXCIrRS53K1wiXSlcIjtFLmJJbkNhcHR1cmU9XCIoPzpefChbXlwiK0UudytcIl0pKVwiO0UuQj1cIig/OltcIitFLncrXCJdW1wiK0UudytcIl18W15cIitFLncrXCJdW15cIitFLncrXCJdKVwiO0UuZD1FLk47XG52YXIgYz1Tay50b2tlbi50b2tlbnM7Y29uc3QgbT1Tay5idWlsdGluLlN5bnRheEVycm9yLG49U2suYnVpbHRpbi5TeW50YXhFcnJvcjtmLnByb3RvdHlwZS5leGFjdF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHlwZT09Yy5UX09QJiZ0aGlzLnN0cmluZyBpbiBTay50b2tlbi5FWEFDVF9UT0tFTl9UWVBFUz9Tay50b2tlbi5FWEFDVF9UT0tFTl9UWVBFU1t0aGlzLnN0cmluZ106dGhpcy50eXBlfTt2YXIgZD0vW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csbD1SZWdFeHAoZC5zb3VyY2UpO2NvbnN0IHtMdTpyLExsOnYsTHQ6cSxMbTp0LExvOncsTmw6QyxNbjpELE1jOkwsTmQ6TixQYzpBfT1FO0U9cit2K3ErdCt3K0MrXCJfXFxcXHUxODg1LVxcXFx1MTg4NlxcXFx1MjExOFxcXFx1MjEyRVxcXFx1MzA5Qi1cXFxcdTMwOUNcIjtjb25zdCBIPVwiW1wiK0UrXCJdK1tcIisoRStEK0wrTitBK1wiXFxcXHUwMEI3XFxcXHUwMzg3XFxcXHUxMzY5LVxcXFx1MTM3MVxcXFx1MTlEQV0qXCIpLHg9bmV3IFJlZ0V4cChcIl5cIitIK1wiJFwiKTtTay50b2tlbi5pc0lkZW50aWZpZXI9XG5wOyhmdW5jdGlvbihiYSl7cmV0dXJuIGUuYXBwbHkobnVsbCxhcmd1bWVudHMpK1wiKlwifSkoXCJcXFxcXFxcXFxcXFxyP1xcXFxuWyBcXFxcZlxcXFx0XSpcIik7ZyhcIiNbXlxcXFxyXFxcXG5dKlwiKTtFPWUoXCJbMC05XSg/Ol8/WzAtOV0pKlxcXFwuKD86WzAtOV0oPzpfP1swLTldKSopP1wiLFwiXFxcXC5bMC05XSg/Ol8/WzAtOV0pKlwiKStnKFwiW2VFXVstK10/WzAtOV0oPzpfP1swLTldKSpcIik7dmFyIEI9ZShFLFwiWzAtOV0oPzpfP1swLTldKSpbZUVdWy0rXT9bMC05XSg/Ol8/WzAtOV0pKlwiKSxGPWUoXCJbMC05XSg/Ol8/WzAtOV0pKltqSl1cIixCK1wiW2pKXVwiKTtFPWUuYXBwbHkobnVsbCxoKCkpO1E9ZShFK1wiJycnXCIsRSsnXCJcIlwiJyk7ZShFK1wiJ1teXFxcXG4nXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXFxcXG4nXFxcXFxcXFxdKikqJ1wiLEUrJ1wiW15cXFxcblwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXFxcXG5cIlxcXFxcXFxcXSopKlwiJyk7dmFyIEosUCxXO2EoITApO1NrLnRva2VuLnNldHVwVG9rZW5zPWE7dmFyIGNhPWUoRStcIidbXlxcXFxuJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuJ1xcXFxcXFxcXSopKlwiK1xuZShcIidcIixcIlxcXFxcXFxcXFxcXHI/XFxcXG5cIiksRSsnXCJbXlxcXFxuXCJcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cXFxcblwiXFxcXFxcXFxdKikqJytlKCdcIicsXCJcXFxcXFxcXFxcXFxyP1xcXFxuXCIpKSxoYT1lKFwiXFxcXFxcXFxcXFxccj9cXFxcbnwkXCIsXCIjW15cXFxcclxcXFxuXSpcIixRKSxvYT17fTtFPWgoKTtmb3IobGV0IGJhIG9mIEUpb2FbYmErXCInXCJdPVwiXlteJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXidcXFxcXFxcXF0qKSonXCIsb2FbYmErJ1wiJ109J15bXlwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXCJcXFxcXFxcXF0qKSpcIicsb2FbYmErXCInJydcIl09XCJeW14nXFxcXFxcXFxdKig/Oig/OlxcXFxcXFxcLnwnKD8hJycpKVteJ1xcXFxcXFxcXSopKicnJ1wiLG9hW2JhKydcIlwiXCInXT0nXlteXCJcXFxcXFxcXF0qKD86KD86XFxcXFxcXFwufFwiKD8hXCJcIikpW15cIlxcXFxcXFxcXSopKlwiXCJcIic7bGV0IGthPVtdLGlhPVtdO2ZvcihsZXQgYmEgb2YgRSlrYS5wdXNoKGJhKydcIicpLGthLnB1c2goYmErXCInXCIpLGlhLnB1c2goYmErJ1wiXCJcIicpLGlhLnB1c2goYmErXCInJydcIik7U2suX3Rva2VuaXplPWZ1bmN0aW9uKGJhLGphLG5hLGZhKXt2YXIgVj1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/XG5cIlwiOlwiKD86TD8pXCI7Vj1lKFwiMFt4WF0oPzpfP1swLTlhLWZBLUZdKStcIitWLFwiMFtiQl0oPzpfP1swMV0pK1wiK1YsU2suX19mdXR1cmVfXy5zaWxlbnRfb2N0YWxfbGl0ZXJhbD9cIjAoW29PXT8pKD86Xz9bMC03XSkrXCIrVjpcIjAoW29PXSkoPzpfP1swLTddKStcIitWLFwiKD86MCg/Ol8/MCkqfFsxLTldKD86Xz9bMC05XSkqKVwiK1YpO1Y9ZShGLEIsVik7Vj1cIlsgXFxcXGZcXFxcdF0qXCIrZShoYSxWLFcsY2EsSCk7Vj1uZXcgUmVnRXhwKFYpO3ZhciBsYT0wLE89MCxUPTAsWT1cIlwiLGRhPTAscWE9bnVsbCxwYT1bMF0seix1PXZvaWQgMCx5PXZvaWQgMCxHLEs7dm9pZCAwIT09bmEmJihcInV0Zi04LXNpZ1wiPT1uYSYmKG5hPVwidXRmLThcIiksZmEobmV3IGYoYy5UX0VOQ09ESU5HLG5hLFswLDBdLFswLDBdLFwiXCIpKSk7Zm9yKHZhciBJPW5hPVwiXCI7Oyl7dHJ5e25hPUksST1qYSgpfWNhdGNoKFgpe0k9XCJcIn1sYSs9MTt2YXIgTT0wLFI9SS5sZW5ndGg7aWYoWSl7aWYoIUkpdGhyb3cgbmV3IG0oXCJFT0YgaW4gbXVsdGktbGluZSBzdHJpbmdcIixcbmJhLHlbMF0seVsxXSk7dS5sYXN0SW5kZXg9MDt2YXIgVT11LmV4ZWMoSSk7aWYoVSlNPUc9VVswXS5sZW5ndGgsZmEobmV3IGYoYy5UX1NUUklORyxZK0kuc3Vic3RyaW5nKDAsRykseSxbbGEsR10scWErSSkpLFk9XCJcIixkYT0wLHFhPW51bGw7ZWxzZXtkYSYmXCJcXFxcXFxuXCIhPT1JLnN1YnN0cmluZyhJLmxlbmd0aC0yKSYmXCJcXFxcXFxyXFxuXCIhPT1JLnN1YnN0cmluZyhJLmxlbmd0aC0zKT8oZmEobmV3IGYoYy5UX0VSUk9SVE9LRU4sWStJLHksW2xhLEkubGVuZ3RoXSxxYSkpLFk9XCJcIixxYT1udWxsKTooWSs9SSxxYSs9SSk7Y29udGludWV9fWVsc2UgaWYoMCE9T3x8VCl7aWYoIUkpdGhyb3cgbmV3IG0oXCJFT0YgaW4gbXVsdGktbGluZSBzdGF0ZW1lbnRcIixiYSxsYSwwKTtUPTB9ZWxzZXtpZighSSlicmVhaztmb3Ioej0wO008Ujspe2lmKFwiIFwiPT1JW01dKXorPTE7ZWxzZSBpZihcIlxcdFwiPT1JW01dKXo9OCpNYXRoLmZsb29yKHovOCsxKTtlbHNlIGlmKFwiXFxmXCI9PUlbTV0pej0wO2Vsc2UgYnJlYWs7XG5NKz0xfWlmKE09PVIpYnJlYWs7aWYoayhcIiNcXHJcXG5cIixJW01dKSl7aWYoXCIjXCI9PUlbTV0pe3o9SS5zdWJzdHJpbmcoTSk7Zm9yKFI9ei5sZW5ndGg7MDxSJiYtMSE9PVwiXFxyXFxuXCIuaW5kZXhPZih6LmNoYXJBdChSLTEpKTstLVIpO1I9ei5zdWJzdHJpbmcoMCxSKTtmYShuZXcgZihjLlRfQ09NTUVOVCxSLFtsYSxNXSxbbGEsTStSLmxlbmd0aF0sSSkpO00rPVIubGVuZ3RofWZhKG5ldyBmKGMuVF9OTCxJLnN1YnN0cmluZyhNKSxbbGEsTV0sW2xhLEkubGVuZ3RoXSxJKSk7Y29udGludWV9ej5wYVtwYS5sZW5ndGgtMV0mJihwYS5wdXNoKHopLGZhKG5ldyBmKGMuVF9JTkRFTlQsSS5zdWJzdHJpbmcoTSksW2xhLDBdLFtsYSxNXSxJKSkpO2Zvcig7ejxwYVtwYS5sZW5ndGgtMV07KXtpZighayhwYSx6KSl0aHJvdyBuZXcgbihcInVuaW5kZW50IGRvZXMgbm90IG1hdGNoIGFueSBvdXRlciBpbmRlbnRhdGlvbiBsZXZlbFwiLGJhLGxhLE0pO3BhPXBhLnNsaWNlKDAsLTEpO2ZhKG5ldyBmKGMuVF9ERURFTlQsXG5cIlwiLFtsYSxNXSxbbGEsTV0sSSkpfX1mb3IoO008Ujspe2Zvcih6PUkuY2hhckF0KE0pO1wiIFwiPT09enx8XCJcXGZcIj09PXp8fFwiXFx0XCI9PT16OylNKz0xLHo9SS5jaGFyQXQoTSk7aWYoSz1WLmV4ZWMoSS5zdWJzdHJpbmcoTSkpKXtpZih6PU0sRz16K0tbMV0ubGVuZ3RoLEs9W2xhLHpdLFU9W2xhLEddLE09Ryx6IT1HKXtHPUkuc3Vic3RyaW5nKHosRyk7dmFyIFM9SVt6XTtpZihrKFwiMDEyMzQ1Njc4OVwiLFMpfHxcIi5cIj09UyYmXCIuXCIhPUcmJlwiLi4uXCIhPUcpZmEobmV3IGYoYy5UX05VTUJFUixHLEssVSxJKSk7ZWxzZSBpZihrKFwiXFxyXFxuXCIsUykpMDxPP2ZhKG5ldyBmKGMuVF9OTCxHLEssVSxJKSk6ZmEobmV3IGYoYy5UX05FV0xJTkUsRyxLLFUsSSkpO2Vsc2UgaWYoXCIjXCI9PVMpZmEobmV3IGYoYy5UX0NPTU1FTlQsRyxLLFUsSSkpO2Vsc2UgaWYoayhpYSxHKSlpZih1PVJlZ0V4cChvYVtHXSksVT11LmV4ZWMoSS5zdWJzdHJpbmcoTSkpKU09VVswXS5sZW5ndGgrTSxHPUkuc3Vic3RyaW5nKHosXG5NKSxmYShuZXcgZihjLlRfU1RSSU5HLEcsSyxbbGEsTV0sSSkpO2Vsc2V7eT1bbGEsel07WT1JLnN1YnN0cmluZyh6KTtxYT1JO2JyZWFrfWVsc2UgaWYoayhrYSxTKXx8ayhrYSxHLnN1YnN0cmluZygwLDIpKXx8ayhrYSxHLnN1YnN0cmluZygwLDMpKSlpZihcIlxcblwiPT1HW0cubGVuZ3RoLTFdKXt5PVtsYSx6XTt1PVJlZ0V4cChvYVtTXXx8b2FbR1sxXV18fG9hW0dbMl1dKTtZPUkuc3Vic3RyaW5nKHopO2RhPTE7cWE9STticmVha31lbHNlIGZhKG5ldyBmKGMuVF9TVFJJTkcsRyxLLFUsSSkpO2Vsc2UgcChTKT9mYShuZXcgZihjLlRfTkFNRSxHLEssVSxJKSk6XCJcXFxcXCI9PVM/VD0xOihrKFwiKFt7XCIsUyk/Tys9MTprKFwiKV19XCIsUykmJi0tTyxmYShuZXcgZihjLlRfT1AsRyxLLFUsSSkpKX19ZWxzZSBmYShuZXcgZihjLlRfRVJST1JUT0tFTixJW01dLFtsYSxNXSxbbGEsTSsxXSxJKSksTSs9MX19bmEmJiFrKFwiXFxyXFxuXCIsbmFbbmEubGVuZ3RoLTFdKSYmZmEobmV3IGYoYy5UX05FV0xJTkUsXG5cIlwiLFtsYS0xLG5hLmxlbmd0aF0sW2xhLTEsbmEubGVuZ3RoKzFdLFwiXCIpKTtmb3IodmFyIFogaW4gcGEuc2xpY2UoMSkpZmEobmV3IGYoYy5UX0RFREVOVCxcIlwiLFtsYSwwXSxbbGEsMF0sXCJcIikpO2ZhKG5ldyBmKGMuVF9FTkRNQVJLRVIsXCJcIixbbGEsMF0sW2xhLDBdLFwiXCIpKX07U2suX3Rva2VuaXplLkZsb2F0bnVtYmVyPUI7U2suZXhwb3J0U3ltYm9sKFwiU2suX3Rva2VuaXplXCIsU2suX3Rva2VuaXplKX1dKTt9KS5jYWxsKHRoaXMgfHwgd2luZG93KVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1za3VscHQubWluLmpzLm1hcCIsIi8qXG5UaGUgVGltZWRBY3RpdmVjb2RlIGNsYXNzZXMgYXJlIGEgZ3JlYXQgZXhhbXBsZSBvZiB3aGVyZSBtdWx0aXBsZSBpbmhlcml0YW5jZSB3b3VsZCBiZSB1c2VmdWxcbkJ1dCBzaW5jZSBKYXZhc2NyaXB0IGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgaW5oZXJpdGFuY2Ugd2UgdXNlIHRoZSBtaXhpbiBwYXR0ZXJuLlxuXG4qL1xuaW1wb3J0IExpdmVDb2RlIGZyb20gXCIuL2xpdmVjb2RlXCI7XG5pbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZVwiO1xuaW1wb3J0IEpTQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX2pzXCI7XG5pbXBvcnQgSFRNTEFjdGl2ZUNvZGUgZnJvbSBcIi4vYWN0aXZlY29kZV9odG1sXCI7XG5pbXBvcnQgU1FMQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX3NxbFwiO1xuXG52YXIgVGltZWRBY3RpdmVDb2RlTWl4aW4gPSB7XG4gICAgdGltZWRJbml0OiBhc3luYyBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB0aGlzLmlzVGltZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhpZGVCdXR0b25zKCk7XG4gICAgICAgIHRoaXMubmVlZHNSZWluaXRpYWxpemF0aW9uID0gdHJ1ZTsgLy8gdGhlIHJ1biBidXR0b24gY2xpY2sgbGlzdGVuZXIgbmVlZHMgdG8gYmUgcmVpbml0aWFsaXplZFxuICAgICAgICB0aGlzLmNvbnRhaW5lckRpdi5jbGFzc0xpc3QuYWRkKFwidGltZWRDb21wb25lbnRcIik7XG4gICAgICAgIHdpbmRvdy5lZExpc3RbdGhpcy5kaXZpZF0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgaGlkZUJ1dHRvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkxpc3QgPSBbXG4gICAgICAgICAgICB0aGlzLnNhdmVCdXR0b24sXG4gICAgICAgICAgICB0aGlzLmxvYWRCdXR0b24sXG4gICAgICAgICAgICB0aGlzLmdyYWRlQnV0dG9uLFxuICAgICAgICAgICAgdGhpcy5zaG93SGlkZUJ1dHQsXG4gICAgICAgICAgICB0aGlzLmNvYWNoQnV0dG9uLFxuICAgICAgICAgICAgdGhpcy5hdEJ1dHRvbixcbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidXR0b25MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmIGJ1dHRvbkxpc3RbaV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgJChidXR0b25MaXN0W2ldKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gYmplIC0gbm90IG5lZWRlZCBhbnltb3JlXG4gICAgcmVuZGVyVGltZWRJY29uOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIC8vIHJlbmRlcnMgdGhlIGNsb2NrIGljb24gb24gdGltZWQgY29tcG9uZW50cy4gICAgVGhlIGNvbXBvbmVudCBwYXJhbWV0ZXJcbiAgICAgICAgLy8gaXMgdGhlIGVsZW1lbnQgdGhhdCB0aGUgaWNvbiBzaG91bGQgYmUgYXBwZW5kZWQgdG8uXG4gICAgICAgIHZhciB0aW1lSWNvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciB0aW1lSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICQodGltZUljb24pLmF0dHIoe1xuICAgICAgICAgICAgc3JjOiBcIi4uL19zdGF0aWMvY2xvY2sucG5nXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJ3aWR0aDoxNXB4O2hlaWdodDoxNXB4XCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lSWNvbkRpdi5jbGFzc05hbWUgPSBcInRpbWVUaXBcIjtcbiAgICAgICAgdGltZUljb25EaXYudGl0bGUgPSBcIlwiO1xuICAgICAgICB0aW1lSWNvbkRpdi5hcHBlbmRDaGlsZCh0aW1lSWNvbik7XG4gICAgICAgICQoY29tcG9uZW50KS5wcmVwZW5kKHRpbWVJY29uRGl2KTtcbiAgICB9LFxuXG4gICAgY2hlY2tDb3JyZWN0VGltZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcGN0X2NvcnJlY3QgaXMgc2V0IGJ5IHRoZSB1bml0dGVzdC9ndWkucHkgbW9kdWxlIGluIHNrdWxwdC5cbiAgICAgICAgLy8gaXQgcmVsaWVzIG9uIGZpbmRpbmcgdGhpcyBvYmplY3QgaW4gdGhlIGVkTGlzdFxuICAgICAgICBpZiAodGhpcy5pc0Fuc3dlcmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wY3RfY29ycmVjdCA+PSAxMDAuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlRcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiRlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSVwiOyAvLyB3ZSBpZ25vcmUgdGhpcyBpbiB0aGUgZ3JhZGluZyBpZiBubyB1bml0dGVzdHNcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWRlRmVlZGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICB9LFxuXG4gICAgcmVpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbiAodGFrZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bkJ1dHRvbi5vbmNsaWNrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlYXR0YWNoaW5nIHJ1bmJ1dHRvbmhhbmRsZXJcIik7XG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5vbmNsaWNrID0gdGhpcy5ydW5CdXR0b25IYW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMuY29kZURpdikuc2hvdygpO1xuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAkKHRoaXMuY29kZURpdikucmVtb3ZlQ2xhc3MoXCJhYy1kaXNhYmxlZFwiKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICBpZiAodGhpcy5oaXN0b3J5U2NydWJiZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcih7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgc2xpZGU6IHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIGNoYW5nZTogdGhpcy5zbGlkZWl0LmJpbmQodGhpcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFrZW4pIHtcbiAgICAgICAgICAgICQoYCMke3RoaXMuZGl2aWR9X3VuaXRfcmVzdWx0c2ApLnNob3coKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgY2xhc3MgVGltZWRMaXZlQ29kZSBleHRlbmRzIExpdmVDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLnRpbWVkSW5pdChvcHRzKTtcbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oVGltZWRMaXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcblxuZXhwb3J0IGNsYXNzIFRpbWVkQWN0aXZlQ29kZSBleHRlbmRzIEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0Q29tcGxldGUgPSB0aGlzLnRpbWVkSW5pdChvcHRzKTtcbiAgICB9XG5cbiAgICAvLyBmb3IgdGltZWQgZXhhbXMgd2UgbmVlZCB0byBjYWxsIHJ1blByb2cgYW5kIHRlbGwgaXQgdGhhdCB0aGVyZSBpc1xuICAgIC8vIG5vIEdVSSBmb3Igc2xpZGVycyBvciBvdGhlciB0aGluZ3MuXG4gICAgLy8gdGhlIGFuc3dlcnMuXG4gICAgYXN5bmMgY2hlY2tDdXJyZW50QW5zd2VyKCkge1xuICAgICAgICBsZXQgbm9VSSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudGltZWRJbml0Q29tcGxldGU7XG4gICAgICAgIGlmICh0aGlzLmlzQW5zd2VyZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuUHJvZyhub1VJLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oVGltZWRBY3RpdmVDb2RlLnByb3RvdHlwZSwgVGltZWRBY3RpdmVDb2RlTWl4aW4pO1xuXG5leHBvcnQgY2xhc3MgVGltZWRKU0FjdGl2ZUNvZGUgZXh0ZW5kcyBKU0FjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xuICAgIH1cbn1cbk9iamVjdC5hc3NpZ24oVGltZWRKU0FjdGl2ZUNvZGUucHJvdG90eXBlLCBUaW1lZEFjdGl2ZUNvZGVNaXhpbik7XG5cbmV4cG9ydCBjbGFzcyBUaW1lZEhUTUxBY3RpdmVDb2RlIGV4dGVuZHMgSFRNTEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xuICAgIH1cbn1cbk9iamVjdC5hc3NpZ24oVGltZWRIVE1MQWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcblxuZXhwb3J0IGNsYXNzIFRpbWVkU1FMQWN0aXZlQ29kZSBleHRlbmRzIFNRTEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xuICAgIH1cbn1cbk9iamVjdC5hc3NpZ24oVGltZWRTUUxBY3RpdmVDb2RlLnByb3RvdHlwZSwgVGltZWRBY3RpdmVDb2RlTWl4aW4pO1xuIiwiLypcblxuaGlnaGxpZ2h0IHY0XG5cbkhpZ2hsaWdodHMgYXJiaXRyYXJ5IHRlcm1zLlxuXG48aHR0cDovL2pvaGFubmJ1cmthcmQuZGUvYmxvZy9wcm9ncmFtbWluZy9qYXZhc2NyaXB0L2hpZ2hsaWdodC1qYXZhc2NyaXB0LXRleHQtaGlnbGlnaHRpbmctanF1ZXJ5LXBsdWdpbi5odG1sPlxuXG5NSVQgbGljZW5zZS5cblxuSm9oYW5uIEJ1cmthcmRcbjxodHRwOi8vam9oYW5uYnVya2FyZC5kZT5cbjxtYWlsdG86amJAZWFpby5jb20+XG5cbiovXG5cbmpRdWVyeS5mbi5oaWdobGlnaHQgPSBmdW5jdGlvbihwYXQpIHtcbiBmdW5jdGlvbiBpbm5lckhpZ2hsaWdodChub2RlLCBwYXQpIHtcbiAgdmFyIHNraXAgPSAwO1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICB2YXIgcG9zID0gbm9kZS5kYXRhLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihwYXQpO1xuICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHNwYW5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHNwYW5ub2RlLmNsYXNzTmFtZSA9ICdoaWdobGlnaHQnO1xuICAgIHZhciBtaWRkbGViaXQgPSBub2RlLnNwbGl0VGV4dChwb3MpO1xuICAgIHZhciBlbmRiaXQgPSBtaWRkbGViaXQuc3BsaXRUZXh0KHBhdC5sZW5ndGgpO1xuICAgIHZhciBtaWRkbGVjbG9uZSA9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgc3Bhbm5vZGUuYXBwZW5kQ2hpbGQobWlkZGxlY2xvbmUpO1xuICAgIG1pZGRsZWJpdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzcGFubm9kZSwgbWlkZGxlYml0KTtcbiAgICBza2lwID0gMTtcbiAgIH1cbiAgfVxuICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jaGlsZE5vZGVzICYmICEvKHNjcmlwdHxzdHlsZSkvaS50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaSArPSBpbm5lckhpZ2hsaWdodChub2RlLmNoaWxkTm9kZXNbaV0sIHBhdCk7XG4gICB9XG4gIH1cbiAgcmV0dXJuIHNraXA7XG4gfVxuIHJldHVybiB0aGlzLmxlbmd0aCAmJiBwYXQgJiYgcGF0Lmxlbmd0aCA/IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgaW5uZXJIaWdobGlnaHQodGhpcywgcGF0LnRvVXBwZXJDYXNlKCkpO1xuIH0pIDogdGhpcztcbn07XG5cbmpRdWVyeS5mbi5yZW1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gdGhpcy5maW5kKFwic3Bhbi5oaWdobGlnaHRcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQubm9kZU5hbWU7XG4gIHdpdGggKHRoaXMucGFyZW50Tm9kZSkge1xuICAgcmVwbGFjZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCwgdGhpcyk7XG4gICBub3JtYWxpemUoKTtcbiAgfVxuIH0pLmVuZCgpO1xufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==