/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/BTM_root.js":
/*!*************************!*\
  !*** ./src/BTM_root.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BTM\": () => (/* binding */ BTM),\n/* harmony export */   \"exprType\": () => (/* binding */ exprType),\n/* harmony export */   \"exprValue\": () => (/* binding */ exprValue),\n/* harmony export */   \"opPrec\": () => (/* binding */ opPrec),\n/* harmony export */   \"toTeX\": () => (/* binding */ toTeX)\n/* harmony export */ });\n/* harmony import */ var _reductions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reductions.js */ \"./src/reductions.js\");\n/* harmony import */ var _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar_expr.js */ \"./src/scalar_expr.js\");\n/* harmony import */ var _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variable_expr.js */ \"./src/variable_expr.js\");\n/* harmony import */ var _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unop_expr.js */ \"./src/unop_expr.js\");\n/* harmony import */ var _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binop_expr.js */ \"./src/binop_expr.js\");\n/* harmony import */ var _multiop_expr_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multiop_expr.js */ \"./src/multiop_expr.js\");\n/* harmony import */ var _function_expr_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./function_expr.js */ \"./src/function_expr.js\");\n/* harmony import */ var _deriv_expr_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./deriv_expr.js */ \"./src/deriv_expr.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./random.js */ \"./src/random.js\");\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***********************\n** Evaluating expressions occurs in the context of a BTM environment.\n************************* */\n\n\n\n\n\n\n\n\n\n\n\n\nconst opPrec = {\n    disj: 0,\n    conj: 1,\n    equal: 2,\n    addsub: 3,\n    multdiv: 4,\n    power: 5,\n    fcn: 6,\n    fop: 7\n};\n\nconst exprType = {\n    number: 0,\n    variable: 1,\n    fcn: 2,\n    unop: 3,\n    binop: 4,\n    multiop: 5,\n    operator: 6,\n    array: 7,\n    matrix: 8\n};\n\nconst exprValue = { undef: -1, bool : 0, numeric : 1 };\n\nfunction toTeX(expr) {\n    return typeof expr.toTeX === \"function\" ? expr.toTeX() : expr;\n}\n\nclass BTM {\n    constructor(settings) {\n        if (settings === undefined) {\n            settings = {};\n            settings.seed = '1234';\n        }\n        // Each instance of BTM environment needs bindings across all expressions.\n        this.randomBindings = {};\n        this.bindings = {};\n        this.data = {};\n        this.data.allValues = {};\n        this.data.params = {};\n        this.data.variables = {};\n        this.data.expressions = {};\n        this.opPrec = opPrec;\n        this.exprType = exprType;\n        this.exprValue = exprValue;\n        this.options = {\n            negativeNumbers: true,\n            absTol: 1e-8,\n            relTol: 1e-4,\n            useRelErr: true,\n            doFlatten: false \n        };\n        this.setReductionRules();\n        this.multiop_expr = _multiop_expr_js__WEBPACK_IMPORTED_MODULE_5__.multiop_expr;\n        this.binop_expr = _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr;\n\n        // Generate a random generator. We might be passed either a pre-seeded `rand` function or a seed for our own.\n        let rngOptions = {};\n        if (typeof settings.rand !== 'undefined') {\n            rngOptions.rand = settings.rand;\n        }\n        if (typeof settings.seed !== 'undefined') {\n            rngOptions.seed = settings.seed;\n        }\n        this.rng = new _random_js__WEBPACK_IMPORTED_MODULE_8__.RNG(rngOptions);\n    }\n\n    // Perform approximate comparison tests using environment settings\n    // a < b: -1\n    // a ~= b: 0\n    // a > b: 1\n    numberCmp(a,b,override) {\n        // Work with actual values.\n        var valA, valB, cmpResult;\n        var useRelErr = this.options.useRelErr,\n            relTol = this.options.relTol,\n            absTol = this.options.absTol;\n\n        if (typeof a === 'number' || typeof a === 'Number') {\n            valA = a;\n        } else {\n            valA = a.value();\n        }\n        if (typeof b === 'number' || typeof b === 'Number') {\n            valB = b;\n        } else {\n            valB = b.value();\n        }\n\n        // Pull out the options.\n        if (typeof override !== 'undefined') {\n            if (typeof override.useRelErr !== 'undefined') {\n                useRelErr = override.useRelErr;\n            }\n            if (typeof override.relTol !== 'undefined') {\n                relTol = override.relTol;\n            }\n            if (typeof override.absTol !== 'undefined') {\n                absTol = override.absTol;\n            }\n        }\n\n        if (!useRelErr || Math.abs(valA) < absTol) {\n            if (Math.abs(valB-valA) < absTol) {\n                cmpResult = 0;\n            } else if (valA < valB) {\n                cmpResult = -1;\n            } else {\n                cmpResult = 1;\n            }\n        } else {\n            if (Math.abs(valB-valA)/Math.abs(valA) < relTol) {\n                cmpResult = 0;\n            } else if (valA < valB) {\n                cmpResult = -1;\n            } else {\n                cmpResult = 1;\n            }\n        }\n        return cmpResult;\n    }\n\n    /* Block of methods to deal with reduction rules in context */\n    setReductionRules() {\n        this.reduceRules = (0,_reductions_js__WEBPACK_IMPORTED_MODULE_0__.defaultReductions)(this);\n    }\n\n    addReductionRule(equation, description, useOneWay) {\n        (0,_reductions_js__WEBPACK_IMPORTED_MODULE_0__.newRule)(this, this.reduceRules, equation, description, true, useOneWay);\n    }\n\n    disableReductionRule(equation) {\n        (0,_reductions_js__WEBPACK_IMPORTED_MODULE_0__.disableRule)(this, this.reduceRules, equation);\n    }\n\n    addRule(ruleList, equation, description, useOneWay){\n        (0,_reductions_js__WEBPACK_IMPORTED_MODULE_0__.newRule)(this, ruleList, equation, description, true, useOneWay);\n    }\n\n    findMatchRules(reductionList, testExpr, doValidate) {\n        return (0,_reductions_js__WEBPACK_IMPORTED_MODULE_0__.findMatchRules)(reductionList, testExpr, doValidate);\n    }\n\n    addMathObject(name, context, newObject) {\n        switch(context) {\n            case 'number':\n                if (newObject.isConstant()) {\n                    this.data.params[name] = newObject;\n                    this.data.allValues[name] = newObject;\n                } else {\n                    throw `Attempt to add math object '${name}' with context '${context}' that does not match.`;\n                }\n                break;\n            case 'formula':\n                this.data.allValues[name] = newObject;\n                break;\n        }\n        return newObject;\n    }\n\n    generateRandom(distr, options) {\n        var rndVal, rndScalar;\n\n        switch (distr) {\n            case 'discrete':\n                let Nvals = Math.floor((options.max-options.min) / options.by)+1;\n                do {\n                    rndVal = options.min + options.by * this.rng.randInt(0,Nvals-1);\n                } while (options.nonzero && Math.abs(rndVal) < this.options.absTol);\n                break;\n        }\n        rndScalar = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this, rndVal);\n        return rndScalar;\n    }\n\n    addParameter(name, options) {\n        var newParam;\n        let prec = options.prec;\n        if (options.mode === 'random') {\n            let distr = options.distr;\n            if (typeof distr === 'undefined') {\n                distr = 'discrete_range';\n            }\n            switch (distr) {\n                case 'discrete_range':\n                let Nvals = Math.floor((options.max-options.min) / options.by)+1;\n                do {\n                    newParam = options.min + options.by * this.rng.randInt(0,Nvals-1);\n                } while (options.nonzero && Math.abs(newParam) < this.options.absTol);\n                break;\n            }\n        } else if (options.mode == 'calculate') {\n            newParam = this.parse(options.formula, \"number\").evaluate(this.data.params);\n        } else if (options.mode == 'rational') {\n            newParam = this.parse(new rational_number(options.numer,options.denom).toString(), \"number\");\n        } else if (options.mode == 'static') {\n            newParam = options.value;\n        }\n        if (typeof prec === 'number') {\n            newParam = Math.round(newParam/prec) / Math.round(1/prec);\n        }\n        this.data.params[name] = newParam;\n        this.data.allValues[name] = newParam;\n\n        return newParam;\n    }\n\n    addVariable(name, options) {\n        var newVar = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__.variable_expr(name);\n        \n        this.data.variables[name] = newVar;\n        this.data.allValues[name] = newVar;\n\n        return newVar;\n    }\n\n    evaluateMathObject(mathObject, context, bindings) {\n        var theExpr, newExpr, retValue;\n        // Not yet parsed\n        if (typeof mathObject === 'string') {\n            var formula = this.decodeFormula(mathObject);\n            theExpr = this.parse(formula, \"formula\");\n        // Already parsed\n        } else if (typeof mathObject === 'object') {\n            theExpr = mathObject;\n        }\n        retValue = theExpr.evaluate(bindings);\n        newExpr = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this, retValue);\n        return newExpr;\n    }\n\n    parseExpression(expression, context) {\n        var newExpr;\n        // Not yet parsed\n        if (typeof expression === 'string') {\n        var formula = this.decodeFormula(expression);\n        newExpr = this.parse(formula, context);\n        // Already parsed\n        } else if (typeof expression === 'object') {\n            newExpr = expression;\n        }\n        return newExpr;\n    }\n\n    addExpression(name, expression) {\n        var newExpr = this.parseExpression(expression, \"formula\");\n        \n        this.data.expressions[name] = newExpr;\n        this.data.allValues[name] = newExpr;\n\n        return newExpr;\n    }\n\n    // This routine takes the text and looks for strings in mustaches {{name}}\n    // It replaces this element with the corresponding parameter, variable, or expression.\n    // These should have been previously parsed and stored in this.data.\n    decodeFormula(statement, displayMode) {\n        // First find all of the expected substitutions.\n        var substRequestList = {};\n        var matchRE = /\\{\\{[A-Za-z]\\w*\\}\\}/g;\n        var substMatches = statement.match(matchRE);\n        if (substMatches != null) {\n            for (var i=0; i<substMatches.length; i++) {\n                var matchName = substMatches[i];\n                matchName = matchName.substr(2,matchName.length-4);\n                // Now see if the name is in our substitution rules.\n                if (this.data.allValues[matchName] != undefined) {\n                    if (displayMode != undefined && displayMode) {\n                        substRequestList[matchName] = '{'+this.data.allValues[matchName].toTeX()+'}';\n                    } else {\n                        substRequestList[matchName] = '('+this.data.allValues[matchName].toString()+')';\n                    }\n                }\n            }\n        }\n\n        // We are now ready to make the substitutions.\n        var retString = statement;\n        for (var match in substRequestList) {\n            var re = new RegExp(\"{{\" + match + \"}}\", \"g\");\n            var subst = substRequestList[match];\n            retString = retString.replace(re, subst);\n        }\n        return retString;\n    }\n\n    compareExpressions(expr1, expr2) {\n        if (typeof expr1 === 'string') {\n            expr1 = this.parse(expr1, \"formula\")\n        }\n        if (typeof expr2 === 'string') {\n            expr2 = this.parse(expr2, \"formula\")\n        }\n        return (expr1.compare(expr2));\n    }\n\n    getParser(context) {\n        var self=this,\n            parseContext=context;\n        return (function(exprString){ return self.parse(exprString, parseContext); })\n    }\n \n  /* ****************************************\n    btm.parse() is the workhorse.\n\n      Take a string representing a formula, and decompose it into an appropriate\n      tree structure suitable for recursive evaluation of the function.\n      Returns the root element to the tree.\n  ***************************************** */\n  parse(formulaStr, context, bindings, options) {\n    if (arguments.length < 2) {\n        context = \"formula\";\n    }\n    if (arguments.length < 3) {\n      bindings = {};\n    }\n    if (arguments.length < 4) {\n      options = {};\n    }\n\n    const numberMatch = /\\d|(\\.\\d)/;\n    const nameMatch = /[a-zA-Z]/;\n    const unopMatch = /[\\+\\-/]/;\n    const opMatch = /[\\+\\-*/^=\\$&]/;\n\n    var charPos = 0, endPos;\n    var parseError = '';\n\n    // Strip any extraneous white space and parentheses.\n    var workingStr;\n    workingStr = formulaStr.trim();\n\n    // Test if parentheses are all balanced.\n    var hasExtraParens = true;\n    while (hasExtraParens) {\n      hasExtraParens = false;\n      if (workingStr.charAt(0) == '(') {\n        var endExpr = completeParenthesis(workingStr, 0);\n        if (endExpr+1 >= workingStr.length) {\n          hasExtraParens = true;\n          workingStr = workingStr.slice(1,-1);\n        }\n      }\n    }\n\n    // We build the tree as it is parsed. \n    // Two stacks keep track of operands (expressions) and operators\n    // which we will identify as the string is parsed left to right\n    // At the time an operand is parsed, we don't know to which operator \n    // it ultimately belongs, so we push it onto a stack until we know.\n    var operandStack = new Array();\n    var operatorStack = new Array();\n\n    // When an operator is pushed, we want to compare it to the previous operator\n    // and see if we need to apply the operators to some operands.\n    // This is based on operator precedence (order of operations).\n    // An empty newOp means to finish resolve the rest of the stacks.\n    function resolveOperator(btm, operatorStack, operandStack, newOp) {\n      // Test if the operator has lower precedence.\n      var oldOp = 0;\n      while (operatorStack.length > 0) {\n        oldOp = operatorStack.pop();\n        if (newOp && (newOp.type==exprType.unop || oldOp.prec < newOp.prec)) {\n            break;\n        }\n\n        // To get here, the new operator must be *binary*\n        // and the operator to the left has *higher* precedence.\n        // So we need to peel off the operator to the left with its operands\n        // to form an expression as a new compound operand for the new operator.\n        var newExpr;\n        // Unary: Either negative or reciprocal require *one* operand\n        if (oldOp.type == exprType.unop) {\n          if (operandStack.length > 0) {\n            var input = operandStack.pop();\n\n            // Deal with negative numbers separately.\n            if (btm.options.negativeNumbers && input.type == exprType.number && oldOp.op == '-') {\n              newExpr = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(btm, input.number.multiply(-1));\n            } else {\n              newExpr = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(btm, oldOp.op, input);\n            }\n          } else {\n            newExpr = new _expression_js__WEBPACK_IMPORTED_MODULE_9__.expression(btm);\n            newExpr.setParsingError(\"Incomplete formula: missing value for \" + oldOp.op);\n          }\n        // Binary: Will be *two* operands.\n        } else {\n          if (operandStack.length > 1) {\n            var inputB = operandStack.pop();\n            var inputA = operandStack.pop();\n            newExpr = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(btm, oldOp.op, inputA, inputB);\n          } else {\n            newExpr = new _expression_js__WEBPACK_IMPORTED_MODULE_9__.expression(btm);\n            newExpr.setParsingError(\"Incomplete formula: missing value for \" + oldOp.op);\n          }\n        }\n        operandStack.push(newExpr);\n        oldOp = 0;\n      }\n      // The new operator is unary or has higher precedence than the previous op.\n      // We need to push the old operator back on the stack to use later.\n      if (oldOp != 0) {\n        operatorStack.push(oldOp);\n      }\n      // A new operation was added to deal with later.\n      if (newOp) {\n        operatorStack.push(newOp);\n      }\n    }\n\n    // Now we begin to process the string representing the expression.\n    var lastElement = -1, newElement; // 0 for operand, 1 for operator.\n\n    // Read string left to right.\n    // Identify what type of math object starts at this character.\n    // Find the other end of that object by completion.\n    // Interpret that object, possibly through a recursive parsing.\n    for (charPos = 0; charPos<workingStr.length; charPos++) {\n      // Identify the next element in the string.\n      if (workingStr.charAt(charPos) == ' ') {\n        continue;\n\n      // It might be a close parentheses that was not matched on the left.\n      } else if (workingStr.charAt(charPos) == ')') {\n        // Treat this like an implicit open parenthesis on the left.\n        resolveOperator(this, operatorStack, operandStack);\n        newElement = 0;\n        lastElement = -1;\n\n      // It could be an expression surrounded by parentheses -- use recursion\n      } else if (workingStr.charAt(charPos) == '(') {\n        endPos = completeParenthesis(workingStr, charPos);\n        var subExprStr = workingStr.slice(charPos+1,endPos);\n        var subExpr = this.parse(subExprStr, context, bindings);\n        operandStack.push(subExpr);\n        newElement = 0;\n        charPos = endPos;\n\n      // It could be an absolute value\n      } else if (workingStr.charAt(charPos) == '|') {\n        endPos = completeAbsValue(workingStr, charPos);\n        var subExprStr = workingStr.slice(charPos+1,endPos);\n        var subExpr = this.parse(subExprStr, context, bindings);\n        var newExpr = new _function_expr_js__WEBPACK_IMPORTED_MODULE_6__.function_expr(this, 'abs', subExpr);\n        operandStack.push(newExpr);\n        newElement = 0;\n        charPos = endPos;\n\n      // It could be a number. Just read it off\n      } else if (workingStr.substr(charPos).search(numberMatch) == 0) {\n        endPos = completeNumber(workingStr, charPos, options);\n        var newExpr = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this, new Number(workingStr.slice(charPos, endPos)));\n        if (options && options.noDecimals && workingStr.charAt(charPos) == '.') {\n          newExpr.setParsingError(\"Whole numbers only. No decimal values are allowed.\")\n        }\n        operandStack.push(newExpr);\n        newElement = 0;\n        charPos = endPos-1;\n\n      // It could be a name, either a function or variable.\n      } else if (workingStr.substr(charPos).search(nameMatch) == 0) {\n        endPos = completeName(workingStr, charPos);\n        var theName = workingStr.slice(charPos,endPos);\n        // If not a known name, break it down using composite if possible.\n        if (bindings[theName]=== undefined) {\n          // Returns the first known name, or theName not composite.\n          var testResults = TestNameIsComposite(theName, bindings);\n          if (testResults.isComposite) {\n            theName = testResults.name;\n            endPos = charPos + theName.length;\n          }\n        }\n        // Test if a function\n        if (bindings[theName]===undefined && workingStr.charAt(endPos) == '(') {\n          var endParen = completeParenthesis(workingStr, endPos);\n\n          var fcnName = theName;\n          var newExpr;\n          // See if this is a derivative\n          if (fcnName == 'D') {\n            var expr, ivar, ivarValue;\n            var entries = workingStr.slice(endPos+1,endParen).split(\",\");\n            expr = this.parse(entries[0], context, bindings);\n            if (entries.length == 1) {\n              newExpr = new _deriv_expr_js__WEBPACK_IMPORTED_MODULE_7__.deriv_expr(this, expr, 'x');\n            } else {\n              ivar = this.parse(entries[1], context, bindings);\n              // D(f(x),x,c) means f'(c)\n              if (entries.length > 2) {\n                ivarValue = this.parse(entries[2], context, bindings);\n              }\n              newExpr = new _deriv_expr_js__WEBPACK_IMPORTED_MODULE_7__.deriv_expr(this, expr, ivar, ivarValue);\n            }\n          } else {\n            var subExpr = this.parse(workingStr.slice(endPos+1,endParen), context, bindings);\n            newExpr = new _function_expr_js__WEBPACK_IMPORTED_MODULE_6__.function_expr(this, theName, subExpr);\n          }\n          operandStack.push(newExpr);\n          newElement = 0;\n          charPos = endParen;\n        }\n        // or a variable.\n        else {\n          // Test if needs index\n          if (workingStr.charAt(endPos) == '[') {\n            var endParen, hasError=false;\n            try {\n              endParen = completeBracket(workingStr, endPos, true);\n            } catch (error) {\n              parseError = error;\n              hasError = true;\n              endParen = endPos+1;\n            }\n            var indexExpr = this.parse(workingStr.slice(endPos+1,endParen), context, bindings);\n            var newExpr = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__.index_expr(this, theName, indexExpr);\n            if (hasError) {\n              newExpr.setParsingError(parseError);\n              parseError = \"\";\n            }\n            operandStack.push(newExpr);\n            newElement = 0;\n            charPos = endParen;\n          } else {\n            var newExpr = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__.variable_expr(this, theName);\n            operandStack.push(newExpr);\n            newElement = 0;\n            charPos = endPos-1;\n          }\n        }\n\n      // It could be an operator.\n      } else if (workingStr.substr(charPos).search(opMatch) == 0) {\n        newElement = 1;\n        var op = workingStr.charAt(charPos);\n        var newOp = new operator(op);\n\n        // Consecutive operators?    Better be sign change or reciprocal.\n        if (lastElement != 0) {\n          if (op == \"-\" || op == \"/\") {\n            newOp.type = exprType.unop;\n            newOp.prec = opPrec.multdiv;\n          } else {\n            // ERROR!!!\n            parseError = \"Error: consecutive operators\";\n          }\n        }\n        resolveOperator(this, operatorStack, operandStack, newOp);\n      }\n\n      // Two consecutive operands must have an implicit multiplication between them\n      if (lastElement == 0 && newElement == 0) {\n        var holdElement = operandStack.pop();\n\n        // Push a multiplication\n        var newOp = new operator('*');\n        resolveOperator(this, operatorStack, operandStack, newOp);\n\n        // Then restore the operand stack.\n        operandStack.push(holdElement);\n      }\n      lastElement = newElement;\n    }\n\n    // Now finish up the operator stack: nothing new to include\n    resolveOperator(this, operatorStack, operandStack);\n    var finalExpression = operandStack.pop();\n    if (parseError.length > 0) {\n        finalExpression.setParsingError(parseError);\n    } else {\n        // Test if context is consistent\n        switch (context) {\n            case 'number':\n                if (!finalExpression.isConstant()) {\n                    //throw \"The expression should be a constant but depends on variables.\"\n                }\n                finalExpression = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this, finalExpression.value());\n                break;\n            case 'formula':\n                break;\n        }\n        //finalExpression.setContext(context);\n    }\n    if (options.doFlatten) {\n      finalExpression.flatten();\n    }\n    return finalExpression;\n  }\n}\n\n// Used in parse\nfunction operator(opStr) {\n  this.op = opStr;\n  switch(opStr) {\n    case '+':\n    case '-':\n      this.prec = opPrec.addsub;\n      this.type = exprType.binop;\n      this.valueType = exprValue.numeric;\n      break;\n    case '*':\n    case '/':\n      this.prec = opPrec.multdiv;\n      this.type = exprType.binop;\n      this.valueType = exprValue.numeric;\n      break;\n    case '^':\n      this.prec = opPrec.power;\n      this.type = exprType.binop;\n      this.valueType = exprValue.numeric;\n      break;\n    case '&':\n      this.prec = opPrec.conj;\n      this.type = exprType.binop;\n      this.valueType = exprValue.bool;\n      break;\n    case '$':  // $=or since |=absolute value bar\n//    this.op = '|'\n      this.prec = opPrec.disj;\n      this.type = exprType.binop;\n      this.valueType = exprValue.bool;\n      break;\n    case '=':\n      this.prec = opPrec.equal;\n      this.type = exprType.binop;\n      this.valueType = exprValue.bool;\n      break;\n    case ',':\n      this.prec = opPrec.fop;\n      this.type = exprType.array;\n      this.valueType = exprValue.vector;\n      break;\n    default:\n      this.prec = opPrec.fcn;\n      this.type = exprType.fcn;\n      break;\n  }\n}\n\n/* An absolute value can be complicated because also a function. \nMay not be clear if nested: |2|x-3|- 5|.\nIs that 2x-15 or abs(2|x-3|-5)?\nResolve by requiring explicit operations: |2*|x-3|-5| or |2|*x-3*|-5|\n*/\nfunction completeAbsValue(formulaStr, startPos) {\n  var pLevel = 1;\n  var charPos = startPos;\n  var wasOp = true; // open absolute value implicitly has previous operation.\n\n  while (pLevel > 0 && charPos < formulaStr.length) {\n    charPos++;\n    // We encounter another absolute value.\n    if (formulaStr.charAt(charPos) == '|') {\n      if (wasOp) { // Must be opening a new absolute value.\n        pLevel++;\n        // wasOp is still true since can't close immediately\n      } else {  // Assume closing absolute value. If not wanted, need operator.\n        pLevel--;\n        // wasOp is still false since just closed a value.\n      }\n    // Keep track of whether just had operator or not.\n    } else if (\"+-*/([\".search(formulaStr.charAt(charPos)) >= 0) {\n      wasOp = true;\n    } else if (formulaStr.charAt(charPos) != ' ') {\n      wasOp = false;\n    }\n  }\n  return(charPos);\n}\n\n// Find the balancing closing parenthesis.\nfunction completeParenthesis(formulaStr, startPos) {\n  var pLevel = 1;\n  var charPos = startPos;\n\n  while (pLevel > 0 && charPos < formulaStr.length) {\n    charPos++;\n    if (formulaStr.charAt(charPos) == ')') {\n      pLevel--;\n    } else if (formulaStr.charAt(charPos) == '(') {\n      pLevel++;\n    }\n  }\n  return(charPos);\n}\n\n// Brackets are used for sequence indexing, not regular grouping.\nfunction completeBracket(formulaStr, startPos, asSubscript) {\n  var pLevel = 1;\n  var charPos = startPos;\n  var fail = false;\n\n  while (pLevel > 0 && charPos < formulaStr.length) {\n    charPos++;\n    if (formulaStr.charAt(charPos) == ']') {\n        pLevel--;\n    } else if (formulaStr.charAt(charPos) == '[') {\n        if (asSubscript) {\n          fail = true;\n        }\n        pLevel++;\n    }\n  }\n  if (asSubscript && fail) {\n    throw \"Nested brackets used for subscripts are not supported.\";\n  }\n  return(charPos);\n}\n\n/* Given a string and a starting position of a name, identify the entire name. */\n/* Require start with letter, then any sequence of *word* character */\n/* Also allow primes for derivatives at the end. */\nfunction completeName(formulaStr, startPos) {\n  var matchRule = /[A-Za-z]\\w*'*/;\n  var match = formulaStr.substr(startPos).match(matchRule);\n  return(startPos + match[0].length);\n}\n\n/* Given a string and a starting position of a number, identify the entire number. */\nfunction completeNumber(formulaStr, startPos, options) {\n  var matchRule;\n  if (options && options.noDecimals) {\n    matchRule = /[0-9]*/;\n  } else {\n    matchRule = /[0-9]*(\\.[0-9]*)?(e-?[0-9]+)?/;\n  }\n  var match = formulaStr.substr(startPos).match(matchRule);\n  return(startPos + match[0].length);\n}\n\n/* Tests a string to see if it can be constructed as a concatentation of known names. */\n/* For example, abc could be a name or could be a*b*c */\n/* Pass in the bindings giving the known names and see if we can build this name */\n/* Return the *first* name that is part of the whole. */\nfunction TestNameIsComposite(text, bindings) {\n  var retStruct = new Object();\n  retStruct.isComposite = false;\n\n  if (bindings !== undefined) {\n    var remain, nextName;\n    if (bindings[text] !== undefined) {\n      retStruct.isComposite = true;\n      retStruct.name = text;\n    } else {\n      // See if the text *starts* with a known name\n      var knownNames = Object.keys(bindings);\n      for (var ikey in knownNames) {\n        nextName = knownNames[ikey];\n        // If *this* name is the start of the text, see if the rest from known names.\n        if (text.search(nextName)==0) {\n          remain = TestNameIsComposite(text.slice(nextName.length), bindings);\n          if (remain.isComposite) {\n            retStruct.isComposite = true;\n            retStruct.name = nextName;\n            break;\n          }\n        }\n      }\n    }\n  }\n  return retStruct;\n}\n\n\nwindow.BTM = BTM;\nwindow.toTeX = toTeX;\n\n//# sourceURL=webpack://btm-expressions/./src/BTM_root.js?");

/***/ }),

/***/ "./src/binop_expr.js":
/*!***************************!*\
  !*** ./src/binop_expr.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"binop_expr\": () => (/* binding */ binop_expr)\n/* harmony export */ });\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/* harmony import */ var _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar_expr.js */ \"./src/scalar_expr.js\");\n/* harmony import */ var _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unop_expr.js */ \"./src/unop_expr.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Binary Expression -- defined by an operator and two inputs.\n* *************************************************** */\n\n\n\n\n\n\nclass binop_expr extends _expression_js__WEBPACK_IMPORTED_MODULE_1__.expression {\n    constructor(btm, op, inputA, inputB) {\n        super(btm);\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop;\n        this.op = op;\n        if (typeof inputA == 'undefined')\n            inputA = new _expression_js__WEBPACK_IMPORTED_MODULE_1__.expression(this.btm);\n        if (typeof inputB == 'undefined')\n            inputB = new _expression_js__WEBPACK_IMPORTED_MODULE_1__.expression(this.btm);\n        this.inputs = [inputA, inputB];\n            inputA.parent = this;\n            inputB.parent = this;\n\n        switch (op) {\n            case '+':\n            case '-':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.addsub;\n                break;\n            case '*':\n            case '/':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.multdiv;\n                break;\n            case '^':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.power;\n                break;\n            case '&':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.conj;\n                this.valueType = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprValue.bool;\n                break;\n            case '$':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.disj;\n                this.valueType = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprValue.bool;\n                break;\n            case '=':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.equal;\n                this.valueType = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprValue.bool;\n                break;\n            default:\n                console.log(\"Unknown binary operator: '\"+op+\"'.\");\n                break;\n        }\n    }\n\n    toString() {\n        var theStr;\n        var opAStr, opBStr;\n        var isError = false;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opAStr = '?';\n            isError = true;\n        } else {\n            opAStr = this.inputs[0].toString();\n            if ((this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop\n                    && this.inputs[0].prec < this.prec)\n                || (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                    && opAStr.indexOf(\"/\") >= 0\n                    && _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.multdiv <= this.prec)\n                ) \n            {\n                opAStr = '(' + opAStr + ')';\n            }\n        }\n        if (typeof this.inputs[1] == 'undefined') {\n            opBStr = '?';\n            isError = true;\n        } else {\n            opBStr = this.inputs[1].toString();\n            if ((this.inputs[1].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop\n                    && this.inputs[1].prec <= this.prec)\n                || (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                    && opBStr.indexOf(\"/\") >= 0\n                    && _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.opPrec.multdiv <= this.prec)\n                ) \n            {\n                opBStr = '(' + opBStr + ')';\n            }\n        }\n\n        var theOp = this.op;\n        if (theOp == '|') {\n            theOp = ' $ ';\n        }\n\n        theStr = opAStr + theOp + opBStr;\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputsA = this.inputs[0].allStringEquivs(),\n            allInputsB = this.inputs[1].allStringEquivs();\n\n        var retValue = [];\n\n        var theOp = this.op;\n        if (theOp == '|') {\n            theOp = ' $ ';\n        }\n\n        for (var i in allInputsA) {\n            for (var j in allInputsB) {\n                opAStr = allInputsA[i];\n                if (this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[0].prec < this.prec) {\n                    opAStr = '(' + opAStr + ')';\n                }\n                opBStr = allInputsB[j];\n                if (this.inputs[1].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[1].prec <= this.prec) {\n                    opBStr = '(' + opBStr + ')';\n                }\n\n                retValue.push(opAStr + theOp + opBStr);\n\n                if (this.op == '+' || this.op == '*' || this.op == '&' || this.op == '$') {\n                    opBStr = allInputsB[j];\n                    if (this.inputs[1].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[1].prec < this.prec) {\n                        opBStr = '(' + opBStr + ')';\n                    }\n                    opAStr = allInputsA[i];\n                    if (this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[0].prec <= this.prec) {\n                        opAStr = '(' + opAStr + ')';\n                    }\n                    retValue.push(opBStr + theOp + opAStr);\n                }\n            }\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var theOp;\n        var opAStr, opBStr;\n\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opAStr = '?';\n        } else {\n            opAStr = this.inputs[0].toTeX(showSelect);\n        }\n        if (typeof this.inputs[1] == 'undefined') {\n            opBStr = '?';\n        } else {\n            opBStr = this.inputs[1].toTeX(showSelect);\n        }\n        theOp = this.op;\n        if (showSelect && this.select) {\n            switch (theOp) {\n                case '*':\n                    theOp = '\\\\cdot ';\n                    break;\n                case '/':\n                    theOp = '\\\\div ';\n                    break;\n                case '^':\n                    theOp = '\\\\wedge ';\n                    break;\n                case '|':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '$':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '&':\n                    theOp = '\\\\hbox{ and }';\n                    break;\n            }\n        } else {\n            switch (theOp) {\n                case '*':\n                    if (this.inputs[1] && this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number) {\n                        theOp = '\\\\cdot ';\n                    } else if (this.inputs[1] && this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop\n                                && this.inputs[1].op=='^' && this.inputs[1].inputs[0].type==_BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number) {\n                        theOp = '\\\\cdot ';\n                    } else {\n                        theOp = ' ';\n                    }\n                    break;\n                case '|':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '$':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '&':\n                    theOp = '\\\\hbox{ and }';\n                    break;\n            }\n        }\n        if (theOp == '/') {\n            theStr = '\\\\frac{' + opAStr + '}{' + opBStr + '}';\n        } else if (theOp == '^') {\n            if (this.inputs[0] && this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.fcn) {\n                theStr = '\\\\left(' + opAStr + '\\\\right)';\n            } else {\n                theStr = opAStr;\n            }\n            theStr += theOp + '{' + opBStr + '}';\n        } else {\n            var argStrL='', argStrR='', opStrL='', opStrR='';\n\n            if (showSelect && this.select) {\n                argStrL = '{\\\\color{blue}';\n                argStrR = '}';\n                opStrL = '{\\\\color{red}';\n                opStrR = '}';\n            }\n            if (this.inputs[0] && this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[0].prec < this.prec) {\n                theStr = '\\\\left(' + argStrL + opAStr + argStrR + '\\\\right)';\n            } else {\n                theStr = argStrL + opAStr + argStrR;\n            }\n            theStr += opStrL + theOp + opStrR;\n            if (this.inputs[1] && this.inputs[1].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[1].prec <= this.prec) {\n                theStr += '\\\\left(' + argStrL + opBStr + argStrR + '\\\\right)';\n            } else {\n                theStr += argStrL + opBStr + argStrR;\n            }\n        }\n        if (showSelect && this.select) {\n          theStr = \"{\\\\color{red}\\\\boxed{\" + theStr + \"}}\";\n        }\n        theStr = theStr.replace(/\\+-/g, '-');\n        return(theStr);\n    }\n\n    toMathML() {\n        var theStr;\n        var theOp;\n        var opAStr, opBStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opAStr = '?';\n        } else {\n            opAStr = this.inputs[0].toMathML();\n        }\n        if (typeof this.inputs[1] == 'undefined') {\n            opBStr = '?';\n        } else {\n            opBStr = this.inputs[1].toMathML();\n        }\n        switch (this.op) {\n            case '+':\n                theOp = \"<plus/>\"\n                break;\n            case '-':\n                theOp = \"<minus/>\"\n                break;\n            case '*':\n                theOp = \"<times/>\"\n                break;\n            case '/':\n                theOp = \"<divide/>\"\n                break;\n            case '^':\n                theOp = \"<power/>\"\n                break;\n        }\n        theStr = \"<apply>\" + theOp + opAStr + opBStr + \"</apply>\";\n\n        return(theStr);\n    }\n\n    operateToTeX() {\n        var opString = this.op;\n\n        switch (opString) {\n            case '*':\n                opString = '\\\\times ';\n                break;\n            case '/':\n                opString = '\\\\div ';\n                break;\n            case '^':\n                opString = '\\\\wedge ';\n                break;\n            case '|':\n                opString = '\\\\hbox{ or }';\n                break;\n            case '$':\n                opString = '\\\\hbox{ or }';\n                break;\n            case '&':\n                opString = '\\\\hbox{ and }';\n                break;\n        }\n\n        return(opString);\n    }\n\n    isCommutative() {\n        var commutes = false;\n        if (this.op === '+' || this.op === '*') {\n            commutes = true;\n        }\n        return(commutes);\n    }\n\n    evaluate(bindings) {\n        var inputAVal = this.inputs[0].evaluate(bindings);\n        var inputBVal = this.inputs[1].evaluate(bindings);\n\n        if (inputAVal == undefined || inputBVal == undefined) {\n            return(undefined);\n        }\n\n        var retVal = undefined;\n        switch (this.op) {\n            case '+':\n                retVal = inputAVal + inputBVal;\n                break;\n            case '-':\n                retVal = inputAVal - inputBVal;\n                break;\n            case '*':\n                retVal = inputAVal * inputBVal;\n                break;\n            case '/':\n                retVal = inputAVal / inputBVal;\n                break;\n            case '^':\n                if (!this.inputs[1].isConstant()) {\n                    retVal = Math.exp(inputBVal * Math.log(inputAVal));\n                } else {\n                    if (inputAVal >= 0 || (inputBVal % 1 == 0)) {\n                        retVal = Math.pow(inputAVal,inputBVal);\n                    } else {\n                        retVal = Math.exp(inputBVal * Math.log(inputAVal));\n                    }\n                }\n                break;\n            case '=':\n                retVal = (Math.abs(inputAVal - inputBVal) < this.btm.options.absTol);\n                break;\n            case '&':\n                retVal = inputAVal && inputBVal;\n                break;\n            case '|':\n            case '$':\n                retVal = inputAVal || inputBVal;\n                break;\n            default:\n                console.log(\"The binary operator '\" + this.op + \"' is not defined.\");\n                retVal = undefined;\n                break;\n        }\n        return(retVal);\n    }\n\n    // See if this operator is now redundant.\n    // Return the resulting expression.\n    reduce() {\n        var newExpr = this;\n        if (this.inputs.length <= 1) {\n            if (this.inputs.length == 0) {\n                // Sum with no elements = 0\n                // Product with no elements = 1\n                newExpr = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, this.op == '+' ? 0 : 1);\n            } else {\n                // Sum or product with one element *is* that element.\n                newExpr = this.inputs[0].reduce();\n            }\n            newExpr.parent = this.parent;\n            if (this.parent !== null) {\n                this.parent.inputSubst(this, newExpr);\n            }\n        }\n        return(newExpr);\n    }\n\n    simplifyConstants() {\n        var retVal = this;\n        this.inputs[0] = this.inputs[0].simplifyConstants();\n        this.inputs[0].parent = this;\n        this.inputs[1] = this.inputs[1].simplifyConstants();\n        this.inputs[1].parent = this;\n        if ((this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                || (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[0].inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number)\n            ) &&\n            (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                || (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.unop && this.inputs[1].inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number)\n            ))\n        {\n            var numA, numB, theNumber;\n            if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number) {\n                numA = this.inputs[0].number;\n            } else {\n                switch (this.inputs[0].op) {\n                    case '-':\n                        numA = this.inputs[0].inputs[0].number.addInverse();\n                        break;\n                    case '/':\n                        numA = this.inputs[0].inputs[0].number.multInverse();\n                        break;\n                }\n            }\n            if (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number) {\n                numB = this.inputs[1].number;\n            } else {\n                switch (this.inputs[1].op) {\n                    case '-':\n                        numB = this.inputs[1].inputs[0].number.addInverse();\n                        break;\n                    case '/':\n                        numB = this.inputs[1].inputs[0].number.multInverse();\n                        break;\n                }\n            }\n            switch (this.op) {\n                case '+':\n                    theNumber = numA.add(numB);\n                    break;\n                case '-':\n                    theNumber = numA.subtract(numB);\n                    break;\n                case '*':\n                    theNumber = numA.multiply(numB);\n                    break;\n                case '/':\n                    theNumber = numA.divide(numB);\n                    break;\n                case '^':\n                    // Integer powers of a rational number can be represented exactly.\n                    if (numA instanceof rational_number && numB instanceof rational_number\n                            && numB.q == 1 && numB.p % 1 == 0 && numB.p > 0) {\n                        theNumber = new rational_number(Math.pow(numA.p, numB.p), Math.pow(numA.q, numB.p));\n                    }\n                    break;\n            }\n            if (theNumber !== undefined) {\n                if (!this.btm.options.negativeNumbers && theNumber.p < 0) {\n                    retVal = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '-', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, theNumber.multiply(-1)));\n                } else {\n                    retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, theNumber);\n                }\n            }\n        } else {\n            switch (this.op) {\n                case '+':\n                    // Simplify 0+a\n                    if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[0].number.value()==0) {\n                        retVal = this.inputs[1];\n                    }\n                    // Simplify a+0\n                    else if (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[1].number.value() == 0) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '-':\n                    // Simplify 0-a\n                    if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[0].number.value()==0) {\n                        retVal = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, \"-\", this.inputs[1]);\n                    }\n                    // Simplify a-0\n                    else if (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[1].number.value() == 0) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '*':\n                    // Simplify 1*a\n                    if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[0].number.value()==1) {\n                        retVal = this.inputs[1];\n                    }\n                    // Simplify a*1\n                    else if (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[1].number.value() == 1) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '/':\n                    // Simplify 1/a to unary operator of multiplicative inverse.\n                    if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[0].number.value()==1) {\n                        retVal = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, \"/\", this.inputs[1]);\n                    }\n                    // Simplify a/1\n                    else if (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[1].number.value() == 1) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '^':\n                    // Simplify 0^p\n                    if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[0].number.value()==0) {\n                        retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 0);\n                    }\n                    // Simplify 1^p\n                    else if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[0].number.value() == 1) {\n                        retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 1);\n                    }\n                    // Simplify p^1\n                    else if (this.inputs[1].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number\n                            && this.inputs[1].number.value() == 1) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n            }\n        }\n        return(retVal);\n    }\n\n    flatten() {\n        var inA = this.inputs[0].flatten();\n        var inB = this.inputs[1].flatten();\n\n        var retVal;\n        switch (this.op) {\n            case '+':\n            case '-':\n                var inputs = [];\n                if ((inA.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.multiop || inA.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop)\n                    && (inA.op == '+' || inA.op == '-')) \n                {\n                    var newInput = inA.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    inputs.push(inA);\n                }\n                if ((inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.multiop || inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop)\n                    && (inB.op == '+' || inB.op == '-')) \n                {\n                    var newInput = inB.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    if (this.op == '-') {\n                        if ((inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.multiop || inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop)\n                            && (inB.op == '+' || inB.op == '-')) \n                        {\n                            var newInput = inB.flatten();\n                            for (var i in newInput.inputs) {\n                                inputs.push(new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '-',newInput.inputs[i]));\n                            }\n                        } else {\n                            inputs.push(new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '-',inB));\n                        }\n                    } else {\n                        inputs.push(inB);\n                    }\n                }\n                retVal = new multiop_expr(this.btm, '+', inputs);\n                break;\n            case '*':\n            case '/':\n                var inputs = [];\n                if ((inA.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.multiop || inA.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop)\n                    && (inA.op == '*' || inA.op == '/')) \n                {\n                    var newInput = inA.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    inputs.push(inA);\n                }\n                if ((inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.multiop || inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop)\n                    && (inB.op == '*' || inB.op == '/'))\n                {\n                    var newInput = inB.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    if (this.op == '/') {\n                        if ((inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.multiop || inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop)\n                            && (inB.op == '*' || inB.op == '/')) \n                        {\n                            var newInput = inB.flatten();\n                            for (var i in newInput.inputs) {\n                                inputs.push(new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '/',newInput.inputs[i]));\n                            }\n                        } else {\n                            inputs.push(new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '/',inB));\n                        }\n                    } else {\n                        inputs.push(inB);\n                    }\n                }\n                retVal = new multiop_expr(this.btm, '*', inputs);\n                break;\n            default:\n                retVal = new binop_expr(this.btm, this.op, inA, inB);\n        }\n        return(retVal);\n    }\n\n    copy() {\n      var inA = this.inputs[0].copy();\n      var inB = this.inputs[1].copy();\n      return (new binop_expr(this.btm, this.op, inA, inB));\n    }\n\n    compose(bindings) {\n        var inA = this.inputs[0].compose(bindings);\n        var inB = this.inputs[1].compose(bindings);\n\n        var retVal;\n        retVal = new binop_expr(this.btm, this.op, inA, inB);\n        if (inA.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number && inB.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.number) {\n            switch (this.op) {\n                case '+':\n                    retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, inA.number.add(inB.number));\n                    break;\n                case '-':\n                    retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, inA.number.subtract(inB.number));\n                    break;\n                case '*':\n                    retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, inA.number.multiply(inB.number));\n                    break;\n                case '/':\n                    retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, inA.number.divide(inB.number));\n                    break;\n            }\n        }\n        return(retVal);\n    }\n\n    derivative(ivar, varList) {\n        var uConst = this.inputs[0].isConstant();\n        var vConst = this.inputs[1].isConstant();\n\n        var theDeriv;\n        if (uConst && vConst) {\n            theDeriv = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 0);\n        } else {\n            var dudx, dvdx;\n\n            if (uConst) {\n                dudx = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 0);\n            } else {\n                dudx = this.inputs[0].derivative(ivar, varList);\n            }\n            if (vConst) {\n                dvdx = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 0);\n            } else {\n                dvdx = this.inputs[1].derivative(ivar, varList);\n            }\n            switch (this.op) {\n                case '+':\n                    theDeriv = new binop_expr(this.btm, '+', dudx, dvdx);\n                    break;\n                case '-':\n                    theDeriv = new binop_expr(this.btm, '-', dudx, dvdx);\n                    break;\n                case '*':\n                    var udv = new binop_expr(this.btm, '*', this.inputs[0], dvdx)\n                    var vdu = new binop_expr(this.btm, '*', dudx, this.inputs[1])\n                    if (uConst) {\n                        theDeriv = udv;\n                    } else if (vConst) {\n                        theDeriv = vdu;\n                    } else {\n                        theDeriv = new binop_expr(this.btm, '+', vdu, udv);\n                    }\n                    break;\n                case '/':\n                    if (vConst) {\n                        theDeriv = new binop_expr(this.btm, '/', dudx, this.inputs[1]);\n                    } else if (uConst) {\n                        var numer = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '-', new binop_expr(this.btm, '*', this.inputs[0], dvdx));\n                        var denom = new binop_expr(this.btm, '^', this.inputs[1], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 2));\n                        theDeriv = new binop_expr(this.btm, '/', numer, denom);\n                    } else {\n                        var udv = new binop_expr(this.btm, '*', this.inputs[0], dvdx)\n                        var vdu = new binop_expr(this.btm, '*', dudx, this.inputs[1])\n                        var numer = new binop_expr(this.btm, '-', vdu, udv);\n                        var denom = new binop_expr(this.btm, '^', this.inputs[1], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 2));\n                        theDeriv = new binop_expr(this.btm, '/', numer, denom);\n                    }\n                    break;\n                case '^':\n                    var powDep = this.inputs[1].dependencies();\n                    var ivarName = (typeof ivar == 'string') ? ivar : ivar.name;\n                    // See if the power depends on the variable\n                    if (powDep.length > 0 && powDep.indexOf(ivarName) >= 0) {\n                        var theArg = new binop_expr(this.btm, '*', this.inputs[1], new function_expr(this.btm, 'log', this.inputs[0]));\n                        var theFcn = new function_expr(this.btm, 'exp', theArg);\n                        theDeriv = theFcn.derivative(ivar, varList);\n                    // Otherwise this is a simple application of the power rule\n                    } else if (!uConst) {\n                        var newPow = new binop_expr(this.btm, '-', this.inputs[1], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 1));\n                        var dydu = new binop_expr(this.btm, '*', this.inputs[1], new binop_expr(this.btm, '^', this.inputs[0], newPow));\n                        if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.variable\n                                && this.inputs[0].name == ivarName) {\n                            theDeriv = dydu;\n                        } else {\n                            var dudx = this.inputs[0].derivative(ivar, varList);\n                            theDeriv = new binop_expr(this.btm, '*', dydu, dudx);\n                        }\n                    } else {\n                        theDeriv = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_2__.scalar_expr(this.btm, 0);\n                    }\n                    break;\n                default:\n                    console.log(\"The binary operator '\" + this.op + \"' is not defined.\");\n                    theDeriv = undefined;\n                    break;\n            }\n        }\n        return(theDeriv);\n    }\n}\n\n\n//# sourceURL=webpack://btm-expressions/./src/binop_expr.js?");

/***/ }),

/***/ "./src/deriv_expr.js":
/*!***************************!*\
  !*** ./src/deriv_expr.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deriv_expr\": () => (/* binding */ deriv_expr)\n/* harmony export */ });\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/* harmony import */ var _variable_expr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./variable_expr.js */ \"./src/variable_expr.js\");\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Derivative of an Expression\n* *************************************************** */\n\n\n\n\n\nclass deriv_expr extends _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression {\n    constructor(btm, formula, variable, atValue) {\n        super(btm);\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.operator;\n        this.op = \"D\";\n        if (typeof formula == 'undefined')\n            formula = new _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression(this.btm);\n        if (typeof variable == 'undefined') {\n            variable = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_1__.variable_expr(this.btm, 'x');\n        } else if (typeof variable == 'string') {\n            variable = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_1__.variable_expr(this.btm, variable);\n        }\n        this.ivar = variable;\n        this.ivarValue = atValue;\n        this.inputs = [formula];\n        this.isRate = false;\n        formula.parent = this;\n    }\n\n    toString() {\n        var theStr;\n        var exprStr, varStr, valStr;\n\n        varStr = this.ivar.toString();\n        exprStr = this.inputs[0].toString();\n        if (typeof this.ivarValue != 'undefined') {\n            valStr = this.ivarValue.toString();\n            theStr = \"D(\"+exprStr+\",\"+varStr+\",\"+valStr+\")\";\n        } else {\n            theStr = \"D(\"+exprStr+\",\"+varStr+\")\";\n        }\n        return(theStr);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var opStr, varStr, exprStr, valStr;\n\n        varStr = this.ivar.toTeX();\n        exprStr = this.inputs[0].toTeX();\n        if (this.isRate && this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.variable) {\n            if (typeof this.ivarValue != 'undefined') {\n                valStr = this.ivarValue.toTeX();\n                theStr = \"\\\\left. \\\\frac{d\" + exprStr + \"}{d\"+varStr+\"} \\\\right|_{\"\n                    + varStr + \"=\" + valStr + \"}\";\n            } else {\n                theStr = \"\\\\frac{d\" + exprStr +\"}{d\"+varStr+\"}\";\n            }\n        } else {\n            if (typeof this.ivarValue != 'undefined') {\n                valStr = this.ivarValue.toTeX();\n                opStr = \"\\\\left. \\\\frac{d}{d\"+varStr+\"} \\\\right|_{\"\n                    + varStr + \"=\" + valStr + \"}\";\n            } else {\n                opStr = \"\\\\frac{d}{d\"+varStr+\"}\";\n            }\n            theStr = opStr + \"\\\\Big[\" + exprStr + \"\\\\Big]\";\n        }\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputs = this.inputs[0].allStringEquivs();\n        var varStr, valStr;\n        var retValue = [];\n\n        varStr = this.ivar.toString();\n        if (typeof this.ivarValue != 'undefined') {\n            valStr = this.ivarValue.toString();\n        }\n        for (var i in allInputs) {\n            if (typeof this.ivarValue != 'undefined') {\n                retValue[i] = \"D(\"+allInputs[i]+\",\"+varStr+\",\"+valStr+\")\";\n            } else {\n                retValue[i] = \"D(\"+allInputs[i]+\",\"+varStr+\")\";\n            }\n        }\n\n        return(allInputs);\n    }\n\n    toMathML() {\n        var theStr;\n        var exprStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            exprStr = '?';\n        } else {\n            exprStr = this.inputs[0].toMathML();\n        }\n        theStr = \"<apply><derivative/>\" + exprStr + \"</apply>\";\n\n        return(theStr);\n    }\n\n    evaluate(bindings) {\n        var retVal;\n        var derivExpr;\n        var dbind = {};\n\n        if (typeof this.ivarValue != 'undefined') {\n            dbind[this.ivar.name] = this.ivarValue;\n        }\n        // Compute the derivative of the expression, then evaluate at binding\n        derivExpr = this.inputs[0].derivative(this.ivar, bindings);\n        derivExpr = derivExpr.compose(dbind);\n        retVal = derivExpr.evaluate(bindings);\n        return(retVal);\n    }\n\n    simplifyConstants() {\n        return(this);\n    }\n\n    flatten() {\n      return (new deriv_expr(this.btm, this.inputs[0].flatten(), this.ivar, this.ivarValue));\n    }\n\n    copy() {\n      return (new deriv_expr(this.btm, this.inputs[0].copy(), this.ivar, this.ivarValue));\n    }\n\n\n    compose(bindings) {\n    }\n\n    derivative(ivar, varList) {\n        var dbind = {};\n\n        if (typeof this.ivarValue != 'undefined') {\n            dbind[this.ivar] = this.ivarValue;\n        }\n        // Evaluate the main expression using original binding\n        var firstDeriv = this.inputs[0].derivative(this.ivar, varList);\n        firstDeriv.compose(dbind);\n\n        // Now differentiate that expression using new binding.\n        return firstDeriv.derivative(ivar, varList);\n    }\n}\n\n\n//# sourceURL=webpack://btm-expressions/./src/deriv_expr.js?");

/***/ }),

/***/ "./src/expression.js":
/*!***************************!*\
  !*** ./src/expression.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MathObject\": () => (/* binding */ MathObject),\n/* harmony export */   \"expression\": () => (/* binding */ expression)\n/* harmony export */ });\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/* harmony import */ var _reductions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reductions.js */ \"./src/reductions.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n\n\n\nclass MathObject {\n    constructor(btm) {\n        this.btm = btm;\n        if (!(btm instanceof _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.BTM)) {\n            throw \"MathObject constructed with invalid environment\";\n        }\n        this.select = false;\n        this.parent = null;\n        this.inputs = [];\n        this.valueType = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprValue.undef;\n        this.context = undefined;\n    }\n    \n    // Method to *evaluate* the object.\n    // - Return undefined\n    value(bindings) {\n    }\n    \n    // Update context setting\n    setContext(context) {\n        this.context = context;\n        // Update context on inputs.\n        for (var i in this.inputs) {\n            this.inputs[i].setContext(context);\n        }\n    }\n\n    // When the parser throws an error, need to record it.\n    setParsingError(errorString) {\n        this.parseError = errorString;\n    }\n\n    // Errors from parsing. Check all possible children (recursively)\n    hasParsingError() {\n        var retValue = false,\n            i = 0;\n        if (this.parseError) {\n            retValue = true;\n        }\n\n        while (!retValue && i < this.inputs.length) {\n            // Check for reductions on inputs.\n            retValue = this.inputs[i].hasParsingError();\n            i++;\n        }\n        return retValue;\n    }\n    \n    // Errors from parsing. Find the *first* error in the parsing process.\n    getParsingError() {\n        var errString = this.parseError;\n        var i=0;\n        while (!errString && i < this.inputs.length) {\n            errString = this.inputs[i].getParsingError();\n        }\n        return (errString);\n    }\n    \n    // Method to generate the expression as input-style string.\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        var theStr = '';\n        return(theStr);\n    }\n    \n    // Method to generate the expression using presentation-style (LaTeX)\n    // - showSelect is so that part of the expression can be highlighted\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        return(this.toString());\n    }\n\n    // Method to represent the expression using MathML\n    toMathML() {\n        return(\"<mi>\" + this.toString() + \"</mi>\");\n    }\n    \n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([]);\n    }\n    \n    // To convert binary tree structure to n-ary tree for supported operations (+ and *)\n    // Most things can't flatten. Return a copy.\n    flatten() {\n        return this.copy();\n    }\n    \n    // Test if the expression evaluates to a constant.\n    isConstant() {\n        var retValue = false;\n        return(retValue);\n    }\n    \n    // Test if the expression evaluates to a constant.\n    isExpression() {\n        var retValue = false;\n        return(retValue);\n    }\n\n}\n\nclass expression extends MathObject {\n  constructor(btm) {\n        if (!(btm instanceof _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.BTM)) {\n            throw \"expression constructed with invalid environment\";\n        }\n        super(btm);\n        this.select = false;\n        this.parent = null;\n        this.inputs = [];\n        this.valueType = _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprValue.numeric;\n    }\n\n    // Method to *evaluate* the value of the expression using given symbol bindings.\n    // - Return native Number value\n    value(bindings) {\n        return(this.evaluate(bindings));\n    }\n\n    // When the parser throws an error, need to record it.\n    setParsingError(errorString) {\n        this.parseError = errorString;\n    }\n\n    // Errors from parsing. Check all possible children (recursively)\n    hasParsingError() {\n        var retValue = false,\n            i = 0;\n        if (this.parseError) {\n            retValue = true;\n        }\n\n        while (!retValue && i < this.inputs.length) {\n            // Check for reductions on inputs.\n            retValue = this.inputs[i].hasParsingError();\n            i++;\n        }\n        return retValue;\n    }\n\n    // Errors from parsing. Find the *first* error in the parsing process.\n    getParsingError() {\n        var errString = this.parseError;\n        var i=0;\n        while (!errString && i < this.inputs.length) {\n            errString = this.inputs[i].getParsingError();\n        }\n        return (errString);\n    }\n\n    // Method to generate the expression as input-style string.\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        var theStr = '';\n        return(theStr);\n    }\n\n    // Method to generate the expression using presentation-style (LaTeX)\n    // - showSelect is so that part of the expression can be highlighted\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        return(this.toString());\n    }\n\n    // Method to represent the expression using MathML\n    toMathML() {\n        return(\"<mi>\" + this.toString() + \"</mi>\");\n    }\n\n    operateToTeX() {\n        return(this.toTeX());\n    }\n\n    treeToTeX(expand) {\n        var retStruct = {};\n        \n        retStruct.parent = (typeof this.parent === 'undefined' || this.parent === null) ? null : this.parent.operateToTeX();\n        if (typeof expand === 'undefined' || !expand) {\n            retStruct.current = this.toTeX();\n            retStruct.inputs = null;\n        } else {\n            retStruct.current = this.operateToTeX();\n            retStruct.inputs = [];\n            for (var i in this.inputs) {\n                retStruct.inputs[i] = this.inputs[i].toTeX();\n            }\n        }\n        return(retStruct);\n    }\n\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([]);\n    }\n\n    // To convert binary tree structure to n-ary tree for supported operations (+ and *)\n    // Most things can't flatten. Return a copy.\n    flatten() {\n        return this.copy();\n    }\n\n    // Create a new expression that is a copy.\n    copy() {\n        var myCopy = new expression(this.btm);\n        return myCopy;\n    }\n\n    // When subtree only involves constants, simplify the formula to a value.\n    // Default: Look at all descendants (inputs) and simplify there.\n    simplifyConstants() {\n        for (var i in this.inputs) {\n            this.inputs[i] = this.inputs[i].simplifyConstants();\n            this.inputs[i].parent = this;\n        }\n        return(this);\n    }\n\n    // Find all dependencies (symbols) required to evaluate expression.\n    dependencies(forced) {\n        var inDeps;\n        var i, j;\n        var depArray = new Array();\n\n        var master = {};\n        if (forced != undefined) {\n            for (var i=0; i<forced.length; i++) {\n                depArray.push(forced[i]);\n                master[forced[i]] = true;\n            }\n        }\n        for (i in this.inputs) {\n            inDeps = this.inputs[i].dependencies();\n            for (j in inDeps) {\n                if (typeof master[inDeps[j]] == \"undefined\") {\n                    depArray.push(inDeps[j]);\n                    master[inDeps[j]] = true;\n                }\n            }\n        }\n\n        return(depArray);\n    }\n\n    // Method to return input at given index.\n    getInput(whichInput) {\n        var inputExpr = null;\n        if (whichInput < 0 || whichInput >= this.inputs.length) {\n            throw 'Attempt to get an undefined input expression.';\n        } else {\n            inputExpr = this.inputs[whichInput];\n        }\n        return(inputExpr);\n    }\n\n    // Test if the expression evaluates to a constant.\n    isConstant() {\n        var retValue = true;\n        for (var i in this.inputs) {\n            retValue = retValue & this.inputs[i].isConstant();\n        }\n        return(retValue);\n    }\n\n    // Evaluate the expression given the bindings to symbols.\n    evaluate(bindings) {\n        return(0);\n    }\n\n    // Create a *new* expression where a symbol is *replaced* by a bound expression\n    compose(bindings) {\n        return(new expression(this.btm));\n    }\n\n    // Compare *this* expression to a given *testExpr*.\n    // *options* gives options associated with testing (e.g., relative tolerance)\n    // but also supports fixing certain bindings.\n    // Supports abstract input matching against variables using *matchInputs*\n    compare(testExpr, options, matchInputs) {\n        var isEqual = true;\n        var i, n;\n\n        if (matchInputs == undefined) {\n            matchInputs = false;\n        }\n        if (options == undefined) {\n            options = {};\n        }\n        var knownBindings = Object.keys(options);\n        var unknownBindings = [];\n\n        var rTol = 1e-8;\n        if (typeof options.rTol !== 'undefined') {\n            rTol = options.rTol;\n            i = knownBindings.indexOf('rTol');\n            knownBindings.splice(i, 1);\n        }\n\n        var dependA = this.dependencies();\n        var dependB = testExpr.dependencies();\n\n        for (i=0; i<dependA.length; i++) {\n            if (knownBindings.indexOf(dependA[i]) < 0\n                && unknownBindings.indexOf(dependA[i]) < 0)\n            {\n                unknownBindings.push(dependA[i]);\n            }\n        }\n        for (i=0; i<dependB.length; i++) {\n            if (knownBindings.indexOf(dependB[i]) < 0\n                && unknownBindings.indexOf(dependB[i]) < 0)\n            {\n                unknownBindings.push(dependB[i]);\n            }\n        }\n\n        // Create the arrays of test points.\n        var variableList = [];\n        var testPointList = [];\n        var x, xOpt, xMin, xMax, dx, n, testPoints;\n        n = 10;\n        for (i=0; i<knownBindings.length; i++) {\n            x = knownBindings[i];\n            xOpt = options[x];\n            xMin = xOpt.min;\n            xMax = xOpt.max;\n            dx = (xMax-xMin)/n;\n            testPoints = [];\n            for (var j=0; j<n; j++) {\n                testPoints[j] = xMin+j*dx;\n            }\n            testPoints[n] = xMax;\n\n            // Add this to the list of testing arrays.\n            variableList.push(x);\n            testPointList.push(testPoints);\n        }\n        for (i=0; i<unknownBindings.length; i++) {\n            x = unknownBindings[i];\n            xMin = -2;\n            xMax = 2;\n            dx = (xMax-xMin)/n;\n            testPoints = [];\n            for (var j=0; j<n; j++) {\n                testPoints[j] = xMin+j*dx;\n            }\n            testPoints[n] = xMax;\n\n            // Add this to the list of testing arrays.\n            variableList.push(x);\n            testPointList.push(testPoints);\n        }\n\n        // Now we will proceed through all possible points.\n        // Analogy: Each variable is like one \"digit\" on an odometer.\n        // Go through full cycle of a variable's options and then advance the next variable.\n        // Use an odometer-like array that references which point from\n        // each list is being used. When the last entry reaches the end,\n        // the odometer rolls over until all entries are done.\n        var odometer = [];\n        for (i=0; i<variableList.length; i++)\n            odometer[i]=0;\n        var done = false;\n        while (!done && isEqual) {\n            var y1, y2;\n            var bindings = {};\n            for (i=0; i<variableList.length; i++) {\n                x = variableList[i];\n                bindings[x] = testPointList[i][odometer[i]];\n            }\n            y1 = this.evaluate(bindings);\n            y2 = testExpr.evaluate(bindings);\n            // Both finite? Check for relative error.\n            if (isFinite(y1) && isFinite(y2)) {\n                if (!(Math.abs(y1)<1e-12 && Math.abs(y2)<1e-12)\n                    && Math.abs(y1-y2)/Math.abs(y1)>rTol) {\n                    isEqual = false;\n                }\n                // If one is finite, other must be NaN\n                } else if ( (isFinite(y1) && !isNaN(y2))\n                            || (isFinite(y2) && !isNaN(y1)) ) {\n                    isEqual = false;\n                }\n\n                // Advance the odometer.\n                var j=0;\n                done = true; // This will only persist when the odometer is done.\n                while (j < variableList.length) {\n                    odometer[j]++;\n                    if (odometer[j] >= testPointList[j].length) {\n                        odometer[j] = 0;\n                        j++;\n                    } else {\n                        done = false;\n                        break;\n                    }\n                }\n            }\n            if (matchInputs && isEqual) {\n                var matchOp;\n                if (this.op == '+' || this.op == '-') {\n                    matchOp = '+';\n                } else if (this.op == '*' || this.op == '/') {\n                    matchOp = '*';\n                }\n                if ((matchOp=='+' && testExpr.op != '+' && testExpr.op != '-')\n                    || (matchOp=='*' && testExpr.op != '*' && testExpr.op != '/')) {\n                    isEqual = false;\n                }\n                if (isEqual) {\n                    var flatA, flatB;\n                    flatA = this.flatten();\n                    flatB = testExpr.flatten();\n                    if (flatA.inputs.length == flatB.inputs.length) {\n                    var inputMatched = [];\n                    for (i=0; i<flatA.inputs.length; i++) {\n                        inputMatched[i] = false;\n                    }\n                    // Go through each input of testExpr and see if it matches on of this inputs.\n                    for (i=0; i<flatB.inputs.length && isEqual; i++) {\n                        var matchFound = false;\n                        for (j=0; j<flatA.inputs.length && !matchFound; j++) {\n                            if (!inputMatched[j] && flatA.inputs[j].compare(flatB.inputs[i])) {\n                                inputMatched[j] = true;\n                                matchFound = true;\n                            }\n                        }\n                        if (!matchFound) {\n                            isEqual = false;\n                        }\n                    }\n                } else {\n                    isEqual = false;\n                }\n            }\n        }\n        return(isEqual);\n    }\n\n    // Apply reduction rules to create a reduced expression\n    reduce() {\n        var workExpr = this.simplifyConstants();\n        var matchRules;\n\n        // Check for reductions on inputs.\n        for (var i in workExpr.inputs) {\n            workExpr.inputs[i] = workExpr.inputs[i].reduce();\n        }\n        matchRules = (0,_reductions_js__WEBPACK_IMPORTED_MODULE_1__.findMatchRules)(this.btm.reduceRules, workExpr, true);\n        while (matchRules.length > 0) {\n            workExpr = this.btm.parse(matchRules[0].subStr, this.context);\n            matchRules = (0,_reductions_js__WEBPACK_IMPORTED_MODULE_1__.findMatchRules)(this.btm.reduceRules, workExpr, true);\n        }\n        return workExpr;\n    }\n\n    \n    derivative(ivar, varList) {\n        return(new scalar_expr(this.btm, 0));\n    }\n\n    /*\n        The match method is designed to compare \"this\" expression\n        to the given \"expr\" expression and see if it is consistent with\n        the current bindings. The bindings will be an object where\n        variables in \"this\" are assigned to strings representing expressions.\n        If there is a mismatch, return \"null\" and the matching process should terminate.\n\n        Overrides:\n            - numbers, to deal with scalar formula that simplify\n            - variables, which can match arbitrary expressions.\n            - indexed expressions might need a special method.\n            - multiop, where should see if a variable can match a subcollection of inputs.\n    */\n    match(expr, bindings) {\n        var retValue = null;\n        if (this.type == expr.type && this.operateToTeX() == expr.operateToTeX()) {\n            retValue = bindings;\n            for (var i=0; i<this.inputs.length; i++) {\n                if (retValue !== null) {\n                    retValue = this.inputs[i].match(expr.inputs[i], retValue);\n                }\n            }\n        }\n        return(retValue);\n    }\n\n    inputSubst(origExpr, subExpr) {\n        var i = this.inputs.indexOf(origExpr);\n        if (i >= 0) {\n            this.inputs[i] = subExpr;\n            if (subExpr !== undefined) {\n                subExpr.parent = this;\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack://btm-expressions/./src/expression.js?");

/***/ }),

/***/ "./src/function_expr.js":
/*!******************************!*\
  !*** ./src/function_expr.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"function_expr\": () => (/* binding */ function_expr)\n/* harmony export */ });\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/* harmony import */ var _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar_expr.js */ \"./src/scalar_expr.js\");\n/* harmony import */ var _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variable_expr.js */ \"./src/variable_expr.js\");\n/* harmony import */ var _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unop_expr.js */ \"./src/unop_expr.js\");\n/* harmony import */ var _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binop_expr.js */ \"./src/binop_expr.js\");\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n   * Define the Function Expression -- defined by a function name and input expression\n   * *************************************************** */\n\n\n\n\n\n\n\n\nclass function_expr extends _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression {\n    constructor(btm, name, inputExpr, restrictDomain) {\n        super(btm);\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_5__.exprType.fcn;\n        // Count how many derivatives.\n        var primePos = name.indexOf(\"'\");\n        this.derivs = 0;\n        if (primePos > 0) {\n            this.name = name.slice(0,primePos);\n            this.derivs = name.slice(primePos).length;\n        } else {\n            this.name = name;\n        }\n        if (typeof inputExpr == 'undefined')\n            inputExpr = new _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression(this.btm);\n        this.inputs = [inputExpr];\n        inputExpr.parent = this;\n        this.domain = restrictDomain;\n\n        this.alternate = null;\n        this.builtin = true;\n        switch(this.name) {\n            case 'asin':\n            case 'acos':\n            case 'atan':\n            case 'asec':\n            case 'acsc':\n            case 'acot':\n                this.name = 'arc'+this.name.slice(1,4);\n                break;\n            case 'log':\n                this.name = 'ln';\n                break;\n            case 'sin':\n            case 'cos':\n            case 'tan':\n            case 'csc':\n            case 'sec':\n            case 'cot':\n            case 'arcsin':\n            case 'arccos':\n            case 'arctan':\n            case 'arcsec':\n            case 'arccsc':\n            case 'arccot':\n            case 'sqrt':\n            case 'root':\n            case 'abs':\n            case 'exp':\n            case 'expb':\n            case 'ln':\n            case 'log10':\n                break;\n            default:\n                this.builtin = false;\n                // When using a custom function for the first time, we need to create\n                // a random dummy function for work when not bound to definition.\n                // See if we have already used this function.\n                // For consistency, we should keep it the same.\n                var functionEntry = this.btm.randomBindings[this.name];\n                // If never used previously, generate a random function.\n                // This will allow valid comparisons to occur.\n                if (functionEntry == undefined) {\n                    functionEntry = {};\n                    functionEntry[\"input\"] = \"x\";\n                    var formula = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, this.btm.rng.randRational([-20,20],[1,15]));\n                    var newTerm, varTerm;\n                    for (var i=1; i<=6; i++) {\n                        newTerm = this.btm.parse(\"sin(\"+i+\"*x)\", \"formula\");\n                        newTerm = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, \"*\",\n                                        new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, this.btm.rng.randRational([-20,20],[1,10])),\n                                        newTerm);\n                        formula = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, \"+\", formula, newTerm);\n                    }\n                    functionEntry[\"value\"] = [ formula ];\n                    this.btm.randomBindings[this.name] = functionEntry;\n                }\n                if (this.derivs > 0) {\n                    var xvar = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__.variable_expr(this.btm, \"x\");\n                    for (var i=functionEntry[\"value\"].length; i<=this.derivs; i++) {\n                        functionEntry[\"value\"][i] = functionEntry[\"value\"][i-1].derivative(xvar, {\"x\":0});\n                    }\n                }\n                break;\n        }\n        // If using a derivative of a known function, then we should compute that in advance.\n        if (this.builtin && this.derivs > 0) {\n            var xvar = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__.variable_expr(this.btm, \"x\");\n            var deriv = new function_expr(this.btm, this.name, xvar);\n            for (var i=0; i<this.derivs; i++) {\n                deriv = deriv.derivative(xvar, {\"x\":0});\n            }\n            var binding = {};\n            binding[\"x\"] = inputExpr;\n            this.alternate = deriv.compose(binding);\n        }\n    }\n\n    getName() {\n        return (this.name + \"'\".repeat(this.derivs));\n    }\n\n    toString(elementOnly) {\n        var fcnString, retString;\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        fcnString = this.getName();\n        if (elementOnly) {\n            retString = fcnString;\n        } else {\n            var argStrings = [];\n            if (this.inputs.length == 0 || typeof this.inputs[0] == 'undefined') {\n                argStrings.push('?');\n            } else {\n                for (var i in this.inputs) {\n                    argStrings.push(this.inputs[i].toString());\n                }\n            }\n            retString = fcnString + '(' + argStrings.join(',') + ')';\n        }\n        return(retString);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputs = [], inputOptions = [];\n        for (var i in this.inputs) {\n            inputOptions.push(this.inputs[i].allStringEquivs());\n        }\n        var retValue = [];\n        var fcnString = this.getName();\n        // Want to create a list of all possible input representations.\n        function generateArgs(left, rightOptions) {\n            if (rightOptions.length==0) {\n                allInputs.push(left);\n            } else {\n                var N = left.length;\n                var newLeft = [];\n                for (var k in left) {\n                    newLeft.push(left[k]);\n                }\n                for (var k in rightOptions[0]) {\n                    newLeft[N] = rightOptions[0][k];\n                    generateArgs(newLeft, rightOptions.slice(1));\n                }\n            }\n        }\n        generateArgs([], inputOptions);\n        for (var i in allInputs) {\n            retValue[i] = fcnString+'(' + allInputs[i].join('+') + ')';\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        var texString = '';\n        var fcnString;\n        var argStrings = [];\n        if (typeof this.inputs[0] == 'undefined') {\n            argStrings.push('?');\n        } else {\n            for (var i in this.inputs) {\n                argStrings.push(this.inputs[i].toTeX(showSelect));\n                if (showSelect && this.select) {\n                    argStrings[i] = \"{\\\\color{blue}\" + argStrings[i] + \"}\";\n                }\n            }\n        }\n\n        switch(this.name) {\n            case 'sin':\n                fcnString = '\\\\sin';\n                break;\n            case 'cos':\n                fcnString = '\\\\cos';\n                break;\n            case 'tan':\n                fcnString = '\\\\tan';\n                break;\n            case 'csc':\n                fcnString = '\\\\csc';\n                break;\n            case 'sec':\n                fcnString = '\\\\sec';\n                break;\n            case 'cot':\n                fcnString = '\\\\cot';\n                break;\n            case 'arcsin':\n                fcnString = '\\\\sin^{-1}';\n                break;\n            case 'arccos':\n                fcnString = '\\\\cos^{-1}';\n                break;\n            case 'arctan':\n                fcnString = '\\\\tan^{-1}';\n                break;\n            case 'arccsc':\n                fcnString = '\\\\csc^{-1}';\n                break;\n            case 'arcsec':\n                fcnString = '\\\\sec^{-1}';\n                break;\n            case 'arccot':\n                fcnString = '\\\\cot^{-1}';\n                break;\n            case 'sqrt':\n                fcnString = '\\\\mathrm{sqrt}';\n                texString = '\\\\sqrt{' + argStrings[0] + '}';\n                break;\n            case 'root':\n                fcnString = '\\\\mathrm{root}';\n                texString = '\\\\sqrt[' + argStrings[1] +']{' + argStrings[0] + '}';\n                break;\n            case 'abs':\n                fcnString = '\\\\abs';\n                texString = '\\\\left|' + argStrings[0] + '\\\\right|';\n                break;\n            case 'exp':\n                fcnString = 'e^';\n                texString = 'e^{' + argStrings[0] + '}';\n                break;\n            case 'expb':\n                fcnString = '\\\\exp';\n                break;\n            case 'ln':\n                fcnString = '\\\\ln'\n                break;\n            case 'log10':\n                fcnString = '\\\\log_{10}'\n                break;\n            default:\n                if (this.name.length > 1) {\n                    fcnString = '\\\\mathrm{' + this.name + '}';\n                } else {\n                    fcnString = this.name;\n                }\n                break;\n        }\n        if (this.derivs > 0) {\n            if (this.derivs <= 3) {\n                fcnString = fcnString + \"'\".repeat(this.derivs);\n            } else {\n                fcnString = fcnString + \"^{(\"+this.derivs+\")}\";\n            }\n        }\n\n        if (showSelect && this.select) {\n            fcnString = \"\\\\color{red}{\" + fcnString + \"}\";\n            texString = '';\n        }\n        if (texString == '') {\n            texString = fcnString + ' \\\\mathopen{}\\\\left(' + argStrings.join(',') + '\\\\right)\\\\mathclose{}';\n        }\n        return(texString);\n    }\n\n    toMathML() {\n        var texString;\n        var argString;\n        if (typeof this.inputs[0] == 'undefined') {\n            argString = '?';\n        } else {\n            argString = this.inputs[0].toMathML();\n        }\n        switch(this.name) {\n            case 'sin':\n            case 'cos':\n            case 'tan':\n            case 'csc':\n            case 'sec':\n            case 'cot':\n            case 'arcsin':\n            case 'arccos':\n            case 'arctan':\n            case 'exp':\n            case 'expb':\n            case 'ln':\n            case 'abs':\n                texString = '<apply><' + this.name + '/>' + argString + '</apply>';\n                break;\n            case 'sqrt':\n                texString = '<apply><root/>' + argString + '</apply>';\n                break;\n            case 'log10':\n                texString = '<apply><log/><logbase><cn>10</cn></logbase>' + argString + '</apply>';\n                break;\n            default:\n                texString = '<apply><ci>' + name + '</ci>' + argString + '</apply>';\n                break;\n        }\n        return(texString);\n    }\n\n    operateToTeX() {\n        var fcnString;\n        switch(this.name) {\n            case 'sin':\n                fcnString = '\\\\sin';\n                break;\n            case 'cos':\n                fcnString = '\\\\cos';\n                break;\n            case 'tan':\n                fcnString = '\\\\tan';\n                break;\n            case 'csc':\n                fcnString = '\\\\csc';\n                break;\n            case 'sec':\n                fcnString = '\\\\sec';\n                break;\n            case 'cot':\n                fcnString = '\\\\cot';\n                break;\n            case 'arcsin':\n                fcnString = '\\\\sin^{-1}';\n                break;\n            case 'arccos':\n                fcnString = '\\\\cos^{-1}';\n                break;\n            case 'arctan':\n                fcnString = '\\\\tan^{-1}';\n                break;\n            case 'arccsc':\n                fcnString = '\\\\csc^{-1}';\n                break;\n            case 'arcsec':\n                fcnString = '\\\\sec^{-1}';\n                break;\n            case 'arccot':\n                fcnString = '\\\\cot^{-1}';\n                break;\n            case 'sqrt':\n                fcnString = '\\\\mathrm{sqrt}';\n                break;\n            case 'abs':\n                fcnString = '\\\\abs';\n                break;\n            case 'exp':\n            case 'expb':\n                fcnString = '\\\\exp';\n                break;\n            case 'ln':\n                fcnString = '\\\\ln'\n                break;\n            case 'log10':\n                fcnString = '\\\\log_{10}'\n                break;\n            default:\n                if (this.name.length > 1) {\n                    fcnString = '\\\\mathrm{' + this.name + '}';\n                } else {\n                    fcnString = this.name;\n                }\n                break;\n        }\n        if (this.derivs > 0) {\n            if (this.derivs <= 3) {\n                fcnString = fcnString + \"'\".repeat(this.derivs);\n            } else {\n                fcnString = fcnString + \"^{(\"+this.derivs+\")}\";\n            }\n        }\n\n        return(fcnString+\"(\\\\Box)\");\n    }\n\n    evaluate(bindings) {\n        var inputVal = this.inputs[0].evaluate(bindings);\n        var retVal = undefined;\n\n        if (inputVal == undefined) {\n            return(undefined);\n        }\n\n        // Built-in functions with derivatives have computed derivative earlier.\n        if (this.builtin && this.derivs > 0) {\n            if (this.alternate != undefined) {\n                retVal = this.alternate.evaluate(bindings);\n            } else {\n                console.log(\"Error: Built-in function called with unspecified derivative formula.\");\n            }\n        } else {\n            if (bindings[this.name] == undefined) {\n                // Check the list of common mathematical functions.\n                switch(this.name) {\n                    case 'sin':\n                        retVal = Math.sin(inputVal);\n                        break;\n                    case 'cos':\n                        retVal = Math.cos(inputVal);\n                        break;\n                    case 'tan':\n                        retVal = Math.tan(inputVal);\n                        break;\n                    case 'csc':\n                        retVal = 1/Math.sin(inputVal);\n                        break;\n                    case 'sec':\n                        retVal = 1/Math.cos(inputVal);\n                        break;\n                    case 'cot':\n                        retVal = 1/Math.tan(inputVal);\n                        break;\n                    case 'arcsin':\n                        if (Math.abs(inputVal) <= 1) {\n                            retVal = Math.asin(inputVal);\n                        }\n                        break;\n                    case 'arccos':\n                        if (Math.abs(inputVal) <= 1) {\n                            retVal = Math.acos(inputVal);\n                        }\n                        break;\n                    case 'arctan':\n                        retVal = Math.atan(inputVal);\n                        break;\n                    case 'arccsc':\n                        if (Math.abs(inputVal) >= 1) {\n                            retVal = Math.asin(1/inputVal);\n                        }\n                        break;\n                    case 'arcsec':\n                        if (Math.abs(inputVal) >= 1) {\n                            retVal = Math.acos(1/inputVal);\n                        }\n                        break;\n                    case 'arccot':\n                        if (inputVal == 0) {\n                            retVal = Math.PI/2;\n                        } else {\n                            retVal = Math.PI/2 - Math.atan(1/inputVal);\n                        }\n                        break;\n                    case 'sqrt':\n                        if (inputVal >= 0) {\n                            retVal = Math.sqrt(inputVal);\n                        }\n                        break;\n                    case 'abs':\n                        retVal = Math.abs(inputVal);\n                        break;\n                    case 'exp':\n                    case 'expb':\n                        retVal = Math.exp(inputVal);\n                        break;\n                    case 'ln':\n                        if (inputVal > 0) {\n                            retVal = Math.log(inputVal);\n                        }\n                        break;\n                    case 'log10':\n                        if (inputVal > 0) {\n                            retVal = Math.LOG10E * Math.log(inputVal);\n                        }\n                        break;\n                    default:\n                        // See if we have already used this function.\n                        // For consistency, we should keep it the same.\n                        var functionEntry = this.btm.randomBindings[this.name];\n                        // If never used previously, generate a random function.\n                        // This will allow valid comparisons to occur.\n                        if (functionEntry == undefined) {\n                            console.log(\"Error: A custom function never had a backend definition.\");\n                        }\n                        // Copy the bindings.\n                        var fBind = {};\n                        Object.keys(bindings).forEach(function(key) {\n                            fBind[ key ] = bindings[ key ];\n                        });\n                        // Now, use the variable of the function.\n                        fBind[functionEntry[\"input\"]] = inputVal;\n                        // See if we need additional derivatives in binding\n                        if (this.derivs >= functionEntry[\"value\"].length) {\n                            var ivar = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__.variable_expr(this.btm, functionEntry[\"input\"]);\n                            var varBind = {};\n                            varBind[ivar] = 0;\n                            for (var i=functionEntry[\"value\"].length; i <= this.derivs; i++) {\n                                functionEntry[\"value\"][i] = functionEntry[\"value\"][i-1].derivative(ivar, varBind);\n                            }\n                        }\n                        retVal = functionEntry[\"value\"][this.derivs].evaluate(fBind);\n                        break;\n                }\n            } else {\n                var functionEntry = bindings[this.name];\n                // Copy the bindings.\n                var fBind = {};\n                Object.keys(bindings).forEach(function(key) {\n                    fBind[ key ] = bindings[ key ];\n                });\n                // Now, use the variable of the function.\n                fBind[functionEntry[\"input\"]] = inputVal;\n                // See if we need additional derivatives in binding\n                if (this.derivs >= functionEntry[\"value\"].length) {\n                    var ivar = new _variable_expr_js__WEBPACK_IMPORTED_MODULE_2__.variable_expr(this.btm, functionEntry[\"input\"]);\n                    var varBind = {};\n                    varBind[ivar] = 0;\n                    for (var i=functionEntry[\"value\"].length; i <= this.derivs; i++) {\n                        functionEntry[\"value\"][i] = functionEntry[\"value\"][i-1].derivative(ivar, varBind);\n                    }\n                }\n                retVal = functionEntry[\"value\"][this.derivs].evaluate(fBind);\n            }\n        }\n        return(retVal);\n    }\n\n    flatten() {\n        return(new function_expr(this.btm, this.getName(), this.inputs[0].flatten()));\n    }\n\n    copy() {\n      return(new function_expr(this.btm, this.getName(), this.inputs[0].copy()));\n    }\n\n    compose(bindings) {\n        return(new function_expr(this.btm, this.getName(), this.inputs[0].compose(bindings)));\n    }\n\n    derivative(ivar, varList) {\n        var theDeriv;\n        var depArray = this.inputs[0].dependencies();\n        var uConst = true;\n        var ivarName = (typeof ivar == 'string') ? ivar : ivar.name;\n        for (var i=0; i<depArray.length; i++) {\n            if (depArray[i] == ivarName) {\n                uConst = false;\n            }\n        }\n\n        if (uConst) {\n            theDeriv = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 0);\n        } else {\n            var dydu;\n\n            switch(this.name) {\n                    case 'sin':\n                        dydu = new function_expr(this.btm, 'cos', this.inputs[0]);\n                        break;\n                    case 'cos':\n                        dydu = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '-', new function_expr(this.btm, 'sin', this.inputs[0]));\n                        break;\n                    case 'tan':\n                        var theSec = new function_expr(this.btm, 'sec', this.inputs[0]);\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', theSec, new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2));\n                        break;\n                    case 'csc':\n                        var theCot = new function_expr(this.btm, 'cot', this.inputs[0]);\n                        dydu = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '-', new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '*', this, theCot));\n                        break;\n                    case 'sec':\n                        var theTan = new function_expr(this.btm, 'tan', this.inputs[0]);\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '*', this, theTan);\n                        break;\n                    case 'cot':\n                        var theCsc = new function_expr(this.btm, 'csc', this.inputs[0]);\n                        dydu = new _unop_expr_js__WEBPACK_IMPORTED_MODULE_3__.unop_expr(this.btm, '-', new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', theCsc, new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2)));\n                        break;\n                    case 'arcsin':\n                        var theCos = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '-', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', this.inputs[0], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2)));\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), new function_expr(this.btm, 'sqrt', theCos));\n                        break;\n                    case 'arccos':\n                        var theSin = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '-', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', this.inputs[0], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2)));\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, -1), new function_expr(this.btm, 'sqrt', theSin));\n                        break;\n                    case 'arctan':\n                        var tanSq = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', this.inputs[0], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2));\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '+', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), tanSq));\n                        break;\n                    case 'arcsec':\n                        var theSq = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', this.inputs[0], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2));\n                        var theRad = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '-', theSq, new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1));\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '*', new function_expr(this.btm, 'abs', this.inputs[0]), new function_expr(this.btm, 'sqrt', theRad)));\n                        break;\n                    case 'arccsc':\n                        var theSq = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', this.inputs[0], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2));\n                        var theRad = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '-', theSq, new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1));\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, -1), new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '*', new function_expr(this.btm, 'abs', this.inputs[0]), new function_expr(this.btm, 'sqrt', theRad)));\n                        break;\n                    case 'arccot':\n                        var cotSq = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '^', this.inputs[0], new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2));\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, -1), new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '+', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), cotSq));\n                        break;\n                    case 'sqrt':\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '*', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 2), this));\n                        break;\n                    case 'abs':\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', this, this.inputs[0]);\n                        break;\n                    case 'exp':\n                    case 'expb':\n                        dydu = new function_expr(this.btm, this.name, this.inputs[0]);\n                        break;\n                    case 'ln':\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1), this.inputs[0]);\n                        break;\n                    case 'log10':\n                        dydu = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '/', new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, Math.LOG10E), this.inputs[0]);\n                        break;\n                    default:\n                        dydu = new function_expr(this.btm, this.getName()+\"'\", this.inputs[0]);\n                        break;\n            }\n            if (!uConst && this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_5__.exprType.variable) {\n                theDeriv = dydu;\n            } else {\n                var dudx = this.inputs[0].derivative(ivar, varList);\n\n                if (dudx == undefined) {\n                    theDeriv = undefined;\n                } else {\n                    theDeriv = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_4__.binop_expr(this.btm, '*', dydu, dudx);\n                }\n            }\n        }\n        return(theDeriv);\n    }\n}\n\n//# sourceURL=webpack://btm-expressions/./src/function_expr.js?");

/***/ }),

/***/ "./src/multiop_expr.js":
/*!*****************************!*\
  !*** ./src/multiop_expr.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"multiop_expr\": () => (/* binding */ multiop_expr)\n/* harmony export */ });\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/* harmony import */ var _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar_expr.js */ \"./src/scalar_expr.js\");\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Multi-Operand Expression (for sum and product)\n* *************************************************** */\n\n\n\n\n\nclass multiop_expr extends _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression {\n    constructor(btm, op, inputs) {\n        super(btm);\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.multiop;\n        this.op = op;\n        this.inputs = inputs; // an array\n        for (var i in inputs) {\n            if (typeof inputs[i] == 'undefined')\n                inputs[i] = new _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression(this.btm);\n            inputs[i].parent = this;\n        }\n        switch (op) {\n            case '+':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.opPrec.addsub;\n                break;\n            case '*':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.opPrec.multdiv;\n                break;\n            default:\n                alert(\"Unknown multi-operand operator: '\"+op+\"'.\");\n                break;\n        }\n    }\n\n    toString() {\n        var theStr,\n            opStr,\n            isError = false,\n            showOp;\n\n        theStr = '';\n        for (var i in this.inputs) {\n            showOp = true;\n            if (typeof this.inputs[i] == 'undefined') {\n                opStr = '?';\n                isError = true;\n            } else {\n                opStr = this.inputs[i].toString();\n                if ((this.inputs[i].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.unop\n                        && this.inputs[i].prec <= this.prec)\n                    || (this.inputs[i].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.number\n                        && this.inputs[i].number.q != 1\n                        && _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.opPrec.multdiv <= this.prec)\n                ) {\n                    opStr = '(' + opStr + ')';\n                }\n            }\n            theStr += ( i>0 ? this.op : '' ) + opStr;\n        }\n\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputsArrays = [];\n\n        var indexList = [];\n        for (var i in this.inputs) {\n            allInputsArrays[i] = this.inputs[i].allStringEquivs();\n            indexList.push(i);\n        }\n        var inputPerms = permutations(indexList);\n\n        var retValue = [];\n\n        var theOp = this.op;\n        if (theOp == '|') {\n            // Don't want \"or\" to be translated as absolute value\n            theOp = ' $ ';\n        }\n\n        function buildStringEquivs(indexList, leftStr) {\n            if (typeof leftStr == \"undefined\") {\n                leftStr = \"\";\n            } else if (indexList.length > 0) {\n                leftStr += theOp;\n            }\n            if (indexList.length > 0) {\n                var workInputs = allInputsArrays[indexList[0]];\n                for (var i in workInputs) {\n                    buildStringEquivs(indexList.slice(1), leftStr + \"(\" + workInputs[i] + \")\");\n                }\n            } else {\n                retValue.push(leftStr);\n            }\n        }\n\n        for (var i in inputPerms) {\n            buildStringEquivs(inputPerms[i]);\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var theOp;\n        var opStr;\n        var argStrL, argStrR, opStrL, opStrR;\n\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n\n        theOp = this.op;\n        if (this.op == '*') {\n            if (showSelect && this.select) {\n                theOp = '\\\\times';\n            } else {\n                theOp = ' ';\n            }\n        }\n\n        if (showSelect && this.select) {\n            argStrL = '{\\\\color{blue}';\n            argStrR = '}';\n            opStrL = '{\\\\color{red}';\n            opStrR = '}';\n        } else {\n            argStrL = '';\n            argStrR = '';\n            opStrL = '';\n            opStrR = '';\n        }\n\n        theStr = '';\n        var minPrec = this.prec;\n        for (var i in this.inputs) {\n            if (typeof this.inputs[i] == 'undefined') {\n                opStr = '?';\n                theStr += ( i>0 ? opStrL + theOp + opStrR : '' ) + opStr;\n            } else {\n                if (this.op == '*'\n                        && this.inputs[i].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.unop && this.inputs[i].op == '/'\n                        && !(showSelect && this.select))\n                {\n                    opStr = argStrL + this.inputs[i].inputs[0].toTeX(showSelect) + argStrR;\n                    if (this.inputs[i].inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.unop && this.inputs[i].inputs[0].prec < minPrec) {\n                        opStr = '\\\\left(' + opStr + '\\\\right)';\n                    }\n                    if (theStr == '') {\n                        theStr = '1'\n                    }\n                    theStr = '\\\\frac{' + theStr + '}{' + opStr + '}';\n\n                } else if (this.op == '+'\n                        && this.inputs[i].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.unop && this.inputs[i].op == '-'\n                        && !(showSelect && this.select))\n                {\n                    opStr = argStrL + this.inputs[i].toTeX(showSelect) + argStrR;\n                    theStr += opStr;\n                } else {\n                    opStr = argStrL + this.inputs[i].toTeX(showSelect) + argStrR;\n                    if ((this.inputs[i].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.unop\n                            && this.inputs[i].prec <= minPrec)\n                        || (i>0 && this.op == '*' && this.inputs[i].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.number)) {\n                        opStr = '\\\\left(' + opStr + '\\\\right)';\n                    }\n                    theStr += ( i>0 ? opStrL + theOp + opStrR : '' ) + opStr;\n                }\n            }\n        }\n\n        return(theStr);\n    }\n\n    toMathML() {\n        var theStr;\n        var theOp;\n        var opStr;\n\n        switch (this.op) {\n            case '+':\n                theOp = \"<plus/>\"\n                break;\n            case '*':\n                theOp = \"<times/>\"\n                break;\n        }\n\n        theStr = \"<apply>\" + theOp;\n        for (var i in this.inputs) {\n            if (typeof this.inputs[i] == 'undefined') {\n                opStr = '?';\n            } else {\n                opStr = this.inputs[i].toMathML();\n            }\n            theStr += opStr;\n        }\n        theStr += \"</apply>\";\n\n        return(theStr);\n    }\n\n    operateToTeX() {\n        var opString = this.op;\n\n        switch (opString) {\n            case '*':\n                opString = '\\\\times';\n                break;\n        }\n\n        return(opString);\n    }\n\n    isCommutative() {\n        var commutes = false;\n        if (this.op === '+' || this.op === '*') {\n            commutes = true;\n        }\n        return(commutes);\n    }\n\n    evaluate(bindings) {\n        var inputVal;\n        var i;\n        var retVal;\n\n        switch (this.op) {\n            case '+':\n                retVal = 0;\n                for (i in this.inputs) {\n                    inputVal = this.inputs[i].evaluate(bindings);\n                    retVal += inputVal;\n                }\n                break;\n            case '*':\n                retVal = 1;\n                for (i in this.inputs) {\n                    inputVal = this.inputs[i].evaluate(bindings);\n                    retVal *= inputVal;\n                }\n                break;\n            default:\n                console.log(\"The binary operator '\" + this.op + \"' is not defined.\");\n                retVal = undefined;\n                break;\n        }\n        return(retVal);\n    }\n\n    // Flatten and also sort terms.\n    flatten() {\n        var newInputs = [];\n        for (var i in this.inputs) {\n            var nextInput = this.inputs[i].flatten();\n            if (nextInput.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.multiop && nextInput.op == this.op) {\n                for (var j in nextInput.inputs) {\n                    newInputs.push(nextInput.inputs[j]);\n                }\n            } else {\n                newInputs.push(nextInput);\n            }\n        }\n\n        var retValue;\n        if (newInputs.length == 0) {\n            // Adding no elements = 0\n            // Multiplying no elements = 1\n            retValue = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, this.op == '+' ? 0 : 1);\n        } else if (newInputs.length == 1) {\n            retValue = newInputs[0];\n        } else {\n            // Sort the inputs by precedence for products\n            // Usually very small, so bubble sort is good enough\n            if (this.op=='*') {\n                var tmp;\n                for (var i=0; i<newInputs.length-1; i++) {\n                    for (var j=i+1; j<newInputs.length; j++) {\n                        if (newInputs[i].type > newInputs[j].type) {\n                            tmp = newInputs[i];\n                            newInputs[i] = newInputs[j];\n                            newInputs[j] = tmp;\n                        }\n                    }\n                }\n            }\n            retValue = new multiop_expr(this.btm, this.op, newInputs);\n        }\n        return(retValue);\n    }\n\n    // See if this operator is now redundant.\n    // Return the resulting expression.\n    reduce() {\n        var newExpr = this;\n        if (this.inputs.length <= 1) {\n            if (this.inputs.length == 0) {\n                // Sum with no elements = 0\n                // Product with no elements = 1\n                newExpr = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, this.op == '+' ? 0 : 1);\n            } else {\n                // Sum or product with one element *is* that element.\n                newExpr = this.inputs[0];\n            }\n            newExpr.parent = this.parent;\n            if (this.parent !== null) {\n                this.parent.inputSubst(this, newExpr);\n            }\n        }\n        return(newExpr);\n    }\n\n    simplifyConstants() {\n        var i,\n            constIndex = [],\n            newInputs = [];\n        // Simplify all inputs\n        // Notice which inputs are themselves constant \n        for (i in this.inputs) {\n            this.inputs[i] = this.inputs[i].simplifyConstants();\n            this.inputs[i].parent = this;\n            if (this.inputs[i].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.number) {\n                constIndex.push(i);\n            } else {\n                newInputs.push(this.inputs[i]);\n            }\n        }\n\n        // For all inputs that are constants, group them together and simplify.\n        var newExpr = this;\n        if (constIndex.length > 1) {\n            var newConstant = this.inputs[constIndex[0]].number;\n            for (i=1; i<constIndex.length; i++) {\n                switch (this.op) {\n                    case '+':\n                        newConstant = newConstant.add(this.inputs[constIndex[i]].number);\n                        break;\n                    case '*':\n                        newConstant = newConstant.multiply(this.inputs[constIndex[i]].number);\n                        break;\n                }\n            }\n\n            // For addition, the constant goes to the end.\n            // For multiplication, the constant goes to the beginning.\n            var newInput;\n            switch (this.op) {\n                case '+':\n                    newInputs.push(newInput = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, newConstant));\n                    break;\n                case '*':\n                    newInputs.splice(0, 0, newInput = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, newConstant));\n                    break;\n            }\n            if (newInputs.length == 1) {\n                newExpr = newInputs[0];\n            } else {\n                newInput.parent = this;\n                newExpr = new multiop_expr(this.btm, this.op, newInputs);\n            }\n        }\n        return(newExpr);\n    }\n\n    // This comparison routine needs to deal with two issues.\n    // (1) The passed expression has more inputs than this (in which case we group them)\n    // (2) Possibility of commuting makes the match work.\n    match(expr, bindings) {\n        function copyBindings(bindings)\n        {\n            var retValue = {};\n            for (var key in bindings) {\n                retValue[key] = bindings[key];\n            }\n            return(retValue);\n        }\n\n        var retValue = null,\n            n = this.inputs.length;\n        if (expr.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.multiop && this.op == expr.op\n                && n <= expr.inputs.length) {\n\n            // Match on first n-1 and group remainder at end.\n            var cmpExpr,\n                cmpInputs = [];\n\n            for (var i=0; i<n; i++) {\n                if (i<(n-1) || expr.inputs.length==n) {\n                    cmpInputs[i] = this.btm.parse(expr.inputs[i].toString(), expr.inputs[i].context);\n                } else {\n                    // Create copies of the inputs\n                    var newInputs = [];\n                    for (var j=0; j<=expr.inputs.length-n; j++) {\n                        newInputs[j] = this.btm.parse(expr.inputs[n+j-1].toString(), expr.inputs[n+j-1].context);\n                    }\n                    cmpInputs[i] = new multiop_expr(this.btm, expr.op, newInputs);\n                }\n            }\n            cmpExpr = new multiop_expr(this.btm, expr.op, cmpInputs);\n\n            // Now make the comparison.\n            retValue = copyBindings(bindings);\n            retValue = _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression.prototype.match.call(this, cmpExpr, retValue);\n\n            // If still fail to match, try the reverse grouping: match on last n-1 and group beginning.\n            if (retValue == null && n < expr.inputs.length) {\n                var diff = expr.inputs.length - n;\n                cmpInputs = [];\n\n                for (var i=0; i<n; i++) {\n                    if (i==0) {\n                        // Create copies of the inputs\n                        var newInputs = [];\n                        for (var j=0; j<=diff; j++) {\n                            newInputs[j] = this.btm.parse(expr.inputs[j].toString(), expr.inputs[j].context);\n                        }\n                        cmpInputs[i] = new multiop_expr(this.btm, expr.op, newInputs);\n                    } else {\n                        cmpInputs[i] = this.btm.parse(expr.inputs[diff+i].toString(), expr.inputs[diff+i].context);\n                    }\n                }\n                cmpExpr = new multiop_expr(this.btm, expr.op, cmpInputs);\n\n                // Now make the comparison.\n                retValue = copyBindings(bindings);\n                retValue = _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression.prototype.match.call(this, cmpExpr, retValue);\n            }\n        }\n        return(retValue);\n    }\n\n    compose(bindings) {\n        var newInputs = [];\n\n        for (var i in this.inputs) {\n            newInputs.push(this.inputs[i].compose(bindings));\n        }\n\n        var retValue;\n        if (newInputs.length == 0) {\n            retValue = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, this.op == '+' ? 0 : 1);\n        } else if (newInputs.length == 1) {\n            retValue = newInputs[0];\n        } else {\n            retValue = new multiop_expr(this.btm, this.op, newInputs);\n        }\n        return(retValue);\n    }\n\n    derivative(ivar, varList) {\n        var dTerms = [];\n\n        var theDeriv;\n        var i, dudx;\n        for (i in this.inputs) {\n            if (!this.inputs[i].isConstant()) {\n                dudx = this.inputs[i].derivative(ivar, varList);\n                switch (this.op) {\n                    case '+':\n                        dTerms.push(dudx);\n                        break;\n                    case '*':\n                        var dProdTerms = [];\n                        for (j in this.inputs) {\n                            if (i == j) {\n                                dProdTerms.push(dudx);\n                            } else {\n                                dProdTerms.push(this.inputs[j].compose({}));\n                            }\n                        }\n                        dTerms.push(new multiop_expr(this.btm, '*', dProdTerms));\n                        break;\n                }\n            }\n        }\n        if (dTerms.length == 0) {\n            theDeriv = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 0);\n        } else if (dTerms.length == 1) {\n            theDeriv = dTerms[0];\n        } else {\n            theDeriv = new multiop_expr(this.btm, '+', dTerms);\n        }\n        return(theDeriv);\n    }\n}\n\n//# sourceURL=webpack://btm-expressions/./src/multiop_expr.js?");

/***/ }),

/***/ "./src/random.js":
/*!***********************!*\
  !*** ./src/random.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RNG\": () => (/* binding */ RNG)\n/* harmony export */ });\n/* harmony import */ var _rational_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rational_number.js */ \"./src/rational_number.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n\n\n/* ****************************************************\n*    Routines for dealing with random values\n* **************************************************** */\n\n/* To use a seeded RNG, we rely on an open source project for the underlying mechanics. */\n\n/*////////////////////////////////////////////////////////////////\naleaPRNG 1.1\n//////////////////////////////////////////////////////////////////\nhttps://github.com/macmcmeans/aleaPRNG/blob/master/aleaPRNG-1.1.js\n//////////////////////////////////////////////////////////////////\nOriginal work copyright © 2010 Johannes Baagøe, under MIT license\nThis is a derivative work copyright (c) 2017-2020, W. Mac\" McMeans, under BSD license.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n////////////////////////////////////////////////////////////////*/\nfunction aleaPRNG() {\n    return( function( args ) {\n        \"use strict\";\n\n        const version = 'aleaPRNG 1.1.0';\n\n        var s0\n            , s1\n            , s2\n            , c\n            , uinta = new Uint32Array( 3 )\n            , initialArgs\n            , mashver = ''\n        ;\n\n        /* private: initializes generator with specified seed */\n        function _initState( _internalSeed ) {\n            var mash = Mash();\n\n            // internal state of generator\n            s0 = mash( ' ' );\n            s1 = mash( ' ' );\n            s2 = mash( ' ' );\n\n            c = 1;\n\n            for( var i = 0; i < _internalSeed.length; i++ ) {\n                s0 -= mash( _internalSeed[ i ] );\n                if( s0 < 0 ) { s0 += 1; }\n\n                s1 -= mash( _internalSeed[ i ] );\n                if( s1 < 0 ) { s1 += 1; }\n                \n                s2 -= mash( _internalSeed[ i ] );\n                if( s2 < 0 ) { s2 += 1; }\n            }\n\n            mashver = mash.version;\n\n            mash = null;\n        };\n\n        /* private: dependent string hash function */\n        function Mash() {\n            var n = 4022871197; // 0xefc8249d\n\n            var mash = function( data ) {\n                data = data.toString();\n                \n                // cache the length\n                for( var i = 0, l = data.length; i < l; i++ ) {\n                    n += data.charCodeAt( i );\n                    \n                    var h = 0.02519603282416938 * n;\n                    \n                    n  = h >>> 0;\n                    h -= n;\n                    h *= n;\n                    n  = h >>> 0;\n                    h -= n;\n                    n += h * 4294967296; // 0x100000000      2^32\n                }\n                return ( n >>> 0 ) * 2.3283064365386963e-10; // 2^-32\n            };\n\n            mash.version = 'Mash 0.9';\n            return mash;\n        };\n\n\n        /* private: check if number is integer */\n        function _isInteger( _int ) { \n            return parseInt( _int, 10 ) === _int; \n        };\n\n        /* public: return a 32-bit fraction in the range [0, 1]\n        This is the main function returned when aleaPRNG is instantiated\n        */\n        var random = function() {\n            var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n            \n            s0 = s1;\n            s1 = s2;\n\n            return s2 = t - ( c = t | 0 );\n        };\n\n        /* public: return a 53-bit fraction in the range [0, 1] */\n        random.fract53 = function() {\n            return random() + ( random() * 0x200000  | 0 ) * 1.1102230246251565e-16; // 2^-53\n        };\n\n        /* public: return an unsigned integer in the range [0, 2^32] */\n        random.int32 = function() {\n            return random() * 0x100000000; // 2^32\n        };\n\n        /* public: advance the generator the specified amount of cycles */\n        random.cycle = function( _run ) {\n            _run = typeof _run === 'undefined' ? 1 : +_run;\n            if( _run < 1 ) { _run = 1; }\n            for( var i = 0; i < _run; i++ ) { random(); }\n        };\n\n        /* public: return inclusive range */\n        random.range = function() { \n            var loBound\n                , hiBound\n            ;\n            \n            if( arguments.length === 1 ) {\n                loBound = 0;\n                hiBound = arguments[ 0 ];\n\n            } else {\n                loBound = arguments[ 0 ];\n                hiBound = arguments[ 1 ];\n            }\n\n            if( arguments[ 0 ] > arguments[ 1 ] ) { \n                loBound = arguments[ 1 ];\n                hiBound = arguments[ 0 ];\n            }\n\n            // return integer\n            if( _isInteger( loBound ) && _isInteger( hiBound ) ) { \n                return Math.floor( random() * ( hiBound - loBound + 1 ) ) + loBound; \n\n            // return float\n            } else {\n                return random() * ( hiBound - loBound ) + loBound; \n            }\n        };\n\n        /* public: initialize generator with the seed values used upon instantiation */\n        random.restart = function() {\n            _initState( initialArgs );\n        };\n\n        /* public: seeding function */\n        random.seed = function() { \n            _initState( Array.prototype.slice.call( arguments ) );\n        }; \n\n        /* public: show the version of the RNG */\n        random.version = function() { \n            return version;\n        }; \n\n        /* public: show the version of the RNG and the Mash string hasher */\n        random.versions = function() { \n            return version + ', ' + mashver;\n        }; \n\n        // when no seed is specified, create a random one from Windows Crypto (Monte Carlo application) \n        if( args.length === 0 ) {\n             window.crypto.getRandomValues( uinta );\n             args = [ uinta[ 0 ], uinta[ 1 ], uinta[ 2 ] ];\n        };\n\n        // store the seed used when the RNG was instantiated, if any\n        initialArgs = args;\n\n        // initialize the RNG\n        _initState( args );\n\n        return random;\n\n    })( Array.prototype.slice.call( arguments ) );\n};\n\nclass RNG {\n    constructor(rngSettings) {\n        if (rngSettings.rand) {\n          this.rand = rngSettings.rand;\n        } else {\n          let seed;\n          if (rngSettings.seed == undefined) {\n            seed = new Date().getTime().toString();\n          } else {\n            seed = rngSettings.seed;\n          }\n          this.rand = aleaPRNG(seed);\n        }\n    }\n\n    setSeed(seed) {\n        this.alea.seed(seed.toString());\n    }\n\n    // Standard uniform generator values in [0,1)\n    random() {\n        return(this.rand());\n    }\n\n    // Randomly choose +1 or -1.\n    randSign() {\n        var a = 2*Math.floor(2*this.random())-1;\n        return(a);\n    }\n\n    // Randomly choose integer uniformly in {min, ..., max}.\n    randInt(min, max) {\n        var a = min+Math.floor( (max-min+1)*this.random() );\n        return(a);\n    }\n    \n    // Randomly choose floating point uniformly in [min,max)\n    randUniform(min, max) {\n        var a = min+(max-min)*this.random();\n        return(a);\n    }\n\n    // Randomly a k-length permuted subsequence of {min, ..., max}\n    randChoice(min, max, k) {\n        var a = new Array();\n        var b = new Array();\n        var i,j;\n        for (i=0; i<=max-min; i++) {\n            a[i] = min+i;\n        }\n        for (i=0; i<k; i++) {\n            j = Math.floor( (max-min+1-i)*this.random() );\n            b[i] = a.splice(j,1)[0];\n        }\n\n        return (b);\n    }\n\n    // Generate a random rational number, passing in 2-len arrays for limits.\n    randRational(pLims, qLims) {\n        var p, q;\n\n        // Find the raw rational number\n        p = this.randInt(pLims[0], pLims[1]);\n        q = this.randInt(qLims[0], qLims[1]);\n\n        return (new _rational_number_js__WEBPACK_IMPORTED_MODULE_0__.rational_number(p,q));\n    }\n\n    // Generate a random hex code of desired length.\n    randHexHash(n) {\n      var hash = '';\n      var chars = '0123456789abcdef';\n      for (var i=0; i<n; i++) {\n        hash += chars[this.randInt(0,15)];\n      }\n      return hash;\n    }\n}\n\n//# sourceURL=webpack://btm-expressions/./src/random.js?");

/***/ }),

/***/ "./src/rational_number.js":
/*!********************************!*\
  !*** ./src/rational_number.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"findGCD\": () => (/* binding */ findGCD),\n/* harmony export */   \"rational_number\": () => (/* binding */ rational_number)\n/* harmony export */ });\n/* harmony import */ var _real_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./real_number.js */ \"./src/real_number.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* *******************************\n** Define a class to work with rational numbers\n******************************* */\n\n\n\n/* Private utility commands. */\n  \nfunction isInt(x) {\n    var retValue = false;\n    if (Number.isInteger === undefined) {\n    retValue = (x == Math.floor(x));\n    } else {\n    retValue = Number.isInteger(x);\n    }\n    return retValue;\n}\n\n\n // Implement Euclid's algorithm.\n function findGCD(a,b) {\n    var c;\n    a = Math.abs(a);\n    b = Math.abs(b);\n    if (a < b) {\n        c=a; a=b; b=c;\n    }\n\n    if (b == 0)\n        return 0;\n\n    // In this loop, we always have a > b.\n    while (b > 0) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nclass rational_number extends _real_number_js__WEBPACK_IMPORTED_MODULE_0__.real_number {\n    constructor(p,q) {\n        if (q == undefined) {\n            super(p);\n            this.p = p;\n            this.q = 1;\n        } else {\n            super(p/q);\n            if (q == 0) {\n                this.p = Math.sqrt(-1);\n                this.q = 1;\n            } else if (p == 0) {\n                this.p = 0;\n                this.q = 1;\n            } else {\n                if (q < 0) {\n                  this.p = -p;\n                  this.q = -q;\n                } else {\n                  this.p = p;\n                  this.q = q;\n                }\n                this.simplify();\n            }\n        }\n    }\n\n    // Return a numerical value of the rational expression.\n    value() {\n        return (this.p/this.q);\n    }\n    \n    // Use Euclid's algorithm to find the gcd, then reduce\n    simplify() {\n        var a;\n\n        // Don't simplify if not ratio of integers.\n        if (this.p % 1 != 0 || this.q % 1 != 0) {\n        return;\n        }\n        a = findGCD(this.p, this.q);\n        this.p /= a;\n        this.q /= a;\n    }\n\n    equal(other) {\n        if (other.constructor.name != \"rational_number\") {\n          return (this.value()==other.value());\n        } else {\n          return (this.p.valueOf()==other.p.valueOf()\n                    && this.q.valueOf() == other.q.valueOf());\n        }\n    }\n\n    // Add to this rational another rational number and create new object.\n    add(other) {\n        var sum;\n        if (other instanceof rational_number) {\n        sum = new rational_number(this.p*other.q+other.p*this.q, this.q*other.q);\n        } else if (isInt(other)) {\n        sum = new rational_number(this.p+other*this.q, this.q);\n        } else {\n        sum = new _real_number_js__WEBPACK_IMPORTED_MODULE_0__.real_number(this.value() + other);\n        }\n        return(sum);\n    }\n\n    // Subtract from this rational another rational number and create new object.\n    subtract(other) {\n        var sum;\n        if (other instanceof rational_number) {\n            sum = new rational_number(this.p*other.q-other.p*this.q, this.q*other.q);\n        } else if (isInt(other)) {\n            sum = new rational_number(this.p-other*this.q, this.q);\n        } else {\n            sum = new _real_number_js__WEBPACK_IMPORTED_MODULE_0__.real_number(this.value() - other);\n        }\n        return(sum);\n    }\n\n    // Multiply this rational by another rational number and create new object.\n    multiply(other) {\n        var product;\n        if (other instanceof rational_number) {\n            product = new rational_number(this.p*other.p, this.q*other.q);\n        } else if (isInt(other)) {\n            product = new rational_number(this.p*other, this.q);\n        } else {\n            product = new _real_number_js__WEBPACK_IMPORTED_MODULE_0__.real_number(this.value() * other);\n        }\n\n        return(product);\n    }\n\n    // Divide this rational by another rational number and create new object.\n    divide(other) {\n        var product;\n        if (other instanceof rational_number) {\n            product = new rational_number(this.p*other.q, this.q*other.p);\n        } else if (isInt(other)) {\n            product = new rational_number(this.p, this.q*other);\n        } else {\n            product = new _real_number_js__WEBPACK_IMPORTED_MODULE_0__.real_number(this.value() / other);\n        }\n\n        return(product);\n    }\n\n    // Additive Inverse\n    addInverse() {\n        var inverse = new rational_number(-this.p, this.q);\n        return(inverse);\n    }\n\n    // Multiplicative Inverse\n    multInverse() {\n        var inverse;\n        if (this.p != 0) {\n            inverse = new rational_number(this.q, this.p);\n        } else {\n            inverse = new _real_number_js__WEBPACK_IMPORTED_MODULE_0__.real_number(NaN);\n        }\n        return(inverse);\n    }\n\n    // Format the rational number as string.\n    toString(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.p>0) ? '+' : '';\n        if (isNaN(this.p)) {\n            str = 'NaN';\n        } else if (this.q == 1) {\n            str = str + this.p;\n        } else {\n            str = str + this.p + '/' + this.q;\n        }\n\n        return(str);\n    }\n\n    // Format the rational number as TeX string.\n    toTeX(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.p>0) ? '+' : '';\n        if (isNaN(this.p)) {\n            str = '\\\\mathrm{NaN}';\n        } else if (this.q == 1) {\n            str = str + this.p;\n        } else {\n            if (this.p < 0) {\n                str = '-\\\\frac{' + -this.p + '}{' + this.q + '}';\n            } else {\n                str = str + '\\\\frac{' + this.p + '}{' + this.q + '}';\n            }\n        }\n\n        return(str);\n    }\n\n    toMathML() {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var opAStr = \"<cn>\" + this.p + \"</cn>\",\n            opBStr = \"<cn>\" + this.q + \"</cn>\";\n\n        return(\"<cn>\" + this.toString() + \"</cn>\");\n\n        if (isNaN(this.p)) {\n            str = \"<cn>?</cn>\";\n        } else if (this.q == 1) {\n            str = opAStr;\n        } else {\n            str = \"<apply><divide/>\"+opAStr+opBStr+\"</apply>\";\n        }\n    }\n}\n\n\n\n\n\n \n\n\n\n\n\n//# sourceURL=webpack://btm-expressions/./src/rational_number.js?");

/***/ }),

/***/ "./src/real_number.js":
/*!****************************!*\
  !*** ./src/real_number.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"real_number\": () => (/* binding */ real_number)\n/* harmony export */ });\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* *******************************\n** Define a generic class to work numbers\n******************************* */\n\nclass real_number {\n    constructor(a) {\n      if (typeof a === 'number' || a instanceof Number) {\n        this.number = a;\n      } else if (a instanceof real_number) {\n        this.number = a.number;\n      }\n    }\n\n    // Return a numerical value of the rational expression.\n    value() {\n        return this.number;\n    }\n    \n    // Real numbers have no natural simplification, but declaring the method.\n    simplify() {\n    }\n\n    equal(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        return (this.value()==other.value());\n    }\n\n    // Add numbers.\n    add(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var sum = new real_number(this.number + other.value());\n        return(sum);\n    }\n\n    // Subtract this - other\n    subtract(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var sum = new real_number(this.number - other.value());\n        return(sum);\n    }\n\n    // Multiply this rational by another rational number and create new object.\n    multiply(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var product = new real_number(this.number * other.value());\n        return(product);\n    }\n\n    // Divide this rational by another rational number and create new object.\n    divide(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var product;\n        if (other.value != 0) {\n            product = new real_number(this.number / other.value());\n        } else {\n            product = new real_number(NaN);\n        }\n        return(product);\n    }\n\n    // Additive Inverse\n    addInverse() {\n        var inverse = new real_number(-this.number);\n        return(inverse);\n    }\n\n    // Multiplicative Inverse\n    multInverse() {\n        var inverse;\n        if (this.number != 0) {\n            inverse = new real_number(this.number);\n        } else {\n            inverse = new real_number(NaN);\n        }\n        return(inverse);\n    }\n\n    toString(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.number>0) ? '+' : '';\n        if (isNaN(this.number)) {\n            str = 'NaN';\n        } else {\n            str = str + Number(this.number.toFixed(10));\n        }\n  \n        return(str);\n    }\n  \n    // Format the rational number as TeX string.\n    toTeX(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.number>0) ? '+' : '';\n        if (isNaN(this.number)) {\n            str = '\\\\mathrm{NaN}';\n        } else {\n            str = str + Number(this.toString(leadSign));\n        }\n        return(str);\n    }\n\n    // Format as a root MathML element.\n    toMathML(leadSign) {\n        return(\"<cn>\" + this.toString() + \"</cn>\");\n    }\n}\n\n\n\n\n\n \n\n\n\n\n\n//# sourceURL=webpack://btm-expressions/./src/real_number.js?");

/***/ }),

/***/ "./src/reductions.js":
/*!***************************!*\
  !*** ./src/reductions.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultProductReductions\": () => (/* binding */ defaultProductReductions),\n/* harmony export */   \"defaultReductions\": () => (/* binding */ defaultReductions),\n/* harmony export */   \"defaultSumReductions\": () => (/* binding */ defaultSumReductions),\n/* harmony export */   \"disableRule\": () => (/* binding */ disableRule),\n/* harmony export */   \"findMatchRules\": () => (/* binding */ findMatchRules),\n/* harmony export */   \"newRule\": () => (/* binding */ newRule)\n/* harmony export */ });\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* *********************************************************************************\n**  Dealing with identities and reductions.\n********************************************************************************* */\n\n\n\nclass Identity {\n    constructor(refExpr, eqExpr, description, isValid, idNum) {\n        this.refExpr = refExpr;\n        this.eqExpr = eqExpr;\n        this.description = description;\n        this.isValid = isValid;\n        this.isActive = true;\n        this.idNum = idNum;\n    }\n}\n\nclass Match {\n    constructor(testRule, bindings) {\n        // Find unbound variables.\n        var allVars = testRule.eqExpr.dependencies(),\n            missVars = [];\n        for (var j in allVars) {\n            if (typeof bindings[allVars[j]] == 'undefined') {\n                missVars.push(allVars[j]);\n            }\n        }\n        for (var j in missVars) {\n            bindings[missVars[j]] = \"input\"+(+j+1)+\"\";\n        }\n        var substExpr = testRule.eqExpr.compose(bindings);\n\n        this.subTeX = substExpr.toTeX();\n        this.subStr = substExpr.toString();\n        this.name = testRule.description;\n        if (substExpr.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprType.binop && substExpr.valueType == _BTM_root_js__WEBPACK_IMPORTED_MODULE_0__.exprValue.bool) {\n            this.equation = testRule.refExpr.toTeX() + \" \\\\iff \" + testRule.eqExpr.toTeX();\n        } else {\n            this.equation = testRule.refExpr.toTeX() + \"=\" + testRule.eqExpr.toTeX();\n        }\n        this.bindings = bindings;\n        this.numInputs = missVars.length;\n        this.ruleID = testRule.idNum;\n    }\n}\n\n\n\nfunction newRule(btm, reductionList, equation, description, isValid, useOneWay, constraints) {\n    var exprFormulas = equation.split('==');\n    if (exprFormulas.length != 2) {\n        console.log(\"Invalid equation in identity list: \" + equation);\n    } else {\n        for (var refID=0; refID <= 1; refID++) {\n            if (refID == 1 && typeof useOneWay != 'undefined' && useOneWay) {\n                break;\n            }\n            var identity;\n\n            var refExpr = btm.parse(exprFormulas[refID],\"formula\");\n            var eqExpr = btm.parse(exprFormulas[1-refID],\"formula\");\n            var numVars = refExpr.dependencies().length;\n            var allRefExpr = [exprFormulas[refID]];\n            // this is a big slow down, so just make sure each rule is written in multiple ways.\n            //      var allRefExpr = refExpr.allStringEquivs();\n\n            var uniqueExpr = [];\n            for (var i in allRefExpr) {\n                var nextExpr = btm.parse(allRefExpr[i],\"formula\");\n                var isNew = true;\n                for (var j in uniqueExpr) {\n                    var bindings = uniqueExpr[j].match(nextExpr, {});\n                    if (bindings !== null) {\n                        isNew = false;\n                    }\n                }\n                if (isNew) {\n                    var ruleID = reductionList.length+1;\n                    identity = new Identity(nextExpr, eqExpr, description, isValid, ruleID);\n                    reductionList.push(identity);\n                    uniqueExpr.push(nextExpr);\n                }\n            }\n        }\n    }\n}\n\n// Disable a rule in the list.\nfunction disableRule(btm, reductionList, equation) {\n  // Match only on refExpr.\n  var exprFormulas = equation.split('==');\n  var refExpr, eqExpr;\n  if (exprFormulas.length > 2) {\n    console.log(\"Invalid equation in identity list: \" + equation);\n    return;\n  } else {\n    refExpr = btm.parse(exprFormulas[0],\"formula\");\n  }\n  for (var i in reductionList) {\n    var testRule = reductionList[i];\n    var bindings = testRule.refExpr.match(refExpr, {})\n    if (bindings !== null) {\n      reductionList[i].isActive = false;\n    }\n}\n}\n\n/* *******************\n** Given a list of reduction rules and a given expression,\n** test each reduction rule to see if it matches the structure.\n** Create an array of new objects with bindings stating what\n** substitutions are necessary to make the matches.\n******************* */\nfunction findMatchRules(reductionList, testExpr, doValidate) {\n    var matchList = [];\n    var i, testRule;\n    for (i in reductionList) {\n        testRule = reductionList[i];\n        var bindings = testRule.refExpr.match(testExpr, {})\n        if (testRule.isActive && bindings !== null) {\n            var match = new Match(testRule, bindings);\n            matchList.push(match);\n        }\n    }\n    return(matchList);\n}\n\n\nfunction defaultReductions(btm) {\n    var reduceRules = new Array();\n\n    newRule(btm, reduceRules, '0+x==x', 'Additive Identity', true, true);\n    newRule(btm, reduceRules, 'x+0==x', 'Additive Identity', true, true);\n    newRule(btm, reduceRules, '0-x==-x', 'Additive Inverse', true, true);\n    newRule(btm, reduceRules, 'x-0==x', 'Additive Identity', true, true);\n    newRule(btm, reduceRules, '0*x==0', 'Multiply by Zero', true, true);\n    newRule(btm, reduceRules, 'x*0==0', 'Multiply by Zero', true, true);\n    newRule(btm, reduceRules, '1*x==x', 'Multiplicative Identity', true, true);\n    newRule(btm, reduceRules, 'x*1==x', 'Multiplicative Identity', true, true);\n    newRule(btm, reduceRules, '0/x==0', 'Multiply by Zero', true, true);\n    newRule(btm, reduceRules, 'x/1==x', 'Divide by One', true, true);\n    newRule(btm, reduceRules, 'x^1==x', 'First Power', true, true);\n    newRule(btm, reduceRules, 'x^0==1', 'Zero Power', true, true);\n    newRule(btm, reduceRules, 'x^(-a)==1/(x^a)', 'Negative Power', true, true);\n    newRule(btm, reduceRules, '1^x==1', 'One to a Power', true, true);\n    newRule(btm, reduceRules, '-1*x==-x', 'Multiplicative Identity', true, true);\n    newRule(btm, reduceRules, 'x*-1==-x', 'Multiplicative Identity', true, true);\n    newRule(btm, reduceRules, 'x-x==0', 'Additive Inverses Cancel', true, true);\n    newRule(btm, reduceRules, 'x+-x==0', 'Additive Inverses Cancel', true, true);\n    newRule(btm, reduceRules, '-x+x==0', 'Additive Inverses Cancel', true, true);\n    newRule(btm, reduceRules, '(-x)+y==y-x', \"Swap Leading Negative\", true, true);\n    newRule(btm, reduceRules, 'x+(-y)==x-y', \"Subtraction\", true, true);\n    newRule(btm, reduceRules, '(-x)+(-y)==-(x+y)', \"Factor Negation from Addition\", true, true);\n    newRule(btm, reduceRules, '(-x)-y==-(x+y)', \"Factor Negation from Addition\", true, true);\n    newRule(btm, reduceRules, 'x-(-y)==x+y', \"Additive Inverse's Inverse\", true, true);\n    newRule(btm, reduceRules, '(-x)*y==-(x*y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(btm, reduceRules, 'x*(-y)==-(x*y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(btm, reduceRules, '(-x)/y==-(x/y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(btm, reduceRules, 'x/(-y)==-(x/y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(btm, reduceRules, '-(-x)==x', \"Additive Inverse's Inverse\", true, true);\n    newRule(btm, reduceRules, '/(/x)==x', \"Multiplicative Inverse's Inverse\", true, true);\n\n    return(reduceRules);\n}\n\nfunction defaultSumReductions(btm) {\n    var sumReductions = new Array();\n\n    newRule(btm, sumReductions, 'a+0==a', 'Simplify Addition by Zero', true, true);\n    newRule(btm, sumReductions, '0+a==a', 'Simplify Addition by Zero', true, true);\n    newRule(btm, sumReductions, 'a-a==0', 'Cancel Additive Inverses', true, true);\n    newRule(btm, sumReductions, 'a+-a==0', 'Cancel Additive Inverses', true, true);\n    newRule(btm, sumReductions, '-a+a==0', 'Cancel Additive Inverses', true, true);\n    newRule(btm, sumReductions, 'a*b+-a*b==0', 'Cancel Additive Inverses', true, true);\n    newRule(btm, sumReductions, '-a*b+a*b==0', 'Cancel Additive Inverses', true, true);\n    newRule(btm, sumReductions, 'a*(b+c)==a*b+a*c', 'Expand Products by Distributing', true, true);\n    newRule(btm, sumReductions, '(a+b)*c==a*c+b*c', 'Expand Products by Distributing', true, true);\n    newRule(btm, sumReductions, 'a*(b-c)==a*b-a*c', 'Expand Products by Distributing', true, true);\n    newRule(btm, sumReductions, '(a-b)*c==a*c-b*c', 'Expand Products by Distributing', true, true);\n\n    return(sumReductions);\n}\n\nfunction defaultProductReductions(btm) {\n    var productReductions = new Array();\n\n    newRule(btm, productReductions, '0*a==0', 'Simplify Multiplication by Zero', true, true);\n    newRule(btm, productReductions, 'a*0==0', 'Simplify Multiplication by Zero', true, true);\n    newRule(btm, productReductions, '1*a==a', 'Simplify Multiplication by One', true, true);\n    newRule(btm, productReductions, 'a*1==a', 'Simplify Multiplication by One', true, true);\n    newRule(btm, productReductions, 'a/a==1', 'Cancel Multiplicative Inverses', true, true);\n    newRule(btm, productReductions, 'a*/a==1', 'Cancel Multiplicative Inverses', true, true);\n    newRule(btm, productReductions, '/a*a==1', 'Cancel Multiplicative Inverses', true, true);\n    newRule(btm, productReductions, '(a*b)/(a*c)==b/c', 'Cancel Common Factors', true,true);\n    newRule(btm, productReductions, 'a^m/a^n==a^(m-n)', 'Cancel Common Factors', true,true);\n    newRule(btm, productReductions, '(a^m*b)/(a^n*c)==(a^(m-n)*b)/c', 'Cancel Common Factors', true,true);\n    newRule(btm, productReductions, 'a*a==a^2', 'Write Products of Common Terms as Powers', true, true);\n    newRule(btm, productReductions, 'a*a^n==a^(n+1)', 'Write Products of Common Terms as Powers', true, true);\n    newRule(btm, productReductions, 'a^n*a==a^(n+1)', 'Write Products of Common Terms as Powers', true, true);\n    newRule(btm, productReductions, 'a^m*a^n==a^(m+n)', 'Write Products of Common Terms as Powers', true, true);\n    newRule(btm, productReductions, '(a^-m*b)/c==b/(a^m*c)', 'Rewrite Using Positive Powers', true,true);\n    newRule(btm, productReductions, '(b*a^-m)/c==b/(a^m*c)', 'Rewrite Using Positive Powers', true,true);\n    newRule(btm, productReductions, 'b/(a^-m*c)==(a^m*b)/c', 'Rewrite Using Positive Powers', true,true);\n    newRule(btm, productReductions, 'b/(c*a^-m)==(a^m*b)/c', 'Rewrite Using Positive Powers', true,true);\n\n    return (productReductions);\n  }\n\n//# sourceURL=webpack://btm-expressions/./src/reductions.js?");

/***/ }),

/***/ "./src/scalar_expr.js":
/*!****************************!*\
  !*** ./src/scalar_expr.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scalar_expr\": () => (/* binding */ scalar_expr)\n/* harmony export */ });\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/* harmony import */ var _real_number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./real_number.js */ \"./src/real_number.js\");\n/* harmony import */ var _rational_number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rational_number.js */ \"./src/rational_number.js\");\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Scalar Expression -- a numerical value\n* *************************************************** */\n\n\n\n\n\n\nclass scalar_expr extends _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression {\n    constructor(btm, number) {\n        super(btm);\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.number;\n        if (typeof number == \"object\" &&\n            (number.constructor.name === \"rational_number\"\n              ||\n             number.constructor.name === \"real_number\")\n            )\n        {\n            this.number = number;\n        } else if (Math.floor(number)==number) {\n            this.number = new _rational_number_js__WEBPACK_IMPORTED_MODULE_2__.rational_number(number, 1);\n        } else {\n            this.number = new _real_number_js__WEBPACK_IMPORTED_MODULE_1__.real_number(number);\n        }\n        this.context = \"number\";\n    }\n\n    // Parsed representation.\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        return(this.number.toString());\n    }\n    \n    // Display representation.\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        var word = this.number.toTeX();\n        if (showSelect && this.select) {\n            word = \"{\\\\color{red}\" + word + \"}\";\n        }\n        return(word);\n    }\n    \n    // MathML representation.\n    toMathML() {\n        return(\"<cn>\" + this.toString() + \"</cn>\");\n    }\n    \n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([this.toString()]);\n    }\n    \n    // Test if represents constant value.\n    isConstant() {\n        /*\n        This could just use expression.prototype.constant, but use this\n        because it ALWAYS is true for scalar_expr and does not need a check\n        */\n        return(true);\n    }\n    \n    // Combine constants where possible\n    simplifyConstants() {\n        var retValue;\n        if (!this.btm.options.negativeNumbers && this.number.p < 0) {\n            var theNumber = this.number.multiply(-1);\n            retValue = new unop_expr(this.btm, '-', new scalar_expr(this.btm, theNumber));\n        } else {\n            retValue = this;\n        }\n        return(retValue);\n    }\n    \n    value() {\n        return(this.number.value());\n    }\n\n    evaluate(bindings) {\n        return(this.value());\n    }\n    \n    copy() {\n        return(new scalar_expr(this.btm, this.number));\n    }\n    \n    compose(bindings) {\n        return(new scalar_expr(this.btm, this.number));\n    }\n    \n    derivative(ivar, varList) {\n        return(new scalar_expr(this.btm, 0));\n    }\n    \n    /*\n        See expressions.prototype.match for explanation.\n    \n        A scalar might match a constant formula.\n    */\n    match(expr, bindings) {\n        var retValue = null,\n            testExpr = expr;\n    \n        // Special named constants can not match expressions.\n        if (expr.isConstant() && expr.type != _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.number) {\n            var testExpr = this.btm.parse(expr.toString(), expr.context).simplifyConstants();\n            if (this.toString() === testExpr.toString()) {\n              retValue = bindings;\n            }\n        }\n        else if (testExpr.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.number\n                && this.number.equal(testExpr.number)) {\n            retValue = bindings;\n        }\n    \n        return(retValue);\n    }    \n}\n\n\n\n//# sourceURL=webpack://btm-expressions/./src/scalar_expr.js?");

/***/ }),

/***/ "./src/unop_expr.js":
/*!**************************!*\
  !*** ./src/unop_expr.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unop_expr\": () => (/* binding */ unop_expr)\n/* harmony export */ });\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/* harmony import */ var _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar_expr.js */ \"./src/scalar_expr.js\");\n/* harmony import */ var _binop_expr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binop_expr.js */ \"./src/binop_expr.js\");\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Unary Expression -- defined by an operator and an input.\n* *************************************************** */\n\n\n\n\n\n\nclass unop_expr extends _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression {\n    constructor(btm, op, input) {\n        super(btm);\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.unop;\n        this.op = op;\n        if (typeof input == 'undefined')\n            input = new _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression();\n        this.inputs = [input];\n            input.parent = this;\n        switch (op) {\n            case '+':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.opPrec.multdiv;\n                break;\n            case '-':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.opPrec.multdiv;\n                break;\n            case '/':\n                this.prec = _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.opPrec.power;\n                break;\n            default:\n                alert(\"Unknown unary operator: '\"+op+\"'.\");\n                break;\n        }\n    }\n\n    toString() {\n        var theStr;\n        var opStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opStr = '?';\n        } else {\n            opStr = this.inputs[0].toString();\n        }\n        if ((this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.unop\n                && this.inputs[0].prec < this.prec)\n            || (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.number\n                && opStr.indexOf('/') >= 0\n                && _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.opPrec.multdiv <= this.prec)\n            ) \n        {\n            theStr = this.op + '(' + opStr + ')';\n        } else {\n            theStr = this.op + opStr;\n        }\n\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputs = this.inputs[0].allStringEquivs();\n        var retValue = [];\n\n        for (var i in allInputs) {\n            if (this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.unop && this.inputs[0].prec <= this.prec) {\n                retValue[i] = this.op + '(' + allInputs[i] + ')';\n            } else {\n                retValue[i] = this.op + allInputs[i];\n            }\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var opStr, theOp;\n\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opStr = '?';\n        } else {\n            opStr = this.inputs[0].toTeX(showSelect);\n        }\n\n        theOp = this.op;\n        if (theOp == '/') {\n            theOp = '\\\\div ';\n            if (showSelect && this.select) {\n                theStr = \"{\\\\color{red}\" + this.op + \"}\"\n                                + '\\\\left({\\\\color{blue}' + opStr + '}\\\\right)';\n            } else {\n                theStr = '\\\\frac{1}{' + opStr + '}';\n            }\n        } else {\n            if (showSelect && this.select) {\n                theStr = \"{\\\\color{red}\" + this.op + \"}\"\n                                + '\\\\left({\\\\color{blue}' + opStr + '}\\\\right)';\n            } else if (this.inputs[0].type >= _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.unop && this.inputs[0].prec <= this.prec\n                && (this.inputs[0].type != _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.unop || this.op != '-' || this.inputs[0].op != '/')) {\n                theStr = theOp + '\\\\left(' + opStr + '\\\\right)';\n            } else {\n                theStr = theOp + opStr;\n            }\n        }\n        return(theStr);\n    }\n\n    toMathML() {\n        var theStr;\n        var opStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opStr = '?';\n        } else {\n            opStr = this.inputs[0].toMathML();\n        }\n        switch (this.op) {\n            case '+':\n                theStr = opStr;\n                break;\n            case '-':\n                theStr = \"<apply><minus/>\" + opStr + \"</apply>\";\n                break;\n            case '/':\n                theStr = \"<apply><divide/><cn>1</cn>\" + opStr + \"</apply>\";\n                break;\n        }\n\n        return(theStr);\n    }\n\n    operateToTeX() {\n        var opString = this.op;\n\n        if (opString === '/') {\n            opString = '\\\\div';\n        }\n\n        return(opString);\n    }\n\n    evaluate(bindings) {\n        var inputVal = this.inputs[0].evaluate(bindings);\n\n        var retVal;\n        if (inputVal == undefined) {\n            return(undefined);\n        }\n        switch (this.op) {\n            case '+':\n                retVal = inputVal;\n                break;\n            case '-':\n                retVal = -1*inputVal;\n                break;\n            case '/':\n                // Even when divide by zero, we want to use this, since in the exception\n                // we want the value to be Infinite and not undefined.\n                retVal = 1/inputVal;\n                break;\n            default:\n                alert(\"The unary operator '\" + this.op + \"' is not defined.\");\n                retVal = undefined;\n                break;\n        }\n        return(retVal);\n    }\n\n    simplifyConstants() {\n        var retVal;\n\n        this.inputs[0] = this.inputs[0].simplifyConstants();\n        this.inputs[0].parent = this;\n        if (this.inputs[0].type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.number) {\n            var theNumber = this.inputs[0].number;\n            switch (this.op) {\n                case '-':\n                    if (options.negativeNumbers) {\n                    retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, theNumber.addInverse());\n                    } else {\n                    retVal = this;\n                    }\n                    break;\n                case '/':\n                    retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, theNumber.multInverse());\n                    break;\n            }\n        } else {\n            retVal = this;\n        }\n        return(retVal);\n    }\n\n    flatten() {\n      return(new unop_expr(this.btm, this.op, this.inputs[0].flatten()));\n    }\n\n    copy() {\n      return(new unop_expr(this.btm, this.op, this.inputs[0].copy()));\n    }\n\n    compose(bindings) {\n        return(new unop_expr(this.btm, this.op, this.inputs[0].compose(bindings)));\n    }\n\n    derivative(ivar, varList) {\n        var theDeriv;\n\n        var uConst = this.inputs[0].isConstant();\n        if (uConst) {\n            theDeriv = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 0);\n        } else {\n            switch (this.op) {\n                case '+':\n                    theDeriv = this.inputs[0].derivative(ivar, varList);\n                    break;\n                case '-':\n                    theDeriv = new unop_expr(this.btm, '-', this.inputs[0].derivative(ivar, varList));\n                    break;\n                case '/':\n                    var denom = new _binop_expr_js__WEBPACK_IMPORTED_MODULE_2__.binop_expr(this.btm, '*', this.inputs[0], this.inputs[0]);\n                    theDeriv = new unop_expr(this.btm, '-', new _binop_expr_js__WEBPACK_IMPORTED_MODULE_2__.binop_expr(this.btm, '/', this.inputs[0].derivative(ivar, varList), denom));\n                    break;\n                default:\n                    console.log(\"The derivative of the unary operator '\" + this.op + \"' is not defined.\");\n                    theDeriv = undefined;\n                    break;\n            }\n        }\n        return(theDeriv);\n    }\n\n    match(expr, bindings) {\n        var retValue = null;\n\n        // Special named constants can not match expressions.\n        if (this.isConstant() && expr.isConstant()) {\n            var newExpr = expr.simplifyConstants(),\n                newThis = this.simplifyConstants();\n\n            if (newExpr.toString() === newThis.toString()\n                || newExpr.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.number && newThis.type == _BTM_root_js__WEBPACK_IMPORTED_MODULE_3__.exprType.number\n                    && newThis.number.equal(newExpr.number)) {\n                retValue = bindings;\n            }\n        } else {\n            retValue = _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression.prototype.match.call(this, expr, bindings);\n        }\n\n        return(retValue);\n    }\n}\n\n\n//# sourceURL=webpack://btm-expressions/./src/unop_expr.js?");

/***/ }),

/***/ "./src/variable_expr.js":
/*!******************************!*\
  !*** ./src/variable_expr.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"index_expr\": () => (/* binding */ index_expr),\n/* harmony export */   \"variable_expr\": () => (/* binding */ variable_expr)\n/* harmony export */ });\n/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ \"./src/expression.js\");\n/* harmony import */ var _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar_expr.js */ \"./src/scalar_expr.js\");\n/* harmony import */ var _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BTM_root.js */ \"./src/BTM_root.js\");\n/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Variable Expression -- a value defined by a name\n* *************************************************** */\n\n\n\n\nclass variable_expr extends _expression_js__WEBPACK_IMPORTED_MODULE_0__.expression {\n    constructor(btm, name) {\n        super(btm);\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.variable;\n        this.name = name;\n\n        // Count how many derivatives.\n        var primePos = name.indexOf(\"'\");\n        this.derivs = 0;\n        if (primePos > 0) {\n            this.derivs = name.slice(primePos).length;\n        }\n\n        this.isConst = false;\n        this.isSpecial = false;\n        switch(this.name) {\n            case 'e':\n            case 'pi':\n            case 'dne':\n            case 'inf':\n                this.isConst = true;\n                this.isSpecial = true;\n                break;\n        }\n    }\n\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        return(this.name);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([this.toString()]);\n    }\n\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        var str = this.toString();\n\n        switch (this.name) {\n            case 'alpha':\n            case 'beta':\n            case 'gamma':\n            case 'delta':\n            case 'epsilon':\n            case 'zeta':\n            case 'eta':\n            case 'theta':\n            case 'kappa':\n            case 'lambda':\n            case 'mu':\n            case 'nu':\n            case 'xi':\n            case 'pi':\n            case 'rho':\n            case 'sigma':\n            case 'tau':\n            case 'upsilon':\n            case 'phi':\n            case 'chi':\n            case 'psi':\n            case 'omega':\n            case 'Gamma':\n            case 'Delta':\n            case 'Theta':\n            case 'Lambda':\n            case 'Xi':\n            case 'Pi':\n            case 'Sigma':\n            case 'Upsilon':\n            case 'Phi':\n            case 'Psi':\n            case 'Omega':\n                str = '\\\\' + this.name;\n                break;\n            case 'inf':\n                str = '\\\\infty';\n                break;\n            default:\n                if (this.isSpecial) {\n                    str = '\\\\mathrm{' + this.name + '}';\n                }\n                break;\n        }\n        if (this.name.indexOf(\"input\")==0) {\n            str = \"\\\\boxed{\\\\dots?^{\" + this.name.slice(5) + \"}}\";\n        }\n\n        if (showSelect && this.select) {\n            str = \"{\\\\color{red}\" + str + \"}\";\n        }\n        return(str);\n    }\n\n    dependencies(forced) {\n        var depArray = new Array();\n        if (forced != undefined) {\n            for (var i=0; i<forced.length; i++) {\n                depArray.push(forced[i]);\n            }\n        }\n        if (!this.isConst && depArray.indexOf(this.name) < 0) {\n            depArray.push(this.name);\n        }\n        return(depArray);\n    }\n\n    /*\n        A variable is constant only if referring to mathematical constants (e, pi)\n    */\n    isConstant() {\n        return(this.isConst);\n    }\n\n    evaluate(bindings) {\n        var retVal;\n\n        if (bindings[this.name] == undefined) {\n            switch(this.name) {\n                case 'e':\n                    retVal = Math.E;\n                    break;\n                case 'pi':\n                    retVal = Math.PI;\n                    break;\n                case 'inf':\n                    retVal = Infinity;\n                    break;\n                case 'dne':\n                    retVal = Number.NaN;\n                    break;\n                default:\n                    console.log(\"Variable evaluated without binding.\")\n                    break;\n            }\n        } else {\n            retVal = bindings[this.name];\n        }\n\n        return(retVal);\n    }\n\n    copy() {\n        return(new variable_expr(this.btm, this.name));\n    }\n\n    compose(bindings) {\n        var retVal;\n\n        if (bindings[this.name] == undefined) {\n            retVal = new variable_expr(this.btm, this.name);\n        } else {\n            if (typeof bindings[this.name] == \"string\") {\n                retVal = this.btm.parse(bindings[this.name], \"formula\");\n            } else {\n                retVal = bindings[this.name];\n            }\n        }\n\n        return(retVal);\n    }\n\n    derivative(ivar, varList) {\n        var retVal;\n        var ivarName = (typeof ivar == 'string') ? ivar : ivar.name;\n\n        if (this.name === ivarName) {\n            retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 1);\n\n        // If either a constant or another independent variable, deriv=0\n        } else if (this.isConst || varList && varList[this.name] != undefined) {\n            retVal = new _scalar_expr_js__WEBPACK_IMPORTED_MODULE_1__.scalar_expr(this.btm, 0);\n\n        // Presuming other variables are dependent variables.\n        } else  {\n            retVal = new variable_expr(this.btm, this.name+\"'\");\n        }\n        return(retVal);\n    }\n\n    /*\n        See expressions.prototype.match for explanation.\n\n        A variable can match any expression. But we need to check\n        if the variable has already matched an expression. If so,\n        it must be the same again.\n    */\n    match(expr, bindings) {\n        var retValue = null;\n\n        // Special named constants can not match expressions.\n        if (this.isConst) {\n            if (expr.toString() === this.name) {\n                retValue = bindings;\n            }\n\n        // If never previously assigned, can match any expression.\n        } else if (bindings != null && bindings[this.name] == undefined && expr.valueType == _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprValue.numeric) {\n            retValue = bindings;\n            retValue[this.name] = expr.toString();\n        } else if (bindings != null && bindings[this.name] == expr.toString()) {\n            retValue = bindings;\n        }\n\n        return(retValue);\n    }\n}\n\n    /* ***************************************************\n    * Define the Index Expression -- a reference into a list\n    * *************************************************** */\n\nclass index_expr {\n    \n    constructor(btm, name, index) {\n        this.btm = btm;\n        if (!(btm instanceof BTM)) {\n            console.log(\"variable_expr constructed with invalid environment\")\n        }\n        this.type = _BTM_root_js__WEBPACK_IMPORTED_MODULE_2__.exprType.variable;\n        this.name = name;\n        this.select = false;\n        this.boundName = \"[]\"+name;\n        this.parent = null;\n        this.index = index;\n        var depArray = index.dependencies();\n        if (depArray.length > 1) {\n            alert(\"An array reference can only have one index variable.\");\n        } else {\n            this.k = depArray[0];\n        }\n    }\n\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        return(this.name + \"[\" + this.index.toString() + \"]\");\n    }\n\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        word = this.name + \"_{\" + this.index.toString() + \"}\";\n        if (showSelect && this.select) {\n            word = \"{\\\\color{red}\" + word + \"}\";\n        }\n        return(word);\n    }\n\n    toMathML() {\n        return(\"<apply><selector/><ci type=\\\"vector\\\">\" + this.name + \"</ci>\" + this.index.toString() + \"</apply>\");\n    }\n\n    dependencies(forced) {\n        var depArray = new Array();\n        if (forced != undefined) {\n            for (var i=0; i<forced.length; i++) {\n                depArray.push(forced[i]);\n            }\n        }\n        switch(this.name) {\n            default:\n                depArray.push(\"row\");\n                depArray.push(this.boundName);\n                break;\n        }\n        return(depArray);\n    }\n\n    evaluate(bindings) {\n        var retVal;\n\n        if (bindings[this.boundName] == undefined) {\n            switch(this.name) {\n                default:\n                    retVal = undefined;\n                    break;\n            }\n        } else {\n            var tmpBind = {};\n            if (this.k != undefined) {\n                tmpBind[this.k] = bindings[\"row\"];\n            }\n            var i = this.index.evaluate(tmpBind)-1;\n            if (i >= 0 && i<bindings[this.boundName].length) {\n                retVal = bindings[this.boundName][i];\n            }\n        }\n\n        return(retVal);\n    }\n}\n\n//# sourceURL=webpack://btm-expressions/./src/variable_expr.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/BTM_root.js");
/******/ 	
/******/ })()
;