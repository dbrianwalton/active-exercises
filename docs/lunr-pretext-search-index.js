var ptx_lunr_search_style = "textbook";
var ptx_lunr_docs = [
{
  "id": "colophon-1",
  "level": "1",
  "url": "colophon-1.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": "  Brian Walton's homepage  http:\/\/educ.jmu.edu\/~waltondb   copyright  "
},
{
  "id": "meta_frontmatter-preface",
  "level": "1",
  "url": "meta_frontmatter-preface.html",
  "type": "Preface",
  "number": "",
  "title": "Preface",
  "body": "   This book describes how to mark-up and include dynamic exercises within a PreTeXt document, that are enabled by Runestone Components in the HTML output.  "
},
{
  "id": "ch_motivation",
  "level": "1",
  "url": "ch_motivation.html",
  "type": "Chapter",
  "number": "1",
  "title": "Motivation",
  "body": " Motivation  I have long been interested in interactive exercises for students learning mathematics. The promise is that students can try exercises that focus on particular skills or concepts and a computer will provide immediate feedback on whether they found an appropriate solution. When these problems are designed to allow for random variations with answer checkers that adapt to these variations, we have dynamic exercises.  Dynamic exercises have a number of benefits. A single dynamic exercise creates a template for a large number of related problems. In a homework system, this allows a class of students to be assigned related problems that follow a common strategy while ensuring that students are individually solving problems with different details than (most of) those around them. For a single student, dynamic exercises allow a student to try new problems to reinforce earlier practice. The computer might be able to recognize submitted answers that result from common mistakes or misconceptions and provide feedback that can guide the student to correct their error.  Dynamic exercises also have some challenges. For an author, there is the complication of writing a generalization of an exercise. Key aspects of the problem that allow mutation introduce parameters for randomization. The author then needs to ensure that different random versions of the problem have comparable complexity and methods of solution. An answer and solution that incorporates the variability is also necessary.  Online homework systems are one way that the idea of dynamic exercises is realized. WeBWorK is one example of a system that allows authors to create custom problems as well as to provide logic to evaluate student responses. Other learning systems implement similar models. These different systems have their own approaches for how an author defines and writes their exercises.  PreTeXt-authored books now allow WeBWorK exercises to be embedded within the text. Once such a problem is activated, a student can anonymously submit a response to a question and a remote server can evaluate their submission and provide appropriate feedback. I am exploring the possibility and practicality of generalizing the inclusion of dynamic exercises where an author can define the logic and structure of the exercise rather than provide code specific to a particular system like WeBWorK.   Anticipated Objectives    An XML-based definition of an exercise can allow for transcoding to different systems, e.g. WeBWorK, WebAssign, or other systems.  An author can focus on the structure and logic of a dynamic exercise rather than the syntax and language-specific implementations.  A Javascript evaluation engine could create a server-free implementation of problems reducing the reliance of a text on 3rd party servers.     WeBWorK allows incredible flexibility in authoring questions. This XML-based approach to defining problems is not intended to support that full flexibility. Part of the development challenge will be to identify a core set of features that make sense.  "
},
{
  "id": "section-markup-exercise",
  "level": "1",
  "url": "section-markup-exercise.html",
  "type": "Section",
  "number": "2.1",
  "title": "Overview of Exercise Markup",
  "body": " Overview of Exercise Markup  As much as possible, the markup should follow PreTeXt standards. One goal is that any user-facing content on a web-page should match the style of other elements generated by PreTeXt. Problems transcoded to WeBWorK should match how similar problems defined in PreTeXt using <pg> elements are created. Consequently, tags supported for standard exercises should be supported natively as much as possible in dynamic exercises.   This is very much a draft proposal for markup. Ideas for improvement and implementation warnings are welcome.   We will use an <exercise> element with an attribute @exercise-interactive='fillin-dynamic' to indicate that the exercise involves a Runestone fillin exercise using dynamic processing.  The overall structure of an exercise is proposed to have the following structure. There are two XML blocks that are specific to a dynamic exercise, setup and evaluation . The other blocks are intended to match PreTeXt standard usage. An answer block perhaps does not make sense. The other standard elements will be formatted as usual, with some additional tags to specify where items such as values and expressions are inserted.   <exercise xml:id='my-id' exercise-interactive='fillin-dynamic'> <title\/> <setup> <de-environment> <!-- Specify the dynamic problem randomization elements --> ... <!-- and other environment settings like error tolerance --> <\/de-environment> <!-- This piece is not yet specified. --> <de-object\/> <!-- One or more dynamically created objects --> <de-object\/> <!-- These are translated into script commands --> ... <\/setup> <statement> <!-- Usual PreTeXt with elements to include dynamic expressions --> ... <\/statement> <solution> <!-- Usual PreTeXt with elements to include dynamic expressions --> ... <!-- As far as I can tell this is not supported by Runestone yet --> <\/solution> <evaluation> <!-- Specify the dynamic problem evaluation and feedback --> ... <\/evaluation> <\/exercise>  Overall XML structure of a dynamic exercise.   "
},
{
  "id": "remark-1",
  "level": "2",
  "url": "section-markup-exercise.html#remark-1",
  "type": "Remark",
  "number": "2.1.1",
  "title": "",
  "body": " This is very much a draft proposal for markup. Ideas for improvement and implementation warnings are welcome.  "
},
{
  "id": "listing-1",
  "level": "2",
  "url": "section-markup-exercise.html#listing-1",
  "type": "Listing",
  "number": "2.1.2",
  "title": "",
  "body": " <exercise xml:id='my-id' exercise-interactive='fillin-dynamic'> <title\/> <setup> <de-environment> <!-- Specify the dynamic problem randomization elements --> ... <!-- and other environment settings like error tolerance --> <\/de-environment> <!-- This piece is not yet specified. --> <de-object\/> <!-- One or more dynamically created objects --> <de-object\/> <!-- These are translated into script commands --> ... <\/setup> <statement> <!-- Usual PreTeXt with elements to include dynamic expressions --> ... <\/statement> <solution> <!-- Usual PreTeXt with elements to include dynamic expressions --> ... <!-- As far as I can tell this is not supported by Runestone yet --> <\/solution> <evaluation> <!-- Specify the dynamic problem evaluation and feedback --> ... <\/evaluation> <\/exercise>  Overall XML structure of a dynamic exercise.  "
},
{
  "id": "section-markup-setup",
  "level": "1",
  "url": "section-markup-setup.html",
  "type": "Section",
  "number": "2.2",
  "title": "Setup and Randomization",
  "body": " Setup and Randomization  The setup block defines all of the dynamically generated mathematical objects. It also specifies particular constraints on any variables in the system as well as other environmental settings, such as required tolerance for values to match. The tag has an attribute seed which is used to provide a default seed for the initial state of the problem that will be used to create the static version. (Question: Should we use the same style seed that would be used for WeBWorK since this can create WeBWorK questions as well?)  The block consists of a single <de-environment> element (not yet specified). This will include a specification of variables that will be used in the problem, the standard domain of evaluation for those variables (where formulas are evaluated), and how values will be compared for approximate equality (relative vs absolute error and tolerance values).  The environment will be followed by a sequence of <de-object> elements that create dynamic content objects that will be used to describe the problem fully, including when answers are evaluated. Instruction elements can define expressions represent numbers or formulas by including @context attributes of @context='number' and @context='formula' , respectively. This should allow flexibility for additional contexts to be implemented in the future, such as text, lists, sets, points, vectors, or matrices. Additional attributes will be specific to the @context .  Each object must have a @name attribute which will be used as a variable name in the corresponding scripts used in implementation. Object names should must with a letter and can contain letters A-Za-z, digits 0-9, and the underscore. Additionally, objects can be defined in terms of previously defined objects, referencing them by name, and the order in which the elements are included is critical. An object can not be referenced prior to its creation.  Numerical quantities (constants) are objects with @context=\"number\" . The @mode attribute specifies how the number is defined. They can be defined as a specific value ( @mode=\"value\" ), as a random value ( @mode=\"random\" ), calculated in terms of previously defined numbers ( @mode=\"formula\" ) using mustache substitution, or evaluating a formula object at specific variable instances ( @mode=\"evaluate\" ). Expression terms can be computed in terms of previously defined parameters or expressions using the defined variables.  Algebraic expressions involving variables are objects with @context=\"formula\" . The @mode attribute specifies how the formula is defined. The most common approach is by providing a formula in terms of previous objects ( @mode=\"formula\" ) using mustache substitution. Additionally, a formula can be defined by substitution of a variable with another expression ( @mode=\"substitution\" ), by differentiating with respect to a variable ( @mode=\"derivative\" ), or by evaluating variables at specific values ( @mode=\"evaluate\" ).   Mustache Substitution vs VAR elements  Implementations of dynamic exercises will reference the object names in different ways. For example, WeBWorK and WebAssign both use Perl syntax and so the names will be transcoded with a dollar sign $ before the name. Other implementations will just use the names directly. To retain a simple substitution schema when defining a value or an expression, we adopt mustache substitution . This means that the name of the parameter or expression needs to be surrounded by double curly braces. Variables themselves are not enclosed by braces. For example, if we had previously defined a parameter c and wanted to introduce an expression , the mustache-substitution expression would be written {{c}}*x+3 .  In all contexts other than providing a formula that will be parsed, we will refer to objects either for display in PreTeXt content or to refer to expressions as objects for evaluation (as in when checking answers), using an XML #var element with @name=\"expression-name\" to match.   Examples of typical statements are included below with an explanation of the options.     <de-object name=\"a\" context=\"number\" mode=\"value\">12<\/de-object>  This would create a mathematical object representing the number 12 assigned to the name a .    <de-object name=\"cSq\" context=\"number\" mode=\"formula\">{{a}}^2+{{b}}^2<\/de-object>  This would create a mathematical object calculated in terms of previously created numbers a and b according to the formula and saved with the name of cSq .    <de-object name=\"fVal\" context=\"number\" mode=\"evaluate\"> <formula><var name=\"fFunc\"><\/formula> <variable name=\"x\"><var name=\"x0\"><\/variable> <\/de-object>  This would create a numerical mathematical object fVal by evaluating a formula previously created and named fFunc using a value for the variable using the value previously stored in another numerical object x0 .    <de-object name=\"fVal\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-5\" max=\"5\" by=\"1\" nonzero=\"yes\" \/> <\/de-object>  At present, only one random distribution is implemented. The options for the random distribution will all be given in the <options> as attributes. For the distribution=\"discrete\" distribution, there are default values of @by=\"1\" and @nonzero=\"no\" . The distribution considers the values starting at @min , counting by @by , until we reach @max . Each value has the same probability.  Using attributes instead of XML is simpler to type. However, if we want to implement distributions where the properties themselves are dynamically determined (for example, change the min\/max values or the by value), then this probably should be done use tags. Can we allow both? I wonder if the following would be reasonable and possible:  <de-object name=\"fVal\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" by=\"1\" nonzero=\"yes\"> <min><var name=\"myMin\"\/><\/min> <max><var name=\"myMin\"\/><\/max> <\/options> <\/de-object>    <de-object name=\"quadratic\" context=\"formula\" mode=\"formula\">{{a}}x^2+{{b}}x+{{{c}}<\/de-object>  Define the formula , replacing the values of with the values previously assigned as their own objects.    <de-object name=\"quadComp\" context=\"formula\" mode=\"substitution\"> <formula><var name=\"quadratic\" \/><\/formula> <variable name=\"x\"> <de-object context=\"formula\" mode=\"formula\">{{m}}x+{{b2}}<\/de-object> <\/variable> <\/de-object>  It is technically possible to define a new object anywhere that we would otherwise use the <var> tag to refer to a previously-defined value. This is not recommended because the value of the intermediate result is never saved. However, in this example, we would start with the quadratic formula defined in the previous example and create a new expression replacing with the formula . In other words, this is how we implement composition of functions.  Alternatively, we could accomplish the same thing (recommended) by defining the intermediate object:  <de-object name=\"myLine\" context=\"formula\" mode=\"formula\">{{m}}x+{{b2}}<\/de-object> <de-object name=\"quadComp\" context=\"formula\" mode=\"substitution\"> <formula><var name=\"quadratic\" \/><\/formula> <variable name=\"x\"><var name=\"myLine\"\/><\/variable> <\/de-object>    <de-object name=\"quadDeriv\" context=\"formula\" mode=\"derivative\"> <formula><var name=\"quadratic\" \/><\/formula> <variable name=\"x\" \/> <\/de-object>  Calculate the derivative of quadratic with respect to . This relies on the implementation environments being able to do differentiation. Both WeBWorK and BTMExpressions.js support this intrinsically.    <de-object name=\"quadDeriv\" context=\"formula\" mode=\"evaluate\"> <formula><var name=\"myFormula\" \/><\/formula> <variable name=\"x\"><var name=\"myValue\" \/><\/variable> <\/de-object>  This is similar to substitution, except that the variable in the expression defined as myFormula is evaluated at a numerical value defined by myValue .     "
},
{
  "id": "p-19",
  "level": "2",
  "url": "section-markup-setup.html#p-19",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "mustache substitution "
},
{
  "id": "section-markup-evaluation",
  "level": "1",
  "url": "section-markup-evaluation.html",
  "type": "Section",
  "number": "2.3",
  "title": "Evaluation and Feedback",
  "body": " Evaluation and Feedback  In the content of the exercise, specifically in the statement element and its content, the author should insert fillin elements for where answers will be entered for evaluation. Each #fillin should have a @submit attribute that will give a name used for matching evaluation rules to the specific student response. That is, a mathematical object with a name based on @submit will be parsed from the student response and be available at the time the answer checker evaluates the work. It should also have a @correct attribute that gives the name of a #de-object element that represents a possible correct answer. WeBWorK uses this value when showing correct answers. (I don't know if Runestone provides a way to show correct answers.) Other attributes that are used for defining WeBWorK problems in PreTeXt are also intended to be available. This includes an optional attribute @width that specifies how large the answer blank should be.  The evaluation block of XML provides the necessary information for how to determine whether student answers are correct. It also is responsible for describing any special feedback that is provided to the student, such as answer hints specific to the submitted student response.  The evaluation block contains evaluate elements that includes a @submit attribute that must match the @submit attribute of a #fillin inside the statement. Each #evaluate will include #test elements that perform tests and provide feedback when the test evaluates to true . Each test will contain one or more boolean operator elements and a feedback response. When more than one operator appears, ALL of the operators must return true (performing an implicit AND operation). An attribute on an #evaluate of @correct=\"yes\" is used to specify how to check for correctness. If no evaluation has this set, then the @correct variable defined with the fillin will be used to test for correctness. I am working on having the ability to use a single test to determine correctness of all blanks. Some systems (WeBWorK) use different techniques depending on whether student answers for other blanks are used in evaluation of correctness. Consequently, if answer evaluators involve student answers other than the answer being tested, the #evalation should have @answers-coupled=\"yes\" . (Maybe it is possible to check for this automatically.)  The overall evaluation block should have the following structure:   <evaluation> <evaluate submit=\"answerBlank1\"> <!-- Block to provide feedback for matching fillin --> ... <\/evaluate> <evaluate submit=\"answerBlank2\"> <!-- Block to provide feedback for matching fillin --> ... <\/evaluate> <\/evaluation>  XML structure of the evaluation block for independent answer blanks.   I am thinking about the following structure for a single checker for all fillins. The model I am exploring is to have an additional #evaluate with @all=\"yes\" instead of @submit to define a test that will be used for all of the answers, illustrated in the following example. There should not be any @correct attributes on the tests for the individual blanks.   <evaluation answers-coupled=\"yes\"> <evaluate all=\"yes\"> <!-- Block to evaluate entire exercise at once --> ... <evaluate> <evaluate submit=\"answerBlank1\"> <!-- Block to provide limited feedback for matching fillin --> ... <\/evaluate> <evaluate submit=\"answerBlank2\"> <!-- Block to provide limited feedback for matching fillin --> ... <\/evaluate> <\/evaluation>  XML structure of the evaluation block for fully-coordinated answer blanks.   Each test element consists of the logical test and a feedback element giving the text response when the logical test results in a true value. The logical test can consist of a formula object specified by either var or de-term elements, in which case truth is determined by testing if the student answer defined by @submit matches the given formula object. The logical test can also compare any two formula elements using an #equal logical test element, where one or both of the formula elements were constructed using the student responses. Or the logical test can be a composite logical tests using Boolean operators #and , #or , or #not , with child elements containing additional logical tests. As mentioned previously, the root test is presumed to be like #and when there are multiple logical tests as children of the test element. Default feedback statements for correct and incorrect answers will be part of the configurable settings.  A simple example of an #evaluate block is presented:   <evaluate submit=\"answerBlank1\"> <test correct=\"yes\"> <var name=\"expression1\"\/> <\/test> <test> <var name=\"expression2\"\/> <feedback>custom response<\/feedback> <\/test> <feedback>default incorrect feedback<\/feedback> <\/evaluate>  XML structure of the evaluate block marking correct if answerBlank1 and expression1 match and giving custom response as feedback if it matches expression2 .   A more complex example of an #evaluate block is presented, illustrating one way to test two answer blanks where the order of values entered does not matter. One of two and statements must be true to be correct, so there is an #or test at the base level with two #and tests inside each of the options:   <evaluate> <test correct=\"yes\"> <or> <and> <equal> <var name=\"expression1\" \/> <var name=\"answerBlank1\" \/> <\/equal> <equal> <var name=\"expression2\" \/> <var name=\"answerBlank2\" \/> <\/equal> <\/and> <and> <equal> <var name=\"expression1\" \/> <var name=\"answerBlank2\" \/> <\/equal> <equal> <var name=\"expression2\" \/> <var name=\"answerBlank1\" \/> <\/equal> <\/and> <\/or> <feedback>Outstanding!<\/feedback> <\/test> <\/evaluate>  XML structure of an evaluate block based on comparing two blanks with two answers.   "
},
{
  "id": "listing-evaluation-block-single",
  "level": "2",
  "url": "section-markup-evaluation.html#listing-evaluation-block-single",
  "type": "Listing",
  "number": "2.3.1",
  "title": "",
  "body": " <evaluation> <evaluate submit=\"answerBlank1\"> <!-- Block to provide feedback for matching fillin --> ... <\/evaluate> <evaluate submit=\"answerBlank2\"> <!-- Block to provide feedback for matching fillin --> ... <\/evaluate> <\/evaluation>  XML structure of the evaluation block for independent answer blanks.  "
},
{
  "id": "listing-evaluation-block-mixed",
  "level": "2",
  "url": "section-markup-evaluation.html#listing-evaluation-block-mixed",
  "type": "Listing",
  "number": "2.3.2",
  "title": "",
  "body": " <evaluation answers-coupled=\"yes\"> <evaluate all=\"yes\"> <!-- Block to evaluate entire exercise at once --> ... <evaluate> <evaluate submit=\"answerBlank1\"> <!-- Block to provide limited feedback for matching fillin --> ... <\/evaluate> <evaluate submit=\"answerBlank2\"> <!-- Block to provide limited feedback for matching fillin --> ... <\/evaluate> <\/evaluation>  XML structure of the evaluation block for fully-coordinated answer blanks.  "
},
{
  "id": "listing-evaluate-block-simple-test",
  "level": "2",
  "url": "section-markup-evaluation.html#listing-evaluate-block-simple-test",
  "type": "Listing",
  "number": "2.3.3",
  "title": "",
  "body": " <evaluate submit=\"answerBlank1\"> <test correct=\"yes\"> <var name=\"expression1\"\/> <\/test> <test> <var name=\"expression2\"\/> <feedback>custom response<\/feedback> <\/test> <feedback>default incorrect feedback<\/feedback> <\/evaluate>  XML structure of the evaluate block marking correct if answerBlank1 and expression1 match and giving custom response as feedback if it matches expression2 .  "
},
{
  "id": "listing-evaluate-block-coupled-test",
  "level": "2",
  "url": "section-markup-evaluation.html#listing-evaluate-block-coupled-test",
  "type": "Listing",
  "number": "2.3.4",
  "title": "",
  "body": " <evaluate> <test correct=\"yes\"> <or> <and> <equal> <var name=\"expression1\" \/> <var name=\"answerBlank1\" \/> <\/equal> <equal> <var name=\"expression2\" \/> <var name=\"answerBlank2\" \/> <\/equal> <\/and> <and> <equal> <var name=\"expression1\" \/> <var name=\"answerBlank2\" \/> <\/equal> <equal> <var name=\"expression2\" \/> <var name=\"answerBlank1\" \/> <\/equal> <\/and> <\/or> <feedback>Outstanding!<\/feedback> <\/test> <\/evaluate>  XML structure of an evaluate block based on comparing two blanks with two answers.  "
},
{
  "id": "section-demonstration-usage",
  "level": "1",
  "url": "section-demonstration-usage.html",
  "type": "Section",
  "number": "3.1",
  "title": "Usage",
  "body": " Usage  I have worked up a prototype parser of XML markup to PGML WeBWorK problems. In my dynamic-examples branch of the PreTeXt mathbook project, I have added a file dynamic-runestone-fitb.xsl to facilitate Runestone javascript implementation and dynamic-webwork-fitb.xsl to facilitate WeBWorK .pg file generation.  To generate WeBWorK .pg files, we would use the following syntax to call the routine.  > cd ::project-directory:: > mkdir pg; cd pg > xsltproc --xinclude ::pretext-path::\/xsl\/dynamicexercise.xsl ::project-root-xml::  To generate HTML that implements the Runestone javascript versions, we would use the following syntax to call the routine. In addition, there needs to be a modification of the .js and .css Runestone files included in the header. Instead of using the standard files, we need to include the custom versions of the prototype version created by Bryan Jones. I still need to standardize how these files are included.  > cd ::project-directory:: > mkdir html; cd html > xsltproc --xinclude ::pretext-path::\/xsl\/dynamicexercise.xsl ::project-root-xml::  "
},
{
  "id": "section-markup-examples",
  "level": "1",
  "url": "section-markup-examples.html",
  "type": "Section",
  "number": "3.2",
  "title": "Examples of Markup",
  "body": " Examples of Markup  The first example is for solving a linear equation of the form . The parameters and are created randomly.   <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"solve-equation\"> <title>Solve an Equation<\/title> <setup seed=\"12345\"> <de-object name=\"m\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" nonzero=\"yes\" min=\"-4\" max=\"5\" by=\"1\" \/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" \/> <\/de-object> <de-object name=\"negB\" context=\"number\" mode=\"formula\">-{{b}}<\/de-object> <de-object name=\"theFunction\" context=\"formula\" mode=\"formula\">{{m}}*x+{{b}}<\/de-object> <de-object name=\"theAnswer\" context=\"formula\" mode=\"formula\">-{{b}}\/{{m}}<\/de-object> <\/setup> <statement> <p> Solve the equation <me><eval expr=\"theFunction\"\/>=0<\/me> to get the value of <m>x<\/m>. <\/p> <p><m>x = <\/m> <fillin width=\"5\" correct=\"theAnswer\" name=\"solution\"\/><\/p> <\/statement> <solution> <p> We want to isolate the <m>x<\/m> in the equation <m><eval expr=\"theFunction\"\/>=0<\/m>. Because addition of <m><eval expr=\"b\"\/><\/m> is the last operation, we apply the inverse by adding <m><eval expr=\"negB\"\/><\/m> to both sides. The new, but equivalent equation is now <m><eval expr=\"m\"\/>x = <eval expr=\"negB\"\/><\/m>. Dividing both sides of the equation by <m><eval expr=\"m\"\/><\/m>, we obtain the solution <m>x=<eval expr=\"theAnswer\"\/><\/m>. <\/p> <\/solution> <evaluation> <evaluate submit=\"solution\"> <test correct=\"yes\"> <eval expr=\"theAnswer\" \/> <feedback>Correct!<\/feedback> <\/test> <test> <de-object context=\"formula\" mode=\"formula\">{{b}}\/{{m}}<\/de-object> <feedback>Error with signs while isolating <m>x<\/m><\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <\/exercise>  ex-solve-equation.ptx     Solve an Equation   Solve the equation to get the value of .      We want to isolate the in the equation . Because addition of is the last operation, we apply the inverse by adding to both sides. The new, but equivalent equation is now . Dividing both sides of the equation by , we obtain the solution .    A second example is calculating derivatives of a simple polynomial of the form . The parameters , , and are created randomly.   <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"find-derivatives\"> <title>Find the Derivatives<\/title> <setup seed=\"1234\"> <de-object name=\"a\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"n\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"2\" max=\"5\"\/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"formula\" context=\"formula\" mode=\"formula\">{{a}}*x^{{n}}+{{b}}<\/de-object> <de-object name=\"correctD1\" context=\"formula\" mode=\"formula\">({{a}}*{{n}})*x^({{n}}-1)<\/de-object> <de-object name=\"correctD2\" context=\"formula\" mode=\"formula\">({{a}}*{{n}}*({{n}}-1))*x^({{n}}-2)<\/de-object> <\/setup> <statement> <p> Consider the function <m>f(x)=<eval expr=\"formula\"\/><\/m>. Find <m>f'(x)<\/m> and <m>f''(x)<\/m>. <\/p> <p> <m>f'(x) = <\/m> <fillin width=\"15\" correct=\"correctD1\" name=\"firstD\"\/> and <m>f''(x)=<\/m> <fillin width=\"15\" correct=\"correctD2\" name=\"secondD\"\/> <\/p> <\/statement> <evaluation> <evaluate submit=\"firstD\"> <test> <eval expr=\"correctD2\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <evaluate submit=\"secondD\"> <test> <eval expr=\"correctD1\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <solution> <p>Placeholder for a solution!<\/p> <\/solution> <\/exercise>  ex-solve-equation.ptx    A third example illustrates coupled answers and asks to find two functions and so that equals a given function.   <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"find-derivatives\"> <title>Find the Derivatives<\/title> <setup seed=\"1234\"> <de-object name=\"a\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"n\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"2\" max=\"5\"\/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"formula\" context=\"formula\" mode=\"formula\">{{a}}*x^{{n}}+{{b}}<\/de-object> <de-object name=\"correctD1\" context=\"formula\" mode=\"formula\">({{a}}*{{n}})*x^({{n}}-1)<\/de-object> <de-object name=\"correctD2\" context=\"formula\" mode=\"formula\">({{a}}*{{n}}*({{n}}-1))*x^({{n}}-2)<\/de-object> <\/setup> <statement> <p> Consider the function <m>f(x)=<eval expr=\"formula\"\/><\/m>. Find <m>f'(x)<\/m> and <m>f''(x)<\/m>. <\/p> <p> <m>f'(x) = <\/m> <fillin width=\"15\" correct=\"correctD1\" name=\"firstD\"\/> and <m>f''(x)=<\/m> <fillin width=\"15\" correct=\"correctD2\" name=\"secondD\"\/> <\/p> <\/statement> <evaluation> <evaluate submit=\"firstD\"> <test> <eval expr=\"correctD2\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <evaluate submit=\"secondD\"> <test> <eval expr=\"correctD1\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <solution> <p>Placeholder for a solution!<\/p> <\/solution> <\/exercise>  ex-solve-equation.ptx    I also am playing with including graphics that are dynamically generated. Here is an example of a problem that graphs a function and asks for the equation of the tangent line.   <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"function-tangent-line\"> <title>Find the Tangent Line<\/title> <setup seed=\"1234\"> <environment> <random-seed>1234<\/random-seed> <\/environment> <!-- Create parabola coefficients --> <de-object name=\"a\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" \/> <\/de-object> <de-object name=\"c\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\" \/> <\/de-object> <!-- Choose a point --> <de-object name=\"x0\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-3\" max=\"3\" \/> <\/de-object> <!-- Create the quadratic function --> <de-object name=\"fFunc\" context=\"formula\" mode=\"formula\">{{a}}*x^2+{{b}}*x+{{c}}<\/de-object> <de-object name=\"fPrime\" context=\"formula\" mode=\"derivative\"> <formula><eval expr=\"fFunc\"\/><\/formula> <variable name=\"x\"\/> <\/de-object> <!-- Calculate values needed --> <de-object name=\"y0\" context=\"number\" mode=\"evaluate\"> <formula><eval expr=\"fFunc\"\/><\/formula> <variable name=\"x\"><eval expr=\"x0\"\/><\/variable> <\/de-object> <de-object name=\"m\" context=\"number\" mode=\"evaluate\"> <formula><eval expr=\"fPrime\"\/><\/formula> <variable name=\"x\"><eval expr=\"x0\"\/><\/variable> <\/de-object> <!-- Tangent Formula --> <de-object name=\"tangentFunc\" context=\"formula\" mode=\"formula\">{{m}}*(x-{{x0}})+{{y0}}<\/de-object> <de-object name=\"errorTangent1\" context=\"formula\" mode=\"formula\">{{fPrime}}*(x-{{x0}})+{{y0}}<\/de-object> <postRenderScript> v.B = v.jsx_graph.create(\"point\", [v.x0.value()+1, 0], { fixed:false }); v.angleTol = 5; \/\/ Tolerance for angle v.aspect = 10; v.yTol = 0.1; \/\/ Tolerance for y-value of point v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)-v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)+v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A,v.B]); v.B2 = v.jsx_graph2.create(\"point\", [()=>v.B.X(), ()=>v.B.Y()]); v.jsx_graph2.create(\"functiongraph\", [(x) => v.fFunc.evaluate({'x':x}), v.x0.value()-1, v.x0.value()+1]); v.jsx_graph2.create(\"line\", [v.A2,v.B2]); v.jsx_graph.addChild(v.jsx_graph2); <\/postRenderScript> <\/setup> <statement> <p>Given the graph of a function, <m>y=f(x)<\/m>, move the point labeled <m>B<\/m> to create an approximate tangent line at <m>x=<eval expr=\"x0\"\/><\/m> and use this to approximate the equation of the tangent line.<\/p> <p>The tangent line is approximated by <m>y=<\/m> <fillin context=\"formula\" correct=\"tangentFunc\" name=\"stuTangent\" \/><\/p> <dynamic-graph sub-id=\"graph\" width=\"300px\" height=\"300px\" mode=\"jsxgraph\"> <board-settings> <xmin>-5<\/xmin> <xmax>5<\/xmax> <ymin>-50<\/ymin> <ymax>50<\/ymax> <\/board-settings> <contents> <graph-function> <formula><eval expr=\"fFunc\"\/><\/formula> <variable> <name>x<\/name> <min>-5<\/min> <max>5<\/max> <\/variable> <style> <color>red<\/color> <stroke>dashed<\/stroke> <stroke-width>2<\/stroke-width> <\/style> <\/graph-function> <graph-point name=\"A\"> <coord><eval expr=\"x0\"\/><\/coord> <coord><eval expr=\"y0\"\/><\/coord> <style> <color>red<\/color> <\/style> <\/graph-point> <\/contents> <\/dynamic-graph> <dynamic-graph sub-id=\"graph2\" width=\"150px\" height=\"150px\" mode=\"jsxgraph\"> <board-settings> <xmin>v.x0.value()-.5<\/xmin> <xmax>v.x0.value()+.5<\/xmax> <ymin>v.y0.value()-5<\/ymin> <ymax>v.y0.value()+5<\/ymax> <\/board-settings> <contents> <graph-point name=\"A2\"> <coord><eval expr=\"x0\"\/><\/coord> <coord><eval expr=\"y0\"\/><\/coord> <style> <color>red<\/color> <\/style> <\/graph-point> <\/contents> <\/dynamic-graph> <\/statement> <evaluation> <evaluate submit=\"stuTangent\"> <test correct=\"yes\"> <raw-js> ( function(){ let retValue=0, stuSlope = stuTangent.derivative('x'); if (stuSlope.isConstant) { stuSlope = stuSlope.evaluate({'x':x0.value()}); if ( Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) &lt; yTol &amp;&amp; Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuSlope\/aspect)) &lt; (angleTol\/180)*Math.PI ) { retValue = 1; } } return retValue; })() <\/raw-js> <feedback>Great! That is a close approximation to the tangent line.<\/feedback> <\/test> <test> <raw-js>( !stuTangent.derivative('x').isConstant() )<\/raw-js> <feedback>Your formula \\\\([%= stuTangent.toTeX() %]\\\\) is not linear.<\/feedback> <\/test> <test> <raw-js>function(){ return Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) &gt; yTol;}()<\/raw-js> <feedback>The y-value of your line at the point of interest is too far away from the graph to be considered on the graph.<\/feedback> <\/test> <test> <raw-js>function(){ return Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuTangent.derivative('x').evaluate({'x':x0.value()})\/aspect)) &gt; (angleTol\/180)*Math.PI; }() <\/raw-js> <feedback>The angle of the line determined by its slope is not close enough to the tangent line.<\/feedback> <\/test> <test> <eval expr=\"fPrime\"\/> <feedback>The derivative itself is not the same as the tangent line.<\/feedback> <\/test> <\/evaluate> <\/evaluation> <solution> <p> Starting with the function <m>f(x) = <eval expr=\"fFunc\"\/><\/m>, we first calculate the derivative <m>f'(x) = <eval expr=\"fPrime\"\/><\/m>. We evaluate <m>f(<eval expr=\"x0\"\/>) = <eval expr=\"y0\"\/><\/m> and <m>f'(<eval expr=\"x0\"\/>) = <eval expr=\"m\"\/><\/m> to find the <m>y<\/m>-value at the point and the slope of the tangent line. Then, using the point-slope equation of a line we get the equation of the tangent line as <m>y=<eval expr=\"tangentFunc\"\/><\/m>. <\/p> <\/solution> <\/exercise>  ex-solve-equation.ptx   "
},
{
  "id": "listing-6",
  "level": "2",
  "url": "section-markup-examples.html#listing-6",
  "type": "Listing",
  "number": "3.2.1",
  "title": "",
  "body": " <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"solve-equation\"> <title>Solve an Equation<\/title> <setup seed=\"12345\"> <de-object name=\"m\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" nonzero=\"yes\" min=\"-4\" max=\"5\" by=\"1\" \/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" \/> <\/de-object> <de-object name=\"negB\" context=\"number\" mode=\"formula\">-{{b}}<\/de-object> <de-object name=\"theFunction\" context=\"formula\" mode=\"formula\">{{m}}*x+{{b}}<\/de-object> <de-object name=\"theAnswer\" context=\"formula\" mode=\"formula\">-{{b}}\/{{m}}<\/de-object> <\/setup> <statement> <p> Solve the equation <me><eval expr=\"theFunction\"\/>=0<\/me> to get the value of <m>x<\/m>. <\/p> <p><m>x = <\/m> <fillin width=\"5\" correct=\"theAnswer\" name=\"solution\"\/><\/p> <\/statement> <solution> <p> We want to isolate the <m>x<\/m> in the equation <m><eval expr=\"theFunction\"\/>=0<\/m>. Because addition of <m><eval expr=\"b\"\/><\/m> is the last operation, we apply the inverse by adding <m><eval expr=\"negB\"\/><\/m> to both sides. The new, but equivalent equation is now <m><eval expr=\"m\"\/>x = <eval expr=\"negB\"\/><\/m>. Dividing both sides of the equation by <m><eval expr=\"m\"\/><\/m>, we obtain the solution <m>x=<eval expr=\"theAnswer\"\/><\/m>. <\/p> <\/solution> <evaluation> <evaluate submit=\"solution\"> <test correct=\"yes\"> <eval expr=\"theAnswer\" \/> <feedback>Correct!<\/feedback> <\/test> <test> <de-object context=\"formula\" mode=\"formula\">{{b}}\/{{m}}<\/de-object> <feedback>Error with signs while isolating <m>x<\/m><\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <\/exercise>  ex-solve-equation.ptx  "
},
{
  "id": "solve-equation-fill",
  "level": "2",
  "url": "section-markup-examples.html#solve-equation-fill",
  "type": "Example",
  "number": "3.2.2",
  "title": "Solve an Equation.",
  "body": " Solve an Equation   Solve the equation to get the value of .      We want to isolate the in the equation . Because addition of is the last operation, we apply the inverse by adding to both sides. The new, but equivalent equation is now . Dividing both sides of the equation by , we obtain the solution .   "
},
{
  "id": "listing-7",
  "level": "2",
  "url": "section-markup-examples.html#listing-7",
  "type": "Listing",
  "number": "3.2.3",
  "title": "",
  "body": " <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"find-derivatives\"> <title>Find the Derivatives<\/title> <setup seed=\"1234\"> <de-object name=\"a\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"n\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"2\" max=\"5\"\/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"formula\" context=\"formula\" mode=\"formula\">{{a}}*x^{{n}}+{{b}}<\/de-object> <de-object name=\"correctD1\" context=\"formula\" mode=\"formula\">({{a}}*{{n}})*x^({{n}}-1)<\/de-object> <de-object name=\"correctD2\" context=\"formula\" mode=\"formula\">({{a}}*{{n}}*({{n}}-1))*x^({{n}}-2)<\/de-object> <\/setup> <statement> <p> Consider the function <m>f(x)=<eval expr=\"formula\"\/><\/m>. Find <m>f'(x)<\/m> and <m>f''(x)<\/m>. <\/p> <p> <m>f'(x) = <\/m> <fillin width=\"15\" correct=\"correctD1\" name=\"firstD\"\/> and <m>f''(x)=<\/m> <fillin width=\"15\" correct=\"correctD2\" name=\"secondD\"\/> <\/p> <\/statement> <evaluation> <evaluate submit=\"firstD\"> <test> <eval expr=\"correctD2\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <evaluate submit=\"secondD\"> <test> <eval expr=\"correctD1\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <solution> <p>Placeholder for a solution!<\/p> <\/solution> <\/exercise>  ex-solve-equation.ptx  "
},
{
  "id": "listing-8",
  "level": "2",
  "url": "section-markup-examples.html#listing-8",
  "type": "Listing",
  "number": "3.2.4",
  "title": "",
  "body": " <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"find-derivatives\"> <title>Find the Derivatives<\/title> <setup seed=\"1234\"> <de-object name=\"a\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"n\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"2\" max=\"5\"\/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"formula\" context=\"formula\" mode=\"formula\">{{a}}*x^{{n}}+{{b}}<\/de-object> <de-object name=\"correctD1\" context=\"formula\" mode=\"formula\">({{a}}*{{n}})*x^({{n}}-1)<\/de-object> <de-object name=\"correctD2\" context=\"formula\" mode=\"formula\">({{a}}*{{n}}*({{n}}-1))*x^({{n}}-2)<\/de-object> <\/setup> <statement> <p> Consider the function <m>f(x)=<eval expr=\"formula\"\/><\/m>. Find <m>f'(x)<\/m> and <m>f''(x)<\/m>. <\/p> <p> <m>f'(x) = <\/m> <fillin width=\"15\" correct=\"correctD1\" name=\"firstD\"\/> and <m>f''(x)=<\/m> <fillin width=\"15\" correct=\"correctD2\" name=\"secondD\"\/> <\/p> <\/statement> <evaluation> <evaluate submit=\"firstD\"> <test> <eval expr=\"correctD2\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <evaluate submit=\"secondD\"> <test> <eval expr=\"correctD1\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <solution> <p>Placeholder for a solution!<\/p> <\/solution> <\/exercise>  ex-solve-equation.ptx  "
},
{
  "id": "listing-9",
  "level": "2",
  "url": "section-markup-examples.html#listing-9",
  "type": "Listing",
  "number": "3.2.5",
  "title": "",
  "body": " <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <exercise xml:id=\"function-tangent-line\"> <title>Find the Tangent Line<\/title> <setup seed=\"1234\"> <environment> <random-seed>1234<\/random-seed> <\/environment> <!-- Create parabola coefficients --> <de-object name=\"a\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"b\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" \/> <\/de-object> <de-object name=\"c\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\" \/> <\/de-object> <!-- Choose a point --> <de-object name=\"x0\" context=\"number\" mode=\"random\"> <options distribution=\"discrete\" min=\"-3\" max=\"3\" \/> <\/de-object> <!-- Create the quadratic function --> <de-object name=\"fFunc\" context=\"formula\" mode=\"formula\">{{a}}*x^2+{{b}}*x+{{c}}<\/de-object> <de-object name=\"fPrime\" context=\"formula\" mode=\"derivative\"> <formula><eval expr=\"fFunc\"\/><\/formula> <variable name=\"x\"\/> <\/de-object> <!-- Calculate values needed --> <de-object name=\"y0\" context=\"number\" mode=\"evaluate\"> <formula><eval expr=\"fFunc\"\/><\/formula> <variable name=\"x\"><eval expr=\"x0\"\/><\/variable> <\/de-object> <de-object name=\"m\" context=\"number\" mode=\"evaluate\"> <formula><eval expr=\"fPrime\"\/><\/formula> <variable name=\"x\"><eval expr=\"x0\"\/><\/variable> <\/de-object> <!-- Tangent Formula --> <de-object name=\"tangentFunc\" context=\"formula\" mode=\"formula\">{{m}}*(x-{{x0}})+{{y0}}<\/de-object> <de-object name=\"errorTangent1\" context=\"formula\" mode=\"formula\">{{fPrime}}*(x-{{x0}})+{{y0}}<\/de-object> <postRenderScript> v.B = v.jsx_graph.create(\"point\", [v.x0.value()+1, 0], { fixed:false }); v.angleTol = 5; \/\/ Tolerance for angle v.aspect = 10; v.yTol = 0.1; \/\/ Tolerance for y-value of point v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)-v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)+v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A,v.B]); v.B2 = v.jsx_graph2.create(\"point\", [()=>v.B.X(), ()=>v.B.Y()]); v.jsx_graph2.create(\"functiongraph\", [(x) => v.fFunc.evaluate({'x':x}), v.x0.value()-1, v.x0.value()+1]); v.jsx_graph2.create(\"line\", [v.A2,v.B2]); v.jsx_graph.addChild(v.jsx_graph2); <\/postRenderScript> <\/setup> <statement> <p>Given the graph of a function, <m>y=f(x)<\/m>, move the point labeled <m>B<\/m> to create an approximate tangent line at <m>x=<eval expr=\"x0\"\/><\/m> and use this to approximate the equation of the tangent line.<\/p> <p>The tangent line is approximated by <m>y=<\/m> <fillin context=\"formula\" correct=\"tangentFunc\" name=\"stuTangent\" \/><\/p> <dynamic-graph sub-id=\"graph\" width=\"300px\" height=\"300px\" mode=\"jsxgraph\"> <board-settings> <xmin>-5<\/xmin> <xmax>5<\/xmax> <ymin>-50<\/ymin> <ymax>50<\/ymax> <\/board-settings> <contents> <graph-function> <formula><eval expr=\"fFunc\"\/><\/formula> <variable> <name>x<\/name> <min>-5<\/min> <max>5<\/max> <\/variable> <style> <color>red<\/color> <stroke>dashed<\/stroke> <stroke-width>2<\/stroke-width> <\/style> <\/graph-function> <graph-point name=\"A\"> <coord><eval expr=\"x0\"\/><\/coord> <coord><eval expr=\"y0\"\/><\/coord> <style> <color>red<\/color> <\/style> <\/graph-point> <\/contents> <\/dynamic-graph> <dynamic-graph sub-id=\"graph2\" width=\"150px\" height=\"150px\" mode=\"jsxgraph\"> <board-settings> <xmin>v.x0.value()-.5<\/xmin> <xmax>v.x0.value()+.5<\/xmax> <ymin>v.y0.value()-5<\/ymin> <ymax>v.y0.value()+5<\/ymax> <\/board-settings> <contents> <graph-point name=\"A2\"> <coord><eval expr=\"x0\"\/><\/coord> <coord><eval expr=\"y0\"\/><\/coord> <style> <color>red<\/color> <\/style> <\/graph-point> <\/contents> <\/dynamic-graph> <\/statement> <evaluation> <evaluate submit=\"stuTangent\"> <test correct=\"yes\"> <raw-js> ( function(){ let retValue=0, stuSlope = stuTangent.derivative('x'); if (stuSlope.isConstant) { stuSlope = stuSlope.evaluate({'x':x0.value()}); if ( Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) &lt; yTol &amp;&amp; Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuSlope\/aspect)) &lt; (angleTol\/180)*Math.PI ) { retValue = 1; } } return retValue; })() <\/raw-js> <feedback>Great! That is a close approximation to the tangent line.<\/feedback> <\/test> <test> <raw-js>( !stuTangent.derivative('x').isConstant() )<\/raw-js> <feedback>Your formula \\\\([%= stuTangent.toTeX() %]\\\\) is not linear.<\/feedback> <\/test> <test> <raw-js>function(){ return Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) &gt; yTol;}()<\/raw-js> <feedback>The y-value of your line at the point of interest is too far away from the graph to be considered on the graph.<\/feedback> <\/test> <test> <raw-js>function(){ return Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuTangent.derivative('x').evaluate({'x':x0.value()})\/aspect)) &gt; (angleTol\/180)*Math.PI; }() <\/raw-js> <feedback>The angle of the line determined by its slope is not close enough to the tangent line.<\/feedback> <\/test> <test> <eval expr=\"fPrime\"\/> <feedback>The derivative itself is not the same as the tangent line.<\/feedback> <\/test> <\/evaluate> <\/evaluation> <solution> <p> Starting with the function <m>f(x) = <eval expr=\"fFunc\"\/><\/m>, we first calculate the derivative <m>f'(x) = <eval expr=\"fPrime\"\/><\/m>. We evaluate <m>f(<eval expr=\"x0\"\/>) = <eval expr=\"y0\"\/><\/m> and <m>f'(<eval expr=\"x0\"\/>) = <eval expr=\"m\"\/><\/m> to find the <m>y<\/m>-value at the point and the slope of the tangent line. Then, using the point-slope equation of a line we get the equation of the tangent line as <m>y=<eval expr=\"tangentFunc\"\/><\/m>. <\/p> <\/solution> <\/exercise>  ex-solve-equation.ptx  "
},
{
  "id": "ch-live-exercises",
  "level": "1",
  "url": "ch-live-exercises.html",
  "type": "Chapter",
  "number": "4",
  "title": "Live HTML Exercises",
  "body": " Live HTML Exercises  This is where the live WeBWorK problems would go and where they are coded into the project. PreTeXt currently doesn't know what to do with the var elements, so they don't appear properly. Here is some math .   Fill-In Formula (Dynamic)  Find a formula for a cubic function that roots at , , and and so that .                 {{x1}}+{{d1}}  {{x2}}+{{d2}}  (x-{{x1}})*(x-{{x2}})*(x-{{x3}})    0   {{y0}}\/{{base_yint}}  {{A}}*(x-{{x1}})*(x-{{x2}})*(x-{{x3}})         Knowing the roots of a polynomial allows us to write down the formula of in factored form, with an unknown scaling multiple .  When we evaluate at using this formula, we find . Since we also know , we can write down the equation and find that .  Consequently, we can write our function in the form .   Solve an Equation        -{{b}}  {{m}}*x+{{b}}  -{{b}}\/{{m}}   Solve the equation to get the value of .        Correct!    {{b}}\/{{m}}  Error with signs while isolating   Incorrect. Try again.    We want to isolate the in the equation . Because addition of is the last operation, we apply the inverse by adding to both sides. The new, but equivalent equation is now . Dividing both sides of the equation by , we obtain the solution .   Find the Derivatives           {{a}}*x^{{n}}+{{b}}  ({{a}}*{{n}})*x^({{n}}-1)  ({{a}}*{{n}}*({{n}}-1))*x^({{n}}-2)   Consider the function . Find and .    and        You confused which derivative is which.   Incorrect. Try again.      You confused which derivative is which.   Incorrect. Try again.    Placeholder for a solution!   Decompose the Function                 {{a}}*x^{{n}}+{{b}}  {{c}}*x+{{d}}  x       Consider the function . Find two nontrivial functions and so that .    and        is not allowed for nontrivial compositions.                    You have composed in the wrong order.       is not allowed for nontrivial compositions.                         Excellent!     Noticing that the expression appears inside parentheses with a power, it makes sense to think of that as the inner function, defining . The outer function describes what happens to that. If we imagined replacing the formula with a box and then call that box our variable , we find the outer function is given by .  This is not the only non-trivial composition. Can you find others?   Find the Tangent Line   1234                  {{a}}*x^2+{{b}}*x+{{c}}                {{m}}*(x-{{x0}})+{{y0}}  {{fPrime}}*(x-{{x0}})+{{y0}}  v.B = v.jsx_graph.create(\"point\", [v.x0.value()+1, 0], { fixed:false }); v.angleTol = 5; \/\/ Tolerance for angle v.aspect = 10; v.yTol = 0.1; \/\/ Tolerance for y-value of point v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)-v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)+v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A,v.B]); v.B2 = v.jsx_graph2.create(\"point\", [()=>v.B.X(), ()=>v.B.Y()]); v.jsx_graph2.create(\"functiongraph\", [(x) => v.fFunc.evaluate({'x':x}), v.x0.value()-1, v.x0.value()+1]); v.jsx_graph2.create(\"line\", [v.A2,v.B2]); v.jsx_graph.addChild(v.jsx_graph2);   Given the graph of a function, , move the point labeled to create an approximate tangent line at and use this to approximate the equation of the tangent line.  The tangent line is approximated by     -5  5  -50  50       x  -5  5    red  dashed  2        red        v.x0.value()-.5  v.x0.value()+.5  v.y0.value()-5  v.y0.value()+5        red         ( function(){ let retValue=0, stuSlope = stuTangent.derivative('x'); if (stuSlope.isConstant) { stuSlope = stuSlope.evaluate({'x':x0.value()}); if ( Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) < yTol && Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuSlope\/aspect)) < (angleTol\/180)*Math.PI ) { retValue = 1; } } return retValue; })()  Great! That is a close approximation to the tangent line.    ( !stuTangent.derivative('x').isConstant() )  Your formula \\\\([%= stuTangent.toTeX() %]\\\\) is not linear.    function(){ return Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) > yTol;}()  The y-value of your line at the point of interest is too far away from the graph to be considered on the graph.    function(){ return Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuTangent.derivative('x').evaluate({'x':x0.value()})\/aspect)) > (angleTol\/180)*Math.PI; }()  The angle of the line determined by its slope is not close enough to the tangent line.     The derivative itself is not the same as the tangent line.     Starting with the function , we first calculate the derivative . We evaluate and to find the -value at the point and the slope of the tangent line. Then, using the point-slope equation of a line we get the equation of the tangent line as .    "
},
{
  "id": "dynamic-fitb-simple-formula",
  "level": "2",
  "url": "exercises-1.html#dynamic-fitb-simple-formula",
  "type": "Exercise",
  "number": "4.1",
  "title": "Fill-In Formula (Dynamic).",
  "body": "Fill-In Formula (Dynamic)  Find a formula for a cubic function that roots at , , and and so that .                 {{x1}}+{{d1}}  {{x2}}+{{d2}}  (x-{{x1}})*(x-{{x2}})*(x-{{x3}})    0   {{y0}}\/{{base_yint}}  {{A}}*(x-{{x1}})*(x-{{x2}})*(x-{{x3}})         Knowing the roots of a polynomial allows us to write down the formula of in factored form, with an unknown scaling multiple .  When we evaluate at using this formula, we find . Since we also know , we can write down the equation and find that .  Consequently, we can write our function in the form .  "
},
{
  "id": "solve-equation",
  "level": "2",
  "url": "exercises-1.html#solve-equation",
  "type": "Exercise",
  "number": "4.2",
  "title": "Solve an Equation.",
  "body": "Solve an Equation        -{{b}}  {{m}}*x+{{b}}  -{{b}}\/{{m}}   Solve the equation to get the value of .        Correct!    {{b}}\/{{m}}  Error with signs while isolating   Incorrect. Try again.    We want to isolate the in the equation . Because addition of is the last operation, we apply the inverse by adding to both sides. The new, but equivalent equation is now . Dividing both sides of the equation by , we obtain the solution .  "
},
{
  "id": "find-derivatives",
  "level": "2",
  "url": "exercises-1.html#find-derivatives",
  "type": "Exercise",
  "number": "4.3",
  "title": "Find the Derivatives.",
  "body": "Find the Derivatives           {{a}}*x^{{n}}+{{b}}  ({{a}}*{{n}})*x^({{n}}-1)  ({{a}}*{{n}}*({{n}}-1))*x^({{n}}-2)   Consider the function . Find and .    and        You confused which derivative is which.   Incorrect. Try again.      You confused which derivative is which.   Incorrect. Try again.    Placeholder for a solution!  "
},
{
  "id": "function-decomposition",
  "level": "2",
  "url": "exercises-1.html#function-decomposition",
  "type": "Exercise",
  "number": "4.4",
  "title": "Decompose the Function.",
  "body": "Decompose the Function                 {{a}}*x^{{n}}+{{b}}  {{c}}*x+{{d}}  x       Consider the function . Find two nontrivial functions and so that .    and        is not allowed for nontrivial compositions.                    You have composed in the wrong order.       is not allowed for nontrivial compositions.                         Excellent!     Noticing that the expression appears inside parentheses with a power, it makes sense to think of that as the inner function, defining . The outer function describes what happens to that. If we imagined replacing the formula with a box and then call that box our variable , we find the outer function is given by .  This is not the only non-trivial composition. Can you find others?  "
},
{
  "id": "function-tangent-line",
  "level": "2",
  "url": "exercises-1.html#function-tangent-line",
  "type": "Exercise",
  "number": "4.5",
  "title": "Find the Tangent Line.",
  "body": "Find the Tangent Line   1234                  {{a}}*x^2+{{b}}*x+{{c}}                {{m}}*(x-{{x0}})+{{y0}}  {{fPrime}}*(x-{{x0}})+{{y0}}  v.B = v.jsx_graph.create(\"point\", [v.x0.value()+1, 0], { fixed:false }); v.angleTol = 5; \/\/ Tolerance for angle v.aspect = 10; v.yTol = 0.1; \/\/ Tolerance for y-value of point v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)-v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A, v.jsx_graph.create(\"point\", [v.x0.value()+1, v.y0.value()+v.aspect*Math.tan(Math.atan(v.m.value()\/v.aspect)+v.angleTol*Math.PI\/180)], {visible:false})], {strokeWidth:1, dash:2}); v.jsx_graph.create(\"line\", [v.A,v.B]); v.B2 = v.jsx_graph2.create(\"point\", [()=>v.B.X(), ()=>v.B.Y()]); v.jsx_graph2.create(\"functiongraph\", [(x) => v.fFunc.evaluate({'x':x}), v.x0.value()-1, v.x0.value()+1]); v.jsx_graph2.create(\"line\", [v.A2,v.B2]); v.jsx_graph.addChild(v.jsx_graph2);   Given the graph of a function, , move the point labeled to create an approximate tangent line at and use this to approximate the equation of the tangent line.  The tangent line is approximated by     -5  5  -50  50       x  -5  5    red  dashed  2        red        v.x0.value()-.5  v.x0.value()+.5  v.y0.value()-5  v.y0.value()+5        red         ( function(){ let retValue=0, stuSlope = stuTangent.derivative('x'); if (stuSlope.isConstant) { stuSlope = stuSlope.evaluate({'x':x0.value()}); if ( Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) < yTol && Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuSlope\/aspect)) < (angleTol\/180)*Math.PI ) { retValue = 1; } } return retValue; })()  Great! That is a close approximation to the tangent line.    ( !stuTangent.derivative('x').isConstant() )  Your formula \\\\([%= stuTangent.toTeX() %]\\\\) is not linear.    function(){ return Math.abs(y0.value() - stuTangent.evaluate({'x':x0.value()})) > yTol;}()  The y-value of your line at the point of interest is too far away from the graph to be considered on the graph.    function(){ return Math.abs(Math.atan(m.value()\/aspect) - Math.atan(stuTangent.derivative('x').evaluate({'x':x0.value()})\/aspect)) > (angleTol\/180)*Math.PI; }()  The angle of the line determined by its slope is not close enough to the tangent line.     The derivative itself is not the same as the tangent line.     Starting with the function , we first calculate the derivative . We evaluate and to find the -value at the point and the slope of the tangent line. Then, using the point-slope equation of a line we get the equation of the tangent line as .  "
},
{
  "id": "solutions-1",
  "level": "1",
  "url": "solutions-1.html",
  "type": "Appendix",
  "number": "A",
  "title": "Selected Hints",
  "body": " Selected Hints  "
},
{
  "id": "solutions-2",
  "level": "1",
  "url": "solutions-2.html",
  "type": "Appendix",
  "number": "B",
  "title": "Selected Solutions",
  "body": " Selected Solutions  "
},
{
  "id": "appendix-1",
  "level": "1",
  "url": "appendix-1.html",
  "type": "Appendix",
  "number": "C",
  "title": "List of Symbols",
  "body": " List of Symbols   "
},
{
  "id": "index-1",
  "level": "1",
  "url": "index-1.html",
  "type": "Index",
  "number": "",
  "title": "Index",
  "body": " Index   "
},
{
  "id": "colophon-2",
  "level": "1",
  "url": "colophon-2.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": " This book was authored in PreTeXt .  "
}
]

var ptx_lunr_idx = lunr(function () {
  this.ref('id')
  this.field('title')
  this.field('body')

  ptx_lunr_docs.forEach(function (doc) {
    this.add(doc)
  }, this)
})
