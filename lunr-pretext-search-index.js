var ptx_lunr_search_style = "textbook";
var ptx_lunr_docs = [
{
  "id": "meta_frontmatter-2",
  "level": "1",
  "url": "meta_frontmatter-2.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": "  Brian Walton's GitHub repository   copyright  "
},
{
  "id": "meta_frontmatter-preface",
  "level": "1",
  "url": "meta_frontmatter-preface.html",
  "type": "Preface",
  "number": "",
  "title": "Preface",
  "body": "   This document provides documentation for the Runestone Fill-in-the-Blank Component and PreTeXt markup that supports dynamically generated questions and evaluators.  "
},
{
  "id": "ch_motivation",
  "level": "1",
  "url": "ch_motivation.html",
  "type": "Chapter",
  "number": "1",
  "title": "Motivation",
  "body": " Motivation  I have long been interested in interactive exercises for students learning mathematics. The promise is that students can try exercises that focus on particular skills or concepts and a computer will provide immediate feedback on whether they found an appropriate solution. When these problems are designed to allow for random variations with answer checkers that adapt to these variations, we have dynamic exercises.  Dynamic exercises have a number of benefits. A single dynamic exercise creates a template for a large number of related problems. In a homework system, this allows a class of students to be assigned related problems that follow a common strategy while ensuring that students are individually solving problems with different details than (most of) those around them. For a single student, dynamic exercises allow a student to try new problems to reinforce earlier practice. The computer might be able to recognize submitted answers that result from common mistakes or misconceptions and provide feedback that can guide the student to correct their error.  Dynamic exercises also have some challenges. For an author, there is the complication of writing a generalization of an exercise. Key aspects of the problem that allow mutation introduce parameters for randomization. The author then needs to ensure that different random versions of the problem have comparable complexity and methods of solution. An answer and solution that incorporates the variability is also necessary.  Online homework systems are one way that the idea of dynamic exercises is realized. WeBWorK is one example of a system that allows authors to create custom problems as well as to provide logic to evaluate student responses. Other learning systems implement similar models. These different systems have their own approaches for how an author defines and writes their exercises.  PreTeXt-authored books allow WeBWorK exercises to be embedded within the text. Once such a problem is activated, a student can anonymously submit a response to a question and a remote server can evaluate their submission and provide appropriate feedback. The markup described in this document makes it possible for an author to define the logic and structure of the exercise. The PreTeXt processing system then interprets the structure into an implementation that can be a server-free version or a problem definition file that can be implemented in a homework system like WeBWorK. Although it is anticipated that the Javascript implementation will grow to include additional structures, this XML-based approach to defining problems is not intended to support the full flexibility of a system like WeBWorK.   Objectives    The author focuses on the structure and logic of a dynamic exercise rather than the syntax and language-specific implementations.  A Javascript evaluation engine is available to provide a server-free implementation of problems reducing the reliance of a text on 3rd party servers.  An XML-based definition of an exercise can allow for transcoding to different systems, e.g. WeBWorK, WebAssign, or other systems.     "
},
{
  "id": "section-markup-exercise",
  "level": "1",
  "url": "section-markup-exercise.html",
  "type": "Section",
  "number": "2.1",
  "title": "Fill-in-the-Blank Exercise Markup",
  "body": " Fill-in-the-Blank Exercise Markup  Currently, fill-in-the-blank questions in PreTeXt are only implemented as exercises. To define a fill-in-the-blank exercise, you will first define a standard PreTeXt <exercise> element with a an optional <title> and required <statement> . In the <statement> of your exercise, you will add <fillin> elements. Because these exercises are implemented as Runestone components, the <exercise> also requires a @label attribute.  Each <fillin> is required to have an attribute @answer that contains a correct answer to the question or @ansobj that gives the name of an object containing an answer. The <fillin> is also required to have a @mode that characterizes the mode by which the submitted answer will be parsed. Current possible modes are string , number , and math . If the evaluation of the answer is complex, the <fillin> should also have a @name attribute, which is required to follow standard programming variable name format. Additionally, a <fillin> has an optional @width attribute that controls the size of the blank in static representations.  An interactive fill-in-the-blank exercise requires an <evaluation> element that is a sibling to the corresponding <statement> element. Each <fillin> defined in the <statement> will have a corresponding <evaluate> element within the <evaluation> . If the <fillin> has a @name , the corresponding <evaluate> should have a matching @name attribute. Each <evaluate> will contain a sequence of <test> elements that contain a rule for the test and a feedback message, as explained later.  In order to make the exercise dynamic, where elements of the statement and answers are based on randomization, it is also required to include a <setup> element. The <setup> element can also be used to initialize any additional Javascript associated with the exercise for more advanced settings.  The overall structure for a fill-in-the-blank exercise is illustrated in . Additional details will be explained in the following sections.    <exercise xml:id='my-id' label='fillin-label'> <title\/> <statement> <p>Write your question.<\/p> <p>I say question, you say <fillin mode='string' name='blankName' answer='answer'\/>! <\/statement> <solution> <!-- currently only used in static representation --> <\/solution> <setup\/> <!-- optional setup to make this dynamic --> <evaluation> <!-- rules for evaluation and feedback --> <evaluate name='blankName'> ... <\/evaluate> <\/evaluation> <\/exercise>   Overall XML structure of a fill-in-the-blank exercise.   "
},
{
  "id": "listing-xml-fitb-overview",
  "level": "2",
  "url": "section-markup-exercise.html#listing-xml-fitb-overview",
  "type": "Listing",
  "number": "2.1.1",
  "title": "",
  "body": "  <exercise xml:id='my-id' label='fillin-label'> <title\/> <statement> <p>Write your question.<\/p> <p>I say question, you say <fillin mode='string' name='blankName' answer='answer'\/>! <\/statement> <solution> <!-- currently only used in static representation --> <\/solution> <setup\/> <!-- optional setup to make this dynamic --> <evaluation> <!-- rules for evaluation and feedback --> <evaluate name='blankName'> ... <\/evaluate> <\/evaluation> <\/exercise>   Overall XML structure of a fill-in-the-blank exercise.  "
},
{
  "id": "section-simple-evaluation",
  "level": "1",
  "url": "section-simple-evaluation.html",
  "type": "Section",
  "number": "2.2",
  "title": "Basic Structure of Evaluation",
  "body": " Basic Structure of Evaluation  Before we get to dynamic, randomized versions of exercises, we will first look at the evaluation of answers for simple answers involving text or numbers. Each <fillin> can be associated with an arbitrary sequence of <test> elements with associated <evaluate> containing a comparison rule and associated feedback. One <test> needs to be identified as testing for correctness, identified with @correct='yes' . All other tests are performed in sequence only if the test for correctness fails, allowing feedback specific to various possible mistakes. The first of these tests to succeed will be the one that provides its feedback in response to the reader's submission.    <evaluate name='blankName'> <test correct='yes'> <comparison\/> <feedback>Correct!<\/feedback> <\/test> <test> <comparison\/> <feedback>Custom feedback A<\/feedback> <\/test> <test> <comparison\/> <feedback>Custom feedback B<\/feedback> <\/test> ... <\/evaluate>   Structure of each <evaluate> element within the <evaluation> block. The <comparison> is replaced by one of the possible comparison elements.   There are three basic comparisons available number comparison, string comparison with regular expressions, and arbitrary Javascript boolean expressions.   Number Comparison  Number comparison with <numcmp> is used when the reader's submission is expected to be a number. The value being tested is provided in the @value attribute. If a dynamic object holds the value, this is replaced by a @object attribute containing the name of that object. Alternatively, the value provided by the <fillin>  @answer attribute can by used by including @use-answer=\"yes\" . It may be the case that a range of values are all considered acceptable answers. In this case, the range can be provided by specifying a @tolerance from the provided value or by directly specifying @min and @max values. Examples of possible <test> definitions are provided in .    <!-- Example A --> <test correct=\"yes\"> <numcmp use-answer=\"yes\"\/> <feedback>Correct.<\/feedback> <\/test> <!-- Example B --> <test> <numcmp use-answer=\"yes\" tolerance=\"0.1\"\/> <feedback>Your answer is within 0.1 of the correct value.<\/feedback> <\/test> <!-- Example C --> <test> <numcmp value=\"42\"\/> <feedback>That is a reasonable guess, but no.<\/feedback> <\/test> <!-- Example D --> <test> <numcmp min=\"3\" max=\"4\"\/> <feedback>You chose a value between 3 and 4.<\/feedback> <\/test> <!-- Example E --> <test> <numcmp value=\"3\" tolerance=\"0.5\"\/> <feedback>You chose a value that rounds to 3.<\/feedback> <\/test>   Examples of <test> using <numcmp> .     String (Text) Comparison  String comparison with <strcmp> is used when the reader's submission is text that can be matched exactly or with a regular expression. The content of the element is the matching string or the regular expression that defines valid answers. By default, PreTeXt adds regular expression codes to surround the provided answer in order to strip off leading and trailing white space and requires your expression completely matches the remaining text. To disable this behavior, include @strip=\"no\" as an attribute. If the comparison does not depend on the case of the characters, include @case=\"insensitive\" . The corresponding <fillin> should have provided an example of a correct answer with @answer , but this should not be a regular expression. To match against that provided string, you may use @use-answer=\"yes\" . Examples of possible <test> definitions are provided in .    <!-- Example A --> <test correct=\"yes\"> <strcmp use-answer=\"yes\"\/> <feedback>Correct.<\/feedback> <\/test> <!-- Example B --> <test> <strcmp use-answer=\"yes\" case=\"insensitive\"\/> <feedback>Some of the characters used the wrong case.<\/feedback> <\/test> <!-- Example C --> <test> <strcmp>[0-9]+<\/strcmp> <feedback>You typed a word made out of digits.<\/feedback> <\/test> <!-- Example D --> <test> <strcmp use-answer=\"yes\" strip=\"no\"\/> <feedback>Your answer includes the correct word but has extra text.<\/feedback> <\/test> <!-- Example E --> <test> <strcmp strip=\"no\" case=\"insensitive\">z.+z<\/strcmp> <feedback>Your answer includes text surrounded by z's.<\/feedback> <\/test>   Examples of <test> using <strcmp> .     Javascript comparison expressions  Additional flexibility is provided by allowing arbitrary user-defined Javascript comparisons using <jscmp> . The content of the <jscmp> element needs to be Javascript code that will evaluate to either a Boolean value of true or false or a string that contains the feedback for a true match. The function should always return false if there is not a match. In addition, because the code is being entered within XML, you will need to take care that special characters are escaped or the code block itself is escaped.  The context in which the code is evaluated will be inside an anonymous function in which the scope includes various useful values. The user's submitted responses for every named <fillin> will be available in a local variable with that same corresponding name. The variable ans will contain the user response for the <fillin> corresponding to the <evaluate> that is being tested. There is also an array ans_array that contains the submitted responses in sequence. Beware that although the Javascript will be evaluated in the context of an anonymous function, Javascript is not sandboxed and you should avoid any calls that might affect content.    <!-- Example A --> <test> <jscmp><!-- test if number is in a list --> [2, 3, 5, 7, 11, 13, 17, 19].includes(Number(ans)) <\/jscmp> <feedback>Your response is prime integer less than 20.<\/feedback> <\/test> <!-- Example B --> <test> <jscmp><!-- find why it fails to be in list --><![CDATA[ function(){ const val=Number(ans); if (val <= 0) { return \"You need to give a positive integer.\" } if (val >= 20) { return \"The integer must be less than 20.\" } for (let i=2; i<=3; i++) { if (val % i == 0) { return `Your answer is composite; for example, it is divisible by ${i}.` } } return false; }()]]> <\/jscmp> <\/test> <!-- Example C --> <test> <jscmp><!-- test if string is palindrome --> function(){ const r1 = new RegExp(\"^\\\\w+$\"); var result=r1.test(ans); if (result) { let revAns = ans.split(\"\").reverse().join(\"\"); result = (ans === revAns); } return result; }() <\/jscmp> <feedback>Your response is a palindrome.<\/feedback> <\/test>   Examples of <test> using <jscmp> .      I love . What number am I thinking of, accurate to two decimal places?           Your answer is within 0.1 of the value I wanted.      That is a reasonable guess, but no.      You chose a value between 3 and 4.      You chose a value that rounds to 3.      The word I'm thinking about is \"magic.\" What word am I thinking about?   Try what happens if you mix the case, or type in a number, or include more than the word, or try \"pizzazz.\"           Some of the characters used the wrong case.     [0-9]+  You typed a word made out of digits.      Your answer includes the correct word but has extra text.     z.+z  Your answer includes text surrounded by z's.      What is an example of a prime number less than 20?      [2, 3, 5, 7, 11, 13, 17, 19].includes(Number(ans))  Your response is prime integer less than 20.    function(){ const val=Number(ans); if (val <= 0) { return \"You need to give a positive integer.\" } if (val >= 20) { return \"The integer must be less than 20.\" } for (let i=2; i<=3; i++) { if (val % i == 0) { return `Your answer is composite; for example, it is divisible by ${i}.` } } return false; }()      What is an example of a palindrome?      function(){ const r1 = new RegExp(\"^\\\\w+$\"); var result=r1.test(ans); if (result) { let revAns = ans.split(\"\").reverse().join(\"\"); result = (ans === revAns); } return result; }()  Your response is a palindrome.    \\w+\\s\\w+  Your response needs to be a single word.      "
},
{
  "id": "listing-xml-evaluate-overview",
  "level": "2",
  "url": "section-simple-evaluation.html#listing-xml-evaluate-overview",
  "type": "Listing",
  "number": "2.2.1",
  "title": "",
  "body": "  <evaluate name='blankName'> <test correct='yes'> <comparison\/> <feedback>Correct!<\/feedback> <\/test> <test> <comparison\/> <feedback>Custom feedback A<\/feedback> <\/test> <test> <comparison\/> <feedback>Custom feedback B<\/feedback> <\/test> ... <\/evaluate>   Structure of each <evaluate> element within the <evaluation> block. The <comparison> is replaced by one of the possible comparison elements.  "
},
{
  "id": "listing-xml-test-numcmp-basic",
  "level": "2",
  "url": "section-simple-evaluation.html#listing-xml-test-numcmp-basic",
  "type": "Listing",
  "number": "2.2.2",
  "title": "",
  "body": "  <!-- Example A --> <test correct=\"yes\"> <numcmp use-answer=\"yes\"\/> <feedback>Correct.<\/feedback> <\/test> <!-- Example B --> <test> <numcmp use-answer=\"yes\" tolerance=\"0.1\"\/> <feedback>Your answer is within 0.1 of the correct value.<\/feedback> <\/test> <!-- Example C --> <test> <numcmp value=\"42\"\/> <feedback>That is a reasonable guess, but no.<\/feedback> <\/test> <!-- Example D --> <test> <numcmp min=\"3\" max=\"4\"\/> <feedback>You chose a value between 3 and 4.<\/feedback> <\/test> <!-- Example E --> <test> <numcmp value=\"3\" tolerance=\"0.5\"\/> <feedback>You chose a value that rounds to 3.<\/feedback> <\/test>   Examples of <test> using <numcmp> .  "
},
{
  "id": "listing-xml-test-strcmp-basic",
  "level": "2",
  "url": "section-simple-evaluation.html#listing-xml-test-strcmp-basic",
  "type": "Listing",
  "number": "2.2.3",
  "title": "",
  "body": "  <!-- Example A --> <test correct=\"yes\"> <strcmp use-answer=\"yes\"\/> <feedback>Correct.<\/feedback> <\/test> <!-- Example B --> <test> <strcmp use-answer=\"yes\" case=\"insensitive\"\/> <feedback>Some of the characters used the wrong case.<\/feedback> <\/test> <!-- Example C --> <test> <strcmp>[0-9]+<\/strcmp> <feedback>You typed a word made out of digits.<\/feedback> <\/test> <!-- Example D --> <test> <strcmp use-answer=\"yes\" strip=\"no\"\/> <feedback>Your answer includes the correct word but has extra text.<\/feedback> <\/test> <!-- Example E --> <test> <strcmp strip=\"no\" case=\"insensitive\">z.+z<\/strcmp> <feedback>Your answer includes text surrounded by z's.<\/feedback> <\/test>   Examples of <test> using <strcmp> .  "
},
{
  "id": "listing-xml-test-jscmp-basic",
  "level": "2",
  "url": "section-simple-evaluation.html#listing-xml-test-jscmp-basic",
  "type": "Listing",
  "number": "2.2.4",
  "title": "",
  "body": "  <!-- Example A --> <test> <jscmp><!-- test if number is in a list --> [2, 3, 5, 7, 11, 13, 17, 19].includes(Number(ans)) <\/jscmp> <feedback>Your response is prime integer less than 20.<\/feedback> <\/test> <!-- Example B --> <test> <jscmp><!-- find why it fails to be in list --><![CDATA[ function(){ const val=Number(ans); if (val <= 0) { return \"You need to give a positive integer.\" } if (val >= 20) { return \"The integer must be less than 20.\" } for (let i=2; i<=3; i++) { if (val % i == 0) { return `Your answer is composite; for example, it is divisible by ${i}.` } } return false; }()]]> <\/jscmp> <\/test> <!-- Example C --> <test> <jscmp><!-- test if string is palindrome --> function(){ const r1 = new RegExp(\"^\\\\w+$\"); var result=r1.test(ans); if (result) { let revAns = ans.split(\"\").reverse().join(\"\"); result = (ans === revAns); } return result; }() <\/jscmp> <feedback>Your response is a palindrome.<\/feedback> <\/test>   Examples of <test> using <jscmp> .  "
},
{
  "id": "ex-demo-numbers",
  "level": "2",
  "url": "section-simple-evaluation.html#ex-demo-numbers",
  "type": "Exercise",
  "number": "2.2.1",
  "title": "",
  "body": " I love . What number am I thinking of, accurate to two decimal places?           Your answer is within 0.1 of the value I wanted.      That is a reasonable guess, but no.      You chose a value between 3 and 4.      You chose a value that rounds to 3.    "
},
{
  "id": "ex-demo-strings",
  "level": "2",
  "url": "section-simple-evaluation.html#ex-demo-strings",
  "type": "Exercise",
  "number": "2.2.2",
  "title": "",
  "body": " The word I'm thinking about is \"magic.\" What word am I thinking about?   Try what happens if you mix the case, or type in a number, or include more than the word, or try \"pizzazz.\"           Some of the characters used the wrong case.     [0-9]+  You typed a word made out of digits.      Your answer includes the correct word but has extra text.     z.+z  Your answer includes text surrounded by z's.    "
},
{
  "id": "ex-demo-jscmp-primes",
  "level": "2",
  "url": "section-simple-evaluation.html#ex-demo-jscmp-primes",
  "type": "Exercise",
  "number": "2.2.3",
  "title": "",
  "body": " What is an example of a prime number less than 20?      [2, 3, 5, 7, 11, 13, 17, 19].includes(Number(ans))  Your response is prime integer less than 20.    function(){ const val=Number(ans); if (val <= 0) { return \"You need to give a positive integer.\" } if (val >= 20) { return \"The integer must be less than 20.\" } for (let i=2; i<=3; i++) { if (val % i == 0) { return `Your answer is composite; for example, it is divisible by ${i}.` } } return false; }()    "
},
{
  "id": "ex-demo-jscmp-palindrome",
  "level": "2",
  "url": "section-simple-evaluation.html#ex-demo-jscmp-palindrome",
  "type": "Exercise",
  "number": "2.2.4",
  "title": "",
  "body": " What is an example of a palindrome?      function(){ const r1 = new RegExp(\"^\\\\w+$\"); var result=r1.test(ans); if (result) { let revAns = ans.split(\"\").reverse().join(\"\"); result = (ans === revAns); } return result; }()  Your response is a palindrome.    \\w+\\s\\w+  Your response needs to be a single word.    "
},
{
  "id": "section-static-setup",
  "level": "1",
  "url": "section-static-setup.html",
  "type": "Section",
  "number": "2.3",
  "title": "Setup and Randomization",
  "body": " Setup and Randomization  Additional flexibility in defining a fill-in-the-blank exercise is provided by introducing an optional <setup> block. This block creates a javascript interface with the Runestone Component defining the exercise so that objects defined during setup can appear in the <statement> , <solution> , and <evaluation> stages of the exercise. A random number generator is made available in this setup. Because static versions of a text need to be consistent, the <setup> tag needs to include a @seed attribute. Dynamic instances ignore this seed value and generate a random initial state.  For dynamic problems, XML mark-up is used to define standard objects within an exercise, such as mathematical expressions. The markup for generating math objects is explained in . Here we focus on pure Javascript randomization for the setup and how substitutions occur within the other elements of the exercise. Direct Javascript code should be included in a <postSetupScript> child element of <setup> and will be evaluated after any XML-defined objects are created.  Within <setup> , the Javascript code works with a JS object v whose members will all be accessible in all of the other components of the exercise. In <preSetupScript> and <postSetupScript> , any object you want to create that should persist in the exercise should be created as a member of v . Any time you wish to reference that object within <setup> , the object must be referenced as a member, as in v.myObject . When referencing these objects in every other component of the exercise, you will only use the object name, as in myObject .  The random number generator defined for the dynamic exercise is available as the function rand() . This function returns a random decimal value between 0 and 1. The seed for the generator is automatically managed by the controlling Runestone Component so that the user sees the same version of the exercise each time they open the text, unless they re-randomize the problem.  A more sophisticated generator is loaded with a math environment, accessible through an object RNG . The RNG object includes the following methods for generating various types of random values.  RNG.randSign() : Random values and .  RNG.randInt(a,b) : Random integer from .  RNG.randUniform(a,b) : Random floating value .  RNG.randDiscrete(a,b,dx,nonzero) : Random value from with . If nonzero=true (optional parameter), then is excluded.    To insert your generated object in the <statement> or <solution> for the exercise, use an <eval> element. Provide the name of the object using the @obj attribute. For example, if I had generated a random value and stored it in v.myNumber , I could include this value in the <statement> or <solution> by using <eval obj=\"myNumber\"\/> . When declaring a <fillin> , if the correct answer is determined by an object, instead of using @answer , use @ansobj=\"objName\" , where objName is replaced by the variable object containing the generated answer.   The substitution generically uses the object's toString function. If the object has a method toTeX , then that function will be called whenever the replacement occurs within a math environment.   In the <evaluation> block, you may still use <numcmp> and <strcmp> . To do a simple comparison with the answer object specified by the <fillin> , the <numcmp> or <strcmp> will have the parameter @use-answer=\"yes\" However, if <numcmp> or <strcmp> is to compare the submitted response to a different object computed during <setup> , such as to give other feedback, use the attribute @object=\"objName\" instead of @value . If a comparison uses <jscmp> , then all object members of v defined in <setup> are directly available by name.  An example is provided in . This is then implemented in .    <exercise xml:id=\"ex-demo-random-simple\" label=\"ex-demo-random-simple\"> <statement> <p> What is the square of <m>x=<eval obj=\"myNum\"\/><\/m>? <m>x^2=<\/m><fillin width=\"5\" mode=\"number\" ansobj=\"mySquare\"\/> <\/p> <\/statement> <setup seed=\"1234\"> <postSetupScript> v.myNum=RNG.randDiscrete(2, 12, 1); v.mySquare=v.myNum**2; <\/postSetupScript> <\/setup> <evaluation> <evaluate> <test correct=\"yes\"> <numcmp use-answer=\"yes\"\/> <\/test> <test> <numcmp valobj=\"myNum\"\/> <feedback>You responded with the original number. Now square it.<\/feedback> <\/test> <\/evaluate> <\/evaluation> <\/exercise>       What is the square of ?    v.myNum=RNG.randDiscrete(2, 12, 1); v.mySquare=v.myNum**2;         You responded with the original number. Now square it.      "
},
{
  "id": "section-static-setup-8",
  "level": "2",
  "url": "section-static-setup.html#section-static-setup-8",
  "type": "Remark",
  "number": "2.3.1",
  "title": "",
  "body": " The substitution generically uses the object's toString function. If the object has a method toTeX , then that function will be called whenever the replacement occurs within a math environment.  "
},
{
  "id": "listing-random-simple",
  "level": "2",
  "url": "section-static-setup.html#listing-random-simple",
  "type": "Listing",
  "number": "2.3.2",
  "title": "",
  "body": "  <exercise xml:id=\"ex-demo-random-simple\" label=\"ex-demo-random-simple\"> <statement> <p> What is the square of <m>x=<eval obj=\"myNum\"\/><\/m>? <m>x^2=<\/m><fillin width=\"5\" mode=\"number\" ansobj=\"mySquare\"\/> <\/p> <\/statement> <setup seed=\"1234\"> <postSetupScript> v.myNum=RNG.randDiscrete(2, 12, 1); v.mySquare=v.myNum**2; <\/postSetupScript> <\/setup> <evaluation> <evaluate> <test correct=\"yes\"> <numcmp use-answer=\"yes\"\/> <\/test> <test> <numcmp valobj=\"myNum\"\/> <feedback>You responded with the original number. Now square it.<\/feedback> <\/test> <\/evaluate> <\/evaluation> <\/exercise>    "
},
{
  "id": "ex-demo-random-simple",
  "level": "2",
  "url": "section-static-setup.html#ex-demo-random-simple",
  "type": "Exercise",
  "number": "2.3.1",
  "title": "",
  "body": " What is the square of ?    v.myNum=RNG.randDiscrete(2, 12, 1); v.mySquare=v.myNum**2;         You responded with the original number. Now square it.    "
},
{
  "id": "sec-dynamic-math",
  "level": "1",
  "url": "sec-dynamic-math.html",
  "type": "Section",
  "number": "2.4",
  "title": "Including Math Objects in Fill-in-the-Blank Exercises",
  "body": " Including Math Objects in Fill-in-the-Blank Exercises   For mathematics instruction, fill-in-the-blank questions are often used with answers defined by mathematical formulas rather than simple numbers or strings. To support this target, additional mark-up is available to implement numbers and expressions represented by formulas. This section describes how to define math objects, how to include them in the statement and solution of the exercise, and how to perform evaluation of responses through the use of expression comparison.    Defining Math Objects  In order to facilitate fill-in-the-blank questions involving mathematical formulas, the <setup> block supports XML elements that define objects to represent numbers and expressions. Objects are added to the environment using <de-object> with a name given by @name . The @context attribute specifies the type of the math object, using @context=\"number\" if the object is meant represent a constant value and @context=\"formula\" if the object is an expression involving variables.  The actual object represented by the <de-object> is defined by one of the following possible elements.  <de-random> : create a number using a random distribution  <de-number> : create a number calculated from a formula involving constants  <de-evaluate> : create a number by evaluating a formula object using particular values for each variable in the formula  <de-expression> : create a formula by parsing an expression, using substitution with other formulas, or by taking a derivative of another formula  Details for each element are provided in the remainder of this section.  To randomize formulas, we typically start by defining random values for parameters that will be used in those formulas. This is accomplished using the <de-random> element which uses attributes to define the distribution. Use @distribution=\"discrete\" with additional attributes @min=\"a\" , @max=\"b\" , @by=\"dx\" (optional, with default @by=\"1\" ), and @nonzero=\"yes|no\" (optional, with default @nonzero=\"no\" ). Internally, this calls RNG.randDiscrete() so that the value is randomly chosen from one of the values less than . If @nonzero=\"yes\" , the value is constrained to skip 0.  When we need to define a number that is calculated in terms of other constants, use the <de-number> element. The content of the element will be a formula which is parsed to an abstract representation of the number. Any previously defined number objects can be included in the formula. In addition, mathematical constants such as and can be included by using pi and e .  When we need to define a formula involving variables, use the tag <de-expression> with the attribute @mode=\"formula\" or with @mode missing. The content of the element will be a formula to be parsed that can involve variables and any objects representing numbers or formulas that were previously added to the math context. Use a space or * between numbers or object names to multiply their values. Be careful not to define formulas with object names that match the name of a variable.  Once a formula is defined as an object, we can generate new objects based on that formula. Currently supported methods include evaluation to create a number, substitution to create new formulas, and differentiation to create the derivative as a new formula.  To evaluate a formula and obtain a number, we need to specify the value of each variable in that formula. This is accomplished with <de-evaluate> . Within <de-evaluate> , we need to include a <formula> element which can contain one of the following:  <eval> with @obj=\"objName\" to reference a previously defined formula object by its name,  <de-expression> to create a temporary formula object using the same rules as explained in this section.  In addition, the <de-evaluate> must include a <variable> element for each variable that appears in the formula with @name giving the name of the variable and one of the following as content:  <eval> with @obj=\"objName\" to reference a previously defined number object by its name,  <de-number> to create a temporary number object based on a parsed formula as described earlier,  or plain text giving a direct representation of a number (no formulas).    To substitute an arbitrary math object for a variable (composition) to obtain a new formula, we create <de-expression> using @mode=\"substitution\" . Within the <de-expression> element, we need to specify the root formula using a <formula> element containing either <eval> or <de-expression> elements as described above for <de-evaluate> . We also need to include a <variable> element for each variable that will be replaced. Just as for evaluation, the <variable> needs @name to indicate the name of the relevant variable and content specifying the formula to use in substitution:  <eval> with @obj=\"objName\" to reference a previously defined math object by its name,  <de-expression> to create a temporary formula object based on a any valid formula described in this section.    To differentiate a formula with respect to one of its variables, we create <de-expression> using @mode=\"derivative\" . Within the <de-expression> element, we need to include a <formula> element for the root formula containing either <eval> or <de-expression> elements. We also need to include a <variable> element with the @name indicating the variable of differentiation. The <variable> should have no content.    Referencing Math Objects  Having defined math objects in the <setup> for an exercise, we can reference these objects in the statement body of text, as answers to <fillin> elements, and in the <evaluation> block. To insert a math object in the <statement> , include an <eval> element within a math environment using the attribute @obj=\"objName\" . To indicate that a <fillin> is expecting a mathematical formula, we need to use the attribute @mode=\"math\" and then declare a correct answer with the attribute @ansobj=\"objName\" .  When a user submits an answer to the <fillin> , the Runestone Component parses the response to create an object representing the response for use in the <evaluation> block. The responses for each <fillin> with @mode=\"math\" are parsed as math objects. In the context of each <evaluate> element associated with a <fillin> , the variable ans has the parsed response for that <fillin> . Other <fillin> responses are in the array ans_array . In addition, for each <fillin> with a @name , the parsed response is available by that name.  The basic comparison for a <test> involving math objects is the <mathcmp> evaluator. The simplest case is to compare the submitted response with an object created in the <setup> block.  <mathcmp use-answer=\"yes\"\/> : matches the submitted response with @ansobj defined in corresponding <fillin>  <mathcmp expr=\"objName\"\/> : matches the submitted response with the math object having name objName  The next case is to compare the submitted response with a new math object created at the time of the comparison. For example, this allows the new object to be dependent on the submitted response. Additionally, it might be desired to compare two different math objects, with one or both of the objects created at the time of the comparison. The basic structure of these comparisons are illustrated in .    <!-- Compare submitted response with fillin answer --> <mathcmp use-answer=\"yes\"\/> <!-- Compare submitted response with pre-computed object --> <mathcmp obj=\"objName\"\/> <!-- Compare submitted response with pre-computed object (alternate) --> <mathcmp> <eval obj=\"objName\"\/> <\/mathcmp <!-- Implicit mathcmp with submitted response (alternate) --> <eval obj=\"objName\"\/> <!-- Compare submitted response with newly generated object --> <mathcmp> <de-expression\/> <\/mathcmp> <!-- Implicit mathcmp with submitted response (alternate) --> <de-expression\/> <!-- Compare with newly generated object with pre-computed object --> <mathcmp> <de-expression\/> <eval obj=\"objName\"\/> <\/mathcmp> <!-- Compare two newly generated objects --> <mathcmp> <de-expression\/> <de-expression\/> <\/mathcmp>   Possible structures for using <mathcmp> within a <test> . The <de-expression> would be replaced by any valid construction as described for the <setup> .     Advanced Evaluation Techniques  Sometimes, we want to use a common test to evaluate all of the answers simulatenously. In this case, the <evaluation> element requires an attribute @answers-coupled=\"yes\" . We also add an <evaluate> element with @all=\"yes\" that will have a single <test> with @correct=\"yes\" . Feedback for incorrect answers is still determine by <test> entries in the <evaluate> associated with each answer. Normally, <evaluate> elements are matched with <fillin> elements based on their ordering. The alternative, which is required when coupling the answers, is to ensure that every <fillin> and their corresponding <evaluate> elements have matching @name attributes.  When multiple conditions must be satisfied for a submitted response to result in given feedback, some XML elements are defined to perform Boolean logic. In the place of a comparison <jscmp> or <mathcmp> , we can use an element <logic> with attribute @op set to represent one of the three possible operations @op=\"not\" , @op=\"and\" , or @op=\"or\" . Each <logic> element will contain a sequence of other comparisons ( <jscmp> , <mathcmp> , or <logic> ). The comparison <logic> with @op=\"and\" is satisfied if all of the children comparisons evaluate to true. The comparison <logic> with @op=\"or\" is satisfied if at least one of the children comparisons evaluates to true. The comparison <logic> with @op=\"not\" is satisfied if at least one of the children comparisons evaluates to false.  In addition, a special case applies at the first level. If a <test> element contains more than one comparison, there is an implicit <logic> with @op=\"and\" in effect. That is, the default behavior for <test> is that all child comparisons are required to be satisfied.    Example Listings of Mathematics Exercises  To illustrate examples using dynamic math objects and evaluation methods, listings for sample exercises are provided with the implemented versions appearing in .    <exercise xml:id=\"ex-demo-solve-equation\" label=\"ex-demo-solve-equation\"> <title>Solve an Equation<\/title> <statement> <p> Solve the equation <me><eval obj=\"theFunction\"\/>=0<\/me> to get the value of <m>x<\/m>. <\/p> <p><m>x = <\/m> <fillin width=\"5\" ansobj=\"theAnswer\"\/><\/p> <\/statement> <solution> <p> We want to isolate the <m>x<\/m> in the equation <m><eval obj=\"theFunction\"\/>=0<\/m>. Because addition of <m><eval obj=\"b\"\/><\/m> is the last operation, we apply the inverse by adding <m><eval obj=\"negB\"\/><\/m> to both sides. The new, but equivalent equation is now <m><eval obj=\"m\"\/>x = <eval obj=\"negB\"\/><\/m>. Dividing both sides of the equation by <m><eval obj=\"m\"\/><\/m>, we obtain the solution <m>x=<eval obj=\"theAnswer\"\/><\/m>. <\/p> <\/solution> <setup seed=\"12345\"> <de-object name=\"m\" context=\"number\"> <de-random distribution=\"discrete\" nonzero=\"yes\" min=\"-4\" max=\"5\" by=\"1\" \/> <\/de-object> <de-object name=\"b\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" \/> <\/de-object> <de-object name=\"negB\" context=\"number\"> <de-number>-b<\/de-number> <\/de-object> <de-object name=\"theFunction\" context=\"formula\"> <de-expression mode=\"formula\">m*x+b<\/de-expression> <\/de-object> <de-object name=\"theAnswer\" context=\"formula\"> <de-expression mode=\"formula\">-b\/m<\/de-expression> <\/de-object> <\/setup> <evaluation> <evaluate> <test correct=\"yes\"> <mathcmp use-answer=\"yes\" \/> <feedback>Correct!<\/feedback> <\/test> <test> <de-expression mode=\"formula\">{{b}}\/{{m}}<\/de-expression> <feedback>Check for a sign error while isolating <m>x<\/m>.<\/feedback> <\/test> <\/evaluate> <\/evaluation> <\/exercise>   XML defining .     <exercise xml:id=\"ex-find-derivatives\"> <title>Find the Derivatives<\/title> <statement> <p> Consider the function <m>f(x)=<eval obj=\"formula\"\/><\/m>. Find <m>f'(x)<\/m> and <m>f''(x)<\/m>. <\/p> <p> <m>f'(x) = <\/m> <fillin width=\"15\" ansobj=\"correctD1\" name=\"firstD\"\/> and <m>f''(x)=<\/m> <fillin width=\"15\" ansobj=\"correctD2\" name=\"secondD\"\/> <\/p> <\/statement> <solution> <p> The derivative of a constant is zero, so <m>\\frac{d}{dx}[<eval obj=\"b\"\/>]=0<\/m>. The term <m>x^{<eval obj=\"n\"\/>}<\/m> is a power, so the power rule gives us <m>\\frac{d}{dx}[x^<eval obj=\"n\"\/>]=<eval obj=\"n\"\/>x^{<eval obj=\"n\"\/>-1}<\/m>. Putting this together, we find <m>f'(x)=<eval obj=\"correctD1\"\/><\/m>. Applying the power rule a second time, we find <m>f''(x)=<eval obj=\"correctD2\"\/><\/m>. <\/p> <\/solution> <setup seed=\"1234\"> <de-object name=\"a\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"n\" context=\"number\"> <de-random distribution=\"discrete\" min=\"2\" max=\"5\"\/> <\/de-object> <de-object name=\"b\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"formula\" context=\"formula\"> <de-expression mode=\"formula\">a*x^n+b<\/de-expression> <\/de-object> <de-object name=\"correctD1\" context=\"formula\"> <de-expression mode=\"derivative\"> <formula><eval obj=\"formula\"\/><\/formula> <variable name=\"x\"\/> <\/de-expression> <\/de-object> <de-object name=\"correctD2\" context=\"formula\"> <de-expression mode=\"derivative\"> <formula><eval obj=\"correctD1\"\/><\/formula> <variable name=\"x\"\/> <\/de-expression> <\/de-object> <\/setup> <evaluation> <evaluate submit=\"firstD\"> <test correct=\"yes\"> <mathcmp use-answer=\"yes\"\/> <\/test> <test> <mathcmp obj=\"correctD2\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <\/evaluate> <evaluate submit=\"secondD\"> <test correct=\"yes\"> <mathcmp use-answer=\"yes\"\/> <\/test> <test> <eval obj=\"correctD1\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <\/exercise>   XML defining .     <exercise xml:id=\"ex-decompose-function\" label=\"ex-decompose-function\"> <title>Decompose the Function<\/title> <statement> <p> Consider the function <me>h(x)=<eval obj=\"composition\"\/><\/me>. Find two nontrivial functions <m>f(x)<\/m> and <m>g(x)<\/m> so that <m>h(x) = f(g(x))<\/m>. <\/p> <p> <m>f(x) = <\/m> <fillin width=\"15\" ansobj=\"outerFormula\" name=\"fGiven\"\/> and <m>g(x)=<\/m> <fillin width=\"15\" ansobj=\"innerFormula\" name=\"gGiven\"\/> <\/p> <\/statement> <solution> <p> Noticing that the expression <m><eval obj=\"innerFormula\"\/><\/m> appears inside parentheses with a power, it makes sense to think of that as the inner function, defining <m>g(x) = <eval obj=\"innerFormula\"\/><\/m>. The outer function describes what happens to that. If we imagined replacing the formula <m><eval obj=\"innerFormula\"\/><\/m> with a box and then call that box our variable <m>x<\/m>, we find the outer function is given by <m>f(x) = <eval obj=\"outerFormula\"\/><\/m>. <\/p> <p> This is not the only non-trivial composition. Can you find others? <\/p> <\/solution> <setup seed=\"4321\"> <de-object name=\"a\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"n\" context=\"number\"> <de-random distribution=\"discrete\" min=\"2\" max=\"5\" \/> <\/de-object> <de-object name=\"b\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"c\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"d\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"outerFormula\" context=\"formula\"> <de-expression mode=\"formula\">a*x^n+b<\/de-expression> <\/de-object> <de-object name=\"innerFormula\" context=\"formula\"> <de-expression mode=\"formula\">c*x+d<\/de-expression> <\/de-object> <de-object name=\"identityFunction\" context=\"formula\"> <de-expression mode=\"formula\">x<\/de-expression> <\/de-object> <de-object name=\"composition\" context=\"formula\"> <de-expression mode=\"substitution\"> <formula><eval obj=\"outerFormula\"\/><\/formula> <variable name=\"x\"><eval obj=\"innerFormula\"\/><\/variable> <\/de-expression> <\/de-object> <\/setup> <evaluation answers-coupled=\"yes\"> <evaluate name=\"fGiven\"> <test> <eval obj=\"identityFunction\"\/> <feedback><m>f(x)=x<\/m> is not allowed for nontrivial compositions.<\/feedback> <\/test> <test> <not> <mathcmp> <eval obj=\"composition\"\/> <de-expression context=\"formula\" mode=\"substitution\"> <formula><eval obj=\"fGiven\"\/><\/formula> <variable name=\"x\"><eval obj=\"gGiven\"\/><\/variable> <\/de-expression> <\/mathcmp> <\/not> <mathcmp> <eval obj=\"composition\"\/> <de-expression context=\"formula\" mode=\"substitution\"> <formula><eval obj=\"gGiven\"\/><\/formula> <variable name=\"x\"><eval obj=\"fGiven\"\/><\/variable> <\/de-expression> <\/mathcmp> <feedback>You have composed in the wrong order.<\/feedback> <\/test> <\/evaluate> <evaluate name=\"gGiven\"> <test> <eval obj=\"identityFunction\"\/> <feedback><m>g(x)=x<\/m> is not allowed for nontrivial compositions.<\/feedback> <\/test> <\/evaluate> <evaluate all=\"yes\"> <test correct=\"yes\"> <mathcmp> <eval obj=\"composition\"\/> <de-expression context=\"formula\" mode=\"substitution\"> <formula><eval obj=\"fGiven\"\/><\/formula> <variable name=\"x\"><eval obj=\"gGiven\"\/><\/variable> <\/de-expression> <\/mathcmp> <logic op=\"not\"> <mathcmp> <eval obj=\"fGiven\"\/> <eval obj=\"identityFunction\"\/> <\/mathcmp> <\/logic> <logic op=\"not\"> <mathcmp> <eval obj=\"gGiven\"\/> <eval obj=\"identityFunction\"\/> <\/mathcmp> <\/logic> <feedback>Excellent!<\/feedback> <\/test> <\/evaluate> <\/evaluation> <\/exercise>   XML defining .     Solve an Equation  Solve the equation to get the value of .            -b    m*x+b    -b\/m       Correct!    {{b}}\/{{m}}  Check for a sign error while isolating .     We want to isolate the in the equation . Because addition of is the last operation, we apply the inverse by adding to both sides. The new, but equivalent equation is now . Dividing both sides of the equation by , we obtain the solution .   Find the Derivatives  Consider the function . Find and .    and               a*x^n+b                      You confused which derivative is which.          You confused which derivative is which.   Incorrect. Try again.    The derivative of a constant is zero, so . The term is a power, so the power rule gives us . Putting this together, we find . Applying the power rule a second time, we find .   Decompose the Function  Consider the function . Find two nontrivial functions and so that .    and                     a*x^n+b    c*x+d    x             is not allowed for nontrivial compositions.                    You have composed in the wrong order.       is not allowed for nontrivial compositions.                         Excellent!     Noticing that the expression appears inside parentheses with a power, it makes sense to think of that as the inner function, defining . The outer function describes what happens to that. If we imagined replacing the formula with a box and then call that box our variable , we find the outer function is given by .  This is not the only non-trivial composition. Can you find others?    "
},
{
  "id": "list-mathcmp-expressions-structure",
  "level": "2",
  "url": "sec-dynamic-math.html#list-mathcmp-expressions-structure",
  "type": "Listing",
  "number": "2.4.1",
  "title": "",
  "body": "  <!-- Compare submitted response with fillin answer --> <mathcmp use-answer=\"yes\"\/> <!-- Compare submitted response with pre-computed object --> <mathcmp obj=\"objName\"\/> <!-- Compare submitted response with pre-computed object (alternate) --> <mathcmp> <eval obj=\"objName\"\/> <\/mathcmp <!-- Implicit mathcmp with submitted response (alternate) --> <eval obj=\"objName\"\/> <!-- Compare submitted response with newly generated object --> <mathcmp> <de-expression\/> <\/mathcmp> <!-- Implicit mathcmp with submitted response (alternate) --> <de-expression\/> <!-- Compare with newly generated object with pre-computed object --> <mathcmp> <de-expression\/> <eval obj=\"objName\"\/> <\/mathcmp> <!-- Compare two newly generated objects --> <mathcmp> <de-expression\/> <de-expression\/> <\/mathcmp>   Possible structures for using <mathcmp> within a <test> . The <de-expression> would be replaced by any valid construction as described for the <setup> .  "
},
{
  "id": "sec-dynamic-math-6-3",
  "level": "2",
  "url": "sec-dynamic-math.html#sec-dynamic-math-6-3",
  "type": "Listing",
  "number": "2.4.2",
  "title": "",
  "body": "  <exercise xml:id=\"ex-demo-solve-equation\" label=\"ex-demo-solve-equation\"> <title>Solve an Equation<\/title> <statement> <p> Solve the equation <me><eval obj=\"theFunction\"\/>=0<\/me> to get the value of <m>x<\/m>. <\/p> <p><m>x = <\/m> <fillin width=\"5\" ansobj=\"theAnswer\"\/><\/p> <\/statement> <solution> <p> We want to isolate the <m>x<\/m> in the equation <m><eval obj=\"theFunction\"\/>=0<\/m>. Because addition of <m><eval obj=\"b\"\/><\/m> is the last operation, we apply the inverse by adding <m><eval obj=\"negB\"\/><\/m> to both sides. The new, but equivalent equation is now <m><eval obj=\"m\"\/>x = <eval obj=\"negB\"\/><\/m>. Dividing both sides of the equation by <m><eval obj=\"m\"\/><\/m>, we obtain the solution <m>x=<eval obj=\"theAnswer\"\/><\/m>. <\/p> <\/solution> <setup seed=\"12345\"> <de-object name=\"m\" context=\"number\"> <de-random distribution=\"discrete\" nonzero=\"yes\" min=\"-4\" max=\"5\" by=\"1\" \/> <\/de-object> <de-object name=\"b\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" \/> <\/de-object> <de-object name=\"negB\" context=\"number\"> <de-number>-b<\/de-number> <\/de-object> <de-object name=\"theFunction\" context=\"formula\"> <de-expression mode=\"formula\">m*x+b<\/de-expression> <\/de-object> <de-object name=\"theAnswer\" context=\"formula\"> <de-expression mode=\"formula\">-b\/m<\/de-expression> <\/de-object> <\/setup> <evaluation> <evaluate> <test correct=\"yes\"> <mathcmp use-answer=\"yes\" \/> <feedback>Correct!<\/feedback> <\/test> <test> <de-expression mode=\"formula\">{{b}}\/{{m}}<\/de-expression> <feedback>Check for a sign error while isolating <m>x<\/m>.<\/feedback> <\/test> <\/evaluate> <\/evaluation> <\/exercise>   XML defining .  "
},
{
  "id": "sec-dynamic-math-6-4",
  "level": "2",
  "url": "sec-dynamic-math.html#sec-dynamic-math-6-4",
  "type": "Listing",
  "number": "2.4.3",
  "title": "",
  "body": "  <exercise xml:id=\"ex-find-derivatives\"> <title>Find the Derivatives<\/title> <statement> <p> Consider the function <m>f(x)=<eval obj=\"formula\"\/><\/m>. Find <m>f'(x)<\/m> and <m>f''(x)<\/m>. <\/p> <p> <m>f'(x) = <\/m> <fillin width=\"15\" ansobj=\"correctD1\" name=\"firstD\"\/> and <m>f''(x)=<\/m> <fillin width=\"15\" ansobj=\"correctD2\" name=\"secondD\"\/> <\/p> <\/statement> <solution> <p> The derivative of a constant is zero, so <m>\\frac{d}{dx}[<eval obj=\"b\"\/>]=0<\/m>. The term <m>x^{<eval obj=\"n\"\/>}<\/m> is a power, so the power rule gives us <m>\\frac{d}{dx}[x^<eval obj=\"n\"\/>]=<eval obj=\"n\"\/>x^{<eval obj=\"n\"\/>-1}<\/m>. Putting this together, we find <m>f'(x)=<eval obj=\"correctD1\"\/><\/m>. Applying the power rule a second time, we find <m>f''(x)=<eval obj=\"correctD2\"\/><\/m>. <\/p> <\/solution> <setup seed=\"1234\"> <de-object name=\"a\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"n\" context=\"number\"> <de-random distribution=\"discrete\" min=\"2\" max=\"5\"\/> <\/de-object> <de-object name=\"b\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" nonzero=\"yes\"\/> <\/de-object> <de-object name=\"formula\" context=\"formula\"> <de-expression mode=\"formula\">a*x^n+b<\/de-expression> <\/de-object> <de-object name=\"correctD1\" context=\"formula\"> <de-expression mode=\"derivative\"> <formula><eval obj=\"formula\"\/><\/formula> <variable name=\"x\"\/> <\/de-expression> <\/de-object> <de-object name=\"correctD2\" context=\"formula\"> <de-expression mode=\"derivative\"> <formula><eval obj=\"correctD1\"\/><\/formula> <variable name=\"x\"\/> <\/de-expression> <\/de-object> <\/setup> <evaluation> <evaluate submit=\"firstD\"> <test correct=\"yes\"> <mathcmp use-answer=\"yes\"\/> <\/test> <test> <mathcmp obj=\"correctD2\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <\/evaluate> <evaluate submit=\"secondD\"> <test correct=\"yes\"> <mathcmp use-answer=\"yes\"\/> <\/test> <test> <eval obj=\"correctD1\"\/> <feedback>You confused which derivative is which.<\/feedback> <\/test> <feedback>Incorrect. Try again.<\/feedback> <\/evaluate> <\/evaluation> <\/exercise>   XML defining .  "
},
{
  "id": "sec-dynamic-math-6-5",
  "level": "2",
  "url": "sec-dynamic-math.html#sec-dynamic-math-6-5",
  "type": "Listing",
  "number": "2.4.4",
  "title": "",
  "body": "  <exercise xml:id=\"ex-decompose-function\" label=\"ex-decompose-function\"> <title>Decompose the Function<\/title> <statement> <p> Consider the function <me>h(x)=<eval obj=\"composition\"\/><\/me>. Find two nontrivial functions <m>f(x)<\/m> and <m>g(x)<\/m> so that <m>h(x) = f(g(x))<\/m>. <\/p> <p> <m>f(x) = <\/m> <fillin width=\"15\" ansobj=\"outerFormula\" name=\"fGiven\"\/> and <m>g(x)=<\/m> <fillin width=\"15\" ansobj=\"innerFormula\" name=\"gGiven\"\/> <\/p> <\/statement> <solution> <p> Noticing that the expression <m><eval obj=\"innerFormula\"\/><\/m> appears inside parentheses with a power, it makes sense to think of that as the inner function, defining <m>g(x) = <eval obj=\"innerFormula\"\/><\/m>. The outer function describes what happens to that. If we imagined replacing the formula <m><eval obj=\"innerFormula\"\/><\/m> with a box and then call that box our variable <m>x<\/m>, we find the outer function is given by <m>f(x) = <eval obj=\"outerFormula\"\/><\/m>. <\/p> <p> This is not the only non-trivial composition. Can you find others? <\/p> <\/solution> <setup seed=\"4321\"> <de-object name=\"a\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"n\" context=\"number\"> <de-random distribution=\"discrete\" min=\"2\" max=\"5\" \/> <\/de-object> <de-object name=\"b\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"c\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-4\" max=\"5\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"d\" context=\"number\"> <de-random distribution=\"discrete\" min=\"-10\" max=\"10\" by=\"1\" nonzero=\"yes\" \/> <\/de-object> <de-object name=\"outerFormula\" context=\"formula\"> <de-expression mode=\"formula\">a*x^n+b<\/de-expression> <\/de-object> <de-object name=\"innerFormula\" context=\"formula\"> <de-expression mode=\"formula\">c*x+d<\/de-expression> <\/de-object> <de-object name=\"identityFunction\" context=\"formula\"> <de-expression mode=\"formula\">x<\/de-expression> <\/de-object> <de-object name=\"composition\" context=\"formula\"> <de-expression mode=\"substitution\"> <formula><eval obj=\"outerFormula\"\/><\/formula> <variable name=\"x\"><eval obj=\"innerFormula\"\/><\/variable> <\/de-expression> <\/de-object> <\/setup> <evaluation answers-coupled=\"yes\"> <evaluate name=\"fGiven\"> <test> <eval obj=\"identityFunction\"\/> <feedback><m>f(x)=x<\/m> is not allowed for nontrivial compositions.<\/feedback> <\/test> <test> <not> <mathcmp> <eval obj=\"composition\"\/> <de-expression context=\"formula\" mode=\"substitution\"> <formula><eval obj=\"fGiven\"\/><\/formula> <variable name=\"x\"><eval obj=\"gGiven\"\/><\/variable> <\/de-expression> <\/mathcmp> <\/not> <mathcmp> <eval obj=\"composition\"\/> <de-expression context=\"formula\" mode=\"substitution\"> <formula><eval obj=\"gGiven\"\/><\/formula> <variable name=\"x\"><eval obj=\"fGiven\"\/><\/variable> <\/de-expression> <\/mathcmp> <feedback>You have composed in the wrong order.<\/feedback> <\/test> <\/evaluate> <evaluate name=\"gGiven\"> <test> <eval obj=\"identityFunction\"\/> <feedback><m>g(x)=x<\/m> is not allowed for nontrivial compositions.<\/feedback> <\/test> <\/evaluate> <evaluate all=\"yes\"> <test correct=\"yes\"> <mathcmp> <eval obj=\"composition\"\/> <de-expression context=\"formula\" mode=\"substitution\"> <formula><eval obj=\"fGiven\"\/><\/formula> <variable name=\"x\"><eval obj=\"gGiven\"\/><\/variable> <\/de-expression> <\/mathcmp> <logic op=\"not\"> <mathcmp> <eval obj=\"fGiven\"\/> <eval obj=\"identityFunction\"\/> <\/mathcmp> <\/logic> <logic op=\"not\"> <mathcmp> <eval obj=\"gGiven\"\/> <eval obj=\"identityFunction\"\/> <\/mathcmp> <\/logic> <feedback>Excellent!<\/feedback> <\/test> <\/evaluate> <\/evaluation> <\/exercise>   XML defining .  "
},
{
  "id": "ex-demo-solve-equation",
  "level": "2",
  "url": "sec-dynamic-math.html#ex-demo-solve-equation",
  "type": "Exercise",
  "number": "2.4.5.1",
  "title": "Solve an Equation.",
  "body": "Solve an Equation  Solve the equation to get the value of .            -b    m*x+b    -b\/m       Correct!    {{b}}\/{{m}}  Check for a sign error while isolating .     We want to isolate the in the equation . Because addition of is the last operation, we apply the inverse by adding to both sides. The new, but equivalent equation is now . Dividing both sides of the equation by , we obtain the solution .  "
},
{
  "id": "ex-find-derivatives",
  "level": "2",
  "url": "sec-dynamic-math.html#ex-find-derivatives",
  "type": "Exercise",
  "number": "2.4.5.2",
  "title": "Find the Derivatives.",
  "body": "Find the Derivatives  Consider the function . Find and .    and               a*x^n+b                      You confused which derivative is which.          You confused which derivative is which.   Incorrect. Try again.    The derivative of a constant is zero, so . The term is a power, so the power rule gives us . Putting this together, we find . Applying the power rule a second time, we find .  "
},
{
  "id": "ex-decompose-function",
  "level": "2",
  "url": "sec-dynamic-math.html#ex-decompose-function",
  "type": "Exercise",
  "number": "2.4.5.3",
  "title": "Decompose the Function.",
  "body": "Decompose the Function  Consider the function . Find two nontrivial functions and so that .    and                     a*x^n+b    c*x+d    x             is not allowed for nontrivial compositions.                    You have composed in the wrong order.       is not allowed for nontrivial compositions.                         Excellent!     Noticing that the expression appears inside parentheses with a power, it makes sense to think of that as the inner function, defining . The outer function describes what happens to that. If we imagined replacing the formula with a box and then call that box our variable , we find the outer function is given by .  This is not the only non-trivial composition. Can you find others?  "
},
{
  "id": "meta_backmatter-2",
  "level": "1",
  "url": "meta_backmatter-2.html",
  "type": "Appendix",
  "number": "A",
  "title": "Selected Hints",
  "body": " Selected Hints  "
},
{
  "id": "meta_backmatter-3",
  "level": "1",
  "url": "meta_backmatter-3.html",
  "type": "Appendix",
  "number": "B",
  "title": "Selected Solutions",
  "body": " Selected Solutions  "
},
{
  "id": "meta_backmatter-4",
  "level": "1",
  "url": "meta_backmatter-4.html",
  "type": "Appendix",
  "number": "C",
  "title": "List of Symbols",
  "body": " List of Symbols   "
},
{
  "id": "meta_backmatter-5",
  "level": "1",
  "url": "meta_backmatter-5.html",
  "type": "Index",
  "number": "",
  "title": "Index",
  "body": " Index   "
},
{
  "id": "meta_backmatter-6",
  "level": "1",
  "url": "meta_backmatter-6.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": " This book was authored in PreTeXt .  "
}
]

var ptx_lunr_idx = lunr(function () {
  this.ref('id')
  this.field('title')
  this.field('body')
  this.metadataWhitelist = ['position']

  ptx_lunr_docs.forEach(function (doc) {
    this.add(doc)
  }, this)
})
