(self["webpackChunkWebComponents"] = self["webpackChunkWebComponents"] || []).push([["node_modules_moment_locale_sync_recursive_-runestone_activecode_js_acfactory_js-node_modules_-ef73b3"],{

/***/ 15664:
/*!**************************************************!*\
  !*** ./runestone/activecode/css/activecode.less ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 42786,
	"./af.js": 42786,
	"./ar": 30867,
	"./ar-dz": 14130,
	"./ar-dz.js": 14130,
	"./ar-kw": 96135,
	"./ar-kw.js": 96135,
	"./ar-ly": 56440,
	"./ar-ly.js": 56440,
	"./ar-ma": 47702,
	"./ar-ma.js": 47702,
	"./ar-sa": 16040,
	"./ar-sa.js": 16040,
	"./ar-tn": 37100,
	"./ar-tn.js": 37100,
	"./ar.js": 30867,
	"./az": 31083,
	"./az.js": 31083,
	"./be": 9808,
	"./be.js": 9808,
	"./bg": 68338,
	"./bg.js": 68338,
	"./bm": 67438,
	"./bm.js": 67438,
	"./bn": 8905,
	"./bn.js": 8905,
	"./bo": 11560,
	"./bo.js": 11560,
	"./br": 1278,
	"./br.js": 1278,
	"./bs": 80622,
	"./bs.js": 80622,
	"./ca": 2468,
	"./ca.js": 2468,
	"./cs": 5822,
	"./cs.js": 5822,
	"./cv": 50877,
	"./cv.js": 50877,
	"./cy": 47373,
	"./cy.js": 47373,
	"./da": 24780,
	"./da.js": 24780,
	"./de": 59740,
	"./de-at": 60217,
	"./de-at.js": 60217,
	"./de-ch": 60894,
	"./de-ch.js": 60894,
	"./de.js": 59740,
	"./dv": 5300,
	"./dv.js": 5300,
	"./el": 50837,
	"./el.js": 50837,
	"./en-au": 78348,
	"./en-au.js": 78348,
	"./en-ca": 77925,
	"./en-ca.js": 77925,
	"./en-gb": 22243,
	"./en-gb.js": 22243,
	"./en-ie": 46436,
	"./en-ie.js": 46436,
	"./en-nz": 76319,
	"./en-nz.js": 76319,
	"./eo": 92915,
	"./eo.js": 92915,
	"./es": 55655,
	"./es-do": 55251,
	"./es-do.js": 55251,
	"./es-us": 71146,
	"./es-us.js": 71146,
	"./es.js": 55655,
	"./et": 5603,
	"./et.js": 5603,
	"./eu": 77763,
	"./eu.js": 77763,
	"./fa": 76959,
	"./fa.js": 76959,
	"./fi": 11897,
	"./fi.js": 11897,
	"./fo": 94694,
	"./fo.js": 94694,
	"./fr": 94470,
	"./fr-ca": 63049,
	"./fr-ca.js": 63049,
	"./fr-ch": 52330,
	"./fr-ch.js": 52330,
	"./fr.js": 94470,
	"./fy": 5044,
	"./fy.js": 5044,
	"./gd": 2101,
	"./gd.js": 2101,
	"./gl": 38794,
	"./gl.js": 38794,
	"./gom-latn": 23168,
	"./gom-latn.js": 23168,
	"./gu": 95349,
	"./gu.js": 95349,
	"./he": 24206,
	"./he.js": 24206,
	"./hi": 30094,
	"./hi.js": 30094,
	"./hr": 30316,
	"./hr.js": 30316,
	"./hu": 22138,
	"./hu.js": 22138,
	"./hy-am": 11423,
	"./hy-am.js": 11423,
	"./id": 29218,
	"./id.js": 29218,
	"./is": 90135,
	"./is.js": 90135,
	"./it": 90626,
	"./it.js": 90626,
	"./ja": 39183,
	"./ja.js": 39183,
	"./jv": 24286,
	"./jv.js": 24286,
	"./ka": 40415,
	"./ka.js": 40415,
	"./kk": 47772,
	"./kk.js": 47772,
	"./km": 18758,
	"./km.js": 18758,
	"./kn": 79282,
	"./kn.js": 79282,
	"./ko": 33730,
	"./ko.js": 33730,
	"./ky": 33291,
	"./ky.js": 33291,
	"./lb": 36841,
	"./lb.js": 36841,
	"./lo": 55466,
	"./lo.js": 55466,
	"./lt": 57010,
	"./lt.js": 57010,
	"./lv": 37595,
	"./lv.js": 37595,
	"./me": 39861,
	"./me.js": 39861,
	"./mi": 35493,
	"./mi.js": 35493,
	"./mk": 95966,
	"./mk.js": 95966,
	"./ml": 87341,
	"./ml.js": 87341,
	"./mr": 10370,
	"./mr.js": 10370,
	"./ms": 9847,
	"./ms-my": 41237,
	"./ms-my.js": 41237,
	"./ms.js": 9847,
	"./mt": 72126,
	"./mt.js": 72126,
	"./my": 56165,
	"./my.js": 56165,
	"./nb": 64924,
	"./nb.js": 64924,
	"./ne": 16744,
	"./ne.js": 16744,
	"./nl": 93901,
	"./nl-be": 59814,
	"./nl-be.js": 59814,
	"./nl.js": 93901,
	"./nn": 83877,
	"./nn.js": 83877,
	"./pa-in": 15858,
	"./pa-in.js": 15858,
	"./pl": 64495,
	"./pl.js": 64495,
	"./pt": 89520,
	"./pt-br": 57971,
	"./pt-br.js": 57971,
	"./pt.js": 89520,
	"./ro": 96459,
	"./ro.js": 96459,
	"./ru": 21793,
	"./ru.js": 21793,
	"./sd": 40950,
	"./sd.js": 40950,
	"./se": 10490,
	"./se.js": 10490,
	"./si": 90124,
	"./si.js": 90124,
	"./sk": 64249,
	"./sk.js": 64249,
	"./sl": 14985,
	"./sl.js": 14985,
	"./sq": 51104,
	"./sq.js": 51104,
	"./sr": 49131,
	"./sr-cyrl": 13709,
	"./sr-cyrl.js": 13709,
	"./sr.js": 49131,
	"./ss": 85893,
	"./ss.js": 85893,
	"./sv": 98760,
	"./sv.js": 98760,
	"./sw": 91172,
	"./sw.js": 91172,
	"./ta": 27333,
	"./ta.js": 27333,
	"./te": 23110,
	"./te.js": 23110,
	"./tet": 52095,
	"./tet.js": 52095,
	"./th": 9041,
	"./th.js": 9041,
	"./tl-ph": 75768,
	"./tl-ph.js": 75768,
	"./tlh": 89444,
	"./tlh.js": 89444,
	"./tr": 72397,
	"./tr.js": 72397,
	"./tzl": 28254,
	"./tzl.js": 28254,
	"./tzm": 51106,
	"./tzm-latn": 30699,
	"./tzm-latn.js": 30699,
	"./tzm.js": 51106,
	"./uk": 67691,
	"./uk.js": 67691,
	"./ur": 13795,
	"./ur.js": 13795,
	"./uz": 6791,
	"./uz-latn": 60588,
	"./uz-latn.js": 60588,
	"./uz.js": 6791,
	"./vi": 65666,
	"./vi.js": 65666,
	"./x-pseudo": 14378,
	"./x-pseudo.js": 14378,
	"./yo": 75805,
	"./yo.js": 75805,
	"./zh-cn": 83839,
	"./zh-cn.js": 83839,
	"./zh-hk": 55726,
	"./zh-hk.js": 55726,
	"./zh-tw": 74152,
	"./zh-tw.js": 74152
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 86902:
/*!**********************************************!*\
  !*** ./runestone/activecode/js/acfactory.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ACFactory)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var _activecode_js_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activecode_js.js */ 40653);
/* harmony import */ var _activecode_html_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode_html.js */ 15033);
/* harmony import */ var _activecode_sql_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode_sql.js */ 23538);
/* harmony import */ var _livecode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./livecode.js */ 45425);
/* harmony import */ var _timed_activecode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./timed_activecode */ 12797);
/* harmony import */ var _common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/js/jquery.highlight.js */ 33194);
/* harmony import */ var _common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_6__);








class ACFactory {
    constructor() {
        this.foo = "bar";
    }
    static createActiveCode(orig, lang, addopts) {
        var opts = {
            orig: orig,
            useRunestoneServices: eBookConfig.useRunestoneServices,
            python3: eBookConfig.python3,
        };
        if (addopts) {
            for (var attrname in addopts) {
                opts[attrname] = addopts[attrname];
            }
        }
        if (lang === undefined) {
            lang = $(opts.orig).find("[data-lang]").data("lang");
        }
        if (opts.timed == true) {
            if (lang === "python") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedActiveCode(opts);
            } else if (
                lang === "java" ||
                lang === "cpp" ||
                lang === "c" ||
                lang === "python3"
            ) {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedLiveCode(opts);
            } else if (lang === "javascript") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedJSActiveCode(opts);
            } else if (lang === "htmlmixed") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedHTMLActiveCode(opts);
            } else if (lang === "sql") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedSQLActiveCode(opts);
            } else {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_5__.TimedActiveCode(opts);
            }
        } else {
            if (lang === "javascript") {
                return new _activecode_js_js__WEBPACK_IMPORTED_MODULE_1__["default"](opts);
            } else if (lang === "htmlmixed") {
                return new _activecode_html_js__WEBPACK_IMPORTED_MODULE_2__["default"](opts);
            } else if (lang === "sql") {
                return new _activecode_sql_js__WEBPACK_IMPORTED_MODULE_3__["default"](opts);
            } else if (
                ["java", "cpp", "c", "python3", "python2", "octave"].indexOf(
                    lang
                ) > -1
            ) {
                return new _livecode_js__WEBPACK_IMPORTED_MODULE_4__["default"](opts);
            } else {
                // default is python
                return new _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode(opts);
            }
        }
    }
    // used by web2py controller(s)
    static addActiveCodeToDiv(outerdivid, acdivid, sid, initialcode, language) {
        var thepre, newac;
        var acdiv = document.getElementById(acdivid);
        $(acdiv).empty();
        thepre = document.createElement("textarea");
        thepre["data-component"] = "activecode";
        thepre.id = outerdivid;
        $(thepre).data("lang", language);
        $(acdiv).append(thepre);
        var opts = {
            orig: thepre,
            useRunestoneServices: true,
        };
        var addopts = {
            sid: sid,
            graderactive: true,
        };
        newac = ACFactory.createActiveCode(thepre, language, addopts);
        var savediv = newac.divid;
        newac.divid = savediv;
        newac.editor.setSize(500, 300);
        setTimeout(function () {
            newac.editor.refresh();
        }, 500);
    }
    static createActiveCodeFromOpts(opts) {
        return ACFactory.createActiveCode(opts.orig, opts.lang, opts);
    }
    static createScratchActivecode() {
        /* set up the scratch Activecode editor in the search menu */
        // use the URL to assign a divid - each page should have a unique Activecode block id.
        // Remove everything from the URL but the course and page name
        // todo:  this could probably be eliminated and simply moved to the template file

        if (eBookConfig.enableScratchAC == false) return;

        var divid = eBookConfig.course + "_scratch_ac";
        divid = divid.replace(/[#.]/g, ""); // in case book title has characters that will mess up our selectors
        eBookConfig.scratchDiv = divid;
        let stdin = "";
        var lang = eBookConfig.acDefaultLanguage
            ? eBookConfig.acDefaultLanguage
            : "python";
        if (lang === "java" || lang === "cpp" || lang === "python3") {
            stdin = `data-stdin="text for stdin"`;
        }
        const languageNames = {
            'cpp': 'C++',
            'c': 'C',
            'html': 'HTML',
            'htmlmixed': 'HTML',
            'java': 'Java',
            'javascript': 'JavaScript',
            'js':'JavaScript',
            'octave': 'Octave',
            'python': 'Python',
            'py2':'Python 2',
            'python2': 'Python 2',
            'py3':'Python 3',
            'py3anaconda': 'Python 3 with Anaconda',
            'python3': 'Python 3',
            'ruby': 'Ruby',
            'sql': 'SQL',
            'ts': 'TypeScript'
        };

        // generate the HTML
        var html = `<div class="ptx-runestone-container"><div id="ac_modal_${divid}" class="modal fade">
              <div class="modal-dialog scratch-ac-modal">
                <div class="modal-content">
                  <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                    <h4 class="modal-title">Scratch ActiveCode (${languageNames[lang.toLowerCase()] || lang})</h4>
                  </div>
                  <div class="modal-body">
                  <div data-component="activecode" id=${divid}>
                  <div id=${divid}_question class="ac_question"><p>Use this area for writing code or taking notes.</p></div>
                  <textarea data-codelens="true" data-lang="${lang}" ${stdin}>
                  </textarea>
                  </div>
                  </div>
                </div>
              </div>
            </div>
            </div>`;
        var el = $(html);
        $("body").append(el);
        el.on("shown.bs.modal", function(){
            // default lang isn't in dictionary of known programming languages
            if (!languageNames[lang.toLowerCase()]) {
                alert(`${lang} is a known language. Please report this`)
            }
        });
        el.on("shown.bs.modal show.bs.modal", function () {
            el.find(".CodeMirror").each(function (i, e) {
                e.CodeMirror.refresh();
                e.CodeMirror.focus();
            });
        });
    }
    static toggleScratchActivecode() {
        if (!eBookConfig.enableScratchAC) return;
        var divid = "ac_modal_" + eBookConfig.scratchDiv;
        var div = $("#" + divid);
        $(`#${eBookConfig.scratchDiv}`).removeClass("ac_section");
        div.modal("toggle");
    }
}

//
// Page Initialization
//

$(document).on("runestone:login-complete", function () {
    ACFactory.createScratchActivecode();
    $("[data-component=activecode]").each(function () {
        if ($(this).closest("[data-component=timedAssessment]").length == 0) {
            // If this element exists within a timed component, don't render it here
            try {
                window.componentMap[this.id] = ACFactory.createActiveCode(
                    this,
                    $(this).find("textarea").data("lang")
                );
            } catch (err) {
                console.log(`Error rendering Activecode Problem ${this.id}
                Details: ${err}`);
            }
        }
    });
    // The componentMap can have any component, not all of them have a disableSaveLoad
    // method or an enableSaveLoad method.  So we need to check for that before calling it.
    if (loggedout) {
        for (let k in window.componentMap) {
            if (window.componentMap[k].disableSaveLoad) {
                window.componentMap[k].disableSaveLoad();
            }
        }
    } else {
        for (let k in window.componentMap) {
            if (window.componentMap[k].enableSaveLoad) {
                window.componentMap[k].enableSaveLoad();
            }
        }
    }
});

if (typeof window.component_factory === "undefined") {
    window.component_factory = {};
}

window.component_factory.activecode = ACFactory.createActiveCodeFromOpts;

// This is the easiest way to expose this outside the module.
window.ACFactory = ACFactory;

// This seems a bit hacky and possibly brittle, but its hard to know how long it will take to
// figure out the login/logout status of the user.  Sometimes its immediate, and sometimes its
// long.  So to be safe we'll do it both ways..
var loggedout;
$(document).on("runestone:logout", function () {
    loggedout = true;
});
$(document).on("runestone:logout", function () {
    for (let k in window.componentMap) {
        if (
            window.componentMap.hasOwnProperty(k) &&
            window.componentMap.attributes["data-component"] == "activecode"
        ) {
            window.componentMap[k].disableSaveLoad();
        }
    }
});


/***/ }),

/***/ 40053:
/*!*******************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.en.js ***!
  \*******************************************************/
/***/ (() => {

$.i18n().load({
    en: {
        msg_activecode_load_history: "Load History",
        msg_activecode_audio_tour: "Audio Tour",
        msg_activecode_loaded_code: "Loaded your saved code.",
        msg_activecode_no_saved_code: "No saved code.",
        msg_activecode_run_code: "Run",
        msg_activecode_show_feedback: "Show Feedback",
        msg_activecode_show_code: "Show Code",
        msg_activecode_hide_code: "Hide Code",
        msg_activecode_show_codelens: "Show CodeLens",
        msg_activecode_show_in_codelens: "Show in CodeLens",
        msg_activecode_hide_codelens: "Hide Codelens",
        msg_activecode_reformat: "Reformat",

        msg_activecode_parse_error:
            "A parse error means that Python does not understand the syntax on the line the error message points out. Common examples are forgetting commas beteween arguments or forgetting a : on a for statement",
        msg_activecode_parse_error_fix:
            "To fix a parse error you just need to look carefully at the line with the error and possibly the line before it.  Make sure it conforms to all of Python's rules.",
        msg_activecode_type_error:
            "Type errors most often occur when an expression tries to combine two objects with types that should not be combined.  Like raising a string to a power",
        msg_activecode_type_error_fix:
            "To fix a type error you will most likely need to trace through your code and make sure the variables have the types you expect them to have.  It may be helpful to print out each variable along the way to be sure its value is what you think it should be.",
        msg_activecode_name_error:
            "A name error almost always means that you have used a variable before it has a value.  Often this may be a simple typo, so check the spelling carefully.",
        msg_activecode_name_error_fix:
            "Check the right hand side of assignment statements and your function calls, this is the most likely place for a NameError to be found.",
        msg_activecode_value_error:
            "A ValueError most often occurs when you pass a parameter to a function and the function is expecting one type and you pass another.",
        msg_activecode_value_error_fix:
            "The error message gives you a pretty good hint about the name of the function as well as the value that is incorrect. Look at the error message closely and then trace back to the variable containing the problematic value.",
        msg_activecode_attribute_error:
            "This error message is telling you that the object on the left hand side of the dot, does not have the attribute or method on the right hand side.",
        msg_activecode_attribute_error_fix:
            "The most common variant of this message is that the object undefined does not have attribute X.  This tells you that the object on the left hand side of the dot is not what you think. Trace the variable back and print it out in various places until you discover where it becomes undefined.  Otherwise check the attribute on the right hand side of the dot for a typo.",
        msg_activecode_token_error:
            "Most of the time this error indicates that you have forgotten a right parenthesis or have forgotten to close a pair of quotes.",
        msg_activecode_token_error_fix:
            "Check each line of your program and make sure that your parenthesis are balanced.",
        msg_activecode_time_limit_error:
            "Your program is running too long.  Most programs in this book should run in less than 10 seconds easily. This probably indicates your program is in an infinite loop.",
        msg_activecode_time_limit_error_fix:
            "Add some print statements to figure out if your program is in an infinte loop.  If it is not you can increase the run time with sys.setExecutionLimit(msecs)",
        msg_activecode_general_error:
            "Your program is running for too long.  Most programs in this book should run in less than 30 seconds easily. This probably indicates your program is in an infinite loop.",
        msg_activecode_general_error_fix:
            "Add some print statements to figure out if your program is in an infinte loop.  If it is not you can increase the run time with sys.setExecutionLimit(msecs)",
        msg_activecode_syntax_error:
            "This message indicates that Python can't figure out the syntax of a particular statement.  Some examples are assigning to a literal, or a function call",
        msg_activecode_syntax_error_fix:
            "Check your assignment statements and make sure that the left hand side of the assignment is a variable, not a literal or a function.",
        msg_activecode_key_error:
            "This message indicates that you are trying to access an element of a dictionary, but the dictionary does not have that the key you are using.",
        msg_activecode_key_error_fix:
            "You may have a typo in the name of your key.  It is also good practice to check if the key exists using a statement like if key in mydict.  You can also use mydict.get(key,defaultvalue) so that if the key is not in the dictionary you get the default value instead of an error.",
        msg_activecode_index_error:
            "This message means that you are trying to index past the end of a string or a list.  For example if your list has 3 things in it and you try to access the item at position 3 or more.",
        msg_activecode_index_error_fix:
            "Remember that the first item in a list or string is at index position 0, quite often this message comes about because you are off by one.  Remember in a list of length 3 the last legal index is 2",
        msg_activecode_uri_error: "",
        msg_activecode_uri_error_fix: "",
        msg_activecode_import_error:
            "This error message indicates that you are trying to import a module that does not exist",
        msg_activecode_import_error_fix:
            "One problem may simply be that you have a typo.  It may also be that you are trying to import a module that exists in 'real' Python, but does not exist in this book.  If this is the case, please submit a feature request to have the module added.",
        msg_activecode_reference_error:
            "This is most likely an internal error, particularly if the message references the console.",
        msg_activecode_reference_error_fix:
            "Try refreshing the webpage, and if the error continues, submit a bug report along with your code",
        msg_activecode_zero_division_error:
            "This tells you that you are trying to divide by 0. Typically this is because the value of the variable in the denominator of a division expression has the value 0",
        msg_activecode_zero_division_error_fix:
            "You may need to protect against dividing by 0 with an if statment, or you may need to rexamine your assumptions about the legal values of variables, it could be an earlier statment that is unexpectedly assigning a value of zero to the variable in question.",
        msg_activecode_range_error:
            "This message almost always shows up in the form of Maximum call stack size exceeded.",
        msg_activecode_range_error_fix:
            "This always occurs when a function calls itself.  Its pretty likely that you are not doing this on purpose. Except in the chapter on recursion.  If you are in that chapter then its likely you haven't identified a good base case.",
        msg_activecode_internal_error:
            "An Internal error may mean that you've triggered a bug in our Python",
        msg_activecode_internal_error_fix:
            "Report this error, along with your code as a bug.",
        msg_activecode_indentation_error:
            "This error occurs when you have not indented your code properly.  This is most likely to happen as part of an if, for, while or def statement.",
        msg_activecode_indentation_error_fix:
            "Check your if, def, for, and while statements to be sure the lines are properly indented beneath them.  Another source of this error comes from copying and pasting code where you have accidentally left some bits of code lying around that don't belong there anymore.",
        msg_activecode_not_implemented_error:
            "This error occurs when you try to use a builtin function of Python that has not been implemented in this in-browser version of Python.",
        msg_activecode_not_implemented_error_fix:
            "For now the only way to fix this is to not use the function.  There may be workarounds.  If you really need this builtin function then file a bug report and tell us how you are trying to use the function.",

        msg_activecode_file_not_found: "File not found: '$1'",
        msg_activecode_no_file_or_dir:
            "[Errno 2] No such file or directory: '$1'",
        msg_activecode_starting: "Click the play button to begin the $1",
        msg_activecode_playing: "Playing the $1",
        msg_activecode_loading_audio:
            "Loading audio.  Please wait.   If the tour doesn't start soon click on the leftmost control button (Play first audio in tour)",
        msg_activecode_pause_current_audio: "Pause current audio",
        msg_activecode_pause_audio: "Pause audio",
        msg_activecode_play_paused_audio: "Play paused audio",
        msg_activecode_audio_paused:
            "The $1 has been paused. Click on the play button to resume the tour.",
        msg_activecode_input_prg: "Input for Program",
        msg_activecode_were_compiling_err:
            "There were errors compiling your code. See below.",
        msg_activecode_time_limit_exc: "Time Limit Exceeded on your program",
        msg_activecode_server_err: "A server error occurred",
        msg_activecode_compiling_running:
            "Compiling and Running your Code Now...",
        msg_activecode_server_comm_err: "Error communicating with the server.",
        msg_activecode_save_run: "Save & Run",
        msg_activecode_render: "Save & Render",
        msg_activecode_assertion_error:
            "An assertion error happens when python encounters an assertion statement.  Python evaluates the expression to the right of the word assert; if that expression is True everything is fine and the program continues.  If the expression is False Python raises an error and stops.",
        msg_activecode_assertion_error_fix:
            "Check the expression to the right of assert.  The expression is False and you will need to determine why that is.  You may want to simply print out the individual parts of the expression to understand why it is evaluating to False.",
        msg_activecode_load_db: "Loading DB...",
        msg_activecode_code_coach: "Code Coach",
    },
});


/***/ }),

/***/ 46108:
/*!**********************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.pt-br.js ***!
  \**********************************************************/
/***/ (() => {

$.i18n().load({
    "pt-br": {
        msg_activecode_load_history: "Carregar histórico",
        msg_activecode_audio_tour: "Tour de áudio",
        msg_activecode_loaded_code: "Código salvo carregado.",
        msg_activecode_no_saved_code: "Não há código salvo.",
        msg_activecode_run_code: "Executar",
        msg_activecode_show_feedback: "Exibir Feedbacks",
        msg_activecode_show_code: "Mostrar Código",
        msg_activecode_hide_code: "Ocultar Código",
        msg_activecode_show_codelens: "Mostrar CodeLens",
        msg_activecode_show_in_codelens: "Mostrar em CodeLens",
        msg_activecode_hide_codelens: "Ocultar Codelens",
        msg_activecode_reformat: "Reformatar",

        msg_activecode_parse_error:
            "Um erro de Parse significa que Python não entende a sintaxe da linha que a mensagem de erro aponta. Exemplos comuns são esquecer vírgulas entre argumentos ou esquecer ':' em um comando for.",
        msg_activecode_parse_error_fix:
            "Para corrigir um erro de Parse, você só precisa olhar cuidadosamente a linha com o erro e possivelmente a linha antes dela. Tenha certeza que estão de acordo com todas as regras de Python.",
        msg_activecode_type_error:
            "Erros de tipagem ocorrem mais frequentemente quando uma expressão tenta combinar dois objetos com tipos que não deveriam ser combinados. Como elevar uma String a uma potência.",
        msg_activecode_type_error_fix:
            "Para corrigir um erro de tipagem você provavelmente precisará percorrer seu código e ter certeza de que as variáveis possuem os tipos que você espera que elas tenham. Pode ser útil imprimir cada variável ao longo do caminho para checar se elas possuem o valor que você acha que deveriam ter.",
        msg_activecode_name_error:
            "Um erro de nome quase sempre significa que você usou uma variável antes dela ter um valor. Frequentemente isso pode ser um erro de digitação, então cheque a ortografia cuidadosamente.",
        msg_activecode_name_error_fix:
            "Cheque o lado direito das atribuições e suas chamadas de funções, são os lugares mais prováveis de encontrar um erro de nome.",
        msg_activecode_value_error:
            "Um erro de valor ocorre mais frequentemente quando uma função está esperando um tipo mas você passa um parâmetro de outro tipo.",
        msg_activecode_value_error_fix:
            "A mensagem de erro te dá uma boa dica sobre o nome da função e o valor incorreto. Leia atentamente a mensagem de erro e volte à variável que contém o valor problemático.",
        msg_activecode_attribute_error:
            "Essa mensagem de erro está te dizendo que o objeto do lado esquerdo do ponto não tem o atributo ou método do seu lado direito.",
        msg_activecode_attribute_error_fix:
            "A variante mais comum dessa mensagem é que o objeto indefinido não tem o atributo X. Isso diz que o objeto do lado esquerdo do ponto não é o que você pensa. Rastreie essa variável e imprima-a em vários lugares até descobrir onde ela se torna indefinida. Caso contrário, cheque se há erro de digitação no atributo do lado direito do ponto.",
        msg_activecode_token_error:
            "Na maioria das vezes este erro indica que você esqueceu de fechar um parênteses ou aspas.",
        msg_activecode_token_error_fix:
            "Cheque cada linha do seu programa e certifique-se de que todos os parênteses estão fechados.",
        msg_activecode_time_limit_error:
            "Seu programa está demorando muito. Os programas deste livro deveriam rodar em menos de 10 segundos. Isso provavelmente indica que seu programa está em um loop infinito.",
        msg_activecode_time_limit_error_fix:
            "Imprima mensagens em algumas linhas para descobrir se seu programa está em um loop infinito. Caso não esteja, você pode aumentar o tempo limite de execução com o comando sys.setExecutionLimit(ms)",
        msg_activecode_general_error:
            "Seu programa está demorando muito. Os programas deste livro deveriam rodar em menos de 30 segundos. Isso provavelmente indica que seu programa está em um loop infinito.",
        msg_activecode_general_error_fix:
            "Imprima mensagens em algumas linhas para descobrir se seu programa está em um loop infinito. Caso não esteja, você pode aumentar o tempo limite de execução com o comando sys.setExecutionLimit(ms)",
        msg_activecode_syntax_error:
            "Esta mensagem indica que Python não entendeu a sintaxe de um comando. Alguns exemplos são atribuição de um literal, ou uma chamada de função",
        msg_activecode_syntax_error_fix:
            "Cheque as atribuições de seu programa e certifique-se de que o lado esquerdo é uma variável, e não um literal ou função.",
        msg_activecode_key_error:
            "Esta mensagem indica que você está tentando acessar um elemento cuja chave não existe no dicionário.",
        msg_activecode_key_error_fix:
            "Você pode ter um erro de digitação no nome da sua chave. É uma boa prática checar se a chave existe usando um comando 'if (chave) in meu_dicionario'. Você também pode usar o comando 'meu_dicionario.get(chave, valorPadrão)' para obter o valor padrão ao invés de um erro caso a chave não exista.",
        msg_activecode_index_error:
            "Você está tentando acessar um índice além do final de uma string ou lista. Por exemplo, se sua lista possui 3 elementos nela e você tenta acessar o item na posição 3 ou mais.",
        msg_activecode_index_error_fix:
            "Lembre-se que o primeiro elemento de uma lista ou string está no índice 0, normalmente esta mensagem é exibida porque você errou o índice por 1. Em uma lista de tamanho 3, o último índice válido é 2",
        msg_activecode_uri_error: "",
        msg_activecode_uri_error_fix: "",
        msg_activecode_import_error:
            "Esta mensagem indica que você está tentando importar um módulo que não existe",
        msg_activecode_import_error_fix:
            "Um problema pode ser apenas um erro de digitação. Também pode ser que você está tentando importar um módulo que existe em Python 'real', mas não existe neste livro. Se este é o caso, por favor envie um pedido para ter esse módulo adicionado.",
        msg_activecode_reference_error:
            "Isso parece ser um erro interno, especialmente se a mensagem faz referência ao console.",
        msg_activecode_reference_error_fix:
            "Tente atualizar a página. Se o erro persistir, envie um relatório de bug junto com seu código",
        msg_activecode_zero_division_error:
            "Isso diz que você está tentando dividir por 0. Normalmente é porque o valor da variável no denominador de uma divisão tem o valor 0",
        msg_activecode_zero_division_error_fix:
            "Você pode proteger contra dividir por 0 com um comando 'if', ou você pode precisar reavaliar suas suposições sobre os valores das variáveis, pois um comando anterior pode ter inesperadamente atribuído o valor 0 a essa variável.",
        msg_activecode_range_error:
            "Esta mensagem quase sempre aparece na forma de 'Tamanho máximo da pilha de chamadas excedido'.",
        msg_activecode_range_error_fix:
            "Isso sempre ocorre quando uma função chama ela mesma. Provavelmente você não está fazendo isso de propósito, exceto no capítulo sobre recursão. Se você está nesse capítulo, então provavelmente ainda não identificou um bom caso base.",
        msg_activecode_internal_error:
            "Um erro interno pode significar que você desencadeou um bug no nosso Python",
        msg_activecode_internal_error_fix:
            "Reporte este erro como um bug, juntamente com seu código",
        msg_activecode_indentation_error:
            "Este erro ocorre quando você não indentou seu código devidamente. Isso é mais provável de ocorrer como parte de um comando if, for, while ou def.",
        msg_activecode_indentation_error_fix:
            "Cheque seus comandos if, def, for e while para ter certeza de que as linhas estão devidamente indentadas abaixo delas. Outra fonte deste erro é copiar e colar código em que você acidentalmente deixou restos de código que não pertencem mais ali.",
        msg_activecode_not_implemented_error:
            "Este erro ocorre quando você tenta usar uma função embutida de Python que não foi implementada nesta versão browser de Python.",
        msg_activecode_not_implemented_error_fix:
            "Por enquanto a única maneira de consertar isso é não usando a função. Podem haver soluções alternativas. Se você realmente precisa desta função embutida, envie-nos um relatório de bug e digac omo está tentando usar a função.",

        msg_activecode_file_not_found: "Arquivo não encontrado: '$1'",
        msg_activecode_no_file_or_dir:
            "[Erro nº 2] Arquivo ou diretório inexistente: '$1'",
        msg_activecode_starting: "Clique no botão de execução para começar $1",
        msg_activecode_playing: "Executando $1",
        msg_activecode_loading_audio:
            "Carregando áudio. Por favor, espere. Se o tour não começar logo, clique em 'Stop Tour' e tente novamente.",
        msg_activecode_pause_current_audio: "Pausar áudio atual",
        msg_activecode_pause_audio: "Pausar áudio",
        msg_activecode_play_paused_audio: "Reproduzir áudio pausado",
        msg_activecode_audio_paused:
            "$1 foi pausado. Clique no botão de execução para retomar o tour.",
        msg_activecode_input_prg: "Entrada para o programa",
        msg_activecode_were_compiling_err:
            "Houveram erros ao compilar seu código. Veja abaixo.",
        msg_activecode_time_limit_exc: "Limite de tempo excedido no seu programa",
        msg_activecode_server_err: "Um erro de servidor ocorreu",
        msg_activecode_compiling_running:
            "Compilando e executando seu código...",
        msg_activecode_server_comm_err: "Erro ao comunicar com o servidor.",
        msg_activecode_save_run: "Salvar & Executar",
        msg_activecode_render: "Salvar & Renderizar",
        msg_activecode_assertion_error:
            "Um erro de asserção ocorre quando python encontra um comando 'assert'. Python avalia a expressão do lado direito; se é verdadeira, o programa continua normalmente. Se é falsa, python gera um erro e para a execução." ,
        msg_activecode_assertion_error_fix:
            "Cheque a expressão do lado direito de 'assert'. Essa expressão é falsa e é preciso verificar o motivo. Você pode querer imprimir cada parte da expressão e entender porque é falsa.",
        msg_activecode_load_db: "Carregando banco de dados...",
    },
});


/***/ }),

/***/ 82510:
/*!************************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.sr-Cyrl.js ***!
  \************************************************************/
/***/ (() => {

$.i18n().load({
    "sr-Cyrl": {
        msg_activecode_load_history: "Учитај историју",
        msg_activecode_audio_tour: "Аудио тура",
        msg_activecode_loaded_code: "Ваш изворни код је учитан.",
        msg_activecode_no_saved_code: "Не постоји снимљен код.",
        msg_activecode_run_code: "Покрени програм",
        msg_activecode_show_feedback: "Прикажи резултат",
        msg_activecode_show_code: "Прикажи код",
        msg_activecode_hide_code: "Затвори код",
        msg_activecode_show_codelens: "Корак по корак",
        msg_activecode_show_in_codelens: "Корак по корак",
        msg_activecode_hide_codelens: "Затвори корак по корак",
        msg_activecode_reformat: "Реформат",

        msg_sctivecode_parse_error:
            "Синтаксна грешка (parse error) значи да Пајтон не разуме синтаксу у линији кога на коју порука о грешци указује. Типични примери овакве грешке су заборавлјена двотачка код 'if' или 'for' исказа или заборављена запета између аргумената код позива функције",
        msg_sctivecode_parse_error_fix:
            "Да бисте исправили синтаксну грешку треба пажњиво да погледате линију изворног кода на коју указује поруга о грешци и можда претходну линину изворног кода. Проверите да ли су поштована сва синтаксна правила Пајтона.",
    },
});


/***/ }),

/***/ 750:
/*!***********************************************!*\
  !*** ./runestone/activecode/js/activecode.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveCode: () => (/* binding */ ActiveCode)
/* harmony export */ });
/* harmony import */ var _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/js/runestonebase.js */ 2568);
/* harmony import */ var _audiotour_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audiotour.js */ 27350);
/* harmony import */ var _activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode-i18n.en.js */ 40053);
/* harmony import */ var _activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode-i18n.pt-br.js */ 46108);
/* harmony import */ var _activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activecode-i18n.sr-Cyrl.js */ 82510);
/* harmony import */ var _activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! codemirror */ 4631);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! codemirror/mode/python/python.js */ 5321);
/* harmony import */ var codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! codemirror/mode/css/css.js */ 36629);
/* harmony import */ var codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! codemirror/mode/htmlmixed/htmlmixed.js */ 16531);
/* harmony import */ var codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! codemirror/mode/xml/xml.js */ 29589);
/* harmony import */ var codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! codemirror/mode/javascript/javascript.js */ 96876);
/* harmony import */ var codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! codemirror/mode/sql/sql.js */ 54086);
/* harmony import */ var codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! codemirror/mode/clike/clike.js */ 99762);
/* harmony import */ var codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! codemirror/mode/octave/octave.js */ 15734);
/* harmony import */ var codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _css_activecode_less__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./../css/activecode.less */ 15664);
/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ 90464);
/* harmony import */ var codemirror_addon_hint_show_hint_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! codemirror/addon/hint/show-hint.js */ 71707);
/* harmony import */ var codemirror_addon_hint_show_hint_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_hint_show_hint_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var codemirror_addon_hint_show_hint_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! codemirror/addon/hint/show-hint.css */ 68129);
/* harmony import */ var codemirror_addon_hint_sql_hint_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! codemirror/addon/hint/sql-hint.js */ 3585);
/* harmony import */ var codemirror_addon_hint_sql_hint_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_hint_sql_hint_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var codemirror_addon_hint_anyword_hint_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! codemirror/addon/hint/anyword-hint.js */ 48991);
/* harmony import */ var codemirror_addon_hint_anyword_hint_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_hint_anyword_hint_js__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var codemirror_addon_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! codemirror/addon/edit/matchbrackets.js */ 4328);
/* harmony import */ var codemirror_addon_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _skulpt_min_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./skulpt.min.js */ 53098);
/* harmony import */ var _skulpt_min_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_skulpt_min_js__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./skulpt-stdlib.js */ 55409);
/* harmony import */ var _skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _coach_python_pyflakes_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./coach-python-pyflakes.js */ 56047);
/* harmony import */ var vega_embed__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! vega-embed */ 39119);
/**
 *
 * Created by bmiller on 3/19/15.
 */
/* Define global variables for ESLint */
/* global Sk */



























// Used by Skulpt.

// Adapt for use outside webpack -- see https://github.com/vega/vega-embed.
window.vegaEmbed = vega_embed__WEBPACK_IMPORTED_MODULE_24__["default"];

var isMouseDown = false;
var stopExecution = false;

document.onmousedown = function () {
    isMouseDown = true;
};

document.onmouseup = function () {
    isMouseDown = false;
};
window.componentMap = {};

var socket, connection, doc;
var chatcodesServer = "chat.codes";

(codemirror__WEBPACK_IMPORTED_MODULE_5___default().commands).autocomplete = function (cm) {
    cm.showHint({ hint: (codemirror__WEBPACK_IMPORTED_MODULE_5___default().hint).anyword });
};

// separate into constructor and init
class ActiveCode extends _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(opts) {
        super(opts);
        var suffStart;
        var orig = $(opts.orig).find("textarea")[0];
        this.containerDiv = opts.orig;
        this.useRunestoneServices = opts.useRunestoneServices;
        this.python3 = true;
        this.origElem = orig;
        this.origText = this.origElem.textContent;
        this.codeCoachList = []; //list of CodeCoaches that will be used to provide feedback
        this.divid = opts.orig.id;
        this.code = $(orig).text() || "\n\n\n\n\n";
        this.language = $(orig).data("lang");
        this.timelimit = $(orig).data("timelimit");
        this.includes = $(orig).data("include");
        this.hidecode = $(orig).data("hidecode");
        this.chatcodes = $(orig).data("chatcodes");
        this.hidehistory = $(orig).data("hidehistory");
        this.question = $(opts.orig).find(`#${this.divid}_question`)[0];
        this.tie = $(orig).data("tie");
        this.dburl = $(orig).data("dburl");
        this.runButton = null;
        this.enabledownload = $(orig).data("enabledownload");
        this.downloadButton = null;
        this.saveButton = null;
        this.loadButton = null;
        this.outerDiv = null;
        this.partner = "";
        this.runCount = 0;
        this.logResults = true;
        if (!eBookConfig.allow_pairs || $(orig).data("nopair")) {
            this.enablePartner = false;
        } else {
            this.enablePartner = true;
        }
        this.output = null; // create pre for output
        this.graphics = null; // create div for turtle graphics
        this.codecoach = null; // div for Code Coaches
        this.codelens = null;
        this.controlDiv = null;
        this.historyScrubber = null;
        this.timestamps = ["Original"];
        this.autorun = $(orig).data("autorun");
        this.outputLineCount = 0;
        if (this.chatcodes && eBookConfig.enable_chatcodes) {
            if (!socket) {
                socket = new WebSocket("wss://" + chatcodesServer);
            }
            if (!connection) {
                connection = new window.sharedb.Connection(socket);
            }
            if (!doc) {
                doc = connection.get("chatcodes", "channels");
            }
        }
        if (this.graderactive || this.isTimed) {
            this.hidecode = false;
        }
        if (this.includes) {
            this.includes = this.includes.split(/\s+/);
        }
        let prefixEnd = this.code.indexOf("^^^^");
        if (prefixEnd > -1) {
            this.prefix = this.code.substring(0, prefixEnd);
            this.code = this.code.substring(prefixEnd + 5);
        }
        suffStart = this.code.indexOf("====");
        if (suffStart > -1) {
            // The +5 gets past the ====\n
            this.suffix = this.code.substring(suffStart + 5);
            this.code = this.code.substring(0, suffStart);
        }
        this.history = [this.code];
        this.createEditor();
        this.createOutput();
        this.createControls();
        if ($(orig).data("caption")) {
            this.caption = $(orig).data("caption");
        } else {
            this.caption = "ActiveCode";
        }
        this.addCaption("runestone");

        //Setup CodeCoaches - add based on language
        if (this.language == "python" || this.language == "python3") {
            this.codeCoachList.push(new _coach_python_pyflakes_js__WEBPACK_IMPORTED_MODULE_23__["default"]());
        }

        setTimeout(
            function () {
                this.editor.refresh();
            }.bind(this),
            1000
        );
        if (this.autorun) {
            // Simulate pressing the run button, since this will also prevent the user from clicking it until the initial run is complete, and also help the user understand why they're waiting.
            $(this.runButtonHandler.bind(this));
        }
        this.indicate_component_ready();
        if (typeof Prism !== "undefined") {
            Prism.highlightAllUnder(this.containerDiv);
        }
    }

    createEditor(index) {
        this.outerDiv = document.createElement("div");
        var linkdiv = document.createElement("div");
        linkdiv.id = this.divid.replace(/_/g, "-").toLowerCase(); // :ref: changes _ to - so add this as a target
        var codeDiv = document.createElement("div");
        $(codeDiv).addClass("ac_code_div");
        this.codeDiv = codeDiv;
        this.outerDiv.lang = this.language;
        $(this.origElem).replaceWith(this.outerDiv);
        if (linkdiv.id !== this.divid) {
            // Don't want the 'extra' target if they match.
            this.outerDiv.appendChild(linkdiv);
        }
        this.outerDiv.appendChild(codeDiv);
        var edmode = this.outerDiv.lang;
        if (edmode === "sql") {
            edmode = "text/x-sql";
        } else if (edmode === "java") {
            edmode = "text/x-java";
        } else if (edmode === "cpp") {
            edmode = "text/x-c++src";
        } else if (edmode === "c") {
            edmode = "text/x-csrc";
        } else if (edmode === "python3") {
            edmode = "python";
        } else if (edmode === "octave" || edmode === "MATLAB") {
            edmode = "text/x-octave";
        }
        var editor = codemirror__WEBPACK_IMPORTED_MODULE_5___default()(codeDiv, {
            value: this.code,
            lineNumbers: true,
            mode: edmode,
            indentUnit: 4,
            matchBrackets: true,
            autoMatchParens: true,
            extraKeys: {
                Tab: "indentMore",
                "Shift-Tab": "indentLess",
                "Ctrl-Space": "autocomplete",
            },
        });
        // Make the editor resizable
        $(editor.getWrapperElement()).resizable({
            resize: function () {
                editor.setSize($(this).width(), $(this).height());
                editor.refresh();
            },
        });
        // give the user a visual cue that they have changed but not saved
        editor.on(
            "change",
            function (ev) {
                if (
                    editor.acEditEvent == false ||
                    editor.acEditEvent === undefined
                ) {
                    // change events can come before any real changes for various reasons, some unknown
                    // this avoids unneccsary log events and updates to the activity counter
                    // offsetParent === null means that the element is not on the screen and so can't change
                    // this.controlDiv.offsetParent
                    if (
                        this.origText === editor.getValue() ||
                        this.addingScrubber
                    ) {
                        console.log("Fake change event, skipping the log");
                        return;
                    }
                    $(editor.getWrapperElement()).css(
                        "border-top",
                        "2px solid #b43232"
                    );
                    $(editor.getWrapperElement()).css(
                        "border-bottom",
                        "2px solid #b43232"
                    );
                    this.isAnswered = true;
                    // the first time the student types in the write-code box
                    this.logBookEvent({
                        event: "activecode",
                        act: "edit",
                        div_id: this.divid,
                    });
                }
                editor.acEditEvent = true;
            }.bind(this)
        ); // use bind to preserve *this* inside the on handler.

        //Solving Keyboard Trap of ActiveCode: If user use tab for navigation outside of ActiveCode, then change tab behavior in ActiveCode to enable tab user to tab out of the textarea
        $(window).keydown(function (e) {
            var code = e.keyCode ? e.keyCode : e.which;
            if (code == 9 && $("textarea:focus").length === 0) {
                editor.setOption("extraKeys", {
                    Tab: function (cm) {
                        $(document.activeElement)
                            .closest(".tab-content")
                            .nextSibling.focus();
                    },
                    "Shift-Tab": function (cm) {
                        $(document.activeElement)
                            .closest(".tab-content")
                            .previousSibling.focus();
                    },
                });
            }
        });
        this.editor = editor;
        if (this.hidecode) {
            $(this.codeDiv).css("display", "none");
        }
    }

    async runButtonHandler() {
        // Disable the run button until the run is finished.
        this.runButton.disabled = true;
        try {
            await this.runProg();
        } catch (e) {
            console.log(`there was an error ${e} running the code`);
        }
        if (this.logResults) {
            this.logCurrentAnswer();
        }
        this.runCoaches();
        this.renderFeedback();
        // The run is finished; re-enable the button.
        this.runButton.disabled = false;
        this.runCount += 1;
        this.toggleAlert();
    }

    createControls() {
        var ctrlDiv = document.createElement("div");
        var butt;
        $(ctrlDiv).addClass("ac_actions");
        // Run
        butt = document.createElement("button");
        $(butt).text($.i18n("msg_activecode_run_code"));
        $(butt).addClass("btn btn-success run-button");
        ctrlDiv.appendChild(butt);
        this.runButton = butt;
        // console.log("adding click function for run");
        this.runButton.onclick = this.runButtonHandler.bind(this);
        $(butt).attr("type", "button");

        if (this.enabledownload || eBookConfig.downloadsEnabled) {
            this.addDownloadButton(ctrlDiv);
        }
        if (!this.hidecode && !this.hidehistory) {
            this.addHistoryScrubber(true);
        }
        if ($(this.origElem).data("gradebutton") && !this.graderactive) {
            this.addFeedbackButton(ctrlDiv);
        }
        // Show/Hide Code
        if (this.hidecode) {
            this.enableHideShow(ctrlDiv);
        }
        // CodeLens
        if ($(this.origElem).data("codelens") && !this.graderactive) {
            this.enableCodeLens(ctrlDiv);
        }

        // Code reformatting
        if (reformatable.has(this.language)) {
            this.enableReformat(ctrlDiv);
        }

        // Audio Tour
        if ($(this.origElem).data("audio")) {
            this.enableAudioTours(ctrlDiv);
        }
        if (eBookConfig.isInstructor) {
            this.enableInstructorSharing(ctrlDiv);
        }
        if (this.enablePartner) {
            this.setupPartner(ctrlDiv);
        }
        if (this.chatcodes && eBookConfig.enable_chatcodes) {
            this.enableChatCodes(ctrlDiv);
        }

        $(this.outerDiv).prepend(ctrlDiv);
        if (this.question) {
            if ($(this.question).html().match(/^\s+$/)) {
                $(this.question).remove();
            } else {
                $(this.outerDiv).prepend(this.question);
            }
        }
        this.controlDiv = ctrlDiv;
    }

    addFeedbackButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_feedback"));
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        this.gradeButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(this.createGradeSummary.bind(this));
    }

    addDownloadButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).text("Download");
        $(butt).addClass("btn save-button");
        ctrlDiv.appendChild(butt);
        this.downloadButton = butt;
        $(butt).click(this.downloadFile.bind(this, this.language));
        $(butt).attr("type", "button");
    }

    enableHideShow(ctrlDiv) {
        $(this.runButton).attr("disabled", "disabled");
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_code"));
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        this.showHideButt = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            function () {
                $(this.codeDiv).toggle();
                if (this.historyScrubber == null) {
                    this.addHistoryScrubber(true);
                } else {
                    $(this.historyScrubber.parentElement).toggle();
                }
                if (
                    $(this.showHideButt).text() ==
                    $.i18n("msg_activecode_show_code")
                ) {
                    $(this.showHideButt).text(
                        $.i18n("msg_activecode_hide_code")
                    );
                } else {
                    $(this.showHideButt).text(
                        $.i18n("msg_activecode_show_code")
                    );
                }
                if ($(this.runButton).attr("disabled")) {
                    $(this.runButton).removeAttr("disabled");
                } else {
                    $(this.runButton).attr("disabled", "disabled");
                }
            }.bind(this)
        );
    }

    enableCodeLens(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_codelens"));
        $(butt).css("margin-left", "10px");
        this.clButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(this.showCodelens.bind(this));
    }

    enableReformat(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_reformat"));
        $(butt).css("margin-left", "10px");
        this.reformatButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(this.reformat.bind(this));
    }

    enableAudioTours(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_audio_tour"));
        $(butt).css("margin-left", "10px");
        this.atButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            function () {
                new _audiotour_js__WEBPACK_IMPORTED_MODULE_1__["default"](
                    this.divid,
                    this.code,
                    1,
                    $(this.origElem).data("audio")
                );
            }.bind(this)
        );
    }

    enableInstructorSharing(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("btn btn-info");
        $(butt).text("Share Code");
        $(butt).css("margin-left", "10px");
        this.shareButt = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            async function () {
                if (
                    !confirm(
                        "You are about to share this code with ALL of your students.  Are you sure you want to continue?"
                    )
                ) {
                    return;
                }
                let data = {
                    divid: this.divid,
                    code: this.editor.getValue(),
                    lang: this.language,
                };
                let request = new Request(
                    eBookConfig.ajaxURL + "broadcast_code.json",
                    {
                        method: "POST",
                        headers: this.jsonHeaders,
                        body: JSON.stringify(data),
                    }
                );
                let post_promise = await fetch(request);
                if (!post_promise.ok) {
                    if (post_promise.status === 303 || post_promise.status === 404) {
                        alert("You must be logged in to share code");
                    } else {
                        alert("Sharing Failed return status: ${post_promise.status}");
                    }
                    return;
                }
                let status = await post_promise.json();
                if (status.mess === "success") {
                    alert(`Shared Code with ${status.share_count} students`);
                } else {
                    alert("Sharing Failed");
                }
            }.bind(this)
        );
    }

    setupPartner(ctrlDiv) {
        var checkPartner = document.createElement("input");
        checkPartner.type = "checkbox";
        checkPartner.id = `${this.divid}_part`;
        ctrlDiv.appendChild(checkPartner);
        var plabel = document.createElement("label");
        plabel.for = `${this.divid}_part`;
        $(plabel).text("Pair?");
        ctrlDiv.appendChild(plabel);
        $(checkPartner).click(
            function () {
                if (this.partner) {
                    this.partner = false;
                    $(partnerTextBox).hide();
                    this.partner = "";
                    partnerTextBox.value = "";
                    $(plabel).text("Pair?");
                } else {
                    let didAgree = localStorage.getItem("partnerAgree");
                    if (!didAgree) {
                        didAgree = confirm(
                            "Pair Programming should only be used with the consent of your instructor." +
                                "Your partner must be a registered member of the class and have agreed to pair with you." +
                                "By clicking OK you certify that both of these conditions have been met."
                        );
                        if (didAgree) {
                            localStorage.setItem("partnerAgree", "true");
                        } else {
                            return;
                        }
                    }
                    this.partner = true;
                    $(plabel).text("with: ");
                    $(partnerTextBox).show();
                }
            }.bind(this)
        );
        var partnerTextBox = document.createElement("input");
        partnerTextBox.type = "text";
        ctrlDiv.appendChild(partnerTextBox);
        $(partnerTextBox).hide();
        $(partnerTextBox).change(
            function () {
                this.partner = partnerTextBox.value;
            }.bind(this)
        );
    }

    // This is probably obsolete.  Not sure if anyone at Michigan will come back
    // to working on this again.
    enableChatCodes(ctrlDiv) {
        var chatBar = document.createElement("div");
        var channels = document.createElement("span");
        var topic = window.location.host + "-" + this.divid;
        ctrlDiv.appendChild(chatBar);
        $(chatBar).text("Chat: ");
        $(chatBar).append(channels);
        let butt = document.createElement("a");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text("Create Channel");
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        $(butt).attr("target", "_blank");
        $(butt).attr(
            "href",
            "http://" +
                chatcodesServer +
                "/new?" +
                $.param({
                    topic: window.location.host + "-" + this.divid,
                    code: this.editor.getValue(),
                    lang: "Python",
                })
        );
        this.chatButton = butt;
        chatBar.appendChild(butt);
        var updateChatCodesChannels = function () {
            var data = doc.data;
            var i = 1;
            $(channels).html("");
            data["channels"].forEach(function (channel) {
                if (!channel.archived && topic === channel.topic) {
                    var link = $("<a />");
                    var href =
                        "http://" + chatcodesServer + "/" + channel.channelName;
                    link.attr({
                        href: href,
                        target: "_blank",
                    });
                    link.text(" " + channel.channelName + "(" + i + ") ");
                    $(channels).append(link);
                    i++;
                }
            });
            if (i === 1) {
                $(channels).text("(no active converstations on this problem)");
            }
        };
        doc.subscribe(updateChatCodesChannels);
        doc.on("op", updateChatCodesChannels);
    }

    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_save_run"));
    }

    // _`addHistoryScrubber`
    // ---------------------
    // Activecode -- If the code has not changed wrt the scrubber position value then don't save the code or reposition the scrubber
    //  -- still call runlog, but add a parameter to not save the code
    // add an initial load history button
    // if there is no edit then there is no append   to_save (True/False)
    async addHistoryScrubber(pos_last) {
        this.addingScrubber = true;
        let response;
        var reqData = {
            acid: this.divid,
        };
        if (this.sid !== undefined) {
            reqData["sid"] = this.sid;
        }
        console.log("before get hist");
        if (
            eBookConfig.practice_mode ||
            !eBookConfig.isLoggedIn ||
            (this.isTimed && !this.assessmentTaken)
        ) {
            // If this is timed and already taken we should restore history info
            this.renderScrubber();
        } else {
            let request = new Request(
                `${eBookConfig.new_server_prefix}/assessment/gethist`,
                {
                    method: "POST",
                    headers: this.jsonHeaders,
                    body: JSON.stringify(reqData),
                }
            );
            try {
                response = await fetch(request);
                let data = await response.json();
                if (!response.ok) {
                    throw new Error(
                        `Failed to get the history data: ${data.detail}`
                    );
                }
                data = data.detail;
                if (data.history !== undefined) {
                    this.history = this.history.concat(data.history);
                    for (let t in data.timestamps) {
                        this.timestamps.push(
                            new Date(data.timestamps[t]).toLocaleString()
                        );
                    }
                }
            } catch (e) {
                console.log(`unable to fetch history: ${e}`);
            }
            this.renderScrubber(pos_last);
        }
        this.addingScrubber = false;
        return "success";
    }

    renderScrubber(pos_last) {
        console.log("making a new scrubber");
        var scrubberDiv = document.createElement("div");
        $(scrubberDiv).css("display", "inline-block");
        $(scrubberDiv).css("margin-left", "10px");
        $(scrubberDiv).css("margin-right", "10px");
        $(scrubberDiv).css({
            "min-width": "200px",
            "max-width": "300px",
        });
        var scrubber = document.createElement("div");
        this.timestampP = document.createElement("span");
        this.slideit = function (ev, el) {
            this.editor.setValue(this.history[$(scrubber).slider("value")]);
            var curVal = this.timestamps[$(scrubber).slider("value")];
            let pos = $(scrubber).slider("value");
            let outOf = this.history.length;
            $(this.timestampP).text(`${curVal} - ${pos + 1} of ${outOf}`);
            // a slide will also result in a slidechange event we don't want to double
            // log these events.  So do not log the slide until it stops and creates the changed
            if (ev !== null && ev.type != "slide") {
                this.logBookEvent({
                    event: "activecode",
                    act: "slide:" + curVal,
                    div_id: this.divid,
                });
            }
        };
        $(scrubber).slider({
            max: this.history.length - 1,
            value: this.history.length - 1,
        });
        $(scrubber).css("margin", "10px");
        $(scrubber).on("slide", this.slideit.bind(this));
        $(scrubber).on("slidechange", this.slideit.bind(this));
        scrubberDiv.appendChild(scrubber);
        scrubberDiv.appendChild(this.timestampP);
        // If there is a deadline set then position the scrubber at the last submission
        // prior to the deadline
        if (this.deadline) {
            let i = 0;
            let done = false;
            while (i < this.history.length && !done) {
                if (new Date(this.timestamps[i]) > this.deadline) {
                    done = true;
                } else {
                    i += 1;
                }
            }
            i = i - 1;
            scrubber.value = Math.max(i, 0);
            this.editor.setValue(this.history[scrubber.value]);
            $(scrubber).slider("value", scrubber.value);
        } else if (pos_last) {
            scrubber.value = this.history.length - 1;
            this.editor.setValue(this.history[scrubber.value]);
        } else {
            scrubber.value = 0;
        }
        let pos = $(scrubber).slider("value");
        let outOf = this.history.length;
        let ts = this.timestamps[$(scrubber).slider("value")];
        $(this.timestampP).text(`${ts} - ${pos + 1} of ${outOf}`);
        this.historyScrubber = scrubber;
        $(scrubberDiv).insertAfter(this.runButton);
    } // end definition of helper

    createOutput() {
        // Create a parent div with two elements:  pre for standard output and a div
        // to hold turtle graphics output.  We use a div in case the turtle changes from
        // using a canvas to using some other element like svg in the future.
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output");
        this.outDiv = outDiv;
        this.output = document.createElement("pre");
        this.output.id = this.divid + "_stdout";
        $(this.output).css("visibility", "hidden");
        $(this.output).css("max-height", "400px");
        $(this.output).css("overflow", "auto");
        this.graphics = document.createElement("div");
        this.graphics.id = this.divid + "_graphics";
        $(this.graphics).addClass("ac-canvas");
        // This bit of magic adds an event which waits for a canvas child to be created on our
        // newly created div.  When a canvas child is added we add a new class so that the visible
        // canvas can be styled in CSS.  Which a the moment means just adding a border.
        $(this.graphics).on(
            "DOMNodeInserted",
            "canvas",
            function () {
                $(this.graphics).addClass("visible-ac-canvas");
            }.bind(this)
        );

        var coachDiv = document.createElement("div");
        coachDiv.classList.add("alert", "alert-warning", "codecoach");
        $(coachDiv).css("display", "none");
        let coachHead = coachDiv.appendChild(document.createElement("h3"));
        coachHead.textContent = $.i18n("msg_activecode_code_coach");
        this.outerDiv.appendChild(coachDiv);
        this.codecoach = coachDiv;

        outDiv.appendChild(this.output);
        outDiv.appendChild(this.graphics);
        this.outerDiv.appendChild(outDiv);
        var lensDiv = document.createElement("div");
        lensDiv.classList.add("codelens");
        lensDiv.id = `${this.divid}_codelens`;
        $(lensDiv).css("display", "none");
        this.codelens = lensDiv;
        this.outerDiv.appendChild(lensDiv);
    }

    disableSaveLoad() {
        $(this.saveButton).addClass("disabled");
        $(this.saveButton).attr("title", "Login to save your code");
        $(this.loadButton).addClass("disabled");
        $(this.loadButton).attr("title", "Login to load your code");
    }

    downloadFile(lang) {
        var fnb = this.divid;
        var d = new Date();
        var fileName =
            fnb +
            "_" +
            d
                .toJSON()
                .substring(0, 10) // reverse date format
                .split("-")
                .join("") +
            "." +
            languageExtensions[lang];
        var code = this.editor.getValue();
        if ("Blob" in window) {
            var textToWrite = code.replace(/\n/g, "\r\n");
            var textFileAsBlob = new Blob([textToWrite], {
                type: "text/plain",
            });
            if ("msSaveOrOpenBlob" in navigator) {
                navigator.msSaveOrOpenBlob(textFileAsBlob, fileName);
            } else {
                var downloadLink = document.createElement("a");
                downloadLink.download = fileName;
                downloadLink.innerHTML = "Download File";
                downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
                downloadLink.click();
            }
        } else {
            alert("Your browser does not support the HTML5 Blob.");
        }
    }

    async createGradeSummary() {
        // get grade and comments for this assignment
        // get summary of all grades for this student
        // display grades in modal window
        var data = {
            div_id: this.divid,
        };
        let request = new Request(eBookConfig.ajaxURL + "getassignmentgrade", {
            method: "POST",
            headers: this.jsonHeaders,
            body: JSON.stringify(data),
        });
        let response = await fetch(request);
        let report = await response.json();
        var body;
        // check for report['message']
        if (report) {
            if (report["version"] == 2) {
                // new version; would be better to embed this in HTML for the activecode
                body =
                    "<h4>Grade Report</h4>" +
                    "<p>This question: " +
                    report["grade"];
                if (report["released"]) {
                    body += " out of " + report["max"];
                }
                body += "</p> <p>";
                if (report["released"] == false) {
                    body += "Preliminary Comments: ";
                }
                body += report["comment"] + "</p>";
            } else {
                body =
                    "<h4>Grade Report</h4>" +
                    "<p>This assignment: " +
                    report["grade"] +
                    "</p>" +
                    "<p>" +
                    report["comment"] +
                    "</p>" +
                    "<p>Number of graded assignments: " +
                    report["count"] +
                    "</p>" +
                    "<p>Average score: " +
                    report["avg"] +
                    "</p>";
            }
        } else {
            body = "<h4>The server did not return any grade information</h4>";
        }
        var html = `<div class="modal fade">
                  <div class="modal-dialog compare-modal">
                    <div class="modal-content">
                      <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                        <h4 class="modal-title">Assignment Feedback</h4>
                      </div>
                      <div class="modal-body">
                        ${body}
                      </div>
                    </div>
                  </div>
                </div>`;
        var el = $(html);
        el.modal();

        return response;
    }

    async showCodelens() {
        if (this.codelens.style.display == "none") {
            this.codelens.style.display = "block";
            this.clButton.innerText = $.i18n("msg_activecode_hide_codelens");
        } else {
            this.codelens.style.display = "none";
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
            return;
        }
        var cl = this.codelens.firstChild;
        if (cl) {
            this.codelens.removeChild(cl);
        }
        var code = await this.buildProg(false);
        var myVars = {};
        myVars.code = code;
        myVars.origin = "opt-frontend.js";
        myVars.cumulative = false;
        myVars.heapPrimitives = false;
        myVars.drawParentPointers = false;
        myVars.textReferences = false;
        myVars.showOnlyOutputs = false;
        myVars.rawInputLstJSON = JSON.stringify([]);
        if (this.language == "python") {
            if (this.python3) {
                myVars.py = 3;
            } else {
                myVars.py = 2;
            }
        } else if (this.langauge == "javascript") {
            myVars.py = "js";
        } else {
            myVars.py = this.language;
        }
        myVars.curInstr = 0;
        myVars.codeDivWidth = 350;
        myVars.codeDivHeight = 400;
        var srcURL = "https://pythontutor.com/iframe-embed.html";
        var srcVars = $.param(myVars);
        var embedUrlStr = `${srcURL}#${srcVars}`;
        var myIframe = document.createElement("iframe");
        myIframe.setAttribute("id", this.divid + "_codelens");
        myIframe.setAttribute("width", "100%");
        myIframe.setAttribute("height", "500");
        myIframe.setAttribute("style", "display:block");
        myIframe.style.background = "#fff";
        //myIframe.setAttribute("src",srcURL)
        myIframe.src = embedUrlStr;
        this.codelens.appendChild(myIframe);
        this.logBookEvent({
            event: "codelens",
            act: "view",
            div_id: this.divid,
        });
    }

    reformat() {
        const first = this.editor.firstLine();
        const last = this.editor.lastLine();
        for (let i = first; i <= last; i++) {
            this.editor.indentLine(i);
        }
        this.reformatButton.blur();
    }

    toggleEditorVisibility() {}

    addErrorMessage(err) {
        // Add the error message
        this.errLastRun = true;
        var errHead = $("<h3>").html("Error");
        this.eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.eContainer.className = "error alert alert-danger";
        this.eContainer.id = this.divid + "_errinfo";
        this.eContainer.appendChild(errHead[0]);
        var errText = this.eContainer.appendChild(
            document.createElement("pre")
        );
        // But, adjust the line numbers.  If the line number is <= pretextLines then it is in included code
        // if it is greater than the number of included lines but less than the pretext + current editor then it is in the student code.
        // adjust the line number we display by eliminating the pre-included code.
        if (err.traceback && err.traceback.length >= 1) {
            var errorLine = err.traceback[0].lineno;
            if (errorLine <= this.pretextLines) {
                errText.innerHTML =
                    "An error occurred in the hidden, included code. Sorry we can't give you a more helpful error message";
                return;
            } else if (errorLine > this.progLines + this.pretextLines) {
                errText.innerHTML = `An error occurred after the end of your code.
One possible reason is that you have an unclosed parenthesis or string.
Another possibility is that there is an error in the hidden test code.
Yet another is that there is an internal error.  The internal error message is: ${err.message}`;
                return;
            } else {
                if (this.pretextLines > 0) {
                    err.traceback[0].lineno =
                        err.traceback[0].lineno - this.pretextLines + 1;
                }
            }
        }
        var errString = err.toString();
        var to = errString.indexOf(":");
        var errName = errString.substring(0, to);
        errText.innerHTML = errString;
        $(this.eContainer).append("<h3>Description</h3>");
        var errDesc = this.eContainer.appendChild(document.createElement("p"));
        errDesc.innerHTML = errorText[errName];
        $(this.eContainer).append("<h3>To Fix</h3>");
        var errFix = this.eContainer.appendChild(document.createElement("p"));
        errFix.innerHTML = errorText[errName + "Fix"];
        var moreInfo = "../ErrorHelp/" + errName.toLowerCase() + ".html";
        //console.log("Runtime Error: " + err.toString());
    }
    setTimeLimit(timer) {
        var timelimit = this.timelimit;
        if (timer !== undefined) {
            timelimit = timer;
        }
        // set execLimit in milliseconds  -- for student projects set this to
        // 25 seconds -- just less than Chrome's own timer.
        if (
            this.code.indexOf("ontimer") > -1 ||
            this.code.indexOf("onclick") > -1 ||
            this.code.indexOf("onkey") > -1 ||
            this.code.indexOf("setDelay") > -1
        ) {
            Sk.execLimit = null;
        } else {
            if (timelimit === "off") {
                Sk.execLimit = null;
            } else if (timelimit) {
                Sk.execLimit = timelimit;
            } else {
                Sk.execLimit = 25000;
            }
        }
    }
    builtinRead(x) {
        if (
            Sk.builtinFiles === undefined ||
            Sk.builtinFiles["files"][x] === undefined
        )
            throw $.i18n("msg_activecode_file_not_found", x);
        return Sk.builtinFiles["files"][x];
    }
    fileReader(divid) {
        // In the beginning files were just pre tags and we used the divid as the filename
        let elem = document.getElementById(divid);
        // In PreTeXt we moved that to a @data-filename
        if (elem === null) {
            elem = document.querySelector(`[data-filename="${divid}"]`);
        }
        let data = "";
        let result = "";
        if (elem == null && Sk.builtinFiles.files.hasOwnProperty(divid)) {
            return Sk.builtinFiles["files"][divid];
        } else {
            // try remote file unless it ends with .js or .py -- otherwise we'll ask the server for all
            // kinds of modules that we are trying to import
            if (!(divid.endsWith(".js") || divid.endsWith(".py"))) {
                $.ajax({
                    async: false,
                    url: `/runestone/ajax/get_datafile?course_id=${eBookConfig.course}&acid=${divid}`,
                    success: function (data) {
                        result = JSON.parse(data).data;
                    },
                    error: function (err) {
                        result = null;
                    },
                });
                if (result) {
                    return result;
                }
            }
        }
        if (elem == null && result === null) {
            throw new Sk.builtin.IOError(
                $.i18n("msg_activecode_no_file_or_dir", divid)
            );
        } else {
            // for backward compatibility - early on we had textarea with the divid on it.
            // but later this switched to a runestone wrapper.  So we may need to dig for a pre
            // or a textarea?
            if (elem.nodeName.toLowerCase() == "textarea") {
                data = elem.value;
            } else {
                let pre = elem.querySelector("pre");
                if (pre) {
                    data = pre.textContent;
                } else {
                    data = elem.textContent;
                }
            }
        }
        return data;
    }
    outputfun(text) {
        // bnm python 3
        if (this.outputLineCount > 1000) return;
        $(this.output).css("visibility", "visible");
        text = text
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\n/g, "<br/>");
        // todo: try to make this use the suspension mechanism in skulpt
        return new Sk.misceval.promiseToSuspension(
            new Promise(
                function (resolve) {
                    setTimeout(
                        function () {
                            if (this.outputLineCount < 1000) {
                                $(this.output).append(text);
                                this.outputLineCount += 1;
                                resolve(Sk.builtin.none.none$);
                            } else {
                                if (this.outputLineCount == 1000) {
                                    $(this.output).append("Too Much output");
                                    this.outputLineCount += 1;
                                    stopExecution = true;
                                    resolve(Sk.builtin.none.none$);
                                }
                            }
                        }.bind(this),
                        1
                    );
                }.bind(this)
            )
        );
    }

    filewriter(fobj, bytes) {
        let filecomponent = document.getElementById(fobj.name);
        if (!filecomponent) {
            let container = document.createElement("div");
            $(container).addClass("runestone");
            let tab = document.createElement("div");
            $(tab).addClass("datafile_caption");
            tab.innerHTML = `Data file: <code>${fobj.name}</code>`;
            filecomponent = document.createElement("textarea");
            filecomponent.rows = 10;
            filecomponent.cols = 50;
            filecomponent.id = fobj.name;
            $(filecomponent).css("margin-bottom", "5px");
            $(filecomponent).addClass("ac_output");
            container.appendChild(tab);
            container.appendChild(filecomponent);
            this.outerDiv.appendChild(container);
        } else {
            if (fobj.pos$ == 0) {
                $(filecomponent).val("");
            }
        }
        let current = $(filecomponent).val();
        current = current + bytes.v;
        $(filecomponent).val(current);
        $(filecomponent).css("display", "block");
        fobj.pos$ = current.length;
        return current.length;
    }

    async getIncludedCode(divid) {
        if (window.componentMap[divid]) {
            return window.componentMap[divid].editor.getValue();
        } else {
            let request = new Request(
                `/runestone/ajax/get_datafile?course_id=${eBookConfig.course}&acid=${divid}`,
                {
                    method: "GET",
                    headers: this.jsonHeaders,
                }
            );
            let wresult = await fetch(request);
            let obj = await wresult.json();
            return obj.data;
        }
    }

    async buildProg(useSuffix) {
        // assemble code from prefix, suffix, and editor for running.
        var pretext;
        var prog = this.editor.getValue() + "\n";
        if (this.prefix) {
            prog = this.prefix + prog;
        }
        this.pretext = "";
        this.pretextLines = 0;
        this.progLines = prog.match(/\n/g).length + 1;
        if (this.includes) {
            // iterate over the includes, in-order prepending to prog
            pretext = "";
            for (var x = 0; x < this.includes.length; x++) {
                let iCode = await this.getIncludedCode(this.includes[x]);
                pretext = pretext + iCode + "\n";
            }
            this.pretext = pretext;
            if (this.pretext) {
                this.pretextLines = (this.pretext.match(/\n/g) || "").length;
            }
            prog = pretext + prog;
        }
        if (useSuffix && this.suffix) {
            prog = prog + this.suffix;
        }
        return Promise.resolve(prog);
    }

    async manage_scrubber(saveCode) {
        if (this.historyScrubber === null && !this.autorun) {
            await this.addHistoryScrubber();
        }
        if (
            this.historyScrubber &&
            this.history[$(this.historyScrubber).slider("value")] !=
                this.editor.getValue()
        ) {
            saveCode = "True";
            this.history.push(this.editor.getValue());
            this.timestamps.push(new Date().toLocaleString());
            $(this.historyScrubber).slider(
                "option",
                "max",
                this.history.length - 1
            );
            $(this.historyScrubber).slider(
                "option",
                "value",
                this.history.length - 1
            );
            this.slideit(null);
        } else {
            saveCode = "False";
        }
        if (this.historyScrubber == null) {
            saveCode = "False";
        }
        return saveCode;
    }

    async checkCurrentAnswer() {
        try {
            await this.runProg();
        } catch (e) {
            console.log(`error running code ${e}`);
        }
    }

    // the sid parameter is optional and is used for group submissions
    async logCurrentAnswer(sid) {
        let data = {
            div_id: this.divid,
            code: this.editor.getValue(),
            language: this.language,
            errinfo: this.errinfo || "",
            to_save: this.saveCode || "F",
            prefix: this.pretext,
            suffix: this.suffix,
            partner: this.partner,
        }; // Log the run event
        if (typeof sid !== "undefined") {
            data.sid = sid;
        }
        await this.logRunEvent(data);
        // If unit tests were run there will be a unit_results
        if (this.unit_results) {
            let unitData = {
                act: this.unit_results,
                div_id: this.divid,
                event: "unittest",
            };
            if (typeof sid !== "undefined") {
                unitData.sid = sid;
            }
            await this.logBookEvent(unitData);
        }
    }

    async runCoaches() {
        //Run all available code coaches and update code coach div

        //clear anything after header in codecoach div and hide it
        $(this.codecoach).children().slice(1).remove();
        $(this.codecoach).css("display", "none");

        //get code, run coaches
        let code = await this.buildProg(false);
        let results = [];
        for (let coach of this.codeCoachList) {
            results.push(coach.check(code));
        }

        //once all coaches are done, update div
        Promise.allSettled(results).then((promises) => {
            for (let p of promises) {
                if (
                    p.status === "fulfilled" &&
                    p.value !== null &&
                    p.value.trim() !== ""
                ) {
                    let checkDiv = document.createElement("div");
                    checkDiv.classList.add("python_check_results");
                    let checkPre = checkDiv.appendChild(
                        document.createElement("pre")
                    );
                    checkPre.textContent = p.value;
                    this.codecoach.append(checkDiv);
                    $(this.codecoach).css("display", "block");
                }
            }
        });
    }

    renderFeedback() {
        // The python unit test code builds the table as it is running the tests
        // In "normal" usage this is displayed immediately.
        // However in exam mode we make a div which is offscreen
        if (this.unit_results_divid) {
            if (this.unit_results_divid.indexOf("_offscreen_") > 0) {
                let urDivid = `${this.divid}_offscreen_unit_results`;
                let unitFeedback = document.getElementById(urDivid);
                let tmp = document.body.removeChild(unitFeedback);
                if ($(this.outerDiv).find(`#${urDivid}`).length > 0) {
                    tmp = $(this.outerDiv).find(`#${urDivid}`)[0];
                } else {
                    this.outerDiv.appendChild(tmp);
                }
                $(tmp).show();
            } else {
                let urDivid = this.divid + "_unit_results";
                if (
                    $(this.outerDiv).find(`#${urDivid}`).length == 0 &&
                    $(this.outerDiv).find(`#${urDivid}_offscreen_unit_results`)
                        .length == 0
                ) {
                    let urResults = document.getElementById(urDivid);
                    // why do we do this?  This doesn't seem to matter for grading...
                    if (urResults) {
                        this.outerDiv.appendChild(urResults);
                    }
                }
            }
        }
    }

    toggleAlert() {
        if (this.is_toggle && this.runCount == 3) {
            if (
                this.errinfo != "success" ||
                this.unit_results.substring(8, 11) != 100.0
            ) {
                setTimeout(function () {
                    alert(
                        "Help is Available Using the Toggle Question Selector! You can try the Mixed-up Question first."
                    );
                }, 500);
                this.logBookEvent({
                    event: "togglealert",
                    act: "Help is Available Using the Toggle Question Selector",
                    div_id: this.divid,
                });
            }
        }
    }

    /* runProg has several async elements to it.
     * 1. Skulpt runs the python program asynchronously
     * 2. The history is restored asynchronously
     * 3. Logging is asynchronous
     *
     * This method returns the skulpt Promise and so the promise will resolve when skulpt is finished.
     * when finished this.unit_results will contain the results of any unit tests that have been run.
     * The table of results is constructed and added to the DOM by the python unittest.gui module in skulpt.
     *
     */
    async runProg(noUI, logResults) {
        console.log("starting runProg");
        stopExecution = false;
        this.outputLineCount = 0;
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        var prog = await this.buildProg(true);
        this.saveCode = "True";
        $(this.output).text("");
        if (this.unit_results_divid) {
            let urdiv = document.getElementById(
                this.unit_results_divid + "_unit_results"
            );
            if (urdiv) {
                urdiv.innerHTML = "";
            }
        }
        while ($(`#${this.divid}_errinfo`).length > 0) {
            $(`#${this.divid}_errinfo`).remove();
        }
        //$(this.eContainer).remove();
        if (this.codelens) {
            this.codelens.style.display = "none";
        }
        if (this.clButton) {
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
        }
        Sk.configure({
            output: this.outputfun.bind(this),
            read: this.fileReader,
            filewrite: this.filewriter.bind(this),
            __future__: Sk.python3,
            killableWhile: true,
            killableFor: true,
            nonreadopen: true,
            //        python3: this.python3,
            imageProxy: "/ns/rsproxy/imageproxy",
            inputfunTakesPrompt: true,
            jsonpSites: ["https://itunes.apple.com"],
        });
        // Sk.JoBase = document.createElement("canvas");
        // JoBase - currently broken - needs this canvas element
        Sk.divid = this.divid;
        Sk.logResults = logResults;
        if (this.graderactive && this.outerDiv.closest(".loading")) {
            Sk.gradeContainer = this.outerDiv.closest(".loading").id;
        } else {
            Sk.gradeContainer = this.divid;
        }
        this.setTimeLimit();
        (Sk.TurtleGraphics || (Sk.TurtleGraphics = {})).target = this.graphics;
        Sk.canvas = this.graphics.id; //todo: get rid of this here and in image
        if (!noUI) {
            this.saveCode = await this.manage_scrubber(this.saveCode);
            $(this.runButton).attr("disabled", "disabled");
            $(this.historyScrubber).off("slidechange");
            $(this.historyScrubber).slider("disable");
            $(this.outDiv).show({
                duration: 700,
                queue: false,
            });
        }
        try {
            await Sk.misceval.asyncToPromise(
                function () {
                    return Sk.importMainWithBody("<stdin>", false, prog, true);
                },
                {
                    // suspension handlers
                    "*": () => {
                        if (stopExecution) {
                            console.log("stopExecution is true");
                            throw new Error(`The program was interrupted`);
                        }
                    },
                }
            );
            if (!noUI) {
                if (this.slideit) {
                    $(this.historyScrubber).on(
                        "slidechange",
                        this.slideit.bind(this)
                    );
                }
                $(this.historyScrubber).slider("enable");
            }
            this.errLastRun = false;
            this.errinfo = "success";
        } catch (err) {
            if (!noUI) {
                $(this.historyScrubber).on(
                    "slidechange",
                    this.slideit.bind(this)
                );
                $(this.historyScrubber).slider("enable");
            }
            this.errinfo = err.toString();
            this.addErrorMessage(err);
        } finally {
            $(this.runButton).removeAttr("disabled");
            if (typeof window.allVisualizers != "undefined") {
                $.each(window.allVisualizers, function (i, e) {
                    e.redrawConnectors();
                });
            }
        }
    }

    disableInteraction() {
        $(this.runButton).hide();
        $(this.codeDiv).addClass("ac-disabled");
    }
}

var languageExtensions = {
    python: "py",
    html: "html",
    javascript: "js",
    java: "java",
    python2: "py",
    python3: "py",
    cpp: "cpp",
    c: "c",
    sql: "sql",
    octave: "m",
};

// Languages that get a "Reformat" button. Probably works fine for any curly
// brace language but better not to add them until someone actually checks a
// book using that language. Definitely works badly for Python since it will
// indent anything after an `if` to be part of the if.
var reformatable = new Set(["java", "cpp", "c", "javascript"]);

var errorText = {};

errorText.ParseError = $.i18n("msg_sctivecode_parse_error");
errorText.ParseErrorFix = $.i18n("msg_sctivecode_parse_error_fix");
errorText.TypeError = $.i18n("msg_activecode_type_error");
errorText.TypeErrorFix = $.i18n("msg_activecode_type_error_fix");
errorText.NameError = $.i18n("msg_activecode_name_error");
errorText.NameErrorFix = $.i18n("msg_activecode_name_error_fix");
errorText.ValueError = $.i18n("msg_activecode_value_error");
errorText.ValueErrorFix = $.i18n("msg_activecode_value_error_fix");
errorText.AttributeError = $.i18n("msg_activecode_attribute_error");
errorText.AttributeErrorFix = $.i18n("msg_activecode_attribute_error_fix");
errorText.TokenError = $.i18n("msg_activecode_token_error");
errorText.TokenErrorFix = $.i18n("msg_activecode_token_error_fix");
errorText.TimeLimitError = $.i18n("msg_activecode_time_limit_error");
errorText.TimeLimitErrorFix = $.i18n("msg_activecode_time_limit_error_fix");
errorText.Error = $.i18n("msg_activecode_general_error");
errorText.ErrorFix = $.i18n("msg_activecode_general_error_fix");
errorText.SyntaxError = $.i18n("msg_activecode_syntax_error");
errorText.SyntaxErrorFix = $.i18n("msg_activecode_syntax_error_fix");
errorText.IndexError = $.i18n("msg_activecode_index_error");
errorText.IndexErrorFix = $.i18n("msg_activecode_index_error_fix");
errorText.URIError = $.i18n("msg_activecode_uri_error");
errorText.URIErrorFix = $.i18n("msg_activecode_uri_error_fix");
errorText.ImportError = $.i18n("msg_activecode_import_error");
errorText.ImportErrorFix = $.i18n("msg_activecode_import_error_fix");
errorText.ReferenceError = $.i18n("msg_activecode_reference_error");
errorText.ReferenceErrorFix = $.i18n("msg_activecode_reference_error_fix");
errorText.ZeroDivisionError = $.i18n("msg_activecode_zero_division_error");
errorText.ZeroDivisionErrorFix = $.i18n(
    "msg_activecode_zero_division_error_fix"
);
errorText.RangeError = $.i18n("msg_activecode_range_error");
errorText.RangeErrorFix = $.i18n("msg_activecode_range_error_fix");
errorText.InternalError = $.i18n("msg_activecode_internal_error");
errorText.InternalErrorFix = $.i18n("msg_activecode_internal_error_fix");
errorText.IndentationError = $.i18n("msg_activecode_indentation_error");
errorText.IndentationErrorFix = $.i18n("msg_activecode_indentation_error_fix");
errorText.NotImplementedError = $.i18n("msg_activecode_not_implemented_error");
errorText.NotImplementedErrorFix = $.i18n(
    "msg_activecode_not_implemented_error_fix"
);
errorText.KeyError = $.i18n("msg_activecode_key_error");
errorText.KeyErrorFix = $.i18n("msg_activecode_key_error_fix");
errorText.AssertionError = $.i18n("msg_activecode_assertion_error");
errorText.AssertionErrorFix = $.i18n("msg_activecode_assertion_error_fix");

String.prototype.replaceAll = function (target, replacement) {
    return this.split(target).join(replacement);
};


/***/ }),

/***/ 15033:
/*!****************************************************!*\
  !*** ./runestone/activecode/js/activecode_html.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HTMLActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class HTMLActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        this.code = $("<textarea />").html(this.origElem.innerHTML).text();
        $(this.runButton).text("Render");
        this.editor.setValue(this.code);
    }

    async runProg() {
        var prog = await this.buildProg(true);
        let saveCode = "True";
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.output).text("");
        $(this.outDiv).show({ duration: 700, queue: false });
        prog =
            "<script type=text/javascript>window.onerror = function(msg,url,line) {alert(msg+' on line: '+line);};</script>" +
            prog;
        this.output.srcdoc = prog;
    }

    createOutput() {
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output");
        this.outDiv = outDiv;
        this.output = document.createElement("iframe");
        $(this.output).css("background-color", "white");
        $(this.output).css("position", "relative");
        $(this.output).css("height", "400px");
        $(this.output).css("width", "100%");
        outDiv.appendChild(this.output);
        this.outerDiv.appendChild(outDiv);
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
    }
    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_render"));
    }
}


/***/ }),

/***/ 40653:
/*!**************************************************!*\
  !*** ./runestone/activecode/js/activecode_js.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JSActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class JSActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
    }
    outputfun(a) {
        $(this.output).css("visibility", "visible");
        var str = "[";
        if (typeof a == "object" && a.length) {
            for (var i = 0; i < a.length; i++)
                if (typeof a[i] == "object" && a[i].length) {
                    str += (i == 0 ? "" : " ") + "[";
                    for (var j = 0; j < a[i].length; j++)
                        str +=
                            a[i][j] +
                            (j == a[i].length - 1
                                ? "]" + (i == a.length - 1 ? "]" : ",") + "\n"
                                : ", ");
                } else str += a[i] + (i == a.length - 1 ? "]" : ", ");
        } else {
            try {
                str = JSON.stringify(a);
            } catch (e) {
                str = a;
            }
        }
        return str;
    }
    async runProg() {
        var _this = this;
        var prog = await this.buildProg(true);
        var saveCode = "True";
        var write = function (str) {
            _this.output.innerHTML += _this.outputfun(str);
        };
        var writeln = function (str) {
            if (!str) str = "";
            _this.output.innerHTML += _this.outputfun(str) + "<br />";
        };
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.eContainer).remove();
        $(this.output).text("");
        $(this.outDiv).show({ duration: 700, queue: false });
        try {
            eval(prog);
            this.errinfo = "success";
        } catch (e) {
            this.addErrorMessage(e);
            this.errinfo = e;
        }
    }

    addErrorMessage(err) {
        // Add the error message
        this.errLastRun = true;
        var errHead = $("<h3>").html("Error");
        this.eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.eContainer.className = "error alert alert-danger";
        this.eContainer.id = this.divid + "_errinfo";
        this.eContainer.appendChild(errHead[0]);
        var errText = this.eContainer.appendChild(
            document.createElement("pre")
        );
        var errString = err.toString();
        errText.innerHTML = errString;
        console.log("Runtime Error: " + err.toString());
    }
}


/***/ }),

/***/ 23538:
/*!***************************************************!*\
  !*** ./runestone/activecode/js/activecode_sql.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SQLActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var handsontable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! handsontable */ 36080);
/* harmony import */ var handsontable_dist_handsontable_full_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! handsontable/dist/handsontable.full.css */ 59823);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sql.js/dist/sql-wasm.js */ 26657);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3__);





var allDburls = {};

class SQLActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        //  fnprefix sets the path to load the sql-wasm.wasm file
        var bookprefix;
        var fnprefix;
        // Fix: the mode=browsing problem wich disables useRunestoneServices and
        // makes it impossible to cororectly load sql-wasm
        if (
            eBookConfig.useRunestoneServices ||
            window.location.search.includes("mode=browsing")
        ) {
            bookprefix = `/ns/books/published/${eBookConfig.basecourse}`;
            fnprefix = bookprefix + "/_static";
        } else {
            // The else clause handles the case where you are building for a static web browser
            bookprefix = "";
            fnprefix = "/_static";
        }
        this.config = {
            locateFile: (filename) => `${fnprefix}/${filename}`,
        };
        this.showLast = $(this.origElem).data("showlastsql");
        var self = this;
        sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3___default()(this.config).then(function (SQL) {
            // set up call to load database asynchronously if given
            if (self.dburl) {
                if (self.dburl.startsWith("/_static")) {
                    self.dburl = `${bookprefix}${self.dburl}`;
                } else if (self.dburl.startsWith("external")) {
                    self.dburl = `${bookprefix}/${self.dburl}`;
                }
                $(self.runButton).attr("disabled", "disabled");
                let buttonText = $(self.runButton).text();
                $(self.runButton).text($.i18n("msg_activecode_load_db"));
                if (!(self.dburl in allDburls)) {
                    allDburls[self.dburl] = {
                        status: "loading",
                        xWaitFor: jQuery.Deferred(),
                    };
                } else {
                    if (allDburls[self.dburl].status == "loading") {
                        allDburls[self.dburl].xWaitFor.done(function () {
                            self.db = allDburls[self.dburl].dbObject;
                            $(self.runButton).removeAttr("disabled");
                            $(self.runButton).text(buttonText);
                        });
                        return;
                    }
                    self.db = allDburls[self.dburl].dbObject;
                    $(self.runButton).removeAttr("disabled");
                    $(self.runButton).text(buttonText);
                    return;
                }
                var xhr = new XMLHttpRequest();
                // For example: https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite
                xhr.open("GET", self.dburl, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = (e) => {
                    var uInt8Array = new Uint8Array(xhr.response);
                    self.db = new SQL.Database(uInt8Array);
                    allDburls[self.dburl].dbObject = self.db;
                    $(self.runButton).text(buttonText);
                    $(self.runButton).removeAttr("disabled");
                    allDburls[self.dburl].db = uInt8Array;
                    allDburls[self.dburl].status = "ready";
                    allDburls[self.dburl].xWaitFor.resolve();
                    // contents is now [{columns:['col1','col2',...], values:[[first row], [second row], ...]}]
                };
                xhr.send();
            } else {
                self.db = new SQL.Database();
            }
        });
    }
    async runProg(noUI, logResults) {
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        // Clear any old results
        this.saveCode = "True";
        let divid = this.divid + "_sql_out";
        let respDiv = document.getElementById(divid);
        if (respDiv) {
            respDiv.parentElement.removeChild(respDiv);
        }
        $(this.output).text("");
        // Run this query
        let query = await this.buildProg(false); // false --> Do not include suffix
        if (!this.db) {
            $(this.output).text(
                `Error: Database not initialized! DBURL: ${this.dburl}`
            );
            return;
        }

        let it = this.db.iterateStatements(query);
        this.results = [];
        try {
            for (let statement of it) {
                let columns = statement.getColumnNames();
                if (columns.length > 0) {
                    // data! probably a SELECT
                    let data = [];
                    while (statement.step()) {
                        data.push(statement.get());
                    }
                    this.results.push({
                        status: "success",
                        columns: columns,
                        values: data,
                        rowcount: data.length,
                    });
                } else {
                    let nsql = statement.getNormalizedSQL();
                    let prefix = nsql.substr(0, 6).toLowerCase();
                    statement.step(); // execute the query
                    // Try to detect INSERT/UPDATE/DELETE to give friendly feedback
                    // on rows modified - unfortunately, this won't catch such queries
                    // if they use CTEs.  There seems to be no reliable way of knowing
                    // when a SQLite query actually modified data.
                    if (
                        prefix === "insert" ||
                        prefix === "update" ||
                        prefix === "delete"
                    ) {
                        this.results.push({
                            status: "success",
                            operation: prefix,
                            rowcount: this.db.getRowsModified(),
                        });
                    } else {
                        this.results.push({ status: "success" });
                    }
                }
            }
        } catch (e) {
            this.results.push({
                status: "failure",
                message: e.toString(),
                sql: it.getRemainingSQL(),
            });
        }

        if (this.results.length === 0) {
            this.results.push({
                status: "failure",
                message: "No queries submitted.",
            });
        }

        try {
            this.saveCode = await this.manage_scrubber(this.saveCode);
            if (this.slideit) {
                $(this.historyScrubber).on(
                    "slidechange",
                    this.slideit.bind(this)
                );
            }
            $(this.historyScrubber).slider("enable");
        } catch (e) {
            console.log(`Failed to update scrubber ${e}`);
        }

        respDiv = document.createElement("div");
        respDiv.id = divid;
        this.outDiv.appendChild(respDiv);
        $(this.outDiv).show();
        // Sometimes we don't want to show a bunch of intermediate results
        // like when we are including a bunch of previous statements from
        // other activecodes In that case the showlastsql flag can be set
        // so we only show the last result
        let resultArray = this.results;
        if (this.showLast) {
            resultArray = this.results.slice(-1);
        }
        for (let r of resultArray) {
            let section = document.createElement("div");
            section.setAttribute("class", "ac_sql_result");
            respDiv.appendChild(section);
            if (r.status === "success") {
                if (r.columns) {
                    let tableDiv = document.createElement("div");
                    section.appendChild(tableDiv);
                    let maxHeight = 350;
                    if (resultArray.length > 1) maxHeight = 200; // max height smaller if lots of results
                    createTable(r, tableDiv, maxHeight);
                    let messageBox = document.createElement("pre");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    let msg = "" + r.rowcount + rmsg + "returned";
                    if (r.rowcount > 100) {
                        msg = msg + " (only first 100 rows displayed)";
                    }
                    msg = msg + ".";
                    messageBox.textContent = msg;
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                } else if (r.rowcount) {
                    let messageBox = document.createElement("pre");
                    let op = r.operation;
                    op = op + (op.charAt(op.length - 1) === "e" ? "d." : "ed.");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    messageBox.textContent = "" + r.rowcount + rmsg + op;
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                } else {
                    let messageBox = document.createElement("pre");
                    messageBox.textContent = "Operation succeeded.";
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                }
            } else {
                let messageBox = document.createElement("pre");
                messageBox.textContent = r.message;
                messageBox.setAttribute("class", "ac_sql_result_failure");
                section.appendChild(messageBox);
            }
        }

        // Now handle autograding
        if (this.suffix) {
            this.testResult = this.autograde(
                this.results[this.results.length - 1]
            );
        } else {
            $(this.output).css("visibility", "hidden");
        }

        return Promise.resolve("done");
    }

    async logCurrentAnswer(sid) {
        let data = {
            div_id: this.divid,
            code: this.editor.getValue(),
            language: this.language,
            errinfo: this.results[this.results.length - 1].status,
            to_save: this.saveCode,
            prefix: this.pretext,
            suffix: this.suffix,
            partner: this.partner,
        }; // Log the run event
        if (typeof sid !== "undefined") {
            data.sid = sid;
        }
        await this.logRunEvent(data);

        if (this.unit_results) {
            let unitData = {
                event: "unittest",
                div_id: this.divid,
                course: eBookConfig.course,
                act: this.unit_results,
            };
            if (typeof sid !== "undefined") {
                unitData.sid = sid;
            }
            await this.logBookEvent(unitData);
        }
    }

    renderFeedback() {
        if (this.testResult) {
            $(this.output).text(this.testResult);
            $(this.output).css("visibility", "visible");
        }
    }

    autograde(result_table) {
        var tests = this.suffix.split(/\n/);
        this.passed = 0;
        this.failed = 0;
        // Tests should be of the form
        // assert row,col oper value for example
        // assert 4,4 == 3
        var result = "";
        tests = tests.filter(function (s) {
            return s.indexOf("assert") > -1;
        });
        for (let test of tests) {
            let wlist = test.split(/\s+/);
            wlist.shift();
            let loc = wlist.shift();
            let oper = wlist.shift();
            let expected = wlist.join(" ");
            let [row, col] = loc.split(",");
            result += this.testOneAssert(
                row,
                col,
                oper,
                expected,
                result_table
            );
            result += "\n";
        }
        let pct = (100 * this.passed) / (this.passed + this.failed);
        if (isNaN(pct)) {
            pct = 0.0;
        }
        pct = pct.toLocaleString(undefined, { maximumFractionDigits: 2 });
        result += `You passed ${this.passed} out of ${
            this.passed + this.failed
        } tests for ${pct}%`;
        this.unit_results = `percent:${pct}:passed:${this.passed}:failed:${this.failed}`;
        return result;
    }
    testOneAssert(row, col, oper, expected, result_table) {
        // make sure row and col are in bounds
        let actual;
        let output = "";
        try {
            actual = result_table.values[row][col];
        } catch (e) {
            output = `Failed Not enough data to check row ${row} or column ${col}`;
            this.failed++;
            return output;
        }
        const operators = {
            "==": function (operand1, operand2) {
                return operand1 == operand2;
            },
            "!=": function (operand1, operand2) {
                return operand1 != operand2;
            },
            ">": function (operand1, operand2) {
                return operand1 > operand2;
            },
            "<": function (operand1, operand2) {
                return operand1 > operand2;
            },
        };
        let res = operators[oper](actual, expected);
        if (res) {
            output = `Pass: ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.passed++;
        } else {
            output = `Failed ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.failed++;
        }
        return output;
    }
}

function createTable(tableData, container, maxHeight) {
    let data = tableData.values;
    let trimRows = undefined;
    if (data.length === 0) {
        // kludge: no column headers will show up unless we do this
        data = [tableData.columns.map((e) => null)];
        trimRows = [0];
    }

    var hot = new handsontable__WEBPACK_IMPORTED_MODULE_1__["default"](container, {
        data: data,
        trimRows: trimRows,
        width: "100%",
        height: maxHeight,
        autoRowSize: true,
        autoColumnSize: { useHeaders: true },
        rowHeaders: false,
        colHeaders: tableData.columns,
        editor: false,
        maxRows: 100,
        filters: false,
        dropdownMenu: false,
        licenseKey: "non-commercial-and-evaluation",
    });

    // calculate actual height and resize
    let actualHeight = 40; // header height + small margin
    if (tableData.values.length > 0) {
        for (let i = 0; i < data.length; i++) {
            actualHeight = actualHeight + hot.getRowHeight(i);
            if (actualHeight > maxHeight) break;
        }
    }

    hot.updateSettings({ height: actualHeight });

    return hot;
}


/***/ }),

/***/ 27350:
/*!**********************************************!*\
  !*** ./runestone/activecode/js/audiotour.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioTour)
/* harmony export */ });
/* harmony import */ var _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/js/runestonebase.js */ 2568);


// function to display the audio tours
class AudioTour extends _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(divid, code, bnum, audio_text) {
        // Bug Fix: If a class extends another class, this is undefined UNTIL super is called
        super();
        this.audio_tour = null;
        this.audio_code = null;
        this.windowcode = null;
        this.first_audio = null;
        this.prev_audio = null;
        this.pause_audio = null;
        this.next_audio = null;
        this.last_audio = null;
        this.status = null;
        this.stop_button = null;
        this.tourButtons = [];
        this.elem = null; // current audio element playing
        this.currIndex = null; // current index
        this.len = null; // current length of audio files for tour
        this.buttonCount = null; // number of audio tour buttons
        this.aname = null; // the audio file name
        this.ahash = null; // hash of the audio file name to the lines to highlight
        this.theDivid = null; // div id
        this.afile = null; // file name for audio
        this.playing = false; // flag to say if playing or not
        this.tourName = "";
        // Replacing has been done here to make sure special characters in the code are displayed correctly
        code = code.replaceAll("*doubleq*", '"');
        code = code.replaceAll("*singleq*", "'");
        code = code.replaceAll("*open*", "(");
        code = code.replaceAll("*close*", ")");
        code = code.replaceAll("*nline*", "<br/>");
        var codeArray = code.split("\n");
        var audio_hash = [];
        var bval = [];
        var atype = audio_text.replaceAll("*doubleq*", '"');
        var audio_type = atype.split("*atype*");
        for (let i = 0; i < audio_type.length - 1; i++) {
            audio_hash[i] = audio_type[i];
            var aword = audio_type[i].split(";");
            bval.push(aword[0]);
        }
        var first =
            "<pre><div id='" +
            divid +
            "_l1'>" +
            "1.   " +
            codeArray[0] +
            "</div>";
        var num_lines = codeArray.length;
        for (let i = 1; i < num_lines; i++) {
            if (i < 9) {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ".   " +
                    codeArray[i] +
                    "</div>";
            } else if (i < 99) {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ".  " +
                    codeArray[i] +
                    "</div>";
            } else {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ". " +
                    codeArray[i] +
                    "</div>";
            }
        }
        first = first + "</pre>";
        //laying out the HTML content
        var bcount = 0;
        for (var i = 0; i < audio_type.length - 1; i++) {
            var newButton = document.createElement("button");
            newButton.className = "btn btn-success";
            newButton.innerHTML = bval[i].replace(/\"/g, "");
            this.tourButtons.push(newButton);
            bcount++;
        }
        this.audio_tour = document.createElement("div");
        this.audio_tour.align = "center";
        this.audio_code = document.createElement("p");
        this.windowcode = document.createElement("div");
        this.windowcode.align = "left";
        $(this.windowcode).html(first);
        this.first_audio = document.createElement("button");
        this.prev_audio = document.createElement("button");
        this.pause_audio = document.createElement("button");
        this.next_audio = document.createElement("button");
        this.last_audio = document.createElement("button");
        this.first_audio.className =
            "btn-default glyphicon glyphicon-fast-backward";
        this.prev_audio.className =
            "btn-default glyphicon glyphicon-step-backward";
        this.pause_audio.className = "btn-default glyphicon glyphicon-pause";
        this.next_audio.className =
            "btn-default glyphicon glyphicon-step-forward";
        this.last_audio.className =
            "btn-default glyphicon glyphicon-fast-forward";
        this.first_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.prev_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.pause_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.next_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.last_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.first_audio.name = "first_audio";
        this.prev_audio.name = "prev_audio";
        this.pause_audio.name = "pause_audio";
        this.next_audio.name = "next_audio";
        this.last_audio.name = "last_audio";
        this.first_audio.title = "Play first audio in tour";
        this.prev_audio.title = "Play previous audio in tour";
        this.pause_audio.title = "Pause current audio";
        this.next_audio.title = "Play next audio in tour";
        this.last_audio.title = "Play last audio in tour";
        this.first_audio.setAttribute("aria-label", "Play first audio in tour");
        this.prev_audio.setAttribute(
            "aria-label",
            "Play previous audio in tour"
        );
        this.pause_audio.setAttribute("aria-label", "Pause audio");
        this.next_audio.setAttribute("aria-label", "Play next audio in tour");
        this.last_audio.setAttribute("aria-label", "Play last audio in tour");
        this.first_audio.disabled = true;
        this.prev_audio.disabled = true;
        this.pause_audio.disabled = true;
        this.next_audio.disabled = true;
        this.last_audio.disabled = true;
        this.status = document.createElement("div");
        this.status.className = "alert alert-info";
        this.status.setAttribute("style", "display: none;");
        this.stop_button = document.createElement("button");
        this.stop_button.className = "btn btn-default";
        this.stop_button.innerHTML = "Stop tour";
        $(this.audio_tour).append(
            this.audio_code,
            this.windowcode,
            document.createElement("br"),
            this.first_audio,
            this.prev_audio,
            this.pause_audio,
            this.next_audio,
            this.last_audio,
            document.createElement("br"),
            this.status,
            document.createElement("br"),
            this.tourButtons,
            this.stop_button
        );
        $("#" + divid + " .ac_code_div").append(this.audio_tour);
        $("#" + divid + " .ac_code_div").css("width", "100%");
        $("#" + divid + " .CodeMirror.cm-s-default.ui-resizable").hide();
        $("#" + divid + " .ac_opt.btn.btn-default:last-child").hide();
        $(this.stop_button).click(
            function () {
                if (this.playing) {
                    this.elem.pause();
                }
                //log change to db
                this.logBookEvent({
                    event: "Audio",
                    act: "closeWindow",
                    div_id: divid,
                });
                $(this.audio_tour).remove();
                $(
                    "#" + divid + " .CodeMirror.cm-s-default.ui-resizable"
                ).show();
                $("#" + divid + " .ac_opt.btn.btn-default:last-child").show();
                $("#" + divid + " .ac_code_div").css("width", "");
            }.bind(this)
        );
        $(this.tourButtons[0]).click(
            function () {
                this.tour(divid, audio_hash[0], bcount);
            }.bind(this)
        );
        $(this.tourButtons[1]).click(
            function () {
                this.tour(divid, audio_hash[1], bcount);
            }.bind(this)
        );
        $(this.tourButtons[2]).click(
            function () {
                this.tour(divid, audio_hash[2], bcount);
            }.bind(this)
        );
        $(this.tourButtons[3]).click(
            function () {
                this.tour(divid, audio_hash[3], bcount);
            }.bind(this)
        );
        $(this.tourButtons[4]).click(
            function () {
                this.tour(divid, audio_hash[4], bcount);
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.first_audio).click(
            function () {
                this.firstAudio();
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.prev_audio).click(
            function () {
                this.prevAudio();
            }.bind(this)
        );
        // handle the click to pause or play the audio
        $(this.pause_audio).click(
            function () {
                this.pauseAndPlayAudio(divid);
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.next_audio).click(
            function () {
                this.nextAudio();
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.last_audio).click(
            function () {
                this.lastAudio();
            }.bind(this)
        );
        // make the image buttons look disabled
        $(this.first_audio).css("opacity", 0.25);
        $(this.prev_audio).css("opacity", 0.25);
        $(this.pause_audio).css("opacity", 0.25);
        $(this.next_audio).css("opacity", 0.25);
        $(this.last_audio).css("opacity", 0.25);
    }
    tour(divid, audio_type, bcount) {
        // set globals
        this.buttonCount = bcount;
        this.theDivid = divid;
        this.status.setAttribute(
            "style",
            "display: inline-block; margin-top: 7px; margin-bottom: 3px;"
        );
        // enable prev, pause/play and next buttons and make visible
        $(this.first_audio).removeAttr("disabled");
        $(this.prev_audio).removeAttr("disabled");
        $(this.pause_audio).removeAttr("disabled");
        $(this.next_audio).removeAttr("disabled");
        $(this.last_audio).removeAttr("disabled");
        $(this.first_audio).css("opacity", 1.0);
        $(this.prev_audio).css("opacity", 1.0);
        $(this.pause_audio).css("opacity", 1.0);
        $(this.next_audio).css("opacity", 1.0);
        $(this.last_audio).css("opacity", 1.0);
        // disable tour buttons
        for (var i = 0; i < bcount; i++)
            $(this.tourButtons[i]).attr("disabled", "disabled");
        var atype = audio_type.split(";");
        var name = atype[0].replaceAll('"', " ");
        this.tourName = name;
        $(this.status).html($.i18n("msg_activecode_starting", name));
        //log tour type to db
        this.logBookEvent({ event: "Audio", act: name, div_id: divid });
        var max = atype.length;
        var str = "";
        this.ahash = [];
        this.aname = [];
        for (i = 1; i < max - 1; i++) {
            var temp = atype[i].split(":");
            var temp_line = temp[0];
            var temp_aname = temp[1];
            var akey = temp_aname.substring(1, temp_aname.length);
            var lnums = temp_line.substring(1, temp_line.length);
            //alert("akey:"+akey+"lnum:"+lnums);
            // str+="<audio id="+akey+" preload='auto'><source src='http://ice-web.cc.gatech.edu/ce21/audio/"+
            // akey+".mp3' type='audio/mpeg'><source src='http://ice-web.cc.gatech.edu/ce21/audio/"+akey+
            // ".ogg' type='audio/ogg'>Your browser does not support the audio tag</audio>";
            //var dir =
            //    "http://media.interactivepython.org/" +
            //    eBookConfig.basecourse.toLowerCase() +
            //    "/audio/";
            var dir = "../_static/audio/"
            str += "<audio id=" + akey + " preload='auto' >";
            str += "<source src='" + dir + akey + ".wav' type='audio/wav'>";
            str += "<source src='" + dir + akey + ".mp3' type='audio/mpeg'>";
            str += "<source src='" + dir + akey + ".wav' type='audio/wav'>";
            str += "<source src='" + dir + akey + ".mp3' type='audio/mpeg'>";
            str += "<br />Your browser does not support the audio tag</audio>";
            this.ahash[akey] = lnums;
            this.aname.push(akey);
        }
        $(this.audio_code).html(str);
        this.len = this.aname.length; // set the number of audio file in the tour
        this.currIndex = 0;
        this.playCurrIndexAudio();
    }
    handlePlaying() {
        this.elem.pause();
        // unbind current ended
        $("#" + this.afile).unbind("ended");
        // unhighlight the prev lines
        this.unhighlightLines(
            this.theDivid,
            this.ahash[this.aname[this.currIndex]]
        );
    }
    firstAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "first",
            div_id: this.theDivid,
        });
        // move to the first audio
        this.currIndex = 0;
        // start at the first audio
        this.playCurrIndexAudio();
    }
    prevAudio() {
        // if there is a previous audio
        if (this.currIndex > 0) {
            // if audio is this.playing handle it
            this.handlePlaying();
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "prev",
                div_id: this.theDivid,
            });
            // move to previous to the current (but the current index has moved to the next)
            this.currIndex = this.currIndex - 1;
            // start at the prev audio
            this.playCurrIndexAudio();
        }
    }
    nextAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "next",
            div_id: this.theDivid,
        });
        // if not at the end
        if (this.currIndex < this.len - 1) {
            // start at the next audio
            this.currIndex = this.currIndex + 1;
            this.playCurrIndexAudio();
        } else if (this.currIndex == this.len - 1) {
            this.handleTourEnd();
        }
    }
    lastAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "last",
            div_id: this.theDivid,
        });
        // move to the last audio
        this.currIndex = this.len - 1;
        // start at last
        this.playCurrIndexAudio();
    }
    // play the audio at the current index
    playCurrIndexAudio() {
        // set this.playing to false
        this.playing = false;
        // play the current audio and highlight the lines
        this.playaudio(this.currIndex, this.aname, this.theDivid, this.ahash);
    }
    // handle the end of the tour
    handleTourEnd() {
        $(this.status).html("The " + this.tourName + " has ended.");
        this.pause_audio.className = "btn-default glyphicon glyphicon-pause";
        this.pause_audio.title = "Pause audio";
        this.pause_audio.setAttribute("aria-label", "Pause audio");
        $(this.first_audio).attr("disabled", "disabled");
        $(this.prev_audio).attr("disabled", "disabled");
        $(this.pause_audio).attr("disabled", "disabled");
        $(this.next_audio).attr("disabled", "disabled");
        $(this.last_audio).attr("disabled", "disabled");
        $(this.first_audio).css("opacity", 0.25);
        $(this.prev_audio).css("opacity", 0.25);
        $(this.pause_audio).css("opacity", 0.25);
        $(this.next_audio).css("opacity", 0.25);
        $(this.last_audio).css("opacity", 0.25);
        // enable the tour buttons
        for (var j = 0; j < this.buttonCount; j++)
            $(this.tourButtons[j]).removeAttr("disabled");
    }
    // only call this one after the first time
    outerAudio() {
        // unbind ended
        $("#" + this.afile).unbind("ended");
        // set this.playing to false
        this.playing = false;
        // unhighlight previous lines from the last audio
        this.unhighlightLines(
            this.theDivid,
            this.ahash[this.aname[this.currIndex]]
        );
        // increment the this.currIndex to point to the next one
        this.currIndex++;
        // if the end of the tour reset the buttons
        if (this.currIndex == this.len) {
            this.handleTourEnd();
        }
        // else not done yet so play the next audio
        else {
            // play the audio at the current index
            this.playCurrIndexAudio();
        }
    }
    // play the audio now that it is ready
    playWhenReady(afile, divid, ahash) {
        // unbind current
        $("#" + afile).unbind("canplaythrough");
        this.elem.currentTime = 0;
        this.playing = true;
        //console.log("in playWhenReady " + elem.duration);
        this.highlightLines(divid, ahash[afile]);
        if (
            this.pause_audio.className ===
            "btn-default glyphicon glyphicon-pause"
        ) {
            $(this.status).html(
                $.i18n("msg_activecode_playing", this.tourName)
            );
            $("#" + afile).bind(
                "ended",
                function () {
                    this.outerAudio();
                }.bind(this)
            );
            this.elem.play();
        } else {
            $("#" + afile).bind(
                "ended",
                function () {
                    this.outerAudio();
                }.bind(this)
            );
        }
    }
    // play the audio at the specified index i and set the duration and highlight the lines
    playaudio(i, aname, divid, ahash) {
        this.afile = aname[i];
        this.elem = document.getElementById(this.afile);
        // if this isn't ready to play yet - no duration yet then wait
        //console.log("in playaudio " + elem.duration);
        if (isNaN(this.elem.duration) || this.elem.duration == 0) {
            // set the status
            $(this.status).html($.i18n("msg_activecode_loading_audio"));
            $("#" + this.afile).bind(
                "canplaythrough",
                function () {
                    this.playWhenReady(this.afile, divid, ahash);
                }.bind(this)
            );
        }
        // otherwise it is ready so play it
        else {
            this.playWhenReady(this.afile, divid, ahash);
        }
    }
    // pause if this.playing and play if paused
    pauseAndPlayAudio(divid) {
        var btn = this.pause_audio;
        // if paused and clicked then continue from current
        if (this.elem.paused) {
            // calcualte the time left to play in milliseconds
            let counter = (this.elem.duration - this.elem.currentTime) * 1000;
            this.elem.play(); // start the audio from current spot
            this.pause_audio.className =
                "btn-default glyphicon glyphicon-pause";
            this.pause_audio.title = $.i18n(
                "msg_activecode_pause_current_audio"
            );
            this.pause_audio.setAttribute(
                "aria-label",
                $.i18n("msg_activecode_pause_audio")
            );
            $(this.status).html(
                $.i18n("msg_activecode_playing", this.tourName)
            );
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "play",
                div_id: this.theDivid,
            });
        }
        // if audio was this.playing pause it
        else if (this.playing) {
            this.elem.pause(); // pause the audio
            this.pause_audio.className = "btn-default glyphicon glyphicon-play";
            this.pause_audio.title = $.i18n("msg_activecode_play_paused_audio");
            this.pause_audio.setAttribute(
                "aria-label",
                $.i18n("msg_activecode_play_paused_audio")
            );
            $(this.status).html(
                $.i18n("msg_activecode_audio_paused", this.tourName)
            );
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "pause",
                div_id: this.theDivid,
            });
        }
    }
    // process the lines
    processLines(divid, lnum, color) {
        var comma = lnum.split(",");
        if (comma.length > 1) {
            for (let i = 0; i < comma.length; i++) {
                this.setBackgroundForLines(divid, comma[i], color);
            }
        } else {
            this.setBackgroundForLines(divid, lnum, color);
        }
    }
    // unhighlight the lines - set the background back to transparent
    unhighlightLines(divid, lnum) {
        this.processLines(divid, lnum, "transparent");
    }
    // highlight the lines - set the background to a yellow color
    highlightLines(divid, lnum) {
        this.processLines(divid, lnum, "#ffff99");
    }
    // set the background to the passed color
    setBackgroundForLines(divid, lnum, color) {
        var hyphen = lnum.split("-");
        var str;
        // if a range of lines
        if (hyphen.length > 1) {
            var start = parseInt(hyphen[0]);
            var end = parseInt(hyphen[1]) + 1;
            for (var k = start; k < end; k++) {
                //alert(k);
                str = "#" + divid + "_l" + k;
                if ($(str).text() != "") {
                    $(str).css("background-color", color);
                }
                //$(str).effect("highlight",{},(dur*1000)+4500);
            }
        } else {
            //alert(lnum);
            str = "#" + divid + "_l" + lnum;
            $(str).css("background-color", color);
            //$(str).effect("highlight",{},(dur*1000)+4500);
        }
    }
}


/***/ }),

/***/ 56047:
/*!**********************************************************!*\
  !*** ./runestone/activecode/js/coach-python-pyflakes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PyflakesCoach)
/* harmony export */ });
$.i18n().load({
    en: {
        msd_pyflakes_coach_line: "Line",
    },
});

class PyflakesCoach {
    async check(code) {
        let promise = new Promise(function (resolve, reject) {
            fetch('/ns/coach/python_check', {
                method: 'POST',
                body: code
            })
            .then((response) => {
                return response.json();
            })
            .then((data) => {
                if(data.trim() !== '') {
                    let message = "";
                    //clean up returned text
                    let errorLines = data.split("\n");
                    let codeLines = code.split("\n");
                    for(let line of errorLines) {
                        if(line.indexOf(".py:") != -1) {
                            //old pyflakes returns "file:line:col error"
                            //new pyflakes returns "file:line:col: error"
                            //handle either
                            const cleaner = /[^.]*.py:(\d+):(\d+):? (.*)/i;
                            let lineParts = line.match(cleaner);  //[1]: line, [2]: col, [3]: error
                            
                            //for now, filter messages about star imports
                            if(!lineParts[3].includes("defined from star imports") 
                            && !lineParts[3].includes("*' used; unable to detect undefined names"))
                            {
                                message += $.i18n("msd_pyflakes_coach_line") + lineParts[1] + ": " + lineParts[3] + "\n";
                                message += codeLines[lineParts[1] - 1] + "\n";
                                message += " ".repeat(lineParts[2] - 1) + "^\n";
                            }
                        } else {
                            message += line + "\n";
                        }
                    }
                    message = message.slice(0,-1);  //remove trailing newline
                    resolve(message);
                }
                resolve(null);
            })
            .catch(err => {
                reject("Error in Pyflakes Coach: " + err);
            })
        });
        return promise;
    }
}



/***/ }),

/***/ 69902:
/*!*******************************************************!*\
  !*** ./runestone/activecode/js/extractUnitResults.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JUnitTestParser)
/* harmony export */ });
var testString = `Starting Tests
Expected: Answer                   Actual: Answer                   Message: Checking method printAnswer()                     Passed: true
Expected: 6 line(s) of text        Actual: 0 line(s) of text        Message: Checking main method                              Passed: false
Hello World
Expected: String String            Actual: String String            Message: Checking Instance Variable Type(s)                Passed: true
Expected: Question                 Actual: Question                 Message: Checking method printQuestion()                   Passed: true
Debugging output
More debug output
Expected: 2 Private                Actual: 2 Private                Message: Checking Private Instance Variable(s)             Passed: true
Expected: pass                     Actual: pass                     Message: Checking constructor with parameters              Passed: true
Expected: fail                     Actual: fail                     Message: Checking default constructor                      Passed: true
Ending Tests
You got 6 out of 7 correct. 85.71%`;

class JUnitTestParser {
    constructor(output, parentId) {
        let patt = new RegExp(
            "Expected:\\s+(.*?)Actual:\\s+(.*?)Message:\\s+(.*?)Passed:\\s+(true|false)",
            "g"
        );
        this.textResults = "";
        let matches = output.matchAll(patt);
        let parent = document.createElement("div");
        parent.classList.add("unittest-results");
        let tbl = document.createElement("table");
        tbl.classList.add("ac-feedback");
        parent.appendChild(tbl);
        parent.setAttribute("id", `${parentId}_unit_results`);
        let tr = document.createElement("tr");
        tr.innerHTML =
            '<th class="ac-feedback">Result</th><th class="ac-feedback">Expected</th><th class="ac-feedback">Actual</th><th class="ac-feedback">Notes</th>';
        tbl.appendChild(tr);
        for (const match of matches) {
            let tr = document.createElement("tr");
            let td = document.createElement("td");
            td.classList.add("ac-feedback");
            if (match[match.length - 1] == "true") {
                td.innerHTML = "Pass";
                td.style =
                    "background-color: rgb(131, 211, 130); text-align: center;";
            } else {
                td.innerHTML = "Fail";
                td.style =
                    "background-color: rgb(222, 142, 150); text-align: center;";
            }
            tr.appendChild(td);
            tbl.appendChild(tr);
            for (let i = 1; i < match.length - 1; i++) {
                let td = document.createElement("td");
                td.innerHTML = match[i];
                td.classList.add("ac-feedback");
                tr.appendChild(td);
            }
            tbl.appendChild(tr);
            this.table = parent;
            this.textResults += match[0] + "\n";
            output = output.replace(match[0], "");
        }
        let match = output.match(
            /You got\s+(\d+) out of (\d+) correct.\s+(\d+\.\d+)%/
        );
        if (match) {
            output = output.replace(match[0], "");
            let pctString = document.createElement("span");
            pctString.innerHTML = match[0];
            this.pctString = pctString;
            this.pct = match[3];
            this.passed = match[1];
            this.failed = match[2] - match[1];
        }
        output = output.replace("Starting Tests", "");
        output = output.replace("Ending Tests", "");
        output = output.replace(/\n/g, "<br>");
        output = output.replace(/(<br>)+/g, "<br>");
        // do not mess up this next line, it is THE hack that makes turtle graphics and images work
        output = output.replaceAll("&lt;img", "<img");
        this.stdout = output;
    }
}

// let x = new ResultsToTable(testString);
// console.log(x.stdout);
// console.log(x.table);


/***/ }),

/***/ 45425:
/*!*********************************************!*\
  !*** ./runestone/activecode/js/livecode.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ 64440);
/* harmony import */ var _extractUnitResults_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extractUnitResults.js */ 69902);
/* harmony import */ var _codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../codelens/js/pytutor-embed.bundle.js */ 71951);
/* harmony import */ var _codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var byte_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! byte-base64 */ 71294);






class LiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        var orig = $(opts.orig).find("textarea")[0];
        super(opts);
        this.stdin = $(orig).data("stdin");
        this.datafile = $(orig).data("datafile");
        this.sourcefile = $(orig).data("sourcefile");
        this.compileargs = unescapeHtml($(orig).data("compileargs"));
        this.linkargs = unescapeHtml($(orig).data("linkargs"));
        this.runargs = unescapeHtml($(orig).data("runargs"));
        this.interpreterargs = unescapeHtml($(orig).data("interpreterargs"));
        this.API_KEY = "67033pV7eUUvqo07OJDIV8UZ049aLEK1";
        this.USE_API_KEY = true;
        this.JOBE_SERVER = eBookConfig.jobehost || eBookConfig.host;
        this.resource = eBookConfig.proxyuri_runs || "/runestone/proxy/jobeRun";
        this.jobePutFiles =
            eBookConfig.proxyuri_files || "/runestone/proxy/jobePushFile/";
        this.jobeCheckFiles =
            eBookConfig.proxyuri_files || "/runestone/proxy/jobeCheckFile/";
        // TODO:  should add a proper put/check in pavement.tmpl as this is misleading and will break on runestone
        this.div2id = {};
        if (this.stdin) {
            this.createInputElement();
        }
        this.createErrorOutput();
    }
    outputfun(a) {}
    createInputElement() {
        var label = document.createElement("label");
        label.for = this.divid + "_stdin";
        $(label).text($.i18n("msg_activecode_input_prg"));
        var input = document.createElement("input");
        input.id = this.divid + "_stdin";
        input.type = "text";
        input.size = "35";
        input.value = this.stdin;
        this.outerDiv.appendChild(label);
        this.outerDiv.appendChild(input);
        this.stdin_el = input;
    }
    createErrorOutput() {}

    /*  Main runProg method for livecode
     *
     */
    async runProg(noUI, logResults) {
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        await this.runSetup();
        try {
            let res = await this.submitToJobe();
            if (!res.ok) {
                this.addJobeErrorMessage(
                    $.i18n(`Server Error: ${res.statusText}`)
                );
                $(this.runButton).removeAttr("disabled");
                return "fail";
            }
            let runResults = await res.json();
            this.processJobeResponse(runResults);
        } catch (e) {
            this.addJobeErrorMessage(
                $.i18n("msg_activecode_server_comm_err") + e.toString()
            );
            $(this.runButton).removeAttr("disabled");
            return `fail: ${e}`;
        }
        return "success";
    }
    /**
     * Note:
     * In order to check for supplemental files in java and deal with asynchronicity
     * I split the original runProg into two functions: runProg and runProg_callback
     */
    async runSetup() {
        var stdin;
        var source;
        var saveCode = "True";
        var sfilemap = {
            java: "",
            cpp: "test.cpp",
            c: "test.c",
            python3: "test.py",
            python2: "test.py",
            octave: "octatest.m",
        };
        var sourcefilename = "";
        var testdrivername = "";
        var file_checkp;

        // extract the class names so files can be named properly
        if (this.suffix && this.language == "java") {
            // the suffix contains unit test code and should include and import of junit
            // import static org.junit.Assert.*;
            // import org.junit.*;
            // import java.io.*;
            if (this.suffix.indexOf("import org.junit") < 0) {
                console.log(`Missing imports in unit tests:
                    ${this.suffix}`);
                // alert("The unit tests for this problem are incomplete, Please report this.");
                this.suffix =
                    `
                import static org.junit.Assert.*;
                import org.junit.*;
                import java.io.*;
                ` + this.suffix;
            }
            let classMatch = new RegExp(/public\s+class\s+(\w+)/);
            source = await this.buildProg(false);
            let m = source.match(classMatch);
            if (m) {
                sourcefilename = m[1] + ".java";
            }
            // this will be unit test code
            m = this.suffix.match(classMatch);
            if (m) {
                testdrivername = m[1] + ".java";
            }
        } else {
            source = await this.buildProg(true);
        }
        // Validate the data is convertible to Base64. If not then error out now
        try {
            btoa(source);
        } catch (e) {
            alert(
                "Error: Bad Characters in the activecode window. Likely a quote character that has been copy/pasted. 🙁"
            );
            return;
        }

        this.saveCode = await this.manage_scrubber(saveCode);

        // assemble parameters for JOBE
        var paramlist = [
            "compileargs",
            "linkargs",
            "runargs",
            "interpreterargs",
            "memorylimit",
        ];
        var paramobj = {};
        for (let param of paramlist) {
            if (this[param]) {
                paramobj[param] = eval(this[param]); // needs a list
            }
        }
        if (this.language === "octave") {
            paramobj.memorylimit = 200000;
        }

        if (this.stdin) {
            stdin = $(this.stdin_el).val();
        }
        if (!this.sourcefile) {
            this.sourcefile = sfilemap[this.language];
        }

        $(this.output).html($.i18n("msg_activecode_compiling_running"));
        var files = [];
        var content, base64;
        if (this.datafile != undefined) {
            var ids = this.datafile.split(",");
            for (var i = 0; i < ids.length; i++) {
                let fileName = ids[i].trim();
                let file = document.getElementById(fileName);
                if (file === null || file === undefined) {
                    file = document.querySelector(
                        '[data-filename="' + fileName + '"]'
                    );
                }
                let fileExtension = fileName.substring(
                    fileName.lastIndexOf(".") + 1
                );
                if (file === null || file === undefined) {
                    // console.log("No file with given id");
                    // check to see if file is in db
                    content = this.fileReader(fileName);
                } else {
                    content = file.textContent;
                    // may be undefined at this point if file is an image
                }
                if (fileExtension === "jar") {
                    files = files.concat(this.parseJavaClasses(content));
                } else if (["jpg", "png", "gif"].indexOf(fileExtension) > -1) {
                    if (file) {
                        if (file.toDataURL) {
                            base64 = file.toDataURL("image/" + fileExtension);
                            base64 = base64.substring(base64.indexOf(",") + 1);
                        } else {
                            base64 = file.src.substring(
                                file.src.indexOf(",") + 1
                            );
                        }
                    } else {
                        base64 = content;
                    }
                    files.push({ name: fileName, content: base64 });
                } else {
                    // if no className or un recognized className it is treated as an individual file
                    // this could be any type of file, .txt, .java, .csv, etc
                    files.push({ name: fileName, content: content });
                }
            }
        }
        // If we are running unit tests we need to substitute the test driver for the student
        // code and send the student code as a file.  We'll do that here.
        this.junitDriverCode = `
        import org.junit.runner.JUnitCore;
        import org.junit.runner.Result;
        import org.junit.runner.notification.Failure;

        public class TestRunner {
            public static void main(String[] args) {
                CodeTestHelper.resetFinalResults();
                Result result = JUnitCore.runClasses(${testdrivername.replace(
                    ".java",
                    ".class"
                )});
                System.out.println(CodeTestHelper.getFinalResults());

                int total = result.getRunCount();
                int fails = result.getFailureCount();
                int corr  = total - fails;
                System.out.println("You got " + corr + " out of " + total + " correct. " + String.format("%.2f", (100.0 * corr / total)) + "%");
            }
        }
        `;
        if (this.suffix && this.language == "java") {
            files.push({ name: sourcefilename, content: source });
            files.push({ name: testdrivername, content: this.suffix });
            source = this.junitDriverCode;
            if (paramobj.compileargs) {
                paramobj.compileargs.push(sourcefilename);
            } else {
                paramobj.compileargs = [sourcefilename];
            }
        }
        let runspec = {
            language_id: this.language,
            sourcecode: source,
            parameters: paramobj,
            sourcefilename: this.sourcefile,
        };

        if (stdin) {
            runspec.input = stdin;
        }
        if (files.length === 0) {
            this.json_runspec = JSON.stringify({ run_spec: runspec });
            file_checkp = Promise.resolve("ready");
        } else {
            runspec["file_list"] = [];
            var promises = [];
            var instance = this;

            for (let i = 0; i < files.length; i++) {
                var fileName = files[i].name;
                var fileContent = files[i].content;
                instance.div2id[fileName] =
                    "runestone" + (0,_md5_js__WEBPACK_IMPORTED_MODULE_1__["default"])(fileName + fileContent);
                runspec["file_list"].push([
                    instance.div2id[fileName],
                    fileName,
                ]);
                promises.push(
                    new Promise((resolve, reject) => {
                        instance.checkFile(files[i], resolve, reject);
                    })
                );
            }
            this.json_runspec = JSON.stringify({ run_spec: runspec });
            this.div2id = instance.div2id;
            file_checkp = Promise.all(promises).catch(function (err) {
                console.log("Error: " + err);
            });
        }
        return file_checkp;
    }

    /* Submit the assembled job to the JOBE server and await the results.
     *
     */
    async submitToJobe() {
        var data = this.json_runspec;
        let host = this.JOBE_SERVER + this.resource;
        $(this.runButton).attr("disabled", "disabled");
        $(this.outDiv).show({ duration: 700, queue: false });
        $(this.errDiv).remove();
        $(this.output).css("visibility", "visible");

        let headers = new Headers({
            "Content-type": "application/json; charset=utf-8",
            Accept: "application/json",
            "X-API-KEY": this.API_KEY,
        });
        let request = new Request(host, {
            method: "POST",
            headers: headers,
            body: data,
        });
        return fetch(request);

        ///$("#" + divid + "_errinfo").remove();
    }

    processJobeResponse(result) {
        var logresult;
        var odiv = this.output;
        this.parsedOutput = {};
        $(this.runButton).removeAttr("disabled");
        if (result.outcome === 15) {
            logresult = "success";
        } else {
            logresult = result.outcome;
        }
        this.errinfo = logresult;
        switch (result.outcome) {
            case 15: {
                this.parsedOutput = new _extractUnitResults_js__WEBPACK_IMPORTED_MODULE_2__["default"](
                    result.stdout,
                    this.divid
                );
                $(odiv).html(this.parsedOutput.stdout);
                if (this.suffix) {
                    if (this.parsedOutput.pct === undefined) {
                        this.parsedOutput.pct =
                            this.parsedOutput.passed =
                            this.parsedOutput.failed =
                                0;
                    }
                    this.unit_results = `percent:${this.parsedOutput.pct}:passed:${this.parsedOutput.passed}:failed:${this.parsedOutput.failed}`;
                }
                break;
            }
            case 11: // compiler error
                $(odiv).html($.i18n("msg_activecode_were_compiling_err"));
                this.addJobeErrorMessage(result.cmpinfo);
                this.errinfo = result.cmpinfo;
                break;
            case 12: // run time error
                $(odiv).html(result.stdout.replace(/\n/g, "<br>"));
                if (result.stderr) {
                    this.addJobeErrorMessage(result.stderr);
                }
                break;
            case 13: // time limit
                $(odiv).html(escapeHtml(result.stdout.replace(/\n/g, "<br>")));
                this.addJobeErrorMessage(
                    $.i18n("msg_activecode_time_limit_exc")
                );
                break;
            default:
                if (result.stderr) {
                    $(odiv).html(result.stderr.replace(/\n/g, "<br>"));
                } else {
                    this.addJobeErrorMessage(
                        $.i18n("msg_activecode_server_err")
                    );
                }
        }
        // todo: handle server busy and timeout errors too
    }

    renderFeedback() {
        let rdiv = document.getElementById(`${this.divid}_unit_results`);
        if (rdiv) {
            rdiv.remove();
        }
        if (this.parsedOutput && this.parsedOutput.table) {
            this.outDiv.appendChild(this.parsedOutput.table);
        }
        rdiv = document.getElementById(`${this.divid}_unit_results`);
        if (rdiv) {
            rdiv.appendChild(this.parsedOutput.pctString);
        }
    }

    addJobeErrorMessage(err) {
        var errHead = $("<h3>").html("Error");
        var eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.errDiv = eContainer;
        eContainer.className = "error alert alert-danger";
        eContainer.id = this.divid + "_errinfo";
        eContainer.appendChild(errHead[0]);
        var errText = eContainer.appendChild(document.createElement("pre"));
        errText.innerHTML = escapeHtml(err);
    }
    /**
     * Checks to see if file is on server
     * Places it on server if it is not on server
     * @param  {object{name, contents}} file    File to place on server
     * @param  {function} resolve promise resolve function
     * @param  {function} reject  promise reject function
     */
    checkFile(file, resolve, reject) {
        var file_id = this.div2id[file.name];
        var resource = this.jobeCheckFiles + file_id;
        var host = this.JOBE_SERVER + resource;
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", host, true);
        xhr.setRequestHeader("Content-type", "application/json");
        xhr.setRequestHeader("Accept", "text/plain");
        xhr.setRequestHeader("X-API-KEY", this.API_KEY);
        xhr.onerror = function () {
            // console.log("error sending file" + xhr.responseText);
        };
        xhr.onload = function () {
            switch (xhr.status) {
                case 208:
                case 404:
                    // console.log("File not on Server");
                    this.pushDataFile(file, resolve, reject);
                    break;
                case 400:
                    // console.log("Bad Request");
                    reject();
                    break;
                case 204:
                    // console.log("File already on Server");
                    resolve();
                    break;
                default:
                    //console.log("This case should never happen");
                    reject();
            }
        }.bind(this);
        xhr.send();
    }
    /**
     * Places a file on a server
     */
    pushDataFile(file, resolve, reject) {
        var fileName = file.name;
        var extension = fileName.substring(fileName.indexOf(".") + 1);
        var file_id = this.div2id[fileName];
        var contents = file.content;
        // File types being uploaded that come in already in base64 format
        var extensions = ["jar", "zip", "png", "jpg", "jpeg"];
        var contentsb64;
        if (extensions.indexOf(extension) === -1) {
            contentsb64 = (0,byte_base64__WEBPACK_IMPORTED_MODULE_4__.base64encode)(contents);
        } else {
            contentsb64 = contents;
        }
        var data = JSON.stringify({ file_contents: contentsb64 });
        var resource = this.jobePutFiles + file_id;
        var host = this.JOBE_SERVER + resource;
        var xhr = new XMLHttpRequest();
        xhr.open("PUT", host, true);
        xhr.setRequestHeader("Content-type", "application/json");
        xhr.setRequestHeader("Accept", "text/plain");
        xhr.setRequestHeader("X-API-KEY", this.API_KEY);
        xhr.onload = function () {
            switch (xhr.status) {
                case 403:
                    // console.log("Forbidden");
                    reject();
                    break;
                case 400:
                    // console.log("Bad Request");
                    reject();
                    break;
                case 204:
                    //console.log("successfully sent file " + xhr.responseText);
                    //console.log("File " + fileName +", " + file_id +" placed on server");
                    resolve();
                    break;
                default:
                    // console.log("This case should never happen");
                    reject();
            }
        }.bind(this);
        xhr.onerror = function () {
            // console.log("error sending file" + xhr.responseText);
            reject();
        };
        xhr.send(data);
    }

    async showCodelens() {
        let clMess = "";
        if (this.codelens.style.display == "none") {
            this.codelens.style.display = "block";
            clMess = "Building your visualization";
            this.codelens.innerHTML = clMess;
            this.clButton.innerText = $.i18n("msg_activecode_hide_codelens");
        } else {
            this.codelens.style.display = "none";
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
            return;
        }
        var cl = this.codelens.firstChild;
        if (cl) {
            this.codelens.removeChild(cl);
            this.codelens.innerHTML = clMess;
        }
        var code = await this.buildProg(false);
        if (code.match(/System.exit/)) {
            alert(
                "Sorry... System.exit breaks the visualizer temporarily removing"
            );
            code = code.replace(/System.exit\(\d+\);/, "");
        }
        var myVars = {};
        myVars.code = code;
        myVars.lang = this.language;
        if (this.stdin) {
            myVars.stdin = $(this.stdin_el).val();
        }
        var targetDiv = this.codelens.id;

        let request = new Request("/runestone/proxy/pytutor_trace", {
            method: "POST",
            body: JSON.stringify(myVars),
            headers: this.jsonHeaders,
        });
        try {
            let response = await fetch(request);
            let data = await response.json();
            let vis = addVisualizerToPage(data, targetDiv, {
                startingInstruction: 0,
                editCodeBaseURL: null,
                hideCode: false,
                lang: myVars.lang,
            });
        } catch (error) {
            let targetDivError = document.getElementById(targetDiv);
            targetDivError.innerHTML =
                "Sorry, an error occurred while creating your visualization.";
            console.log("Get Trace Failed -- ");
            console.log(error);
        }

        this.logBookEvent({
            event: "codelens",
            act: "view",
            div_id: this.divid,
        });
    }

    /**
     * Seperates text into multiple .java files
     * @param  {String} text String with muliple java classes needed to be seperated
     * @return {array of objects}  .name gives the name of the java file with .java extension
     *                   .content gives the contents of the file
     */
    parseJavaClasses(text) {
        text = text.trim();
        var found = false;
        var stack = 0;
        var startIndex = 0;
        var classes = [];
        var importIndex = 0;
        var endOfLastCommentBeforeClassBegins = 0;
        for (var i = 0; i < text.length; i++) {
            var char = text.charAt(i);
            if (char === "/") {
                i++;
                if (text.charAt(i) === "/") {
                    i++;
                    while (text.charAt(i) !== "\n" && i < text.length) {
                        i++;
                    }
                    if (!found) {
                        endOfLastCommentBeforeClassBegins = i;
                    }
                } else if (text.charAt(i) == "*") {
                    i++;
                    while (
                        (text.charAt(i) !== "*" ||
                            text.charAt(i + 1) !== "/") &&
                        i + 1 < text.length
                    ) {
                        i++;
                    }
                    if (!found) {
                        endOfLastCommentBeforeClassBegins = i;
                    }
                }
            } else if (char === '"') {
                i++;
                while (text.charAt(i) !== '"' && i < text.length) {
                    i++;
                }
            } else if (char === "'") {
                while (text.charAt(i) !== "'" && i < text.length) {
                    i++;
                }
            } else if (char === "(") {
                var pCount = 1;
                i++;
                while (pCount > 0 && i < text.length) {
                    if (text.charAt(i) === "(") {
                        pCount++;
                    } else if (text.charAt(i) === ")") {
                        pCount--;
                    }
                    i++;
                }
            }
            if (!found && text.charAt(i) === "{") {
                startIndex = i;
                found = true;
                stack = 1;
            } else if (found) {
                if (text.charAt(i) === "{") {
                    stack++;
                }
                if (text.charAt(i) === "}") {
                    stack--;
                }
            }
            if (found && stack === 0) {
                let endIndex = i + 1;
                var words = text
                    .substring(endOfLastCommentBeforeClassBegins, startIndex)
                    .trim()
                    .split(" ");
                var className = "";
                for (var w = 0; w < words.length; w++) {
                    className = words[w];
                    if (words[w] === "extends" || words[w] === "implements") {
                        className = words[w - 1];
                        w = words.length;
                    }
                }
                className = className.trim() + ".java";
                classes.push({
                    name: className,
                    content: text.substring(importIndex, endIndex),
                });
                found = false;
                importIndex = endIndex;
                endOfLastCommentBeforeClassBegins = endIndex;
            }
        }
        return classes;
    }
}
function unescapeHtml(safe) {
    if (safe) {
        return safe
            .replace(/&amp;/g, "&")
            .replace(/&lt;/g, "<")
            .replace(/&gt;/g, ">")
            .replace(/&quot;/g, '"')
            .replace(/&#x27;/g, "'");
    }
}
function escapeHtml(str) {
    if (str) {
	return str
	    .replace(/&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/'/g, '&#x27;')
	    .replace(/"/g, '&quot;');
    }
}


/***/ }),

/***/ 64440:
/*!****************************************!*\
  !*** ./runestone/activecode/js/md5.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MD5)
/* harmony export */ });
/**
 *
 *  MD5 (Message-Digest Algorithm)
 *  http://www.webtoolkit.info/
 *
 **/

function MD5(string) {
    function RotateLeft(lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    }

    function AddUnsigned(lX, lY) {
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = lX & 0x80000000;
        lY8 = lY & 0x80000000;
        lX4 = lX & 0x40000000;
        lY4 = lY & 0x40000000;
        lResult = (lX & 0x3fffffff) + (lY & 0x3fffffff);
        if (lX4 & lY4) {
            return lResult ^ 0x80000000 ^ lX8 ^ lY8;
        }
        if (lX4 | lY4) {
            if (lResult & 0x40000000) {
                return lResult ^ 0xc0000000 ^ lX8 ^ lY8;
            } else {
                return lResult ^ 0x40000000 ^ lX8 ^ lY8;
            }
        } else {
            return lResult ^ lX8 ^ lY8;
        }
    }

    function F(x, y, z) {
        return (x & y) | (~x & z);
    }

    function G(x, y, z) {
        return (x & z) | (y & ~z);
    }

    function H(x, y, z) {
        return x ^ y ^ z;
    }

    function I(x, y, z) {
        return y ^ (x | ~z);
    }

    function FF(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function GG(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function HH(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function II(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function ConvertToWordArray(string) {
        var lWordCount;
        var lMessageLength = string.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 =
            (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount < lMessageLength) {
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] =
                lWordArray[lWordCount] |
                (string.charCodeAt(lByteCount) << lBytePosition);
            lByteCount++;
        }
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] =
            lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
    }

    function WordToHex(lValue) {
        var WordToHexValue = "",
            WordToHexValue_temp = "",
            lByte,
            lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
            lByte = (lValue >>> (lCount * 8)) & 255;
            WordToHexValue_temp = "0" + lByte.toString(16);
            WordToHexValue =
                WordToHexValue +
                WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        }
        return WordToHexValue;
    }

    function Utf8Encode(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if (c > 127 && c < 2048) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }

        return utftext;
    }

    var x = Array();
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7,
        S12 = 12,
        S13 = 17,
        S14 = 22;
    var S21 = 5,
        S22 = 9,
        S23 = 14,
        S24 = 20;
    var S31 = 4,
        S32 = 11,
        S33 = 16,
        S34 = 23;
    var S41 = 6,
        S42 = 10,
        S43 = 15,
        S44 = 21;

    string = Utf8Encode(string);

    x = ConvertToWordArray(string);

    a = 0x67452301;
    b = 0xefcdab89;
    c = 0x98badcfe;
    d = 0x10325476;

    for (k = 0; k < x.length; k += 16) {
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = FF(a, b, c, d, x[k + 0], S11, 0xd76aa478);
        d = FF(d, a, b, c, x[k + 1], S12, 0xe8c7b756);
        c = FF(c, d, a, b, x[k + 2], S13, 0x242070db);
        b = FF(b, c, d, a, x[k + 3], S14, 0xc1bdceee);
        a = FF(a, b, c, d, x[k + 4], S11, 0xf57c0faf);
        d = FF(d, a, b, c, x[k + 5], S12, 0x4787c62a);
        c = FF(c, d, a, b, x[k + 6], S13, 0xa8304613);
        b = FF(b, c, d, a, x[k + 7], S14, 0xfd469501);
        a = FF(a, b, c, d, x[k + 8], S11, 0x698098d8);
        d = FF(d, a, b, c, x[k + 9], S12, 0x8b44f7af);
        c = FF(c, d, a, b, x[k + 10], S13, 0xffff5bb1);
        b = FF(b, c, d, a, x[k + 11], S14, 0x895cd7be);
        a = FF(a, b, c, d, x[k + 12], S11, 0x6b901122);
        d = FF(d, a, b, c, x[k + 13], S12, 0xfd987193);
        c = FF(c, d, a, b, x[k + 14], S13, 0xa679438e);
        b = FF(b, c, d, a, x[k + 15], S14, 0x49b40821);
        a = GG(a, b, c, d, x[k + 1], S21, 0xf61e2562);
        d = GG(d, a, b, c, x[k + 6], S22, 0xc040b340);
        c = GG(c, d, a, b, x[k + 11], S23, 0x265e5a51);
        b = GG(b, c, d, a, x[k + 0], S24, 0xe9b6c7aa);
        a = GG(a, b, c, d, x[k + 5], S21, 0xd62f105d);
        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = GG(c, d, a, b, x[k + 15], S23, 0xd8a1e681);
        b = GG(b, c, d, a, x[k + 4], S24, 0xe7d3fbc8);
        a = GG(a, b, c, d, x[k + 9], S21, 0x21e1cde6);
        d = GG(d, a, b, c, x[k + 14], S22, 0xc33707d6);
        c = GG(c, d, a, b, x[k + 3], S23, 0xf4d50d87);
        b = GG(b, c, d, a, x[k + 8], S24, 0x455a14ed);
        a = GG(a, b, c, d, x[k + 13], S21, 0xa9e3e905);
        d = GG(d, a, b, c, x[k + 2], S22, 0xfcefa3f8);
        c = GG(c, d, a, b, x[k + 7], S23, 0x676f02d9);
        b = GG(b, c, d, a, x[k + 12], S24, 0x8d2a4c8a);
        a = HH(a, b, c, d, x[k + 5], S31, 0xfffa3942);
        d = HH(d, a, b, c, x[k + 8], S32, 0x8771f681);
        c = HH(c, d, a, b, x[k + 11], S33, 0x6d9d6122);
        b = HH(b, c, d, a, x[k + 14], S34, 0xfde5380c);
        a = HH(a, b, c, d, x[k + 1], S31, 0xa4beea44);
        d = HH(d, a, b, c, x[k + 4], S32, 0x4bdecfa9);
        c = HH(c, d, a, b, x[k + 7], S33, 0xf6bb4b60);
        b = HH(b, c, d, a, x[k + 10], S34, 0xbebfbc70);
        a = HH(a, b, c, d, x[k + 13], S31, 0x289b7ec6);
        d = HH(d, a, b, c, x[k + 0], S32, 0xeaa127fa);
        c = HH(c, d, a, b, x[k + 3], S33, 0xd4ef3085);
        b = HH(b, c, d, a, x[k + 6], S34, 0x4881d05);
        a = HH(a, b, c, d, x[k + 9], S31, 0xd9d4d039);
        d = HH(d, a, b, c, x[k + 12], S32, 0xe6db99e5);
        c = HH(c, d, a, b, x[k + 15], S33, 0x1fa27cf8);
        b = HH(b, c, d, a, x[k + 2], S34, 0xc4ac5665);
        a = II(a, b, c, d, x[k + 0], S41, 0xf4292244);
        d = II(d, a, b, c, x[k + 7], S42, 0x432aff97);
        c = II(c, d, a, b, x[k + 14], S43, 0xab9423a7);
        b = II(b, c, d, a, x[k + 5], S44, 0xfc93a039);
        a = II(a, b, c, d, x[k + 12], S41, 0x655b59c3);
        d = II(d, a, b, c, x[k + 3], S42, 0x8f0ccc92);
        c = II(c, d, a, b, x[k + 10], S43, 0xffeff47d);
        b = II(b, c, d, a, x[k + 1], S44, 0x85845dd1);
        a = II(a, b, c, d, x[k + 8], S41, 0x6fa87e4f);
        d = II(d, a, b, c, x[k + 15], S42, 0xfe2ce6e0);
        c = II(c, d, a, b, x[k + 6], S43, 0xa3014314);
        b = II(b, c, d, a, x[k + 13], S44, 0x4e0811a1);
        a = II(a, b, c, d, x[k + 4], S41, 0xf7537e82);
        d = II(d, a, b, c, x[k + 11], S42, 0xbd3af235);
        c = II(c, d, a, b, x[k + 2], S43, 0x2ad7d2bb);
        b = II(b, c, d, a, x[k + 9], S44, 0xeb86d391);
        a = AddUnsigned(a, AA);
        b = AddUnsigned(b, BB);
        c = AddUnsigned(c, CC);
        d = AddUnsigned(d, DD);
    }

    var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);

    return temp.toLowerCase();
}


/***/ }),

/***/ 55409:
/*!**************************************************!*\
  !*** ./runestone/activecode/js/skulpt-stdlib.js ***!
  \**************************************************/
/***/ (() => {

Sk.builtinFiles={"files":{"src/builtin/this.py":"s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint(\"\".join([d.get(c, c) for c in s]))\n","src/lib/BaseHTTPServer.py":"import _sk_fail; _sk_fail._(\"BaseHTTPServer\")\n","src/lib/Bastion.py":"import _sk_fail; _sk_fail._(\"Bastion\")\n","src/lib/CGIHTTPServer.py":"import _sk_fail; _sk_fail._(\"CGIHTTPServer\")\n","src/lib/ConfigParser.py":"import _sk_fail; _sk_fail._(\"ConfigParser\")\n","src/lib/Cookie.py":"import _sk_fail; _sk_fail._(\"Cookie\")\n","src/lib/DocXMLRPCServer.py":"import _sk_fail; _sk_fail._(\"DocXMLRPCServer\")\n","src/lib/HTMLParser.py":"import _sk_fail; _sk_fail._(\"HTMLParser\")\n","src/lib/MimeWriter.py":"import _sk_fail; _sk_fail._(\"MimeWriter\")\n","src/lib/Queue.py":"import _sk_fail; _sk_fail._(\"Queue\")\n","src/lib/SimpleHTTPServer.py":"import _sk_fail; _sk_fail._(\"SimpleHTTPServer\")\n","src/lib/SimpleXMLRPCServer.py":"import _sk_fail; _sk_fail._(\"SimpleXMLRPCServer\")\n","src/lib/SocketServer.py":"import _sk_fail; _sk_fail._(\"SocketServer\")\n","src/lib/StringIO.py":"r\"\"\"File-like objects that read from or write to a string buffer.\n\nThis implements (nearly) all stdio methods.\n\nf = StringIO()      # ready for writing\nf = StringIO(buf)   # ready for reading\nf.close()           # explicitly release resources held\nflag = f.isatty()   # always false\npos = f.tell()      # get current position\nf.seek(pos)         # set current position\nf.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF\nbuf = f.read()      # read until EOF\nbuf = f.read(n)     # read up to n bytes\nbuf = f.readline()  # read until end of line ('\\n') or EOF\nlist = f.readlines()# list of f.readline() results until EOF\nf.truncate([size])  # truncate file at to at most size (default: current pos)\nf.write(buf)        # write at current position\nf.writelines(list)  # for line in list: f.write(line)\nf.getvalue()        # return whole file's contents as a string\n\nNotes:\n- Using a real file is often faster (but less convenient).\n- There's also a much faster implementation in C, called cStringIO, but\n  it's not subclassable.\n- fileno() is left unimplemented so that code which uses it triggers\n  an exception early.\n- Seeking far beyond EOF and then writing will insert real null\n  bytes that occupy space in the buffer.\n- There's a simple test set (see end of this file).\n\"\"\"\n\n__all__ = [\"StringIO\"]\n\ndef _complain_ifclosed(closed):\n    if closed:\n        raise ValueError(\"I/O operation on closed file\")\n\nclass StringIO:\n    \"\"\"class StringIO([buffer])\n\n    When a StringIO object is created, it can be initialized to an existing\n    string by passing the string to the constructor. If no string is given,\n    the StringIO will start empty.\n\n    The StringIO object can accept either Unicode or 8-bit strings, but\n    mixing the two may take some care. If both are used, 8-bit strings that\n    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause\n    a UnicodeError to be raised when getvalue() is called.\n    \"\"\"\n    def __init__(self, buf = ''):\n        # Force self.buf to be a string or unicode\n        if not isinstance(buf, str):\n            buf = str(buf)\n        self.buf = buf\n        self.len = len(buf)\n        self.buflist = []\n        self.pos = 0\n        self.closed = False\n        self.softspace = 0\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"A file object is its own iterator, for example iter(f) returns f\n        (unless f is closed). When a file is used as an iterator, typically\n        in a for loop (for example, for line in f: print line), the next()\n        method is called repeatedly. This method returns the next input line,\n        or raises StopIteration when EOF is hit.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        r = self.readline()\n        if not r:\n            raise StopIteration\n        return r\n\n    def close(self):\n        \"\"\"Free the memory buffer.\n        \"\"\"\n        if not self.closed:\n            self.closed = True\n            self.buf = None\n            self.pos = None\n\n    def isatty(self):\n        \"\"\"Returns False because StringIO objects are not connected to a\n        tty-like device.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        return False\n\n    def seek(self, pos, mode = 0):\n        \"\"\"Set the file's current position.\n\n        The mode argument is optional and defaults to 0 (absolute file\n        positioning); other values are 1 (seek relative to the current\n        position) and 2 (seek relative to the file's end).\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if mode == 1:\n            pos += self.pos\n        elif mode == 2:\n            pos += self.len\n        self.pos = max(0, pos)\n\n    def tell(self):\n        \"\"\"Return the file's current position.\"\"\"\n        _complain_ifclosed(self.closed)\n        return self.pos\n\n    def read(self, n = -1):\n        \"\"\"Read at most size bytes from the file\n        (less if the read hits EOF before obtaining size bytes).\n\n        If the size argument is negative or omitted, read all data until EOF\n        is reached. The bytes are returned as a string object. An empty\n        string is returned when EOF is encountered immediately.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if n is None or n < 0:\n            newpos = self.len\n        else:\n            newpos = min(self.pos+n, self.len)\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readline(self, length=None):\n        r\"\"\"Read one entire line from the file.\n\n        A trailing newline character is kept in the string (but may be absent\n        when a file ends with an incomplete line). If the size argument is\n        present and non-negative, it is a maximum byte count (including the\n        trailing newline) and an incomplete line may be returned.\n\n        An empty string is returned only when EOF is encountered immediately.\n\n        Note: Unlike stdio's fgets(), the returned string contains null\n        characters ('\\0') if they occurred in the input.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        i = self.buf.find('\\n', self.pos)\n        if i < 0:\n            newpos = self.len\n        else:\n            newpos = i+1\n        if length is not None and length >= 0:\n            if self.pos + length < newpos:\n                newpos = self.pos + length\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readlines(self, sizehint = 0):\n        \"\"\"Read until EOF using readline() and return a list containing the\n        lines thus read.\n\n        If the optional sizehint argument is present, instead of reading up\n        to EOF, whole lines totalling approximately sizehint bytes (or more\n        to accommodate a final whole line).\n        \"\"\"\n        total = 0\n        lines = []\n        line = self.readline()\n        while line:\n            lines.append(line)\n            total += len(line)\n            if 0 < sizehint <= total:\n                break\n            line = self.readline()\n        return lines\n\n    def truncate(self, size=None):\n        \"\"\"Truncate the file's size.\n\n        If the optional size argument is present, the file is truncated to\n        (at most) that size. The size defaults to the current position.\n        The current file position is not changed unless the position\n        is beyond the new file size.\n\n        If the specified size exceeds the file's current size, the\n        file remains unchanged.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if size is None:\n            size = self.pos\n        elif size < 0:\n            raise IOError(22, \"Negative size not allowed\")\n        elif size < self.pos:\n            self.pos = size\n        self.buf = self.getvalue()[:size]\n        self.len = size\n\n    def write(self, s):\n        \"\"\"Write a string to the file.\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if not s: return\n        # Force s to be a string or unicode\n        if not isinstance(s, str):\n            s = str(s)\n        spos = self.pos\n        slen = self.len\n        if spos == slen:\n            self.buflist.append(s)\n            self.len = self.pos = spos + len(s)\n            return\n        if spos > slen:\n            self.buflist.append('\\0'*(spos - slen))\n            slen = spos\n        newpos = spos + len(s)\n        if spos < slen:\n            if self.buflist:\n                self.buf += ''.join(self.buflist)\n            self.buflist = [self.buf[:spos], s, self.buf[newpos:]]\n            self.buf = ''\n            if newpos > slen:\n                slen = newpos\n        else:\n            self.buflist.append(s)\n            slen = newpos\n        self.len = slen\n        self.pos = newpos\n\n    def writelines(self, iterable):\n        \"\"\"Write a sequence of strings to the file. The sequence can be any\n        iterable object producing strings, typically a list of strings. There\n        is no return value.\n\n        (The name is intended to match readlines(); writelines() does not add\n        line separators.)\n        \"\"\"\n        write = self.write\n        for line in iterable:\n            write(line)\n\n    def flush(self):\n        \"\"\"Flush the internal buffer\n        \"\"\"\n        _complain_ifclosed(self.closed)\n\n    def getvalue(self):\n        \"\"\"\n        Retrieve the entire contents of the \"file\" at any time before\n        the StringIO object's close() method is called.\n\n        The StringIO object can accept either Unicode or 8-bit strings,\n        but mixing the two may take some care. If both are used, 8-bit\n        strings that cannot be interpreted as 7-bit ASCII (that use the\n        8th bit) will cause a UnicodeError to be raised when getvalue()\n        is called.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        return self.buf\n","src/lib/UserDict.py":"import _sk_fail; _sk_fail._(\"UserDict\")\n","src/lib/UserList.py":"import _sk_fail; _sk_fail._(\"UserList\")\n","src/lib/UserString.py":"import _sk_fail; _sk_fail._(\"UserString\")\n","src/lib/_LWPCookieJar.py":"import _sk_fail; _sk_fail._(\"_LWPCookieJar\")\n","src/lib/_MozillaCookieJar.py":"import _sk_fail; _sk_fail._(\"_MozillaCookieJar\")\n","src/lib/__future__.py":"import _sk_fail;_sk_fail._(\"__future__\")\n","src/lib/__phello__.foo.py":"import _sk_fail; _sk_fail._(\"__phello__.foo\")\n","src/lib/_abcoll.py":"import _sk_fail; _sk_fail._(\"_abcoll\")\n","src/lib/_sk_fail.py":"class NotImplementedImportError(ImportError, NotImplementedError): pass\n\ndef _(name):\n    msg = \"{} is not yet implemented in Skulpt\".format(name)\n    raise NotImplementedImportError(msg, name=name)\n","src/lib/_threading_local.py":"import _sk_fail; _sk_fail._(\"_threading_local\")\n","src/lib/abc.py":"import _sk_fail; _sk_fail._(\"abc\")\n","src/lib/aifc.py":"import _sk_fail; _sk_fail._(\"aifc\")\n","src/lib/altair/__init__.py":"import random\n\ntry:\n    from vega_caller import render_graph\nexcept:\n    print(\"Mock render\")\n\n    def render_graph(js):\n        print(js)\n\n\nclass Chart:\n    # TODO allow data to be specified as a URL to a CSV or DB or json\n    def __init__(self, data, title=None):\n        self.title = title\n        self.data_id = random.randrange(1000000, 5000000)\n        self.dsname = \"data-{}\".format(self.data_id)\n        if isinstance(data, dict):\n            self.data = Data(**data)\n        else:\n            self.data = data\n\n        self.json = {}\n        self.json[\"$schema\"] = \"https://vega.github.io/schema/vega-lite/v2.5.json\"\n        self.json[\"data\"] = {}\n        if self.title:\n            self.json[\"title\"] = self.title\n\n        self.json[\"data\"] = {\"values\": self.data.vals}\n        self.is_composite = False\n\n    # mark can be a simple string or a dictionary\n    # \"mark\": {\"color\": \"green\", \"opacity\": 0.2, \"type\": \"rect\"}\n\n    def mark_json(self, mark_type, **kwargs):\n        if kwargs:\n            self.json[\"mark\"] = {}\n            self.json[\"mark\"][\"type\"] = mark_type\n            self.json[\"mark\"].update(kwargs)\n        else:\n            self.json[\"mark\"] = mark_type\n\n        return self\n\n    def mark_bar(self, **kwargs):\n        return self.mark_json(\"bar\", **kwargs)\n\n    def mark_point(self, **kwargs):\n        return self.mark_json(\"point\", **kwargs)\n\n    def mark_line(self, **kwargs):\n        return self.mark_json(\"line\", **kwargs)\n\n    def mark_rect(self, **kwargs):\n        return self.mark_json(\"rect\", **kwargs)\n\n    def mark_area(self, **kwargs):\n        return self.mark_json(\"area\", **kwargs)\n\n    def mark_tick(self, **kwargs):\n        return self.mark_json(\"tick\", **kwargs)\n\n    def encode(self, x=\"\", y=\"\", color=\"\", size=\"\", tooltip=\"\"):\n        self.encoding = {}\n        if x:\n            if isinstance(x, Axis):\n                self.encoding[\"x\"] = x.toJson()\n            else:\n                self.encoding[\"x\"] = Axis(x).toJson()\n        if y:\n            if isinstance(y, Axis):\n                self.encoding[\"y\"] = y.toJson()\n            else:\n                self.encoding[\"y\"] = Axis(y).toJson()\n\n        # \"color\": {\"type\": \"nominal\", \"field\": \"species\"}\n        if color:\n            field, tp = _get_name_type(color)\n            self.encoding[\"color\"] = dict(type=tp, field=field)\n\n        # \"size\": {\"type\": \"quantitative\", \"field\": \"Acceleration\"}\n        if size:\n            field, tp = _get_name_type(size)\n            self.encoding[\"size\"] = dict(type=tp, field=field)\n\n        if tooltip:\n            field, tp = _get_name_type(tooltip)\n            self.encoding[\"tooltip\"] = dict(type=tp, field=field)\n\n        self.json[\"encoding\"] = self.encoding\n        return self\n\n    def interactive(self):\n        iconfig = {\n            \"selector002\": {\n                \"type\": \"interval\",\n                \"bind\": \"scales\",\n                \"encodings\": [\"x\", \"y\"],\n                \"on\": \"[mousedown, window:mouseup] > window:mousemove!\",\n                \"translate\": \"[mousedown, window:mouseup] > window:mousemove!\",\n                \"zoom\": \"wheel!\",\n                \"mark\": {\"fill\": \"#333\", \"fillOpacity\": 0.125, \"stroke\": \"white\"},\n                \"resolve\": \"global\",\n            }\n        }\n        self.json[\"selection\"] = iconfig\n        return self\n\n    def display(self):\n        render_graph(self.json)\n\n    def __add__(self, other):\n        return self.add_layer(other, \"layer\")\n\n    def __and__(self, other):\n        return self.add_layer(other, \"vconcat\")\n\n    def __or__(self, other):\n        return self.add_layer(other, \"hconcat\")\n\n    def add_layer(self, other, lname):\n        # multle layers are added by concatenating the new element to the\n        # existing layer.  If the layer does not exist then initialize\n        # it from self.\n        if lname not in self.json:\n            self.json[lname] = []\n            self.json[\"datasets\"] = {}\n            temp = {}\n            temp[\"data\"] = {\"name\": self.dsname}\n            self.json[\"datasets\"][self.dsname] = self.json[\"data\"][\"values\"]\n            del self.json[\"data\"]\n            temp[\"encoding\"] = self.json[\"encoding\"]\n            del self.json[\"encoding\"]\n            temp[\"mark\"] = self.json[\"mark\"]\n            del self.json[\"mark\"]\n            self.json[lname].append(temp)\n        temp = {}\n        self.json[\"datasets\"][other.dsname] = other.json[\"data\"][\"values\"]\n        temp[\"data\"] = {\"name\": other.dsname}\n        temp[\"encoding\"] = other.json[\"encoding\"]\n        temp[\"mark\"] = other.json[\"mark\"]\n        self.json[lname].append(temp)\n        return self\n\n\n#   \"datasets\": {\n#     \"data-e56e43354d9b8f2ab0d1e90cf27cd47f\": [\n#       {\"a\": 4, \"b\": 1, \"c\": \"r\"},\n#       {\"a\": 5, \"b\": 2, \"c\": \"g\"},\n#       {\"a\": 6, \"b\": 3, \"c\": \"b\"}\n#     ],\n#     \"data-a4c3047a15bf9380c2e615cf87648369\": [\n#       {\"a\": 1, \"b\": 4, \"c\": \"r\"},\n#       {\"a\": 2, \"b\": 5, \"c\": \"g\"},\n#       {\"a\": 3, \"b\": 6, \"c\": \"b\"}\n#     ]\n#   }\n\n# TODO:  add a rect mark type for a heat map\n\n\ndef _get_name_type(name):\n    typed = {\"Q\": \"quantitative\", \"O\": \"ordinal\", \"N\": \"nominal\", \"T\": \"temporal\"}\n    nt = name.split(\":\")\n    tstring = \"quantitative\"\n    if len(nt) == 2:\n        tstring = typed[nt[1]]\n    return nt[0], tstring\n\n\nclass Axis:\n    def __init__(self, name, bin=False):\n        self.aggregate = None\n        self.name, self.type = _get_name_type(name)\n        if \"()\" in self.name:  # aggregate function\n            self.aggregate = self.name.replace(\"()\", \"\")\n            self.name = None\n        self.bin = bin\n\n    def toJson(self):\n        json = {}\n        if self.name:\n            json[\"field\"] = self.name\n        if self.type:\n            json[\"type\"] = self.type\n        if self.bin:\n            json[\"bin\"] = True\n        if self.aggregate:\n            json[\"aggregate\"] = self.aggregate\n\n        return json\n\n\nclass X(Axis):\n    pass\n\n\nclass Y(Axis):\n    pass\n\n\nclass Data:\n    def __init__(self, **kwargs):\n        \"\"\"\n        input can be the form of a series of keyword args where\n        the keyword is the column name, or a single keyword data\n        that is a list of json style records as rows.\n        could also accept a csv file? or keywords columns and rows\n        This accepts a lot more options that \"real altair\" to make it easier\n        to work with non-DataFrame data sets.  Internally:\n        self.keys contains the list of column names\n        self.vals is a list of dictionaries of the form [{col1:val1, col2:val2, ... coln:valn},\n                                                         {col1:val3, col2:val4, ... coln:valn},\n                                                         {col1:val5, col2:val6, ... coln:valn}]\n        \"\"\"\n        # todo: accept a URL as the argument to read a CSV or JSON file\n        if len(kwargs) == 1 and \"data\" in kwargs:\n            self.data = kwargs[\"data\"]\n            self.keys = self.data[0].keys()\n            self.vals = self.data\n        elif len(kwargs) == 2 and (\"columns\" in kwargs) and (\"rows\" in kwargs):\n            self.keys = kwargs[\"columns\"]\n            self.vals = []\n            for r in kwargs[\"rows\"]:\n                self.vals.append(dict(zip(self.keys, r)))\n        else:\n            keys = kwargs.keys()\n            vals = []\n            primary_key = list(keys)[0]\n            for ix in range(len(kwargs[primary_key])):\n                d = {}\n                for key in keys:\n                    d[key] = kwargs[key][ix]\n                vals.append(d)\n            self.vals = vals\n            self.keys = keys\n\n    def __str__(self):\n        # header = \"\\t\".join(self.keys) + \"\\n\"\n        header = \"\"\n        for key in self.keys:\n            header += key.center(10) + \" \"\n        header += \"\\n\"\n        template = \"\"\n        for key in self.keys:\n            template += \"{\" + key + \": <10} \"\n        template += \"\\n\"\n        res = \"\"\n        for row in self.vals:\n            res += template.format(**row)\n\n        return header + res\n\n\nif __name__ == \"__main__\":\n    d = Data(a=[3, 4, 5], b=[1, 2, 3], c=[\"r\", \"g\", \"b\"])\n    print(d)\n    print(\n        type(\n            Chart({\"a\": list(\"abc\"), \"b\": [1, 2, 3]}).mark_bar().encode(x=\"a:N\", y=\"b\")\n        )\n    )\n    aa = (\n        Chart(Data(a=[3, 4, 5], b=[1, 2, 3], c=[\"r\", \"g\", \"b\"]))\n        .mark_point(color=\"red\")\n        .encode(x=\"b\", y=\"a\", color=\"c:O\")\n    )\n    print(\"aa = \", aa)\n    aa.display()\n\n    bb = (\n        Chart(Data(a=[1, 2, 3], b=[4, 5, 6], c=[\"r\", \"g\", \"b\"]))\n        .mark_line()\n        .encode(x=\"b\", y=\"a\", color=\"c:O\")\n    )\n    print(\"bb = \", bb)\n    bb.display()\n    print(\"aa+bb\", (aa + bb).display())\n    # Chart(Data(a=[1,2,3,2,2,4,5,5,6,7,8,8,8,8,8,9,0,0])).mark_bar().encode(Axis('a:Q', bin=True),y='count()')\n\n\n# todo: see if I can work with the repr of an object to get the behavior that altair gets in notebooks\n# todo: implement a Bin object to specifiy maxbins\n","src/lib/antigravity.py":"import webbrowser\n\nwebbrowser.open(\"https://xkcd.com/353/\")\n","src/lib/anydbm.py":"import _sk_fail; _sk_fail._(\"anydbm\")\n","src/lib/ast.py":"import _sk_fail; _sk_fail._(\"ast\")\n","src/lib/asynchat.py":"import _sk_fail; _sk_fail._(\"asynchat\")\n","src/lib/asyncore.py":"import _sk_fail; _sk_fail._(\"asyncore\")\n","src/lib/atexit.py":"import _sk_fail; _sk_fail._(\"atexit\")\n","src/lib/audiodev.py":"import _sk_fail; _sk_fail._(\"audiodev\")\n","src/lib/base64.py":"import _sk_fail; _sk_fail._(\"base64\")\n","src/lib/bdb.py":"import _sk_fail; _sk_fail._(\"bdb\")\n","src/lib/binhex.py":"import _sk_fail; _sk_fail._(\"binhex\")\n","src/lib/bisect.py":"\"\"\"Bisection algorithms.\"\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n\ndef bisect_right(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    return lo\n\ndef insort_left(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    a.insert(lo, x)\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    return lo\n\n# Overwrite above definitions with a fast C implementation\ntry:\n    from _bisect import *\nexcept ImportError:\n    pass\n\n# Create aliases\nbisect = bisect_right\ninsort = insort_right\n","src/lib/bsddb/__init__.py":"import _sk_fail; _sk_fail._(\"bsddb\")\n","src/lib/cProfile.py":"import _sk_fail; _sk_fail._(\"cProfile\")\n","src/lib/cgi.py":"import _sk_fail; _sk_fail._(\"cgi\")\n","src/lib/cgitb.py":"import _sk_fail; _sk_fail._(\"cgitb\")\n","src/lib/chunk.py":"import _sk_fail; _sk_fail._(\"chunk\")\n","src/lib/cmd.py":"import _sk_fail; _sk_fail._(\"cmd\")\n","src/lib/code.py":"import _sk_fail; _sk_fail._(\"code\")\n","src/lib/codecs.py":"import _sk_fail; _sk_fail._(\"codecs\")\n","src/lib/codeop.py":"import _sk_fail; _sk_fail._(\"codeop\")\n","src/lib/colorsys.py":"import _sk_fail; _sk_fail._(\"colorsys\")\n","src/lib/commands.py":"import _sk_fail; _sk_fail._(\"commands\")\n","src/lib/compileall.py":"import _sk_fail; _sk_fail._(\"compileall\")\n","src/lib/compiler/__init__.py":"import _sk_fail; _sk_fail._(\"compiler\")\n","src/lib/config/__init__.py":"import _sk_fail; _sk_fail._(\"config\")\n","src/lib/contextlib.py":"import _sk_fail; _sk_fail._(\"contextlib\")\n","src/lib/cookielib.py":"import _sk_fail; _sk_fail._(\"cookielib\")\n","src/lib/copy.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\nimport types\nclass Error(Exception):\n    pass\nerror = Error \nclass _EmptyClass:\n    pass\ntry:\n    long\nexcept NameError:\n    long = int\ntry:\n    bytes\nexcept NameError:\n    bytes = str\n\ndef check_notimplemented_state(x):\n    getstate = getattr(x, \"__getstate__\", None)\n    setstate = getattr(x, \"__setstate__\", None)\n    initargs = getattr(x, \"__getinitargs__\", None)\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n\n\ndef copy(x):\n    cls = type(x)\n    if callable(x):\n        return x\n    copier = getattr(cls, \"__copy__\", None)\n    if copier:\n        return copier(x)\n    if cls in (type(None), int, float, bool, str, bytes, tuple, type, frozenset, long):\n        return x\n    if (cls == list) or (cls == dict) or (cls == set) or (cls == slice):\n        return cls(x)\n    reductor = getattr(x, \"__reduce_ex__\", None)\n    if reductor:\n        rv = reductor(4)\n    else:\n        reductor = getattr(x, \"__reduce__\", None)\n        if reductor:\n            rv = reductor()\n        elif str(cls)[1:6] == \"class\":\n            check_notimplemented_state(x)\n            copier = _copy_inst\n            return copier(x)\n        else:\n            raise Error(\"un(shallow)copyable object of type %s\" % cls)\n    if isinstance(rv, str):\n        return x\n    return _reconstruct(x, rv, 0)\n\ndef _copy_inst(x):\n    if hasattr(x, '__copy__'):\n        return x.__copy__()\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n    return y\n\nd = _deepcopy_dispatch = {}\n\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    idx = id(x)\n    y = memo.get(idx, _nil)\n    if y is not _nil:\n        return y\n    cls = type(x)\n    copier = _deepcopy_dispatch.get(cls)\n    if copier:\n        y = copier(x, memo)\n    else:\n        try:\n            issc = issubclass(cls, type)\n        except TypeError: # cls is not a class (old Boost; see SF #502085)\n            issc = 0\n        if issc:\n            y = _deepcopy_atomic(x, memo)\n        else:\n            copier = getattr(x, \"__deepcopy__\", None)\n            if copier:\n                y = copier(memo)\n            else:\n                reductor = getattr(x, \"__reduce_ex__\", None)\n                if reductor:\n                    rv = reductor(2)\n                else:\n                    rv = None\n                    reductor = getattr(x, \"__reduce__\", None)\n                    if reductor:\n                        rv = reductor()\n                    elif str(cls)[1:6] == \"class\":\n                        check_notimplemented_state(x)\n                        copier = _deepcopy_dispatch[\"InstanceType\"]\n                        y = copier(x, memo)\n                    else:\n                        raise Error(\n                            \"un(deep)copyable object of type %s\" % cls)\n                if rv is not None:\n                    y = _reconstruct(x, rv, 1, memo)\n    memo[idx] = y\n    _keep_alive(x, memo) # Make sure x lives at least as long as d\n    return y\n\ndef _deepcopy_atomic(x, memo):\n    return x\nd[type(None)] = _deepcopy_atomic\n# d[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\n# try:\n# d[types.CodeType] = _deepcopy_atomic\n# except AttributeError:\n#   pass\nd[type] = _deepcopy_atomic\n# d[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\n# d[weakref.ref] = _deepcopy_atomic\n\ndef _deepcopy_list(x, memo):\n    y = []\n    memo[id(x)] = y\n    for a in x:\n        y.append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list\n\ndef _deepcopy_set(x, memo):\n    result = set([])  # make empty set\n    memo[id(x)] = result  # register this set in the memo for loop checking\n    for a in x:   # go through elements of set\n        result.add(deepcopy(a, memo))  # add the copied elements into the new set\n    return result # return the new set\nd[set] = _deepcopy_set\n\ndef _deepcopy_frozenset(x, memo):\n    result = frozenset(_deepcopy_set(x,memo)) \n    memo[id(x)] = result \n    return result\nd[frozenset] = _deepcopy_frozenset\n\ndef _deepcopy_tuple(x, memo):\n    y = [deepcopy(a, memo) for a in x]\n    # We're not going to put the tuple in the memo, but it's still important we\n    # check for it, in case the tuple contains recursive mutable structures.\n    try:\n        return memo[id(x)]\n    except KeyError:\n        pass\n    for k, j in zip(x, y):\n        if k is not j:\n            y = tuple(y)\n            break\n    else:\n        y = x\n    return y\nd[tuple] = _deepcopy_tuple\n\ndef _deepcopy_dict(x, memo):\n    y = {}\n    memo[id(x)] = y\n    for key, value in x.items():\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    return y\nd[dict] = _deepcopy_dict\n\n# def _deepcopy_method(x, memo): # Copy instance methods\n#     y = type(x)(x.im_func, deepcopy(x.im_self, memo), x.im_class);\n#     return y\nd[types.MethodType] = _deepcopy_atomic\n\ndef _deepcopy_inst(x, memo):\n    if hasattr(x, '__deepcopy__'):\n         return x.__deepcopy__(memo)\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        args = deepcopy(args, memo)\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    memo[id(x)] = y\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    state = deepcopy(state, memo)\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n        return y\nd[\"InstanceType\"] = _deepcopy_inst\n\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.\n    We store a reference at the id of the memo, which should\n    normally not be used unless someone tries to deepcopy\n    the memo itself...\n    \"\"\"\n    try:\n        memo[id(memo)].append(x)\n    except KeyError:\n        # aha, this is the first one :-)\n        memo[id(memo)]=[x]\n\ndef _reconstruct(x, info, deep, memo=None):\n    if isinstance(info, str):\n        return x\n    assert isinstance(info, tuple)\n    if memo is None:\n        memo = {}\n    n = len(info)\n    assert n in (2, 3, 4, 5)\n    callable, args = info[:2]\n    if n > 2:\n        state = info[2]\n    else:\n        state = None\n    if n > 3:\n        listiter = info[3]\n    else:\n        listiter = None\n    if n > 4:\n        dictiter = info[4]\n    else:\n        dictiter = None\n    if deep:\n        args = deepcopy(args, memo)\n    y = callable(*args)\n    memo[id(x)] = y\n\n    if state is not None:\n        if deep:\n            state = deepcopy(state, memo)\n        if hasattr(y, '__setstate__'):\n            y.__setstate__(state)\n        else:\n            if isinstance(state, tuple) and len(state) == 2:\n                state, slotstate = state\n            else:\n                slotstate = None\n            if state is not None:\n                y.__dict__.update(state)\n            if slotstate is not None:\n                for key, value in slotstate.items():\n                    setattr(y, key, value)\n\n    if listiter is not None:\n        for item in listiter:\n            if deep:\n                item = deepcopy(item, memo)\n            y.append(item)\n    if dictiter is not None:\n        for key, value in dictiter:\n            if deep:\n                key = deepcopy(key, memo)\n                value = deepcopy(value, memo)\n            y[key] = value\n    return y\n\ndel d\n\ndel types\n\n# Helper for instance creation without calling __init__\nclass _EmptyClass:\n    pass","src/lib/copy_reg.py":"import _sk_fail; _sk_fail._(\"copy_reg\")\n","src/lib/csv.py":"import _sk_fail; _sk_fail._(\"csv\")\n","src/lib/ctypes/__init__.py":"import _sk_fail; _sk_fail._(\"ctypes\")\n","src/lib/ctypes/macholib/__init__.py":"import _sk_fail; _sk_fail._(\"macholib\")\n","src/lib/curses/__init__.py":"import _sk_fail; _sk_fail._(\"curses\")\n","src/lib/dbhash.py":"import _sk_fail; _sk_fail._(\"dbhash\")\n","src/lib/decimal.py":"import _sk_fail; _sk_fail._(\"decimal\")\n","src/lib/difflib.py":"import _sk_fail; _sk_fail._(\"difflib\")\n","src/lib/dircache.py":"import _sk_fail; _sk_fail._(\"dircache\")\n","src/lib/dis.py":"import _sk_fail; _sk_fail._(\"dis\")\n","src/lib/distutils/__init__.py":"import _sk_fail; _sk_fail._(\"distutils\")\n","src/lib/distutils/command/__init__.py":"import _sk_fail; _sk_fail._(\"command\")\n","src/lib/distutils/tests/__init__.py":"import _sk_fail; _sk_fail._(\"tests\")\n","src/lib/doctest.py":"import _sk_fail; _sk_fail._(\"doctest\")\n","src/lib/dumbdbm.py":"import _sk_fail; _sk_fail._(\"dumbdbm\")\n","src/lib/dummy_thread.py":"import _sk_fail; _sk_fail._(\"dummy_thread\")\n","src/lib/dummy_threading.py":"import _sk_fail; _sk_fail._(\"dummy_threading\")\n","src/lib/email/__init__.py":"import _sk_fail; _sk_fail._(\"email\")\n","src/lib/email/mime/__init__.py":"import _sk_fail; _sk_fail._(\"mime\")\n","src/lib/email/test/data/__init__.py":"import _sk_fail; _sk_fail._(\"data\")\n","src/lib/encodings/__init__.py":"import _sk_fail; _sk_fail._(\"encodings\")\n","src/lib/filecmp.py":"import _sk_fail; _sk_fail._(\"filecmp\")\n","src/lib/fileinput.py":"import _sk_fail; _sk_fail._(\"fileinput\")\n","src/lib/fnmatch.py":"import _sk_fail; _sk_fail._(\"fnmatch\")\n","src/lib/formatter.py":"import _sk_fail; _sk_fail._(\"formatter\")\n","src/lib/fpformat.py":"import _sk_fail; _sk_fail._(\"fpformat\")\n","src/lib/fractions.py":"import _sk_fail; _sk_fail._(\"fractions\")\n","src/lib/ftplib.py":"import _sk_fail; _sk_fail._(\"ftplib\")\n","src/lib/genericpath.py":"import _sk_fail; _sk_fail._(\"genericpath\")\n","src/lib/getopt.py":"import _sk_fail; _sk_fail._(\"getopt\")\n","src/lib/getpass.py":"import _sk_fail; _sk_fail._(\"getpass\")\n","src/lib/gettext.py":"import _sk_fail; _sk_fail._(\"gettext\")\n","src/lib/glob.py":"import _sk_fail; _sk_fail._(\"glob\")\n","src/lib/gzip.py":"import _sk_fail; _sk_fail._(\"gzip\")\n","src/lib/hashlib.py":"import _sk_fail; _sk_fail._(\"hashlib\")\n","src/lib/heapq.py":"\"\"\"Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!\n\"\"\"\n\n# Original code by Kevin O'Connor, augmented by Tim Peters and Raymond Hettinger\n\n__about__ = \"\"\"Heap queues\n\n[explanation by François Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\na usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n\"\"\"\n\n__all__ = ['heappush', 'heappop', 'heapify', 'heapreplace',\n           'nlargest', 'nsmallest', 'heappushpop']\n\n\ndef heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap) - 1)\n\n\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup(heap, 0)\n        return returnitem\n    return lastelt\n\n\ndef heapreplace(heap, item):\n    \"\"\"Pop and return the current smallest value, and add the new item.\n\n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed-size heap.  Note that the value\n    returned may be larger than item!  That constrains reasonable uses of\n    this routine unless written as part of a conditional replacement:\n\n        if item > heap[0]:\n            item = heapreplace(heap, item)\n    \"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup(heap, 0)\n    return returnitem\n\n\ndef heappushpop(heap, item):\n    \"\"\"Fast version of a heappush followed by a heappop.\"\"\"\n    if heap and heap[0] < item:\n        item, heap[0] = heap[0], item\n        _siftup(heap, 0)\n    return item\n\n\ndef heapify(x):\n    \"\"\"Transform list into a heap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    # Transform bottom-up.  The largest index there's any point to looking at\n    # is the largest with a child index in-range, so must have 2*i + 1 < n,\n    # or i < (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so\n    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is\n    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.\n    for i in reversed(range(n // 2)):\n        _siftup(x, i)\n\n\ndef _heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt\n\n\ndef _heapreplace_max(heap, item):\n    \"\"\"Maxheap version of a heappop followed by a heappush.\"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup_max(heap, 0)\n    return returnitem\n\n\ndef _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n // 2)):\n        _siftup_max(x, i)\n\n# 'heap' is a heap at all indices >= startpos, except possibly for pos.  pos\n# is the index of a leaf with a possibly out-of-order value.  Restore the\n# heap invariant.\n\n\ndef _siftdown(heap, startpos, pos):\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if newitem < parent:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\n# The child indices of heap index pos are already heaps, and we want to make\n# a heap at index pos too.  We do this by bubbling the smaller child of\n# pos up (and so on with that child's children, etc) until hitting a leaf,\n# then using _siftdown to move the oddball originally at index pos into place.\n#\n# We *could* break out of the loop as soon as we find a pos where newitem <=\n# both its children, but turns out that's not a good idea, and despite that\n# many books write the algorithm that way.  During a heap pop, the last array\n# element is sifted in, and that tends to be large, so that comparing it\n# against values starting from the root usually doesn't pay (= usually doesn't\n# get us out of the loop early).  See Knuth, Volume 3, where this is\n# explained and quantified in an exercise.\n#\n# Cutting the # of comparisons is important, since these routines have no\n# way to extract \"the priority\" from an array element, so that intelligence\n# is likely to be hiding in custom comparison methods, or in array elements\n# storing (priority, record) tuples.  Comparisons are thus potentially\n# expensive.\n#\n# On random arrays of length 1000, making this change cut the number of\n# comparisons made by heapify() a little, and those made by exhaustive\n# heappop() a lot, in accord with theory.  Here are typical results from 3\n# runs (3 just to demonstrate how small the variance is):\n#\n# Compares needed by heapify     Compares needed by 1000 heappops\n# --------------------------     --------------------------------\n# 1837 cut to 1663               14996 cut to 8680\n# 1855 cut to 1659               14966 cut to 8678\n# 1847 cut to 1660               15024 cut to 8703\n#\n# Building the heap by using heappush() 1000 times instead required\n# 2198, 2148, and 2219 compares:  heapify() is more efficient, when\n# you can use it.\n#\n# The total compares needed by list.sort() on the same lists were 8627,\n# 8627, and 8632 (this should be compared to the sum of heapify() and\n# heappop() compares):  list.sort() is (unsurprisingly!) more efficient\n# for sorting.\n\n\ndef _siftup(heap, pos):\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the smaller child until hitting a leaf.\n    childpos = 2 * pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of smaller child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[childpos] < heap[rightpos]:\n            childpos = rightpos\n        # Move the smaller child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2 * pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown(heap, startpos, pos)\n\n\ndef _siftdown_max(heap, startpos, pos):\n    'Maxheap variant of _siftdown'\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if parent < newitem:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\n\ndef _siftup_max(heap, pos):\n    'Maxheap variant of _siftup'\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the larger child until hitting a leaf.\n    childpos = 2 * pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of larger child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[rightpos] < heap[childpos]:\n            childpos = rightpos\n        # Move the larger child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2 * pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown_max(heap, startpos, pos)\n\n\n# Algorithm notes for nlargest() and nsmallest()\n# ==============================================\n#\n# Make a single pass over the data while keeping the k most extreme values\n# in a heap.  Memory consumption is limited to keeping k values in a list.\n#\n# Measured performance for random inputs:\n#\n#                                   number of comparisons\n#    n inputs     k-extreme values  (average of 5 trials)   % more than min()\n# -------------   ----------------  ---------------------   -----------------\n#      1,000           100                  3,317               231.7%\n#     10,000           100                 14,046                40.5%\n#    100,000           100                105,749                 5.7%\n#  1,000,000           100              1,007,751                 0.8%\n# 10,000,000           100             10,009,401                 0.1%\n#\n# Theoretical number of comparisons for k smallest of n random inputs:\n#\n# Step   Comparisons                  Action\n# ----   --------------------------   ---------------------------\n#  1     1.66 * k                     heapify the first k-inputs\n#  2     n - k                        compare remaining elements to top of heap\n#  3     k * (1 + lg2(k)) * ln(n/k)   replace the topmost value on the heap\n#  4     k * lg2(k) - (k/2)           final sort of the k most extreme values\n#\n# Combining and simplifying for a rough estimate gives:\n#\n#        comparisons = n + k * (log(k, 2) * log(n/k) + log(k, 2) + log(n/k))\n#\n# Computing the number of comparisons for step 3:\n# -----------------------------------------------\n# * For the i-th new value from the iterable, the probability of being in the\n#   k most extreme values is k/i.  For example, the probability of the 101st\n#   value seen being in the 100 most extreme values is 100/101.\n# * If the value is a new extreme value, the cost of inserting it into the\n#   heap is 1 + log(k, 2).\n# * The probability times the cost gives:\n#            (k/i) * (1 + log(k, 2))\n# * Summing across the remaining n-k elements gives:\n#            sum((k/i) * (1 + log(k, 2)) for i in range(k+1, n+1))\n# * This reduces to:\n#            (H(n) - H(k)) * k * (1 + log(k, 2))\n# * Where H(n) is the n-th harmonic number estimated by:\n#            gamma = 0.5772156649\n#            H(n) = log(n, e) + gamma + 1 / (2 * n)\n#   http://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Rate_of_divergence\n# * Substituting the H(n) formula:\n#            comparisons = k * (1 + log(k, 2)) * (log(n/k, e) + (1/n - 1/k) / 2)\n#\n# Worst-case for step 3:\n# ----------------------\n# In the worst case, the input data is reversed sorted so that every new element\n# must be inserted in the heap:\n#\n#             comparisons = 1.66 * k + log(k, 2) * (n - k)\n#\n# Alternative Algorithms\n# ----------------------\n# Other algorithms were not used because they:\n# 1) Took much more auxiliary memory,\n# 2) Made multiple passes over the data.\n# 3) Made more comparisons in common cases (small k, large n, semi-random input).\n# See the more detailed comparison of approach at:\n# http://code.activestate.com/recipes/577573-compare-algorithms-for-heapqsmallest\n\ndef nsmallest(n, iterable, key=None):\n    \"\"\"Find the n smallest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key)[:n]\n    \"\"\"\n\n    # Short-cut for n==1 is to use min()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = min(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]\n\n    # When n>=size, it's faster to use sorted()\n    try:\n        size = len(iterable)\n    except (TypeError, AttributeError):\n        pass\n    else:\n        if n >= size:\n            return sorted(iterable, key=key)[:n]\n\n    # When key is none, use simpler decoration\n    if key is None:\n        it = iter(iterable)\n        # put the range(n) first so that zip() doesn't\n        # consume one too many elements from the iterator\n        result = [(elem, i) for i, elem in zip(range(n), it)]\n        if not result:\n            return result\n        _heapify_max(result)\n        top = result[0][0]\n        order = n\n        _heapreplace = _heapreplace_max\n        for elem in it:\n            if elem < top:\n                _heapreplace(result, (elem, order))\n                top, _order = result[0]\n                order += 1\n        result.sort()\n        return [elem for (elem, order) in result]\n\n    # General case, slowest method\n    it = iter(iterable)\n    result = [(key(elem), i, elem) for i, elem in zip(range(n), it)]\n    if not result:\n        return result\n    _heapify_max(result)\n    top = result[0][0]\n    order = n\n    _heapreplace = _heapreplace_max\n    for elem in it:\n        k = key(elem)\n        if k < top:\n            _heapreplace(result, (k, order, elem))\n            top, _order, _elem = result[0]\n            order += 1\n    result.sort()\n    return [elem for (k, order, elem) in result]\n\n\ndef nlargest(n, iterable, key=None):\n    \"\"\"Find the n largest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]\n    \"\"\"\n\n    # Short-cut for n==1 is to use max()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = max(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]\n\n    # When n>=size, it's faster to use sorted()\n    try:\n        size = len(iterable)\n    except (TypeError, AttributeError):\n        pass\n    else:\n        if n >= size:\n            return sorted(iterable, key=key, reverse=True)[:n]\n\n    # When key is none, use simpler decoration\n    if key is None:\n        it = iter(iterable)\n        result = [(elem, i) for i, elem in zip(range(0, -n, -1), it)]\n        if not result:\n            return result\n        heapify(result)\n        top = result[0][0]\n        order = -n\n        _heapreplace = heapreplace\n        for elem in it:\n            if top < elem:\n                _heapreplace(result, (elem, order))\n                top, _order = result[0]\n                order -= 1\n        result.sort(reverse=True)\n        return [elem for (elem, order) in result]\n\n    # General case, slowest method\n    it = iter(iterable)\n    result = [(key(elem), i, elem) for i, elem in zip(range(0, -n, -1), it)]\n    if not result:\n        return result\n    heapify(result)\n    top = result[0][0]\n    order = -n\n    _heapreplace = heapreplace\n    for elem in it:\n        k = key(elem)\n        if top < k:\n            _heapreplace(result, (k, order, elem))\n            top, _order, _elem = result[0]\n            order -= 1\n    result.sort(reverse=True)\n    return [elem for (k, order, elem) in result]\n\n\n# If available, use C implementation\ntry:\n    from _heapq import *\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapreplace_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapify_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heappop_max\nexcept ImportError:\n    pass\n\n\nif __name__ == \"__main__\":\n\n    import doctest  # pragma: no cover\n    print(doctest.testmod())  # pragma: no cover\n","src/lib/hmac.py":"import _sk_fail; _sk_fail._(\"hmac\")\n","src/lib/hotshot/__init__.py":"import _sk_fail; _sk_fail._(\"hotshot\")\n","src/lib/htmlentitydefs.py":"import _sk_fail; _sk_fail._(\"htmlentitydefs\")\n","src/lib/htmllib.py":"import _sk_fail; _sk_fail._(\"htmllib\")\n","src/lib/httplib.py":"import _sk_fail; _sk_fail._(\"httplib\")\n","src/lib/idlelib/Icons/__init__.py":"import _sk_fail; _sk_fail._(\"Icons\")\n","src/lib/idlelib/__init__.py":"import _sk_fail; _sk_fail._(\"idlelib\")\n","src/lib/ihooks.py":"import _sk_fail; _sk_fail._(\"ihooks\")\n","src/lib/imaplib.py":"import _sk_fail; _sk_fail._(\"imaplib\")\n","src/lib/imghdr.py":"import _sk_fail; _sk_fail._(\"imghdr\")\n","src/lib/imputil.py":"import _sk_fail; _sk_fail._(\"imputil\")\n","src/lib/io.py":"import _sk_fail; _sk_fail._(\"io\")\n","src/lib/lib-dynload/__init__.py":"import _sk_fail; _sk_fail._(\"lib-dynload\")\n","src/lib/lib-tk/__init__.py":"import _sk_fail; _sk_fail._(\"lib-tk\")\n","src/lib/lib2to3/__init__.py":"import _sk_fail; _sk_fail._(\"lib2to3\")\n","src/lib/lib2to3/fixes/__init__.py":"import _sk_fail; _sk_fail._(\"fixes\")\n","src/lib/lib2to3/pgen2/__init__.py":"import _sk_fail; _sk_fail._(\"pgen2\")\n","src/lib/lib2to3/tests/__init__.py":"import _sk_fail; _sk_fail._(\"tests\")\n","src/lib/linecache.py":"import _sk_fail; _sk_fail._(\"linecache\")\n","src/lib/locale.py":"import _sk_fail; _sk_fail._(\"locale\")\n","src/lib/logging/__init__.py":"import _sk_fail; _sk_fail._(\"logging\")\n","src/lib/macpath.py":"import _sk_fail; _sk_fail._(\"macpath\")\n","src/lib/macurl2path.py":"import _sk_fail; _sk_fail._(\"macurl2path\")\n","src/lib/mailbox.py":"import _sk_fail; _sk_fail._(\"mailbox\")\n","src/lib/mailcap.py":"import _sk_fail; _sk_fail._(\"mailcap\")\n","src/lib/markupbase.py":"import _sk_fail; _sk_fail._(\"markupbase\")\n","src/lib/md5.py":"import _sk_fail; _sk_fail._(\"md5\")\n","src/lib/mhlib.py":"import _sk_fail; _sk_fail._(\"mhlib\")\n","src/lib/mimetools.py":"import _sk_fail; _sk_fail._(\"mimetools\")\n","src/lib/mimetypes.py":"import _sk_fail; _sk_fail._(\"mimetypes\")\n","src/lib/mimify.py":"import _sk_fail; _sk_fail._(\"mimify\")\n","src/lib/modulefinder.py":"import _sk_fail; _sk_fail._(\"modulefinder\")\n","src/lib/multifile.py":"import _sk_fail; _sk_fail._(\"multifile\")\n","src/lib/multiprocessing/__init__.py":"import _sk_fail; _sk_fail._(\"multiprocessing\")\n","src/lib/multiprocessing/dummy/__init__.py":"import _sk_fail; _sk_fail._(\"dummy\")\n","src/lib/mutex.py":"import _sk_fail; _sk_fail._(\"mutex\")\n","src/lib/netrc.py":"import _sk_fail; _sk_fail._(\"netrc\")\n","src/lib/new.py":"import _sk_fail; _sk_fail._(\"new\")\n","src/lib/nntplib.py":"import _sk_fail; _sk_fail._(\"nntplib\")\n","src/lib/ntpath.py":"import _sk_fail; _sk_fail._(\"ntpath\")\n","src/lib/nturl2path.py":"import _sk_fail; _sk_fail._(\"nturl2path\")\n","src/lib/numbers.py":"Number = (int, float, complex)\nIntegral = int\nComplex = complex\n","src/lib/opcode.py":"import _sk_fail; _sk_fail._(\"opcode\")\n","src/lib/optparse.py":"import _sk_fail; _sk_fail._(\"optparse\")\n","src/lib/os.py":"import _sk_fail; _sk_fail._(\"os\")\n","src/lib/os2emxpath.py":"import _sk_fail; _sk_fail._(\"os2emxpath\")\n","src/lib/pdb.py":"import _sk_fail; _sk_fail._(\"pdb\")\n","src/lib/pickle.py":"import _sk_fail; _sk_fail._(\"pickle\")\n","src/lib/pickletools.py":"import _sk_fail; _sk_fail._(\"pickletools\")\n","src/lib/pipes.py":"import _sk_fail; _sk_fail._(\"pipes\")\n","src/lib/pkgutil.py":"import _sk_fail; _sk_fail._(\"pkgutil\")\n","src/lib/platform.py":"import _sk_fail; _sk_fail._(\"platform\")\n","src/lib/plistlib.py":"import _sk_fail; _sk_fail._(\"plistlib\")\n","src/lib/popen2.py":"import _sk_fail; _sk_fail._(\"popen2\")\n","src/lib/poplib.py":"import _sk_fail; _sk_fail._(\"poplib\")\n","src/lib/posixfile.py":"import _sk_fail; _sk_fail._(\"posixfile\")\n","src/lib/posixpath.py":"import _sk_fail; _sk_fail._(\"posixpath\")\n","src/lib/pprint.py":"import _sk_fail; _sk_fail._(\"pprint\")\n","src/lib/profile.py":"import _sk_fail; _sk_fail._(\"profile\")\n","src/lib/pstats.py":"import _sk_fail; _sk_fail._(\"pstats\")\n","src/lib/pty.py":"import _sk_fail; _sk_fail._(\"pty\")\n","src/lib/py_compile.py":"import _sk_fail; _sk_fail._(\"py_compile\")\n","src/lib/pyclbr.py":"import _sk_fail; _sk_fail._(\"pyclbr\")\n","src/lib/pydoc.py":"import _sk_fail; _sk_fail._(\"pydoc\")\n","src/lib/pydoc_topics.py":"import _sk_fail; _sk_fail._(\"pydoc_topics\")\n","src/lib/pythonds/__init__.py":"","src/lib/pythonds/basic/__init__.py":"\n#__all__ = [\"stack\"]\n\n\nfrom .stack import Stack\nfrom .queue import Queue\nfrom .deque import Deque\n\n\n","src/lib/pythonds/basic/deque.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# deque.py\n\n\nclass Deque:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def addFront(self, item):\n        self.items.append(item)\n\n    def addRear(self, item):\n        self.items.insert(0, item)\n\n    def removeFront(self):\n        return self.items.pop()\n\n    def removeRear(self):\n        return self.items.pop(0)\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/basic/queue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# queue.py\n\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def enqueue(self, item):\n        self.items.insert(0, item)\n\n    def dequeue(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/basic/stack.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# stack.py\n\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/graphs/__init__.py":"\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n","src/lib/pythonds/graphs/adjGraph.py":"#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = 'white'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":disc \" + str(self.disc) + \":fin \" + str(self.fin) + \":dist \" + str(self.dist) + \":pred \\n\\t[\" + str(self.pred)+ \"]\\n\"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open(\"test.dat\")\n        for line in gFile:\n            fVertex, tVertex = line.split('|')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == '__main__':\n    unittest.main()\n              \n","src/lib/pythonds/graphs/priorityQueue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,'x'))\n        self.theHeap.add((3,'y'))\n        self.theHeap.add((5,'z'))\n        self.theHeap.add((6,'a'))\n        self.theHeap.add((4,'d'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == 'x'\n        assert self.theHeap.delMin() == 'y'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey('d',1)\n        assert self.theHeap.delMin() == 'd'\n        \nif __name__ == '__main__':\n    unittest.main()\n","src/lib/pythonds/trees/__init__.py":"\nfrom .binaryTree import BinaryTree\nfrom .balance import AVLTree\nfrom .bst import BinarySearchTree\nfrom .binheap import BinHeap\n\n\n","src/lib/pythonds/trees/balance.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    '''\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n","src/lib/pythonds/trees/binaryTree.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    \"\"\"    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print('(')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(')')\n\n    def postordereval(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print('(')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(')') \n\ndef printexp(tree):\n    sVal = \"\"\n    if tree:\n        sVal = '(' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + ')'\n    return sVal\n\ndef postordereval(tree):\n    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree('*')\n# x.insertLeft('+')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n","src/lib/pythonds/trees/binheap.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n","src/lib/pythonds/trees/bst.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    '''\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError('Error, key not in tree')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree.\"\"\"\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n","src/lib/pythonds3/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3 import statement\n\"\"\"\n\nfrom pythonds3.basic import Stack, Queue, Deque\nfrom pythonds3.graphs import Graph, Vertex\nfrom pythonds3.searching import HashTable\nfrom pythonds3.trees import (\n    BinaryTree,\n    AVLTree,\n    BinarySearchTree,\n    BinaryHeap,\n    PriorityQueue,\n)\n\n__all__ = [\n    \"Stack\",\n    \"Queue\",\n    \"Deque\",\n    \"Graph\",\n    \"Vertex\",\n    \"HashTable\",\n    \"BinaryTree\",\n    \"AVLTree\",\n    \"BinarySearchTree\",\n    \"BinaryHeap\",\n    \"BinaryTree\",\n    \"PriorityQueue\",\n]\n","src/lib/pythonds3/basic/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.basic import statement\n\"\"\"\nfrom pythonds3.basic.stack import Stack\nfrom pythonds3.basic.queue import Queue\nfrom pythonds3.basic.deque import Deque\nfrom pythonds3.basic.linked_list import OrderedList\nfrom pythonds3.basic.linked_list import UnorderedList\n\n__all__ = [\"Stack\", \"Queue\", \"Deque\", \"OrderedList\", \"UnorderedList\"]\n","src/lib/pythonds3/basic/deque.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Deque:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new deque\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the deque is empty\"\"\"\n        return not bool(self._items)\n\n    def add_front(self, item):\n        \"\"\"Add an item to the front of the deque\"\"\"\n        self._items.append(item)\n\n    def add_rear(self, item):\n        \"\"\"Add an item to the rear of the deque\"\"\"\n        self._items.insert(0, item)\n\n    def remove_front(self):\n        \"\"\"Remove an item from the front of the deque\"\"\"\n        return self._items.pop()\n\n    def remove_rear(self):\n        \"\"\"Remove an item from the rear of the deque\"\"\"\n        return self._items.pop(0)\n\n    def size(self):\n        \"\"\"Get the number of items in the deque\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/basic/linked_list.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass LinkedListNode:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n\n\nclass LinkedList:\n    \"\"\"Linked List class implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a linked list\"\"\"\n        self._head = None\n        self._count = 0\n\n    def is_empty(self):\n        \"\"\"Is the list empty\"\"\"\n        return self._head is None\n\n    def size(self):\n        \"\"\"Size of the list\"\"\"\n        return self._count\n\n    def __len__(self):\n        \"\"\"Size of the list\"\"\"\n        return self._count\n\n    def __str__(self):\n        \"\"\"List as a string\"\"\"\n        list_str = \"[\"\n        current = self._head\n\n        while current:\n            list_str += str(current)\n            if current.next:\n                list_str += \", \"\n            current = current.next\n        list_str += \"]\"\n        return list_str\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        pass\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        pass\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        pass\n\n\nclass UnorderedList(LinkedList):\n    \"\"\"Unordered linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create an unordered linked list\"\"\"\n        LinkedList.__init__(self)\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        new_node = LinkedListNode(value)\n        new_node.set_next(self._head)\n        self._head = new_node\n        self._count = self._count + 1\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        current = self._head\n        prev = None\n\n        while current:\n            if current.data == value:\n                if prev is None:\n                    self._head = current.next\n                else:\n                    prev.next = current.next\n                self._count = self._count - 1\n                return\n            prev = current\n            current = current.next\n        raise ValueError(\"{} is not in the list\".format(value))\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        current = self._head\n\n        while current:\n            if current.data == value:\n                return True\n            current = current.next\n        return False\n\n\nclass OrderedList(LinkedList):\n    \"\"\"Ordered linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create an Ordered linked list\"\"\"\n        LinkedList.__init__(self)\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        current = self._head\n        prev = None\n        new_node = LinkedListNode(value)\n\n        while current and current.data < value:\n            prev = current\n            current = current.next\n\n        if prev is None:\n            new_node.next = self._head\n            self._head = new_node\n        else:\n            new_node.next = current\n            prev.next = new_node\n        self._count = self._count + 1\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        # This is an exercise\n        pass\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        # This is an exercise\n        pass\n","src/lib/pythonds3/basic/queue.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Queue:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new queue\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return not bool(self._items)\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the queue\"\"\"\n        self._items.insert(0, item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the queue\"\"\"\n        return self._items.pop()\n\n    def size(self):\n        \"\"\"Get the number of items in the queue\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/basic/stack.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Stack:\n    \"\"\"Stack implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new stack\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the stack is empty\"\"\"\n        return not bool(self._items)\n\n    def push(self, item):\n        \"\"\"Add an item to the stack\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove an item from the stack\"\"\"\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"Get the value of the top item in the stack\"\"\"\n        return self._items[-1]\n\n    def size(self):\n        \"\"\"Get the number of items in the stack\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/graphs/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.graphs import statement\n\"\"\"\nfrom pythonds3.graphs.adjacency_graph import Graph\nfrom pythonds3.graphs.adjacency_graph import Vertex\n\n__all__ = [\"Graph\"]\n","src/lib/pythonds3/graphs/adjacency_graph.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport heapq\nimport sys\n\n\nclass Vertex:\n    \"\"\"Graph vertex class\"\"\"\n\n    def __init__(self, key):\n        \"\"\"Create new vertex\"\"\"\n        self._key = key\n        self._neighbors = {}\n        self._color = \"white\"\n        self._distance = sys.maxsize\n        self._previous = None\n        self._discovery_time = 0\n        self._closing_time = 0\n\n    def __lt__(self, other):\n        \"\"\"Less than operator required for heapify\"\"\"\n        return self.key < other.key\n\n    def get_key(self):\n        \"\"\"Get vertex key\"\"\"\n        return self._key\n\n    key = property(get_key)\n\n    def get_neighbor(self, other):\n        \"\"\"Get the distance (edge weight) to an adjacent node (neighbor)\"\"\"\n        return self._neighbors.get(other, None)\n\n    def set_neighbor(self, other, weight=0):\n        \"\"\"Set the distance (add an edge) to an adjacent node (neighbor)\"\"\"\n        self._neighbors[other] = weight\n\n    def get_neighbors(self):\n        \"\"\"Get all adjacent nodes (neighbors)\"\"\"\n        return self._neighbors.keys()\n\n    def get_color(self):\n        \"\"\"Get vertex color\"\"\"\n        return self._color\n\n    def set_color(self, color):\n        \"\"\"Set vertex color\"\"\"\n        self._color = color\n\n    color = property(get_color, set_color)\n\n    def get_distance(self):\n        \"\"\"Get distance\"\"\"\n        return self._distance\n\n    def set_distance(self, distance):\n        \"\"\"Set distance\"\"\"\n        self._distance = distance\n\n    distance = property(get_distance, set_distance)\n\n    def get_previous(self):\n        \"\"\"Get previous\"\"\"\n        return self._previous\n\n    def set_previous(self, previous):\n        \"\"\"Set previous\"\"\"\n        self._previous = previous\n\n    previous = property(get_previous, set_previous)\n\n    def get_discovery_time(self):\n        \"\"\"Get discovery time\"\"\"\n        return self._discovery_time\n\n    def set_discovery_time(self, discovery_time):\n        \"\"\"Set discovery time\"\"\"\n        self._discovery_time = discovery_time\n\n    discovery_time = property(get_discovery_time, set_discovery_time)\n\n    def get_closing_time(self):\n        \"\"\"Get closing time\"\"\"\n        return self._closing_time\n\n    def set_closing_time(self, closing_time):\n        \"\"\"Set closing time\"\"\"\n        self._closing_time = closing_time\n\n    closing_time = property(get_closing_time, set_closing_time)\n\n    def __str__(self):\n        return \"{:^8}|{:^8}|{:^8}|{:^8}|{:^8}| {}\".format(\n            self._key,\n            self._color,\n            self._distance,\n            self._discovery_time,\n            self._closing_time,\n            self._previous,\n        )\n\n\nclass Graph:\n    \"\"\"Graph as an adjacency matrix\"\"\"\n\n    def __init__(self):\n        self._vertices = {}\n        self._edges = {}\n        self._time = 0\n\n    def __iter__(self):\n        \"\"\"Iterator\"\"\"\n        return iter(self._vertices.values())\n\n    def size(self):\n        \"\"\"Graph's size\"\"\"\n        return len(self._vertices)\n\n    def __len__(self):\n        \"\"\"Graph's size\"\"\"\n        return len(self._vertices)\n\n    def __contains__(self, key):\n        \"\"\"in operator override\"\"\"\n        return key in self._vertices\n\n    def get_vertex(self, key):\n        \"\"\"Find the vertex in the graph named vert_key\"\"\"\n        return self._vertices.get(key, None)\n\n    def set_vertex(self, key):\n        \"\"\"Add an instance of Vertex to the graph\"\"\"\n        self._vertices[key] = Vertex(key)\n\n    def add_edge(self, from_vertex, to_vertex, weight=0):\n        \"\"\"Add a weighted and directed edge to the graph\"\"\"\n        if from_vertex not in self._vertices:\n            self.set_vertex(from_vertex)\n        if to_vertex not in self._vertices:\n            self.set_vertex(to_vertex)\n        self._vertices[from_vertex].set_neighbor(self._vertices[to_vertex], weight)\n        self._edges[(from_vertex, to_vertex)] = weight\n\n    def get_vertices(self):\n        \"\"\"Return the list of all vertices in the graph\"\"\"\n        return self._vertices.keys()\n\n    def get_edges(self):\n        \"\"\"Return the list of all edges in the graph\"\"\"\n        return self._edges.keys()\n\n    def reset_distances(self, default_distance=sys.maxsize):\n        \"\"\"Reset distances to test Dijkstra's\"\"\"\n        for vertex in self:\n            vertex.distance = default_distance\n\n    def bfs(self, start):\n        \"\"\"Breadth First Search\"\"\"\n        start.distance = 0\n        start.previous = None\n        vert_queue = [start]\n        while vert_queue:\n            current_vert = vert_queue.pop(0)\n            for neigh in current_vert.get_neighbors():\n                if neigh.color == \"white\":\n                    neigh.color = \"gray\"\n                    neigh.distance = current_vert.distance + 1\n                    neigh.previous = current_vert\n                    vert_queue.append(neigh)\n            current_vert.color = \"black\"\n\n    def dfs(self):\n        \"\"\"Depth First search\"\"\"\n        for vertex in self:\n            if vertex.color == \"white\":\n                self.dfs_visit(vertex)\n\n    def dfs_visit(self, start):\n        \"\"\"DFS helper function\"\"\"\n        start.color = \"gray\"\n        self._time = self._time + 1\n        start.discovery_time = self._time\n        for next_vertex in start.get_neighbors():\n            if next_vertex.color == \"white\":\n                next_vertex.set_previous(start)\n                self.dfs_visit(next_vertex)\n        start.color = \"black\"\n        self._time = self._time + 1\n        start.closing_time = self._time\n\n    def traverse(self, src, dst):\n        \"\"\"Traverse a graph\"\"\"\n        path = []\n        current = self.get_vertex(dst)\n        while current:\n            path.append(current)\n            current = current.previous\n        print(\n            \"Path from {} to {} ({}): {}\".format(\n                self.get_vertex(src).key,\n                self.get_vertex(dst).key,\n                self.get_vertex(dst).distance,\n                \" \".join(vertex.key for vertex in reversed(path)),\n            )\n        )\n\n    def dijkstra(self, start):\n        \"\"\"Dijkstra's shortest path algorithm\"\"\"\n        start.distance = 0\n        not_yet_visited = [[start.distance, start]]\n        heapq.heapify(not_yet_visited)\n        while not_yet_visited:\n            current_vertex = heapq.heappop(not_yet_visited)[1]\n            for next_vertex in current_vertex.get_neighbors():\n                new_distance = current_vertex.distance + current_vertex.get_neighbor(\n                    next_vertex\n                )\n                if new_distance < next_vertex.distance:\n                    next_vertex.distance = new_distance\n                    next_vertex.previous = current_vertex\n                    found = False\n                    for vertex in not_yet_visited:\n                        if vertex[1].key == next_vertex.key:\n                            vertex[0] = next_vertex.distance\n                            heapq.heapify(not_yet_visited)\n                            found = True\n                    if not found:\n                        heapq.heappush(\n                            not_yet_visited, [next_vertex.distance, next_vertex]\n                        )\n\n    def bellman_ford(self, start):\n        \"\"\"Bellman-Ford shortest path algorithm\"\"\"\n        start.distance = 0\n        for _ in range(len(self._vertices)):\n            for edge in self._edges:\n                if (\n                    self.get_vertex(edge[0]).distance + self._edges[edge]\n                    < self.get_vertex(edge[1]).distance\n                ):\n                    self.get_vertex(edge[1]).distance = (\n                        self.get_vertex(edge[0]).distance + self._edges[edge]\n                    )\n                    self.get_vertex(edge[1]).previous = self.get_vertex(edge[0])\n        for edge in self._edges:\n            if (\n                self.get_vertex(edge[0]).distance + self._edges[edge]\n                < self.get_vertex(edge[1]).distance\n            ):\n                raise ValueError(\"Graph contains a negative-weight cycle\")\n\n    def prim(self, start):\n        \"\"\"Prim's spanning tree algorithm\"\"\"\n        start.distance = 0\n        not_in_a_tree = [[vertex.distance, vertex] for vertex in self]\n        heapq.heapify(not_in_a_tree)\n        while not_in_a_tree:\n            current_vertex = heapq.heappop(not_in_a_tree)[1]\n            for next_vertex in current_vertex.get_neighbors():\n                new_distance = current_vertex.get_neighbor(next_vertex)\n                if (\n                    any(item[1] == next_vertex for item in not_in_a_tree)\n                    and new_distance < next_vertex.distance\n                ):\n                    next_vertex.previous = current_vertex\n                    next_vertex.distance = new_distance\n                    for item in not_in_a_tree:\n                        if item[1] == next_vertex:\n                            item[0] = new_distance\n                            heapq.heapify(not_in_a_tree)\n                            break\n","src/lib/pythonds3/intro/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.intro import statement\n\"\"\"\nfrom pythonds3.intro.oop import Fraction\n\n__all__ = [\"Fraction\"]\n","src/lib/pythonds3/intro/oop.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\ndef gcd(number1, number2):\n    \"\"\"Helper function to simplify fractions\"\"\"\n    if not isinstance(number1, int) or not isinstance(number2, int):\n        raise TypeError(\"Numerator and denominator must be integers\")\n    while number1 % number2:\n        number1, number2 = number2, number1 % number2\n    return number2\n\n\nclass Fraction:\n    \"\"\"Fraction class\"\"\"\n\n    def __init__(self, new_numer, new_denom):\n        try:\n            common = gcd(new_numer, new_denom)\n        except TypeError:\n            raise\n        self._numer = new_numer // common\n        self._denom = new_denom // common\n\n    @property\n    def numer(self):\n        \"\"\"Get numerator\"\"\"\n        return self._numer\n\n    @numer.setter\n    def set_numer(self, new_numer):\n        \"\"\"Set numerator\"\"\"\n        self._numer = new_numer\n\n    def get_denom(self):\n        \"\"\"Get deniminator\"\"\"\n        return self._denom\n\n    def set_denom(self, new_denom):\n        \"\"\"Set deniminator\"\"\"\n        self._denom = new_denom\n\n    # Another way to create an attribute\n    denom = property(get_denom, set_denom)\n\n    def __str__(self):\n        \"\"\"Get the string value\"\"\"\n        if self._numer > self._denom:\n            return \"{} {}/{}\".format(\n                self._numer // self._denom, self._numer % self._denom, self._denom\n            )\n        return \"{}/{}\".format(self._numer, self._denom)\n\n    def __repr__(self):\n        \"\"\"Fraction representation\"\"\"\n        return \"Fraction({}, {})\".format(self._numer, self._denom)\n\n    def __eq__(self, other):\n        \"\"\"Equality comparison\"\"\"\n        return self._numer * other.denom == other.numer * self._denom\n\n    def __add__(self, other):\n        \"\"\"Add two fractions\"\"\"\n        new_numer = self._numer * other.denom + self._denom * other.numer\n        new_denom = self._denom * other.denom\n        return Fraction(new_numer, new_denom)\n","src/lib/pythonds3/searching/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.search import statement\n\"\"\"\nfrom pythonds3.searching.hash_table import HashTable\n\n__all__ = [\"HashTable\"]\n","src/lib/pythonds3/searching/hash_table.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass HashTable:\n    \"\"\"Hash Table implementation\"\"\"\n\n    def __init__(self, size=16):\n        \"\"\"Create a hash table\"\"\"\n        self._size = size\n        self._slots = [None] * self._size\n        self._data = [None] * self._size\n\n    def __getitem__(self, key):\n        \"\"\"Magic __get__\"\"\"\n        return self.get(key)\n\n    def __setitem__(self, key, data):\n        \"\"\"Magic __set__\"\"\"\n        self.put(key, data)\n\n    def __len__(self):\n        \"\"\"Magic __len__\"\"\"\n        return self._size - self._slots.count(None)\n\n    def __contains__(self, key):\n        \"\"\"Magin in\"\"\"\n        return key in self._slots\n\n    def _hash_function(self, key, size):\n        \"\"\"Simple hash function\"\"\"\n        return key % size\n\n    def _rehash(self, old_hash, size, step=1):\n        \"\"\"Simple rehash function\"\"\"\n        return (old_hash + step) % size\n\n    def is_empty(self):\n        \"\"\"Check if the table is empty\"\"\"\n        return self._size == self._slots.count(None)\n\n    def size(self):\n        \"\"\"Get number of items in the table\"\"\"\n        return self._size - self._slots.count(None)\n\n    def put(self, key, data):\n        \"\"\"Add an item to the table\"\"\"\n        hash_value = self._hash_function(key, len(self._slots))\n\n        if self._slots[hash_value] is None:\n            self._slots[hash_value] = key\n            self._data[hash_value] = data\n        else:\n            if self._slots[hash_value] == key:\n                self._data[hash_value] = data  # replace\n            else:\n                j = 0\n                next_slot = self._rehash(hash_value, len(self._slots), j)\n                while (\n                    self._slots[next_slot] is not None\n                    and self._slots[next_slot] != key\n                    and j < self._size\n                ):\n                    j = j + 1\n                    next_slot = self._rehash(hash_value, len(self._slots), j)\n\n                if self._slots[next_slot] is None:\n                    self._slots[next_slot] = key\n                    self._data[next_slot] = data\n                elif j == self._size:\n                    raise Exception(\"Hash Table is full\")\n                else:\n                    self._data[next_slot] = data  # replace\n\n    def get(self, key):\n        \"\"\"Get an item from the table\"\"\"\n        start_slot = self._hash_function(key, len(self._slots))\n        position = start_slot\n        j = 0\n\n        while self._slots[position] is not None and j < self._size:\n            if self._slots[position] == key:\n                return self._data[position]\n            j = j + 1\n            position = self._rehash(start_slot, len(self._slots), j)\n\n        raise KeyError(\"{} is not in the table\".format(key))\n","src/lib/pythonds3/sorting/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.sorting import statement\n\"\"\"\nfrom pythonds3.sorting.sorting_algorithms import bubble_sort\nfrom pythonds3.sorting.sorting_algorithms import select_sort\nfrom pythonds3.sorting.sorting_algorithms import insert_sort\nfrom pythonds3.sorting.sorting_algorithms import shell_sort\nfrom pythonds3.sorting.sorting_algorithms import merge_sort\nfrom pythonds3.sorting.sorting_algorithms import quick_sort\nfrom pythonds3.sorting.sorting_algorithms import heap_sort\n","src/lib/pythonds3/sorting/sorting_algorithms.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport heapq\n\n\ndef bubble_sort(lst):\n    \"\"\"Bubble sort\"\"\"\n    for i in range(len(lst) - 1, 0, -1):\n        exchanges = False\n        for j in range(i):\n            if lst[j] > lst[j + 1]:\n                exchanges = True\n                lst[j], lst[j + 1] = lst[j + 1], lst[j]\n        if not exchanges:\n            break\n\n\ndef select_sort(lst):\n    \"\"\"Selection sort\"\"\"\n    for i, item in enumerate(lst):\n        min_idx = len(lst) - 1\n        for j in range(i, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            lst[min_idx], lst[i] = lst[i], lst[min_idx]\n\n\ndef insert_sort(lst):\n    \"\"\"Insertion sort\"\"\"\n    for i in range(1, len(lst)):\n        cur_val = lst[i]\n        cur_pos = i\n\n        while cur_pos > 0 and lst[cur_pos - 1] > cur_val:\n            lst[cur_pos] = lst[cur_pos - 1]\n            cur_pos = cur_pos - 1\n        lst[cur_pos] = cur_val\n\n\ndef shell_sort(lst):\n    \"\"\"Shell sort\"\"\"\n    sublist_count = len(lst) // 3\n    while sublist_count > 0:\n        for pos_start in range(sublist_count):\n            _gap_insert_sort(lst, pos_start, sublist_count)\n        sublist_count = sublist_count // 2\n\n\ndef _gap_insert_sort(lst, start, gap):\n    \"\"\"Shell sort helper function\"\"\"\n    for i in range(start + gap, len(lst), gap):\n        cur_val = lst[i]\n        cur_pos = i\n        while cur_pos >= gap and lst[cur_pos - gap] > cur_val:\n            lst[cur_pos] = lst[cur_pos - gap]\n            cur_pos = cur_pos - gap\n        lst[cur_pos] = cur_val\n\n\ndef merge_sort(lst):\n    \"\"\"Merge sort\"\"\"\n    if len(lst) > 1:\n        mid = len(lst) // 2\n        left_half = lst[:mid]\n        right_half = lst[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i, j, k = 0, 0, 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] <= right_half[j]:\n                lst[k] = left_half[i]\n                i = i + 1\n            else:\n                lst[k] = right_half[j]\n                j = j + 1\n            k = k + 1\n\n        while i < len(left_half):\n            lst[k] = left_half[i]\n            i = i + 1\n            k = k + 1\n\n        while j < len(right_half):\n            lst[k] = right_half[j]\n            j = j + 1\n            k = k + 1\n\n\ndef quick_sort(lst):\n    \"\"\"Quick sort\"\"\"\n    _quick_sort_help(lst, 0, len(lst) - 1)\n\n\ndef _quick_sort_help(lst, mark_l, mark_r):\n    \"\"\"Quick sort helper\"\"\"\n    if mark_l < mark_r:\n        split = _quick_sort_part(lst, mark_l, mark_r)\n        _quick_sort_help(lst, mark_l, split - 1)\n        _quick_sort_help(lst, split + 1, mark_r)\n\n\ndef _quick_sort_part(lst, mark_l, mark_r):\n    \"\"\"Quick sort partition\"\"\"\n    pivot_val = lst[mark_l]\n    mark_l_cur = mark_l + 1\n    mark_r_cur = mark_r\n    done = False\n\n    while not done:\n        while mark_l_cur <= mark_r_cur and lst[mark_l_cur] <= pivot_val:\n            mark_l_cur = mark_l_cur + 1\n        while mark_l_cur <= mark_r_cur and lst[mark_r_cur] >= pivot_val:\n            mark_r_cur = mark_r_cur - 1\n        if mark_r_cur < mark_l_cur:\n            done = True\n        else:\n            lst[mark_l_cur], lst[mark_r_cur] = lst[mark_r_cur], lst[mark_l_cur]\n    lst[mark_l], lst[mark_r_cur] = lst[mark_r_cur], lst[mark_l]\n\n    return mark_r_cur\n\n\ndef heap_sort(lst):\n    \"\"\"Heap sort\"\"\"\n    res = []\n    heapq.heapify(lst)\n    while lst:\n        res.append(heapq.heappop(lst))\n    for i in res:\n        lst.append(i)\n","src/lib/pythonds3/trees/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.trees import statement\n\"\"\"\nfrom pythonds3.trees.avl_tree import AVLTree\nfrom pythonds3.trees.binary_search_tree import BinarySearchTree\nfrom pythonds3.trees.binary_heap import BinaryHeap\nfrom pythonds3.trees.binary_tree import BinaryTree\nfrom pythonds3.trees.priority_queue import PriorityQueue\n\n__all__ = [\"BinaryTree\", \"BinaryHeap\", \"BinarySearchTree\", \"AVLTree\", \"PriorityQueue\"]\n","src/lib/pythonds3/trees/avl_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005, 2010\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nfrom pythonds3.trees.binary_search_tree import BinarySearchTree\nfrom pythonds3.trees.binary_search_tree import BinaryTreeNode\n\n\nclass AVLTreeNode(BinaryTreeNode):\n    \"\"\"AVL Tree Node\"\"\"\n\n    def __init__(self, key, val, balance_factor, left=None, right=None, parent=None):\n        \"\"\"Create an AVL tree node\"\"\"\n        BinaryTreeNode.__init__(self, key, val, left, right, parent)\n        self._balance_factor = balance_factor\n\n    def get_balance_factor(self):\n        \"\"\"Get the node balance factor\"\"\"\n        return self._balance_factor\n\n    def set_balance_factor(self, value):\n        \"\"\"Set the node balance factor\"\"\"\n        self._balance_factor = value\n\n    balance_factor = property(get_balance_factor, set_balance_factor)\n\n\nclass AVLTree(BinarySearchTree):\n    \"\"\"AVL tree implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a new AVL tree\"\"\"\n        BinarySearchTree.__init__(self)\n\n    def put(self, key, value):\n        \"\"\"Add new node\"\"\"\n        if self._root:\n            self._put(key, value, self._root)\n        else:\n            self._root = AVLTreeNode(key, value, 0)\n        self._size = self._size + 1\n\n    def _put(self, key, value, current_node):\n        \"\"\"Add a new node to the tree (helper function)\"\"\"\n        if key < current_node.key:\n            if current_node.get_child_left():\n                self._put(key, value, current_node.child_left)\n            else:\n                current_node.child_left = AVLTreeNode(\n                    key, value, 0, parent=current_node\n                )\n                self.update_balance(current_node.child_left)\n        else:\n            if current_node.get_child_right():\n                self._put(key, value, current_node.child_right)\n            else:\n                current_node.child_right = AVLTreeNode(\n                    key, value, 0, parent=current_node\n                )\n                self.update_balance(current_node.child_right)\n\n    def update_balance(self, node):\n        \"\"\"Update the tree balance\"\"\"\n        if node.balance_factor > 1 or node.balance_factor < -1:\n            self.rebalance(node)\n            return\n        if node.parent:\n            if node.is_child_left():\n                node.parent.balance_factor += 1\n            elif node.is_child_right():\n                node.parent.balance_factor -= 1\n\n            if node.parent.balance_factor != 0:\n                self.update_balance(node.parent)\n\n    def rebalance(self, node):\n        \"\"\"Rebalance the tree\"\"\"\n        if node.balance_factor < 0:\n            if node.child_right.balance_factor > 0:\n                # Do an LR Rotation\n                self.rotate_right(node.child_right)\n                self.rotate_left(node)\n            else:\n                # single left\n                self.rotate_left(node)\n        elif node.balance_factor > 0:\n            if node.child_left.balance_factor < 0:\n                # Do an RL Rotation\n                self.rotate_left(node.child_left)\n                self.rotate_right(node)\n            else:\n                # single right\n                self.rotate_right(node)\n\n    def rotate_left(self, rotation_root):\n        \"\"\"Left rotation\"\"\"\n        new_root = rotation_root.child_right\n        rotation_root.child_right = new_root.child_left\n        if new_root.child_left:\n            new_root.child_left.parent = rotation_root\n        new_root.parent = rotation_root.parent\n        if rotation_root.is_root():\n            self._root = new_root\n        else:\n            if rotation_root.is_child_left():\n                rotation_root.parent.child_left = new_root\n            else:\n                rotation_root.parent.child_right = new_root\n        new_root.child_left = rotation_root\n        rotation_root.parent = new_root\n        rotation_root.balance_factor = (\n            rotation_root.balance_factor + 1 - min(new_root.balance_factor, 0)\n        )\n        new_root.balance_factor = (\n            new_root.balance_factor + 1 + max(rotation_root.balance_factor, 0)\n        )\n\n    def rotate_right(self, rotation_root):\n        \"\"\"Right rotation\"\"\"\n        new_root = rotation_root.child_left\n        rotation_root.child_left = new_root.child_right\n        if new_root.child_right:\n            new_root.child_right.parent = rotation_root\n        new_root.parent = rotation_root.parent\n        if rotation_root.is_root():\n            self._root = new_root\n        else:\n            if rotation_root.is_child_right():\n                rotation_root.parent.child_right = new_root\n            else:\n                rotation_root.parent.child_left = new_root\n        new_root.child_right = rotation_root\n        rotation_root.parent = new_root\n        rotation_root.balance_factor = (\n            rotation_root.balance_factor - 1 - max(new_root.balance_factor, 0)\n        )\n        new_root.balance_factor = (\n            new_root.balance_factor - 1 + min(rotation_root.balance_factor, 0)\n        )\n","src/lib/pythonds3/trees/binary_heap.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass BinaryHeap:\n    \"\"\"Minimal Binary Heap\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a heap\"\"\"\n        self._heap = []\n\n    def _perc_up(self, cur_idx):\n        \"\"\"Move a node up\"\"\"\n        while (cur_idx - 1) // 2 >= 0:\n            parent_idx = (cur_idx - 1) // 2\n            if self._heap[cur_idx] < self._heap[parent_idx]:\n                self._heap[cur_idx], self._heap[parent_idx] = (\n                    self._heap[parent_idx],\n                    self._heap[cur_idx],\n                )\n            cur_idx = parent_idx\n\n    def _perc_down(self, cur_idx):\n        \"\"\"Move a node down\"\"\"\n        while 2 * cur_idx + 1 < len(self._heap):\n            min_child_idx = self._get_min_child(cur_idx)\n            if self._heap[cur_idx] > self._heap[min_child_idx]:\n                self._heap[cur_idx], self._heap[min_child_idx] = (\n                    self._heap[min_child_idx],\n                    self._heap[cur_idx],\n                )\n            else:\n                return\n            cur_idx = min_child_idx\n\n    def _get_min_child(self, parent_idx):\n        \"\"\"Get a smaller child\"\"\"\n        if 2 * parent_idx + 2 > len(self._heap) - 1:\n            return 2 * parent_idx + 1\n        if self._heap[2 * parent_idx + 1] < self._heap[2 * parent_idx + 2]:\n            return 2 * parent_idx + 1\n        return 2 * parent_idx + 2\n\n    def heapify(self, not_a_heap, show_details=False):\n        \"\"\"Build a heap from any list\"\"\"\n        self._heap = not_a_heap[:]\n        cur_idx = len(self._heap) // 2 - 1\n        while cur_idx >= 0:\n            self._perc_down(cur_idx)\n            cur_idx = cur_idx - 1\n            if show_details:\n                print(self._heap)\n\n    def insert(self, item):\n        \"\"\"Add a new item\"\"\"\n        self._heap.append(item)\n        self._perc_up(len(self._heap) - 1)\n\n    def delete(self):\n        \"\"\"Remove an item\"\"\"\n        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]\n        result = self._heap.pop()\n        self._perc_down(0)\n        return result\n\n    def is_empty(self):\n        \"\"\"Check if the heap is empty\"\"\"\n        return not bool(self._heap)\n\n    def __len__(self):\n        \"\"\"Get heap size\"\"\"\n        return len(self._heap)\n\n    def __str__(self):\n        \"\"\"Heap as a string\"\"\"\n        return str(self._heap)\n\n    def __contains__(self, item):\n        \"\"\"__contains__in method override\"\"\"\n        return item in self._heap\n","src/lib/pythonds3/trees/binary_search_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005, 2010\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass BinaryTreeNode:\n    \"\"\"Binary Tree Node class\"\"\"\n\n    def __init__(self, key, value, left=None, right=None, parent=None):\n        \"\"\"Create new Tree Node\"\"\"\n        self._key = key\n        self._value = value\n        self._child_left = left\n        self._child_right = right\n        self._parent = parent\n\n    def get_child_left(self):\n        \"\"\"Return the node's left child\"\"\"\n        return self._child_left\n\n    def set_child_left(self, node):\n        \"\"\"Assign the node's left child\"\"\"\n        self._child_left = node\n\n    child_left = property(get_child_left, set_child_left)\n\n    def get_child_right(self):\n        \"\"\"Return the node's right child\"\"\"\n        return self._child_right\n\n    def set_child_right(self, node):\n        \"\"\"Assign the node's right child\"\"\"\n        self._child_right = node\n\n    child_right = property(get_child_right, set_child_right)\n\n    def get_parent(self):\n        \"\"\"Return the node's parent\"\"\"\n        return self._parent\n\n    def set_parent(self, node):\n        \"\"\"Assign the node's parent\"\"\"\n        self._parent = node\n\n    parent = property(get_parent, set_parent)\n\n    def is_child_left(self):\n        \"\"\"Check if the node is a left child\"\"\"\n        return self._parent and self._parent.child_left == self\n\n    def is_child_right(self):\n        \"\"\"Check if the node is a right child\"\"\"\n        return self._parent and self._parent.child_right == self\n\n    def is_root(self):\n        \"\"\"Check if the node is a tree root\"\"\"\n        return not self._parent\n\n    def is_leaf(self):\n        \"\"\"Check if the node is a leaf\"\"\"\n        return not (self._child_right or self._child_left)\n\n    def has_a_child(self):\n        \"\"\"Check if the node has any child\"\"\"\n        return self._child_right or self._child_left\n\n    def has_children(self):\n        \"\"\"Check if the node has both children\"\"\"\n        return self._child_right and self._child_left\n\n    def get_key(self):\n        \"\"\"Get node key\"\"\"\n        return self._key\n\n    def set_key(self, key):\n        \"\"\"Set node key\"\"\"\n        self._key = key\n\n    key = property(get_key, set_key)\n\n    def get_value(self):\n        \"\"\"Get node value\"\"\"\n        return self._value\n\n    def set_value(self, value):\n        \"\"\"Set node value\"\"\"\n        self._value = value\n\n    value = property(get_value, set_value)\n\n    def replace_payload(self, key, value, left, right):\n        \"\"\"Change node payload\"\"\"\n        self._key = key\n        self._value = value\n        self._child_left = left\n        self._child_right = right\n        if self.child_left:\n            self._child_left.parent = self\n        if self.child_right:\n            self._child_right.parent = self\n\n    def find_successor(self):\n        \"\"\"Find the node's successor\"\"\"\n        successor = None\n        if self._child_right:\n            successor = self._child_right.find_min()\n        else:\n            if self._parent:\n                if self.is_child_left():\n                    successor = self._parent\n                else:\n                    self._parent.child_right = None\n                    successor = self._parent.find_successor()\n                    self._parent.child_right = self\n        return successor\n\n    def find_min(self):\n        \"\"\"Find the smallest node in the right subtree\"\"\"\n        current = self\n        while current.child_left:\n            current = current.child_left\n        return current\n\n    def splice_out(self):\n        \"\"\"Splice out\"\"\"\n        if self.is_leaf():\n            if self.is_child_left():\n                self._parent.child_left = None\n            else:\n                self._parent.child_right = None\n        elif self.has_a_child():\n            if self.child_left:\n                if self.is_child_left():\n                    self._parent.child_left = self._child_left\n                else:\n                    self._parent.child_right = self._child_left\n                self._child_left.parent = self._parent\n            else:\n                if self.is_child_left():\n                    self._parent.child_left = self._child_right\n                else:\n                    self._parent.child_right = self._child_right\n                self._child_right.parent = self._parent\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree\"\"\"\n        if self:\n            if self._child_left:\n                for elem in self._child_left:\n                    yield elem\n            yield self._key\n            if self._child_right:\n                for elem in self._child_right:\n                    yield elem\n\n\nclass BinarySearchTree:\n    \"\"\"Binary search tree implementation\"\"\"\n\n    def __init__(self):\n        self._root = None\n        self._size = 0\n\n    def __len__(self):\n        \"\"\"Tree size\"\"\"\n        return self._size\n\n    def size(self):\n        \"\"\"Tree size\"\"\"\n        return self._size\n\n    def __iter__(self):\n        \"\"\"Iterator\"\"\"\n        return self._root.__iter__()\n\n    def __getitem__(self, key):\n        \"\"\"[] getter operator override\"\"\"\n        result = self.get(key)\n        if result:\n            return result\n        raise KeyError(\"Error, key not in tree\")\n\n    def get_root(self):\n        \"\"\"Get tree root\"\"\"\n        return self._root\n\n    def set_root(self, node):\n        \"\"\"Set tree root\"\"\"\n        self._root = node\n\n    root = property(get_root, set_root)\n\n    def get(self, key):\n        \"\"\"Retrieve a value by the key\"\"\"\n        if self._root:\n            result = self._get(key, self._root)\n            if result:\n                return result.value\n            return None\n        else:\n            return None\n\n    def _get(self, key, current_node):\n        \"\"\"Retrieve a value by the key (helper function)\"\"\"\n        if not current_node:\n            return None\n        if current_node.key == key:\n            return current_node\n        elif key < current_node.key:\n            return self._get(key, current_node.child_left)\n        else:\n            return self._get(key, current_node.child_right)\n\n    def __setitem__(self, key, value):\n        \"\"\"[] setter operator override\"\"\"\n        self.put(key, value)\n\n    def put(self, key, value):\n        \"\"\"Add new node\"\"\"\n        if self._root:\n            self._put(key, value, self._root)\n        else:\n            self._root = BinaryTreeNode(key, value)\n        self._size = self._size + 1\n\n    def _put(self, key, value, current_node):\n        \"\"\"Add new node (helper function)\"\"\"\n        if key < current_node.key:\n            if current_node.child_left:\n                self._put(key, value, current_node.child_left)\n            else:\n                current_node.child_left = BinaryTreeNode(\n                    key, value, parent=current_node\n                )\n        else:\n            if current_node.child_right:\n                self._put(key, value, current_node.child_right)\n            else:\n                current_node.child_right = BinaryTreeNode(\n                    key, value, parent=current_node\n                )\n\n    def __contains__(self, key):\n        \"\"\"in operator override\"\"\"\n        return bool(self._get(key, self._root))\n\n    def __delitem__(self, key):\n        \"\"\"del operator override\"\"\"\n        self.delete(key)\n\n    def delete(self, key):\n        \"\"\"Remove a node by its key\"\"\"\n        if self._size > 1:\n            node_to_remove = self._get(key, self._root)\n            if node_to_remove:\n                self._delete(node_to_remove)\n                self._size = self._size - 1\n            else:\n                raise KeyError(\"Error, key not in tree\")\n        elif self._size == 1 and self._root.key == key:\n            self._root = None\n            self._size = self._size - 1\n        else:\n            raise KeyError(\"Error, key not in tree\")\n\n    def _delete(self, current_node):\n        \"\"\"Remove a node by its key (helper function)\"\"\"\n        if current_node.is_leaf():  # removing a leaf\n            if current_node == current_node.parent.child_left:\n                current_node.parent.child_left = None\n            else:\n                current_node.parent.child_right = None\n        elif current_node.has_children():  # removing a node with two children\n            successor = current_node.find_successor()\n            successor.splice_out()\n            current_node.key = successor.key\n            current_node.value = successor.value\n        else:  # removing a node with one child\n            if current_node.get_child_left():\n                if current_node.is_child_left():\n                    current_node.child_left.parent = current_node.parent\n                    current_node.parent.child_left = current_node.child_left\n                elif current_node.is_child_right():\n                    current_node.child_left.parent = current_node.parent\n                    current_node.parent.child_right = current_node.child_left\n                else:\n                    current_node.replace_payload(\n                        current_node.child_left.key,\n                        current_node.child_left.value,\n                        current_node.child_left.child_left,\n                        current_node.child_left.child_right,\n                    )\n            else:\n                if current_node.is_child_left():\n                    current_node.child_right.parent = current_node.parent\n                    current_node.parent.child_left = current_node.child_right\n                elif current_node.is_child_right():\n                    current_node.child_right.parent = current_node.parent\n                    current_node.parent.child_right = current_node.child_right\n                else:\n                    current_node.replace_payload(\n                        current_node.child_right.key,\n                        current_node.child_right.value,\n                        current_node.child_right.child_left,\n                        current_node.child_right.child_right,\n                    )\n\n    def inorder(self):\n        \"\"\"In-order tree traversal\"\"\"\n        self._inorder(self._root)\n\n    def _inorder(self, tree):\n        \"\"\"In-order tree traversal (helper function)\"\"\"\n        if tree:\n            self._inorder(tree.child_left)\n            print(tree.key, end=\" \")\n            self._inorder(tree.child_right)\n\n    def postorder(self):\n        \"\"\"Post-order tree traversal\"\"\"\n        self._postorder(self._root)\n\n    def _postorder(self, tree):\n        \"\"\"Post-order tree traversal (helper function)\"\"\"\n        if tree:\n            self._postorder(tree.child_left)\n            self._postorder(tree.child_right)\n            print(tree.key, end=\" \")\n\n    def preorder(self):\n        \"\"\"Pre-order tree traversal\"\"\"\n        self._preorder(self._root)\n\n    def _preorder(self, tree):\n        \"\"\"Pre-order tree traversal (helper function)\"\"\"\n        if tree:\n            print(tree.key, end=\" \")\n            self._preorder(tree.child_left)\n            self._preorder(tree.child_right)\n\n    def clear(self):\n        \"\"\"Remove all nodes\"\"\"\n        while self._root:\n            self.delete(self._root.key)\n","src/lib/pythonds3/trees/binary_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport operator\n\n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n\n    Modified to allow for trees to be constructed from other trees\n    rather than always creating a new tree in the insert_feft or insert_right\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"Create new tree\"\"\"\n        self._key = key\n        self._child_left = None\n        self._child_right = None\n\n    def get_root_val(self):\n        \"\"\"Get root key value\"\"\"\n        return self._key\n\n    def set_root_val(self, key):\n        \"\"\"Set root key value\"\"\"\n        self._key = key\n\n    root = property(get_root_val, set_root_val)\n\n    def get_child_left(self):\n        \"\"\"Get left child\"\"\"\n        return self._child_left\n\n    def set_child_left(self, node):\n        \"\"\"Set left child\"\"\"\n        self._child_left = node\n\n    child_left = property(get_child_left, set_child_left)\n\n    def get_child_right(self):\n        \"\"\"Get right child\"\"\"\n        return self._child_right\n\n    def set_child_right(self, node):\n        \"\"\"Set right child\"\"\"\n        self._child_right = node\n\n    child_right = property(get_child_right, set_child_right)\n\n    def is_leaf(self):\n        \"\"\"Check if a node is leaf\"\"\"\n        return (not self._child_left) and (not self._child_right)\n\n    def insert_left(self, new_node):\n        \"\"\"Insert left subtree\"\"\"\n        if isinstance(new_node, BinaryTree):\n            new_subtree = new_node\n        else:\n            new_subtree = BinaryTree(new_node)\n\n        if self._child_left:\n            new_subtree.set_child_left(self._child_left)\n\n        self._child_left = new_subtree\n\n    def insert_right(self, new_node):\n        \"\"\"Insert right subtree\"\"\"\n        if isinstance(new_node, BinaryTree):\n            new_subtree = new_node\n        else:\n            new_subtree = BinaryTree(new_node)\n\n        if self._child_right:\n            new_subtree.set_child_right(self._child_right)\n        self._child_right = new_subtree\n\n    def preorder(self):\n        \"\"\"Pre-order tree traversal\"\"\"\n        print(self._key, end=\" \")\n        if self._child_left:\n            self._child_left.preorder()\n        if self._child_right:\n            self._child_right.preorder()\n\n    def inorder(self):\n        \"\"\"In-order tree traversal\"\"\"\n        if self._child_left:\n            self._child_left.inorder()\n        print(self._key, end=\" \")\n        if self._child_right:\n            self._child_right.inorder()\n\n    def postorder(self):\n        \"\"\"Post-order tree traversal\"\"\"\n        if self._child_left:\n            self._child_left.postorder()\n        if self._child_right:\n            self._child_right.postorder()\n        print(self._key, end=\" \")\n\n    def print_exp(self):\n        \"\"\"Print an expression\"\"\"\n        if self._child_left:\n            print(\"(\", end=\" \")\n            self._child_left.print_exp()\n        print(self._key, end=\" \")\n        if self._child_right:\n            self._child_right.print_exp()\n            print(\")\", end=\" \")\n\n    def postorder_eval(self):\n        \"\"\"Postorder evaluation\"\"\"\n        operations = {\n            \"+\": operator.add,\n            \"-\": operator.sub,\n            \"*\": operator.mul,\n            \"/\": operator.truediv,\n        }\n        result_1 = None\n        result_2 = None\n        if self._child_left:\n            result_1 = self._child_left.postorder_eval()\n        if self._child_right:\n            result_2 = self._child_right.postorder_eval()\n        if result_1 and result_2:\n            return operations[self._key](result_1, result_2)\n        return self._key\n\n    def height(self):\n        \"\"\"Height of a tree\"\"\"\n        if not self._key:\n            return -1\n        if self._child_left:\n            height_left = self._child_left.height()\n        else:\n            height_left = -1\n\n        if self._child_right:\n            height_right = self._child_right.height()\n        else:\n            height_right = -1\n\n        return 1 + max(height_left, height_right)\n\n    def __len__(self):\n        \"\"\"Size of a tree\"\"\"\n        return self.size()\n\n    def size(self):\n        \"\"\"Count nodes in a tree\"\"\"\n        if not self._key:\n            return 0\n        if self._child_left:\n            children_left = self._child_left.size()\n        else:\n            children_left = 0\n\n        if self._child_right:\n            children_right = self._child_right.size()\n        else:\n            children_right = 0\n\n        return 1 + children_left + children_right\n","src/lib/pythonds3/trees/priority_queue.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nfrom pythonds3.trees.binary_heap import BinaryHeap\n\n\nclass PriorityQueue(BinaryHeap):\n    \"\"\"\n    This implementation of binary heap takes (key, value) pairs where key signifies priority\n    We will assume that the keys are all comparable.\n    \"\"\"\n\n    def change_priority(self, new_priority, value):\n        \"\"\"Change the priority\"\"\"\n        key_to_move = 0\n        for i in range(len(self._heap)):\n            if self._heap[i][1] == value:\n                key_to_move = i\n                break\n        if key_to_move > -1:\n            self._heap[key_to_move] = (new_priority, self._heap[key_to_move][1])\n            self._perc_up(key_to_move)\n","src/lib/pythoned/__init__.py":"","src/lib/pythoned/arboles/__init__.py":"\n\n\nfrom .avl import ArbolAVL\nfrom .abb import ArbolBinarioBusqueda\nfrom .monticuloBinario import MonticuloBinario\n\n\n","src/lib/pythoned/arboles/abb.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#abb.py\n\nclass ArbolBinarioBusqueda:\n\n    def __init__(self):\n        self.raiz = None\n        self.tamano = 0\n\n    def agregar(self,clave,valor):\n        if self.raiz:\n            self._agregar(clave,valor,self.raiz)\n        else:\n            self.raiz = NodoArbol(clave,valor)\n        self.tamano = self.tamano + 1\n\n    def _agregar(self,clave,valor,nodoActual):\n        if clave < nodoActual.clave:\n            if nodoActual.tieneHijoIzquierdo():\n                   self._agregar(clave,valor,nodoActual.hijoIzquierdo)\n            else:\n                   nodoActual.hijoIzquierdo = NodoArbol(clave,valor,padre=nodoActual)\n        else:\n            if nodoActual.tieneHijoDerecho():\n                   self._agregar(clave,valor,nodoActual.hijoDerecho)\n            else:\n                   nodoActual.hijoDerecho = NodoArbol(clave,valor,padre=nodoActual)\n \n    def __setitem__(self,c,v):\n        self.agregar(c,v)\n\n    def obtener(self,clave):\n        if self.raiz:\n            res = self._obtener(clave,self.raiz)\n            if res:\n                return res.cargaUtil\n            else:\n                return None\n        else:\n            return None\n\n    def _obtener(self,clave,nodoActual):\n    \tif not nodoActual:\n    \t    return None\n    \telif nodoActual.clave == clave:\n    \t    return nodoActual\n    \telif clave < nodoActual.clave:\n    \t    return self._obtener(clave,nodoActual.hijoIzquierdo)\n    \telse:\n    \t    return self._obtener(clave,nodoActual.hijoDerecho)        \n\n    def __getitem__(self,clave):\n        res = self.obtener(clave) \n        if res:\n            return res\n        else:\n            raise KeyError('Error, la clave no está en el árbol')\n\n    def __contains__(self,clave):\n    \tif self._obtener(clave,self.raiz):\n    \t    return True\n    \telse:\n    \t    return False\n       \n    def longitud(self):\n        return self.tamano\n\n    def __len__(self):\n        return self.tamano\n\n    def __iter__(self):\n        return self.raiz.__iter__()\n\n    def eliminar(self,clave):\n        if self.tamano > 1:\n           nodoAEliminar = self._obtener(clave,self.raiz)\n    \t   if nodoAEliminar:\n    \t       self.remover(nodoAEliminar)\n    \t       self.tamano = self.tamano-1\n    \t   else:\n    \t       raise KeyError('Error, la clave no está en el árbol')\n        elif self.tamano == 1 and self.raiz.clave == clave:\n    \t    self.raiz = None\n    \t    self.tamano = self.tamano - 1\n        else:\n    \t    raise KeyError('Error, la clave no está en el árbol')\n\n    def __delitem__(self,clave):\n        self.eliminar(clave)\n\n    def remover(self,nodoActual):\n        if nodoActual.esHoja(): #hoja\n            if nodoActual == nodoActual.padre.hijoIzquierdo:\n                nodoActual.padre.hijoIzquierdo = None\n            else:\n                nodoActual.padre.hijoDerecho = None\n        elif nodoActual.tieneAmbosHijos(): #interior\n            suc = nodoActual.encontrarSucesor()\n            suc.empalmar()\n            nodoActual.clave = suc.clave\n            nodoActual.cargaUtil = suc.cargaUtil\n\n        else: # este nodo tiene un (1) hijo\n            if nodoActual.tieneHijoIzquierdo():\n                if nodoActual.esHijoIzquierdo():\n                    nodoActual.hijoIzquierdo.padre = nodoActual.padre\n                    nodoActual.padre.hijoIzquierdo = nodoActual.hijoIzquierdo\n                elif nodoActual.esHijoDerecho():\n                    nodoActual.hijoIzquierdo.padre = nodoActual.padre\n                    nodoActual.padre.hijoDerecho = nodoActual.hijoIzquierdo\n                else:\n                    nodoActual.reemplazarDatoDeNodo(nodoActual.hijoIzquierdo.clave, nodoActual.hijoIzquierdo.cargaUtil, nodoActual.hijoIzquierdo.hijoIzquierdo, nodoActual.hijoIzquierdo.hijoDerecho)\n            else:\n                if nodoActual.esHijoIzquierdo():\n                    nodoActual.hijoDerecho.padre = nodoActual.padre\n                    nodoActual.padre.hijoIzquierdo = nodoActual.hijoDerecho\n                elif nodoActual.esHijoDerecho():\n                    nodoActual.hijoDerecho.padre = nodoActual.padre\n                    nodoActual.padre.hijoDerecho = nodoActual.hijoDerecho\n                else:\n                    nodoActual.reemplazarDatoDeNodo(nodoActual.hijoDerecho.clave, nodoActual.hijoDerecho.cargaUtil, nodoActual.hijoDerecho.hijoIzquierdo, nodoActual.hijoDerecho.hijoDerecho)\n\n    def inorden(self):\n        self._inorden(self.raiz)\n\n    def _inorden(self,arbol):\n        if arbol != None:\n            self._inorden(arbol.hijoIzquierdo)\n            print(arbol.clave)\n            self._inorden(arbol.hijoDerecho)\n\n    def postorden(self):\n        self._postorden(self.raiz)\n\n    def _postorden(self, arbol):\n        if arbol:\n            self._postorden(arbol.hijoDerecho)\n            self._postorden(arbol.hijoIzquierdo)\n            print(arbol.clave)            \n\n    def preorden(self):\n        self._preorden(self,self.raiz)\n\n    def _preorden(self,arbol):\n        if arbol:\n            print(arbol.clave)            \n            self._preorden(arbol.hijoIzquierdo)\n            self._preorden(arbol.hijoDerecho)\n\n\nclass NodoArbol:\n   def __init__(self,clave,valor,izquierdo=None,derecho=None,padre=None):\n        self.clave = clave\n        self.cargaUtil = valor\n        self.hijoIzquierdo = izquierdo\n        self.hijoDerecho = derecho\n        self.padre = padre\n        self.factorEquilibrio = 0\n\n    def tieneHijoIzquierdo(self):\n        return self.hijoIzquierdo\n       \n    def tieneHijoDerecho(self):\n        return self.hijoDerecho\n\n    def esHijoIzquierdo(self):\n        return self.padre and self.padre.hijoIzquierdo == self\n    \n    def esHijoDerecho(self):\n        return self.padre and self.padre.hijoDerecho == self\n\n    def esRaiz(self):\n        return not self.padre\n\n    def esHoja(self):\n        return not (self.hijoDerecho or self.hijoIzquierdo)\n\n    def tieneAlgunHijo(self):\n        return self.hijoDerecho or self.hijoIzquierdo\n\n    def tieneAmbosHijos(self):\n        return self.hijoDerecho and self.hijoIzquierdo\n\n    def reemplazarDatoDeNodo(self,clave,valor,hizq,hder):\n        self.clave = clave\n        self.cargaUtil = valor\n        self.hijoIzquierdo = hizq\n        self.hijoDerecho = hder\n        if self.tieneHijoIzquierdo():\n            self.hijoIzquierdo.padre = self\n        if self.tieneHijoDerecho():\n            self.hijoDerecho.padre = self    \n\n    def encontrarSucesor(self):\n        suc = None\n        if self.tieneHijoDerecho():\n            suc = self.hijoDerecho.encontrarMin()\n        else:\n            if self.padre:\n                if self.esHijoIzquierdo():\n                    suc = self.padre\n                else:\n                    self.padre.hijoDerecho = None\n                    suc = self.padre.encontrarSucesor()\n                    self.padre.hijoDerecho = self\n        return suc\n\n    def empalmar(self):\n        if self.esHoja():\n            if self.esHijoIzquierdo():\n                self.padre.hijoIzquierdo = None\n            else:\n                self.padre.hijoDerecho = None\n        elif self.tieneAlgunHijo():\n            if self.tieneHijoIzquierdo():\n                if self.esHijoIzquierdo():\n                    self.padre.hijoIzquierdo = self.hijoIzquierdo\n                else:\n                    self.padre.hijoDerecho = self.hijoIzquierdo\n                self.hijoIzquierdo.padre = self.padre\n            else:\n                if self.esHijoIzquierdo():\n                    self.padre.hijoIzquierdo = self.hijoDerecho\n                else:\n                    self.padre.hijoDerecho = self.hijoDerecho\n                self.hijoDerecho.padre = self.padre\n\n    def encontrarMin(self):\n        actual = self\n        while actual.tieneHijoIzquierdo():\n            actual = actual.hijoIzquierdo\n        return actual\n\n    def __iter__(self):\n        if self:\n    \t    if self.tieneHijoIzquierdo():\n    \t        for elem in self.hijoIzquierdo:\n    \t\t    yield elem\n            yield self.clave\n    \t    if self.tieneHijoDerecho():\n                for elem in self.hijoDerecho:\n    \t\t    yield elem\n","src/lib/pythoned/arboles/arbolBinario.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#arbolBinario.py\n\nclass ArbolBinario:\n    def __init__(self,objetoRaiz):\n        self.clave = objetoRaiz\n        self.hijoIzquierdo = None\n        self.hijoDerecho = None\n    \n    def insertarIzquierdo(self,nuevoNodo):\n        if self.hijoIzquierdo == None:\n            self.hijoIzquierdo = ArbolBinario(nuevoNodo)\n        else:  \n            t = ArbolBinario(nuevoNodo)\n            t.hijoIzquierdo = self.hijoIzquierdo\n            self.hijoIzquierdo = t\n\n    def insertarDerecho(self,nuevoNodo):\n        if self.hijoDerecho == None:\n            self.hijoDerecho = ArbolBinario(nuevoNodo)\n        else:\n            t = ArbolBinario(nuevoNodo)\n            t.hijoDerecho = self.hijoDerecho\n            self.hijoDerecho = t\n\n    def esHoja(self):\n        return ((not self.hijoIzquierdo) and (not self.hijoDerecho))\n\n    def obtenerHijoDerecho(self):\n        return self.hijoDerecho\n    \n    def obtenerHijoIzquierdo(self):\n        return self.hijoIzquierdo\n    \n    def asignarValorRaiz(self,obj):\n        self.clave = obj\n\n    def obtenerValorRaiz(self):\n        return self.clave\n\n    def inorden(self):\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.inorden()\n        print(self.clave)\n        if self.hijoDerecho:\n            self.hijoDerecho.inorden()\n\n    def postorden(self):\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.postorden()\n        if self.hijoDerecho:\n            self.hijoDerecho.postorden()\n        print(self.clave)\n\n    def preorden(self):\n        print(self.clave)\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.preorden()\n        if self.hijoDerecho:\n            self.hijoDerecho.preorden()\n\n    def imprimirExpresion(self):\n        if self.hijoIzquierdo:\n            print('(', end=' ')\n            self.hijoIzquierdo.imprimirExpresion()\n        print(self.clave, end=' ')\n        if self.hijoDerecho:\n            self.hijoDerecho.imprimirExpresion()\n            print(')', end=' ')\n\n    def evalPostorden(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.hijoIzquierdo:\n            res1 = self.hijoIzquierdo.evalPostorden()  #// \\label{peleft}\n        if self.hijoDerecho:\n            res2 = self.hijoDerecho.evalPostorden() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.clave](res1,res2) #// \\label{peeval}\n        else:\n            return self.clave\n\ndef inorden(arbol):\n    if arbol != None:\n        inorden(arbol.obtenerHijoIzquierdo())\n        print(arbol.obtenerValorRaiz())\n        inorden(arbol.obtenerHijoDerecho())\n\ndef imprimirExpresion(arbol):\n    if arbol.hijoIzquierdo:\n        print('(', end=' ')\n        imprimirExpresion(arbol.obtenerHijoIzquierdo())\n    print(arbol.obtenerValorRaiz(), end=' ')\n    if arbol.hijoDerecho:\n        imprimirExpresion(arbol.obtenerHijoDerecho())\n        print(')', end=' ') \n\ndef imprimirExpresion(arbol):\n  valorCadena = \"\"\n  if arbol:\n      valorCadena = '(' + imprimirExpresion(arbol.obtenerHijoIzquierdo())\n      valorCadena = valorCadena + str(arbol.obtenerValorRaiz())\n      valorCadena = valorCadena + imprimirExpresion(arbol.obtenerHijoDerecho())+')'\n  return valorCadena\n\ndef evalPostorden(arbol):\n    operadores = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if arbol:\n        res1 = evalPostorden(arbol.obtenerHijoIzquierdo()) #// \\label{peleft}\n        res2 = evalPostorden(arbol.obtenerHijoDerecho())  #// \\label{peright}\n        if res1 and res2:\n            return operadores[arbol.obtenerValorRaiz()](res1,res2) #// \\label{peeval}\n        else:\n            return arbol.obtenerValorRaiz()\n\ndef altura(arbol):\n    if arbol == None:\n        return -1\n    else:\n        return 1 + max(altura(arbol.hijoIzquierdo),altura(arbol.hijoDerecho))\n\nt = ArbolBinario(7)\nt.insertarIzquierdo(3)\nt.insertarDerecho(9)\ninorden(t)\nimport operator\nx = ArbolBinario('*')\nx.insertarIzquierdo('+')\nl = x.obtenerHijoIzquierdo()\nl.insertarIzquierdo(4)\nl.insertarDerecho(5)\nx.insertarDerecho(7)\nprint(imprimirExpresion(x))\nprint(evalPostorden(x))\nprint(altura(x))\n","src/lib/pythoned/arboles/avl.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#avl.py\n\nfrom .abb import ArbolBinarioBusqueda, NodoArbol\n\nclass ArbolAVL(ArbolBinarioBusqueda):\n\n    def _agregar(self,clave,valor,nodoActual):\n    \tif clave < nodoActual.clave:\n    \t    if nodoActual.tieneHijoIzquierdo():\n    \t\tself._agregar(clave,valor,nodoActual.hijoIzquierdo)\n    \t    else:\n    \t\tnodoActual.hijoIzquierdo = NodoArbol(clave,valor,padre=nodoActual)\n    \t\tself.actualizarEquilibrio(nodoActual.hijoIzquierdo)\n    \telse:\n    \t    if nodoActual.tieneHijoDerecho():\n    \t\tself._agregar(clave,valor,nodoActual.hijoDerecho)\n    \t    else:\n    \t\tnodoActual.hijoDerecho = NodoArbol(clave,valor,padre=nodoActual)\n    \t\tself.actualizarEquilibrio(nodoActual.hijoDerecho)\n\n    def actualizarEquilibrio(self,nodo):\n    \tif nodo.factorEquilibrio > 1 or nodo.factorEquilibrio < -1:\n    \t    self.reequilibrar(nodo)    \n    \t    return\n    \tif nodo.padre != None:\n    \t    if nodo.esHijoIzquierdo():\n    \t\t    nodo.padre.factorEquilibrio += 1\n    \t    elif nodo.esHijoDerecho():\n    \t\t    nodo.padre.factorEquilibrio -= 1\n\n    \t    if nodo.padre.factorEquilibrio != 0:\n    \t\t    self.actualizarEquilibrio(nodo.padre)\n\n    def reequilibrar(self,nodo):\n        if nodo.factorEquilibrio < 0:\n\t    if nodo.hijoDerecho.factorEquilibrio > 0:\n\t        self.rotarDerecha(nodo.hijoDerecho)\n\t        self.rotarIzquierda(nodo)\n\t    else:\n\t        self.rotarIzquierda(nodo)\n        elif nodo.factorEquilibrio > 0:\n\t    if nodo.hijoIzquierdo.factorEquilibrio < 0:\n\t        self.rotarIzquierda(nodo.hijoIzquierdo)\n\t        self.rotarDerecha(nodo)\n\t     else:\n\t        self.rotarDerecha(nodo)\n           \n    def rotarIzquierda(self,rotRaiz):\n    \tnuevaRaiz = rotRaiz.hijoDerecho\n    \trotRaiz.hijoDerecho = nuevaRaiz.hijoIzquierdo\n    \tif nuevaRaiz.hijoIzquierdo != None:\n    \t    nuevaRaiz.hijoIzquierdo.padre = rotRaiz\n    \tnuevaRaiz.padre = rotRaiz.padre\n    \tif rotRaiz.esRaiz():\n    \t    self.raiz = nuevaRaiz\n    \telse:\n    \t    if rotRaiz.esHijoIzquierdo():\n    \t        rotRaiz.padre.hijoIzquierdo = nuevaRaiz\n    \t    else:\n    \t    \trotRaiz.padre.hijoDerecho = nuevaRaiz\n    \tnuevaRaiz.hijoIzquierdo = rotRaiz\n    \trotRaiz.padre = nuevaRaiz\n    \trotRaiz.factorEquilibrio = rotRaiz.factorEquilibrio + 1 - min(nuevaRaiz.factorEquilibrio, 0)\n    \tnuevaRaiz.factorEquilibrio = nuevaRaiz.factorEquilibrio + 1 + max(rotRaiz.factorEquilibrio, 0)\n\n    def rotarDerecha(self,rotRaiz):\n        nuevaRaiz = rotRaiz.hijoIzquierdo\n        rotRaiz.hijoIzquierdo = nuevaRaiz.hijoDerecho\n        if nuevaRaiz.hijoDerecho != None:\n            nuevaRaiz.hijoDerecho.padre = rotRaiz\n        nuevaRaiz.padre = rotRaiz.padre\n        if rotRaiz.esRaiz():\n            self.raiz = nuevaRaiz\n        else:\n            if rotRaiz.esHijoDerecho():\n                rotRaiz.padre.hijoDerecho = nuevaRaiz\n            else:\n                rotRaiz.padre.hijoIzquierdo = nuevaRaiz\n        nuevaRaiz.hijoDerecho = rotRaiz\n        rotRaiz.padre = nuevaRaiz\n        rotRaiz.factorEquilibrio = rotRaiz.factorEquilibrio - 1 - max(nuevaRaiz.factorEquilibrio, 0)\n        nuevaRaiz.factorEquilibrio = nuevaRaiz.factorEquilibrio - 1 + min(rotRaiz.factorEquilibrio, 0)  \n\n","src/lib/pythoned/arboles/monticuloBinario.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#monticuloBinario.py\n\nclass MonticuloBinario:\n    def __init__(self):\n        self.listaMonticulo = [0]\n        self.tamanoActual = 0\n\n    def construirMonticulo(self,unaLista):\n        i = len(unaLista) // 2\n        self.tamanoActual = len(unaLista)\n        self.listaMonticulo = [0] + unaLista[:]\n        print(len(self.listaMonticulo), i)\n        while (i > 0):\n            print(self.listaMonticulo, i)\n            self.infiltAbajo(i)\n            i = i - 1\n        print(self.listaMonticulo,i)\n                        \n    def infiltAbajo(self,i):\n        while (i * 2) <= self.tamanoActual:\n            hm = self.hijoMin(i)\n            if self.listaMonticulo[i] > self.listaMonticulo[hm]:\n                tmp = self.listaMonticulo[i]\n                self.listaMonticulo[i] = self.listaMonticulo[hm]\n                self.listaMonticulo[hm] = tmp\n            i = hm\n                \n    def hijoMin(self,i):\n        if i * 2 + 1 > self.tamanoActual:\n            return i * 2\n        else:\n            if self.listaMonticulo[i * 2] < self.listaMonticulo[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def infiltArriba(self,i):\n        while i // 2 > 0:\n            if self.listaMonticulo[i] < self.listaMonticulo[i//2]:\n               tmp = self.listaMonticulo[i // 2]\n               self.listaMonticulo[i // 2] = self.listaMonticulo[i]\n               self.listaMonticulo[i] = tmp\n            i = i // 2\n \n    def insertar(self,k):\n        self.listaMonticulo.append(k)\n        self.tamanoActual = self.tamanoActual + 1\n        self.infiltArriba(self.tamanoActual)\n\n    def eliminarMin(self):\n        valorSacado = self.listaMonticulo[1]\n        self.listaMonticulo[1] = self.listaMonticulo[self.tamanoActual]\n        self.tamanoActual = self.tamanoActual - 1\n        self.listaMonticulo.pop()\n        self.infiltAbajo(1)\n        return valorSacado\n        \n    def estaVacio(self):\n        if tamanoActual == 0:\n            return True\n        else:\n            return False\n","src/lib/pythoned/basicas/__init__.py":"\n#__all__ = [\"pila\"]\n\n\nfrom .pila import Pila\nfrom .cola import Cola\nfrom .coladoble import ColaDoble\n\n\n","src/lib/pythoned/basicas/cola.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#cola.py\n\nclass Cola:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def agregar(self, item):\n        self.items.insert(0,item)\n\n    def avanzar(self):\n        return self.items.pop()\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/basicas/coladoble.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#coladoble.py\n\nclass ColaDoble:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def agregarFrente(self, item):\n        self.items.append(item)\n\n    def agregarFinal(self, item):\n        self.items.insert(0,item)\n\n    def removerFrente(self):\n        return self.items.pop()\n\n    def removerFinal(self):\n        return self.items.pop(0)\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/basicas/pila.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#pila.py\n\nclass Pila:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def incluir(self, item):\n        self.items.append(item)\n\n    def extraer(self):\n        return self.items.pop()\n\n    def inspeccionar(self):\n        return self.items[len(self.items)-1]\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/grafos/__init__.py":"\n\nfrom .grafoAdy import Grafo\nfrom .grafoAdy import Vertice\nfrom .colaPrioridad import ColaPrioridad\n","src/lib/pythoned/grafos/colaPrioridad.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#colaPrioridad.py\n\nclass ColaPrioridad:\n    def __init__(self):\n        self.arregloMonticulo = [(0,0)]\n        self.tamanoActual = 0\n\n    def construirMonticulo(self,unaLista):\n        self.tamanoActual = len(unaLista)\n        self.arregloMonticulo = [(0,0)]\n        for i in unaLista:\n            self.arregloMonticulo.append(i)\n        i = len(unaLista) // 2            \n        while (i > 0):\n            self.infiltAbajo(i)\n            i = i - 1\n                        \n    def infiltAbajo(self,i):\n        while (i * 2) <= self.tamanoActual:\n            hm = self.hijoMin(i)\n            if self.arregloMonticulo[i][0] > self.arregloMonticulo[hm][0]:\n                tmp = self.arregloMonticulo[i]\n                self.arregloMonticulo[i] = self.arregloMonticulo[hm]\n                self.arregloMonticulo[hm] = tmp\n            i = hm\n                \n    def hijoMin(self,i):\n        if i*2 > self.tamanoActual:\n            return -1\n        else:\n            if i*2 + 1 > self.tamanoActual:\n                return i*2\n            else:\n                if self.arregloMonticulo[i*2][0] < self.arregloMonticulo[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def infiltArriba(self,i):\n        while i // 2 > 0:\n            if self.arregloMonticulo[i][0] < self.arregloMonticulo[i//2][0]:\n               tmp = self.arregloMonticulo[i//2]\n               self.arregloMonticulo[i//2] = self.arregloMonticulo[i]\n               self.arregloMonticulo[i] = tmp\n            i = i//2\n \n    def insertar(self,k):\n        self.arregloMonticulo.append(k)\n        self.tamanoActual = self.tamanoActual + 1\n        self.infiltArriba(self.tamanoActual)\n\n    def eliminarMin(self):\n        valorSacado = self.arregloMonticulo[1][1]\n        self.arregloMonticulo[1] = self.arregloMonticulo[self.tamanoActual]\n        self.tamanoActual = self.tamanoActual - 1\n        self.arregloMonticulo.pop()\n        self.infiltAbajo(1)\n        return valorSacado\n        \n    def estaVacia(self):\n        if self.tamanoActual == 0:\n            return True\n        else:\n            return False\n\n    def decrementarClave(self,valor,nuevo):\n        hecho = False\n        i = 1\n        miClave = 0\n        while not hecho and i <= self.tamanoActual:\n            if self.arregloMonticulo[i][1] == valor:\n                hecho = True\n                miClave = i\n            else:\n                i = i + 1\n        if miClave > 0:\n            self.arregloMonticulo[miClave] = (nuevo,self.arregloMonticulo[miClave][1])\n            self.infiltArriba(miClave)\n            \n    def __contains__(self,vertice):\n        for pareja in self.arregloMonticulo:\n            if pareja[1] == vertice:\n                return True\n        return False     \n\n","src/lib/pythoned/grafos/grafoAdy.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#grafoAdy.py\n\n\nimport sys\n\nclass Grafo:\n    def __init__(self):\n        self.listaVertices = {}\n        self.numVertices = 0\n        \n    def agregarVertice(self,clave):\n        self.numVertices = self.numVertices + 1\n        nuevoVertice = Vertice(clave)\n        self.listaVertices[clave] = nuevoVertice\n        return nuevoVertice\n    \n    def obtenerVertice(self,n):\n        if n in self.listaVertices:\n            return self.listaVertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.listaVertices\n    \n    def agregarArista(self,de,a,costo=0):\n            if de not in self.listaVertices:\n                nv = self.agregarVertice(de)\n            if a not in self.listaVertices:\n                nv = self.agregarVertice(a)\n            self.listaVertices[de].agregarVecino(self.listaVertices[a],costo)\n    \n    def obtenerVertices(self):\n        return list(self.listaVertices.keys())\n        \n    def __iter__(self):\n        return iter(self.listaVertices.values())\n                \nclass Vertice:\n    def __init__(self,clave):\n        self.id = clave\n        self.conectadoA = {}\n        self.color = 'blanco'\n        self.dist = sys.maxsize\n        self.predecesor = None\n        self.desc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def  agregarVecino(self,vecino,ponderacion=0):\n        self.conectadoA[vecino] = ponderacion\n        \n    def asignarColor(self,color):\n        self.color = color\n        \n    def asignarDistancia(self,d):\n        self.dist = d\n\n    def asignarPredecesor(self,p):\n        self.predecesor = p\n\n    def asignarDescubrimiento(self,tiempoDescubrimiento):\n        self.desc = tiempoDescubrimiento\n        \n    def asignarFinalizacion(self,tiempoFinalizacion):\n        self.fin = tiempoFinalizacion\n        \n    def obtenerFinalizacion(self):\n        return self.fin\n        \n    def obtenerDescubrimiento(self):\n        return self.desc\n        \n    def obtenerPredecesor(self):\n        return self.predecesor\n        \n    def obtenerDistancia(self):\n        return self.dist\n        \n    def obtenerColor(self):\n        return self.color\n    \n    def obtenerConexiones(self):\n        return self.conectadoA.keys()\n        \n    def obtenerPonderacion(self,vecino):\n        return self.conectadoA[vecino]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":desc \" + str(self.desc) + \":fin \" + str(self.fin) + \":distancia \" + str(self.dist) + \":predecesor \\n\\t[\" + str(self.predecesor)+ \"]\\n\"\n    \n    def obtenerId(self):\n        return self.id\n","src/lib/quopri.py":"import _sk_fail; _sk_fail._(\"quopri\")\n","src/lib/repr.py":"import _sk_fail; _sk_fail._(\"repr\")\n","src/lib/requests.py":"# most restricted version\n\"\"\"\nThis solution works in runestone - however it is much more limited.\nAn error does not occur in the same way in the textbook as it does\nfor the command line. Since HTTPError is not currently available in\nRunestone, I had to change the exception.\nDecode and Encode are not available in Runestone, so there might be\nissues with reponses.\nDoes not use the status attribute for urlopen, would be nice to have\nthat back.\nDoes not work on regular web pages (like google or the michigan daily) because of cross-site scripting limits.\n\"\"\"\nfrom urllib.request import urlopen\nimport json\n\nclass Response:\n    def __init__(self, data, url):\n        self.text = data\n        self.url = url\n\n    def json(self):\n        try:\n            return json.loads(self.text)\n        except:\n            return {\"error\": \"Response not interpretable as json. Try printing the .text attribute\"}\n\n    def __str__(self):\n        return \"<A Response object for the following request: {}>\".format(self.url)\n\n\nurl_subs = {\" \": \"+\",\n            \"!\": \"%21\",\n            '\"': \"%22\",\n            \"#\": \"%23\",\n            \"$\": \"%24\",\n            \"'\": \"%27\",\n            \"(\": \"%28\",\n            \")\": \"%29\",\n            \"*\": \"%2A\",\n            \"+\": \"%2B\",\n            \",\": \"%2C\",\n            \"/\": \"%2F\",\n            \":\": \"%3A\",\n            \";\": \"%3B\",\n            \"=\": \"%3D\",\n            \"?\": \"%3F\",\n            \"@\": \"%40\",\n            \"[\": \"%5B\",\n            \"]\": \"%5D\",\n            }\n\ndef _subst(s, substitutions=url_subs):\n    res = \"\"\n    for c in str(s):\n        if c in substitutions:\n            res += substitutions[c]\n        else:\n            res += c\n    return res\n\n\ndef requestURL(baseurl, params={}):\n    try:\n        if len(params) == 0:\n            return baseurl\n        complete_url = baseurl + \"?\"\n        pairs = [\"{}={}\".format(_subst(k), _subst(params[k])) for k in params]\n        complete_url += \"&\".join(pairs)\n        return complete_url\n    except:\n        return None\n\ndef get(baseurl, params={}):\n    full_url = requestURL(baseurl, params)\n    if not full_url:\n        text_data = \"<html><body><h1>invalid request</h1></body></html>\"\n        full_url = \"Couldn’t generate a valid URL\"\n    else:\n        data = urlopen(full_url)\n        text_data = data.read().strip()\n        if len(text_data) == 0:\n            text_data = \"Failed to retrieve that URL\"\n    return Response(text_data, full_url)","src/lib/requests_with_caching.py":"import requests\nimport json\n\nPERMANENT_CACHE_FNAME = \"permanent_cache.txt\"\nTEMP_CACHE_FNAME = \"this_page_cache.txt\"\n\ndef _write_to_file(cache, fname):\n    with open(fname, 'w') as outfile:\n        outfile.write(json.dumps(cache, indent=2))\n\ndef _read_from_file(fname):\n    try:\n        with open(fname, 'r') as infile:\n            res = infile.read()\n            return json.loads(res)\n    except:\n        return {}\n\ndef add_to_cache(cache_file, cache_key, cache_value):\n    temp_cache = _read_from_file(cache_file)\n    temp_cache[cache_key] = cache_value\n    _write_to_file(temp_cache, cache_file)\n\ndef clear_cache(cache_file=TEMP_CACHE_FNAME):\n    _write_to_file({}, cache_file)\n\ndef make_cache_key(baseurl, params_d, private_keys=[\"api_key\", \"apikey\"]):\n    \"\"\"Makes a long string representing the query.\n    Alphabetize the keys from the params dictionary so we get the same order each time.\n    Omit keys with private info.\"\"\"\n    alphabetized_keys = sorted(params_d.keys())\n    res = []\n    for k in alphabetized_keys:\n        if k not in private_keys:\n            res.append(\"{}-{}\".format(k, params_d[k]))\n    return baseurl + \"_\".join(res)\n\ndef get(baseurl, params={}, private_keys_to_ignore=[\"api_key\", \"apikey\"], permanent_cache_file=PERMANENT_CACHE_FNAME, temp_cache_file=TEMP_CACHE_FNAME):\n    full_url = requests.requestURL(baseurl, params)\n    cache_key = make_cache_key(baseurl, params, private_keys_to_ignore)\n    # Load the permanent and page-specific caches from files\n    permanent_cache = _read_from_file(permanent_cache_file)\n    temp_cache = _read_from_file(temp_cache_file)\n    if cache_key in temp_cache:\n        print(\"found in page-specific cache\")\n        # make a Response object containing text from the change, and the full_url that would have been fetched\n        return requests.Response(temp_cache[cache_key], full_url)\n    elif cache_key in permanent_cache:\n        print(\"found in permanent_cache\")\n        # make a Response object containing text from the change, and the full_url that would have been fetched\n        return requests.Response(permanent_cache[cache_key], full_url)\n    else:\n        print(\"new; adding to cache\")\n        # actually request it\n        resp = requests.get(baseurl, params)\n        # save it\n        add_to_cache(temp_cache_file, cache_key, resp.text)\n        return resp","src/lib/rexec.py":"import _sk_fail; _sk_fail._(\"rexec\")\n","src/lib/rfc822.py":"import _sk_fail; _sk_fail._(\"rfc822\")\n","src/lib/rlcompleter.py":"import _sk_fail; _sk_fail._(\"rlcompleter\")\n","src/lib/robotparser.py":"import _sk_fail; _sk_fail._(\"robotparser\")\n","src/lib/runpy.py":"import _sk_fail; _sk_fail._(\"runpy\")\n","src/lib/sched.py":"import _sk_fail; _sk_fail._(\"sched\")\n","src/lib/sets.py":"import _sk_fail; _sk_fail._(\"sets\")\n","src/lib/sgmllib.py":"import _sk_fail; _sk_fail._(\"sgmllib\")\n","src/lib/sha.py":"import _sk_fail; _sk_fail._(\"sha\")\n","src/lib/shelve.py":"import _sk_fail; _sk_fail._(\"shelve\")\n","src/lib/shlex.py":"import _sk_fail; _sk_fail._(\"shlex\")\n","src/lib/shutil.py":"import _sk_fail; _sk_fail._(\"shutil\")\n","src/lib/site.py":"import _sk_fail; _sk_fail._(\"site\")\n","src/lib/smtpd.py":"import _sk_fail; _sk_fail._(\"smtpd\")\n","src/lib/smtplib.py":"import _sk_fail; _sk_fail._(\"smtplib\")\n","src/lib/sndhdr.py":"import _sk_fail; _sk_fail._(\"sndhdr\")\n","src/lib/socket.py":"import _sk_fail; _sk_fail._(\"socket\")\n","src/lib/sqlite3/__init__.py":"import _sk_fail; _sk_fail._(\"sqlite3\")\n","src/lib/sre.py":"import _sk_fail; _sk_fail._(\"sre\")\n","src/lib/sre_compile.py":"import _sk_fail; _sk_fail._(\"sre_compile\")\n","src/lib/sre_constants.py":"import _sk_fail; _sk_fail._(\"sre_constants\")\n","src/lib/sre_parse.py":"import _sk_fail; _sk_fail._(\"sre_parse\")\n","src/lib/ssl.py":"import _sk_fail; _sk_fail._(\"ssl\")\n","src/lib/stat.py":"import _sk_fail; _sk_fail._(\"stat\")\n","src/lib/statistics.py":"\"\"\"\nBasic statistics module.\n\nThis module provides functions for calculating statistics of data, including\naverages, variance, and standard deviation.\n\nCalculating averages\n--------------------\n\n==================  =============================================\nFunction            Description\n==================  =============================================\nmean                Arithmetic mean (average) of data.\nharmonic_mean       Harmonic mean of data.\nmedian              Median (middle value) of data.\nmedian_low          Low median of data.\nmedian_high         High median of data.\nmedian_grouped      Median, or 50th percentile, of grouped data.\nmode                Mode (most common value) of data.\n==================  =============================================\n\nCalculate the arithmetic mean (\"the average\") of data:\n\n>>> mean([-1.0, 2.5, 3.25, 5.75])\n2.625\n\n\nCalculate the standard median of discrete data:\n\n>>> median([2, 3, 4, 5])\n3.5\n\n\nCalculate the median, or 50th percentile, of data grouped into class intervals\ncentred on the data values provided. E.g. if your data points are rounded to\nthe nearest whole number:\n\n>>> median_grouped([2, 2, 3, 3, 3, 4])  #doctest: +ELLIPSIS\n2.8333333333...\n\nThis should be interpreted in this way: you have two data points in the class\ninterval 1.5-2.5, three data points in the class interval 2.5-3.5, and one in\nthe class interval 3.5-4.5. The median of these data points is 2.8333...\n\n\nCalculating variability or spread\n---------------------------------\n\n==================  =============================================\nFunction            Description\n==================  =============================================\npvariance           Population variance of data.\nvariance            Sample variance of data.\npstdev              Population standard deviation of data.\nstdev               Sample standard deviation of data.\n==================  =============================================\n\nCalculate the standard deviation of sample data:\n\n>>> stdev([2.5, 3.25, 5.5, 11.25, 11.75])  #doctest: +ELLIPSIS\n4.38961843444...\n\nIf you have previously calculated the mean, you can pass it as the optional\nsecond argument to the four \"spread\" functions to avoid recalculating it:\n\n>>> data = [1, 2, 2, 4, 4, 4, 5, 6]\n>>> mu = mean(data)\n>>> pvariance(data, mu)\n2.5\n\n\nExceptions\n----------\n\nA single exception is defined: StatisticsError is a subclass of ValueError.\n\n\"\"\"\n\n__all__ = [ 'StatisticsError',\n            'pstdev', 'pvariance', 'stdev', 'variance',\n            'median',  'median_low', 'median_high', 'median_grouped',\n            'mean', 'mode', 'harmonic_mean',\n          ]\n\nfrom collections import Counter\nfrom math import sqrt\n\ndef mean(data):\n    return sum(data) / len(data)\n\ndef harmonic_mean(data):\n    raise NotImplementedError\n\n\ndef median(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = (_data[l//2] + _data[l//2-1]) / 2\n    else:\n        _median = _data[l//2]\n    return _median\n\ndef median_low(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = _data[l//2-1]\n    else:\n        _median = _data[l//2]\n    return _median\n\n\ndef median_high(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = _data[l//2]\n    else:\n        _median = _data[l//2]\n    return _median\n\n\ndef median_grouped(data):\n    return median(data)\n\ndef mode(data):\n    counter = Counter(data)\n    max_count = max(counter.values())\n    _mode = [k for k,v in counter.items() if v == max_count]\n    if len(_mode) > 1:\n        raise ValueError(\"No Unique Mode, found {} equally common values\".format(len(_mode)))\n    else:\n        return _mode[0]\n\n\ndef variance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/len(data)\n    return final_variance\n\ndef pvariance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/len(data)\n    return final_variance\n\ndef variance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/(len(data) -1)\n    return final_variance\n\ndef pstdev(data):\n    return sqrt(pvariance(data))\n\ndef stdev(data):\n    return sqrt(variance(data))\n\n","src/lib/statvfs.py":"import _sk_fail; _sk_fail._(\"statvfs\")\n","src/lib/stringold.py":"import _sk_fail; _sk_fail._(\"stringold\")\n","src/lib/stringprep.py":"import _sk_fail; _sk_fail._(\"stringprep\")\n","src/lib/struct.py":"import _sk_fail; _sk_fail._(\"struct\")\n","src/lib/subprocess.py":"import _sk_fail; _sk_fail._(\"subprocess\")\n","src/lib/sunau.py":"import _sk_fail; _sk_fail._(\"sunau\")\n","src/lib/sunaudio.py":"import _sk_fail; _sk_fail._(\"sunaudio\")\n","src/lib/symbol.py":"import _sk_fail; _sk_fail._(\"symbol\")\n","src/lib/symtable.py":"import _sk_fail; _sk_fail._(\"symtable\")\n","src/lib/tabnanny.py":"import _sk_fail; _sk_fail._(\"tabnanny\")\n","src/lib/tarfile.py":"import _sk_fail; _sk_fail._(\"tarfile\")\n","src/lib/telnetlib.py":"import _sk_fail; _sk_fail._(\"telnetlib\")\n","src/lib/tempfile.py":"import _sk_fail; _sk_fail._(\"tempfile\")\n","src/lib/test/__init__.py":"__author__ = 'bmiller'\n\ndef testEqual(actual, expected, places=5):\n    if isinstance(expected,int):\n        if actual == expected:\n            print('Pass')\n            return True\n    elif isinstance(expected,float):\n        if abs(actual-expected) < 10**(-places):\n            print('Pass')\n            return True\n    else:\n        if actual == expected:\n            print('Pass')\n            return True\n    print('Test Failed: expected ' + str(expected) + ' but got ' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n","src/lib/test/ann_module.py":"\n\n\"\"\"\nThe module for testing variable annotations.\nEmpty lines above are for good reason (testing for correct line numbers)\n\"\"\"\n\n# from typing import Optional\n# from functools import wraps\n\n__annotations__[1] = 2\n\nclass C:\n\n    x = 5; #y: Optional['C'] = None\n\n# from typing import Tuple\nx: int = 5; y: str = x;# f: Tuple[int, int]\n\nclass M(type):\n\n    __annotations__['123'] = 123\n    o: type = object\n\n(pars): bool = True\n\nclass D(C):\n    j: str = 'hi'; k: str= 'bye'\n\n# from types import new_class\n# h_class = new_class('H', (C,))\n# j_class = new_class('J')\n\nclass F():\n    z: int = 5\n    def __init__(self, x):\n        pass\n\nclass Y(F):\n    def __init__(self):\n        super(F, self).__init__(123)\n\nclass Meta(type):\n    def __new__(meta, name, bases, namespace):\n        return super().__new__(meta, name, bases, namespace)\n\nclass S(metaclass = Meta):\n    x: str = 'something'\n    y: str = 'something else'\n\n# def foo(x: int = 10):\n#     def bar(y: List[str]):\n#         x: str = 'yes'\n#     bar()\n\n# def dec(func):\n#     @wraps(func)\n#     def wrapper(*args, **kwargs):\n#         return func(*args, **kwargs)\n#     return wrapper\n","src/lib/test/ann_module2.py":"\"\"\"\nSome correct syntax for variable annotation here.\nMore examples are in test_grammar and test_parser.\n\"\"\"\n\n# from typing import no_type_check, ClassVar\n\ni: int = 1\nj: int\nx: float = i/10\n\ndef f():\n    # class C: ...\n    class C: pass\n    return C()\n\nf().new_attr: object = object()\n\nclass C:\n    def __init__(self, x: int) -> None:\n        self.x = x\n\nc = C(5)\nc.new_attr: int = 10\n\n__annotations__ = {}\n\n\n# @no_type_check\n# class NTC:\n#     def meth(self, param: complex) -> None:\n#         ...\n\n# class CV:\n#     var: ClassVar['CV']\n\n# CV.var = CV()\n","src/lib/test/ann_module3.py":"\"\"\"\nCorrect syntax for variable annotation that should fail at runtime\nin a certain manner. More examples are in test_grammar and test_parser.\n\"\"\"\n\ndef f_bad_ann():\n    __annotations__[1] = 2\n\nclass C_OK:\n    def __init__(self, x: int) -> None:\n        self.x: no_such_name = x  # This one is OK as proposed by Guido\n\nclass D_bad_ann:\n    def __init__(self, x: int) -> None:\n        sfel.y: int = 0\n\ndef g_bad_ann():\n    no_such_name.attr: int = 0\n","src/lib/test/bad_getattr.py":"x = 1\n\n__getattr__ = \"Surprise!\"\n__dir__ = \"Surprise again!\"\n","src/lib/test/bad_getattr2.py":"def __getattr__():\n    \"Bad one\"\n\nx = 1\n\ndef __dir__(bad_sig):\n    return []\n","src/lib/test/bad_getattr3.py":"def __getattr__(name):\n    global __getattr__\n    if name != 'delgetattr':\n        raise AttributeError\n    del __getattr__\n    raise AttributeError\n","src/lib/test/decimaltestdata/__init__.py":"import _sk_fail; _sk_fail._(\"decimaltestdata\")\n","src/lib/test/good_getattr.py":"x = 1\n\ndef __dir__():\n    return ['a', 'b', 'c']\n\ndef __getattr__(name):\n    if name == \"yolo\":\n        raise AttributeError(\"Deprecated, use whatever instead\")\n    return f\"There is {name}\"\n\ny = 2\n","src/lib/test/test_support.py":"\"\"\"Supporting definitions for the Python regression tests.\"\"\"\n\nif __name__ != 'test.test_support':\n    raise ImportError('test_support must be imported from the test package')\n\nimport unittest\n\n\n# def run_unittest(*classes):\n#     \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n#     valid_types = (unittest.TestSuite, unittest.TestCase)\n#     suite = unittest.TestSuite()\n#     for cls in classes:\n#         if isinstance(cls, str):\n#             if cls in sys.modules:\n#                 suite.addTest(unittest.findTestCases(sys.modules[cls]))\n#             else:\n#                 raise ValueError(\"str arguments must be keys in sys.modules\")\n#         elif isinstance(cls, valid_types):\n#             suite.addTest(cls)\n#         else:\n#             suite.addTest(unittest.makeSuite(cls))\n#     _run_suite(suite)\n\ndef run_unittest(*classes):\n    \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n    for cls in classes:\n        print cls\n        if issubclass(cls, unittest.TestCase):\n            cls().main()\n        else:\n            print \"Don't know what to do with \", cls\n","src/lib/textwrap.py":"\"\"\"Text wrapping and filling.\n\"\"\"\n\n# Copyright (C) 1999-2001 Gregory P. Ward.\n# Copyright (C) 2002, 2003 Python Software Foundation.\n# Written by Greg Ward <gward@python.net>\n\nimport re, string\n\n__all__ = ['TextWrapper', 'wrap', 'fill', 'dedent', 'indent', 'shorten']\n\n# Hardcode the recognized whitespace characters to the US-ASCII\n# whitespace characters.  The main reason for doing this is that\n# some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n_whitespace = '\\t\\n\\x0b\\x0c\\r '\n\nclass TextWrapper:\n    \"\"\"\n    Object for wrapping/filling text.  The public interface consists of\n    the wrap() and fill() methods; the other methods are just there for\n    subclasses to override in order to tweak the default behaviour.\n    If you want to completely replace the main wrapping algorithm,\n    you'll probably have to override _wrap_chunks().\n    Several instance attributes control various aspects of wrapping:\n      width (default: 70)\n        the maximum width of wrapped lines (unless break_long_words\n        is false)\n      initial_indent (default: \"\")\n        string that will be prepended to the first line of wrapped\n        output.  Counts towards the line's width.\n      subsequent_indent (default: \"\")\n        string that will be prepended to all lines save the first\n        of wrapped output; also counts towards each line's width.\n      expand_tabs (default: true)\n        Expand tabs in input text to spaces before further processing.\n        Each tab will become 0 .. 'tabsize' spaces, depending on its position\n        in its line.  If false, each tab is treated as a single character.\n      tabsize (default: 8)\n        Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n        'expand_tabs' is false.\n      replace_whitespace (default: true)\n        Replace all whitespace characters in the input text by spaces\n        after tab expansion.  Note that if expand_tabs is false and\n        replace_whitespace is true, every tab will be converted to a\n        single space!\n      fix_sentence_endings (default: false)\n        Ensure that sentence-ending punctuation is always followed\n        by two spaces.  Off by default because the algorithm is\n        (unavoidably) imperfect.\n      break_long_words (default: true)\n        Break words longer than 'width'.  If false, those words will not\n        be broken, and some lines might be longer than 'width'.\n      break_on_hyphens (default: true)\n        Allow breaking hyphenated words. If true, wrapping will occur\n        preferably on whitespaces and right after hyphens part of\n        compound words.\n      drop_whitespace (default: true)\n        Drop leading and trailing whitespace from lines.\n      max_lines (default: None)\n        Truncate wrapped lines.\n      placeholder (default: ' [...]')\n        Append to the last line of truncated text.\n    \"\"\"\n\n    unicode_whitespace_trans = {}\n    # uspace = ord(' ')\n    uspace = ' '\n    for x in _whitespace:\n        # unicode_whitespace_trans[ord(x)] = uspace\n        unicode_whitespace_trans[x] = uspace\n\n    # This funky little regex is just the trick for splitting\n    # text up into word-wrappable chunks.  E.g.\n    #   \"Hello there -- you goof-ball, use the -b option!\"\n    # splits into\n    #   Hello/ /there/ /--/ /you/ /goof-/ball,/ /use/ /the/ /-b/ /option!\n    # (after stripping out empty strings).\n    wordsep_re = re.compile(\n        r'(\\s+|'                                  # any whitespace\n        r'[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W]))')  # hyphenated words\n    em_dash = re.compile(r'(\\s+|'                                  # any whitespace\n                         r'[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W])|'   # hyphenated words\n                         r'(?!^)-{2,}(?=\\w))')                     # em-dash\n\n                         \n    # This less funky little regex just split on recognized spaces. E.g.\n    #   \"Hello there -- you goof-ball, use the -b option!\"\n    # splits into\n    #   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\n    wordsep_simple_re = re.compile(r'(\\s+)')\n\n\n    # XXX this is not locale- or charset-aware -- string.lowercase\n    # is US-ASCII only (and therefore English-only)\n    sentence_end_re = re.compile(r'[a-z]'             # lowercase letter\n                                 r'[\\.\\!\\?]'          # sentence-ending punct.\n                                 r'[\\\"\\']?'           # optional end-of-quote\n                                 r'\\Z')               # end of chunk\n    sentence_end_re = r'[a-z][\\.\\!\\?][\\\"\\']?'\n\n    def __init__(self,\n                 width=70,\n                 initial_indent=\"\",\n                 subsequent_indent=\"\",\n                 expand_tabs=True,\n                 replace_whitespace=True,\n                 fix_sentence_endings=False,\n                 break_long_words=True,\n                 drop_whitespace=True,\n                 break_on_hyphens=True,\n                 tabsize=8,\n                 max_lines=None,\n                 placeholder=' [...]'):\n        self.width = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs = expand_tabs\n        self.replace_whitespace = replace_whitespace\n        self.fix_sentence_endings = fix_sentence_endings\n        self.break_long_words = break_long_words\n        self.drop_whitespace = drop_whitespace\n        self.break_on_hyphens = break_on_hyphens\n        self.tabsize = tabsize\n        self.max_lines = max_lines\n        self.placeholder = placeholder\n\n\n    # -- Private methods -----------------------------------------------\n    # (possibly useful for subclasses to override)\n\n    def _munge_whitespace(self, text):\n        \"\"\"_munge_whitespace(text : string) -> string\n        Munge whitespace in text: expand tabs and convert all other\n        whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n        becomes \" foo    bar  baz\".\n        \"\"\"\n        if self.expand_tabs:\n            text = text.expandtabs(self.tabsize)\n        if self.replace_whitespace:\n            for key, val in self.unicode_whitespace_trans.items():\n                text = text.replace(key, val)\n        return text\n\n\n    def _split(self, text):\n        \"\"\"_split(text : string) -> [string]\n        Split the text to wrap into indivisible chunks.  Chunks are\n        not quite the same as words; see _wrap_chunks() for full\n        details.  As an example, the text\n          Look, goof-ball -- use the -b option!\n        breaks into the following chunks:\n          'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n        if break_on_hyphens is True, or in:\n          'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', option!'\n        otherwise.\n        \"\"\"\n        if self.break_on_hyphens is True:\n            chunks = self.wordsep_re.split(text)\n            if \"--\" in text:\n                chunks = [item \n                            for sublist in [self.em_dash.split(chunk) for chunk in chunks] \n                                for item in sublist]\n        else:\n            chunks = self.wordsep_simple_re.split(text)\n        chunks = [c for c in chunks if c]\n        return chunks\n\n    def _fix_sentence_endings(self, chunks):\n        \"\"\"_fix_sentence_endings(chunks : [string])\n        Correct for sentence endings buried in 'chunks'.  Eg. when the\n        original text contains \"... foo.\\\\nBar ...\", munge_whitespace()\n        and split() will convert that to [..., \"foo.\", \" \", \"Bar\", ...]\n        which has one too few spaces; this method simply changes the one\n        space to two.\n        \"\"\"\n        i = 0\n        # patsearch = self.sentence_end_re.search\n        while i < len(chunks)-1:\n            if chunks[i+1] == \" \" and re.search(self.sentence_end_re, chunks[i]) and chunks[i][-1] in \".!?\\\"\\'\":\n                chunks[i+1] = \"  \"\n                i += 2\n            else:\n                i += 1\n\n    def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):\n        \"\"\"_handle_long_word(chunks : [string],\n                             cur_line : [string],\n                             cur_len : int, width : int)\n        Handle a chunk of text (most likely a word, not whitespace) that\n        is too long to fit in any line.\n        \"\"\"\n        # Figure out when indent is larger than the specified width, and make\n        # sure at least one character is stripped off on every pass\n        if width < 1:\n            space_left = 1\n        else:\n            space_left = width - cur_len\n\n        # If we're allowed to break long words, then do so: put as much\n        # of the next chunk onto the current line as will fit.\n        if self.break_long_words:\n            cur_line.append(reversed_chunks[-1][:space_left])\n            reversed_chunks[-1] = reversed_chunks[-1][space_left:]\n\n        # Otherwise, we have to preserve the long word intact.  Only add\n        # it to the current line if there's nothing already there --\n        # that minimizes how much we violate the width constraint.\n        elif not cur_line:\n            cur_line.append(reversed_chunks.pop())\n\n        # If we're not allowed to break long words, and there's already\n        # text on the current line, do nothing.  Next time through the\n        # main loop of _wrap_chunks(), we'll wind up here again, but\n        # cur_len will be zero, so the next line will be entirely\n        # devoted to the long word that we can't handle right now.\n\n    def _wrap_chunks(self, chunks):\n        \"\"\"_wrap_chunks(chunks : [string]) -> [string]\n        Wrap a sequence of text chunks and return a list of lines of\n        length 'self.width' or less.  (If 'break_long_words' is false,\n        some lines may be longer than this.)  Chunks correspond roughly\n        to words and the whitespace between them: each chunk is\n        indivisible (modulo 'break_long_words'), but a line break can\n        come between any two chunks.  Chunks should not have internal\n        whitespace; ie. a chunk is either all whitespace or a \"word\".\n        Whitespace chunks will be removed from the beginning and end of\n        lines, but apart from that whitespace is preserved.\n        \"\"\"\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            if len(indent) + len(self.placeholder.lstrip()) > self.width:\n                raise ValueError(\"placeholder too large for max width\")\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            # Maximum width for this line.\n            width = self.width - len(indent)\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if self.drop_whitespace and cur_line and cur_line[-1].strip() == '':\n                cur_len -= len(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                    len(lines) + 1 < self.max_lines or\n                    (not chunks or\n                     self.drop_whitespace and\n                     len(chunks) == 1 and\n                     not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n                    while cur_line:\n                        if (cur_line[-1].strip() and\n                            cur_len + len(self.placeholder) <= width):\n                            cur_line.append(self.placeholder)\n                            lines.append(indent + ''.join(cur_line))\n                            break\n                        cur_len -= len(cur_line[-1])\n                        del cur_line[-1]\n                    else:\n                        if lines:\n                            prev_line = lines[-1].rstrip()\n                            if (len(prev_line) + len(self.placeholder) <=\n                                    self.width):\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def _split_chunks(self, text):\n        text = self._munge_whitespace(text)\n        return self._split(text)\n\n    # -- Public interface ----------------------------------------------\n\n    def wrap(self, text):\n        \"\"\"wrap(text : string) -> [string]\n        Reformat the single paragraph in 'text' so it fits in lines of\n        no more than 'self.width' columns, and return a list of wrapped\n        lines.  Tabs in 'text' are expanded with string.expandtabs(),\n        and all other whitespace characters (including newline) are\n        converted to space.\n        \"\"\"\n        chunks = self._split_chunks(text)\n        if self.fix_sentence_endings:\n            self._fix_sentence_endings(chunks)\n        return self._wrap_chunks(chunks)\n\n    def fill(self, text):\n        \"\"\"fill(text : string) -> string\n        Reformat the single paragraph in 'text' to fit in lines of no\n        more than 'self.width' columns, and return a new string\n        containing the entire wrapped paragraph.\n        \"\"\"\n        return \"\\n\".join(self.wrap(text))\n\n\n# -- Convenience interface ---------------------------------------------\n\ndef wrap(text, width=70, **kwargs):\n    \"\"\"Wrap a single paragraph of text, returning a list of wrapped lines.\n    Reformat the single paragraph in 'text' so it fits in lines of no\n    more than 'width' columns, and return a list of wrapped lines.  By\n    default, tabs in 'text' are expanded with string.expandtabs(), and\n    all other whitespace characters (including newline) are converted to\n    space.  See TextWrapper class for available keyword args to customize\n    wrapping behaviour.\n    \"\"\"\n    w = TextWrapper(width=width, **kwargs)\n    return w.wrap(text)\n\ndef fill(text, width=70, **kwargs):\n    \"\"\"Fill a single paragraph of text, returning a new string.\n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n    \"\"\"\n    w = TextWrapper(width=width, **kwargs)\n    return w.fill(text)\n\ndef shorten(text, width, **kwargs):\n    \"\"\"Collapse and truncate the given text to fit in the given width.\n    The text first has its whitespace collapsed.  If it then fits in\n    the *width*, it is returned as is.  Otherwise, as many words\n    as possible are joined and then the placeholder is appended::\n        >>> textwrap.shorten(\"Hello  world!\", width=12)\n        'Hello world!'\n        >>> textwrap.shorten(\"Hello  world!\", width=11)\n        'Hello [...]'\n    \"\"\"\n    w = TextWrapper(width=width, max_lines=1, **kwargs)\n    return w.fill(' '.join(text.strip().split()))\n\n\n# -- Loosely related functionality -------------------------------------\n\n# _whitespace_only_re = re.compile('^[ \\t]+$', re.MULTILINE)\n# _leading_whitespace_re = re.compile('(^[ \\t]*)(?:[^ \\t\\n])', re.MULTILINE)\n\ndef dedent(text):\n    \"\"\"Remove any common leading whitespace from every line in `text`.\n    This can be used to make triple-quoted strings line up with the left\n    edge of the display, while still presenting them in the source code\n    in indented form.\n    Note that tabs and spaces are both treated as whitespace, but they\n    are not equal: the lines \"  hello\" and \"\\\\thello\" are\n    considered to have no common leading whitespace.\n    Entirely blank lines are normalized to a newline character.\n    \"\"\"\n    # Look for the longest leading string of spaces and tabs common to\n    # all lines.\n    margin = None\n\n    indents = re.findall(r'(^[ \\t]*)(?:[^ \\t\\n])',text, re.MULTILINE)\n    for indent in indents:\n        if margin is None:\n            margin = indent\n\n        # Current line more deeply indented than previous winner:\n        # no change (previous winner is still on top).\n        elif indent.startswith(margin):\n            pass\n\n        # Current line consistent with and no deeper than previous winner:\n        # it's the new winner.\n        elif margin.startswith(indent):\n            margin = indent\n\n        # Find the largest common whitespace between current line and previous\n        # winner.\n        else:\n            for i, (x, y) in enumerate(zip(margin, indent)):\n                if x != y:\n                    margin = margin[:i]\n                    break\n    # sanity check (testing/debugging only)\n    if 0 and margin:\n        for line in text.split(\"\\n\"):\n            assert not line or line.startswith(margin), \\\n                   \"line = %r, margin = %r\" % (line, margin)\n\n    if margin:\n        lines = [line[len(margin):] \n                    if line.strip()\n                        else line.strip() \n                            for line in text.split(\"\\n\")]\n        text = \"\\n\".join(lines)\n    return text\n\n\ndef indent(text, prefix, predicate=None):\n    \"\"\"Adds 'prefix' to the beginning of selected lines in 'text'.\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.\n    \"\"\"\n    if predicate is None:\n        def predicate(line):\n            return line.strip()\n\n    def prefixed_lines():\n        for line in text.splitlines(True):\n            yield (prefix + line if predicate(line) else line)\n    return ''.join(prefixed_lines())\n\n\nif __name__ == \"__main__\":\n    #print dedent(\"\\tfoo\\n\\tbar\")\n    #print dedent(\"  \\thello there\\n  \\t  how are you?\")\n    print(dedent(\"Hello there.\\n  This is indented.\"))","src/lib/this.py":"\nprint(\"\"\"\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\"\"\"\n      )\n","src/lib/threading.py":"import _sk_fail; _sk_fail._(\"threading\")\n","src/lib/timeit.py":"import _sk_fail; _sk_fail._(\"timeit\")\n","src/lib/toaiff.py":"import _sk_fail; _sk_fail._(\"toaiff\")\n","src/lib/trace.py":"import _sk_fail; _sk_fail._(\"trace\")\n","src/lib/traceback.py":"import _sk_fail; _sk_fail._(\"traceback\")\n","src/lib/tty.py":"import _sk_fail; _sk_fail._(\"tty\")\n","src/lib/types.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\n\"\"\"Define names for all type symbols known in the standard interpreter.\nTypes that are part of optional modules (e.g. array) are not listed.\n\"\"\"\nimport sys\n\n# Iterators in Python aren't a matter of type but of protocol.  A large\n# and changing number of builtin types implement *some* flavor of\n# iterator.  Don't check the type!  Use hasattr to check for both\n# \"__iter__\" and \"next\" attributes instead.\nMappingProxyType = type(type.__dict__)\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\n\nNoneType = type(None)\nTypeType = type\nObjectType = object\nIntType = int\ntry:\n    LongType = long\nexcept: pass\nFloatType = float\nBooleanType = bool\ntry:\n    ComplexType = complex\nexcept NameError:\n    pass\nStringType = str\n\n# StringTypes is already outdated.  Instead of writing \"type(x) in\n# types.StringTypes\", you should use \"isinstance(x, basestring)\".  But\n# we keep around for compatibility with Python 2.2.\ntry:\n    UnicodeType = unicode\n    StringTypes = (StringType, UnicodeType)\nexcept NameError:\n    StringTypes = (StringType,)\n\nBufferType = buffer\n\nTupleType = tuple\nListType = list\nDictType = DictionaryType = dict\n\ndef _f(): pass\nFunctionType = type(_f)\nLambdaType = type(lambda: None)         # Same as FunctionType\n#CodeType = type(_f.func_code)\n\ndef _g():\n    yield 1\nGeneratorType = type(_g())\n\nclass _C:\n    def _m(self): pass\nClassType = type(_C)\nUnboundMethodType = type(_C._m)         # Same as MethodType\n_x = _C()\nInstanceType = type(_x)\nMethodType = type(_x._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\n\nModuleType = type(sys)\nFileType = file\ntry:\n    XRangeType = xrange\nexcept NameError:\n    pass\n\n# try:\n#     raise TypeError\n# except TypeError:\n#     tb = sys.exc_info()[2]\n#     TracebackType = type(tb)\n#     FrameType = type(tb.tb_frame)\n#     del tb\n\nSliceType = slice\nEllipsisType = type(Ellipsis)\n\n# DictProxyType = type(TypeType.__dict__)\nNotImplementedType = type(NotImplemented)\n\n# For Jython, the following two types are identical\n# GetSetDescriptorType = type(FunctionType.func_code)\n# MemberDescriptorType = type(FunctionType.func_globals)\n\ndel sys, _f, _g, _C, _x                           # Not for export\n__all__ = list(n for n in globals() if n[:1] != '_')\n\nGenericAlias = type(type[int])","src/lib/unittest/__init__.py":"__author__ = 'bmiller'\n'''\nThis is the start of something that behaves like\nthe unittest module from cpython.\n\n'''\nimport re\n\nclass _AssertRaisesContext(object):\n    \"\"\"A context manager used to implement TestCase.assertRaises* methods.\"\"\"\n    def __init__(self, expected, test_case):\n        self.test_case = test_case\n        self.expected = expected\n        self.exception = None\n\n    def _is_subtype(self, expected, basetype):\n        if isinstance(expected, tuple):\n            return all(self._is_subtype(e, basetype) for e in expected)\n        return isinstance(expected, type) and issubclass(expected, basetype)\n\n    def handle(self, args, kwargs):\n        \"\"\"\n        If args is empty, assertRaises is being used as a\n        context manager, so return self.\n        If args is not empty, call a callable passing positional and keyword\n        arguments.\n        \"\"\"\n        try:\n            if not self._is_subtype(self.expected, BaseException):\n                raise TypeError('assertRaises() arg 1 must be an exception type or tuple of exception types')\n            if not args:\n                return self\n\n            callable_obj = args[0]\n            args = args[1:]\n            with self:\n                callable_obj(*args, **kwargs) \n\n        finally:\n            # bpo-23890: manually break a reference cycle\n            self = None\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        res = True\n        feedback = \"\"\n        self.exception = exc_value\n        try:\n            act_exc = exc_type.__name__\n        except AttributeError:\n            act_exc = str(exc_type)\n        try:\n            exp_exc = self.expected.__name__\n        except AttributeError:\n            exp_exc = str(self.expected)\n\n        if exc_type is None:\n            res = False\n            feedback = \"{} not raised\".format(exp_exc)\n        elif not issubclass(exc_type, self.expected):\n            res = False\n            feedback = \"Expected {} but got {}\".format(exp_exc, act_exc)\n\n        self.test_case.appendResult(res, act_exc, exp_exc, feedback)\n        return True\n\n\nclass TestCase(object):\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.assertPassed = 0\n        self.assertFailed = 0\n        self.verbosity = 1\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == 'test' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n    \n    def cleanName(self,funcName):\n        return funcName.__func__.__name__\n\n    def main(self):\n\n        for func in self.tlist:\n            if self.verbosity > 1:\n                print('Running %s' % self.cleanName(func))\n            try:\n                self.setUp()\n                self.assertPassed = 0\n                self.assertFailed = 0\n                func()\n                self.tearDown()\n                if self.assertFailed == 0:\n                    self.numPassed += 1\n                else:\n                    self.numFailed += 1\n                    print('Tests failed in %s ' % self.cleanName(func))\n            except Exception as e:\n                self.assertFailed += 1\n                self.numFailed += 1\n                print('Test threw exception in %s (%s)' % (self.cleanName(func), e))\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=\"\"):\n        res = actual==expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual ,expected, feedback)\n\n    def assertNotEqual(self, actual, expected, feedback=\"\"):\n        res = actual != expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual, expected, feedback)\n\n    def assertTrue(self,x, feedback=\"\"):\n        res = bool(x) is True\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be True\" % (str(x))\n        self.appendResult(res, x, True, feedback)\n\n    def assertFalse(self,x, feedback=\"\"):\n        res = not bool(x)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be False\" % (str(x))\n        self.appendResult(res, x, False, feedback)\n\n    def assertIs(self,a,b, feedback=\"\"):\n        res = a is b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNot(self,a,b, feedback=\"\"):\n        res = a is not b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNone(self,x, feedback=\"\"):\n        res = x is None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIsNotNone(self,x, feedback=\"\"):\n        res = x is not None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIn(self, a, b, feedback=\"\"):\n        res = a in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIn(self, a, b, feedback=\"\"):\n        res = a not in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsInstance(self,a,b, feedback=\"\"):\n        res = isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be an instance of %s\" % (str(a), str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=\"\"):\n        res = not isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be an instance of %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertRegex(self, text, expected_regex, feedback=\"\"):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, )): #bytes\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            res = False\n            if feedback == \"\":\n                feedback = \"Regex didn't match: %r not found in %r\" % (\n                    repr(expected_regex), text)\n        else:\n            res = True\n        self.appendResult(res, text, expected_regex, feedback)\n\n    def assertNotRegex(self, text, unexpected_regex, feedback=\"\"):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, )): # bytes\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            feedback = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                repr(unexpected_regex),\n                text)\n            # _formatMessage ensures the longMessage option is respected\n        self.appendResult(not bool(match), text, unexpected_regex, feedback)\n\n    def assertAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = abs(a-b) <= delta\n        else:\n            if places is None:\n                places = 7\n            res = round(a-b, places) == 0\n        \n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = not (a == b) and abs(a - b) > delta\n        else:\n            if places is None:\n                places = 7\n\n            res = round(a-b, places) != 0\n\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreater(self,a,b, feedback=\"\"):\n        res = a > b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be greater than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=\"\"):\n        res = a >= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be >= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLess(self, a, b, feedback=\"\"):\n        res = a < b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be less than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLessEqual(self,a,b, feedback=\"\"):\n        res = a <= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be <= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res:\n            msg = 'Pass'\n            self.assertPassed += 1\n        else:\n            msg = 'Fail: ' +  feedback\n            print(msg)\n            self.assertFailed += 1\n\n    def assertRaises(self, expected_exception, *args, **kwargs):\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle(args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n\n    def fail(self, msg=None):\n        if msg is None:\n            msg = 'Fail'\n        else:\n            msg = 'Fail: ' + msg\n        print(msg)\n        self.assertFailed += 1\n\n    def showSummary(self):\n        # don't divde by zero\n        # pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        print(\"Ran %d tests, passed: %d failed: %d\\n\" % (self.numPassed+self.numFailed,\n                                               self.numPassed, self.numFailed))\n\n\n\ndef main(verbosity=1):\n    glob = globals() # globals() still needs work\n    for name in glob:\n        if type(glob[name]) == type and issubclass(glob[name], TestCase):\n            try:\n                tc = glob[name]()\n                tc.verbosity = verbosity\n                tc.main()\n            except:\n                print(\"Uncaught Error in: \", name)\n","src/lib/unittest/gui.py":"import document\nfrom unittest import TestCase\nfrom urllib.request import urlopen\nfrom time import sleep\n\n\nclass TestCaseGui(TestCase):\n    def __init__(self):\n        TestCase.__init__(self)\n        self.closestDiv = document.currentDiv()\n        self.divid = document.currentGradingContainer()\n        self.mydiv = document.getElementById(self.divid)\n        # If there is no div then create a dummy to avoid errors when running\n        # grading \"off screen\"\n        if self.mydiv is None:\n            self.mydiv = document.createElement(\"div\")\n            self.mydiv.id = self.divid + \"_offscreen_unit_results\"\n            self.mydiv.style.display = \"none\"\n            body = document.getElementsByTagName(\"body\")[0]\n            body.appendChild(self.mydiv)\n            self.unit_results_divid = self.divid + \"_offscreen_unit_results\"\n\n        res = document.getElementById(self.divid + \"_unit_results\")\n        if res:\n            self.resdiv = res\n            res.innerHTML = \"\"\n            self.unit_results_divid = self.divid + \"_unit_results\"\n        else:\n            self.resdiv = document.createElement(\"div\")\n            self.resdiv.id = self.divid + \"_unit_results\"\n            self.resdiv.classList.add(\"unittest-results\")\n            self.mydiv.appendChild(self.resdiv)\n            self.unit_results_divid = self.divid + \"_unit_results\"\n\n    def main(self):\n        t = document.createElement(\"table\")\n        self.resTable = t\n        x = self.resdiv.closest(\".timedComponent\")\n        if x:\n            self.is_timed = True\n        else:\n            self.is_timed = False\n        self.resdiv.appendChild(self.resTable)\n        if self.is_timed:\n            self.resdiv.style.display = \"none\"\n\n        headers = [\"Result\", \"Actual Value\", \"Expected Value\", \"Notes\"]\n        row = document.createElement(\"tr\")\n        for item in headers:\n            head = document.createElement(\"th\")\n            head.classList.add(\"ac-feedback\")\n            head.innerHTML = item\n            head.style.textAlign = \"center\"\n            row.appendChild(head)\n        self.resTable.appendChild(row)\n\n        for func in self.tlist:\n            try:\n                self.setUp()\n                func()\n                self.tearDown()\n            except Exception as e:\n                self.appendResult(\"Error\", None, None, str(e).split(\"on line\")[0])\n                self.numFailed += 1\n        self.showSummary()\n\n    def getOutput(self):\n        sleep(0.2)\n        # self.divid will be the gradingWrapper when in grading mode\n        if self.closestDiv != self.divid:\n            output = document.querySelector(\n                \"#{} #{}_stdout\".format(self.divid, self.closestDiv)\n            )\n        else:\n            output = document.getElementById(self.divid + \"_stdout\")\n        return output.innerText\n\n    def getEditorText(self):\n        return document.getCurrentEditorValue()\n\n    def appendResult(self, res, actual, expected, param):\n        trimActual = False\n        if len(str(actual)) > 15:\n            trimActual = True\n            actualType = type(actual)\n        trimExpected = False\n        if len(str(expected)) > 15:\n            trimExpected = True\n            expectedType = type(expected)\n        row = document.createElement(\"tr\")\n        err = False\n        if res == \"Error\":\n            err = True\n            msg = \"Error: %s\" % param\n            errorData = document.createElement(\"td\")\n            errorData.classList.add(\"ac-feedback\")\n            errorData.innerHTML = \"ERROR\"\n            errorData.style.backgroundColor = \"#de8e96\"\n            errorData.style.textAlign = \"center\"\n            row.appendChild(errorData)\n        elif res:\n            passed = document.createElement(\"td\")\n            passed.classList.add(\"ac-feedback\")\n            passed.innerHTML = \"Pass\"\n            passed.style.backgroundColor = \"#83d382\"\n            passed.style.textAlign = \"center\"\n            row.appendChild(passed)\n            self.numPassed += 1\n        else:\n            fail = document.createElement(\"td\")\n            fail.classList.add(\"ac-feedback\")\n            fail.innerHTML = \"Fail\"\n            fail.style.backgroundColor = \"#de8e96\"\n            fail.style.textAlign = \"center\"\n            row.appendChild(fail)\n            self.numFailed += 1\n\n        act = document.createElement(\"td\")\n        act.classList.add(\"ac-feedback\")\n        if trimActual:\n            actHTML = str(actual)[:5] + \"...\" + str(actual)[-5:]\n            if actualType == str:\n                actHTML = repr(actHTML)\n            act.innerHTML = actHTML\n        else:\n            act.innerHTML = repr(actual)\n        act.style.textAlign = \"center\"\n        row.appendChild(act)\n\n        expect = document.createElement(\"td\")\n        expect.classList.add(\"ac-feedback\")\n\n        if trimExpected:\n            expectedHTML = str(expected)[:5] + \"...\" + str(expected)[-5:]\n            if expectedType == str:\n                expectedHTML = repr(expectedHTML)\n            expect.innerHTML = expectedHTML\n        else:\n            expect.innerHTML = repr(expected)\n        expect.style.textAlign = \"center\"\n        row.appendChild(expect)\n        inp = document.createElement(\"td\")\n        inp.classList.add(\"ac-feedback\")\n\n        if err:\n            inp.innerHTML = msg\n        else:\n            inp.innerHTML = param\n        inp.style.textAlign = \"center\"\n        row.appendChild(inp)\n\n        def foo(evt):\n            document.popup(expandmsg)\n\n        if trimActual or trimExpected:\n            expandbutton = document.createElement(\"button\")\n            expandbutton.innerHTML = \"Expand Differences\"\n            expandmsg = \"Actual: \" + str(actual) + \"\\nExpected: \" + str(expected)\n            expandbutton.value = expandmsg\n            expandbutton.type = \"button\"\n            expandbutton.addEventListener(\"click\", foo)\n            expandbutton.classList.add(\"btn\", \"btn-info\")\n            row.appendChild(expandbutton)\n\n        self.resTable.appendChild(row)\n\n    def showSummary(self):\n        pct = float(self.numPassed) / (self.numPassed + self.numFailed) * 100\n        pctcorrect = (\n            \"percent:\"\n            + str(pct)\n            + \":passed:\"\n            + str(self.numPassed)\n            + \":failed:\"\n            + str(self.numFailed)\n        )\n        pTag = document.createElement(\"p\")\n        if not self.is_timed:\n            pTag.innerHTML = \"You passed: \" + str(pct) + \"% of the tests\"\n            self.resdiv.appendChild(pTag)\n        try:\n            jseval(\n                \"window.componentMap['{}'].pct_correct = {}\".format(\n                    self.closestDiv, pct\n                )\n            )\n            jseval(\n                \"window.componentMap['{}'].unit_results = '{}'\".format(\n                    self.closestDiv, pctcorrect\n                )\n            )\n            jseval(\n                \"window.componentMap['{}'].unit_results_divid = '{}'\".format(\n                    self.closestDiv, self.mydiv.getAttribute(\"id\")\n                )\n            )\n\n        except:\n            print(\n                \"failed to find object to record unittest results in {}! {}\".format(\n                    self.closestDiv, pctcorrect\n                )\n            )\n","src/lib/urllib2.py":"import _sk_fail; _sk_fail._(\"urllib2\")\n","src/lib/urlparse.py":"import _sk_fail; _sk_fail._(\"urlparse\")\n","src/lib/user.py":"import _sk_fail; _sk_fail._(\"user\")\n","src/lib/uu.py":"import _sk_fail; _sk_fail._(\"uu\")\n","src/lib/warnings.py":"import _sk_fail; _sk_fail._(\"warnings\")\n","src/lib/wave.py":"import _sk_fail; _sk_fail._(\"wave\")\n","src/lib/weakref.py":"import _sk_fail; _sk_fail._(\"weakref\")\n","src/lib/whichdb.py":"import _sk_fail; _sk_fail._(\"whichdb\")\n","src/lib/wsgiref/__init__.py":"import _sk_fail; _sk_fail._(\"wsgiref\")\n","src/lib/xdrlib.py":"import _sk_fail; _sk_fail._(\"xdrlib\")\n","src/lib/xml/__init__.py":"import _sk_fail; _sk_fail._(\"xml\")\n","src/lib/xml/dom/__init__.py":"import _sk_fail; _sk_fail._(\"dom\")\n","src/lib/xml/etree/__init__.py":"import _sk_fail; _sk_fail._(\"etree\")\n","src/lib/xml/parsers/__init__.py":"import _sk_fail; _sk_fail._(\"parsers\")\n","src/lib/xml/sax/__init__.py":"import _sk_fail; _sk_fail._(\"sax\")\n","src/lib/xmllib.py":"import _sk_fail; _sk_fail._(\"xmllib\")\n","src/lib/xmlrpclib.py":"import _sk_fail; _sk_fail._(\"xmlrpclib\")\n","src/lib/zipfile.py":"import _sk_fail; _sk_fail._(\"zipfile\")\n","src/builtin/sys.js":"var $builtinmodule=function(i){var t,n={},e=[],u=Sk.getSysArgv();for(t=0;t<u.length;++t)e.push(new Sk.builtin.str(u[t]));n.argv=new Sk.builtins.list(e),n.copyright=new Sk.builtin.str(\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\"),Sk.__future__.python3?(n.version=new Sk.builtin.str(\"3.7(ish) [Skulpt]\"),n.version_info=new Sk.builtin.tuple([new Sk.builtin.int_(3),new Sk.builtin.int_(7)])):(n.version=new Sk.builtin.str(\"2.7(ish) [Skulpt]\"),n.version_info=new Sk.builtin.tuple([new Sk.builtin.int_(2),new Sk.builtin.int_(7)])),n.maxint=new Sk.builtin.int_(Math.pow(2,53)-1),n.maxsize=new Sk.builtin.int_(Math.pow(2,53)-1),n.modules=Sk.sysmodules,n.path=Sk.realsyspath,n.getdefaultencoding=new Sk.builtin.func((()=>new Sk.builtin.str(\"utf-8\"))),n.getExecutionLimit=new Sk.builtin.func((function(){return null===Sk.execLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.execLimit)})),n.setExecutionLimit=new Sk.builtin.func((function(i){if(null===Sk.execLimit)throw new Sk.builtin.NotImplementedError(\"Execution limiting is not enabled\");void 0!==i&&(Sk.execLimit=Sk.builtin.asnum$(i))})),n.resetTimeout=new Sk.builtin.func((function(){Sk.execStart=new Date})),n.getYieldLimit=new Sk.builtin.func((function(){return null===Sk.yieldLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.yieldLimit)})),n.setYieldLimit=new Sk.builtin.func((function(i){if(null===Sk.yieldLimit)throw new Sk.builtin.NotImplementedError(\"Yielding is not enabled\");void 0!==i&&(Sk.yieldLimit=Sk.builtin.asnum$(i))})),n.debug=new Sk.builtin.func((function(){return Sk.builtin.none.none$}));const o=Sk.builtin.make_structseq(\"sys\",\"float_info\",{max:\"DBL_MAX -- maximum representable finite float\",max_exp:\"DBL_MAX_EXP -- maximum int e such that radix**(e-1) is representable\",max_10_exp:\"DBL_MAX_10_EXP -- maximum int e such that 10**e is representable\",min:\"DBL_MIN -- Minimum positive normalized float\",min_exp:\"DBL_MIN_EXP -- minimum int e such that radix**(e-1) is a normalized float\",min_10_exp:\"DBL_MIN_10_EXP -- minimum int e such that 10**e is a normalized\",dig:\"DBL_DIG -- digits\",mant_dig:\"DBL_MANT_DIG -- mantissa digits\",epsilon:\"DBL_EPSILON -- Difference between 1 and the next representable float\",radix:\"FLT_RADIX -- radix of exponent\",rounds:\"FLT_ROUNDS -- rounding mode\"});n.float_info=new o([Number.MAX_VALUE,Math.floor(Math.log2(Number.MAX_VALUE)),Math.floor(Math.log10(Number.MAX_VALUE)),Number.MIN_VALUE,Math.ceil(Math.log2(Number.MIN_VALUE)),Math.ceil(Math.log10(Number.MIN_VALUE)),15,Math.log2(Number.MAX_SAFE_INTEGER),Number.EPSILON,2,1].map((i=>Sk.ffi.remapToPy(i))));const s=Sk.builtin.make_structseq(\"sys\",\"int_info\",{bits_per_digit:\"size of a digit in bits\",sizeof_digit:\"size in bytes of the C type used to represent a digit\"});n.int_info=new s([30,4].map((i=>Sk.ffi.remapToPy(i))));const l=Sk.builtin.make_structseq(\"sys\",\"hash_info\",{width:\"width of the type used for hashing, in bits\",modulus:\"prime number giving the modulus on which the hash function is based\",inf:\"value to be used for hash of a positive infinity\",nan:\"value to be used for hash of a nan\",imag:\"multiplier used for the imaginary part of a complex number\",algorithm:\"name of the algorithm for hashing of str, bytes and memoryviews\",hash_bits:\"internal output size of hash algorithm\",seed_bits:\"seed size of hash algorithm\",cutoff:\"small string optimization cutoff\"});return n.hash_info=new l([32,536870911,314159,0,1000003,\"siphash24\",32,128,0].map((i=>Sk.ffi.remapToPy(i)))),n.__stdout__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdout\"),new Sk.builtin.str(\"w\")),n.__stdin__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdin\"),new Sk.builtin.str(\"r\")),n.stdout=n.__stdout__,n.stdin=n.__stdin__,n};","src/lib/JoBase.js":"const $builtinmodule=()=>{Sk.misceval.print_(\"Welcome to JoBase\\n\");const e=Sk.JoBase,o={},t=[],r=[],n=e.getContext(\"webgl\"),a=n.createProgram(),c=n.createBuffer(),i=n.createShader(n.VERTEX_SHADER),s=n.createShader(n.FRAGMENT_SHADER),str=e=>new Sk.builtin.str(e),def=e=>new Sk.builtin.func(e),float=e=>new Sk.builtin.float_(e),int=e=>new Sk.builtin.int_(e),bool=e=>new Sk.builtin.bool(e),tuple=e=>new Sk.builtin.tuple(e),number=e=>{if(Sk.builtin.checkNumber(e))return e.v;throw new Sk.builtin.TypeError(\"must be real number, not \"+e.tp$name)},string=e=>{if(Sk.builtin.checkString(e))return e.v;throw new Sk.builtin.TypeError(\"must be str, not \"+e.tp$name)},property=(...e)=>call(Sk.builtins.property,...e),build=(...e)=>Sk.misceval.buildClass(o,...e),call=(...e)=>Sk.misceval.callsimOrSuspend(...e),is=(...e)=>Sk.builtin.isinstance(...e).v,wait=e=>Sk.misceval.promiseToSuspension(new Promise(e)),object=e=>{throw new Sk.builtin.TypeError(\"must be Shape or cursor, not \"+e.tp$name)},path=e=>str(\"https://jobase.org/Browser/JoBase/\"+e),width=()=>e.width/devicePixelRatio,height=()=>e.height/devicePixelRatio,x=()=>o.cursor.$x-width()/2,y=()=>height()/2-o.cursor.$y,blank=()=>{},mouseEnter=()=>o.cursor.$enter=!0,mouseLeave=()=>o.cursor.$leave=!0,mouseDown=()=>{o.cursor.$press=!0,o.cursor.$hold=!0},mouseUp=()=>{o.cursor.$release=!0,o.cursor.$hold=!1},mouseMove=t=>{const r=e.getBoundingClientRect();o.cursor.$x=t.clientX-r.left,o.cursor.$y=t.clientY-r.top,o.cursor.$move=!0},keyDown=e=>{const t=Object.keys(o.key.$data).find((t=>o.key.$data[t].code==e.code)),r=o.key.$data[t];e.repeat?(o.key.$repeat=!0,r&&(r.repeat=!0)):(o.key.$press=!0,r&&(r.press=!0)&&(r.hold=!0))},keyUp=e=>{const t=Object.keys(o.key.$data).find((t=>o.key.$data[t].code==e.code)),r=o.key.$data[t];o.key.$release=!0,r&&(r.release=!0)&&(r.hold=!1)},collidePolyPoint=(e,o)=>e.reduce(((e,t,r,n)=>{const a=n[r+1==n.length?0:r+1];return o[0]<(a[0]-t[0])*(o[1]-t[1])/(a[1]-t[1])+t[0]&&(t[1]>o[1]&&a[1]<o[1]||t[1]<o[1]&&a[1]>o[1])?!e:e}),!1),getRectPoly=e=>{const o=e.$anchor[0]+e.$size[0]*e.$scale[0]/2,t=e.$anchor[1]+e.$size[1]*e.$scale[1]/2;return((e,o,t)=>{const r=Math.cos(o*Math.PI/180),n=Math.sin(o*Math.PI/180);return e.map((e=>[e[0]*r-e[1]*n+t[0],e[0]*n+e[1]*r+t[1]]))})([[-o,t],[o,t],[o,-t],[-o,-t]],e.$angle,e.$pos)},createImage=e=>{const o=n.createTexture();return n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),o},renderText=e=>{const o=document.createElement(\"canvas\"),t=o.getContext(\"2d\"),a=e.$fontSize+\"px _\"+r.indexOf(e.$font);t.font=a;const c=t.measureText(e.$content),i=c.actualBoundingBoxRight-c.actualBoundingBoxLeft,s=t.measureText(\"Sy\"),d=s.actualBoundingBoxDescent+s.actualBoundingBoxAscent;e.$size[0]=o.width=i,e.$size[1]=o.height=d,t.font=a,t.fillStyle=\"#fff\",t.fillText(e.$content,0,s.actualBoundingBoxAscent),n.deleteTexture(e.$texture),e.$texture=createImage(o)},loadFont=e=>new Promise(((o,t)=>{if(r.includes(e))return o();new FontFace(\"_\"+r.length,`url(${e})`).load().then((t=>{document.fonts.add(t),r.push(e),o()})).catch((()=>{return t((o=`failed to load font: \"${e}\"`,new Sk.builtin.FileNotFoundError(o)));var o}))})),drawShape=(e,o,t,r,c,i)=>{const s=o[0]*e.$scale[0],d=o[1]*e.$scale[1],l=e.$anchor[0],u=e.$anchor[1],$=e.$pos[0],p=e.$pos[1],m=Math.sin(e.$angle*Math.PI/180),f=Math.cos(e.$angle*Math.PI/180);var h,_;h=[s*f,s*m,0,0,d*-m,d*f,0,0,0,0,1,0,l*f+u*-m+$,l*m+u*f+p,0,1],_=e.$color,n.uniform4fv(n.getUniformLocation(a,\"color\"),new Float32Array(_)),n.uniformMatrix4fv(n.getUniformLocation(a,\"object\"),!1,new Float32Array(h)),n.bindBuffer(n.ARRAY_BUFFER,t),n.uniform1i(n.getUniformLocation(a,\"image\"),c),n.drawArrays(r,0,i)},d=def(((e,t)=>{if(is(e,o.Rectangle)){if(is(t,o.Rectangle))return bool((r=getRectPoly(e),n=getRectPoly(t),collidePolyPoint(r,n[0])||collidePolyPoint(n,r[0])||r.find(((e,o,t)=>((e,o,t)=>e.find(((e,r,n)=>((e,o,t,r)=>{const n=(r[1]-t[1])*(o[0]-e[0])-(r[0]-t[0])*(o[1]-e[1]),a=((r[0]-t[0])*(e[1]-t[1])-(r[1]-t[1])*(e[0]-t[0]))/n,c=((o[0]-e[0])*(e[1]-t[1])-(o[1]-e[1])*(e[0]-t[0]))/n;return a>=0&&a<=1&&c>=0&&c<=1})(o,t,e,n[r+1==n.length?0:r+1]))))(n,e,t[o+1==t.length?0:o+1])))));if(t==o.cursor)return bool(collidePolyPoint(getRectPoly(e),[x(),y()]));object(t)}var r,n;if(e==o.cursor){if(is(t,o.Rectangle))return bool(collidePolyPoint(getRectPoly(t),[x(),y()]));if(t==o.cursor)return Sk.builtins.bool.true$;object(t)}object(e)})),l={set:(e,o)=>{if(e.ob$type==l.class)o.forEach(((o,t,r)=>r[t]=t<e.$data.length?e.$get()[t]:o));else{if(!Sk.builtin.checkSequence(e))throw new Sk.builtins.TypeError(\"attribute must be a sequence of values\");o.forEach(((o,t,r)=>r[t]=t<e.v.length?e.v[t].v:o))}return o},new:(e,o,...t)=>{const r=call(l.class);return r.$parent=e,r.$get=o,r.$data=t.map((e=>({name:e[0],set:e[1]}))),r},class:build(((e,o)=>{o.__getattr__=def(((e,o)=>{const t=e.$data.findIndex((e=>e.name==o.v));if(-1!=t)return float(e.$get()[t])})),o.__setattr__=def(((e,o,t)=>{const r=e.$data.find((e=>e.name==o.v));r&&r.set(e.$parent,t)})),o.__str__=def((e=>str(`(${e.$get().join(\", \")})`))),o.__repr__=def((e=>str(`[${e.$get().join(\", \")}]`)))}),\"Vector\")},u={new:(e,o,t,r,n)=>{e.$color=l.set(n,[0,0,0,1]),e.$pos=[number(o),number(t)],e.$angle=number(r),e.$anchor=[0,0],e.$scale=[1,1]},class:build(((e,t)=>{t.collides_with=d,t.look_at=def(((e,t)=>{const set=(o,t)=>{const r=Math.atan2(t-e.$pos[1],o-e.$pos[0]);e.$angle=180*r/Math.PI};t==o.cursor?set(x(),y()):is(t,u.class)?set(...t.$pos):object(t)})),t.move_toward=def(((e,t,r)=>{const n=number(r)??1,set=(o,t)=>{const r=o-e.$pos[0],a=t-e.$pos[1];Math.hypot(r,a)<n?(e.$pos[0]+=r,e.$pos[1]+=a):(e.$pos[0]+=Math.cos(Math.atan2(a,r))*n,e.$pos[1]+=Math.sin(Math.atan2(a,r))*n)};t==o.cursor?set(x(),y()):is(t,u.class)?set(...t.$pos):object(t)}));const x=(e,o)=>e.$pos[0]=number(o),y=(e,o)=>e.$pos[1]=number(o);t.x=property(def((e=>float(e.$pos[0]))),def(x)),t.y=property(def((e=>float(e.$pos[1]))),def(y)),t.pos=t.position=property(def((e=>l.new(e,(()=>e.$pos),[\"x\",x],[\"y\",y]))),def(((e,o)=>l.set(o,e.$pos)))),t.top=property(def((e=>float(e.$top()))),def(((e,o)=>e.$pos[1]+=o-e.$top()))),t.left=property(def((e=>float(e.$left()))),def(((e,o)=>e.$pos[0]+=o-e.$left()))),t.bottom=property(def((e=>float(e.$bottom()))),def(((e,o)=>e.$pos[1]+=o-e.$bottom()))),t.right=property(def((e=>float(e.$right()))),def(((e,o)=>e.$pos[0]+=o-e.$right())));const scaleX=(e,o)=>e.$scale[0]=number(o),scaleY=(e,o)=>e.$scale[1]=number(o);t.scale=property(def((e=>l.new(e,(()=>e.$scale),[\"x\",scaleX],[\"y\",scaleY]))),def(((e,o)=>l.set(o,e.$scale))));const anchorX=(e,o)=>e.$anchor[0]=number(o),anchorY=(e,o)=>e.$anchor[1]=number(o);t.anchor=property(def((e=>l.new(e,(()=>e.$anchor),[\"x\",anchorX],[\"y\",anchorY]))),def(((e,o)=>l.set(o,e.$anchor)))),t.angle=property(def((e=>float(e.$angle))),def(((e,o)=>e.$angle=number(o))));const red=(e,o)=>e.$color[0]=number(o),green=(e,o)=>e.$color[1]=number(o),blue=(e,o)=>e.$color[2]=number(o),alpha=(e,o)=>e.$color[3]=number(o);t.red=property(def((e=>float(e.$color[0]))),def(red)),t.green=property(def((e=>float(e.$color[1]))),def(green)),t.blue=property(def((e=>float(e.$color[2]))),def(blue)),t.blue=property(def((e=>float(e.$color[3]))),def(alpha)),t.color=property(def((e=>l.new(e,(()=>e.$color),[\"red\",red],[\"green\",green],[\"blue\",blue],[\"alpha\",alpha]))),def(((e,o)=>l.set(o,e.$color))))}),\"Shape\")};return o.MAN=path(\"images/man.png\"),o.COIN=path(\"images/coin.png\"),o.ENEMY=path(\"images/enemy.png\"),o.DEFAULT=path(\"fonts/default.ttf\"),o.CODE=path(\"fonts/code.ttf\"),o.PENCIL=path(\"fonts/pencil.ttf\"),o.SERIF=path(\"fonts/serif.ttf\"),o.HANDWRITING=path(\"fonts/handwriting.ttf\"),o.TYPEWRITER=path(\"fonts/typewriter.ttf\"),o.JOINED=path(\"fonts/joined.ttf\"),o.window=call(build(((e,o)=>{const init=(e,o,t,r,a)=>{e.$caption=string(o),e.$color=l.set(a,[1,1,1]),n.clearColor(...e.$color,1)};init.$defaults=[str(\"JoBase\"),null,null,tuple()],init.co_varnames=[\"self\",\"caption\",\"width\",\"height\",\"color\"],o.__init__=def(init),o.close=def((e=>e.$close=!0)),o.maximize=def(blank),o.minimize=def(blank),o.focus=def(blank),o.caption=property(def((e=>str(e.$caption))),def(((e,o)=>e.$caption=string(o))));const red=(e,o)=>{e.$color[0]=number(o),n.clearColor(...e.$color,1)},green=(e,o)=>{e.$color[1]=number(o),n.clearColor(...e.$color,1)},blue=(e,o)=>{e.$color[2]=number(o),n.clearColor(...e.$color,1)};o.red=property(def((e=>float(e.$color[0]))),def(red)),o.green=property(def((e=>float(e.$color[1]))),def(green)),o.blue=property(def((e=>float(e.$color[2]))),def(blue)),o.color=property(def((e=>l.new(e,(()=>e.$color),[\"red\",red],[\"green\",green],[\"blue\",blue]))),def(((e,o)=>n.clearColor(...l.set(o,e.$color),1)))),o.width=property(def((()=>float(width())))),o.height=property(def((()=>float(height())))),o.size=property(def((e=>l.new(e,(()=>[width(),height()]),[\"x\",blank],[\"y\",blank]))),def(((e,o)=>l.set(o,new Array(2))))),o.top=property(def((()=>float(height()/2)))),o.bottom=property(def((()=>float(height()/-2)))),o.left=property(def((()=>float(width()/-2)))),o.right=property(def((()=>float(width()/2)))),o.resize=property(def((e=>bool(e.$resize))))}),\"Window\")),o.cursor=call(build(((e,o)=>{o.x=property(def((()=>float(x())))),o.y=property(def((()=>float(y())))),o.pos=o.position=property(def((e=>l.new(e,(()=>[x(),y()]),[\"x\",blank],[\"y\",blank]))),def(((e,o)=>l.set(o,new Array(2))))),o.move=property(def((e=>bool(e.$move)))),o.enter=property(def((e=>bool(e.$enter)))),o.leave=property(def((e=>bool(e.$leave)))),o.press=property(def((e=>bool(e.$press)))),o.release=property(def((e=>bool(e.$release)))),o.hold=property(def((e=>bool(e.$hold))))}),\"Cursor\")),o.cursor.$x=0,o.cursor.$y=0,o.key=call(build(((e,o)=>{o.__getattr__=def(((e,o)=>{const t=e.$data[o.v];if(t)return t.hold||t.release?(r=[str(\"press\"),bool(t.press),str(\"release\"),bool(t.release),str(\"repeat\"),bool(t.repeat)],new Sk.builtin.dict(r)):Sk.builtin.bool.false$;var r})),o.hold=property(def((e=>{for(const o in e.$data)if(e.$data[o].hold)return Sk.builtin.bool.true$;return Sk.builtin.bool.false$}))),o.press=property(def((e=>bool(e.$press)))),o.release=property(def((e=>bool(e.$release)))),o.repeat=property(def((e=>bool(e.$repeat))))}),\"Key\")),o.key.$data={space:{code:\"Space\"},apostrophe:{code:\"Quote\"},comma:{code:\"Comma\"},minus:{code:\"Minus\"},period:{code:\"Period\"},slash:{code:\"Slash\"},_0:{code:\"Digit0\"},_1:{code:\"Digit1\"},_2:{code:\"Digit2\"},_3:{code:\"Digit3\"},_4:{code:\"Digit4\"},_5:{code:\"Digit5\"},_6:{code:\"Digit6\"},_7:{code:\"Digit7\"},_8:{code:\"Digit8\"},_9:{code:\"Digit9\"},semicolon:{code:\"Semicolon\"},equal:{code:\"Equal\"},a:{code:\"KeyA\"},b:{code:\"KeyB\"},c:{code:\"KeyC\"},d:{code:\"KeyD\"},e:{code:\"KeyE\"},f:{code:\"KeyF\"},g:{code:\"KeyG\"},h:{code:\"KeyH\"},i:{code:\"KeyI\"},j:{code:\"KeyJ\"},k:{code:\"KeyK\"},l:{code:\"KeyL\"},m:{code:\"KeyM\"},n:{code:\"KeyN\"},o:{code:\"KeyO\"},p:{code:\"KeyP\"},q:{code:\"KeyQ\"},r:{code:\"KeyR\"},s:{code:\"KeyS\"},t:{code:\"KeyT\"},u:{code:\"KeyU\"},v:{code:\"KeyV\"},w:{code:\"KeyW\"},x:{code:\"KeyX\"},y:{code:\"KeyY\"},z:{code:\"KeyZ\"},left_bracket:{code:\"BracketLeft\"},backslash:{code:\"Backslash\"},right_bracket:{code:\"BracketRight\"},backquote:{code:\"Backquote\"},escape:{code:\"Escape\"},enter:{code:\"Enter\"},tab:{code:\"Tab\"},backspace:{code:\"Backspace\"},insert:{code:\"Insert\"},delete:{code:\"Delete\"},right:{code:\"ArrowRight\"},left:{code:\"ArrowLeft\"},down:{code:\"ArrowDown\"},up:{code:\"ArrowUp\"},page_up:{code:\"PageUp\"},page_down:{code:\"PageDown\"},home:{code:\"Home\"},end:{code:\"End\"},caps_lock:{code:\"CapsLock\"},scroll_lock:{code:\"ScrollLock\"},num_lock:{code:\"NumLock\"},print_screen:{code:\"PrintScreen\"},pause:{code:\"Pause\"},f1:{code:\"F1\"},f2:{code:\"F2\"},f3:{code:\"F3\"},f4:{code:\"F4\"},f5:{code:\"F5\"},f6:{code:\"F6\"},f7:{code:\"F7\"},f8:{code:\"F8\"},f9:{code:\"F9\"},f10:{code:\"F10\"},f11:{code:\"F11\"},f12:{code:\"F12\"},f13:{code:\"F13\"},f14:{code:\"F14\"},f15:{code:\"F15\"},f16:{code:\"F16\"},f17:{code:\"F17\"},f18:{code:\"F18\"},f19:{code:\"F19\"},f20:{code:\"F20\"},f21:{code:\"F21\"},f22:{code:\"F22\"},f23:{code:\"F23\"},f24:{code:\"F24\"},f25:{code:\"F25\"},pad_0:{code:\"Numpad0\"},pad_1:{code:\"Numpad1\"},pad_2:{code:\"Numpad2\"},pad_3:{code:\"Numpad3\"},pad_4:{code:\"Numpad4\"},pad_5:{code:\"Numpad5\"},pad_6:{code:\"Numpad6\"},pad_7:{code:\"Numpad7\"},pad_8:{code:\"Numpad8\"},pad_9:{code:\"Numpad9\"},decimal:{code:\"NumpadDecimal\"},divide:{code:\"NumpadDivide\"},multiply:{code:\"NumpadMultiply\"},subtract:{code:\"NumpadSubtract\"},add:{code:\"NumpadAdd\"},enter:{code:\"NumpadEnter\"},equal:{code:\"NumpadEqual\"},left_shift:{code:\"ShiftLeft\"},left_ctrl:{code:\"ControlLeft\"},left_alt:{code:\"AltLeft\"},left_super:{code:\"SuperLeft\"},right_shift:{code:\"ShiftRight\"},right_ctrl:{code:\"ControlRight\"},right_alt:{code:\"AltRight\"},right_super:{code:\"SuperRight\"},menu:{code:\"Menu\"}},o.camera=call(build(((e,o)=>{const init=(e,o,t)=>{e.$pos=[number(o),number(t)]};init.$defaults=[int(),int()],init.co_varnames=[\"self\",\"x\",\"y\"],o.__init__=def(init);const x=(e,o)=>e.$pos[0]=number(o),y=(e,o)=>e.$pos[1]=number(o);o.x=property(def((e=>float(e.$pos[0]))),def(x)),o.y=property(def((e=>float(e.$pos[1]))),def(y)),o.pos=o.position=property(def((e=>l.new(e,(()=>e.$pos),[\"x\",x],[\"y\",y]))),def(((e,o)=>l.set(o,e.$pos))))}),\"Camera\")),o.Rectangle=build(((e,o)=>{const init=(e,o,t,r,n,a,c)=>{u.new(e,o,t,a,c),e.$size=[number(r),number(n)],e.$top=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[1]>e?o[1]:e),o[0][1]);var o},e.$left=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[0]<e?o[0]:e),o[0][0]);var o},e.$bottom=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[1]<e?o[1]:e),o[0][1]);var o},e.$right=()=>{return(o=getRectPoly(e)).reduce(((e,o)=>o[0]>e?o[0]:e),o[0][0]);var o}};init.$defaults=[int(),int(),int(50),int(50),int(),tuple()],init.co_varnames=[\"self\",\"x\",\"y\",\"width\",\"height\",\"angle\",\"color\"],o.__init__=def(init),o.draw=def((e=>drawShape(e,e.$size,c,n.TRIANGLE_STRIP,!1,4)));const width=(e,o)=>e.$size[0]=number(o),height=(e,o)=>e.$size[1]=number(o);o.width=property(def((e=>float(e.$size[0]))),def(width)),o.height=property(def((e=>float(e.$size[1]))),def(height)),o.size=property(def((e=>l.new(e,(()=>e.$size),[\"width\",width],[\"height\",height]))),def(((e,o)=>l.set(o,e.$size))))}),\"Rectangle\",[u.class]),o.Image=build(((e,r)=>{const init=(e,r,n,a,c,i,s,d)=>wait(((u,$)=>{call(o.Rectangle.prototype.__init__,e,n,a,i,s,c);const p=t.find((e=>e.name==string(r))),set=o=>{e.$texture=o.source,e.$size[0]||=o.width,e.$size[1]||=o.height};if(e.$color=l.set(d,[1,1,1,1]),p)return set(p),u();const m=new Image;m.crossOrigin=\"anonymous\",m.src=string(r),m.onerror=()=>$(new Sk.builtin.FileNotFoundError(`failed to load image: \"${string(r)}\"`)),m.onload=()=>{const e={name:string(r),width:m.width,height:m.height,source:createImage(m)};t.push(e),set(e),u()}}));init.$defaults=[o.MAN,int(),int(),int(),int(),int(),tuple()],init.co_varnames=[\"self\",\"name\",\"x\",\"y\",\"angle\",\"width\",\"height\",\"color\"],r.__init__=def(init),r.draw=def((e=>{n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,e.$texture),drawShape(e,e.$size,c,n.TRIANGLE_STRIP,!0,4)}))}),\"Image\",[o.Rectangle]),o.Text=build(((e,t)=>{const init=(e,t,r,n,a,c,i,s)=>wait(((d,l)=>{call(o.Rectangle.prototype.__init__,e,r,n,int(),int(),c,i),e.$font=string(s),e.$fontSize=number(a),e.$content=string(t),loadFont(e.$font).then((()=>{renderText(e),d()})).catch(l)}));init.$defaults=[str(\"Text\"),int(),int(),int(50),int(),tuple(),o.DEFAULT],init.co_varnames=[\"self\",\"content\",\"x\",\"y\",\"font_size\",\"angle\",\"color\",\"font\"],t.__init__=def(init),t.draw=def((e=>{n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,e.$texture),drawShape(e,e.$size,c,n.TRIANGLE_STRIP,!0,4)})),t.content=property(def((e=>str(e.$content))),def(((e,o)=>{e.$content=string(o),renderText(e)}))),t.font=property(def((e=>str(e.$font))),def(((e,o)=>wait(((t,r)=>{loadFont(e.$font=string(o)).then((()=>{renderText(e),t()})).catch(r)}))))),t.font_size=property(def((e=>float(e.$font_size))),def(((e,o)=>{e.$font_size=number(o),renderText(e)})))}),\"Text\",[o.Rectangle]),o.random=def(((e,o)=>{const t=Math.min(number(e),number(o));return float(Math.random()*(Math.max(number(e),number(o))-t)+t)})),o.run=def((()=>wait(((r,i)=>{const update=()=>{const final=o=>{n.deleteBuffer(c),n.deleteProgram(a),t.forEach((e=>n.deleteTexture(e.source))),d.disconnect(),e.removeEventListener(\"mouseenter\",mouseEnter),e.removeEventListener(\"mouseleave\",mouseLeave),e.removeEventListener(\"mousedown\",mouseDown),e.removeEventListener(\"mouseup\",mouseUp),e.removeEventListener(\"mousemove\",mouseMove),e.removeEventListener(\"keydown\",keyDown),e.removeEventListener(\"keyup\",keyUp),cancelAnimationFrame(s.frame),o?i(o):r()};if(o.window.$close||Date.now()-Sk.execStart>Sk.execLimit)return final();const l=o.camera.$pos[0],u=o.camera.$pos[1],$=new Float32Array([2/width(),0,0,0,0,2/height(),0,0,0,0,-2,0,2*-l/width(),2*-u/height(),-1,1]);n.uniformMatrix4fv(n.getUniformLocation(a,\"camera\"),!1,$),n.clear(n.COLOR_BUFFER_BIT);try{s.main.$d.loop&&call(s.main.$d.loop)}catch(p){final(p)}o.window.$resize=!1,o.cursor.$move=!1,o.cursor.$enter=!1,o.cursor.$leave=!1,o.cursor.$press=!1,o.cursor.$release=!1,o.key.$press=!1,o.key.$release=!1,o.key.$repeat=!1;for(const e in o.key.$data)o.key.$data[e].press=!1,o.key.$data[e].release=!1,o.key.$data[e].repeat=!1},loop=()=>{s.frame=requestAnimationFrame(loop),update()},s={main:Sk.importModule(\"__main__\",!1,!0),frame:requestAnimationFrame(loop)},d=new MutationObserver((()=>{n.viewport(0,0,e.width,e.height),o.window.$resize=!0,update()}));d.observe(e,{attributes:!0})})))),e.addEventListener(\"mouseenter\",mouseEnter),e.addEventListener(\"mouseleave\",mouseLeave),e.addEventListener(\"mousedown\",mouseDown),e.addEventListener(\"mouseup\",mouseUp),e.addEventListener(\"mousemove\",mouseMove),e.addEventListener(\"keydown\",keyDown),e.addEventListener(\"keyup\",keyUp),e.tabIndex=0,e.focus(),n.shaderSource(i,\"\\n        attribute vec2 vertex;\\n        attribute vec2 coordinate;\\n        varying vec2 position;\\n        \\n        uniform mat4 camera;\\n        uniform mat4 object;\\n        \\n        void main(void) {\\n            gl_Position = camera * object * vec4(vertex, 0, 1);\\n            position = coordinate;\\n        }\"),n.shaderSource(s,\"\\n        precision mediump float;\\n        varying vec2 position;\\n\\n        uniform vec4 color;\\n        uniform sampler2D sampler;\\n        uniform int image;\\n\\n        void main(void) {\\n            if (image == 1) gl_FragColor = texture2D(sampler, position) * color;\\n            else gl_FragColor = color;\\n        }\"),n.compileShader(i),n.compileShader(s),n.attachShader(a,i),n.attachShader(a,s),n.linkProgram(a),n.useProgram(a),n.uniform1i(n.getUniformLocation(a,\"sampler\"),0),n.deleteShader(i),n.deleteShader(s),n.bindBuffer(n.ARRAY_BUFFER,c),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-.5,.5,0,0,.5,.5,1,0,-.5,-.5,0,1,.5,-.5,1,1]),n.STATIC_DRAW),n.vertexAttribPointer(n.getAttribLocation(a,\"vertex\"),2,n.FLOAT,!1,16,0),n.vertexAttribPointer(n.getAttribLocation(a,\"coordinate\"),2,n.FLOAT,!1,16,8),n.enableVertexAttribArray(0),n.enableVertexAttribArray(1),n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.pixelStorei(n.UNPACK_ALIGNMENT,1),o};","src/lib/_strptime.js":"function $builtinmodule(){const e=Sk.builtin.int_,t=Sk.builtin.none.none$,i=Sk.builtin.str,s=Sk.builtin.tuple,n=Sk.misceval.callsimOrSuspendArray,{isTrue:a,richCompareBool:r,chain:l}=Sk.misceval,{typeName:o,setUpModuleMethods:_,buildNativeClass:c}=Sk.abstr,{TypeError:m,ValueError:d,KeyError:h,IndexError:f,checkString:u,asnum$:w}=Sk.builtin,{remapToPy:p,remapToJs:g}=Sk.ffi,{getAttr:$,setAttr:y}=Sk.generic,S=l,k=/^[0-9]+$/;function _as_integer(e){if(!k.test(e))throw new d(`invalid literal for int() with base 10: '${e}'`);return parseInt(e)}const b=/([\\\\.^$*+?\\(\\){}\\[\\]|])/g,v=/\\s+/g;let O=Sk.importModule(\"time\",!1,!0),z=Sk.importModule(\"datetime\",!1,!0);const L=S(z,(e=>(z=e.$d,O)),(e=>{O=e.$d}));return S(L,(()=>{function _strftime(e){return t=>e.$strftime(t).toString().toLowerCase()}function _strftime_timetuple(e,t){return O.strftime.tp$call([new i(e),t]).toString().toLowerCase()}const l=new i(\"fromordinal\");function _struct_time(t){return O.struct_time.tp$call([new s(t.map((t=>new e(t))))])}function _localized_month(){const e=[()=>\"\"];for(let t=0;t<12;t++){const i=new k(2001,t+1,1);e.push(_strftime(i))}return e}function _localized_day(){const e=[];for(let t=0;t<7;t++){const i=new k(2001,1,t+1);e.push(_strftime(i))}return e}const S={__name__:new i(\"_strptime\")},k=z.date,L=z.timedelta,E=z.timezone;function _getlang(){return[t,t]}class LocaleTime{constructor(){this.lang=_getlang(),this.__calc_weekday(),this.__calc_month(),this.__calc_am_pm(),this.__calc_timezone(),this.__calc_date_time()}__calc_weekday(){this.a_weekday=_localized_day().map((e=>e(\"%a\"))),this.f_weekday=_localized_day().map((e=>e(\"%A\")))}__calc_month(){this.a_month=_localized_month().map((e=>e(\"%b\"))),this.f_month=_localized_month().map((e=>e(\"%B\")))}__calc_am_pm(){const e=[];[1,22].forEach((t=>{const i=_strftime_timetuple(\"%p\",_struct_time([1999,3,17,t,44,55,2,76,0]));e.push(i)})),this.am_pm=e}__calc_date_time(){const e=_struct_time([1999,3,17,22,44,55,2,76,0]),i=[t,t,t];i[0]=_strftime_timetuple(\"%c\",e),i[1]=_strftime_timetuple(\"%x\",e),i[2]=_strftime_timetuple(\"%X\",e);const s=[[\"%\",\"%%\"],[this.f_weekday[2],\"%A\"],[this.f_month[3],\"%B\"],[this.a_weekday[2],\"%a\"],[this.a_month[3],\"%b\"],[this.am_pm[1],\"%p\"],[\"1999\",\"%Y\"],[\"99\",\"%y\"],[\"22\",\"%H\"],[\"44\",\"%M\"],[\"55\",\"%S\"],[\"76\",\"%j\"],[\"17\",\"%d\"],[\"03\",\"%m\"],[\"3\",\"%m\"],[\"2\",\"%w\"],[\"10\",\"%I\"]];s.push(...this.timezone.flat().map((e=>[e,\"%Z\"]))),[[0,\"%c\"],[1,\"%x\"],[2,\"%X\"]].forEach((([e,t])=>{let n=i[e];s.forEach((([e,t])=>{e&&(n=n.replace(e,t))}));let a;a=_strftime_timetuple(t,_struct_time([1999,1,3,1,1,1,6,3,0])).includes(\"00\")?\"%W\":\"%U\",i[e]=n.replace(\"11\",a)})),this.LC_date_time=i[0],this.LC_date=i[1],this.LC_time=i[2]}__calc_timezone(){try{O.tzset.tp$call([])}catch{}this.tzname=O.tzname.v.map((e=>e.toString())),this.daylight=w(O.daylight);const e=[this.tzname[0].toLowerCase(),\"utc\",\"gmt\"];let t;t=this.daylight?[this.tzname[1].toLowerCase()]:[],this.timezone=[e,t]}}class TimeRE{constructor(e=null){this.locale_time=e||new LocaleTime,Object.assign(this,{d:\"(?<d>3[0-1]|[1-2]\\\\d|0[1-9]|[1-9]| [1-9])\",f:\"(?<f>[0-9]{1,6})\",H:\"(?<H>2[0-3]|[0-1]\\\\d|\\\\d)\",I:\"(?<I>1[0-2]|0[1-9]|[1-9])\",G:\"(?<G>\\\\d\\\\d\\\\d\\\\d)\",j:\"(?<j>36[0-6]|3[0-5]\\\\d|[1-2]\\\\d\\\\d|0[1-9]\\\\d|00[1-9]|[1-9]\\\\d|0[1-9]|[1-9])\",m:\"(?<m>1[0-2]|0[1-9]|[1-9])\",M:\"(?<M>[0-5]\\\\d|\\\\d)\",S:\"(?<S>6[0-1]|[0-5]\\\\d|\\\\d)\",U:\"(?<U>5[0-3]|[0-4]\\\\d|\\\\d)\",w:\"(?<w>[0-6])\",u:\"(?<u>[1-7])\",V:\"(?<V>5[0-3]|0[1-9]|[1-4]\\\\d|\\\\d)\",y:\"(?<y>\\\\d\\\\d)\",Y:\"(?<Y>\\\\d\\\\d\\\\d\\\\d)\",z:\"(?<z>[+-]\\\\d\\\\d:?[0-5]\\\\d(:?[0-5]\\\\d(\\\\.\\\\d{1,6})?)?|Z)\",A:this.__seqToRE(this.locale_time.f_weekday,\"A\"),a:this.__seqToRE(this.locale_time.a_weekday,\"a\"),B:this.__seqToRE(this.locale_time.f_month.slice(1),\"B\"),b:this.__seqToRE(this.locale_time.a_month.slice(1),\"b\"),p:this.__seqToRE(this.locale_time.am_pm,\"p\"),Z:this.__seqToRE(this.locale_time.timezone.flat(),\"Z\"),\"%\":\"%\"}),this.W=this.U.replace(\"U\",\"W\"),this.x=this.pattern(this.locale_time.LC_date),this.X=this.pattern(this.locale_time.LC_time),this.c=this.pattern(this.locale_time.LC_date_time)}__seqToRE(e,t){if((e=e.slice(0).sort(((e,t)=>t.length-e.length))).every((e=>\"\"===e)))return\"\";return`(?<${t}>${e.map((e=>e)).join(\"|\")})`}pattern(e){let t=\"\";for(e=(e=e.replace(b,\"\\\\$1\")).replace(v,\"\\\\s+\");e.includes(\"%\");){const i=e.indexOf(\"%\")+1,s=this[e[i]];if(void 0===s)throw new h(e[i]);t=`${t}${e.slice(0,i-1)}${s}`,e=e.slice(i+1)}return t+e}compile(e){return new RegExp(\"^\"+this.pattern(e),\"i\")}}let C=new TimeRE;const T=5;let A={};function _strptime(i,s=\"%a %b %d %H:%M:%S %Y\"){function _checkString(e,t){if(\"string\"!=typeof e&&!u(e))throw new m(`strptime() argument ${t} must be a str, not '${o(e)}'`)}_checkString(i,0),_checkString(s,1),i=i.toString(),s=s.toString();let n,_=C.locale_time;if(Object.keys(A).length>T&&(A={}),n=A[s],void 0===n)try{n=C.compile(s)}catch(V){if(V instanceof h){let e=V.args.v[0];throw\"\\\\\"==e&&(e=\"%\"),new d(`'${e}' is a bad directive in format '${s}'`)}if(V instanceof f)throw new d(\"stray %% in format '\"+s+\"'\");throw V}const c=i.match(n);if(null===c)throw new d(`time data '${i}' does not match format '${s}'`);if(i.length!==c[0].length)throw new d(`unconverted data remains: ${i.slice(c[0].length)}`);let w=t,p=t,g=1,$=1,y=0,S=0,b=0,v=0,z=-1,L=t,E=0,I=t,M=t,H=t,Y=t,j=t,U=c.groups||{};if(Object.keys(U).forEach((e=>{if(void 0!==U[e])if(\"y\"===e)p=_as_integer(U.y),p+=p<=68?2e3:1900;else if(\"Y\"===e)p=_as_integer(U.Y);else if(\"G\"===e)w=_as_integer(U.G);else if(\"m\"===e)g=_as_integer(U.m);else if(\"B\"===e)g=_.f_month.indexOf(U.B.toLowerCase());else if(\"b\"===e)g=_.a_month.indexOf(U.b.toLowerCase());else if(\"d\"===e)$=_as_integer(U.d);else if(\"H\"===e)y=_as_integer(U.H);else if(\"H\"===e)y=_as_integer(U.H);else if(\"I\"===e){y=_as_integer(U.I);const e=(U.p||\"\").toLowerCase();[\"\",_.am_pm[0]].includes(e)?12===y&&(y=0):e===_.am_pm[1]&&12!==y&&(y+=12)}else if(\"M\"===e)S=_as_integer(U.M);else if(\"S\"===e)b=_as_integer(U.S);else if(\"f\"===e){let e=U.f;e+=\"0\".repeat(6-e.length),v=_as_integer(e)}else if(\"A\"===e)Y=_.f_weekday.indexOf(U.A.toLowerCase());else if(\"a\"===e)Y=_.a_weekday.indexOf(U.a.toLowerCase());else if(\"w\"===e)Y=_as_integer(U.w),0===Y?Y=6:Y-=1;else if(\"u\"===e)Y=_as_integer(U.u),Y-=1;else if(\"j\"===e)j=_as_integer(U.j);else if([\"U\",\"W\"].includes(e))M=_as_integer(U[e]),H=\"U\"===e?6:0;else if(\"V\"===e)I=_as_integer(U.V);else if(\"z\"===e){let e=U.z;if(\"Z\"===e)L=0;else{if(\":\"===e[3]&&(e=e.slice(0,3)+e.slice(4),e.length>5)){if(\":\"!==e[5]){const e=`Inconsistent use of : in ${U.z}`;throw new d(e)}e=e.slice(0,5)+e.slice(6)}const t=_as_integer(e.slice(1,3)),i=_as_integer(e.slice(3,5)),s=_as_integer(e.slice(5,7)||0);L=3600*t+60*i+s;const n=e.slice(8),a=\"0\".repeat(6-n.length);E=_as_integer(n+a),e.startsWith(\"-\")&&(L=-L,E=-E)}}else if(\"Z\"===e){let e=U.Z.toLowerCase(),t=0;for(let i of _.timezone){if(i.includes(e)){const i=O.tzname.v;if(r(i[0],i[1],\"Eq\")&&a(O.daylight)&&![\"utc\",\"gmt\"].includes(e))break;z=t}t++}}})),p===t&&w!==t){if(I===t||Y===t)throw new d(\"ISO year directive '%G' must be used with the ISO week directive '%V' and a weekday directive ('%A','%a', '%w', or '%u').\");if(j!==t)throw new d(\"Day of the year directive '%j' is not compatible with ISO year directive '%G'.Use '%Y' instead.\")}else if(M===t&&I!==t)throw new d(Y===t?\"ISO week directive '%V' must be used with the ISO year directive '%G' and a weekday directive ('%A', '%a', '%w', or '%u').\":\"ISO week directive '%V' is incompatible with the year directive '%Y'. Use the ISO year '%G' instead.\");let x=!1;if(p===t&&2===g&&29===$?(p=1904,x=!0):p===t&&(p=1900),j===t&&Y!==t){if(M!==t){j=function _calc_julian_from_U_or_W(e,t,i,s){let n=(new k(e,1,1).$toOrdinal()+6)%7;return s||(n=(n+1)%7,i=(i+1)%7),0===t?1+i-n:(7-n)%7+7*(t-1)+1+i}(p,M,Y,0===H)}else w!==t&&I!==t&&([p,j]=function _calc_julian_from_V(e,t,i){let s=7*t+i-((new k(e,1,4).$toOrdinal()%7||7)+3);return s<1&&(s+=new k(e,1,1).$toOrdinal(),s-=new k(e-=1,1,1).$toOrdinal()),[e,s]}(w,I,Y+1));if(j!==t&&j<=0){p-=1;const e=function _is_leap(e){return e%4==0&&(e%100!=0||e%400==0)}(p)?366:365;j+=e}}if(j===t)j=new k(p,g,$).$toOrdinal()-new k(p,1,1).$toOrdinal()+1;else{const t=function _fromordinal(t){return k.tp$getattr(l).tp$call([new e(t)])}(j-1+new k(p,1,1).$toOrdinal());p=t.$year,g=t.$month,$=t.$day}Y===t&&(Y=(new k(p,g,$).$toOrdinal()+6)%7);const R=U.Z||t;return x&&(p=1900),[[p,g,$,y,S,b,Y,j,z,R,L],v,E]}return _(\"_strptime\",S,{_strptime_time:{$meth:function _strptime_time(t,i=\"%a %b %d %H:%M:%S %Y\"){let n=_strptime(t,i)[0].slice(0,11);return n=n.map(((t,i)=>i<9?new e(t):p(t))),O.struct_time.tp$call([new s(n)])},$flags:{NamedArgs:[\"data_string\",\"format\"],Defaults:[\"%a %b %d %H:%M:%S %Y\"]}},_strptime_datetime:{$meth:function _strptime_datetime(s,r,l=\"%a %b %d %H:%M:%S %Y\"){const[o,_,c]=_strptime(r,l),[m,d]=o.slice(-2),h=o.slice(0,6);let f,u;return h.push(_),h.map((t=>new e(t))),d!==t&&(f=new L(0,d,c),u=a(m)?new E(f,new i(m)):new E(f),h.push(u)),n(s,h)},$flags:{NamedArgs:[\"cls\",\"data_string\",\"format\"],Defaults:[\"%a %b %d %H:%M:%S %Y\"]}},_strptime:{$meth(i,n){const a=_strptime(i,n);return a[0]=new s(a[0].map((i=>i===t?i:new e(i)))),a[1]=new e(a[1]),a[2]=new e(a[2]),new s(a)},$flags:{NamedArgs:[\"data_string\",\"format\"],Defaults:[\"%a %b %d %H:%M:%S %Y\"]}},_getlang:{$meth:()=>p(_getlang()),$flags:{NoArgs:!0}}}),S.LocaleTime=c(\"_strptime.LocaleTime\",{constructor:function(){this.v=new LocaleTime},slots:{tp$getattr(e,t){return this.v.hasOwnProperty(e.toString())?p(this.v[e.toString()]):$.call(this,e,t)},tp$setattr(e,t){if(!this.v.hasOwnProperty(e.toString()))return y.call(this,e,t);this.v[e.toString()]=g(t)}}}),S}))}","src/lib/altair/vega_caller.js":"var $builtinmodule=function(e){var n={__file__:\"/src/lib/vega_caller.js\"};return n.__package__=Sk.builtin.none.none$,n.render_graph=new Sk.builtin.func((function(e){Sk.builtin.pyCheckArgs(\"render_graph\",arguments,1,1);let n=\"#\"+Sk.divid+\"_graphics\";try{vegaEmbed(n,Sk.ffi.remapToJs(e),{actions:!0})}catch(i){throw new Sk.builtin.Exception(\"Error in graph specification unable to render the graph\\n\"+i.message)}})),n};","src/lib/array.js":"function $builtinmodule(e){var n={},t=[\"c\",\"b\",\"B\",\"u\",\"h\",\"H\",\"i\",\"I\",\"l\",\"L\",\"f\",\"d\"];return n.__name__=new Sk.builtin.str(\"array\"),n.array=Sk.misceval.buildClass(n,(function(e,n){n.__init__=new Sk.builtin.func((function(e,n,i){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,3),-1==t.indexOf(Sk.ffi.remapToJs(n)))throw new Sk.builtin.ValueError(\"bad typecode (must be c, b, B, u, h, H, i, I, l, L, f or d)\");if(i&&!Sk.builtin.checkIterable(i))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");if(e.$d.mp$ass_subscript(new Sk.builtin.str(\"typecode\"),n),e.$d.mp$ass_subscript(new Sk.builtin.str(\"__module__\"),new Sk.builtin.str(\"array\")),e.typecode=n,void 0===i)e.internalIterable=new Sk.builtin.list;else if(i instanceof Sk.builtin.list)e.internalIterable=i;else{e.internalIterable=new Sk.builtin.list;for(let n=Sk.abstr.iter(i),t=n.tp$iternext();void 0!==t;t=n.tp$iternext())Sk.misceval.callsimArray(e.internalIterable.append,[e.internalIterable,t])}})),n.__repr__=new Sk.builtin.func((function(e){var n=Sk.ffi.remapToJs(e.typecode),t=\"\";return Sk.ffi.remapToJs(e.internalIterable).length&&(t=\"c\"==Sk.ffi.remapToJs(e.typecode)?\", '\"+Sk.ffi.remapToJs(e.internalIterable).join(\"\")+\"'\":\", \"+Sk.ffi.remapToJs(Sk.misceval.callsimArray(e.internalIterable.__repr__,[e.internalIterable]))),new Sk.builtin.str(\"array('\"+n+\"'\"+t+\")\")})),n.__str__=n.__repr__,n.__getattribute__=new Sk.builtin.func((function(e,n){return e.tp$getattr(n)})),n.append=new Sk.builtin.func((function(e,n){return Sk.misceval.callsimArray(e.internalIterable.append,[e.internalIterable,n]),Sk.builtin.none.none$})),n.extend=new Sk.builtin.func((function(e,n){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2),!Sk.builtin.checkIterable(n))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");for(let t=Sk.abstr.iter(n),i=t.tp$iternext();void 0!==i;i=t.tp$iternext())Sk.misceval.callsimArray(e.internalIterable.append,[e.internalIterable,i])}))}),\"array\",[]),n}","src/lib/calendar.js":"function $builtinmodule(e){const t={},{misceval:{chain:n},importModule:r}=Sk,importOrSuspend=e=>r(e,!1,!0);return n(importOrSuspend(\"datetime\"),(e=>(t.datetime=e,importOrSuspend(\"itertools\"))),(e=>(t.iterRepeat=e.$d.repeat,t.iterChain=e.$d.chain,calendarModule(t))))}function calendarModule(e){const{abstr:{setUpModuleMethods:t,numberBinOp:n,iter:r,objectGetItem:o},builtin:{bool:s,bool:{true$:m,false$:d},func:l,int_:i,list:c,none:{none$:f},str:h,slice:w,tuple:y,range:u,max:_,min:g,property:k,print:p,enumerate:$,ValueError:b},ffi:{remapToPy:M},misceval:{isTrue:T,iterator:C,arrayFromIterable:O,buildClass:L,richCompareBool:x,asIndexOrThrow:F,objectRepr:I,callsimArray:A},global:v,global:{strftime:E}}=Sk,S=new i(0),H=new i(1),D=new i(2),N=new i(3),R=new i(6),j=new i(7),J=new i(9),P=new i(12),Y=new i(13),U=new i(24),z=new i(60),le=(e,t)=>x(e,t,\"LtE\"),eq=(e,t)=>x(e,t,\"Eq\"),mod=(e,t)=>n(e,t,\"Mod\"),add=(e,t)=>n(e,t,\"Add\"),sub=(e,t)=>n(e,t,\"Sub\"),mul=(e,t)=>n(e,t,\"Mult\"),inc=e=>add(e,H),dec=e=>sub(e,H),mod7=e=>mod(e,j),getA=(e,t)=>e.tp$getattr(new h(t)),callA=(e,t,...n)=>A(e.tp$getattr(new h(t)),n);function*iterJs(e){const t=r(e);let n;for(;n=t.tp$iternext();)yield n}function iterFn(e,t){return e=r(e),new C((()=>{const n=e.tp$iternext();return n&&t(n)}),!0)}function makePyMethod(e,t,{args:n,name:r,doc:o,defaults:s}){t.co_varnames=[\"self\",...n||[]],t.co_docstring=o?new h(o):f,s&&(t.$defaults=s),t.co_name=new h(r),t.co_qualname=new h(e+\".\"+r);const m=new l(t);return m.$module=Q.__name__,m}const{datetime:B,iterRepeat:W,iterChain:q}=e;let{MINYEAR:G,MAXYEAR:X,date:V}=B.$d;const K=getA(h,\"center\"),pyCenter=(e,t)=>A(K,[e,t]),pyRStrip=e=>new h(e.toString().trimRight());G=G.valueOf(),X=X.valueOf();const Q={__name__:new h(\"calendar\"),__all__:M([\"IllegalMonthError\",\"IllegalWeekdayError\",\"setfirstweekday\",\"firstweekday\",\"isleap\",\"leapdays\",\"weekday\",\"monthrange\",\"monthcalendar\",\"prmonth\",\"month\",\"prcal\",\"calendar\",\"timegm\",\"month_name\",\"month_abbr\",\"day_name\",\"day_abbr\",\"Calendar\",\"TextCalendar\",\"HTMLCalendar\",\"LocaleTextCalendar\",\"LocaleHTMLCalendar\",\"weekheader\"])};function makeErr(e,t){return L(Q,((e,n)=>{n.__init__=new l((function __init__(e,t){e.$attr=t})),n.__str__=new l((function __str__(e){return new h(t.replace(\"$\",I(e.$attr)))}))}),e,[b])}const Z=makeErr(\"IllegalMonthError\",\"bad month $; must be 1-12\"),ee=makeErr(\"IllegalWeekdayError\",\"bad weekday number $; must be 0 (Monday) to 6 (Sunday)\"),te=1,ae=2,ne=[0,31,28,31,30,31,30,31,31,30,31,30,31];function mkLocalizedCls(e,t){t.__init__=new l((function __init__(e,t){e.format=t})),t.__getitem__=new l((function __getitem__(t,n){const r=o(e,n);if(n instanceof w){const e=[];for(const n of r.valueOf())e.push(A(n,[t.format]));return new c(e)}return A(r,[t.format])}));const n=new i(e.valueOf().length);t.__len__=new l((function __len__(e){return n}))}const re=new h(\"strftime\"),oe=L(Q,((e,t)=>{let n=[new l((e=>h.$empty))];for(let r=0;r<12;r++){const e=new V(2001,r+1,1);n.push(e.tp$getattr(re))}n=new c(n),t._months=n,mkLocalizedCls(n,t)}),\"_localized_month\"),se=L(Q,((e,t)=>{let n=[];for(let r=0;r<7;r++){const e=new V(2001,1,r+1);n.push(e.tp$getattr(re))}n=new c(n),t._days=n,mkLocalizedCls(n,t)}),\"_localized_day\"),me=A(se,[new h(\"%A\")]),de=A(se,[new h(\"%a\")]),ie=A(oe,[new h(\"%B\")]),ce=A(oe,[new h(\"%b\")]),[fe,he,we,ye,ue,_e,ge]=[0,1,2,3,4,5,6];function isleap(e){return(e=F(e))%4==0&&(e%100!=0||e%400==0)}function weekday(e,t,n){e=F(e),G<=e&&e<=X||(e=2e3+e%400);const r=A(V,[new i(e),t,n]);return callA(V,\"weekday\",r)}function monthrange(e,t){if(!le(H,t)||!le(t,P))throw A(Z,[t]);const n=weekday(e,t,H);t=F(t);const r=ne[t]+Number(t===ae&&isleap(e));return[n,new i(r)]}function iterweekdays(e){return iterFn(A(u,[e.fwd,add(e.fwd,j)]),mod7)}function itermonthdates(e,t,n){return iterFn(itermonthdays3(e,t,n),(e=>A(V,e.valueOf())))}function itermonthdays(e,t,n){const[r,o]=monthrange(t,n),s=mod7(sub(r,e.fwd)),m=A(W,[S,s]),d=A(u,[H,inc(o)]),l=mod7(sub(e.fwd,add(r,o))),i=A(W,[S,l]);return A(q,[m,d,i])}function itermonthdays2(e,t,n){return iterFn(A($,[itermonthdays(e,t,n),e.fwd]),(e=>{const[t,n]=e.valueOf();return new y([n,mod7(t)])}))}function itermonthdays3(e,t,n){const ymdIter=(e,t,n)=>iterFn(n,(n=>new y([e,t,n]))),[r,o]=monthrange(t,n),s=mod7(sub(r,e.fwd)),m=mod7(sub(e.fwd,add(r,o))),[d,l]=function _prevmonth(e,t){return eq(t,H)?[dec(e),P]:[e,dec(t)]}(t,n),c=inc(function _monthlen(e,t){return t=F(t),new i(ne[t]+Number(t===ae&&isleap(e)))}(d,l)),f=A(u,[sub(c,s),c]),h=A(u,[H,inc(o)]),[w,_]=function _nextmonth(e,t){return eq(t,P)?[inc(e),H]:[e,inc(t)]}(t,n),g=A(u,[H,inc(m)]);return A(q,[ymdIter(d,l,f),ymdIter(t,n,h),ymdIter(w,_,g)])}function itermonthdays4(e,t,n){const r=itermonthdays3(e,t,n);let o=0;return iterFn(r,(t=>new y([...t.valueOf(),mod7(add(e.fwd,new i(o++)))])))}function _monthIter(e,t,n,r){const o=O(e(t,n,r)),s=[];for(let m=0;m<o.length;m+=7)s.push(new c(o.slice(m,m+7)));return new c(s)}function monthdatescalendar(e,t,n){return _monthIter(itermonthdates,e,t,n)}function monthdays2calendar(e,t,n){return _monthIter(itermonthdays2,e,t,n)}function monthdayscalendar(e,t,n){return _monthIter(itermonthdays,e,t,n)}function _yearIter(e,t,n,r){r=F(r);const o=[];for(let m=te;m<te+12;m++)o.push(e(t,n,new i(m)));const s=[];for(let m=0;m<o.length;m+=r)s.push(new c(o.slice(m,m+r)));return new c(s)}function yeardatescalendar(e,t,n){return _yearIter(monthdatescalendar,e,t,n)}function yeardays2calendar(e,t,n){return _yearIter(monthdays2calendar,e,t,n)}function yeardayscalendar(e,t,n){return _yearIter(monthdayscalendar,e,t,n)}const ke=L(Q,((e,t)=>{const n=makePyMethod.bind(null,\"Calendar\"),r=[\"firstweekday\"],o=[\"year\",\"month\"],s=[\"year\",\"width\"],m={__init__:n((function __init__(e,t){return Object.defineProperty(e,\"fwd\",{get(){return mod7(this._fwd)},set(e){return this._fwd=e,!0}}),e.fwd=t,f}),{name:\"__init__\",args:r,defaults:[S]}),getfirstweekday:n((function getfirstweekday(e){return e.fwd}),{name:\"getfirstweekday\"}),setfirstweekday:n((function setfirstweekday(e,t){return e.fwd=t,f}),{name:\"setfirstweekday\",args:r}),iterweekdays:n(iterweekdays,{name:\"iterweekdays\"}),itermonthdates:n(itermonthdates,{name:\"itermonthdates\",args:o}),itermonthdays:n(itermonthdays,{name:\"itermonthdays\",args:o}),itermonthdays2:n(itermonthdays2,{name:\"itermonthdays2\",args:o}),itermonthdays3:n(itermonthdays3,{name:\"itermonthdays3\",args:o}),itermonthdays4:n(itermonthdays4,{name:\"itermonthdays4\",args:o}),monthdatescalendar:n(monthdatescalendar,{name:\"monthdatescalendar\",args:o}),monthdays2calendar:n(monthdays2calendar,{name:\"monthdays2calendar\",args:o}),monthdayscalendar:n(monthdayscalendar,{name:\"monthdayscalendar\",args:o}),yeardatescalendar:n(yeardatescalendar,{name:\"yeardatescalendar\",args:s,defaults:[N]}),yeardays2calendar:n(yeardays2calendar,{name:\"yeardays2calendar\",args:s,defaults:[N]}),yeardayscalendar:n(yeardayscalendar,{name:\"yeardayscalendar\",args:s,defaults:[N]})};m.firstweekday=new k(m.getfirstweekday,m.setfirstweekday),Object.assign(t,m)}),\"Calendar\");function doTextFormatweekday(e,t,n){let r;return r=x(n,J,\"GtE\")?me:de,pyCenter(o(o(r,t),new w(f,n)),n)}function doTextFormatmonthname(e,t,n,r,s=!0){let m=o(ie,n);return T(s)&&(m=mod(new h(\"%s %r\"),new y([m,t]))),pyCenter(m,r)}const pe=L(Q,((e,t)=>{const txtPrint=e=>p([e],[\"end\",h.$empty]);const n=doTextFormatweekday;function formatweekheader(e,t){const n=[];for(const r of iterJs(iterweekdays(e)))n.push(callA(e,\"formatweekday\",r,t).toString());return new h(n.join(\" \"))}const r=doTextFormatmonthname;const o=makePyMethod.bind(null,\"TextCalendar\"),s={prweek:o((function prweek(e,t,n){txtPrint(callA(e,\"formatweek\",t,n))}),{name:\"prweek\",args:[\"theweek\",\"width\"]}),formatday:o((function formatday(e,t,n,r){let o;return o=eq(t,S)?h.$empty:mod(new h(\"%2i\"),t),pyCenter(o,r)}),{name:\"formatday\",args:[\"day\",\"weekday\",\"width\"]}),formatweek:o((function formatweek(e,t,n){const r=[];for(const o of iterJs(t)){const[t,s]=o.valueOf();r.push(callA(e,\"formatday\",t,s,n).toString())}return new h(r.join(\" \"))}),{name:\"formatweek\",args:[\"theweek\",\"width\"]}),formatweekday:o(n,{name:\"formatweekday\",args:[\"day\",\"width\"]}),formatweekheader:o(formatweekheader,{name:\"formatweekheader\",args:[\"width\"]}),formatmonthname:o(r,{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"width\",\"withyear\"],defaults:[m]}),prmonth:o((function prmonth(e,t,n,r,o){txtPrint(callA(e,\"formatmonth\",t,n,r,o))}),{name:\"prmonth\",args:[\"theyear\",\"themonth\",\"w\",\"l\"],defaults:[S,S]}),formatmonth:o((function formatmonth(e,t,n,r,o){const addNewLines=e=>new h(e+\"\\n\".repeat(o.valueOf()));r=_([D,r]),o=_([H,o]);let s=callA(e,\"formatmonthname\",t,n,dec(mul(j,inc(r))),!0);s=pyRStrip(s),s=addNewLines(s),s=add(s,pyRStrip(callA(e,\"formatweekheader\",r))),s=addNewLines(s);for(const m of iterJs(monthdays2calendar(e,t,n)))s=add(s,pyRStrip(callA(e,\"formatweek\",m,r))),s=addNewLines(s);return s}),{name:\"formatmonth\",args:[\"thyear\",\"themonth\",\"w\",\"l\"],defaults:[S,S]}),formatyear:o((function formatyear(e,t,n,r,o,s){n=_([D,n]),r=_([H,r]),o=_([D,o]);const m=dec(mul(inc(n),j));let d=\"\";const a=e=>d+=e;a(pyRStrip(pyCenter(t.$r(),add(mul(m,s),mul(o,dec(s)))))),a(\"\\n\".repeat(r));const l=formatweekheader(e,n);let f=0;for(const w of iterJs(yeardays2calendar(e,t,s))){const d=new i(f),y=inc(mul(s,d)),_=g([inc(mul(s,inc(d))),Y]),k=A(u,[y,_]);a(\"\\n\".repeat(r));const p=iterFn(k,(n=>callA(e,\"formatmonthname\",t,n,m,!1)));a(pyRStrip(formatstring(p,m,o))),a(\"\\n\".repeat(r));const $=iterFn(k,(e=>l));a(pyRStrip(formatstring($,m,o))),a(\"\\n\".repeat(r));const b=Math.max(...w.valueOf().map((e=>e.valueOf().length)));for(let t=0;t<b;t++){const s=[];for(let r of w.valueOf())r=r.valueOf(),t>=r.length?s.push(h.$empty):s.push(callA(e,\"formatweek\",r[t],n));a(pyRStrip(formatstring(new c(s),m,o))),a(\"\\n\".repeat(r))}f++}return new h(d)}),{name:\"formatyear\",args:[\"theyear\",\"w\",\"l\",\"c\",\"m\"],defaults:[D,H,R,N]}),pryear:o((function pryear(e,t,n,r,o,s){txtPrint(callA(e,\"formatyear\",t,n,r,o,s))}),{name:\"pryear\",args:[\"theyear\",\"w\",\"l\",\"c\",\"m\"],defaults:[S,S,R,N]})};Object.assign(t,s)}),\"TextCalendar\",[ke]);function doHtmlFormatweekday(e,t){return new h(`<th class=\"${o(getA(e,\"cssclasses_weekday_head\"),t)}\">${o(de,t)}</th>`)}function doHtmlFormatmonthname(e,t,n,r=!0){let s=\"\"+o(ie,n);return T(r)&&(s+=\" \"+t),new h(`<tr><th colspan=\"7\" class=\"${getA(e,\"cssclass_month_head\")}\">${s}</th></tr>`)}const $e=L(Q,((e,t)=>{const n=M([\"mon\",\"tue\",\"wed\",\"thu\",\"fri\",\"sat\",\"sun\"]),r=n,s=new h(\"noday\"),d=new h(\"month\"),l=d,c=new h(\"year\"),w=c,u=new h('<td class=\"%s\">&nbsp;</td>'),g=new h('<td class=\"%s\">%d</td>');const k=doHtmlFormatweekday;function formatweekheader(e){let t=\"\";for(const n of iterJs(iterweekdays(e)))t+=callA(e,\"formatweekday\",n);return new h(`<tr>${t}</tr>`)}const p=doHtmlFormatmonthname;const $=makePyMethod.bind(null,\"HTMLCalendar\"),b={formatday:$((function formatday(e,t,n){return eq(t,S)?mod(u,getA(e,\"cssclass_noday\")):mod(g,new y([o(getA(e,\"cssclasses\"),n),t]))}),{name:\"formatday\",args:[\"day\",\"weekday\"]}),formatweek:$((function formatweek(e,t){let n=\"\";for(const r of iterJs(t)){const[t,o]=r.valueOf();n+=callA(e,\"formatday\",t,o)}return new h(`<tr>${n}</tr>`)}),{name:\"formatweek\",args:[\"theweek\"]}),formatweekday:$(k,{name:\"formatweekday\",args:[\"day\"]}),formatweekheader:$(formatweekheader,{name:\"formatweekheader\"}),formatmonthname:$(p,{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"withyear\"],defaults:[m]}),formatmonth:$((function formatmonth(e,t,n,r=!0){let o=\"\";const a=e=>o+=e+\"\\n\";a(`<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"${getA(e,\"cssclass_month\")}\">`),a(callA(e,\"formatmonthname\",t,n,r)),a(formatweekheader(e));for(const s of iterJs(monthdays2calendar(e,t,n)))a(callA(e,\"formatweek\",s));return a(\"</table>\"),new h(o)}),{name:\"formatmonth\",args:[\"thyear\",\"themonth\",\"withyear\"],defaults:[m]}),formatyear:$((function formatyear(e,t,n){let r=\"\";const a=e=>r+=e;n=_([n,H]).valueOf(),a(`<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"${getA(e,\"cssclass_year\")}\">`),a(\"\\n\"),a(`<tr><th colspan=\"${n}\" class=\"${getA(e,\"cssclass_year_head\")}\">${t}</th></tr>`);for(let o=te;o<te+12;o+=n){a(\"<tr>\");const r=Math.min(o+n,13);for(let n=o;n<r;n++)a(\"<td>\"),a(callA(e,\"formatmonth\",t,new i(n),!1)),a(\"</td>\");a(\"</tr>\")}return a(\"</table>\"),new h(r)}),{name:\"formatyear\",args:[\"theyear\",\"width\"],defaults:[N]}),formatyearpage:$((function formatyearpage(e,t,n=3,r=\"calendar.css\",o=null){null!==o&&o!==f||(o=new h(\"utf-8\"));let s=\"\";const a=e=>s+=e;return a(`<?xml version=\"1.0\" encoding=\"${o}\"?>\\n`),a('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n'),a(\"<html>\\n\"),a(\"<head>\\n\"),a(`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=${o}\" />\\n`),r!==f&&a(`<link rel=\"stylesheet\" type=\"text/css\" href=\"${r}\" />\\n`),a(`<title>Calendar for ${t}</title>\\n`),a(\"</head>\\n\"),a(\"<body>\\n\"),a(callA(e,\"formatyear\",t,n)),a(\"</body>\\n\"),a(\"</html>\\n\"),callA(h,\"encode\",new h(s),o,new h(\"ignore\"))}),{name:\"formatyearpage\",args:[\"theyear\",\"width\",\"css\",\"encoding\"],defaults:[N,new h(\"calendar.css\"),new h(\"utf-8\")]}),cssclasses:n,cssclasses_weekday_head:r,cssclass_noday:s,cssclass_month_head:d,cssclass_month:l,cssclass_year_head:c,cssclass_year:w};Object.assign(t,b)}),\"HTMLCalendar\",[ke]);function withLocale(e,t){const n=E.localizeByIdentifier(e.toString());v.strftime=n;try{return t()}finally{v.strftime=E}}function localInit(e,t){T(t)||(t=new h(\"en_US\")),e.locale=t}const be=L(Q,((e,t)=>{const n=makePyMethod.bind(null,\"LocaleTextCalendar\"),r={__init__:n((function __init__(e,t,n){return callA(pe,\"__init__\",e,t),localInit(e,n),f}),{name:\"__init__\",args:[\"firstweekday\",\"locale\"],defaults:[S,f]}),formatweekday:n((function formatweekday(e,t,n){return withLocale(e.locale,(()=>doTextFormatweekday(0,t,n)))}),{name:\"formatweekday\",args:[\"day\",\"width\"]}),formatmonthname:n((function formatmonthname(e,t,n,r,o){return withLocale(e.locale,(()=>doTextFormatmonthname(0,t,n,r,o)))}),{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"width\",\"withyear\"],defaults:[m]})};Object.assign(t,r)}),\"LocaleTextCalendar\",[pe]),Me=L(Q,((e,t)=>{const n=makePyMethod.bind(null,\"LocaleHTMLCalendar\"),r={__init__:n((function __init__(e,t,n){return callA($e,\"__init__\",e,t),localInit(e,n),f}),{name:\"__init__\",args:[\"firstweekday\",\"locale\"],defaults:[S,f]}),formatweekday:n((function formatweekday(e,t){return withLocale(e.locale,(()=>doHtmlFormatweekday(e,t)))}),{name:\"formatweekday\",args:[\"day\"]}),formatmonthname:n((function formatmonthname(e,t,n,r){return withLocale(e.locale,(()=>doHtmlFormatmonthname(e,t,n,r)))}),{name:\"formatmonthname\",args:[\"theyear\",\"themonth\",\"withyear\"],defaults:[m]})};Object.assign(t,r)}),\"LocaleHTMLCalendar\",[$e]),Te=A(pe,[]);Object.assign(Q,{IllegalMonthError:Z,IllegalWeekdayError:ee,day_name:me,month_name:ie,day_abbr:de,month_abbr:ce,January:new i(te),February:new i(ae),mdays:M(ne),MONDAY:new i(fe),TUESDAY:new i(he),WEDNESDAY:new i(we),THURSDAY:new i(ye),FRIDAY:new i(ue),SATURDAY:new i(_e),SUNDAY:new i(ge),Calendar:ke,TextCalendar:pe,HTMLCalendar:$e,LocaleTextCalendar:be,LocaleHTMLCalendar:Me,c:Te,firstweekday:getA(Te,\"getfirstweekday\"),monthcalendar:getA(Te,\"monthdayscalendar\"),prweek:getA(Te,\"prweek\"),week:getA(Te,\"formatweek\"),weekheader:getA(Te,\"formatweekheader\"),prmonth:getA(Te,\"prmonth\"),month:getA(Te,\"formatmonth\"),calendar:getA(Te,\"formatyear\"),prcal:getA(Te,\"pryear\")});const Ce=new i(20),Oe=R;function formatstring(e,t,n){t||(t=Ce),n||(n=Oe),n=mul(n,new h(\" \"));const r=[];for(const o of iterJs(e))r.push(pyCenter(o,t).toString());return new h(r.join(n.toString()))}const Le=getA(V,\"toordinal\"),xe=A(Le,[new V(1970,1,1)]);return t(\"calendar\",Q,{isleap:{$meth:e=>s(isleap(e)),$flags:{NamedArgs:[\"year\"]},$doc:\"Return True for leap years, False for non-leap years\"},leapdays:{$meth(e,t){e=F(e)-1,t=F(t)-1;const n=Math.floor;return new i(n(t/4)-n(e/4)-(n(t/100)-n(e/100))+(n(t/400)-n(e/400)))},$flags:{MinArgs:2,MaxArgs:2}},weekday:{$meth:weekday,$flags:{NamedArgs:[\"year\",\"month\",\"day\"]},$doc:\"Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).\"},monthrange:{$meth:(e,t)=>new y(monthrange(e,t)),$flags:{NamedArgs:[\"year\",\"month\"]},$doc:\"Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for year, month.\"},setfirstweekday:{$meth(e){const t=F(e);if(!(fe<=t&&t<=ge))throw A(ee,[e]);Te.fwd=e},$flags:{NamedArgs:[\"firstweekday\"]}},format:{$meth:function format(e,t,n){return p([formatstring(e,t,n)]),f},$flags:{NamedArgs:[\"cols\",\"colwidth\",\"spacing\"],Defaults:[Ce,Oe]}},formatstring:{$meth:formatstring,$flags:{NamedArgs:[\"cols\",\"colwidth\",\"spacing\"],Defaults:[Ce,Oe]}},timegm:{$meth(e){const[t,n,r,o,s,m]=e.valueOf(),d=A(V,[t,n,H]),l=A(Le,[d]),i=add(sub(l,xe),dec(r)),c=add(mul(i,U),o),f=add(mul(c,z),s);return add(mul(f,z),m)},$flags:{OneArg:!0}}}),Q}","src/lib/cellbotics/__init__.js":"\"use strict\";function promiseToPy(e){const n=new Sk.misceval.Suspension;let i,t;return n.resume=function(){if(t)throw t;return i},n.data={type:\"Sk.promise\",promise:e.then((function(e){return i=e,e}),(function(e){return t=e,e}))},n}function remapToPy(e){return e instanceof Promise&&(e=promiseToPy(e)),Sk.ffi.remapToPy(e)}function remapToJsFunc(e,...n){return function(...i){n&&Sk.builtin.pyCheckArgs(e.name,i,...n),i=i.slice(1);return remapToPy(e(...i.map((e=>Sk.ffi.remapToJs(e)))))}}var $builtinmodule=function(e){return remapToPy(Promise.all([runestoneComponents.runestone_import(\"ble\"),runestoneComponents.runestone_import(\"simple_sensor\")]).then((([e,n])=>{const i={__name__:new Sk.builtin.str(\"cellbotics\")},get_self=e=>e&&e.__js_class;i.JsProperty=Sk.misceval.buildClass(i,(function(e,n){n.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",e,2,2);const[n,i]=e;n.__js_property=Sk.ffi.remapToJs(i)})),n.__get__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__get__\",e,2,3);const[n,i,t]=e;return remapToPy(get_self(i)[n.__js_property])}))}),\"JsProperty\",[]);const prop_wrap=e=>Sk.misceval.callsim(i.JsProperty,new Sk.builtins.str(e)),t=e.cell_bot_ble_gui.cell_bot_ble;t&&(i.CellBot=Sk.misceval.buildClass(i,(function(e,n){n.__init__=new Sk.builtin.func((function(e){if(!t.paired())throw\"The CellBot is not paired. Click on the Pair button before running your program.\";return remapToPy(t.resetHardware().then((()=>{})))})),n.INPUT=new Sk.builtin.int_(t.INPUT),n.OUTPUT=new Sk.builtin.int_(t.OUTPUT);const wrap=(e,n)=>new Sk.builtin.func(remapToJsFunc(e,n,n));n.resetHardware=wrap(t.resetHardware,1),n.pinMode=wrap(t.pinMode,3),n.digitalWrite=wrap(t.digitalWrite,3),n.digitalRead=wrap(t.digitalRead,2),n.ledcSetup=wrap(t.ledcSetup,4),n.ledcAttachPin=wrap(t.ledcAttachPin,3),n.ledcDetachPin=wrap(t.ledcDetachPin,2),n.ledcWrite=wrap(t.ledcWrite,3)}),\"CellBot\",[]));const method_wrap=(e,n)=>new Sk.builtin.func(((...i)=>remapToJsFunc(get_self(i[0])[e],n,n)(...i)));i._Sensor=Sk.misceval.buildClass(i,(function(e,n){n.start=method_wrap(\"start\",1),n.stop=method_wrap(\"stop\",1)}),\"_Sensor\",[]),i._XYZSensor=Sk.misceval.buildClass(i,(function(e,n){n.x=prop_wrap(\"x\"),n.y=prop_wrap(\"y\"),n.z=prop_wrap(\"z\")}),\"_XYZSensor\",[i._Sensor]),i._OrientationSensor=Sk.misceval.buildClass(i,(function(e,n){n.quaternion=prop_wrap(\"quaternion\")}),\"_OrientationSensor\",[i._Sensor]);const sensor_factory=(e,n,t)=>i[e]=Sk.misceval.buildClass(i,(function(e,n){n.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",[e],1,1),e[0].__js_class=new t}))}),e,[n]);return i.AmbientLightSensor=Sk.misceval.buildClass(i,(function(e,i){i.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",[e],1,1),e[0].__js_class=new n.SimpleAmbientLightSensor})),i.illuminance=prop_wrap(\"illuminance\")}),\"AmbientLightSensor\",[i._Sensor]),i.GeolocationSensor=Sk.misceval.buildClass(i,(function(e,i){i.__init__=new Sk.builtin.func((function(...e){Sk.builtin.pyCheckArgs(\"__init__\",[e],1,1),e[0].__js_class=new n.SimpleGeolocationSensor})),i.latitude=prop_wrap(\"latitude\"),i.longitude=prop_wrap(\"longitude\"),i.altitude=prop_wrap(\"altitude\"),i.accuracy=prop_wrap(\"accuracy\"),i.altitudeAccuracy=prop_wrap(\"altitudeAccuracy\"),i.heading=prop_wrap(\"heading\"),i.speed=prop_wrap(\"speed\")}),\"GeolocationSensor\",[i._Sensor]),sensor_factory(\"Accelerometer\",i._XYZSensor,n.SimpleAccelerometer),sensor_factory(\"Gyroscope\",i._XYZSensor,n.SimpleGyroscope),sensor_factory(\"Magnetometer\",i._XYZSensor,n.SimpleMagnetometer),sensor_factory(\"LinearAccelerationSensor\",i._XYZSensor,n.SimpleLinearAccelerationSensor),sensor_factory(\"GravitySensor\",i._XYZSensor,n.SimpleGravitySensor),sensor_factory(\"AbsoluteOrientationSensor\",i._OrientationSensor,n.SimpleAbsoluteOrientationSensor),sensor_factory(\"RelativeOrientationSensor\",i._OrientationSensor,n.SimpleRelativeOrientationSensor),i})))};","src/lib/collections.js":"function $builtinmodule(t){const e={};return Sk.misceval.chain(Sk.importModule(\"keyword\",!1,!0),(t=>(e._iskeyword=t.$d.iskeyword,Sk.importModule(\"itertools\",!1,!0))),(t=>(e._chain=t.$d.chain,e._starmap=t.$d.starmap,e._repeat=t.$d.repeat,Sk.importModule(\"operator\",!1,!0))),(t=>{e._itemgetter=t.$d.itemgetter}),(()=>collections_mod(e)))}function collections_mod(t){function counterNumberSlot(e){return function(i){if(void 0!==i&&!(i instanceof t.Counter))return Sk.builtin.NotImplemented.NotImplemented$;const s=new t.Counter;return e.call(this,s,i),s}}function counterInplaceSlot(t,e){return function(i){if(!(i instanceof Sk.builtin.dict))throw new Sk.builtin.TypeError(\"Counter \"+t+\"= \"+Sk.abstr.typeName(i)+\" is not supported\");return e.call(this,i),this.keep$positive()}}t.__all__=new Sk.builtin.list([\"deque\",\"defaultdict\",\"namedtuple\",\"Counter\",\"OrderedDict\"].map((t=>new Sk.builtin.str(t)))),t.defaultdict=Sk.abstr.buildNativeClass(\"collections.defaultdict\",{constructor:function defaultdict(t,e){this.default_factory=t,Sk.builtin.dict.call(this,e)},base:Sk.builtin.dict,methods:{copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__missing__:{$meth(t){if(Sk.builtin.checkNone(this.default_factory))throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(t));{const e=Sk.misceval.callsimArray(this.default_factory,[]);return this.mp$ass_subscript(t,e),e}},$flags:{OneArg:!0}}},getsets:{default_factory:{$get(){return this.default_factory},$set(t){t=t||Sk.builtin.none.none$,this.default_factory=t}}},slots:{tp$doc:\"defaultdict(default_factory[, ...]) --\\x3e dict with default factory\\n\\nThe default factory is called without arguments to produce\\na new value when a key is not present, in __getitem__ only.\\nA defaultdict compares equal to a dict with the same items.\\nAll remaining arguments are treated the same as if they were\\npassed to the dict constructor, including keyword arguments.\\n\",tp$init(t,e){const i=t.shift();if(void 0===i)this.default_factory=Sk.builtin.none.none$;else{if(!Sk.builtin.checkCallable(i)&&!Sk.builtin.checkNone(i))throw new Sk.builtin.TypeError(\"first argument must be callable\");this.default_factory=i}return Sk.builtin.dict.prototype.tp$init.call(this,t,e)},$r(){const t=Sk.misceval.objectRepr(this.default_factory),e=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str(\"defaultdict(\"+t+\", \"+e+\")\")}},proto:{$copy(){const e=[];return Sk.misceval.iterFor(Sk.abstr.iter(this),(t=>{e.push(t),e.push(this.mp$subscript(t))})),new t.defaultdict(this.default_factory,e)}}}),t.Counter=Sk.abstr.buildNativeClass(\"Counter\",{constructor:function Counter(){this.$d=new Sk.builtin.dict,Sk.builtin.dict.apply(this)},base:Sk.builtin.dict,methods:{elements:{$flags:{NoArgs:!0},$meth(){const e=t._chain.tp$getattr(new Sk.builtin.str(\"from_iterable\")),i=t._starmap,s=t._repeat,n=Sk.misceval.callsimArray;return n(e,[n(i,[s,n(this.tp$getattr(this.str$items))])])}},most_common:{$flags:{NamedArgs:[\"n\"],Defaults:[Sk.builtin.none.none$]},$meth(t){const e=this.sq$length();t=Sk.builtin.checkNone(t)||(t=Sk.misceval.asIndexOrThrow(t))>e?e:t<0?0:t;const i=this.$items().sort(((t,e)=>Sk.misceval.richCompareBool(t[1],e[1],\"Lt\")?1:Sk.misceval.richCompareBool(t[1],e[1],\"Gt\")?-1:0));return new Sk.builtin.list(i.slice(0,t).map((t=>new Sk.builtin.tuple(t))))}},update:{$flags:{FastCall:!0},$meth(t,e){return Sk.abstr.checkArgsLen(\"update\",t,0,1),this.counter$update(t,e)}},subtract:{$flags:{FastCall:!0},$meth(t,e){Sk.abstr.checkArgsLen(\"subtract\",t,0,1);const i=t[0];if(void 0!==i)if(i instanceof Sk.builtin.dict)for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,i.mp$subscript(n),\"Sub\"))}else for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,this.$one,\"Sub\"))}e=e||[];for(let s=0;s<e.length;s+=2){const t=new Sk.builtin.str(e[s]),i=this.mp$subscript(t);this.mp$ass_subscript(t,Sk.abstr.numberBinOp(i,e[s+1],\"Sub\"))}return Sk.builtin.none.none$}},__missing__:{$meth(t){return this.$zero},$flags:{OneArg:!0}},copy:{$meth(){return Sk.misceval.callsimArray(t.Counter,[this])},$flags:{NoArgs:!0}}},getsets:{__dict__:Sk.generic.getSetDict},slots:{tp$doc:\"Dict subclass for counting hashable items.  Sometimes called a bag\\n    or multiset.  Elements are stored as dictionary keys and their counts\\n    are stored as dictionary values.\\n\\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\\n\\n    >>> c.most_common(3)                # three most common elements\\n    [('a', 5), ('b', 4), ('c', 3)]\\n    >>> sorted(c)                       # list all unique elements\\n    ['a', 'b', 'c', 'd', 'e']\\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\\n    'aaaaabbbbcccdde'\\n    >>> sum(c.values())                 # total of all counts\\n    15\\n\\n    >>> c['a']                          # count of letter 'a'\\n    5\\n    >>> for elem in 'shazam':           # update counts from an iterable\\n    ...     c[elem] += 1                # by adding 1 to each element's count\\n    >>> c['a']                          # now there are seven 'a'\\n    7\\n    >>> del c['b']                      # remove all 'b'\\n    >>> c['b']                          # now there are zero 'b'\\n    0\\n\\n    >>> d = Counter('simsalabim')       # make another counter\\n    >>> c.update(d)                     # add in the second counter\\n    >>> c['a']                          # now there are nine 'a'\\n    9\\n\\n    >>> c.clear()                       # empty the counter\\n    >>> c\\n    Counter()\\n\\n    Note:  If a count is set to zero or reduced to zero, it will remain\\n    in the counter until the entry is deleted or the counter is cleared:\\n\\n    >>> c = Counter('aaabbc')\\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\\n    [('a', 3), ('c', 1), ('b', 0)]\\n\\n\",tp$init(t,e){return Sk.abstr.checkArgsLen(this.tpjs_name,t,0,1),this.counter$update(t,e)},$r(){const t=this.size>0?Sk.builtin.dict.prototype.$r.call(this).v:\"\";return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+\")\")},tp$as_sequence_or_mapping:!0,mp$ass_subscript(t,e){return void 0===e?this.mp$lookup(t)&&Sk.builtin.dict.prototype.mp$ass_subscript.call(this,t,e):Sk.builtin.dict.prototype.mp$ass_subscript.call(this,t,e)},tp$as_number:!0,nb$positive:counterNumberSlot((function(t){this.$items().forEach((([e,i])=>{Sk.misceval.richCompareBool(i,this.$zero,\"Gt\")&&t.mp$ass_subscript(e,i)}))})),nb$negative:counterNumberSlot((function(t){this.$items().forEach((([e,i])=>{Sk.misceval.richCompareBool(i,this.$zero,\"Lt\")&&t.mp$ass_subscript(e,Sk.abstr.numberBinOp(this.$zero,i,\"Sub\"))}))})),nb$subtract:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=Sk.abstr.numberBinOp(s,e.mp$subscript(i),\"Sub\");Sk.misceval.richCompareBool(n,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,n)})),e.$items().forEach((([e,i])=>{void 0===this.mp$lookup(e)&&Sk.misceval.richCompareBool(i,this.$zero,\"Lt\")&&t.mp$ass_subscript(e,Sk.abstr.numberBinOp(this.$zero,i,\"Sub\"))}))})),nb$add:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=Sk.abstr.numberBinOp(s,e.mp$subscript(i),\"Add\");Sk.misceval.richCompareBool(n,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,n)})),e.$items().forEach((([e,i])=>{void 0===this.mp$lookup(e)&&Sk.misceval.richCompareBool(i,this.$zero,\"Gt\")&&t.mp$ass_subscript(e,i)}))})),nb$inplace_add:counterInplaceSlot(\"+\",(function(t){t.$items().forEach((([t,e])=>{const i=Sk.abstr.numberInplaceBinOp(this.mp$subscript(t),e,\"Add\");this.mp$ass_subscript(t,i)}))})),nb$inplace_subtract:counterInplaceSlot(\"-\",(function(t){t.$items().forEach((([t,e])=>{const i=Sk.abstr.numberInplaceBinOp(this.mp$subscript(t),e,\"Sub\");this.mp$ass_subscript(t,i)}))})),nb$or:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=e.mp$subscript(i),r=Sk.misceval.richCompareBool(s,n,\"Lt\")?n:s;Sk.misceval.richCompareBool(r,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,r)})),e.$items().forEach((([e,i])=>{void 0===this.mp$lookup(e)&&Sk.misceval.richCompareBool(i,this.$zero,\"Gt\")&&t.mp$ass_subscript(e,i)}))})),nb$and:counterNumberSlot((function(t,e){this.$items().forEach((([i,s])=>{const n=e.mp$subscript(i),r=Sk.misceval.richCompareBool(s,n,\"Lt\")?s:n;Sk.misceval.richCompareBool(r,this.$zero,\"Gt\")&&t.mp$ass_subscript(i,r)}))})),nb$inplace_and:counterInplaceSlot(\"&\",(function(t){this.$items().forEach((([e,i])=>{const s=t.mp$subscript(e);Sk.misceval.richCompareBool(s,i,\"Lt\")&&this.mp$ass_subscript(e,s)}))})),nb$inplace_or:counterInplaceSlot(\"|\",(function(t){t.$items().forEach((([t,e])=>{Sk.misceval.richCompareBool(e,this.mp$subscript(t),\"Gt\")&&this.mp$ass_subscript(t,e)}))})),nb$reflected_and:null,nb$reflected_or:null,nb$reflected_add:null,nb$reflected_subtract:null},proto:{keep$positive(){return this.$items().forEach((([t,e])=>{Sk.misceval.richCompareBool(e,this.$zero,\"LtE\")&&this.mp$ass_subscript(t)})),this},$zero:new Sk.builtin.int_(0),$one:new Sk.builtin.int_(1),str$items:new Sk.builtin.str(\"items\"),counter$update(t,e){const i=t[0];if(void 0!==i)if(Sk.builtin.checkMapping(i))if(this.sq$length())for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,i.mp$subscript(n),\"Add\"))}else this.update$common(t,void 0,\"update\");else for(let s=Sk.abstr.iter(i),n=s.tp$iternext();void 0!==n;n=s.tp$iternext()){const t=this.mp$subscript(n);this.mp$ass_subscript(n,Sk.abstr.numberBinOp(t,this.$one,\"Add\"))}if(e&&e.length)if(this.sq$length())for(let s=0;s<e.length;s+=2){const t=new Sk.builtin.str(e[s]),i=this.mp$subscript(t);this.mp$ass_subscript(t,Sk.abstr.numberBinOp(i,e[s+1],\"Add\"))}else this.update$common([],e,\"update\");return Sk.builtin.none.none$}},classmethods:{fromkeys:{$meth:function fromkeys(){throw new Sk.builtin.NotImplementedError(\"Counter.fromkeys() is undefined.  Use Counter(iterable) instead.\")},$flags:{MinArgs:1,MaxArgs:2}}}}),t.OrderedDict=Sk.abstr.buildNativeClass(\"collections.OrderedDict\",{constructor:function OrderedDict(){Sk.builtin.dict.call(this)},base:Sk.builtin.dict,slots:{tp$doc:\"Dictionary that remembers insertion order\",$r(){if(this.in$repr)return new Sk.builtin.str(\"...\");this.in$repr=!0;let t=this.$items().map((([t,e])=>`(${Sk.misceval.objectRepr(t)}, ${Sk.misceval.objectRepr(e)})`));return t=0===t.length?\"\":\"[\"+t.join(\", \")+\"]\",this.in$repr=!1,new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+\")\")},tp$richcompare(e,i){if(\"Eq\"!==i&&\"Ne\"!==i)return Sk.builtin.NotImplemented.NotImplemented$;if(!(e instanceof t.OrderedDict))return Sk.builtin.dict.prototype.tp$richcompare.call(this,e,i);const s=\"Eq\"==i,n=this.size;if(n!==e.size)return!s;const r=e.$items(),a=this.$items();for(let t=0;t<n;t++){const e=a[t],i=r[t],n=e[0],o=i[0];if(n!==o&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(n,o,\"Eq\")))return!s;const l=e[1],h=i[1];if(l!==h&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(l,h,\"Eq\")))return!s}return s}},methods:{popitem:{$flags:{NamedArgs:[\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(t){const e=this.get$size();if(0===e)throw new Sk.builtin.KeyError(\"dictionary is empty\");const[i,s]=this.$items()[Sk.misceval.isTrue(t)?e-1:0];return this.pop$item(i),new Sk.builtin.tuple([i,s])}},move_to_end:{$flags:{NamedArgs:[\"key\",\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(t,e){let i;for(let n in this.entries){const e=this.entries[n][0];if(e===t||Sk.misceval.richCompareBool(e,t,\"Eq\")){i=n;break}}if(void 0===i)throw new Sk.builtin.KeyError(t);const s=this.entries[i];return delete this.entries[i],Sk.misceval.isTrue(e)?this.entries[i]=s:this.entries={[i]:s,...this.entries},Sk.builtin.none.none$}}}}),t.deque=Sk.abstr.buildNativeClass(\"collections.deque\",{constructor:function deque(t,e,i,s,n){this.head=i||0,this.tail=s||0,this.mask=n||1,this.maxlen=e,this.v=t||new Array(2)},slots:{tp$doc:\"deque([iterable[, maxlen]]) --\\x3e deque object\\n\\nA list-like sequence optimized for data accesses near its endpoints.\",tp$hash:Sk.builtin.none.none$,tp$new:Sk.generic.new,tp$init(t,e){let[i,s]=Sk.abstr.copyKeywordsToNamedArgs(\"deque\",[\"iterable\",\"maxlen\"],t,e);if(void 0!==s&&!Sk.builtin.checkNone(s)){if(s=Sk.misceval.asIndexSized(s,Sk.builtin.OverflowError,\"an integer is required\"),s<0)throw new Sk.builtin.ValueError(\"maxlen must be non-negative\");this.maxlen=s}this.$clear(),void 0!==i&&this.$extend(i)},tp$getattr:Sk.generic.getAttr,tp$richcompare(e,i){if(this===e&&Sk.misceval.opAllowsEquality(i))return!0;if(!(e instanceof t.deque))return Sk.builtin.NotImplemented.NotImplemented$;const s=e,n=this.v;e=e.v;const r=this.tail-this.head&this.mask,a=s.tail-s.head&s.mask;let o,l=Math.max(r,a);if(r===a)for(l=0;l<r&&l<a&&(o=Sk.misceval.richCompareBool(n[this.head+l&this.mask],e[s.head+l&s.mask],\"Eq\"),o);++l);if(l>=r||l>=a)switch(i){case\"Lt\":return r<a;case\"LtE\":return r<=a;case\"Eq\":return r===a;case\"NotEq\":return r!==a;case\"Gt\":return r>a;case\"GtE\":return r>=a}return\"Eq\"!==i&&(\"NotEq\"===i||Sk.misceval.richCompareBool(n[this.head+l&this.mask],e[s.head+l&s.mask],i))},tp$iter(){return new e(this)},$r(){const t=[],e=this.tail-this.head&this.mask;if(this.$entered_repr)return new Sk.builtin.str(\"[...]\");this.$entered_repr=!0;for(let s=0;s<e;s++)t.push(Sk.misceval.objectRepr(this.v[this.head+s&this.mask]));const i=Sk.abstr.typeName(this);return void 0!==this.maxlen?new Sk.builtin.str(i+\"([\"+t.filter(Boolean).join(\", \")+\"], maxlen=\"+this.maxlen+\")\"):(this.$entered_repr=void 0,new Sk.builtin.str(i+\"([\"+t.filter(Boolean).join(\", \")+\"])\"))},tp$as_number:!0,nb$bool(){return 0!=(this.tail-this.head&this.mask)},tp$as_sequence_or_mapping:!0,sq$contains(t){for(let e=this.tp$iter(),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())if(Sk.misceval.richCompareBool(i,t,\"Eq\"))return!0;return!1},sq$concat(e){if(!(e instanceof t.deque))throw new Sk.builtin.TypeError(\"can only concatenate deque (not '\"+Sk.abstr.typeName(e)+\"') to deque\");const i=this.$copy();for(let t=e.tp$iter(),s=t.tp$iternext();void 0!==s;s=t.tp$iternext())i.$push(s);return i},sq$length(){return this.tail-this.head&this.mask},sq$repeat(t){t=Sk.misceval.asIndexOrThrow(t,\"can't multiply sequence by non-int of type '{tp$name}'\");const e=this.tail-this.head&this.mask,i=this.$copy();let s;t<=0&&i.$clear();for(let n=1;n<t;n++)for(let t=0;t<e;t++)s=this.head+t&this.mask,i.$push(this.v[s]);return i},mp$subscript(t){t=Sk.misceval.asIndexOrThrow(t);const e=this.tail-this.head&this.mask;if(t>=e||t<-e)throw new Sk.builtin.IndexError(\"deque index out of range\");const i=(t>=0?this.head:this.tail)+t&this.mask;return this.v[i]},mp$ass_subscript(t,e){t=Sk.misceval.asIndexOrThrow(t);const i=this.tail-this.head&this.mask;if(t>=i||t<-i)throw new Sk.builtin.IndexError(\"deque index out of range\");void 0===e?this.del$item(t):this.set$item(t,e)},nb$inplace_add(t){this.maxlen=void 0;for(let e=Sk.abstr.iter(t),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())this.$push(i);return this},nb$inplace_multiply(t){(t=Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError,\"can't multiply sequence by non-int of type '{tp$name}'\"))<=0&&this.$clear();const e=this.$copy(),i=this.tail-this.head&this.mask;for(let s=1;s<t;s++)for(let t=0;t<i;t++){const i=this.head+t&this.mask;e.$push(this.v[i])}return this.v=e.v,this.head=e.head,this.tail=e.tail,this.mask=e.mask,this}},methods:{append:{$meth(t){return this.$push(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the right side of the deque.\"},appendleft:{$meth(t){return this.$pushLeft(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the left side of the deque.\"},clear:{$meth(){return this.$clear(),Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove all elements from the deque.\"},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},count:{$meth(t){const e=this.tail-this.head&this.mask;let i=0;for(let s=0;s<e;s++)Sk.misceval.richCompareBool(this.v[this.head+s&this.mask],t,\"Eq\")&&i++;return new Sk.builtin.int_(i)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.count(value) -> integer -- return number of occurrences of value\"},extend:{$meth(t){return this.$extend(t),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the right side of the deque with elements from the iterable\"},extendleft:{$meth(t){for(let e=Sk.abstr.iter(t),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())this.$pushLeft(i);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the left side of the deque with elements from the iterable\"},index:{$meth(t,e,i){const s=this.$index(t,e,i);if(void 0!==s)return new Sk.builtin.int_(s);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(t)+\" is not in deque\")},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:\"D.index(value, [start, [stop]]) -> integer -- return first index of value.\\nRaises ValueError if the value is not present.\"},insert:{$meth(t,e){t=Sk.misceval.asIndexOrThrow(t,\"integer argument expected, got {tp$name}\");const i=this.tail-this.head&this.mask;if(void 0!==this.maxlen&&i>=this.maxlen)throw new Sk.builtin.IndexError(\"deque already at its maximum size\");t>i&&(t=i),t<=-i&&(t=0);const s=(t>=0?this.head:this.tail)+t&this.mask;let n=this.tail;for(this.tail=this.tail+1&this.mask;n!==s;){const t=n-1&this.mask;this.v[n]=this.v[t],n=t}return this.v[s]=e,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1),Sk.builtin.none.none$},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"D.insert(index, object) -- insert object before index\"},pop:{$meth(){return this.$pop()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the rightmost element.\"},popleft:{$meth(){return this.$popLeft()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the leftmost element.\"},remove:{$meth(t){const e=this.$index(t);if(void 0===e)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(t)+\" is not in deque\");let i=this.head+e&this.mask;for(;i!==this.tail;){const t=i+1&this.mask;this.v[i]=this.v[t],i=t}this.tail=this.tail-1&this.mask;var s=this.tail-this.head&this.mask;s<this.mask>>>1&&this.$resize(s,this.v.length>>>1)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.remove(value) -- remove first occurrence of value.\"},__reversed__:{$meth(){return new i(this)},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.__reversed__() -- return a reverse iterator over the deque\"},reverse:{$meth(){const t=this.head,e=this.tail,i=this.mask,s=this.tail-this.head&this.mask;for(let n=0;n<~~(s/2);n++){const s=e-n-1&i,r=t+n&i,a=this.v[s];this.v[s]=this.v[r],this.v[r]=a}return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.reverse() -- reverse *IN PLACE*\"},rotate:{$meth(t){t=void 0===t?1:Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError);const e=this.head,i=this.tail;if(0===t||e===i)return this;if(this.head=e-t&this.mask,this.tail=i-t&this.mask,t>0)for(let s=1;s<=t;s++){const t=e-s&this.mask,n=i-s&this.mask;this.v[t]=this.v[n],this.v[n]=void 0}else for(let s=0;s>t;s--){const t=i-s&this.mask,n=e-s&this.mask;this.v[t]=this.v[n],this.v[n]=void 0}return Sk.builtin.none.none$},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:\"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.\"}},classmethods:Sk.generic.classGetItem,getsets:{maxlen:{$get(){return void 0===this.maxlen?Sk.builtin.none.none$:new Sk.builtin.int_(this.maxlen)},$doc:\"maximum size of a deque or None if unbounded\"}},proto:{$clear(){this.head=0,this.tail=0,this.mask=1,this.v=new Array(2)},$copy(){return new t.deque(this.v.slice(0),this.maxlen,this.head,this.tail,this.mask)},$extend(t){for(let e=Sk.abstr.iter(t),i=e.tp$iternext();void 0!==i;i=e.tp$iternext())this.$push(i)},set$item(t,e){const i=(t>=0?this.head:this.tail)+t&this.mask;this.v[i]=e},del$item(t){let e=(t>=0?this.head:this.tail)+t&this.mask;for(;e!==this.tail;){const t=e+1&this.mask;this.v[e]=this.v[t],e=t}const i=this.tail-this.head&this.mask;this.tail=this.tail-1&this.mask,i<this.mask>>>1&&this.$resize(i,this.v.length>>>1)},$push(t){this.v[this.tail]=t,this.tail=this.tail+1&this.mask,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);const e=this.tail-this.head&this.mask;return void 0!==this.maxlen&&e>this.maxlen&&this.$popLeft(),this},$pushLeft(t){this.head=this.head-1&this.mask,this.v[this.head]=t,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);const e=this.tail-this.head&this.mask;return void 0!==this.maxlen&&e>this.maxlen&&this.$pop(),this},$pop(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");this.tail=this.tail-1&this.mask;const t=this.v[this.tail];this.v[this.tail]=void 0;const e=this.tail-this.head&this.mask;return e<this.mask>>>1&&this.$resize(e,this.v.length>>>1),t},$popLeft(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");const t=this.v[this.head];this.v[this.head]=void 0,this.head=this.head+1&this.mask;const e=this.tail-this.head&this.mask;return e<this.mask>>>1&&this.$resize(e,this.v.length>>>1),t},$resize(t,e){const i=this.head,s=this.mask;if(this.head=0,this.tail=t,this.mask=e-1,0===i)return void(this.v.length=e);const n=new Array(e);for(let r=0;r<t;r++)n[r]=this.v[i+r&s];this.v=n},$index(t,e,i){const s=this.tail-this.head&this.mask;e=void 0===e?0:Sk.misceval.asIndexOrThrow(e),i=void 0===i?s:Sk.misceval.asIndexOrThrow(i);const n=this.head,r=this.mask,a=this.v;i=i>=0?i:i<-s?0:s+i;for(let o=e>=0?e:e<-s?0:s+e;o<i;o++)if(a[n+o&r]===t)return o},sk$asarray(){const t=[],e=this.tail-this.head&this.mask;for(let i=0;i<e;++i){const e=this.head+i&this.mask;t.push(this.v[e])}return t}}});const e=Sk.abstr.buildIteratorClass(\"_collections._deque_iterator\",{constructor:function _deque_iterator(t){this.$index=0,this.dq=t.v,this.$length=t.tail-t.head&t.mask,this.$head=t.head,this.$tail=t.tail,this.$mask=t.mask},iternext(){if(this.$index>=this.$length)return;const t=(this.$index>=0?this.$head:this.$tail)+this.$index&this.$mask;return this.$index++,this.dq[t]},methods:{__length_hint__:{$meth:function __length_hint__(){return new Sk.builtin.int_(this.$length-this.$index)},$flags:{NoArgs:!0}}}}),i=Sk.abstr.buildIteratorClass(\"_collections._deque_reverse_iterator\",{constructor:function _deque_reverse_iterator(t){this.$index=(t.tail-t.head&t.mask)-1,this.dq=t.v,this.$head=t.head,this.$mask=t.mask},iternext(){if(this.$index<0)return;const t=this.$head+this.$index&this.$mask;return this.$index--,this.dq[t]},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef}}),s=new RegExp(/^[0-9].*/),n=new RegExp(/^[0-9_].*/),r=new RegExp(/^\\w*$/),a=/,/g,o=/\\s+/;function namedtuple(e,i,l,h,c){if(e=e.tp$str(),Sk.misceval.isTrue(Sk.misceval.callsimArray(t._iskeyword,[e])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+Sk.misceval.objectRepr(e)+\"'\");const u=e.$jsstr();if(s.test(u)||!r.test(u)||!u)throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+u+\"'\");let m,d;if(Sk.builtin.checkString(i))m=i.$jsstr().replace(a,\" \").split(o),1==m.length&&\"\"===m[0]&&(m=[]),d=m.map((t=>new Sk.builtin.str(t)));else{m=[],d=[];for(let t=Sk.abstr.iter(i),e=t.tp$iternext();void 0!==e;e=t.tp$iternext())e=e.tp$str(),d.push(e),m.push(e.$jsstr())}let p=new Set;if(Sk.misceval.isTrue(l))for(let s=0;s<m.length;s++)(Sk.misceval.isTrue(Sk.misceval.callsimArray(t._iskeyword,[d[s]]))||n.test(m[s])||!r.test(m[s])||!m[s]||p.has(m[s]))&&(m[s]=\"_\"+s,d[s]=new Sk.builtin.str(\"_\"+s)),p.add(m[s]);else for(let s=0;s<m.length;s++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(t._iskeyword,[d[s]])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+m[s]+\"'\");if(n.test(m[s]))throw new Sk.builtin.ValueError(\"Field names cannot start with an underscore: '\"+m[s]+\"'\");if(!r.test(m[s])||!m[s])throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+m[s]+\"'\");if(p.has(m[s]))throw new Sk.builtin.ValueError(\"Encountered duplicate field name: '\"+m[s]+\"'\");p.add(m[s])}const $=new Sk.builtin.tuple(d),k=[];let b=[];if(!Sk.builtin.checkNone(h)){if(b=Sk.misceval.arrayFromIterable(h),b.length>m.length)throw new Sk.builtin.TypeError(\"Got more default values than field names\");for(let t=0,e=d.length-b.length;e<d.length;t++,e++)k.push(d[e]),k.push(b[t])}const f=new Sk.builtin.dict(k);function _make(t,e){return t.prototype.tp$new(Sk.misceval.arrayFromIterable(e))}function _asdict(t){const e=[];for(let i=0;i<t._fields.v.length;i++)e.push(t._fields.v[i]),e.push(t.v[i]);return new Sk.builtin.dict(e)}function _replace(t,e){const i=(t=new Sk.builtin.dict(t)).tp$getattr(new Sk.builtin.str(\"pop\")),s=Sk.abstr.gattr(e,new Sk.builtin.str(\"_make\")),n=Sk.misceval.callsimArray,r=n(s,[n(Sk.builtin.map_,[i,$,e])]);if(t.sq$length()){const e=t.sk$asarray();throw new Sk.builtin.ValueError(\"Got unexpectd field names: [\"+e.map((t=>\"'\"+t.$jsstr()+\"'\"))+\"]\")}return r}_make.co_varnames=[\"_cls\",\"iterable\"],_asdict.co_varnames=[\"self\"],_replace.co_kwargs=1,_replace.co_varnames=[\"_self\"];const S={};for(let s=0;s<m.length;s++)S[d[s].$mangled]=new Sk.builtin.property(new t._itemgetter([new Sk.builtin.int_(s)]),void 0,void 0,new Sk.builtin.str(\"Alias for field number \"+s));return Sk.abstr.buildNativeClass(u,{constructor:function NamedTuple(){},base:Sk.builtin.tuple,slots:{tp$doc:u+\"(\"+m.join(\", \")+\")\",tp$new(t,e){t=Sk.abstr.copyKeywordsToNamedArgs(\"__new__\",m,t,e,b);const i=new this.constructor;return Sk.builtin.tuple.call(i,t),i},$r(){const t=this.v.map(((t,e)=>m[e]+\"=\"+Sk.misceval.objectRepr(t)));return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t.join(\", \")+\")\")}},flags:{sk$klass:!0},proto:Object.assign({__module__:Sk.builtin.checkNone(c)?Sk.globals.__name__:c,__slots__:new Sk.builtin.tuple,_fields:$,_field_defaults:f,_make:new Sk.builtin.classmethod(new Sk.builtin.func(_make)),_asdict:new Sk.builtin.func(_asdict),_replace:new Sk.builtin.func(_replace)},S)})}return namedtuple.co_argcount=2,namedtuple.co_kwonlyargcount=3,namedtuple.$kwdefs=[Sk.builtin.bool.false$,Sk.builtin.none.none$,Sk.builtin.none.none$],namedtuple.co_varnames=[\"typename\",\"field_names\",\"rename\",\"defaults\",\"module\"],t.namedtuple=new Sk.builtin.func(namedtuple),t}","src/lib/datetime.js":"function $builtinmodule(){const{isTrue:t,richCompareBool:e,asIndexOrThrow:n,asIndexSized:i,objectRepr:s,opAllowsEquality:o,callsimArray:r,callsimOrSuspendArray:a}=Sk.misceval,{numberBinOp:$,typeName:c,buildNativeClass:h,checkArgsLen:m,objectHash:u,copyKeywordsToNamedArgs:l}=Sk.abstr,{int_:f,float_:d,str:w,bytes:_,tuple:p,bool:{true$:g},none:{none$:y},NotImplemented:{NotImplemented$:b},TypeError:z,ValueError:v,OverflowError:M,ZeroDivisionError:A,NotImplementedError:x,checkNumber:N,checkFloat:S,checkString:k,checkInt:O,asnum$:I,round:E,getattr:T}=Sk.builtin,{remapToPy:D,remapToJs:R}=Sk.ffi,intRound=t=>E(t).nb$int(),q=$,C=new w(\"auto\"),U=new w(\"utcoffset\"),Y=new w(\"tzname\"),j=new w(\"as_integer_ratio\"),F=new w(\"dst\"),H=new w(\"isoformat\"),J=new w(\"replace\"),B=new w(\"fromtimestamp\"),G=new w(\"fromordinal\"),L=new w(\"utcfromtimestamp\"),X=new w(\"strftime\"),P=new w(\"fromutc\"),W=new f(0),Z=new d(0),K=new f(7),V=new f(60),Q=new f(3600),tt=new f(1e3),et=new f(1e6),nt=new d(1e6),it=new f(86400),st=new d(86400);let ot=null;function pyDivMod(t,e){return q(t,e,\"DivMod\").v}function $divMod(t,e){if(\"number\"!=typeof t||\"number\"!=typeof e)return t=JSBI.BigInt(t),e=JSBI.BigInt(e),[JSBI.toNumber(JSBI.divide(t,e)),JSBI.toNumber(JSBI.remainder(t,e))];if(0===e)throw new A(\"integer division or modulo by zero\");return[Math.floor(t/e),t-Math.floor(t/e)*e]}function modf(t){const e=(t=I(t))<0?-1:1;return t=Math.abs(t),[new d(e*(t-Math.floor(t))),new d(e*Math.floor(t))]}function _d(t,e=\"0\",n=2){return t.toString().padStart(n,e)}const rt=/^[0-9]+$/;function _as_integer(t){if(!rt.test(t))throw new Error;return parseInt(t)}function _as_int_ratio(t){let e=r(t.tp$getattr(j));if(!(e instanceof p))throw new z(\"unexpected return type from as_integer_ratio(): expected tuple, got '\"+c(e)+\"'\");if(e=e.v,2!==e.length)throw new v(\"as_integer_ratio() must return a 2-tuple\");return e}return Sk.misceval.chain(Sk.importModule(\"time\",!1,!0),(a=>{const $=a.$d,E={__name__:new w(\"datetime\"),__all__:new Sk.builtin.list([\"date\",\"datetime\",\"time\",\"timedelta\",\"timezone\",\"tzinfo\",\"MINYEAR\",\"MAXYEAR\"].map((t=>new w(t))))};function _cmp(t,e){for(let n=0;n<t.length;n++)if(t[n]!==e[n])return t[n]>e[n]?1:-1;return 0}function _do_compare(t,e,n){const i=t.$cmp(e,n);switch(n){case\"Lt\":return i<0;case\"LtE\":return i<=0;case\"Eq\":return 0===i;case\"NotEq\":return 0!==i;case\"Gt\":return i>0;case\"GtE\":return i>=0}}const j=9999;E.MINYEAR=new f(1),E.MAXYEAR=new f(j);const rt=3652059,at=[-1,31,28,31,30,31,30,31,31,30,31,30,31],$t=[-1];let ct=0;function _is_leap(t){return t%4==0&&(t%100!=0||t%400==0)}function _days_before_year(t){const e=t-1;return 365*e+Math.floor(e/4)-Math.floor(e/100)+Math.floor(e/400)}function _days_before_month(t,e){return $t[e]+(e>2&&_is_leap(t))}function _ymd2ord(t,e,n){return _days_before_year(t)+_days_before_month(t,e)+n}at.slice(1).forEach((t=>{$t.push(ct),ct+=t}));const ht=_days_before_year(401),mt=_days_before_year(101),ut=_days_before_year(5);function _ord2ymd(t){if((t=n(t))>Number.MAX_SAFE_INTEGER)throw new M(\"Python int too large to convert to js number\");if(t<1)throw new v(\"ordinal must be >= 1\");let e,i,s,o;t-=1,[e,t]=$divMod(t,ht);let r=400*e+1;if([i,t]=$divMod(t,mt),[s,t]=$divMod(t,ut),[o,t]=$divMod(t,365),r+=100*i+4*s+o,4===o||4===i)return[r-1,12,31].map((t=>new f(t)));const a=3===o&&(24!==s||3===i);let $=t+50>>5,c=$t[$]+($>2&&a);return c>t&&($-=1,c-=at[$]+(2===$&&a)),[r,$,(t-=c)+1].map((t=>new f(t)))}const lt=[null,\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],ft=[null,\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"];function _build_struct_time(t,e,n,i,s,o,r){const a=(_ymd2ord(t,e,n)+6)%7,c=_days_before_month(t,e)+n;return $.struct_time.tp$call([new p([t,e,n,i,s,o,a,c,r].map((t=>new f(t))))])}const dt={hours:t=>_d(t),minutes:(t,e)=>_d(t)+\":\"+_d(e),seconds:(t,e,n)=>_d(t)+\":\"+_d(e)+\":\"+_d(n),milliseconds:(t,e,n,i)=>_d(t)+\":\"+_d(e)+\":\"+_d(n)+\".\"+_d(i,\"0\",3),microseconds:(t,e,n,i)=>_d(t)+\":\"+_d(e)+\":\"+_d(n)+\".\"+_d(i,\"0\",6)};function _format_time(t,e,n,i,s=\"auto\"){if(\"string\"!=typeof s&&!k(s))throw new z(\"must be str, not \"+c(s));\"auto\"===(s=s.toString())?s=i?\"microseconds\":\"seconds\":\"milliseconds\"===s&&(i=Math.floor(i/1e3));let o=dt[s];if(void 0===o)throw new v(\"Unknown timespec value\");return o(t,e,n,i)}function _format_offset(t){let e,n=\"\";if(t!==y){let i,s,o;return t.$days<0?(e=\"-\",t=new wt(-t.$days,-t.$secs,-t.$micro)):e=\"+\",[i,s]=pyDivMod(t,pt),[s,o]=pyDivMod(s,gt),n+=e+`${_d(i)}:${_d(s)}`,(o.$secs||o.$micro)&&(n+=\":\"+_d(o.$secs,\"0\",2),o.$micro&&(n+=\".\"+_d(o.$micro,\"0\",6))),n}}function _wrap_strftime(t,e,n){let i=null,s=null,o=null,a=[],c=0;const h=e.length;for(;c<h;){let n=e[c];if(c+=1,\"%\"===n)if(c<h)if(n=e[c],c+=1,\"f\"===n)null===i&&(i=_d(t.$micro||0,\"0\",6)),a.push(i);else if(\"z\"===n){if(null===s){s=\"\";const e=t.tp$getattr(U);if(void 0!==e){let t=r(e);if(t!==y){let e,n,i,o=\"+\";t.$days<0&&(t=new wt(-t.$days,-t.$secs,-t.$micro),o=\"-\"),[e,i]=pyDivMod(t,pt),[n,i]=pyDivMod(i,gt);const r=i.$secs,a=t.$micro;s=a?o+_d(e)+_d(n)+_d(r)+\".\"+_d(a,\"0\",6):r?o+_d(e)+_d(n)+_d(r):o+_d(e)+_d(n)}}}a.push(s)}else if(\"Z\"===n){if(null===o){o=\"\";const e=t.tp$getattr(Y);if(void 0!==e){let t=r(e);if(t!==y){const e=t.tp$getattr(J);if(o=r(e,[new w(\"%\"),new w(\"%%\")]),!k(o))throw new z(\"tzname.replace() did not return a string\")}}}a.push(o)}else a.push(\"%\",n);else a.push(\"%\");else a.push(n)}return a=a.join(\"\"),$.strftime.tp$call([new w(a),n])}function _parse_isoformat_date(t){const e=_as_integer(t.slice(0,4));if(\"-\"!==t[4])throw new v(\"Invalid date separator: \"+t[4]);const n=_as_integer(t.slice(5,7));if(\"-\"!==t[7])throw new v(\"Invalid date separator: \"+t[7]);return[e,n,_as_integer(t.slice(8,10))].map((t=>new f(t)))}function _parse_hh_mm_ss_ff(t){const e=t.length,n=[0,0,0,0];let i=0;for(let s=0;s<3;s++){if(e-i<2)throw new v(\"Incomplete time component\");n[s]=_as_integer(t.slice(i,i+2)),i+=2;const o=t.substr(i,1);if(!o||s>=2)break;if(\":\"!==o)throw new v(\"Invalid time separator: \"+o);i+=1}if(i<e){if(\".\"!==t[i])throw new v(\"Invalid microsecond component\");{i+=1;const s=e-i;if(3!==s&&6!==s)throw new v(\"Invalid microsecond component\");n[3]=_as_integer(t.slice(i)),3===s&&(n[3]*=1e3)}}return n}function _parse_isoformat_time(t){if(t.length<2)throw new v(\"Isoformat time too short\");const e=t.indexOf(\"-\")+1||t.indexOf(\"+\")+1;let n,i=_parse_hh_mm_ss_ff(e>0?t.slice(0,e-1):t),s=y;if(e>0){if(n=t.slice(e),![5,8,15].includes(n.length))throw new v(\"Malformed time zone string\");const i=_parse_hh_mm_ss_ff(n);if(i.every((t=>0===t)))s=St.prototype.utc;else{const n=\"-\"===t[e-1]?-1:1,o=new wt(0,n*(3600*i[0]+60*i[1]+i[2]),n*i[3]);s=new St(o)}}return i=i.map((t=>new f(t))),i.push(s),i}function _check_tzname(t){if(t!==y&&!k(t))throw new z(\"tzinfo.tzname() must return None or string, not '\"+c(t)+\"'\")}function _check_utc_offset(t,n){if(n!==y){if(!(n instanceof wt))throw new z(`tzinfo.${t}() must return None or timedelta, not '${c(n)}'`);if(!e(zt,n,\"Lt\")||!e(n,_t,\"Lt\"))throw new v(`${t}()=${n.toString()}, must be strictly between -timedelta(hours=24) and timedelta(hours=24)`)}}function _check_date_fields(t,e=null,i=null){if(null===e||null===i){throw new z(`function missing required argument '${null===i?\"day\":\"month\"}' (pos ${null===i?\"3\":\"2\"})`)}if(t=n(t),e=n(e),i=n(i),!(1<=t&&t<=j))throw new v(\"year must be in 1..\"+j,new f(t));if(!(1<=e&&e<=12))throw new v(\"month must be in 1..12\",new f(e));const s=function _days_in_month(t,e){return 2===e&&_is_leap(t)?29:at[e]}(t,e);if(!(1<=i&&i<=s))throw new v(\"day must be in 1..\"+s,new f(i));return[t,e,i]}function _check_time_fields(t,e,i,s,o){if(t=n(t),e=n(e),i=n(i),s=n(s),o=n(o),!(0<=t&&t<=23))throw new v(\"hour must be in 0..23\",new f(t));if(!(0<=e&&e<=59))throw new v(\"minute must be in 0..59\",new f(e));if(!(0<=i&&i<=59))throw new v(\"second must be in 0..59\",new f(i));if(!(0<=s&&s<=999999))throw new v(\"microsecond must be in 0..999999\",new f(s));if(0!==o&&1!==o)throw new v(\"fold must be either 0 or 1\",new f(o));return[t,e,i,s,o]}function _check_tzinfo_arg(t){if(t!==y&&!(t instanceof Mt))throw new z(\"tzinfo argument must be None or of a tzinfo subclass\")}function _divide_and_round(t,e){let[n,i]=$divMod(t,e);return i*=2,((e>0?i>e:i<e)||i===e&&Math.abs(n)%2==1)&&(n+=1),n}const wt=E.timedelta=h(\"datetime.timedelta\",{constructor:function timedelta(t=0,e=0,n=0){let i,s;if([i,n]=$divMod(n,1e6),e+=i,[s,e]=$divMod(e,86400),t+=s,this.$days=t,this.$secs=e,this.$micro=n,this.$hashcode=-1,Math.abs(t)>999999999)throw new M(`days=${t}; must have magnitude <= 999999999`)},slots:{tp$new(t,e){let i,s,o,r,a,$,c,[h,m,u,d,w,_,p]=l(\"timedelta\",[\"days\",\"seconds\",\"microseconds\",\"milliseconds\",\"minutes\",\"hours\",\"weeks\"],t,e,new Array(7).fill(W));i=s=o=W,h=q(h,q(p,K,\"Mult\"),\"Add\"),m=q(m,q(q(w,V,\"Mult\"),q(_,Q,\"Mult\"),\"Add\"),\"Add\"),u=q(u,q(d,tt,\"Mult\"),\"Add\"),S(h)?([r,h]=modf(h),[a,$]=modf(q(r,st,\"Mult\")),s=new f($),i=new f(h)):(a=Z,i=h),S(m)?([c,m]=modf(m),m=new f(m),c=q(c,a,\"Add\")):c=a,[h,m]=pyDivMod(m,it),i=q(i,h,\"Add\"),s=q(s,new f(m),\"Add\");const g=q(c,nt,\"Mult\");if(S(u)?(u=intRound(q(u,g,\"Add\")),[m,u]=pyDivMod(u,et),[h,m]=pyDivMod(m,it),i=q(i,h,\"Add\"),s=q(s,m,\"Add\")):(u=new f(u),[m,u]=pyDivMod(u,et),[h,m]=pyDivMod(m,it),i=q(i,h,\"Add\"),s=q(s,m,\"Add\"),u=intRound(q(u,g,\"Add\"))),[m,o]=pyDivMod(u,et),s=q(s,m,\"Add\"),[h,s]=pyDivMod(s,it),i=q(i,h,\"Add\"),i=n(i),s=n(s),o=n(o),Math.abs(i)>999999999)throw new M(\"timedelta # of days is too large: \"+h.toString());if(this===wt.prototype)return new wt(i,s,o);{const t=new this.constructor;return wt.call(t,i,s,o),t}},$r(){const t=[];return this.$days&&t.push(`days=${this.$days}`),this.$secs&&t.push(`seconds=${this.$secs}`),this.$micro&&t.push(`microseconds=${this.$micro}`),t.length||t.push(\"0\"),new w(`${this.tp$name}(${t.join(\", \")})`)},tp$str(){const t=this.$secs%60;let e=Math.floor(this.$secs/60);const n=Math.floor(e/60);e%=60;let i=`${n}:${_d(e)}:${_d(t)}`;if(this.$days){i=`${this.$days} day${function plural(t){return 1!==Math.abs(t)?\"s\":\"\"}(this.$days)}, `+i}return this.$micro&&(i+=`.${_d(this.$micro,\"0\",6)}`),new w(i)},tp$as_number:!0,nb$add(t){return t instanceof wt?new wt(this.$days+t.$days,this.$secs+t.$secs,this.$micro+t.$micro):b},nb$subtract(t){return t instanceof wt?new wt(this.$days-t.$days,this.$secs-t.$secs,this.$micro-t.$micro):b},nb$positive(){return this},nb$negative(){return new wt(-this.$days,-this.$secs,-this.$micro)},nb$abs(){return this.$days<0?this.nb$negative():this},nb$multiply(t){if(O(t))return t=i(t,M),new wt(this.$days*t,this.$secs*t,this.$micro*t);if(S(t)){const e=this.$toMicrosecs();let[s,o]=_as_int_ratio(t);return s=i(s,M),o=n(o),new wt(0,0,_divide_and_round(e*s,o))}return b},nb$floor_divide(t){const e=this.$toMicrosecs();if(t instanceof wt){const n=t.$toMicrosecs();if(0===n)throw new A(\"integer division or modulo by zero\");return new f(Math.floor(e/n))}if(O(t)){if(0===(t=i(t,M)))throw new A(\"integer division or modulo by zero\");return new wt(0,0,Math.floor(e/t))}return b},nb$divide(t){const e=this.$toMicrosecs();if(t instanceof wt){if(0===t.$toMicrosecs())throw new A(\"integer division or modulo by zero\");return new d(e/t.$toMicrosecs())}if(O(t))return t=n(t),new wt(0,0,_divide_and_round(e,t));if(S(t)){let[s,o]=_as_int_ratio(t);return s=n(s),o=i(o,M),new wt(0,0,_divide_and_round(o*e,s))}return b},nb$remainder(t){if(!(t instanceof wt))return b;const e=this.$toMicrosecs(),n=t.$toMicrosecs();if(0===n)throw new A(\"integer division or modulo by zero\");const i=e-Math.floor(e/n)*n;return new wt(0,0,i)},nb$divmod(t){if(!(t instanceof wt))return b;const e=this.$toMicrosecs(),n=t.$toMicrosecs(),[i,s]=$divMod(e,n);return new p([new f(i),new wt(0,0,s)])},tp$richcompare(t,e){return t instanceof wt?_do_compare(this,t,e):b},tp$hash(){return-1===this.$hashcode&&(this.$hashcode=u(new p(this.$getState().map((t=>new f(t)))))),this.$hashcode},nb$bool(){return 0!==this.$days||0!==this.$secs||0!==this.$micro}},methods:{total_seconds:{$meth(){return new d(((86400*this.$days+this.$secs)*10**6+this.$micro)/10**6)},$flags:{NoArgs:!0},$doc:\"Total seconds in the duration.\"},__reduce__:{$meth(){return new p([this.ob$type,new p(this.$getState().map((t=>D(t))))])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},getsets:{days:{$get(){return new f(this.$days)},$doc:\"Number of days.\"},seconds:{$get(){return new f(this.$secs)},$doc:\"Number of seconds (>= 0 and less than 1 day).\"},microseconds:{$get(){return new f(this.$micro)},$doc:\"Number of microseconds (>= 0 and less than 1 second).\"}},proto:{$toMicrosecs(){return 1e6*(86400*this.$days+this.$secs)+this.$micro},$cmp(t){return _cmp(this.$getState(),t.$getState())},$getState(){return[this.$days,this.$secs,this.$micro]}}});wt.prototype.min=new wt(-999999999),wt.prototype.max=new wt(999999999,86399,999999),wt.prototype.resolution=new wt(0,0,1);const _t=new wt(1),pt=new wt(0,3600),gt=new wt(0,60),yt=new wt(0,1),bt=new wt(0),zt=new wt(-1),vt=E.date=h(\"datetime.date\",{constructor:function date(t,e,n){this.$year=t,this.$month=e,this.$day=n,this.$hashcode=-1},slots:{tp$new(t,e){let n,[i,s,o]=l(\"date\",[\"year\",\"month\",\"day\"],t,e,[null,null]);if(null===s&&i instanceof _&&4===(n=i.valueOf()).length&&1<=n[2]&&n[2]<=12){const t=new this.constructor;return t.$setState(n),t}if([i,s,o]=_check_date_fields(i,s,o),this===vt.prototype)return new vt(i,s,o);{const t=new this.constructor;return vt.call(t,i,s,o),t}},$r(){return new w(`${this.tp$name}(${this.$year}, ${this.$month}, ${this.$day})`)},tp$str(){return this.tp$getattr(H).tp$call([])},tp$richcompare(t,e){return t instanceof vt?_do_compare(this,t,e):b},tp$hash(){return-1===this.$hashcode&&(this.$hashcode=u(this.$getState())),this.$hashcode},tp$as_number:!0,nb$add(t){if(t instanceof wt){const e=this.$toOrdinal()+t.$days;if(0<e&&e<=rt)return this.ob$type.tp$getattr(G).tp$call([new f(e)]);throw new M(\"result out of range\")}return b},nb$subtract(t){if(t instanceof wt)return q(this,new wt(-t.$days),\"Add\");if(t instanceof vt){const e=this.$toOrdinal(),n=t.$toOrdinal();return new wt(e-n)}return b},nb$reflected_subtract:null},classmethods:{fromtimestamp:{$meth:function fromtimestamp(t){const[e,n,i]=$.localtime.tp$call([t]).v;return this.tp$call([e,n,i])},$flags:{OneArg:!0},$textsig:null,$doc:\"timestamp -> local date from a POSIX timestamp (like time.time()).\"},fromordinal:{$meth:function fromordinal(t){return this.tp$call(_ord2ymd(t))},$flags:{OneArg:!0},$textsig:null,$doc:\"int -> date corresponding to a proleptic Gregorian ordinal.\"},fromisocalendar:{$meth:function fromisocalendar(t,e,i){if(t=n(t),e=n(e),i=n(i),!(1<=t&&t<=j))throw new v(`Year is out of range: ${t}`);let s,o;if(!(0<e&&e<53)&&(s=!0,53===e&&(o=_ymd2ord(t,1,1)%7,(4===o||3===o&&_is_leap(t))&&(s=!1)),s))throw new v(`Invalid week: ${e}`);if(!(0<i&&i<8))throw new v(`Invalid weekday: ${i} (range is [1, 7])`);const r=7*(e-1)+(i-1),a=_isoweek1monday(t)+r;return this.tp$call(_ord2ymd(a))},$flags:{NamedArgs:[\"year\",\"week\",\"day\"]},$textsig:null,$doc:\"int -> date corresponding to a proleptic Gregorian ordinal.\"},fromisoformat:{$meth:function fromisoformat(t){if(!k(t))throw new z(\"fromisoformat: argument must be str\");t=t.toString();try{if(10!==t.length)throw new Error;return this.tp$call(_parse_isoformat_date(t))}catch(e){throw new v(\"Invalid isoformat string: '\"+t+\"'\")}},$flags:{OneArg:!0},$textsig:null,$doc:\"str -> Construct a date from the output of date.isoformat()\"},today:{$meth:function today(){const t=$.time.tp$call([]);return this.tp$getattr(B).tp$call([t])},$flags:{NoArgs:!0},$textsig:null,$doc:\"Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).\"}},methods:{ctime:{$meth:function ctime(){const t=this.$toOrdinal()%7||7,e=ft[t],n=lt[this.$month];return new w(`${e} ${n} ${_d(this.$day,\" \",2)} 00:00:00 ${_d(this.$year,\"0\",4)}`)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return ctime() style string.\"},strftime:{$meth:function strftime(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return _wrap_strftime(this,t=t.toString(),this.$timetuple())},$flags:{OneArg:!0},$textsig:null,$doc:\"format -> strftime() style string.\"},__format__:{$meth:function __format__(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return t!==w.$empty?this.tp$getattr(X).tp$call([t]):this.tp$str()},$flags:{OneArg:!0},$textsig:null,$doc:\"Formats self with strftime.\"},timetuple:{$meth:function timetuple(){return this.$timetuple()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time tuple, compatible with time.localtime().\"},isocalendar:{$meth:function isocalendar(){let t=this.$year,e=_isoweek1monday(t);const n=_ymd2ord(this.$year,this.$month,this.$day);let[i,s]=$divMod(n-e,7);return i<0?(t-=1,e=_isoweek1monday(t),[i,s]=$divMod(n-e,7)):i>=52&&n>=_isoweek1monday(t+1)&&(t+=1,i=0),new At(new f(t),new f(i+1),new f(s+1))},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a 3-tuple containing ISO year, week number, and weekday.\"},isoformat:{$meth:function isoformat(){return this.$isoformat()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return string in ISO 8601 format, YYYY-MM-DD.\"},isoweekday:{$meth:function isoweekday(){return new f(this.$toOrdinal()%7||7)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return the day of the week represented by the date.\\nMonday == 1 ... Sunday == 7\"},toordinal:{$meth:function toordinal(){return new f(this.$toOrdinal())},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.\"},weekday:{$meth:function weekday(){return new f((this.$toOrdinal()+6)%7)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return the day of the week represented by the date.\\nMonday == 0 ... Sunday == 6\"},replace:{$meth:function replace(t,e,n){return t===y&&(t=new f(this.$year)),e===y&&(e=new f(this.$month)),n===y&&(n=new f(this.$day)),this.ob$type.tp$call([t,e,n])},$flags:{NamedArgs:[\"year\",\"month\",\"day\"],Defaults:[y,y,y]},$textsig:null,$doc:\"Return date with new specified fields.\"},__reduce__:{$meth(){return new p([this.ob$type,new p([this.$getState()])])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},getsets:{year:{$get(){return new f(this.$year)},$doc:\"year (1-9999)\"},month:{$get(){return new f(this.$month)},$doc:\"month (1-12)\"},day:{$get(){return new f(this.$day)},$doc:\"day (1-31)\"}},proto:{$cmp(t){return _cmp([this.$year,this.$month,this.$day],[t.$year,t.$month,t.$day])},$getState(){const[t,e]=$divMod(this.$year,256);return new _([t,e,this.$month,this.$day])},$setState(t){const[e,n,i,s]=t,o=256*e+n;this.$year=o,this.$month=i,this.$day=s},$toOrdinal(){return _ymd2ord(this.$year,this.$month,this.$day)},$isoformat(){return new w(`${_d(this.$year,\"0\",4)}-${_d(this.$month,\"0\",2)}-${_d(this.$day,\"0\",2)}`)},$timetuple(){return _build_struct_time(this.$year,this.$month,this.$day,this.$hour||0,this.$min||0,this.$sec||0,-1)},$strftime(t=\"\"){return _wrap_strftime(this,t.toString(),this.$timetuple())}}});vt.prototype.min=new vt(1,1,1),vt.prototype.max=new vt(9999,12,31),vt.prototype.resolution=new wt(1);const Mt=E.tzinfo=h(\"datetime.tzinfo\",{constructor:function tzinfo(){},methods:{tzname:{$meth:function tzname(t){throw new x(\"tzinfo subclass must override tzname()\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime -> string name of time zone.\"},utcoffset:{$meth:function utcoffset(t){throw new x(\"tzinfo subclass must override utcoffset()\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime -> timedelta showing offset from UTC, negative values indicating West of UTC\"},dst:{$meth:function dst(t){throw new x(\"tzinfo subclass must override dst()\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime -> DST offset as timedelta positive east of UTC.\"},fromutc:{$meth:function fromutc(e){if(!(e instanceof Nt))throw new z(\"fromutc() requires a datetime argument\");if(e.$tzinfo!==this)throw new v(\"dt.tzinfo is not self\");const n=r(e.tp$getattr(U));if(n===y)throw new v(\"fromutc() requires a non-None utcoffset() result\");let i=r(e.tp$getattr(F));if(i===y)throw new v(\"fromutc() requires a non-None dst() result\");const s=q(n,i,\"Sub\");if(t(s)&&(e=q(e,s,\"Add\"),i=r(e.tp$getattr(F)),i===y))throw new v(\"fromutc(): dt.dst gave inconsistent results; cannot convert\");return q(e,i,\"Add\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime in UTC -> datetime in local time.\"},__reduce__:{$meth(){let e,n;const i=T(this,new w(\"__getinitargs__\"),y);e=i!==y?r(i,[]):new p;const s=T(this,new w(\"__getstate__\"),y);return s!==y?n=r(s,[]):(n=T(this,new w(\"__dict__\"),y),n=t(n)?n:y),new p(n===y?[this.ob$type,e]:[this.ob$type,e,n])},$flags:{NoArgs:!0},$textsig:null,$doc:\"-> (cls, state)\"}}}),At=h(\"datetime.IsoCalendarDate\",{base:p,constructor:function IsoCalendarDate(t,e,n){this.y=t,this.w=e,this.wd=n,p.call(this,[t,e,n])},slots:{tp$new(t,e){const[n,i,s]=l(\"IsoCalendarDate\",[\"year\",\"week\",\"weekday\"],t,e);return new this.constructor(n,i,s)},$r(){return new w(`${this.tp$name}(year=${this.y}, week=${this.w}, weekday=${this.wd})`)}},getsets:{year:{$get(){return this.y}},week:{$get(){return this.w}},weekday:{$get(){return this.wd}}}}),xt=E.time=h(\"datetime.time\",{constructor:function time(t=0,e=0,n=0,i=0,s=null,o=0){this.$hour=t,this.$min=e,this.$sec=n,this.$micro=i,this.$tzinfo=s||y,this.$fold=o,this.$hashcode=-1},slots:{tp$new(t,e){m(\"time\",t,0,5);let n,[i,s,o,r,a,$]=l(\"time\",[\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[W,W,W,W,y,W]);if(i instanceof _&&6===(n=i.valueOf()).length&&(127&n[0])<24){const t=new this.constructor;return t.$setState(n,s===W?y:s),t}if([i,s,o,r,$]=_check_time_fields(i,s,o,r,$),_check_tzinfo_arg(a),this===xt.prototype)return new xt(i,s,o,r,a,$);{const t=new this.constructor;return xt.call(t,i,s,o,r,a,$),t}},tp$richcompare(t,e){return t instanceof xt?_do_compare(this,t,e):b},tp$hash(){if(-1===this.$hashcode){const e=this.$fold?r(this.tp$getattr(J),[],[\"fold\",W]):this,n=r(e.tp$getattr(U));if(t(n)){let[t,e]=pyDivMod(new wt(0,3600*this.$hour+60*this.$min).nb$subtract(n),pt);e=e.nb$floor_divide(gt),0<=t&&t<=24?(t=I(t),e=I(e),this.$hashcode=u(new xt(t,e,this.$sec,this.$micro))):this.$hashcode=u(new p([t,e,new f(this.$sec),new f(this.$micro)]))}else this.$hashcode=u(e.$getState()[0])}return this.$hashcode},$r(){let t;return t=0!==this.$micro?`, ${this.$sec}, ${this.$micro}`:0!==this.$sec?`, ${this.$sec}`:\"\",t=`${this.tp$name}(${this.$hour}, ${this.$min}${t})`,this.$tzinfo!==y&&(t=t.slice(0,-1)+\", tzinfo=\"+s(this.$tzinfo)+\")\"),this.$fold&&(t=t.slice(0,-1)+\", fold=1)\"),new w(t)},tp$str(){return this.tp$getattr(H).tp$call([])}},methods:{isoformat:{$meth:function isoformat(t){let e=_format_time(this.$hour,this.$min,this.$sec,this.$micro,t);const n=this.$tzstr();return n&&(e+=n),new w(e)},$flags:{NamedArgs:[\"timespec\"],Defaults:[C]},$textsig:null,$doc:\"Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\\n\\ntimespec specifies what components of the time to include.\\n\"},strftime:{$meth:function strftime(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return _wrap_strftime(this,t=t.toString(),new p([1900,1,1,this.$hour,this.$min,this.$sec,0,1,-1].map((t=>new f(t)))))},$flags:{OneArg:!0},$textsig:null,$doc:\"format -> strftime() style string.\"},__format__:{$meth:function __format__(t){if(!k(t))throw new z(\"must be str, not \"+c(t));return t!==w.$empty?this.tp$getattr(X).tp$call([t]):this.tp$str()},$flags:{OneArg:!0},$textsig:null,$doc:\"Formats self with strftime.\"},utcoffset:{$meth:function utcoffset(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(U),e=r(t,[y]);return _check_utc_offset(\"utcoffset\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.utcoffset(self).\"},tzname:{$meth:function tzname(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(Y),e=r(t,[y]);return _check_tzname(e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.tzname(self).\"},dst:{$meth:function dst(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(F),e=r(t,[y]);return _check_utc_offset(\"dst\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.dst(self).\"},replace:{$meth:function replace(t,e){m(\"replace\",t,0,5);let[n,i,s,o,r,a]=l(\"replace\",[\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[y,y,y,y,g,y]);return n===y&&(n=new f(this.$hour)),i===y&&(i=new f(this.$min)),s===y&&(s=new f(this.$sec)),o===y&&(o=new f(this.$micro)),r===g&&(r=this.$tzinfo),a===y&&(a=new f(this.$fold)),this.ob$type.tp$call([n,i,s,o,r],[\"fold\",a])},$flags:{FastCall:!0},$textsig:null,$doc:\"Return time with new specified fields.\"},__reduce_ex__:{$meth(t){return new p([this.ob$type,new p(this.$getState(R(t)))])},$flags:{OneArg:!0},$textsig:null,$doc:\"__reduce_ex__(proto) -> (cls, state)\"},__reduce__:{$meth(){return this.tp$getattr(new w(\"__reduce_ex__\")).tp$call([new f(2)])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},classmethods:{fromisoformat:{$meth:function fromisoformat(t){if(!k(t))throw new z(\"fromisoformat: argument must be str\");t=t.toString();try{return this.tp$call(_parse_isoformat_time(t))}catch{throw new v(\"Invalid isofrmat string: '\"+t+\"'\")}},$flags:{OneArg:!0},$textsig:null,$doc:\"string -> time from time.isoformat() output\"}},getsets:{hour:{$get(){return new f(this.$hour)}},minute:{$get(){return new f(this.$min)}},second:{$get(){return new f(this.$sec)}},microsecond:{$get(){return new f(this.$micro)}},tzinfo:{$get(){return this.$tzinfo}},fold:{$get(){return new f(this.$fold)}}},proto:{$cmp(t,n){const s=this.$tzinfo,o=t.$tzinfo;let a,$,c;if(a=$=y,s===o?c=!0:(a=r(this.tp$getattr(U)),$=r(t.tp$getattr(U)),c=e(a,$,\"Eq\")),c)return _cmp([this.$hour,this.$min,this.$sec,this.$micro],[t.$hour,t.$min,t.$sec,t.$micro]);if(a===y||$===y){if(\"Eq\"===n||\"NotEq\"===n)return 2;throw new z(\"cannot compare naive and aware times\")}const h=60*this.$hour+this.$min-i(a.nb$floor_divide(gt)),m=60*t.$hour+t.$min-i($.nb$floor_divide(gt));return _cmp([h,this.$sec,this.$micro],[m,t.$sec,t.$micro])},$tzstr(){return _format_offset(r(this.tp$getattr(U)))},$getState(t=3){let[e,n]=$divMod(this.$micro,256),[i,s]=$divMod(e,256),o=this.$hour;this.$fold&&t>3&&(o+=128);const r=new _([o,this.$min,this.$sec,i,s,n]);return this.$tzinfo===y?[r]:[r,this.$tzinfo]},$setState(t,e){const[n,i,s,o,r,a]=t;n>127?(this.$fold=1,this.$hour=n-128):(this.$fold=0,this.$hour=n),this.$min=i,this.$sec=s,this.$micro=(o<<8|r)<<8|a,this.$tzinfo=e}}});xt.prototype.min=new xt(0,0,0),xt.prototype.max=new xt(23,59,59,999999),xt.prototype.resolution=new wt;const Nt=E.datetime=h(\"datetime.datetime\",{base:vt,constructor:function datetime(t,e,n,i=0,s=0,o=0,r=0,a=null,$=0){this.$year=t,this.$month=e,this.$day=n,this.$hour=i,this.$min=s,this.$sec=o,this.$micro=r,this.$tzinfo=a||y,this.$fold=$,this.$hashcode=-1},slots:{tp$new(t,e){m(\"datetime\",t,0,9);let n,[i,s,o,r,a,$,c,h,u]=l(\"time\",[\"year\",\"month\",\"day\",\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[null,null,W,W,W,W,y,W]);if(i instanceof _&&10===(n=i.valueOf()).length&&(127&n[2])<=12){const t=new this.constructor;return t.$setState(n,null===s?y:s),t}if([i,s,o]=_check_date_fields(i,s,o),[r,a,$,c,u]=_check_time_fields(r,a,$,c,u),_check_tzinfo_arg(h),this===Nt.prototype)return new Nt(i,s,o,r,a,$,c,h,u);{const t=new this.constructor;return Nt.call(t,i,s,o,r,a,$,c,h,u),t}},$r(){const t=[this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,this.$micro];0===t[t.length-1]&&t.pop(),0===t[t.length-1]&&t.pop();let e=`${this.tp$name}(${t.join(\", \")})`;return this.$tzinfo!==y&&(e=e.slice(0,-1)+\", tzinfo=\"+s(this.$tzinfo)+\")\"),this.$fold&&(e=e.slice(0,-1)+\", fold=1)\"),new w(e)},tp$str(){return this.tp$getattr(H).tp$call([],[\"sep\",new w(\" \")])},tp$richcompare(t,e){if(t instanceof Nt)return _do_compare(this,t,e);if(!(t instanceof vt))return b;if(\"Eq\"===e||\"NotEq\"===e)return\"NotEq\"===e;throw new z(`can't compare '${c(this)}' to '${c(t)}'`)},tp$as_number:!0,nb$add(t){if(!(t instanceof wt))return b;let e=new wt(this.$toOrdinal(),3600*this.$hour+60*this.$min+this.$sec,this.$micro);e=q(e,t,\"Add\");let[n,i]=$divMod(e.$secs,3600),[s,o]=$divMod(i,60);if(0<e.$days&&e.$days<=rt)return this.ob$type.tp$getattr(new w(\"combine\")).tp$call([vt.tp$call(_ord2ymd(e.$days)),new xt(n,s,o,e.$micro,this.$tzinfo)]);throw new M(\"result out of range\")},nb$subtract(t){if(!(t instanceof Nt))return t instanceof wt?this.nb$add(t.nb$negative()):b;const n=this.$toOrdinal(),i=t.$toOrdinal(),s=this.$sec+60*this.$min+3600*this.$hour,o=t.$sec+60*t.$min+3600*t.$hour,a=new wt(n-i,s-o,this.$micro-t.$micro);if(this.$tzinfo===t.$tzinfo)return a;const $=r(this.tp$getattr(U)),c=r(t.tp$getattr(U));if(e($,c,\"Eq\"))return a;if($===y||c===y)throw new z(\"cannot mix naive and timezone-aware time\");return a.nb$add(c).nb$subtract($)},nb$reflected_subtract:null,tp$hash(){if(-1===this.$hashcode){const t=this.$fold?r(this.tp$getattr(J),[],[\"fold\",W]):this,e=r(t.tp$getattr(U));if(e===y)this.$hashcode=u(t.$getState()[0]);else{const t=_ymd2ord(this.$year,this.$month,this.$day),n=3600*this.$hour+60*this.$min+this.$sec;this.$hashcode=u(new wt(t,n,this.$micro).nb$subtract(e))}}return this.$hashcode}},methods:{date:{$meth:function _date(){return new vt(this.$year,this.$month,this.$day)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return date object with same year, month and day.\"},time:{$meth:function _time(){return new xt(this.$hour,this.$min,this.$sec,this.$micro,y,this.$fold)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time object with same time but with tzinfo=None.\"},timetz:{$meth:function timetz(){return new xt(this.$hour,this.$min,this.$sec,this.$micro,this.$tzinfo,this.$fold)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time object with same time and tzinfo.\"},ctime:{$meth:function ctime(){const t=this.$toOrdinal()%7||7,e=ft[t],n=lt[this.$month];return new w(`${e} ${n} ${_d(this.$day,\" \",2)} ${_d(this.$hour,\"0\",2)}:${_d(this.$min,\"0\",2)}:${_d(this.$sec,\"0\",2)} ${_d(this.$year,\"0\",4)}`)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return ctime() style string.\"},timetuple:{$meth:function timetuple(){let e=r(this.tp$getattr(F));return e=e===y?-1:t(e)?1:0,_build_struct_time(this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,e)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return time tuple, compatible with time.localtime().\"},timestamp:{$meth:function timestamp(){if(this.$tzinfo===y){let t=this.$mkTime();return t=I(t),new d(t+this.$micro/1e6)}{const t=q(this,kt,\"Sub\");return new d(((86400*t.$days+t.$secs)*10**6+t.$micro)/10**6)}},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return POSIX timestamp as float.\"},utctimetuple:{$meth:function utctimetuple(){const e=r(this.tp$getattr(U));let n=this;return t(e)&&(n=q(n,e,\"Sub\")),_build_struct_time(n.$year,n.$month,n.$day,n.$hour,n.$min,n.$sec,0)},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return UTC time tuple, compatible with time.localtime().\"},isoformat:{$meth:function isoformat(t,e){if(!k(t))throw new z(\"sep must be str, not \"+c(t));let n=`${_d(this.$year,\"0\",4)}-${_d(this.$month,\"0\",2)}-${_d(this.$day,\"0\",2)}`+t.toString();n+=_format_time(this.$hour,this.$min,this.$sec,this.$micro,e);const i=_format_offset(r(this.tp$getattr(U)));return i&&(n+=i),new w(n)},$flags:{NamedArgs:[\"sep\",\"timespec\"],Defaults:[new w(\"T\"),C]},$textsig:null,$doc:\"[sep] -> string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\\nsep is used to separate the year from the time, and defaults to 'T'.\\ntimespec specifies what components of the time to include (allowed values are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds', and 'microseconds').\\n\"},utcoffset:{$meth:function utcoffset(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(U),e=r(t,[this]);return _check_utc_offset(\"utcoffset\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.utcoffset(self).\"},tzname:{$meth:function tzname(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(Y),e=r(t,[this]);return _check_tzname(e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.tzname(self).\"},dst:{$meth:function dst(){if(this.$tzinfo===y)return y;const t=this.$tzinfo.tp$getattr(F),e=r(t,[this]);return _check_utc_offset(\"dst\",e),e},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return self.tzinfo.dst(self).\"},replace:{$meth:function replace(t,e){m(\"replace\",t,0,8);let[n,i,s,o,r,a,$,c,h]=l(\"replace\",[\"year\",\"month\",\"day\",\"hour\",\"minute\",\"second\",\"microsecond\",\"tzinfo\",\"fold\"],t,e,[y,y,y,y,y,y,y,g,y]);return n===y&&(n=new f(this.$year)),i===y&&(i=new f(this.$month)),s===y&&(s=new f(this.$day)),o===y&&(o=new f(this.$hour)),r===y&&(r=new f(this.$min)),a===y&&(a=new f(this.$sec)),$===y&&($=new f(this.$micro)),c===g&&(c=this.$tzinfo),h===y&&(h=new f(this.$fold)),this.ob$type.tp$call([n,i,s,o,r,a,$,c],[\"fold\",h])},$flags:{FastCall:!0},$textsig:null,$doc:\"Return datetime with new specified fields.\"},astimezone:{$meth:function astimezone(t){if(t===y)t=this.$localTimezone();else if(!(t instanceof Mt))throw new z(\"tz argument must be an instance of tzinfo\");let e,n=this.$tzinfo;if(n===y?(n=this.$localTimezone(),e=r(n.tp$getattr(U),[this])):(e=r(n.tp$getattr(U),[this]),e===y&&(n=r(this.tp$getattr(J),[],[\"tzinfo\",y]).$localTimezone(),e=r(n.tp$getattr(U),[this]))),t===n)return this;const i=r(this.nb$subtract(e).tp$getattr(J),[],[\"tzinfo\",t]);return t.tp$getattr(P).tp$call([i])},$flags:{NamedArgs:[\"tz\"],Defaults:[y]},$textsig:null,$doc:\"tz -> convert to local time in new timezone tz\\n\"},__reduce_ex__:{$meth(t){return new p([this.ob$type,new p(this.$getState(R(t)))])},$flags:{OneArg:!0},$textsig:null,$doc:\"__reduce_ex__(proto) -> (cls, state)\"},__reduce__:{$meth(){return this.tp$getattr(new w(\"__reduce_ex__\")).tp$call([new f(2)])},$flags:{NoArgs:!0},$textsig:null,$doc:\"__reduce__() -> (cls, state)\"}},classmethods:{now:{$meth:function now(t){const e=$.time.tp$call([]);return this.tp$getattr(B).tp$call([e,t])},$flags:{NamedArgs:[\"tz\"],Defaults:[y]},$textsig:\"($type, /, tz=None)\",$doc:\"Returns new datetime object representing current time local to tz.\\n\\n  tz\\n    Timezone object.\\n\\nIf no tz is specified, uses local timezone.\"},utcnow:{$meth:function utcnow(){const t=$.time.tp$call([]);return this.tp$getattr(L).tp$call([t])},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a new datetime representing UTC day and time.\"},fromtimestamp:{$meth:function fromtimestamp(t,e){return _check_tzinfo_arg(e),this.prototype.$fromtimestamp.call(this,t,e!==y,e)},$flags:{NamedArgs:[\"timestamp\",\"tz\"],Defaults:[y]},$textsig:null,$doc:\"timestamp[, tz] -> tz's local time from POSIX timestamp.\"},utcfromtimestamp:{$meth:function utcfromtimestamp(t){return this.prototype.$fromtimestamp.call(this,t,!0,y)},$flags:{OneArg:!0},$textsig:null,$doc:\"Construct a naive UTC datetime from a POSIX timestamp.\"},strptime:{$meth:function strptime(t,e){return null===ot?Sk.misceval.chain(Sk.importModule(\"_strptime\",!1,!0),(n=>(ot=n.tp$getattr(new w(\"_strptime_datetime\")),ot.tp$call([this,t,e])))):ot.tp$call([this,t,e])},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"string, format -> new datetime parsed from a string (like time.strptime()).\"},combine:{$meth:function combine(t,e,n){if(!(t instanceof vt))throw new z(\"date argument must be a date instance\");if(!(e instanceof xt))throw new z(\"time argument must be a time instance\");n===g&&(n=e.$tzinfo);const i=[t.$year,t.$month,t.$day,e.$hour,e.$min,e.$sec,e.$micro].map((t=>new f(t)));return i.push(n),this.tp$call(i,[\"fold\",new f(e.$fold)])},$flags:{NamedArgs:[\"date\",\"time\",\"tzinfo\"],Defaults:[g]},$textsig:null,$doc:\"date, time -> datetime with same date and time fields\"},fromisoformat:{$meth:function fromisoformat(t){if(!k(t))throw new z(\"fromisoformat: argument must be str\");const e=(t=t.toString()).slice(0,10),n=t.slice(11);let i,s;try{i=_parse_isoformat_date(e)}catch(o){throw new v(\"Invalid isoformat string: '\"+t+\"'\")}if(n)try{s=_parse_isoformat_time(n)}catch(o){throw new v(\"Invalid isoformat string: '\"+t+\"'\")}else s=[W,W,W,W,y];return this.tp$call(i.concat(s))},$flags:{OneArg:!0},$textsig:null,$doc:\"string -> datetime from datetime.isoformat() output\"}},getsets:{hour:{$get(){return new f(this.$hour)}},minute:{$get(){return new f(this.$min)}},second:{$get(){return new f(this.$sec)}},microsecond:{$get(){return new f(this.$micro)}},tzinfo:{$get(){return this.$tzinfo}},fold:{$get(){return new f(this.$fold)}}},proto:{$cmp(n,i){const s=this.$tzinfo,o=n.$tzinfo;let a,$,c;if(a=$=y,s===o)c=!0;else{if(a=r(this.tp$getattr(U)),$=r(n.tp$getattr(U)),\"Eq\"===i||\"NotEq\"===i){const t=r(this.tp$getattr(J),[],[\"fold\",new f(Number(!this.$fold))]);if(e(a,r(t.tp$getattr(U)),\"NotEq\"))return 2;const i=r(n.tp$getattr(J),[],[\"fold\",new f(Number(!n.$fold))]);if(e($,r(i.tp$getattr(U)),\"NotEq\"))return 2}c=e(a,$,\"Eq\")}if(c)return _cmp([this.$year,this.$month,this.$day,this.$hour,this.$min,this.$sec,this.$micro],[n.$year,n.$month,n.$day,n.$hour,n.$min,n.$sec,n.$micro]);if(a===y||$===y){if(\"Eq\"===i||\"NotEq\"===i)return 2;throw new z(\"cannot compare naive and aware datetimes\")}const h=this.nb$subtract(n);return h.$days<0?-1:t(h)?1:0},$mkTime(){const t=new Nt(1970,1,1),e=this.nb$subtract(t).nb$floor_divide(yt);function local(e){const[n,i,s,o,r,a]=$.localtime.tp$call([e]).v;return Nt.tp$call([n,i,s,o,r,a]).nb$subtract(t).nb$floor_divide(yt)}let n,i,s=local(e).nb$subtract(e),o=e.nb$subtract(s),r=local(o);if(r.ob$eq(e)){if(n=o.nb$add([new f(-86400),new f(86400)][this.$fold]),i=local(n).nb$subtract(n),s.ob$eq(i))return o}else i=r.nb$subtract(o);n=e.nb$subtract(i);if(local(n).ob$eq(e))return n;if(r.ob$eq(e))return o;const a=o.ob$ge(n)?o:n;return[a,o===a?n:o][this.$fold]},$fromtimestamp(t,n,s){let o;if(!N(t))throw new z(\"a number is required, (got '\"+c(t)+\"'\");[o,t]=modf(t);let a=intRound(q(o,nt,\"Mult\"));a=a.v,t=t.v,a>=1e6?(t+=1,a-=1e6):a<0&&(t-=1,a+=1e6),t=new f(t),Number.isInteger(a)||(a=Math.trunc(a)),a=new f(a);const h=n?$.gmtime:$.localtime;function converter(t){return h.tp$call([t]).v}let[m,u,l,d,_,p]=converter(t);p=new f(Math.min(i(p),59));let g=r(this,[m,u,l,d,_,p,a,s]);if(s===y){const n=86400;[m,u,l,d,_,p]=converter(q(t,new f(n),\"Sub\"));const i=r(this,[m,u,l,d,_,p,a,s]),o=q(q(g,i,\"Sub\"),new wt(0,n),\"Sub\");if(o.$days<0){[m,u,l,d,_,p]=converter(q(t,q(o,yt,\"FloorDiv\"),\"Add\"));const n=r(this,[m,u,l,d,_,p,a,s]);e(n,g,\"Eq\")&&(g.$fold=1)}}else g=r(s.tp$getattr(new w(\"fromutc\")),[g]);return g},$localTimezone(){let t;t=this.$tzinfo===y?this.$mkTime():this.nb$subtract(kt).nb$floor_divide(yt);const e=$.localtime.tp$call([t]),n=(Nt.tp$call(e.v.slice(0,6)),e.tp$getattr(new w(\"tm_gmtoff\"))),i=e.tp$getattr(new w(\"tm_zone\"));return new St(wt.tp$call([W,n]),i)},$getState(t=3){let[e,n]=$divMod(this.$year,256),[i,s]=$divMod(this.$micro,256),[o,r]=$divMod(i,256),a=this.$month;this.$fold&&t>3&&(a+=128);const $=new _([e,n,a,this.$day,this.$hour,this.$min,this.$sec,o,r,s]);return this.$tzinfo===y?[$]:[$,this.$tzinfo]},$setState(t,e){const[n,i,s,o,r,a,$,c,h,m]=t;s>127?(this.$fold=1,this.$month=s-128):(this.$fold=0,this.$month=s),this.$year=256*n+i,this.$day=o,this.$hour=r,this.$min=a,this.$sec=$,this.$micro=(c<<8|h)<<8|m,this.$tzinfo=e}}});function _isoweek1monday(t){const e=_ymd2ord(t,1,1),n=(e+6)%7;let i=e-n;return n>3&&(i+=7),i}Nt.prototype.min=new Nt(1,1,1),Nt.prototype.max=new Nt(9999,12,31,23,59,59,999999),Nt.prototype.resolution=new wt(0,0,1);const St=E.timezone=h(\"datetime.timezone\",{base:Mt,constructor:function timezone(t,n){if(this.$offset=t,this.$name=n||y,!e(this.$minoffset,t,\"LtE\")||!e(this.$maxoffset,t,\"GtE\"))throw new v(\"offset must be a timedelta strictly between -timedelta(hours=24) and timedelta(hours=24).\")},slots:{tp$new(e,n){let[i,s]=l(\"timezone\",[\"offset\",\"name\"],e,n,[null]);if(!(i instanceof wt))throw new z(\"offset must be a timedelta\");if(null===s){if(!t(i))return this.utc;s=y}else if(!k(s))throw new z(\"name must be a string\");if(this===St.prototype)return new St(i,s);{const t=new this.constructor;return St.call(t,i,s),t}},tp$richcompare(t,n){if(!(t instanceof St))return b;const i=e(this.$offset,t.$offset,\"Eq\");return\"NotEq\"===n?!i:\"Eq\"===n||i&&o(n)?i:b},$r(){return this===this.utc?new w(\"datetime.timezone.utc\"):this.$name===y?new w(`${this.tp$name}(${s(this.$offset)})`):new w(`${this.tp$name}(${s(this.$offset)}, ${s(this.$name)})`)},tp$str(){return this.tp$getattr(Y).tp$call([y])},tp$hash(){return u(this.$offset)}},methods:{tzname:{$meth:function tzname(t){if(t instanceof Nt||t===y)return this.$name===y?this.$nameFromOff(this.$offset):this.$name;throw new z(\"tzname() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"If name is specified when timezone is created, returns the name.  Otherwise returns offset as 'UTC(+|-)HH:MM'.\"},utcoffset:{$meth:function utcoffset(t){if(t instanceof Nt||t===y)return this.$offset;throw new z(\"utcoffset() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"Return fixed offset.\"},dst:{$meth:function dst(t){if(t instanceof Nt||t===y)return y;throw new z(\"dst() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"Return None.\"},fromutc:{$meth:function fromutc(t){if(t instanceof Nt){if(t.$tzinfo!==this)throw new v(\"fromutc: dt.tzinfo is not self\");return q(t,this.$offset,\"Add\")}throw new z(\"fromutc() argument must be a datetime instance or None\")},$flags:{OneArg:!0},$textsig:null,$doc:\"datetime in UTC -> datetime in local time.\"},__getinitargs__:{$meth(){return this.$name===y?new p([this.$offset]):new p([this.$offset,this.$name])},$flags:{NoArgs:!0}}},proto:{$maxoffset:new wt(0,86399,999999),$minoffset:new wt(-1,0,1),$nameFromOff(n){if(!t(n))return new w(\"UTC\");let i,s,o,r,a,$;return e(n,bt,\"Lt\")?(i=\"-\",n=n.nb$negative()):i=\"+\",[s,o]=pyDivMod(n,pt),[r,o]=pyDivMod(o,gt),a=o.$secs,$=o.$micro,new w($?`UTC${i}${_d(s)}:${_d(r)}:${_d(a)}.${_d($,\"0\",6)}`:a?`UTC${i}${_d(s)}:${_d(r)}:${_d(a)}`:`UTC${i}${_d(s)}:${_d(r)}`)}}});St.prototype.utc=new St(new wt(0)),St.prototype.min=new St(new wt(0,-86340,0)),St.prototype.max=new St(new wt(0,86340,0));const kt=new Nt(1970,1,1,0,0,0,0,St.prototype.utc);return E}))}","src/lib/document.js":"function $builtinmodule(){const{builtin:{str:i},misceval:{callsimArray:n},ffi:{toPy:t},abstr:{gattr:e}}=Sk,r={__name__:new i(\"document\")},o=t(Sk.global.document);return Sk.abstr.setUpModuleMethods(\"document\",r,{__getattr__:{$meth:i=>e(o,i,!0),$flags:{OneArg:!0}},__dir__:{$meth:()=>n(o.tp$getattr(i.$dir)),$flags:{NoArgs:!0}}}),r.currentDiv=new Sk.builtin.func((function(){if(void 0!==Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for divid\")})),r.currentCourse=new Sk.builtin.func((function(){if(void 0!==eBookConfig)return new Sk.builtin.str(eBookConfig.course);throw new Sk.builtin.AttributeError(\"There is no course\")})),r.currentGradingContainer=new Sk.builtin.func((function(){if(void 0!==Sk.gradeContainer)return new Sk.builtin.str(Sk.gradeContainer);if(null!=Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for grading\")})),r.getCurrentEditorValue=new Sk.builtin.func((function(){if(void 0!==Sk.divid&&void 0!==window.componentMap){if(Sk.gradeContainer!=Sk.divid){var i=Sk.gradeContainer+\" \"+Sk.divid;return i in window.componentMap?new Sk.builtin.str(window.componentMap[i].editor.getValue()):new Sk.builtin.str(window.componentMap[Sk.divid].editor.getValue())}return new Sk.builtin.str(window.componentMap[Sk.divid].editor.getValue())}throw new Sk.builtin.AttributeError(\"Can't find editor for this div\")})),r.popup=new Sk.builtin.func((function(i){const n=Sk.ffi.remapToJs(i);alert(n)})),r}","src/lib/fractions.js":"function $builtinmodule(t){const e={};return Sk.misceval.chain(Sk.importModule(\"math\",!1,!0),(t=>(e.math=t,Sk.importModule(\"sys\",!1,!0))),(t=>(e.sys=t,fractionsMod(e))))}function fractionsMod({math:t,sys:e}){const{builtin:{int_:n,bool:{true$:i,false$:r},none:{none$:s},NotImplemented:{NotImplemented$:o},tuple:a,float_:$,complex:u,str:h,isinstance:l,TypeError:m,ZeroDivisionError:d,ValueError:f,NotImplementedError:c,abs:_,round:b,pow:p},ffi:{remapToPy:g},abstr:{buildNativeClass:w,copyKeywordsToNamedArgs:v,numberBinOp:y,typeName:k,lookupSpecial:E,checkArgsLen:N},misceval:{isTrue:F,richCompareBool:A,callsimArray:S,objectRepr:M}}=Sk,O={__name__:new h(\"fractions\"),__all__:g([\"Fraction\"])},D=/^\\s*(?<sign>[-+]?)(?=\\d|\\.\\d)(?<num>\\d*)(?:(?:\\/(?<denom>\\d+))?|(?:\\.(?<decimal>\\d*))?(?:E(?<exp>[-+]?\\d+))?)\\s*$/i,q=new n(0),x=new n(1),z=new n(2),I=new n(10),T=new h(\"numerator\"),R=new h(\"denominator\"),B=new h(\"as_integer_ratio\"),C=new h(\"from_float\"),getNumer=t=>t.tp$getattr(T),getDenom=t=>t.tp$getattr(R),mul=(t,e)=>y(t,e,\"Mult\"),div=(t,e)=>y(t,e,\"Div\"),pow=(t,e)=>y(t,e,\"Pow\"),add=(t,e)=>y(t,e,\"Add\"),sub=(t,e)=>y(t,e,\"Sub\"),floorDiv=(t,e)=>y(t,e,\"FloorDiv\"),divmod=(t,e)=>y(t,e,\"DivMod\"),mod=(t,e)=>y(t,e,\"Mod\"),K=t.tp$getattr(new h(\"gcd\")),eq=(t,e)=>A(t,e,\"Eq\"),lt=(t,e)=>A(t,e,\"Lt\"),ge=(t,e)=>A(t,e,\"GtE\"),L={NoArgs:!0},P={OneArg:!0},j=e.tp$getattr(new h(\"hash_info\")),G=j.tp$getattr(new h(\"modulus\")),V=j.tp$getattr(new h(\"inf\"));function _operator_fallbacks(t,e){return[function(n){return isRational(n)?t(this,n):n instanceof $?e(this.nb$float(),n):n instanceof u?e(S(u,[this]),n):o},function(n){return isRational(n)?t(n,this):n instanceof $?e(n,this.nb$float()):n instanceof u?e(n,S(u,[this])):o}]}const[Z,H]=_operator_fallbacks(((t,e)=>{const n=getDenom(t),i=getDenom(e);return S(ot,[add(mul(getNumer(t),i),mul(getNumer(e),n)),mul(n,i)])}),add),[J,Q]=_operator_fallbacks(((t,e)=>{const n=getDenom(t),i=getDenom(e);return S(ot,[sub(mul(getNumer(t),i),mul(getNumer(e),n)),mul(n,i)])}),sub),[U,W]=_operator_fallbacks(((t,e)=>S(ot,[mul(getNumer(t),getNumer(e)),mul(getDenom(t),getDenom(e))])),mul),[X,Y]=_operator_fallbacks(((t,e)=>S(ot,[mul(getNumer(t),getDenom(e)),mul(getDenom(t),getNumer(e))])),div),[tt,et]=_operator_fallbacks(((t,e)=>floorDiv(mul(getNumer(t),getDenom(e)),mul(getDenom(t),getNumer(e)))),floorDiv),[nt,it]=_operator_fallbacks(((t,e)=>{const n=getDenom(t),i=getDenom(e),[r,s]=divmod(mul(getNumer(t),i),mul(n,getNumer(e))).valueOf();return new a([r,S(ot,[s,mul(n,i)])])}),divmod),[rt,st]=_operator_fallbacks(((t,e)=>{const n=getDenom(t),i=getDenom(e),r=mod(mul(getNumer(t),i),mul(getNumer(e),n));return S(ot,[r,mul(n,i)])}),mod),ot=O.Fraction=w(\"fractions.Fraction\",{constructor:function(t,e){this.$num=t||q,this.$den=e||x},slots:{tp$new(t,e){N(\"Fraction\",t,0,2);let[r,o,a]=v(\"Fraction\",[\"numerator\",\"denominator\",\"_normalize\"],t,e,[q,s,i]);const u=new this.constructor;if(o===s){if(r.ob$type===n)return u.$num=r,u.$den=x,u;if(isRational(r))return u.$num=getNumer(r),u.$den=getDenom(r),u;if(r instanceof $)return[u.$num,u.$den]=S(r.tp$getattr(B)).valueOf(),u;if(!(r instanceof h))throw new m(\"argument should be a string or a Rational instance\");{const t=r.toString().match(D);if(null===t)throw new f(\"Invalid literal for Fraction: \"+M(r));r=new n(t.groups.num||\"0\");const e=t.groups.denom;if(e)o=new n(e);else{o=x;const e=t.groups.decimal;if(e){const t=new n(\"\"+10**e.length);r=add(mul(r,t),new n(e)),o=mul(o,t)}let i=t.groups.exp;i&&(i=new n(i),lt(i,q)?o=mul(o,pow(I,i.nb$negative())):r=mul(r,pow(I,i)))}\"-\"==t.groups.sign&&(r=r.nb$negative())}}else if(r.ob$type===n&&o.ob$type===n);else{if(!isRational(r)||!isRational(o))throw new m(\"both arguments should be Rational instances\");[r,o]=[mul(getNumer(r),getDenom(o)),mul(getNumer(o),getDenom(r))]}if(eq(o,q))throw new d(`Fraction(${r}, 0)`);if(F(a)){let t=S(K,[r,o]);lt(o,q)&&(t=t.nb$negative()),r=floorDiv(r,t),o=floorDiv(o,t)}return u.$num=r,u.$den=o,u},$r(){const t=E(this.ob$type,h.$name);return new h(`${t}(${this.$num}, ${this.$den})`)},tp$str(){return eq(this.$den,x)?new h(this.$num):new h(`${this.$num}/${this.$den}`)},tp$hash(){const t=p(this.$den,sub(G,z),G);let e;e=F(t)?mod(mul(_(this.$num),t),G):V;let n=ge(this,q)?e:e.nb$negative();return n=n.tp$hash(),-1===n?-2:n},tp$richcompare(t,e){const op=(t,n)=>A(t,n,e);if(\"Eq\"===e||\"NotEq\"==e){if(t.ob$type===n){const n=eq(this.$num,t)&&eq(this.$den,x);return\"Eq\"===e?n:!n}if(t instanceof ot||t instanceof n){const n=eq(this.$num,getNumer(t))&&eq(this.$den,getDenom(t));return\"Eq\"===e?n:!n}t instanceof u&&eq(t.tp$getattr(new h(\"imag\")),q)&&(t=t.tp$getattr(new h(\"real\")))}return isRational(t)?op(mul(getNumer(this),getDenom(t)),mul(getDenom(this),getNumer(t))):t instanceof $?Number.isFinite(t.valueOf())?op(this,S(this.tp$getattr(C),[t])):op(new $(0),t):o},tp$as_number:!0,nb$add:Z,nb$reflected_add:H,nb$subtract:J,nb$reflected_subtract:Q,nb$multiply:U,nb$reflected_multiply:W,nb$divide:X,nb$reflected_divide:Y,nb$floor_divide:tt,nb$reflected_floor_divide:et,nb$divmod:nt,nb$reflected_divmod:it,nb$remainder:rt,nb$reflected_remainder:st,nb$power(t){if(isRational(t)){if(eq(getDenom(t),x)){let e=getNumer(t);return ge(e,q)?S(ot,[pow(this.$num,e),pow(this.$den,e)],[\"_normalize\",r]):ge(this.$num,q)?(e=e.nb$negative(),S(ot,[pow(this.$den,e),pow(this.$num,e)],[\"_normalize\",r])):(e=e.nb$negative(),S(ot,[pow(this.$den.nb$negative(),e),pow(this.$num.nb$negative(),e)],[\"_normalize\",r]))}return pow(this.nb$float(),S($,[t]))}return pow(this.nb$float(),t)},nb$reflected_power(t){return eq(this.$den,x)&&ge(this.$num,q)?pow(t,this.$num):isRational(t)?pow(new ot(getNumer(t),getDenom(t)),this):eq(this.$den,x)?pow(t,this.$num):pow(t,this.nb$float())},nb$positive(){return new ot(this.$num,this.$den)},nb$negative(){return new ot(this.$num.nb$negative(),this.$den)},nb$abs(){return new ot(this.$num.nb$abs(),this.$den)},nb$bool(){return this.$num.nb$bool()},nb$float(){return div(this.$num,this.$den)}},methods:{as_integer_ratio:{$meth(){return new a([this.$num,this.$den])},$flags:L},limit_denominator:{$meth(t){if(lt(t,x))throw new f(\"max_denominator should be at least 1\");if(ge(t,this.$den))return S(ot,[this]);let[e,n,i,r]=[q,x,x,q],s=this.$num,o=this.$den;for(;;){const a=floorDiv(s,o),$=add(n,mul(a,r));if(lt(t,$))break;[e,n,i,r]=[i,r,add(e,mul(a,i)),$],[s,o]=[o,sub(s,mul(a,o))]}const a=floorDiv(sub(t,n),r),$=S(ot,[add(e,mul(a,i)),add(n,mul(a,r))]),u=S(ot,[i,r]);return ge(_(sub($,this)),_(sub(u,this)))?u:$},$flags:{NamedArgs:[\"max_denominator\"],Defaults:[new n(1e6)]}},__trunc__:{$meth(){return lt(this.$num,q)?floorDiv(this.$num.nb$negative(),this.$den).nb$negative():floorDiv(this.$num,this.$den)},$flags:L},__floor__:{$meth(){return floorDiv(this.$num,this.$den)},$flags:L},__ceil__:{$meth(){return floorDiv(this.$num.nb$negative(),this.$den).nb$negative()},$flags:L},__round__:{$meth(t){if(t===s){const[t,e]=divmod(this.$num,this.$den).valueOf(),n=mul(e,z);return lt(n,this.$den)?t:lt(this.$den,n)?add(t,x):eq(mod(t,z),q)?t:add(t,x)}const e=pow(I,_(t));return lt(q,t)?S(ot,[b(mul(this,e)),e]):S(ot,[mul(b(div(this,e)),e)])},$flags:{NamedArgs:[\"ndigits\"],Defaults:[s]}},__reduce__:{$meth(){return new a([this.ob$type,new a([new h(this)])])},$flags:L},__copy__:{$meth(){return this.ob$type===ot?this:S(this.ob$type,[this.$num,this.$den])},$flags:L},__deepcopy__:{$meth(t){return this.ob$type===ot?this:S(this.ob$type,[this.$num,this.$den])},$flags:P}},classmethods:{from_float:{$meth(t){if(t instanceof n)return S(this,[t]);if(t instanceof $){const[e,n]=S(t.tp$getattr(B)).valueOf();return S(this,[e,n])}throw new m(`${k(this)}.from_float() only takes floats, not ${M(t)}, (${k(t)})`)},$flags:P},from_decimal:{$meth(){throw c(\"from_decimal not yet implemented in SKulpt\")},$flags:P}},getsets:{numerator:{$get(){return this.$num}},denominator:{$get(){return this.$den}},_numerator:{$get(){return this.$num},$set(t){this.$num=t}},_denominator:{$get(){return this.$den},$set(t){this.$den=t}}}}),at=new a([n,ot]),isRational=t=>F(l(t,at));return O}","src/lib/functools.js":"function $builtinmodule(){const t={};return Sk.misceval.chain(Sk.importModule(\"collections\",!1,!0),(e=>(t._namedtuple=e.$d.namedtuple,functools_mod(t))))}function functools_mod(t){const{object:e,int_:n,str:r,list:s,tuple:a,dict:i,none:{none$:o},bool:{false$:c},NotImplemented:{NotImplemented$:_},bool:l,func:p,method:u,TypeError:h,RuntimeError:d,ValueError:f,NotImplementedError:m,AttributeErrror:w,OverflowError:g,checkNone:$,checkBool:y,checkCallable:k,checkClass:b}=Sk.builtin,{callsimArray:x,callsimOrSuspendArray:A,iterFor:S,chain:E,isIndex:v,asIndexSized:N,isTrue:P,richCompareBool:j,objectRepr:R}=Sk.misceval,{remapToPy:z}=Sk.ffi,{buildNativeClass:q,setUpModuleMethods:T,keywordArrayFromPyDict:I,keywordArrayToPyDict:D,objectHash:C,lookupSpecial:M,copyKeywordsToNamedArgs:W,typeName:F,iter:U,gattr:O}=Sk.abstr,{getSetDict:G,getAttr:B,setAttr:K}=Sk.generic;function proxyFail(t){return new p((()=>{throw new m(t+\" is not yet implemented in skulpt\")}))}Object.assign(t,{__name__:new r(\"functools\"),__doc__:new r(\"Tools for working with functions and callable objects\"),__all__:new s([\"update_wrapper\",\"wraps\",\"WRAPPER_ASSIGNMENTS\",\"WRAPPER_UPDATES\",\"total_ordering\",\"cmp_to_key\",\"cache\",\"lru_cache\",\"reduce\",\"partial\",\"partialmethod\",\"singledispatch\",\"singledispatchmethod\",\"cached_property\"].map((t=>new r(t)))),WRAPPER_ASSIGNMENTS:new a([\"__module__\",\"__name__\",\"__qualname__\",\"__doc__\",\"__annotations__\"].map((t=>new r(t)))),WRAPPER_UPDATES:new a([new r(\"__dict__\")]),singledispatch:proxyFail(\"singledispatch\"),singledispatchmethod:proxyFail(\"singledispatchmethod\"),cached_property:proxyFail(\"cached_property\")});const L=new r(\"cache_parameters\");function _lru_cache(e,n){if(n||(n=c),v(e))(e=N(e,g))<0&&(e=0);else{if(k(e)&&y(n)){const r=e,s=new V(r,e=128,n);return s.tp$setattr(L,new p((()=>z({maxsize:e,typed:n})))),A(t.update_wrapper,[s,r])}if(!$(e))throw new h(\"Expected first argument to be an integer, a callable, or None\")}return new p((r=>{const s=new V(r,e,n);return s.tp$setattr(L,new p((()=>z({maxsize:e,typed:n})))),A(t.update_wrapper,[s,r])}))}const H=t._CacheInfo=x(t._namedtuple,[\"CacheInfo\",[\"hits\",\"misses\",\"maxsize\",\"currsize\"]].map((t=>z(t))),[\"module\",new r(\"functools\")]),V=q(\"functools._lru_cache_wrapper\",{constructor:function _lru_cache_wrapper(t,e,n,r){if(!k(t))throw new h(\"the first argument must be callable\");let s;if($(e))s=infinite_lru_cache_wrapper,e=-1;else{if(!v(e))throw new h(\"maxsize should be integer or None\");(e=N(e,g))<0&&(e=0),s=0===e?uncached_lru_cache_wrapper:bounded_lru_cache_wrapper}this.root={},this.root.prev=this.root.next=this.root,this.wrapper=s,this.maxsize=e,this.typed=n,this.cache=new i([]),this.func=t,this.misses=this.hits=0,this.$d=new i([])},slots:{tp$new(t,e){const[n,r,s,a]=W(\"_lru_cache_wrapper\",[\"user_function\",\"maxsize\",\"typed\",\"cache_info_type\"],t,e);return new V(n,r,s,a)},tp$call(t,e){return this.wrapper(t,e)},tp$descr_get(t,e){return null===t?this:new u(this,t)},tp$doc:\"Create a cached callable that wraps another function.\\n\\nuser_function:      the function being cached\\n\\nmaxsize:  0         for no caching\\n          None      for unlimited cache size\\n          n         for a bounded cache\\n\\ntyped:    False     cache f(3) and f(3.0) as identical calls\\n          True      cache f(3) and f(3.0) as distinct calls\\n\\ncache_info_type:    namedtuple class with the fields:\\n                        hits misses currsize maxsize\\n\"},methods:{cache_info:{$meth(){return A(H,[this.hits,this.misses,-1===this.maxsize?o:this.maxsize,this.cache.get$size()].map((t=>z(t))))},$flags:{NoArgs:!0},$doc:\"Report cache statistics\"},cache_clear:{$meth(){return this.hits=this.misses=0,this.root={},this.root.next=this.root.prev=this.root,A(this.cache.tp$getattr(new r(\"clear\"),!0))},$flags:{NoArgs:!0},$doc:\"Clear the cache and cache statistics\"},__deepcopy__:{$meth(t){return this},$flags:{OneArg:!0}},__copy__:{$meth(){return this},$flags:{NoArgs:!0}}},getsets:{__dict__:G}});function infinite_lru_cache_wrapper(t,e){const n=_make_key(t,e,this.typed),r=this.cache.mp$lookup(n);return void 0!==r?(this.hits++,r):(this.misses++,E(A(this.func,t,e),(t=>(this.cache.mp$ass_subscript(n,t),t))))}function uncached_lru_cache_wrapper(t,e){return this.misses++,A(this.func,t,e)}function bounded_lru_cache_wrapper(t,e){const n=_make_key(t,e,this.typed),r=this.cache.mp$lookup(n);if(void 0!==r){const{result:t}=r;return lru_cache_extract_link(r),lru_cache_append_link(this,r),this.hits++,t}return this.misses++,E(A(this.func,t,e),(t=>{if(void 0!==this.cache.mp$lookup(n))return t;if(this.cache.get$size()<this.maxsize||this.root.next===this.root){const e={key:n,result:t};return this.cache.mp$ass_subscript(n,e),lru_cache_append_link(this,e),t}const e=this.root.next;lru_cache_extract_link(e);if(void 0===this.cache.pop$item(e.key))throw function lru_cache_prepend_link(t,e){const n=t.root,r=n.next;r.prev=n.next=e,e.prev=n,e.next=r}(this,e),new d(\"cached item removed unexpectedly\");return e.key=n,e.result=t,this.cache.mp$ass_subscript(n,e),lru_cache_append_link(this,e),t}))}function lru_cache_extract_link(t){const{prev:e,next:n}=t;e.next=t.next,n.prev=t.prev}function lru_cache_append_link(t,e){const n=t.root,r=n.prev;r.next=n.prev=e,e.prev=r,e.next=n}const J=q(\"_HachedSeq\",{base:s,constructor:function _HachedSeq(t){this.$hashval=C(new a(t)),s.call(this,t)},slots:{tp$hash(){return this.$hashval}}}),Q=new e,X=new Set([n,r]);function _make_key(t,e,n){const s=t.slice(0),i=[];if(e&&e.length){s.push(Q);for(let t=0;t<e.length;t+=2){const n=e[t+1];i.push(n),s.push(new a([new r(e[t]),n]))}}if(P(n))s.push(...t.map((t=>t.ob$type)),...i.map((t=>t.ob$type)));else if(1===s.length&&X.has(s[0].ob$type))return s[0];return new J(s)}function partial_adjust_args_kwargs(t,e){if(t=this.arg_arr.concat(t),e){e=D(e);const t=this.kwdict.dict$copy();t.dict$merge(e),e=I(t)}else e=I(this.kwdict);return{args:t,kwargs:e}}function partial_new(t,e){if(t.length<1)throw new h(\"type 'partial' takes at least 1 argument\");let n,r,s=t.shift();if(s instanceof this.sk$builtinBase){const t=s;s=t.fn,n=t.arg_arr,r=t.kwdict}this.check$func(s),n&&(t=n.concat(t));let a=D(e=e||[]);if(r){const t=r.dict$copy();t.dict$merge(a),a=t}if(this.sk$builtinBase===this.constructor)return new this.constructor(s,t,a);{const e=new this.constructor;return this.sk$builtinBase.call(e,s,t,a),e}}function partial_repr(){if(this.in$repr)return new r(\"...\");this.in$repr=!0;const t=[R(this.fn)];return this.arg_arr.forEach((e=>{t.push(R(e))})),this.kwdict.$items().forEach((([e,n])=>{t.push(e.toString()+\"=\"+R(n))})),this.in$repr=!1,new r(this.tp$name+\"(\"+t.join(\", \")+\")\")}t.partial=q(\"functools.partial\",{constructor:function partial(t,e,n){this.fn=t,this.arg_arr=e,this.arg_tup=new a(e),this.kwdict=n,this.in$repr=!1,this.$d=new i([])},slots:{tp$new:partial_new,tp$call(t,e){return({args:t,kwargs:e}=this.adj$args_kws(t,e)),this.fn.tp$call(t,e)},tp$doc:\"partial(func, *args, **keywords) - new function with partial application\\n    of the given arguments and keywords.\\n\",$r:partial_repr,tp$getattr:B,tp$setattr:K},getsets:{func:{$get(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:G},methods:{},classmethods:Sk.generic.classGetItem,proto:{adj$args_kws:partial_adjust_args_kwargs,check$func(t){if(!k(t))throw new h(\"the first argument must be callable\")}}}),t.partialmethod=q(\"functools.partialmethod\",{constructor:function partialmethod(t,e,n){this.fn=t,this.arg_arr=e,this.arg_tup=new a(e),this.kwdict=n},slots:{tp$new:partial_new,tp$doc:\"Method descriptor with partial application of the given arguments\\n    and keywords.\\n\\n    Supports wrapping existing descriptors and handles non-descriptor\\n    callables as instance methods.\\n    \",$r:partial_repr,tp$descr_get(e,n){let r;if(this.fn.tp$descr_get){const s=this.fn.tp$descr_get(e,n);if(s!==this.fn){if(!k(s))throw new h(\"type 'partial' requires a callable\");r=new t.partial(s,this.arg_arr.slice(0),this.kwdict.dict$copy());const e=M(s,this.str$self);void 0!==e&&r.tp$setattr(this.str$self,e)}}return void 0===r&&(r=this.make$unbound().tp$descr_get(e,n)),r}},methods:{_make_unbound_method:{$meth(){return this.make$unbound()},$flags:{NoArgs:!0}}},classmethods:Sk.generic.classGetItem,getsets:{func:{$get(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:G},proto:{str$self:new r(\"__self__\"),make$unbound(){const t=this;function _method(e,n){const r=e.shift();return({args:e,kwargs:n}=t.adj$args_kws(e,n)),e.unshift(r),A(t.fn,e,n)}return _method.co_fastcall=!0,new p(_method)},adj$args_kws:partial_adjust_args_kwargs,check$func(t){if(!k(t)&&void 0===t.tp$descr_get)throw new h(R(t)+\" is not callable or a descriptor\")}}});const Y={__lt__:r.$lt,__le__:r.$le,__gt__:r.$gt,__ge__:r.$ge};function from_slot(t,e){const n=Y[t];function compare_slot(t,r){let s=x(t.tp$getattr(n),[r]);return s===_?s:(s=P(s),new l(e(s,t,r)))}return compare_slot.co_name=n,compare_slot}const Z=from_slot(\"__lt__\",((t,e,n)=>!t&&j(e,n,\"NotEq\"))),tt=from_slot(\"__lt__\",((t,e,n)=>t||j(e,n,\"Eq\"))),et=from_slot(\"__lt__\",(t=>!t)),nt=from_slot(\"__le__\",((t,e,n)=>!t||j(e,n,\"Eq\"))),rt=from_slot(\"__le__\",((t,e,n)=>t&&j(e,n,\"NotEq\"))),st=from_slot(\"__le__\",(t=>!t)),at=from_slot(\"__gt__\",((t,e,n)=>!t&&j(e,n,\"NotEq\"))),it=from_slot(\"__gt__\",((t,e,n)=>t||j(e,n,\"Eq\"))),ot=from_slot(\"__gt__\",(t=>!t)),ct=from_slot(\"__ge__\",((t,e,n)=>!t||j(e,n,\"Eq\"))),_t=from_slot(\"__ge__\",((t,e,n)=>t&&j(e,n,\"NotEq\"))),lt=from_slot(\"__ge__\",(t=>!t)),pt={__lt__:{__gt__:new p(Z),__le__:new p(tt),__ge__:new p(et)},__le__:{__ge__:new p(nt),__lt__:new p(rt),__gt__:new p(st)},__gt__:{__lt__:new p(at),__ge__:new p(it),__le__:new p(ot)},__ge__:{__le__:new p(ct),__gt__:new p(_t),__lt__:new p(lt)}},ut={__lt__:\"ob$lt\",__le__:\"ob$le\",__gt__:\"ob$gt\",__ge__:\"ob$ge\"};const ht=new n(0),dt=q(\"functools.KeyWrapper\",{constructor:function(t,e){this.cmp=t,this.obj=e},slots:{tp$call(t,e){const[n]=W(\"K\",[\"obj\"],t,e,[]);return new dt(this.cmp,n)},tp$richcompare(t,e){if(!(t instanceof dt))throw new h(\"other argument must be K instance\");const n=this.obj,r=t.obj;if(!n||!r)throw new w(\"object\");const s=A(this.cmp,[n,r]);return E(s,(t=>j(t,ht,e)))},tp$getattr:B,tp$hash:o},getsets:{obj:{$get(){return this.obj||o},$set(t){this.obj=t},$doc:\"Value wrapped by a key function.\"}}}),ft=new r(\"update\"),mt=new r(\"__wrapped__\");return T(\"functools\",t,{cache:{$meth:function cache(t){return A(_lru_cache(o),[t])},$flags:{OneArg:!0},$doc:'Simple lightweight unbounded cache.  Sometimes called \"memoize\".',$textsig:\"($module, user_function, /)\"},lru_cache:{$meth:_lru_cache,$flags:{NamedArgs:[\"maxsize\",\"typed\"],Defaults:[new n(128),c]},$doc:\"Least-recently-used cache decorator.\\n\\nIf *maxsize* is set to None, the LRU features are disabled and the cache\\ncan grow without bound.\\n\\nIf *typed* is True, arguments of different types will be cached separately.\\nFor example, f(3.0) and f(3) will be treated as distinct calls with\\ndistinct results.\\n\\nArguments to the cached function must be hashable.\\n\\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\\nAccess the underlying function with f.__wrapped__.\\n\\nSee:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\"},cmp_to_key:{$meth:function cmp_to_key(t){return new dt(t)},$flags:{NamedArgs:[\"mycmp\"],Defaults:[]},$doc:\"Convert a cmp= function into a key= function.\",$textsig:\"($module, cmp, /)\"},reduce:{$meth:function reduce(t,e,n){const r=U(e);let s;return n=n||r.tp$iternext(!0),E(n,(e=>{if(void 0===e)throw new h(\"reduce() of empty sequence with no initial value\");return s=e,S(r,(e=>E(A(t,[s,e]),(t=>{s=t}))))}),(()=>s))},$flags:{MinArgs:2,MaxArgs:3},$doc:\"reduce(function, sequence[, initial]) -> value\\n\\nApply a function of two arguments cumulatively to the items of a sequence,\\nfrom left to right, so as to reduce the sequence to a single value.\\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\\nof the sequence in the calculation, and serves as a default when the\\nsequence is empty.\",$textsig:\"($module, function, sequence[, initial], /)\"},total_ordering:{$meth:function total_ordering(t){const n=[];if(!b(t))throw new h(\"total ordering only supported for type objects not '\"+F(t)+\"'\");if(Object.keys(pt).forEach((r=>{const s=ut[r];t.prototype[s]!==e.prototype[s]&&n.push(r)})),!n.length)throw new f(\"must define atleast one ordering operation: <, >, <=, >=\");const r=n[0];return Object.entries(pt[r]).forEach((([e,r])=>{n.includes(e)||t.tp$setattr(Y[e],r)})),t},$flags:{OneArg:!0},$doc:\"Class decorator that fills in missing ordering methods\"},update_wrapper:{$meth:function update_wrapper(t,e,n,r){let s,a=U(n);for(let i=a.tp$iternext();void 0!==i;i=a.tp$iternext())void 0!==(s=e.tp$getattr(i))&&t.tp$setattr(i,s);a=U(r);for(let o=a.tp$iternext();void 0!==o;o=a.tp$iternext()){s=e.tp$getattr(o)||new i([]);const n=O(t,o),r=O(n,ft);x(r,[s])}return t.tp$setattr(mt,e),t},$flags:{NamedArgs:[\"wrapper\",\"wrapped\",\"assigned\",\"updated\"],Defaults:[t.WRAPPER_ASSIGNMENTS,t.WRAPPER_UPDATES]},$doc:\"Update a wrapper function to look like the wrapped function\\n\\n       wrapper is the function to be updated\\n       wrapped is the original function\\n       assigned is a tuple naming the attributes assigned directly\\n       from the wrapped function to the wrapper function (defaults to\\n       functools.WRAPPER_ASSIGNMENTS)\\n       updated is a tuple naming the attributes of the wrapper that\\n       are updated with the corresponding attribute from the wrapped\\n       function (defaults to functools.WRAPPER_UPDATES)\\n    \",$textsig:\"($module, /, wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"},wraps:{$meth:function wraps(e,n,r){const s=[\"wrapped\",e,\"assigned\",n,\"updated\",r];return A(t.partial,[t.update_wrapper],s)},$flags:{NamedArgs:[\"wrapped\",\"assigned\",\"updated\"],Defaults:[t.WRAPPER_ASSIGNMENTS,t.WRAPPER_UPDATES]},$doc:\"Decorator factory to apply update_wrapper() to a wrapper function\\n\\n       Returns a decorator that invokes update_wrapper() with the decorated\\n       function as the wrapper argument and the arguments to wraps() as the\\n       remaining arguments. Default arguments are as for update_wrapper().\\n       This is a convenience function to simplify applying partial() to\\n       update_wrapper().\\n    \",$textsig:\"($module, /, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"}}),t}","src/lib/image.js":"var ImageMod,$builtinmodule;ImageMod||((ImageMod={}).canvasLib=[]),$builtinmodule=function(e){var n,i,t,a,u,l,r,c={__name__:new Sk.builtin.str(\"image\")};return c.Image=Sk.misceval.buildClass(c,(function(e,n){u=function(e){e.width=e.image.width,e.height=e.image.height,e.delay=0,e.updateCount=0,e.updateInterval=1,e.lastx=0,e.lasty=0,e.canvas=document.createElement(\"canvas\"),e.canvas.height=e.height,e.canvas.width=e.width,e.ctx=e.canvas.getContext(\"2d\"),e.ctx.drawImage(e.image,0,0),e.imagedata=e.ctx.getImageData(0,0,e.width,e.height)},n.__init__=new Sk.builtin.func((function(e,n){var i;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2);try{e.image=document.getElementById(Sk.ffi.remapToJs(n)),null==e.image&&(e.image=document.querySelector(`[data-filename=\"${Sk.ffi.remapToJs(n)}\"]`)),u(e)}catch(t){e.image=null}if(null==e.image)return(i=new Sk.misceval.Suspension).resume=function(){if(i.data.error)throw new Sk.builtin.IOError(i.data.error.message)},i.data={type:\"Sk.promise\",promise:new Promise((function(i,t){var a=new Image;a.crossOrigin=\"\",a.onerror=function(){t(Error(\"Failed to load URL: \"+a.src))},a.onload=function(){e.image=this,u(e),i()},a.src=r(n)}))},i})),r=function(e){let n=Sk.ffi.remapToJs(e);try{let e=Sk.read(n);return`data:image/${n.substring(n.lastIndexOf(\".\")+1)};base64, ${e}`}catch(u){console.log(`${n} is not in the database ${u}`)}var i,t,a=\"function\"==typeof Sk.imageProxy?Sk.imageProxy:function(e){return(i=document.createElement(\"a\")).href=t,window.location.host!==i.host?Sk.imageProxy+\"/\"+e:e};return t=a(t=Sk.ffi.remapToJs(e))},l=function(e,n,i){if(n<0||i<0||n>=e.width||i>=e.height)throw new Sk.builtin.ValueError(\"Pixel index out of range.\")};var setdelay=function(e,n,i){var t;Sk.builtin.pyCheckArgsLen(\"setdelay\",arguments.length,2,3),e.delay=Sk.ffi.remapToJs(n),t=Sk.builtin.asnum$(i),e.updateInterval=t||1};n.set_delay=new Sk.builtin.func(setdelay),n.setDelay=new Sk.builtin.func(setdelay);var getpixels=function(e){var n,i=[];for(Sk.builtin.pyCheckArgsLen(\"getpixels\",arguments.length,1,1),n=0;n<e.image.height*e.image.width;n++)i[n]=Sk.misceval.callsimArray(e.getPixel,[e,n%e.image.width,Math.floor(n/e.image.width)]);return new Sk.builtin.tuple(i)};n.get_pixels=new Sk.builtin.func(getpixels),n.getPixels=new Sk.builtin.func(getpixels),n.getData=new Sk.builtin.func((function(e){var n,i,t,a,u,r,c,s=[];for(Sk.builtin.pyCheckArgsLen(\"getData\",arguments.length,1,1),n=0;n<e.image.height*e.image.width;n++)i=n%e.image.width,t=Math.floor(n/e.image.width),l(e,i,t),c=4*t*e.width+4*i,a=e.imagedata.data[c],u=e.imagedata.data[c+1],r=e.imagedata.data[c+2],s[n]=new Sk.builtin.tuple([new Sk.builtin.int_(a),new Sk.builtin.int_(u),new Sk.builtin.int_(r)]);return new Sk.builtin.list(s)}));var getpixel=function(e,n,i){var t,a,u,r;return Sk.builtin.pyCheckArgsLen(\"getpixel\",arguments.length,3,3),n=Sk.builtin.asnum$(n),i=Sk.builtin.asnum$(i),l(e,n,i),r=4*i*e.width+4*n,t=e.imagedata.data[r],u=e.imagedata.data[r+1],a=e.imagedata.data[r+2],Sk.misceval.callsimArray(c.Pixel,[t,u,a,n,i])};n.get_pixel=new Sk.builtin.func(getpixel),n.getPixel=new Sk.builtin.func(getpixel),a=function(e,n,i){var t=new Sk.misceval.Suspension;return t.resume=function(){return Sk.builtin.none.none$},t.data={type:\"Sk.promise\",promise:new Promise((function(n,i){e.updateCount++,e.updateCount%e.updateInterval==0||e.updateCount===e.width*e.height?(e.lastCtx.putImageData(e.imagedata,0,0),e.delay>0?window.setTimeout(n,e.delay):n()):n()}))},t};var setpixel=function(e,n,i,t){var u;return Sk.builtin.pyCheckArgsLen(\"setpixel\",arguments.length,4,4),n=Sk.builtin.asnum$(n),i=Sk.builtin.asnum$(i),l(e,n,i),u=4*i*e.width+4*n,e.imagedata.data[u]=Sk.builtin.asnum$(Sk.misceval.callsimArray(t.getRed,[t])),e.imagedata.data[u+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(t.getGreen,[t])),e.imagedata.data[u+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(t.getBlue,[t])),e.imagedata.data[u+3]=255,a(e)};n.set_pixel=new Sk.builtin.func(setpixel),n.setPixel=new Sk.builtin.func(setpixel);var setpixelat=function(e,n,i){var t,u,r;return Sk.builtin.pyCheckArgsLen(\"setpixelat\",arguments.length,3,3),t=(n=Sk.builtin.asnum$(n))%e.image.width,u=Math.floor(n/e.image.width),l(e,t,u),r=4*u*e.width+4*t,e.imagedata.data[r]=Sk.builtin.asnum$(Sk.misceval.callsimArray(i.getRed,[i])),e.imagedata.data[r+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(i.getGreen,[i])),e.imagedata.data[r+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(i.getBlue,[i])),e.imagedata.data[r+3]=255,a(e)};n.set_pixel_at=new Sk.builtin.func(setpixelat),n.setPixelAt=new Sk.builtin.func(setpixelat);var updatepixel=function(e,n){var i,t,u;return Sk.builtin.pyCheckArgsLen(\"updatepixel\",arguments.length,2,2),i=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getX,[n])),t=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getY,[n])),l(e,i,t),u=4*t*e.width+4*i,e.imagedata.data[u]=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getRed,[n])),e.imagedata.data[u+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getGreen,[n])),e.imagedata.data[u+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(n.getBlue,[n])),e.imagedata.data[u+3]=255,a(e)};n.update_pixel=new Sk.builtin.func(updatepixel),n.updatePixel=new Sk.builtin.func(updatepixel);var getheight=function(e){return Sk.builtin.pyCheckArgsLen(\"getheight\",arguments.length,1,1),new Sk.builtin.int_(e.height)};n.get_height=new Sk.builtin.func(getheight),n.getHeight=new Sk.builtin.func(getheight);var getwidth=function(e,n){return Sk.builtin.pyCheckArgsLen(\"getwidth\",arguments.length,1,1),new Sk.builtin.int_(e.width)};n.get_width=new Sk.builtin.func(getwidth),n.getWidth=new Sk.builtin.func(getwidth),n.__getattr__=new Sk.builtin.func((function(e,n){return\"height\"===(n=Sk.ffi.remapToJs(n))?Sk.builtin.assk$(e.height):\"width\"===n?Sk.builtin.assk$(e.width):void 0})),n.__setattr__=new Sk.builtin.func((function(e,n,i){throw\"height\"===(n=Sk.ffi.remapToJs(n))||\"width\"===n?new Sk.builtin.Exception(\"Cannot change height or width they can only be set on creation\"):new Sk.builtin.Exception(\"Unknown attribute: \"+n)})),n.draw=new Sk.builtin.func((function(e,n,i,t){var a;return Sk.builtin.pyCheckArgsLen(\"draw\",arguments.length,2,4),(a=new Sk.misceval.Suspension).resume=function(){return Sk.builtin.none.none$},a.data={type:\"Sk.promise\",promise:new Promise((function(a,u){var l;n=Sk.builtin.asnum$(n),i=Sk.builtin.asnum$(i),t=Sk.builtin.asnum$(t),l=Sk.misceval.callsimArray(n.getWin,[n]).getContext(\"2d\"),void 0===i&&(i=0,t=0),e.lastUlx=i,e.lastUly=t,e.lastCtx=l,l.putImageData(e.imagedata,i,t),e.delay>0?window.setTimeout(a,e.delay):window.setTimeout(a,200)}))},a}))}),\"Image\",[]),t=function(e,n){n.__init__=new Sk.builtin.func((function(e,n,i){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,3,3),e.width=Sk.builtin.asnum$(n),e.height=Sk.builtin.asnum$(i),e.canvas=document.createElement(\"canvas\"),e.ctx=e.canvas.getContext(\"2d\"),e.canvas.height=e.height,e.canvas.width=e.width,e.imagedata=e.ctx.getImageData(0,0,e.width,e.height)}))},c.EmptyImage=Sk.misceval.buildClass(c,t,\"EmptyImage\",[c.Image]),i=function(e,n){n.__init__=new Sk.builtin.func((function(e,n,i,t,a,u){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,4,6),e.red=Sk.builtin.asnum$(n),e.green=Sk.builtin.asnum$(i),e.blue=Sk.builtin.asnum$(t),e.x=Sk.builtin.asnum$(a),e.y=Sk.builtin.asnum$(u)}));var getred=function(e){return Sk.builtin.pyCheckArgsLen(\"getred\",arguments.length,1,1),Sk.builtin.assk$(e.red)};n.get_red=new Sk.builtin.func(getred),n.getRed=new Sk.builtin.func(getred);var getgreen=function(e){return Sk.builtin.pyCheckArgsLen(\"getgreen\",arguments.length,1,1),Sk.builtin.assk$(e.green)};n.get_green=new Sk.builtin.func(getgreen),n.getGreen=new Sk.builtin.func(getgreen);var getblue=function(e){return Sk.builtin.pyCheckArgsLen(\"getblue\",arguments.length,1,1),Sk.builtin.assk$(e.blue)};n.get_blue=new Sk.builtin.func(getblue),n.getBlue=new Sk.builtin.func(getblue);var getx=function(e){return Sk.builtin.pyCheckArgsLen(\"getx\",arguments.length,1,1),Sk.builtin.assk$(e.x)};n.get_x=new Sk.builtin.func(getx),n.getX=new Sk.builtin.func(getx);var gety=function(e){return Sk.builtin.pyCheckArgsLen(\"gety\",arguments.length,1,1),Sk.builtin.assk$(e.y)};n.get_y=new Sk.builtin.func(gety),n.getY=new Sk.builtin.func(gety);var setred=function(e,n){Sk.builtin.pyCheckArgsLen(\"setred\",arguments.length,2,2),e.red=Sk.builtin.asnum$(n)};n.set_red=new Sk.builtin.func(setred),n.setRed=new Sk.builtin.func(setred);var setgreen=function(e,n){Sk.builtin.pyCheckArgsLen(\"setgreen\",arguments.length,2,2),e.green=Sk.builtin.asnum$(n)};n.set_green=new Sk.builtin.func(setgreen),n.setGreen=new Sk.builtin.func(setgreen);var setblue=function(e,n){Sk.builtin.pyCheckArgsLen(\"setblue\",arguments.length,2,2),e.blue=Sk.builtin.asnum$(n)};n.set_blue=new Sk.builtin.func(setblue),n.setBlue=new Sk.builtin.func(setblue),n.__getattr__=new Sk.builtin.func((function(e,n){return\"red\"===(n=Sk.ffi.remapToJs(n))?Sk.builtin.assk$(e.red):\"green\"===n?Sk.builtin.assk$(e.green):\"blue\"===n?Sk.builtin.assk$(e.blue):void 0})),n.__setattr__=new Sk.builtin.func((function(e,n,i){\"red\"!==(n=Sk.ffi.remapToJs(n))&&\"green\"!==n&&\"blue\"!==n||(e[n]=Sk.builtin.asnum$(i))}));var setx=function(e,n){Sk.builtin.pyCheckArgsLen(\"setx\",arguments.length,2,2),e.x=Sk.builtin.asnum$(n)};n.set_x=new Sk.builtin.func(setx),n.setX=new Sk.builtin.func(setx);var sety=function(e,n){Sk.builtin.pyCheckArgsLen(\"sety\",arguments.length,2,2),e.y=Sk.builtin.asnum$(n)};n.set_y=new Sk.builtin.func(sety),n.setY=new Sk.builtin.func(sety),n.__getitem__=new Sk.builtin.func((function(e,n){return 0===(n=Sk.builtin.asnum$(n))?e.red:1==n?e.green:2==n?e.blue:void 0})),n.__str__=new Sk.builtin.func((function(e){return Sk.ffi.remapToPy(\"[\"+e.red+\",\"+e.green+\",\"+e.blue+\"]\")})),n.getColorTuple=new Sk.builtin.func((function(e,n,i){})),n.setRange=new Sk.builtin.func((function(e,n){e.max=Sk.builtin.asnum$(n)}))},c.Pixel=Sk.misceval.buildClass(c,i,\"Pixel\",[]),n=function(e,n){n.__init__=new Sk.builtin.func((function(e,n,i){var t,a,u;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,1,3),void 0===(t=ImageMod.canvasLib[Sk.canvas])?(a=document.createElement(\"canvas\"),u=document.getElementById(Sk.canvas),e.theScreen=a,u.appendChild(a),ImageMod.canvasLib[Sk.canvas]=a,ImageMod.canvasLib[Sk.canvas]=e.theScreen):(e.theScreen=t,e.theScreen.height=e.theScreen.height),void 0!==n?(e.theScreen.height=i.v,e.theScreen.width=n.v):(Sk.availableHeight&&(e.theScreen.height=Sk.availableHeight),Sk.availableWidth&&(e.theScreen.width=Sk.availableWidth)),e.theScreen.style.display=\"block\"})),n.getWin=new Sk.builtin.func((function(e){return e.theScreen})),n.exitonclick=new Sk.builtin.func((function(e){var n=e.theScreen.id;e.theScreen.onclick=function(){document.getElementById(n).style.display=\"none\",document.getElementById(n).onclick=null,delete ImageMod.canvasLib[n]}}))},c.ImageWin=Sk.misceval.buildClass(c,n,\"ImageWin\",[]),c};","src/lib/itertools.js":"var $builtinmodule=function(t){var e={};function combinationsNew(t,e,i){let r,s;[r,s]=Sk.abstr.copyKeywordsToNamedArgs(t.tp$name,[\"iterable\",\"r\"],e,i,[]);const n=Sk.misceval.arrayFromIterable(r);if(s=Sk.misceval.asIndexSized(s,Sk.builtin.OverFlowError),s<0)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===t)return new t.constructor(n,s);{const e=new this.constructor;return t.constructor.call(e,n,s),e}}return e.accumulate=Sk.abstr.buildIteratorClass(\"itertools.accumulate\",{constructor:function accumulate(t,e,i){this.iter=t,this.func=e,this.total=i,this.tp$iternext=()=>(this.total=Sk.builtin.checkNone(this.total)?this.iter.tp$iternext():this.total,this.tp$iternext=this.constructor.prototype.tp$iternext,this.total)},iternext(t){let e=this.iter.tp$iternext();if(void 0!==e)return this.total=Sk.misceval.callsimArray(this.func,[this.total,e]),this.total},slots:{tp$doc:\"accumulate(iterable[, func, initial]) --\\x3e accumulate object\\n\\nReturn series of accumulated sums (or other binary function results).\",tp$new(t,i){Sk.abstr.checkArgsLen(\"accumulate\",t,0,2);let[r,s,n]=Sk.abstr.copyKeywordsToNamedArgs(\"accumulate\",[\"iterable\",\"func\",\"initial\"],t,i,[Sk.builtin.none.none$,Sk.builtin.none.none$]);if(r=Sk.abstr.iter(r),s=Sk.builtin.checkNone(s)?new Sk.builtin.func(((t,e)=>Sk.abstr.numberBinOp(t,e,\"Add\"))):s,this===e.accumulate.prototype)return new e.accumulate(r,s,n);{const t=new this.constructor;return e.accumulate.call(t,r,s,n),t}}}}),e.chain=Sk.abstr.buildIteratorClass(\"itertools.chain\",{constructor:function chain(t){this.iterables=t,this.current_it=null,this.tp$iternext=()=>{if(this.tp$iternext=this.constructor.prototype.tp$iternext,this.current_it=this.iterables.tp$iternext(),void 0!==this.current_it)return this.current_it=Sk.abstr.iter(this.current_it),this.tp$iternext();this.tp$iternext=()=>{}}},iternext(t){let e;for(;void 0===e;){if(e=this.current_it.tp$iternext(),void 0!==e)return e;if(this.current_it=this.iterables.tp$iternext(),void 0===this.current_it)return void(this.tp$iternext=()=>{});this.current_it=Sk.abstr.iter(this.current_it)}},slots:{tp$doc:\"chain(*iterables) --\\x3e chain object\\n\\nReturn a chain object whose .__next__() method returns elements from the\\nfirst iterable until it is exhausted, then elements from the next\\niterable, until all of the iterables are exhausted.\",tp$new(t,i){if(Sk.abstr.checkNoKwargs(\"chain\",i),t=new Sk.builtin.tuple(t.slice(0)).tp$iter(),this===e.chain.prototype)return new e.chain(t);{const i=new this.constructor;return e.chain.call(i,t),i}}},classmethods:Object.assign({from_iterable:{$meth(t){const i=Sk.abstr.iter(t);return new e.chain(i)},$flags:{OneArg:!0},$doc:\"chain.from_iterable(iterable) --\\x3e chain object\\n\\nAlternate chain() constructor taking a single iterable argument\\nthat evaluates lazily.\",$textsig:null}},Sk.generic.classGetItem)}),e.combinations=Sk.abstr.buildIteratorClass(\"itertools.combinations\",{constructor:function combinations(t,e){this.pool=t,this.r=e,this.indices=new Array(e).fill().map(((t,e)=>e)),this.n=t.length,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(t){let e,i=!1;for(e=this.r-1;e>=0;e--)if(this.indices[e]!=e+this.n-this.r){i=!0;break}if(!i)return void(this.r=0);this.indices[e]++;for(let s=e+1;s<this.r;s++)this.indices[s]=this.indices[s-1]+1;const r=this.indices.map((t=>this.pool[t]));return new Sk.builtin.tuple(r)},slots:{tp$doc:\"combinations(iterable, r) --\\x3e combinations object\\n\\nReturn successive r-length combinations of elements in the iterable.\\n\\ncombinations(range(4), 3) --\\x3e (0,1,2), (0,1,3), (0,2,3), (1,2,3)\",tp$new(t,i){return combinationsNew.call(this,e.combinations.prototype,t,i)}}}),e.combinations_with_replacement=Sk.abstr.buildIteratorClass(\"itertools.combinations_with_replacement\",{constructor:function combinations_with_replacement(t,e){this.pool=t,this.r=e,this.indices=new Array(e).fill(0),this.n=t.length,this.tp$iternext=()=>{if(this.r&&!this.n)return;this.tp$iternext=this.constructor.prototype.tp$iternext;const t=this.indices.map((t=>this.pool[t]));return new Sk.builtin.tuple(t)}},iternext(t){let e,i=!1;for(e=this.r-1;e>=0;e--)if(this.indices[e]!=this.n-1){i=!0;break}if(!i)return void(this.r=0);const r=this.indices[e]+1;for(let n=e;n<this.r;n++)this.indices[n]=r;const s=this.indices.map((t=>this.pool[t]));return new Sk.builtin.tuple(s)},slots:{tp$doc:\"combinations_with_replacement(iterable, r) --\\x3e combinations_with_replacement object\\n\\nReturn successive r-length combinations of elements in the iterable\\nallowing individual elements to have successive repeats.\\ncombinations_with_replacement('ABC', 2) --\\x3e AA AB AC BB BC CC\",tp$new(t,i){return combinationsNew.call(this,e.combinations_with_replacement.prototype,t,i)}}}),e.compress=Sk.abstr.buildIteratorClass(\"itertools.compress\",{constructor:function compress(t,e){this.data=t,this.selectors=e},iternext(){let t=this.data.tp$iternext(),e=this.selectors.tp$iternext();for(;void 0!==t&&void 0!==e;){if(Sk.misceval.isTrue(e))return t;t=this.data.tp$iternext(),e=this.selectors.tp$iternext()}},slots:{tp$doc:\"compress(data, selectors) --\\x3e iterator over selected data\\n\\nReturn data elements corresponding to true selector elements.\\nForms a shorter iterator from selected data elements using the\\nselectors to choose the data elements.\",tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"compress\",[\"data\",\"selectors\"],t,i,[]),r=Sk.abstr.iter(r),s=Sk.abstr.iter(s),this===e.count.prototype)return new e.compress(r,s);{const t=new this.constructor;return e.compress.call(t,r,s),t}}}}),e.count=Sk.abstr.buildIteratorClass(\"itertools.count\",{constructor:function count(t,e){this.start=t,this.step=e},iternext(){const t=this.start;return this.start=Sk.abstr.numberBinOp(this.start,this.step,\"Add\"),t},slots:{tp$doc:\"count(start=0, step=1) --\\x3e count object\\n\\nReturn a count object whose .__next__() method returns consecutive values.\\nEquivalent to:\\n\\n    def count(firstval=0, step=1):\\n        x = firstval\\n        while 1:\\n            yield x\\n            x += step\\n\",tp$new(t,i){const[r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"count\",[\"start\",\"step\"],t,i,[new Sk.builtin.int_(0),new Sk.builtin.int_(1)]);if(!Sk.builtin.checkNumber(r)&&!Sk.builtin.checkComplex(r))throw new Sk.builtin.TypeError(\"a number is required\");if(!Sk.builtin.checkNumber(s)&&!Sk.builtin.checkComplex(s))throw new Sk.builtin.TypeError(\"a number is required\");if(this===e.count.prototype)return new e.count(r,s);{const t=new this.constructor;return e.count.call(t,r,s),t}},$r(){const t=Sk.misceval.objectRepr(this.start);let e=Sk.misceval.objectRepr(this.step);return e=\"1\"===e?\"\":\", \"+e,new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+e+\")\")}}}),e.cycle=Sk.abstr.buildIteratorClass(\"itertools.cycle\",{constructor:function cycle(t){this.iter=t,this.saved=[],this.consumed=!1,this.i=0,this.length},iternext(){let t;if(!this.consumed){if(t=this.iter.tp$iternext(),void 0!==t)return this.saved.push(t),t;if(this.consumed=!0,this.length=this.saved.length,!this.length)return}return t=this.saved[this.i],this.i=(this.i+1)%this.length,t},slots:{tp$doc:\"cycle(iterable) --\\x3e cycle object\\n\\nReturn elements from the iterable until it is exhausted.\\nThen repeat the sequence indefinitely.\",tp$new(t,i){Sk.abstr.checkOneArg(\"cycle\",t,i);const r=Sk.abstr.iter(t[0]);if(this===e.cycle.prototype)return new e.cycle(r);{const t=new this.constructor;return e.cycle.call(t,r),t}}}}),e.dropwhile=Sk.abstr.buildIteratorClass(\"itertools.dropwhile\",{constructor:function dropwhile(t,e){this.predicate=t,this.iter=e,this.passed},iternext(){let t=this.iter.tp$iternext();for(;void 0===this.passed&&void 0!==t;){const e=Sk.misceval.callsimArray(this.predicate,[t]);if(!Sk.misceval.isTrue(e))return this.passed=!0,t;t=this.iter.tp$iternext()}return t},slots:{tp$doc:\"dropwhile(predicate, iterable) --\\x3e dropwhile object\\n\\nDrop items from the iterable while predicate(item) is true.\\nAfterwards, return every element until the iterable is exhausted.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"dropwhile\",i),Sk.abstr.checkArgsLen(\"dropwhile\",t,2,2);const r=t[0],s=Sk.abstr.iter(t[1]);if(this===e.dropwhile.prototype)return new e.dropwhile(r,s);{const t=new this.constructor;return e.dropwhile.call(t,r,s),t}}}}),e.filterfalse=Sk.abstr.buildIteratorClass(\"itertools.filterfalse\",{constructor:function filterfalse(t,e){this.predicate=t,this.iter=e},iternext(t){let e=this.iter.tp$iternext();if(void 0===e)return;let i=Sk.misceval.callsimArray(this.predicate,[e]);for(;Sk.misceval.isTrue(i);){if(e=this.iter.tp$iternext(),void 0===e)return;i=Sk.misceval.callsimArray(this.predicate,[e])}return e},slots:{tp$doc:\"filterfalse(function or None, sequence) --\\x3e filterfalse object\\n\\nReturn those items of sequence for which function(item) is false.\\nIf function is None, return the items that are false.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"filterfalse\",i),Sk.abstr.checkArgsLen(\"filterfalse\",t,2,2);const r=Sk.builtin.checkNone(t[0])?Sk.builtin.bool:t[0],s=Sk.abstr.iter(t[1]);if(this===e.filterfalse.prototype)return new e.filterfalse(r,s);{const t=new this.constructor;return e.filterfalse.call(t,r,s),t}}}}),e._grouper=Sk.abstr.buildIteratorClass(\"itertools._grouper\",{constructor:function _grouper(t,e){this.groupby=t,this.tgtkey=t.tgtkey,this.id=t.id},iternext(t){const e=Sk.misceval.richCompareBool(this.groupby.currkey,this.tgtkey,\"Eq\");if(this.groupby.id===this.id&&e){let t=this.groupby.currval;return this.groupby.currval=this.groupby.iter.tp$iternext(),void 0!==this.groupby.currval&&(this.groupby.currkey=Sk.misceval.callsimArray(this.groupby.keyf,[this.groupby.currval])),t}}}),e.groupby=Sk.abstr.buildIteratorClass(\"itertools.groupby\",{constructor:function groupby(t,e){this.iter=t,this.keyf=e,this.currval,this.currkey=this.tgtkey=new Sk.builtin.object,this.id},iternext(t){this.id=new Object;let i=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\");for(;i;){if(this.currval=this.iter.tp$iternext(),void 0===this.currval)return;this.currkey=Sk.misceval.callsimArray(this.keyf,[this.currval]),i=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\")}this.tgtkey=this.currkey;const r=new e._grouper(this);return new Sk.builtin.tuple([this.currkey,r])},slots:{tp$doc:\"groupby(iterable, key=None) -> make an iterator that returns consecutive\\nkeys and groups from the iterable.  If the key function is not specified or\\nis None, the element itself is used for grouping.\\n\",tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"groupby\",[\"iterable\",\"key\"],t,i,[Sk.builtin.none.none$]),r=Sk.abstr.iter(r),s=Sk.builtin.checkNone(s)?new Sk.builtin.func((t=>t)):s,this===e.groupby.prototype)return new e.groupby(r,s);{const t=new this.constructor;return e.groupby.call(t,r,s),t}}}}),e.islice=Sk.abstr.buildIteratorClass(\"itertools.islice\",{constructor:function islice(t,e,i,r){this.iter=t,this.previt=e,this.stop=i,this.step=r,this.tp$iternext=()=>{if(this.tp$iternext=this.constructor.prototype.tp$iternext,!(this.previt>=this.stop)){for(let t=0;t<this.previt;t++)this.iter.tp$iternext();return this.iter.tp$iternext()}for(let t=0;t<this.stop;t++)this.iter.tp$iternext()}},iternext(t){if(!(this.previt+this.step>=this.stop)){for(let t=this.previt+1;t<this.previt+this.step;t++)this.iter.tp$iternext();return this.previt+=this.step,this.iter.tp$iternext()}for(let e=this.previt+1;e<this.stop;e++)this.previt+=this.step,this.iter.tp$iternext()},slots:{tp$doc:\"islice(iterable, stop) --\\x3e islice object\\nislice(iterable, start, stop[, step]) --\\x3e islice object\\n\\nReturn an iterator whose next() method returns selected values from an\\niterable.  If start is specified, will skip all preceding elements;\\notherwise, start defaults to zero.  Step defaults to one.  If\\nspecified as another value, step determines how many values are \\nskipped between successive calls.  Works like a slice() on a list\\nbut returns an iterator.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"islice\",i),Sk.abstr.checkArgsLen(\"islice\",t,2,4);const r=Sk.abstr.iter(t[0]);let s=t[1],n=t[2],o=t[3];if(void 0===n?(n=s,s=Sk.builtin.none.none$,o=Sk.builtin.none.none$):void 0===o&&(o=Sk.builtin.none.none$),!Sk.builtin.checkNone(n)&&!Sk.misceval.isIndex(n))throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(n=Sk.builtin.checkNone(n)?Number.MAX_SAFE_INTEGER:Sk.misceval.asIndexSized(n),n<0||n>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(!Sk.builtin.checkNone(s)&&!Sk.misceval.isIndex(s))throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(s=Sk.builtin.checkNone(s)?0:Sk.misceval.asIndexSized(s),s<0||s>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(!Sk.builtin.checkNone(o)&&!Sk.misceval.isIndex(o))throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None\");if(o=Sk.builtin.checkNone(o)?1:Sk.misceval.asIndexSized(o),o<=0||o>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None.\");if(this===e.islice.prototype)return new e.islice(r,s,n,o);{const t=new this.constructor;return e.islice.call(t,r,s,n,o),t}}}}),e.permutations=Sk.abstr.buildIteratorClass(\"itertools.permutations\",{constructor:function permutations(t,e){this.pool=t,this.r=e;const i=t.length;this.indices=new Array(i).fill().map(((t,e)=>e)),this.cycles=new Array(e).fill().map(((t,e)=>i-e)),this.n=i,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(t){for(let e=this.r-1;e>=0;e--){if(this.cycles[e]--,0!=this.cycles[e]){const t=this.cycles[e];[this.indices[e],this.indices[this.n-t]]=[this.indices[this.n-t],this.indices[e]];const i=this.indices.map((t=>this.pool[t])).slice(0,this.r);return new Sk.builtin.tuple(i)}this.indices.push(this.indices.splice(e,1)[0]),this.cycles[e]=this.n-e}this.r=0},slots:{tp$doc:\"permutations(iterable[, r]) --\\x3e permutations object\\n\\nReturn successive r-length permutations of elements in the iterable.\\n\\npermutations(range(3), 2) --\\x3e (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)\",tp$new(t,i){let r,s;[r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"permutations\",[\"iterable\",\"r\"],t,i,[Sk.builtin.none.none$]);const n=Sk.misceval.arrayFromIterable(r);if(s=Sk.builtin.checkNone(s)?n.length:Sk.misceval.asIndexSized(s,Sk.builtin.OverFlowError),s<0)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===e.permutations.prototype)return new e.permutations(n,s);{const t=new this.constructor;return e.permutations.call(t,n,s),t}}}}),e.product=Sk.abstr.buildIteratorClass(\"itertools.product\",{constructor:function product(t){this.pools=t,this.n=t.length,this.indices=Array(t.length).fill(0),this.pool_sizes=t.map((t=>t.length)),this.tp$iternext=()=>{this.tp$iternext=this.constructor.prototype.tp$iternext;const t=this.indices.map(((t,e)=>this.pools[e][this.indices[e]]));if(!t.some((t=>void 0===t)))return new Sk.builtin.tuple(t);this.n=0}},iternext(t){let e=this.n-1;for(;e>=0&&e<this.n;)this.indices[e]++,this.indices[e]>=this.pool_sizes[e]?(this.indices[e]=-1,e--):e++;if(this.n&&!this.indices.every((t=>-1===t))){const t=this.indices.map(((t,e)=>this.pools[e][this.indices[e]]));return new Sk.builtin.tuple(t)}this.n=0},slots:{tp$doc:\"product(*iterables, repeat=1) --\\x3e product object\\n\\nCartesian product of input iterables.  Equivalent to nested for-loops.\\n\\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\\nThe leftmost iterators are in the outermost for-loop, so the output tuples\\ncycle in a manner similar to an odometer (with the rightmost element changing\\non every iteration).\\n\\nTo compute the product of an iterable with itself, specify the number\\nof repetitions with the optional repeat keyword argument. For example,\\nproduct(A, repeat=4) means the same as product(A, A, A, A).\\n\\nproduct('ab', range(3)) --\\x3e ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\\nproduct((0,1), (0,1), (0,1)) --\\x3e (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...\",tp$new(t,i){let[r]=Sk.abstr.copyKeywordsToNamedArgs(\"product\",[\"repeat\"],[],i,[new Sk.builtin.int_(1)]);if(r=Sk.misceval.asIndexSized(r,Sk.builtin.OverFlowError),r<0)throw new Sk.builtin.ValueError(\"repeat argument cannot be negative\");const s=[];for(let e=0;e<t.length;e++)s.push(Sk.misceval.arrayFromIterable(t[e]));const n=[].concat(...Array(r).fill(s));if(this===e.product.prototype)return new e.product(n);{const t=new this.constructor;return e.product.call(t,n),t}}}}),e.repeat=Sk.abstr.buildIteratorClass(\"itertools.repeat\",{constructor:function repeat(t,e){this.object=t,this.times=e,void 0===e&&(this.tp$iternext=()=>this.object)},iternext(t){return this.times-- >0?this.object:void 0},slots:{tp$doc:\"repeat(object [,times]) -> create an iterator which returns the object\\nfor the specified number of times.  If not specified, returns the object\\nendlessly.\",tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"repeat\",[\"object\",\"times\"],t,i,[null]),s=null!==s?Sk.misceval.asIndexSized(s,Sk.builtin.OverFlowError):void 0,this===e.repeat.prototype)return new e.repeat(r,s);{const t=new this.constructor;return e.repeat.call(t,r,s),t}},$r(){const t=Sk.misceval.objectRepr(this.object),e=void 0===this.times?\"\":\", \"+(this.times>=0?this.times:0);return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+t+e+\")\")}},methods:{__lenght_hint__:{$meth(){if(void 0===this.times)throw new Sk.builtin.TypeError(\"len() of unsized object\");return new Sk.builtin.int_(this.times)},$flags:{NoArgs:!0},$textsig:null}}}),e.starmap=Sk.abstr.buildIteratorClass(\"itertools.starmap\",{constructor:function starmap(t,e){this.func=t,this.iter=e},iternext(t){const e=this.iter.tp$iternext();if(void 0===e)return;const i=Sk.misceval.arrayFromIterable(e);return Sk.misceval.callsimArray(this.func,i)},slots:{tp$new(t,i){let r,s;if([r,s]=Sk.abstr.copyKeywordsToNamedArgs(\"starmap\",[\"func\",\"iterable\"],t,i,[]),s=Sk.abstr.iter(s),r=Sk.builtin.checkNone(r)?Sk.builtin.bool:r,this===e.starmap.prototype)return new e.starmap(r,s);{const t=new this.constructor;return e.starmap.call(t,r,s),t}}}}),e.takewhile=Sk.abstr.buildIteratorClass(\"itertools.takewhile\",{constructor:function takewhile(t,e){this.predicate=t,this.iter=e},iternext(){const t=this.iter.tp$iternext();if(void 0!==t){const e=Sk.misceval.callsimArray(this.predicate,[t]);if(Sk.misceval.isTrue(e))return t;this.tp$iternext=()=>{}}},slots:{tp$doc:\"takewhile(predicate, iterable) --\\x3e takewhile object\\n\\nReturn successive entries from an iterable as long as the \\npredicate evaluates to true for each entry.\",tp$new(t,i){Sk.abstr.checkNoKwargs(\"takewhile\",i),Sk.abstr.checkArgsLen(\"takewhile\",t,2,2);const r=t[0],s=Sk.abstr.iter(t[1]);if(this===e.takewhile.prototype)return new e.takewhile(r,s);{const t=new this.constructor;return e.takewhile.call(t,r,s),t}}}}),e.tee=new Sk.builtin.func((function(){throw new Sk.builtin.NotImplementedError(\"tee is not yet implemented in Skulpt\")})),e.zip_longest=Sk.abstr.buildIteratorClass(\"itertools.zip_longest\",{constructor:function zip_longest(t,e){this.iters=t,this.fillvalue=e,this.active=this.iters.length},iternext(t){if(!this.active)return;let i;const r=[];for(let s=0;s<this.iters.length;s++){if(i=this.iters[s].tp$iternext(),void 0===i){if(this.active--,!this.active)return;this.iters[s]=new e.repeat(this.fillvalue),i=this.fillvalue}r.push(i)}return new Sk.builtin.tuple(r)},slots:{tp$doc:\"zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --\\x3e zip_longest object\\n\\nReturn a zip_longest object whose .__next__() method returns a tuple where\\nthe i-th element comes from the i-th iterable argument.  The .__next__()\\nmethod continues until the longest iterable in the argument sequence\\nis exhausted and then it raises StopIteration.  When the shorter iterables\\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\\ndefaults to None or can be specified by a keyword argument.\\n\",tp$new(t,i){const[r]=Sk.abstr.copyKeywordsToNamedArgs(\"zip_longest\",[\"fillvalue\"],[],i,[Sk.builtin.none.none$]),s=[];for(let e=0;e<t.length;e++)s.push(Sk.abstr.iter(t[e]));if(this===e.zip_longest.prototype)return new e.zip_longest(s,r);{const t=new this.constructor;return e.zip_longest.call(t,s,r),t}}}}),e.__doc__=new Sk.builtin.str(\"An implementation of the python itertools module in Skulpt\"),e.__package__=new Sk.builtin.str(\"\"),e};","src/lib/json/__init__.js":"var $builtinmodule=function(t){\"use strict\";var e={},dumps_f=function(t){Sk.builtin.pyCheckArgs(\"dumps\",arguments,1,1/0,!0,!1);var e,n,i,u=Array.prototype.slice.call(arguments,1),f=new Sk.builtins.dict(t),a=!1;return e={ascii:!0,separators:{item_separator:\", \",key_separator:\": \"}},f=Sk.ffi.remapToJs(f),n=Sk.ffi.remapToJs(u[0]),\"boolean\"==typeof f.ensure_ascii&&!1===f.ensure_ascii&&(e.ascii=!1),\"boolean\"==typeof f.sort_keys&&f.sort_keys&&(a=!0),a||(e.cmp=function(t,e){return 0}),\"object\"==typeof f.separators&&2==f.separators.length&&(e.separators.item_separator=f.separators[0],e.separators.key_separator=f.separators[1]),f.indent&&(e.space=f.indent),f.default,i=stringify(n,e),new Sk.builtin.str(i)};dumps_f.co_kwargs=!0,e.dumps=new Sk.builtin.func(dumps_f);var loads_f=function(t){Sk.builtin.pyCheckArgs(\"loads\",arguments,1,1/0,!0,!1);var e,n,i=Array.prototype.slice.call(arguments,1),u=new Sk.builtins.dict(t);return u=Sk.ffi.remapToJs(u),e=i[0].v,n=JSON.parse(e),Sk.ffi.remapToPy(n)};return loads_f.co_kwargs=!0,e.loads=new Sk.builtin.func(loads_f),e};!function r(t,e,n){function o(u,f){if(!e[u]){if(!t[u]){var a=\"function\"==typeof require&&require;if(!f&&a)return a(u,!0);if(i)return i(u,!0);var s=new Error(\"Cannot find module '\"+u+\"'\");throw s.code=\"MODULE_NOT_FOUND\",s}var c=e[u]={exports:{}};t[u][0].call(c.exports,(function(e){return o(t[u][1][e]||e)}),c,c.exports,r,t,e,n)}return e[u].exports}for(var i=\"function\"==typeof require&&require,u=0;u<n.length;u++)o(n[u]);return o}({1:[function(t,e,n){var i=\"undefined\"!=typeof JSON?JSON:t(\"jsonify\");e.exports=function(t,e){e||(e={}),\"function\"==typeof e&&(e={cmp:e});var n,a=e.cmp&&(n=e.cmp,function(t){return function(e,i){var u={key:e,value:t[e]},f={key:i,value:t[i]};return n(u,f)}});return function stringify(t){if(\"object\"!=typeof t||null===t)return i.stringify(t);if(u(t)){for(var e=[],n=0;n<t.length;n++)e.push(stringify(t[n]));return\"[\"+e.join(\",\")+\"]\"}var s=f(t).sort(a&&a(t));for(e=[],n=0;n<s.length;n++){var c=s[n];e.push(stringify(c)+\":\"+stringify(t[c]))}return\"{\"+e.join(\",\")+\"}\"}(t)};var u=Array.isArray||function(t){return\"[object Array]\"==={}.toString.call(t)},f=Object.keys||function(t){var e=Object.prototype.hasOwnProperty||function(){return!0},n=[];for(var i in t)e.call(t,i)&&n.push(i);return n}},{jsonify:2}],2:[function(t,e,n){n.parse=t(\"./lib/parse\"),n.stringify=t(\"./lib/stringify\")},{\"./lib/parse\":3,\"./lib/stringify\":4}],3:[function(t,e,n){var i,u,f,a,s={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},error=function(t){throw{name:\"SyntaxError\",message:t,at:i,text:f}},next=function(t){return t&&t!==u&&error(\"Expected '\"+t+\"' instead of '\"+u+\"'\"),u=f.charAt(i),i+=1,u},number=function(){var t,e=\"\";for(\"-\"===u&&(e=\"-\",next(\"-\"));u>=\"0\"&&u<=\"9\";)e+=u,next();if(\".\"===u)for(e+=\".\";next()&&u>=\"0\"&&u<=\"9\";)e+=u;if(\"e\"===u||\"E\"===u)for(e+=u,next(),\"-\"!==u&&\"+\"!==u||(e+=u,next());u>=\"0\"&&u<=\"9\";)e+=u,next();if(t=+e,isFinite(t))return t;error(\"Bad number\")},string=function(){var t,e,n,i=\"\";if('\"'===u)for(;next();){if('\"'===u)return next(),i;if(\"\\\\\"===u)if(next(),\"u\"===u){for(n=0,e=0;e<4&&(t=parseInt(next(),16),isFinite(t));e+=1)n=16*n+t;i+=String.fromCharCode(n)}else{if(\"string\"!=typeof s[u])break;i+=s[u]}else i+=u}error(\"Bad string\")},white=function(){for(;u&&u<=\" \";)next()};a=function(){switch(white(),u){case\"{\":return function(){var t,e={};if(\"{\"===u){if(next(\"{\"),white(),\"}\"===u)return next(\"}\"),e;for(;u;){if(t=string(),white(),next(\":\"),Object.hasOwnProperty.call(e,t)&&error('Duplicate key \"'+t+'\"'),e[t]=a(),white(),\"}\"===u)return next(\"}\"),e;next(\",\"),white()}}error(\"Bad object\")}();case\"[\":return function(){var t=[];if(\"[\"===u){if(next(\"[\"),white(),\"]\"===u)return next(\"]\"),t;for(;u;){if(t.push(a()),white(),\"]\"===u)return next(\"]\"),t;next(\",\"),white()}}error(\"Bad array\")}();case'\"':return string();case\"-\":return number();default:return u>=\"0\"&&u<=\"9\"?number():function(){switch(u){case\"t\":return next(\"t\"),next(\"r\"),next(\"u\"),next(\"e\"),!0;case\"f\":return next(\"f\"),next(\"a\"),next(\"l\"),next(\"s\"),next(\"e\"),!1;case\"n\":return next(\"n\"),next(\"u\"),next(\"l\"),next(\"l\"),null}error(\"Unexpected '\"+u+\"'\")}()}},e.exports=function(t,e){var n;return f=t,i=0,u=\" \",n=a(),white(),u&&error(\"Syntax error\"),\"function\"==typeof e?function walk(t,n){var i,u,f=t[n];if(f&&\"object\"==typeof f)for(i in f)Object.prototype.hasOwnProperty.call(f,i)&&(void 0!==(u=walk(f,i))?f[i]=u:delete f[i]);return e.call(t,n,f)}({\"\":n},\"\"):n}},{}],4:[function(t,e,n){var i,u,f,a=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,s={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"};function quote(t){return a.lastIndex=0,a.test(t)?'\"'+t.replace(a,(function(t){var e=s[t];return\"string\"==typeof e?e:\"\\\\u\"+(\"0000\"+t.charCodeAt(0).toString(16)).slice(-4)}))+'\"':'\"'+t+'\"'}function str(t,e){var n,a,s,c,l,p=i,y=e[t];switch(y&&\"object\"==typeof y&&\"function\"==typeof y.toJSON&&(y=y.toJSON(t)),\"function\"==typeof f&&(y=f.call(e,t,y)),typeof y){case\"string\":return quote(y);case\"number\":return isFinite(y)?String(y):\"null\";case\"boolean\":case\"null\":return String(y);case\"object\":if(!y)return\"null\";if(i+=u,l=[],\"[object Array]\"===Object.prototype.toString.apply(y)){for(c=y.length,n=0;n<c;n+=1)l[n]=str(n,y)||\"null\";return s=0===l.length?\"[]\":i?\"[\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"]\":\"[\"+l.join(\",\")+\"]\",i=p,s}if(f&&\"object\"==typeof f)for(c=f.length,n=0;n<c;n+=1)\"string\"==typeof(a=f[n])&&(s=str(a,y))&&l.push(quote(a)+(i?\": \":\":\")+s);else for(a in y)Object.prototype.hasOwnProperty.call(y,a)&&(s=str(a,y))&&l.push(quote(a)+(i?\": \":\":\")+s);return s=0===l.length?\"{}\":i?\"{\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"}\":\"{\"+l.join(\",\")+\"}\",i=p,s}}e.exports=function(t,e,n){var a;if(i=\"\",u=\"\",\"number\"==typeof n)for(a=0;a<n;a+=1)u+=\" \";else\"string\"==typeof n&&(u=n);if(f=e,e&&\"function\"!=typeof e&&(\"object\"!=typeof e||\"number\"!=typeof e.length))throw new Error(\"JSON.stringify\");return str(\"\",{\"\":t})}},{}],5:[function(t,e,n){var i,u,f=e.exports={};function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}function runTimeout(t){if(i===setTimeout)return setTimeout(t,0);if((i===defaultSetTimout||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{return i(t,0)}catch(e){try{return i.call(null,t,0)}catch(e){return i.call(this,t,0)}}}!function(){try{i=\"function\"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){i=defaultSetTimout}try{u=\"function\"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){u=defaultClearTimeout}}();var a,s=[],c=!1,l=-1;function cleanUpNextTick(){c&&a&&(c=!1,a.length?s=a.concat(s):l=-1,s.length&&drainQueue())}function drainQueue(){if(!c){var t=runTimeout(cleanUpNextTick);c=!0;for(var e=s.length;e;){for(a=s,s=[];++l<e;)a&&a[l].run();l=-1,e=s.length}a=null,c=!1,function runClearTimeout(t){if(u===clearTimeout)return clearTimeout(t);if((u===defaultClearTimeout||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(t);try{return u(t)}catch(e){try{return u.call(null,t)}catch(e){return u.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];s.push(new Item(t,e)),1!==s.length||c||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},f.title=\"browser\",f.browser=!0,f.env={},f.argv=[],f.version=\"\",f.versions={},f.on=noop,f.addListener=noop,f.once=noop,f.off=noop,f.removeListener=noop,f.removeAllListeners=noop,f.emit=noop,f.prependListener=noop,f.prependOnceListener=noop,f.listeners=function(t){return[]},f.binding=function(t){throw new Error(\"process.binding is not supported\")},f.cwd=function(){return\"/\"},f.chdir=function(t){throw new Error(\"process.chdir is not supported\")},f.umask=function(){return 0}},{}],6:[function(t,e,n){(function(n){var i=t(\"json-stable-stringify\");n.browser?window.stringify=i:e.exports=i}).call(this,t(\"_process\"))},{_process:5,\"json-stable-stringify\":1}]},{},[6]);","src/lib/json/stringify.js":"!function r(t,e,n){function o(u,f){if(!e[u]){if(!t[u]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(u,!0);if(i)return i(u,!0);var a=new Error(\"Cannot find module '\"+u+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var s=e[u]={exports:{}};t[u][0].call(s.exports,(function(e){return o(t[u][1][e]||e)}),s,s.exports,r,t,e,n)}return e[u].exports}for(var i=\"function\"==typeof require&&require,u=0;u<n.length;u++)o(n[u]);return o}({1:[function(t,e,n){var i=\"undefined\"!=typeof JSON?JSON:t(\"jsonify\");e.exports=function(t,e){e||(e={}),\"function\"==typeof e&&(e={cmp:e});var n,c=e.cmp&&(n=e.cmp,function(t){return function(e,i){var u={key:e,value:t[e]},f={key:i,value:t[i]};return n(u,f)}});return function stringify(t){if(\"object\"!=typeof t||null===t)return i.stringify(t);if(u(t)){for(var e=[],n=0;n<t.length;n++)e.push(stringify(t[n]));return\"[\"+e.join(\",\")+\"]\"}var a=f(t).sort(c&&c(t));for(e=[],n=0;n<a.length;n++){var s=a[n];e.push(stringify(s)+\":\"+stringify(t[s]))}return\"{\"+e.join(\",\")+\"}\"}(t)};var u=Array.isArray||function(t){return\"[object Array]\"==={}.toString.call(t)},f=Object.keys||function(t){var e=Object.prototype.hasOwnProperty||function(){return!0},n=[];for(var i in t)e.call(t,i)&&n.push(i);return n}},{jsonify:2}],2:[function(t,e,n){n.parse=t(\"./lib/parse\"),n.stringify=t(\"./lib/stringify\")},{\"./lib/parse\":3,\"./lib/stringify\":4}],3:[function(t,e,n){var i,u,f,c,a={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},error=function(t){throw{name:\"SyntaxError\",message:t,at:i,text:f}},next=function(t){return t&&t!==u&&error(\"Expected '\"+t+\"' instead of '\"+u+\"'\"),u=f.charAt(i),i+=1,u},number=function(){var t,e=\"\";for(\"-\"===u&&(e=\"-\",next(\"-\"));u>=\"0\"&&u<=\"9\";)e+=u,next();if(\".\"===u)for(e+=\".\";next()&&u>=\"0\"&&u<=\"9\";)e+=u;if(\"e\"===u||\"E\"===u)for(e+=u,next(),\"-\"!==u&&\"+\"!==u||(e+=u,next());u>=\"0\"&&u<=\"9\";)e+=u,next();if(t=+e,isFinite(t))return t;error(\"Bad number\")},string=function(){var t,e,n,i=\"\";if('\"'===u)for(;next();){if('\"'===u)return next(),i;if(\"\\\\\"===u)if(next(),\"u\"===u){for(n=0,e=0;e<4&&(t=parseInt(next(),16),isFinite(t));e+=1)n=16*n+t;i+=String.fromCharCode(n)}else{if(\"string\"!=typeof a[u])break;i+=a[u]}else i+=u}error(\"Bad string\")},white=function(){for(;u&&u<=\" \";)next()};c=function(){switch(white(),u){case\"{\":return function(){var t,e={};if(\"{\"===u){if(next(\"{\"),white(),\"}\"===u)return next(\"}\"),e;for(;u;){if(t=string(),white(),next(\":\"),Object.hasOwnProperty.call(e,t)&&error('Duplicate key \"'+t+'\"'),e[t]=c(),white(),\"}\"===u)return next(\"}\"),e;next(\",\"),white()}}error(\"Bad object\")}();case\"[\":return function(){var t=[];if(\"[\"===u){if(next(\"[\"),white(),\"]\"===u)return next(\"]\"),t;for(;u;){if(t.push(c()),white(),\"]\"===u)return next(\"]\"),t;next(\",\"),white()}}error(\"Bad array\")}();case'\"':return string();case\"-\":return number();default:return u>=\"0\"&&u<=\"9\"?number():function(){switch(u){case\"t\":return next(\"t\"),next(\"r\"),next(\"u\"),next(\"e\"),!0;case\"f\":return next(\"f\"),next(\"a\"),next(\"l\"),next(\"s\"),next(\"e\"),!1;case\"n\":return next(\"n\"),next(\"u\"),next(\"l\"),next(\"l\"),null}error(\"Unexpected '\"+u+\"'\")}()}},e.exports=function(t,e){var n;return f=t,i=0,u=\" \",n=c(),white(),u&&error(\"Syntax error\"),\"function\"==typeof e?function walk(t,n){var i,u,f=t[n];if(f&&\"object\"==typeof f)for(i in f)Object.prototype.hasOwnProperty.call(f,i)&&(void 0!==(u=walk(f,i))?f[i]=u:delete f[i]);return e.call(t,n,f)}({\"\":n},\"\"):n}},{}],4:[function(t,e,n){var i,u,f,c=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,a={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"};function quote(t){return c.lastIndex=0,c.test(t)?'\"'+t.replace(c,(function(t){var e=a[t];return\"string\"==typeof e?e:\"\\\\u\"+(\"0000\"+t.charCodeAt(0).toString(16)).slice(-4)}))+'\"':'\"'+t+'\"'}function str(t,e){var n,c,a,s,l,p=i,y=e[t];switch(y&&\"object\"==typeof y&&\"function\"==typeof y.toJSON&&(y=y.toJSON(t)),\"function\"==typeof f&&(y=f.call(e,t,y)),typeof y){case\"string\":return quote(y);case\"number\":return isFinite(y)?String(y):\"null\";case\"boolean\":case\"null\":return String(y);case\"object\":if(!y)return\"null\";if(i+=u,l=[],\"[object Array]\"===Object.prototype.toString.apply(y)){for(s=y.length,n=0;n<s;n+=1)l[n]=str(n,y)||\"null\";return a=0===l.length?\"[]\":i?\"[\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"]\":\"[\"+l.join(\",\")+\"]\",i=p,a}if(f&&\"object\"==typeof f)for(s=f.length,n=0;n<s;n+=1)\"string\"==typeof(c=f[n])&&(a=str(c,y))&&l.push(quote(c)+(i?\": \":\":\")+a);else for(c in y)Object.prototype.hasOwnProperty.call(y,c)&&(a=str(c,y))&&l.push(quote(c)+(i?\": \":\":\")+a);return a=0===l.length?\"{}\":i?\"{\\n\"+i+l.join(\",\\n\"+i)+\"\\n\"+p+\"}\":\"{\"+l.join(\",\")+\"}\",i=p,a}}e.exports=function(t,e,n){var c;if(i=\"\",u=\"\",\"number\"==typeof n)for(c=0;c<n;c+=1)u+=\" \";else\"string\"==typeof n&&(u=n);if(f=e,e&&\"function\"!=typeof e&&(\"object\"!=typeof e||\"number\"!=typeof e.length))throw new Error(\"JSON.stringify\");return str(\"\",{\"\":t})}},{}],5:[function(t,e,n){var i,u,f=e.exports={};function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}function runTimeout(t){if(i===setTimeout)return setTimeout(t,0);if((i===defaultSetTimout||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{return i(t,0)}catch(e){try{return i.call(null,t,0)}catch(e){return i.call(this,t,0)}}}!function(){try{i=\"function\"==typeof setTimeout?setTimeout:defaultSetTimout}catch(t){i=defaultSetTimout}try{u=\"function\"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(t){u=defaultClearTimeout}}();var c,a=[],s=!1,l=-1;function cleanUpNextTick(){s&&c&&(s=!1,c.length?a=c.concat(a):l=-1,a.length&&drainQueue())}function drainQueue(){if(!s){var t=runTimeout(cleanUpNextTick);s=!0;for(var e=a.length;e;){for(c=a,a=[];++l<e;)c&&c[l].run();l=-1,e=a.length}c=null,s=!1,function runClearTimeout(t){if(u===clearTimeout)return clearTimeout(t);if((u===defaultClearTimeout||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(t);try{return u(t)}catch(e){try{return u.call(null,t)}catch(e){return u.call(this,t)}}}(t)}}function Item(t,e){this.fun=t,this.array=e}function noop(){}f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];a.push(new Item(t,e)),1!==a.length||s||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},f.title=\"browser\",f.browser=!0,f.env={},f.argv=[],f.version=\"\",f.versions={},f.on=noop,f.addListener=noop,f.once=noop,f.off=noop,f.removeListener=noop,f.removeAllListeners=noop,f.emit=noop,f.prependListener=noop,f.prependOnceListener=noop,f.listeners=function(t){return[]},f.binding=function(t){throw new Error(\"process.binding is not supported\")},f.cwd=function(){return\"/\"},f.chdir=function(t){throw new Error(\"process.chdir is not supported\")},f.umask=function(){return 0}},{}],6:[function(t,e,n){(function(n){var i=t(\"json-stable-stringify\");n.browser?window.stringify=i:e.exports=i}).call(this,t(\"_process\"))},{_process:5,\"json-stable-stringify\":1}]},{},[6]);","src/lib/json.js":"function $builtinmodule(){const{builtin:{str:e,float_:t,list:n,tuple:r,dict:o,func:s,TypeError:i,ValueError:l,NotImplementedError:a,sorted:c,none:{none$:u},bool:{true$:h,false$:d},checkString:f,checkBytes:p},ffi:{toPy:g,toJs:m,toPyFloat:w,toPyInt:_,isTrue:b},abstr:{typeName:y,buildNativeClass:N,checkOneArg:O,setUpModuleMethods:k,copyKeywordsToNamedArgs:S},misceval:{objectRepr:J,callsimArray:$}}=Sk,E={__name__:new e(\"json\"),__all__:g([\"dump\",\"dumps\",\"load\",\"loads\",\"JSONDecoder\",\"JSONDecodeError\",\"JSONEncoder\"]),dump:proxyFail(\"dump\"),load:proxyFail(\"load\"),JSONDecoder:proxyFail(\"JSONDecoder\"),JSONEncoder:proxyFail(\"JSONEncoder\")};function proxyFail(e){return new s((()=>{throw new a(e+\" is not yet implemented in skulpt\")}))}const j=E.JSONDecodeError=N(\"json.JSONDecodeError\",{base:l,constructor:function JSONDecodeError(e,t,n){const r=t.slice(0,n),o=r.split(\"\\n\").length,s=n-r.lastIndexOf(\"\\n\"),i=`${e}: line ${o} column ${s} (char ${n})`;l.call(this,i),this.$msg=e,this.$doc=t,this.$pos=n,this.$lineno=o,this.$colno=s},getsets:Object.fromEntries([\"msg\",\"doc\",\"pos\",\"lineno\",\"colno\"].map((e=>[e,{$get(){return g(this[\"$\"+e])}}])))});class JSONEncoder{constructor(e,t,n,r,o,s,i,l){this.skipkeys=e,this.ensure_ascii=t,this.check_circular=n,this.allow_nan=r,this.indent=o,this.separators=s,this.sort_keys=l,this.item_separator=\", \",this.key_separator=\": \",null!==this.separators?[this.item_separator,this.key_separator]=this.separators:null!==this.indent&&(this.item_separator=\",\"),null!==i&&(this.default=i),this.encoder=this.make_encoder()}default(e){throw new i(`Object of type ${y(e)} is not JSON serializable`)}encode(t){return new e(this.encoder(t))}make_encoder(){let e,t;e=this.check_circular?new Set:null,t=(this.ensure_ascii,JSON.stringify);return function _make_iterencode(e,t,n,r,s,a,u,h,d){null!==r&&\"string\"!=typeof r&&(r=\" \".repeat(r));let f,p,g,w;null!==e?(f=t=>{if(e.has(t))throw new l(\"Circular reference detected\");e.add(t)},p=t=>e.delete(t)):(f=e=>{},p=e=>{});null!==r?(g=(e,t)=>{t+=1;const n=\"\\n\"+r.repeat(t);return[e+=n,t,u+n]},w=(e,t,n)=>(n-=1,e+=\"\\n\"+r.repeat(n)+t)):(g=(e,t)=>[e,t,u],w=(e,t,n)=>e+t);const _unhandled=(e,n)=>{f(e);const r=_iterencode(t(e),n);return p(e),r},_iterencode_list=(e,t)=>{if(!e.length)return\"[]\";let n,r;f(e),[n,t,r]=g(\"[\",t);let o=!0;for(let s of e)o?o=!1:n+=r,n+=_iterencode(s,t);return p(e),w(n,\"]\",t)},_iterencode_dict=(e,t)=>{if(!e.sq$length())return\"{}\";let r,l;f(e),[r,t,l]=g(\"{\",t);let u=!0;if(h){const t=$(e.tp$getattr(v)),n=c(t);e=$(o,[n])}for(let[o,c]of e.$items()){const e=o.valueOf(),h=typeof e;if(\"string\"===h)o=e;else if(\"number\"===h)o=s(o);else if(\"boolean\"===h||null===e)o=String(e);else{if(!JSBI.__isBigInt(e)){if(d)continue;throw new i(\"keys must be str, int, float, bool or None, not \"+y(o))}o=e.toString()}u?u=!1:r+=l,r+=n(o),r+=a,r+=_iterencode(c,t)}return p(e),w(r,\"}\",t)},_iterencode=(e,t=0)=>String(m(e,{stringHook:e=>n(e),numberHook:(e,t)=>s(t),bigintHook:e=>e.toString(),dictHook:e=>_iterencode_dict(e,t),arrayHook:e=>_iterencode_list(e,t),setHook:e=>_unhandled(e,t),funcHook:(e,n)=>_unhandled(n,t),objecthook:(e,n)=>_unhandled(n,t),unhandledHook:e=>_unhandled(e,t)}));return _iterencode}(e,this.default,t,this.indent,((e,t=this.allow_nan)=>{const n=e.valueOf();let r;if(Number.isFinite(n))return J(e);if(r=n.toString(),!t)throw new l(\"Out of range float values are not JSON compliant: \"+J(e));return r}),this.key_separator,this.item_separator,this.sort_keys,this.skipkeys)}}const v=new e(\"items\");const x=[!1,!0,!0,!0,null,null,null,!1],D=new JSONEncoder(...x),F=/(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?/;const I=/\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"/m;function scanstring(t,n){const r=t.substring(n-1).match(I);if(null===r)throw new j(\"Unterminated string starting at\",t,n-1);try{return[new e(JSON.parse(r[0])),n+r[0].length-1]}catch(o){let e=o.message.match(/(?:column|position) (\\d+)/);e=e&&Number(e[1]);n=n+(e||0)-(void 0===o.columnNumber?1:2);const r=o.message.replace(\"JSON.parse: \",\"\").replace(/ at line \\d+ column \\d+ of the JSON data/,\"\").replace(/ in JSON at position \\d+$/,\"\");throw new j(r,t,n)}}const A=/[ \\t\\n\\r]*/;function JSONArray(e,t,r){const o=[];let s=e[t];const adjust_white_space=()=>{if(\" \"===s||\"\\t\"===s||\"\\n\"===s||\"\\r\"===s){const n=e.substring(t).match(A);t+=n[0].length,s=e[t]}};if(adjust_white_space(),\"]\"===s)return[new n([]),t+1];for(;;){let n;if([n,t]=r(e,t),void 0===n)throw new j(\"Expecting value\",e,t);if(o.push(n),s=e[t],adjust_white_space(),t++,\"]\"===s)break;if(\",\"!==s)throw new j(\"Expecting ',' delimiter\",e,t-1);s=e[t],adjust_white_space()}return[new n(o),t]}function JSONObject(e,t,s,i,l){let a=[],c=e[t];const adjust_white_space=()=>{if(\" \"===c||\"\\t\"===c||\"\\n\"===c||\"\\r\"===c){const n=e.substring(t).match(A);t+=n[0].length,c=e[t]}};if('\"'!==c){if(adjust_white_space(),\"}\"===c){if(null!==l){return[l(new n([])),t+1]}return a=new o([]),null!==i&&(a=i(a)),[a,t+1]}if('\"'!==c)throw new j(\"Expecting property name enclosed in double quotes\",e,t)}let u,h;for(t+=1;;){if([u,t]=scanstring(e,t),\":\"!==(c=e[t])&&(adjust_white_space(),\":\"!==e[t]))throw new j(\"Expecting ':' delimiter\",e,t);if(c=e[++t],adjust_white_space(),[h,t]=s(e,t),void 0===h)throw new j(\"Expecting value\",e,t);if(c=e[t],a.push([u,h]),adjust_white_space(),t++,\"}\"===c)break;if(\",\"!==c)throw new j(\"Expecting ',' delimiter\",e,t-1);if(c=e[t],adjust_white_space(),t++,'\"'!==c)throw new j(\"Expecting property name enclosed in double quotes\",e,t-1)}if(null!==l){return[l(new n(a.map((e=>new r(e))))),t]}return a=new o(a.flat()),null!==i&&(a=i(a)),[a,t]}const H={NaN:new t(NaN),Infinity:new t(1/0),\"-Infinity\":new t(-1/0)};class JSONDecoder{constructor(e,t,n,r,o){this.object_hook=e,this.parse_float=t||w,this.parse_int=n||_,this.parse_constant=r||(e=>H[e]),this.object_pairs_hook=o,this.parse_object=JSONObject,this.parse_array=JSONArray,this.parse_string=scanstring,this.scan_once=function make_scanner(e){const{parse_object:t,parse_array:n,parse_string:r,parse_float:o,parse_int:s,parse_constant:i,object_hook:l,object_pairs_hook:a}=e,scan_once=(e,c)=>{const f=e[c];if(void 0===f)return[f,c];if('\"'===f)return r(e,c+1);if(\"{\"===f)return t(e,c+1,scan_once,l,a);if(\"[\"===f)return n(e,c+1,scan_once);if(\"n\"===f&&\"null\"===e.substring(c,c+4))return[u,c+4];if(\"t\"===f&&\"true\"===e.substring(c,c+4))return[h,c+4];if(\"f\"===f&&\"false\"===e.substring(c,c+5))return[d,c+5];const p=e.substring(c).match(F);if(null!==p){let e;const[t,n,r,i]=p;return e=r||i?o(n+(r||\"\")+(i||\"\")):s(n),[e,c+t.length]}return\"N\"===f&&\"NaN\"===e.substring(c,c+3)?[i(\"NaN\"),c+3]:\"I\"==f&&\"Infinity\"===e.substring(c,c+8)?[i(\"Infinity\"),c+8]:\"-\"==f&&\"-Infinity\"===e.substring(c,c+9)?[i(\"-Infinity\"),c+9]:[void 0,c]};return scan_once}(this)}white(e,t){const n=(0===t?e:e.substring(t)).match(A);return null!==n&&(t+=n[0].length),t}decode(e){e=e.toString();let[t,n]=this.scan_once(e,this.white(e,0));if(void 0===t)throw new j(\"Expecting value\",e,n);if(n=this.white(e,n),n!==e.length)throw new j(\"Extra data\",e,n);return t}}const T=Array(5).fill(null),C=new JSONDecoder(...T);function convertToNullOrFunc(e){return null===e||e===u?null:t=>$(e,[g(t)])}return k(\"json\",E,{loads:{$meth(e,t){O(\"dumps\",e);let n=e[0];if(f(n));else{if(!p(n))throw new i(`the JSON object must be str or bytes, not ${y(n)}`);n=(new TextDecoder).decode(n.valueOf())}const r=S(\"dumps\",[\"object_hook\",\"parse_float\",\"parse_int\",\"parse_constant\",\"object_pairs_hook\"],[],t,T).map(convertToNullOrFunc);return r.every((e=>null===e))?C.decode(n):new JSONDecoder(...r).decode(n)},$doc:\"Deserialize ``s`` (a ``str`` or ``bytes`` instance containing a JSON document) to a Python object.\",$flags:{FastCall:!0}},dumps:{$meth(e,t){O(\"dumps\",e);const n=e[0];let[r,o,s,l,a,c,u,h]=S(\"loads\",[\"skipkeys\",\"ensure_ascii\",\"check_circular\",\"allow_nan\",\"indent\",\"separators\",\"default\",\"sort_keys\"],[],t,x);if(r=b(r),o=b(o),s=b(s),l=b(l),a=m(a),c=m(c),u=convertToNullOrFunc(u),h=b(h),!r&&o&&s&&l&&null===a&&null===c&&null===u&&!h)return D.encode(n);if(null===c);else if(!Array.isArray(c)||2!==c.length||\"string\"!=typeof c[0]||\"string\"!=typeof c[1])throw new i(\"separators shuld be a list or tuple of strings of length 2\");return new JSONEncoder(r,o,s,l,a,c,u,h).encode(n)},$doc:\"Serialize ``obj`` to a JSON formatted ``str``\",$flags:{FastCall:!0}}}),E}","src/lib/keyword.js":"function $builtinmodule(){const{ffi:{remapToPy:t},builtin:{frozenset:e,str:s}}=Sk,i=new s(\"keyword\"),n=t([\"iskeyword\",\"issoftkeyword\",\"kwlist\",\"softkwlist\"]),o=t([\"False\",\"None\",\"True\",\"and\",\"as\",\"assert\",\"async\",\"await\",\"break\",\"class\",\"continue\",\"def\",\"del\",\"elif\",\"else\",\"except\",\"finally\",\"for\",\"from\",\"global\",\"if\",\"import\",\"in\",\"is\",\"lambda\",\"nonlocal\",\"not\",\"or\",\"pass\",\"raise\",\"return\",\"try\",\"while\",\"with\",\"yield\"]),a=t([\"_\",\"case\",\"match\"]);return{__name__:i,__all__:n,kwlist:o,softkwlist:a,iskeyword:new e(o).tp$getattr(s.$contains),issoftkeyword:new e(a).tp$getattr(s.$contains)}}","src/lib/math.js":"const $builtinmodule=function(e){const{builtin:{str:t,int_:n,float_:i,TypeError:r,pyCheckType:u,checkNumber:l},abstr:{lookupSpecial:o},misceval:{callsimOrSuspendArray:a}}=Sk,s={pi:new Sk.builtin.float_(Math.PI),e:new Sk.builtin.float_(Math.E),tau:new Sk.builtin.float_(2*Math.PI),nan:new Sk.builtin.float_(NaN),inf:new Sk.builtin.float_(1/0)},b=new t(\"__ceil__\");const get_sign=function(e){return e=e?e<0?-1:1:1/e<0?-1:1};const c=18;function factorial(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=Sk.builtin.asnum$(e);if((e=Math.floor(t))!=t)throw new Sk.builtin.ValueError(\"factorial() only accepts integral values\");if(e<0)throw new Sk.builtin.ValueError(\"factorial() not defined for negative numbers\");let n=1;for(let i=2;i<=e&&i<=c;i++)n*=i;if(e<=c)return new Sk.builtin.int_(n);n=JSBI.BigInt(n);for(let i=c+1;i<=e;i++)n=JSBI.multiply(n,JSBI.BigInt(i));return new Sk.builtin.int_(n)}const m=new t(\"__floor__\");function _gcd_internal(e,t){let n;return\"number\"==typeof e&&\"number\"==typeof t?(n=function _gcd(e,t){return 0==t?e:_gcd(t,e%t)}(e=Math.abs(e),t=Math.abs(t)),n=n<0?-n:n):(n=function _biggcd(e,t){return JSBI.equal(t,JSBI.__ZERO)?e:_biggcd(t,JSBI.remainder(e,t))}(e=JSBI.BigInt(e),t=JSBI.BigInt(t)),JSBI.lessThan(n,JSBI.__ZERO)&&(n=JSBI.multiply(n,JSBI.BigInt(-1)))),n}return Sk.abstr.setUpModuleMethods(\"math\",s,{acos:{$meth:function acos(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.acos(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc cosine (measured in radians) of x.\"},acosh:{$meth:function acosh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=(e=Sk.builtin.asnum$(e))+Math.sqrt(e*e-1);return new Sk.builtin.float_(Math.log(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic cosine of x.\"},asin:{$meth:function asin(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.asin(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc sine (measured in radians) of x.\"},asinh:{$meth:function asinh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=(e=Sk.builtin.asnum$(e))+Math.sqrt(e*e+1);return new Sk.builtin.float_(Math.log(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic sine of x.\"},atan:{$meth:function atan(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.atan(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc tangent (measured in radians) of x.\"},atan2:{$meth:function atan2(e,t){return Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(t)),new Sk.builtin.float_(Math.atan2(Sk.builtin.asnum$(e),Sk.builtin.asnum$(t)))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, y, x, /)\",$doc:\"Return the arc tangent (measured in radians) of y/x.\\n\\nUnlike atan(y/x), the signs of both x and y are considered.\"},atanh:{$meth:function atanh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=(1+(e=Sk.builtin.asnum$(e)))/(1-e);return new Sk.builtin.float_(Math.log(t)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic tangent of x.\"},ceil:{$meth:function ceil(e){let t;if(e.ob$type!==i){const n=o(e,b);if(void 0!==n)return a(n);u(\"\",\"real number\",l(e)),t=Sk.builtin.asnum$(e)}else t=e.v;return new n(Math.ceil(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the ceiling of x as an Integral.\\n\\nThis is the smallest integer >= x.\"},comb:{$meth:function comb(e,t){let n=Sk.misceval.asIndexOrThrow(e),i=Sk.misceval.asIndexOrThrow(t);if(n<0)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");if(i<0)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(i>e)return new Sk.builtin.int_(0);e=new Sk.builtin.int_(n),t=new Sk.builtin.int_(i);let r=Sk.ffi.remapToJs(e.nb$subtract(t));if(r<i&&(i=r),0===i)return new Sk.builtin.int_(1);if(i>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"min(n - k, k) must not exceed \"+Number.MAX_SAFE_INTEGER);const u=new Sk.builtin.int_(1);let l=e;for(let o=1;o<i;o++)e=e.nb$subtract(u),r=new Sk.builtin.int_(o+1),l=l.nb$multiply(e),l=l.nb$floor_divide(r);return l},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.\"},copysign:{$meth:function copysign(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));const n=Sk.builtin.asnum$(t),i=Sk.builtin.asnum$(e),r=get_sign(i)*get_sign(n);return new Sk.builtin.float_(i*r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return a float with the magnitude (absolute value) of x but the sign of y.\\n\\nOn platforms that support signed zeros, copysign(1.0, -0.0)\\nreturns -1.0.\\n\"},cos:{$meth:function cos(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.cos(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the cosine of x (measured in radians).\"},cosh:{$meth:function cosh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e);const t=Math.E,n=Math.pow(t,e),i=(n+1/n)/2;return new Sk.builtin.float_(i)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic cosine of x.\"},degrees:{$meth:function degrees(e){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e));const t=180/Math.PI*Sk.builtin.asnum$(e);return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from radians to degrees.\"},dist:{$meth:function dist(e){throw new Sk.builtin.NotImplementedError(\"math.dist() is not yet implemented in Skulpt\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, p, q, /)\",$doc:\"Return the Euclidean distance between 2 points in any dimension.\"},erf:{$meth:function erf(e){throw new Sk.builtin.NotImplementedError(\"math.erf() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Error function at x.\"},erfc:{$meth:function erfc(e){throw new Sk.builtin.NotImplementedError(\"math.erfc() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Complementary error function at x.\"},exp:{$meth:function exp(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=e.v;if(\"number\"!=typeof t&&(t=e.nb$float().v),t==1/0||t==-1/0||isNaN(t))return new Sk.builtin.float_(Math.exp(t));const n=Math.exp(t);if(!isFinite(n))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(n)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return e raised to the power of x.\"},expm1:{$meth:function expm1(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);if(Math.abs(t)<.7){const e=Math.exp(t);if(1==e)return new Sk.builtin.float_(t);{const n=(e-1)*t/Math.log(e);return new Sk.builtin.float_(n)}}{const e=Math.exp(t)-1;return new Sk.builtin.float_(e)}},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return exp(x)-1.\\n\\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.\"},fabs:{$meth:function fabs(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=e.v;return JSBI.__isBigInt(t)&&(t=e.nb$float().v),t=Math.abs(t),new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the absolute value of the float x.\"},factorial:{$meth:factorial,$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Find x!.\\n\\nRaise a ValueError if x is negative or non-integral.\"},floor:{$meth:function floor(e){let t;if(e.ob$type===i)t=e.v;else{const n=o(e,m);if(void 0!==n)return a(n);u(\"x\",\"number\",l(e)),t=Sk.builtin.asnum$(e)}return new n(Math.floor(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the floor of x as an Integral.\\n\\nThis is the largest integer <= x.\"},fmod:{$meth:function fmod(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if(\"number\"!=typeof n&&(n=e.nb$float().v),\"number\"!=typeof i&&(i=t.nb$float().v),(i==1/0||i==-1/0)&&isFinite(n))return new Sk.builtin.float_(n);const r=n%i;if(isNaN(r)&&!isNaN(n)&&!isNaN(i))throw new Sk.builtin.ValueError(\"math domain error\");return new Sk.builtin.float_(r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return fmod(x, y), according to platform C.\\n\\nx % y may differ.\"},frexp:{$meth:function frexp(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e),n=[t,0];if(0!==t&&Number.isFinite(t)){const e=Math.abs(t);let i=Math.max(-1023,Math.floor(Math.log2(e))+1),r=e*Math.pow(2,-i);for(;r<.5;)r*=2,i--;for(;r>=1;)r*=.5,i++;t<0&&(r=-r),n[0]=r,n[1]=i}return n[0]=new Sk.builtin.float_(n[0]),n[1]=new Sk.builtin.int_(n[1]),new Sk.builtin.tuple(n)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the mantissa and exponent of x, as pair (m, e).\\n\\nm is a float and e is an int, such that x = m * 2.**e.\\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.\"},fsum:{$meth:function fsum(e){if(!Sk.builtin.checkIterable(e))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(e)+\"' object is not iterable\");let t,n,i,r=[];for(let l=(e=Sk.abstr.iter(e)).tp$iternext();void 0!==l;l=e.tp$iternext()){Sk.builtin.pyCheckType(\"\",\"real number\",Sk.builtin.checkNumber(l)),t=0;let e=l.v;\"number\"!=typeof e&&(e=l.nb$float().v),l=e;for(let u=0,o=r.length;u<o;u++){let e=r[u];if(Math.abs(l)<Math.abs(e)){let t=l;l=e,e=t}n=l+e,i=e-(n-l),i&&(r[t]=i,t++),l=n}r=r.slice(0,t).concat([l])}const u=r.reduce((function(e,t){return e+t}),0);return new Sk.builtin.float_(u)},$flags:{OneArg:!0},$textsig:\"($module, seq, /)\",$doc:\"Return an accurate floating point sum of values in the iterable seq.\\n\\nAssumes IEEE-754 floating point arithmetic.\"},gamma:{$meth:function gamma(e){throw new Sk.builtin.NotImplementedError(\"math.gamma() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Gamma function at x.\"},gcd:{$meth:function gcd(e,t){Sk.builtin.pyCheckType(\"a\",\"integer\",Sk.builtin.checkInt(e)),Sk.builtin.pyCheckType(\"b\",\"integer\",Sk.builtin.checkInt(t));const n=_gcd_internal(Sk.builtin.asnum$(e),Sk.builtin.asnum$(t));return\"number\"==typeof n?new Sk.builtin.int_(n):new Sk.builtin.int_(n.toString())},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"greatest common divisor of x and y\"},hypot:{$meth:function hypot(e,t){return Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t)),e=Sk.builtin.asnum$(e),t=Sk.builtin.asnum$(t),new Sk.builtin.float_(Math.sqrt(e*e+t*t))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return the Euclidean distance, sqrt(x*x + y*y).\"},isclose:{$meth:function isclose(e,t){Sk.abstr.checkArgsLen(\"isclose\",e,2,2);const n=Sk.abstr.copyKeywordsToNamedArgs(\"isclose\",[\"rel_tol\",\"abs_tol\"],[],t,[new Sk.builtin.float_(1e-9),new Sk.builtin.float_(0)]),i=e[0],r=e[1],u=n[0],l=n[1];Sk.builtin.pyCheckType(\"a\",\"number\",Sk.builtin.checkNumber(i)),Sk.builtin.pyCheckType(\"b\",\"number\",Sk.builtin.checkNumber(r)),Sk.builtin.pyCheckType(\"rel_tol\",\"number\",Sk.builtin.checkNumber(u)),Sk.builtin.pyCheckType(\"abs_tol\",\"number\",Sk.builtin.checkNumber(l));const o=Sk.builtin.asnum$(i),a=Sk.builtin.asnum$(r),s=Sk.builtin.asnum$(u),b=Sk.builtin.asnum$(l);if(s<0||b<0)throw new Sk.builtin.ValueError(\"tolerances must be non-negative\");if(o==a)return Sk.builtin.bool.true$;if(o==1/0||o==-1/0||a==1/0||a==-1/0)return Sk.builtin.bool.false$;const c=Math.abs(a-o),m=c<=Math.abs(s*a)||c<=Math.abs(s*o)||c<=b;return new Sk.builtin.bool(m)},$flags:{FastCall:!0},$textsig:\"($module, /, a, b, *, rel_tol=1e-09, abs_tol=0.0)\",$doc:'Determine whether two floating point numbers are close in value.\\n\\n  rel_tol\\n    maximum difference for being considered \"close\", relative to the\\n    magnitude of the input values\\n  abs_tol\\n    maximum difference for being considered \"close\", regardless of the\\n    magnitude of the input values\\n\\nReturn True if a is close in value to b, and False otherwise.\\n\\nFor the values to be considered close, the difference between them\\nmust be smaller than at least one of the tolerances.\\n\\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\\nis, NaN is not close to anything, even itself.  inf and -inf are\\nonly close to themselves.'},isfinite:{$meth:function isfinite(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);return Sk.builtin.checkInt(e)||isFinite(t)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is neither an infinity nor a NaN, and False otherwise.\"},isinf:{$meth:function isinf(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);return Sk.builtin.checkInt(e)||isFinite(t)||isNaN(t)?Sk.builtin.bool.false$:Sk.builtin.bool.true$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a positive or negative infinity, and False otherwise.\"},isnan:{$meth:function isnan(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);return isNaN(t)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a NaN (not a number), and False otherwise.\"},isqrt:{$meth:function isqrt(e){let t=Sk.misceval.asIndexOrThrow(e);if(t<0)throw new Sk.builtin.ValueError(\"isqrt() argument must be nonnegative\");return 0==t?new Sk.builtin.int_(0):\"number\"==typeof t?new Sk.builtin.int_(Math.floor(Math.sqrt(t))):function bigint_isqrt(e){let t=e.toString(2).length;t=Math.floor((t-1)/2);let n=t.toString(2).length;const i=JSBI.BigInt(1),r=JSBI.BigInt(2),u=JSBI.BigInt(t),l=JSBI.multiply(r,u);let o=i,a=JSBI.BigInt(0);for(;n>0;){n--;let t=a;a=JSBI.signedRightShift(u,JSBI.BigInt(n));const r=JSBI.subtract(JSBI.subtract(a,t),i),s=JSBI.leftShift(o,r),b=JSBI.add(JSBI.subtract(JSBI.subtract(l,t),a),i),c=JSBI.signedRightShift(e,b);o=JSBI.add(s,JSBI.divide(c,o))}let s=o;return JSBI.greaterThan(JSBI.multiply(s,s),e)&&(s=JSBI.subtract(s,i)),JSBI.lessThanOrEqual(s,JSBI.BigInt(Number.MAX_SAFE_INTEGER))&&(s=Number(s)),new Sk.builtin.int_(s)}(t)},$flags:{OneArg:!0},$textsig:\"($module, n, /)\",$doc:\"Return the integer part of the square root of the input.\"},lcm:{$meth:function lcm(...e){function abs(e){return\"number\"==typeof e?new Sk.builtin.int_(Math.abs(e)):JSBI.lessThan(e,JSBI.__ZERO)?new Sk.builtin.int_(JSBI.unaryMinus(e)):new Sk.builtin.int_(e)}const t=e.length;if(0===t)return new Sk.builtin.int_(1);let n;for(n=0;n<t;++n)e[n]=Sk.misceval.asIndexOrThrow(e[n]);let i,r=e[0];if(1===t)return abs(r);for(n=1;n<t;++n){if(i=e[n],0===i)return new Sk.builtin.int_(0);if(\"number\"==typeof r&&\"number\"==typeof i){let e=r/_gcd_internal(r,i)*i;e=Math.abs(e),r=e>Number.MAX_SAFE_INTEGER?JSBI.BigInt(r):e}else r=JSBI.BigInt(r);\"number\"!=typeof r&&(i=JSBI.BigInt(i),r=JSBI.multiply(JSBI.divide(r,_gcd_internal(r,i)),i))}return abs(r)},$flags:{MinArgs:0},$textsig:\"($module, *integers, /)\",$doc:\"Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1.\"},ldexp:{$meth:function ldexp(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"i\",\"integer\",Sk.builtin.checkInt(t));let n=e.v;\"number\"!=typeof n&&(n=e.nb$float().v);const i=Sk.builtin.asnum$(t);if(n==1/0||n==-1/0||0==n||isNaN(n))return new Sk.builtin.float_(n);const r=n*Math.pow(2,i);if(!isFinite(r))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, i, /)\",$doc:\"Return x * (2**i).\\n\\nThis is essentially the inverse of frexp().\"},lgamma:{$meth:function lgamma(e){throw new Sk.builtin.NotImplementedError(\"math.lgamma() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Natural logarithm of absolute value of Gamma function at x.\"},log:{$meth:function log(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let n,i,r=Sk.builtin.asnum$(e);if(r<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(void 0===t?n=Math.E:(Sk.builtin.pyCheckType(\"base\",\"number\",Sk.builtin.checkNumber(t)),n=Sk.builtin.asnum$(t)),n<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(Sk.builtin.checkFloat(e)||r<Number.MAX_SAFE_INTEGER)i=Math.log(r)/Math.log(n);else{r=new Sk.builtin.str(e).$jsstr();const t=r.length,u=parseFloat(\"0.\"+r);i=(t*Math.log(10)+Math.log(u))/Math.log(n)}return new Sk.builtin.float_(i)},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:\"log(x, [base=e])\\nReturn the logarithm of x to the given base.\\n\\nIf the base not specified, returns the natural logarithm (base e) of x.\"},log10:{$meth:function log10(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t,n=Sk.builtin.asnum$(e);if(n<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(Sk.builtin.checkFloat(e)||n<Number.MAX_SAFE_INTEGER)t=Math.log10(n);else{n=new Sk.builtin.str(e).$jsstr();const i=n.length,r=parseFloat(\"0.\"+n);t=i+Math.log10(r)}return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 10 logarithm of x.\"},log1p:{$meth:function log1p(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=e.v;if(\"number\"!=typeof t&&(t=e.nb$float().v),t<=-1)throw new Sk.builtin.ValueError(\"math domain error\");if(0==t)return new Sk.builtin.float_(t);if(Math.abs(t)<Number.EPSILON/2)return new Sk.builtin.float_(t);if(-.5<=t&&t<=1){const e=1+t,n=Math.log(e)-(e-1-t)/e;return new Sk.builtin.float_(n)}{const e=Math.log(1+t);return new Sk.builtin.float_(e)}},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the natural logarithm of 1+x (base e).\\n\\nThe result is computed in a way which is accurate for x near zero.\"},log2:{$meth:function log2(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t,n=Sk.builtin.asnum$(e);if(n<=0)throw new Sk.builtin.ValueError(\"math domain error\");if(Sk.builtin.checkFloat(e)||n<Number.MAX_SAFE_INTEGER)t=Math.log2(n);else{n=new Sk.builtin.str(e).$jsstr();const i=n.length,r=parseFloat(\"0.\"+n);t=i*Math.log2(10)+Math.log2(r)}return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 2 logarithm of x.\"},modf:{$meth:function modf(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));let t=Sk.builtin.asnum$(e);if(!isFinite(t)){if(t==1/0)return new Sk.builtin.tuple([new Sk.builtin.float_(0),new Sk.builtin.float_(t)]);if(t==-1/0)return new Sk.builtin.tuple([new Sk.builtin.float_(-0),new Sk.builtin.float_(t)]);if(isNaN(t))return new Sk.builtin.tuple([new Sk.builtin.float_(t),new Sk.builtin.float_(t)])}const n=get_sign(t);t=Math.abs(t);const i=n*Math.floor(t),r=n*(t-Math.floor(t));return new Sk.builtin.tuple([new Sk.builtin.float_(r),new Sk.builtin.float_(i)])},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the fractional and integer parts of x.\\n\\nBoth results carry the sign of x and are floats.\"},perm:{$meth:function perm(e,t){if(void 0===t||Sk.builtin.checkNone(t))return factorial(e);if(e=Sk.misceval.asIndexOrThrow(e),t=Sk.misceval.asIndexOrThrow(t),e<0)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");if(t<0)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(t>e)return new Sk.builtin.int_(0);if(0===t)return new Sk.builtin.int_(1);if(t>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"k must not exceed \"+Number.MAX_SAFE_INTEGER);const n=new Sk.builtin.int_(1);let i=e=new Sk.builtin.int_(e);for(let r=1;r<t;r++)e=e.nb$subtract(n),i=i.nb$multiply(e);return i},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"'Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.'\"},prod:{$meth:function prod(e,t){Sk.abstr.checkArgsLen(\"prod\",e,1,1),e=Sk.abstr.copyKeywordsToNamedArgs(\"prod\",[null,\"start\"],e,t,[new Sk.builtin.int_(1)]);const n=Sk.abstr.iter(e[0]);let i,r=e[1];return i=r.constructor===Sk.builtin.int_?function fastProdInt(){return Sk.misceval.iterFor(n,(e=>{if(e.constructor!==Sk.builtin.int_)return e.constructor===Sk.builtin.float_?(r=r.nb$float().nb$multiply(e),new Sk.misceval.Break(\"float\")):(r=Sk.abstr.numberBinOp(r,e,\"Mult\"),new Sk.misceval.Break(\"slow\"));r=r.nb$multiply(e)}))}():r.constructor===Sk.builtin.float_?\"float\":\"slow\",Sk.misceval.chain(i,(e=>\"float\"===e?function fastProdFloat(){return Sk.misceval.iterFor(n,(e=>{if(e.constructor!==Sk.builtin.float_&&e.constructor!==Sk.builtin.int_)return r=Sk.abstr.numberBinOp(r,e,\"Mult\"),new Sk.misceval.Break(\"slow\");r=r.nb$multiply(e)}))}():e),(e=>{if(\"slow\"===e)return function slowProd(){return Sk.misceval.iterFor(n,(e=>{r=Sk.abstr.numberBinOp(r,e,\"Mult\")}))}()}),(()=>r))},$flags:{FastCall:!0},$textsig:\"($module, iterable, /, *, start=1)\",$doc:\"Calculate the product of all the elements in the input iterable. The default start value for the product is 1.\\n\\nWhen the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.\"},pow:{$meth:function pow(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if(\"number\"!=typeof n&&(n=e.nb$float().v),\"number\"!=typeof i&&(i=t.nb$float().v),0==n&&i<0)throw new Sk.builtin.ValueError(\"math domain error\");if(1==n)return new Sk.builtin.float_(1);if(Number.isFinite(n)&&Number.isFinite(i)&&n<0&&!Number.isInteger(i))throw new Sk.builtin.ValueError(\"math domain error\");if(-1==n&&(i==-1/0||i==1/0))return new Sk.builtin.float_(1);const r=Math.pow(n,i);if(!Number.isFinite(n)||!Number.isFinite(i))return new Sk.builtin.float_(r);if(r==1/0||r==-1/0)throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(r)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return x**y (x to the power of y).\"},radians:{$meth:function radians(e){Sk.builtin.pyCheckType(\"deg\",\"number\",Sk.builtin.checkNumber(e));const t=Math.PI/180*Sk.builtin.asnum$(e);return new Sk.builtin.float_(t)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from degrees to radians.\"},remainder:{$meth:function remainder(e,t){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(t));let n=e.v,i=t.v;if(\"number\"!=typeof n&&(n=e.nb$float().v),\"number\"!=typeof i&&(i=t.nb$float().v),isFinite(n)&&isFinite(i)){let e,t,r,u,l;if(0==i)throw new Sk.builtin.ValueError(\"math domain error\");if(e=Math.abs(n),t=Math.abs(i),u=e%t,r=t-u,u<r)l=u;else if(u>r)l=-r;else{if(u!=r)throw new Sk.builtin.AssertionError;l=u-.5*(e-u)%t*2}return new Sk.builtin.float_(get_sign(n)*l)}if(isNaN(n))return e;if(isNaN(i))return t;if(n==1/0||n==-1/0)throw new Sk.builtin.ValueError(\"math domain error\");if(i!=1/0&&i!=-1/0)throw new Sk.builtin.AssertionError;return new Sk.builtin.float_(n)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Difference between x and the closest integer multiple of y.\\n\\nReturn x - n*y where n*y is the closest integer multiple of y.\\nIn the case where x is exactly halfway between two multiples of\\ny, the nearest even value of n is used. The result is always exact.\"},sin:{$meth:function sin(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.sin(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the sine of x (measured in radians).\"},sinh:{$meth:function sinh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e);const t=Math.E,n=Math.pow(t,e),i=(n-1/n)/2;return new Sk.builtin.float_(i)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic sine of x.\"},sqrt:{$meth:function sqrt(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);if(t<0)throw new Sk.builtin.ValueError(\"math domain error\");return new Sk.builtin.float_(Math.sqrt(t))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the square root of x.\"},tan:{$meth:function tan(e){return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(e)),new Sk.builtin.float_(Math.tan(Sk.builtin.asnum$(e)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the tangent of x (measured in radians).\"},tanh:{$meth:function tanh(e){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(e));const t=Sk.builtin.asnum$(e);if(0===t)return new Sk.builtin.float_(t);const n=Math.E,i=Math.pow(n,t),r=1/i,u=(i-r)/2/((i+r)/2);return new Sk.builtin.float_(u)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic tangent of x.\"},trunc:{$meth:function trunc(e){if(e.ob$type===i)return e.nb$int();const n=o(e,t.$trunc);if(void 0===n)throw new r(`type ${e.tp$name} doesn't define __trunc__ method`);return a(n)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Truncates the Real x to the nearest Integral toward 0.\\n\\nUses the __trunc__ magic method.\"}}),s};","src/lib/operator.js":"function $builtinmodule(e){const{builtin:{str:t,tuple:a,list:r,int_:o,bool:n,TypeError:s,ValueError:i,none:{none$:m},NotImplemented:{NotImplemented$:d},abs:l,len:h,checkString:u,checkInt:c},abstr:{buildNativeClass:M,checkNoKwargs:b,checkArgsLen:g,checkOneArg:f,numberUnaryOp:p,numberBinOp:A,numberInplaceBinOp:k,objectGetItem:$,objectDelItem:_,objectSetItem:w,sequenceConcat:v,sequenceContains:x,sequenceGetCountOf:j,sequenceGetIndexOf:O,sequenceInPlaceConcat:I,typeName:S,lookupSpecial:y,gattr:q,setUpModuleMethods:R},misceval:{richCompareBool:B,asIndexOrThrow:N,chain:E,callsimArray:T,callsimOrSuspendArray:C,objectRepr:D},generic:{getAttr:G}}=Sk,L=[\"abs\",\"add\",\"and_\",\"concat\",\"contains\",\"delitem\",\"eq\",\"floordiv\",\"ge\",\"getitem\",\"gt\",\"iadd\",\"iand\",\"iconcat\",\"ifloordiv\",\"ilshift\",\"imatmul\",\"imod\",\"imul\",\"index\",\"inv\",\"invert\",\"ior\",\"ipow\",\"irshift\",\"isub\",\"itruediv\",\"ixor\",\"le\",\"lshift\",\"lt\",\"matmul\",\"mod\",\"mul\",\"ne\",\"neg\",\"not_\",\"or_\",\"pos\",\"pow\",\"rshift\",\"setitem\",\"sub\",\"truediv\",\"xor\"],F=[\"attrgetter\",\"countOf\",\"indexOf\",\"is_\",\"is_not\",\"itemgetter\",\"length_hint\",\"methodcaller\",\"truth\",...L].sort(),P={__name__:new t(\"operator\"),__doc__:new t(\"Operator interface.\\n\\nThis module exports a set of functions implemented in javascript corresponding\\nto the intrinsic operators of Python.  For example, operator.add(x, y)\\nis equivalent to the expression x+y.  The function names are those\\nused for special methods; variants without leading and trailing\\n'__' are also provided for convenience.\"),__all__:new r(F.map((e=>new t(e))))};P.itemgetter=M(\"operator.itemgetter\",{constructor:function itemgetter(e){this.items=e,this.oneitem=1===e.length,this.item=e[0],this.in$repr=!1},slots:{tp$getattr:G,tp$new:(e,t)=>(b(\"itemgetter\",t),g(\"itemgetter\",e,1),new P.itemgetter(e)),tp$call(e,t){f(\"itemgetter\",e,t);const r=e[0];return this.oneitem?$(r,this.item,!0):new a(this.items.map((e=>$(r,e))))},tp$doc:\"Return a callable object that fetches the given item(s) from its operand.\\n            After f = itemgetter(2), the call f(r) returns r[2].\\n            After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\",$r(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;const e=this.tp$name+\"(\"+this.items.map((e=>D(e))).join(\", \")+\")\";return this.in$repr=!1,e}}}),P.attrgetter=M(\"operator.attrgetter\",{constructor:function attrgetter(e){this.attrs=e,this.oneattr=1===e.length,this.attr=e[0],this.in$repr=!1},slots:{tp$getattr:G,tp$new(e,a){b(\"attrgetter\",a),g(\"attrgetter\",e,1);const r=[];for(let o=0;o<e.length;o++){const a=e[o];if(!u(a))throw new s(\"attribute name must be a string\");const n=a.toString();n.includes(\".\")?r.push(n.split(\".\").map((e=>new t(e)))):r.push([a])}return new P.attrgetter(r)},tp$call(e,t){f(\"attrgetter\",e,t);const r=e[0];if(this.oneattr)return this.attr.reduce(((e,t)=>q(e,t)),r);const o=this.attrs.map((e=>e.reduce(((e,t)=>q(e,t)),r)));return new a(o)},tp$doc:\"attrgetter(attr, ...) --\\x3e attrgetter object\\n\\nReturn a callable object that fetches the given attribute(s) from its operand.\\nAfter f = attrgetter('name'), the call f(r) returns r.name.\\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\\n(r.name.first, r.name.last).\",$r(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;const e=this.tp$name+\"(\"+this.items.map((e=>D(e))).join(\", \")+\")\";return this.in$repr=!1,e}}}),P.methodcaller=M(\"operator.methodcaller\",{constructor:function methodcaller(e,t,a){this.$name=e,this.args=t,this.kwargs=a||[],this.in$repr=!1},slots:{tp$getattr:G,tp$new(e,t){g(\"methodcaller\",e,1);const a=e[0];if(!u(a))throw new s(\"method name must be a string\");return new P.methodcaller(a,e.slice(1),t)},tp$call(e,t){f(\"methodcaller\",e,t);const a=e[0];return E(q(a,this.$name,!0),(e=>C(e,this.args,this.kwargs)))},tp$doc:\"methodcaller(name, ...) --\\x3e methodcaller object\\n\\nReturn a callable object that calls the given method on its operand.\\nAfter f = methodcaller('name'), the call f(r) returns r.name().\\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\\nr.name('date', foo=1).\",$r(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;let e=[D(this.$name)];e.push(...this.args.map((e=>D(e))));for(let t=0;t<this.kwargs.length;t+=2)e.push(this.kwargs[t]+\"=\"+D(this.kwargs[t+1]));return e=this.tp$name+\"(\"+e.join(\", \")+\")\",this.in$repr=!1,e}}});const U={1:{$flags:{OneArg:!0},$textsig:\"($module, a, /)\"},2:{$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\"},3:{$flags:{MinArgs:3,MaxArgs:3},$textsig:\"($module, a, b, c, /)\"}};function makeModuleMethod(e,t){return{$meth:e,$doc:t,...U[e.length]}}function sameAs(e){return\"Same as \"+e+\".\"}return R(\"operator\",P,{lt:makeModuleMethod(((e,t)=>n(B(e,t,\"Lt\"))),sameAs(\"a < b\")),le:makeModuleMethod(((e,t)=>n(B(e,t,\"LtE\"))),sameAs(\"a <= b\")),eq:makeModuleMethod(((e,t)=>n(B(e,t,\"Eq\"))),sameAs(\"a == b\")),ne:makeModuleMethod(((e,t)=>n(B(e,t,\"NotEq\"))),sameAs(\"a != b\")),ge:makeModuleMethod(((e,t)=>n(B(e,t,\"GtE\"))),sameAs(\"a >= b\")),gt:makeModuleMethod(((e,t)=>n(B(e,t,\"Gt\"))),sameAs(\"a > b\")),not_:makeModuleMethod((e=>p(e,\"Not\")),sameAs(\"not a\")),truth:makeModuleMethod((e=>n(e)),\"Return True if a is true, False otherwise.\"),is_:makeModuleMethod(((e,t)=>n(B(e,t,\"Is\"))),sameAs(\"a is b\")),is_not:makeModuleMethod(((e,t)=>n(B(e,t,\"IsNot\"))),sameAs(\"a is not b\")),abs:makeModuleMethod((e=>l(e)),sameAs(\"abs(a)\")),add:makeModuleMethod(((e,t)=>A(e,t,\"Add\")),sameAs(\"a + b\")),and_:makeModuleMethod(((e,t)=>A(e,t,\"BitAnd\")),sameAs(\"a & b\")),floordiv:makeModuleMethod(((e,t)=>A(e,t,\"FloorDiv\")),sameAs(\"a // b\")),index:makeModuleMethod((e=>new o(N(e))),sameAs(\"a.__index__()\")),inv:makeModuleMethod((e=>p(e,\"Invert\")),sameAs(\"~a\")),invert:makeModuleMethod((e=>p(e,\"Invert\")),sameAs(\"~a\")),lshift:makeModuleMethod(((e,t)=>A(e,t,\"LShift\")),sameAs(\"a << b\")),mod:makeModuleMethod(((e,t)=>A(e,t,\"Mod\")),sameAs(\"a % b\")),mul:makeModuleMethod(((e,t)=>A(e,t,\"Mult\")),sameAs(\"a * b\")),matmul:makeModuleMethod(((e,t)=>A(e,t,\"MatMult\")),sameAs(\"a @ b\")),neg:makeModuleMethod((e=>p(e,\"USub\")),sameAs(\"-a\")),or_:makeModuleMethod(((e,t)=>A(e,t,\"BitOr\")),sameAs(\"a | b\")),pos:makeModuleMethod((e=>p(e,\"UAdd\")),sameAs(\"+a\")),pow:makeModuleMethod(((e,t)=>A(e,t,\"Pow\")),sameAs(\"a ** b\")),rshift:makeModuleMethod(((e,t)=>A(e,t,\"RShift\")),sameAs(\"a >> b\")),sub:makeModuleMethod(((e,t)=>A(e,t,\"Sub\")),sameAs(\"a - b\")),truediv:makeModuleMethod(((e,t)=>A(e,t,\"Div\")),sameAs(\"a / b\")),xor:makeModuleMethod(((e,t)=>A(e,t,\"BitXor\")),sameAs(\"a ^ b\")),concat:makeModuleMethod(((e,t)=>v(e,t)),sameAs(\"a + b, for a and b sequences\")),contains:makeModuleMethod(((e,t)=>E(x(e,t),n)),sameAs(\"b in a (note reversed operands)\")),countOf:makeModuleMethod(((e,t)=>j(e,t)),\"Return thenumber of times b occurs in a.\"),delitem:makeModuleMethod(((e,t)=>E(_(e,t,!0),(()=>m))),sameAs(\"del a[b]\")),getitem:makeModuleMethod(((e,t)=>$(e,t,!0)),sameAs(\"a[b]\")),indexOf:makeModuleMethod(((e,t)=>O(e,t)),\"Return the first index of b in a\"),setitem:makeModuleMethod(((e,t,a)=>E(w(e,t,a,!0),(()=>m))),sameAs(\"a[b] = c\")),length_hint:{$meth:function length_hint(e,a){if(void 0===a)a=new o(0);else if(!c(a))throw new s(\"'\"+S(a)+\"' object cannot be interpreted as an integer\");try{return h(e)}catch(m){if(!(m instanceof s))throw m}const r=y(e,t.$length_hint);if(void 0===r)return a;let n;try{n=T(r,[])}catch(m){if(!(m instanceof s))throw m;return a}if(n===d)return a;if(!c(n))throw new s(\"__length_hint__ must be an integer, not \"+S(n));if(n.nb$isnegative())throw new i(\"__length_hint__() should return >= 0\");return n},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, obj, default=0, /)\",$doc:\"Return an estimate of the number of items in obj.\\n\\nThis is useful for presizing containers when building from an iterable.\\n\\nIf the object supports len(), the result will be exact.\\nOtherwise, it may over- or under-estimate by an arbitrary amount.\\nThe result will be an integer >= 0.\"},iadd:makeModuleMethod(((e,t)=>k(e,t,\"Add\")),sameAs(\"a += b\")),iand:makeModuleMethod(((e,t)=>k(e,t,\"BitAnd\")),sameAs(\"a &= b\")),iconcat:makeModuleMethod(((e,t)=>I(e,t)),sameAs(\"a += b, for a and b sequences\")),ifloordiv:makeModuleMethod(((e,t)=>k(e,t,\"FloorDiv\")),sameAs(\"a //= b\")),ilshift:makeModuleMethod(((e,t)=>k(e,t,\"LShift\")),sameAs(\"a <<= b\")),imod:makeModuleMethod(((e,t)=>k(e,t,\"Mod\")),sameAs(\"a %= b\")),imul:makeModuleMethod(((e,t)=>k(e,t,\"Mult\")),sameAs(\"a *= b\")),imatmul:makeModuleMethod(((e,t)=>k(e,t,\"MatMult\")),sameAs(\"a @= b\")),ior:makeModuleMethod(((e,t)=>k(e,t,\"BitOr\")),sameAs(\"a |= b\")),ipow:makeModuleMethod(((e,t)=>k(e,t,\"Pow\")),sameAs(\"a **= b\")),irshift:makeModuleMethod(((e,t)=>k(e,t,\"RShift\")),sameAs(\"a >>= b\")),isub:makeModuleMethod(((e,t)=>k(e,t,\"Sub\")),sameAs(\"a -= b\")),itruediv:makeModuleMethod(((e,t)=>k(e,t,\"Div\")),sameAs(\"a /= b\")),ixor:makeModuleMethod(((e,t)=>k(e,t,\"BitXor\")),sameAs(\"a ^= b\"))}),L.forEach((e=>{P[`__${e.replace(\"_\",\"\")}__`]=P[e]})),P.div=P.truediv,P.__div__=P.div,P}","src/lib/platform.js":"var $builtinmodule=function(n){var e={},i=\"undefined\"!=typeof window&&\"undefined\"!=typeof window.navigator;return e.python_implementation=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"python_implementation\",arguments.length,0,0),new Sk.builtin.str(\"Skulpt\")})),e.node=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"node\",arguments.length,0,0),new Sk.builtin.str(\"\")})),e.version=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"version\",arguments.length,0,0),new Sk.builtin.str(\"\")})),e.python_version=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"python_version\",arguments.length,0,0),n=Sk.__future__.python_version?\"3.2.0\":\"2.7.0\",new Sk.builtin.str(n)})),e.system=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"system\",arguments.length,0,0),n=i?window.navigator.appCodeName:\"\",new Sk.builtin.str(n)})),e.machine=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"machine\",arguments.length,0,0),n=i?window.navigator.platform:\"\",new Sk.builtin.str(n)})),e.release=new Sk.builtin.func((function(){var n;return Sk.builtin.pyCheckArgsLen(\"release\",arguments.length,0,0),n=i?window.navigator.appVersion:\"\",new Sk.builtin.str(n)})),e.architecture=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"architecture\",arguments.length,0,0),new Sk.builtin.tuple([new Sk.builtin.str(\"64bit\"),new Sk.builtin.str(\"\")])})),e.processor=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"processor\",arguments.length,0,0),new Sk.builtin.str(\"\")})),e};","src/lib/processing.js":"var $builtinmodule=function(n){var i,e,t,u,o,s,l,c={__name__:new Sk.builtin.str(\"processing\")},r=[],v=!0,f=null;c.processing=null,c.p=null,c.X=new Sk.builtin.int_(0),c.Y=new Sk.builtin.int_(1),c.Z=new Sk.builtin.int_(2),c.R=new Sk.builtin.int_(3),c.G=new Sk.builtin.int_(4),c.B=new Sk.builtin.int_(5),c.A=new Sk.builtin.int_(6),c.U=new Sk.builtin.int_(7),c.V=new Sk.builtin.int_(8),c.NX=new Sk.builtin.int_(9),c.NY=new Sk.builtin.int_(10),c.NZ=new Sk.builtin.int_(11),c.EDGE=new Sk.builtin.int_(12),c.SR=new Sk.builtin.int_(13),c.SG=new Sk.builtin.int_(14),c.SB=new Sk.builtin.int_(15),c.SA=new Sk.builtin.int_(16),c.SW=new Sk.builtin.int_(17),c.TX=new Sk.builtin.int_(18),c.TY=new Sk.builtin.int_(19),c.TZ=new Sk.builtin.int_(20),c.VX=new Sk.builtin.int_(21),c.VY=new Sk.builtin.int_(22),c.VZ=new Sk.builtin.int_(23),c.VW=new Sk.builtin.int_(24),c.AR=new Sk.builtin.int_(25),c.AG=new Sk.builtin.int_(26),c.AB=new Sk.builtin.int_(27),c.DR=new Sk.builtin.int_(3),c.DG=new Sk.builtin.int_(4),c.DB=new Sk.builtin.int_(5),c.DA=new Sk.builtin.int_(6),c.SPR=new Sk.builtin.int_(28),c.SPG=new Sk.builtin.int_(29),c.SPB=new Sk.builtin.int_(30),c.SHINE=new Sk.builtin.int_(31),c.ER=new Sk.builtin.int_(32),c.EG=new Sk.builtin.int_(33),c.EB=new Sk.builtin.int_(34),c.BEEN_LIT=new Sk.builtin.int_(35),c.VERTEX_FIELD_COUNT=new Sk.builtin.int_(36),c.CENTER=new Sk.builtin.int_(3),c.RADIUS=new Sk.builtin.int_(2),c.CORNERS=new Sk.builtin.int_(1),c.CORNER=new Sk.builtin.int_(0),c.DIAMETER=new Sk.builtin.int_(3),c.BASELINE=new Sk.builtin.int_(0),c.TOP=new Sk.builtin.int_(101),c.BOTTOM=new Sk.builtin.int_(102),c.NORMAL=new Sk.builtin.int_(1),c.NORMALIZED=new Sk.builtin.int_(1),c.IMAGE=new Sk.builtin.int_(2),c.MODEL=new Sk.builtin.int_(4),c.SHAPE=new Sk.builtin.int_(5),c.AMBIENT=new Sk.builtin.int_(0),c.DIRECTIONAL=new Sk.builtin.int_(1),c.SPOT=new Sk.builtin.int_(3),c.RGB=new Sk.builtin.int_(1),c.ARGB=new Sk.builtin.int_(2),c.HSB=new Sk.builtin.int_(3),c.ALPHA=new Sk.builtin.int_(4),c.CMYK=new Sk.builtin.int_(5),c.TIFF=new Sk.builtin.int_(0),c.TARGA=new Sk.builtin.int_(1),c.JPEG=new Sk.builtin.int_(2),c.GIF=new Sk.builtin.int_(3),c.MITER=new Sk.builtin.str(\"miter\"),c.BEVEL=new Sk.builtin.str(\"bevel\"),c.ROUND=new Sk.builtin.str(\"round\"),c.SQUARE=new Sk.builtin.str(\"butt\"),c.PROJECT=new Sk.builtin.str(\"square\"),c.P2D=new Sk.builtin.int_(1),c.JAVA2D=new Sk.builtin.int_(1),c.WEBGL=new Sk.builtin.int_(2),c.P3D=new Sk.builtin.int_(2),c.OPENGL=new Sk.builtin.int_(2),c.PDF=new Sk.builtin.int_(0),c.DXF=new Sk.builtin.int_(0),c.OTHER=new Sk.builtin.int_(0),c.WINDOWS=new Sk.builtin.int_(1),c.MAXOSX=new Sk.builtin.int_(2),c.LINUX=new Sk.builtin.int_(3),c.EPSILON=new Sk.builtin.float_(1e-4),c.MAX_FLOAT=new Sk.builtin.float_(34028235e31),c.MIN_FLOAT=new Sk.builtin.float_(-34028235e31),c.MAX_INT=new Sk.builtin.int_(2147483647),c.MIN_INT=new Sk.builtin.int_(-2147483648),c.HALF_PI=new Sk.builtin.float_(Math.PI/2),c.THIRD_PI=new Sk.builtin.float_(Math.PI/3),c.PI=new Sk.builtin.float_(Math.PI),c.TWO_PI=new Sk.builtin.float_(2*Math.PI),c.TAU=new Sk.builtin.float_(2*Math.PI),c.QUARTER_PI=new Sk.builtin.float_(Math.PI/4),c.DEG_TO_RAD=new Sk.builtin.float_(Math.PI/180),c.RAD_TO_DEG=new Sk.builtin.float_(180/Math.PI),c.WHITESPACE=new Sk.builtin.str(\" \\t\\n\\r\\f \"),c.POINT=new Sk.builtin.int_(2),c.POINTS=new Sk.builtin.int_(2),c.LINE=new Sk.builtin.int_(4),c.LINES=new Sk.builtin.int_(4),c.TRIANGLE=new Sk.builtin.int_(8),c.TRIANGLES=new Sk.builtin.int_(9),c.TRIANGLE_FAN=new Sk.builtin.int_(11),c.TRIANGLE_STRIP=new Sk.builtin.int_(10),c.QUAD=new Sk.builtin.int_(16),c.QUADS=new Sk.builtin.int_(16),c.QUAD_STRIP=new Sk.builtin.int_(17),c.POLYGON=new Sk.builtin.int_(20),c.PATH=new Sk.builtin.int_(21),c.RECT=new Sk.builtin.int_(30),c.ELLIPSE=new Sk.builtin.int_(31),c.ARC=new Sk.builtin.int_(32),c.SPHERE=new Sk.builtin.int_(40),c.BOX=new Sk.builtin.int_(41),c.GROUP=new Sk.builtin.int_(0),c.PRIMITIVE=new Sk.builtin.int_(1),c.GEOMETRY=new Sk.builtin.int_(3),c.VERTEX=new Sk.builtin.int_(0),c.BEZIER_VERTEX=new Sk.builtin.int_(1),c.CURVE_VERTEX=new Sk.builtin.int_(2),c.BREAK=new Sk.builtin.int_(3),c.CLOSESHAPE=new Sk.builtin.int_(4),c.REPLACE=new Sk.builtin.int_(0),c.BLEND=new Sk.builtin.int_(1),c.ADD=new Sk.builtin.int_(2),c.SUBTRACT=new Sk.builtin.int_(4),c.LIGHTEST=new Sk.builtin.int_(8),c.DARKEST=new Sk.builtin.int_(16),c.DIFFERENCE=new Sk.builtin.int_(32),c.EXCLUSION=new Sk.builtin.int_(64),c.MULTIPLY=new Sk.builtin.int_(128),c.SCREEN=new Sk.builtin.int_(256),c.OVERLAY=new Sk.builtin.int_(512),c.HARD_LIGHT=new Sk.builtin.int_(1024),c.SOFT_LIGHT=new Sk.builtin.int_(2048),c.DODGE=new Sk.builtin.int_(4096),c.BURN=new Sk.builtin.int_(8192),c.ALPHA_MASK=new Sk.builtin.int_(4278190080),c.RED_MASK=new Sk.builtin.int_(16711680),c.GREEN_MASK=new Sk.builtin.int_(65280),c.BLUE_MASK=new Sk.builtin.int_(255),c.CUSTOM=new Sk.builtin.int_(0),c.ORTHOGRAPHIC=new Sk.builtin.int_(2),c.PERSPECTIVE=new Sk.builtin.int_(3),c.ARROW=new Sk.builtin.str(\"default\"),c.CROSS=new Sk.builtin.str(\"crosshair\"),c.HAND=new Sk.builtin.str(\"pointer\"),c.MOVE=new Sk.builtin.str(\"move\"),c.TEXT=new Sk.builtin.str(\"text\"),c.WAIT=new Sk.builtin.str(\"wait\"),c.NOCURSOR=Sk.builtin.assk$(\"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\"),c.DISABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(1),c.ENABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(-1),c.ENABLE_OPENGL_4X_SMOOTH=new Sk.builtin.int_(2),c.ENABLE_NATIVE_FONTS=new Sk.builtin.int_(3),c.DISABLE_DEPTH_TEST=new Sk.builtin.int_(4),c.ENABLE_DEPTH_TEST=new Sk.builtin.int_(-4),c.ENABLE_DEPTH_SORT=new Sk.builtin.int_(5),c.DISABLE_DEPTH_SORT=new Sk.builtin.int_(-5),c.DISABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(6),c.ENABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(-6),c.ENABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(7),c.DISABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(-7),c.HINT_COUNT=new Sk.builtin.int_(10),c.OPEN=new Sk.builtin.int_(1),c.CLOSE=new Sk.builtin.int_(2),c.BLUR=new Sk.builtin.int_(11),c.GRAY=new Sk.builtin.int_(12),c.INVERT=new Sk.builtin.int_(13),c.OPAQUE=new Sk.builtin.int_(14),c.POSTERIZE=new Sk.builtin.int_(15),c.THRESHOLD=new Sk.builtin.int_(16),c.ERODE=new Sk.builtin.int_(17),c.DILATE=new Sk.builtin.int_(18),c.BACKSPACE=new Sk.builtin.int_(8),c.TAB=new Sk.builtin.int_(9),c.ENTER=new Sk.builtin.int_(10),c.RETURN=new Sk.builtin.int_(13),c.ESC=new Sk.builtin.int_(27),c.DELETE=new Sk.builtin.int_(127),c.CODED=new Sk.builtin.int_(65535),c.SHIFT=new Sk.builtin.int_(16),c.CONTROL=new Sk.builtin.int_(17),c.ALT=new Sk.builtin.int_(18),c.CAPSLK=new Sk.builtin.int_(20),c.PGUP=new Sk.builtin.int_(33),c.PGDN=new Sk.builtin.int_(34),c.END=new Sk.builtin.int_(35),c.HOME=new Sk.builtin.int_(36),c.LEFT=new Sk.builtin.int_(37),c.UP=new Sk.builtin.int_(38),c.RIGHT=new Sk.builtin.int_(39),c.DOWN=new Sk.builtin.int_(40),c.F1=new Sk.builtin.int_(112),c.F2=new Sk.builtin.int_(113),c.F3=new Sk.builtin.int_(114),c.F4=new Sk.builtin.int_(115),c.F5=new Sk.builtin.int_(116),c.F6=new Sk.builtin.int_(117),c.F7=new Sk.builtin.int_(118),c.F8=new Sk.builtin.int_(119),c.F9=new Sk.builtin.int_(120),c.F10=new Sk.builtin.int_(121),c.F11=new Sk.builtin.int_(122),c.F12=new Sk.builtin.int_(123),c.NUMLK=new Sk.builtin.int_(144),c.META=new Sk.builtin.int_(157),c.INSERT=new Sk.builtin.int_(155),c.SINCOS_LENGTH=new Sk.builtin.int_(720),c.PRECISIONB=new Sk.builtin.int_(15),c.PRECISIONF=new Sk.builtin.int_(32768),c.PREC_MAXVAL=new Sk.builtin.int_(32767),c.PREC_ALPHA_SHIFT=new Sk.builtin.int_(9),c.PREC_RED_SHIFT=new Sk.builtin.int_(1),c.NORMAL_MODE_AUTO=new Sk.builtin.int_(0),c.NORMAL_MODE_SHAPE=new Sk.builtin.int_(1),c.NORMAL_MODE_VERTEX=new Sk.builtin.int_(2),c.MAX_LIGHTS=new Sk.builtin.int_(8),c.line=new Sk.builtin.func((function(n,i,e,t){c.processing.line(n.v,i.v,e.v,t.v)})),c.ellipse=new Sk.builtin.func((function(n,i,e,t){c.processing.ellipse(n.v,i.v,e.v,t.v)})),c.circle=new Sk.builtin.func((function(n,i,e){c.processing.ellipse(n.v,i.v,e.v,e.v)})),c.text=new Sk.builtin.func((function(n,i,e){c.processing.text(n.v,i.v,e.v)})),c.point=new Sk.builtin.func((function(n,i){c.processing.point(n.v,i.v)})),c.arc=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.arc(n.v,i.v,e.v,t.v,u.v,o.v)})),c.quad=new Sk.builtin.func((function(n,i,e,t,u,o,s,l){c.processing.quad(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v)})),c.rect=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof u?c.processing.rect(n.v,i.v,e.v,t.v):c.processing.rect(n.v,i.v,e.v,t.v,u.v)})),c.triangle=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.triangle(n.v,i.v,e.v,t.v,u.v,o.v)})),c.bezier=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r,v,f,S){\"undefined\"==typeof r?c.processing.bezier(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):c.processing.bezier(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v,f.v,S.v)})),c.alpha=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.alpha(n.v)):\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.alpha(n.v,i.v)):new Sk.builtin.float_(c.processing.alpha(n.v,i.v,e.v))})),c.ambient=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof i?c.processing.ambient(n.v):\"undefined\"==typeof e?c.processing.ambient(n.v,i.v):c.processing.ambient(n.v,i.v,e.v)})),c.ambientLight=new Sk.builtin.func((function(n,i,e,t,u,o){\"undefined\"==typeof t?c.processing.ambientLight(n.v,i.v,e.v):\"undefined\"==typeof u?c.processing.ambientLight(n.v,i.v,e.v,t.v):\"undefined\"==typeof o?c.processing.ambientLight(n.v,i.v,e.v,t.v,u.v):c.processing.ambientLight(n.v,i.v,e.v,t.v,u.v,o.v)})),c.beginCamera=new Sk.builtin.func((function(){c.processing.beginCamera()})),c.beginShape=new Sk.builtin.func((function(n){\"undefined\"==typeof n&&(n=c.POLYGON),c.processing.beginShape(n.v)})),c.bezierDetail=new Sk.builtin.func((function(n){n=\"undefined\"!=typeof n?n.v:20,c.processing.bezierDetail(n)})),c.bezierPoint=new Sk.builtin.func((function(n,i,e,t,u){c.processing.bezierPoint(n.v,i.v,e.v,t.v,u.v)})),c.bezierTangent=new Sk.builtin.func((function(n,i,e,t,u){c.processing.bezierTangent(n.v,i.v,e.v,t.v,u.v)})),c.bezierVertex=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r){\"undefined\"==typeof s?c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v):\"undefined\"==typeof l?c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v,s.v):\"undefined\"==typeof r?c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):c.processing.bezierVertex(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v)})),c.blend=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r,v){n instanceof Sk.builtin.int_||n instanceof Sk.builtin.float_?c.processing.blend(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v):c.processing.blend(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v)})),c.blendColor=new Sk.builtin.func((function(n,i,e){var t=Sk.misceval.callsimArray(c.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return t.v=c.processing.blendColor(n.v,i.v,e.v),t})),c.brightness=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.brightness(n.v)):\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.brightness(n.v,i.v)):new Sk.builtin.float_(c.processing.brightness(n.v,i.v,e.v))})),c.camera=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r){\"undefined\"==typeof n?c.processing.camera():c.processing.camera(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v)})),c.constrain=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.constrain(n.v,i.v,e.v))})),c.copy=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r){n instanceof Sk.builtin.int_||n instanceof Sk.builtin.float_?c.processing.copy(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):c.processing.copy(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v)})),c.createFont=new Sk.builtin.func((function(n,i,e,t){var u=Sk.misceval.callsimArray(c.PFont);return u.v=\"undefined\"==typeof e?c.processing.createFont(n.v,i.v):\"undefined\"==typeof t?c.processing.createFont(n.v,i.v,e.v):c.processing.createFont(n.v,i.v,e.v,t.v),u})),c.createGraphics=new Sk.builtin.func((function(n,i,e,t){var u=Sk.misceval.callsimArray(c.PGraphics);return u.v=\"undefined\"==typeof t?c.processing.createGraphics(n.v,i.v,e.v):c.processing.createGraphics(n.v,i.v,e.v,t.v),u})),c.createImage=new Sk.builtin.func((function(n,i,e){var t=Sk.misceval.callsimArray(c.PImage);return t.v=c.processing.createImage(n.v,i.v,e.v),t})),c.cursor=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof n?c.processing.cursor():\"undefined\"==typeof i?c.processing.cursor(n.v):\"undefined\"==typeof e?c.processing.cursor(n.v,i.v):c.processing.cursor(n.v,i.v,e.v)})),c.curve=new Sk.builtin.func((function(n,i,e,t,u,o,s,l,r,v,f,S){\"undefined\"==typeof r?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v):\"undefined\"==typeof v?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v):\"undefined\"==typeof f?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v):\"undefined\"==typeof S?c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v,f.v):c.processing.curve(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v,r.v,v.v,f.v,S.v)})),c.curveDetail=new Sk.builtin.func((function(n){c.processing.curveDetail(n.v)})),c.curvePoint=new Sk.builtin.func((function(n,i,e,t,u){c.processing.curvePoint(n.v,i.v,e.v,t.v,u.v)})),c.curveTangent=new Sk.builtin.func((function(n,i,e,t,u){c.processing.curveTangent(n.v,i.v,e.v,t.v,u.v)})),c.curveTightness=new Sk.builtin.func((function(n){c.processing.curveTightness(n.v)})),c.curveVertex=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof e?c.processing.curveVertex(n.v,i.v):c.processing.curveVertex(n.v,i.v,e.v)})),c.day=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.day())})),c.degrees=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.degrees(n.v))})),c.directionalLight=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.directionalLight(n.v,i.v,e.v,t.v,u.v,o.v)})),c.dist=new Sk.builtin.func((function(n,i,e,t,u,o){return\"undefined\"==typeof u?new Sk.builtin.float_(c.processing.dist(n.v,i.v,e.v,t.v)):\"undefined\"==typeof o?new Sk.builtin.float_(c.processing.dist(n.v,i.v,e.v,t.v,u.v)):new Sk.builtin.float_(c.processing.dist(n.v,i.v,e.v,t.v,u.v,o.v))})),c.emissive=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof i?c.processing.emissive(n.v):\"undefined\"==typeof e?c.processing.emissive(n.v,i.v):c.processing.emissive(n.v,i.v,e.v)})),c.endCamera=new Sk.builtin.func((function(){c.processing.endCamera()})),c.endShape=new Sk.builtin.func((function(n){\"undefined\"==typeof n?c.processing.endShape():c.processing.endShape(n.v)})),c.filter=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.filter(n.v):c.processing.filter(n.v,i.v)})),c.frustum=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.frustum(n,i,e,t,u,o)})),c.hint=new Sk.builtin.func((function(n){c.processing.hint(n)})),c.hour=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.hour())})),c.hue=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.hue(n.v))})),c.imageMode=new Sk.builtin.func((function(n){c.processing.imageMode(n.v)})),c.lerp=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.lerp(n.v,i.v,e.v))})),c.lerpColor=new Sk.builtin.func((function(n,i,e){var t=Sk.misceval.callsimArray(c.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return t.v=c.processing.lerpColor(n.v,i.v,e.v),t})),c.lightFalloff=new Sk.builtin.func((function(n,i,e){c.processing.lightFalloff(n.v,i.v,e.v)})),c.lights=new Sk.builtin.func((function(){c.processing.lights()})),c.lightSpecular=new Sk.builtin.func((function(n,i,e){c.processing.lightSpecular(n.v,i.v,e.v)})),c.loadBytes=new Sk.builtin.func((function(n){return new Sk.builtin.list(c.processing.loadBytes(n.v))})),c.loadFont=new Sk.builtin.func((function(n){var i=Sk.misceval.callsimArray(c.PFont);return i.v=c.processing.loadFont(n.v),i})),c.loadShape=new Sk.builtin.func((function(n){return Sk.misceval.callsimArray(c.PShapeSVG,[new Sk.builtin.str(\"string\"),n])})),c.loadStrings=new Sk.builtin.func((function(n){return new Sk.builtin.list(c.processing.loadStrings(n.v))})),c.mag=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.mag(n.v,i.v)):new Sk.builtin.float_(c.processing.mag(n.v,i.v,e.v))})),c.map=new Sk.builtin.func((function(n,i,e,t,u){return new Sk.builtin.float_(c.processing.map(n.v,i.v,e.v,t.v,u.v))})),c.millis=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.millis())})),c.minute=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.minute())})),c.modelX=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.modelX(n.v,i.v,e.v))})),c.modelY=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.modelY(n.v,i.v,e.v))})),c.modelZ=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.modelZ(n.v,i.v,e.v))})),c.month=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.month())})),c.noCursor=new Sk.builtin.func((function(){c.processing.noCursor()})),c.noise=new Sk.builtin.func((function(n,i,e){return\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.noise(n.v)):\"undefined\"==typeof e?new Sk.builtin.float_(c.processing.noise(n.v,i.v)):new Sk.builtin.float_(c.processing.noise(n.v,i.v,e.v))})),c.noiseDetail=new Sk.builtin.func((function(n,i){c.processing.noiseDetail(n.v,i.v)})),c.noiseSeed=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.noiseSeed(n.v))})),c.noLights=new Sk.builtin.func((function(){c.processing.noLights()})),c.norm=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.norm(n.v,i.v,e.v))})),c.normal=new Sk.builtin.func((function(n,i,e){c.processing.normal(n.v,i.v,e.v)})),c.noTint=new Sk.builtin.func((function(){c.processing.noTint()})),c.ortho=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.ortho(n.v,i.v,e.v,t.v,u.v,o.v)})),c.perspective=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof n?c.processing.perspective():\"undefined\"==typeof i?c.processing.perspective(n.v):\"undefined\"==typeof e?c.processing.perspective(n.v,i.v):\"undefined\"==typeof t?c.processing.perspective(n.v,i.v,e.v):c.processing.perspective(n.v,i.v,e.v,t.v)})),c.pointLight=new Sk.builtin.func((function(n,i,e,t,u,o){c.processing.pointLight(n.v,i.v,e.v,t.v,u.v,o.v)})),c.printCamera=new Sk.builtin.func((function(){c.processing.printCamera()})),c.println=new Sk.builtin.func((function(n){c.processing.println(n.v)})),c.printProjection=new Sk.builtin.func((function(){c.processing.printProjection()})),c.radians=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.radians(n.v))})),c.randomSeed=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.randomSeed(n.v))})),c.random=new Sk.builtin.func((function(n,i){return\"undefined\"==typeof n?new Sk.builtin.float_(c.processing.random()):\"undefined\"==typeof i?new Sk.builtin.float_(c.processing.random(n.v)):new Sk.builtin.float_(c.processing.random(n.v,i.v))})),c.requestImage=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PImage);return e.v=\"undefined\"==typeof i?c.processing.requestImage(n.v):c.processing.requestImage(n.v,i.v),e})),c.saturation=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.saturation(n.v))})),c.save=new Sk.builtin.func((function(n){c.processing.save(n.v)})),c.saveFrame=new Sk.builtin.func((function(n){\"undefined\"==typeof n?c.processing.saveFrame():c.processing.saveFrame(n.v)})),c.saveStrings=new Sk.builtin.func((function(n,i){c.processing.saveStrings(n.v,i.v)})),c.screenX=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.screenX(n.v,i.v,e.v))})),c.screenY=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.screenY(n.v,i.v,e.v))})),c.screenZ=new Sk.builtin.func((function(n,i,e){return new Sk.builtin.float_(c.processing.screenZ(n.v,i.v,e.v))})),c.second=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.second())})),c.shape=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof i?c.processing.shape(n.v):\"undefined\"==typeof e?c.processing.shape(n.v,i.v):\"undefined\"==typeof t?c.processing.shape(n.v,i.v,e.v):\"undefined\"==typeof u?c.processing.shape(n.v,i.v,e.v,t.v):c.processing.shape(n.v,i.v,e.v,t.v,u.v)})),c.shapeMode=new Sk.builtin.func((function(n){c.processing.shapeMode(n.v)})),c.shininess=new Sk.builtin.func((function(n){c.processing.shininess(n.v)})),c.specular=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof i?c.processing.specular(n.v):\"undefined\"==typeof e?c.processing.specular(n.v,i.v):c.processing.specular(n.v,i.v,e.v)})),c.spotLight=new Sk.builtin.func((function(n,i,e,t,u,o,s,l){c.processing.spotLight(n.v,i.v,e.v,t.v,u.v,o.v,s.v,l.v)})),c.sq=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.sq(n))})),c.status=new Sk.builtin.func((function(n){c.processing.status(n.v)})),c.textAlign=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.textAlign(n.v):c.processing.textAlign(n.v,i.v)})),c.textAscent=new Sk.builtin.func((function(){return new Sk.builtin.float_(c.processing.textAscent())})),c.textDescent=new Sk.builtin.func((function(){return new Sk.builtin.float_(c.processing.textDescent())})),c.textFont=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.textFont(n.v):c.processing.textFont(n.v,i.v)})),c.textLeading=new Sk.builtin.func((function(n){c.processing.textLeading(n.v)})),c.textMode=new Sk.builtin.func((function(n){c.processing.textMode(n.v)})),c.textSize=new Sk.builtin.func((function(n){c.processing.textSize(n.v)})),c.texture=new Sk.builtin.func((function(n){c.processing.texture(n.v)})),c.textureMode=new Sk.builtin.func((function(n){c.processing.textureMode(n.v)})),c.textWidth=new Sk.builtin.func((function(n){return new Sk.builtin.float_(c.processing.textWidth(n.v))})),c.tint=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof i?c.processing.tint(n.v):\"undefined\"==typeof e?c.processing.tint(n.v,i.v):\"undefined\"==typeof t?c.processing.tint(n.v,i.v,e.v):c.processing.tint(n.v,i.v,e.v,t.v)})),c.updatePixels=new Sk.builtin.func((function(){c.processing.updatePixels()})),c.vertex=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof e?c.processing.vertex(n.v,i.v):\"undefined\"==typeof t?c.processing.vertex(n.v,i.v,e.v):\"undefined\"==typeof u?c.processing.vertex(n.v,i.v,e.v,t.v):c.processing.vertex(n.v,i.v,e.v,t.v,u.v)})),c.year=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.year())})),c.box=new Sk.builtin.func((function(n){c.processing.box(n.v)})),c.sphere=new Sk.builtin.func((function(n){c.processing.sphere(n.v)})),c.sphereDetail=new Sk.builtin.func((function(n,i){\"undefined\"==typeof i?c.processing.sphereDetail(n.v):c.processing.sphereDetail(n.v,i.v)})),c.background=new Sk.builtin.func((function(n,i,e){\"undefined\"!=typeof i&&(i=i.v),\"undefined\"!=typeof e&&(e=e.v),c.processing.background(n.v,i,e)})),c.fill=new Sk.builtin.func((function(n,i,e,t){\"undefined\"!=typeof i&&(i=i.v),\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),c.processing.fill(n.v,i,e,t)})),c.stroke=new Sk.builtin.func((function(n,i,e,t){\"undefined\"!=typeof i&&(i=i.v),\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),c.processing.stroke(n.v,i,e,t)})),c.noStroke=new Sk.builtin.func((function(){c.processing.noStroke()})),c.colorMode=new Sk.builtin.func((function(n,i,e,t,u){i=\"undefined\"==typeof i?255:i.v,\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),\"undefined\"!=typeof u&&(u=u.v),c.processing.colorMode(n.v,i,e,t,u)})),c.noFill=new Sk.builtin.func((function(){c.processing.noFill()})),c.loop=new Sk.builtin.func((function(){if(null===c.processing)throw new Sk.builtin.Exception(\"loop() should be called after run()\");v=!0,c.processing.loop()})),c.noLoop=new Sk.builtin.func((function(){if(null===c.processing)throw new Sk.builtin.Exception(\"noLoop() should be called after run()\");v=!1,c.processing.noLoop()})),c.frameRate=new Sk.builtin.func((function(n){c.processing.frameRate(n.v)})),c.width=new Sk.builtin.int_(0),c.height=new Sk.builtin.int_(0),c.renderMode=c.P2D,c.size=new Sk.builtin.func((function(n,i,e){\"undefined\"==typeof e&&(e=c.P2D),c.processing.size(n.v,i.v,e.v),c.width=new Sk.builtin.int_(c.processing.width),c.height=new Sk.builtin.int_(c.processing.height),c.renderMode=e})),c.exitp=new Sk.builtin.func((function(){c.processing.exit()})),c.mouseX=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.mouseX)})),c.mouseY=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.mouseY)})),c.pmouseX=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.pmouseX)})),c.pmouseY=new Sk.builtin.func((function(){return new Sk.builtin.int_(c.processing.pmouseY)})),c.rectMode=new Sk.builtin.func((function(n){c.processing.rectMode(n.v)})),c.strokeWeight=new Sk.builtin.func((function(n){c.processing.strokeWeight(n.v)})),c.smooth=new Sk.builtin.func((function(){c.processing.smooth()})),c.noSmooth=new Sk.builtin.func((function(){c.processing.noSmooth()})),c.ellipseMode=new Sk.builtin.func((function(n){c.processing.ellipseMode(n.v)})),c.strokeCap=new Sk.builtin.func((function(n){c.processing.strokeCap(n.v)})),c.strokeJoin=new Sk.builtin.func((function(n){c.processing.strokeJoin(n.v)})),c.rotate=new Sk.builtin.func((function(n){c.processing.rotate(n.v)})),c.rotateX=new Sk.builtin.func((function(n){c.processing.rotateX(n.v)})),c.rotateY=new Sk.builtin.func((function(n){c.processing.rotateY(n.v)})),c.rotateZ=new Sk.builtin.func((function(n){c.processing.rotateZ(n.v)})),c.scale=new Sk.builtin.func((function(n,i,e){i=\"undefined\"==typeof i?1:i.v,e=\"undefined\"==typeof e?1:e.v,c.processing.scale(n.v,i,e)})),c.translate=new Sk.builtin.func((function(n,i,e){i=\"undefined\"==typeof i?1:i.v,e=\"undefined\"==typeof e?1:e.v,c.processing.translate(n.v,i,e)})),c.popMatrix=new Sk.builtin.func((function(){c.processing.popMatrix()})),c.pushMatrix=new Sk.builtin.func((function(){c.processing.pushMatrix()})),c.applyMatrix=new Sk.builtin.func((function(){var n,i=Array.prototype.slice.call(arguments,0,16);for(n=0;n<i.length;n++)i[n]=\"undefined\"==typeof i[n]?0:i[n].v;c.processing.applyMatrix.apply(c.processing,i)})),c.resetMatrix=new Sk.builtin.func((function(){c.processing.resetMatrix()})),c.printMatrix=new Sk.builtin.func((function(){return Sk.ffi.remapToPy(c.processing.printMatrix())})),c.run=new Sk.builtin.func((function(){var n=document.getElementById(Sk.canvas);if(!n)throw new Error(\"Processing module: Canvas element not specified\");if(window.Processing.logger={log:function(n){Sk.misceval.print_(n)}},(f=window.Processing.getInstanceById(Sk.canvas))&&f.exit(),c.p=new window.Processing(n,(function sketchProc(n){c.processing=n,n.draw=function(){var i=!1;for(var e in r)0===r[e].width&&(i=!0);if(!0===i)return!0===v?void 0:void n.loop();if(!1===v&&n.noLoop(),c.frameCount=n.frameCount,Sk.globals.draw)try{Sk.misceval.callsimArray(Sk.globals.draw)}catch(t){Sk.uncaughtException(t)}};var i=[\"setup\",\"mouseMoved\",\"mouseClicked\",\"mouseDragged\",\"mouseMoved\",\"mouseOut\",\"mouseOver\",\"mousePressed\",\"mouseReleased\",\"keyPressed\",\"keyReleased\",\"keyTyped\"];for(var e in i)Sk.globals[i[e]]&&(n[i[e]]=new Function(\"try {Sk.misceval.callsimArray(Sk.globals['\"+i[e]+\"']);} catch(e) {Sk.uncaughtException(e);}\"))})),0===c.width.v&&0===c.height.v){var i=n.offsetWidth,e=n.offsetHeight;Sk.misceval.callsimArray(c.size,[new Sk.builtin.int_(i),new Sk.builtin.int_(e),c.renderMode])}})),s=function(n,i){i.__getattr__=new Sk.builtin.func((function(n,i){return\"x\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(c.processing.mouseX):\"y\"===i?Sk.builtin.assk$(c.processing.mouseY):\"px\"===i?Sk.builtin.assk$(c.processing.pmouseX):\"py\"===i?Sk.builtin.assk$(c.processing.pmouseY):\"pressed\"===i?new Sk.builtin.bool(c.processing.__mousePressed):\"button\"===i?Sk.builtin.assk$(c.processing.mouseButton):void 0}))},c.Mouse=Sk.misceval.buildClass(c,s,\"Mouse\",[]),c.mouse=Sk.misceval.callsimArray(c.Mouse),o=function(n,i){i.__getattr__=new Sk.builtin.func((function(n,i){return\"key\"===(i=Sk.ffi.remapToJs(i))?new Sk.builtin.str(c.processing.key.toString()):\"keyCode\"===i?Sk.builtin.assk$(c.processing.keyCode):\"keyPressed\"===i?new Sk.builtin.str(c.processing.keyPressed):void 0}))},c.Keyboard=Sk.misceval.buildClass(c,o,\"Keyboard\",[]),c.keyboard=Sk.misceval.callsimArray(c.Keyboard),u=function(n,i){i.__getattr__=new Sk.builtin.func((function(n,i){return\"frameCount\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(c.processing.frameCount):\"frameRate\"===i?Sk.builtin.assk$(c.processing.frameRate):\"height\"===i?Sk.builtin.assk$(c.processing.height):\"width\"===i?Sk.builtin.assk$(c.processing.width):\"online\"===i?new Sk.builtin.bool(c.processing.online):\"focused\"===i?new Sk.builtin.bool(c.processing.focused):void 0}))},c.Environment=Sk.misceval.buildClass(c,u,\"Environment\",[]),c.environment=Sk.misceval.callsimArray(c.Environment),t=function(n,i){i.__init__=new Sk.builtin.func((function(n){n.pixels=null})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"height\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(c.processing.height):\"width\"===i?Sk.builtin.assk$(c.processing.width):(\"pixels\"===i&&null==n.pixels&&(n.pixels=new Sk.builtin.list(c.processing.pixels.toArray())),n.pixels)}))},c.Screen=Sk.misceval.buildClass(c,t,\"Screen\",[]),c.screen=Sk.misceval.callsimArray(c.Screen),c.loadPixels=new Sk.builtin.func((function(){c.processing.loadPixels()})),e=function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"!=typeof e&&(e=e.v),\"undefined\"!=typeof t&&(t=t.v),\"undefined\"!=typeof u&&(u=u.v),n.v=c.processing.color(i.v,e,t,u)}))},c.color=Sk.misceval.buildClass(c,e,\"color\",[]),c.red=new Sk.builtin.func((function(n){return new Sk.builtin.int_(c.processing.red(n.v))})),c.green=new Sk.builtin.func((function(n){return new Sk.builtin.int_(c.processing.green(n.v))})),c.blue=new Sk.builtin.func((function(n){return new Sk.builtin.int_(c.processing.blue(n.v))})),i=function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?new c.processing.PImage:\"undefined\"==typeof e?new c.processing.PImage(i.v):\"undefined\"==typeof t?new c.processing.PImage(i.v,e.v):new c.processing.PImage(i.v,e.v,t.v)})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"width\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(n.v.width):\"height\"===i?Sk.builtin.assk$(n.v.height):void 0}))},c.loadImage=new Sk.builtin.func((function(n){var i=c.processing.loadImage(n.v);r.push(i);var e=Sk.misceval.callsimArray(c.PImage);return e.v=i,e})),c.image=new Sk.builtin.func((function(n,i,e,t,u){\"undefined\"==typeof t?c.processing.image(n.v,i.v,e.v):c.processing.image(n.v,i.v,e.v,t.v,u.v)})),c.get=new Sk.builtin.func((function(n,i){var e=c.processing.get(n.v,i.v);return Sk.misceval.callsimArray(c.color,[new Sk.builtin.int_(c.processing.red(e)),new Sk.builtin.int_(c.processing.green(e)),new Sk.builtin.int_(c.processing.blue(e))])})),c.set=new Sk.builtin.func((function(n,i,e){c.processing.set(n.v,i.v,e.v)})),l=function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?new c.processing.PVector:\"undefined\"==typeof t?new c.processing.PVector(i.v,e.v):new c.processing.PVector(i.v,e.v,t.v)})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"x\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(n.v.x):\"y\"===i?Sk.builtin.assk$(n.v.y):\"z\"===i?Sk.builtin.assk$(n.v.z):void 0})),i.get=new Sk.builtin.func((function(n){var i=Sk.misceval.callsimArray(c.PVector);return i.v=n.v.get(),i})),i.set=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof t?n.v.set(i.v,e.v):n.v.set(i.v,e.v,t.v)})),i.mag=new Sk.builtin.func((function(n){return Sk.builtin.assk$(n.v.mag())})),i.add=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.add(i.v),e})),i.sub=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.sub(i.v),e})),i.mult=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.mult(i.v),e})),i.div=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.div(i.v),e})),i.dist=new Sk.builtin.func((function(n,i){return Sk.builtin.assk$(n.v.dist(i.v))})),i.dot=new Sk.builtin.func((function(n,i,e,t){return\"undefined\"==typeof e?Sk.builtin.assk$(n.v.dot(i.v)):Sk.builtin.assk$(n.v.dot(i.v,e.v,t.v))})),i.cross=new Sk.builtin.func((function(n,i){var e=Sk.misceval.callsimArray(c.PVector);return e.v=n.v.cross(i.v),e})),i.normalize=new Sk.builtin.func((function(n){n.v.normalize()})),i.limit=new Sk.builtin.func((function(n,i){n.v.limit(i.v)})),i.angleBetween=new Sk.builtin.func((function(n,i){return Sk.builtin.assk$(n.v.angleBetween(i.v))})),i.array=new Sk.builtin.func((function(n){return new Sk.builtin.list(n.v.array())}))};return c.PFont=Sk.misceval.buildClass(c,(function(n,i){i.__init__=new Sk.builtin.func((function(n,i){n.v=\"undefined\"==typeof i?new c.processing.PFont:new c.processing.PVector(i.v)})),i.list=new Sk.builtin.func((function(n){return new Sk.builtin.list(n.v.list())}))}),\"PFont\",[]),c.PGraphics=Sk.misceval.buildClass(c,(function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?new c.processing.PVector:\"undefined\"==typeof t?new c.processing.PVector(i.v,e.v):new c.processing.PVector(i.v,e.v,t.v)})),i.beginDraw=new Sk.builtin.func((function(n){n.v.beginDraw()})),i.endDraw=new Sk.builtin.func((function(n){n.v.endDraw()}))}),\"PGraphics\",[]),c.PShapeSVG=Sk.misceval.buildClass(c,(function(n,i){i.__init__=new Sk.builtin.func((function(n,i,e,t){n.v=\"undefined\"==typeof i?null:\"undefined\"==typeof e?new c.processing.PShapeSVG(i.v):\"undefined\"==typeof t?new c.processing.PShapeSVG(i.v,e.v):new c.processing.PShapeSVG(i.v,e.v,t.v)})),i.__getattr__=new Sk.builtin.func((function(n,i){return\"width\"===(i=Sk.ffi.remapToJs(i))?Sk.builtin.assk$(n.v.width):\"height\"===i?Sk.builtin.assk$(n.v.height):void 0})),i.isVisible=new Sk.builtin.func((function(n){return new Sk.builtin.bool(n.v.isVisible())})),i.setVisible=new Sk.builtin.func((function(n,i){n.v.setVisible(i.v)})),i.disableStyle=new Sk.builtin.func((function(n){n.v.disableStyle()})),i.enableStyle=new Sk.builtin.func((function(n){n.v.enableStyle()})),i.getChild=new Sk.builtin.func((function(n,i){var e=n.v.getChild(i.v);if(null!=e){var t=Sk.misceval.callsimArray(c.PShapeSVG);return t.v=e,t}return null})),i.translate=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof t?n.v.translate(i.v,e.v):n.v.translate(i.v,e.v,t.v)})),i.rotate=new Sk.builtin.func((function(n,i){n.v.rotate(i.v)})),i.rotateX=new Sk.builtin.func((function(n,i){n.v.rotateX(i.v)})),i.rotateY=new Sk.builtin.func((function(n,i){n.v.rotateY(i.v)})),i.rotateZ=new Sk.builtin.func((function(n,i){n.v.rotateZ(i.v)})),i.scale=new Sk.builtin.func((function(n,i,e,t){\"undefined\"==typeof e?n.v.scale(i.v):\"undefined\"==typeof t?n.v.scale(i.v,e.v):n.v.scale(i.v,e.v,t.v)}))}),\"PShapeSVG\",[]),c.PVector=Sk.misceval.buildClass(c,l,\"PVector\",[]),c.PImage=Sk.misceval.buildClass(c,i,\"PImage\",[]),c};","src/lib/random.js":"var MersenneTwister=function(n){null==n&&(n=(new Date).getTime()),this.N=624,this.M=397,this.MATRIX_A=2567483615,this.UPPER_MASK=2147483648,this.LOWER_MASK=2147483647,this.mt=new Array(this.N),this.mti=this.N+1,this.init_genrand(n)};MersenneTwister.prototype.init_genrand=function(n){for(this.mt[0]=n>>>0,this.mti=1;this.mti<this.N;this.mti++)n=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30,this.mt[this.mti]=(1812433253*((4294901760&n)>>>16)<<16)+1812433253*(65535&n)+this.mti,this.mt[this.mti]>>>=0},MersenneTwister.prototype.init_by_array=function(n,t){var i,e,r;for(this.init_genrand(19650218),i=1,e=0,r=this.N>t?this.N:t;r;r--){var u=this.mt[i-1]^this.mt[i-1]>>>30;this.mt[i]=(this.mt[i]^(1664525*((4294901760&u)>>>16)<<16)+1664525*(65535&u))+n[e]+e,this.mt[i]>>>=0,e++,++i>=this.N&&(this.mt[0]=this.mt[this.N-1],i=1),e>=t&&(e=0)}for(r=this.N-1;r;r--){u=this.mt[i-1]^this.mt[i-1]>>>30;this.mt[i]=(this.mt[i]^(1566083941*((4294901760&u)>>>16)<<16)+1566083941*(65535&u))-i,this.mt[i]>>>=0,++i>=this.N&&(this.mt[0]=this.mt[this.N-1],i=1)}this.mt[0]=2147483648},MersenneTwister.prototype.genrand_int32=function(){var n,t=new Array(0,this.MATRIX_A);if(this.mti>=this.N){var i;for(this.mti==this.N+1&&this.init_genrand(5489),i=0;i<this.N-this.M;i++)n=this.mt[i]&this.UPPER_MASK|this.mt[i+1]&this.LOWER_MASK,this.mt[i]=this.mt[i+this.M]^n>>>1^t[1&n];for(;i<this.N-1;i++)n=this.mt[i]&this.UPPER_MASK|this.mt[i+1]&this.LOWER_MASK,this.mt[i]=this.mt[i+(this.M-this.N)]^n>>>1^t[1&n];n=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK,this.mt[this.N-1]=this.mt[this.M-1]^n>>>1^t[1&n],this.mti=0}return n=this.mt[this.mti++],n^=n>>>11,n^=n<<7&2636928640,n^=n<<15&4022730752,(n^=n>>>18)>>>0},MersenneTwister.prototype.genrand_int31=function(){return this.genrand_int32()>>>1},MersenneTwister.prototype.genrand_real1=function(){return this.genrand_int32()*(1/4294967295)},MersenneTwister.prototype.random=function(){return this.genrand_int32()*(1/4294967296)},MersenneTwister.prototype.genrand_real3=function(){return(this.genrand_int32()+.5)*(1/4294967296)},MersenneTwister.prototype.genrand_res53=function(){return(67108864*(this.genrand_int32()>>>5)+(this.genrand_int32()>>>6))*(1/9007199254740992)};var $builtinmodule=function(n){var t={},i=new MersenneTwister,e=void 0;t.seed=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"seed\",arguments.length,0,1),n=Sk.builtin.asnum$(n),i=arguments.length>0?new MersenneTwister(n):new MersenneTwister,Sk.builtin.none.none$})),t.random=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"random\",arguments.length,0,0),new Sk.builtin.float_(i.genrand_res53())}));var toInt=function(n){return 0|n},randrange=function(n,t,e){var r,u,s;if(!Sk.builtin.checkInt(n))throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");if(void 0===t)return s=toInt(i.genrand_res53()*n),new Sk.builtin.int_(s);if(!Sk.builtin.checkInt(t))throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");if(void 0===e&&(e=1),r=t-n,1==e&&r>0)return s=n+toInt(i.genrand_res53()*r),new Sk.builtin.int_(s);if(1==e)throw new Sk.builtin.ValueError(\"empty range for randrange() (\"+n+\", \"+t+\", \"+r+\")\");if(!Sk.builtin.checkInt(e))throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");if(e>0)u=toInt((r+e-1)/e);else{if(!(e<0))throw new Sk.builtin.ValueError(\"zero step for randrange()\");u=toInt((r+e+1)/e)}if(u<=0)throw new Sk.builtin.ValueError(\"empty range for randrange()\");return s=n+e*toInt(i.genrand_res53()*u),new Sk.builtin.int_(s)};t.randint=new Sk.builtin.func((function(n,t){return Sk.builtin.pyCheckArgsLen(\"randint\",arguments.length,2,2),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),randrange(n,t+1)})),t.randrange=new Sk.builtin.func((function(n,t,i){return Sk.builtin.pyCheckArgsLen(\"randrange\",arguments.length,1,3),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),i=Sk.builtin.asnum$(i),randrange(n,t,i)})),t.uniform=new Sk.builtin.func((function(n,t){Sk.builtin.pyCheckArgsLen(\"uniform\",arguments.length,2,2),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t);const e=n+i.genrand_res53()*(t-n);return new Sk.builtin.float_(e)})),t.triangular=new Sk.builtin.func((function(n,t,e){var r,u,s;return Sk.builtin.pyCheckArgsLen(\"triangular\",arguments.length,2,3),Sk.builtin.pyCheckType(\"low\",\"number\",Sk.builtin.checkNumber(n)),Sk.builtin.pyCheckType(\"high\",\"number\",Sk.builtin.checkNumber(t)),(n=Sk.builtin.asnum$(n))>(t=Sk.builtin.asnum$(t))&&(s=n,n=t,t=s),void 0===e||e===Sk.builtin.none.none$?e=(t-n)/2:(Sk.builtin.pyCheckType(\"mode\",\"number\",Sk.builtin.checkNumber(e)),e=Sk.builtin.asnum$(e)),u=(r=i.genrand_res53())<(e-n)/(t-n)?n+Math.sqrt(r*(t-n)*(e-n)):t-Math.sqrt((1-r)*(t-n)*(t-e)),new Sk.builtin.float_(u)}));var normalSample=function(n,t){var r,u,s,h,l;return void 0!==e?(l=e,e=void 0):(r=i.genrand_res53(),u=i.genrand_res53(),s=Math.sqrt(-2*Math.log(r)),h=2*Math.PI*u,l=s*Math.cos(h),e=s*Math.sin(h)),n+t*l};return t.gauss=new Sk.builtin.func((function(n,t){return Sk.builtin.pyCheckArgsLen(\"gauss\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(n)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(t)),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),new Sk.builtin.float_(normalSample(n,t))})),t.normalvariate=t.gauss,t.lognormvariate=new Sk.builtin.func((function(n,t){return Sk.builtin.pyCheckArgsLen(\"lognormvariate\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(n)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(t)),n=Sk.builtin.asnum$(n),t=Sk.builtin.asnum$(t),new Sk.builtin.float_(Math.exp(normalSample(n,t)))})),t.expovariate=new Sk.builtin.func((function(n){Sk.builtin.pyCheckArgsLen(\"expovariate\",arguments.length,1,1),Sk.builtin.pyCheckType(\"lambd\",\"number\",Sk.builtin.checkNumber(n)),n=Sk.builtin.asnum$(n);var t=i.genrand_res53();return new Sk.builtin.float_(-Math.log(t)/n)})),t.choice=new Sk.builtin.func((function(n){if(Sk.builtin.pyCheckArgsLen(\"choice\",arguments.length,1,1),Sk.builtin.pyCheckType(\"seq\",\"sequence\",Sk.builtin.checkSequence(n)),void 0!==n.sq$length){var t=new Sk.builtin.int_(toInt(i.genrand_res53()*n.sq$length()));return n.mp$subscript(t)}throw new Sk.builtin.TypeError(\"object has no length\")})),t.shuffle=new Sk.builtin.func((function(n){if(Sk.builtin.pyCheckArgsLen(\"shuffle\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"sequence\",Sk.builtin.checkSequence(n)),n.constructor===Sk.builtin.list){const u=n.v;for(var t=u.length-1;t>0;t-=1){var e=u[r=toInt(i.genrand_res53()*(t+1))];u[r]=u[t],u[t]=e}}else{if(void 0===n.sq$length)throw new Sk.builtin.TypeError(\"object has no length\");if(void 0===n.mp$ass_subscript)throw new Sk.builtin.TypeError(\"object is immutable\");for(t=n.sq$length()-1;t>0;t-=1){var r=new Sk.builtin.int_(toInt(i.genrand_res53()*(t+1)));t=new Sk.builtin.int_(t);e=n.mp$subscript(r);n.mp$ass_subscript(r,n.mp$subscript(t)),n.mp$ass_subscript(t,e)}}return Sk.builtin.none.none$})),t.sample=new Sk.builtin.func((function(n,t){var e,r,u,s,h;for(Sk.builtin.pyCheckArgsLen(\"sample\",arguments.length,2,2),Sk.builtin.pyCheckType(\"population\",\"iterable\",Sk.builtin.checkIterable(n)),Sk.builtin.pyCheckType(\"k\",\"integer\",Sk.builtin.checkInt(t)),t=Sk.builtin.asnum$(t),h=[],e=0,s=(u=Sk.abstr.iter(n)).tp$iternext();void 0!==s;e++,s=u.tp$iternext())r=Math.floor(i.genrand_res53()*(e+1)),e<t?(r<e&&(h[e]=h[r]),h[r]=s):r<t&&(h[r]=s);if(e<t)throw new Sk.builtin.ValueError(\"sample larger than population\");return new Sk.builtin.list(h)})),t};","src/lib/re.js":"function $builtinmodule(name){const{builtin:{dict:pyDict,str:pyStr,list:pyList,int_:pyInt,type:pyType,tuple:pyTuple,mappingproxy:pyMappingProxy,slice:pySlice,none:{none$:pyNone},NotImplemented:{NotImplemented$:pyNotImplemented},Exception:Exception,OverflowError:OverflowError,IndexError:IndexError,TypeError:TypeError,ValueError:ValueError,checkInt:checkInt,checkString:checkString,checkCallable:checkCallable,hex:hex},abstr:{buildNativeClass:buildNativeClass,typeName:typeName,checkOneArg:checkOneArg,numberBinOp:numberBinOp,copyKeywordToNamedArgs:copyKeywordToNamedArgs,setUpModuleMethods:setUpModuleMethods},misceval:{iterator:pyIterator,objectRepr:objectRepr,asIndexSized:asIndexSized,isIndex:isIndex,callsimArray:pyCall}}=Sk,re={__name__:new pyStr(\"re\"),__all__:new pyList([\"match\",\"fullmatch\",\"search\",\"sub\",\"subn\",\"split\",\"findall\",\"finditer\",\"compile\",\"purge\",\"template\",\"escape\",\"error\",\"Pattern\",\"Match\",\"A\",\"I\",\"L\",\"M\",\"S\",\"X\",\"U\",\"ASCII\",\"IGNORECASE\",\"LOCALE\",\"MULTILINE\",\"DOTALL\",\"VERBOSE\",\"UNICODE\"].map((e=>new pyStr(e))))},_value2member={},RegexFlagMeta=buildNativeClass(\"RegexFlagMeta\",{constructor:function RegexFlagMeta(){},base:pyType,slots:{tp$iter(){const e=Object.values(_members)[Symbol.iterator]();return new pyIterator((()=>e.next().value))},sq$contains(e){if(!(e instanceof this))throw new TypeError(\"unsupported operand type(s) for 'in': '\"+typeName(e)+\"' and '\"+typeName(this)+\"'\");return Object.values(_members).includes(e)}}});re.RegexFlag=buildNativeClass(\"RegexFlag\",{meta:RegexFlagMeta,base:pyInt,constructor:function RegexFlag(e){const t=_value2member[e];if(t)return t;this.v=e,_value2member[e]=this},slots:{tp$new(e,t){checkOneArg(\"RegexFlag\",e,t);const r=e[0].valueOf();if(!checkInt(r))throw new ValueError(objectRepr(r)+\" is not a valid RegexFlag\");return new re.RegexFlag(r)},$r(){let e=this.valueOf();const t=e<0;e=t?~e:e;const r=[];Object.entries(_members).forEach((([t,n])=>{const s=n.valueOf();e&s&&(e&=~s,r.push(\"re.\"+t))})),e&&r.push(hex(e).toString());let n=r.join(\"|\");return t&&(n=r.length>1?\"~(\"+n+\")\":\"~\"+n),new pyStr(n)},sq$contains(e){if(!(e instanceof re.RegexFlag))throw new TypeError(\"'in' requires a RegexFlag not \"+typeName(e));return this.nb$and(e)===e},nb$and:flagBitSlot(((e,t)=>e&t),JSBI.bitwiseAnd),nb$or:flagBitSlot(((e,t)=>e|t),JSBI.bitwiseOr),nb$xor:flagBitSlot(((e,t)=>e^t),JSBI.bitwiseXor),nb$invert:function(){const e=this.v;return\"number\"==typeof e?new re.RegexFlag(~e):new re.RegexFlag(JSBI.bitwiseNot(e))}},proto:{valueOf(){return this.v}},flags:{sk$acceptable_as_base_class:!1}}),re.TEMPLATE=re.T=new re.RegexFlag(1),re.IGNORECASE=re.I=new re.RegexFlag(2),re.LOCALE=re.L=new re.RegexFlag(4),re.MULTILINE=re.M=new re.RegexFlag(8),re.DOTALL=re.S=new re.RegexFlag(16),re.UNICODE=re.U=new re.RegexFlag(32),re.VERBOSE=re.X=new re.RegexFlag(64),re.DEBUG=new re.RegexFlag(128),re.ASCII=re.A=new re.RegexFlag(256);const _members={ASCII:re.A,IGNORECASE:re.I,LOCALE:re.L,UNICODE:re.U,MULTILINE:re.M,DOTALL:re.S,VERBOSE:re.X,TEMPLATE:re.T,DEBUG:re.DEBUG};function flagBitSlot(e,t){return function(r){if(r instanceof re.RegexFlag||r instanceof pyInt){let n=this.v,s=r.v;if(\"number\"==typeof n&&\"number\"==typeof s){let t=e(n,s);return t<0&&(t+=4294967296),new re.RegexFlag(t)}return n=JSBI.BigUp(n),s=JSBI.BigUp(s),new re.RegexFlag(JSBI.numberIfSafe(t(n,s)))}return pyNotImplemented}}const jsFlags={i:re.I,m:re.M,s:re.S,u:re.U},jsInlineFlags={i:re.I,a:re.A,s:re.S,L:re.L,m:re.M,u:re.U,x:re.X};RegExp.prototype.hasOwnProperty(\"sticky\")||delete jsFlags.s,RegExp.prototype.hasOwnProperty(\"unicode\")||delete jsFlags.u;const flagFails=Object.entries({\"cannot use LOCALE flag with a str pattern\":re.L,\"ASCII and UNICODE flags are incompatible\":new re.RegexFlag(re.A.valueOf()|re.U.valueOf())}),inline_regex=/\\(\\?([isamux]+)\\)/g;function adjustFlags(e,t){let r=e.toString(),n=\"g\",s=0;return r=r.replace(inline_regex,((e,t)=>{for(let r of t){const e=jsInlineFlags[r];s|=e.valueOf()}return\"\"})),flagFails.forEach((([e,t])=>{if((t.valueOf()&s)===t.valueOf())throw new re.error(\"bad bad inline flags: \"+e)})),t=numberBinOp(new re.RegexFlag(s),t,\"BitOr\"),flagFails.forEach((([e,r])=>{if(numberBinOp(r,t,\"BitAnd\")===r)throw new ValueError(e)})),numberBinOp(re.A,t,\"BitAnd\")!==re.A&&(t=numberBinOp(re.U,t,\"BitOr\")),Object.entries(jsFlags).forEach((([e,r])=>{numberBinOp(r,t,\"BitAnd\")===r&&(n+=e)})),t=new re.RegexFlag(t.valueOf()),[r,n,t]}let neg_lookbehind_A=\"(?<!\\\\\\\\n)\";(function checkLookBehindSupport(){try{eval(\"/(?<!foo)/\")}catch{neg_lookbehind_A=\"\"}})();const py_to_js_regex=/([^\\\\])({,|\\\\A|\\\\Z|\\$|\\(\\?P=([^\\d\\W]\\w*)\\)|\\(\\?P<([^\\d\\W]\\w*)>)(?![^\\[]*\\])/g,py_to_js_unicode_escape=/\\\\[\\t\\r\\n \\v\\f#&~\"'!]|\\\\-(?![^\\[]*\\])/g,quantifier_error=/Incomplete quantifier|Lone quantifier/g,_compiled_patterns=Object.create(null);function compile_pattern(e,t){let r,n;[r,n,t]=adjustFlags(e,t);const s=_compiled_patterns[e.toString()];if(s&&s.$flags===t)return s;const i={};let o,a;r=\"_\"+r,r=r.replace(py_to_js_regex,((t,r,n,s,o,a)=>{switch(n){case\"\\\\A\":return r+neg_lookbehind_A+\"^\";case\"\\\\Z\":return r+\"$(?!\\\\n)\";case\"{,\":return r+\"{0,\";case\"$\":return r+\"(?:(?=\\\\n$)|$)\";default:if(n.endsWith(\">\"))return i[o]=!0,r+\"(?<\"+o+\">\";if(!i[s])throw new re.error(\"unknown group name \"+s+\" at position \"+a+1,e,new pyInt(a+1));return r+\"\\\\k<\"+s+\">\"}})),r=r.slice(1);let l=r;n.includes(\"u\")&&(l=r.replace(py_to_js_unicode_escape,(e=>{switch(e){case\"\\\\ \":return\" \";case\"\\\\\\t\":return\"\\\\t\";case\"\\\\\\n\":return\"\\\\n\";case\"\\\\\\v\":return\"\\\\v\";case\"\\\\\\f\":return\"\\\\f\";case\"\\\\r\":return\"\\\\r\";default:return e.slice(1)}})));try{o=new RegExp(l,n)}catch(g){if(!quantifier_error.test(g.message))throw a=g.message.substring(g.message.lastIndexOf(\":\")+2)+\" in pattern: \"+e.toString(),new re.error(a,e);try{o=new RegExp(r,n.replace(\"u\",\"\"))}catch(g){throw a=g.message.substring(g.message.lastIndexOf(\":\")+2)+\" in pattern: \"+e.toString(),new re.error(a,e)}}const p=new re.Pattern(o,e,t);return _compiled_patterns[e.toString()]=p,p}function _compile(e,t){if(e instanceof re.Pattern){if(t!==zero||t.valueOf())throw new ValueError(\"cannot process flags argument with compiled pattern\");return e}if(!checkString(e))throw new TypeError(\"first argument must be string or compiled pattern\");return compile_pattern(e,t)}re.error=buildNativeClass(\"re.error\",{base:Exception,constructor:function error(e,t,r){this.$pattern=t,this.$msg=e,this.$pos=r||pyNone,Exception.call(this,e)},slots:{tp$doc:\"Exception raised for invalid regular expressions.\\n\\n    Attributes:\\n\\n        msg: The unformatted error message\\n        pattern: The regular expression pattern\\n\",tp$init(e,t){const[r,n,s]=copyKeywordToNamedArgs(\"re.error\",[\"msg\",\"pattern\",\"pos\"],e,t,[pyNone,pyNone]);this.$pattern=n,this.$pos=s,this.$msg=r}},getsets:{msg:{$get(){return this.$msg}},pattern:{$get(){return this.$pattern}},pos:{$get(){return this.$pos}}}});const zero=new pyInt(0),maxsize=Number.MAX_SAFE_INTEGER;re.Pattern=buildNativeClass(\"re.Pattern\",{constructor:function(e,t,r){this.v=e,this.str=t,this.$flags=r,this.$groups=null,this.$groupindex=null},slots:{$r(){const e=objectRepr(this.str).slice(0,200),t=objectRepr(this.$flags.nb$and(re.U.nb$invert()));return new pyStr(\"re.compile(\"+e+(t?\", \"+t:\"\")+\")\")},tp$richcompare(e,t){if(\"Eq\"!==t&&\"NotEq\"!==t||!(e instanceof re.Pattern))return pyNotImplemented;const r=this.str===e.str&&this.$flags===e.$flags;return\"Eq\"===t?r:!r},tp$hash(){},tp$doc:\"Compiled regular expression object.\"},methods:{match:{$meth:function match(e,t,r){return this.$match(e,t,r)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[zero,maxsize]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Matches zero or more characters at the beginning of the string.\"},fullmatch:{$meth:function fullmatch(e,t,r){return this.full$match(e,t,r)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[zero,maxsize]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Matches against all of the string.\"},search:{$meth:function search(e,t,r){return this.$search(e,t,r)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[zero,maxsize]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Scan through string looking for a match, and return a corresponding match object instance.\\n\\nReturn None if no position in the string matches.\"},sub:{$meth:function sub(e,t,r){return this.$sub(e,t,r)},$flags:{NamedArgs:[\"repl\",\"string\",\"count\"],Defaults:[zero]},$textsig:\"($self, /, repl, string, count=0)\",$doc:\"Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl.\"},subn:{$meth:function(e,t,r){return this.$subn(e,t,r)},$flags:{NamedArgs:[\"repl\",\"string\",\"count\"],Defaults:[zero]},$textsig:\"($self, /, repl, string, count=0)\",$doc:\"Return the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl.\"},findall:{$meth:function findall(e,t,r){return this.find$all(e,t,r)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[zero,maxsize]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Return a list of all non-overlapping matches of pattern in string.\"},split:{$meth:function split(e,t){return this.$split(e,t)},$flags:{NamedArgs:[\"string\",\"maxsplit\"],Defaults:[zero]},$textsig:\"($self, /, string, maxsplit=0)\",$doc:\"Split string by the occurrences of pattern.\"},finditer:{$meth:function finditer(e,t,r){return this.find$iter(e,t,r)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[zero,maxsize]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:\"Return an iterator over all non-overlapping matches for the RE pattern in string.\\n\\nFor each match, the iterator returns a match object.\"},scanner:{$meth:function scanner(e,t,r){return this.$scanner(e,t,r)},$flags:{NamedArgs:[\"string\",\"pos\",\"endpos\"],Defaults:[zero,maxsize]},$textsig:\"($self, /, string, pos=0, endpos=sys.maxsize)\",$doc:null},__copy__:{$meth:function copy(){return this},$flags:{NoArgs:!0},$textsig:\"($self, /)\",$doc:null},__deepcopy__:{$meth:function(){return this},$flags:{OneArg:!0},$textsig:\"($self, memo, /)\",$doc:null}},getsets:{pattern:{$get(){return this.str},$doc:\"The pattern string from which the RE object was compiled.\"},flags:{$get(){return this.$flags},$doc:\"The regex matching flags.\"},groups:{$get(){if(null===this.$groups){const e=(this.str.v.match(this.group$regex)||[]).length;this.$groups=new pyInt(e)}return this.$groups},$doc:\"The number of capturing groups in the pattern.\"},groupindex:{$get(){if(null===this.$groupindex){const e=this.str.v.matchAll(this.group$regex),t=[];let r=1;for(const n of e)n[1]&&(t.push(new pyStr(n[1])),t.push(new pyInt(r))),r++;this.$groupindex=new pyMappingProxy(new pyDict(t))}return this.$groupindex},$doc:\"A dictionary mapping group names to group numbers.\"}},proto:{group$regex:/\\((?!\\?(?!P<).*)(?:\\?P<([^\\d\\W]\\w*)>)?(?![^\\[]*\\])/g,get$count:e=>(e=asIndexSized(e,OverflowError))||Number.POSITIVE_INFINITY,get$jsstr(e,t,r){if(!checkString(e))throw new TypeError(\"expected string or bytes-like object\");if(t===zero&&r===maxsize||void 0===t&&void 0===r)return{jsstr:e.toString(),pos:zero.valueOf(),endpos:e.sq$length()};const{start:n,end:s}=pySlice.startEnd$wrt(e,t,r);return{jsstr:e.toString().slice(n,s),pos:n,endpos:s}},find$all(e,t,r){let{jsstr:n}=this.get$jsstr(e,t,r);const s=this.v,i=n.matchAll(s),o=[];for(let a of i)o.push(1===a.length?new pyStr(a[0]):2===a.length?new pyStr(a[1]):new pyTuple(a.slice(1).map((e=>new pyStr(e)))));return new pyList(o)},$split(e,t){t=(t=asIndexSized(t))||Number.POSITIVE_INFINITY;let{jsstr:r}=this.get$jsstr(e);const n=this.v,s=[];let i,o=0,a=0;for(;null!==(i=n.exec(r))&&o<t;)if(s.push(new pyStr(r.substring(a,i.index))),i.length>1&&s.push(...i.slice(1).map((e=>void 0===e?pyNone:new pyStr(e)))),o++,a=n.lastIndex,i.index===n.lastIndex){if(!r)break;r=r.slice(i.index),a=0,n.lastIndex=1}return n.lastIndex=0,s.push(new pyStr(r.slice(a))),new pyList(s)},match$from_repl(e,t,r,n){let s;const i=e[e.length-1];return\"object\"==typeof i?(s=e.slice(0,e.length-3),Object.assign(s,{groups:i}),s.index=e[e.length-3]):(s=e.slice(0,e.length-2),s.groups=void 0,s.index=e[e.length-2]),new re.Match(s,this.str,t,r,n)},do$sub(e,t,r){const{jsstr:n,pos:s,endpos:i}=this.get$jsstr(t);let o;checkCallable(e)?o=t=>{const r=pyCall(e,[t]);if(!checkString(r))throw new TypeError(\"expected str instance, \"+typeName(r)+\" found\");return r.toString()}:(e=this.get$jsstr(e).jsstr,o=t=>t.template$repl(e)),r=this.get$count(r);let a=0;const l=n.replace(this.v,((...e)=>{if(a>=r)return e[0];a++;const n=this.match$from_repl(e,t,s,i);return o(n)}));return[new pyStr(l),new pyInt(a)]},$sub(e,t,r){const[n]=this.do$sub(e,t,r);return n},$subn(e,t,r){return new pyTuple(this.do$sub(e,t,r))},do$match(e,t,r,n){let s;({jsstr:s,pos:r,endpos:n}=this.get$jsstr(t,r,n));const i=s.match(e);return null===i?pyNone:new re.Match(i,this,t,r,n)},$search(e,t,r){var n=new RegExp(this.v.source,this.v.flags.replace(\"g\",\"\"));return this.do$match(n,e,t,r)},$match(e,t,r){let n=this.v.source,s=this.v.flags.replace(\"g\",\"\").replace(\"m\",\"\");n=\"^\"+n;var i=new RegExp(n,s);return this.do$match(i,e,t,r)},full$match(e,t,r){let n=this.v.source,s=this.v.flags.replace(\"g\",\"\").replace(\"m\",\"\");n=\"^(?:\"+n+\")$\";var i=new RegExp(n,s);return this.do$match(i,e,t,r)},find$iter(e,t,r){let n;({jsstr:n,pos:t,endpos:r}=this.get$jsstr(e,t,r));const s=n.matchAll(this.v);return new pyIterator((()=>{const n=s.next().value;if(void 0!==n)return new re.Match(n,this,e,t,r)}))}},flags:{sk$acceptable_as_base_class:!1}}),re.Match=buildNativeClass(\"re.Match\",{constructor:function(e,t,r,n,s){this.v=e,this.$match=new pyStr(this.v[0]),this.str=r,this.$re=t,this.$pos=n,this.$endpos=s,this.$groupdict=null,this.$groups=null,this.$lastindex=null,this.$lastgroup=null,this.$regs=null},slots:{tp$doc:\"The result of re.match() and re.search().\\nMatch objects always have a boolean value of True.\",$r(){let e=\"<re.Match object; \";return e+=\"span=(\"+this.v.index+\", \"+(this.v.index+this.$match.sq$length())+\"), \",e+=\"match=\"+objectRepr(this.$match)+\">\",new pyStr(e)},tp$as_squence_or_mapping:!0,mp$subscript(e){const t=this.get$group(e);return void 0===t?pyNone:new pyStr(t)}},methods:{group:{$meth:function group(...e){let t;return e.length<=1?(t=this.get$group(e[0]),void 0===t?pyNone:new pyStr(t)):(t=[],e.forEach((e=>{e=this.get$group(e),t.push(void 0===e?pyNone:new pyStr(e))})),new pyTuple(t))},$flags:{MinArgs:0},$textsig:null,$doc:\"group([group1, ...]) -> str or tuple.\\n    Return subgroup(s) of the match by indices or names.\\n    For 0 returns the entire match.\"},start:{$meth:function start(e){const t=this.get$group(e);return new pyInt(void 0===t?-1:this.str.v.indexOf(t,this.v.index+this.$pos))},$flags:{MinArgs:0,MaxArgs:1},$textsig:\"($self, group=0, /)\",$doc:\"Return index of the start of the substring matched by group.\"},end:{$meth:function end(e){const t=this.get$group(e);return new pyInt(void 0===t?-1:this.str.v.indexOf(t,this.v.index+this.$pos)+[...t].length)},$flags:{MinArgs:0,MaxArgs:1},$textsig:\"($self, group=0, /)\",$doc:\"Return index of the end of the substring matched by group.\"},span:{$meth:function span(e){return this.$span(e)},$flags:{MinArgs:0,MaxArgs:1},$textsig:\"($self, group=0, /)\",$doc:\"For match object m, return the 2-tuple (m.start(group), m.end(group)).\"},groups:{$meth:function groups(e){return null!==this.$groups||(this.$groups=Array.from(this.v.slice(1),(t=>void 0===t?e:new pyStr(t))),this.$groups=new pyTuple(this.$groups)),this.$groups},$flags:{NamedArgs:[\"default\"],Defaults:[pyNone]},$textsig:\"($self, /, default=None)\",$doc:\"Return a tuple containing all the subgroups of the match, from 1.\\n\\n  default\\n    Is used for groups that did not participate in the match.\"},groupdict:{$meth:function groupdict(e){if(null!==this.$groupdict)return this.$groupdict;if(void 0===this.v.groups)this.$groupdict=new pyDict;else{const t=[];Object.entries(this.v.groups).forEach((([r,n])=>{t.push(new pyStr(r)),t.push(void 0===n?e:new pyStr(n))})),this.$groupdict=new pyDict(t)}return this.$groupdict},$flags:{NamedArgs:[\"default\"],Defaults:[pyNone]},$textsig:\"($self, /, default=None)\",$doc:\"Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\\n\\n  default\\n    Is used for groups that did not participate in the match.\"},expand:{$meth:function expand(e){if(!checkString(e))throw new TypeError(\"expected str instance got \"+typeName(e));return e=e.toString(),e=this.template$repl(e),new pyStr(e)},$flags:{OneArg:!0},$textsig:\"($self, /, template)\",$doc:\"Return the string obtained by doing backslash substitution on the string template, as done by the sub() method.\"},__copy__:{$meth:function __copy__(){return this},$flags:{NoArgs:!0},$textsig:\"($self, /)\",$doc:null},__deepcopy__:{$meth:function __deepcopy__(){return this},$flags:{OneArg:!0},$textsig:\"($self, memo, /)\",$doc:null}},getsets:{lastindex:{$get(){if(null!==this.$lastindex)return this.$lastindex;let e,t=0;return this.v.forEach(((r,n)=>{n&&void 0!==r&&e!==r&&(t=n,e=r)})),this.$lastindex=t?new pyInt(t):pyNone,this.$lastindex},$doc:\"The integer index of the last matched capturing group.\"},lastgroup:{$get(){if(null!==this.$lastgroup)return this.$lastgroup;if(void 0===this.v.groups)this.$lastgroup=pyNone;else{let e;Object.entries(this.v.groups).forEach((([t,r])=>{void 0!==r&&(e=t)})),this.$lastgroup=void 0===e?pyNone:new pyStr(e)}return this.$lastgroup},$doc:\"The name of the last matched capturing group.\"},regs:{$get(){if(null!==this.$regs)return this.$regs;const e=[];return this.v.forEach(((t,r)=>{e.push(this.$span(r))})),this.$regs=new pyTuple(e),this.$regs}},string:{$get(){return this.str},$doc:\"The string passed to match() or search().\"},re:{$get(){return this.$re},$doc:\"The regular expression object.\"},pos:{$get(){return new pyInt(this.$pos)},$doc:\"The index into the string at which the RE engine started looking for a match.\"},endpos:{$get(){return new pyInt(this.$endpos)},$doc:\"The index into the string beyond which the RE engine will not go.\"}},proto:{get$group(e){if(void 0===e)return this.v[0];if(checkString(e)){if(e=e.toString(),this.v.groups&&Object.prototype.hasOwnProperty.call(this.v.groups,e))return this.v.groups[e]}else if(isIndex(e)&&(e=asIndexSized(e))>=0&&e<this.v.length)return this.v[e];throw new IndexError(\"no such group\")},$span(e){const t=this.get$group(e);if(void 0===t)return new pyTuple([new pyInt(-1),new pyInt(-1)]);let r;return\"\"===t&&\"\"===this.v[0]?(r=new pyInt(this.v.index),new pyTuple([r,r])):(r=this.str.v.indexOf(t,this.v.index+this.$pos),new pyTuple([new pyInt(r),new pyInt(r+[...t].length)]))},hasOwnProperty:Object.prototype.hasOwnProperty,template$regex:/\\\\([1-9][0-9]|[1-9])|\\\\g<([1-9][0-9]*)>|\\\\g<([^\\d\\W]\\w*)>|\\\\g<?.*>?/g,template$repl(e){return e.replace(this.template$regex,((e,t,r,n,s,i)=>{let o;if(void 0!==(t=t||r)?o=t<this.v.length?this.v[t]||\"\":void 0:this.v.groups&&this.hasOwnProperty.call(this.v.groups,n)&&(o=this.v.groups[n]||\"\"),void 0===o){if(n)throw new IndexError(\"unknown group name '\"+n+\"'\");throw new re.error(\"invalid group reference \"+(t||e.slice(2))+\" at position \"+(s+1))}return o}))}},flags:{sk$acceptable_as_base_class:!1}}),setUpModuleMethods(\"re\",re,{match:{$meth:function match(e,t,r){return _compile(e,r).$match(t)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[zero]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Try to apply the pattern at the start of the string, returning\\n    a Match object, or None if no match was found.\"},fullmatch:{$meth:function fullmatch(e,t,r){return _compile(e,r).full$match(t)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[zero]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Try to apply the pattern to all of the string, returning\\n    a Match object, or None if no match was found.\"},search:{$meth:function search(e,t,r){return _compile(e,r).$search(t)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[zero]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Scan through string looking for a match to the pattern, returning\\n    a Match object, or None if no match was found.\"},sub:{$meth:function sub(e,t,r,n,s){return _compile(e,s).$sub(t,r,n)},$flags:{NamedArgs:[\"pattern\",\"repl\",\"string\",\"count\",\"flags\"],Defaults:[zero,zero]},$textsig:\"($module, / , pattern, string, count=0, flags=0)\",$doc:\"Return the string obtained by replacing the leftmost\\n    non-overlapping occurrences of the pattern in string by the\\n    replacement repl.  repl can be either a string or a callable;\\n    if a string, backslash escapes in it are processed.  If it is\\n    a callable, it's passed the Match object and must return\\n    a replacement string to be used.\"},subn:{$meth:function subn(e,t,r,n,s){return _compile(e,s).$subn(t,r,n)},$flags:{NamedArgs:[\"pattern\",\"repl\",\"string\",\"count\",\"flags\"],Defaults:[zero,zero]},$textsig:\"($module, / , pattern, string, count=0, flags=0)\",$doc:\"Return a 2-tuple containing (new_string, number).\\n    new_string is the string obtained by replacing the leftmost\\n    non-overlapping occurrences of the pattern in the source\\n    string by the replacement repl.  number is the number of\\n    substitutions that were made. repl can be either a string or a\\n    callable; if a string, backslash escapes in it are processed.\\n    If it is a callable, it's passed the Match object and must\\n    return a replacement string to be used.\"},split:{$meth:function split(e,t,r,n){return _compile(e,n).$split(t,r)},$flags:{NamedArgs:[\"pattern\",\"string\",\"maxsplit\",\"flags\"],Defaults:[zero,zero]},$textsig:\"($module, / , pattern, string, maxsplit=0, flags=0)\",$doc:\"Split the source string by the occurrences of the pattern,\\n    returning a list containing the resulting substrings.  If\\n    capturing parentheses are used in pattern, then the text of all\\n    groups in the pattern are also returned as part of the resulting\\n    list.  If maxsplit is nonzero, at most maxsplit splits occur,\\n    and the remainder of the string is returned as the final element\\n    of the list.\"},findall:{$meth:function findall(e,t,r){return _compile(e,r).find$all(t)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[zero]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Return a list of all non-overlapping matches in the string.\\n\\n    If one or more capturing groups are present in the pattern, return\\n    a list of groups; this will be a list of tuples if the pattern\\n    has more than one group.\\n\\n    Empty matches are included in the result.\"},finditer:{$meth:function finditer(e,t,r){return _compile(e,r).find$iter(t)},$flags:{NamedArgs:[\"pattern\",\"string\",\"flags\"],Defaults:[zero]},$textsig:\"($module, / , pattern, string, flags=0)\",$doc:\"Return an iterator over all non-overlapping matches in the\\n    string.  For each match, the iterator returns a Match object.\\n\\n    Empty matches are included in the result.\"},compile:{$meth:function compile(e,t){return _compile(e,t)},$flags:{NamedArgs:[\"pattern\",\"flags\"],Defaults:[zero]},$textsig:\"($module, / , pattern, flags=0)\",$doc:\"Compile a regular expression pattern, returning a Pattern object.\"},purge:{$meth:function purge(){return Object.keys(_compiled_patterns).forEach((e=>{delete _compiled_patterns[e]})),pyNone},$flags:{NoArgs:!0},$textsig:\"($module, / )\",$doc:\"Clear the regular expression caches\"},template:{$meth:function template(e,t){return _compile(e,numberBinOp(re.T,t,\"BitOr\"))},$flags:{NamedArgs:[\"pattern\",\"flags\"],Defaults:[zero]},$textsig:\"($module, / , pattern, flags=0)\",$doc:\"Compile a template pattern, returning a Pattern object\"},escape:{$meth:function(e){if(!checkString(e))throw new TypeError(\"expected a str instances, got \"+typeName(e));return e=(e=e.toString()).replace(escape_chrs,\"\\\\$&\"),new pyStr(e)},$flags:{NamedArgs:[\"pattern\"],Defaults:[]},$textsig:\"($module, / , pattern)\",$doc:\"\\n    Escape special characters in a string.\\n    \"}});const escape_chrs=/[\\&\\~\\#.*+\\-?^${}()|[\\]\\\\\\t\\r\\v\\f\\n ]/g;return re}","src/lib/signal.js":"var $builtinmodule=function(n){var i={};return i.SIG_DFL=new Sk.builtin.int_(0),i.SIG_IGN=new Sk.builtin.int_(1),i.CTRL_C_EVENT=new Sk.builtin.int_(0),i.CTRL_BREAK_EVENT=new Sk.builtin.int_(0),i.NSIG=new Sk.builtin.int_(23),i.SIGHUP=new Sk.builtin.int_(1),i.SIGNINT=new Sk.builtin.int_(2),i.SIGILL=new Sk.builtin.int_(4),i.SIGFPE=new Sk.builtin.int_(8),i.SIGKILL=new Sk.builtin.int_(9),i.SIGSEGV=new Sk.builtin.int_(11),i.SIGTERM=new Sk.builtin.int_(15),i.SIGBREAK=new Sk.builtin.int_(21),i.SIGABRT=new Sk.builtin.int_(22),i.pause=new Sk.builtin.func((function(){Sk.builtin.pyCheckArgsLen(\"pause\",arguments.length,0,0);var n=new Sk.misceval.Suspension;return n.resume=function(){return Sk.builtin.none.none$},n.data={type:\"Sk.promise\",promise:new Promise((function(n,i){if(null!=Sk.signals&&Sk.signals.addEventListener){Sk.signals.addEventListener((function handleSignal(i){Sk.signals.removeEventListener(handleSignal),n()}))}else console.warn(\"signal.pause() not supported\"),Sk.misceval.print_(\"signal.pause() not supported\"),n()}))},n})),i.signal=new Sk.builtin.func((function(){throw new Sk.builtin.NotImplementedError(\"signal.signal is not supported.\")})),i};","src/lib/string.js":"var $builtinmodule=function(i){var t={};return t.ascii_lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),t.ascii_uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),t.ascii_letters=new Sk.builtin.str(t.ascii_lowercase.v+t.ascii_uppercase.v),t.lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),t.uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),t.letters=new Sk.builtin.str(t.lowercase.v+t.uppercase.v),t.digits=new Sk.builtin.str(\"0123456789\"),t.hexdigits=new Sk.builtin.str(\"0123456789abcdefABCDEF\"),t.octdigits=new Sk.builtin.str(\"01234567\"),t.punctuation=new Sk.builtin.str(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"),t.whitespace=new Sk.builtin.str(\"\\t\\n\\v\\f\\r \"),t.printable=new Sk.builtin.str(t.digits.v+t.letters.v+t.punctuation.v+\" \\t\\n\\r\\v\\f\"),t.split=new Sk.builtin.func((function(...i){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.split,i)})),t.capitalize=new Sk.builtin.func((function(i){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.capitalize,[i])})),t.join=new Sk.builtin.func((function(i,t){return void 0===t&&(t=new Sk.builtin.str(\" \")),Sk.misceval.callsimArray(Sk.builtin.str.prototype.join,[t,i])})),t.capwords=new Sk.builtin.func((function(i,n){if(Sk.builtin.pyCheckArgsLen(\"capwords\",arguments.length,1,2),!Sk.builtin.checkString(i))throw new Sk.builtin.TypeError(\"s must be a string\");if(void 0===n&&(n=new Sk.builtin.str(\" \")),!Sk.builtin.checkString(n))throw new Sk.builtin.TypeError(\"sep must be a string\");for(var e=Sk.misceval.callsimArray(t.split,[i,n]).v,r=[],l=0;l<e.length;l++){var s=e[l],u=Sk.misceval.callsimArray(t.capitalize,[s]);r.push(u)}return Sk.misceval.callsimArray(t.join,[new Sk.builtin.list(r),n])})),t};","src/lib/time.js":"var $builtinmodule=function(t){var e={};e.__package__=new Sk.builtin.str(\"\");var n=Sk.builtin.make_structseq(\"time\",\"struct_time\",{tm_year:\"year, for example, 1993\",tm_mon:\"month of year, range [1, 12]\",tm_mday:\"day of month, range [1, 31]\",tm_hour:\"hours, range [0, 23]\",tm_min:\"minutes, range [0, 59]\",tm_sec:\"seconds, range [0, 61]\",tm_wday:\"day of week, range [0, 6], Monday is 0\",tm_yday:\"day of year, range [1, 366]\",tm_isdst:\"1 if summer time is in effect, 0 if not, and -1 if unknown\"},{tm_zone:\"abbreviation of timezone name\",tm_gmtoff:\"offset from UTC in seconds\"});function padLeft(t,e,n){var i=t.toString();return Array(e-i.length+1).join(n||\" \")+i}function getDayOfYear(t,e){var n=(e=e||!1)?t.getUTCMonth():t.getMonth(),i=e?t.getUTCDate():t.getDate(),u=[0,31,59,90,120,151,181,212,243,273,304,334][n]+i;return n>1&&function isLeapYear(t){return 0==(3&t)&&(t%100!=0||t%400==0)}(e?t.getUTCFullYear():t.getFullYear())&&u++,u}function stdTimezoneOffset(){var t=new Date(2002,0,1),e=new Date(2002,6,1);return Math.max(t.getTimezoneOffset(),e.getTimezoneOffset())}function dst(t){return t.getTimezoneOffset()<stdTimezoneOffset()}function timeZoneName(t){var e,n=/\\((.*)\\)/.exec(t.toString());if(null!=Sk.global.navigator&&(e=Sk.global.navigator.userLanguage||Sk.global.navigator.language),n&&n.length>1)return n[1];if(void 0===e)return null;try{return(n=t.toLocaleString(e,{timeZoneName:\"short\"}).split(\" \"))[n.length-1]}catch(i){return null}}function from_seconds(t,e){var i=new Date;if(t){Sk.builtin.pyCheckType(\"secs\",\"number\",Sk.builtin.checkNumber(t));var u=Sk.builtin.asnum$(t);i.setTime(1e3*u)}return function date_to_struct_time(t,e){let i;if(e=e||!1)i=[new Sk.builtin.str(\"UTC\"),new Sk.builtin.int_(0)];else{var u=-t.getTimezoneOffset()/60,r=(u<0?\"-\":\"+\")+(\"\"+Math.abs(u)).padStart(2,\"0\");i=[new Sk.builtin.str(r),new Sk.builtin.int_(3600*u)]}return new n([Sk.builtin.assk$(e?t.getUTCFullYear():t.getFullYear()),Sk.builtin.assk$((e?t.getUTCMonth():t.getMonth())+1),Sk.builtin.assk$(e?t.getUTCDate():t.getDate()),Sk.builtin.assk$(e?t.getUTCHours():t.getHours()),Sk.builtin.assk$(e?t.getUTCMinutes():t.getMinutes()),Sk.builtin.assk$(e?t.getUTCSeconds():t.getSeconds()),Sk.builtin.assk$(((e?t.getUTCDay():t.getDay())+6)%7),Sk.builtin.assk$(getDayOfYear(t,e)),Sk.builtin.assk$(e?0:dst(t)?1:0)],i)}(i,e)}e.struct_time=n,e.time=new Sk.builtin.func((function(){return Sk.builtin.pyCheckArgsLen(\"time\",arguments.length,0,0),new Sk.builtin.float_(Date.now()/1e3)})),e.sleep=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"sleep\",arguments.length,1,1),Sk.builtin.pyCheckType(\"delay\",\"float\",Sk.builtin.checkNumber(t)),new Sk.misceval.promiseToSuspension(new Promise((function(e){Sk.setTimeout((function(){e(Sk.builtin.none.none$)}),1e3*Sk.ffi.remapToJs(t))})))})),e.localtime=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"localtime\",arguments.length,0,1),from_seconds(t,!1)})),e.gmtime=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"gmtime\",arguments.length,0,1),from_seconds(t,!0)}));var i=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],u=[\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"];function asctime_f(t){if(Sk.builtin.pyCheckArgsLen(\"asctime\",arguments.length,0,1),!t||Sk.builtin.checkNone(t)?t=from_seconds():t instanceof n||(t=new n(t)),t instanceof Sk.builtin.tuple&&9==t.v.length){var e=[];return e.push(u[Sk.builtin.asnum$(t.v[6])]),e.push(i[Sk.builtin.asnum$(t.v[1])-1]),e.push(padLeft(Sk.builtin.asnum$(t.v[2]).toString(),2,\"0\")),e.push(padLeft(Sk.builtin.asnum$(t.v[3]).toString(),2,\"0\")+\":\"+padLeft(Sk.builtin.asnum$(t.v[4]).toString(),2,\"0\")+\":\"+padLeft(Sk.builtin.asnum$(t.v[5]).toString(),2,\"0\")),e.push(padLeft(Sk.builtin.asnum$(t.v[0]).toString(),4,\"0\")),new Sk.builtin.str(e.join(\" \"))}}function mktime_f(t){if(Sk.builtin.pyCheckArgsLen(\"mktime\",arguments.length,1,1),t instanceof Sk.builtin.tuple&&9==t.v.length){var e=new Date(Sk.builtin.asnum$(t.v[0]),Sk.builtin.asnum$(t.v[1])-1,Sk.builtin.asnum$(t.v[2]),Sk.builtin.asnum$(t.v[3]),Sk.builtin.asnum$(t.v[4]),Sk.builtin.asnum$(t.v[5]));return Sk.builtin.assk$(e.getTime()/1e3,void 0)}throw new Sk.builtin.TypeError(\"mktime() requires a struct_time or 9-tuple\")}e.asctime=new Sk.builtin.func(asctime_f),e.ctime=new Sk.builtin.func((function(t){return Sk.builtin.pyCheckArgsLen(\"ctime\",arguments.length,0,1),asctime_f(from_seconds(t))})),e.mktime=new Sk.builtin.func(mktime_f),e.timezone=new Sk.builtin.int_(60*stdTimezoneOffset()),e.altzone=new Sk.builtin.int_(60*function altTimezoneOffset(){var t=new Date(2002,0,1),e=new Date(2002,6,1);return Math.min(t.getTimezoneOffset(),e.getTimezoneOffset())}()),e.daylight=new Sk.builtin.int_(function daylight_check(){const t=new Date(2002,0,1),e=new Date(2002,6,1);return t.getTimezoneOffset()!=e.getTimezoneOffset()}()?1:0),e.tzname=new Sk.builtin.tuple(function timeZoneNames(){var t=new Date(2002,0,1),e=new Date(2002,6,1);return dst(t)?[new Sk.builtin.str(timeZoneName(e)),new Sk.builtin.str(timeZoneName(t))]:[new Sk.builtin.str(timeZoneName(t)),new Sk.builtin.str(timeZoneName(e))]}()),e.accept2dyear=Sk.builtin.assk$(1),e.clock=new Sk.builtin.func((function(){var t=0;return t=Sk.global.performance&&Sk.global.performance.now?performance.now()/1e3:(new Date).getTime()/1e3,new Sk.builtin.float_(t)})),e.strftime=new Sk.builtin.func((function strftime_f(t,e){var i;if(Sk.builtin.pyCheckArgsLen(\"strftime\",arguments.length,1,2),!Sk.builtin.checkString(t))throw new Sk.builtin.TypeError(\"format must be a string\");return e?e instanceof n||(e=new n(e)):e=from_seconds(),function check_struct_time(t){if(!(t instanceof n))throw new Sk.builtin.TypeError(\"Required argument 'struct_time' must be of type: 'struct_time'\");var e,i=t.v.length,u=t.v;for(e=0;e<i;++e)if(!Sk.builtin.checkInt(u[e]))throw new Sk.builtin.TypeError(\"struct_time may only contain integers\");return!0}(e),i=Sk.ffi.remapToJs(t),Sk.ffi.remapToPy(Sk.global.strftime(i,new Date(1e3*mktime_f(e).v)))})),e.tzset=new Sk.builtin.func((function tzset_f(){throw new Sk.builtin.NotImplementedError(\"time.tzset() is not yet implemented\")}));let r=null;return e.strptime=new Sk.builtin.func((function strptime_f(...t){return Sk.builtin.pyCheckArgsLen(\"strptime\",t.length,1,2),null===r?Sk.misceval.chain(Sk.importModule(\"_strptime\",!1,!0),(e=>(r=e.tp$getattr(new Sk.builtin.str(\"_strptime_time\")),r.tp$call(t)))):r.tp$call(t)})),e};","src/lib/token.js":"var $builtinmodule=function(n){var e={};e.__file__=new Sk.builtin.str(\"/src/lib/token.py\");const t=[];for(let i in Sk.token.tok_name){const n=Sk.token.tok_name[i].slice(2),k=parseInt(i,10);t.push(Sk.ffi.remapToPy(k)),t.push(Sk.ffi.remapToPy(n)),e[n]=Sk.ffi.remapToPy(k)}return e.tok_name=new Sk.builtin.dict(t),e.ISTERMINAL=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"ISTERMINAL\",arguments.length,1,1),Sk.token.ISTERMINAL(Sk.ffi.remapToJs(n))})),e.ISNONTERMINAL=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"ISNONTERMINAL\",arguments.length,1,1),Sk.token.ISNONTERMINAL(Sk.ffi.remapToJs(n))})),e.ISEOF=new Sk.builtin.func((function(n){return Sk.builtin.pyCheckArgsLen(\"ISEOF\",arguments.length,1,1),Sk.token.ISEOF(Sk.ffi.remapToJs(n))})),e};","src/lib/tokenize.js":"var $builtinmodule=function(e){var i={};return i.tokenize=new Sk.builtin.func((function(e){Sk.builtin.pyCheckArgsLen(\"tokenize\",1,1),Sk.builtin.checkFunction(e);const i=[];return Sk._tokenize(\"<stdin>\",(function jsReadline(){const i=Sk.misceval.callsimArray(e);return Sk.ffi.remapToJs(i)}),\"UTF-8\",(function receiveToken(e){i.push(new Sk.builtin.tuple([Sk.ffi.remapToPy(e.type),Sk.ffi.remapToPy(e.string),new Sk.builtin.tuple([Sk.ffi.remapToPy(e.start[0]),Sk.ffi.remapToPy(e.start[1])]),new Sk.builtin.tuple([Sk.ffi.remapToPy(e.end[0]),Sk.ffi.remapToPy(e.end[1])]),Sk.ffi.remapToPy(e.line)]))})),new Sk.builtin.list(i)})),i};","src/lib/turtle.js":"var $builtinmodule=function(e){\"use strict\";var t=function getConfiguredTarget(){var e,t;for(t=\"string\"==typeof(e=Sk.TurtleGraphics&&Sk.TurtleGraphics.target||\"turtle\")?document.getElementById(e):e;t.firstChild;)t.removeChild(t.firstChild);return t}();return t.turtleInstance?t.turtleInstance.reset():t.turtleInstance=function generateTurtleModule(e){var t,n,r,i,s,a,o,l,u={__name__:new Sk.builtin.str(\"turtle\")},c=!0,h=1e3/30,d={},f={},_={target:\"turtle\",width:400,height:400,worldWidth:0,worldHeight:0,animate:!0,bufferSize:0,allowUndo:!0,assets:{}};function getAsset(e){var t=i.assets,n=\"function\"==typeof t?t(e):t[e];return\"string\"==typeof n?new Promise((function(t,r){var s=new Image;s.onload=function(){i.assets[e]=this,t(s)},s.onerror=function(){r(new Error(\"Missing asset: \"+n))},s.src=n})):new InstantPromise(void 0,n)}function InstantPromise(e,t){this.lastResult=t,this.lastError=e}function FrameManager(){this.reset()}function getFrameManager(){return o||(o=new FrameManager),o}function MouseHandler(){var e=this;for(var t in this._target=getTarget(),this._managers={},this._handlers={mousedown:function(t){e.onEvent(\"mousedown\",t)},mouseup:function(t){e.onEvent(\"mouseup\",t)},mousemove:function(t){e.onEvent(\"mousemove\",t)}},this._handlers)this._target.addEventListener(t,this._handlers[t])}function EventManager(e,t){this._type=e,this._target=t,this._handlers=void 0,function getMouseHandler(){return a||(a=new MouseHandler),a}().addManager(e,this)}function Turtle(e){if(getFrameManager().addTurtle(this),this._screen=getScreen(),this._managers={},this._shape=e.v,!d.hasOwnProperty(this._shape))throw new Sk.builtin.ValueError(\"Shape:'\"+this._shape+\"' not in default shape, please check shape again!\");this.reset()}function Screen(){var e,t;this._frames=1,this._delay=void 0,this._bgcolor=\"none\",this._mode=\"standard\",this._managers={},this._keyLogger={},e=(i.worldWidth||i.width||getWidth())/2,t=(i.worldHeight||i.height||getHeight())/2,this.setUpWorld(-e,-t,e,t)}function ensureAnonymous(){return s||(s=Sk.misceval.callsimArray(u.Turtle)),s.instance}function getTarget(){return e}function getScreen(){return r||(r=new Screen),r}function getWidth(){return 0|(r&&r._width||i.width||getTarget().clientWidth||_.width)}function getHeight(){return 0|(r&&r._height||i.height||getTarget().clientHeight||_.height)}function createLayer(e,t){var n,r=document.createElement(\"canvas\"),i=getWidth(),s=getHeight(),a=getTarget().firstChild?-s+\"px\":\"0\";return r.width=i,r.height=s,r.style.position=\"relative\",r.style.display=\"block\",r.style.setProperty(\"margin-top\",a),r.style.setProperty(\"z-index\",e),t&&(r.style.display=\"none\"),getTarget().appendChild(r),(n=r.getContext(\"2d\")).lineCap=\"round\",n.lineJoin=\"round\",applyWorld(getScreen(),n),n}function cancelAnimationFrame(){t&&((window.cancelAnimationFrame||window.mozCancelAnimationFrame)(t),t=void 0),n&&(window.clearTimeout(n),n=void 0)}function applyWorld(e,t){var n=e.llx,r=(e.lly,e.urx,e.ury),i=e.xScale,s=e.yScale;t&&(clearLayer(t),t.restore(),t.save(),t.scale(1/i,1/s),t.translate(-n,-r))}function pushUndo(e){var t,n,r;if(i.allowUndo&&e._bufferSize){for(e._undoBuffer||(e._undoBuffer=[]);e._undoBuffer.length>e._bufferSize;)e._undoBuffer.shift();for(n={},t=\"x y angle radians color fill down filling shown shape size\".split(\" \"),r=0;r<t.length;r++)n[t[r]]=e[\"_\"+t[r]];return e._undoBuffer.push(n),e.addUpdate((function(){n.fillBuffer=this.fillBuffer?this.fillBuffer.slice():void 0,e._paper&&e._paper.canvas&&(n.image=e._paper.canvas.toDataURL())}),!1)}}e.hasAttribute(\"tabindex\")||e.setAttribute(\"tabindex\",0),f.FLOAT=function(e){return new Sk.builtin.float_(e)},f.COLOR=function(e){if(\"string\"==typeof e)return new Sk.builtin.str(e);for(var t=0;t<3;t++)e[t]=Sk.builtin.assk$(e[t]);return 4===e.length&&(e[3]=new Sk.builtin.float_(e[3])),new Sk.builtin.tuple(e)},f.TURTLE_LIST=function(e){for(var t=[],n=0;n<e.length;n++)t.push(e[n].skInstance);return new Sk.builtin.tuple(t)},d.arrow=[[-10,0],[10,0],[0,10]],d.square=[[10,-10],[10,10],[-10,10],[-10,-10]],d.triangle=[[10,-5.77],[0,11.55],[-10,-5.77]],d.classic=[[0,0],[-5,-9],[0,-7],[5,-9]],d.turtle=[[0,16],[-2,14],[-1,10],[-4,7],[-7,9],[-9,8],[-6,5],[-7,1],[-5,-3],[-8,-6],[-6,-8],[-4,-5],[0,-7],[4,-5],[6,-8],[8,-6],[5,-3],[7,1],[6,5],[9,8],[7,9],[4,7],[1,10],[2,14]],d.circle=[[10,0],[9.51,3.09],[8.09,5.88],[5.88,8.09],[3.09,9.51],[0,10],[-3.09,9.51],[-5.88,8.09],[-8.09,5.88],[-9.51,3.09],[-10,0],[-9.51,-3.09],[-8.09,-5.88],[-5.88,-8.09],[-3.09,-9.51],[-0,-10],[3.09,-9.51],[5.88,-8.09],[8.09,-5.88],[9.51,-3.09]],i=function(){var e;for(e in Sk.TurtleGraphics||(Sk.TurtleGraphics={}),_)Sk.TurtleGraphics.hasOwnProperty(e)||(Sk.TurtleGraphics[e]=_[e]);return Sk.TurtleGraphics}(),InstantPromise.prototype.then=function(e){if(this.lastError)return this;try{this.lastResult=e(this.lastResult)}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this},InstantPromise.prototype.catch=function(e){if(this.lastError)try{this.lastResult=e(this.lastError),this.lastError=void 0}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this},function(e){var r,s;function animationFrame(e){return i.animate?!e&&r?r:function(t){return n=window.setTimeout(t,e||h)}:function(e){e()}}(s=window.requestAnimationFrame||window.mozRequestAnimationFrame)&&(r=function(e){return t=s(e)}),e.willRenderNext=function(){return!(!this._buffer||this._frameCount+1!==this.frameBuffer())},e.turtles=function(){return this._turtles},e.addTurtle=function(e){this._turtles.push(e)},e.reset=function(){if(this._turtles)for(var e=this._turtles.length;--e>=0;)this._turtles[e].reset();this._turtles=[],this._frames=[],this._frameCount=0,this._buffer=1,this._rate=0,this._animationFrame=animationFrame()},e.addFrame=function(e,t){return t&&(this._frameCount+=1),this.frames().push(e),!i.animate||this._buffer&&this._frameCount===this.frameBuffer()?this.update():new InstantPromise},e.frames=function(){return this._frames},e.frameBuffer=function(e){return\"number\"==typeof e&&(this._buffer=0|e,e&&e<=this._frameCount)?this.update():this._buffer},e.refreshInterval=function(e){return\"number\"==typeof e&&(this._rate=0|e,this._animationFrame=animationFrame(e)),this._rate},e.update=function(){return this._frames&&this._frames.length?this.requestAnimationFrame():new InstantPromise},e.requestAnimationFrame=function(){var e,t,n=this._frames,r=this._animationFrame,i=this._turtles,s=getScreen().spriteLayer();return this._frames=[],this._frameCount=0,new Promise((function(a){r((function paint(){for(t=0;t<n.length;t++)n[t]&&n[t]();for(clearLayer(s),t=0;t<i.length;t++)(e=i[t]).getState().shown&&drawTurtle(e.getState(),s);a()}))}))}}(FrameManager.prototype),(l=MouseHandler.prototype).onEvent=function(e,t){var n,r,i,s,a,o=this._managers[e],l=this._managers.mousemove,u=!1;function computeCoordinates(){if(!u){var e=getScreen(),a=e.spriteLayer().canvas.getBoundingClientRect();n=t.clientX-a.left|0,r=t.clientY-a.top|0,i=n*e.xScale+e.llx,s=r*e.yScale+e.ury,u=!0}}if((\"mousedown\"===e||\"mouseup\"===e)&&l&&l.length)for(computeCoordinates(),a=l.length;--a>=0;)l[a].test(n,r,i,s)&&l[a].canMove(\"mousedown\"===e);if(o&&o.length)for(computeCoordinates(),a=o.length;--a>=0;)(\"mousemove\"===e&&o[a].canMove()&&o[a].test(n,r,i,s)||\"mousedown\"===e&&o[a].test(n,r,i,s))&&o[a].trigger([i,s])},l.reset=function(){this._managers={}},l.addManager=function(e,t){this._managers[e]||(this._managers[e]=[]),this._managers[e].push(t)},function(e){e.reset=function(){this._handlers=void 0},e.canMove=function(e){return!(!this._target||!this._target.hitTest)&&(void 0!==e&&(this._target.hitTest.hit=e),this._target.hitTest.hit)},e.test=function(e,t,n,r){return this._target&&this._target.hitTest?this._target.hitTest(e,t,n,r):!!this._target},e.trigger=function(e){var t,n=this._handlers;if(n&&n.length)for(t=0;t<n.length;t++)n[t].apply({},e)},e.addHandler=function(e,t){var n=this._handlers;if(!t&&n&&n.length)for(;n.shift(););\"function\"==typeof e?(n||(n=this._handlers=[]),n.push(e)):n&&!n.length&&this.reset()}}(EventManager.prototype),Turtle.RADIANS=2*Math.PI,function(e){function circleRotate(e,t,n){return function(){return e.addUpdate(void 0,!1,{angle:t,radians:n})}}function circleSegment(e,t,n,r,i,s){return function(){return e.translate(t,n,r,i,s,!0)}}e.hitTest=function(e,t,n,r){var i=getScreen().hitTestLayer();clearLayer(i),drawTurtle(this.getState(),i);var s=i.getImageData(e,t,1,1).data;return s[3]||s[0]||s[1]||s[2]},e.addUpdate=function(e,t,n){var r=this.getState(),i=Array.prototype.slice.call(arguments,n?2:3);return getFrameManager().addFrame((function(){if(e&&e.apply(r,i),n)for(var t in n)r[t]=n[t]}),t)},e.getState=function(){var e=this;return this._state||(this._state={x:this._x,y:this._y,angle:this._angle,radians:this._radians,shape:this._shape,color:this._color,fill:this._fill,filling:this._filling,size:this._size,speed:this._computed_speed,down:this._down,shown:this._shown,colorMode:this._colorMode,context:function(){return e.getPaper()}}),this._state},e.translate=function(e,t,n,r,i,s){var a=this;return function translate(e,t,n,r,i,s,a){var o,l=e._computed_speed,u=getScreen(),c=Math.abs(u.xScale),h=Math.abs(u.yScale),d=t,f=n,_=Math.sqrt(r*r*c+i*i*h),g=l?Math.round(Math.max(1,_/l)):1,p=r/g,m=i/g,v=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise,y=!(!l&&a);for(e.addUpdate((function(){this.filling&&this.fillBuffer.push({x:this.x,y:this.y,stroke:this.down,color:this.color,size:this.size})}),!1),o=0;o<g;o++)d=t+p*(o+1),f=n+m*(o+1),v=v.then(partialTranslate(e,d,f,s,y)),s=!1;return v.then((function(){return[t+r,n+i]}))}(this,e,t,n,r,i,s).then((function(e){a._x=e[0],a._y=e[1]}))},e.rotate=function(e,t,n){var r=this;return function rotate(e,t,n,r){var i,s=e._computed_speed,a=n/e._fullCircle*360,o=s?Math.round(Math.max(1,Math.abs(a)/s)):1,l=n/o,u={},c=!(!s&&r),h=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise;for(i=0;i<o;i++)calculateHeading(e,t+l*(i+1),u),h=h.then(partialRotate(e,u.angle,u.radians,c));return h.then((function(){return calculateHeading(e,t+n)}))}(this,e,t,n).then((function(e){r._angle=e.angle,r._radians=e.radians}))},e.queueMoveBy=function(e,t,n,r){var i=Math.cos(n)*r,s=Math.sin(n)*r;return this.translate(e,t,i,s,!0)},e.queueTurnTo=function(e,t){return(t%=this._fullCircle)<0&&(t+=this._fullCircle),this.rotate(e,t-e)},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new EventManager(e,this)),this._managers[e]},e.getPaper=function(){return this._paper||(this._paper=createLayer(2))},e.reset=function(){for(var e in this._x=0,this._y=0,this._radians=0,this._angle=0,this._shown=!0,this._down=!0,this._color=\"black\",this._fill=\"black\",this._size=1,this._filling=!1,this._undoBuffer=[],this._speed=3,this._computed_speed=6,this._colorMode=1,this._state=void 0,this._managers)this._managers[e].reset();this._isRadians=!1,this._fullCircle=360,this._bufferSize=\"number\"==typeof i.bufferSize?i.bufferSize:0,removeLayer(this._paper),this._paper=void 0},e.$degrees=function(e){return e=\"number\"==typeof e?Math.abs(e):360,this._isRadians=!1,e&&this._fullCircle?this._angle=this._angle/this._fullCircle*e:this._angle=this._radians=0,this._fullCircle=e,this.addUpdate(void 0,!1,{angle:this._angle,radians:this._radians})},e.$degrees.minArgs=0,e.$degrees.co_varnames=[\"fullcircle\"],e.$degrees.returnType=f.FLOAT,e.$radians=function(){return this._isRadians||(this._isRadians=!0,this._angle=this._radians,this._fullCircle=Turtle.RADIANS),this._angle},e.$radians.returnType=f.FLOAT,e.$position=e.$pos=function(){return[this.$xcor(),this.$ycor()]},e.$position.returnType=function(e){return new Sk.builtin.tuple([new Sk.builtin.float_(e[0]),new Sk.builtin.float_(e[1])])},e.$towards=function(e,t){var n=getCoordinates(e,t);return(Math.PI+Math.atan2(this._y-n.y,this._x-n.x))*(this._fullCircle/Turtle.RADIANS)},e.$towards.co_varnames=[\"x\",\"y\"],e.$towards.minArgs=1,e.$towards.returnType=f.FLOAT,e.$distance=function(e,t){var n=getCoordinates(e,t),r=n.x-this._x,i=n.y-this._y;return Math.sqrt(r*r+i*i)},e.$distance.co_varnames=[\"x\",\"y\"],e.$distance.minArgs=1,e.$distance.returnType=f.FLOAT,e.$heading=function(){return Math.abs(this._angle)<1e-13?0:this._angle},e.$heading.returnType=f.FLOAT,e.$xcor=function(){return Math.abs(this._x)<1e-13?0:this._x},e.$xcor.returnType=f.FLOAT,e.$ycor=function(){return Math.abs(this._y)<1e-13?0:this._y},e.$ycor.returnType=f.FLOAT,e.$forward=e.$fd=function(e){return pushUndo(this),this.queueMoveBy(this._x,this._y,this._radians,e)},e.$forward.co_varnames=e.$fd.co_varnames=[\"distance\"],e.$undo=function(){!function popUndo(e){var t;if(e._bufferSize&&e._undoBuffer&&(t=e._undoBuffer.pop())){for(var n in t)\"image\"!==n&&\"fillBuffer\"!==n&&(e[\"_\"+n]=t[n]);e.addUpdate((function(){t.image&&(g.src=t.image),clearLayer(this.context(),!1,g),delete t.image}),!0,t)}}(this)},e.$undobufferentries=function(){return this._undoBuffer.length},e.$setundobuffer=function(e){this._bufferSize=\"number\"==typeof e?Math.min(Math.abs(e),1e3):0},e.$setundobuffer.co_varnames=[\"size\"],e.$backward=e.$back=e.$bk=function(e){return pushUndo(this),this.queueMoveBy(this._x,this._y,this._radians,-e)},e.$backward.co_varnames=e.$back.co_varnames=e.$bk.co_varnames=[\"distance\"],e.$goto_$rw$=e.$setpos=e.$setposition=function(e,t){var n=getCoordinates(e,t);return pushUndo(this),this.translate(this._x,this._y,n.x-this._x,n.y-this._y,!0)},e.$goto_$rw$.co_varnames=e.$setpos.co_varnames=e.$setposition.co_varnames=[\"x\",\"y\"],e.$goto_$rw$.minArgs=e.$setpos.minArgs=e.$setposition.minArgs=1,e.$setx=function(e){return this.translate(this._x,this._y,e-this._x,0,!0)},e.$setx.co_varnames=[\"x\"],e.$sety=function(e){return this.translate(this._x,this._y,0,e-this._y,!0)},e.$sety.co_varnames=[\"y\"],e.$home=function(){var e=this,t=this._angle;return pushUndo(this),e.translate(this._x,this._y,-this._x,-this._y,!0).then((function(n){return e.queueTurnTo(t,0)})).then((function(e){}))},e.$right=e.$rt=function(e){return pushUndo(this),this.rotate(this._angle,-e)},e.$right.co_varnames=e.$rt.co_varnames=[\"angle\"],e.$left=e.$lt=function(e){return pushUndo(this),this.rotate(this._angle,e)},e.$left.co_varnames=e.$lt.co_varnames=[\"angle\"],e.$setheading=e.$seth=function(e){return pushUndo(this),this.queueTurnTo(this._angle,e)},e.$setheading.co_varnames=e.$seth.co_varnames=[\"angle\"],e.$circle=function(e,t,n){var r,i,s,a,o,l,u,c,h,d=this,f=this._x,_=this._y,g=this._angle,p={},m=1/getScreen().lineScale,v=!0;for(pushUndo(this),void 0===t&&(t=d._fullCircle),void 0===n&&(i=Math.abs(t)/d._fullCircle,n=1+(Math.min(11+Math.abs(e*m)/6,59)*i|0)),a=.5*(s=t/n),o=2*e*Math.sin(s*Math.PI/d._fullCircle),e<0?(o=-o,s=-s,a=-a,r=g-t):r=g+t,h=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise,g+=a,l=0;l<n;l++)calculateHeading(d,g+s*l,p),u=Math.cos(p.radians)*o,c=Math.sin(p.radians)*o,h=h.then(circleRotate(d,p.angle,p.radians)).then(circleSegment(d,f,_,u,c,v)),f+=u,_+=c,v=!1;return h.then((function(){return calculateHeading(d,r,p),d._angle=p.angle,d._radians=p.radians,d.addUpdate(void 0,!0,p)}))},e.$circle.co_varnames=[\"radius\",\"extent\",\"steps\"],e.$circle.minArgs=1,e.$penup=e.$up=e.$pu=function(){return this._down=!1,this.addUpdate(void 0,!1,{down:!1})},e.$pendown=e.$down=e.$pd=function(){return this._down=!0,this.addUpdate(void 0,!1,{down:!0})},e.$isdown=function(){return this._down},e.$speed=function(e){if(\"undefined\"==typeof e)return this._speed;const t={fastest:0,fast:10,normal:6,slow:3,slowest:1};if(e in t&&(e=t[e]),\"number\"!=typeof e){if(\"string\"==typeof e){const e=Object.keys(t).join(\", \");throw new Sk.builtin.TypeError(\"speed string expected one of \"+e)}throw new Sk.builtin.TypeError(\"speed expected a string or number\")}return e=e>.5&&e<10.5?Sk.builtin.asnum$(Sk.builtin.round(Sk.builtin.assk$(e))):0,this._speed=e,this._computed_speed=2*e,this.addUpdate(void 0,!1,{speed:this._computed_speed})},e.$speed.minArgs=0,e.$speed.co_varnames=[\"speed\"],e.$pencolor=function(e,t,n,r){return void 0!==e?(this._color=createColor(this._colorMode,e,t,n,r),this.addUpdate(void 0,this._shown,{color:this._color})):hexToRGB(this._color)},e.$pencolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$pencolor.minArgs=0,e.$pencolor.returnType=f.COLOR,e.$fillcolor=function(e,t,n,r){return void 0!==e?(this._fill=createColor(this._colorMode,e,t,n,r),this.addUpdate(void 0,this._shown,{fill:this._fill})):hexToRGB(this._fill)},e.$fillcolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$fillcolor.minArgs=0,e.$fillcolor.returnType=f.COLOR,e.$color=function(e,t,n,r){return void 0!==e?(void 0===t||void 0!==n?(this._color=createColor(this._colorMode,e,t,n,r),this._fill=this._color):(this._color=createColor(this._colorMode,e),this._fill=createColor(this._colorMode,t)),this.addUpdate(void 0,this._shown,{color:this._color,fill:this._fill})):[this.$pencolor(),this.$fillcolor()]},e.$color.minArgs=0,e.$color.co_varnames=[\"color\",\"fill\",\"b\",\"a\"],e.$color.returnType=function(e){return new Sk.builtin.tuple([f.COLOR(e[0]),f.COLOR(e[1])])},e.$fill=function(e){if(void 0!==e){if((e=!!e)===this._filling)return;return this._filling=e,e?(pushUndo(this),this.addUpdate(void 0,!1,{filling:!0,fillBuffer:[{x:this._x,y:this._y}]})):(pushUndo(this),this.addUpdate((function(){this.fillBuffer.push(this),drawFill.call(this)}),!0,{filling:!1,fillBuffer:void 0}))}return this._filling},e.$fill.co_varnames=[\"flag\"],e.$fill.minArgs=0,e.$begin_fill=function(){return this.$fill(!0)},e.$end_fill=function(){return this.$fill(!1)},e.$stamp=function(){return pushUndo(this),this.addUpdate((function(){drawTurtle(this,this.context())}),!0)},e.$dot=function(e,t,n,r,i){return pushUndo(this),e=\"number\"==typeof(e=Sk.builtin.asnum$(e))?Math.max(1,0|Math.abs(e)):Math.max(this._size+4,2*this._size),t=void 0!==t?createColor(this._colorMode,t,n,r,i):this._color,this.addUpdate(drawDot,!0,void 0,e,t)},e.$dot.co_varnames=[\"size\",\"color\",\"g\",\"b\",\"a\"],e.$write=function(e,t,n,r){var i,s,a,o,l,u=this;return pushUndo(this),e=String(e),r&&r.constructor===Array&&(s=\"string\"==typeof r[0]?r[0]:\"Arial\",a=String(r[1]||\"12pt\"),o=\"string\"==typeof r[2]?r[2]:\"normal\",/^\\d+$/.test(a)&&(a+=\"pt\"),r=[o,a,s].join(\" \")),n||(n=\"left\"),i=this.addUpdate(drawText,!0,void 0,e,n,r),!t||\"left\"!==n&&\"center\"!==n||(l=function measureText(e,t){return t&&(p.font=t),p.measureText(e).width}(e,r),\"center\"===n&&(l/=2),i=i.then((function(){var e=u.getState();return u.translate(e.x,e.y,l,0,!0)}))),i},e.$write.co_varnames=[\"message\",\"move\",\"align\",\"font\"],e.$write.minArgs=1,e.$pensize=e.$width=function(e){return void 0!==e?(this._size=e,this.addUpdate(void 0,this._shown,{size:e})):this._size},e.$pensize.minArgs=e.$width.minArgs=0,e.$pensize.co_varnames=e.$width.co_varnames=[\"width\"],e.$showturtle=e.$st=function(){return this._shown=!0,this.addUpdate(void 0,!0,{shown:!0})},e.$hideturtle=e.$ht=function(){return this._shown=!1,this.addUpdate(void 0,!0,{shown:!1})},e.$isvisible=function(){return this._shown},e.$shape=function(e){return e&&d[e]?(this._shape=e,this.addUpdate(void 0,this._shown,{shape:e})):this._shape},e.$shape.minArgs=0,e.$shape.co_varnames=[\"name\"],e.$window_width=function(){return this._screen.$window_width()},e.$window_height=function(){return this._screen.$window_height()},e.$tracer=function(e,t){return this._screen.$tracer(e,t)},e.$tracer.minArgs=0,e.$tracer.co_varnames=[\"n\",\"delay\"],e.$update=function(){return this._screen.$update()},e.$delay=function(e){return this._screen.$delay(e)},e.$delay.minArgs=0,e.$delay.co_varnames=[\"delay\"],e.$reset=function(){return this.reset(),this.$clear()},e.$mainloop=e.$done=function(){return this._screen.$mainloop()},e.$clear=function(){return this.addUpdate((function(){clearLayer(this.context())}),!0)},e.$dot.minArgs=0,e.$onclick=function(e,t,n){this.getManager(\"mousedown\").addHandler(e,n)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$onrelease=function(e,t,n){this.getManager(\"mouseup\").addHandler(e,n)},e.$onrelease.minArgs=1,e.$onrelease.co_varnames=[\"method\",\"btn\",\"add\"],e.$ondrag=function(e,t,n){this.getManager(\"mousemove\").addHandler(e,n)},e.$ondrag.minArgs=1,e.$ondrag.co_varnames=[\"method\",\"btn\",\"add\"],e.$getscreen=function(){return Sk.misceval.callsimArray(u.Screen)},e.$getscreen.isSk=!0,e.$clone=function(){var e=Sk.misceval.callsimOrSuspendArray(u.Turtle);return e.instance._x=this._x,e.instance._y=this._y,e.instance._angle=this._angle,e.instance._radians=this._radians,e.instance._shape=this._shape,e.instance._color=this._color,e.instance._fill=this._fill,e.instance._filling=this._filling,e.instance._size=this._size,e.instance._computed_speed=this._computed_speed,e.instance._down=this._down,e.instance._shown=this._shown,e.instance._colorMode=this._colorMode,e.instance._isRadians=this._isRadians,e.instance._fullCircle=this._fullCircle,e.instance._bufferSize=this._bufferSize,e.instance._undoBuffer=this._undoBuffer,e._clonedFrom=this,e},e.$clone.returnType=function(e){return e},e.$getturtle=e.$getpen=function(){return this.skInstance},e.$getturtle.isSk=!0}(Turtle.prototype),function(e){e.spriteLayer=function(){return this._sprites||(this._sprites=createLayer(3))},e.bgLayer=function(){return this._background||(this._background=createLayer(1))},e.hitTestLayer=function(){return this._hitTest||(this._hitTest=createLayer(0,!0))},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new EventManager(e,this)),this._managers[e]},e.reset=function(){var e;for(e in this._keyListeners=void 0,this._keyLogger)window.clearInterval(this._keyLogger[e]),window.clearTimeout(this._keyLogger[e]),delete this._keyLogger[e];for(e in this._keyDownListener&&(getTarget().removeEventListener(\"keydown\",this._keyDownListener),this._keyDownListener=void 0),this._keyUpListener&&(getTarget().removeEventListener(\"keyup\",this._keyUpListener),this._keyUpListener=void 0),this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),this._managers)this._managers[e].reset();this._mode=\"standard\",removeLayer(this._sprites),this._sprites=void 0,removeLayer(this._background),this._background=void 0},e.setUpWorld=function(e,t,n,r){var i=this;i.llx=e,i.lly=t,i.urx=n,i.ury=r,i.xScale=(n-e)/getWidth(),i.yScale=-1*(r-t)/getHeight(),i.lineScale=Math.min(Math.abs(i.xScale),Math.abs(i.yScale))},e.$setup=function(e,t,n,r){return isNaN(parseFloat(e))&&(e=getWidth()),isNaN(parseFloat(t))&&(t=getHeight()),e<=1&&(e=getWidth()*e),t<=1&&(t=getHeight()*t),this._width=e,this._height=t,this._xOffset=void 0===n||isNaN(parseInt(n))?0:parseInt(n),this._yOffset=void 0===r||isNaN(parseInt(r))?0:parseInt(r),\"world\"===this._mode?this._setworldcoordinates(this.llx,this.lly,this.urx,this.ury):this._setworldcoordinates(-e/2,-t/2,e/2,t/2)},e.$setup.minArgs=0,e.$setup.co_varnames=[\"width\",\"height\",\"startx\",\"starty\"],e.$register_shape=e.$addshape=function(e,t){if(!t)return getAsset(e).then((function(t){d[e]=t}));d[e]=t},e.$register_shape.minArgs=1,e.$register_shape.co_varnames=[\"name\",\"shape\"],e.$getshapes=function(){return Object.keys(d)},e.$tracer=function(e,t){return void 0!==e||void 0!==t?(\"number\"==typeof t&&(this._delay=t,getFrameManager().refreshInterval(t)),\"number\"==typeof e?(this._frames=e,getFrameManager().frameBuffer(e)):void 0):this._frames},e.$tracer.co_varnames=[\"frames\",\"delay\"],e.$tracer.minArgs=0,e.$delay=function(e){return void 0!==e?this.$tracer(void 0,e):void 0===this._delay?h:this._delay},e.$delay.co_varnames=[\"delay\"],e._setworldcoordinates=function(e,t,n,r){return getFrameManager().turtles(),this.setUpWorld(e,t,n,r),this._sprites&&applyWorld(this,this._sprites),this._background&&applyWorld(this,this._background),this.$clear()},e.$setworldcoordinates=function(e,t,n,r){return this._mode=\"world\",this._setworldcoordinates(e,t,n,r)},e.$setworldcoordinates.co_varnames=[\"llx\",\"lly\",\"urx\",\"ury\"],e.minArgs=4,e.$clear=e.$clearscreen=function(){return this.reset(),this.$reset()},e.$update=function(){return getFrameManager().update()},e.$reset=e.$resetscreen=function(){var e=this,t=getFrameManager().turtles();return getFrameManager().addFrame((function(){applyWorld(e,e._sprites),applyWorld(e,e._background);for(var n=0;n<t.length;n++)t[n].reset(),applyWorld(e,t[n]._paper)}),!0)},e.$window_width=function(){return getWidth()},e.$window_height=function(){return getHeight()},e.$delay.minArgs=0,e.$turtles=function(){return getFrameManager().turtles()},e.$turtles.returnType=f.TURTLE_LIST,e.$bgpic=function(e){var t;return e?(t=this,getAsset(e).then((function(e){clearLayer(t.bgLayer(),void 0,e)}))):this._bgpic},e.$bgpic.minArgs=0,e.$bgpic.co_varnames=[\"name\"],e.$bgcolor=function(e,t,n,r){return void 0!==e?(this._bgcolor=createColor(this._colorMode,e,t,n,r),void clearLayer(this.bgLayer(),this._bgcolor)):hexToRGB(this._bgcolor)},e.$bgcolor.minArgs=0,e.$bgcolor.co_varnames=[\"color\",\"g\",\"b\",\"a\"],e.$bgcolor.returnType=f.COLOR,e.$colormode=function(e){return void 0!==e?(this._colorMode=255===e?255:1,this.addUpdate(void 0,this._shown,{colorMode:this._colorMode})):this._colorMode},e.$colormode.minArgs=0,e.$colormode.co_varnames=[\"cmode\"],e.$colormode.returnType=function(e){return 255===e?new Sk.builtin.int_(255):new Sk.builtin.float_(1)},e.$mainloop=e.$done=function(){},e.$bye=function(){return Sk.TurtleGraphics.reset()},e.$exitonclick=function(){return this._exitOnClick=!0,this.getManager(\"mousedown\").addHandler((function(){resetTurtle()}),!1)},e.$onclick=function(e,t,n){this._exitOnClick||this.getManager(\"mousedown\").addHandler(e,n)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"];var t={8:/^back(space)?$/i,9:/^tab$/i,13:/^(enter|return)$/i,16:/^shift$/i,17:/^(ctrl|control)$/i,18:/^alt$/i,27:/^esc(ape)?$/i,32:/^space$/i,33:/^page[\\s\\-]?up$/i,34:/^page[\\s\\-]?down$/i,35:/^end$/i,36:/^home$/i,37:/^left([\\s\\-]?arrow)?$/i,38:/^up([\\s\\-]?arrow)?$/i,39:/^right([\\s\\-]?arrow)?$/i,40:/^down([\\s\\-]?arrow)?$/i,45:/^insert$/i,46:/^del(ete)?$/i};e._createKeyRepeater=function(e,t){var n=this;n._keyLogger[t]=window.setTimeout((function(){n._keyListeners[e](),n._keyLogger[t]=window.setInterval((function(){n._keyListeners[e]()}),50)}),333)},e._createKeyDownListener=function(){var e=this;this._keyDownListener||(this._keyDownListener=function(n){if(focusTurtle()){var r,i,s=n.charCode||n.keyCode,a=String.fromCharCode(s).toLowerCase();if(!e._keyLogger[s])for(r in e._keyListeners)if(i=r.length>1&&t[s]&&t[s].test(r),r===a||i){e._keyListeners[r](),e._createKeyRepeater(r,s),n.preventDefault();break}}},getTarget().addEventListener(\"keydown\",this._keyDownListener))},e._createKeyUpListener=function(){var e=this;this._keyUpListener||(this._keyUpListener=function(t){var n=e._keyLogger[t.charCode||t.keyCode];void 0!==n&&(t.preventDefault(),window.clearInterval(n),window.clearTimeout(n),delete e._keyLogger[t.charCode||t.keyCode])},getTarget().addEventListener(\"keyup\",this._keyUpListener))},e.$title=function(e){document.title=e},e.$title.minArgs=1,e.$title.co_varnames=[\"title\"],e.$listen=function(){this._createKeyUpListener(),this._createKeyDownListener()},e.$onkey=function(e,t){if(\"function\"==typeof t){var n=e;e=t,t=n}t=String(t).toLowerCase(),e&&\"function\"==typeof e?(this._keyListeners||(this._keyListeners={}),this._keyListeners[t]=e):delete this._keyListeners[t]},e.$onkey.minArgs=2,e.$onkey.co_varnames=[\"method\",\"keyValue\"],e.$onscreenclick=function(e,t,n){this.getManager(\"mousedown\").addHandler(e,n)},e.$onscreenclick.minArgs=1,e.$onscreenclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$ontimer=function(e,t){this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),e&&\"number\"==typeof t&&(this._timer=window.setTimeout(e,Math.max(0,0|t)))},e.$ontimer.minArgs=0,e.$ontimer.co_varnames=[\"method\",\"interval\"]}(Screen.prototype);var g=new Image;function removeLayer(e){e&&e.canvas&&e.canvas.parentNode&&e.canvas.parentNode.removeChild(e.canvas)}function clearLayer(e,t,n){e&&(e.save(),e.setTransform(1,0,0,1,0,0),t?(e.fillStyle=t,e.fillRect(0,0,e.canvas.width,e.canvas.height)):e.clearRect(0,0,e.canvas.width,e.canvas.height),n&&e.drawImage(n,0,0),e.restore())}function drawTurtle(e,t){var n,r,i,s=d[e.shape],a=getScreen(),o=(getWidth(),getHeight(),a.xScale),l=a.yScale;if(t){if(n=Math.cos(e.radians)/o,r=Math.sin(e.radians)/l,i=Math.atan2(r,n)-Math.PI/2,t.save(),t.translate(e.x,e.y),t.scale(o,l),s.nodeName){var u=s.naturalWidth,c=s.naturalHeight;t.drawImage(s,0,0,u,c,-u/2,-c/2,u,c)}else{t.rotate(i),t.beginPath(),t.lineWidth=1,t.strokeStyle=e.color,t.fillStyle=e.fill,t.moveTo(-s[0][0],s[0][1]);for(var h=1;h<s.length;h++)t.lineTo(-s[h][0],s[h][1]);t.closePath(),t.fill(),t.stroke()}t.restore()}}function drawDot(e,t){var n=this.context(),r=getScreen(),i=r.xScale,s=r.yScale;n&&(n.beginPath(),n.moveTo(this.x,this.y),e*=Math.min(Math.abs(i),Math.abs(s)),n.arc(this.x,this.y,e/2,0,Turtle.RADIANS),n.closePath(),n.fillStyle=t||this.color,n.fill())}var p=document.createElement(\"canvas\").getContext(\"2d\");function drawText(e,t,n){var r=this.context();r&&(r.save(),n&&(r.font=n),t&&t.match(/^(left|right|center)$/)&&(r.textAlign=t),r.scale(1,-1),r.fillStyle=this.fill,r.fillText(e,this.x,-this.y),r.restore())}function drawLine(e,t,n){var r=this.context();r&&(t&&(r.beginPath(),r.moveTo(this.x,this.y)),r.lineWidth=this.size*getScreen().lineScale,r.strokeStyle=this.color,r.lineTo(e.x,e.y),r.stroke())}function drawFill(){var e,t=this.context(),n=this.fillBuffer;if(t&&n&&n.length){for(t.save(),t.beginPath(),t.moveTo(n[0].x,n[0].y),e=1;e<n.length;e++)t.lineTo(n[e].x,n[e].y);for(t.closePath(),t.fillStyle=this.fill,t.fill(),e=1;e<n.length;e++)n[e].stroke&&(t.beginPath(),t.moveTo(n[e-1].x,n[e-1].y),t.lineWidth=n[e].size*getScreen().lineScale,t.strokeStyle=n[e].color,t.lineTo(n[e].x,n[e].y),t.stroke());t.restore()}}function partialTranslate(e,t,n,r,i){return function(){return e.addUpdate((function(e){this.down&&drawLine.call(this,e,r)}),i,{x:t,y:n},r)}}function partialRotate(e,t,n,r){return function(){return e.addUpdate(void 0,r,{angle:t,radians:n})}}function getCoordinates(e,t){return void 0===t&&(t=e&&(e.y||e._y||e[1])||0,e=e&&(e.x||e._x||e[0])||0),{x:e,y:t}}function hexToRGB(e){var t,n,r;return(t=/^rgba?\\((\\d+),(\\d+),(\\d+)(?:,([.\\d]+))?\\)$/.exec(e))?(r=[parseInt(t[1]),parseInt(t[2]),parseInt(t[3])],t[4]&&r.push(parseFloat(t[4]))):/^#?[a-f\\d]{3}|[a-f\\d]{6}$/i.exec(e)?(4===e.length&&(e=e.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,(function(e,t,n,r){return t+t+n+n+r+r}))),n=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e),r=[parseInt(n[1],16),parseInt(n[2],16),parseInt(n[3],16)]):r=e,r}function createColor(e,t,n,r,i){var s;if(void 0!==n&&(t=[t,n,r,i]),t.constructor===Array&&t.length){if(255===e)for(s=0;s<3;s++){if(\"number\"!=typeof t[s])throw new Sk.builtin.ValueError(\"bad color sequence\");t[s]=Math.max(0,Math.min(255,parseInt(t[s])))}else for(s=0;s<3;s++){if(\"number\"!=typeof t[s])throw new Sk.builtin.ValueError(\"bad color sequence\");if(!(t[s]<=1))throw new Sk.builtin.ValueError(\"bad color sequence\");t[s]=Math.max(0,Math.min(255,parseInt(255*t[s])))}\"number\"==typeof t[s]?(t[3]=Math.max(0,Math.min(1,t[s])),t=\"rgba(\"+t.join(\",\")+\")\"):t=\"rgb(\"+t.slice(0,3).join(\",\")+\")\"}else{if(\"string\"!=typeof t||t.match(/\\s*url\\s*\\(/i))return\"black\";t=t.replace(/\\s+/g,\"\")}return t}function calculateHeading(e,t,n){var r=e._angle||0,i=e._radians||0;return n||(n={}),\"number\"==typeof t&&(e._isRadians?r=i=t%Turtle.RADIANS:e._fullCircle?i=(r=t%e._fullCircle)/e._fullCircle*Turtle.RADIANS:r=i=0,r<0&&(r+=e._fullCircle,i+=Turtle.RADIANS)),n.angle=r,n.radians=i,n}function pythonToJavascriptFunction(e,t){return function(){var n=Array.prototype.slice.call(arguments).map((function(e){return Sk.ffi.remapToPy(e)}));return\"undefined\"!=typeof t&&n.unshift(t),Sk.misceval.applyAsync(void 0,e,void 0,void 0,void 0,n).catch(Sk.uncaughtException)}}function addModuleMethod(e,t,n,r){var i,s=n.replace(/^\\$/,\"\"),a=s.replace(/_\\$[a-z]+\\$$/i,\"\"),o=e.prototype[n].length,l=e.prototype[n].minArgs,u=e.prototype[n].co_varnames||[],c=e.prototype[n].returnType,h=e.prototype[n].isSk;void 0===l&&(l=o),i=function(){var e,t,i,s,u,d=Array.prototype.slice.call(arguments,0),f=r?r():d.shift().instance;if(d.length<l||d.length>o)throw u=l===o?\"exactly \"+o:\"between \"+l+\" and \"+o,new Sk.builtin.TypeError(a+\"() takes \"+u+\" positional argument(s) (\"+d.length+\" given)\");for(e=d.length;--e>=0;)void 0!==d[e]&&(d[e]instanceof Sk.builtin.func?d[e]=pythonToJavascriptFunction(d[e]):d[e]instanceof Sk.builtin.method?d[e]=pythonToJavascriptFunction(d[e].im_func,d[e].im_self):d[e]&&d[e].$d instanceof Sk.builtin.dict&&d[e].instance?d[e]=d[e].instance:d[e]=Sk.ffi.remapToJs(d[e]));var _=d.slice(0);for(d=[],e=_.length;e>=0;--e)null!==_[e]&&(d[e]=_[e]);try{t=f[n].apply(f,d)}catch(g){throw window&&window.console&&(window.console.log(\"wrapped method failed\"),window.console.log(g.stack)),g}return t instanceof InstantPromise&&(t=t.lastResult),t instanceof Promise?(t=t.catch((function(e){throw window&&window.console&&(window.console.log(\"promise failed\"),window.console.log(e.stack)),e})),(i=new Sk.misceval.Suspension).resume=function(){return void 0===s?Sk.builtin.none.none$:Sk.ffi.remapToPy(s)},i.data={type:\"Sk.promise\",promise:t.then((function(e){return s=e,e}))},i):void 0===t?Sk.builtin.none.none$:h?t:\"function\"==typeof c?c(t):Sk.ffi.remapToPy(t)},i.co_name=new Sk.builtin.str(a),i.co_varnames=u.slice(),i.$defaults=[];for(var d=l;d<u.length;d++)i.$defaults.push(Sk.builtin.none.none$);r||i.co_varnames.unshift(\"self\"),t[s]=new Sk.builtin.func(i)}function initTurtle(e,t){Sk.builtin.pyCheckArgs(\"__init__\",arguments,2,3,!1,!1),e.instance=new Turtle(t),e.instance.skInstance=e}for(var m in initTurtle.co_varnames=[\"self\",\"shape\"],initTurtle.co_name=new Sk.builtin.str(\"Turtle\"),initTurtle.co_argcount=2,initTurtle.$defaults=[Sk.builtin.none.none$,new Sk.builtin.str(\"classic\")],Turtle.prototype)/^\\$[a-z_]+/.test(m)&&addModuleMethod(Turtle,u,m,ensureAnonymous);function focusTurtle(e){return void 0!==e&&((c=!!e)?getTarget().focus():getTarget().blur()),c}function resetTurtle(){for(cancelAnimationFrame(),getScreen().reset(),getFrameManager().reset();e.firstChild;)e.removeChild(e.firstChild);a&&a.reset(),r=void 0,s=void 0,a=void 0}return addModuleMethod(Screen,u,\"$mainloop\",getScreen),addModuleMethod(Screen,u,\"$done\",getScreen),addModuleMethod(Screen,u,\"$bye\",getScreen),addModuleMethod(Screen,u,\"$tracer\",getScreen),addModuleMethod(Screen,u,\"$update\",getScreen),addModuleMethod(Screen,u,\"$delay\",getScreen),addModuleMethod(Screen,u,\"$window_width\",getScreen),addModuleMethod(Screen,u,\"$window_height\",getScreen),addModuleMethod(Screen,u,\"$title\",getScreen),addModuleMethod(Screen,u,\"$onkey\",getScreen),addModuleMethod(Screen,u,\"$listen\",getScreen),addModuleMethod(Screen,u,\"$register_shape\",getScreen),addModuleMethod(Screen,u,\"$clearscreen\",getScreen),addModuleMethod(Screen,u,\"$bgcolor\",getScreen),addModuleMethod(Screen,u,\"$bgpic\",getScreen),addModuleMethod(Screen,u,\"$setworldcoordinates\",getScreen),addModuleMethod(Screen,u,\"$ontimer\",getScreen),addModuleMethod(Screen,u,\"$onscreenclick\",getScreen),addModuleMethod(Screen,u,\"$exitonclick\",getScreen),addModuleMethod(Screen,u,\"$resetscreen\",getScreen),addModuleMethod(Screen,u,\"$setup\",getScreen),addModuleMethod(Screen,u,\"$turtles\",getScreen),u.Turtle=Sk.misceval.buildClass(u,(function TurtleWrapper(e,t){for(var n in t.__init__=new Sk.builtin.func(initTurtle),Turtle.prototype)/^\\$[a-z_]+/.test(n)&&addModuleMethod(Turtle,t,n)}),\"Turtle\",[]),u.Screen=Sk.misceval.buildClass(u,(function ScreenWrapper(e,t){for(var n in t.__init__=new Sk.builtin.func((function(e){e.instance=getScreen()})),Screen.prototype)/^\\$[a-z_]+/.test(n)&&addModuleMethod(Screen,t,n)}),\"Screen\",[]),{skModule:u,reset:resetTurtle,stop:function stopTurtle(){cancelAnimationFrame(),a&&a.reset(),r=void 0,s=void 0,a=void 0},focus:focusTurtle,Turtle:Turtle,Screen:Screen}}(t),Sk.TurtleGraphics.module=t.turtleInstance.skModule,Sk.TurtleGraphics.reset=t.turtleInstance.reset,Sk.TurtleGraphics.stop=t.turtleInstance.stop,Sk.TurtleGraphics.focus=t.turtleInstance.focus,Sk.TurtleGraphics.raw={Turtle:t.turtleInstance.Turtle,Screen:t.turtleInstance.Screen},t.turtleInstance.skModule};","src/lib/urllib/__init__.js":"var $builtinmodule=function(n){return{}};","src/lib/urllib/request/__init__.js":"var $builtinmodule=function(n){var e={};e.Response=Sk.misceval.buildClass(e,(function(n,e){e.__init__=new Sk.builtin.func((function(n,e){n.data$=e.responseText,n.lineList=n.data$.split(\"\\n\"),n.lineList=n.lineList.slice(0,-1);for(var i=0;i<n.lineList.length;i++)n.lineList[i]=n.lineList[i]+\"\\n\";n.currentLine=0,n.pos$=0})),e.__str__=new Sk.builtin.func((function(n){return Sk.ffi.remapToPy(\"<Response>\")})),e.__iter__=new Sk.builtin.func((function(n){var e=n.lineList;return Sk.builtin.makeGenerator((function(){if(!(this.$index>=this.$lines.length))return new Sk.builtin.str(this.$lines[this.$index++])}),{$obj:n,$index:0,$lines:e})})),e.read=new Sk.builtin.func((function(n,e){if(n.closed)throw new Sk.builtin.ValueError(\"I/O operation on closed file\");var i=n.data$.length;void 0===e&&(e=i);var t=new Sk.builtin.str(n.data$.substr(n.pos$,e));return n.pos$+=e,n.pos$>=i&&(n.pos$=i),t})),e.readline=new Sk.builtin.func((function(n,e){var i=\"\";return n.currentLine<n.lineList.length&&(i=n.lineList[n.currentLine],n.currentLine++),new Sk.builtin.str(i)})),e.readlines=new Sk.builtin.func((function(n,e){for(var i=[],t=n.currentLine;t<n.lineList.length;t++)i.push(new Sk.builtin.str(n.lineList[t]));return new Sk.builtin.list(i)}))}),\"Response\",[]);return e.urlopen=new Sk.builtin.func((function(n,i,t){var r;r=function(n){var e;if(!Sk.jsonpSites)return!1;for(e=0;e<Sk.jsonpSites.length;e++)if(n.startsWith(Sk.jsonpSites[e]))return!0;return!1}(n.v)?new Promise((function(i,t){var r=document.createElement(\"script\");r.src=n.v+\"&callback=Sk.jsonpcallback\",r.onerror=function(n){t(\"An error occured getting the data\")},Sk.jsonpcallback=function(n){var t={responseText:JSON.stringify(n)};i(Sk.misceval.callsimArray(e.Response,[t]))};try{document.body.appendChild(r)}catch(s){console.log(\"caught error in urlopen\"+s)}})):new Promise((function(t,r){var s=new XMLHttpRequest;s.addEventListener(\"loadend\",(function(n){t(Sk.misceval.callsimArray(e.Response,[s]))})),i?(s.open(\"POST\",n.v),s.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"),s.send(i.v)):(s.open(\"GET\",n.v),s.send(null))}));var s,u=new Sk.misceval.Suspension;return u.resume=function(){return s},u.data={type:\"Sk.promise\",promise:r.then((function(n){return s=n,n}),(function(n){return s=\"\",n}))},u})),e};","src/lib/uuid.js":"function $builtinmodule(){const{builtin:{bytes:e,str:t,int_:n,TypeError:i,ValueError:s,NotImplementedError:r,none:{none$:o},NotImplemented:{NotImplemented$:l}},abstr:{buildNativeClass:a,checkArgsLen:m,copyKeywordsToNamedArgs:$,lookupSpecial:u,setUpModuleMethods:h},misceval:{callsimArray:d,objectRepr:c,richCompareBool:g}}=Sk,p={__name__:new t(\"uuid\"),RESERVED_NCS:o,RFC_4122:o,RESERVED_FUTURE:o};let f=Sk.global.crypto;\"undefined\"==typeof f&&(f={getRandomValues(e){let t=e.length;for(;t--;)e[t]=Math.floor(256*Math.random());return e}});const w=n.tp$getattr(new t(\"from_bytes\")),b=n.tp$getattr(new t(\"to_bytes\")),y=new n(1).nb$lshift(new n(128)),_=new n(0),I=new n(4),U=new n(16),v=new t(\"big\"),E=new t(\"%032x\"),S=/-/g;function notImplemented(){throw new r(\"Not yet implemneted in Skulpt\")}function switchBytesBytesLe(e){const t=new Uint8Array(e);return t[0]=e[3],t[1]=e[2],t[2]=e[1],t[3]=e[0],t[4]=e[5],t[5]=e[4],t[6]=e[7],t[7]=e[6],t}const R=p.UUID=a(\"uuid.UUID\",{constructor:function(){},slots:{tp$init(l,a){m(\"UUID\",l,0,6);let[u,h,c,p,f,b,I]=$(\"UUID\",[\"hex\",\"bytes\",\"bytes_le\",\"fields\",\"int\",\"version\",\"is_safe\"],l,a,[o,o,o,o,o,o,o]);if(4!==[u,h,c,p,f].filter((e=>e===o)).length)throw new i(\"one of the hex, bytes, bytes_le, fields, or int arguments must be given\");if(u!==o){u=u.toString().replace(\"urn:\",\"\").replace(\"uuid:\",\"\");let e=0,i=u.length-1;for(;\"{}\".indexOf(u[e])>=0;)e++;for(;\"{}\".indexOf(u[i])>=0;)i--;if(u=u.slice(e,i+1),u=u.replace(S,\"\"),32!==u.length)throw new s(\"badly formed hexadecimal UUID string\");f=d(n,[new t(u),U])}if(c!==o){if(!(c instanceof e))throw new i(\"bytes_le should be a bytes instance\");if(c=c.valueOf(),16!==c.length)throw new s(\"bytes_le is not a 16-char string\");h=switchBytesBytesLe(c),h=new e(h)}if(h!==o){if(!(h instanceof e))throw new i(\"bytes_le should be a bytes instance\");if(16!==h.valueOf().length)throw new s(\"bytes is not a 16-char string\");f=d(w,[h],[\"byteorder\",v])}if(p!==o)throw new r(\"fields argument is not yet supported\");if(f!==o&&(g(f,_,\"Lt\")||((e,t)=>g(e,t,\"GtE\"))(f,y)))throw new s(\"int is out of range (need a 128-bit value)\");this.$int=f,this.$isSafe=I},tp$str(){const e=E.nb$remainder(this.$int).toString();return new t(`${e.slice(0,8)}-${e.slice(8,12)}-${e.slice(12,16)}-${e.slice(16,20)}-${e.slice(20)}`)},$r(){const e=u(this.ob$type,t.$name),n=c(this.tp$str());return new t(`${e}(${n})`)},tp$hash(){return this.$int.tp$hash()},tp$richcompare(e,t){return e instanceof R?this.$int.tp$richcompare(e.$int,t):l},tp$as_number:!0,nb$int(){return this.$int}},getsets:{int:{$get(){return this.$int}},is_safe:{$get(){return this.$isSafe}},bytes:{$get(){return d(b,[this.$int,U,v])}},bytes_le:{$get(){const n=this.tp$getattr(new t(\"bytes\")).valueOf();return new e(switchBytesBytesLe(n))}},fields:{$get:()=>notImplemented()},time_low:{$get:()=>notImplemented()},time_mid:{$get:()=>notImplemented()},time_hi_version:{$get:()=>notImplemented()},clock_seq_hi_variant:{$get:()=>notImplemented()},clock_seq_low:{$get:()=>notImplemented()},time:{$get:()=>notImplemented()},clock_seq:{$get:()=>notImplemented()},node:{$get:()=>notImplemented()},hex:{$get(){return E.nb$remainder(this.$int)}},urn:{$get(){return new t(`urn:uuid:${this}`)}},variant:{$get:()=>notImplemented()},version:{$get:()=>notImplemented()}}});return h(\"uuid\",p,{uuid1:{$meth(){notImplemented()},$flags:{FastCall:!0}},uuid2:{$meth(){notImplemented()},$flags:{FastCall:!0}},uuid3:{$meth(){notImplemented()},$flags:{FastCall:!0}},uuid4:{$meth(){const t=new e(f.getRandomValues(new Uint8Array(16)));return d(R,[],[\"bytes\",t,\"version\",I])},$flags:{NoArgs:!0}},uuid5:{$meth(){notImplemented()},$flags:{FastCall:!0}}}),p}","src/lib/webbrowser.js":"var $builtinmodule=function(n){var e={},t=\"undefined\"!=typeof window&&\"undefined\"!=typeof window.navigator;function open_tab(n){return Sk.builtin.pyCheckType(\"url\",\"string\",Sk.builtin.checkString(n)),t?(n=n.$jsstr(),window.open(n,\"_blank\"),Sk.builtin.bool.true$):Sk.builtin.bool.false$}return e.__name__=new Sk.builtin.str(\"webbrowser\"),e.open=new Sk.builtin.func((function open(n){return Sk.builtin.pyCheckArgsLen(\"open\",arguments.length+1,1,3),open_tab(n)})),e.open_new=new Sk.builtin.func((function open_new(n){return Sk.builtin.pyCheckArgsLen(\"open_new\",arguments.length,1,1),open_tab(n)})),e.open_new_tab=new Sk.builtin.func((function open_new_tab(n){return Sk.builtin.pyCheckArgsLen(\"open_new_tab\",arguments.length,1,1),open_tab(n)})),e.DefaultBrowser=Sk.misceval.buildClass(e,(function dflbrowser(n,e){e.__init__=new Sk.builtin.func((function __init__(n){return Sk.builtin.none.none$})),e.open=new Sk.builtin.func((function open(n,e){return Sk.builtin.pyCheckArgsLen(\"open\",arguments.length,2,4),open_tab(e)})),e.open_new=new Sk.builtin.func((function open_new(n,e){return Sk.builtin.pyCheckArgsLen(\"open_new\",arguments.length,2,2),open_tab(e)})),e.open_new_tab=new Sk.builtin.func((function open_new_tab(n,e){return Sk.builtin.pyCheckArgsLen(\"open_new_tab\",arguments.length,2,2),open_tab(e)}))}),\"DefaultBrowser\",[]),e.get=new Sk.builtin.func((function get(){return Sk.builtin.pyCheckArgsLen(\"get\",arguments.length,0,1),Sk.misceval.callsimArray(e.DefaultBrowser,[])})),e};","src/lib/webgl/__init__.js":"var $builtinmodule=function(n){var t={__name__:new Sk.builtin.str(\"webgl\")},makeFailHTML=function(n){return'<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr><td align=\"center\"><div style=\"display: table-cell; vertical-align: middle;\"><div style=\"\">'+n+\"</div></div></td></tr></table>\"},e='This page requires a browser that supports WebGL.<br/><a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';return t.Context=Sk.misceval.buildClass(t,(function(n,t){t.__init__=new Sk.builtin.func((function(n,t){var i=document.getElementById(t.v),r=function(n,t){var i=document.getElementById(n);if(t||(t=i.getElementsByTagName(\"canvas\")[0]),t){var r=function(n){for(var t=[\"webgl\",\"experimental-webgl\",\"webkit-3d\",\"moz-webgl\"],e=null,i=0;i<t.length;++i){try{e=n.getContext(t[i])}catch(r){}if(e)break}if(e){function returnFalse(){return!1}n.onselectstart=returnFalse,n.onmousedown=returnFalse}return e}(t);if(!r){var u=navigator.userAgent.match(/(\\w+\\/.*? )/g),a={};try{for(var o=0;o<u.length;++o){for(var l=u[o].match(/(\\w+)/g),c=[],f=1;f<l.length;++f)c.push(parseInt(l[f]));a[l[0]]=c}}catch(s){}a.Chrome&&(a.Chrome[0]>7||7==a.Chrome[0]&&a.Chrome[1]>0||7==a.Chrome[0]&&0==a.Chrome[1]&&a.Chrome[2]>=521)?i.innerHTML=makeFailHTML('It doesn\\'t appear your computer can support WebGL.<br/><a href=\"http://get.webgl.org\">Click here for more information.</a>'):i.innerHTML=makeFailHTML(e)}return r}i.innerHTML=makeFailHTML(e)}(t.v,i);if(!r)throw new Error(\"Your browser does not appear to support WebGL.\");for(var u in n.gl=r,r.__proto__)if(\"number\"==typeof r.__proto__[u])Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(u),r.__proto__[u]);else if(\"function\"==typeof r.__proto__[u])switch(u){case\"bufferData\":case\"clearColor\":case\"drawArrays\":case\"getAttribLocation\":case\"getUniformLocation\":case\"shaderSource\":case\"uniformMatrix4fv\":case\"vertexAttribPointer\":case\"viewport\":break;default:!function(t){Sk.abstr.objectSetItem(n.$d,new Sk.builtin.str(u),new Sk.builtin.func((function(){return r.__proto__[t].apply(r,arguments)})))}(u)}r.clearColor(100/255,149/255,237/255,1),r.clear(r.COLOR_BUFFER_BIT)})),t.tp$getattr=Sk.generic.getAttr,t.bufferData=new Sk.builtin.func((function(n,t,e,i){n.gl.bufferData(t,e.v,i)})),t.clearColor=new Sk.builtin.func((function(n,t,e,i,r){n.gl.clearColor(Sk.builtin.asnum$(t),Sk.builtin.asnum$(e),Sk.builtin.asnum$(i),Sk.builtin.asnum$(r))})),t.getAttribLocation=new Sk.builtin.func((function(n,t,e){return n.gl.getAttribLocation(t,e.v)})),t.getUniformLocation=new Sk.builtin.func((function(n,t,e){return n.gl.getUniformLocation(t,e.v)})),t.shaderSource=new Sk.builtin.func((function(n,t,e){n.gl.shaderSource(t,e.v)})),t.drawArrays=new Sk.builtin.func((function(n,t,e,i){n.gl.drawArrays(Sk.builtin.asnum$(t),Sk.builtin.asnum$(e),Sk.builtin.asnum$(i))})),t.vertexAttribPointer=new Sk.builtin.func((function(n,t,e,i,r,u,a){n.gl.vertexAttribPointer(t,Sk.builtin.asnum$(e),Sk.builtin.asnum$(i),r,Sk.builtin.asnum$(u),Sk.builtin.asnum$(a))})),t.viewport=new Sk.builtin.func((function(n,t,e,i,r){n.gl.viewport(Sk.builtin.asnum$(t),Sk.builtin.asnum$(e),Sk.builtin.asnum$(i),Sk.builtin.asnum$(r))})),t.uniformMatrix4fv=new Sk.builtin.func((function(n,t,e,i){n.gl.uniformMatrix4fv(Sk.builtin.asnum$(t),e,i.v)})),t.setDrawFunc=new Sk.builtin.func((function(n,t){var e=(new Date).getTime();setInterval((function(){Sk.misceval.callsimArray(t,[n,(new Date).getTime()-e])}),1e3/60)}))}),\"Context\",[]),t.Float32Array=Sk.misceval.buildClass(t,(function(n,t){t.__init__=new Sk.builtin.func((function(n,t){n.v=\"number\"==typeof t?new Float32Array(t):new Float32Array(Sk.ffi.remapToJs(t))})),t.__repr__=new Sk.builtin.func((function(n){for(var t=[],e=0;e<n.v.length;++e)t.push(n.v[e]);return new Sk.builtin.str(\"[\"+t.join(\", \")+\"]\")}))}),\"Float32Array\",[]),t.Matrix4x4=Sk.misceval.buildClass(t,(function(n,t){t.__init__=new Sk.builtin.func((function(n,t){n.v=new Float32Array(Sk.ffi.remapToJs(t))})),t.identity=new Sk.builtin.func((function(n){var t=n.v;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1})),t.perspective=new Sk.builtin.func((function(n,t,e,i,r){var u=Math.tan(.5*Math.PI-Sk.builtin.asnum$(t)*Math.PI/180*.5),a=Sk.builtin.asnum$(e),o=Sk.builtin.asnum$(i),l=Sk.builtin.asnum$(r),c=1/(o-l),f=n.v;f[0]=u/a,f[1]=0,f[2]=0,f[3]=0,f[4]=0,f[5]=u,f[6]=0,f[7]=0,f[8]=0,f[9]=0,f[10]=(o+l)*c,f[11]=-1,f[12]=0,f[13]=0,f[14]=o*l*c*2,f[15]=0})),t.translate=new Sk.builtin.func((function(n,t){var e=n.v,i=Sk.ffi.remapToJs(t);e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=i[0],e[13]=i[1],e[14]=i[2],e[15]=1})),t.__repr__=new Sk.builtin.func((function(n){for(var t=[],e=0;e<n.v.length;++e)t.push(n.v[e]);return new Sk.builtin.str(\"[\"+t.join(\", \")+\"]\")}))}),\"Matrix4x4\",[]),t};","src/lib/webgl/math.js":"var $builtinmodule=function(e){var n={};return n.Mat44=Sk.misceval.buildClass(n,(function(e,t){t.__init__=new Sk.builtin.func((function(e){Sk.misceval.callsimArray(t.loadIdentity,[e]),e.stack=[]})),t.push=new Sk.builtin.func((function(e){e.stack.push(e.elements.slice(0))})),t.pop=new Sk.builtin.func((function(e){e.elements=e.stack.pop()})),t.loadIdentity=new Sk.builtin.func((function(e){e.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]})),t.transform3=new Sk.builtin.func((function(e,t){var l=e.elements;return Sk.misceval.callsimArray(n.Vec3,[l[0]*t.x+l[4]*t.y+l[8]*t.z,l[1]*t.x+l[5]*t.y+l[9]*t.z,l[2]*t.x+l[6]*t.y+l[10]*t.z])})),t.scale=new Sk.builtin.func((function(e,n,t,l){return e.elements[0]*=n,e.elements[1]*=n,e.elements[2]*=n,e.elements[3]*=n,e.elements[4]*=t,e.elements[5]*=t,e.elements[6]*=t,e.elements[7]*=t,e.elements[8]*=l,e.elements[9]*=l,e.elements[10]*=l,e.elements[11]*=l,e})),t.translate=new Sk.builtin.func((function(e,n,t,l){return e.elements[12]+=e.elements[0]*n+e.elements[4]*t+e.elements[8]*l,e.elements[13]+=e.elements[1]*n+e.elements[5]*t+e.elements[9]*l,e.elements[14]+=e.elements[2]*n+e.elements[6]*t+e.elements[10]*l,e.elements[15]+=e.elements[3]*n+e.elements[7]*t+e.elements[11]*l,e})),t.rotate=new Sk.builtin.func((function(e,t,l,s,m){var i,a,c,u,r,f,o,k,S,y,b,v=Math.sqrt(l*l+s*s+m*m),_=Math.sin(t*Math.PI/180),w=Math.cos(t*Math.PI/180);v>0&&(i=(l/=v)*l,a=(s/=v)*s,c=(m/=v)*m,u=l*s,r=s*m,f=m*l,o=l*_,k=s*_,S=m*_,y=1-w,(b=Sk.misceval.callsimArray(n.Mat44)).elements[0]=y*i+w,b.elements[1]=y*u-S,b.elements[2]=y*f+k,b.elements[3]=0,b.elements[4]=y*u+S,b.elements[5]=y*a+w,b.elements[6]=y*r-o,b.elements[7]=0,b.elements[8]=y*f-k,b.elements[9]=y*r+o,b.elements[10]=y*c+w,b.elements[11]=0,b.elements[12]=0,b.elements[13]=0,b.elements[14]=0,b.elements[15]=1,b=b.multiply(e),e.elements=b.elements);return e})),t.multiply=new Sk.builtin.func((function(e,t){for(var l=Sk.misceval.callsimArray(n.Mat44),s=0;s<4;s++)l.elements[4*s+0]=e.elements[4*s+0]*t.elements[0]+e.elements[4*s+1]*t.elements[4]+e.elements[4*s+2]*t.elements[8]+e.elements[4*s+3]*t.elements[12],l.elements[4*s+1]=e.elements[4*s+0]*t.elements[1]+e.elements[4*s+1]*t.elements[5]+e.elements[4*s+2]*t.elements[9]+e.elements[4*s+3]*t.elements[13],l.elements[4*s+2]=e.elements[4*s+0]*t.elements[2]+e.elements[4*s+1]*t.elements[6]+e.elements[4*s+2]*t.elements[10]+e.elements[4*s+3]*t.elements[14],l.elements[4*s+3]=e.elements[4*s+0]*t.elements[3]+e.elements[4*s+1]*t.elements[7]+e.elements[4*s+2]*t.elements[11]+e.elements[4*s+3]*t.elements[15];return e.elements=l.elements,e})),t.lookAt=new Sk.builtin.func((function(e,t,l,s,m,i,a,c,u,r){var f=[t-m,l-i,s-a],o=Math.sqrt(f[0]*f[0]+f[1]*f[1]+f[2]*f[2]);o&&(f[0]/=o,f[1]/=o,f[2]/=o);var k=[c,u,r],S=[];S[0]=k[1]*f[2]-k[2]*f[1],S[1]=-k[0]*f[2]+k[2]*f[0],S[2]=k[0]*f[1]-k[1]*f[0],k[0]=f[1]*S[2]-f[2]*S[1],k[1]=-f[0]*S[2]+f[2]*S[0],k[2]=f[0]*S[1]-f[1]*S[0],(o=Math.sqrt(S[0]*S[0]+S[1]*S[1]+S[2]*S[2]))&&(S[0]/=o,S[1]/=o,S[2]/=o),(o=Math.sqrt(k[0]*k[0]+k[1]*k[1]+k[2]*k[2]))&&(k[0]/=o,k[1]/=o,k[2]/=o);var y=Sk.misceval.callsimArray(n.Mat44);return y.elements[0]=S[0],y.elements[4]=S[1],y.elements[8]=S[2],y.elements[12]=0,y.elements[1]=k[0],y.elements[5]=k[1],y.elements[9]=k[2],y.elements[13]=0,y.elements[2]=f[0],y.elements[6]=f[1],y.elements[10]=f[2],y.elements[14]=0,y.elements[3]=0,y.elements[7]=0,y.elements[11]=0,y.elements[15]=1,y=y.multiply(e),e.elements=y.elements,e.translate(-t,-l,-s),e}))}),\"Mat44\",[]),n.Mat33=Sk.misceval.buildClass(n,(function(e,n){n.__init__=new Sk.builtin.func((function(e){Sk.misceval.callsimArray(n.loadIdentity,[e])})),n.loadIdentity=new Sk.builtin.func((function(e){e.elements=[1,0,0,0,1,0,0,0,1]}))}),\"Mat33\",[]),n.Vec3=Sk.misceval.buildClass(n,(function(e,t){t.__init__=new Sk.builtin.func((function(e,n,t,l){e.x=n,e.y=t,e.z=l})),t.__sub__=new Sk.builtin.func((function(e,t){return Sk.misceval.callsimArray(n.Vec3,[e.x-t.x,e.y-t.y,e.z-t.z])}))}),\"Vec3\",[]),n.cross=new Sk.builtin.func((function(e,t){return Sk.asserts.assert(e instanceof n.Vec3&&t instanceof n.Vec3),Sk.misceval.callsimArray(n.Vec3,[e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x])})),n};","src/lib/webgl/matrix4.js":"var $builtinmodule=function(n){var r={},t=new Float32Array(3),a=new Float32Array(3),u=new Float32Array(3),e=(new Float32Array(4),new Float32Array(4),new Float32Array(4),new Float32Array(16),new Float32Array(16),new Float32Array(16),function(n,r){for(var t=0,a=r.length,u=0;u<a;++u)t+=r[u]*r[u];if((t=Math.sqrt(t))>1e-5)for(u=0;u<a;++u)n[u]=r[u]/t;else for(u=0;u<a;++u)n[u]=0;return n}),cross=function(n,r,t){return n[0]=r[1]*t[2]-r[2]*t[1],n[1]=r[2]*t[0]-r[0]*t[2],n[2]=r[0]*t[1]-r[1]*t[0],n},dot=function(n,r){return n[0]*r[0]+n[1]*r[1]+n[2]*r[2]};return r.lookAt=new Sk.builtin.func((function(n,r,i,o){var v=a,f=u,l=e(t,function(n,r,t){for(var a=r.length,u=0;u<a;++u)n[u]=r[u]-t[u];return n}(t,r.v,i.v)),c=e(v,cross(v,o.v,l)),w=cross(f,l,c),h=n.v;return h[0]=c[0],h[1]=w[0],h[2]=l[0],h[3]=0,h[4]=c[1],h[5]=w[1],h[6]=l[1],h[7]=0,h[8]=c[2],h[9]=w[2],h[10]=l[2],h[11]=0,h[12]=-dot(c,r.v),h[13]=-dot(w,r.v),h[14]=-dot(l,r.v),h[15]=1,n})),r.perspective=new Sk.builtin.func((function(n,r,t,a,u){var e=Math.tan(.5*Math.PI-r*Math.PI/180*.5),i=1/(a-u),o=n.v;return o[0]=e/t,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=e,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=(a+u)*i,o[11]=-1,o[12]=0,o[13]=0,o[14]=a*u*i*2,o[15]=0,n})),r.rotationY=new Sk.builtin.func((function(n,r){var t=n.v,a=Math.cos(r*Math.PI/180),u=Math.sin(r*Math.PI/180);return t[0]=a,t[1]=0,t[2]=-u,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=u,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,n})),r.identity=new Sk.builtin.func((function(n){var r=n.v;return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,n})),r.mul=new Sk.builtin.func((function(n,r,t){var a=n.v,u=r.v,e=t.v,i=u[0],o=u[1],v=u[2],f=u[3],l=u[4],c=u[5],w=u[6],h=u[7],y=u[8],A=u[9],F=u[10],b=u[11],k=u[12],M=u[13],s=u[14],S=u[15],I=e[0],P=e[1],p=e[2],d=e[3],g=e[4],m=e[5],q=e[6],Y=e[7],$=e[8],j=e[9],x=e[10],z=e[11],B=e[12],C=e[13],D=e[14],E=e[15];return a[0]=i*I+o*g+v*$+f*B,a[1]=i*P+o*m+v*j+f*C,a[2]=i*p+o*q+v*x+f*D,a[3]=i*d+o*Y+v*z+f*E,a[4]=l*I+c*g+w*$+h*B,a[5]=l*P+c*m+w*j+h*C,a[6]=l*p+c*q+w*x+h*D,a[7]=l*d+c*Y+w*z+h*E,a[8]=y*I+A*g+F*$+b*B,a[9]=y*P+A*m+F*j+b*C,a[10]=y*p+A*q+F*x+b*D,a[11]=y*d+A*Y+F*z+b*E,a[12]=k*I+M*g+s*$+S*B,a[13]=k*P+M*m+s*j+S*C,a[14]=k*p+M*q+s*x+S*D,a[15]=k*d+M*Y+s*z+S*E,n})),r.invert=new Sk.builtin.func((function(n,r){var t=n.v,a=r.v,u=a[0],e=a[1],i=a[2],o=a[3],v=a[4],f=a[5],l=a[6],c=a[7],w=a[8],h=a[9],y=a[10],A=a[11],F=a[12],b=a[13],k=a[14],M=a[15],s=y*M,S=k*A,I=l*M,P=k*c,p=l*A,d=y*c,g=i*M,m=k*o,q=i*A,Y=y*o,$=i*c,j=l*o,x=w*b,z=F*h,B=v*b,C=F*f,D=v*h,E=w*f,G=u*b,H=F*e,J=u*h,K=w*e,L=u*f,N=v*e,O=s*f+P*h+p*b-(S*f+I*h+d*b),Q=S*e+g*h+Y*b-(s*e+m*h+q*b),R=I*e+m*f+$*b-(P*e+g*f+j*b),T=d*e+q*f+j*h-(p*e+Y*f+$*h),U=1/(u*O+v*Q+w*R+F*T);return t[0]=U*O,t[1]=U*Q,t[2]=U*R,t[3]=U*T,t[4]=U*(S*v+I*w+d*F-(s*v+P*w+p*F)),t[5]=U*(s*u+m*w+q*F-(S*u+g*w+Y*F)),t[6]=U*(P*u+g*v+j*F-(I*u+m*v+$*F)),t[7]=U*(p*u+Y*v+$*w-(d*u+q*v+j*w)),t[8]=U*(x*c+C*A+D*M-(z*c+B*A+E*M)),t[9]=U*(z*o+G*A+K*M-(x*o+H*A+J*M)),t[10]=U*(B*o+H*c+L*M-(C*o+G*c+N*M)),t[11]=U*(E*o+J*c+N*A-(D*o+K*c+L*A)),t[12]=U*(B*y+E*k+z*l-(D*k+x*l+C*y)),t[13]=U*(J*k+x*i+H*y-(G*y+K*k+z*i)),t[14]=U*(G*l+N*k+C*i-(L*k+B*i+H*l)),t[15]=U*(L*y+D*i+K*l-(J*l+N*y+E*i)),n})),r.transpose=new Sk.builtin.func((function(n,r){for(var t=n.v,a=r.v,u=0;u<4;++u)for(var e=0;e<4;++e)t[4*u+e]=a[4*e+u];return t})),r};","src/lib/webgl/models.js":"var $builtinmodule=function(t){return Sk.misceval.chain(Sk.importModule(\"webgl\",!1,!0),(e=>{const n=e.$d;var r={},Buffer=function(t,e){var r=e||n.ARRAY_BUFFER,i=n.createBuffer();if(this.target=r,this.buf=i,this.set(t),this.numComponents_=t.numComponents,this.numElements_=t.numElements,this.totalComponents_=this.numComponents_*this.numElements_,t.buffer instanceof Float32Array)this.type_=n.FLOAT;else if(t.buffer instanceof Uint8Array)this.type_=n.UNSIGNED_BYTE;else if(t.buffer instanceof Int8Array)this.type_=n._BYTE;else if(t.buffer instanceof Uint16Array)this.type_=n.UNSIGNED_SHORT;else{if(!(t.buffer instanceof Int16Array))throw\"unhandled type:\"+typeof t.buffer;this.type_=n.SHORT}};return Buffer.prototype.set=function(t){n.bindBuffer(this.target,this.buf),n.bufferData(this.target,t.buffer,n.STATIC_DRAW)},Buffer.prototype.type=function(){return this.type_},Buffer.prototype.numComponents=function(){return this.numComponents_},Buffer.prototype.numElements=function(){return this.numElements_},Buffer.prototype.totalComponents=function(){return this.totalComponents_},Buffer.prototype.buffer=function(){return this.buf},Buffer.prototype.stride=function(){return 0},Buffer.prototype.offset=function(){return 0},r.Model=Sk.misceval.buildClass(r,(function(e,r){r.__init__=new Sk.builtin.func((function(e,r,i,f){e.buffers={};var setBuffer=function(t,r){var i=\"indices\"==t?n.ELEMENT_ARRAY_BUFFER:n.ARRAY_BUFFER;let f=e.buffers[t];f?f.set(r):f=new Buffer(r,i),e.buffers[t]=f};for(t in i)setBuffer(t,i[t]);var o={},s=0;for(var u in f)o[u]=s++;e.mode=n.TRIANGLES,e.textures=f.v,e.textureUnits=o,e.shader=r})),r.drawPrep=new Sk.builtin.func((function(t,e){var r=t.shader,i=t.buffers,f=t.textures;for(var o in e=Sk.ffi.remapToJs(e),Sk.misceval.callsimArray(r.use,[r]),i){var s=i[o];if(\"indices\"==o)n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,s.buffer());else{var u=r.attrib[o];u&&u(s)}}for(var a in f){var m=t.textureUnits[a];r.setUniform$impl(r,f,m),f[a].bindToUnit(m)}for(var p in e)r.setUniform$impl(r,p,e[p])})),r.draw=new Sk.builtin.func((function(t,e,r){var i=t.shader;e=Sk.ffi.remapToJs(e);for(let n in e)i.setUniform$impl(i,n,e[n]);if(r)for(var f in r){var o=t.textureUnits[f];i.setUniform$impl(i,f,o),r[f].bindToUnit(o)}var s=t.buffers;n.drawElements(t.mode,s.indices.totalComponents(),n.UNSIGNED_SHORT,0)}))}),\"Model\",[]),r}))};","src/lib/webgl/primitives.js":"var $builtinmodule=function(t){var n={},AttribBuffer=function(t,n,e){e=e||\"Float32Array\";var r=window[e];n.length?(this.buffer=new r(n),n=this.buffer.length/t,this.cursor=n):(this.buffer=new r(t*n),this.cursor=0),this.numComponents=t,this.numElements=n,this.type=e};return AttribBuffer.prototype.stride=function(){return 0},AttribBuffer.prototype.offset=function(){return 0},AttribBuffer.prototype.getElement=function(t){for(var n=t*this.numComponents,e=[],r=0;r<this.numComponents;++r)e.push(this.buffer[n+r]);return e},AttribBuffer.prototype.setElement=function(t,n){for(var e=t*this.numComponents,r=0;r<this.numComponents;++r)this.buffer[e+r]=n[r]},AttribBuffer.prototype.clone=function(){var t=new AttribBuffer(this.numComponents,this.numElements,this.type);return t.pushArray(this),t},AttribBuffer.prototype.push=function(t){this.setElement(this.cursor++,t)},AttribBuffer.prototype.pushArray=function(t){for(var n=0;n<t.numElements;++n)this.push(t.getElement(n))},AttribBuffer.prototype.pushArrayWithOffset=function(t,n){for(var e=0;e<t.numElements;++e){for(var r=t.getElement(e),o=0;o<n.length;++o)r[o]+=n[o];this.push(r)}},AttribBuffer.prototype.computeExtents=function(){for(var t=this.numElements,n=this.numComponents,e=this.getElement(0),r=this.getElement(0),o=1;o<t;++o)for(var s=this.getElement(o),u=0;u<n;++u)e[u]=Math.min(e[u],s[u]),r[u]=Math.max(r[u],s[u]);return{min:e,max:r}},n.createCube=new Sk.builtin.func((function(t){for(var n=[[3,7,5,1],[0,4,6,2],[6,7,3,2],[0,1,5,4],[5,7,6,4],[2,3,1,0]],e=t/2,r=[[-e,-e,-e],[+e,-e,-e],[-e,+e,-e],[+e,+e,-e],[-e,-e,+e],[+e,-e,+e],[-e,+e,+e],[+e,+e,+e]],o=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],s=[[0,0],[1,0],[1,1],[0,1]],u=new AttribBuffer(3,24),i=new AttribBuffer(3,24),h=new AttribBuffer(2,24),p=new AttribBuffer(3,12,\"Uint16Array\"),m=0;m<6;++m){for(var f=n[m],a=0;a<4;++a){var l=r[f[a]],c=o[m],y=s[a];u.push(l),i.push(c),h.push(y)}var v=4*m;p.push([v+0,v+1,v+2]),p.push([v+0,v+2,v+3])}return{position:u,normal:i,texCoord:h,indices:p}})),n};"}}

/***/ }),

/***/ 53098:
/*!***********************************************!*\
  !*** ./runestone/activecode/js/skulpt.min.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

(function(){/*
 unicode_hack.js
    Copyright (C) 2010-2012  Marcelo Gibson de Castro Gonçalves. All rights reserved.

    Copying and distribution of this file, with or without modification,
    are permitted in any medium without royalty provided the copyright
    notice and this notice are preserved.  This file is offered as-is,
    without any warranty.
*/
'use strict';var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.ISOLATE_POLYFILLS=!1;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(F,P,b){if(F==Array.prototype||F==Object.prototype)return F;F[P]=b.value;return F};
$jscomp.getGlobal=function(F){F=["object"==typeof globalThis&&globalThis,F,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof __webpack_require__.g&&__webpack_require__.g];for(var P=0;P<F.length;++P){var b=F[P];if(b&&b.Math==Math)return b}throw Error("Cannot find global object");};$jscomp.global=$jscomp.getGlobal(this);$jscomp.IS_SYMBOL_NATIVE="function"===typeof Symbol&&"symbol"===typeof Symbol("x");$jscomp.TRUST_ES6_POLYFILLS=!$jscomp.ISOLATE_POLYFILLS||$jscomp.IS_SYMBOL_NATIVE;$jscomp.polyfills={};
$jscomp.propertyToPolyfillSymbol={};$jscomp.POLYFILL_PREFIX="$jscp$";var $jscomp$lookupPolyfilledValue=function(F,P){var b=$jscomp.propertyToPolyfillSymbol[P];if(null==b)return F[P];b=F[b];return void 0!==b?b:F[P]};$jscomp.polyfill=function(F,P,b,e){P&&($jscomp.ISOLATE_POLYFILLS?$jscomp.polyfillIsolated(F,P,b,e):$jscomp.polyfillUnisolated(F,P,b,e))};
$jscomp.polyfillUnisolated=function(F,P,b,e){b=$jscomp.global;F=F.split(".");for(e=0;e<F.length-1;e++){var d=F[e];if(!(d in b))return;b=b[d]}F=F[F.length-1];e=b[F];P=P(e);P!=e&&null!=P&&$jscomp.defineProperty(b,F,{configurable:!0,writable:!0,value:P})};
$jscomp.polyfillIsolated=function(F,P,b,e){var d=F.split(".");F=1===d.length;e=d[0];e=!F&&e in $jscomp.polyfills?$jscomp.polyfills:$jscomp.global;for(var f=0;f<d.length-1;f++){var h=d[f];if(!(h in e))return;e=e[h]}d=d[d.length-1];b=$jscomp.IS_SYMBOL_NATIVE&&"es6"===b?e[d]:null;P=P(b);null!=P&&(F?$jscomp.defineProperty($jscomp.polyfills,d,{configurable:!0,writable:!0,value:P}):P!==b&&(void 0===$jscomp.propertyToPolyfillSymbol[d]&&($jscomp.propertyToPolyfillSymbol[d]=$jscomp.IS_SYMBOL_NATIVE?$jscomp.global.Symbol(d):
$jscomp.POLYFILL_PREFIX+d),$jscomp.defineProperty(e,$jscomp.propertyToPolyfillSymbol[d],{configurable:!0,writable:!0,value:P})))};$jscomp.polyfill("Array.prototype.flat",function(F){return F?F:function(P){P=void 0===P?1:P;for(var b=[],e=0;e<this.length;e++){var d=this[e];Array.isArray(d)&&0<P?(d=Array.prototype.flat.call(d,P-1),b.push.apply(b,d)):b.push(d)}return b}},"es9","es5");$jscomp.arrayIteratorImpl=function(F){var P=0;return function(){return P<F.length?{done:!1,value:F[P++]}:{done:!0}}};
$jscomp.arrayIterator=function(F){return{next:$jscomp.arrayIteratorImpl(F)}};$jscomp.initSymbol=function(){};$jscomp.iteratorPrototype=function(F){F={next:F};F[Symbol.iterator]=function(){return this};return F};
$jscomp.polyfill("String.prototype.matchAll",function(F){return F?F:function(P){if(P instanceof RegExp&&!P.global)throw new TypeError("RegExp passed into String.prototype.matchAll() must have global tag.");var b=new RegExp(P,P instanceof RegExp?void 0:"g"),e=this,d=!1,f={next:function(){var h={},p=b.lastIndex;if(d)return{value:void 0,done:!0};var g=b.exec(e);if(!g)return d=!0,{value:void 0,done:!0};b.lastIndex===p&&(b.lastIndex+=1);h.value=g;h.done=!1;return h}};f[Symbol.iterator]=function(){return f};
return f}},"es_2020","es3");$jscomp.polyfill("Array.prototype.includes",function(F){return F?F:function(P,b){var e=this;e instanceof String&&(e=String(e));var d=e.length;b=b||0;for(0>b&&(b=Math.max(b+d,0));b<d;b++){var f=e[b];if(f===P||Object.is(f,P))return!0}return!1}},"es7","es3");$jscomp.owns=function(F,P){return Object.prototype.hasOwnProperty.call(F,P)};
$jscomp.polyfill("Object.entries",function(F){return F?F:function(P){var b=[],e;for(e in P)$jscomp.owns(P,e)&&b.push([e,P[e]]);return b}},"es8","es3");
$jscomp.polyfill("Object.fromEntries",function(F){return F?F:function(P){var b={};if(!(Symbol.iterator in P))throw new TypeError(""+P+" is not iterable");P=P[Symbol.iterator].call(P);for(var e=P.next();!e.done;e=P.next()){e=e.value;if(Object(e)!==e)throw new TypeError("iterable for fromEntries should yield objects");b[e[0]]=e[1]}return b}},"es_2019","es3");
$jscomp.checkStringArgs=function(F,P,b){if(null==F)throw new TypeError("The 'this' value for String.prototype."+b+" must not be null or undefined");if(P instanceof RegExp)throw new TypeError("First argument to String.prototype."+b+" must not be a regular expression");return F+""};$jscomp.stringPadding=function(F,P){F=void 0!==F?String(F):" ";return 0<P&&F?F.repeat(Math.ceil(P/F.length)).substring(0,P):""};
$jscomp.polyfill("String.prototype.padStart",function(F){return F?F:function(P,b){var e=$jscomp.checkStringArgs(this,null,"padStart");return $jscomp.stringPadding(b,P-e.length)+e}},"es8","es3");$jscomp.polyfill("Object.values",function(F){return F?F:function(P){var b=[],e;for(e in P)$jscomp.owns(P,e)&&b.push(P[e]);return b}},"es8","es3");
$jscomp.iteratorFromArray=function(F,P){F instanceof String&&(F+="");var b=0,e=!1,d={next:function(){if(!e&&b<F.length){var f=b++;return{value:P(f,F[f]),done:!1}}e=!0;return{done:!0,value:void 0}}};d[Symbol.iterator]=function(){return d};return d};$jscomp.polyfill("Array.prototype.values",function(F){return F?F:function(){return $jscomp.iteratorFromArray(this,function(P,b){return b})}},"es8","es3");
(function(F){function P(e){if(b[e])return b[e].exports;var d=b[e]={i:e,l:!1,exports:{}};F[e].call(d.exports,d,d.exports,P);d.l=!0;return d.exports}var b={};P.m=F;P.c=b;P.d=function(e,d,f){P.o(e,d)||Object.defineProperty(e,d,{enumerable:!0,get:f})};P.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"});Object.defineProperty(e,"__esModule",{value:!0})};P.t=function(e,d){d&1&&(e=P(e));if(d&8||d&4&&"object"===typeof e&&e&&e.__esModule)return e;
var f=Object.create(null);P.r(f);Object.defineProperty(f,"default",{enumerable:!0,value:e});if(d&2&&"string"!=typeof e)for(var h in e)P.d(f,h,function(p){return e[p]}.bind(null,h));return f};P.n=function(e){var d=e&&e.__esModule?function(){return e["default"]}:function(){return e};P.d(d,"a",d);return d};P.o=function(e,d){return Object.prototype.hasOwnProperty.call(e,d)};P.p="";return P(P.s=1)})([function(F,P){P=function(){return this}();try{P=P||(new Function("return this"))()}catch(b){"object"===
typeof window&&(P=window)}F.exports=P},function(F,P,b){b(2);Sk.global.strftime=b(3);b(4);b(6);b(7);b(9);b(10);b(11);b(12);b(13);b(14);b(15);b(16);b(17);b(18);[Sk.builtin.object,Sk.builtin.type].forEach(e=>{Sk.abstr.setUpSlots(e);Sk.abstr.setUpMethods(e);Sk.abstr.setUpGetSets(e);Sk.abstr.setUpClassMethods(e)});b(19);b(20);b(21);[Sk.builtin.str,Sk.builtin.none,Sk.builtin.NotImplemented,Sk.builtin.object].forEach(e=>{e=e.prototype;e.__doc__=e.hasOwnProperty("tp$doc")?new Sk.builtin.str(e.tp$doc):Sk.builtin.none.none$});
b(22);b(23);b(24);b(25);b(26);b(27);b(28);b(29);b(31);b(32);b(33);b(34);b(35);b(36);b(37);b(38);b(39);b(40);b(41);b(42);b(43);b(44);b(45);b(46);b(47);b(48);b(49);b(50);b(51);b(52);b(53);b(66);b(54);b(55);b(56);b(57);b(58);b(59);b(60);b(61);b(62);b(63);b(64);b(65)},function(F,P,b){(function(e){var d={build:{githash:"399aa8d0509b1022562f237f1d21919782943b47",date:"2024-03-04T15:06:12.777Z"}};d.global="undefined"!==typeof e?e:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{};d.exportSymbol=
function(f,h){f=f.split(".");var p=d.global,g;for(g=0;g<f.length-1;g++){var a=f[g];p=p.hasOwnProperty(a)?p[a]:p[a]={}}"undefined"!==typeof h&&(a=f[g],p[a]=h)};d.isArrayLike=function(f){return f instanceof Array||f&&f.length&&"number"==typeof f.length?!0:!1};d.js_beautify=function(f){return f};d.exportSymbol("Sk",d);d.exportSymbol("Sk.global",d.global);d.exportSymbol("Sk.build",d.build);d.exportSymbol("Sk.exportSymbol",d.exportSymbol);d.exportSymbol("Sk.isArrayLike",d.isArrayLike);d.exportSymbol("Sk.js_beautify",
d.js_beautify)}).call(this,b(0))},function(F,P){(function(){function b(k,u,l){function q(I,M,S,E){for(var H="",y=null,A=!1,J=I.length,Q=!1,X=0;X<J;X++){var aa=I.charCodeAt(X);if(!0===A)if(45===aa)y="";else if(95===aa)y=" ";else if(48===aa)y="0";else if(58===aa)Q&&g("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime"),Q=!0;else{switch(aa){case 37:H+="%";break;case 65:H+=S.days[M.getDay()];break;case 66:H+=S.months[M.getMonth()];break;case 67:H+=e(Math.floor(M.getFullYear()/100),
y);break;case 68:H+=q(S.formats.D,M,S,E);break;case 70:H+=q(S.formats.F,M,S,E);break;case 72:H+=e(M.getHours(),y);break;case 73:H+=e(f(M.getHours()),y);break;case 76:H+=d(Math.floor(E%1E3));break;case 77:H+=e(M.getMinutes(),y);break;case 80:H+=12>M.getHours()?S.am:S.pm;break;case 82:H+=q(S.formats.R,M,S,E);break;case 83:H+=e(M.getSeconds(),y);break;case 84:H+=q(S.formats.T,M,S,E);break;case 85:H+=e(h(M,"sunday"),y);break;case 87:H+=e(h(M,"monday"),y);break;case 88:H+=q(S.formats.X,M,S,E);break;case 89:H+=
M.getFullYear();break;case 90:t&&0===r?H+="GMT":(y=M,y=(y=y.toString().match(/\(([\w\s]+)\)/))&&y[1],H+=y||"");break;case 97:H+=S.shortDays[M.getDay()];break;case 98:H+=S.shortMonths[M.getMonth()];break;case 99:H+=q(S.formats.c,M,S,E);break;case 100:H+=e(M.getDate(),y);break;case 101:H+=e(M.getDate(),null==y?" ":y);break;case 104:H+=S.shortMonths[M.getMonth()];break;case 106:y=new Date(M.getFullYear(),0,1);y=Math.ceil((M.getTime()-y.getTime())/864E5);H+=d(y);break;case 107:H+=e(M.getHours(),null==
y?" ":y);break;case 108:H+=e(f(M.getHours()),null==y?" ":y);break;case 109:H+=e(M.getMonth()+1,y);break;case 110:H+="\n";break;case 111:y=M.getDate();H=S.ordinalSuffixes?H+(String(y)+(S.ordinalSuffixes[y-1]||p(y))):H+(String(y)+p(y));break;case 112:H+=12>M.getHours()?S.AM:S.PM;break;case 114:H+=q(S.formats.r,M,S,E);break;case 115:H+=Math.floor(E/1E3);break;case 116:H+="\t";break;case 117:y=M.getDay();H+=0===y?7:y;break;case 118:H+=q(S.formats.v,M,S,E);break;case 119:H+=M.getDay();break;case 120:H+=
q(S.formats.x,M,S,E);break;case 121:A=M.getFullYear()%100;H+=e(A,y);break;case 122:t&&0===r?H+=Q?"+00:00":"+0000":(y=0!==r?r/6E4:-M.getTimezoneOffset(),A=Q?":":"",aa=Math.abs(y%60),H+=(0>y?"-":"+")+e(Math.floor(Math.abs(y/60)))+A+e(aa));break;default:A&&(H+="%"),H+=I[X]}y=null;A=!1}else 37===aa?A=!0:H+=I[X]}return H}var z=k||c,r=u||0,t=l||!1,x=0,v,B=function(I,M){if(M){var S=M.getTime();if(t){var E=6E4*(M.getTimezoneOffset()||0);M=new Date(S+E+r);6E4*(M.getTimezoneOffset()||0)!==E&&(M=6E4*(M.getTimezoneOffset()||
0),M=new Date(S+M+r))}}else S=Date.now(),S>x?(x=S,v=new Date(x),S=x,t&&(v=new Date(x+6E4*(v.getTimezoneOffset()||0)+r))):S=x,M=v;return q(I,M,z,S)};B.localize=function(I){return new b(I||z,r,t)};B.localizeByIdentifier=function(I){var M=a[I];return M?B.localize(M):(g('[WARNING] No locale found with identifier "'+I+'".'),B)};B.timezone=function(I){var M=r,S=t,E=typeof I;if("number"===E||"string"===E)S=!0,"string"===E?(M="-"===I[0]?-1:1,E=parseInt(I.slice(1,3),10),I=parseInt(I.slice(3,5),10),M=M*(60*
E+I)*6E4):"number"===E&&(M=6E4*I);return new b(z,M,S)};B.utc=function(){return new b(z,r,!0)};return B}function e(k,u){if(""===u||9<k)return""+k;null==u&&(u="0");return u+k}function d(k){return 99<k?k:9<k?"0"+k:"00"+k}function f(k){return 0===k?12:12<k?k-12:k}function h(k,u){u=u||"sunday";var l=k.getDay();"monday"===u&&(0===l?l=6:l--);u=Date.UTC(k.getFullYear(),0,1);k=Date.UTC(k.getFullYear(),k.getMonth(),k.getDate());return Math.floor((Math.floor((k-u)/864E5)+7-l)/7)}function p(k){var u=k%10;k%=
100;if(11<=k&&13>=k||0===u||4<=u)return"th";switch(u){case 1:return"st";case 2:return"nd";case 3:return"rd"}}function g(k){"undefined"!==typeof console&&"function"==typeof console.warn&&console.warn(k)}var a={de_DE:{identifier:"de-DE",days:"Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag".split(" "),shortDays:"So Mo Di Mi Do Fr Sa".split(" "),months:"Januar Februar M\u00e4rz April Mai Juni Juli August September Oktober November Dezember".split(" "),shortMonths:"Jan Feb M\u00e4r Apr Mai Jun Jul Aug Sep Okt Nov Dez".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d.%m.%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},en_CA:{identifier:"en-CA",days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),ordinalSuffixes:"st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}},en_US:{identifier:"en-US",days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),ordinalSuffixes:"st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%m/%d/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}},es_MX:{identifier:"es-MX",days:"domingo lunes martes mi\u00e9rcoles jueves viernes s\u00e1bado".split(" "),shortDays:"dom lun mar mi\u00e9 jue vie s\u00e1b".split(" "),months:"enero febrero marzo abril mayo junio julio agosto septiembre octubre noviembre diciembre".split(" "),shortMonths:"ene feb mar abr may jun jul ago sep oct nov dic".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},fr_FR:{identifier:"fr-FR",days:"dimanche lundi mardi mercredi jeudi vendredi samedi".split(" "),shortDays:"dim. lun. mar. mer. jeu. ven. sam.".split(" "),months:"janvier f\u00e9vrier mars avril mai juin juillet ao\u00fbt septembre octobre novembre d\u00e9cembre".split(" "),shortMonths:"janv. f\u00e9vr. mars avril mai juin juil. ao\u00fbt sept. oct. nov. d\u00e9c.".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},it_IT:{identifier:"it-IT",days:"domenica luned\u00ec marted\u00ec mercoled\u00ec gioved\u00ec venerd\u00ec sabato".split(" "),shortDays:"dom lun mar mer gio ven sab".split(" "),months:"gennaio febbraio marzo aprile maggio giugno luglio agosto settembre ottobre novembre dicembre".split(" "),shortMonths:"gen feb mar apr mag giu lug ago set ott nov dic".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},nl_NL:{identifier:"nl-NL",days:"zondag maandag dinsdag woensdag donderdag vrijdag zaterdag".split(" "),shortDays:"zo ma di wo do vr za".split(" "),months:"januari februari maart april mei juni juli augustus september oktober november december".split(" "),shortMonths:"jan feb mrt apr mei jun jul aug sep okt nov dec".split(" "),AM:"AM",PM:"PM",
am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d-%m-%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},pt_BR:{identifier:"pt-BR",days:"domingo segunda ter\u00e7a quarta quinta sexta s\u00e1bado".split(" "),shortDays:"Dom Seg Ter Qua Qui Sex S\u00e1b".split(" "),months:"janeiro fevereiro mar\u00e7o abril maio junho julho agosto setembro outubro novembro dezembro".split(" "),shortMonths:"Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez".split(" "),AM:"AM",PM:"PM",
am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d-%m-%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},ru_RU:{identifier:"ru-RU",days:"\u0412\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435 \u041f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a \u0412\u0442\u043e\u0440\u043d\u0438\u043a \u0421\u0440\u0435\u0434\u0430 \u0427\u0435\u0442\u0432\u0435\u0440\u0433 \u041f\u044f\u0442\u043d\u0438\u0446\u0430 \u0421\u0443\u0431\u0431\u043e\u0442\u0430".split(" "),
shortDays:"\u0412\u0441 \u041f\u043d \u0412\u0442 \u0421\u0440 \u0427\u0442 \u041f\u0442 \u0421\u0431".split(" "),months:"\u042f\u043d\u0432\u0430\u0440\u044c \u0424\u0435\u0432\u0440\u0430\u043b\u044c \u041c\u0430\u0440\u0442 \u0410\u043f\u0440\u0435\u043b\u044c \u041c\u0430\u0439 \u0418\u044e\u043d\u044c \u0418\u044e\u043b\u044c \u0410\u0432\u0433\u0443\u0441\u0442 \u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c \u041e\u043a\u0442\u044f\u0431\u0440\u044c \u041d\u043e\u044f\u0431\u0440\u044c \u0414\u0435\u043a\u0430\u0431\u0440\u044c".split(" "),
shortMonths:"\u044f\u043d\u0432 \u0444\u0435\u0432 \u043c\u0430\u0440 \u0430\u043f\u0440 \u043c\u0430\u0439 \u0438\u044e\u043d \u0438\u044e\u043b \u0430\u0432\u0433 \u0441\u0435\u043d \u043e\u043a\u0442 \u043d\u043e\u044f \u0434\u0435\u043a".split(" "),AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X",D:"%d.%m.%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},tr_TR:{identifier:"tr-TR",days:"Pazar Pazartesi Sal\u0131 \u00c7ar\u015famba Per\u015fembe Cuma Cumartesi".split(" "),
shortDays:"Paz Pzt Sal \u00c7r\u015f Pr\u015f Cum Cts".split(" "),months:"Ocak \u015eubat Mart Nisan May\u0131s Haziran Temmuz A\u011fustos Eyl\u00fcl Ekim Kas\u0131m Aral\u0131k".split(" "),shortMonths:"Oca \u015eub Mar Nis May Haz Tem A\u011fu Eyl Eki Kas Ara".split(" "),AM:"\u00d6\u00d6",PM:"\u00d6S",am:"\u00d6\u00d6",pm:"\u00d6S",formats:{c:"%a %d %b %Y %X %Z",D:"%d-%m-%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},zh_CN:{identifier:"zh-CN",days:"\u661f\u671f\u65e5 \u661f\u671f\u4e00 \u661f\u671f\u4e8c \u661f\u671f\u4e09 \u661f\u671f\u56db \u661f\u671f\u4e94 \u661f\u671f\u516d".split(" "),
shortDays:"\u65e5\u4e00\u4e8c\u4e09\u56db\u4e94\u516d".split(""),months:"\u4e00\u6708\u4efd \u4e8c\u6708\u4efd \u4e09\u6708\u4efd \u56db\u6708\u4efd \u4e94\u6708\u4efd \u516d\u6708\u4efd \u4e03\u6708\u4efd \u516b\u6708\u4efd \u4e5d\u6708\u4efd \u5341\u6708\u4efd \u5341\u4e00\u6708\u4efd \u5341\u4e8c\u6708\u4efd".split(" "),shortMonths:"\u4e00\u6708 \u4e8c\u6708 \u4e09\u6708 \u56db\u6708 \u4e94\u6708 \u516d\u6708 \u4e03\u6708 \u516b\u6708 \u4e5d\u6708 \u5341\u6708 \u5341\u4e00\u6708 \u5341\u4e8c\u6708".split(" "),
AM:"\u4e0a\u5348",PM:"\u4e0b\u5348",am:"\u4e0a\u5348",pm:"\u4e0b\u5348",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}}},c=a.en_US,n=new b(c,0,!1);if("undefined"!==typeof F)var m=F.exports=n;else m=function(){return this||(0,eval)("this")}(),m.strftime=n;"function"!==typeof Date.now&&(Date.now=function(){return+new Date})})()},function(F,P,b){F=b(5);const e=Sk.global.JSBI=void 0!==Sk.global.BigInt?{}:F;void 0===Sk.global.BigInt?
(e.__isBigInt||(e.__isBigInt=d=>d instanceof e),e.powermod=(d,f,h)=>{const p=e.BigInt(1);let g=p;for(f=e.greaterThan(f,e.__ZERO)?f:e.unaryMinus(f);e.greaterThan(f,e.__ZERO);)e.bitwiseAnd(f,p)&&(g=e.remainder(e.multiply(g,d),h)),f=e.signedRightShift(f,p),d=e.remainder(e.multiply(d,d),h);return g}):Object.assign(e,{BigInt:Sk.global.BigInt,toNumber:d=>Number(d),toString:d=>d.toString(),__isBigInt:d=>"bigint"===typeof d,unaryMinus:d=>-d,bitwiseNot:d=>~d,bitwiseAnd:(d,f)=>d&f,bitwiseOr:(d,f)=>d|f,bitwiseXor:(d,
f)=>d^f,exponentiate:(d,f)=>{const h=e.BigInt(1);let p=h;for(f=f>e.__ZERO?f:-f;f>e.__ZERO;)f&h&&(p*=d),f>>=h,d*=d;return p},powermod:(d,f,h)=>{const p=e.BigInt(1);let g=p;for(f=f>e.__ZERO?f:-f;f>e.__ZERO;)f&p&&(g=g*d%h),f>>=p,d=d*d%h;return g},multiply:(d,f)=>d*f,divide:(d,f)=>d/f,remainder:(d,f)=>d%f,add:(d,f)=>d+f,subtract:(d,f)=>d-f,leftShift:(d,f)=>d<<f,signedRightShift:(d,f)=>d>>f,unsignedRightShift:(d,f)=>d>>>f,lessThan:(d,f)=>d<f,lessThanOrEqual:(d,f)=>d<=f,greaterThan:(d,f)=>d>f,greaterThanOrEqual:(d,
f)=>d>=f,equal:(d,f)=>d===f,notEqual:(d,f)=>d!==f});e.__ZERO=e.BigInt(0);e.__MAX_SAFE=e.BigInt(Number.MAX_SAFE_INTEGER);e.__MIN_SAFE=e.BigInt(-Number.MAX_SAFE_INTEGER);e.numberIfSafe=d=>e.lessThan(d,e.__MAX_SAFE)&&e.greaterThan(d,e.__MIN_SAFE)?e.toNumber(d):d;e.BigUp=d=>e.__isBigInt(d)?d:e.BigInt(d)},function(F,P,b){(function(e,d){F.exports=d()})(this,function(){var e=Math.imul,d=Math.clz32,f=Math.abs,h=Math.max,p=Math.floor;class g extends Array{constructor(a,c){if(super(a),this.sign=c,a>g.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded");
}static BigInt(a){var c=Number.isFinite;if("number"==typeof a){if(0===a)return g.__zero();if(g.__isOneDigitInt(a))return 0>a?g.__oneDigit(-a,!0):g.__oneDigit(a,!1);if(!c(a)||p(a)!==a)throw new RangeError("The number "+a+" cannot be converted to BigInt because it is not an integer");return g.__fromDouble(a)}if("string"==typeof a){c=g.__fromString(a);if(null===c)throw new SyntaxError("Cannot convert "+a+" to a BigInt");return c}if("boolean"==typeof a)return!0===a?g.__oneDigit(1,!1):g.__zero();if("object"==
typeof a){if(a.constructor===g)return a;a=g.__toPrimitive(a);return g.BigInt(a)}throw new TypeError("Cannot convert "+a+" to a BigInt");}toDebugString(){const a=["BigInt["];for(const c of this)a.push((c?(c>>>0).toString(16):c)+", ");return a.push("]"),a.join("")}toString(a){a=void 0===a?10:a;if(2>a||36<a)throw new RangeError("toString() radix argument must be between 2 and 36");return 0===this.length?"0":0==(a&a-1)?g.__toStringBasePowerOfTwo(this,a):g.__toStringGeneric(this,a,!1)}static toNumber(a){var c=
a.length;if(0===c)return 0;if(1===c){var n=a.__unsignedDigit(0);return a.sign?-n:n}var m=a.__digit(c-1),k=g.__clz30(m);n=30*c-k;if(1024<n)return a.sign?-Infinity:1/0;--n;let u=c-1;var l=k+3;k=(32===l?0:m<<l)>>>12;const q=l-12;c=12<=l?0:m<<20+l;l=20+l;for(0<q&&0<u&&(u--,m=a.__digit(u),k|=m>>>30-q,c=m<<q+2,l=q+2);0<l&&0<u;)u--,m=a.__digit(u),c|=30<=l?m<<l-30:m>>>30-l,l-=30;m=g.__decideRounding(a,l,u,m);if((1===m||0===m&&1==(1&c))&&(c=c+1>>>0,0===c&&(k++,0!=k>>>20&&(k=0,n++,1023<n))))return a.sign?-Infinity:
1/0;a=a.sign?-2147483648:0;return n=n+1023<<20,g.__kBitConversionInts[1]=a|n|k,g.__kBitConversionInts[0]=c,g.__kBitConversionDouble[0]}static unaryMinus(a){if(0===a.length)return a;const c=a.__copy();return c.sign=!a.sign,c}static bitwiseNot(a){return a.sign?g.__absoluteSubOne(a).__trim():g.__absoluteAddOne(a,!0)}static exponentiate(a,c){if(c.sign)throw new RangeError("Exponent must be positive");if(0===c.length)return g.__oneDigit(1,!1);if(0===a.length)return a;if(1===a.length&&1===a.__digit(0))return a.sign&&
0==(1&c.__digit(0))?g.unaryMinus(a):a;if(1<c.length)throw new RangeError("BigInt too big");c=c.__unsignedDigit(0);if(1===c)return a;if(c>=g.__kMaxLengthBits)throw new RangeError("BigInt too big");if(1===a.length&&2===a.__digit(0)){var n=1+(0|c/30);a=new g(n,a.sign&&0!=(1&c));a.__initializeDigits();return a.__setDigit(n-1,1<<c%30),a}n=null;let m=a;0!=(1&c)&&(n=a);for(c>>=1;0!==c;c>>=1)m=g.multiply(m,m),0!=(1&c)&&(null===n?n=m:n=g.multiply(n,m));return n}static multiply(a,c){if(0===a.length)return a;
if(0===c.length)return c;var n=a.length+c.length;30<=a.__clzmsd()+c.__clzmsd()&&n--;n=new g(n,a.sign!==c.sign);n.__initializeDigits();for(let m=0;m<a.length;m++)g.__multiplyAccumulate(c,a.__digit(m),n,m);return n.__trim()}static divide(a,c){if(0===c.length)throw new RangeError("Division by zero");if(0>g.__absoluteCompare(a,c))return g.__zero();const n=a.sign!==c.sign,m=c.__unsignedDigit(0);if(1===c.length&&32767>=m){if(1===m)return n===a.sign?a:g.unaryMinus(a);a=g.__absoluteDivSmall(a,m,null)}else a=
g.__absoluteDivLarge(a,c,!0,!1);return a.sign=n,a.__trim()}static remainder(a,c){if(0===c.length)throw new RangeError("Division by zero");if(0>g.__absoluteCompare(a,c))return a;const n=c.__unsignedDigit(0);if(1===c.length&&32767>=n){if(1===n)return g.__zero();c=g.__absoluteModSmall(a,n);return 0===c?g.__zero():g.__oneDigit(c,a.sign)}c=g.__absoluteDivLarge(a,c,!1,!0);return c.sign=a.sign,c.__trim()}static add(a,c){const n=a.sign;return n===c.sign?g.__absoluteAdd(a,c,n):0<=g.__absoluteCompare(a,c)?
g.__absoluteSub(a,c,n):g.__absoluteSub(c,a,!n)}static subtract(a,c){const n=a.sign;return n===c.sign?0<=g.__absoluteCompare(a,c)?g.__absoluteSub(a,c,n):g.__absoluteSub(c,a,!n):g.__absoluteAdd(a,c,n)}static leftShift(a,c){return 0===c.length||0===a.length?a:c.sign?g.__rightShiftByAbsolute(a,c):g.__leftShiftByAbsolute(a,c)}static signedRightShift(a,c){return 0===c.length||0===a.length?a:c.sign?g.__leftShiftByAbsolute(a,c):g.__rightShiftByAbsolute(a,c)}static unsignedRightShift(){throw new TypeError("BigInts have no unsigned right shift; use >> instead");
}static lessThan(a,c){return 0>g.__compareToBigInt(a,c)}static lessThanOrEqual(a,c){return 0>=g.__compareToBigInt(a,c)}static greaterThan(a,c){return 0<g.__compareToBigInt(a,c)}static greaterThanOrEqual(a,c){return 0<=g.__compareToBigInt(a,c)}static equal(a,c){if(a.sign!==c.sign||a.length!==c.length)return!1;for(let n=0;n<a.length;n++)if(a.__digit(n)!==c.__digit(n))return!1;return!0}static notEqual(a,c){return!g.equal(a,c)}static bitwiseAnd(a,c){if(!a.sign&&!c.sign)return g.__absoluteAnd(a,c).__trim();
if(a.sign&&c.sign){const n=h(a.length,c.length)+1;a=g.__absoluteSubOne(a,n);c=g.__absoluteSubOne(c);return a=g.__absoluteOr(a,c,a),g.__absoluteAddOne(a,!0,a).__trim()}a.sign&&([a,c]=[c,a]);return g.__absoluteAndNot(a,g.__absoluteSubOne(c)).__trim()}static bitwiseXor(a,c){if(!a.sign&&!c.sign)return g.__absoluteXor(a,c).__trim();if(a.sign&&c.sign){var n=h(a.length,c.length);a=g.__absoluteSubOne(a,n);c=g.__absoluteSubOne(c);return g.__absoluteXor(a,c,a).__trim()}n=h(a.length,c.length)+1;a.sign&&([a,
c]=[c,a]);c=g.__absoluteSubOne(c,n);return c=g.__absoluteXor(c,a,c),g.__absoluteAddOne(c,!0,c).__trim()}static bitwiseOr(a,c){const n=h(a.length,c.length);if(!a.sign&&!c.sign)return g.__absoluteOr(a,c).__trim();if(a.sign&&c.sign)return a=g.__absoluteSubOne(a,n),c=g.__absoluteSubOne(c),a=g.__absoluteAnd(a,c,a),g.__absoluteAddOne(a,!0,a).__trim();a.sign&&([a,c]=[c,a]);c=g.__absoluteSubOne(c,n);return c=g.__absoluteAndNot(c,a,c),g.__absoluteAddOne(c,!0,c).__trim()}static asIntN(a,c){if(0===c.length)return c;
if(a=p(a),0>a)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===a)return g.__zero();if(a>=g.__kMaxLengthBits)return c;const n=0|(a+29)/30;if(c.length<n)return c;const m=c.__unsignedDigit(n-1),k=1<<(a-1)%30;if(c.length===n&&m<k)return c;if((m&k)!==k)return g.__truncateToNBits(a,c);if(!c.sign)return g.__truncateAndSubFromPowerOfTwo(a,c,!0);if(0==(m&k-1)){for(let u=n-2;0<=u;u--)if(0!==c.__digit(u))return g.__truncateAndSubFromPowerOfTwo(a,c,!1);return c.length===n&&m===
k?c:g.__truncateToNBits(a,c)}return g.__truncateAndSubFromPowerOfTwo(a,c,!1)}static asUintN(a,c){if(0===c.length)return c;if(a=p(a),0>a)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(0===a)return g.__zero();if(c.sign){if(a>g.__kMaxLengthBits)throw new RangeError("BigInt too big");return g.__truncateAndSubFromPowerOfTwo(a,c,!1)}if(a>=g.__kMaxLengthBits)return c;const n=0|(a+29)/30;if(c.length<n)return c;const m=a%30;return c.length!=n||0!==m&&0!=c.__digit(n-1)>>>m?g.__truncateToNBits(a,
c):c}static ADD(a,c){if(a=g.__toPrimitive(a),c=g.__toPrimitive(c),"string"==typeof a)return"string"!=typeof c&&(c=c.toString()),a+c;if("string"==typeof c)return a.toString()+c;if(a=g.__toNumeric(a),c=g.__toNumeric(c),g.__isBigInt(a)&&g.__isBigInt(c))return g.add(a,c);if("number"==typeof a&&"number"==typeof c)return a+c;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");}static LT(a,c){return g.__compare(a,c,0)}static LE(a,c){return g.__compare(a,c,1)}static GT(a,c){return g.__compare(a,
c,2)}static GE(a,c){return g.__compare(a,c,3)}static EQ(a,c){for(;;){if(g.__isBigInt(a))return g.__isBigInt(c)?g.equal(a,c):g.EQ(c,a);if("number"==typeof a){if(g.__isBigInt(c))return g.__equalToNumber(c,a);if("object"!=typeof c)return a==c;c=g.__toPrimitive(c)}else if("string"==typeof a){if(g.__isBigInt(c))return a=g.__fromString(a),null!==a&&g.equal(a,c);if("object"!=typeof c)return a==c;c=g.__toPrimitive(c)}else if("boolean"==typeof a){if(g.__isBigInt(c))return g.__equalToNumber(c,+a);if("object"!=
typeof c)return a==c;c=g.__toPrimitive(c)}else if("symbol"==typeof a){if(g.__isBigInt(c))return!1;if("object"!=typeof c)return a==c;c=g.__toPrimitive(c)}else if("object"==typeof a){if("object"==typeof c&&c.constructor!==g)return a==c;a=g.__toPrimitive(a)}else return a==c}}static NE(a,c){return!g.EQ(a,c)}static __zero(){return new g(0,!1)}static __oneDigit(a,c){c=new g(1,c);return c.__setDigit(0,a),c}__copy(){const a=new g(this.length,this.sign);for(let c=0;c<this.length;c++)a[c]=this[c];return a}__trim(){let a=
this.length,c=this[a-1];for(;0===c;)a--,c=this[a-1],this.pop();return 0===a&&(this.sign=!1),this}__initializeDigits(){for(let a=0;a<this.length;a++)this[a]=0}static __decideRounding(a,c,n,m){if(0<c)return-1;if(0>c)c=-c-1;else{if(0===n)return-1;n--;m=a.__digit(n);c=29}c=1<<c;if(0==(m&c))return-1;if(--c,0!=(m&c))return 1;for(;0<n;)if(n--,0!==a.__digit(n))return 1;return 0}static __fromDouble(a){g.__kBitConversionDouble[0]=a;var c=(2047&g.__kBitConversionInts[1]>>>20)-1023,n=(0|c/30)+1;a=new g(n,0>a);
let m=1048575&g.__kBitConversionInts[1]|1048576,k=g.__kBitConversionInts[0];c%=30;let u;if(20>c){var l=20-c;u=l+32;c=m>>>l;m=m<<32-l|k>>>l;k<<=32-l}else 20===c?(u=32,c=m,m=k):(l=c-20,u=32-l,c=m<<l|k>>>32-l,m=k<<l),k=0;a.__setDigit(n-1,c);for(n-=2;0<=n;n--)0<u?(u-=30,c=m>>>2,m=m<<30|k>>>2,k<<=30):c=0,a.__setDigit(n,c);return a.__trim()}static __isWhitespace(a){return!!(13>=a&&9<=a)||(159>=a?32==a:131071>=a?160==a||5760==a:196607>=a?(a&=131071,10>=a||40==a||41==a||47==a||95==a||4096==a):65279==a)}static __fromString(a,
c){c=void 0===c?0:c;let n=0;const m=a.length;let k=0;if(k===m)return g.__zero();let u=a.charCodeAt(k);for(;g.__isWhitespace(u);){if(++k===m)return g.__zero();u=a.charCodeAt(k)}if(43===u){if(++k===m)return null;u=a.charCodeAt(k);n=1}else if(45===u){if(++k===m)return null;u=a.charCodeAt(k);n=-1}if(0===c){if(c=10,48===u){if(++k===m)return g.__zero();if(u=a.charCodeAt(k),88===u||120===u){if(c=16,++k===m)return null;u=a.charCodeAt(k)}else if(79===u||111===u){if(c=8,++k===m)return null;u=a.charCodeAt(k)}else if(66===
u||98===u){if(c=2,++k===m)return null;u=a.charCodeAt(k)}}}else if(16===c&&48===u){if(++k===m)return g.__zero();if(u=a.charCodeAt(k),88===u||120===u){if(++k===m)return null;u=a.charCodeAt(k)}}if(0!=n&&10!==c)return null;for(;48===u;){if(++k===m)return g.__zero();u=a.charCodeAt(k)}var l=m-k;let q=g.__kMaxBitsPerChar[c];var z=g.__kBitsPerCharTableMultiplier-1;if(l>1073741824/q)return null;l=new g(0|((q*l+z>>>g.__kBitsPerCharTableShift)+29)/30,!1);const r=10>c?c:10,t=10<c?c-10:0;if(0==(c&c-1)){q>>=g.__kBitsPerCharTableShift;
c=[];var x=[],v=!1;do{for(var B=0,I=0;;){if(u-48>>>0<r)z=u-48;else if((32|u)-97>>>0<t)z=(32|u)-87;else{v=!0;break}if(I+=q,B=B<<q|z,++k===m){v=!0;break}if(u=a.charCodeAt(k),30<I+q)break}c.push(B);x.push(I)}while(!v);g.__fillFromParts(l,c,x)}else{l.__initializeDigits();x=!1;v=0;do{B=0;for(I=1;;){if(u-48>>>0<r)z=u-48;else if((32|u)-97>>>0<t)z=(32|u)-87;else{x=!0;break}const M=I*c;if(1073741823<M)break;if(I=M,B=B*c+z,v++,++k===m){x=!0;break}u=a.charCodeAt(k)}z=30*g.__kBitsPerCharTableMultiplier-1;l.__inplaceMultiplyAdd(I,
B,0|(q*v+z>>>g.__kBitsPerCharTableShift)/30)}while(!x)}if(k!==m){if(!g.__isWhitespace(u))return null;for(k++;k<m;k++)if(u=a.charCodeAt(k),!g.__isWhitespace(u))return null}return l.sign=-1==n,l.__trim()}static __fillFromParts(a,c,n){let m=0,k=0,u=0;for(let l=c.length-1;0<=l;l--){const q=c[l],z=n[l];k|=q<<u;u+=z;30===u?(a.__setDigit(m++,k),u=0,k=0):30<u&&(a.__setDigit(m++,1073741823&k),u-=30,k=q>>>z-u)}if(0!==k){if(m>=a.length)throw Error("implementation bug");a.__setDigit(m++,k)}for(;m<a.length;m++)a.__setDigit(m,
0)}static __toStringBasePowerOfTwo(a,c){const n=a.length;var m=c-1;m=(85&m>>>1)+(85&m);m=(51&m>>>2)+(51&m);m=(15&m>>>4)+(15&m);--c;const k=a.__digit(n-1);var u=g.__clz30(k),l=0|(30*n-u+m-1)/m;if(a.sign&&l++,268435456<l)throw Error("string too long");u=Array(l);--l;var q=0,z=0;for(let r=0;r<n-1;r++){const t=a.__digit(r);q=(q|t<<z)&c;u[l--]=g.__kConversionChars[q];z=m-z;q=t>>>z;for(z=30-z;z>=m;)u[l--]=g.__kConversionChars[q&c],q>>>=m,z-=m}u[l--]=g.__kConversionChars[(q|k<<z)&c];for(q=k>>>m-z;0!==q;)u[l--]=
g.__kConversionChars[q&c],q>>>=m;if(a.sign&&(u[l--]="-"),-1!=l)throw Error("implementation bug");return u.join("")}static __toStringGeneric(a,c,n){var m=a.length;if(0===m)return"";if(1===m)return c=a.__unsignedDigit(0).toString(c),!1===n&&a.sign&&(c="-"+c),c;var k=30*m-g.__clz30(a.__digit(m-1));m=g.__kMaxBitsPerChar[c]-1;k*=g.__kBitsPerCharTableMultiplier;m=(0|(k+(m-1))/m)+1>>1;k=g.exponentiate(g.__oneDigit(c,!1),g.__oneDigit(m,!1));var u=k.__unsignedDigit(0);if(1===k.length&&32767>=u){k=new g(a.length,
!1);k.__initializeDigits();var l=0;for(let q=2*a.length-1;0<=q;q--)l=l<<15|a.__halfDigit(q),k.__setHalfDigit(q,0|l/u),l=0|l%u;u=l.toString(c)}else u=g.__absoluteDivLarge(a,k,!0,!0),k=u.quotient,u=u.remainder.__trim(),u=g.__toStringGeneric(u,c,!0);k.__trim();for(c=g.__toStringGeneric(k,c,!0);u.length<m;)u="0"+u;return!1===n&&a.sign&&(c="-"+c),c+u}static __unequalSign(a){return a?-1:1}static __absoluteGreater(a){return a?-1:1}static __absoluteLess(a){return a?1:-1}static __compareToBigInt(a,c){const n=
a.sign;if(n!==c.sign)return g.__unequalSign(n);a=g.__absoluteCompare(a,c);return 0<a?g.__absoluteGreater(n):0>a?g.__absoluteLess(n):0}static __compareToNumber(a,c){if(g.__isOneDigitInt(c)){const n=a.sign,m=0>c;if(n!==m)return g.__unequalSign(n);if(0===a.length){if(m)throw Error("implementation bug");return 0===c?0:-1}if(1<a.length)return g.__absoluteGreater(n);c=f(c);a=a.__unsignedDigit(0);return a>c?g.__absoluteGreater(n):a<c?g.__absoluteLess(n):0}return g.__compareToDouble(a,c)}static __compareToDouble(a,
c){if(c!==c)return c;if(c===1/0)return-1;if(-Infinity===c)return 1;const n=a.sign;if(n!==0>c)return g.__unequalSign(n);if(0===c)throw Error("implementation bug: should be handled elsewhere");if(0===a.length)return-1;g.__kBitConversionDouble[0]=c;c=2047&g.__kBitConversionInts[1]>>>20;if(2047==c)throw Error("implementation bug: handled elsewhere");var m=c-1023;if(0>m)return g.__absoluteGreater(n);c=a.length;var k=a.__digit(c-1),u=g.__clz30(k),l=30*c-u;m+=1;if(l<m)return g.__absoluteLess(n);if(l>m)return g.__absoluteGreater(n);
m=1048576|1048575&g.__kBitConversionInts[1];let q=g.__kBitConversionInts[0];u=29-u;if(u!==(0|(l-1)%30))throw Error("implementation bug");if(20>u){var z=20-u;u=z+32;l=m>>>z;m=m<<32-z|q>>>z;q<<=32-z}else 20===u?(u=32,l=m,m=q):(z=u-20,u=32-z,l=m<<z|q>>>32-z,m=q<<z),q=0;if(k>>>=0,l>>>=0,k>l)return g.__absoluteGreater(n);if(k<l)return g.__absoluteLess(n);for(c-=2;0<=c;c--){0<u?(u-=30,l=m>>>2,m=m<<30|q>>>2,q<<=30):l=0;k=a.__unsignedDigit(c);if(k>l)return g.__absoluteGreater(n);if(k<l)return g.__absoluteLess(n)}if(0!==
m||0!==q){if(0===u)throw Error("implementation bug");return g.__absoluteLess(n)}return 0}static __equalToNumber(a,c){return g.__isOneDigitInt(c)?0===c?0===a.length:1===a.length&&a.sign===0>c&&a.__unsignedDigit(0)===f(c):0===g.__compareToDouble(a,c)}static __comparisonResultToBool(a,c){return 0===c?0>a:1===c?0>=a:2===c?0<a:3===c?0<=a:void 0}static __compare(a,c,n){if(a=g.__toPrimitive(a),c=g.__toPrimitive(c),"string"==typeof a&&"string"==typeof c)switch(n){case 0:return a<c;case 1:return a<=c;case 2:return a>
c;case 3:return a>=c}if(g.__isBigInt(a)&&"string"==typeof c)return c=g.__fromString(c),null!==c&&g.__comparisonResultToBool(g.__compareToBigInt(a,c),n);if("string"==typeof a&&g.__isBigInt(c))return a=g.__fromString(a),null!==a&&g.__comparisonResultToBool(g.__compareToBigInt(a,c),n);if(a=g.__toNumeric(a),c=g.__toNumeric(c),g.__isBigInt(a)){if(g.__isBigInt(c))return g.__comparisonResultToBool(g.__compareToBigInt(a,c),n);if("number"!=typeof c)throw Error("implementation bug");return g.__comparisonResultToBool(g.__compareToNumber(a,
c),n)}if("number"!=typeof a)throw Error("implementation bug");if(g.__isBigInt(c))return g.__comparisonResultToBool(g.__compareToNumber(c,a),2^n);if("number"!=typeof c)throw Error("implementation bug");return 0===n?a<c:1===n?a<=c:2===n?a>c:3===n?a>=c:void 0}__clzmsd(){return g.__clz30(this.__digit(this.length-1))}static __absoluteAdd(a,c,n){if(a.length<c.length)return g.__absoluteAdd(c,a,n);if(0===a.length)return a;if(0===c.length)return a.sign===n?a:g.unaryMinus(a);var m=a.length;(0===a.__clzmsd()||
c.length===a.length&&0===c.__clzmsd())&&m++;n=new g(m,n);let k=m=0;for(;k<c.length;k++){const u=a.__digit(k)+c.__digit(k)+m;m=u>>>30;n.__setDigit(k,1073741823&u)}for(;k<a.length;k++)c=a.__digit(k)+m,m=c>>>30,n.__setDigit(k,1073741823&c);return k<n.length&&n.__setDigit(k,m),n.__trim()}static __absoluteSub(a,c,n){if(0===a.length)return a;if(0===c.length)return a.sign===n?a:g.unaryMinus(a);n=new g(a.length,n);let m=0,k=0;for(;k<c.length;k++){const u=a.__digit(k)-c.__digit(k)-m;m=1&u>>>30;n.__setDigit(k,
1073741823&u)}for(;k<a.length;k++)c=a.__digit(k)-m,m=1&c>>>30,n.__setDigit(k,1073741823&c);return n.__trim()}static __absoluteAddOne(a,c,n){n=void 0===n?null:n;const m=a.length;null===n?n=new g(m,c):n.sign=c;c=1;for(let k=0;k<m;k++){const u=a.__digit(k)+c;c=u>>>30;n.__setDigit(k,1073741823&u)}return 0!=c&&n.__setDigitGrow(m,1),n}static __absoluteSubOne(a,c){const n=a.length;c=c||n;const m=new g(c,!1);let k=1;for(let u=0;u<n;u++){const l=a.__digit(u)-k;k=1&l>>>30;m.__setDigit(u,1073741823&l)}if(0!=
k)throw Error("implementation bug");for(a=n;a<c;a++)m.__setDigit(a,0);return m}static __absoluteAnd(a,c,n){n=void 0===n?null:n;var m=a.length,k=c.length;let u=k;m<k&&(u=m,m=a,a=c,c=m);m=u;null===n?n=new g(m,!1):m=n.length;for(k=0;k<u;k++)n.__setDigit(k,a.__digit(k)&c.__digit(k));for(;k<m;k++)n.__setDigit(k,0);return n}static __absoluteAndNot(a,c,n){n=void 0===n?null:n;const m=a.length;var k=c.length;let u=k;m<k&&(u=m);k=m;null===n?n=new g(k,!1):k=n.length;let l=0;for(;l<u;l++)n.__setDigit(l,a.__digit(l)&
~c.__digit(l));for(;l<m;l++)n.__setDigit(l,a.__digit(l));for(;l<k;l++)n.__setDigit(l,0);return n}static __absoluteOr(a,c,n){n=void 0===n?null:n;let m=a.length;var k=c.length;let u=k;if(m<k){u=m;var l=a;a=c;m=k;c=l}k=m;null===n?n=new g(k,!1):k=n.length;for(l=0;l<u;l++)n.__setDigit(l,a.__digit(l)|c.__digit(l));for(;l<m;l++)n.__setDigit(l,a.__digit(l));for(;l<k;l++)n.__setDigit(l,0);return n}static __absoluteXor(a,c,n){n=void 0===n?null:n;let m=a.length;var k=c.length;let u=k;if(m<k){u=m;var l=a;a=c;
m=k;c=l}k=m;null===n?n=new g(k,!1):k=n.length;for(l=0;l<u;l++)n.__setDigit(l,a.__digit(l)^c.__digit(l));for(;l<m;l++)n.__setDigit(l,a.__digit(l));for(;l<k;l++)n.__setDigit(l,0);return n}static __absoluteCompare(a,c){var n=a.length-c.length;if(0!=n)return n;for(n=a.length-1;0<=n&&a.__digit(n)===c.__digit(n);)n--;return 0>n?0:a.__unsignedDigit(n)>c.__unsignedDigit(n)?1:-1}static __multiplyAccumulate(a,c,n,m){if(0!==c){var k=32767&c,u=c>>>15,l=c=0;for(let t,x=0;x<a.length;x++,m++){t=n.__digit(m);var q=
a.__digit(x),z=32767&q,r=q>>>15;q=g.__imul(z,k);z=g.__imul(z,u);const v=g.__imul(r,k);r=g.__imul(r,u);t+=l+q+c;c=t>>>30;t&=1073741823;t+=((32767&z)<<15)+((32767&v)<<15);c+=t>>>30;l=r+(z>>>15)+(v>>>15);n.__setDigit(m,1073741823&t)}for(;0!=c||0!==l;m++)a=n.__digit(m),a+=c+l,l=0,c=a>>>30,n.__setDigit(m,1073741823&a)}}static __internalMultiplyAdd(a,c,n,m,k){let u=0;for(let z=0;z<m;z++){var l=a.__digit(z),q=g.__imul(32767&l,c);l=g.__imul(l>>>15,c);q=q+((32767&l)<<15)+u+n;n=q>>>30;u=l>>>15;k.__setDigit(z,
1073741823&q)}if(k.length>m)for(k.__setDigit(m++,n+u);m<k.length;)k.__setDigit(m++,0);else if(0!==n+u)throw Error("implementation bug");}__inplaceMultiplyAdd(a,c,n){n>this.length&&(n=this.length);const m=32767&a;a>>>=15;let k=0;for(let z=0;z<n;z++){var u=this.__digit(z),l=32767&u,q=u>>>15;u=g.__imul(l,m);l=g.__imul(l,a);const r=g.__imul(q,m);q=g.__imul(q,a);u=c+u+k;k=u>>>30;u&=1073741823;u+=((32767&l)<<15)+((32767&r)<<15);k+=u>>>30;c=q+(l>>>15)+(r>>>15);this.__setDigit(z,1073741823&u)}if(0!=k||0!==
c)throw Error("implementation bug");}static __absoluteDivSmall(a,c,n){n=void 0===n?null:n;null===n&&(n=new g(a.length,!1));let m=0;for(let k,u=2*a.length-1;0<=u;u-=2){k=(m<<15|a.__halfDigit(u))>>>0;const l=0|k/c;m=0|k%c;k=(m<<15|a.__halfDigit(u-1))>>>0;const q=0|k/c;m=0|k%c;n.__setDigit(u>>>1,l<<15|q)}return n}static __absoluteModSmall(a,c){let n=0;for(let m=2*a.length-1;0<=m;m--)n=0|((n<<15|a.__halfDigit(m))>>>0)%c;return n}static __absoluteDivLarge(a,c,n,m){const k=c.__halfDigitLength(),u=c.length;
var l=a.__halfDigitLength()-k;let q=null;n&&(q=new g(l+2>>>1,!1),q.__initializeDigits());const z=new g(k+2>>>1,!1);z.__initializeDigits();const r=g.__clz15(c.__halfDigit(k-1));0<r&&(c=g.__specialLeftShift(c,r,0));a=g.__specialLeftShift(a,r,1);const t=c.__halfDigit(k-1);let x=0;for(let v,B=l;0<=B;B--){v=32767;l=a.__halfDigit(B+k);if(l!==t){l=(l<<15|a.__halfDigit(B+k-1))>>>0;v=0|l/t;l=0|l%t;const I=c.__halfDigit(k-2),M=a.__halfDigit(B+k-2);for(;g.__imul(v,I)>>>0>(l<<16|M)>>>0&&(v--,l+=t,!(32767<l)););
}g.__internalMultiplyAdd(c,v,0,u,z);l=a.__inplaceSub(z,B,k+1);0!==l&&(l=a.__inplaceAdd(c,B,k),a.__setHalfDigit(B+k,32767&a.__halfDigit(B+k)+l),v--);n&&(1&B?x=v<<15:q.__setDigit(B>>>1,x|v))}if(m)return a.__inplaceRightShift(r),n?{quotient:q,remainder:a}:a;if(n)return q;throw Error("unreachable");}static __clz15(a){return g.__clz30(a)-15}__inplaceAdd(a,c,n){let m=0;for(let k=0;k<n;k++){const u=this.__halfDigit(c+k)+a.__halfDigit(k)+m;m=u>>>15;this.__setHalfDigit(c+k,32767&u)}return m}__inplaceSub(a,
c,n){let m=0;if(1&c){c>>=1;for(var k=this.__digit(c),u=32767&k,l=0;l<n-1>>>1;l++){var q=a.__digit(l);k=(k>>>15)-(32767&q)-m;m=1&k>>>15;this.__setDigit(c+l,(32767&k)<<15|32767&u);k=this.__digit(c+l+1);u=(32767&k)-(q>>>15)-m;m=1&u>>>15}q=a.__digit(l);const z=(k>>>15)-(32767&q)-m;m=1&z>>>15;this.__setDigit(c+l,(32767&z)<<15|32767&u);if(c+l+1>=this.length)throw new RangeError("out of bounds");0==(1&n)&&(k=this.__digit(c+l+1),u=(32767&k)-(q>>>15)-m,m=1&u>>>15,this.__setDigit(c+a.length,1073709056&k|32767&
u))}else{c>>=1;for(u=0;u<a.length-1;u++)k=this.__digit(c+u),q=a.__digit(u),l=(32767&k)-(32767&q)-m,m=1&l>>>15,k=(k>>>15)-(q>>>15)-m,m=1&k>>>15,this.__setDigit(c+u,(32767&k)<<15|32767&l);l=this.__digit(c+u);a=a.__digit(u);k=(32767&l)-(32767&a)-m;m=1&k>>>15;q=0;0==(1&n)&&(q=(l>>>15)-(a>>>15)-m,m=1&q>>>15);this.__setDigit(c+u,(32767&q)<<15|32767&k)}return m}__inplaceRightShift(a){if(0!==a){var c=this.__digit(0)>>>a,n=this.length-1;for(let m=0;m<n;m++){const k=this.__digit(m+1);this.__setDigit(m,1073741823&
k<<30-a|c);c=k>>>a}this.__setDigit(n,c)}}static __specialLeftShift(a,c,n){const m=a.length,k=new g(m+n,!1);if(0===c){for(c=0;c<m;c++)k.__setDigit(c,a.__digit(c));return 0<n&&k.__setDigit(m,0),k}let u=0;for(let l=0;l<m;l++){const q=a.__digit(l);k.__setDigit(l,1073741823&q<<c|u);u=q>>>30-c}return 0<n&&k.__setDigit(m,u),k}static __leftShiftByAbsolute(a,c){var n=g.__toShiftAmount(c);if(0>n)throw new RangeError("BigInt too big");c=0|n/30;var m=n%30;const k=a.length,u=0!==m&&0!=a.__digit(k-1)>>>30-m;var l=
k+c+(u?1:0);n=new g(l,a.sign);if(0===m){for(m=0;m<c;m++)n.__setDigit(m,0);for(;m<l;m++)n.__setDigit(m,a.__digit(m-c))}else{l=0;for(var q=0;q<c;q++)n.__setDigit(q,0);for(q=0;q<k;q++){const z=a.__digit(q);n.__setDigit(q+c,1073741823&z<<m|l);l=z>>>30-m}if(u)n.__setDigit(k+c,l);else if(0!==l)throw Error("implementation bug");}return n.__trim()}static __rightShiftByAbsolute(a,c){var n=a.length,m=a.sign,k=g.__toShiftAmount(c);if(0>k)return g.__rightShiftByMaximum(m);c=0|k/30;var u=k%30,l=n-c;if(0>=l)return g.__rightShiftByMaximum(m);
k=!1;if(m)if(0!=(a.__digit(c)&(1<<u)-1))k=!0;else for(var q=0;q<c;q++)if(0!==a.__digit(q)){k=!0;break}k&&0===u&&0==~a.__digit(n-1)&&l++;m=new g(l,m);if(0===u)for(m.__setDigit(l-1,0),u=c;u<n;u++)m.__setDigit(u-c,a.__digit(u));else{l=a.__digit(c)>>>u;n=n-c-1;for(q=0;q<n;q++){const z=a.__digit(q+c+1);m.__setDigit(q,1073741823&z<<30-u|l);l=z>>>u}m.__setDigit(n,l)}return k&&(m=g.__absoluteAddOne(m,!0,m)),m.__trim()}static __rightShiftByMaximum(a){return a?g.__oneDigit(1,!0):g.__zero()}static __toShiftAmount(a){if(1<
a.length)return-1;a=a.__unsignedDigit(0);return a>g.__kMaxLengthBits?-1:a}static __toPrimitive(a,c){c=void 0===c?"default":c;if("object"!=typeof a||a.constructor===g)return a;if("undefined"!=typeof Symbol&&"symbol"==typeof Symbol.toPrimitive){const n=a[Symbol.toPrimitive];if(n){a=n(c);if("object"!=typeof a)return a;throw new TypeError("Cannot convert object to primitive value");}}if(c=a.valueOf)if(c=c.call(a),"object"!=typeof c)return c;if(c=a.toString)if(a=c.call(a),"object"!=typeof a)return a;throw new TypeError("Cannot convert object to primitive value");
}static __toNumeric(a){return g.__isBigInt(a)?a:+a}static __isBigInt(a){return"object"==typeof a&&null!==a&&a.constructor===g}static __truncateToNBits(a,c){var n=0|(a+29)/30;const m=new g(n,c.sign);--n;for(let k=0;k<n;k++)m.__setDigit(k,c.__digit(k));c=c.__digit(n);0!=a%30&&(a=32-a%30,c=c<<a>>>a);return m.__setDigit(n,c),m.__trim()}static __truncateAndSubFromPowerOfTwo(a,c,n){var m=Math.min,k=0|(a+29)/30;n=new g(k,n);let u=0;--k;var l=0;for(m=m(k,c.length);u<m;u++){const q=0-c.__digit(u)-l;l=1&q>>>
30;n.__setDigit(u,1073741823&q)}for(;u<k;u++)n.__setDigit(u,0|1073741823&-l);c=k<c.length?c.__digit(k):0;a%=30;0==a?l=0-c-l&1073741823:(a=32-a,c=c<<a>>>a,a=1<<32-a,l=a-c-l,l&=a-1);return n.__setDigit(k,l),n.__trim()}__digit(a){return this[a]}__unsignedDigit(a){return this[a]>>>0}__setDigit(a,c){this[a]=0|c}__setDigitGrow(a,c){this[a]=0|c}__halfDigitLength(){const a=this.length;return 32767>=this.__unsignedDigit(a-1)?2*a-1:2*a}__halfDigit(a){return 32767&this[a>>>1]>>>15*(1&a)}__setHalfDigit(a,c){const n=
a>>>1,m=this.__digit(n);this.__setDigit(n,1&a?32767&m|c<<15:1073709056&m|32767&c)}static __digitPow(a,c){let n=1;for(;0<c;)1&c&&(n*=a),c>>>=1,a*=a;return n}static __isOneDigitInt(a){return(1073741823&a)===a}}return g.__kMaxLength=33554432,g.__kMaxLengthBits=g.__kMaxLength<<5,g.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],g.__kBitsPerCharTableShift=5,g.__kBitsPerCharTableMultiplier=1<<g.__kBitsPerCharTableShift,
g.__kConversionChars="0123456789abcdefghijklmnopqrstuvwxyz".split(""),g.__kBitConversionBuffer=new ArrayBuffer(8),g.__kBitConversionDouble=new Float64Array(g.__kBitConversionBuffer),g.__kBitConversionInts=new Int32Array(g.__kBitConversionBuffer),g.__clz30=d?function(a){return d(a)-2}:function(a){var c=Math.LN2,n=Math.log;return 0===a?30:0|29-(0|n(a>>>0)/c)},g.__imul=e||function(a,c){return 0|a*c},g})},function(F,P){[..."abc"].flat();"a".matchAll(/a/g)},function(F,P,b){(function(e,d){(function(f,h){function p(v){delete q[v]}
function g(v){if(z)setTimeout(g,0,v);else{var B=q[v];if(B){z=!0;try{var I=B.callback,M=B.args;switch(M.length){case 0:I();break;case 1:I(M[0]);break;case 2:I(M[0],M[1]);break;case 3:I(M[0],M[1],M[2]);break;default:I.apply(h,M)}}finally{p(v),z=!1}}}}function a(){t=function(v){d.nextTick(function(){g(v)})}}function c(){if(f.postMessage&&!f.importScripts){var v=!0,B=f.onmessage;f.onmessage=function(){v=!1};f.postMessage("","*");f.onmessage=B;return v}}function n(){var v="setImmediate$"+Math.random()+
"$",B=function(I){I.source===f&&"string"===typeof I.data&&0===I.data.indexOf(v)&&g(+I.data.slice(v.length))};f.addEventListener?f.addEventListener("message",B,!1):f.attachEvent("onmessage",B);t=function(I){f.postMessage(v+I,"*")}}function m(){var v=new MessageChannel;v.port1.onmessage=function(B){g(B.data)};t=function(B){v.port2.postMessage(B)}}function k(){var v=r.documentElement;t=function(B){var I=r.createElement("script");I.onreadystatechange=function(){g(B);I.onreadystatechange=null;v.removeChild(I);
I=null};v.appendChild(I)}}function u(){t=function(v){setTimeout(g,0,v)}}if(!f.setImmediate){var l=1,q={},z=!1,r=f.document,t,x=Object.getPrototypeOf&&Object.getPrototypeOf(f);x=x&&x.setTimeout?x:f;"[object process]"==={}.toString.call(f.process)?a():c()?n():f.MessageChannel?m():r&&"onreadystatechange"in r.createElement("script")?k():u();x.setImmediate=function(v){"function"!==typeof v&&(v=new Function(""+v));for(var B=Array(arguments.length-1),I=0;I<B.length;I++)B[I]=arguments[I+1];q[l]={callback:v,
args:B};t(l);return l++};x.clearImmediate=p}})("undefined"===typeof self?"undefined"===typeof e?this:e:self)}).call(this,b(0),b(8))},function(F,P){function b(){throw Error("setTimeout has not been defined");}function e(){throw Error("clearTimeout has not been defined");}function d(q){if(c===setTimeout)return setTimeout(q,0);if((c===b||!c)&&setTimeout)return c=setTimeout,setTimeout(q,0);try{return c(q,0)}catch(z){try{return c.call(null,q,0)}catch(r){return c.call(this,q,0)}}}function f(q){if(n===clearTimeout)return clearTimeout(q);
if((n===e||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(q);try{return n(q)}catch(z){try{return n.call(null,q)}catch(r){return n.call(this,q)}}}function h(){k&&u&&(k=!1,u.length?m=u.concat(m):l=-1,m.length&&p())}function p(){if(!k){var q=d(h);k=!0;for(var z=m.length;z;){u=m;for(m=[];++l<z;)u&&u[l].run();l=-1;z=m.length}u=null;k=!1;f(q)}}function g(q,z){this.fun=q;this.array=z}function a(){}F=F.exports={};try{var c="function"===typeof setTimeout?setTimeout:b}catch(q){c=b}try{var n="function"===
typeof clearTimeout?clearTimeout:e}catch(q){n=e}var m=[],k=!1,u,l=-1;F.nextTick=function(q){var z=Array(arguments.length-1);if(1<arguments.length)for(var r=1;r<arguments.length;r++)z[r-1]=arguments[r];m.push(new g(q,z));1!==m.length||k||d(p)};g.prototype.run=function(){this.fun.apply(null,this.array)};F.title="browser";F.browser=!0;F.env={};F.argv=[];F.version="";F.versions={};F.on=a;F.addListener=a;F.once=a;F.off=a;F.removeListener=a;F.removeAllListeners=a;F.emit=a;F.prependListener=a;F.prependOnceListener=
a;F.listeners=function(q){return[]};F.binding=function(q){throw Error("process.binding is not supported");};F.cwd=function(){return"/"};F.chdir=function(q){throw Error("process.chdir is not supported");};F.umask=function(){return 0}},function(F,P){Sk.asserts={};Sk.asserts.assert=function(b,e){return b};Sk.exportSymbol("Sk.asserts.assert",Sk.asserts.assert);Sk.asserts.fail=function(b){};Sk.exportSymbol("Sk.asserts.fail",Sk.asserts.fail)},function(F,P){Sk.bool_check=function(b,e){if(void 0===b||null===
b||"boolean"!==typeof b)throw Error("must specify "+e+" and it must be a boolean");};Sk.python2={print_function:!1,division:!1,absolute_import:null,unicode_literals:!1,python3:!1,class_repr:!1,inherit_from_object:!1,super_args:!1,octal_number_literal:!1,bankers_rounding:!1,python_version:!1,dunder_round:!1,exceptions:!1,no_long_type:!1,ceil_floor_int:!1,silent_octal_literal:!0};Sk.python3={print_function:!0,division:!0,absolute_import:null,unicode_literals:!0,python3:!0,class_repr:!0,inherit_from_object:!0,
super_args:!0,octal_number_literal:!0,bankers_rounding:!0,python_version:!0,dunder_round:!0,exceptions:!0,no_long_type:!0,ceil_floor_int:!0,silent_octal_literal:!1};Sk.configure=function(b){Sk.output=b.output||Sk.output;Sk.asserts.assert("function"===typeof Sk.output);Sk.filewriter=b.filewriter||Sk.filewriter;Sk.asserts.assert("function"===typeof Sk.filewriter);Sk.debugout=b.debugout||Sk.debugout;Sk.asserts.assert("function"===typeof Sk.debugout);Sk.uncaughtException=b.uncaughtException||Sk.uncaughtException;
Sk.asserts.assert("function"===typeof Sk.uncaughtException);Sk.read=b.read||Sk.read;Sk.asserts.assert("function"===typeof Sk.read);Sk.nonreadopen=b.nonreadopen||!1;Sk.asserts.assert("boolean"===typeof Sk.nonreadopen);Sk.fileopen=b.fileopen||void 0;Sk.asserts.assert("function"===typeof Sk.fileopen||"undefined"===typeof Sk.fileopen);Sk.filewrite=b.filewrite||void 0;Sk.asserts.assert("function"===typeof Sk.filewrite||"undefined"===typeof Sk.filewrite);Sk.timeoutMsg=b.timeoutMsg||Sk.timeoutMsg;Sk.asserts.assert("function"===
typeof Sk.timeoutMsg);Sk.exportSymbol("Sk.timeoutMsg",Sk.timeoutMsg);Sk.sysargv=b.sysargv||Sk.sysargv;Sk.asserts.assert(Sk.isArrayLike(Sk.sysargv));Sk.__future__=b.__future__||Sk.python3;Sk.bool_check(Sk.__future__.print_function,"Sk.__future__.print_function");Sk.bool_check(Sk.__future__.division,"Sk.__future__.division");Sk.bool_check(Sk.__future__.unicode_literals,"Sk.__future__.unicode_literals");Sk.bool_check(Sk.__future__.class_repr,"Sk.__future__.class_repr");Sk.bool_check(Sk.__future__.inherit_from_object,
"Sk.__future__.inherit_from_object");Sk.bool_check(Sk.__future__.super_args,"Sk.__future__.super_args");Sk.bool_check(Sk.__future__.octal_number_literal,"Sk.__future__.octal_number_literal");Sk.bool_check(Sk.__future__.bankers_rounding,"Sk.__future__.bankers_rounding");Sk.bool_check(Sk.__future__.python_version,"Sk.__future__.python_version");Sk.bool_check(Sk.__future__.dunder_round,"Sk.__future__.dunder_round");Sk.bool_check(Sk.__future__.exceptions,"Sk.__future__.exceptions");Sk.bool_check(Sk.__future__.no_long_type,
"Sk.__future__.no_long_type");Sk.bool_check(Sk.__future__.ceil_floor_int,"Sk.__future__.ceil_floor_int");Sk.bool_check(Sk.__future__.silent_octal_literal,"Sk.__future__.silent_octal_literal");Sk.imageProxy=b.imageProxy||"http://localhost:8080/320x";Sk.asserts.assert("string"===typeof Sk.imageProxy||"function"===typeof Sk.imageProxy);Sk.inputfun=b.inputfun||Sk.inputfun;Sk.asserts.assert("function"===typeof Sk.inputfun);Sk.inputfunTakesPrompt=b.inputfunTakesPrompt||!1;Sk.asserts.assert("boolean"===
typeof Sk.inputfunTakesPrompt);Sk.retainGlobals=b.retainglobals||b.retainGlobals||!1;Sk.asserts.assert("boolean"===typeof Sk.retainGlobals);Sk.debugging=b.debugging||!1;Sk.asserts.assert("boolean"===typeof Sk.debugging);Sk.killableWhile=b.killableWhile||!1;Sk.asserts.assert("boolean"===typeof Sk.killableWhile);Sk.killableFor=b.killableFor||!1;Sk.asserts.assert("boolean"===typeof Sk.killableFor);Sk.signals=b.signals;Sk.signals=!0===Sk.signals?{listeners:[],addEventListener(e){Sk.signals.listeners.push(e)},
removeEventListener(e){e=Sk.signals.listeners.indexOf(e);0<=e&&Sk.signals.listeners.splice(e,1)},signal(e,d){for(var f=0;f<Sk.signals.listeners.length;f++)Sk.signals.listeners[f].call(null,e,d)}}:null;Sk.asserts.assert("object"===typeof Sk.signals);Sk.breakpoints=b.breakpoints||function(){return!0};Sk.asserts.assert("function"===typeof Sk.breakpoints);Sk.setTimeout=b.setTimeout;void 0===Sk.setTimeout&&(Sk.setTimeout="function"===typeof setTimeout?function(e,d){setTimeout(e,d)}:function(e,d){e()});
Sk.asserts.assert("function"===typeof Sk.setTimeout);"execLimit"in b&&(Sk.execLimit=b.execLimit);"yieldLimit"in b&&(Sk.yieldLimit=b.yieldLimit);b.syspath&&(Sk.syspath=b.syspath,Sk.asserts.assert(Sk.isArrayLike(Sk.syspath)),Sk.realsyspath=void 0,Sk.sysmodules=new Sk.builtin.dict([]));Sk.misceval.softspace_=!1;Sk.switch_version(Sk.__future__.python3);Sk.builtin.str.$next=Sk.__future__.python3?new Sk.builtin.str("__next__"):new Sk.builtin.str("next");Sk.setupOperators(Sk.__future__.python3);Sk.setupDunderMethods(Sk.__future__.python3);
Sk.setupObjects(Sk.__future__.python3);Sk.token.setupTokens(Sk.__future__.python3)};Sk.exportSymbol("Sk.configure",Sk.configure);Sk.uncaughtException=function(b){throw b;};Sk.uncaughtException=function(b){throw b;};Sk.exportSymbol("Sk.uncaughtException",Sk.uncaughtException);Sk.timeoutMsg=function(){return"Program exceeded run time limit."};Sk.exportSymbol("Sk.timeoutMsg",Sk.timeoutMsg);Sk.execLimit=Number.POSITIVE_INFINITY;Sk.yieldLimit=Number.POSITIVE_INFINITY;Sk.output=function(b){};Sk.read=function(b){if(void 0===
Sk.builtinFiles)throw"skulpt-stdlib.js has not been loaded";if(void 0===Sk.builtinFiles.files[b])throw"File not found: '"+b+"'";return Sk.builtinFiles.files[b]};Sk.sysargv=[];Sk.getSysArgv=function(){return Sk.sysargv};Sk.exportSymbol("Sk.getSysArgv",Sk.getSysArgv);Sk.syspath=[];Sk.inBrowser=void 0!==Sk.global.document;Sk.debugout=function(b){};(function(){void 0!==Sk.global.write?(Sk.output=Sk.global.write,Sk.filewriter=Sk.global.write):void 0!==Sk.global.console&&void 0!==Sk.global.console.log?
(Sk.output=function(b){Sk.global.console.log(b)},Sk.filewriter=Sk.output):void 0!==Sk.global.print&&(Sk.output=Sk.global.print,Sk.filewriter=Sk.output);void 0!==Sk.global.console&&void 0!==Sk.global.console.log?Sk.debugout=function(b){Sk.global.console.log(b)}:void 0!==Sk.global.print&&(Sk.debugout=Sk.global.print)})();Sk.inputfun=function(b){return window.prompt(b)};Sk.setup_method_mappings=function(){};Sk.setupDictIterators=function(b){};Sk.switch_version=function(b){const e={float_:{method_names:["__round__"],
2:[!1],3:[!0]},int_:{method_names:["__round__"],2:[!1],3:[!0]},list:{method_names:["clear","copy","sort"],2:[!1,!1,!0],3:[!0,!0,!0]},dict:{method_names:["has_key","keys","items","values"],2:[!0,!0,!0,!0],3:[!1,!0,!0,!0]}};for(let p in e){const g=Sk.builtin[p],a=e[p].method_names;var d=e[p][3];if(b&&void 0===g.py3$methods)break;else if(void 0===g.py3$methods){g.py3$methods={};for(var f=0;f<a.length;f++){var h=a[f];d[f]&&(g.py3$methods[h]=g.prototype[h].d$def)}}b?f=g.py3$methods:(d=e[p][2],f=g.py2$methods);
for(h=0;h<a.length;h++){const c=a[h];delete g.prototype[c];d[h]&&(g.prototype[c]=new Sk.builtin.method_descriptor(g,f[c]))}}};Sk.exportSymbol("Sk.__future__",Sk.__future__);Sk.exportSymbol("Sk.inputfun",Sk.inputfun)},function(F,P){function b(k,u,l){if(k.hasOwnProperty(u)){const q=k[u];q instanceof Sk.builtin.func&&(k[u]=new Sk.builtin[l](q))}}function e(k){return this.prototype[k.$mangled]}function d(k){k=k.$mangled;const u=this.prototype.tp$mro;for(let l=0;l<u.length;++l){const q=u[l].prototype;
if(q.hasOwnProperty(k))return q[k]}}function f(k,u,l,q){const z=h(l),r=u.prototype;Sk.abstr.setUpInheritance(k,u,z,q);k=new Sk.builtin.str(k);Object.defineProperties(r,{sk$prototypical:{value:!0,writable:!0},tp$bases:{value:l,writable:!0},tp$mro:{value:null,writable:!0},ht$type:{value:!0,writable:!0},ht$name:{value:k,writable:!0},ht$qualname:{value:k,writable:!0}});r.tp$mro=u.$buildMRO();Object.defineProperties(u,{$typeLookup:{value:r.sk$prototypical?e:d,writable:!0},sk$klass:{value:!0,writable:!0}})}
function h(k){function u(t){return t.sk$solidBase||t.sk$solidSlotBase?t:u(t.prototype.tp$base)}0===k.length&&k.push(Sk.builtin.object);let l,q,z,r;for(let t=0;t<k.length;t++){r=k[t];if(!Sk.builtin.checkClass(r))throw new Sk.builtin.TypeError("bases must be 'type' objects");if(r.sk$unacceptableBase)throw new Sk.builtin.TypeError("type '"+r.prototype.tp$name+"' is not an acceptable base type");z=u(r);if(void 0===q)q=z,l=r;else if(!q.$isSubType(z))if(z.$isSubType(q))q=z,l=r;else throw new Sk.builtin.TypeError("multiple bases have instance layout conflicts");
}return l}function p(k,u){const l=u.prototype,q=l.sk$nslots||0;Object.defineProperty(l,"sk$nslots",{value:q+k.length,writable:!0});k.length&&Object.defineProperty(u,"sk$solidSlotBase",{value:!0,writable:!0});k.forEach((z,r)=>{r+=q;l[z.$mangled]=new Sk.builtin.getset_descriptor(u,{$get(){const t=this.$s[r];if(void 0===t)throw new Sk.builtin.AttributeError(z);return t},$set(t){this.$s[r]=t}})})}function g(k){for(;null!==k.prototype.tp$base;){if(void 0===k.sk$klass&&k.prototype.hasOwnProperty("__dict__"))return k=
k.prototype.__dict__,Sk.builtin.checkDataDescr(k)?k:void 0;k=k.prototype.tp$base}}function a(k,u,l){if(void 0===k.sk$klass)throw new Sk.builtin.TypeError("can't set "+k.prototype.tp$name+"."+l.$jsstr());if(void 0===u)throw new Sk.builtin.TypeError("can't delete "+k.prototype.tp$name+"."+l.$jsstr());}function c(k,u){k=(new Sk.builtin.super_(k,k)).tp$getattr(Sk.builtin.str.$initsubclass);Sk.misceval.callsimArray(k,[],u)}function n(k){const u=k.prototype;Object.keys(u).forEach(l=>{const q=Sk.abstr.lookupSpecial(u[l],
Sk.builtin.str.$setname);if(void 0!==q)try{Sk.misceval.callsimArray(q,[k,new Sk.builtin.str(l)])}catch(z){throw l=new Sk.builtin.RuntimeError("Error calling __set_name__ on '"+Sk.abstr.typeName(u[l])+"' instance '"+l+"' in '"+k.prototype.tp$name+"'"),l.$cause=z,l;}})}void 0===Sk.builtin&&(Sk.builtin={});Sk.builtin.type=function(k){this instanceof Sk.builtin.type&&Sk.asserts.fail("calling new Sk.builtin.type is not safe");return k.ob$type};Object.defineProperties(Sk.builtin.type.prototype,{call:{value:Function.prototype.call},
apply:{value:Function.prototype.apply},tp$slots:{value:{tp$doc:"type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type",tp$call:function(k,u){if(this===Sk.builtin.type){if(1===k.length&&(void 0===u||!u.length))return k[0].ob$type;if(3!==k.length)throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");}let l=this.prototype.tp$new(k,u);if(l.$isSuspension)return Sk.misceval.chain(l,q=>{l=q;if(l.ob$type.$isSubType(this))return l.tp$init(k,u)},
()=>l);if(l.ob$type.$isSubType(this)){const q=l.tp$init(k,u);return void 0!==q&&q.$isSuspension?Sk.misceval.chain(q,()=>l):l}return l},tp$new:function(k,u){if(3!==k.length){if(1===k.length&&(void 0===u||!u.length))return k[0].ob$type;throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");}const l=k[0];var q=k[1];const z=k[2];if("dict"!==z.tp$name)throw new Sk.builtin.TypeError("type() argument 3 must be dict, not "+Sk.abstr.typeName(z));if(!Sk.builtin.checkString(l))throw new Sk.builtin.TypeError("type() argument 1 must be str, not "+
Sk.abstr.typeName(l));const r=l.$jsstr();if("tuple"!==q.tp$name)throw new Sk.builtin.TypeError("type() argument 2 must be tuple, not "+Sk.abstr.typeName(q));q=q.sk$asarray();k=function(){this.sk$hasDict&&(this.$d=new Sk.builtin.dict);this.$s=[]};f(r,k,q,this.constructor);const t=k.prototype;Sk.globals&&(t.__module__=Sk.globals.__name__);t.__doc__=Sk.builtin.none.none$;q=z.quick$lookup(Sk.builtin.str.$slots);let x=void 0===q,v=void 0!==k.$typeLookup(Sk.builtin.str.$dict),B;void 0!==q&&(B=new Set,q=
Sk.builtin.checkString(q)?[q]:Sk.misceval.arrayFromIterable(q),q.forEach(I=>{if(!Sk.builtin.checkString(I))throw new Sk.builtin.TypeError("__slots__ items must be strings, not '"+Sk.abstr.typeName(I)+"'");if(!I.$isIdentifier())throw new Sk.builtin.TypeError("__slots__ must be identifiers");if(I===Sk.builtin.str.$dict){if(v)throw new Sk.builtin.TypeError("__dict__ slot disallowed: we already got one");x=!0}else B.add(Sk.mangleName(l,I))}),q=[...B].sort((I,M)=>I.toString().localeCompare(M.toString())),
p(q,k));x&&!v&&(t.__dict__=new Sk.builtin.getset_descriptor(k,m),v=!0);Object.defineProperties(t,{ht$slots:{value:q||null,writable:!0},sk$hasDict:{value:v,writable:!0}});z.$items().forEach(I=>{var [M,S]=I;if(B&&B.has(M))throw new Sk.builtin.ValueError("'"+M.toString()+"' in __slots__ conflicts with class variable");t[M.$mangled]=S});if(t.hasOwnProperty("__qualname__")){q=t.__qualname__;if(!Sk.builtin.checkString(q))throw new Sk.builtin.TypeError("type __qualname__ must be a str, not '"+Sk.abstr.typeName(q)+
"'");t.ht$qualname=q}q=k.prototype;b(q,"__init_subclass__","classmethod");b(q,"__new__","staticmethod");b(q,"__class_getitem__","classmethod");k.$allocateSlots();n(k);c(k,u);return k},tp$init:function(k,u){if(k&&1==k.length&&u&&u.length)throw new Sk.builtin.TypeError("type.__init__() takes no keyword arguments");if(3!=k.length&&1!=k.length)throw new Sk.builtin.TypeError("type.__init__() takes 1 or 3 arguments");return Sk.builtin.object.prototype.tp$init.call(this,[])},tp$getattr:function(k,u){var l=
this.ob$type;const q=l.$typeLookup(k);let z;if(void 0!==q&&(z=q.tp$descr_get,void 0!==z&&void 0!==q.tp$descr_set))return u=z.call(q,this,l,u);k=this.$typeLookup(k);if(void 0!==k)return l=k.tp$descr_get,void 0!==l?u=l.call(k,null,this,u):k;if(void 0!==z)return u=z.call(q,this,l,u);if(void 0!==q)return q},tp$setattr:function(k,u,l){if(!this.sk$klass){if(void 0!==u)throw new Sk.builtin.TypeError("can't set attributes of built-in/extension type '"+this.prototype.tp$name+"'");throw new Sk.builtin.TypeError("can't delete attributes on type object '"+
this.prototype.tp$name+"'");}const q=this.ob$type.$typeLookup(k);if(void 0!==q){const z=q.tp$descr_set;if(z)return z.call(q,this,u,l)}l=k.$mangled;if(void 0===u)if(u=this.prototype,u.hasOwnProperty(l))delete u[l],k=Sk.dunderToSkulpt[l],void 0!==k&&(delete this.prototype[k],u.sk$prototypical||this.$allocateGetterSlot(l));else throw new Sk.builtin.AttributeError("type object '"+this.prototype.tp$name+"' has no attribute '"+k.$jsstr()+"'");else this.prototype[l]=u,l in Sk.dunderToSkulpt&&this.$allocateSlot(l,
u)},$r:function(){let k=this.prototype.__module__,u="",l="class";k&&Sk.builtin.checkString(k)?u=k.v+".":k=null;k||this.sk$klass||Sk.__future__.class_repr||(l="type");return new Sk.builtin.str("<"+l+" '"+u+this.prototype.tp$name+"'>")}},writable:!0},tp$methods:{value:null,writable:!0},tp$classmethods:{value:null,writable:!0},tp$getsets:{value:null,writable:!0},sk$type:{value:!0},$isSubType:{value:function(k){return this===k||this.prototype instanceof k||!this.prototype.sk$prototypical&&this.prototype.tp$mro.includes(k)}},
$allocateSlot:{value:function(k,u){k=Sk.slots[k];const l=k.$slot_name,q=this.prototype;q.hasOwnProperty(l)&&delete q[l];Object.defineProperty(q,l,{value:k.$slot_func(u),writable:!0,configurable:!0})}},$allocateSlots:{value:function(){const k=this.prototype;this.prototype.sk$prototypical?Object.keys(k).forEach(u=>{u in Sk.slots&&this.$allocateSlot(u,k[u])}):Object.keys(Sk.slots).forEach(u=>{k.hasOwnProperty(u)?this.$allocateSlot(u,k[u]):this.$allocateGetterSlot(u)});k.hasOwnProperty("__eq__")&&!k.hasOwnProperty("__hash__")&&
(k.tp$hash=k.__hash__=Sk.builtin.none.none$)}},$allocateGetterSlot:{value:function(k){const u=Sk.slots[k].$slot_name,l=this.prototype;l.hasOwnProperty(u)||Object.defineProperty(l,u,{configurable:!0,get(){const q=l.tp$mro;for(let z=1;z<q.length;z++){const r=Object.getOwnPropertyDescriptor(q[z].prototype,u);if(void 0!==r&&r.value)return r.value}}})}},$typeLookup:{value:function(k){return this.prototype.sk$prototypical?this.prototype[k.$mangled]:d.call(this,k)},writable:!0},$mroMerge:{value:function(k){this.prototype.sk$prototypical=
!0;let u;const l=[];for(;;){for(u=0;u<k.length;++u){var q=k[u];if(0!==q.length)break}if(u===k.length)return l;var z=[];for(u=0;u<k.length;++u)if(q=k[u],0!==q.length){const r=q[0];q=0;a:for(;q<k.length;++q){const t=k[q];for(let x=1;x<t.length;++x)if(t[x]===r)break a}q===k.length&&z.push(r)}if(0===z.length)throw new Sk.builtin.TypeError("Inconsistent precedences in type hierarchy");z=z[0];l.length&&this.prototype.sk$prototypical&&Object.getPrototypeOf(l[l.length-1].prototype)!==z.prototype&&(this.prototype.sk$prototypical=
!1);l.push(z);for(u=0;u<k.length;++u)q=k[u],0<q.length&&q[0]===z&&q.splice(0,1)}}},$buildMRO:{value:function(){const k=[[this]],u=this.prototype.tp$bases;for(var l=0;l<u.length;++l)k.push([...u[l].prototype.tp$mro]);l=[];for(let q=0;q<u.length;++q)l.push(u[q]);k.push(l);return this.$mroMerge(k)}},sk$attrError:{value(){return"type object '"+this.prototype.tp$name+"'"},writable:!0}});Sk.builtin.type.prototype.tp$getsets={__base__:{$get(){return this.prototype.tp$base||Sk.builtin.none.none$}},__bases__:{$get(){void 0===
this.sk$tuple_bases&&(this.sk$tuple_bases=new Sk.builtin.tuple(this.prototype.tp$bases));return this.sk$tuple_bases}},__mro__:{$get(){void 0===this.sk$tuple_mro&&(this.sk$tuple_mro=new Sk.builtin.tuple(this.prototype.tp$mro));return this.sk$tuple_mro}},__dict__:{$get(){return new Sk.builtin.mappingproxy(this.prototype)}},__doc__:{$get(){const k=this.$typeLookup(Sk.builtin.str.$doc);return k?void 0!==k.tp$descr_get?this===Sk.builtin.type?new Sk.builtin.str(this.prototype.tp$doc):k.tp$descr_get(null,
this):this.prototype.__doc__:Sk.builtin.none.none$},$set(k){a(this,k,Sk.builtin.str.$doc);this.prototype.__doc__=k}},__name__:{$get(){let k=this.prototype.ht$name;if(void 0!==k)return new Sk.builtin.str(k);k=this.prototype.tp$name;k.includes(".")&&(k=k.slice(k.lastIndexOf(".")+1));return new Sk.builtin.str(k)},$set(k){a(this,k,Sk.builtin.str.$name);if(!Sk.builtin.checkString(k))throw new Sk.builtin.TypeError("can only assign string to "+this.prototype.tp$name+".__name__, not '"+Sk.abstr.typeName(k)+
"'");this.prototype.ht$name=k;this.prototype.tp$name=k.$jsstr()}},__qualname__:{$get(){return this.prototype.ht$qualname||Sk.abstr.lookupSpecial(this,Sk.builtin.str.$name)},$set(k){a(this,k,Sk.builtin.str.$name);if(!Sk.builtin.checkString(k))throw new Sk.builtin.TypeError("can only assign string to "+this.prototype.tp$name+".__qualname__, not '"+Sk.abstr.typeName(k)+"'");this.prototype.ht$qualname=k}},__module__:{$get(){const k=this.prototype,u=k.__module__;return u&&u.ob$type!==Sk.builtin.getset_descriptor?
u:k.tp$name.includes(".")?new Sk.builtin.str(k.tp$name.slice(0,k.tp$name.lastIndexOf("."))):new Sk.builtin.str("builtins")},$set(k){a(this,k,Sk.builtin.str.$module);this.prototype.__module__=k}}};Sk.builtin.type.prototype.tp$methods={mro:{$meth(){return new Sk.builtin.list(this.$buildMRO())},$flags:{NoArgs:!0}},__dir__:{$meth:function(){const k=new Sk.builtin.dict([]);this.$mergeClassDict(k);return new Sk.builtin.list(k.sk$asarray())},$flags:{NoArgs:!0},$doc:"Specialized __dir__ implementation for types."}};
Sk.builtin.type.tp$classmethods={__prepare__:{$meth(){return new Sk.builtin.dict([])},$flags:{FastCall:!0}}};const m={$get(){const k=g(this.ob$type);return void 0!==k?k.tp$descr_get(this,this.ob$type):Sk.generic.getSetDict.$get.call(this)},$set(k){const u=g(this.ob$type);if(void 0!==u)return u.tp$descr_set(this,k);if(void 0===k)this.$d=new Sk.builtin.dict([]);else return Sk.generic.getSetDict.$set.call(this,k)},$doc:"dictionary for instance variables (if defined)",$name:"__dict__"}},function(F,P){Sk.generic=
{};Sk.generic.getAttr=function(b,e){let d;const f=this.ob$type,h=f.$typeLookup(b);if(void 0!==h&&(d=h.tp$descr_get,void 0!==d&&void 0!==h.tp$descr_set))return d.call(h,this,f,e);const p=this.$d;if(void 0!==p&&(b=p.quick$lookup(b),void 0!==b))return b;if(void 0!==d)return d.call(h,this,f,e);if(void 0!==h)return h};Sk.exportSymbol("Sk.generic.getAttr",Sk.generic.getAttr);Sk.generic.setAttr=function(b,e,d){var f=this.ob$type.$typeLookup(b);if(void 0!==f&&null!==f){const h=f.tp$descr_set;if(h)return h.call(f,
this,e,d)}d=this.$d;if(void 0!==d)if(d.mp$ass_subscript){if(void 0!==e)return d.mp$ass_subscript(b,e);try{return d.mp$ass_subscript(b)}catch(h){if(h instanceof Sk.builtin.KeyError)throw new Sk.builtin.AttributeError("'"+Sk.abstr.typeName(this)+"' object has no attribute '"+b.$jsstr()+"'");throw h;}}else if("object"===typeof d){f=b.$mangled;if(void 0!==e){d[f]=e;return}if(void 0!==d[f]){delete d[f];return}}throw new Sk.builtin.AttributeError(this.sk$attrError()+" has no attribute '"+b.$jsstr()+"'");
};Sk.exportSymbol("Sk.generic.setAttr",Sk.generic.setAttr);Sk.generic.new=function(b){return function(e,d){if(this.constructor===b)return new this.constructor;e=new this.constructor;b.call(e);return e}};Sk.generic.newMethodDef={$meth(b,e){const d=this.prototype;if(1>b.length)throw b=d.tp$name,new Sk.builtin.TypeError(b+".__new__(): not enough arguments");var f=b.shift();if(void 0===f.sk$type)throw b=d.tp$name,new Sk.builtin.TypeError(b+"__new__(X): X is not a type object ("+Sk.abstr.typeName(f)+")");
if(!f.$isSubType(this))throw b=d.tp$name,f=f.prototype.tp$name,new Sk.builtin.TypeError(b+".__new__("+f+"): "+f+" is not a subtype of "+b);const h=f.prototype.sk$staticNew.prototype;if(h.tp$new!==d.tp$new)throw b=d.tp$name,f=f.prototype.tp$name,new Sk.builtin.TypeError(b+".__new__("+f+") is not safe, use "+h.tp$name+".__new__()");return d.tp$new.call(f.prototype,b,e)},$flags:{FastCall:!0},$textsig:"($type, *args, **kwargs)",$name:"__new__"};Sk.generic.selfIter=function(){return this};Sk.generic.iterNextWithArrayCheckSize=
function(){if(this.$seq.length!==this.$orig.get$size()){const b=this.tp$name.split("_")[0];throw new Sk.builtin.RuntimeError(b+" changed size during iteration");}if(!(this.$index>=this.$seq.length))return this.$seq[this.$index++]};Sk.generic.iterNextWithArray=function(){const b=this.$seq[this.$index++];void 0===b&&(this.tp$iternext=()=>{});return b};Sk.generic.iterLengthHintWithArrayMethodDef={$meth:function(){return new Sk.builtin.int_(this.$seq.length-this.$index)},$flags:{NoArgs:!0}};Sk.generic.iterReverseLengthHintMethodDef=
{$meth:function(){return new Sk.builtin.int_(this.$index)},$flags:{NoArgs:!0}};Sk.generic.getSetDict={$get(){return this.$d},$set(b){if(void 0===b)throw new Sk.builtin.TypeError("cannot delete __dict__");if(b instanceof Sk.builtin.dict)this.$d=b;else throw new Sk.builtin.TypeError("__dict__ must be set to a dictionary, not a '"+Sk.abstr.typeName(b)+"'");},$doc:"dictionary for instance variables (if defined)",$name:"__dict__"};Sk.generic.seqCompare=function(b,e){if(this===b&&Sk.misceval.opAllowsEquality(e))return!0;
if(!(b instanceof this.sk$builtinBase))return Sk.builtin.NotImplemented.NotImplemented$;const d=this.v;b=b.v;let f;if(d.length!==b.length&&("Eq"===e||"NotEq"===e))return"Eq"===e?!1:!0;for(f=0;f<d.length&&f<b.length&&(d[f]===b[f]||Sk.misceval.richCompareBool(d[f],b[f],"Eq"));++f);const h=d.length,p=b.length;if(f>=h||f>=p)switch(e){case "Lt":return h<p;case "LtE":return h<=p;case "Eq":return h===p;case "NotEq":return h!==p;case "Gt":return h>p;case "GtE":return h>=p;default:Sk.asserts.fail()}return"Eq"===
e?!1:"NotEq"===e?!0:Sk.misceval.richCompareBool(d[f],b[f],e)};Sk.generic.classGetItem={__class_getitem__:{$meth(b){return new Sk.builtin.GenericAlias(this,b)},$flags:{OneArg:!0}}}},function(F,P){Sk.builtin.pyCheckArgs=function(b,e,d,f,h,p){e=e.length;void 0===f&&(f=Infinity);h&&--e;p&&--e;if(e<d||e>f)throw new Sk.builtin.TypeError((d===f?b+"() takes exactly "+d+" arguments":e<d?b+"() takes at least "+d+" arguments":0<d?b+"() takes at most "+f+" arguments":b+"() takes no arguments")+(" ("+e+" given)"));
};Sk.exportSymbol("Sk.builtin.pyCheckArgs",Sk.builtin.pyCheckArgs);Sk.builtin.pyCheckArgsLen=function(b,e,d,f,h,p){void 0===f&&(f=Infinity);h&&--e;p&&--e;if(e<d||e>f)throw new Sk.builtin.TypeError((d===f?b+"() takes exactly "+d+" arguments":e<d?b+"() takes at least "+d+" arguments":b+"() takes at most "+f+" arguments")+(" ("+e+" given)"));};Sk.builtin.pyCheckType=function(b,e,d){if(!d)throw new Sk.builtin.TypeError(b+" must be a "+e);};Sk.exportSymbol("Sk.builtin.pyCheckType",Sk.builtin.pyCheckType);
Sk.builtin.checkSequence=function(b){return null!=b&&void 0!==b.mp$subscript};Sk.exportSymbol("Sk.builtin.checkSequence",Sk.builtin.checkSequence);Sk.builtin.checkIterable=function(b){return void 0===b?!1:b.tp$iter?void 0!==b.tp$iter().tp$iternext:void 0!==b.mp$subscript};Sk.exportSymbol("Sk.builtin.checkIterable",Sk.builtin.checkIterable);Sk.builtin.checkCallable=function(b){return null!=b&&void 0!==b.tp$call};Sk.builtin.checkNumber=function(b){return"number"===typeof b||b instanceof Sk.builtin.int_||
b instanceof Sk.builtin.float_||b instanceof Sk.builtin.lng};Sk.exportSymbol("Sk.builtin.checkNumber",Sk.builtin.checkNumber);Sk.builtin.checkComplex=function(b){return b instanceof Sk.builtin.complex};Sk.exportSymbol("Sk.builtin.checkComplex",Sk.builtin.checkComplex);Sk.builtin.checkInt=function(b){return b instanceof Sk.builtin.int_||"number"===typeof b&&Number.isInteger(b)};Sk.exportSymbol("Sk.builtin.checkInt",Sk.builtin.checkInt);Sk.builtin.checkFloat=function(b){return b instanceof Sk.builtin.float_};
Sk.exportSymbol("Sk.builtin.checkFloat",Sk.builtin.checkFloat);Sk.builtin.checkString=function(b){return b instanceof Sk.builtin.str};Sk.exportSymbol("Sk.builtin.checkString",Sk.builtin.checkString);Sk.builtin.checkBytes=function(b){return b instanceof Sk.builtin.bytes};Sk.builtin.checkClass=function(b){return b instanceof Sk.builtin.type};Sk.exportSymbol("Sk.builtin.checkClass",Sk.builtin.checkClass);Sk.builtin.checkBool=function(b){return b instanceof Sk.builtin.bool};Sk.exportSymbol("Sk.builtin.checkBool",
Sk.builtin.checkBool);Sk.builtin.checkNone=function(b){return b===Sk.builtin.none.none$};Sk.exportSymbol("Sk.builtin.checkNone",Sk.builtin.checkNone);Sk.builtin.checkFunction=function(b){return null!=b&&void 0!==b.tp$call};Sk.exportSymbol("Sk.builtin.checkFunction",Sk.builtin.checkFunction);Sk.builtin.checkDataDescr=function(b){return b&&void 0!==b.tp$descr_set};Sk.exportSymbol("Sk.builtin.checkDataDescr",Sk.builtin.checkDataDescr);Sk.builtin.checkAnySet=function(b){return b instanceof Sk.builtin.set||
b instanceof Sk.builtin.frozenset};Sk.builtin.checkMapping=function(b){return b instanceof Sk.builtin.dict||null!=b&&void 0!==b.mp$subscript&&void 0!==Sk.abstr.lookupSpecial(b,Sk.builtin.str.$keys)}},function(F,P){function b(l,q){switch(q){case "Add":return l.nb$add;case "Sub":return l.nb$subtract;case "Mult":return l.nb$multiply;case "MatMult":if(Sk.__future__.python3)return l.nb$matrix_multiply;case "Div":return l.nb$divide;case "FloorDiv":return l.nb$floor_divide;case "Mod":return l.nb$remainder;
case "DivMod":return l.nb$divmod;case "Pow":return l.nb$power;case "LShift":return l.nb$lshift;case "RShift":return l.nb$rshift;case "BitAnd":return l.nb$and;case "BitXor":return l.nb$xor;case "BitOr":return l.nb$or}}function e(l,q){switch(q){case "Add":return l.nb$reflected_add;case "Sub":return l.nb$reflected_subtract;case "Mult":return l.nb$reflected_multiply;case "MatMult":if(Sk.__future__.python3)return l.nb$reflected_matrix_multiply;case "Div":return l.nb$reflected_divide;case "FloorDiv":return l.nb$reflected_floor_divide;
case "Mod":return l.nb$reflected_remainder;case "DivMod":return l.nb$reflected_divmod;case "Pow":return l.nb$reflected_power;case "LShift":return l.nb$reflected_lshift;case "RShift":return l.nb$reflected_rshift;case "BitAnd":return l.nb$reflected_and;case "BitXor":return l.nb$reflected_xor;case "BitOr":return l.nb$reflected_or}}function d(l,q){switch(q){case "Add":return l.nb$inplace_add;case "Sub":return l.nb$inplace_subtract;case "Mult":return l.nb$inplace_multiply;case "MatMult":if(Sk.__future__.python3)return l.nb$inplace_matrix_multiply;
case "Div":return l.nb$inplace_divide;case "FloorDiv":return l.nb$inplace_floor_divide;case "Mod":return l.nb$inplace_remainder;case "Pow":return l.nb$inplace_power;case "LShift":return l.nb$inplace_lshift;case "RShift":return l.nb$inplace_rshift;case "BitAnd":return l.nb$inplace_and;case "BitOr":return l.nb$inplace_or;case "BitXor":return l.nb$inplace_xor}}function f(l,q,z){const r=q.constructor,t=l.constructor;let x;let v=!1;if(r!==t&&void 0===r.sk$baseClass&&q instanceof t)if(x=e(q,z),void 0===
x)v=!0;else if(x!==e(l,z)){v=!0;var B=x.call(q,l);if(B!==Sk.builtin.NotImplemented.NotImplemented$)return B}B=b(l,z);if(void 0!==B&&(B=B.call(l,q),B!==Sk.builtin.NotImplemented.NotImplemented$)||!v&&r!==t&&(x||(x=e(q,z)),void 0!==x&&(B=x.call(q,l),B!==Sk.builtin.NotImplemented.NotImplemented$)))return B}function h(l,q,z){var r=d(l,z);return void 0!==r&&(r=r.call(l,q),r!==Sk.builtin.NotImplemented.NotImplemented$)?r:f(l,q,z)}function p(l){u.forEach(q=>{var [z,r]=q;l[r]=function(t){return this.tp$richcompare(t,
z)}})}function g(l){const q=Sk.reflectedNumberSlots;Object.keys(q).forEach(z=>{if(void 0!==l[z]){const r=q[z],t=r.reflected,x=l[t];void 0!==x?null===x&&delete l[t]:l[t]=r.slot||l[z]}})}function a(l){const q=Sk.sequenceAndMappingSlots;Object.keys(q).forEach(z=>{void 0!==l[z]&&q[z].forEach(r=>{l[r]=l[z]})})}Sk.abstr={};Sk.abstr.typeName=function(l){if(null!=l&&void 0!==l.tp$name){let q=l.ht$name;if(void 0!==q)return q.toString();q=l.tp$name;q.includes(".")&&(q=q.slice(q.lastIndexOf(".")+1));return q}Sk.asserts.fail(l+
" passed to typeName");return"<invalid type>"};const c={Add:"+",Sub:"-",Mult:"*",MatMult:"@",Div:"/",FloorDiv:"//",Mod:"%",DivMod:"divmod()",Pow:"** or pow()",LShift:"<<",RShift:">>",BitAnd:"&",BitXor:"^",BitOr:"|"},n={UAdd:"+",USub:"-",Invert:"~"};Sk.abstr.numberBinOp=function(l,q,z){var r;if(!(r=f(l,q,z)))throw l=Sk.abstr.typeName(l),q=Sk.abstr.typeName(q),new Sk.builtin.TypeError("unsupported operand type(s) for "+c[z]+": '"+l+"' and '"+q+"'");return r};Sk.exportSymbol("Sk.abstr.numberBinOp",Sk.abstr.numberBinOp);
Sk.abstr.numberInplaceBinOp=function(l,q,z){var r;if(!(r=h(l,q,z)))throw l=Sk.abstr.typeName(l),q=Sk.abstr.typeName(q),new Sk.builtin.TypeError("unsupported operand type(s) for "+c[z]+"=: '"+l+"' and '"+q+"'");return r};Sk.exportSymbol("Sk.abstr.numberInplaceBinOp",Sk.abstr.numberInplaceBinOp);Sk.abstr.numberUnaryOp=function(l,q){if("Not"===q)return Sk.misceval.isTrue(l)?Sk.builtin.bool.false$:Sk.builtin.bool.true$;b:{switch(q){case "USub":var z=l.nb$negative;break b;case "UAdd":z=l.nb$positive;break b;
case "Invert":z=l.nb$invert;break b}z=void 0}z=void 0!==z?z.call(l):void 0;if(!z)throw l=Sk.abstr.typeName(l),new Sk.builtin.TypeError("bad operand type for unary "+n[q]+": '"+l+"'");return z};Sk.exportSymbol("Sk.abstr.numberUnaryOp",Sk.abstr.numberUnaryOp);Sk.abstr.fixSeqIndex_=function(l,q){q=Sk.builtin.asnum$(q);0>q&&l.sq$length&&(q+=l.sq$length());return q};Sk.abstr.sequenceContains=function(l,q,z){if(l.sq$contains)return l.sq$contains(q,z);l=Sk.misceval.iterFor(Sk.abstr.iter(l),function(r){return r===
q||Sk.misceval.richCompareBool(r,q,"Eq")?new Sk.misceval.Break(!0):!1},!1);return z?l:Sk.misceval.retryOptionalSuspensionOrThrow(l)};Sk.abstr.sequenceConcat=function(l,q){if(l.sq$concat)return l.sq$concat(q);if(Sk.builtin.checkSequence(l)&&Sk.builtin.checkSequence(q)&&(q=f(l,q,"Add"),void 0!==q))return q;throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(l)+"' object can't be concatenated");};Sk.abstr.sequenceInPlaceConcat=function(l,q){if(l.sq$inplace_concat)return l.sq$inplace_concat(q);if(l.sq$concat)return l.sq$concat(q);
if(Sk.builtin.checkSequence(l)&&Sk.builtin.checkSequence(q)&&(q=h(l,q,"Add"),void 0!==q))return q;throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(l)+"' object can't be concatenated");};Sk.abstr.sequenceGetIndexOf=function(l,q){if(l.index)return Sk.misceval.callsimArray(l.index,[l,q]);let z=0;for(let r=Sk.abstr.iter(l),t=r.tp$iternext();void 0!==t;t=r.tp$iternext()){if(Sk.misceval.richCompareBool(q,t,"Eq"))return new Sk.builtin.int_(z);z+=1}throw new Sk.builtin.ValueError("sequence.index(x): x not in sequence");
};Sk.abstr.sequenceGetCountOf=function(l,q){if(l.count)return Sk.misceval.callsimArray(l.count,[l,q]);let z=0;for(let r=Sk.abstr.iter(l),t=r.tp$iternext();void 0!==t;t=r.tp$iternext())Sk.misceval.richCompareBool(q,t,"Eq")&&(z+=1);return new Sk.builtin.int_(z)};Sk.abstr.sequenceGetItem=function(l,q,z){"number"===typeof q&&(q=new Sk.builtin.int_(q));return Sk.abstr.objectGetItem(l,q,z)};Sk.abstr.sequenceSetItem=function(l,q,z,r){"number"===typeof q&&(q=new Sk.builtin.int_(q));return Sk.abstr.objectSetItem(l,
q,z,r)};Sk.abstr.sequenceDelItem=function(l,q,z){return Sk.abstr.objectDelItem(l,q,z)};Sk.abstr.sequenceGetSlice=function(l,q,z){return Sk.abstr.objectGetItem(l,new Sk.builtin.slice(q,z))};Sk.abstr.sequenceDelSlice=function(l,q,z){return Sk.abstr.objectDelItem(l,new Sk.builtin.slice(q,z))};Sk.abstr.sequenceSetSlice=function(l,q,z,r){return Sk.abstr.objectSetItem(l,new Sk.builtin.slice(q,z))};Sk.abstr.sequenceUnpack=function(l,q,z,r){if(!Sk.builtin.checkIterable(l))throw new Sk.builtin.TypeError("cannot unpack non-iterable "+
Sk.abstr.typeName(l)+" object");const t=Sk.abstr.iter(l),x=[];let v=0,B;0<q&&(B=Sk.misceval.iterFor(t,I=>{x.push(I);if(++v===q)return new Sk.misceval.Break}));return Sk.misceval.chain(B,()=>{if(x.length<q)throw new Sk.builtin.ValueError("not enough values to unpack (expected at least "+z+", got "+x.length+")");if(!r)return Sk.misceval.chain(t.tp$iternext(!0),M=>{if(void 0!==M)throw new Sk.builtin.ValueError("too many values to unpack (expected "+q+")");return x});const I=[];return Sk.misceval.chain(Sk.misceval.iterFor(t,
M=>{I.push(M)}),()=>{const M=I.length+q-z;if(0>M)throw new Sk.builtin.ValueError("not enough values to unpack (expected at least "+z+", got "+(z+M)+")");x.push(new Sk.builtin.list(I.slice(0,M)));x.push(...I.slice(M));return x})})};Sk.abstr.mappingUnpackIntoKeywordArray=function(l,q,z){if(q instanceof Sk.builtin.dict)q.$items().forEach(t=>{var [x,v]=t;if(!Sk.builtin.checkString(x))throw new Sk.builtin.TypeError((z.$qualname?z.$qualname+"() ":"")+"keywords must be strings");l.push(x.v);l.push(v)});
else{var r=Sk.abstr.lookupSpecial(q,Sk.builtin.str.$keys);if(void 0===r)throw new Sk.builtin.TypeError("Object is not a mapping");return Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(r),t=>Sk.misceval.iterFor(Sk.abstr.iter(t),x=>{if(!Sk.builtin.checkString(x))throw new Sk.builtin.TypeError((z.$qualname?z.$qualname+"() ":"")+"keywords must be strings");return Sk.misceval.chain(q.mp$subscript(x,!0),v=>{l.push(x.v);l.push(v)})}))}};Sk.abstr.keywordArrayFromPyDict=function(l){const q=[];l.$items().forEach(z=>
{var [r,t]=z;if(!Sk.builtin.checkString(r))throw new Sk.builtin.TypeError("keywords must be strings");q.push(r.toString());q.push(t)});return q};Sk.abstr.keywordArrayToPyDict=function(l){const q=new Sk.builtin.dict;for(let z=0;z<l.length;z+=2)q.mp$ass_subscript(new Sk.builtin.str(l[z]),l[z+1]);return q};Sk.abstr.copyKeywordsToNamedArgs=function(l,q,z,r,t){r=r||[];var x=z.length+r.length/2;if(x>q.length)throw new Sk.builtin.TypeError(l+"() expected at most "+q.length+" arguments ("+x+" given)");if(r.length||
void 0!==t){if(x===q.length&&!r.length)return z;if(0===x&&q.length===(t&&t.length))return t}else return z;z=z.slice(0);for(x=0;x<r.length;x+=2){const v=r[x].toString(),B=r[x+1],I=q.indexOf(v);if(0<=I){if(void 0!==z[I])throw new Sk.builtin.TypeError(l+"() got multiple values for argument '"+v+"'");z[I]=B}else throw new Sk.builtin.TypeError(l+"() got an unexpected keyword argument '"+v+"'");}if(t){r=q.length;for(x=r-1;0<=x;x--)void 0===z[x]&&(z[x]=t[t.length-1-(r-1-x)]);q=q.filter((v,B)=>void 0===z[B]);
if(q.length)throw new Sk.builtin.TypeError(l+"() missing "+q.length+" required positional arguments: "+q.join(", "));}return z};Sk.exportSymbol("Sk.abstr.copyKeywordsToNamedArgs",Sk.abstr.copyKeywordsToNamedArgs);Sk.abstr.checkNoKwargs=function(l,q){if(q&&q.length)throw new Sk.builtin.TypeError(l+"() takes no keyword arguments");};Sk.exportSymbol("Sk.abstr.checkNoKwargs",Sk.abstr.checkNoKwargs);Sk.abstr.checkNoArgs=function(l,q,z){if(q=q.length+(z?z.length:0))throw new Sk.builtin.TypeError(l+"() takes no arguments ("+
q+" given)");};Sk.exportSymbol("Sk.abstr.checkNoArgs",Sk.abstr.checkNoArgs);Sk.abstr.checkOneArg=function(l,q,z){Sk.abstr.checkNoKwargs(l,z);if(1!==q.length)throw new Sk.builtin.TypeError(l+"() takes exactly one argument ("+q.length+" given)");};Sk.exportSymbol("Sk.abstr.checkOneArg",Sk.abstr.checkOneArg);Sk.abstr.checkArgsLen=function(l,q,z,r){q=q.length;void 0===r&&(r=Infinity);if(q<z||q>r)throw new Sk.builtin.TypeError((z===r?l+"() takes exactly "+z+" arguments":q<z?l+"() takes at least "+z+" arguments":
l+"() takes at most "+r+" arguments")+(" ("+q+" given)"));};Sk.exportSymbol("Sk.abstr.checkArgsLen",Sk.abstr.checkArgsLen);Sk.abstr.objectFormat=function(l,q){if(void 0===q)q=Sk.builtin.str.$emptystr;else if(!Sk.builtin.checkString(q))throw new Sk.builtin.TypeError("Format specifier must be a string, not "+Sk.abstr.typeName(q));l=Sk.abstr.lookupSpecial(l,Sk.builtin.str.$format);q=Sk.misceval.callsimArray(l,[q]);if(!Sk.builtin.checkString(q))throw new Sk.builtin.TypeError("__format__ must return a str, not "+
Sk.abstr.typeName(q));return q};Sk.abstr.objectHash=function(l){const q=l.tp$hash;if(void 0!==q){if(Sk.builtin.checkNone(q))throw new Sk.builtin.TypeError("unhashable type: '"+Sk.abstr.typeName(l)+"'");return l.tp$hash()}throw new Sk.builtin.TypeError("unsupported Javascript type");};Sk.abstr.objectAdd=function(l,q){if(l.nb$add)return l.nb$add(q);l=Sk.abstr.typeName(l);q=Sk.abstr.typeName(q);throw new Sk.builtin.TypeError("unsupported operand type(s) for +: '"+l+"' and '"+q+"'");};Sk.abstr.objectNegative=
function(l){if(l.nb$negative)return l.nb$negative();throw new Sk.builtin.TypeError("bad operand type for unary -: '"+Sk.abstr.typeName(l)+"'");};Sk.abstr.objectPositive=function(l){if(l.nb$positive)return l.nb$positive();throw new Sk.builtin.TypeError("bad operand type for unary +: '"+Sk.abstr.typeName(l)+"'");};Sk.abstr.objectDelItem=function(l,q,z){if(l.mp$ass_subscript)return l.mp$ass_subscript(q,void 0,z);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(l)+"' object does not support item deletion");
};Sk.exportSymbol("Sk.abstr.objectDelItem",Sk.abstr.objectDelItem);Sk.abstr.objectGetItem=function(l,q,z){if(l.mp$subscript)return l.mp$subscript(q,z);if(Sk.builtin.checkClass(l)){if(l===Sk.builtin.type)return new Sk.builtin.GenericAlias(l,q);const r=Sk.abstr.typeLookup(l,Sk.builtin.str.$class_getitem);if(void 0!==r)return l=Sk.misceval.callsimOrSuspendArray(r,[q]),z?l:Sk.misceval.retryOptionalSuspensionOrThrow(l)}throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(l)+"' does not support indexing");
};Sk.exportSymbol("Sk.abstr.objectGetItem",Sk.abstr.objectGetItem);Sk.abstr.objectSetItem=function(l,q,z,r){if(l.mp$ass_subscript)return l.mp$ass_subscript(q,z,r);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(l)+"' does not support item assignment");};Sk.exportSymbol("Sk.abstr.objectSetItem",Sk.abstr.objectSetItem);Sk.abstr.gattr=function(l,q,z){z=l.tp$getattr(q,z);if(void 0===z)throw new Sk.builtin.AttributeError(l.sk$attrError()+" has no attribute '"+q.$jsstr()+"'");return z.$isSuspension?
Sk.misceval.chain(z,function(r){if(void 0===r)throw new Sk.builtin.AttributeError(l.sk$attrError()+" has no attribute '"+q.$jsstr()+"'");return r}):z};Sk.exportSymbol("Sk.abstr.gattr",Sk.abstr.gattr);Sk.abstr.sattr=function(l,q,z,r){return l.tp$setattr(q,z,r)};Sk.exportSymbol("Sk.abstr.sattr",Sk.abstr.sattr);Sk.abstr.iternext=function(l,q){return l.tp$iternext(q)};Sk.exportSymbol("Sk.abstr.iternext",Sk.abstr.iternext);Sk.abstr.iter=function(l){if(l.tp$iter){l=l.tp$iter();if(l.tp$iternext)return l;
throw new Sk.builtin.TypeError("iter() returned non-iterator of type '"+Sk.abstr.typeName(l)+"'");}if(l.mp$subscript)return new Sk.builtin.seq_iter_(l);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(l)+"' object is not iterable");};Sk.exportSymbol("Sk.abstr.iter",Sk.abstr.iter);Sk.abstr.lookupSpecial=function(l,q){var z=l.ob$type;if(void 0===z)Sk.asserts.fail("javascript object sent to lookupSpecial");else if(q=z.$typeLookup(q),void 0!==q)return void 0!==q.tp$descr_get&&(q=q.tp$descr_get(l,
z)),q};Sk.exportSymbol("Sk.abstr.lookupSpecial",Sk.abstr.lookupSpecial);Sk.abstr.lookupAttr=function(l,q){try{return l.tp$getattr(q)}catch(z){if(!(z instanceof Sk.builtin.AttributeError))throw z;}};Sk.abstr.typeLookup=function(l,q){q=l.$typeLookup(q);return void 0!==q&&q.tp$descr_get?q.tp$descr_get(null,l):q};Sk.abstr.markUnhashable=function(l){l=l.prototype;l.__hash__=Sk.builtin.none.none$;l.tp$hash=Sk.builtin.none.none$};Sk.abstr.setUpInheritance=function(l,q,z,r){r=r||Sk.builtin.type;z=void 0===
z?Sk.builtin.object:z;const t=null!==z?z.prototype:null;Object.setPrototypeOf(q,r.prototype);Object.setPrototypeOf(q.prototype,t);Object.defineProperties(q.prototype,{sk$object:{value:q,writable:!0},ob$type:{value:q,writable:!0},tp$name:{value:l,writable:!0},tp$base:{value:z,writable:!0}})};Sk.abstr.setUpBuiltinMro=function(l){let q=l.prototype.tp$base;const z=null===q?[]:[q];if(q===Sk.builtin.object||null===q)Object.defineProperty(l,"sk$baseClass",{value:!0,writable:!0}),Object.defineProperty(l.prototype,
"sk$builtinBase",{value:l,writable:!0});Object.defineProperty(l,"sk$solidBase",{value:!0,writable:!0});const r=[l];for(;null!==q;)r.push(q),q=q.prototype.tp$base;Object.defineProperties(l.prototype,{sk$prototypical:{value:!0,writable:!0},tp$bases:{value:z,writable:!0},tp$mro:{value:r,writable:!0}});Object.defineProperty(l,"$typeLookup",{value:function(t){return this.prototype[t.$mangled]},writable:!0})};let m=l=>Sk.builtin.str&&Sk.builtin.str.$fixReserved?(m=Sk.builtin.str.$fixReserved,Sk.builtin.str.$fixReserved(l)):
l;Sk.abstr.setUpGetSets=function(l,q){if(void 0!==Sk.builtin.getset_descriptor){var z=l.prototype;q=q||z.tp$getsets||{};Object.entries(q).forEach(r=>{var [t,x]=r;x.$name=t;z[m(t)]=new Sk.builtin.getset_descriptor(l,x)});Object.defineProperty(z,"tp$getsets",{value:null,writable:!0})}};Sk.abstr.setUpMethods=function(l,q){if(void 0!==Sk.builtin.method_descriptor){var z=l.prototype;q=q||z.tp$methods||{};Object.entries(q).forEach(r=>{var [t,x]=r;x.$name=t;z[m(t)]=new Sk.builtin.method_descriptor(l,x)});
Object.defineProperty(z,"tp$methods",{value:null,writable:!0})}};Sk.abstr.setUpClassMethods=function(l,q){if(void 0!==Sk.builtin.classmethod_descriptor){var z=l.prototype;q=q||z.tp$classmethods||{};Object.entries(q).forEach(r=>{var [t,x]=r;x.$name=t;z[m(t)]=new Sk.builtin.classmethod_descriptor(l,x)});Object.defineProperty(z,"tp$classmethods",{value:null,writable:!0})}};const k={Eq:"ob$eq",NotEq:"ob$ne",Gt:"ob$gt",GtE:"ob$ge",Lt:"ob$lt",LtE:"ob$le"},u=Object.entries(k);Sk.abstr.setUpSlots=function(l,
q){function z(v,B){t[v]=new Sk.builtin.wrapper_descriptor(l,Sk.slots[v],B)}function r(v,B){"string"===typeof v?z(v,B):v.forEach(I=>{z(I,B)})}if(void 0!==Sk.builtin.wrapper_descriptor){var t=l.prototype;q=q||t.tp$slots||{};q.tp$new===Sk.generic.new&&(q.tp$new=Sk.generic.new(l));q.tp$richcompare?p(q):q.ob$eq&&(q.tp$richcompare=function(v,B){return this[k[B]].call(this,v)});q.tp$as_number&&g(q);q.tp$as_sequence_or_mapping&&a(q);Object.entries(q).forEach(v=>{var [B,I]=v;Object.defineProperty(t,B,{value:I,
writable:!0})});q.tp$new&&(t.__new__=new Sk.builtin.sk_method(Sk.generic.newMethodDef,l),Object.defineProperty(t,"sk$staticNew",{value:l,writable:!0}));Sk.subSlots.main_slots.forEach(v=>{var [B,I]=v;v=q[B];void 0!==v&&r(I,v)});var x=q.tp$hash;void 0!==x&&("function"===typeof x?z("__hash__",x):x===Sk.builtin.none.none$?t.__hash__=x:Sk.asserts.fail("invalid tp$hash"));q.tp$as_number&&Sk.subSlots.number_slots.forEach(v=>{var [B,I]=v;v=q[B];void 0!==v&&r(I,v)});q.tp$as_sequence_or_mapping&&Sk.subSlots.sequence_and_mapping_slots.forEach(v=>
{var [B,I]=v;v=q[B];void 0!==v&&r(I,v)});Object.defineProperty(t,"tp$slots",{value:null,writable:!0})}};Sk.abstr.buildNativeClass=function(l,q){q=q||{};Sk.asserts.assert(q.hasOwnProperty("constructor"),"A constructor is required to build a native class");let z=q.constructor;Sk.abstr.setUpInheritance(l,z,q.base,q.meta);Sk.abstr.setUpBuiltinMro(z);const r=z.prototype;Object.defineProperties(r,{tp$slots:{value:q.slots,writable:!0},tp$getsets:{value:q.getsets,writable:!0},tp$methods:{value:q.methods,
writable:!0},tp$classmethods:{value:q.classmethods,writable:!0}});Sk.abstr.setUpSlots(z,q.slots||{});Sk.abstr.setUpMethods(z,q.methods);Sk.abstr.setUpGetSets(z,q.getsets);Sk.abstr.setUpClassMethods(z,q.classmethods);Object.entries(q.proto||{}).forEach(t=>{var [x,v]=t;Object.defineProperty(r,x,{value:v,writable:!0,enumerable:!(x.includes("$")||x in Object.prototype)})});Object.entries(q.flags||{}).forEach(t=>{var [x,v]=t;Object.defineProperty(z,x,{value:v,writable:!0})});r.hasOwnProperty("tp$iter")&&
(r[Symbol.iterator]=function(){return this.tp$iter()[Symbol.iterator]()});void 0!==Sk.builtin.str&&r.hasOwnProperty("tp$doc")&&!r.hasOwnProperty("__doc__")&&(l=r.tp$doc||null,r.__doc__="string"===typeof l?new Sk.builtin.str(l):Sk.builtin.none.none$);return z};Sk.abstr.buildIteratorClass=function(l,q){Sk.asserts.assert(q.hasOwnProperty("constructor"),"must provide a constructor");q.slots=q.slots||{};q.slots.tp$iter=Sk.generic.selfIter;q.slots.tp$iternext=q.slots.tp$iternext||q.iternext;q.slots.tp$getattr=
q.slots.tp$getattr||Sk.generic.getAttr;l=Sk.abstr.buildNativeClass(l,q);Sk.abstr.built$iterators.push(l);l.prototype[Symbol.iterator]=function(){return{next:()=>{const z=this.tp$iternext();return{value:z,done:void 0===z}}}};return l};Sk.abstr.built$iterators=[];Sk.abstr.setUpModuleMethods=function(l,q,z){Object.entries(z).forEach(r=>{var [t,x]=r;x.$name=x.$name||t;q[t]=new Sk.builtin.sk_method(x,null,l)});return q};Sk.abstr.superConstructor=function(l,q,z){var r=Array.prototype.slice.call(arguments,
2);l.prototype.tp$base.apply(q,r)}},function(F,P){function b(f){const h=f.prototype,p=h.tp$base;if(null==p)return!1;const g=p.prototype;return p.sk$solidSlotBase||f.sk$solidSlotBase||g.sk$hasDict!==h.sk$hasDict||p.sk$solidBase&&p!==Sk.builtin.module?!1:!0}function e(f,h){f=f.prototype;h=h.prototype;const p=f.ht$slots,g=h.ht$slots;return f.sk$hasDict!==h.sk$hasDict?!1:p===g?!0:p&&g?p.length===g.length&&p.every((a,c)=>a===g[c]):(p&&(p.length||null))===(g&&(g.length||null))}const d=new WeakMap;Sk.builtin.object=
Sk.abstr.buildNativeClass("object",{constructor:function(){Sk.asserts.assert(this instanceof Sk.builtin.object,"bad call to object, use 'new'")},base:null,slots:{tp$new(f,h){if(f.length||h&&h.length){if(this.tp$new!==Sk.builtin.object.prototype.tp$new)throw new Sk.builtin.TypeError("object.__new__() takes exactly one argument (the type to instantiate)");if(this.tp$init===Sk.builtin.object.prototype.tp$init)throw new Sk.builtin.TypeError(Sk.abstr.typeName(this)+"() takes no arguments");}return new this.constructor},
tp$init(f,h){if(f.length||h&&h.length){if(this.tp$init!==Sk.builtin.object.prototype.tp$init)throw new Sk.builtin.TypeError("object.__init__() takes exactly one argument (the instance to initialize)");if(this.tp$new===Sk.builtin.object.prototype.tp$new)throw new Sk.builtin.TypeError(Sk.abstr.typeName(this)+".__init__() takes exactly one argument (the instance to initialize)");}},tp$getattr:Sk.generic.getAttr,tp$setattr:Sk.generic.setAttr,$r(){const f=Sk.abstr.lookupSpecial(this,Sk.builtin.str.$module);
let h="";f&&Sk.builtin.checkString(f)&&(h=f.v+".");return new Sk.builtin.str("<"+h+Sk.abstr.typeName(this)+" object>")},tp$str(){return this.$r()},tp$hash(){let f=d.get(this);if(void 0!==f)return f;f=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER-Number.MAX_SAFE_INTEGER/2);d.set(this,f);return f},tp$richcompare(f,h){switch(h){case "Eq":f=this===f||Sk.builtin.NotImplemented.NotImplemented$;break;case "NotEq":f=this.ob$eq(f,"Eq");f!==Sk.builtin.NotImplemented.NotImplemented$&&(f=!Sk.misceval.isTrue(f));
break;default:f=Sk.builtin.NotImplemented.NotImplemented$}return f},tp$doc:"The most base type"},getsets:{__class__:{$get(){return this.ob$type},$set(f){if(void 0===f)throw new Sk.builtin.TypeError("can't delete __class__ attribute");if(!Sk.builtin.checkClass(f))throw new Sk.builtin.TypeError("__class__ must be set to a class, not '"+Sk.abstr.typeName(f)+"' object");const h=this.ob$type;if(!(h.$isSubType(Sk.builtin.module)&&f.$isSubType(Sk.builtin.module)||void 0!==h.prototype.ht$type&&void 0!==f.prototype.ht$type))throw new Sk.builtin.TypeError(" __class__ assignment only supported for heap types or ModuleType subclasses");
{let p=h,g=f;for(;b(p);)p=p.prototype.tp$base;for(;b(g);)g=g.prototype.tp$base;if(p!==g&&(p.prototype.tp$base!==g.prototype.tp$base||!e(p,g)))throw new Sk.builtin.TypeError("__class__ assignment: '"+f.prototype.tp$name+"' object layout differs from '"+h.prototype.tp$name+"'");}Object.setPrototypeOf(this,f.prototype)},$doc:"the object's class"}},methods:{__dir__:{$meth:function(){let f=Sk.abstr.lookupAttr(this,Sk.builtin.str.$dict);f=void 0===f?new Sk.builtin.dict([]):f instanceof Sk.builtin.dict?
f.dict$copy():new Sk.builtin.dict([]);const h=Sk.abstr.lookupAttr(this,Sk.builtin.str.$class);void 0!==h&&h.$mergeClassDict(f);return new Sk.builtin.list(f.sk$asarray())},$flags:{NoArgs:!0},$doc:"Default dir() implementation."},__format__:{$meth(f){if(!Sk.builtin.checkString(f))throw new Sk.builtin.TypeError("__format__() argument must be str, not "+Sk.abstr.typeName(f));if(f!==Sk.builtin.str.$empty)throw new Sk.builtin.TypeError(`unsupported format string passed to ${Sk.abstr.typeName(this)}.__format__`);
return this.tp$str()},$flags:{OneArg:!0},$doc:"Default object formatter."}},classmethods:{__init_subclass__:{$meth(f){return Sk.builtin.none.none$},$flags:{FastCall:!0,NoKwargs:!0}}},proto:{valueOf:Object.prototype.valueOf,toString(){return this.tp$str().v},hasOwnProperty:Object.prototype.hasOwnProperty,ht$type:void 0,sk$attrError(){return"'"+this.tp$name+"' object"},$mergeClassDict(f){var h=Sk.abstr.lookupAttr(this,Sk.builtin.str.$dict);void 0!==h&&f.dict$merge(h);h=Sk.abstr.lookupAttr(this,Sk.builtin.str.$bases);
if(void 0!==h){var p=Sk.builtin.len(h).valueOf();for(let g=0;g<p;g++)Sk.abstr.objectGetItem(h,new Sk.builtin.int_(g)).$mergeClassDict(f)}}}});Sk.abstr.setUpInheritance("type",Sk.builtin.type,Sk.builtin.object);Sk.abstr.setUpBuiltinMro(Sk.builtin.type)},function(F,P){function b(t,x,v){Sk.abstr.checkNoArgs(this.$name,x,v);t=this.call(t);return void 0===t?Sk.builtin.none.none$:t}function e(t,x,v){Sk.abstr.checkOneArg(this.$name,x,v);t=this.call(t,x[0]);return void 0===t?Sk.builtin.none.none$:t}function d(t,
x,v){Sk.abstr.checkOneArg(this.$name,x,v);t=this.call(t,x[0],!0);return Sk.misceval.chain(t,B=>void 0===B?Sk.builtin.none.none$:B)}function f(t,x,v){Sk.abstr.checkNoKwargs(this.$name,v);Sk.abstr.checkArgsLen(this.$name,x,1,2);t=this.call(t,...x);return void 0===t?Sk.builtin.none.none$:t}function h(t,x,v){Sk.abstr.checkNoKwargs(this.$name,v);Sk.abstr.checkArgsLen(this.$name,x,2,2);return Sk.misceval.chain(this.call(t,x[0],x[1],!0),()=>Sk.builtin.none.none$)}function p(t,x,v){Sk.abstr.checkOneArg(this.$name,
x,v);t=this.call(t,x[0],void 0,!0);return Sk.misceval.chain(t,B=>void 0===B?Sk.builtin.none.none$:B)}function g(t,x,v){t=e.call(this,t,x,v);return t===Sk.builtin.NotImplemented.NotImplemented$?t:new Sk.builtin.bool(t)}function a(t,x,v){return function(B,I,M){B=t.call(this,B,I,M);return v?Sk.misceval.chain(B,x):x(Sk.misceval.retryOptionalSuspensionOrThrow(B))}}function c(t){return function(){const x=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;return Sk.misceval.callsimArray(x,[])}}function n(t,
x,v,B){return function(I){return function(){var M=I.tp$descr_get?I.tp$descr_get(this,this.ob$type):I;M=Sk.misceval.callsimArray(M,[]);if(!x(M))throw new Sk.builtin.TypeError(t+" should return "+v+" (returned "+Sk.abstr.typeName(M)+")");return void 0!==B?B(M):M}}}function m(t){return function(x){const v=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;return Sk.misceval.callsimArray(v,[x])}}function k(t,x){let v=this.ob$type.$typeLookup(Sk.builtin.str.$getattribute);if(v instanceof Sk.builtin.wrapper_descriptor)return v.d$wrapped.call(this,
t,x);v.tp$descr_get&&(v=v.tp$descr_get(this,this.ob$type));const B=Sk.misceval.tryCatch(()=>Sk.misceval.callsimOrSuspendArray(v,[t]),I=>{if(!(I instanceof Sk.builtin.AttributeError))throw I;});return x?B:Sk.misceval.retryOptionalSuspensionOrThrow(B)}function u(t,x,v){return function(B){return function(I,M,S){let E;void 0===M?(E=x,v=null):E=t;let H=this.ob$type.$typeLookup(new Sk.builtin.str(E));if(H instanceof Sk.builtin.wrapper_descriptor)return H.d$wrapped.call(this,I,M);H.tp$descr_get&&(H=H.tp$descr_get(this,
this.ob$type,S));if(void 0!==H)I=Sk.misceval.callsimOrSuspendArray(H,void 0===M?[I]:[I,M]);else{if(v)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(this)+"' object "+v);throw new Sk.builtin.AttributeError(E);}return S?I:Sk.misceval.retryOptionalSuspensionOrThrow(I)}}}function l(t,x){let v=t.ob$type;for(;v&&void 0!==v.sk$klass;)v=v.prototype.tp$base;if(v&&v.prototype.tp$setattr!==x)throw new Sk.builtin.TypeError("can't apply this "+x.$name+" to "+Sk.abstr.typeName(t)+" object");}Sk.slots=Object.create(null);
F=Sk.slots;Sk.slots.__init__={$name:"__init__",$slot_name:"tp$init",$slot_func:function(t){return function(x,v){const B=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;x=Sk.misceval.callsimOrSuspendArray(B,x,v);return Sk.misceval.chain(x,I=>{if(!Sk.builtin.checkNone(I)&&void 0!==I)throw new Sk.builtin.TypeError("__init__() should return None, not "+Sk.abstr.typeName(I));})}},$wrapper:function(t,x,v){this.call(t,x,v);return Sk.builtin.none.none$},$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},
$doc:"Initialize self.  See help(type(self)) for accurate signature."};F.__new__={$name:"__new__",$slot_name:"tp$new",$slot_func:function(t){const x=function(v,B){let I=t;t.tp$descr_get&&(I=t.tp$descr_get(null,this.constructor));return Sk.misceval.callsimOrSuspendArray(I,[this.constructor,...v],B)};x.sk$static_new=!1;return x},$wrapper:null,$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Create and return a new object."};F.__call__={$name:"__call__",$slot_name:"tp$call",$slot_func:function(t){return function(x,
v){const B=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;return Sk.misceval.callsimOrSuspendArray(B,x,v)}},$wrapper:function(t,x,v){t=t.tp$call(x,v);return void 0===t?Sk.builtin.none.none$:t},$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Call self as a function."};F.__repr__={$name:"__repr__",$slot_name:"$r",$slot_func:n("__repr__",Sk.builtin.checkString,"str"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return repr(self)."};F.__str__={$name:"__str__",$slot_name:"tp$str",
$slot_func:n("__str__",Sk.builtin.checkString,"str"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return str(self)."};var q=n("__hash__",Sk.builtin.checkInt,"int",t=>"number"===typeof t.v?t.v:t.tp$hash());F.__hash__={$name:"__hash__",$slot_name:"tp$hash",$slot_func:function(t){return t===Sk.builtin.none.none$?Sk.builtin.none.none$:q(t)},$wrapper:a(b,t=>new Sk.builtin.int_(t)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return hash(self)."};F.__getattribute__={$name:"__getattribute__",
$slot_name:"tp$getattr",$slot_func:function(t){return function(x,v){let B=this.ob$type.$typeLookup(Sk.builtin.str.$getattr);if(void 0===B)return k.call(this,x,v);const I=Sk.misceval.chain(k.call(this,x,v),M=>Sk.misceval.tryCatch(()=>{if(void 0!==M)return M;B.tp$descr_get&&(B=B.tp$descr_get(this,this.ob$type));return Sk.misceval.callsimOrSuspendArray(B,[x])},function(S){if(!(S instanceof Sk.builtin.AttributeError))throw S;}));return v?I:Sk.misceval.retryOptionalSuspensionOrThrow(I)}},$wrapper:function(t,
x,v){Sk.abstr.checkOneArg(this.$name,x,v);const B=x[0];if(!Sk.builtin.checkString(B))throw new Sk.builtin.TypeError("attribute name must be string, not '"+Sk.abstr.typeName(B)+"'");x=this.call(t,B,!0);return Sk.misceval.chain(x,I=>{if(void 0===I)throw new Sk.builtin.AttributeError(Sk.abstr.typeName(t)+" has no attribute "+B.$jsstr());return I})},$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Return getattr(self, name)."};F.__getattr__={$name:"__getattr__",$slot_name:"tp$getattr",$slot_func:F.__getattribute__.$slot_func,
$wrapper:null,$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Return getattr(self, name)."};F.__setattr__={$name:"__setattr__",$slot_name:"tp$setattr",$slot_func:u("__setattr__","__delattr__"),$wrapper:function(t,x,v){Sk.abstr.checkNoKwargs(this.$name,v);Sk.abstr.checkArgsLen(this.$name,x,2,2);l(t,this);return Sk.misceval.chain(this.call(t,x[0],x[1],!0),()=>Sk.builtin.none.none$)},$textsig:"($self, name, value, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Implement setattr(self, name, value)."};F.__delattr__=
{$name:"__delattr__",$slot_name:"tp$setattr",$slot_func:F.__setattr__.$slot_func,$wrapper:function(t,x,v){Sk.abstr.checkOneArg(this.$name,x,v);l(t,this);this.call(t,x[0]);return Sk.builtin.none.none$},$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Implement delattr(self, name)."};F.__get__={$name:"__get__",$slot_name:"tp$descr_get",$slot_func:function(t){return function(x,v,B){null===x&&(x=Sk.builtin.none.none$);null==v&&(v=Sk.builtin.none.none$);const I=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):
t;x=Sk.misceval.callsimOrSuspendArray(I,[x,v]);return B?x:Sk.misceval.retryOptionalSuspensionOrThrow(x)}},$wrapper:function(t,x,v){Sk.abstr.checkNoKwargs(this.$name,v);Sk.abstr.checkArgsLen(this.$name,x,1,2);v=x[0];x=x[1];v===Sk.builtin.none.none$&&(v=null);x===Sk.builtin.none.none$&&(x=null);if(null===x&&null===v)throw new Sk.builtin.TypeError("__get__(None, None) is invalid");return this.call(t,v,x,!0)},$textsig:"($self, instance, owner, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Return an attribute of instance, which is of type owner."};
F.__set__={$name:"__set__",$slot_name:"tp$descr_set",$slot_func:u("__set__","__delete__"),$wrapper:h,$textsig:"($self, instance, value, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Set an attribute of instance to value."};F.__delete__={$name:"__delete__",$slot_name:"tp$descr_set",$slot_func:F.__set__.$slot_func,$wrapper:p,$textsig:"($self, instance, /)",$flags:{OneArg:!0},$doc:"Delete an attribute of instance."};F.__eq__={$name:"__eq__",$slot_name:"ob$eq",$slot_func:m,$wrapper:g,$textsig:"($self, value, /)",
$flags:{OneArg:!0},$doc:"Return self==value."};F.__ge__={$name:"__ge__",$slot_name:"ob$ge",$slot_func:m,$wrapper:g,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>=value."};F.__gt__={$name:"__gt__",$slot_name:"ob$gt",$slot_func:m,$wrapper:g,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>value."};F.__le__={$name:"__le__",$slot_name:"ob$le",$slot_func:m,$wrapper:g,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<=value."};F.__lt__={$name:"__lt__",
$slot_name:"ob$lt",$slot_func:m,$wrapper:g,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<value."};F.__ne__={$name:"__ne__",$slot_name:"ob$ne",$slot_func:m,$wrapper:g,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self!=value."};F.__iter__={$name:"__iter__",$slot_name:"tp$iter",$slot_func:c,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Implement iter(self)."};F.__next__={$name:"__next__",$slot_name:"tp$iternext",$slot_func:function(t){return function(x){const v=
t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t,B=Sk.misceval.tryCatch(()=>Sk.misceval.callsimOrSuspendArray(v,[]),I=>{if(I instanceof Sk.builtin.StopIteration)this.gi$ret=I.$value;else throw I;});return x?B:Sk.misceval.retryOptionalSuspensionOrThrow(B)}},$wrapper:function(t,x,v){Sk.abstr.checkNoArgs(this.$name,x,v);return Sk.misceval.chain(t.tp$iternext(!0),B=>{if(void 0===B)throw new Sk.builtin.StopIteration;return B})},$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Implement next(self)."};F.__len__=
{$name:"__len__",$slot_name:"sq$length",$slot_func:function(t){return function(x){const v=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;if(x)return x=Sk.misceval.callsimOrSuspendArray(v,[]),Sk.misceval.chain(x,B=>Sk.misceval.asIndexOrThrow(B));x=Sk.misceval.callsimArray(v,[]);return Sk.misceval.asIndexOrThrow(x)}},$wrapper:a(function(t,x,v){Sk.abstr.checkNoArgs(this.$name,x,v);t=this.call(t,!0);return Sk.misceval.chain(t,B=>void 0===B?Sk.builtin.none.none$:B)},t=>new Sk.builtin.int_(t),!0),$flags:{NoArgs:!0},
$textsig:"($self, /)",$doc:"Return len(self)."};F.__contains__={$name:"__contains__",$slot_name:"sq$contains",$slot_func:function(t){return function(x,v){const B=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;x=Sk.misceval.callsimOrSuspendArray(B,[x]);x=Sk.misceval.chain(x,I=>Sk.misceval.isTrue(I));return x.$isSuspension?v?x:Sk.misceval.retryOptionalSuspensionOrThrow(x):x}},$wrapper:a(d,t=>new Sk.builtin.bool(t),!0),$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Return key in self."};F.__getitem__=
{$name:"__getitem__",$slot_name:"mp$subscript",$slot_func:function(t){return function(x,v){const B=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;x=Sk.misceval.callsimOrSuspendArray(B,[x]);return v?x:Sk.misceval.retryOptionalSuspensionOrThrow(x)}},$wrapper:d,$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Return self[key]."};F.__setitem__={$name:"__setitem__",$slot_name:"mp$ass_subscript",$slot_func:u("__setitem__","__delitem__","does not support item assignment"),$wrapper:h,$textsig:"($self, key, value, /)",
$flags:{MinArgs:2,MaxArgs:2},$doc:"Set self[key] to value."};F.__delitem__={$name:"__delitem__",$slot_name:"mp$ass_subscript",$slot_func:F.__setitem__.$slot_func,$wrapper:p,$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Delete self[key]."};F.__add__={$name:"__add__",$slot_name:"nb$add",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self+value."};F.__radd__={$name:"__radd__",$slot_name:"nb$reflected_add",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",
$flags:{OneArg:!0},$doc:"Return value+self."};F.__iadd__={$name:"__iadd__",$slot_name:"nb$inplace_add",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self+=value."};F.__sub__={$name:"__sub__",$slot_name:"nb$subtract",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self-value."};F.__rsub__={$name:"__rsub__",$slot_name:"nb$reflected_subtract",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value-self."};
F.__imul__={$name:"__imul__",$slot_name:"nb$inplace_multiply",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self*=value."};F.__mul__={$name:"__mul__",$slot_name:"nb$multiply",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self*value."};F.__rmul__={$name:"__rmul__",$slot_name:"nb$reflected_multiply",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value*self."};F.__isub__={$name:"__isub__",
$slot_name:"nb$inplace_subtract",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self-=value."};F.__mod__={$name:"__mod__",$slot_name:"nb$remainder",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self%value."};F.__rmod__={$name:"__rmod__",$slot_name:"nb$reflected_remainder",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value%self."};F.__imod__={$name:"__imod__",$slot_name:"nb$inplace_remainder",
$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement value%=self."};F.__divmod__={$name:"__divmod__",$slot_name:"nb$divmod",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return divmod(self, value)."};F.__rdivmod__={$name:"__rdivmod__",$slot_name:"nb$reflected_divmod",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return divmod(value, self)"};F.__pos__={$name:"__pos__",$slot_name:"nb$positive",$slot_func:c,
$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"+self"};F.__neg__={$name:"__neg__",$slot_name:"nb$negative",$slot_func:c,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"-self"};F.__abs__={$name:"__abs__",$slot_name:"nb$abs",$slot_func:c,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"abs(self)"};F.__bool__={$name:"__bool__",$slot_name:"nb$bool",$slot_func:n("__bool__",Sk.builtin.checkBool,"bool",t=>0!==t.v),$wrapper:a(b,t=>new Sk.builtin.bool(t)),$textsig:"($self, /)",
$flags:{NoArgs:!0},$doc:"self != 0"};F.__invert__={$name:"__invert__",$slot_name:"nb$invert",$slot_func:c,$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"~self"};F.__lshift__={$name:"__lshift__",$slot_name:"nb$lshift",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<<value."};F.__rlshift__={$name:"__rlshift__",$slot_name:"nb$reflected_lshift",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value<<self."};F.__rshift__=
{$name:"__rshift__",$slot_name:"nb$rshift",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>>value."};F.__rrshift__={$name:"__rrshift__",$slot_name:"nb$reflected_rshift",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value>>self."};F.__ilshift__={$name:"__ilshift__",$slot_name:"nb$inplace_lshift",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self<<=value."};F.__irshift__={$name:"__irshift__",
$slot_name:"nb$inplace_rshift",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self=>>value."};F.__and__={$name:"__and__",$slot_name:"nb$and",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self&value."};F.__rand__={$name:"__rand__",$slot_name:"nb$refelcted_and",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value&self."};F.__iand__={$name:"__iand__",$slot_name:"nb$and",$slot_func:m,
$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self&=value."};F.__xor__={$name:"__xor__",$slot_name:"nb$xor",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self^value."};F.__rxor__={$name:"__rxor__",$slot_name:"nb$reflected_xor",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value^self."};F.__ixor__={$name:"__ixor__",$slot_name:"nb$inplace_xor",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",
$flags:{OneArg:!0},$doc:"Implement self^=value."};F.__or__={$name:"__or__",$slot_name:"nb$or",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self|value."};F.__ror__={$name:"__ror__",$slot_name:"nb$reflected_or",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value|self."};F.__ior__={$name:"__ior__",$slot_name:"nb$inplace_or",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self|=value."};
F.__int__={$name:"__int__",$slot_name:"nb$int",$slot_func:n("__int__",Sk.builtin.checkInt,"int"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"int(self)"};F.__float__={$name:"__float__",$slot_name:"nb$float",$slot_func:n("__float__",Sk.builtin.checkFloat,"float"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"float(self)"};F.__floordiv__={$name:"__floordiv__",$slot_name:"nb$floor_divide",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self//value."};
F.__rfloordiv__={$name:"__rfloordiv__",$slot_name:"nb$reflected_floor_divide",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value//self."};F.__ifloordiv__={$name:"__ifloordiv__",$slot_name:"nb$inplace_floor_divide",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self//=value."};F.__truediv__={$name:"__truediv__",$slot_name:"nb$divide",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self/value."};
F.__rtruediv__={$name:"__rtruediv__",$slot_name:"nb$reflected_divide",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value/self."};F.__itruediv__={$name:"__itruediv__",$slot_name:"nb$inplace_divide",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self/=value."};F.__index__={$name:"__index__",$slot_name:"nb$index",$slot_func:n("__index__",Sk.builtin.checkInt,"int",t=>t.v),$wrapper:a(b,t=>new Sk.builtin.int_(t)),$textsig:"($self, /)",
$flags:{NoArgs:!0},$doc:"Return self converted to an integer, if self is suitable for use as an index into a list."};F.__pow__={$name:"__pow__",$slot_name:"nb$power",$slot_func:function(t){return function(x,v){const B=t.tp$descr_get?t.tp$descr_get(this,this.ob$type):t;return void 0==v?Sk.misceval.callsimArray(B,[x]):Sk.misceval.callsimArray(B,[x,v])}},$wrapper:f,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,MaxArgs:2},$doc:"Return pow(self, value, mod)."};F.__rpow__={$name:"__rpow__",$slot_name:"nb$reflected_power",
$slot_func:F.__pow__.$slot_func,$wrapper:f,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,MaxArgs:2},$doc:"Return pow(value, self, mod)."};F.__ipow__={$name:"__ipow__",$slot_name:"nb$inplace_power",$slot_func:F.__pow__.$slot_func,$wrapper:f,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,MaxArgs:2},$doc:"Implement **="};F.__matmul__={$name:"__matmul__",$slot_name:"nb$matrix_multiply",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self@value."};
F.__rmatmul__={$name:"__rmatmul__",$slot_name:"nb$reflected_matrix_multiply",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value@self."};F.__imatmul__={$name:"__imatmul__",$slot_name:"nb$inplace_matrix_multiply",$slot_func:m,$wrapper:e,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self@=value."};F.__long__={$name:"__long__",$slot_name:"nb$long",$slot_func:n("__long__",Sk.builtin.checkInt,"int"),$wrapper:b,$textsig:"($self, /)",$flags:{NoArgs:!0},
$doc:"int(self)"};var z,r={next:{$name:"next",$slot_name:"tp$iternext",$slot_func:F.__next__.$slot_func,$wrapper:F.__next__.$wrapper,$textsig:F.__next__.$textsig,$flags:F.__next__.$flags},__nonzero__:{$name:"__nonzero__",$slot_name:"nb$bool",$slot_func:n("__nonzero__",Sk.builtin.checkInt,"int",t=>0!==t.v),$wrapper:a(b,t=>new Sk.builtin.bool(t)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"x.__nonzero__() <==> x != 0"},__div__:{$name:"__div__",$slot_name:"nb$divide",$slot_func:m,$wrapper:e,$textsig:"($self, other/)",
$flags:{OneArg:!0},$doc:"x.__div__(y) <==> x/y"},__rdiv__:{$name:"__rdiv__",$slot_name:"nb$reflected_divide",$slot_func:m,$wrapper:e,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"x.__rdiv__(y) <==> x/y"},__idiv__:{$name:"__idiv__",$slot_name:"nb$inplace_divide",$slot_func:m,$wrapper:e,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"implement self /= other"}};Sk.subSlots={main_slots:Object.entries({tp$init:"__init__",tp$call:"__call__",$r:"__repr__",tp$str:"__str__",tp$getattr:"__getattribute__",
tp$setattr:["__setattr__","__delattr__"],ob$eq:"__eq__",ob$ne:"__ne__",ob$lt:"__lt__",ob$le:"__le__",ob$gt:"__gt__",ob$ge:"__ge__",tp$descr_get:"__get__",tp$descr_set:["__set__","__delete__"],tp$iter:"__iter__",tp$iternext:"__next__"}),number_slots:Object.entries({nb$abs:"__abs__",nb$negative:"__neg__",nb$positive:"__pos__",nb$int:"__int__",nb$long:"__long__",nb$float:"__float__",nb$index:"__index__",nb$add:"__add__",nb$reflected_add:"__radd__",nb$inplace_add:"__iadd__",nb$subtract:"__sub__",nb$reflected_subtract:"__rsub__",
nb$inplace_subtract:"__isub__",nb$multiply:"__mul__",nb$reflected_multiply:"__rmul__",nb$inplace_multiply:"__imul__",nb$floor_divide:"__floordiv__",nb$reflected_floor_divide:"__rfloordiv__",nb$inplace_floor_divide:"__ifloordiv__",nb$invert:"__invert__",nb$remainder:"__mod__",nb$reflected_remainder:"__rmod__",nb$inplace_remainder:"__imod__",nb$divmod:"__divmod__",nb$reflected_divmod:"__rdivmod__",nb$power:"__pow__",nb$reflected_power:"__rpow__",nb$inplace_power:"__ipow__",nb$divide:"__truediv__",nb$reflected_divide:"__rtruediv__",
nb$inplace_divide:"__itruediv__",nb$bool:"__bool__",nb$and:"__and__",nb$reflected_and:"__rand__",nb$inplace_and:"__iand__",nb$or:"__or__",nb$reflected_or:"__ror__",nb$inplace_or:"__ior__",nb$xor:"__xor__",nb$reflected_xor:"__rxor__",nb$inplace_xor:"__ixor__",nb$lshift:"__lshift__",nb$reflected_lshift:"__rlshift__",nb$rshift:"__rshift__",nb$reflected_rshift:"__rrshift__",nb$inplace_lshift:"__ilshift__",nb$inplace_rshift:"__irshift__",nb$matrix_multiply:"__matmul__",nb$reflected_matrix_multiply:"__rmatmul__",
nb$inplace_matrix_multiply:"__imatmul__"}),sequence_and_mapping_slots:Object.entries({sq$length:"__len__",sq$contains:"__contains__",mp$subscript:"__getitem__",mp$ass_subscript:["__setitem__","__delitem__"],nb$add:"__add__",nb$multiply:"__mul__",nb$reflected_multiply:"__rmul__",nb$inplace_add:"__iadd__",nb$inplace_multiply:"__imul__"})};Sk.reflectedNumberSlots={nb$add:{reflected:"nb$reflected_add"},nb$subtract:{reflected:"nb$reflected_subtract",slot:function(t){return t instanceof this.constructor?
t.nb$subtract(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$multiply:{reflected:"nb$reflected_multiply"},nb$divide:{reflected:"nb$reflected_divide",slot:function(t){return t instanceof this.constructor?t.nb$divide(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$floor_divide:{reflected:"nb$reflected_floor_divide",slot:function(t){return t instanceof this.constructor?t.nb$floor_divide(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$remainder:{reflected:"nb$reflected_remainder",slot:function(t){return t instanceof
this.constructor?t.nb$remainder(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$divmod:{reflected:"nb$reflected_divmod",slot:function(t){return t instanceof this.constructor?t.nb$divmod(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$power:{reflected:"nb$reflected_power",slot:function(t,x){return t instanceof this.constructor?t.nb$power(this,x):Sk.builtin.NotImplemented.NotImplemented$}},nb$and:{reflected:"nb$reflected_and"},nb$or:{reflected:"nb$reflected_or"},nb$xor:{reflected:"nb$reflected_xor"},
nb$lshift:{reflected:"nb$reflected_lshift",slot:function(t){return t instanceof this.constructor?t.nb$lshift(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$rshift:{reflected:"nb$reflected_rshift",slot:function(t){return t instanceof this.constructor?t.nb$rshift(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$matrix_multiply:{reflected:"nb$reflexted_matrix_multiply",slot:function(t){return t instanceof this.constructor?t.nb$matrix_multiply(this):Sk.builtin.NotImplemented.NotImplemented$}}};
Sk.sequenceAndMappingSlots={sq$concat:["nb$add"],sq$repeat:["nb$multiply","nb$reflected_multiply"],mp$length:["sq$length"],sq$inplace_repeat:["nb$inplace_multiply"],sq$inplace_concat:["nb$inplace_add"]};Sk.dunderToSkulpt={__repr__:"$r",__str__:"tp$str",__init__:"tp$init",__new__:"tp$new",__hash__:"tp$hash",__call__:"tp$call",__iter__:"tp$iter",__next__:"tp$iternext",__eq__:"ob$eq",__ne__:"ob$ne",__lt__:"ob$lt",__le__:"ob$le",__gt__:"ob$gt",__ge__:"ob$ge",__abs__:"nb$abs",__neg__:"nb$negative",__pos__:"nb$positive",
__int__:"nb$int",__float__:"nb$float",__index__:"nb$index",__add__:"nb$add",__radd__:"nb$reflected_add",__iadd__:"nb$inplace_add",__sub__:"nb$subtract",__rsub__:"nb$reflected_subtract",__isub__:"nb$inplace_subtract",__mul__:"nb$multiply",__rmul__:"nb$reflected_multiply",__imul__:"nb$inplace_multiply",__truediv__:"nb$divide",__rtruediv__:"nb$reflected_divide",__itruediv__:"nb$inplace_divide",__floordiv__:"nb$floor_divide",__rfloordiv__:"nb$reflected_floor_divide",__ifloordiv__:"nb$inplace_floor_divide",
__invert__:"nb$invert",__mod__:"nb$remainder",__rmod__:"nb$reflected_remainder",__imod__:"nb$inplace_remainder",__divmod__:"nb$divmod",__rdivmod__:"nb$reflected_divmod",__pow__:"nb$power",__rpow__:"nb$reflected_power",__ipow__:"nb$inplace_power",__bool__:"nb$bool",__long__:"nb$long",__lshift__:"nb$lshift",__rlshift__:"nb$reflected_lshift",__ilshift__:"nb$inplace_lshift",__rshift__:"nb$rshift",__rrshift__:"nb$reflected_rshift",__irshift__:"nb$inplace_rshift",__and__:"nb$and",__rand__:"nb$reflected_and",
__iand__:"nb$inplace_and",__or__:"nb$or",__ror__:"nb$reflected_or",__ior__:"nb$inplace_or",__xor__:"nb$xor",__rxor__:"nb$reflected_xor",__ixor__:"nb$inplace_xor",__matmul__:"nb$matrix_multiply",__rmatmul__:"nb$reflected_matrix_multiply",__imatmul__:"nb$inplace_matrix_multiply",__get__:"tp$descr_get",__set__:"tp$descr_set",__delete__:"tp$descr_set",__getattribute__:"tp$getattr",__getattr__:"tp$getattr",__setattr__:"tp$setattr",__delattr__:"tp$setattr",__len__:"sq$length",__contains__:"sq$contains",
__getitem__:"mp$subscript",__setitem__:"mp$ass_subscript",__delitem__:"mp$ass_subscript"};Sk.exportSymbol("Sk.setupDunderMethods",Sk.setupDunderMethods);Sk.setupDunderMethods=function(t){function x(A,J,Q){for(let X=0;X<A.length;X++){const aa=A[X].prototype;aa.hasOwnProperty(Q)||(aa[Q]=aa[J],delete aa[J])}}var v=Sk.slots;if(!t||void 0!==z){var B=Sk.abstr.built$iterators,I=[Sk.builtin.int_,Sk.builtin.lng,Sk.builtin.float_,Sk.builtin.complex],M=Sk.subSlots.number_slots,S=Sk.subSlots.main_slots,E=S.findIndex(A=>
"tp$iternext"===A[0]),H=M.findIndex(A=>"nb$bool"===A[0]),y=Sk.dunderToSkulpt;if(t){y.__bool__="nb$bool";y.__next__="tp$iternext";delete y.__nonzero__;delete y.__div__;delete y.__rdiv__;delete y.__idiv__;delete y.next;for(let A in z)v[A]=z[A];for(let A in r)delete v[A];for(t=0;t<I.length;t++)v=I[t].prototype,delete v.__div__,delete v.__rdiv__;S[E][1]="__next__";M[H][1]="__bool__";x(B,"next","__next__");x(I,"__bool__","__nonzero__")}else{void 0===z&&(v.py3$slots={__next__:v.__next__},z=v.py3$slots);
y.next="tp$iternext";y.__nonzero__="nb$bool";y.__div__="nb$divide";y.__rdiv__="nb$reflected_divide";y.__idiv__="nb$inplace_divide";delete y.__bool__;delete y.__next__;for(let A in r)v[A]=r[A];for(let A in z)delete v[A];S[E][1]="next";M[H][1]="__nonzero__";x(B,"__next__","next");x(I,"__nonzero__","__bool__");for(B=0;B<I.length;B++)M=I[B],S=M.prototype,S.hasOwnProperty("__div__")||(S.__div__=new Sk.builtin.wrapper_descriptor(M,r.__div__,S.nb$divide),S.__rdiv__=new Sk.builtin.wrapper_descriptor(M,r.__rdiv__,
Sk.reflectedNumberSlots.nb$divide.slot))}}}},function(F,P){function b(p,g,a){return Sk.abstr.buildNativeClass(p,{constructor:a.constructor,slots:Object.assign({tp$getattr:Sk.generic.getAttr,$r:f},a.slots),getsets:Object.assign(a.getsets||{},h),proto:Object.assign(a.proto||{},{d$repr_name:g||p,d$check:e,d$set_check:d}),flags:{sk$unacceptableBase:!0}})}function e(p){if(null==p)return this;if(!p.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+
this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(p)+"' object");}function d(p){if(!p.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(p)+"' object");}function f(){return new Sk.builtin.str("<"+this.d$repr_name+" '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects>")}const h={__doc__:{$get(){return this.d$def.$doc?new Sk.builtin.str(this.d$def.$doc):
Sk.builtin.none.none$}},__objclass__:{$get(){return this.d$type}},__name__:{$get(){return new Sk.builtin.str(this.d$name)}}};F={__text_signature__:{$get(){return this.d$def.$textsig?new Sk.builtin.str(this.d$def.$textsig):Sk.builtin.none.none$}}};Sk.builtin.getset_descriptor=b("getset_descriptor",void 0,{constructor:function(p,g){this.d$def=g;this.$get=g.$get;this.$set=g.$set;this.d$type=p;this.d$name=g.$name},slots:{tp$descr_get(p,g,a){if(g=this.d$check(p))return g;if(void 0!==this.$get)return p=
this.$get.call(p),a?p:Sk.misceval.retryOptionalSuspensionOrThrow(p);throw new Sk.builtin.AttributeError("getset_descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects is not readable");},tp$descr_set(p,g,a){this.d$set_check(p);if(void 0!==this.$set)return p=this.$set.call(p,g),a?p:Sk.misceval.retryOptionalSuspensionOrThrow(p);throw new Sk.builtin.AttributeError("attribute '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects is readonly");}}});Sk.builtin.method_descriptor=
b("method_descriptor","method",{constructor:function(p,g){this.d$def=g;this.$meth=g.$meth;this.d$type=p;this.d$name=g.$name||"<native JS>";this.$flags=p=g.$flags||{};p.FastCall&&p.NoKwargs?this.tp$call=this.$methodFastCallNoKwargs:p.FastCall?this.tp$call=this.$methodFastCall:p.NoArgs?this.tp$call=this.$methodCallNoArgs:p.OneArg?this.tp$call=this.$methodCallOneArg:p.NamedArgs?this.tp$call=this.$methodCallNamedArgs:void 0!==p.MinArgs?this.tp$call=this.$methodCallMinArgs:(this.func_code=g.$meth,this.tp$call=
this.$defaultCall,this.$memoiseFlags=Sk.builtin.func.prototype.$memoiseFlags,this.$resolveArgs=Sk.builtin.func.prototype.$resolveArgs)},slots:{tp$call(p,g){return this.tp$call(p,g)},tp$descr_get(p,g){let a;return(a=this.d$check(p))?a:new Sk.builtin.sk_method(this.d$def,p)}},getsets:F,proto:{$methodFastCall(p,g){const a=p.shift();this.m$checkself(a);return this.$meth.call(a,p,g)},$methodFastCallNoKwargs(p,g){const a=p.shift();this.m$checkself(a);Sk.abstr.checkNoKwargs(this.d$name,g);return this.$meth.call(a,
p)},$methodCallNoArgs(p,g){const a=p.shift();this.m$checkself(a);Sk.abstr.checkNoArgs(this.d$name,p,g);return this.$meth.call(a)},$methodCallOneArg(p,g){const a=p.shift();this.m$checkself(a);Sk.abstr.checkOneArg(this.d$name,p,g);return this.$meth.call(a,p[0])},$methodCallNamedArgs(p,g){const a=p.shift();this.m$checkself(a);p=Sk.abstr.copyKeywordsToNamedArgs(this.d$name,this.$flags.NamedArgs,p,g,this.$flags.Defaults);return this.$meth.call(a,...p)},$methodCallMinArgs(p,g){const a=p.shift();this.m$checkself(a);
Sk.abstr.checkNoKwargs(this.d$name,g);Sk.abstr.checkArgsLen(this.d$name,p,this.$flags.MinArgs,this.$flags.MaxArgs);return this.$meth.call(a,...p)},$defaultCall(p,g){this.m$checkself(p[0]);return Sk.builtin.func.prototype.tp$call.call(this,p,g)},m$checkself(p){if(void 0===p)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");this.d$check(p)}}});Sk.builtin.wrapper_descriptor=b("wrapper_descriptor","slot wrapper",{constructor:function(p,
g,a){this.d$def=g;this.d$type=p;this.d$name=a.$name=g.$name;this.d$wrapped=a},slots:{tp$descr_get(p,g){let a;return(a=this.d$check(p))?a:new Sk.builtin.method_wrapper(this,p)},tp$call(p,g){if(1>p.length)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");const a=p.shift();if(!a.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+
Sk.abstr.typeName(a)+"'");return this.raw$call(a,p,g)}},proto:{raw$call(p,g,a){this.d$wrapped.$name=this.d$name;return this.d$def.$wrapper.call(this.d$wrapped,p,g,a)}}});Sk.builtin.method_wrapper=b("method_wrapper",void 0,{constructor:function(p,g){this.m$descr=p;this.m$self=g;this.d$def=p.d$def;this.d$name=p.d$name;this.d$type=p.d$type},slots:{tp$call(p,g){return this.m$descr.raw$call(this.m$self,p,g)},tp$richcompare(p,g){if("Eq"!==g&&"NotEq"!==g||!(p instanceof Sk.builtin.method_wrapper))return Sk.builtin.NotImplemented.NotImplemented$;
p=this.m$self===p.m$self&&this.m$descr===p.m$descr;return"Eq"===g?p:!p},$r(){return new Sk.builtin.str("<method-wrapper '"+this.d$name+"' of "+Sk.abstr.typeName(this.m$self)+" object>")}},getsets:{__self__:{$get(){return this.m$self}}}});Sk.builtin.classmethod_descriptor=b("classmethod_descriptor","method",{constructor:function(p,g){this.d$def=g;this.$meth=g.$meth;this.d$type=p;this.d$name=g.$name||"<native JS>"},slots:{tp$call(p,g){if(1>p.length)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+
"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");const a=p.shift();return this.tp$descr_get(null,a).tp$call(p,g)},tp$descr_get(p,g,a){if(void 0===g)if(null!==p)g=g||p.ob$type;else throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' for type '"+this.d$type.prototype.tp$name+"' needs an object or a type");if(!g.ob$type.$isSubType(Sk.builtin.type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' for type '"+this.d$type.prototype.tp$name+"' needs a type not a '"+
Sk.abstr.typeName(g)+"' as arg 2");if(!g.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(g)+"' object");return new Sk.builtin.sk_method(this.d$def,g)}},getsets:F});[Sk.builtin.method_descriptor,Sk.builtin.getset_descriptor,Sk.builtin.wrapper_descriptor,Sk.builtin.method_wrapper,Sk.builtin.classmethod_descriptor].forEach(p=>{Sk.abstr.setUpSlots(p);Sk.abstr.setUpMethods(p);
Sk.abstr.setUpGetSets(p)})},function(F,P){Sk.builtin.sk_method=Sk.abstr.buildNativeClass("builtin_function_or_method",{constructor:function(b,e,d){this.$meth=b.$meth.bind(e);this.$doc=b.$doc;this.$self=e||null;this.$module=d?new Sk.builtin.str(d):null;this.$name=b.$name||b.$meth.name||"<native JS>";this.m$def=b;this.$textsig=b.$textsig;this.$flags=b=b.$flags||{};b.FastCall&&b.NoKwargs?this.tp$call=this.$fastCallNoKwargs:b.FastCall?this.tp$call=this.$meth:b.NoArgs?this.tp$call=this.$callNoArgs:b.OneArg?
this.tp$call=this.$callOneArg:b.NamedArgs?this.tp$call=this.$callNamedArgs:void 0!==b.MinArgs?this.tp$call=this.$callMinArgs:(this.func_code=this.$meth,this.tp$call=this.$defaultCallMethod)},proto:{$fastCallNoKwargs(b,e){Sk.abstr.checkNoKwargs(this.$name,e);return this.$meth(b)},$callNoArgs(b,e){Sk.abstr.checkNoArgs(this.$name,b,e);return this.$meth()},$callOneArg(b,e){Sk.abstr.checkOneArg(this.$name,b,e);return this.$meth(b[0])},$callNamedArgs(b,e){b=Sk.abstr.copyKeywordsToNamedArgs(this.$name,this.$flags.NamedArgs,
b,e,this.$flags.Defaults);return this.$meth(...b)},$callMinArgs(b,e){Sk.abstr.checkNoKwargs(this.$name,e);Sk.abstr.checkArgsLen(this.$name,b,this.$flags.MinArgs,this.$flags.MaxArgs);return this.$meth(...b)},$defaultCallMethod(b,e){return null!==this.$self?Sk.builtin.func.prototype.tp$call.call(this,[this.$self,...b],e):Sk.builtin.func.prototype.tp$call.call(this,b,e)},$memoiseFlags(){return Sk.builtin.func.prototype.$memoiseFlags.call(this)},$resolveArgs(){return Sk.builtin.func.prototype.$resolveArgs.call(this)}},
flags:{sk$unacceptableBase:!0},slots:{tp$getattr:Sk.generic.getAttr,$r(){return null===this.$self?new Sk.builtin.str("<built-in function "+this.$name+">"):new Sk.builtin.str("<built-in method "+this.$name+" of "+Sk.abstr.typeName(this.$self)+" object>")},tp$call(b,e){return this.tp$call(b,e)},tp$richcompare(b,e){if("Eq"!==e&&"NotEq"!==e||!(b instanceof Sk.builtin.sk_method))return Sk.builtin.NotImplemented.NotImplemented$;b=this.$self===b.$self&&this.m$def.$meth===b.m$def.$meth;return"Eq"===e?b:!b}},
getsets:{__module__:{$get(){return this.$module||Sk.builtin.none.none$},$set(b){this.$module=b=b||Sk.builtin.none.none$}},__doc__:{$get(){return this.$doc?new Sk.builtin.str(this.$doc):Sk.builtin.none.none$}},__name__:{$get(){return new Sk.builtin.str(this.$name)}},__text_signature__:{$get(){return new Sk.builtin.str(this.$textsig)}},__self__:{$get(){return this.$self||Sk.sysModules.mp$lookup(this.$module)||Sk.builtin.none.none$}}}})},function(F,P){Sk.builtin.none=Sk.abstr.buildNativeClass("NoneType",
{constructor:function(){return Sk.builtin.none.none$},slots:{tp$new(b,e){Sk.abstr.checkNoArgs("NoneType",b,e);return Sk.builtin.none.none$},$r(){return new Sk.builtin.str("None")},tp$as_number:!0,nb$bool(){return!1}},proto:{valueOf(){return null}},flags:{sk$unacceptableBase:!0}});Sk.builtin.none.none$=Object.create(Sk.builtin.none.prototype,{v:{value:null,enumerable:!0}});Sk.builtin.NotImplemented=Sk.abstr.buildNativeClass("NotImplementedType",{constructor:function(){return Sk.builtin.NotImplemented.NotImplemented$},
slots:{$r(){return new Sk.builtin.str("NotImplemented")},tp$new(b,e){Sk.abstr.checkNoArgs("NotImplementedType",b,e);return Sk.builtin.NotImplemented.NotImplemented$}},flags:{sk$unacceptableBase:!0}});Sk.builtin.NotImplemented.NotImplemented$=Object.create(Sk.builtin.NotImplemented.prototype,{v:{value:null,enumerable:!0}});F=Sk.abstr.buildNativeClass("ellipsis",{constructor:function(){return Sk.builtin.Ellipsis},slots:{tp$new(b,e){Sk.abstr.checkNoArgs("ellipsis",b,e);return Sk.builtin.Ellipsis},$r(){return new Sk.builtin.str("Ellipsis")}},
flags:{sk$unacceptableBase:!0}});Sk.builtin.Ellipsis=Object.create(F.prototype,{v:{value:"..."}})},function(F,P){const b=/^(?:(.)?([<>=\^]))?([\+\-\s])?(#)?(0)?(\d+)?(,|_)?(?:\.(\d+))?([bcdeEfFgGnosxX%])?$/;Sk.formatting={};let e=function(a,c,n,m){Sk.asserts.assert("string"===typeof c);if(a[6]){var k=parseInt(a[6],10);m=a[2]||(a[5]?"=":m?">":"<");let u=k-(c.length+(n?n.length:0));if(0>=u)return n+c;k=(a[1]||(a[5]?"0":" ")).repeat(u);switch(m){case "=":if("s"===a[9])throw new Sk.builtin.ValueError("'=' alignment not allowed in string format specifier");
return n+k+c;case ">":return k+n+c;case "<":return n+c+k;case "^":return a=Math.floor(u/2),k.substring(0,a)+n+c+k.substring(a)}}return n+c},d=function(a,c){return c?"-":"+"===a[3]?"+":" "===a[3]?" ":""};const f=/\B(?=(\d{3})+(?!\d))/g,h=/\B(?=([A-Za-z0-9]{4})+(?![A-Za-z0-9]))/g;let p=function(a,c,n){Sk.asserts.assert(c instanceof Sk.builtin.int_||c instanceof Sk.builtin.lng);if(a[8])throw new Sk.builtin.ValueError("Precision not allowed in integer format");var m=c.str$(n,!1);c=c.nb$isnegative();c=
d(a,c);a[4]&&(16===n?c+="0x":8===n?c+="0o":2===n&&(c+="0b"));const k=a[9];"X"===k&&(m=m.toUpperCase());if("n"===a[9])m=(+m).toLocaleString();else if(a[7]){m=m.split(".");const u=a[7];if(","===u&&10!==n)throw new Sk.builtin.ValueError(`Cannot specify ',' with '${k}'`);m[0]=m[0].replace(10===n?f:h,u);m=m.join(".")}return e(a,m,c,!0)},g=function(a,c,n){if(!c)return a.str$(10,!0);c=c.match(b);if(!c)throw new Sk.builtin.ValueError("Invalid format specifier");var m=c[9];m||(m=n?"g":"d");if(-1==(n?"fFeEgG%":
"bcdoxXnfFeEgG%").indexOf(m))throw new Sk.builtin.ValueError("Unknown format code '"+c[9]+"' for object of type '"+Sk.abstr.typeName(a)+"'");switch(m){case "d":case "n":return p(c,a,10);case "x":case "X":return p(c,a,16);case "o":return p(c,a,8);case "b":return p(c,a,2);case "c":if(c[3])throw new Sk.builtin.ValueError("Sign not allowed with integer format specifier 'c'");if(c[4])throw new Sk.builtin.ValueError("Alternate form not allowed with integer format specifier 'c'");if(c[7])throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");
if(c[8])throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");return e(c,String.fromCodePoint(Sk.builtin.asnum$(a)),"",!0);case "f":case "F":case "e":case "E":case "g":case "G":{if(c[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed in float format specifier");n=Sk.builtin.asnum$(a);"string"===typeof n&&(n=Number(n));if(Infinity===n)return e(c,"inf","",!0);if(-Infinity===n)return e(c,"inf","-",!0);if(isNaN(n))return e(c,"nan","",!0);a=!1;0>n&&(n=-n,a=!0);var k=["toExponential",
"toFixed","toPrecision"]["efg".indexOf(m.toLowerCase())];let u=c[8]?parseInt(c[8],10):6;n=n[k](u);-1!=="EFG".indexOf(m)&&(n=n.toUpperCase());if("g"===m.toLowerCase()||!c[9]){if(k=n.match(/\.(\d*[1-9])?(0+)$/)){let [,l,q]=k;n=n.slice(0,l?-q.length:-(q.length+1))}-1!=n.indexOf(".")||c[9]||(n+=".0")}"e"===m.toLowerCase()&&(n=n.replace(/^([-+]?[0-9]*\.?[0-9]+[eE][-+]?)([0-9])?$/,"$10$2"));c[7]&&(m=n.toString().split("."),m[0]=m[0].replace(/\B(?=(\d{3})+(?!\d))/g,","),n=m.join("."));return e(c,n,d(c,a),
!0)}case "%":if(c[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed with format specifier '%'");a=Sk.builtin.asnum$(a);"string"===typeof a&&(a=Number(a));if(Infinity===a)return e(c,"inf%","",!0);if(-Infinity===a)return e(c,"inf%","-",!0);if(isNaN(a))return e(c,"nan%","",!0);m=!1;0>a&&(a=-a,m=!0);n=c[8]?parseInt(c[8],10):6;a=(100*a).toFixed(n)+"%";return e(c,a,d(c,m),!0);default:throw new Sk.builtin.ValueError("Unknown format code '"+c[9]+"'");}};Sk.formatting.mkNumber__format__=a=>
function(c){if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError("format() argument 2 must be str, not "+Sk.abstr.typeName(c));return new Sk.builtin.str(g(this,c.$jsstr(),a))};Sk.formatting.format=function(a,c){c=c||[];const n={};for(let k=0;k<c.length;k+=2)n[c[k]]=c[k+1];for(let k in a)n[k]=a[k];let m=0;a=this.v.replace(/{(((?:\d+)|(?:\w+))?((?:\.(\w+))|(?:\[((?:\d+)|(?:\w+))\])?))?(?:!([rs]))?(?::([^}]*))?}/g,function(k,u,l,q,z,r,t,x,v,B){let I;if(void 0!==r&&""!==r)k=n[l],I=k.constructor===
Array?k[r]:/^\d+$/.test(r)?Sk.abstr.objectGetItem(k,new Sk.builtin.int_(parseInt(r,10)),!1):Sk.abstr.objectGetItem(k,new Sk.builtin.str(r),!1),m++;else if(void 0!==z&&""!==z)I=Sk.abstr.gattr(n[l||m++],new Sk.builtin.str(z));else if(void 0!==l&&""!==l)I=n[l];else if(void 0===u||""===u)I=n[m],m++;else if(u instanceof Sk.builtin.int_||u instanceof Sk.builtin.float_||u instanceof Sk.builtin.lng||/^\d+$/.test(u))I=n[u],m++;if("s"===t)I=new Sk.builtin.str(I);else if("r"===t)I=Sk.builtin.repr(I);else if(""!==
t&&void 0!==t)throw new Sk.builtin.ValueError("Unknown conversion specifier "+t);return Sk.abstr.objectFormat(I,new Sk.builtin.str(x)).$jsstr()});return new Sk.builtin.str(a)};Sk.formatting.formatString=function(a){if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("format() argument 2 must be str, not "+Sk.abstr.typeName(a));a=a.$jsstr().match(b);if(a[9]&&"s"!==a[9])throw new Sk.builtin.ValueError("Unknown format code '"+a[9]+"' for object of type 'str'");if(a[3])throw new Sk.builtin.ValueError("Sign not allowed in string format specifier");
if(a[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed with string format specifier");if(a[7])throw new Sk.builtin.ValueError("Cannot specify ',' with 's'");let c=this.v;a[8]&&(c=c.substring(0,a[8]));return new Sk.builtin.str(e(a,c,"",!1))}},function(F,P){function b(r){let t;const x=[];for(let v=0;v<r.length;v++)t=r.charAt(v),k.test(t)?x.push(t):"\\000"===t?x.push("\\000"):x.push("\\"+t);return x.join("")}function e(r,t,x){t=Sk.builtin.checkNone(t)?null:r.get$tgt(t);if(null!==t&&
!t.length)throw new Sk.builtin.ValueError("empty separator");r=r.v;var v=0;if(null===t){var B=/[\s\xa0]+/g;v=r.length;r=r.replace(l,"");v-=r.length}else B=t.replace(u,"\\$1"),B=new RegExp(B,"g");const I=[];let M=0,S=0,E;for(x=0>x?Infinity:x;null!=(E=B.exec(r))&&S<x&&E.index!==B.lastIndex;)I.push(M+v),I.push(E.index+v),M=B.lastIndex,S+=1;if(null!==t||r.length-M)I.push(M+v),I.push(r.length+v);return I}function d(r,t){return function(x){if(void 0===x||Sk.builtin.checkNone(x))x=r;else if(x instanceof
Sk.builtin.str)x=b(x.v),x=new RegExp(t(x),"g");else throw new Sk.builtin.TypeError("strip arg must be None or str");return new Sk.builtin.str(this.v.replace(x,""))}}function f(r){return function(t){t=this.get$tgt(t);const x=this.v;let v;if(r){if(v=x.lastIndexOf(t),0>v)return new Sk.builtin.tuple([new Sk.builtin.str(""),new Sk.builtin.str(""),new Sk.builtin.str(x)])}else if(v=x.indexOf(t),0>v)return new Sk.builtin.tuple([new Sk.builtin.str(x),new Sk.builtin.str(""),new Sk.builtin.str("")]);return new Sk.builtin.tuple([new Sk.builtin.str(x.substring(0,
v)),new Sk.builtin.str(t),new Sk.builtin.str(x.substring(v+t.length))])}}function h(r,t){return function(x,v){x=Sk.misceval.asIndexSized(x,Sk.builtin.OverflowError);if(void 0===v)v=" ";else if(v instanceof Sk.builtin.str&&1===v.sq$length())v=v.v;else throw new Sk.builtin.TypeError("the fill character must be a str of length 1");var B=this.sq$length();if(B>=x)return new Sk.builtin.str(this.v);if(t)return B=x-B,x=Math.floor(B/2)+(B&x&1),v=v.repeat(x)+this.v+v.repeat(B-x),new Sk.builtin.str(v);v=v.repeat(x-
B);return new Sk.builtin.str(r?v+this.v:this.v+v)}}function p(r,t,x){({start:t,end:x}=Sk.builtin.slice.startEnd$wrt(r,t,x));if(r.$hasAstralCodePoints()){const v=r.codepoints[t];t=void 0===v?t+r.v.length-r.codepoints.length:v;x=r.codepoints[x];x=void 0===x?r.v.length:x}return{start:t,end:x}}function g(r){return function(t,x,v){t=this.get$tgt(t);({start:x,end:v}=p(this,x,v));if(v<x)return-1;v-=t.length;t=r?this.v.lastIndexOf(t,v):this.v.indexOf(t,x);t=t>=x&&t<=v?t:-1;if(this.codepoints){v=this.sq$length();
x=-1;for(let B=0;B<v;B++)t==this.codepoints[B]&&(x=B)}else x=t;return x}}function a(r,t){return function(x,v,B){if(!(x instanceof Sk.builtin.str||x instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError(r+" first arg must be str or a tuple of str, not "+Sk.abstr.typeName(x));({start:v,end:B}=p(this,v,B));if(v>B)return Sk.builtin.bool.false$;v=this.v.slice(v,B);if(x instanceof Sk.builtin.tuple){for(let I=Sk.abstr.iter(x),M=I.tp$iternext();void 0!==M;M=I.tp$iternext()){if(!(M instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("tuple for "+
r+" must only contain str, not "+Sk.abstr.typeName(M));if(t(v,M.v))return Sk.builtin.bool.true$}return Sk.builtin.bool.false$}return new Sk.builtin.bool(t(v,x.v))}}function c(r){return void 0===z[r]?r:r+"_$rw$"}var n=/^[0-9!#_]/,m=Object.create(null);Sk.builtin.str=Sk.abstr.buildNativeClass("str",{constructor:function(r){Sk.asserts.assert(this instanceof Sk.builtin.str,"bad call to str - use 'new'");if("string"!==typeof r)if(void 0===r)r="";else if(null===r)r="None";else{if(void 0!==r.tp$str)return r.tp$str();
if("number"===typeof r)r=Number.isFinite(r)?String(r):String(r).replace("Infinity","inf").replace("NaN","nan");else throw new Sk.builtin.TypeError("could not convert object of type '"+Sk.abstr.typeName(r)+"' to str");}const t=m[r];if(void 0!==t)return t;m[r]=this;this.$mangled=c(r);this.$savedKeyHash=r.replace(n,"!$&");this.v=r},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
tp$new(r,t){t=t||[];if(this!==Sk.builtin.str.prototype)return this.$subtype_new(r,t);if(1>=r.length&&!t.length)return new Sk.builtin.str(r[0]);if(Sk.__future__.python3){const [x,v,B]=Sk.abstr.copyKeywordsToNamedArgs("str",["object","encoding","errors"],r,t);if(void 0===x||void 0===v&&void 0===B)return new Sk.builtin.str(x);Sk.builtin.bytes.check$encodeArgs("str",v,B);if(!Sk.builtin.checkBytes(x))throw new Sk.builtin.TypeError("decoding to str: need a bytes-like object, "+Sk.abstr.typeName(x)+" found");
return Sk.builtin.bytes.$decode.call(x,v,B)}throw new Sk.builtin.TypeError("str takes at most one argument ("+(r.length+t.length)+" given)");},$r(){let r="'";-1!==this.v.indexOf("'")&&-1===this.v.indexOf('"')&&(r='"');const t=this.v.length;let x=r;for(let I=0;I<t;I++){var v=this.v.charAt(I);var B=this.v.charCodeAt(I);v===r||"\\"===v?x+="\\"+v:"\t"===v?x+="\\t":"\n"===v?x+="\\n":"\r"===v?x+="\\r":(255<B&&55296>B||57344<=B)&&!Sk.__future__.python3?x+="\\u"+("000"+B.toString(16)).slice(-4):55296<=B&&
!Sk.__future__.python3?(v=this.v.codePointAt(I),I++,v=v.toString(16),B="0000000"+v.toString(16),x=4<v.length?x+("\\U"+B.slice(-8)):x+("\\u"+B.slice(-4))):255<B&&!Sk.__future__.python3?x+="\\ufffd":" ">v||127<=B&&!Sk.__future__.python3?(v=v.charCodeAt(0).toString(16),2>v.length&&(v="0"+v),x+="\\x"+v):x+=v}return new Sk.builtin.str(x+r)},tp$str(){return this.constructor===Sk.builtin.str?this:new Sk.builtin.str(this.v)},tp$iter(){return new q(this)},tp$richcompare(r,t){if(!(r instanceof Sk.builtin.str))return Sk.builtin.NotImplemented.NotImplemented$;
switch(t){case "Lt":return this.v<r.v;case "LtE":return this.v<=r.v;case "Eq":return this.v===r.v;case "NotEq":return this.v!==r.v;case "Gt":return this.v>r.v;case "GtE":return this.v>=r.v}},mp$subscript(r){let t;if(Sk.misceval.isIndex(r)){r=Sk.misceval.asIndexSized(r,Sk.builtin.OverflowError);t=this.sq$length();0>r&&(r+=t);if(0>r||r>=t)throw new Sk.builtin.IndexError("string index out of range");return this.codepoints?new Sk.builtin.str(this.v.substring(this.codepoints[r],this.codepoints[r+1])):
new Sk.builtin.str(this.v.charAt(r))}if(r instanceof Sk.builtin.slice){let x="";t=this.sq$length();this.codepoints?r.sssiter$(t,v=>{x+=this.v.substring(this.codepoints[v],this.codepoints[v+1])}):r.sssiter$(t,v=>{x+=this.v.charAt(v)});return new Sk.builtin.str(x)}throw new Sk.builtin.TypeError("string indices must be integers, not "+Sk.abstr.typeName(r));},sq$length(){return this.$hasAstralCodePoints()?this.codepoints.length:this.v.length},sq$concat(r){if(!(r instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("cannot concatenate 'str' and '"+
Sk.abstr.typeName(r)+"' objects");return new Sk.builtin.str(this.v+r.v)},sq$repeat(r){if(!Sk.misceval.isIndex(r))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(r)+"'");r=Sk.misceval.asIndexSized(r,Sk.builtin.OverflowError);if(r*this.v.length>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;let t="";for(let x=0;x<r;x++)t+=this.v;return new Sk.builtin.str(t)},sq$contains(r){if(!(r instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("'in <string>' requires string as left operand not "+
Sk.abstr.typeName(r));return-1!==this.v.indexOf(r.v)},tp$as_number:!0,nb$remainder:function(r){var t;const x=this.sk$builtinBase;r.constructor===Sk.builtin.tuple||r instanceof Sk.builtin.dict||r instanceof Sk.builtin.mappingproxy||(r=new Sk.builtin.tuple([r]));var v=0;var B=this.$jsstr().replace(/%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrsb%])/g,function(I,M,S,E,H,y,A){var J,Q,X,aa,ea;E=Sk.builtin.asnum$(E);H=Sk.builtin.asnum$(H);void 0!==M&&""!==M||"%"==A||
(J=v++);""===H&&(H=void 0);var na=Q=X=aa=ea=!1;S&&(-1!==S.indexOf("-")?aa=!0:-1!==S.indexOf("0")&&(ea=!0),-1!==S.indexOf("+")?Q=!0:-1!==S.indexOf(" ")&&(X=!0),na=-1!==S.indexOf("#"));H&&(H=parseInt(H.substr(1),10));S=function(ca,la){var ia;la=Sk.builtin.asnum$(la);var ka=!1;if("number"===typeof ca){0>ca&&(ca=-ca,ka=!0);var U=ca.toString(la)}else ca instanceof Sk.builtin.float_?(U=ca.str$(la,!1),2<U.length&&".0"===U.substr(-2)&&(U=U.substr(0,U.length-2)),ka=ca.nb$isnegative()):ca instanceof Sk.builtin.int_?
(U=ca.str$(la,!1),ka=ca.nb$isnegative()):ca instanceof Sk.builtin.lng&&(U=ca.str$(la,!1),ka=ca.nb$isnegative());Sk.asserts.assert(void 0!==U,"unhandled number format");ca=!1;if(H)for(ia=U.length;ia<H;++ia)U="0"+U,ca=!0;ia="";ka?ia="-":Q?ia="+"+ia:X&&(ia=" "+ia);na&&(16===la?ia+="0x":8!==la||ca||"0"===U||(ia+="0"));return[ia,U]};I=function(ca){var la=ca[0];ca=ca[1];if(E){E=parseInt(E,10);var ia=ca.length+la.length;if(ea)for(;ia<E;++ia)ca="0"+ca;else if(aa){for(;ia<E;++ia)ca+=" ";Sk.__future__.python3&&
(ca+=la,la="")}else for(;ia<E;++ia)la=" "+la}return la+ca};if(r.constructor===Sk.builtin.tuple)M=r.v[J];else if(void 0!==r.mp$subscript&&void 0!==M)M=M.substring(1,M.length-1),M=r.mp$subscript(new x(M));else if(r.constructor===Sk.builtin.dict||r.constructor===Sk.builtin.list)M=r;else throw new Sk.builtin.AttributeError(r.tp$name+" instance has no attribute 'mp$subscript'");if("d"===A||"i"===A){var oa=S(M,10);if(void 0===oa[1])throw new Sk.builtin.TypeError("%"+A+" format: a number is required, not "+
Sk.abstr.typeName(M));A=oa[1];oa[1]=-1!==A.indexOf(".")?parseInt(A,10).toString():A;return I(oa)}if("o"===A)return I(S(M,8));if("x"===A)return I(S(M,16));if("X"===A)return I(S(M,16)).toUpperCase();if("f"===A||"F"===A||"e"===A||"E"===A||"g"===A||"G"===A){oa=Sk.builtin.asnum$(M);"string"===typeof oa&&(oa=Number(oa));if(Infinity===oa)return"inf";if(-Infinity===oa)return"-inf";if(isNaN(oa))return"nan";J=["toExponential","toFixed","toPrecision"]["efg".indexOf(A.toLowerCase())];if(void 0===H||""===H)if("e"===
A||"E"===A)H=6;else if("f"===A||"F"===A)H=Sk.__future__.python3?6:7;J=oa[J](H);Sk.builtin.checkFloat(M)&&0===oa&&-Infinity===1/oa&&(J="-"+J);Sk.__future__.python3&&(7<=J.length&&"0.0000"==J.slice(0,6)&&(t=parseFloat(J),J=t.toExponential()),"-"==J.charAt(J.length-2)&&(J=J.slice(0,J.length-1)+"0"+J.charAt(J.length-1)));-1!=="EFG".indexOf(A)&&(J=J.toUpperCase());return I(["",J])}if("c"===A){if("number"===typeof M)return String.fromCharCode(M);if(M instanceof Sk.builtin.int_||M instanceof Sk.builtin.float_)return String.fromCharCode(M.v);
if(M instanceof Sk.builtin.lng)return String.fromCharCode(M.str$(10,!1)[0]);if(M.constructor===Sk.builtin.str)return M.v.substr(0,1);throw new Sk.builtin.TypeError("an integer is required");}if("r"===A)return A=Sk.builtin.repr(M),H?A.v.substr(0,H):A.v;if("s"===A&&x===Sk.builtin.str){A=new Sk.builtin.str(M);A=A.$jsstr();if(H)return A.substr(0,H);E&&(A=I([" ",A]));return A}if("b"===A||"s"===A){if(x===Sk.builtin.str)throw new Sk.builtin.ValueError("unsupported format character 'b'");if(!(M instanceof
Sk.builtin.bytes)&&void 0===(oa=Sk.abstr.lookupSpecial(M,Sk.builtin.str.$bytes)))throw new Sk.builtin.TypeError("%b requires a bytes-like object, or an object that implements __bytes__, not '"+Sk.abstr.typeName(M)+"'");void 0!==oa&&(M=new Sk.builtin.bytes(M));A=M.$jsstr();if(H)return A.substr(0,H);E&&(A=I([" ",A]));return A}if("%"===A)return"%"});if(r instanceof Sk.builtin.tuple&&v<r.sq$length())throw new Sk.builtin.TypeError("not all arguments converted during string formatting");return new x(B)}},
proto:{toString(){return this.v},$subtype_new(r,t){const x=new this.constructor;r=Sk.builtin.str.prototype.tp$new(r,t);x.$mangled=r.$mangled;x.$savedKeyHash=r.$savedKeyHash;x.v=r.v;return x},$jsstr(){return this.v},$hasAstralCodePoints(){if(null===this.codepoints)return!1;if(void 0!==this.codepoints)return!0;for(var r=0;r<this.v.length;r++){let t=this.v.charCodeAt(r);if(55296<=t&&57344>t){this.codepoints=[];for(r=0;r<this.v.length;r++)this.codepoints.push(r),t=this.v.charCodeAt(r),55296<=t&&56320>
t&&r++;return!0}}this.codepoints=null;return!1},sk$asarray(){const r=[];if(this.$hasAstralCodePoints()){var t=this.codepoints;for(let x=0;x<t.length;x++)r.push(new Sk.builtin.str(this.v.substring(t[x],t[x+1])))}else for(t=0;t<this.v.length;t++)r.push(new Sk.builtin.str(this.v[t]));return r},find$left:g(!1),find$right:g(!0),get$tgt(r){if(r instanceof Sk.builtin.str)return r.v;throw new Sk.builtin.TypeError("a str instance is required not '"+Sk.abstr.typeName(r)+"'");},valueOf(){return this.v},$isIdentifier(){return Sk.token.isIdentifier(this.v)}},
methods:{encode:{$meth:function(r,t){({encoding:r,errors:t}=Sk.builtin.bytes.check$encodeArgs("encode",r,t));r=Sk.builtin.bytes.str$encode(this,r,t);return Sk.__future__.python3?r:new Sk.builtin.str(r.$jsstr())},$flags:{NamedArgs:["encoding","errors"]},$textsig:"($self, /, encoding='utf-8', errors='strict')",$doc:"Encode the string using the codec registered for encoding.\n\n  encoding\n    The encoding in which to encode the string.\n  errors\n    The error handling scheme to use for encoding errors.\n    The default is 'strict' meaning that encoding errors raise a\n    UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n    'xmlcharrefreplace' as well as any other name registered with\n    codecs.register_error that can handle UnicodeEncodeErrors."},
replace:{$meth(r,t,x){r=this.get$tgt(r);t=this.get$tgt(t);x=void 0===x?-1:Sk.misceval.asIndexSized(x,Sk.builtin.OverflowError);r=new RegExp(b(r),"g");if(0>x)return new Sk.builtin.str(this.v.replace(r,t));let v=0;r=this.v.replace(r,B=>v++<x?t:B);return new Sk.builtin.str(r)},$flags:{MinArgs:2,MaxArgs:3},$textsig:"($self, old, new, count=-1, /)",$doc:"Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."},
split:{$meth:function(r,t){t=Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError);r=e(this,r,t);t=[];for(let x=0;x<r.length;x++)t.push(new Sk.builtin.str(this.v.substring(r[x],r[++x])));return new Sk.builtin.list(t)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."},
rsplit:{$meth:function(r,t){t=Sk.misceval.asIndexSized(t,Sk.builtin.OverflowError);r=e(this,r,-1);var x=0>t?0:2*(r.length/2-t);t=[];for(0>=x?x=0:t.push(new Sk.builtin.str(this.v.slice(0,r[x-1])));x<r.length;x++)t.push(new Sk.builtin.str(this.v.substring(r[x],r[++x])));return new Sk.builtin.list(t)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplits are done starting at the end of the string and working to the front."},
join:{$meth(r){const t=[];return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(r),x=>{if(!(x instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("sequence item "+t.length+": expected str, "+Sk.abstr.typeName(x)+" found");t.push(x.v)}),()=>new Sk.builtin.str(t.join(this.v)))},$flags:{OneArg:!0},$textsig:"($self, iterable, /)",$doc:"Concatenate any number of strings.\n\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\n\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'"},
capitalize:{$meth:function(){return new Sk.builtin.str(this.v.charAt(0).toUpperCase()+this.v.slice(1).toLowerCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a capitalized version of the string.\n\nMore specifically, make the first character have upper case and the rest lower\ncase."},title:{$meth:function(){const r=this.v.replace(/[a-z][a-z]*/gi,t=>t[0].toUpperCase()+t.substr(1).toLowerCase());return new Sk.builtin.str(r)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a version of the string where each word is titlecased.\n\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case."},
center:{$meth:h(!1,!0),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a centered string of length width.\n\nPadding is done using the specified fill character (default is a space)."},count:{$meth:function(r,t,x){r=this.get$tgt(r);({start:t,end:x}=p(this,t,x));if(x<t)return new Sk.builtin.int_(0);r=r.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");r=new RegExp(r,"g");return(t=this.v.slice(t,x).match(r))?new Sk.builtin.int_(t.length):new Sk.builtin.int_(0)},$flags:{MinArgs:1,
MaxArgs:3},$textsig:null,$doc:"S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation."},expandtabs:{$meth:function(r){if(Sk.builtin.checkInt(r))r=Sk.builtin.asnum$(r);else throw new Sk.builtin.TypeError("an integer is required, got type"+Sk.abstr.typeName(r));const t=Array(r+1).join(" "),x=this.v.replace(/([^\r\n\t]*)\t/g,(v,B)=>B+t.slice(B.length%r));
return new Sk.builtin.str(x)},$flags:{NamedArgs:["tabsize"],Defaults:[8]},$textsig:"($self, /, tabsize=8)",$doc:"Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed."},find:{$meth:function(r,t,x){return new Sk.builtin.int_(this.find$left(r,t,x))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},
partition:{$meth:f(!1),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings."},index:{$meth:function(r,t,x){r=this.find$left(r,t,x);if(-1===r)throw new Sk.builtin.ValueError("substring not found");
return new Sk.builtin.int_(r)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found, \nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."},ljust:{$meth:h(!1,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a left-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."},
lower:{$meth(){return new Sk.builtin.str(this.v.toLowerCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a copy of the string converted to lowercase."},lstrip:{$meth:d(/^\s+/g,r=>"^["+r+"]+"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with leading whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."},rfind:{$meth(r,t,x){return new Sk.builtin.int_(this.find$right(r,t,x))},$flags:{MinArgs:1,MaxArgs:3},
$textsig:null,$doc:"S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},rindex:{$meth:function(r,t,x){r=this.find$right(r,t,x);if(-1===r)throw new Sk.builtin.ValueError("substring not found");return new Sk.builtin.int_(r)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."},
rjust:{$meth:h(!0,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a right-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."},rstrip:{$meth:d(/\s+$/g,r=>"["+r+"]+$"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."},rpartition:{$meth:f(!0),$flags:{OneArg:!0},
$textsig:"($self, sep, /)",$doc:"Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string."},splitlines:{$meth:function(r){r=Sk.misceval.isTrue(r);const t=this.v,x=[],v=t.length;var B=
0;for(let M=0;M<v;M++){var I=t.charAt(M);if("\n"===t.charAt(M+1)&&"\r"===I)I=M+2,B=t.slice(B,I),r||(B=B.replace(/(\r|\n)/g,"")),x.push(new Sk.builtin.str(B)),B=I;else if("\n"===I&&"\r"!==t.charAt(M-1)||"\r"===I)I=M+1,B=t.slice(B,I),r||(B=B.replace(/(\r|\n)/g,"")),x.push(new Sk.builtin.str(B)),B=I}B<v&&(B=t.slice(B,v),r||(B=B.replace(/(\r|\n)/g,"")),x.push(new Sk.builtin.str(B)));return new Sk.builtin.list(x)},$flags:{NamedArgs:["keepends"],Defaults:[!1]},$textsig:"($self, /, keepends=False)",$doc:"Return a list of the lines in the string, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."},
strip:{$meth:d(/^\s+|\s+$/g,r=>"^["+r+"]+|["+r+"]+$"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with leading and trailing whitespace remove.\n\nIf chars is given and not None, remove characters in chars instead."},swapcase:{$meth(){const r=this.v.replace(/[a-z]/gi,t=>{const x=t.toLowerCase();return x===t?t.toUpperCase():x});return new Sk.builtin.str(r)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Convert uppercase characters to lowercase and lowercase characters to uppercase."},
upper:{$meth(){return new Sk.builtin.str(this.v.toUpperCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a copy of the string converted to uppercase."},startswith:{$meth:a("startswith",(r,t)=>0===r.indexOf(t)),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try."},
endswith:{$meth:a("endswith",(r,t)=>-1!==r.indexOf(t,r.length-t.length)),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try."},isascii:{$meth(){return new Sk.builtin.bool(/^[\x00-\x7F]*$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too."},islower:{$meth:function(){return new Sk.builtin.bool(this.v.length&&/[a-z]/.test(this.v)&&!/[A-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string."},
isupper:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[a-z]/.test(this.v)&&/[A-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string."},istitle:{$meth:function(){const r=this.v;let t=!1,x=!1,v;for(let B=0;B<r.length;B++)if(v=r.charAt(B),!/[a-z]/.test(v)&&/[A-Z]/.test(v)){if(x)return Sk.builtin.bool.false$;
t=x=!0}else if(/[a-z]/.test(v)&&!/[A-Z]/.test(v)){if(!x)return Sk.builtin.bool.false$;t=!0}else x=!1;return new Sk.builtin.bool(t)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a title-cased string, False otherwise.\n\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones."},isspace:{$meth:function(){return new Sk.builtin.bool(/^\s+$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return True if the string is a whitespace string, False otherwise.\n\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string."},isdigit:{$meth:function(){return new Sk.builtin.bool(/^\d+$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string."},
isnumeric:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^0-9]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a numeric string, False otherwise.\n\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string."},isalpha:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^a-zA-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an alphabetic string, False otherwise.\n\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string."},
isalnum:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^a-zA-Z0-9]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an alpha-numeric string, False otherwise.\n\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string."},isidentifier:{$meth:function(){return this.$isIdentifier()?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:'Return True if the string is a valid Python identifier, False otherwise.\n\nUse keyword.iskeyword() to test for reserved identifiers such as "def" and\n"class".'},
zfill:{$meth:function(r){r=Sk.misceval.asIndexSized(r,Sk.builtin.OverflowError);let t="";r-=this.v.length;const x="+"===this.v[0]||"-"===this.v[0]?1:0;for(let v=0;v<r;v++)t+="0";return new Sk.builtin.str(this.v.substr(0,x)+t+this.v.substr(x))},$flags:{OneArg:!0},$textsig:"($self, width, /)",$doc:"Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe string is never truncated."},format:{$meth:Sk.formatting.format,$flags:{FastCall:!0},$textsig:null,$doc:"S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}')."},
__format__:{$meth:Sk.formatting.formatString,$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:"Return a formatted version of the string as described by format_spec."},__getnewargs__:{$meth(){return new Sk.builtin.tuple(new Sk.builtin.str(this.v))},$flags:{NoArgs:!0},$textsig:null,$doc:null}}});Sk.exportSymbol("Sk.builtin.str",Sk.builtin.str);var k=/^[A-Za-z0-9]+$/,u=/([.*+?=|\\\/()\[\]\{\}^$])/g,l=/^[\s\xa0]+/;Sk.builtin.str.$py2decode=new Sk.builtin.method_descriptor(Sk.builtin.str,{$name:"decode",
$meth(r,t){const x=new Sk.builtin.bytes(this.v);return Sk.builtin.bytes.$decode.call(x,r,t)},$flags:{NamedArgs:["encoding","errors"]}});var q=Sk.abstr.buildIteratorClass("str_iterator",{constructor:function(r){this.$index=0;r.$hasAstralCodePoints()?(this.$seq=r.codepoints,this.tp$iternext=()=>{const t=this.$seq[this.$index];if(void 0!==t)return new Sk.builtin.str(r.v.substring(t,this.$seq[++this.$index]))}):(this.$seq=r.v,this.tp$iternext=()=>{const t=this.$seq[this.$index++];if(void 0!==t)return new Sk.builtin.str(t)})},
iternext(){return this.tp$iternext()},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}}),z={abstract:!0,as:!0,boolean:!0,break:!0,byte:!0,case:!0,catch:!0,char:!0,class:!0,continue:!0,const:!0,debugger:!0,default:!0,delete:!0,do:!0,double:!0,else:!0,enum:!0,export:!0,extends:!0,false:!0,final:!0,finally:!0,float:!0,for:!0,function:!0,goto:!0,if:!0,implements:!0,import:!0,in:!0,instanceof:!0,int:!0,interface:!0,is:!0,long:!0,namespace:!0,native:!0,
new:!0,null:!0,package:!0,private:!0,protected:!0,public:!0,return:!0,short:!0,static:!0,super:!0,switch:!0,synchronized:!0,this:!0,throw:!0,throws:!0,transient:!0,true:!0,try:!0,typeof:!0,use:!0,var:!0,void:!0,volatile:!0,while:!0,with:!0,constructor:!0,__defineGetter__:!0,__defineSetter__:!0,apply:!0,arguments:!0,call:!0,caller:!0,eval:!0,hasOwnProperty:!0,isPrototypeOf:!0,__lookupGetter__:!0,__lookupSetter__:!0,__noSuchMethod__:!0,propertyIsEnumerable:!0,prototype:!0,toSource:!0,toLocaleString:!0,
toString:!0,unwatch:!0,valueOf:!0,watch:!0,length:!0,name:!0};Sk.builtin.str.reservedWords_=z;Sk.builtin.str.$fixReserved=c},function(F,P){Sk.builtin.func=Sk.abstr.buildNativeClass("function",{constructor:function(b,e,d,f){Sk.asserts.assert(this instanceof Sk.builtin.func,"builtin func should be called as a class with `new`");this.func_code=b;this.func_globals=e||null;this.$name=b.co_name&&b.co_name.v||b.name||"<native JS>";this.$d=Sk.builtin.dict?new Sk.builtin.dict:void 0;this.$doc=b.co_docstring||
Sk.builtin.none.none$;this.$module=Sk.globals&&Sk.globals.__name__||Sk.builtin.none.none$;this.$qualname=b.co_qualname&&b.co_qualname.v||this.$name;if(void 0!==f)for(let h in f)d[h]=f[h];this.func_closure=d;this.func_annotations=null;this.$memoiseFlags();this.memoised=b.co_fastcall||null;this.tp$call=b.co_fastcall?b.bind(this):Sk.builtin.func.prototype.tp$call.bind(this)},slots:{tp$getattr:Sk.generic.getAttr,tp$descr_get(b,e){return null===b?this:new Sk.builtin.method(this,b)},$r(){return new Sk.builtin.str("<function "+
this.$qualname+">")},tp$call(b,e){this.memoised||(this.$memoiseFlags(),this.memoised=!0);if(void 0===this.co_argcount&&void 0===this.co_varnames&&!this.co_kwargs&&!this.func_closure){if(e&&0!==e.length)throw new Sk.builtin.TypeError(this.$name+"() takes no keyword arguments");return this.func_code.apply(this.func_globals,b)}b=this.$resolveArgs(b,e);this.func_closure&&b.push(this.func_closure);return this.func_code.apply(this.func_globals,b)}},getsets:{__name__:{$get(){return new Sk.builtin.str(this.$name)},
$set(b){if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("__name__ must be set to a string object");this.$name=b.$jsstr()}},__qualname__:{$get(){return new Sk.builtin.str(this.$qualname)},$set(b){if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("__qualname__ must be set to a string object");this.$qualname=b.$jsstr()}},__dict__:Sk.generic.getSetDict,__annotations__:{$get(){null===this.func_annotations?this.func_annotations=new Sk.builtin.dict([]):Array.isArray(this.func_annotations)&&
(this.func_annotations=Sk.abstr.keywordArrayToPyDict(this.func_annotations));return this.func_annotations},$set(b){if(void 0===b||Sk.builtin.checkNone(b))this.func_annotations=new Sk.builtin.dict([]);else if(b instanceof Sk.builtin.dict)this.func_annotations=b;else throw new Sk.builtin.TypeError("__annotations__ must be set to a dict object");}},__defaults__:{$get(){return null==this.$defaults?Sk.builtin.none.none$:new Sk.builtin.tuple(this.$defaults)},$set(b){if(void 0===b||Sk.builtin.checkNone(b))this.$defaults=
null;else if(b instanceof Sk.builtin.tuple)this.$defaults=b.valueOf();else throw new Sk.builtin.TypeError("__defaults__ must be set to a tuple object");}},__doc__:{$get(){return this.$doc},$set(b){this.$doc=b||Sk.builtin.none.none$}},__module__:{$get(){return this.$module},$set(b){this.$module=b||Sk.builtin.none.none$}}},proto:{$memoiseFlags(){this.co_varnames=this.func_code.co_varnames;this.co_argcount=this.func_code.co_argcount;void 0===this.co_argcount&&this.co_varnames&&(this.co_argcount=this.co_varnames.length);
this.co_kwonlyargcount=this.func_code.co_kwonlyargcount||0;this.co_varargs=this.func_code.co_varargs;this.co_kwargs=this.func_code.co_kwargs;this.$defaults=this.func_code.$defaults;this.$kwdefs=this.func_code.$kwdefs||[]},$resolveArgs:function(b,e){var d=this.co_argcount;void 0===d&&(d=this.co_varnames?this.co_varnames.length:b.length);var f=this.co_varnames||[],h=this.co_kwonlyargcount||0;let p=d+h;if(!(0!==h||this.co_kwargs||e&&0!==e.length||this.co_varargs)){if(b.length==d)return b;if(0===b.length&&
this.$defaults&&this.$defaults.length===d){for(f=0;f!=this.$defaults.length;f++)b[f]=this.$defaults[f];return b}}let g;this.co_kwargs&&(g=[]);var a=b.length;let c=b.length<=d?b:b.slice(0,d);if(this.co_varargs)b=b.length>c.length?b.slice(c.length):[],c[p]=new Sk.builtin.tuple(b);else if(a>d)throw new Sk.builtin.TypeError(`${this.$name}"() takes ${d} positional ${1==d?"argument":"arguments"} but ${a} ${1==a?"was":"were"} given`);if(e){if(this.func_code.no_kw)throw new Sk.builtin.TypeError(this.$name+
"() takes no keyword arguments");for(b=0;b<e.length;b+=2){a=e[b];var n=e[b+1],m=f.indexOf(a);if(0<=m){if(void 0!==c[m])throw new Sk.builtin.TypeError(this.$name+"() got multiple values for argument '"+a+"'");c[m]=n}else if(g)g.push(new Sk.builtin.str(a),n);else throw new Sk.builtin.TypeError(this.$name+"() got an unexpected keyword argument '"+a+"'");}}e=this.$defaults||[];b=0;a=[];n=!1;for(m=d-e.length;b<m;b++)void 0===c[b]&&(a.push(f[b]),void 0===f[b]&&(n=!0));if(0!=a.length&&(this.co_argcount||
this.co_varnames))throw new Sk.builtin.TypeError(this.$name+"() missing "+a.length+" required argument"+(1==a.length?"":"s")+(n?"":": "+a.map(k=>"'"+k+"'").join(", ")));for(;b<d;b++)void 0===c[b]&&(c[b]=e[b-m]);if(0<h){h=[];e=this.$kwdefs;for(b=d;b<p;b++)void 0===c[b]&&(void 0!==e[b-d]?c[b]=e[b-d]:h.push(f[b]));if(0!==h.length)throw new Sk.builtin.TypeError(this.$name+"() missing "+h.length+" required keyword argument"+(1==h.length?"":"s")+": "+h.join(", "));}if(this.func_closure&&f)for(d=c.length;d<
f.length;d++)c.push(void 0);g&&c.unshift(g);return c}}})},function(F,P){Sk.builtin.asnum$=function(f){return void 0===f||null===f||"number"===typeof f?f:f instanceof Sk.builtin.int_?"number"===typeof f.v?f.v:f.v.toString():f instanceof Sk.builtin.float_?f.v:f===Sk.builtin.none.none$?null:f};Sk.exportSymbol("Sk.builtin.asnum$",Sk.builtin.asnum$);Sk.builtin.assk$=function(f){return 0===f%1?new Sk.builtin.int_(f):new Sk.builtin.float_(f)};Sk.exportSymbol("Sk.builtin.assk$",Sk.builtin.assk$);Sk.builtin.asnum$nofloat=
function(f){if(void 0===f||null===f)return f;if("number"===typeof f)f=f.toString();else if(f instanceof Sk.builtin.int_)f=f.v.toString();else if(f instanceof Sk.builtin.float_)f=f.v.toString();else{if(f===Sk.builtin.none.none$)return null;return}if(0>f.indexOf(".")&&0>f.indexOf("e")&&0>f.indexOf("E"))return f;var h=0;if(0<=f.indexOf("e")){var p=f.substr(0,f.indexOf("e"));h=f.substr(f.indexOf("e")+1)}else 0<=f.indexOf("E")?(p=f.substr(0,f.indexOf("e")),h=f.substr(f.indexOf("E")+1)):p=f;h=parseInt(h,
10);f=p.indexOf(".");if(0>f){if(0<=h){for(;0<h--;)p+="0";return p}return p.length>-h?p.substr(0,p.length+h):0}p=0===f?p.substr(1):f<p.length?p.substr(0,f)+p.substr(f+1):p.substr(0,f);for(f+=h;f>p.length;)p+="0";return p=0>=f?0:p.substr(0,f)};Sk.exportSymbol("Sk.builtin.asnum$nofloat",Sk.builtin.asnum$nofloat);Sk.builtin.round=function(f,h){if(void 0===f)throw new Sk.builtin.TypeError("a float is required");if(!Sk.__future__.dunder_round){if(!Sk.builtin.checkNumber(f))throw new Sk.builtin.TypeError("a float is required");
if(f.round$)return f.round$(h);throw new Sk.builtin.AttributeError(Sk.abstr.typeName(f)+" instance has no attribute '__float__'");}if(void 0!==h&&!Sk.builtin.checkNone(h)&&!Sk.misceval.isIndex(h))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(h)+"' object cannot be interpreted as an index");f=Sk.abstr.lookupSpecial(f,Sk.builtin.str.$round);if(void 0!==f)return void 0!==h?Sk.misceval.callsimArray(f,[h]):Sk.misceval.callsimArray(f,[]);throw new Sk.builtin.TypeError("a float is required");};Sk.builtin.len=
function(f){if(f.sq$length)f=f.sq$length(!0);else throw new Sk.builtin.TypeError("object of type '"+Sk.abstr.typeName(f)+"' has no len()");return Sk.misceval.chain(f,h=>new Sk.builtin.int_(h))};Sk.builtin.min=function(f,h){let p;const g=f.length;if(!g)throw new Sk.builtin.TypeError("min expected 1 argument, got 0");const [a,c]=Sk.abstr.copyKeywordsToNamedArgs("min",["default","key"],[],h,[null,Sk.builtin.none.none$]);if(1<g&&null!==a)throw new Sk.builtin.TypeError("Cannot specify a default for min() with multiple positional arguments");
p=1==g?Sk.abstr.iter(f[0]):Sk.abstr.iter(new Sk.builtin.tuple(f));if(!Sk.builtin.checkNone(c)&&!Sk.builtin.checkCallable(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not callable");let n;return Sk.misceval.chain(p.tp$iternext(!0),m=>{n=m;if(void 0!==n)return Sk.builtin.checkNone(c)?Sk.misceval.iterFor(p,k=>{Sk.misceval.richCompareBool(k,n,"Lt")&&(n=k)}):Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,[n]),k=>Sk.misceval.iterFor(p,u=>Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,
[u]),l=>{Sk.misceval.richCompareBool(l,k,"Lt")&&(n=u,k=l)})))},()=>{if(void 0===n){if(null===a)throw new Sk.builtin.ValueError("min() arg is an empty sequence");n=a}return n})};Sk.builtin.max=function(f,h){let p;const g=f.length;if(!g)throw new Sk.builtin.TypeError("max expected 1 argument, got 0");const [a,c]=Sk.abstr.copyKeywordsToNamedArgs("max",["default","key"],[],h,[null,Sk.builtin.none.none$]);if(1<g&&null!==a)throw new Sk.builtin.TypeError("Cannot specify a default for max() with multiple positional arguments");
p=1===g?Sk.abstr.iter(f[0]):Sk.abstr.iter(new Sk.builtin.tuple(f));if(!Sk.builtin.checkNone(c)&&!Sk.builtin.checkCallable(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not callable");let n;return Sk.misceval.chain(p.tp$iternext(!0),m=>{n=m;if(void 0!==n)return Sk.builtin.checkNone(c)?Sk.misceval.iterFor(p,k=>{Sk.misceval.richCompareBool(k,n,"Gt")&&(n=k)}):Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,[n]),k=>Sk.misceval.iterFor(p,u=>Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(c,
[u]),l=>{Sk.misceval.richCompareBool(l,k,"Gt")&&(n=u,k=l)})))},()=>{if(void 0===n){if(null===a)throw new Sk.builtin.ValueError("max() arg is an empty sequence");n=a}return n})};Sk.builtin.min.co_fastcall=Sk.builtin.max.co_fastcall=1;Sk.builtin.any=function(f){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(f),function(h){if(Sk.misceval.isTrue(h))return new Sk.misceval.Break(Sk.builtin.bool.true$)}),h=>h||Sk.builtin.bool.false$)};Sk.builtin.all=function(f){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(f),
function(h){if(!Sk.misceval.isTrue(h))return new Sk.misceval.Break(Sk.builtin.bool.false$)}),h=>h||Sk.builtin.bool.true$)};Sk.builtin.sum=function(f,h){function p(){return Sk.misceval.iterFor(c,m=>{if(m.constructor===Sk.builtin.int_)n=n.nb$add(m);else{if(m.constructor===Sk.builtin.float_)return n=n.nb$float().nb$add(m),new Sk.misceval.Break("float");n=Sk.abstr.numberBinOp(n,m,"Add");return new Sk.misceval.Break("slow")}})}function g(){return Sk.misceval.iterFor(c,m=>{if(m.constructor===Sk.builtin.float_||
m.constructor===Sk.builtin.int_)n=n.nb$add(m);else return n=Sk.abstr.numberBinOp(n,m,"Add"),new Sk.misceval.Break("slow")})}function a(){return Sk.misceval.iterFor(c,m=>{n=Sk.abstr.numberBinOp(n,m,"Add")})}const c=Sk.abstr.iter(f);if(void 0===h)var n=new Sk.builtin.int_(0);else{if(Sk.builtin.checkString(h))throw new Sk.builtin.TypeError("sum() can't sum strings [use ''.join(seq) instead]");n=h}f=void 0===h||h.constructor===Sk.builtin.int_?p():h.constructor===Sk.builtin.float_?"float":"slow";return Sk.misceval.chain(f,
m=>"float"===m?g():m,m=>{if("slow"===m)return a()},()=>n)};Sk.builtin.zip=function(){var f,h;if(0===arguments.length)return new Sk.builtin.list([]);var p=[];for(h=0;h<arguments.length;h++)if(Sk.builtin.checkIterable(arguments[h]))p.push(Sk.abstr.iter(arguments[h]));else throw new Sk.builtin.TypeError("argument "+h+" must support iteration");var g=[];for(f=!1;!f;){var a=[];for(h=0;h<arguments.length;h++){var c=p[h].tp$iternext();if(void 0===c){f=!0;break}a.push(c)}f||g.push(new Sk.builtin.tuple(a))}return new Sk.builtin.list(g)};
Sk.builtin.abs=function(f){if(f.nb$abs)return f.nb$abs();throw new Sk.builtin.TypeError("bad operand type for abs(): '"+Sk.abstr.typeName(f)+"'");};Sk.builtin.fabs=function(f){return Sk.builtin.abs(f)};Sk.builtin.ord=function(f){if(Sk.builtin.checkString(f)){if(1!==f.v.length&&1!==f.sq$length())throw new Sk.builtin.TypeError("ord() expected a character, but string of length "+f.v.length+" found");return new Sk.builtin.int_(f.v.codePointAt(0))}if(Sk.builtin.checkBytes(f)){if(1!==f.sq$length())throw new Sk.builtin.TypeError("ord() expected a character, but string of length "+
f.v.length+" found");return new Sk.builtin.int_(f.v[0])}throw new Sk.builtin.TypeError("ord() expected a string of length 1, but "+Sk.abstr.typeName(f)+" found");};Sk.builtin.chr=function(f){if(!Sk.builtin.checkInt(f))throw new Sk.builtin.TypeError("an integer is required");f=Sk.builtin.asnum$(f);if(Sk.__future__.python3){if(0>f||1114112<=f)throw new Sk.builtin.ValueError("chr() arg not in range(0x110000)");}else if(0>f||256<=f)throw new Sk.builtin.ValueError("chr() arg not in range(256)");return new Sk.builtin.str(String.fromCodePoint(f))};
Sk.builtin.unichr=function(f){Sk.builtin.pyCheckArgsLen("unichr",arguments.length,1,1);if(!Sk.builtin.checkInt(f))throw new Sk.builtin.TypeError("an integer is required");f=Sk.builtin.asnum$(f);try{return new Sk.builtin.str(String.fromCodePoint(f))}catch(h){if(h instanceof RangeError)throw new Sk.builtin.ValueError(h.message);throw h;}};Sk.builtin.int2str_=function(f,h,p){let g=Sk.misceval.asIndexOrThrow(f),a=g.toString(h);a=0>g?"-"+p+a.slice(1):p+a;2!==h&&!Sk.__future__.python3&&(f instanceof Sk.builtin.lng||
JSBI.__isBigInt(g))&&(a+="L");return new Sk.builtin.str(a)};Sk.builtin.hex=function(f){if(!Sk.misceval.isIndex(f))throw new Sk.builtin.TypeError("hex() argument can't be converted to hex");return Sk.builtin.int2str_(f,16,"0x")};Sk.builtin.oct=function(f){if(!Sk.misceval.isIndex(f))throw new Sk.builtin.TypeError("oct() argument can't be converted to hex");return Sk.__future__.octal_number_literal?Sk.builtin.int2str_(f,8,"0o"):Sk.builtin.int2str_(f,8,"0")};Sk.builtin.bin=function(f){if(!Sk.misceval.isIndex(f))throw new Sk.builtin.TypeError("'"+
Sk.abstr.typeName(f)+"' object can't be interpreted as an index");return Sk.builtin.int2str_(f,2,"0b")};Sk.builtin.dir=function(f){if(void 0!==f)return f=Sk.abstr.lookupSpecial(f,Sk.builtin.str.$dir),Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(f,[]),h=>Sk.builtin.sorted(h));throw new Sk.builtin.NotImplementedError("skulpt does not yet support dir with no args");};Sk.builtin.repr=function(f){return f.$r()};Sk.builtin.ascii=function(f){return Sk.misceval.chain(f.$r(),h=>{let p,g;for(g=0;g<h.v.length;g++)if(127<=
h.v.charCodeAt(g)){p=h.v.substr(0,g);break}if(!p)return h;for(;g<h.v.length;g++){var a=h.v.charAt(g),c=h.v.charCodeAt(g);127<c&&255>=c?(a=c.toString(16),2>a.length&&(a="0"+a),p+="\\x"+a):127<c&&55296>c||57344<=c?p+="\\u"+("000"+c.toString(16)).slice(-4):55296<=c?(a=h.v.codePointAt(g),g++,a=a.toString(16),c="0000000"+a.toString(16),p=4<a.length?p+("\\U"+c.slice(-8)):p+("\\u"+c.slice(-4))):p+=a}return new Sk.builtin.str(p)})};Sk.builtin.open=function(f,h,p){void 0===h&&(h=new Sk.builtin.str("r"));if(/\+/.test(h.v))throw"todo; haven't implemented read/write mode";
if(("w"===h.v||"wb"===h.v||"a"===h.v||"ab"===h.v)&&!Sk.nonreadopen)throw"todo; haven't implemented non-read opens";return new Sk.builtin.file(f,h,p)};Sk.builtin.isinstance=function(f,h){if(!(Sk.builtin.checkClass(h)||h instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError("isinstance() arg 2 must be a class, type, or tuple of classes and types");var p=f.ob$type;if(p===h)return Sk.builtin.bool.true$;if(!(h instanceof Sk.builtin.tuple)){if(p.$isSubType(h))return Sk.builtin.bool.true$;f=f.tp$getattr(Sk.builtin.str.$class);
return f!=p&&Sk.builtin.checkClass(f)&&f.$isSubType(h)?Sk.builtin.bool.true$:Sk.builtin.bool.false$}for(p=0;p<h.v.length;++p)if(Sk.misceval.isTrue(Sk.builtin.isinstance(f,h.v[p])))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$};Sk.builtin.hash=function(f){return new Sk.builtin.int_(Sk.abstr.objectHash(f))};Sk.builtin.getattr=function(f,h,p){if(!Sk.builtin.checkString(h))throw new Sk.builtin.TypeError("attribute name must be string");const g=Sk.misceval.tryCatch(()=>f.tp$getattr(h,!0),
a=>{if(!(a instanceof Sk.builtin.AttributeError))throw a;});return Sk.misceval.chain(g,a=>{if(void 0===a){if(void 0!==p)return p;throw new Sk.builtin.AttributeError(f.sk$attrError()+" has no attribute "+Sk.misceval.objectRepr(h));}return a})};Sk.builtin.setattr=function(f,h,p){if(!Sk.builtin.checkString(h))throw new Sk.builtin.TypeError("attribute name must be string");return Sk.misceval.chain(f.tp$setattr(h,p,!0),()=>Sk.builtin.none.none$)};Sk.builtin.raw_input=function(f){var h=f?f:"";return Sk.misceval.chain(Sk.importModule("sys",
!1,!0),function(p){return Sk.inputfunTakesPrompt?Sk.builtin.file.$readline(p.$d.stdin,null,h):Sk.misceval.chain(void 0,function(){return Sk.misceval.callsimOrSuspendArray(p.$d.stdout.write,[p.$d.stdout,new Sk.builtin.str(h)])},function(){return Sk.misceval.callsimOrSuspendArray(p.$d.stdin.readline,[p.$d.stdin])})})};Sk.builtin.input=Sk.builtin.raw_input;Sk.builtin.jseval=function(f){f=Sk.global.eval(Sk.ffi.remapToJs(f));return Sk.ffi.remapToPy(f)};Sk.builtin.jsmillis=function(){console.warn("jsmillis is deprecated");
return(new Date).valueOf()};const b=Sk.abstr.buildNativeClass("code",{constructor:function(f,h){this.compiled=h;this.code=h.code;this.filename=f},slots:{tp$new(f,h){throw new Sk.builtin.NotImplementedError("cannot construct a code object in skulpt");},$r(){return new Sk.builtin.str("<code object <module>, file "+this.filename+">")}}});Sk.builtin.compile=function(f,h,p,g,a,c){Sk.builtin.pyCheckType("source","str",Sk.builtin.checkString(f));Sk.builtin.pyCheckType("filename","str",Sk.builtin.checkString(h));
Sk.builtin.pyCheckType("mode","str",Sk.builtin.checkString(p));f=f.$jsstr();h=h.$jsstr();p=p.$jsstr();return Sk.misceval.chain(Sk.compile(f,h,p,!0),n=>new b(h,n))};Sk.builtin.exec=function(f,h,p){let g=h&&h.__file__;g=void 0!==g&&Sk.builtin.checkString(g)?g.toString():"<string>";if(Sk.builtin.checkString(f))f=Sk.compile(f.$jsstr(),g,"exec",!0);else if("string"===typeof f)f=Sk.compile(f,g,"exec",!0);else if(!(f instanceof b))throw new Sk.builtin.TypeError("exec() arg 1 must be a string, bytes or code object");
Sk.asserts.assert(void 0===h||h.constructor===Object,"internal calls to exec should be called with a javascript object for globals");Sk.asserts.assert(void 0===p||p.constructor===Object,"internal calls to exec should be called with a javascript object for locals");const a=Sk.globals;h=h||a;return Sk.misceval.chain(f,c=>Sk.global.eval(c.code)(h,p),c=>{Sk.globals=a;return c})};Sk.builtin.eval=function(f,h,p){if(Sk.builtin.checkString(f))f=f.$jsstr();else if(Sk.builtin.checkBytes(f))throw new Sk.builtin.NotImplementedError("bytes for eval is not yet implemented in skulpt");
if("string"===typeof f){f=f.trim();var g=Sk.parse("?",f);g=Sk.astFromParse(g.cst,"?",g.flags);if(1<g.body.length||!(g.body[0]instanceof Sk.astnodes.Expr))throw new Sk.builtin.SyntaxError("invalid syntax");f="__final_res__ = "+f}else if(!(f instanceof b))throw new Sk.builtin.TypeError("eval() arg 1 must be a string, bytes or code object");return Sk.misceval.chain(Sk.builtin.exec(f,h,p),a=>{const c=a.__final_res__||Sk.builtin.none.none$;delete a.__final_res__;return c})};Sk.builtin.map=function(f,h){var p=
[],g,a;Sk.builtin.pyCheckArgsLen("map",arguments.length,2);if(2<arguments.length){var c=[];var n=Array.prototype.slice.apply(arguments).slice(1);for(a=0;a<n.length;a++){if(!Sk.builtin.checkIterable(n[a])){var m=parseInt(a,10)+2;throw new Sk.builtin.TypeError("argument "+m+" to map() must support iteration");}n[a]=Sk.abstr.iter(n[a])}for(;;){var k=[];for(a=g=0;a<n.length;a++)m=n[a].tp$iternext(),void 0===m?(k.push(Sk.builtin.none.none$),g++):k.push(m);if(g!==n.length)c.push(k);else break}h=new Sk.builtin.list(c)}if(!Sk.builtin.checkIterable(h))throw new Sk.builtin.TypeError("'"+
Sk.abstr.typeName(h)+"' object is not iterable");return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(h),function(u){if(f===Sk.builtin.none.none$)u instanceof Array&&(u=new Sk.builtin.tuple(u)),p.push(u);else return u instanceof Array||(u=[u]),Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(f,u),function(l){p.push(l)})}),function(){return new Sk.builtin.list(p)})};Sk.builtin.reduce=function(f,h,p){if(!Sk.builtin.checkIterable(h))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(h)+"' object is not iterable");
h=Sk.abstr.iter(h);if(void 0===p&&(p=h.tp$iternext(),void 0===p))throw new Sk.builtin.TypeError("reduce() of empty sequence with no initial value");var g=p;for(p=h.tp$iternext();void 0!==p;p=h.tp$iternext())g=Sk.misceval.callsimArray(f,[g,p]);return g};Sk.builtin.sorted=function(f,h,p,g){f=Sk.misceval.arrayFromIterable(f,!0);return Sk.misceval.chain(f,a=>{a=new Sk.builtin.list(a);a.list$sort(h,p,g);return a})};Sk.builtin.filter=function(f,h){var p;Sk.builtin.pyCheckArgsLen("filter",arguments.length,
2,2);if(!Sk.builtin.checkIterable(h))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(h)+"' object is not iterable");var g=function(){return[]};var a=function(k,u){k.push(u);return k};var c=function(k){return new Sk.builtin.list(k)};h.ob$type===Sk.builtin.str?(g=function(){return new Sk.builtin.str("")},a=function(k,u){return k.sq$concat(u)},c=function(k){return k}):h.ob$type===Sk.builtin.tuple&&(c=function(k){return new Sk.builtin.tuple(k)});var n=g();var m=Sk.abstr.iter(h);for(p=m.tp$iternext();void 0!==
p;p=m.tp$iternext())g=f===Sk.builtin.none.none$?new Sk.builtin.bool(p):Sk.misceval.callsimArray(f,[p]),Sk.misceval.isTrue(g)&&(n=a(n,p));return c(n)};Sk.builtin.hasattr=function(f,h){if(!Sk.builtin.checkString(h))throw new Sk.builtin.TypeError("hasattr(): attribute name must be string");const p=Sk.misceval.tryCatch(()=>f.tp$getattr(h,!0),g=>{if(!(g instanceof Sk.builtin.AttributeError))throw g;});return Sk.misceval.chain(p,g=>void 0===g?Sk.builtin.bool.false$:Sk.builtin.bool.true$)};Sk.builtin.pow=
function(f,h,p){if(void 0===p||Sk.builtin.checkNone(p))return Sk.abstr.numberBinOp(f,h,"Pow");if(!(Sk.builtin.checkInt(f)&&Sk.builtin.checkInt(h)&&Sk.builtin.checkInt(p))){if(Sk.builtin.checkFloat(f)||Sk.builtin.checkComplex(f))return f.nb$power(h,p);throw new Sk.builtin.TypeError("unsupported operand type(s) for ** or pow(): '"+Sk.abstr.typeName(f)+"', '"+Sk.abstr.typeName(h)+"', '"+Sk.abstr.typeName(p)+"'");}return f.nb$power(h,p)};Sk.builtin.quit=function(f){f=(new Sk.builtin.str(f)).v;throw new Sk.builtin.SystemExit(f);
};Sk.builtin.issubclass=function(f,h){if(!Sk.builtin.checkClass(f))throw new Sk.builtin.TypeError("issubclass() arg 1 must be a class");var p=Sk.builtin.checkClass(h);if(!(p||h instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError("issubclass() arg 2 must be a class or tuple of classes");if(p)return f.$isSubType(h)?Sk.builtin.bool.true$:Sk.builtin.bool.false$;for(p=0;p<h.v.length;++p)if(Sk.misceval.isTrue(Sk.builtin.issubclass(f,h.v[p])))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$};
Sk.builtin.globals=function(){var f,h=new Sk.builtin.dict([]);for(f in Sk.globals){var p=Sk.unfixReserved(f);h.mp$ass_subscript(new Sk.builtin.str(p),Sk.globals[f])}return h};Sk.builtin.divmod=function(f,h){return Sk.abstr.numberBinOp(f,h,"DivMod")};Sk.builtin.format=function(f,h){return Sk.abstr.objectFormat(f,h)};const e=new WeakMap;let d=0;Sk.builtin.id=function(f){const h=e.get(f);if(void 0!==h)return new Sk.builtin.int_(h);e.set(f,d);return new Sk.builtin.int_(d++)};Sk.builtin.bytearray=function(){throw new Sk.builtin.NotImplementedError("bytearray is not yet implemented");
};Sk.builtin.callable=function(f){return Sk.builtin.checkCallable(f)?Sk.builtin.bool.true$:Sk.builtin.bool.false$};Sk.builtin.delattr=function(f,h){return Sk.builtin.setattr(f,h,void 0)};Sk.builtin.execfile=function(){throw new Sk.builtin.NotImplementedError("execfile is not yet implemented");};Sk.builtin.help=function(){throw new Sk.builtin.NotImplementedError("help is not yet implemented");};Sk.builtin.iter=function(f,h){return 1===arguments.length?Sk.abstr.iter(f):Sk.abstr.iter(new Sk.builtin.callable_iter_(f,
h))};Sk.builtin.locals=function(){throw new Sk.builtin.NotImplementedError("locals is not yet implemented");};Sk.builtin.memoryview=function(){throw new Sk.builtin.NotImplementedError("memoryview is not yet implemented");};Sk.builtin.next_=function(f,h){if(!f.tp$iternext)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(f)+"' object is not an iterator");return Sk.misceval.chain(f.tp$iternext(!0),p=>{if(void 0===p){if(h)return h;p=f.gi$ret;if(void 0!==p&&p!==Sk.builtin.none.none$)throw new Sk.builtin.StopIteration(p);
throw new Sk.builtin.StopIteration;}return p})};Sk.builtin.reload=function(){throw new Sk.builtin.NotImplementedError("reload is not yet implemented");};Sk.builtin.vars=function(){throw new Sk.builtin.NotImplementedError("vars is not yet implemented");};Sk.builtin.apply_=function(){throw new Sk.builtin.NotImplementedError("apply is not yet implemented");};Sk.builtin.buffer=function(){throw new Sk.builtin.NotImplementedError("buffer is not yet implemented");};Sk.builtin.coerce=function(){throw new Sk.builtin.NotImplementedError("coerce is not yet implemented");
};Sk.builtin.intern=function(){throw new Sk.builtin.NotImplementedError("intern is not yet implemented");}},function(F,P){function b(V,Z){Z=new this.constructor;this.ht$type&&p.call(Z);Z.args=new Sk.builtin.tuple(V.slice(0));return Z}function e(V,Z){Sk.abstr.checkNoKwargs(Sk.abstr.typeName(this),Z);this.args=new Sk.builtin.tuple(V.slice(0))}function d(){return 1>=this.args.v.length?new Sk.builtin.str(this.args.v[0]):this.args.$r()}function f(V,Z,fa,qa,pa,D){pa||(pa=[]);const w=qa?{}:{sk$solidBase:!1};
fa={tp$init:qa||e,tp$doc:fa};D&&(fa.tp$str=D);return Sk.abstr.buildNativeClass(Z,{base:V,constructor:function(...C){V.apply(this,C);pa.forEach((G,L)=>{this["$"+G]=Sk.ffi.remapToPy(C[L])})},slots:fa,getsets:Object.fromEntries(pa.map(C=>[C,{$get(){return this["$"+C]||Sk.builtin.none.none$},$set(G){this["$"+C]=G||Sk.builtin.none.none$}}])),flags:w})}function h(V,Z,fa){const qa=V.prototype.tp$init;fa={tp$doc:fa,tp$init:qa};qa===e&&(fa.tp$new=b);return Sk.abstr.buildNativeClass(Z,{base:V,constructor:function(...pa){V.apply(this,
pa)},slots:fa,flags:{sk$solidBase:!1}})}const p=Sk.abstr.buildNativeClass("BaseException",{constructor:function qa(Z,...fa){Sk.asserts.assert(this instanceof qa,"bad call to exception constructor, use 'new'");"string"===typeof Z&&(Z=new Sk.builtin.str(Z));this.args=new Sk.builtin.tuple(Z?[Z]:[]);this.traceback=2<=fa.length?[{filename:fa[0]||"<unknown>",lineno:fa[1]}]:[];this.context=this.cause=null;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"Common base class for all exceptions",
tp$new:b,tp$init:e,$r(){let Z=this.tp$name;Z+="("+this.args.v.map(fa=>Sk.misceval.objectRepr(fa)).join(", ")+")";return new Sk.builtin.str(Z)},tp$str:d},getsets:{args:{$get(){return this.args},$set(Z){if(void 0===Z)throw new Sk.builtin.TypeError("args may not be deleted");this.args=new Sk.builtin.tuple(Z)}},__cause__:{$get(){return this.$cause||Sk.builtin.none.none$},$set(Z){if(!(Sk.builtin.checkNone(Z)||Z instanceof Sk.builtin.BaseException))throw new ia("exception cause must be None or derive from BaseException");
this.$cause=Z}},__dict__:Sk.generic.getSetDict},proto:{toString(){let Z=this.tp$name;Z+=": "+this.tp$str().v;return Z=0!==this.traceback.length?Z+(" on line "+this.traceback[0].lineno):Z+" at <unknown>"}}});F=h(p,"SystemExit","Request to exit from the interpreter.");P=h(p,"KeyboardInterrupt","Program interrupted by user.");const g=h(p,"GeneratorExit","Request that a generator exit."),a=h(p,"Exception","Common base class for all non-exit exceptions."),c=f(a,"StopIteration","Signal the end from iterator.__next__().",
function(Z,fa){e.call(this,Z,fa);this.$value=Z[0]||Sk.builtin.none.none$},["value"]),n=h(a,"StopAsyncIteration","Signal the end from iterator.__anext__()."),m=h(a,"ArithmeticError","Base class for arithmetic errors."),k=h(m,"FloatingPointError","Floating point operation failed."),u=h(m,"OverflowError","Result too large to be represented."),l=h(m,"ZeroDivisionError","Second argument to a division or modulo operation was zero."),q=h(a,"AssertionError","Assertion failed."),z=h(a,"AttributeError","Attribute not found."),
r=h(a,"BufferError","Buffer error."),t=h(a,"EOFError","Read beyond end of file."),x=f(a,"ImportError","Import can't find module, or can't find name in module.",function(Z,fa){e.call(this,Z);const [qa,pa]=Sk.abstr.copyKeywordsToNamedArgs("ImportError",["name","path"],[],fa);this.$name=qa;this.$path=pa;1===Z.length&&(this.$msg=Z[0])},["msg","name","path"],function(){return Sk.builtin.checkString(this.$msg)?this.$msg:d.call(this)}),v=h(x,"ModuleNotFoundError","Module not found."),B=h(a,"LookupError",
"Base class for lookup errors."),I=h(B,"IndexError","Sequence index out of range."),M=f(B,"KeyError","Mapping key not found.",null,null,function(){return 1===this.args.v.length?this.args.v[0].$r():d.call(this)}),S=h(a,"MemoryError","Out of memory."),E=h(a,"NameError","Name not found globally."),H=h(E,"UnboundLocalError","Local name referenced but not bound to a value."),y=f(a,"OSError","Base class for I/O related errors.",function(Z,fa){e.call(this,Z,fa)}),A=h(y,"FileNotFoundError","File not found."),
J=h(y,"TimeoutError","Timeout expired."),Q=h(a,"ReferenceError","Weak ref proxy used after referent went away."),X=h(a,"RuntimeError","Unspecified run-time error."),aa=h(X,"NotImplementedError","Method or function hasn't been implemented yet."),ea=h(X,"RecursionError","Recursion limit exceeded."),na=f(a,"SyntaxError","Invalid syntax.",function(Z,fa){e.call(this,Z,fa);1<=Z.length&&(this.$msg=Z[0]);2===Z.length&&(Z=(new Sk.builtin.tuple(Z[1])).v,this.$filename=Z[0],this.$lineno=Z[1],this.$offset=Z[2],
this.$text=Z[3])},["msg","filename","lineno","offset","text"],function(){return d.call(this)}),oa=h(na,"IndentationError","Improper indentation."),ca=h(oa,"TabError","Improper mixture of spaces and tabs."),la=h(a,"SystemError","Internal error in the Skulpt interpreter."),ia=h(a,"TypeError","Inappropriate argument type."),ka=h(a,"ValueError","Inappropriate argument value (of correct type)."),U=h(ka,"UnicodeError","Unicode related error."),ja=h(U,"UnicodeDecodeError","Unicode decoding error."),O=h(U,
"UnicodeEncodeError","Unicode encoding error.");Object.assign(Sk.builtin,{BaseException:p,SystemExit:F,KeyboardInterrupt:P,GeneratorExit:g,Exception:a,StopIteration:c,StopAsyncIteration:n,ArithmeticError:m,FloatingPointError:k,OverflowError:u,ZeroDivisionError:l,AssertionError:q,AttributeError:z,BufferError:r,EOFError:t,ImportError:x,ModuleNotFoundError:v,LookupError:B,IndexError:I,KeyError:M,MemoryError:S,NameError:E,UnboundLocalError:H,OSError:y,IOError:y,FileNotFoundError:A,TimeoutError:J,ReferenceError:Q,
RuntimeError:X,NotImplementedError:aa,RecursionError:ea,SyntaxError:na,IndentationError:oa,TabError:ca,SystemError:la,TypeError:ia,ValueError:ka,UnicodeError:U,UnicodeDecodeError:ja,UnicodeEncodeError:O});Sk.builtin.SuspensionError=h(a,"SuspensionError","Unsupported Suspension in code.");Sk.builtin.ExternalError=Sk.abstr.buildNativeClass("ExternalError",{constructor:function(...Z){this.nativeError=Z[0];if(!Sk.builtin.checkString(this.nativeError)&&(Z[0]=this.nativeError.toString(),Z[0].startsWith("RangeError: Maximum call")))return Z[0]=
"Maximum call stack size exceeded",new ea(...Z);a.apply(this,Z)},base:a});Sk.builtin.getExcInfo=function(Z){return new Sk.builtin.tuple([Z.ob$type||Sk.builtin.none.none$,Z,Sk.builtin.none.none$])}},function(F,P){Sk.builtin.method=Sk.abstr.buildNativeClass("method",{constructor:function(b,e){Sk.asserts.assert(this instanceof Sk.builtin.method,"bad call to method constructor, use 'new'");this.im_func=b;this.im_self=e;this.im_call=b.tp$call},slots:{$r(){let b=this.im_func.tp$getattr(Sk.builtin.str.$qualname)||
this.im_func.tp$getattr(Sk.builtin.str.$name);b=b&&b.v||"?";return new Sk.builtin.str("<bound method "+b+" of "+Sk.misceval.objectRepr(this.im_self)+">")},tp$hash(){const b=Sk.abstr.objectHash(this.im_self),e=Sk.abstr.objectHash(this.im_func);return b+e},tp$call(b,e){var d=this.im_call;if(void 0===d)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(this.im_func)+"' object is not callable");b=[this.im_self,...b];return d.call(this.im_func,b,e)},tp$new(b,e){Sk.abstr.checkNoKwargs("method",e);Sk.abstr.checkArgsLen("method",
b,2,2);e=b[0];b=b[1];if(!Sk.builtin.checkCallable(e))throw new Sk.builtin.TypeError("first argument must be callable");if(Sk.builtin.checkNone(b))throw new Sk.builtin.TypeError("self must not be None");return new Sk.builtin.method(e,b)},tp$richcompare(b,e){if("Eq"!=e&&"NotEq"!=e||!(b instanceof Sk.builtin.method))return Sk.builtin.NotImplemented.NotImplemented$;let d;try{d=Sk.misceval.richCompareBool(this.im_self,b.im_self,"Eq",!1)&&this.im_func==b.im_func}catch(f){d=!1}return"Eq"==e?d:!d},tp$descr_get(b,
e){return this},tp$getattr(b,e){const d=Sk.abstr.lookupSpecial(this,b);return void 0!==d?d:this.im_func.tp$getattr(b,e)}},getsets:{__func__:{$get(){return this.im_func}},__self__:{$get(){return this.im_self}},__doc__:{$get(){return this.im_func.tp$getattr(Sk.builtin.str.$doc)}}},flags:{sk$unacceptableBase:!0}})},function(F,P){function b(p){if(null!==p&&void 0!==p){if(!0===p.sk$int)return p.v;if(void 0!==p.nb$index)return p.nb$index();if("number"===typeof p&&Number.isInteger(p))return p}}function e(p,
g){const a=b(p);if(void 0!==a)return a;g=(g||"'{tp$name}' object cannot be interpreted as an integer").replace("{tp$name}",Sk.abstr.typeName(p));throw new Sk.builtin.TypeError(g);}function d(){const p=(Sk.global.navigator||{}).userAgent||"";return-1<p.indexOf("MSIE ")||-1<p.indexOf("Trident/")}function f(p,g){let a=p;g.forEach(c=>{c=c.ob$type;if(!a.$isSubType(c))if(c.$isSubType(a))a=c;else throw new Sk.builtin.TypeError("metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases");
});return a}function h(p,g,a,c,n){const m=p.tp$getattr(Sk.builtin.str.$prepare);let k,u=null;if(void 0===m)return[u,k];u=Sk.misceval.callsimArray(m,[g,a],c);if(!Sk.builtin.checkMapping(u))throw new Sk.builtin.TypeError(n?p.prototype.tp$name:"<metaclass>.__prepare__() must return a mapping not '"+Sk.abstr.typeName(u)+"'");k={get(l,q){try{return Sk.abstr.objectGetItem(l,new Sk.builtin.str(Sk.unfixReserved(q)))}catch(z){if(!(z instanceof Sk.builtin.KeyError))throw z;}},set(l,q,z){Sk.abstr.objectSetItem(l,
new Sk.builtin.str(Sk.unfixReserved(q)),z);return!0}};return[u,k]}Sk.misceval={};Sk.misceval.Suspension=function(p,g,a){this.$isSuspension=!0;void 0!==p&&void 0!==g&&(this.resume=function(){return p(g.resume())});this.child=g;this.optional=void 0!==g&&g.optional;this.data=void 0===a&&void 0!==g?g.data:a};Sk.exportSymbol("Sk.misceval.Suspension",Sk.misceval.Suspension);Sk.misceval.retryOptionalSuspensionOrThrow=function(p,g){for(;p instanceof Sk.misceval.Suspension;){if(!p.optional){g=new Sk.builtin.SuspensionError(g||
"Cannot call a function that blocks or suspends here");const a=[];for(;null!=p;)p.$lineno&&a.push({filename:p.$filename,lineno:p.$lineno,colno:p.$colno}),p=p.child;a.reverse();g.traceback.push(...a);throw g;}p=p.resume()}return p};Sk.exportSymbol("Sk.misceval.retryOptionalSuspensionOrThrow",Sk.misceval.retryOptionalSuspensionOrThrow);Sk.misceval.isIndex=function(p){return null!==p&&void 0!==p&&(void 0!==p.nb$index||"number"===typeof p&&Number.isInteger(p))};Sk.exportSymbol("Sk.misceval.isIndex",Sk.misceval.isIndex);
Sk.misceval.asIndex=b;Sk.misceval.asIndexSized=function(p,g,a){a=e(p,a);if("number"===typeof a)return a;if(null==g)return JSBI.lessThan(a,JSBI.__ZERO)?-Number.MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER;throw new g("cannot fit '"+Sk.abstr.typeName(p)+"' into an index-sized integer");};Sk.misceval.asIndexOrThrow=e;Sk.misceval.applySlice=function(p,g,a,c){return Sk.abstr.objectGetItem(p,new Sk.builtin.slice(g,a,null),c)};Sk.exportSymbol("Sk.misceval.applySlice",Sk.misceval.applySlice);Sk.misceval.assignSlice=
function(p,g,a,c,n){g=new Sk.builtin.slice(g,a);return null===c?Sk.abstr.objectDelItem(p,g):Sk.abstr.objectSetItem(p,g,c,n)};Sk.exportSymbol("Sk.misceval.assignSlice",Sk.misceval.assignSlice);Sk.misceval.arrayFromArguments=function(p){var g;if(1!=p.length)return p;var a=p[0];a instanceof Sk.builtin.set?a=a.tp$iter().$obj:a instanceof Sk.builtin.dict&&(a=Sk.builtin.dict.prototype.keys.func_code(a));if(a instanceof Sk.builtin.list||a instanceof Sk.builtin.tuple)return a.v;if(Sk.builtin.checkIterable(a)){p=
[];a=Sk.abstr.iter(a);for(g=a.tp$iternext();void 0!==g;g=a.tp$iternext())p.push(g);return p}throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object is not iterable");};Sk.exportSymbol("Sk.misceval.arrayFromArguments",Sk.misceval.arrayFromArguments);Sk.misceval.iterator=Sk.abstr.buildIteratorClass("iterator",{constructor:function(p,g){this.tp$iternext=g?p:function(a){let c=p();return a||void 0===c||!c.$isSuspension?c:Sk.misceval.retryOptionalSuspensionOrThrow(c)}},iternext:function(p){return this.tp$iternext(p)},
flags:{sk$unacceptableBase:!0}});Sk.misceval.swappedOp_={Eq:"Eq",NotEq:"NotEq",Lt:"Gt",LtE:"GtE",Gt:"Lt",GtE:"LtE"};Sk.misceval.opSymbols={Eq:"==",NotEq:"!=",Lt:"<",LtE:"<=",Gt:">",GtE:">=",Is:"is",IsNot:"is not",In_:"in",NotIn:"not in"};Sk.misceval.richCompareBool=function(p,g,a,c){Sk.asserts.assert(p.sk$object&&g.sk$object,"JS object passed to richCompareBool");var n=p.ob$type,m=g.ob$type,k=m!==n&&void 0===m.sk$baseClass&&m.$isSubType(n);if(!Sk.__future__.python3&&n!==m&&("GtE"===a||"Gt"===a||"LtE"===
a||"Lt"===a)){var u=[Sk.builtin.float_,Sk.builtin.int_,Sk.builtin.lng,Sk.builtin.bool];const q=[Sk.builtin.dict,Sk.builtin.enumerate,Sk.builtin.filter_,Sk.builtin.list,Sk.builtin.map_,Sk.builtin.str,Sk.builtin.tuple,Sk.builtin.zip_];var l=u.indexOf(n);n=q.indexOf(n);u=u.indexOf(m);m=q.indexOf(m);if(p===Sk.builtin.none.none$)switch(a){case "Lt":return!0;case "LtE":return!0;case "Gt":return!1;case "GtE":return!1}if(g===Sk.builtin.none.none$)switch(a){case "Lt":return!1;case "LtE":return!1;case "Gt":return!0;
case "GtE":return!0}if(-1!==l&&-1!==m)switch(a){case "Lt":return!0;case "LtE":return!0;case "Gt":return!1;case "GtE":return!1}if(-1!==n&&-1!==u)switch(a){case "Lt":return!1;case "LtE":return!1;case "Gt":return!0;case "GtE":return!0}if(-1!==n&&-1!==m)switch(a){case "Lt":return n<m;case "LtE":return n<=m;case "Gt":return n>m;case "GtE":return n>=m}}if("Is"===a)return p===g;if("IsNot"===a)return p!==g;if("In"===a)return Sk.misceval.chain(Sk.abstr.sequenceContains(g,p,c),Sk.misceval.isTrue);if("NotIn"===
a)return Sk.misceval.chain(Sk.abstr.sequenceContains(g,p,c),function(q){return!Sk.misceval.isTrue(q)});m={Eq:"ob$eq",NotEq:"ob$ne",Gt:"ob$gt",GtE:"ob$ge",Lt:"ob$lt",LtE:"ob$le"};l=m[a];if(k&&(c=m[Sk.misceval.swappedOp_[a]],(c=g[c](p))!==Sk.builtin.NotImplemented.NotImplemented$)||(c=p[l](g))!==Sk.builtin.NotImplemented.NotImplemented$||!k&&(c=m[Sk.misceval.swappedOp_[a]],(c=g[c](p))!==Sk.builtin.NotImplemented.NotImplemented$))return Sk.misceval.isTrue(c);if(!Sk.__future__.python3){if(k=Sk.abstr.lookupSpecial(p,
Sk.builtin.str.$cmp))try{c=Sk.misceval.callsimArray(k,[g]);if(Sk.builtin.checkNumber(c)){c=Sk.builtin.asnum$(c);if("Eq"===a)return 0===c;if("NotEq"===a)return 0!==c;if("Lt"===a)return 0>c;if("Gt"===a)return 0<c;if("LtE"===a)return 0>=c;if("GtE"===a)return 0<=c}if(c!==Sk.builtin.NotImplemented.NotImplemented$)throw new Sk.builtin.TypeError("comparison did not return an int");}catch(q){throw new Sk.builtin.TypeError("comparison did not return an int");}if(k=Sk.abstr.lookupSpecial(g,Sk.builtin.str.$cmp))try{c=
Sk.misceval.callsimArray(k,[p]);if(Sk.builtin.checkNumber(c)){c=Sk.builtin.asnum$(c);if("Eq"===a)return 0===c;if("NotEq"===a)return 0!==c;if("Lt"===a)return 0<c;if("Gt"===a)return 0>c;if("LtE"===a)return 0<=c;if("GtE"===a)return 0>=c}if(c!==Sk.builtin.NotImplemented.NotImplemented$)throw new Sk.builtin.TypeError("comparison did not return an int");}catch(q){throw new Sk.builtin.TypeError("comparison did not return an int");}if(p===Sk.builtin.none.none$&&g===Sk.builtin.none.none$){if("Eq"===a)return p.v===
g.v;if("NotEq"===a)return p.v!==g.v;if("Gt"===a)return p.v>g.v;if("GtE"===a)return p.v>=g.v;if("Lt"===a)return p.v<g.v;if("LtE"===a)return p.v<=g.v}}if("Eq"===a)return p===g;if("NotEq"===a)return p!==g;p=Sk.abstr.typeName(p);g=Sk.abstr.typeName(g);throw new Sk.builtin.TypeError("'"+Sk.misceval.opSymbols[a]+"' not supported between instances of '"+p+"' and '"+g+"'");};Sk.exportSymbol("Sk.misceval.richCompareBool",Sk.misceval.richCompareBool);Sk.misceval.objectRepr=function(p){Sk.asserts.assert(void 0!==
p,"trying to repr undefined");if(null!==p&&p.$r)return p.$r().v;try{return(new Sk.builtin.str(p)).v}catch(g){if(g instanceof Sk.builtin.TypeError)return"<unknown>";throw g;}};Sk.exportSymbol("Sk.misceval.objectRepr",Sk.misceval.objectRepr);Sk.misceval.opAllowsEquality=function(p){switch(p){case "LtE":case "Eq":case "GtE":return!0}return!1};Sk.exportSymbol("Sk.misceval.opAllowsEquality",Sk.misceval.opAllowsEquality);Sk.misceval.isTrue=function(p){return!0===p||p===Sk.builtin.bool.true$?!0:!1===p||
p===Sk.builtin.bool.false$||null===p||void 0===p?!1:p.nb$bool?p.nb$bool():p.sq$length?0!==p.sq$length():!!p};Sk.exportSymbol("Sk.misceval.isTrue",Sk.misceval.isTrue);Sk.misceval.softspace_=!1;Sk.misceval.print_=function(p){Sk.misceval.softspace_&&("\n"!==p&&Sk.output(" "),Sk.misceval.softspace_=!1);var g=new Sk.builtin.str(p);return Sk.misceval.chain(Sk.importModule("sys",!1,!0),function(a){return Sk.misceval.apply(a.$d.stdout.write,void 0,void 0,void 0,[a.$d.stdout,g])},function(){var a;(a=0===g.v.length)||
(a=g.v[g.v.length-1],a=!("\n"===a||"\t"===a||"\r"===a));if(a||" "===g.v[g.v.length-1])Sk.misceval.softspace_=!0})};Sk.exportSymbol("Sk.misceval.print_",Sk.misceval.print_);Sk.misceval.loadname=function(p,g){g=g[p];if(void 0!==g)return g;g=Sk.builtins[p];if(void 0!==g)return g;throw new Sk.builtin.NameError("name '"+Sk.unfixReserved(p)+"' is not defined");};Sk.exportSymbol("Sk.misceval.loadname",Sk.misceval.loadname);Sk.misceval.call=function(p,g,a,c,n){n=Array.prototype.slice.call(arguments,4);return Sk.misceval.apply(p,
g,a,c,n)};Sk.exportSymbol("Sk.misceval.call",Sk.misceval.call);Sk.misceval.callAsync=function(p,g,a,c,n,m){m=Array.prototype.slice.call(arguments,5);return Sk.misceval.applyAsync(p,g,a,c,n,m)};Sk.exportSymbol("Sk.misceval.callAsync",Sk.misceval.callAsync);Sk.misceval.callOrSuspend=function(p,g,a,c,n){n=Array.prototype.slice.call(arguments,4);return Sk.misceval.applyOrSuspend(p,g,a,c,n)};Sk.exportSymbol("Sk.misceval.callOrSuspend",Sk.misceval.callOrSuspend);Sk.misceval.callsim=function(p,g){g=Array.prototype.slice.call(arguments,
1);return Sk.misceval.apply(p,void 0,void 0,void 0,g)};Sk.exportSymbol("Sk.misceval.callsim",Sk.misceval.callsim);Sk.misceval.callsimArray=function(p,g,a){g=g||[];return Sk.misceval.retryOptionalSuspensionOrThrow(Sk.misceval.callsimOrSuspendArray(p,g,a))};Sk.exportSymbol("Sk.misceval.callsimArray",Sk.misceval.callsimArray);Sk.misceval.callsimAsync=function(p,g,a){a=Array.prototype.slice.call(arguments,2);return Sk.misceval.applyAsync(p,g,void 0,void 0,void 0,a)};Sk.exportSymbol("Sk.misceval.callsimAsync",
Sk.misceval.callsimAsync);Sk.misceval.callsimOrSuspend=function(p,g){g=Array.prototype.slice.call(arguments,1);return Sk.misceval.applyOrSuspend(p,void 0,void 0,void 0,g)};Sk.exportSymbol("Sk.misceval.callsimOrSuspend",Sk.misceval.callsimOrSuspend);Sk.misceval.callsimOrSuspendArray=function(p,g,a){g=g||[];return void 0!==p&&p.tp$call?p.tp$call(g,a):Sk.misceval.applyOrSuspend(p,void 0,void 0,a,g)};Sk.exportSymbol("Sk.misceval.callsimOrSuspendArray",Sk.misceval.callsimOrSuspendArray);Sk.misceval.apply=
function(p,g,a,c,n){p=Sk.misceval.applyOrSuspend(p,g,a,c,n);return p instanceof Sk.misceval.Suspension?Sk.misceval.retryOptionalSuspensionOrThrow(p):p};Sk.exportSymbol("Sk.misceval.apply",Sk.misceval.apply);Sk.misceval.asyncToPromise=function(p,g){return new Promise(function(a,c){try{(function k(m){try{for(var u=function(){try{k(m.resume())}catch(t){c(t)}},l=function(t){try{m.data.result=t,u()}catch(x){c(x)}},q=function(t){try{m.data.error=t,u()}catch(x){c(x)}};m instanceof Sk.misceval.Suspension;){var z=
g&&(g[m.data.type]||g["*"]);if(z){var r=z(m);if(r){r.then(k,c);return}}if("Sk.promise"==m.data.type){m.data.promise.then(l,q);return}if("Sk.yield"==m.data.type){Sk.global.setImmediate(u);return}if("Sk.delay"==m.data.type){Sk.global.setImmediate(u);return}if(m.optional)m=m.resume();else throw new Sk.builtin.SuspensionError("Unhandled non-optional suspension of type '"+m.data.type+"'");}a(m)}catch(t){c(t)}})(p())}catch(n){c(n)}})};Sk.exportSymbol("Sk.misceval.asyncToPromise",Sk.misceval.asyncToPromise);
Sk.misceval.applyAsync=function(p,g,a,c,n,m){return Sk.misceval.asyncToPromise(function(){return Sk.misceval.applyOrSuspend(g,a,c,n,m)},p)};Sk.exportSymbol("Sk.misceval.applyAsync",Sk.misceval.applyAsync);Sk.misceval.chain=function(p,g){for(var a=1,c=p,n,m;;){if(a==arguments.length)return c;if(c&&c.$isSuspension)break;c=arguments[a](c);a++}m=Array(arguments.length-a);for(n=0;n<arguments.length-a;n++)m[n]=arguments[a+n];n=0;return function l(u){for(;n<m.length;){if(u instanceof Sk.misceval.Suspension)return new Sk.misceval.Suspension(l,
u);u=m[n](u);n++}return u}(c)};Sk.exportSymbol("Sk.misceval.chain",Sk.misceval.chain);Sk.misceval.tryCatch=function(p,g){try{var a=p()}catch(c){return g(c)}return a instanceof Sk.misceval.Suspension?(p=new Sk.misceval.Suspension(void 0,a),p.resume=function(){return Sk.misceval.tryCatch(a.resume,g)},p):a};Sk.exportSymbol("Sk.misceval.tryCatch",Sk.misceval.tryCatch);Sk.misceval.iterFor=function(p,g,a){var c=a,n=function(m){c=m;return m instanceof Sk.misceval.Break?m:p.tp$iternext(!0)};return function u(k){for(;void 0!==
k;){if(k instanceof Sk.misceval.Suspension)return new Sk.misceval.Suspension(u,k);if(k===Sk.misceval.Break||k instanceof Sk.misceval.Break)return k.brValue;k=Sk.misceval.chain(g(k,c),n)}return c}(p.tp$iternext(!0))};Sk.exportSymbol("Sk.misceval.iterFor",Sk.misceval.iterFor);Sk.misceval.iterArray=function(p,g,a){Sk.asserts.assert(Array.isArray(p),"iterArgs requires an array");let c=0;return Sk.misceval.iterFor({tp$iternext:()=>p[c++]},g,a)};Sk.misceval.arrayFromIterable=function(p,g){if(void 0===p)return[];
if(void 0===p.ht$type&&void 0!==p.sk$asarray)return p.sk$asarray();const a=[];p=Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(p),c=>{a.push(c)}),()=>a);return g?p:Sk.misceval.retryOptionalSuspensionOrThrow(p)};Sk.misceval.Break=function(p){if(!(this instanceof Sk.misceval.Break))return new Sk.misceval.Break(p);this.brValue=p};Sk.exportSymbol("Sk.misceval.Break",Sk.misceval.Break);Sk.misceval.applyOrSuspend=function(p,g,a,c,n){var m;if(null==p||p===Sk.builtin.none.none$)throw new Sk.builtin.TypeError("'"+
Sk.abstr.typeName(p)+"' object is not callable");"function"===typeof p&&void 0===p.tp$call&&(p=new Sk.builtin.func(p));var k=p.tp$call;if(void 0!==k){if(a)for(a=a.tp$iter(),m=a.tp$iternext();void 0!==m;m=a.tp$iternext())n.push(m);if(g)for(a=Sk.abstr.iter(g),m=a.tp$iternext();void 0!==m;m=a.tp$iternext()){if(!Sk.builtin.checkString(m))throw new Sk.builtin.TypeError("Function keywords must be strings");c.push(m.v);c.push(Sk.abstr.objectGetItem(g,m,!1))}return k.call(p,n,c,g)}k=p.__call__;if(void 0!==
k)return n.unshift(p),Sk.misceval.apply(k,g,a,c,n);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(p)+"' object is not callable");};Sk.exportSymbol("Sk.misceval.applyOrSuspend",Sk.misceval.applyOrSuspend);Sk.misceval.promiseToSuspension=function(p){var g=new Sk.misceval.Suspension;g.resume=function(){if(g.data.error)throw g.data.error;return g.data.result};g.data={type:"Sk.promise",promise:p};return g};Sk.exportSymbol("Sk.misceval.promiseToSuspension",Sk.misceval.promiseToSuspension);Sk.misceval.buildClass=
function(p,g,a,c,n,m){a=new Sk.builtin.str(a);const k=new Sk.builtin.tuple(c);m=m||[];c=c||[];let u;var l=!0;const q=m.indexOf("metaclass");-1<q?(u=m[q+1],m[q]=m[m.length-2],m[q+1]=m[m.length-1],m.pop(),m.pop(),l=Sk.builtin.checkClass(u)):u=c.length?c[0].ob$type:Sk.builtin.type;l&&(u=f(u,c));let z=null;u!==Sk.builtin.type&&([z,t]=h(u,a,k,m,l));c=!1;let r={};if(null===z)z=new Sk.builtin.dict([]);else if(z.constructor===Sk.builtin.dict||d()){var t=Sk.abstr.iter(Sk.misceval.callsimArray(z.tp$getattr(Sk.builtin.str.$keys)));
for(l=t.tp$iternext();void 0!==l;l=t.tp$iternext())Sk.builtin.checkString(l)&&(r[l.toString()]=z.mp$subscript(l))}else r=new Proxy(z,t),c=!0;p.__name__&&(r.__module__=p.__name__);g(p,r,void 0===n?{}:n);c||Object.keys(r).forEach(x=>{Sk.abstr.objectSetItem(z,new Sk.builtin.str(x),r[x])});return Sk.misceval.callsimOrSuspendArray(u,[a,k,z],m)};Sk.exportSymbol("Sk.misceval.buildClass",Sk.misceval.buildClass)},function(F,P){Sk.builtin.callable_iter_=Sk.abstr.buildIteratorClass("callable_iterator",{constructor:function(b,
e){if(!Sk.builtin.checkCallable(b))throw new Sk.builtin.TypeError("iter(v, w): v must be callable");this.$callable=b;this.$sentinel=e;this.$flag=!1},iternext(b){if(!0!==this.$flag){if(b)return b=Sk.misceval.callsimOrSuspendArray(this.$callable,[]),Sk.misceval.chain(b,e=>{if(Sk.misceval.richCompareBool(e,this.$sentinel,"Eq",!0))this.$flag=!0;else return e});b=Sk.misceval.callsimArray(this.$callable,[]);if(Sk.misceval.richCompareBool(b,this.$sentinel,"Eq",!1))this.$flag=!0;else return b}},flags:{sk$unacceptableBase:!0}});
Sk.builtin.seq_iter_=Sk.abstr.buildIteratorClass("iterator",{constructor:function(b){this.$index=0;this.$seq=b},iternext(b){let e;e=Sk.misceval.tryCatch(()=>this.$seq.mp$subscript(new Sk.builtin.int_(this.$index++),b),d=>{if(d instanceof Sk.builtin.IndexError||d instanceof Sk.builtin.StopIteration)this.gi$ret=d.$value||Sk.builtin.none.none$;else throw d;});return b?e:Sk.misceval.retryOptionalSuspensionOrThrow(e)},methods:{__length_hint__:{$flags:{NoArgs:!0},$meth(){if(this.$seq.sq$length)return this.$seq.sq$length()-
this.$index;throw new Sk.builtin.NotImplementedError("len is not implemented for "+Sk.abstr.typeName(this.$seq));}}},flags:{sk$unacceptableBase:!0}});Sk.exportSymbol("Sk.builtin.callable_iter_",Sk.builtin.callable_iter_)},function(F,P){Sk.builtin.list=Sk.abstr.buildNativeClass("list",{constructor:function(d){void 0===d?d=[]:Array.isArray(d)||(d=Sk.misceval.arrayFromIterable(d));Sk.asserts.assert(this instanceof Sk.builtin.list,"bad call to list, use 'new' with an Array of python objects");this.v=
d;this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",tp$new:Sk.generic.new,tp$init(d,f){Sk.abstr.checkNoKwargs("list",f);Sk.abstr.checkArgsLen("list",d,0,1);return Sk.misceval.chain(Sk.misceval.arrayFromIterable(d[0],!0),h=>{this.v=h})},$r(){if(this.in$repr)return new Sk.builtin.str("[...]");
this.in$repr=!0;const d=this.v.map(f=>Sk.misceval.objectRepr(f));this.in$repr=!1;return new Sk.builtin.str("["+d.join(", ")+"]")},tp$richcompare:Sk.generic.seqCompare,tp$iter(){return new b(this)},sq$length(){return this.v.length},sq$concat(d){if(!(d instanceof Sk.builtin.list))throw new Sk.builtin.TypeError("can only concatenate list to list");return new Sk.builtin.list(this.v.concat(d.v))},sq$contains(d){for(let f=this.tp$iter(),h=f.tp$iternext();void 0!==h;h=f.tp$iternext())if(h===d||Sk.misceval.richCompareBool(h,
d,"Eq"))return!0;return!1},sq$repeat(d){if(!Sk.misceval.isIndex(d))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(d)+"'");d=Sk.misceval.asIndexSized(d,Sk.builtin.OverflowError);if(d*this.v.length>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;const f=[];for(let h=0;h<d;h++)for(let p=0;p<this.v.length;p++)f.push(this.v[p]);return new Sk.builtin.list(f)},mp$subscript(d){if(Sk.misceval.isIndex(d))return d=Sk.misceval.asIndexSized(d,Sk.builtin.IndexError),
d=this.list$inRange(d,"list index out of range"),this.v[d];if(d instanceof Sk.builtin.slice){const f=[];d.sssiter$(this.v.length,h=>{f.push(this.v[h])});return new Sk.builtin.list(f)}throw new Sk.builtin.TypeError("list indices must be integers or slices, not "+Sk.abstr.typeName(d));},mp$ass_subscript(d,f){void 0===f?this.del$subscript(d):this.ass$subscript(d,f)},sq$inplace_concat(d){return d===this?(this.v.push(...this.v),this):Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(d),f=>{this.v.push(f)}),
()=>this)},sq$inplace_repeat(d){if(!Sk.misceval.isIndex(d))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(d)+"'");d=Sk.misceval.asIndexSized(d,Sk.builtin.OverflowError);const f=this.v.length;if(0>=d)this.v.length=0;else if(d*f>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;for(let h=1;h<d;h++)for(let p=0;p<f;p++)this.v.push(this.v[p]);return this}},methods:{__reversed__:{$meth(){return new e(this)},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return a reverse iterator over the list."},clear:{$meth(){this.v.length=0;return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Remove all items from list."},copy:{$meth(){return new Sk.builtin.list(this.v.slice(0))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a shallow copy of the list."},append:{$meth(d){this.v.push(d);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:"($self, object, /)",$doc:"Append object to the end of the list."},insert:{$meth(d,
f){d=Sk.misceval.asIndexSized(d,Sk.builtin.OverflowError);({start:d}=Sk.builtin.slice.startEnd$wrt(this,d));this.v.splice(d,0,f);return Sk.builtin.none.none$},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($self, index, object, /)",$doc:"Insert object before index."},extend:{$meth(d){return d===this?(this.v.push(...this.v),Sk.builtin.none.none$):Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(d),f=>{this.v.push(f)}),()=>Sk.builtin.none.none$)},$flags:{OneArg:!0},$textsig:"($self, iterable, /)",$doc:"Extend list by appending elements from the iterable."},
pop:{$meth(d){d=void 0===d?this.v.length-1:Sk.misceval.asIndexSized(d,Sk.builtin.OverflowError);d=this.list$inRange(d,"pop index out of range");const f=this.v[d];this.v.splice(d,1);return f},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, index=-1, /)",$doc:"Remove and return item at index (default last).\n\nRaises IndexError if list is empty or index is out of range."},remove:{$meth(d){d=this.list$indexOf(d);if(-1===d)throw new Sk.builtin.ValueError("list.remove(x): x not in list");this.v.splice(d,
1);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Remove first occurrence of value.\n\nRaises ValueError if the value is not present."},sort:{$meth(d,f){if(d.length)throw new Sk.builtin.TypeError("sort() takes no positional arguments");const [h,p]=Sk.abstr.copyKeywordsToNamedArgs("sort",["key","reverse"],d,f,[Sk.builtin.none.none$,Sk.builtin.bool.false$]);return this.list$sort(void 0,h,p)},$flags:{FastCall:!0},$textsig:"($self, /, *, key=None, reverse=False)",
$doc:"Stable sort *IN PLACE*."},index:{$meth(d,f,h){if(void 0!==f&&!Sk.misceval.isIndex(f)||void 0!==h&&!Sk.misceval.isIndex(h))throw new Sk.builtin.TypeError("slice indices must be integers or have an __index__ method");f=this.list$indexOf(d,f,h);if(-1===f)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(d)+" is not in list");return new Sk.builtin.int_(f)},$flags:{MinArgs:1,MaxArgs:3},$textsig:"($self, value, start=0, stop=sys.maxsize, /)",$doc:"Return first index of value.\n\nRaises ValueError if the value is not present."},
count:{$meth(d){let f=0;const h=this.v.length;for(let p=0;p<h;p++)if(this.v[p]===d||Sk.misceval.richCompareBool(this.v[p],d,"Eq"))f+=1;return new Sk.builtin.int_(f)},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Return number of occurrences of value."},reverse:{$meth(){this.list$reverse();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Reverse *IN PLACE*."}},classmethods:Sk.generic.classGetItem,proto:{sk$asarray(){return this.v.slice(0)},list$sort:function(d,f,
h){const p=null!=f&&f!==Sk.builtin.none.none$;var g=null!=d&&d!==Sk.builtin.none.none$;let a;if(void 0===h)a=!1;else if(Sk.builtin.checkInt(h))a=Sk.misceval.isTrue(h);else throw new Sk.builtin.TypeError("an integer is required");h=new Sk.builtin.timSort(this);this.v=[];const c=new Sk.builtin.int_(0);if(p){h.lt=g?function(n,m){n=Sk.misceval.callsimArray(d,[n[0],m[0]]);return Sk.misceval.richCompareBool(n,c,"Lt")}:function(n,m){return Sk.misceval.richCompareBool(n[0],m[0],"Lt")};for(let n=0;n<h.listlength;n++){g=
h.list.v[n];const m=Sk.misceval.callsimArray(f,[g]);h.list.v[n]=[m,g]}}else g&&(h.lt=function(n,m){n=Sk.misceval.callsimArray(d,[n,m]);return Sk.misceval.richCompareBool(n,c,"Lt")});a&&h.list.list$reverse();h.sort();a&&h.list.list$reverse();if(p)for(f=0;f<h.listlength;f++)g=h.list.v[f][1],h.list.v[f]=g;f=0<this.sq$length();this.v=h.list.v;if(f)throw new Sk.builtin.ValueError("list modified during sort");return Sk.builtin.none.none$},list$inRange(d,f){0>d&&(d+=this.v.length);if(0<=d&&d<this.v.length)return d;
throw new Sk.builtin.IndexError(f);},list$indexOf(d,f,h){for({start:f,end:h}=Sk.builtin.slice.startEnd$wrt(this,f,h);f<h&&f<this.v.length;f++)if(this.v[f]===d||Sk.misceval.richCompareBool(this.v[f],d,"Eq"))return f;return-1},list$reverse(){this.v.reverse()},ass$subscript(d,f){if(Sk.misceval.isIndex(d))this.ass$index(d,f);else if(d instanceof Sk.builtin.slice){const {start:h,stop:p,step:g}=d.slice$indices(this.v.length);1===g?this.ass$slice(h,p,f):this.ass$ext_slice(d,f)}else throw new Sk.builtin.TypeError("list indices must be integers or slices, not "+
Sk.abstr.typeName(d));},ass$index(d,f){d=Sk.misceval.asIndexSized(d,Sk.builtin.IndexError);d=this.list$inRange(d,"list assignment index out of range");this.v[d]=f},ass$slice(d,f,h){if(!Sk.builtin.checkIterable(h))throw new Sk.builtin.TypeError("can only assign an iterable");h=Sk.misceval.arrayFromIterable(h);this.v.splice(d,f-d,...h)},ass$ext_slice(d,f){const h=[];d.sssiter$(this.v.length,p=>{h.push(p)});if(!Sk.builtin.checkIterable(f))throw new Sk.builtin.TypeError("must assign iterable to extended slice");
d=Sk.misceval.arrayFromIterable(f);if(h.length!==d.length)throw new Sk.builtin.ValueError("attempt to assign sequence of size "+d.length+" to extended slice of size "+h.length);for(f=0;f<h.length;f++)this.v.splice(h[f],1,d[f])},del$subscript(d){if(Sk.misceval.isIndex(d))this.del$index(d);else if(d instanceof Sk.builtin.slice){const {start:f,stop:h,step:p}=d.slice$indices(this.v.length);1===p?this.del$slice(f,h):this.del$ext_slice(d,0<p?1:0)}else throw new Sk.builtin.TypeError("list indices must be integers, not "+
Sk.abstr.typeName(d));},del$index(d){d=Sk.misceval.asIndexSized(d,Sk.builtin.IndexError);d=this.list$inRange(d,"list assignment index out of range");this.v.splice(d,1)},del$slice(d,f){this.v.splice(d,f-d)},del$ext_slice(d,f){let h=0;d.sssiter$(this.v.length,p=>{this.v.splice(p-h,1);h+=f})},valueOf(){return this.v}}});Sk.exportSymbol("Sk.builtin.list",Sk.builtin.list);Sk.builtin.list.py2$methods={sort:{$name:"sort",$meth(d,f){const [h,p,g]=Sk.abstr.copyKeywordsToNamedArgs("sort",["cmp","key","reverse"],
d,f,[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.bool.false$]);return this.list$sort(h,p,g)},$flags:{FastCall:!0},$textsig:"($self, cmp=None, key=None, reverse=False)",$doc:"Stable sort *IN PLACE*."}};var b=Sk.abstr.buildIteratorClass("list_iterator",{constructor:function(d){this.$index=0;this.$seq=d.v},iternext:Sk.generic.iterNextWithArray,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}}),e=Sk.abstr.buildIteratorClass("list_reverseiterator",
{constructor:function(d){this.$index=d.v.length-1;this.$seq=d.v},iternext(){const d=this.$seq[this.$index--];if(void 0===d)this.tp$iternext=()=>{};else return d},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef},flags:{sk$unacceptableBase:!0}})},function(F,P,b){function e(E){var H=E.replace(v,"").replace(B,"_").toLowerCase();H=x[H];return void 0===H?E:H}function d(E,H,y){if(void 0===H)H="utf-8";else if(Sk.builtin.checkString(H))H=H.$jsstr();else throw new Sk.builtin.TypeError(E+
"() argument "+("bytesstr".includes(E)?2:1)+" must be str not "+Sk.abstr.typeName(H));if(void 0===y)y="strict";else if(Sk.builtin.checkString(y))y=y.$jsstr();else throw new Sk.builtin.TypeError(E+"() argument "+("bytesstr".includes(E)?3:2)+" must be str not "+Sk.abstr.typeName(y));return{encoding:H,errors:y}}function f(E,H,y){E=E.$jsstr();H=e(H);if("strict"!==y&&"ignore"!==y&&"replace"!==y)throw new Sk.builtin.NotImplementedError("'"+y+"' error handling not implemented in Skulpt");if("ascii"===H){H=
[];for(A in E){const J=E.charCodeAt(A);if(127<J){if("strict"===y)throw y=h(J),new Sk.builtin.UnicodeEncodeError("'ascii' codec can't encode character '"+y+"' in position "+A+": ordinal not in range(128)");"replace"===y&&H.push(63)}else H.push(J)}var A=new Uint8Array(H)}else if("utf-8"===H)A=I.encode(E);else throw new Sk.builtin.LookupError("unknown encoding: "+H);return new Sk.builtin.bytes(A)}function h(E){var H=265>=E?"\\x":"\\u";E=E.toString(16);3===E.length&&(E=E.slice(1,3));return E=1===E.length?
H+"0"+E:H+E}function p(E,H){({encoding:E,errors:H}=d("decode",E,H));E=e(E);if("strict"!==H&&"ignore"!==H&&"replace"!==H)throw new Sk.builtin.NotImplementedError("'"+H+"' error handling not implemented in Skulpt");if("ascii"===E){E=this.v;var y="";for(let A=0;A<E.length;A++){const J=E[A];if(127<J){if("strict"===H)throw new Sk.builtin.UnicodeDecodeError("'ascii' codec can't decode byte 0x"+J.toString(16)+" in position "+A+": ordinal not in range(128)");"replace"===H&&(y+=String.fromCharCode(65533))}else y+=
String.fromCharCode(J)}E=y}else if("utf-8"===E)a:if(E=this.v,y=H,H=M.decode(E),"replace"===y)E=H;else{if("strict"===y){y=H.indexOf("\ufffd");if(-1===y){E=H;break a}throw new Sk.builtin.UnicodeDecodeError("'utf-8' codec can't decode byte 0x"+E[y].toString(16)+" in position "+y+": invalid start byte");}E=H.replace(/\ufffd/g,"")}else throw new Sk.builtin.LookupError("unknown encoding: "+E);return new Sk.builtin.str(E)}function g(E,H){return function(y,A,J){if(!(y instanceof Sk.builtin.bytes||y instanceof
Sk.builtin.tuple))throw new Sk.builtin.TypeError(E+" first arg must be bytes or a tuple of bytes, not "+Sk.abstr.typeName(y));({start:A,end:J}=Sk.builtin.slice.startEnd$wrt(this,A,J));if(J<A)return Sk.builtin.bool.false$;A=this.v.subarray(A,J);if(y instanceof Sk.builtin.tuple){for(let Q=Sk.abstr.iter(y),X=Q.tp$iternext();void 0!==X;X=Q.tp$iternext())if(X=this.get$raw(X),H(A,X))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$}return H(A,y.v)?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}
function a(E){return function(H,y,A){H=this.get$tgt(H);({start:y,end:A}=Sk.builtin.slice.startEnd$wrt(this,y,A));return A<y?-1:"number"===typeof H?(H=E?this.v.lastIndexOf(H,A-1):this.v.indexOf(H,y),H>=y&&H<A?H:-1):E?this.find$subright(H,y,A):this.find$subleft(H,y,A)}}function c(E){return function(H){H=this.get$raw(H);let y;if(E){if(y=this.find$subright(H,0,this.v.length),0>y)return new Sk.builtin.tuple([new Sk.builtin.bytes,new Sk.builtin.bytes,this])}else if(y=this.find$subleft(H,0,this.v.length),
0>y)return new Sk.builtin.tuple([this,new Sk.builtin.bytes,new Sk.builtin.bytes]);return new Sk.builtin.tuple([new Sk.builtin.bytes(this.v.subarray(0,y)),new Sk.builtin.bytes(H),new Sk.builtin.bytes(this.v.subarray(y+H.length))])}}function n(E,H){return function(y){var A=void 0===y||y===Sk.builtin.none.none$?new Uint8Array([9,10,11,12,13,32,133]):this.get$raw(y);y=0;var J=this.v.length;if(E)for(;y<J&&A.includes(this.v[y]);)y++;if(H)for(;J>y&&A.includes(this.v[J-1]);)J--;A=new Uint8Array(J-y);for(J=
0;J<A.length;J++)A[J]=this.v[J+y];return new Sk.builtin.bytes(A)}}function m(E,H,y){return function(A,J){if(void 0===J)J=32;else if(J instanceof Sk.builtin.bytes&&1==J.v.length)J=J.v[0];else throw new Sk.builtin.TypeError(E+"() argument 2 must be a byte string of length 1, not "+Sk.abstr.typeName(J));const Q=this.v.length;A=Sk.misceval.asIndexSized(A,Sk.builtin.OverflowError);if(A<=Q)return new Sk.builtin.bytes(this.v);const X=new Uint8Array(A);let aa,ea;y?(aa=Math.floor((A-Q)/2),ea=(A-Q)%2?aa+1:
aa):H?(aa=A-Q,ea=0):(aa=0,ea=A-Q);X.fill(J,0,aa);for(let na=0;na<Q;na++)X[na+aa]=this.v[na];X.fill(J,A-ea);return new Sk.builtin.bytes(X)}}function k(E){return 9<=E&&13>=E||32===E}function u(E){return 97<=E&&122>=E}function l(E){return 65<=E&&90>=E}function q(E){return 48<=E&&57>=E}function z(E,H){return function(){return 0===this.v.length?H?Sk.builtin.bool.true$:Sk.builtin.bool.false$:this.v.every(y=>E(y))?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function r(E,H){return function(){let y=!1;for(let A=
0;A<this.v.length;A++){if(H(this.v[A]))return Sk.builtin.bool.false$;!y&&E(this.v[A])&&(y=!0)}return y?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function t(E){return function(){const H=new Uint8Array(this.v.length);for(let y=0;y<this.v.length;y++)H[y]=E(this.v[y]);return new Sk.builtin.bytes(H)}}b(30);const x={utf:"utf-8",utf8:"utf-8",utf_8:"utf-8",ascii:"ascii"};var v=/\s+/g,B=/[_-]+/g;const I=new TextEncoder,M=new TextDecoder;Sk.builtin.bytes=Sk.abstr.buildNativeClass("bytes",{constructor:function(E){if(!(this instanceof
Sk.builtin.bytes))throw new TypeError("bytes is a constructor use 'new'");if(void 0===E)this.v=new Uint8Array;else if(E instanceof Uint8Array)this.v=E;else if(Array.isArray(E))Sk.asserts.assert(E.every(H=>0<=H&&255>=H),"bad internal call to bytes with array"),this.v=new Uint8Array(E);else if("string"===typeof E){let H;const y=new Uint8Array(E.length),A=E.length;for(let J=0;J<A;J++){H=E.charCodeAt(J);if(255<H)throw new Sk.builtin.UnicodeDecodeError("invalid string at index "+J+" (possibly contains a unicode character)");
y[J]=H}this.v=y}else if("number"===typeof E)this.v=new Uint8Array(E);else throw new TypeError(`bad internal argument to bytes constructor (got '${typeof E}': ${E})`);},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
tp$new(E,H){if(this!==Sk.builtin.bytes.prototype)return this.$subtype_new(E,H);H=H||[];let y;if(1>=E.length&&0===+H.length)E=E[0];else{[E,H,y]=Sk.abstr.copyKeywordsToNamedArgs("bytes",[null,"pySource","errors"],E,H);({encoding:H,errors:y}=d("bytes",H,y));if(!Sk.builtin.checkString(E))throw new Sk.builtin.TypeError("encoding or errors without a string argument");return f(E,H,y)}if(void 0===E)return new Sk.builtin.bytes;if(void 0!==(H=Sk.abstr.lookupSpecial(E,Sk.builtin.str.$bytes)))return E=Sk.misceval.callsimOrSuspendArray(H,
[]),Sk.misceval.chain(E,A=>{if(!Sk.builtin.checkBytes(A))throw new Sk.builtin.TypeError("__bytes__ returned non-bytes (type "+Sk.abstr.typeName(A)+")");return A});if(Sk.misceval.isIndex(E)){E=Sk.misceval.asIndexSized(E,Sk.builtin.OverflowError);if(0>E)throw new Sk.builtin.ValueError("negative count");return new Sk.builtin.bytes(E)}if(Sk.builtin.checkBytes(E))return new Sk.builtin.bytes(E.v);if(Sk.builtin.checkString(E))throw new Sk.builtin.TypeError("string argument without an encoding");if(Sk.builtin.checkIterable(E)){let A=
[];E=Sk.misceval.iterFor(Sk.abstr.iter(E),J=>{J=Sk.misceval.asIndexSized(J);if(0>J||255<J)throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");A.push(J)});return Sk.misceval.chain(E,()=>new Sk.builtin.bytes(A))}throw new Sk.builtin.TypeError("cannot convert '"+Sk.abstr.typeName(E)+"' object into bytes");},$r(){let E,H="'";const y=-1!==this.v.indexOf(34);let A="";for(let J=0;J<this.v.length;J++)if(E=this.v[J],9>E||10<E&&13>E||13<E&&32>E||126<E)A+=h(E);else if(9===E||10===E||13===E||39===
E||92===E)switch(E){case 9:A+="\\t";break;case 10:A+="\\n";break;case 13:A+="\\r";break;case 39:y?A+="\\'":(A+="'",H='"');break;case 92:A+="\\\\"}else A+=String.fromCharCode(E);return new Sk.builtin.str("b"+H+A+H)},tp$str(){return this.$r()},tp$iter(){return new S(this)},tp$richcompare(E,H){if(this===E&&Sk.misceval.opAllowsEquality(H))return!0;if(!(E instanceof Sk.builtin.bytes))return Sk.builtin.NotImplemented.NotImplemented$;const y=this.v;E=E.v;if(y.length!==E.length&&("Eq"===H||"NotEq"===H))return"Eq"===
H?!1:!0;let A;const J=Math.min(y.length,E.length);for(A=0;A<J&&y[A]===E[A];A++);switch(H){case "Lt":return A===J&&y.length<E.length||y[A]<E[A];case "LtE":return A===J&&y.length<=E.length||y[A]<=E[A];case "Eq":return A===J;case "NotEq":return A<J;case "Gt":return A===J&&y.length>E.length||y[A]>E[A];case "GtE":return A===J&&y.length>=E.length||y[A]>=E[A]}},tp$hash(){return(new Sk.builtin.str(this.$jsstr())).tp$hash()},tp$as_sequence_or_mapping:!0,mp$subscript(E){if(Sk.misceval.isIndex(E)){let H=Sk.misceval.asIndexSized(E,
Sk.builtin.IndexError);if(void 0!==H){0>H&&(H=this.v.length+H);if(0>H||H>=this.v.length)throw new Sk.builtin.IndexError("index out of range");return new Sk.builtin.int_(this.v[H])}}else if(E instanceof Sk.builtin.slice){const H=[];E.sssiter$(this.v.length,y=>{H.push(this.v[y])});return new Sk.builtin.bytes(new Uint8Array(H))}throw new Sk.builtin.TypeError("byte indices must be integers or slices, not "+Sk.abstr.typeName(E));},sq$length(){return this.v.length},sq$concat(E){if(!(E instanceof Sk.builtin.bytes))throw new Sk.builtin.TypeError("can't concat "+
Sk.abstr.typeName(E)+" to bytes");const H=new Uint8Array(this.v.length+E.v.length);let y;for(y=0;y<this.v.length;y++)H[y]=this.v[y];for(let A=0;A<E.v.length;A++,y++)H[y]=E.v[A];return new Sk.builtin.bytes(H)},sq$repeat(E){if(!Sk.misceval.isIndex(E))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(E)+"'");E=Sk.misceval.asIndexSized(E,Sk.builtin.OverflowError);const H=E*this.v.length;if(H>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;if(0>=
E)return new Sk.builtin.bytes;E=new Uint8Array(H);let y=0;for(;y<H;)for(let A=0;A<this.v.length;A++)E[y++]=this.v[A];return new Sk.builtin.bytes(E)},sq$contains(E){return-1!==this.find$left(E)},tp$as_number:!0,nb$remainder:Sk.builtin.str.prototype.nb$remainder},proto:{$jsstr(){let E="";for(let H=0;H<this.v.length;H++)E+=String.fromCharCode(this.v[H]);return E},get$tgt(E){if(E instanceof Sk.builtin.bytes)return E.v;E=Sk.misceval.asIndexOrThrow(E,"argument should be integer or bytes-like object, not {tp$name}");
if(0>E||255<E)throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");return E},get$raw(E){if(E instanceof Sk.builtin.bytes)return E.v;throw new Sk.builtin.TypeError("a bytes-like object is required, not '"+Sk.abstr.typeName(E)+"'");},get$splitArgs:function(E,H){H=Sk.misceval.asIndexSized(H,Sk.builtin.OverflowError);H=0>H?Infinity:H;E=Sk.builtin.checkNone(E)?null:this.get$raw(E);if(null!==E&&!E.length)throw new Sk.builtin.ValueError("empty separator");return{sep:E,maxsplit:H}},find$left:a(!1),
find$right:a(!0),find$subleft:function(E,H,y){y=y-E.length+1;let A=H;for(;A<y;){if(E.every((J,Q)=>J===this.v[A+Q]))return A;A++}return-1},find$subright(E,H,y){let A=y-E.length;for(;A>=H;){if(E.every((J,Q)=>J===this.v[A+Q]))return A;A--}return-1},$subtype_new(E,H){const y=new this.constructor;E=Sk.builtin.bytes.prototype.tp$new(E,H);y.v=E.v;return y},sk$asarray(){const E=[];this.v.forEach(H=>{E.push(new Sk.builtin.int_(H))});return E},valueOf(){return this.v}},flags:{str$encode:f,$decode:p,check$encodeArgs:d},
methods:{__getnewargs__:{$meth(){return new Sk.builtin.tuple(new Sk.builtin.bytes(this.v))},$flags:{NoArgs:!0},$textsig:null,$doc:null},capitalize:{$meth(){const E=this.v.length;if(0===E)return new Sk.builtin.bytes(this.v);const H=new Uint8Array(E);let y=this.v[0];H[0]=u(y)?y-32:y;for(let A=1;A<E;A++)y=this.v[A],H[A]=l(y)?y+32:y;return new Sk.builtin.bytes(H)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased."},
center:{$meth:m("center",!1,!0),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.center(width[, fillchar]) -> copy of B\n\nReturn B centered in a string of length width.  Padding is\ndone using the specified fill character (default is a space)."},count:{$meth(E,H,y){E=this.get$tgt(E);({start:H,end:y}=Sk.builtin.slice.startEnd$wrt(this,H,y));let A=0;if("number"===typeof E)for(;H<y;H++)this.v[H]===E&&A++;else{y=y-E.length+1;for(let J=H;J<y;J++)E.every((Q,X)=>Q===this.v[J+X])&&(A++,J+=E.length-1)}return new Sk.builtin.int_(A)},
$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of subsection sub in\nbytes B[start:end].  Optional arguments start and end are interpreted\nas in slice notation."},decode:{$meth:p,$flags:{NamedArgs:["encoding","errors"]},$textsig:"($self, /, encoding='utf-8', errors='strict')",$doc:"Decode the bytes using the codec registered for encoding.\n\n  encoding\n    The encoding with which to decode the bytes.\n  errors\n    The error handling scheme to use for the handling of decoding errors.\n    The default is 'strict' meaning that decoding errors raise a\n    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n    as well as any other name registered with codecs.register_error that\n    can handle UnicodeDecodeErrors."},
endswith:{$meth:g("endswith",(E,H)=>{const y=E.length-H.length;return 0<=y&&H.every((A,J)=>A===E[y+J])}),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if B ends with the specified suffix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nsuffix can also be a tuple of bytes to try."},expandtabs:{$meth(E){E=Sk.misceval.asIndexSized(E,Sk.builtin.OverflowError,"an integer is required (got type {tp$nam})");
const H=[];let y=0;for(let J=0;J<this.v.length;J++){var A=this.v[J];9===A?(A=E-y%E,H.push(...Array(A).fill(32)),y+=A):10===A||13===A?(H.push(A),y=0):(H.push(A),y++)}return new Sk.builtin.bytes(new Uint8Array(H))},$flags:{NamedArgs:["tabsize"],Defaults:[8]},$textsig:null,$doc:"B.expandtabs(tabsize=8) -> copy of B\n\nReturn a copy of B where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed."},find:{$meth:function(E,H,y){return new Sk.builtin.int_(this.find$left(E,
H,y))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},hex:{$meth(){let E="";for(let H=0;H<this.v.length;H++)E+=this.v[H].toString(16).padStart(2,"0");return new Sk.builtin.str(E)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.hex() -> string\n\nCreate a string of hexadecimal numbers from a bytes object.\nExample: b'\\xb9\\x01\\xef'.hex() -> 'b901ef'."},
index:{$meth:function(E,H,y){E=this.find$left(E,H,y);if(-1===E)throw new Sk.builtin.ValueError("subsection not found");return new Sk.builtin.int_(E)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the subsection is not found."},isalnum:{$meth:z(E=>q(E)||
u(E)||l(E)),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise."},isalpha:{$meth:z(E=>65<=E&&90>=E||97<=E&&122>=E),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise."},isascii:{$meth:z(E=>0<=E&&127>=E,!0),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise."},
isdigit:{$meth:z(q),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise."},islower:{$meth:r(u,l),$flags:{NoArgs:!0},$textsig:null,$doc:"B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise."},isspace:{$meth:z(k),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise."},
istitle:{$meth:function(){let E=!1,H=!1;for(let y=0;y<this.v.length;y++){const A=this.v[y];if(l(A)){if(E)return Sk.builtin.bool.false$;H=E=!0}else if(u(A)){if(!E)return Sk.builtin.bool.false$;H=!0}else E=!1}return H?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{NoArgs:!0},$textsig:null,$doc:"B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise."},
isupper:{$meth:r(l,u),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise."},join:{$meth(E){const H=[];let y=0;return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(E),A=>{if(!(A instanceof Sk.builtin.bytes))throw new Sk.builtin.TypeError("sequence item "+y+": expected a bytes-like object, "+Sk.abstr.typeName(A)+" found");y++;H.length&&H.push(...this.v);H.push(...A.v)}),
()=>new Sk.builtin.bytes(new Uint8Array(H)))},$flags:{OneArg:!0},$textsig:"($self, iterable_of_bytes, /)",$doc:"Concatenate any number of bytes objects.\n\nThe bytes whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytes object.\n\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'."},ljust:{$meth:m("ljust",!1,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.ljust(width[, fillchar]) -> copy of B\n\nReturn B left justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)."},
lower:{$meth:t(E=>l(E)?E+32:E),$flags:{NoArgs:!0},$textsig:null,$doc:"B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase."},lstrip:{$meth:n(!0,!1),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading  ASCII whitespace."},partition:{$meth:c(!1),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects."},
replace:{$meth(E,H,y){E=this.get$raw(E);H=this.get$raw(H);y=void 0===y?-1:Sk.misceval.asIndexSized(y,Sk.builtin.OverflowError);y=0>y?Infinity:y;const A=[];let J=0;for(var Q=0;Q<this.v.length&&J<y;){const X=this.find$subleft(E,Q,this.v.length);if(-1===X)break;for(;Q<X;Q++)A.push(this.v[Q]);A.push(...H);Q=X+E.length;J++}for(Q;Q<this.v.length;Q++)A.push(this.v[Q]);return new Sk.builtin.bytes(new Uint8Array(A))},$flags:{MinArgs:2,MaxArgs:3},$textsig:"($self, old, new, count=-1, /)",$doc:"Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."},
rfind:{$meth(E,H,y){return new Sk.builtin.int_(this.find$right(E,H,y))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},rindex:{$meth:function(E,H,y){E=this.find$right(E,H,y);if(-1===E)throw new Sk.builtin.ValueError("subsection not found");return new Sk.builtin.int_(E)},
$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaise ValueError when the subsection is not found."},rjust:{$meth:m("rjust",!0,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.rjust(width[, fillchar]) -> copy of B\n\nReturn B right justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)"},
rpartition:{$meth:c(!0),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object."},rsplit:{$meth:function(E,H){({sep:E,
maxsplit:H}=this.get$splitArgs(E,H));const y=[];let A=0,J=this.v.length;if(null!==E){for(;0<=J&&A<H;){const Q=this.find$subright(E,0,J);if(-1===Q)break;y.push(new Sk.builtin.bytes(this.v.subarray(Q+E.length,J)));J=Q;A++}y.push(new Sk.builtin.bytes(this.v.subarray(0,J)))}else{for(J--;A<H;){for(;k(this.v[J]);)J--;if(0>J)break;E=J+1;for(J--;0<=J&&!k(this.v[J]);)J--;y.push(new Sk.builtin.bytes(this.v.subarray(J+1,E)));A++}if(0<=J){for(;k(this.v[J]);)J--;0<=J&&y.push(new Sk.builtin.bytes(this.v.subarray(0,
J+1)))}}return new Sk.builtin.list(y.reverse())},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytes and working to the front."},
rstrip:{$meth:n(!1,!0),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace."},split:{$meth:function(E,H){({sep:E,maxsplit:H}=this.get$splitArgs(E,H));const y=[],A=this.v.length;let J=0,Q=0;if(null!==E){for(;Q<A&&J<H;){const X=this.find$subleft(E,Q,A);if(-1===X)break;y.push(new Sk.builtin.bytes(this.v.subarray(Q,X)));Q=X+E.length;J++}y.push(new Sk.builtin.bytes(this.v.subarray(Q,
A)))}else{for(;J<H;){for(;k(this.v[Q]);)Q++;if(Q===A)break;E=Q;for(Q++;Q<A&&!k(this.v[Q]);)Q++;y.push(new Sk.builtin.bytes(this.v.subarray(E,Q)));J++}if(Q<A){for(;k(this.v[Q]);)Q++;Q<A&&y.push(new Sk.builtin.bytes(this.v.subarray(Q,A)))}}return new Sk.builtin.list(y)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."},
splitlines:{$meth(E){E=Sk.misceval.isTrue(E);const H=[];let y=0;let A=0;const J=this.v.length;for(;A<J;){var Q=this.v[A];if(13===Q){const X=10===this.v[A+1];Q=E?X?A+2:A+1:A;H.push(new Sk.builtin.bytes(this.v.subarray(y,Q)));A=y=X?A+2:A+1}else 10===Q?(Q=E?A+1:A,H.push(new Sk.builtin.bytes(this.v.subarray(y,Q))),A=y=A+1):A++}y<J&&H.push(new Sk.builtin.bytes(this.v.subarray(y,J)));return new Sk.builtin.list(H)},$flags:{NamedArgs:["keepends"],Defaults:[!1]},$textsig:"($self, /, keepends=False)",$doc:"Return a list of the lines in the bytes, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."},
startswith:{$meth:g("startswith",(E,H)=>H.length<=E.length&&H.every((y,A)=>y===E[A])),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if B starts with the specified prefix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nprefix can also be a tuple of bytes to try."},strip:{$meth:n(!0,!0),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace."},
swapcase:{$meth:t(E=>l(E)?E+32:u(E)?E-32:E),$flags:{NoArgs:!0},$textsig:null,$doc:"B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa."},title:{$meth(){const E=this.v.length,H=new Uint8Array(E);let y=!1;for(let A=0;A<E;A++){const J=this.v[A];l(J)?(H[A]=y?J+32:J,y=!0):u(J)?(H[A]=y?J:J-32,y=!0):(H[A]=J,y=!1)}return new Sk.builtin.bytes(H)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase."},
upper:{$meth:t(E=>u(E)?E-32:E),$flags:{NoArgs:!0},$textsig:null,$doc:"B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase."},zfill:{$meth(E){E=Sk.misceval.asIndexSized(E,Sk.builtin.IndexError);const H=E-this.v.length;if(0>=H)return new Sk.builtin.bytes(this.v);const y=new Uint8Array(E);let A=0,J;if(43===this.v[0]||45===this.v[0])y[0]=this.v[0],A++;y.fill(48,A,A+H);J=A;for(A+=H;A<E;A++,J++)y[A]=this.v[J];return new Sk.builtin.bytes(y)},$flags:{OneArg:!0},$textsig:null,
$doc:"B.zfill(width) -> copy of B\n\nPad a numeric string B with zeros on the left, to fill a field\nof the specified width.  B is never truncated."}},classmethods:{fromhex:{$meth:function(E){function H(aa){for(let ea=Q;ea<aa;ea+=2){let na=E.substr(ea,2);if(!A.test(na))throw new Sk.builtin.ValueError("non-hexadecimal number found in fromhex() arg at position "+(ea+1));J.push(parseInt(na,16))}}if(!Sk.builtin.checkString(E))throw new Sk.builtin.TypeError("fromhex() argument must be str, not "+Sk.abstr.typeName(E));
E=E.$jsstr();const y=/\s+/g,A=/^[abcdefABCDEF0123456789]{2}$/,J=[];let Q=0,X;for(;null!==(X=y.exec(E));)H(X.index),Q=y.lastIndex;H(E.length);return new this(J)},$flags:{OneArg:!0},$textsig:"($type, string, /)",$doc:"Create a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'."}}});var S=Sk.abstr.buildIteratorClass("bytes_iterator",{constructor:function(E){this.$index=0;this.$seq=E.v},iternext(){const E=
this.$seq[this.$index++];if(void 0!==E)return new Sk.builtin.int_(E)},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}});Sk.exportSymbol("Sk.builtin.bytes",Sk.builtin.bytes)},function(F,P,b){(function(e){(function(d){function f(){}function h(){}var p=String.fromCharCode,g={}.toString,a=g.call(d.SharedArrayBuffer),c=g(),n=d.Uint8Array,m=n||Array,k=n?ArrayBuffer:m,u=k.isView||function(r){return r&&"length"in r},l=g.call(k.prototype);k=h.prototype;
var q=d.TextEncoder,z=new (n?Uint16Array:m)(32);f.prototype.decode=function(r){if(!u(r)){var t=g.call(r);if(t!==l&&t!==a&&t!==c)throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");r=n?new m(r):r||[]}for(var x=t="",v=0,B=r.length|0,I=B-32|0,M,S,E=0,H=0,y,A=0,J=-1;v<B;){for(M=v<=I?32:B-v|0;A<M;v=v+1|0,A=A+1|0){S=r[v]&255;switch(S>>4){case 15:y=r[v=v+1|0]&255;if(2!==y>>6||247<S){v=v-1|0;break}E=(S&7)<<6|y&63;H=5;S=256;case 14:y=
r[v=v+1|0]&255,E<<=6,E|=(S&15)<<6|y&63,H=2===y>>6?H+4|0:24,S=S+256&768;case 13:case 12:y=r[v=v+1|0]&255,E<<=6,E|=(S&31)<<6|y&63,H=H+7|0,v<B&&2===y>>6&&E>>H&&1114112>E?(S=E,E=E-65536|0,0<=E&&(J=(E>>10)+55296|0,S=(E&1023)+56320|0,31>A?(z[A]=J,A=A+1|0,J=-1):(y=J,J=S,S=y))):(S>>=8,v=v-S-1|0,S=65533),E=H=0,M=v<=I?32:B-v|0;default:z[A]=S;continue;case 11:case 10:case 9:case 8:}z[A]=65533}x+=p(z[0],z[1],z[2],z[3],z[4],z[5],z[6],z[7],z[8],z[9],z[10],z[11],z[12],z[13],z[14],z[15],z[16],z[17],z[18],z[19],z[20],
z[21],z[22],z[23],z[24],z[25],z[26],z[27],z[28],z[29],z[30],z[31]);32>A&&(x=x.slice(0,A-32|0));if(v<B){if(z[0]=J,A=~J>>>31,J=-1,x.length<t.length)continue}else-1!==J&&(x+=p(J));t+=x;x=""}return t};k.encode=function(r){r=void 0===r?"":""+r;var t=r.length|0,x=new m((t<<1)+8|0),v,B=0,I=!n;for(v=0;v<t;v=v+1|0,B=B+1|0){var M=r.charCodeAt(v)|0;if(127>=M)x[B]=M;else{if(2047>=M)x[B]=192|M>>6;else{a:{if(55296<=M)if(56319>=M){var S=r.charCodeAt(v=v+1|0)|0;if(56320<=S&&57343>=S){M=(M<<10)+S-56613888|0;if(65535<
M){x[B]=240|M>>18;x[B=B+1|0]=128|M>>12&63;x[B=B+1|0]=128|M>>6&63;x[B=B+1|0]=128|M&63;continue}break a}M=65533}else 57343>=M&&(M=65533);!I&&v<<1<B&&v<<1<(B-7|0)&&(I=!0,S=new m(3*t),S.set(x),x=S)}x[B]=224|M>>12;x[B=B+1|0]=128|M>>6&63}x[B=B+1|0]=128|M&63}}return n?x.subarray(0,B):x.slice(0,B)};q||(d.TextDecoder=f,d.TextEncoder=h)})("undefined"==typeof e?"undefined"==typeof self?this:self:e)}).call(this,b(0))},function(F,P){Sk.builtin.tuple=Sk.abstr.buildNativeClass("tuple",{constructor:function(e){void 0===
e?e=[]:Array.isArray(e)||(e=Sk.misceval.arrayFromIterable(e));Sk.asserts.assert(this instanceof Sk.builtin.tuple,"bad call to tuple, use 'new' with an Array of python objects");this.v=e;this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.",
$r(){if(this.in$repr)return new Sk.builtin.str("(...)");this.in$repr=!0;let e=this.v.map(d=>Sk.misceval.objectRepr(d));this.in$repr=!1;e=e.join(", ");1===this.v.length&&(e+=",");return new Sk.builtin.str("("+e+")")},tp$new(e,d){if(this!==Sk.builtin.tuple.prototype)return this.$subtype_new(e,d);Sk.abstr.checkNoKwargs("tuple",d);Sk.abstr.checkArgsLen("tuple",e,0,1);e=e[0];return void 0===e?new Sk.builtin.tuple([]):e.constructor===Sk.builtin.tuple?e:Sk.misceval.chain(Sk.misceval.arrayFromIterable(e,
!0),f=>new Sk.builtin.tuple(f))},tp$hash(){let e,d=3430008,f=1000003;const h=this.v.length;for(let p=0;p<h;++p){e=Sk.abstr.objectHash(this.v[p]);if(-1===e)return-1;d=(d^e)*f;f+=82520+h+h}d+=97531;-1===d&&(d=-2);return d|0},tp$richcompare:Sk.generic.seqCompare,tp$iter(){return new b(this)},mp$subscript(e){if(Sk.misceval.isIndex(e)){e=Sk.misceval.asIndexSized(e,Sk.builtin.IndexError);0>e&&(e=this.v.length+e);if(0>e||e>=this.v.length)throw new Sk.builtin.IndexError("tuple index out of range");return this.v[e]}if(e instanceof
Sk.builtin.slice){const d=[];e.sssiter$(this.v.length,f=>{d.push(this.v[f])});return new Sk.builtin.tuple(d)}throw new Sk.builtin.TypeError("tuple indices must be integers or slices, not "+Sk.abstr.typeName(e));},sq$length(){return this.v.length},sq$repeat(e){e=Sk.misceval.asIndexSized(e,Sk.builtin.OverflowError);if(1===e&&this.constructor===Sk.builtin.tuple)return this;const d=[];for(let f=0;f<e;f++)for(let h=0;h<this.v.length;h++)d.push(this.v[h]);return new Sk.builtin.tuple(d)},sq$concat(e){if(!(e instanceof
Sk.builtin.tuple))throw new Sk.builtin.TypeError("can only concatenate tuple (not '"+Sk.abstr.typeName(e)+"') to tuple");return new Sk.builtin.tuple(this.v.concat(e.v))},sq$contains(e){for(let d=this.tp$iter(),f=d.tp$iternext();void 0!==f;f=d.tp$iternext())if(f===e||Sk.misceval.richCompareBool(f,e,"Eq"))return!0;return!1}},proto:{$subtype_new(e,d){d=new this.constructor;e=Sk.builtin.tuple.prototype.tp$new(e);d.v=e.v;return d},sk$asarray(){return this.v.slice(0)},valueOf(){return this.v}},methods:{__getnewargs__:{$meth(){return new Sk.builtin.tuple(this.v.slice(0))},
$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:null},index:{$meth(e,d,f){if(void 0!==d&&!Sk.misceval.isIndex(d)||void 0!==f&&!Sk.misceval.isIndex(f))throw new Sk.builtin.TypeError("slice indices must be integers or have an __index__ method");({start:d,end:f}=Sk.builtin.slice.startEnd$wrt(this,d,f));const h=this.v;for(;d<f;d++)if(h[d]===e||Sk.misceval.richCompareBool(h[d],e,"Eq"))return new Sk.builtin.int_(d);throw new Sk.builtin.ValueError("tuple.index(x): x not in tuple");},$flags:{MinArgs:1,MaxArgs:3},
$textsig:"($self, value, start=0, stop=sys.maxsize, /)",$doc:"Return first index of value.\n\nRaises ValueError if the value is not present."},count:{$meth(e){const d=this.v.length,f=this.v;let h=0;for(let p=0;p<d;++p)if(f[p]===e||Sk.misceval.richCompareBool(f[p],e,"Eq"))h+=1;return new Sk.builtin.int_(h)},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Return number of occurrences of value."}},classmethods:Sk.generic.classGetItem});Sk.exportSymbol("Sk.builtin.tuple",Sk.builtin.tuple);var b=
Sk.abstr.buildIteratorClass("tuple_iterator",{constructor:function(e){this.$index=0;this.$seq=e.sk$asarray()},iternext:Sk.generic.iterNextWithArray,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}})},function(F,P){function b(r){let t=r.$savedKeyHash;return void 0!==t?t:t=Sk.abstr.objectHash(r)}function e(r){return new Sk.builtin.set(Sk.misceval.arrayFromIterable(r))}function d(r,t){for(let x=Sk.abstr.iter(r),v=x.tp$iternext();void 0!==v;v=x.tp$iternext())if(!Sk.abstr.sequenceContains(t,
v))return!1;return!0}function f(r,t,x){const v={constructor:function(B){if(1!==arguments.length)throw new Sk.builtin.TypeError("cannot create '"+Sk.abstr.typeName(this)+"' instances");this.dict=B;this.in$repr=!1}};v.slots=Object.assign(t,g);v.methods={isdisjoint:{$meth(B){const I=e(this);return I.isdisjoint.$meth.call(I,B)},$flags:{OneArg:!0},$textsig:null,$doc:"Return True if the view and the given iterable have a null intersection."},__reversed__:{$meth:x,$flags:{NoArgs:!0},$textsig:null,$doc:"Return a reverse iterator over the dict keys."}};
v.flags={sk$acceptable_as_base:!1};"dict_values"===r&&(delete v.slots.tp$as_number,delete v.slots.tp$richcompare);return Sk.abstr.buildNativeClass(r,v)}function h(r,t,x){return Sk.abstr.buildIteratorClass(r,{constructor:function(v){this.$index=0;this.$orig=v;this.tp$iternext=()=>{this.$seq=v.$items();this.$version=v.$version;x&&(this.$seq=this.$seq.reverse());this.tp$iternext=this.constructor.prototype.tp$iternext;return this.tp$iternext()}},iternext:t,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},
flags:{sk$unacceptableBase:!0},proto:{next$item:p}})}function p(){if(this.$version!==this.$orig.$version){if(this.$seq.length!==this.$orig.get$size())throw new Sk.builtin.RuntimeError("dict changed size during iteration");throw new Sk.builtin.RuntimeError("dictionary keys changed during iteration");}return this.$seq[this.$index++]}Sk.builtin.dict=Sk.abstr.buildNativeClass("dict",{constructor:function(r){void 0===r&&(r=[]);Sk.asserts.assert(Array.isArray(r)&&0===r.length%2&&this instanceof Sk.builtin.dict,
"bad call to dict constructor");this.size=0;this.entries=Object.create(null);this.buckets={};for(let t=0;t<r.length;t+=2)this.set$item(r[t],r[t+1]);this.in$repr=!1;this.$version=0},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$as_number:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
$r(){if(this.in$repr)return new Sk.builtin.str("{...}");this.in$repr=!0;const r=this.$items().map(t=>{var [x,v]=t;return Sk.misceval.objectRepr(x)+": "+Sk.misceval.objectRepr(v)});this.in$repr=!1;return new Sk.builtin.str("{"+r.join(", ")+"}")},tp$new:Sk.generic.new,tp$init(r,t){return this.update$common(r,t,"dict")},tp$iter(){return new m(this)},tp$richcompare(r,t){let x;if(!(r instanceof Sk.builtin.dict)||"Eq"!==t&&"NotEq"!==t)return Sk.builtin.NotImplemented.NotImplemented$;if(r===this)x=!0;else if(this.size!==
r.size)x=!1;else{let v;x=this.$items().every(B=>{var [I,M]=B;v=r.mp$lookup(I);return void 0!==v&&(v===M||Sk.misceval.richCompareBool(M,v,"Eq"))})}return"Eq"===t?x:!x},nb$or(r){if(!(r instanceof Sk.builtin.dict))return Sk.builtin.NotImplemented.NotImplemented$;const t=this.dict$copy();t.dict$merge(r);return t},nb$reflected_or(r){if(!(r instanceof Sk.builtin.dict))return Sk.builtin.NotImplemented.NotImplemented$;r=r.dict$copy();r.dict$merge(this);return r},nb$inplace_or(r){return Sk.misceval.chain(this.update$onearg(r),
()=>this)},sq$length(){return this.get$size()},sq$contains(r){return void 0!==this.mp$lookup(r)},mp$subscript(r,t){var x=this.mp$lookup(r);if(void 0!==x)return x;x=Sk.abstr.lookupSpecial(this,Sk.builtin.str.$missing);if(void 0!==x)return r=Sk.misceval.callsimOrSuspendArray(x,[r]),t?r:Sk.misceval.retryOptionalSuspensionOrThrow(r);throw new Sk.builtin.KeyError(r);},mp$ass_subscript(r,t){if(void 0===t){if(void 0===this.pop$item(r))throw new Sk.builtin.KeyError(r);}else this.set$item(r,t)}},methods:{__reversed__:{$meth(){return new l(this)},
$flags:{NoArgs:!0},$textsig:null,$doc:"Return a reverse iterator over the dict keys."},get:{$meth(r,t){return this.mp$lookup(r)||t||Sk.builtin.none.none$},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, key, default=None, /)",$doc:"Return the value for key if key is in the dictionary, else default."},setdefault:{$meth(r,t){let x;const v=b(r);x="string"===typeof v?this.entries[v]:this.get$bucket_item(r,v);if(void 0!==x)return x[1];t=t||Sk.builtin.none.none$;"string"===typeof v?this.entries[v]=[r,t]:
this.set$bucket_item(r,t,v);this.size++;this.$version++;return t},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, key, default=None, /)",$doc:"Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default."},pop:{$meth(r,t){const x=this.pop$item(r);if(void 0!==x)return x[1];if(void 0!==t)return t;throw new Sk.builtin.KeyError(r);},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised"},
popitem:{$meth(){const r=this.get$size();if(0===r)throw new Sk.builtin.KeyError("popitem(): dictionary is empty");const [t,x]=this.$items()[r-1];this.pop$item(t);return new Sk.builtin.tuple([t,x])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.popitem() -> (k, v), remove and return some (key, value) pair as a\n2-tuple; but raise KeyError if D is empty."},keys:{$meth(){return new a(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$meth(){return new n(this)},
$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$meth(){return new c(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> an object providing a view on D's values"},update:{$meth(r,t){return Sk.misceval.chain(this.update$common(r,t,"update"),()=>Sk.builtin.none.none$)},$flags:{FastCall:!0},$textsig:null,$doc:"D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]"},
clear:{$meth(){this.size=0;this.$version++;this.entries=Object.create(null);this.buckets={}},$flags:{NoArgs:!0},$textsig:null,$doc:"D.clear() -> None.  Remove all items from D."},copy:{$meth(){return this.dict$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"D.copy() -> a shallow copy of D"}},classmethods:Object.assign({fromkeys:{$meth:function(r,t){t=t||Sk.builtin.none.none$;let x=this===Sk.builtin.dict?new this:this.tp$call([],[]);return Sk.misceval.chain(x,v=>{x=v;return Sk.misceval.iterFor(Sk.abstr.iter(r),
B=>x.mp$ass_subscript(B,t,!0))},()=>x)},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($type, iterable, value=None, /)",$doc:"Create a new dictionary with keys from iterable and values set to value."}},Sk.generic.classGetItem),proto:{quick$lookup:function(r){r=this.entries[r.$savedKeyHash];if(void 0!==r)return r[1]},mp$lookup:function(r){const t=b(r);r="string"===typeof t?this.entries[t]:this.get$bucket_item(r,t);if(void 0!==r)return r[1]},get$size(){return this.size},sk$asarray(){return Object.values(this.entries).map(r=>
r[0])},update$common:function(r,t,x){Sk.abstr.checkArgsLen(x,r,0,1);r=r[0];let v;void 0!==r&&(v=this.update$onearg(r));return Sk.misceval.chain(v,()=>{if(t)for(let B=0;B<t.length;B+=2)this.set$item(new Sk.builtin.str(t[B]),t[B+1])})},update$onearg(r){return r instanceof Sk.builtin.dict||void 0!==Sk.abstr.lookupSpecial(r,Sk.builtin.str.$keys)?this.dict$merge(r):this.dict$merge_seq(r)},dict$copy(){const r=new Sk.builtin.dict([]);r.size=this.size;var t=Object.entries(this.entries);for(var x in t){var v=
t[x][1];r.entries[t[x][0]]=[v[0],v[1]]}for(let B in this.buckets)for(x=this.buckets[B],r.buckets[B]=t=[],v=0;v<x.length;v++)t.push(r.entries["#"+B+"_"+v]);return r},$items(){return Object.values(this.entries)},set$item:function(r,t){const x=b(r);let v;"string"===typeof x?(v=this.entries[x],void 0===v?(this.entries[x]=[r,t],this.size++,this.$version++):v[1]=t):(v=this.get$bucket_item(r,x),void 0===v?(this.set$bucket_item(r,t,x),this.size++,this.$version++):v[1]=t)},get$bucket_item:function(r,t){t=
this.buckets[t];if(void 0!==t)for(let v=0;v<t.length;v++){var x=t[v];if(void 0!==x&&(x[0]===r||Sk.misceval.richCompareBool(r,x[0],"Eq")))return x}},pop$bucket_item:function(r,t){const x=this.buckets[t];let v;if(void 0!==x)for(let B=0;B<x.length;B++)if(v=x[B],void 0!==v&&(v[0]===r||Sk.misceval.richCompareBool(r,v[0],"Eq")))return delete this.entries["#"+t+"_"+B],x[B]=void 0,x.every(I=>void 0===I)&&delete this.buckets[t],v},set$bucket_item:function(r,t,x){let v=this.buckets[x];r=[r,t];void 0===v?(this.buckets[x]=
[r],x="#"+x+"_0"):(t=v.indexOf(void 0),-1!==t?(x="#"+x+"_"+t,v[t]=r):(x="#"+x+"_"+v.length,v.push(r)));this.entries[x]=r},pop$item:function(r){const t=b(r);"string"===typeof t?(r=this.entries[t],delete this.entries[t]):r=this.pop$bucket_item(r,t);if(void 0!==r)return this.size--,this.$version++,r},dict$merge:function(r){if(r.tp$iter===Sk.builtin.dict.prototype.tp$iter){var t=r.tp$iter();for(let x=t.tp$iternext();void 0!==x;x=t.tp$iternext()){const v=r.mp$subscript(x);this.set$item(x,v)}}else{t=Sk.abstr.lookupSpecial(r,
Sk.builtin.str.$keys);if(void 0===t)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(r)+"' object is not a mapping");return Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(t),x=>Sk.misceval.iterFor(Sk.abstr.iter(x),v=>Sk.misceval.chain(Sk.abstr.objectGetItem(r,v,!0),B=>{this.set$item(v,B)})))}},dict$merge_seq:function(r){let t=0;return Sk.misceval.iterFor(Sk.abstr.iter(r),x=>{if(!Sk.builtin.checkIterable(x))throw new Sk.builtin.TypeError("cannot convert dictionary update sequence element #"+
t+" to a sequence");x=Sk.misceval.arrayFromIterable(x);if(2!==x.length)throw new Sk.builtin.ValueError("dictionary update sequence element #"+t+" has length "+x.length+"; 2 is required");this.set$item(x[0],x[1]);t++})}}});const g={tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,$r(){if(this.in$repr)return new Sk.builtin.str("...");this.in$repr=!0;let r=Sk.misceval.arrayFromIterable(this);r=r.map(t=>Sk.misceval.objectRepr(t));this.in$repr=!1;
return new Sk.builtin.str(Sk.abstr.typeName(this)+"(["+r.join(", ")+"])")},tp$richcompare(r,t){if(!(Sk.builtin.checkAnySet(r)||r instanceof a||r instanceof n))return Sk.builtin.NotImplemented.NotImplemented$;const x=this.sq$length(),v=r.sq$length();switch(t){case "NotEq":case "Eq":let B;this===r?B=!0:x===v&&(B=d(this,r));return"NotEq"===t?!B:B;case "Lt":return x<v&&d(this,r);case "LtE":return x<=v&&d(this,r);case "Gt":return x>v&&d(r,this);case "GtE":return x>=v&&d(r,this)}},nb$subtract(r){const t=
e(this);return t.difference.$meth.call(t,r)},nb$and(r){const t=e(this);return t.intersection.$meth.call(t,r)},nb$or(r){const t=e(this);return t.union.$meth.call(t,r)},nb$xor(r){const t=e(this);return t.symmetric_difference.$meth.call(t,r)},sq$length(){return this.dict.get$size()}};var a=f("dict_keys",{sq$contains(r){return void 0!==this.dict.mp$lookup(r)},tp$iter(){return new m(this.dict)}},function(){return new l(this.dict)}),c=f("dict_values",{tp$iter(){return new u(this.dict)}},function(){return new z(this.dict)}),
n=f("dict_items",{sq$contains(r){if(!(r instanceof Sk.builtin.tuple&&2===r.sq$length()))return!1;var t=r.mp$subscript(new Sk.builtin.int_(0));r=r.mp$subscript(new Sk.builtin.int_(1));t=this.dict.mp$lookup(t);return void 0===t?!1:t===r||Sk.misceval.richCompareBool(t,r,"Eq")},tp$iter(){return new k(this.dict)}},function(){return new q(this.dict)}),m=h("dict_keyiterator",function(){const r=this.next$item();return r&&r[0]}),k=h("dict_itemiterator",function(){const r=this.next$item();return r&&new Sk.builtin.tuple([r[0],
r[1]])}),u=h("dict_valueiterator",function(){const r=this.next$item();return r&&r[1]}),l=h("dict_reversekeyiterator",m.prototype.tp$iternext,!0),q=h("dict_reverseitemiterator",k.prototype.tp$iternext,!0),z=h("dict_reversevalueiterator",u.prototype.tp$iternext,!0);Sk.builtin.dict.py2$methods={has_key:{$name:"has_key",$flags:{OneArg:!0},$meth(r){return new Sk.builtin.bool(this.sq$contains(r))},$doc:"D.has_key(k) -> True if D has a key k, else False"},keys:{$name:"keys",$meth(){return new Sk.builtin.list(this.sk$asarray())},
$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$name:"items",$meth(){return new Sk.builtin.list(this.$items().map(r=>{var [t,x]=r;return new Sk.builtin.tuple([t,x])}))},$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$name:"values",$meth(){return new Sk.builtin.list(this.$items().map(r=>{[,r]=r;return r}))},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> an object providing a view on D's values"}}},
function(F,P){function b(e,d){Object.defineProperties(e,{entries:{get:()=>{const f=Object.create(null);Object.entries(d).forEach(h=>{var [p,g]=h;p=Sk.unfixReserved(p);p.includes("$")||(p=new Sk.builtin.str(p),f[p.$savedKeyHash]=[p,g])});return f},configurable:!0},size:{get:()=>Object.keys(d).map(f=>Sk.unfixReserved(f)).filter(f=>!f.includes("$")).length,configurable:!0}})}Sk.builtin.mappingproxy=Sk.abstr.buildNativeClass("mappingproxy",{constructor:function(e){Sk.asserts.assert(this instanceof Sk.builtin.mappingproxy,
"bad call to mapping proxy, use 'new'");if(void 0!==e){const d=e.constructor;d===Object||null===d||e.hasOwnProperty("sk$object")?(this.mapping=new Sk.builtin.dict([]),b(this.mapping,e)):Sk.builtin.checkMapping(e)?this.mapping=e:Sk.asserts.fail("unhandled case for mappingproxy")}},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$new(e,d){Sk.abstr.checkNoKwargs("mappingproxy",d);Sk.abstr.checkOneArg("mappingproxy",e,d);e=e[0];if(!Sk.builtin.checkMapping(e))throw new Sk.builtin.TypeError("mappingproxy() argument must be a mapping, not "+
Sk.abstr.typeName(e));d=new Sk.builtin.mappingproxy;d.mapping=e;return d},tp$richcompare(e,d){return Sk.misceval.richCompareBool(this.mapping,e,d)},tp$str(){return this.mapping.tp$str()},$r(){return new Sk.builtin.str("mappingproxy("+Sk.misceval.objectRepr(this.mapping)+")")},mp$subscript(e,d){return this.mapping.mp$subscript(e,d)},sq$contains(e){return this.mapping.sq$contains(e)},sq$length(){return this.mapping.sq$length()},tp$iter(){return this.mapping.tp$iter()},tp$as_number:!0,nb$or(e){e instanceof
Sk.builtin.mappingproxy&&(e=e.mapping);return Sk.abstr.numberBinOp(this.mapping,e,"BitOr")},nb$reflected_or(e){e instanceof Sk.builtin.mappingproxy&&(e=e.mapping);return Sk.abstr.numberBinOp(e,this.mapping,"BitOr")},nb$inplace_or(e){throw new Sk.builtin.TypeError("'|=' is not supported by "+Sk.abstr.typeName(this)+"; use '|' instead");}},methods:{get:{$meth(e,d){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$get),e,d)},$flags:{FastCall:!0},$textsig:null,$doc:"D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."},
keys:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$keys),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$items),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$values),[])},$flags:{NoArgs:!0},$textsig:null,
$doc:"D.values() -> a set-like object providing a view on D's values"},copy:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$copy),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.copy() -> a shallow copy of D"}},classmethods:Sk.generic.classGetItem,proto:{str$get:new Sk.builtin.str("get"),str$copy:new Sk.builtin.str("copy"),str$keys:new Sk.builtin.str("keys"),str$items:new Sk.builtin.str("items"),str$values:new Sk.builtin.str("values"),mp$lookup(e){return this.mapping.mp$lookup(e)}},
flags:{sk$unacceptableBase:!0}})},function(F,P){Sk.builtin.property=Sk.abstr.buildNativeClass("property",{constructor:function(b,e,d,f){this.prop$get=b||Sk.builtin.none.none$;this.prop$set=e||Sk.builtin.none.none$;this.prop$del=d||Sk.builtin.none.none$;this.prop$doc=f||b&&b.$doc||Sk.builtin.none.none$},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,tp$init(b,e){b=Sk.abstr.copyKeywordsToNamedArgs("property",["fget","fset","fdel","doc"],b,e,Array(4).fill(Sk.builtin.none.none$));this.prop$get=
b[0];this.prop$set=b[1];this.prop$del=b[2];Sk.builtin.checkNone(b[3])?Sk.builtin.checkNone(b[0])||(this.prop$doc=b[0].$doc||b[3]):this.prop$doc=b[3]},tp$doc:"Property attribute.\n\n  fget\n    function to be used for getting an attribute value\n  fset\n    function to be used for setting an attribute value\n  fdel\n    function to be used for del'ing an attribute\n  doc\n    docstring\n\nTypical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, 'I'm the 'x' property.')\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        'I am the 'x' property.'\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x",
tp$descr_get(b,e,d){if(null===b)return this;if(void 0===this.prop$get)throw new Sk.builtin.AttributeError("unreadable attribute");b=Sk.misceval.callsimOrSuspendArray(this.prop$get,[b]);return d?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)},tp$descr_set(b,e,d){let f;f=null==e?this.prop$del:this.prop$set;if(Sk.builtin.checkNone(f))throw new Sk.builtin.AttributeError("can't "+(null==e?"delete":"set")+" attribute");if(!f.tp$call)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(f)+"' is not callable");
b=null==e?f.tp$call([b]):f.tp$call([b,e]);return d?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)}},methods:{getter:{$meth(b){return new Sk.builtin.property(b,this.prop$set,this.prop$del,this.prop$doc)},$flags:{OneArg:!0}},setter:{$meth(b){return new Sk.builtin.property(this.prop$get,b,this.prop$del,this.prop$doc)},$flags:{OneArg:!0}},deleter:{$meth(b){return new Sk.builtin.property(this.prop$get,this.prop$set,b,this.prop$doc)},$flags:{OneArg:!0}}},getsets:{fget:{$get(){return this.prop$get}},fset:{$get(){return this.prop$set}},
fdel:{$get(){return this.prop$del}},__doc__:{$get(){return this.prop$doc},$set(b){this.prop$doc=b=b||Sk.builtin.none.none$}}}});Sk.builtin.classmethod=Sk.abstr.buildNativeClass("classmethod",{constructor:function(b){this.cm$callable=b;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,tp$init(b,e){Sk.abstr.checkNoKwargs("classmethod",e);Sk.abstr.checkArgsLen("classmethod",b,1,1);this.cm$callable=b[0]},tp$doc:"classmethod(function) -> method\n\nConvert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, ...):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
tp$descr_get(b,e,d){const f=this.cm$callable;if(void 0===f)throw new Sk.builtin.RuntimeError("uninitialized classmethod object");void 0===e&&(e=b.ob$type);return(b=f.tp$descr_get)?b.call(f,e,d):new Sk.builtin.method(f,e)}},getsets:{__func__:{$get(){return this.cm$callable}},__dict__:Sk.generic.getSetDict}});Sk.builtin.staticmethod=Sk.abstr.buildNativeClass("staticmethod",{constructor:function(b){this.sm$callable=b;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,
tp$init(b,e){Sk.abstr.checkNoKwargs("staticmethod",e);Sk.abstr.checkArgsLen("staticmethod",b,1,1);this.sm$callable=b[0]},tp$doc:"staticmethod(function) -> method\n\nConvert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, ...):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
tp$descr_get(b,e){if(void 0===this.sm$callable)throw new Sk.builtin.RuntimeError("uninitialized staticmethod object");return this.sm$callable}},getsets:{__func__:{$get(){return this.sm$callable}},__dict__:Sk.generic.getSetDict}})},function(F,P){function b(y,A){return function(J){if(!(J instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;let Q=this.v;J=J.v;if("number"===typeof Q&&"number"===typeof J){const X=y(Q,J);if(n(X))return new Sk.builtin.int_(X)}Q=k(Q);J=k(J);return new Sk.builtin.int_(A(Q,
J))}}function e(y,A){return function(J){if(!(J instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;let Q=this.v;J=J.v;if("number"===typeof Q&&"number"===typeof J)return y(Q,J);Q=k(Q);J=k(J);return A(Q,J)}}function d(y,A){return function(){let J=this.v;if("number"===typeof J){const Q=y(J);if(void 0!==Q)return new Sk.builtin.int_(Q);J=k(J)}return new Sk.builtin.int_(A(J))}}function f(){return new Sk.builtin.int_(this.v)}function h(y,A){return function(J){if(!(J instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;
let Q=this.v;J=J.v;if(0===J)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");if("number"===typeof Q&&"number"===typeof J)return new Sk.builtin.int_(y(Q,J));Q=k(Q);J=k(J);return new Sk.builtin.int_(JSBI.numberIfSafe(A(Q,J)))}}function p(y,A){return function(J){if(!(J instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;if(J.nb$isnegative())throw new Sk.builtin.ValueError("negative shift count");let Q=this.v;if(0===Q)return new Sk.builtin.int_(0);
J=J.v;if("number"===typeof Q&&"number"===typeof J&&53>J){const X=y(Q,J);if(void 0!==X)return new Sk.builtin.int_(X)}Q=k(Q);J=k(J);return new Sk.builtin.int_(A(Q,J))}}function g(y,A){return function(J){if(!(J instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;let Q=this.v;J=J.v;if("number"===typeof Q&&"number"===typeof J&&Math.abs(Q)<Math.pow(2,31)&&Math.abs(J)<Math.pow(2,31))return new Sk.builtin.int_(y(Q,J));Q=k(Q);J=k(J);return new Sk.builtin.int_(JSBI.numberIfSafe(A(Q,
J)))}}function a(y){return JSBI.lessThan(y,JSBI.__ZERO)?JSBI.unaryMinus(y):y}function c(y,A){if(JSBI.greaterThanOrEqual(JSBI.bitwiseXor(y,A),JSBI.__ZERO))return JSBI.divide(y,A);y=JSBI.lessThan(y,JSBI.__ZERO)?JSBI.add(y,x):JSBI.subtract(y,x);return JSBI.subtract(JSBI.divide(y,A),x)}function n(y){return y<=Number.MAX_SAFE_INTEGER&&y>=-Number.MAX_SAFE_INTEGER}function m(y){return y<=Number.MAX_SAFE_INTEGER&&y>=-Number.MAX_SAFE_INTEGER?+y:JSBI.BigInt(y)}function k(y){return"number"===typeof y?JSBI.BigInt(y):
y}function u(y,A){A=A!==Sk.builtin.none.none$?Sk.misceval.asIndexOrThrow(A):null;if(y instanceof Sk.builtin.str)return null===A&&(A=10),new Sk.builtin.int_(Sk.str2number(y.v,A));if(null!==A)throw new Sk.builtin.TypeError("int() can't convert non-string with explicit base");if(void 0!==y.nb$int)return y.nb$int();if(void 0!==y.nb$index)return new Sk.builtin.int_(y.nb$index());if(A=Sk.abstr.lookupSpecial(y,Sk.builtin.str.$trunc)){A=Sk.misceval.callsimArray(A,[]);if(!Sk.builtin.checkInt(A))throw new Sk.builtin.TypeError(Sk.builtin.str.$trunc.$jsstr()+
" returned non-Integral (type "+Sk.abstr.typeName(y)+")");return new Sk.builtin.int_(A.v)}throw new Sk.builtin.TypeError("int() argument must be a string, a bytes-like object or a number, not '"+Sk.abstr.typeName(y)+"'");}function l(y){if(!Sk.builtin.checkString(y))throw new Sk.builtin.TypeError("'byteorder' must be str, not "+Sk.abstr.typeName(y));y=y.toString();if("little"===y)return 1;if("big"===y)return 0;throw new Sk.builtin.ValueError("byteorder must be either 'little' or 'big'");}Sk.builtin.int_=
Sk.abstr.buildNativeClass("int",{constructor:function(y){Sk.asserts.assert(this instanceof Sk.builtin.int_,"bad call to int use 'new'");let A;if("number"===typeof y){if(-6<y&&257>y)return S[y];A=y}else if(JSBI.__isBigInt(y))A=y;else{if(void 0===y)return E;if("string"===typeof y)A=m(y);else{if(y.nb$int)return y.nb$int();Sk.asserts.fail("bad argument to int constructor")}}this.v=A},slots:{tp$as_number:!0,tp$doc:"int(x=0) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
$r(){return new Sk.builtin.str(this.v.toString())},tp$hash(){var y=this.v;if("number"===typeof y){if(-1===y)return-2;if(536870911>y&&-536870911<y)return y;y=k(y)}y=JSBI.toNumber(JSBI.remainder(y,q));return-1===y?-2:y},tp$new(y,A){1===y.length+(A?A.length:0)?(A=y[0],y=Sk.builtin.none.none$):(y=Sk.abstr.copyKeywordsToNamedArgs("int",[null,"base"],y,A,[E,Sk.builtin.none.none$]),A=y[0],y=y[1]);A=u(A,y);if(this===Sk.builtin.int_.prototype)return A;y=new this.constructor;y.v=A.v;return y},tp$getattr:Sk.generic.getAttr,
ob$eq:e((y,A)=>y==A,JSBI.equal),ob$ne:e((y,A)=>y!=A,JSBI.notEqual),ob$gt:e((y,A)=>y>A,JSBI.greaterThan),ob$ge:e((y,A)=>y>=A,JSBI.greaterThanOrEqual),ob$lt:e((y,A)=>y<A,JSBI.lessThan),ob$le:e((y,A)=>y<=A,JSBI.lessThanOrEqual),nb$int:f,nb$index(){return this.v},nb$float(){var y=this.v;if("number"===typeof y)return new Sk.builtin.float_(y);y=parseFloat(JSBI.toNumber(y));if(Infinity===y||-Infinity===y)throw new Sk.builtin.OverflowError("int too large to convert to float");return new Sk.builtin.float_(y)},
nb$isnegative(){const y=this.v;return"number"===typeof y?0>y:JSBI.lessThan(y,JSBI.__ZERO)},nb$ispositive(){const y=this.v;return"number"===typeof y?0<=y:JSBI.greaterThanOrEqual(y,JSBI.__ZERO)},nb$bool(){return 0!==this.v},nb$positive:f,nb$negative:d(y=>-y,JSBI.unaryMinus),nb$add:b((y,A)=>y+A,(y,A)=>JSBI.numberIfSafe(JSBI.add(y,A))),nb$subtract:b((y,A)=>y-A,(y,A)=>JSBI.numberIfSafe(JSBI.subtract(y,A))),nb$multiply:b((y,A)=>y*A,(y,A)=>y===JSBI.__ZERO||A===JSBI.__ZERO?0:JSBI.multiply(y,A)),nb$divide:function(y){if(!Sk.__future__.python3)return this.nb$floor_divide(y);
if(!(y instanceof Sk.builtin.int_))return Sk.builtin.NotImplemented.NotImplemented$;var A=this.v,J=y.v;if(0===J)throw new Sk.builtin.ZeroDivisionError("division by zero");if("number"===typeof A&&"number"===typeof J)return new Sk.builtin.float_(A/J);A=k(A);J=k(J);y=JSBI.lessThan(JSBI.bitwiseXor(A,J),JSBI.__ZERO);if(JSBI.equal(A,JSBI.__ZERO))return new Sk.builtin.float_(y?-0:0);A=a(A);J=a(J);if(JSBI.greaterThanOrEqual(A,JSBI.multiply(v,J)))throw new Sk.builtin.OverflowError("int/int too large to represent as a float");
var Q=A.toString(2).length-J.toString(2).length,X=JSBI.BigInt(0>Q?-Q:Q);if(0<=Q&&JSBI.greaterThanOrEqual(A,JSBI.multiply(JSBI.exponentiate(t,X),J))||0>Q&&JSBI.greaterThanOrEqual(JSBI.multiply(A,JSBI.exponentiate(t,X)),J))Q+=1;Q=Math.max(Q,r)-z;A=JSBI.leftShift(A,JSBI.BigInt(Math.max(-Q,0)));J=JSBI.leftShift(J,JSBI.BigInt(Math.max(Q,0)));X=JSBI.divide(A,J);A=JSBI.remainder(A,J);A=JSBI.multiply(t,A);if(JSBI.greaterThan(A,J)||JSBI.equal(A,J)&&JSBI.equal(JSBI.remainder(X,t),x))X=JSBI.add(X,x);X=JSBI.toNumber(X);
if(Infinity===X||-Infinity===X)throw new Sk.builtin.OverflowError("int/int too large to represent as a float");J=X*Math.pow(2,Q);return new Sk.builtin.float_(y?-J:J)},nb$floor_divide:h((y,A)=>Math.floor(y/A),c),nb$remainder:h((y,A)=>y-Math.floor(y/A)*A,(y,A)=>JSBI.subtract(y,JSBI.multiply(A,c(y,A)))),nb$divmod(y){const A=this.nb$floor_divide(y);y=this.nb$remainder(y);return A===Sk.builtin.NotImplemented.NotImplemented$||y===Sk.builtin.NotImplemented.NotImplemented$?Sk.builtin.NotImplemented.NotImplemented$:
new Sk.builtin.tuple([A,y])},nb$and:g((y,A)=>y&A,JSBI.bitwiseAnd),nb$or:g((y,A)=>y|A,JSBI.bitwiseOr),nb$xor:g((y,A)=>y^A,JSBI.bitwiseXor),nb$abs:d(Math.abs,a),nb$lshift:p((y,A)=>{y=2*y*I[A];if(n(y))return y},JSBI.leftShift),nb$rshift:p((y,A)=>{Math.floor(y/I[A+1])},(y,A)=>JSBI.numberIfSafe(JSBI.signedRightShift(y,A))),nb$invert:d(y=>Math.abs(y)<Math.pow(2,31)?~y:void 0,y=>JSBI.numberIfSafe(JSBI.bitwiseNot(y))),nb$power(y,A){let J;void 0!==A&&Sk.builtin.checkNone(A)&&(A=void 0);if(!(y instanceof Sk.builtin.int_&&
(void 0===A||A instanceof Sk.builtin.int_)))return Sk.builtin.NotImplemented.NotImplemented$;const Q=y.nb$isnegative();if(Q&&void 0===A)return this.nb$float().nb$power(y.nb$float());let X=this.v;y=y.v;if("number"===typeof X&&"number"===typeof y){const aa=Math.pow(X,y);if(n(aa)&&(J=new Sk.builtin.int_(aa),void 0===A))return J}if(void 0!==A){if(Q)throw new Sk.builtin.ValueError("pow() 2nd argument cannot be negative when 3rd argument specified");if(0===A.v)throw new Sk.builtin.ValueError("pow() 3rd argument cannot be 0");
return void 0!==J?J.nb$remainder(A):new Sk.builtin.int_(JSBI.numberIfSafe(JSBI.powermod(k(X),k(y),k(A.v))))}return new Sk.builtin.int_(JSBI.exponentiate(k(X),k(y)))},nb$long(){return new Sk.builtin.lng(this.v)}},getsets:{real:{$get:f,$doc:"the real part of a complex number"},imag:{$get(){return E},$doc:"the imaginary part of a complex number"},numerator:{$get:f},denominator:{$get(){return H}}},classmethods:{from_bytes:{$meth(y,A){Sk.abstr.checkArgsLen("from_bytes",y,0,2);let [J,Q,X]=Sk.abstr.copyKeywordsToNamedArgs("from_bytes",
["bytes","byteorder","signed"],y,A,[Sk.builtin.bool.false$]);y=l(Q);J instanceof Sk.builtin.bytes||(J=Sk.misceval.callsimArray(Sk.builtin.bytes,[J]));if(Sk.misceval.isTrue(X))throw new Sk.builtin.NotImplementedError("from_bytes with signed=True is not yet implemented in Skulpt");const aa=[];J.valueOf().forEach(ea=>{aa.push(ea.toString(16).padStart(2,"0"))});y&&aa.reverse();y=new Sk.builtin.int_(JSBI.numberIfSafe(JSBI.BigInt("0x"+(aa.join("")||"0"))));return this===Sk.builtin.int_?y:Sk.misceval.callsimArray(this,
[y])},$flags:{FastCall:!0}}},methods:{conjugate:{$meth:f,$flags:{NoArgs:!0},$textsig:null,$doc:"Returns self, the complex conjugate of any int."},bit_length:{$meth(){let y=this.v;if(0===y)return new Sk.builtin.int_(0);y="number"===typeof y?Math.abs(y):a(y);return new Sk.builtin.int_(y.toString(2).length)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6"},to_bytes:{$meth(y,A){Sk.abstr.checkArgsLen("to_bytes",
y,0,2);let [J,Q,X]=Sk.abstr.copyKeywordsToNamedArgs("to_bytes",["length","byteorder","signed"],y,A,[Sk.builtin.bool.false$]);y=l(Q);J=Sk.misceval.asIndexSized(J,Sk.builtin.OverflowError);if(0>J)throw new Sk.builtin.ValueError("length argument must be non-negative");if(Sk.misceval.isTrue(X))throw new Sk.builtin.NotImplementedError("to_bytes with signed=True is not yet implemented in Skulpt");if(this.nb$isnegative())throw new Sk.builtin.OverflowError("can't convert negative int to unsigned");A=JSBI.BigInt(this.v).toString(16);
A.length%2&&(A="0"+A);var aa=A.length/2;if(aa>J){if(0===J&&"00"===A)return new Sk.builtin.bytes;throw new Sk.builtin.OverflowError("int too big to convert");}const ea=Array(J).fill(0);aa=J-aa;let na=0;for(;aa<J;)ea[aa]=parseInt(A.slice(na,na+2),16),aa+=1,na+=2;y&&ea.reverse();return new Sk.builtin.bytes(ea)},$flags:{FastCall:!0},$textsig:"($self, /, length, byteorder, *, signed=False)",$doc:"Return an array of bytes representing an integer.\n\n  length\n    Length of bytes object to use.  An OverflowError is raised if the\n    integer is not representable with the given number of bytes.\n  byteorder\n    The byte order used to represent the integer.  If byteorder is 'big',\n    the most significant byte is at the beginning of the byte array.  If\n    byteorder is 'little', the most significant byte is at the end of the\n    byte array.  To request the native byte order of the host system, use\n    `sys.byteorder' as the byte order value.\n  signed\n    Determines whether two's complement is used to represent the integer.\n    If signed is False and a negative integer is given, an OverflowError\n    is raised."},
__trunc__:{$meth:f,$flags:{NoArgs:!0},$textsig:null,$doc:"Truncating an Integral returns itself."},__floor__:{$meth:f,$flags:{NoArgs:!0},$textsig:null,$doc:"Flooring an Integral returns itself."},__ceil__:{$meth:f,$flags:{NoArgs:!0},$textsig:null,$doc:"Ceiling of an Integral returns itself."},__round__:{$meth(y){return this.round$(y)},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"Rounding an Integral returns itself.\nRounding with an ndigits argument also returns an integer."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([new Sk.builtin.int_(this.v)])},
$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:Sk.builtin.none.none$},__format__:{$meth:Sk.formatting.mkNumber__format__(!1),$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:Sk.builtin.none.none$}},proto:{str$(y,A){y=void 0===y||10===y?this.v.toString():this.v.toString(y);A||void 0===A||"-"===y[0]&&(y=y.substring(1));return y},round$(y){y=void 0===y?0:Sk.misceval.asIndexSized(y);var A=this.v;if(0<=y)return new Sk.builtin.int_(A);if("number"!==typeof A){{var J=y;(y=JSBI.lessThan(A,JSBI.__ZERO))&&
(A=JSBI.unaryMinus(A));J=JSBI.exponentiate(JSBI.BigInt(10),JSBI.unaryMinus(JSBI.BigInt(J)));let Q=JSBI.divide(A,J);A=JSBI.remainder(A,J);A=JSBI.multiply(A,t);JSBI.greaterThan(A,J)?Q=JSBI.add(Q,x):JSBI.equal(A,J)&&(Sk.__future__.bankers_rounding?JSBI.equal(JSBI.remainder(Q,t),x)&&(Q=JSBI.add(Q,x)):Q=JSBI.add(Q,x));Q=JSBI.multiply(Q,J);y&&(Q=JSBI.unaryMinus(Q));y=new Sk.builtin.int_(Q)}return y}y=Math.pow(10,-y);if(y/10>Math.abs(A))return new Sk.builtin.int_(0);if(!Sk.__future__.bankers_rounding)return new Sk.builtin.int_(Math.round(A/
y)*y);A/=y;J=Math.round(A);return new Sk.builtin.int_((.5===(0<A?A:-A)%1?0===J%2?J:J-1:J)*y)},valueOf(){return this.v},sk$int:!0}});Sk.exportSymbol("Sk.builtin.int_",Sk.builtin.int_);const q=JSBI.BigInt("536870911"),z=Math.log2(Number.MAX_SAFE_INTEGER);F=JSBI.BigInt(Math.floor(Math.log2(Number.MAX_VALUE)));const r=Math.ceil(Math.log2(Number.MIN_VALUE)),t=JSBI.BigInt(2),x=JSBI.BigInt(1),v=JSBI.subtract(JSBI.exponentiate(t,F),JSBI.exponentiate(t,JSBI.subtract(F,JSBI.add(JSBI.BigInt(z),x)))),B=/_(?=[^_])/g;
Sk.str2number=function(y,A){var J=y,Q=!1,X;y=y.replace(/^\s+|\s+$/g,"");"-"===y.charAt(0)&&(Q=!0,y=y.substring(1));"+"===y.charAt(0)&&(y=y.substring(1));if(null===A||void 0===A)A=10;if((2>A||36<A)&&0!==A)throw new Sk.builtin.ValueError("int() base must be >= 2 and <= 36");"string"===typeof A&&(A=Number(A));if("0x"===y.substring(0,2).toLowerCase())if(16===A||0===A)y=y.substring(2),A=16;else{if(34>A)throw new Sk.builtin.ValueError("invalid literal for int() with base "+A+": '"+J+"'");}else if("0b"===
y.substring(0,2).toLowerCase())if(2===A||0===A)y=y.substring(2),A=2;else{if(12>A)throw new Sk.builtin.ValueError("invalid literal for int() with base "+A+": '"+J+"'");}else if("0o"===y.substring(0,2).toLowerCase())if(8===A||0===A)y=y.substring(2),A=8;else{if(25>A)throw new Sk.builtin.ValueError("invalid literal for int() with base "+A+": '"+J+"'");}else if("0"===y.charAt(0)){if("0"===y)return 0;if(8===A||0===A)A=8}0===A&&(A=10);if(-1!==y.indexOf("_")){if(-1!==y.indexOf("__"))throw new Sk.builtin.ValueError("invalid literal for int() with base "+
A+": '"+J+"'");y=10!==A?y.replace(B,""):y.charAt(0)+y.substring(1).replace(B,"")}if(0===y.length)throw new Sk.builtin.ValueError("invalid literal for int() with base "+A+": '"+J+"'");for(X=0;X<y.length;X+=1){var aa=y.charCodeAt(X);var ea=A;48<=aa&&57>=aa?ea=aa-48:65<=aa&&90>=aa?ea=aa-65+10:97<=aa&&122>=aa&&(ea=aa-97+10);if(ea>=A)throw new Sk.builtin.ValueError("invalid literal for int() with base "+A+": '"+J+"'");}Q&&(y="-"+y);ea=parseInt(y,A);if(n(ea))return ea;J=!1;"-"===y[0]&&(J=!0,y=y.substring(1));
A=JSBI.BigInt(A);Q=x;X=JSBI.__ZERO;for(aa=y.length-1;0<=aa;aa--)ea=y.charCodeAt(aa),48<=ea&&57>=ea?ea-=48:65<=ea&&90>=ea?ea=ea-65+10:97<=ea&&122>=ea&&(ea=ea-97+10),ea=JSBI.multiply(JSBI.BigInt(ea),Q),X=JSBI.add(X,ea),Q=JSBI.multiply(Q,A);J&&(X=JSBI.multiply(X,JSBI.BigInt(-1)));return y=X};Sk.builtin.int_.py2$methods={};Sk.longFromStr=function(y,A){if(Sk.__future__.python3)return new Sk.builtin.int_(m(y));y=Sk.str2number(y,A);return new Sk.builtin.lng(y)};Sk.exportSymbol("Sk.longFromStr",Sk.longFromStr);
Sk.builtin.int_.withinThreshold=n;Sk.builtin.int_.stringToNumberOrBig=m;const I=[.5,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,0x800000000000,281474976710656,
562949953421312,0x4000000000000,0x8000000000000,4503599627370496,9007199254740992];Sk.builtin.lng=Sk.abstr.buildNativeClass("long",{base:Sk.builtin.int_,constructor:function(y){y=Sk.builtin.int_.call(this,y);void 0!==y&&(this.v=y.v)},slots:{$r(){return new Sk.builtin.str(this.v.toString()+"L")},tp$as_number:!0,nb$negative(){return new Sk.builtin.lng(M.nb$negative.call(this).v)},nb$positive(){return new Sk.builtin.lng(M.nb$positive.call(this).v)}}});const M=Sk.builtin.int_.prototype,S=[];for(F=-5;257>
F;F++)S[F]=Object.create(Sk.builtin.int_.prototype,{v:{value:F}});const E=S[0],H=S[1]},function(F,P){const b=Sk.builtin.int_.prototype;Sk.builtin.bool=Sk.abstr.buildNativeClass("bool",{constructor:function(e){return Sk.misceval.isTrue(e)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},base:Sk.builtin.int_,slots:{tp$doc:"bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
tp$new(e,d){Sk.abstr.checkNoKwargs("bool",d);Sk.abstr.checkArgsLen("bool",e,0,1);return new Sk.builtin.bool(e[0])},$r(){return this.v?this.str$True:this.str$False},tp$as_number:!0,nb$and(e){return e.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v&e.v):b.nb$and.call(this,e)},nb$or(e){return e.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v|e.v):b.nb$or.call(this,e)},nb$xor(e){return e.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v^e.v):b.nb$xor.call(this,e)}},flags:{sk$unacceptableBase:!0},
methods:{__format__:{$meth(){return this.$r()},$flags:{OneArg:!0}}},proto:{str$False:new Sk.builtin.str("False"),str$True:new Sk.builtin.str("True"),valueOf(){return!!this.v}}});Sk.exportSymbol("Sk.builtin.bool",Sk.builtin.bool);Sk.builtin.bool.true$=Object.create(Sk.builtin.bool.prototype,{v:{value:1,enumerable:!0}});Sk.builtin.bool.false$=Object.create(Sk.builtin.bool.prototype,{v:{value:0,enumerable:!0}})},function(F,P){function b(k){const u=[k,0];if(0===k)return u;var l=Math.abs(k);let q=Math.max(-1023,
Math.floor(Math.log2(l))+1);for(l*=Math.pow(2,-q);.5>l;)l*=2,q--;for(;1<=l;)l*=.5,q++;0>k&&(l=-l);u[0]=l;u[1]=q;return u}function e(){return new Sk.builtin.float_(this.v)}function d(k){return function(u){const l=this.v;u=u.v;if("number"!==typeof u)if(JSBI.__isBigInt(u)){if(u=parseFloat(JSBI.toNumber(u)),Infinity==u||-Infinity==u)throw new Sk.builtin.OverflowError("int too large to convert to float");}else return Sk.builtin.NotImplemented.NotImplemented$;return k(l,u)}}function f(k,u){return function(l){const q=
this.v;l=l.v;if("number"!==typeof l){if(!JSBI.__isBigInt(l))return Sk.builtin.NotImplemented.NotImplemented$;if(void 0!==u)return u(q,l)}return k(q,l)}}function h(k){const u=d(k);return function(l,q){if(void 0!==q&&!Sk.builtin.checkNone(q))throw new Sk.builtin.TypeError("pow() 3rd argument not allowed unless all arguments are integers");return u.call(this,l)}}function p(k,u){if(0===u)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");return Infinity===k?Infinity===u||-Infinity===
k?new Sk.builtin.float_(NaN):0>u?new Sk.builtin.float_(-Infinity):new Sk.builtin.float_(Infinity):-Infinity===k?Infinity===u||-Infinity===k?new Sk.builtin.float_(NaN):0>u?new Sk.builtin.float_(Infinity):new Sk.builtin.float_(-Infinity):new Sk.builtin.float_(k/u)}function g(k,u){if(Infinity===k||-Infinity===k)return new Sk.builtin.float_(NaN);if(0===u)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");return Infinity===u?0>k?new Sk.builtin.float_(-1):new Sk.builtin.float_(0):
-Infinity===u?0>k||0!==k?new Sk.builtin.float_(0):new Sk.builtin.float_(-1):new Sk.builtin.float_(Math.floor(k/u))}function a(k,u){if(0===u)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");if(0===k)return new Sk.builtin.float_(0);if(Infinity===u)return Infinity===k||-Infinity===k?new Sk.builtin.float_(NaN):0<k?new Sk.builtin.float_(k):new Sk.builtin.float_(Infinity);let l=k%u;0>k?0<u&&0>l&&(l+=u):0>u&&0!==l&&(l+=u);0===l&&(0>u?l=-0:-Infinity===Infinity/l&&(l=0));return new Sk.builtin.float_(l)}
function c(k,u){if(0>k&&0!==u%1)return(new Sk.builtin.complex(k,0)).nb$power(new Sk.builtin.complex(u,0));if(0===k&&0>u)throw new Sk.builtin.ZeroDivisionError("0.0 cannot be raised to a negative power");const l=Math.pow(k,u);if(Infinity===Math.abs(l)&&Infinity!==Math.abs(k)&&Infinity!==Math.abs(u))throw new Sk.builtin.OverflowError("Numerical result out of range");return new Sk.builtin.float_(l)}Sk.builtin.float_=Sk.abstr.buildNativeClass("float",{constructor:function(k){Sk.asserts.assert(this instanceof
Sk.builtin.float_,"bad call to float use 'new'");if("number"===typeof k)this.v=k;else if(void 0===k)this.v=0;else if("string"===typeof k)this.v=parseFloat(k);else{if(k.nb$float)return k.nb$float();Sk.asserts.fail("bad argument to float constructor")}},slots:{tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$doc:"Convert a string or number to a floating point number, if possible.",tp$hash(){var k=this.v;if(!Number.isFinite(k))return Number.isNaN(k)?0:0<k?314159:-314159;let [u,l]=b(k);k=1;0>u&&(k=-1,
u=-u);let q=0,z;for(;u;)q=q<<28&536870911|q>>1,u*=268435456,l-=28,z=Math.trunc(u),u-=z,q+=z,536870911<=q&&(q-=536870911);l=0<=l?l%29:28-(-1-l)%29;q=(q<<l&536870911|q>>29-l)*k;return-1===q?-2:q},$r(){return new Sk.builtin.str(this.str$(10,!0))},tp$new(k,u){if(u&&u.length)throw new Sk.builtin.TypeError("float() takes no keyword arguments");if(k&&1<k.length)throw new Sk.builtin.TypeError("float expected at most 1 arguments, got "+k.length);k=k[0];if(void 0===k)var l=new Sk.builtin.float_(0);else if(void 0!==
k.nb$float)l=k.nb$float();else if(void 0!==k.nb$index)l=(new Sk.builtin.int_(k.nb$index())).nb$float();else if(Sk.builtin.checkString(k)){l=k.v;k=l;if(-1!==l.indexOf("_")){if(n.test(l))throw new Sk.builtin.ValueError("could not convert string to float: '"+l+"'");k=l.charAt(0)+l.substring(1).replace(m,"")}if(l.match(/^-inf$/i))var q=-Infinity;else l.match(/^[+]?inf$/i)?q=Infinity:l.match(/^[-+]?nan$/i)?q=NaN:isNaN(k)||(q=parseFloat(k),Number.isNaN(q)&&(q=void 0));if(void 0===q)throw new Sk.builtin.ValueError("could not convert string to float: "+
Sk.misceval.objectRepr(new Sk.builtin.str(l)));l=new Sk.builtin.float_(q)}if(void 0===l)throw new Sk.builtin.TypeError("float() argument must be a string or a number");if(this===Sk.builtin.float_.prototype)return l;q=new this.constructor;q.v=l.v;return q},nb$int(){let k=this.v;if(!Number.isFinite(k)){if(Infinity===k||-Infinity===k)throw new Sk.builtin.OverflowError("cannot convert float infinity to integer");throw new Sk.builtin.ValueError("cannot convert float NaN to integer");}k=0>k?Math.ceil(k):
Math.floor(k);return Sk.builtin.int_.withinThreshold(k)?new Sk.builtin.int_(k):new Sk.builtin.int_(JSBI.BigInt(k))},nb$float:e,nb$long(){return new Sk.builtin.lng(this.nb$int().v)},nb$add:d((k,u)=>new Sk.builtin.float_(k+u)),nb$subtract:d((k,u)=>new Sk.builtin.float_(k-u)),nb$reflected_subtract:d((k,u)=>new Sk.builtin.float_(u-k)),nb$multiply:d((k,u)=>new Sk.builtin.float_(k*u)),nb$divide:d(p),nb$reflected_divide:d((k,u)=>p(u,k)),nb$floor_divide:d(g),nb$reflected_floor_divide:d((k,u)=>g(u,k)),nb$remainder:d(a),
nb$reflected_remainder:d((k,u)=>a(u,k)),nb$divmod:d((k,u)=>new Sk.builtin.tuple([g(k,u),a(k,u)])),nb$reflected_divmod:d((k,u)=>new Sk.builtin.tuple([g(u,k),a(u,k)])),nb$power:h(c),nb$reflected_power:h((k,u)=>c(u,k)),nb$abs(){return new Sk.builtin.float_(Math.abs(this.v))},nb$negative(){return new Sk.builtin.float_(-this.v)},nb$positive(){return new Sk.builtin.float_(this.v)},nb$bool(){return 0!==this.v},nb$isnegative(){return 0>this.v},nb$ispositive(){return 0<=this.v},ob$eq:f((k,u)=>k==u,JSBI.EQ),
ob$ne:f((k,u)=>k!=u,JSBI.NE),ob$gt:f((k,u)=>k>u,JSBI.GT),ob$ge:f((k,u)=>k>=u,JSBI.GE),ob$lt:f((k,u)=>k<u,JSBI.LT),ob$le:f((k,u)=>k<=u,JSBI.LE)},getsets:{real:{$get:e,$doc:"the real part of a complex number"},imag:{$get(){return new Sk.builtin.float_(0)},$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth:e,$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return self, the complex conjugate of any float."},__trunc__:{$meth(){return this.nb$int()},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return the Integral closest to x between 0 and x."},__round__:{$meth(k){return this.round$(k)},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, ndigits=None, /)",$doc:"Return the Integral closest to x, rounding half toward even.\n\nWhen an argument is passed, work like built-in round(x, ndigits)."},as_integer_ratio:{$meth(){if(!Number.isFinite(this.v)){if(Number.isNaN(this.v))throw new Sk.builtin.ValueError("cannot convert NaN to integer ratio");throw new Sk.builtin.OverflowError("cannot convert Infinity to integer ratio");
}let [k,u]=b(this.v);for(var l=0;300>l&&k!=Math.floor(k);l++)k*=2,u--;l=new Sk.builtin.int_(Math.abs(u));let q=new Sk.builtin.int_(k),z=new Sk.builtin.int_(1);0<u?q=q.nb$lshift(l):z=z.nb$lshift(l);return new Sk.builtin.tuple([q,z])},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return integer ratio.\n\nReturn a pair of integers, whose ratio is exactly equal to the original float\nand with a positive denominator.\n\nRaise OverflowError on infinities and a ValueError on NaNs.\n\n>>> (10.0).as_integer_ratio()\n(10, 1)\n>>> (0.0).as_integer_ratio()\n(0, 1)\n>>> (-.25).as_integer_ratio()\n(-1, 4)"},
is_integer:{$meth(){return new Sk.builtin.bool(Number.isInteger(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the float is an integer."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([this])},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:Sk.builtin.none.none$},__format__:{$meth:Sk.formatting.mkNumber__format__(!0),$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:Sk.builtin.none.none$}},proto:{valueOf(){return this.v}}});const n=/_[eE]|[eE]_|\._|_\.|[+-]_|__/,
m=/_(?=[^_])/g;Sk.builtin.float_.PyFloat_Check=function(k){return void 0===k?!1:Sk.builtin.checkNumber(k)||Sk.builtin.checkFloat(k)||k.ob$type.$isSubType(Sk.builtin.float_)?!0:!1};Sk.builtin.float_.prototype.toFixed=function(k){k=Sk.builtin.asnum$(k);return this.v.toFixed(k)};Sk.builtin.float_.prototype.round$=function(k){var u=Sk.builtin.asnum$(this);var l=void 0===k?0:Sk.misceval.asIndexSized(k);if(Sk.__future__.bankers_rounding){u*=Math.pow(10,l);var q=Math.round(u);l=(.5===(0<u?u:-u)%1?0===q%
2?q:q-1:q)/Math.pow(10,l);return void 0===k?new Sk.builtin.int_(l):new Sk.builtin.float_(l)}k=Math.pow(10,l);l=Math.round(u*k)/k;return new Sk.builtin.float_(l)};Sk.builtin.float_.prototype.str$=function(k,u){if(isNaN(this.v))return"nan";void 0===u&&(u=!0);if(Infinity==this.v)return"inf";if(-Infinity==this.v&&u)return"-inf";if(-Infinity==this.v&&!u)return"inf";u=u?this.v:Math.abs(this.v);if(void 0===k||10===k){var l=Sk.__future__.python3?u.toPrecision(16):u.toPrecision(12);var q=l.indexOf(".");k=
u.toString().slice(0,q);q=u.toString().slice(q);k.match(/^-?0$/)&&q.slice(1).match(/^0{4,}/)&&(l=12>l.length?u.toExponential():u.toExponential(11));if(0>l.indexOf("e")&&0<=l.indexOf(".")){for(;"0"==l.charAt(l.length-1);)l=l.substring(0,l.length-1);"."==l.charAt(l.length-1)&&(l+="0")}l=l.replace(/\.0+e/,"e","i");l=l.replace(/(e[-+])([1-9])$/,"$10$2");l=l.replace(/0+(e.*)/,"$1")}else l=u.toString(k);0===this.v&&-Infinity===1/this.v&&(l="-"+l);0>l.indexOf(".")&&0>l.indexOf("E")&&0>l.indexOf("e")&&(l+=
".0");return l};Sk.builtin.float_.py2$methods={}},function(F,P){function b(l){let q=l.v;if("number"===typeof q)return q;l.nb$float&&(q=l.nb$float());if(void 0===q)throw new Sk.builtin.TypeError("a float is required");return q.v}function e(l,q,z){if(z===Sk.builtin.complex.prototype)return new Sk.builtin.complex(l,q);z=new z.constructor;Sk.builtin.complex.call(z,l,q);return z}function d(l,q){return function(z){const r=this.real,t=this.imag;var x=z.real;const v=z.v;if("number"===typeof x)z=z.imag;else if("number"===
typeof v)x=v,z=0;else if(JSBI.__isBigInt(v)){if(void 0===q){if(x=parseFloat(JSBI.toNumber(v)),Infinity==x||-Infinity==x)throw new Sk.builtin.OverflowError("int too large to convert to float");}else x=v.toString();z=0}else return Sk.builtin.NotImplemented.NotImplemented$;return l(r,t,x,z)}}function f(l,q,z,r){var t=Math.abs(z);const x=Math.abs(r);if(t>=x){if(0===t)throw new Sk.builtin.ZeroDivisionError("complex division by zero");t=r/z;z+=r*t;r=(l+q*t)/z;l=(q-l*t)/z}else x>=t?(t=z/r,z=z*t+r,Sk.asserts.assert(0!==
r),r=(l*t+q)/z,l=(q*t-l)/z):l=r=NaN;return new Sk.builtin.complex(r,l)}function h(l,q,z,r){if(0===z&&0===r){r=1;var t=0}else if(0===l&&0===q){if(0!==r||0>z)throw new Sk.builtin.ZeroDivisionError("complex division by zero");t=r=0}else{const x=Math.hypot(l,q);t=Math.pow(x,z);l=Math.atan2(q,l);z*=l;0!==r&&(t/=Math.exp(l*r),z+=r*Math.log(x));r=t*Math.cos(z);t*=Math.sin(z)}return new Sk.builtin.complex(r,t)}function p(l,q,z){let r=1;var t=new Sk.builtin.complex(1,0);for(l=new Sk.builtin.complex(l,q);0<
r&&z>=r;)z&r&&(t=new Sk.builtin.complex(t.real*l.real-t.imag*l.imag,t.real*l.imag+l.real*t.imag)),r<<=1,l=new Sk.builtin.complex(l.real*l.real-l.imag*l.imag,2*l.real*l.imag);return t}function g(l,q,z,r,t){t=!1;switch(q){case "e":case "f":case "g":break;case "E":t=!0;q="e";break;case "F":t=!0;q="f";break;case "r":if(0!==z)throw Error("Bad internall call");z=17;q="g";break;default:throw Error("Bad internall call");}if(isNaN(l))l="nan";else if(Infinity===l)l="inf";else if(-Infinity===l)l="-inf";else{r&
g.Py_DTSF_ADD_DOT_0&&(q="g");var x="%"+(r&g.Py_DTSF_ALT?"#":"");null!=z&&(x=x+"."+z);x=new Sk.builtin.str(x+q);l=x.nb$remainder(new Sk.builtin.float_(l));l=l.v}r&g.Py_DTSF_SIGN&&"-"!==l[0]&&(l="+"+l);t&&(l=l.toUpperCase());return l}Sk.builtin.complex=Sk.abstr.buildNativeClass("complex",{constructor:function(l,q){Sk.asserts.assert(this instanceof Sk.builtin.complex,"bad call to complex constructor, use 'new'");this.real=l;this.imag=q},slots:{tp$as_number:!0,tp$doc:"Create a complex number from a real part and an optional imaginary part.\n\nThis is equivalent to (real + imag*1j) where imag defaults to 0.",
tp$hash(){var l=(new Sk.builtin.float_(this.real)).tp$hash();l=1003*(new Sk.builtin.float_(this.imag)).tp$hash()+l;return Sk.builtin.int_.withinThreshold(l)?l:(new Sk.builtin.int_(JSBI.BigInt(l))).tp$hash()},tp$getattr:Sk.generic.getAttr,tp$new(l,q){l=Sk.abstr.copyKeywordsToNamedArgs("complex",["real","imag"],l,q,[null,null]);{var z=l[1],r;let x=q=!1;var t=l[0];if(null!=t&&t.constructor===Sk.builtin.complex&&null==z)q=t;else if(Sk.builtin.checkString(t)){if(null!=z)throw new Sk.builtin.TypeError("complex() can't take second arg if first is a string");
q=Sk.builtin.complex.complex_subtype_from_string(t,this)}else{if(null!=z&&Sk.builtin.checkString(z))throw new Sk.builtin.TypeError("complex() second arg can't be a string");null==t?l=null:(l=Sk.abstr.lookupSpecial(t,Sk.builtin.str.$complex),l=void 0!==l?Sk.misceval.callsimArray(l,[]):null);if(null!=l&&l!==Sk.builtin.NotImplemented.NotImplemented$){if(!a(l))throw new Sk.builtin.TypeError("__complex__ should return a complex object");t=l}if(null!=t&&void 0===t.nb$float)throw new Sk.builtin.TypeError("complex() first argument must be a string or a number, not '"+
Sk.abstr.typeName(t)+"'");if(null!=z&&void 0===z.nb$float)throw new Sk.builtin.TypeError("complex() second argument must be a number, not '"+Sk.abstr.typeName(t)+"'");null==t?t=l=0:a(t)?(l=t.real,t=t.imag,q=!0):(l=b(t),t=0);null==z?z=r=0:a(z)?(r=z.real,z=z.imag,x=!0):(r=b(z),z=0);!0===x&&(l-=z);!0===q&&(r+=t);q=e(l,r,this)}}return q},tp$richcompare(l,q){if("Eq"!==q&&"NotEq"!==q){if(Sk.builtin.checkNumber(l)||a(l))throw new Sk.builtin.TypeError("no ordering relation is defined for complex numbers");
return Sk.builtin.NotImplemented.NotImplemented$}return d(function(z,r,t,x){z=z==t&&r==x;return"Eq"===q?z:!z},!0).call(this,l)},$r(){{var l,q;let t=l="";var z=this.real;var r=this.imag;if(q=0===z)q=1==(z?0>z?-1:1:0>1/z?-1:1);q?(z="",q=g(r,"g",null,0,null)):(z=l=g(z,"g",null,0,null),q=g(r,"g",null,g.Py_DTSF_SIGN,null),0===r&&-Infinity===1/r&&q&&"-"!==q[0]&&(q="-"+q),l="(",t=")");r=new Sk.builtin.str(""+l+z+q+"j"+t)}return r},nb$int(){throw new Sk.builtin.TypeError("can't convert complex to int");},
nb$long(){throw new Sk.builtin.TypeError("can't convert complex to long");},nb$float(){throw new Sk.builtin.TypeError("can't convert complex to float");},nb$positive(){return new Sk.builtin.complex(this.real,this.imag)},nb$negative(){return new Sk.builtin.complex(-this.real,-this.imag)},nb$bool(){return this.real||this.imag},nb$add:d((l,q,z,r)=>new Sk.builtin.complex(l+z,q+r)),nb$subtract:d((l,q,z,r)=>new Sk.builtin.complex(l-z,q-r)),nb$reflected_subtract:d((l,q,z,r)=>new Sk.builtin.complex(z-l,r-
q)),nb$multiply:d((l,q,z,r)=>new Sk.builtin.complex(z*l-r*q,l*r+q*z)),nb$divide:d(f),nb$reflected_divide:d((l,q,z,r)=>f(z,r,l,q)),nb$floor_divide(l){throw new Sk.builtin.TypeError("can't take floor of complex number.");},nb$reflected_floor_divide(l){throw new Sk.builtin.TypeError("can't take floor of complex number.");},nb$remainder(l){throw new Sk.builtin.TypeError("can't mod complex numbers.");},nb$reflected_remainder(l){throw new Sk.builtin.TypeError("can't mod complex numbers.");},nb$divmod(l){throw new Sk.builtin.TypeError("can't take floor or mod of complex number.");
},nb$power(l,q){if(null!=q&&!Sk.builtin.checkNone(q))throw new Sk.builtin.ValueError("complex modulo");return k.call(this,l)},nb$reflected_power(l,q){if(null!=q&&!Sk.builtin.checkNone(q))throw new Sk.builtin.ValueError("complex modulo");return u.call(this,l)},nb$abs(){var l=this.real;const q=this.imag;if(!Number.isFinite(l)||!Number.isFinite(q))return Infinity===l||-Infinity===l?new Sk.builtin.float_(Math.abs(l)):Infinity===q||-Infinity===q?new Sk.builtin.float_(Math.abs(q)):new Sk.builtin.float_(NaN);
l=Math.hypot(l,q);if(!Number.isFinite(l))throw new Sk.builtin.OverflowError("absolute value too large");return new Sk.builtin.float_(l)}},getsets:{real:{$get(){return new Sk.builtin.float_(this.real)},$doc:"the real part of a complex number"},imag:{$get(){return new Sk.builtin.float_(this.imag)},$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth(){return new Sk.builtin.complex(this.real,-this.imag)},$flags:{NoArgs:!0},$textsig:null,$doc:"complex.conjugate() -> complex\n\nReturn the complex conjugate of its argument. (3-4j).conjugate() == 3+4j."},
__getnewargs__:{$meth(){return new Sk.builtin.tuple([new Sk.builtin.float_(this.real),new Sk.builtin.float_(this.imag)])},$flags:{NoArgs:!0},$textsig:null,$doc:Sk.builtin.none.none$},__format__:{$meth(l){if(Sk.builtin.checkString(l))throw new Sk.builtin.NotImplementedError("__format__ is not implemented for complex type.");throw new Sk.builtin.TypeError("__format__ requires str");},$flags:{OneArg:!0},$textsig:null,$doc:"complex.__format__() -> str\n\nConvert to a string according to format_spec."}}});
Sk.exportSymbol("Sk.builtin.complex",Sk.builtin.complex);const a=Sk.builtin.checkComplex,c=/_[eE]|[eE]_|\._|_\.|[+-]_|_j|j_/,n=/_(?=[^_])/g;Sk.builtin.complex.complex_subtype_from_string=function(l,q){q=q||Sk.builtin.complex.prototype;var z=0,r=0,t=!1;if(Sk.builtin.checkString(l))l=Sk.ffi.remapToJs(l);else if("string"!==typeof l)throw new TypeError("provided unsupported string-alike argument");if(-1!==l.indexOf("\x00")||0===l.length||""===l)throw new Sk.builtin.ValueError("complex() arg is a malformed string");
var x=0;l=l.replace(/inf|infinity/gi,"Infinity");for(l=l.replace(/nan/gi,"NaN");" "===l[x];)x++;if("("===l[x])for(t=!0,x++;" "===l[x];)x++;if(-1!==l.indexOf("_")){if(c.test(l))throw new Sk.builtin.ValueError("could not convert string to complex: '"+l+"'");l=l.charAt(0)+l.substring(1).replace(n,"")}var v=/^(?:[+-]?(?:(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[eE][+-]?\d+)?|NaN|Infinity))/;var B=l.substr(x);var I=B.match(v);if(null!==I)if(x+=I[0].length,"j"===l[x]||"J"===l[x])r=parseFloat(I[0]),x++;else if("+"===
l[x]||"-"===l[x]){z=parseFloat(I[0]);I=l.substr(x).match(v);null!==I?(r=parseFloat(I[0]),x+=I[0].length):(r="+"===l[x]?1:-1,x++);if("j"!==l[x]&&"J"!==l[x])throw new Sk.builtin.ValueError("complex() arg is malformed string");x++}else z=parseFloat(I[0]);else I=I=B.match(/^([+-]?[jJ])/),null!==I&&(r=1===I[0].length?1:"+"===I[0][0]?1:-1,x+=I[0].length);for(;" "===l[x];)x++;if(t){if(")"!==l[x])throw new Sk.builtin.ValueError("complex() arg is malformed string");for(x++;" "===l[x];)x++}if(l.length!==x)throw new Sk.builtin.ValueError("complex() arg is malformed string");
return e(z,r,q)};const m=(l,q,z,r)=>{const t=z|0;return 0===r&&z===t?(100<t||-100>t?l=h(l,q,t,0):0<t?l=p(l,q,t):(l=p(l,q,-t),l=f(1,0,l.real,l.imag)),l):h(l,q,z,r)},k=d(m),u=d((l,q,z,r)=>m(z,r,l,q));g.Py_DTSF_SIGN=1;g.Py_DTSF_ADD_DOT_0=2;g.Py_DTSF_ALT=4;g.Py_DTST_FINITE=0;g.Py_DTST_INFINITE=1;g.Py_DTST_NAN=2},function(F,P){Sk.builtin.slice=Sk.abstr.buildNativeClass("slice",{constructor:function(b,e,d){void 0===e&&void 0===d&&(e=b,b=Sk.builtin.none.none$);void 0===e&&(e=Sk.builtin.none.none$);void 0===
d&&(d=Sk.builtin.none.none$);this.start=b;this.stop=e;this.step=d},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"slice(stop)\nslice(start, stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",tp$hash:Sk.builtin.none.none$,tp$new(b,e){Sk.abstr.checkNoKwargs("slice",e);Sk.abstr.checkArgsLen("slice",b,1,3);return new Sk.builtin.slice(...b)},$r(){const b=Sk.misceval.objectRepr(this.start),e=Sk.misceval.objectRepr(this.stop),d=Sk.misceval.objectRepr(this.step);return new Sk.builtin.str("slice("+
b+", "+e+", "+d+")")},tp$richcompare(b,e){if(b.ob$type!==Sk.builtin.slice)return Sk.builtin.NotImplemented.NotImplemented$;const d=new Sk.builtin.tuple([this.start,this.stop,this.step]);b=new Sk.builtin.tuple([b.start,b.stop,b.step]);return d.tp$richcompare(b,e)}},getsets:{start:{$get(){return this.start}},step:{$get(){return this.step}},stop:{$get(){return this.stop}}},methods:{indices:{$meth:function(b){b=Sk.misceval.asIndexSized(b,Sk.builtin.OverflowError);if(0>b)throw new Sk.builtin.TypeError("length should not be negative");
const {start:e,stop:d,step:f}=this.slice$indices(b);return new Sk.builtin.tuple([new Sk.builtin.int_(e),new Sk.builtin.int_(d),new Sk.builtin.int_(f)])},$doc:"S.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop\nindices, and the stride length of the extended slice described by\nS. Out of bounds indices are clipped in a manner consistent with the\nhandling of normal slices.",$textsig:null,$flags:{OneArg:!0}}},proto:{slice$as_indices(b){let e;var d=
b?f=>Sk.misceval.asIndexSized(f,null,"slice indices must be integers or None or have an __index__ method"):f=>Sk.misceval.asIndexOrThrow(f,"slice indices must be integers or None or have an __index__ method");if(Sk.builtin.checkNone(this.step))e=1;else if(e=d(this.step),0===e)throw new Sk.builtin.ValueError("slice step cannot be zero");b=Sk.builtin.checkNone(this.start)?null:d(this.start);d=Sk.builtin.checkNone(this.stop)?null:d(this.stop);return{start:b,stop:d,step:e}},$wrt(b,e,d,f,h){h=h?p=>JSBI.__isBigInt(p)?
JSBI.add(p,JSBI.BigInt(b)):p+b:p=>p+b;0<f?(null===e?e=0:0>e&&(e=h(e),0>e&&(e=0)),null===d?d=b:d>b?d=b:0>d&&(d=h(d))):(null===e?e=b-1:e>=b?e=b-1:0>e&&(e=h(e)),null===d?d=-1:0>d&&(d=h(d),0>d&&(d=-1)));return{start:e,stop:d,step:f}},slice$indices(b,e){let {start:d,stop:f,step:h}=this.slice$as_indices(!0,e);return this.$wrt(b,d,f,h,e)},sssiter$(b,e){let {start:d,stop:f,step:h}=this.slice$indices(b,!0);if(0<h)for(b=d;b<f;b+=h)e(b);else for(b=d;b>f;b+=h)e(b)}},flags:{sk$unacceptableBase:!0}});Sk.builtin.slice.startEnd$wrt=
function(b,e,d){b=b.sq$length();void 0===e||Sk.builtin.checkNone(e)?e=0:(e=Sk.misceval.asIndexSized(e,null,"slice indices must be integers or have an __index__ method"),0>e&&(e+=b,0>e&&(e=0)));void 0===d||Sk.builtin.checkNone(d)?d=b:(d=Sk.misceval.asIndexSized(d,null,"slice indices must be integers or have an __index__ method"),0>d?(d+=b,0>d&&(d=0)):d>b&&(d=b));return{start:e,end:d}}},function(F,P){function b(f){return function(h){return Sk.builtin.checkAnySet(h)?f.call(this,h):Sk.builtin.NotImplemented.NotImplemented$}}
function e(f){f instanceof Sk.builtin.set&&f.tp$hash===Sk.builtin.none.none$&&(f=new Sk.builtin.frozenset(Sk.misceval.arrayFromIterable(f)));return f}F={};Sk.builtin.set=Sk.abstr.buildNativeClass("set",{constructor:function(f){void 0===f?f=[]:Array.isArray(f)||(f=Sk.misceval.arrayFromIterable(f));Sk.asserts.assert(this instanceof Sk.builtin.set,"Bad call to set - must be called with an Array and 'new'");const h=[];for(let p=0;p<f.length;p++)h.push(f[p]),h.push(!0);this.v=new Sk.builtin.dict(h);this.in$repr=
!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"set() -> new empty set object\nset(iterable) -> new set object\n\nBuild an unordered collection of unique elements.",tp$init(f,h){Sk.abstr.checkNoKwargs("set",h);Sk.abstr.checkArgsLen("set",f,0,1);this.set$clear();return(f=f[0])&&this.set$update(f)},tp$new:Sk.generic.new,$r(){if(this.in$repr)return new Sk.builtin.str(Sk.abstr.typeName(this)+"(...)");this.in$repr=!0;const f=this.sk$asarray().map(h=>
Sk.misceval.objectRepr(h));this.in$repr=!1;return Sk.__future__.python3?0===f.length?new Sk.builtin.str(Sk.abstr.typeName(this)+"()"):this.ob$type!==Sk.builtin.set?new Sk.builtin.str(Sk.abstr.typeName(this)+"({"+f.join(", ")+"})"):new Sk.builtin.str("{"+f.join(", ")+"}"):new Sk.builtin.str(Sk.abstr.typeName(this)+"(["+f.join(", ")+"])")},tp$iter(){return new d(this)},tp$richcompare(f,h){if(!Sk.builtin.checkAnySet(f))return Sk.builtin.NotImplemented.NotImplemented$;switch(h){case "NotEq":case "Eq":return f=
this===f?!0:this.get$size()!==f.get$size()?!1:Sk.misceval.isTrue(this.set$issubset(f)),"Eq"===h?f:!f;case "LtE":return this===f||Sk.misceval.isTrue(this.set$issubset(f));case "GtE":return this===f||Sk.misceval.isTrue(f.set$issubset(this));case "Lt":return this.get$size()<f.get$size()&&Sk.misceval.isTrue(this.set$issubset(f));case "Gt":return this.get$size()>f.get$size()&&Sk.misceval.isTrue(f.set$issubset(this))}},nb$subtract:b(function(f){return this.difference.$meth.call(this,f)}),nb$and:b(function(f){return this.intersection.$meth.call(this,
f)}),nb$or:b(function(f){return this.union.$meth.call(this,f)}),nb$xor:b(function(f){return this.symmetric_difference.$meth.call(this,f)}),nb$inplace_subtract:b(function(f){f===this&&(f=f.set$copy());return Sk.misceval.chain(this.difference_update.$meth.call(this,f),()=>this)}),nb$inplace_and:b(function(f){return Sk.misceval.chain(this.intersection_update.$meth.call(this,f),()=>this)}),nb$inplace_or:b(function(f){return Sk.misceval.chain(this.update.$meth.call(this,f),()=>this)}),nb$inplace_xor:b(function(f){f===
this&&(f=f.set$copy());return Sk.misceval.chain(this.symmetric_difference_update.$meth.call(this,f),()=>this)}),sq$length(){return this.get$size()},sq$contains(f){f=e(f);return this.v.sq$contains(f)}},methods:{add:{$meth(f){this.set$add(f);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Add an element to a set.\n\nThis has no effect if the element is already present."},clear:{$meth(){this.set$clear();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:"Remove all elements from this set."},
copy:{$meth(){return this.set$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a shallow copy of a set."},discard:{$meth(f){f=e(f);this.set$discard(f);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Remove an element from a set if it is a member.\n\nIf the element is not a member, do nothing."},difference:{$meth(...f){const h=this.set$copy();return Sk.misceval.chain(Sk.misceval.iterArray(f,p=>h.set$difference_update(p)),()=>h)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the difference of two or more sets as a new set.\n\n(i.e. all elements that are in this set but not the others.)"},
difference_update:{$meth(...f){return Sk.misceval.chain(Sk.misceval.iterArray(f,h=>this.set$difference_update(h)),()=>Sk.builtin.none.none$)},$flags:{MinArgs:0},$textsig:null,$doc:"Remove all elements of another set from this set."},intersection:{$meth(...f){return this.set$intersection_multi(...f)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the intersection of two sets as a new set.\n\n(i.e. all elements that are in both sets.)"},intersection_update:{$meth(...f){return Sk.misceval.chain(this.set$intersection_multi(...f),
h=>{this.swap$bodies(h);return Sk.builtin.none.none$})},$flags:{MinArgs:0},$textsig:null,$doc:"Update a set with the intersection of itself and another."},isdisjoint:{$meth(f){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(f),h=>{if(this.sq$contains(h))return new Sk.misceval.Break(Sk.builtin.bool.false$)}),h=>h||Sk.builtin.bool.true$)},$flags:{OneArg:!0},$textsig:null,$doc:"Return True if two sets have a null intersection."},issubset:{$meth(f){Sk.builtin.checkAnySet(f)||(f=this.set$make_basetype(f));
return Sk.misceval.chain(f,h=>this.set$issubset(h))},$flags:{OneArg:!0},$textsig:null,$doc:"Report whether another set contains this set."},issuperset:{$meth(f){Sk.builtin.checkAnySet(f)||(f=this.set$make_basetype(f));return Sk.misceval.chain(f,h=>h.set$issubset(this))},$flags:{OneArg:!0},$textsig:null,$doc:"Report whether this set contains another set."},pop:{$meth(){if(0===this.get$size())throw new Sk.builtin.KeyError("pop from an empty set");return Sk.misceval.callsimArray(this.v.popitem,[this.v]).v[0]},
$flags:{NoArgs:!0},$textsig:null,$doc:"Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."},remove:{$meth(f){const h=e(f);if(this.v.mp$lookup(h))return this.v.mp$ass_subscript(h),Sk.builtin.none.none$;throw new Sk.builtin.KeyError(f);},$flags:{OneArg:!0},$textsig:null,$doc:"Remove an element from a set; it must be a member.\n\nIf the element is not a member, raise a KeyError."},symmetric_difference:{$meth(f){let h;return Sk.misceval.chain(this.set$make_basetype(f),p=>
{h=p;return h.set$symmetric_diff_update(this)},()=>h)},$flags:{OneArg:!0},$textsig:null,$doc:"Return the symmetric difference of two sets as a new set.\n\n(i.e. all elements that are in exactly one of the sets.)"},symmetric_difference_update:{$meth(f){Sk.builtin.checkAnySet(f)||(f=this.set$make_basetype(f));return Sk.misceval.chain(f,h=>this.set$symmetric_diff_update(h),()=>Sk.builtin.none.none$)},$flags:{OneArg:!0},$textsig:null,$doc:"Update a set with the symmetric difference of itself and another."},
union:{$meth(...f){const h=this.set$copy();return Sk.misceval.chain(Sk.misceval.iterArray(f,p=>h.set$update(p)),()=>h)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the union of sets as a new set.\n\n(i.e. all elements that are in either set.)"},update:{$meth(...f){return Sk.misceval.chain(Sk.misceval.iterArray(f,h=>this.set$update(h)),()=>Sk.builtin.none.none$)},$flags:{MinArgs:0},$textsig:null,$doc:"Update a set with the union of itself and others."}},classmethods:Sk.generic.classGetItem,proto:Object.assign(F,
{sk$asarray(){return this.v.sk$asarray()},get$size(){return this.v.sq$length()},set$add(f){this.v.mp$ass_subscript(f,!0)},set$make_basetype(f){return Sk.misceval.chain(Sk.misceval.arrayFromIterable(f,!0),h=>new this.sk$builtinBase(h))},set$discard(f){return this.v.pop$item(f)},set$clear(){this.v=new Sk.builtin.dict([])},set$copy(){const f=new this.sk$builtinBase;f.v=this.v.dict$copy();return f},set$difference_update(f){return Sk.misceval.iterFor(Sk.abstr.iter(f),h=>{this.set$discard(h)})},set$intersection(f){const h=
new this.sk$builtinBase;return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(f),p=>{this.sq$contains(p)&&h.set$add(p)}),()=>h)},set$intersection_multi(...f){if(!f.length)return this.set$copy();let h=this;return Sk.misceval.chain(Sk.misceval.iterArray(f,p=>Sk.misceval.chain(h.set$intersection(p),g=>{h=g})),()=>h)},set$issubset(f){const h=this.get$size(),p=f.get$size();if(h>p)return Sk.builtin.bool.false$;for(let g=this.tp$iter(),a=g.tp$iternext();void 0!==a;a=g.tp$iternext())if(!f.sq$contains(a))return Sk.builtin.bool.false$;
return Sk.builtin.bool.true$},set$symmetric_diff_update(f){return Sk.misceval.iterFor(Sk.abstr.iter(f),h=>{void 0===this.set$discard(h)&&this.set$add(h)})},set$update(f){return Sk.misceval.iterFor(Sk.abstr.iter(f),h=>{this.set$add(h)})},swap$bodies(f){this.v=f.v}})});Sk.exportSymbol("Sk.builtin.set",Sk.builtin.set);P=Sk.builtin.set.prototype;Sk.builtin.frozenset=Sk.abstr.buildNativeClass("frozenset",{constructor:function(f){void 0===f?f=[]:Array.isArray(f)||(f=Sk.misceval.arrayFromIterable(f));Sk.asserts.assert(this instanceof
Sk.builtin.frozenset,"bad call to frozen set - must be called with 'new'");const h=[];for(let p=0;p<f.length;p++)h.push(f[p]),h.push(!0);this.v=new Sk.builtin.dict(h);this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$doc:"frozenset() -> empty frozenset object\nfrozenset(iterable) -> frozenset object\n\nBuild an immutable unordered collection of unique elements.",tp$hash(){let f=1927868237;const h=this.sk$asarray();f*=h.length+1;for(let p=0;p<h.length;p++){const g=
Sk.abstr.objectHash(h[p]);f^=3644798167*(g^g<<16^89869747)}return 69069*f+907133923},tp$new(f,h){if(this!==Sk.builtin.frozenset.prototype)return this.$subtype_new(f,h);Sk.abstr.checkNoKwargs("frozenset",h);Sk.abstr.checkArgsLen("frozenset",f,0,1);f=f[0];return void 0!==f&&f.ob$type===Sk.builtin.frozenset?f:Sk.misceval.chain(Sk.misceval.arrayFromIterable(f,!0),p=>p.length?new Sk.builtin.frozenset(p):Sk.builtin.frozenset.$emptyset)},$r:P.$r,tp$iter:P.tp$iter,tp$richcompare:P.tp$richcompare,nb$subtract:P.nb$subtract,
nb$and:P.nb$and,nb$or:P.nb$or,nb$xor:P.nb$xor,sq$length:P.sq$length,sq$contains:P.sq$contains},methods:{copy:Object.assign({},P.copy.d$def,{$meth(){return this.constructor===this.sk$builtinBase?this:new Sk.builtin.frozenset(this.sk$asarray())}}),difference:P.difference.d$def,intersection:P.intersection.d$def,isdisjoint:P.isdisjoint.d$def,issubset:P.issubset.d$def,issuperset:P.issuperset.d$def,symmetric_difference:P.symmetric_difference.d$def,union:P.union.d$def},classmethods:Sk.generic.classGetItem,
proto:Object.assign({$subtype_new(f,h){const p=new this.constructor;return Sk.misceval.chain(Sk.builtin.frozenset.prototype.tp$new(f),g=>{p.v=g.v;return p})}},F)});Sk.builtin.frozenset.$emptyset=new Sk.builtin.frozenset([]);Sk.exportSymbol("Sk.builtin.frozenset",Sk.builtin.frozenset);var d=Sk.abstr.buildIteratorClass("set_iterator",{constructor:function(f){this.$index=0;this.$seq=f.sk$asarray();this.$orig=f},iternext:Sk.generic.iterNextWithArrayCheckSize,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},
flags:{sk$unacceptableBase:!0}})},function(F,P){Sk.builtin.print=function(b,e){let [d,f,h]=Sk.abstr.copyKeywordsToNamedArgs("print",["sep","end","file","flush"],[],e);if(void 0===d||Sk.builtin.checkNone(d))d=" ";else if(Sk.builtin.checkString(d))d=d.$jsstr();else throw new Sk.builtin.TypeError("sep must be None or a string, not "+Sk.abstr.typeName(d));if(void 0===f||Sk.builtin.checkNone(f))f="\n";else if(Sk.builtin.checkString(f))f=f.$jsstr();else throw new Sk.builtin.TypeError("end must be None or a string, not "+
Sk.abstr.typeName(f));let p;if(void 0!==h&&!Sk.builtin.checkNone(h)&&(p=Sk.abstr.lookupSpecial(h,Sk.builtin.str.$write),void 0===p))throw new Sk.builtin.AttributeError("'"+Sk.abstr.typeName(h)+"' object has no attribute 'write'");const g=new Sk.builtin.str(b.map(a=>(new Sk.builtin.str(a)).toString()).join(d)+f);if(void 0!==p)Sk.misceval.callsimArray(p,[g]);else return Sk.misceval.chain(Sk.importModule("sys",!1,!0),a=>(p=Sk.abstr.lookupSpecial(a.$d.stdout,Sk.builtin.str.$write))&&Sk.misceval.callsimOrSuspendArray(p,
[g]))};Sk.builtin.print.co_fastcall=1},function(F,P){Sk.builtin.module=Sk.abstr.buildNativeClass("module",{constructor:function(){this.$d={}},slots:{tp$doc:"Create a module object.\n\nThe name must be a string; the optional doc argument can have any type.",tp$getattr(b,e){var d=this.$d[b.$mangled];if(void 0!==d)return d;d=this.ob$type.$typeLookup(b);if(void 0!==d){const h=d.tp$descr_get;return h?h.call(d,this,this.ob$type,e):d}const f=this.$d.__getattr__;if(void 0!==f)return d=Sk.misceval.tryCatch(()=>
Sk.misceval.callsimOrSuspendArray(f,[b]),h=>{if(!(h instanceof Sk.builtin.AttributeError))throw h;}),e?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)},tp$setattr:Sk.generic.setAttr,tp$new:Sk.generic.new,tp$init(b,e){const [d,f]=Sk.abstr.copyKeywordsToNamedArgs("module",["name","doc"],b,e,[Sk.builtin.none.none$]);Sk.builtin.pyCheckType("module","string",d);this.init$dict(d,f)},$r(){let b=this.get$name();if(void 0!==b){var e=this.get$mod_reprf();if(void 0!==e)return Sk.misceval.callsimOrSuspendArray(e,
[this])}b=void 0===b?"'?'":b;e=this.from$file();e=void 0===e?this.empty_or$loader():e;return new Sk.builtin.str("<module "+b+e+">")}},getsets:{__dict__:{$get(){return new Sk.builtin.mappingproxy(this.$d)}}},methods:{__dir__:{$meth(){const b=this.tp$getattr(Sk.builtin.str.$dict);if(!Sk.builtin.checkMapping(b))throw new Sk.builtin.TypeError("__dict__ is not a dictionary");const e=b.mp$lookup(Sk.builtin.str.$dir);return void 0!==e?Sk.misceval.callsimOrSuspendArray(e,[]):new Sk.builtin.list(Sk.misceval.arrayFromIterable(b))},
$flags:{NoArgs:!0},$doc:"__dir__() -> list\nspecialized dir() implementation"}},proto:{sk$hasDict:!0,init$dict(b,e){this.$d.__name__=b;this.$d.__doc__=e;this.$d.__package__=Sk.builtin.none.none$;this.$d.__spec__=Sk.builtin.none.none$;this.$d.__loader__=Sk.builtin.none.none$},sk$attrError(){let b=this.get$name();b=void 0===b?"module":"module "+b;this.$initializing&&(b="(most likely due to a circular import) partially initialized "+b);return b},get$name(){const b=this.tp$getattr(Sk.builtin.str.$name);
return b&&Sk.misceval.objectRepr(b)},from$file(){const b=this.tp$getattr(Sk.builtin.str.$file);return b&&" from "+Sk.misceval.objectRepr(b)},empty_or$loader(){if(this.$js&&this.$js.includes("$builtinmodule"))return" (built-in)";const b=this.tp$getattr(Sk.builtin.str.$loader);return void 0===b||Sk.builtin.checkNone(b)?"":" ("+Sk.misceval.objectRepr(b)+")"},get$mod_reprf(){const b=this.tp$getattr(Sk.builtin.str.$loader);return b&&b.tp$getattr(this.str$mod_repr)},str$mod_repr:new Sk.builtin.str("module_repr")}});
Sk.exportSymbol("Sk.builtin.module",Sk.builtin.module)},function(F,P){Sk.builtin.structseq_types={};Sk.builtin.make_structseq=function(b,e,d,f,h){f=void 0===f?{}:f;h=void 0===h?null:h;const p=b+"."+e,g=[],a={};Object.keys(d).forEach((k,u)=>{g.push(k);a[k]={$get(){return this.v[u]},$doc:d[k]}});const c=g.length;let n=c;Object.keys(f).forEach((k,u)=>{a[k]={$get(){return this.$hidden[u]||Sk.builtin.none.none$},$doc:f[k]};n++});var m=Sk.abstr.buildNativeClass(p,{constructor:function(k,u){Sk.asserts.assert(this instanceof
m);Sk.builtin.tuple.call(this,k);this.$hidden=u||[]},base:Sk.builtin.tuple,slots:{tp$new(k,u){Sk.abstr.checkOneArg(p,k,u);k=Sk.misceval.arrayFromIterable(k[0]);if(k.length<c)throw new Sk.builtin.TypeError(p+"() takes an at least "+c+"-sequence ("+k.length+"-sequence given)");if(k.length>n)throw new Sk.builtin.TypeError(p+"() takes an at most "+n+"-sequence ("+k.length+"-sequence given)");return new m(k.slice(0,c),k.slice(c))},tp$doc:h?h:Sk.builtin.none.none$,$r(){var k;if(0===this.v.length)return new Sk.builtin.str(p+
"()");var u=[];for(k=0;k<g.length;++k)u[k]=g[k]+"="+Sk.misceval.objectRepr(this.v[k]);k=u.join(", ");1===this.v.length&&(k+=",");return new Sk.builtin.str(p+"("+k+")")}},methods:{__reduce__:{$meth(){throw new Sk.builtin.NotImplementedError("__reduce__ is not implemented");},$flags:{NoArgs:!0}}},getsets:a,proto:{num_sequence_fields:new Sk.builtin.int_(c)}});return m};Sk.exportSymbol("Sk.builtin.make_structseq",Sk.builtin.make_structseq)},function(F,P){Sk.builtin.generator=Sk.abstr.buildIteratorClass("generator",
{constructor:function(b,e,d,f,h){var p;if(b){if(!(this instanceof Sk.builtin.generator))throw new TypeError("bad internal call to generator, use 'new'");this.func_code=b;this.func_globals=e||null;this.gi$running=!1;this.gi$resumeat=0;this.gi$sentvalue=Sk.builtin.none.none$;this.gi$locals={};this.gi$cells={};if(0<d.length)for(e=0;e<b.co_varnames.length;++e)this.gi$locals[b.co_varnames[e]]=d[e];if(void 0!==h)for(p in h)f[p]=h[p];this.func_closure=f}},slots:{$r(){return new Sk.builtin.str("<generator object "+
this.func_code.co_name.v+">")}},iternext(b,e){var d=this;if(this.gi$running)throw new Sk.builtin.ValueError("generator already executing");this.gi$running=!0;void 0===e&&(e=Sk.builtin.none.none$);this.gi$sentvalue=e;e=[this];this.func_closure&&e.push(this.func_closure);return function p(h){if(h instanceof Sk.misceval.Suspension){if(b)return new Sk.misceval.Suspension(p,h);h=Sk.misceval.retryOptionalSuspensionOrThrow(h)}d.gi$running=!1;Sk.asserts.assert(void 0!==h);if(Array.isArray(h))return d.gi$resumeat=
h[0],h=h[1];d.gi$ret=h}(this.func_code.apply(this.func_globals,e))},methods:{send:{$meth(b){return Sk.misceval.chain(this.tp$iternext(!0,b),e=>{if(void 0===e)throw e=this.gi$ret,void 0!==e&&e!==Sk.builtin.none.none$?new Sk.builtin.StopIteration(e):new Sk.builtin.StopIteration;return e})},$flags:{OneArg:!0},$doc:"send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration."}}});Sk.exportSymbol("Sk.builtin.generator",Sk.builtin.generator);Sk.builtin.makeGenerator=function(b,
e){var d,f=new Sk.builtin.generator(null,null,null);f.tp$iternext=b;for(d in e)e.hasOwnProperty(d)&&(f[d]=e[d]);return f};Sk.exportSymbol("Sk.builtin.makeGenerator",Sk.builtin.makeGenerator)},function(F,P){Sk.builtin.file=function(b,e,d){var f;if(!(this instanceof Sk.builtin.file))return new Sk.builtin.file(b,e,d);this.mode=e;this.name=Sk.ffi.remapToJs(b);this.closed=!1;if("/dev/stdout"===this.name)this.data$=Sk.builtin.none.none$,this.fileno=1;else if("/dev/stdin"===this.name)this.fileno=0;else if("/dev/stderr"===
this.name)this.fileno=2;else{if("w"===Sk.ffi.remapToJs(this.mode))this.fileno=Sk.builtin.file.currentFileno++;else for(f in this.fileno=Sk.inBrowser?10:11,this.data$=Sk.read(b.v),this.lineList=this.data$.split("\n"),this.lineList=this.lineList.slice(0,-1),this.lineList)this.lineList[f]+="\n";this.currentLine=0}this.pos$=0;Sk.fileopen&&10<=this.fileno&&Sk.fileopen(this);return this};Sk.builtin.file.currentFileno=12;Sk.abstr.setUpInheritance("file",Sk.builtin.file,Sk.builtin.object);Sk.abstr.setUpBuiltinMro(Sk.builtin.file);
Sk.builtin.file.prototype.$r=function(){return new Sk.builtin.str("<"+(this.closed?"closed":"open")+"file '"+this.name+"', mode '"+Sk.ffi.remapToJs(this.mode)+"'>")};Sk.builtin.file.prototype.tp$iter=function(){var b={tp$iter:function(){return b},$obj:this,$index:this.currentLine,$lines:this.lineList,tp$iternext:function(){if(!(b.$index>=b.$lines.length))return new Sk.builtin.str(b.$lines[b.$index++])}};return b};Sk.abstr.setUpSlots(Sk.builtin.file);Sk.builtin.file.prototype.__enter__=new Sk.builtin.func(function(b){return b});
Sk.builtin.file.prototype.__exit__=new Sk.builtin.func(function(b){return Sk.misceval.callsimArray(Sk.builtin.file.prototype.close,[b])});Sk.builtin.file.prototype.close=new Sk.builtin.func(function(b){b.closed=!0;return Sk.builtin.none.none$});Sk.builtin.file.prototype.flush=new Sk.builtin.func(function(b){});Sk.builtin.file.prototype.fileno=new Sk.builtin.func(function(b){return this.fileno});Sk.builtin.file.prototype.isatty=new Sk.builtin.func(function(b){return!1});Sk.builtin.file.prototype.read=
new Sk.builtin.func(function(b,e){var d=b.data$.length;if(b.closed)throw new Sk.builtin.ValueError("I/O operation on closed file");var f=void 0===e?d:Sk.ffi.remapToJs(e);f=new Sk.builtin.str(b.data$.substr(b.pos$,f));b.pos$=void 0===e?d:b.pos$+Sk.ffi.remapToJs(e);b.pos$>=d&&(b.pos$=d);return f});Sk.builtin.file.$readline=function(b,e,d){if(0===b.fileno){b=Sk.ffi.remapToJs(d);b=Sk.inputfun(b?b:"");if(b instanceof Promise||b&&"function"===typeof b.then){var f=new Sk.misceval.Suspension;f.resume=function(){if(f.data.error)throw f.data.error;
return new Sk.builtin.str(f.data.result)};f.data={type:"Sk.promise",promise:b};return f}return new Sk.builtin.str(b)}e="";b.currentLine<b.lineList.length&&(e=b.lineList[b.currentLine],b.currentLine++);return new Sk.builtin.str(e)};Sk.builtin.file.prototype.readline=new Sk.builtin.func(function(b,e){return Sk.builtin.file.$readline(b,e,void 0)});Sk.builtin.file.prototype.readlines=new Sk.builtin.func(function(b,e){if(0===b.fileno)return new Sk.builtin.NotImplementedError("readlines ins't implemented because the web doesn't support Ctrl+D");
var d=[];for(e=b.currentLine;e<b.lineList.length;e++)d.push(new Sk.builtin.str(b.lineList[e]));return new Sk.builtin.list(d)});Sk.builtin.file.prototype.seek=new Sk.builtin.func(function(b,e,d){e=Sk.ffi.remapToJs(e);void 0===d&&(d=0);0===d?b.pos$=e:1==d?b.pos$=b.data$.length+e:2==d&&(b.pos$=b.data$.length+e);return Sk.builtin.none.none$});Sk.builtin.file.prototype.tell=new Sk.builtin.func(function(b){return Sk.ffi.remapToPy(b.pos$)});Sk.builtin.file.prototype.truncate=new Sk.builtin.func(function(b,
e){Sk.asserts.fail()});Sk.builtin.file.prototype.write=new Sk.builtin.func(function(b,e){var d=Sk.ffi.remapToJs(b.mode);Sk.ffi.remapToJs(e);if("w"===d||"wb"===d||"a"===d||"ab"===d)if(Sk.filewrite){if(b.closed)throw new Sk.builtin.ValueError("I/O operation on closed file");1===b.fileno?Sk.output(Sk.ffi.remapToJs(e)):Sk.filewrite(b,e)}else 1===b.fileno?Sk.output(Sk.ffi.remapToJs(e)):Sk.asserts.fail();return Sk.builtin.none.none$});Sk.exportSymbol("Sk.builtin.file",Sk.builtin.file)},function(F,P){function b(v,
B){if(null===v||void 0===v)return Sk.builtin.none.none$;if(v.sk$object)return v;if(v.$isPyWrapped&&v.unwrap)return v.unwrap();var I=typeof v;B=B||{};if("string"===I)return new Sk.builtin.str(v);if("number"===I)return h(v);if("boolean"===I)return new Sk.builtin.bool(v);if("function"===I)return B.funcHook?B.funcHook(v):a(v);if(JSBI.__isBigInt(v))return new Sk.builtin.int_(JSBI.numberIfSafe(v));if(Array.isArray(v))return new Sk.builtin.list(v.map(M=>b(M,B)));if("object"===I){I=v.constructor;if(I===Object&&
Object.getPrototypeOf(v)===c||void 0===I)return B.dictHook?B.dictHook(v):g(v,B);if(I===Uint8Array)return new Sk.builtin.bytes(v);if(I===Set)return p(v,B);if(I===Map){const M=new Sk.builtin.dict;v.forEach((S,E)=>{M.mp$ass_subscript(b(E,B),b(S,B))});return M}return I===Sk.misceval.Suspension?v:B.proxyHook?B.proxyHook(v):a(v)}if(B.unhandledHook)return B.unhandledHook(v);Sk.asserts.fail("unhandled remap case of type "+I)}function e(v,B){if(void 0===v||null===v)return v;const I=v.valueOf();if(null===I)return I;
const M=typeof I;B=B||{};if("string"===M)return B.stringHook?B.stringHook(I):I;if("boolean"===M)return I;if("number"===M)return B.numberHook?B.numberHook(I,v):I;if(JSBI.__isBigInt(I))return B.bigintHook?B.bigintHook(I,v):I;if(Array.isArray(I))return B.arrayHook?B.arrayHook(I,v):I.map(S=>e(S,B));if(I.sk$object)return v instanceof Sk.builtin.dict?B.dictHook?B.dictHook(v):f(v,B):v instanceof Sk.builtin.set?B.setHook?B.setHook(v):new Set(d(v,B)):B.unhandledHook?B.unhandledHook(v):void 0;if("object"===
M)return B.objectHook?B.objectHook(I,v):I;if("function"===M)return B.funcHook?B.funcHook(I,v):I;Sk.asserts.fail("unhandled type "+M)}function d(v,B){return Array.from(v,I=>e(I,B))}function f(v,B){const I={};v.$items().forEach(M=>{var [S,E]=M;I[S.valueOf()]=e(E,B)});return I}function h(v){return Number.isInteger(v)?Math.abs(v)<Number.MAX_SAFE_INTEGER?new Sk.builtin.int_(v):new Sk.builtin.int_(JSBI.BigInt(v)):new Sk.builtin.float_(v)}function p(v,B){return new Sk.builtin.set(Array.from(v,I=>b(I,B)))}
function g(v,B){const I=new Sk.builtin.dict;Object.entries(v).forEach(M=>{var [S,E]=M;I.mp$ass_subscript(new Sk.builtin.str(S),b(E,B))});return I}function a(v,B){if(null===v||void 0===v)return Sk.builtin.none.none$;var I=typeof v;if("object"!==I&&"function"!==I)return b(v);B=B||{};if(I=k.get(v)){if(B.bound===I.$bound)return I;B.name||(B.name=I.$name)}B=new z(v,B);k.set(v,B);return B}Sk.ffi={remapToPy:b,remapToJs:e,toPy:b,toJs:e,isTrue:function(v){return null!=v&&v.nb$bool?v.nb$bool():v.sq$length?
0!==v.sq$length():!!v},toJsString:function(v){return String(v)},toJsNumber:function(v){return Number(v)},toJsArray:d,toJsHashMap:f,toPyDict:g,toPyFloat:function(v){return new Sk.builtin.float_(Number(v))},toPyInt:function(v){if("number"===typeof v)return v=Math.trunc(v),Math.abs(v)<Number.MAX_SAFE_INTEGER?new Sk.builtin.int_(v):new Sk.builtin.int_(JSBI.BigInt(v));if(JSBI.__isBigInt(v))return new Sk.builtin.int_(JSBI.numberIfSafe(v));if("string"===typeof v&&v.match(m))return new Sk.builtin.int_(v);
throw new TypeError("bad type passed to toPyInt() got "+v);},toPyNumber:function(v){const B=typeof v;return"number"===B?h(v):"string"===B?v.match(m)?new Sk.builtin.int_(v):new Sk.builtin.float_(parseFloat(v)):JSBI.__isBigInt(v)?new Sk.builtin.int_(JSBI.numberIfSafe(v)):new Sk.builtin.float_(Number(v))},toPyStr:function(v){return new Sk.builtin.str(v)},toPyList:function(v,B){return new Sk.builtin.list(Array.from(v,I=>b(I,B)))},toPyTuple:function(v,B){return new Sk.builtin.tuple(Array.from(v,I=>b(I,
B)))},toPySet:p,numberToPy:h,proxy:a};const c=Object.prototype,n=Function.prototype,m=/^-?\d+$/,k=new WeakMap,u={dictHook:v=>a(v),unhandledHook:v=>String(v)},l=(v,B)=>({dictHook:I=>a(I),funcHook:I=>a(I,{bound:v,name:B}),unhandledHook:I=>String(I)}),q={unhandledHook:v=>{var B=k.get(v);if(B)return B;B={v,$isPyWrapped:!0,unwrap:()=>v};if(void 0===v.tp$call)return k.set(v,B),B;const I=(...M)=>{M=M.map(E=>b(E,u));let S=Sk.misceval.tryCatch(()=>Sk.misceval.chain(v.tp$call(M),E=>e(E,q)),E=>{if(Sk.uncaughtException)Sk.uncaughtException(E);
else throw E;});for(;S instanceof Sk.misceval.Suspension;){if(!S.optional)return Sk.misceval.asyncToPromise(()=>S);S=S.resume()}return S};k.set(v,Object.assign(I,B));return I}},z=Sk.abstr.buildNativeClass("Proxy",{constructor:function(v,B){if(void 0===v)throw new Sk.builtin.TypeError("Proxy cannot be called from python");this.js$wrapped=v;this.$module=null;this.$methods=Object.create(null);this.in$repr=!1;B||(B={});Object.defineProperties(this,this.memoized$slots);"function"===typeof v?(this.is$callable=
!0,this.$bound=B.bound,this.$name=B.name||v.name||"(native JS)",2>=this.$name.length&&(this.$name+=" (native JS)")):(this.is$callable=!1,delete this.is$type,this.is$type=!1,this.$name=B.name)},slots:{tp$doc:"proxy for a javascript object",tp$hash(){return Sk.builtin.object.prototype.tp$hash.call(this.js$wrapped)},tp$getattr(v){return this.$lookup(v)||Sk.generic.getAttr.call(this,v)},tp$setattr(v,B){v=v.toString();void 0===B?delete this.js$wrapped[v]:this.js$wrapped[v]=e(B,q)},$r(){if(this.is$callable){if(this.is$type||
!this.$bound)return new Sk.builtin.str("<"+this.tp$name+" '"+this.$name+"'>");var v=Sk.misceval.objectRepr(a(this.$bound));return new Sk.builtin.str("<bound "+this.tp$name+" '"+this.$name+"' of "+v+">")}if(this.js$proto===c){if(this.in$repr)return new Sk.builtin.str("{...}");this.in$repr=!0;v=Object.entries(this.js$wrapped).map(B=>{var [I,M]=B;M=b(M,l(this.js$wrapped,I));return"'"+I+"': "+Sk.misceval.objectRepr(M)});v=new Sk.builtin.str("proxyobject({"+v.join(", ")+"})");this.in$repr=!1;return v}return new Sk.builtin.str("<"+
this.tp$name+" "+("proxyobject"===this.tp$name?"object":"proxyobject")+">")},tp$as_sequence_or_mapping:!0,mp$subscript(v){const B=this.$lookup(v);if(void 0===B)throw new Sk.builtin.LookupError(v);return B},mp$ass_subscript(v,B){return this.tp$setattr(v,B)},sq$contains(v){return e(v)in this.js$wrapped},ob$eq(v){return this.js$wrapped===v.js$wrapped},ob$ne(v){return this.js$wrapped!==v.js$wrapped},tp$as_number:!0,nb$bool(){return this.js$proto===c?0<Object.keys(this.js$wrapped).length:this.sq$length?
0<this.sq$length():!0}},methods:{__dir__:{$meth(){const v=Sk.misceval.callsimArray(Sk.builtin.type.prototype.__dir__,[z]).valueOf();return new Sk.builtin.list(v.concat(Array.from(this.$dir,B=>new Sk.builtin.str(B))))},$flags:{NoArgs:!0}},__new__:{$meth(v,...B){if(!(v instanceof z))throw new Sk.builtin.TypeError("expected a proxy object as the first argument not "+Sk.abstr.typeName(v));try{return v.$new(B)}catch(I){if(I instanceof TypeError&&I.message.includes("not a constructor"))throw new Sk.builtin.TypeError(Sk.misceval.objectRepr(v)+
" is not a constructor");throw I;}},$flags:{MinArgs:1}},__call__:{$meth(v,B){if("function"!==typeof this.js$wrapped)throw new Sk.builtin.TypeError("'"+this.tp$name+"' object is not callable");return this.$call(v,B)},$flags:{FastCall:!0}},keys:{$meth(){return new Sk.builtin.list(Object.keys(this.js$wrapped).map(v=>new Sk.builtin.str(v)))},$flags:{NoArgs:!0}},get:{$meth(v,B){return this.$lookup(v)||B||Sk.builtin.none.none$},$flags:{MinArgs:1,MaxArgs:2}}},getsets:{__class__:{$get(){return b(this.js$wrapped.constructor,
u)},$set(){throw new Sk.builtin.TypeError("not writable");}},__name__:{$get(){return new Sk.builtin.str(this.$name)}},__module__:{$get(){return this.$module||Sk.builtin.none.none$},$set(v){this.$module=v}}},proto:{valueOf(){return this.js$wrapped},$new(v,B){Sk.abstr.checkNoKwargs("__new__",B);return b(new this.js$wrapped(...v.map(I=>e(I,q))),{dictHook:I=>a(I),proxyHook:I=>a(I,{name:this.$name})})},$call(v,B){Sk.abstr.checkNoKwargs("__call__",B);return Sk.misceval.chain(this.js$wrapped.apply(this.$bound,
v.map(I=>e(I,q))),I=>I instanceof Promise?Sk.misceval.promiseToSuspension(I):I,I=>b(I,u))},$lookup(v){v=v.toString();const B=this.js$wrapped[v];if(void 0!==B)return b(B,l(this.js$wrapped,v));if(v in this.js$wrapped)return Sk.builtin.none.none$},memoized$slots:{js$proto:{configurable:!0,get(){delete this.js$proto;return this.js$proto=Object.getPrototypeOf(this.js$wrapped)}},$dir:{configurable:!0,get(){const v=[];let B=this.js$wrapped;for(;null!=B&&B!==c&&B!==n;)v.push(...Object.getOwnPropertyNames(B)),
B=Object.getPrototypeOf(B);return new Set(v)}},tp$iter:{configurable:!0,get(){delete this.tp$iter;return void 0!==this.js$wrapped[Symbol.iterator]?this.tp$iter=()=>a(this.js$wrapped[Symbol.iterator]()):this.tp$iter=()=>{throw new Sk.builtin.TypeError(Sk.misceval.objectRepr(this)+" is not iterable");}}},tp$iternext:{configurable:!0,get(){delete this.tp$iternext;if(void 0!==this.js$wrapped.next)return this.tp$iternext=()=>{const v=this.js$wrapped.next().value;return v&&b(v,u)}}},sq$length:{configurable:!0,
get(){delete this.sq$length;if(!this.is$callable&&void 0!==this.js$wrapped.length)return this.sq$length=()=>this.js$wrapped.length}},tp$call:{configurable:!0,get(){delete this.tp$call;if(this.is$callable)return this.tp$call=this.is$type?this.$new:this.$call}},tp$name:{configurable:!0,get(){delete this.tp$name;if(this.is$callable)return this.tp$name=this.is$type?"proxyclass":this.$bound?"proxymethod":"proxyfunction";{const v=this.js$wrapped;let B=v[Symbol.toStringTag]||this.$name||v.constructor&&v.constructor.name||
"proxyobject";"Object"===B?B="proxyobject":2>=B.length&&(B=a(v.constructor).$name);return this.tp$name=B}}},is$type:{configurable:!0,get(){delete this.is$type;var v=this.js$wrapped;const B=v.prototype;if(void 0===B)return this.is$type=v===Sk.global.Proxy;{const I=t.call(v).match(r);v=null===I?null:"class"===I[0]?!0:!x.has(v)}return!0===v?this.is$type=!0:!1===v?this.is$type=!1:1<Object.getOwnPropertyNames(B).length?this.is$type=!0:this.is$type=Object.getPrototypeOf(B)!==c}}}},flags:{sk$acceptable_as_base_class:!1}}),
r=/^class|^function[a-zA-Z\d\(\)\{\s]+\[native code\]\s+\}$/,t=n.toString,x=new Set([Number,String,Symbol,Boolean]);"undefined"!==typeof Sk.global.BigInt&&x.add(Sk.global.BigInt)},function(F,P){function b(h,p,g){h=void 0===h?h:Sk.misceval.asIndexOrThrow(h);p=void 0===p?p:Sk.misceval.asIndexOrThrow(p);g=void 0===g?g:Sk.misceval.asIndexOrThrow(g);if(void 0===p&&void 0===g)p=h,h=0,g=1;else if(void 0===g)g=1;else if(0===g)throw new Sk.builtin.ValueError("range() step argument must not be zero");const a=
[];if("number"===typeof h&&"number"===typeof p&&"number"===typeof g)if(0<g)for(var c=h;c<p;c+=g)a.push(new Sk.builtin.int_(c));else for(c=h;c>p;c+=g)a.push(new Sk.builtin.int_(c));else{h=c=JSBI.BigInt(h);g=JSBI.BigInt(g);p=JSBI.BigInt(p);if(JSBI.greaterThan(g,JSBI.__ZERO))for(;JSBI.lessThan(c,p);)a.push(new Sk.builtin.int_(e(c))),c=JSBI.add(c,g);else for(;JSBI.greaterThan(c,p);)a.push(new Sk.builtin.int_(e(c))),c=JSBI.add(c,g);h=e(h);g=e(g);p=e(p)}return new Sk.builtin.range_(h,p,g,a)}function e(h){return JSBI.lessThan(h,
JSBI.__MAX_SAFE)&&JSBI.greaterThan(h,JSBI.__MIN_SAFE)?JSBI.toNumber(h):h}Sk.builtin.range_=Sk.abstr.buildNativeClass("range",{constructor:function(h,p,g,a){this.start=h;this.stop=p;this.step=g;this.v=a},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"range(stop) -> range object\nrange(start, stop[, step]) -> range object\n\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).",
tp$new(h,p){Sk.abstr.checkNoKwargs("range",p);Sk.abstr.checkArgsLen("range",h,1,3);return b(h[0],h[1],h[2])},$r(){let h="range("+this.start+", "+this.stop;1!=this.step&&(h+=", "+this.step);return new Sk.builtin.str(h+")")},tp$richcompare(h,p){if("Eq"!==p&&"NotEq"!==p||h.ob$type!==Sk.builtin.range_)return Sk.builtin.NotImplemented.NotImplemented$;h=new Sk.builtin.list(h.v);return(new Sk.builtin.list(this.v)).tp$richcompare(h,p)},tp$iter(){return new d(this)},nb$bool(){return 0!==this.v.length},sq$contains(h){const p=
this.v;for(let g=0;g<p.length;g++)if(Sk.misceval.richCompareBool(h,p[g],"Eq"))return!0;return!1},sq$length(){return this.v.length},mp$subscript(h){if(Sk.misceval.isIndex(h)){h=Sk.misceval.asIndexSized(h);0>h&&(h=this.v.length+h);if(0>h||h>=this.v.length)throw new Sk.builtin.IndexError("range object index out of range");return this.v[h]}if(h.constructor===Sk.builtin.slice){const p=[],g=this.v;h.sssiter$(g.length,m=>{p.push(g[m])});let {start:a,stop:c,step:n}=h.slice$indices(g.length);a=Sk.misceval.asIndex(g[a])||
this.start;c=Sk.misceval.asIndex(g[c])||this.stop;n="number"===typeof this.step?n*this.step:JSBI.multiply(this.step,JSBI.BigInt(n));return new Sk.builtin.range_(a,c,n,p)}throw new Sk.builtin.TypeError("range indices must be integers or slices, not "+Sk.abstr.typeName(h));}},getsets:{start:{$get(){return new Sk.builtin.int_(this.start)}},step:{$get(){return new Sk.builtin.int_(this.step)}},stop:{$get(){return new Sk.builtin.int_(this.stop)}}},methods:{__reversed__:{$meth(){return new f(this)},$flags:{NoArgs:!0},
$textsig:null,$doc:"Return a reverse iterator."},count:{$meth(h){let p=0;for(let g=0;g<this.v.length;g++)Sk.misceval.richCompareBool(h,this.v[g],"Eq")&&p++;return new Sk.builtin.int_(p)},$flags:{OneArg:!0},$textsig:null,$doc:"rangeobject.count(value) -> integer -- return number of occurrences of value"},index:{$meth(h){for(let p=0;p<this.v.length;p++)if(Sk.misceval.richCompareBool(h,this.v[p],"Eq"))return new Sk.builtin.int_(p);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(h)+"is not in range");
},$flags:{OneArg:!0},$textsig:null,$doc:"rangeobject.index(value, [start, [stop]]) -> integer -- return index of value.\nRaise ValueError if the value is not present."}},proto:{sk$asarray(){return this.v.slice(0)}},flags:{sk$unacceptableBase:!0}});var d=Sk.abstr.buildIteratorClass("range_iterator",{constructor:function(h){this.$index=0;this.$seq=h.v},iternext(){return this.$seq[this.$index++]},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$unacceptableBase:!0}}),f=
Sk.abstr.buildIteratorClass("range_reverseiterator",{constructor:function(h){this.$seq=h.v;this.$index=this.$seq.length-1},iternext(){return this.$seq[this.$index--]},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef},flags:{sk$unacceptableBase:!0}});Sk.builtin.range=Sk.builtin.xrange=function(h,p,g){h=b(h,p,g);return new Sk.builtin.list(h.v)}},function(F,P){Sk.builtin.enumerate=Sk.abstr.buildIteratorClass("enumerate",{constructor:function(b,e){if(!(this instanceof Sk.builtin.enumerate))throw TypeError("Failed to construct 'enumerate': Please use the 'new' operator");
this.$iterable=b;this.$index=e;return this},iternext(b){const e=Sk.misceval.chain(this.$iterable.tp$iternext(b),d=>{if(void 0!==d)return new Sk.builtin.tuple([new Sk.builtin.int_(this.$index++),d])});return b?e:Sk.misceval.retryOptionalSuspensionOrThrow(e)},slots:{tp$doc:"Return an enumerate object.\n\n  iterable\n    an object supporting iteration\n\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\n\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",
tp$new(b,e){let [d,f]=Sk.abstr.copyKeywordsToNamedArgs("enumerate",["iterable","start"],b,e,[new Sk.builtin.int_(0)]);d=Sk.abstr.iter(d);f=Sk.misceval.asIndexOrThrow(f);if(this===Sk.builtin.enumerate.prototype)return new Sk.builtin.enumerate(d,f);b=new this.constructor;Sk.builtin.enumerate.call(b,d,f);return b}},classmethods:Sk.generic.classGetItem});Sk.exportSymbol("Sk.builtin.enumerate",Sk.builtin.enumerate)},function(F,P){Sk.builtin.filter_=Sk.abstr.buildIteratorClass("filter",{constructor:function(b,
e){this.$func=b;this.$iterable=e},iternext(b){const e=Sk.misceval.iterFor(this.$iterable,d=>Sk.misceval.chain(this.check$filter(d),f=>f?new Sk.misceval.Break(f):void 0));return b?e:Sk.misceval.retryOptionalSuspensionOrThrow(e)},slots:{tp$doc:"Return an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",tp$new(b,e){let [d,f]=Sk.abstr.copyKeywordsToNamedArgs("filter",["predicate","iterable"],b,e,[]);d=Sk.builtin.checkNone(d)?
null:d;f=Sk.abstr.iter(f);if(this===Sk.builtin.filter_.prototype)return new Sk.builtin.filter_(d,f);b=new this.constructor;Sk.builtin.filter_.call(b,d,f);return b}},proto:{check$filter(b){let e;e=null===this.$func?b:Sk.misceval.callsimOrSuspendArray(this.$func,[b]);return Sk.misceval.chain(e,d=>Sk.misceval.isTrue(d)?b:void 0)}}});Sk.exportSymbol("Sk.builtin.filter_",Sk.builtin.filter_)},function(F,P){Sk.builtin.map_=Sk.abstr.buildIteratorClass("map",{constructor:function(b,e){this.$func=b;this.$iters=
e},iternext(b){const e=[],d=Sk.misceval.chain(Sk.misceval.iterArray(this.$iters,f=>Sk.misceval.chain(f.tp$iternext(b),h=>{if(void 0===h)return new Sk.misceval.Break(!0);e.push(h)})),f=>f?void 0:Sk.misceval.callsimOrSuspendArray(this.$func,e));return b?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)},slots:{tp$doc:"map(func, *iterables) --\x3e map object\n\nMake an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",tp$new(b,
e){this===Sk.builtin.map_.prototype&&Sk.abstr.checkNoKwargs("map",e);Sk.abstr.checkArgsLen("map",b,2);e=b[0];const d=[];for(let f=1;f<b.length;f++)d.push(Sk.abstr.iter(b[f]));if(this===Sk.builtin.map_.prototype)return new Sk.builtin.map_(e,d);b=new this.constructor;Sk.builtin.map_.call(b,e,d);return b}}});Sk.exportSymbol("Sk.builtin.map_",Sk.builtin.map_)},function(F,P){Sk.builtin.reversed=Sk.abstr.buildIteratorClass("reversed",{constructor:function(b){this.$idx=b.sq$length()-1;this.$seq=b;return this},
iternext(b){if(!(0>this.$idx)){var e=Sk.misceval.tryCatch(()=>Sk.abstr.objectGetItem(this.$seq,new Sk.builtin.int_(this.$idx--),b),d=>{if(d instanceof Sk.builtin.IndexError)this.$idx=-1;else throw d;});return b?e:Sk.misceval.retryOptionalSuspensionOrThrow(e)}},slots:{tp$doc:"Return a reverse iterator over the values of the given sequence.",tp$new(b,e){this===Sk.builtin.reversed.prototype&&Sk.abstr.checkNoKwargs("reversed",e);Sk.abstr.checkArgsLen("reversed",b,1,1);b=b[0];e=Sk.abstr.lookupSpecial(b,
Sk.builtin.str.$reversed);if(void 0!==e)return Sk.misceval.callsimArray(e,[]);if(!Sk.builtin.checkSequence(b)||void 0===Sk.abstr.lookupSpecial(b,Sk.builtin.str.$len))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(b)+"' object is not a sequence");if(this===Sk.builtin.reversed.prototype)return new Sk.builtin.reversed(b);e=new this.constructor;Sk.builtin.reversed.call(e,b);return e}},methods:{__length_hint__:{$meth:function(){return 0<=this.$idx?new Sk.builtin.int_(this.$idx):new Sk.builtin.int_(0)},
$flags:{NoArgs:!0}}}})},function(F,P){Sk.builtin.zip_=Sk.abstr.buildIteratorClass("zip",{constructor:function(b){this.$iters=b;0===b.length&&(this.tp$iternext=()=>{})},iternext(b){const e=[],d=Sk.misceval.chain(Sk.misceval.iterArray(this.$iters,f=>Sk.misceval.chain(f.tp$iternext(b),h=>{if(void 0===h)return new Sk.misceval.Break(!0);e.push(h)})),f=>f?void 0:new Sk.builtin.tuple(e));return b?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)},slots:{tp$doc:"zip(iter1 [,iter2 [...]]) --\x3e zip object\n\nReturn a zip object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the shortest iterable in the argument sequence\nis exhausted and then it raises StopIteration.",
tp$new(b,e){this===Sk.builtin.zip_.prototype&&Sk.abstr.checkNoKwargs("zip",e);e=[];for(let d=0;d<b.length;d++)try{e.push(Sk.abstr.iter(b[d]))}catch(f){if(f instanceof Sk.builtin.TypeError)throw new Sk.builtin.TypeError("zip argument #"+(d+1)+" must support iteration");throw f;}if(this===Sk.builtin.zip_.prototype)return new Sk.builtin.zip_(e);b=new this.constructor;Sk.builtin.zip_.call(b,e);return b}}});Sk.exportSymbol("Sk.builtin.zip_",Sk.builtin.zip_)},function(F,P){var b={T_ENDMARKER:0,T_NAME:1,
T_NUMBER:2,T_STRING:3,T_NEWLINE:4,T_INDENT:5,T_DEDENT:6,T_LPAR:7,T_RPAR:8,T_LSQB:9,T_RSQB:10,T_COLON:11,T_COMMA:12,T_SEMI:13,T_PLUS:14,T_MINUS:15,T_STAR:16,T_SLASH:17,T_VBAR:18,T_AMPER:19,T_LESS:20,T_GREATER:21,T_EQUAL:22,T_DOT:23,T_PERCENT:24,T_LBRACE:25,T_RBRACE:26,T_EQEQUAL:27,T_NOTEQUAL:28,T_LESSEQUAL:29,T_GREATEREQUAL:30,T_TILDE:31,T_CIRCUMFLEX:32,T_LEFTSHIFT:33,T_RIGHTSHIFT:34,T_DOUBLESTAR:35,T_PLUSEQUAL:36,T_MINEQUAL:37,T_STAREQUAL:38,T_SLASHEQUAL:39,T_PERCENTEQUAL:40,T_AMPEREQUAL:41,T_VBAREQUAL:42,
T_CIRCUMFLEXEQUAL:43,T_LEFTSHIFTEQUAL:44,T_RIGHTSHIFTEQUAL:45,T_DOUBLESTAREQUAL:46,T_DOUBLESLASH:47,T_DOUBLESLASHEQUAL:48,T_AT:49,T_ATEQUAL:50,T_RARROW:51,T_ELLIPSIS:52,T_OP:53,T_AWAIT:54,T_ASYNC:55,T_ERRORTOKEN:56,T_NT_OFFSET:256,T_N_TOKENS:60,T_COMMENT:57,T_NL:58,T_ENCODING:59};F={"!=":b.T_NOTEQUAL,"%":b.T_PERCENT,"%=":b.T_PERCENTEQUAL,"&":b.T_AMPER,"&=":b.T_AMPEREQUAL,"(":b.T_LPAR,")":b.T_RPAR,"*":b.T_STAR,"**":b.T_DOUBLESTAR,"**=":b.T_DOUBLESTAREQUAL,"*=":b.T_STAREQUAL,"+":b.T_PLUS,"+=":b.T_PLUSEQUAL,
",":b.T_COMMA,"-":b.T_MINUS,"-=":b.T_MINEQUAL,"->":b.T_RARROW,".":b.T_DOT,"...":b.T_ELLIPSIS,"/":b.T_SLASH,"//":b.T_DOUBLESLASH,"//=":b.T_DOUBLESLASHEQUAL,"/=":b.T_SLASHEQUAL,":":b.T_COLON,";":b.T_SEMI,"<":b.T_LESS,"<<":b.T_LEFTSHIFT,"<<=":b.T_LEFTSHIFTEQUAL,"<=":b.T_LESSEQUAL,"=":b.T_EQUAL,"==":b.T_EQEQUAL,">":b.T_GREATER,">=":b.T_GREATEREQUAL,">>":b.T_RIGHTSHIFT,">>=":b.T_RIGHTSHIFTEQUAL,"@":b.T_AT,"@=":b.T_ATEQUAL,"[":b.T_LSQB,"]":b.T_RSQB,"^":b.T_CIRCUMFLEX,"^=":b.T_CIRCUMFLEXEQUAL,"{":b.T_LBRACE,
"|":b.T_VBAR,"|=":b.T_VBAREQUAL,"}":b.T_RBRACE,"~":b.T_TILDE};var e={};(function(){for(var d in b)e[b[d]]=d})();["tok_name","ISTERMINAL","ISNONTERMINAL","ISEOF"].concat(Object.keys(e).map(function(d){return e[d]}));Sk.token={};Sk.token.tokens=b;Sk.token.tok_name=e;Sk.token.EXACT_TOKEN_TYPES=F;Sk.token.ISTERMINAL=function(d){return d<b.T_NT_OFFSET};Sk.token.ISNONTERMINAL=function(d){return d>=b.T_NT_OFFSET};Sk.token.ISEOF=function(d){return d==b.T_ENDMARKER};Sk.exportSymbol("Sk.token",Sk.token);Sk.exportSymbol("Sk.token.tokens",
Sk.token.tokens);Sk.exportSymbol("Sk.token.tok_name",Sk.token.tok_name);Sk.exportSymbol("Sk.token.EXACT_TOKEN_TYPES");Sk.exportSymbol("Sk.token.ISTERMINAL",Sk.token.ISTERMINAL);Sk.exportSymbol("Sk.token.ISNONTERMINAL",Sk.token.ISNONTERMINAL);Sk.exportSymbol("Sk.token.ISEOF",Sk.token.ISEOF)},function(F,P){Sk.OpMap={"(":Sk.token.tokens.T_LPAR,")":Sk.token.tokens.T_RPAR,"[":Sk.token.tokens.T_LSQB,"]":Sk.token.tokens.T_RSQB,":":Sk.token.tokens.T_COLON,",":Sk.token.tokens.T_COMMA,";":Sk.token.tokens.T_SEMI,
"+":Sk.token.tokens.T_PLUS,"-":Sk.token.tokens.T_MINUS,"*":Sk.token.tokens.T_STAR,"/":Sk.token.tokens.T_SLASH,"|":Sk.token.tokens.T_VBAR,"&":Sk.token.tokens.T_AMPER,"<":Sk.token.tokens.T_LESS,">":Sk.token.tokens.T_GREATER,"=":Sk.token.tokens.T_EQUAL,".":Sk.token.tokens.T_DOT,"%":Sk.token.tokens.T_PERCENT,"`":Sk.token.tokens.T_BACKQUOTE,"{":Sk.token.tokens.T_LBRACE,"}":Sk.token.tokens.T_RBRACE,"@":Sk.token.tokens.T_AT,"@=":Sk.token.tokens.T_ATEQUAL,"==":Sk.token.tokens.T_EQEQUAL,"!=":Sk.token.tokens.T_NOTEQUAL,
"<>":Sk.token.tokens.T_NOTEQUAL,"<=":Sk.token.tokens.T_LESSEQUAL,">=":Sk.token.tokens.T_GREATEREQUAL,"~":Sk.token.tokens.T_TILDE,"^":Sk.token.tokens.T_CIRCUMFLEX,"<<":Sk.token.tokens.T_LEFTSHIFT,">>":Sk.token.tokens.T_RIGHTSHIFT,"**":Sk.token.tokens.T_DOUBLESTAR,"+=":Sk.token.tokens.T_PLUSEQUAL,"-=":Sk.token.tokens.T_MINEQUAL,"*=":Sk.token.tokens.T_STAREQUAL,"/=":Sk.token.tokens.T_SLASHEQUAL,"%=":Sk.token.tokens.T_PERCENTEQUAL,"&=":Sk.token.tokens.T_AMPEREQUAL,"|=":Sk.token.tokens.T_VBAREQUAL,"^=":Sk.token.tokens.T_CIRCUMFLEXEQUAL,
"<<=":Sk.token.tokens.T_LEFTSHIFTEQUAL,">>=":Sk.token.tokens.T_RIGHTSHIFTEQUAL,"**=":Sk.token.tokens.T_DOUBLESTAREQUAL,"//":Sk.token.tokens.T_DOUBLESLASH,"//=":Sk.token.tokens.T_DOUBLESLASHEQUAL,"->":Sk.token.tokens.T_RARROW,"...":Sk.token.tokens.T_ELLIPSIS};Sk.ParseTables={sym:{and_expr:257,and_test:258,annassign:259,arglist:260,argument:261,arith_expr:262,assert_stmt:263,async_funcdef:264,async_stmt:265,atom:266,atom_expr:267,augassign:268,break_stmt:269,classdef:270,comp_for:271,comp_if:272,comp_iter:273,
comp_op:274,comparison:275,compound_stmt:276,continue_stmt:277,debugger_stmt:278,decorated:279,decorator:280,decorators:281,del_stmt:282,dictorsetmaker:283,dotted_as_name:284,dotted_as_names:285,dotted_name:286,encoding_decl:287,eval_input:288,except_clause:289,expr:290,expr_stmt:291,exprlist:292,factor:293,file_input:294,flow_stmt:295,for_stmt:296,funcdef:297,global_stmt:298,if_stmt:299,import_as_name:300,import_as_names:301,import_from:302,import_name:303,import_stmt:304,lambdef:305,lambdef_nocond:306,
nonlocal_stmt:307,not_test:308,or_test:309,parameters:310,pass_stmt:311,power:312,print_stmt:313,raise_stmt:314,return_stmt:315,shift_expr:316,simple_stmt:317,single_input:256,sliceop:318,small_stmt:319,star_expr:320,stmt:321,subscript:322,subscriptlist:323,suite:324,term:325,test:326,test_nocond:327,testlist:328,testlist_comp:329,testlist_star_expr:330,tfpdef:331,trailer:332,try_stmt:333,typedargslist:334,varargslist:335,vfpdef:336,while_stmt:337,with_item:338,with_stmt:339,xor_expr:340,yield_arg:341,
yield_expr:342,yield_stmt:343},number2symbol:{256:"single_input",257:"and_expr",258:"and_test",259:"annassign",260:"arglist",261:"argument",262:"arith_expr",263:"assert_stmt",264:"async_funcdef",265:"async_stmt",266:"atom",267:"atom_expr",268:"augassign",269:"break_stmt",270:"classdef",271:"comp_for",272:"comp_if",273:"comp_iter",274:"comp_op",275:"comparison",276:"compound_stmt",277:"continue_stmt",278:"debugger_stmt",279:"decorated",280:"decorator",281:"decorators",282:"del_stmt",283:"dictorsetmaker",
284:"dotted_as_name",285:"dotted_as_names",286:"dotted_name",287:"encoding_decl",288:"eval_input",289:"except_clause",290:"expr",291:"expr_stmt",292:"exprlist",293:"factor",294:"file_input",295:"flow_stmt",296:"for_stmt",297:"funcdef",298:"global_stmt",299:"if_stmt",300:"import_as_name",301:"import_as_names",302:"import_from",303:"import_name",304:"import_stmt",305:"lambdef",306:"lambdef_nocond",307:"nonlocal_stmt",308:"not_test",309:"or_test",310:"parameters",311:"pass_stmt",312:"power",313:"print_stmt",
314:"raise_stmt",315:"return_stmt",316:"shift_expr",317:"simple_stmt",318:"sliceop",319:"small_stmt",320:"star_expr",321:"stmt",322:"subscript",323:"subscriptlist",324:"suite",325:"term",326:"test",327:"test_nocond",328:"testlist",329:"testlist_comp",330:"testlist_star_expr",331:"tfpdef",332:"trailer",333:"try_stmt",334:"typedargslist",335:"varargslist",336:"vfpdef",337:"while_stmt",338:"with_item",339:"with_stmt",340:"xor_expr",341:"yield_arg",342:"yield_expr",343:"yield_stmt"},dfas:{256:[[[[1,1],
[2,1],[3,2]],[[0,1]],[[2,1]]],{2:1,4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1}],257:[[[[44,1]],[[45,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],258:[[[[46,1]],[[47,0],[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],259:[[[[48,1]],[[49,2]],[[50,3],[0,2]],[[49,4]],[[0,4]]],{48:1}],
260:[[[[51,1]],[[52,2],[0,1]],[[51,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],261:[[[[49,1],[15,2],[53,2]],[[50,2],[54,3],[0,1]],[[49,3]],[[0,3]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],262:[[[[55,1]],[[30,0],[43,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],263:[[[[24,1]],[[49,2]],[[52,3],[0,2]],[[49,4]],[[0,4]]],{24:1}],264:[[[[10,1]],[[56,2]],[[0,2]]],{10:1}],
265:[[[[10,1]],[[57,2],[56,2],[58,2]],[[0,2]]],{10:1}],266:[[[[6,1],[25,1],[33,1],[9,1],[11,1],[12,2],[35,3],[38,4],[19,1],[7,5]],[[0,1]],[[59,1],[60,6]],[[61,1],[62,7],[63,7]],[[64,1],[63,8]],[[7,5],[0,5]],[[59,1]],[[61,1]],[[64,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,33:1,35:1,38:1}],267:[[[[29,1],[65,2]],[[65,2]],[[66,2],[0,2]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,29:1,33:1,35:1,38:1}],268:[[[[67,1],[68,1],[69,1],[70,1],[71,1],[72,1],[73,1],[74,1],[75,1],[76,1],[77,1],[78,1],[79,1]],[[0,1]]],{67:1,
68:1,69:1,70:1,71:1,72:1,73:1,74:1,75:1,76:1,77:1,78:1,79:1}],269:[[[[39,1]],[[0,1]]],{39:1}],270:[[[[13,1]],[[25,2]],[[48,3],[35,4]],[[80,5]],[[61,6],[81,7]],[[0,5]],[[48,3]],[[61,6]]],{13:1}],271:[[[[10,1],[34,2]],[[34,2]],[[82,3]],[[83,4]],[[84,5]],[[85,6],[0,5]],[[0,6]]],{10:1,34:1}],272:[[[[37,1]],[[86,2]],[[85,3],[0,2]],[[0,3]]],{37:1}],273:[[[[87,1],[54,1]],[[0,1]]],{10:1,34:1,37:1}],274:[[[[88,1],[89,1],[8,2],[90,1],[88,1],[83,1],[91,1],[92,3],[93,1],[94,1]],[[0,1]],[[83,1]],[[8,1],[0,3]]],
{8:1,83:1,88:1,89:1,90:1,91:1,92:1,93:1,94:1}],275:[[[[95,1]],[[96,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],276:[[[[97,1],[98,1],[58,1],[99,1],[57,1],[100,1],[56,1],[101,1],[102,1]],[[0,1]]],{4:1,10:1,13:1,20:1,21:1,34:1,37:1,41:1,42:1}],277:[[[[40,1]],[[0,1]]],{40:1}],278:[[[[17,1]],[[0,1]]],{17:1}],279:[[[[103,1]],[[56,2],[104,2],[99,2]],[[0,2]]],{41:1}],280:[[[[41,1]],[[105,2]],[[2,4],[35,3]],[[61,5],[81,6]],[[0,4]],[[2,4]],[[61,5]]],{41:1}],281:[[[[106,
1]],[[106,1],[0,1]]],{41:1}],282:[[[[27,1]],[[82,2]],[[0,2]]],{27:1}],283:[[[[49,1],[107,2],[53,3]],[[48,4],[54,5],[52,6],[0,1]],[[54,5],[52,6],[0,2]],[[95,7]],[[49,7]],[[0,5]],[[49,8],[107,8],[0,6]],[[54,5],[52,9],[0,7]],[[52,6],[0,8]],[[49,10],[53,11],[0,9]],[[48,12]],[[95,13]],[[49,13]],[[52,9],[0,13]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],284:[[[[105,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],{25:1}],285:[[[[109,1]],[[52,0],[0,1]]],{25:1}],286:[[[[25,
1]],[[110,0],[0,1]]],{25:1}],287:[[[[25,1]],[[0,1]]],{25:1}],288:[[[[111,1]],[[2,1],[112,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],289:[[[[113,1]],[[49,2],[0,1]],[[108,3],[52,3],[0,2]],[[49,4]],[[0,4]]],{113:1}],290:[[[[114,1]],[[115,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],291:[[[[116,1]],[[117,2],[50,3],[118,4],[0,1]],[[111,4],[62,4]],[[116,5],[62,5]],[[0,4]],[[50,3],[0,5]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,
15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],292:[[[[95,1],[107,1]],[[52,2],[0,1]],[[95,1],[107,1],[0,2]]],{6:1,7:1,9:1,11:1,12:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],293:[[[[119,2],[30,1],[22,1],[43,1]],[[120,2]],[[0,2]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],294:[[[[2,0],[112,1],[121,0]],[[0,1]]],{2:1,4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,
34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1,112:1}],295:[[[[122,1],[123,1],[124,1],[125,1],[126,1]],[[0,1]]],{5:1,23:1,31:1,39:1,40:1}],296:[[[[34,1]],[[82,2]],[[83,3]],[[111,4]],[[48,5]],[[80,6]],[[127,7],[0,6]],[[48,8]],[[80,9]],[[0,9]]],{34:1}],297:[[[[4,1]],[[25,2]],[[128,3]],[[48,4],[129,5]],[[80,6]],[[49,7]],[[0,6]],[[48,4]]],{4:1}],298:[[[[26,1]],[[25,2]],[[52,1],[0,2]]],{26:1}],299:[[[[37,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[130,1],[0,4]],[[48,6]],[[80,7]],[[0,7]]],{37:1}],300:[[[[25,
1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],{25:1}],301:[[[[131,1]],[[52,2],[0,1]],[[131,1],[0,2]]],{25:1}],302:[[[[36,1]],[[105,2],[19,3],[110,3]],[[32,4]],[[105,2],[19,3],[32,4],[110,3]],[[132,5],[15,5],[35,6]],[[0,5]],[[132,7]],[[61,5]]],{36:1}],303:[[[[32,1]],[[133,2]],[[0,2]]],{32:1}],304:[[[[134,1],[135,1]],[[0,1]]],{32:1,36:1}],305:[[[[14,1]],[[48,2],[136,3]],[[49,4]],[[48,2]],[[0,4]]],{14:1}],306:[[[[14,1]],[[48,2],[136,3]],[[86,4]],[[48,2]],[[0,4]]],{14:1}],307:[[[[18,1]],[[25,2]],[[52,1],[0,2]]],
{18:1}],308:[[[[8,1],[137,2]],[[46,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],309:[[[[138,1]],[[139,0],[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],310:[[[[35,1]],[[61,2],[140,3]],[[0,2]],[[61,2]]],{35:1}],311:[[[[28,1]],[[0,1]]],{28:1}],312:[[[[141,1]],[[53,2],[0,1]],[[120,3]],[[0,3]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,29:1,33:1,35:1,38:1}],313:[[[[16,1]],[[49,2],[142,3],[0,1]],[[52,4],[0,2]],[[49,5]],[[49,2],[0,4]],
[[52,6],[0,5]],[[49,7]],[[52,8],[0,7]],[[49,7],[0,8]]],{16:1}],314:[[[[5,1]],[[49,2],[0,1]],[[36,3],[52,3],[0,2]],[[49,4]],[[52,5],[0,4]],[[49,6]],[[0,6]]],{5:1}],315:[[[[23,1]],[[111,2],[0,1]],[[0,2]]],{23:1}],316:[[[[143,1]],[[144,0],[142,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],317:[[[[145,1]],[[2,2],[146,3]],[[0,2]],[[145,1],[2,2]]],{5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,
36:1,38:1,39:1,40:1,43:1}],318:[[[[48,1]],[[49,2],[0,1]],[[0,2]]],{48:1}],319:[[[[147,1],[148,1],[149,1],[150,1],[151,1],[152,1],[153,1],[154,1],[155,1],[156,1]],[[0,1]]],{5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,36:1,38:1,39:1,40:1,43:1}],320:[[[[15,1]],[[95,2]],[[0,2]]],{15:1}],321:[[[[1,1],[3,1]],[[0,1]]],{4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,
27:1,28:1,29:1,30:1,31:1,32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1}],322:[[[[49,1],[48,2]],[[48,2],[0,1]],[[49,3],[157,4],[0,2]],[[157,4],[0,3]],[[0,4]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,48:1}],323:[[[[158,1]],[[52,2],[0,1]],[[158,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,48:1}],324:[[[[1,1],[2,2]],[[0,1]],[[159,3]],[[121,4]],[[160,1],[121,4]]],{2:1,5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,
17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,36:1,38:1,39:1,40:1,43:1}],325:[[[[120,1]],[[161,0],[15,0],[162,0],[41,0],[163,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],326:[[[[84,1],[164,2]],[[37,3],[0,1]],[[0,2]],[[84,4]],[[127,5]],[[49,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],327:[[[[165,1],[84,1]],[[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],
328:[[[[49,1]],[[52,2],[0,1]],[[49,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],329:[[[[49,1],[107,1]],[[54,2],[52,3],[0,1]],[[0,2]],[[49,4],[107,4],[0,3]],[[52,3],[0,4]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],330:[[[[49,1],[107,1]],[[52,2],[0,1]],[[49,1],[107,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],331:[[[[25,1]],[[48,2],[0,1]],[[49,3]],[[0,3]]],{25:1}],
332:[[[[35,1],[110,2],[38,3]],[[61,4],[81,5]],[[25,4]],[[166,6]],[[0,4]],[[61,4]],[[64,4]]],{35:1,38:1,110:1}],333:[[[[20,1]],[[48,2]],[[80,3]],[[167,4],[168,5]],[[48,6]],[[48,7]],[[80,8]],[[80,9]],[[167,4],[127,10],[168,5],[0,8]],[[0,9]],[[48,11]],[[80,12]],[[168,5],[0,12]]],{20:1}],334:[[[[15,1],[169,2],[53,3]],[[169,4],[52,5],[0,1]],[[50,6],[52,7],[0,2]],[[169,8]],[[52,5],[0,4]],[[169,9],[53,3],[0,5]],[[49,10]],[[15,11],[169,2],[53,3],[0,7]],[[52,12],[0,8]],[[50,13],[52,5],[0,9]],[[52,7],[0,10]],
[[169,14],[52,15],[0,11]],[[0,12]],[[49,4]],[[52,15],[0,14]],[[169,16],[53,3],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],{15:1,25:1,53:1}],335:[[[[15,1],[53,2],[170,3]],[[170,5],[52,4],[0,1]],[[170,6]],[[50,7],[52,8],[0,3]],[[53,2],[170,9],[0,4]],[[52,4],[0,5]],[[52,10],[0,6]],[[49,11]],[[15,12],[53,2],[170,3],[0,8]],[[50,13],[52,4],[0,9]],[[0,10]],[[52,8],[0,11]],[[52,15],[170,14],[0,12]],[[49,5]],[[52,15],[0,14]],[[53,2],[170,16],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],{15:1,25:1,53:1}],336:[[[[25,
1]],[[0,1]]],{25:1}],337:[[[[21,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[0,4]],[[48,6]],[[80,7]],[[0,7]]],{21:1}],338:[[[[49,1]],[[108,2],[0,1]],[[95,3]],[[0,3]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],339:[[[[42,1]],[[171,2]],[[48,3],[52,1]],[[80,4]],[[0,4]]],{42:1}],340:[[[[172,1]],[[173,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],341:[[[[111,2],[36,1]],[[49,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,
30:1,33:1,35:1,36:1,38:1,43:1}],342:[[[[31,1]],[[174,2],[0,1]],[[0,2]]],{31:1}],343:[[[[62,1]],[[0,1]]],{31:1}]},states:[[[[1,1],[2,1],[3,2]],[[0,1]],[[2,1]]],[[[44,1]],[[45,0],[0,1]]],[[[46,1]],[[47,0],[0,1]]],[[[48,1]],[[49,2]],[[50,3],[0,2]],[[49,4]],[[0,4]]],[[[51,1]],[[52,2],[0,1]],[[51,1],[0,2]]],[[[49,1],[15,2],[53,2]],[[50,2],[54,3],[0,1]],[[49,3]],[[0,3]]],[[[55,1]],[[30,0],[43,0],[0,1]]],[[[24,1]],[[49,2]],[[52,3],[0,2]],[[49,4]],[[0,4]]],[[[10,1]],[[56,2]],[[0,2]]],[[[10,1]],[[57,2],[56,
2],[58,2]],[[0,2]]],[[[6,1],[25,1],[33,1],[9,1],[11,1],[12,2],[35,3],[38,4],[19,1],[7,5]],[[0,1]],[[59,1],[60,6]],[[61,1],[62,7],[63,7]],[[64,1],[63,8]],[[7,5],[0,5]],[[59,1]],[[61,1]],[[64,1]]],[[[29,1],[65,2]],[[65,2]],[[66,2],[0,2]]],[[[67,1],[68,1],[69,1],[70,1],[71,1],[72,1],[73,1],[74,1],[75,1],[76,1],[77,1],[78,1],[79,1]],[[0,1]]],[[[39,1]],[[0,1]]],[[[13,1]],[[25,2]],[[48,3],[35,4]],[[80,5]],[[61,6],[81,7]],[[0,5]],[[48,3]],[[61,6]]],[[[10,1],[34,2]],[[34,2]],[[82,3]],[[83,4]],[[84,5]],[[85,
6],[0,5]],[[0,6]]],[[[37,1]],[[86,2]],[[85,3],[0,2]],[[0,3]]],[[[87,1],[54,1]],[[0,1]]],[[[88,1],[89,1],[8,2],[90,1],[88,1],[83,1],[91,1],[92,3],[93,1],[94,1]],[[0,1]],[[83,1]],[[8,1],[0,3]]],[[[95,1]],[[96,0],[0,1]]],[[[97,1],[98,1],[58,1],[99,1],[57,1],[100,1],[56,1],[101,1],[102,1]],[[0,1]]],[[[40,1]],[[0,1]]],[[[17,1]],[[0,1]]],[[[103,1]],[[56,2],[104,2],[99,2]],[[0,2]]],[[[41,1]],[[105,2]],[[2,4],[35,3]],[[61,5],[81,6]],[[0,4]],[[2,4]],[[61,5]]],[[[106,1]],[[106,1],[0,1]]],[[[27,1]],[[82,2]],
[[0,2]]],[[[49,1],[107,2],[53,3]],[[48,4],[54,5],[52,6],[0,1]],[[54,5],[52,6],[0,2]],[[95,7]],[[49,7]],[[0,5]],[[49,8],[107,8],[0,6]],[[54,5],[52,9],[0,7]],[[52,6],[0,8]],[[49,10],[53,11],[0,9]],[[48,12]],[[95,13]],[[49,13]],[[52,9],[0,13]]],[[[105,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],[[[109,1]],[[52,0],[0,1]]],[[[25,1]],[[110,0],[0,1]]],[[[25,1]],[[0,1]]],[[[111,1]],[[2,1],[112,2]],[[0,2]]],[[[113,1]],[[49,2],[0,1]],[[108,3],[52,3],[0,2]],[[49,4]],[[0,4]]],[[[114,1]],[[115,0],[0,1]]],[[[116,1]],
[[117,2],[50,3],[118,4],[0,1]],[[111,4],[62,4]],[[116,5],[62,5]],[[0,4]],[[50,3],[0,5]]],[[[95,1],[107,1]],[[52,2],[0,1]],[[95,1],[107,1],[0,2]]],[[[119,2],[30,1],[22,1],[43,1]],[[120,2]],[[0,2]]],[[[2,0],[112,1],[121,0]],[[0,1]]],[[[122,1],[123,1],[124,1],[125,1],[126,1]],[[0,1]]],[[[34,1]],[[82,2]],[[83,3]],[[111,4]],[[48,5]],[[80,6]],[[127,7],[0,6]],[[48,8]],[[80,9]],[[0,9]]],[[[4,1]],[[25,2]],[[128,3]],[[48,4],[129,5]],[[80,6]],[[49,7]],[[0,6]],[[48,4]]],[[[26,1]],[[25,2]],[[52,1],[0,2]]],[[[37,
1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[130,1],[0,4]],[[48,6]],[[80,7]],[[0,7]]],[[[25,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],[[[131,1]],[[52,2],[0,1]],[[131,1],[0,2]]],[[[36,1]],[[105,2],[19,3],[110,3]],[[32,4]],[[105,2],[19,3],[32,4],[110,3]],[[132,5],[15,5],[35,6]],[[0,5]],[[132,7]],[[61,5]]],[[[32,1]],[[133,2]],[[0,2]]],[[[134,1],[135,1]],[[0,1]]],[[[14,1]],[[48,2],[136,3]],[[49,4]],[[48,2]],[[0,4]]],[[[14,1]],[[48,2],[136,3]],[[86,4]],[[48,2]],[[0,4]]],[[[18,1]],[[25,2]],[[52,1],[0,2]]],[[[8,
1],[137,2]],[[46,2]],[[0,2]]],[[[138,1]],[[139,0],[0,1]]],[[[35,1]],[[61,2],[140,3]],[[0,2]],[[61,2]]],[[[28,1]],[[0,1]]],[[[141,1]],[[53,2],[0,1]],[[120,3]],[[0,3]]],[[[16,1]],[[49,2],[142,3],[0,1]],[[52,4],[0,2]],[[49,5]],[[49,2],[0,4]],[[52,6],[0,5]],[[49,7]],[[52,8],[0,7]],[[49,7],[0,8]]],[[[5,1]],[[49,2],[0,1]],[[36,3],[52,3],[0,2]],[[49,4]],[[52,5],[0,4]],[[49,6]],[[0,6]]],[[[23,1]],[[111,2],[0,1]],[[0,2]]],[[[143,1]],[[144,0],[142,0],[0,1]]],[[[145,1]],[[2,2],[146,3]],[[0,2]],[[145,1],[2,2]]],
[[[48,1]],[[49,2],[0,1]],[[0,2]]],[[[147,1],[148,1],[149,1],[150,1],[151,1],[152,1],[153,1],[154,1],[155,1],[156,1]],[[0,1]]],[[[15,1]],[[95,2]],[[0,2]]],[[[1,1],[3,1]],[[0,1]]],[[[49,1],[48,2]],[[48,2],[0,1]],[[49,3],[157,4],[0,2]],[[157,4],[0,3]],[[0,4]]],[[[158,1]],[[52,2],[0,1]],[[158,1],[0,2]]],[[[1,1],[2,2]],[[0,1]],[[159,3]],[[121,4]],[[160,1],[121,4]]],[[[120,1]],[[161,0],[15,0],[162,0],[41,0],[163,0],[0,1]]],[[[84,1],[164,2]],[[37,3],[0,1]],[[0,2]],[[84,4]],[[127,5]],[[49,2]]],[[[165,1],
[84,1]],[[0,1]]],[[[49,1]],[[52,2],[0,1]],[[49,1],[0,2]]],[[[49,1],[107,1]],[[54,2],[52,3],[0,1]],[[0,2]],[[49,4],[107,4],[0,3]],[[52,3],[0,4]]],[[[49,1],[107,1]],[[52,2],[0,1]],[[49,1],[107,1],[0,2]]],[[[25,1]],[[48,2],[0,1]],[[49,3]],[[0,3]]],[[[35,1],[110,2],[38,3]],[[61,4],[81,5]],[[25,4]],[[166,6]],[[0,4]],[[61,4]],[[64,4]]],[[[20,1]],[[48,2]],[[80,3]],[[167,4],[168,5]],[[48,6]],[[48,7]],[[80,8]],[[80,9]],[[167,4],[127,10],[168,5],[0,8]],[[0,9]],[[48,11]],[[80,12]],[[168,5],[0,12]]],[[[15,1],
[169,2],[53,3]],[[169,4],[52,5],[0,1]],[[50,6],[52,7],[0,2]],[[169,8]],[[52,5],[0,4]],[[169,9],[53,3],[0,5]],[[49,10]],[[15,11],[169,2],[53,3],[0,7]],[[52,12],[0,8]],[[50,13],[52,5],[0,9]],[[52,7],[0,10]],[[169,14],[52,15],[0,11]],[[0,12]],[[49,4]],[[52,15],[0,14]],[[169,16],[53,3],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],[[[15,1],[53,2],[170,3]],[[170,5],[52,4],[0,1]],[[170,6]],[[50,7],[52,8],[0,3]],[[53,2],[170,9],[0,4]],[[52,4],[0,5]],[[52,10],[0,6]],[[49,11]],[[15,12],[53,2],[170,3],[0,8]],
[[50,13],[52,4],[0,9]],[[0,10]],[[52,8],[0,11]],[[52,15],[170,14],[0,12]],[[49,5]],[[52,15],[0,14]],[[53,2],[170,16],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],[[[25,1]],[[0,1]]],[[[21,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[0,4]],[[48,6]],[[80,7]],[[0,7]]],[[[49,1]],[[108,2],[0,1]],[[95,3]],[[0,3]]],[[[42,1]],[[171,2]],[[48,3],[52,1]],[[80,4]],[[0,4]]],[[[172,1]],[[173,0],[0,1]]],[[[111,2],[36,1]],[[49,2]],[[0,2]]],[[[31,1]],[[174,2],[0,1]],[[0,2]]],[[[62,1]],[[0,1]]]],labels:[[0,"EMPTY"],[317,
null],[4,null],[276,null],[1,"def"],[1,"raise"],[1,"True"],[3,null],[1,"not"],[1,"None"],[55,null],[2,null],[25,null],[1,"class"],[1,"lambda"],[16,null],[1,"print"],[1,"debugger"],[1,"nonlocal"],[52,null],[1,"try"],[1,"while"],[31,null],[1,"return"],[1,"assert"],[1,null],[1,"global"],[1,"del"],[1,"pass"],[54,null],[15,null],[1,"yield"],[1,"import"],[1,"False"],[1,"for"],[7,null],[1,"from"],[1,"if"],[9,null],[1,"break"],[1,"continue"],[49,null],[1,"with"],[14,null],[316,null],[19,null],[308,null],
[1,"and"],[11,null],[326,null],[22,null],[261,null],[12,null],[35,null],[271,null],[325,null],[297,null],[339,null],[296,null],[26,null],[283,null],[8,null],[342,null],[329,null],[10,null],[266,null],[332,null],[45,null],[38,null],[40,null],[50,null],[46,null],[41,null],[42,null],[36,null],[43,null],[48,null],[44,null],[37,null],[39,null],[324,null],[260,null],[292,null],[1,"in"],[309,null],[273,null],[327,null],[272,null],[28,null],[21,null],[27,null],[29,null],[1,"is"],[30,null],[20,null],[290,
null],[274,null],[333,null],[299,null],[270,null],[337,null],[279,null],[265,null],[281,null],[264,null],[286,null],[280,null],[320,null],[1,"as"],[284,null],[23,null],[328,null],[0,null],[1,"except"],[340,null],[18,null],[330,null],[268,null],[259,null],[312,null],[293,null],[321,null],[269,null],[277,null],[314,null],[315,null],[343,null],[1,"else"],[310,null],[51,null],[1,"elif"],[300,null],[301,null],[285,null],[303,null],[302,null],[335,null],[275,null],[258,null],[1,"or"],[334,null],[267,null],
[34,null],[262,null],[33,null],[319,null],[13,null],[295,null],[263,null],[291,null],[311,null],[307,null],[313,null],[282,null],[298,null],[304,null],[278,null],[318,null],[322,null],[5,null],[6,null],[47,null],[17,null],[24,null],[305,null],[306,null],[323,null],[289,null],[1,"finally"],[331,null],[336,null],[338,null],[257,null],[32,null],[341,null]],keywords:{False:33,None:9,True:6,and:47,as:108,assert:24,"break":39,"class":13,"continue":40,"debugger":17,def:4,del:27,elif:130,"else":127,except:113,
"finally":168,"for":34,from:36,global:26,"if":37,"import":32,"in":83,is:92,lambda:14,nonlocal:18,not:8,or:139,pass:28,print:16,raise:5,"return":23,"try":20,"while":21,"with":42,yield:31},tokens:{0:112,1:25,2:11,3:7,4:2,5:159,6:160,7:35,8:61,9:38,10:64,11:48,12:52,13:146,14:43,15:30,16:15,17:162,18:115,19:45,20:94,21:89,22:50,23:110,24:163,25:12,26:59,27:90,28:88,29:91,30:93,31:22,32:173,33:144,34:142,35:53,36:74,37:78,38:68,39:79,40:69,41:72,42:73,43:75,44:77,45:67,46:71,47:161,48:76,49:41,50:70,
51:129,52:19,54:29,55:10},start:256}},function(F,P){function b(d,f){this.filename=d;this.grammar=f;this.p_flags=0;return this}function e(d,f){void 0===f&&(f="file_input");d=new b(d,Sk.ParseTables);"file_input"===f?d.setup(Sk.ParseTables.sym.file_input):Sk.asserts.fail("todo;");return d}b.FUTURE_PRINT_FUNCTION="print_function";b.FUTURE_UNICODE_LITERALS="unicode_literals";b.FUTURE_DIVISION="division";b.FUTURE_ABSOLUTE_IMPORT="absolute_import";b.FUTURE_WITH_STATEMENT="with_statement";b.FUTURE_NESTED_SCOPES=
"nested_scopes";b.FUTURE_GENERATORS="generators";b.CO_FUTURE_PRINT_FUNCTION=65536;b.CO_FUTURE_UNICODE_LITERALS=131072;b.CO_FUTURE_DIVISON=8192;b.CO_FUTURE_ABSOLUTE_IMPORT=16384;b.CO_FUTURE_WITH_STATEMENT=32768;b.prototype.setup=function(d){d=d||this.grammar.start;this.stack=[{dfa:this.grammar.dfas[d],state:0,node:{type:d,value:null,context:null,children:[]}}];this.used_names={}};b.prototype.addtoken=function(d,f,h){var p,g=this.classify(d,f,h);a:for(;;){var a=this.stack[this.stack.length-1];var c=
a.dfa[0];var n=c[a.state];for(p=0;p<n.length;++p){var m=n[p][0];var k=n[p][1];var u=this.grammar.labels[m][0];if(g===m){Sk.asserts.assert(256>u);this.shift(d,f,k,h);for(h=k;1===c[h].length&&0===c[h][0][0]&&c[h][0][1]===h;){this.pop();if(0===this.stack.length)return!0;a=this.stack[this.stack.length-1];h=a.state;c=a.dfa[0]}return!1}if(256<=u&&(m=this.grammar.dfas[u],m=m[1],m.hasOwnProperty(g))){this.push(u,this.grammar.dfas[u],k,h);continue a}}b:{c=[0,a.state];for(a=n.length;a--;)if(n[a][0]===c[0]&&
n[a][1]===c[1]){n=!0;break b}n=!1}if(n){if(this.pop(),0===this.stack.length)throw new Sk.builtin.SyntaxError("too much input",this.filename);}else throw d=h[0][0],new Sk.builtin.SyntaxError("bad input",this.filename,d,h);}};b.prototype.classify=function(d,f,h){if(d===Sk.token.tokens.T_NAME){this.used_names[f]=!0;var p=this.grammar.keywords.hasOwnProperty(f)&&this.grammar.keywords[f];"print"===f&&(this.p_flags&b.CO_FUTURE_PRINT_FUNCTION||!0===Sk.__future__.print_function)&&(p=!1);if(p)return p}p=this.grammar.tokens.hasOwnProperty(d)&&
this.grammar.tokens[d];if(!p){f="#"+d;for(let g in Sk.token.tokens)if(Sk.token.tokens[g]==d){f=g;break}throw new Sk.builtin.SyntaxError("bad token "+f,this.filename,h[0][0],h);}return p};b.prototype.shift=function(d,f,h,p){var g=this.stack[this.stack.length-1].dfa,a=this.stack[this.stack.length-1].node;a.children.push({type:d,value:f,lineno:p[0][0],col_offset:p[0][1],children:null});this.stack[this.stack.length-1]={dfa:g,state:h,node:a}};b.prototype.push=function(d,f,h,p){d={type:d,value:null,lineno:p[0][0],
col_offset:p[0][1],children:[]};this.stack[this.stack.length-1]={dfa:this.stack[this.stack.length-1].dfa,state:h,node:this.stack[this.stack.length-1].node};this.stack.push({dfa:f,state:0,node:d})};b.prototype.pop=function(){var d=this.stack.pop().node;if(d)if(0!==this.stack.length){var f=this.stack[this.stack.length-1].node;f.children.push(d)}else this.rootnode=d,this.rootnode.used_names=this.used_names};Sk.parse=function(d,f){var h=Sk.token.tokens.T_COMMENT,p=Sk.token.tokens.T_NL,g=Sk.token.tokens.T_OP,
a=Sk.token.tokens.T_ENDMARKER,c=Sk.token.tokens.T_ENCODING,n=!1,m=e(d);Sk._tokenize(d,function(k){var u=k.split("\n").reverse().map(function(l){return l+"\n"});return function(){if(0===u.length)throw new Sk.builtin.Exception("EOF");return u.pop()}}(f),"utf-8",function(k){var u=null;k.type!==h&&k.type!==p&&k.type!==c&&(k.type===g&&(u=Sk.OpMap[k.string]),m.addtoken(u||k.type,k.string,[k.start,k.end,k.line]),k.type===a&&(n=!0))});if(!n)throw new Sk.builtin.SyntaxError("incomplete input",this.filename);
return{cst:m.rootnode,flags:m.p_flags}};Sk.parseTreeDump=function(d,f){var h;f=f||"";var p=""+f;if(256<=d.type)for(p+=Sk.ParseTables.number2symbol[d.type]+"\n",h=0;h<d.children.length;++h)p+=Sk.parseTreeDump(d.children[h],f+"  ");else p+=Sk.token.tok_name[d.type]+": "+(new Sk.builtin.str(d.value)).$r().v+"\n";return p};Sk.exportSymbol("Sk.Parser",b);Sk.exportSymbol("Sk.parse",Sk.parse);Sk.exportSymbol("Sk.parseTreeDump",Sk.parseTreeDump)},function(F,P){Sk.astnodes={};Sk.astnodes.Load=function(){};
Sk.astnodes.Store=function(){};Sk.astnodes.Del=function(){};Sk.astnodes.AugLoad=function(){};Sk.astnodes.AugStore=function(){};Sk.astnodes.Param=function(){};Sk.astnodes.And=function(){};Sk.astnodes.Or=function(){};Sk.astnodes.Add=function(){};Sk.astnodes.Sub=function(){};Sk.astnodes.Mult=function(){};Sk.astnodes.MatMult=function(){};Sk.astnodes.Div=function(){};Sk.astnodes.Mod=function(){};Sk.astnodes.Pow=function(){};Sk.astnodes.LShift=function(){};Sk.astnodes.RShift=function(){};Sk.astnodes.BitOr=
function(){};Sk.astnodes.BitXor=function(){};Sk.astnodes.BitAnd=function(){};Sk.astnodes.FloorDiv=function(){};Sk.astnodes.Invert=function(){};Sk.astnodes.Not=function(){};Sk.astnodes.UAdd=function(){};Sk.astnodes.USub=function(){};Sk.astnodes.Eq=function(){};Sk.astnodes.NotEq=function(){};Sk.astnodes.Lt=function(){};Sk.astnodes.LtE=function(){};Sk.astnodes.Gt=function(){};Sk.astnodes.GtE=function(){};Sk.astnodes.Is=function(){};Sk.astnodes.IsNot=function(){};Sk.astnodes.In=function(){};Sk.astnodes.NotIn=
function(){};Sk.astnodes.Module=function(b,e){this.body=b;this.docstring=e;return this};Sk.astnodes.Interactive=function(b){this.body=b;return this};Sk.astnodes.Expression=function(b){this.body=b;return this};Sk.astnodes.Suite=function(b){this.body=b;return this};Sk.astnodes.FunctionDef=function(b,e,d,f,h,p,g,a){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==a&&void 0!==a);this.name=b;this.args=e;this.body=d;this.decorator_list=f;this.returns=h;this.docstring=p;this.lineno=g;this.col_offset=
a;return this};Sk.astnodes.AsyncFunctionDef=function(b,e,d,f,h,p,g,a){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==a&&void 0!==a);this.name=b;this.args=e;this.body=d;this.decorator_list=f;this.returns=h;this.docstring=p;this.lineno=g;this.col_offset=a;return this};Sk.astnodes.ClassDef=function(b,e,d,f,h,p,g,a){Sk.asserts.assert(null!==g&&void 0!==g);Sk.asserts.assert(null!==a&&void 0!==a);this.name=b;this.bases=e;this.keywords=d;this.body=f;this.decorator_list=h;this.docstring=
p;this.lineno=g;this.col_offset=a;return this};Sk.astnodes.Return=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.value=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Delete=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.targets=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Assign=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==
f);this.targets=b;this.value=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.AugAssign=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.target=b;this.op=e;this.value=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.AnnAssign=function(b,e,d,f,h,p){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==p&&void 0!==p);this.target=b;this.annotation=e;this.value=d;this.simple=f;this.lineno=h;this.col_offset=p;return this};
Sk.astnodes.For=function(b,e,d,f,h,p){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==p&&void 0!==p);this.target=b;this.iter=e;this.body=d;this.orelse=f;this.lineno=h;this.col_offset=p;return this};Sk.astnodes.AsyncFor=function(b,e,d,f,h,p){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==p&&void 0!==p);this.target=b;this.iter=e;this.body=d;this.orelse=f;this.lineno=h;this.col_offset=p;return this};Sk.astnodes.While=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&
void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.test=b;this.body=e;this.orelse=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.If=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.test=b;this.body=e;this.orelse=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.With=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.items=b;this.body=e;this.lineno=d;this.col_offset=
f;return this};Sk.astnodes.AsyncWith=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.items=b;this.body=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Raise=function(b,e,d,f,h,p){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==p&&void 0!==p);this.exc=b;this.cause=e;this.inst=d;this.tback=f;this.lineno=h;this.col_offset=p;return this};Sk.astnodes.Try=function(b,e,d,f,h,p){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==
p&&void 0!==p);this.body=b;this.handlers=e;this.orelse=d;this.finalbody=f;this.lineno=h;this.col_offset=p;return this};Sk.astnodes.Assert=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.test=b;this.msg=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Import=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.names=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.ImportFrom=function(b,
e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.module=b;this.names=e;this.level=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.Global=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.names=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Nonlocal=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.names=b;this.lineno=e;this.col_offset=
d;return this};Sk.astnodes.Expr=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.value=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Pass=function(b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Break=function(b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Continue=
function(b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Print=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.dest=b;this.values=e;this.nl=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.Debugger=function(b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.lineno=b;this.col_offset=e;return this};Sk.astnodes.BoolOp=
function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.op=b;this.values=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.BinOp=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.left=b;this.op=e;this.right=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.UnaryOp=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.op=b;this.operand=
e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Lambda=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.args=b;this.body=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.IfExp=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.test=b;this.body=e;this.orelse=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.Dict=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==
d);Sk.asserts.assert(null!==f&&void 0!==f);this.keys=b;this.values=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Set=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.elts=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.ListComp=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.elt=b;this.generators=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.SetComp=function(b,
e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.elt=b;this.generators=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.DictComp=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.key=b;this.value=e;this.generators=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.GeneratorExp=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.elt=
b;this.generators=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Await=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.value=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Yield=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.value=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.YieldFrom=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==
d&&void 0!==d);this.value=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Compare=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.left=b;this.ops=e;this.comparators=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.Call=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.func=b;this.args=e;this.keywords=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.Num=function(b,
e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.n=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Str=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.s=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.FormattedValue=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.value=b;this.conversion=e;this.format_spec=d;this.lineno=f;this.col_offset=
h;return this};Sk.astnodes.JoinedStr=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.values=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Bytes=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.s=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.NameConstant=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.value=b;this.lineno=
e;this.col_offset=d;return this};Sk.astnodes.Ellipsis=function(b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Constant=function(b,e,d){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==d&&void 0!==d);this.value=b;this.lineno=e;this.col_offset=d;return this};Sk.astnodes.Attribute=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.value=
b;this.attr=e;this.ctx=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.Subscript=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.value=b;this.slice=e;this.ctx=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.Starred=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.value=b;this.ctx=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Name=function(b,e,d,f){Sk.asserts.assert(null!==
d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.id=b;this.ctx=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.List=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.elts=b;this.ctx=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Tuple=function(b,e,d,f){Sk.asserts.assert(null!==d&&void 0!==d);Sk.asserts.assert(null!==f&&void 0!==f);this.elts=b;this.ctx=e;this.lineno=d;this.col_offset=f;return this};Sk.astnodes.Slice=
function(b,e,d){this.lower=b;this.upper=e;this.step=d;return this};Sk.astnodes.ExtSlice=function(b){this.dims=b;return this};Sk.astnodes.Index=function(b){this.value=b;return this};Sk.astnodes.comprehension=function(b,e,d,f){this.target=b;this.iter=e;this.ifs=d;this.is_async=f;return this};Sk.astnodes.ExceptHandler=function(b,e,d,f,h){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==h&&void 0!==h);this.type=b;this.name=e;this.body=d;this.lineno=f;this.col_offset=h;return this};Sk.astnodes.arguments_=
function(b,e,d,f,h,p){this.args=b;this.vararg=e;this.kwonlyargs=d;this.kw_defaults=f;this.kwarg=h;this.defaults=p;return this};Sk.astnodes.arg=function b(b,e){this.arg=b;this.annotation=e;return this};Sk.astnodes.keyword=function(b,e){this.arg=b;this.value=e;return this};Sk.astnodes.alias=function(b,e){this.name=b;this.asname=e;return this};Sk.astnodes.withitem=function(b,e){this.context_expr=b;this.optional_vars=e;return this};Sk.astnodes.Module.prototype._astname="Module";Sk.astnodes.Module.prototype._fields=
["body",function(b){return b.body},"docstring",function(b){return b.docstring}];Sk.astnodes.Interactive.prototype._astname="Interactive";Sk.astnodes.Interactive.prototype._fields=["body",function(b){return b.body}];Sk.astnodes.Expression.prototype._astname="Expression";Sk.astnodes.Expression.prototype._fields=["body",function(b){return b.body}];Sk.astnodes.Suite.prototype._astname="Suite";Sk.astnodes.Suite.prototype._fields=["body",function(b){return b.body}];Sk.astnodes.FunctionDef.prototype._astname=
"FunctionDef";Sk.astnodes.FunctionDef.prototype._fields=["name",function(b){return b.name},"args",function(b){return b.args},"body",function(b){return b.body},"decorator_list",function(b){return b.decorator_list},"returns",function(b){return b.returns},"docstring",function(b){return b.docstring}];Sk.astnodes.AsyncFunctionDef.prototype._astname="AsyncFunctionDef";Sk.astnodes.AsyncFunctionDef.prototype._fields=["name",function(b){return b.name},"args",function(b){return b.args},"body",function(b){return b.body},
"decorator_list",function(b){return b.decorator_list},"returns",function(b){return b.returns},"docstring",function(b){return b.docstring}];Sk.astnodes.ClassDef.prototype._astname="ClassDef";Sk.astnodes.ClassDef.prototype._fields=["name",function(b){return b.name},"bases",function(b){return b.bases},"keywords",function(b){return b.keywords},"body",function(b){return b.body},"decorator_list",function(b){return b.decorator_list},"docstring",function(b){return b.docstring}];Sk.astnodes.Return.prototype._astname=
"Return";Sk.astnodes.Return.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Delete.prototype._astname="Delete";Sk.astnodes.Delete.prototype._fields=["targets",function(b){return b.targets}];Sk.astnodes.Assign.prototype._astname="Assign";Sk.astnodes.Assign.prototype._fields=["targets",function(b){return b.targets},"value",function(b){return b.value}];Sk.astnodes.AugAssign.prototype._astname="AugAssign";Sk.astnodes.AugAssign.prototype._fields=["target",function(b){return b.target},
"op",function(b){return b.op},"value",function(b){return b.value}];Sk.astnodes.AnnAssign.prototype._astname="AnnAssign";Sk.astnodes.AnnAssign.prototype._fields=["target",function(b){return b.target},"annotation",function(b){return b.annotation},"value",function(b){return b.value},"simple",function(b){return b.simple}];Sk.astnodes.For.prototype._astname="For";Sk.astnodes.For.prototype._fields=["target",function(b){return b.target},"iter",function(b){return b.iter},"body",function(b){return b.body},
"orelse",function(b){return b.orelse}];Sk.astnodes.AsyncFor.prototype._astname="AsyncFor";Sk.astnodes.AsyncFor.prototype._fields=["target",function(b){return b.target},"iter",function(b){return b.iter},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.While.prototype._astname="While";Sk.astnodes.While.prototype._fields=["test",function(b){return b.test},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.If.prototype._astname="If";
Sk.astnodes.If.prototype._fields=["test",function(b){return b.test},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.With.prototype._astname="With";Sk.astnodes.With.prototype._fields=["items",function(b){return b.items},"body",function(b){return b.body}];Sk.astnodes.AsyncWith.prototype._astname="AsyncWith";Sk.astnodes.AsyncWith.prototype._fields=["items",function(b){return b.items},"body",function(b){return b.body}];Sk.astnodes.Raise.prototype._astname="Raise";
Sk.astnodes.Raise.prototype._fields=["exc",function(b){return b.exc},"cause",function(b){return b.cause},"inst",function(b){return b.inst},"tback",function(b){return b.tback}];Sk.astnodes.Try.prototype._astname="Try";Sk.astnodes.Try.prototype._fields=["body",function(b){return b.body},"handlers",function(b){return b.handlers},"orelse",function(b){return b.orelse},"finalbody",function(b){return b.finalbody}];Sk.astnodes.Assert.prototype._astname="Assert";Sk.astnodes.Assert.prototype._fields=["test",
function(b){return b.test},"msg",function(b){return b.msg}];Sk.astnodes.Import.prototype._astname="Import";Sk.astnodes.Import.prototype._fields=["names",function(b){return b.names}];Sk.astnodes.ImportFrom.prototype._astname="ImportFrom";Sk.astnodes.ImportFrom.prototype._fields=["module",function(b){return b.module},"names",function(b){return b.names},"level",function(b){return b.level}];Sk.astnodes.Global.prototype._astname="Global";Sk.astnodes.Global.prototype._fields=["names",function(b){return b.names}];
Sk.astnodes.Nonlocal.prototype._astname="Nonlocal";Sk.astnodes.Nonlocal.prototype._fields=["names",function(b){return b.names}];Sk.astnodes.Expr.prototype._astname="Expr";Sk.astnodes.Expr.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Pass.prototype._astname="Pass";Sk.astnodes.Pass.prototype._fields=[];Sk.astnodes.Break.prototype._astname="Break";Sk.astnodes.Break.prototype._fields=[];Sk.astnodes.Continue.prototype._astname="Continue";Sk.astnodes.Continue.prototype._fields=[];
Sk.astnodes.Print.prototype._astname="Print";Sk.astnodes.Print.prototype._fields=["dest",function(b){return b.dest},"values",function(b){return b.values},"nl",function(b){return b.nl}];Sk.astnodes.Debugger.prototype._astname="Debugger";Sk.astnodes.Debugger.prototype._fields=[];Sk.astnodes.BoolOp.prototype._astname="BoolOp";Sk.astnodes.BoolOp.prototype._fields=["op",function(b){return b.op},"values",function(b){return b.values}];Sk.astnodes.BinOp.prototype._astname="BinOp";Sk.astnodes.BinOp.prototype._fields=
["left",function(b){return b.left},"op",function(b){return b.op},"right",function(b){return b.right}];Sk.astnodes.UnaryOp.prototype._astname="UnaryOp";Sk.astnodes.UnaryOp.prototype._fields=["op",function(b){return b.op},"operand",function(b){return b.operand}];Sk.astnodes.Lambda.prototype._astname="Lambda";Sk.astnodes.Lambda.prototype._fields=["args",function(b){return b.args},"body",function(b){return b.body}];Sk.astnodes.IfExp.prototype._astname="IfExp";Sk.astnodes.IfExp.prototype._fields=["test",
function(b){return b.test},"body",function(b){return b.body},"orelse",function(b){return b.orelse}];Sk.astnodes.Dict.prototype._astname="Dict";Sk.astnodes.Dict.prototype._fields=["keys",function(b){return b.keys},"values",function(b){return b.values}];Sk.astnodes.Set.prototype._astname="Set";Sk.astnodes.Set.prototype._fields=["elts",function(b){return b.elts}];Sk.astnodes.ListComp.prototype._astname="ListComp";Sk.astnodes.ListComp.prototype._fields=["elt",function(b){return b.elt},"generators",function(b){return b.generators}];
Sk.astnodes.SetComp.prototype._astname="SetComp";Sk.astnodes.SetComp.prototype._fields=["elt",function(b){return b.elt},"generators",function(b){return b.generators}];Sk.astnodes.DictComp.prototype._astname="DictComp";Sk.astnodes.DictComp.prototype._fields=["key",function(b){return b.key},"value",function(b){return b.value},"generators",function(b){return b.generators}];Sk.astnodes.GeneratorExp.prototype._astname="GeneratorExp";Sk.astnodes.GeneratorExp.prototype._fields=["elt",function(b){return b.elt},
"generators",function(b){return b.generators}];Sk.astnodes.Await.prototype._astname="Await";Sk.astnodes.Await.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Yield.prototype._astname="Yield";Sk.astnodes.Yield.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.YieldFrom.prototype._astname="YieldFrom";Sk.astnodes.YieldFrom.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Compare.prototype._astname="Compare";Sk.astnodes.Compare.prototype._fields=
["left",function(b){return b.left},"ops",function(b){return b.ops},"comparators",function(b){return b.comparators}];Sk.astnodes.Call.prototype._astname="Call";Sk.astnodes.Call.prototype._fields=["func",function(b){return b.func},"args",function(b){return b.args},"keywords",function(b){return b.keywords}];Sk.astnodes.Num.prototype._astname="Num";Sk.astnodes.Num.prototype._fields=["n",function(b){return b.n}];Sk.astnodes.Str.prototype._astname="Str";Sk.astnodes.Str.prototype._fields=["s",function(b){return b.s}];
Sk.astnodes.FormattedValue.prototype._astname="FormattedValue";Sk.astnodes.FormattedValue.prototype._fields=["value",function(b){return b.value},"conversion",function(b){return b.conversion},"format_spec",function(b){return b.format_spec}];Sk.astnodes.JoinedStr.prototype._astname="JoinedStr";Sk.astnodes.JoinedStr.prototype._fields=["values",function(b){return b.values}];Sk.astnodes.Bytes.prototype._astname="Bytes";Sk.astnodes.Bytes.prototype._fields=["s",function(b){return b.s}];Sk.astnodes.NameConstant.prototype._astname=
"NameConstant";Sk.astnodes.NameConstant.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Ellipsis.prototype._astname="Ellipsis";Sk.astnodes.Ellipsis.prototype._fields=[];Sk.astnodes.Constant.prototype._astname="Constant";Sk.astnodes.Constant.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.Attribute.prototype._astname="Attribute";Sk.astnodes.Attribute.prototype._fields=["value",function(b){return b.value},"attr",function(b){return b.attr},"ctx",function(b){return b.ctx}];
Sk.astnodes.Subscript.prototype._astname="Subscript";Sk.astnodes.Subscript.prototype._fields=["value",function(b){return b.value},"slice",function(b){return b.slice},"ctx",function(b){return b.ctx}];Sk.astnodes.Starred.prototype._astname="Starred";Sk.astnodes.Starred.prototype._fields=["value",function(b){return b.value},"ctx",function(b){return b.ctx}];Sk.astnodes.Name.prototype._astname="Name";Sk.astnodes.Name.prototype._fields=["id",function(b){return b.id},"ctx",function(b){return b.ctx}];Sk.astnodes.List.prototype._astname=
"List";Sk.astnodes.List.prototype._fields=["elts",function(b){return b.elts},"ctx",function(b){return b.ctx}];Sk.astnodes.Tuple.prototype._astname="Tuple";Sk.astnodes.Tuple.prototype._fields=["elts",function(b){return b.elts},"ctx",function(b){return b.ctx}];Sk.astnodes.Load.prototype._astname="Load";Sk.astnodes.Load.prototype._isenum=!0;Sk.astnodes.Store.prototype._astname="Store";Sk.astnodes.Store.prototype._isenum=!0;Sk.astnodes.Del.prototype._astname="Del";Sk.astnodes.Del.prototype._isenum=!0;
Sk.astnodes.AugLoad.prototype._astname="AugLoad";Sk.astnodes.AugLoad.prototype._isenum=!0;Sk.astnodes.AugStore.prototype._astname="AugStore";Sk.astnodes.AugStore.prototype._isenum=!0;Sk.astnodes.Param.prototype._astname="Param";Sk.astnodes.Param.prototype._isenum=!0;Sk.astnodes.Slice.prototype._astname="Slice";Sk.astnodes.Slice.prototype._fields=["lower",function(b){return b.lower},"upper",function(b){return b.upper},"step",function(b){return b.step}];Sk.astnodes.ExtSlice.prototype._astname="ExtSlice";
Sk.astnodes.ExtSlice.prototype._fields=["dims",function(b){return b.dims}];Sk.astnodes.Index.prototype._astname="Index";Sk.astnodes.Index.prototype._fields=["value",function(b){return b.value}];Sk.astnodes.And.prototype._astname="And";Sk.astnodes.And.prototype._isenum=!0;Sk.astnodes.Or.prototype._astname="Or";Sk.astnodes.Or.prototype._isenum=!0;Sk.astnodes.Add.prototype._astname="Add";Sk.astnodes.Add.prototype._isenum=!0;Sk.astnodes.Sub.prototype._astname="Sub";Sk.astnodes.Sub.prototype._isenum=!0;
Sk.astnodes.Mult.prototype._astname="Mult";Sk.astnodes.Mult.prototype._isenum=!0;Sk.astnodes.MatMult.prototype._astname="MatMult";Sk.astnodes.MatMult.prototype._isenum=!0;Sk.astnodes.Div.prototype._astname="Div";Sk.astnodes.Div.prototype._isenum=!0;Sk.astnodes.Mod.prototype._astname="Mod";Sk.astnodes.Mod.prototype._isenum=!0;Sk.astnodes.Pow.prototype._astname="Pow";Sk.astnodes.Pow.prototype._isenum=!0;Sk.astnodes.LShift.prototype._astname="LShift";Sk.astnodes.LShift.prototype._isenum=!0;Sk.astnodes.RShift.prototype._astname=
"RShift";Sk.astnodes.RShift.prototype._isenum=!0;Sk.astnodes.BitOr.prototype._astname="BitOr";Sk.astnodes.BitOr.prototype._isenum=!0;Sk.astnodes.BitXor.prototype._astname="BitXor";Sk.astnodes.BitXor.prototype._isenum=!0;Sk.astnodes.BitAnd.prototype._astname="BitAnd";Sk.astnodes.BitAnd.prototype._isenum=!0;Sk.astnodes.FloorDiv.prototype._astname="FloorDiv";Sk.astnodes.FloorDiv.prototype._isenum=!0;Sk.astnodes.Invert.prototype._astname="Invert";Sk.astnodes.Invert.prototype._isenum=!0;Sk.astnodes.Not.prototype._astname=
"Not";Sk.astnodes.Not.prototype._isenum=!0;Sk.astnodes.UAdd.prototype._astname="UAdd";Sk.astnodes.UAdd.prototype._isenum=!0;Sk.astnodes.USub.prototype._astname="USub";Sk.astnodes.USub.prototype._isenum=!0;Sk.astnodes.Eq.prototype._astname="Eq";Sk.astnodes.Eq.prototype._isenum=!0;Sk.astnodes.NotEq.prototype._astname="NotEq";Sk.astnodes.NotEq.prototype._isenum=!0;Sk.astnodes.Lt.prototype._astname="Lt";Sk.astnodes.Lt.prototype._isenum=!0;Sk.astnodes.LtE.prototype._astname="LtE";Sk.astnodes.LtE.prototype._isenum=
!0;Sk.astnodes.Gt.prototype._astname="Gt";Sk.astnodes.Gt.prototype._isenum=!0;Sk.astnodes.GtE.prototype._astname="GtE";Sk.astnodes.GtE.prototype._isenum=!0;Sk.astnodes.Is.prototype._astname="Is";Sk.astnodes.Is.prototype._isenum=!0;Sk.astnodes.IsNot.prototype._astname="IsNot";Sk.astnodes.IsNot.prototype._isenum=!0;Sk.astnodes.In.prototype._astname="In";Sk.astnodes.In.prototype._isenum=!0;Sk.astnodes.NotIn.prototype._astname="NotIn";Sk.astnodes.NotIn.prototype._isenum=!0;Sk.astnodes.comprehension.prototype._astname=
"comprehension";Sk.astnodes.comprehension.prototype._fields=["target",function(b){return b.target},"iter",function(b){return b.iter},"ifs",function(b){return b.ifs},"is_async",function(b){return b.is_async}];Sk.astnodes.ExceptHandler.prototype._astname="ExceptHandler";Sk.astnodes.ExceptHandler.prototype._fields=["type",function(b){return b.type},"name",function(b){return b.name},"body",function(b){return b.body}];Sk.astnodes.arguments_.prototype._astname="arguments";Sk.astnodes.arguments_.prototype._fields=
["args",function(b){return b.args},"vararg",function(b){return b.vararg},"kwonlyargs",function(b){return b.kwonlyargs},"kw_defaults",function(b){return b.kw_defaults},"kwarg",function(b){return b.kwarg},"defaults",function(b){return b.defaults}];Sk.astnodes.arg.prototype._astname="arg";Sk.astnodes.arg.prototype._fields=["arg",function(b){return b.arg},"annotation",function(b){return b.annotation}];Sk.astnodes.keyword.prototype._astname="keyword";Sk.astnodes.keyword.prototype._fields=["arg",function(b){return b.arg},
"value",function(b){return b.value}];Sk.astnodes.alias.prototype._astname="alias";Sk.astnodes.alias.prototype._fields=["name",function(b){return b.name},"asname",function(b){return b.asname}];Sk.astnodes.withitem.prototype._astname="withitem";Sk.astnodes.withitem.prototype._fields=["context_expr",function(b){return b.context_expr},"optional_vars",function(b){return b.optional_vars}];Sk.exportSymbol("Sk.astnodes",Sk.astnodes)},function(F,P){function b(D,w,C){this.c_encoding=D;this.c_filename=w;this.c_flags=
C||0}function e(D){Sk.asserts.assert(void 0!==D,"node must be defined");return null===D.children?0:D.children.length}function d(D,w){Sk.asserts.assert(void 0!==D,"node must be defined");Sk.asserts.assert(void 0!==w,"index of child must be specified");return D.children[w]}function f(D,w){Sk.asserts.assert(D.type===w,"node wasn't expected type")}function h(D,w,C){throw new Sk.builtin.SyntaxError(C,D.c_filename,w.lineno);}function p(D){Sk.asserts.assert("string"===typeof D,"expecting string, got "+typeof D);
return new Sk.builtin.str(D)}function g(D){var w,C;switch(D.type){case O.single_input:if(d(D,0).type===V.T_NEWLINE)break;else return g(d(D,0));case O.file_input:for(w=C=0;w<e(D);++w){var G=d(D,w);G.type===O.stmt&&(C+=g(G))}return C;case O.stmt:return g(d(D,0));case O.compound_stmt:return 1;case O.simple_stmt:return Math.floor(e(D)/2);case O.suite:if(1===e(D))return g(d(D,0));C=0;for(w=2;w<e(D)-1;++w)C+=g(d(D,w));return C;default:Sk.asserts.fail("Non-statement found")}return 0}function a(D,w,C,G){C instanceof
Sk.builtin.str&&(C=C.v);if("None"===C)throw new Sk.builtin.SyntaxError("assignment to None",D.c_filename,G);if("True"===C||"False"===C)throw new Sk.builtin.SyntaxError("assignment to True or False is forbidden",D.c_filename,G);}function c(D,w,C,G){var L;Sk.asserts.assert(C!==Sk.astnodes.AugStore&&C!==Sk.astnodes.AugLoad,"context not AugStore or AugLoad");var K=L=null;switch(w.constructor){case Sk.astnodes.Attribute:case Sk.astnodes.Name:C===Sk.astnodes.Store&&a(D,G,w.attr,G.lineno);w.ctx=C;break;
case Sk.astnodes.Starred:w.ctx=C;c(D,w.value,C,G);break;case Sk.astnodes.Subscript:w.ctx=C;break;case Sk.astnodes.List:w.ctx=C;L=w.elts;break;case Sk.astnodes.Tuple:if(0===w.elts.length)throw new Sk.builtin.SyntaxError("can't assign to ()",D.c_filename,G.lineno);w.ctx=C;L=w.elts;break;case Sk.astnodes.Lambda:K="lambda";break;case Sk.astnodes.Call:K="function call";break;case Sk.astnodes.BoolOp:case Sk.astnodes.BinOp:case Sk.astnodes.UnaryOp:K="operator";break;case Sk.astnodes.GeneratorExp:K="generator expression";
break;case Sk.astnodes.Yield:K="yield expression";break;case Sk.astnodes.ListComp:K="list comprehension";break;case Sk.astnodes.SetComp:K="set comprehension";break;case Sk.astnodes.DictComp:K="dict comprehension";break;case Sk.astnodes.Dict:case Sk.astnodes.Set:case Sk.astnodes.Num:case Sk.astnodes.Str:K="literal";break;case Sk.astnodes.NameConstant:K="True, False or None";break;case Sk.astnodes.Compare:K="comparison";break;case Sk.astnodes.Repr:K="repr";break;case Sk.astnodes.IfExp:K="conditional expression";
break;default:Sk.asserts.fail("unhandled expression in assignment")}if(K)throw new Sk.builtin.SyntaxError("can't "+(C===Sk.astnodes.Store?"assign to":"delete")+" "+K,D.c_filename,G.lineno);if(L)for(w=0;w<L.length;++w)c(D,L[w],C,G)}function n(D){if(void 0===fa[D.type])throw new Sk.builtin.SyntaxError("invalid syntax",D.type,D.lineno);return fa[D.type]}function m(D,w){return D.value?new Sk.builtin.str(D.value):new Sk.builtin.str(D)}function k(D,w){f(w,O.comp_op);if(1===e(w))switch(w=d(w,0),w.type){case V.T_LESS:return Sk.astnodes.Lt;
case V.T_GREATER:return Sk.astnodes.Gt;case V.T_EQEQUAL:return Sk.astnodes.Eq;case V.T_LESSEQUAL:return Sk.astnodes.LtE;case V.T_GREATEREQUAL:return Sk.astnodes.GtE;case V.T_NOTEQUAL:return Sk.astnodes.NotEq;case V.T_NAME:if("in"===w.value)return Sk.astnodes.In;if("is"===w.value)return Sk.astnodes.Is}else if(2===e(w)&&d(w,0).type===V.T_NAME){if("in"===d(w,1).value)return Sk.astnodes.NotIn;if("is"===d(w,0).value)return Sk.astnodes.IsNot}Sk.asserts.fail("invalid comp_op")}function u(D,w){D&&(D.lineno=
w.lineno,D.col_offset=w.col_offset,D.end_lineno=w.end_lineno,D.end_col_offset=w.end_col_offset);return D}function l(D,w){var C,G=[];Sk.asserts.assert(w.type===O.testlist||w.type===O.testlist_star_expr||w.type===O.listmaker||w.type===O.testlist_comp||w.type===O.testlist_safe||w.type===O.testlist1,"node type must be listlike");for(C=0;C<e(w);C+=2)Sk.asserts.assert(d(w,C).type===O.test||d(w,C).type===O.old_test||d(w,C).type===O.star_expr),G[C/2]=U(D,d(w,C));return G}function q(D,w){var C;f(w,O.suite);
var G=[];var L=0;if(d(w,0).type===O.simple_stmt){w=d(w,0);var K=e(w)-1;d(w,K-1).type===V.T_SEMI&&--K;for(C=0;C<K;C+=2)G[L++]=ja(D,d(w,C))}else for(C=2;C<e(w)-1;++C){K=d(w,C);f(K,O.stmt);var N=g(K);if(1===N)G[L++]=ja(D,K);else for(K=d(K,0),f(K,O.simple_stmt),N=0;N<e(K);N+=2){if(0===e(d(K,N))){Sk.asserts.assert(N+1===e(K));break}G[L++]=ja(D,d(K,N))}}Sk.asserts.assert(L===g(w));return G}function z(D,w,C){var G;f(w,O.exprlist);var L=[];for(G=0;G<e(w);G+=2){var K=U(D,d(w,G));L[G/2]=K;C&&c(D,K,C,d(w,G))}return L}
function r(D,w){a:for(;;)switch(w.type){case O.import_as_name:D=null;var C=p(d(w,0).value);3===e(w)&&(D=d(w,2).value);return new Sk.astnodes.alias(C,null==D?null:p(D));case O.dotted_as_name:if(1===e(w)){w=d(w,0);continue a}else return D=r(D,d(w,0)),Sk.asserts.assert(!D.asname),D.asname=p(d(w,2).value),D;case O.dotted_name:if(1===e(w))return new Sk.astnodes.alias(p(d(w,0).value),null);D="";for(C=0;C<e(w);C+=2)D+=d(w,C).value+".";return new Sk.astnodes.alias(p(D.substr(0,D.length-1)),null);case V.T_STAR:return new Sk.astnodes.alias(p("*"),
null);default:throw new Sk.builtin.SyntaxError("unexpected import name",D.c_filename,w.lineno);}}function t(D,w){Sk.asserts.assert(w.type==O.testlist_comp||w.type==O.argument);return Q(D,w,0)}function x(D,w){if(d(w,0).type===V.T_MINUS&&2===e(w)){var C=d(w,1);if(C.type===O.factor&&1===e(C)&&(C=d(C,0),C.type===O.power&&1===e(C))){var G=d(C,0);if(G.type===O.atom&&(C=d(G,0),C.type===V.T_NUMBER))return C.value="-"+C.value,ia(D,G)}}D=U(D,d(w,1));switch(d(w,0).type){case V.T_PLUS:return new Sk.astnodes.UnaryOp(Sk.astnodes.UAdd,
D,w.lineno,w.col_offset);case V.T_MINUS:return new Sk.astnodes.UnaryOp(Sk.astnodes.USub,D,w.lineno,w.col_offset);case V.T_TILDE:return new Sk.astnodes.UnaryOp(Sk.astnodes.Invert,D,w.lineno,w.col_offset)}Sk.asserts.fail("unhandled factor")}function v(D,w,C,G){var L,K,N;f(w,O.arglist);for(L=N=K=0;L<e(w);L++){var R=d(w,L);R.type==O.argument&&(1==e(R)?K++:d(R,1).type==O.comp_for?(K++,G||h(D,R,"invalid syntax"),1<e(w)&&h(D,R,"Generator expression must be parenthesized")):d(R,0).type==V.T_STAR?K++:N++)}var W=
[];var T=[];for(L=G=N=K=0;L<e(w);L++)if(R=d(w,L),R.type==O.argument){var ba=d(R,0);if(1==e(R)){N&&(G?h(D,ba,"positional argument follows keyword argument unpacking"):h(D,ba,"positional argument follows keyword argument"));var Y=U(D,ba);if(!Y)return null;W[K++]=Y}else if(ba.type==V.T_STAR){if(G)return h(D,ba,"iterable argument unpacking follows keyword argument unpacking"),null;Y=U(D,d(R,1));if(!Y)return null;R=new Sk.astnodes.Starred(Y,Sk.astnodes.Load,ba.lineno,ba.col_offset);W[K++]=R}else if(ba.type==
V.T_DOUBLESTAR){L++;Y=U(D,d(R,1));if(!Y)return null;R=new Sk.astnodes.keyword(null,Y);T[N++]=R;G++}else if(d(R,1).type==O.comp_for){Y=t(D,R);if(!Y)return null;W[K++]=Y}else{var da;Y=U(D,ba);if(!Y)return null;if(Y.constructor===Sk.astnodes.Lambda)return h(D,ba,"lambda cannot contain assignment"),null;if(Y.constructor!==Sk.astnodes.Name)return h(D,ba,"keyword can't be an expression"),null;if(a(D,Y.id,R,1))return null;var ma=Y.id;for(da=0;da<N;da++)if((Y=T[da].arg)&&Y===ma)return h(D,ba,"keyword argument repeated"),
null;Y=U(D,d(R,2));if(!Y)return null;R=new Sk.astnodes.keyword(ma,Y);T[N++]=R}}return new Sk.astnodes.Call(C,W,T,C.lineno,C.col_offset)}function B(D,w,C){f(w,O.trailer);if(d(w,0).type==V.T_LPAR)return 2==e(w)?new Sk.astnodes.Call(C,null,null,w.lineno,w.col_offset):v(D,d(w,1),C,!0);if(d(w,0).type==V.T_DOT){var G=m(d(w,1));return G?new Sk.astnodes.Attribute(C,G,Sk.astnodes.Load,w.lineno,w.col_offset):null}f(d(w,0),V.T_LSQB);f(d(w,2),V.T_RSQB);w=d(w,1);if(1==e(w))return(G=la(D,d(w,0)))?new Sk.astnodes.Subscript(C,
G,Sk.astnodes.Load,w.lineno,w.col_offset):null;var L,K=1,N=[];for(L=0;L<e(w);L+=2){G=la(D,d(w,L));if(!G)return null;G.kind!=Z.Index_kind&&(K=0);N[L/2]=G}if(!K)return new Sk.astnodes.Subscript(C,new Sk.astnodes.ExtSlice(N),Sk.astnodes.Load,w.lineno,w.col_offset);D=[];for(L=0;L<N.length;++L)G=N[L],Sk.asserts.assert(G.kind==Z.Index_kind&&G.v.Index.value),D[L]=G.v.Index.value;G=new Sk.astnodes.Tuple(D,Sk.astnodes.Load,w.lineno,w.col_offset);return new Sk.astnodes.Subscript(C,new Sk.astnodes.Index(G),
Sk.astnodes.Load,w.lineno,w.col_offset)}function I(D,w){f(w,O.flow_stmt);var C=d(w,0);switch(C.type){case O.break_stmt:return new Sk.astnodes.Break(w.lineno,w.col_offset,w.end_lineno,w.end_col_offset);case O.continue_stmt:return new Sk.astnodes.Continue(w.lineno,w.col_offset,w.end_lineno,w.end_col_offset);case O.yield_stmt:return(D=U(D,d(C,0)))?new Sk.astnodes.Expr(D,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset):null;case O.return_stmt:if(1==e(C))return new Sk.astnodes.Return(null,w.lineno,
w.col_offset,w.end_lineno,w.end_col_offset);var G=aa(D,d(C,1));return G?new Sk.astnodes.Return(G,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset):null;case O.raise_stmt:if(1==e(C))return new Sk.astnodes.Raise(null,null,null,null,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset);if(2<=e(C)){var L=null;G=U(D,d(C,1));var K=null,N=null;4==e(C)&&"from"==d(C,2).value?(Sk.__future__.python3||h(D,d(C,2),"raise ... from ... is not available in Python 2"),L=U(D,d(C,3))):4<=e(C)&&","==d(C,2).value&&(Sk.__future__.python3&&
h(D,w,"Old raise syntax is not available in Python 3"),K=U(D,d(C,3)),6==e(C)&&(N=U(D,d(C,5))));return new Sk.astnodes.Raise(G,L,K,N,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset)}default:return Sk.asserts.fail("unexpected flow_stmt: ",C.type),null}}function M(D,w){var C=null;Sk.asserts.assert(w.type===O.tfpdef||w.type===O.vfpdef);var G=d(w,0);a(D,G,G.value,G.lineno);G=p(G.value);3==e(w)&&d(w,1).type===V.T_COLON&&(C=U(D,d(w,2)));return new Sk.astnodes.arg(G,C,w.lineno,w.col_offset)}function S(D,
w,C,G,L){var K=C,N=0;G||h(D,d(w,C),"named arguments must follow bare *");for(Sk.asserts.assert(L);K<e(w);){var R=d(w,K);switch(R.type){case O.vfpdef:case O.tfpdef:K+1<e(w)&&d(w,K+1).type==V.T_EQUAL?(L[N]=U(D,d(w,K+2)),K+=2):L[N]=null;var W=3==e(R)?U(D,d(R,2)):null;R=d(R,0);a(D,R,R.value,R.lineno);C=p(R.value);G[N++]=new Sk.astnodes.arg(C,W,R.lineno,R.col_offset);K+=2;break;case V.T_DOUBLESTAR:return K;default:h(D,R,"unexpected node")}}return K}function E(D,w){var C,G,L,K=[],N=[],R=[],W=[],T=null,
ba=null;if(w.type===O.parameters){if(2===e(w))return new Sk.astnodes.arguments_([],null,[],[],null,[]);w=d(w,1)}Sk.asserts.assert(w.type===O.varargslist||w.type===O.typedargslist);for(C=G=L=0;L<e(w);){var Y=d(w,L);switch(Y.type){case O.tfpdef:case O.vfpdef:if(L+1<e(w)&&d(w,L+1).type==V.T_EQUAL){N[G++]=U(D,d(w,L+2));L+=2;var da=1}else if(da)throw new Sk.builtin.SyntaxError("non-default argument follows default argument",D.c_filename,w.lineno);K[C++]=M(D,Y);L+=2;break;case V.T_STAR:if(L+1>=e(w)||L+
2==e(w)&&d(w,L+1).type==V.T_COMMA)throw new Sk.builtin.SyntaxError("named arguments must follow bare *",D.c_filename,w.lineno);Y=d(w,L+1);Y.type==V.T_COMMA?(L+=2,L=S(D,w,L,R,W)):(T=M(D,Y),L+=3,L<e(w)&&(d(w,L).type==O.tfpdef||d(w,L).type==O.vfpdef)&&(L=S(D,w,L,R,W)));break;case V.T_DOUBLESTAR:Y=d(w,L+1);Sk.asserts.assert(Y.type==O.tfpdef||Y.type==O.vfpdef);ba=M(D,Y);L+=3;break;default:Sk.asserts.fail("unexpected node in varargslist");return}}return new Sk.astnodes.arguments_(K,T,R,W,ba,N)}function H(D,
w,C,G){var L=G?d(w,1):w,K=null,N=1,R=null;if(G&&5>D.c_feature_version)return h(D,L,"Async functions are only supported in Python 3.5 and greater"),null;f(L,O.funcdef);var W=m(d(L,N));if(a(D,W,d(L,N),0))return null;var T=E(D,d(L,N+1));if(!T)return null;if(d(L,N+2).type==V.T_RARROW){K=U(D,d(L,N+3));if(!K)return null;N+=2}if(d(L,N+3).type==V.T_TYPE_COMMENT){R=V.T_NEW_TYPE_COMMENT(d(L,N+3));if(!R)return null;N+=1}var ba=q(D,d(L,N+3));if(!ba)return null;if(1<e(d(L,N+3))&&(N=d(d(L,N+3),1),N.type==V.T_TYPE_COMMENT)){if(null!=
R)return h(D,L,"Cannot have two type comments on def"),null;R=V.T_NEW_TYPE_COMMENT(N);if(!R)return null}return G?new Sk.astnodes.AsyncFunctionDef(W,T,ba,C,K,R,w.lineno,w.col_offset,void 0,void 0):new Sk.astnodes.FunctionDef(W,T,ba,C,K,R,L.lineno,L.col_offset,void 0,void 0)}function y(D,w,C){f(w,O.classdef);if(4==e(w)){var G=q(D,d(w,3));var L=m(d(w,1).value);a(D,d(w,3),L,w.lineno);return new Sk.astnodes.ClassDef(L,[],[],G,C,null,w.lineno,w.col_offset)}if(d(w,3).type===V.T_RPAR)return G=q(D,d(w,5)),
L=m(d(w,1).value),a(D,d(w,3),L,d(w,3).lineno),new Sk.astnodes.ClassDef(L,[],[],G,C,null,w.lineno,w.col_offset);L=m(d(w,1));L=new Sk.astnodes.Name(L,Sk.astnodes.Load,w.lineno,w.col_offset);var K=v(D,d(w,3),L,!1);G=q(D,d(w,6));L=m(d(w,1).value);a(D,d(w,1),L,d(w,1).lineno);return new Sk.astnodes.ClassDef(L,K.args,K.keywords,G,C,null,w.lineno,w.col_offset)}function A(D,w){function C(Y,da){for(Y=0;;){f(da,O.comp_iter);if(d(da,0).type===O.comp_for)return Y;da=d(da,0);f(da,O.comp_if);Y++;if(2===e(da))return Y;
da=d(da,2)}}var G;var L=function(Y,da){Y=0;a:for(;;){Y++;f(da,O.comp_for);if(5===e(da))da=d(da,4);else return Y;b:for(;;){f(da,O.comp_iter);da=d(da,0);if(da.type===O.comp_for)continue a;else if(da.type===O.comp_if)if(3===e(da)){da=d(da,2);continue b}else return Y;break}break}Sk.asserts.fail("logic error in countCompFors")}(D,w);var K=[];for(G=0;G<L;++G){f(w,O.comp_for);var N=d(w,1);var R=z(D,N,Sk.astnodes.Store);var W=U(D,d(w,3));var T=1===e(N)?new Sk.astnodes.comprehension(R[0],W,[]):new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(R,
Sk.astnodes.Store,w.lineno,w.col_offset),W,[]);if(5===e(w)){w=d(w,4);var ba=C(D,w);N=[];for(R=0;R<ba;++R)f(w,O.comp_iter),w=d(w,0),f(w,O.comp_if),W=U(D,d(w,1)),N[R]=W,3===e(w)&&(w=d(w,2));w.type===O.comp_iter&&(w=d(w,0));T.ifs=N}K[G]=T}return K}function J(D,w){var C=[];a:{var G=w;var L=0;b:for(;;){var K=0;L++;f(G,O.comp_for);d(G,0).type==V.T_ASYNC&&(K=1);if(e(G)==5+K)G=d(G,4+K);else break a;c:for(;;){f(G,O.comp_iter);G=d(G,0);if(G.type===O.comp_for)continue b;else if(G.type===O.comp_if)if(3===e(G)){G=
d(G,2);continue c}else break a;break}break}L=void 0}for(G=0;G<L;G++){var N=0;d(w,0).type==V.T_ASYNC&&(N=1);var R=d(w,1+N);var W=z(D,R,Sk.astnodes.Store);if(!W)return null;K=U(D,d(w,3+N));if(!K)return null;var T=W[0];W=1==e(R)?new Sk.astnodes.comprehension(T,K,null,N):new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(W,Sk.astnodes.Store,T.lineno,T.col_offset,R.end_lineno,R.end_col_offset),K,null,N);if(e(w)==5+N){T=[];w=d(w,4+N);a:for(K=w,N=0;;){f(K,O.comp_iter);if(d(K,0).type==O.comp_for){R=N;break a}K=
d(K,0);f(K,O.comp_if);N++;if(2==e(K)){R=N;break a}K=d(K,2)}if(-1==R)return null;for(N=0;N<R;N++){f(w,O.comp_iter);w=d(w,0);f(w,O.comp_if);K=U(D,d(w,1));if(!K)return null;T[N]=K;3==e(w)&&(w=d(w,2))}w.type==O.comp_iter&&(w=d(w,0));W.ifs=T}C[G]=W}return C}function Q(D,w,C){Sk.asserts.assert(1<e(w));var G=d(w,0);var L=U(D,G);if(L.constructor===Sk.astnodes.Starred)return h(D,G,"iterable unpacking cannot be used in comprehension"),null;D=J(D,d(w,1));return 0==C?new Sk.astnodes.GeneratorExp(L,D,w.lineno,
w.col_offset,w.end_lineno,w.end_col_offset):1==C?new Sk.astnodes.ListComp(L,D,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset):2==C?new Sk.astnodes.SetComp(L,D,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset):null}function X(D,w){f(w,O.augassign);w=d(w,0);switch(w.value.charAt(0)){case "+":return Sk.astnodes.Add;case "-":return Sk.astnodes.Sub;case "/":return"/"===w.value.charAt(1)?Sk.astnodes.FloorDiv:Sk.astnodes.Div;case "%":return Sk.astnodes.Mod;case "<":return Sk.astnodes.LShift;case ">":return Sk.astnodes.RShift;
case "&":return Sk.astnodes.BitAnd;case "^":return Sk.astnodes.BitXor;case "|":return Sk.astnodes.BitOr;case "*":return"*"===w.value.charAt(1)?Sk.astnodes.Pow:Sk.astnodes.Mult;case "@":if(Sk.__future__.python3)return Sk.astnodes.MatMult;default:Sk.asserts.fail("invalid augassign")}}function aa(D,w){Sk.asserts.assert(0<e(w));w.type===O.testlist_comp?1<e(w)&&Sk.asserts.assert(d(w,1).type!==O.comp_for):Sk.asserts.assert(w.type===O.testlist||w.type===O.testlist_star_expr);return 1===e(w)?U(D,d(w,0)):
new Sk.astnodes.Tuple(l(D,w),Sk.astnodes.Load,w.lineno,w.col_offset)}function ea(D,w){f(w,O.expr_stmt);if(1===e(w))return new Sk.astnodes.Expr(aa(D,d(w,0)),w.lineno,w.col_offset);if(d(w,1).type===O.augassign){var C=d(w,0);var G=aa(D,C);c(D,G,Sk.astnodes.Store,C);switch(G.constructor){case Sk.astnodes.Name:var L=G.id;a(D,C,L,w.lineno);break;case Sk.astnodes.Attribute:case Sk.astnodes.Subscript:break;case Sk.astnodes.GeneratorExp:throw new Sk.builtin.SyntaxError("augmented assignment to generator expression not possible",
D.c_filename,w.lineno);case Sk.astnodes.Yield:throw new Sk.builtin.SyntaxError("augmented assignment to yield expression not possible",D.c_filename,w.lineno);default:throw new Sk.builtin.SyntaxError("illegal expression for augmented assignment",D.c_filename,w.lineno);}C=d(w,2);L=C.type===O.testlist?aa(D,C):U(D,C);return new Sk.astnodes.AugAssign(G,X(D,d(w,1)),L,w.lineno,w.col_offset)}if(d(w,1).type===O.annassign){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("Annotated assignment is not supported in Python 2",
D.c_filename,w.lineno);C=d(w,0);var K=d(w,1);var N=1;for(G=C;1==e(G);)G=d(G,0);0<e(G)&&d(G,0).type==V.T_LPAR&&(N=0);G=aa(D,C);switch(G.constructor){case Sk.astnodes.Name:L=G.id;a(D,C,L,w.lineno);c(D,G,Sk.astnodes.Store,C);break;case Sk.astnodes.Attribute:L=G.attr;a(D,C,L,w.lineno);c(D,G,Sk.astnodes.Store,C);break;case Sk.astnodes.Subscript:c(D,G,Sk.astnodes.Store,C);break;case Sk.astnodes.List:throw new Sk.builtin.SyntaxError("only single target (not list) can be annotated",D.c_filename,w.lineno);
case Sk.astnodes.Tuple:throw new Sk.builtin.SyntaxError("only single target (not tuple) can be annotated",D.c_filename,w.lineno);default:throw new Sk.builtin.SyntaxError("illegal target for annotation",D.c_filename,w.lineno);}G.constructor!=Sk.astnodes.Name&&(N=0);C=d(K,1);L=U(D,C);if(2==e(K))return new Sk.astnodes.AnnAssign(G,L,null,N,w.lineno,w.col_offset);C=d(K,3);D=U(D,C);return new Sk.astnodes.AnnAssign(G,L,D,N,w.lineno,w.col_offset)}f(d(w,1),V.T_EQUAL);N=[];for(G=0;G<e(w)-2;G+=2){C=d(w,G);if(C.type===
O.yield_expr)throw new Sk.builtin.SyntaxError("assignment to yield expression not possible",D.c_filename,w.lineno);C=aa(D,C);c(D,C,Sk.astnodes.Store,d(w,G));N[G/2]=C}C=d(w,e(w)-1);D=C.type===O.testlist_star_expr?aa(D,C):U(D,C);return new Sk.astnodes.Assign(N,D,w.lineno,w.col_offset)}function na(D,w,C,G,L){Sk.asserts.assert(C>=w);Sk.asserts.assert("{"==D.charAt(w-1));Sk.asserts.assert("}"==D.charAt(C)||"!"==D.charAt(C)||":"==D.charAt(C));D=D.substring(w,C);/^\s*$/.test(D)&&h(G,L,"f-string: empty expression not allowed");
try{let N=Sk.parse("<fstring>","("+D+")");var K=Sk.astFromParse(N.cst,"<fstring>",N.flags)}catch(N){throw N.traceback&&N.traceback[0]&&(K=N.traceback[0],K.lineno=(K.lineno||1)-1+L.lineno,K.filename=G.c_filename),N;}Sk.asserts.assert(1==K.body.length&&K.body[0].constructor===Sk.astnodes.Expr);return K.body[0].value}function oa(D,w,C,G,L,K,N){Sk.asserts.assert("{"==D.charAt(w));w++;var R=w;let W=null,T=0,ba=0,Y,da,ma=()=>h(K,N,"f-string: expecting '}'");for(Sk.asserts.assert(w<=C);w<C;w++){let ha=D.charAt(w);
"\\"==ha&&h(K,N,"f-string expression part cannot include a backslash");if(W)ha==W&&(3==T?w+2<C&&D.charAt(w+1)==ha&&D.charAt(w+2)==ha&&(w+=2,W=T=0):T=W=0);else if("'"==ha||'"'==ha)w+2<C&&D.charAt(w+1)==ha&&D.charAt(w+2)==ha?(T=3,w+=2):T=1,W=ha;else if("["==ha||"{"==ha||"("==ha)ba++;else if(0!=ba&&("]"==ha||"}"==ha||")"==ha))ba--;else if("#"==ha)h(K,N,"f-string expression part cannot include '#'");else if(!(0!=ba||"!"!=ha&&":"!=ha&&"}"!=ha||"!"==ha&&w+1<C&&"="==D.charAt(w+1)))break}W&&h(K,N,"f-string: unterminated string");
ba&&h(K,N,"f-string: mismatched '(', '{', or '['");R=na(D,R,w,K,N);"!"==D.charAt(w)&&(w++,w>=C&&ma(),da=D.charAt(w),w++,"s"!=da&&"r"!=da&&"a"!=da&&h(K,N,"f-string: invalid conversion character: expected 's', 'r', or 'a'"));w>=C&&ma();":"==D.charAt(w)&&(w++,w>=C&&ma(),[Y,w]=ca(D,w,C,G,L+1,K,N));(w>=C||"}"!=D.charAt(w))&&ma();w++;return[new Sk.astnodes.FormattedValue(R,da,Y,N.lineno,N.col_offset),w]}function ca(D,w,C,G,L,K,N){let R=[],W=T=>{if(-1!==T.indexOf("}")){if(/(^|[^}])}(}})*($|[^}])/.test(T))throw new Sk.builtin.SyntaxError("f-string: single '}' is not allowed",
K.c_filename,N.lineno,N.col_offset);T=T.replace(/}}/g,"}")}R.push(new Sk.astnodes.Str(new Sk.builtin.str(T),N.lineno,N.col_offset,K.end_lineno,N.end_col_offset))};for(;w<C;){let T=D.indexOf("{",w);if(0!==L){let ba=D.indexOf("}",w);-1!==ba&&(-1===T?C=ba:T>ba&&(T=-1,C=ba))}if(-1===T){W(D.substring(w,C));w=C;break}else if(T+1<C&&"{"===D.charAt(T+1))W(D.substring(w,T+1)),w=T+2;else{W(D.substring(w,T));w=T;let [ba,Y]=oa(D,T,C,G,L,K,N);R.push(ba);w=Y}}return[new Sk.astnodes.JoinedStr(R,N.lineno,N.col_offset),
w]}function la(D,w){var C,G;f(w,O.subscript);var L=d(w,0);var K=C=G=null;if(L.type===V.T_DOT)return new Sk.astnodes.Ellipsis;if(1===e(w)&&L.type===O.test)return new Sk.astnodes.Index(U(D,L));L.type===O.test&&(G=U(D,L));L.type===V.T_COLON?1<e(w)&&(L=d(w,1),L.type===O.test&&(C=U(D,L))):2<e(w)&&(L=d(w,2),L.type===O.test&&(C=U(D,L)));L=d(w,e(w)-1);L.type===O.sliceop&&(1===e(L)?(L=d(L,0),K=new Sk.astnodes.NameConstant(Sk.builtin.none.none$,Sk.astnodes.Load,L.lineno,L.col_offset)):(L=d(L,1),L.type===O.test&&
(K=U(D,L))));return new Sk.astnodes.Slice(G,C,K)}function ia(D,w){var C=d(w,0);switch(C.type){case V.T_NAME:var G=C.value;if(4<=G.length&&5>=G.length){if("None"===G)return new Sk.astnodes.NameConstant(Sk.builtin.none.none$,w.lineno,w.col_offset);if("True"===G)return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$,w.lineno,w.col_offset);if("False"===G)return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$,w.lineno,w.col_offset)}D=m(G,D);return new Sk.astnodes.Name(D,Sk.astnodes.Load,w.lineno,
w.col_offset,w.end_lineno,w.end_col_offset);case V.T_STRING:C=[];for(var L=0;L<e(w);++L){var K=d(w,L).value;var N=D;var R=d(w,L);var W=K;var T=W.charAt(0);for(var ba=!1,Y=K=!1;;){if("u"!==T&&"U"!==T)if("r"===T||"R"===T)ba=!0;else if("b"===T||"B"===T)Y=!0;else if("f"===T||"F"===T)K=!0;else break;W=W.substr(1);T=W.charAt(0)}Sk.asserts.assert("'"===T||'"'===T&&W.charAt(W.length-1)===T);W=W.substr(1,W.length-2);4<=W.length&&W.charAt(0)===T&&W.charAt(1)===T&&(Sk.asserts.assert(W.charAt(W.length-1)===T&&
W.charAt(W.length-2)===T),W=W.substr(2,W.length-4));if(ba||-1===W.indexOf("\\")){if(Y)for(T=0;T<W.length;T++)127<W.charCodeAt(T)&&h(N,R,"bytes can only contain ASCII literal characters");N=[p(W),K,Y]}else{ba=W;var da=ba.length,ma="";for(W=0;W<da;++W)T=ba.charAt(W),"\\"===T?(++W,T=ba.charAt(W),"n"===T?ma+="\n":"\\"===T?ma+="\\":"t"===T?ma+="\t":"r"===T?ma+="\r":"b"===T?ma+="\b":"f"===T?ma+="\f":"v"===T?ma+="\v":"0"===T?ma+="\x00":'"'===T?ma+='"':"'"===T?ma+="'":"\n"!==T&&("x"===T?(W+2>=da&&h(N,R,"Truncated \\xNN escape"),
ma+=String.fromCharCode(parseInt(ba.substr(W+1,2),16)),W+=2):Y||"u"!==T?Y||"U"!==T?ma+="\\"+T:(W+8>=da&&h(N,R,"Truncated \\UXXXXXXXX escape"),ma+=String.fromCodePoint(parseInt(ba.substr(W+1,8),16)),W+=8):(W+4>=da&&h(N,R,"Truncated \\uXXXX escape"),ma+=String.fromCharCode(parseInt(ba.substr(W+1,4),16)),W+=4))):Y&&127<T.charCodeAt(0)?h(N,R,"bytes can only contain ASCII literal characters"):ma+=T;N=ma;N=[p(N),K,Y]}K=N;N=K[0];R=K[1];K=K[2];0!=L&&G!==K&&h(D,w,"cannot mix bytes and nonbytes literals");
G=K;if(R){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("invalid string (f-strings are not supported in Python 2)",D.c_filename,d(w,L).lineno);var ha=N.$jsstr();[ha]=ca(ha,0,ha.length,!1,0,D,d(w,L));C.push.apply(C,ha.values);ha=null}else ha?ha.s=ha.s.sq$concat(N):(ha=new (G?Sk.astnodes.Bytes:Sk.astnodes.Str)(N,w.lineno,w.col_offset,D.end_lineno,w.end_col_offset),C.push(ha))}w=1===C.length&&C[0].constructor===Sk.astnodes.Str?C[0]:new Sk.astnodes.JoinedStr(C,w.lineno,w.col_offset,D.end_lineno,
w.end_col_offset);return w;case V.T_NUMBER:D=Sk.astnodes.Num;G=C.value;G=G.replace(pa,"");L=G[G.length-1];if("j"===L||"J"===L)G=new Sk.builtin.complex(0,parseFloat(G.slice(0,-1)));else if(qa.test(G))G=new Sk.builtin.float_(parseFloat(G));else{"0"===G[0]&&"0"!==G&&65>G.charCodeAt(1)&&(G="0o"+G.substring(1));C=!0;if("l"===L||"L"===L)G=G.slice(0,-1),C=!1;L=Number(G);G=L>Number.MAX_SAFE_INTEGER?C?new Sk.builtin.int_(JSBI.BigInt(G)):new Sk.builtin.lng(JSBI.BigInt(G)):C?new Sk.builtin.int_(L):new Sk.builtin.lng(L)}return new D(G,
w.lineno,w.col_offset);case V.T_ELLIPSIS:return new Sk.astnodes.Ellipsis(w.lineno,w.col_offset,w.end_lineno,w.end_col_offset);case V.T_LPAR:return C=d(w,1),C.type==V.T_RPAR?new Sk.astnodes.Tuple([],Sk.astnodes.Load,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset):C.type==O.yield_expr?U(D,C):1==e(C)?aa(D,C):d(C,1).type==O.comp_for?u(t(D,C),w):u(aa(D,C),w);case V.T_LSQB:C=d(w,1);if(C.type==V.T_RSQB)return new Sk.astnodes.List([],Sk.astnodes.Load,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset);
f(C,O.testlist_comp);if(1==e(C)||d(C,1).type==V.T_COMMA)return(D=l(D,C))?new Sk.astnodes.List(D,Sk.astnodes.Load,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset):null;G=C;Sk.asserts.assert(G.type==O.testlist_comp);D=Q(D,G,1);return u(D,w);case V.T_LBRACE:C=d(w,1);if(C.type==V.T_RBRACE)return new Sk.astnodes.Dict(null,null,w.lineno,w.col_offset,w.end_lineno,w.end_col_offset);G=d(C,0).type==V.T_DOUBLESTAR;if(1==e(C)||1<e(C)&&d(C,1).type==V.T_COMMA){G=C;L=[];Sk.asserts.assert(G.type===O.dictorsetmaker);
for(C=0;C<e(G);C+=2)ha=U(D,d(G,C)),L[C/2]=ha;D=new Sk.astnodes.Set(L,G.lineno,G.col_offset)}else if(1<e(C)&&d(C,1).type==O.comp_for)G=C,Sk.asserts.assert(G.type===O.dictorsetmaker),Sk.asserts.assert(1<e(G)),C=U(D,d(G,0)),D=A(D,d(G,1)),D=new Sk.astnodes.SetComp(C,D,G.lineno,G.col_offset);else if(e(C)>3-G&&d(C,3-G).type==O.comp_for){if(G)return h(D,w,"dict unpacking cannot be used in dict comprehension"),null;G=C;Sk.asserts.assert(3<e(G));f(d(G,1),V.T_COLON);C=U(D,d(G,0));L=U(D,d(G,2));D=A(D,d(G,3));
D=new Sk.astnodes.DictComp(C,L,D,G.lineno,G.col_offset)}else{G=C;L=[];ha=[];for(K=C=0;K<e(G);K++)N=D,R=G,Y=K,d(R,Y).type==V.T_DOUBLESTAR?(Sk.asserts.assert(2<=e(R)-Y),K=U(N,d(R,Y+1)),N={key:null,value:K,i:Y+2}):(Sk.asserts.assert(3<=e(R)-Y),(K=U(N,d(R,Y)))?(W=K,f(d(R,Y+1),V.T_COLON),N=(K=U(N,d(R,Y+2)))?{key:W,value:K,i:Y+3}:!1):N=0),K=N.i,L[C]=N.key,ha[C]=N.value,C++;D=new Sk.astnodes.Dict(L,ha,G.lineno,G.col_offset,G.end_lineno,G.end_col_offset)}return u(D,w);default:return Sk.asserts.fail("unhandled atom "+
C.type),null}}function ka(D,w){var C,G=0;f(w,O.atom_expr);var L=e(w);d(w,0).type===V.T_AWAIT&&(G=1,Sk.asserts.assert(1<L));var K=ia(D,d(w,G));if(!K)return null;if(1===L)return K;if(G&&2===L)return new Sk.astnodes.Await(K,w.lineno,w.col_offset);for(C=G+1;C<L;C++){var N=d(w,C);if(N.type!==O.trailer)break;N=B(D,N,K);if(!N)return null;N.lineno=K.lineno;N.col_offset=K.col_offset;K=N}return G?new Sk.astnodes.Await(K,w.line,w.col_offset):K}function U(D,w){a:for(;;){switch(w.type){case O.test:case O.test_nocond:if(d(w,
0).type===O.lambdef||d(w,0).type===O.lambdef_nocond){var C=d(w,0);3===e(C)?(w=new Sk.astnodes.arguments_([],null,null,[]),D=U(D,d(C,2))):(w=E(D,d(C,1)),D=U(D,d(C,3)));return new Sk.astnodes.Lambda(w,D,C.lineno,C.col_offset)}if(1<e(w))return Sk.asserts.assert(5===e(w)),new Sk.astnodes.IfExp(U(D,d(w,2)),U(D,d(w,0)),U(D,d(w,4)),w.lineno,w.col_offset);case O.or_test:case O.and_test:if(1===e(w)){w=d(w,0);continue a}var G=[];for(C=0;C<e(w);C+=2)G[C/2]=U(D,d(w,C));if("and"===d(w,1).value)return new Sk.astnodes.BoolOp(Sk.astnodes.And,
G,w.lineno,w.col_offset);Sk.asserts.assert("or"===d(w,1).value);return new Sk.astnodes.BoolOp(Sk.astnodes.Or,G,w.lineno,w.col_offset);case O.not_test:if(1===e(w)){w=d(w,0);continue a}else return new Sk.astnodes.UnaryOp(Sk.astnodes.Not,U(D,d(w,1)),w.lineno,w.col_offset);case O.comparison:if(1===e(w)){w=d(w,0);continue a}else{var L=[];G=[];for(C=1;C<e(w);C+=2)L[(C-1)/2]=k(D,d(w,C)),G[(C-1)/2]=U(D,d(w,C+1));return new Sk.astnodes.Compare(U(D,d(w,0)),L,G,w.lineno,w.col_offset)}case O.star_expr:return f(w,
O.star_expr),new Sk.astnodes.Starred(U(D,d(w,1)),Sk.astnodes.Load,w.lineno,w.col_offset);case O.expr:case O.xor_expr:case O.and_expr:case O.shift_expr:case O.arith_expr:case O.term:if(1===e(w)){w=d(w,0);continue a}var K=w,N=new Sk.astnodes.BinOp(U(D,d(K,0)),n(d(K,1)),U(D,d(K,2)),K.lineno,K.col_offset),R=(e(K)-1)/2;for(w=1;w<R;++w)C=d(K,2*w+1),G=n(C),L=U(D,d(K,2*w+2)),N=new Sk.astnodes.BinOp(N,G,L,C.lineno,C.col_offset);return N;case O.yield_expr:return G=!1,L=null,1<e(w)&&(C=d(w,1)),C&&(L=d(C,e(C)-
1),2==e(C)?(G=!0,L=U(D,L)):L=aa(D,L)),G?new Sk.astnodes.YieldFrom(L,w.lineno,w.col_offset):new Sk.astnodes.Yield(L,w.lineno,w.col_offset);case O.factor:if(1===e(w)){w=d(w,0);continue a}return x(D,w);case O.power:return C=w,f(C,O.power),w=ka(D,d(C,0)),1!==e(C)&&d(C,e(C)-1).type===O.factor&&(D=U(D,d(C,e(C)-1)),w=new Sk.astnodes.BinOp(w,Sk.astnodes.Pow,D,C.lineno,C.col_offset)),w;default:Sk.asserts.fail("unhandled expr","n.type: %d",w.type)}break}}function ja(D,w){w.type===O.stmt&&(Sk.asserts.assert(1===
e(w)),w=d(w,0));w.type===O.simple_stmt&&(Sk.asserts.assert(1===g(w)),w=d(w,0));if(w.type===O.small_stmt)switch(w=d(w,0),w.type){case O.expr_stmt:return ea(D,w);case O.del_stmt:var C=w;f(C,O.del_stmt);return new Sk.astnodes.Delete(z(D,d(C,1),Sk.astnodes.Del),C.lineno,C.col_offset);case O.pass_stmt:return new Sk.astnodes.Pass(w.lineno,w.col_offset);case O.flow_stmt:return I(D,w);case O.import_stmt:var G=w,L;f(G,O.import_stmt);var K=G.lineno;w=G.col_offset;G=d(G,0);if(G.type===O.import_name){G=d(G,1);
f(G,O.dotted_as_names);var N=[];for(L=0;L<e(G);L+=2)N[L/2]=r(D,d(G,L));D=new Sk.astnodes.Import(N,K,w)}else if(G.type===O.import_from){var R=null;C=0;for(N=1;N<e(G);++N)if(d(G,N).type===O.dotted_name){R=r(D,d(G,N));N++;break}else if(d(G,N).type===V.T_DOT)C++;else if(d(G,N).type===V.T_ELLIPSIS)C+=3;else break;++N;switch(d(G,N).type){case V.T_STAR:G=d(G,N);break;case V.T_LPAR:G=d(G,N+1);e(G);break;case O.import_as_names:G=d(G,N);N=e(G);if(0===N%2)throw new Sk.builtin.SyntaxError("trailing comma not allowed without surrounding parentheses",
D.c_filename,G.lineno);break;default:throw new Sk.builtin.SyntaxError("Unexpected node-type in from-import",D.c_filename,G.lineno);}N=[];if(G.type===V.T_STAR)N[0]=r(D,G);else for(L=0;L<e(G);L+=2)N[L/2]=r(D,d(G,L));D=R?R.name.v:"";D=new Sk.astnodes.ImportFrom(p(D),N,C,K,w)}else throw new Sk.builtin.SyntaxError("unknown import statement",D.c_filename,G.lineno);return D;case O.global_stmt:D=w;w=[];f(D,O.global_stmt);for(C=1;C<e(D);C+=2)w[(C-1)/2]=p(d(D,C).value);return new Sk.astnodes.Global(w,D.lineno,
D.col_offset);case O.nonlocal_stmt:h(D,w,"Not implemented: nonlocal");break;case O.assert_stmt:return C=w,f(C,O.assert_stmt),2===e(C)?D=new Sk.astnodes.Assert(U(D,d(C,1)),null,C.lineno,C.col_offset):4===e(C)?D=new Sk.astnodes.Assert(U(D,d(C,1)),U(D,d(C,3)),C.lineno,C.col_offset):(Sk.asserts.fail("improper number of parts to assert stmt"),D=void 0),D;case O.print_stmt:C=w;Sk.__future__.print_function&&h(D,C,"Missing parentheses in call to 'print'");G=1;K=null;f(C,O.print_stmt);2<=e(C)&&d(C,1).type===
V.T_RIGHTSHIFT&&(K=U(D,d(C,2)),G=4);w=[];for(R=0;G<e(C);G+=2,++R)w[R]=U(D,d(C,G));D=d(C,e(C)-1).type===V.T_COMMA?!1:!0;return new Sk.astnodes.Print(K,w,D,C.lineno,C.col_offset);case O.debugger_stmt:return new Sk.astnodes.Debugger(w.lineno,w.col_offset);default:Sk.asserts.fail("unhandled small_stmt")}else switch(C=d(w,0),f(w,O.compound_stmt),C.type){case O.if_stmt:f(C,O.if_stmt);if(4===e(C))D=new Sk.astnodes.If(U(D,d(C,1)),q(D,d(C,3)),[],C.lineno,C.col_offset);else if(w=d(C,4).value.charAt(2),"s"===
w)D=new Sk.astnodes.If(U(D,d(C,1)),q(D,d(C,3)),q(D,d(C,6)),C.lineno,C.col_offset);else if("i"===w){K=e(C)-4;G=!1;w=[];d(C,K+1).type===V.T_NAME&&"s"===d(C,K+1).value.charAt(2)&&(G=!0,K-=3);K/=4;G&&(w=[new Sk.astnodes.If(U(D,d(C,e(C)-6)),q(D,d(C,e(C)-4)),q(D,d(C,e(C)-1)),d(C,e(C)-6).lineno,d(C,e(C)-6).col_offset)],K--);for(R=0;R<K;++R)G=5+4*(K-R-1),w=[new Sk.astnodes.If(U(D,d(C,G)),q(D,d(C,G+2)),w,d(C,G).lineno,d(C,G).col_offset)];D=new Sk.astnodes.If(U(D,d(C,1)),q(D,d(C,3)),w,C.lineno,C.col_offset)}else Sk.asserts.fail("unexpected token in 'if' statement"),
D=void 0;return D;case O.while_stmt:return f(C,O.while_stmt),4===e(C)?D=new Sk.astnodes.While(U(D,d(C,1)),q(D,d(C,3)),[],C.lineno,C.col_offset):7===e(C)?D=new Sk.astnodes.While(U(D,d(C,1)),q(D,d(C,3)),q(D,d(C,6)),C.lineno,C.col_offset):(Sk.asserts.fail("wrong number of tokens for 'while' stmt"),D=void 0),D;case O.for_stmt:return w=[],f(C,O.for_stmt),9===e(C)&&(w=q(D,d(C,8))),G=d(C,1),K=z(D,G,Sk.astnodes.Store),K=1===e(G)?K[0]:new Sk.astnodes.Tuple(K,Sk.astnodes.Store,C.lineno,C.col_offset),new Sk.astnodes.For(K,
aa(D,d(C,3)),q(D,d(C,5)),w,C.lineno,C.col_offset);case O.try_stmt:w=[];L=e(C);K=(L-3)/3;R=[];N=null;f(C,O.try_stmt);G=q(D,d(C,2));if(d(C,L-3).type===V.T_NAME)"finally"===d(C,L-3).value?(9<=L&&d(C,L-6).type===V.T_NAME&&(R=q(D,d(C,L-4)),K--),N=q(D,d(C,L-1))):R=q(D,d(C,L-1)),K--;else if(d(C,L-3).type!==O.except_clause)throw new Sk.builtin.SyntaxError("malformed 'try' statement",D.c_filename,C.lineno);if(0<K)for(L=0;L<K;L++){var W=L;var T=D,ba=d(C,3+3*L),Y=d(C,5+3*L);f(ba,O.except_clause);f(Y,O.suite);
if(1===e(ba))var da=new Sk.astnodes.ExceptHandler(null,null,q(T,Y),ba.lineno,ba.col_offset);else 2===e(ba)?da=new Sk.astnodes.ExceptHandler(U(T,d(ba,1)),null,q(T,Y),ba.lineno,ba.col_offset):4===e(ba)?(Sk.__future__.python3&&","==d(ba,2).value&&h(T,ba,"Old-style 'except' clauses are not supported in Python 3"),U(T,d(ba,1)),da=U(T,d(ba,3)),c(T,da,Sk.astnodes.Store,d(ba,3)),da=new Sk.astnodes.ExceptHandler(U(T,d(ba,1)),da,q(T,Y),ba.lineno,ba.col_offset)):(Sk.asserts.fail("wrong number of children for except clause"),
da=void 0);w[W]=da}Sk.asserts.assert(!!N||0!=w.length);return new Sk.astnodes.Try(G,w,R,N,C.lineno,C.col_offset);case O.with_stmt:w=[];f(C,O.with_stmt);for(K=1;K<e(C)-2;K+=2)G=void 0,N=D,L=d(C,K),f(L,O.with_item),R=U(N,d(L,0)),3==e(L)&&(G=U(N,d(L,2)),c(N,G,Sk.astnodes.Store,L)),G=new Sk.astnodes.withitem(R,G),w[(K-1)/2]=G;D=q(D,d(C,e(C)-1));D=new Sk.astnodes.With(w,D,C.lineno,C.col_offset);return D;case O.funcdef:return H(D,C,[],!1);case O.classdef:return y(D,C,[]);case O.decorated:K=null;f(C,O.decorated);
G=d(C,0);f(G,O.decorators);w=[];for(R=0;R<e(G);++R){N=w;L=R;W=D;da=d(G,R);f(da,O.decorator);f(d(da,0),V.T_AT);f(d(da,e(da)-1),V.T_NEWLINE);var ma,ha=d(da,1);f(ha,O.dotted_name);T=ha.lineno;ba=ha.col_offset;Y=p(d(ha,0).value);var ra=new Sk.astnodes.Name(Y,Sk.astnodes.Load,T,ba);for(ma=2;ma<e(ha);ma+=2)Y=p(d(ha,ma).value),ra=new Sk.astnodes.Attribute(ra,Y,Sk.astnodes.Load,T,ba);T=ra;W=3===e(da)?T:5===e(da)?new Sk.astnodes.Call(T,[],[],da.lineno,da.col_offset):v(W,d(da,3),T);N[L]=W}Sk.asserts.assert(d(C,
1).type==O.funcdef||d(C,1).type==O.async_funcdef||d(C,1).type==O.classdef);d(C,1).type==O.funcdef?(K=d(C,1),K=H(D,K,w,!1)):d(C,1).type==O.classdef?K=y(D,d(C,1),w):d(C,1).type==O.async_funcdef&&(K=d(C,1),f(K,O.async_funcdef),f(d(K,0),V.T_NAME),Sk.asserts.assert(("async"===d(K,0)).value),f(d(K,1),O.funcdef),K=H(D,K,w,!0));K&&(K.lineno=C.lineno,K.col_offset=C.col_offset);return K;case O.async_stmt:h(D,C,"Not implemented: async");break;default:Sk.asserts.assert("unhandled compound_stmt")}}var O=Sk.ParseTables.sym,
V=Sk.token.tokens,Z={Slice_kind:1,ExtSlice_kind:2,Index_kind:3},fa={};fa[V.T_VBAR]=Sk.astnodes.BitOr;fa[V.T_CIRCUMFLEX]=Sk.astnodes.BitXor;fa[V.T_AMPER]=Sk.astnodes.BitAnd;fa[V.T_LEFTSHIFT]=Sk.astnodes.LShift;fa[V.T_RIGHTSHIFT]=Sk.astnodes.RShift;fa[V.T_PLUS]=Sk.astnodes.Add;fa[V.T_MINUS]=Sk.astnodes.Sub;fa[V.T_STAR]=Sk.astnodes.Mult;fa[V.T_SLASH]=Sk.astnodes.Div;fa[V.T_DOUBLESLASH]=Sk.astnodes.FloorDiv;fa[V.T_PERCENT]=Sk.astnodes.Mod;Sk.setupOperators=function(D){D?fa[V.T_AT]=Sk.astnodes.MatMult:
fa[V.T_AT]&&delete fa[V.T_AT]};Sk.exportSymbol("Sk.setupOperators",Sk.setupOperators);const qa=new RegExp("^"+Sk._tokenize.Floatnumber+"$"),pa=/_/g;Sk.astFromParse=function(D,w,C){var G,L=new b("utf-8",w,C),K=[],N=0;switch(D.type){case O.file_input:for(G=0;G<e(D)-1;++G){var R=d(D,G);if(R.type!==V.T_NEWLINE)if(f(R,O.stmt),C=g(R),1===C)K[N++]=ja(L,R);else for(R=d(R,0),f(R,O.simple_stmt),w=0;w<C;++w)K[N++]=ja(L,d(R,2*w))}return new Sk.astnodes.Module(K);case O.eval_input:Sk.asserts.fail("todo;");case O.single_input:Sk.asserts.fail("todo;");
default:Sk.asserts.fail("todo;")}};Sk.astDump=function(D){var w=function(G){var L,K="";for(L=0;L<G;++L)K+=" ";return K},C=function(G,L){var K;if(null===G)return L+"None";if(G.prototype&&void 0!==G.prototype._astname&&G.prototype._isenum)return L+G.prototype._astname+"()";if(void 0!==G._astname){var N=w(G._astname.length+1);var R=[];for(K=0;K<G._fields.length;K+=2){var W=G._fields[K];var T=G._fields[K+1](G);var ba=w(W.length+1);R.push([W,C(T,L+N+ba)])}T=[];for(K=0;K<R.length;++K)ba=R[K],T.push(ba[0]+
"="+ba[1].replace(/^\s+/,""));K=T.join(",\n"+L+N);return L+G._astname+"("+K+")"}if(Sk.isArrayLike(G)){N=[];for(K=0;K<G.length;++K)R=G[K],N.push(C(R,L+" "));G=N.join(",\n");return L+"["+G.replace(/^\s+/,"")+"]"}G=!0===G?"True":!1===G?"False":G instanceof Sk.builtin.lng?G.tp$str().v:G instanceof Sk.builtin.str?G.$r().v:""+G;return L+G};return C(D,"")};Sk.exportSymbol("Sk.astFromParse",Sk.astFromParse);Sk.exportSymbol("Sk.astDump",Sk.astDump)},function(F,P){function b(g,a,c){this.__name=g;this.__flags=
a;this.__scope=a>>11&7;this.__namespaces=c||[]}function e(g,a,c,n,m){this.symFlags={};this.name=a;this.varnames=[];this.children=[];this.blockType=c;this.returnsValue=this.varkeywords=this.varargs=this.generator=this.childHasFree=this.hasFree=this.isNested=!1;this.lineno=m;this.table=g;g.cur&&(g.cur.nested||"function"===g.cur.blockType)&&(this.isNested=!0);n.scopeId=p++;g.stss[n.scopeId]=this;this.symbols={}}function d(g){this.filename=g;this.top=this.cur=null;this.stack=[];this.curClass=this.global=
null;this.tmpname=0;this.stss={}}function f(g,a){var c;for(c=0;c<a.length;c++)g(a[c])}function h(g,a){for(var c in a)g[c]=a[c]}Sk.exportSymbol("Sk.SYMTAB_CONSTS",{DEF_GLOBAL:1,DEF_LOCAL:2,DEF_PARAM:4,USE:8,DEF_STAR:16,DEF_DOUBLESTAR:32,DEF_INTUPLE:64,DEF_FREE:128,DEF_FREE_GLOBAL:256,DEF_FREE_CLASS:512,DEF_IMPORT:1024,DEF_BOUND:1030,SCOPE_OFF:11,SCOPE_MASK:7,LOCAL:1,GLOBAL_EXPLICIT:2,GLOBAL_IMPLICIT:3,FREE:4,CELL:5,OPT_IMPORT_STAR:1,OPT_EXEC:2,OPT_BARE_EXEC:4,OPT_TOPLEVEL:8,GENERATOR:2,GENERATOR_EXPRESSION:2,
ModuleBlock:"module",FunctionBlock:"function",ClassBlock:"class"});b.prototype.get_name=function(){return this.__name};b.prototype.is_referenced=function(){return!!(this.__flags&8)};b.prototype.is_parameter=function(){return!!(this.__flags&4)};b.prototype.is_global=function(){return 3===this.__scope||2==this.__scope};b.prototype.is_declared_global=function(){return 2==this.__scope};b.prototype.is_local=function(){return!!(this.__flags&1030)};b.prototype.is_free=function(){return 4==this.__scope};
b.prototype.is_imported=function(){return!!(this.__flags&1024)};b.prototype.is_assigned=function(){return!!(this.__flags&2)};b.prototype.is_namespace=function(){return this.__namespaces&&0<this.__namespaces.length};b.prototype.get_namespaces=function(){return this.__namespaces};var p=0;e.prototype.get_type=function(){return this.blockType};e.prototype.get_name=function(){return this.name};e.prototype.get_lineno=function(){return this.lineno};e.prototype.is_nested=function(){return this.isNested};
e.prototype.has_children=function(){return 0<this.children.length};e.prototype.get_identifiers=function(){return this._identsMatching(function(){return!0})};e.prototype.lookup=function(g){if(this.symbols.hasOwnProperty(g))g=this.symbols[g];else{var a=this.symFlags[g];var c=this.__check_children(g);g=this.symbols[g]=new b(g,a,c)}return g};e.prototype.__check_children=function(g){var a,c=[];for(a=0;a<this.children.length;++a){var n=this.children[a];n.name===g&&c.push(n)}return c};e.prototype._identsMatching=
function(g){var a,c=[];for(a in this.symFlags)this.symFlags.hasOwnProperty(a)&&g(this.symFlags[a])&&c.push(a);c.sort();return c};e.prototype.get_parameters=function(){Sk.asserts.assert("function"==this.get_type(),"get_parameters only valid for function scopes");this._funcParams||(this._funcParams=this._identsMatching(function(g){return g&4}));return this._funcParams};e.prototype.get_locals=function(){Sk.asserts.assert("function"==this.get_type(),"get_locals only valid for function scopes");this._funcLocals||
(this._funcLocals=this._identsMatching(function(g){return g&1030}));return this._funcLocals};e.prototype.get_globals=function(){Sk.asserts.assert("function"==this.get_type(),"get_globals only valid for function scopes");this._funcGlobals||(this._funcGlobals=this._identsMatching(function(g){g=g>>11&7;return 3==g||2==g}));return this._funcGlobals};e.prototype.get_frees=function(){Sk.asserts.assert("function"==this.get_type(),"get_frees only valid for function scopes");this._funcFrees||(this._funcFrees=
this._identsMatching(function(g){return 4==(g>>11&7)}));return this._funcFrees};e.prototype.get_methods=function(){var g;Sk.asserts.assert("class"==this.get_type(),"get_methods only valid for class scopes");if(!this._classMethods){var a=[];for(g=0;g<this.children.length;++g)a.push(this.children[g].name);a.sort();this._classMethods=a}return this._classMethods};e.prototype.getScope=function(g){g=this.symFlags[g];return void 0===g?0:g>>11&7};d.prototype.getStsForAst=function(g){Sk.asserts.assert(void 0!==
g.scopeId,"ast wasn't added to st?");g=this.stss[g.scopeId];Sk.asserts.assert(void 0!==g,"unknown sym tab entry");return g};d.prototype.SEQStmt=function(g){var a,c;if(null!==g){Sk.asserts.assert(Sk.isArrayLike(g),"SEQ: nodes isn't array? got "+g.toString());var n=g.length;for(c=0;c<n;++c)(a=g[c])&&this.visitStmt(a)}};d.prototype.SEQExpr=function(g){var a,c;if(null!==g){Sk.asserts.assert(Sk.isArrayLike(g),"SEQ: nodes isn't array? got "+g.toString());var n=g.length;for(c=0;c<n;++c)(a=g[c])&&this.visitExpr(a)}};
d.prototype.enterBlock=function(g,a,c,n){g=Sk.fixReserved(g);var m=null;this.cur&&(m=this.cur,this.stack.push(this.cur));this.cur=new e(this,g,a,c,n);"top"===g&&(this.global=this.cur.symFlags);m&&m.children.push(this.cur)};d.prototype.exitBlock=function(){this.cur=null;0<this.stack.length&&(this.cur=this.stack.pop())};d.prototype.visitParams=function(g,a){var c;for(c=0;c<g.length;++c)if(a=g[c],a.constructor===Sk.astnodes.arg)this.addDef(a.arg,4,a.lineno);else throw new Sk.builtin.SyntaxError("invalid expression in parameter list",
this.filename);};d.prototype.visitAnnotations=function(g,a){g.posonlyargs&&this.visitArgAnnotations(g.posonlyargs);g.args&&this.visitArgAnnotations(g.args);g.vararg&&g.vararg.annotation&&this.visitExpr(g.vararg.annotation);g.kwarg&&g.kwarg.annotation&&this.visitExpr(g.kwarg.annotation);g.kwonlyargs&&this.visitArgAnnotations(g.kwonlyargs);a&&this.visitExpr(a)};d.prototype.visitArgAnnotations=function(g){for(let a=0;a<g.length;a++){const c=g[a];c.annotation&&this.visitExpr(c.annotation)}};d.prototype.visitArguments=
function(g,a){g.args&&this.visitParams(g.args,!0);g.kwonlyargs&&this.visitParams(g.kwonlyargs,!0);g.vararg&&(this.addDef(g.vararg.arg,4,a),this.cur.varargs=!0);g.kwarg&&(this.addDef(g.kwarg.arg,4,a),this.cur.varkeywords=!0)};d.prototype.newTmpname=function(g){this.addDef(new Sk.builtin.str("_["+ ++this.tmpname+"]"),2,g)};d.prototype.addDef=function(g,a,c){var n=Sk.mangleName(this.curClass,g).v;n=Sk.fixReserved(n);var m=this.cur.symFlags[n];if(void 0!==m){if(a&4&&m&4)throw new Sk.builtin.SyntaxError("duplicate argument '"+
g.v+"' in function definition",this.filename,c);m|=a}else m=a;this.cur.symFlags[n]=m;a&4?this.cur.varnames.push(n):a&1&&(m=a,g=this.global[n],void 0!==g&&(m|=g),this.global[n]=m)};d.prototype.visitSlice=function(g){var a;switch(g.constructor){case Sk.astnodes.Slice:g.lower&&this.visitExpr(g.lower);g.upper&&this.visitExpr(g.upper);g.step&&this.visitExpr(g.step);break;case Sk.astnodes.ExtSlice:for(a=0;a<g.dims.length;++a)this.visitSlice(g.dims[a]);break;case Sk.astnodes.Index:this.visitExpr(g.value)}};
d.prototype.visitStmt=function(g){var a;Sk.asserts.assert(void 0!==g,"visitStmt called with undefined");switch(g.constructor){case Sk.astnodes.FunctionDef:this.addDef(g.name,2,g.lineno);g.args.defaults&&this.SEQExpr(g.args.defaults);g.decorator_list&&this.SEQExpr(g.decorator_list);this.visitAnnotations(g.args,g.returns);this.enterBlock(g.name.v,"function",g,g.lineno);this.visitArguments(g.args,g.lineno);this.SEQStmt(g.body);this.exitBlock();break;case Sk.astnodes.ClassDef:this.addDef(g.name,2,g.lineno);
this.SEQExpr(g.bases);g.decorator_list&&this.SEQExpr(g.decorator_list);this.enterBlock(g.name.v,"class",g,g.lineno);this.curClass=g.name;this.SEQStmt(g.body);this.exitBlock();break;case Sk.astnodes.Return:g.value&&(this.visitExpr(g.value),this.cur.returnsValue=!0);break;case Sk.astnodes.Delete:this.SEQExpr(g.targets);break;case Sk.astnodes.Assign:this.SEQExpr(g.targets);this.visitExpr(g.value);break;case Sk.astnodes.AnnAssign:if(g.target.constructor==Sk.astnodes.Name){var c=g.target;var n=Sk.mangleName(this.curClass,
c.id).v;n=Sk.fixReserved(n);c=this.cur.symFlags[n];if(c&2049&&this.global!=this.cur.symFlags&&g.simple)throw new Sk.builtin.SyntaxError("annotated name '"+n+"' can't be global",this.filename,g.lineno);g.simple?this.addDef(new Sk.builtin.str(n),4098,g.lineno):g.value&&this.addDef(new Sk.builtin.str(n),2,g.lineno)}else this.visitExpr(g.target);this.visitExpr(g.annotation);g.value&&this.visitExpr(g.value);break;case Sk.astnodes.AugAssign:this.visitExpr(g.target);this.visitExpr(g.value);break;case Sk.astnodes.Print:g.dest&&
this.visitExpr(g.dest);this.SEQExpr(g.values);break;case Sk.astnodes.For:this.visitExpr(g.target);this.visitExpr(g.iter);this.SEQStmt(g.body);g.orelse&&this.SEQStmt(g.orelse);break;case Sk.astnodes.While:this.visitExpr(g.test);this.SEQStmt(g.body);g.orelse&&this.SEQStmt(g.orelse);break;case Sk.astnodes.If:this.visitExpr(g.test);this.SEQStmt(g.body);g.orelse&&this.SEQStmt(g.orelse);break;case Sk.astnodes.Raise:g.exc&&(this.visitExpr(g.exc),g.inst&&(this.visitExpr(g.inst),g.tback&&this.visitExpr(g.tback)),
g.cause&&this.visitExpr(g.cause));break;case Sk.astnodes.Assert:this.visitExpr(g.test);g.msg&&this.visitExpr(g.msg);break;case Sk.astnodes.Import:case Sk.astnodes.ImportFrom:this.visitAlias(g.names,g.lineno);break;case Sk.astnodes.Global:var m=g.names.length;for(a=0;a<m;++a){n=Sk.mangleName(this.curClass,g.names[a]).v;n=Sk.fixReserved(n);c=this.cur.symFlags[n];if(c&10){if(c&2)throw new Sk.builtin.SyntaxError("name '"+n+"' is assigned to before global declaration",this.filename,g.lineno);throw new Sk.builtin.SyntaxError("name '"+
n+"' is used prior to global declaration",this.filename,g.lineno);}this.addDef(new Sk.builtin.str(n),1,g.lineno)}break;case Sk.astnodes.Expr:this.visitExpr(g.value);break;case Sk.astnodes.Pass:case Sk.astnodes.Break:case Sk.astnodes.Continue:case Sk.astnodes.Debugger:break;case Sk.astnodes.With:f(this.visit_withitem.bind(this),g.items);f(this.visitStmt.bind(this),g.body);break;case Sk.astnodes.Try:this.SEQStmt(g.body);this.visitExcepthandlers(g.handlers);this.SEQStmt(g.orelse);this.SEQStmt(g.finalbody);
break;default:Sk.asserts.fail("Unhandled type "+g.constructor.name+" in visitStmt")}};d.prototype.visit_withitem=function(g){this.visitExpr(g.context_expr);g.optional_vars&&this.visitExpr(g.optional_vars)};d.prototype.visitExpr=function(g){Sk.asserts.assert(void 0!==g,"visitExpr called with undefined");switch(g.constructor){case Sk.astnodes.BoolOp:this.SEQExpr(g.values);break;case Sk.astnodes.BinOp:this.visitExpr(g.left);this.visitExpr(g.right);break;case Sk.astnodes.UnaryOp:this.visitExpr(g.operand);
break;case Sk.astnodes.Lambda:this.addDef(new Sk.builtin.str("lambda"),2,g.lineno);g.args.defaults&&this.SEQExpr(g.args.defaults);this.enterBlock("lambda","function",g,g.lineno);this.visitArguments(g.args,g.lineno);this.visitExpr(g.body);this.exitBlock();break;case Sk.astnodes.IfExp:this.visitExpr(g.test);this.visitExpr(g.body);this.visitExpr(g.orelse);break;case Sk.astnodes.Dict:this.SEQExpr(g.keys);this.SEQExpr(g.values);break;case Sk.astnodes.DictComp:case Sk.astnodes.SetComp:this.visitComprehension(g.generators,
0);break;case Sk.astnodes.ListComp:this.newTmpname(g.lineno);this.visitExpr(g.elt);this.visitComprehension(g.generators,0);break;case Sk.astnodes.GeneratorExp:this.visitGenexp(g);break;case Sk.astnodes.YieldFrom:case Sk.astnodes.Yield:g.value&&this.visitExpr(g.value);this.cur.generator=!0;if(this.cur.returnsValue)throw new Sk.builtin.SyntaxError("'return' with argument inside generator",this.filename);break;case Sk.astnodes.Compare:this.visitExpr(g.left);this.SEQExpr(g.comparators);break;case Sk.astnodes.Call:this.visitExpr(g.func);
if(g.args)for(let a of g.args)a.constructor===Sk.astnodes.Starred?this.visitExpr(a.value):this.visitExpr(a);if(g.keywords)for(let a of g.keywords)this.visitExpr(a.value);break;case Sk.astnodes.Num:case Sk.astnodes.Str:case Sk.astnodes.Bytes:break;case Sk.astnodes.JoinedStr:for(let a of g.values)this.visitExpr(a);break;case Sk.astnodes.FormattedValue:this.visitExpr(g.value);g.format_spec&&this.visitExpr(g.format_spec);break;case Sk.astnodes.Attribute:this.visitExpr(g.value);break;case Sk.astnodes.Subscript:this.visitExpr(g.value);
this.visitSlice(g.slice);break;case Sk.astnodes.Name:this.addDef(g.id,g.ctx===Sk.astnodes.Load?8:2,g.lineno);break;case Sk.astnodes.NameConstant:break;case Sk.astnodes.List:case Sk.astnodes.Tuple:case Sk.astnodes.Set:this.SEQExpr(g.elts);break;case Sk.astnodes.Starred:this.visitExpr(g.value);break;case Sk.astnodes.Ellipsis:break;default:Sk.asserts.fail("Unhandled type "+g.constructor.name+" in visitExpr")}};d.prototype.visitComprehension=function(g,a){var c,n=g.length;for(c=a;c<n;++c)a=g[c],this.visitExpr(a.target),
this.visitExpr(a.iter),this.SEQExpr(a.ifs)};d.prototype.visitAlias=function(g,a){var c,n;for(n=0;n<g.length;++n){var m=g[n];var k=c=null===m.asname?m.name.v:m.asname.v;m=c.indexOf(".");-1!==m&&(k=c.substr(0,m));if("*"!==c)this.addDef(new Sk.builtin.str(k),1024,a);else if("module"!==this.cur.blockType)throw new Sk.builtin.SyntaxError("import * only allowed at module level",this.filename);}};d.prototype.visitGenexp=function(g){var a=g.generators[0];this.visitExpr(a.iter);this.enterBlock("genexpr","function",
g,g.lineno);this.cur.generator=!0;this.addDef(new Sk.builtin.str(".0"),4,g.lineno);this.visitExpr(a.target);this.SEQExpr(a.ifs);this.visitComprehension(g.generators,1);this.visitExpr(g.elt);this.exitBlock()};d.prototype.visitExcepthandlers=function(g){var a,c;for(a=0;c=g[a];++a)c.type&&this.visitExpr(c.type),c.name&&this.visitExpr(c.name),this.SEQStmt(c.body)};d.prototype.analyzeBlock=function(g,a,c,n){var m={};var k={},u={},l={},q={};"class"==g.blockType&&(h(u,n),a&&h(l,a));for(r in g.symFlags){var z=
g.symFlags[r];this.analyzeName(g,k,r,z,a,m,c,n)}"class"!==g.blockType&&("function"===g.blockType&&h(l,m),a&&h(l,a),h(u,n));m={};var r=g.children.length;for(z=0;z<r;++z)if(n=g.children[z],this.analyzeChildBlock(n,l,q,u,m),n.hasFree||n.childHasFree)g.childHasFree=!0;h(q,m);"function"===g.blockType&&this.analyzeCells(k,q);a=this.updateSymbols(g.symFlags,k,a,q,"class"===g.blockType);g.hasFree=g.hasFree||a;h(c,q)};d.prototype.analyzeChildBlock=function(g,a,c,n,m){var k={};h(k,a);a={};h(a,c);c={};h(c,n);
this.analyzeBlock(g,k,a,c);h(m,a)};d.prototype.analyzeCells=function(g,a){var c;for(c in g){var n=g[c];1===n&&void 0!==a[c]&&(g[c]=5,delete a[c])}};d.prototype.updateSymbols=function(g,a,c,n,m){var k,u=!1;for(k in g){var l=g[k];var q=a[k];l|=q<<11;g[k]=l}for(k in n)a=g[k],void 0!==a?m&&a&1031&&(a|=512,g[k]=a):void 0!==c[k]&&(g[k]=8192,u=!0);return u};d.prototype.analyzeName=function(g,a,c,n,m,k,u,l){if(n&1){if(n&4)throw new Sk.builtin.SyntaxError("name '"+c+"' is local and global",this.filename,g.lineno);
a[c]=2;l[c]=null;m&&void 0!==m[c]&&delete m[c]}else n&1030?(a[c]=1,k[c]=null,delete l[c]):m&&void 0!==m[c]?(a[c]=4,g.hasFree=!0,u[c]=null):(l&&void 0!==l[c]||!g.isNested||(g.hasFree=!0),a[c]=3)};d.prototype.analyze=function(){this.analyzeBlock(this.top,null,{},{})};Sk.symboltable=function(g,a){var c=new d(a);c.enterBlock("top","module",g,0);c.top=c.cur;for(a=0;a<g.body.length;++a)c.visitStmt(g.body[a]);c.exitBlock();c.analyze();return c};Sk.dumpSymtab=function(g){var a=function(m){return m?"True":
"False"},c=function(m){var k,u=[];for(k=0;k<m.length;++k)u.push((new Sk.builtin.str(m[k])).$r().v);return"["+u.join(", ")+"]"},n=function(m,k){var u,l;void 0===k&&(k="");var q=k+"Sym_type: "+m.get_type()+"\n";q+=k+"Sym_name: "+m.get_name()+"\n";q+=k+"Sym_lineno: "+m.get_lineno()+"\n";q+=k+"Sym_nested: "+a(m.is_nested())+"\n";q+=k+"Sym_haschildren: "+a(m.has_children())+"\n";"class"===m.get_type()?q+=k+"Class_methods: "+c(m.get_methods())+"\n":"function"===m.get_type()&&(q+=k+"Func_params: "+c(m.get_parameters())+
"\n",q+=k+"Func_locals: "+c(m.get_locals())+"\n",q+=k+"Func_globals: "+c(m.get_globals())+"\n",q+=k+"Func_frees: "+c(m.get_frees())+"\n");q+=k+"-- Identifiers --\n";var z=m.get_identifiers();var r=z.length;for(l=0;l<r;++l){var t=m.lookup(z[l]);q+=k+"name: "+t.get_name()+"\n";q+=k+"  is_referenced: "+a(t.is_referenced())+"\n";q+=k+"  is_imported: "+a(t.is_imported())+"\n";q+=k+"  is_parameter: "+a(t.is_parameter())+"\n";q+=k+"  is_global: "+a(t.is_global())+"\n";q+=k+"  is_declared_global: "+a(t.is_declared_global())+
"\n";q+=k+"  is_local: "+a(t.is_local())+"\n";q+=k+"  is_free: "+a(t.is_free())+"\n";q+=k+"  is_assigned: "+a(t.is_assigned())+"\n";q+=k+"  is_namespace: "+a(t.is_namespace())+"\n";var x=t.get_namespaces();var v=x.length;q+=k+"  namespaces: [\n";var B=[];for(u=0;u<v;++u)t=x[u],B.push(n(t,k+"    "));q+=B.join("\n");q+=k+"  ]\n"}return q};return n(g.top,"")};Sk.exportSymbol("Sk.symboltable",Sk.symboltable);Sk.exportSymbol("Sk.dumpSymtab",Sk.dumpSymtab)},function(F,P){function b(a,c,n,m,k){this.filename=
a;this.st=c;this.flags=n;this.canSuspend=m;this.interactive=!1;this.nestlevel=0;this.u=null;this.stack=[];this.result=[];this.allUnits=[];this.source=k?k.split("\n"):!1}function e(){this.name=this.ste=null;this.doesSuspend=this.canSuspend=!1;this.private_=null;this.lineno=this.firstlineno=0;this.linenoSet=!1;this.localnames=[];this.localtemps=[];this.tempsToSave=[];this.blocknum=0;this.blocks=[];this.curblock=0;this.consts={};this.scopename=null;this.suffixCode=this.switchCode=this.varDeclsCode=this.prefixCode=
"";this.breakBlocks=[];this.continueBlocks=[];this.exceptBlocks=[];this.finallyBlocks=[]}function d(a){return void 0===p[a]?a:a+"_$rw$"}function f(a,c){var n=c.v;if(null===a||null===n||"_"!==n.charAt(0)||"_"!==n.charAt(1)||"_"===n.charAt(n.length-1)&&"_"===n.charAt(n.length-2))return c;var m=a.v;m.replace(/_/g,"");if(""===m)return c;m=a.v;m.replace(/^_*/,"");return m=new Sk.builtin.str("_"+m+n)}var h;Sk.gensymcount=0;e.prototype.activateScope=function(){var a=this;h=function(){var c,n=a.blocks[a.curblock];
if(null===n._next)for(c=0;c<arguments.length;++c)n.push(arguments[c])}};b.prototype.getSourceLine=function(a){Sk.asserts.assert(this.source);return this.source[a-1]};b.prototype.annotateSource=function(a){var c;if(this.source){var n=a.lineno;var m=a.col_offset;h("\n//\n// line ",n,":\n// ",this.getSourceLine(n),"\n// ");for(c=0;c<m;++c)h(" ");h("^\n//\n");Sk.asserts.assert(void 0!==a.lineno&&void 0!==a.col_offset);h("$currLineNo = ",n,";\n$currColNo = ",m,";\n\n")}};b.prototype.gensym=function(a){return a=
"$"+(a||"")+Sk.gensymcount++};b.prototype.niceName=function(a){return this.gensym(a.replace("<","").replace(">","").replace(" ","_"))};var p=Sk.builtin.str.reservedWords_;b.prototype.makeConstant=function(a){var c,n="";for(c=0;c<arguments.length;++c)n+=arguments[c];for(m in this.u.consts)if(this.u.consts.hasOwnProperty(m)&&(c=this.u.consts[m],c==n))return m;var m=this.u.scopename+"."+this.gensym("const");this.u.consts[m]=n;return m};b.prototype._gr=function(a,c){var n,m=this.gensym(a);this.u.localtemps.push(m);
h("var ",m,"=");for(n=1;n<arguments.length;++n)h(arguments[n]);h(";");return m};b.prototype.outputInterruptTest=function(){var a="";if(null!==Sk.execLimit||null!==Sk.yieldLimit&&this.u.canSuspend)a+="var $dateNow = Date.now();",null!==Sk.execLimit&&(a+="if ($dateNow - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeoutError(Sk.timeoutMsg())}"),null!==Sk.yieldLimit&&this.u.canSuspend&&(a=a+"if (!$waking && ($dateNow - Sk.lastYield > Sk.yieldLimit)) {var $susp = $saveSuspension({data: {type: 'Sk.yield'}, resume: function() {}}, '"+
(this.filename+"',$currLineNo,$currColNo);"),a+="$susp.$blk = $blk;$susp.optional = true;return $susp;}$waking = false;",this.u.doesSuspend=!0);return a};b.prototype._jumpfalse=function(a,c){a=this._gr("jfalse","(",a,"===false||!Sk.misceval.isTrue(",a,"))");h("if(",a,"){/*test failed */$blk=",c,";continue;}")};b.prototype._jumpundef=function(a,c){h("if(",a,"===undefined){$blk=",c,";continue;}")};b.prototype._jumpnotundef=function(a,c){h("if(",a,"!==undefined){$blk=",c,";continue;}")};b.prototype._jumptrue=
function(a,c){a=this._gr("jtrue","(",a,"===true||Sk.misceval.isTrue(",a,"))");h("if(",a,"){/*test passed */$blk=",c,";continue;}")};b.prototype._jump=function(a){null===this.u.blocks[this.u.curblock]._next&&(h("$blk=",a,";"),this.u.blocks[this.u.curblock]._next=a)};b.prototype._checkSuspension=function(a){if(this.u.canSuspend){var c=this.newBlock("function return or resume suspension");this._jump(c);this.setBlock(c);a=a||{lineno:"$currLineNo",col_offset:"$currColNo"};h("if ($ret && $ret.$isSuspension) { return $saveSuspension($ret,'"+
this.filename+"',"+a.lineno+","+a.col_offset+"); }");this.u.doesSuspend=!0;this.u.tempsToSave=this.u.tempsToSave.concat(this.u.localtemps)}else h("if ($ret && $ret.$isSuspension) { $ret = Sk.misceval.retryOptionalSuspensionOrThrow($ret); }")};b.prototype.cunpackstarstoarray=function(a,c){if(!a||0==a.length)return"[]";let n=!1;for(let m of a){if(c&&n)throw new Sk.builtin.SyntaxError("Extended argument unpacking is not permitted in Python 2");m.constructor===Sk.astnodes.Starred&&(n=!0)}if(n){c=this._gr("unpack",
"[]");for(let m of a)m.constructor!==Sk.astnodes.Starred?h(c,".push(",this.vexpr(m),");"):(h("$ret = Sk.misceval.iterFor(Sk.abstr.iter(",this.vexpr(m.value),"), function(e) { ",c,".push(e); });"),this._checkSuspension());return c}return"["+a.map(m=>this.vexpr(m)).join(",")+"]"};b.prototype.cunpackkwstoarray=function(a,c){var n="undefined";if(a&&0<a.length){let m=!1;n=[];for(let k of a){if(m&&!Sk.__future__.python3)throw new SyntaxError("Advanced unpacking of function arguments is not supported in Python 2");
k.arg?(n.push("'"+k.arg.v+"'"),n.push(this.vexpr(k.value))):m=!0}n="["+n.join(",")+"]";if(m){n=this._gr("keywordArgs",n);for(let k of a)k.arg||(h("$ret = Sk.abstr.mappingUnpackIntoKeywordArray(",n,",",this.vexpr(k.value),",",c,");"),this._checkSuspension())}}return n};b.prototype.ctuplelistorset=function(a,c,n){var m;Sk.asserts.assert("tuple"===n||"list"===n||"set"===n);var k=!1;for(m=0;m<a.elts.length;m++)if(a.elts[m].constructor===Sk.astnodes.Starred){k=!0;var u=m;break}if(a.ctx===Sk.astnodes.Store){if(k){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("assignment unpacking with stars is not supported in Python 2",
this.filename,a.lineno);for(m=u+1;m<a.elts.length;m++)if(a.elts[m].constructor===Sk.astnodes.Starred)throw new Sk.builtin.SyntaxError("multiple starred expressions in assignment",this.filename,a.lineno);}n=k?u:a.elts.length;h("$ret = Sk.abstr.sequenceUnpack("+c+","+n+","+(k?a.elts.length-1:n)+", "+k+");");this._checkSuspension();c=this._gr("items","$ret");for(m=0;m<a.elts.length;++m)m===u?this.vexpr(a.elts[m].value,c+"["+m+"]"):this.vexpr(a.elts[m],c+"["+m+"]")}else if(a.ctx===Sk.astnodes.Load||"set"===
n){if(k){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("List packing with stars is not supported in Python 2");return this._gr("load"+n,"new Sk.builtins['",n,"'](",this.cunpackstarstoarray(a.elts),")")}if("tuple"===n){k=!0;c=[];for(m=0;m<a.elts.length;++m)u=this.vexpr(a.elts[m]),k&&-1==u.indexOf("$const")&&(k=!1),c.push(u);if(k)return this.makeConstant("new Sk.builtin.tuple(["+c+"])");for(m=0;m<c.length;++m)c[m]=this._gr("elem",c[m]);return this._gr("load"+n,"new Sk.builtins['",n,"']([",
c,"])")}c=[];for(m=0;m<a.elts.length;++m)c.push(this._gr("elem",this.vexpr(a.elts[m])));return this._gr("load"+n,"new Sk.builtins['",n,"']([",c,"])")}};b.prototype.csubdict=function(a,c,n){const m=[];for(;c<n;c++)m.push(this.vexpr(a.keys[c])),m.push(this.vexpr(a.values[c]));return this._gr("loaddict","new Sk.builtins['dict']([",m,"])")};b.prototype.cdict=function(a){let c=0;var n;const m=a.values?a.values.length:0;let k=0,u;for(let l=0;l<m;l++)(n=null===a.keys[l])?(k&&(n=this.csubdict(a,l-k,l),c?
h(u,".dict$merge(",n,");"):(u=n,c=1),k=0),0===c&&(u=this._gr("loaddict","new Sk.builtins.dict([])"),c=1),n=this.vexpr(a.values[l]),h("$ret = ",u,".dict$merge(",n,");"),this._checkSuspension(a)):k++;k&&(n=this.csubdict(a,m-k,m),c?h(u,".dict$merge(",n,");"):(u=n,c=1));0===c&&(u=this._gr("loaddict","new Sk.builtins.dict([])"));return u};b.prototype.clistcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.ListComp);var c=this._gr("_compr","new Sk.builtins['list']([])");return this.ccompgen("list",
c,a.generators,0,a.elt,null,a)};b.prototype.cdictcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.DictComp);var c=this._gr("_dcompr","new Sk.builtins.dict([])");return this.ccompgen("dict",c,a.generators,0,a.value,a.key,a)};b.prototype.csetcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.SetComp);var c=this._gr("_setcompr","new Sk.builtins.set([])");return this.ccompgen("set",c,a.generators,0,a.elt,null,a)};b.prototype.ccompgen=function(a,c,n,m,k,u,l){var q=this.newBlock(a+" comp start"),
z=this.newBlock(a+" comp skip"),r=this.newBlock(a+" comp anchor"),t=n[m],x=this.vexpr(t.iter);x=this._gr("iter","Sk.abstr.iter(",x,")");var v;this._jump(q);this.setBlock(q);h("$ret = Sk.abstr.iternext(",x,", true);");this._checkSuspension(l);x=this._gr("next","$ret");this._jumpundef(x,r);this.vexpr(t.target,x);var B=t.ifs?t.ifs.length:0;for(v=0;v<B;++v)x=this.vexpr(t.ifs[v]),this._jumpfalse(x,q);++m<n.length&&this.ccompgen(a,c,n,m,k,u,l);m>=n.length&&(n=this.vexpr(k),"dict"===a?(a=this.vexpr(u),h(c,
".mp$ass_subscript(",a,",",n,");")):"list"===a?h(c,".v.push(",n,");"):"set"===a&&h(c,".v.mp$ass_subscript(",n,", true);"),this._jump(z),this.setBlock(z));this._jump(q);this.setBlock(r);return c};b.prototype.cyield=function(a){if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'yield' outside function",this.filename,a.lineno);var c="Sk.builtin.none.none$";a.value&&(c=this.vexpr(a.value));a=this.newBlock("after yield");h("return [/*resume*/",a,",/*ret*/",c,"];");
this.setBlock(a);return"$gen.gi$sentvalue"};b.prototype.cyieldfrom=function(a){if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'yield' outside function",this.filename,a.lineno);var c=this.vexpr(a.value);c=this._gr("iter","Sk.abstr.iter(",c,")");h("$gen."+c+"=",c,";");var n=this.newBlock("after iter"),m=this.newBlock("after yield from");this._jump(n);this.setBlock(n);var k=this.gensym("retval");h(c,"=$gen.",c,";");h("var ",k,";");h("if ($gen.gi$sentvalue === Sk.builtin.none.none$ || "+
c+".constructor === Sk.builtin.generator) {");h("$ret=",c,".tp$iternext(true, $gen.gi$sentvalue);");h("} else {");var u=this.makeConstant("new Sk.builtin.str('send');");h("$ret=Sk.misceval.tryCatch(");h("function(){");h("return Sk.misceval.callsimOrSuspendArray(Sk.abstr.gattr(",c,",",u,"), [$gen.gi$sentvalue]);},");h("function (e) { ");h("if (e instanceof Sk.builtin.StopIteration) { ");h(c,".gi$ret = e.$value;");h("return undefined;");h("} else { throw e; }");h("}");h(");");h("}");this._checkSuspension(a);
h(k,"=$ret;");h("if(",k,"===undefined) {");h("$gen.gi$sentvalue=$gen."+c+".gi$ret;");h("$blk=",m,";continue;");h("}");h("return [/*resume*/",n,",/*ret*/",k,"];");this.setBlock(m);return"$gen.gi$sentvalue"};b.prototype.ccompare=function(a){var c;Sk.asserts.assert(a.ops.length===a.comparators.length);var n=this.vexpr(a.left);var m=a.ops.length;var k=this.newBlock("done");var u=this._gr("compareres","null");for(c=0;c<m;++c){var l=this.vexpr(a.comparators[c]);const q=a.ops[c];q===Sk.astnodes.Is?h("$ret = ",
n,"===",l,";"):q===Sk.astnodes.IsNot?h("$ret = ",n,"!==",l,";"):(h("$ret = Sk.misceval.richCompareBool(",n,",",l,",'",q.prototype._astname,"', true);"),this._checkSuspension(a));h(u,"=Sk.builtin.bool($ret);");this._jumpfalse("$ret",k);n=l}this._jump(k);this.setBlock(k);return u};b.prototype.ccall=function(a){var c=this.vexpr(a.func);let n=this.cunpackstarstoarray(a.args,!Sk.__future__.python3),m=this.cunpackkwstoarray(a.keywords,c);Sk.__future__.super_args&&a.func.id&&"super"===a.func.id.v&&"[]"===
n&&(this.u.tempsToSave.push("$sup"),h('if (typeof $sup === "undefined") { throw new Sk.builtin.RuntimeError("super(): no arguments") };'),n="[$gbl.__class__,$sup]");h("$ret = (",c,".tp$call)?",c,".tp$call(",n,",",m,") : Sk.misceval.applyOrSuspend(",c,",undefined,undefined,",m,",",n,");");this._checkSuspension(a);return this._gr("call","$ret")};b.prototype.cslice=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.Slice);if(Sk.__future__.python3){var c=a.lower?this.vexpr(a.lower):"Sk.builtin.none.none$";
var n=a.upper?this.vexpr(a.upper):"Sk.builtin.none.none$"}else c=a.lower?this.vexpr(a.lower):a.step?"Sk.builtin.none.none$":"new Sk.builtin.int_(0)",n=a.upper?this.vexpr(a.upper):a.step?"Sk.builtin.none.none$":"new Sk.builtin.int_(2147483647)";a=a.step?this.vexpr(a.step):"Sk.builtin.none.none$";return this._gr("slice","new Sk.builtins['slice'](",c,",",n,",",a,")")};b.prototype.eslice=function(a){var c;Sk.asserts.assert(a instanceof Array);var n=[];for(c=0;c<a.length;c++)n.push(this.vslicesub(a[c]));
return this._gr("extslice","new Sk.builtins['tuple']([",n,"])")};b.prototype.vslicesub=function(a){switch(a.constructor){case Sk.astnodes.Index:var c=this.vexpr(a.value);break;case Sk.astnodes.Slice:c=this.cslice(a);break;case Sk.astnodes.Ellipsis:Sk.asserts.fail("todo compile.js Ellipsis;");break;case Sk.astnodes.ExtSlice:c=this.eslice(a.dims);break;default:Sk.asserts.fail("invalid subscript kind")}return c};b.prototype.vslice=function(a,c,n,m){a=this.vslicesub(a);return this.chandlesubscr(c,n,a,
m)};b.prototype.chandlesubscr=function(a,c,n,m){if(a===Sk.astnodes.Load||a===Sk.astnodes.AugLoad)return h("$ret = Sk.abstr.objectGetItem(",c,",",n,", true);"),this._checkSuspension(),this._gr("lsubscr","$ret");a===Sk.astnodes.Store||a===Sk.astnodes.AugStore?(h("$ret = Sk.abstr.objectSetItem(",c,",",n,",",m,", true);"),this._checkSuspension()):a===Sk.astnodes.Del?h("Sk.abstr.objectDelItem(",c,",",n,");"):Sk.asserts.fail("handlesubscr fail")};b.prototype.cboolop=function(a){var c,n;Sk.asserts.assert(a instanceof
Sk.astnodes.BoolOp);var m=a.op===Sk.astnodes.And?this._jumpfalse:this._jumptrue;var k=this.newBlock("end of boolop");var u=a.values;var l=u.length;for(c=0;c<l;++c)a=this.vexpr(u[c]),0===c&&(n=this._gr("boolopsucc",a)),h(n,"=",a,";"),m.call(this,a,k);this._jump(k);this.setBlock(k);return n};b.prototype.cjoinedstr=function(a){let c;Sk.asserts.assert(a instanceof Sk.astnodes.JoinedStr);for(let n of a.values)a=this.vexpr(n),c?h(c,"=",c,".sq$concat(",a,");"):c=this._gr("joinedstr",a);c||(c="Sk.builtin.str.$emptystr");
return c};b.prototype.cformattedvalue=function(a){let c=this.vexpr(a.value);switch(a.conversion){case "s":c=this._gr("value","new Sk.builtin.str(",c,")");break;case "a":c=this._gr("value","Sk.builtin.ascii(",c,")");break;case "r":c=this._gr("value","Sk.builtin.repr(",c,")")}a=a.format_spec?this.vexpr(a.format_spec):"Sk.builtin.str.$emptystr";return this._gr("formatted","Sk.abstr.objectFormat("+c+","+a+")")};b.prototype.vexpr=function(a,c,n,m){var k;a.lineno>this.u.lineno&&(this.u.lineno=a.lineno,
this.u.linenoSet=!1);switch(a.constructor){case Sk.astnodes.BoolOp:return this.cboolop(a);case Sk.astnodes.BinOp:return this._gr("binop","Sk.abstr.numberBinOp(",this.vexpr(a.left),",",this.vexpr(a.right),",'",a.op.prototype._astname,"')");case Sk.astnodes.UnaryOp:return this._gr("unaryop","Sk.abstr.numberUnaryOp(",this.vexpr(a.operand),",'",a.op.prototype._astname,"')");case Sk.astnodes.Lambda:return this.clambda(a);case Sk.astnodes.IfExp:return this.cifexp(a);case Sk.astnodes.Dict:return this.cdict(a);
case Sk.astnodes.ListComp:return this.clistcomp(a);case Sk.astnodes.DictComp:return this.cdictcomp(a);case Sk.astnodes.SetComp:return this.csetcomp(a);case Sk.astnodes.GeneratorExp:return this.cgenexp(a);case Sk.astnodes.Yield:return this.cyield(a);case Sk.astnodes.YieldFrom:return this.cyieldfrom(a);case Sk.astnodes.Compare:return this.ccompare(a);case Sk.astnodes.Call:return c=this.ccall(a),this.annotateSource(a),c;case Sk.astnodes.Num:if("number"===typeof a.n)return a.n;if(a.n instanceof Sk.builtin.lng)return this.makeConstant("new Sk.builtin.lng('"+
a.n.v.toString()+"')");if(a.n instanceof Sk.builtin.int_)return"number"===typeof a.n.v?this.makeConstant("new Sk.builtin.int_("+a.n.v+")"):this.makeConstant("new Sk.builtin.int_('"+a.n.v.toString()+"')");if(a.n instanceof Sk.builtin.float_)return a=0===a.n.v&&-Infinity===1/a.n.v?"-0":a.n.v,this.makeConstant("new Sk.builtin.float_("+a+")");if(a.n instanceof Sk.builtin.complex)return this.makeConstant("new Sk.builtin.complex("+(0===a.n.real&&-Infinity===1/a.n.real?"-0":a.n.real)+", "+(0===a.n.imag&&
-Infinity===1/a.n.imag?"-0":a.n.imag)+")");Sk.asserts.fail("unhandled Num type");case Sk.astnodes.Bytes:if(Sk.__future__.python3){c=[];a=a.s.$jsstr();for(n=0;n<a.length;n++)c.push(a.charCodeAt(n));return this.makeConstant("new Sk.builtin.bytes([",c.join(", "),"])")}case Sk.astnodes.Str:c=this.makeConstant;a=a.s.$jsstr();n='"';for(k=0;k<a.length;k++)m=a.charCodeAt(k),n=10==m?n+"\\n":92==m?n+"\\\\":34==m||32>m||127<=m&&256>m?n+("\\x"+("0"+m.toString(16)).substr(-2)):256<=m?n+("\\u"+("000"+m.toString(16)).substr(-4)):
n+a.charAt(k);a=n+'"';return c.call(this,"new Sk.builtin.str(",a,")");case Sk.astnodes.Attribute:a.ctx!==Sk.astnodes.AugLoad&&a.ctx!==Sk.astnodes.AugStore&&(k=this.vexpr(a.value));m=a.attr.$r().v;m=m.substring(1,m.length-1);m=f(this.u.private_,new Sk.builtin.str(m)).v;m=this.makeConstant("new Sk.builtin.str('"+m+"')");switch(a.ctx){case Sk.astnodes.AugLoad:return h("$ret = ",n,".tp$getattr(",m,", true);"),this._checkSuspension(a),h("\nif ($ret === undefined) {"),h("\nthrow new Sk.builtin.AttributeError(",
n,'.sk$attrError() + " has no attribute \'" + ',m,'.$jsstr() + "\'");'),h("\n};"),this._gr("lattr","$ret");case Sk.astnodes.Load:return h("$ret = ",k,".tp$getattr(",m,", true);"),this._checkSuspension(a),h("\nif ($ret === undefined) {"),h("\nthrow new Sk.builtin.AttributeError(",k,'.sk$attrError() + " has no attribute \'" + ',m,'.$jsstr() + "\'");'),h("\n};"),this._gr("lattr","$ret");case Sk.astnodes.AugStore:h("$ret = undefined;");h("if(",c,"!==undefined){");h("$ret = ",n,".tp$setattr(",m,",",c,
", true);");h("}");this._checkSuspension(a);break;case Sk.astnodes.Store:h("$ret = ",k,".tp$setattr(",m,",",c,", true);");this._checkSuspension(a);break;case Sk.astnodes.Del:h("$ret = ",k,".tp$setattr(",m,", undefined, true);");this._checkSuspension(a);break;default:Sk.asserts.fail("invalid attribute expression")}break;case Sk.astnodes.Subscript:switch(a.ctx){case Sk.astnodes.AugLoad:return h("$ret = Sk.abstr.objectGetItem(",n,",",m,", true);"),this._checkSuspension(a),this._gr("gitem","$ret");case Sk.astnodes.Load:case Sk.astnodes.Store:case Sk.astnodes.Del:return this.vslice(a.slice,
a.ctx,this.vexpr(a.value),c);case Sk.astnodes.AugStore:h("$ret=undefined;");h("if(",c,"!==undefined){");h("$ret=Sk.abstr.objectSetItem(",n,",",m,",",c,", true)");h("}");this._checkSuspension(a);break;default:Sk.asserts.fail("invalid subscript expression")}break;case Sk.astnodes.Name:return this.nameop(a.id,a.ctx,c);case Sk.astnodes.NameConstant:if(a.ctx===Sk.astnodes.Store||a.ctx===Sk.astnodes.AugStore||a.ctx===Sk.astnodes.Del)throw new Sk.builtin.SyntaxError("can not assign to a constant name");
switch(a.value){case Sk.builtin.none.none$:return"Sk.builtin.none.none$";case Sk.builtin.bool.true$:return"Sk.builtin.bool.true$";case Sk.builtin.bool.false$:return"Sk.builtin.bool.false$";default:Sk.asserts.fail("invalid named constant")}break;case Sk.astnodes.List:return this.ctuplelistorset(a,c,"list");case Sk.astnodes.Tuple:return this.ctuplelistorset(a,c,"tuple");case Sk.astnodes.Set:return this.ctuplelistorset(a,c,"set");case Sk.astnodes.Starred:switch(a.ctx){case Sk.astnodes.Store:throw new Sk.builtin.SyntaxError("starred assignment target must be in a list or tuple",
this.filename,a.lineno);default:throw new Sk.builtin.SyntaxError("can't use starred expression here",this.filename,a.lineno);}case Sk.astnodes.JoinedStr:return this.cjoinedstr(a);case Sk.astnodes.FormattedValue:return this.cformattedvalue(a);case Sk.astnodes.Ellipsis:return this.makeConstant("Sk.builtin.Ellipsis");default:Sk.asserts.fail("unhandled case "+a.constructor.name+" vexpr")}};b.prototype.vseqexpr=function(a,c){var n;Sk.asserts.assert(void 0===c||a.length===c.length);var m=[];for(n=0;n<a.length;++n)m.push(this.vexpr(a[n],
void 0===c?void 0:c[n]));return m};b.prototype.cannassign=function(a){var c=a.target;let n=a.value;n&&(n=this.vexpr(a.value),this.vexpr(c,n));switch(c.constructor){case Sk.astnodes.Name:!a.simple||this.u.ste.blockType!==Sk.SYMTAB_CONSTS.ClassBlock&&this.u.ste.blockType!=Sk.SYMTAB_CONSTS.ModuleBlock||(this.u.hasAnnotations=!0,a=this.vexpr(a.annotation),c=f(this.u.private_,c.id).v,c=this.makeConstant("new Sk.builtin.str('"+c+"')"),this.chandlesubscr(Sk.astnodes.Store,"$loc.__annotations__",c,a))}};
b.prototype.caugassign=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.AugAssign);var c=a.target;switch(c.constructor){case Sk.astnodes.Attribute:var n=this.vexpr(c.value);c=new Sk.astnodes.Attribute(c.value,c.attr,Sk.astnodes.AugLoad,c.lineno,c.col_offset);var m=this.vexpr(c,void 0,n);var k=this.vexpr(a.value);a=this._gr("inplbinopattr","Sk.abstr.numberInplaceBinOp(",m,",",k,",'",a.op.prototype._astname,"')");c.ctx=Sk.astnodes.AugStore;return this.vexpr(c,a,n);case Sk.astnodes.Subscript:n=
this.vexpr(c.value);var u=this.vslicesub(c.slice);c=new Sk.astnodes.Subscript(c.value,u,Sk.astnodes.AugLoad,c.lineno,c.col_offset);m=this.vexpr(c,void 0,n,u);k=this.vexpr(a.value);a=this._gr("inplbinopsubscr","Sk.abstr.numberInplaceBinOp(",m,",",k,",'",a.op.prototype._astname,"')");c.ctx=Sk.astnodes.AugStore;return this.vexpr(c,a,n,u);case Sk.astnodes.Name:return n=this.nameop(c.id,Sk.astnodes.Load),k=this.vexpr(a.value),a=this._gr("inplbinop","Sk.abstr.numberInplaceBinOp(",n,",",k,",'",a.op.prototype._astname,
"')"),this.nameop(c.id,Sk.astnodes.Store,a);default:Sk.asserts.fail("unhandled case in augassign")}};b.prototype.exprConstant=function(a){switch(a.constructor){case Sk.astnodes.Num:return Sk.misceval.isTrue(a.n)?1:0;case Sk.astnodes.Str:return Sk.misceval.isTrue(a.s)?1:0;default:return-1}};b.prototype.newBlock=function(a){var c=this.u.blocknum++;this.u.blocks[c]=[];this.u.blocks[c]._name=a||"<unnamed>";this.u.blocks[c]._next=null;return c};b.prototype.setBlock=function(a){Sk.asserts.assert(0<=a&&
a<this.u.blocknum);this.u.curblock=a};b.prototype.pushBreakBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.breakBlocks.push(a)};b.prototype.popBreakBlock=function(){this.u.breakBlocks.pop()};b.prototype.pushContinueBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.continueBlocks.push(a)};b.prototype.popContinueBlock=function(){this.u.continueBlocks.pop()};b.prototype.pushExceptBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.exceptBlocks.push(a)};
b.prototype.popExceptBlock=function(){this.u.exceptBlocks.pop()};b.prototype.pushFinallyBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);Sk.asserts.assert(this.u.breakBlocks.length===this.u.continueBlocks.length);this.u.finallyBlocks.push({blk:a,breakDepth:this.u.breakBlocks.length})};b.prototype.popFinallyBlock=function(){this.u.finallyBlocks.pop()};b.prototype.peekFinallyBlock=function(){return 0<this.u.finallyBlocks.length?this.u.finallyBlocks[this.u.finallyBlocks.length-1]:void 0};
b.prototype.setupExcept=function(a){h("$exc.push(",a,");")};b.prototype.endExcept=function(){h("$exc.pop();")};b.prototype.outputLocals=function(a){var c,n={};for(c=0;a.argnames&&c<a.argnames.length;++c)n[a.argnames[c]]=!0;a.localnames.sort();var m=[];for(c=0;c<a.localnames.length;++c){var k=a.localnames[c];void 0===n[k]&&(m.push(k),n[k]=!0)}return 0<m.length?"var "+m.join(",")+"; /* locals */":""};b.prototype.outputSuspensionHelpers=function(a){var c,n=[],m=a.localnames.concat(a.tempsToSave),k={},
u=a.ste.blockType===Sk.SYMTAB_CONSTS.FunctionBlock&&a.ste.childHasFree,l=(0<m.length?"var "+m.join(",")+";":"")+"var $wakeFromSuspension = function() {var susp = "+a.scopename+".$wakingSuspension; "+a.scopename+".$wakingSuspension = undefined;$blk=susp.$blk; $loc=susp.$loc; $gbl=susp.$gbl; $exc=susp.$exc; $err=susp.$err; $postfinally=susp.$postfinally;$currLineNo=susp.$lineno; $currColNo=susp.$colno; Sk.lastYield=Date.now();"+(u?"$cell=susp.$cell;":"");for(c=0;c<m.length;c++){var q=m[c];void 0===
k[q]&&(l+=q+"=susp.$tmps."+q+";",k[q]=!0)}l+="try { $ret=susp.child.resume(); } catch(err) { if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+this.filename+"'}); if($exc.length>0) { $err=err; $blk=$exc.pop(); } else { throw err; } }};";l+="var $saveSuspension = function($child, $filename, $lineno, $colno) {var susp = new Sk.misceval.Suspension(); susp.child=$child;susp.resume=function(){"+
a.scopename+".$wakingSuspension=susp; return "+a.scopename+"("+(a.ste.generator?"$gen":"")+"); };susp.data=susp.child.data;susp.$blk=$blk;susp.$loc=$loc;susp.$gbl=$gbl;susp.$exc=$exc;susp.$err=$err;susp.$postfinally=$postfinally;susp.$filename=$filename;susp.$lineno=$lineno;susp.$colno=$colno;susp.optional=susp.child.optional;"+(u?"susp.$cell=$cell;":"");k={};for(c=0;c<m.length;c++)q=m[c],void 0===k[q]&&(n.push('"'+q+'":'+q),k[q]=!0);return l+="susp.$tmps={"+n.join(",")+"};return susp;};"};b.prototype.outputAllUnits=
function(){var a,c,n="";for(c=0;c<this.allUnits.length;++c){var m=this.allUnits[c];n+=m.prefixCode;n+=this.outputLocals(m);m.doesSuspend&&(n+=this.outputSuspensionHelpers(m));n+=m.varDeclsCode;n+=m.switchCode;var k=m.blocks;var u=Object.create(null);for(a=0;a<k.length;++a){var l=a;if(!(l in u))for(;;)if(u[l]=!0,n+="case "+l+": /* --- "+k[l]._name+" --- */",n+=k[l].join(""),null!==k[l]._next)if(k[l]._next in u){n+="/* jump */ continue;";break}else n+="/* allowing case fallthrough */",l=k[l]._next;
else{n+="throw new Sk.builtin.SystemError('internal error: unterminated block');";break}}n+=m.suffixCode}return n};b.prototype.cif=function(a){var c;Sk.asserts.assert(a instanceof Sk.astnodes.If);var n=this.exprConstant(a.test);if(0===n)a.orelse&&0<a.orelse.length&&this.vseqstmt(a.orelse);else if(1===n)this.vseqstmt(a.body);else{var m=this.newBlock("end of if");a.orelse&&0<a.orelse.length&&(c=this.newBlock("next branch of if"));n=this.vexpr(a.test);a.orelse&&0<a.orelse.length?(this._jumpfalse(n,c),
this.vseqstmt(a.body),this._jump(m),this.setBlock(c),this.vseqstmt(a.orelse)):(this._jumpfalse(n,m),this.vseqstmt(a.body));this._jump(m);this.setBlock(m)}};b.prototype.cwhile=function(a){if(0===this.exprConstant(a.test))a.orelse&&this.vseqstmt(a.orelse);else{var c=this.newBlock("while test");this._jump(c);this.setBlock(c);if((Sk.debugging||Sk.killableWhile)&&this.u.canSuspend){var n=this.newBlock("debug breakpoint for line "+a.lineno);h("if (Sk.breakpoints('"+this.filename+"',"+a.lineno+","+a.col_offset+
")) {","var $susp = $saveSuspension({data: {type: 'Sk.delay'}, resume: function() {}}, '"+this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+n+";","$susp.optional = true;","return $susp;","}");this._jump(n);this.setBlock(n);this.u.doesSuspend=!0}var m=this.newBlock("after while");var k=0<a.orelse.length?this.newBlock("while orelse"):null;n=this.newBlock("while body");this.annotateSource(a);this._jumpfalse(this.vexpr(a.test),k?k:m);this._jump(n);this.pushBreakBlock(m);this.pushContinueBlock(c);
this.setBlock(n);this.vseqstmt(a.body);this._jump(c);this.popContinueBlock();this.popBreakBlock();0<a.orelse.length&&(this.setBlock(k),this.vseqstmt(a.orelse),this._jump(m));this.setBlock(m)}};b.prototype.cfor=function(a){var c=this.newBlock("for start"),n=this.newBlock("for cleanup"),m=this.newBlock("for end");this.pushBreakBlock(m);this.pushContinueBlock(c);var k=this.vexpr(a.iter);if(this.u.ste.generator){var u="$loc."+this.gensym("iter");h(u,"=Sk.abstr.iter(",k,");")}else u=this._gr("iter","Sk.abstr.iter(",
k,")"),this.u.tempsToSave.push(u);this._jump(c);this.setBlock(c);h("$ret = Sk.abstr.iternext(",u,this.u.canSuspend?", true":", false",");");this._checkSuspension(a);u=this._gr("next","$ret");this._jumpundef(u,n);this.vexpr(a.target,u);(Sk.debugging||Sk.killableFor)&&this.u.canSuspend&&(u=this.newBlock("debug breakpoint for line "+a.lineno),h("if (Sk.breakpoints('"+this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.delay'}, resume: function() {}}, '"+
this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+u+";","$susp.optional = true;","return $susp;","}"),this._jump(u),this.setBlock(u),this.u.doesSuspend=!0);this.vseqstmt(a.body);this._jump(c);this.setBlock(n);this.popContinueBlock();this.popBreakBlock();this.vseqstmt(a.orelse);this._jump(m);this.setBlock(m)};b.prototype.craise=function(a){if(a.exc){var c=this._gr("exc",this.vexpr(a.exc)),n=this.newBlock("exception now instantiated"),m=this._gr("isclass",c+".prototype instanceof Sk.builtin.BaseException");
this._jumpfalse(m,n);a.inst?(m=this._gr("inst",this.vexpr(a.inst)),h("if(!(",m," instanceof Sk.builtin.tuple)) {",m,"= new Sk.builtin.tuple([",m,"]);","}"),h("$ret = Sk.misceval.callsimOrSuspendArray(",c,",",m,".v);")):h("$ret = Sk.misceval.callsimOrSuspend(",c,");");this._checkSuspension(a);h(c,"=$ret;");this._jump(n);this.setBlock(n);h("if (",c," instanceof Sk.builtin.BaseException) {throw ",c,";} else {throw new Sk.builtin.TypeError('exceptions must derive from BaseException');};")}else h("throw $err;")};
b.prototype.outputFinallyCascade=function(a){if(0==this.u.finallyBlocks.length)h("if($postfinally!==undefined) { if ($postfinally.returning) { return $postfinally.returning; } else { $blk=$postfinally.gotoBlock; $postfinally=undefined; continue; } }");else{var c=this.peekFinallyBlock();h("if($postfinally!==undefined) {","if ($postfinally.returning",c.breakDepth==a.breakDepth?"|| $postfinally.isBreak":"",") {","$blk=",c.blk,";continue;","} else {","$blk=$postfinally.gotoBlock;$postfinally=undefined;continue;",
"}","}")}};b.prototype.ctry=function(a){var c,n=a.handlers.length;if(a.finalbody){var m=this.newBlock("finalbody");var k=this.newBlock("finalexh");var u=this._gr("finally_reraise","undefined");this.u.tempsToSave.push(u);this.pushFinallyBlock(m);var l=this.peekFinallyBlock();this.setupExcept(k)}var q=[];for(c=0;c<n;++c)q.push(this.newBlock("except_"+c+"_"));var z=this.newBlock("unhandled");var r=this.newBlock("orelse");var t=this.newBlock("end");0!=q.length&&this.setupExcept(q[0]);this.vseqstmt(a.body);
0!=q.length&&this.endExcept();this._jump(r);for(c=0;c<n;++c){this.setBlock(q[c]);var x=a.handlers[c];if(!x.type&&c<n-1)throw new Sk.builtin.SyntaxError("default 'except:' must be last",this.filename,x.lineno);if(x.type){var v=this.vexpr(x.type);var B=c==n-1?z:q[c+1];v=this._gr("instance","Sk.misceval.isTrue(Sk.builtin.isinstance($err, ",v,"))");this._jumpfalse(v,B)}x.name&&this.vexpr(x.name,"$err");this.vseqstmt(x.body);this._jump(t)}this.setBlock(z);h("throw $err;");this.setBlock(r);this.vseqstmt(a.orelse);
this._jump(t);this.setBlock(t);a.finalbody&&(this.endExcept(),this._jump(m),this.setBlock(k),h(u,"=$err;"),this._jump(m),this.setBlock(m),this.popFinallyBlock(),this.vseqstmt(a.finalbody),h("if(",u,"!==undefined) { throw ",u,";}"),this.outputFinallyCascade(l))};b.prototype.cwith=function(a,c){var n=this.newBlock("withexh"),m=this.newBlock("withtidyup"),k=this.newBlock("withcarryon");var u=this._gr("mgr",this.vexpr(a.items[c].context_expr));h("$ret = Sk.abstr.lookupSpecial(",u,",Sk.builtin.str.$exit);");
this._checkSuspension(a);var l=this._gr("exit","$ret");this.u.tempsToSave.push(l);h("$ret = Sk.abstr.lookupSpecial(",u,",Sk.builtin.str.$enter);");this._checkSuspension(a);h("$ret = Sk.misceval.callsimOrSuspendArray($ret);");this._checkSuspension(a);u=this._gr("value","$ret");this.pushFinallyBlock(m);var q=this.u.finallyBlocks[this.u.finallyBlocks.length-1];this.setupExcept(n);a.items[c].optional_vars&&this.nameop(a.items[c].optional_vars.id,Sk.astnodes.Store,u);c+1<a.items.length?this.cwith(a,c+
1):this.vseqstmt(a.body);this.endExcept();this._jump(m);this.setBlock(n);h("$ret = Sk.misceval.applyOrSuspend(",l,",undefined,Sk.builtin.getExcInfo($err),undefined,[]);");this._checkSuspension(a);this._jumptrue("$ret",k);h("throw $err;");this.setBlock(m);this.popFinallyBlock();h("$ret = Sk.misceval.callsimOrSuspendArray(",l,",[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.none.none$]);");this._checkSuspension(a);this.outputFinallyCascade(q);this._jump(k);this.setBlock(k)};b.prototype.cassert=
function(a){var c=this.vexpr(a.test),n=this.newBlock("end");this._jumptrue(c,n);h("throw new Sk.builtin.AssertionError(",a.msg?this.vexpr(a.msg):"",");");this.setBlock(n)};b.prototype.cimportas=function(a,c,n){a=a.v;var m=a.indexOf("."),k=n;if(-1!==m)for(a=a.substr(m+1);-1!==m;)m=a.indexOf("."),n=-1!==m?a.substr(0,m):a,k=this._gr("lattr","Sk.abstr.gattr(",k,", new Sk.builtin.str('",n,"'))"),a=a.substr(m+1);return this.nameop(c,Sk.astnodes.Store,k)};b.prototype.cimport=function(a){var c,n=a.names.length;
for(c=0;c<n;++c){var m=a.names[c];h("$ret = Sk.builtin.__import__(",m.name.$r().v,",$gbl,$loc,[],",Sk.__future__.absolute_import?0:-1,");");this._checkSuspension(a);var k=this._gr("module","$ret");if(m.asname)this.cimportas(m.name,m.asname,k);else{var u=m.name;m=u.v.indexOf(".");-1!==m&&(u=new Sk.builtin.str(u.v.substr(0,m)));this.nameop(u,Sk.astnodes.Store,k)}}};b.prototype.cfromimport=function(a){var c,n=a.names.length;var m=[];var k=a.level;0!=k||Sk.__future__.absolute_import||(k=-1);for(c=0;c<
n;++c)m[c]="'"+a.names[c].name.v+"'";h("$ret = Sk.builtin.__import__(",a.module.$r().v,",$gbl,$loc,[",m,"],",k,");");this._checkSuspension(a);k=this._gr("module","$ret");for(c=0;c<n;++c){m=a.names[c];var u="'"+m.name.v+"'";if(0===c&&"*"===m.name.v){Sk.asserts.assert(1===n);h("Sk.importStar(",k,",$loc, $gbl);");break}var l=this._gr("item","Sk.abstr.gattr(",k,", new Sk.builtin.str(",u,"), undefined)");u=m.name;m.asname&&(u=m.asname);this.nameop(u,Sk.astnodes.Store,l)}};b.prototype.buildcodeobj=function(a,
c,n,m,k,u){var l=[],q,z=[],r=[],t=[],x=null,v=null;n&&(z=this.vseqexpr(n));m&&m.defaults&&(r=this.vseqexpr(m.defaults));n=this.cannotations(m,a.returns);m&&m.kw_defaults&&(t=m.kw_defaults.map(J=>J?this.vexpr(J):"undefined"));m&&m.vararg&&(x=m.vararg);m&&m.kwarg&&(v=m.kwarg);if(!Sk.__future__.python3&&m&&m.kwonlyargs&&0!=m.kwonlyargs.length)throw new Sk.builtin.SyntaxError("Keyword-only arguments are not supported in Python 2");var B=this.enterScope(c,a,a.lineno,this.canSuspend);var I=this.u.ste.generator;
var M=this.u.ste.hasFree;var S=this.u.ste.childHasFree;var E=this.newBlock("codeobj entry");this.u.prefixCode="var "+B+"=(function "+this.niceName(c.v)+"$(";var H=[];if(I){if(v)throw new Sk.builtin.SyntaxError(c.v+"(): keyword arguments in generators not supported",this.filename,a.lineno);if(x)throw new Sk.builtin.SyntaxError(c.v+"(): variable number of arguments in generators not supported",this.filename,a.lineno);H.push("$gen")}else{v&&(H.push("$kwa"),this.u.tempsToSave.push("$kwa"));for(q=0;m&&
q<m.args.length;++q)H.push(this.nameop(m.args[q].arg,Sk.astnodes.Param));for(q=0;m&&m.kwonlyargs&&q<m.kwonlyargs.length;++q)H.push(this.nameop(m.kwonlyargs[q].arg,Sk.astnodes.Param));x&&H.push(this.nameop(m.vararg.arg,Sk.astnodes.Param))}let y=!I;M&&(y||H.push("$free"),this.u.tempsToSave.push("$free"));this.u.prefixCode=y?this.u.prefixCode+"$posargs,$kwargs":this.u.prefixCode+H.join(",");this.u.prefixCode+="){";I&&(this.u.prefixCode+="\n// generator\n");M&&(this.u.prefixCode+="\n// has free\n");S&&
(this.u.prefixCode+="\n// has cell\n");y&&(this.u.prefixCode+="\n// fast call\n");var A="{}";I&&(E="$gen.gi$resumeat",A="$gen.gi$locals");q=",$cell={}";S&&I&&(q=",$cell=$gen.gi$cells");this.u.varDeclsCode+="var $blk="+E+",$exc=[],$loc="+A+q+",$gbl="+(y?"this && this.func_globals":"this")+(y&&M?",$free=this && this.func_closure":"")+",$err=undefined,$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";null!==Sk.execLimit&&(this.u.varDeclsCode+="if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");
null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.varDeclsCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.varDeclsCode+="var $waking=false; if ("+B+".$wakingSuspension!==undefined) { $wakeFromSuspension(); $waking=true; } else {";if(y){this.u.varDeclsCode=v||x||m&&m.kwonlyargs&&0!==m.kwonlyargs.length?this.u.varDeclsCode+"\nvar $args = this.$resolveArgs($posargs,$kwargs)\n":this.u.varDeclsCode+("var $args = ((!$kwargs || $kwargs.length===0) && $posargs.length==="+
H.length+") ? $posargs : this.$resolveArgs($posargs,$kwargs)");for(q=0;q<H.length;q++)this.u.varDeclsCode+=","+H[q]+"=$args["+q+"]";if(q=H[v?1:0])this.u.varDeclsCode+=`,$sup=${q}`;this.u.varDeclsCode+=";\n"}if(I&&0<r.length)for(E=m.args.length-r.length,q=0;q<r.length;++q)H=this.nameop(m.args[q+E].arg,Sk.astnodes.Param),this.u.varDeclsCode+="if("+H+"===undefined)"+H+"="+B+".$defaults["+q+"];";for(q=0;m&&q<m.args.length;++q)H=m.args[q].arg,this.isCell(H)&&(H=d(f(this.u.private_,H).v),this.u.varDeclsCode+=
"$cell."+H+"="+H+";");for(q=0;m&&m.kwonlyargs&&q<m.kwonlyargs.length;++q)H=m.kwonlyargs[q].arg,this.isCell(H)&&(H=d(f(this.u.private_,H).v),this.u.varDeclsCode+="$cell."+H+"="+H+";");x&&this.isCell(x.arg)&&(q=d(f(this.u.private_,x.arg).v),this.u.varDeclsCode+="$cell."+q+"="+q+";");v&&(this.u.localnames.push(v.arg.v),this.u.varDeclsCode+=v.arg.v+"=new Sk.builtins['dict']($kwa);",this.isCell(v.arg)&&(q=d(f(this.u.private_,v.arg).v),this.u.varDeclsCode+="$cell."+q+"="+q+";"));this.u.varDeclsCode+="}";
Sk.__future__.python3&&u&&(this.u.varDeclsCode+="$gbl.__class__=$gbl."+u.v+";");this.u.switchCode="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="} }catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});";
k.call(this,B);if(m){for(let J of m.args)l.push(J.arg.v);for(let J of m.kwonlyargs||[])l.push(J.arg.v);this.u.argnames=l}this.exitScope();0<r.length&&h(B,".$defaults=[",r.join(","),"];");m&&m.kwonlyargs&&0<m.kwonlyargs.length&&(h(B,".co_argcount=",m.args.length,";"),h(B,".co_kwonlyargcount=",m.kwonlyargs.length,";"),h(B,".$kwdefs=[",t.join(","),"];"));0<l.length?h(B,".co_varnames=['",l.join("','"),"'];"):h(B,".co_varnames=[];");h(B,".co_docstring=",this.cDocstringOfCode(a),";");v&&h(B,".co_kwargs=1;");
x&&h(B,".co_varargs=1;");I||h(B,".co_fastcall=1;");a="";M&&(a=",$cell",(k=this.u.ste.hasFree)&&(a+=",$free"));if(I)return m&&0<m.args.length?this._gr("gener","new Sk.builtins['function']((function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgsLen(\"",c.v,'",arguments.length,',m.args.length-r.length,",",m.args.length,");return new Sk.builtins['generator'](",B,",$gbl,$origargs",a,");}))"):this._gr("gener","new Sk.builtins['function']((function(){Sk.builtin.pyCheckArgsLen(\"",
c.v,"\",arguments.length,0,0);return new Sk.builtins['generator'](",B,",$gbl,[]",a,");}))");if(0<z.length){h("$ret = new Sk.builtins['function'](",B,",$gbl",a,");");for(let J of z.reverse())h("$ret = Sk.misceval.callsimOrSuspendArray(",J,",[$ret]);"),this._checkSuspension();c=this._gr("funcobj","$ret")}else c=this._gr("funcobj","new Sk.builtins['function'](",B,",$gbl",a,")");n&&h(c,".func_annotations=",n,";");return c};b.prototype.cargannotation=function(a,c,n){c&&(a=f(this.u.private_,a).v,n.push(`'${a}'`),
n.push(this.vexpr(c)))};b.prototype.cargannotations=function(a,c){if(a)for(let n=0;n<a.length;n++){const m=a[n];this.cargannotation(m.arg,m.annotation,c)}};const g=new Sk.builtin.str("return");b.prototype.cannotations=function(a,c){const n=[];a&&(this.cargannotations(a.posonlyargs,n),this.cargannotations(a.args,n),a.vararg&&a.vararg.annotation&&this.cargannotation(a.vararg.arg,a.vararg.annotation,n),this.cargannotations(a.kwonlyargs,n),a.kwarg&&a.kwarg.annotation&&this.cargannotation(a.kwarg.arg,
a.kwarg.annotation,n));c&&this.cargannotation(g,c,n);if(0!==n.length)return"["+n.join(",")+"]"};b.prototype.maybeCDocstringOfBody=function(a){if(0===a.length)return null;a=a[0];if(a.constructor!==Sk.astnodes.Expr)return null;a=a.value;return a.constructor!==Sk.astnodes.Str?null:this.vexpr(a)};b.prototype.cDocstringOfCode=function(a){switch(a.constructor){case Sk.astnodes.AsyncFunctionDef:case Sk.astnodes.FunctionDef:return this.maybeCDocstringOfBody(a.body)||"Sk.builtin.none.none$";case Sk.astnodes.Lambda:case Sk.astnodes.GeneratorExp:return"Sk.builtin.none.none$";
default:Sk.asserts.fail(`unexpected node kind ${a.constructor.name}`)}};b.prototype.cfunction=function(a,c){Sk.asserts.assert(a instanceof Sk.astnodes.FunctionDef);c=this.buildcodeobj(a,a.name,a.decorator_list,a.args,function(n){this.vseqstmt(a.body);h("return Sk.builtin.none.none$;")},c);this.nameop(a.name,Sk.astnodes.Store,c)};b.prototype.clambda=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.Lambda);return this.buildcodeobj(a,new Sk.builtin.str("<lambda>"),null,a.args,function(c){c=this.vexpr(a.body);
h("return ",c,";")})};b.prototype.cifexp=function(a){var c=this.newBlock("next of ifexp"),n=this.newBlock("end of ifexp"),m=this._gr("res","null"),k=this.vexpr(a.test);this._jumpfalse(k,c);h(m,"=",this.vexpr(a.body),";");this._jump(n);this.setBlock(c);h(m,"=",this.vexpr(a.orelse),";");this._jump(n);this.setBlock(n);return m};b.prototype.cgenexpgen=function(a,c,n){var m=this.newBlock("start for "+c),k=this.newBlock("skip for "+c);this.newBlock("if cleanup for "+c);var u=this.newBlock("end for "+c),
l=a[c];if(0===c)var q="$loc.$iter0";else{var z=this.vexpr(l.iter);q="$loc."+this.gensym("iter");h(q,"=","Sk.abstr.iter(",z,");")}this._jump(m);this.setBlock(m);this.annotateSource(n);h("$ret = Sk.abstr.iternext(",q,this.u.canSuspend?", true":", false",");");this._checkSuspension(n);z=this._gr("next","$ret");this._jumpundef(z,u);this.vexpr(l.target,z);var r=l.ifs?l.ifs.length:0;for(q=0;q<r;++q)this.annotateSource(l.ifs[q]),z=this.vexpr(l.ifs[q]),this._jumpfalse(z,m);++c<a.length&&this.cgenexpgen(a,
c,n);c>=a.length&&(this.annotateSource(n),a=this.vexpr(n),h("return [",k,"/*resume*/,",a,"/*ret*/];"),this.setBlock(k));this._jump(m);this.setBlock(u);1===c&&h("return Sk.builtin.none.none$;")};b.prototype.cgenexp=function(a){var c=this.buildcodeobj(a,new Sk.builtin.str("<genexpr>"),null,null,function(n){this.cgenexpgen(a.generators,0,a.elt)});c=this._gr("gener","Sk.misceval.callsimArray(",c,");");h(c,".gi$locals.$iter0=Sk.abstr.iter(",this.vexpr(a.generators[0].iter),");");return c};b.prototype.cclass=
function(a){Sk.asserts.assert(a instanceof Sk.astnodes.ClassDef);var c=this.vseqexpr(a.decorator_list);var n=this.vseqexpr(a.bases);let m=this.cunpackkwstoarray(a.keywords);var k=this.enterScope(a.name,a,a.lineno);var u=this.newBlock("class entry");this.u.prefixCode="var "+k+"=(function $"+a.name.v+"$class_outer($globals,$locals,$cell){var $gbl=$globals,$loc=$locals,$free=$globals;";this.u.switchCode+="(function $"+a.name.v+"$_closure($cell){";this.u.switchCode+="var $blk="+u+",$exc=[],$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";
null!==Sk.execLimit&&(this.u.switchCode+="if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.switchCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.switchCode+="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="}}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+
this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }}}";this.u.suffixCode+="}).call(null, $cell);});";this.u.private_=a.name;this.cbody(a.body,a.name);h("return;");this.exitScope();h("$ret = Sk.misceval.buildClass($gbl,",k,",",a.name.$r().v,",[",n,"], $cell, ",m,");");this._checkSuspension();for(let l of c.reverse())h("$ret = Sk.misceval.callsimOrSuspendArray(",l,", [$ret]);"),this._checkSuspension();this.nameop(a.name,Sk.astnodes.Store,"$ret")};b.prototype.ccontinue=
function(a){var c=this.peekFinallyBlock();if(0==this.u.continueBlocks.length)throw new Sk.builtin.SyntaxError("'continue' outside loop",this.filename,a.lineno);a=this.u.continueBlocks[this.u.continueBlocks.length-1];Sk.asserts.assert(this.u.breakBlocks.length===this.u.continueBlocks.length);c&&c.breakDepth==this.u.continueBlocks.length?h("$postfinally={isBreak:true,gotoBlock:",a,"};"):this._jump(a)};b.prototype.cbreak=function(a){var c=this.peekFinallyBlock();if(0===this.u.breakBlocks.length)throw new Sk.builtin.SyntaxError("'break' outside loop",
this.filename,a.lineno);a=this.u.breakBlocks[this.u.breakBlocks.length-1];c&&c.breakDepth==this.u.breakBlocks.length?h("$postfinally={isBreak:true,gotoBlock:",a,"};"):this._jump(a)};b.prototype.vstmt=function(a,c){this.u.lineno=a.lineno;this.u.linenoSet=!1;this.u.localtemps=[];if(Sk.debugging&&this.u.canSuspend){var n=this.newBlock("debug breakpoint for line "+a.lineno);h("if (Sk.breakpoints('"+this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.debug'}, resume: function() {}}, '"+
this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+n+";","$susp.optional = true;","return $susp;","}");this._jump(n);this.setBlock(n);this.u.doesSuspend=!0}this.annotateSource(a);switch(a.constructor){case Sk.astnodes.FunctionDef:this.cfunction(a,c);break;case Sk.astnodes.ClassDef:this.cclass(a);break;case Sk.astnodes.Return:if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'return' outside function",this.filename,a.lineno);n=a.value?this.vexpr(a.value):
"Sk.builtin.none.none$";0==this.u.finallyBlocks.length?h("return ",n,";"):(h("$postfinally={returning:",n,"};"),this._jump(this.peekFinallyBlock().blk));break;case Sk.astnodes.Delete:this.vseqexpr(a.targets);break;case Sk.astnodes.Assign:var m=a.targets.length;n=this.vexpr(a.value);for(c=0;c<m;++c)this.vexpr(a.targets[c],n);break;case Sk.astnodes.AnnAssign:return this.cannassign(a);case Sk.astnodes.AugAssign:return this.caugassign(a);case Sk.astnodes.Print:this.cprint(a);break;case Sk.astnodes.For:return this.cfor(a);
case Sk.astnodes.While:return this.cwhile(a);case Sk.astnodes.If:return this.cif(a);case Sk.astnodes.Raise:return this.craise(a);case Sk.astnodes.Try:return this.ctry(a);case Sk.astnodes.With:return this.cwith(a,0);case Sk.astnodes.Assert:return this.cassert(a);case Sk.astnodes.Import:return this.cimport(a);case Sk.astnodes.ImportFrom:return this.cfromimport(a);case Sk.astnodes.Global:break;case Sk.astnodes.Expr:this.vexpr(a.value);break;case Sk.astnodes.Pass:break;case Sk.astnodes.Break:this.cbreak(a);
break;case Sk.astnodes.Continue:this.ccontinue(a);break;case Sk.astnodes.Debugger:h("debugger;");break;default:Sk.asserts.fail("unhandled case in vstmt: "+JSON.stringify(a))}};b.prototype.vseqstmt=function(a){var c;for(c=0;c<a.length;++c)this.vstmt(a[c])};b.prototype.isCell=function(a){a=d(f(this.u.private_,a).v);return this.u.ste.getScope(a)===Sk.SYMTAB_CONSTS.CELL};b.prototype.nameop=function(a,c,n){if((c===Sk.astnodes.Store||c===Sk.astnodes.AugStore||c===Sk.astnodes.Del)&&"__debug__"===a.v)throw new Sk.builtin.SyntaxError("can not assign to __debug__",
this.filename,this.u.lineno);Sk.asserts.assert("None"!==a.v);if("NotImplemented"===a.v)return"Sk.builtin.NotImplemented.NotImplemented$";var m=f(this.u.private_,a).v;m=d(m);var k=3;var u=this.u.ste.getScope(m);var l=null;switch(u){case Sk.SYMTAB_CONSTS.FREE:l="$free";k=2;break;case Sk.SYMTAB_CONSTS.CELL:l="$cell";k=2;break;case Sk.SYMTAB_CONSTS.LOCAL:this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock||this.u.ste.generator||(k=0);break;case Sk.SYMTAB_CONSTS.GLOBAL_IMPLICIT:this.u.ste.blockType===
Sk.SYMTAB_CONSTS.FunctionBlock&&(k=1);break;case Sk.SYMTAB_CONSTS.GLOBAL_EXPLICIT:k=1}Sk.asserts.assert(u||"_"===a.v.charAt(1));a=m;this.u.ste.generator||this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock?m="$loc."+m:(0===k||3===k)&&this.u.localnames.push(m);switch(k){case 0:switch(c){case Sk.astnodes.Load:case Sk.astnodes.Param:return h("if (",m," === undefined) { throw new Sk.builtin.UnboundLocalError('local variable \\'",m,"\\' referenced before assignment'); }\n"),m;case Sk.astnodes.Store:h(m,
"=",n,";");break;case Sk.astnodes.Del:h("delete ",m,";");break;default:Sk.asserts.fail("unhandled")}break;case 3:switch(c){case Sk.astnodes.Load:return this._gr("loadname",m,"!==undefined?",m,":Sk.misceval.loadname('",a,"',$gbl);");case Sk.astnodes.Store:h(m,"=",n,";");break;case Sk.astnodes.Del:h("delete ",m,";");break;case Sk.astnodes.Param:return m;default:Sk.asserts.fail("unhandled")}break;case 1:switch(c){case Sk.astnodes.Load:return this._gr("loadgbl","Sk.misceval.loadname('",a,"',$gbl)");case Sk.astnodes.Store:h("$gbl.",
a,"=",n,";");break;case Sk.astnodes.Del:h("delete $gbl.",a);break;default:Sk.asserts.fail("unhandled case in name op_global")}break;case 2:switch(c){case Sk.astnodes.Load:return l+"."+a;case Sk.astnodes.Store:h(l,".",a,"=",n,";");break;case Sk.astnodes.Param:return a;default:Sk.asserts.fail("unhandled case in name op_deref")}break;default:Sk.asserts.fail("unhandled case")}};b.prototype.enterScope=function(a,c,n,m){var k=new e;k.ste=this.st.getStsForAst(c);k.name=a;k.firstlineno=n;k.canSuspend=m||
!1;this.u&&this.u.private_&&(k.private_=this.u.private_);this.stack.push(this.u);this.allUnits.push(k);a=this.gensym("scope");k.scopename=a;this.u=k;this.u.activateScope();this.nestlevel++;return a};b.prototype.exitScope=function(){var a=this.u;this.nestlevel--;(this.u=0<=this.stack.length-1?this.stack.pop():null)&&this.u.activateScope();if("<module>"!==a.name.v){var c=a.name.$r().v;c=c.substring(1,c.length-1);h(a.scopename,".co_name=new Sk.builtins['str']('",c,"');");this.stack.length&&"class"==
this.u.ste.blockType&&h(a.scopename,".co_qualname=new Sk.builtins['str']('"+this.u.name.v+"."+c+"');")}for(var n in a.consts)a.consts.hasOwnProperty(n)&&(a.suffixCode+=n+" = "+a.consts[n]+";")};b.prototype.cbody=function(a,c){var n=0;const m=this.maybeCDocstringOfBody(a);null!==m&&(h("$loc.__doc__ = ",m,";"),n=1);for(;n<a.length;++n)this.vstmt(a[n],c);this.u.hasAnnotations&&(this.u.varDeclsCode+="$loc.__annotations__ || ($loc.__annotations__ = new Sk.builtin.dict());")};b.prototype.cprint=function(a){var c;
Sk.asserts.assert(a instanceof Sk.astnodes.Print);a.dest&&this.vexpr(a.dest);var n=a.values.length;for(c=0;c<n;++c)h("$ret = Sk.misceval.print_(","new Sk.builtins['str'](",this.vexpr(a.values[c]),").v);"),this._checkSuspension(a);a.nl&&(h("$ret = Sk.misceval.print_(",'"\\n");'),this._checkSuspension(a))};b.prototype.cmod=function(a){var c=this.enterScope(new Sk.builtin.str("<module>"),a,0,this.canSuspend),n=this.newBlock("module entry");this.u.prefixCode="var "+c+"=(function($forcegbl, $forceloc){";
this.u.varDeclsCode="var $gbl = $forcegbl || {}, $blk="+n+",$exc=[],$loc=$forceloc || $gbl,$cell={},$err=undefined;var $ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";null!==Sk.execLimit&&(this.u.varDeclsCode+="if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.varDeclsCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.varDeclsCode+="var $waking=false; if ("+c+
".$wakingSuspension!==undefined) { $wakeFromSuspension(); $waking=true; }if (Sk.retainGlobals) {    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; }    else { Sk.globals = $gbl; }} else { Sk.globals = $gbl; }";this.u.switchCode="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="}";this.u.suffixCode+="}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+
this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } });";switch(a.constructor){case Sk.astnodes.Module:this.cbody(a.body);h("return $loc;");break;default:Sk.asserts.fail("todo; unhandled case in compilerMod")}this.exitScope();this.result.push(this.outputAllUnits());return c};Sk.compile=function(a,c,n,m){n=Sk.__future__;Sk.__future__=Object.create(Sk.__future__);var k=Sk.parse(c,a),u=Sk.astFromParse(k.cst,c,k.flags);k=k.flags;var l=Sk.symboltable(u,
c);a=new b(c,l,k,m,a);m=a.cmod(u);Sk.__future__=n;return{funcname:"$compiledmod",code:`var $compiledmod = function() {${a.result.join("")}\nreturn ${m};}();\n$compiledmod;`,filename:c}};Sk.exportSymbol("Sk.compile",Sk.compile);Sk.resetCompiler=function(){Sk.gensymcount=0};Sk.exportSymbol("Sk.resetCompiler",Sk.resetCompiler);Sk.fixReserved=d;Sk.exportSymbol("Sk.fixReserved",Sk.fixReserved);Sk.unfixReserved=function(a){return a.replace(/_\$rw\$$/,"")};Sk.exportSymbol("Sk.unfixReserved",Sk.unfixReserved);
Sk.mangleName=f;Sk.exportSymbol("Sk.mangleName",Sk.mangleName);Sk.reservedWords_=p;Sk.exportSymbol("Sk.reservedWords_",Sk.reservedWords_)},function(F,P){Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.importSearchPathForName=function(b,e,d){var f=b.replace(/\./g,"/"),h=function(p,g){return Sk.misceval.chain(Sk.misceval.tryCatch(function(){return Sk.read(p)},function(a){}),function(a){if(void 0!==a)return new Sk.misceval.Break({filename:p,code:a,packagePath:g})})};void 0===d&&(d=Sk.realsyspath);
return Sk.misceval.iterFor(d.tp$iter(),function(p){return Sk.misceval.chain(h(p.v+"/"+f+e,!1),function(g){return g?g:h(p.v+"/"+f+"/__init__"+e,p.v+"/"+f)})})};Sk.importSetUpPath=function(b){if(!Sk.realsyspath){var e=[new Sk.builtin.str("src/builtin"),new Sk.builtin.str("src/lib"),new Sk.builtin.str(".")];for(b=0;b<Sk.syspath.length;++b)e.push(new Sk.builtin.str(Sk.syspath[b]));Sk.realsyspath=new Sk.builtin.list(e)}};Sk.importModuleInternal_=function(b,e,d,f,h,p,g){var a,c,n,m,k=null,u=void 0!==h?
h.tp$getattr(Sk.builtin.str.$name):void 0,l=void 0!==u?u.v+".":"",q=void 0!==h?h.tp$getattr(Sk.builtin.str.$path):void 0;Sk.importSetUpPath(g);if(h&&!u){if(p)return;throw new Sk.builtin.ValueError("Attempted to import relative to invalid package (no name)");}void 0===d&&(d=l+b);var z=b.split(".");if(1<z.length){var r=z.slice(0,z.length-1).join(".");k=Sk.importModuleInternal_(r,e,void 0,void 0,h,p,g)}var t=Sk.misceval.chain(k,function(x){k=x;c=Sk.sysmodules.quick$lookup(new Sk.builtin.str(d));return void 0!==
c?k||c:Sk.misceval.chain(void 0,function(){var v=b;if(1<z.length){if(!k)return;n=Sk.sysmodules.mp$subscript(new Sk.builtin.str(l+r));v=z[z.length-1];q=n.tp$getattr(Sk.builtin.str.$path)}m=new Sk.builtin.module;if("string"===typeof f){a=b+".py";var B=Sk.compile(f,a,"exec",g)}else B=Sk.misceval.chain(void 0,function(){if(Sk.onBeforeImport&&"function"===typeof Sk.onBeforeImport)return Sk.onBeforeImport(b)},function(I){if(!1===I)throw new Sk.builtin.ImportError("Importing "+b+" is not allowed");if("string"===
typeof I)throw new Sk.builtin.ImportError(I);return Sk.importSearchPathForName(v,".js",q)},function(I){return I?{funcname:"$builtinmodule",code:I.code,filename:I.filename,packagePath:I.packagePath}:Sk.misceval.chain(Sk.importSearchPathForName(v,".py",q),function(M){if(I=M)return Sk.compile(I.code,I.filename,"exec",g)},function(M){if(M)return M.packagePath=I.packagePath,M})});return B},function(v){if(v){var B=m.$js=v.code;null==a&&(a=v.filename);null!=Sk.dateSet&&Sk.dateSet||(B="Sk.execStart = Sk.lastYield = new Date();\n"+
v.code,Sk.dateSet=!0);if(e){var I=function(y){var A,J=Sk.js_beautify(y).split("\n");for(A=1;A<=J.length;++A){var Q=(""+A).length;for(y="";5>Q;++Q)y+=" ";J[A-1]="/* "+y+A+" */ "+J[A-1]}return J.join("\n")};B=I(B);Sk.debugout(B)}"$compiledmod"!==v.funcname&&(B+="\n"+v.funcname+";");var M=new Sk.builtin.str(d),S=new Sk.builtin.str(b);Sk.sysmodules.mp$ass_subscript(M,m);h&&h.tp$setattr(S,m);var E=Sk.global.eval(B);m.init$dict(M,Sk.builtin.none.none$);m.$d.__package__=v.packagePath?M:r?new Sk.builtin.str(l+
r):u?u:Sk.builtin.none.none$;v.packagePath&&(m.$d.__path__=new Sk.builtin.tuple([new Sk.builtin.str(v.packagePath)]));v.filename&&"$builtinmodule"!==v.funcname&&(m.$d.__file__=new Sk.builtin.str(v.filename));var H=h&&h.$initializing;m.$initializing=!0;h&&!H&&(h.$initializing=!0);return Sk.misceval.tryCatch(()=>Sk.misceval.chain(E(m.$d),y=>{m.$initializing=!1;h&&!H&&(h.$initializing=!1);return y}),y=>{try{Sk.abstr.objectDelItem(Sk.sysmodules,M)}catch(A){}if(h)try{h.tp$setattr(S,void 0)}catch(A){}m.$initializing=
!1;h&&!H&&(h.$initializing=!1);throw y;})}},function(v){var B;if(void 0===v){if(p&&!k)return;throw new Sk.builtin.ModuleNotFoundError("No module named "+Sk.misceval.objectRepr(new Sk.builtin.str(b)));}if(v!==m.$d){for(B in m.$d)v[B]||(v[B]=m.$d[B]);m.$d=v}if(Sk.onAfterImport&&"function"===typeof Sk.onAfterImport)try{Sk.onAfterImport(b)}catch(I){}return k?(n.tp$setattr(new Sk.builtin.str(z[z.length-1]),m),k):m})});return g?t:Sk.misceval.retryOptionalSuspensionOrThrow(t)};Sk.importModule=function(b,
e,d){return Sk.importModuleInternal_(b,e,void 0,void 0,void 0,!1,d)};Sk.importMain=function(b,e,d){Sk.dateSet=!1;Sk.filesLoaded=!1;Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.resetCompiler();return Sk.importModuleInternal_(b,e,"__main__",void 0,void 0,!1,d)};Sk.importMainWithBody=function(b,e,d,f){Sk.dateSet=!1;Sk.filesLoaded=!1;Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.resetCompiler();return Sk.importModuleInternal_(b,e,"__main__",d,void 0,!1,f)};Sk.importBuiltinWithBody=
function(b,e,d,f){return Sk.importModuleInternal_(b,e,"__builtin__."+b,d,void 0,!1,f)};Sk.builtin.__import__=function(b,e,d,f,h){b=b.toString();var p=Sk.globals,g;null==h&&(h=Sk.__future__.absolute_import?0:-1);if(0!==h&&e.__package__&&e.__package__!==Sk.builtin.none.none$){if((g=e.__package__.v)&&0<h){e=g.split(".");if(h-1>=e.length)throw new Sk.builtin.ImportError("Attempted relative import beyond toplevel package");e.length-=h-1;g=e.join(".")}var a=Sk.sysmodules.quick$lookup(new Sk.builtin.str(g))}if(0<
h&&void 0===a)throw new Sk.builtin.ImportError("Attempted relative import in non-package");b.split(".");return Sk.misceval.chain(void 0,function(){if(0!==h&&void 0!==a)return""===b?a:Sk.importModuleInternal_(b,void 0,g+"."+b,void 0,a,-1==h,!0)},function(c){return void 0===c?(g=a=void 0,Sk.importModuleInternal_(b,void 0,void 0,void 0,void 0,!1,!0)):c},function(c){if(f&&0!==f.length){c=[null];const n=Sk.sysmodules.mp$subscript(new Sk.builtin.str((g||"")+(g&&b?".":"")+b));for(let m=0;m<f.length;m++){const k=
f[m];"*"!==k&&void 0===n.tp$getattr(new Sk.builtin.str(k))&&c.push(()=>Sk.importModuleInternal_(k,void 0,void 0,void 0,n,!0,!0))}return Sk.misceval.chain(...c,function(){Sk.asserts.assert(n);return n})}return c},function(c){p!==Sk.globals&&(Sk.globals=p);return c})};Sk.importStar=function(b,e,d){if(d=b.tp$getattr(new Sk.builtin.str("__all__")))for(let f=Sk.abstr.iter(d),h=f.tp$iternext();void 0!==h;h=f.tp$iternext())e[h.v]=Sk.abstr.gattr(b,h);else{d=Object.getOwnPropertyNames(b.$d);for(let f in d)"_"!=
d[f].charAt(0)&&(e[d[f]]=b.$d[d[f]])}};Sk.exportSymbol("Sk.importMain",Sk.importMain);Sk.exportSymbol("Sk.importMainWithBody",Sk.importMainWithBody);Sk.exportSymbol("Sk.importBuiltinWithBody",Sk.importBuiltinWithBody);Sk.exportSymbol("Sk.builtin.__import__",Sk.builtin.__import__);Sk.exportSymbol("Sk.importStar",Sk.importStar)},function(F,P){Sk.builtin.timSort=function(b,e){this.list=new Sk.builtin.list(b.v);this.MIN_GALLOP=7;this.listlength=e?e:b.sq$length()};Sk.builtin.timSort.prototype.lt=function(b,
e){return Sk.misceval.richCompareBool(b,e,"Lt")};Sk.builtin.timSort.prototype.le=function(b,e){return!this.lt(e,b)};Sk.builtin.timSort.prototype.setitem=function(b,e){this.list.v[b]=e};Sk.builtin.timSort.prototype.binary_sort=function(b,e){var d;for(d=b.base+e;d<b.base+b.len;d++){var f=b.base;var h=d;for(e=b.getitem(h);f<h;){var p=f+(h-f>>1);this.lt(e,b.getitem(p))?h=p:f=p+1}Sk.asserts.assert(f===h);for(p=d;p>f;p--)b.setitem(p,b.getitem(p-1));b.setitem(f,e)}};Sk.builtin.timSort.prototype.count_run=
function(b){var e;if(1>=b.len){var d=b.len;var f=!1}else if(d=2,this.lt(b.getitem(b.base+1),b.getitem(b.base)))for(f=!0,e=b.base+2;e<b.base+b.len;e++)if(this.lt(b.getitem(e),b.getitem(e-1)))d++;else break;else for(f=!1,e=b.base+2;e<b.base+b.len&&!this.lt(b.getitem(e),b.getitem(e-1));e++)d++;return{run:new Sk.builtin.listSlice(b.list,b.base,d),descending:f}};Sk.builtin.timSort.prototype.sort=function(){var b,e=new Sk.builtin.listSlice(this.list,0,this.listlength);if(!(2>e.len)){this.merge_init();for(b=
this.merge_compute_minrun(e.len);0<e.len;){var d=this.count_run(e);d.descending&&d.run.reverse();if(d.run.len<b){var f=d.run.len;d.run.len=b<e.len?b:e.len;this.binary_sort(d.run,f)}e.advance(d.run.len);this.pending.push(d.run);this.merge_collapse()}Sk.asserts.assert(e.base==this.listlength);this.merge_force_collapse();Sk.asserts.assert(1==this.pending.length);Sk.asserts.assert(0===this.pending[0].base);Sk.asserts.assert(this.pending[0].len==this.listlength)}};Sk.builtin.timSort.prototype.gallop=function(b,
e,d,f){var h;Sk.asserts.assert(0<=d&&d<e.len);var p=this;f=f?function(n,m){return p.le(n,m)}:function(n,m){return p.lt(n,m)};var g=e.base+d;var a=0;var c=1;if(f(e.getitem(g),b)){for(h=e.len-d;c<h;)if(f(e.getitem(g+c),b)){a=c;try{c=(c<<1)+1}catch(n){c=h}}else break;c>h&&(c=h);a+=d;c+=d}else{for(h=d+1;c<h&&!f(e.getitem(g-c),b);){a=c;try{c=(c<<1)+1}catch(n){c=h}}c>h&&(c=h);g=d-a;a=d-c;c=g}Sk.asserts.assert(-1<=a<c<=e.len);for(a+=1;a<c;)d=a+(c-a>>1),f(e.getitem(e.base+d),b)?a=d+1:c=d;Sk.asserts.assert(a==
c);return c};Sk.builtin.timSort.prototype.merge_init=function(){this.min_gallop=this.MIN_GALLOP;this.pending=[]};Sk.builtin.timSort.prototype.merge_lo=function(b,e){var d,f,h;Sk.asserts.assert(0<b.len&&0<e.len&&b.base+b.len==e.base);var p=this.min_gallop;var g=b.base;b=b.copyitems();try{if(this.setitem(g,e.popleft()),g++,1!=b.len&&0!==e.len)for(;;){for(f=d=0;;)if(this.lt(e.getitem(e.base),b.getitem(b.base))){this.setitem(g,e.popleft());g++;if(0===e.len)return;f++;d=0;if(f>=p)break}else{this.setitem(g,
b.popleft());g++;if(1==b.len)return;d++;f=0;if(d>=p)break}for(p+=1;;){this.min_gallop=p-=1<p;d=this.gallop(e.getitem(e.base),b,0,!0);for(h=b.base;h<b.base+d;h++)this.setitem(g,b.getitem(h)),g++;b.advance(d);if(1>=b.len)return;this.setitem(g,e.popleft());g++;if(0===e.len)return;f=this.gallop(b.getitem(b.base),e,0,!1);for(h=e.base;h<e.base+f;h++)this.setitem(g,e.getitem(h)),g++;e.advance(f);if(0===e.len)return;this.setitem(g,b.popleft());g++;if(1==b.len)return;if(d<this.MIN_GALLOP&&f<this.MIN_GALLOP)break;
p++;this.min_gallop=p}}}finally{Sk.asserts.assert(0<=b.len&&0<=e.len);for(h=e.base;h<e.base+e.len;h++)this.setitem(g,e.getitem(h)),g++;for(h=b.base;h<b.base+b.len;h++)this.setitem(g,b.getitem(h)),g++}};Sk.builtin.timSort.prototype.merge_hi=function(b,e){var d,f,h;Sk.asserts.assert(0<b.len&&0<e.len&&b.base+b.len==e.base);var p=this.min_gallop;var g=e.base+e.len;e=e.copyitems();try{if(g--,this.setitem(g,b.popright()),0!==b.len&&1!=e.len)for(;;){for(f=d=0;;){var a=b.getitem(b.base+b.len-1);var c=e.getitem(e.base+
e.len-1);if(this.lt(c,a)){g--;this.setitem(g,a);b.len--;if(0===b.len)return;d++;f=0;if(d>=p)break}else{g--;this.setitem(g,c);e.len--;if(1==e.len)return;f++;d=0;if(f>=p)break}}for(p+=1;;){this.min_gallop=p-=1<p;c=e.getitem(e.base+e.len-1);var n=this.gallop(c,b,b.len-1,!0);d=b.len-n;for(h=b.base+b.len-1;h>b.base+n-1;h--)g--,this.setitem(g,b.getitem(h));b.len-=d;if(0===b.len)return;g--;this.setitem(g,e.popright());if(1==e.len)return;a=b.getitem(b.base+b.len-1);n=this.gallop(a,e,e.len-1,!1);f=e.len-n;
for(h=e.base+e.len-1;h>e.base+n-1;h--)g--,this.setitem(g,e.getitem(h));e.len-=f;if(1>=e.len)return;g--;this.setitem(g,b.popright());if(0===b.len)return;if(d<this.MIN_GALLOP&&f<this.MIN_GALLOP)break;p++;this.min_gallop=p}}}finally{Sk.asserts.assert(0<=b.len&&0<=e.len);for(h=b.base+b.len-1;h>b.base-1;h--)g--,this.setitem(g,b.getitem(h));for(h=e.base+e.len-1;h>e.base-1;h--)g--,this.setitem(g,e.getitem(h))}};Sk.builtin.timSort.prototype.merge_at=function(b){0>b&&(b=this.pending.length+b);var e=this.pending[b];
var d=this.pending[b+1];Sk.asserts.assert(0<e.len&&0<d.len);Sk.asserts.assert(e.base+e.len==d.base);this.pending[b]=new Sk.builtin.listSlice(this.list,e.base,e.len+d.len);this.pending.splice(b+1,1);b=this.gallop(d.getitem(d.base),e,0,!0);e.advance(b);0!==e.len&&(d.len=this.gallop(e.getitem(e.base+e.len-1),d,d.len-1,!1),0!==d.len&&(e.len<=d.len?this.merge_lo(e,d):this.merge_hi(e,d)))};Sk.builtin.timSort.prototype.merge_collapse=function(){for(var b=this.pending;1<b.length;)if(3<=b.length&&b[b.length-
3].len<=b[b.length-2].len+b[b.length-1].len)b[b.length-3].len<b[b.length-1].len?this.merge_at(-3):this.merge_at(-2);else if(b[b.length-2].len<=b[b.length-1].len)this.merge_at(-2);else break};Sk.builtin.timSort.prototype.merge_force_collapse=function(){for(var b=this.pending;1<b.length;)3<=b.length&&b[b.length-3].len<b[b.length-1].len?this.merge_at(-3):this.merge_at(-2)};Sk.builtin.timSort.prototype.merge_compute_minrun=function(b){for(var e=0;64<=b;)e|=b&1,b>>=1;return b+e};Sk.builtin.listSlice=function(b,
e,d){this.list=b;this.base=e;this.len=d};Sk.builtin.listSlice.prototype.copyitems=function(){var b=this.base,e=this.base+this.len;Sk.asserts.assert(0<=b<=e);return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(b,e)),0,this.len)};Sk.builtin.listSlice.prototype.advance=function(b){this.base+=b;this.len-=b;Sk.asserts.assert(this.base<=this.list.sq$length())};Sk.builtin.listSlice.prototype.getitem=function(b){return this.list.v[b]};Sk.builtin.listSlice.prototype.setitem=function(b,e){this.list.v[b]=
e};Sk.builtin.listSlice.prototype.popleft=function(){var b=this.list.v[this.base];this.base++;this.len--;return b};Sk.builtin.listSlice.prototype.popright=function(){this.len--;return this.list.v[this.base+this.len]};Sk.builtin.listSlice.prototype.reverse=function(){for(var b,e,d=this.list,f=this.base,h=f+this.len-1;f<h;)b=d.v[h],e=d.v[f],d.v[f]=b,d.v[h]=e,f++,h--};Sk.exportSymbol("Sk.builtin.listSlice",Sk.builtin.listSlice);Sk.exportSymbol("Sk.builtin.timSort",Sk.builtin.timSort)},function(F,P){Sk.builtin.super_=
Sk.abstr.buildNativeClass("super",{constructor:function(b,e){Sk.asserts.assert(this instanceof Sk.builtin.super_,"bad call to super, use 'new'");this.type=b;this.obj=e;if(void 0!==b&&!Sk.builtin.checkClass(b))throw new Sk.builtin.TypeError("must be type, not "+Sk.abstr.typeName(b));this.obj_type=void 0!==this.obj?this.$supercheck(b,this.obj):null},slots:{tp$doc:"super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)\n",
tp$new:Sk.generic.new,tp$init(b,e){Sk.abstr.checkNoKwargs("super",e);Sk.abstr.checkArgsLen("super",b,1,2);e=b[0];b=b[1];if(!Sk.builtin.checkClass(e))throw new Sk.builtin.TypeError("must be type, not "+Sk.abstr.typeName(e));this.obj=b;this.type=e;null!=this.obj&&(this.obj_type=this.$supercheck(e,this.obj))},$r(){return this.obj?new Sk.builtin.str("<super: <class '"+this.type.prototype.tp$name+"'>, <"+Sk.abstr.typeName(this.obj)+" object>>"):new Sk.builtin.str("<super: <class '"+this.type.prototype.tp$name+
"'>, NULL>")},tp$getattr(b,e){let d=this.obj_type;if(null==d)return Sk.generic.getAttr.call(this,b,e);var f=d.prototype.tp$mro;const h=f.length;if(b===Sk.builtin.str.$class)return Sk.generic.getAttr.call(this,b,e);let p;for(p=0;p+1<h&&this.type!==f[p];p++);p++;if(p>=h)return Sk.generic.getAttr.call(this,b,e);b=b.$mangled;let g;for(;p<h;){e=f[p].prototype;e.hasOwnProperty(b)&&(g=e[b]);if(void 0!==g)return f=g.tp$descr_get,void 0!==f&&(g=f.call(g,this.obj===d?null:this.obj,d)),g;p++}},tp$descr_get(b,
e,d){if(null===b||null!=this.obj)return this;if(this.ob$type!==Sk.builtin.super_)return b=Sk.misceval.callsimOrSuspendArray(this.ob$type,[this.type,b]),d?b:Sk.misceval.retryOptionalSuspensionOrThrow(b);d=this.$supercheck(this.type,b);e=new Sk.builtin.super_;e.type=this.type;e.obj=b;e.obj_type=d;return e}},getsets:{__thisclass__:{$get(){return this.type},$doc:"the class invoking super()"},__self__:{$get(){return this.obj||Sk.builtin.none.none$},$doc:"the instance invoking super(); may be None"},__self_class__:{$get(){return this.obj_type||
Sk.builtin.none.none$},$doc:"the type of the instance invoking super(); may be None"}},proto:{$supercheck(b,e){if(Sk.builtin.checkClass(e)&&e.$isSubType(b))return e;if(e.ob$type.$isSubType(b))return e.ob$type;{const d=e.tp$getattr(Sk.builtin.str.$class);if(void 0!==d&&d!==e.ob$type&&Sk.builtin.checkClass(d)&&d.$isSubType(b))return d}throw new Sk.builtin.TypeError("super(type, obj): obj must be an instance or subtype of type");}}})},function(F,P){Sk.builtin.GenericAlias=Sk.abstr.buildNativeClass("types.GenericAlias",
{constructor:function(b,e){this.$origin=b;e instanceof Sk.builtin.tuple||(e=new Sk.builtin.tuple([e]));this.$args=e;this.$params=null},slots:{tp$new(b,e){Sk.abstr.checkNoKwargs("GenericAlias",e);Sk.abstr.checkArgsLen("GenericAlias",b,2,2);return new Sk.builtin.GenericAlias(b[0],b[1])},tp$getattr(b,e){return Sk.builtin.checkString(b)&&!this.attr$exc.includes(b)?this.$origin.tp$getattr(b,e):Sk.generic.getAttr.call(this,b,e)},$r(){const b=this.ga$repr(this.$origin);let e="";this.$args.v.forEach((d,f)=>
{e+=0<f?", ":"";e+=this.ga$repr(d)});e||(e="()");return new Sk.builtin.str(b+"["+e+"]")},tp$doc:"Represent a PEP 585 generic type\n\nE.g. for t = list[int], t.origin is list and t.args is (int,).",tp$hash(){const b=Sk.abstr.objectHash(this.$origin);if(-1==b)return-1;const e=Sk.abstr.objectHash(this.$args);return-1==e?-1:b^e},tp$call(b,e){b=Sk.misceval.callsimArray(this.$origin,b,e);try{b.tp$setattr(new Sk.builtin.str("__orig_class__"),this)}catch(d){if(!(d instanceof Sk.builtin.AttributeError||d instanceof
Sk.builtin.TypeError))throw d;}return b},tp$richcompare(b,e){if(!(b instanceof Sk.builtin.GenericAlias)||"Eq"!==e&&"NotEq"!==e)return Sk.builtin.NotImplemented.NotImplemented$;const d=Sk.misceval.richCompareBool(this.$origin,b.$origin,"Eq");if(!d)return"Eq"===e?d:!d;b=Sk.misceval.richCompareBool(this.$args,b.$args,"Eq");return"Eq"===e?b:!b},tp$as_sequence_or_mapping:!0,mp$subscript(b){null===this.$params&&this.mk$params();if(0===this.$params.sq$length())throw new Sk.builtin.TypeError("There are no type variables left in "+
Sk.misceval.objectRepr(this));}},methods:{__mro_entries__:{$meth(){return new Sk.builtin.tuple([this.$origin])},$flags:{NoArgs:!0}},__instancecheck__:{$meth(b){throw new Sk.builtin.TypeError("isinstance() argument 2 cannot be a parameterized generic");},$flags:{OneArg:!0}},__subclasscheck__:{$meth(b){throw new Sk.builtin.TypeError("issubclass() argument 2 cannot be a parameterized generic");},$flags:{OneArg:!0}}},getsets:{__parameters__:{$get(){null===this.$params&&this.mk$params();return this.$params},
$doc:"Type variables in the GenericAlias."},__origin__:{$get(){return this.$origin}},__args__:{$get(){return this.$args}}},proto:{mk$params(){const b=[];this.$args.v.forEach(e=>{this.is$typevar(e)&&0>this.tuple$index(b,e)&&b.push(e)});this.$params=new Sk.builtin.tuple(b)},tuple$index(b,e){return b.indexOf(e)},is$typevar(b){if("TypeVar"!==b.tp$name)return!1;b=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$module);if(void 0===b)throw Sk.builtin.RuntimeError("found object withought a __module__");return"typing"===
b.toString()},ga$repr(b){if(b===Sk.builtin.Ellipsis)return"...";if(Sk.abstr.lookupSpecial(b,this.str$orig)&&Sk.abstr.lookupSpecial(b,this.str$args))return Sk.misceval.objectRepr(b);const e=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$qualname);if(void 0===e)return Sk.misceval.objectRepr(b);const d=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$module);return void 0===d||Sk.builtin.checkNone(d)?Sk.misceval.objectRepr(b):"builtins"===d.toString()?e.toString():d.toString()+"."+e.toString()},str$orig:new Sk.builtin.str("__origin__"),
str$args:new Sk.builtin.str("__args__"),attr$exc:"__origin__ __args__ __parameters__ __mro_entries__ __reduce_ex__ __reduce__".split(" ").map(b=>new Sk.builtin.str(b))}})},function(F,P){function b(f,h){let p=void 0;if(void 0===f||Sk.builtin.checkNone(f))f=void 0;else if(f instanceof Sk.builtin.dict)p={},f.$items().forEach(g=>{var [a,c]=g;Sk.builtin.checkString(a)&&(p[a.$mangled]=c)});else throw new Sk.builtin.TypeError(h+" must be a dict or None, not "+Sk.abstr.typeName(f));return p}function e(f,
h){if(void 0!==f&&!Sk.builtin.checkNone(f))for(let p in h)f.mp$ass_subscript(new Sk.builtin.str(Sk.unfixReserved(p)),h[p])}Sk.builtins={round:null,len:null,min:null,max:null,sum:null,abs:null,fabs:null,ord:null,chr:null,hex:null,oct:null,bin:null,dir:null,repr:null,open:null,isinstance:null,hash:null,getattr:null,hasattr:null,id:null,sorted:null,any:null,all:null,enumerate:Sk.builtin.enumerate,filter:Sk.builtin.filter_,map:Sk.builtin.map_,range:Sk.builtin.range_,reversed:Sk.builtin.reversed,zip:Sk.builtin.zip_,
BaseException:Sk.builtin.BaseException,AttributeError:Sk.builtin.AttributeError,ValueError:Sk.builtin.ValueError,Exception:Sk.builtin.Exception,ZeroDivisionError:Sk.builtin.ZeroDivisionError,AssertionError:Sk.builtin.AssertionError,ImportError:Sk.builtin.ImportError,ModuleNotFoundError:Sk.builtin.ModuleNotFoundError,IndentationError:Sk.builtin.IndentationError,IndexError:Sk.builtin.IndexError,LookupError:Sk.builtin.LookupError,KeyError:Sk.builtin.KeyError,TypeError:Sk.builtin.TypeError,UnicodeDecodeError:Sk.builtin.UnicodeDecodeError,
UnicodeEncodeError:Sk.builtin.UnicodeEncodeError,NameError:Sk.builtin.NameError,UnboundLocalError:Sk.builtin.UnboundLocalError,IOError:Sk.builtin.IOError,NotImplementedError:Sk.builtin.NotImplementedError,SystemExit:Sk.builtin.SystemExit,OverflowError:Sk.builtin.OverflowError,OperationError:Sk.builtin.OperationError,NegativePowerError:Sk.builtin.NegativePowerError,RuntimeError:Sk.builtin.RuntimeError,RecursionError:Sk.builtin.RecursionError,StopIteration:Sk.builtin.StopIteration,SyntaxError:Sk.builtin.SyntaxError,
SystemError:Sk.builtin.SystemError,KeyboardInterrupt:Sk.builtin.KeyboardInterrupt,float_$rw$:Sk.builtin.float_,int_$rw$:Sk.builtin.int_,bool:Sk.builtin.bool,complex:Sk.builtin.complex,dict:Sk.builtin.dict,file:Sk.builtin.file,frozenset:Sk.builtin.frozenset,"function":Sk.builtin.func,generator:Sk.builtin.generator,list:Sk.builtin.list,long_$rw$:Sk.builtin.lng,method:Sk.builtin.method,object:Sk.builtin.object,slice:Sk.builtin.slice,str:Sk.builtin.str,set:Sk.builtin.set,tuple:Sk.builtin.tuple,type:Sk.builtin.type,
input:null,raw_input:new Sk.builtin.func(Sk.builtin.raw_input),setattr:null,jseval:Sk.builtin.jseval,jsmillis:Sk.builtin.jsmillis,quit:new Sk.builtin.func(Sk.builtin.quit),exit:new Sk.builtin.func(Sk.builtin.quit),print:null,divmod:null,format:null,globals:null,issubclass:null,iter:null,execfile:Sk.builtin.execfile,help:Sk.builtin.help,memoryview:Sk.builtin.memoryview,reload:Sk.builtin.reload,super_$rw$:Sk.builtin.super_,unichr:new Sk.builtin.func(Sk.builtin.unichr),vars:Sk.builtin.vars,apply_$rw$:Sk.builtin.apply_,
buffer:Sk.builtin.buffer,coerce:Sk.builtin.coerce,intern:Sk.builtin.intern,property:Sk.builtin.property,classmethod:Sk.builtin.classmethod,staticmethod:Sk.builtin.staticmethod,Ellipsis:Sk.builtin.Ellipsis};F=Sk.builtin.none.none$;P=new Sk.builtin.tuple;const d=new Sk.builtin.int_(0);Sk.abstr.setUpModuleMethods("builtins",Sk.builtins,{__import__:{$meth(f,h,p,g,a){if(!Sk.builtin.checkString(f))throw new Sk.builtin.TypeError("__import__() argument 1 must be str, not "+f.tp$name);if(f===Sk.builtin.str.$empty&&
0===a.v)throw new Sk.builtin.ValueError("Empty module name");h=b(h,"globals")||{};g=Sk.ffi.remapToJs(g);a=Sk.ffi.remapToJs(a);return Sk.builtin.__import__(f,h,void 0,g,a)},$flags:{NamedArgs:["name","globals","locals","fromlist","level"],Defaults:[F,F,P,d]},$textsig:null,$doc:"__import__(name, globals=None, locals=None, fromlist=(), level=0) -> module\n\nImport a module. Because this function is meant for use by the Python\ninterpreter and not for general use, it is better to use\nimportlib.import_module() to programmatically import a module.\n\nThe globals argument is only used to determine the context;\nthey are not modified.  The locals argument is unused.  The fromlist\nshould be a list of names to emulate ``from name import ...'', or an\nempty list to emulate ``import name''.\nWhen importing a module from a package, note that __import__('A.B', ...)\nreturns package A when fromlist is empty, but its submodule B when\nfromlist is not empty.  The level argument is used to determine whether to\nperform absolute or relative imports: 0 is absolute, while a positive number\nis the number of parent directories to search relative to the current module."},
abs:{$meth:Sk.builtin.abs,$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the absolute value of the argument."},all:{$meth:Sk.builtin.all,$flags:{OneArg:!0},$textsig:"($module, iterable, /)",$doc:"Return True if bool(x) is True for all values x in the iterable.\n\nIf the iterable is empty, return True."},any:{$meth:Sk.builtin.any,$flags:{OneArg:!0},$textsig:"($module, iterable, /)",$doc:"Return True if bool(x) is True for any x in the iterable.\n\nIf the iterable is empty, return False."},
ascii:{$meth:Sk.builtin.ascii,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."},bin:{$meth:Sk.builtin.bin,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the binary representation of an integer.\n\n   >>> bin(2796202)\n   '0b1010101010101010101010'"},
callable:{$meth:Sk.builtin.callable,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a\n__call__() method."},chr:{$meth:Sk.builtin.chr,$flags:{OneArg:!0},$textsig:"($module, i, /)",$doc:"Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff."},compile:{$meth:Sk.builtin.compile,$flags:{MinArgs:3,MaxArgs:6},$textsig:"($module, /, source, filename, mode, flags=0,\n        dont_inherit=False, optimize=-1)",
$doc:"Compile source into a code object that can be executed by exec() or eval().\n\nThe source code may represent a Python module, statement or expression.\nThe filename will be used for run-time error messages.\nThe mode must be 'exec' to compile a module, 'single' to compile a\nsingle (interactive) statement, or 'eval' to compile an expression.\nThe flags argument, if present, controls which future statements influence\nthe compilation of the code.\nThe dont_inherit argument, if true, stops the compilation inheriting\nthe effects of any future statements in effect in the code calling\ncompile; if absent or false these statements do influence the compilation,\nin addition to any features explicitly specified."},
delattr:{$meth:Sk.builtin.delattr,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, name, /)",$doc:"Deletes the named attribute from the given object.\n\ndelattr(x, 'y') is equivalent to ``del x.y''"},dir:{$meth:Sk.builtin.dir,$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"dir([object]) -> list of strings\n\nIf called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes."},
divmod:{$meth:Sk.builtin.divmod,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."},eval_$rw$:{$name:"eval",$meth:function(f,h,p){const g=b(h,"globals"),a=b(p,"locals");return Sk.misceval.chain(Sk.builtin.eval(f,g,a),c=>{e(h,g);e(p,a);return c})},$flags:{MinArgs:1,MaxArgs:3},$textsig:"($module, source, globals=None, locals=None, /)",$doc:"Evaluate the given source in the context of globals and locals.\n\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it."},
exec:{$meth:function(f,h,p){const g=b(h,"globals"),a=b(p,"locals");return Sk.misceval.chain(Sk.builtin.exec(f,g,a),c=>{e(h,g);e(p,a);return Sk.builtin.none.none$})},$flags:{MinArgs:1,MaxArgs:3},$textsig:"($module, source, globals=None, locals=None, /)",$doc:"Execute the given source in the context of globals and locals.\n\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it."},
format:{$meth:Sk.builtin.format,$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, value, format_spec='', /)",$doc:"Return value.__format__(format_spec)\n\nformat_spec defaults to the empty string.\nSee the Format Specification Mini-Language section of help('FORMATTING') for\ndetails."},getattr:{$meth:Sk.builtin.getattr,$flags:{MinArgs:2,MaxArgs:3},$textsig:null,$doc:"getattr(object, name[, default]) -> value\n\nGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case."},
globals:{$meth:Sk.builtin.globals,$flags:{NoArgs:!0},$textsig:"($module, /)",$doc:"Return the dictionary containing the current scope's global variables.\n\nNOTE: Updates to this dictionary *will* affect name lookups in the current\nglobal scope and vice-versa."},hasattr:{$meth:Sk.builtin.hasattr,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, name, /)",$doc:"Return whether the object has an attribute with the given name.\n\nThis is done by calling getattr(obj, name) and catching AttributeError."},
hash:{$meth:Sk.builtin.hash,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the hash value for the given object.\n\nTwo objects that compare equal must also have the same hash value, but the\nreverse is not necessarily true."},hex:{$meth:Sk.builtin.hex,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the hexadecimal representation of an integer.\n\n   >>> hex(12648430)\n   '0xc0ffee'"},id:{$meth:Sk.builtin.id,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the identity of an object.\n\nThis is guaranteed to be unique among simultaneously existing objects.\n(CPython uses the object's memory address.)"},
input:{$meth:Sk.builtin.input,$flags:{MinArgs:0,MaxArgs:1},$textsig:"($module, prompt=None, /)",$doc:"Read a string from standard input.  The trailing newline is stripped.\n\nThe prompt string, if given, is printed to standard output without a\ntrailing newline before reading input.\n\nIf the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\nOn *nix systems, readline is used if available."},isinstance:{$meth:Sk.builtin.isinstance,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, class_or_tuple, /)",
$doc:"Return whether an object is an instance of a class or of a subclass thereof.\n\nA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\nor ...`` etc."},issubclass:{$meth:Sk.builtin.issubclass,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, cls, class_or_tuple, /)",$doc:"Return whether 'cls' is a derived from another class or is the same class.\n\nA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\nor ...`` etc."},
iter:{$meth:Sk.builtin.iter,$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, iterable /)",$doc:"iter(iterable) -> iterator\niter(callable, sentinel) -> iterator\n\nGet an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel."},len:{$meth:Sk.builtin.len,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the number of items in a container."},locals:{$meth:Sk.builtin.locals,
$flags:{NoArgs:!0},$textsig:"($module, /)",$doc:"Return a dictionary containing the current scope's local variables.\n\nNOTE: Whether or not updates to this dictionary will affect name lookups in\nthe local scope and vice-versa is *implementation dependent* and not\ncovered by any backwards compatibility guarantees."},max:{$meth:Sk.builtin.max,$flags:{FastCall:!0},$textsig:null,$doc:"max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the largest argument."},
min:{$meth:Sk.builtin.min,$flags:{FastCall:!0},$textsig:null,$doc:"min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the smallest argument."},next:{$name:"next",$meth:Sk.builtin.next_,$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"next(iterator[, default])\n\nReturn the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration."},
oct:{$meth:Sk.builtin.oct,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the octal representation of an integer.\n\n   >>> oct(342391)\n   '0o1234567'"},open:{$meth:Sk.builtin.open,$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"open(name[, mode[, buffering]]) -> file object\n\nOpen a file using the file() type, returns a file object.  This is the\npreferred way to open a file.  See file.__doc__ for further information."},ord:{$meth:Sk.builtin.ord,$flags:{OneArg:!0},$textsig:"($module, c, /)",
$doc:"Return the Unicode code point for a one-character string."},pow:{$meth:Sk.builtin.pow,$flags:{MinArgs:2,MaxArgs:3},$textsig:"($module, x, y, z=None, /)",$doc:"Equivalent to x**y (with two arguments) or x**y % z (with three arguments)\n\nSome types, such as ints, are able to use a more efficient algorithm when\ninvoked using the three argument form."},print:{$meth:Sk.builtin.print,$flags:{FastCall:!0},$textsig:null,$doc:"print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream."},
repr:{$meth:Sk.builtin.repr,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the canonical string representation of the object.\n\nFor many object types, including most builtins, eval(repr(obj)) == obj."},round:{$meth:Sk.builtin.round,$flags:{NamedArgs:["number","ndigits"]},$textsig:"($module, /, number, ndigits=None)",$doc:"Round a number to a given precision in decimal digits.\n\nThe return value is an integer if ndigits is omitted or None.  Otherwise\nthe return value has the same type as the number.  ndigits may be negative."},
setattr:{$meth:Sk.builtin.setattr,$flags:{MinArgs:3,MaxArgs:3},$textsig:"($module, obj, name, value, /)",$doc:"Sets the named attribute on the given object to the specified value.\n\nsetattr(x, 'y', v) is equivalent to ``x.y = v''"},sorted:{$meth:Sk.builtin.sorted,$flags:{NamedArgs:[null,"cmp","key","reverse"],Defaults:[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.bool.false$]},$textsig:"($module, iterable, /, *, key=None, reverse=False)",$doc:"Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order."},
sum:{$meth:Sk.builtin.sum,$flags:{NamedArgs:[null,"start"],Defaults:[new Sk.builtin.int_(0)]},$textsig:"($module, iterable, /, start=0)",$doc:"Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types."},vars:{$meth:Sk.builtin.vars,$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"vars([object]) -> dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__."}});
Sk.setupObjects=function(f){f?(Sk.builtins.filter=Sk.builtin.filter_,Sk.builtins.map=Sk.builtin.map_,Sk.builtins.zip=Sk.builtin.zip_,Sk.builtins.range=Sk.builtin.range_,delete Sk.builtins.reduce,delete Sk.builtins.xrange,delete Sk.builtins.StandardError,delete Sk.builtins.unicode,delete Sk.builtins.basestring,delete Sk.builtins.long_$rw$,Sk.builtin.int_.prototype.$r=function(){return new Sk.builtin.str(this.v.toString())},delete Sk.builtin.int_.prototype.tp$str,delete Sk.builtin.bool.prototype.tp$str,
delete Sk.builtins.raw_input,delete Sk.builtins.unichr,delete Sk.builtin.str.prototype.decode,Sk.builtins.bytes=Sk.builtin.bytes,Sk.builtins.ascii=new Sk.builtin.sk_method({$meth:Sk.builtin.ascii,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."},
null,"builtins")):(Sk.builtins.range=new Sk.builtin.sk_method({$meth:Sk.builtin.range,$name:"range",$flags:{MinArgs:1,MaxArgs:3}},void 0,"builtins"),Sk.builtins.xrange=new Sk.builtin.sk_method({$meth:Sk.builtin.xrange,$name:"xrange",$flags:{MinArgs:1,MaxArgs:3}},null,"builtins"),Sk.builtins.reduce=new Sk.builtin.sk_method({$meth:Sk.builtin.reduce,$name:"reduce",$flags:{MinArgs:2,MaxArgs:3}},null,"builtins"),Sk.builtins.filter=new Sk.builtin.func(Sk.builtin.filter),Sk.builtins.map=new Sk.builtin.func(Sk.builtin.map),
Sk.builtins.zip=new Sk.builtin.func(Sk.builtin.zip),Sk.builtins.StandardError=Sk.builtin.Exception,Sk.builtins.unicode=Sk.builtin.str,Sk.builtins.basestring=Sk.builtin.str,Sk.builtins.long_$rw$=Sk.builtin.lng,Sk.builtin.int_.prototype.$r=function(){const h=this.v;return"number"===typeof h?new Sk.builtin.str(h.toString()):new Sk.builtin.str(h.toString()+"L")},Sk.builtin.int_.prototype.tp$str=function(){return new Sk.builtin.str(this.v.toString())},Sk.builtin.bool.prototype.tp$str=function(){return this.$r()},
Sk.builtins.raw_input=new Sk.builtin.func(Sk.builtin.raw_input),Sk.builtins.unichr=new Sk.builtin.func(Sk.builtin.unichr),Sk.builtin.str.prototype.decode=Sk.builtin.str.$py2decode,delete Sk.builtins.bytes,delete Sk.builtins.ascii)};Sk.exportSymbol("Sk.setupObjects",Sk.setupObjects);Sk.exportSymbol("Sk.builtins",Sk.builtins)},function(F,P){Sk.builtin.str.$empty=new Sk.builtin.str("");Sk.builtin.str.$emptystr=Sk.builtin.str.$empty;Sk.builtin.str.$utf8=new Sk.builtin.str("utf-8");Sk.builtin.str.$ascii=
new Sk.builtin.str("ascii");Sk.builtin.str.$default_factory=new Sk.builtin.str("default_factory");Sk.builtin.str.$imag=new Sk.builtin.str("imag");Sk.builtin.str.$real=new Sk.builtin.str("real");Sk.builtin.str.$abs=new Sk.builtin.str("__abs__");Sk.builtin.str.$bases=new Sk.builtin.str("__bases__");Sk.builtin.str.$bytes=new Sk.builtin.str("__bytes__");Sk.builtin.str.$call=new Sk.builtin.str("__call__");Sk.builtin.str.$class=new Sk.builtin.str("__class__");Sk.builtin.str.$class_getitem=new Sk.builtin.str("__class_getitem__");
Sk.builtin.str.$cmp=new Sk.builtin.str("__cmp__");Sk.builtin.str.$complex=new Sk.builtin.str("__complex__");Sk.builtin.str.$contains=new Sk.builtin.str("__contains__");Sk.builtin.str.$copy=new Sk.builtin.str("__copy__");Sk.builtin.str.$dict=new Sk.builtin.str("__dict__");Sk.builtin.str.$dir=new Sk.builtin.str("__dir__");Sk.builtin.str.$doc=new Sk.builtin.str("__doc__");Sk.builtin.str.$enter=new Sk.builtin.str("__enter__");Sk.builtin.str.$eq=new Sk.builtin.str("__eq__");Sk.builtin.str.$exit=new Sk.builtin.str("__exit__");
Sk.builtin.str.$index=new Sk.builtin.str("__index__");Sk.builtin.str.$init=new Sk.builtin.str("__init__");Sk.builtin.str.$initsubclass=new Sk.builtin.str("__init_subclass__");Sk.builtin.str.$int_=new Sk.builtin.str("__int__");Sk.builtin.str.$iter=new Sk.builtin.str("__iter__");Sk.builtin.str.$file=new Sk.builtin.str("__file__");Sk.builtin.str.$float_=new Sk.builtin.str("__float__");Sk.builtin.str.$format=new Sk.builtin.str("__format__");Sk.builtin.str.$ge=new Sk.builtin.str("__ge__");Sk.builtin.str.$getattr=
new Sk.builtin.str("__getattr__");Sk.builtin.str.$getattribute=new Sk.builtin.str("__getattribute__");Sk.builtin.str.$getitem=new Sk.builtin.str("__getitem__");Sk.builtin.str.$gt=new Sk.builtin.str("__gt__");Sk.builtin.str.$keys=new Sk.builtin.str("keys");Sk.builtin.str.$le=new Sk.builtin.str("__le__");Sk.builtin.str.$len=new Sk.builtin.str("__len__");Sk.builtin.str.$length_hint=new Sk.builtin.str("__length_hint__");Sk.builtin.str.$loader=new Sk.builtin.str("__loader__");Sk.builtin.str.$lt=new Sk.builtin.str("__lt__");
Sk.builtin.str.$module=new Sk.builtin.str("__module__");Sk.builtin.str.$missing=new Sk.builtin.str("__missing__");Sk.builtin.str.$name=new Sk.builtin.str("__name__");Sk.builtin.str.$ne=new Sk.builtin.str("__ne__");Sk.builtin.str.$new=new Sk.builtin.str("__new__");Sk.builtin.str.$next=new Sk.builtin.str("__next__");Sk.builtin.str.$path=new Sk.builtin.str("__path__");Sk.builtin.str.$prepare=new Sk.builtin.str("__prepare__");Sk.builtin.str.$qualname=new Sk.builtin.str("__qualname__");Sk.builtin.str.$repr=
new Sk.builtin.str("__repr__");Sk.builtin.str.$reversed=new Sk.builtin.str("__reversed__");Sk.builtin.str.$round=new Sk.builtin.str("__round__");Sk.builtin.str.$setattr=new Sk.builtin.str("__setattr__");Sk.builtin.str.$setitem=new Sk.builtin.str("__setitem__");Sk.builtin.str.$slots=new Sk.builtin.str("__slots__");Sk.builtin.str.$str=new Sk.builtin.str("__str__");Sk.builtin.str.$setname=new Sk.builtin.str("__set_name__");Sk.builtin.str.$trunc=new Sk.builtin.str("__trunc__");Sk.builtin.str.$write=new Sk.builtin.str("write");
Sk.misceval.op2method_={Eq:Sk.builtin.str.$eq,NotEq:Sk.builtin.str.$ne,Gt:Sk.builtin.str.$gt,GtE:Sk.builtin.str.$ge,Lt:Sk.builtin.str.$lt,LtE:Sk.builtin.str.$le}},function(F,P,b){function e(ca,la,ia,ka,U){this.type=ca;this.string=la;this.start=ia;this.end=ka;this.line=U}function d(ca){return"("+Array.prototype.slice.call(arguments).join("|")+")"}function f(ca){return d.apply(null,arguments)+"?"}function h(ca,la){for(var ia=ca.length;ia--;)if(ca[ia]===la)return!0;return!1}function p(ca){ca=ca.normalize("NFKC");
return E.test(ca)}function g(){return" FR RF Br BR Fr r B R b bR f rb rB F Rf U rF u RB br fR fr rf Rb".split(" ")}function a(ca){ca?delete Sk.token.EXACT_TOKEN_TYPES["<>"]:Sk.token.EXACT_TOKEN_TYPES["<>"]=Sk.token.tokens.T_NOTEQUAL;A=Object.keys(Sk.token.EXACT_TOKEN_TYPES).sort();J=d.apply(this,A.reverse().map(function(la){return la&&u.test(la)?la.replace(k,"\\$&"):la}));Q=d("\\r?\\n",J)}b.r(P);F={Cc:"\\0-\\x1F\\x7F-\\x9F",Cf:"\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB",
Co:"\\uE000-\\uF8FF",Cs:"\\uD800-\\uDFFF",Ll:"a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0560-\\u0588\\u10D0-\\u10FA\\u10FD-\\u10FF\\u13F8-\\u13FD\\u1C80-\\u1C88\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7AF\\uA7B5\\uA7B7\\uA7B9\\uA7BB\\uA7BD\\uA7BF\\uA7C3\\uA7C8\\uA7CA\\uA7F6\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB68\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A",
Lm:"\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3\\uAAF4\\uAB5C-\\uAB5F\\uAB69\\uFF70\\uFF9E\\uFF9F",
Lo:"\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC",
Lt:"\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC",Lu:"A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AE\\uA7B0-\\uA7B4\\uA7B6\\uA7B8\\uA7BA\\uA7BC\\uA7BE\\uA7C2\\uA7C4-\\uA7C7\\uA7C9\\uA7F5\\uFF21-\\uFF3A",
M:"\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81-\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA82C\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F",
Mc:"\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\u302E\\u302F\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uAA7D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC",
Me:"\\u0488\\u0489\\u1ABE\\u20DD-\\u20E0\\u20E2-\\u20E4\\uA670-\\uA672",Mn:"\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1ABF\\u1AC0\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F",
Nd:"0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19",
Nl:"\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF",No:"\\xB2\\xB3\\xB9\\xBC-\\xBE\\u09F4-\\u09F9\\u0B72-\\u0B77\\u0BF0-\\u0BF2\\u0C78-\\u0C7E\\u0D58-\\u0D5E\\u0D70-\\u0D78\\u0F2A-\\u0F33\\u1369-\\u137C\\u17F0-\\u17F9\\u19DA\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2150-\\u215F\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2CFD\\u3192-\\u3195\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\uA830-\\uA835",Pc:"_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F",
Pd:"\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D",Pe:"\\)\\]\\}\\u0F3B\\u0F3D\\u169C\\u2046\\u207E\\u208E\\u2309\\u230B\\u232A\\u2769\\u276B\\u276D\\u276F\\u2771\\u2773\\u2775\\u27C6\\u27E7\\u27E9\\u27EB\\u27ED\\u27EF\\u2984\\u2986\\u2988\\u298A\\u298C\\u298E\\u2990\\u2992\\u2994\\u2996\\u2998\\u29D9\\u29DB\\u29FD\\u2E23\\u2E25\\u2E27\\u2E29\\u3009\\u300B\\u300D\\u300F\\u3011\\u3015\\u3017\\u3019\\u301B\\u301E\\u301F\\uFD3E\\uFE18\\uFE36\\uFE38\\uFE3A\\uFE3C\\uFE3E\\uFE40\\uFE42\\uFE44\\uFE48\\uFE5A\\uFE5C\\uFE5E\\uFF09\\uFF3D\\uFF5D\\uFF60\\uFF63",
Pf:"\\xBB\\u2019\\u201D\\u203A\\u2E03\\u2E05\\u2E0A\\u2E0D\\u2E1D\\u2E21",Pi:"\\xAB\\u2018\\u201B\\u201C\\u201F\\u2039\\u2E02\\u2E04\\u2E09\\u2E0C\\u2E1C\\u2E20",Po:"!-#%-'\\*,\\.\\/:;\\?@\\xA1\\xA7\\xB6\\xB7\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u166E\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u1805\\u1807-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2016\\u2017\\u2020-\\u2027\\u2030-\\u2038\\u203B-\\u203E\\u2041-\\u2043\\u2047-\\u2051\\u2053\\u2055-\\u205E\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00\\u2E01\\u2E06-\\u2E08\\u2E0B\\u2E0E-\\u2E16\\u2E18\\u2E19\\u2E1B\\u2E1E\\u2E1F\\u2E2A-\\u2E2E\\u2E30-\\u2E39\\u2E3C-\\u2E3F\\u2E41\\u2E43-\\u2E4F\\u2E52\\u3001-\\u3003\\u303D\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFE10-\\uFE16\\uFE19\\uFE30\\uFE45\\uFE46\\uFE49-\\uFE4C\\uFE50-\\uFE52\\uFE54-\\uFE57\\uFE5F-\\uFE61\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF07\\uFF0A\\uFF0C\\uFF0E\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3C\\uFF61\\uFF64\\uFF65",
Ps:"\\(\\[\\{\\u0F3A\\u0F3C\\u169B\\u201A\\u201E\\u2045\\u207D\\u208D\\u2308\\u230A\\u2329\\u2768\\u276A\\u276C\\u276E\\u2770\\u2772\\u2774\\u27C5\\u27E6\\u27E8\\u27EA\\u27EC\\u27EE\\u2983\\u2985\\u2987\\u2989\\u298B\\u298D\\u298F\\u2991\\u2993\\u2995\\u2997\\u29D8\\u29DA\\u29FC\\u2E22\\u2E24\\u2E26\\u2E28\\u2E42\\u3008\\u300A\\u300C\\u300E\\u3010\\u3014\\u3016\\u3018\\u301A\\u301D\\uFD3F\\uFE17\\uFE35\\uFE37\\uFE39\\uFE3B\\uFE3D\\uFE3F\\uFE41\\uFE43\\uFE47\\uFE59\\uFE5B\\uFE5D\\uFF08\\uFF3B\\uFF5B\\uFF5F\\uFF62",
Sc:"\\$\\xA2-\\xA5\\u058F\\u060B\\u07FE\\u07FF\\u09F2\\u09F3\\u09FB\\u0AF1\\u0BF9\\u0E3F\\u17DB\\u20A0-\\u20BF\\uA838\\uFDFC\\uFE69\\uFF04\\uFFE0\\uFFE1\\uFFE5\\uFFE6",Sk:"\\^`\\xA8\\xAF\\xB4\\xB8\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0384\\u0385\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD\\u1FFE\\u309B\\u309C\\uA700-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uAB5B\\uAB6A\\uAB6B\\uFBB2-\\uFBC1\\uFF3E\\uFF40\\uFFE3",Sm:"\\+<->\\|~\\xAC\\xB1\\xD7\\xF7\\u03F6\\u0606-\\u0608\\u2044\\u2052\\u207A-\\u207C\\u208A-\\u208C\\u2118\\u2140-\\u2144\\u214B\\u2190-\\u2194\\u219A\\u219B\\u21A0\\u21A3\\u21A6\\u21AE\\u21CE\\u21CF\\u21D2\\u21D4\\u21F4-\\u22FF\\u2320\\u2321\\u237C\\u239B-\\u23B3\\u23DC-\\u23E1\\u25B7\\u25C1\\u25F8-\\u25FF\\u266F\\u27C0-\\u27C4\\u27C7-\\u27E5\\u27F0-\\u27FF\\u2900-\\u2982\\u2999-\\u29D7\\u29DC-\\u29FB\\u29FE-\\u2AFF\\u2B30-\\u2B44\\u2B47-\\u2B4C\\uFB29\\uFE62\\uFE64-\\uFE66\\uFF0B\\uFF1C-\\uFF1E\\uFF5C\\uFF5E\\uFFE2\\uFFE9-\\uFFEC",
So:"\\xA6\\xA9\\xAE\\xB0\\u0482\\u058D\\u058E\\u060E\\u060F\\u06DE\\u06E9\\u06FD\\u06FE\\u07F6\\u09FA\\u0B70\\u0BF3-\\u0BF8\\u0BFA\\u0C7F\\u0D4F\\u0D79\\u0F01-\\u0F03\\u0F13\\u0F15-\\u0F17\\u0F1A-\\u0F1F\\u0F34\\u0F36\\u0F38\\u0FBE-\\u0FC5\\u0FC7-\\u0FCC\\u0FCE\\u0FCF\\u0FD5-\\u0FD8\\u109E\\u109F\\u1390-\\u1399\\u166D\\u1940\\u19DE-\\u19FF\\u1B61-\\u1B6A\\u1B74-\\u1B7C\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116\\u2117\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u214A\\u214C\\u214D\\u214F\\u218A\\u218B\\u2195-\\u2199\\u219C-\\u219F\\u21A1\\u21A2\\u21A4\\u21A5\\u21A7-\\u21AD\\u21AF-\\u21CD\\u21D0\\u21D1\\u21D3\\u21D5-\\u21F3\\u2300-\\u2307\\u230C-\\u231F\\u2322-\\u2328\\u232B-\\u237B\\u237D-\\u239A\\u23B4-\\u23DB\\u23E2-\\u2426\\u2440-\\u244A\\u249C-\\u24E9\\u2500-\\u25B6\\u25B8-\\u25C0\\u25C2-\\u25F7\\u2600-\\u266E\\u2670-\\u2767\\u2794-\\u27BF\\u2800-\\u28FF\\u2B00-\\u2B2F\\u2B45\\u2B46\\u2B4D-\\u2B73\\u2B76-\\u2B95\\u2B97-\\u2BFF\\u2CE5-\\u2CEA\\u2E50\\u2E51\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303E\\u303F\\u3190\\u3191\\u3196-\\u319F\\u31C0-\\u31E3\\u3200-\\u321E\\u322A-\\u3247\\u3250\\u3260-\\u327F\\u328A-\\u32B0\\u32C0-\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA828-\\uA82B\\uA836\\uA837\\uA839\\uAA77-\\uAA79\\uFDFD\\uFFE4\\uFFE8\\uFFED\\uFFEE\\uFFFC\\uFFFD",
Zl:"\\u2028",Zp:"\\u2029",Zs:" \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000"};F.C=F.Cc+F.Cf+F.Cs+F.Co;F.L=F.Lu+F.Ll+F.Lt+F.Lm+F.Mn+F.Lo;F.LC=F.Lu+F.Ll+F.Lt;F.M=F.Mn+F.Mc+F.Me;F.N=F.Nd+F.Nl+F.No;F.P=F.Pc+F.Pd+F.Ps+F.Pe+F.Pi+F.Pf+F.Po;F.S=F.Sm+F.Sc+F.Sk+F.So;F.Z=F.Zs+F.Zl+F.Zp;F.w="_"+F.L+F.N;F.b="(?:["+F.w+"](?:[^"+F.w+"]|$)|(?:^|[^"+F.w+"])["+F.w+"])";F.bOut="(?=[^"+F.w+"]|$)";F.bIn="(?:^|[^"+F.w+"])";F.bInCapture="(?:^|([^"+F.w+"]))";F.B="(?:["+F.w+"]["+F.w+"]|[^"+F.w+"][^"+F.w+"])";F.d=F.N;
var c=Sk.token.tokens;const n=Sk.builtin.SyntaxError,m=Sk.builtin.SyntaxError;e.prototype.exact_type=function(){return this.type==c.T_OP&&this.string in Sk.token.EXACT_TOKEN_TYPES?Sk.token.EXACT_TOKEN_TYPES[this.string]:this.type};var k=/[\\^$.*+?()[\]{}|]/g,u=RegExp(k.source);const {Lu:l,Ll:q,Lt:z,Lm:r,Lo:t,Nl:x,Mn:v,Mc:B,Nd:I,Pc:M}=F;F=l+q+z+r+t+x+"_\\u1885-\\u1886\\u2118\\u212E\\u309B-\\u309C";const S="["+F+"]+["+(F+v+B+I+M+"\\u00B7\\u0387\\u1369-\\u1371\\u19DA]*"),E=new RegExp("^"+S+"$");Sk.token.isIdentifier=
p;(function(ca){return d.apply(null,arguments)+"*"})("\\\\\\r?\\n[ \\f\\t]*");f("#[^\\r\\n]*");F=d("[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?","\\.[0-9](?:_?[0-9])*")+f("[eE][-+]?[0-9](?:_?[0-9])*");var H=d(F,"[0-9](?:_?[0-9])*[eE][-+]?[0-9](?:_?[0-9])*"),y=d("[0-9](?:_?[0-9])*[jJ]",H+"[jJ]");F=d.apply(null,g());P=d(F+"'''",F+'"""');d(F+"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'",F+'"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');var A,J,Q;a(!0);Sk.token.setupTokens=a;var X=d(F+"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*"+
d("'","\\\\\\r?\\n"),F+'"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*'+d('"',"\\\\\\r?\\n")),aa=d("\\\\\\r?\\n|$","#[^\\r\\n]*",P),ea={};F=g();for(let ca of F)ea[ca+"'"]="^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'",ea[ca+'"']='^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"',ea[ca+"'''"]="^[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''",ea[ca+'"""']='^[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';let na=[],oa=[];for(let ca of F)na.push(ca+'"'),na.push(ca+"'"),oa.push(ca+'"""'),oa.push(ca+"'''");Sk._tokenize=function(ca,la,ia,ka){var U=Sk.__future__.python3?
"":"(?:L?)";U=d("0[xX](?:_?[0-9a-fA-F])+"+U,"0[bB](?:_?[01])+"+U,Sk.__future__.silent_octal_literal?"0([oO]?)(?:_?[0-7])+"+U:"0([oO])(?:_?[0-7])+"+U,"(?:0(?:_?0)*|[1-9](?:_?[0-9])*)"+U);U=d(y,H,U);U="[ \\f\\t]*"+d(aa,U,Q,X,S);U=new RegExp(U);var ja=0,O=0,V=0,Z="",fa=0,qa=null,pa=[0],D,w=void 0,C=void 0,G,L;void 0!==ia&&("utf-8-sig"==ia&&(ia="utf-8"),ka(new e(c.T_ENCODING,ia,[0,0],[0,0],"")));for(var K=ia="";;){try{ia=K,K=la()}catch(Y){K=""}ja+=1;var N=0,R=K.length;if(Z){if(!K)throw new n("EOF in multi-line string",
ca,C[0],C[1]);w.lastIndex=0;var W=w.exec(K);if(W)N=G=W[0].length,ka(new e(c.T_STRING,Z+K.substring(0,G),C,[ja,G],qa+K)),Z="",fa=0,qa=null;else{fa&&"\\\n"!==K.substring(K.length-2)&&"\\\r\n"!==K.substring(K.length-3)?(ka(new e(c.T_ERRORTOKEN,Z+K,C,[ja,K.length],qa)),Z="",qa=null):(Z+=K,qa+=K);continue}}else if(0!=O||V){if(!K)throw new n("EOF in multi-line statement",ca,ja,0);V=0}else{if(!K)break;for(D=0;N<R;){if(" "==K[N])D+=1;else if("\t"==K[N])D=8*Math.floor(D/8+1);else if("\f"==K[N])D=0;else break;
N+=1}if(N==R)break;if(h("#\r\n",K[N])){if("#"==K[N]){D=K.substring(N);for(R=D.length;0<R&&-1!=="\r\n".indexOf(D.charAt(R-1));--R);R=D.substring(0,R);ka(new e(c.T_COMMENT,R,[ja,N],[ja,N+R.length],K));N+=R.length}ka(new e(c.T_NL,K.substring(N),[ja,N],[ja,K.length],K));continue}D>pa[pa.length-1]&&(pa.push(D),ka(new e(c.T_INDENT,K.substring(N),[ja,0],[ja,N],K)));for(;D<pa[pa.length-1];){if(!h(pa,D))throw new m("unindent does not match any outer indentation level",ca,ja,N);pa=pa.slice(0,-1);ka(new e(c.T_DEDENT,
"",[ja,N],[ja,N],K))}}for(;N<R;){for(D=K.charAt(N);" "===D||"\f"===D||"\t"===D;)N+=1,D=K.charAt(N);if(L=U.exec(K.substring(N))){if(D=N,G=D+L[1].length,L=[ja,D],W=[ja,G],N=G,D!=G){G=K.substring(D,G);var T=K[D];if(h("0123456789",T)||"."==T&&"."!=G&&"..."!=G)ka(new e(c.T_NUMBER,G,L,W,K));else if(h("\r\n",T))0<O?ka(new e(c.T_NL,G,L,W,K)):ka(new e(c.T_NEWLINE,G,L,W,K));else if("#"==T)ka(new e(c.T_COMMENT,G,L,W,K));else if(h(oa,G))if(w=RegExp(ea[G]),W=w.exec(K.substring(N)))N=W[0].length+N,G=K.substring(D,
N),ka(new e(c.T_STRING,G,L,[ja,N],K));else{C=[ja,D];Z=K.substring(D);qa=K;break}else if(h(na,T)||h(na,G.substring(0,2))||h(na,G.substring(0,3)))if("\n"==G[G.length-1]){C=[ja,D];w=RegExp(ea[T]||ea[G[1]]||ea[G[2]]);Z=K.substring(D);fa=1;qa=K;break}else ka(new e(c.T_STRING,G,L,W,K));else p(T)?ka(new e(c.T_NAME,G,L,W,K)):"\\"==T?V=1:(h("([{",T)?O+=1:h(")]}",T)&&--O,ka(new e(c.T_OP,G,L,W,K)))}}else ka(new e(c.T_ERRORTOKEN,K[N],[ja,N],[ja,N+1],K)),N+=1}}ia&&!h("\r\n",ia[ia.length-1])&&ka(new e(c.T_NEWLINE,
"",[ja-1,ia.length],[ja-1,ia.length+1],""));for(var ba in pa.slice(1))ka(new e(c.T_DEDENT,"",[ja,0],[ja,0],""));ka(new e(c.T_ENDMARKER,"",[ja,0],[ja,0],""))};Sk._tokenize.Floatnumber=H;Sk.exportSymbol("Sk._tokenize",Sk._tokenize)}]);}).call(this || window)

//# sourceMappingURL=skulpt.min.js.map

/***/ }),

/***/ 12797:
/*!*****************************************************!*\
  !*** ./runestone/activecode/js/timed_activecode.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimedActiveCode: () => (/* binding */ TimedActiveCode),
/* harmony export */   TimedHTMLActiveCode: () => (/* binding */ TimedHTMLActiveCode),
/* harmony export */   TimedJSActiveCode: () => (/* binding */ TimedJSActiveCode),
/* harmony export */   TimedLiveCode: () => (/* binding */ TimedLiveCode),
/* harmony export */   TimedSQLActiveCode: () => (/* binding */ TimedSQLActiveCode)
/* harmony export */ });
/* harmony import */ var _livecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./livecode */ 45425);
/* harmony import */ var _activecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activecode */ 750);
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode_js */ 40653);
/* harmony import */ var _activecode_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode_html */ 15033);
/* harmony import */ var _activecode_sql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activecode_sql */ 23538);
/*
The TimedActivecode classes are a great example of where multiple inheritance would be useful
But since Javascript does not support multiple inheritance we use the mixin pattern.

*/






var TimedActiveCodeMixin = {
    timedInit: async function (opts) {
        this.isTimed = true;
        this.hideButtons();
        this.needsReinitialization = true; // the run button click listener needs to be reinitialized
        this.containerDiv.classList.add("timedComponent");
        window.componentMap[this.divid] = this;
        return true;
    },

    hideButtons: function () {
        var buttonList = [
            this.saveButton,
            this.loadButton,
            this.gradeButton,
            this.showHideButt,
            this.coachButton,
            this.atButton,
        ];
        for (var i = 0; i < buttonList.length; i++) {
            if (buttonList[i] !== undefined && buttonList[i] !== null)
                $(buttonList[i]).hide();
        }
    },

    // bje - not needed anymore
    renderTimedIcon: function (component) {
        // renders the clock icon on timed components.    The component parameter
        // is the element that the icon should be appended to.
        var timeIconDiv = document.createElement("div");
        var timeIcon = document.createElement("img");
        $(timeIcon).attr({
            src: "../_static/clock.png",
            style: "width:15px;height:15px",
        });
        timeIconDiv.className = "timeTip";
        timeIconDiv.title = "";
        timeIconDiv.appendChild(timeIcon);
        $(component).prepend(timeIconDiv);
    },

    checkCorrectTimed: function () {
        // pct_correct is set by the unittest/gui.py module in skulpt.
        // it relies on finding this object in the edList
        if (this.isAnswered) {
            if (this.pct_correct >= 100.0) {
                return "T";
            } else {
                return "F";
            }
        } else {
            return "I"; // we ignore this in the grading if no unittests
        }
    },

    hideFeedback: function () {
        $(this.output).css("visibility", "hidden");
    },

    reinitializeListeners: function (taken) {
        if (!this.runButton.onclick) {
            console.log("reattaching runbuttonhandler");
            this.runButton.onclick = this.runButtonHander.bind(this);
        }
        $(this.codeDiv).show();
        this.runButton.disabled = false;
        $(this.codeDiv).removeClass("ac-disabled");
        this.editor.refresh();
        if (this.historyScrubber !== null) {
            $(this.historyScrubber).slider({
                max: this.history.length - 1,
                value: this.history.length - 1,
                slide: this.slideit.bind(this),
                change: this.slideit.bind(this),
            });
        }
        if (taken) {
            $(`#${this.divid}_unit_results`).show();
        }
    },
};

class TimedLiveCode extends _livecode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}

Object.assign(TimedLiveCode.prototype, TimedActiveCodeMixin);

class TimedActiveCode extends _activecode__WEBPACK_IMPORTED_MODULE_1__.ActiveCode {
    constructor(opts) {
        super(opts);
        this.timedInitComplete = this.timedInit(opts);
    }

    // for timed exams we need to call runProg and tell it that there is
    // no GUI for sliders or other things.
    // the answers.
    async checkCurrentAnswer() {
        let noUI = true;
        const result = await this.timedInitComplete;
        if (this.isAnswered) {
            await this.runProg(noUI, false);
        }
    }
}

Object.assign(TimedActiveCode.prototype, TimedActiveCodeMixin);

class TimedJSActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedJSActiveCode.prototype, TimedActiveCodeMixin);

class TimedHTMLActiveCode extends _activecode_html__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedHTMLActiveCode.prototype, TimedActiveCodeMixin);

class TimedSQLActiveCode extends _activecode_sql__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedSQLActiveCode.prototype, TimedActiveCodeMixin);


/***/ }),

/***/ 33194:
/*!*************************************************!*\
  !*** ./runestone/common/js/jquery.highlight.js ***!
  \*************************************************/
/***/ (() => {

/*

highlight v4

Highlights arbitrary terms.

<http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html>

MIT license.

Johann Burkard
<http://johannburkard.de>
<mailto:jb@eaio.com>

*/

jQuery.fn.highlight = function(pat) {
 function innerHighlight(node, pat) {
  var skip = 0;
  if (node.nodeType == 3) {
   var pos = node.data.toUpperCase().indexOf(pat);
   if (pos >= 0) {
    var spannode = document.createElement('span');
    spannode.className = 'highlight';
    var middlebit = node.splitText(pos);
    var endbit = middlebit.splitText(pat.length);
    var middleclone = middlebit.cloneNode(true);
    spannode.appendChild(middleclone);
    middlebit.parentNode.replaceChild(spannode, middlebit);
    skip = 1;
   }
  }
  else if (node.nodeType == 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
   for (var i = 0; i < node.childNodes.length; ++i) {
    i += innerHighlight(node.childNodes[i], pat);
   }
  }
  return skip;
 }
 return this.length && pat && pat.length ? this.each(function() {
  innerHighlight(this, pat.toUpperCase());
 }) : this;
};

jQuery.fn.removeHighlight = function() {
 return this.find("span.highlight").each(function() {
  this.parentNode.firstChild.nodeName;
  with (this.parentNode) {
   replaceChild(this.firstChild, this);
   normalize();
  }
 }).end();
};


/***/ }),

/***/ 37607:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 70803:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 59547:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 16449:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 23516:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlZml4LW5vZGVfbW9kdWxlc19tb21lbnRfbG9jYWxlX3N5bmNfcmVjdXJzaXZlXy1ydW5lc3RvbmVfYWN0aXZlY29kZV9qc19hY2ZhY3RvcnlfanMtbm9kZV9tb2R1bGVzXy1lZjczYjMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0VBQWtFO0FBQ2xFLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ2xQRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlKQUF5SjtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7Ozs7Ozs7OztBQ3ZIRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7QUN0SEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWdEO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sR0FBRyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixZQUFZO0FBQzlGO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsbUJBQW1CLFFBQVEsTUFBTTtBQUNwRztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMERBQTBELG1CQUFtQixRQUFRLE1BQU07QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRjZDO0FBQ2xCO0FBQzJCO0FBQ0g7QUFDUjs7QUFFNUIsdUJBQXVCLHNEQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNW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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBbUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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YnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvY3NzL2FjdGl2ZWNvZGUubGVzcz8yNzU1Iiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS8gc3luYyBeXFwuXFwvLiokIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGUtaTE4bi5lbi5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZS1pMThuLnB0LWJyLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY3RpdmVjb2RlLWkxOG4uc3ItQ3lybC5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZS5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZV9odG1sLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY3RpdmVjb2RlX2pzLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY3RpdmVjb2RlX3NxbC5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYXVkaW90b3VyLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9jb2FjaC1weXRob24tcHlmbGFrZXMuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2V4dHJhY3RVbml0UmVzdWx0cy5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvbGl2ZWNvZGUuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL21kNS5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvc2t1bHB0LXN0ZGxpYi5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvc2t1bHB0Lm1pbi5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvdGltZWRfYWN0aXZlY29kZS5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2NvbW1vbi9qcy9qcXVlcnkuaGlnaGxpZ2h0LmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvVXNlcnMvd2FsdG9uZGIvRGV2ZWxvcGVyL1J1bmVzdG9uZS9ycy9iYXNlcy9yc3B0eC9pbnRlcmFjdGl2ZXMvbm9kZV9tb2R1bGVzL3NxbC5qcy9kaXN0fGNyeXB0byIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzL2lnbm9yZWR8L1VzZXJzL3dhbHRvbmRiL0RldmVsb3Blci9SdW5lc3RvbmUvcnMvYmFzZXMvcnNwdHgvaW50ZXJhY3RpdmVzL25vZGVfbW9kdWxlcy9zcWwuanMvZGlzdHxmcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzL2lnbm9yZWR8L1VzZXJzL3dhbHRvbmRiL0RldmVsb3Blci9SdW5lc3RvbmUvcnMvYmFzZXMvcnNwdHgvaW50ZXJhY3RpdmVzL25vZGVfbW9kdWxlcy9zcWwuanMvZGlzdHxwYXRoIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvVXNlcnMvd2FsdG9uZGIvRGV2ZWxvcGVyL1J1bmVzdG9uZS9ycy9iYXNlcy9yc3B0eC9pbnRlcmFjdGl2ZXMvbm9kZV9tb2R1bGVzL3ZlZ2EtbG9hZGVyL3NyY3xmcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzL2lnbm9yZWR8L1VzZXJzL3dhbHRvbmRiL0RldmVsb3Blci9SdW5lc3RvbmUvcnMvYmFzZXMvcnNwdHgvaW50ZXJhY3RpdmVzL25vZGVfbW9kdWxlcy92ZWdhLWxvYWRlci9zcmN8bm9kZS1mZXRjaCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vYWZcIjogNDI3ODYsXG5cdFwiLi9hZi5qc1wiOiA0Mjc4Nixcblx0XCIuL2FyXCI6IDMwODY3LFxuXHRcIi4vYXItZHpcIjogMTQxMzAsXG5cdFwiLi9hci1kei5qc1wiOiAxNDEzMCxcblx0XCIuL2FyLWt3XCI6IDk2MTM1LFxuXHRcIi4vYXIta3cuanNcIjogOTYxMzUsXG5cdFwiLi9hci1seVwiOiA1NjQ0MCxcblx0XCIuL2FyLWx5LmpzXCI6IDU2NDQwLFxuXHRcIi4vYXItbWFcIjogNDc3MDIsXG5cdFwiLi9hci1tYS5qc1wiOiA0NzcwMixcblx0XCIuL2FyLXNhXCI6IDE2MDQwLFxuXHRcIi4vYXItc2EuanNcIjogMTYwNDAsXG5cdFwiLi9hci10blwiOiAzNzEwMCxcblx0XCIuL2FyLXRuLmpzXCI6IDM3MTAwLFxuXHRcIi4vYXIuanNcIjogMzA4NjcsXG5cdFwiLi9helwiOiAzMTA4Myxcblx0XCIuL2F6LmpzXCI6IDMxMDgzLFxuXHRcIi4vYmVcIjogOTgwOCxcblx0XCIuL2JlLmpzXCI6IDk4MDgsXG5cdFwiLi9iZ1wiOiA2ODMzOCxcblx0XCIuL2JnLmpzXCI6IDY4MzM4LFxuXHRcIi4vYm1cIjogNjc0MzgsXG5cdFwiLi9ibS5qc1wiOiA2NzQzOCxcblx0XCIuL2JuXCI6IDg5MDUsXG5cdFwiLi9ibi5qc1wiOiA4OTA1LFxuXHRcIi4vYm9cIjogMTE1NjAsXG5cdFwiLi9iby5qc1wiOiAxMTU2MCxcblx0XCIuL2JyXCI6IDEyNzgsXG5cdFwiLi9ici5qc1wiOiAxMjc4LFxuXHRcIi4vYnNcIjogODA2MjIsXG5cdFwiLi9icy5qc1wiOiA4MDYyMixcblx0XCIuL2NhXCI6IDI0NjgsXG5cdFwiLi9jYS5qc1wiOiAyNDY4LFxuXHRcIi4vY3NcIjogNTgyMixcblx0XCIuL2NzLmpzXCI6IDU4MjIsXG5cdFwiLi9jdlwiOiA1MDg3Nyxcblx0XCIuL2N2LmpzXCI6IDUwODc3LFxuXHRcIi4vY3lcIjogNDczNzMsXG5cdFwiLi9jeS5qc1wiOiA0NzM3Myxcblx0XCIuL2RhXCI6IDI0NzgwLFxuXHRcIi4vZGEuanNcIjogMjQ3ODAsXG5cdFwiLi9kZVwiOiA1OTc0MCxcblx0XCIuL2RlLWF0XCI6IDYwMjE3LFxuXHRcIi4vZGUtYXQuanNcIjogNjAyMTcsXG5cdFwiLi9kZS1jaFwiOiA2MDg5NCxcblx0XCIuL2RlLWNoLmpzXCI6IDYwODk0LFxuXHRcIi4vZGUuanNcIjogNTk3NDAsXG5cdFwiLi9kdlwiOiA1MzAwLFxuXHRcIi4vZHYuanNcIjogNTMwMCxcblx0XCIuL2VsXCI6IDUwODM3LFxuXHRcIi4vZWwuanNcIjogNTA4MzcsXG5cdFwiLi9lbi1hdVwiOiA3ODM0OCxcblx0XCIuL2VuLWF1LmpzXCI6IDc4MzQ4LFxuXHRcIi4vZW4tY2FcIjogNzc5MjUsXG5cdFwiLi9lbi1jYS5qc1wiOiA3NzkyNSxcblx0XCIuL2VuLWdiXCI6IDIyMjQzLFxuXHRcIi4vZW4tZ2IuanNcIjogMjIyNDMsXG5cdFwiLi9lbi1pZVwiOiA0NjQzNixcblx0XCIuL2VuLWllLmpzXCI6IDQ2NDM2LFxuXHRcIi4vZW4tbnpcIjogNzYzMTksXG5cdFwiLi9lbi1uei5qc1wiOiA3NjMxOSxcblx0XCIuL2VvXCI6IDkyOTE1LFxuXHRcIi4vZW8uanNcIjogOTI5MTUsXG5cdFwiLi9lc1wiOiA1NTY1NSxcblx0XCIuL2VzLWRvXCI6IDU1MjUxLFxuXHRcIi4vZXMtZG8uanNcIjogNTUyNTEsXG5cdFwiLi9lcy11c1wiOiA3MTE0Nixcblx0XCIuL2VzLXVzLmpzXCI6IDcxMTQ2LFxuXHRcIi4vZXMuanNcIjogNTU2NTUsXG5cdFwiLi9ldFwiOiA1NjAzLFxuXHRcIi4vZXQuanNcIjogNTYwMyxcblx0XCIuL2V1XCI6IDc3NzYzLFxuXHRcIi4vZXUuanNcIjogNzc3NjMsXG5cdFwiLi9mYVwiOiA3Njk1OSxcblx0XCIuL2ZhLmpzXCI6IDc2OTU5LFxuXHRcIi4vZmlcIjogMTE4OTcsXG5cdFwiLi9maS5qc1wiOiAxMTg5Nyxcblx0XCIuL2ZvXCI6IDk0Njk0LFxuXHRcIi4vZm8uanNcIjogOTQ2OTQsXG5cdFwiLi9mclwiOiA5NDQ3MCxcblx0XCIuL2ZyLWNhXCI6IDYzMDQ5LFxuXHRcIi4vZnItY2EuanNcIjogNjMwNDksXG5cdFwiLi9mci1jaFwiOiA1MjMzMCxcblx0XCIuL2ZyLWNoLmpzXCI6IDUyMzMwLFxuXHRcIi4vZnIuanNcIjogOTQ0NzAsXG5cdFwiLi9meVwiOiA1MDQ0LFxuXHRcIi4vZnkuanNcIjogNTA0NCxcblx0XCIuL2dkXCI6IDIxMDEsXG5cdFwiLi9nZC5qc1wiOiAyMTAxLFxuXHRcIi4vZ2xcIjogMzg3OTQsXG5cdFwiLi9nbC5qc1wiOiAzODc5NCxcblx0XCIuL2dvbS1sYXRuXCI6IDIzMTY4LFxuXHRcIi4vZ29tLWxhdG4uanNcIjogMjMxNjgsXG5cdFwiLi9ndVwiOiA5NTM0OSxcblx0XCIuL2d1LmpzXCI6IDk1MzQ5LFxuXHRcIi4vaGVcIjogMjQyMDYsXG5cdFwiLi9oZS5qc1wiOiAyNDIwNixcblx0XCIuL2hpXCI6IDMwMDk0LFxuXHRcIi4vaGkuanNcIjogMzAwOTQsXG5cdFwiLi9oclwiOiAzMDMxNixcblx0XCIuL2hyLmpzXCI6IDMwMzE2LFxuXHRcIi4vaHVcIjogMjIxMzgsXG5cdFwiLi9odS5qc1wiOiAyMjEzOCxcblx0XCIuL2h5LWFtXCI6IDExNDIzLFxuXHRcIi4vaHktYW0uanNcIjogMTE0MjMsXG5cdFwiLi9pZFwiOiAyOTIxOCxcblx0XCIuL2lkLmpzXCI6IDI5MjE4LFxuXHRcIi4vaXNcIjogOTAxMzUsXG5cdFwiLi9pcy5qc1wiOiA5MDEzNSxcblx0XCIuL2l0XCI6IDkwNjI2LFxuXHRcIi4vaXQuanNcIjogOTA2MjYsXG5cdFwiLi9qYVwiOiAzOTE4Myxcblx0XCIuL2phLmpzXCI6IDM5MTgzLFxuXHRcIi4vanZcIjogMjQyODYsXG5cdFwiLi9qdi5qc1wiOiAyNDI4Nixcblx0XCIuL2thXCI6IDQwNDE1LFxuXHRcIi4va2EuanNcIjogNDA0MTUsXG5cdFwiLi9ra1wiOiA0Nzc3Mixcblx0XCIuL2trLmpzXCI6IDQ3NzcyLFxuXHRcIi4va21cIjogMTg3NTgsXG5cdFwiLi9rbS5qc1wiOiAxODc1OCxcblx0XCIuL2tuXCI6IDc5MjgyLFxuXHRcIi4va24uanNcIjogNzkyODIsXG5cdFwiLi9rb1wiOiAzMzczMCxcblx0XCIuL2tvLmpzXCI6IDMzNzMwLFxuXHRcIi4va3lcIjogMzMyOTEsXG5cdFwiLi9reS5qc1wiOiAzMzI5MSxcblx0XCIuL2xiXCI6IDM2ODQxLFxuXHRcIi4vbGIuanNcIjogMzY4NDEsXG5cdFwiLi9sb1wiOiA1NTQ2Nixcblx0XCIuL2xvLmpzXCI6IDU1NDY2LFxuXHRcIi4vbHRcIjogNTcwMTAsXG5cdFwiLi9sdC5qc1wiOiA1NzAxMCxcblx0XCIuL2x2XCI6IDM3NTk1LFxuXHRcIi4vbHYuanNcIjogMzc1OTUsXG5cdFwiLi9tZVwiOiAzOTg2MSxcblx0XCIuL21lLmpzXCI6IDM5ODYxLFxuXHRcIi4vbWlcIjogMzU0OTMsXG5cdFwiLi9taS5qc1wiOiAzNTQ5Myxcblx0XCIuL21rXCI6IDk1OTY2LFxuXHRcIi4vbWsuanNcIjogOTU5NjYsXG5cdFwiLi9tbFwiOiA4NzM0MSxcblx0XCIuL21sLmpzXCI6IDg3MzQxLFxuXHRcIi4vbXJcIjogMTAzNzAsXG5cdFwiLi9tci5qc1wiOiAxMDM3MCxcblx0XCIuL21zXCI6IDk4NDcsXG5cdFwiLi9tcy1teVwiOiA0MTIzNyxcblx0XCIuL21zLW15LmpzXCI6IDQxMjM3LFxuXHRcIi4vbXMuanNcIjogOTg0Nyxcblx0XCIuL210XCI6IDcyMTI2LFxuXHRcIi4vbXQuanNcIjogNzIxMjYsXG5cdFwiLi9teVwiOiA1NjE2NSxcblx0XCIuL215LmpzXCI6IDU2MTY1LFxuXHRcIi4vbmJcIjogNjQ5MjQsXG5cdFwiLi9uYi5qc1wiOiA2NDkyNCxcblx0XCIuL25lXCI6IDE2NzQ0LFxuXHRcIi4vbmUuanNcIjogMTY3NDQsXG5cdFwiLi9ubFwiOiA5MzkwMSxcblx0XCIuL25sLWJlXCI6IDU5ODE0LFxuXHRcIi4vbmwtYmUuanNcIjogNTk4MTQsXG5cdFwiLi9ubC5qc1wiOiA5MzkwMSxcblx0XCIuL25uXCI6IDgzODc3LFxuXHRcIi4vbm4uanNcIjogODM4NzcsXG5cdFwiLi9wYS1pblwiOiAxNTg1OCxcblx0XCIuL3BhLWluLmpzXCI6IDE1ODU4LFxuXHRcIi4vcGxcIjogNjQ0OTUsXG5cdFwiLi9wbC5qc1wiOiA2NDQ5NSxcblx0XCIuL3B0XCI6IDg5NTIwLFxuXHRcIi4vcHQtYnJcIjogNTc5NzEsXG5cdFwiLi9wdC1ici5qc1wiOiA1Nzk3MSxcblx0XCIuL3B0LmpzXCI6IDg5NTIwLFxuXHRcIi4vcm9cIjogOTY0NTksXG5cdFwiLi9yby5qc1wiOiA5NjQ1OSxcblx0XCIuL3J1XCI6IDIxNzkzLFxuXHRcIi4vcnUuanNcIjogMjE3OTMsXG5cdFwiLi9zZFwiOiA0MDk1MCxcblx0XCIuL3NkLmpzXCI6IDQwOTUwLFxuXHRcIi4vc2VcIjogMTA0OTAsXG5cdFwiLi9zZS5qc1wiOiAxMDQ5MCxcblx0XCIuL3NpXCI6IDkwMTI0LFxuXHRcIi4vc2kuanNcIjogOTAxMjQsXG5cdFwiLi9za1wiOiA2NDI0OSxcblx0XCIuL3NrLmpzXCI6IDY0MjQ5LFxuXHRcIi4vc2xcIjogMTQ5ODUsXG5cdFwiLi9zbC5qc1wiOiAxNDk4NSxcblx0XCIuL3NxXCI6IDUxMTA0LFxuXHRcIi4vc3EuanNcIjogNTExMDQsXG5cdFwiLi9zclwiOiA0OTEzMSxcblx0XCIuL3NyLWN5cmxcIjogMTM3MDksXG5cdFwiLi9zci1jeXJsLmpzXCI6IDEzNzA5LFxuXHRcIi4vc3IuanNcIjogNDkxMzEsXG5cdFwiLi9zc1wiOiA4NTg5Myxcblx0XCIuL3NzLmpzXCI6IDg1ODkzLFxuXHRcIi4vc3ZcIjogOTg3NjAsXG5cdFwiLi9zdi5qc1wiOiA5ODc2MCxcblx0XCIuL3N3XCI6IDkxMTcyLFxuXHRcIi4vc3cuanNcIjogOTExNzIsXG5cdFwiLi90YVwiOiAyNzMzMyxcblx0XCIuL3RhLmpzXCI6IDI3MzMzLFxuXHRcIi4vdGVcIjogMjMxMTAsXG5cdFwiLi90ZS5qc1wiOiAyMzExMCxcblx0XCIuL3RldFwiOiA1MjA5NSxcblx0XCIuL3RldC5qc1wiOiA1MjA5NSxcblx0XCIuL3RoXCI6IDkwNDEsXG5cdFwiLi90aC5qc1wiOiA5MDQxLFxuXHRcIi4vdGwtcGhcIjogNzU3NjgsXG5cdFwiLi90bC1waC5qc1wiOiA3NTc2OCxcblx0XCIuL3RsaFwiOiA4OTQ0NCxcblx0XCIuL3RsaC5qc1wiOiA4OTQ0NCxcblx0XCIuL3RyXCI6IDcyMzk3LFxuXHRcIi4vdHIuanNcIjogNzIzOTcsXG5cdFwiLi90emxcIjogMjgyNTQsXG5cdFwiLi90emwuanNcIjogMjgyNTQsXG5cdFwiLi90em1cIjogNTExMDYsXG5cdFwiLi90em0tbGF0blwiOiAzMDY5OSxcblx0XCIuL3R6bS1sYXRuLmpzXCI6IDMwNjk5LFxuXHRcIi4vdHptLmpzXCI6IDUxMTA2LFxuXHRcIi4vdWtcIjogNjc2OTEsXG5cdFwiLi91ay5qc1wiOiA2NzY5MSxcblx0XCIuL3VyXCI6IDEzNzk1LFxuXHRcIi4vdXIuanNcIjogMTM3OTUsXG5cdFwiLi91elwiOiA2NzkxLFxuXHRcIi4vdXotbGF0blwiOiA2MDU4OCxcblx0XCIuL3V6LWxhdG4uanNcIjogNjA1ODgsXG5cdFwiLi91ei5qc1wiOiA2NzkxLFxuXHRcIi4vdmlcIjogNjU2NjYsXG5cdFwiLi92aS5qc1wiOiA2NTY2Nixcblx0XCIuL3gtcHNldWRvXCI6IDE0Mzc4LFxuXHRcIi4veC1wc2V1ZG8uanNcIjogMTQzNzgsXG5cdFwiLi95b1wiOiA3NTgwNSxcblx0XCIuL3lvLmpzXCI6IDc1ODA1LFxuXHRcIi4vemgtY25cIjogODM4MzksXG5cdFwiLi96aC1jbi5qc1wiOiA4MzgzOSxcblx0XCIuL3poLWhrXCI6IDU1NzI2LFxuXHRcIi4vemgtaGsuanNcIjogNTU3MjYsXG5cdFwiLi96aC10d1wiOiA3NDE1Mixcblx0XCIuL3poLXR3LmpzXCI6IDc0MTUyXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gNDY3MDA7IiwiaW1wb3J0IHsgQWN0aXZlQ29kZSB9IGZyb20gXCIuL2FjdGl2ZWNvZGUuanNcIjtcbmltcG9ydCBKU0FjdGl2ZUNvZGUgZnJvbSBcIi4vYWN0aXZlY29kZV9qcy5qc1wiO1xuaW1wb3J0IEhUTUxBY3RpdmVDb2RlIGZyb20gXCIuL2FjdGl2ZWNvZGVfaHRtbC5qc1wiO1xuaW1wb3J0IFNRTEFjdGl2ZUNvZGUgZnJvbSBcIi4vYWN0aXZlY29kZV9zcWwuanNcIjtcbmltcG9ydCBMaXZlQ29kZSBmcm9tIFwiLi9saXZlY29kZS5qc1wiO1xuaW1wb3J0IHtcbiAgICBUaW1lZEFjdGl2ZUNvZGUsXG4gICAgVGltZWRMaXZlQ29kZSxcbiAgICBUaW1lZEpTQWN0aXZlQ29kZSxcbiAgICBUaW1lZEhUTUxBY3RpdmVDb2RlLFxuICAgIFRpbWVkU1FMQWN0aXZlQ29kZSxcbn0gZnJvbSBcIi4vdGltZWRfYWN0aXZlY29kZVwiO1xuaW1wb3J0IFwiLi4vLi4vY29tbW9uL2pzL2pxdWVyeS5oaWdobGlnaHQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUNGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mb28gPSBcImJhclwiO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlQWN0aXZlQ29kZShvcmlnLCBsYW5nLCBhZGRvcHRzKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgb3JpZzogb3JpZyxcbiAgICAgICAgICAgIHVzZVJ1bmVzdG9uZVNlcnZpY2VzOiBlQm9va0NvbmZpZy51c2VSdW5lc3RvbmVTZXJ2aWNlcyxcbiAgICAgICAgICAgIHB5dGhvbjM6IGVCb29rQ29uZmlnLnB5dGhvbjMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhZGRvcHRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhdHRybmFtZSBpbiBhZGRvcHRzKSB7XG4gICAgICAgICAgICAgICAgb3B0c1thdHRybmFtZV0gPSBhZGRvcHRzW2F0dHJuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYW5nID0gJChvcHRzLm9yaWcpLmZpbmQoXCJbZGF0YS1sYW5nXVwiKS5kYXRhKFwibGFuZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy50aW1lZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAobGFuZyA9PT0gXCJweXRob25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGltZWRBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBsYW5nID09PSBcImphdmFcIiB8fFxuICAgICAgICAgICAgICAgIGxhbmcgPT09IFwiY3BwXCIgfHxcbiAgICAgICAgICAgICAgICBsYW5nID09PSBcImNcIiB8fFxuICAgICAgICAgICAgICAgIGxhbmcgPT09IFwicHl0aG9uM1wiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRpbWVkTGl2ZUNvZGUob3B0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhbmcgPT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZEpTQWN0aXZlQ29kZShvcHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFuZyA9PT0gXCJodG1sbWl4ZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGltZWRIVE1MQWN0aXZlQ29kZShvcHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFuZyA9PT0gXCJzcWxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGltZWRTUUxBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRpbWVkQWN0aXZlQ29kZShvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYW5nID09PSBcImphdmFzY3JpcHRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSlNBY3RpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYW5nID09PSBcImh0bWxtaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIVE1MQWN0aXZlQ29kZShvcHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFuZyA9PT0gXCJzcWxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU1FMQWN0aXZlQ29kZShvcHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgW1wiamF2YVwiLCBcImNwcFwiLCBcImNcIiwgXCJweXRob24zXCIsIFwicHl0aG9uMlwiLCBcIm9jdGF2ZVwiXS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICBsYW5nXG4gICAgICAgICAgICAgICAgKSA+IC0xXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdmVDb2RlKG9wdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIHB5dGhvblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlQ29kZShvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHdlYjJweSBjb250cm9sbGVyKHMpXG4gICAgc3RhdGljIGFkZEFjdGl2ZUNvZGVUb0RpdihvdXRlcmRpdmlkLCBhY2RpdmlkLCBzaWQsIGluaXRpYWxjb2RlLCBsYW5ndWFnZSkge1xuICAgICAgICB2YXIgdGhlcHJlLCBuZXdhYztcbiAgICAgICAgdmFyIGFjZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYWNkaXZpZCk7XG4gICAgICAgICQoYWNkaXYpLmVtcHR5KCk7XG4gICAgICAgIHRoZXByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgdGhlcHJlW1wiZGF0YS1jb21wb25lbnRcIl0gPSBcImFjdGl2ZWNvZGVcIjtcbiAgICAgICAgdGhlcHJlLmlkID0gb3V0ZXJkaXZpZDtcbiAgICAgICAgJCh0aGVwcmUpLmRhdGEoXCJsYW5nXCIsIGxhbmd1YWdlKTtcbiAgICAgICAgJChhY2RpdikuYXBwZW5kKHRoZXByZSk7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgb3JpZzogdGhlcHJlLFxuICAgICAgICAgICAgdXNlUnVuZXN0b25lU2VydmljZXM6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhZGRvcHRzID0ge1xuICAgICAgICAgICAgc2lkOiBzaWQsXG4gICAgICAgICAgICBncmFkZXJhY3RpdmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIG5ld2FjID0gQUNGYWN0b3J5LmNyZWF0ZUFjdGl2ZUNvZGUodGhlcHJlLCBsYW5ndWFnZSwgYWRkb3B0cyk7XG4gICAgICAgIHZhciBzYXZlZGl2ID0gbmV3YWMuZGl2aWQ7XG4gICAgICAgIG5ld2FjLmRpdmlkID0gc2F2ZWRpdjtcbiAgICAgICAgbmV3YWMuZWRpdG9yLnNldFNpemUoNTAwLCAzMDApO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5ld2FjLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBY3RpdmVDb2RlRnJvbU9wdHMob3B0cykge1xuICAgICAgICByZXR1cm4gQUNGYWN0b3J5LmNyZWF0ZUFjdGl2ZUNvZGUob3B0cy5vcmlnLCBvcHRzLmxhbmcsIG9wdHMpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlU2NyYXRjaEFjdGl2ZWNvZGUoKSB7XG4gICAgICAgIC8qIHNldCB1cCB0aGUgc2NyYXRjaCBBY3RpdmVjb2RlIGVkaXRvciBpbiB0aGUgc2VhcmNoIG1lbnUgKi9cbiAgICAgICAgLy8gdXNlIHRoZSBVUkwgdG8gYXNzaWduIGEgZGl2aWQgLSBlYWNoIHBhZ2Ugc2hvdWxkIGhhdmUgYSB1bmlxdWUgQWN0aXZlY29kZSBibG9jayBpZC5cbiAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgVVJMIGJ1dCB0aGUgY291cnNlIGFuZCBwYWdlIG5hbWVcbiAgICAgICAgLy8gdG9kbzogIHRoaXMgY291bGQgcHJvYmFibHkgYmUgZWxpbWluYXRlZCBhbmQgc2ltcGx5IG1vdmVkIHRvIHRoZSB0ZW1wbGF0ZSBmaWxlXG5cbiAgICAgICAgaWYgKGVCb29rQ29uZmlnLmVuYWJsZVNjcmF0Y2hBQyA9PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBkaXZpZCA9IGVCb29rQ29uZmlnLmNvdXJzZSArIFwiX3NjcmF0Y2hfYWNcIjtcbiAgICAgICAgZGl2aWQgPSBkaXZpZC5yZXBsYWNlKC9bIy5dL2csIFwiXCIpOyAvLyBpbiBjYXNlIGJvb2sgdGl0bGUgaGFzIGNoYXJhY3RlcnMgdGhhdCB3aWxsIG1lc3MgdXAgb3VyIHNlbGVjdG9yc1xuICAgICAgICBlQm9va0NvbmZpZy5zY3JhdGNoRGl2ID0gZGl2aWQ7XG4gICAgICAgIGxldCBzdGRpbiA9IFwiXCI7XG4gICAgICAgIHZhciBsYW5nID0gZUJvb2tDb25maWcuYWNEZWZhdWx0TGFuZ3VhZ2VcbiAgICAgICAgICAgID8gZUJvb2tDb25maWcuYWNEZWZhdWx0TGFuZ3VhZ2VcbiAgICAgICAgICAgIDogXCJweXRob25cIjtcbiAgICAgICAgaWYgKGxhbmcgPT09IFwiamF2YVwiIHx8IGxhbmcgPT09IFwiY3BwXCIgfHwgbGFuZyA9PT0gXCJweXRob24zXCIpIHtcbiAgICAgICAgICAgIHN0ZGluID0gYGRhdGEtc3RkaW49XCJ0ZXh0IGZvciBzdGRpblwiYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYW5ndWFnZU5hbWVzID0ge1xuICAgICAgICAgICAgJ2NwcCc6ICdDKysnLFxuICAgICAgICAgICAgJ2MnOiAnQycsXG4gICAgICAgICAgICAnaHRtbCc6ICdIVE1MJyxcbiAgICAgICAgICAgICdodG1sbWl4ZWQnOiAnSFRNTCcsXG4gICAgICAgICAgICAnamF2YSc6ICdKYXZhJyxcbiAgICAgICAgICAgICdqYXZhc2NyaXB0JzogJ0phdmFTY3JpcHQnLFxuICAgICAgICAgICAgJ2pzJzonSmF2YVNjcmlwdCcsXG4gICAgICAgICAgICAnb2N0YXZlJzogJ09jdGF2ZScsXG4gICAgICAgICAgICAncHl0aG9uJzogJ1B5dGhvbicsXG4gICAgICAgICAgICAncHkyJzonUHl0aG9uIDInLFxuICAgICAgICAgICAgJ3B5dGhvbjInOiAnUHl0aG9uIDInLFxuICAgICAgICAgICAgJ3B5Myc6J1B5dGhvbiAzJyxcbiAgICAgICAgICAgICdweTNhbmFjb25kYSc6ICdQeXRob24gMyB3aXRoIEFuYWNvbmRhJyxcbiAgICAgICAgICAgICdweXRob24zJzogJ1B5dGhvbiAzJyxcbiAgICAgICAgICAgICdydWJ5JzogJ1J1YnknLFxuICAgICAgICAgICAgJ3NxbCc6ICdTUUwnLFxuICAgICAgICAgICAgJ3RzJzogJ1R5cGVTY3JpcHQnXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIEhUTUxcbiAgICAgICAgdmFyIGh0bWwgPSBgPGRpdiBjbGFzcz1cInB0eC1ydW5lc3RvbmUtY29udGFpbmVyXCI+PGRpdiBpZD1cImFjX21vZGFsXyR7ZGl2aWR9XCIgY2xhc3M9XCJtb2RhbCBmYWRlXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2cgc2NyYXRjaC1hYy1tb2RhbFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVwibW9kYWwtdGl0bGVcIj5TY3JhdGNoIEFjdGl2ZUNvZGUgKCR7bGFuZ3VhZ2VOYW1lc1tsYW5nLnRvTG93ZXJDYXNlKCldIHx8IGxhbmd9KTwvaDQ+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGRhdGEtY29tcG9uZW50PVwiYWN0aXZlY29kZVwiIGlkPSR7ZGl2aWR9PlxuICAgICAgICAgICAgICAgICAgPGRpdiBpZD0ke2RpdmlkfV9xdWVzdGlvbiBjbGFzcz1cImFjX3F1ZXN0aW9uXCI+PHA+VXNlIHRoaXMgYXJlYSBmb3Igd3JpdGluZyBjb2RlIG9yIHRha2luZyBub3Rlcy48L3A+PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgZGF0YS1jb2RlbGVucz1cInRydWVcIiBkYXRhLWxhbmc9XCIke2xhbmd9XCIgJHtzdGRpbn0+XG4gICAgICAgICAgICAgICAgICA8L3RleHRhcmVhPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgIHZhciBlbCA9ICQoaHRtbCk7XG4gICAgICAgICQoXCJib2R5XCIpLmFwcGVuZChlbCk7XG4gICAgICAgIGVsLm9uKFwic2hvd24uYnMubW9kYWxcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgbGFuZyBpc24ndCBpbiBkaWN0aW9uYXJ5IG9mIGtub3duIHByb2dyYW1taW5nIGxhbmd1YWdlc1xuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZU5hbWVzW2xhbmcudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICBhbGVydChgJHtsYW5nfSBpcyBhIGtub3duIGxhbmd1YWdlLiBQbGVhc2UgcmVwb3J0IHRoaXNgKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWwub24oXCJzaG93bi5icy5tb2RhbCBzaG93LmJzLm1vZGFsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgZS5Db2RlTWlycm9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBlLkNvZGVNaXJyb3IuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHRvZ2dsZVNjcmF0Y2hBY3RpdmVjb2RlKCkge1xuICAgICAgICBpZiAoIWVCb29rQ29uZmlnLmVuYWJsZVNjcmF0Y2hBQykgcmV0dXJuO1xuICAgICAgICB2YXIgZGl2aWQgPSBcImFjX21vZGFsX1wiICsgZUJvb2tDb25maWcuc2NyYXRjaERpdjtcbiAgICAgICAgdmFyIGRpdiA9ICQoXCIjXCIgKyBkaXZpZCk7XG4gICAgICAgICQoYCMke2VCb29rQ29uZmlnLnNjcmF0Y2hEaXZ9YCkucmVtb3ZlQ2xhc3MoXCJhY19zZWN0aW9uXCIpO1xuICAgICAgICBkaXYubW9kYWwoXCJ0b2dnbGVcIik7XG4gICAgfVxufVxuXG4vL1xuLy8gUGFnZSBJbml0aWFsaXphdGlvblxuLy9cblxuJChkb2N1bWVudCkub24oXCJydW5lc3RvbmU6bG9naW4tY29tcGxldGVcIiwgZnVuY3Rpb24gKCkge1xuICAgIEFDRmFjdG9yeS5jcmVhdGVTY3JhdGNoQWN0aXZlY29kZSgpO1xuICAgICQoXCJbZGF0YS1jb21wb25lbnQ9YWN0aXZlY29kZV1cIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgkKHRoaXMpLmNsb3Nlc3QoXCJbZGF0YS1jb21wb25lbnQ9dGltZWRBc3Nlc3NtZW50XVwiKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGV4aXN0cyB3aXRoaW4gYSB0aW1lZCBjb21wb25lbnQsIGRvbid0IHJlbmRlciBpdCBoZXJlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb21wb25lbnRNYXBbdGhpcy5pZF0gPSBBQ0ZhY3RvcnkuY3JlYXRlQWN0aXZlQ29kZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5maW5kKFwidGV4dGFyZWFcIikuZGF0YShcImxhbmdcIilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIHJlbmRlcmluZyBBY3RpdmVjb2RlIFByb2JsZW0gJHt0aGlzLmlkfVxuICAgICAgICAgICAgICAgIERldGFpbHM6ICR7ZXJyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gVGhlIGNvbXBvbmVudE1hcCBjYW4gaGF2ZSBhbnkgY29tcG9uZW50LCBub3QgYWxsIG9mIHRoZW0gaGF2ZSBhIGRpc2FibGVTYXZlTG9hZFxuICAgIC8vIG1ldGhvZCBvciBhbiBlbmFibGVTYXZlTG9hZCBtZXRob2QuICBTbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGF0IGJlZm9yZSBjYWxsaW5nIGl0LlxuICAgIGlmIChsb2dnZWRvdXQpIHtcbiAgICAgICAgZm9yIChsZXQgayBpbiB3aW5kb3cuY29tcG9uZW50TWFwKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbXBvbmVudE1hcFtrXS5kaXNhYmxlU2F2ZUxvYWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29tcG9uZW50TWFwW2tdLmRpc2FibGVTYXZlTG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgayBpbiB3aW5kb3cuY29tcG9uZW50TWFwKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbXBvbmVudE1hcFtrXS5lbmFibGVTYXZlTG9hZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb21wb25lbnRNYXBba10uZW5hYmxlU2F2ZUxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5pZiAodHlwZW9mIHdpbmRvdy5jb21wb25lbnRfZmFjdG9yeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5jb21wb25lbnRfZmFjdG9yeSA9IHt9O1xufVxuXG53aW5kb3cuY29tcG9uZW50X2ZhY3RvcnkuYWN0aXZlY29kZSA9IEFDRmFjdG9yeS5jcmVhdGVBY3RpdmVDb2RlRnJvbU9wdHM7XG5cbi8vIFRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IHRvIGV4cG9zZSB0aGlzIG91dHNpZGUgdGhlIG1vZHVsZS5cbndpbmRvdy5BQ0ZhY3RvcnkgPSBBQ0ZhY3Rvcnk7XG5cbi8vIFRoaXMgc2VlbXMgYSBiaXQgaGFja3kgYW5kIHBvc3NpYmx5IGJyaXR0bGUsIGJ1dCBpdHMgaGFyZCB0byBrbm93IGhvdyBsb25nIGl0IHdpbGwgdGFrZSB0b1xuLy8gZmlndXJlIG91dCB0aGUgbG9naW4vbG9nb3V0IHN0YXR1cyBvZiB0aGUgdXNlci4gIFNvbWV0aW1lcyBpdHMgaW1tZWRpYXRlLCBhbmQgc29tZXRpbWVzIGl0c1xuLy8gbG9uZy4gIFNvIHRvIGJlIHNhZmUgd2UnbGwgZG8gaXQgYm90aCB3YXlzLi5cbnZhciBsb2dnZWRvdXQ7XG4kKGRvY3VtZW50KS5vbihcInJ1bmVzdG9uZTpsb2dvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGxvZ2dlZG91dCA9IHRydWU7XG59KTtcbiQoZG9jdW1lbnQpLm9uKFwicnVuZXN0b25lOmxvZ291dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yIChsZXQgayBpbiB3aW5kb3cuY29tcG9uZW50TWFwKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHdpbmRvdy5jb21wb25lbnRNYXAuaGFzT3duUHJvcGVydHkoaykgJiZcbiAgICAgICAgICAgIHdpbmRvdy5jb21wb25lbnRNYXAuYXR0cmlidXRlc1tcImRhdGEtY29tcG9uZW50XCJdID09IFwiYWN0aXZlY29kZVwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgd2luZG93LmNvbXBvbmVudE1hcFtrXS5kaXNhYmxlU2F2ZUxvYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiJC5pMThuKCkubG9hZCh7XG4gICAgZW46IHtcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9oaXN0b3J5OiBcIkxvYWQgSGlzdG9yeVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdWRpb190b3VyOiBcIkF1ZGlvIFRvdXJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZGVkX2NvZGU6IFwiTG9hZGVkIHlvdXIgc2F2ZWQgY29kZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fc2F2ZWRfY29kZTogXCJObyBzYXZlZCBjb2RlLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ydW5fY29kZTogXCJSdW5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19mZWVkYmFjazogXCJTaG93IEZlZWRiYWNrXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZTogXCJTaG93IENvZGVcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaGlkZV9jb2RlOiBcIkhpZGUgQ29kZVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2NvZGVsZW5zOiBcIlNob3cgQ29kZUxlbnNcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19pbl9jb2RlbGVuczogXCJTaG93IGluIENvZGVMZW5zXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2hpZGVfY29kZWxlbnM6IFwiSGlkZSBDb2RlbGVuc1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yZWZvcm1hdDogXCJSZWZvcm1hdFwiLFxuXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BhcnNlX2Vycm9yOlxuICAgICAgICAgICAgXCJBIHBhcnNlIGVycm9yIG1lYW5zIHRoYXQgUHl0aG9uIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhlIHN5bnRheCBvbiB0aGUgbGluZSB0aGUgZXJyb3IgbWVzc2FnZSBwb2ludHMgb3V0LiBDb21tb24gZXhhbXBsZXMgYXJlIGZvcmdldHRpbmcgY29tbWFzIGJldGV3ZWVuIGFyZ3VtZW50cyBvciBmb3JnZXR0aW5nIGEgOiBvbiBhIGZvciBzdGF0ZW1lbnRcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGFyc2VfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJUbyBmaXggYSBwYXJzZSBlcnJvciB5b3UganVzdCBuZWVkIHRvIGxvb2sgY2FyZWZ1bGx5IGF0IHRoZSBsaW5lIHdpdGggdGhlIGVycm9yIGFuZCBwb3NzaWJseSB0aGUgbGluZSBiZWZvcmUgaXQuICBNYWtlIHN1cmUgaXQgY29uZm9ybXMgdG8gYWxsIG9mIFB5dGhvbidzIHJ1bGVzLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90eXBlX2Vycm9yOlxuICAgICAgICAgICAgXCJUeXBlIGVycm9ycyBtb3N0IG9mdGVuIG9jY3VyIHdoZW4gYW4gZXhwcmVzc2lvbiB0cmllcyB0byBjb21iaW5lIHR3byBvYmplY3RzIHdpdGggdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbWJpbmVkLiAgTGlrZSByYWlzaW5nIGEgc3RyaW5nIHRvIGEgcG93ZXJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlRvIGZpeCBhIHR5cGUgZXJyb3IgeW91IHdpbGwgbW9zdCBsaWtlbHkgbmVlZCB0byB0cmFjZSB0aHJvdWdoIHlvdXIgY29kZSBhbmQgbWFrZSBzdXJlIHRoZSB2YXJpYWJsZXMgaGF2ZSB0aGUgdHlwZXMgeW91IGV4cGVjdCB0aGVtIHRvIGhhdmUuICBJdCBtYXkgYmUgaGVscGZ1bCB0byBwcmludCBvdXQgZWFjaCB2YXJpYWJsZSBhbG9uZyB0aGUgd2F5IHRvIGJlIHN1cmUgaXRzIHZhbHVlIGlzIHdoYXQgeW91IHRoaW5rIGl0IHNob3VsZCBiZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcjpcbiAgICAgICAgICAgIFwiQSBuYW1lIGVycm9yIGFsbW9zdCBhbHdheXMgbWVhbnMgdGhhdCB5b3UgaGF2ZSB1c2VkIGEgdmFyaWFibGUgYmVmb3JlIGl0IGhhcyBhIHZhbHVlLiAgT2Z0ZW4gdGhpcyBtYXkgYmUgYSBzaW1wbGUgdHlwbywgc28gY2hlY2sgdGhlIHNwZWxsaW5nIGNhcmVmdWxseS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZWNrIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgYXNzaWdubWVudCBzdGF0ZW1lbnRzIGFuZCB5b3VyIGZ1bmN0aW9uIGNhbGxzLCB0aGlzIGlzIHRoZSBtb3N0IGxpa2VseSBwbGFjZSBmb3IgYSBOYW1lRXJyb3IgdG8gYmUgZm91bmQuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3ZhbHVlX2Vycm9yOlxuICAgICAgICAgICAgXCJBIFZhbHVlRXJyb3IgbW9zdCBvZnRlbiBvY2N1cnMgd2hlbiB5b3UgcGFzcyBhIHBhcmFtZXRlciB0byBhIGZ1bmN0aW9uIGFuZCB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0aW5nIG9uZSB0eXBlIGFuZCB5b3UgcGFzcyBhbm90aGVyLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlRoZSBlcnJvciBtZXNzYWdlIGdpdmVzIHlvdSBhIHByZXR0eSBnb29kIGhpbnQgYWJvdXQgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGFzIHdlbGwgYXMgdGhlIHZhbHVlIHRoYXQgaXMgaW5jb3JyZWN0LiBMb29rIGF0IHRoZSBlcnJvciBtZXNzYWdlIGNsb3NlbHkgYW5kIHRoZW4gdHJhY2UgYmFjayB0byB0aGUgdmFyaWFibGUgY29udGFpbmluZyB0aGUgcHJvYmxlbWF0aWMgdmFsdWUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvcjpcbiAgICAgICAgICAgIFwiVGhpcyBlcnJvciBtZXNzYWdlIGlzIHRlbGxpbmcgeW91IHRoYXQgdGhlIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGRvdCwgZG9lcyBub3QgaGF2ZSB0aGUgYXR0cmlidXRlIG9yIG1ldGhvZCBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdHRyaWJ1dGVfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJUaGUgbW9zdCBjb21tb24gdmFyaWFudCBvZiB0aGlzIG1lc3NhZ2UgaXMgdGhhdCB0aGUgb2JqZWN0IHVuZGVmaW5lZCBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZSBYLiAgVGhpcyB0ZWxscyB5b3UgdGhhdCB0aGUgb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgZG90IGlzIG5vdCB3aGF0IHlvdSB0aGluay4gVHJhY2UgdGhlIHZhcmlhYmxlIGJhY2sgYW5kIHByaW50IGl0IG91dCBpbiB2YXJpb3VzIHBsYWNlcyB1bnRpbCB5b3UgZGlzY292ZXIgd2hlcmUgaXQgYmVjb21lcyB1bmRlZmluZWQuICBPdGhlcndpc2UgY2hlY2sgdGhlIGF0dHJpYnV0ZSBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBkb3QgZm9yIGEgdHlwby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdG9rZW5fZXJyb3I6XG4gICAgICAgICAgICBcIk1vc3Qgb2YgdGhlIHRpbWUgdGhpcyBlcnJvciBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBmb3Jnb3R0ZW4gYSByaWdodCBwYXJlbnRoZXNpcyBvciBoYXZlIGZvcmdvdHRlbiB0byBjbG9zZSBhIHBhaXIgb2YgcXVvdGVzLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZWNrIGVhY2ggbGluZSBvZiB5b3VyIHByb2dyYW0gYW5kIG1ha2Ugc3VyZSB0aGF0IHlvdXIgcGFyZW50aGVzaXMgYXJlIGJhbGFuY2VkLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90aW1lX2xpbWl0X2Vycm9yOlxuICAgICAgICAgICAgXCJZb3VyIHByb2dyYW0gaXMgcnVubmluZyB0b28gbG9uZy4gIE1vc3QgcHJvZ3JhbXMgaW4gdGhpcyBib29rIHNob3VsZCBydW4gaW4gbGVzcyB0aGFuIDEwIHNlY29uZHMgZWFzaWx5LiBUaGlzIHByb2JhYmx5IGluZGljYXRlcyB5b3VyIHByb2dyYW0gaXMgaW4gYW4gaW5maW5pdGUgbG9vcC5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkFkZCBzb21lIHByaW50IHN0YXRlbWVudHMgdG8gZmlndXJlIG91dCBpZiB5b3VyIHByb2dyYW0gaXMgaW4gYW4gaW5maW50ZSBsb29wLiAgSWYgaXQgaXMgbm90IHlvdSBjYW4gaW5jcmVhc2UgdGhlIHJ1biB0aW1lIHdpdGggc3lzLnNldEV4ZWN1dGlvbkxpbWl0KG1zZWNzKVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yOlxuICAgICAgICAgICAgXCJZb3VyIHByb2dyYW0gaXMgcnVubmluZyBmb3IgdG9vIGxvbmcuICBNb3N0IHByb2dyYW1zIGluIHRoaXMgYm9vayBzaG91bGQgcnVuIGluIGxlc3MgdGhhbiAzMCBzZWNvbmRzIGVhc2lseS4gVGhpcyBwcm9iYWJseSBpbmRpY2F0ZXMgeW91ciBwcm9ncmFtIGlzIGluIGFuIGluZmluaXRlIGxvb3AuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2dlbmVyYWxfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJBZGQgc29tZSBwcmludCBzdGF0ZW1lbnRzIHRvIGZpZ3VyZSBvdXQgaWYgeW91ciBwcm9ncmFtIGlzIGluIGFuIGluZmludGUgbG9vcC4gIElmIGl0IGlzIG5vdCB5b3UgY2FuIGluY3JlYXNlIHRoZSBydW4gdGltZSB3aXRoIHN5cy5zZXRFeGVjdXRpb25MaW1pdChtc2VjcylcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc3ludGF4X2Vycm9yOlxuICAgICAgICAgICAgXCJUaGlzIG1lc3NhZ2UgaW5kaWNhdGVzIHRoYXQgUHl0aG9uIGNhbid0IGZpZ3VyZSBvdXQgdGhlIHN5bnRheCBvZiBhIHBhcnRpY3VsYXIgc3RhdGVtZW50LiAgU29tZSBleGFtcGxlcyBhcmUgYXNzaWduaW5nIHRvIGEgbGl0ZXJhbCwgb3IgYSBmdW5jdGlvbiBjYWxsXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N5bnRheF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZWNrIHlvdXIgYXNzaWdubWVudCBzdGF0ZW1lbnRzIGFuZCBtYWtlIHN1cmUgdGhhdCB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFzc2lnbm1lbnQgaXMgYSB2YXJpYWJsZSwgbm90IGEgbGl0ZXJhbCBvciBhIGZ1bmN0aW9uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9rZXlfZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgbWVzc2FnZSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3MgYW4gZWxlbWVudCBvZiBhIGRpY3Rpb25hcnksIGJ1dCB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBoYXZlIHRoYXQgdGhlIGtleSB5b3UgYXJlIHVzaW5nLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9rZXlfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJZb3UgbWF5IGhhdmUgYSB0eXBvIGluIHRoZSBuYW1lIG9mIHlvdXIga2V5LiAgSXQgaXMgYWxzbyBnb29kIHByYWN0aWNlIHRvIGNoZWNrIGlmIHRoZSBrZXkgZXhpc3RzIHVzaW5nIGEgc3RhdGVtZW50IGxpa2UgaWYga2V5IGluIG15ZGljdC4gIFlvdSBjYW4gYWxzbyB1c2UgbXlkaWN0LmdldChrZXksZGVmYXVsdHZhbHVlKSBzbyB0aGF0IGlmIHRoZSBrZXkgaXMgbm90IGluIHRoZSBkaWN0aW9uYXJ5IHlvdSBnZXQgdGhlIGRlZmF1bHQgdmFsdWUgaW5zdGVhZCBvZiBhbiBlcnJvci5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZXhfZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgbWVzc2FnZSBtZWFucyB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGluZGV4IHBhc3QgdGhlIGVuZCBvZiBhIHN0cmluZyBvciBhIGxpc3QuICBGb3IgZXhhbXBsZSBpZiB5b3VyIGxpc3QgaGFzIDMgdGhpbmdzIGluIGl0IGFuZCB5b3UgdHJ5IHRvIGFjY2VzcyB0aGUgaXRlbSBhdCBwb3NpdGlvbiAzIG9yIG1vcmUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2luZGV4X2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiUmVtZW1iZXIgdGhhdCB0aGUgZmlyc3QgaXRlbSBpbiBhIGxpc3Qgb3Igc3RyaW5nIGlzIGF0IGluZGV4IHBvc2l0aW9uIDAsIHF1aXRlIG9mdGVuIHRoaXMgbWVzc2FnZSBjb21lcyBhYm91dCBiZWNhdXNlIHlvdSBhcmUgb2ZmIGJ5IG9uZS4gIFJlbWVtYmVyIGluIGEgbGlzdCBvZiBsZW5ndGggMyB0aGUgbGFzdCBsZWdhbCBpbmRleCBpcyAyXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3VyaV9lcnJvcjogXCJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yX2ZpeDogXCJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yOlxuICAgICAgICAgICAgXCJUaGlzIGVycm9yIG1lc3NhZ2UgaW5kaWNhdGVzIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gaW1wb3J0IGEgbW9kdWxlIHRoYXQgZG9lcyBub3QgZXhpc3RcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiT25lIHByb2JsZW0gbWF5IHNpbXBseSBiZSB0aGF0IHlvdSBoYXZlIGEgdHlwby4gIEl0IG1heSBhbHNvIGJlIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gaW1wb3J0IGEgbW9kdWxlIHRoYXQgZXhpc3RzIGluICdyZWFsJyBQeXRob24sIGJ1dCBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGJvb2suICBJZiB0aGlzIGlzIHRoZSBjYXNlLCBwbGVhc2Ugc3VibWl0IGEgZmVhdHVyZSByZXF1ZXN0IHRvIGhhdmUgdGhlIG1vZHVsZSBhZGRlZC5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yOlxuICAgICAgICAgICAgXCJUaGlzIGlzIG1vc3QgbGlrZWx5IGFuIGludGVybmFsIGVycm9yLCBwYXJ0aWN1bGFybHkgaWYgdGhlIG1lc3NhZ2UgcmVmZXJlbmNlcyB0aGUgY29uc29sZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiVHJ5IHJlZnJlc2hpbmcgdGhlIHdlYnBhZ2UsIGFuZCBpZiB0aGUgZXJyb3IgY29udGludWVzLCBzdWJtaXQgYSBidWcgcmVwb3J0IGFsb25nIHdpdGggeW91ciBjb2RlXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3plcm9fZGl2aXNpb25fZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgdGVsbHMgeW91IHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gZGl2aWRlIGJ5IDAuIFR5cGljYWxseSB0aGlzIGlzIGJlY2F1c2UgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBpbiB0aGUgZGVub21pbmF0b3Igb2YgYSBkaXZpc2lvbiBleHByZXNzaW9uIGhhcyB0aGUgdmFsdWUgMFwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV96ZXJvX2RpdmlzaW9uX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiWW91IG1heSBuZWVkIHRvIHByb3RlY3QgYWdhaW5zdCBkaXZpZGluZyBieSAwIHdpdGggYW4gaWYgc3RhdG1lbnQsIG9yIHlvdSBtYXkgbmVlZCB0byByZXhhbWluZSB5b3VyIGFzc3VtcHRpb25zIGFib3V0IHRoZSBsZWdhbCB2YWx1ZXMgb2YgdmFyaWFibGVzLCBpdCBjb3VsZCBiZSBhbiBlYXJsaWVyIHN0YXRtZW50IHRoYXQgaXMgdW5leHBlY3RlZGx5IGFzc2lnbmluZyBhIHZhbHVlIG9mIHplcm8gdG8gdGhlIHZhcmlhYmxlIGluIHF1ZXN0aW9uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcjpcbiAgICAgICAgICAgIFwiVGhpcyBtZXNzYWdlIGFsbW9zdCBhbHdheXMgc2hvd3MgdXAgaW4gdGhlIGZvcm0gb2YgTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JhbmdlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiVGhpcyBhbHdheXMgb2NjdXJzIHdoZW4gYSBmdW5jdGlvbiBjYWxscyBpdHNlbGYuICBJdHMgcHJldHR5IGxpa2VseSB0aGF0IHlvdSBhcmUgbm90IGRvaW5nIHRoaXMgb24gcHVycG9zZS4gRXhjZXB0IGluIHRoZSBjaGFwdGVyIG9uIHJlY3Vyc2lvbi4gIElmIHlvdSBhcmUgaW4gdGhhdCBjaGFwdGVyIHRoZW4gaXRzIGxpa2VseSB5b3UgaGF2ZW4ndCBpZGVudGlmaWVkIGEgZ29vZCBiYXNlIGNhc2UuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ludGVybmFsX2Vycm9yOlxuICAgICAgICAgICAgXCJBbiBJbnRlcm5hbCBlcnJvciBtYXkgbWVhbiB0aGF0IHlvdSd2ZSB0cmlnZ2VyZWQgYSBidWcgaW4gb3VyIFB5dGhvblwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlJlcG9ydCB0aGlzIGVycm9yLCBhbG9uZyB3aXRoIHlvdXIgY29kZSBhcyBhIGJ1Zy5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZW50YXRpb25fZXJyb3I6XG4gICAgICAgICAgICBcIlRoaXMgZXJyb3Igb2NjdXJzIHdoZW4geW91IGhhdmUgbm90IGluZGVudGVkIHlvdXIgY29kZSBwcm9wZXJseS4gIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGFzIHBhcnQgb2YgYW4gaWYsIGZvciwgd2hpbGUgb3IgZGVmIHN0YXRlbWVudC5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZW50YXRpb25fZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJDaGVjayB5b3VyIGlmLCBkZWYsIGZvciwgYW5kIHdoaWxlIHN0YXRlbWVudHMgdG8gYmUgc3VyZSB0aGUgbGluZXMgYXJlIHByb3Blcmx5IGluZGVudGVkIGJlbmVhdGggdGhlbS4gIEFub3RoZXIgc291cmNlIG9mIHRoaXMgZXJyb3IgY29tZXMgZnJvbSBjb3B5aW5nIGFuZCBwYXN0aW5nIGNvZGUgd2hlcmUgeW91IGhhdmUgYWNjaWRlbnRhbGx5IGxlZnQgc29tZSBiaXRzIG9mIGNvZGUgbHlpbmcgYXJvdW5kIHRoYXQgZG9uJ3QgYmVsb25nIHRoZXJlIGFueW1vcmUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25vdF9pbXBsZW1lbnRlZF9lcnJvcjpcbiAgICAgICAgICAgIFwiVGhpcyBlcnJvciBvY2N1cnMgd2hlbiB5b3UgdHJ5IHRvIHVzZSBhIGJ1aWx0aW4gZnVuY3Rpb24gb2YgUHl0aG9uIHRoYXQgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGluIHRoaXMgaW4tYnJvd3NlciB2ZXJzaW9uIG9mIFB5dGhvbi5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm90X2ltcGxlbWVudGVkX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiRm9yIG5vdyB0aGUgb25seSB3YXkgdG8gZml4IHRoaXMgaXMgdG8gbm90IHVzZSB0aGUgZnVuY3Rpb24uICBUaGVyZSBtYXkgYmUgd29ya2Fyb3VuZHMuICBJZiB5b3UgcmVhbGx5IG5lZWQgdGhpcyBidWlsdGluIGZ1bmN0aW9uIHRoZW4gZmlsZSBhIGJ1ZyByZXBvcnQgYW5kIHRlbGwgdXMgaG93IHlvdSBhcmUgdHJ5aW5nIHRvIHVzZSB0aGUgZnVuY3Rpb24uXCIsXG5cbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfZmlsZV9ub3RfZm91bmQ6IFwiRmlsZSBub3QgZm91bmQ6ICckMSdcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fZmlsZV9vcl9kaXI6XG4gICAgICAgICAgICBcIltFcnJubyAyXSBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5OiAnJDEnXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N0YXJ0aW5nOiBcIkNsaWNrIHRoZSBwbGF5IGJ1dHRvbiB0byBiZWdpbiB0aGUgJDFcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGxheWluZzogXCJQbGF5aW5nIHRoZSAkMVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkaW5nX2F1ZGlvOlxuICAgICAgICAgICAgXCJMb2FkaW5nIGF1ZGlvLiAgUGxlYXNlIHdhaXQuICAgSWYgdGhlIHRvdXIgZG9lc24ndCBzdGFydCBzb29uIGNsaWNrIG9uIHRoZSBsZWZ0bW9zdCBjb250cm9sIGJ1dHRvbiAoUGxheSBmaXJzdCBhdWRpbyBpbiB0b3VyKVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXVzZV9jdXJyZW50X2F1ZGlvOiBcIlBhdXNlIGN1cnJlbnQgYXVkaW9cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGF1c2VfYXVkaW86IFwiUGF1c2UgYXVkaW9cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGxheV9wYXVzZWRfYXVkaW86IFwiUGxheSBwYXVzZWQgYXVkaW9cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fcGF1c2VkOlxuICAgICAgICAgICAgXCJUaGUgJDEgaGFzIGJlZW4gcGF1c2VkLiBDbGljayBvbiB0aGUgcGxheSBidXR0b24gdG8gcmVzdW1lIHRoZSB0b3VyLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnB1dF9wcmc6IFwiSW5wdXQgZm9yIFByb2dyYW1cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfd2VyZV9jb21waWxpbmdfZXJyOlxuICAgICAgICAgICAgXCJUaGVyZSB3ZXJlIGVycm9ycyBjb21waWxpbmcgeW91ciBjb2RlLiBTZWUgYmVsb3cuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXhjOiBcIlRpbWUgTGltaXQgRXhjZWVkZWQgb24geW91ciBwcm9ncmFtXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3NlcnZlcl9lcnI6IFwiQSBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWRcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfY29tcGlsaW5nX3J1bm5pbmc6XG4gICAgICAgICAgICBcIkNvbXBpbGluZyBhbmQgUnVubmluZyB5b3VyIENvZGUgTm93Li4uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3NlcnZlcl9jb21tX2VycjogXCJFcnJvciBjb21tdW5pY2F0aW5nIHdpdGggdGhlIHNlcnZlci5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2F2ZV9ydW46IFwiU2F2ZSAmIFJ1blwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yZW5kZXI6IFwiU2F2ZSAmIFJlbmRlclwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hc3NlcnRpb25fZXJyb3I6XG4gICAgICAgICAgICBcIkFuIGFzc2VydGlvbiBlcnJvciBoYXBwZW5zIHdoZW4gcHl0aG9uIGVuY291bnRlcnMgYW4gYXNzZXJ0aW9uIHN0YXRlbWVudC4gIFB5dGhvbiBldmFsdWF0ZXMgdGhlIGV4cHJlc3Npb24gdG8gdGhlIHJpZ2h0IG9mIHRoZSB3b3JkIGFzc2VydDsgaWYgdGhhdCBleHByZXNzaW9uIGlzIFRydWUgZXZlcnl0aGluZyBpcyBmaW5lIGFuZCB0aGUgcHJvZ3JhbSBjb250aW51ZXMuICBJZiB0aGUgZXhwcmVzc2lvbiBpcyBGYWxzZSBQeXRob24gcmFpc2VzIGFuIGVycm9yIGFuZCBzdG9wcy5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXNzZXJ0aW9uX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiQ2hlY2sgdGhlIGV4cHJlc3Npb24gdG8gdGhlIHJpZ2h0IG9mIGFzc2VydC4gIFRoZSBleHByZXNzaW9uIGlzIEZhbHNlIGFuZCB5b3Ugd2lsbCBuZWVkIHRvIGRldGVybWluZSB3aHkgdGhhdCBpcy4gIFlvdSBtYXkgd2FudCB0byBzaW1wbHkgcHJpbnQgb3V0IHRoZSBpbmRpdmlkdWFsIHBhcnRzIG9mIHRoZSBleHByZXNzaW9uIHRvIHVuZGVyc3RhbmQgd2h5IGl0IGlzIGV2YWx1YXRpbmcgdG8gRmFsc2UuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRfZGI6IFwiTG9hZGluZyBEQi4uLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9jb2RlX2NvYWNoOiBcIkNvZGUgQ29hY2hcIixcbiAgICB9LFxufSk7XG4iLCIkLmkxOG4oKS5sb2FkKHtcbiAgICBcInB0LWJyXCI6IHtcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9oaXN0b3J5OiBcIkNhcnJlZ2FyIGhpc3TDs3JpY29cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fdG91cjogXCJUb3VyIGRlIMOhdWRpb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkZWRfY29kZTogXCJDw7NkaWdvIHNhbHZvIGNhcnJlZ2Fkby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fc2F2ZWRfY29kZTogXCJOw6NvIGjDoSBjw7NkaWdvIHNhbHZvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ydW5fY29kZTogXCJFeGVjdXRhclwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2ZlZWRiYWNrOiBcIkV4aWJpciBGZWVkYmFja3NcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlOiBcIk1vc3RyYXIgQ8OzZGlnb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGU6IFwiT2N1bHRhciBDw7NkaWdvXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZWxlbnM6IFwiTW9zdHJhciBDb2RlTGVuc1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2luX2NvZGVsZW5zOiBcIk1vc3RyYXIgZW0gQ29kZUxlbnNcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaGlkZV9jb2RlbGVuczogXCJPY3VsdGFyIENvZGVsZW5zXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JlZm9ybWF0OiBcIlJlZm9ybWF0YXJcIixcblxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXJzZV9lcnJvcjpcbiAgICAgICAgICAgIFwiVW0gZXJybyBkZSBQYXJzZSBzaWduaWZpY2EgcXVlIFB5dGhvbiBuw6NvIGVudGVuZGUgYSBzaW50YXhlIGRhIGxpbmhhIHF1ZSBhIG1lbnNhZ2VtIGRlIGVycm8gYXBvbnRhLiBFeGVtcGxvcyBjb211bnMgc8OjbyBlc3F1ZWNlciB2w61yZ3VsYXMgZW50cmUgYXJndW1lbnRvcyBvdSBlc3F1ZWNlciAnOicgZW0gdW0gY29tYW5kbyBmb3IuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BhcnNlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiUGFyYSBjb3JyaWdpciB1bSBlcnJvIGRlIFBhcnNlLCB2b2PDqiBzw7MgcHJlY2lzYSBvbGhhciBjdWlkYWRvc2FtZW50ZSBhIGxpbmhhIGNvbSBvIGVycm8gZSBwb3NzaXZlbG1lbnRlIGEgbGluaGEgYW50ZXMgZGVsYS4gVGVuaGEgY2VydGV6YSBxdWUgZXN0w6NvIGRlIGFjb3JkbyBjb20gdG9kYXMgYXMgcmVncmFzIGRlIFB5dGhvbi5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcjpcbiAgICAgICAgICAgIFwiRXJyb3MgZGUgdGlwYWdlbSBvY29ycmVtIG1haXMgZnJlcXVlbnRlbWVudGUgcXVhbmRvIHVtYSBleHByZXNzw6NvIHRlbnRhIGNvbWJpbmFyIGRvaXMgb2JqZXRvcyBjb20gdGlwb3MgcXVlIG7Do28gZGV2ZXJpYW0gc2VyIGNvbWJpbmFkb3MuIENvbW8gZWxldmFyIHVtYSBTdHJpbmcgYSB1bWEgcG90w6puY2lhLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90eXBlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiUGFyYSBjb3JyaWdpciB1bSBlcnJvIGRlIHRpcGFnZW0gdm9jw6ogcHJvdmF2ZWxtZW50ZSBwcmVjaXNhcsOhIHBlcmNvcnJlciBzZXUgY8OzZGlnbyBlIHRlciBjZXJ0ZXphIGRlIHF1ZSBhcyB2YXJpw6F2ZWlzIHBvc3N1ZW0gb3MgdGlwb3MgcXVlIHZvY8OqIGVzcGVyYSBxdWUgZWxhcyB0ZW5oYW0uIFBvZGUgc2VyIMO6dGlsIGltcHJpbWlyIGNhZGEgdmFyacOhdmVsIGFvIGxvbmdvIGRvIGNhbWluaG8gcGFyYSBjaGVjYXIgc2UgZWxhcyBwb3NzdWVtIG8gdmFsb3IgcXVlIHZvY8OqIGFjaGEgcXVlIGRldmVyaWFtIHRlci5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcjpcbiAgICAgICAgICAgIFwiVW0gZXJybyBkZSBub21lIHF1YXNlIHNlbXByZSBzaWduaWZpY2EgcXVlIHZvY8OqIHVzb3UgdW1hIHZhcmnDoXZlbCBhbnRlcyBkZWxhIHRlciB1bSB2YWxvci4gRnJlcXVlbnRlbWVudGUgaXNzbyBwb2RlIHNlciB1bSBlcnJvIGRlIGRpZ2l0YcOnw6NvLCBlbnTDo28gY2hlcXVlIGEgb3J0b2dyYWZpYSBjdWlkYWRvc2FtZW50ZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZXF1ZSBvIGxhZG8gZGlyZWl0byBkYXMgYXRyaWJ1acOnw7VlcyBlIHN1YXMgY2hhbWFkYXMgZGUgZnVuw6fDtWVzLCBzw6NvIG9zIGx1Z2FyZXMgbWFpcyBwcm92w6F2ZWlzIGRlIGVuY29udHJhciB1bSBlcnJvIGRlIG5vbWUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3ZhbHVlX2Vycm9yOlxuICAgICAgICAgICAgXCJVbSBlcnJvIGRlIHZhbG9yIG9jb3JyZSBtYWlzIGZyZXF1ZW50ZW1lbnRlIHF1YW5kbyB1bWEgZnVuw6fDo28gZXN0w6EgZXNwZXJhbmRvIHVtIHRpcG8gbWFzIHZvY8OqIHBhc3NhIHVtIHBhcsOibWV0cm8gZGUgb3V0cm8gdGlwby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdmFsdWVfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJBIG1lbnNhZ2VtIGRlIGVycm8gdGUgZMOhIHVtYSBib2EgZGljYSBzb2JyZSBvIG5vbWUgZGEgZnVuw6fDo28gZSBvIHZhbG9yIGluY29ycmV0by4gTGVpYSBhdGVudGFtZW50ZSBhIG1lbnNhZ2VtIGRlIGVycm8gZSB2b2x0ZSDDoCB2YXJpw6F2ZWwgcXVlIGNvbnTDqW0gbyB2YWxvciBwcm9ibGVtw6F0aWNvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdHRyaWJ1dGVfZXJyb3I6XG4gICAgICAgICAgICBcIkVzc2EgbWVuc2FnZW0gZGUgZXJybyBlc3TDoSB0ZSBkaXplbmRvIHF1ZSBvIG9iamV0byBkbyBsYWRvIGVzcXVlcmRvIGRvIHBvbnRvIG7Do28gdGVtIG8gYXRyaWJ1dG8gb3UgbcOpdG9kbyBkbyBzZXUgbGFkbyBkaXJlaXRvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdHRyaWJ1dGVfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJBIHZhcmlhbnRlIG1haXMgY29tdW0gZGVzc2EgbWVuc2FnZW0gw6kgcXVlIG8gb2JqZXRvIGluZGVmaW5pZG8gbsOjbyB0ZW0gbyBhdHJpYnV0byBYLiBJc3NvIGRpeiBxdWUgbyBvYmpldG8gZG8gbGFkbyBlc3F1ZXJkbyBkbyBwb250byBuw6NvIMOpIG8gcXVlIHZvY8OqIHBlbnNhLiBSYXN0cmVpZSBlc3NhIHZhcmnDoXZlbCBlIGltcHJpbWEtYSBlbSB2w6FyaW9zIGx1Z2FyZXMgYXTDqSBkZXNjb2JyaXIgb25kZSBlbGEgc2UgdG9ybmEgaW5kZWZpbmlkYS4gQ2FzbyBjb250csOhcmlvLCBjaGVxdWUgc2UgaMOhIGVycm8gZGUgZGlnaXRhw6fDo28gbm8gYXRyaWJ1dG8gZG8gbGFkbyBkaXJlaXRvIGRvIHBvbnRvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcjpcbiAgICAgICAgICAgIFwiTmEgbWFpb3JpYSBkYXMgdmV6ZXMgZXN0ZSBlcnJvIGluZGljYSBxdWUgdm9jw6ogZXNxdWVjZXUgZGUgZmVjaGFyIHVtIHBhcsOqbnRlc2VzIG91IGFzcGFzLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZXF1ZSBjYWRhIGxpbmhhIGRvIHNldSBwcm9ncmFtYSBlIGNlcnRpZmlxdWUtc2UgZGUgcXVlIHRvZG9zIG9zIHBhcsOqbnRlc2VzIGVzdMOjbyBmZWNoYWRvcy5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9lcnJvcjpcbiAgICAgICAgICAgIFwiU2V1IHByb2dyYW1hIGVzdMOhIGRlbW9yYW5kbyBtdWl0by4gT3MgcHJvZ3JhbWFzIGRlc3RlIGxpdnJvIGRldmVyaWFtIHJvZGFyIGVtIG1lbm9zIGRlIDEwIHNlZ3VuZG9zLiBJc3NvIHByb3ZhdmVsbWVudGUgaW5kaWNhIHF1ZSBzZXUgcHJvZ3JhbWEgZXN0w6EgZW0gdW0gbG9vcCBpbmZpbml0by5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkltcHJpbWEgbWVuc2FnZW5zIGVtIGFsZ3VtYXMgbGluaGFzIHBhcmEgZGVzY29icmlyIHNlIHNldSBwcm9ncmFtYSBlc3TDoSBlbSB1bSBsb29wIGluZmluaXRvLiBDYXNvIG7Do28gZXN0ZWphLCB2b2PDqiBwb2RlIGF1bWVudGFyIG8gdGVtcG8gbGltaXRlIGRlIGV4ZWN1w6fDo28gY29tIG8gY29tYW5kbyBzeXMuc2V0RXhlY3V0aW9uTGltaXQobXMpXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2dlbmVyYWxfZXJyb3I6XG4gICAgICAgICAgICBcIlNldSBwcm9ncmFtYSBlc3TDoSBkZW1vcmFuZG8gbXVpdG8uIE9zIHByb2dyYW1hcyBkZXN0ZSBsaXZybyBkZXZlcmlhbSByb2RhciBlbSBtZW5vcyBkZSAzMCBzZWd1bmRvcy4gSXNzbyBwcm92YXZlbG1lbnRlIGluZGljYSBxdWUgc2V1IHByb2dyYW1hIGVzdMOhIGVtIHVtIGxvb3AgaW5maW5pdG8uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2dlbmVyYWxfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJJbXByaW1hIG1lbnNhZ2VucyBlbSBhbGd1bWFzIGxpbmhhcyBwYXJhIGRlc2NvYnJpciBzZSBzZXUgcHJvZ3JhbWEgZXN0w6EgZW0gdW0gbG9vcCBpbmZpbml0by4gQ2FzbyBuw6NvIGVzdGVqYSwgdm9jw6ogcG9kZSBhdW1lbnRhciBvIHRlbXBvIGxpbWl0ZSBkZSBleGVjdcOnw6NvIGNvbSBvIGNvbWFuZG8gc3lzLnNldEV4ZWN1dGlvbkxpbWl0KG1zKVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3I6XG4gICAgICAgICAgICBcIkVzdGEgbWVuc2FnZW0gaW5kaWNhIHF1ZSBQeXRob24gbsOjbyBlbnRlbmRldSBhIHNpbnRheGUgZGUgdW0gY29tYW5kby4gQWxndW5zIGV4ZW1wbG9zIHPDo28gYXRyaWJ1acOnw6NvIGRlIHVtIGxpdGVyYWwsIG91IHVtYSBjaGFtYWRhIGRlIGZ1bsOnw6NvXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N5bnRheF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIkNoZXF1ZSBhcyBhdHJpYnVpw6fDtWVzIGRlIHNldSBwcm9ncmFtYSBlIGNlcnRpZmlxdWUtc2UgZGUgcXVlIG8gbGFkbyBlc3F1ZXJkbyDDqSB1bWEgdmFyacOhdmVsLCBlIG7Do28gdW0gbGl0ZXJhbCBvdSBmdW7Dp8Ojby5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yOlxuICAgICAgICAgICAgXCJFc3RhIG1lbnNhZ2VtIGluZGljYSBxdWUgdm9jw6ogZXN0w6EgdGVudGFuZG8gYWNlc3NhciB1bSBlbGVtZW50byBjdWphIGNoYXZlIG7Do28gZXhpc3RlIG5vIGRpY2lvbsOhcmlvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9rZXlfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJWb2PDqiBwb2RlIHRlciB1bSBlcnJvIGRlIGRpZ2l0YcOnw6NvIG5vIG5vbWUgZGEgc3VhIGNoYXZlLiDDiSB1bWEgYm9hIHByw6F0aWNhIGNoZWNhciBzZSBhIGNoYXZlIGV4aXN0ZSB1c2FuZG8gdW0gY29tYW5kbyAnaWYgKGNoYXZlKSBpbiBtZXVfZGljaW9uYXJpbycuIFZvY8OqIHRhbWLDqW0gcG9kZSB1c2FyIG8gY29tYW5kbyAnbWV1X2RpY2lvbmFyaW8uZ2V0KGNoYXZlLCB2YWxvclBhZHLDo28pJyBwYXJhIG9idGVyIG8gdmFsb3IgcGFkcsOjbyBhbyBpbnbDqXMgZGUgdW0gZXJybyBjYXNvIGEgY2hhdmUgbsOjbyBleGlzdGEuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2luZGV4X2Vycm9yOlxuICAgICAgICAgICAgXCJWb2PDqiBlc3TDoSB0ZW50YW5kbyBhY2Vzc2FyIHVtIMOtbmRpY2UgYWzDqW0gZG8gZmluYWwgZGUgdW1hIHN0cmluZyBvdSBsaXN0YS4gUG9yIGV4ZW1wbG8sIHNlIHN1YSBsaXN0YSBwb3NzdWkgMyBlbGVtZW50b3MgbmVsYSBlIHZvY8OqIHRlbnRhIGFjZXNzYXIgbyBpdGVtIG5hIHBvc2nDp8OjbyAzIG91IG1haXMuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2luZGV4X2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiTGVtYnJlLXNlIHF1ZSBvIHByaW1laXJvIGVsZW1lbnRvIGRlIHVtYSBsaXN0YSBvdSBzdHJpbmcgZXN0w6Egbm8gw61uZGljZSAwLCBub3JtYWxtZW50ZSBlc3RhIG1lbnNhZ2VtIMOpIGV4aWJpZGEgcG9ycXVlIHZvY8OqIGVycm91IG8gw61uZGljZSBwb3IgMS4gRW0gdW1hIGxpc3RhIGRlIHRhbWFuaG8gMywgbyDDumx0aW1vIMOtbmRpY2UgdsOhbGlkbyDDqSAyXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3VyaV9lcnJvcjogXCJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yX2ZpeDogXCJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yOlxuICAgICAgICAgICAgXCJFc3RhIG1lbnNhZ2VtIGluZGljYSBxdWUgdm9jw6ogZXN0w6EgdGVudGFuZG8gaW1wb3J0YXIgdW0gbcOzZHVsbyBxdWUgbsOjbyBleGlzdGVcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiVW0gcHJvYmxlbWEgcG9kZSBzZXIgYXBlbmFzIHVtIGVycm8gZGUgZGlnaXRhw6fDo28uIFRhbWLDqW0gcG9kZSBzZXIgcXVlIHZvY8OqIGVzdMOhIHRlbnRhbmRvIGltcG9ydGFyIHVtIG3Ds2R1bG8gcXVlIGV4aXN0ZSBlbSBQeXRob24gJ3JlYWwnLCBtYXMgbsOjbyBleGlzdGUgbmVzdGUgbGl2cm8uIFNlIGVzdGUgw6kgbyBjYXNvLCBwb3IgZmF2b3IgZW52aWUgdW0gcGVkaWRvIHBhcmEgdGVyIGVzc2UgbcOzZHVsbyBhZGljaW9uYWRvLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yZWZlcmVuY2VfZXJyb3I6XG4gICAgICAgICAgICBcIklzc28gcGFyZWNlIHNlciB1bSBlcnJvIGludGVybm8sIGVzcGVjaWFsbWVudGUgc2UgYSBtZW5zYWdlbSBmYXogcmVmZXLDqm5jaWEgYW8gY29uc29sZS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiVGVudGUgYXR1YWxpemFyIGEgcMOhZ2luYS4gU2UgbyBlcnJvIHBlcnNpc3RpciwgZW52aWUgdW0gcmVsYXTDs3JpbyBkZSBidWcganVudG8gY29tIHNldSBjw7NkaWdvXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3plcm9fZGl2aXNpb25fZXJyb3I6XG4gICAgICAgICAgICBcIklzc28gZGl6IHF1ZSB2b2PDqiBlc3TDoSB0ZW50YW5kbyBkaXZpZGlyIHBvciAwLiBOb3JtYWxtZW50ZSDDqSBwb3JxdWUgbyB2YWxvciBkYSB2YXJpw6F2ZWwgbm8gZGVub21pbmFkb3IgZGUgdW1hIGRpdmlzw6NvIHRlbSBvIHZhbG9yIDBcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfemVyb19kaXZpc2lvbl9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlZvY8OqIHBvZGUgcHJvdGVnZXIgY29udHJhIGRpdmlkaXIgcG9yIDAgY29tIHVtIGNvbWFuZG8gJ2lmJywgb3Ugdm9jw6ogcG9kZSBwcmVjaXNhciByZWF2YWxpYXIgc3VhcyBzdXBvc2nDp8O1ZXMgc29icmUgb3MgdmFsb3JlcyBkYXMgdmFyacOhdmVpcywgcG9pcyB1bSBjb21hbmRvIGFudGVyaW9yIHBvZGUgdGVyIGluZXNwZXJhZGFtZW50ZSBhdHJpYnXDrWRvIG8gdmFsb3IgMCBhIGVzc2EgdmFyacOhdmVsLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcjpcbiAgICAgICAgICAgIFwiRXN0YSBtZW5zYWdlbSBxdWFzZSBzZW1wcmUgYXBhcmVjZSBuYSBmb3JtYSBkZSAnVGFtYW5obyBtw6F4aW1vIGRhIHBpbGhhIGRlIGNoYW1hZGFzIGV4Y2VkaWRvJy5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmFuZ2VfZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJJc3NvIHNlbXByZSBvY29ycmUgcXVhbmRvIHVtYSBmdW7Dp8OjbyBjaGFtYSBlbGEgbWVzbWEuIFByb3ZhdmVsbWVudGUgdm9jw6ogbsOjbyBlc3TDoSBmYXplbmRvIGlzc28gZGUgcHJvcMOzc2l0bywgZXhjZXRvIG5vIGNhcMOtdHVsbyBzb2JyZSByZWN1cnPDo28uIFNlIHZvY8OqIGVzdMOhIG5lc3NlIGNhcMOtdHVsbywgZW50w6NvIHByb3ZhdmVsbWVudGUgYWluZGEgbsOjbyBpZGVudGlmaWNvdSB1bSBib20gY2FzbyBiYXNlLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcjpcbiAgICAgICAgICAgIFwiVW0gZXJybyBpbnRlcm5vIHBvZGUgc2lnbmlmaWNhciBxdWUgdm9jw6ogZGVzZW5jYWRlb3UgdW0gYnVnIG5vIG5vc3NvIFB5dGhvblwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlJlcG9ydGUgZXN0ZSBlcnJvIGNvbW8gdW0gYnVnLCBqdW50YW1lbnRlIGNvbSBzZXUgY8OzZGlnb1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbmRlbnRhdGlvbl9lcnJvcjpcbiAgICAgICAgICAgIFwiRXN0ZSBlcnJvIG9jb3JyZSBxdWFuZG8gdm9jw6ogbsOjbyBpbmRlbnRvdSBzZXUgY8OzZGlnbyBkZXZpZGFtZW50ZS4gSXNzbyDDqSBtYWlzIHByb3bDoXZlbCBkZSBvY29ycmVyIGNvbW8gcGFydGUgZGUgdW0gY29tYW5kbyBpZiwgZm9yLCB3aGlsZSBvdSBkZWYuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2luZGVudGF0aW9uX2Vycm9yX2ZpeDpcbiAgICAgICAgICAgIFwiQ2hlcXVlIHNldXMgY29tYW5kb3MgaWYsIGRlZiwgZm9yIGUgd2hpbGUgcGFyYSB0ZXIgY2VydGV6YSBkZSBxdWUgYXMgbGluaGFzIGVzdMOjbyBkZXZpZGFtZW50ZSBpbmRlbnRhZGFzIGFiYWl4byBkZWxhcy4gT3V0cmEgZm9udGUgZGVzdGUgZXJybyDDqSBjb3BpYXIgZSBjb2xhciBjw7NkaWdvIGVtIHF1ZSB2b2PDqiBhY2lkZW50YWxtZW50ZSBkZWl4b3UgcmVzdG9zIGRlIGPDs2RpZ28gcXVlIG7Do28gcGVydGVuY2VtIG1haXMgYWxpLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ub3RfaW1wbGVtZW50ZWRfZXJyb3I6XG4gICAgICAgICAgICBcIkVzdGUgZXJybyBvY29ycmUgcXVhbmRvIHZvY8OqIHRlbnRhIHVzYXIgdW1hIGZ1bsOnw6NvIGVtYnV0aWRhIGRlIFB5dGhvbiBxdWUgbsOjbyBmb2kgaW1wbGVtZW50YWRhIG5lc3RhIHZlcnPDo28gYnJvd3NlciBkZSBQeXRob24uXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25vdF9pbXBsZW1lbnRlZF9lcnJvcl9maXg6XG4gICAgICAgICAgICBcIlBvciBlbnF1YW50byBhIMO6bmljYSBtYW5laXJhIGRlIGNvbnNlcnRhciBpc3NvIMOpIG7Do28gdXNhbmRvIGEgZnVuw6fDo28uIFBvZGVtIGhhdmVyIHNvbHXDp8O1ZXMgYWx0ZXJuYXRpdmFzLiBTZSB2b2PDqiByZWFsbWVudGUgcHJlY2lzYSBkZXN0YSBmdW7Dp8OjbyBlbWJ1dGlkYSwgZW52aWUtbm9zIHVtIHJlbGF0w7NyaW8gZGUgYnVnIGUgZGlnYWMgb21vIGVzdMOhIHRlbnRhbmRvIHVzYXIgYSBmdW7Dp8Ojby5cIixcblxuICAgICAgICBtc2dfYWN0aXZlY29kZV9maWxlX25vdF9mb3VuZDogXCJBcnF1aXZvIG7Do28gZW5jb250cmFkbzogJyQxJ1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ub19maWxlX29yX2RpcjpcbiAgICAgICAgICAgIFwiW0Vycm8gbsK6IDJdIEFycXVpdm8gb3UgZGlyZXTDs3JpbyBpbmV4aXN0ZW50ZTogJyQxJ1wiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zdGFydGluZzogXCJDbGlxdWUgbm8gYm90w6NvIGRlIGV4ZWN1w6fDo28gcGFyYSBjb21lw6dhciAkMVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wbGF5aW5nOiBcIkV4ZWN1dGFuZG8gJDFcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZGluZ19hdWRpbzpcbiAgICAgICAgICAgIFwiQ2FycmVnYW5kbyDDoXVkaW8uIFBvciBmYXZvciwgZXNwZXJlLiBTZSBvIHRvdXIgbsOjbyBjb21lw6dhciBsb2dvLCBjbGlxdWUgZW0gJ1N0b3AgVG91cicgZSB0ZW50ZSBub3ZhbWVudGUuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BhdXNlX2N1cnJlbnRfYXVkaW86IFwiUGF1c2FyIMOhdWRpbyBhdHVhbFwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXVzZV9hdWRpbzogXCJQYXVzYXIgw6F1ZGlvXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BsYXlfcGF1c2VkX2F1ZGlvOiBcIlJlcHJvZHV6aXIgw6F1ZGlvIHBhdXNhZG9cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fcGF1c2VkOlxuICAgICAgICAgICAgXCIkMSBmb2kgcGF1c2Fkby4gQ2xpcXVlIG5vIGJvdMOjbyBkZSBleGVjdcOnw6NvIHBhcmEgcmV0b21hciBvIHRvdXIuXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2lucHV0X3ByZzogXCJFbnRyYWRhIHBhcmEgbyBwcm9ncmFtYVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV93ZXJlX2NvbXBpbGluZ19lcnI6XG4gICAgICAgICAgICBcIkhvdXZlcmFtIGVycm9zIGFvIGNvbXBpbGFyIHNldSBjw7NkaWdvLiBWZWphIGFiYWl4by5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9leGM6IFwiTGltaXRlIGRlIHRlbXBvIGV4Y2VkaWRvIG5vIHNldSBwcm9ncmFtYVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zZXJ2ZXJfZXJyOiBcIlVtIGVycm8gZGUgc2Vydmlkb3Igb2NvcnJldVwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9jb21waWxpbmdfcnVubmluZzpcbiAgICAgICAgICAgIFwiQ29tcGlsYW5kbyBlIGV4ZWN1dGFuZG8gc2V1IGPDs2RpZ28uLi5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2VydmVyX2NvbW1fZXJyOiBcIkVycm8gYW8gY29tdW5pY2FyIGNvbSBvIHNlcnZpZG9yLlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zYXZlX3J1bjogXCJTYWx2YXIgJiBFeGVjdXRhclwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yZW5kZXI6IFwiU2FsdmFyICYgUmVuZGVyaXphclwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hc3NlcnRpb25fZXJyb3I6XG4gICAgICAgICAgICBcIlVtIGVycm8gZGUgYXNzZXLDp8OjbyBvY29ycmUgcXVhbmRvIHB5dGhvbiBlbmNvbnRyYSB1bSBjb21hbmRvICdhc3NlcnQnLiBQeXRob24gYXZhbGlhIGEgZXhwcmVzc8OjbyBkbyBsYWRvIGRpcmVpdG87IHNlIMOpIHZlcmRhZGVpcmEsIG8gcHJvZ3JhbWEgY29udGludWEgbm9ybWFsbWVudGUuIFNlIMOpIGZhbHNhLCBweXRob24gZ2VyYSB1bSBlcnJvIGUgcGFyYSBhIGV4ZWN1w6fDo28uXCIgLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hc3NlcnRpb25fZXJyb3JfZml4OlxuICAgICAgICAgICAgXCJDaGVxdWUgYSBleHByZXNzw6NvIGRvIGxhZG8gZGlyZWl0byBkZSAnYXNzZXJ0Jy4gRXNzYSBleHByZXNzw6NvIMOpIGZhbHNhIGUgw6kgcHJlY2lzbyB2ZXJpZmljYXIgbyBtb3Rpdm8uIFZvY8OqIHBvZGUgcXVlcmVyIGltcHJpbWlyIGNhZGEgcGFydGUgZGEgZXhwcmVzc8OjbyBlIGVudGVuZGVyIHBvcnF1ZSDDqSBmYWxzYS5cIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9kYjogXCJDYXJyZWdhbmRvIGJhbmNvIGRlIGRhZG9zLi4uXCIsXG4gICAgfSxcbn0pO1xuIiwiJC5pMThuKCkubG9hZCh7XG4gICAgXCJzci1DeXJsXCI6IHtcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9oaXN0b3J5OiBcItCj0YfQuNGC0LDRmCDQuNGB0YLQvtGA0LjRmNGDXCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2F1ZGlvX3RvdXI6IFwi0JDRg9C00LjQviDRgtGD0YDQsFwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkZWRfY29kZTogXCLQktCw0Ygg0LjQt9Cy0L7RgNC90Lgg0LrQvtC0INGY0LUg0YPRh9C40YLQsNC9LlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ub19zYXZlZF9jb2RlOiBcItCd0LUg0L/QvtGB0YLQvtGY0Lgg0YHQvdC40LzRmdC10L0g0LrQvtC0LlwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ydW5fY29kZTogXCLQn9C+0LrRgNC10L3QuCDQv9GA0L7Qs9GA0LDQvFwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2ZlZWRiYWNrOiBcItCf0YDQuNC60LDQttC4INGA0LXQt9GD0LvRgtCw0YJcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlOiBcItCf0YDQuNC60LDQttC4INC60L7QtFwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGU6IFwi0JfQsNGC0LLQvtGA0Lgg0LrQvtC0XCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZWxlbnM6IFwi0JrQvtGA0LDQuiDQv9C+INC60L7RgNCw0LpcIixcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19pbl9jb2RlbGVuczogXCLQmtC+0YDQsNC6INC/0L4g0LrQvtGA0LDQulwiLFxuICAgICAgICBtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVsZW5zOiBcItCX0LDRgtCy0L7RgNC4INC60L7RgNCw0Log0L/QviDQutC+0YDQsNC6XCIsXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JlZm9ybWF0OiBcItCg0LXRhNC+0YDQvNCw0YJcIixcblxuICAgICAgICBtc2dfc2N0aXZlY29kZV9wYXJzZV9lcnJvcjpcbiAgICAgICAgICAgIFwi0KHQuNC90YLQsNC60YHQvdCwINCz0YDQtdGI0LrQsCAocGFyc2UgZXJyb3IpINC30L3QsNGH0Lgg0LTQsCDQn9Cw0ZjRgtC+0L0g0L3QtSDRgNCw0LfRg9C80LUg0YHQuNC90YLQsNC60YHRgyDRgyDQu9C40L3QuNGY0Lgg0LrQvtCz0LAg0L3QsCDQutC+0ZjRgyDQv9C+0YDRg9C60LAg0L4g0LPRgNC10YjRhtC4INGD0LrQsNC30YPRmNC1LiDQotC40L/QuNGH0L3QuCDQv9GA0LjQvNC10YDQuCDQvtCy0LDQutCy0LUg0LPRgNC10YjQutC1INGB0YMg0LfQsNCx0L7RgNCw0LLQu9GY0LXQvdCwINC00LLQvtGC0LDRh9C60LAg0LrQvtC0ICdpZicg0LjQu9C4ICdmb3InINC40YHQutCw0LfQsCDQuNC70Lgg0LfQsNCx0L7RgNCw0LLRmdC10L3QsCDQt9Cw0L/QtdGC0LAg0LjQt9C80LXRktGDINCw0YDQs9GD0LzQtdC90LDRgtCwINC60L7QtCDQv9C+0LfQuNCy0LAg0YTRg9C90LrRhtC40ZjQtVwiLFxuICAgICAgICBtc2dfc2N0aXZlY29kZV9wYXJzZV9lcnJvcl9maXg6XG4gICAgICAgICAgICBcItCU0LAg0LHQuNGB0YLQtSDQuNGB0L/RgNCw0LLQuNC70Lgg0YHQuNC90YLQsNC60YHQvdGDINCz0YDQtdGI0LrRgyDRgtGA0LXQsdCwINC/0LDQttGa0LjQstC+INC00LAg0L/QvtCz0LvQtdC00LDRgtC1INC70LjQvdC40ZjRgyDQuNC30LLQvtGA0L3QvtCzINC60L7QtNCwINC90LAg0LrQvtGY0YMg0YPQutCw0LfRg9GY0LUg0L/QvtGA0YPQs9CwINC+INCz0YDQtdGI0YbQuCDQuCDQvNC+0LbQtNCwINC/0YDQtdGC0YXQvtC00L3RgyDQu9C40L3QuNC90YMg0LjQt9Cy0L7RgNC90L7QsyDQutC+0LTQsC4g0J/RgNC+0LLQtdGA0LjRgtC1INC00LAg0LvQuCDRgdGDINC/0L7RiNGC0L7QstCw0L3QsCDRgdCy0LAg0YHQuNC90YLQsNC60YHQvdCwINC/0YDQsNCy0LjQu9CwINCf0LDRmNGC0L7QvdCwLlwiLFxuICAgIH0sXG59KTtcbiIsIi8qKlxuICpcbiAqIENyZWF0ZWQgYnkgYm1pbGxlciBvbiAzLzE5LzE1LlxuICovXG4vKiBEZWZpbmUgZ2xvYmFsIHZhcmlhYmxlcyBmb3IgRVNMaW50ICovXG4vKiBnbG9iYWwgU2sgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdW5lc3RvbmVCYXNlIGZyb20gXCIuLi8uLi9jb21tb24vanMvcnVuZXN0b25lYmFzZS5qc1wiO1xuaW1wb3J0IEF1ZGlvVG91ciBmcm9tIFwiLi9hdWRpb3RvdXIuanNcIjtcbmltcG9ydCBcIi4vYWN0aXZlY29kZS1pMThuLmVuLmpzXCI7XG5pbXBvcnQgXCIuL2FjdGl2ZWNvZGUtaTE4bi5wdC1ici5qc1wiO1xuaW1wb3J0IFwiLi9hY3RpdmVjb2RlLWkxOG4uc3ItQ3lybC5qc1wiO1xuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcImNvZGVtaXJyb3JcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS9weXRob24vcHl0aG9uLmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvY3NzL2Nzcy5qc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2h0bWxtaXhlZC9odG1sbWl4ZWQuanNcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0LmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvc3FsL3NxbC5qc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2NsaWtlL2NsaWtlLmpzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvb2N0YXZlL29jdGF2ZS5qc1wiO1xuaW1wb3J0IFwiLi8uLi9jc3MvYWN0aXZlY29kZS5sZXNzXCI7XG5pbXBvcnQgXCJjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmNzc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9oaW50L3Nob3ctaGludC5qc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9oaW50L3Nob3ctaGludC5jc3NcIjtcbmltcG9ydCBcImNvZGVtaXJyb3IvYWRkb24vaGludC9zcWwtaGludC5qc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9oaW50L2FueXdvcmQtaGludC5qc1wiO1xuaW1wb3J0IFwiY29kZW1pcnJvci9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHMuanNcIjtcbmltcG9ydCBcIi4vc2t1bHB0Lm1pbi5qc1wiO1xuaW1wb3J0IFwiLi9za3VscHQtc3RkbGliLmpzXCI7XG5pbXBvcnQgUHlmbGFrZXNDb2FjaCBmcm9tIFwiLi9jb2FjaC1weXRob24tcHlmbGFrZXMuanNcIjtcbi8vIFVzZWQgYnkgU2t1bHB0LlxuaW1wb3J0IGVtYmVkIGZyb20gXCJ2ZWdhLWVtYmVkXCI7XG4vLyBBZGFwdCBmb3IgdXNlIG91dHNpZGUgd2VicGFjayAtLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1lbWJlZC5cbndpbmRvdy52ZWdhRW1iZWQgPSBlbWJlZDtcblxudmFyIGlzTW91c2VEb3duID0gZmFsc2U7XG52YXIgc3RvcEV4ZWN1dGlvbiA9IGZhbHNlO1xuXG5kb2N1bWVudC5vbm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc01vdXNlRG93biA9IHRydWU7XG59O1xuXG5kb2N1bWVudC5vbm1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaXNNb3VzZURvd24gPSBmYWxzZTtcbn07XG53aW5kb3cuY29tcG9uZW50TWFwID0ge307XG5cbnZhciBzb2NrZXQsIGNvbm5lY3Rpb24sIGRvYztcbnZhciBjaGF0Y29kZXNTZXJ2ZXIgPSBcImNoYXQuY29kZXNcIjtcblxuQ29kZU1pcnJvci5jb21tYW5kcy5hdXRvY29tcGxldGUgPSBmdW5jdGlvbiAoY20pIHtcbiAgICBjbS5zaG93SGludCh7IGhpbnQ6IENvZGVNaXJyb3IuaGludC5hbnl3b3JkIH0pO1xufTtcblxuLy8gc2VwYXJhdGUgaW50byBjb25zdHJ1Y3RvciBhbmQgaW5pdFxuZXhwb3J0IGNsYXNzIEFjdGl2ZUNvZGUgZXh0ZW5kcyBSdW5lc3RvbmVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB2YXIgc3VmZlN0YXJ0O1xuICAgICAgICB2YXIgb3JpZyA9ICQob3B0cy5vcmlnKS5maW5kKFwidGV4dGFyZWFcIilbMF07XG4gICAgICAgIHRoaXMuY29udGFpbmVyRGl2ID0gb3B0cy5vcmlnO1xuICAgICAgICB0aGlzLnVzZVJ1bmVzdG9uZVNlcnZpY2VzID0gb3B0cy51c2VSdW5lc3RvbmVTZXJ2aWNlcztcbiAgICAgICAgdGhpcy5weXRob24zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcmlnRWxlbSA9IG9yaWc7XG4gICAgICAgIHRoaXMub3JpZ1RleHQgPSB0aGlzLm9yaWdFbGVtLnRleHRDb250ZW50O1xuICAgICAgICB0aGlzLmNvZGVDb2FjaExpc3QgPSBbXTsgLy9saXN0IG9mIENvZGVDb2FjaGVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHByb3ZpZGUgZmVlZGJhY2tcbiAgICAgICAgdGhpcy5kaXZpZCA9IG9wdHMub3JpZy5pZDtcbiAgICAgICAgdGhpcy5jb2RlID0gJChvcmlnKS50ZXh0KCkgfHwgXCJcXG5cXG5cXG5cXG5cXG5cIjtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9ICQob3JpZykuZGF0YShcImxhbmdcIik7XG4gICAgICAgIHRoaXMudGltZWxpbWl0ID0gJChvcmlnKS5kYXRhKFwidGltZWxpbWl0XCIpO1xuICAgICAgICB0aGlzLmluY2x1ZGVzID0gJChvcmlnKS5kYXRhKFwiaW5jbHVkZVwiKTtcbiAgICAgICAgdGhpcy5oaWRlY29kZSA9ICQob3JpZykuZGF0YShcImhpZGVjb2RlXCIpO1xuICAgICAgICB0aGlzLmNoYXRjb2RlcyA9ICQob3JpZykuZGF0YShcImNoYXRjb2Rlc1wiKTtcbiAgICAgICAgdGhpcy5oaWRlaGlzdG9yeSA9ICQob3JpZykuZGF0YShcImhpZGVoaXN0b3J5XCIpO1xuICAgICAgICB0aGlzLnF1ZXN0aW9uID0gJChvcHRzLm9yaWcpLmZpbmQoYCMke3RoaXMuZGl2aWR9X3F1ZXN0aW9uYClbMF07XG4gICAgICAgIHRoaXMudGllID0gJChvcmlnKS5kYXRhKFwidGllXCIpO1xuICAgICAgICB0aGlzLmRidXJsID0gJChvcmlnKS5kYXRhKFwiZGJ1cmxcIik7XG4gICAgICAgIHRoaXMucnVuQnV0dG9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVkb3dubG9hZCA9ICQob3JpZykuZGF0YShcImVuYWJsZWRvd25sb2FkXCIpO1xuICAgICAgICB0aGlzLmRvd25sb2FkQnV0dG9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYXZlQnV0dG9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkQnV0dG9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vdXRlckRpdiA9IG51bGw7XG4gICAgICAgIHRoaXMucGFydG5lciA9IFwiXCI7XG4gICAgICAgIHRoaXMucnVuQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmxvZ1Jlc3VsdHMgPSB0cnVlO1xuICAgICAgICBpZiAoIWVCb29rQ29uZmlnLmFsbG93X3BhaXJzIHx8ICQob3JpZykuZGF0YShcIm5vcGFpclwiKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVQYXJ0bmVyID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVBhcnRuZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gY3JlYXRlIHByZSBmb3Igb3V0cHV0XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBudWxsOyAvLyBjcmVhdGUgZGl2IGZvciB0dXJ0bGUgZ3JhcGhpY3NcbiAgICAgICAgdGhpcy5jb2RlY29hY2ggPSBudWxsOyAvLyBkaXYgZm9yIENvZGUgQ29hY2hlc1xuICAgICAgICB0aGlzLmNvZGVsZW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250cm9sRGl2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXN0b3J5U2NydWJiZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcHMgPSBbXCJPcmlnaW5hbFwiXTtcbiAgICAgICAgdGhpcy5hdXRvcnVuID0gJChvcmlnKS5kYXRhKFwiYXV0b3J1blwiKTtcbiAgICAgICAgdGhpcy5vdXRwdXRMaW5lQ291bnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5jaGF0Y29kZXMgJiYgZUJvb2tDb25maWcuZW5hYmxlX2NoYXRjb2Rlcykge1xuICAgICAgICAgICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KFwid3NzOi8vXCIgKyBjaGF0Y29kZXNTZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IG5ldyB3aW5kb3cuc2hhcmVkYi5Db25uZWN0aW9uKHNvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgICAgIGRvYyA9IGNvbm5lY3Rpb24uZ2V0KFwiY2hhdGNvZGVzXCIsIFwiY2hhbm5lbHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JhZGVyYWN0aXZlIHx8IHRoaXMuaXNUaW1lZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlY29kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVzID0gdGhpcy5pbmNsdWRlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVmaXhFbmQgPSB0aGlzLmNvZGUuaW5kZXhPZihcIl5eXl5cIik7XG4gICAgICAgIGlmIChwcmVmaXhFbmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSB0aGlzLmNvZGUuc3Vic3RyaW5nKDAsIHByZWZpeEVuZCk7XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUuc3Vic3RyaW5nKHByZWZpeEVuZCArIDUpO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZTdGFydCA9IHRoaXMuY29kZS5pbmRleE9mKFwiPT09PVwiKTtcbiAgICAgICAgaWYgKHN1ZmZTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGUgKzUgZ2V0cyBwYXN0IHRoZSA9PT09XFxuXG4gICAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHRoaXMuY29kZS5zdWJzdHJpbmcoc3VmZlN0YXJ0ICsgNSk7XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUuc3Vic3RyaW5nKDAsIHN1ZmZTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW3RoaXMuY29kZV07XG4gICAgICAgIHRoaXMuY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlT3V0cHV0KCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udHJvbHMoKTtcbiAgICAgICAgaWYgKCQob3JpZykuZGF0YShcImNhcHRpb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdGlvbiA9ICQob3JpZykuZGF0YShcImNhcHRpb25cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhcHRpb24gPSBcIkFjdGl2ZUNvZGVcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENhcHRpb24oXCJydW5lc3RvbmVcIik7XG5cbiAgICAgICAgLy9TZXR1cCBDb2RlQ29hY2hlcyAtIGFkZCBiYXNlZCBvbiBsYW5ndWFnZVxuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZSA9PSBcInB5dGhvblwiIHx8IHRoaXMubGFuZ3VhZ2UgPT0gXCJweXRob24zXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZUNvYWNoTGlzdC5wdXNoKG5ldyBQeWZsYWtlc0NvYWNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAxMDAwXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9ydW4pIHtcbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHByZXNzaW5nIHRoZSBydW4gYnV0dG9uLCBzaW5jZSB0aGlzIHdpbGwgYWxzbyBwcmV2ZW50IHRoZSB1c2VyIGZyb20gY2xpY2tpbmcgaXQgdW50aWwgdGhlIGluaXRpYWwgcnVuIGlzIGNvbXBsZXRlLCBhbmQgYWxzbyBoZWxwIHRoZSB1c2VyIHVuZGVyc3RhbmQgd2h5IHRoZXkncmUgd2FpdGluZy5cbiAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b25IYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kaWNhdGVfY29tcG9uZW50X3JlYWR5KCk7XG4gICAgICAgIGlmICh0eXBlb2YgUHJpc20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyKHRoaXMuY29udGFpbmVyRGl2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZUVkaXRvcihpbmRleCkge1xuICAgICAgICB0aGlzLm91dGVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIGxpbmtkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBsaW5rZGl2LmlkID0gdGhpcy5kaXZpZC5yZXBsYWNlKC9fL2csIFwiLVwiKS50b0xvd2VyQ2FzZSgpOyAvLyA6cmVmOiBjaGFuZ2VzIF8gdG8gLSBzbyBhZGQgdGhpcyBhcyBhIHRhcmdldFxuICAgICAgICB2YXIgY29kZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQoY29kZURpdikuYWRkQ2xhc3MoXCJhY19jb2RlX2RpdlwiKTtcbiAgICAgICAgdGhpcy5jb2RlRGl2ID0gY29kZURpdjtcbiAgICAgICAgdGhpcy5vdXRlckRpdi5sYW5nID0gdGhpcy5sYW5ndWFnZTtcbiAgICAgICAgJCh0aGlzLm9yaWdFbGVtKS5yZXBsYWNlV2l0aCh0aGlzLm91dGVyRGl2KTtcbiAgICAgICAgaWYgKGxpbmtkaXYuaWQgIT09IHRoaXMuZGl2aWQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHdhbnQgdGhlICdleHRyYScgdGFyZ2V0IGlmIHRoZXkgbWF0Y2guXG4gICAgICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGxpbmtkaXYpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoY29kZURpdik7XG4gICAgICAgIHZhciBlZG1vZGUgPSB0aGlzLm91dGVyRGl2Lmxhbmc7XG4gICAgICAgIGlmIChlZG1vZGUgPT09IFwic3FsXCIpIHtcbiAgICAgICAgICAgIGVkbW9kZSA9IFwidGV4dC94LXNxbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGVkbW9kZSA9PT0gXCJqYXZhXCIpIHtcbiAgICAgICAgICAgIGVkbW9kZSA9IFwidGV4dC94LWphdmFcIjtcbiAgICAgICAgfSBlbHNlIGlmIChlZG1vZGUgPT09IFwiY3BwXCIpIHtcbiAgICAgICAgICAgIGVkbW9kZSA9IFwidGV4dC94LWMrK3NyY1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGVkbW9kZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgICAgIGVkbW9kZSA9IFwidGV4dC94LWNzcmNcIjtcbiAgICAgICAgfSBlbHNlIGlmIChlZG1vZGUgPT09IFwicHl0aG9uM1wiKSB7XG4gICAgICAgICAgICBlZG1vZGUgPSBcInB5dGhvblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGVkbW9kZSA9PT0gXCJvY3RhdmVcIiB8fCBlZG1vZGUgPT09IFwiTUFUTEFCXCIpIHtcbiAgICAgICAgICAgIGVkbW9kZSA9IFwidGV4dC94LW9jdGF2ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZGl0b3IgPSBDb2RlTWlycm9yKGNvZGVEaXYsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGU6IGVkbW9kZSxcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXG4gICAgICAgICAgICBtYXRjaEJyYWNrZXRzOiB0cnVlLFxuICAgICAgICAgICAgYXV0b01hdGNoUGFyZW5zOiB0cnVlLFxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgVGFiOiBcImluZGVudE1vcmVcIixcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcbiAgICAgICAgICAgICAgICBcIkN0cmwtU3BhY2VcIjogXCJhdXRvY29tcGxldGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYWtlIHRoZSBlZGl0b3IgcmVzaXphYmxlXG4gICAgICAgICQoZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkpLnJlc2l6YWJsZSh7XG4gICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0U2l6ZSgkKHRoaXMpLndpZHRoKCksICQodGhpcykuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZ2l2ZSB0aGUgdXNlciBhIHZpc3VhbCBjdWUgdGhhdCB0aGV5IGhhdmUgY2hhbmdlZCBidXQgbm90IHNhdmVkXG4gICAgICAgIGVkaXRvci5vbihcbiAgICAgICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5hY0VkaXRFdmVudCA9PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYWNFZGl0RXZlbnQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgZXZlbnRzIGNhbiBjb21lIGJlZm9yZSBhbnkgcmVhbCBjaGFuZ2VzIGZvciB2YXJpb3VzIHJlYXNvbnMsIHNvbWUgdW5rbm93blxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGF2b2lkcyB1bm5lY2NzYXJ5IGxvZyBldmVudHMgYW5kIHVwZGF0ZXMgdG8gdGhlIGFjdGl2aXR5IGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0UGFyZW50ID09PSBudWxsIG1lYW5zIHRoYXQgdGhlIGVsZW1lbnQgaXMgbm90IG9uIHRoZSBzY3JlZW4gYW5kIHNvIGNhbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmNvbnRyb2xEaXYub2Zmc2V0UGFyZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ1RleHQgPT09IGVkaXRvci5nZXRWYWx1ZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZGluZ1NjcnViYmVyXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGYWtlIGNoYW5nZSBldmVudCwgc2tpcHBpbmcgdGhlIGxvZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkKGVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpKS5jc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJvcmRlci10b3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiMnB4IHNvbGlkICNiNDMyMzJcIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAkKGVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpKS5jc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJvcmRlci1ib3R0b21cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiMnB4IHNvbGlkICNiNDMyMzJcIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQW5zd2VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgdGltZSB0aGUgc3R1ZGVudCB0eXBlcyBpbiB0aGUgd3JpdGUtY29kZSBib3hcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYWN0aXZlY29kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0OiBcImVkaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkaXRvci5hY0VkaXRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTsgLy8gdXNlIGJpbmQgdG8gcHJlc2VydmUgKnRoaXMqIGluc2lkZSB0aGUgb24gaGFuZGxlci5cblxuICAgICAgICAvL1NvbHZpbmcgS2V5Ym9hcmQgVHJhcCBvZiBBY3RpdmVDb2RlOiBJZiB1c2VyIHVzZSB0YWIgZm9yIG5hdmlnYXRpb24gb3V0c2lkZSBvZiBBY3RpdmVDb2RlLCB0aGVuIGNoYW5nZSB0YWIgYmVoYXZpb3IgaW4gQWN0aXZlQ29kZSB0byBlbmFibGUgdGFiIHVzZXIgdG8gdGFiIG91dCBvZiB0aGUgdGV4dGFyZWFcbiAgICAgICAgJCh3aW5kb3cpLmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZS5rZXlDb2RlID8gZS5rZXlDb2RlIDogZS53aGljaDtcbiAgICAgICAgICAgIGlmIChjb2RlID09IDkgJiYgJChcInRleHRhcmVhOmZvY3VzXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb24oXCJleHRyYUtleXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBUYWI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KFwiLnRhYi1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5leHRTaWJsaW5nLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KFwiLnRhYi1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByZXZpb3VzU2libGluZy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIGlmICh0aGlzLmhpZGVjb2RlKSB7XG4gICAgICAgICAgICAkKHRoaXMuY29kZURpdikuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBydW5CdXR0b25IYW5kbGVyKCkge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBydW4gYnV0dG9uIHVudGlsIHRoZSBydW4gaXMgZmluaXNoZWQuXG4gICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuUHJvZygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgdGhlcmUgd2FzIGFuIGVycm9yICR7ZX0gcnVubmluZyB0aGUgY29kZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvZ1Jlc3VsdHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nQ3VycmVudEFuc3dlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuQ29hY2hlcygpO1xuICAgICAgICB0aGlzLnJlbmRlckZlZWRiYWNrKCk7XG4gICAgICAgIC8vIFRoZSBydW4gaXMgZmluaXNoZWQ7IHJlLWVuYWJsZSB0aGUgYnV0dG9uLlxuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJ1bkNvdW50ICs9IDE7XG4gICAgICAgIHRoaXMudG9nZ2xlQWxlcnQoKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb250cm9scygpIHtcbiAgICAgICAgdmFyIGN0cmxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgYnV0dDtcbiAgICAgICAgJChjdHJsRGl2KS5hZGRDbGFzcyhcImFjX2FjdGlvbnNcIik7XG4gICAgICAgIC8vIFJ1blxuICAgICAgICBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgJChidXR0KS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3J1bl9jb2RlXCIpKTtcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImJ0biBidG4tc3VjY2VzcyBydW4tYnV0dG9uXCIpO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xuICAgICAgICB0aGlzLnJ1bkJ1dHRvbiA9IGJ1dHQ7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYWRkaW5nIGNsaWNrIGZ1bmN0aW9uIGZvciBydW5cIik7XG4gICAgICAgIHRoaXMucnVuQnV0dG9uLm9uY2xpY2sgPSB0aGlzLnJ1bkJ1dHRvbkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcblxuICAgICAgICBpZiAodGhpcy5lbmFibGVkb3dubG9hZCB8fCBlQm9va0NvbmZpZy5kb3dubG9hZHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERvd25sb2FkQnV0dG9uKGN0cmxEaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oaWRlY29kZSAmJiAhdGhpcy5oaWRlaGlzdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5hZGRIaXN0b3J5U2NydWJiZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQodGhpcy5vcmlnRWxlbSkuZGF0YShcImdyYWRlYnV0dG9uXCIpICYmICF0aGlzLmdyYWRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRGZWVkYmFja0J1dHRvbihjdHJsRGl2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG93L0hpZGUgQ29kZVxuICAgICAgICBpZiAodGhpcy5oaWRlY29kZSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVIaWRlU2hvdyhjdHJsRGl2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb2RlTGVuc1xuICAgICAgICBpZiAoJCh0aGlzLm9yaWdFbGVtKS5kYXRhKFwiY29kZWxlbnNcIikgJiYgIXRoaXMuZ3JhZGVyYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUNvZGVMZW5zKGN0cmxEaXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29kZSByZWZvcm1hdHRpbmdcbiAgICAgICAgaWYgKHJlZm9ybWF0YWJsZS5oYXModGhpcy5sYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUmVmb3JtYXQoY3RybERpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdWRpbyBUb3VyXG4gICAgICAgIGlmICgkKHRoaXMub3JpZ0VsZW0pLmRhdGEoXCJhdWRpb1wiKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVBdWRpb1RvdXJzKGN0cmxEaXYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlQm9va0NvbmZpZy5pc0luc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlSW5zdHJ1Y3RvclNoYXJpbmcoY3RybERpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGFydG5lcikge1xuICAgICAgICAgICAgdGhpcy5zZXR1cFBhcnRuZXIoY3RybERpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhdGNvZGVzICYmIGVCb29rQ29uZmlnLmVuYWJsZV9jaGF0Y29kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2hhdENvZGVzKGN0cmxEaXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzLm91dGVyRGl2KS5wcmVwZW5kKGN0cmxEaXYpO1xuICAgICAgICBpZiAodGhpcy5xdWVzdGlvbikge1xuICAgICAgICAgICAgaWYgKCQodGhpcy5xdWVzdGlvbikuaHRtbCgpLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgICAgICAgICAgICAgICQodGhpcy5xdWVzdGlvbikucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQodGhpcy5vdXRlckRpdikucHJlcGVuZCh0aGlzLnF1ZXN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xEaXYgPSBjdHJsRGl2O1xuICAgIH1cblxuICAgIGFkZEZlZWRiYWNrQnV0dG9uKGN0cmxEaXYpIHtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgJChidXR0KS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfZmVlZGJhY2tcIikpO1xuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy5ncmFkZUJ1dHRvbiA9IGJ1dHQ7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XG4gICAgICAgICQoYnV0dCkuY2xpY2sodGhpcy5jcmVhdGVHcmFkZVN1bW1hcnkuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgYWRkRG93bmxvYWRCdXR0b24oY3RybERpdikge1xuICAgICAgICBsZXQgYnV0dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgICQoYnV0dCkudGV4dChcIkRvd25sb2FkXCIpO1xuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYnRuIHNhdmUtYnV0dG9uXCIpO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xuICAgICAgICB0aGlzLmRvd25sb2FkQnV0dG9uID0gYnV0dDtcbiAgICAgICAgJChidXR0KS5jbGljayh0aGlzLmRvd25sb2FkRmlsZS5iaW5kKHRoaXMsIHRoaXMubGFuZ3VhZ2UpKTtcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcbiAgICB9XG5cbiAgICBlbmFibGVIaWRlU2hvdyhjdHJsRGl2KSB7XG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICBsZXQgYnV0dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgICQoYnV0dCkuYWRkQ2xhc3MoXCJhY19vcHQgYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlXCIpKTtcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XG4gICAgICAgICQoYnV0dCkuYXR0cihcInR5cGVcIiwgXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMuc2hvd0hpZGVCdXR0ID0gYnV0dDtcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChidXR0KTtcbiAgICAgICAgJChidXR0KS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMuY29kZURpdikudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlzdG9yeVNjcnViYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRIaXN0b3J5U2NydWJiZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlci5wYXJlbnRFbGVtZW50KS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuc2hvd0hpZGVCdXR0KS50ZXh0KCkgPT1cbiAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlXCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5zaG93SGlkZUJ1dHQpLnRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVcIilcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuc2hvd0hpZGVCdXR0KS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlXCIpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGVuYWJsZUNvZGVMZW5zKGN0cmxEaXYpIHtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgJChidXR0KS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZWxlbnNcIikpO1xuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcbiAgICAgICAgdGhpcy5jbEJ1dHRvbiA9IGJ1dHQ7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XG4gICAgICAgICQoYnV0dCkuY2xpY2sodGhpcy5zaG93Q29kZWxlbnMuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZW5hYmxlUmVmb3JtYXQoY3RybERpdikge1xuICAgICAgICBsZXQgYnV0dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgICQoYnV0dCkuYWRkQ2xhc3MoXCJhY19vcHQgYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcmVmb3JtYXRcIikpO1xuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcbiAgICAgICAgdGhpcy5yZWZvcm1hdEJ1dHRvbiA9IGJ1dHQ7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XG4gICAgICAgICQoYnV0dCkuY2xpY2sodGhpcy5yZWZvcm1hdC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBlbmFibGVBdWRpb1RvdXJzKGN0cmxEaXYpIHtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgJChidXR0KS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F1ZGlvX3RvdXJcIikpO1xuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcbiAgICAgICAgdGhpcy5hdEJ1dHRvbiA9IGJ1dHQ7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XG4gICAgICAgICQoYnV0dCkuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3IEF1ZGlvVG91cihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMub3JpZ0VsZW0pLmRhdGEoXCJhdWRpb1wiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBlbmFibGVJbnN0cnVjdG9yU2hhcmluZyhjdHJsRGl2KSB7XG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImJ0biBidG4taW5mb1wiKTtcbiAgICAgICAgJChidXR0KS50ZXh0KFwiU2hhcmUgQ29kZVwiKTtcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XG4gICAgICAgIHRoaXMuc2hhcmVCdXR0ID0gYnV0dDtcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChidXR0KTtcbiAgICAgICAgJChidXR0KS5jbGljayhcbiAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFjb25maXJtKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJZb3UgYXJlIGFib3V0IHRvIHNoYXJlIHRoaXMgY29kZSB3aXRoIEFMTCBvZiB5b3VyIHN0dWRlbnRzLiAgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNvbnRpbnVlP1wiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRoaXMuZWRpdG9yLmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgIGxhbmc6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICBlQm9va0NvbmZpZy5hamF4VVJMICsgXCJicm9hZGNhc3RfY29kZS5qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmpzb25IZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxldCBwb3N0X3Byb21pc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXBvc3RfcHJvbWlzZS5vaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdF9wcm9taXNlLnN0YXR1cyA9PT0gMzAzIHx8IHBvc3RfcHJvbWlzZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJZb3UgbXVzdCBiZSBsb2dnZWQgaW4gdG8gc2hhcmUgY29kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiU2hhcmluZyBGYWlsZWQgcmV0dXJuIHN0YXR1czogJHtwb3N0X3Byb21pc2Uuc3RhdHVzfVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSBhd2FpdCBwb3N0X3Byb21pc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMubWVzcyA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoYFNoYXJlZCBDb2RlIHdpdGggJHtzdGF0dXMuc2hhcmVfY291bnR9IHN0dWRlbnRzYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJTaGFyaW5nIEZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXR1cFBhcnRuZXIoY3RybERpdikge1xuICAgICAgICB2YXIgY2hlY2tQYXJ0bmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBjaGVja1BhcnRuZXIudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgY2hlY2tQYXJ0bmVyLmlkID0gYCR7dGhpcy5kaXZpZH1fcGFydGA7XG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoY2hlY2tQYXJ0bmVyKTtcbiAgICAgICAgdmFyIHBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgcGxhYmVsLmZvciA9IGAke3RoaXMuZGl2aWR9X3BhcnRgO1xuICAgICAgICAkKHBsYWJlbCkudGV4dChcIlBhaXI/XCIpO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKHBsYWJlbCk7XG4gICAgICAgICQoY2hlY2tQYXJ0bmVyKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJ0bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydG5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkKHBhcnRuZXJUZXh0Qm94KS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydG5lciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRuZXJUZXh0Qm94LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgJChwbGFiZWwpLnRleHQoXCJQYWlyP1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlkQWdyZWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInBhcnRuZXJBZ3JlZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWRBZ3JlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkQWdyZWUgPSBjb25maXJtKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUGFpciBQcm9ncmFtbWluZyBzaG91bGQgb25seSBiZSB1c2VkIHdpdGggdGhlIGNvbnNlbnQgb2YgeW91ciBpbnN0cnVjdG9yLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJZb3VyIHBhcnRuZXIgbXVzdCBiZSBhIHJlZ2lzdGVyZWQgbWVtYmVyIG9mIHRoZSBjbGFzcyBhbmQgaGF2ZSBhZ3JlZWQgdG8gcGFpciB3aXRoIHlvdS5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQnkgY2xpY2tpbmcgT0sgeW91IGNlcnRpZnkgdGhhdCBib3RoIG9mIHRoZXNlIGNvbmRpdGlvbnMgaGF2ZSBiZWVuIG1ldC5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWRBZ3JlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwicGFydG5lckFncmVlXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydG5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICQocGxhYmVsKS50ZXh0KFwid2l0aDogXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKHBhcnRuZXJUZXh0Qm94KS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBwYXJ0bmVyVGV4dEJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgcGFydG5lclRleHRCb3gudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKHBhcnRuZXJUZXh0Qm94KTtcbiAgICAgICAgJChwYXJ0bmVyVGV4dEJveCkuaGlkZSgpO1xuICAgICAgICAkKHBhcnRuZXJUZXh0Qm94KS5jaGFuZ2UoXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0bmVyID0gcGFydG5lclRleHRCb3gudmFsdWU7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IG9ic29sZXRlLiAgTm90IHN1cmUgaWYgYW55b25lIGF0IE1pY2hpZ2FuIHdpbGwgY29tZSBiYWNrXG4gICAgLy8gdG8gd29ya2luZyBvbiB0aGlzIGFnYWluLlxuICAgIGVuYWJsZUNoYXRDb2RlcyhjdHJsRGl2KSB7XG4gICAgICAgIHZhciBjaGF0QmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIGNoYW5uZWxzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHZhciB0b3BpYyA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgXCItXCIgKyB0aGlzLmRpdmlkO1xuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGNoYXRCYXIpO1xuICAgICAgICAkKGNoYXRCYXIpLnRleHQoXCJDaGF0OiBcIik7XG4gICAgICAgICQoY2hhdEJhcikuYXBwZW5kKGNoYW5uZWxzKTtcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImFjX29wdCBidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgICQoYnV0dCkudGV4dChcIkNyZWF0ZSBDaGFubmVsXCIpO1xuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcbiAgICAgICAgJChidXR0KS5hdHRyKFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpO1xuICAgICAgICAkKGJ1dHQpLmF0dHIoXG4gICAgICAgICAgICBcImhyZWZcIixcbiAgICAgICAgICAgIFwiaHR0cDovL1wiICtcbiAgICAgICAgICAgICAgICBjaGF0Y29kZXNTZXJ2ZXIgK1xuICAgICAgICAgICAgICAgIFwiL25ldz9cIiArXG4gICAgICAgICAgICAgICAgJC5wYXJhbSh7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljOiB3aW5kb3cubG9jYXRpb24uaG9zdCArIFwiLVwiICsgdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZzogXCJQeXRob25cIixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNoYXRCdXR0b24gPSBidXR0O1xuICAgICAgICBjaGF0QmFyLmFwcGVuZENoaWxkKGJ1dHQpO1xuICAgICAgICB2YXIgdXBkYXRlQ2hhdENvZGVzQ2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRvYy5kYXRhO1xuICAgICAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICAgICAgJChjaGFubmVscykuaHRtbChcIlwiKTtcbiAgICAgICAgICAgIGRhdGFbXCJjaGFubmVsc1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFubmVsLmFyY2hpdmVkICYmIHRvcGljID09PSBjaGFubmVsLnRvcGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rID0gJChcIjxhIC8+XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly9cIiArIGNoYXRjb2Rlc1NlcnZlciArIFwiL1wiICsgY2hhbm5lbC5jaGFubmVsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbGluay5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnRleHQoXCIgXCIgKyBjaGFubmVsLmNoYW5uZWxOYW1lICsgXCIoXCIgKyBpICsgXCIpIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgJChjaGFubmVscykuYXBwZW5kKGxpbmspO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICQoY2hhbm5lbHMpLnRleHQoXCIobm8gYWN0aXZlIGNvbnZlcnN0YXRpb25zIG9uIHRoaXMgcHJvYmxlbSlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvYy5zdWJzY3JpYmUodXBkYXRlQ2hhdENvZGVzQ2hhbm5lbHMpO1xuICAgICAgICBkb2Mub24oXCJvcFwiLCB1cGRhdGVDaGF0Q29kZXNDaGFubmVscyk7XG4gICAgfVxuXG4gICAgZW5hYmxlU2F2ZUxvYWQoKSB7XG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2F2ZV9ydW5cIikpO1xuICAgIH1cblxuICAgIC8vIF9gYWRkSGlzdG9yeVNjcnViYmVyYFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFjdGl2ZWNvZGUgLS0gSWYgdGhlIGNvZGUgaGFzIG5vdCBjaGFuZ2VkIHdydCB0aGUgc2NydWJiZXIgcG9zaXRpb24gdmFsdWUgdGhlbiBkb24ndCBzYXZlIHRoZSBjb2RlIG9yIHJlcG9zaXRpb24gdGhlIHNjcnViYmVyXG4gICAgLy8gIC0tIHN0aWxsIGNhbGwgcnVubG9nLCBidXQgYWRkIGEgcGFyYW1ldGVyIHRvIG5vdCBzYXZlIHRoZSBjb2RlXG4gICAgLy8gYWRkIGFuIGluaXRpYWwgbG9hZCBoaXN0b3J5IGJ1dHRvblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGVkaXQgdGhlbiB0aGVyZSBpcyBubyBhcHBlbmQgICB0b19zYXZlIChUcnVlL0ZhbHNlKVxuICAgIGFzeW5jIGFkZEhpc3RvcnlTY3J1YmJlcihwb3NfbGFzdCkge1xuICAgICAgICB0aGlzLmFkZGluZ1NjcnViYmVyID0gdHJ1ZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB2YXIgcmVxRGF0YSA9IHtcbiAgICAgICAgICAgIGFjaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnNpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXFEYXRhW1wic2lkXCJdID0gdGhpcy5zaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJiZWZvcmUgZ2V0IGhpc3RcIik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGVCb29rQ29uZmlnLnByYWN0aWNlX21vZGUgfHxcbiAgICAgICAgICAgICFlQm9va0NvbmZpZy5pc0xvZ2dlZEluIHx8XG4gICAgICAgICAgICAodGhpcy5pc1RpbWVkICYmICF0aGlzLmFzc2Vzc21lbnRUYWtlbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRpbWVkIGFuZCBhbHJlYWR5IHRha2VuIHdlIHNob3VsZCByZXN0b3JlIGhpc3RvcnkgaW5mb1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTY3J1YmJlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcbiAgICAgICAgICAgICAgICBgJHtlQm9va0NvbmZpZy5uZXdfc2VydmVyX3ByZWZpeH0vYXNzZXNzbWVudC9nZXRoaXN0YCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcURhdGEpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGdldCB0aGUgaGlzdG9yeSBkYXRhOiAke2RhdGEuZGV0YWlsfWBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhpc3RvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmhpc3RvcnkuY29uY2F0KGRhdGEuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gZGF0YS50aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShkYXRhLnRpbWVzdGFtcHNbdF0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVuYWJsZSB0byBmZXRjaCBoaXN0b3J5OiAke2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbmRlclNjcnViYmVyKHBvc19sYXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZGluZ1NjcnViYmVyID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbiAgICB9XG5cbiAgICByZW5kZXJTY3J1YmJlcihwb3NfbGFzdCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm1ha2luZyBhIG5ldyBzY3J1YmJlclwiKTtcbiAgICAgICAgdmFyIHNjcnViYmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgJChzY3J1YmJlckRpdikuY3NzKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKTtcbiAgICAgICAgJChzY3J1YmJlckRpdikuY3NzKFwibWFyZ2luLWxlZnRcIiwgXCIxMHB4XCIpO1xuICAgICAgICAkKHNjcnViYmVyRGl2KS5jc3MoXCJtYXJnaW4tcmlnaHRcIiwgXCIxMHB4XCIpO1xuICAgICAgICAkKHNjcnViYmVyRGl2KS5jc3Moe1xuICAgICAgICAgICAgXCJtaW4td2lkdGhcIjogXCIyMDBweFwiLFxuICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogXCIzMDBweFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNjcnViYmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXBQID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMuc2xpZGVpdCA9IGZ1bmN0aW9uIChldiwgZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRoaXMuaGlzdG9yeVskKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKV0pO1xuICAgICAgICAgICAgdmFyIGN1clZhbCA9IHRoaXMudGltZXN0YW1wc1skKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKV07XG4gICAgICAgICAgICBsZXQgcG9zID0gJChzY3J1YmJlcikuc2xpZGVyKFwidmFsdWVcIik7XG4gICAgICAgICAgICBsZXQgb3V0T2YgPSB0aGlzLmhpc3RvcnkubGVuZ3RoO1xuICAgICAgICAgICAgJCh0aGlzLnRpbWVzdGFtcFApLnRleHQoYCR7Y3VyVmFsfSAtICR7cG9zICsgMX0gb2YgJHtvdXRPZn1gKTtcbiAgICAgICAgICAgIC8vIGEgc2xpZGUgd2lsbCBhbHNvIHJlc3VsdCBpbiBhIHNsaWRlY2hhbmdlIGV2ZW50IHdlIGRvbid0IHdhbnQgdG8gZG91YmxlXG4gICAgICAgICAgICAvLyBsb2cgdGhlc2UgZXZlbnRzLiAgU28gZG8gbm90IGxvZyB0aGUgc2xpZGUgdW50aWwgaXQgc3RvcHMgYW5kIGNyZWF0ZXMgdGhlIGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChldiAhPT0gbnVsbCAmJiBldi50eXBlICE9IFwic2xpZGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYWN0aXZlY29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Q6IFwic2xpZGU6XCIgKyBjdXJWYWwsXG4gICAgICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJChzY3J1YmJlcikuc2xpZGVyKHtcbiAgICAgICAgICAgIG1heDogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXG4gICAgICAgIH0pO1xuICAgICAgICAkKHNjcnViYmVyKS5jc3MoXCJtYXJnaW5cIiwgXCIxMHB4XCIpO1xuICAgICAgICAkKHNjcnViYmVyKS5vbihcInNsaWRlXCIsIHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgJChzY3J1YmJlcikub24oXCJzbGlkZWNoYW5nZVwiLCB0aGlzLnNsaWRlaXQuYmluZCh0aGlzKSk7XG4gICAgICAgIHNjcnViYmVyRGl2LmFwcGVuZENoaWxkKHNjcnViYmVyKTtcbiAgICAgICAgc2NydWJiZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy50aW1lc3RhbXBQKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkZWFkbGluZSBzZXQgdGhlbiBwb3NpdGlvbiB0aGUgc2NydWJiZXIgYXQgdGhlIGxhc3Qgc3VibWlzc2lvblxuICAgICAgICAvLyBwcmlvciB0byB0aGUgZGVhZGxpbmVcbiAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmUpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMuaGlzdG9yeS5sZW5ndGggJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUodGhpcy50aW1lc3RhbXBzW2ldKSA+IHRoaXMuZGVhZGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBpIC0gMTtcbiAgICAgICAgICAgIHNjcnViYmVyLnZhbHVlID0gTWF0aC5tYXgoaSwgMCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0aGlzLmhpc3Rvcnlbc2NydWJiZXIudmFsdWVdKTtcbiAgICAgICAgICAgICQoc2NydWJiZXIpLnNsaWRlcihcInZhbHVlXCIsIHNjcnViYmVyLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NfbGFzdCkge1xuICAgICAgICAgICAgc2NydWJiZXIudmFsdWUgPSB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRoaXMuaGlzdG9yeVtzY3J1YmJlci52YWx1ZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NydWJiZXIudmFsdWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb3MgPSAkKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKTtcbiAgICAgICAgbGV0IG91dE9mID0gdGhpcy5oaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgbGV0IHRzID0gdGhpcy50aW1lc3RhbXBzWyQoc2NydWJiZXIpLnNsaWRlcihcInZhbHVlXCIpXTtcbiAgICAgICAgJCh0aGlzLnRpbWVzdGFtcFApLnRleHQoYCR7dHN9IC0gJHtwb3MgKyAxfSBvZiAke291dE9mfWApO1xuICAgICAgICB0aGlzLmhpc3RvcnlTY3J1YmJlciA9IHNjcnViYmVyO1xuICAgICAgICAkKHNjcnViYmVyRGl2KS5pbnNlcnRBZnRlcih0aGlzLnJ1bkJ1dHRvbik7XG4gICAgfSAvLyBlbmQgZGVmaW5pdGlvbiBvZiBoZWxwZXJcblxuICAgIGNyZWF0ZU91dHB1dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcGFyZW50IGRpdiB3aXRoIHR3byBlbGVtZW50czogIHByZSBmb3Igc3RhbmRhcmQgb3V0cHV0IGFuZCBhIGRpdlxuICAgICAgICAvLyB0byBob2xkIHR1cnRsZSBncmFwaGljcyBvdXRwdXQuICBXZSB1c2UgYSBkaXYgaW4gY2FzZSB0aGUgdHVydGxlIGNoYW5nZXMgZnJvbVxuICAgICAgICAvLyB1c2luZyBhIGNhbnZhcyB0byB1c2luZyBzb21lIG90aGVyIGVsZW1lbnQgbGlrZSBzdmcgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgdmFyIG91dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImFjX291dHB1dFwiKTtcbiAgICAgICAgdGhpcy5vdXREaXYgPSBvdXREaXY7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgdGhpcy5vdXRwdXQuaWQgPSB0aGlzLmRpdmlkICsgXCJfc3Rkb3V0XCI7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcIm1heC1oZWlnaHRcIiwgXCI0MDBweFwiKTtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5pZCA9IHRoaXMuZGl2aWQgKyBcIl9ncmFwaGljc1wiO1xuICAgICAgICAkKHRoaXMuZ3JhcGhpY3MpLmFkZENsYXNzKFwiYWMtY2FudmFzXCIpO1xuICAgICAgICAvLyBUaGlzIGJpdCBvZiBtYWdpYyBhZGRzIGFuIGV2ZW50IHdoaWNoIHdhaXRzIGZvciBhIGNhbnZhcyBjaGlsZCB0byBiZSBjcmVhdGVkIG9uIG91clxuICAgICAgICAvLyBuZXdseSBjcmVhdGVkIGRpdi4gIFdoZW4gYSBjYW52YXMgY2hpbGQgaXMgYWRkZWQgd2UgYWRkIGEgbmV3IGNsYXNzIHNvIHRoYXQgdGhlIHZpc2libGVcbiAgICAgICAgLy8gY2FudmFzIGNhbiBiZSBzdHlsZWQgaW4gQ1NTLiAgV2hpY2ggYSB0aGUgbW9tZW50IG1lYW5zIGp1c3QgYWRkaW5nIGEgYm9yZGVyLlxuICAgICAgICAkKHRoaXMuZ3JhcGhpY3MpLm9uKFxuICAgICAgICAgICAgXCJET01Ob2RlSW5zZXJ0ZWRcIixcbiAgICAgICAgICAgIFwiY2FudmFzXCIsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmdyYXBoaWNzKS5hZGRDbGFzcyhcInZpc2libGUtYWMtY2FudmFzXCIpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGNvYWNoRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY29hY2hEaXYuY2xhc3NMaXN0LmFkZChcImFsZXJ0XCIsIFwiYWxlcnQtd2FybmluZ1wiLCBcImNvZGVjb2FjaFwiKTtcbiAgICAgICAgJChjb2FjaERpdikuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIGxldCBjb2FjaEhlYWQgPSBjb2FjaERpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDNcIikpO1xuICAgICAgICBjb2FjaEhlYWQudGV4dENvbnRlbnQgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9jb2RlX2NvYWNoXCIpO1xuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGNvYWNoRGl2KTtcbiAgICAgICAgdGhpcy5jb2RlY29hY2ggPSBjb2FjaERpdjtcblxuICAgICAgICBvdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5vdXRwdXQpO1xuICAgICAgICBvdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5ncmFwaGljcyk7XG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQob3V0RGl2KTtcbiAgICAgICAgdmFyIGxlbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBsZW5zRGl2LmNsYXNzTGlzdC5hZGQoXCJjb2RlbGVuc1wiKTtcbiAgICAgICAgbGVuc0Rpdi5pZCA9IGAke3RoaXMuZGl2aWR9X2NvZGVsZW5zYDtcbiAgICAgICAgJChsZW5zRGl2KS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgdGhpcy5jb2RlbGVucyA9IGxlbnNEaXY7XG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQobGVuc0Rpdik7XG4gICAgfVxuXG4gICAgZGlzYWJsZVNhdmVMb2FkKCkge1xuICAgICAgICAkKHRoaXMuc2F2ZUJ1dHRvbikuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLnNhdmVCdXR0b24pLmF0dHIoXCJ0aXRsZVwiLCBcIkxvZ2luIHRvIHNhdmUgeW91ciBjb2RlXCIpO1xuICAgICAgICAkKHRoaXMubG9hZEJ1dHRvbikuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLmxvYWRCdXR0b24pLmF0dHIoXCJ0aXRsZVwiLCBcIkxvZ2luIHRvIGxvYWQgeW91ciBjb2RlXCIpO1xuICAgIH1cblxuICAgIGRvd25sb2FkRmlsZShsYW5nKSB7XG4gICAgICAgIHZhciBmbmIgPSB0aGlzLmRpdmlkO1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9XG4gICAgICAgICAgICBmbmIgK1xuICAgICAgICAgICAgXCJfXCIgK1xuICAgICAgICAgICAgZFxuICAgICAgICAgICAgICAgIC50b0pTT04oKVxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgMTApIC8vIHJldmVyc2UgZGF0ZSBmb3JtYXRcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCItXCIpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIikgK1xuICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgbGFuZ3VhZ2VFeHRlbnNpb25zW2xhbmddO1xuICAgICAgICB2YXIgY29kZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChcIkJsb2JcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0VG9Xcml0ZSA9IGNvZGUucmVwbGFjZSgvXFxuL2csIFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgdmFyIHRleHRGaWxlQXNCbG9iID0gbmV3IEJsb2IoW3RleHRUb1dyaXRlXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXCJtc1NhdmVPck9wZW5CbG9iXCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IodGV4dEZpbGVBc0Jsb2IsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5pbm5lckhUTUwgPSBcIkRvd25sb2FkIEZpbGVcIjtcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHRleHRGaWxlQXNCbG9iKTtcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIEhUTUw1IEJsb2IuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlR3JhZGVTdW1tYXJ5KCkge1xuICAgICAgICAvLyBnZXQgZ3JhZGUgYW5kIGNvbW1lbnRzIGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICAgICAgLy8gZ2V0IHN1bW1hcnkgb2YgYWxsIGdyYWRlcyBmb3IgdGhpcyBzdHVkZW50XG4gICAgICAgIC8vIGRpc3BsYXkgZ3JhZGVzIGluIG1vZGFsIHdpbmRvd1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChlQm9va0NvbmZpZy5hamF4VVJMICsgXCJnZXRhc3NpZ25tZW50Z3JhZGVcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJlcG9ydFsnbWVzc2FnZSddXG4gICAgICAgIGlmIChyZXBvcnQpIHtcbiAgICAgICAgICAgIGlmIChyZXBvcnRbXCJ2ZXJzaW9uXCJdID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgdmVyc2lvbjsgd291bGQgYmUgYmV0dGVyIHRvIGVtYmVkIHRoaXMgaW4gSFRNTCBmb3IgdGhlIGFjdGl2ZWNvZGVcbiAgICAgICAgICAgICAgICBib2R5ID1cbiAgICAgICAgICAgICAgICAgICAgXCI8aDQ+R3JhZGUgUmVwb3J0PC9oND5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiPHA+VGhpcyBxdWVzdGlvbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJncmFkZVwiXTtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0W1wicmVsZWFzZWRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSArPSBcIiBvdXQgb2YgXCIgKyByZXBvcnRbXCJtYXhcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkgKz0gXCI8L3A+IDxwPlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRbXCJyZWxlYXNlZFwiXSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ICs9IFwiUHJlbGltaW5hcnkgQ29tbWVudHM6IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib2R5ICs9IHJlcG9ydFtcImNvbW1lbnRcIl0gKyBcIjwvcD5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keSA9XG4gICAgICAgICAgICAgICAgICAgIFwiPGg0PkdyYWRlIFJlcG9ydDwvaDQ+XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIjxwPlRoaXMgYXNzaWdubWVudDogXCIgK1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJncmFkZVwiXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8cD5cIiArXG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFtcImNvbW1lbnRcIl0gK1xuICAgICAgICAgICAgICAgICAgICBcIjwvcD5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiPHA+TnVtYmVyIG9mIGdyYWRlZCBhc3NpZ25tZW50czogXCIgK1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJjb3VudFwiXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8cD5BdmVyYWdlIHNjb3JlOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFtcImF2Z1wiXSArXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IFwiPGg0PlRoZSBzZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IGdyYWRlIGluZm9ybWF0aW9uPC9oND5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaHRtbCA9IGA8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBjb21wYXJlLW1vZGFsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVwibW9kYWwtdGl0bGVcIj5Bc3NpZ25tZW50IEZlZWRiYWNrPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgJHtib2R5fVxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgIHZhciBlbCA9ICQoaHRtbCk7XG4gICAgICAgIGVsLm1vZGFsKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGFzeW5jIHNob3dDb2RlbGVucygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgdGhpcy5jbEJ1dHRvbi5pbm5lclRleHQgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVsZW5zXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB0aGlzLmNsQnV0dG9uLmlubmVyVGV4dCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfaW5fY29kZWxlbnNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsID0gdGhpcy5jb2RlbGVucy5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMucmVtb3ZlQ2hpbGQoY2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlID0gYXdhaXQgdGhpcy5idWlsZFByb2coZmFsc2UpO1xuICAgICAgICB2YXIgbXlWYXJzID0ge307XG4gICAgICAgIG15VmFycy5jb2RlID0gY29kZTtcbiAgICAgICAgbXlWYXJzLm9yaWdpbiA9IFwib3B0LWZyb250ZW5kLmpzXCI7XG4gICAgICAgIG15VmFycy5jdW11bGF0aXZlID0gZmFsc2U7XG4gICAgICAgIG15VmFycy5oZWFwUHJpbWl0aXZlcyA9IGZhbHNlO1xuICAgICAgICBteVZhcnMuZHJhd1BhcmVudFBvaW50ZXJzID0gZmFsc2U7XG4gICAgICAgIG15VmFycy50ZXh0UmVmZXJlbmNlcyA9IGZhbHNlO1xuICAgICAgICBteVZhcnMuc2hvd09ubHlPdXRwdXRzID0gZmFsc2U7XG4gICAgICAgIG15VmFycy5yYXdJbnB1dExzdEpTT04gPSBKU09OLnN0cmluZ2lmeShbXSk7XG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlID09IFwicHl0aG9uXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB5dGhvbjMpIHtcbiAgICAgICAgICAgICAgICBteVZhcnMucHkgPSAzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBteVZhcnMucHkgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFuZ2F1Z2UgPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgIG15VmFycy5weSA9IFwianNcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG15VmFycy5weSA9IHRoaXMubGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgbXlWYXJzLmN1ckluc3RyID0gMDtcbiAgICAgICAgbXlWYXJzLmNvZGVEaXZXaWR0aCA9IDM1MDtcbiAgICAgICAgbXlWYXJzLmNvZGVEaXZIZWlnaHQgPSA0MDA7XG4gICAgICAgIHZhciBzcmNVUkwgPSBcImh0dHBzOi8vcHl0aG9udHV0b3IuY29tL2lmcmFtZS1lbWJlZC5odG1sXCI7XG4gICAgICAgIHZhciBzcmNWYXJzID0gJC5wYXJhbShteVZhcnMpO1xuICAgICAgICB2YXIgZW1iZWRVcmxTdHIgPSBgJHtzcmNVUkx9IyR7c3JjVmFyc31gO1xuICAgICAgICB2YXIgbXlJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBteUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLmRpdmlkICsgXCJfY29kZWxlbnNcIik7XG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICAgICAgbXlJZnJhbWUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiNTAwXCIpO1xuICAgICAgICBteUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgICAgIG15SWZyYW1lLnN0eWxlLmJhY2tncm91bmQgPSBcIiNmZmZcIjtcbiAgICAgICAgLy9teUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIixzcmNVUkwpXG4gICAgICAgIG15SWZyYW1lLnNyYyA9IGVtYmVkVXJsU3RyO1xuICAgICAgICB0aGlzLmNvZGVsZW5zLmFwcGVuZENoaWxkKG15SWZyYW1lKTtcbiAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwiY29kZWxlbnNcIixcbiAgICAgICAgICAgIGFjdDogXCJ2aWV3XCIsXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlZm9ybWF0KCkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXMuZWRpdG9yLmZpcnN0TGluZSgpO1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5lZGl0b3IubGFzdExpbmUoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuaW5kZW50TGluZShpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZm9ybWF0QnV0dG9uLmJsdXIoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVFZGl0b3JWaXNpYmlsaXR5KCkge31cblxuICAgIGFkZEVycm9yTWVzc2FnZShlcnIpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBlcnJvciBtZXNzYWdlXG4gICAgICAgIHRoaXMuZXJyTGFzdFJ1biA9IHRydWU7XG4gICAgICAgIHZhciBlcnJIZWFkID0gJChcIjxoMz5cIikuaHRtbChcIkVycm9yXCIpO1xuICAgICAgICB0aGlzLmVDb250YWluZXIgPSB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVDb250YWluZXIuY2xhc3NOYW1lID0gXCJlcnJvciBhbGVydCBhbGVydC1kYW5nZXJcIjtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyLmlkID0gdGhpcy5kaXZpZCArIFwiX2VycmluZm9cIjtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyLmFwcGVuZENoaWxkKGVyckhlYWRbMF0pO1xuICAgICAgICB2YXIgZXJyVGV4dCA9IHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIilcbiAgICAgICAgKTtcbiAgICAgICAgLy8gQnV0LCBhZGp1c3QgdGhlIGxpbmUgbnVtYmVycy4gIElmIHRoZSBsaW5lIG51bWJlciBpcyA8PSBwcmV0ZXh0TGluZXMgdGhlbiBpdCBpcyBpbiBpbmNsdWRlZCBjb2RlXG4gICAgICAgIC8vIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGluY2x1ZGVkIGxpbmVzIGJ1dCBsZXNzIHRoYW4gdGhlIHByZXRleHQgKyBjdXJyZW50IGVkaXRvciB0aGVuIGl0IGlzIGluIHRoZSBzdHVkZW50IGNvZGUuXG4gICAgICAgIC8vIGFkanVzdCB0aGUgbGluZSBudW1iZXIgd2UgZGlzcGxheSBieSBlbGltaW5hdGluZyB0aGUgcHJlLWluY2x1ZGVkIGNvZGUuXG4gICAgICAgIGlmIChlcnIudHJhY2ViYWNrICYmIGVyci50cmFjZWJhY2subGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgIHZhciBlcnJvckxpbmUgPSBlcnIudHJhY2ViYWNrWzBdLmxpbmVubztcbiAgICAgICAgICAgIGlmIChlcnJvckxpbmUgPD0gdGhpcy5wcmV0ZXh0TGluZXMpIHtcbiAgICAgICAgICAgICAgICBlcnJUZXh0LmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgICAgIFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIGhpZGRlbiwgaW5jbHVkZWQgY29kZS4gU29ycnkgd2UgY2FuJ3QgZ2l2ZSB5b3UgYSBtb3JlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JMaW5lID4gdGhpcy5wcm9nTGluZXMgKyB0aGlzLnByZXRleHRMaW5lcykge1xuICAgICAgICAgICAgICAgIGVyclRleHQuaW5uZXJIVE1MID0gYEFuIGVycm9yIG9jY3VycmVkIGFmdGVyIHRoZSBlbmQgb2YgeW91ciBjb2RlLlxuT25lIHBvc3NpYmxlIHJlYXNvbiBpcyB0aGF0IHlvdSBoYXZlIGFuIHVuY2xvc2VkIHBhcmVudGhlc2lzIG9yIHN0cmluZy5cbkFub3RoZXIgcG9zc2liaWxpdHkgaXMgdGhhdCB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgaGlkZGVuIHRlc3QgY29kZS5cbllldCBhbm90aGVyIGlzIHRoYXQgdGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IuICBUaGUgaW50ZXJuYWwgZXJyb3IgbWVzc2FnZSBpczogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldGV4dExpbmVzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIudHJhY2ViYWNrWzBdLmxpbmVubyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIudHJhY2ViYWNrWzBdLmxpbmVubyAtIHRoaXMucHJldGV4dExpbmVzICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyclN0cmluZyA9IGVyci50b1N0cmluZygpO1xuICAgICAgICB2YXIgdG8gPSBlcnJTdHJpbmcuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIHZhciBlcnJOYW1lID0gZXJyU3RyaW5nLnN1YnN0cmluZygwLCB0byk7XG4gICAgICAgIGVyclRleHQuaW5uZXJIVE1MID0gZXJyU3RyaW5nO1xuICAgICAgICAkKHRoaXMuZUNvbnRhaW5lcikuYXBwZW5kKFwiPGgzPkRlc2NyaXB0aW9uPC9oMz5cIik7XG4gICAgICAgIHZhciBlcnJEZXNjID0gdGhpcy5lQ29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgZXJyRGVzYy5pbm5lckhUTUwgPSBlcnJvclRleHRbZXJyTmFtZV07XG4gICAgICAgICQodGhpcy5lQ29udGFpbmVyKS5hcHBlbmQoXCI8aDM+VG8gRml4PC9oMz5cIik7XG4gICAgICAgIHZhciBlcnJGaXggPSB0aGlzLmVDb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikpO1xuICAgICAgICBlcnJGaXguaW5uZXJIVE1MID0gZXJyb3JUZXh0W2Vyck5hbWUgKyBcIkZpeFwiXTtcbiAgICAgICAgdmFyIG1vcmVJbmZvID0gXCIuLi9FcnJvckhlbHAvXCIgKyBlcnJOYW1lLnRvTG93ZXJDYXNlKCkgKyBcIi5odG1sXCI7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJSdW50aW1lIEVycm9yOiBcIiArIGVyci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgc2V0VGltZUxpbWl0KHRpbWVyKSB7XG4gICAgICAgIHZhciB0aW1lbGltaXQgPSB0aGlzLnRpbWVsaW1pdDtcbiAgICAgICAgaWYgKHRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVsaW1pdCA9IHRpbWVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBleGVjTGltaXQgaW4gbWlsbGlzZWNvbmRzICAtLSBmb3Igc3R1ZGVudCBwcm9qZWN0cyBzZXQgdGhpcyB0b1xuICAgICAgICAvLyAyNSBzZWNvbmRzIC0tIGp1c3QgbGVzcyB0aGFuIENocm9tZSdzIG93biB0aW1lci5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5jb2RlLmluZGV4T2YoXCJvbnRpbWVyXCIpID4gLTEgfHxcbiAgICAgICAgICAgIHRoaXMuY29kZS5pbmRleE9mKFwib25jbGlja1wiKSA+IC0xIHx8XG4gICAgICAgICAgICB0aGlzLmNvZGUuaW5kZXhPZihcIm9ua2V5XCIpID4gLTEgfHxcbiAgICAgICAgICAgIHRoaXMuY29kZS5pbmRleE9mKFwic2V0RGVsYXlcIikgPiAtMVxuICAgICAgICApIHtcbiAgICAgICAgICAgIFNrLmV4ZWNMaW1pdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGltZWxpbWl0ID09PSBcIm9mZlwiKSB7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZWxpbWl0KSB7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gdGltZWxpbWl0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXQgPSAyNTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsdGluUmVhZCh4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVt4XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgIClcbiAgICAgICAgICAgIHRocm93ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ZpbGVfbm90X2ZvdW5kXCIsIHgpO1xuICAgICAgICByZXR1cm4gU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1beF07XG4gICAgfVxuICAgIGZpbGVSZWFkZXIoZGl2aWQpIHtcbiAgICAgICAgLy8gSW4gdGhlIGJlZ2lubmluZyBmaWxlcyB3ZXJlIGp1c3QgcHJlIHRhZ3MgYW5kIHdlIHVzZWQgdGhlIGRpdmlkIGFzIHRoZSBmaWxlbmFtZVxuICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkKTtcbiAgICAgICAgLy8gSW4gUHJlVGVYdCB3ZSBtb3ZlZCB0aGF0IHRvIGEgQGRhdGEtZmlsZW5hbWVcbiAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1maWxlbmFtZT1cIiR7ZGl2aWR9XCJdYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBcIlwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGVsZW0gPT0gbnVsbCAmJiBTay5idWlsdGluRmlsZXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZGl2aWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZGl2aWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdHJ5IHJlbW90ZSBmaWxlIHVubGVzcyBpdCBlbmRzIHdpdGggLmpzIG9yIC5weSAtLSBvdGhlcndpc2Ugd2UnbGwgYXNrIHRoZSBzZXJ2ZXIgZm9yIGFsbFxuICAgICAgICAgICAgLy8ga2luZHMgb2YgbW9kdWxlcyB0aGF0IHdlIGFyZSB0cnlpbmcgdG8gaW1wb3J0XG4gICAgICAgICAgICBpZiAoIShkaXZpZC5lbmRzV2l0aChcIi5qc1wiKSB8fCBkaXZpZC5lbmRzV2l0aChcIi5weVwiKSkpIHtcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYC9ydW5lc3RvbmUvYWpheC9nZXRfZGF0YWZpbGU/Y291cnNlX2lkPSR7ZUJvb2tDb25maWcuY291cnNlfSZhY2lkPSR7ZGl2aWR9YCxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSkuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbSA9PSBudWxsICYmIHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcbiAgICAgICAgICAgICAgICAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9ub19maWxlX29yX2RpclwiLCBkaXZpZClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIGVhcmx5IG9uIHdlIGhhZCB0ZXh0YXJlYSB3aXRoIHRoZSBkaXZpZCBvbiBpdC5cbiAgICAgICAgICAgIC8vIGJ1dCBsYXRlciB0aGlzIHN3aXRjaGVkIHRvIGEgcnVuZXN0b25lIHdyYXBwZXIuICBTbyB3ZSBtYXkgbmVlZCB0byBkaWcgZm9yIGEgcHJlXG4gICAgICAgICAgICAvLyBvciBhIHRleHRhcmVhP1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZWxlbS52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZSA9IGVsZW0ucXVlcnlTZWxlY3RvcihcInByZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwcmUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBvdXRwdXRmdW4odGV4dCkge1xuICAgICAgICAvLyBibm0gcHl0aG9uIDNcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0TGluZUNvdW50ID4gMTAwMCkgcmV0dXJuO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcbiAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIFwiPGJyLz5cIik7XG4gICAgICAgIC8vIHRvZG86IHRyeSB0byBtYWtlIHRoaXMgdXNlIHRoZSBzdXNwZW5zaW9uIG1lY2hhbmlzbSBpbiBza3VscHRcbiAgICAgICAgcmV0dXJuIG5ldyBTay5taXNjZXZhbC5wcm9taXNlVG9TdXNwZW5zaW9uKFxuICAgICAgICAgICAgbmV3IFByb21pc2UoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRMaW5lQ291bnQgPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5vdXRwdXQpLmFwcGVuZCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRMaW5lQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShTay5idWlsdGluLm5vbmUubm9uZSQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dExpbmVDb3VudCA9PSAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMub3V0cHV0KS5hcHBlbmQoXCJUb28gTXVjaCBvdXRwdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dExpbmVDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcEV4ZWN1dGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZmlsZXdyaXRlcihmb2JqLCBieXRlcykge1xuICAgICAgICBsZXQgZmlsZWNvbXBvbmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvYmoubmFtZSk7XG4gICAgICAgIGlmICghZmlsZWNvbXBvbmVudCkge1xuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAkKGNvbnRhaW5lcikuYWRkQ2xhc3MoXCJydW5lc3RvbmVcIik7XG4gICAgICAgICAgICBsZXQgdGFiID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICQodGFiKS5hZGRDbGFzcyhcImRhdGFmaWxlX2NhcHRpb25cIik7XG4gICAgICAgICAgICB0YWIuaW5uZXJIVE1MID0gYERhdGEgZmlsZTogPGNvZGU+JHtmb2JqLm5hbWV9PC9jb2RlPmA7XG4gICAgICAgICAgICBmaWxlY29tcG9uZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICAgICAgZmlsZWNvbXBvbmVudC5yb3dzID0gMTA7XG4gICAgICAgICAgICBmaWxlY29tcG9uZW50LmNvbHMgPSA1MDtcbiAgICAgICAgICAgIGZpbGVjb21wb25lbnQuaWQgPSBmb2JqLm5hbWU7XG4gICAgICAgICAgICAkKGZpbGVjb21wb25lbnQpLmNzcyhcIm1hcmdpbi1ib3R0b21cIiwgXCI1cHhcIik7XG4gICAgICAgICAgICAkKGZpbGVjb21wb25lbnQpLmFkZENsYXNzKFwiYWNfb3V0cHV0XCIpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRhYik7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsZWNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9iai5wb3MkID09IDApIHtcbiAgICAgICAgICAgICAgICAkKGZpbGVjb21wb25lbnQpLnZhbChcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9ICQoZmlsZWNvbXBvbmVudCkudmFsKCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICsgYnl0ZXMudjtcbiAgICAgICAgJChmaWxlY29tcG9uZW50KS52YWwoY3VycmVudCk7XG4gICAgICAgICQoZmlsZWNvbXBvbmVudCkuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICBmb2JqLnBvcyQgPSBjdXJyZW50Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQubGVuZ3RoO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEluY2x1ZGVkQ29kZShkaXZpZCkge1xuICAgICAgICBpZiAod2luZG93LmNvbXBvbmVudE1hcFtkaXZpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY29tcG9uZW50TWFwW2RpdmlkXS5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYC9ydW5lc3RvbmUvYWpheC9nZXRfZGF0YWZpbGU/Y291cnNlX2lkPSR7ZUJvb2tDb25maWcuY291cnNlfSZhY2lkPSR7ZGl2aWR9YCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5qc29uSGVhZGVycyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IHdyZXN1bHQgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxldCBvYmogPSBhd2FpdCB3cmVzdWx0Lmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiBvYmouZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGJ1aWxkUHJvZyh1c2VTdWZmaXgpIHtcbiAgICAgICAgLy8gYXNzZW1ibGUgY29kZSBmcm9tIHByZWZpeCwgc3VmZml4LCBhbmQgZWRpdG9yIGZvciBydW5uaW5nLlxuICAgICAgICB2YXIgcHJldGV4dDtcbiAgICAgICAgdmFyIHByb2cgPSB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpICsgXCJcXG5cIjtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICBwcm9nID0gdGhpcy5wcmVmaXggKyBwcm9nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMucHJldGV4dExpbmVzID0gMDtcbiAgICAgICAgdGhpcy5wcm9nTGluZXMgPSBwcm9nLm1hdGNoKC9cXG4vZykubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZXMpIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgaW5jbHVkZXMsIGluLW9yZGVyIHByZXBlbmRpbmcgdG8gcHJvZ1xuICAgICAgICAgICAgcHJldGV4dCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuaW5jbHVkZXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaUNvZGUgPSBhd2FpdCB0aGlzLmdldEluY2x1ZGVkQ29kZSh0aGlzLmluY2x1ZGVzW3hdKTtcbiAgICAgICAgICAgICAgICBwcmV0ZXh0ID0gcHJldGV4dCArIGlDb2RlICsgXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldGV4dCA9IHByZXRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV0ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV0ZXh0TGluZXMgPSAodGhpcy5wcmV0ZXh0Lm1hdGNoKC9cXG4vZykgfHwgXCJcIikubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZyA9IHByZXRleHQgKyBwcm9nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VTdWZmaXggJiYgdGhpcy5zdWZmaXgpIHtcbiAgICAgICAgICAgIHByb2cgPSBwcm9nICsgdGhpcy5zdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9nKTtcbiAgICB9XG5cbiAgICBhc3luYyBtYW5hZ2Vfc2NydWJiZXIoc2F2ZUNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeVNjcnViYmVyID09PSBudWxsICYmICF0aGlzLmF1dG9ydW4pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRkSGlzdG9yeVNjcnViYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5U2NydWJiZXIgJiZcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVskKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKV0gIT1cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgc2F2ZUNvZGUgPSBcIlRydWVcIjtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHRoaXMuZWRpdG9yLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXBzLnB1c2gobmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpKTtcbiAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcbiAgICAgICAgICAgICAgICBcIm9wdGlvblwiLFxuICAgICAgICAgICAgICAgIFwibWF4XCIsXG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5zbGlkZXIoXG4gICAgICAgICAgICAgICAgXCJvcHRpb25cIixcbiAgICAgICAgICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnNsaWRlaXQobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYXZlQ29kZSA9IFwiRmFsc2VcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaXN0b3J5U2NydWJiZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2F2ZUNvZGUgPSBcIkZhbHNlXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhdmVDb2RlO1xuICAgIH1cblxuICAgIGFzeW5jIGNoZWNrQ3VycmVudEFuc3dlcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuUHJvZygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgZXJyb3IgcnVubmluZyBjb2RlICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZSBzaWQgcGFyYW1ldGVyIGlzIG9wdGlvbmFsIGFuZCBpcyB1c2VkIGZvciBncm91cCBzdWJtaXNzaW9uc1xuICAgIGFzeW5jIGxvZ0N1cnJlbnRBbnN3ZXIoc2lkKSB7XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxuICAgICAgICAgICAgY29kZTogdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICAgICAgZXJyaW5mbzogdGhpcy5lcnJpbmZvIHx8IFwiXCIsXG4gICAgICAgICAgICB0b19zYXZlOiB0aGlzLnNhdmVDb2RlIHx8IFwiRlwiLFxuICAgICAgICAgICAgcHJlZml4OiB0aGlzLnByZXRleHQsXG4gICAgICAgICAgICBzdWZmaXg6IHRoaXMuc3VmZml4LFxuICAgICAgICAgICAgcGFydG5lcjogdGhpcy5wYXJ0bmVyLFxuICAgICAgICB9OyAvLyBMb2cgdGhlIHJ1biBldmVudFxuICAgICAgICBpZiAodHlwZW9mIHNpZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZGF0YS5zaWQgPSBzaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5sb2dSdW5FdmVudChkYXRhKTtcbiAgICAgICAgLy8gSWYgdW5pdCB0ZXN0cyB3ZXJlIHJ1biB0aGVyZSB3aWxsIGJlIGEgdW5pdF9yZXN1bHRzXG4gICAgICAgIGlmICh0aGlzLnVuaXRfcmVzdWx0cykge1xuICAgICAgICAgICAgbGV0IHVuaXREYXRhID0ge1xuICAgICAgICAgICAgICAgIGFjdDogdGhpcy51bml0X3Jlc3VsdHMsXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBcInVuaXR0ZXN0XCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzaWQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB1bml0RGF0YS5zaWQgPSBzaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvZ0Jvb2tFdmVudCh1bml0RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBydW5Db2FjaGVzKCkge1xuICAgICAgICAvL1J1biBhbGwgYXZhaWxhYmxlIGNvZGUgY29hY2hlcyBhbmQgdXBkYXRlIGNvZGUgY29hY2ggZGl2XG5cbiAgICAgICAgLy9jbGVhciBhbnl0aGluZyBhZnRlciBoZWFkZXIgaW4gY29kZWNvYWNoIGRpdiBhbmQgaGlkZSBpdFxuICAgICAgICAkKHRoaXMuY29kZWNvYWNoKS5jaGlsZHJlbigpLnNsaWNlKDEpLnJlbW92ZSgpO1xuICAgICAgICAkKHRoaXMuY29kZWNvYWNoKS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblxuICAgICAgICAvL2dldCBjb2RlLCBydW4gY29hY2hlc1xuICAgICAgICBsZXQgY29kZSA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKGZhbHNlKTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29hY2ggb2YgdGhpcy5jb2RlQ29hY2hMaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY29hY2guY2hlY2soY29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9vbmNlIGFsbCBjb2FjaGVzIGFyZSBkb25lLCB1cGRhdGUgZGl2XG4gICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChyZXN1bHRzKS50aGVuKChwcm9taXNlcykgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwcm9taXNlcykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcC52YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBwLnZhbHVlLnRyaW0oKSAhPT0gXCJcIlxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja0Rpdi5jbGFzc0xpc3QuYWRkKFwicHl0aG9uX2NoZWNrX3Jlc3VsdHNcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGVja1ByZSA9IGNoZWNrRGl2LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1ByZS50ZXh0Q29udGVudCA9IHAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29kZWNvYWNoLmFwcGVuZChjaGVja0Rpdik7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5jb2RlY29hY2gpLmNzcyhcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlckZlZWRiYWNrKCkge1xuICAgICAgICAvLyBUaGUgcHl0aG9uIHVuaXQgdGVzdCBjb2RlIGJ1aWxkcyB0aGUgdGFibGUgYXMgaXQgaXMgcnVubmluZyB0aGUgdGVzdHNcbiAgICAgICAgLy8gSW4gXCJub3JtYWxcIiB1c2FnZSB0aGlzIGlzIGRpc3BsYXllZCBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBleGFtIG1vZGUgd2UgbWFrZSBhIGRpdiB3aGljaCBpcyBvZmZzY3JlZW5cbiAgICAgICAgaWYgKHRoaXMudW5pdF9yZXN1bHRzX2RpdmlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51bml0X3Jlc3VsdHNfZGl2aWQuaW5kZXhPZihcIl9vZmZzY3JlZW5fXCIpID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB1ckRpdmlkID0gYCR7dGhpcy5kaXZpZH1fb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c2A7XG4gICAgICAgICAgICAgICAgbGV0IHVuaXRGZWVkYmFjayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVyRGl2aWQpO1xuICAgICAgICAgICAgICAgIGxldCB0bXAgPSBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHVuaXRGZWVkYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcy5vdXRlckRpdikuZmluZChgIyR7dXJEaXZpZH1gKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9ICQodGhpcy5vdXRlckRpdikuZmluZChgIyR7dXJEaXZpZH1gKVswXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQodG1wKS5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB1ckRpdmlkID0gdGhpcy5kaXZpZCArIFwiX3VuaXRfcmVzdWx0c1wiO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLm91dGVyRGl2KS5maW5kKGAjJHt1ckRpdmlkfWApLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5vdXRlckRpdikuZmluZChgIyR7dXJEaXZpZH1fb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c2ApXG4gICAgICAgICAgICAgICAgICAgICAgICAubGVuZ3RoID09IDBcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVyUmVzdWx0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVyRGl2aWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aHkgZG8gd2UgZG8gdGhpcz8gIFRoaXMgZG9lc24ndCBzZWVtIHRvIG1hdHRlciBmb3IgZ3JhZGluZy4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAodXJSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKHVyUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGVBbGVydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfdG9nZ2xlICYmIHRoaXMucnVuQ291bnQgPT0gMykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoaXMuZXJyaW5mbyAhPSBcInN1Y2Nlc3NcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMudW5pdF9yZXN1bHRzLnN1YnN0cmluZyg4LCAxMSkgIT0gMTAwLjBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSGVscCBpcyBBdmFpbGFibGUgVXNpbmcgdGhlIFRvZ2dsZSBRdWVzdGlvbiBTZWxlY3RvciEgWW91IGNhbiB0cnkgdGhlIE1peGVkLXVwIFF1ZXN0aW9uIGZpcnN0LlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcInRvZ2dsZWFsZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdDogXCJIZWxwIGlzIEF2YWlsYWJsZSBVc2luZyB0aGUgVG9nZ2xlIFF1ZXN0aW9uIFNlbGVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIHJ1blByb2cgaGFzIHNldmVyYWwgYXN5bmMgZWxlbWVudHMgdG8gaXQuXG4gICAgICogMS4gU2t1bHB0IHJ1bnMgdGhlIHB5dGhvbiBwcm9ncmFtIGFzeW5jaHJvbm91c2x5XG4gICAgICogMi4gVGhlIGhpc3RvcnkgaXMgcmVzdG9yZWQgYXN5bmNocm9ub3VzbHlcbiAgICAgKiAzLiBMb2dnaW5nIGlzIGFzeW5jaHJvbm91c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2t1bHB0IFByb21pc2UgYW5kIHNvIHRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aGVuIHNrdWxwdCBpcyBmaW5pc2hlZC5cbiAgICAgKiB3aGVuIGZpbmlzaGVkIHRoaXMudW5pdF9yZXN1bHRzIHdpbGwgY29udGFpbiB0aGUgcmVzdWx0cyBvZiBhbnkgdW5pdCB0ZXN0cyB0aGF0IGhhdmUgYmVlbiBydW4uXG4gICAgICogVGhlIHRhYmxlIG9mIHJlc3VsdHMgaXMgY29uc3RydWN0ZWQgYW5kIGFkZGVkIHRvIHRoZSBET00gYnkgdGhlIHB5dGhvbiB1bml0dGVzdC5ndWkgbW9kdWxlIGluIHNrdWxwdC5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHJ1blByb2cobm9VSSwgbG9nUmVzdWx0cykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIHJ1blByb2dcIik7XG4gICAgICAgIHN0b3BFeGVjdXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vdXRwdXRMaW5lQ291bnQgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGxvZ1Jlc3VsdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1Jlc3VsdHMgPSBsb2dSZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9VSSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIG5vVUkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZyA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKHRydWUpO1xuICAgICAgICB0aGlzLnNhdmVDb2RlID0gXCJUcnVlXCI7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLnRleHQoXCJcIik7XG4gICAgICAgIGlmICh0aGlzLnVuaXRfcmVzdWx0c19kaXZpZCkge1xuICAgICAgICAgICAgbGV0IHVyZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgdGhpcy51bml0X3Jlc3VsdHNfZGl2aWQgKyBcIl91bml0X3Jlc3VsdHNcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh1cmRpdikge1xuICAgICAgICAgICAgICAgIHVyZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCQoYCMke3RoaXMuZGl2aWR9X2VycmluZm9gKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkKGAjJHt0aGlzLmRpdmlkfV9lcnJpbmZvYCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8kKHRoaXMuZUNvbnRhaW5lcikucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLmNvZGVsZW5zKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbEJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5jbEJ1dHRvbi5pbm5lclRleHQgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zaG93X2luX2NvZGVsZW5zXCIpO1xuICAgICAgICB9XG4gICAgICAgIFNrLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0ZnVuLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWFkOiB0aGlzLmZpbGVSZWFkZXIsXG4gICAgICAgICAgICBmaWxld3JpdGU6IHRoaXMuZmlsZXdyaXRlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX19mdXR1cmVfXzogU2sucHl0aG9uMyxcbiAgICAgICAgICAgIGtpbGxhYmxlV2hpbGU6IHRydWUsXG4gICAgICAgICAgICBraWxsYWJsZUZvcjogdHJ1ZSxcbiAgICAgICAgICAgIG5vbnJlYWRvcGVuOiB0cnVlLFxuICAgICAgICAgICAgLy8gICAgICAgIHB5dGhvbjM6IHRoaXMucHl0aG9uMyxcbiAgICAgICAgICAgIGltYWdlUHJveHk6IFwiL25zL3JzcHJveHkvaW1hZ2Vwcm94eVwiLFxuICAgICAgICAgICAgaW5wdXRmdW5UYWtlc1Byb21wdDogdHJ1ZSxcbiAgICAgICAgICAgIGpzb25wU2l0ZXM6IFtcImh0dHBzOi8vaXR1bmVzLmFwcGxlLmNvbVwiXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNrLkpvQmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIC8vIEpvQmFzZSAtIGN1cnJlbnRseSBicm9rZW4gLSBuZWVkcyB0aGlzIGNhbnZhcyBlbGVtZW50XG4gICAgICAgIFNrLmRpdmlkID0gdGhpcy5kaXZpZDtcbiAgICAgICAgU2subG9nUmVzdWx0cyA9IGxvZ1Jlc3VsdHM7XG4gICAgICAgIGlmICh0aGlzLmdyYWRlcmFjdGl2ZSAmJiB0aGlzLm91dGVyRGl2LmNsb3Nlc3QoXCIubG9hZGluZ1wiKSkge1xuICAgICAgICAgICAgU2suZ3JhZGVDb250YWluZXIgPSB0aGlzLm91dGVyRGl2LmNsb3Nlc3QoXCIubG9hZGluZ1wiKS5pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFNrLmdyYWRlQ29udGFpbmVyID0gdGhpcy5kaXZpZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFRpbWVMaW1pdCgpO1xuICAgICAgICAoU2suVHVydGxlR3JhcGhpY3MgfHwgKFNrLlR1cnRsZUdyYXBoaWNzID0ge30pKS50YXJnZXQgPSB0aGlzLmdyYXBoaWNzO1xuICAgICAgICBTay5jYW52YXMgPSB0aGlzLmdyYXBoaWNzLmlkOyAvL3RvZG86IGdldCByaWQgb2YgdGhpcyBoZXJlIGFuZCBpbiBpbWFnZVxuICAgICAgICBpZiAoIW5vVUkpIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBhd2FpdCB0aGlzLm1hbmFnZV9zY3J1YmJlcih0aGlzLnNhdmVDb2RlKTtcbiAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikub2ZmKFwic2xpZGVjaGFuZ2VcIik7XG4gICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5zbGlkZXIoXCJkaXNhYmxlXCIpO1xuICAgICAgICAgICAgJCh0aGlzLm91dERpdikuc2hvdyh7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDcwMCxcbiAgICAgICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgU2subWlzY2V2YWwuYXN5bmNUb1Byb21pc2UoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2suaW1wb3J0TWFpbldpdGhCb2R5KFwiPHN0ZGluPlwiLCBmYWxzZSwgcHJvZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1c3BlbnNpb24gaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgXCIqXCI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdG9wRXhlY3V0aW9uIGlzIHRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcHJvZ3JhbSB3YXMgaW50ZXJydXB0ZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFub1VJKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2xpZGVpdCkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5vbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2xpZGVjaGFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcImVuYWJsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyTGFzdFJ1biA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lcnJpbmZvID0gXCJzdWNjZXNzXCI7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFub1VJKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikub24oXG4gICAgICAgICAgICAgICAgICAgIFwic2xpZGVjaGFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGlkZWl0LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcImVuYWJsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyaW5mbyA9IGVyci50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvck1lc3NhZ2UoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmFsbFZpc3VhbGl6ZXJzICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2god2luZG93LmFsbFZpc3VhbGl6ZXJzLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnJlZHJhd0Nvbm5lY3RvcnMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVJbnRlcmFjdGlvbigpIHtcbiAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikuaGlkZSgpO1xuICAgICAgICAkKHRoaXMuY29kZURpdikuYWRkQ2xhc3MoXCJhYy1kaXNhYmxlZFwiKTtcbiAgICB9XG59XG5cbnZhciBsYW5ndWFnZUV4dGVuc2lvbnMgPSB7XG4gICAgcHl0aG9uOiBcInB5XCIsXG4gICAgaHRtbDogXCJodG1sXCIsXG4gICAgamF2YXNjcmlwdDogXCJqc1wiLFxuICAgIGphdmE6IFwiamF2YVwiLFxuICAgIHB5dGhvbjI6IFwicHlcIixcbiAgICBweXRob24zOiBcInB5XCIsXG4gICAgY3BwOiBcImNwcFwiLFxuICAgIGM6IFwiY1wiLFxuICAgIHNxbDogXCJzcWxcIixcbiAgICBvY3RhdmU6IFwibVwiLFxufTtcblxuLy8gTGFuZ3VhZ2VzIHRoYXQgZ2V0IGEgXCJSZWZvcm1hdFwiIGJ1dHRvbi4gUHJvYmFibHkgd29ya3MgZmluZSBmb3IgYW55IGN1cmx5XG4vLyBicmFjZSBsYW5ndWFnZSBidXQgYmV0dGVyIG5vdCB0byBhZGQgdGhlbSB1bnRpbCBzb21lb25lIGFjdHVhbGx5IGNoZWNrcyBhXG4vLyBib29rIHVzaW5nIHRoYXQgbGFuZ3VhZ2UuIERlZmluaXRlbHkgd29ya3MgYmFkbHkgZm9yIFB5dGhvbiBzaW5jZSBpdCB3aWxsXG4vLyBpbmRlbnQgYW55dGhpbmcgYWZ0ZXIgYW4gYGlmYCB0byBiZSBwYXJ0IG9mIHRoZSBpZi5cbnZhciByZWZvcm1hdGFibGUgPSBuZXcgU2V0KFtcImphdmFcIiwgXCJjcHBcIiwgXCJjXCIsIFwiamF2YXNjcmlwdFwiXSk7XG5cbnZhciBlcnJvclRleHQgPSB7fTtcblxuZXJyb3JUZXh0LlBhcnNlRXJyb3IgPSAkLmkxOG4oXCJtc2dfc2N0aXZlY29kZV9wYXJzZV9lcnJvclwiKTtcbmVycm9yVGV4dC5QYXJzZUVycm9yRml4ID0gJC5pMThuKFwibXNnX3NjdGl2ZWNvZGVfcGFyc2VfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0LlR5cGVFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3R5cGVfZXJyb3JcIik7XG5lcnJvclRleHQuVHlwZUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuTmFtZUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvclwiKTtcbmVycm9yVGV4dC5OYW1lRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9uYW1lX2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5WYWx1ZUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdmFsdWVfZXJyb3JcIik7XG5lcnJvclRleHQuVmFsdWVFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3ZhbHVlX2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5BdHRyaWJ1dGVFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvclwiKTtcbmVycm9yVGV4dC5BdHRyaWJ1dGVFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuVG9rZW5FcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Rva2VuX2Vycm9yXCIpO1xuZXJyb3JUZXh0LlRva2VuRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuVGltZUxpbWl0RXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV90aW1lX2xpbWl0X2Vycm9yXCIpO1xuZXJyb3JUZXh0LlRpbWVMaW1pdEVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yXCIpO1xuZXJyb3JUZXh0LkVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfZ2VuZXJhbF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuU3ludGF4RXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3JcIik7XG5lcnJvclRleHQuU3ludGF4RXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0LkluZGV4RXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbmRleF9lcnJvclwiKTtcbmVycm9yVGV4dC5JbmRleEVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfaW5kZXhfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0LlVSSUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yXCIpO1xuZXJyb3JUZXh0LlVSSUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5JbXBvcnRFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvclwiKTtcbmVycm9yVGV4dC5JbXBvcnRFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuUmVmZXJlbmNlRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9yZWZlcmVuY2VfZXJyb3JcIik7XG5lcnJvclRleHQuUmVmZXJlbmNlRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9yZWZlcmVuY2VfZXJyb3JfZml4XCIpO1xuZXJyb3JUZXh0Llplcm9EaXZpc2lvbkVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfemVyb19kaXZpc2lvbl9lcnJvclwiKTtcbmVycm9yVGV4dC5aZXJvRGl2aXNpb25FcnJvckZpeCA9ICQuaTE4bihcbiAgICBcIm1zZ19hY3RpdmVjb2RlX3plcm9fZGl2aXNpb25fZXJyb3JfZml4XCJcbik7XG5lcnJvclRleHQuUmFuZ2VFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3JhbmdlX2Vycm9yXCIpO1xuZXJyb3JUZXh0LlJhbmdlRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuSW50ZXJuYWxFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ludGVybmFsX2Vycm9yXCIpO1xuZXJyb3JUZXh0LkludGVybmFsRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuSW5kZW50YXRpb25FcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2luZGVudGF0aW9uX2Vycm9yXCIpO1xuZXJyb3JUZXh0LkluZGVudGF0aW9uRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbmRlbnRhdGlvbl9lcnJvcl9maXhcIik7XG5lcnJvclRleHQuTm90SW1wbGVtZW50ZWRFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX25vdF9pbXBsZW1lbnRlZF9lcnJvclwiKTtcbmVycm9yVGV4dC5Ob3RJbXBsZW1lbnRlZEVycm9yRml4ID0gJC5pMThuKFxuICAgIFwibXNnX2FjdGl2ZWNvZGVfbm90X2ltcGxlbWVudGVkX2Vycm9yX2ZpeFwiXG4pO1xuZXJyb3JUZXh0LktleUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yXCIpO1xuZXJyb3JUZXh0LktleUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yX2ZpeFwiKTtcbmVycm9yVGV4dC5Bc3NlcnRpb25FcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvclwiKTtcbmVycm9yVGV4dC5Bc3NlcnRpb25FcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvcl9maXhcIik7XG5cblN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaXQodGFyZ2V0KS5qb2luKHJlcGxhY2VtZW50KTtcbn07XG4iLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVE1MQWN0aXZlQ29kZSBleHRlbmRzIEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuY29kZSA9ICQoXCI8dGV4dGFyZWEgLz5cIikuaHRtbCh0aGlzLm9yaWdFbGVtLmlubmVySFRNTCkudGV4dCgpO1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS50ZXh0KFwiUmVuZGVyXCIpO1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0aGlzLmNvZGUpO1xuICAgIH1cblxuICAgIGFzeW5jIHJ1blByb2coKSB7XG4gICAgICAgIHZhciBwcm9nID0gYXdhaXQgdGhpcy5idWlsZFByb2codHJ1ZSk7XG4gICAgICAgIGxldCBzYXZlQ29kZSA9IFwiVHJ1ZVwiO1xuICAgICAgICB0aGlzLnNhdmVDb2RlID0gYXdhaXQgdGhpcy5tYW5hZ2Vfc2NydWJiZXIoc2F2ZUNvZGUpO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFwiXCIpO1xuICAgICAgICAkKHRoaXMub3V0RGl2KS5zaG93KHsgZHVyYXRpb246IDcwMCwgcXVldWU6IGZhbHNlIH0pO1xuICAgICAgICBwcm9nID1cbiAgICAgICAgICAgIFwiPHNjcmlwdCB0eXBlPXRleHQvamF2YXNjcmlwdD53aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uKG1zZyx1cmwsbGluZSkge2FsZXJ0KG1zZysnIG9uIGxpbmU6ICcrbGluZSk7fTs8L3NjcmlwdD5cIiArXG4gICAgICAgICAgICBwcm9nO1xuICAgICAgICB0aGlzLm91dHB1dC5zcmNkb2MgPSBwcm9nO1xuICAgIH1cblxuICAgIGNyZWF0ZU91dHB1dCgpIHtcbiAgICAgICAgdmFyIG91dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImFjX291dHB1dFwiKTtcbiAgICAgICAgdGhpcy5vdXREaXYgPSBvdXREaXY7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIndoaXRlXCIpO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpO1xuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJoZWlnaHRcIiwgXCI0MDBweFwiKTtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwid2lkdGhcIiwgXCIxMDAlXCIpO1xuICAgICAgICBvdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5vdXRwdXQpO1xuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKG91dERpdik7XG4gICAgICAgIHZhciBjbGVhckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICQoY2xlYXJEaXYpLmNzcyhcImNsZWFyXCIsIFwiYm90aFwiKTsgLy8gbmVlZGVkIHRvIG1ha2UgcGFyZW50IGRpdiByZXNpemUgcHJvcGVybHlcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChjbGVhckRpdik7XG4gICAgfVxuICAgIGVuYWJsZVNhdmVMb2FkKCkge1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3JlbmRlclwiKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQWN0aXZlQ29kZSB9IGZyb20gXCIuL2FjdGl2ZWNvZGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNBY3RpdmVDb2RlIGV4dGVuZHMgQWN0aXZlQ29kZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICB9XG4gICAgb3V0cHV0ZnVuKGEpIHtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG4gICAgICAgIHZhciBzdHIgPSBcIltcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBhID09IFwib2JqZWN0XCIgJiYgYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFbaV0gPT0gXCJvYmplY3RcIiAmJiBhW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gKGkgPT0gMCA/IFwiXCIgOiBcIiBcIikgKyBcIltcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhW2ldLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXVtqXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGogPT0gYVtpXS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJdXCIgKyAoaSA9PSBhLmxlbmd0aCAtIDEgPyBcIl1cIiA6IFwiLFwiKSArIFwiXFxuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIiwgXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBzdHIgKz0gYVtpXSArIChpID09IGEubGVuZ3RoIC0gMSA/IFwiXVwiIDogXCIsIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBhc3luYyBydW5Qcm9nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvZyA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKHRydWUpO1xuICAgICAgICB2YXIgc2F2ZUNvZGUgPSBcIlRydWVcIjtcbiAgICAgICAgdmFyIHdyaXRlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgX3RoaXMub3V0cHV0LmlubmVySFRNTCArPSBfdGhpcy5vdXRwdXRmdW4oc3RyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdyaXRlbG4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICBpZiAoIXN0cikgc3RyID0gXCJcIjtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dC5pbm5lckhUTUwgKz0gX3RoaXMub3V0cHV0ZnVuKHN0cikgKyBcIjxiciAvPlwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNhdmVDb2RlID0gYXdhaXQgdGhpcy5tYW5hZ2Vfc2NydWJiZXIoc2F2ZUNvZGUpO1xuICAgICAgICAkKHRoaXMuZUNvbnRhaW5lcikucmVtb3ZlKCk7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLnRleHQoXCJcIik7XG4gICAgICAgICQodGhpcy5vdXREaXYpLnNob3coeyBkdXJhdGlvbjogNzAwLCBxdWV1ZTogZmFsc2UgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmFsKHByb2cpO1xuICAgICAgICAgICAgdGhpcy5lcnJpbmZvID0gXCJzdWNjZXNzXCI7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICAgICAgdGhpcy5lcnJpbmZvID0gZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZEVycm9yTWVzc2FnZShlcnIpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBlcnJvciBtZXNzYWdlXG4gICAgICAgIHRoaXMuZXJyTGFzdFJ1biA9IHRydWU7XG4gICAgICAgIHZhciBlcnJIZWFkID0gJChcIjxoMz5cIikuaHRtbChcIkVycm9yXCIpO1xuICAgICAgICB0aGlzLmVDb250YWluZXIgPSB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVDb250YWluZXIuY2xhc3NOYW1lID0gXCJlcnJvciBhbGVydCBhbGVydC1kYW5nZXJcIjtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyLmlkID0gdGhpcy5kaXZpZCArIFwiX2VycmluZm9cIjtcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyLmFwcGVuZENoaWxkKGVyckhlYWRbMF0pO1xuICAgICAgICB2YXIgZXJyVGV4dCA9IHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIilcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGVyclN0cmluZyA9IGVyci50b1N0cmluZygpO1xuICAgICAgICBlcnJUZXh0LmlubmVySFRNTCA9IGVyclN0cmluZztcbiAgICAgICAgY29uc29sZS5sb2coXCJSdW50aW1lIEVycm9yOiBcIiArIGVyci50b1N0cmluZygpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xuaW1wb3J0IEhhbmRzb250YWJsZSBmcm9tIFwiaGFuZHNvbnRhYmxlXCI7XG5pbXBvcnQgXCJoYW5kc29udGFibGUvZGlzdC9oYW5kc29udGFibGUuZnVsbC5jc3NcIjtcbmltcG9ydCBpbml0U3FsSnMgZnJvbSBcInNxbC5qcy9kaXN0L3NxbC13YXNtLmpzXCI7XG5cbnZhciBhbGxEYnVybHMgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1FMQWN0aXZlQ29kZSBleHRlbmRzIEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIC8vICBmbnByZWZpeCBzZXRzIHRoZSBwYXRoIHRvIGxvYWQgdGhlIHNxbC13YXNtLndhc20gZmlsZVxuICAgICAgICB2YXIgYm9va3ByZWZpeDtcbiAgICAgICAgdmFyIGZucHJlZml4O1xuICAgICAgICAvLyBGaXg6IHRoZSBtb2RlPWJyb3dzaW5nIHByb2JsZW0gd2ljaCBkaXNhYmxlcyB1c2VSdW5lc3RvbmVTZXJ2aWNlcyBhbmRcbiAgICAgICAgLy8gbWFrZXMgaXQgaW1wb3NzaWJsZSB0byBjb3JvcmVjdGx5IGxvYWQgc3FsLXdhc21cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZUJvb2tDb25maWcudXNlUnVuZXN0b25lU2VydmljZXMgfHxcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guaW5jbHVkZXMoXCJtb2RlPWJyb3dzaW5nXCIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgYm9va3ByZWZpeCA9IGAvbnMvYm9va3MvcHVibGlzaGVkLyR7ZUJvb2tDb25maWcuYmFzZWNvdXJzZX1gO1xuICAgICAgICAgICAgZm5wcmVmaXggPSBib29rcHJlZml4ICsgXCIvX3N0YXRpY1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGVsc2UgY2xhdXNlIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgeW91IGFyZSBidWlsZGluZyBmb3IgYSBzdGF0aWMgd2ViIGJyb3dzZXJcbiAgICAgICAgICAgIGJvb2twcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgZm5wcmVmaXggPSBcIi9fc3RhdGljXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICBsb2NhdGVGaWxlOiAoZmlsZW5hbWUpID0+IGAke2ZucHJlZml4fS8ke2ZpbGVuYW1lfWAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2hvd0xhc3QgPSAkKHRoaXMub3JpZ0VsZW0pLmRhdGEoXCJzaG93bGFzdHNxbFwiKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpbml0U3FsSnModGhpcy5jb25maWcpLnRoZW4oZnVuY3Rpb24gKFNRTCkge1xuICAgICAgICAgICAgLy8gc2V0IHVwIGNhbGwgdG8gbG9hZCBkYXRhYmFzZSBhc3luY2hyb25vdXNseSBpZiBnaXZlblxuICAgICAgICAgICAgaWYgKHNlbGYuZGJ1cmwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYnVybC5zdGFydHNXaXRoKFwiL19zdGF0aWNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYnVybCA9IGAke2Jvb2twcmVmaXh9JHtzZWxmLmRidXJsfWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmRidXJsLnN0YXJ0c1dpdGgoXCJleHRlcm5hbFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRidXJsID0gYCR7Ym9va3ByZWZpeH0vJHtzZWxmLmRidXJsfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBidXR0b25UZXh0ID0gJChzZWxmLnJ1bkJ1dHRvbikudGV4dCgpO1xuICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbG9hZF9kYlwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoc2VsZi5kYnVybCBpbiBhbGxEYnVybHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4V2FpdEZvcjogalF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbERidXJsc1tzZWxmLmRidXJsXS5zdGF0dXMgPT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS54V2FpdEZvci5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRiID0gYWxsRGJ1cmxzW3NlbGYuZGJ1cmxdLmRiT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYiA9IGFsbERidXJsc1tzZWxmLmRidXJsXS5kYk9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2xlcm9jaGEvY2hpbm9vay1kYXRhYmFzZS9yYXcvbWFzdGVyL0NoaW5vb2tEYXRhYmFzZS9EYXRhU291cmNlcy9DaGlub29rX1NxbGl0ZS5zcWxpdGVcbiAgICAgICAgICAgICAgICB4aHIub3BlbihcIkdFVFwiLCBzZWxmLmRidXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdUludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGIgPSBuZXcgU1FMLkRhdGFiYXNlKHVJbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0uZGJPYmplY3QgPSBzZWxmLmRiO1xuICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xuICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS5kYiA9IHVJbnQ4QXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS5zdGF0dXMgPSBcInJlYWR5XCI7XG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS54V2FpdEZvci5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRlbnRzIGlzIG5vdyBbe2NvbHVtbnM6Wydjb2wxJywnY29sMicsLi4uXSwgdmFsdWVzOltbZmlyc3Qgcm93XSwgW3NlY29uZCByb3ddLCAuLi5dfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZGIgPSBuZXcgU1FMLkRhdGFiYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBydW5Qcm9nKG5vVUksIGxvZ1Jlc3VsdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2dSZXN1bHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1Jlc3VsdHMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dSZXN1bHRzID0gbG9nUmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5vVUkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBub1VJID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgYW55IG9sZCByZXN1bHRzXG4gICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBcIlRydWVcIjtcbiAgICAgICAgbGV0IGRpdmlkID0gdGhpcy5kaXZpZCArIFwiX3NxbF9vdXRcIjtcbiAgICAgICAgbGV0IHJlc3BEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkaXZpZCk7XG4gICAgICAgIGlmIChyZXNwRGl2KSB7XG4gICAgICAgICAgICByZXNwRGl2LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocmVzcERpdik7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dChcIlwiKTtcbiAgICAgICAgLy8gUnVuIHRoaXMgcXVlcnlcbiAgICAgICAgbGV0IHF1ZXJ5ID0gYXdhaXQgdGhpcy5idWlsZFByb2coZmFsc2UpOyAvLyBmYWxzZSAtLT4gRG8gbm90IGluY2x1ZGUgc3VmZml4XG4gICAgICAgIGlmICghdGhpcy5kYikge1xuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dChcbiAgICAgICAgICAgICAgICBgRXJyb3I6IERhdGFiYXNlIG5vdCBpbml0aWFsaXplZCEgREJVUkw6ICR7dGhpcy5kYnVybH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ID0gdGhpcy5kYi5pdGVyYXRlU3RhdGVtZW50cyhxdWVyeSk7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGVtZW50IG9mIGl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbnMgPSBzdGF0ZW1lbnQuZ2V0Q29sdW1uTmFtZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEhIHByb2JhYmx5IGEgU0VMRUNUXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZW1lbnQuc3RlcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goc3RhdGVtZW50LmdldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd2NvdW50OiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5zcWwgPSBzdGF0ZW1lbnQuZ2V0Tm9ybWFsaXplZFNRTCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlZml4ID0gbnNxbC5zdWJzdHIoMCwgNikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50LnN0ZXAoKTsgLy8gZXhlY3V0ZSB0aGUgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGRldGVjdCBJTlNFUlQvVVBEQVRFL0RFTEVURSB0byBnaXZlIGZyaWVuZGx5IGZlZWRiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHJvd3MgbW9kaWZpZWQgLSB1bmZvcnR1bmF0ZWx5LCB0aGlzIHdvbid0IGNhdGNoIHN1Y2ggcXVlcmllc1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGV5IHVzZSBDVEVzLiAgVGhlcmUgc2VlbXMgdG8gYmUgbm8gcmVsaWFibGUgd2F5IG9mIGtub3dpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBhIFNRTGl0ZSBxdWVyeSBhY3R1YWxseSBtb2RpZmllZCBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPT09IFwiaW5zZXJ0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9PT0gXCJ1cGRhdGVcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID09PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Y291bnQ6IHRoaXMuZGIuZ2V0Um93c01vZGlmaWVkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5wdXNoKHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJmYWlsdXJlXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNxbDogaXQuZ2V0UmVtYWluaW5nU1FMKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcImZhaWx1cmVcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIHF1ZXJpZXMgc3VibWl0dGVkLlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHRoaXMuc2F2ZUNvZGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2xpZGVpdCkge1xuICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLm9uKFxuICAgICAgICAgICAgICAgICAgICBcInNsaWRlY2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcImVuYWJsZVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byB1cGRhdGUgc2NydWJiZXIgJHtlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHJlc3BEaXYuaWQgPSBkaXZpZDtcbiAgICAgICAgdGhpcy5vdXREaXYuYXBwZW5kQ2hpbGQocmVzcERpdik7XG4gICAgICAgICQodGhpcy5vdXREaXYpLnNob3coKTtcbiAgICAgICAgLy8gU29tZXRpbWVzIHdlIGRvbid0IHdhbnQgdG8gc2hvdyBhIGJ1bmNoIG9mIGludGVybWVkaWF0ZSByZXN1bHRzXG4gICAgICAgIC8vIGxpa2Ugd2hlbiB3ZSBhcmUgaW5jbHVkaW5nIGEgYnVuY2ggb2YgcHJldmlvdXMgc3RhdGVtZW50cyBmcm9tXG4gICAgICAgIC8vIG90aGVyIGFjdGl2ZWNvZGVzIEluIHRoYXQgY2FzZSB0aGUgc2hvd2xhc3RzcWwgZmxhZyBjYW4gYmUgc2V0XG4gICAgICAgIC8vIHNvIHdlIG9ubHkgc2hvdyB0aGUgbGFzdCByZXN1bHRcbiAgICAgICAgbGV0IHJlc3VsdEFycmF5ID0gdGhpcy5yZXN1bHRzO1xuICAgICAgICBpZiAodGhpcy5zaG93TGFzdCkge1xuICAgICAgICAgICAgcmVzdWx0QXJyYXkgPSB0aGlzLnJlc3VsdHMuc2xpY2UoLTEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHIgb2YgcmVzdWx0QXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhY19zcWxfcmVzdWx0XCIpO1xuICAgICAgICAgICAgcmVzcERpdi5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChyLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWJsZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQodGFibGVEaXYpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gMzUwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0QXJyYXkubGVuZ3RoID4gMSkgbWF4SGVpZ2h0ID0gMjAwOyAvLyBtYXggaGVpZ2h0IHNtYWxsZXIgaWYgbG90cyBvZiByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKHIsIHRhYmxlRGl2LCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZUJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBybXNnID0gci5yb3djb3VudCAhPT0gMSA/IFwiIHJvd3MgXCIgOiBcIiByb3cgXCI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSBcIlwiICsgci5yb3djb3VudCArIHJtc2cgKyBcInJldHVybmVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLnJvd2NvdW50ID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtc2cgKyBcIiAob25seSBmaXJzdCAxMDAgcm93cyBkaXNwbGF5ZWQpXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbXNnICsgXCIuXCI7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3gudGV4dENvbnRlbnQgPSBtc2c7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3guc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhY19zcWxfcmVzdWx0X3N1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQobWVzc2FnZUJveCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyLnJvd2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9wID0gci5vcGVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIG9wID0gb3AgKyAob3AuY2hhckF0KG9wLmxlbmd0aCAtIDEpID09PSBcImVcIiA/IFwiZC5cIiA6IFwiZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm1zZyA9IHIucm93Y291bnQgIT09IDEgPyBcIiByb3dzIFwiIDogXCIgcm93IFwiO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnRleHRDb250ZW50ID0gXCJcIiArIHIucm93Y291bnQgKyBybXNnICsgb3A7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3guc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhY19zcWxfcmVzdWx0X3N1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQobWVzc2FnZUJveCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnRleHRDb250ZW50ID0gXCJPcGVyYXRpb24gc3VjY2VlZGVkLlwiO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQm94LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWNfc3FsX3Jlc3VsdF9zdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKG1lc3NhZ2VCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3gudGV4dENvbnRlbnQgPSByLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUJveC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFjX3NxbF9yZXN1bHRfZmFpbHVyZVwiKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKG1lc3NhZ2VCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IGhhbmRsZSBhdXRvZ3JhZGluZ1xuICAgICAgICBpZiAodGhpcy5zdWZmaXgpIHtcbiAgICAgICAgICAgIHRoaXMudGVzdFJlc3VsdCA9IHRoaXMuYXV0b2dyYWRlKFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0c1t0aGlzLnJlc3VsdHMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcImRvbmVcIik7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9nQ3VycmVudEFuc3dlcihzaWQpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICAgICAgICBlcnJpbmZvOiB0aGlzLnJlc3VsdHNbdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDFdLnN0YXR1cyxcbiAgICAgICAgICAgIHRvX3NhdmU6IHRoaXMuc2F2ZUNvZGUsXG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMucHJldGV4dCxcbiAgICAgICAgICAgIHN1ZmZpeDogdGhpcy5zdWZmaXgsXG4gICAgICAgICAgICBwYXJ0bmVyOiB0aGlzLnBhcnRuZXIsXG4gICAgICAgIH07IC8vIExvZyB0aGUgcnVuIGV2ZW50XG4gICAgICAgIGlmICh0eXBlb2Ygc2lkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkYXRhLnNpZCA9IHNpZDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmxvZ1J1bkV2ZW50KGRhdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLnVuaXRfcmVzdWx0cykge1xuICAgICAgICAgICAgbGV0IHVuaXREYXRhID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcInVuaXR0ZXN0XCIsXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxuICAgICAgICAgICAgICAgIGNvdXJzZTogZUJvb2tDb25maWcuY291cnNlLFxuICAgICAgICAgICAgICAgIGFjdDogdGhpcy51bml0X3Jlc3VsdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzaWQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB1bml0RGF0YS5zaWQgPSBzaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvZ0Jvb2tFdmVudCh1bml0RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJGZWVkYmFjaygpIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dCh0aGlzLnRlc3RSZXN1bHQpO1xuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhdXRvZ3JhZGUocmVzdWx0X3RhYmxlKSB7XG4gICAgICAgIHZhciB0ZXN0cyA9IHRoaXMuc3VmZml4LnNwbGl0KC9cXG4vKTtcbiAgICAgICAgdGhpcy5wYXNzZWQgPSAwO1xuICAgICAgICB0aGlzLmZhaWxlZCA9IDA7XG4gICAgICAgIC8vIFRlc3RzIHNob3VsZCBiZSBvZiB0aGUgZm9ybVxuICAgICAgICAvLyBhc3NlcnQgcm93LGNvbCBvcGVyIHZhbHVlIGZvciBleGFtcGxlXG4gICAgICAgIC8vIGFzc2VydCA0LDQgPT0gM1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdGVzdHMgPSB0ZXN0cy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmluZGV4T2YoXCJhc3NlcnRcIikgPiAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IHRlc3Qgb2YgdGVzdHMpIHtcbiAgICAgICAgICAgIGxldCB3bGlzdCA9IHRlc3Quc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgIHdsaXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICBsZXQgbG9jID0gd2xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIGxldCBvcGVyID0gd2xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIGxldCBleHBlY3RlZCA9IHdsaXN0LmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgbGV0IFtyb3csIGNvbF0gPSBsb2Muc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudGVzdE9uZUFzc2VydChcbiAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgIG9wZXIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0X3RhYmxlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBjdCA9ICgxMDAgKiB0aGlzLnBhc3NlZCkgLyAodGhpcy5wYXNzZWQgKyB0aGlzLmZhaWxlZCk7XG4gICAgICAgIGlmIChpc05hTihwY3QpKSB7XG4gICAgICAgICAgICBwY3QgPSAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgcGN0ID0gcGN0LnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwgeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSk7XG4gICAgICAgIHJlc3VsdCArPSBgWW91IHBhc3NlZCAke3RoaXMucGFzc2VkfSBvdXQgb2YgJHtcbiAgICAgICAgICAgIHRoaXMucGFzc2VkICsgdGhpcy5mYWlsZWRcbiAgICAgICAgfSB0ZXN0cyBmb3IgJHtwY3R9JWA7XG4gICAgICAgIHRoaXMudW5pdF9yZXN1bHRzID0gYHBlcmNlbnQ6JHtwY3R9OnBhc3NlZDoke3RoaXMucGFzc2VkfTpmYWlsZWQ6JHt0aGlzLmZhaWxlZH1gO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXN0T25lQXNzZXJ0KHJvdywgY29sLCBvcGVyLCBleHBlY3RlZCwgcmVzdWx0X3RhYmxlKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSByb3cgYW5kIGNvbCBhcmUgaW4gYm91bmRzXG4gICAgICAgIGxldCBhY3R1YWw7XG4gICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWN0dWFsID0gcmVzdWx0X3RhYmxlLnZhbHVlc1tyb3ddW2NvbF07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGBGYWlsZWQgTm90IGVub3VnaCBkYXRhIHRvIGNoZWNrIHJvdyAke3Jvd30gb3IgY29sdW1uICR7Y29sfWA7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZCsrO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcGVyYXRvcnMgPSB7XG4gICAgICAgICAgICBcIj09XCI6IGZ1bmN0aW9uIChvcGVyYW5kMSwgb3BlcmFuZDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDEgPT0gb3BlcmFuZDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIhPVwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQxICE9IG9wZXJhbmQyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiPlwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQxID4gb3BlcmFuZDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCI8XCI6IGZ1bmN0aW9uIChvcGVyYW5kMSwgb3BlcmFuZDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDEgPiBvcGVyYW5kMjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXMgPSBvcGVyYXRvcnNbb3Blcl0oYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGBQYXNzOiAke2FjdHVhbH0gJHtvcGVyfSAke2V4cGVjdGVkfSBpbiByb3cgJHtyb3d9IGNvbHVtbiAke3Jlc3VsdF90YWJsZS5jb2x1bW5zW2NvbF19YDtcbiAgICAgICAgICAgIHRoaXMucGFzc2VkKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBgRmFpbGVkICR7YWN0dWFsfSAke29wZXJ9ICR7ZXhwZWN0ZWR9IGluIHJvdyAke3Jvd30gY29sdW1uICR7cmVzdWx0X3RhYmxlLmNvbHVtbnNbY29sXX1gO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFibGUodGFibGVEYXRhLCBjb250YWluZXIsIG1heEhlaWdodCkge1xuICAgIGxldCBkYXRhID0gdGFibGVEYXRhLnZhbHVlcztcbiAgICBsZXQgdHJpbVJvd3MgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGtsdWRnZTogbm8gY29sdW1uIGhlYWRlcnMgd2lsbCBzaG93IHVwIHVubGVzcyB3ZSBkbyB0aGlzXG4gICAgICAgIGRhdGEgPSBbdGFibGVEYXRhLmNvbHVtbnMubWFwKChlKSA9PiBudWxsKV07XG4gICAgICAgIHRyaW1Sb3dzID0gWzBdO1xuICAgIH1cblxuICAgIHZhciBob3QgPSBuZXcgSGFuZHNvbnRhYmxlKGNvbnRhaW5lciwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB0cmltUm93czogdHJpbVJvd3MsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBtYXhIZWlnaHQsXG4gICAgICAgIGF1dG9Sb3dTaXplOiB0cnVlLFxuICAgICAgICBhdXRvQ29sdW1uU2l6ZTogeyB1c2VIZWFkZXJzOiB0cnVlIH0sXG4gICAgICAgIHJvd0hlYWRlcnM6IGZhbHNlLFxuICAgICAgICBjb2xIZWFkZXJzOiB0YWJsZURhdGEuY29sdW1ucyxcbiAgICAgICAgZWRpdG9yOiBmYWxzZSxcbiAgICAgICAgbWF4Um93czogMTAwLFxuICAgICAgICBmaWx0ZXJzOiBmYWxzZSxcbiAgICAgICAgZHJvcGRvd25NZW51OiBmYWxzZSxcbiAgICAgICAgbGljZW5zZUtleTogXCJub24tY29tbWVyY2lhbC1hbmQtZXZhbHVhdGlvblwiLFxuICAgIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBoZWlnaHQgYW5kIHJlc2l6ZVxuICAgIGxldCBhY3R1YWxIZWlnaHQgPSA0MDsgLy8gaGVhZGVyIGhlaWdodCArIHNtYWxsIG1hcmdpblxuICAgIGlmICh0YWJsZURhdGEudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhY3R1YWxIZWlnaHQgPSBhY3R1YWxIZWlnaHQgKyBob3QuZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICAgICAgaWYgKGFjdHVhbEhlaWdodCA+IG1heEhlaWdodCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob3QudXBkYXRlU2V0dGluZ3MoeyBoZWlnaHQ6IGFjdHVhbEhlaWdodCB9KTtcblxuICAgIHJldHVybiBob3Q7XG59XG4iLCJpbXBvcnQgUnVuZXN0b25lQmFzZSBmcm9tIFwiLi4vLi4vY29tbW9uL2pzL3J1bmVzdG9uZWJhc2UuanNcIjtcblxuLy8gZnVuY3Rpb24gdG8gZGlzcGxheSB0aGUgYXVkaW8gdG91cnNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvVG91ciBleHRlbmRzIFJ1bmVzdG9uZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGRpdmlkLCBjb2RlLCBibnVtLCBhdWRpb190ZXh0KSB7XG4gICAgICAgIC8vIEJ1ZyBGaXg6IElmIGEgY2xhc3MgZXh0ZW5kcyBhbm90aGVyIGNsYXNzLCB0aGlzIGlzIHVuZGVmaW5lZCBVTlRJTCBzdXBlciBpcyBjYWxsZWRcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdWRpb190b3VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdWRpb19jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy53aW5kb3djb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpbyA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldl9hdWRpbyA9IG51bGw7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8gPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RfYXVkaW8gPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcF9idXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLnRvdXJCdXR0b25zID0gW107XG4gICAgICAgIHRoaXMuZWxlbSA9IG51bGw7IC8vIGN1cnJlbnQgYXVkaW8gZWxlbWVudCBwbGF5aW5nXG4gICAgICAgIHRoaXMuY3VyckluZGV4ID0gbnVsbDsgLy8gY3VycmVudCBpbmRleFxuICAgICAgICB0aGlzLmxlbiA9IG51bGw7IC8vIGN1cnJlbnQgbGVuZ3RoIG9mIGF1ZGlvIGZpbGVzIGZvciB0b3VyXG4gICAgICAgIHRoaXMuYnV0dG9uQ291bnQgPSBudWxsOyAvLyBudW1iZXIgb2YgYXVkaW8gdG91ciBidXR0b25zXG4gICAgICAgIHRoaXMuYW5hbWUgPSBudWxsOyAvLyB0aGUgYXVkaW8gZmlsZSBuYW1lXG4gICAgICAgIHRoaXMuYWhhc2ggPSBudWxsOyAvLyBoYXNoIG9mIHRoZSBhdWRpbyBmaWxlIG5hbWUgdG8gdGhlIGxpbmVzIHRvIGhpZ2hsaWdodFxuICAgICAgICB0aGlzLnRoZURpdmlkID0gbnVsbDsgLy8gZGl2IGlkXG4gICAgICAgIHRoaXMuYWZpbGUgPSBudWxsOyAvLyBmaWxlIG5hbWUgZm9yIGF1ZGlvXG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlOyAvLyBmbGFnIHRvIHNheSBpZiBwbGF5aW5nIG9yIG5vdFxuICAgICAgICB0aGlzLnRvdXJOYW1lID0gXCJcIjtcbiAgICAgICAgLy8gUmVwbGFjaW5nIGhhcyBiZWVuIGRvbmUgaGVyZSB0byBtYWtlIHN1cmUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBjb2RlIGFyZSBkaXNwbGF5ZWQgY29ycmVjdGx5XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2VBbGwoXCIqZG91YmxlcSpcIiwgJ1wiJyk7XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2VBbGwoXCIqc2luZ2xlcSpcIiwgXCInXCIpO1xuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlQWxsKFwiKm9wZW4qXCIsIFwiKFwiKTtcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZUFsbChcIipjbG9zZSpcIiwgXCIpXCIpO1xuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlQWxsKFwiKm5saW5lKlwiLCBcIjxici8+XCIpO1xuICAgICAgICB2YXIgY29kZUFycmF5ID0gY29kZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGF1ZGlvX2hhc2ggPSBbXTtcbiAgICAgICAgdmFyIGJ2YWwgPSBbXTtcbiAgICAgICAgdmFyIGF0eXBlID0gYXVkaW9fdGV4dC5yZXBsYWNlQWxsKFwiKmRvdWJsZXEqXCIsICdcIicpO1xuICAgICAgICB2YXIgYXVkaW9fdHlwZSA9IGF0eXBlLnNwbGl0KFwiKmF0eXBlKlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb190eXBlLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgYXVkaW9faGFzaFtpXSA9IGF1ZGlvX3R5cGVbaV07XG4gICAgICAgICAgICB2YXIgYXdvcmQgPSBhdWRpb190eXBlW2ldLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgICAgIGJ2YWwucHVzaChhd29yZFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0ID1cbiAgICAgICAgICAgIFwiPHByZT48ZGl2IGlkPSdcIiArXG4gICAgICAgICAgICBkaXZpZCArXG4gICAgICAgICAgICBcIl9sMSc+XCIgK1xuICAgICAgICAgICAgXCIxLiAgIFwiICtcbiAgICAgICAgICAgIGNvZGVBcnJheVswXSArXG4gICAgICAgICAgICBcIjwvZGl2PlwiO1xuICAgICAgICB2YXIgbnVtX2xpbmVzID0gY29kZUFycmF5Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1fbGluZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCA5KSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCArXG4gICAgICAgICAgICAgICAgICAgIFwiPGRpdiBpZD0nXCIgK1xuICAgICAgICAgICAgICAgICAgICBkaXZpZCArXG4gICAgICAgICAgICAgICAgICAgIFwiX2xcIiArXG4gICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIic+XCIgK1xuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgXCIuICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICBjb2RlQXJyYXlbaV0gK1xuICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgOTkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdCA9XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ICtcbiAgICAgICAgICAgICAgICAgICAgXCI8ZGl2IGlkPSdcIiArXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkICtcbiAgICAgICAgICAgICAgICAgICAgXCJfbFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIFwiJz5cIiArXG4gICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIi4gIFwiICtcbiAgICAgICAgICAgICAgICAgICAgY29kZUFycmF5W2ldICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCArXG4gICAgICAgICAgICAgICAgICAgIFwiPGRpdiBpZD0nXCIgK1xuICAgICAgICAgICAgICAgICAgICBkaXZpZCArXG4gICAgICAgICAgICAgICAgICAgIFwiX2xcIiArXG4gICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xuICAgICAgICAgICAgICAgICAgICBcIic+XCIgK1xuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgXCIuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgY29kZUFycmF5W2ldICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaXJzdCA9IGZpcnN0ICsgXCI8L3ByZT5cIjtcbiAgICAgICAgLy9sYXlpbmcgb3V0IHRoZSBIVE1MIGNvbnRlbnRcbiAgICAgICAgdmFyIGJjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXVkaW9fdHlwZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAgICAgbmV3QnV0dG9uLmNsYXNzTmFtZSA9IFwiYnRuIGJ0bi1zdWNjZXNzXCI7XG4gICAgICAgICAgICBuZXdCdXR0b24uaW5uZXJIVE1MID0gYnZhbFtpXS5yZXBsYWNlKC9cXFwiL2csIFwiXCIpO1xuICAgICAgICAgICAgdGhpcy50b3VyQnV0dG9ucy5wdXNoKG5ld0J1dHRvbik7XG4gICAgICAgICAgICBiY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1ZGlvX3RvdXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmF1ZGlvX3RvdXIuYWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0aGlzLmF1ZGlvX2NvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgdGhpcy53aW5kb3djb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy53aW5kb3djb2RlLmFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICQodGhpcy53aW5kb3djb2RlKS5odG1sKGZpcnN0KTtcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMucHJldl9hdWRpbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLmxhc3RfYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLmNsYXNzTmFtZSA9XG4gICAgICAgICAgICBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tZmFzdC1iYWNrd2FyZFwiO1xuICAgICAgICB0aGlzLnByZXZfYXVkaW8uY2xhc3NOYW1lID1cbiAgICAgICAgICAgIFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1zdGVwLWJhY2t3YXJkXCI7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8uY2xhc3NOYW1lID0gXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXBhdXNlXCI7XG4gICAgICAgIHRoaXMubmV4dF9hdWRpby5jbGFzc05hbWUgPVxuICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXN0ZXAtZm9yd2FyZFwiO1xuICAgICAgICB0aGlzLmxhc3RfYXVkaW8uY2xhc3NOYW1lID1cbiAgICAgICAgICAgIFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1mYXN0LWZvcndhcmRcIjtcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpby5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICBcImhlaWdodDogMjJweDsgd2lkdGg6IDI1cHg7IGJvcmRlci1yYWRpdXM6IDRweDsgbWFyZ2luLXJpZ2h0OjJweDtcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLnByZXZfYXVkaW8uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgXCJoZWlnaHQ6IDIycHg7IHdpZHRoOiAyNXB4OyBib3JkZXItcmFkaXVzOiA0cHg7IG1hcmdpbi1yaWdodDoycHg7XCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICBcImhlaWdodDogMjJweDsgd2lkdGg6IDI1cHg7IGJvcmRlci1yYWRpdXM6IDRweDsgbWFyZ2luLXJpZ2h0OjJweDtcIlxuICAgICAgICApO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgXCJoZWlnaHQ6IDIycHg7IHdpZHRoOiAyNXB4OyBib3JkZXItcmFkaXVzOiA0cHg7IG1hcmdpbi1yaWdodDoycHg7XCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0OiAyMnB4OyB3aWR0aDogMjVweDsgYm9yZGVyLXJhZGl1czogNHB4OyBtYXJnaW4tcmlnaHQ6MnB4O1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8ubmFtZSA9IFwiZmlyc3RfYXVkaW9cIjtcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLm5hbWUgPSBcInByZXZfYXVkaW9cIjtcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5uYW1lID0gXCJwYXVzZV9hdWRpb1wiO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8ubmFtZSA9IFwibmV4dF9hdWRpb1wiO1xuICAgICAgICB0aGlzLmxhc3RfYXVkaW8ubmFtZSA9IFwibGFzdF9hdWRpb1wiO1xuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLnRpdGxlID0gXCJQbGF5IGZpcnN0IGF1ZGlvIGluIHRvdXJcIjtcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLnRpdGxlID0gXCJQbGF5IHByZXZpb3VzIGF1ZGlvIGluIHRvdXJcIjtcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby50aXRsZSA9IFwiUGF1c2UgY3VycmVudCBhdWRpb1wiO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8udGl0bGUgPSBcIlBsYXkgbmV4dCBhdWRpbyBpbiB0b3VyXCI7XG4gICAgICAgIHRoaXMubGFzdF9hdWRpby50aXRsZSA9IFwiUGxheSBsYXN0IGF1ZGlvIGluIHRvdXJcIjtcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpby5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiUGxheSBmaXJzdCBhdWRpbyBpbiB0b3VyXCIpO1xuICAgICAgICB0aGlzLnByZXZfYXVkaW8uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICAgICAgICBcIlBsYXkgcHJldmlvdXMgYXVkaW8gaW4gdG91clwiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlBhdXNlIGF1ZGlvXCIpO1xuICAgICAgICB0aGlzLm5leHRfYXVkaW8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlBsYXkgbmV4dCBhdWRpbyBpbiB0b3VyXCIpO1xuICAgICAgICB0aGlzLmxhc3RfYXVkaW8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlBsYXkgbGFzdCBhdWRpbyBpbiB0b3VyXCIpO1xuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubmV4dF9hdWRpby5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdF9hdWRpby5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zdGF0dXMuY2xhc3NOYW1lID0gXCJhbGVydCBhbGVydC1pbmZvXCI7XG4gICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTogbm9uZTtcIik7XG4gICAgICAgIHRoaXMuc3RvcF9idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLnN0b3BfYnV0dG9uLmNsYXNzTmFtZSA9IFwiYnRuIGJ0bi1kZWZhdWx0XCI7XG4gICAgICAgIHRoaXMuc3RvcF9idXR0b24uaW5uZXJIVE1MID0gXCJTdG9wIHRvdXJcIjtcbiAgICAgICAgJCh0aGlzLmF1ZGlvX3RvdXIpLmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMuYXVkaW9fY29kZSxcbiAgICAgICAgICAgIHRoaXMud2luZG93Y29kZSxcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSxcbiAgICAgICAgICAgIHRoaXMuZmlyc3RfYXVkaW8sXG4gICAgICAgICAgICB0aGlzLnByZXZfYXVkaW8sXG4gICAgICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLFxuICAgICAgICAgICAgdGhpcy5uZXh0X2F1ZGlvLFxuICAgICAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpLFxuICAgICAgICAgICAgdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIiksXG4gICAgICAgICAgICB0aGlzLnRvdXJCdXR0b25zLFxuICAgICAgICAgICAgdGhpcy5zdG9wX2J1dHRvblxuICAgICAgICApO1xuICAgICAgICAkKFwiI1wiICsgZGl2aWQgKyBcIiAuYWNfY29kZV9kaXZcIikuYXBwZW5kKHRoaXMuYXVkaW9fdG91cik7XG4gICAgICAgICQoXCIjXCIgKyBkaXZpZCArIFwiIC5hY19jb2RlX2RpdlwiKS5jc3MoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XG4gICAgICAgICQoXCIjXCIgKyBkaXZpZCArIFwiIC5Db2RlTWlycm9yLmNtLXMtZGVmYXVsdC51aS1yZXNpemFibGVcIikuaGlkZSgpO1xuICAgICAgICAkKFwiI1wiICsgZGl2aWQgKyBcIiAuYWNfb3B0LmJ0bi5idG4tZGVmYXVsdDpsYXN0LWNoaWxkXCIpLmhpZGUoKTtcbiAgICAgICAgJCh0aGlzLnN0b3BfYnV0dG9uKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcIkF1ZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdDogXCJjbG9zZVdpbmRvd1wiLFxuICAgICAgICAgICAgICAgICAgICBkaXZfaWQ6IGRpdmlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICQodGhpcy5hdWRpb190b3VyKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkKFxuICAgICAgICAgICAgICAgICAgICBcIiNcIiArIGRpdmlkICsgXCIgLkNvZGVNaXJyb3IuY20tcy1kZWZhdWx0LnVpLXJlc2l6YWJsZVwiXG4gICAgICAgICAgICAgICAgKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLmFjX29wdC5idG4uYnRuLWRlZmF1bHQ6bGFzdC1jaGlsZFwiKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLmFjX2NvZGVfZGl2XCIpLmNzcyhcIndpZHRoXCIsIFwiXCIpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgICQodGhpcy50b3VyQnV0dG9uc1swXSkuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VyKGRpdmlkLCBhdWRpb19oYXNoWzBdLCBiY291bnQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgICQodGhpcy50b3VyQnV0dG9uc1sxXSkuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VyKGRpdmlkLCBhdWRpb19oYXNoWzFdLCBiY291bnQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgICQodGhpcy50b3VyQnV0dG9uc1syXSkuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VyKGRpdmlkLCBhdWRpb19oYXNoWzJdLCBiY291bnQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgICQodGhpcy50b3VyQnV0dG9uc1szXSkuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VyKGRpdmlkLCBhdWRpb19oYXNoWzNdLCBiY291bnQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgICQodGhpcy50b3VyQnV0dG9uc1s0XSkuY2xpY2soXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VyKGRpdmlkLCBhdWRpb19oYXNoWzRdLCBiY291bnQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2xpY2sgdG8gZ28gdG8gdGhlIG5leHQgYXVkaW9cbiAgICAgICAgJCh0aGlzLmZpcnN0X2F1ZGlvKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0QXVkaW8oKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIGdvIHRvIHRoZSBuZXh0IGF1ZGlvXG4gICAgICAgICQodGhpcy5wcmV2X2F1ZGlvKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBdWRpbygpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2xpY2sgdG8gcGF1c2Ugb3IgcGxheSB0aGUgYXVkaW9cbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlQW5kUGxheUF1ZGlvKGRpdmlkKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApO1xuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIGdvIHRvIHRoZSBuZXh0IGF1ZGlvXG4gICAgICAgICQodGhpcy5uZXh0X2F1ZGlvKS5jbGljayhcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRBdWRpbygpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2xpY2sgdG8gZ28gdG8gdGhlIG5leHQgYXVkaW9cbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLmNsaWNrKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEF1ZGlvKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICAgICAgLy8gbWFrZSB0aGUgaW1hZ2UgYnV0dG9ucyBsb29rIGRpc2FibGVkXG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcbiAgICAgICAgJCh0aGlzLnByZXZfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XG4gICAgICAgICQodGhpcy5wYXVzZV9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XG4gICAgICAgICQodGhpcy5sYXN0X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDAuMjUpO1xuICAgIH1cbiAgICB0b3VyKGRpdmlkLCBhdWRpb190eXBlLCBiY291bnQpIHtcbiAgICAgICAgLy8gc2V0IGdsb2JhbHNcbiAgICAgICAgdGhpcy5idXR0b25Db3VudCA9IGJjb3VudDtcbiAgICAgICAgdGhpcy50aGVEaXZpZCA9IGRpdmlkO1xuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgICAgICBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgbWFyZ2luLXRvcDogN3B4OyBtYXJnaW4tYm90dG9tOiAzcHg7XCJcbiAgICAgICAgKTtcbiAgICAgICAgLy8gZW5hYmxlIHByZXYsIHBhdXNlL3BsYXkgYW5kIG5leHQgYnV0dG9ucyBhbmQgbWFrZSB2aXNpYmxlXG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAkKHRoaXMucHJldl9hdWRpbykucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAkKHRoaXMucGF1c2VfYXVkaW8pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLmZpcnN0X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDEuMCk7XG4gICAgICAgICQodGhpcy5wcmV2X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDEuMCk7XG4gICAgICAgICQodGhpcy5wYXVzZV9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAxLjApO1xuICAgICAgICAkKHRoaXMubmV4dF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAxLjApO1xuICAgICAgICAkKHRoaXMubGFzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAxLjApO1xuICAgICAgICAvLyBkaXNhYmxlIHRvdXIgYnV0dG9uc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJjb3VudDsgaSsrKVxuICAgICAgICAgICAgJCh0aGlzLnRvdXJCdXR0b25zW2ldKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgdmFyIGF0eXBlID0gYXVkaW9fdHlwZS5zcGxpdChcIjtcIik7XG4gICAgICAgIHZhciBuYW1lID0gYXR5cGVbMF0ucmVwbGFjZUFsbCgnXCInLCBcIiBcIik7XG4gICAgICAgIHRoaXMudG91ck5hbWUgPSBuYW1lO1xuICAgICAgICAkKHRoaXMuc3RhdHVzKS5odG1sKCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3N0YXJ0aW5nXCIsIG5hbWUpKTtcbiAgICAgICAgLy9sb2cgdG91ciB0eXBlIHRvIGRiXG4gICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHsgZXZlbnQ6IFwiQXVkaW9cIiwgYWN0OiBuYW1lLCBkaXZfaWQ6IGRpdmlkIH0pO1xuICAgICAgICB2YXIgbWF4ID0gYXR5cGUubGVuZ3RoO1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgdGhpcy5haGFzaCA9IFtdO1xuICAgICAgICB0aGlzLmFuYW1lID0gW107XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtYXggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gYXR5cGVbaV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgdmFyIHRlbXBfbGluZSA9IHRlbXBbMF07XG4gICAgICAgICAgICB2YXIgdGVtcF9hbmFtZSA9IHRlbXBbMV07XG4gICAgICAgICAgICB2YXIgYWtleSA9IHRlbXBfYW5hbWUuc3Vic3RyaW5nKDEsIHRlbXBfYW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBsbnVtcyA9IHRlbXBfbGluZS5zdWJzdHJpbmcoMSwgdGVtcF9saW5lLmxlbmd0aCk7XG4gICAgICAgICAgICAvL2FsZXJ0KFwiYWtleTpcIitha2V5K1wibG51bTpcIitsbnVtcyk7XG4gICAgICAgICAgICAvLyBzdHIrPVwiPGF1ZGlvIGlkPVwiK2FrZXkrXCIgcHJlbG9hZD0nYXV0byc+PHNvdXJjZSBzcmM9J2h0dHA6Ly9pY2Utd2ViLmNjLmdhdGVjaC5lZHUvY2UyMS9hdWRpby9cIitcbiAgICAgICAgICAgIC8vIGFrZXkrXCIubXAzJyB0eXBlPSdhdWRpby9tcGVnJz48c291cmNlIHNyYz0naHR0cDovL2ljZS13ZWIuY2MuZ2F0ZWNoLmVkdS9jZTIxL2F1ZGlvL1wiK2FrZXkrXG4gICAgICAgICAgICAvLyBcIi5vZ2cnIHR5cGU9J2F1ZGlvL29nZyc+WW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIGF1ZGlvIHRhZzwvYXVkaW8+XCI7XG4gICAgICAgICAgICAvL3ZhciBkaXIgPVxuICAgICAgICAgICAgLy8gICAgXCJodHRwOi8vbWVkaWEuaW50ZXJhY3RpdmVweXRob24ub3JnL1wiICtcbiAgICAgICAgICAgIC8vICAgIGVCb29rQ29uZmlnLmJhc2Vjb3Vyc2UudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgICAvLyAgICBcIi9hdWRpby9cIjtcbiAgICAgICAgICAgIHZhciBkaXIgPSBcIi4uL19zdGF0aWMvYXVkaW8vXCJcbiAgICAgICAgICAgIHN0ciArPSBcIjxhdWRpbyBpZD1cIiArIGFrZXkgKyBcIiBwcmVsb2FkPSdhdXRvJyA+XCI7XG4gICAgICAgICAgICBzdHIgKz0gXCI8c291cmNlIHNyYz0nXCIgKyBkaXIgKyBha2V5ICsgXCIud2F2JyB0eXBlPSdhdWRpby93YXYnPlwiO1xuICAgICAgICAgICAgc3RyICs9IFwiPHNvdXJjZSBzcmM9J1wiICsgZGlyICsgYWtleSArIFwiLm1wMycgdHlwZT0nYXVkaW8vbXBlZyc+XCI7XG4gICAgICAgICAgICBzdHIgKz0gXCI8c291cmNlIHNyYz0nXCIgKyBkaXIgKyBha2V5ICsgXCIud2F2JyB0eXBlPSdhdWRpby93YXYnPlwiO1xuICAgICAgICAgICAgc3RyICs9IFwiPHNvdXJjZSBzcmM9J1wiICsgZGlyICsgYWtleSArIFwiLm1wMycgdHlwZT0nYXVkaW8vbXBlZyc+XCI7XG4gICAgICAgICAgICBzdHIgKz0gXCI8YnIgLz5Zb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYXVkaW8gdGFnPC9hdWRpbz5cIjtcbiAgICAgICAgICAgIHRoaXMuYWhhc2hbYWtleV0gPSBsbnVtcztcbiAgICAgICAgICAgIHRoaXMuYW5hbWUucHVzaChha2V5KTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMuYXVkaW9fY29kZSkuaHRtbChzdHIpO1xuICAgICAgICB0aGlzLmxlbiA9IHRoaXMuYW5hbWUubGVuZ3RoOyAvLyBzZXQgdGhlIG51bWJlciBvZiBhdWRpbyBmaWxlIGluIHRoZSB0b3VyXG4gICAgICAgIHRoaXMuY3VyckluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcbiAgICB9XG4gICAgaGFuZGxlUGxheWluZygpIHtcbiAgICAgICAgdGhpcy5lbGVtLnBhdXNlKCk7XG4gICAgICAgIC8vIHVuYmluZCBjdXJyZW50IGVuZGVkXG4gICAgICAgICQoXCIjXCIgKyB0aGlzLmFmaWxlKS51bmJpbmQoXCJlbmRlZFwiKTtcbiAgICAgICAgLy8gdW5oaWdobGlnaHQgdGhlIHByZXYgbGluZXNcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodExpbmVzKFxuICAgICAgICAgICAgdGhpcy50aGVEaXZpZCxcbiAgICAgICAgICAgIHRoaXMuYWhhc2hbdGhpcy5hbmFtZVt0aGlzLmN1cnJJbmRleF1dXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZpcnN0QXVkaW8oKSB7XG4gICAgICAgIC8vIGlmIGF1ZGlvIGlzIHRoaXMucGxheWluZyBoYW5kbGUgaXRcbiAgICAgICAgdGhpcy5oYW5kbGVQbGF5aW5nKCk7XG4gICAgICAgIC8vbG9nIGNoYW5nZSB0byBkYlxuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxuICAgICAgICAgICAgYWN0OiBcImZpcnN0XCIsXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMudGhlRGl2aWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBmaXJzdCBhdWRpb1xuICAgICAgICB0aGlzLmN1cnJJbmRleCA9IDA7XG4gICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBmaXJzdCBhdWRpb1xuICAgICAgICB0aGlzLnBsYXlDdXJySW5kZXhBdWRpbygpO1xuICAgIH1cbiAgICBwcmV2QXVkaW8oKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcHJldmlvdXMgYXVkaW9cbiAgICAgICAgaWYgKHRoaXMuY3VyckluZGV4ID4gMCkge1xuICAgICAgICAgICAgLy8gaWYgYXVkaW8gaXMgdGhpcy5wbGF5aW5nIGhhbmRsZSBpdFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQbGF5aW5nKCk7XG4gICAgICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcbiAgICAgICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxuICAgICAgICAgICAgICAgIGFjdDogXCJwcmV2XCIsXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBtb3ZlIHRvIHByZXZpb3VzIHRvIHRoZSBjdXJyZW50IChidXQgdGhlIGN1cnJlbnQgaW5kZXggaGFzIG1vdmVkIHRvIHRoZSBuZXh0KVxuICAgICAgICAgICAgdGhpcy5jdXJySW5kZXggPSB0aGlzLmN1cnJJbmRleCAtIDE7XG4gICAgICAgICAgICAvLyBzdGFydCBhdCB0aGUgcHJldiBhdWRpb1xuICAgICAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0QXVkaW8oKSB7XG4gICAgICAgIC8vIGlmIGF1ZGlvIGlzIHRoaXMucGxheWluZyBoYW5kbGUgaXRcbiAgICAgICAgdGhpcy5oYW5kbGVQbGF5aW5nKCk7XG4gICAgICAgIC8vbG9nIGNoYW5nZSB0byBkYlxuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxuICAgICAgICAgICAgYWN0OiBcIm5leHRcIixcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy50aGVEaXZpZCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIG5vdCBhdCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLmN1cnJJbmRleCA8IHRoaXMubGVuIC0gMSkge1xuICAgICAgICAgICAgLy8gc3RhcnQgYXQgdGhlIG5leHQgYXVkaW9cbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gdGhpcy5jdXJySW5kZXggKyAxO1xuICAgICAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJJbmRleCA9PSB0aGlzLmxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91ckVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxhc3RBdWRpbygpIHtcbiAgICAgICAgLy8gaWYgYXVkaW8gaXMgdGhpcy5wbGF5aW5nIGhhbmRsZSBpdFxuICAgICAgICB0aGlzLmhhbmRsZVBsYXlpbmcoKTtcbiAgICAgICAgLy9sb2cgY2hhbmdlIHRvIGRiXG4gICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBcIkF1ZGlvXCIsXG4gICAgICAgICAgICBhY3Q6IFwibGFzdFwiLFxuICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gbW92ZSB0byB0aGUgbGFzdCBhdWRpb1xuICAgICAgICB0aGlzLmN1cnJJbmRleCA9IHRoaXMubGVuIC0gMTtcbiAgICAgICAgLy8gc3RhcnQgYXQgbGFzdFxuICAgICAgICB0aGlzLnBsYXlDdXJySW5kZXhBdWRpbygpO1xuICAgIH1cbiAgICAvLyBwbGF5IHRoZSBhdWRpbyBhdCB0aGUgY3VycmVudCBpbmRleFxuICAgIHBsYXlDdXJySW5kZXhBdWRpbygpIHtcbiAgICAgICAgLy8gc2V0IHRoaXMucGxheWluZyB0byBmYWxzZVxuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gcGxheSB0aGUgY3VycmVudCBhdWRpbyBhbmQgaGlnaGxpZ2h0IHRoZSBsaW5lc1xuICAgICAgICB0aGlzLnBsYXlhdWRpbyh0aGlzLmN1cnJJbmRleCwgdGhpcy5hbmFtZSwgdGhpcy50aGVEaXZpZCwgdGhpcy5haGFzaCk7XG4gICAgfVxuICAgIC8vIGhhbmRsZSB0aGUgZW5kIG9mIHRoZSB0b3VyXG4gICAgaGFuZGxlVG91ckVuZCgpIHtcbiAgICAgICAgJCh0aGlzLnN0YXR1cykuaHRtbChcIlRoZSBcIiArIHRoaXMudG91ck5hbWUgKyBcIiBoYXMgZW5kZWQuXCIpO1xuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLmNsYXNzTmFtZSA9IFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1wYXVzZVwiO1xuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnRpdGxlID0gXCJQYXVzZSBhdWRpb1wiO1xuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQYXVzZSBhdWRpb1wiKTtcbiAgICAgICAgJCh0aGlzLmZpcnN0X2F1ZGlvKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLnByZXZfYXVkaW8pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAkKHRoaXMucGF1c2VfYXVkaW8pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAkKHRoaXMubmV4dF9hdWRpbykuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQodGhpcy5sYXN0X2F1ZGlvKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLmZpcnN0X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDAuMjUpO1xuICAgICAgICAkKHRoaXMucHJldl9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDAuMjUpO1xuICAgICAgICAkKHRoaXMubmV4dF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XG4gICAgICAgIC8vIGVuYWJsZSB0aGUgdG91ciBidXR0b25zXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5idXR0b25Db3VudDsgaisrKVxuICAgICAgICAgICAgJCh0aGlzLnRvdXJCdXR0b25zW2pdKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgfVxuICAgIC8vIG9ubHkgY2FsbCB0aGlzIG9uZSBhZnRlciB0aGUgZmlyc3QgdGltZVxuICAgIG91dGVyQXVkaW8oKSB7XG4gICAgICAgIC8vIHVuYmluZCBlbmRlZFxuICAgICAgICAkKFwiI1wiICsgdGhpcy5hZmlsZSkudW5iaW5kKFwiZW5kZWRcIik7XG4gICAgICAgIC8vIHNldCB0aGlzLnBsYXlpbmcgdG8gZmFsc2VcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIHVuaGlnaGxpZ2h0IHByZXZpb3VzIGxpbmVzIGZyb20gdGhlIGxhc3QgYXVkaW9cbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodExpbmVzKFxuICAgICAgICAgICAgdGhpcy50aGVEaXZpZCxcbiAgICAgICAgICAgIHRoaXMuYWhhc2hbdGhpcy5hbmFtZVt0aGlzLmN1cnJJbmRleF1dXG4gICAgICAgICk7XG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgdGhpcy5jdXJySW5kZXggdG8gcG9pbnQgdG8gdGhlIG5leHQgb25lXG4gICAgICAgIHRoaXMuY3VyckluZGV4Kys7XG4gICAgICAgIC8vIGlmIHRoZSBlbmQgb2YgdGhlIHRvdXIgcmVzZXQgdGhlIGJ1dHRvbnNcbiAgICAgICAgaWYgKHRoaXMuY3VyckluZGV4ID09IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRvdXJFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIG5vdCBkb25lIHlldCBzbyBwbGF5IHRoZSBuZXh0IGF1ZGlvXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGxheSB0aGUgYXVkaW8gYXQgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgIHRoaXMucGxheUN1cnJJbmRleEF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGxheSB0aGUgYXVkaW8gbm93IHRoYXQgaXQgaXMgcmVhZHlcbiAgICBwbGF5V2hlblJlYWR5KGFmaWxlLCBkaXZpZCwgYWhhc2gpIHtcbiAgICAgICAgLy8gdW5iaW5kIGN1cnJlbnRcbiAgICAgICAgJChcIiNcIiArIGFmaWxlKS51bmJpbmQoXCJjYW5wbGF5dGhyb3VnaFwiKTtcbiAgICAgICAgdGhpcy5lbGVtLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImluIHBsYXlXaGVuUmVhZHkgXCIgKyBlbGVtLmR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRMaW5lcyhkaXZpZCwgYWhhc2hbYWZpbGVdKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5jbGFzc05hbWUgPT09XG4gICAgICAgICAgICBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tcGF1c2VcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgICQodGhpcy5zdGF0dXMpLmh0bWwoXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcGxheWluZ1wiLCB0aGlzLnRvdXJOYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICQoXCIjXCIgKyBhZmlsZSkuYmluZChcbiAgICAgICAgICAgICAgICBcImVuZGVkXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dGVyQXVkaW8oKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmVsZW0ucGxheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcIiNcIiArIGFmaWxlKS5iaW5kKFxuICAgICAgICAgICAgICAgIFwiZW5kZWRcIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0ZXJBdWRpbygpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwbGF5IHRoZSBhdWRpbyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGkgYW5kIHNldCB0aGUgZHVyYXRpb24gYW5kIGhpZ2hsaWdodCB0aGUgbGluZXNcbiAgICBwbGF5YXVkaW8oaSwgYW5hbWUsIGRpdmlkLCBhaGFzaCkge1xuICAgICAgICB0aGlzLmFmaWxlID0gYW5hbWVbaV07XG4gICAgICAgIHRoaXMuZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuYWZpbGUpO1xuICAgICAgICAvLyBpZiB0aGlzIGlzbid0IHJlYWR5IHRvIHBsYXkgeWV0IC0gbm8gZHVyYXRpb24geWV0IHRoZW4gd2FpdFxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiaW4gcGxheWF1ZGlvIFwiICsgZWxlbS5kdXJhdGlvbik7XG4gICAgICAgIGlmIChpc05hTih0aGlzLmVsZW0uZHVyYXRpb24pIHx8IHRoaXMuZWxlbS5kdXJhdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHN0YXR1c1xuICAgICAgICAgICAgJCh0aGlzLnN0YXR1cykuaHRtbCgkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9sb2FkaW5nX2F1ZGlvXCIpKTtcbiAgICAgICAgICAgICQoXCIjXCIgKyB0aGlzLmFmaWxlKS5iaW5kKFxuICAgICAgICAgICAgICAgIFwiY2FucGxheXRocm91Z2hcIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheVdoZW5SZWFkeSh0aGlzLmFmaWxlLCBkaXZpZCwgYWhhc2gpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgaXQgaXMgcmVhZHkgc28gcGxheSBpdFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGxheVdoZW5SZWFkeSh0aGlzLmFmaWxlLCBkaXZpZCwgYWhhc2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHBhdXNlIGlmIHRoaXMucGxheWluZyBhbmQgcGxheSBpZiBwYXVzZWRcbiAgICBwYXVzZUFuZFBsYXlBdWRpbyhkaXZpZCkge1xuICAgICAgICB2YXIgYnRuID0gdGhpcy5wYXVzZV9hdWRpbztcbiAgICAgICAgLy8gaWYgcGF1c2VkIGFuZCBjbGlja2VkIHRoZW4gY29udGludWUgZnJvbSBjdXJyZW50XG4gICAgICAgIGlmICh0aGlzLmVsZW0ucGF1c2VkKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWFsdGUgdGhlIHRpbWUgbGVmdCB0byBwbGF5IGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgbGV0IGNvdW50ZXIgPSAodGhpcy5lbGVtLmR1cmF0aW9uIC0gdGhpcy5lbGVtLmN1cnJlbnRUaW1lKSAqIDEwMDA7XG4gICAgICAgICAgICB0aGlzLmVsZW0ucGxheSgpOyAvLyBzdGFydCB0aGUgYXVkaW8gZnJvbSBjdXJyZW50IHNwb3RcbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8uY2xhc3NOYW1lID1cbiAgICAgICAgICAgICAgICBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tcGF1c2VcIjtcbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8udGl0bGUgPSAkLmkxOG4oXG4gICAgICAgICAgICAgICAgXCJtc2dfYWN0aXZlY29kZV9wYXVzZV9jdXJyZW50X2F1ZGlvXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgICAgICAgICAgICAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9wYXVzZV9hdWRpb1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICQodGhpcy5zdGF0dXMpLmh0bWwoXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcGxheWluZ1wiLCB0aGlzLnRvdXJOYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vbG9nIGNoYW5nZSB0byBkYlxuICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcIkF1ZGlvXCIsXG4gICAgICAgICAgICAgICAgYWN0OiBcInBsYXlcIixcbiAgICAgICAgICAgICAgICBkaXZfaWQ6IHRoaXMudGhlRGl2aWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhdWRpbyB3YXMgdGhpcy5wbGF5aW5nIHBhdXNlIGl0XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGxheWluZykge1xuICAgICAgICAgICAgdGhpcy5lbGVtLnBhdXNlKCk7IC8vIHBhdXNlIHRoZSBhdWRpb1xuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5jbGFzc05hbWUgPSBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tcGxheVwiO1xuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpby50aXRsZSA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3BsYXlfcGF1c2VkX2F1ZGlvXCIpO1xuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcGxheV9wYXVzZWRfYXVkaW9cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAkKHRoaXMuc3RhdHVzKS5odG1sKFxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F1ZGlvX3BhdXNlZFwiLCB0aGlzLnRvdXJOYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vbG9nIGNoYW5nZSB0byBkYlxuICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcIkF1ZGlvXCIsXG4gICAgICAgICAgICAgICAgYWN0OiBcInBhdXNlXCIsXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJvY2VzcyB0aGUgbGluZXNcbiAgICBwcm9jZXNzTGluZXMoZGl2aWQsIGxudW0sIGNvbG9yKSB7XG4gICAgICAgIHZhciBjb21tYSA9IGxudW0uc3BsaXQoXCIsXCIpO1xuICAgICAgICBpZiAoY29tbWEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZEZvckxpbmVzKGRpdmlkLCBjb21tYVtpXSwgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kRm9yTGluZXMoZGl2aWQsIGxudW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmhpZ2hsaWdodCB0aGUgbGluZXMgLSBzZXQgdGhlIGJhY2tncm91bmQgYmFjayB0byB0cmFuc3BhcmVudFxuICAgIHVuaGlnaGxpZ2h0TGluZXMoZGl2aWQsIGxudW0pIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzTGluZXMoZGl2aWQsIGxudW0sIFwidHJhbnNwYXJlbnRcIik7XG4gICAgfVxuICAgIC8vIGhpZ2hsaWdodCB0aGUgbGluZXMgLSBzZXQgdGhlIGJhY2tncm91bmQgdG8gYSB5ZWxsb3cgY29sb3JcbiAgICBoaWdobGlnaHRMaW5lcyhkaXZpZCwgbG51bSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NMaW5lcyhkaXZpZCwgbG51bSwgXCIjZmZmZjk5XCIpO1xuICAgIH1cbiAgICAvLyBzZXQgdGhlIGJhY2tncm91bmQgdG8gdGhlIHBhc3NlZCBjb2xvclxuICAgIHNldEJhY2tncm91bmRGb3JMaW5lcyhkaXZpZCwgbG51bSwgY29sb3IpIHtcbiAgICAgICAgdmFyIGh5cGhlbiA9IGxudW0uc3BsaXQoXCItXCIpO1xuICAgICAgICB2YXIgc3RyO1xuICAgICAgICAvLyBpZiBhIHJhbmdlIG9mIGxpbmVzXG4gICAgICAgIGlmIChoeXBoZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcGFyc2VJbnQoaHlwaGVuWzBdKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBwYXJzZUludChoeXBoZW5bMV0pICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBzdGFydDsgayA8IGVuZDsgaysrKSB7XG4gICAgICAgICAgICAgICAgLy9hbGVydChrKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBcIiNcIiArIGRpdmlkICsgXCJfbFwiICsgaztcbiAgICAgICAgICAgICAgICBpZiAoJChzdHIpLnRleHQoKSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICQoc3RyKS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8kKHN0cikuZWZmZWN0KFwiaGlnaGxpZ2h0XCIse30sKGR1cioxMDAwKSs0NTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vYWxlcnQobG51bSk7XG4gICAgICAgICAgICBzdHIgPSBcIiNcIiArIGRpdmlkICsgXCJfbFwiICsgbG51bTtcbiAgICAgICAgICAgICQoc3RyKS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgICAgIC8vJChzdHIpLmVmZmVjdChcImhpZ2hsaWdodFwiLHt9LChkdXIqMTAwMCkrNDUwMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIkLmkxOG4oKS5sb2FkKHtcbiAgICBlbjoge1xuICAgICAgICBtc2RfcHlmbGFrZXNfY29hY2hfbGluZTogXCJMaW5lXCIsXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQeWZsYWtlc0NvYWNoIHtcbiAgICBhc3luYyBjaGVjayhjb2RlKSB7XG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZmV0Y2goJy9ucy9jb2FjaC9weXRob25fY2hlY2snLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogY29kZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZihkYXRhLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAvL2NsZWFuIHVwIHJldHVybmVkIHRleHRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yTGluZXMgPSBkYXRhLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZUxpbmVzID0gY29kZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBsaW5lIG9mIGVycm9yTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxpbmUuaW5kZXhPZihcIi5weTpcIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29sZCBweWZsYWtlcyByZXR1cm5zIFwiZmlsZTpsaW5lOmNvbCBlcnJvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXcgcHlmbGFrZXMgcmV0dXJucyBcImZpbGU6bGluZTpjb2w6IGVycm9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hhbmRsZSBlaXRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVyID0gL1teLl0qLnB5OihcXGQrKTooXFxkKyk6PyAoLiopL2k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVQYXJ0cyA9IGxpbmUubWF0Y2goY2xlYW5lcik7ICAvL1sxXTogbGluZSwgWzJdOiBjb2wsIFszXTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvciBub3csIGZpbHRlciBtZXNzYWdlcyBhYm91dCBzdGFyIGltcG9ydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighbGluZVBhcnRzWzNdLmluY2x1ZGVzKFwiZGVmaW5lZCBmcm9tIHN0YXIgaW1wb3J0c1wiKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhbGluZVBhcnRzWzNdLmluY2x1ZGVzKFwiKicgdXNlZDsgdW5hYmxlIHRvIGRldGVjdCB1bmRlZmluZWQgbmFtZXNcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICQuaTE4bihcIm1zZF9weWZsYWtlc19jb2FjaF9saW5lXCIpICsgbGluZVBhcnRzWzFdICsgXCI6IFwiICsgbGluZVBhcnRzWzNdICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBjb2RlTGluZXNbbGluZVBhcnRzWzFdIC0gMV0gKyBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIFwiLnJlcGVhdChsaW5lUGFydHNbMl0gLSAxKSArIFwiXlxcblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5zbGljZSgwLC0xKTsgIC8vcmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJFcnJvciBpbiBQeWZsYWtlcyBDb2FjaDogXCIgKyBlcnIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbn1cblxuIiwidmFyIHRlc3RTdHJpbmcgPSBgU3RhcnRpbmcgVGVzdHNcbkV4cGVjdGVkOiBBbnN3ZXIgICAgICAgICAgICAgICAgICAgQWN0dWFsOiBBbnN3ZXIgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgbWV0aG9kIHByaW50QW5zd2VyKCkgICAgICAgICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkV4cGVjdGVkOiA2IGxpbmUocykgb2YgdGV4dCAgICAgICAgQWN0dWFsOiAwIGxpbmUocykgb2YgdGV4dCAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgbWFpbiBtZXRob2QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXNzZWQ6IGZhbHNlXG5IZWxsbyBXb3JsZFxuRXhwZWN0ZWQ6IFN0cmluZyBTdHJpbmcgICAgICAgICAgICBBY3R1YWw6IFN0cmluZyBTdHJpbmcgICAgICAgICAgICBNZXNzYWdlOiBDaGVja2luZyBJbnN0YW5jZSBWYXJpYWJsZSBUeXBlKHMpICAgICAgICAgICAgICAgIFBhc3NlZDogdHJ1ZVxuRXhwZWN0ZWQ6IFF1ZXN0aW9uICAgICAgICAgICAgICAgICBBY3R1YWw6IFF1ZXN0aW9uICAgICAgICAgICAgICAgICBNZXNzYWdlOiBDaGVja2luZyBtZXRob2QgcHJpbnRRdWVzdGlvbigpICAgICAgICAgICAgICAgICAgIFBhc3NlZDogdHJ1ZVxuRGVidWdnaW5nIG91dHB1dFxuTW9yZSBkZWJ1ZyBvdXRwdXRcbkV4cGVjdGVkOiAyIFByaXZhdGUgICAgICAgICAgICAgICAgQWN0dWFsOiAyIFByaXZhdGUgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgUHJpdmF0ZSBJbnN0YW5jZSBWYXJpYWJsZShzKSAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkV4cGVjdGVkOiBwYXNzICAgICAgICAgICAgICAgICAgICAgQWN0dWFsOiBwYXNzICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkV4cGVjdGVkOiBmYWlsICAgICAgICAgICAgICAgICAgICAgQWN0dWFsOiBmYWlsICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgZGVmYXVsdCBjb25zdHJ1Y3RvciAgICAgICAgICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcbkVuZGluZyBUZXN0c1xuWW91IGdvdCA2IG91dCBvZiA3IGNvcnJlY3QuIDg1LjcxJWA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpVbml0VGVzdFBhcnNlciB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0LCBwYXJlbnRJZCkge1xuICAgICAgICBsZXQgcGF0dCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBcIkV4cGVjdGVkOlxcXFxzKyguKj8pQWN0dWFsOlxcXFxzKyguKj8pTWVzc2FnZTpcXFxccysoLio/KVBhc3NlZDpcXFxccysodHJ1ZXxmYWxzZSlcIixcbiAgICAgICAgICAgIFwiZ1wiXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudGV4dFJlc3VsdHMgPSBcIlwiO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG91dHB1dC5tYXRjaEFsbChwYXR0KTtcbiAgICAgICAgbGV0IHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKFwidW5pdHRlc3QtcmVzdWx0c1wiKTtcbiAgICAgICAgbGV0IHRibCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcbiAgICAgICAgdGJsLmNsYXNzTGlzdC5hZGQoXCJhYy1mZWVkYmFja1wiKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRibCk7XG4gICAgICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtwYXJlbnRJZH1fdW5pdF9yZXN1bHRzYCk7XG4gICAgICAgIGxldCB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcbiAgICAgICAgdHIuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJhYy1mZWVkYmFja1wiPlJlc3VsdDwvdGg+PHRoIGNsYXNzPVwiYWMtZmVlZGJhY2tcIj5FeHBlY3RlZDwvdGg+PHRoIGNsYXNzPVwiYWMtZmVlZGJhY2tcIj5BY3R1YWw8L3RoPjx0aCBjbGFzcz1cImFjLWZlZWRiYWNrXCI+Tm90ZXM8L3RoPic7XG4gICAgICAgIHRibC5hcHBlbmRDaGlsZCh0cik7XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgbGV0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuICAgICAgICAgICAgbGV0IHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgICAgICAgdGQuY2xhc3NMaXN0LmFkZChcImFjLWZlZWRiYWNrXCIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGQuaW5uZXJIVE1MID0gXCJQYXNzXCI7XG4gICAgICAgICAgICAgICAgdGQuc3R5bGUgPVxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6IHJnYigxMzEsIDIxMSwgMTMwKTsgdGV4dC1hbGlnbjogY2VudGVyO1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZC5pbm5lckhUTUwgPSBcIkZhaWxcIjtcbiAgICAgICAgICAgICAgICB0ZC5zdHlsZSA9XG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyMiwgMTQyLCAxNTApOyB0ZXh0LWFsaWduOiBjZW50ZXI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG4gICAgICAgICAgICB0YmwuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgICAgICAgICAgdGQuaW5uZXJIVE1MID0gbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgdGQuY2xhc3NMaXN0LmFkZChcImFjLWZlZWRiYWNrXCIpO1xuICAgICAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRibC5hcHBlbmRDaGlsZCh0cik7XG4gICAgICAgICAgICB0aGlzLnRhYmxlID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy50ZXh0UmVzdWx0cyArPSBtYXRjaFswXSArIFwiXFxuXCI7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShtYXRjaFswXSwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoID0gb3V0cHV0Lm1hdGNoKFxuICAgICAgICAgICAgL1lvdSBnb3RcXHMrKFxcZCspIG91dCBvZiAoXFxkKykgY29ycmVjdC5cXHMrKFxcZCtcXC5cXGQrKSUvXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UobWF0Y2hbMF0sIFwiXCIpO1xuICAgICAgICAgICAgbGV0IHBjdFN0cmluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgcGN0U3RyaW5nLmlubmVySFRNTCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgdGhpcy5wY3RTdHJpbmcgPSBwY3RTdHJpbmc7XG4gICAgICAgICAgICB0aGlzLnBjdCA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgdGhpcy5wYXNzZWQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkID0gbWF0Y2hbMl0gLSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShcIlN0YXJ0aW5nIFRlc3RzXCIsIFwiXCIpO1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShcIkVuZGluZyBUZXN0c1wiLCBcIlwiKTtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIik7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8oPGJyPikrL2csIFwiPGJyPlwiKTtcbiAgICAgICAgLy8gZG8gbm90IG1lc3MgdXAgdGhpcyBuZXh0IGxpbmUsIGl0IGlzIFRIRSBoYWNrIHRoYXQgbWFrZXMgdHVydGxlIGdyYXBoaWNzIGFuZCBpbWFnZXMgd29ya1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZUFsbChcIiZsdDtpbWdcIiwgXCI8aW1nXCIpO1xuICAgICAgICB0aGlzLnN0ZG91dCA9IG91dHB1dDtcbiAgICB9XG59XG5cbi8vIGxldCB4ID0gbmV3IFJlc3VsdHNUb1RhYmxlKHRlc3RTdHJpbmcpO1xuLy8gY29uc29sZS5sb2coeC5zdGRvdXQpO1xuLy8gY29uc29sZS5sb2coeC50YWJsZSk7XG4iLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xuaW1wb3J0IE1ENSBmcm9tIFwiLi9tZDUuanNcIjtcbmltcG9ydCBKVW5pdFRlc3RQYXJzZXIgZnJvbSBcIi4vZXh0cmFjdFVuaXRSZXN1bHRzLmpzXCI7XG5pbXBvcnQgXCIuLi8uLi9jb2RlbGVucy9qcy9weXR1dG9yLWVtYmVkLmJ1bmRsZS5qc1wiO1xuaW1wb3J0IHsgYmFzZTY0ZW5jb2RlIH0gZnJvbSBcImJ5dGUtYmFzZTY0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVDb2RlIGV4dGVuZHMgQWN0aXZlQ29kZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgb3JpZyA9ICQob3B0cy5vcmlnKS5maW5kKFwidGV4dGFyZWFcIilbMF07XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLnN0ZGluID0gJChvcmlnKS5kYXRhKFwic3RkaW5cIik7XG4gICAgICAgIHRoaXMuZGF0YWZpbGUgPSAkKG9yaWcpLmRhdGEoXCJkYXRhZmlsZVwiKTtcbiAgICAgICAgdGhpcy5zb3VyY2VmaWxlID0gJChvcmlnKS5kYXRhKFwic291cmNlZmlsZVwiKTtcbiAgICAgICAgdGhpcy5jb21waWxlYXJncyA9IHVuZXNjYXBlSHRtbCgkKG9yaWcpLmRhdGEoXCJjb21waWxlYXJnc1wiKSk7XG4gICAgICAgIHRoaXMubGlua2FyZ3MgPSB1bmVzY2FwZUh0bWwoJChvcmlnKS5kYXRhKFwibGlua2FyZ3NcIikpO1xuICAgICAgICB0aGlzLnJ1bmFyZ3MgPSB1bmVzY2FwZUh0bWwoJChvcmlnKS5kYXRhKFwicnVuYXJnc1wiKSk7XG4gICAgICAgIHRoaXMuaW50ZXJwcmV0ZXJhcmdzID0gdW5lc2NhcGVIdG1sKCQob3JpZykuZGF0YShcImludGVycHJldGVyYXJnc1wiKSk7XG4gICAgICAgIHRoaXMuQVBJX0tFWSA9IFwiNjcwMzNwVjdlVVV2cW8wN09KRElWOFVaMDQ5YUxFSzFcIjtcbiAgICAgICAgdGhpcy5VU0VfQVBJX0tFWSA9IHRydWU7XG4gICAgICAgIHRoaXMuSk9CRV9TRVJWRVIgPSBlQm9va0NvbmZpZy5qb2JlaG9zdCB8fCBlQm9va0NvbmZpZy5ob3N0O1xuICAgICAgICB0aGlzLnJlc291cmNlID0gZUJvb2tDb25maWcucHJveHl1cmlfcnVucyB8fCBcIi9ydW5lc3RvbmUvcHJveHkvam9iZVJ1blwiO1xuICAgICAgICB0aGlzLmpvYmVQdXRGaWxlcyA9XG4gICAgICAgICAgICBlQm9va0NvbmZpZy5wcm94eXVyaV9maWxlcyB8fCBcIi9ydW5lc3RvbmUvcHJveHkvam9iZVB1c2hGaWxlL1wiO1xuICAgICAgICB0aGlzLmpvYmVDaGVja0ZpbGVzID1cbiAgICAgICAgICAgIGVCb29rQ29uZmlnLnByb3h5dXJpX2ZpbGVzIHx8IFwiL3J1bmVzdG9uZS9wcm94eS9qb2JlQ2hlY2tGaWxlL1wiO1xuICAgICAgICAvLyBUT0RPOiAgc2hvdWxkIGFkZCBhIHByb3BlciBwdXQvY2hlY2sgaW4gcGF2ZW1lbnQudG1wbCBhcyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIHdpbGwgYnJlYWsgb24gcnVuZXN0b25lXG4gICAgICAgIHRoaXMuZGl2MmlkID0ge307XG4gICAgICAgIGlmICh0aGlzLnN0ZGluKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUlucHV0RWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlRXJyb3JPdXRwdXQoKTtcbiAgICB9XG4gICAgb3V0cHV0ZnVuKGEpIHt9XG4gICAgY3JlYXRlSW5wdXRFbGVtZW50KCkge1xuICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgIGxhYmVsLmZvciA9IHRoaXMuZGl2aWQgKyBcIl9zdGRpblwiO1xuICAgICAgICAkKGxhYmVsKS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2lucHV0X3ByZ1wiKSk7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQuaWQgPSB0aGlzLmRpdmlkICsgXCJfc3RkaW5cIjtcbiAgICAgICAgaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBpbnB1dC5zaXplID0gXCIzNVwiO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMuc3RkaW47XG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgdGhpcy5zdGRpbl9lbCA9IGlucHV0O1xuICAgIH1cbiAgICBjcmVhdGVFcnJvck91dHB1dCgpIHt9XG5cbiAgICAvKiAgTWFpbiBydW5Qcm9nIG1ldGhvZCBmb3IgbGl2ZWNvZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHJ1blByb2cobm9VSSwgbG9nUmVzdWx0cykge1xuICAgICAgICBpZiAodHlwZW9mIGxvZ1Jlc3VsdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1Jlc3VsdHMgPSBsb2dSZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9VSSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIG5vVUkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnJ1blNldHVwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgdGhpcy5zdWJtaXRUb0pvYmUoKTtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAkLmkxOG4oYFNlcnZlciBFcnJvcjogJHtyZXMuc3RhdHVzVGV4dH1gKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZhaWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydW5SZXN1bHRzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0pvYmVSZXNwb25zZShydW5SZXN1bHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKFxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3NlcnZlcl9jb21tX2VyclwiKSArIGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBgZmFpbDogJHtlfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwic3VjY2Vzc1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RlOlxuICAgICAqIEluIG9yZGVyIHRvIGNoZWNrIGZvciBzdXBwbGVtZW50YWwgZmlsZXMgaW4gamF2YSBhbmQgZGVhbCB3aXRoIGFzeW5jaHJvbmljaXR5XG4gICAgICogSSBzcGxpdCB0aGUgb3JpZ2luYWwgcnVuUHJvZyBpbnRvIHR3byBmdW5jdGlvbnM6IHJ1blByb2cgYW5kIHJ1blByb2dfY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhc3luYyBydW5TZXR1cCgpIHtcbiAgICAgICAgdmFyIHN0ZGluO1xuICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICB2YXIgc2F2ZUNvZGUgPSBcIlRydWVcIjtcbiAgICAgICAgdmFyIHNmaWxlbWFwID0ge1xuICAgICAgICAgICAgamF2YTogXCJcIixcbiAgICAgICAgICAgIGNwcDogXCJ0ZXN0LmNwcFwiLFxuICAgICAgICAgICAgYzogXCJ0ZXN0LmNcIixcbiAgICAgICAgICAgIHB5dGhvbjM6IFwidGVzdC5weVwiLFxuICAgICAgICAgICAgcHl0aG9uMjogXCJ0ZXN0LnB5XCIsXG4gICAgICAgICAgICBvY3RhdmU6IFwib2N0YXRlc3QubVwiLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc291cmNlZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICB2YXIgdGVzdGRyaXZlcm5hbWUgPSBcIlwiO1xuICAgICAgICB2YXIgZmlsZV9jaGVja3A7XG5cbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgY2xhc3MgbmFtZXMgc28gZmlsZXMgY2FuIGJlIG5hbWVkIHByb3Blcmx5XG4gICAgICAgIGlmICh0aGlzLnN1ZmZpeCAmJiB0aGlzLmxhbmd1YWdlID09IFwiamF2YVwiKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3VmZml4IGNvbnRhaW5zIHVuaXQgdGVzdCBjb2RlIGFuZCBzaG91bGQgaW5jbHVkZSBhbmQgaW1wb3J0IG9mIGp1bml0XG4gICAgICAgICAgICAvLyBpbXBvcnQgc3RhdGljIG9yZy5qdW5pdC5Bc3NlcnQuKjtcbiAgICAgICAgICAgIC8vIGltcG9ydCBvcmcuanVuaXQuKjtcbiAgICAgICAgICAgIC8vIGltcG9ydCBqYXZhLmlvLio7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWZmaXguaW5kZXhPZihcImltcG9ydCBvcmcuanVuaXRcIikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1pc3NpbmcgaW1wb3J0cyBpbiB1bml0IHRlc3RzOlxuICAgICAgICAgICAgICAgICAgICAke3RoaXMuc3VmZml4fWApO1xuICAgICAgICAgICAgICAgIC8vIGFsZXJ0KFwiVGhlIHVuaXQgdGVzdHMgZm9yIHRoaXMgcHJvYmxlbSBhcmUgaW5jb21wbGV0ZSwgUGxlYXNlIHJlcG9ydCB0aGlzLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1ZmZpeCA9XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICBpbXBvcnQgc3RhdGljIG9yZy5qdW5pdC5Bc3NlcnQuKjtcbiAgICAgICAgICAgICAgICBpbXBvcnQgb3JnLmp1bml0Lio7XG4gICAgICAgICAgICAgICAgaW1wb3J0IGphdmEuaW8uKjtcbiAgICAgICAgICAgICAgICBgICsgdGhpcy5zdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2xhc3NNYXRjaCA9IG5ldyBSZWdFeHAoL3B1YmxpY1xccytjbGFzc1xccysoXFx3KykvKTtcbiAgICAgICAgICAgIHNvdXJjZSA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKGZhbHNlKTtcbiAgICAgICAgICAgIGxldCBtID0gc291cmNlLm1hdGNoKGNsYXNzTWF0Y2gpO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VmaWxlbmFtZSA9IG1bMV0gKyBcIi5qYXZhXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgdW5pdCB0ZXN0IGNvZGVcbiAgICAgICAgICAgIG0gPSB0aGlzLnN1ZmZpeC5tYXRjaChjbGFzc01hdGNoKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgdGVzdGRyaXZlcm5hbWUgPSBtWzFdICsgXCIuamF2YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlID0gYXdhaXQgdGhpcy5idWlsZFByb2codHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgaXMgY29udmVydGlibGUgdG8gQmFzZTY0LiBJZiBub3QgdGhlbiBlcnJvciBvdXQgbm93XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBidG9hKHNvdXJjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGFsZXJ0KFxuICAgICAgICAgICAgICAgIFwiRXJyb3I6IEJhZCBDaGFyYWN0ZXJzIGluIHRoZSBhY3RpdmVjb2RlIHdpbmRvdy4gTGlrZWx5IGEgcXVvdGUgY2hhcmFjdGVyIHRoYXQgaGFzIGJlZW4gY29weS9wYXN0ZWQuIPCfmYFcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBhd2FpdCB0aGlzLm1hbmFnZV9zY3J1YmJlcihzYXZlQ29kZSk7XG5cbiAgICAgICAgLy8gYXNzZW1ibGUgcGFyYW1ldGVycyBmb3IgSk9CRVxuICAgICAgICB2YXIgcGFyYW1saXN0ID0gW1xuICAgICAgICAgICAgXCJjb21waWxlYXJnc1wiLFxuICAgICAgICAgICAgXCJsaW5rYXJnc1wiLFxuICAgICAgICAgICAgXCJydW5hcmdzXCIsXG4gICAgICAgICAgICBcImludGVycHJldGVyYXJnc1wiLFxuICAgICAgICAgICAgXCJtZW1vcnlsaW1pdFwiLFxuICAgICAgICBdO1xuICAgICAgICB2YXIgcGFyYW1vYmogPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcGFyYW0gb2YgcGFyYW1saXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpc1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICBwYXJhbW9ialtwYXJhbV0gPSBldmFsKHRoaXNbcGFyYW1dKTsgLy8gbmVlZHMgYSBsaXN0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFuZ3VhZ2UgPT09IFwib2N0YXZlXCIpIHtcbiAgICAgICAgICAgIHBhcmFtb2JqLm1lbW9yeWxpbWl0ID0gMjAwMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RkaW4pIHtcbiAgICAgICAgICAgIHN0ZGluID0gJCh0aGlzLnN0ZGluX2VsKS52YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc291cmNlZmlsZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VmaWxlID0gc2ZpbGVtYXBbdGhpcy5sYW5ndWFnZV07XG4gICAgICAgIH1cblxuICAgICAgICAkKHRoaXMub3V0cHV0KS5odG1sKCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2NvbXBpbGluZ19ydW5uaW5nXCIpKTtcbiAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICAgIHZhciBjb250ZW50LCBiYXNlNjQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGFmaWxlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGlkcyA9IHRoaXMuZGF0YWZpbGUuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSBpZHNbaV0udHJpbSgpO1xuICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlID09PSBudWxsIHx8IGZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdbZGF0YS1maWxlbmFtZT1cIicgKyBmaWxlTmFtZSArICdcIl0nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmaWxlRXh0ZW5zaW9uID0gZmlsZU5hbWUuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSA9PT0gbnVsbCB8fCBmaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJObyBmaWxlIHdpdGggZ2l2ZW4gaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBmaWxlIGlzIGluIGRiXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmZpbGVSZWFkZXIoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmaWxlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXkgYmUgdW5kZWZpbmVkIGF0IHRoaXMgcG9pbnQgaWYgZmlsZSBpcyBhbiBpbWFnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZUV4dGVuc2lvbiA9PT0gXCJqYXJcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdCh0aGlzLnBhcnNlSmF2YUNsYXNzZXMoY29udGVudCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoW1wianBnXCIsIFwicG5nXCIsIFwiZ2lmXCJdLmluZGV4T2YoZmlsZUV4dGVuc2lvbikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUudG9EYXRhVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0ID0gZmlsZS50b0RhdGFVUkwoXCJpbWFnZS9cIiArIGZpbGVFeHRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoYmFzZTY0LmluZGV4T2YoXCIsXCIpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGZpbGUuc3JjLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zcmMuaW5kZXhPZihcIixcIikgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaCh7IG5hbWU6IGZpbGVOYW1lLCBjb250ZW50OiBiYXNlNjQgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gY2xhc3NOYW1lIG9yIHVuIHJlY29nbml6ZWQgY2xhc3NOYW1lIGl0IGlzIHRyZWF0ZWQgYXMgYW4gaW5kaXZpZHVhbCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgYW55IHR5cGUgb2YgZmlsZSwgLnR4dCwgLmphdmEsIC5jc3YsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHsgbmFtZTogZmlsZU5hbWUsIGNvbnRlbnQ6IGNvbnRlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSBydW5uaW5nIHVuaXQgdGVzdHMgd2UgbmVlZCB0byBzdWJzdGl0dXRlIHRoZSB0ZXN0IGRyaXZlciBmb3IgdGhlIHN0dWRlbnRcbiAgICAgICAgLy8gY29kZSBhbmQgc2VuZCB0aGUgc3R1ZGVudCBjb2RlIGFzIGEgZmlsZS4gIFdlJ2xsIGRvIHRoYXQgaGVyZS5cbiAgICAgICAgdGhpcy5qdW5pdERyaXZlckNvZGUgPSBgXG4gICAgICAgIGltcG9ydCBvcmcuanVuaXQucnVubmVyLkpVbml0Q29yZTtcbiAgICAgICAgaW1wb3J0IG9yZy5qdW5pdC5ydW5uZXIuUmVzdWx0O1xuICAgICAgICBpbXBvcnQgb3JnLmp1bml0LnJ1bm5lci5ub3RpZmljYXRpb24uRmFpbHVyZTtcblxuICAgICAgICBwdWJsaWMgY2xhc3MgVGVzdFJ1bm5lciB7XG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgbWFpbihTdHJpbmdbXSBhcmdzKSB7XG4gICAgICAgICAgICAgICAgQ29kZVRlc3RIZWxwZXIucmVzZXRGaW5hbFJlc3VsdHMoKTtcbiAgICAgICAgICAgICAgICBSZXN1bHQgcmVzdWx0ID0gSlVuaXRDb3JlLnJ1bkNsYXNzZXMoJHt0ZXN0ZHJpdmVybmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICBcIi5qYXZhXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiLmNsYXNzXCJcbiAgICAgICAgICAgICAgICApfSk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLm91dC5wcmludGxuKENvZGVUZXN0SGVscGVyLmdldEZpbmFsUmVzdWx0cygpKTtcblxuICAgICAgICAgICAgICAgIGludCB0b3RhbCA9IHJlc3VsdC5nZXRSdW5Db3VudCgpO1xuICAgICAgICAgICAgICAgIGludCBmYWlscyA9IHJlc3VsdC5nZXRGYWlsdXJlQ291bnQoKTtcbiAgICAgICAgICAgICAgICBpbnQgY29yciAgPSB0b3RhbCAtIGZhaWxzO1xuICAgICAgICAgICAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihcIllvdSBnb3QgXCIgKyBjb3JyICsgXCIgb3V0IG9mIFwiICsgdG90YWwgKyBcIiBjb3JyZWN0LiBcIiArIFN0cmluZy5mb3JtYXQoXCIlLjJmXCIsICgxMDAuMCAqIGNvcnIgLyB0b3RhbCkpICsgXCIlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIGlmICh0aGlzLnN1ZmZpeCAmJiB0aGlzLmxhbmd1YWdlID09IFwiamF2YVwiKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKHsgbmFtZTogc291cmNlZmlsZW5hbWUsIGNvbnRlbnQ6IHNvdXJjZSB9KTtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goeyBuYW1lOiB0ZXN0ZHJpdmVybmFtZSwgY29udGVudDogdGhpcy5zdWZmaXggfSk7XG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLmp1bml0RHJpdmVyQ29kZTtcbiAgICAgICAgICAgIGlmIChwYXJhbW9iai5jb21waWxlYXJncykge1xuICAgICAgICAgICAgICAgIHBhcmFtb2JqLmNvbXBpbGVhcmdzLnB1c2goc291cmNlZmlsZW5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbW9iai5jb21waWxlYXJncyA9IFtzb3VyY2VmaWxlbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJ1bnNwZWMgPSB7XG4gICAgICAgICAgICBsYW5ndWFnZV9pZDogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgICAgIHNvdXJjZWNvZGU6IHNvdXJjZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtb2JqLFxuICAgICAgICAgICAgc291cmNlZmlsZW5hbWU6IHRoaXMuc291cmNlZmlsZSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RkaW4pIHtcbiAgICAgICAgICAgIHJ1bnNwZWMuaW5wdXQgPSBzdGRpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmpzb25fcnVuc3BlYyA9IEpTT04uc3RyaW5naWZ5KHsgcnVuX3NwZWM6IHJ1bnNwZWMgfSk7XG4gICAgICAgICAgICBmaWxlX2NoZWNrcCA9IFByb21pc2UucmVzb2x2ZShcInJlYWR5XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuc3BlY1tcImZpbGVfbGlzdFwiXSA9IFtdO1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gZmlsZXNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQgPSBmaWxlc1tpXS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRpdjJpZFtmaWxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICBcInJ1bmVzdG9uZVwiICsgTUQ1KGZpbGVOYW1lICsgZmlsZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJ1bnNwZWNbXCJmaWxlX2xpc3RcIl0ucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmRpdjJpZFtmaWxlTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNoZWNrRmlsZShmaWxlc1tpXSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5qc29uX3J1bnNwZWMgPSBKU09OLnN0cmluZ2lmeSh7IHJ1bl9zcGVjOiBydW5zcGVjIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXYyaWQgPSBpbnN0YW5jZS5kaXYyaWQ7XG4gICAgICAgICAgICBmaWxlX2NoZWNrcCA9IFByb21pc2UuYWxsKHByb21pc2VzKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVfY2hlY2twO1xuICAgIH1cblxuICAgIC8qIFN1Ym1pdCB0aGUgYXNzZW1ibGVkIGpvYiB0byB0aGUgSk9CRSBzZXJ2ZXIgYW5kIGF3YWl0IHRoZSByZXN1bHRzLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0VG9Kb2JlKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuanNvbl9ydW5zcGVjO1xuICAgICAgICBsZXQgaG9zdCA9IHRoaXMuSk9CRV9TRVJWRVIgKyB0aGlzLnJlc291cmNlO1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJCh0aGlzLm91dERpdikuc2hvdyh7IGR1cmF0aW9uOiA3MDAsIHF1ZXVlOiBmYWxzZSB9KTtcbiAgICAgICAgJCh0aGlzLmVyckRpdikucmVtb3ZlKCk7XG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuXG4gICAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgXCJDb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgXCJYLUFQSS1LRVlcIjogdGhpcy5BUElfS0VZLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChob3N0LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmV0Y2gocmVxdWVzdCk7XG5cbiAgICAgICAgLy8vJChcIiNcIiArIGRpdmlkICsgXCJfZXJyaW5mb1wiKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzSm9iZVJlc3BvbnNlKHJlc3VsdCkge1xuICAgICAgICB2YXIgbG9ncmVzdWx0O1xuICAgICAgICB2YXIgb2RpdiA9IHRoaXMub3V0cHV0O1xuICAgICAgICB0aGlzLnBhcnNlZE91dHB1dCA9IHt9O1xuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIGlmIChyZXN1bHQub3V0Y29tZSA9PT0gMTUpIHtcbiAgICAgICAgICAgIGxvZ3Jlc3VsdCA9IFwic3VjY2Vzc1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9ncmVzdWx0ID0gcmVzdWx0Lm91dGNvbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJpbmZvID0gbG9ncmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHJlc3VsdC5vdXRjb21lKSB7XG4gICAgICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRPdXRwdXQgPSBuZXcgSlVuaXRUZXN0UGFyc2VyKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3Rkb3V0LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAkKG9kaXYpLmh0bWwodGhpcy5wYXJzZWRPdXRwdXQuc3Rkb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VkT3V0cHV0LnBjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZE91dHB1dC5wY3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkT3V0cHV0LnBhc3NlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRPdXRwdXQuZmFpbGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaXRfcmVzdWx0cyA9IGBwZXJjZW50OiR7dGhpcy5wYXJzZWRPdXRwdXQucGN0fTpwYXNzZWQ6JHt0aGlzLnBhcnNlZE91dHB1dC5wYXNzZWR9OmZhaWxlZDoke3RoaXMucGFyc2VkT3V0cHV0LmZhaWxlZH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIGNvbXBpbGVyIGVycm9yXG4gICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3dlcmVfY29tcGlsaW5nX2VyclwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKHJlc3VsdC5jbXBpbmZvKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycmluZm8gPSByZXN1bHQuY21waW5mbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6IC8vIHJ1biB0aW1lIGVycm9yXG4gICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKHJlc3VsdC5zdGRvdXQucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKHJlc3VsdC5zdGRlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTM6IC8vIHRpbWUgbGltaXRcbiAgICAgICAgICAgICAgICAkKG9kaXYpLmh0bWwoZXNjYXBlSHRtbChyZXN1bHQuc3Rkb3V0LnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXhjXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKHJlc3VsdC5zdGRlcnIucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRKb2JlRXJyb3JNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2VydmVyX2VyclwiKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBoYW5kbGUgc2VydmVyIGJ1c3kgYW5kIHRpbWVvdXQgZXJyb3JzIHRvb1xuICAgIH1cblxuICAgIHJlbmRlckZlZWRiYWNrKCkge1xuICAgICAgICBsZXQgcmRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke3RoaXMuZGl2aWR9X3VuaXRfcmVzdWx0c2ApO1xuICAgICAgICBpZiAocmRpdikge1xuICAgICAgICAgICAgcmRpdi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJzZWRPdXRwdXQgJiYgdGhpcy5wYXJzZWRPdXRwdXQudGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0RGl2LmFwcGVuZENoaWxkKHRoaXMucGFyc2VkT3V0cHV0LnRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYCR7dGhpcy5kaXZpZH1fdW5pdF9yZXN1bHRzYCk7XG4gICAgICAgIGlmIChyZGl2KSB7XG4gICAgICAgICAgICByZGl2LmFwcGVuZENoaWxkKHRoaXMucGFyc2VkT3V0cHV0LnBjdFN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRKb2JlRXJyb3JNZXNzYWdlKGVycikge1xuICAgICAgICB2YXIgZXJySGVhZCA9ICQoXCI8aDM+XCIpLmh0bWwoXCJFcnJvclwiKTtcbiAgICAgICAgdmFyIGVDb250YWluZXIgPSB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVyckRpdiA9IGVDb250YWluZXI7XG4gICAgICAgIGVDb250YWluZXIuY2xhc3NOYW1lID0gXCJlcnJvciBhbGVydCBhbGVydC1kYW5nZXJcIjtcbiAgICAgICAgZUNvbnRhaW5lci5pZCA9IHRoaXMuZGl2aWQgKyBcIl9lcnJpbmZvXCI7XG4gICAgICAgIGVDb250YWluZXIuYXBwZW5kQ2hpbGQoZXJySGVhZFswXSk7XG4gICAgICAgIHZhciBlcnJUZXh0ID0gZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpKTtcbiAgICAgICAgZXJyVGV4dC5pbm5lckhUTUwgPSBlc2NhcGVIdG1sKGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgZmlsZSBpcyBvbiBzZXJ2ZXJcbiAgICAgKiBQbGFjZXMgaXQgb24gc2VydmVyIGlmIGl0IGlzIG5vdCBvbiBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R7bmFtZSwgY29udGVudHN9fSBmaWxlICAgIEZpbGUgdG8gcGxhY2Ugb24gc2VydmVyXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHJlc29sdmUgcHJvbWlzZSByZXNvbHZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHJlamVjdCAgcHJvbWlzZSByZWplY3QgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBjaGVja0ZpbGUoZmlsZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBmaWxlX2lkID0gdGhpcy5kaXYyaWRbZmlsZS5uYW1lXTtcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5qb2JlQ2hlY2tGaWxlcyArIGZpbGVfaWQ7XG4gICAgICAgIHZhciBob3N0ID0gdGhpcy5KT0JFX1NFUlZFUiArIHJlc291cmNlO1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiSEVBRFwiLCBob3N0LCB0cnVlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1BUEktS0VZXCIsIHRoaXMuQVBJX0tFWSk7XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJlcnJvciBzZW5kaW5nIGZpbGVcIiArIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDg6XG4gICAgICAgICAgICAgICAgY2FzZSA0MDQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRmlsZSBub3Qgb24gU2VydmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hEYXRhRmlsZShmaWxlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJCYWQgUmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkZpbGUgYWxyZWFkeSBvbiBTZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgYSBmaWxlIG9uIGEgc2VydmVyXG4gICAgICovXG4gICAgcHVzaERhdGFGaWxlKGZpbGUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgIHZhciBleHRlbnNpb24gPSBmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUuaW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICAgICAgdmFyIGZpbGVfaWQgPSB0aGlzLmRpdjJpZFtmaWxlTmFtZV07XG4gICAgICAgIHZhciBjb250ZW50cyA9IGZpbGUuY29udGVudDtcbiAgICAgICAgLy8gRmlsZSB0eXBlcyBiZWluZyB1cGxvYWRlZCB0aGF0IGNvbWUgaW4gYWxyZWFkeSBpbiBiYXNlNjQgZm9ybWF0XG4gICAgICAgIHZhciBleHRlbnNpb25zID0gW1wiamFyXCIsIFwiemlwXCIsIFwicG5nXCIsIFwianBnXCIsIFwianBlZ1wiXTtcbiAgICAgICAgdmFyIGNvbnRlbnRzYjY0O1xuICAgICAgICBpZiAoZXh0ZW5zaW9ucy5pbmRleE9mKGV4dGVuc2lvbikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZW50c2I2NCA9IGJhc2U2NGVuY29kZShjb250ZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50c2I2NCA9IGNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoeyBmaWxlX2NvbnRlbnRzOiBjb250ZW50c2I2NCB9KTtcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5qb2JlUHV0RmlsZXMgKyBmaWxlX2lkO1xuICAgICAgICB2YXIgaG9zdCA9IHRoaXMuSk9CRV9TRVJWRVIgKyByZXNvdXJjZTtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBVVFwiLCBob3N0LCB0cnVlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1BUEktS0VZXCIsIHRoaXMuQVBJX0tFWSk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHhoci5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJGb3JiaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJCYWQgUmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3VjY2Vzc2Z1bGx5IHNlbnQgZmlsZSBcIiArIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRmlsZSBcIiArIGZpbGVOYW1lICtcIiwgXCIgKyBmaWxlX2lkICtcIiBwbGFjZWQgb24gc2VydmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVGhpcyBjYXNlIHNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJlcnJvciBzZW5kaW5nIGZpbGVcIiArIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKGRhdGEpO1xuICAgIH1cblxuICAgIGFzeW5jIHNob3dDb2RlbGVucygpIHtcbiAgICAgICAgbGV0IGNsTWVzcyA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmNvZGVsZW5zLnN0eWxlLmRpc3BsYXkgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIGNsTWVzcyA9IFwiQnVpbGRpbmcgeW91ciB2aXN1YWxpemF0aW9uXCI7XG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLmlubmVySFRNTCA9IGNsTWVzcztcbiAgICAgICAgICAgIHRoaXMuY2xCdXR0b24uaW5uZXJUZXh0ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfaGlkZV9jb2RlbGVuc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgdGhpcy5jbEJ1dHRvbi5pbm5lclRleHQgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zaG93X2luX2NvZGVsZW5zXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbCA9IHRoaXMuY29kZWxlbnMuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGNsKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLnJlbW92ZUNoaWxkKGNsKTtcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMuaW5uZXJIVE1MID0gY2xNZXNzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlID0gYXdhaXQgdGhpcy5idWlsZFByb2coZmFsc2UpO1xuICAgICAgICBpZiAoY29kZS5tYXRjaCgvU3lzdGVtLmV4aXQvKSkge1xuICAgICAgICAgICAgYWxlcnQoXG4gICAgICAgICAgICAgICAgXCJTb3JyeS4uLiBTeXN0ZW0uZXhpdCBicmVha3MgdGhlIHZpc3VhbGl6ZXIgdGVtcG9yYXJpbHkgcmVtb3ZpbmdcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1N5c3RlbS5leGl0XFwoXFxkK1xcKTsvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXlWYXJzID0ge307XG4gICAgICAgIG15VmFycy5jb2RlID0gY29kZTtcbiAgICAgICAgbXlWYXJzLmxhbmcgPSB0aGlzLmxhbmd1YWdlO1xuICAgICAgICBpZiAodGhpcy5zdGRpbikge1xuICAgICAgICAgICAgbXlWYXJzLnN0ZGluID0gJCh0aGlzLnN0ZGluX2VsKS52YWwoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0RGl2ID0gdGhpcy5jb2RlbGVucy5pZDtcblxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KFwiL3J1bmVzdG9uZS9wcm94eS9weXR1dG9yX3RyYWNlXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShteVZhcnMpLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5qc29uSGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgbGV0IHZpcyA9IGFkZFZpc3VhbGl6ZXJUb1BhZ2UoZGF0YSwgdGFyZ2V0RGl2LCB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdJbnN0cnVjdGlvbjogMCxcbiAgICAgICAgICAgICAgICBlZGl0Q29kZUJhc2VVUkw6IG51bGwsXG4gICAgICAgICAgICAgICAgaGlkZUNvZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhbmc6IG15VmFycy5sYW5nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGl2RXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXREaXYpO1xuICAgICAgICAgICAgdGFyZ2V0RGl2RXJyb3IuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBcIlNvcnJ5LCBhbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyB5b3VyIHZpc3VhbGl6YXRpb24uXCI7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdldCBUcmFjZSBGYWlsZWQgLS0gXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwiY29kZWxlbnNcIixcbiAgICAgICAgICAgIGFjdDogXCJ2aWV3XCIsXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcGVyYXRlcyB0ZXh0IGludG8gbXVsdGlwbGUgLmphdmEgZmlsZXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgU3RyaW5nIHdpdGggbXVsaXBsZSBqYXZhIGNsYXNzZXMgbmVlZGVkIHRvIGJlIHNlcGVyYXRlZFxuICAgICAqIEByZXR1cm4ge2FycmF5IG9mIG9iamVjdHN9ICAubmFtZSBnaXZlcyB0aGUgbmFtZSBvZiB0aGUgamF2YSBmaWxlIHdpdGggLmphdmEgZXh0ZW5zaW9uXG4gICAgICogICAgICAgICAgICAgICAgICAgLmNvbnRlbnQgZ2l2ZXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlXG4gICAgICovXG4gICAgcGFyc2VKYXZhQ2xhc3Nlcyh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGFjayA9IDA7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICAgICAgdmFyIGltcG9ydEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGVuZE9mTGFzdENvbW1lbnRCZWZvcmVDbGFzc0JlZ2lucyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRleHQuY2hhckF0KGkpICE9PSBcIlxcblwiICYmIGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mTGFzdENvbW1lbnRCZWZvcmVDbGFzc0JlZ2lucyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHQuY2hhckF0KGkpID09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRleHQuY2hhckF0KGkpICE9PSBcIipcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuY2hhckF0KGkgKyAxKSAhPT0gXCIvXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpICsgMSA8IHRleHQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mTGFzdENvbW1lbnRCZWZvcmVDbGFzc0JlZ2lucyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRleHQuY2hhckF0KGkpICE9PSAnXCInICYmIGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0ZXh0LmNoYXJBdChpKSAhPT0gXCInXCIgJiYgaSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBDb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwQ291bnQgPiAwICYmIGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0LmNoYXJBdChpKSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kICYmIHRleHQuY2hhckF0KGkpID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjayA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kICYmIHN0YWNrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmRzID0gdGV4dFxuICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKGVuZE9mTGFzdENvbW1lbnRCZWZvcmVDbGFzc0JlZ2lucywgc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gd29yZHNbd107XG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3Jkc1t3XSA9PT0gXCJleHRlbmRzXCIgfHwgd29yZHNbd10gPT09IFwiaW1wbGVtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSB3b3Jkc1t3IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gd29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS50cmltKCkgKyBcIi5qYXZhXCI7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0LnN1YnN0cmluZyhpbXBvcnRJbmRleCwgZW5kSW5kZXgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW1wb3J0SW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgICAgICAgICBlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMgPSBlbmRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG59XG5mdW5jdGlvbiB1bmVzY2FwZUh0bWwoc2FmZSkge1xuICAgIGlmIChzYWZlKSB7XG4gICAgICAgIHJldHVybiBzYWZlXG4gICAgICAgICAgICAucmVwbGFjZSgvJmFtcDsvZywgXCImXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYjeDI3Oy9nLCBcIidcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgICBpZiAoc3RyKSB7XG5cdHJldHVybiBzdHJcblx0ICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG5cdCAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdCAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG5cdCAgICAucmVwbGFjZSgvJy9nLCAnJiN4Mjc7Jylcblx0ICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogIE1ENSAoTWVzc2FnZS1EaWdlc3QgQWxnb3JpdGhtKVxuICogIGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvL1xuICpcbiAqKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTUQ1KHN0cmluZykge1xuICAgIGZ1bmN0aW9uIFJvdGF0ZUxlZnQobFZhbHVlLCBpU2hpZnRCaXRzKSB7XG4gICAgICAgIHJldHVybiAobFZhbHVlIDw8IGlTaGlmdEJpdHMpIHwgKGxWYWx1ZSA+Pj4gKDMyIC0gaVNoaWZ0Qml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFkZFVuc2lnbmVkKGxYLCBsWSkge1xuICAgICAgICB2YXIgbFg0LCBsWTQsIGxYOCwgbFk4LCBsUmVzdWx0O1xuICAgICAgICBsWDggPSBsWCAmIDB4ODAwMDAwMDA7XG4gICAgICAgIGxZOCA9IGxZICYgMHg4MDAwMDAwMDtcbiAgICAgICAgbFg0ID0gbFggJiAweDQwMDAwMDAwO1xuICAgICAgICBsWTQgPSBsWSAmIDB4NDAwMDAwMDA7XG4gICAgICAgIGxSZXN1bHQgPSAobFggJiAweDNmZmZmZmZmKSArIChsWSAmIDB4M2ZmZmZmZmYpO1xuICAgICAgICBpZiAobFg0ICYgbFk0KSB7XG4gICAgICAgICAgICByZXR1cm4gbFJlc3VsdCBeIDB4ODAwMDAwMDAgXiBsWDggXiBsWTg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxYNCB8IGxZNCkge1xuICAgICAgICAgICAgaWYgKGxSZXN1bHQgJiAweDQwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiAweGMwMDAwMDAwIF4gbFg4IF4gbFk4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbFJlc3VsdCBeIDB4NDAwMDAwMDAgXiBsWDggXiBsWTg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbFJlc3VsdCBeIGxYOCBeIGxZODtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEYoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEcoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEgoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEkoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4geSBeICh4IHwgfnopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIGFjKSB7XG4gICAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChGKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIGFjKSB7XG4gICAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChHKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIGFjKSB7XG4gICAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChIKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIGFjKSB7XG4gICAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChJKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnZlcnRUb1dvcmRBcnJheShzdHJpbmcpIHtcbiAgICAgICAgdmFyIGxXb3JkQ291bnQ7XG4gICAgICAgIHZhciBsTWVzc2FnZUxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIHZhciBsTnVtYmVyT2ZXb3Jkc190ZW1wMSA9IGxNZXNzYWdlTGVuZ3RoICsgODtcbiAgICAgICAgdmFyIGxOdW1iZXJPZldvcmRzX3RlbXAyID1cbiAgICAgICAgICAgIChsTnVtYmVyT2ZXb3Jkc190ZW1wMSAtIChsTnVtYmVyT2ZXb3Jkc190ZW1wMSAlIDY0KSkgLyA2NDtcbiAgICAgICAgdmFyIGxOdW1iZXJPZldvcmRzID0gKGxOdW1iZXJPZldvcmRzX3RlbXAyICsgMSkgKiAxNjtcbiAgICAgICAgdmFyIGxXb3JkQXJyYXkgPSBBcnJheShsTnVtYmVyT2ZXb3JkcyAtIDEpO1xuICAgICAgICB2YXIgbEJ5dGVQb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBsQnl0ZUNvdW50ID0gMDtcbiAgICAgICAgd2hpbGUgKGxCeXRlQ291bnQgPCBsTWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgbFdvcmRDb3VudCA9IChsQnl0ZUNvdW50IC0gKGxCeXRlQ291bnQgJSA0KSkgLyA0O1xuICAgICAgICAgICAgbEJ5dGVQb3NpdGlvbiA9IChsQnl0ZUNvdW50ICUgNCkgKiA4O1xuICAgICAgICAgICAgbFdvcmRBcnJheVtsV29yZENvdW50XSA9XG4gICAgICAgICAgICAgICAgbFdvcmRBcnJheVtsV29yZENvdW50XSB8XG4gICAgICAgICAgICAgICAgKHN0cmluZy5jaGFyQ29kZUF0KGxCeXRlQ291bnQpIDw8IGxCeXRlUG9zaXRpb24pO1xuICAgICAgICAgICAgbEJ5dGVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudCAtIChsQnl0ZUNvdW50ICUgNCkpIC8gNDtcbiAgICAgICAgbEJ5dGVQb3NpdGlvbiA9IChsQnl0ZUNvdW50ICUgNCkgKiA4O1xuICAgICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdID1cbiAgICAgICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfCAoMHg4MCA8PCBsQnl0ZVBvc2l0aW9uKTtcbiAgICAgICAgbFdvcmRBcnJheVtsTnVtYmVyT2ZXb3JkcyAtIDJdID0gbE1lc3NhZ2VMZW5ndGggPDwgMztcbiAgICAgICAgbFdvcmRBcnJheVtsTnVtYmVyT2ZXb3JkcyAtIDFdID0gbE1lc3NhZ2VMZW5ndGggPj4+IDI5O1xuICAgICAgICByZXR1cm4gbFdvcmRBcnJheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXb3JkVG9IZXgobFZhbHVlKSB7XG4gICAgICAgIHZhciBXb3JkVG9IZXhWYWx1ZSA9IFwiXCIsXG4gICAgICAgICAgICBXb3JkVG9IZXhWYWx1ZV90ZW1wID0gXCJcIixcbiAgICAgICAgICAgIGxCeXRlLFxuICAgICAgICAgICAgbENvdW50O1xuICAgICAgICBmb3IgKGxDb3VudCA9IDA7IGxDb3VudCA8PSAzOyBsQ291bnQrKykge1xuICAgICAgICAgICAgbEJ5dGUgPSAobFZhbHVlID4+PiAobENvdW50ICogOCkpICYgMjU1O1xuICAgICAgICAgICAgV29yZFRvSGV4VmFsdWVfdGVtcCA9IFwiMFwiICsgbEJ5dGUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgV29yZFRvSGV4VmFsdWUgPVxuICAgICAgICAgICAgICAgIFdvcmRUb0hleFZhbHVlICtcbiAgICAgICAgICAgICAgICBXb3JkVG9IZXhWYWx1ZV90ZW1wLnN1YnN0cihXb3JkVG9IZXhWYWx1ZV90ZW1wLmxlbmd0aCAtIDIsIDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXb3JkVG9IZXhWYWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVdGY4RW5jb2RlKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpO1xuICAgICAgICB2YXIgdXRmdGV4dCA9IFwiXCI7XG5cbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBzdHJpbmcubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG5cbiAgICAgICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMTI3ICYmIGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjID4+IDYpIHwgMTkyKTtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gMTIpIHwgMjI0KTtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjID4+IDYpICYgNjMpIHwgMTI4KTtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0ZnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIHggPSBBcnJheSgpO1xuICAgIHZhciBrLCBBQSwgQkIsIENDLCBERCwgYSwgYiwgYywgZDtcbiAgICB2YXIgUzExID0gNyxcbiAgICAgICAgUzEyID0gMTIsXG4gICAgICAgIFMxMyA9IDE3LFxuICAgICAgICBTMTQgPSAyMjtcbiAgICB2YXIgUzIxID0gNSxcbiAgICAgICAgUzIyID0gOSxcbiAgICAgICAgUzIzID0gMTQsXG4gICAgICAgIFMyNCA9IDIwO1xuICAgIHZhciBTMzEgPSA0LFxuICAgICAgICBTMzIgPSAxMSxcbiAgICAgICAgUzMzID0gMTYsXG4gICAgICAgIFMzNCA9IDIzO1xuICAgIHZhciBTNDEgPSA2LFxuICAgICAgICBTNDIgPSAxMCxcbiAgICAgICAgUzQzID0gMTUsXG4gICAgICAgIFM0NCA9IDIxO1xuXG4gICAgc3RyaW5nID0gVXRmOEVuY29kZShzdHJpbmcpO1xuXG4gICAgeCA9IENvbnZlcnRUb1dvcmRBcnJheShzdHJpbmcpO1xuXG4gICAgYSA9IDB4Njc0NTIzMDE7XG4gICAgYiA9IDB4ZWZjZGFiODk7XG4gICAgYyA9IDB4OThiYWRjZmU7XG4gICAgZCA9IDB4MTAzMjU0NzY7XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgeC5sZW5ndGg7IGsgKz0gMTYpIHtcbiAgICAgICAgQUEgPSBhO1xuICAgICAgICBCQiA9IGI7XG4gICAgICAgIENDID0gYztcbiAgICAgICAgREQgPSBkO1xuICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgeFtrICsgMF0sIFMxMSwgMHhkNzZhYTQ3OCk7XG4gICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCB4W2sgKyAxXSwgUzEyLCAweGU4YzdiNzU2KTtcbiAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIHhbayArIDJdLCBTMTMsIDB4MjQyMDcwZGIpO1xuICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgeFtrICsgM10sIFMxNCwgMHhjMWJkY2VlZSk7XG4gICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCB4W2sgKyA0XSwgUzExLCAweGY1N2MwZmFmKTtcbiAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIHhbayArIDVdLCBTMTIsIDB4NDc4N2M2MmEpO1xuICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgeFtrICsgNl0sIFMxMywgMHhhODMwNDYxMyk7XG4gICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCB4W2sgKyA3XSwgUzE0LCAweGZkNDY5NTAxKTtcbiAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIHhbayArIDhdLCBTMTEsIDB4Njk4MDk4ZDgpO1xuICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgeFtrICsgOV0sIFMxMiwgMHg4YjQ0ZjdhZik7XG4gICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCB4W2sgKyAxMF0sIFMxMywgMHhmZmZmNWJiMSk7XG4gICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCB4W2sgKyAxMV0sIFMxNCwgMHg4OTVjZDdiZSk7XG4gICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCB4W2sgKyAxMl0sIFMxMSwgMHg2YjkwMTEyMik7XG4gICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCB4W2sgKyAxM10sIFMxMiwgMHhmZDk4NzE5Myk7XG4gICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCB4W2sgKyAxNF0sIFMxMywgMHhhNjc5NDM4ZSk7XG4gICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCB4W2sgKyAxNV0sIFMxNCwgMHg0OWI0MDgyMSk7XG4gICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCB4W2sgKyAxXSwgUzIxLCAweGY2MWUyNTYyKTtcbiAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIHhbayArIDZdLCBTMjIsIDB4YzA0MGIzNDApO1xuICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgeFtrICsgMTFdLCBTMjMsIDB4MjY1ZTVhNTEpO1xuICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgeFtrICsgMF0sIFMyNCwgMHhlOWI2YzdhYSk7XG4gICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCB4W2sgKyA1XSwgUzIxLCAweGQ2MmYxMDVkKTtcbiAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIHhbayArIDEwXSwgUzIyLCAweDI0NDE0NTMpO1xuICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgeFtrICsgMTVdLCBTMjMsIDB4ZDhhMWU2ODEpO1xuICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgeFtrICsgNF0sIFMyNCwgMHhlN2QzZmJjOCk7XG4gICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCB4W2sgKyA5XSwgUzIxLCAweDIxZTFjZGU2KTtcbiAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIHhbayArIDE0XSwgUzIyLCAweGMzMzcwN2Q2KTtcbiAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIHhbayArIDNdLCBTMjMsIDB4ZjRkNTBkODcpO1xuICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgeFtrICsgOF0sIFMyNCwgMHg0NTVhMTRlZCk7XG4gICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCB4W2sgKyAxM10sIFMyMSwgMHhhOWUzZTkwNSk7XG4gICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCB4W2sgKyAyXSwgUzIyLCAweGZjZWZhM2Y4KTtcbiAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIHhbayArIDddLCBTMjMsIDB4Njc2ZjAyZDkpO1xuICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgeFtrICsgMTJdLCBTMjQsIDB4OGQyYTRjOGEpO1xuICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgeFtrICsgNV0sIFMzMSwgMHhmZmZhMzk0Mik7XG4gICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCB4W2sgKyA4XSwgUzMyLCAweDg3NzFmNjgxKTtcbiAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIHhbayArIDExXSwgUzMzLCAweDZkOWQ2MTIyKTtcbiAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIHhbayArIDE0XSwgUzM0LCAweGZkZTUzODBjKTtcbiAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIHhbayArIDFdLCBTMzEsIDB4YTRiZWVhNDQpO1xuICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgeFtrICsgNF0sIFMzMiwgMHg0YmRlY2ZhOSk7XG4gICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCB4W2sgKyA3XSwgUzMzLCAweGY2YmI0YjYwKTtcbiAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIHhbayArIDEwXSwgUzM0LCAweGJlYmZiYzcwKTtcbiAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIHhbayArIDEzXSwgUzMxLCAweDI4OWI3ZWM2KTtcbiAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIHhbayArIDBdLCBTMzIsIDB4ZWFhMTI3ZmEpO1xuICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgeFtrICsgM10sIFMzMywgMHhkNGVmMzA4NSk7XG4gICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCB4W2sgKyA2XSwgUzM0LCAweDQ4ODFkMDUpO1xuICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgeFtrICsgOV0sIFMzMSwgMHhkOWQ0ZDAzOSk7XG4gICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCB4W2sgKyAxMl0sIFMzMiwgMHhlNmRiOTllNSk7XG4gICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCB4W2sgKyAxNV0sIFMzMywgMHgxZmEyN2NmOCk7XG4gICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCB4W2sgKyAyXSwgUzM0LCAweGM0YWM1NjY1KTtcbiAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIHhbayArIDBdLCBTNDEsIDB4ZjQyOTIyNDQpO1xuICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgeFtrICsgN10sIFM0MiwgMHg0MzJhZmY5Nyk7XG4gICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCB4W2sgKyAxNF0sIFM0MywgMHhhYjk0MjNhNyk7XG4gICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCB4W2sgKyA1XSwgUzQ0LCAweGZjOTNhMDM5KTtcbiAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIHhbayArIDEyXSwgUzQxLCAweDY1NWI1OWMzKTtcbiAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIHhbayArIDNdLCBTNDIsIDB4OGYwY2NjOTIpO1xuICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgeFtrICsgMTBdLCBTNDMsIDB4ZmZlZmY0N2QpO1xuICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgeFtrICsgMV0sIFM0NCwgMHg4NTg0NWRkMSk7XG4gICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCB4W2sgKyA4XSwgUzQxLCAweDZmYTg3ZTRmKTtcbiAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIHhbayArIDE1XSwgUzQyLCAweGZlMmNlNmUwKTtcbiAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIHhbayArIDZdLCBTNDMsIDB4YTMwMTQzMTQpO1xuICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgeFtrICsgMTNdLCBTNDQsIDB4NGUwODExYTEpO1xuICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgeFtrICsgNF0sIFM0MSwgMHhmNzUzN2U4Mik7XG4gICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCB4W2sgKyAxMV0sIFM0MiwgMHhiZDNhZjIzNSk7XG4gICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCB4W2sgKyAyXSwgUzQzLCAweDJhZDdkMmJiKTtcbiAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIHhbayArIDldLCBTNDQsIDB4ZWI4NmQzOTEpO1xuICAgICAgICBhID0gQWRkVW5zaWduZWQoYSwgQUEpO1xuICAgICAgICBiID0gQWRkVW5zaWduZWQoYiwgQkIpO1xuICAgICAgICBjID0gQWRkVW5zaWduZWQoYywgQ0MpO1xuICAgICAgICBkID0gQWRkVW5zaWduZWQoZCwgREQpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wID0gV29yZFRvSGV4KGEpICsgV29yZFRvSGV4KGIpICsgV29yZFRvSGV4KGMpICsgV29yZFRvSGV4KGQpO1xuXG4gICAgcmV0dXJuIHRlbXAudG9Mb3dlckNhc2UoKTtcbn1cbiIsIlNrLmJ1aWx0aW5GaWxlcz17XCJmaWxlc1wiOntcInNyYy9idWlsdGluL3RoaXMucHlcIjpcInMgPSBcXFwiXFxcIlxcXCJHdXIgTXJhIGJzIENsZ3ViYSwgb2wgR3Z6IENyZ3JlZlxcblxcbk9ybmhndnNoeSB2ZiBvcmdncmUgZ3VuYSBodHlsLlxcblJrY3l2cHZnIHZmIG9yZ2dyZSBndW5hIHZ6Y3l2cHZnLlxcbkZ2emN5ciB2ZiBvcmdncmUgZ3VuYSBwYnpjeXJrLlxcblBiemN5cmsgdmYgb3JnZ3JlIGd1bmEgcGJ6Y3l2cG5ncnEuXFxuU3luZyB2ZiBvcmdncmUgZ3VuYSBhcmZncnEuXFxuRmNuZWZyIHZmIG9yZ2dyZSBndW5hIHFyYWZyLlxcbkVybnFub3Z5dmdsIHBiaGFnZi5cXG5GY3Jwdm55IHBuZnJmIG5lcmEnZyBmY3Jwdm55IHJhYmh0dSBnYiBvZXJueCBndXIgZWh5cmYuXFxuTnlndWJodHUgY2VucGd2cG55dmdsIG9ybmdmIGNoZXZnbC5cXG5SZWViZWYgZnViaHlxIGFyaXJlIGNuZmYgZnZ5cmFneWwuXFxuSGF5cmZmIHJrY3l2cHZneWwgZnZ5cmFwcnEuXFxuVmEgZ3VyIHNucHIgYnMgbnpvdnRodmdsLCBlcnNoZnIgZ3VyIGdyemNnbmd2YmEgZ2IgdGhyZmYuXFxuR3VyZXIgZnViaHlxIG9yIGJhci0tIG5hcSBjZXJzcmVub3lsIGJheWwgYmFyIC0tYm9pdmJoZiBqbmwgZ2IgcWIgdmcuXFxuTnlndWJodHUgZ3VuZyBqbmwgem5sIGFiZyBvciBib2l2YmhmIG5nIHN2ZWZnIGhheXJmZiBsYmgnZXIgUWhncHUuXFxuQWJqIHZmIG9yZ2dyZSBndW5hIGFyaXJlLlxcbk55Z3ViaHR1IGFyaXJlIHZmIGJzZ3JhIG9yZ2dyZSBndW5hICpldnR1ZyogYWJqLlxcblZzIGd1ciB2emN5cnpyYWduZ3ZiYSB2ZiB1bmVxIGdiIHJrY3ludmEsIHZnJ2YgbiBvbnEgdnFybi5cXG5WcyBndXIgdnpjeXJ6cmFnbmd2YmEgdmYgcm5mbCBnYiBya2N5bnZhLCB2ZyB6bmwgb3IgbiB0YmJxIHZxcm4uXFxuQW56cmZjbnByZiBuZXIgYmFyIHViYXh2YXQgdGVybmcgdnFybiAtLSB5cmcnZiBxYiB6YmVyIGJzIGd1YmZyIVxcXCJcXFwiXFxcIlxcblxcbmQgPSB7fVxcbmZvciBjIGluICg2NSwgOTcpOlxcbiAgICBmb3IgaSBpbiByYW5nZSgyNik6XFxuICAgICAgICBkW2NocihpK2MpXSA9IGNocigoaSsxMykgJSAyNiArIGMpXFxuXFxucHJpbnQoXFxcIlxcXCIuam9pbihbZC5nZXQoYywgYykgZm9yIGMgaW4gc10pKVxcblwiLFwic3JjL2xpYi9CYXNlSFRUUFNlcnZlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJCYXNlSFRUUFNlcnZlclxcXCIpXFxuXCIsXCJzcmMvbGliL0Jhc3Rpb24ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiQmFzdGlvblxcXCIpXFxuXCIsXCJzcmMvbGliL0NHSUhUVFBTZXJ2ZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiQ0dJSFRUUFNlcnZlclxcXCIpXFxuXCIsXCJzcmMvbGliL0NvbmZpZ1BhcnNlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJDb25maWdQYXJzZXJcXFwiKVxcblwiLFwic3JjL2xpYi9Db29raWUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiQ29va2llXFxcIilcXG5cIixcInNyYy9saWIvRG9jWE1MUlBDU2VydmVyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIkRvY1hNTFJQQ1NlcnZlclxcXCIpXFxuXCIsXCJzcmMvbGliL0hUTUxQYXJzZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiSFRNTFBhcnNlclxcXCIpXFxuXCIsXCJzcmMvbGliL01pbWVXcml0ZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiTWltZVdyaXRlclxcXCIpXFxuXCIsXCJzcmMvbGliL1F1ZXVlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIlF1ZXVlXFxcIilcXG5cIixcInNyYy9saWIvU2ltcGxlSFRUUFNlcnZlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJTaW1wbGVIVFRQU2VydmVyXFxcIilcXG5cIixcInNyYy9saWIvU2ltcGxlWE1MUlBDU2VydmVyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIlNpbXBsZVhNTFJQQ1NlcnZlclxcXCIpXFxuXCIsXCJzcmMvbGliL1NvY2tldFNlcnZlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJTb2NrZXRTZXJ2ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9TdHJpbmdJTy5weVwiOlwiclxcXCJcXFwiXFxcIkZpbGUtbGlrZSBvYmplY3RzIHRoYXQgcmVhZCBmcm9tIG9yIHdyaXRlIHRvIGEgc3RyaW5nIGJ1ZmZlci5cXG5cXG5UaGlzIGltcGxlbWVudHMgKG5lYXJseSkgYWxsIHN0ZGlvIG1ldGhvZHMuXFxuXFxuZiA9IFN0cmluZ0lPKCkgICAgICAjIHJlYWR5IGZvciB3cml0aW5nXFxuZiA9IFN0cmluZ0lPKGJ1ZikgICAjIHJlYWR5IGZvciByZWFkaW5nXFxuZi5jbG9zZSgpICAgICAgICAgICAjIGV4cGxpY2l0bHkgcmVsZWFzZSByZXNvdXJjZXMgaGVsZFxcbmZsYWcgPSBmLmlzYXR0eSgpICAgIyBhbHdheXMgZmFsc2VcXG5wb3MgPSBmLnRlbGwoKSAgICAgICMgZ2V0IGN1cnJlbnQgcG9zaXRpb25cXG5mLnNlZWsocG9zKSAgICAgICAgICMgc2V0IGN1cnJlbnQgcG9zaXRpb25cXG5mLnNlZWsocG9zLCBtb2RlKSAgICMgbW9kZSAwOiBhYnNvbHV0ZTsgMTogcmVsYXRpdmU7IDI6IHJlbGF0aXZlIHRvIEVPRlxcbmJ1ZiA9IGYucmVhZCgpICAgICAgIyByZWFkIHVudGlsIEVPRlxcbmJ1ZiA9IGYucmVhZChuKSAgICAgIyByZWFkIHVwIHRvIG4gYnl0ZXNcXG5idWYgPSBmLnJlYWRsaW5lKCkgICMgcmVhZCB1bnRpbCBlbmQgb2YgbGluZSAoJ1xcXFxuJykgb3IgRU9GXFxubGlzdCA9IGYucmVhZGxpbmVzKCkjIGxpc3Qgb2YgZi5yZWFkbGluZSgpIHJlc3VsdHMgdW50aWwgRU9GXFxuZi50cnVuY2F0ZShbc2l6ZV0pICAjIHRydW5jYXRlIGZpbGUgYXQgdG8gYXQgbW9zdCBzaXplIChkZWZhdWx0OiBjdXJyZW50IHBvcylcXG5mLndyaXRlKGJ1ZikgICAgICAgICMgd3JpdGUgYXQgY3VycmVudCBwb3NpdGlvblxcbmYud3JpdGVsaW5lcyhsaXN0KSAgIyBmb3IgbGluZSBpbiBsaXN0OiBmLndyaXRlKGxpbmUpXFxuZi5nZXR2YWx1ZSgpICAgICAgICAjIHJldHVybiB3aG9sZSBmaWxlJ3MgY29udGVudHMgYXMgYSBzdHJpbmdcXG5cXG5Ob3RlczpcXG4tIFVzaW5nIGEgcmVhbCBmaWxlIGlzIG9mdGVuIGZhc3RlciAoYnV0IGxlc3MgY29udmVuaWVudCkuXFxuLSBUaGVyZSdzIGFsc28gYSBtdWNoIGZhc3RlciBpbXBsZW1lbnRhdGlvbiBpbiBDLCBjYWxsZWQgY1N0cmluZ0lPLCBidXRcXG4gIGl0J3Mgbm90IHN1YmNsYXNzYWJsZS5cXG4tIGZpbGVubygpIGlzIGxlZnQgdW5pbXBsZW1lbnRlZCBzbyB0aGF0IGNvZGUgd2hpY2ggdXNlcyBpdCB0cmlnZ2Vyc1xcbiAgYW4gZXhjZXB0aW9uIGVhcmx5Llxcbi0gU2Vla2luZyBmYXIgYmV5b25kIEVPRiBhbmQgdGhlbiB3cml0aW5nIHdpbGwgaW5zZXJ0IHJlYWwgbnVsbFxcbiAgYnl0ZXMgdGhhdCBvY2N1cHkgc3BhY2UgaW4gdGhlIGJ1ZmZlci5cXG4tIFRoZXJlJ3MgYSBzaW1wbGUgdGVzdCBzZXQgKHNlZSBlbmQgb2YgdGhpcyBmaWxlKS5cXG5cXFwiXFxcIlxcXCJcXG5cXG5fX2FsbF9fID0gW1xcXCJTdHJpbmdJT1xcXCJdXFxuXFxuZGVmIF9jb21wbGFpbl9pZmNsb3NlZChjbG9zZWQpOlxcbiAgICBpZiBjbG9zZWQ6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJJL08gb3BlcmF0aW9uIG9uIGNsb3NlZCBmaWxlXFxcIilcXG5cXG5jbGFzcyBTdHJpbmdJTzpcXG4gICAgXFxcIlxcXCJcXFwiY2xhc3MgU3RyaW5nSU8oW2J1ZmZlcl0pXFxuXFxuICAgIFdoZW4gYSBTdHJpbmdJTyBvYmplY3QgaXMgY3JlYXRlZCwgaXQgY2FuIGJlIGluaXRpYWxpemVkIHRvIGFuIGV4aXN0aW5nXFxuICAgIHN0cmluZyBieSBwYXNzaW5nIHRoZSBzdHJpbmcgdG8gdGhlIGNvbnN0cnVjdG9yLiBJZiBubyBzdHJpbmcgaXMgZ2l2ZW4sXFxuICAgIHRoZSBTdHJpbmdJTyB3aWxsIHN0YXJ0IGVtcHR5LlxcblxcbiAgICBUaGUgU3RyaW5nSU8gb2JqZWN0IGNhbiBhY2NlcHQgZWl0aGVyIFVuaWNvZGUgb3IgOC1iaXQgc3RyaW5ncywgYnV0XFxuICAgIG1peGluZyB0aGUgdHdvIG1heSB0YWtlIHNvbWUgY2FyZS4gSWYgYm90aCBhcmUgdXNlZCwgOC1iaXQgc3RyaW5ncyB0aGF0XFxuICAgIGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyA3LWJpdCBBU0NJSSAodGhhdCB1c2UgdGhlIDh0aCBiaXQpIHdpbGwgY2F1c2VcXG4gICAgYSBVbmljb2RlRXJyb3IgdG8gYmUgcmFpc2VkIHdoZW4gZ2V0dmFsdWUoKSBpcyBjYWxsZWQuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgYnVmID0gJycpOlxcbiAgICAgICAgIyBGb3JjZSBzZWxmLmJ1ZiB0byBiZSBhIHN0cmluZyBvciB1bmljb2RlXFxuICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShidWYsIHN0cik6XFxuICAgICAgICAgICAgYnVmID0gc3RyKGJ1ZilcXG4gICAgICAgIHNlbGYuYnVmID0gYnVmXFxuICAgICAgICBzZWxmLmxlbiA9IGxlbihidWYpXFxuICAgICAgICBzZWxmLmJ1Zmxpc3QgPSBbXVxcbiAgICAgICAgc2VsZi5wb3MgPSAwXFxuICAgICAgICBzZWxmLmNsb3NlZCA9IEZhbHNlXFxuICAgICAgICBzZWxmLnNvZnRzcGFjZSA9IDBcXG5cXG4gICAgZGVmIF9faXRlcl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIG5leHQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBIGZpbGUgb2JqZWN0IGlzIGl0cyBvd24gaXRlcmF0b3IsIGZvciBleGFtcGxlIGl0ZXIoZikgcmV0dXJucyBmXFxuICAgICAgICAodW5sZXNzIGYgaXMgY2xvc2VkKS4gV2hlbiBhIGZpbGUgaXMgdXNlZCBhcyBhbiBpdGVyYXRvciwgdHlwaWNhbGx5XFxuICAgICAgICBpbiBhIGZvciBsb29wIChmb3IgZXhhbXBsZSwgZm9yIGxpbmUgaW4gZjogcHJpbnQgbGluZSksIHRoZSBuZXh0KClcXG4gICAgICAgIG1ldGhvZCBpcyBjYWxsZWQgcmVwZWF0ZWRseS4gVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCBpbnB1dCBsaW5lLFxcbiAgICAgICAgb3IgcmFpc2VzIFN0b3BJdGVyYXRpb24gd2hlbiBFT0YgaXMgaGl0LlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICByID0gc2VsZi5yZWFkbGluZSgpXFxuICAgICAgICBpZiBub3QgcjpcXG4gICAgICAgICAgICByYWlzZSBTdG9wSXRlcmF0aW9uXFxuICAgICAgICByZXR1cm4gclxcblxcbiAgICBkZWYgY2xvc2Uoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJGcmVlIHRoZSBtZW1vcnkgYnVmZmVyLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBub3Qgc2VsZi5jbG9zZWQ6XFxuICAgICAgICAgICAgc2VsZi5jbG9zZWQgPSBUcnVlXFxuICAgICAgICAgICAgc2VsZi5idWYgPSBOb25lXFxuICAgICAgICAgICAgc2VsZi5wb3MgPSBOb25lXFxuXFxuICAgIGRlZiBpc2F0dHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm5zIEZhbHNlIGJlY2F1c2UgU3RyaW5nSU8gb2JqZWN0cyBhcmUgbm90IGNvbm5lY3RlZCB0byBhXFxuICAgICAgICB0dHktbGlrZSBkZXZpY2UuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIHJldHVybiBGYWxzZVxcblxcbiAgICBkZWYgc2VlayhzZWxmLCBwb3MsIG1vZGUgPSAwKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCB0aGUgZmlsZSdzIGN1cnJlbnQgcG9zaXRpb24uXFxuXFxuICAgICAgICBUaGUgbW9kZSBhcmd1bWVudCBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMCAoYWJzb2x1dGUgZmlsZVxcbiAgICAgICAgcG9zaXRpb25pbmcpOyBvdGhlciB2YWx1ZXMgYXJlIDEgKHNlZWsgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnRcXG4gICAgICAgIHBvc2l0aW9uKSBhbmQgMiAoc2VlayByZWxhdGl2ZSB0byB0aGUgZmlsZSdzIGVuZCkuXFxuXFxuICAgICAgICBUaGVyZSBpcyBubyByZXR1cm4gdmFsdWUuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIGlmIHNlbGYuYnVmbGlzdDpcXG4gICAgICAgICAgICBzZWxmLmJ1ZiArPSAnJy5qb2luKHNlbGYuYnVmbGlzdClcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QgPSBbXVxcbiAgICAgICAgaWYgbW9kZSA9PSAxOlxcbiAgICAgICAgICAgIHBvcyArPSBzZWxmLnBvc1xcbiAgICAgICAgZWxpZiBtb2RlID09IDI6XFxuICAgICAgICAgICAgcG9zICs9IHNlbGYubGVuXFxuICAgICAgICBzZWxmLnBvcyA9IG1heCgwLCBwb3MpXFxuXFxuICAgIGRlZiB0ZWxsKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBmaWxlJ3MgY3VycmVudCBwb3NpdGlvbi5cXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIHJldHVybiBzZWxmLnBvc1xcblxcbiAgICBkZWYgcmVhZChzZWxmLCBuID0gLTEpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVhZCBhdCBtb3N0IHNpemUgYnl0ZXMgZnJvbSB0aGUgZmlsZVxcbiAgICAgICAgKGxlc3MgaWYgdGhlIHJlYWQgaGl0cyBFT0YgYmVmb3JlIG9idGFpbmluZyBzaXplIGJ5dGVzKS5cXG5cXG4gICAgICAgIElmIHRoZSBzaXplIGFyZ3VtZW50IGlzIG5lZ2F0aXZlIG9yIG9taXR0ZWQsIHJlYWQgYWxsIGRhdGEgdW50aWwgRU9GXFxuICAgICAgICBpcyByZWFjaGVkLiBUaGUgYnl0ZXMgYXJlIHJldHVybmVkIGFzIGEgc3RyaW5nIG9iamVjdC4gQW4gZW1wdHlcXG4gICAgICAgIHN0cmluZyBpcyByZXR1cm5lZCB3aGVuIEVPRiBpcyBlbmNvdW50ZXJlZCBpbW1lZGlhdGVseS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgaWYgc2VsZi5idWZsaXN0OlxcbiAgICAgICAgICAgIHNlbGYuYnVmICs9ICcnLmpvaW4oc2VsZi5idWZsaXN0KVxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdCA9IFtdXFxuICAgICAgICBpZiBuIGlzIE5vbmUgb3IgbiA8IDA6XFxuICAgICAgICAgICAgbmV3cG9zID0gc2VsZi5sZW5cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbmV3cG9zID0gbWluKHNlbGYucG9zK24sIHNlbGYubGVuKVxcbiAgICAgICAgciA9IHNlbGYuYnVmW3NlbGYucG9zOm5ld3Bvc11cXG4gICAgICAgIHNlbGYucG9zID0gbmV3cG9zXFxuICAgICAgICByZXR1cm4gclxcblxcbiAgICBkZWYgcmVhZGxpbmUoc2VsZiwgbGVuZ3RoPU5vbmUpOlxcbiAgICAgICAgclxcXCJcXFwiXFxcIlJlYWQgb25lIGVudGlyZSBsaW5lIGZyb20gdGhlIGZpbGUuXFxuXFxuICAgICAgICBBIHRyYWlsaW5nIG5ld2xpbmUgY2hhcmFjdGVyIGlzIGtlcHQgaW4gdGhlIHN0cmluZyAoYnV0IG1heSBiZSBhYnNlbnRcXG4gICAgICAgIHdoZW4gYSBmaWxlIGVuZHMgd2l0aCBhbiBpbmNvbXBsZXRlIGxpbmUpLiBJZiB0aGUgc2l6ZSBhcmd1bWVudCBpc1xcbiAgICAgICAgcHJlc2VudCBhbmQgbm9uLW5lZ2F0aXZlLCBpdCBpcyBhIG1heGltdW0gYnl0ZSBjb3VudCAoaW5jbHVkaW5nIHRoZVxcbiAgICAgICAgdHJhaWxpbmcgbmV3bGluZSkgYW5kIGFuIGluY29tcGxldGUgbGluZSBtYXkgYmUgcmV0dXJuZWQuXFxuXFxuICAgICAgICBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgb25seSB3aGVuIEVPRiBpcyBlbmNvdW50ZXJlZCBpbW1lZGlhdGVseS5cXG5cXG4gICAgICAgIE5vdGU6IFVubGlrZSBzdGRpbydzIGZnZXRzKCksIHRoZSByZXR1cm5lZCBzdHJpbmcgY29udGFpbnMgbnVsbFxcbiAgICAgICAgY2hhcmFjdGVycyAoJ1xcXFwwJykgaWYgdGhleSBvY2N1cnJlZCBpbiB0aGUgaW5wdXQuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIGlmIHNlbGYuYnVmbGlzdDpcXG4gICAgICAgICAgICBzZWxmLmJ1ZiArPSAnJy5qb2luKHNlbGYuYnVmbGlzdClcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QgPSBbXVxcbiAgICAgICAgaSA9IHNlbGYuYnVmLmZpbmQoJ1xcXFxuJywgc2VsZi5wb3MpXFxuICAgICAgICBpZiBpIDwgMDpcXG4gICAgICAgICAgICBuZXdwb3MgPSBzZWxmLmxlblxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBuZXdwb3MgPSBpKzFcXG4gICAgICAgIGlmIGxlbmd0aCBpcyBub3QgTm9uZSBhbmQgbGVuZ3RoID49IDA6XFxuICAgICAgICAgICAgaWYgc2VsZi5wb3MgKyBsZW5ndGggPCBuZXdwb3M6XFxuICAgICAgICAgICAgICAgIG5ld3BvcyA9IHNlbGYucG9zICsgbGVuZ3RoXFxuICAgICAgICByID0gc2VsZi5idWZbc2VsZi5wb3M6bmV3cG9zXVxcbiAgICAgICAgc2VsZi5wb3MgPSBuZXdwb3NcXG4gICAgICAgIHJldHVybiByXFxuXFxuICAgIGRlZiByZWFkbGluZXMoc2VsZiwgc2l6ZWhpbnQgPSAwKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlYWQgdW50aWwgRU9GIHVzaW5nIHJlYWRsaW5lKCkgYW5kIHJldHVybiBhIGxpc3QgY29udGFpbmluZyB0aGVcXG4gICAgICAgIGxpbmVzIHRodXMgcmVhZC5cXG5cXG4gICAgICAgIElmIHRoZSBvcHRpb25hbCBzaXplaGludCBhcmd1bWVudCBpcyBwcmVzZW50LCBpbnN0ZWFkIG9mIHJlYWRpbmcgdXBcXG4gICAgICAgIHRvIEVPRiwgd2hvbGUgbGluZXMgdG90YWxsaW5nIGFwcHJveGltYXRlbHkgc2l6ZWhpbnQgYnl0ZXMgKG9yIG1vcmVcXG4gICAgICAgIHRvIGFjY29tbW9kYXRlIGEgZmluYWwgd2hvbGUgbGluZSkuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIHRvdGFsID0gMFxcbiAgICAgICAgbGluZXMgPSBbXVxcbiAgICAgICAgbGluZSA9IHNlbGYucmVhZGxpbmUoKVxcbiAgICAgICAgd2hpbGUgbGluZTpcXG4gICAgICAgICAgICBsaW5lcy5hcHBlbmQobGluZSlcXG4gICAgICAgICAgICB0b3RhbCArPSBsZW4obGluZSlcXG4gICAgICAgICAgICBpZiAwIDwgc2l6ZWhpbnQgPD0gdG90YWw6XFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgbGluZSA9IHNlbGYucmVhZGxpbmUoKVxcbiAgICAgICAgcmV0dXJuIGxpbmVzXFxuXFxuICAgIGRlZiB0cnVuY2F0ZShzZWxmLCBzaXplPU5vbmUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVHJ1bmNhdGUgdGhlIGZpbGUncyBzaXplLlxcblxcbiAgICAgICAgSWYgdGhlIG9wdGlvbmFsIHNpemUgYXJndW1lbnQgaXMgcHJlc2VudCwgdGhlIGZpbGUgaXMgdHJ1bmNhdGVkIHRvXFxuICAgICAgICAoYXQgbW9zdCkgdGhhdCBzaXplLiBUaGUgc2l6ZSBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBwb3NpdGlvbi5cXG4gICAgICAgIFRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24gaXMgbm90IGNoYW5nZWQgdW5sZXNzIHRoZSBwb3NpdGlvblxcbiAgICAgICAgaXMgYmV5b25kIHRoZSBuZXcgZmlsZSBzaXplLlxcblxcbiAgICAgICAgSWYgdGhlIHNwZWNpZmllZCBzaXplIGV4Y2VlZHMgdGhlIGZpbGUncyBjdXJyZW50IHNpemUsIHRoZVxcbiAgICAgICAgZmlsZSByZW1haW5zIHVuY2hhbmdlZC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgaWYgc2l6ZSBpcyBOb25lOlxcbiAgICAgICAgICAgIHNpemUgPSBzZWxmLnBvc1xcbiAgICAgICAgZWxpZiBzaXplIDwgMDpcXG4gICAgICAgICAgICByYWlzZSBJT0Vycm9yKDIyLCBcXFwiTmVnYXRpdmUgc2l6ZSBub3QgYWxsb3dlZFxcXCIpXFxuICAgICAgICBlbGlmIHNpemUgPCBzZWxmLnBvczpcXG4gICAgICAgICAgICBzZWxmLnBvcyA9IHNpemVcXG4gICAgICAgIHNlbGYuYnVmID0gc2VsZi5nZXR2YWx1ZSgpWzpzaXplXVxcbiAgICAgICAgc2VsZi5sZW4gPSBzaXplXFxuXFxuICAgIGRlZiB3cml0ZShzZWxmLCBzKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIldyaXRlIGEgc3RyaW5nIHRvIHRoZSBmaWxlLlxcblxcbiAgICAgICAgVGhlcmUgaXMgbm8gcmV0dXJuIHZhbHVlLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICBpZiBub3QgczogcmV0dXJuXFxuICAgICAgICAjIEZvcmNlIHMgdG8gYmUgYSBzdHJpbmcgb3IgdW5pY29kZVxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uocywgc3RyKTpcXG4gICAgICAgICAgICBzID0gc3RyKHMpXFxuICAgICAgICBzcG9zID0gc2VsZi5wb3NcXG4gICAgICAgIHNsZW4gPSBzZWxmLmxlblxcbiAgICAgICAgaWYgc3BvcyA9PSBzbGVuOlxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdC5hcHBlbmQocylcXG4gICAgICAgICAgICBzZWxmLmxlbiA9IHNlbGYucG9zID0gc3BvcyArIGxlbihzKVxcbiAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgaWYgc3BvcyA+IHNsZW46XFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0LmFwcGVuZCgnXFxcXDAnKihzcG9zIC0gc2xlbikpXFxuICAgICAgICAgICAgc2xlbiA9IHNwb3NcXG4gICAgICAgIG5ld3BvcyA9IHNwb3MgKyBsZW4ocylcXG4gICAgICAgIGlmIHNwb3MgPCBzbGVuOlxcbiAgICAgICAgICAgIGlmIHNlbGYuYnVmbGlzdDpcXG4gICAgICAgICAgICAgICAgc2VsZi5idWYgKz0gJycuam9pbihzZWxmLmJ1Zmxpc3QpXFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0ID0gW3NlbGYuYnVmWzpzcG9zXSwgcywgc2VsZi5idWZbbmV3cG9zOl1dXFxuICAgICAgICAgICAgc2VsZi5idWYgPSAnJ1xcbiAgICAgICAgICAgIGlmIG5ld3BvcyA+IHNsZW46XFxuICAgICAgICAgICAgICAgIHNsZW4gPSBuZXdwb3NcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0LmFwcGVuZChzKVxcbiAgICAgICAgICAgIHNsZW4gPSBuZXdwb3NcXG4gICAgICAgIHNlbGYubGVuID0gc2xlblxcbiAgICAgICAgc2VsZi5wb3MgPSBuZXdwb3NcXG5cXG4gICAgZGVmIHdyaXRlbGluZXMoc2VsZiwgaXRlcmFibGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiV3JpdGUgYSBzZXF1ZW5jZSBvZiBzdHJpbmdzIHRvIHRoZSBmaWxlLiBUaGUgc2VxdWVuY2UgY2FuIGJlIGFueVxcbiAgICAgICAgaXRlcmFibGUgb2JqZWN0IHByb2R1Y2luZyBzdHJpbmdzLCB0eXBpY2FsbHkgYSBsaXN0IG9mIHN0cmluZ3MuIFRoZXJlXFxuICAgICAgICBpcyBubyByZXR1cm4gdmFsdWUuXFxuXFxuICAgICAgICAoVGhlIG5hbWUgaXMgaW50ZW5kZWQgdG8gbWF0Y2ggcmVhZGxpbmVzKCk7IHdyaXRlbGluZXMoKSBkb2VzIG5vdCBhZGRcXG4gICAgICAgIGxpbmUgc2VwYXJhdG9ycy4pXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIHdyaXRlID0gc2VsZi53cml0ZVxcbiAgICAgICAgZm9yIGxpbmUgaW4gaXRlcmFibGU6XFxuICAgICAgICAgICAgd3JpdGUobGluZSlcXG5cXG4gICAgZGVmIGZsdXNoKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmx1c2ggdGhlIGludGVybmFsIGJ1ZmZlclxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuXFxuICAgIGRlZiBnZXR2YWx1ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgUmV0cmlldmUgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgXFxcImZpbGVcXFwiIGF0IGFueSB0aW1lIGJlZm9yZVxcbiAgICAgICAgdGhlIFN0cmluZ0lPIG9iamVjdCdzIGNsb3NlKCkgbWV0aG9kIGlzIGNhbGxlZC5cXG5cXG4gICAgICAgIFRoZSBTdHJpbmdJTyBvYmplY3QgY2FuIGFjY2VwdCBlaXRoZXIgVW5pY29kZSBvciA4LWJpdCBzdHJpbmdzLFxcbiAgICAgICAgYnV0IG1peGluZyB0aGUgdHdvIG1heSB0YWtlIHNvbWUgY2FyZS4gSWYgYm90aCBhcmUgdXNlZCwgOC1iaXRcXG4gICAgICAgIHN0cmluZ3MgdGhhdCBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQgYXMgNy1iaXQgQVNDSUkgKHRoYXQgdXNlIHRoZVxcbiAgICAgICAgOHRoIGJpdCkgd2lsbCBjYXVzZSBhIFVuaWNvZGVFcnJvciB0byBiZSByYWlzZWQgd2hlbiBnZXR2YWx1ZSgpXFxuICAgICAgICBpcyBjYWxsZWQuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIGlmIHNlbGYuYnVmbGlzdDpcXG4gICAgICAgICAgICBzZWxmLmJ1ZiArPSAnJy5qb2luKHNlbGYuYnVmbGlzdClcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QgPSBbXVxcbiAgICAgICAgcmV0dXJuIHNlbGYuYnVmXFxuXCIsXCJzcmMvbGliL1VzZXJEaWN0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIlVzZXJEaWN0XFxcIilcXG5cIixcInNyYy9saWIvVXNlckxpc3QucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiVXNlckxpc3RcXFwiKVxcblwiLFwic3JjL2xpYi9Vc2VyU3RyaW5nLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIlVzZXJTdHJpbmdcXFwiKVxcblwiLFwic3JjL2xpYi9fTFdQQ29va2llSmFyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIl9MV1BDb29raWVKYXJcXFwiKVxcblwiLFwic3JjL2xpYi9fTW96aWxsYUNvb2tpZUphci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJfTW96aWxsYUNvb2tpZUphclxcXCIpXFxuXCIsXCJzcmMvbGliL19fZnV0dXJlX18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDtfc2tfZmFpbC5fKFxcXCJfX2Z1dHVyZV9fXFxcIilcXG5cIixcInNyYy9saWIvX19waGVsbG9fXy5mb28ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiX19waGVsbG9fXy5mb29cXFwiKVxcblwiLFwic3JjL2xpYi9fYWJjb2xsLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIl9hYmNvbGxcXFwiKVxcblwiLFwic3JjL2xpYi9fc2tfZmFpbC5weVwiOlwiY2xhc3MgTm90SW1wbGVtZW50ZWRJbXBvcnRFcnJvcihJbXBvcnRFcnJvciwgTm90SW1wbGVtZW50ZWRFcnJvcik6IHBhc3NcXG5cXG5kZWYgXyhuYW1lKTpcXG4gICAgbXNnID0gXFxcInt9IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIi5mb3JtYXQobmFtZSlcXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRJbXBvcnRFcnJvcihtc2csIG5hbWU9bmFtZSlcXG5cIixcInNyYy9saWIvX3RocmVhZGluZ19sb2NhbC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJfdGhyZWFkaW5nX2xvY2FsXFxcIilcXG5cIixcInNyYy9saWIvYWJjLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImFiY1xcXCIpXFxuXCIsXCJzcmMvbGliL2FpZmMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiYWlmY1xcXCIpXFxuXCIsXCJzcmMvbGliL2FsdGFpci9fX2luaXRfXy5weVwiOlwiaW1wb3J0IHJhbmRvbVxcblxcbnRyeTpcXG4gICAgZnJvbSB2ZWdhX2NhbGxlciBpbXBvcnQgcmVuZGVyX2dyYXBoXFxuZXhjZXB0OlxcbiAgICBwcmludChcXFwiTW9jayByZW5kZXJcXFwiKVxcblxcbiAgICBkZWYgcmVuZGVyX2dyYXBoKGpzKTpcXG4gICAgICAgIHByaW50KGpzKVxcblxcblxcbmNsYXNzIENoYXJ0OlxcbiAgICAjIFRPRE8gYWxsb3cgZGF0YSB0byBiZSBzcGVjaWZpZWQgYXMgYSBVUkwgdG8gYSBDU1Ygb3IgREIgb3IganNvblxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgZGF0YSwgdGl0bGU9Tm9uZSk6XFxuICAgICAgICBzZWxmLnRpdGxlID0gdGl0bGVcXG4gICAgICAgIHNlbGYuZGF0YV9pZCA9IHJhbmRvbS5yYW5kcmFuZ2UoMTAwMDAwMCwgNTAwMDAwMClcXG4gICAgICAgIHNlbGYuZHNuYW1lID0gXFxcImRhdGEte31cXFwiLmZvcm1hdChzZWxmLmRhdGFfaWQpXFxuICAgICAgICBpZiBpc2luc3RhbmNlKGRhdGEsIGRpY3QpOlxcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IERhdGEoKipkYXRhKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSBkYXRhXFxuXFxuICAgICAgICBzZWxmLmpzb24gPSB7fVxcbiAgICAgICAgc2VsZi5qc29uW1xcXCIkc2NoZW1hXFxcIl0gPSBcXFwiaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby9zY2hlbWEvdmVnYS1saXRlL3YyLjUuanNvblxcXCJcXG4gICAgICAgIHNlbGYuanNvbltcXFwiZGF0YVxcXCJdID0ge31cXG4gICAgICAgIGlmIHNlbGYudGl0bGU6XFxuICAgICAgICAgICAgc2VsZi5qc29uW1xcXCJ0aXRsZVxcXCJdID0gc2VsZi50aXRsZVxcblxcbiAgICAgICAgc2VsZi5qc29uW1xcXCJkYXRhXFxcIl0gPSB7XFxcInZhbHVlc1xcXCI6IHNlbGYuZGF0YS52YWxzfVxcbiAgICAgICAgc2VsZi5pc19jb21wb3NpdGUgPSBGYWxzZVxcblxcbiAgICAjIG1hcmsgY2FuIGJlIGEgc2ltcGxlIHN0cmluZyBvciBhIGRpY3Rpb25hcnlcXG4gICAgIyBcXFwibWFya1xcXCI6IHtcXFwiY29sb3JcXFwiOiBcXFwiZ3JlZW5cXFwiLCBcXFwib3BhY2l0eVxcXCI6IDAuMiwgXFxcInR5cGVcXFwiOiBcXFwicmVjdFxcXCJ9XFxuXFxuICAgIGRlZiBtYXJrX2pzb24oc2VsZiwgbWFya190eXBlLCAqKmt3YXJncyk6XFxuICAgICAgICBpZiBrd2FyZ3M6XFxuICAgICAgICAgICAgc2VsZi5qc29uW1xcXCJtYXJrXFxcIl0gPSB7fVxcbiAgICAgICAgICAgIHNlbGYuanNvbltcXFwibWFya1xcXCJdW1xcXCJ0eXBlXFxcIl0gPSBtYXJrX3R5cGVcXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcIm1hcmtcXFwiXS51cGRhdGUoa3dhcmdzKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcIm1hcmtcXFwiXSA9IG1hcmtfdHlwZVxcblxcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIG1hcmtfYmFyKHNlbGYsICoqa3dhcmdzKTpcXG4gICAgICAgIHJldHVybiBzZWxmLm1hcmtfanNvbihcXFwiYmFyXFxcIiwgKiprd2FyZ3MpXFxuXFxuICAgIGRlZiBtYXJrX3BvaW50KHNlbGYsICoqa3dhcmdzKTpcXG4gICAgICAgIHJldHVybiBzZWxmLm1hcmtfanNvbihcXFwicG9pbnRcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfbGluZShzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcImxpbmVcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfcmVjdChzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcInJlY3RcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfYXJlYShzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcImFyZWFcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfdGljayhzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcInRpY2tcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIGVuY29kZShzZWxmLCB4PVxcXCJcXFwiLCB5PVxcXCJcXFwiLCBjb2xvcj1cXFwiXFxcIiwgc2l6ZT1cXFwiXFxcIiwgdG9vbHRpcD1cXFwiXFxcIik6XFxuICAgICAgICBzZWxmLmVuY29kaW5nID0ge31cXG4gICAgICAgIGlmIHg6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZSh4LCBBeGlzKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwieFxcXCJdID0geC50b0pzb24oKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHNlbGYuZW5jb2RpbmdbXFxcInhcXFwiXSA9IEF4aXMoeCkudG9Kc29uKClcXG4gICAgICAgIGlmIHk6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZSh5LCBBeGlzKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwieVxcXCJdID0geS50b0pzb24oKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHNlbGYuZW5jb2RpbmdbXFxcInlcXFwiXSA9IEF4aXMoeSkudG9Kc29uKClcXG5cXG4gICAgICAgICMgXFxcImNvbG9yXFxcIjoge1xcXCJ0eXBlXFxcIjogXFxcIm5vbWluYWxcXFwiLCBcXFwiZmllbGRcXFwiOiBcXFwic3BlY2llc1xcXCJ9XFxuICAgICAgICBpZiBjb2xvcjpcXG4gICAgICAgICAgICBmaWVsZCwgdHAgPSBfZ2V0X25hbWVfdHlwZShjb2xvcilcXG4gICAgICAgICAgICBzZWxmLmVuY29kaW5nW1xcXCJjb2xvclxcXCJdID0gZGljdCh0eXBlPXRwLCBmaWVsZD1maWVsZClcXG5cXG4gICAgICAgICMgXFxcInNpemVcXFwiOiB7XFxcInR5cGVcXFwiOiBcXFwicXVhbnRpdGF0aXZlXFxcIiwgXFxcImZpZWxkXFxcIjogXFxcIkFjY2VsZXJhdGlvblxcXCJ9XFxuICAgICAgICBpZiBzaXplOlxcbiAgICAgICAgICAgIGZpZWxkLCB0cCA9IF9nZXRfbmFtZV90eXBlKHNpemUpXFxuICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwic2l6ZVxcXCJdID0gZGljdCh0eXBlPXRwLCBmaWVsZD1maWVsZClcXG5cXG4gICAgICAgIGlmIHRvb2x0aXA6XFxuICAgICAgICAgICAgZmllbGQsIHRwID0gX2dldF9uYW1lX3R5cGUodG9vbHRpcClcXG4gICAgICAgICAgICBzZWxmLmVuY29kaW5nW1xcXCJ0b29sdGlwXFxcIl0gPSBkaWN0KHR5cGU9dHAsIGZpZWxkPWZpZWxkKVxcblxcbiAgICAgICAgc2VsZi5qc29uW1xcXCJlbmNvZGluZ1xcXCJdID0gc2VsZi5lbmNvZGluZ1xcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIGludGVyYWN0aXZlKHNlbGYpOlxcbiAgICAgICAgaWNvbmZpZyA9IHtcXG4gICAgICAgICAgICBcXFwic2VsZWN0b3IwMDJcXFwiOiB7XFxuICAgICAgICAgICAgICAgIFxcXCJ0eXBlXFxcIjogXFxcImludGVydmFsXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcImJpbmRcXFwiOiBcXFwic2NhbGVzXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcImVuY29kaW5nc1xcXCI6IFtcXFwieFxcXCIsIFxcXCJ5XFxcIl0sXFxuICAgICAgICAgICAgICAgIFxcXCJvblxcXCI6IFxcXCJbbW91c2Vkb3duLCB3aW5kb3c6bW91c2V1cF0gPiB3aW5kb3c6bW91c2Vtb3ZlIVxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJ0cmFuc2xhdGVcXFwiOiBcXFwiW21vdXNlZG93biwgd2luZG93Om1vdXNldXBdID4gd2luZG93Om1vdXNlbW92ZSFcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiem9vbVxcXCI6IFxcXCJ3aGVlbCFcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwibWFya1xcXCI6IHtcXFwiZmlsbFxcXCI6IFxcXCIjMzMzXFxcIiwgXFxcImZpbGxPcGFjaXR5XFxcIjogMC4xMjUsIFxcXCJzdHJva2VcXFwiOiBcXFwid2hpdGVcXFwifSxcXG4gICAgICAgICAgICAgICAgXFxcInJlc29sdmVcXFwiOiBcXFwiZ2xvYmFsXFxcIixcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZWxmLmpzb25bXFxcInNlbGVjdGlvblxcXCJdID0gaWNvbmZpZ1xcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIGRpc3BsYXkoc2VsZik6XFxuICAgICAgICByZW5kZXJfZ3JhcGgoc2VsZi5qc29uKVxcblxcbiAgICBkZWYgX19hZGRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICByZXR1cm4gc2VsZi5hZGRfbGF5ZXIob3RoZXIsIFxcXCJsYXllclxcXCIpXFxuXFxuICAgIGRlZiBfX2FuZF9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmFkZF9sYXllcihvdGhlciwgXFxcInZjb25jYXRcXFwiKVxcblxcbiAgICBkZWYgX19vcl9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmFkZF9sYXllcihvdGhlciwgXFxcImhjb25jYXRcXFwiKVxcblxcbiAgICBkZWYgYWRkX2xheWVyKHNlbGYsIG90aGVyLCBsbmFtZSk6XFxuICAgICAgICAjIG11bHRsZSBsYXllcnMgYXJlIGFkZGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIG5ldyBlbGVtZW50IHRvIHRoZVxcbiAgICAgICAgIyBleGlzdGluZyBsYXllci4gIElmIHRoZSBsYXllciBkb2VzIG5vdCBleGlzdCB0aGVuIGluaXRpYWxpemVcXG4gICAgICAgICMgaXQgZnJvbSBzZWxmLlxcbiAgICAgICAgaWYgbG5hbWUgbm90IGluIHNlbGYuanNvbjpcXG4gICAgICAgICAgICBzZWxmLmpzb25bbG5hbWVdID0gW11cXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcImRhdGFzZXRzXFxcIl0gPSB7fVxcbiAgICAgICAgICAgIHRlbXAgPSB7fVxcbiAgICAgICAgICAgIHRlbXBbXFxcImRhdGFcXFwiXSA9IHtcXFwibmFtZVxcXCI6IHNlbGYuZHNuYW1lfVxcbiAgICAgICAgICAgIHNlbGYuanNvbltcXFwiZGF0YXNldHNcXFwiXVtzZWxmLmRzbmFtZV0gPSBzZWxmLmpzb25bXFxcImRhdGFcXFwiXVtcXFwidmFsdWVzXFxcIl1cXG4gICAgICAgICAgICBkZWwgc2VsZi5qc29uW1xcXCJkYXRhXFxcIl1cXG4gICAgICAgICAgICB0ZW1wW1xcXCJlbmNvZGluZ1xcXCJdID0gc2VsZi5qc29uW1xcXCJlbmNvZGluZ1xcXCJdXFxuICAgICAgICAgICAgZGVsIHNlbGYuanNvbltcXFwiZW5jb2RpbmdcXFwiXVxcbiAgICAgICAgICAgIHRlbXBbXFxcIm1hcmtcXFwiXSA9IHNlbGYuanNvbltcXFwibWFya1xcXCJdXFxuICAgICAgICAgICAgZGVsIHNlbGYuanNvbltcXFwibWFya1xcXCJdXFxuICAgICAgICAgICAgc2VsZi5qc29uW2xuYW1lXS5hcHBlbmQodGVtcClcXG4gICAgICAgIHRlbXAgPSB7fVxcbiAgICAgICAgc2VsZi5qc29uW1xcXCJkYXRhc2V0c1xcXCJdW290aGVyLmRzbmFtZV0gPSBvdGhlci5qc29uW1xcXCJkYXRhXFxcIl1bXFxcInZhbHVlc1xcXCJdXFxuICAgICAgICB0ZW1wW1xcXCJkYXRhXFxcIl0gPSB7XFxcIm5hbWVcXFwiOiBvdGhlci5kc25hbWV9XFxuICAgICAgICB0ZW1wW1xcXCJlbmNvZGluZ1xcXCJdID0gb3RoZXIuanNvbltcXFwiZW5jb2RpbmdcXFwiXVxcbiAgICAgICAgdGVtcFtcXFwibWFya1xcXCJdID0gb3RoZXIuanNvbltcXFwibWFya1xcXCJdXFxuICAgICAgICBzZWxmLmpzb25bbG5hbWVdLmFwcGVuZCh0ZW1wKVxcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG5cXG4jICAgXFxcImRhdGFzZXRzXFxcIjoge1xcbiMgICAgIFxcXCJkYXRhLWU1NmU0MzM1NGQ5YjhmMmFiMGQxZTkwY2YyN2NkNDdmXFxcIjogW1xcbiMgICAgICAge1xcXCJhXFxcIjogNCwgXFxcImJcXFwiOiAxLCBcXFwiY1xcXCI6IFxcXCJyXFxcIn0sXFxuIyAgICAgICB7XFxcImFcXFwiOiA1LCBcXFwiYlxcXCI6IDIsIFxcXCJjXFxcIjogXFxcImdcXFwifSxcXG4jICAgICAgIHtcXFwiYVxcXCI6IDYsIFxcXCJiXFxcIjogMywgXFxcImNcXFwiOiBcXFwiYlxcXCJ9XFxuIyAgICAgXSxcXG4jICAgICBcXFwiZGF0YS1hNGMzMDQ3YTE1YmY5MzgwYzJlNjE1Y2Y4NzY0ODM2OVxcXCI6IFtcXG4jICAgICAgIHtcXFwiYVxcXCI6IDEsIFxcXCJiXFxcIjogNCwgXFxcImNcXFwiOiBcXFwiclxcXCJ9LFxcbiMgICAgICAge1xcXCJhXFxcIjogMiwgXFxcImJcXFwiOiA1LCBcXFwiY1xcXCI6IFxcXCJnXFxcIn0sXFxuIyAgICAgICB7XFxcImFcXFwiOiAzLCBcXFwiYlxcXCI6IDYsIFxcXCJjXFxcIjogXFxcImJcXFwifVxcbiMgICAgIF1cXG4jICAgfVxcblxcbiMgVE9ETzogIGFkZCBhIHJlY3QgbWFyayB0eXBlIGZvciBhIGhlYXQgbWFwXFxuXFxuXFxuZGVmIF9nZXRfbmFtZV90eXBlKG5hbWUpOlxcbiAgICB0eXBlZCA9IHtcXFwiUVxcXCI6IFxcXCJxdWFudGl0YXRpdmVcXFwiLCBcXFwiT1xcXCI6IFxcXCJvcmRpbmFsXFxcIiwgXFxcIk5cXFwiOiBcXFwibm9taW5hbFxcXCIsIFxcXCJUXFxcIjogXFxcInRlbXBvcmFsXFxcIn1cXG4gICAgbnQgPSBuYW1lLnNwbGl0KFxcXCI6XFxcIilcXG4gICAgdHN0cmluZyA9IFxcXCJxdWFudGl0YXRpdmVcXFwiXFxuICAgIGlmIGxlbihudCkgPT0gMjpcXG4gICAgICAgIHRzdHJpbmcgPSB0eXBlZFtudFsxXV1cXG4gICAgcmV0dXJuIG50WzBdLCB0c3RyaW5nXFxuXFxuXFxuY2xhc3MgQXhpczpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5hbWUsIGJpbj1GYWxzZSk6XFxuICAgICAgICBzZWxmLmFnZ3JlZ2F0ZSA9IE5vbmVcXG4gICAgICAgIHNlbGYubmFtZSwgc2VsZi50eXBlID0gX2dldF9uYW1lX3R5cGUobmFtZSlcXG4gICAgICAgIGlmIFxcXCIoKVxcXCIgaW4gc2VsZi5uYW1lOiAgIyBhZ2dyZWdhdGUgZnVuY3Rpb25cXG4gICAgICAgICAgICBzZWxmLmFnZ3JlZ2F0ZSA9IHNlbGYubmFtZS5yZXBsYWNlKFxcXCIoKVxcXCIsIFxcXCJcXFwiKVxcbiAgICAgICAgICAgIHNlbGYubmFtZSA9IE5vbmVcXG4gICAgICAgIHNlbGYuYmluID0gYmluXFxuXFxuICAgIGRlZiB0b0pzb24oc2VsZik6XFxuICAgICAgICBqc29uID0ge31cXG4gICAgICAgIGlmIHNlbGYubmFtZTpcXG4gICAgICAgICAgICBqc29uW1xcXCJmaWVsZFxcXCJdID0gc2VsZi5uYW1lXFxuICAgICAgICBpZiBzZWxmLnR5cGU6XFxuICAgICAgICAgICAganNvbltcXFwidHlwZVxcXCJdID0gc2VsZi50eXBlXFxuICAgICAgICBpZiBzZWxmLmJpbjpcXG4gICAgICAgICAgICBqc29uW1xcXCJiaW5cXFwiXSA9IFRydWVcXG4gICAgICAgIGlmIHNlbGYuYWdncmVnYXRlOlxcbiAgICAgICAgICAgIGpzb25bXFxcImFnZ3JlZ2F0ZVxcXCJdID0gc2VsZi5hZ2dyZWdhdGVcXG5cXG4gICAgICAgIHJldHVybiBqc29uXFxuXFxuXFxuY2xhc3MgWChBeGlzKTpcXG4gICAgcGFzc1xcblxcblxcbmNsYXNzIFkoQXhpcyk6XFxuICAgIHBhc3NcXG5cXG5cXG5jbGFzcyBEYXRhOlxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgKiprd2FyZ3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpbnB1dCBjYW4gYmUgdGhlIGZvcm0gb2YgYSBzZXJpZXMgb2Yga2V5d29yZCBhcmdzIHdoZXJlXFxuICAgICAgICB0aGUga2V5d29yZCBpcyB0aGUgY29sdW1uIG5hbWUsIG9yIGEgc2luZ2xlIGtleXdvcmQgZGF0YVxcbiAgICAgICAgdGhhdCBpcyBhIGxpc3Qgb2YganNvbiBzdHlsZSByZWNvcmRzIGFzIHJvd3MuXFxuICAgICAgICBjb3VsZCBhbHNvIGFjY2VwdCBhIGNzdiBmaWxlPyBvciBrZXl3b3JkcyBjb2x1bW5zIGFuZCByb3dzXFxuICAgICAgICBUaGlzIGFjY2VwdHMgYSBsb3QgbW9yZSBvcHRpb25zIHRoYXQgXFxcInJlYWwgYWx0YWlyXFxcIiB0byBtYWtlIGl0IGVhc2llclxcbiAgICAgICAgdG8gd29yayB3aXRoIG5vbi1EYXRhRnJhbWUgZGF0YSBzZXRzLiAgSW50ZXJuYWxseTpcXG4gICAgICAgIHNlbGYua2V5cyBjb250YWlucyB0aGUgbGlzdCBvZiBjb2x1bW4gbmFtZXNcXG4gICAgICAgIHNlbGYudmFscyBpcyBhIGxpc3Qgb2YgZGljdGlvbmFyaWVzIG9mIHRoZSBmb3JtIFt7Y29sMTp2YWwxLCBjb2wyOnZhbDIsIC4uLiBjb2xuOnZhbG59LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2wxOnZhbDMsIGNvbDI6dmFsNCwgLi4uIGNvbG46dmFsbn0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbDE6dmFsNSwgY29sMjp2YWw2LCAuLi4gY29sbjp2YWxufV1cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgIyB0b2RvOiBhY2NlcHQgYSBVUkwgYXMgdGhlIGFyZ3VtZW50IHRvIHJlYWQgYSBDU1Ygb3IgSlNPTiBmaWxlXFxuICAgICAgICBpZiBsZW4oa3dhcmdzKSA9PSAxIGFuZCBcXFwiZGF0YVxcXCIgaW4ga3dhcmdzOlxcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IGt3YXJnc1tcXFwiZGF0YVxcXCJdXFxuICAgICAgICAgICAgc2VsZi5rZXlzID0gc2VsZi5kYXRhWzBdLmtleXMoKVxcbiAgICAgICAgICAgIHNlbGYudmFscyA9IHNlbGYuZGF0YVxcbiAgICAgICAgZWxpZiBsZW4oa3dhcmdzKSA9PSAyIGFuZCAoXFxcImNvbHVtbnNcXFwiIGluIGt3YXJncykgYW5kIChcXFwicm93c1xcXCIgaW4ga3dhcmdzKTpcXG4gICAgICAgICAgICBzZWxmLmtleXMgPSBrd2FyZ3NbXFxcImNvbHVtbnNcXFwiXVxcbiAgICAgICAgICAgIHNlbGYudmFscyA9IFtdXFxuICAgICAgICAgICAgZm9yIHIgaW4ga3dhcmdzW1xcXCJyb3dzXFxcIl06XFxuICAgICAgICAgICAgICAgIHNlbGYudmFscy5hcHBlbmQoZGljdCh6aXAoc2VsZi5rZXlzLCByKSkpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGtleXMgPSBrd2FyZ3Mua2V5cygpXFxuICAgICAgICAgICAgdmFscyA9IFtdXFxuICAgICAgICAgICAgcHJpbWFyeV9rZXkgPSBsaXN0KGtleXMpWzBdXFxuICAgICAgICAgICAgZm9yIGl4IGluIHJhbmdlKGxlbihrd2FyZ3NbcHJpbWFyeV9rZXldKSk6XFxuICAgICAgICAgICAgICAgIGQgPSB7fVxcbiAgICAgICAgICAgICAgICBmb3Iga2V5IGluIGtleXM6XFxuICAgICAgICAgICAgICAgICAgICBkW2tleV0gPSBrd2FyZ3Nba2V5XVtpeF1cXG4gICAgICAgICAgICAgICAgdmFscy5hcHBlbmQoZClcXG4gICAgICAgICAgICBzZWxmLnZhbHMgPSB2YWxzXFxuICAgICAgICAgICAgc2VsZi5rZXlzID0ga2V5c1xcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgICMgaGVhZGVyID0gXFxcIlxcXFx0XFxcIi5qb2luKHNlbGYua2V5cykgKyBcXFwiXFxcXG5cXFwiXFxuICAgICAgICBoZWFkZXIgPSBcXFwiXFxcIlxcbiAgICAgICAgZm9yIGtleSBpbiBzZWxmLmtleXM6XFxuICAgICAgICAgICAgaGVhZGVyICs9IGtleS5jZW50ZXIoMTApICsgXFxcIiBcXFwiXFxuICAgICAgICBoZWFkZXIgKz0gXFxcIlxcXFxuXFxcIlxcbiAgICAgICAgdGVtcGxhdGUgPSBcXFwiXFxcIlxcbiAgICAgICAgZm9yIGtleSBpbiBzZWxmLmtleXM6XFxuICAgICAgICAgICAgdGVtcGxhdGUgKz0gXFxcIntcXFwiICsga2V5ICsgXFxcIjogPDEwfSBcXFwiXFxuICAgICAgICB0ZW1wbGF0ZSArPSBcXFwiXFxcXG5cXFwiXFxuICAgICAgICByZXMgPSBcXFwiXFxcIlxcbiAgICAgICAgZm9yIHJvdyBpbiBzZWxmLnZhbHM6XFxuICAgICAgICAgICAgcmVzICs9IHRlbXBsYXRlLmZvcm1hdCgqKnJvdylcXG5cXG4gICAgICAgIHJldHVybiBoZWFkZXIgKyByZXNcXG5cXG5cXG5pZiBfX25hbWVfXyA9PSBcXFwiX19tYWluX19cXFwiOlxcbiAgICBkID0gRGF0YShhPVszLCA0LCA1XSwgYj1bMSwgMiwgM10sIGM9W1xcXCJyXFxcIiwgXFxcImdcXFwiLCBcXFwiYlxcXCJdKVxcbiAgICBwcmludChkKVxcbiAgICBwcmludChcXG4gICAgICAgIHR5cGUoXFxuICAgICAgICAgICAgQ2hhcnQoe1xcXCJhXFxcIjogbGlzdChcXFwiYWJjXFxcIiksIFxcXCJiXFxcIjogWzEsIDIsIDNdfSkubWFya19iYXIoKS5lbmNvZGUoeD1cXFwiYTpOXFxcIiwgeT1cXFwiYlxcXCIpXFxuICAgICAgICApXFxuICAgIClcXG4gICAgYWEgPSAoXFxuICAgICAgICBDaGFydChEYXRhKGE9WzMsIDQsIDVdLCBiPVsxLCAyLCAzXSwgYz1bXFxcInJcXFwiLCBcXFwiZ1xcXCIsIFxcXCJiXFxcIl0pKVxcbiAgICAgICAgLm1hcmtfcG9pbnQoY29sb3I9XFxcInJlZFxcXCIpXFxuICAgICAgICAuZW5jb2RlKHg9XFxcImJcXFwiLCB5PVxcXCJhXFxcIiwgY29sb3I9XFxcImM6T1xcXCIpXFxuICAgIClcXG4gICAgcHJpbnQoXFxcImFhID0gXFxcIiwgYWEpXFxuICAgIGFhLmRpc3BsYXkoKVxcblxcbiAgICBiYiA9IChcXG4gICAgICAgIENoYXJ0KERhdGEoYT1bMSwgMiwgM10sIGI9WzQsIDUsIDZdLCBjPVtcXFwiclxcXCIsIFxcXCJnXFxcIiwgXFxcImJcXFwiXSkpXFxuICAgICAgICAubWFya19saW5lKClcXG4gICAgICAgIC5lbmNvZGUoeD1cXFwiYlxcXCIsIHk9XFxcImFcXFwiLCBjb2xvcj1cXFwiYzpPXFxcIilcXG4gICAgKVxcbiAgICBwcmludChcXFwiYmIgPSBcXFwiLCBiYilcXG4gICAgYmIuZGlzcGxheSgpXFxuICAgIHByaW50KFxcXCJhYStiYlxcXCIsIChhYSArIGJiKS5kaXNwbGF5KCkpXFxuICAgICMgQ2hhcnQoRGF0YShhPVsxLDIsMywyLDIsNCw1LDUsNiw3LDgsOCw4LDgsOCw5LDAsMF0pKS5tYXJrX2JhcigpLmVuY29kZShBeGlzKCdhOlEnLCBiaW49VHJ1ZSkseT0nY291bnQoKScpXFxuXFxuXFxuIyB0b2RvOiBzZWUgaWYgSSBjYW4gd29yayB3aXRoIHRoZSByZXByIG9mIGFuIG9iamVjdCB0byBnZXQgdGhlIGJlaGF2aW9yIHRoYXQgYWx0YWlyIGdldHMgaW4gbm90ZWJvb2tzXFxuIyB0b2RvOiBpbXBsZW1lbnQgYSBCaW4gb2JqZWN0IHRvIHNwZWNpZml5IG1heGJpbnNcXG5cIixcInNyYy9saWIvYW50aWdyYXZpdHkucHlcIjpcImltcG9ydCB3ZWJicm93c2VyXFxuXFxud2ViYnJvd3Nlci5vcGVuKFxcXCJodHRwczovL3hrY2QuY29tLzM1My9cXFwiKVxcblwiLFwic3JjL2xpYi9hbnlkYm0ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiYW55ZGJtXFxcIilcXG5cIixcInNyYy9saWIvYXN0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImFzdFxcXCIpXFxuXCIsXCJzcmMvbGliL2FzeW5jaGF0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImFzeW5jaGF0XFxcIilcXG5cIixcInNyYy9saWIvYXN5bmNvcmUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiYXN5bmNvcmVcXFwiKVxcblwiLFwic3JjL2xpYi9hdGV4aXQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiYXRleGl0XFxcIilcXG5cIixcInNyYy9saWIvYXVkaW9kZXYucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiYXVkaW9kZXZcXFwiKVxcblwiLFwic3JjL2xpYi9iYXNlNjQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiYmFzZTY0XFxcIilcXG5cIixcInNyYy9saWIvYmRiLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImJkYlxcXCIpXFxuXCIsXCJzcmMvbGliL2JpbmhleC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJiaW5oZXhcXFwiKVxcblwiLFwic3JjL2xpYi9iaXNlY3QucHlcIjpcIlxcXCJcXFwiXFxcIkJpc2VjdGlvbiBhbGdvcml0aG1zLlxcXCJcXFwiXFxcIlxcblxcbmRlZiBpbnNvcnRfcmlnaHQoYSwgeCwgbG89MCwgaGk9Tm9uZSk6XFxuICAgIFxcXCJcXFwiXFxcIkluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXFxuXFxuICAgIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cXG5cXG4gICAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgbGVuKGEpKSBib3VuZCB0aGVcXG4gICAgc2xpY2Ugb2YgYSB0byBiZSBzZWFyY2hlZC5cXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGlmIGxvIDwgMDpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJylcXG4gICAgaWYgaGkgaXMgTm9uZTpcXG4gICAgICAgIGhpID0gbGVuKGEpXFxuICAgIHdoaWxlIGxvIDwgaGk6XFxuICAgICAgICBtaWQgPSAobG8raGkpLy8yXFxuICAgICAgICBpZiB4IDwgYVttaWRdOiBoaSA9IG1pZFxcbiAgICAgICAgZWxzZTogbG8gPSBtaWQrMVxcbiAgICBhLmluc2VydChsbywgeClcXG5cXG5kZWYgYmlzZWN0X3JpZ2h0KGEsIHgsIGxvPTAsIGhpPU5vbmUpOlxcbiAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIGluZGV4IHdoZXJlIHRvIGluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cXG5cXG4gICAgVGhlIHJldHVybiB2YWx1ZSBpIGlzIHN1Y2ggdGhhdCBhbGwgZSBpbiBhWzppXSBoYXZlIGUgPD0geCwgYW5kIGFsbCBlIGluXFxuICAgIGFbaTpdIGhhdmUgZSA+IHguICBTbyBpZiB4IGFscmVhZHkgYXBwZWFycyBpbiB0aGUgbGlzdCwgYS5pbnNlcnQoeCkgd2lsbFxcbiAgICBpbnNlcnQganVzdCBhZnRlciB0aGUgcmlnaHRtb3N0IHggYWxyZWFkeSB0aGVyZS5cXG5cXG4gICAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgbGVuKGEpKSBib3VuZCB0aGVcXG4gICAgc2xpY2Ugb2YgYSB0byBiZSBzZWFyY2hlZC5cXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGlmIGxvIDwgMDpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJylcXG4gICAgaWYgaGkgaXMgTm9uZTpcXG4gICAgICAgIGhpID0gbGVuKGEpXFxuICAgIHdoaWxlIGxvIDwgaGk6XFxuICAgICAgICBtaWQgPSAobG8raGkpLy8yXFxuICAgICAgICBpZiB4IDwgYVttaWRdOiBoaSA9IG1pZFxcbiAgICAgICAgZWxzZTogbG8gPSBtaWQrMVxcbiAgICByZXR1cm4gbG9cXG5cXG5kZWYgaW5zb3J0X2xlZnQoYSwgeCwgbG89MCwgaGk9Tm9uZSk6XFxuICAgIFxcXCJcXFwiXFxcIkluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXFxuXFxuICAgIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIGxlZnQgb2YgdGhlIGxlZnRtb3N0IHguXFxuXFxuICAgIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGxlbihhKSkgYm91bmQgdGhlXFxuICAgIHNsaWNlIG9mIGEgdG8gYmUgc2VhcmNoZWQuXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICBpZiBsbyA8IDA6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpXFxuICAgIGlmIGhpIGlzIE5vbmU6XFxuICAgICAgICBoaSA9IGxlbihhKVxcbiAgICB3aGlsZSBsbyA8IGhpOlxcbiAgICAgICAgbWlkID0gKGxvK2hpKS8vMlxcbiAgICAgICAgaWYgYVttaWRdIDwgeDogbG8gPSBtaWQrMVxcbiAgICAgICAgZWxzZTogaGkgPSBtaWRcXG4gICAgYS5pbnNlcnQobG8sIHgpXFxuXFxuXFxuZGVmIGJpc2VjdF9sZWZ0KGEsIHgsIGxvPTAsIGhpPU5vbmUpOlxcbiAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIGluZGV4IHdoZXJlIHRvIGluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cXG5cXG4gICAgVGhlIHJldHVybiB2YWx1ZSBpIGlzIHN1Y2ggdGhhdCBhbGwgZSBpbiBhWzppXSBoYXZlIGUgPCB4LCBhbmQgYWxsIGUgaW5cXG4gICAgYVtpOl0gaGF2ZSBlID49IHguICBTbyBpZiB4IGFscmVhZHkgYXBwZWFycyBpbiB0aGUgbGlzdCwgYS5pbnNlcnQoeCkgd2lsbFxcbiAgICBpbnNlcnQganVzdCBiZWZvcmUgdGhlIGxlZnRtb3N0IHggYWxyZWFkeSB0aGVyZS5cXG5cXG4gICAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgbGVuKGEpKSBib3VuZCB0aGVcXG4gICAgc2xpY2Ugb2YgYSB0byBiZSBzZWFyY2hlZC5cXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGlmIGxvIDwgMDpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJylcXG4gICAgaWYgaGkgaXMgTm9uZTpcXG4gICAgICAgIGhpID0gbGVuKGEpXFxuICAgIHdoaWxlIGxvIDwgaGk6XFxuICAgICAgICBtaWQgPSAobG8raGkpLy8yXFxuICAgICAgICBpZiBhW21pZF0gPCB4OiBsbyA9IG1pZCsxXFxuICAgICAgICBlbHNlOiBoaSA9IG1pZFxcbiAgICByZXR1cm4gbG9cXG5cXG4jIE92ZXJ3cml0ZSBhYm92ZSBkZWZpbml0aW9ucyB3aXRoIGEgZmFzdCBDIGltcGxlbWVudGF0aW9uXFxudHJ5OlxcbiAgICBmcm9tIF9iaXNlY3QgaW1wb3J0ICpcXG5leGNlcHQgSW1wb3J0RXJyb3I6XFxuICAgIHBhc3NcXG5cXG4jIENyZWF0ZSBhbGlhc2VzXFxuYmlzZWN0ID0gYmlzZWN0X3JpZ2h0XFxuaW5zb3J0ID0gaW5zb3J0X3JpZ2h0XFxuXCIsXCJzcmMvbGliL2JzZGRiL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImJzZGRiXFxcIilcXG5cIixcInNyYy9saWIvY1Byb2ZpbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY1Byb2ZpbGVcXFwiKVxcblwiLFwic3JjL2xpYi9jZ2kucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY2dpXFxcIilcXG5cIixcInNyYy9saWIvY2dpdGIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY2dpdGJcXFwiKVxcblwiLFwic3JjL2xpYi9jaHVuay5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjaHVua1xcXCIpXFxuXCIsXCJzcmMvbGliL2NtZC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjbWRcXFwiKVxcblwiLFwic3JjL2xpYi9jb2RlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvZGVcXFwiKVxcblwiLFwic3JjL2xpYi9jb2RlY3MucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY29kZWNzXFxcIilcXG5cIixcInNyYy9saWIvY29kZW9wLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvZGVvcFxcXCIpXFxuXCIsXCJzcmMvbGliL2NvbG9yc3lzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvbG9yc3lzXFxcIilcXG5cIixcInNyYy9saWIvY29tbWFuZHMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY29tbWFuZHNcXFwiKVxcblwiLFwic3JjL2xpYi9jb21waWxlYWxsLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvbXBpbGVhbGxcXFwiKVxcblwiLFwic3JjL2xpYi9jb21waWxlci9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb21waWxlclxcXCIpXFxuXCIsXCJzcmMvbGliL2NvbmZpZy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb25maWdcXFwiKVxcblwiLFwic3JjL2xpYi9jb250ZXh0bGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImNvbnRleHRsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9jb29raWVsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY29va2llbGliXFxcIilcXG5cIixcInNyYy9saWIvY29weS5weVwiOlwiXFxcIlxcXCJcXFwiXFxuVGhpcyBmaWxlIHdhcyBtb2RpZmllZCBmcm9tIENQeXRob24uXFxuQ29weXJpZ2h0IChjKSAyMDAxLCAyMDAyLCAyMDAzLCAyMDA0LCAyMDA1LCAyMDA2LCAyMDA3LCAyMDA4LCAyMDA5LCAyMDEwLFxcbjIwMTEsIDIwMTIsIDIwMTMsIDIwMTQsIDIwMTUgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb247IEFsbCBSaWdodHMgUmVzZXJ2ZWRcXG5cXFwiXFxcIlxcXCJcXG5pbXBvcnQgdHlwZXNcXG5jbGFzcyBFcnJvcihFeGNlcHRpb24pOlxcbiAgICBwYXNzXFxuZXJyb3IgPSBFcnJvciBcXG5jbGFzcyBfRW1wdHlDbGFzczpcXG4gICAgcGFzc1xcbnRyeTpcXG4gICAgbG9uZ1xcbmV4Y2VwdCBOYW1lRXJyb3I6XFxuICAgIGxvbmcgPSBpbnRcXG50cnk6XFxuICAgIGJ5dGVzXFxuZXhjZXB0IE5hbWVFcnJvcjpcXG4gICAgYnl0ZXMgPSBzdHJcXG5cXG5kZWYgY2hlY2tfbm90aW1wbGVtZW50ZWRfc3RhdGUoeCk6XFxuICAgIGdldHN0YXRlID0gZ2V0YXR0cih4LCBcXFwiX19nZXRzdGF0ZV9fXFxcIiwgTm9uZSlcXG4gICAgc2V0c3RhdGUgPSBnZXRhdHRyKHgsIFxcXCJfX3NldHN0YXRlX19cXFwiLCBOb25lKVxcbiAgICBpbml0YXJncyA9IGdldGF0dHIoeCwgXFxcIl9fZ2V0aW5pdGFyZ3NfX1xcXCIsIE5vbmUpXFxuICAgIGlmIGdldHN0YXRlIG9yIHNldHN0YXRlIG9yIGluaXRhcmdzOlxcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiU2t1bHB0IGRvZXMgbm90IHlldCBzdXBwb3J0IGNvcHlpbmcgd2l0aCB1c2VyLWRlZmluZWQgX19nZXRzdGF0ZV9fLCBfX3NldHN0YXRlX18gb3IgX19nZXRpbml0YXJnc19fKClcXFwiKVxcblxcblxcbmRlZiBjb3B5KHgpOlxcbiAgICBjbHMgPSB0eXBlKHgpXFxuICAgIGlmIGNhbGxhYmxlKHgpOlxcbiAgICAgICAgcmV0dXJuIHhcXG4gICAgY29waWVyID0gZ2V0YXR0cihjbHMsIFxcXCJfX2NvcHlfX1xcXCIsIE5vbmUpXFxuICAgIGlmIGNvcGllcjpcXG4gICAgICAgIHJldHVybiBjb3BpZXIoeClcXG4gICAgaWYgY2xzIGluICh0eXBlKE5vbmUpLCBpbnQsIGZsb2F0LCBib29sLCBzdHIsIGJ5dGVzLCB0dXBsZSwgdHlwZSwgZnJvemVuc2V0LCBsb25nKTpcXG4gICAgICAgIHJldHVybiB4XFxuICAgIGlmIChjbHMgPT0gbGlzdCkgb3IgKGNscyA9PSBkaWN0KSBvciAoY2xzID09IHNldCkgb3IgKGNscyA9PSBzbGljZSk6XFxuICAgICAgICByZXR1cm4gY2xzKHgpXFxuICAgIHJlZHVjdG9yID0gZ2V0YXR0cih4LCBcXFwiX19yZWR1Y2VfZXhfX1xcXCIsIE5vbmUpXFxuICAgIGlmIHJlZHVjdG9yOlxcbiAgICAgICAgcnYgPSByZWR1Y3Rvcig0KVxcbiAgICBlbHNlOlxcbiAgICAgICAgcmVkdWN0b3IgPSBnZXRhdHRyKHgsIFxcXCJfX3JlZHVjZV9fXFxcIiwgTm9uZSlcXG4gICAgICAgIGlmIHJlZHVjdG9yOlxcbiAgICAgICAgICAgIHJ2ID0gcmVkdWN0b3IoKVxcbiAgICAgICAgZWxpZiBzdHIoY2xzKVsxOjZdID09IFxcXCJjbGFzc1xcXCI6XFxuICAgICAgICAgICAgY2hlY2tfbm90aW1wbGVtZW50ZWRfc3RhdGUoeClcXG4gICAgICAgICAgICBjb3BpZXIgPSBfY29weV9pbnN0XFxuICAgICAgICAgICAgcmV0dXJuIGNvcGllcih4KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBFcnJvcihcXFwidW4oc2hhbGxvdyljb3B5YWJsZSBvYmplY3Qgb2YgdHlwZSAlc1xcXCIgJSBjbHMpXFxuICAgIGlmIGlzaW5zdGFuY2UocnYsIHN0cik6XFxuICAgICAgICByZXR1cm4geFxcbiAgICByZXR1cm4gX3JlY29uc3RydWN0KHgsIHJ2LCAwKVxcblxcbmRlZiBfY29weV9pbnN0KHgpOlxcbiAgICBpZiBoYXNhdHRyKHgsICdfX2NvcHlfXycpOlxcbiAgICAgICAgcmV0dXJuIHguX19jb3B5X18oKVxcbiAgICBpZiBoYXNhdHRyKHgsICdfX2dldGluaXRhcmdzX18nKTpcXG4gICAgICAgIGFyZ3MgPSB4Ll9fZ2V0aW5pdGFyZ3NfXygpXFxuICAgICAgICB5ID0geC5fX2NsYXNzX18oKmFyZ3MpXFxuICAgIGVsc2U6XFxuICAgICAgICB5ID0gX0VtcHR5Q2xhc3MoKVxcbiAgICAgICAgeS5fX2NsYXNzX18gPSB4Ll9fY2xhc3NfX1xcbiAgICBpZiBoYXNhdHRyKHgsICdfX2dldHN0YXRlX18nKTpcXG4gICAgICAgIHN0YXRlID0geC5fX2dldHN0YXRlX18oKVxcbiAgICBlbHNlOlxcbiAgICAgICAgc3RhdGUgPSB4Ll9fZGljdF9fXFxuICAgIGlmIGhhc2F0dHIoeSwgJ19fc2V0c3RhdGVfXycpOlxcbiAgICAgICAgeS5fX3NldHN0YXRlX18oc3RhdGUpXFxuICAgIGVsc2U6XFxuICAgICAgICB5Ll9fZGljdF9fLnVwZGF0ZShzdGF0ZSlcXG4gICAgcmV0dXJuIHlcXG5cXG5kID0gX2RlZXBjb3B5X2Rpc3BhdGNoID0ge31cXG5cXG5kZWYgZGVlcGNvcHkoeCwgbWVtbz1Ob25lLCBfbmlsPVtdKTpcXG4gICAgXFxcIlxcXCJcXFwiRGVlcCBjb3B5IG9wZXJhdGlvbiBvbiBhcmJpdHJhcnkgUHl0aG9uIG9iamVjdHMuXFxuICAgIFNlZSB0aGUgbW9kdWxlJ3MgX19kb2NfXyBzdHJpbmcgZm9yIG1vcmUgaW5mby5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIGlmIG1lbW8gaXMgTm9uZTpcXG4gICAgICAgIG1lbW8gPSB7fVxcbiAgICBpZHggPSBpZCh4KVxcbiAgICB5ID0gbWVtby5nZXQoaWR4LCBfbmlsKVxcbiAgICBpZiB5IGlzIG5vdCBfbmlsOlxcbiAgICAgICAgcmV0dXJuIHlcXG4gICAgY2xzID0gdHlwZSh4KVxcbiAgICBjb3BpZXIgPSBfZGVlcGNvcHlfZGlzcGF0Y2guZ2V0KGNscylcXG4gICAgaWYgY29waWVyOlxcbiAgICAgICAgeSA9IGNvcGllcih4LCBtZW1vKVxcbiAgICBlbHNlOlxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGlzc2MgPSBpc3N1YmNsYXNzKGNscywgdHlwZSlcXG4gICAgICAgIGV4Y2VwdCBUeXBlRXJyb3I6ICMgY2xzIGlzIG5vdCBhIGNsYXNzIChvbGQgQm9vc3Q7IHNlZSBTRiAjNTAyMDg1KVxcbiAgICAgICAgICAgIGlzc2MgPSAwXFxuICAgICAgICBpZiBpc3NjOlxcbiAgICAgICAgICAgIHkgPSBfZGVlcGNvcHlfYXRvbWljKHgsIG1lbW8pXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGNvcGllciA9IGdldGF0dHIoeCwgXFxcIl9fZGVlcGNvcHlfX1xcXCIsIE5vbmUpXFxuICAgICAgICAgICAgaWYgY29waWVyOlxcbiAgICAgICAgICAgICAgICB5ID0gY29waWVyKG1lbW8pXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmVkdWN0b3IgPSBnZXRhdHRyKHgsIFxcXCJfX3JlZHVjZV9leF9fXFxcIiwgTm9uZSlcXG4gICAgICAgICAgICAgICAgaWYgcmVkdWN0b3I6XFxuICAgICAgICAgICAgICAgICAgICBydiA9IHJlZHVjdG9yKDIpXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBydiA9IE5vbmVcXG4gICAgICAgICAgICAgICAgICAgIHJlZHVjdG9yID0gZ2V0YXR0cih4LCBcXFwiX19yZWR1Y2VfX1xcXCIsIE5vbmUpXFxuICAgICAgICAgICAgICAgICAgICBpZiByZWR1Y3RvcjpcXG4gICAgICAgICAgICAgICAgICAgICAgICBydiA9IHJlZHVjdG9yKClcXG4gICAgICAgICAgICAgICAgICAgIGVsaWYgc3RyKGNscylbMTo2XSA9PSBcXFwiY2xhc3NcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX25vdGltcGxlbWVudGVkX3N0YXRlKHgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29waWVyID0gX2RlZXBjb3B5X2Rpc3BhdGNoW1xcXCJJbnN0YW5jZVR5cGVcXFwiXVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjb3BpZXIoeCwgbWVtbylcXG4gICAgICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UgRXJyb3IoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ1bihkZWVwKWNvcHlhYmxlIG9iamVjdCBvZiB0eXBlICVzXFxcIiAlIGNscylcXG4gICAgICAgICAgICAgICAgaWYgcnYgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgICAgICAgICB5ID0gX3JlY29uc3RydWN0KHgsIHJ2LCAxLCBtZW1vKVxcbiAgICBtZW1vW2lkeF0gPSB5XFxuICAgIF9rZWVwX2FsaXZlKHgsIG1lbW8pICMgTWFrZSBzdXJlIHggbGl2ZXMgYXQgbGVhc3QgYXMgbG9uZyBhcyBkXFxuICAgIHJldHVybiB5XFxuXFxuZGVmIF9kZWVwY29weV9hdG9taWMoeCwgbWVtbyk6XFxuICAgIHJldHVybiB4XFxuZFt0eXBlKE5vbmUpXSA9IF9kZWVwY29weV9hdG9taWNcXG4jIGRbdHlwZShFbGxpcHNpcyldID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbdHlwZShOb3RJbXBsZW1lbnRlZCldID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbaW50XSA9IF9kZWVwY29weV9hdG9taWNcXG5kW2Zsb2F0XSA9IF9kZWVwY29weV9hdG9taWNcXG5kW2Jvb2xdID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbY29tcGxleF0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFtieXRlc10gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFtzdHJdID0gX2RlZXBjb3B5X2F0b21pY1xcbiMgdHJ5OlxcbiMgZFt0eXBlcy5Db2RlVHlwZV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuIyBleGNlcHQgQXR0cmlidXRlRXJyb3I6XFxuIyAgIHBhc3NcXG5kW3R5cGVdID0gX2RlZXBjb3B5X2F0b21pY1xcbiMgZFt0eXBlcy5CdWlsdGluRnVuY3Rpb25UeXBlXSA9IF9kZWVwY29weV9hdG9taWNcXG5kW3R5cGVzLkZ1bmN0aW9uVHlwZV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuIyBkW3dlYWtyZWYucmVmXSA9IF9kZWVwY29weV9hdG9taWNcXG5cXG5kZWYgX2RlZXBjb3B5X2xpc3QoeCwgbWVtbyk6XFxuICAgIHkgPSBbXVxcbiAgICBtZW1vW2lkKHgpXSA9IHlcXG4gICAgZm9yIGEgaW4geDpcXG4gICAgICAgIHkuYXBwZW5kKGRlZXBjb3B5KGEsIG1lbW8pKVxcbiAgICByZXR1cm4geVxcbmRbbGlzdF0gPSBfZGVlcGNvcHlfbGlzdFxcblxcbmRlZiBfZGVlcGNvcHlfc2V0KHgsIG1lbW8pOlxcbiAgICByZXN1bHQgPSBzZXQoW10pICAjIG1ha2UgZW1wdHkgc2V0XFxuICAgIG1lbW9baWQoeCldID0gcmVzdWx0ICAjIHJlZ2lzdGVyIHRoaXMgc2V0IGluIHRoZSBtZW1vIGZvciBsb29wIGNoZWNraW5nXFxuICAgIGZvciBhIGluIHg6ICAgIyBnbyB0aHJvdWdoIGVsZW1lbnRzIG9mIHNldFxcbiAgICAgICAgcmVzdWx0LmFkZChkZWVwY29weShhLCBtZW1vKSkgICMgYWRkIHRoZSBjb3BpZWQgZWxlbWVudHMgaW50byB0aGUgbmV3IHNldFxcbiAgICByZXR1cm4gcmVzdWx0ICMgcmV0dXJuIHRoZSBuZXcgc2V0XFxuZFtzZXRdID0gX2RlZXBjb3B5X3NldFxcblxcbmRlZiBfZGVlcGNvcHlfZnJvemVuc2V0KHgsIG1lbW8pOlxcbiAgICByZXN1bHQgPSBmcm96ZW5zZXQoX2RlZXBjb3B5X3NldCh4LG1lbW8pKSBcXG4gICAgbWVtb1tpZCh4KV0gPSByZXN1bHQgXFxuICAgIHJldHVybiByZXN1bHRcXG5kW2Zyb3plbnNldF0gPSBfZGVlcGNvcHlfZnJvemVuc2V0XFxuXFxuZGVmIF9kZWVwY29weV90dXBsZSh4LCBtZW1vKTpcXG4gICAgeSA9IFtkZWVwY29weShhLCBtZW1vKSBmb3IgYSBpbiB4XVxcbiAgICAjIFdlJ3JlIG5vdCBnb2luZyB0byBwdXQgdGhlIHR1cGxlIGluIHRoZSBtZW1vLCBidXQgaXQncyBzdGlsbCBpbXBvcnRhbnQgd2VcXG4gICAgIyBjaGVjayBmb3IgaXQsIGluIGNhc2UgdGhlIHR1cGxlIGNvbnRhaW5zIHJlY3Vyc2l2ZSBtdXRhYmxlIHN0cnVjdHVyZXMuXFxuICAgIHRyeTpcXG4gICAgICAgIHJldHVybiBtZW1vW2lkKHgpXVxcbiAgICBleGNlcHQgS2V5RXJyb3I6XFxuICAgICAgICBwYXNzXFxuICAgIGZvciBrLCBqIGluIHppcCh4LCB5KTpcXG4gICAgICAgIGlmIGsgaXMgbm90IGo6XFxuICAgICAgICAgICAgeSA9IHR1cGxlKHkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgZWxzZTpcXG4gICAgICAgIHkgPSB4XFxuICAgIHJldHVybiB5XFxuZFt0dXBsZV0gPSBfZGVlcGNvcHlfdHVwbGVcXG5cXG5kZWYgX2RlZXBjb3B5X2RpY3QoeCwgbWVtbyk6XFxuICAgIHkgPSB7fVxcbiAgICBtZW1vW2lkKHgpXSA9IHlcXG4gICAgZm9yIGtleSwgdmFsdWUgaW4geC5pdGVtcygpOlxcbiAgICAgICAgeVtkZWVwY29weShrZXksIG1lbW8pXSA9IGRlZXBjb3B5KHZhbHVlLCBtZW1vKVxcbiAgICByZXR1cm4geVxcbmRbZGljdF0gPSBfZGVlcGNvcHlfZGljdFxcblxcbiMgZGVmIF9kZWVwY29weV9tZXRob2QoeCwgbWVtbyk6ICMgQ29weSBpbnN0YW5jZSBtZXRob2RzXFxuIyAgICAgeSA9IHR5cGUoeCkoeC5pbV9mdW5jLCBkZWVwY29weSh4LmltX3NlbGYsIG1lbW8pLCB4LmltX2NsYXNzKTtcXG4jICAgICByZXR1cm4geVxcbmRbdHlwZXMuTWV0aG9kVHlwZV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuXFxuZGVmIF9kZWVwY29weV9pbnN0KHgsIG1lbW8pOlxcbiAgICBpZiBoYXNhdHRyKHgsICdfX2RlZXBjb3B5X18nKTpcXG4gICAgICAgICByZXR1cm4geC5fX2RlZXBjb3B5X18obWVtbylcXG4gICAgaWYgaGFzYXR0cih4LCAnX19nZXRpbml0YXJnc19fJyk6XFxuICAgICAgICBhcmdzID0geC5fX2dldGluaXRhcmdzX18oKVxcbiAgICAgICAgYXJncyA9IGRlZXBjb3B5KGFyZ3MsIG1lbW8pXFxuICAgICAgICB5ID0geC5fX2NsYXNzX18oKmFyZ3MpXFxuICAgIGVsc2U6XFxuICAgICAgICB5ID0gX0VtcHR5Q2xhc3MoKVxcbiAgICAgICAgeS5fX2NsYXNzX18gPSB4Ll9fY2xhc3NfX1xcbiAgICBtZW1vW2lkKHgpXSA9IHlcXG4gICAgaWYgaGFzYXR0cih4LCAnX19nZXRzdGF0ZV9fJyk6XFxuICAgICAgICBzdGF0ZSA9IHguX19nZXRzdGF0ZV9fKClcXG4gICAgZWxzZTpcXG4gICAgICAgIHN0YXRlID0geC5fX2RpY3RfX1xcbiAgICBzdGF0ZSA9IGRlZXBjb3B5KHN0YXRlLCBtZW1vKVxcbiAgICBpZiBoYXNhdHRyKHksICdfX3NldHN0YXRlX18nKTpcXG4gICAgICAgIHkuX19zZXRzdGF0ZV9fKHN0YXRlKVxcbiAgICBlbHNlOlxcbiAgICAgICAgeS5fX2RpY3RfXy51cGRhdGUoc3RhdGUpXFxuICAgICAgICByZXR1cm4geVxcbmRbXFxcIkluc3RhbmNlVHlwZVxcXCJdID0gX2RlZXBjb3B5X2luc3RcXG5cXG5kZWYgX2tlZXBfYWxpdmUoeCwgbWVtbyk6XFxuICAgIFxcXCJcXFwiXFxcIktlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3QgeCBpbiB0aGUgbWVtby5cXG4gICAgQmVjYXVzZSB3ZSByZW1lbWJlciBvYmplY3RzIGJ5IHRoZWlyIGlkLCB3ZSBoYXZlXFxuICAgIHRvIGFzc3VyZSB0aGF0IHBvc3NpYmx5IHRlbXBvcmFyeSBvYmplY3RzIGFyZSBrZXB0XFxuICAgIGFsaXZlIGJ5IHJlZmVyZW5jaW5nIHRoZW0uXFxuICAgIFdlIHN0b3JlIGEgcmVmZXJlbmNlIGF0IHRoZSBpZCBvZiB0aGUgbWVtbywgd2hpY2ggc2hvdWxkXFxuICAgIG5vcm1hbGx5IG5vdCBiZSB1c2VkIHVubGVzcyBzb21lb25lIHRyaWVzIHRvIGRlZXBjb3B5XFxuICAgIHRoZSBtZW1vIGl0c2VsZi4uLlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgdHJ5OlxcbiAgICAgICAgbWVtb1tpZChtZW1vKV0uYXBwZW5kKHgpXFxuICAgIGV4Y2VwdCBLZXlFcnJvcjpcXG4gICAgICAgICMgYWhhLCB0aGlzIGlzIHRoZSBmaXJzdCBvbmUgOi0pXFxuICAgICAgICBtZW1vW2lkKG1lbW8pXT1beF1cXG5cXG5kZWYgX3JlY29uc3RydWN0KHgsIGluZm8sIGRlZXAsIG1lbW89Tm9uZSk6XFxuICAgIGlmIGlzaW5zdGFuY2UoaW5mbywgc3RyKTpcXG4gICAgICAgIHJldHVybiB4XFxuICAgIGFzc2VydCBpc2luc3RhbmNlKGluZm8sIHR1cGxlKVxcbiAgICBpZiBtZW1vIGlzIE5vbmU6XFxuICAgICAgICBtZW1vID0ge31cXG4gICAgbiA9IGxlbihpbmZvKVxcbiAgICBhc3NlcnQgbiBpbiAoMiwgMywgNCwgNSlcXG4gICAgY2FsbGFibGUsIGFyZ3MgPSBpbmZvWzoyXVxcbiAgICBpZiBuID4gMjpcXG4gICAgICAgIHN0YXRlID0gaW5mb1syXVxcbiAgICBlbHNlOlxcbiAgICAgICAgc3RhdGUgPSBOb25lXFxuICAgIGlmIG4gPiAzOlxcbiAgICAgICAgbGlzdGl0ZXIgPSBpbmZvWzNdXFxuICAgIGVsc2U6XFxuICAgICAgICBsaXN0aXRlciA9IE5vbmVcXG4gICAgaWYgbiA+IDQ6XFxuICAgICAgICBkaWN0aXRlciA9IGluZm9bNF1cXG4gICAgZWxzZTpcXG4gICAgICAgIGRpY3RpdGVyID0gTm9uZVxcbiAgICBpZiBkZWVwOlxcbiAgICAgICAgYXJncyA9IGRlZXBjb3B5KGFyZ3MsIG1lbW8pXFxuICAgIHkgPSBjYWxsYWJsZSgqYXJncylcXG4gICAgbWVtb1tpZCh4KV0gPSB5XFxuXFxuICAgIGlmIHN0YXRlIGlzIG5vdCBOb25lOlxcbiAgICAgICAgaWYgZGVlcDpcXG4gICAgICAgICAgICBzdGF0ZSA9IGRlZXBjb3B5KHN0YXRlLCBtZW1vKVxcbiAgICAgICAgaWYgaGFzYXR0cih5LCAnX19zZXRzdGF0ZV9fJyk6XFxuICAgICAgICAgICAgeS5fX3NldHN0YXRlX18oc3RhdGUpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uoc3RhdGUsIHR1cGxlKSBhbmQgbGVuKHN0YXRlKSA9PSAyOlxcbiAgICAgICAgICAgICAgICBzdGF0ZSwgc2xvdHN0YXRlID0gc3RhdGVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzbG90c3RhdGUgPSBOb25lXFxuICAgICAgICAgICAgaWYgc3RhdGUgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgICAgIHkuX19kaWN0X18udXBkYXRlKHN0YXRlKVxcbiAgICAgICAgICAgIGlmIHNsb3RzdGF0ZSBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICAgICAgZm9yIGtleSwgdmFsdWUgaW4gc2xvdHN0YXRlLml0ZW1zKCk6XFxuICAgICAgICAgICAgICAgICAgICBzZXRhdHRyKHksIGtleSwgdmFsdWUpXFxuXFxuICAgIGlmIGxpc3RpdGVyIGlzIG5vdCBOb25lOlxcbiAgICAgICAgZm9yIGl0ZW0gaW4gbGlzdGl0ZXI6XFxuICAgICAgICAgICAgaWYgZGVlcDpcXG4gICAgICAgICAgICAgICAgaXRlbSA9IGRlZXBjb3B5KGl0ZW0sIG1lbW8pXFxuICAgICAgICAgICAgeS5hcHBlbmQoaXRlbSlcXG4gICAgaWYgZGljdGl0ZXIgaXMgbm90IE5vbmU6XFxuICAgICAgICBmb3Iga2V5LCB2YWx1ZSBpbiBkaWN0aXRlcjpcXG4gICAgICAgICAgICBpZiBkZWVwOlxcbiAgICAgICAgICAgICAgICBrZXkgPSBkZWVwY29weShrZXksIG1lbW8pXFxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVlcGNvcHkodmFsdWUsIG1lbW8pXFxuICAgICAgICAgICAgeVtrZXldID0gdmFsdWVcXG4gICAgcmV0dXJuIHlcXG5cXG5kZWwgZFxcblxcbmRlbCB0eXBlc1xcblxcbiMgSGVscGVyIGZvciBpbnN0YW5jZSBjcmVhdGlvbiB3aXRob3V0IGNhbGxpbmcgX19pbml0X19cXG5jbGFzcyBfRW1wdHlDbGFzczpcXG4gICAgcGFzc1wiLFwic3JjL2xpYi9jb3B5X3JlZy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjb3B5X3JlZ1xcXCIpXFxuXCIsXCJzcmMvbGliL2Nzdi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJjc3ZcXFwiKVxcblwiLFwic3JjL2xpYi9jdHlwZXMvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY3R5cGVzXFxcIilcXG5cIixcInNyYy9saWIvY3R5cGVzL21hY2hvbGliL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1hY2hvbGliXFxcIilcXG5cIixcInNyYy9saWIvY3Vyc2VzL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImN1cnNlc1xcXCIpXFxuXCIsXCJzcmMvbGliL2RiaGFzaC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkYmhhc2hcXFwiKVxcblwiLFwic3JjL2xpYi9kZWNpbWFsLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImRlY2ltYWxcXFwiKVxcblwiLFwic3JjL2xpYi9kaWZmbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImRpZmZsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9kaXJjYWNoZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkaXJjYWNoZVxcXCIpXFxuXCIsXCJzcmMvbGliL2Rpcy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkaXNcXFwiKVxcblwiLFwic3JjL2xpYi9kaXN0dXRpbHMvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZGlzdHV0aWxzXFxcIilcXG5cIixcInNyYy9saWIvZGlzdHV0aWxzL2NvbW1hbmQvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiY29tbWFuZFxcXCIpXFxuXCIsXCJzcmMvbGliL2Rpc3R1dGlscy90ZXN0cy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0ZXN0c1xcXCIpXFxuXCIsXCJzcmMvbGliL2RvY3Rlc3QucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZG9jdGVzdFxcXCIpXFxuXCIsXCJzcmMvbGliL2R1bWJkYm0ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZHVtYmRibVxcXCIpXFxuXCIsXCJzcmMvbGliL2R1bW15X3RocmVhZC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkdW1teV90aHJlYWRcXFwiKVxcblwiLFwic3JjL2xpYi9kdW1teV90aHJlYWRpbmcucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZHVtbXlfdGhyZWFkaW5nXFxcIilcXG5cIixcInNyYy9saWIvZW1haWwvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZW1haWxcXFwiKVxcblwiLFwic3JjL2xpYi9lbWFpbC9taW1lL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1pbWVcXFwiKVxcblwiLFwic3JjL2xpYi9lbWFpbC90ZXN0L2RhdGEvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZGF0YVxcXCIpXFxuXCIsXCJzcmMvbGliL2VuY29kaW5ncy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJlbmNvZGluZ3NcXFwiKVxcblwiLFwic3JjL2xpYi9maWxlY21wLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImZpbGVjbXBcXFwiKVxcblwiLFwic3JjL2xpYi9maWxlaW5wdXQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZmlsZWlucHV0XFxcIilcXG5cIixcInNyYy9saWIvZm5tYXRjaC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJmbm1hdGNoXFxcIilcXG5cIixcInNyYy9saWIvZm9ybWF0dGVyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImZvcm1hdHRlclxcXCIpXFxuXCIsXCJzcmMvbGliL2ZwZm9ybWF0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImZwZm9ybWF0XFxcIilcXG5cIixcInNyYy9saWIvZnJhY3Rpb25zLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImZyYWN0aW9uc1xcXCIpXFxuXCIsXCJzcmMvbGliL2Z0cGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJmdHBsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9nZW5lcmljcGF0aC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJnZW5lcmljcGF0aFxcXCIpXFxuXCIsXCJzcmMvbGliL2dldG9wdC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJnZXRvcHRcXFwiKVxcblwiLFwic3JjL2xpYi9nZXRwYXNzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImdldHBhc3NcXFwiKVxcblwiLFwic3JjL2xpYi9nZXR0ZXh0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImdldHRleHRcXFwiKVxcblwiLFwic3JjL2xpYi9nbG9iLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImdsb2JcXFwiKVxcblwiLFwic3JjL2xpYi9nemlwLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImd6aXBcXFwiKVxcblwiLFwic3JjL2xpYi9oYXNobGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImhhc2hsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9oZWFwcS5weVwiOlwiXFxcIlxcXCJcXFwiSGVhcCBxdWV1ZSBhbGdvcml0aG0gKGEuay5hLiBwcmlvcml0eSBxdWV1ZSkuXFxuXFxuSGVhcHMgYXJlIGFycmF5cyBmb3Igd2hpY2ggYVtrXSA8PSBhWzIqaysxXSBhbmQgYVtrXSA8PSBhWzIqaysyXSBmb3JcXG5hbGwgaywgY291bnRpbmcgZWxlbWVudHMgZnJvbSAwLiAgRm9yIHRoZSBzYWtlIG9mIGNvbXBhcmlzb24sXFxubm9uLWV4aXN0aW5nIGVsZW1lbnRzIGFyZSBjb25zaWRlcmVkIHRvIGJlIGluZmluaXRlLiAgVGhlIGludGVyZXN0aW5nXFxucHJvcGVydHkgb2YgYSBoZWFwIGlzIHRoYXQgYVswXSBpcyBhbHdheXMgaXRzIHNtYWxsZXN0IGVsZW1lbnQuXFxuXFxuVXNhZ2U6XFxuXFxuaGVhcCA9IFtdICAgICAgICAgICAgIyBjcmVhdGVzIGFuIGVtcHR5IGhlYXBcXG5oZWFwcHVzaChoZWFwLCBpdGVtKSAjIHB1c2hlcyBhIG5ldyBpdGVtIG9uIHRoZSBoZWFwXFxuaXRlbSA9IGhlYXBwb3AoaGVhcCkgIyBwb3BzIHRoZSBzbWFsbGVzdCBpdGVtIGZyb20gdGhlIGhlYXBcXG5pdGVtID0gaGVhcFswXSAgICAgICAjIHNtYWxsZXN0IGl0ZW0gb24gdGhlIGhlYXAgd2l0aG91dCBwb3BwaW5nIGl0XFxuaGVhcGlmeSh4KSAgICAgICAgICAgIyB0cmFuc2Zvcm1zIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBsaW5lYXIgdGltZVxcbml0ZW0gPSBoZWFwcmVwbGFjZShoZWFwLCBpdGVtKSAjIHBvcHMgYW5kIHJldHVybnMgc21hbGxlc3QgaXRlbSwgYW5kIGFkZHNcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBuZXcgaXRlbTsgdGhlIGhlYXAgc2l6ZSBpcyB1bmNoYW5nZWRcXG5cXG5PdXIgQVBJIGRpZmZlcnMgZnJvbSB0ZXh0Ym9vayBoZWFwIGFsZ29yaXRobXMgYXMgZm9sbG93czpcXG5cXG4tIFdlIHVzZSAwLWJhc2VkIGluZGV4aW5nLiAgVGhpcyBtYWtlcyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlXFxuICBpbmRleCBmb3IgYSBub2RlIGFuZCB0aGUgaW5kZXhlcyBmb3IgaXRzIGNoaWxkcmVuIHNsaWdodGx5IGxlc3NcXG4gIG9idmlvdXMsIGJ1dCBpcyBtb3JlIHN1aXRhYmxlIHNpbmNlIFB5dGhvbiB1c2VzIDAtYmFzZWQgaW5kZXhpbmcuXFxuXFxuLSBPdXIgaGVhcHBvcCgpIG1ldGhvZCByZXR1cm5zIHRoZSBzbWFsbGVzdCBpdGVtLCBub3QgdGhlIGxhcmdlc3QuXFxuXFxuVGhlc2UgdHdvIG1ha2UgaXQgcG9zc2libGUgdG8gdmlldyB0aGUgaGVhcCBhcyBhIHJlZ3VsYXIgUHl0aG9uIGxpc3RcXG53aXRob3V0IHN1cnByaXNlczogaGVhcFswXSBpcyB0aGUgc21hbGxlc3QgaXRlbSwgYW5kIGhlYXAuc29ydCgpXFxubWFpbnRhaW5zIHRoZSBoZWFwIGludmFyaWFudCFcXG5cXFwiXFxcIlxcXCJcXG5cXG4jIE9yaWdpbmFsIGNvZGUgYnkgS2V2aW4gTydDb25ub3IsIGF1Z21lbnRlZCBieSBUaW0gUGV0ZXJzIGFuZCBSYXltb25kIEhldHRpbmdlclxcblxcbl9fYWJvdXRfXyA9IFxcXCJcXFwiXFxcIkhlYXAgcXVldWVzXFxuXFxuW2V4cGxhbmF0aW9uIGJ5IEZyYW7Dp29pcyBQaW5hcmRdXFxuXFxuSGVhcHMgYXJlIGFycmF5cyBmb3Igd2hpY2ggYVtrXSA8PSBhWzIqaysxXSBhbmQgYVtrXSA8PSBhWzIqaysyXSBmb3JcXG5hbGwgaywgY291bnRpbmcgZWxlbWVudHMgZnJvbSAwLiAgRm9yIHRoZSBzYWtlIG9mIGNvbXBhcmlzb24sXFxubm9uLWV4aXN0aW5nIGVsZW1lbnRzIGFyZSBjb25zaWRlcmVkIHRvIGJlIGluZmluaXRlLiAgVGhlIGludGVyZXN0aW5nXFxucHJvcGVydHkgb2YgYSBoZWFwIGlzIHRoYXQgYVswXSBpcyBhbHdheXMgaXRzIHNtYWxsZXN0IGVsZW1lbnQuXFxuXFxuVGhlIHN0cmFuZ2UgaW52YXJpYW50IGFib3ZlIGlzIG1lYW50IHRvIGJlIGFuIGVmZmljaWVudCBtZW1vcnlcXG5yZXByZXNlbnRhdGlvbiBmb3IgYSB0b3VybmFtZW50LiAgVGhlIG51bWJlcnMgYmVsb3cgYXJlIGBrJywgbm90IGFba106XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXFxuXFxuICAgICAgICAgICAgICAgICAgMSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcXG5cXG4gICAgICAgICAgMyAgICAgICAgICAgICAgIDQgICAgICAgICAgICAgICAgNSAgICAgICAgICAgICAgIDZcXG5cXG4gICAgICA3ICAgICAgIDggICAgICAgOSAgICAgICAxMCAgICAgIDExICAgICAgMTIgICAgICAxMyAgICAgIDE0XFxuXFxuICAgIDE1IDE2ICAgMTcgMTggICAxOSAyMCAgIDIxIDIyICAgMjMgMjQgICAyNSAyNiAgIDI3IDI4ICAgMjkgMzBcXG5cXG5cXG5JbiB0aGUgdHJlZSBhYm92ZSwgZWFjaCBjZWxsIGBrJyBpcyB0b3BwaW5nIGAyKmsrMScgYW5kIGAyKmsrMicuICBJblxcbmEgdXN1YWwgYmluYXJ5IHRvdXJuYW1lbnQgd2Ugc2VlIGluIHNwb3J0cywgZWFjaCBjZWxsIGlzIHRoZSB3aW5uZXJcXG5vdmVyIHRoZSB0d28gY2VsbHMgaXQgdG9wcywgYW5kIHdlIGNhbiB0cmFjZSB0aGUgd2lubmVyIGRvd24gdGhlIHRyZWVcXG50byBzZWUgYWxsIG9wcG9uZW50cyBzL2hlIGhhZC4gIEhvd2V2ZXIsIGluIG1hbnkgY29tcHV0ZXIgYXBwbGljYXRpb25zXFxub2Ygc3VjaCB0b3VybmFtZW50cywgd2UgZG8gbm90IG5lZWQgdG8gdHJhY2UgdGhlIGhpc3Rvcnkgb2YgYSB3aW5uZXIuXFxuVG8gYmUgbW9yZSBtZW1vcnkgZWZmaWNpZW50LCB3aGVuIGEgd2lubmVyIGlzIHByb21vdGVkLCB3ZSB0cnkgdG9cXG5yZXBsYWNlIGl0IGJ5IHNvbWV0aGluZyBlbHNlIGF0IGEgbG93ZXIgbGV2ZWwsIGFuZCB0aGUgcnVsZSBiZWNvbWVzXFxudGhhdCBhIGNlbGwgYW5kIHRoZSB0d28gY2VsbHMgaXQgdG9wcyBjb250YWluIHRocmVlIGRpZmZlcmVudCBpdGVtcyxcXG5idXQgdGhlIHRvcCBjZWxsIFxcXCJ3aW5zXFxcIiBvdmVyIHRoZSB0d28gdG9wcGVkIGNlbGxzLlxcblxcbklmIHRoaXMgaGVhcCBpbnZhcmlhbnQgaXMgcHJvdGVjdGVkIGF0IGFsbCB0aW1lLCBpbmRleCAwIGlzIGNsZWFybHlcXG50aGUgb3ZlcmFsbCB3aW5uZXIuICBUaGUgc2ltcGxlc3QgYWxnb3JpdGhtaWMgd2F5IHRvIHJlbW92ZSBpdCBhbmRcXG5maW5kIHRoZSBcXFwibmV4dFxcXCIgd2lubmVyIGlzIHRvIG1vdmUgc29tZSBsb3NlciAobGV0J3Mgc2F5IGNlbGwgMzAgaW4gdGhlXFxuZGlhZ3JhbSBhYm92ZSkgaW50byB0aGUgMCBwb3NpdGlvbiwgYW5kIHRoZW4gcGVyY29sYXRlIHRoaXMgbmV3IDAgZG93blxcbnRoZSB0cmVlLCBleGNoYW5naW5nIHZhbHVlcywgdW50aWwgdGhlIGludmFyaWFudCBpcyByZS1lc3RhYmxpc2hlZC5cXG5UaGlzIGlzIGNsZWFybHkgbG9nYXJpdGhtaWMgb24gdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgdHJlZS5cXG5CeSBpdGVyYXRpbmcgb3ZlciBhbGwgaXRlbXMsIHlvdSBnZXQgYW4gTyhuIGxuIG4pIHNvcnQuXFxuXFxuQSBuaWNlIGZlYXR1cmUgb2YgdGhpcyBzb3J0IGlzIHRoYXQgeW91IGNhbiBlZmZpY2llbnRseSBpbnNlcnQgbmV3XFxuaXRlbXMgd2hpbGUgdGhlIHNvcnQgaXMgZ29pbmcgb24sIHByb3ZpZGVkIHRoYXQgdGhlIGluc2VydGVkIGl0ZW1zIGFyZVxcbm5vdCBcXFwiYmV0dGVyXFxcIiB0aGFuIHRoZSBsYXN0IDAndGggZWxlbWVudCB5b3UgZXh0cmFjdGVkLiAgVGhpcyBpc1xcbmVzcGVjaWFsbHkgdXNlZnVsIGluIHNpbXVsYXRpb24gY29udGV4dHMsIHdoZXJlIHRoZSB0cmVlIGhvbGRzIGFsbFxcbmluY29taW5nIGV2ZW50cywgYW5kIHRoZSBcXFwid2luXFxcIiBjb25kaXRpb24gbWVhbnMgdGhlIHNtYWxsZXN0IHNjaGVkdWxlZFxcbnRpbWUuICBXaGVuIGFuIGV2ZW50IHNjaGVkdWxlIG90aGVyIGV2ZW50cyBmb3IgZXhlY3V0aW9uLCB0aGV5IGFyZVxcbnNjaGVkdWxlZCBpbnRvIHRoZSBmdXR1cmUsIHNvIHRoZXkgY2FuIGVhc2lseSBnbyBpbnRvIHRoZSBoZWFwLiAgU28sIGFcXG5oZWFwIGlzIGEgZ29vZCBzdHJ1Y3R1cmUgZm9yIGltcGxlbWVudGluZyBzY2hlZHVsZXJzICh0aGlzIGlzIHdoYXQgSVxcbnVzZWQgZm9yIG15IE1JREkgc2VxdWVuY2VyIDotKS5cXG5cXG5WYXJpb3VzIHN0cnVjdHVyZXMgZm9yIGltcGxlbWVudGluZyBzY2hlZHVsZXJzIGhhdmUgYmVlbiBleHRlbnNpdmVseVxcbnN0dWRpZWQsIGFuZCBoZWFwcyBhcmUgZ29vZCBmb3IgdGhpcywgYXMgdGhleSBhcmUgcmVhc29uYWJseSBzcGVlZHksXFxudGhlIHNwZWVkIGlzIGFsbW9zdCBjb25zdGFudCwgYW5kIHRoZSB3b3JzdCBjYXNlIGlzIG5vdCBtdWNoIGRpZmZlcmVudFxcbnRoYW4gdGhlIGF2ZXJhZ2UgY2FzZS4gIEhvd2V2ZXIsIHRoZXJlIGFyZSBvdGhlciByZXByZXNlbnRhdGlvbnMgd2hpY2hcXG5hcmUgbW9yZSBlZmZpY2llbnQgb3ZlcmFsbCwgeWV0IHRoZSB3b3JzdCBjYXNlcyBtaWdodCBiZSB0ZXJyaWJsZS5cXG5cXG5IZWFwcyBhcmUgYWxzbyB2ZXJ5IHVzZWZ1bCBpbiBiaWcgZGlzayBzb3J0cy4gIFlvdSBtb3N0IHByb2JhYmx5IGFsbFxcbmtub3cgdGhhdCBhIGJpZyBzb3J0IGltcGxpZXMgcHJvZHVjaW5nIFxcXCJydW5zXFxcIiAod2hpY2ggYXJlIHByZS1zb3J0ZWRcXG5zZXF1ZW5jZXMsIHdoaWNoIHNpemUgaXMgdXN1YWxseSByZWxhdGVkIHRvIHRoZSBhbW91bnQgb2YgQ1BVIG1lbW9yeSksXFxuZm9sbG93ZWQgYnkgYSBtZXJnaW5nIHBhc3NlcyBmb3IgdGhlc2UgcnVucywgd2hpY2ggbWVyZ2luZyBpcyBvZnRlblxcbnZlcnkgY2xldmVybHkgb3JnYW5pc2VkWzFdLiAgSXQgaXMgdmVyeSBpbXBvcnRhbnQgdGhhdCB0aGUgaW5pdGlhbFxcbnNvcnQgcHJvZHVjZXMgdGhlIGxvbmdlc3QgcnVucyBwb3NzaWJsZS4gIFRvdXJuYW1lbnRzIGFyZSBhIGdvb2Qgd2F5XFxudG8gdGhhdC4gIElmLCB1c2luZyBhbGwgdGhlIG1lbW9yeSBhdmFpbGFibGUgdG8gaG9sZCBhIHRvdXJuYW1lbnQsIHlvdVxcbnJlcGxhY2UgYW5kIHBlcmNvbGF0ZSBpdGVtcyB0aGF0IGhhcHBlbiB0byBmaXQgdGhlIGN1cnJlbnQgcnVuLCB5b3UnbGxcXG5wcm9kdWNlIHJ1bnMgd2hpY2ggYXJlIHR3aWNlIHRoZSBzaXplIG9mIHRoZSBtZW1vcnkgZm9yIHJhbmRvbSBpbnB1dCxcXG5hbmQgbXVjaCBiZXR0ZXIgZm9yIGlucHV0IGZ1enppbHkgb3JkZXJlZC5cXG5cXG5Nb3Jlb3ZlciwgaWYgeW91IG91dHB1dCB0aGUgMCd0aCBpdGVtIG9uIGRpc2sgYW5kIGdldCBhbiBpbnB1dCB3aGljaFxcbm1heSBub3QgZml0IGluIHRoZSBjdXJyZW50IHRvdXJuYW1lbnQgKGJlY2F1c2UgdGhlIHZhbHVlIFxcXCJ3aW5zXFxcIiBvdmVyXFxudGhlIGxhc3Qgb3V0cHV0IHZhbHVlKSwgaXQgY2Fubm90IGZpdCBpbiB0aGUgaGVhcCwgc28gdGhlIHNpemUgb2YgdGhlXFxuaGVhcCBkZWNyZWFzZXMuICBUaGUgZnJlZWQgbWVtb3J5IGNvdWxkIGJlIGNsZXZlcmx5IHJldXNlZCBpbW1lZGlhdGVseVxcbmZvciBwcm9ncmVzc2l2ZWx5IGJ1aWxkaW5nIGEgc2Vjb25kIGhlYXAsIHdoaWNoIGdyb3dzIGF0IGV4YWN0bHkgdGhlXFxuc2FtZSByYXRlIHRoZSBmaXJzdCBoZWFwIGlzIG1lbHRpbmcuICBXaGVuIHRoZSBmaXJzdCBoZWFwIGNvbXBsZXRlbHlcXG52YW5pc2hlcywgeW91IHN3aXRjaCBoZWFwcyBhbmQgc3RhcnQgYSBuZXcgcnVuLiAgQ2xldmVyIGFuZCBxdWl0ZVxcbmVmZmVjdGl2ZSFcXG5cXG5JbiBhIHdvcmQsIGhlYXBzIGFyZSB1c2VmdWwgbWVtb3J5IHN0cnVjdHVyZXMgdG8ga25vdy4gIEkgdXNlIHRoZW0gaW5cXG5hIGZldyBhcHBsaWNhdGlvbnMsIGFuZCBJIHRoaW5rIGl0IGlzIGdvb2QgdG8ga2VlcCBhIGBoZWFwJyBtb2R1bGVcXG5hcm91bmQuIDotKVxcblxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuWzFdIFRoZSBkaXNrIGJhbGFuY2luZyBhbGdvcml0aG1zIHdoaWNoIGFyZSBjdXJyZW50LCBub3dhZGF5cywgYXJlXFxubW9yZSBhbm5veWluZyB0aGFuIGNsZXZlciwgYW5kIHRoaXMgaXMgYSBjb25zZXF1ZW5jZSBvZiB0aGUgc2Vla2luZ1xcbmNhcGFiaWxpdGllcyBvZiB0aGUgZGlza3MuICBPbiBkZXZpY2VzIHdoaWNoIGNhbm5vdCBzZWVrLCBsaWtlIGJpZ1xcbnRhcGUgZHJpdmVzLCB0aGUgc3Rvcnkgd2FzIHF1aXRlIGRpZmZlcmVudCwgYW5kIG9uZSBoYWQgdG8gYmUgdmVyeVxcbmNsZXZlciB0byBlbnN1cmUgKGZhciBpbiBhZHZhbmNlKSB0aGF0IGVhY2ggdGFwZSBtb3ZlbWVudCB3aWxsIGJlIHRoZVxcbm1vc3QgZWZmZWN0aXZlIHBvc3NpYmxlICh0aGF0IGlzLCB3aWxsIGJlc3QgcGFydGljaXBhdGUgYXRcXG5cXFwicHJvZ3Jlc3NpbmdcXFwiIHRoZSBtZXJnZSkuICBTb21lIHRhcGVzIHdlcmUgZXZlbiBhYmxlIHRvIHJlYWRcXG5iYWNrd2FyZHMsIGFuZCB0aGlzIHdhcyBhbHNvIHVzZWQgdG8gYXZvaWQgdGhlIHJld2luZGluZyB0aW1lLlxcbkJlbGlldmUgbWUsIHJlYWwgZ29vZCB0YXBlIHNvcnRzIHdlcmUgcXVpdGUgc3BlY3RhY3VsYXIgdG8gd2F0Y2ghXFxuRnJvbSBhbGwgdGltZXMsIHNvcnRpbmcgaGFzIGFsd2F5cyBiZWVuIGEgR3JlYXQgQXJ0ISA6LSlcXG5cXFwiXFxcIlxcXCJcXG5cXG5fX2FsbF9fID0gWydoZWFwcHVzaCcsICdoZWFwcG9wJywgJ2hlYXBpZnknLCAnaGVhcHJlcGxhY2UnLFxcbiAgICAgICAgICAgJ25sYXJnZXN0JywgJ25zbWFsbGVzdCcsICdoZWFwcHVzaHBvcCddXFxuXFxuXFxuZGVmIGhlYXBwdXNoKGhlYXAsIGl0ZW0pOlxcbiAgICBcXFwiXFxcIlxcXCJQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXFxcIlxcXCJcXFwiXFxuICAgIGhlYXAuYXBwZW5kKGl0ZW0pXFxuICAgIF9zaWZ0ZG93bihoZWFwLCAwLCBsZW4oaGVhcCkgLSAxKVxcblxcblxcbmRlZiBoZWFwcG9wKGhlYXApOlxcbiAgICBcXFwiXFxcIlxcXCJQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXFxcIlxcXCJcXFwiXFxuICAgIGxhc3RlbHQgPSBoZWFwLnBvcCgpICAgICMgcmFpc2VzIGFwcHJvcHJpYXRlIEluZGV4RXJyb3IgaWYgaGVhcCBpcyBlbXB0eVxcbiAgICBpZiBoZWFwOlxcbiAgICAgICAgcmV0dXJuaXRlbSA9IGhlYXBbMF1cXG4gICAgICAgIGhlYXBbMF0gPSBsYXN0ZWx0XFxuICAgICAgICBfc2lmdHVwKGhlYXAsIDApXFxuICAgICAgICByZXR1cm4gcmV0dXJuaXRlbVxcbiAgICByZXR1cm4gbGFzdGVsdFxcblxcblxcbmRlZiBoZWFwcmVwbGFjZShoZWFwLCBpdGVtKTpcXG4gICAgXFxcIlxcXCJcXFwiUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxcblxcbiAgICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcXG4gICAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQtc2l6ZSBoZWFwLiAgTm90ZSB0aGF0IHRoZSB2YWx1ZVxcbiAgICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZXMgb2ZcXG4gICAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcXG5cXG4gICAgICAgIGlmIGl0ZW0gPiBoZWFwWzBdOlxcbiAgICAgICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShoZWFwLCBpdGVtKVxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgcmV0dXJuaXRlbSA9IGhlYXBbMF0gICAgIyByYWlzZXMgYXBwcm9wcmlhdGUgSW5kZXhFcnJvciBpZiBoZWFwIGlzIGVtcHR5XFxuICAgIGhlYXBbMF0gPSBpdGVtXFxuICAgIF9zaWZ0dXAoaGVhcCwgMClcXG4gICAgcmV0dXJuIHJldHVybml0ZW1cXG5cXG5cXG5kZWYgaGVhcHB1c2hwb3AoaGVhcCwgaXRlbSk6XFxuICAgIFxcXCJcXFwiXFxcIkZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cXFwiXFxcIlxcXCJcXG4gICAgaWYgaGVhcCBhbmQgaGVhcFswXSA8IGl0ZW06XFxuICAgICAgICBpdGVtLCBoZWFwWzBdID0gaGVhcFswXSwgaXRlbVxcbiAgICAgICAgX3NpZnR1cChoZWFwLCAwKVxcbiAgICByZXR1cm4gaXRlbVxcblxcblxcbmRlZiBoZWFwaWZ5KHgpOlxcbiAgICBcXFwiXFxcIlxcXCJUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8obGVuKHgpKSB0aW1lLlxcXCJcXFwiXFxcIlxcbiAgICBuID0gbGVuKHgpXFxuICAgICMgVHJhbnNmb3JtIGJvdHRvbS11cC4gIFRoZSBsYXJnZXN0IGluZGV4IHRoZXJlJ3MgYW55IHBvaW50IHRvIGxvb2tpbmcgYXRcXG4gICAgIyBpcyB0aGUgbGFyZ2VzdCB3aXRoIGEgY2hpbGQgaW5kZXggaW4tcmFuZ2UsIHNvIG11c3QgaGF2ZSAyKmkgKyAxIDwgbixcXG4gICAgIyBvciBpIDwgKG4tMSkvMi4gIElmIG4gaXMgZXZlbiA9IDIqaiwgdGhpcyBpcyAoMipqLTEpLzIgPSBqLTEvMiBzb1xcbiAgICAjIGotMSBpcyB0aGUgbGFyZ2VzdCwgd2hpY2ggaXMgbi8vMiAtIDEuICBJZiBuIGlzIG9kZCA9IDIqaisxLCB0aGlzIGlzXFxuICAgICMgKDIqaisxLTEpLzIgPSBqIHNvIGotMSBpcyB0aGUgbGFyZ2VzdCwgYW5kIHRoYXQncyBhZ2FpbiBuLy8yLTEuXFxuICAgIGZvciBpIGluIHJldmVyc2VkKHJhbmdlKG4gLy8gMikpOlxcbiAgICAgICAgX3NpZnR1cCh4LCBpKVxcblxcblxcbmRlZiBfaGVhcHBvcF9tYXgoaGVhcCk6XFxuICAgIFxcXCJcXFwiXFxcIk1heGhlYXAgdmVyc2lvbiBvZiBhIGhlYXBwb3AuXFxcIlxcXCJcXFwiXFxuICAgIGxhc3RlbHQgPSBoZWFwLnBvcCgpICAgICMgcmFpc2VzIGFwcHJvcHJpYXRlIEluZGV4RXJyb3IgaWYgaGVhcCBpcyBlbXB0eVxcbiAgICBpZiBoZWFwOlxcbiAgICAgICAgcmV0dXJuaXRlbSA9IGhlYXBbMF1cXG4gICAgICAgIGhlYXBbMF0gPSBsYXN0ZWx0XFxuICAgICAgICBfc2lmdHVwX21heChoZWFwLCAwKVxcbiAgICAgICAgcmV0dXJuIHJldHVybml0ZW1cXG4gICAgcmV0dXJuIGxhc3RlbHRcXG5cXG5cXG5kZWYgX2hlYXByZXBsYWNlX21heChoZWFwLCBpdGVtKTpcXG4gICAgXFxcIlxcXCJcXFwiTWF4aGVhcCB2ZXJzaW9uIG9mIGEgaGVhcHBvcCBmb2xsb3dlZCBieSBhIGhlYXBwdXNoLlxcXCJcXFwiXFxcIlxcbiAgICByZXR1cm5pdGVtID0gaGVhcFswXSAgICAjIHJhaXNlcyBhcHByb3ByaWF0ZSBJbmRleEVycm9yIGlmIGhlYXAgaXMgZW1wdHlcXG4gICAgaGVhcFswXSA9IGl0ZW1cXG4gICAgX3NpZnR1cF9tYXgoaGVhcCwgMClcXG4gICAgcmV0dXJuIHJldHVybml0ZW1cXG5cXG5cXG5kZWYgX2hlYXBpZnlfbWF4KHgpOlxcbiAgICBcXFwiXFxcIlxcXCJUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgbWF4aGVhcCwgaW4tcGxhY2UsIGluIE8obGVuKHgpKSB0aW1lLlxcXCJcXFwiXFxcIlxcbiAgICBuID0gbGVuKHgpXFxuICAgIGZvciBpIGluIHJldmVyc2VkKHJhbmdlKG4gLy8gMikpOlxcbiAgICAgICAgX3NpZnR1cF9tYXgoeCwgaSlcXG5cXG4jICdoZWFwJyBpcyBhIGhlYXAgYXQgYWxsIGluZGljZXMgPj0gc3RhcnRwb3MsIGV4Y2VwdCBwb3NzaWJseSBmb3IgcG9zLiAgcG9zXFxuIyBpcyB0aGUgaW5kZXggb2YgYSBsZWFmIHdpdGggYSBwb3NzaWJseSBvdXQtb2Ytb3JkZXIgdmFsdWUuICBSZXN0b3JlIHRoZVxcbiMgaGVhcCBpbnZhcmlhbnQuXFxuXFxuXFxuZGVmIF9zaWZ0ZG93bihoZWFwLCBzdGFydHBvcywgcG9zKTpcXG4gICAgbmV3aXRlbSA9IGhlYXBbcG9zXVxcbiAgICAjIEZvbGxvdyB0aGUgcGF0aCB0byB0aGUgcm9vdCwgbW92aW5nIHBhcmVudHMgZG93biB1bnRpbCBmaW5kaW5nIGEgcGxhY2VcXG4gICAgIyBuZXdpdGVtIGZpdHMuXFxuICAgIHdoaWxlIHBvcyA+IHN0YXJ0cG9zOlxcbiAgICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDFcXG4gICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50cG9zXVxcbiAgICAgICAgaWYgbmV3aXRlbSA8IHBhcmVudDpcXG4gICAgICAgICAgICBoZWFwW3Bvc10gPSBwYXJlbnRcXG4gICAgICAgICAgICBwb3MgPSBwYXJlbnRwb3NcXG4gICAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgYnJlYWtcXG4gICAgaGVhcFtwb3NdID0gbmV3aXRlbVxcblxcbiMgVGhlIGNoaWxkIGluZGljZXMgb2YgaGVhcCBpbmRleCBwb3MgYXJlIGFscmVhZHkgaGVhcHMsIGFuZCB3ZSB3YW50IHRvIG1ha2VcXG4jIGEgaGVhcCBhdCBpbmRleCBwb3MgdG9vLiAgV2UgZG8gdGhpcyBieSBidWJibGluZyB0aGUgc21hbGxlciBjaGlsZCBvZlxcbiMgcG9zIHVwIChhbmQgc28gb24gd2l0aCB0aGF0IGNoaWxkJ3MgY2hpbGRyZW4sIGV0YykgdW50aWwgaGl0dGluZyBhIGxlYWYsXFxuIyB0aGVuIHVzaW5nIF9zaWZ0ZG93biB0byBtb3ZlIHRoZSBvZGRiYWxsIG9yaWdpbmFsbHkgYXQgaW5kZXggcG9zIGludG8gcGxhY2UuXFxuI1xcbiMgV2UgKmNvdWxkKiBicmVhayBvdXQgb2YgdGhlIGxvb3AgYXMgc29vbiBhcyB3ZSBmaW5kIGEgcG9zIHdoZXJlIG5ld2l0ZW0gPD1cXG4jIGJvdGggaXRzIGNoaWxkcmVuLCBidXQgdHVybnMgb3V0IHRoYXQncyBub3QgYSBnb29kIGlkZWEsIGFuZCBkZXNwaXRlIHRoYXRcXG4jIG1hbnkgYm9va3Mgd3JpdGUgdGhlIGFsZ29yaXRobSB0aGF0IHdheS4gIER1cmluZyBhIGhlYXAgcG9wLCB0aGUgbGFzdCBhcnJheVxcbiMgZWxlbWVudCBpcyBzaWZ0ZWQgaW4sIGFuZCB0aGF0IHRlbmRzIHRvIGJlIGxhcmdlLCBzbyB0aGF0IGNvbXBhcmluZyBpdFxcbiMgYWdhaW5zdCB2YWx1ZXMgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCB1c3VhbGx5IGRvZXNuJ3QgcGF5ICg9IHVzdWFsbHkgZG9lc24ndFxcbiMgZ2V0IHVzIG91dCBvZiB0aGUgbG9vcCBlYXJseSkuICBTZWUgS251dGgsIFZvbHVtZSAzLCB3aGVyZSB0aGlzIGlzXFxuIyBleHBsYWluZWQgYW5kIHF1YW50aWZpZWQgaW4gYW4gZXhlcmNpc2UuXFxuI1xcbiMgQ3V0dGluZyB0aGUgIyBvZiBjb21wYXJpc29ucyBpcyBpbXBvcnRhbnQsIHNpbmNlIHRoZXNlIHJvdXRpbmVzIGhhdmUgbm9cXG4jIHdheSB0byBleHRyYWN0IFxcXCJ0aGUgcHJpb3JpdHlcXFwiIGZyb20gYW4gYXJyYXkgZWxlbWVudCwgc28gdGhhdCBpbnRlbGxpZ2VuY2VcXG4jIGlzIGxpa2VseSB0byBiZSBoaWRpbmcgaW4gY3VzdG9tIGNvbXBhcmlzb24gbWV0aG9kcywgb3IgaW4gYXJyYXkgZWxlbWVudHNcXG4jIHN0b3JpbmcgKHByaW9yaXR5LCByZWNvcmQpIHR1cGxlcy4gIENvbXBhcmlzb25zIGFyZSB0aHVzIHBvdGVudGlhbGx5XFxuIyBleHBlbnNpdmUuXFxuI1xcbiMgT24gcmFuZG9tIGFycmF5cyBvZiBsZW5ndGggMTAwMCwgbWFraW5nIHRoaXMgY2hhbmdlIGN1dCB0aGUgbnVtYmVyIG9mXFxuIyBjb21wYXJpc29ucyBtYWRlIGJ5IGhlYXBpZnkoKSBhIGxpdHRsZSwgYW5kIHRob3NlIG1hZGUgYnkgZXhoYXVzdGl2ZVxcbiMgaGVhcHBvcCgpIGEgbG90LCBpbiBhY2NvcmQgd2l0aCB0aGVvcnkuICBIZXJlIGFyZSB0eXBpY2FsIHJlc3VsdHMgZnJvbSAzXFxuIyBydW5zICgzIGp1c3QgdG8gZGVtb25zdHJhdGUgaG93IHNtYWxsIHRoZSB2YXJpYW5jZSBpcyk6XFxuI1xcbiMgQ29tcGFyZXMgbmVlZGVkIGJ5IGhlYXBpZnkgICAgIENvbXBhcmVzIG5lZWRlZCBieSAxMDAwIGhlYXBwb3BzXFxuIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4jIDE4MzcgY3V0IHRvIDE2NjMgICAgICAgICAgICAgICAxNDk5NiBjdXQgdG8gODY4MFxcbiMgMTg1NSBjdXQgdG8gMTY1OSAgICAgICAgICAgICAgIDE0OTY2IGN1dCB0byA4Njc4XFxuIyAxODQ3IGN1dCB0byAxNjYwICAgICAgICAgICAgICAgMTUwMjQgY3V0IHRvIDg3MDNcXG4jXFxuIyBCdWlsZGluZyB0aGUgaGVhcCBieSB1c2luZyBoZWFwcHVzaCgpIDEwMDAgdGltZXMgaW5zdGVhZCByZXF1aXJlZFxcbiMgMjE5OCwgMjE0OCwgYW5kIDIyMTkgY29tcGFyZXM6ICBoZWFwaWZ5KCkgaXMgbW9yZSBlZmZpY2llbnQsIHdoZW5cXG4jIHlvdSBjYW4gdXNlIGl0LlxcbiNcXG4jIFRoZSB0b3RhbCBjb21wYXJlcyBuZWVkZWQgYnkgbGlzdC5zb3J0KCkgb24gdGhlIHNhbWUgbGlzdHMgd2VyZSA4NjI3LFxcbiMgODYyNywgYW5kIDg2MzIgKHRoaXMgc2hvdWxkIGJlIGNvbXBhcmVkIHRvIHRoZSBzdW0gb2YgaGVhcGlmeSgpIGFuZFxcbiMgaGVhcHBvcCgpIGNvbXBhcmVzKTogIGxpc3Quc29ydCgpIGlzICh1bnN1cnByaXNpbmdseSEpIG1vcmUgZWZmaWNpZW50XFxuIyBmb3Igc29ydGluZy5cXG5cXG5cXG5kZWYgX3NpZnR1cChoZWFwLCBwb3MpOlxcbiAgICBlbmRwb3MgPSBsZW4oaGVhcClcXG4gICAgc3RhcnRwb3MgPSBwb3NcXG4gICAgbmV3aXRlbSA9IGhlYXBbcG9zXVxcbiAgICAjIEJ1YmJsZSB1cCB0aGUgc21hbGxlciBjaGlsZCB1bnRpbCBoaXR0aW5nIGEgbGVhZi5cXG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMSAgICAjIGxlZnRtb3N0IGNoaWxkIHBvc2l0aW9uXFxuICAgIHdoaWxlIGNoaWxkcG9zIDwgZW5kcG9zOlxcbiAgICAgICAgIyBTZXQgY2hpbGRwb3MgdG8gaW5kZXggb2Ygc21hbGxlciBjaGlsZC5cXG4gICAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxXFxuICAgICAgICBpZiByaWdodHBvcyA8IGVuZHBvcyBhbmQgbm90IGhlYXBbY2hpbGRwb3NdIDwgaGVhcFtyaWdodHBvc106XFxuICAgICAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvc1xcbiAgICAgICAgIyBNb3ZlIHRoZSBzbWFsbGVyIGNoaWxkIHVwLlxcbiAgICAgICAgaGVhcFtwb3NdID0gaGVhcFtjaGlsZHBvc11cXG4gICAgICAgIHBvcyA9IGNoaWxkcG9zXFxuICAgICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxXFxuICAgICMgVGhlIGxlYWYgYXQgcG9zIGlzIGVtcHR5IG5vdy4gIFB1dCBuZXdpdGVtIHRoZXJlLCBhbmQgYnViYmxlIGl0IHVwXFxuICAgICMgdG8gaXRzIGZpbmFsIHJlc3RpbmcgcGxhY2UgKGJ5IHNpZnRpbmcgaXRzIHBhcmVudHMgZG93bikuXFxuICAgIGhlYXBbcG9zXSA9IG5ld2l0ZW1cXG4gICAgX3NpZnRkb3duKGhlYXAsIHN0YXJ0cG9zLCBwb3MpXFxuXFxuXFxuZGVmIF9zaWZ0ZG93bl9tYXgoaGVhcCwgc3RhcnRwb3MsIHBvcyk6XFxuICAgICdNYXhoZWFwIHZhcmlhbnQgb2YgX3NpZnRkb3duJ1xcbiAgICBuZXdpdGVtID0gaGVhcFtwb3NdXFxuICAgICMgRm9sbG93IHRoZSBwYXRoIHRvIHRoZSByb290LCBtb3ZpbmcgcGFyZW50cyBkb3duIHVudGlsIGZpbmRpbmcgYSBwbGFjZVxcbiAgICAjIG5ld2l0ZW0gZml0cy5cXG4gICAgd2hpbGUgcG9zID4gc3RhcnRwb3M6XFxuICAgICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMVxcbiAgICAgICAgcGFyZW50ID0gaGVhcFtwYXJlbnRwb3NdXFxuICAgICAgICBpZiBwYXJlbnQgPCBuZXdpdGVtOlxcbiAgICAgICAgICAgIGhlYXBbcG9zXSA9IHBhcmVudFxcbiAgICAgICAgICAgIHBvcyA9IHBhcmVudHBvc1xcbiAgICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICBicmVha1xcbiAgICBoZWFwW3Bvc10gPSBuZXdpdGVtXFxuXFxuXFxuZGVmIF9zaWZ0dXBfbWF4KGhlYXAsIHBvcyk6XFxuICAgICdNYXhoZWFwIHZhcmlhbnQgb2YgX3NpZnR1cCdcXG4gICAgZW5kcG9zID0gbGVuKGhlYXApXFxuICAgIHN0YXJ0cG9zID0gcG9zXFxuICAgIG5ld2l0ZW0gPSBoZWFwW3Bvc11cXG4gICAgIyBCdWJibGUgdXAgdGhlIGxhcmdlciBjaGlsZCB1bnRpbCBoaXR0aW5nIGEgbGVhZi5cXG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMSAgICAjIGxlZnRtb3N0IGNoaWxkIHBvc2l0aW9uXFxuICAgIHdoaWxlIGNoaWxkcG9zIDwgZW5kcG9zOlxcbiAgICAgICAgIyBTZXQgY2hpbGRwb3MgdG8gaW5kZXggb2YgbGFyZ2VyIGNoaWxkLlxcbiAgICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDFcXG4gICAgICAgIGlmIHJpZ2h0cG9zIDwgZW5kcG9zIGFuZCBub3QgaGVhcFtyaWdodHBvc10gPCBoZWFwW2NoaWxkcG9zXTpcXG4gICAgICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zXFxuICAgICAgICAjIE1vdmUgdGhlIGxhcmdlciBjaGlsZCB1cC5cXG4gICAgICAgIGhlYXBbcG9zXSA9IGhlYXBbY2hpbGRwb3NdXFxuICAgICAgICBwb3MgPSBjaGlsZHBvc1xcbiAgICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMVxcbiAgICAjIFRoZSBsZWFmIGF0IHBvcyBpcyBlbXB0eSBub3cuICBQdXQgbmV3aXRlbSB0aGVyZSwgYW5kIGJ1YmJsZSBpdCB1cFxcbiAgICAjIHRvIGl0cyBmaW5hbCByZXN0aW5nIHBsYWNlIChieSBzaWZ0aW5nIGl0cyBwYXJlbnRzIGRvd24pLlxcbiAgICBoZWFwW3Bvc10gPSBuZXdpdGVtXFxuICAgIF9zaWZ0ZG93bl9tYXgoaGVhcCwgc3RhcnRwb3MsIHBvcylcXG5cXG5cXG4jIEFsZ29yaXRobSBub3RlcyBmb3Igbmxhcmdlc3QoKSBhbmQgbnNtYWxsZXN0KClcXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4jXFxuIyBNYWtlIGEgc2luZ2xlIHBhc3Mgb3ZlciB0aGUgZGF0YSB3aGlsZSBrZWVwaW5nIHRoZSBrIG1vc3QgZXh0cmVtZSB2YWx1ZXNcXG4jIGluIGEgaGVhcC4gIE1lbW9yeSBjb25zdW1wdGlvbiBpcyBsaW1pdGVkIHRvIGtlZXBpbmcgayB2YWx1ZXMgaW4gYSBsaXN0LlxcbiNcXG4jIE1lYXN1cmVkIHBlcmZvcm1hbmNlIGZvciByYW5kb20gaW5wdXRzOlxcbiNcXG4jICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgb2YgY29tcGFyaXNvbnNcXG4jICAgIG4gaW5wdXRzICAgICBrLWV4dHJlbWUgdmFsdWVzICAoYXZlcmFnZSBvZiA1IHRyaWFscykgICAlIG1vcmUgdGhhbiBtaW4oKVxcbiMgLS0tLS0tLS0tLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0tXFxuIyAgICAgIDEsMDAwICAgICAgICAgICAxMDAgICAgICAgICAgICAgICAgICAzLDMxNyAgICAgICAgICAgICAgIDIzMS43JVxcbiMgICAgIDEwLDAwMCAgICAgICAgICAgMTAwICAgICAgICAgICAgICAgICAxNCwwNDYgICAgICAgICAgICAgICAgNDAuNSVcXG4jICAgIDEwMCwwMDAgICAgICAgICAgIDEwMCAgICAgICAgICAgICAgICAxMDUsNzQ5ICAgICAgICAgICAgICAgICA1LjclXFxuIyAgMSwwMDAsMDAwICAgICAgICAgICAxMDAgICAgICAgICAgICAgIDEsMDA3LDc1MSAgICAgICAgICAgICAgICAgMC44JVxcbiMgMTAsMDAwLDAwMCAgICAgICAgICAgMTAwICAgICAgICAgICAgIDEwLDAwOSw0MDEgICAgICAgICAgICAgICAgIDAuMSVcXG4jXFxuIyBUaGVvcmV0aWNhbCBudW1iZXIgb2YgY29tcGFyaXNvbnMgZm9yIGsgc21hbGxlc3Qgb2YgbiByYW5kb20gaW5wdXRzOlxcbiNcXG4jIFN0ZXAgICBDb21wYXJpc29ucyAgICAgICAgICAgICAgICAgIEFjdGlvblxcbiMgLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuIyAgMSAgICAgMS42NiAqIGsgICAgICAgICAgICAgICAgICAgICBoZWFwaWZ5IHRoZSBmaXJzdCBrLWlucHV0c1xcbiMgIDIgICAgIG4gLSBrICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSByZW1haW5pbmcgZWxlbWVudHMgdG8gdG9wIG9mIGhlYXBcXG4jICAzICAgICBrICogKDEgKyBsZzIoaykpICogbG4obi9rKSAgIHJlcGxhY2UgdGhlIHRvcG1vc3QgdmFsdWUgb24gdGhlIGhlYXBcXG4jICA0ICAgICBrICogbGcyKGspIC0gKGsvMikgICAgICAgICAgIGZpbmFsIHNvcnQgb2YgdGhlIGsgbW9zdCBleHRyZW1lIHZhbHVlc1xcbiNcXG4jIENvbWJpbmluZyBhbmQgc2ltcGxpZnlpbmcgZm9yIGEgcm91Z2ggZXN0aW1hdGUgZ2l2ZXM6XFxuI1xcbiMgICAgICAgIGNvbXBhcmlzb25zID0gbiArIGsgKiAobG9nKGssIDIpICogbG9nKG4vaykgKyBsb2coaywgMikgKyBsb2cobi9rKSlcXG4jXFxuIyBDb21wdXRpbmcgdGhlIG51bWJlciBvZiBjb21wYXJpc29ucyBmb3Igc3RlcCAzOlxcbiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4jICogRm9yIHRoZSBpLXRoIG5ldyB2YWx1ZSBmcm9tIHRoZSBpdGVyYWJsZSwgdGhlIHByb2JhYmlsaXR5IG9mIGJlaW5nIGluIHRoZVxcbiMgICBrIG1vc3QgZXh0cmVtZSB2YWx1ZXMgaXMgay9pLiAgRm9yIGV4YW1wbGUsIHRoZSBwcm9iYWJpbGl0eSBvZiB0aGUgMTAxc3RcXG4jICAgdmFsdWUgc2VlbiBiZWluZyBpbiB0aGUgMTAwIG1vc3QgZXh0cmVtZSB2YWx1ZXMgaXMgMTAwLzEwMS5cXG4jICogSWYgdGhlIHZhbHVlIGlzIGEgbmV3IGV4dHJlbWUgdmFsdWUsIHRoZSBjb3N0IG9mIGluc2VydGluZyBpdCBpbnRvIHRoZVxcbiMgICBoZWFwIGlzIDEgKyBsb2coaywgMikuXFxuIyAqIFRoZSBwcm9iYWJpbGl0eSB0aW1lcyB0aGUgY29zdCBnaXZlczpcXG4jICAgICAgICAgICAgKGsvaSkgKiAoMSArIGxvZyhrLCAyKSlcXG4jICogU3VtbWluZyBhY3Jvc3MgdGhlIHJlbWFpbmluZyBuLWsgZWxlbWVudHMgZ2l2ZXM6XFxuIyAgICAgICAgICAgIHN1bSgoay9pKSAqICgxICsgbG9nKGssIDIpKSBmb3IgaSBpbiByYW5nZShrKzEsIG4rMSkpXFxuIyAqIFRoaXMgcmVkdWNlcyB0bzpcXG4jICAgICAgICAgICAgKEgobikgLSBIKGspKSAqIGsgKiAoMSArIGxvZyhrLCAyKSlcXG4jICogV2hlcmUgSChuKSBpcyB0aGUgbi10aCBoYXJtb25pYyBudW1iZXIgZXN0aW1hdGVkIGJ5OlxcbiMgICAgICAgICAgICBnYW1tYSA9IDAuNTc3MjE1NjY0OVxcbiMgICAgICAgICAgICBIKG4pID0gbG9nKG4sIGUpICsgZ2FtbWEgKyAxIC8gKDIgKiBuKVxcbiMgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhcm1vbmljX3Nlcmllc18obWF0aGVtYXRpY3MpI1JhdGVfb2ZfZGl2ZXJnZW5jZVxcbiMgKiBTdWJzdGl0dXRpbmcgdGhlIEgobikgZm9ybXVsYTpcXG4jICAgICAgICAgICAgY29tcGFyaXNvbnMgPSBrICogKDEgKyBsb2coaywgMikpICogKGxvZyhuL2ssIGUpICsgKDEvbiAtIDEvaykgLyAyKVxcbiNcXG4jIFdvcnN0LWNhc2UgZm9yIHN0ZXAgMzpcXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4jIEluIHRoZSB3b3JzdCBjYXNlLCB0aGUgaW5wdXQgZGF0YSBpcyByZXZlcnNlZCBzb3J0ZWQgc28gdGhhdCBldmVyeSBuZXcgZWxlbWVudFxcbiMgbXVzdCBiZSBpbnNlcnRlZCBpbiB0aGUgaGVhcDpcXG4jXFxuIyAgICAgICAgICAgICBjb21wYXJpc29ucyA9IDEuNjYgKiBrICsgbG9nKGssIDIpICogKG4gLSBrKVxcbiNcXG4jIEFsdGVybmF0aXZlIEFsZ29yaXRobXNcXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4jIE90aGVyIGFsZ29yaXRobXMgd2VyZSBub3QgdXNlZCBiZWNhdXNlIHRoZXk6XFxuIyAxKSBUb29rIG11Y2ggbW9yZSBhdXhpbGlhcnkgbWVtb3J5LFxcbiMgMikgTWFkZSBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZGF0YS5cXG4jIDMpIE1hZGUgbW9yZSBjb21wYXJpc29ucyBpbiBjb21tb24gY2FzZXMgKHNtYWxsIGssIGxhcmdlIG4sIHNlbWktcmFuZG9tIGlucHV0KS5cXG4jIFNlZSB0aGUgbW9yZSBkZXRhaWxlZCBjb21wYXJpc29uIG9mIGFwcHJvYWNoIGF0OlxcbiMgaHR0cDovL2NvZGUuYWN0aXZlc3RhdGUuY29tL3JlY2lwZXMvNTc3NTczLWNvbXBhcmUtYWxnb3JpdGhtcy1mb3ItaGVhcHFzbWFsbGVzdFxcblxcbmRlZiBuc21hbGxlc3QobiwgaXRlcmFibGUsIGtleT1Ob25lKTpcXG4gICAgXFxcIlxcXCJcXFwiRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXFxuXFxuICAgIEVxdWl2YWxlbnQgdG86ICBzb3J0ZWQoaXRlcmFibGUsIGtleT1rZXkpWzpuXVxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgIyBTaG9ydC1jdXQgZm9yIG49PTEgaXMgdG8gdXNlIG1pbigpXFxuICAgIGlmIG4gPT0gMTpcXG4gICAgICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgICAgIHNlbnRpbmVsID0gb2JqZWN0KClcXG4gICAgICAgIHJlc3VsdCA9IG1pbihpdCwgZGVmYXVsdD1zZW50aW5lbCwga2V5PWtleSlcXG4gICAgICAgIHJldHVybiBbXSBpZiByZXN1bHQgaXMgc2VudGluZWwgZWxzZSBbcmVzdWx0XVxcblxcbiAgICAjIFdoZW4gbj49c2l6ZSwgaXQncyBmYXN0ZXIgdG8gdXNlIHNvcnRlZCgpXFxuICAgIHRyeTpcXG4gICAgICAgIHNpemUgPSBsZW4oaXRlcmFibGUpXFxuICAgIGV4Y2VwdCAoVHlwZUVycm9yLCBBdHRyaWJ1dGVFcnJvcik6XFxuICAgICAgICBwYXNzXFxuICAgIGVsc2U6XFxuICAgICAgICBpZiBuID49IHNpemU6XFxuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZChpdGVyYWJsZSwga2V5PWtleSlbOm5dXFxuXFxuICAgICMgV2hlbiBrZXkgaXMgbm9uZSwgdXNlIHNpbXBsZXIgZGVjb3JhdGlvblxcbiAgICBpZiBrZXkgaXMgTm9uZTpcXG4gICAgICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgICAgICMgcHV0IHRoZSByYW5nZShuKSBmaXJzdCBzbyB0aGF0IHppcCgpIGRvZXNuJ3RcXG4gICAgICAgICMgY29uc3VtZSBvbmUgdG9vIG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgaXRlcmF0b3JcXG4gICAgICAgIHJlc3VsdCA9IFsoZWxlbSwgaSkgZm9yIGksIGVsZW0gaW4gemlwKHJhbmdlKG4pLCBpdCldXFxuICAgICAgICBpZiBub3QgcmVzdWx0OlxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgICAgIF9oZWFwaWZ5X21heChyZXN1bHQpXFxuICAgICAgICB0b3AgPSByZXN1bHRbMF1bMF1cXG4gICAgICAgIG9yZGVyID0gblxcbiAgICAgICAgX2hlYXByZXBsYWNlID0gX2hlYXByZXBsYWNlX21heFxcbiAgICAgICAgZm9yIGVsZW0gaW4gaXQ6XFxuICAgICAgICAgICAgaWYgZWxlbSA8IHRvcDpcXG4gICAgICAgICAgICAgICAgX2hlYXByZXBsYWNlKHJlc3VsdCwgKGVsZW0sIG9yZGVyKSlcXG4gICAgICAgICAgICAgICAgdG9wLCBfb3JkZXIgPSByZXN1bHRbMF1cXG4gICAgICAgICAgICAgICAgb3JkZXIgKz0gMVxcbiAgICAgICAgcmVzdWx0LnNvcnQoKVxcbiAgICAgICAgcmV0dXJuIFtlbGVtIGZvciAoZWxlbSwgb3JkZXIpIGluIHJlc3VsdF1cXG5cXG4gICAgIyBHZW5lcmFsIGNhc2UsIHNsb3dlc3QgbWV0aG9kXFxuICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgcmVzdWx0ID0gWyhrZXkoZWxlbSksIGksIGVsZW0pIGZvciBpLCBlbGVtIGluIHppcChyYW5nZShuKSwgaXQpXVxcbiAgICBpZiBub3QgcmVzdWx0OlxcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICBfaGVhcGlmeV9tYXgocmVzdWx0KVxcbiAgICB0b3AgPSByZXN1bHRbMF1bMF1cXG4gICAgb3JkZXIgPSBuXFxuICAgIF9oZWFwcmVwbGFjZSA9IF9oZWFwcmVwbGFjZV9tYXhcXG4gICAgZm9yIGVsZW0gaW4gaXQ6XFxuICAgICAgICBrID0ga2V5KGVsZW0pXFxuICAgICAgICBpZiBrIDwgdG9wOlxcbiAgICAgICAgICAgIF9oZWFwcmVwbGFjZShyZXN1bHQsIChrLCBvcmRlciwgZWxlbSkpXFxuICAgICAgICAgICAgdG9wLCBfb3JkZXIsIF9lbGVtID0gcmVzdWx0WzBdXFxuICAgICAgICAgICAgb3JkZXIgKz0gMVxcbiAgICByZXN1bHQuc29ydCgpXFxuICAgIHJldHVybiBbZWxlbSBmb3IgKGssIG9yZGVyLCBlbGVtKSBpbiByZXN1bHRdXFxuXFxuXFxuZGVmIG5sYXJnZXN0KG4sIGl0ZXJhYmxlLCBrZXk9Tm9uZSk6XFxuICAgIFxcXCJcXFwiXFxcIkZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXFxuXFxuICAgIEVxdWl2YWxlbnQgdG86ICBzb3J0ZWQoaXRlcmFibGUsIGtleT1rZXksIHJldmVyc2U9VHJ1ZSlbOm5dXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICAjIFNob3J0LWN1dCBmb3Igbj09MSBpcyB0byB1c2UgbWF4KClcXG4gICAgaWYgbiA9PSAxOlxcbiAgICAgICAgaXQgPSBpdGVyKGl0ZXJhYmxlKVxcbiAgICAgICAgc2VudGluZWwgPSBvYmplY3QoKVxcbiAgICAgICAgcmVzdWx0ID0gbWF4KGl0LCBkZWZhdWx0PXNlbnRpbmVsLCBrZXk9a2V5KVxcbiAgICAgICAgcmV0dXJuIFtdIGlmIHJlc3VsdCBpcyBzZW50aW5lbCBlbHNlIFtyZXN1bHRdXFxuXFxuICAgICMgV2hlbiBuPj1zaXplLCBpdCdzIGZhc3RlciB0byB1c2Ugc29ydGVkKClcXG4gICAgdHJ5OlxcbiAgICAgICAgc2l6ZSA9IGxlbihpdGVyYWJsZSlcXG4gICAgZXhjZXB0IChUeXBlRXJyb3IsIEF0dHJpYnV0ZUVycm9yKTpcXG4gICAgICAgIHBhc3NcXG4gICAgZWxzZTpcXG4gICAgICAgIGlmIG4gPj0gc2l6ZTpcXG4gICAgICAgICAgICByZXR1cm4gc29ydGVkKGl0ZXJhYmxlLCBrZXk9a2V5LCByZXZlcnNlPVRydWUpWzpuXVxcblxcbiAgICAjIFdoZW4ga2V5IGlzIG5vbmUsIHVzZSBzaW1wbGVyIGRlY29yYXRpb25cXG4gICAgaWYga2V5IGlzIE5vbmU6XFxuICAgICAgICBpdCA9IGl0ZXIoaXRlcmFibGUpXFxuICAgICAgICByZXN1bHQgPSBbKGVsZW0sIGkpIGZvciBpLCBlbGVtIGluIHppcChyYW5nZSgwLCAtbiwgLTEpLCBpdCldXFxuICAgICAgICBpZiBub3QgcmVzdWx0OlxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgICAgIGhlYXBpZnkocmVzdWx0KVxcbiAgICAgICAgdG9wID0gcmVzdWx0WzBdWzBdXFxuICAgICAgICBvcmRlciA9IC1uXFxuICAgICAgICBfaGVhcHJlcGxhY2UgPSBoZWFwcmVwbGFjZVxcbiAgICAgICAgZm9yIGVsZW0gaW4gaXQ6XFxuICAgICAgICAgICAgaWYgdG9wIDwgZWxlbTpcXG4gICAgICAgICAgICAgICAgX2hlYXByZXBsYWNlKHJlc3VsdCwgKGVsZW0sIG9yZGVyKSlcXG4gICAgICAgICAgICAgICAgdG9wLCBfb3JkZXIgPSByZXN1bHRbMF1cXG4gICAgICAgICAgICAgICAgb3JkZXIgLT0gMVxcbiAgICAgICAgcmVzdWx0LnNvcnQocmV2ZXJzZT1UcnVlKVxcbiAgICAgICAgcmV0dXJuIFtlbGVtIGZvciAoZWxlbSwgb3JkZXIpIGluIHJlc3VsdF1cXG5cXG4gICAgIyBHZW5lcmFsIGNhc2UsIHNsb3dlc3QgbWV0aG9kXFxuICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgcmVzdWx0ID0gWyhrZXkoZWxlbSksIGksIGVsZW0pIGZvciBpLCBlbGVtIGluIHppcChyYW5nZSgwLCAtbiwgLTEpLCBpdCldXFxuICAgIGlmIG5vdCByZXN1bHQ6XFxuICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgIGhlYXBpZnkocmVzdWx0KVxcbiAgICB0b3AgPSByZXN1bHRbMF1bMF1cXG4gICAgb3JkZXIgPSAtblxcbiAgICBfaGVhcHJlcGxhY2UgPSBoZWFwcmVwbGFjZVxcbiAgICBmb3IgZWxlbSBpbiBpdDpcXG4gICAgICAgIGsgPSBrZXkoZWxlbSlcXG4gICAgICAgIGlmIHRvcCA8IGs6XFxuICAgICAgICAgICAgX2hlYXByZXBsYWNlKHJlc3VsdCwgKGssIG9yZGVyLCBlbGVtKSlcXG4gICAgICAgICAgICB0b3AsIF9vcmRlciwgX2VsZW0gPSByZXN1bHRbMF1cXG4gICAgICAgICAgICBvcmRlciAtPSAxXFxuICAgIHJlc3VsdC5zb3J0KHJldmVyc2U9VHJ1ZSlcXG4gICAgcmV0dXJuIFtlbGVtIGZvciAoaywgb3JkZXIsIGVsZW0pIGluIHJlc3VsdF1cXG5cXG5cXG4jIElmIGF2YWlsYWJsZSwgdXNlIEMgaW1wbGVtZW50YXRpb25cXG50cnk6XFxuICAgIGZyb20gX2hlYXBxIGltcG9ydCAqXFxuZXhjZXB0IEltcG9ydEVycm9yOlxcbiAgICBwYXNzXFxudHJ5OlxcbiAgICBmcm9tIF9oZWFwcSBpbXBvcnQgX2hlYXByZXBsYWNlX21heFxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcbnRyeTpcXG4gICAgZnJvbSBfaGVhcHEgaW1wb3J0IF9oZWFwaWZ5X21heFxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcbnRyeTpcXG4gICAgZnJvbSBfaGVhcHEgaW1wb3J0IF9oZWFwcG9wX21heFxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcblxcblxcbmlmIF9fbmFtZV9fID09IFxcXCJfX21haW5fX1xcXCI6XFxuXFxuICAgIGltcG9ydCBkb2N0ZXN0ICAjIHByYWdtYTogbm8gY292ZXJcXG4gICAgcHJpbnQoZG9jdGVzdC50ZXN0bW9kKCkpICAjIHByYWdtYTogbm8gY292ZXJcXG5cIixcInNyYy9saWIvaG1hYy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJobWFjXFxcIilcXG5cIixcInNyYy9saWIvaG90c2hvdC9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJob3RzaG90XFxcIilcXG5cIixcInNyYy9saWIvaHRtbGVudGl0eWRlZnMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiaHRtbGVudGl0eWRlZnNcXFwiKVxcblwiLFwic3JjL2xpYi9odG1sbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImh0bWxsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9odHRwbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImh0dHBsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9pZGxlbGliL0ljb25zL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIkljb25zXFxcIilcXG5cIixcInNyYy9saWIvaWRsZWxpYi9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJpZGxlbGliXFxcIilcXG5cIixcInNyYy9saWIvaWhvb2tzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImlob29rc1xcXCIpXFxuXCIsXCJzcmMvbGliL2ltYXBsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiaW1hcGxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL2ltZ2hkci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJpbWdoZHJcXFwiKVxcblwiLFwic3JjL2xpYi9pbXB1dGlsLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImltcHV0aWxcXFwiKVxcblwiLFwic3JjL2xpYi9pby5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJpb1xcXCIpXFxuXCIsXCJzcmMvbGliL2xpYi1keW5sb2FkL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImxpYi1keW5sb2FkXFxcIilcXG5cIixcInNyYy9saWIvbGliLXRrL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcImxpYi10a1xcXCIpXFxuXCIsXCJzcmMvbGliL2xpYjJ0bzMvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibGliMnRvM1xcXCIpXFxuXCIsXCJzcmMvbGliL2xpYjJ0bzMvZml4ZXMvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZml4ZXNcXFwiKVxcblwiLFwic3JjL2xpYi9saWIydG8zL3BnZW4yL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBnZW4yXFxcIilcXG5cIixcInNyYy9saWIvbGliMnRvMy90ZXN0cy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0ZXN0c1xcXCIpXFxuXCIsXCJzcmMvbGliL2xpbmVjYWNoZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJsaW5lY2FjaGVcXFwiKVxcblwiLFwic3JjL2xpYi9sb2NhbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibG9jYWxlXFxcIilcXG5cIixcInNyYy9saWIvbG9nZ2luZy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJsb2dnaW5nXFxcIilcXG5cIixcInNyYy9saWIvbWFjcGF0aC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtYWNwYXRoXFxcIilcXG5cIixcInNyYy9saWIvbWFjdXJsMnBhdGgucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWFjdXJsMnBhdGhcXFwiKVxcblwiLFwic3JjL2xpYi9tYWlsYm94LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1haWxib3hcXFwiKVxcblwiLFwic3JjL2xpYi9tYWlsY2FwLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1haWxjYXBcXFwiKVxcblwiLFwic3JjL2xpYi9tYXJrdXBiYXNlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1hcmt1cGJhc2VcXFwiKVxcblwiLFwic3JjL2xpYi9tZDUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWQ1XFxcIilcXG5cIixcInNyYy9saWIvbWhsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWhsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9taW1ldG9vbHMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibWltZXRvb2xzXFxcIilcXG5cIixcInNyYy9saWIvbWltZXR5cGVzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm1pbWV0eXBlc1xcXCIpXFxuXCIsXCJzcmMvbGliL21pbWlmeS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtaW1pZnlcXFwiKVxcblwiLFwic3JjL2xpYi9tb2R1bGVmaW5kZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibW9kdWxlZmluZGVyXFxcIilcXG5cIixcInNyYy9saWIvbXVsdGlmaWxlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm11bHRpZmlsZVxcXCIpXFxuXCIsXCJzcmMvbGliL211bHRpcHJvY2Vzc2luZy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtdWx0aXByb2Nlc3NpbmdcXFwiKVxcblwiLFwic3JjL2xpYi9tdWx0aXByb2Nlc3NpbmcvZHVtbXkvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZHVtbXlcXFwiKVxcblwiLFwic3JjL2xpYi9tdXRleC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJtdXRleFxcXCIpXFxuXCIsXCJzcmMvbGliL25ldHJjLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm5ldHJjXFxcIilcXG5cIixcInNyYy9saWIvbmV3LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm5ld1xcXCIpXFxuXCIsXCJzcmMvbGliL25udHBsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwibm50cGxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL250cGF0aC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJudHBhdGhcXFwiKVxcblwiLFwic3JjL2xpYi9udHVybDJwYXRoLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm50dXJsMnBhdGhcXFwiKVxcblwiLFwic3JjL2xpYi9udW1iZXJzLnB5XCI6XCJOdW1iZXIgPSAoaW50LCBmbG9hdCwgY29tcGxleClcXG5JbnRlZ3JhbCA9IGludFxcbkNvbXBsZXggPSBjb21wbGV4XFxuXCIsXCJzcmMvbGliL29wY29kZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJvcGNvZGVcXFwiKVxcblwiLFwic3JjL2xpYi9vcHRwYXJzZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJvcHRwYXJzZVxcXCIpXFxuXCIsXCJzcmMvbGliL29zLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcIm9zXFxcIilcXG5cIixcInNyYy9saWIvb3MyZW14cGF0aC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJvczJlbXhwYXRoXFxcIilcXG5cIixcInNyYy9saWIvcGRiLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBkYlxcXCIpXFxuXCIsXCJzcmMvbGliL3BpY2tsZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwaWNrbGVcXFwiKVxcblwiLFwic3JjL2xpYi9waWNrbGV0b29scy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwaWNrbGV0b29sc1xcXCIpXFxuXCIsXCJzcmMvbGliL3BpcGVzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBpcGVzXFxcIilcXG5cIixcInNyYy9saWIvcGtndXRpbC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwa2d1dGlsXFxcIilcXG5cIixcInNyYy9saWIvcGxhdGZvcm0ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicGxhdGZvcm1cXFwiKVxcblwiLFwic3JjL2xpYi9wbGlzdGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwbGlzdGxpYlxcXCIpXFxuXCIsXCJzcmMvbGliL3BvcGVuMi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwb3BlbjJcXFwiKVxcblwiLFwic3JjL2xpYi9wb3BsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicG9wbGliXFxcIilcXG5cIixcInNyYy9saWIvcG9zaXhmaWxlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBvc2l4ZmlsZVxcXCIpXFxuXCIsXCJzcmMvbGliL3Bvc2l4cGF0aC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwb3NpeHBhdGhcXFwiKVxcblwiLFwic3JjL2xpYi9wcHJpbnQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicHByaW50XFxcIilcXG5cIixcInNyYy9saWIvcHJvZmlsZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwcm9maWxlXFxcIilcXG5cIixcInNyYy9saWIvcHN0YXRzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInBzdGF0c1xcXCIpXFxuXCIsXCJzcmMvbGliL3B0eS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwdHlcXFwiKVxcblwiLFwic3JjL2xpYi9weV9jb21waWxlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInB5X2NvbXBpbGVcXFwiKVxcblwiLFwic3JjL2xpYi9weWNsYnIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicHljbGJyXFxcIilcXG5cIixcInNyYy9saWIvcHlkb2MucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicHlkb2NcXFwiKVxcblwiLFwic3JjL2xpYi9weWRvY190b3BpY3MucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicHlkb2NfdG9waWNzXFxcIilcXG5cIixcInNyYy9saWIvcHl0aG9uZHMvX19pbml0X18ucHlcIjpcIlwiLFwic3JjL2xpYi9weXRob25kcy9iYXNpYy9fX2luaXRfXy5weVwiOlwiXFxuI19fYWxsX18gPSBbXFxcInN0YWNrXFxcIl1cXG5cXG5cXG5mcm9tIC5zdGFjayBpbXBvcnQgU3RhY2tcXG5mcm9tIC5xdWV1ZSBpbXBvcnQgUXVldWVcXG5mcm9tIC5kZXF1ZSBpbXBvcnQgRGVxdWVcXG5cXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZHMvYmFzaWMvZGVxdWUucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBJbnRyb2R1Y3Rpb24gdG8gRGF0YSBTdHJ1Y3R1cmVzIGFuZCBBbGdvcml0aG1zIGluIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMDVcXG4jXFxuIyBkZXF1ZS5weVxcblxcblxcbmNsYXNzIERlcXVlOlxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLml0ZW1zID0gW11cXG5cXG4gICAgZGVmIGlzRW1wdHkoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgYWRkRnJvbnQoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmFwcGVuZChpdGVtKVxcblxcbiAgICBkZWYgYWRkUmVhcihzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuaW5zZXJ0KDAsIGl0ZW0pXFxuXFxuICAgIGRlZiByZW1vdmVGcm9udChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiByZW1vdmVSZWFyKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKDApXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25kcy9iYXNpYy9xdWV1ZS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiNcXG4jIHF1ZXVlLnB5XFxuXFxuXFxuY2xhc3MgUXVldWU6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNFbXB0eShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zID09IFtdXFxuXFxuICAgIGRlZiBlbnF1ZXVlKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgc2VsZi5pdGVtcy5pbnNlcnQoMCwgaXRlbSlcXG5cXG4gICAgZGVmIGRlcXVldWUoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZHMvYmFzaWMvc3RhY2sucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBJbnRyb2R1Y3Rpb24gdG8gRGF0YSBTdHJ1Y3R1cmVzIGFuZCBBbGdvcml0aG1zIGluIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMDVcXG4jXFxuIyBzdGFjay5weVxcblxcblxcbmNsYXNzIFN0YWNrOlxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLml0ZW1zID0gW11cXG5cXG4gICAgZGVmIGlzRW1wdHkoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgcHVzaChzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuYXBwZW5kKGl0ZW0pXFxuXFxuICAgIGRlZiBwb3Aoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgcGVlayhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zW2xlbihzZWxmLml0ZW1zKSAtIDFdXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25kcy9ncmFwaHMvX19pbml0X18ucHlcIjpcIlxcblxcbmZyb20gLmFkakdyYXBoIGltcG9ydCBHcmFwaFxcbmZyb20gLmFkakdyYXBoIGltcG9ydCBWZXJ0ZXhcXG5mcm9tIC5wcmlvcml0eVF1ZXVlIGltcG9ydCBQcmlvcml0eVF1ZXVlXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL2dyYXBocy9hZGpHcmFwaC5weVwiOlwiI1xcbiMgIGFkakdyYXBoXFxuI1xcbiMgIENyZWF0ZWQgYnkgQnJhZCBNaWxsZXIgb24gMjAwNS0wMi0yNC5cXG4jICBDb3B5cmlnaHQgKGMpIDIwMDUgQnJhZCBNaWxsZXIsIERhdmlkIFJhbnVtLCBMdXRoZXIgQ29sbGVnZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4jXFxuXFxuaW1wb3J0IHN5c1xcbmltcG9ydCBvc1xcbmltcG9ydCB1bml0dGVzdFxcblxcbmNsYXNzIEdyYXBoOlxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLnZlcnRpY2VzID0ge31cXG4gICAgICAgIHNlbGYubnVtVmVydGljZXMgPSAwXFxuICAgICAgICBcXG4gICAgZGVmIGFkZFZlcnRleChzZWxmLGtleSk6XFxuICAgICAgICBzZWxmLm51bVZlcnRpY2VzID0gc2VsZi5udW1WZXJ0aWNlcyArIDFcXG4gICAgICAgIG5ld1ZlcnRleCA9IFZlcnRleChrZXkpXFxuICAgICAgICBzZWxmLnZlcnRpY2VzW2tleV0gPSBuZXdWZXJ0ZXhcXG4gICAgICAgIHJldHVybiBuZXdWZXJ0ZXhcXG4gICAgXFxuICAgIGRlZiBnZXRWZXJ0ZXgoc2VsZixuKTpcXG4gICAgICAgIGlmIG4gaW4gc2VsZi52ZXJ0aWNlczpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi52ZXJ0aWNlc1tuXVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsbik6XFxuICAgICAgICByZXR1cm4gbiBpbiBzZWxmLnZlcnRpY2VzXFxuICAgIFxcbiAgICBkZWYgYWRkRWRnZShzZWxmLGYsdCxjb3N0PTApOlxcbiAgICAgICAgICAgIGlmIGYgbm90IGluIHNlbGYudmVydGljZXM6XFxuICAgICAgICAgICAgICAgIG52ID0gc2VsZi5hZGRWZXJ0ZXgoZilcXG4gICAgICAgICAgICBpZiB0IG5vdCBpbiBzZWxmLnZlcnRpY2VzOlxcbiAgICAgICAgICAgICAgICBudiA9IHNlbGYuYWRkVmVydGV4KHQpXFxuICAgICAgICAgICAgc2VsZi52ZXJ0aWNlc1tmXS5hZGROZWlnaGJvcihzZWxmLnZlcnRpY2VzW3RdLGNvc3QpXFxuICAgIFxcbiAgICBkZWYgZ2V0VmVydGljZXMoc2VsZik6XFxuICAgICAgICByZXR1cm4gbGlzdChzZWxmLnZlcnRpY2VzLmtleXMoKSlcXG4gICAgICAgIFxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gaXRlcihzZWxmLnZlcnRpY2VzLnZhbHVlcygpKVxcbiAgICAgICAgICAgICAgICBcXG5jbGFzcyBWZXJ0ZXg6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLG51bSk6XFxuICAgICAgICBzZWxmLmlkID0gbnVtXFxuICAgICAgICBzZWxmLmNvbm5lY3RlZFRvID0ge31cXG4gICAgICAgIHNlbGYuY29sb3IgPSAnd2hpdGUnXFxuICAgICAgICBzZWxmLmRpc3QgPSBzeXMubWF4c2l6ZVxcbiAgICAgICAgc2VsZi5wcmVkID0gTm9uZVxcbiAgICAgICAgc2VsZi5kaXNjID0gMFxcbiAgICAgICAgc2VsZi5maW4gPSAwXFxuXFxuICAgICMgZGVmIF9fbHRfXyhzZWxmLG8pOlxcbiAgICAjICAgICByZXR1cm4gc2VsZi5pZCA8IG8uaWRcXG4gICAgXFxuICAgIGRlZiBhZGROZWlnaGJvcihzZWxmLG5icix3ZWlnaHQ9MCk6XFxuICAgICAgICBzZWxmLmNvbm5lY3RlZFRvW25icl0gPSB3ZWlnaHRcXG4gICAgICAgIFxcbiAgICBkZWYgc2V0Q29sb3Ioc2VsZixjb2xvcik6XFxuICAgICAgICBzZWxmLmNvbG9yID0gY29sb3JcXG4gICAgICAgIFxcbiAgICBkZWYgc2V0RGlzdGFuY2Uoc2VsZixkKTpcXG4gICAgICAgIHNlbGYuZGlzdCA9IGRcXG5cXG4gICAgZGVmIHNldFByZWQoc2VsZixwKTpcXG4gICAgICAgIHNlbGYucHJlZCA9IHBcXG5cXG4gICAgZGVmIHNldERpc2NvdmVyeShzZWxmLGR0aW1lKTpcXG4gICAgICAgIHNlbGYuZGlzYyA9IGR0aW1lXFxuICAgICAgICBcXG4gICAgZGVmIHNldEZpbmlzaChzZWxmLGZ0aW1lKTpcXG4gICAgICAgIHNlbGYuZmluID0gZnRpbWVcXG4gICAgICAgIFxcbiAgICBkZWYgZ2V0RmluaXNoKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZmluXFxuICAgICAgICBcXG4gICAgZGVmIGdldERpc2NvdmVyeShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmRpc2NcXG4gICAgICAgIFxcbiAgICBkZWYgZ2V0UHJlZChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnByZWRcXG4gICAgICAgIFxcbiAgICBkZWYgZ2V0RGlzdGFuY2Uoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5kaXN0XFxuICAgICAgICBcXG4gICAgZGVmIGdldENvbG9yKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuY29sb3JcXG4gICAgXFxuICAgIGRlZiBnZXRDb25uZWN0aW9ucyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmNvbm5lY3RlZFRvLmtleXMoKVxcbiAgICAgICAgXFxuICAgIGRlZiBnZXRXZWlnaHQoc2VsZixuYnIpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuY29ubmVjdGVkVG9bbmJyXVxcbiAgICAgICAgICAgICAgICBcXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc3RyKHNlbGYuaWQpICsgXFxcIjpjb2xvciBcXFwiICsgc2VsZi5jb2xvciArIFxcXCI6ZGlzYyBcXFwiICsgc3RyKHNlbGYuZGlzYykgKyBcXFwiOmZpbiBcXFwiICsgc3RyKHNlbGYuZmluKSArIFxcXCI6ZGlzdCBcXFwiICsgc3RyKHNlbGYuZGlzdCkgKyBcXFwiOnByZWQgXFxcXG5cXFxcdFtcXFwiICsgc3RyKHNlbGYucHJlZCkrIFxcXCJdXFxcXG5cXFwiXFxuICAgIFxcbiAgICBkZWYgZ2V0SWQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pZFxcblxcbmNsYXNzIGFkakdyYXBoVGVzdHModW5pdHRlc3QuVGVzdENhc2UpOlxcbiAgICBkZWYgc2V0VXAoc2VsZik6XFxuICAgICAgICBzZWxmLnRHcmFwaCA9IEdyYXBoKClcXG4gICAgICAgIFxcbiAgICBkZWYgdGVzdE1ha2VHcmFwaChzZWxmKTpcXG4gICAgICAgIGdGaWxlID0gb3BlbihcXFwidGVzdC5kYXRcXFwiKVxcbiAgICAgICAgZm9yIGxpbmUgaW4gZ0ZpbGU6XFxuICAgICAgICAgICAgZlZlcnRleCwgdFZlcnRleCA9IGxpbmUuc3BsaXQoJ3wnKVxcbiAgICAgICAgICAgIGZWZXJ0ZXggPSBpbnQoZlZlcnRleClcXG4gICAgICAgICAgICB0VmVydGV4ID0gaW50KHRWZXJ0ZXgpXFxuICAgICAgICAgICAgc2VsZi50R3JhcGguYWRkRWRnZShmVmVydGV4LHRWZXJ0ZXgpXFxuICAgICAgICBmb3IgaSBpbiBzZWxmLnRHcmFwaDpcXG4gICAgICAgICAgICBhZGogPSBpLmdldEFkaigpXFxuICAgICAgICAgICAgZm9yIGsgaW4gYWRqOlxcbiAgICAgICAgICAgICAgICBwcmludChpLCBrKVxcblxcbiAgICAgICAgXFxuaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzpcXG4gICAgdW5pdHRlc3QubWFpbigpXFxuICAgICAgICAgICAgICBcXG5cIixcInNyYy9saWIvcHl0aG9uZHMvZ3JhcGhzL3ByaW9yaXR5UXVldWUucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBJbnRyb2R1Y3Rpb24gdG8gRGF0YSBTdHJ1Y3R1cmVzIGFuZCBBbGdvcml0aG1zIGluIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMDVcXG4jIFxcbmltcG9ydCB1bml0dGVzdFxcblxcbiMgdGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgaGVhcCB0YWtlcyBrZXkgdmFsdWUgcGFpcnMsXFxuIyB3ZSB3aWxsIGFzc3VtZSB0aGF0IHRoZSBrZXlzIGFyZSBhbGwgY29tcGFyYWJsZVxcblxcbmNsYXNzIFByaW9yaXR5UXVldWU6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaGVhcEFycmF5ID0gWygwLDApXVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IDBcXG5cXG4gICAgZGVmIGJ1aWxkSGVhcChzZWxmLGFsaXN0KTpcXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSBsZW4oYWxpc3QpXFxuICAgICAgICBzZWxmLmhlYXBBcnJheSA9IFsoMCwwKV1cXG4gICAgICAgIGZvciBpIGluIGFsaXN0OlxcbiAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5LmFwcGVuZChpKVxcbiAgICAgICAgaSA9IGxlbihhbGlzdCkgLy8gMiAgICAgICAgICAgIFxcbiAgICAgICAgd2hpbGUgKGkgPiAwKTpcXG4gICAgICAgICAgICBzZWxmLnBlcmNEb3duKGkpXFxuICAgICAgICAgICAgaSA9IGkgLSAxXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgIGRlZiBwZXJjRG93bihzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgKGkgKiAyKSA8PSBzZWxmLmN1cnJlbnRTaXplOlxcbiAgICAgICAgICAgIG1jID0gc2VsZi5taW5DaGlsZChpKVxcbiAgICAgICAgICAgIGlmIHNlbGYuaGVhcEFycmF5W2ldWzBdID4gc2VsZi5oZWFwQXJyYXlbbWNdWzBdOlxcbiAgICAgICAgICAgICAgICB0bXAgPSBzZWxmLmhlYXBBcnJheVtpXVxcbiAgICAgICAgICAgICAgICBzZWxmLmhlYXBBcnJheVtpXSA9IHNlbGYuaGVhcEFycmF5W21jXVxcbiAgICAgICAgICAgICAgICBzZWxmLmhlYXBBcnJheVttY10gPSB0bXBcXG4gICAgICAgICAgICBpID0gbWNcXG4gICAgICAgICAgICAgICAgXFxuICAgIGRlZiBtaW5DaGlsZChzZWxmLGkpOlxcbiAgICAgICAgaWYgaSoyID4gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICByZXR1cm4gLTFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgaSoyICsgMSA+IHNlbGYuY3VycmVudFNpemU6XFxuICAgICAgICAgICAgICAgIHJldHVybiBpKjJcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmhlYXBBcnJheVtpKjJdWzBdIDwgc2VsZi5oZWFwQXJyYXlbaSoyKzFdWzBdOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkqMlxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkqMisxXFxuXFxuICAgIGRlZiBwZXJjVXAoc2VsZixpKTpcXG4gICAgICAgIHdoaWxlIGkgLy8gMiA+IDA6XFxuICAgICAgICAgICAgaWYgc2VsZi5oZWFwQXJyYXlbaV1bMF0gPCBzZWxmLmhlYXBBcnJheVtpLy8yXVswXTpcXG4gICAgICAgICAgICAgICB0bXAgPSBzZWxmLmhlYXBBcnJheVtpLy8yXVxcbiAgICAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W2kvLzJdID0gc2VsZi5oZWFwQXJyYXlbaV1cXG4gICAgICAgICAgICAgICBzZWxmLmhlYXBBcnJheVtpXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBpLy8yXFxuIFxcbiAgICBkZWYgYWRkKHNlbGYsayk6XFxuICAgICAgICBzZWxmLmhlYXBBcnJheS5hcHBlbmQoaylcXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSBzZWxmLmN1cnJlbnRTaXplICsgMVxcbiAgICAgICAgc2VsZi5wZXJjVXAoc2VsZi5jdXJyZW50U2l6ZSlcXG5cXG4gICAgZGVmIGRlbE1pbihzZWxmKTpcXG4gICAgICAgIHJldHZhbCA9IHNlbGYuaGVhcEFycmF5WzFdWzFdXFxuICAgICAgICBzZWxmLmhlYXBBcnJheVsxXSA9IHNlbGYuaGVhcEFycmF5W3NlbGYuY3VycmVudFNpemVdXFxuICAgICAgICBzZWxmLmN1cnJlbnRTaXplID0gc2VsZi5jdXJyZW50U2l6ZSAtIDFcXG4gICAgICAgIHNlbGYuaGVhcEFycmF5LnBvcCgpXFxuICAgICAgICBzZWxmLnBlcmNEb3duKDEpXFxuICAgICAgICByZXR1cm4gcmV0dmFsXFxuICAgICAgICBcXG4gICAgZGVmIGlzRW1wdHkoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmN1cnJlbnRTaXplID09IDA6XFxuICAgICAgICAgICAgcmV0dXJuIFRydWVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuXFxuICAgIGRlZiBkZWNyZWFzZUtleShzZWxmLHZhbCxhbXQpOlxcbiAgICAgICAgIyB0aGlzIGlzIGEgbGl0dGxlIHdpZXJkLCBidXQgd2UgbmVlZCB0byBmaW5kIHRoZSBoZWFwIHRoaW5nIHRvIGRlY3JlYXNlIGJ5XFxuICAgICAgICAjIGxvb2tpbmcgYXQgaXRzIHZhbHVlXFxuICAgICAgICBkb25lID0gRmFsc2VcXG4gICAgICAgIGkgPSAxXFxuICAgICAgICBteUtleSA9IDBcXG4gICAgICAgIHdoaWxlIG5vdCBkb25lIGFuZCBpIDw9IHNlbGYuY3VycmVudFNpemU6XFxuICAgICAgICAgICAgaWYgc2VsZi5oZWFwQXJyYXlbaV1bMV0gPT0gdmFsOlxcbiAgICAgICAgICAgICAgICBkb25lID0gVHJ1ZVxcbiAgICAgICAgICAgICAgICBteUtleSA9IGlcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpID0gaSArIDFcXG4gICAgICAgIGlmIG15S2V5ID4gMDpcXG4gICAgICAgICAgICBzZWxmLmhlYXBBcnJheVtteUtleV0gPSAoYW10LHNlbGYuaGVhcEFycmF5W215S2V5XVsxXSlcXG4gICAgICAgICAgICBzZWxmLnBlcmNVcChteUtleSlcXG4gICAgICAgICAgICBcXG4gICAgZGVmIF9fY29udGFpbnNfXyhzZWxmLHZ0eCk6XFxuICAgICAgICBmb3IgcGFpciBpbiBzZWxmLmhlYXBBcnJheTpcXG4gICAgICAgICAgICBpZiBwYWlyWzFdID09IHZ0eDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcXG4gICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgXFxuY2xhc3MgVGVzdEJpbkhlYXAodW5pdHRlc3QuVGVzdENhc2UpOlxcbiAgICBkZWYgc2V0VXAoc2VsZik6XFxuICAgICAgICBzZWxmLnRoZUhlYXAgPSBQcmlvcml0eVF1ZXVlKClcXG4gICAgICAgIHNlbGYudGhlSGVhcC5hZGQoKDIsJ3gnKSlcXG4gICAgICAgIHNlbGYudGhlSGVhcC5hZGQoKDMsJ3knKSlcXG4gICAgICAgIHNlbGYudGhlSGVhcC5hZGQoKDUsJ3onKSlcXG4gICAgICAgIHNlbGYudGhlSGVhcC5hZGQoKDYsJ2EnKSlcXG4gICAgICAgIHNlbGYudGhlSGVhcC5hZGQoKDQsJ2QnKSlcXG5cXG5cXG4gICAgZGVmIHRlc3RJbnNlcnQoc2VsZik6XFxuICAgICAgICBhc3NlcnQgc2VsZi50aGVIZWFwLmN1cnJlbnRTaXplID09IDVcXG5cXG4gICAgZGVmIHRlc3REZWxtaW4oc2VsZik6XFxuICAgICAgICBhc3NlcnQgc2VsZi50aGVIZWFwLmRlbE1pbigpID09ICd4J1xcbiAgICAgICAgYXNzZXJ0IHNlbGYudGhlSGVhcC5kZWxNaW4oKSA9PSAneSdcXG4gICAgXFxuICAgIGRlZiB0ZXN0RGVjS2V5KHNlbGYpOlxcbiAgICAgICAgc2VsZi50aGVIZWFwLmRlY3JlYXNlS2V5KCdkJywxKVxcbiAgICAgICAgYXNzZXJ0IHNlbGYudGhlSGVhcC5kZWxNaW4oKSA9PSAnZCdcXG4gICAgICAgIFxcbmlmIF9fbmFtZV9fID09ICdfX21haW5fXyc6XFxuICAgIHVuaXR0ZXN0Lm1haW4oKVxcblwiLFwic3JjL2xpYi9weXRob25kcy90cmVlcy9fX2luaXRfXy5weVwiOlwiXFxuZnJvbSAuYmluYXJ5VHJlZSBpbXBvcnQgQmluYXJ5VHJlZVxcbmZyb20gLmJhbGFuY2UgaW1wb3J0IEFWTFRyZWVcXG5mcm9tIC5ic3QgaW1wb3J0IEJpbmFyeVNlYXJjaFRyZWVcXG5mcm9tIC5iaW5oZWFwIGltcG9ydCBCaW5IZWFwXFxuXFxuXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL3RyZWVzL2JhbGFuY2UucHlcIjpcIiMhL2Jpbi9lbnYgcHl0aG9uMy4xXFxuIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNSwgMjAxMFxcbiMgXFxuXFxuZnJvbSAuYnN0IGltcG9ydCBCaW5hcnlTZWFyY2hUcmVlLCBUcmVlTm9kZVxcblxcbmNsYXNzIEFWTFRyZWUoQmluYXJ5U2VhcmNoVHJlZSk6XFxuICAgICcnJ1xcbiAgICBBdXRob3I6ICBCcmFkIE1pbGxlclxcbiAgICBEYXRlOiAgMS8xNS8yMDA1XFxuICAgIERlc2NyaXB0aW9uOiAgSW1sZW1lbnQgYSBiaW5hcnkgc2VhcmNoIHRyZWUgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyZmFjZVxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uczogIFxcbiAgICAgICAgICAgICAgICAgIF9fY29udGFpbnNfXyh5KSA8PT0+IHkgaW4geFxcbiAgICAgICAgICAgICAgICAgIF9fZ2V0aXRlbV9fKHkpIDw9PT4geFt5XVxcbiAgICAgICAgICAgICAgICAgIF9faW5pdF9fKClcXG4gICAgICAgICAgICAgICAgICBfX2xlbl9fKCkgPD09PiBsZW4oeClcXG4gICAgICAgICAgICAgICAgICBfX3NldGl0ZW1fXyhrLHYpIDw9PT4geFtrXSA9IHZcXG4gICAgICAgICAgICAgICAgICBjbGVhcigpXFxuICAgICAgICAgICAgICAgICAgZ2V0KGspXFxuICAgICAgICAgICAgICAgICAgaGFzX2tleShrKVxcbiAgICAgICAgICAgICAgICAgIGl0ZW1zKCkgXFxuICAgICAgICAgICAgICAgICAga2V5cygpIFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlcygpXFxuICAgICAgICAgICAgICAgICAgcHV0KGssdilcXG4gICAgJycnXFxuXFxuXFxuICAgIGRlZiBfcHV0KHNlbGYsa2V5LHZhbCxjdXJyZW50Tm9kZSk6XFxuICAgICAgICBpZiBrZXkgPCBjdXJyZW50Tm9kZS5rZXk6XFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksdmFsLGN1cnJlbnROb2RlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQgPSBUcmVlTm9kZShrZXksdmFsLHBhcmVudD1jdXJyZW50Tm9kZSlcXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVCYWxhbmNlKGN1cnJlbnROb2RlLmxlZnRDaGlsZClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wdXQoa2V5LHZhbCxjdXJyZW50Tm9kZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQgPSBUcmVlTm9kZShrZXksdmFsLHBhcmVudD1jdXJyZW50Tm9kZSlcXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVCYWxhbmNlKGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQpICAgICAgICAgICAgICAgIFxcblxcbiAgICBkZWYgdXBkYXRlQmFsYW5jZShzZWxmLG5vZGUpOlxcbiAgICAgICAgaWYgbm9kZS5iYWxhbmNlRmFjdG9yID4gMSBvciBub2RlLmJhbGFuY2VGYWN0b3IgPCAtMTpcXG4gICAgICAgICAgICBzZWxmLnJlYmFsYW5jZShub2RlKVxcbiAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgaWYgbm9kZS5wYXJlbnQgIT0gTm9uZTpcXG4gICAgICAgICAgICBpZiBub2RlLmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmJhbGFuY2VGYWN0b3IgKz0gMVxcbiAgICAgICAgICAgIGVsaWYgbm9kZS5pc1JpZ2h0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuYmFsYW5jZUZhY3RvciAtPSAxXFxuXFxuICAgICAgICAgICAgaWYgbm9kZS5wYXJlbnQuYmFsYW5jZUZhY3RvciAhPSAwOlxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUJhbGFuY2Uobm9kZS5wYXJlbnQpXFxuXFxuICAgIGRlZiByZWJhbGFuY2Uoc2VsZixub2RlKTpcXG4gICAgICAgIGlmIG5vZGUuYmFsYW5jZUZhY3RvciA8IDA6XFxuICAgICAgICAgICAgaWYgbm9kZS5yaWdodENoaWxkLmJhbGFuY2VGYWN0b3IgPiAwOlxcbiAgICAgICAgICAgICAgICAjIERvIGFuIExSIFJvdGF0aW9uXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlUmlnaHQobm9kZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZUxlZnQobm9kZSlcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAjIHNpbmdsZSBsZWZ0XFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlTGVmdChub2RlKVxcbiAgICAgICAgZWxpZiBub2RlLmJhbGFuY2VGYWN0b3IgPiAwOlxcbiAgICAgICAgICAgIGlmIG5vZGUubGVmdENoaWxkLmJhbGFuY2VGYWN0b3IgPCAwOlxcbiAgICAgICAgICAgICAgICAjIERvIGFuIFJMIFJvdGF0aW9uXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlTGVmdChub2RlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVSaWdodChub2RlKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICMgc2luZ2xlIHJpZ2h0XFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlUmlnaHQobm9kZSlcXG5cXG4gICAgZGVmIHJvdGF0ZUxlZnQoc2VsZixyb3RSb290KTpcXG4gICAgICAgIG5ld1Jvb3QgPSByb3RSb290LnJpZ2h0Q2hpbGRcXG4gICAgICAgIHJvdFJvb3QucmlnaHRDaGlsZCA9IG5ld1Jvb3QubGVmdENoaWxkXFxuICAgICAgICBpZiBuZXdSb290LmxlZnRDaGlsZCAhPSBOb25lOlxcbiAgICAgICAgICAgIG5ld1Jvb3QubGVmdENoaWxkLnBhcmVudCA9IHJvdFJvb3RcXG4gICAgICAgIG5ld1Jvb3QucGFyZW50ID0gcm90Um9vdC5wYXJlbnRcXG4gICAgICAgIGlmIHJvdFJvb3QuaXNSb290KCk6XFxuICAgICAgICAgICAgc2VsZi5yb290ID0gbmV3Um9vdFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiByb3RSb290LmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHJvdFJvb3QucGFyZW50LmxlZnRDaGlsZCA9IG5ld1Jvb3RcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByb3RSb290LnBhcmVudC5yaWdodENoaWxkID0gbmV3Um9vdFxcbiAgICAgICAgbmV3Um9vdC5sZWZ0Q2hpbGQgPSByb3RSb290XFxuICAgICAgICByb3RSb290LnBhcmVudCA9IG5ld1Jvb3RcXG4gICAgICAgIHJvdFJvb3QuYmFsYW5jZUZhY3RvciA9IHJvdFJvb3QuYmFsYW5jZUZhY3RvciArIDEgLSBtaW4obmV3Um9vdC5iYWxhbmNlRmFjdG9yLCAwKVxcbiAgICAgICAgbmV3Um9vdC5iYWxhbmNlRmFjdG9yID0gbmV3Um9vdC5iYWxhbmNlRmFjdG9yICsgMSArIG1heChyb3RSb290LmJhbGFuY2VGYWN0b3IsIDApXFxuXFxuXFxuICAgIGRlZiByb3RhdGVSaWdodChzZWxmLHJvdFJvb3QpOlxcbiAgICAgICAgbmV3Um9vdCA9IHJvdFJvb3QubGVmdENoaWxkXFxuICAgICAgICByb3RSb290LmxlZnRDaGlsZCA9IG5ld1Jvb3QucmlnaHRDaGlsZFxcbiAgICAgICAgaWYgbmV3Um9vdC5yaWdodENoaWxkICE9IE5vbmU6XFxuICAgICAgICAgICAgbmV3Um9vdC5yaWdodENoaWxkLnBhcmVudCA9IHJvdFJvb3RcXG4gICAgICAgIG5ld1Jvb3QucGFyZW50ID0gcm90Um9vdC5wYXJlbnRcXG4gICAgICAgIGlmIHJvdFJvb3QuaXNSb290KCk6XFxuICAgICAgICAgICAgc2VsZi5yb290ID0gbmV3Um9vdFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiByb3RSb290LmlzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICByb3RSb290LnBhcmVudC5yaWdodENoaWxkID0gbmV3Um9vdFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJvdFJvb3QucGFyZW50LmxlZnRDaGlsZCA9IG5ld1Jvb3RcXG4gICAgICAgIG5ld1Jvb3QucmlnaHRDaGlsZCA9IHJvdFJvb3RcXG4gICAgICAgIHJvdFJvb3QucGFyZW50ID0gbmV3Um9vdFxcbiAgICAgICAgcm90Um9vdC5iYWxhbmNlRmFjdG9yID0gcm90Um9vdC5iYWxhbmNlRmFjdG9yIC0gMSAtIG1heChuZXdSb290LmJhbGFuY2VGYWN0b3IsIDApXFxuICAgICAgICBuZXdSb290LmJhbGFuY2VGYWN0b3IgPSBuZXdSb290LmJhbGFuY2VGYWN0b3IgLSAxICsgbWluKHJvdFJvb3QuYmFsYW5jZUZhY3RvciwgMClcXG4gICAgICAgIFxcblwiLFwic3JjL2xpYi9weXRob25kcy90cmVlcy9iaW5hcnlUcmVlLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgSW50cm9kdWN0aW9uIHRvIERhdGEgU3RydWN0dXJlcyBhbmQgQWxnb3JpdGhtcyBpbiBQeXRob25cXG4jIENvcHlyaWdodCAyMDA1XFxuIyBcXG5cXG5jbGFzcyBCaW5hcnlUcmVlOlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgQSByZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgQmluYXJ5IFRyZWVcXG4gICAgVXNpbmcgbGlua3MgYW5kIE5vZGVzIGFwcHJvYWNoLlxcbiAgICBcXFwiXFxcIlxcXCIgICAgXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLHJvb3RPYmopOlxcbiAgICAgICAgc2VsZi5rZXkgPSByb290T2JqXFxuICAgICAgICBzZWxmLmxlZnRDaGlsZCA9IE5vbmVcXG4gICAgICAgIHNlbGYucmlnaHRDaGlsZCA9IE5vbmVcXG5cXG4gICAgZGVmIGluc2VydExlZnQoc2VsZixuZXdOb2RlKTpcXG4gICAgICAgIGlmIHNlbGYubGVmdENoaWxkID09IE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQgPSBCaW5hcnlUcmVlKG5ld05vZGUpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHQgPSBCaW5hcnlUcmVlKG5ld05vZGUpXFxuICAgICAgICAgICAgdC5sZWZ0ID0gc2VsZi5sZWZ0Q2hpbGRcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZCA9IHRcXG4gICAgXFxuICAgIGRlZiBpbnNlcnRSaWdodChzZWxmLG5ld05vZGUpOlxcbiAgICAgICAgaWYgc2VsZi5yaWdodENoaWxkID09IE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5yaWdodENoaWxkID0gQmluYXJ5VHJlZShuZXdOb2RlKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICB0ID0gQmluYXJ5VHJlZShuZXdOb2RlKVxcbiAgICAgICAgICAgIHQucmlnaHQgPSBzZWxmLnJpZ2h0Q2hpbGRcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQgPSB0XFxuXFxuICAgIGRlZiBpc0xlYWYoc2VsZik6XFxuICAgICAgICByZXR1cm4gKChub3Qgc2VsZi5sZWZ0Q2hpbGQpIGFuZCAobm90IHNlbGYucmlnaHRDaGlsZCkpXFxuXFxuICAgIGRlZiBnZXRSaWdodENoaWxkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucmlnaHRDaGlsZFxcblxcbiAgICBkZWYgZ2V0TGVmdENoaWxkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYubGVmdENoaWxkXFxuXFxuICAgIGRlZiBzZXRSb290VmFsKHNlbGYsb2JqKTpcXG4gICAgICAgIHNlbGYua2V5ID0gb2JqXFxuXFxuICAgIGRlZiBnZXRSb290VmFsKHNlbGYsKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmtleVxcblxcbiAgICBkZWYgaW5vcmRlcihzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYubGVmdENoaWxkOlxcbiAgICAgICAgICAgIHNlbGYubGVmdENoaWxkLmlub3JkZXIoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5rZXkpXFxuICAgICAgICBpZiBzZWxmLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICAgICAgc2VsZi5yaWdodENoaWxkLmlub3JkZXIoKVxcblxcbiAgICBkZWYgcG9zdG9yZGVyKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQucG9zdG9yZGVyKClcXG4gICAgICAgIGlmIHNlbGYucmlnaHRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQucG9zdG9yZGVyKClcXG4gICAgICAgIHByaW50KHNlbGYua2V5KVxcblxcblxcbiAgICBkZWYgcHJlb3JkZXIoc2VsZik6XFxuICAgICAgICBwcmludChzZWxmLmtleSlcXG4gICAgICAgIGlmIHNlbGYubGVmdENoaWxkOlxcbiAgICAgICAgICAgIHNlbGYubGVmdENoaWxkLnByZW9yZGVyKClcXG4gICAgICAgIGlmIHNlbGYucmlnaHRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQucHJlb3JkZXIoKVxcblxcbiAgICBkZWYgcHJpbnRleHAoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmxlZnRDaGlsZDpcXG4gICAgICAgICAgICBwcmludCgnKCcpXFxuICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQucHJpbnRleHAoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5rZXkpXFxuICAgICAgICBpZiBzZWxmLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICAgICAgc2VsZi5yaWdodENoaWxkLnByaW50ZXhwKClcXG4gICAgICAgICAgICBwcmludCgnKScpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXJldmFsKHNlbGYpOlxcbiAgICAgICAgb3BlcnMgPSB7JysnOm9wZXJhdG9yLmFkZCwgJy0nOm9wZXJhdG9yLnN1YiwgJyonOm9wZXJhdG9yLm11bCwgJy8nOm9wZXJhdG9yLnRydWVkaXZ9XFxuICAgICAgICByZXMxID0gTm9uZVxcbiAgICAgICAgcmVzMiA9IE5vbmVcXG4gICAgICAgIGlmIHNlbGYubGVmdENoaWxkOlxcbiAgICAgICAgICAgIHJlczEgPSBzZWxmLmxlZnRDaGlsZC5wb3N0b3JkZXJldmFsKCkgICMvLyBcXFxcbGFiZWx7cGVsZWZ0fVxcbiAgICAgICAgaWYgc2VsZi5yaWdodENoaWxkOlxcbiAgICAgICAgICAgIHJlczIgPSBzZWxmLnJpZ2h0Q2hpbGQucG9zdG9yZGVyZXZhbCgpICMvLyBcXFxcbGFiZWx7cGVyaWdodH1cXG4gICAgICAgIGlmIHJlczEgYW5kIHJlczI6XFxuICAgICAgICAgICAgcmV0dXJuIG9wZXJzW3NlbGYua2V5XShyZXMxLHJlczIpICMvLyBcXFxcbGFiZWx7cGVldmFsfVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5rZXlcXG5cXG5kZWYgaW5vcmRlcih0cmVlKTpcXG4gICAgaWYgdHJlZSAhPSBOb25lOlxcbiAgICAgICAgaW5vcmRlcih0cmVlLmdldExlZnRDaGlsZCgpKVxcbiAgICAgICAgcHJpbnQodHJlZS5nZXRSb290VmFsKCkpXFxuICAgICAgICBpbm9yZGVyKHRyZWUuZ2V0UmlnaHRDaGlsZCgpKVxcblxcbmRlZiBwcmludGV4cCh0cmVlKTpcXG4gICAgaWYgdHJlZS5sZWZ0Q2hpbGQ6XFxuICAgICAgICBwcmludCgnKCcpXFxuICAgICAgICBwcmludGV4cCh0cmVlLmdldExlZnRDaGlsZCgpKVxcbiAgICBwcmludCh0cmVlLmdldFJvb3RWYWwoKSlcXG4gICAgaWYgdHJlZS5yaWdodENoaWxkOlxcbiAgICAgICAgcHJpbnRleHAodHJlZS5nZXRSaWdodENoaWxkKCkpXFxuICAgICAgICBwcmludCgnKScpIFxcblxcbmRlZiBwcmludGV4cCh0cmVlKTpcXG4gICAgc1ZhbCA9IFxcXCJcXFwiXFxuICAgIGlmIHRyZWU6XFxuICAgICAgICBzVmFsID0gJygnICsgcHJpbnRleHAodHJlZS5nZXRMZWZ0Q2hpbGQoKSlcXG4gICAgICAgIHNWYWwgPSBzVmFsICsgc3RyKHRyZWUuZ2V0Um9vdFZhbCgpKVxcbiAgICAgICAgc1ZhbCA9IHNWYWwgKyBwcmludGV4cCh0cmVlLmdldFJpZ2h0Q2hpbGQoKSkgKyAnKSdcXG4gICAgcmV0dXJuIHNWYWxcXG5cXG5kZWYgcG9zdG9yZGVyZXZhbCh0cmVlKTpcXG4gICAgb3BlcnMgPSB7JysnOm9wZXJhdG9yLmFkZCwgJy0nOm9wZXJhdG9yLnN1YiwgJyonOm9wZXJhdG9yLm11bCwgJy8nOm9wZXJhdG9yLnRydWVkaXZ9XFxuICAgIHJlczEgPSBOb25lXFxuICAgIHJlczIgPSBOb25lXFxuICAgIGlmIHRyZWU6XFxuICAgICAgICByZXMxID0gcG9zdG9yZGVyZXZhbCh0cmVlLmdldExlZnRDaGlsZCgpKSAgIy8vIFxcXFxsYWJlbHtwZWxlZnR9XFxuICAgICAgICByZXMyID0gcG9zdG9yZGVyZXZhbCh0cmVlLmdldFJpZ2h0Q2hpbGQoKSkgIy8vIFxcXFxsYWJlbHtwZXJpZ2h0fVxcbiAgICAgICAgaWYgcmVzMSBhbmQgcmVzMjpcXG4gICAgICAgICAgICByZXR1cm4gb3BlcnNbdHJlZS5nZXRSb290VmFsKCldKHJlczEscmVzMikgIy8vIFxcXFxsYWJlbHtwZWV2YWx9XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiB0cmVlLmdldFJvb3RWYWwoKVxcblxcbmRlZiBoZWlnaHQodHJlZSk6XFxuICAgIGlmIHRyZWUgPT0gTm9uZTpcXG4gICAgICAgIHJldHVybiAtMVxcbiAgICBlbHNlOlxcbiAgICAgICAgcmV0dXJuIDEgKyBtYXgoaGVpZ2h0KHRyZWUubGVmdENoaWxkKSxoZWlnaHQodHJlZS5yaWdodENoaWxkKSlcXG5cXG4jIHQgPSBCaW5hcnlUcmVlKDcpXFxuIyB0Lmluc2VydExlZnQoMylcXG4jIHQuaW5zZXJ0UmlnaHQoOSlcXG4jIGlub3JkZXIodClcXG4jIGltcG9ydCBvcGVyYXRvclxcbiMgeCA9IEJpbmFyeVRyZWUoJyonKVxcbiMgeC5pbnNlcnRMZWZ0KCcrJylcXG4jIGwgPSB4LmdldExlZnRDaGlsZCgpXFxuIyBsLmluc2VydExlZnQoNClcXG4jIGwuaW5zZXJ0UmlnaHQoNSlcXG4jIHguaW5zZXJ0UmlnaHQoNylcXG4jIHByaW50KHByaW50ZXhwKHgpKVxcbiMgcHJpbnQocG9zdG9yZGVyZXZhbCh4KSlcXG4jIHByaW50KGhlaWdodCh4KSlcXG5cIixcInNyYy9saWIvcHl0aG9uZHMvdHJlZXMvYmluaGVhcC5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiMgXFxuXFxuIyB0aGlzIGhlYXAgdGFrZXMga2V5IHZhbHVlIHBhaXJzLCB3ZSB3aWxsIGFzc3VtZSB0aGF0IHRoZSBrZXlzIGFyZSBpbnRlZ2Vyc1xcbmNsYXNzIEJpbkhlYXA6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaGVhcExpc3QgPSBbMF1cXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSAwXFxuXFxuXFxuICAgIGRlZiBidWlsZEhlYXAoc2VsZixhbGlzdCk6XFxuICAgICAgICBpID0gbGVuKGFsaXN0KSAvLyAyXFxuICAgICAgICBzZWxmLmN1cnJlbnRTaXplID0gbGVuKGFsaXN0KVxcbiAgICAgICAgc2VsZi5oZWFwTGlzdCA9IFswXSArIGFsaXN0WzpdXFxuICAgICAgICBwcmludChsZW4oc2VsZi5oZWFwTGlzdCksIGkpXFxuICAgICAgICB3aGlsZSAoaSA+IDApOlxcbiAgICAgICAgICAgIHByaW50KHNlbGYuaGVhcExpc3QsIGkpXFxuICAgICAgICAgICAgc2VsZi5wZXJjRG93bihpKVxcbiAgICAgICAgICAgIGkgPSBpIC0gMVxcbiAgICAgICAgcHJpbnQoc2VsZi5oZWFwTGlzdCxpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgcGVyY0Rvd24oc2VsZixpKTpcXG4gICAgICAgIHdoaWxlIChpICogMikgPD0gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICBtYyA9IHNlbGYubWluQ2hpbGQoaSlcXG4gICAgICAgICAgICBpZiBzZWxmLmhlYXBMaXN0W2ldID4gc2VsZi5oZWFwTGlzdFttY106XFxuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuaGVhcExpc3RbaV1cXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFwTGlzdFtpXSA9IHNlbGYuaGVhcExpc3RbbWNdXFxuICAgICAgICAgICAgICAgIHNlbGYuaGVhcExpc3RbbWNdID0gdG1wXFxuICAgICAgICAgICAgaSA9IG1jXFxuICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgbWluQ2hpbGQoc2VsZixpKTpcXG4gICAgICAgIGlmIGkgKiAyICsgMSA+IHNlbGYuY3VycmVudFNpemU6XFxuICAgICAgICAgICAgcmV0dXJuIGkgKiAyXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHNlbGYuaGVhcExpc3RbaSAqIDJdIDwgc2VsZi5oZWFwTGlzdFtpICogMiArIDFdOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAqIDJcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAqIDIgKyAxXFxuXFxuICAgIGRlZiBwZXJjVXAoc2VsZixpKTpcXG4gICAgICAgIHdoaWxlIGkgLy8gMiA+IDA6XFxuICAgICAgICAgICAgaWYgc2VsZi5oZWFwTGlzdFtpXSA8IHNlbGYuaGVhcExpc3RbaS8vMl06XFxuICAgICAgICAgICAgICAgdG1wID0gc2VsZi5oZWFwTGlzdFtpIC8vIDJdXFxuICAgICAgICAgICAgICAgc2VsZi5oZWFwTGlzdFtpIC8vIDJdID0gc2VsZi5oZWFwTGlzdFtpXVxcbiAgICAgICAgICAgICAgIHNlbGYuaGVhcExpc3RbaV0gPSB0bXBcXG4gICAgICAgICAgICBpID0gaSAvLyAyXFxuIFxcbiAgICBkZWYgaW5zZXJ0KHNlbGYsayk6XFxuICAgICAgICBzZWxmLmhlYXBMaXN0LmFwcGVuZChrKVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IHNlbGYuY3VycmVudFNpemUgKyAxXFxuICAgICAgICBzZWxmLnBlcmNVcChzZWxmLmN1cnJlbnRTaXplKVxcblxcbiAgICBkZWYgZGVsTWluKHNlbGYpOlxcbiAgICAgICAgcmV0dmFsID0gc2VsZi5oZWFwTGlzdFsxXVxcbiAgICAgICAgc2VsZi5oZWFwTGlzdFsxXSA9IHNlbGYuaGVhcExpc3Rbc2VsZi5jdXJyZW50U2l6ZV1cXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSBzZWxmLmN1cnJlbnRTaXplIC0gMVxcbiAgICAgICAgc2VsZi5oZWFwTGlzdC5wb3AoKVxcbiAgICAgICAgc2VsZi5wZXJjRG93bigxKVxcbiAgICAgICAgcmV0dXJuIHJldHZhbFxcbiAgICAgICAgXFxuICAgIGRlZiBpc0VtcHR5KHNlbGYpOlxcbiAgICAgICAgaWYgY3VycmVudFNpemUgPT0gMDpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG5cIixcInNyYy9saWIvcHl0aG9uZHMvdHJlZXMvYnN0LnB5XCI6XCIjIS9iaW4vZW52IHB5dGhvbjMuMVxcbiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBJbnRyb2R1Y3Rpb24gdG8gRGF0YSBTdHJ1Y3R1cmVzIGFuZCBBbGdvcml0aG1zIGluIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMDUsIDIwMTBcXG4jIFxcblxcbmNsYXNzIEJpbmFyeVNlYXJjaFRyZWU6XFxuICAgICcnJ1xcbiAgICBBdXRob3I6ICBCcmFkIE1pbGxlclxcbiAgICBEYXRlOiAgMS8xNS8yMDA1XFxuICAgIERlc2NyaXB0aW9uOiAgSW1sZW1lbnQgYSBiaW5hcnkgc2VhcmNoIHRyZWUgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyZmFjZVxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uczogIFxcbiAgICAgICAgICAgICAgICAgIF9fY29udGFpbnNfXyh5KSA8PT0+IHkgaW4geFxcbiAgICAgICAgICAgICAgICAgIF9fZ2V0aXRlbV9fKHkpIDw9PT4geFt5XVxcbiAgICAgICAgICAgICAgICAgIF9faW5pdF9fKClcXG4gICAgICAgICAgICAgICAgICBfX2xlbl9fKCkgPD09PiBsZW4oeClcXG4gICAgICAgICAgICAgICAgICBfX3NldGl0ZW1fXyhrLHYpIDw9PT4geFtrXSA9IHZcXG4gICAgICAgICAgICAgICAgICBjbGVhcigpXFxuICAgICAgICAgICAgICAgICAgZ2V0KGspXFxuICAgICAgICAgICAgICAgICAgaXRlbXMoKSBcXG4gICAgICAgICAgICAgICAgICBrZXlzKCkgXFxuICAgICAgICAgICAgICAgICAgdmFsdWVzKClcXG4gICAgICAgICAgICAgICAgICBwdXQoayx2KVxcbiAgICAgICAgICAgICAgICAgIGluXFxuICAgICAgICAgICAgICAgICAgZGVsIDw9PT4gXFxuICAgICcnJ1xcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLnJvb3QgPSBOb25lXFxuICAgICAgICBzZWxmLnNpemUgPSAwXFxuICAgIFxcbiAgICBkZWYgcHV0KHNlbGYsa2V5LHZhbCk6XFxuICAgICAgICBpZiBzZWxmLnJvb3Q6XFxuICAgICAgICAgICAgc2VsZi5fcHV0KGtleSx2YWwsc2VsZi5yb290KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLnJvb3QgPSBUcmVlTm9kZShrZXksdmFsKVxcbiAgICAgICAgc2VsZi5zaXplID0gc2VsZi5zaXplICsgMVxcblxcbiAgICBkZWYgX3B1dChzZWxmLGtleSx2YWwsY3VycmVudE5vZGUpOlxcbiAgICAgICAgaWYga2V5IDwgY3VycmVudE5vZGUua2V5OlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnROb2RlLmhhc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wdXQoa2V5LHZhbCxjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkID0gVHJlZU5vZGUoa2V5LHZhbCxwYXJlbnQ9Y3VycmVudE5vZGUpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnROb2RlLmhhc1JpZ2h0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSx2YWwsY3VycmVudE5vZGUucmlnaHRDaGlsZClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yaWdodENoaWxkID0gVHJlZU5vZGUoa2V5LHZhbCxwYXJlbnQ9Y3VycmVudE5vZGUpXFxuICAgICAgICAgICAgXFxuICAgIGRlZiBfX3NldGl0ZW1fXyhzZWxmLGssdik6XFxuICAgICAgICBzZWxmLnB1dChrLHYpXFxuXFxuICAgIGRlZiBnZXQoc2VsZixrZXkpOlxcbiAgICAgICAgaWYgc2VsZi5yb290OlxcbiAgICAgICAgICAgIHJlcyA9IHNlbGYuX2dldChrZXksc2VsZi5yb290KVxcbiAgICAgICAgICAgIGlmIHJlczpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5wYXlsb2FkXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIFxcbiAgICBkZWYgX2dldChzZWxmLGtleSxjdXJyZW50Tm9kZSk6XFxuICAgICAgICBpZiBub3QgY3VycmVudE5vZGU6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIGVsaWYgY3VycmVudE5vZGUua2V5ID09IGtleTpcXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudE5vZGVcXG4gICAgICAgIGVsaWYga2V5IDwgY3VycmVudE5vZGUua2V5OlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXQoa2V5LGN1cnJlbnROb2RlLmxlZnRDaGlsZClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldChrZXksY3VycmVudE5vZGUucmlnaHRDaGlsZClcXG4gICAgICAgICAgICBcXG4gICAgICAgIFxcbiAgICBkZWYgX19nZXRpdGVtX18oc2VsZixrZXkpOlxcbiAgICAgICAgcmVzID0gc2VsZi5nZXQoa2V5KVxcbiAgICAgICAgaWYgcmVzOlxcbiAgICAgICAgICAgIHJldHVybiByZXNcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoJ0Vycm9yLCBrZXkgbm90IGluIHRyZWUnKVxcbiAgICAgICAgICAgIFxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsa2V5KTpcXG4gICAgICAgIGlmIHNlbGYuX2dldChrZXksc2VsZi5yb290KTpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgIFxcbiAgICBkZWYgbGVuZ3RoKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuc2l6ZVxcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnNpemVcXG5cXG4gICAgZGVmIF9faXRlcl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucm9vdC5fX2l0ZXJfXygpXFxuICAgIFxcbiAgICBkZWYgZGVsZXRlKHNlbGYsa2V5KTpcXG4gICAgICAgIGlmIHNlbGYuc2l6ZSA+IDE6XFxuICAgICAgICAgICAgbm9kZVRvUmVtb3ZlID0gc2VsZi5fZ2V0KGtleSxzZWxmLnJvb3QpXFxuICAgICAgICAgICAgaWYgbm9kZVRvUmVtb3ZlOlxcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZShub2RlVG9SZW1vdmUpXFxuICAgICAgICAgICAgICAgIHNlbGYuc2l6ZSA9IHNlbGYuc2l6ZS0xXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoJ0Vycm9yLCBrZXkgbm90IGluIHRyZWUnKVxcbiAgICAgICAgZWxpZiBzZWxmLnNpemUgPT0gMSBhbmQgc2VsZi5yb290LmtleSA9PSBrZXk6XFxuICAgICAgICAgICAgc2VsZi5yb290ID0gTm9uZVxcbiAgICAgICAgICAgIHNlbGYuc2l6ZSA9IHNlbGYuc2l6ZSAtIDFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoJ0Vycm9yLCBrZXkgbm90IGluIHRyZWUnKVxcblxcbiAgICBkZWYgX19kZWxpdGVtX18oc2VsZixrZXkpOlxcbiAgICAgICAgc2VsZi5kZWxldGUoa2V5KVxcbiAgICBcXG4gICAgZGVmIHJlbW92ZShzZWxmLGN1cnJlbnROb2RlKTpcXG4gICAgICAgIGlmIGN1cnJlbnROb2RlLmlzTGVhZigpOiAjbGVhZlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnROb2RlID09IGN1cnJlbnROb2RlLnBhcmVudC5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnBhcmVudC5sZWZ0Q2hpbGQgPSBOb25lXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50LnJpZ2h0Q2hpbGQgPSBOb25lXFxuICAgICAgICBlbGlmIGN1cnJlbnROb2RlLmhhc0JvdGhDaGlsZHJlbigpOiAjaW50ZXJpb3JcXG4gICAgICAgICAgICBzdWNjID0gY3VycmVudE5vZGUuZmluZFN1Y2Nlc3NvcigpXFxuICAgICAgICAgICAgc3VjYy5zcGxpY2VPdXQoKVxcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmtleSA9IHN1Y2Mua2V5XFxuICAgICAgICAgICAgY3VycmVudE5vZGUucGF5bG9hZCA9IHN1Y2MucGF5bG9hZFxcbiAgICAgICAgZWxzZTogIyB0aGlzIG5vZGUgaGFzIG9uZSBjaGlsZFxcbiAgICAgICAgICAgIGlmIGN1cnJlbnROb2RlLmhhc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBpZiBjdXJyZW50Tm9kZS5pc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkLnBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudFxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50LmxlZnRDaGlsZCA9IGN1cnJlbnROb2RlLmxlZnRDaGlsZFxcbiAgICAgICAgICAgICAgICBlbGlmIGN1cnJlbnROb2RlLmlzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkLnBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudFxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50LnJpZ2h0Q2hpbGQgPSBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJlcGxhY2VOb2RlRGF0YShjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQua2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmxlZnRDaGlsZC5wYXlsb2FkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmxlZnRDaGlsZC5sZWZ0Q2hpbGQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkLnJpZ2h0Q2hpbGQpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQucGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQubGVmdENoaWxkID0gY3VycmVudE5vZGUucmlnaHRDaGlsZFxcbiAgICAgICAgICAgICAgICBlbGlmIGN1cnJlbnROb2RlLmlzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHRDaGlsZC5wYXJlbnQgPSBjdXJyZW50Tm9kZS5wYXJlbnRcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnBhcmVudC5yaWdodENoaWxkID0gY3VycmVudE5vZGUucmlnaHRDaGlsZFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZU5vZGVEYXRhKGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQua2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQucGF5bG9hZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yaWdodENoaWxkLmxlZnRDaGlsZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yaWdodENoaWxkLnJpZ2h0Q2hpbGQpXFxuXFxuICAgIGRlZiBpbm9yZGVyKHNlbGYpOlxcbiAgICAgICAgc2VsZi5faW5vcmRlcihzZWxmLnJvb3QpXFxuXFxuICAgIGRlZiBfaW5vcmRlcihzZWxmLHRyZWUpOlxcbiAgICAgICAgaWYgdHJlZSAhPSBOb25lOlxcbiAgICAgICAgICAgIHNlbGYuX2lub3JkZXIodHJlZS5sZWZ0Q2hpbGQpXFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXkpXFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlcih0cmVlLnJpZ2h0Q2hpbGQpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXIoc2VsZik6XFxuICAgICAgICBzZWxmLl9wb3N0b3JkZXIoc2VsZi5yb290KVxcblxcbiAgICBkZWYgX3Bvc3RvcmRlcihzZWxmLCB0cmVlKTpcXG4gICAgICAgIGlmIHRyZWU6XFxuICAgICAgICAgICAgc2VsZi5fcG9zdG9yZGVyKHRyZWUucmlnaHRDaGlsZClcXG4gICAgICAgICAgICBzZWxmLl9wb3N0b3JkZXIodHJlZS5sZWZ0Q2hpbGQpXFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXkpICAgICAgICAgICAgXFxuXFxuICAgIGRlZiBwcmVvcmRlcihzZWxmKTpcXG4gICAgICAgIHNlbGYuX3ByZW9yZGVyKHNlbGYsc2VsZi5yb290KVxcblxcbiAgICBkZWYgX3ByZW9yZGVyKHNlbGYsdHJlZSk6XFxuICAgICAgICBpZiB0cmVlOlxcbiAgICAgICAgICAgIHByaW50KHRyZWUua2V5KSAgICAgICAgICAgIFxcbiAgICAgICAgICAgIHNlbGYuX3ByZW9yZGVyKHRyZWUubGVmdENoaWxkKVxcbiAgICAgICAgICAgIHNlbGYuX3ByZW9yZGVyKHRyZWUucmlnaHRDaGlsZClcXG5cXG4gICAgICAgICAgICAgICAgXFxuY2xhc3MgVHJlZU5vZGU6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLGtleSx2YWwsbGVmdD1Ob25lLHJpZ2h0PU5vbmUscGFyZW50PU5vbmUpOlxcbiAgICAgICAgc2VsZi5rZXkgPSBrZXlcXG4gICAgICAgIHNlbGYucGF5bG9hZCA9IHZhbFxcbiAgICAgICAgc2VsZi5sZWZ0Q2hpbGQgPSBsZWZ0XFxuICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQgPSByaWdodFxcbiAgICAgICAgc2VsZi5wYXJlbnQgPSBwYXJlbnRcXG4gICAgICAgIHNlbGYuYmFsYW5jZUZhY3RvciA9IDBcXG4gICAgICAgIFxcbiAgICBkZWYgaGFzTGVmdENoaWxkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYubGVmdENoaWxkXFxuXFxuICAgIGRlZiBoYXNSaWdodENoaWxkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucmlnaHRDaGlsZFxcbiAgICBcXG4gICAgZGVmIGlzTGVmdENoaWxkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50IGFuZCBzZWxmLnBhcmVudC5sZWZ0Q2hpbGQgPT0gc2VsZlxcblxcbiAgICBkZWYgaXNSaWdodENoaWxkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50IGFuZCBzZWxmLnBhcmVudC5yaWdodENoaWxkID09IHNlbGZcXG5cXG4gICAgZGVmIGlzUm9vdChzZWxmKTpcXG4gICAgICAgIHJldHVybiBub3Qgc2VsZi5wYXJlbnRcXG5cXG4gICAgZGVmIGlzTGVhZihzZWxmKTpcXG4gICAgICAgIHJldHVybiBub3QgKHNlbGYucmlnaHRDaGlsZCBvciBzZWxmLmxlZnRDaGlsZClcXG5cXG4gICAgZGVmIGhhc0FueUNoaWxkcmVuKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucmlnaHRDaGlsZCBvciBzZWxmLmxlZnRDaGlsZFxcblxcbiAgICBkZWYgaGFzQm90aENoaWxkcmVuKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucmlnaHRDaGlsZCBhbmQgc2VsZi5sZWZ0Q2hpbGRcXG4gICAgXFxuICAgIGRlZiByZXBsYWNlTm9kZURhdGEoc2VsZixrZXksdmFsdWUsbGMscmMpOlxcbiAgICAgICAgc2VsZi5rZXkgPSBrZXlcXG4gICAgICAgIHNlbGYucGF5bG9hZCA9IHZhbHVlXFxuICAgICAgICBzZWxmLmxlZnRDaGlsZCA9IGxjXFxuICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQgPSByY1xcbiAgICAgICAgaWYgc2VsZi5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZC5wYXJlbnQgPSBzZWxmXFxuICAgICAgICBpZiBzZWxmLmhhc1JpZ2h0Q2hpbGQoKTpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQucGFyZW50ID0gc2VsZlxcbiAgICAgICAgXFxuICAgIGRlZiBmaW5kU3VjY2Vzc29yKHNlbGYpOlxcbiAgICAgICAgc3VjYyA9IE5vbmVcXG4gICAgICAgIGlmIHNlbGYuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgIHN1Y2MgPSBzZWxmLnJpZ2h0Q2hpbGQuZmluZE1pbigpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHNlbGYucGFyZW50OlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBzdWNjID0gc2VsZi5wYXJlbnRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPSBOb25lXFxuICAgICAgICAgICAgICAgICAgICBzdWNjID0gc2VsZi5wYXJlbnQuZmluZFN1Y2Nlc3NvcigpXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5yaWdodENoaWxkID0gc2VsZlxcbiAgICAgICAgcmV0dXJuIHN1Y2NcXG5cXG5cXG4gICAgZGVmIHNwbGljZU91dChzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuaXNMZWFmKCk6XFxuICAgICAgICAgICAgaWYgc2VsZi5pc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5sZWZ0Q2hpbGQgPSBOb25lXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnQucmlnaHRDaGlsZCA9IE5vbmVcXG4gICAgICAgIGVsaWYgc2VsZi5oYXNBbnlDaGlsZHJlbigpOlxcbiAgICAgICAgICAgIGlmIHNlbGYuaGFzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LmxlZnRDaGlsZCA9IHNlbGYubGVmdENoaWxkXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5yaWdodENoaWxkID0gc2VsZi5sZWZ0Q2hpbGRcXG4gICAgICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQucGFyZW50ID0gc2VsZi5wYXJlbnRcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5sZWZ0Q2hpbGQgPSBzZWxmLnJpZ2h0Q2hpbGRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPSBzZWxmLnJpZ2h0Q2hpbGRcXG4gICAgICAgICAgICAgICAgc2VsZi5yaWdodENoaWxkLnBhcmVudCA9IHNlbGYucGFyZW50XFxuXFxuICAgIGRlZiBmaW5kTWluKHNlbGYpOlxcbiAgICAgICAgY3VycmVudCA9IHNlbGZcXG4gICAgICAgIHdoaWxlIGN1cnJlbnQuaGFzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdENoaWxkXFxuICAgICAgICByZXR1cm4gY3VycmVudFxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJUaGUgc3RhbmRhcmQgaW5vcmRlciB0cmF2ZXJzYWwgb2YgYSBiaW5hcnkgdHJlZS5cXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGY6XFxuICAgICAgICAgICAgaWYgc2VsZi5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgZm9yIGVsZW0gaW4gc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBlbGVtXFxuICAgICAgICAgICAgeWllbGQgc2VsZi5rZXlcXG4gICAgICAgICAgICBpZiBzZWxmLmhhc1JpZ2h0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgZm9yIGVsZW0gaW4gc2VsZi5yaWdodENoaWxkOlxcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZWxlbVxcblxcbiAgICAgICAgICAgIFxcblwiLFwic3JjL2xpYi9weXRob25kczMvX19pbml0X18ucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5weXRob25kczMgaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcblxcbmZyb20gcHl0aG9uZHMzLmJhc2ljIGltcG9ydCBTdGFjaywgUXVldWUsIERlcXVlXFxuZnJvbSBweXRob25kczMuZ3JhcGhzIGltcG9ydCBHcmFwaCwgVmVydGV4XFxuZnJvbSBweXRob25kczMuc2VhcmNoaW5nIGltcG9ydCBIYXNoVGFibGVcXG5mcm9tIHB5dGhvbmRzMy50cmVlcyBpbXBvcnQgKFxcbiAgICBCaW5hcnlUcmVlLFxcbiAgICBBVkxUcmVlLFxcbiAgICBCaW5hcnlTZWFyY2hUcmVlLFxcbiAgICBCaW5hcnlIZWFwLFxcbiAgICBQcmlvcml0eVF1ZXVlLFxcbilcXG5cXG5fX2FsbF9fID0gW1xcbiAgICBcXFwiU3RhY2tcXFwiLFxcbiAgICBcXFwiUXVldWVcXFwiLFxcbiAgICBcXFwiRGVxdWVcXFwiLFxcbiAgICBcXFwiR3JhcGhcXFwiLFxcbiAgICBcXFwiVmVydGV4XFxcIixcXG4gICAgXFxcIkhhc2hUYWJsZVxcXCIsXFxuICAgIFxcXCJCaW5hcnlUcmVlXFxcIixcXG4gICAgXFxcIkFWTFRyZWVcXFwiLFxcbiAgICBcXFwiQmluYXJ5U2VhcmNoVHJlZVxcXCIsXFxuICAgIFxcXCJCaW5hcnlIZWFwXFxcIixcXG4gICAgXFxcIkJpbmFyeVRyZWVcXFwiLFxcbiAgICBcXFwiUHJpb3JpdHlRdWV1ZVxcXCIsXFxuXVxcblwiLFwic3JjL2xpYi9weXRob25kczMvYmFzaWMvX19pbml0X18ucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5weXRob25kczMuYmFzaWMgaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcbmZyb20gcHl0aG9uZHMzLmJhc2ljLnN0YWNrIGltcG9ydCBTdGFja1xcbmZyb20gcHl0aG9uZHMzLmJhc2ljLnF1ZXVlIGltcG9ydCBRdWV1ZVxcbmZyb20gcHl0aG9uZHMzLmJhc2ljLmRlcXVlIGltcG9ydCBEZXF1ZVxcbmZyb20gcHl0aG9uZHMzLmJhc2ljLmxpbmtlZF9saXN0IGltcG9ydCBPcmRlcmVkTGlzdFxcbmZyb20gcHl0aG9uZHMzLmJhc2ljLmxpbmtlZF9saXN0IGltcG9ydCBVbm9yZGVyZWRMaXN0XFxuXFxuX19hbGxfXyA9IFtcXFwiU3RhY2tcXFwiLCBcXFwiUXVldWVcXFwiLCBcXFwiRGVxdWVcXFwiLCBcXFwiT3JkZXJlZExpc3RcXFwiLCBcXFwiVW5vcmRlcmVkTGlzdFxcXCJdXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9iYXNpYy9kZXF1ZS5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5cXG5jbGFzcyBEZXF1ZTpcXG4gICAgXFxcIlxcXCJcXFwiUXVldWUgaW1wbGVtZW50YXRpb24gYXMgYSBsaXN0XFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBuZXcgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zID0gW11cXG5cXG4gICAgZGVmIGlzX2VtcHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIGRlcXVlIGlzIGVtcHR5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gbm90IGJvb2woc2VsZi5faXRlbXMpXFxuXFxuICAgIGRlZiBhZGRfZnJvbnQoc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaXRlbSB0byB0aGUgZnJvbnQgb2YgdGhlIGRlcXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9pdGVtcy5hcHBlbmQoaXRlbSlcXG5cXG4gICAgZGVmIGFkZF9yZWFyKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGFuIGl0ZW0gdG8gdGhlIHJlYXIgb2YgdGhlIGRlcXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9pdGVtcy5pbnNlcnQoMCwgaXRlbSlcXG5cXG4gICAgZGVmIHJlbW92ZV9mcm9udChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGZyb250IG9mIHRoZSBkZXF1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2l0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiByZW1vdmVfcmVhcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIHJlYXIgb2YgdGhlIGRlcXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5faXRlbXMucG9wKDApXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGRlcXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuX2l0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25kczMvYmFzaWMvbGlua2VkX2xpc3QucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuXFxuY2xhc3MgTGlua2VkTGlzdE5vZGU6XFxuICAgIFxcXCJcXFwiXFxcIkEgbm9kZSBvZiBhIGxpbmtlZCBsaXN0XFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBub2RlX2RhdGEpOlxcbiAgICAgICAgc2VsZi5fZGF0YSA9IG5vZGVfZGF0YVxcbiAgICAgICAgc2VsZi5fbmV4dCA9IE5vbmVcXG5cXG4gICAgZGVmIGdldF9kYXRhKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG5vZGUgZGF0YVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2RhdGFcXG5cXG4gICAgZGVmIHNldF9kYXRhKHNlbGYsIG5vZGVfZGF0YSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbm9kZSBkYXRhXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9kYXRhID0gbm9kZV9kYXRhXFxuXFxuICAgIGRhdGEgPSBwcm9wZXJ0eShnZXRfZGF0YSwgc2V0X2RhdGEpXFxuXFxuICAgIGRlZiBnZXRfbmV4dChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBuZXh0IG5vZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9uZXh0XFxuXFxuICAgIGRlZiBzZXRfbmV4dChzZWxmLCBub2RlX25leHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IG5leHQgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fbmV4dCA9IG5vZGVfbmV4dFxcblxcbiAgICBuZXh0ID0gcHJvcGVydHkoZ2V0X25leHQsIHNldF9uZXh0KVxcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlN0cmluZ1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHN0cihzZWxmLl9kYXRhKVxcblxcblxcbmNsYXNzIExpbmtlZExpc3Q6XFxuICAgIFxcXCJcXFwiXFxcIkxpbmtlZCBMaXN0IGNsYXNzIGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhIGxpbmtlZCBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9oZWFkID0gTm9uZVxcbiAgICAgICAgc2VsZi5fY291bnQgPSAwXFxuXFxuICAgIGRlZiBpc19lbXB0eShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIklzIHRoZSBsaXN0IGVtcHR5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5faGVhZCBpcyBOb25lXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2l6ZSBvZiB0aGUgbGlzdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NvdW50XFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2l6ZSBvZiB0aGUgbGlzdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NvdW50XFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTGlzdCBhcyBhIHN0cmluZ1xcXCJcXFwiXFxcIlxcbiAgICAgICAgbGlzdF9zdHIgPSBcXFwiW1xcXCJcXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLl9oZWFkXFxuXFxuICAgICAgICB3aGlsZSBjdXJyZW50OlxcbiAgICAgICAgICAgIGxpc3Rfc3RyICs9IHN0cihjdXJyZW50KVxcbiAgICAgICAgICAgIGlmIGN1cnJlbnQubmV4dDpcXG4gICAgICAgICAgICAgICAgbGlzdF9zdHIgKz0gXFxcIiwgXFxcIlxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcXG4gICAgICAgIGxpc3Rfc3RyICs9IFxcXCJdXFxcIlxcbiAgICAgICAgcmV0dXJuIGxpc3Rfc3RyXFxuXFxuICAgIGRlZiBhZGQoc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGEgbmV3IG5vZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHBhc3NcXG5cXG4gICAgZGVmIHJlbW92ZShzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZW1vdmUgYSBub2RlIHdpdGggYSBzcGVjaWZpYyB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcGFzc1xcblxcbiAgICBkZWYgc2VhcmNoKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNlYXJjaCBmb3IgYSBub2RlIHdpdGggYSBzcGVjaWZpYyB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcGFzc1xcblxcblxcbmNsYXNzIFVub3JkZXJlZExpc3QoTGlua2VkTGlzdCk6XFxuICAgIFxcXCJcXFwiXFxcIlVub3JkZXJlZCBsaW5rZWQgbGlzdCBpbXBsZW1lbnRhdGlvblxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgYW4gdW5vcmRlcmVkIGxpbmtlZCBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICBMaW5rZWRMaXN0Ll9faW5pdF9fKHNlbGYpXFxuXFxuICAgIGRlZiBhZGQoc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGEgbmV3IG5vZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIG5ld19ub2RlID0gTGlua2VkTGlzdE5vZGUodmFsdWUpXFxuICAgICAgICBuZXdfbm9kZS5zZXRfbmV4dChzZWxmLl9oZWFkKVxcbiAgICAgICAgc2VsZi5faGVhZCA9IG5ld19ub2RlXFxuICAgICAgICBzZWxmLl9jb3VudCA9IHNlbGYuX2NvdW50ICsgMVxcblxcbiAgICBkZWYgcmVtb3ZlKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBjdXJyZW50ID0gc2VsZi5faGVhZFxcbiAgICAgICAgcHJldiA9IE5vbmVcXG5cXG4gICAgICAgIHdoaWxlIGN1cnJlbnQ6XFxuICAgICAgICAgICAgaWYgY3VycmVudC5kYXRhID09IHZhbHVlOlxcbiAgICAgICAgICAgICAgICBpZiBwcmV2IGlzIE5vbmU6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9oZWFkID0gY3VycmVudC5uZXh0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBjdXJyZW50Lm5leHRcXG4gICAgICAgICAgICAgICAgc2VsZi5fY291bnQgPSBzZWxmLl9jb3VudCAtIDFcXG4gICAgICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnRcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJ7fSBpcyBub3QgaW4gdGhlIGxpc3RcXFwiLmZvcm1hdCh2YWx1ZSkpXFxuXFxuICAgIGRlZiBzZWFyY2goc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2VhcmNoIGZvciBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBjdXJyZW50ID0gc2VsZi5faGVhZFxcblxcbiAgICAgICAgd2hpbGUgY3VycmVudDpcXG4gICAgICAgICAgICBpZiBjdXJyZW50LmRhdGEgPT0gdmFsdWU6XFxuICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFxcbiAgICAgICAgcmV0dXJuIEZhbHNlXFxuXFxuXFxuY2xhc3MgT3JkZXJlZExpc3QoTGlua2VkTGlzdCk6XFxuICAgIFxcXCJcXFwiXFxcIk9yZGVyZWQgbGlua2VkIGxpc3QgaW1wbGVtZW50YXRpb25cXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIGFuIE9yZGVyZWQgbGlua2VkIGxpc3RcXFwiXFxcIlxcXCJcXG4gICAgICAgIExpbmtlZExpc3QuX19pbml0X18oc2VsZilcXG5cXG4gICAgZGVmIGFkZChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgY3VycmVudCA9IHNlbGYuX2hlYWRcXG4gICAgICAgIHByZXYgPSBOb25lXFxuICAgICAgICBuZXdfbm9kZSA9IExpbmtlZExpc3ROb2RlKHZhbHVlKVxcblxcbiAgICAgICAgd2hpbGUgY3VycmVudCBhbmQgY3VycmVudC5kYXRhIDwgdmFsdWU6XFxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnRcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0XFxuXFxuICAgICAgICBpZiBwcmV2IGlzIE5vbmU6XFxuICAgICAgICAgICAgbmV3X25vZGUubmV4dCA9IHNlbGYuX2hlYWRcXG4gICAgICAgICAgICBzZWxmLl9oZWFkID0gbmV3X25vZGVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbmV3X25vZGUubmV4dCA9IGN1cnJlbnRcXG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdfbm9kZVxcbiAgICAgICAgc2VsZi5fY291bnQgPSBzZWxmLl9jb3VudCArIDFcXG5cXG4gICAgZGVmIHJlbW92ZShzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZW1vdmUgYSBub2RlIHdpdGggYSBzcGVjaWZpYyB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgIyBUaGlzIGlzIGFuIGV4ZXJjaXNlXFxuICAgICAgICBwYXNzXFxuXFxuICAgIGRlZiBzZWFyY2goc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2VhcmNoIGZvciBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICAjIFRoaXMgaXMgYW4gZXhlcmNpc2VcXG4gICAgICAgIHBhc3NcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2Jhc2ljL3F1ZXVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIFF1ZXVlOlxcbiAgICBcXFwiXFxcIlxcXCJRdWV1ZSBpbXBsZW1lbnRhdGlvbiBhcyBhIGxpc3RcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyBxdWV1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgcXVldWUgaXMgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgYm9vbChzZWxmLl9pdGVtcylcXG5cXG4gICAgZGVmIGVucXVldWUoc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaXRlbSB0byB0aGUgcXVldWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zLmluc2VydCgwLCBpdGVtKVxcblxcbiAgICBkZWYgZGVxdWV1ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIHF1ZXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5faXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgcXVldWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5faXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9iYXNpYy9zdGFjay5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5cXG5jbGFzcyBTdGFjazpcXG4gICAgXFxcIlxcXCJcXFwiU3RhY2sgaW1wbGVtZW50YXRpb24gYXMgYSBsaXN0XFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBuZXcgc3RhY2tcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zID0gW11cXG5cXG4gICAgZGVmIGlzX2VtcHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIHN0YWNrIGlzIGVtcHR5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gbm90IGJvb2woc2VsZi5faXRlbXMpXFxuXFxuICAgIGRlZiBwdXNoKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGFuIGl0ZW0gdG8gdGhlIHN0YWNrXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9pdGVtcy5hcHBlbmQoaXRlbSlcXG5cXG4gICAgZGVmIHBvcChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIHN0YWNrXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5faXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHBlZWsoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIHZhbHVlIG9mIHRoZSB0b3AgaXRlbSBpbiB0aGUgc3RhY2tcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9pdGVtc1stMV1cXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc3RhY2tcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5faXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9ncmFwaHMvX19pbml0X18ucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5weXRob25kczMuZ3JhcGhzIGltcG9ydCBzdGF0ZW1lbnRcXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHB5dGhvbmRzMy5ncmFwaHMuYWRqYWNlbmN5X2dyYXBoIGltcG9ydCBHcmFwaFxcbmZyb20gcHl0aG9uZHMzLmdyYXBocy5hZGphY2VuY3lfZ3JhcGggaW1wb3J0IFZlcnRleFxcblxcbl9fYWxsX18gPSBbXFxcIkdyYXBoXFxcIl1cXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2dyYXBocy9hZGphY2VuY3lfZ3JhcGgucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuaW1wb3J0IGhlYXBxXFxuaW1wb3J0IHN5c1xcblxcblxcbmNsYXNzIFZlcnRleDpcXG4gICAgXFxcIlxcXCJcXFwiR3JhcGggdmVydGV4IGNsYXNzXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyB2ZXJ0ZXhcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2tleSA9IGtleVxcbiAgICAgICAgc2VsZi5fbmVpZ2hib3JzID0ge31cXG4gICAgICAgIHNlbGYuX2NvbG9yID0gXFxcIndoaXRlXFxcIlxcbiAgICAgICAgc2VsZi5fZGlzdGFuY2UgPSBzeXMubWF4c2l6ZVxcbiAgICAgICAgc2VsZi5fcHJldmlvdXMgPSBOb25lXFxuICAgICAgICBzZWxmLl9kaXNjb3ZlcnlfdGltZSA9IDBcXG4gICAgICAgIHNlbGYuX2Nsb3NpbmdfdGltZSA9IDBcXG5cXG4gICAgZGVmIF9fbHRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJMZXNzIHRoYW4gb3BlcmF0b3IgcmVxdWlyZWQgZm9yIGhlYXBpZnlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLmtleSA8IG90aGVyLmtleVxcblxcbiAgICBkZWYgZ2V0X2tleShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCB2ZXJ0ZXgga2V5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fa2V5XFxuXFxuICAgIGtleSA9IHByb3BlcnR5KGdldF9rZXkpXFxuXFxuICAgIGRlZiBnZXRfbmVpZ2hib3Ioc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHRoZSBkaXN0YW5jZSAoZWRnZSB3ZWlnaHQpIHRvIGFuIGFkamFjZW50IG5vZGUgKG5laWdoYm9yKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX25laWdoYm9ycy5nZXQob3RoZXIsIE5vbmUpXFxuXFxuICAgIGRlZiBzZXRfbmVpZ2hib3Ioc2VsZiwgb3RoZXIsIHdlaWdodD0wKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCB0aGUgZGlzdGFuY2UgKGFkZCBhbiBlZGdlKSB0byBhbiBhZGphY2VudCBub2RlIChuZWlnaGJvcilcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX25laWdoYm9yc1tvdGhlcl0gPSB3ZWlnaHRcXG5cXG4gICAgZGVmIGdldF9uZWlnaGJvcnMoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgYWxsIGFkamFjZW50IG5vZGVzIChuZWlnaGJvcnMpXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fbmVpZ2hib3JzLmtleXMoKVxcblxcbiAgICBkZWYgZ2V0X2NvbG9yKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHZlcnRleCBjb2xvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NvbG9yXFxuXFxuICAgIGRlZiBzZXRfY29sb3Ioc2VsZiwgY29sb3IpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHZlcnRleCBjb2xvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY29sb3IgPSBjb2xvclxcblxcbiAgICBjb2xvciA9IHByb3BlcnR5KGdldF9jb2xvciwgc2V0X2NvbG9yKVxcblxcbiAgICBkZWYgZ2V0X2Rpc3RhbmNlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGRpc3RhbmNlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fZGlzdGFuY2VcXG5cXG4gICAgZGVmIHNldF9kaXN0YW5jZShzZWxmLCBkaXN0YW5jZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgZGlzdGFuY2VcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2Rpc3RhbmNlID0gZGlzdGFuY2VcXG5cXG4gICAgZGlzdGFuY2UgPSBwcm9wZXJ0eShnZXRfZGlzdGFuY2UsIHNldF9kaXN0YW5jZSlcXG5cXG4gICAgZGVmIGdldF9wcmV2aW91cyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBwcmV2aW91c1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ByZXZpb3VzXFxuXFxuICAgIGRlZiBzZXRfcHJldmlvdXMoc2VsZiwgcHJldmlvdXMpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHByZXZpb3VzXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9wcmV2aW91cyA9IHByZXZpb3VzXFxuXFxuICAgIHByZXZpb3VzID0gcHJvcGVydHkoZ2V0X3ByZXZpb3VzLCBzZXRfcHJldmlvdXMpXFxuXFxuICAgIGRlZiBnZXRfZGlzY292ZXJ5X3RpbWUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgZGlzY292ZXJ5IHRpbWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9kaXNjb3ZlcnlfdGltZVxcblxcbiAgICBkZWYgc2V0X2Rpc2NvdmVyeV90aW1lKHNlbGYsIGRpc2NvdmVyeV90aW1lKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBkaXNjb3ZlcnkgdGltZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fZGlzY292ZXJ5X3RpbWUgPSBkaXNjb3ZlcnlfdGltZVxcblxcbiAgICBkaXNjb3ZlcnlfdGltZSA9IHByb3BlcnR5KGdldF9kaXNjb3ZlcnlfdGltZSwgc2V0X2Rpc2NvdmVyeV90aW1lKVxcblxcbiAgICBkZWYgZ2V0X2Nsb3NpbmdfdGltZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBjbG9zaW5nIHRpbWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9jbG9zaW5nX3RpbWVcXG5cXG4gICAgZGVmIHNldF9jbG9zaW5nX3RpbWUoc2VsZiwgY2xvc2luZ190aW1lKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBjbG9zaW5nIHRpbWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2Nsb3NpbmdfdGltZSA9IGNsb3NpbmdfdGltZVxcblxcbiAgICBjbG9zaW5nX3RpbWUgPSBwcm9wZXJ0eShnZXRfY2xvc2luZ190aW1lLCBzZXRfY2xvc2luZ190aW1lKVxcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBcXFwiezpeOH18ezpeOH18ezpeOH18ezpeOH18ezpeOH18IHt9XFxcIi5mb3JtYXQoXFxuICAgICAgICAgICAgc2VsZi5fa2V5LFxcbiAgICAgICAgICAgIHNlbGYuX2NvbG9yLFxcbiAgICAgICAgICAgIHNlbGYuX2Rpc3RhbmNlLFxcbiAgICAgICAgICAgIHNlbGYuX2Rpc2NvdmVyeV90aW1lLFxcbiAgICAgICAgICAgIHNlbGYuX2Nsb3NpbmdfdGltZSxcXG4gICAgICAgICAgICBzZWxmLl9wcmV2aW91cyxcXG4gICAgICAgIClcXG5cXG5cXG5jbGFzcyBHcmFwaDpcXG4gICAgXFxcIlxcXCJcXFwiR3JhcGggYXMgYW4gYWRqYWNlbmN5IG1hdHJpeFxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLl92ZXJ0aWNlcyA9IHt9XFxuICAgICAgICBzZWxmLl9lZGdlcyA9IHt9XFxuICAgICAgICBzZWxmLl90aW1lID0gMFxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJJdGVyYXRvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGl0ZXIoc2VsZi5fdmVydGljZXMudmFsdWVzKCkpXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR3JhcGgncyBzaXplXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuX3ZlcnRpY2VzKVxcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdyYXBoJ3Mgc2l6ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLl92ZXJ0aWNlcylcXG5cXG4gICAgZGVmIF9fY29udGFpbnNfXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiaW4gb3BlcmF0b3Igb3ZlcnJpZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBrZXkgaW4gc2VsZi5fdmVydGljZXNcXG5cXG4gICAgZGVmIGdldF92ZXJ0ZXgoc2VsZiwga2V5KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZpbmQgdGhlIHZlcnRleCBpbiB0aGUgZ3JhcGggbmFtZWQgdmVydF9rZXlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl92ZXJ0aWNlcy5nZXQoa2V5LCBOb25lKVxcblxcbiAgICBkZWYgc2V0X3ZlcnRleChzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGFuIGluc3RhbmNlIG9mIFZlcnRleCB0byB0aGUgZ3JhcGhcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3ZlcnRpY2VzW2tleV0gPSBWZXJ0ZXgoa2V5KVxcblxcbiAgICBkZWYgYWRkX2VkZ2Uoc2VsZiwgZnJvbV92ZXJ0ZXgsIHRvX3ZlcnRleCwgd2VpZ2h0PTApOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGEgd2VpZ2h0ZWQgYW5kIGRpcmVjdGVkIGVkZ2UgdG8gdGhlIGdyYXBoXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBmcm9tX3ZlcnRleCBub3QgaW4gc2VsZi5fdmVydGljZXM6XFxuICAgICAgICAgICAgc2VsZi5zZXRfdmVydGV4KGZyb21fdmVydGV4KVxcbiAgICAgICAgaWYgdG9fdmVydGV4IG5vdCBpbiBzZWxmLl92ZXJ0aWNlczpcXG4gICAgICAgICAgICBzZWxmLnNldF92ZXJ0ZXgodG9fdmVydGV4KVxcbiAgICAgICAgc2VsZi5fdmVydGljZXNbZnJvbV92ZXJ0ZXhdLnNldF9uZWlnaGJvcihzZWxmLl92ZXJ0aWNlc1t0b192ZXJ0ZXhdLCB3ZWlnaHQpXFxuICAgICAgICBzZWxmLl9lZGdlc1soZnJvbV92ZXJ0ZXgsIHRvX3ZlcnRleCldID0gd2VpZ2h0XFxuXFxuICAgIGRlZiBnZXRfdmVydGljZXMoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHZlcnRpY2VzIGluIHRoZSBncmFwaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZlcnRpY2VzLmtleXMoKVxcblxcbiAgICBkZWYgZ2V0X2VkZ2VzKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBlZGdlcyBpbiB0aGUgZ3JhcGhcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9lZGdlcy5rZXlzKClcXG5cXG4gICAgZGVmIHJlc2V0X2Rpc3RhbmNlcyhzZWxmLCBkZWZhdWx0X2Rpc3RhbmNlPXN5cy5tYXhzaXplKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlc2V0IGRpc3RhbmNlcyB0byB0ZXN0IERpamtzdHJhJ3NcXFwiXFxcIlxcXCJcXG4gICAgICAgIGZvciB2ZXJ0ZXggaW4gc2VsZjpcXG4gICAgICAgICAgICB2ZXJ0ZXguZGlzdGFuY2UgPSBkZWZhdWx0X2Rpc3RhbmNlXFxuXFxuICAgIGRlZiBiZnMoc2VsZiwgc3RhcnQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQnJlYWR0aCBGaXJzdCBTZWFyY2hcXFwiXFxcIlxcXCJcXG4gICAgICAgIHN0YXJ0LmRpc3RhbmNlID0gMFxcbiAgICAgICAgc3RhcnQucHJldmlvdXMgPSBOb25lXFxuICAgICAgICB2ZXJ0X3F1ZXVlID0gW3N0YXJ0XVxcbiAgICAgICAgd2hpbGUgdmVydF9xdWV1ZTpcXG4gICAgICAgICAgICBjdXJyZW50X3ZlcnQgPSB2ZXJ0X3F1ZXVlLnBvcCgwKVxcbiAgICAgICAgICAgIGZvciBuZWlnaCBpbiBjdXJyZW50X3ZlcnQuZ2V0X25laWdoYm9ycygpOlxcbiAgICAgICAgICAgICAgICBpZiBuZWlnaC5jb2xvciA9PSBcXFwid2hpdGVcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2guY29sb3IgPSBcXFwiZ3JheVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIG5laWdoLmRpc3RhbmNlID0gY3VycmVudF92ZXJ0LmRpc3RhbmNlICsgMVxcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2gucHJldmlvdXMgPSBjdXJyZW50X3ZlcnRcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRfcXVldWUuYXBwZW5kKG5laWdoKVxcbiAgICAgICAgICAgIGN1cnJlbnRfdmVydC5jb2xvciA9IFxcXCJibGFja1xcXCJcXG5cXG4gICAgZGVmIGRmcyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkRlcHRoIEZpcnN0IHNlYXJjaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgZm9yIHZlcnRleCBpbiBzZWxmOlxcbiAgICAgICAgICAgIGlmIHZlcnRleC5jb2xvciA9PSBcXFwid2hpdGVcXFwiOlxcbiAgICAgICAgICAgICAgICBzZWxmLmRmc192aXNpdCh2ZXJ0ZXgpXFxuXFxuICAgIGRlZiBkZnNfdmlzaXQoc2VsZiwgc3RhcnQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiREZTIGhlbHBlciBmdW5jdGlvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgc3RhcnQuY29sb3IgPSBcXFwiZ3JheVxcXCJcXG4gICAgICAgIHNlbGYuX3RpbWUgPSBzZWxmLl90aW1lICsgMVxcbiAgICAgICAgc3RhcnQuZGlzY292ZXJ5X3RpbWUgPSBzZWxmLl90aW1lXFxuICAgICAgICBmb3IgbmV4dF92ZXJ0ZXggaW4gc3RhcnQuZ2V0X25laWdoYm9ycygpOlxcbiAgICAgICAgICAgIGlmIG5leHRfdmVydGV4LmNvbG9yID09IFxcXCJ3aGl0ZVxcXCI6XFxuICAgICAgICAgICAgICAgIG5leHRfdmVydGV4LnNldF9wcmV2aW91cyhzdGFydClcXG4gICAgICAgICAgICAgICAgc2VsZi5kZnNfdmlzaXQobmV4dF92ZXJ0ZXgpXFxuICAgICAgICBzdGFydC5jb2xvciA9IFxcXCJibGFja1xcXCJcXG4gICAgICAgIHNlbGYuX3RpbWUgPSBzZWxmLl90aW1lICsgMVxcbiAgICAgICAgc3RhcnQuY2xvc2luZ190aW1lID0gc2VsZi5fdGltZVxcblxcbiAgICBkZWYgdHJhdmVyc2Uoc2VsZiwgc3JjLCBkc3QpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVHJhdmVyc2UgYSBncmFwaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcGF0aCA9IFtdXFxuICAgICAgICBjdXJyZW50ID0gc2VsZi5nZXRfdmVydGV4KGRzdClcXG4gICAgICAgIHdoaWxlIGN1cnJlbnQ6XFxuICAgICAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudClcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wcmV2aW91c1xcbiAgICAgICAgcHJpbnQoXFxuICAgICAgICAgICAgXFxcIlBhdGggZnJvbSB7fSB0byB7fSAoe30pOiB7fVxcXCIuZm9ybWF0KFxcbiAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoc3JjKS5rZXksXFxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChkc3QpLmtleSxcXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRfdmVydGV4KGRzdCkuZGlzdGFuY2UsXFxuICAgICAgICAgICAgICAgIFxcXCIgXFxcIi5qb2luKHZlcnRleC5rZXkgZm9yIHZlcnRleCBpbiByZXZlcnNlZChwYXRoKSksXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgKVxcblxcbiAgICBkZWYgZGlqa3N0cmEoc2VsZiwgc3RhcnQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRGlqa3N0cmEncyBzaG9ydGVzdCBwYXRoIGFsZ29yaXRobVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc3RhcnQuZGlzdGFuY2UgPSAwXFxuICAgICAgICBub3RfeWV0X3Zpc2l0ZWQgPSBbW3N0YXJ0LmRpc3RhbmNlLCBzdGFydF1dXFxuICAgICAgICBoZWFwcS5oZWFwaWZ5KG5vdF95ZXRfdmlzaXRlZClcXG4gICAgICAgIHdoaWxlIG5vdF95ZXRfdmlzaXRlZDpcXG4gICAgICAgICAgICBjdXJyZW50X3ZlcnRleCA9IGhlYXBxLmhlYXBwb3Aobm90X3lldF92aXNpdGVkKVsxXVxcbiAgICAgICAgICAgIGZvciBuZXh0X3ZlcnRleCBpbiBjdXJyZW50X3ZlcnRleC5nZXRfbmVpZ2hib3JzKCk6XFxuICAgICAgICAgICAgICAgIG5ld19kaXN0YW5jZSA9IGN1cnJlbnRfdmVydGV4LmRpc3RhbmNlICsgY3VycmVudF92ZXJ0ZXguZ2V0X25laWdoYm9yKFxcbiAgICAgICAgICAgICAgICAgICAgbmV4dF92ZXJ0ZXhcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICBpZiBuZXdfZGlzdGFuY2UgPCBuZXh0X3ZlcnRleC5kaXN0YW5jZTpcXG4gICAgICAgICAgICAgICAgICAgIG5leHRfdmVydGV4LmRpc3RhbmNlID0gbmV3X2Rpc3RhbmNlXFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3ZlcnRleC5wcmV2aW91cyA9IGN1cnJlbnRfdmVydGV4XFxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IEZhbHNlXFxuICAgICAgICAgICAgICAgICAgICBmb3IgdmVydGV4IGluIG5vdF95ZXRfdmlzaXRlZDpcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiB2ZXJ0ZXhbMV0ua2V5ID09IG5leHRfdmVydGV4LmtleTpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4WzBdID0gbmV4dF92ZXJ0ZXguZGlzdGFuY2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhcHEuaGVhcGlmeShub3RfeWV0X3Zpc2l0ZWQpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gVHJ1ZVxcbiAgICAgICAgICAgICAgICAgICAgaWYgbm90IGZvdW5kOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RfeWV0X3Zpc2l0ZWQsIFtuZXh0X3ZlcnRleC5kaXN0YW5jZSwgbmV4dF92ZXJ0ZXhdXFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxcblxcbiAgICBkZWYgYmVsbG1hbl9mb3JkKHNlbGYsIHN0YXJ0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkJlbGxtYW4tRm9yZCBzaG9ydGVzdCBwYXRoIGFsZ29yaXRobVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc3RhcnQuZGlzdGFuY2UgPSAwXFxuICAgICAgICBmb3IgXyBpbiByYW5nZShsZW4oc2VsZi5fdmVydGljZXMpKTpcXG4gICAgICAgICAgICBmb3IgZWRnZSBpbiBzZWxmLl9lZGdlczpcXG4gICAgICAgICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRfdmVydGV4KGVkZ2VbMF0pLmRpc3RhbmNlICsgc2VsZi5fZWRnZXNbZWRnZV1cXG4gICAgICAgICAgICAgICAgICAgIDwgc2VsZi5nZXRfdmVydGV4KGVkZ2VbMV0pLmRpc3RhbmNlXFxuICAgICAgICAgICAgICAgICk6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZWRnZVsxXSkuZGlzdGFuY2UgPSAoXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRfdmVydGV4KGVkZ2VbMF0pLmRpc3RhbmNlICsgc2VsZi5fZWRnZXNbZWRnZV1cXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChlZGdlWzFdKS5wcmV2aW91cyA9IHNlbGYuZ2V0X3ZlcnRleChlZGdlWzBdKVxcbiAgICAgICAgZm9yIGVkZ2UgaW4gc2VsZi5fZWRnZXM6XFxuICAgICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZWRnZVswXSkuZGlzdGFuY2UgKyBzZWxmLl9lZGdlc1tlZGdlXVxcbiAgICAgICAgICAgICAgICA8IHNlbGYuZ2V0X3ZlcnRleChlZGdlWzFdKS5kaXN0YW5jZVxcbiAgICAgICAgICAgICk6XFxuICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcIkdyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUtd2VpZ2h0IGN5Y2xlXFxcIilcXG5cXG4gICAgZGVmIHByaW0oc2VsZiwgc3RhcnQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUHJpbSdzIHNwYW5uaW5nIHRyZWUgYWxnb3JpdGhtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdGFydC5kaXN0YW5jZSA9IDBcXG4gICAgICAgIG5vdF9pbl9hX3RyZWUgPSBbW3ZlcnRleC5kaXN0YW5jZSwgdmVydGV4XSBmb3IgdmVydGV4IGluIHNlbGZdXFxuICAgICAgICBoZWFwcS5oZWFwaWZ5KG5vdF9pbl9hX3RyZWUpXFxuICAgICAgICB3aGlsZSBub3RfaW5fYV90cmVlOlxcbiAgICAgICAgICAgIGN1cnJlbnRfdmVydGV4ID0gaGVhcHEuaGVhcHBvcChub3RfaW5fYV90cmVlKVsxXVxcbiAgICAgICAgICAgIGZvciBuZXh0X3ZlcnRleCBpbiBjdXJyZW50X3ZlcnRleC5nZXRfbmVpZ2hib3JzKCk6XFxuICAgICAgICAgICAgICAgIG5ld19kaXN0YW5jZSA9IGN1cnJlbnRfdmVydGV4LmdldF9uZWlnaGJvcihuZXh0X3ZlcnRleClcXG4gICAgICAgICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgICAgICAgICAgYW55KGl0ZW1bMV0gPT0gbmV4dF92ZXJ0ZXggZm9yIGl0ZW0gaW4gbm90X2luX2FfdHJlZSlcXG4gICAgICAgICAgICAgICAgICAgIGFuZCBuZXdfZGlzdGFuY2UgPCBuZXh0X3ZlcnRleC5kaXN0YW5jZVxcbiAgICAgICAgICAgICAgICApOlxcbiAgICAgICAgICAgICAgICAgICAgbmV4dF92ZXJ0ZXgucHJldmlvdXMgPSBjdXJyZW50X3ZlcnRleFxcbiAgICAgICAgICAgICAgICAgICAgbmV4dF92ZXJ0ZXguZGlzdGFuY2UgPSBuZXdfZGlzdGFuY2VcXG4gICAgICAgICAgICAgICAgICAgIGZvciBpdGVtIGluIG5vdF9pbl9hX3RyZWU6XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgaXRlbVsxXSA9PSBuZXh0X3ZlcnRleDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVswXSA9IG5ld19kaXN0YW5jZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFwcS5oZWFwaWZ5KG5vdF9pbl9hX3RyZWUpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9pbnRyby9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5pbnRybyBpbXBvcnQgc3RhdGVtZW50XFxuXFxcIlxcXCJcXFwiXFxuZnJvbSBweXRob25kczMuaW50cm8ub29wIGltcG9ydCBGcmFjdGlvblxcblxcbl9fYWxsX18gPSBbXFxcIkZyYWN0aW9uXFxcIl1cXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2ludHJvL29vcC5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5cXG5kZWYgZ2NkKG51bWJlcjEsIG51bWJlcjIpOlxcbiAgICBcXFwiXFxcIlxcXCJIZWxwZXIgZnVuY3Rpb24gdG8gc2ltcGxpZnkgZnJhY3Rpb25zXFxcIlxcXCJcXFwiXFxuICAgIGlmIG5vdCBpc2luc3RhbmNlKG51bWJlcjEsIGludCkgb3Igbm90IGlzaW5zdGFuY2UobnVtYmVyMiwgaW50KTpcXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvcihcXFwiTnVtZXJhdG9yIGFuZCBkZW5vbWluYXRvciBtdXN0IGJlIGludGVnZXJzXFxcIilcXG4gICAgd2hpbGUgbnVtYmVyMSAlIG51bWJlcjI6XFxuICAgICAgICBudW1iZXIxLCBudW1iZXIyID0gbnVtYmVyMiwgbnVtYmVyMSAlIG51bWJlcjJcXG4gICAgcmV0dXJuIG51bWJlcjJcXG5cXG5cXG5jbGFzcyBGcmFjdGlvbjpcXG4gICAgXFxcIlxcXCJcXFwiRnJhY3Rpb24gY2xhc3NcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5ld19udW1lciwgbmV3X2Rlbm9tKTpcXG4gICAgICAgIHRyeTpcXG4gICAgICAgICAgICBjb21tb24gPSBnY2QobmV3X251bWVyLCBuZXdfZGVub20pXFxuICAgICAgICBleGNlcHQgVHlwZUVycm9yOlxcbiAgICAgICAgICAgIHJhaXNlXFxuICAgICAgICBzZWxmLl9udW1lciA9IG5ld19udW1lciAvLyBjb21tb25cXG4gICAgICAgIHNlbGYuX2Rlbm9tID0gbmV3X2Rlbm9tIC8vIGNvbW1vblxcblxcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIG51bWVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG51bWVyYXRvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX251bWVyXFxuXFxuICAgIEBudW1lci5zZXR0ZXJcXG4gICAgZGVmIHNldF9udW1lcihzZWxmLCBuZXdfbnVtZXIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IG51bWVyYXRvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fbnVtZXIgPSBuZXdfbnVtZXJcXG5cXG4gICAgZGVmIGdldF9kZW5vbShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBkZW5pbWluYXRvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2Rlbm9tXFxuXFxuICAgIGRlZiBzZXRfZGVub20oc2VsZiwgbmV3X2Rlbm9tKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBkZW5pbWluYXRvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fZGVub20gPSBuZXdfZGVub21cXG5cXG4gICAgIyBBbm90aGVyIHdheSB0byBjcmVhdGUgYW4gYXR0cmlidXRlXFxuICAgIGRlbm9tID0gcHJvcGVydHkoZ2V0X2Rlbm9tLCBzZXRfZGVub20pXFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHRoZSBzdHJpbmcgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX251bWVyID4gc2VsZi5fZGVub206XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ7fSB7fS97fVxcXCIuZm9ybWF0KFxcbiAgICAgICAgICAgICAgICBzZWxmLl9udW1lciAvLyBzZWxmLl9kZW5vbSwgc2VsZi5fbnVtZXIgJSBzZWxmLl9kZW5vbSwgc2VsZi5fZGVub21cXG4gICAgICAgICAgICApXFxuICAgICAgICByZXR1cm4gXFxcInt9L3t9XFxcIi5mb3JtYXQoc2VsZi5fbnVtZXIsIHNlbGYuX2Rlbm9tKVxcblxcbiAgICBkZWYgX19yZXByX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJGcmFjdGlvbiByZXByZXNlbnRhdGlvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIFxcXCJGcmFjdGlvbih7fSwge30pXFxcIi5mb3JtYXQoc2VsZi5fbnVtZXIsIHNlbGYuX2Rlbm9tKVxcblxcbiAgICBkZWYgX19lcV9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkVxdWFsaXR5IGNvbXBhcmlzb25cXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9udW1lciAqIG90aGVyLmRlbm9tID09IG90aGVyLm51bWVyICogc2VsZi5fZGVub21cXG5cXG4gICAgZGVmIF9fYWRkX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIHR3byBmcmFjdGlvbnNcXFwiXFxcIlxcXCJcXG4gICAgICAgIG5ld19udW1lciA9IHNlbGYuX251bWVyICogb3RoZXIuZGVub20gKyBzZWxmLl9kZW5vbSAqIG90aGVyLm51bWVyXFxuICAgICAgICBuZXdfZGVub20gPSBzZWxmLl9kZW5vbSAqIG90aGVyLmRlbm9tXFxuICAgICAgICByZXR1cm4gRnJhY3Rpb24obmV3X251bWVyLCBuZXdfZGVub20pXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9zZWFyY2hpbmcvX19pbml0X18ucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5weXRob25kczMuc2VhcmNoIGltcG9ydCBzdGF0ZW1lbnRcXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHB5dGhvbmRzMy5zZWFyY2hpbmcuaGFzaF90YWJsZSBpbXBvcnQgSGFzaFRhYmxlXFxuXFxuX19hbGxfXyA9IFtcXFwiSGFzaFRhYmxlXFxcIl1cXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3NlYXJjaGluZy9oYXNoX3RhYmxlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIEhhc2hUYWJsZTpcXG4gICAgXFxcIlxcXCJcXFwiSGFzaCBUYWJsZSBpbXBsZW1lbnRhdGlvblxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgc2l6ZT0xNik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgYSBoYXNoIHRhYmxlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9zaXplID0gc2l6ZVxcbiAgICAgICAgc2VsZi5fc2xvdHMgPSBbTm9uZV0gKiBzZWxmLl9zaXplXFxuICAgICAgICBzZWxmLl9kYXRhID0gW05vbmVdICogc2VsZi5fc2l6ZVxcblxcbiAgICBkZWYgX19nZXRpdGVtX18oc2VsZiwga2V5KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIk1hZ2ljIF9fZ2V0X19cXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLmdldChrZXkpXFxuXFxuICAgIGRlZiBfX3NldGl0ZW1fXyhzZWxmLCBrZXksIGRhdGEpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTWFnaWMgX19zZXRfX1xcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5wdXQoa2V5LCBkYXRhKVxcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIk1hZ2ljIF9fbGVuX19cXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9zaXplIC0gc2VsZi5fc2xvdHMuY291bnQoTm9uZSlcXG5cXG4gICAgZGVmIF9fY29udGFpbnNfXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTWFnaW4gaW5cXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBrZXkgaW4gc2VsZi5fc2xvdHNcXG5cXG4gICAgZGVmIF9oYXNoX2Z1bmN0aW9uKHNlbGYsIGtleSwgc2l6ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaW1wbGUgaGFzaCBmdW5jdGlvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGtleSAlIHNpemVcXG5cXG4gICAgZGVmIF9yZWhhc2goc2VsZiwgb2xkX2hhc2gsIHNpemUsIHN0ZXA9MSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaW1wbGUgcmVoYXNoIGZ1bmN0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gKG9sZF9oYXNoICsgc3RlcCkgJSBzaXplXFxuXFxuICAgIGRlZiBpc19lbXB0eShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIHRoZSB0YWJsZSBpcyBlbXB0eVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NpemUgPT0gc2VsZi5fc2xvdHMuY291bnQoTm9uZSlcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0YWJsZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NpemUgLSBzZWxmLl9zbG90cy5jb3VudChOb25lKVxcblxcbiAgICBkZWYgcHV0KHNlbGYsIGtleSwgZGF0YSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaXRlbSB0byB0aGUgdGFibGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGhhc2hfdmFsdWUgPSBzZWxmLl9oYXNoX2Z1bmN0aW9uKGtleSwgbGVuKHNlbGYuX3Nsb3RzKSlcXG5cXG4gICAgICAgIGlmIHNlbGYuX3Nsb3RzW2hhc2hfdmFsdWVdIGlzIE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5fc2xvdHNbaGFzaF92YWx1ZV0gPSBrZXlcXG4gICAgICAgICAgICBzZWxmLl9kYXRhW2hhc2hfdmFsdWVdID0gZGF0YVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBzZWxmLl9zbG90c1toYXNoX3ZhbHVlXSA9PSBrZXk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX2RhdGFbaGFzaF92YWx1ZV0gPSBkYXRhICAjIHJlcGxhY2VcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBqID0gMFxcbiAgICAgICAgICAgICAgICBuZXh0X3Nsb3QgPSBzZWxmLl9yZWhhc2goaGFzaF92YWx1ZSwgbGVuKHNlbGYuX3Nsb3RzKSwgailcXG4gICAgICAgICAgICAgICAgd2hpbGUgKFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2xvdHNbbmV4dF9zbG90XSBpcyBub3QgTm9uZVxcbiAgICAgICAgICAgICAgICAgICAgYW5kIHNlbGYuX3Nsb3RzW25leHRfc2xvdF0gIT0ga2V5XFxuICAgICAgICAgICAgICAgICAgICBhbmQgaiA8IHNlbGYuX3NpemVcXG4gICAgICAgICAgICAgICAgKTpcXG4gICAgICAgICAgICAgICAgICAgIGogPSBqICsgMVxcbiAgICAgICAgICAgICAgICAgICAgbmV4dF9zbG90ID0gc2VsZi5fcmVoYXNoKGhhc2hfdmFsdWUsIGxlbihzZWxmLl9zbG90cyksIGopXFxuXFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuX3Nsb3RzW25leHRfc2xvdF0gaXMgTm9uZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Nsb3RzW25leHRfc2xvdF0gPSBrZXlcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RhdGFbbmV4dF9zbG90XSA9IGRhdGFcXG4gICAgICAgICAgICAgICAgZWxpZiBqID09IHNlbGYuX3NpemU6XFxuICAgICAgICAgICAgICAgICAgICByYWlzZSBFeGNlcHRpb24oXFxcIkhhc2ggVGFibGUgaXMgZnVsbFxcXCIpXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kYXRhW25leHRfc2xvdF0gPSBkYXRhICAjIHJlcGxhY2VcXG5cXG4gICAgZGVmIGdldChzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGFuIGl0ZW0gZnJvbSB0aGUgdGFibGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHN0YXJ0X3Nsb3QgPSBzZWxmLl9oYXNoX2Z1bmN0aW9uKGtleSwgbGVuKHNlbGYuX3Nsb3RzKSlcXG4gICAgICAgIHBvc2l0aW9uID0gc3RhcnRfc2xvdFxcbiAgICAgICAgaiA9IDBcXG5cXG4gICAgICAgIHdoaWxlIHNlbGYuX3Nsb3RzW3Bvc2l0aW9uXSBpcyBub3QgTm9uZSBhbmQgaiA8IHNlbGYuX3NpemU6XFxuICAgICAgICAgICAgaWYgc2VsZi5fc2xvdHNbcG9zaXRpb25dID09IGtleTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2RhdGFbcG9zaXRpb25dXFxuICAgICAgICAgICAgaiA9IGogKyAxXFxuICAgICAgICAgICAgcG9zaXRpb24gPSBzZWxmLl9yZWhhc2goc3RhcnRfc2xvdCwgbGVuKHNlbGYuX3Nsb3RzKSwgailcXG5cXG4gICAgICAgIHJhaXNlIEtleUVycm9yKFxcXCJ7fSBpcyBub3QgaW4gdGhlIHRhYmxlXFxcIi5mb3JtYXQoa2V5KSlcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3NvcnRpbmcvX19pbml0X18ucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5weXRob25kczMuc29ydGluZyBpbXBvcnQgc3RhdGVtZW50XFxuXFxcIlxcXCJcXFwiXFxuZnJvbSBweXRob25kczMuc29ydGluZy5zb3J0aW5nX2FsZ29yaXRobXMgaW1wb3J0IGJ1YmJsZV9zb3J0XFxuZnJvbSBweXRob25kczMuc29ydGluZy5zb3J0aW5nX2FsZ29yaXRobXMgaW1wb3J0IHNlbGVjdF9zb3J0XFxuZnJvbSBweXRob25kczMuc29ydGluZy5zb3J0aW5nX2FsZ29yaXRobXMgaW1wb3J0IGluc2VydF9zb3J0XFxuZnJvbSBweXRob25kczMuc29ydGluZy5zb3J0aW5nX2FsZ29yaXRobXMgaW1wb3J0IHNoZWxsX3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgbWVyZ2Vfc29ydFxcbmZyb20gcHl0aG9uZHMzLnNvcnRpbmcuc29ydGluZ19hbGdvcml0aG1zIGltcG9ydCBxdWlja19zb3J0XFxuZnJvbSBweXRob25kczMuc29ydGluZy5zb3J0aW5nX2FsZ29yaXRobXMgaW1wb3J0IGhlYXBfc29ydFxcblwiLFwic3JjL2xpYi9weXRob25kczMvc29ydGluZy9zb3J0aW5nX2FsZ29yaXRobXMucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuaW1wb3J0IGhlYXBxXFxuXFxuXFxuZGVmIGJ1YmJsZV9zb3J0KGxzdCk6XFxuICAgIFxcXCJcXFwiXFxcIkJ1YmJsZSBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIGZvciBpIGluIHJhbmdlKGxlbihsc3QpIC0gMSwgMCwgLTEpOlxcbiAgICAgICAgZXhjaGFuZ2VzID0gRmFsc2VcXG4gICAgICAgIGZvciBqIGluIHJhbmdlKGkpOlxcbiAgICAgICAgICAgIGlmIGxzdFtqXSA+IGxzdFtqICsgMV06XFxuICAgICAgICAgICAgICAgIGV4Y2hhbmdlcyA9IFRydWVcXG4gICAgICAgICAgICAgICAgbHN0W2pdLCBsc3RbaiArIDFdID0gbHN0W2ogKyAxXSwgbHN0W2pdXFxuICAgICAgICBpZiBub3QgZXhjaGFuZ2VzOlxcbiAgICAgICAgICAgIGJyZWFrXFxuXFxuXFxuZGVmIHNlbGVjdF9zb3J0KGxzdCk6XFxuICAgIFxcXCJcXFwiXFxcIlNlbGVjdGlvbiBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIGZvciBpLCBpdGVtIGluIGVudW1lcmF0ZShsc3QpOlxcbiAgICAgICAgbWluX2lkeCA9IGxlbihsc3QpIC0gMVxcbiAgICAgICAgZm9yIGogaW4gcmFuZ2UoaSwgbGVuKGxzdCkpOlxcbiAgICAgICAgICAgIGlmIGxzdFtqXSA8IGxzdFttaW5faWR4XTpcXG4gICAgICAgICAgICAgICAgbWluX2lkeCA9IGpcXG4gICAgICAgIGlmIG1pbl9pZHggIT0gaTpcXG4gICAgICAgICAgICBsc3RbbWluX2lkeF0sIGxzdFtpXSA9IGxzdFtpXSwgbHN0W21pbl9pZHhdXFxuXFxuXFxuZGVmIGluc2VydF9zb3J0KGxzdCk6XFxuICAgIFxcXCJcXFwiXFxcIkluc2VydGlvbiBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIGZvciBpIGluIHJhbmdlKDEsIGxlbihsc3QpKTpcXG4gICAgICAgIGN1cl92YWwgPSBsc3RbaV1cXG4gICAgICAgIGN1cl9wb3MgPSBpXFxuXFxuICAgICAgICB3aGlsZSBjdXJfcG9zID4gMCBhbmQgbHN0W2N1cl9wb3MgLSAxXSA+IGN1cl92YWw6XFxuICAgICAgICAgICAgbHN0W2N1cl9wb3NdID0gbHN0W2N1cl9wb3MgLSAxXVxcbiAgICAgICAgICAgIGN1cl9wb3MgPSBjdXJfcG9zIC0gMVxcbiAgICAgICAgbHN0W2N1cl9wb3NdID0gY3VyX3ZhbFxcblxcblxcbmRlZiBzaGVsbF9zb3J0KGxzdCk6XFxuICAgIFxcXCJcXFwiXFxcIlNoZWxsIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgc3VibGlzdF9jb3VudCA9IGxlbihsc3QpIC8vIDNcXG4gICAgd2hpbGUgc3VibGlzdF9jb3VudCA+IDA6XFxuICAgICAgICBmb3IgcG9zX3N0YXJ0IGluIHJhbmdlKHN1Ymxpc3RfY291bnQpOlxcbiAgICAgICAgICAgIF9nYXBfaW5zZXJ0X3NvcnQobHN0LCBwb3Nfc3RhcnQsIHN1Ymxpc3RfY291bnQpXFxuICAgICAgICBzdWJsaXN0X2NvdW50ID0gc3VibGlzdF9jb3VudCAvLyAyXFxuXFxuXFxuZGVmIF9nYXBfaW5zZXJ0X3NvcnQobHN0LCBzdGFydCwgZ2FwKTpcXG4gICAgXFxcIlxcXCJcXFwiU2hlbGwgc29ydCBoZWxwZXIgZnVuY3Rpb25cXFwiXFxcIlxcXCJcXG4gICAgZm9yIGkgaW4gcmFuZ2Uoc3RhcnQgKyBnYXAsIGxlbihsc3QpLCBnYXApOlxcbiAgICAgICAgY3VyX3ZhbCA9IGxzdFtpXVxcbiAgICAgICAgY3VyX3BvcyA9IGlcXG4gICAgICAgIHdoaWxlIGN1cl9wb3MgPj0gZ2FwIGFuZCBsc3RbY3VyX3BvcyAtIGdhcF0gPiBjdXJfdmFsOlxcbiAgICAgICAgICAgIGxzdFtjdXJfcG9zXSA9IGxzdFtjdXJfcG9zIC0gZ2FwXVxcbiAgICAgICAgICAgIGN1cl9wb3MgPSBjdXJfcG9zIC0gZ2FwXFxuICAgICAgICBsc3RbY3VyX3Bvc10gPSBjdXJfdmFsXFxuXFxuXFxuZGVmIG1lcmdlX3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiTWVyZ2Ugc29ydFxcXCJcXFwiXFxcIlxcbiAgICBpZiBsZW4obHN0KSA+IDE6XFxuICAgICAgICBtaWQgPSBsZW4obHN0KSAvLyAyXFxuICAgICAgICBsZWZ0X2hhbGYgPSBsc3RbOm1pZF1cXG4gICAgICAgIHJpZ2h0X2hhbGYgPSBsc3RbbWlkOl1cXG5cXG4gICAgICAgIG1lcmdlX3NvcnQobGVmdF9oYWxmKVxcbiAgICAgICAgbWVyZ2Vfc29ydChyaWdodF9oYWxmKVxcblxcbiAgICAgICAgaSwgaiwgayA9IDAsIDAsIDBcXG4gICAgICAgIHdoaWxlIGkgPCBsZW4obGVmdF9oYWxmKSBhbmQgaiA8IGxlbihyaWdodF9oYWxmKTpcXG4gICAgICAgICAgICBpZiBsZWZ0X2hhbGZbaV0gPD0gcmlnaHRfaGFsZltqXTpcXG4gICAgICAgICAgICAgICAgbHN0W2tdID0gbGVmdF9oYWxmW2ldXFxuICAgICAgICAgICAgICAgIGkgPSBpICsgMVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGxzdFtrXSA9IHJpZ2h0X2hhbGZbal1cXG4gICAgICAgICAgICAgICAgaiA9IGogKyAxXFxuICAgICAgICAgICAgayA9IGsgKyAxXFxuXFxuICAgICAgICB3aGlsZSBpIDwgbGVuKGxlZnRfaGFsZik6XFxuICAgICAgICAgICAgbHN0W2tdID0gbGVmdF9oYWxmW2ldXFxuICAgICAgICAgICAgaSA9IGkgKyAxXFxuICAgICAgICAgICAgayA9IGsgKyAxXFxuXFxuICAgICAgICB3aGlsZSBqIDwgbGVuKHJpZ2h0X2hhbGYpOlxcbiAgICAgICAgICAgIGxzdFtrXSA9IHJpZ2h0X2hhbGZbal1cXG4gICAgICAgICAgICBqID0gaiArIDFcXG4gICAgICAgICAgICBrID0gayArIDFcXG5cXG5cXG5kZWYgcXVpY2tfc29ydChsc3QpOlxcbiAgICBcXFwiXFxcIlxcXCJRdWljayBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIF9xdWlja19zb3J0X2hlbHAobHN0LCAwLCBsZW4obHN0KSAtIDEpXFxuXFxuXFxuZGVmIF9xdWlja19zb3J0X2hlbHAobHN0LCBtYXJrX2wsIG1hcmtfcik6XFxuICAgIFxcXCJcXFwiXFxcIlF1aWNrIHNvcnQgaGVscGVyXFxcIlxcXCJcXFwiXFxuICAgIGlmIG1hcmtfbCA8IG1hcmtfcjpcXG4gICAgICAgIHNwbGl0ID0gX3F1aWNrX3NvcnRfcGFydChsc3QsIG1hcmtfbCwgbWFya19yKVxcbiAgICAgICAgX3F1aWNrX3NvcnRfaGVscChsc3QsIG1hcmtfbCwgc3BsaXQgLSAxKVxcbiAgICAgICAgX3F1aWNrX3NvcnRfaGVscChsc3QsIHNwbGl0ICsgMSwgbWFya19yKVxcblxcblxcbmRlZiBfcXVpY2tfc29ydF9wYXJ0KGxzdCwgbWFya19sLCBtYXJrX3IpOlxcbiAgICBcXFwiXFxcIlxcXCJRdWljayBzb3J0IHBhcnRpdGlvblxcXCJcXFwiXFxcIlxcbiAgICBwaXZvdF92YWwgPSBsc3RbbWFya19sXVxcbiAgICBtYXJrX2xfY3VyID0gbWFya19sICsgMVxcbiAgICBtYXJrX3JfY3VyID0gbWFya19yXFxuICAgIGRvbmUgPSBGYWxzZVxcblxcbiAgICB3aGlsZSBub3QgZG9uZTpcXG4gICAgICAgIHdoaWxlIG1hcmtfbF9jdXIgPD0gbWFya19yX2N1ciBhbmQgbHN0W21hcmtfbF9jdXJdIDw9IHBpdm90X3ZhbDpcXG4gICAgICAgICAgICBtYXJrX2xfY3VyID0gbWFya19sX2N1ciArIDFcXG4gICAgICAgIHdoaWxlIG1hcmtfbF9jdXIgPD0gbWFya19yX2N1ciBhbmQgbHN0W21hcmtfcl9jdXJdID49IHBpdm90X3ZhbDpcXG4gICAgICAgICAgICBtYXJrX3JfY3VyID0gbWFya19yX2N1ciAtIDFcXG4gICAgICAgIGlmIG1hcmtfcl9jdXIgPCBtYXJrX2xfY3VyOlxcbiAgICAgICAgICAgIGRvbmUgPSBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGxzdFttYXJrX2xfY3VyXSwgbHN0W21hcmtfcl9jdXJdID0gbHN0W21hcmtfcl9jdXJdLCBsc3RbbWFya19sX2N1cl1cXG4gICAgbHN0W21hcmtfbF0sIGxzdFttYXJrX3JfY3VyXSA9IGxzdFttYXJrX3JfY3VyXSwgbHN0W21hcmtfbF1cXG5cXG4gICAgcmV0dXJuIG1hcmtfcl9jdXJcXG5cXG5cXG5kZWYgaGVhcF9zb3J0KGxzdCk6XFxuICAgIFxcXCJcXFwiXFxcIkhlYXAgc29ydFxcXCJcXFwiXFxcIlxcbiAgICByZXMgPSBbXVxcbiAgICBoZWFwcS5oZWFwaWZ5KGxzdClcXG4gICAgd2hpbGUgbHN0OlxcbiAgICAgICAgcmVzLmFwcGVuZChoZWFwcS5oZWFwcG9wKGxzdCkpXFxuICAgIGZvciBpIGluIHJlczpcXG4gICAgICAgIGxzdC5hcHBlbmQoaSlcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL19faW5pdF9fLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxucHl0aG9uZHMzLnRyZWVzIGltcG9ydCBzdGF0ZW1lbnRcXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHB5dGhvbmRzMy50cmVlcy5hdmxfdHJlZSBpbXBvcnQgQVZMVHJlZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmJpbmFyeV9zZWFyY2hfdHJlZSBpbXBvcnQgQmluYXJ5U2VhcmNoVHJlZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmJpbmFyeV9oZWFwIGltcG9ydCBCaW5hcnlIZWFwXFxuZnJvbSBweXRob25kczMudHJlZXMuYmluYXJ5X3RyZWUgaW1wb3J0IEJpbmFyeVRyZWVcXG5mcm9tIHB5dGhvbmRzMy50cmVlcy5wcmlvcml0eV9xdWV1ZSBpbXBvcnQgUHJpb3JpdHlRdWV1ZVxcblxcbl9fYWxsX18gPSBbXFxcIkJpbmFyeVRyZWVcXFwiLCBcXFwiQmluYXJ5SGVhcFxcXCIsIFxcXCJCaW5hcnlTZWFyY2hUcmVlXFxcIiwgXFxcIkFWTFRyZWVcXFwiLCBcXFwiUHJpb3JpdHlRdWV1ZVxcXCJdXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy90cmVlcy9hdmxfdHJlZS5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNSwgMjAxMFxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5mcm9tIHB5dGhvbmRzMy50cmVlcy5iaW5hcnlfc2VhcmNoX3RyZWUgaW1wb3J0IEJpbmFyeVNlYXJjaFRyZWVcXG5mcm9tIHB5dGhvbmRzMy50cmVlcy5iaW5hcnlfc2VhcmNoX3RyZWUgaW1wb3J0IEJpbmFyeVRyZWVOb2RlXFxuXFxuXFxuY2xhc3MgQVZMVHJlZU5vZGUoQmluYXJ5VHJlZU5vZGUpOlxcbiAgICBcXFwiXFxcIlxcXCJBVkwgVHJlZSBOb2RlXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBrZXksIHZhbCwgYmFsYW5jZV9mYWN0b3IsIGxlZnQ9Tm9uZSwgcmlnaHQ9Tm9uZSwgcGFyZW50PU5vbmUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIGFuIEFWTCB0cmVlIG5vZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLl9faW5pdF9fKHNlbGYsIGtleSwgdmFsLCBsZWZ0LCByaWdodCwgcGFyZW50KVxcbiAgICAgICAgc2VsZi5fYmFsYW5jZV9mYWN0b3IgPSBiYWxhbmNlX2ZhY3RvclxcblxcbiAgICBkZWYgZ2V0X2JhbGFuY2VfZmFjdG9yKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHRoZSBub2RlIGJhbGFuY2UgZmFjdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fYmFsYW5jZV9mYWN0b3JcXG5cXG4gICAgZGVmIHNldF9iYWxhbmNlX2ZhY3RvcihzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgdGhlIG5vZGUgYmFsYW5jZSBmYWN0b3JcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2JhbGFuY2VfZmFjdG9yID0gdmFsdWVcXG5cXG4gICAgYmFsYW5jZV9mYWN0b3IgPSBwcm9wZXJ0eShnZXRfYmFsYW5jZV9mYWN0b3IsIHNldF9iYWxhbmNlX2ZhY3RvcilcXG5cXG5cXG5jbGFzcyBBVkxUcmVlKEJpbmFyeVNlYXJjaFRyZWUpOlxcbiAgICBcXFwiXFxcIlxcXCJBVkwgdHJlZSBpbXBsZW1lbnRhdGlvblxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgYSBuZXcgQVZMIHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIEJpbmFyeVNlYXJjaFRyZWUuX19pbml0X18oc2VsZilcXG5cXG4gICAgZGVmIHB1dChzZWxmLCBrZXksIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fcm9vdDpcXG4gICAgICAgICAgICBzZWxmLl9wdXQoa2V5LCB2YWx1ZSwgc2VsZi5fcm9vdClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5fcm9vdCA9IEFWTFRyZWVOb2RlKGtleSwgdmFsdWUsIDApXFxuICAgICAgICBzZWxmLl9zaXplID0gc2VsZi5fc2l6ZSArIDFcXG5cXG4gICAgZGVmIF9wdXQoc2VsZiwga2V5LCB2YWx1ZSwgY3VycmVudF9ub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhIG5ldyBub2RlIHRvIHRoZSB0cmVlIChoZWxwZXIgZnVuY3Rpb24pXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBrZXkgPCBjdXJyZW50X25vZGUua2V5OlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZS5nZXRfY2hpbGRfbGVmdCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wdXQoa2V5LCB2YWx1ZSwgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQgPSBBVkxUcmVlTm9kZShcXG4gICAgICAgICAgICAgICAgICAgIGtleSwgdmFsdWUsIDAsIHBhcmVudD1jdXJyZW50X25vZGVcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZV9iYWxhbmNlKGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBjdXJyZW50X25vZGUuZ2V0X2NoaWxkX3JpZ2h0KCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksIHZhbHVlLCBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0ID0gQVZMVHJlZU5vZGUoXFxuICAgICAgICAgICAgICAgICAgICBrZXksIHZhbHVlLCAwLCBwYXJlbnQ9Y3VycmVudF9ub2RlXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVfYmFsYW5jZShjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiB1cGRhdGVfYmFsYW5jZShzZWxmLCBub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlVwZGF0ZSB0aGUgdHJlZSBiYWxhbmNlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBub2RlLmJhbGFuY2VfZmFjdG9yID4gMSBvciBub2RlLmJhbGFuY2VfZmFjdG9yIDwgLTE6XFxuICAgICAgICAgICAgc2VsZi5yZWJhbGFuY2Uobm9kZSlcXG4gICAgICAgICAgICByZXR1cm5cXG4gICAgICAgIGlmIG5vZGUucGFyZW50OlxcbiAgICAgICAgICAgIGlmIG5vZGUuaXNfY2hpbGRfbGVmdCgpOlxcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5iYWxhbmNlX2ZhY3RvciArPSAxXFxuICAgICAgICAgICAgZWxpZiBub2RlLmlzX2NoaWxkX3JpZ2h0KCk6XFxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmJhbGFuY2VfZmFjdG9yIC09IDFcXG5cXG4gICAgICAgICAgICBpZiBub2RlLnBhcmVudC5iYWxhbmNlX2ZhY3RvciAhPSAwOlxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZV9iYWxhbmNlKG5vZGUucGFyZW50KVxcblxcbiAgICBkZWYgcmViYWxhbmNlKHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmViYWxhbmNlIHRoZSB0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBub2RlLmJhbGFuY2VfZmFjdG9yIDwgMDpcXG4gICAgICAgICAgICBpZiBub2RlLmNoaWxkX3JpZ2h0LmJhbGFuY2VfZmFjdG9yID4gMDpcXG4gICAgICAgICAgICAgICAgIyBEbyBhbiBMUiBSb3RhdGlvblxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZV9yaWdodChub2RlLmNoaWxkX3JpZ2h0KVxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZV9sZWZ0KG5vZGUpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgIyBzaW5nbGUgbGVmdFxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZV9sZWZ0KG5vZGUpXFxuICAgICAgICBlbGlmIG5vZGUuYmFsYW5jZV9mYWN0b3IgPiAwOlxcbiAgICAgICAgICAgIGlmIG5vZGUuY2hpbGRfbGVmdC5iYWxhbmNlX2ZhY3RvciA8IDA6XFxuICAgICAgICAgICAgICAgICMgRG8gYW4gUkwgUm90YXRpb25cXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVfbGVmdChub2RlLmNoaWxkX2xlZnQpXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlX3JpZ2h0KG5vZGUpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgIyBzaW5nbGUgcmlnaHRcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVfcmlnaHQobm9kZSlcXG5cXG4gICAgZGVmIHJvdGF0ZV9sZWZ0KHNlbGYsIHJvdGF0aW9uX3Jvb3QpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTGVmdCByb3RhdGlvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgbmV3X3Jvb3QgPSByb3RhdGlvbl9yb290LmNoaWxkX3JpZ2h0XFxuICAgICAgICByb3RhdGlvbl9yb290LmNoaWxkX3JpZ2h0ID0gbmV3X3Jvb3QuY2hpbGRfbGVmdFxcbiAgICAgICAgaWYgbmV3X3Jvb3QuY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBuZXdfcm9vdC5jaGlsZF9sZWZ0LnBhcmVudCA9IHJvdGF0aW9uX3Jvb3RcXG4gICAgICAgIG5ld19yb290LnBhcmVudCA9IHJvdGF0aW9uX3Jvb3QucGFyZW50XFxuICAgICAgICBpZiByb3RhdGlvbl9yb290LmlzX3Jvb3QoKTpcXG4gICAgICAgICAgICBzZWxmLl9yb290ID0gbmV3X3Jvb3RcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgcm90YXRpb25fcm9vdC5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uX3Jvb3QucGFyZW50LmNoaWxkX2xlZnQgPSBuZXdfcm9vdFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uX3Jvb3QucGFyZW50LmNoaWxkX3JpZ2h0ID0gbmV3X3Jvb3RcXG4gICAgICAgIG5ld19yb290LmNoaWxkX2xlZnQgPSByb3RhdGlvbl9yb290XFxuICAgICAgICByb3RhdGlvbl9yb290LnBhcmVudCA9IG5ld19yb290XFxuICAgICAgICByb3RhdGlvbl9yb290LmJhbGFuY2VfZmFjdG9yID0gKFxcbiAgICAgICAgICAgIHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IgKyAxIC0gbWluKG5ld19yb290LmJhbGFuY2VfZmFjdG9yLCAwKVxcbiAgICAgICAgKVxcbiAgICAgICAgbmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IgPSAoXFxuICAgICAgICAgICAgbmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IgKyAxICsgbWF4KHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IsIDApXFxuICAgICAgICApXFxuXFxuICAgIGRlZiByb3RhdGVfcmlnaHQoc2VsZiwgcm90YXRpb25fcm9vdCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSaWdodCByb3RhdGlvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgbmV3X3Jvb3QgPSByb3RhdGlvbl9yb290LmNoaWxkX2xlZnRcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QuY2hpbGRfbGVmdCA9IG5ld19yb290LmNoaWxkX3JpZ2h0XFxuICAgICAgICBpZiBuZXdfcm9vdC5jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBuZXdfcm9vdC5jaGlsZF9yaWdodC5wYXJlbnQgPSByb3RhdGlvbl9yb290XFxuICAgICAgICBuZXdfcm9vdC5wYXJlbnQgPSByb3RhdGlvbl9yb290LnBhcmVudFxcbiAgICAgICAgaWYgcm90YXRpb25fcm9vdC5pc19yb290KCk6XFxuICAgICAgICAgICAgc2VsZi5fcm9vdCA9IG5ld19yb290XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHJvdGF0aW9uX3Jvb3QuaXNfY2hpbGRfcmlnaHQoKTpcXG4gICAgICAgICAgICAgICAgcm90YXRpb25fcm9vdC5wYXJlbnQuY2hpbGRfcmlnaHQgPSBuZXdfcm9vdFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uX3Jvb3QucGFyZW50LmNoaWxkX2xlZnQgPSBuZXdfcm9vdFxcbiAgICAgICAgbmV3X3Jvb3QuY2hpbGRfcmlnaHQgPSByb3RhdGlvbl9yb290XFxuICAgICAgICByb3RhdGlvbl9yb290LnBhcmVudCA9IG5ld19yb290XFxuICAgICAgICByb3RhdGlvbl9yb290LmJhbGFuY2VfZmFjdG9yID0gKFxcbiAgICAgICAgICAgIHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IgLSAxIC0gbWF4KG5ld19yb290LmJhbGFuY2VfZmFjdG9yLCAwKVxcbiAgICAgICAgKVxcbiAgICAgICAgbmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IgPSAoXFxuICAgICAgICAgICAgbmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IgLSAxICsgbWluKHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IsIDApXFxuICAgICAgICApXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy90cmVlcy9iaW5hcnlfaGVhcC5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5cXG5jbGFzcyBCaW5hcnlIZWFwOlxcbiAgICBcXFwiXFxcIlxcXCJNaW5pbWFsIEJpbmFyeSBIZWFwXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhIGhlYXBcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2hlYXAgPSBbXVxcblxcbiAgICBkZWYgX3BlcmNfdXAoc2VsZiwgY3VyX2lkeCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJNb3ZlIGEgbm9kZSB1cFxcXCJcXFwiXFxcIlxcbiAgICAgICAgd2hpbGUgKGN1cl9pZHggLSAxKSAvLyAyID49IDA6XFxuICAgICAgICAgICAgcGFyZW50X2lkeCA9IChjdXJfaWR4IC0gMSkgLy8gMlxcbiAgICAgICAgICAgIGlmIHNlbGYuX2hlYXBbY3VyX2lkeF0gPCBzZWxmLl9oZWFwW3BhcmVudF9pZHhdOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9oZWFwW2N1cl9pZHhdLCBzZWxmLl9oZWFwW3BhcmVudF9pZHhdID0gKFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGVhcFtwYXJlbnRfaWR4XSxcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hlYXBbY3VyX2lkeF0sXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICBjdXJfaWR4ID0gcGFyZW50X2lkeFxcblxcbiAgICBkZWYgX3BlcmNfZG93bihzZWxmLCBjdXJfaWR4KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIk1vdmUgYSBub2RlIGRvd25cXFwiXFxcIlxcXCJcXG4gICAgICAgIHdoaWxlIDIgKiBjdXJfaWR4ICsgMSA8IGxlbihzZWxmLl9oZWFwKTpcXG4gICAgICAgICAgICBtaW5fY2hpbGRfaWR4ID0gc2VsZi5fZ2V0X21pbl9jaGlsZChjdXJfaWR4KVxcbiAgICAgICAgICAgIGlmIHNlbGYuX2hlYXBbY3VyX2lkeF0gPiBzZWxmLl9oZWFwW21pbl9jaGlsZF9pZHhdOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9oZWFwW2N1cl9pZHhdLCBzZWxmLl9oZWFwW21pbl9jaGlsZF9pZHhdID0gKFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGVhcFttaW5fY2hpbGRfaWR4XSxcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hlYXBbY3VyX2lkeF0sXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICBjdXJfaWR4ID0gbWluX2NoaWxkX2lkeFxcblxcbiAgICBkZWYgX2dldF9taW5fY2hpbGQoc2VsZiwgcGFyZW50X2lkeCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgYSBzbWFsbGVyIGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiAyICogcGFyZW50X2lkeCArIDIgPiBsZW4oc2VsZi5faGVhcCkgLSAxOlxcbiAgICAgICAgICAgIHJldHVybiAyICogcGFyZW50X2lkeCArIDFcXG4gICAgICAgIGlmIHNlbGYuX2hlYXBbMiAqIHBhcmVudF9pZHggKyAxXSA8IHNlbGYuX2hlYXBbMiAqIHBhcmVudF9pZHggKyAyXTpcXG4gICAgICAgICAgICByZXR1cm4gMiAqIHBhcmVudF9pZHggKyAxXFxuICAgICAgICByZXR1cm4gMiAqIHBhcmVudF9pZHggKyAyXFxuXFxuICAgIGRlZiBoZWFwaWZ5KHNlbGYsIG5vdF9hX2hlYXAsIHNob3dfZGV0YWlscz1GYWxzZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJCdWlsZCBhIGhlYXAgZnJvbSBhbnkgbGlzdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faGVhcCA9IG5vdF9hX2hlYXBbOl1cXG4gICAgICAgIGN1cl9pZHggPSBsZW4oc2VsZi5faGVhcCkgLy8gMiAtIDFcXG4gICAgICAgIHdoaWxlIGN1cl9pZHggPj0gMDpcXG4gICAgICAgICAgICBzZWxmLl9wZXJjX2Rvd24oY3VyX2lkeClcXG4gICAgICAgICAgICBjdXJfaWR4ID0gY3VyX2lkeCAtIDFcXG4gICAgICAgICAgICBpZiBzaG93X2RldGFpbHM6XFxuICAgICAgICAgICAgICAgIHByaW50KHNlbGYuX2hlYXApXFxuXFxuICAgIGRlZiBpbnNlcnQoc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSBuZXcgaXRlbVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faGVhcC5hcHBlbmQoaXRlbSlcXG4gICAgICAgIHNlbGYuX3BlcmNfdXAobGVuKHNlbGYuX2hlYXApIC0gMSlcXG5cXG4gICAgZGVmIGRlbGV0ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhbiBpdGVtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9oZWFwWzBdLCBzZWxmLl9oZWFwWy0xXSA9IHNlbGYuX2hlYXBbLTFdLCBzZWxmLl9oZWFwWzBdXFxuICAgICAgICByZXN1bHQgPSBzZWxmLl9oZWFwLnBvcCgpXFxuICAgICAgICBzZWxmLl9wZXJjX2Rvd24oMClcXG4gICAgICAgIHJldHVybiByZXN1bHRcXG5cXG4gICAgZGVmIGlzX2VtcHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIGhlYXAgaXMgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgYm9vbChzZWxmLl9oZWFwKVxcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBoZWFwIHNpemVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5faGVhcClcXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJIZWFwIGFzIGEgc3RyaW5nXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc3RyKHNlbGYuX2hlYXApXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJfX2NvbnRhaW5zX19pbiBtZXRob2Qgb3ZlcnJpZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBpdGVtIGluIHNlbGYuX2hlYXBcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL2JpbmFyeV9zZWFyY2hfdHJlZS5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNSwgMjAxMFxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5cXG5jbGFzcyBCaW5hcnlUcmVlTm9kZTpcXG4gICAgXFxcIlxcXCJcXFwiQmluYXJ5IFRyZWUgTm9kZSBjbGFzc1xcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZiwga2V5LCB2YWx1ZSwgbGVmdD1Ob25lLCByaWdodD1Ob25lLCBwYXJlbnQ9Tm9uZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgbmV3IFRyZWUgTm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fa2V5ID0ga2V5XFxuICAgICAgICBzZWxmLl92YWx1ZSA9IHZhbHVlXFxuICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0ID0gbGVmdFxcbiAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQgPSByaWdodFxcbiAgICAgICAgc2VsZi5fcGFyZW50ID0gcGFyZW50XFxuXFxuICAgIGRlZiBnZXRfY2hpbGRfbGVmdChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgbm9kZSdzIGxlZnQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9jaGlsZF9sZWZ0XFxuXFxuICAgIGRlZiBzZXRfY2hpbGRfbGVmdChzZWxmLCBub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFzc2lnbiB0aGUgbm9kZSdzIGxlZnQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2NoaWxkX2xlZnQgPSBub2RlXFxuXFxuICAgIGNoaWxkX2xlZnQgPSBwcm9wZXJ0eShnZXRfY2hpbGRfbGVmdCwgc2V0X2NoaWxkX2xlZnQpXFxuXFxuICAgIGRlZiBnZXRfY2hpbGRfcmlnaHQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIG5vZGUncyByaWdodCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX3JpZ2h0XFxuXFxuICAgIGRlZiBzZXRfY2hpbGRfcmlnaHQoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBc3NpZ24gdGhlIG5vZGUncyByaWdodCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQgPSBub2RlXFxuXFxuICAgIGNoaWxkX3JpZ2h0ID0gcHJvcGVydHkoZ2V0X2NoaWxkX3JpZ2h0LCBzZXRfY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiBnZXRfcGFyZW50KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBub2RlJ3MgcGFyZW50XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcGFyZW50XFxuXFxuICAgIGRlZiBzZXRfcGFyZW50KHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQXNzaWduIHRoZSBub2RlJ3MgcGFyZW50XFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9wYXJlbnQgPSBub2RlXFxuXFxuICAgIHBhcmVudCA9IHByb3BlcnR5KGdldF9wYXJlbnQsIHNldF9wYXJlbnQpXFxuXFxuICAgIGRlZiBpc19jaGlsZF9sZWZ0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIG5vZGUgaXMgYSBsZWZ0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcGFyZW50IGFuZCBzZWxmLl9wYXJlbnQuY2hpbGRfbGVmdCA9PSBzZWxmXFxuXFxuICAgIGRlZiBpc19jaGlsZF9yaWdodChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIHRoZSBub2RlIGlzIGEgcmlnaHQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9wYXJlbnQgYW5kIHNlbGYuX3BhcmVudC5jaGlsZF9yaWdodCA9PSBzZWxmXFxuXFxuICAgIGRlZiBpc19yb290KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIG5vZGUgaXMgYSB0cmVlIHJvb3RcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3Qgc2VsZi5fcGFyZW50XFxuXFxuICAgIGRlZiBpc19sZWFmKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIG5vZGUgaXMgYSBsZWFmXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gbm90IChzZWxmLl9jaGlsZF9yaWdodCBvciBzZWxmLl9jaGlsZF9sZWZ0KVxcblxcbiAgICBkZWYgaGFzX2FfY2hpbGQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBoYXMgYW55IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY2hpbGRfcmlnaHQgb3Igc2VsZi5fY2hpbGRfbGVmdFxcblxcbiAgICBkZWYgaGFzX2NoaWxkcmVuKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIG5vZGUgaGFzIGJvdGggY2hpbGRyZW5cXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9jaGlsZF9yaWdodCBhbmQgc2VsZi5fY2hpbGRfbGVmdFxcblxcbiAgICBkZWYgZ2V0X2tleShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBub2RlIGtleVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2tleVxcblxcbiAgICBkZWYgc2V0X2tleShzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IG5vZGUga2V5XFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9rZXkgPSBrZXlcXG5cXG4gICAga2V5ID0gcHJvcGVydHkoZ2V0X2tleSwgc2V0X2tleSlcXG5cXG4gICAgZGVmIGdldF92YWx1ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBub2RlIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fdmFsdWVcXG5cXG4gICAgZGVmIHNldF92YWx1ZShzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbm9kZSB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fdmFsdWUgPSB2YWx1ZVxcblxcbiAgICB2YWx1ZSA9IHByb3BlcnR5KGdldF92YWx1ZSwgc2V0X3ZhbHVlKVxcblxcbiAgICBkZWYgcmVwbGFjZV9wYXlsb2FkKHNlbGYsIGtleSwgdmFsdWUsIGxlZnQsIHJpZ2h0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoYW5nZSBub2RlIHBheWxvYWRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2tleSA9IGtleVxcbiAgICAgICAgc2VsZi5fdmFsdWUgPSB2YWx1ZVxcbiAgICAgICAgc2VsZi5fY2hpbGRfbGVmdCA9IGxlZnRcXG4gICAgICAgIHNlbGYuX2NoaWxkX3JpZ2h0ID0gcmlnaHRcXG4gICAgICAgIGlmIHNlbGYuY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0LnBhcmVudCA9IHNlbGZcXG4gICAgICAgIGlmIHNlbGYuY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQucGFyZW50ID0gc2VsZlxcblxcbiAgICBkZWYgZmluZF9zdWNjZXNzb3Ioc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJGaW5kIHRoZSBub2RlJ3Mgc3VjY2Vzc29yXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdWNjZXNzb3IgPSBOb25lXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzdWNjZXNzb3IgPSBzZWxmLl9jaGlsZF9yaWdodC5maW5kX21pbigpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHNlbGYuX3BhcmVudDpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzb3IgPSBzZWxmLl9wYXJlbnRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3BhcmVudC5jaGlsZF9yaWdodCA9IE5vbmVcXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NvciA9IHNlbGYuX3BhcmVudC5maW5kX3N1Y2Nlc3NvcigpXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfcmlnaHQgPSBzZWxmXFxuICAgICAgICByZXR1cm4gc3VjY2Vzc29yXFxuXFxuICAgIGRlZiBmaW5kX21pbihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZpbmQgdGhlIHNtYWxsZXN0IG5vZGUgaW4gdGhlIHJpZ2h0IHN1YnRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmXFxuICAgICAgICB3aGlsZSBjdXJyZW50LmNoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGRfbGVmdFxcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRcXG5cXG4gICAgZGVmIHNwbGljZV9vdXQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTcGxpY2Ugb3V0XFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLmlzX2xlYWYoKTpcXG4gICAgICAgICAgICBpZiBzZWxmLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX2xlZnQgPSBOb25lXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX3JpZ2h0ID0gTm9uZVxcbiAgICAgICAgZWxpZiBzZWxmLmhhc19hX2NoaWxkKCk6XFxuICAgICAgICAgICAgaWYgc2VsZi5jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3BhcmVudC5jaGlsZF9sZWZ0ID0gc2VsZi5fY2hpbGRfbGVmdFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX3JpZ2h0ID0gc2VsZi5fY2hpbGRfbGVmdFxcbiAgICAgICAgICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0LnBhcmVudCA9IHNlbGYuX3BhcmVudFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNfY2hpbGRfbGVmdCgpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX2xlZnQgPSBzZWxmLl9jaGlsZF9yaWdodFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX3JpZ2h0ID0gc2VsZi5fY2hpbGRfcmlnaHRcXG4gICAgICAgICAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQucGFyZW50ID0gc2VsZi5fcGFyZW50XFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlRoZSBzdGFuZGFyZCBpbm9yZGVyIHRyYXZlcnNhbCBvZiBhIGJpbmFyeSB0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmOlxcbiAgICAgICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgICAgIGZvciBlbGVtIGluIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBlbGVtXFxuICAgICAgICAgICAgeWllbGQgc2VsZi5fa2V5XFxuICAgICAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgICAgIGZvciBlbGVtIGluIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZWxlbVxcblxcblxcbmNsYXNzIEJpbmFyeVNlYXJjaFRyZWU6XFxuICAgIFxcXCJcXFwiXFxcIkJpbmFyeSBzZWFyY2ggdHJlZSBpbXBsZW1lbnRhdGlvblxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLl9yb290ID0gTm9uZVxcbiAgICAgICAgc2VsZi5fc2l6ZSA9IDBcXG5cXG4gICAgZGVmIF9fbGVuX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJUcmVlIHNpemVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9zaXplXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVHJlZSBzaXplXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fc2l6ZVxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJJdGVyYXRvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3Jvb3QuX19pdGVyX18oKVxcblxcbiAgICBkZWYgX19nZXRpdGVtX18oc2VsZiwga2V5KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIltdIGdldHRlciBvcGVyYXRvciBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5nZXQoa2V5KVxcbiAgICAgICAgaWYgcmVzdWx0OlxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgICAgIHJhaXNlIEtleUVycm9yKFxcXCJFcnJvciwga2V5IG5vdCBpbiB0cmVlXFxcIilcXG5cXG4gICAgZGVmIGdldF9yb290KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHRyZWUgcm9vdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3Jvb3RcXG5cXG4gICAgZGVmIHNldF9yb290KHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHRyZWUgcm9vdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fcm9vdCA9IG5vZGVcXG5cXG4gICAgcm9vdCA9IHByb3BlcnR5KGdldF9yb290LCBzZXRfcm9vdClcXG5cXG4gICAgZGVmIGdldChzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0cmlldmUgYSB2YWx1ZSBieSB0aGUga2V5XFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl9yb290OlxcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuX2dldChrZXksIHNlbGYuX3Jvb3QpXFxuICAgICAgICAgICAgaWYgcmVzdWx0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlXFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG5cXG4gICAgZGVmIF9nZXQoc2VsZiwga2V5LCBjdXJyZW50X25vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0cmlldmUgYSB2YWx1ZSBieSB0aGUga2V5IChoZWxwZXIgZnVuY3Rpb24pXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBub3QgY3VycmVudF9ub2RlOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuICAgICAgICBpZiBjdXJyZW50X25vZGUua2V5ID09IGtleTpcXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudF9ub2RlXFxuICAgICAgICBlbGlmIGtleSA8IGN1cnJlbnRfbm9kZS5rZXk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldChrZXksIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0KGtleSwgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0KVxcblxcbiAgICBkZWYgX19zZXRpdGVtX18oc2VsZiwga2V5LCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJbXSBzZXR0ZXIgb3BlcmF0b3Igb3ZlcnJpZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYucHV0KGtleSwgdmFsdWUpXFxuXFxuICAgIGRlZiBwdXQoc2VsZiwga2V5LCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgbmV3IG5vZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX3Jvb3Q6XFxuICAgICAgICAgICAgc2VsZi5fcHV0KGtleSwgdmFsdWUsIHNlbGYuX3Jvb3QpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNlbGYuX3Jvb3QgPSBCaW5hcnlUcmVlTm9kZShrZXksIHZhbHVlKVxcbiAgICAgICAgc2VsZi5fc2l6ZSA9IHNlbGYuX3NpemUgKyAxXFxuXFxuICAgIGRlZiBfcHV0KHNlbGYsIGtleSwgdmFsdWUsIGN1cnJlbnRfbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgbmV3IG5vZGUgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGtleSA8IGN1cnJlbnRfbm9kZS5rZXk6XFxuICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksIHZhbHVlLCBjdXJyZW50X25vZGUuY2hpbGRfbGVmdClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdCA9IEJpbmFyeVRyZWVOb2RlKFxcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgcGFyZW50PWN1cnJlbnRfbm9kZVxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSwgdmFsdWUsIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQgPSBCaW5hcnlUcmVlTm9kZShcXG4gICAgICAgICAgICAgICAgICAgIGtleSwgdmFsdWUsIHBhcmVudD1jdXJyZW50X25vZGVcXG4gICAgICAgICAgICAgICAgKVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJpbiBvcGVyYXRvciBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGJvb2woc2VsZi5fZ2V0KGtleSwgc2VsZi5fcm9vdCkpXFxuXFxuICAgIGRlZiBfX2RlbGl0ZW1fXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiZGVsIG9wZXJhdG9yIG92ZXJyaWRlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLmRlbGV0ZShrZXkpXFxuXFxuICAgIGRlZiBkZWxldGUoc2VsZiwga2V5KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhIG5vZGUgYnkgaXRzIGtleVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fc2l6ZSA+IDE6XFxuICAgICAgICAgICAgbm9kZV90b19yZW1vdmUgPSBzZWxmLl9nZXQoa2V5LCBzZWxmLl9yb290KVxcbiAgICAgICAgICAgIGlmIG5vZGVfdG9fcmVtb3ZlOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWxldGUobm9kZV90b19yZW1vdmUpXFxuICAgICAgICAgICAgICAgIHNlbGYuX3NpemUgPSBzZWxmLl9zaXplIC0gMVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJhaXNlIEtleUVycm9yKFxcXCJFcnJvciwga2V5IG5vdCBpbiB0cmVlXFxcIilcXG4gICAgICAgIGVsaWYgc2VsZi5fc2l6ZSA9PSAxIGFuZCBzZWxmLl9yb290LmtleSA9PSBrZXk6XFxuICAgICAgICAgICAgc2VsZi5fcm9vdCA9IE5vbmVcXG4gICAgICAgICAgICBzZWxmLl9zaXplID0gc2VsZi5fc2l6ZSAtIDFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoXFxcIkVycm9yLCBrZXkgbm90IGluIHRyZWVcXFwiKVxcblxcbiAgICBkZWYgX2RlbGV0ZShzZWxmLCBjdXJyZW50X25vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGEgbm9kZSBieSBpdHMga2V5IChoZWxwZXIgZnVuY3Rpb24pXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBjdXJyZW50X25vZGUuaXNfbGVhZigpOiAgIyByZW1vdmluZyBhIGxlYWZcXG4gICAgICAgICAgICBpZiBjdXJyZW50X25vZGUgPT0gY3VycmVudF9ub2RlLnBhcmVudC5jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX2xlZnQgPSBOb25lXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLnBhcmVudC5jaGlsZF9yaWdodCA9IE5vbmVcXG4gICAgICAgIGVsaWYgY3VycmVudF9ub2RlLmhhc19jaGlsZHJlbigpOiAgIyByZW1vdmluZyBhIG5vZGUgd2l0aCB0d28gY2hpbGRyZW5cXG4gICAgICAgICAgICBzdWNjZXNzb3IgPSBjdXJyZW50X25vZGUuZmluZF9zdWNjZXNzb3IoKVxcbiAgICAgICAgICAgIHN1Y2Nlc3Nvci5zcGxpY2Vfb3V0KClcXG4gICAgICAgICAgICBjdXJyZW50X25vZGUua2V5ID0gc3VjY2Vzc29yLmtleVxcbiAgICAgICAgICAgIGN1cnJlbnRfbm9kZS52YWx1ZSA9IHN1Y2Nlc3Nvci52YWx1ZVxcbiAgICAgICAgZWxzZTogICMgcmVtb3ZpbmcgYSBub2RlIHdpdGggb25lIGNoaWxkXFxuICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmdldF9jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZS5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdC5wYXJlbnQgPSBjdXJyZW50X25vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX2xlZnQgPSBjdXJyZW50X25vZGUuY2hpbGRfbGVmdFxcbiAgICAgICAgICAgICAgICBlbGlmIGN1cnJlbnRfbm9kZS5pc19jaGlsZF9yaWdodCgpOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQucGFyZW50ID0gY3VycmVudF9ub2RlLnBhcmVudFxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLnBhcmVudC5jaGlsZF9yaWdodCA9IGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucmVwbGFjZV9wYXlsb2FkKFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LmtleSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdC52YWx1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdC5jaGlsZF9sZWZ0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LmNoaWxkX3JpZ2h0LFxcbiAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZS5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQucGFyZW50ID0gY3VycmVudF9ub2RlLnBhcmVudFxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLnBhcmVudC5jaGlsZF9sZWZ0ID0gY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0XFxuICAgICAgICAgICAgICAgIGVsaWYgY3VycmVudF9ub2RlLmlzX2NoaWxkX3JpZ2h0KCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQucGFyZW50ID0gY3VycmVudF9ub2RlLnBhcmVudFxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLnBhcmVudC5jaGlsZF9yaWdodCA9IGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLnJlcGxhY2VfcGF5bG9hZChcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQua2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC52YWx1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQuY2hpbGRfbGVmdCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQuY2hpbGRfcmlnaHQsXFxuICAgICAgICAgICAgICAgICAgICApXFxuXFxuICAgIGRlZiBpbm9yZGVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSW4tb3JkZXIgdHJlZSB0cmF2ZXJzYWxcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2lub3JkZXIoc2VsZi5fcm9vdClcXG5cXG4gICAgZGVmIF9pbm9yZGVyKHNlbGYsIHRyZWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSW4tb3JkZXIgdHJlZSB0cmF2ZXJzYWwgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHRyZWU6XFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlcih0cmVlLmNoaWxkX2xlZnQpXFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXksIGVuZD1cXFwiIFxcXCIpXFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlcih0cmVlLmNoaWxkX3JpZ2h0KVxcblxcbiAgICBkZWYgcG9zdG9yZGVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUG9zdC1vcmRlciB0cmVlIHRyYXZlcnNhbFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fcG9zdG9yZGVyKHNlbGYuX3Jvb3QpXFxuXFxuICAgIGRlZiBfcG9zdG9yZGVyKHNlbGYsIHRyZWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUG9zdC1vcmRlciB0cmVlIHRyYXZlcnNhbCAoaGVscGVyIGZ1bmN0aW9uKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgdHJlZTpcXG4gICAgICAgICAgICBzZWxmLl9wb3N0b3JkZXIodHJlZS5jaGlsZF9sZWZ0KVxcbiAgICAgICAgICAgIHNlbGYuX3Bvc3RvcmRlcih0cmVlLmNoaWxkX3JpZ2h0KVxcbiAgICAgICAgICAgIHByaW50KHRyZWUua2V5LCBlbmQ9XFxcIiBcXFwiKVxcblxcbiAgICBkZWYgcHJlb3JkZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQcmUtb3JkZXIgdHJlZSB0cmF2ZXJzYWxcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3ByZW9yZGVyKHNlbGYuX3Jvb3QpXFxuXFxuICAgIGRlZiBfcHJlb3JkZXIoc2VsZiwgdHJlZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQcmUtb3JkZXIgdHJlZSB0cmF2ZXJzYWwgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHRyZWU6XFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXksIGVuZD1cXFwiIFxcXCIpXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZXIodHJlZS5jaGlsZF9sZWZ0KVxcbiAgICAgICAgICAgIHNlbGYuX3ByZW9yZGVyKHRyZWUuY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiBjbGVhcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhbGwgbm9kZXNcXFwiXFxcIlxcXCJcXG4gICAgICAgIHdoaWxlIHNlbGYuX3Jvb3Q6XFxuICAgICAgICAgICAgc2VsZi5kZWxldGUoc2VsZi5fcm9vdC5rZXkpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy90cmVlcy9iaW5hcnlfdHJlZS5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5pbXBvcnQgb3BlcmF0b3JcXG5cXG5cXG5jbGFzcyBCaW5hcnlUcmVlOlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgQSByZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgQmluYXJ5IFRyZWVcXG4gICAgVXNpbmcgbGlua3MgYW5kIE5vZGVzIGFwcHJvYWNoLlxcblxcbiAgICBNb2RpZmllZCB0byBhbGxvdyBmb3IgdHJlZXMgdG8gYmUgY29uc3RydWN0ZWQgZnJvbSBvdGhlciB0cmVlc1xcbiAgICByYXRoZXIgdGhhbiBhbHdheXMgY3JlYXRpbmcgYSBuZXcgdHJlZSBpbiB0aGUgaW5zZXJ0X2ZlZnQgb3IgaW5zZXJ0X3JpZ2h0XFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZiwga2V5KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBuZXcgdHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fa2V5ID0ga2V5XFxuICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0ID0gTm9uZVxcbiAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQgPSBOb25lXFxuXFxuICAgIGRlZiBnZXRfcm9vdF92YWwoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgcm9vdCBrZXkgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9rZXlcXG5cXG4gICAgZGVmIHNldF9yb290X3ZhbChzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHJvb3Qga2V5IHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9rZXkgPSBrZXlcXG5cXG4gICAgcm9vdCA9IHByb3BlcnR5KGdldF9yb290X3ZhbCwgc2V0X3Jvb3RfdmFsKVxcblxcbiAgICBkZWYgZ2V0X2NoaWxkX2xlZnQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgbGVmdCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX2xlZnRcXG5cXG4gICAgZGVmIHNldF9jaGlsZF9sZWZ0KHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IGxlZnQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2NoaWxkX2xlZnQgPSBub2RlXFxuXFxuICAgIGNoaWxkX2xlZnQgPSBwcm9wZXJ0eShnZXRfY2hpbGRfbGVmdCwgc2V0X2NoaWxkX2xlZnQpXFxuXFxuICAgIGRlZiBnZXRfY2hpbGRfcmlnaHQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgcmlnaHQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9jaGlsZF9yaWdodFxcblxcbiAgICBkZWYgc2V0X2NoaWxkX3JpZ2h0KHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHJpZ2h0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9jaGlsZF9yaWdodCA9IG5vZGVcXG5cXG4gICAgY2hpbGRfcmlnaHQgPSBwcm9wZXJ0eShnZXRfY2hpbGRfcmlnaHQsIHNldF9jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIGlzX2xlYWYoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiBhIG5vZGUgaXMgbGVhZlxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIChub3Qgc2VsZi5fY2hpbGRfbGVmdCkgYW5kIChub3Qgc2VsZi5fY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiBpbnNlcnRfbGVmdChzZWxmLCBuZXdfbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJJbnNlcnQgbGVmdCBzdWJ0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBpc2luc3RhbmNlKG5ld19ub2RlLCBCaW5hcnlUcmVlKTpcXG4gICAgICAgICAgICBuZXdfc3VidHJlZSA9IG5ld19ub2RlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIG5ld19zdWJ0cmVlID0gQmluYXJ5VHJlZShuZXdfbm9kZSlcXG5cXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgbmV3X3N1YnRyZWUuc2V0X2NoaWxkX2xlZnQoc2VsZi5fY2hpbGRfbGVmdClcXG5cXG4gICAgICAgIHNlbGYuX2NoaWxkX2xlZnQgPSBuZXdfc3VidHJlZVxcblxcbiAgICBkZWYgaW5zZXJ0X3JpZ2h0KHNlbGYsIG5ld19ub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkluc2VydCByaWdodCBzdWJ0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBpc2luc3RhbmNlKG5ld19ub2RlLCBCaW5hcnlUcmVlKTpcXG4gICAgICAgICAgICBuZXdfc3VidHJlZSA9IG5ld19ub2RlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIG5ld19zdWJ0cmVlID0gQmluYXJ5VHJlZShuZXdfbm9kZSlcXG5cXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIG5ld19zdWJ0cmVlLnNldF9jaGlsZF9yaWdodChzZWxmLl9jaGlsZF9yaWdodClcXG4gICAgICAgIHNlbGYuX2NoaWxkX3JpZ2h0ID0gbmV3X3N1YnRyZWVcXG5cXG4gICAgZGVmIHByZW9yZGVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUHJlLW9yZGVyIHRyZWUgdHJhdmVyc2FsXFxcIlxcXCJcXFwiXFxuICAgICAgICBwcmludChzZWxmLl9rZXksIGVuZD1cXFwiIFxcXCIpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX2xlZnQucHJlb3JkZXIoKVxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQucHJlb3JkZXIoKVxcblxcbiAgICBkZWYgaW5vcmRlcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkluLW9yZGVyIHRyZWUgdHJhdmVyc2FsXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX2xlZnQuaW5vcmRlcigpXFxuICAgICAgICBwcmludChzZWxmLl9rZXksIGVuZD1cXFwiIFxcXCIpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5pbm9yZGVyKClcXG5cXG4gICAgZGVmIHBvc3RvcmRlcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlBvc3Qtb3JkZXIgdHJlZSB0cmF2ZXJzYWxcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfbGVmdC5wb3N0b3JkZXIoKVxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQucG9zdG9yZGVyKClcXG4gICAgICAgIHByaW50KHNlbGYuX2tleSwgZW5kPVxcXCIgXFxcIilcXG5cXG4gICAgZGVmIHByaW50X2V4cChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlByaW50IGFuIGV4cHJlc3Npb25cXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgcHJpbnQoXFxcIihcXFwiLCBlbmQ9XFxcIiBcXFwiKVxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX2xlZnQucHJpbnRfZXhwKClcXG4gICAgICAgIHByaW50KHNlbGYuX2tleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX3JpZ2h0LnByaW50X2V4cCgpXFxuICAgICAgICAgICAgcHJpbnQoXFxcIilcXFwiLCBlbmQ9XFxcIiBcXFwiKVxcblxcbiAgICBkZWYgcG9zdG9yZGVyX2V2YWwoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQb3N0b3JkZXIgZXZhbHVhdGlvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgb3BlcmF0aW9ucyA9IHtcXG4gICAgICAgICAgICBcXFwiK1xcXCI6IG9wZXJhdG9yLmFkZCxcXG4gICAgICAgICAgICBcXFwiLVxcXCI6IG9wZXJhdG9yLnN1YixcXG4gICAgICAgICAgICBcXFwiKlxcXCI6IG9wZXJhdG9yLm11bCxcXG4gICAgICAgICAgICBcXFwiL1xcXCI6IG9wZXJhdG9yLnRydWVkaXYsXFxuICAgICAgICB9XFxuICAgICAgICByZXN1bHRfMSA9IE5vbmVcXG4gICAgICAgIHJlc3VsdF8yID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICByZXN1bHRfMSA9IHNlbGYuX2NoaWxkX2xlZnQucG9zdG9yZGVyX2V2YWwoKVxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgcmVzdWx0XzIgPSBzZWxmLl9jaGlsZF9yaWdodC5wb3N0b3JkZXJfZXZhbCgpXFxuICAgICAgICBpZiByZXN1bHRfMSBhbmQgcmVzdWx0XzI6XFxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbnNbc2VsZi5fa2V5XShyZXN1bHRfMSwgcmVzdWx0XzIpXFxuICAgICAgICByZXR1cm4gc2VsZi5fa2V5XFxuXFxuICAgIGRlZiBoZWlnaHQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJIZWlnaHQgb2YgYSB0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBub3Qgc2VsZi5fa2V5OlxcbiAgICAgICAgICAgIHJldHVybiAtMVxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBoZWlnaHRfbGVmdCA9IHNlbGYuX2NoaWxkX2xlZnQuaGVpZ2h0KClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaGVpZ2h0X2xlZnQgPSAtMVxcblxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgaGVpZ2h0X3JpZ2h0ID0gc2VsZi5fY2hpbGRfcmlnaHQuaGVpZ2h0KClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaGVpZ2h0X3JpZ2h0ID0gLTFcXG5cXG4gICAgICAgIHJldHVybiAxICsgbWF4KGhlaWdodF9sZWZ0LCBoZWlnaHRfcmlnaHQpXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2l6ZSBvZiBhIHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLnNpemUoKVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNvdW50IG5vZGVzIGluIGEgdHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgbm90IHNlbGYuX2tleTpcXG4gICAgICAgICAgICByZXR1cm4gMFxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBjaGlsZHJlbl9sZWZ0ID0gc2VsZi5fY2hpbGRfbGVmdC5zaXplKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgY2hpbGRyZW5fbGVmdCA9IDBcXG5cXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIGNoaWxkcmVuX3JpZ2h0ID0gc2VsZi5fY2hpbGRfcmlnaHQuc2l6ZSgpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGNoaWxkcmVuX3JpZ2h0ID0gMFxcblxcbiAgICAgICAgcmV0dXJuIDEgKyBjaGlsZHJlbl9sZWZ0ICsgY2hpbGRyZW5fcmlnaHRcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL3ByaW9yaXR5X3F1ZXVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmJpbmFyeV9oZWFwIGltcG9ydCBCaW5hcnlIZWFwXFxuXFxuXFxuY2xhc3MgUHJpb3JpdHlRdWV1ZShCaW5hcnlIZWFwKTpcXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IGhlYXAgdGFrZXMgKGtleSwgdmFsdWUpIHBhaXJzIHdoZXJlIGtleSBzaWduaWZpZXMgcHJpb3JpdHlcXG4gICAgV2Ugd2lsbCBhc3N1bWUgdGhhdCB0aGUga2V5cyBhcmUgYWxsIGNvbXBhcmFibGUuXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgY2hhbmdlX3ByaW9yaXR5KHNlbGYsIG5ld19wcmlvcml0eSwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hhbmdlIHRoZSBwcmlvcml0eVxcXCJcXFwiXFxcIlxcbiAgICAgICAga2V5X3RvX21vdmUgPSAwXFxuICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4oc2VsZi5faGVhcCkpOlxcbiAgICAgICAgICAgIGlmIHNlbGYuX2hlYXBbaV1bMV0gPT0gdmFsdWU6XFxuICAgICAgICAgICAgICAgIGtleV90b19tb3ZlID0gaVxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgaWYga2V5X3RvX21vdmUgPiAtMTpcXG4gICAgICAgICAgICBzZWxmLl9oZWFwW2tleV90b19tb3ZlXSA9IChuZXdfcHJpb3JpdHksIHNlbGYuX2hlYXBba2V5X3RvX21vdmVdWzFdKVxcbiAgICAgICAgICAgIHNlbGYuX3BlcmNfdXAoa2V5X3RvX21vdmUpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL19faW5pdF9fLnB5XCI6XCJcIixcInNyYy9saWIvcHl0aG9uZWQvYXJib2xlcy9fX2luaXRfXy5weVwiOlwiXFxuXFxuXFxuZnJvbSAuYXZsIGltcG9ydCBBcmJvbEFWTFxcbmZyb20gLmFiYiBpbXBvcnQgQXJib2xCaW5hcmlvQnVzcXVlZGFcXG5mcm9tIC5tb250aWN1bG9CaW5hcmlvIGltcG9ydCBNb250aWN1bG9CaW5hcmlvXFxuXFxuXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2FyYm9sZXMvYWJiLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuI1xcbiNhYmIucHlcXG5cXG5jbGFzcyBBcmJvbEJpbmFyaW9CdXNxdWVkYTpcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5yYWl6ID0gTm9uZVxcbiAgICAgICAgc2VsZi50YW1hbm8gPSAwXFxuXFxuICAgIGRlZiBhZ3JlZ2FyKHNlbGYsY2xhdmUsdmFsb3IpOlxcbiAgICAgICAgaWYgc2VsZi5yYWl6OlxcbiAgICAgICAgICAgIHNlbGYuX2FncmVnYXIoY2xhdmUsdmFsb3Isc2VsZi5yYWl6KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLnJhaXogPSBOb2RvQXJib2woY2xhdmUsdmFsb3IpXFxuICAgICAgICBzZWxmLnRhbWFubyA9IHNlbGYudGFtYW5vICsgMVxcblxcbiAgICBkZWYgX2FncmVnYXIoc2VsZixjbGF2ZSx2YWxvcixub2RvQWN0dWFsKTpcXG4gICAgICAgIGlmIGNsYXZlIDwgbm9kb0FjdHVhbC5jbGF2ZTpcXG4gICAgICAgICAgICBpZiBub2RvQWN0dWFsLnRpZW5lSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICAgICBzZWxmLl9hZ3JlZ2FyKGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbylcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLmhpam9JenF1aWVyZG8gPSBOb2RvQXJib2woY2xhdmUsdmFsb3IscGFkcmU9bm9kb0FjdHVhbClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgbm9kb0FjdHVhbC50aWVuZUhpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgICAgICAgIHNlbGYuX2FncmVnYXIoY2xhdmUsdmFsb3Isbm9kb0FjdHVhbC5oaWpvRGVyZWNobylcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLmhpam9EZXJlY2hvID0gTm9kb0FyYm9sKGNsYXZlLHZhbG9yLHBhZHJlPW5vZG9BY3R1YWwpXFxuIFxcbiAgICBkZWYgX19zZXRpdGVtX18oc2VsZixjLHYpOlxcbiAgICAgICAgc2VsZi5hZ3JlZ2FyKGMsdilcXG5cXG4gICAgZGVmIG9idGVuZXIoc2VsZixjbGF2ZSk6XFxuICAgICAgICBpZiBzZWxmLnJhaXo6XFxuICAgICAgICAgICAgcmVzID0gc2VsZi5fb2J0ZW5lcihjbGF2ZSxzZWxmLnJhaXopXFxuICAgICAgICAgICAgaWYgcmVzOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmNhcmdhVXRpbFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJldHVybiBOb25lXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuXFxuICAgIGRlZiBfb2J0ZW5lcihzZWxmLGNsYXZlLG5vZG9BY3R1YWwpOlxcbiAgICBcXHRpZiBub3Qgbm9kb0FjdHVhbDpcXG4gICAgXFx0ICAgIHJldHVybiBOb25lXFxuICAgIFxcdGVsaWYgbm9kb0FjdHVhbC5jbGF2ZSA9PSBjbGF2ZTpcXG4gICAgXFx0ICAgIHJldHVybiBub2RvQWN0dWFsXFxuICAgIFxcdGVsaWYgY2xhdmUgPCBub2RvQWN0dWFsLmNsYXZlOlxcbiAgICBcXHQgICAgcmV0dXJuIHNlbGYuX29idGVuZXIoY2xhdmUsbm9kb0FjdHVhbC5oaWpvSXpxdWllcmRvKVxcbiAgICBcXHRlbHNlOlxcbiAgICBcXHQgICAgcmV0dXJuIHNlbGYuX29idGVuZXIoY2xhdmUsbm9kb0FjdHVhbC5oaWpvRGVyZWNobykgICAgICAgIFxcblxcbiAgICBkZWYgX19nZXRpdGVtX18oc2VsZixjbGF2ZSk6XFxuICAgICAgICByZXMgPSBzZWxmLm9idGVuZXIoY2xhdmUpIFxcbiAgICAgICAgaWYgcmVzOlxcbiAgICAgICAgICAgIHJldHVybiByZXNcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoJ0Vycm9yLCBsYSBjbGF2ZSBubyBlc3TDoSBlbiBlbCDDoXJib2wnKVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsY2xhdmUpOlxcbiAgICBcXHRpZiBzZWxmLl9vYnRlbmVyKGNsYXZlLHNlbGYucmFpeik6XFxuICAgIFxcdCAgICByZXR1cm4gVHJ1ZVxcbiAgICBcXHRlbHNlOlxcbiAgICBcXHQgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgIFxcbiAgICBkZWYgbG9uZ2l0dWQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi50YW1hbm9cXG5cXG4gICAgZGVmIF9fbGVuX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi50YW1hbm9cXG5cXG4gICAgZGVmIF9faXRlcl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucmFpei5fX2l0ZXJfXygpXFxuXFxuICAgIGRlZiBlbGltaW5hcihzZWxmLGNsYXZlKTpcXG4gICAgICAgIGlmIHNlbGYudGFtYW5vID4gMTpcXG4gICAgICAgICAgIG5vZG9BRWxpbWluYXIgPSBzZWxmLl9vYnRlbmVyKGNsYXZlLHNlbGYucmFpeilcXG4gICAgXFx0ICAgaWYgbm9kb0FFbGltaW5hcjpcXG4gICAgXFx0ICAgICAgIHNlbGYucmVtb3Zlcihub2RvQUVsaW1pbmFyKVxcbiAgICBcXHQgICAgICAgc2VsZi50YW1hbm8gPSBzZWxmLnRhbWFuby0xXFxuICAgIFxcdCAgIGVsc2U6XFxuICAgIFxcdCAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGxhIGNsYXZlIG5vIGVzdMOhIGVuIGVsIMOhcmJvbCcpXFxuICAgICAgICBlbGlmIHNlbGYudGFtYW5vID09IDEgYW5kIHNlbGYucmFpei5jbGF2ZSA9PSBjbGF2ZTpcXG4gICAgXFx0ICAgIHNlbGYucmFpeiA9IE5vbmVcXG4gICAgXFx0ICAgIHNlbGYudGFtYW5vID0gc2VsZi50YW1hbm8gLSAxXFxuICAgICAgICBlbHNlOlxcbiAgICBcXHQgICAgcmFpc2UgS2V5RXJyb3IoJ0Vycm9yLCBsYSBjbGF2ZSBubyBlc3TDoSBlbiBlbCDDoXJib2wnKVxcblxcbiAgICBkZWYgX19kZWxpdGVtX18oc2VsZixjbGF2ZSk6XFxuICAgICAgICBzZWxmLmVsaW1pbmFyKGNsYXZlKVxcblxcbiAgICBkZWYgcmVtb3ZlcihzZWxmLG5vZG9BY3R1YWwpOlxcbiAgICAgICAgaWYgbm9kb0FjdHVhbC5lc0hvamEoKTogI2hvamFcXG4gICAgICAgICAgICBpZiBub2RvQWN0dWFsID09IG5vZG9BY3R1YWwucGFkcmUuaGlqb0l6cXVpZXJkbzpcXG4gICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvSXpxdWllcmRvID0gTm9uZVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucGFkcmUuaGlqb0RlcmVjaG8gPSBOb25lXFxuICAgICAgICBlbGlmIG5vZG9BY3R1YWwudGllbmVBbWJvc0hpam9zKCk6ICNpbnRlcmlvclxcbiAgICAgICAgICAgIHN1YyA9IG5vZG9BY3R1YWwuZW5jb250cmFyU3VjZXNvcigpXFxuICAgICAgICAgICAgc3VjLmVtcGFsbWFyKClcXG4gICAgICAgICAgICBub2RvQWN0dWFsLmNsYXZlID0gc3VjLmNsYXZlXFxuICAgICAgICAgICAgbm9kb0FjdHVhbC5jYXJnYVV0aWwgPSBzdWMuY2FyZ2FVdGlsXFxuXFxuICAgICAgICBlbHNlOiAjIGVzdGUgbm9kbyB0aWVuZSB1biAoMSkgaGlqb1xcbiAgICAgICAgICAgIGlmIG5vZG9BY3R1YWwudGllbmVIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgIGlmIG5vZG9BY3R1YWwuZXNIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLmhpam9JenF1aWVyZG8ucGFkcmUgPSBub2RvQWN0dWFsLnBhZHJlXFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLnBhZHJlLmhpam9JenF1aWVyZG8gPSBub2RvQWN0dWFsLmhpam9JenF1aWVyZG9cXG4gICAgICAgICAgICAgICAgZWxpZiBub2RvQWN0dWFsLmVzSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkby5wYWRyZSA9IG5vZG9BY3R1YWwucGFkcmVcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucGFkcmUuaGlqb0RlcmVjaG8gPSBub2RvQWN0dWFsLmhpam9JenF1aWVyZG9cXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucmVlbXBsYXphckRhdG9EZU5vZG8obm9kb0FjdHVhbC5oaWpvSXpxdWllcmRvLmNsYXZlLCBub2RvQWN0dWFsLmhpam9JenF1aWVyZG8uY2FyZ2FVdGlsLCBub2RvQWN0dWFsLmhpam9JenF1aWVyZG8uaGlqb0l6cXVpZXJkbywgbm9kb0FjdHVhbC5oaWpvSXpxdWllcmRvLmhpam9EZXJlY2hvKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIG5vZG9BY3R1YWwuZXNIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLmhpam9EZXJlY2hvLnBhZHJlID0gbm9kb0FjdHVhbC5wYWRyZVxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvSXpxdWllcmRvID0gbm9kb0FjdHVhbC5oaWpvRGVyZWNob1xcbiAgICAgICAgICAgICAgICBlbGlmIG5vZG9BY3R1YWwuZXNIaWpvRGVyZWNobygpOlxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5oaWpvRGVyZWNoby5wYWRyZSA9IG5vZG9BY3R1YWwucGFkcmVcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucGFkcmUuaGlqb0RlcmVjaG8gPSBub2RvQWN0dWFsLmhpam9EZXJlY2hvXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLnJlZW1wbGF6YXJEYXRvRGVOb2RvKG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8uY2xhdmUsIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8uY2FyZ2FVdGlsLCBub2RvQWN0dWFsLmhpam9EZXJlY2hvLmhpam9JenF1aWVyZG8sIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8uaGlqb0RlcmVjaG8pXFxuXFxuICAgIGRlZiBpbm9yZGVuKHNlbGYpOlxcbiAgICAgICAgc2VsZi5faW5vcmRlbihzZWxmLnJhaXopXFxuXFxuICAgIGRlZiBfaW5vcmRlbihzZWxmLGFyYm9sKTpcXG4gICAgICAgIGlmIGFyYm9sICE9IE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlbihhcmJvbC5oaWpvSXpxdWllcmRvKVxcbiAgICAgICAgICAgIHByaW50KGFyYm9sLmNsYXZlKVxcbiAgICAgICAgICAgIHNlbGYuX2lub3JkZW4oYXJib2wuaGlqb0RlcmVjaG8pXFxuXFxuICAgIGRlZiBwb3N0b3JkZW4oc2VsZik6XFxuICAgICAgICBzZWxmLl9wb3N0b3JkZW4oc2VsZi5yYWl6KVxcblxcbiAgICBkZWYgX3Bvc3RvcmRlbihzZWxmLCBhcmJvbCk6XFxuICAgICAgICBpZiBhcmJvbDpcXG4gICAgICAgICAgICBzZWxmLl9wb3N0b3JkZW4oYXJib2wuaGlqb0RlcmVjaG8pXFxuICAgICAgICAgICAgc2VsZi5fcG9zdG9yZGVuKGFyYm9sLmhpam9JenF1aWVyZG8pXFxuICAgICAgICAgICAgcHJpbnQoYXJib2wuY2xhdmUpICAgICAgICAgICAgXFxuXFxuICAgIGRlZiBwcmVvcmRlbihzZWxmKTpcXG4gICAgICAgIHNlbGYuX3ByZW9yZGVuKHNlbGYsc2VsZi5yYWl6KVxcblxcbiAgICBkZWYgX3ByZW9yZGVuKHNlbGYsYXJib2wpOlxcbiAgICAgICAgaWYgYXJib2w6XFxuICAgICAgICAgICAgcHJpbnQoYXJib2wuY2xhdmUpICAgICAgICAgICAgXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZW4oYXJib2wuaGlqb0l6cXVpZXJkbylcXG4gICAgICAgICAgICBzZWxmLl9wcmVvcmRlbihhcmJvbC5oaWpvRGVyZWNobylcXG5cXG5cXG5jbGFzcyBOb2RvQXJib2w6XFxuICAgZGVmIF9faW5pdF9fKHNlbGYsY2xhdmUsdmFsb3IsaXpxdWllcmRvPU5vbmUsZGVyZWNobz1Ob25lLHBhZHJlPU5vbmUpOlxcbiAgICAgICAgc2VsZi5jbGF2ZSA9IGNsYXZlXFxuICAgICAgICBzZWxmLmNhcmdhVXRpbCA9IHZhbG9yXFxuICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8gPSBpenF1aWVyZG9cXG4gICAgICAgIHNlbGYuaGlqb0RlcmVjaG8gPSBkZXJlY2hvXFxuICAgICAgICBzZWxmLnBhZHJlID0gcGFkcmVcXG4gICAgICAgIHNlbGYuZmFjdG9yRXF1aWxpYnJpbyA9IDBcXG5cXG4gICAgZGVmIHRpZW5lSGlqb0l6cXVpZXJkbyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmhpam9JenF1aWVyZG9cXG4gICAgICAgXFxuICAgIGRlZiB0aWVuZUhpam9EZXJlY2hvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0RlcmVjaG9cXG5cXG4gICAgZGVmIGVzSGlqb0l6cXVpZXJkbyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnBhZHJlIGFuZCBzZWxmLnBhZHJlLmhpam9JenF1aWVyZG8gPT0gc2VsZlxcbiAgICBcXG4gICAgZGVmIGVzSGlqb0RlcmVjaG8oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5wYWRyZSBhbmQgc2VsZi5wYWRyZS5oaWpvRGVyZWNobyA9PSBzZWxmXFxuXFxuICAgIGRlZiBlc1JhaXooc2VsZik6XFxuICAgICAgICByZXR1cm4gbm90IHNlbGYucGFkcmVcXG5cXG4gICAgZGVmIGVzSG9qYShzZWxmKTpcXG4gICAgICAgIHJldHVybiBub3QgKHNlbGYuaGlqb0RlcmVjaG8gb3Igc2VsZi5oaWpvSXpxdWllcmRvKVxcblxcbiAgICBkZWYgdGllbmVBbGd1bkhpam8oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5oaWpvRGVyZWNobyBvciBzZWxmLmhpam9JenF1aWVyZG9cXG5cXG4gICAgZGVmIHRpZW5lQW1ib3NIaWpvcyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmhpam9EZXJlY2hvIGFuZCBzZWxmLmhpam9JenF1aWVyZG9cXG5cXG4gICAgZGVmIHJlZW1wbGF6YXJEYXRvRGVOb2RvKHNlbGYsY2xhdmUsdmFsb3IsaGl6cSxoZGVyKTpcXG4gICAgICAgIHNlbGYuY2xhdmUgPSBjbGF2ZVxcbiAgICAgICAgc2VsZi5jYXJnYVV0aWwgPSB2YWxvclxcbiAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvID0gaGl6cVxcbiAgICAgICAgc2VsZi5oaWpvRGVyZWNobyA9IGhkZXJcXG4gICAgICAgIGlmIHNlbGYudGllbmVIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvLnBhZHJlID0gc2VsZlxcbiAgICAgICAgaWYgc2VsZi50aWVuZUhpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgc2VsZi5oaWpvRGVyZWNoby5wYWRyZSA9IHNlbGYgICAgXFxuXFxuICAgIGRlZiBlbmNvbnRyYXJTdWNlc29yKHNlbGYpOlxcbiAgICAgICAgc3VjID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi50aWVuZUhpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgc3VjID0gc2VsZi5oaWpvRGVyZWNoby5lbmNvbnRyYXJNaW4oKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBzZWxmLnBhZHJlOlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICAgICAgc3VjID0gc2VsZi5wYWRyZVxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvRGVyZWNobyA9IE5vbmVcXG4gICAgICAgICAgICAgICAgICAgIHN1YyA9IHNlbGYucGFkcmUuZW5jb250cmFyU3VjZXNvcigpXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID0gc2VsZlxcbiAgICAgICAgcmV0dXJuIHN1Y1xcblxcbiAgICBkZWYgZW1wYWxtYXIoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmVzSG9qYSgpOlxcbiAgICAgICAgICAgIGlmIHNlbGYuZXNIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0l6cXVpZXJkbyA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID0gTm9uZVxcbiAgICAgICAgZWxpZiBzZWxmLnRpZW5lQWxndW5IaWpvKCk6XFxuICAgICAgICAgICAgaWYgc2VsZi50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0l6cXVpZXJkbyA9IHNlbGYuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvRGVyZWNobyA9IHNlbGYuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8ucGFkcmUgPSBzZWxmLnBhZHJlXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0l6cXVpZXJkbyA9IHNlbGYuaGlqb0RlcmVjaG9cXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0RlcmVjaG8gPSBzZWxmLmhpam9EZXJlY2hvXFxuICAgICAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8ucGFkcmUgPSBzZWxmLnBhZHJlXFxuXFxuICAgIGRlZiBlbmNvbnRyYXJNaW4oc2VsZik6XFxuICAgICAgICBhY3R1YWwgPSBzZWxmXFxuICAgICAgICB3aGlsZSBhY3R1YWwudGllbmVIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgYWN0dWFsID0gYWN0dWFsLmhpam9JenF1aWVyZG9cXG4gICAgICAgIHJldHVybiBhY3R1YWxcXG5cXG4gICAgZGVmIF9faXRlcl9fKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZjpcXG4gICAgXFx0ICAgIGlmIHNlbGYudGllbmVIaWpvSXpxdWllcmRvKCk6XFxuICAgIFxcdCAgICAgICAgZm9yIGVsZW0gaW4gc2VsZi5oaWpvSXpxdWllcmRvOlxcbiAgICBcXHRcXHQgICAgeWllbGQgZWxlbVxcbiAgICAgICAgICAgIHlpZWxkIHNlbGYuY2xhdmVcXG4gICAgXFx0ICAgIGlmIHNlbGYudGllbmVIaWpvRGVyZWNobygpOlxcbiAgICAgICAgICAgICAgICBmb3IgZWxlbSBpbiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICBcXHRcXHQgICAgeWllbGQgZWxlbVxcblwiLFwic3JjL2xpYi9weXRob25lZC9hcmJvbGVzL2FyYm9sQmluYXJpby5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiMgXFxuI2FyYm9sQmluYXJpby5weVxcblxcbmNsYXNzIEFyYm9sQmluYXJpbzpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsb2JqZXRvUmFpeik6XFxuICAgICAgICBzZWxmLmNsYXZlID0gb2JqZXRvUmFpelxcbiAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvID0gTm9uZVxcbiAgICAgICAgc2VsZi5oaWpvRGVyZWNobyA9IE5vbmVcXG4gICAgXFxuICAgIGRlZiBpbnNlcnRhckl6cXVpZXJkbyhzZWxmLG51ZXZvTm9kbyk6XFxuICAgICAgICBpZiBzZWxmLmhpam9JenF1aWVyZG8gPT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8gPSBBcmJvbEJpbmFyaW8obnVldm9Ob2RvKVxcbiAgICAgICAgZWxzZTogIFxcbiAgICAgICAgICAgIHQgPSBBcmJvbEJpbmFyaW8obnVldm9Ob2RvKVxcbiAgICAgICAgICAgIHQuaGlqb0l6cXVpZXJkbyA9IHNlbGYuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkbyA9IHRcXG5cXG4gICAgZGVmIGluc2VydGFyRGVyZWNobyhzZWxmLG51ZXZvTm9kbyk6XFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvID09IE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5oaWpvRGVyZWNobyA9IEFyYm9sQmluYXJpbyhudWV2b05vZG8pXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHQgPSBBcmJvbEJpbmFyaW8obnVldm9Ob2RvKVxcbiAgICAgICAgICAgIHQuaGlqb0RlcmVjaG8gPSBzZWxmLmhpam9EZXJlY2hvXFxuICAgICAgICAgICAgc2VsZi5oaWpvRGVyZWNobyA9IHRcXG5cXG4gICAgZGVmIGVzSG9qYShzZWxmKTpcXG4gICAgICAgIHJldHVybiAoKG5vdCBzZWxmLmhpam9JenF1aWVyZG8pIGFuZCAobm90IHNlbGYuaGlqb0RlcmVjaG8pKVxcblxcbiAgICBkZWYgb2J0ZW5lckhpam9EZXJlY2hvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0RlcmVjaG9cXG4gICAgXFxuICAgIGRlZiBvYnRlbmVySGlqb0l6cXVpZXJkbyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmhpam9JenF1aWVyZG9cXG4gICAgXFxuICAgIGRlZiBhc2lnbmFyVmFsb3JSYWl6KHNlbGYsb2JqKTpcXG4gICAgICAgIHNlbGYuY2xhdmUgPSBvYmpcXG5cXG4gICAgZGVmIG9idGVuZXJWYWxvclJhaXooc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jbGF2ZVxcblxcbiAgICBkZWYgaW5vcmRlbihzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuaGlqb0l6cXVpZXJkbzpcXG4gICAgICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8uaW5vcmRlbigpXFxuICAgICAgICBwcmludChzZWxmLmNsYXZlKVxcbiAgICAgICAgaWYgc2VsZi5oaWpvRGVyZWNobzpcXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvLmlub3JkZW4oKVxcblxcbiAgICBkZWYgcG9zdG9yZGVuKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkby5wb3N0b3JkZW4oKVxcbiAgICAgICAgaWYgc2VsZi5oaWpvRGVyZWNobzpcXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvLnBvc3RvcmRlbigpXFxuICAgICAgICBwcmludChzZWxmLmNsYXZlKVxcblxcbiAgICBkZWYgcHJlb3JkZW4oc2VsZik6XFxuICAgICAgICBwcmludChzZWxmLmNsYXZlKVxcbiAgICAgICAgaWYgc2VsZi5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkby5wcmVvcmRlbigpXFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8ucHJlb3JkZW4oKVxcblxcbiAgICBkZWYgaW1wcmltaXJFeHByZXNpb24oc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmhpam9JenF1aWVyZG86XFxuICAgICAgICAgICAgcHJpbnQoJygnLCBlbmQ9JyAnKVxcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkby5pbXByaW1pckV4cHJlc2lvbigpXFxuICAgICAgICBwcmludChzZWxmLmNsYXZlLCBlbmQ9JyAnKVxcbiAgICAgICAgaWYgc2VsZi5oaWpvRGVyZWNobzpcXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvLmltcHJpbWlyRXhwcmVzaW9uKClcXG4gICAgICAgICAgICBwcmludCgnKScsIGVuZD0nICcpXFxuXFxuICAgIGRlZiBldmFsUG9zdG9yZGVuKHNlbGYpOlxcbiAgICAgICAgb3BlcnMgPSB7JysnOm9wZXJhdG9yLmFkZCwgJy0nOm9wZXJhdG9yLnN1YiwgJyonOm9wZXJhdG9yLm11bCwgJy8nOm9wZXJhdG9yLnRydWVkaXZ9XFxuICAgICAgICByZXMxID0gTm9uZVxcbiAgICAgICAgcmVzMiA9IE5vbmVcXG4gICAgICAgIGlmIHNlbGYuaGlqb0l6cXVpZXJkbzpcXG4gICAgICAgICAgICByZXMxID0gc2VsZi5oaWpvSXpxdWllcmRvLmV2YWxQb3N0b3JkZW4oKSAgIy8vIFxcXFxsYWJlbHtwZWxlZnR9XFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHJlczIgPSBzZWxmLmhpam9EZXJlY2hvLmV2YWxQb3N0b3JkZW4oKSAjLy8gXFxcXGxhYmVse3BlcmlnaHR9XFxuICAgICAgICBpZiByZXMxIGFuZCByZXMyOlxcbiAgICAgICAgICAgIHJldHVybiBvcGVyc1tzZWxmLmNsYXZlXShyZXMxLHJlczIpICMvLyBcXFxcbGFiZWx7cGVldmFsfVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jbGF2ZVxcblxcbmRlZiBpbm9yZGVuKGFyYm9sKTpcXG4gICAgaWYgYXJib2wgIT0gTm9uZTpcXG4gICAgICAgIGlub3JkZW4oYXJib2wub2J0ZW5lckhpam9JenF1aWVyZG8oKSlcXG4gICAgICAgIHByaW50KGFyYm9sLm9idGVuZXJWYWxvclJhaXooKSlcXG4gICAgICAgIGlub3JkZW4oYXJib2wub2J0ZW5lckhpam9EZXJlY2hvKCkpXFxuXFxuZGVmIGltcHJpbWlyRXhwcmVzaW9uKGFyYm9sKTpcXG4gICAgaWYgYXJib2wuaGlqb0l6cXVpZXJkbzpcXG4gICAgICAgIHByaW50KCcoJywgZW5kPScgJylcXG4gICAgICAgIGltcHJpbWlyRXhwcmVzaW9uKGFyYm9sLm9idGVuZXJIaWpvSXpxdWllcmRvKCkpXFxuICAgIHByaW50KGFyYm9sLm9idGVuZXJWYWxvclJhaXooKSwgZW5kPScgJylcXG4gICAgaWYgYXJib2wuaGlqb0RlcmVjaG86XFxuICAgICAgICBpbXByaW1pckV4cHJlc2lvbihhcmJvbC5vYnRlbmVySGlqb0RlcmVjaG8oKSlcXG4gICAgICAgIHByaW50KCcpJywgZW5kPScgJykgXFxuXFxuZGVmIGltcHJpbWlyRXhwcmVzaW9uKGFyYm9sKTpcXG4gIHZhbG9yQ2FkZW5hID0gXFxcIlxcXCJcXG4gIGlmIGFyYm9sOlxcbiAgICAgIHZhbG9yQ2FkZW5hID0gJygnICsgaW1wcmltaXJFeHByZXNpb24oYXJib2wub2J0ZW5lckhpam9JenF1aWVyZG8oKSlcXG4gICAgICB2YWxvckNhZGVuYSA9IHZhbG9yQ2FkZW5hICsgc3RyKGFyYm9sLm9idGVuZXJWYWxvclJhaXooKSlcXG4gICAgICB2YWxvckNhZGVuYSA9IHZhbG9yQ2FkZW5hICsgaW1wcmltaXJFeHByZXNpb24oYXJib2wub2J0ZW5lckhpam9EZXJlY2hvKCkpKycpJ1xcbiAgcmV0dXJuIHZhbG9yQ2FkZW5hXFxuXFxuZGVmIGV2YWxQb3N0b3JkZW4oYXJib2wpOlxcbiAgICBvcGVyYWRvcmVzID0geycrJzpvcGVyYXRvci5hZGQsICctJzpvcGVyYXRvci5zdWIsICcqJzpvcGVyYXRvci5tdWwsICcvJzpvcGVyYXRvci50cnVlZGl2fVxcbiAgICByZXMxID0gTm9uZVxcbiAgICByZXMyID0gTm9uZVxcbiAgICBpZiBhcmJvbDpcXG4gICAgICAgIHJlczEgPSBldmFsUG9zdG9yZGVuKGFyYm9sLm9idGVuZXJIaWpvSXpxdWllcmRvKCkpICMvLyBcXFxcbGFiZWx7cGVsZWZ0fVxcbiAgICAgICAgcmVzMiA9IGV2YWxQb3N0b3JkZW4oYXJib2wub2J0ZW5lckhpam9EZXJlY2hvKCkpICAjLy8gXFxcXGxhYmVse3BlcmlnaHR9XFxuICAgICAgICBpZiByZXMxIGFuZCByZXMyOlxcbiAgICAgICAgICAgIHJldHVybiBvcGVyYWRvcmVzW2FyYm9sLm9idGVuZXJWYWxvclJhaXooKV0ocmVzMSxyZXMyKSAjLy8gXFxcXGxhYmVse3BlZXZhbH1cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIGFyYm9sLm9idGVuZXJWYWxvclJhaXooKVxcblxcbmRlZiBhbHR1cmEoYXJib2wpOlxcbiAgICBpZiBhcmJvbCA9PSBOb25lOlxcbiAgICAgICAgcmV0dXJuIC0xXFxuICAgIGVsc2U6XFxuICAgICAgICByZXR1cm4gMSArIG1heChhbHR1cmEoYXJib2wuaGlqb0l6cXVpZXJkbyksYWx0dXJhKGFyYm9sLmhpam9EZXJlY2hvKSlcXG5cXG50ID0gQXJib2xCaW5hcmlvKDcpXFxudC5pbnNlcnRhckl6cXVpZXJkbygzKVxcbnQuaW5zZXJ0YXJEZXJlY2hvKDkpXFxuaW5vcmRlbih0KVxcbmltcG9ydCBvcGVyYXRvclxcbnggPSBBcmJvbEJpbmFyaW8oJyonKVxcbnguaW5zZXJ0YXJJenF1aWVyZG8oJysnKVxcbmwgPSB4Lm9idGVuZXJIaWpvSXpxdWllcmRvKClcXG5sLmluc2VydGFySXpxdWllcmRvKDQpXFxubC5pbnNlcnRhckRlcmVjaG8oNSlcXG54Lmluc2VydGFyRGVyZWNobyg3KVxcbnByaW50KGltcHJpbWlyRXhwcmVzaW9uKHgpKVxcbnByaW50KGV2YWxQb3N0b3JkZW4oeCkpXFxucHJpbnQoYWx0dXJhKHgpKVxcblwiLFwic3JjL2xpYi9weXRob25lZC9hcmJvbGVzL2F2bC5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiNcXG4jYXZsLnB5XFxuXFxuZnJvbSAuYWJiIGltcG9ydCBBcmJvbEJpbmFyaW9CdXNxdWVkYSwgTm9kb0FyYm9sXFxuXFxuY2xhc3MgQXJib2xBVkwoQXJib2xCaW5hcmlvQnVzcXVlZGEpOlxcblxcbiAgICBkZWYgX2FncmVnYXIoc2VsZixjbGF2ZSx2YWxvcixub2RvQWN0dWFsKTpcXG4gICAgXFx0aWYgY2xhdmUgPCBub2RvQWN0dWFsLmNsYXZlOlxcbiAgICBcXHQgICAgaWYgbm9kb0FjdHVhbC50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgXFx0XFx0c2VsZi5fYWdyZWdhcihjbGF2ZSx2YWxvcixub2RvQWN0dWFsLmhpam9JenF1aWVyZG8pXFxuICAgIFxcdCAgICBlbHNlOlxcbiAgICBcXHRcXHRub2RvQWN0dWFsLmhpam9JenF1aWVyZG8gPSBOb2RvQXJib2woY2xhdmUsdmFsb3IscGFkcmU9bm9kb0FjdHVhbClcXG4gICAgXFx0XFx0c2VsZi5hY3R1YWxpemFyRXF1aWxpYnJpbyhub2RvQWN0dWFsLmhpam9JenF1aWVyZG8pXFxuICAgIFxcdGVsc2U6XFxuICAgIFxcdCAgICBpZiBub2RvQWN0dWFsLnRpZW5lSGlqb0RlcmVjaG8oKTpcXG4gICAgXFx0XFx0c2VsZi5fYWdyZWdhcihjbGF2ZSx2YWxvcixub2RvQWN0dWFsLmhpam9EZXJlY2hvKVxcbiAgICBcXHQgICAgZWxzZTpcXG4gICAgXFx0XFx0bm9kb0FjdHVhbC5oaWpvRGVyZWNobyA9IE5vZG9BcmJvbChjbGF2ZSx2YWxvcixwYWRyZT1ub2RvQWN0dWFsKVxcbiAgICBcXHRcXHRzZWxmLmFjdHVhbGl6YXJFcXVpbGlicmlvKG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8pXFxuXFxuICAgIGRlZiBhY3R1YWxpemFyRXF1aWxpYnJpbyhzZWxmLG5vZG8pOlxcbiAgICBcXHRpZiBub2RvLmZhY3RvckVxdWlsaWJyaW8gPiAxIG9yIG5vZG8uZmFjdG9yRXF1aWxpYnJpbyA8IC0xOlxcbiAgICBcXHQgICAgc2VsZi5yZWVxdWlsaWJyYXIobm9kbykgICAgXFxuICAgIFxcdCAgICByZXR1cm5cXG4gICAgXFx0aWYgbm9kby5wYWRyZSAhPSBOb25lOlxcbiAgICBcXHQgICAgaWYgbm9kby5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgXFx0XFx0ICAgIG5vZG8ucGFkcmUuZmFjdG9yRXF1aWxpYnJpbyArPSAxXFxuICAgIFxcdCAgICBlbGlmIG5vZG8uZXNIaWpvRGVyZWNobygpOlxcbiAgICBcXHRcXHQgICAgbm9kby5wYWRyZS5mYWN0b3JFcXVpbGlicmlvIC09IDFcXG5cXG4gICAgXFx0ICAgIGlmIG5vZG8ucGFkcmUuZmFjdG9yRXF1aWxpYnJpbyAhPSAwOlxcbiAgICBcXHRcXHQgICAgc2VsZi5hY3R1YWxpemFyRXF1aWxpYnJpbyhub2RvLnBhZHJlKVxcblxcbiAgICBkZWYgcmVlcXVpbGlicmFyKHNlbGYsbm9kbyk6XFxuICAgICAgICBpZiBub2RvLmZhY3RvckVxdWlsaWJyaW8gPCAwOlxcblxcdCAgICBpZiBub2RvLmhpam9EZXJlY2hvLmZhY3RvckVxdWlsaWJyaW8gPiAwOlxcblxcdCAgICAgICAgc2VsZi5yb3RhckRlcmVjaGEobm9kby5oaWpvRGVyZWNobylcXG5cXHQgICAgICAgIHNlbGYucm90YXJJenF1aWVyZGEobm9kbylcXG5cXHQgICAgZWxzZTpcXG5cXHQgICAgICAgIHNlbGYucm90YXJJenF1aWVyZGEobm9kbylcXG4gICAgICAgIGVsaWYgbm9kby5mYWN0b3JFcXVpbGlicmlvID4gMDpcXG5cXHQgICAgaWYgbm9kby5oaWpvSXpxdWllcmRvLmZhY3RvckVxdWlsaWJyaW8gPCAwOlxcblxcdCAgICAgICAgc2VsZi5yb3Rhckl6cXVpZXJkYShub2RvLmhpam9JenF1aWVyZG8pXFxuXFx0ICAgICAgICBzZWxmLnJvdGFyRGVyZWNoYShub2RvKVxcblxcdCAgICAgZWxzZTpcXG5cXHQgICAgICAgIHNlbGYucm90YXJEZXJlY2hhKG5vZG8pXFxuICAgICAgICAgICBcXG4gICAgZGVmIHJvdGFySXpxdWllcmRhKHNlbGYscm90UmFpeik6XFxuICAgIFxcdG51ZXZhUmFpeiA9IHJvdFJhaXouaGlqb0RlcmVjaG9cXG4gICAgXFx0cm90UmFpei5oaWpvRGVyZWNobyA9IG51ZXZhUmFpei5oaWpvSXpxdWllcmRvXFxuICAgIFxcdGlmIG51ZXZhUmFpei5oaWpvSXpxdWllcmRvICE9IE5vbmU6XFxuICAgIFxcdCAgICBudWV2YVJhaXouaGlqb0l6cXVpZXJkby5wYWRyZSA9IHJvdFJhaXpcXG4gICAgXFx0bnVldmFSYWl6LnBhZHJlID0gcm90UmFpei5wYWRyZVxcbiAgICBcXHRpZiByb3RSYWl6LmVzUmFpeigpOlxcbiAgICBcXHQgICAgc2VsZi5yYWl6ID0gbnVldmFSYWl6XFxuICAgIFxcdGVsc2U6XFxuICAgIFxcdCAgICBpZiByb3RSYWl6LmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICBcXHQgICAgICAgIHJvdFJhaXoucGFkcmUuaGlqb0l6cXVpZXJkbyA9IG51ZXZhUmFpelxcbiAgICBcXHQgICAgZWxzZTpcXG4gICAgXFx0ICAgIFxcdHJvdFJhaXoucGFkcmUuaGlqb0RlcmVjaG8gPSBudWV2YVJhaXpcXG4gICAgXFx0bnVldmFSYWl6Lmhpam9JenF1aWVyZG8gPSByb3RSYWl6XFxuICAgIFxcdHJvdFJhaXoucGFkcmUgPSBudWV2YVJhaXpcXG4gICAgXFx0cm90UmFpei5mYWN0b3JFcXVpbGlicmlvID0gcm90UmFpei5mYWN0b3JFcXVpbGlicmlvICsgMSAtIG1pbihudWV2YVJhaXouZmFjdG9yRXF1aWxpYnJpbywgMClcXG4gICAgXFx0bnVldmFSYWl6LmZhY3RvckVxdWlsaWJyaW8gPSBudWV2YVJhaXouZmFjdG9yRXF1aWxpYnJpbyArIDEgKyBtYXgocm90UmFpei5mYWN0b3JFcXVpbGlicmlvLCAwKVxcblxcbiAgICBkZWYgcm90YXJEZXJlY2hhKHNlbGYscm90UmFpeik6XFxuICAgICAgICBudWV2YVJhaXogPSByb3RSYWl6Lmhpam9JenF1aWVyZG9cXG4gICAgICAgIHJvdFJhaXouaGlqb0l6cXVpZXJkbyA9IG51ZXZhUmFpei5oaWpvRGVyZWNob1xcbiAgICAgICAgaWYgbnVldmFSYWl6Lmhpam9EZXJlY2hvICE9IE5vbmU6XFxuICAgICAgICAgICAgbnVldmFSYWl6Lmhpam9EZXJlY2hvLnBhZHJlID0gcm90UmFpelxcbiAgICAgICAgbnVldmFSYWl6LnBhZHJlID0gcm90UmFpei5wYWRyZVxcbiAgICAgICAgaWYgcm90UmFpei5lc1JhaXooKTpcXG4gICAgICAgICAgICBzZWxmLnJhaXogPSBudWV2YVJhaXpcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgcm90UmFpei5lc0hpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgICAgIHJvdFJhaXoucGFkcmUuaGlqb0RlcmVjaG8gPSBudWV2YVJhaXpcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByb3RSYWl6LnBhZHJlLmhpam9JenF1aWVyZG8gPSBudWV2YVJhaXpcXG4gICAgICAgIG51ZXZhUmFpei5oaWpvRGVyZWNobyA9IHJvdFJhaXpcXG4gICAgICAgIHJvdFJhaXoucGFkcmUgPSBudWV2YVJhaXpcXG4gICAgICAgIHJvdFJhaXouZmFjdG9yRXF1aWxpYnJpbyA9IHJvdFJhaXouZmFjdG9yRXF1aWxpYnJpbyAtIDEgLSBtYXgobnVldmFSYWl6LmZhY3RvckVxdWlsaWJyaW8sIDApXFxuICAgICAgICBudWV2YVJhaXouZmFjdG9yRXF1aWxpYnJpbyA9IG51ZXZhUmFpei5mYWN0b3JFcXVpbGlicmlvIC0gMSArIG1pbihyb3RSYWl6LmZhY3RvckVxdWlsaWJyaW8sIDApICBcXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYXJib2xlcy9tb250aWN1bG9CaW5hcmlvLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuIyBcXG4jbW9udGljdWxvQmluYXJpby5weVxcblxcbmNsYXNzIE1vbnRpY3Vsb0JpbmFyaW86XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYubGlzdGFNb250aWN1bG8gPSBbMF1cXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gMFxcblxcbiAgICBkZWYgY29uc3RydWlyTW9udGljdWxvKHNlbGYsdW5hTGlzdGEpOlxcbiAgICAgICAgaSA9IGxlbih1bmFMaXN0YSkgLy8gMlxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSBsZW4odW5hTGlzdGEpXFxuICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvID0gWzBdICsgdW5hTGlzdGFbOl1cXG4gICAgICAgIHByaW50KGxlbihzZWxmLmxpc3RhTW9udGljdWxvKSwgaSlcXG4gICAgICAgIHdoaWxlIChpID4gMCk6XFxuICAgICAgICAgICAgcHJpbnQoc2VsZi5saXN0YU1vbnRpY3VsbywgaSlcXG4gICAgICAgICAgICBzZWxmLmluZmlsdEFiYWpvKGkpXFxuICAgICAgICAgICAgaSA9IGkgLSAxXFxuICAgICAgICBwcmludChzZWxmLmxpc3RhTW9udGljdWxvLGkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgIGRlZiBpbmZpbHRBYmFqbyhzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgKGkgKiAyKSA8PSBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICBobSA9IHNlbGYuaGlqb01pbihpKVxcbiAgICAgICAgICAgIGlmIHNlbGYubGlzdGFNb250aWN1bG9baV0gPiBzZWxmLmxpc3RhTW9udGljdWxvW2htXTpcXG4gICAgICAgICAgICAgICAgdG1wID0gc2VsZi5saXN0YU1vbnRpY3Vsb1tpXVxcbiAgICAgICAgICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvW2ldID0gc2VsZi5saXN0YU1vbnRpY3Vsb1tobV1cXG4gICAgICAgICAgICAgICAgc2VsZi5saXN0YU1vbnRpY3Vsb1tobV0gPSB0bXBcXG4gICAgICAgICAgICBpID0gaG1cXG4gICAgICAgICAgICAgICAgXFxuICAgIGRlZiBoaWpvTWluKHNlbGYsaSk6XFxuICAgICAgICBpZiBpICogMiArIDEgPiBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICByZXR1cm4gaSAqIDJcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgc2VsZi5saXN0YU1vbnRpY3Vsb1tpICogMl0gPCBzZWxmLmxpc3RhTW9udGljdWxvW2kgKiAyICsgMV06XFxuICAgICAgICAgICAgICAgIHJldHVybiBpICogMlxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJldHVybiBpICogMiArIDFcXG5cXG4gICAgZGVmIGluZmlsdEFycmliYShzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgaSAvLyAyID4gMDpcXG4gICAgICAgICAgICBpZiBzZWxmLmxpc3RhTW9udGljdWxvW2ldIDwgc2VsZi5saXN0YU1vbnRpY3Vsb1tpLy8yXTpcXG4gICAgICAgICAgICAgICB0bXAgPSBzZWxmLmxpc3RhTW9udGljdWxvW2kgLy8gMl1cXG4gICAgICAgICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvW2kgLy8gMl0gPSBzZWxmLmxpc3RhTW9udGljdWxvW2ldXFxuICAgICAgICAgICAgICAgc2VsZi5saXN0YU1vbnRpY3Vsb1tpXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBpIC8vIDJcXG4gXFxuICAgIGRlZiBpbnNlcnRhcihzZWxmLGspOlxcbiAgICAgICAgc2VsZi5saXN0YU1vbnRpY3Vsby5hcHBlbmQoaylcXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gc2VsZi50YW1hbm9BY3R1YWwgKyAxXFxuICAgICAgICBzZWxmLmluZmlsdEFycmliYShzZWxmLnRhbWFub0FjdHVhbClcXG5cXG4gICAgZGVmIGVsaW1pbmFyTWluKHNlbGYpOlxcbiAgICAgICAgdmFsb3JTYWNhZG8gPSBzZWxmLmxpc3RhTW9udGljdWxvWzFdXFxuICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvWzFdID0gc2VsZi5saXN0YU1vbnRpY3Vsb1tzZWxmLnRhbWFub0FjdHVhbF1cXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gc2VsZi50YW1hbm9BY3R1YWwgLSAxXFxuICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvLnBvcCgpXFxuICAgICAgICBzZWxmLmluZmlsdEFiYWpvKDEpXFxuICAgICAgICByZXR1cm4gdmFsb3JTYWNhZG9cXG4gICAgICAgIFxcbiAgICBkZWYgZXN0YVZhY2lvKHNlbGYpOlxcbiAgICAgICAgaWYgdGFtYW5vQWN0dWFsID09IDA6XFxuICAgICAgICAgICAgcmV0dXJuIFRydWVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2Jhc2ljYXMvX19pbml0X18ucHlcIjpcIlxcbiNfX2FsbF9fID0gW1xcXCJwaWxhXFxcIl1cXG5cXG5cXG5mcm9tIC5waWxhIGltcG9ydCBQaWxhXFxuZnJvbSAuY29sYSBpbXBvcnQgQ29sYVxcbmZyb20gLmNvbGFkb2JsZSBpbXBvcnQgQ29sYURvYmxlXFxuXFxuXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2Jhc2ljYXMvY29sYS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiNcXG4jY29sYS5weVxcblxcbmNsYXNzIENvbGE6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgZXN0YVZhY2lhKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMgPT0gW11cXG5cXG4gICAgZGVmIGFncmVnYXIoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmluc2VydCgwLGl0ZW0pXFxuXFxuICAgIGRlZiBhdmFuemFyKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHRhbWFubyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYmFzaWNhcy9jb2xhZG9ibGUucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jIFxcbiNjb2xhZG9ibGUucHlcXG5cXG5jbGFzcyBDb2xhRG9ibGU6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgZXN0YVZhY2lhKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMgPT0gW11cXG5cXG4gICAgZGVmIGFncmVnYXJGcmVudGUoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmFwcGVuZChpdGVtKVxcblxcbiAgICBkZWYgYWdyZWdhckZpbmFsKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgc2VsZi5pdGVtcy5pbnNlcnQoMCxpdGVtKVxcblxcbiAgICBkZWYgcmVtb3ZlckZyZW50ZShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiByZW1vdmVyRmluYWwoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcy5wb3AoMClcXG5cXG4gICAgZGVmIHRhbWFubyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYmFzaWNhcy9waWxhLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuIyBcXG4jcGlsYS5weVxcblxcbmNsYXNzIFBpbGE6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgZXN0YVZhY2lhKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMgPT0gW11cXG5cXG4gICAgZGVmIGluY2x1aXIoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmFwcGVuZChpdGVtKVxcblxcbiAgICBkZWYgZXh0cmFlcihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiBpbnNwZWNjaW9uYXIoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtc1tsZW4oc2VsZi5pdGVtcyktMV1cXG5cXG4gICAgZGVmIHRhbWFubyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvZ3JhZm9zL19faW5pdF9fLnB5XCI6XCJcXG5cXG5mcm9tIC5ncmFmb0FkeSBpbXBvcnQgR3JhZm9cXG5mcm9tIC5ncmFmb0FkeSBpbXBvcnQgVmVydGljZVxcbmZyb20gLmNvbGFQcmlvcmlkYWQgaW1wb3J0IENvbGFQcmlvcmlkYWRcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvZ3JhZm9zL2NvbGFQcmlvcmlkYWQucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jIFxcbiNjb2xhUHJpb3JpZGFkLnB5XFxuXFxuY2xhc3MgQ29sYVByaW9yaWRhZDpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvID0gWygwLDApXVxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSAwXFxuXFxuICAgIGRlZiBjb25zdHJ1aXJNb250aWN1bG8oc2VsZix1bmFMaXN0YSk6XFxuICAgICAgICBzZWxmLnRhbWFub0FjdHVhbCA9IGxlbih1bmFMaXN0YSlcXG4gICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3VsbyA9IFsoMCwwKV1cXG4gICAgICAgIGZvciBpIGluIHVuYUxpc3RhOlxcbiAgICAgICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsby5hcHBlbmQoaSlcXG4gICAgICAgIGkgPSBsZW4odW5hTGlzdGEpIC8vIDIgICAgICAgICAgICBcXG4gICAgICAgIHdoaWxlIChpID4gMCk6XFxuICAgICAgICAgICAgc2VsZi5pbmZpbHRBYmFqbyhpKVxcbiAgICAgICAgICAgIGkgPSBpIC0gMVxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgaW5maWx0QWJham8oc2VsZixpKTpcXG4gICAgICAgIHdoaWxlIChpICogMikgPD0gc2VsZi50YW1hbm9BY3R1YWw6XFxuICAgICAgICAgICAgaG0gPSBzZWxmLmhpam9NaW4oaSlcXG4gICAgICAgICAgICBpZiBzZWxmLmFycmVnbG9Nb250aWN1bG9baV1bMF0gPiBzZWxmLmFycmVnbG9Nb250aWN1bG9baG1dWzBdOlxcbiAgICAgICAgICAgICAgICB0bXAgPSBzZWxmLmFycmVnbG9Nb250aWN1bG9baV1cXG4gICAgICAgICAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2ldID0gc2VsZi5hcnJlZ2xvTW9udGljdWxvW2htXVxcbiAgICAgICAgICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9baG1dID0gdG1wXFxuICAgICAgICAgICAgaSA9IGhtXFxuICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgaGlqb01pbihzZWxmLGkpOlxcbiAgICAgICAgaWYgaSoyID4gc2VsZi50YW1hbm9BY3R1YWw6XFxuICAgICAgICAgICAgcmV0dXJuIC0xXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIGkqMiArIDEgPiBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkqMlxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpKjJdWzBdIDwgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2kqMisxXVswXTpcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpKjJcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpKjIrMVxcblxcbiAgICBkZWYgaW5maWx0QXJyaWJhKHNlbGYsaSk6XFxuICAgICAgICB3aGlsZSBpIC8vIDIgPiAwOlxcbiAgICAgICAgICAgIGlmIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVswXSA8IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpLy8yXVswXTpcXG4gICAgICAgICAgICAgICB0bXAgPSBzZWxmLmFycmVnbG9Nb250aWN1bG9baS8vMl1cXG4gICAgICAgICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9baS8vMl0gPSBzZWxmLmFycmVnbG9Nb250aWN1bG9baV1cXG4gICAgICAgICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9baV0gPSB0bXBcXG4gICAgICAgICAgICBpID0gaS8vMlxcbiBcXG4gICAgZGVmIGluc2VydGFyKHNlbGYsayk6XFxuICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG8uYXBwZW5kKGspXFxuICAgICAgICBzZWxmLnRhbWFub0FjdHVhbCA9IHNlbGYudGFtYW5vQWN0dWFsICsgMVxcbiAgICAgICAgc2VsZi5pbmZpbHRBcnJpYmEoc2VsZi50YW1hbm9BY3R1YWwpXFxuXFxuICAgIGRlZiBlbGltaW5hck1pbihzZWxmKTpcXG4gICAgICAgIHZhbG9yU2FjYWRvID0gc2VsZi5hcnJlZ2xvTW9udGljdWxvWzFdWzFdXFxuICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9bMV0gPSBzZWxmLmFycmVnbG9Nb250aWN1bG9bc2VsZi50YW1hbm9BY3R1YWxdXFxuICAgICAgICBzZWxmLnRhbWFub0FjdHVhbCA9IHNlbGYudGFtYW5vQWN0dWFsIC0gMVxcbiAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvLnBvcCgpXFxuICAgICAgICBzZWxmLmluZmlsdEFiYWpvKDEpXFxuICAgICAgICByZXR1cm4gdmFsb3JTYWNhZG9cXG4gICAgICAgIFxcbiAgICBkZWYgZXN0YVZhY2lhKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi50YW1hbm9BY3R1YWwgPT0gMDpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG4gICAgZGVmIGRlY3JlbWVudGFyQ2xhdmUoc2VsZix2YWxvcixudWV2byk6XFxuICAgICAgICBoZWNobyA9IEZhbHNlXFxuICAgICAgICBpID0gMVxcbiAgICAgICAgbWlDbGF2ZSA9IDBcXG4gICAgICAgIHdoaWxlIG5vdCBoZWNobyBhbmQgaSA8PSBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICBpZiBzZWxmLmFycmVnbG9Nb250aWN1bG9baV1bMV0gPT0gdmFsb3I6XFxuICAgICAgICAgICAgICAgIGhlY2hvID0gVHJ1ZVxcbiAgICAgICAgICAgICAgICBtaUNsYXZlID0gaVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGkgPSBpICsgMVxcbiAgICAgICAgaWYgbWlDbGF2ZSA+IDA6XFxuICAgICAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvW21pQ2xhdmVdID0gKG51ZXZvLHNlbGYuYXJyZWdsb01vbnRpY3Vsb1ttaUNsYXZlXVsxXSlcXG4gICAgICAgICAgICBzZWxmLmluZmlsdEFycmliYShtaUNsYXZlKVxcbiAgICAgICAgICAgIFxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsdmVydGljZSk6XFxuICAgICAgICBmb3IgcGFyZWphIGluIHNlbGYuYXJyZWdsb01vbnRpY3VsbzpcXG4gICAgICAgICAgICBpZiBwYXJlamFbMV0gPT0gdmVydGljZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcXG4gICAgICAgIHJldHVybiBGYWxzZSAgICAgXFxuXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2dyYWZvcy9ncmFmb0FkeS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiNcXG4jZ3JhZm9BZHkucHlcXG5cXG5cXG5pbXBvcnQgc3lzXFxuXFxuY2xhc3MgR3JhZm86XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYubGlzdGFWZXJ0aWNlcyA9IHt9XFxuICAgICAgICBzZWxmLm51bVZlcnRpY2VzID0gMFxcbiAgICAgICAgXFxuICAgIGRlZiBhZ3JlZ2FyVmVydGljZShzZWxmLGNsYXZlKTpcXG4gICAgICAgIHNlbGYubnVtVmVydGljZXMgPSBzZWxmLm51bVZlcnRpY2VzICsgMVxcbiAgICAgICAgbnVldm9WZXJ0aWNlID0gVmVydGljZShjbGF2ZSlcXG4gICAgICAgIHNlbGYubGlzdGFWZXJ0aWNlc1tjbGF2ZV0gPSBudWV2b1ZlcnRpY2VcXG4gICAgICAgIHJldHVybiBudWV2b1ZlcnRpY2VcXG4gICAgXFxuICAgIGRlZiBvYnRlbmVyVmVydGljZShzZWxmLG4pOlxcbiAgICAgICAgaWYgbiBpbiBzZWxmLmxpc3RhVmVydGljZXM6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYubGlzdGFWZXJ0aWNlc1tuXVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsbik6XFxuICAgICAgICByZXR1cm4gbiBpbiBzZWxmLmxpc3RhVmVydGljZXNcXG4gICAgXFxuICAgIGRlZiBhZ3JlZ2FyQXJpc3RhKHNlbGYsZGUsYSxjb3N0bz0wKTpcXG4gICAgICAgICAgICBpZiBkZSBub3QgaW4gc2VsZi5saXN0YVZlcnRpY2VzOlxcbiAgICAgICAgICAgICAgICBudiA9IHNlbGYuYWdyZWdhclZlcnRpY2UoZGUpXFxuICAgICAgICAgICAgaWYgYSBub3QgaW4gc2VsZi5saXN0YVZlcnRpY2VzOlxcbiAgICAgICAgICAgICAgICBudiA9IHNlbGYuYWdyZWdhclZlcnRpY2UoYSlcXG4gICAgICAgICAgICBzZWxmLmxpc3RhVmVydGljZXNbZGVdLmFncmVnYXJWZWNpbm8oc2VsZi5saXN0YVZlcnRpY2VzW2FdLGNvc3RvKVxcbiAgICBcXG4gICAgZGVmIG9idGVuZXJWZXJ0aWNlcyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBsaXN0KHNlbGYubGlzdGFWZXJ0aWNlcy5rZXlzKCkpXFxuICAgICAgICBcXG4gICAgZGVmIF9faXRlcl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGl0ZXIoc2VsZi5saXN0YVZlcnRpY2VzLnZhbHVlcygpKVxcbiAgICAgICAgICAgICAgICBcXG5jbGFzcyBWZXJ0aWNlOlxcbiAgICBkZWYgX19pbml0X18oc2VsZixjbGF2ZSk6XFxuICAgICAgICBzZWxmLmlkID0gY2xhdmVcXG4gICAgICAgIHNlbGYuY29uZWN0YWRvQSA9IHt9XFxuICAgICAgICBzZWxmLmNvbG9yID0gJ2JsYW5jbydcXG4gICAgICAgIHNlbGYuZGlzdCA9IHN5cy5tYXhzaXplXFxuICAgICAgICBzZWxmLnByZWRlY2Vzb3IgPSBOb25lXFxuICAgICAgICBzZWxmLmRlc2MgPSAwXFxuICAgICAgICBzZWxmLmZpbiA9IDBcXG5cXG4gICAgIyBkZWYgX19sdF9fKHNlbGYsbyk6XFxuICAgICMgICAgIHJldHVybiBzZWxmLmlkIDwgby5pZFxcbiAgICBcXG4gICAgZGVmICBhZ3JlZ2FyVmVjaW5vKHNlbGYsdmVjaW5vLHBvbmRlcmFjaW9uPTApOlxcbiAgICAgICAgc2VsZi5jb25lY3RhZG9BW3ZlY2lub10gPSBwb25kZXJhY2lvblxcbiAgICAgICAgXFxuICAgIGRlZiBhc2lnbmFyQ29sb3Ioc2VsZixjb2xvcik6XFxuICAgICAgICBzZWxmLmNvbG9yID0gY29sb3JcXG4gICAgICAgIFxcbiAgICBkZWYgYXNpZ25hckRpc3RhbmNpYShzZWxmLGQpOlxcbiAgICAgICAgc2VsZi5kaXN0ID0gZFxcblxcbiAgICBkZWYgYXNpZ25hclByZWRlY2Vzb3Ioc2VsZixwKTpcXG4gICAgICAgIHNlbGYucHJlZGVjZXNvciA9IHBcXG5cXG4gICAgZGVmIGFzaWduYXJEZXNjdWJyaW1pZW50byhzZWxmLHRpZW1wb0Rlc2N1YnJpbWllbnRvKTpcXG4gICAgICAgIHNlbGYuZGVzYyA9IHRpZW1wb0Rlc2N1YnJpbWllbnRvXFxuICAgICAgICBcXG4gICAgZGVmIGFzaWduYXJGaW5hbGl6YWNpb24oc2VsZix0aWVtcG9GaW5hbGl6YWNpb24pOlxcbiAgICAgICAgc2VsZi5maW4gPSB0aWVtcG9GaW5hbGl6YWNpb25cXG4gICAgICAgIFxcbiAgICBkZWYgb2J0ZW5lckZpbmFsaXphY2lvbihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmZpblxcbiAgICAgICAgXFxuICAgIGRlZiBvYnRlbmVyRGVzY3VicmltaWVudG8oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5kZXNjXFxuICAgICAgICBcXG4gICAgZGVmIG9idGVuZXJQcmVkZWNlc29yKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucHJlZGVjZXNvclxcbiAgICAgICAgXFxuICAgIGRlZiBvYnRlbmVyRGlzdGFuY2lhKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZGlzdFxcbiAgICAgICAgXFxuICAgIGRlZiBvYnRlbmVyQ29sb3Ioc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jb2xvclxcbiAgICBcXG4gICAgZGVmIG9idGVuZXJDb25leGlvbmVzKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuY29uZWN0YWRvQS5rZXlzKClcXG4gICAgICAgIFxcbiAgICBkZWYgb2J0ZW5lclBvbmRlcmFjaW9uKHNlbGYsdmVjaW5vKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmNvbmVjdGFkb0FbdmVjaW5vXVxcbiAgICAgICAgICAgICAgICBcXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc3RyKHNlbGYuaWQpICsgXFxcIjpjb2xvciBcXFwiICsgc2VsZi5jb2xvciArIFxcXCI6ZGVzYyBcXFwiICsgc3RyKHNlbGYuZGVzYykgKyBcXFwiOmZpbiBcXFwiICsgc3RyKHNlbGYuZmluKSArIFxcXCI6ZGlzdGFuY2lhIFxcXCIgKyBzdHIoc2VsZi5kaXN0KSArIFxcXCI6cHJlZGVjZXNvciBcXFxcblxcXFx0W1xcXCIgKyBzdHIoc2VsZi5wcmVkZWNlc29yKSsgXFxcIl1cXFxcblxcXCJcXG4gICAgXFxuICAgIGRlZiBvYnRlbmVySWQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pZFxcblwiLFwic3JjL2xpYi9xdW9wcmkucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicXVvcHJpXFxcIilcXG5cIixcInNyYy9saWIvcmVwci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJyZXByXFxcIilcXG5cIixcInNyYy9saWIvcmVxdWVzdHMucHlcIjpcIiMgbW9zdCByZXN0cmljdGVkIHZlcnNpb25cXG5cXFwiXFxcIlxcXCJcXG5UaGlzIHNvbHV0aW9uIHdvcmtzIGluIHJ1bmVzdG9uZSAtIGhvd2V2ZXIgaXQgaXMgbXVjaCBtb3JlIGxpbWl0ZWQuXFxuQW4gZXJyb3IgZG9lcyBub3Qgb2NjdXIgaW4gdGhlIHNhbWUgd2F5IGluIHRoZSB0ZXh0Ym9vayBhcyBpdCBkb2VzXFxuZm9yIHRoZSBjb21tYW5kIGxpbmUuIFNpbmNlIEhUVFBFcnJvciBpcyBub3QgY3VycmVudGx5IGF2YWlsYWJsZSBpblxcblJ1bmVzdG9uZSwgSSBoYWQgdG8gY2hhbmdlIHRoZSBleGNlcHRpb24uXFxuRGVjb2RlIGFuZCBFbmNvZGUgYXJlIG5vdCBhdmFpbGFibGUgaW4gUnVuZXN0b25lLCBzbyB0aGVyZSBtaWdodCBiZVxcbmlzc3VlcyB3aXRoIHJlcG9uc2VzLlxcbkRvZXMgbm90IHVzZSB0aGUgc3RhdHVzIGF0dHJpYnV0ZSBmb3IgdXJsb3Blbiwgd291bGQgYmUgbmljZSB0byBoYXZlXFxudGhhdCBiYWNrLlxcbkRvZXMgbm90IHdvcmsgb24gcmVndWxhciB3ZWIgcGFnZXMgKGxpa2UgZ29vZ2xlIG9yIHRoZSBtaWNoaWdhbiBkYWlseSkgYmVjYXVzZSBvZiBjcm9zcy1zaXRlIHNjcmlwdGluZyBsaW1pdHMuXFxuXFxcIlxcXCJcXFwiXFxuZnJvbSB1cmxsaWIucmVxdWVzdCBpbXBvcnQgdXJsb3BlblxcbmltcG9ydCBqc29uXFxuXFxuY2xhc3MgUmVzcG9uc2U6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBkYXRhLCB1cmwpOlxcbiAgICAgICAgc2VsZi50ZXh0ID0gZGF0YVxcbiAgICAgICAgc2VsZi51cmwgPSB1cmxcXG5cXG4gICAgZGVmIGpzb24oc2VsZik6XFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAgcmV0dXJuIGpzb24ubG9hZHMoc2VsZi50ZXh0KVxcbiAgICAgICAgZXhjZXB0OlxcbiAgICAgICAgICAgIHJldHVybiB7XFxcImVycm9yXFxcIjogXFxcIlJlc3BvbnNlIG5vdCBpbnRlcnByZXRhYmxlIGFzIGpzb24uIFRyeSBwcmludGluZyB0aGUgLnRleHQgYXR0cmlidXRlXFxcIn1cXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gXFxcIjxBIFJlc3BvbnNlIG9iamVjdCBmb3IgdGhlIGZvbGxvd2luZyByZXF1ZXN0OiB7fT5cXFwiLmZvcm1hdChzZWxmLnVybClcXG5cXG5cXG51cmxfc3VicyA9IHtcXFwiIFxcXCI6IFxcXCIrXFxcIixcXG4gICAgICAgICAgICBcXFwiIVxcXCI6IFxcXCIlMjFcXFwiLFxcbiAgICAgICAgICAgICdcXFwiJzogXFxcIiUyMlxcXCIsXFxuICAgICAgICAgICAgXFxcIiNcXFwiOiBcXFwiJTIzXFxcIixcXG4gICAgICAgICAgICBcXFwiJFxcXCI6IFxcXCIlMjRcXFwiLFxcbiAgICAgICAgICAgIFxcXCInXFxcIjogXFxcIiUyN1xcXCIsXFxuICAgICAgICAgICAgXFxcIihcXFwiOiBcXFwiJTI4XFxcIixcXG4gICAgICAgICAgICBcXFwiKVxcXCI6IFxcXCIlMjlcXFwiLFxcbiAgICAgICAgICAgIFxcXCIqXFxcIjogXFxcIiUyQVxcXCIsXFxuICAgICAgICAgICAgXFxcIitcXFwiOiBcXFwiJTJCXFxcIixcXG4gICAgICAgICAgICBcXFwiLFxcXCI6IFxcXCIlMkNcXFwiLFxcbiAgICAgICAgICAgIFxcXCIvXFxcIjogXFxcIiUyRlxcXCIsXFxuICAgICAgICAgICAgXFxcIjpcXFwiOiBcXFwiJTNBXFxcIixcXG4gICAgICAgICAgICBcXFwiO1xcXCI6IFxcXCIlM0JcXFwiLFxcbiAgICAgICAgICAgIFxcXCI9XFxcIjogXFxcIiUzRFxcXCIsXFxuICAgICAgICAgICAgXFxcIj9cXFwiOiBcXFwiJTNGXFxcIixcXG4gICAgICAgICAgICBcXFwiQFxcXCI6IFxcXCIlNDBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJbXFxcIjogXFxcIiU1QlxcXCIsXFxuICAgICAgICAgICAgXFxcIl1cXFwiOiBcXFwiJTVEXFxcIixcXG4gICAgICAgICAgICB9XFxuXFxuZGVmIF9zdWJzdChzLCBzdWJzdGl0dXRpb25zPXVybF9zdWJzKTpcXG4gICAgcmVzID0gXFxcIlxcXCJcXG4gICAgZm9yIGMgaW4gc3RyKHMpOlxcbiAgICAgICAgaWYgYyBpbiBzdWJzdGl0dXRpb25zOlxcbiAgICAgICAgICAgIHJlcyArPSBzdWJzdGl0dXRpb25zW2NdXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJlcyArPSBjXFxuICAgIHJldHVybiByZXNcXG5cXG5cXG5kZWYgcmVxdWVzdFVSTChiYXNldXJsLCBwYXJhbXM9e30pOlxcbiAgICB0cnk6XFxuICAgICAgICBpZiBsZW4ocGFyYW1zKSA9PSAwOlxcbiAgICAgICAgICAgIHJldHVybiBiYXNldXJsXFxuICAgICAgICBjb21wbGV0ZV91cmwgPSBiYXNldXJsICsgXFxcIj9cXFwiXFxuICAgICAgICBwYWlycyA9IFtcXFwie309e31cXFwiLmZvcm1hdChfc3Vic3QoayksIF9zdWJzdChwYXJhbXNba10pKSBmb3IgayBpbiBwYXJhbXNdXFxuICAgICAgICBjb21wbGV0ZV91cmwgKz0gXFxcIiZcXFwiLmpvaW4ocGFpcnMpXFxuICAgICAgICByZXR1cm4gY29tcGxldGVfdXJsXFxuICAgIGV4Y2VwdDpcXG4gICAgICAgIHJldHVybiBOb25lXFxuXFxuZGVmIGdldChiYXNldXJsLCBwYXJhbXM9e30pOlxcbiAgICBmdWxsX3VybCA9IHJlcXVlc3RVUkwoYmFzZXVybCwgcGFyYW1zKVxcbiAgICBpZiBub3QgZnVsbF91cmw6XFxuICAgICAgICB0ZXh0X2RhdGEgPSBcXFwiPGh0bWw+PGJvZHk+PGgxPmludmFsaWQgcmVxdWVzdDwvaDE+PC9ib2R5PjwvaHRtbD5cXFwiXFxuICAgICAgICBmdWxsX3VybCA9IFxcXCJDb3VsZG7igJl0IGdlbmVyYXRlIGEgdmFsaWQgVVJMXFxcIlxcbiAgICBlbHNlOlxcbiAgICAgICAgZGF0YSA9IHVybG9wZW4oZnVsbF91cmwpXFxuICAgICAgICB0ZXh0X2RhdGEgPSBkYXRhLnJlYWQoKS5zdHJpcCgpXFxuICAgICAgICBpZiBsZW4odGV4dF9kYXRhKSA9PSAwOlxcbiAgICAgICAgICAgIHRleHRfZGF0YSA9IFxcXCJGYWlsZWQgdG8gcmV0cmlldmUgdGhhdCBVUkxcXFwiXFxuICAgIHJldHVybiBSZXNwb25zZSh0ZXh0X2RhdGEsIGZ1bGxfdXJsKVwiLFwic3JjL2xpYi9yZXF1ZXN0c193aXRoX2NhY2hpbmcucHlcIjpcImltcG9ydCByZXF1ZXN0c1xcbmltcG9ydCBqc29uXFxuXFxuUEVSTUFORU5UX0NBQ0hFX0ZOQU1FID0gXFxcInBlcm1hbmVudF9jYWNoZS50eHRcXFwiXFxuVEVNUF9DQUNIRV9GTkFNRSA9IFxcXCJ0aGlzX3BhZ2VfY2FjaGUudHh0XFxcIlxcblxcbmRlZiBfd3JpdGVfdG9fZmlsZShjYWNoZSwgZm5hbWUpOlxcbiAgICB3aXRoIG9wZW4oZm5hbWUsICd3JykgYXMgb3V0ZmlsZTpcXG4gICAgICAgIG91dGZpbGUud3JpdGUoanNvbi5kdW1wcyhjYWNoZSwgaW5kZW50PTIpKVxcblxcbmRlZiBfcmVhZF9mcm9tX2ZpbGUoZm5hbWUpOlxcbiAgICB0cnk6XFxuICAgICAgICB3aXRoIG9wZW4oZm5hbWUsICdyJykgYXMgaW5maWxlOlxcbiAgICAgICAgICAgIHJlcyA9IGluZmlsZS5yZWFkKClcXG4gICAgICAgICAgICByZXR1cm4ganNvbi5sb2FkcyhyZXMpXFxuICAgIGV4Y2VwdDpcXG4gICAgICAgIHJldHVybiB7fVxcblxcbmRlZiBhZGRfdG9fY2FjaGUoY2FjaGVfZmlsZSwgY2FjaGVfa2V5LCBjYWNoZV92YWx1ZSk6XFxuICAgIHRlbXBfY2FjaGUgPSBfcmVhZF9mcm9tX2ZpbGUoY2FjaGVfZmlsZSlcXG4gICAgdGVtcF9jYWNoZVtjYWNoZV9rZXldID0gY2FjaGVfdmFsdWVcXG4gICAgX3dyaXRlX3RvX2ZpbGUodGVtcF9jYWNoZSwgY2FjaGVfZmlsZSlcXG5cXG5kZWYgY2xlYXJfY2FjaGUoY2FjaGVfZmlsZT1URU1QX0NBQ0hFX0ZOQU1FKTpcXG4gICAgX3dyaXRlX3RvX2ZpbGUoe30sIGNhY2hlX2ZpbGUpXFxuXFxuZGVmIG1ha2VfY2FjaGVfa2V5KGJhc2V1cmwsIHBhcmFtc19kLCBwcml2YXRlX2tleXM9W1xcXCJhcGlfa2V5XFxcIiwgXFxcImFwaWtleVxcXCJdKTpcXG4gICAgXFxcIlxcXCJcXFwiTWFrZXMgYSBsb25nIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHF1ZXJ5LlxcbiAgICBBbHBoYWJldGl6ZSB0aGUga2V5cyBmcm9tIHRoZSBwYXJhbXMgZGljdGlvbmFyeSBzbyB3ZSBnZXQgdGhlIHNhbWUgb3JkZXIgZWFjaCB0aW1lLlxcbiAgICBPbWl0IGtleXMgd2l0aCBwcml2YXRlIGluZm8uXFxcIlxcXCJcXFwiXFxuICAgIGFscGhhYmV0aXplZF9rZXlzID0gc29ydGVkKHBhcmFtc19kLmtleXMoKSlcXG4gICAgcmVzID0gW11cXG4gICAgZm9yIGsgaW4gYWxwaGFiZXRpemVkX2tleXM6XFxuICAgICAgICBpZiBrIG5vdCBpbiBwcml2YXRlX2tleXM6XFxuICAgICAgICAgICAgcmVzLmFwcGVuZChcXFwie30te31cXFwiLmZvcm1hdChrLCBwYXJhbXNfZFtrXSkpXFxuICAgIHJldHVybiBiYXNldXJsICsgXFxcIl9cXFwiLmpvaW4ocmVzKVxcblxcbmRlZiBnZXQoYmFzZXVybCwgcGFyYW1zPXt9LCBwcml2YXRlX2tleXNfdG9faWdub3JlPVtcXFwiYXBpX2tleVxcXCIsIFxcXCJhcGlrZXlcXFwiXSwgcGVybWFuZW50X2NhY2hlX2ZpbGU9UEVSTUFORU5UX0NBQ0hFX0ZOQU1FLCB0ZW1wX2NhY2hlX2ZpbGU9VEVNUF9DQUNIRV9GTkFNRSk6XFxuICAgIGZ1bGxfdXJsID0gcmVxdWVzdHMucmVxdWVzdFVSTChiYXNldXJsLCBwYXJhbXMpXFxuICAgIGNhY2hlX2tleSA9IG1ha2VfY2FjaGVfa2V5KGJhc2V1cmwsIHBhcmFtcywgcHJpdmF0ZV9rZXlzX3RvX2lnbm9yZSlcXG4gICAgIyBMb2FkIHRoZSBwZXJtYW5lbnQgYW5kIHBhZ2Utc3BlY2lmaWMgY2FjaGVzIGZyb20gZmlsZXNcXG4gICAgcGVybWFuZW50X2NhY2hlID0gX3JlYWRfZnJvbV9maWxlKHBlcm1hbmVudF9jYWNoZV9maWxlKVxcbiAgICB0ZW1wX2NhY2hlID0gX3JlYWRfZnJvbV9maWxlKHRlbXBfY2FjaGVfZmlsZSlcXG4gICAgaWYgY2FjaGVfa2V5IGluIHRlbXBfY2FjaGU6XFxuICAgICAgICBwcmludChcXFwiZm91bmQgaW4gcGFnZS1zcGVjaWZpYyBjYWNoZVxcXCIpXFxuICAgICAgICAjIG1ha2UgYSBSZXNwb25zZSBvYmplY3QgY29udGFpbmluZyB0ZXh0IGZyb20gdGhlIGNoYW5nZSwgYW5kIHRoZSBmdWxsX3VybCB0aGF0IHdvdWxkIGhhdmUgYmVlbiBmZXRjaGVkXFxuICAgICAgICByZXR1cm4gcmVxdWVzdHMuUmVzcG9uc2UodGVtcF9jYWNoZVtjYWNoZV9rZXldLCBmdWxsX3VybClcXG4gICAgZWxpZiBjYWNoZV9rZXkgaW4gcGVybWFuZW50X2NhY2hlOlxcbiAgICAgICAgcHJpbnQoXFxcImZvdW5kIGluIHBlcm1hbmVudF9jYWNoZVxcXCIpXFxuICAgICAgICAjIG1ha2UgYSBSZXNwb25zZSBvYmplY3QgY29udGFpbmluZyB0ZXh0IGZyb20gdGhlIGNoYW5nZSwgYW5kIHRoZSBmdWxsX3VybCB0aGF0IHdvdWxkIGhhdmUgYmVlbiBmZXRjaGVkXFxuICAgICAgICByZXR1cm4gcmVxdWVzdHMuUmVzcG9uc2UocGVybWFuZW50X2NhY2hlW2NhY2hlX2tleV0sIGZ1bGxfdXJsKVxcbiAgICBlbHNlOlxcbiAgICAgICAgcHJpbnQoXFxcIm5ldzsgYWRkaW5nIHRvIGNhY2hlXFxcIilcXG4gICAgICAgICMgYWN0dWFsbHkgcmVxdWVzdCBpdFxcbiAgICAgICAgcmVzcCA9IHJlcXVlc3RzLmdldChiYXNldXJsLCBwYXJhbXMpXFxuICAgICAgICAjIHNhdmUgaXRcXG4gICAgICAgIGFkZF90b19jYWNoZSh0ZW1wX2NhY2hlX2ZpbGUsIGNhY2hlX2tleSwgcmVzcC50ZXh0KVxcbiAgICAgICAgcmV0dXJuIHJlc3BcIixcInNyYy9saWIvcmV4ZWMucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicmV4ZWNcXFwiKVxcblwiLFwic3JjL2xpYi9yZmM4MjIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicmZjODIyXFxcIilcXG5cIixcInNyYy9saWIvcmxjb21wbGV0ZXIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwicmxjb21wbGV0ZXJcXFwiKVxcblwiLFwic3JjL2xpYi9yb2JvdHBhcnNlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJyb2JvdHBhcnNlclxcXCIpXFxuXCIsXCJzcmMvbGliL3J1bnB5LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInJ1bnB5XFxcIilcXG5cIixcInNyYy9saWIvc2NoZWQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2NoZWRcXFwiKVxcblwiLFwic3JjL2xpYi9zZXRzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNldHNcXFwiKVxcblwiLFwic3JjL2xpYi9zZ21sbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNnbWxsaWJcXFwiKVxcblwiLFwic3JjL2xpYi9zaGEucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2hhXFxcIilcXG5cIixcInNyYy9saWIvc2hlbHZlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNoZWx2ZVxcXCIpXFxuXCIsXCJzcmMvbGliL3NobGV4LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNobGV4XFxcIilcXG5cIixcInNyYy9saWIvc2h1dGlsLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNodXRpbFxcXCIpXFxuXCIsXCJzcmMvbGliL3NpdGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic2l0ZVxcXCIpXFxuXCIsXCJzcmMvbGliL3NtdHBkLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNtdHBkXFxcIilcXG5cIixcInNyYy9saWIvc210cGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzbXRwbGliXFxcIilcXG5cIixcInNyYy9saWIvc25kaGRyLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNuZGhkclxcXCIpXFxuXCIsXCJzcmMvbGliL3NvY2tldC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzb2NrZXRcXFwiKVxcblwiLFwic3JjL2xpYi9zcWxpdGUzL19faW5pdF9fLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNxbGl0ZTNcXFwiKVxcblwiLFwic3JjL2xpYi9zcmUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3JlXFxcIilcXG5cIixcInNyYy9saWIvc3JlX2NvbXBpbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3JlX2NvbXBpbGVcXFwiKVxcblwiLFwic3JjL2xpYi9zcmVfY29uc3RhbnRzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNyZV9jb25zdGFudHNcXFwiKVxcblwiLFwic3JjL2xpYi9zcmVfcGFyc2UucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3JlX3BhcnNlXFxcIilcXG5cIixcInNyYy9saWIvc3NsLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInNzbFxcXCIpXFxuXCIsXCJzcmMvbGliL3N0YXQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3RhdFxcXCIpXFxuXCIsXCJzcmMvbGliL3N0YXRpc3RpY3MucHlcIjpcIlxcXCJcXFwiXFxcIlxcbkJhc2ljIHN0YXRpc3RpY3MgbW9kdWxlLlxcblxcblRoaXMgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyBmb3IgY2FsY3VsYXRpbmcgc3RhdGlzdGljcyBvZiBkYXRhLCBpbmNsdWRpbmdcXG5hdmVyYWdlcywgdmFyaWFuY2UsIGFuZCBzdGFuZGFyZCBkZXZpYXRpb24uXFxuXFxuQ2FsY3VsYXRpbmcgYXZlcmFnZXNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbj09PT09PT09PT09PT09PT09PSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuRnVuY3Rpb24gICAgICAgICAgICBEZXNjcmlwdGlvblxcbj09PT09PT09PT09PT09PT09PSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxubWVhbiAgICAgICAgICAgICAgICBBcml0aG1ldGljIG1lYW4gKGF2ZXJhZ2UpIG9mIGRhdGEuXFxuaGFybW9uaWNfbWVhbiAgICAgICBIYXJtb25pYyBtZWFuIG9mIGRhdGEuXFxubWVkaWFuICAgICAgICAgICAgICBNZWRpYW4gKG1pZGRsZSB2YWx1ZSkgb2YgZGF0YS5cXG5tZWRpYW5fbG93ICAgICAgICAgIExvdyBtZWRpYW4gb2YgZGF0YS5cXG5tZWRpYW5faGlnaCAgICAgICAgIEhpZ2ggbWVkaWFuIG9mIGRhdGEuXFxubWVkaWFuX2dyb3VwZWQgICAgICBNZWRpYW4sIG9yIDUwdGggcGVyY2VudGlsZSwgb2YgZ3JvdXBlZCBkYXRhLlxcbm1vZGUgICAgICAgICAgICAgICAgTW9kZSAobW9zdCBjb21tb24gdmFsdWUpIG9mIGRhdGEuXFxuPT09PT09PT09PT09PT09PT09ICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5cXG5DYWxjdWxhdGUgdGhlIGFyaXRobWV0aWMgbWVhbiAoXFxcInRoZSBhdmVyYWdlXFxcIikgb2YgZGF0YTpcXG5cXG4+Pj4gbWVhbihbLTEuMCwgMi41LCAzLjI1LCA1Ljc1XSlcXG4yLjYyNVxcblxcblxcbkNhbGN1bGF0ZSB0aGUgc3RhbmRhcmQgbWVkaWFuIG9mIGRpc2NyZXRlIGRhdGE6XFxuXFxuPj4+IG1lZGlhbihbMiwgMywgNCwgNV0pXFxuMy41XFxuXFxuXFxuQ2FsY3VsYXRlIHRoZSBtZWRpYW4sIG9yIDUwdGggcGVyY2VudGlsZSwgb2YgZGF0YSBncm91cGVkIGludG8gY2xhc3MgaW50ZXJ2YWxzXFxuY2VudHJlZCBvbiB0aGUgZGF0YSB2YWx1ZXMgcHJvdmlkZWQuIEUuZy4gaWYgeW91ciBkYXRhIHBvaW50cyBhcmUgcm91bmRlZCB0b1xcbnRoZSBuZWFyZXN0IHdob2xlIG51bWJlcjpcXG5cXG4+Pj4gbWVkaWFuX2dyb3VwZWQoWzIsIDIsIDMsIDMsIDMsIDRdKSAgI2RvY3Rlc3Q6ICtFTExJUFNJU1xcbjIuODMzMzMzMzMzMy4uLlxcblxcblRoaXMgc2hvdWxkIGJlIGludGVycHJldGVkIGluIHRoaXMgd2F5OiB5b3UgaGF2ZSB0d28gZGF0YSBwb2ludHMgaW4gdGhlIGNsYXNzXFxuaW50ZXJ2YWwgMS41LTIuNSwgdGhyZWUgZGF0YSBwb2ludHMgaW4gdGhlIGNsYXNzIGludGVydmFsIDIuNS0zLjUsIGFuZCBvbmUgaW5cXG50aGUgY2xhc3MgaW50ZXJ2YWwgMy41LTQuNS4gVGhlIG1lZGlhbiBvZiB0aGVzZSBkYXRhIHBvaW50cyBpcyAyLjgzMzMuLi5cXG5cXG5cXG5DYWxjdWxhdGluZyB2YXJpYWJpbGl0eSBvciBzcHJlYWRcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG49PT09PT09PT09PT09PT09PT0gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbkZ1bmN0aW9uICAgICAgICAgICAgRGVzY3JpcHRpb25cXG49PT09PT09PT09PT09PT09PT0gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnB2YXJpYW5jZSAgICAgICAgICAgUG9wdWxhdGlvbiB2YXJpYW5jZSBvZiBkYXRhLlxcbnZhcmlhbmNlICAgICAgICAgICAgU2FtcGxlIHZhcmlhbmNlIG9mIGRhdGEuXFxucHN0ZGV2ICAgICAgICAgICAgICBQb3B1bGF0aW9uIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBkYXRhLlxcbnN0ZGV2ICAgICAgICAgICAgICAgU2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBkYXRhLlxcbj09PT09PT09PT09PT09PT09PSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuXFxuQ2FsY3VsYXRlIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2Ygc2FtcGxlIGRhdGE6XFxuXFxuPj4+IHN0ZGV2KFsyLjUsIDMuMjUsIDUuNSwgMTEuMjUsIDExLjc1XSkgICNkb2N0ZXN0OiArRUxMSVBTSVNcXG40LjM4OTYxODQzNDQ0Li4uXFxuXFxuSWYgeW91IGhhdmUgcHJldmlvdXNseSBjYWxjdWxhdGVkIHRoZSBtZWFuLCB5b3UgY2FuIHBhc3MgaXQgYXMgdGhlIG9wdGlvbmFsXFxuc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBmb3VyIFxcXCJzcHJlYWRcXFwiIGZ1bmN0aW9ucyB0byBhdm9pZCByZWNhbGN1bGF0aW5nIGl0Olxcblxcbj4+PiBkYXRhID0gWzEsIDIsIDIsIDQsIDQsIDQsIDUsIDZdXFxuPj4+IG11ID0gbWVhbihkYXRhKVxcbj4+PiBwdmFyaWFuY2UoZGF0YSwgbXUpXFxuMi41XFxuXFxuXFxuRXhjZXB0aW9uc1xcbi0tLS0tLS0tLS1cXG5cXG5BIHNpbmdsZSBleGNlcHRpb24gaXMgZGVmaW5lZDogU3RhdGlzdGljc0Vycm9yIGlzIGEgc3ViY2xhc3Mgb2YgVmFsdWVFcnJvci5cXG5cXG5cXFwiXFxcIlxcXCJcXG5cXG5fX2FsbF9fID0gWyAnU3RhdGlzdGljc0Vycm9yJyxcXG4gICAgICAgICAgICAncHN0ZGV2JywgJ3B2YXJpYW5jZScsICdzdGRldicsICd2YXJpYW5jZScsXFxuICAgICAgICAgICAgJ21lZGlhbicsICAnbWVkaWFuX2xvdycsICdtZWRpYW5faGlnaCcsICdtZWRpYW5fZ3JvdXBlZCcsXFxuICAgICAgICAgICAgJ21lYW4nLCAnbW9kZScsICdoYXJtb25pY19tZWFuJyxcXG4gICAgICAgICAgXVxcblxcbmZyb20gY29sbGVjdGlvbnMgaW1wb3J0IENvdW50ZXJcXG5mcm9tIG1hdGggaW1wb3J0IHNxcnRcXG5cXG5kZWYgbWVhbihkYXRhKTpcXG4gICAgcmV0dXJuIHN1bShkYXRhKSAvIGxlbihkYXRhKVxcblxcbmRlZiBoYXJtb25pY19tZWFuKGRhdGEpOlxcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXFxuXFxuXFxuZGVmIG1lZGlhbihkYXRhKTpcXG4gICAgX2RhdGEgPSBzb3J0ZWQoZGF0YSlcXG4gICAgbCA9IGxlbihfZGF0YSlcXG4gICAgaWYgbCAlIDIgPT0gMDpcXG4gICAgICAgIF9tZWRpYW4gPSAoX2RhdGFbbC8vMl0gKyBfZGF0YVtsLy8yLTFdKSAvIDJcXG4gICAgZWxzZTpcXG4gICAgICAgIF9tZWRpYW4gPSBfZGF0YVtsLy8yXVxcbiAgICByZXR1cm4gX21lZGlhblxcblxcbmRlZiBtZWRpYW5fbG93KGRhdGEpOlxcbiAgICBfZGF0YSA9IHNvcnRlZChkYXRhKVxcbiAgICBsID0gbGVuKF9kYXRhKVxcbiAgICBpZiBsICUgMiA9PSAwOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzItMV1cXG4gICAgZWxzZTpcXG4gICAgICAgIF9tZWRpYW4gPSBfZGF0YVtsLy8yXVxcbiAgICByZXR1cm4gX21lZGlhblxcblxcblxcbmRlZiBtZWRpYW5faGlnaChkYXRhKTpcXG4gICAgX2RhdGEgPSBzb3J0ZWQoZGF0YSlcXG4gICAgbCA9IGxlbihfZGF0YSlcXG4gICAgaWYgbCAlIDIgPT0gMDpcXG4gICAgICAgIF9tZWRpYW4gPSBfZGF0YVtsLy8yXVxcbiAgICBlbHNlOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzJdXFxuICAgIHJldHVybiBfbWVkaWFuXFxuXFxuXFxuZGVmIG1lZGlhbl9ncm91cGVkKGRhdGEpOlxcbiAgICByZXR1cm4gbWVkaWFuKGRhdGEpXFxuXFxuZGVmIG1vZGUoZGF0YSk6XFxuICAgIGNvdW50ZXIgPSBDb3VudGVyKGRhdGEpXFxuICAgIG1heF9jb3VudCA9IG1heChjb3VudGVyLnZhbHVlcygpKVxcbiAgICBfbW9kZSA9IFtrIGZvciBrLHYgaW4gY291bnRlci5pdGVtcygpIGlmIHYgPT0gbWF4X2NvdW50XVxcbiAgICBpZiBsZW4oX21vZGUpID4gMTpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcIk5vIFVuaXF1ZSBNb2RlLCBmb3VuZCB7fSBlcXVhbGx5IGNvbW1vbiB2YWx1ZXNcXFwiLmZvcm1hdChsZW4oX21vZGUpKSlcXG4gICAgZWxzZTpcXG4gICAgICAgIHJldHVybiBfbW9kZVswXVxcblxcblxcbmRlZiB2YXJpYW5jZShkYXRhKTpcXG4gICAgYXZlcmFnZT1tZWFuKGRhdGEpXFxuICAgIF92YXJpYW5jZT0wXFxuICAgIGZvciBkIGluIGRhdGE6XFxuICAgICAgICBfdmFyaWFuY2UgKz0gKChhdmVyYWdlLWQpKioyKVxcbiAgICAgICAgZmluYWxfdmFyaWFuY2U9X3ZhcmlhbmNlL2xlbihkYXRhKVxcbiAgICByZXR1cm4gZmluYWxfdmFyaWFuY2VcXG5cXG5kZWYgcHZhcmlhbmNlKGRhdGEpOlxcbiAgICBhdmVyYWdlPW1lYW4oZGF0YSlcXG4gICAgX3ZhcmlhbmNlPTBcXG4gICAgZm9yIGQgaW4gZGF0YTpcXG4gICAgICAgIF92YXJpYW5jZSArPSAoKGF2ZXJhZ2UtZCkqKjIpXFxuICAgICAgICBmaW5hbF92YXJpYW5jZT1fdmFyaWFuY2UvbGVuKGRhdGEpXFxuICAgIHJldHVybiBmaW5hbF92YXJpYW5jZVxcblxcbmRlZiB2YXJpYW5jZShkYXRhKTpcXG4gICAgYXZlcmFnZT1tZWFuKGRhdGEpXFxuICAgIF92YXJpYW5jZT0wXFxuICAgIGZvciBkIGluIGRhdGE6XFxuICAgICAgICBfdmFyaWFuY2UgKz0gKChhdmVyYWdlLWQpKioyKVxcbiAgICAgICAgZmluYWxfdmFyaWFuY2U9X3ZhcmlhbmNlLyhsZW4oZGF0YSkgLTEpXFxuICAgIHJldHVybiBmaW5hbF92YXJpYW5jZVxcblxcbmRlZiBwc3RkZXYoZGF0YSk6XFxuICAgIHJldHVybiBzcXJ0KHB2YXJpYW5jZShkYXRhKSlcXG5cXG5kZWYgc3RkZXYoZGF0YSk6XFxuICAgIHJldHVybiBzcXJ0KHZhcmlhbmNlKGRhdGEpKVxcblxcblwiLFwic3JjL2xpYi9zdGF0dmZzLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInN0YXR2ZnNcXFwiKVxcblwiLFwic3JjL2xpYi9zdHJpbmdvbGQucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3RyaW5nb2xkXFxcIilcXG5cIixcInNyYy9saWIvc3RyaW5ncHJlcC5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzdHJpbmdwcmVwXFxcIilcXG5cIixcInNyYy9saWIvc3RydWN0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInN0cnVjdFxcXCIpXFxuXCIsXCJzcmMvbGliL3N1YnByb2Nlc3MucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3VicHJvY2Vzc1xcXCIpXFxuXCIsXCJzcmMvbGliL3N1bmF1LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInN1bmF1XFxcIilcXG5cIixcInNyYy9saWIvc3VuYXVkaW8ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3VuYXVkaW9cXFwiKVxcblwiLFwic3JjL2xpYi9zeW1ib2wucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3ltYm9sXFxcIilcXG5cIixcInNyYy9saWIvc3ltdGFibGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwic3ltdGFibGVcXFwiKVxcblwiLFwic3JjL2xpYi90YWJuYW5ueS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0YWJuYW5ueVxcXCIpXFxuXCIsXCJzcmMvbGliL3RhcmZpbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidGFyZmlsZVxcXCIpXFxuXCIsXCJzcmMvbGliL3RlbG5ldGxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0ZWxuZXRsaWJcXFwiKVxcblwiLFwic3JjL2xpYi90ZW1wZmlsZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0ZW1wZmlsZVxcXCIpXFxuXCIsXCJzcmMvbGliL3Rlc3QvX19pbml0X18ucHlcIjpcIl9fYXV0aG9yX18gPSAnYm1pbGxlcidcXG5cXG5kZWYgdGVzdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHBsYWNlcz01KTpcXG4gICAgaWYgaXNpbnN0YW5jZShleHBlY3RlZCxpbnQpOlxcbiAgICAgICAgaWYgYWN0dWFsID09IGV4cGVjdGVkOlxcbiAgICAgICAgICAgIHByaW50KCdQYXNzJylcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICBlbGlmIGlzaW5zdGFuY2UoZXhwZWN0ZWQsZmxvYXQpOlxcbiAgICAgICAgaWYgYWJzKGFjdHVhbC1leHBlY3RlZCkgPCAxMCoqKC1wbGFjZXMpOlxcbiAgICAgICAgICAgIHByaW50KCdQYXNzJylcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICBlbHNlOlxcbiAgICAgICAgaWYgYWN0dWFsID09IGV4cGVjdGVkOlxcbiAgICAgICAgICAgIHByaW50KCdQYXNzJylcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICBwcmludCgnVGVzdCBGYWlsZWQ6IGV4cGVjdGVkICcgKyBzdHIoZXhwZWN0ZWQpICsgJyBidXQgZ290ICcgKyBzdHIoYWN0dWFsKSlcXG4gICAgcmV0dXJuIEZhbHNlXFxuXFxuZGVmIHRlc3ROb3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKTpcXG4gICAgcGFzc1xcblxcblwiLFwic3JjL2xpYi90ZXN0L2Fubl9tb2R1bGUucHlcIjpcIlxcblxcblxcXCJcXFwiXFxcIlxcblRoZSBtb2R1bGUgZm9yIHRlc3RpbmcgdmFyaWFibGUgYW5ub3RhdGlvbnMuXFxuRW1wdHkgbGluZXMgYWJvdmUgYXJlIGZvciBnb29kIHJlYXNvbiAodGVzdGluZyBmb3IgY29ycmVjdCBsaW5lIG51bWJlcnMpXFxuXFxcIlxcXCJcXFwiXFxuXFxuIyBmcm9tIHR5cGluZyBpbXBvcnQgT3B0aW9uYWxcXG4jIGZyb20gZnVuY3Rvb2xzIGltcG9ydCB3cmFwc1xcblxcbl9fYW5ub3RhdGlvbnNfX1sxXSA9IDJcXG5cXG5jbGFzcyBDOlxcblxcbiAgICB4ID0gNTsgI3k6IE9wdGlvbmFsWydDJ10gPSBOb25lXFxuXFxuIyBmcm9tIHR5cGluZyBpbXBvcnQgVHVwbGVcXG54OiBpbnQgPSA1OyB5OiBzdHIgPSB4OyMgZjogVHVwbGVbaW50LCBpbnRdXFxuXFxuY2xhc3MgTSh0eXBlKTpcXG5cXG4gICAgX19hbm5vdGF0aW9uc19fWycxMjMnXSA9IDEyM1xcbiAgICBvOiB0eXBlID0gb2JqZWN0XFxuXFxuKHBhcnMpOiBib29sID0gVHJ1ZVxcblxcbmNsYXNzIEQoQyk6XFxuICAgIGo6IHN0ciA9ICdoaSc7IGs6IHN0cj0gJ2J5ZSdcXG5cXG4jIGZyb20gdHlwZXMgaW1wb3J0IG5ld19jbGFzc1xcbiMgaF9jbGFzcyA9IG5ld19jbGFzcygnSCcsIChDLCkpXFxuIyBqX2NsYXNzID0gbmV3X2NsYXNzKCdKJylcXG5cXG5jbGFzcyBGKCk6XFxuICAgIHo6IGludCA9IDVcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHgpOlxcbiAgICAgICAgcGFzc1xcblxcbmNsYXNzIFkoRik6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHN1cGVyKEYsIHNlbGYpLl9faW5pdF9fKDEyMylcXG5cXG5jbGFzcyBNZXRhKHR5cGUpOlxcbiAgICBkZWYgX19uZXdfXyhtZXRhLCBuYW1lLCBiYXNlcywgbmFtZXNwYWNlKTpcXG4gICAgICAgIHJldHVybiBzdXBlcigpLl9fbmV3X18obWV0YSwgbmFtZSwgYmFzZXMsIG5hbWVzcGFjZSlcXG5cXG5jbGFzcyBTKG1ldGFjbGFzcyA9IE1ldGEpOlxcbiAgICB4OiBzdHIgPSAnc29tZXRoaW5nJ1xcbiAgICB5OiBzdHIgPSAnc29tZXRoaW5nIGVsc2UnXFxuXFxuIyBkZWYgZm9vKHg6IGludCA9IDEwKTpcXG4jICAgICBkZWYgYmFyKHk6IExpc3Rbc3RyXSk6XFxuIyAgICAgICAgIHg6IHN0ciA9ICd5ZXMnXFxuIyAgICAgYmFyKClcXG5cXG4jIGRlZiBkZWMoZnVuYyk6XFxuIyAgICAgQHdyYXBzKGZ1bmMpXFxuIyAgICAgZGVmIHdyYXBwZXIoKmFyZ3MsICoqa3dhcmdzKTpcXG4jICAgICAgICAgcmV0dXJuIGZ1bmMoKmFyZ3MsICoqa3dhcmdzKVxcbiMgICAgIHJldHVybiB3cmFwcGVyXFxuXCIsXCJzcmMvbGliL3Rlc3QvYW5uX21vZHVsZTIucHlcIjpcIlxcXCJcXFwiXFxcIlxcblNvbWUgY29ycmVjdCBzeW50YXggZm9yIHZhcmlhYmxlIGFubm90YXRpb24gaGVyZS5cXG5Nb3JlIGV4YW1wbGVzIGFyZSBpbiB0ZXN0X2dyYW1tYXIgYW5kIHRlc3RfcGFyc2VyLlxcblxcXCJcXFwiXFxcIlxcblxcbiMgZnJvbSB0eXBpbmcgaW1wb3J0IG5vX3R5cGVfY2hlY2ssIENsYXNzVmFyXFxuXFxuaTogaW50ID0gMVxcbmo6IGludFxcbng6IGZsb2F0ID0gaS8xMFxcblxcbmRlZiBmKCk6XFxuICAgICMgY2xhc3MgQzogLi4uXFxuICAgIGNsYXNzIEM6IHBhc3NcXG4gICAgcmV0dXJuIEMoKVxcblxcbmYoKS5uZXdfYXR0cjogb2JqZWN0ID0gb2JqZWN0KClcXG5cXG5jbGFzcyBDOlxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgeDogaW50KSAtPiBOb25lOlxcbiAgICAgICAgc2VsZi54ID0geFxcblxcbmMgPSBDKDUpXFxuYy5uZXdfYXR0cjogaW50ID0gMTBcXG5cXG5fX2Fubm90YXRpb25zX18gPSB7fVxcblxcblxcbiMgQG5vX3R5cGVfY2hlY2tcXG4jIGNsYXNzIE5UQzpcXG4jICAgICBkZWYgbWV0aChzZWxmLCBwYXJhbTogY29tcGxleCkgLT4gTm9uZTpcXG4jICAgICAgICAgLi4uXFxuXFxuIyBjbGFzcyBDVjpcXG4jICAgICB2YXI6IENsYXNzVmFyWydDViddXFxuXFxuIyBDVi52YXIgPSBDVigpXFxuXCIsXCJzcmMvbGliL3Rlc3QvYW5uX21vZHVsZTMucHlcIjpcIlxcXCJcXFwiXFxcIlxcbkNvcnJlY3Qgc3ludGF4IGZvciB2YXJpYWJsZSBhbm5vdGF0aW9uIHRoYXQgc2hvdWxkIGZhaWwgYXQgcnVudGltZVxcbmluIGEgY2VydGFpbiBtYW5uZXIuIE1vcmUgZXhhbXBsZXMgYXJlIGluIHRlc3RfZ3JhbW1hciBhbmQgdGVzdF9wYXJzZXIuXFxuXFxcIlxcXCJcXFwiXFxuXFxuZGVmIGZfYmFkX2FubigpOlxcbiAgICBfX2Fubm90YXRpb25zX19bMV0gPSAyXFxuXFxuY2xhc3MgQ19PSzpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHg6IGludCkgLT4gTm9uZTpcXG4gICAgICAgIHNlbGYueDogbm9fc3VjaF9uYW1lID0geCAgIyBUaGlzIG9uZSBpcyBPSyBhcyBwcm9wb3NlZCBieSBHdWlkb1xcblxcbmNsYXNzIERfYmFkX2FubjpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHg6IGludCkgLT4gTm9uZTpcXG4gICAgICAgIHNmZWwueTogaW50ID0gMFxcblxcbmRlZiBnX2JhZF9hbm4oKTpcXG4gICAgbm9fc3VjaF9uYW1lLmF0dHI6IGludCA9IDBcXG5cIixcInNyYy9saWIvdGVzdC9iYWRfZ2V0YXR0ci5weVwiOlwieCA9IDFcXG5cXG5fX2dldGF0dHJfXyA9IFxcXCJTdXJwcmlzZSFcXFwiXFxuX19kaXJfXyA9IFxcXCJTdXJwcmlzZSBhZ2FpbiFcXFwiXFxuXCIsXCJzcmMvbGliL3Rlc3QvYmFkX2dldGF0dHIyLnB5XCI6XCJkZWYgX19nZXRhdHRyX18oKTpcXG4gICAgXFxcIkJhZCBvbmVcXFwiXFxuXFxueCA9IDFcXG5cXG5kZWYgX19kaXJfXyhiYWRfc2lnKTpcXG4gICAgcmV0dXJuIFtdXFxuXCIsXCJzcmMvbGliL3Rlc3QvYmFkX2dldGF0dHIzLnB5XCI6XCJkZWYgX19nZXRhdHRyX18obmFtZSk6XFxuICAgIGdsb2JhbCBfX2dldGF0dHJfX1xcbiAgICBpZiBuYW1lICE9ICdkZWxnZXRhdHRyJzpcXG4gICAgICAgIHJhaXNlIEF0dHJpYnV0ZUVycm9yXFxuICAgIGRlbCBfX2dldGF0dHJfX1xcbiAgICByYWlzZSBBdHRyaWJ1dGVFcnJvclxcblwiLFwic3JjL2xpYi90ZXN0L2RlY2ltYWx0ZXN0ZGF0YS9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkZWNpbWFsdGVzdGRhdGFcXFwiKVxcblwiLFwic3JjL2xpYi90ZXN0L2dvb2RfZ2V0YXR0ci5weVwiOlwieCA9IDFcXG5cXG5kZWYgX19kaXJfXygpOlxcbiAgICByZXR1cm4gWydhJywgJ2InLCAnYyddXFxuXFxuZGVmIF9fZ2V0YXR0cl9fKG5hbWUpOlxcbiAgICBpZiBuYW1lID09IFxcXCJ5b2xvXFxcIjpcXG4gICAgICAgIHJhaXNlIEF0dHJpYnV0ZUVycm9yKFxcXCJEZXByZWNhdGVkLCB1c2Ugd2hhdGV2ZXIgaW5zdGVhZFxcXCIpXFxuICAgIHJldHVybiBmXFxcIlRoZXJlIGlzIHtuYW1lfVxcXCJcXG5cXG55ID0gMlxcblwiLFwic3JjL2xpYi90ZXN0L3Rlc3Rfc3VwcG9ydC5weVwiOlwiXFxcIlxcXCJcXFwiU3VwcG9ydGluZyBkZWZpbml0aW9ucyBmb3IgdGhlIFB5dGhvbiByZWdyZXNzaW9uIHRlc3RzLlxcXCJcXFwiXFxcIlxcblxcbmlmIF9fbmFtZV9fICE9ICd0ZXN0LnRlc3Rfc3VwcG9ydCc6XFxuICAgIHJhaXNlIEltcG9ydEVycm9yKCd0ZXN0X3N1cHBvcnQgbXVzdCBiZSBpbXBvcnRlZCBmcm9tIHRoZSB0ZXN0IHBhY2thZ2UnKVxcblxcbmltcG9ydCB1bml0dGVzdFxcblxcblxcbiMgZGVmIHJ1bl91bml0dGVzdCgqY2xhc3Nlcyk6XFxuIyAgICAgXFxcIlxcXCJcXFwiUnVuIHRlc3RzIGZyb20gdW5pdHRlc3QuVGVzdENhc2UtZGVyaXZlZCBjbGFzc2VzLlxcXCJcXFwiXFxcIlxcbiMgICAgIHZhbGlkX3R5cGVzID0gKHVuaXR0ZXN0LlRlc3RTdWl0ZSwgdW5pdHRlc3QuVGVzdENhc2UpXFxuIyAgICAgc3VpdGUgPSB1bml0dGVzdC5UZXN0U3VpdGUoKVxcbiMgICAgIGZvciBjbHMgaW4gY2xhc3NlczpcXG4jICAgICAgICAgaWYgaXNpbnN0YW5jZShjbHMsIHN0cik6XFxuIyAgICAgICAgICAgICBpZiBjbHMgaW4gc3lzLm1vZHVsZXM6XFxuIyAgICAgICAgICAgICAgICAgc3VpdGUuYWRkVGVzdCh1bml0dGVzdC5maW5kVGVzdENhc2VzKHN5cy5tb2R1bGVzW2Nsc10pKVxcbiMgICAgICAgICAgICAgZWxzZTpcXG4jICAgICAgICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJzdHIgYXJndW1lbnRzIG11c3QgYmUga2V5cyBpbiBzeXMubW9kdWxlc1xcXCIpXFxuIyAgICAgICAgIGVsaWYgaXNpbnN0YW5jZShjbHMsIHZhbGlkX3R5cGVzKTpcXG4jICAgICAgICAgICAgIHN1aXRlLmFkZFRlc3QoY2xzKVxcbiMgICAgICAgICBlbHNlOlxcbiMgICAgICAgICAgICAgc3VpdGUuYWRkVGVzdCh1bml0dGVzdC5tYWtlU3VpdGUoY2xzKSlcXG4jICAgICBfcnVuX3N1aXRlKHN1aXRlKVxcblxcbmRlZiBydW5fdW5pdHRlc3QoKmNsYXNzZXMpOlxcbiAgICBcXFwiXFxcIlxcXCJSdW4gdGVzdHMgZnJvbSB1bml0dGVzdC5UZXN0Q2FzZS1kZXJpdmVkIGNsYXNzZXMuXFxcIlxcXCJcXFwiXFxuICAgIGZvciBjbHMgaW4gY2xhc3NlczpcXG4gICAgICAgIHByaW50IGNsc1xcbiAgICAgICAgaWYgaXNzdWJjbGFzcyhjbHMsIHVuaXR0ZXN0LlRlc3RDYXNlKTpcXG4gICAgICAgICAgICBjbHMoKS5tYWluKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcHJpbnQgXFxcIkRvbid0IGtub3cgd2hhdCB0byBkbyB3aXRoIFxcXCIsIGNsc1xcblwiLFwic3JjL2xpYi90ZXh0d3JhcC5weVwiOlwiXFxcIlxcXCJcXFwiVGV4dCB3cmFwcGluZyBhbmQgZmlsbGluZy5cXG5cXFwiXFxcIlxcXCJcXG5cXG4jIENvcHlyaWdodCAoQykgMTk5OS0yMDAxIEdyZWdvcnkgUC4gV2FyZC5cXG4jIENvcHlyaWdodCAoQykgMjAwMiwgMjAwMyBQeXRob24gU29mdHdhcmUgRm91bmRhdGlvbi5cXG4jIFdyaXR0ZW4gYnkgR3JlZyBXYXJkIDxnd2FyZEBweXRob24ubmV0PlxcblxcbmltcG9ydCByZSwgc3RyaW5nXFxuXFxuX19hbGxfXyA9IFsnVGV4dFdyYXBwZXInLCAnd3JhcCcsICdmaWxsJywgJ2RlZGVudCcsICdpbmRlbnQnLCAnc2hvcnRlbiddXFxuXFxuIyBIYXJkY29kZSB0aGUgcmVjb2duaXplZCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgdG8gdGhlIFVTLUFTQ0lJXFxuIyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuICBUaGUgbWFpbiByZWFzb24gZm9yIGRvaW5nIHRoaXMgaXMgdGhhdFxcbiMgc29tZSBVbmljb2RlIHNwYWNlcyAobGlrZSBcXFxcdTAwYTApIGFyZSBub24tYnJlYWtpbmcgd2hpdGVzcGFjZXMuXFxuX3doaXRlc3BhY2UgPSAnXFxcXHRcXFxcblxcXFx4MGJcXFxceDBjXFxcXHIgJ1xcblxcbmNsYXNzIFRleHRXcmFwcGVyOlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgT2JqZWN0IGZvciB3cmFwcGluZy9maWxsaW5nIHRleHQuICBUaGUgcHVibGljIGludGVyZmFjZSBjb25zaXN0cyBvZlxcbiAgICB0aGUgd3JhcCgpIGFuZCBmaWxsKCkgbWV0aG9kczsgdGhlIG90aGVyIG1ldGhvZHMgYXJlIGp1c3QgdGhlcmUgZm9yXFxuICAgIHN1YmNsYXNzZXMgdG8gb3ZlcnJpZGUgaW4gb3JkZXIgdG8gdHdlYWsgdGhlIGRlZmF1bHQgYmVoYXZpb3VyLlxcbiAgICBJZiB5b3Ugd2FudCB0byBjb21wbGV0ZWx5IHJlcGxhY2UgdGhlIG1haW4gd3JhcHBpbmcgYWxnb3JpdGhtLFxcbiAgICB5b3UnbGwgcHJvYmFibHkgaGF2ZSB0byBvdmVycmlkZSBfd3JhcF9jaHVua3MoKS5cXG4gICAgU2V2ZXJhbCBpbnN0YW5jZSBhdHRyaWJ1dGVzIGNvbnRyb2wgdmFyaW91cyBhc3BlY3RzIG9mIHdyYXBwaW5nOlxcbiAgICAgIHdpZHRoIChkZWZhdWx0OiA3MClcXG4gICAgICAgIHRoZSBtYXhpbXVtIHdpZHRoIG9mIHdyYXBwZWQgbGluZXMgKHVubGVzcyBicmVha19sb25nX3dvcmRzXFxuICAgICAgICBpcyBmYWxzZSlcXG4gICAgICBpbml0aWFsX2luZGVudCAoZGVmYXVsdDogXFxcIlxcXCIpXFxuICAgICAgICBzdHJpbmcgdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgZmlyc3QgbGluZSBvZiB3cmFwcGVkXFxuICAgICAgICBvdXRwdXQuICBDb3VudHMgdG93YXJkcyB0aGUgbGluZSdzIHdpZHRoLlxcbiAgICAgIHN1YnNlcXVlbnRfaW5kZW50IChkZWZhdWx0OiBcXFwiXFxcIilcXG4gICAgICAgIHN0cmluZyB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGFsbCBsaW5lcyBzYXZlIHRoZSBmaXJzdFxcbiAgICAgICAgb2Ygd3JhcHBlZCBvdXRwdXQ7IGFsc28gY291bnRzIHRvd2FyZHMgZWFjaCBsaW5lJ3Mgd2lkdGguXFxuICAgICAgZXhwYW5kX3RhYnMgKGRlZmF1bHQ6IHRydWUpXFxuICAgICAgICBFeHBhbmQgdGFicyBpbiBpbnB1dCB0ZXh0IHRvIHNwYWNlcyBiZWZvcmUgZnVydGhlciBwcm9jZXNzaW5nLlxcbiAgICAgICAgRWFjaCB0YWIgd2lsbCBiZWNvbWUgMCAuLiAndGFic2l6ZScgc3BhY2VzLCBkZXBlbmRpbmcgb24gaXRzIHBvc2l0aW9uXFxuICAgICAgICBpbiBpdHMgbGluZS4gIElmIGZhbHNlLCBlYWNoIHRhYiBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIGNoYXJhY3Rlci5cXG4gICAgICB0YWJzaXplIChkZWZhdWx0OiA4KVxcbiAgICAgICAgRXhwYW5kIHRhYnMgaW4gaW5wdXQgdGV4dCB0byAwIC4uICd0YWJzaXplJyBzcGFjZXMsIHVubGVzc1xcbiAgICAgICAgJ2V4cGFuZF90YWJzJyBpcyBmYWxzZS5cXG4gICAgICByZXBsYWNlX3doaXRlc3BhY2UgKGRlZmF1bHQ6IHRydWUpXFxuICAgICAgICBSZXBsYWNlIGFsbCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHRleHQgYnkgc3BhY2VzXFxuICAgICAgICBhZnRlciB0YWIgZXhwYW5zaW9uLiAgTm90ZSB0aGF0IGlmIGV4cGFuZF90YWJzIGlzIGZhbHNlIGFuZFxcbiAgICAgICAgcmVwbGFjZV93aGl0ZXNwYWNlIGlzIHRydWUsIGV2ZXJ5IHRhYiB3aWxsIGJlIGNvbnZlcnRlZCB0byBhXFxuICAgICAgICBzaW5nbGUgc3BhY2UhXFxuICAgICAgZml4X3NlbnRlbmNlX2VuZGluZ3MgKGRlZmF1bHQ6IGZhbHNlKVxcbiAgICAgICAgRW5zdXJlIHRoYXQgc2VudGVuY2UtZW5kaW5nIHB1bmN0dWF0aW9uIGlzIGFsd2F5cyBmb2xsb3dlZFxcbiAgICAgICAgYnkgdHdvIHNwYWNlcy4gIE9mZiBieSBkZWZhdWx0IGJlY2F1c2UgdGhlIGFsZ29yaXRobSBpc1xcbiAgICAgICAgKHVuYXZvaWRhYmx5KSBpbXBlcmZlY3QuXFxuICAgICAgYnJlYWtfbG9uZ193b3JkcyAoZGVmYXVsdDogdHJ1ZSlcXG4gICAgICAgIEJyZWFrIHdvcmRzIGxvbmdlciB0aGFuICd3aWR0aCcuICBJZiBmYWxzZSwgdGhvc2Ugd29yZHMgd2lsbCBub3RcXG4gICAgICAgIGJlIGJyb2tlbiwgYW5kIHNvbWUgbGluZXMgbWlnaHQgYmUgbG9uZ2VyIHRoYW4gJ3dpZHRoJy5cXG4gICAgICBicmVha19vbl9oeXBoZW5zIChkZWZhdWx0OiB0cnVlKVxcbiAgICAgICAgQWxsb3cgYnJlYWtpbmcgaHlwaGVuYXRlZCB3b3Jkcy4gSWYgdHJ1ZSwgd3JhcHBpbmcgd2lsbCBvY2N1clxcbiAgICAgICAgcHJlZmVyYWJseSBvbiB3aGl0ZXNwYWNlcyBhbmQgcmlnaHQgYWZ0ZXIgaHlwaGVucyBwYXJ0IG9mXFxuICAgICAgICBjb21wb3VuZCB3b3Jkcy5cXG4gICAgICBkcm9wX3doaXRlc3BhY2UgKGRlZmF1bHQ6IHRydWUpXFxuICAgICAgICBEcm9wIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBsaW5lcy5cXG4gICAgICBtYXhfbGluZXMgKGRlZmF1bHQ6IE5vbmUpXFxuICAgICAgICBUcnVuY2F0ZSB3cmFwcGVkIGxpbmVzLlxcbiAgICAgIHBsYWNlaG9sZGVyIChkZWZhdWx0OiAnIFsuLi5dJylcXG4gICAgICAgIEFwcGVuZCB0byB0aGUgbGFzdCBsaW5lIG9mIHRydW5jYXRlZCB0ZXh0LlxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgdW5pY29kZV93aGl0ZXNwYWNlX3RyYW5zID0ge31cXG4gICAgIyB1c3BhY2UgPSBvcmQoJyAnKVxcbiAgICB1c3BhY2UgPSAnICdcXG4gICAgZm9yIHggaW4gX3doaXRlc3BhY2U6XFxuICAgICAgICAjIHVuaWNvZGVfd2hpdGVzcGFjZV90cmFuc1tvcmQoeCldID0gdXNwYWNlXFxuICAgICAgICB1bmljb2RlX3doaXRlc3BhY2VfdHJhbnNbeF0gPSB1c3BhY2VcXG5cXG4gICAgIyBUaGlzIGZ1bmt5IGxpdHRsZSByZWdleCBpcyBqdXN0IHRoZSB0cmljayBmb3Igc3BsaXR0aW5nXFxuICAgICMgdGV4dCB1cCBpbnRvIHdvcmQtd3JhcHBhYmxlIGNodW5rcy4gIEUuZy5cXG4gICAgIyAgIFxcXCJIZWxsbyB0aGVyZSAtLSB5b3UgZ29vZi1iYWxsLCB1c2UgdGhlIC1iIG9wdGlvbiFcXFwiXFxuICAgICMgc3BsaXRzIGludG9cXG4gICAgIyAgIEhlbGxvLyAvdGhlcmUvIC8tLS8gL3lvdS8gL2dvb2YtL2JhbGwsLyAvdXNlLyAvdGhlLyAvLWIvIC9vcHRpb24hXFxuICAgICMgKGFmdGVyIHN0cmlwcGluZyBvdXQgZW1wdHkgc3RyaW5ncykuXFxuICAgIHdvcmRzZXBfcmUgPSByZS5jb21waWxlKFxcbiAgICAgICAgcicoXFxcXHMrfCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBhbnkgd2hpdGVzcGFjZVxcbiAgICAgICAgcidbXlxcXFxzXFxcXHddKlxcXFx3K1teMC05XFxcXFddLSg/PVxcXFx3K1teMC05XFxcXFddKSknKSAgIyBoeXBoZW5hdGVkIHdvcmRzXFxuICAgIGVtX2Rhc2ggPSByZS5jb21waWxlKHInKFxcXFxzK3wnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgYW55IHdoaXRlc3BhY2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgcidbXlxcXFxzXFxcXHddKlxcXFx3K1teMC05XFxcXFddLSg/PVxcXFx3K1teMC05XFxcXFddKXwnICAgIyBoeXBoZW5hdGVkIHdvcmRzXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHInKD8hXiktezIsfSg/PVxcXFx3KSknKSAgICAgICAgICAgICAgICAgICAgICMgZW0tZGFzaFxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgIyBUaGlzIGxlc3MgZnVua3kgbGl0dGxlIHJlZ2V4IGp1c3Qgc3BsaXQgb24gcmVjb2duaXplZCBzcGFjZXMuIEUuZy5cXG4gICAgIyAgIFxcXCJIZWxsbyB0aGVyZSAtLSB5b3UgZ29vZi1iYWxsLCB1c2UgdGhlIC1iIG9wdGlvbiFcXFwiXFxuICAgICMgc3BsaXRzIGludG9cXG4gICAgIyAgIEhlbGxvLyAvdGhlcmUvIC8tLS8gL3lvdS8gL2dvb2YtYmFsbCwvIC91c2UvIC90aGUvIC8tYi8gL29wdGlvbiEvXFxuICAgIHdvcmRzZXBfc2ltcGxlX3JlID0gcmUuY29tcGlsZShyJyhcXFxccyspJylcXG5cXG5cXG4gICAgIyBYWFggdGhpcyBpcyBub3QgbG9jYWxlLSBvciBjaGFyc2V0LWF3YXJlIC0tIHN0cmluZy5sb3dlcmNhc2VcXG4gICAgIyBpcyBVUy1BU0NJSSBvbmx5IChhbmQgdGhlcmVmb3JlIEVuZ2xpc2gtb25seSlcXG4gICAgc2VudGVuY2VfZW5kX3JlID0gcmUuY29tcGlsZShyJ1thLXpdJyAgICAgICAgICAgICAjIGxvd2VyY2FzZSBsZXR0ZXJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByJ1tcXFxcLlxcXFwhXFxcXD9dJyAgICAgICAgICAjIHNlbnRlbmNlLWVuZGluZyBwdW5jdC5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByJ1tcXFxcXFxcIlxcXFwnXT8nICAgICAgICAgICAjIG9wdGlvbmFsIGVuZC1vZi1xdW90ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHInXFxcXFonKSAgICAgICAgICAgICAgICMgZW5kIG9mIGNodW5rXFxuICAgIHNlbnRlbmNlX2VuZF9yZSA9IHInW2Etel1bXFxcXC5cXFxcIVxcXFw/XVtcXFxcXFxcIlxcXFwnXT8nXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLFxcbiAgICAgICAgICAgICAgICAgd2lkdGg9NzAsXFxuICAgICAgICAgICAgICAgICBpbml0aWFsX2luZGVudD1cXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgIHN1YnNlcXVlbnRfaW5kZW50PVxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgZXhwYW5kX3RhYnM9VHJ1ZSxcXG4gICAgICAgICAgICAgICAgIHJlcGxhY2Vfd2hpdGVzcGFjZT1UcnVlLFxcbiAgICAgICAgICAgICAgICAgZml4X3NlbnRlbmNlX2VuZGluZ3M9RmFsc2UsXFxuICAgICAgICAgICAgICAgICBicmVha19sb25nX3dvcmRzPVRydWUsXFxuICAgICAgICAgICAgICAgICBkcm9wX3doaXRlc3BhY2U9VHJ1ZSxcXG4gICAgICAgICAgICAgICAgIGJyZWFrX29uX2h5cGhlbnM9VHJ1ZSxcXG4gICAgICAgICAgICAgICAgIHRhYnNpemU9OCxcXG4gICAgICAgICAgICAgICAgIG1heF9saW5lcz1Ob25lLFxcbiAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9JyBbLi4uXScpOlxcbiAgICAgICAgc2VsZi53aWR0aCA9IHdpZHRoXFxuICAgICAgICBzZWxmLmluaXRpYWxfaW5kZW50ID0gaW5pdGlhbF9pbmRlbnRcXG4gICAgICAgIHNlbGYuc3Vic2VxdWVudF9pbmRlbnQgPSBzdWJzZXF1ZW50X2luZGVudFxcbiAgICAgICAgc2VsZi5leHBhbmRfdGFicyA9IGV4cGFuZF90YWJzXFxuICAgICAgICBzZWxmLnJlcGxhY2Vfd2hpdGVzcGFjZSA9IHJlcGxhY2Vfd2hpdGVzcGFjZVxcbiAgICAgICAgc2VsZi5maXhfc2VudGVuY2VfZW5kaW5ncyA9IGZpeF9zZW50ZW5jZV9lbmRpbmdzXFxuICAgICAgICBzZWxmLmJyZWFrX2xvbmdfd29yZHMgPSBicmVha19sb25nX3dvcmRzXFxuICAgICAgICBzZWxmLmRyb3Bfd2hpdGVzcGFjZSA9IGRyb3Bfd2hpdGVzcGFjZVxcbiAgICAgICAgc2VsZi5icmVha19vbl9oeXBoZW5zID0gYnJlYWtfb25faHlwaGVuc1xcbiAgICAgICAgc2VsZi50YWJzaXplID0gdGFic2l6ZVxcbiAgICAgICAgc2VsZi5tYXhfbGluZXMgPSBtYXhfbGluZXNcXG4gICAgICAgIHNlbGYucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlclxcblxcblxcbiAgICAjIC0tIFByaXZhdGUgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAjIChwb3NzaWJseSB1c2VmdWwgZm9yIHN1YmNsYXNzZXMgdG8gb3ZlcnJpZGUpXFxuXFxuICAgIGRlZiBfbXVuZ2Vfd2hpdGVzcGFjZShzZWxmLCB0ZXh0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIl9tdW5nZV93aGl0ZXNwYWNlKHRleHQgOiBzdHJpbmcpIC0+IHN0cmluZ1xcbiAgICAgICAgTXVuZ2Ugd2hpdGVzcGFjZSBpbiB0ZXh0OiBleHBhbmQgdGFicyBhbmQgY29udmVydCBhbGwgb3RoZXJcXG4gICAgICAgIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB0byBzcGFjZXMuICBFZy4gXFxcIiBmb29cXFxcXFxcXHRiYXJcXFxcXFxcXG5cXFxcXFxcXG5iYXpcXFwiXFxuICAgICAgICBiZWNvbWVzIFxcXCIgZm9vICAgIGJhciAgYmF6XFxcIi5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5leHBhbmRfdGFiczpcXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5leHBhbmR0YWJzKHNlbGYudGFic2l6ZSlcXG4gICAgICAgIGlmIHNlbGYucmVwbGFjZV93aGl0ZXNwYWNlOlxcbiAgICAgICAgICAgIGZvciBrZXksIHZhbCBpbiBzZWxmLnVuaWNvZGVfd2hpdGVzcGFjZV90cmFucy5pdGVtcygpOlxcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGtleSwgdmFsKVxcbiAgICAgICAgcmV0dXJuIHRleHRcXG5cXG5cXG4gICAgZGVmIF9zcGxpdChzZWxmLCB0ZXh0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIl9zcGxpdCh0ZXh0IDogc3RyaW5nKSAtPiBbc3RyaW5nXVxcbiAgICAgICAgU3BsaXQgdGhlIHRleHQgdG8gd3JhcCBpbnRvIGluZGl2aXNpYmxlIGNodW5rcy4gIENodW5rcyBhcmVcXG4gICAgICAgIG5vdCBxdWl0ZSB0aGUgc2FtZSBhcyB3b3Jkczsgc2VlIF93cmFwX2NodW5rcygpIGZvciBmdWxsXFxuICAgICAgICBkZXRhaWxzLiAgQXMgYW4gZXhhbXBsZSwgdGhlIHRleHRcXG4gICAgICAgICAgTG9vaywgZ29vZi1iYWxsIC0tIHVzZSB0aGUgLWIgb3B0aW9uIVxcbiAgICAgICAgYnJlYWtzIGludG8gdGhlIGZvbGxvd2luZyBjaHVua3M6XFxuICAgICAgICAgICdMb29rLCcsICcgJywgJ2dvb2YtJywgJ2JhbGwnLCAnICcsICctLScsICcgJyxcXG4gICAgICAgICAgJ3VzZScsICcgJywgJ3RoZScsICcgJywgJy1iJywgJyAnLCAnb3B0aW9uISdcXG4gICAgICAgIGlmIGJyZWFrX29uX2h5cGhlbnMgaXMgVHJ1ZSwgb3IgaW46XFxuICAgICAgICAgICdMb29rLCcsICcgJywgJ2dvb2YtYmFsbCcsICcgJywgJy0tJywgJyAnLFxcbiAgICAgICAgICAndXNlJywgJyAnLCAndGhlJywgJyAnLCAnLWInLCAnICcsIG9wdGlvbiEnXFxuICAgICAgICBvdGhlcndpc2UuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuYnJlYWtfb25faHlwaGVucyBpcyBUcnVlOlxcbiAgICAgICAgICAgIGNodW5rcyA9IHNlbGYud29yZHNlcF9yZS5zcGxpdCh0ZXh0KVxcbiAgICAgICAgICAgIGlmIFxcXCItLVxcXCIgaW4gdGV4dDpcXG4gICAgICAgICAgICAgICAgY2h1bmtzID0gW2l0ZW0gXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBzdWJsaXN0IGluIFtzZWxmLmVtX2Rhc2guc3BsaXQoY2h1bmspIGZvciBjaHVuayBpbiBjaHVua3NdIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGl0ZW0gaW4gc3VibGlzdF1cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgY2h1bmtzID0gc2VsZi53b3Jkc2VwX3NpbXBsZV9yZS5zcGxpdCh0ZXh0KVxcbiAgICAgICAgY2h1bmtzID0gW2MgZm9yIGMgaW4gY2h1bmtzIGlmIGNdXFxuICAgICAgICByZXR1cm4gY2h1bmtzXFxuXFxuICAgIGRlZiBfZml4X3NlbnRlbmNlX2VuZGluZ3Moc2VsZiwgY2h1bmtzKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIl9maXhfc2VudGVuY2VfZW5kaW5ncyhjaHVua3MgOiBbc3RyaW5nXSlcXG4gICAgICAgIENvcnJlY3QgZm9yIHNlbnRlbmNlIGVuZGluZ3MgYnVyaWVkIGluICdjaHVua3MnLiAgRWcuIHdoZW4gdGhlXFxuICAgICAgICBvcmlnaW5hbCB0ZXh0IGNvbnRhaW5zIFxcXCIuLi4gZm9vLlxcXFxcXFxcbkJhciAuLi5cXFwiLCBtdW5nZV93aGl0ZXNwYWNlKClcXG4gICAgICAgIGFuZCBzcGxpdCgpIHdpbGwgY29udmVydCB0aGF0IHRvIFsuLi4sIFxcXCJmb28uXFxcIiwgXFxcIiBcXFwiLCBcXFwiQmFyXFxcIiwgLi4uXVxcbiAgICAgICAgd2hpY2ggaGFzIG9uZSB0b28gZmV3IHNwYWNlczsgdGhpcyBtZXRob2Qgc2ltcGx5IGNoYW5nZXMgdGhlIG9uZVxcbiAgICAgICAgc3BhY2UgdG8gdHdvLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpID0gMFxcbiAgICAgICAgIyBwYXRzZWFyY2ggPSBzZWxmLnNlbnRlbmNlX2VuZF9yZS5zZWFyY2hcXG4gICAgICAgIHdoaWxlIGkgPCBsZW4oY2h1bmtzKS0xOlxcbiAgICAgICAgICAgIGlmIGNodW5rc1tpKzFdID09IFxcXCIgXFxcIiBhbmQgcmUuc2VhcmNoKHNlbGYuc2VudGVuY2VfZW5kX3JlLCBjaHVua3NbaV0pIGFuZCBjaHVua3NbaV1bLTFdIGluIFxcXCIuIT9cXFxcXFxcIlxcXFwnXFxcIjpcXG4gICAgICAgICAgICAgICAgY2h1bmtzW2krMV0gPSBcXFwiICBcXFwiXFxuICAgICAgICAgICAgICAgIGkgKz0gMlxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGkgKz0gMVxcblxcbiAgICBkZWYgX2hhbmRsZV9sb25nX3dvcmQoc2VsZiwgcmV2ZXJzZWRfY2h1bmtzLCBjdXJfbGluZSwgY3VyX2xlbiwgd2lkdGgpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX2hhbmRsZV9sb25nX3dvcmQoY2h1bmtzIDogW3N0cmluZ10sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGluZSA6IFtzdHJpbmddLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyX2xlbiA6IGludCwgd2lkdGggOiBpbnQpXFxuICAgICAgICBIYW5kbGUgYSBjaHVuayBvZiB0ZXh0IChtb3N0IGxpa2VseSBhIHdvcmQsIG5vdCB3aGl0ZXNwYWNlKSB0aGF0XFxuICAgICAgICBpcyB0b28gbG9uZyB0byBmaXQgaW4gYW55IGxpbmUuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgICMgRmlndXJlIG91dCB3aGVuIGluZGVudCBpcyBsYXJnZXIgdGhhbiB0aGUgc3BlY2lmaWVkIHdpZHRoLCBhbmQgbWFrZVxcbiAgICAgICAgIyBzdXJlIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaXMgc3RyaXBwZWQgb2ZmIG9uIGV2ZXJ5IHBhc3NcXG4gICAgICAgIGlmIHdpZHRoIDwgMTpcXG4gICAgICAgICAgICBzcGFjZV9sZWZ0ID0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzcGFjZV9sZWZ0ID0gd2lkdGggLSBjdXJfbGVuXFxuXFxuICAgICAgICAjIElmIHdlJ3JlIGFsbG93ZWQgdG8gYnJlYWsgbG9uZyB3b3JkcywgdGhlbiBkbyBzbzogcHV0IGFzIG11Y2hcXG4gICAgICAgICMgb2YgdGhlIG5leHQgY2h1bmsgb250byB0aGUgY3VycmVudCBsaW5lIGFzIHdpbGwgZml0LlxcbiAgICAgICAgaWYgc2VsZi5icmVha19sb25nX3dvcmRzOlxcbiAgICAgICAgICAgIGN1cl9saW5lLmFwcGVuZChyZXZlcnNlZF9jaHVua3NbLTFdWzpzcGFjZV9sZWZ0XSlcXG4gICAgICAgICAgICByZXZlcnNlZF9jaHVua3NbLTFdID0gcmV2ZXJzZWRfY2h1bmtzWy0xXVtzcGFjZV9sZWZ0Ol1cXG5cXG4gICAgICAgICMgT3RoZXJ3aXNlLCB3ZSBoYXZlIHRvIHByZXNlcnZlIHRoZSBsb25nIHdvcmQgaW50YWN0LiAgT25seSBhZGRcXG4gICAgICAgICMgaXQgdG8gdGhlIGN1cnJlbnQgbGluZSBpZiB0aGVyZSdzIG5vdGhpbmcgYWxyZWFkeSB0aGVyZSAtLVxcbiAgICAgICAgIyB0aGF0IG1pbmltaXplcyBob3cgbXVjaCB3ZSB2aW9sYXRlIHRoZSB3aWR0aCBjb25zdHJhaW50LlxcbiAgICAgICAgZWxpZiBub3QgY3VyX2xpbmU6XFxuICAgICAgICAgICAgY3VyX2xpbmUuYXBwZW5kKHJldmVyc2VkX2NodW5rcy5wb3AoKSlcXG5cXG4gICAgICAgICMgSWYgd2UncmUgbm90IGFsbG93ZWQgdG8gYnJlYWsgbG9uZyB3b3JkcywgYW5kIHRoZXJlJ3MgYWxyZWFkeVxcbiAgICAgICAgIyB0ZXh0IG9uIHRoZSBjdXJyZW50IGxpbmUsIGRvIG5vdGhpbmcuICBOZXh0IHRpbWUgdGhyb3VnaCB0aGVcXG4gICAgICAgICMgbWFpbiBsb29wIG9mIF93cmFwX2NodW5rcygpLCB3ZSdsbCB3aW5kIHVwIGhlcmUgYWdhaW4sIGJ1dFxcbiAgICAgICAgIyBjdXJfbGVuIHdpbGwgYmUgemVybywgc28gdGhlIG5leHQgbGluZSB3aWxsIGJlIGVudGlyZWx5XFxuICAgICAgICAjIGRldm90ZWQgdG8gdGhlIGxvbmcgd29yZCB0aGF0IHdlIGNhbid0IGhhbmRsZSByaWdodCBub3cuXFxuXFxuICAgIGRlZiBfd3JhcF9jaHVua3Moc2VsZiwgY2h1bmtzKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIl93cmFwX2NodW5rcyhjaHVua3MgOiBbc3RyaW5nXSkgLT4gW3N0cmluZ11cXG4gICAgICAgIFdyYXAgYSBzZXF1ZW5jZSBvZiB0ZXh0IGNodW5rcyBhbmQgcmV0dXJuIGEgbGlzdCBvZiBsaW5lcyBvZlxcbiAgICAgICAgbGVuZ3RoICdzZWxmLndpZHRoJyBvciBsZXNzLiAgKElmICdicmVha19sb25nX3dvcmRzJyBpcyBmYWxzZSxcXG4gICAgICAgIHNvbWUgbGluZXMgbWF5IGJlIGxvbmdlciB0aGFuIHRoaXMuKSAgQ2h1bmtzIGNvcnJlc3BvbmQgcm91Z2hseVxcbiAgICAgICAgdG8gd29yZHMgYW5kIHRoZSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlbTogZWFjaCBjaHVuayBpc1xcbiAgICAgICAgaW5kaXZpc2libGUgKG1vZHVsbyAnYnJlYWtfbG9uZ193b3JkcycpLCBidXQgYSBsaW5lIGJyZWFrIGNhblxcbiAgICAgICAgY29tZSBiZXR3ZWVuIGFueSB0d28gY2h1bmtzLiAgQ2h1bmtzIHNob3VsZCBub3QgaGF2ZSBpbnRlcm5hbFxcbiAgICAgICAgd2hpdGVzcGFjZTsgaWUuIGEgY2h1bmsgaXMgZWl0aGVyIGFsbCB3aGl0ZXNwYWNlIG9yIGEgXFxcIndvcmRcXFwiLlxcbiAgICAgICAgV2hpdGVzcGFjZSBjaHVua3Mgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mXFxuICAgICAgICBsaW5lcywgYnV0IGFwYXJ0IGZyb20gdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgbGluZXMgPSBbXVxcbiAgICAgICAgaWYgc2VsZi53aWR0aCA8PSAwOlxcbiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcImludmFsaWQgd2lkdGggJXIgKG11c3QgYmUgPiAwKVxcXCIgJSBzZWxmLndpZHRoKVxcbiAgICAgICAgaWYgc2VsZi5tYXhfbGluZXMgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgaWYgc2VsZi5tYXhfbGluZXMgPiAxOlxcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBzZWxmLnN1YnNlcXVlbnRfaW5kZW50XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc2VsZi5pbml0aWFsX2luZGVudFxcbiAgICAgICAgICAgIGlmIGxlbihpbmRlbnQpICsgbGVuKHNlbGYucGxhY2Vob2xkZXIubHN0cmlwKCkpID4gc2VsZi53aWR0aDpcXG4gICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwicGxhY2Vob2xkZXIgdG9vIGxhcmdlIGZvciBtYXggd2lkdGhcXFwiKVxcblxcbiAgICAgICAgIyBBcnJhbmdlIGluIHJldmVyc2Ugb3JkZXIgc28gaXRlbXMgY2FuIGJlIGVmZmljaWVudGx5IHBvcHBlZFxcbiAgICAgICAgIyBmcm9tIGEgc3RhY2sgb2YgY2h1Y2tzLlxcbiAgICAgICAgY2h1bmtzLnJldmVyc2UoKVxcblxcbiAgICAgICAgd2hpbGUgY2h1bmtzOlxcblxcbiAgICAgICAgICAgICMgU3RhcnQgdGhlIGxpc3Qgb2YgY2h1bmtzIHRoYXQgd2lsbCBtYWtlIHVwIHRoZSBjdXJyZW50IGxpbmUuXFxuICAgICAgICAgICAgIyBjdXJfbGVuIGlzIGp1c3QgdGhlIGxlbmd0aCBvZiBhbGwgdGhlIGNodW5rcyBpbiBjdXJfbGluZS5cXG4gICAgICAgICAgICBjdXJfbGluZSA9IFtdXFxuICAgICAgICAgICAgY3VyX2xlbiA9IDBcXG5cXG4gICAgICAgICAgICAjIEZpZ3VyZSBvdXQgd2hpY2ggc3RhdGljIHN0cmluZyB3aWxsIHByZWZpeCB0aGlzIGxpbmUuXFxuICAgICAgICAgICAgaWYgbGluZXM6XFxuICAgICAgICAgICAgICAgIGluZGVudCA9IHNlbGYuc3Vic2VxdWVudF9pbmRlbnRcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBzZWxmLmluaXRpYWxfaW5kZW50XFxuXFxuICAgICAgICAgICAgIyBNYXhpbXVtIHdpZHRoIGZvciB0aGlzIGxpbmUuXFxuICAgICAgICAgICAgd2lkdGggPSBzZWxmLndpZHRoIC0gbGVuKGluZGVudClcXG5cXG4gICAgICAgICAgICAjIEZpcnN0IGNodW5rIG9uIGxpbmUgaXMgd2hpdGVzcGFjZSAtLSBkcm9wIGl0LCB1bmxlc3MgdGhpc1xcbiAgICAgICAgICAgICMgaXMgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0IChpZS4gbm8gbGluZXMgc3RhcnRlZCB5ZXQpLlxcbiAgICAgICAgICAgIGlmIHNlbGYuZHJvcF93aGl0ZXNwYWNlIGFuZCBjaHVua3NbLTFdLnN0cmlwKCkgPT0gJycgYW5kIGxpbmVzOlxcbiAgICAgICAgICAgICAgICBkZWwgY2h1bmtzWy0xXVxcblxcbiAgICAgICAgICAgIHdoaWxlIGNodW5rczpcXG4gICAgICAgICAgICAgICAgbCA9IGxlbihjaHVua3NbLTFdKVxcblxcbiAgICAgICAgICAgICAgICAjIENhbiBhdCBsZWFzdCBzcXVlZXplIHRoaXMgY2h1bmsgb250byB0aGUgY3VycmVudCBsaW5lLlxcbiAgICAgICAgICAgICAgICBpZiBjdXJfbGVuICsgbCA8PSB3aWR0aDpcXG4gICAgICAgICAgICAgICAgICAgIGN1cl9saW5lLmFwcGVuZChjaHVua3MucG9wKCkpXFxuICAgICAgICAgICAgICAgICAgICBjdXJfbGVuICs9IGxcXG5cXG4gICAgICAgICAgICAgICAgIyBOb3BlLCB0aGlzIGxpbmUgaXMgZnVsbC5cXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuXFxuICAgICAgICAgICAgIyBUaGUgY3VycmVudCBsaW5lIGlzIGZ1bGwsIGFuZCB0aGUgbmV4dCBjaHVuayBpcyB0b28gYmlnIHRvXFxuICAgICAgICAgICAgIyBmaXQgb24gKmFueSogbGluZSAobm90IGp1c3QgdGhpcyBvbmUpLlxcbiAgICAgICAgICAgIGlmIGNodW5rcyBhbmQgbGVuKGNodW5rc1stMV0pID4gd2lkdGg6XFxuICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZV9sb25nX3dvcmQoY2h1bmtzLCBjdXJfbGluZSwgY3VyX2xlbiwgd2lkdGgpXFxuICAgICAgICAgICAgICAgIGN1cl9sZW4gPSBzdW0obWFwKGxlbiwgY3VyX2xpbmUpKVxcblxcbiAgICAgICAgICAgICMgSWYgdGhlIGxhc3QgY2h1bmsgb24gdGhpcyBsaW5lIGlzIGFsbCB3aGl0ZXNwYWNlLCBkcm9wIGl0LlxcbiAgICAgICAgICAgIGlmIHNlbGYuZHJvcF93aGl0ZXNwYWNlIGFuZCBjdXJfbGluZSBhbmQgY3VyX2xpbmVbLTFdLnN0cmlwKCkgPT0gJyc6XFxuICAgICAgICAgICAgICAgIGN1cl9sZW4gLT0gbGVuKGN1cl9saW5lWy0xXSlcXG4gICAgICAgICAgICAgICAgZGVsIGN1cl9saW5lWy0xXVxcblxcbiAgICAgICAgICAgIGlmIGN1cl9saW5lOlxcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tYXhfbGluZXMgaXMgTm9uZSBvclxcbiAgICAgICAgICAgICAgICAgICAgbGVuKGxpbmVzKSArIDEgPCBzZWxmLm1heF9saW5lcyBvclxcbiAgICAgICAgICAgICAgICAgICAgKG5vdCBjaHVua3Mgb3JcXG4gICAgICAgICAgICAgICAgICAgICBzZWxmLmRyb3Bfd2hpdGVzcGFjZSBhbmRcXG4gICAgICAgICAgICAgICAgICAgICBsZW4oY2h1bmtzKSA9PSAxIGFuZFxcbiAgICAgICAgICAgICAgICAgICAgIG5vdCBjaHVua3NbMF0uc3RyaXAoKSkgYW5kIGN1cl9sZW4gPD0gd2lkdGgpOlxcbiAgICAgICAgICAgICAgICAgICAgIyBDb252ZXJ0IGN1cnJlbnQgbGluZSBiYWNrIHRvIGEgc3RyaW5nIGFuZCBzdG9yZSBpdCBpblxcbiAgICAgICAgICAgICAgICAgICAgIyBsaXN0IG9mIGFsbCBsaW5lcyAocmV0dXJuIHZhbHVlKS5cXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZChpbmRlbnQgKyAnJy5qb2luKGN1cl9saW5lKSlcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIGN1cl9saW5lOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJfbGluZVstMV0uc3RyaXAoKSBhbmRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyX2xlbiArIGxlbihzZWxmLnBsYWNlaG9sZGVyKSA8PSB3aWR0aCk6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cl9saW5lLmFwcGVuZChzZWxmLnBsYWNlaG9sZGVyKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmQoaW5kZW50ICsgJycuam9pbihjdXJfbGluZSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyX2xlbiAtPSBsZW4oY3VyX2xpbmVbLTFdKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbCBjdXJfbGluZVstMV1cXG4gICAgICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGluZXM6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZfbGluZSA9IGxpbmVzWy0xXS5yc3RyaXAoKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKHByZXZfbGluZSkgKyBsZW4oc2VsZi5wbGFjZWhvbGRlcikgPD1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLndpZHRoKTpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzWy0xXSA9IHByZXZfbGluZSArIHNlbGYucGxhY2Vob2xkZXJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kKGluZGVudCArIHNlbGYucGxhY2Vob2xkZXIubHN0cmlwKCkpXFxuICAgICAgICAgICAgICAgICAgICBicmVha1xcblxcbiAgICAgICAgcmV0dXJuIGxpbmVzXFxuXFxuICAgIGRlZiBfc3BsaXRfY2h1bmtzKHNlbGYsIHRleHQpOlxcbiAgICAgICAgdGV4dCA9IHNlbGYuX211bmdlX3doaXRlc3BhY2UodGV4dClcXG4gICAgICAgIHJldHVybiBzZWxmLl9zcGxpdCh0ZXh0KVxcblxcbiAgICAjIC0tIFB1YmxpYyBpbnRlcmZhY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICBkZWYgd3JhcChzZWxmLCB0ZXh0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIndyYXAodGV4dCA6IHN0cmluZykgLT4gW3N0cmluZ11cXG4gICAgICAgIFJlZm9ybWF0IHRoZSBzaW5nbGUgcGFyYWdyYXBoIGluICd0ZXh0JyBzbyBpdCBmaXRzIGluIGxpbmVzIG9mXFxuICAgICAgICBubyBtb3JlIHRoYW4gJ3NlbGYud2lkdGgnIGNvbHVtbnMsIGFuZCByZXR1cm4gYSBsaXN0IG9mIHdyYXBwZWRcXG4gICAgICAgIGxpbmVzLiAgVGFicyBpbiAndGV4dCcgYXJlIGV4cGFuZGVkIHdpdGggc3RyaW5nLmV4cGFuZHRhYnMoKSxcXG4gICAgICAgIGFuZCBhbGwgb3RoZXIgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChpbmNsdWRpbmcgbmV3bGluZSkgYXJlXFxuICAgICAgICBjb252ZXJ0ZWQgdG8gc3BhY2UuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIGNodW5rcyA9IHNlbGYuX3NwbGl0X2NodW5rcyh0ZXh0KVxcbiAgICAgICAgaWYgc2VsZi5maXhfc2VudGVuY2VfZW5kaW5nczpcXG4gICAgICAgICAgICBzZWxmLl9maXhfc2VudGVuY2VfZW5kaW5ncyhjaHVua3MpXFxuICAgICAgICByZXR1cm4gc2VsZi5fd3JhcF9jaHVua3MoY2h1bmtzKVxcblxcbiAgICBkZWYgZmlsbChzZWxmLCB0ZXh0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcImZpbGwodGV4dCA6IHN0cmluZykgLT4gc3RyaW5nXFxuICAgICAgICBSZWZvcm1hdCB0aGUgc2luZ2xlIHBhcmFncmFwaCBpbiAndGV4dCcgdG8gZml0IGluIGxpbmVzIG9mIG5vXFxuICAgICAgICBtb3JlIHRoYW4gJ3NlbGYud2lkdGgnIGNvbHVtbnMsIGFuZCByZXR1cm4gYSBuZXcgc3RyaW5nXFxuICAgICAgICBjb250YWluaW5nIHRoZSBlbnRpcmUgd3JhcHBlZCBwYXJhZ3JhcGguXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBcXFwiXFxcXG5cXFwiLmpvaW4oc2VsZi53cmFwKHRleHQpKVxcblxcblxcbiMgLS0gQ29udmVuaWVuY2UgaW50ZXJmYWNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbmRlZiB3cmFwKHRleHQsIHdpZHRoPTcwLCAqKmt3YXJncyk6XFxuICAgIFxcXCJcXFwiXFxcIldyYXAgYSBzaW5nbGUgcGFyYWdyYXBoIG9mIHRleHQsIHJldHVybmluZyBhIGxpc3Qgb2Ygd3JhcHBlZCBsaW5lcy5cXG4gICAgUmVmb3JtYXQgdGhlIHNpbmdsZSBwYXJhZ3JhcGggaW4gJ3RleHQnIHNvIGl0IGZpdHMgaW4gbGluZXMgb2Ygbm9cXG4gICAgbW9yZSB0aGFuICd3aWR0aCcgY29sdW1ucywgYW5kIHJldHVybiBhIGxpc3Qgb2Ygd3JhcHBlZCBsaW5lcy4gIEJ5XFxuICAgIGRlZmF1bHQsIHRhYnMgaW4gJ3RleHQnIGFyZSBleHBhbmRlZCB3aXRoIHN0cmluZy5leHBhbmR0YWJzKCksIGFuZFxcbiAgICBhbGwgb3RoZXIgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChpbmNsdWRpbmcgbmV3bGluZSkgYXJlIGNvbnZlcnRlZCB0b1xcbiAgICBzcGFjZS4gIFNlZSBUZXh0V3JhcHBlciBjbGFzcyBmb3IgYXZhaWxhYmxlIGtleXdvcmQgYXJncyB0byBjdXN0b21pemVcXG4gICAgd3JhcHBpbmcgYmVoYXZpb3VyLlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgdyA9IFRleHRXcmFwcGVyKHdpZHRoPXdpZHRoLCAqKmt3YXJncylcXG4gICAgcmV0dXJuIHcud3JhcCh0ZXh0KVxcblxcbmRlZiBmaWxsKHRleHQsIHdpZHRoPTcwLCAqKmt3YXJncyk6XFxuICAgIFxcXCJcXFwiXFxcIkZpbGwgYSBzaW5nbGUgcGFyYWdyYXBoIG9mIHRleHQsIHJldHVybmluZyBhIG5ldyBzdHJpbmcuXFxuICAgIFJlZm9ybWF0IHRoZSBzaW5nbGUgcGFyYWdyYXBoIGluICd0ZXh0JyB0byBmaXQgaW4gbGluZXMgb2Ygbm8gbW9yZVxcbiAgICB0aGFuICd3aWR0aCcgY29sdW1ucywgYW5kIHJldHVybiBhIG5ldyBzdHJpbmcgY29udGFpbmluZyB0aGUgZW50aXJlXFxuICAgIHdyYXBwZWQgcGFyYWdyYXBoLiAgQXMgd2l0aCB3cmFwKCksIHRhYnMgYXJlIGV4cGFuZGVkIGFuZCBvdGhlclxcbiAgICB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgY29udmVydGVkIHRvIHNwYWNlLiAgU2VlIFRleHRXcmFwcGVyIGNsYXNzIGZvclxcbiAgICBhdmFpbGFibGUga2V5d29yZCBhcmdzIHRvIGN1c3RvbWl6ZSB3cmFwcGluZyBiZWhhdmlvdXIuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICB3ID0gVGV4dFdyYXBwZXIod2lkdGg9d2lkdGgsICoqa3dhcmdzKVxcbiAgICByZXR1cm4gdy5maWxsKHRleHQpXFxuXFxuZGVmIHNob3J0ZW4odGV4dCwgd2lkdGgsICoqa3dhcmdzKTpcXG4gICAgXFxcIlxcXCJcXFwiQ29sbGFwc2UgYW5kIHRydW5jYXRlIHRoZSBnaXZlbiB0ZXh0IHRvIGZpdCBpbiB0aGUgZ2l2ZW4gd2lkdGguXFxuICAgIFRoZSB0ZXh0IGZpcnN0IGhhcyBpdHMgd2hpdGVzcGFjZSBjb2xsYXBzZWQuICBJZiBpdCB0aGVuIGZpdHMgaW5cXG4gICAgdGhlICp3aWR0aCosIGl0IGlzIHJldHVybmVkIGFzIGlzLiAgT3RoZXJ3aXNlLCBhcyBtYW55IHdvcmRzXFxuICAgIGFzIHBvc3NpYmxlIGFyZSBqb2luZWQgYW5kIHRoZW4gdGhlIHBsYWNlaG9sZGVyIGlzIGFwcGVuZGVkOjpcXG4gICAgICAgID4+PiB0ZXh0d3JhcC5zaG9ydGVuKFxcXCJIZWxsbyAgd29ybGQhXFxcIiwgd2lkdGg9MTIpXFxuICAgICAgICAnSGVsbG8gd29ybGQhJ1xcbiAgICAgICAgPj4+IHRleHR3cmFwLnNob3J0ZW4oXFxcIkhlbGxvICB3b3JsZCFcXFwiLCB3aWR0aD0xMSlcXG4gICAgICAgICdIZWxsbyBbLi4uXSdcXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIHcgPSBUZXh0V3JhcHBlcih3aWR0aD13aWR0aCwgbWF4X2xpbmVzPTEsICoqa3dhcmdzKVxcbiAgICByZXR1cm4gdy5maWxsKCcgJy5qb2luKHRleHQuc3RyaXAoKS5zcGxpdCgpKSlcXG5cXG5cXG4jIC0tIExvb3NlbHkgcmVsYXRlZCBmdW5jdGlvbmFsaXR5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4jIF93aGl0ZXNwYWNlX29ubHlfcmUgPSByZS5jb21waWxlKCdeWyBcXFxcdF0rJCcsIHJlLk1VTFRJTElORSlcXG4jIF9sZWFkaW5nX3doaXRlc3BhY2VfcmUgPSByZS5jb21waWxlKCcoXlsgXFxcXHRdKikoPzpbXiBcXFxcdFxcXFxuXSknLCByZS5NVUxUSUxJTkUpXFxuXFxuZGVmIGRlZGVudCh0ZXh0KTpcXG4gICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFueSBjb21tb24gbGVhZGluZyB3aGl0ZXNwYWNlIGZyb20gZXZlcnkgbGluZSBpbiBgdGV4dGAuXFxuICAgIFRoaXMgY2FuIGJlIHVzZWQgdG8gbWFrZSB0cmlwbGUtcXVvdGVkIHN0cmluZ3MgbGluZSB1cCB3aXRoIHRoZSBsZWZ0XFxuICAgIGVkZ2Ugb2YgdGhlIGRpc3BsYXksIHdoaWxlIHN0aWxsIHByZXNlbnRpbmcgdGhlbSBpbiB0aGUgc291cmNlIGNvZGVcXG4gICAgaW4gaW5kZW50ZWQgZm9ybS5cXG4gICAgTm90ZSB0aGF0IHRhYnMgYW5kIHNwYWNlcyBhcmUgYm90aCB0cmVhdGVkIGFzIHdoaXRlc3BhY2UsIGJ1dCB0aGV5XFxuICAgIGFyZSBub3QgZXF1YWw6IHRoZSBsaW5lcyBcXFwiICBoZWxsb1xcXCIgYW5kIFxcXCJcXFxcXFxcXHRoZWxsb1xcXCIgYXJlXFxuICAgIGNvbnNpZGVyZWQgdG8gaGF2ZSBubyBjb21tb24gbGVhZGluZyB3aGl0ZXNwYWNlLlxcbiAgICBFbnRpcmVseSBibGFuayBsaW5lcyBhcmUgbm9ybWFsaXplZCB0byBhIG5ld2xpbmUgY2hhcmFjdGVyLlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgIyBMb29rIGZvciB0aGUgbG9uZ2VzdCBsZWFkaW5nIHN0cmluZyBvZiBzcGFjZXMgYW5kIHRhYnMgY29tbW9uIHRvXFxuICAgICMgYWxsIGxpbmVzLlxcbiAgICBtYXJnaW4gPSBOb25lXFxuXFxuICAgIGluZGVudHMgPSByZS5maW5kYWxsKHInKF5bIFxcXFx0XSopKD86W14gXFxcXHRcXFxcbl0pJyx0ZXh0LCByZS5NVUxUSUxJTkUpXFxuICAgIGZvciBpbmRlbnQgaW4gaW5kZW50czpcXG4gICAgICAgIGlmIG1hcmdpbiBpcyBOb25lOlxcbiAgICAgICAgICAgIG1hcmdpbiA9IGluZGVudFxcblxcbiAgICAgICAgIyBDdXJyZW50IGxpbmUgbW9yZSBkZWVwbHkgaW5kZW50ZWQgdGhhbiBwcmV2aW91cyB3aW5uZXI6XFxuICAgICAgICAjIG5vIGNoYW5nZSAocHJldmlvdXMgd2lubmVyIGlzIHN0aWxsIG9uIHRvcCkuXFxuICAgICAgICBlbGlmIGluZGVudC5zdGFydHN3aXRoKG1hcmdpbik6XFxuICAgICAgICAgICAgcGFzc1xcblxcbiAgICAgICAgIyBDdXJyZW50IGxpbmUgY29uc2lzdGVudCB3aXRoIGFuZCBubyBkZWVwZXIgdGhhbiBwcmV2aW91cyB3aW5uZXI6XFxuICAgICAgICAjIGl0J3MgdGhlIG5ldyB3aW5uZXIuXFxuICAgICAgICBlbGlmIG1hcmdpbi5zdGFydHN3aXRoKGluZGVudCk6XFxuICAgICAgICAgICAgbWFyZ2luID0gaW5kZW50XFxuXFxuICAgICAgICAjIEZpbmQgdGhlIGxhcmdlc3QgY29tbW9uIHdoaXRlc3BhY2UgYmV0d2VlbiBjdXJyZW50IGxpbmUgYW5kIHByZXZpb3VzXFxuICAgICAgICAjIHdpbm5lci5cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgZm9yIGksICh4LCB5KSBpbiBlbnVtZXJhdGUoemlwKG1hcmdpbiwgaW5kZW50KSk6XFxuICAgICAgICAgICAgICAgIGlmIHggIT0geTpcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IG1hcmdpbls6aV1cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICMgc2FuaXR5IGNoZWNrICh0ZXN0aW5nL2RlYnVnZ2luZyBvbmx5KVxcbiAgICBpZiAwIGFuZCBtYXJnaW46XFxuICAgICAgICBmb3IgbGluZSBpbiB0ZXh0LnNwbGl0KFxcXCJcXFxcblxcXCIpOlxcbiAgICAgICAgICAgIGFzc2VydCBub3QgbGluZSBvciBsaW5lLnN0YXJ0c3dpdGgobWFyZ2luKSwgXFxcXFxcbiAgICAgICAgICAgICAgICAgICBcXFwibGluZSA9ICVyLCBtYXJnaW4gPSAlclxcXCIgJSAobGluZSwgbWFyZ2luKVxcblxcbiAgICBpZiBtYXJnaW46XFxuICAgICAgICBsaW5lcyA9IFtsaW5lW2xlbihtYXJnaW4pOl0gXFxuICAgICAgICAgICAgICAgICAgICBpZiBsaW5lLnN0cmlwKClcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGxpbmUuc3RyaXAoKSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGxpbmUgaW4gdGV4dC5zcGxpdChcXFwiXFxcXG5cXFwiKV1cXG4gICAgICAgIHRleHQgPSBcXFwiXFxcXG5cXFwiLmpvaW4obGluZXMpXFxuICAgIHJldHVybiB0ZXh0XFxuXFxuXFxuZGVmIGluZGVudCh0ZXh0LCBwcmVmaXgsIHByZWRpY2F0ZT1Ob25lKTpcXG4gICAgXFxcIlxcXCJcXFwiQWRkcyAncHJlZml4JyB0byB0aGUgYmVnaW5uaW5nIG9mIHNlbGVjdGVkIGxpbmVzIGluICd0ZXh0Jy5cXG4gICAgSWYgJ3ByZWRpY2F0ZScgaXMgcHJvdmlkZWQsICdwcmVmaXgnIHdpbGwgb25seSBiZSBhZGRlZCB0byB0aGUgbGluZXNcXG4gICAgd2hlcmUgJ3ByZWRpY2F0ZShsaW5lKScgaXMgVHJ1ZS4gSWYgJ3ByZWRpY2F0ZScgaXMgbm90IHByb3ZpZGVkLFxcbiAgICBpdCB3aWxsIGRlZmF1bHQgdG8gYWRkaW5nICdwcmVmaXgnIHRvIGFsbCBub24tZW1wdHkgbGluZXMgdGhhdCBkbyBub3RcXG4gICAgY29uc2lzdCBzb2xlbHkgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgaWYgcHJlZGljYXRlIGlzIE5vbmU6XFxuICAgICAgICBkZWYgcHJlZGljYXRlKGxpbmUpOlxcbiAgICAgICAgICAgIHJldHVybiBsaW5lLnN0cmlwKClcXG5cXG4gICAgZGVmIHByZWZpeGVkX2xpbmVzKCk6XFxuICAgICAgICBmb3IgbGluZSBpbiB0ZXh0LnNwbGl0bGluZXMoVHJ1ZSk6XFxuICAgICAgICAgICAgeWllbGQgKHByZWZpeCArIGxpbmUgaWYgcHJlZGljYXRlKGxpbmUpIGVsc2UgbGluZSlcXG4gICAgcmV0dXJuICcnLmpvaW4ocHJlZml4ZWRfbGluZXMoKSlcXG5cXG5cXG5pZiBfX25hbWVfXyA9PSBcXFwiX19tYWluX19cXFwiOlxcbiAgICAjcHJpbnQgZGVkZW50KFxcXCJcXFxcdGZvb1xcXFxuXFxcXHRiYXJcXFwiKVxcbiAgICAjcHJpbnQgZGVkZW50KFxcXCIgIFxcXFx0aGVsbG8gdGhlcmVcXFxcbiAgXFxcXHQgIGhvdyBhcmUgeW91P1xcXCIpXFxuICAgIHByaW50KGRlZGVudChcXFwiSGVsbG8gdGhlcmUuXFxcXG4gIFRoaXMgaXMgaW5kZW50ZWQuXFxcIikpXCIsXCJzcmMvbGliL3RoaXMucHlcIjpcIlxcbnByaW50KFxcXCJcXFwiXFxcIlxcblRoZSBaZW4gb2YgUHl0aG9uLCBieSBUaW0gUGV0ZXJzXFxuXFxuQmVhdXRpZnVsIGlzIGJldHRlciB0aGFuIHVnbHkuXFxuRXhwbGljaXQgaXMgYmV0dGVyIHRoYW4gaW1wbGljaXQuXFxuU2ltcGxlIGlzIGJldHRlciB0aGFuIGNvbXBsZXguXFxuQ29tcGxleCBpcyBiZXR0ZXIgdGhhbiBjb21wbGljYXRlZC5cXG5GbGF0IGlzIGJldHRlciB0aGFuIG5lc3RlZC5cXG5TcGFyc2UgaXMgYmV0dGVyIHRoYW4gZGVuc2UuXFxuUmVhZGFiaWxpdHkgY291bnRzLlxcblNwZWNpYWwgY2FzZXMgYXJlbid0IHNwZWNpYWwgZW5vdWdoIHRvIGJyZWFrIHRoZSBydWxlcy5cXG5BbHRob3VnaCBwcmFjdGljYWxpdHkgYmVhdHMgcHVyaXR5LlxcbkVycm9ycyBzaG91bGQgbmV2ZXIgcGFzcyBzaWxlbnRseS5cXG5Vbmxlc3MgZXhwbGljaXRseSBzaWxlbmNlZC5cXG5JbiB0aGUgZmFjZSBvZiBhbWJpZ3VpdHksIHJlZnVzZSB0aGUgdGVtcHRhdGlvbiB0byBndWVzcy5cXG5UaGVyZSBzaG91bGQgYmUgb25lLS0gYW5kIHByZWZlcmFibHkgb25seSBvbmUgLS1vYnZpb3VzIHdheSB0byBkbyBpdC5cXG5BbHRob3VnaCB0aGF0IHdheSBtYXkgbm90IGJlIG9idmlvdXMgYXQgZmlyc3QgdW5sZXNzIHlvdSdyZSBEdXRjaC5cXG5Ob3cgaXMgYmV0dGVyIHRoYW4gbmV2ZXIuXFxuQWx0aG91Z2ggbmV2ZXIgaXMgb2Z0ZW4gYmV0dGVyIHRoYW4gKnJpZ2h0KiBub3cuXFxuSWYgdGhlIGltcGxlbWVudGF0aW9uIGlzIGhhcmQgdG8gZXhwbGFpbiwgaXQncyBhIGJhZCBpZGVhLlxcbklmIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBlYXN5IHRvIGV4cGxhaW4sIGl0IG1heSBiZSBhIGdvb2QgaWRlYS5cXG5OYW1lc3BhY2VzIGFyZSBvbmUgaG9ua2luZyBncmVhdCBpZGVhIC0tIGxldCdzIGRvIG1vcmUgb2YgdGhvc2UhXFxuXFxcIlxcXCJcXFwiXFxuICAgICAgKVxcblwiLFwic3JjL2xpYi90aHJlYWRpbmcucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidGhyZWFkaW5nXFxcIilcXG5cIixcInNyYy9saWIvdGltZWl0LnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInRpbWVpdFxcXCIpXFxuXCIsXCJzcmMvbGliL3RvYWlmZi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0b2FpZmZcXFwiKVxcblwiLFwic3JjL2xpYi90cmFjZS5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0cmFjZVxcXCIpXFxuXCIsXCJzcmMvbGliL3RyYWNlYmFjay5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ0cmFjZWJhY2tcXFwiKVxcblwiLFwic3JjL2xpYi90dHkucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidHR5XFxcIilcXG5cIixcInNyYy9saWIvdHlwZXMucHlcIjpcIlxcXCJcXFwiXFxcIlxcblRoaXMgZmlsZSB3YXMgbW9kaWZpZWQgZnJvbSBDUHl0aG9uLlxcbkNvcHlyaWdodCAoYykgMjAwMSwgMjAwMiwgMjAwMywgMjAwNCwgMjAwNSwgMjAwNiwgMjAwNywgMjAwOCwgMjAwOSwgMjAxMCxcXG4yMDExLCAyMDEyLCAyMDEzLCAyMDE0LCAyMDE1IFB5dGhvbiBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBBbGwgUmlnaHRzIFJlc2VydmVkXFxuXFxcIlxcXCJcXFwiXFxuXFxcIlxcXCJcXFwiRGVmaW5lIG5hbWVzIGZvciBhbGwgdHlwZSBzeW1ib2xzIGtub3duIGluIHRoZSBzdGFuZGFyZCBpbnRlcnByZXRlci5cXG5UeXBlcyB0aGF0IGFyZSBwYXJ0IG9mIG9wdGlvbmFsIG1vZHVsZXMgKGUuZy4gYXJyYXkpIGFyZSBub3QgbGlzdGVkLlxcblxcXCJcXFwiXFxcIlxcbmltcG9ydCBzeXNcXG5cXG4jIEl0ZXJhdG9ycyBpbiBQeXRob24gYXJlbid0IGEgbWF0dGVyIG9mIHR5cGUgYnV0IG9mIHByb3RvY29sLiAgQSBsYXJnZVxcbiMgYW5kIGNoYW5naW5nIG51bWJlciBvZiBidWlsdGluIHR5cGVzIGltcGxlbWVudCAqc29tZSogZmxhdm9yIG9mXFxuIyBpdGVyYXRvci4gIERvbid0IGNoZWNrIHRoZSB0eXBlISAgVXNlIGhhc2F0dHIgdG8gY2hlY2sgZm9yIGJvdGhcXG4jIFxcXCJfX2l0ZXJfX1xcXCIgYW5kIFxcXCJuZXh0XFxcIiBhdHRyaWJ1dGVzIGluc3RlYWQuXFxuTWFwcGluZ1Byb3h5VHlwZSA9IHR5cGUodHlwZS5fX2RpY3RfXylcXG5XcmFwcGVyRGVzY3JpcHRvclR5cGUgPSB0eXBlKG9iamVjdC5fX2luaXRfXylcXG5NZXRob2RXcmFwcGVyVHlwZSA9IHR5cGUob2JqZWN0KCkuX19zdHJfXylcXG5NZXRob2REZXNjcmlwdG9yVHlwZSA9IHR5cGUoc3RyLmpvaW4pXFxuQ2xhc3NNZXRob2REZXNjcmlwdG9yVHlwZSA9IHR5cGUoZGljdC5fX2RpY3RfX1snZnJvbWtleXMnXSlcXG5cXG5Ob25lVHlwZSA9IHR5cGUoTm9uZSlcXG5UeXBlVHlwZSA9IHR5cGVcXG5PYmplY3RUeXBlID0gb2JqZWN0XFxuSW50VHlwZSA9IGludFxcbnRyeTpcXG4gICAgTG9uZ1R5cGUgPSBsb25nXFxuZXhjZXB0OiBwYXNzXFxuRmxvYXRUeXBlID0gZmxvYXRcXG5Cb29sZWFuVHlwZSA9IGJvb2xcXG50cnk6XFxuICAgIENvbXBsZXhUeXBlID0gY29tcGxleFxcbmV4Y2VwdCBOYW1lRXJyb3I6XFxuICAgIHBhc3NcXG5TdHJpbmdUeXBlID0gc3RyXFxuXFxuIyBTdHJpbmdUeXBlcyBpcyBhbHJlYWR5IG91dGRhdGVkLiAgSW5zdGVhZCBvZiB3cml0aW5nIFxcXCJ0eXBlKHgpIGluXFxuIyB0eXBlcy5TdHJpbmdUeXBlc1xcXCIsIHlvdSBzaG91bGQgdXNlIFxcXCJpc2luc3RhbmNlKHgsIGJhc2VzdHJpbmcpXFxcIi4gIEJ1dFxcbiMgd2Uga2VlcCBhcm91bmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBQeXRob24gMi4yLlxcbnRyeTpcXG4gICAgVW5pY29kZVR5cGUgPSB1bmljb2RlXFxuICAgIFN0cmluZ1R5cGVzID0gKFN0cmluZ1R5cGUsIFVuaWNvZGVUeXBlKVxcbmV4Y2VwdCBOYW1lRXJyb3I6XFxuICAgIFN0cmluZ1R5cGVzID0gKFN0cmluZ1R5cGUsKVxcblxcbkJ1ZmZlclR5cGUgPSBidWZmZXJcXG5cXG5UdXBsZVR5cGUgPSB0dXBsZVxcbkxpc3RUeXBlID0gbGlzdFxcbkRpY3RUeXBlID0gRGljdGlvbmFyeVR5cGUgPSBkaWN0XFxuXFxuZGVmIF9mKCk6IHBhc3NcXG5GdW5jdGlvblR5cGUgPSB0eXBlKF9mKVxcbkxhbWJkYVR5cGUgPSB0eXBlKGxhbWJkYTogTm9uZSkgICAgICAgICAjIFNhbWUgYXMgRnVuY3Rpb25UeXBlXFxuI0NvZGVUeXBlID0gdHlwZShfZi5mdW5jX2NvZGUpXFxuXFxuZGVmIF9nKCk6XFxuICAgIHlpZWxkIDFcXG5HZW5lcmF0b3JUeXBlID0gdHlwZShfZygpKVxcblxcbmNsYXNzIF9DOlxcbiAgICBkZWYgX20oc2VsZik6IHBhc3NcXG5DbGFzc1R5cGUgPSB0eXBlKF9DKVxcblVuYm91bmRNZXRob2RUeXBlID0gdHlwZShfQy5fbSkgICAgICAgICAjIFNhbWUgYXMgTWV0aG9kVHlwZVxcbl94ID0gX0MoKVxcbkluc3RhbmNlVHlwZSA9IHR5cGUoX3gpXFxuTWV0aG9kVHlwZSA9IHR5cGUoX3guX20pXFxuQnVpbHRpbkZ1bmN0aW9uVHlwZSA9IHR5cGUobGVuKVxcbkJ1aWx0aW5NZXRob2RUeXBlID0gdHlwZShbXS5hcHBlbmQpICAgICAjIFNhbWUgYXMgQnVpbHRpbkZ1bmN0aW9uVHlwZVxcblxcbk1vZHVsZVR5cGUgPSB0eXBlKHN5cylcXG5GaWxlVHlwZSA9IGZpbGVcXG50cnk6XFxuICAgIFhSYW5nZVR5cGUgPSB4cmFuZ2VcXG5leGNlcHQgTmFtZUVycm9yOlxcbiAgICBwYXNzXFxuXFxuIyB0cnk6XFxuIyAgICAgcmFpc2UgVHlwZUVycm9yXFxuIyBleGNlcHQgVHlwZUVycm9yOlxcbiMgICAgIHRiID0gc3lzLmV4Y19pbmZvKClbMl1cXG4jICAgICBUcmFjZWJhY2tUeXBlID0gdHlwZSh0YilcXG4jICAgICBGcmFtZVR5cGUgPSB0eXBlKHRiLnRiX2ZyYW1lKVxcbiMgICAgIGRlbCB0YlxcblxcblNsaWNlVHlwZSA9IHNsaWNlXFxuRWxsaXBzaXNUeXBlID0gdHlwZShFbGxpcHNpcylcXG5cXG4jIERpY3RQcm94eVR5cGUgPSB0eXBlKFR5cGVUeXBlLl9fZGljdF9fKVxcbk5vdEltcGxlbWVudGVkVHlwZSA9IHR5cGUoTm90SW1wbGVtZW50ZWQpXFxuXFxuIyBGb3IgSnl0aG9uLCB0aGUgZm9sbG93aW5nIHR3byB0eXBlcyBhcmUgaWRlbnRpY2FsXFxuIyBHZXRTZXREZXNjcmlwdG9yVHlwZSA9IHR5cGUoRnVuY3Rpb25UeXBlLmZ1bmNfY29kZSlcXG4jIE1lbWJlckRlc2NyaXB0b3JUeXBlID0gdHlwZShGdW5jdGlvblR5cGUuZnVuY19nbG9iYWxzKVxcblxcbmRlbCBzeXMsIF9mLCBfZywgX0MsIF94ICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBOb3QgZm9yIGV4cG9ydFxcbl9fYWxsX18gPSBsaXN0KG4gZm9yIG4gaW4gZ2xvYmFscygpIGlmIG5bOjFdICE9ICdfJylcXG5cXG5HZW5lcmljQWxpYXMgPSB0eXBlKHR5cGVbaW50XSlcIixcInNyYy9saWIvdW5pdHRlc3QvX19pbml0X18ucHlcIjpcIl9fYXV0aG9yX18gPSAnYm1pbGxlcidcXG4nJydcXG5UaGlzIGlzIHRoZSBzdGFydCBvZiBzb21ldGhpbmcgdGhhdCBiZWhhdmVzIGxpa2VcXG50aGUgdW5pdHRlc3QgbW9kdWxlIGZyb20gY3B5dGhvbi5cXG5cXG4nJydcXG5pbXBvcnQgcmVcXG5cXG5jbGFzcyBfQXNzZXJ0UmFpc2VzQ29udGV4dChvYmplY3QpOlxcbiAgICBcXFwiXFxcIlxcXCJBIGNvbnRleHQgbWFuYWdlciB1c2VkIHRvIGltcGxlbWVudCBUZXN0Q2FzZS5hc3NlcnRSYWlzZXMqIG1ldGhvZHMuXFxcIlxcXCJcXFwiXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBleHBlY3RlZCwgdGVzdF9jYXNlKTpcXG4gICAgICAgIHNlbGYudGVzdF9jYXNlID0gdGVzdF9jYXNlXFxuICAgICAgICBzZWxmLmV4cGVjdGVkID0gZXhwZWN0ZWRcXG4gICAgICAgIHNlbGYuZXhjZXB0aW9uID0gTm9uZVxcblxcbiAgICBkZWYgX2lzX3N1YnR5cGUoc2VsZiwgZXhwZWN0ZWQsIGJhc2V0eXBlKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UoZXhwZWN0ZWQsIHR1cGxlKTpcXG4gICAgICAgICAgICByZXR1cm4gYWxsKHNlbGYuX2lzX3N1YnR5cGUoZSwgYmFzZXR5cGUpIGZvciBlIGluIGV4cGVjdGVkKVxcbiAgICAgICAgcmV0dXJuIGlzaW5zdGFuY2UoZXhwZWN0ZWQsIHR5cGUpIGFuZCBpc3N1YmNsYXNzKGV4cGVjdGVkLCBiYXNldHlwZSlcXG5cXG4gICAgZGVmIGhhbmRsZShzZWxmLCBhcmdzLCBrd2FyZ3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBJZiBhcmdzIGlzIGVtcHR5LCBhc3NlcnRSYWlzZXMgaXMgYmVpbmcgdXNlZCBhcyBhXFxuICAgICAgICBjb250ZXh0IG1hbmFnZXIsIHNvIHJldHVybiBzZWxmLlxcbiAgICAgICAgSWYgYXJncyBpcyBub3QgZW1wdHksIGNhbGwgYSBjYWxsYWJsZSBwYXNzaW5nIHBvc2l0aW9uYWwgYW5kIGtleXdvcmRcXG4gICAgICAgIGFyZ3VtZW50cy5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGlmIG5vdCBzZWxmLl9pc19zdWJ0eXBlKHNlbGYuZXhwZWN0ZWQsIEJhc2VFeGNlcHRpb24pOlxcbiAgICAgICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoJ2Fzc2VydFJhaXNlcygpIGFyZyAxIG11c3QgYmUgYW4gZXhjZXB0aW9uIHR5cGUgb3IgdHVwbGUgb2YgZXhjZXB0aW9uIHR5cGVzJylcXG4gICAgICAgICAgICBpZiBub3QgYXJnczpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgICAgICAgICBjYWxsYWJsZV9vYmogPSBhcmdzWzBdXFxuICAgICAgICAgICAgYXJncyA9IGFyZ3NbMTpdXFxuICAgICAgICAgICAgd2l0aCBzZWxmOlxcbiAgICAgICAgICAgICAgICBjYWxsYWJsZV9vYmooKmFyZ3MsICoqa3dhcmdzKSBcXG5cXG4gICAgICAgIGZpbmFsbHk6XFxuICAgICAgICAgICAgIyBicG8tMjM4OTA6IG1hbnVhbGx5IGJyZWFrIGEgcmVmZXJlbmNlIGN5Y2xlXFxuICAgICAgICAgICAgc2VsZiA9IE5vbmVcXG5cXG4gICAgZGVmIF9fZW50ZXJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuICAgIGRlZiBfX2V4aXRfXyhzZWxmLCBleGNfdHlwZSwgZXhjX3ZhbHVlLCB0Yik6XFxuICAgICAgICByZXMgPSBUcnVlXFxuICAgICAgICBmZWVkYmFjayA9IFxcXCJcXFwiXFxuICAgICAgICBzZWxmLmV4Y2VwdGlvbiA9IGV4Y192YWx1ZVxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGFjdF9leGMgPSBleGNfdHlwZS5fX25hbWVfX1xcbiAgICAgICAgZXhjZXB0IEF0dHJpYnV0ZUVycm9yOlxcbiAgICAgICAgICAgIGFjdF9leGMgPSBzdHIoZXhjX3R5cGUpXFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAgZXhwX2V4YyA9IHNlbGYuZXhwZWN0ZWQuX19uYW1lX19cXG4gICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjpcXG4gICAgICAgICAgICBleHBfZXhjID0gc3RyKHNlbGYuZXhwZWN0ZWQpXFxuXFxuICAgICAgICBpZiBleGNfdHlwZSBpcyBOb25lOlxcbiAgICAgICAgICAgIHJlcyA9IEZhbHNlXFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwie30gbm90IHJhaXNlZFxcXCIuZm9ybWF0KGV4cF9leGMpXFxuICAgICAgICBlbGlmIG5vdCBpc3N1YmNsYXNzKGV4Y190eXBlLCBzZWxmLmV4cGVjdGVkKTpcXG4gICAgICAgICAgICByZXMgPSBGYWxzZVxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkIHt9IGJ1dCBnb3Qge31cXFwiLmZvcm1hdChleHBfZXhjLCBhY3RfZXhjKVxcblxcbiAgICAgICAgc2VsZi50ZXN0X2Nhc2UuYXBwZW5kUmVzdWx0KHJlcywgYWN0X2V4YywgZXhwX2V4YywgZmVlZGJhY2spXFxuICAgICAgICByZXR1cm4gVHJ1ZVxcblxcblxcbmNsYXNzIFRlc3RDYXNlKG9iamVjdCk6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYubnVtUGFzc2VkID0gMFxcbiAgICAgICAgc2VsZi5udW1GYWlsZWQgPSAwXFxuICAgICAgICBzZWxmLmFzc2VydFBhc3NlZCA9IDBcXG4gICAgICAgIHNlbGYuYXNzZXJ0RmFpbGVkID0gMFxcbiAgICAgICAgc2VsZi52ZXJib3NpdHkgPSAxXFxuICAgICAgICBzZWxmLnRsaXN0ID0gW11cXG4gICAgICAgIHRlc3ROYW1lcyA9IHt9XFxuICAgICAgICBmb3IgbmFtZSBpbiBkaXIoc2VsZik6XFxuICAgICAgICAgICAgaWYgbmFtZVs6NF0gPT0gJ3Rlc3QnIGFuZCBuYW1lIG5vdCBpbiB0ZXN0TmFtZXM6XFxuICAgICAgICAgICAgICAgIHNlbGYudGxpc3QuYXBwZW5kKGdldGF0dHIoc2VsZixuYW1lKSlcXG4gICAgICAgICAgICAgICAgdGVzdE5hbWVzW25hbWVdPVRydWVcXG5cXG4gICAgZGVmIHNldFVwKHNlbGYpOlxcbiAgICAgICAgcGFzc1xcblxcbiAgICBkZWYgdGVhckRvd24oc2VsZik6XFxuICAgICAgICBwYXNzXFxuICAgIFxcbiAgICBkZWYgY2xlYW5OYW1lKHNlbGYsZnVuY05hbWUpOlxcbiAgICAgICAgcmV0dXJuIGZ1bmNOYW1lLl9fZnVuY19fLl9fbmFtZV9fXFxuXFxuICAgIGRlZiBtYWluKHNlbGYpOlxcblxcbiAgICAgICAgZm9yIGZ1bmMgaW4gc2VsZi50bGlzdDpcXG4gICAgICAgICAgICBpZiBzZWxmLnZlcmJvc2l0eSA+IDE6XFxuICAgICAgICAgICAgICAgIHByaW50KCdSdW5uaW5nICVzJyAlIHNlbGYuY2xlYW5OYW1lKGZ1bmMpKVxcbiAgICAgICAgICAgIHRyeTpcXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRVcCgpXFxuICAgICAgICAgICAgICAgIHNlbGYuYXNzZXJ0UGFzc2VkID0gMFxcbiAgICAgICAgICAgICAgICBzZWxmLmFzc2VydEZhaWxlZCA9IDBcXG4gICAgICAgICAgICAgICAgZnVuYygpXFxuICAgICAgICAgICAgICAgIHNlbGYudGVhckRvd24oKVxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmFzc2VydEZhaWxlZCA9PSAwOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5udW1QYXNzZWQgKz0gMVxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5udW1GYWlsZWQgKz0gMVxcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQoJ1Rlc3RzIGZhaWxlZCBpbiAlcyAnICUgc2VsZi5jbGVhbk5hbWUoZnVuYykpXFxuICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxcbiAgICAgICAgICAgICAgICBzZWxmLmFzc2VydEZhaWxlZCArPSAxXFxuICAgICAgICAgICAgICAgIHNlbGYubnVtRmFpbGVkICs9IDFcXG4gICAgICAgICAgICAgICAgcHJpbnQoJ1Rlc3QgdGhyZXcgZXhjZXB0aW9uIGluICVzICglcyknICUgKHNlbGYuY2xlYW5OYW1lKGZ1bmMpLCBlKSlcXG4gICAgICAgIHNlbGYuc2hvd1N1bW1hcnkoKVxcblxcbiAgICBkZWYgYXNzZXJ0RXF1YWwoc2VsZiwgYWN0dWFsLCBleHBlY3RlZCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYWN0dWFsPT1leHBlY3RlZFxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gZXF1YWwgJXNcXFwiICUgKHN0cihhY3R1YWwpLHN0cihleHBlY3RlZCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGFjdHVhbCAsZXhwZWN0ZWQsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0Tm90RXF1YWwoc2VsZiwgYWN0dWFsLCBleHBlY3RlZCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYWN0dWFsICE9IGV4cGVjdGVkXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBub3QgZXF1YWwgJXNcXFwiICUgKHN0cihhY3R1YWwpLHN0cihleHBlY3RlZCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGFjdHVhbCwgZXhwZWN0ZWQsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0VHJ1ZShzZWxmLHgsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGJvb2woeCkgaXMgVHJ1ZVxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgVHJ1ZVxcXCIgJSAoc3RyKHgpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCB4LCBUcnVlLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydEZhbHNlKHNlbGYseCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gbm90IGJvb2woeClcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIEZhbHNlXFxcIiAlIChzdHIoeCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIHgsIEZhbHNlLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydElzKHNlbGYsYSxiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhIGlzIGJcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIHRoZSBzYW1lIG9iamVjdCBhcyAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRJc05vdChzZWxmLGEsYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSBpcyBub3QgYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gbm90IGJlIHRoZSBzYW1lIG9iamVjdCBhcyAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRJc05vbmUoc2VsZix4LCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSB4IGlzIE5vbmVcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIE5vbmVcXFwiICUgKHN0cih4KSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgeCwgTm9uZSwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRJc05vdE5vbmUoc2VsZix4LCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSB4IGlzIG5vdCBOb25lXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBub3QgYmUgTm9uZVxcXCIgJSAoc3RyKHgpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCB4LCBOb25lLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydEluKHNlbGYsIGEsIGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGEgaW4gYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgaW4gJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0Tm90SW4oc2VsZiwgYSwgYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSBub3QgaW4gYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gbm90IGJlIGluICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydElzSW5zdGFuY2Uoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGlzaW5zdGFuY2UoYSxiKVxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJXNcXFwiICUgKHN0cihhKSwgc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydE5vdElzSW5zdGFuY2Uoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IG5vdCBpc2luc3RhbmNlKGEsYilcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIG5vdCBiZSBhbiBpbnN0YW5jZSBvZiAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRSZWdleChzZWxmLCB0ZXh0LCBleHBlY3RlZF9yZWdleCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmFpbCB0aGUgdGVzdCB1bmxlc3MgdGhlIHRleHQgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShleHBlY3RlZF9yZWdleCwgKHN0ciwgKSk6ICNieXRlc1xcbiAgICAgICAgICAgIGFzc2VydCBleHBlY3RlZF9yZWdleCwgXFxcImV4cGVjdGVkX3JlZ2V4IG11c3Qgbm90IGJlIGVtcHR5LlxcXCJcXG4gICAgICAgICAgICBleHBlY3RlZF9yZWdleCA9IHJlLmNvbXBpbGUoZXhwZWN0ZWRfcmVnZXgpXFxuICAgICAgICBpZiBub3QgZXhwZWN0ZWRfcmVnZXguc2VhcmNoKHRleHQpOlxcbiAgICAgICAgICAgIHJlcyA9IEZhbHNlXFxuICAgICAgICAgICAgaWYgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIlJlZ2V4IGRpZG4ndCBtYXRjaDogJXIgbm90IGZvdW5kIGluICVyXFxcIiAlIChcXG4gICAgICAgICAgICAgICAgICAgIHJlcHIoZXhwZWN0ZWRfcmVnZXgpLCB0ZXh0KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXMgPSBUcnVlXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIHRleHQsIGV4cGVjdGVkX3JlZ2V4LCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydE5vdFJlZ2V4KHNlbGYsIHRleHQsIHVuZXhwZWN0ZWRfcmVnZXgsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZhaWwgdGhlIHRlc3QgaWYgdGhlIHRleHQgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZSh1bmV4cGVjdGVkX3JlZ2V4LCAoc3RyLCApKTogIyBieXRlc1xcbiAgICAgICAgICAgIHVuZXhwZWN0ZWRfcmVnZXggPSByZS5jb21waWxlKHVuZXhwZWN0ZWRfcmVnZXgpXFxuICAgICAgICBtYXRjaCA9IHVuZXhwZWN0ZWRfcmVnZXguc2VhcmNoKHRleHQpXFxuICAgICAgICBpZiBtYXRjaDpcXG4gICAgICAgICAgICBmZWVkYmFjayA9ICdSZWdleCBtYXRjaGVkOiAlciBtYXRjaGVzICVyIGluICVyJyAlIChcXG4gICAgICAgICAgICAgICAgdGV4dFttYXRjaC5zdGFydCgpIDogbWF0Y2guZW5kKCldLFxcbiAgICAgICAgICAgICAgICByZXByKHVuZXhwZWN0ZWRfcmVnZXgpLFxcbiAgICAgICAgICAgICAgICB0ZXh0KVxcbiAgICAgICAgICAgICMgX2Zvcm1hdE1lc3NhZ2UgZW5zdXJlcyB0aGUgbG9uZ01lc3NhZ2Ugb3B0aW9uIGlzIHJlc3BlY3RlZFxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQobm90IGJvb2wobWF0Y2gpLCB0ZXh0LCB1bmV4cGVjdGVkX3JlZ2V4LCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydEFsbW9zdEVxdWFsKHNlbGYsIGEsIGIsIHBsYWNlcz03LCBmZWVkYmFjaz1cXFwiXFxcIiwgZGVsdGE9Tm9uZSk6XFxuXFxuICAgICAgICBpZiBkZWx0YSBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICByZXMgPSBhYnMoYS1iKSA8PSBkZWx0YVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBwbGFjZXMgaXMgTm9uZTpcXG4gICAgICAgICAgICAgICAgcGxhY2VzID0gN1xcbiAgICAgICAgICAgIHJlcyA9IHJvdW5kKGEtYiwgcGxhY2VzKSA9PSAwXFxuICAgICAgICBcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGVxdWFsICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydE5vdEFsbW9zdEVxdWFsKHNlbGYsIGEsIGIsIHBsYWNlcz03LCBmZWVkYmFjaz1cXFwiXFxcIiwgZGVsdGE9Tm9uZSk6XFxuXFxuICAgICAgICBpZiBkZWx0YSBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICByZXMgPSBub3QgKGEgPT0gYikgYW5kIGFicyhhIC0gYikgPiBkZWx0YVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBwbGFjZXMgaXMgTm9uZTpcXG4gICAgICAgICAgICAgICAgcGxhY2VzID0gN1xcblxcbiAgICAgICAgICAgIHJlcyA9IHJvdW5kKGEtYiwgcGxhY2VzKSAhPSAwXFxuXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBub3QgZXF1YWwgJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0R3JlYXRlcihzZWxmLGEsYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSA+IGJcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIGdyZWF0ZXIgdGhhbiAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRHcmVhdGVyRXF1YWwoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGEgPj0gYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgPj0gJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0TGVzcyhzZWxmLCBhLCBiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhIDwgYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgbGVzcyB0aGFuICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydExlc3NFcXVhbChzZWxmLGEsYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSA8PSBiXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBiZSA8PSAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhcHBlbmRSZXN1bHQoc2VsZixyZXMsYWN0dWFsLGV4cGVjdGVkLGZlZWRiYWNrKTpcXG4gICAgICAgIGlmIHJlczpcXG4gICAgICAgICAgICBtc2cgPSAnUGFzcydcXG4gICAgICAgICAgICBzZWxmLmFzc2VydFBhc3NlZCArPSAxXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIG1zZyA9ICdGYWlsOiAnICsgIGZlZWRiYWNrXFxuICAgICAgICAgICAgcHJpbnQobXNnKVxcbiAgICAgICAgICAgIHNlbGYuYXNzZXJ0RmFpbGVkICs9IDFcXG5cXG4gICAgZGVmIGFzc2VydFJhaXNlcyhzZWxmLCBleHBlY3RlZF9leGNlcHRpb24sICphcmdzLCAqKmt3YXJncyk6XFxuICAgICAgICBjb250ZXh0ID0gX0Fzc2VydFJhaXNlc0NvbnRleHQoZXhwZWN0ZWRfZXhjZXB0aW9uLCBzZWxmKVxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmhhbmRsZShhcmdzLCBrd2FyZ3MpXFxuICAgICAgICBmaW5hbGx5OlxcbiAgICAgICAgICAgICMgYnBvLTIzODkwOiBtYW51YWxseSBicmVhayBhIHJlZmVyZW5jZSBjeWNsZVxcbiAgICAgICAgICAgIGNvbnRleHQgPSBOb25lXFxuXFxuICAgIGRlZiBmYWlsKHNlbGYsIG1zZz1Ob25lKTpcXG4gICAgICAgIGlmIG1zZyBpcyBOb25lOlxcbiAgICAgICAgICAgIG1zZyA9ICdGYWlsJ1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBtc2cgPSAnRmFpbDogJyArIG1zZ1xcbiAgICAgICAgcHJpbnQobXNnKVxcbiAgICAgICAgc2VsZi5hc3NlcnRGYWlsZWQgKz0gMVxcblxcbiAgICBkZWYgc2hvd1N1bW1hcnkoc2VsZik6XFxuICAgICAgICAjIGRvbid0IGRpdmRlIGJ5IHplcm9cXG4gICAgICAgICMgcGN0ID0gc2VsZi5udW1QYXNzZWQgLyAoc2VsZi5udW1QYXNzZWQrc2VsZi5udW1GYWlsZWQpICogMTAwXFxuICAgICAgICBwcmludChcXFwiUmFuICVkIHRlc3RzLCBwYXNzZWQ6ICVkIGZhaWxlZDogJWRcXFxcblxcXCIgJSAoc2VsZi5udW1QYXNzZWQrc2VsZi5udW1GYWlsZWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm51bVBhc3NlZCwgc2VsZi5udW1GYWlsZWQpKVxcblxcblxcblxcbmRlZiBtYWluKHZlcmJvc2l0eT0xKTpcXG4gICAgZ2xvYiA9IGdsb2JhbHMoKSAjIGdsb2JhbHMoKSBzdGlsbCBuZWVkcyB3b3JrXFxuICAgIGZvciBuYW1lIGluIGdsb2I6XFxuICAgICAgICBpZiB0eXBlKGdsb2JbbmFtZV0pID09IHR5cGUgYW5kIGlzc3ViY2xhc3MoZ2xvYltuYW1lXSwgVGVzdENhc2UpOlxcbiAgICAgICAgICAgIHRyeTpcXG4gICAgICAgICAgICAgICAgdGMgPSBnbG9iW25hbWVdKClcXG4gICAgICAgICAgICAgICAgdGMudmVyYm9zaXR5ID0gdmVyYm9zaXR5XFxuICAgICAgICAgICAgICAgIHRjLm1haW4oKVxcbiAgICAgICAgICAgIGV4Y2VwdDpcXG4gICAgICAgICAgICAgICAgcHJpbnQoXFxcIlVuY2F1Z2h0IEVycm9yIGluOiBcXFwiLCBuYW1lKVxcblwiLFwic3JjL2xpYi91bml0dGVzdC9ndWkucHlcIjpcImltcG9ydCBkb2N1bWVudFxcbmZyb20gdW5pdHRlc3QgaW1wb3J0IFRlc3RDYXNlXFxuZnJvbSB1cmxsaWIucmVxdWVzdCBpbXBvcnQgdXJsb3BlblxcbmZyb20gdGltZSBpbXBvcnQgc2xlZXBcXG5cXG5cXG5jbGFzcyBUZXN0Q2FzZUd1aShUZXN0Q2FzZSk6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFRlc3RDYXNlLl9faW5pdF9fKHNlbGYpXFxuICAgICAgICBzZWxmLmNsb3Nlc3REaXYgPSBkb2N1bWVudC5jdXJyZW50RGl2KClcXG4gICAgICAgIHNlbGYuZGl2aWQgPSBkb2N1bWVudC5jdXJyZW50R3JhZGluZ0NvbnRhaW5lcigpXFxuICAgICAgICBzZWxmLm15ZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5kaXZpZClcXG4gICAgICAgICMgSWYgdGhlcmUgaXMgbm8gZGl2IHRoZW4gY3JlYXRlIGEgZHVtbXkgdG8gYXZvaWQgZXJyb3JzIHdoZW4gcnVubmluZ1xcbiAgICAgICAgIyBncmFkaW5nIFxcXCJvZmYgc2NyZWVuXFxcIlxcbiAgICAgICAgaWYgc2VsZi5teWRpdiBpcyBOb25lOlxcbiAgICAgICAgICAgIHNlbGYubXlkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKVxcbiAgICAgICAgICAgIHNlbGYubXlkaXYuaWQgPSBzZWxmLmRpdmlkICsgXFxcIl9vZmZzY3JlZW5fdW5pdF9yZXN1bHRzXFxcIlxcbiAgICAgICAgICAgIHNlbGYubXlkaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIlxcbiAgICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiYm9keVxcXCIpWzBdXFxuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChzZWxmLm15ZGl2KVxcbiAgICAgICAgICAgIHNlbGYudW5pdF9yZXN1bHRzX2RpdmlkID0gc2VsZi5kaXZpZCArIFxcXCJfb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c1xcXCJcXG5cXG4gICAgICAgIHJlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuZGl2aWQgKyBcXFwiX3VuaXRfcmVzdWx0c1xcXCIpXFxuICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYgPSByZXNcXG4gICAgICAgICAgICByZXMuaW5uZXJIVE1MID0gXFxcIlxcXCJcXG4gICAgICAgICAgICBzZWxmLnVuaXRfcmVzdWx0c19kaXZpZCA9IHNlbGYuZGl2aWQgKyBcXFwiX3VuaXRfcmVzdWx0c1xcXCJcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKVxcbiAgICAgICAgICAgIHNlbGYucmVzZGl2LmlkID0gc2VsZi5kaXZpZCArIFxcXCJfdW5pdF9yZXN1bHRzXFxcIlxcbiAgICAgICAgICAgIHNlbGYucmVzZGl2LmNsYXNzTGlzdC5hZGQoXFxcInVuaXR0ZXN0LXJlc3VsdHNcXFwiKVxcbiAgICAgICAgICAgIHNlbGYubXlkaXYuYXBwZW5kQ2hpbGQoc2VsZi5yZXNkaXYpXFxuICAgICAgICAgICAgc2VsZi51bml0X3Jlc3VsdHNfZGl2aWQgPSBzZWxmLmRpdmlkICsgXFxcIl91bml0X3Jlc3VsdHNcXFwiXFxuXFxuICAgIGRlZiBtYWluKHNlbGYpOlxcbiAgICAgICAgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRhYmxlXFxcIilcXG4gICAgICAgIHNlbGYucmVzVGFibGUgPSB0XFxuICAgICAgICB4ID0gc2VsZi5yZXNkaXYuY2xvc2VzdChcXFwiLnRpbWVkQ29tcG9uZW50XFxcIilcXG4gICAgICAgIGlmIHg6XFxuICAgICAgICAgICAgc2VsZi5pc190aW1lZCA9IFRydWVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5pc190aW1lZCA9IEZhbHNlXFxuICAgICAgICBzZWxmLnJlc2Rpdi5hcHBlbmRDaGlsZChzZWxmLnJlc1RhYmxlKVxcbiAgICAgICAgaWYgc2VsZi5pc190aW1lZDpcXG4gICAgICAgICAgICBzZWxmLnJlc2Rpdi5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiXFxuXFxuICAgICAgICBoZWFkZXJzID0gW1xcXCJSZXN1bHRcXFwiLCBcXFwiQWN0dWFsIFZhbHVlXFxcIiwgXFxcIkV4cGVjdGVkIFZhbHVlXFxcIiwgXFxcIk5vdGVzXFxcIl1cXG4gICAgICAgIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRyXFxcIilcXG4gICAgICAgIGZvciBpdGVtIGluIGhlYWRlcnM6XFxuICAgICAgICAgICAgaGVhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRoXFxcIilcXG4gICAgICAgICAgICBoZWFkLmNsYXNzTGlzdC5hZGQoXFxcImFjLWZlZWRiYWNrXFxcIilcXG4gICAgICAgICAgICBoZWFkLmlubmVySFRNTCA9IGl0ZW1cXG4gICAgICAgICAgICBoZWFkLnN0eWxlLnRleHRBbGlnbiA9IFxcXCJjZW50ZXJcXFwiXFxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGhlYWQpXFxuICAgICAgICBzZWxmLnJlc1RhYmxlLmFwcGVuZENoaWxkKHJvdylcXG5cXG4gICAgICAgIGZvciBmdW5jIGluIHNlbGYudGxpc3Q6XFxuICAgICAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgICAgICBzZWxmLnNldFVwKClcXG4gICAgICAgICAgICAgICAgZnVuYygpXFxuICAgICAgICAgICAgICAgIHNlbGYudGVhckRvd24oKVxcbiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZTpcXG4gICAgICAgICAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQoXFxcIkVycm9yXFxcIiwgTm9uZSwgTm9uZSwgc3RyKGUpLnNwbGl0KFxcXCJvbiBsaW5lXFxcIilbMF0pXFxuICAgICAgICAgICAgICAgIHNlbGYubnVtRmFpbGVkICs9IDFcXG4gICAgICAgIHNlbGYuc2hvd1N1bW1hcnkoKVxcblxcbiAgICBkZWYgZ2V0T3V0cHV0KHNlbGYpOlxcbiAgICAgICAgc2xlZXAoMC4yKVxcbiAgICAgICAgIyBzZWxmLmRpdmlkIHdpbGwgYmUgdGhlIGdyYWRpbmdXcmFwcGVyIHdoZW4gaW4gZ3JhZGluZyBtb2RlXFxuICAgICAgICBpZiBzZWxmLmNsb3Nlc3REaXYgIT0gc2VsZi5kaXZpZDpcXG4gICAgICAgICAgICBvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxcbiAgICAgICAgICAgICAgICBcXFwiI3t9ICN7fV9zdGRvdXRcXFwiLmZvcm1hdChzZWxmLmRpdmlkLCBzZWxmLmNsb3Nlc3REaXYpXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBvdXRwdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLmRpdmlkICsgXFxcIl9zdGRvdXRcXFwiKVxcbiAgICAgICAgcmV0dXJuIG91dHB1dC5pbm5lclRleHRcXG5cXG4gICAgZGVmIGdldEVkaXRvclRleHQoc2VsZik6XFxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0Q3VycmVudEVkaXRvclZhbHVlKClcXG5cXG4gICAgZGVmIGFwcGVuZFJlc3VsdChzZWxmLCByZXMsIGFjdHVhbCwgZXhwZWN0ZWQsIHBhcmFtKTpcXG4gICAgICAgIHRyaW1BY3R1YWwgPSBGYWxzZVxcbiAgICAgICAgaWYgbGVuKHN0cihhY3R1YWwpKSA+IDE1OlxcbiAgICAgICAgICAgIHRyaW1BY3R1YWwgPSBUcnVlXFxuICAgICAgICAgICAgYWN0dWFsVHlwZSA9IHR5cGUoYWN0dWFsKVxcbiAgICAgICAgdHJpbUV4cGVjdGVkID0gRmFsc2VcXG4gICAgICAgIGlmIGxlbihzdHIoZXhwZWN0ZWQpKSA+IDE1OlxcbiAgICAgICAgICAgIHRyaW1FeHBlY3RlZCA9IFRydWVcXG4gICAgICAgICAgICBleHBlY3RlZFR5cGUgPSB0eXBlKGV4cGVjdGVkKVxcbiAgICAgICAgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidHJcXFwiKVxcbiAgICAgICAgZXJyID0gRmFsc2VcXG4gICAgICAgIGlmIHJlcyA9PSBcXFwiRXJyb3JcXFwiOlxcbiAgICAgICAgICAgIGVyciA9IFRydWVcXG4gICAgICAgICAgICBtc2cgPSBcXFwiRXJyb3I6ICVzXFxcIiAlIHBhcmFtXFxuICAgICAgICAgICAgZXJyb3JEYXRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGRcXFwiKVxcbiAgICAgICAgICAgIGVycm9yRGF0YS5jbGFzc0xpc3QuYWRkKFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuICAgICAgICAgICAgZXJyb3JEYXRhLmlubmVySFRNTCA9IFxcXCJFUlJPUlxcXCJcXG4gICAgICAgICAgICBlcnJvckRhdGEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXFxcIiNkZThlOTZcXFwiXFxuICAgICAgICAgICAgZXJyb3JEYXRhLnN0eWxlLnRleHRBbGlnbiA9IFxcXCJjZW50ZXJcXFwiXFxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGVycm9yRGF0YSlcXG4gICAgICAgIGVsaWYgcmVzOlxcbiAgICAgICAgICAgIHBhc3NlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRkXFxcIilcXG4gICAgICAgICAgICBwYXNzZWQuY2xhc3NMaXN0LmFkZChcXFwiYWMtZmVlZGJhY2tcXFwiKVxcbiAgICAgICAgICAgIHBhc3NlZC5pbm5lckhUTUwgPSBcXFwiUGFzc1xcXCJcXG4gICAgICAgICAgICBwYXNzZWQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXFxcIiM4M2QzODJcXFwiXFxuICAgICAgICAgICAgcGFzc2VkLnN0eWxlLnRleHRBbGlnbiA9IFxcXCJjZW50ZXJcXFwiXFxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHBhc3NlZClcXG4gICAgICAgICAgICBzZWxmLm51bVBhc3NlZCArPSAxXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGZhaWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0ZFxcXCIpXFxuICAgICAgICAgICAgZmFpbC5jbGFzc0xpc3QuYWRkKFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuICAgICAgICAgICAgZmFpbC5pbm5lckhUTUwgPSBcXFwiRmFpbFxcXCJcXG4gICAgICAgICAgICBmYWlsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFxcXCIjZGU4ZTk2XFxcIlxcbiAgICAgICAgICAgIGZhaWwuc3R5bGUudGV4dEFsaWduID0gXFxcImNlbnRlclxcXCJcXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoZmFpbClcXG4gICAgICAgICAgICBzZWxmLm51bUZhaWxlZCArPSAxXFxuXFxuICAgICAgICBhY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0ZFxcXCIpXFxuICAgICAgICBhY3QuY2xhc3NMaXN0LmFkZChcXFwiYWMtZmVlZGJhY2tcXFwiKVxcbiAgICAgICAgaWYgdHJpbUFjdHVhbDpcXG4gICAgICAgICAgICBhY3RIVE1MID0gc3RyKGFjdHVhbClbOjVdICsgXFxcIi4uLlxcXCIgKyBzdHIoYWN0dWFsKVstNTpdXFxuICAgICAgICAgICAgaWYgYWN0dWFsVHlwZSA9PSBzdHI6XFxuICAgICAgICAgICAgICAgIGFjdEhUTUwgPSByZXByKGFjdEhUTUwpXFxuICAgICAgICAgICAgYWN0LmlubmVySFRNTCA9IGFjdEhUTUxcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgYWN0LmlubmVySFRNTCA9IHJlcHIoYWN0dWFsKVxcbiAgICAgICAgYWN0LnN0eWxlLnRleHRBbGlnbiA9IFxcXCJjZW50ZXJcXFwiXFxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoYWN0KVxcblxcbiAgICAgICAgZXhwZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGRcXFwiKVxcbiAgICAgICAgZXhwZWN0LmNsYXNzTGlzdC5hZGQoXFxcImFjLWZlZWRiYWNrXFxcIilcXG5cXG4gICAgICAgIGlmIHRyaW1FeHBlY3RlZDpcXG4gICAgICAgICAgICBleHBlY3RlZEhUTUwgPSBzdHIoZXhwZWN0ZWQpWzo1XSArIFxcXCIuLi5cXFwiICsgc3RyKGV4cGVjdGVkKVstNTpdXFxuICAgICAgICAgICAgaWYgZXhwZWN0ZWRUeXBlID09IHN0cjpcXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRIVE1MID0gcmVwcihleHBlY3RlZEhUTUwpXFxuICAgICAgICAgICAgZXhwZWN0LmlubmVySFRNTCA9IGV4cGVjdGVkSFRNTFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBleHBlY3QuaW5uZXJIVE1MID0gcmVwcihleHBlY3RlZClcXG4gICAgICAgIGV4cGVjdC5zdHlsZS50ZXh0QWxpZ24gPSBcXFwiY2VudGVyXFxcIlxcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKGV4cGVjdClcXG4gICAgICAgIGlucCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRkXFxcIilcXG4gICAgICAgIGlucC5jbGFzc0xpc3QuYWRkKFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuXFxuICAgICAgICBpZiBlcnI6XFxuICAgICAgICAgICAgaW5wLmlubmVySFRNTCA9IG1zZ1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpbnAuaW5uZXJIVE1MID0gcGFyYW1cXG4gICAgICAgIGlucC5zdHlsZS50ZXh0QWxpZ24gPSBcXFwiY2VudGVyXFxcIlxcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKGlucClcXG5cXG4gICAgICAgIGRlZiBmb28oZXZ0KTpcXG4gICAgICAgICAgICBkb2N1bWVudC5wb3B1cChleHBhbmRtc2cpXFxuXFxuICAgICAgICBpZiB0cmltQWN0dWFsIG9yIHRyaW1FeHBlY3RlZDpcXG4gICAgICAgICAgICBleHBhbmRidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJidXR0b25cXFwiKVxcbiAgICAgICAgICAgIGV4cGFuZGJ1dHRvbi5pbm5lckhUTUwgPSBcXFwiRXhwYW5kIERpZmZlcmVuY2VzXFxcIlxcbiAgICAgICAgICAgIGV4cGFuZG1zZyA9IFxcXCJBY3R1YWw6IFxcXCIgKyBzdHIoYWN0dWFsKSArIFxcXCJcXFxcbkV4cGVjdGVkOiBcXFwiICsgc3RyKGV4cGVjdGVkKVxcbiAgICAgICAgICAgIGV4cGFuZGJ1dHRvbi52YWx1ZSA9IGV4cGFuZG1zZ1xcbiAgICAgICAgICAgIGV4cGFuZGJ1dHRvbi50eXBlID0gXFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgICBleHBhbmRidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcXFwiY2xpY2tcXFwiLCBmb28pXFxuICAgICAgICAgICAgZXhwYW5kYnV0dG9uLmNsYXNzTGlzdC5hZGQoXFxcImJ0blxcXCIsIFxcXCJidG4taW5mb1xcXCIpXFxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGV4cGFuZGJ1dHRvbilcXG5cXG4gICAgICAgIHNlbGYucmVzVGFibGUuYXBwZW5kQ2hpbGQocm93KVxcblxcbiAgICBkZWYgc2hvd1N1bW1hcnkoc2VsZik6XFxuICAgICAgICBwY3QgPSBmbG9hdChzZWxmLm51bVBhc3NlZCkgLyAoc2VsZi5udW1QYXNzZWQgKyBzZWxmLm51bUZhaWxlZCkgKiAxMDBcXG4gICAgICAgIHBjdGNvcnJlY3QgPSAoXFxuICAgICAgICAgICAgXFxcInBlcmNlbnQ6XFxcIlxcbiAgICAgICAgICAgICsgc3RyKHBjdClcXG4gICAgICAgICAgICArIFxcXCI6cGFzc2VkOlxcXCJcXG4gICAgICAgICAgICArIHN0cihzZWxmLm51bVBhc3NlZClcXG4gICAgICAgICAgICArIFxcXCI6ZmFpbGVkOlxcXCJcXG4gICAgICAgICAgICArIHN0cihzZWxmLm51bUZhaWxlZClcXG4gICAgICAgIClcXG4gICAgICAgIHBUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJwXFxcIilcXG4gICAgICAgIGlmIG5vdCBzZWxmLmlzX3RpbWVkOlxcbiAgICAgICAgICAgIHBUYWcuaW5uZXJIVE1MID0gXFxcIllvdSBwYXNzZWQ6IFxcXCIgKyBzdHIocGN0KSArIFxcXCIlIG9mIHRoZSB0ZXN0c1xcXCJcXG4gICAgICAgICAgICBzZWxmLnJlc2Rpdi5hcHBlbmRDaGlsZChwVGFnKVxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGpzZXZhbChcXG4gICAgICAgICAgICAgICAgXFxcIndpbmRvdy5jb21wb25lbnRNYXBbJ3t9J10ucGN0X2NvcnJlY3QgPSB7fVxcXCIuZm9ybWF0KFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZXN0RGl2LCBwY3RcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIClcXG4gICAgICAgICAgICBqc2V2YWwoXFxuICAgICAgICAgICAgICAgIFxcXCJ3aW5kb3cuY29tcG9uZW50TWFwWyd7fSddLnVuaXRfcmVzdWx0cyA9ICd7fSdcXFwiLmZvcm1hdChcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VzdERpdiwgcGN0Y29ycmVjdFxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIGpzZXZhbChcXG4gICAgICAgICAgICAgICAgXFxcIndpbmRvdy5jb21wb25lbnRNYXBbJ3t9J10udW5pdF9yZXN1bHRzX2RpdmlkID0gJ3t9J1xcXCIuZm9ybWF0KFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZXN0RGl2LCBzZWxmLm15ZGl2LmdldEF0dHJpYnV0ZShcXFwiaWRcXFwiKVxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKVxcblxcbiAgICAgICAgZXhjZXB0OlxcbiAgICAgICAgICAgIHByaW50KFxcbiAgICAgICAgICAgICAgICBcXFwiZmFpbGVkIHRvIGZpbmQgb2JqZWN0IHRvIHJlY29yZCB1bml0dGVzdCByZXN1bHRzIGluIHt9ISB7fVxcXCIuZm9ybWF0KFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZXN0RGl2LCBwY3Rjb3JyZWN0XFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApXFxuXCIsXCJzcmMvbGliL3VybGxpYjIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidXJsbGliMlxcXCIpXFxuXCIsXCJzcmMvbGliL3VybHBhcnNlLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInVybHBhcnNlXFxcIilcXG5cIixcInNyYy9saWIvdXNlci5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ1c2VyXFxcIilcXG5cIixcInNyYy9saWIvdXUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwidXVcXFwiKVxcblwiLFwic3JjL2xpYi93YXJuaW5ncy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ3YXJuaW5nc1xcXCIpXFxuXCIsXCJzcmMvbGliL3dhdmUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwid2F2ZVxcXCIpXFxuXCIsXCJzcmMvbGliL3dlYWtyZWYucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwid2Vha3JlZlxcXCIpXFxuXCIsXCJzcmMvbGliL3doaWNoZGIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwid2hpY2hkYlxcXCIpXFxuXCIsXCJzcmMvbGliL3dzZ2lyZWYvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwid3NnaXJlZlxcXCIpXFxuXCIsXCJzcmMvbGliL3hkcmxpYi5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJ4ZHJsaWJcXFwiKVxcblwiLFwic3JjL2xpYi94bWwvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwieG1sXFxcIilcXG5cIixcInNyYy9saWIveG1sL2RvbS9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJkb21cXFwiKVxcblwiLFwic3JjL2xpYi94bWwvZXRyZWUvX19pbml0X18ucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiZXRyZWVcXFwiKVxcblwiLFwic3JjL2xpYi94bWwvcGFyc2Vycy9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJwYXJzZXJzXFxcIilcXG5cIixcInNyYy9saWIveG1sL3NheC9fX2luaXRfXy5weVwiOlwiaW1wb3J0IF9za19mYWlsOyBfc2tfZmFpbC5fKFxcXCJzYXhcXFwiKVxcblwiLFwic3JjL2xpYi94bWxsaWIucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwieG1sbGliXFxcIilcXG5cIixcInNyYy9saWIveG1scnBjbGliLnB5XCI6XCJpbXBvcnQgX3NrX2ZhaWw7IF9za19mYWlsLl8oXFxcInhtbHJwY2xpYlxcXCIpXFxuXCIsXCJzcmMvbGliL3ppcGZpbGUucHlcIjpcImltcG9ydCBfc2tfZmFpbDsgX3NrX2ZhaWwuXyhcXFwiemlwZmlsZVxcXCIpXFxuXCIsXCJzcmMvYnVpbHRpbi9zeXMuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihpKXt2YXIgdCxuPXt9LGU9W10sdT1Tay5nZXRTeXNBcmd2KCk7Zm9yKHQ9MDt0PHUubGVuZ3RoOysrdCllLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKHVbdF0pKTtuLmFyZ3Y9bmV3IFNrLmJ1aWx0aW5zLmxpc3QoZSksbi5jb3B5cmlnaHQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJDb3B5cmlnaHQgMjAwOS0yMDEwIFNjb3R0IEdyYWhhbS5cXFxcbkFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxcXG5cXFwiKSxTay5fX2Z1dHVyZV9fLnB5dGhvbjM/KG4udmVyc2lvbj1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIjMuNyhpc2gpIFtTa3VscHRdXFxcIiksbi52ZXJzaW9uX2luZm89bmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmludF8oMyksbmV3IFNrLmJ1aWx0aW4uaW50Xyg3KV0pKToobi52ZXJzaW9uPW5ldyBTay5idWlsdGluLnN0cihcXFwiMi43KGlzaCkgW1NrdWxwdF1cXFwiKSxuLnZlcnNpb25faW5mbz1uZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50XygyKSxuZXcgU2suYnVpbHRpbi5pbnRfKDcpXSkpLG4ubWF4aW50PW5ldyBTay5idWlsdGluLmludF8oTWF0aC5wb3coMiw1MyktMSksbi5tYXhzaXplPW5ldyBTay5idWlsdGluLmludF8oTWF0aC5wb3coMiw1MyktMSksbi5tb2R1bGVzPVNrLnN5c21vZHVsZXMsbi5wYXRoPVNrLnJlYWxzeXNwYXRoLG4uZ2V0ZGVmYXVsdGVuY29kaW5nPW5ldyBTay5idWlsdGluLmZ1bmMoKCgpPT5uZXcgU2suYnVpbHRpbi5zdHIoXFxcInV0Zi04XFxcIikpKSxuLmdldEV4ZWN1dGlvbkxpbWl0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT1Tay5leGVjTGltaXQ/U2suYnVpbHRpbi5ub25lLm5vbmUkOm5ldyBTay5idWlsdGluLmludF8oU2suZXhlY0xpbWl0KX0pKSxuLnNldEV4ZWN1dGlvbkxpbWl0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGkpe2lmKG51bGw9PT1Tay5leGVjTGltaXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiRXhlY3V0aW9uIGxpbWl0aW5nIGlzIG5vdCBlbmFibGVkXFxcIik7dm9pZCAwIT09aSYmKFNrLmV4ZWNMaW1pdD1Tay5idWlsdGluLmFzbnVtJChpKSl9KSksbi5yZXNldFRpbWVvdXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtTay5leGVjU3RhcnQ9bmV3IERhdGV9KSksbi5nZXRZaWVsZExpbWl0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT1Tay55aWVsZExpbWl0P1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpuZXcgU2suYnVpbHRpbi5pbnRfKFNrLnlpZWxkTGltaXQpfSkpLG4uc2V0WWllbGRMaW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihpKXtpZihudWxsPT09U2sueWllbGRMaW1pdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJZaWVsZGluZyBpcyBub3QgZW5hYmxlZFxcXCIpO3ZvaWQgMCE9PWkmJihTay55aWVsZExpbWl0PVNrLmJ1aWx0aW4uYXNudW0kKGkpKX0pKSxuLmRlYnVnPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKTtjb25zdCBvPVNrLmJ1aWx0aW4ubWFrZV9zdHJ1Y3RzZXEoXFxcInN5c1xcXCIsXFxcImZsb2F0X2luZm9cXFwiLHttYXg6XFxcIkRCTF9NQVggLS0gbWF4aW11bSByZXByZXNlbnRhYmxlIGZpbml0ZSBmbG9hdFxcXCIsbWF4X2V4cDpcXFwiREJMX01BWF9FWFAgLS0gbWF4aW11bSBpbnQgZSBzdWNoIHRoYXQgcmFkaXgqKihlLTEpIGlzIHJlcHJlc2VudGFibGVcXFwiLG1heF8xMF9leHA6XFxcIkRCTF9NQVhfMTBfRVhQIC0tIG1heGltdW0gaW50IGUgc3VjaCB0aGF0IDEwKiplIGlzIHJlcHJlc2VudGFibGVcXFwiLG1pbjpcXFwiREJMX01JTiAtLSBNaW5pbXVtIHBvc2l0aXZlIG5vcm1hbGl6ZWQgZmxvYXRcXFwiLG1pbl9leHA6XFxcIkRCTF9NSU5fRVhQIC0tIG1pbmltdW0gaW50IGUgc3VjaCB0aGF0IHJhZGl4KiooZS0xKSBpcyBhIG5vcm1hbGl6ZWQgZmxvYXRcXFwiLG1pbl8xMF9leHA6XFxcIkRCTF9NSU5fMTBfRVhQIC0tIG1pbmltdW0gaW50IGUgc3VjaCB0aGF0IDEwKiplIGlzIGEgbm9ybWFsaXplZFxcXCIsZGlnOlxcXCJEQkxfRElHIC0tIGRpZ2l0c1xcXCIsbWFudF9kaWc6XFxcIkRCTF9NQU5UX0RJRyAtLSBtYW50aXNzYSBkaWdpdHNcXFwiLGVwc2lsb246XFxcIkRCTF9FUFNJTE9OIC0tIERpZmZlcmVuY2UgYmV0d2VlbiAxIGFuZCB0aGUgbmV4dCByZXByZXNlbnRhYmxlIGZsb2F0XFxcIixyYWRpeDpcXFwiRkxUX1JBRElYIC0tIHJhZGl4IG9mIGV4cG9uZW50XFxcIixyb3VuZHM6XFxcIkZMVF9ST1VORFMgLS0gcm91bmRpbmcgbW9kZVxcXCJ9KTtuLmZsb2F0X2luZm89bmV3IG8oW051bWJlci5NQVhfVkFMVUUsTWF0aC5mbG9vcihNYXRoLmxvZzIoTnVtYmVyLk1BWF9WQUxVRSkpLE1hdGguZmxvb3IoTWF0aC5sb2cxMChOdW1iZXIuTUFYX1ZBTFVFKSksTnVtYmVyLk1JTl9WQUxVRSxNYXRoLmNlaWwoTWF0aC5sb2cyKE51bWJlci5NSU5fVkFMVUUpKSxNYXRoLmNlaWwoTWF0aC5sb2cxMChOdW1iZXIuTUlOX1ZBTFVFKSksMTUsTWF0aC5sb2cyKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSxOdW1iZXIuRVBTSUxPTiwyLDFdLm1hcCgoaT0+U2suZmZpLnJlbWFwVG9QeShpKSkpKTtjb25zdCBzPVNrLmJ1aWx0aW4ubWFrZV9zdHJ1Y3RzZXEoXFxcInN5c1xcXCIsXFxcImludF9pbmZvXFxcIix7Yml0c19wZXJfZGlnaXQ6XFxcInNpemUgb2YgYSBkaWdpdCBpbiBiaXRzXFxcIixzaXplb2ZfZGlnaXQ6XFxcInNpemUgaW4gYnl0ZXMgb2YgdGhlIEMgdHlwZSB1c2VkIHRvIHJlcHJlc2VudCBhIGRpZ2l0XFxcIn0pO24uaW50X2luZm89bmV3IHMoWzMwLDRdLm1hcCgoaT0+U2suZmZpLnJlbWFwVG9QeShpKSkpKTtjb25zdCBsPVNrLmJ1aWx0aW4ubWFrZV9zdHJ1Y3RzZXEoXFxcInN5c1xcXCIsXFxcImhhc2hfaW5mb1xcXCIse3dpZHRoOlxcXCJ3aWR0aCBvZiB0aGUgdHlwZSB1c2VkIGZvciBoYXNoaW5nLCBpbiBiaXRzXFxcIixtb2R1bHVzOlxcXCJwcmltZSBudW1iZXIgZ2l2aW5nIHRoZSBtb2R1bHVzIG9uIHdoaWNoIHRoZSBoYXNoIGZ1bmN0aW9uIGlzIGJhc2VkXFxcIixpbmY6XFxcInZhbHVlIHRvIGJlIHVzZWQgZm9yIGhhc2ggb2YgYSBwb3NpdGl2ZSBpbmZpbml0eVxcXCIsbmFuOlxcXCJ2YWx1ZSB0byBiZSB1c2VkIGZvciBoYXNoIG9mIGEgbmFuXFxcIixpbWFnOlxcXCJtdWx0aXBsaWVyIHVzZWQgZm9yIHRoZSBpbWFnaW5hcnkgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXFxcIixhbGdvcml0aG06XFxcIm5hbWUgb2YgdGhlIGFsZ29yaXRobSBmb3IgaGFzaGluZyBvZiBzdHIsIGJ5dGVzIGFuZCBtZW1vcnl2aWV3c1xcXCIsaGFzaF9iaXRzOlxcXCJpbnRlcm5hbCBvdXRwdXQgc2l6ZSBvZiBoYXNoIGFsZ29yaXRobVxcXCIsc2VlZF9iaXRzOlxcXCJzZWVkIHNpemUgb2YgaGFzaCBhbGdvcml0aG1cXFwiLGN1dG9mZjpcXFwic21hbGwgc3RyaW5nIG9wdGltaXphdGlvbiBjdXRvZmZcXFwifSk7cmV0dXJuIG4uaGFzaF9pbmZvPW5ldyBsKFszMiw1MzY4NzA5MTEsMzE0MTU5LDAsMTAwMDAwMyxcXFwic2lwaGFzaDI0XFxcIiwzMiwxMjgsMF0ubWFwKChpPT5Tay5mZmkucmVtYXBUb1B5KGkpKSkpLG4uX19zdGRvdXRfXz1uZXcgU2suYnVpbHRpbi5maWxlKG5ldyBTay5idWlsdGluLnN0cihcXFwiL2Rldi9zdGRvdXRcXFwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIndcXFwiKSksbi5fX3N0ZGluX189bmV3IFNrLmJ1aWx0aW4uZmlsZShuZXcgU2suYnVpbHRpbi5zdHIoXFxcIi9kZXYvc3RkaW5cXFwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcInJcXFwiKSksbi5zdGRvdXQ9bi5fX3N0ZG91dF9fLG4uc3RkaW49bi5fX3N0ZGluX18sbn07XCIsXCJzcmMvbGliL0pvQmFzZS5qc1wiOlwiY29uc3QgJGJ1aWx0aW5tb2R1bGU9KCk9PntTay5taXNjZXZhbC5wcmludF8oXFxcIldlbGNvbWUgdG8gSm9CYXNlXFxcXG5cXFwiKTtjb25zdCBlPVNrLkpvQmFzZSxvPXt9LHQ9W10scj1bXSxuPWUuZ2V0Q29udGV4dChcXFwid2ViZ2xcXFwiKSxhPW4uY3JlYXRlUHJvZ3JhbSgpLGM9bi5jcmVhdGVCdWZmZXIoKSxpPW4uY3JlYXRlU2hhZGVyKG4uVkVSVEVYX1NIQURFUikscz1uLmNyZWF0ZVNoYWRlcihuLkZSQUdNRU5UX1NIQURFUiksc3RyPWU9Pm5ldyBTay5idWlsdGluLnN0cihlKSxkZWY9ZT0+bmV3IFNrLmJ1aWx0aW4uZnVuYyhlKSxmbG9hdD1lPT5uZXcgU2suYnVpbHRpbi5mbG9hdF8oZSksaW50PWU9Pm5ldyBTay5idWlsdGluLmludF8oZSksYm9vbD1lPT5uZXcgU2suYnVpbHRpbi5ib29sKGUpLHR1cGxlPWU9Pm5ldyBTay5idWlsdGluLnR1cGxlKGUpLG51bWJlcj1lPT57aWYoU2suYnVpbHRpbi5jaGVja051bWJlcihlKSlyZXR1cm4gZS52O3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwibXVzdCBiZSByZWFsIG51bWJlciwgbm90IFxcXCIrZS50cCRuYW1lKX0sc3RyaW5nPWU9PntpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGUpKXJldHVybiBlLnY7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJtdXN0IGJlIHN0ciwgbm90IFxcXCIrZS50cCRuYW1lKX0scHJvcGVydHk9KC4uLmUpPT5jYWxsKFNrLmJ1aWx0aW5zLnByb3BlcnR5LC4uLmUpLGJ1aWxkPSguLi5lKT0+U2subWlzY2V2YWwuYnVpbGRDbGFzcyhvLC4uLmUpLGNhbGw9KC4uLmUpPT5Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kKC4uLmUpLGlzPSguLi5lKT0+U2suYnVpbHRpbi5pc2luc3RhbmNlKC4uLmUpLnYsd2FpdD1lPT5Tay5taXNjZXZhbC5wcm9taXNlVG9TdXNwZW5zaW9uKG5ldyBQcm9taXNlKGUpKSxvYmplY3Q9ZT0+e3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwibXVzdCBiZSBTaGFwZSBvciBjdXJzb3IsIG5vdCBcXFwiK2UudHAkbmFtZSl9LHBhdGg9ZT0+c3RyKFxcXCJodHRwczovL2pvYmFzZS5vcmcvQnJvd3Nlci9Kb0Jhc2UvXFxcIitlKSx3aWR0aD0oKT0+ZS53aWR0aC9kZXZpY2VQaXhlbFJhdGlvLGhlaWdodD0oKT0+ZS5oZWlnaHQvZGV2aWNlUGl4ZWxSYXRpbyx4PSgpPT5vLmN1cnNvci4keC13aWR0aCgpLzIseT0oKT0+aGVpZ2h0KCkvMi1vLmN1cnNvci4keSxibGFuaz0oKT0+e30sbW91c2VFbnRlcj0oKT0+by5jdXJzb3IuJGVudGVyPSEwLG1vdXNlTGVhdmU9KCk9Pm8uY3Vyc29yLiRsZWF2ZT0hMCxtb3VzZURvd249KCk9PntvLmN1cnNvci4kcHJlc3M9ITAsby5jdXJzb3IuJGhvbGQ9ITB9LG1vdXNlVXA9KCk9PntvLmN1cnNvci4kcmVsZWFzZT0hMCxvLmN1cnNvci4kaG9sZD0hMX0sbW91c2VNb3ZlPXQ9Pntjb25zdCByPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7by5jdXJzb3IuJHg9dC5jbGllbnRYLXIubGVmdCxvLmN1cnNvci4keT10LmNsaWVudFktci50b3Asby5jdXJzb3IuJG1vdmU9ITB9LGtleURvd249ZT0+e2NvbnN0IHQ9T2JqZWN0LmtleXMoby5rZXkuJGRhdGEpLmZpbmQoKHQ9Pm8ua2V5LiRkYXRhW3RdLmNvZGU9PWUuY29kZSkpLHI9by5rZXkuJGRhdGFbdF07ZS5yZXBlYXQ/KG8ua2V5LiRyZXBlYXQ9ITAsciYmKHIucmVwZWF0PSEwKSk6KG8ua2V5LiRwcmVzcz0hMCxyJiYoci5wcmVzcz0hMCkmJihyLmhvbGQ9ITApKX0sa2V5VXA9ZT0+e2NvbnN0IHQ9T2JqZWN0LmtleXMoby5rZXkuJGRhdGEpLmZpbmQoKHQ9Pm8ua2V5LiRkYXRhW3RdLmNvZGU9PWUuY29kZSkpLHI9by5rZXkuJGRhdGFbdF07by5rZXkuJHJlbGVhc2U9ITAsciYmKHIucmVsZWFzZT0hMCkmJihyLmhvbGQ9ITEpfSxjb2xsaWRlUG9seVBvaW50PShlLG8pPT5lLnJlZHVjZSgoKGUsdCxyLG4pPT57Y29uc3QgYT1uW3IrMT09bi5sZW5ndGg/MDpyKzFdO3JldHVybiBvWzBdPChhWzBdLXRbMF0pKihvWzFdLXRbMV0pLyhhWzFdLXRbMV0pK3RbMF0mJih0WzFdPm9bMV0mJmFbMV08b1sxXXx8dFsxXTxvWzFdJiZhWzFdPm9bMV0pPyFlOmV9KSwhMSksZ2V0UmVjdFBvbHk9ZT0+e2NvbnN0IG89ZS4kYW5jaG9yWzBdK2UuJHNpemVbMF0qZS4kc2NhbGVbMF0vMix0PWUuJGFuY2hvclsxXStlLiRzaXplWzFdKmUuJHNjYWxlWzFdLzI7cmV0dXJuKChlLG8sdCk9Pntjb25zdCByPU1hdGguY29zKG8qTWF0aC5QSS8xODApLG49TWF0aC5zaW4obypNYXRoLlBJLzE4MCk7cmV0dXJuIGUubWFwKChlPT5bZVswXSpyLWVbMV0qbit0WzBdLGVbMF0qbitlWzFdKnIrdFsxXV0pKX0pKFtbLW8sdF0sW28sdF0sW28sLXRdLFstbywtdF1dLGUuJGFuZ2xlLGUuJHBvcyl9LGNyZWF0ZUltYWdlPWU9Pntjb25zdCBvPW4uY3JlYXRlVGV4dHVyZSgpO3JldHVybiBuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxvKSxuLnRleEltYWdlMkQobi5URVhUVVJFXzJELDAsbi5SR0JBLG4uUkdCQSxuLlVOU0lHTkVEX0JZVEUsZSksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfV1JBUF9TLG4uQ0xBTVBfVE9fRURHRSksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfV1JBUF9ULG4uQ0xBTVBfVE9fRURHRSksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUlOX0ZJTFRFUixuLkxJTkVBUiksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUFHX0ZJTFRFUixuLkxJTkVBUiksb30scmVuZGVyVGV4dD1lPT57Y29uc3Qgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKSx0PW8uZ2V0Q29udGV4dChcXFwiMmRcXFwiKSxhPWUuJGZvbnRTaXplK1xcXCJweCBfXFxcIityLmluZGV4T2YoZS4kZm9udCk7dC5mb250PWE7Y29uc3QgYz10Lm1lYXN1cmVUZXh0KGUuJGNvbnRlbnQpLGk9Yy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0LWMuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LHM9dC5tZWFzdXJlVGV4dChcXFwiU3lcXFwiKSxkPXMuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50K3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7ZS4kc2l6ZVswXT1vLndpZHRoPWksZS4kc2l6ZVsxXT1vLmhlaWdodD1kLHQuZm9udD1hLHQuZmlsbFN0eWxlPVxcXCIjZmZmXFxcIix0LmZpbGxUZXh0KGUuJGNvbnRlbnQsMCxzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSxuLmRlbGV0ZVRleHR1cmUoZS4kdGV4dHVyZSksZS4kdGV4dHVyZT1jcmVhdGVJbWFnZShvKX0sbG9hZEZvbnQ9ZT0+bmV3IFByb21pc2UoKChvLHQpPT57aWYoci5pbmNsdWRlcyhlKSlyZXR1cm4gbygpO25ldyBGb250RmFjZShcXFwiX1xcXCIrci5sZW5ndGgsYHVybCgke2V9KWApLmxvYWQoKS50aGVuKCh0PT57ZG9jdW1lbnQuZm9udHMuYWRkKHQpLHIucHVzaChlKSxvKCl9KSkuY2F0Y2goKCgpPT57cmV0dXJuIHQoKG89YGZhaWxlZCB0byBsb2FkIGZvbnQ6IFxcXCIke2V9XFxcImAsbmV3IFNrLmJ1aWx0aW4uRmlsZU5vdEZvdW5kRXJyb3IobykpKTt2YXIgb30pKX0pKSxkcmF3U2hhcGU9KGUsbyx0LHIsYyxpKT0+e2NvbnN0IHM9b1swXSplLiRzY2FsZVswXSxkPW9bMV0qZS4kc2NhbGVbMV0sbD1lLiRhbmNob3JbMF0sdT1lLiRhbmNob3JbMV0sJD1lLiRwb3NbMF0scD1lLiRwb3NbMV0sbT1NYXRoLnNpbihlLiRhbmdsZSpNYXRoLlBJLzE4MCksZj1NYXRoLmNvcyhlLiRhbmdsZSpNYXRoLlBJLzE4MCk7dmFyIGgsXztoPVtzKmYscyptLDAsMCxkKi1tLGQqZiwwLDAsMCwwLDEsMCxsKmYrdSotbSskLGwqbSt1KmYrcCwwLDFdLF89ZS4kY29sb3Isbi51bmlmb3JtNGZ2KG4uZ2V0VW5pZm9ybUxvY2F0aW9uKGEsXFxcImNvbG9yXFxcIiksbmV3IEZsb2F0MzJBcnJheShfKSksbi51bmlmb3JtTWF0cml4NGZ2KG4uZ2V0VW5pZm9ybUxvY2F0aW9uKGEsXFxcIm9iamVjdFxcXCIpLCExLG5ldyBGbG9hdDMyQXJyYXkoaCkpLG4uYmluZEJ1ZmZlcihuLkFSUkFZX0JVRkZFUix0KSxuLnVuaWZvcm0xaShuLmdldFVuaWZvcm1Mb2NhdGlvbihhLFxcXCJpbWFnZVxcXCIpLGMpLG4uZHJhd0FycmF5cyhyLDAsaSl9LGQ9ZGVmKCgoZSx0KT0+e2lmKGlzKGUsby5SZWN0YW5nbGUpKXtpZihpcyh0LG8uUmVjdGFuZ2xlKSlyZXR1cm4gYm9vbCgocj1nZXRSZWN0UG9seShlKSxuPWdldFJlY3RQb2x5KHQpLGNvbGxpZGVQb2x5UG9pbnQocixuWzBdKXx8Y29sbGlkZVBvbHlQb2ludChuLHJbMF0pfHxyLmZpbmQoKChlLG8sdCk9PigoZSxvLHQpPT5lLmZpbmQoKChlLHIsbik9PigoZSxvLHQscik9Pntjb25zdCBuPShyWzFdLXRbMV0pKihvWzBdLWVbMF0pLShyWzBdLXRbMF0pKihvWzFdLWVbMV0pLGE9KChyWzBdLXRbMF0pKihlWzFdLXRbMV0pLShyWzFdLXRbMV0pKihlWzBdLXRbMF0pKS9uLGM9KChvWzBdLWVbMF0pKihlWzFdLXRbMV0pLShvWzFdLWVbMV0pKihlWzBdLXRbMF0pKS9uO3JldHVybiBhPj0wJiZhPD0xJiZjPj0wJiZjPD0xfSkobyx0LGUsbltyKzE9PW4ubGVuZ3RoPzA6cisxXSkpKSkobixlLHRbbysxPT10Lmxlbmd0aD8wOm8rMV0pKSkpKTtpZih0PT1vLmN1cnNvcilyZXR1cm4gYm9vbChjb2xsaWRlUG9seVBvaW50KGdldFJlY3RQb2x5KGUpLFt4KCkseSgpXSkpO29iamVjdCh0KX12YXIgcixuO2lmKGU9PW8uY3Vyc29yKXtpZihpcyh0LG8uUmVjdGFuZ2xlKSlyZXR1cm4gYm9vbChjb2xsaWRlUG9seVBvaW50KGdldFJlY3RQb2x5KHQpLFt4KCkseSgpXSkpO2lmKHQ9PW8uY3Vyc29yKXJldHVybiBTay5idWlsdGlucy5ib29sLnRydWUkO29iamVjdCh0KX1vYmplY3QoZSl9KSksbD17c2V0OihlLG8pPT57aWYoZS5vYiR0eXBlPT1sLmNsYXNzKW8uZm9yRWFjaCgoKG8sdCxyKT0+clt0XT10PGUuJGRhdGEubGVuZ3RoP2UuJGdldCgpW3RdOm8pKTtlbHNle2lmKCFTay5idWlsdGluLmNoZWNrU2VxdWVuY2UoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW5zLlR5cGVFcnJvcihcXFwiYXR0cmlidXRlIG11c3QgYmUgYSBzZXF1ZW5jZSBvZiB2YWx1ZXNcXFwiKTtvLmZvckVhY2goKChvLHQscik9PnJbdF09dDxlLnYubGVuZ3RoP2Uudlt0XS52Om8pKX1yZXR1cm4gb30sbmV3OihlLG8sLi4udCk9Pntjb25zdCByPWNhbGwobC5jbGFzcyk7cmV0dXJuIHIuJHBhcmVudD1lLHIuJGdldD1vLHIuJGRhdGE9dC5tYXAoKGU9Pih7bmFtZTplWzBdLHNldDplWzFdfSkpKSxyfSxjbGFzczpidWlsZCgoKGUsbyk9PntvLl9fZ2V0YXR0cl9fPWRlZigoKGUsbyk9Pntjb25zdCB0PWUuJGRhdGEuZmluZEluZGV4KChlPT5lLm5hbWU9PW8udikpO2lmKC0xIT10KXJldHVybiBmbG9hdChlLiRnZXQoKVt0XSl9KSksby5fX3NldGF0dHJfXz1kZWYoKChlLG8sdCk9Pntjb25zdCByPWUuJGRhdGEuZmluZCgoZT0+ZS5uYW1lPT1vLnYpKTtyJiZyLnNldChlLiRwYXJlbnQsdCl9KSksby5fX3N0cl9fPWRlZigoZT0+c3RyKGAoJHtlLiRnZXQoKS5qb2luKFxcXCIsIFxcXCIpfSlgKSkpLG8uX19yZXByX189ZGVmKChlPT5zdHIoYFske2UuJGdldCgpLmpvaW4oXFxcIiwgXFxcIil9XWApKSl9KSxcXFwiVmVjdG9yXFxcIil9LHU9e25ldzooZSxvLHQscixuKT0+e2UuJGNvbG9yPWwuc2V0KG4sWzAsMCwwLDFdKSxlLiRwb3M9W251bWJlcihvKSxudW1iZXIodCldLGUuJGFuZ2xlPW51bWJlcihyKSxlLiRhbmNob3I9WzAsMF0sZS4kc2NhbGU9WzEsMV19LGNsYXNzOmJ1aWxkKCgoZSx0KT0+e3QuY29sbGlkZXNfd2l0aD1kLHQubG9va19hdD1kZWYoKChlLHQpPT57Y29uc3Qgc2V0PShvLHQpPT57Y29uc3Qgcj1NYXRoLmF0YW4yKHQtZS4kcG9zWzFdLG8tZS4kcG9zWzBdKTtlLiRhbmdsZT0xODAqci9NYXRoLlBJfTt0PT1vLmN1cnNvcj9zZXQoeCgpLHkoKSk6aXModCx1LmNsYXNzKT9zZXQoLi4udC4kcG9zKTpvYmplY3QodCl9KSksdC5tb3ZlX3Rvd2FyZD1kZWYoKChlLHQscik9Pntjb25zdCBuPW51bWJlcihyKT8/MSxzZXQ9KG8sdCk9Pntjb25zdCByPW8tZS4kcG9zWzBdLGE9dC1lLiRwb3NbMV07TWF0aC5oeXBvdChyLGEpPG4/KGUuJHBvc1swXSs9cixlLiRwb3NbMV0rPWEpOihlLiRwb3NbMF0rPU1hdGguY29zKE1hdGguYXRhbjIoYSxyKSkqbixlLiRwb3NbMV0rPU1hdGguc2luKE1hdGguYXRhbjIoYSxyKSkqbil9O3Q9PW8uY3Vyc29yP3NldCh4KCkseSgpKTppcyh0LHUuY2xhc3MpP3NldCguLi50LiRwb3MpOm9iamVjdCh0KX0pKTtjb25zdCB4PShlLG8pPT5lLiRwb3NbMF09bnVtYmVyKG8pLHk9KGUsbyk9PmUuJHBvc1sxXT1udW1iZXIobyk7dC54PXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kcG9zWzBdKSkpLGRlZih4KSksdC55PXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kcG9zWzFdKSkpLGRlZih5KSksdC5wb3M9dC5wb3NpdGlvbj1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5lLiRwb3MpLFtcXFwieFxcXCIseF0sW1xcXCJ5XFxcIix5XSkpKSxkZWYoKChlLG8pPT5sLnNldChvLGUuJHBvcykpKSksdC50b3A9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiR0b3AoKSkpKSxkZWYoKChlLG8pPT5lLiRwb3NbMV0rPW8tZS4kdG9wKCkpKSksdC5sZWZ0PXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kbGVmdCgpKSkpLGRlZigoKGUsbyk9PmUuJHBvc1swXSs9by1lLiRsZWZ0KCkpKSksdC5ib3R0b209cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRib3R0b20oKSkpKSxkZWYoKChlLG8pPT5lLiRwb3NbMV0rPW8tZS4kYm90dG9tKCkpKSksdC5yaWdodD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHJpZ2h0KCkpKSksZGVmKCgoZSxvKT0+ZS4kcG9zWzBdKz1vLWUuJHJpZ2h0KCkpKSk7Y29uc3Qgc2NhbGVYPShlLG8pPT5lLiRzY2FsZVswXT1udW1iZXIobyksc2NhbGVZPShlLG8pPT5lLiRzY2FsZVsxXT1udW1iZXIobyk7dC5zY2FsZT1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5lLiRzY2FsZSksW1xcXCJ4XFxcIixzY2FsZVhdLFtcXFwieVxcXCIsc2NhbGVZXSkpKSxkZWYoKChlLG8pPT5sLnNldChvLGUuJHNjYWxlKSkpKTtjb25zdCBhbmNob3JYPShlLG8pPT5lLiRhbmNob3JbMF09bnVtYmVyKG8pLGFuY2hvclk9KGUsbyk9PmUuJGFuY2hvclsxXT1udW1iZXIobyk7dC5hbmNob3I9cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+ZS4kYW5jaG9yKSxbXFxcInhcXFwiLGFuY2hvclhdLFtcXFwieVxcXCIsYW5jaG9yWV0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRhbmNob3IpKSkpLHQuYW5nbGU9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRhbmdsZSkpKSxkZWYoKChlLG8pPT5lLiRhbmdsZT1udW1iZXIobykpKSk7Y29uc3QgcmVkPShlLG8pPT5lLiRjb2xvclswXT1udW1iZXIobyksZ3JlZW49KGUsbyk9PmUuJGNvbG9yWzFdPW51bWJlcihvKSxibHVlPShlLG8pPT5lLiRjb2xvclsyXT1udW1iZXIobyksYWxwaGE9KGUsbyk9PmUuJGNvbG9yWzNdPW51bWJlcihvKTt0LnJlZD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJGNvbG9yWzBdKSkpLGRlZihyZWQpKSx0LmdyZWVuPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kY29sb3JbMV0pKSksZGVmKGdyZWVuKSksdC5ibHVlPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kY29sb3JbMl0pKSksZGVmKGJsdWUpKSx0LmJsdWU9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRjb2xvclszXSkpKSxkZWYoYWxwaGEpKSx0LmNvbG9yPXByb3BlcnR5KGRlZigoZT0+bC5uZXcoZSwoKCk9PmUuJGNvbG9yKSxbXFxcInJlZFxcXCIscmVkXSxbXFxcImdyZWVuXFxcIixncmVlbl0sW1xcXCJibHVlXFxcIixibHVlXSxbXFxcImFscGhhXFxcIixhbHBoYV0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRjb2xvcikpKSl9KSxcXFwiU2hhcGVcXFwiKX07cmV0dXJuIG8uTUFOPXBhdGgoXFxcImltYWdlcy9tYW4ucG5nXFxcIiksby5DT0lOPXBhdGgoXFxcImltYWdlcy9jb2luLnBuZ1xcXCIpLG8uRU5FTVk9cGF0aChcXFwiaW1hZ2VzL2VuZW15LnBuZ1xcXCIpLG8uREVGQVVMVD1wYXRoKFxcXCJmb250cy9kZWZhdWx0LnR0ZlxcXCIpLG8uQ09ERT1wYXRoKFxcXCJmb250cy9jb2RlLnR0ZlxcXCIpLG8uUEVOQ0lMPXBhdGgoXFxcImZvbnRzL3BlbmNpbC50dGZcXFwiKSxvLlNFUklGPXBhdGgoXFxcImZvbnRzL3NlcmlmLnR0ZlxcXCIpLG8uSEFORFdSSVRJTkc9cGF0aChcXFwiZm9udHMvaGFuZHdyaXRpbmcudHRmXFxcIiksby5UWVBFV1JJVEVSPXBhdGgoXFxcImZvbnRzL3R5cGV3cml0ZXIudHRmXFxcIiksby5KT0lORUQ9cGF0aChcXFwiZm9udHMvam9pbmVkLnR0ZlxcXCIpLG8ud2luZG93PWNhbGwoYnVpbGQoKChlLG8pPT57Y29uc3QgaW5pdD0oZSxvLHQscixhKT0+e2UuJGNhcHRpb249c3RyaW5nKG8pLGUuJGNvbG9yPWwuc2V0KGEsWzEsMSwxXSksbi5jbGVhckNvbG9yKC4uLmUuJGNvbG9yLDEpfTtpbml0LiRkZWZhdWx0cz1bc3RyKFxcXCJKb0Jhc2VcXFwiKSxudWxsLG51bGwsdHVwbGUoKV0saW5pdC5jb192YXJuYW1lcz1bXFxcInNlbGZcXFwiLFxcXCJjYXB0aW9uXFxcIixcXFwid2lkdGhcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJjb2xvclxcXCJdLG8uX19pbml0X189ZGVmKGluaXQpLG8uY2xvc2U9ZGVmKChlPT5lLiRjbG9zZT0hMCkpLG8ubWF4aW1pemU9ZGVmKGJsYW5rKSxvLm1pbmltaXplPWRlZihibGFuayksby5mb2N1cz1kZWYoYmxhbmspLG8uY2FwdGlvbj1wcm9wZXJ0eShkZWYoKGU9PnN0cihlLiRjYXB0aW9uKSkpLGRlZigoKGUsbyk9PmUuJGNhcHRpb249c3RyaW5nKG8pKSkpO2NvbnN0IHJlZD0oZSxvKT0+e2UuJGNvbG9yWzBdPW51bWJlcihvKSxuLmNsZWFyQ29sb3IoLi4uZS4kY29sb3IsMSl9LGdyZWVuPShlLG8pPT57ZS4kY29sb3JbMV09bnVtYmVyKG8pLG4uY2xlYXJDb2xvciguLi5lLiRjb2xvciwxKX0sYmx1ZT0oZSxvKT0+e2UuJGNvbG9yWzJdPW51bWJlcihvKSxuLmNsZWFyQ29sb3IoLi4uZS4kY29sb3IsMSl9O28ucmVkPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kY29sb3JbMF0pKSksZGVmKHJlZCkpLG8uZ3JlZW49cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRjb2xvclsxXSkpKSxkZWYoZ3JlZW4pKSxvLmJsdWU9cHJvcGVydHkoZGVmKChlPT5mbG9hdChlLiRjb2xvclsyXSkpKSxkZWYoYmx1ZSkpLG8uY29sb3I9cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+ZS4kY29sb3IpLFtcXFwicmVkXFxcIixyZWRdLFtcXFwiZ3JlZW5cXFwiLGdyZWVuXSxbXFxcImJsdWVcXFwiLGJsdWVdKSkpLGRlZigoKGUsbyk9Pm4uY2xlYXJDb2xvciguLi5sLnNldChvLGUuJGNvbG9yKSwxKSkpKSxvLndpZHRoPXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHdpZHRoKCkpKSkpLG8uaGVpZ2h0PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KGhlaWdodCgpKSkpKSxvLnNpemU9cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+W3dpZHRoKCksaGVpZ2h0KCldKSxbXFxcInhcXFwiLGJsYW5rXSxbXFxcInlcXFwiLGJsYW5rXSkpKSxkZWYoKChlLG8pPT5sLnNldChvLG5ldyBBcnJheSgyKSkpKSksby50b3A9cHJvcGVydHkoZGVmKCgoKT0+ZmxvYXQoaGVpZ2h0KCkvMikpKSksby5ib3R0b209cHJvcGVydHkoZGVmKCgoKT0+ZmxvYXQoaGVpZ2h0KCkvLTIpKSkpLG8ubGVmdD1wcm9wZXJ0eShkZWYoKCgpPT5mbG9hdCh3aWR0aCgpLy0yKSkpKSxvLnJpZ2h0PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHdpZHRoKCkvMikpKSksby5yZXNpemU9cHJvcGVydHkoZGVmKChlPT5ib29sKGUuJHJlc2l6ZSkpKSl9KSxcXFwiV2luZG93XFxcIikpLG8uY3Vyc29yPWNhbGwoYnVpbGQoKChlLG8pPT57by54PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHgoKSkpKSksby55PXByb3BlcnR5KGRlZigoKCk9PmZsb2F0KHkoKSkpKSksby5wb3M9by5wb3NpdGlvbj1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5beCgpLHkoKV0pLFtcXFwieFxcXCIsYmxhbmtdLFtcXFwieVxcXCIsYmxhbmtdKSkpLGRlZigoKGUsbyk9Pmwuc2V0KG8sbmV3IEFycmF5KDIpKSkpKSxvLm1vdmU9cHJvcGVydHkoZGVmKChlPT5ib29sKGUuJG1vdmUpKSkpLG8uZW50ZXI9cHJvcGVydHkoZGVmKChlPT5ib29sKGUuJGVudGVyKSkpKSxvLmxlYXZlPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRsZWF2ZSkpKSksby5wcmVzcz1wcm9wZXJ0eShkZWYoKGU9PmJvb2woZS4kcHJlc3MpKSkpLG8ucmVsZWFzZT1wcm9wZXJ0eShkZWYoKGU9PmJvb2woZS4kcmVsZWFzZSkpKSksby5ob2xkPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRob2xkKSkpKX0pLFxcXCJDdXJzb3JcXFwiKSksby5jdXJzb3IuJHg9MCxvLmN1cnNvci4keT0wLG8ua2V5PWNhbGwoYnVpbGQoKChlLG8pPT57by5fX2dldGF0dHJfXz1kZWYoKChlLG8pPT57Y29uc3QgdD1lLiRkYXRhW28udl07aWYodClyZXR1cm4gdC5ob2xkfHx0LnJlbGVhc2U/KHI9W3N0cihcXFwicHJlc3NcXFwiKSxib29sKHQucHJlc3MpLHN0cihcXFwicmVsZWFzZVxcXCIpLGJvb2wodC5yZWxlYXNlKSxzdHIoXFxcInJlcGVhdFxcXCIpLGJvb2wodC5yZXBlYXQpXSxuZXcgU2suYnVpbHRpbi5kaWN0KHIpKTpTay5idWlsdGluLmJvb2wuZmFsc2UkO3ZhciByfSkpLG8uaG9sZD1wcm9wZXJ0eShkZWYoKGU9Pntmb3IoY29uc3QgbyBpbiBlLiRkYXRhKWlmKGUuJGRhdGFbb10uaG9sZClyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO3JldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkfSkpKSxvLnByZXNzPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRwcmVzcykpKSksby5yZWxlYXNlPXByb3BlcnR5KGRlZigoZT0+Ym9vbChlLiRyZWxlYXNlKSkpKSxvLnJlcGVhdD1wcm9wZXJ0eShkZWYoKGU9PmJvb2woZS4kcmVwZWF0KSkpKX0pLFxcXCJLZXlcXFwiKSksby5rZXkuJGRhdGE9e3NwYWNlOntjb2RlOlxcXCJTcGFjZVxcXCJ9LGFwb3N0cm9waGU6e2NvZGU6XFxcIlF1b3RlXFxcIn0sY29tbWE6e2NvZGU6XFxcIkNvbW1hXFxcIn0sbWludXM6e2NvZGU6XFxcIk1pbnVzXFxcIn0scGVyaW9kOntjb2RlOlxcXCJQZXJpb2RcXFwifSxzbGFzaDp7Y29kZTpcXFwiU2xhc2hcXFwifSxfMDp7Y29kZTpcXFwiRGlnaXQwXFxcIn0sXzE6e2NvZGU6XFxcIkRpZ2l0MVxcXCJ9LF8yOntjb2RlOlxcXCJEaWdpdDJcXFwifSxfMzp7Y29kZTpcXFwiRGlnaXQzXFxcIn0sXzQ6e2NvZGU6XFxcIkRpZ2l0NFxcXCJ9LF81Ontjb2RlOlxcXCJEaWdpdDVcXFwifSxfNjp7Y29kZTpcXFwiRGlnaXQ2XFxcIn0sXzc6e2NvZGU6XFxcIkRpZ2l0N1xcXCJ9LF84Ontjb2RlOlxcXCJEaWdpdDhcXFwifSxfOTp7Y29kZTpcXFwiRGlnaXQ5XFxcIn0sc2VtaWNvbG9uOntjb2RlOlxcXCJTZW1pY29sb25cXFwifSxlcXVhbDp7Y29kZTpcXFwiRXF1YWxcXFwifSxhOntjb2RlOlxcXCJLZXlBXFxcIn0sYjp7Y29kZTpcXFwiS2V5QlxcXCJ9LGM6e2NvZGU6XFxcIktleUNcXFwifSxkOntjb2RlOlxcXCJLZXlEXFxcIn0sZTp7Y29kZTpcXFwiS2V5RVxcXCJ9LGY6e2NvZGU6XFxcIktleUZcXFwifSxnOntjb2RlOlxcXCJLZXlHXFxcIn0saDp7Y29kZTpcXFwiS2V5SFxcXCJ9LGk6e2NvZGU6XFxcIktleUlcXFwifSxqOntjb2RlOlxcXCJLZXlKXFxcIn0sazp7Y29kZTpcXFwiS2V5S1xcXCJ9LGw6e2NvZGU6XFxcIktleUxcXFwifSxtOntjb2RlOlxcXCJLZXlNXFxcIn0sbjp7Y29kZTpcXFwiS2V5TlxcXCJ9LG86e2NvZGU6XFxcIktleU9cXFwifSxwOntjb2RlOlxcXCJLZXlQXFxcIn0scTp7Y29kZTpcXFwiS2V5UVxcXCJ9LHI6e2NvZGU6XFxcIktleVJcXFwifSxzOntjb2RlOlxcXCJLZXlTXFxcIn0sdDp7Y29kZTpcXFwiS2V5VFxcXCJ9LHU6e2NvZGU6XFxcIktleVVcXFwifSx2Ontjb2RlOlxcXCJLZXlWXFxcIn0sdzp7Y29kZTpcXFwiS2V5V1xcXCJ9LHg6e2NvZGU6XFxcIktleVhcXFwifSx5Ontjb2RlOlxcXCJLZXlZXFxcIn0sejp7Y29kZTpcXFwiS2V5WlxcXCJ9LGxlZnRfYnJhY2tldDp7Y29kZTpcXFwiQnJhY2tldExlZnRcXFwifSxiYWNrc2xhc2g6e2NvZGU6XFxcIkJhY2tzbGFzaFxcXCJ9LHJpZ2h0X2JyYWNrZXQ6e2NvZGU6XFxcIkJyYWNrZXRSaWdodFxcXCJ9LGJhY2txdW90ZTp7Y29kZTpcXFwiQmFja3F1b3RlXFxcIn0sZXNjYXBlOntjb2RlOlxcXCJFc2NhcGVcXFwifSxlbnRlcjp7Y29kZTpcXFwiRW50ZXJcXFwifSx0YWI6e2NvZGU6XFxcIlRhYlxcXCJ9LGJhY2tzcGFjZTp7Y29kZTpcXFwiQmFja3NwYWNlXFxcIn0saW5zZXJ0Ontjb2RlOlxcXCJJbnNlcnRcXFwifSxkZWxldGU6e2NvZGU6XFxcIkRlbGV0ZVxcXCJ9LHJpZ2h0Ontjb2RlOlxcXCJBcnJvd1JpZ2h0XFxcIn0sbGVmdDp7Y29kZTpcXFwiQXJyb3dMZWZ0XFxcIn0sZG93bjp7Y29kZTpcXFwiQXJyb3dEb3duXFxcIn0sdXA6e2NvZGU6XFxcIkFycm93VXBcXFwifSxwYWdlX3VwOntjb2RlOlxcXCJQYWdlVXBcXFwifSxwYWdlX2Rvd246e2NvZGU6XFxcIlBhZ2VEb3duXFxcIn0saG9tZTp7Y29kZTpcXFwiSG9tZVxcXCJ9LGVuZDp7Y29kZTpcXFwiRW5kXFxcIn0sY2Fwc19sb2NrOntjb2RlOlxcXCJDYXBzTG9ja1xcXCJ9LHNjcm9sbF9sb2NrOntjb2RlOlxcXCJTY3JvbGxMb2NrXFxcIn0sbnVtX2xvY2s6e2NvZGU6XFxcIk51bUxvY2tcXFwifSxwcmludF9zY3JlZW46e2NvZGU6XFxcIlByaW50U2NyZWVuXFxcIn0scGF1c2U6e2NvZGU6XFxcIlBhdXNlXFxcIn0sZjE6e2NvZGU6XFxcIkYxXFxcIn0sZjI6e2NvZGU6XFxcIkYyXFxcIn0sZjM6e2NvZGU6XFxcIkYzXFxcIn0sZjQ6e2NvZGU6XFxcIkY0XFxcIn0sZjU6e2NvZGU6XFxcIkY1XFxcIn0sZjY6e2NvZGU6XFxcIkY2XFxcIn0sZjc6e2NvZGU6XFxcIkY3XFxcIn0sZjg6e2NvZGU6XFxcIkY4XFxcIn0sZjk6e2NvZGU6XFxcIkY5XFxcIn0sZjEwOntjb2RlOlxcXCJGMTBcXFwifSxmMTE6e2NvZGU6XFxcIkYxMVxcXCJ9LGYxMjp7Y29kZTpcXFwiRjEyXFxcIn0sZjEzOntjb2RlOlxcXCJGMTNcXFwifSxmMTQ6e2NvZGU6XFxcIkYxNFxcXCJ9LGYxNTp7Y29kZTpcXFwiRjE1XFxcIn0sZjE2Ontjb2RlOlxcXCJGMTZcXFwifSxmMTc6e2NvZGU6XFxcIkYxN1xcXCJ9LGYxODp7Y29kZTpcXFwiRjE4XFxcIn0sZjE5Ontjb2RlOlxcXCJGMTlcXFwifSxmMjA6e2NvZGU6XFxcIkYyMFxcXCJ9LGYyMTp7Y29kZTpcXFwiRjIxXFxcIn0sZjIyOntjb2RlOlxcXCJGMjJcXFwifSxmMjM6e2NvZGU6XFxcIkYyM1xcXCJ9LGYyNDp7Y29kZTpcXFwiRjI0XFxcIn0sZjI1Ontjb2RlOlxcXCJGMjVcXFwifSxwYWRfMDp7Y29kZTpcXFwiTnVtcGFkMFxcXCJ9LHBhZF8xOntjb2RlOlxcXCJOdW1wYWQxXFxcIn0scGFkXzI6e2NvZGU6XFxcIk51bXBhZDJcXFwifSxwYWRfMzp7Y29kZTpcXFwiTnVtcGFkM1xcXCJ9LHBhZF80Ontjb2RlOlxcXCJOdW1wYWQ0XFxcIn0scGFkXzU6e2NvZGU6XFxcIk51bXBhZDVcXFwifSxwYWRfNjp7Y29kZTpcXFwiTnVtcGFkNlxcXCJ9LHBhZF83Ontjb2RlOlxcXCJOdW1wYWQ3XFxcIn0scGFkXzg6e2NvZGU6XFxcIk51bXBhZDhcXFwifSxwYWRfOTp7Y29kZTpcXFwiTnVtcGFkOVxcXCJ9LGRlY2ltYWw6e2NvZGU6XFxcIk51bXBhZERlY2ltYWxcXFwifSxkaXZpZGU6e2NvZGU6XFxcIk51bXBhZERpdmlkZVxcXCJ9LG11bHRpcGx5Ontjb2RlOlxcXCJOdW1wYWRNdWx0aXBseVxcXCJ9LHN1YnRyYWN0Ontjb2RlOlxcXCJOdW1wYWRTdWJ0cmFjdFxcXCJ9LGFkZDp7Y29kZTpcXFwiTnVtcGFkQWRkXFxcIn0sZW50ZXI6e2NvZGU6XFxcIk51bXBhZEVudGVyXFxcIn0sZXF1YWw6e2NvZGU6XFxcIk51bXBhZEVxdWFsXFxcIn0sbGVmdF9zaGlmdDp7Y29kZTpcXFwiU2hpZnRMZWZ0XFxcIn0sbGVmdF9jdHJsOntjb2RlOlxcXCJDb250cm9sTGVmdFxcXCJ9LGxlZnRfYWx0Ontjb2RlOlxcXCJBbHRMZWZ0XFxcIn0sbGVmdF9zdXBlcjp7Y29kZTpcXFwiU3VwZXJMZWZ0XFxcIn0scmlnaHRfc2hpZnQ6e2NvZGU6XFxcIlNoaWZ0UmlnaHRcXFwifSxyaWdodF9jdHJsOntjb2RlOlxcXCJDb250cm9sUmlnaHRcXFwifSxyaWdodF9hbHQ6e2NvZGU6XFxcIkFsdFJpZ2h0XFxcIn0scmlnaHRfc3VwZXI6e2NvZGU6XFxcIlN1cGVyUmlnaHRcXFwifSxtZW51Ontjb2RlOlxcXCJNZW51XFxcIn19LG8uY2FtZXJhPWNhbGwoYnVpbGQoKChlLG8pPT57Y29uc3QgaW5pdD0oZSxvLHQpPT57ZS4kcG9zPVtudW1iZXIobyksbnVtYmVyKHQpXX07aW5pdC4kZGVmYXVsdHM9W2ludCgpLGludCgpXSxpbml0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInhcXFwiLFxcXCJ5XFxcIl0sby5fX2luaXRfXz1kZWYoaW5pdCk7Y29uc3QgeD0oZSxvKT0+ZS4kcG9zWzBdPW51bWJlcihvKSx5PShlLG8pPT5lLiRwb3NbMV09bnVtYmVyKG8pO28ueD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHBvc1swXSkpKSxkZWYoeCkpLG8ueT1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHBvc1sxXSkpKSxkZWYoeSkpLG8ucG9zPW8ucG9zaXRpb249cHJvcGVydHkoZGVmKChlPT5sLm5ldyhlLCgoKT0+ZS4kcG9zKSxbXFxcInhcXFwiLHhdLFtcXFwieVxcXCIseV0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRwb3MpKSkpfSksXFxcIkNhbWVyYVxcXCIpKSxvLlJlY3RhbmdsZT1idWlsZCgoKGUsbyk9Pntjb25zdCBpbml0PShlLG8sdCxyLG4sYSxjKT0+e3UubmV3KGUsbyx0LGEsYyksZS4kc2l6ZT1bbnVtYmVyKHIpLG51bWJlcihuKV0sZS4kdG9wPSgpPT57cmV0dXJuKG89Z2V0UmVjdFBvbHkoZSkpLnJlZHVjZSgoKGUsbyk9Pm9bMV0+ZT9vWzFdOmUpLG9bMF1bMV0pO3ZhciBvfSxlLiRsZWZ0PSgpPT57cmV0dXJuKG89Z2V0UmVjdFBvbHkoZSkpLnJlZHVjZSgoKGUsbyk9Pm9bMF08ZT9vWzBdOmUpLG9bMF1bMF0pO3ZhciBvfSxlLiRib3R0b209KCk9PntyZXR1cm4obz1nZXRSZWN0UG9seShlKSkucmVkdWNlKCgoZSxvKT0+b1sxXTxlP29bMV06ZSksb1swXVsxXSk7dmFyIG99LGUuJHJpZ2h0PSgpPT57cmV0dXJuKG89Z2V0UmVjdFBvbHkoZSkpLnJlZHVjZSgoKGUsbyk9Pm9bMF0+ZT9vWzBdOmUpLG9bMF1bMF0pO3ZhciBvfX07aW5pdC4kZGVmYXVsdHM9W2ludCgpLGludCgpLGludCg1MCksaW50KDUwKSxpbnQoKSx0dXBsZSgpXSxpbml0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInhcXFwiLFxcXCJ5XFxcIixcXFwid2lkdGhcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJhbmdsZVxcXCIsXFxcImNvbG9yXFxcIl0sby5fX2luaXRfXz1kZWYoaW5pdCksby5kcmF3PWRlZigoZT0+ZHJhd1NoYXBlKGUsZS4kc2l6ZSxjLG4uVFJJQU5HTEVfU1RSSVAsITEsNCkpKTtjb25zdCB3aWR0aD0oZSxvKT0+ZS4kc2l6ZVswXT1udW1iZXIobyksaGVpZ2h0PShlLG8pPT5lLiRzaXplWzFdPW51bWJlcihvKTtvLndpZHRoPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kc2l6ZVswXSkpKSxkZWYod2lkdGgpKSxvLmhlaWdodD1wcm9wZXJ0eShkZWYoKGU9PmZsb2F0KGUuJHNpemVbMV0pKSksZGVmKGhlaWdodCkpLG8uc2l6ZT1wcm9wZXJ0eShkZWYoKGU9PmwubmV3KGUsKCgpPT5lLiRzaXplKSxbXFxcIndpZHRoXFxcIix3aWR0aF0sW1xcXCJoZWlnaHRcXFwiLGhlaWdodF0pKSksZGVmKCgoZSxvKT0+bC5zZXQobyxlLiRzaXplKSkpKX0pLFxcXCJSZWN0YW5nbGVcXFwiLFt1LmNsYXNzXSksby5JbWFnZT1idWlsZCgoKGUscik9Pntjb25zdCBpbml0PShlLHIsbixhLGMsaSxzLGQpPT53YWl0KCgodSwkKT0+e2NhbGwoby5SZWN0YW5nbGUucHJvdG90eXBlLl9faW5pdF9fLGUsbixhLGkscyxjKTtjb25zdCBwPXQuZmluZCgoZT0+ZS5uYW1lPT1zdHJpbmcocikpKSxzZXQ9bz0+e2UuJHRleHR1cmU9by5zb3VyY2UsZS4kc2l6ZVswXXx8PW8ud2lkdGgsZS4kc2l6ZVsxXXx8PW8uaGVpZ2h0fTtpZihlLiRjb2xvcj1sLnNldChkLFsxLDEsMSwxXSkscClyZXR1cm4gc2V0KHApLHUoKTtjb25zdCBtPW5ldyBJbWFnZTttLmNyb3NzT3JpZ2luPVxcXCJhbm9ueW1vdXNcXFwiLG0uc3JjPXN0cmluZyhyKSxtLm9uZXJyb3I9KCk9PiQobmV3IFNrLmJ1aWx0aW4uRmlsZU5vdEZvdW5kRXJyb3IoYGZhaWxlZCB0byBsb2FkIGltYWdlOiBcXFwiJHtzdHJpbmcocil9XFxcImApKSxtLm9ubG9hZD0oKT0+e2NvbnN0IGU9e25hbWU6c3RyaW5nKHIpLHdpZHRoOm0ud2lkdGgsaGVpZ2h0Om0uaGVpZ2h0LHNvdXJjZTpjcmVhdGVJbWFnZShtKX07dC5wdXNoKGUpLHNldChlKSx1KCl9fSkpO2luaXQuJGRlZmF1bHRzPVtvLk1BTixpbnQoKSxpbnQoKSxpbnQoKSxpbnQoKSxpbnQoKSx0dXBsZSgpXSxpbml0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcIm5hbWVcXFwiLFxcXCJ4XFxcIixcXFwieVxcXCIsXFxcImFuZ2xlXFxcIixcXFwid2lkdGhcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJjb2xvclxcXCJdLHIuX19pbml0X189ZGVmKGluaXQpLHIuZHJhdz1kZWYoKGU9PntuLmFjdGl2ZVRleHR1cmUobi5URVhUVVJFMCksbi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsZS4kdGV4dHVyZSksZHJhd1NoYXBlKGUsZS4kc2l6ZSxjLG4uVFJJQU5HTEVfU1RSSVAsITAsNCl9KSl9KSxcXFwiSW1hZ2VcXFwiLFtvLlJlY3RhbmdsZV0pLG8uVGV4dD1idWlsZCgoKGUsdCk9Pntjb25zdCBpbml0PShlLHQscixuLGEsYyxpLHMpPT53YWl0KCgoZCxsKT0+e2NhbGwoby5SZWN0YW5nbGUucHJvdG90eXBlLl9faW5pdF9fLGUscixuLGludCgpLGludCgpLGMsaSksZS4kZm9udD1zdHJpbmcocyksZS4kZm9udFNpemU9bnVtYmVyKGEpLGUuJGNvbnRlbnQ9c3RyaW5nKHQpLGxvYWRGb250KGUuJGZvbnQpLnRoZW4oKCgpPT57cmVuZGVyVGV4dChlKSxkKCl9KSkuY2F0Y2gobCl9KSk7aW5pdC4kZGVmYXVsdHM9W3N0cihcXFwiVGV4dFxcXCIpLGludCgpLGludCgpLGludCg1MCksaW50KCksdHVwbGUoKSxvLkRFRkFVTFRdLGluaXQuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIixcXFwiY29udGVudFxcXCIsXFxcInhcXFwiLFxcXCJ5XFxcIixcXFwiZm9udF9zaXplXFxcIixcXFwiYW5nbGVcXFwiLFxcXCJjb2xvclxcXCIsXFxcImZvbnRcXFwiXSx0Ll9faW5pdF9fPWRlZihpbml0KSx0LmRyYXc9ZGVmKChlPT57bi5hY3RpdmVUZXh0dXJlKG4uVEVYVFVSRTApLG4uYmluZFRleHR1cmUobi5URVhUVVJFXzJELGUuJHRleHR1cmUpLGRyYXdTaGFwZShlLGUuJHNpemUsYyxuLlRSSUFOR0xFX1NUUklQLCEwLDQpfSkpLHQuY29udGVudD1wcm9wZXJ0eShkZWYoKGU9PnN0cihlLiRjb250ZW50KSkpLGRlZigoKGUsbyk9PntlLiRjb250ZW50PXN0cmluZyhvKSxyZW5kZXJUZXh0KGUpfSkpKSx0LmZvbnQ9cHJvcGVydHkoZGVmKChlPT5zdHIoZS4kZm9udCkpKSxkZWYoKChlLG8pPT53YWl0KCgodCxyKT0+e2xvYWRGb250KGUuJGZvbnQ9c3RyaW5nKG8pKS50aGVuKCgoKT0+e3JlbmRlclRleHQoZSksdCgpfSkpLmNhdGNoKHIpfSkpKSkpLHQuZm9udF9zaXplPXByb3BlcnR5KGRlZigoZT0+ZmxvYXQoZS4kZm9udF9zaXplKSkpLGRlZigoKGUsbyk9PntlLiRmb250X3NpemU9bnVtYmVyKG8pLHJlbmRlclRleHQoZSl9KSkpfSksXFxcIlRleHRcXFwiLFtvLlJlY3RhbmdsZV0pLG8ucmFuZG9tPWRlZigoKGUsbyk9Pntjb25zdCB0PU1hdGgubWluKG51bWJlcihlKSxudW1iZXIobykpO3JldHVybiBmbG9hdChNYXRoLnJhbmRvbSgpKihNYXRoLm1heChudW1iZXIoZSksbnVtYmVyKG8pKS10KSt0KX0pKSxvLnJ1bj1kZWYoKCgpPT53YWl0KCgocixpKT0+e2NvbnN0IHVwZGF0ZT0oKT0+e2NvbnN0IGZpbmFsPW89PntuLmRlbGV0ZUJ1ZmZlcihjKSxuLmRlbGV0ZVByb2dyYW0oYSksdC5mb3JFYWNoKChlPT5uLmRlbGV0ZVRleHR1cmUoZS5zb3VyY2UpKSksZC5kaXNjb25uZWN0KCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJtb3VzZWVudGVyXFxcIixtb3VzZUVudGVyKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIm1vdXNlbGVhdmVcXFwiLG1vdXNlTGVhdmUpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwibW91c2Vkb3duXFxcIixtb3VzZURvd24pLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwibW91c2V1cFxcXCIsbW91c2VVcCksZS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJtb3VzZW1vdmVcXFwiLG1vdXNlTW92ZSksZS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJrZXlkb3duXFxcIixrZXlEb3duKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImtleXVwXFxcIixrZXlVcCksY2FuY2VsQW5pbWF0aW9uRnJhbWUocy5mcmFtZSksbz9pKG8pOnIoKX07aWYoby53aW5kb3cuJGNsb3NlfHxEYXRlLm5vdygpLVNrLmV4ZWNTdGFydD5Tay5leGVjTGltaXQpcmV0dXJuIGZpbmFsKCk7Y29uc3QgbD1vLmNhbWVyYS4kcG9zWzBdLHU9by5jYW1lcmEuJHBvc1sxXSwkPW5ldyBGbG9hdDMyQXJyYXkoWzIvd2lkdGgoKSwwLDAsMCwwLDIvaGVpZ2h0KCksMCwwLDAsMCwtMiwwLDIqLWwvd2lkdGgoKSwyKi11L2hlaWdodCgpLC0xLDFdKTtuLnVuaWZvcm1NYXRyaXg0ZnYobi5nZXRVbmlmb3JtTG9jYXRpb24oYSxcXFwiY2FtZXJhXFxcIiksITEsJCksbi5jbGVhcihuLkNPTE9SX0JVRkZFUl9CSVQpO3RyeXtzLm1haW4uJGQubG9vcCYmY2FsbChzLm1haW4uJGQubG9vcCl9Y2F0Y2gocCl7ZmluYWwocCl9by53aW5kb3cuJHJlc2l6ZT0hMSxvLmN1cnNvci4kbW92ZT0hMSxvLmN1cnNvci4kZW50ZXI9ITEsby5jdXJzb3IuJGxlYXZlPSExLG8uY3Vyc29yLiRwcmVzcz0hMSxvLmN1cnNvci4kcmVsZWFzZT0hMSxvLmtleS4kcHJlc3M9ITEsby5rZXkuJHJlbGVhc2U9ITEsby5rZXkuJHJlcGVhdD0hMTtmb3IoY29uc3QgZSBpbiBvLmtleS4kZGF0YSlvLmtleS4kZGF0YVtlXS5wcmVzcz0hMSxvLmtleS4kZGF0YVtlXS5yZWxlYXNlPSExLG8ua2V5LiRkYXRhW2VdLnJlcGVhdD0hMX0sbG9vcD0oKT0+e3MuZnJhbWU9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApLHVwZGF0ZSgpfSxzPXttYWluOlNrLmltcG9ydE1vZHVsZShcXFwiX19tYWluX19cXFwiLCExLCEwKSxmcmFtZTpyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCl9LGQ9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCgpPT57bi52aWV3cG9ydCgwLDAsZS53aWR0aCxlLmhlaWdodCksby53aW5kb3cuJHJlc2l6ZT0hMCx1cGRhdGUoKX0pKTtkLm9ic2VydmUoZSx7YXR0cmlidXRlczohMH0pfSkpKSksZS5hZGRFdmVudExpc3RlbmVyKFxcXCJtb3VzZWVudGVyXFxcIixtb3VzZUVudGVyKSxlLmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1vdXNlbGVhdmVcXFwiLG1vdXNlTGVhdmUpLGUuYWRkRXZlbnRMaXN0ZW5lcihcXFwibW91c2Vkb3duXFxcIixtb3VzZURvd24pLGUuYWRkRXZlbnRMaXN0ZW5lcihcXFwibW91c2V1cFxcXCIsbW91c2VVcCksZS5hZGRFdmVudExpc3RlbmVyKFxcXCJtb3VzZW1vdmVcXFwiLG1vdXNlTW92ZSksZS5hZGRFdmVudExpc3RlbmVyKFxcXCJrZXlkb3duXFxcIixrZXlEb3duKSxlLmFkZEV2ZW50TGlzdGVuZXIoXFxcImtleXVwXFxcIixrZXlVcCksZS50YWJJbmRleD0wLGUuZm9jdXMoKSxuLnNoYWRlclNvdXJjZShpLFxcXCJcXFxcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgdmVydGV4O1xcXFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBjb29yZGluYXRlO1xcXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgcG9zaXRpb247XFxcXG4gICAgICAgIFxcXFxuICAgICAgICB1bmlmb3JtIG1hdDQgY2FtZXJhO1xcXFxuICAgICAgICB1bmlmb3JtIG1hdDQgb2JqZWN0O1xcXFxuICAgICAgICBcXFxcbiAgICAgICAgdm9pZCBtYWluKHZvaWQpIHtcXFxcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gY2FtZXJhICogb2JqZWN0ICogdmVjNCh2ZXJ0ZXgsIDAsIDEpO1xcXFxuICAgICAgICAgICAgcG9zaXRpb24gPSBjb29yZGluYXRlO1xcXFxuICAgICAgICB9XFxcIiksbi5zaGFkZXJTb3VyY2UocyxcXFwiXFxcXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgcG9zaXRpb247XFxcXG5cXFxcbiAgICAgICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xcXFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyO1xcXFxuICAgICAgICB1bmlmb3JtIGludCBpbWFnZTtcXFxcblxcXFxuICAgICAgICB2b2lkIG1haW4odm9pZCkge1xcXFxuICAgICAgICAgICAgaWYgKGltYWdlID09IDEpIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChzYW1wbGVyLCBwb3NpdGlvbikgKiBjb2xvcjtcXFxcbiAgICAgICAgICAgIGVsc2UgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxcXG4gICAgICAgIH1cXFwiKSxuLmNvbXBpbGVTaGFkZXIoaSksbi5jb21waWxlU2hhZGVyKHMpLG4uYXR0YWNoU2hhZGVyKGEsaSksbi5hdHRhY2hTaGFkZXIoYSxzKSxuLmxpbmtQcm9ncmFtKGEpLG4udXNlUHJvZ3JhbShhKSxuLnVuaWZvcm0xaShuLmdldFVuaWZvcm1Mb2NhdGlvbihhLFxcXCJzYW1wbGVyXFxcIiksMCksbi5kZWxldGVTaGFkZXIoaSksbi5kZWxldGVTaGFkZXIocyksbi5iaW5kQnVmZmVyKG4uQVJSQVlfQlVGRkVSLGMpLG4uYnVmZmVyRGF0YShuLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KFstLjUsLjUsMCwwLC41LC41LDEsMCwtLjUsLS41LDAsMSwuNSwtLjUsMSwxXSksbi5TVEFUSUNfRFJBVyksbi52ZXJ0ZXhBdHRyaWJQb2ludGVyKG4uZ2V0QXR0cmliTG9jYXRpb24oYSxcXFwidmVydGV4XFxcIiksMixuLkZMT0FULCExLDE2LDApLG4udmVydGV4QXR0cmliUG9pbnRlcihuLmdldEF0dHJpYkxvY2F0aW9uKGEsXFxcImNvb3JkaW5hdGVcXFwiKSwyLG4uRkxPQVQsITEsMTYsOCksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDEpLG4uZW5hYmxlKG4uQkxFTkQpLG4uYmxlbmRGdW5jKG4uU1JDX0FMUEhBLG4uT05FX01JTlVTX1NSQ19BTFBIQSksbi5waXhlbFN0b3JlaShuLlVOUEFDS19BTElHTk1FTlQsMSksb307XCIsXCJzcmMvbGliL19zdHJwdGltZS5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUoKXtjb25zdCBlPVNrLmJ1aWx0aW4uaW50Xyx0PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCxpPVNrLmJ1aWx0aW4uc3RyLHM9U2suYnVpbHRpbi50dXBsZSxuPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSx7aXNUcnVlOmEscmljaENvbXBhcmVCb29sOnIsY2hhaW46bH09U2subWlzY2V2YWwse3R5cGVOYW1lOm8sc2V0VXBNb2R1bGVNZXRob2RzOl8sYnVpbGROYXRpdmVDbGFzczpjfT1Tay5hYnN0cix7VHlwZUVycm9yOm0sVmFsdWVFcnJvcjpkLEtleUVycm9yOmgsSW5kZXhFcnJvcjpmLGNoZWNrU3RyaW5nOnUsYXNudW0kOnd9PVNrLmJ1aWx0aW4se3JlbWFwVG9QeTpwLHJlbWFwVG9KczpnfT1Tay5mZmkse2dldEF0dHI6JCxzZXRBdHRyOnl9PVNrLmdlbmVyaWMsUz1sLGs9L15bMC05XSskLztmdW5jdGlvbiBfYXNfaW50ZWdlcihlKXtpZighay50ZXN0KGUpKXRocm93IG5ldyBkKGBpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSAxMDogJyR7ZX0nYCk7cmV0dXJuIHBhcnNlSW50KGUpfWNvbnN0IGI9LyhbXFxcXFxcXFwuXiQqKz9cXFxcKFxcXFwpe31cXFxcW1xcXFxdfF0pL2csdj0vXFxcXHMrL2c7bGV0IE89U2suaW1wb3J0TW9kdWxlKFxcXCJ0aW1lXFxcIiwhMSwhMCksej1Tay5pbXBvcnRNb2R1bGUoXFxcImRhdGV0aW1lXFxcIiwhMSwhMCk7Y29uc3QgTD1TKHosKGU9Pih6PWUuJGQsTykpLChlPT57Tz1lLiRkfSkpO3JldHVybiBTKEwsKCgpPT57ZnVuY3Rpb24gX3N0cmZ0aW1lKGUpe3JldHVybiB0PT5lLiRzdHJmdGltZSh0KS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gX3N0cmZ0aW1lX3RpbWV0dXBsZShlLHQpe3JldHVybiBPLnN0cmZ0aW1lLnRwJGNhbGwoW25ldyBpKGUpLHRdKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCl9Y29uc3QgbD1uZXcgaShcXFwiZnJvbW9yZGluYWxcXFwiKTtmdW5jdGlvbiBfc3RydWN0X3RpbWUodCl7cmV0dXJuIE8uc3RydWN0X3RpbWUudHAkY2FsbChbbmV3IHModC5tYXAoKHQ9Pm5ldyBlKHQpKSkpXSl9ZnVuY3Rpb24gX2xvY2FsaXplZF9tb250aCgpe2NvbnN0IGU9WygpPT5cXFwiXFxcIl07Zm9yKGxldCB0PTA7dDwxMjt0Kyspe2NvbnN0IGk9bmV3IGsoMjAwMSx0KzEsMSk7ZS5wdXNoKF9zdHJmdGltZShpKSl9cmV0dXJuIGV9ZnVuY3Rpb24gX2xvY2FsaXplZF9kYXkoKXtjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8Nzt0Kyspe2NvbnN0IGk9bmV3IGsoMjAwMSwxLHQrMSk7ZS5wdXNoKF9zdHJmdGltZShpKSl9cmV0dXJuIGV9Y29uc3QgUz17X19uYW1lX186bmV3IGkoXFxcIl9zdHJwdGltZVxcXCIpfSxrPXouZGF0ZSxMPXoudGltZWRlbHRhLEU9ei50aW1lem9uZTtmdW5jdGlvbiBfZ2V0bGFuZygpe3JldHVyblt0LHRdfWNsYXNzIExvY2FsZVRpbWV7Y29uc3RydWN0b3IoKXt0aGlzLmxhbmc9X2dldGxhbmcoKSx0aGlzLl9fY2FsY193ZWVrZGF5KCksdGhpcy5fX2NhbGNfbW9udGgoKSx0aGlzLl9fY2FsY19hbV9wbSgpLHRoaXMuX19jYWxjX3RpbWV6b25lKCksdGhpcy5fX2NhbGNfZGF0ZV90aW1lKCl9X19jYWxjX3dlZWtkYXkoKXt0aGlzLmFfd2Vla2RheT1fbG9jYWxpemVkX2RheSgpLm1hcCgoZT0+ZShcXFwiJWFcXFwiKSkpLHRoaXMuZl93ZWVrZGF5PV9sb2NhbGl6ZWRfZGF5KCkubWFwKChlPT5lKFxcXCIlQVxcXCIpKSl9X19jYWxjX21vbnRoKCl7dGhpcy5hX21vbnRoPV9sb2NhbGl6ZWRfbW9udGgoKS5tYXAoKGU9PmUoXFxcIiViXFxcIikpKSx0aGlzLmZfbW9udGg9X2xvY2FsaXplZF9tb250aCgpLm1hcCgoZT0+ZShcXFwiJUJcXFwiKSkpfV9fY2FsY19hbV9wbSgpe2NvbnN0IGU9W107WzEsMjJdLmZvckVhY2goKHQ9Pntjb25zdCBpPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiVwXFxcIixfc3RydWN0X3RpbWUoWzE5OTksMywxNyx0LDQ0LDU1LDIsNzYsMF0pKTtlLnB1c2goaSl9KSksdGhpcy5hbV9wbT1lfV9fY2FsY19kYXRlX3RpbWUoKXtjb25zdCBlPV9zdHJ1Y3RfdGltZShbMTk5OSwzLDE3LDIyLDQ0LDU1LDIsNzYsMF0pLGk9W3QsdCx0XTtpWzBdPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiVjXFxcIixlKSxpWzFdPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiV4XFxcIixlKSxpWzJdPV9zdHJmdGltZV90aW1ldHVwbGUoXFxcIiVYXFxcIixlKTtjb25zdCBzPVtbXFxcIiVcXFwiLFxcXCIlJVxcXCJdLFt0aGlzLmZfd2Vla2RheVsyXSxcXFwiJUFcXFwiXSxbdGhpcy5mX21vbnRoWzNdLFxcXCIlQlxcXCJdLFt0aGlzLmFfd2Vla2RheVsyXSxcXFwiJWFcXFwiXSxbdGhpcy5hX21vbnRoWzNdLFxcXCIlYlxcXCJdLFt0aGlzLmFtX3BtWzFdLFxcXCIlcFxcXCJdLFtcXFwiMTk5OVxcXCIsXFxcIiVZXFxcIl0sW1xcXCI5OVxcXCIsXFxcIiV5XFxcIl0sW1xcXCIyMlxcXCIsXFxcIiVIXFxcIl0sW1xcXCI0NFxcXCIsXFxcIiVNXFxcIl0sW1xcXCI1NVxcXCIsXFxcIiVTXFxcIl0sW1xcXCI3NlxcXCIsXFxcIiVqXFxcIl0sW1xcXCIxN1xcXCIsXFxcIiVkXFxcIl0sW1xcXCIwM1xcXCIsXFxcIiVtXFxcIl0sW1xcXCIzXFxcIixcXFwiJW1cXFwiXSxbXFxcIjJcXFwiLFxcXCIld1xcXCJdLFtcXFwiMTBcXFwiLFxcXCIlSVxcXCJdXTtzLnB1c2goLi4udGhpcy50aW1lem9uZS5mbGF0KCkubWFwKChlPT5bZSxcXFwiJVpcXFwiXSkpKSxbWzAsXFxcIiVjXFxcIl0sWzEsXFxcIiV4XFxcIl0sWzIsXFxcIiVYXFxcIl1dLmZvckVhY2goKChbZSx0XSk9PntsZXQgbj1pW2VdO3MuZm9yRWFjaCgoKFtlLHRdKT0+e2UmJihuPW4ucmVwbGFjZShlLHQpKX0pKTtsZXQgYTthPV9zdHJmdGltZV90aW1ldHVwbGUodCxfc3RydWN0X3RpbWUoWzE5OTksMSwzLDEsMSwxLDYsMywwXSkpLmluY2x1ZGVzKFxcXCIwMFxcXCIpP1xcXCIlV1xcXCI6XFxcIiVVXFxcIixpW2VdPW4ucmVwbGFjZShcXFwiMTFcXFwiLGEpfSkpLHRoaXMuTENfZGF0ZV90aW1lPWlbMF0sdGhpcy5MQ19kYXRlPWlbMV0sdGhpcy5MQ190aW1lPWlbMl19X19jYWxjX3RpbWV6b25lKCl7dHJ5e08udHpzZXQudHAkY2FsbChbXSl9Y2F0Y2h7fXRoaXMudHpuYW1lPU8udHpuYW1lLnYubWFwKChlPT5lLnRvU3RyaW5nKCkpKSx0aGlzLmRheWxpZ2h0PXcoTy5kYXlsaWdodCk7Y29uc3QgZT1bdGhpcy50em5hbWVbMF0udG9Mb3dlckNhc2UoKSxcXFwidXRjXFxcIixcXFwiZ210XFxcIl07bGV0IHQ7dD10aGlzLmRheWxpZ2h0P1t0aGlzLnR6bmFtZVsxXS50b0xvd2VyQ2FzZSgpXTpbXSx0aGlzLnRpbWV6b25lPVtlLHRdfX1jbGFzcyBUaW1lUkV7Y29uc3RydWN0b3IoZT1udWxsKXt0aGlzLmxvY2FsZV90aW1lPWV8fG5ldyBMb2NhbGVUaW1lLE9iamVjdC5hc3NpZ24odGhpcyx7ZDpcXFwiKD88ZD4zWzAtMV18WzEtMl1cXFxcXFxcXGR8MFsxLTldfFsxLTldfCBbMS05XSlcXFwiLGY6XFxcIig/PGY+WzAtOV17MSw2fSlcXFwiLEg6XFxcIig/PEg+MlswLTNdfFswLTFdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLEk6XFxcIig/PEk+MVswLTJdfDBbMS05XXxbMS05XSlcXFwiLEc6XFxcIig/PEc+XFxcXFxcXFxkXFxcXFxcXFxkXFxcXFxcXFxkXFxcXFxcXFxkKVxcXCIsajpcXFwiKD88aj4zNlswLTZdfDNbMC01XVxcXFxcXFxcZHxbMS0yXVxcXFxcXFxcZFxcXFxcXFxcZHwwWzEtOV1cXFxcXFxcXGR8MDBbMS05XXxbMS05XVxcXFxcXFxcZHwwWzEtOV18WzEtOV0pXFxcIixtOlxcXCIoPzxtPjFbMC0yXXwwWzEtOV18WzEtOV0pXFxcIixNOlxcXCIoPzxNPlswLTVdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLFM6XFxcIig/PFM+NlswLTFdfFswLTVdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLFU6XFxcIig/PFU+NVswLTNdfFswLTRdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLHc6XFxcIig/PHc+WzAtNl0pXFxcIix1OlxcXCIoPzx1PlsxLTddKVxcXCIsVjpcXFwiKD88Vj41WzAtM118MFsxLTldfFsxLTRdXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLHk6XFxcIig/PHk+XFxcXFxcXFxkXFxcXFxcXFxkKVxcXCIsWTpcXFwiKD88WT5cXFxcXFxcXGRcXFxcXFxcXGRcXFxcXFxcXGRcXFxcXFxcXGQpXFxcIix6OlxcXCIoPzx6PlsrLV1cXFxcXFxcXGRcXFxcXFxcXGQ6P1swLTVdXFxcXFxcXFxkKDo/WzAtNV1cXFxcXFxcXGQoXFxcXFxcXFwuXFxcXFxcXFxkezEsNn0pPyk/fFopXFxcIixBOnRoaXMuX19zZXFUb1JFKHRoaXMubG9jYWxlX3RpbWUuZl93ZWVrZGF5LFxcXCJBXFxcIiksYTp0aGlzLl9fc2VxVG9SRSh0aGlzLmxvY2FsZV90aW1lLmFfd2Vla2RheSxcXFwiYVxcXCIpLEI6dGhpcy5fX3NlcVRvUkUodGhpcy5sb2NhbGVfdGltZS5mX21vbnRoLnNsaWNlKDEpLFxcXCJCXFxcIiksYjp0aGlzLl9fc2VxVG9SRSh0aGlzLmxvY2FsZV90aW1lLmFfbW9udGguc2xpY2UoMSksXFxcImJcXFwiKSxwOnRoaXMuX19zZXFUb1JFKHRoaXMubG9jYWxlX3RpbWUuYW1fcG0sXFxcInBcXFwiKSxaOnRoaXMuX19zZXFUb1JFKHRoaXMubG9jYWxlX3RpbWUudGltZXpvbmUuZmxhdCgpLFxcXCJaXFxcIiksXFxcIiVcXFwiOlxcXCIlXFxcIn0pLHRoaXMuVz10aGlzLlUucmVwbGFjZShcXFwiVVxcXCIsXFxcIldcXFwiKSx0aGlzLng9dGhpcy5wYXR0ZXJuKHRoaXMubG9jYWxlX3RpbWUuTENfZGF0ZSksdGhpcy5YPXRoaXMucGF0dGVybih0aGlzLmxvY2FsZV90aW1lLkxDX3RpbWUpLHRoaXMuYz10aGlzLnBhdHRlcm4odGhpcy5sb2NhbGVfdGltZS5MQ19kYXRlX3RpbWUpfV9fc2VxVG9SRShlLHQpe2lmKChlPWUuc2xpY2UoMCkuc29ydCgoKGUsdCk9PnQubGVuZ3RoLWUubGVuZ3RoKSkpLmV2ZXJ5KChlPT5cXFwiXFxcIj09PWUpKSlyZXR1cm5cXFwiXFxcIjtyZXR1cm5gKD88JHt0fT4ke2UubWFwKChlPT5lKSkuam9pbihcXFwifFxcXCIpfSlgfXBhdHRlcm4oZSl7bGV0IHQ9XFxcIlxcXCI7Zm9yKGU9KGU9ZS5yZXBsYWNlKGIsXFxcIlxcXFxcXFxcJDFcXFwiKSkucmVwbGFjZSh2LFxcXCJcXFxcXFxcXHMrXFxcIik7ZS5pbmNsdWRlcyhcXFwiJVxcXCIpOyl7Y29uc3QgaT1lLmluZGV4T2YoXFxcIiVcXFwiKSsxLHM9dGhpc1tlW2ldXTtpZih2b2lkIDA9PT1zKXRocm93IG5ldyBoKGVbaV0pO3Q9YCR7dH0ke2Uuc2xpY2UoMCxpLTEpfSR7c31gLGU9ZS5zbGljZShpKzEpfXJldHVybiB0K2V9Y29tcGlsZShlKXtyZXR1cm4gbmV3IFJlZ0V4cChcXFwiXlxcXCIrdGhpcy5wYXR0ZXJuKGUpLFxcXCJpXFxcIil9fWxldCBDPW5ldyBUaW1lUkU7Y29uc3QgVD01O2xldCBBPXt9O2Z1bmN0aW9uIF9zdHJwdGltZShpLHM9XFxcIiVhICViICVkICVIOiVNOiVTICVZXFxcIil7ZnVuY3Rpb24gX2NoZWNrU3RyaW5nKGUsdCl7aWYoXFxcInN0cmluZ1xcXCIhPXR5cGVvZiBlJiYhdShlKSl0aHJvdyBuZXcgbShgc3RycHRpbWUoKSBhcmd1bWVudCAke3R9IG11c3QgYmUgYSBzdHIsIG5vdCAnJHtvKGUpfSdgKX1fY2hlY2tTdHJpbmcoaSwwKSxfY2hlY2tTdHJpbmcocywxKSxpPWkudG9TdHJpbmcoKSxzPXMudG9TdHJpbmcoKTtsZXQgbixfPUMubG9jYWxlX3RpbWU7aWYoT2JqZWN0LmtleXMoQSkubGVuZ3RoPlQmJihBPXt9KSxuPUFbc10sdm9pZCAwPT09bil0cnl7bj1DLmNvbXBpbGUocyl9Y2F0Y2goVil7aWYoViBpbnN0YW5jZW9mIGgpe2xldCBlPVYuYXJncy52WzBdO3Rocm93XFxcIlxcXFxcXFxcXFxcIj09ZSYmKGU9XFxcIiVcXFwiKSxuZXcgZChgJyR7ZX0nIGlzIGEgYmFkIGRpcmVjdGl2ZSBpbiBmb3JtYXQgJyR7c30nYCl9aWYoViBpbnN0YW5jZW9mIGYpdGhyb3cgbmV3IGQoXFxcInN0cmF5ICUlIGluIGZvcm1hdCAnXFxcIitzK1xcXCInXFxcIik7dGhyb3cgVn1jb25zdCBjPWkubWF0Y2gobik7aWYobnVsbD09PWMpdGhyb3cgbmV3IGQoYHRpbWUgZGF0YSAnJHtpfScgZG9lcyBub3QgbWF0Y2ggZm9ybWF0ICcke3N9J2ApO2lmKGkubGVuZ3RoIT09Y1swXS5sZW5ndGgpdGhyb3cgbmV3IGQoYHVuY29udmVydGVkIGRhdGEgcmVtYWluczogJHtpLnNsaWNlKGNbMF0ubGVuZ3RoKX1gKTtsZXQgdz10LHA9dCxnPTEsJD0xLHk9MCxTPTAsYj0wLHY9MCx6PS0xLEw9dCxFPTAsST10LE09dCxIPXQsWT10LGo9dCxVPWMuZ3JvdXBzfHx7fTtpZihPYmplY3Qua2V5cyhVKS5mb3JFYWNoKChlPT57aWYodm9pZCAwIT09VVtlXSlpZihcXFwieVxcXCI9PT1lKXA9X2FzX2ludGVnZXIoVS55KSxwKz1wPD02OD8yZTM6MTkwMDtlbHNlIGlmKFxcXCJZXFxcIj09PWUpcD1fYXNfaW50ZWdlcihVLlkpO2Vsc2UgaWYoXFxcIkdcXFwiPT09ZSl3PV9hc19pbnRlZ2VyKFUuRyk7ZWxzZSBpZihcXFwibVxcXCI9PT1lKWc9X2FzX2ludGVnZXIoVS5tKTtlbHNlIGlmKFxcXCJCXFxcIj09PWUpZz1fLmZfbW9udGguaW5kZXhPZihVLkIudG9Mb3dlckNhc2UoKSk7ZWxzZSBpZihcXFwiYlxcXCI9PT1lKWc9Xy5hX21vbnRoLmluZGV4T2YoVS5iLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoXFxcImRcXFwiPT09ZSkkPV9hc19pbnRlZ2VyKFUuZCk7ZWxzZSBpZihcXFwiSFxcXCI9PT1lKXk9X2FzX2ludGVnZXIoVS5IKTtlbHNlIGlmKFxcXCJIXFxcIj09PWUpeT1fYXNfaW50ZWdlcihVLkgpO2Vsc2UgaWYoXFxcIklcXFwiPT09ZSl7eT1fYXNfaW50ZWdlcihVLkkpO2NvbnN0IGU9KFUucHx8XFxcIlxcXCIpLnRvTG93ZXJDYXNlKCk7W1xcXCJcXFwiLF8uYW1fcG1bMF1dLmluY2x1ZGVzKGUpPzEyPT09eSYmKHk9MCk6ZT09PV8uYW1fcG1bMV0mJjEyIT09eSYmKHkrPTEyKX1lbHNlIGlmKFxcXCJNXFxcIj09PWUpUz1fYXNfaW50ZWdlcihVLk0pO2Vsc2UgaWYoXFxcIlNcXFwiPT09ZSliPV9hc19pbnRlZ2VyKFUuUyk7ZWxzZSBpZihcXFwiZlxcXCI9PT1lKXtsZXQgZT1VLmY7ZSs9XFxcIjBcXFwiLnJlcGVhdCg2LWUubGVuZ3RoKSx2PV9hc19pbnRlZ2VyKGUpfWVsc2UgaWYoXFxcIkFcXFwiPT09ZSlZPV8uZl93ZWVrZGF5LmluZGV4T2YoVS5BLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoXFxcImFcXFwiPT09ZSlZPV8uYV93ZWVrZGF5LmluZGV4T2YoVS5hLnRvTG93ZXJDYXNlKCkpO2Vsc2UgaWYoXFxcIndcXFwiPT09ZSlZPV9hc19pbnRlZ2VyKFUudyksMD09PVk/WT02OlktPTE7ZWxzZSBpZihcXFwidVxcXCI9PT1lKVk9X2FzX2ludGVnZXIoVS51KSxZLT0xO2Vsc2UgaWYoXFxcImpcXFwiPT09ZSlqPV9hc19pbnRlZ2VyKFUuaik7ZWxzZSBpZihbXFxcIlVcXFwiLFxcXCJXXFxcIl0uaW5jbHVkZXMoZSkpTT1fYXNfaW50ZWdlcihVW2VdKSxIPVxcXCJVXFxcIj09PWU/NjowO2Vsc2UgaWYoXFxcIlZcXFwiPT09ZSlJPV9hc19pbnRlZ2VyKFUuVik7ZWxzZSBpZihcXFwielxcXCI9PT1lKXtsZXQgZT1VLno7aWYoXFxcIlpcXFwiPT09ZSlMPTA7ZWxzZXtpZihcXFwiOlxcXCI9PT1lWzNdJiYoZT1lLnNsaWNlKDAsMykrZS5zbGljZSg0KSxlLmxlbmd0aD41KSl7aWYoXFxcIjpcXFwiIT09ZVs1XSl7Y29uc3QgZT1gSW5jb25zaXN0ZW50IHVzZSBvZiA6IGluICR7VS56fWA7dGhyb3cgbmV3IGQoZSl9ZT1lLnNsaWNlKDAsNSkrZS5zbGljZSg2KX1jb25zdCB0PV9hc19pbnRlZ2VyKGUuc2xpY2UoMSwzKSksaT1fYXNfaW50ZWdlcihlLnNsaWNlKDMsNSkpLHM9X2FzX2ludGVnZXIoZS5zbGljZSg1LDcpfHwwKTtMPTM2MDAqdCs2MCppK3M7Y29uc3Qgbj1lLnNsaWNlKDgpLGE9XFxcIjBcXFwiLnJlcGVhdCg2LW4ubGVuZ3RoKTtFPV9hc19pbnRlZ2VyKG4rYSksZS5zdGFydHNXaXRoKFxcXCItXFxcIikmJihMPS1MLEU9LUUpfX1lbHNlIGlmKFxcXCJaXFxcIj09PWUpe2xldCBlPVUuWi50b0xvd2VyQ2FzZSgpLHQ9MDtmb3IobGV0IGkgb2YgXy50aW1lem9uZSl7aWYoaS5pbmNsdWRlcyhlKSl7Y29uc3QgaT1PLnR6bmFtZS52O2lmKHIoaVswXSxpWzFdLFxcXCJFcVxcXCIpJiZhKE8uZGF5bGlnaHQpJiYhW1xcXCJ1dGNcXFwiLFxcXCJnbXRcXFwiXS5pbmNsdWRlcyhlKSlicmVhazt6PXR9dCsrfX19KSkscD09PXQmJnchPT10KXtpZihJPT09dHx8WT09PXQpdGhyb3cgbmV3IGQoXFxcIklTTyB5ZWFyIGRpcmVjdGl2ZSAnJUcnIG11c3QgYmUgdXNlZCB3aXRoIHRoZSBJU08gd2VlayBkaXJlY3RpdmUgJyVWJyBhbmQgYSB3ZWVrZGF5IGRpcmVjdGl2ZSAoJyVBJywnJWEnLCAnJXcnLCBvciAnJXUnKS5cXFwiKTtpZihqIT09dCl0aHJvdyBuZXcgZChcXFwiRGF5IG9mIHRoZSB5ZWFyIGRpcmVjdGl2ZSAnJWonIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggSVNPIHllYXIgZGlyZWN0aXZlICclRycuVXNlICclWScgaW5zdGVhZC5cXFwiKX1lbHNlIGlmKE09PT10JiZJIT09dCl0aHJvdyBuZXcgZChZPT09dD9cXFwiSVNPIHdlZWsgZGlyZWN0aXZlICclVicgbXVzdCBiZSB1c2VkIHdpdGggdGhlIElTTyB5ZWFyIGRpcmVjdGl2ZSAnJUcnIGFuZCBhIHdlZWtkYXkgZGlyZWN0aXZlICgnJUEnLCAnJWEnLCAnJXcnLCBvciAnJXUnKS5cXFwiOlxcXCJJU08gd2VlayBkaXJlY3RpdmUgJyVWJyBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgeWVhciBkaXJlY3RpdmUgJyVZJy4gVXNlIHRoZSBJU08geWVhciAnJUcnIGluc3RlYWQuXFxcIik7bGV0IHg9ITE7aWYocD09PXQmJjI9PT1nJiYyOT09PSQ/KHA9MTkwNCx4PSEwKTpwPT09dCYmKHA9MTkwMCksaj09PXQmJlkhPT10KXtpZihNIT09dCl7aj1mdW5jdGlvbiBfY2FsY19qdWxpYW5fZnJvbV9VX29yX1coZSx0LGkscyl7bGV0IG49KG5ldyBrKGUsMSwxKS4kdG9PcmRpbmFsKCkrNiklNztyZXR1cm4gc3x8KG49KG4rMSklNyxpPShpKzEpJTcpLDA9PT10PzEraS1uOig3LW4pJTcrNyoodC0xKSsxK2l9KHAsTSxZLDA9PT1IKX1lbHNlIHchPT10JiZJIT09dCYmKFtwLGpdPWZ1bmN0aW9uIF9jYWxjX2p1bGlhbl9mcm9tX1YoZSx0LGkpe2xldCBzPTcqdCtpLSgobmV3IGsoZSwxLDQpLiR0b09yZGluYWwoKSU3fHw3KSszKTtyZXR1cm4gczwxJiYocys9bmV3IGsoZSwxLDEpLiR0b09yZGluYWwoKSxzLT1uZXcgayhlLT0xLDEsMSkuJHRvT3JkaW5hbCgpKSxbZSxzXX0odyxJLFkrMSkpO2lmKGohPT10JiZqPD0wKXtwLT0xO2NvbnN0IGU9ZnVuY3Rpb24gX2lzX2xlYXAoZSl7cmV0dXJuIGUlND09MCYmKGUlMTAwIT0wfHxlJTQwMD09MCl9KHApPzM2NjozNjU7ais9ZX19aWYoaj09PXQpaj1uZXcgayhwLGcsJCkuJHRvT3JkaW5hbCgpLW5ldyBrKHAsMSwxKS4kdG9PcmRpbmFsKCkrMTtlbHNle2NvbnN0IHQ9ZnVuY3Rpb24gX2Zyb21vcmRpbmFsKHQpe3JldHVybiBrLnRwJGdldGF0dHIobCkudHAkY2FsbChbbmV3IGUodCldKX0oai0xK25ldyBrKHAsMSwxKS4kdG9PcmRpbmFsKCkpO3A9dC4keWVhcixnPXQuJG1vbnRoLCQ9dC4kZGF5fVk9PT10JiYoWT0obmV3IGsocCxnLCQpLiR0b09yZGluYWwoKSs2KSU3KTtjb25zdCBSPVUuWnx8dDtyZXR1cm4geCYmKHA9MTkwMCksW1twLGcsJCx5LFMsYixZLGoseixSLExdLHYsRV19cmV0dXJuIF8oXFxcIl9zdHJwdGltZVxcXCIsUyx7X3N0cnB0aW1lX3RpbWU6eyRtZXRoOmZ1bmN0aW9uIF9zdHJwdGltZV90aW1lKHQsaT1cXFwiJWEgJWIgJWQgJUg6JU06JVMgJVlcXFwiKXtsZXQgbj1fc3RycHRpbWUodCxpKVswXS5zbGljZSgwLDExKTtyZXR1cm4gbj1uLm1hcCgoKHQsaSk9Pmk8OT9uZXcgZSh0KTpwKHQpKSksTy5zdHJ1Y3RfdGltZS50cCRjYWxsKFtuZXcgcyhuKV0pfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcImRhdGFfc3RyaW5nXFxcIixcXFwiZm9ybWF0XFxcIl0sRGVmYXVsdHM6W1xcXCIlYSAlYiAlZCAlSDolTTolUyAlWVxcXCJdfX0sX3N0cnB0aW1lX2RhdGV0aW1lOnskbWV0aDpmdW5jdGlvbiBfc3RycHRpbWVfZGF0ZXRpbWUocyxyLGw9XFxcIiVhICViICVkICVIOiVNOiVTICVZXFxcIil7Y29uc3RbbyxfLGNdPV9zdHJwdGltZShyLGwpLFttLGRdPW8uc2xpY2UoLTIpLGg9by5zbGljZSgwLDYpO2xldCBmLHU7cmV0dXJuIGgucHVzaChfKSxoLm1hcCgodD0+bmV3IGUodCkpKSxkIT09dCYmKGY9bmV3IEwoMCxkLGMpLHU9YShtKT9uZXcgRShmLG5ldyBpKG0pKTpuZXcgRShmKSxoLnB1c2godSkpLG4ocyxoKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJjbHNcXFwiLFxcXCJkYXRhX3N0cmluZ1xcXCIsXFxcImZvcm1hdFxcXCJdLERlZmF1bHRzOltcXFwiJWEgJWIgJWQgJUg6JU06JVMgJVlcXFwiXX19LF9zdHJwdGltZTp7JG1ldGgoaSxuKXtjb25zdCBhPV9zdHJwdGltZShpLG4pO3JldHVybiBhWzBdPW5ldyBzKGFbMF0ubWFwKChpPT5pPT09dD9pOm5ldyBlKGkpKSkpLGFbMV09bmV3IGUoYVsxXSksYVsyXT1uZXcgZShhWzJdKSxuZXcgcyhhKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJkYXRhX3N0cmluZ1xcXCIsXFxcImZvcm1hdFxcXCJdLERlZmF1bHRzOltcXFwiJWEgJWIgJWQgJUg6JU06JVMgJVlcXFwiXX19LF9nZXRsYW5nOnskbWV0aDooKT0+cChfZ2V0bGFuZygpKSwkZmxhZ3M6e05vQXJnczohMH19fSksUy5Mb2NhbGVUaW1lPWMoXFxcIl9zdHJwdGltZS5Mb2NhbGVUaW1lXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oKXt0aGlzLnY9bmV3IExvY2FsZVRpbWV9LHNsb3RzOnt0cCRnZXRhdHRyKGUsdCl7cmV0dXJuIHRoaXMudi5oYXNPd25Qcm9wZXJ0eShlLnRvU3RyaW5nKCkpP3AodGhpcy52W2UudG9TdHJpbmcoKV0pOiQuY2FsbCh0aGlzLGUsdCl9LHRwJHNldGF0dHIoZSx0KXtpZighdGhpcy52Lmhhc093blByb3BlcnR5KGUudG9TdHJpbmcoKSkpcmV0dXJuIHkuY2FsbCh0aGlzLGUsdCk7dGhpcy52W2UudG9TdHJpbmcoKV09Zyh0KX19fSksU30pKX1cIixcInNyYy9saWIvYWx0YWlyL3ZlZ2FfY2FsbGVyLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oZSl7dmFyIG49e19fZmlsZV9fOlxcXCIvc3JjL2xpYi92ZWdhX2NhbGxlci5qc1xcXCJ9O3JldHVybiBuLl9fcGFja2FnZV9fPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCxuLnJlbmRlcl9ncmFwaD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJyZW5kZXJfZ3JhcGhcXFwiLGFyZ3VtZW50cywxLDEpO2xldCBuPVxcXCIjXFxcIitTay5kaXZpZCtcXFwiX2dyYXBoaWNzXFxcIjt0cnl7dmVnYUVtYmVkKG4sU2suZmZpLnJlbWFwVG9KcyhlKSx7YWN0aW9uczohMH0pfWNhdGNoKGkpe3Rocm93IG5ldyBTay5idWlsdGluLkV4Y2VwdGlvbihcXFwiRXJyb3IgaW4gZ3JhcGggc3BlY2lmaWNhdGlvbiB1bmFibGUgdG8gcmVuZGVyIHRoZSBncmFwaFxcXFxuXFxcIitpLm1lc3NhZ2UpfX0pKSxufTtcIixcInNyYy9saWIvYXJyYXkuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKGUpe3ZhciBuPXt9LHQ9W1xcXCJjXFxcIixcXFwiYlxcXCIsXFxcIkJcXFwiLFxcXCJ1XFxcIixcXFwiaFxcXCIsXFxcIkhcXFwiLFxcXCJpXFxcIixcXFwiSVxcXCIsXFxcImxcXFwiLFxcXCJMXFxcIixcXFwiZlxcXCIsXFxcImRcXFwiXTtyZXR1cm4gbi5fX25hbWVfXz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcImFycmF5XFxcIiksbi5hcnJheT1Tay5taXNjZXZhbC5idWlsZENsYXNzKG4sKGZ1bmN0aW9uKGUsbil7bi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4saSl7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwzKSwtMT09dC5pbmRleE9mKFNrLmZmaS5yZW1hcFRvSnMobikpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImJhZCB0eXBlY29kZSAobXVzdCBiZSBjLCBiLCBCLCB1LCBoLCBILCBpLCBJLCBsLCBMLCBmIG9yIGQpXFxcIik7aWYoaSYmIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShpKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIml0ZXJhdGlvbiBvdmVyIG5vbi1zZXF1ZW5jZVxcXCIpO2lmKGUuJGQubXAkYXNzX3N1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5zdHIoXFxcInR5cGVjb2RlXFxcIiksbiksZS4kZC5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihcXFwiX19tb2R1bGVfX1xcXCIpLG5ldyBTay5idWlsdGluLnN0cihcXFwiYXJyYXlcXFwiKSksZS50eXBlY29kZT1uLHZvaWQgMD09PWkpZS5pbnRlcm5hbEl0ZXJhYmxlPW5ldyBTay5idWlsdGluLmxpc3Q7ZWxzZSBpZihpIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0KWUuaW50ZXJuYWxJdGVyYWJsZT1pO2Vsc2V7ZS5pbnRlcm5hbEl0ZXJhYmxlPW5ldyBTay5idWlsdGluLmxpc3Q7Zm9yKGxldCBuPVNrLmFic3RyLml0ZXIoaSksdD1uLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09dDt0PW4udHAkaXRlcm5leHQoKSlTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZS5pbnRlcm5hbEl0ZXJhYmxlLmFwcGVuZCxbZS5pbnRlcm5hbEl0ZXJhYmxlLHRdKX19KSksbi5fX3JlcHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXt2YXIgbj1Tay5mZmkucmVtYXBUb0pzKGUudHlwZWNvZGUpLHQ9XFxcIlxcXCI7cmV0dXJuIFNrLmZmaS5yZW1hcFRvSnMoZS5pbnRlcm5hbEl0ZXJhYmxlKS5sZW5ndGgmJih0PVxcXCJjXFxcIj09U2suZmZpLnJlbWFwVG9KcyhlLnR5cGVjb2RlKT9cXFwiLCAnXFxcIitTay5mZmkucmVtYXBUb0pzKGUuaW50ZXJuYWxJdGVyYWJsZSkuam9pbihcXFwiXFxcIikrXFxcIidcXFwiOlxcXCIsIFxcXCIrU2suZmZpLnJlbWFwVG9KcyhTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZS5pbnRlcm5hbEl0ZXJhYmxlLl9fcmVwcl9fLFtlLmludGVybmFsSXRlcmFibGVdKSkpLG5ldyBTay5idWlsdGluLnN0cihcXFwiYXJyYXkoJ1xcXCIrbitcXFwiJ1xcXCIrdCtcXFwiKVxcXCIpfSkpLG4uX19zdHJfXz1uLl9fcmVwcl9fLG4uX19nZXRhdHRyaWJ1dGVfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4pe3JldHVybiBlLnRwJGdldGF0dHIobil9KSksbi5hcHBlbmQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUuaW50ZXJuYWxJdGVyYWJsZS5hcHBlbmQsW2UuaW50ZXJuYWxJdGVyYWJsZSxuXSksU2suYnVpbHRpbi5ub25lLm5vbmUkfSkpLG4uZXh0ZW5kPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbil7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSwhU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKG4pKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiaXRlcmF0aW9uIG92ZXIgbm9uLXNlcXVlbmNlXFxcIik7Zm9yKGxldCB0PVNrLmFic3RyLml0ZXIobiksaT10LnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09aTtpPXQudHAkaXRlcm5leHQoKSlTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZS5pbnRlcm5hbEl0ZXJhYmxlLmFwcGVuZCxbZS5pbnRlcm5hbEl0ZXJhYmxlLGldKX0pKX0pLFxcXCJhcnJheVxcXCIsW10pLG59XCIsXCJzcmMvbGliL2NhbGVuZGFyLmpzXCI6XCJmdW5jdGlvbiAkYnVpbHRpbm1vZHVsZShlKXtjb25zdCB0PXt9LHttaXNjZXZhbDp7Y2hhaW46bn0saW1wb3J0TW9kdWxlOnJ9PVNrLGltcG9ydE9yU3VzcGVuZD1lPT5yKGUsITEsITApO3JldHVybiBuKGltcG9ydE9yU3VzcGVuZChcXFwiZGF0ZXRpbWVcXFwiKSwoZT0+KHQuZGF0ZXRpbWU9ZSxpbXBvcnRPclN1c3BlbmQoXFxcIml0ZXJ0b29sc1xcXCIpKSksKGU9Pih0Lml0ZXJSZXBlYXQ9ZS4kZC5yZXBlYXQsdC5pdGVyQ2hhaW49ZS4kZC5jaGFpbixjYWxlbmRhck1vZHVsZSh0KSkpKX1mdW5jdGlvbiBjYWxlbmRhck1vZHVsZShlKXtjb25zdHthYnN0cjp7c2V0VXBNb2R1bGVNZXRob2RzOnQsbnVtYmVyQmluT3A6bixpdGVyOnIsb2JqZWN0R2V0SXRlbTpvfSxidWlsdGluOntib29sOnMsYm9vbDp7dHJ1ZSQ6bSxmYWxzZSQ6ZH0sZnVuYzpsLGludF86aSxsaXN0OmMsbm9uZTp7bm9uZSQ6Zn0sc3RyOmgsc2xpY2U6dyx0dXBsZTp5LHJhbmdlOnUsbWF4Ol8sbWluOmcscHJvcGVydHk6ayxwcmludDpwLGVudW1lcmF0ZTokLFZhbHVlRXJyb3I6Yn0sZmZpOntyZW1hcFRvUHk6TX0sbWlzY2V2YWw6e2lzVHJ1ZTpULGl0ZXJhdG9yOkMsYXJyYXlGcm9tSXRlcmFibGU6TyxidWlsZENsYXNzOkwscmljaENvbXBhcmVCb29sOngsYXNJbmRleE9yVGhyb3c6RixvYmplY3RSZXByOkksY2FsbHNpbUFycmF5OkF9LGdsb2JhbDp2LGdsb2JhbDp7c3RyZnRpbWU6RX19PVNrLFM9bmV3IGkoMCksSD1uZXcgaSgxKSxEPW5ldyBpKDIpLE49bmV3IGkoMyksUj1uZXcgaSg2KSxqPW5ldyBpKDcpLEo9bmV3IGkoOSksUD1uZXcgaSgxMiksWT1uZXcgaSgxMyksVT1uZXcgaSgyNCksej1uZXcgaSg2MCksbGU9KGUsdCk9PngoZSx0LFxcXCJMdEVcXFwiKSxlcT0oZSx0KT0+eChlLHQsXFxcIkVxXFxcIiksbW9kPShlLHQpPT5uKGUsdCxcXFwiTW9kXFxcIiksYWRkPShlLHQpPT5uKGUsdCxcXFwiQWRkXFxcIiksc3ViPShlLHQpPT5uKGUsdCxcXFwiU3ViXFxcIiksbXVsPShlLHQpPT5uKGUsdCxcXFwiTXVsdFxcXCIpLGluYz1lPT5hZGQoZSxIKSxkZWM9ZT0+c3ViKGUsSCksbW9kNz1lPT5tb2QoZSxqKSxnZXRBPShlLHQpPT5lLnRwJGdldGF0dHIobmV3IGgodCkpLGNhbGxBPShlLHQsLi4ubik9PkEoZS50cCRnZXRhdHRyKG5ldyBoKHQpKSxuKTtmdW5jdGlvbippdGVySnMoZSl7Y29uc3QgdD1yKGUpO2xldCBuO2Zvcig7bj10LnRwJGl0ZXJuZXh0KCk7KXlpZWxkIG59ZnVuY3Rpb24gaXRlckZuKGUsdCl7cmV0dXJuIGU9cihlKSxuZXcgQygoKCk9Pntjb25zdCBuPWUudHAkaXRlcm5leHQoKTtyZXR1cm4gbiYmdChuKX0pLCEwKX1mdW5jdGlvbiBtYWtlUHlNZXRob2QoZSx0LHthcmdzOm4sbmFtZTpyLGRvYzpvLGRlZmF1bHRzOnN9KXt0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsLi4ubnx8W11dLHQuY29fZG9jc3RyaW5nPW8/bmV3IGgobyk6ZixzJiYodC4kZGVmYXVsdHM9cyksdC5jb19uYW1lPW5ldyBoKHIpLHQuY29fcXVhbG5hbWU9bmV3IGgoZStcXFwiLlxcXCIrcik7Y29uc3QgbT1uZXcgbCh0KTtyZXR1cm4gbS4kbW9kdWxlPVEuX19uYW1lX18sbX1jb25zdHtkYXRldGltZTpCLGl0ZXJSZXBlYXQ6VyxpdGVyQ2hhaW46cX09ZTtsZXR7TUlOWUVBUjpHLE1BWFlFQVI6WCxkYXRlOlZ9PUIuJGQ7Y29uc3QgSz1nZXRBKGgsXFxcImNlbnRlclxcXCIpLHB5Q2VudGVyPShlLHQpPT5BKEssW2UsdF0pLHB5UlN0cmlwPWU9Pm5ldyBoKGUudG9TdHJpbmcoKS50cmltUmlnaHQoKSk7Rz1HLnZhbHVlT2YoKSxYPVgudmFsdWVPZigpO2NvbnN0IFE9e19fbmFtZV9fOm5ldyBoKFxcXCJjYWxlbmRhclxcXCIpLF9fYWxsX186TShbXFxcIklsbGVnYWxNb250aEVycm9yXFxcIixcXFwiSWxsZWdhbFdlZWtkYXlFcnJvclxcXCIsXFxcInNldGZpcnN0d2Vla2RheVxcXCIsXFxcImZpcnN0d2Vla2RheVxcXCIsXFxcImlzbGVhcFxcXCIsXFxcImxlYXBkYXlzXFxcIixcXFwid2Vla2RheVxcXCIsXFxcIm1vbnRocmFuZ2VcXFwiLFxcXCJtb250aGNhbGVuZGFyXFxcIixcXFwicHJtb250aFxcXCIsXFxcIm1vbnRoXFxcIixcXFwicHJjYWxcXFwiLFxcXCJjYWxlbmRhclxcXCIsXFxcInRpbWVnbVxcXCIsXFxcIm1vbnRoX25hbWVcXFwiLFxcXCJtb250aF9hYmJyXFxcIixcXFwiZGF5X25hbWVcXFwiLFxcXCJkYXlfYWJiclxcXCIsXFxcIkNhbGVuZGFyXFxcIixcXFwiVGV4dENhbGVuZGFyXFxcIixcXFwiSFRNTENhbGVuZGFyXFxcIixcXFwiTG9jYWxlVGV4dENhbGVuZGFyXFxcIixcXFwiTG9jYWxlSFRNTENhbGVuZGFyXFxcIixcXFwid2Vla2hlYWRlclxcXCJdKX07ZnVuY3Rpb24gbWFrZUVycihlLHQpe3JldHVybiBMKFEsKChlLG4pPT57bi5fX2luaXRfXz1uZXcgbCgoZnVuY3Rpb24gX19pbml0X18oZSx0KXtlLiRhdHRyPXR9KSksbi5fX3N0cl9fPW5ldyBsKChmdW5jdGlvbiBfX3N0cl9fKGUpe3JldHVybiBuZXcgaCh0LnJlcGxhY2UoXFxcIiRcXFwiLEkoZS4kYXR0cikpKX0pKX0pLGUsW2JdKX1jb25zdCBaPW1ha2VFcnIoXFxcIklsbGVnYWxNb250aEVycm9yXFxcIixcXFwiYmFkIG1vbnRoICQ7IG11c3QgYmUgMS0xMlxcXCIpLGVlPW1ha2VFcnIoXFxcIklsbGVnYWxXZWVrZGF5RXJyb3JcXFwiLFxcXCJiYWQgd2Vla2RheSBudW1iZXIgJDsgbXVzdCBiZSAwIChNb25kYXkpIHRvIDYgKFN1bmRheSlcXFwiKSx0ZT0xLGFlPTIsbmU9WzAsMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIG1rTG9jYWxpemVkQ2xzKGUsdCl7dC5fX2luaXRfXz1uZXcgbCgoZnVuY3Rpb24gX19pbml0X18oZSx0KXtlLmZvcm1hdD10fSkpLHQuX19nZXRpdGVtX189bmV3IGwoKGZ1bmN0aW9uIF9fZ2V0aXRlbV9fKHQsbil7Y29uc3Qgcj1vKGUsbik7aWYobiBpbnN0YW5jZW9mIHcpe2NvbnN0IGU9W107Zm9yKGNvbnN0IG4gb2Ygci52YWx1ZU9mKCkpZS5wdXNoKEEobixbdC5mb3JtYXRdKSk7cmV0dXJuIG5ldyBjKGUpfXJldHVybiBBKHIsW3QuZm9ybWF0XSl9KSk7Y29uc3Qgbj1uZXcgaShlLnZhbHVlT2YoKS5sZW5ndGgpO3QuX19sZW5fXz1uZXcgbCgoZnVuY3Rpb24gX19sZW5fXyhlKXtyZXR1cm4gbn0pKX1jb25zdCByZT1uZXcgaChcXFwic3RyZnRpbWVcXFwiKSxvZT1MKFEsKChlLHQpPT57bGV0IG49W25ldyBsKChlPT5oLiRlbXB0eSkpXTtmb3IobGV0IHI9MDtyPDEyO3IrKyl7Y29uc3QgZT1uZXcgVigyMDAxLHIrMSwxKTtuLnB1c2goZS50cCRnZXRhdHRyKHJlKSl9bj1uZXcgYyhuKSx0Ll9tb250aHM9bixta0xvY2FsaXplZENscyhuLHQpfSksXFxcIl9sb2NhbGl6ZWRfbW9udGhcXFwiKSxzZT1MKFEsKChlLHQpPT57bGV0IG49W107Zm9yKGxldCByPTA7cjw3O3IrKyl7Y29uc3QgZT1uZXcgVigyMDAxLDEscisxKTtuLnB1c2goZS50cCRnZXRhdHRyKHJlKSl9bj1uZXcgYyhuKSx0Ll9kYXlzPW4sbWtMb2NhbGl6ZWRDbHMobix0KX0pLFxcXCJfbG9jYWxpemVkX2RheVxcXCIpLG1lPUEoc2UsW25ldyBoKFxcXCIlQVxcXCIpXSksZGU9QShzZSxbbmV3IGgoXFxcIiVhXFxcIildKSxpZT1BKG9lLFtuZXcgaChcXFwiJUJcXFwiKV0pLGNlPUEob2UsW25ldyBoKFxcXCIlYlxcXCIpXSksW2ZlLGhlLHdlLHllLHVlLF9lLGdlXT1bMCwxLDIsMyw0LDUsNl07ZnVuY3Rpb24gaXNsZWFwKGUpe3JldHVybihlPUYoZSkpJTQ9PTAmJihlJTEwMCE9MHx8ZSU0MDA9PTApfWZ1bmN0aW9uIHdlZWtkYXkoZSx0LG4pe2U9RihlKSxHPD1lJiZlPD1YfHwoZT0yZTMrZSU0MDApO2NvbnN0IHI9QShWLFtuZXcgaShlKSx0LG5dKTtyZXR1cm4gY2FsbEEoVixcXFwid2Vla2RheVxcXCIscil9ZnVuY3Rpb24gbW9udGhyYW5nZShlLHQpe2lmKCFsZShILHQpfHwhbGUodCxQKSl0aHJvdyBBKFosW3RdKTtjb25zdCBuPXdlZWtkYXkoZSx0LEgpO3Q9Rih0KTtjb25zdCByPW5lW3RdK051bWJlcih0PT09YWUmJmlzbGVhcChlKSk7cmV0dXJuW24sbmV3IGkocildfWZ1bmN0aW9uIGl0ZXJ3ZWVrZGF5cyhlKXtyZXR1cm4gaXRlckZuKEEodSxbZS5md2QsYWRkKGUuZndkLGopXSksbW9kNyl9ZnVuY3Rpb24gaXRlcm1vbnRoZGF0ZXMoZSx0LG4pe3JldHVybiBpdGVyRm4oaXRlcm1vbnRoZGF5czMoZSx0LG4pLChlPT5BKFYsZS52YWx1ZU9mKCkpKSl9ZnVuY3Rpb24gaXRlcm1vbnRoZGF5cyhlLHQsbil7Y29uc3RbcixvXT1tb250aHJhbmdlKHQsbikscz1tb2Q3KHN1YihyLGUuZndkKSksbT1BKFcsW1Msc10pLGQ9QSh1LFtILGluYyhvKV0pLGw9bW9kNyhzdWIoZS5md2QsYWRkKHIsbykpKSxpPUEoVyxbUyxsXSk7cmV0dXJuIEEocSxbbSxkLGldKX1mdW5jdGlvbiBpdGVybW9udGhkYXlzMihlLHQsbil7cmV0dXJuIGl0ZXJGbihBKCQsW2l0ZXJtb250aGRheXMoZSx0LG4pLGUuZndkXSksKGU9Pntjb25zdFt0LG5dPWUudmFsdWVPZigpO3JldHVybiBuZXcgeShbbixtb2Q3KHQpXSl9KSl9ZnVuY3Rpb24gaXRlcm1vbnRoZGF5czMoZSx0LG4pe2NvbnN0IHltZEl0ZXI9KGUsdCxuKT0+aXRlckZuKG4sKG49Pm5ldyB5KFtlLHQsbl0pKSksW3Isb109bW9udGhyYW5nZSh0LG4pLHM9bW9kNyhzdWIocixlLmZ3ZCkpLG09bW9kNyhzdWIoZS5md2QsYWRkKHIsbykpKSxbZCxsXT1mdW5jdGlvbiBfcHJldm1vbnRoKGUsdCl7cmV0dXJuIGVxKHQsSCk/W2RlYyhlKSxQXTpbZSxkZWModCldfSh0LG4pLGM9aW5jKGZ1bmN0aW9uIF9tb250aGxlbihlLHQpe3JldHVybiB0PUYodCksbmV3IGkobmVbdF0rTnVtYmVyKHQ9PT1hZSYmaXNsZWFwKGUpKSl9KGQsbCkpLGY9QSh1LFtzdWIoYyxzKSxjXSksaD1BKHUsW0gsaW5jKG8pXSksW3csX109ZnVuY3Rpb24gX25leHRtb250aChlLHQpe3JldHVybiBlcSh0LFApP1tpbmMoZSksSF06W2UsaW5jKHQpXX0odCxuKSxnPUEodSxbSCxpbmMobSldKTtyZXR1cm4gQShxLFt5bWRJdGVyKGQsbCxmKSx5bWRJdGVyKHQsbixoKSx5bWRJdGVyKHcsXyxnKV0pfWZ1bmN0aW9uIGl0ZXJtb250aGRheXM0KGUsdCxuKXtjb25zdCByPWl0ZXJtb250aGRheXMzKGUsdCxuKTtsZXQgbz0wO3JldHVybiBpdGVyRm4ociwodD0+bmV3IHkoWy4uLnQudmFsdWVPZigpLG1vZDcoYWRkKGUuZndkLG5ldyBpKG8rKykpKV0pKSl9ZnVuY3Rpb24gX21vbnRoSXRlcihlLHQsbixyKXtjb25zdCBvPU8oZSh0LG4scikpLHM9W107Zm9yKGxldCBtPTA7bTxvLmxlbmd0aDttKz03KXMucHVzaChuZXcgYyhvLnNsaWNlKG0sbSs3KSkpO3JldHVybiBuZXcgYyhzKX1mdW5jdGlvbiBtb250aGRhdGVzY2FsZW5kYXIoZSx0LG4pe3JldHVybiBfbW9udGhJdGVyKGl0ZXJtb250aGRhdGVzLGUsdCxuKX1mdW5jdGlvbiBtb250aGRheXMyY2FsZW5kYXIoZSx0LG4pe3JldHVybiBfbW9udGhJdGVyKGl0ZXJtb250aGRheXMyLGUsdCxuKX1mdW5jdGlvbiBtb250aGRheXNjYWxlbmRhcihlLHQsbil7cmV0dXJuIF9tb250aEl0ZXIoaXRlcm1vbnRoZGF5cyxlLHQsbil9ZnVuY3Rpb24gX3llYXJJdGVyKGUsdCxuLHIpe3I9RihyKTtjb25zdCBvPVtdO2ZvcihsZXQgbT10ZTttPHRlKzEyO20rKylvLnB1c2goZSh0LG4sbmV3IGkobSkpKTtjb25zdCBzPVtdO2ZvcihsZXQgbT0wO208by5sZW5ndGg7bSs9cilzLnB1c2gobmV3IGMoby5zbGljZShtLG0rcikpKTtyZXR1cm4gbmV3IGMocyl9ZnVuY3Rpb24geWVhcmRhdGVzY2FsZW5kYXIoZSx0LG4pe3JldHVybiBfeWVhckl0ZXIobW9udGhkYXRlc2NhbGVuZGFyLGUsdCxuKX1mdW5jdGlvbiB5ZWFyZGF5czJjYWxlbmRhcihlLHQsbil7cmV0dXJuIF95ZWFySXRlcihtb250aGRheXMyY2FsZW5kYXIsZSx0LG4pfWZ1bmN0aW9uIHllYXJkYXlzY2FsZW5kYXIoZSx0LG4pe3JldHVybiBfeWVhckl0ZXIobW9udGhkYXlzY2FsZW5kYXIsZSx0LG4pfWNvbnN0IGtlPUwoUSwoKGUsdCk9Pntjb25zdCBuPW1ha2VQeU1ldGhvZC5iaW5kKG51bGwsXFxcIkNhbGVuZGFyXFxcIikscj1bXFxcImZpcnN0d2Vla2RheVxcXCJdLG89W1xcXCJ5ZWFyXFxcIixcXFwibW9udGhcXFwiXSxzPVtcXFwieWVhclxcXCIsXFxcIndpZHRoXFxcIl0sbT17X19pbml0X186bigoZnVuY3Rpb24gX19pbml0X18oZSx0KXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXFxcImZ3ZFxcXCIse2dldCgpe3JldHVybiBtb2Q3KHRoaXMuX2Z3ZCl9LHNldChlKXtyZXR1cm4gdGhpcy5fZndkPWUsITB9fSksZS5md2Q9dCxmfSkse25hbWU6XFxcIl9faW5pdF9fXFxcIixhcmdzOnIsZGVmYXVsdHM6W1NdfSksZ2V0Zmlyc3R3ZWVrZGF5Om4oKGZ1bmN0aW9uIGdldGZpcnN0d2Vla2RheShlKXtyZXR1cm4gZS5md2R9KSx7bmFtZTpcXFwiZ2V0Zmlyc3R3ZWVrZGF5XFxcIn0pLHNldGZpcnN0d2Vla2RheTpuKChmdW5jdGlvbiBzZXRmaXJzdHdlZWtkYXkoZSx0KXtyZXR1cm4gZS5md2Q9dCxmfSkse25hbWU6XFxcInNldGZpcnN0d2Vla2RheVxcXCIsYXJnczpyfSksaXRlcndlZWtkYXlzOm4oaXRlcndlZWtkYXlzLHtuYW1lOlxcXCJpdGVyd2Vla2RheXNcXFwifSksaXRlcm1vbnRoZGF0ZXM6bihpdGVybW9udGhkYXRlcyx7bmFtZTpcXFwiaXRlcm1vbnRoZGF0ZXNcXFwiLGFyZ3M6b30pLGl0ZXJtb250aGRheXM6bihpdGVybW9udGhkYXlzLHtuYW1lOlxcXCJpdGVybW9udGhkYXlzXFxcIixhcmdzOm99KSxpdGVybW9udGhkYXlzMjpuKGl0ZXJtb250aGRheXMyLHtuYW1lOlxcXCJpdGVybW9udGhkYXlzMlxcXCIsYXJnczpvfSksaXRlcm1vbnRoZGF5czM6bihpdGVybW9udGhkYXlzMyx7bmFtZTpcXFwiaXRlcm1vbnRoZGF5czNcXFwiLGFyZ3M6b30pLGl0ZXJtb250aGRheXM0Om4oaXRlcm1vbnRoZGF5czQse25hbWU6XFxcIml0ZXJtb250aGRheXM0XFxcIixhcmdzOm99KSxtb250aGRhdGVzY2FsZW5kYXI6bihtb250aGRhdGVzY2FsZW5kYXIse25hbWU6XFxcIm1vbnRoZGF0ZXNjYWxlbmRhclxcXCIsYXJnczpvfSksbW9udGhkYXlzMmNhbGVuZGFyOm4obW9udGhkYXlzMmNhbGVuZGFyLHtuYW1lOlxcXCJtb250aGRheXMyY2FsZW5kYXJcXFwiLGFyZ3M6b30pLG1vbnRoZGF5c2NhbGVuZGFyOm4obW9udGhkYXlzY2FsZW5kYXIse25hbWU6XFxcIm1vbnRoZGF5c2NhbGVuZGFyXFxcIixhcmdzOm99KSx5ZWFyZGF0ZXNjYWxlbmRhcjpuKHllYXJkYXRlc2NhbGVuZGFyLHtuYW1lOlxcXCJ5ZWFyZGF0ZXNjYWxlbmRhclxcXCIsYXJnczpzLGRlZmF1bHRzOltOXX0pLHllYXJkYXlzMmNhbGVuZGFyOm4oeWVhcmRheXMyY2FsZW5kYXIse25hbWU6XFxcInllYXJkYXlzMmNhbGVuZGFyXFxcIixhcmdzOnMsZGVmYXVsdHM6W05dfSkseWVhcmRheXNjYWxlbmRhcjpuKHllYXJkYXlzY2FsZW5kYXIse25hbWU6XFxcInllYXJkYXlzY2FsZW5kYXJcXFwiLGFyZ3M6cyxkZWZhdWx0czpbTl19KX07bS5maXJzdHdlZWtkYXk9bmV3IGsobS5nZXRmaXJzdHdlZWtkYXksbS5zZXRmaXJzdHdlZWtkYXkpLE9iamVjdC5hc3NpZ24odCxtKX0pLFxcXCJDYWxlbmRhclxcXCIpO2Z1bmN0aW9uIGRvVGV4dEZvcm1hdHdlZWtkYXkoZSx0LG4pe2xldCByO3JldHVybiByPXgobixKLFxcXCJHdEVcXFwiKT9tZTpkZSxweUNlbnRlcihvKG8ocix0KSxuZXcgdyhmLG4pKSxuKX1mdW5jdGlvbiBkb1RleHRGb3JtYXRtb250aG5hbWUoZSx0LG4scixzPSEwKXtsZXQgbT1vKGllLG4pO3JldHVybiBUKHMpJiYobT1tb2QobmV3IGgoXFxcIiVzICVyXFxcIiksbmV3IHkoW20sdF0pKSkscHlDZW50ZXIobSxyKX1jb25zdCBwZT1MKFEsKChlLHQpPT57Y29uc3QgdHh0UHJpbnQ9ZT0+cChbZV0sW1xcXCJlbmRcXFwiLGguJGVtcHR5XSk7Y29uc3Qgbj1kb1RleHRGb3JtYXR3ZWVrZGF5O2Z1bmN0aW9uIGZvcm1hdHdlZWtoZWFkZXIoZSx0KXtjb25zdCBuPVtdO2Zvcihjb25zdCByIG9mIGl0ZXJKcyhpdGVyd2Vla2RheXMoZSkpKW4ucHVzaChjYWxsQShlLFxcXCJmb3JtYXR3ZWVrZGF5XFxcIixyLHQpLnRvU3RyaW5nKCkpO3JldHVybiBuZXcgaChuLmpvaW4oXFxcIiBcXFwiKSl9Y29uc3Qgcj1kb1RleHRGb3JtYXRtb250aG5hbWU7Y29uc3Qgbz1tYWtlUHlNZXRob2QuYmluZChudWxsLFxcXCJUZXh0Q2FsZW5kYXJcXFwiKSxzPXtwcndlZWs6bygoZnVuY3Rpb24gcHJ3ZWVrKGUsdCxuKXt0eHRQcmludChjYWxsQShlLFxcXCJmb3JtYXR3ZWVrXFxcIix0LG4pKX0pLHtuYW1lOlxcXCJwcndlZWtcXFwiLGFyZ3M6W1xcXCJ0aGV3ZWVrXFxcIixcXFwid2lkdGhcXFwiXX0pLGZvcm1hdGRheTpvKChmdW5jdGlvbiBmb3JtYXRkYXkoZSx0LG4scil7bGV0IG87cmV0dXJuIG89ZXEodCxTKT9oLiRlbXB0eTptb2QobmV3IGgoXFxcIiUyaVxcXCIpLHQpLHB5Q2VudGVyKG8scil9KSx7bmFtZTpcXFwiZm9ybWF0ZGF5XFxcIixhcmdzOltcXFwiZGF5XFxcIixcXFwid2Vla2RheVxcXCIsXFxcIndpZHRoXFxcIl19KSxmb3JtYXR3ZWVrOm8oKGZ1bmN0aW9uIGZvcm1hdHdlZWsoZSx0LG4pe2NvbnN0IHI9W107Zm9yKGNvbnN0IG8gb2YgaXRlckpzKHQpKXtjb25zdFt0LHNdPW8udmFsdWVPZigpO3IucHVzaChjYWxsQShlLFxcXCJmb3JtYXRkYXlcXFwiLHQscyxuKS50b1N0cmluZygpKX1yZXR1cm4gbmV3IGgoci5qb2luKFxcXCIgXFxcIikpfSkse25hbWU6XFxcImZvcm1hdHdlZWtcXFwiLGFyZ3M6W1xcXCJ0aGV3ZWVrXFxcIixcXFwid2lkdGhcXFwiXX0pLGZvcm1hdHdlZWtkYXk6byhuLHtuYW1lOlxcXCJmb3JtYXR3ZWVrZGF5XFxcIixhcmdzOltcXFwiZGF5XFxcIixcXFwid2lkdGhcXFwiXX0pLGZvcm1hdHdlZWtoZWFkZXI6byhmb3JtYXR3ZWVraGVhZGVyLHtuYW1lOlxcXCJmb3JtYXR3ZWVraGVhZGVyXFxcIixhcmdzOltcXFwid2lkdGhcXFwiXX0pLGZvcm1hdG1vbnRobmFtZTpvKHIse25hbWU6XFxcImZvcm1hdG1vbnRobmFtZVxcXCIsYXJnczpbXFxcInRoZXllYXJcXFwiLFxcXCJ0aGVtb250aFxcXCIsXFxcIndpZHRoXFxcIixcXFwid2l0aHllYXJcXFwiXSxkZWZhdWx0czpbbV19KSxwcm1vbnRoOm8oKGZ1bmN0aW9uIHBybW9udGgoZSx0LG4scixvKXt0eHRQcmludChjYWxsQShlLFxcXCJmb3JtYXRtb250aFxcXCIsdCxuLHIsbykpfSkse25hbWU6XFxcInBybW9udGhcXFwiLGFyZ3M6W1xcXCJ0aGV5ZWFyXFxcIixcXFwidGhlbW9udGhcXFwiLFxcXCJ3XFxcIixcXFwibFxcXCJdLGRlZmF1bHRzOltTLFNdfSksZm9ybWF0bW9udGg6bygoZnVuY3Rpb24gZm9ybWF0bW9udGgoZSx0LG4scixvKXtjb25zdCBhZGROZXdMaW5lcz1lPT5uZXcgaChlK1xcXCJcXFxcblxcXCIucmVwZWF0KG8udmFsdWVPZigpKSk7cj1fKFtELHJdKSxvPV8oW0gsb10pO2xldCBzPWNhbGxBKGUsXFxcImZvcm1hdG1vbnRobmFtZVxcXCIsdCxuLGRlYyhtdWwoaixpbmMocikpKSwhMCk7cz1weVJTdHJpcChzKSxzPWFkZE5ld0xpbmVzKHMpLHM9YWRkKHMscHlSU3RyaXAoY2FsbEEoZSxcXFwiZm9ybWF0d2Vla2hlYWRlclxcXCIscikpKSxzPWFkZE5ld0xpbmVzKHMpO2Zvcihjb25zdCBtIG9mIGl0ZXJKcyhtb250aGRheXMyY2FsZW5kYXIoZSx0LG4pKSlzPWFkZChzLHB5UlN0cmlwKGNhbGxBKGUsXFxcImZvcm1hdHdlZWtcXFwiLG0scikpKSxzPWFkZE5ld0xpbmVzKHMpO3JldHVybiBzfSkse25hbWU6XFxcImZvcm1hdG1vbnRoXFxcIixhcmdzOltcXFwidGh5ZWFyXFxcIixcXFwidGhlbW9udGhcXFwiLFxcXCJ3XFxcIixcXFwibFxcXCJdLGRlZmF1bHRzOltTLFNdfSksZm9ybWF0eWVhcjpvKChmdW5jdGlvbiBmb3JtYXR5ZWFyKGUsdCxuLHIsbyxzKXtuPV8oW0Qsbl0pLHI9XyhbSCxyXSksbz1fKFtELG9dKTtjb25zdCBtPWRlYyhtdWwoaW5jKG4pLGopKTtsZXQgZD1cXFwiXFxcIjtjb25zdCBhPWU9PmQrPWU7YShweVJTdHJpcChweUNlbnRlcih0LiRyKCksYWRkKG11bChtLHMpLG11bChvLGRlYyhzKSkpKSkpLGEoXFxcIlxcXFxuXFxcIi5yZXBlYXQocikpO2NvbnN0IGw9Zm9ybWF0d2Vla2hlYWRlcihlLG4pO2xldCBmPTA7Zm9yKGNvbnN0IHcgb2YgaXRlckpzKHllYXJkYXlzMmNhbGVuZGFyKGUsdCxzKSkpe2NvbnN0IGQ9bmV3IGkoZikseT1pbmMobXVsKHMsZCkpLF89ZyhbaW5jKG11bChzLGluYyhkKSkpLFldKSxrPUEodSxbeSxfXSk7YShcXFwiXFxcXG5cXFwiLnJlcGVhdChyKSk7Y29uc3QgcD1pdGVyRm4oaywobj0+Y2FsbEEoZSxcXFwiZm9ybWF0bW9udGhuYW1lXFxcIix0LG4sbSwhMSkpKTthKHB5UlN0cmlwKGZvcm1hdHN0cmluZyhwLG0sbykpKSxhKFxcXCJcXFxcblxcXCIucmVwZWF0KHIpKTtjb25zdCAkPWl0ZXJGbihrLChlPT5sKSk7YShweVJTdHJpcChmb3JtYXRzdHJpbmcoJCxtLG8pKSksYShcXFwiXFxcXG5cXFwiLnJlcGVhdChyKSk7Y29uc3QgYj1NYXRoLm1heCguLi53LnZhbHVlT2YoKS5tYXAoKGU9PmUudmFsdWVPZigpLmxlbmd0aCkpKTtmb3IobGV0IHQ9MDt0PGI7dCsrKXtjb25zdCBzPVtdO2ZvcihsZXQgciBvZiB3LnZhbHVlT2YoKSlyPXIudmFsdWVPZigpLHQ+PXIubGVuZ3RoP3MucHVzaChoLiRlbXB0eSk6cy5wdXNoKGNhbGxBKGUsXFxcImZvcm1hdHdlZWtcXFwiLHJbdF0sbikpO2EocHlSU3RyaXAoZm9ybWF0c3RyaW5nKG5ldyBjKHMpLG0sbykpKSxhKFxcXCJcXFxcblxcXCIucmVwZWF0KHIpKX1mKyt9cmV0dXJuIG5ldyBoKGQpfSkse25hbWU6XFxcImZvcm1hdHllYXJcXFwiLGFyZ3M6W1xcXCJ0aGV5ZWFyXFxcIixcXFwid1xcXCIsXFxcImxcXFwiLFxcXCJjXFxcIixcXFwibVxcXCJdLGRlZmF1bHRzOltELEgsUixOXX0pLHByeWVhcjpvKChmdW5jdGlvbiBwcnllYXIoZSx0LG4scixvLHMpe3R4dFByaW50KGNhbGxBKGUsXFxcImZvcm1hdHllYXJcXFwiLHQsbixyLG8scykpfSkse25hbWU6XFxcInByeWVhclxcXCIsYXJnczpbXFxcInRoZXllYXJcXFwiLFxcXCJ3XFxcIixcXFwibFxcXCIsXFxcImNcXFwiLFxcXCJtXFxcIl0sZGVmYXVsdHM6W1MsUyxSLE5dfSl9O09iamVjdC5hc3NpZ24odCxzKX0pLFxcXCJUZXh0Q2FsZW5kYXJcXFwiLFtrZV0pO2Z1bmN0aW9uIGRvSHRtbEZvcm1hdHdlZWtkYXkoZSx0KXtyZXR1cm4gbmV3IGgoYDx0aCBjbGFzcz1cXFwiJHtvKGdldEEoZSxcXFwiY3NzY2xhc3Nlc193ZWVrZGF5X2hlYWRcXFwiKSx0KX1cXFwiPiR7byhkZSx0KX08L3RoPmApfWZ1bmN0aW9uIGRvSHRtbEZvcm1hdG1vbnRobmFtZShlLHQsbixyPSEwKXtsZXQgcz1cXFwiXFxcIitvKGllLG4pO3JldHVybiBUKHIpJiYocys9XFxcIiBcXFwiK3QpLG5ldyBoKGA8dHI+PHRoIGNvbHNwYW49XFxcIjdcXFwiIGNsYXNzPVxcXCIke2dldEEoZSxcXFwiY3NzY2xhc3NfbW9udGhfaGVhZFxcXCIpfVxcXCI+JHtzfTwvdGg+PC90cj5gKX1jb25zdCAkZT1MKFEsKChlLHQpPT57Y29uc3Qgbj1NKFtcXFwibW9uXFxcIixcXFwidHVlXFxcIixcXFwid2VkXFxcIixcXFwidGh1XFxcIixcXFwiZnJpXFxcIixcXFwic2F0XFxcIixcXFwic3VuXFxcIl0pLHI9bixzPW5ldyBoKFxcXCJub2RheVxcXCIpLGQ9bmV3IGgoXFxcIm1vbnRoXFxcIiksbD1kLGM9bmV3IGgoXFxcInllYXJcXFwiKSx3PWMsdT1uZXcgaCgnPHRkIGNsYXNzPVxcXCIlc1xcXCI+Jm5ic3A7PC90ZD4nKSxnPW5ldyBoKCc8dGQgY2xhc3M9XFxcIiVzXFxcIj4lZDwvdGQ+Jyk7Y29uc3Qgaz1kb0h0bWxGb3JtYXR3ZWVrZGF5O2Z1bmN0aW9uIGZvcm1hdHdlZWtoZWFkZXIoZSl7bGV0IHQ9XFxcIlxcXCI7Zm9yKGNvbnN0IG4gb2YgaXRlckpzKGl0ZXJ3ZWVrZGF5cyhlKSkpdCs9Y2FsbEEoZSxcXFwiZm9ybWF0d2Vla2RheVxcXCIsbik7cmV0dXJuIG5ldyBoKGA8dHI+JHt0fTwvdHI+YCl9Y29uc3QgcD1kb0h0bWxGb3JtYXRtb250aG5hbWU7Y29uc3QgJD1tYWtlUHlNZXRob2QuYmluZChudWxsLFxcXCJIVE1MQ2FsZW5kYXJcXFwiKSxiPXtmb3JtYXRkYXk6JCgoZnVuY3Rpb24gZm9ybWF0ZGF5KGUsdCxuKXtyZXR1cm4gZXEodCxTKT9tb2QodSxnZXRBKGUsXFxcImNzc2NsYXNzX25vZGF5XFxcIikpOm1vZChnLG5ldyB5KFtvKGdldEEoZSxcXFwiY3NzY2xhc3Nlc1xcXCIpLG4pLHRdKSl9KSx7bmFtZTpcXFwiZm9ybWF0ZGF5XFxcIixhcmdzOltcXFwiZGF5XFxcIixcXFwid2Vla2RheVxcXCJdfSksZm9ybWF0d2VlazokKChmdW5jdGlvbiBmb3JtYXR3ZWVrKGUsdCl7bGV0IG49XFxcIlxcXCI7Zm9yKGNvbnN0IHIgb2YgaXRlckpzKHQpKXtjb25zdFt0LG9dPXIudmFsdWVPZigpO24rPWNhbGxBKGUsXFxcImZvcm1hdGRheVxcXCIsdCxvKX1yZXR1cm4gbmV3IGgoYDx0cj4ke259PC90cj5gKX0pLHtuYW1lOlxcXCJmb3JtYXR3ZWVrXFxcIixhcmdzOltcXFwidGhld2Vla1xcXCJdfSksZm9ybWF0d2Vla2RheTokKGsse25hbWU6XFxcImZvcm1hdHdlZWtkYXlcXFwiLGFyZ3M6W1xcXCJkYXlcXFwiXX0pLGZvcm1hdHdlZWtoZWFkZXI6JChmb3JtYXR3ZWVraGVhZGVyLHtuYW1lOlxcXCJmb3JtYXR3ZWVraGVhZGVyXFxcIn0pLGZvcm1hdG1vbnRobmFtZTokKHAse25hbWU6XFxcImZvcm1hdG1vbnRobmFtZVxcXCIsYXJnczpbXFxcInRoZXllYXJcXFwiLFxcXCJ0aGVtb250aFxcXCIsXFxcIndpdGh5ZWFyXFxcIl0sZGVmYXVsdHM6W21dfSksZm9ybWF0bW9udGg6JCgoZnVuY3Rpb24gZm9ybWF0bW9udGgoZSx0LG4scj0hMCl7bGV0IG89XFxcIlxcXCI7Y29uc3QgYT1lPT5vKz1lK1xcXCJcXFxcblxcXCI7YShgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiBjbGFzcz1cXFwiJHtnZXRBKGUsXFxcImNzc2NsYXNzX21vbnRoXFxcIil9XFxcIj5gKSxhKGNhbGxBKGUsXFxcImZvcm1hdG1vbnRobmFtZVxcXCIsdCxuLHIpKSxhKGZvcm1hdHdlZWtoZWFkZXIoZSkpO2Zvcihjb25zdCBzIG9mIGl0ZXJKcyhtb250aGRheXMyY2FsZW5kYXIoZSx0LG4pKSlhKGNhbGxBKGUsXFxcImZvcm1hdHdlZWtcXFwiLHMpKTtyZXR1cm4gYShcXFwiPC90YWJsZT5cXFwiKSxuZXcgaChvKX0pLHtuYW1lOlxcXCJmb3JtYXRtb250aFxcXCIsYXJnczpbXFxcInRoeWVhclxcXCIsXFxcInRoZW1vbnRoXFxcIixcXFwid2l0aHllYXJcXFwiXSxkZWZhdWx0czpbbV19KSxmb3JtYXR5ZWFyOiQoKGZ1bmN0aW9uIGZvcm1hdHllYXIoZSx0LG4pe2xldCByPVxcXCJcXFwiO2NvbnN0IGE9ZT0+cis9ZTtuPV8oW24sSF0pLnZhbHVlT2YoKSxhKGA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIGNsYXNzPVxcXCIke2dldEEoZSxcXFwiY3NzY2xhc3NfeWVhclxcXCIpfVxcXCI+YCksYShcXFwiXFxcXG5cXFwiKSxhKGA8dHI+PHRoIGNvbHNwYW49XFxcIiR7bn1cXFwiIGNsYXNzPVxcXCIke2dldEEoZSxcXFwiY3NzY2xhc3NfeWVhcl9oZWFkXFxcIil9XFxcIj4ke3R9PC90aD48L3RyPmApO2ZvcihsZXQgbz10ZTtvPHRlKzEyO28rPW4pe2EoXFxcIjx0cj5cXFwiKTtjb25zdCByPU1hdGgubWluKG8rbiwxMyk7Zm9yKGxldCBuPW87bjxyO24rKylhKFxcXCI8dGQ+XFxcIiksYShjYWxsQShlLFxcXCJmb3JtYXRtb250aFxcXCIsdCxuZXcgaShuKSwhMSkpLGEoXFxcIjwvdGQ+XFxcIik7YShcXFwiPC90cj5cXFwiKX1yZXR1cm4gYShcXFwiPC90YWJsZT5cXFwiKSxuZXcgaChyKX0pLHtuYW1lOlxcXCJmb3JtYXR5ZWFyXFxcIixhcmdzOltcXFwidGhleWVhclxcXCIsXFxcIndpZHRoXFxcIl0sZGVmYXVsdHM6W05dfSksZm9ybWF0eWVhcnBhZ2U6JCgoZnVuY3Rpb24gZm9ybWF0eWVhcnBhZ2UoZSx0LG49MyxyPVxcXCJjYWxlbmRhci5jc3NcXFwiLG89bnVsbCl7bnVsbCE9PW8mJm8hPT1mfHwobz1uZXcgaChcXFwidXRmLThcXFwiKSk7bGV0IHM9XFxcIlxcXCI7Y29uc3QgYT1lPT5zKz1lO3JldHVybiBhKGA8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCIke299XFxcIj8+XFxcXG5gKSxhKCc8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXFxcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBTdHJpY3QvL0VOXFxcIiBcXFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtc3RyaWN0LmR0ZFxcXCI+XFxcXG4nKSxhKFxcXCI8aHRtbD5cXFxcblxcXCIpLGEoXFxcIjxoZWFkPlxcXFxuXFxcIiksYShgPG1ldGEgaHR0cC1lcXVpdj1cXFwiQ29udGVudC1UeXBlXFxcIiBjb250ZW50PVxcXCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9JHtvfVxcXCIgLz5cXFxcbmApLHIhPT1mJiZhKGA8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIHR5cGU9XFxcInRleHQvY3NzXFxcIiBocmVmPVxcXCIke3J9XFxcIiAvPlxcXFxuYCksYShgPHRpdGxlPkNhbGVuZGFyIGZvciAke3R9PC90aXRsZT5cXFxcbmApLGEoXFxcIjwvaGVhZD5cXFxcblxcXCIpLGEoXFxcIjxib2R5PlxcXFxuXFxcIiksYShjYWxsQShlLFxcXCJmb3JtYXR5ZWFyXFxcIix0LG4pKSxhKFxcXCI8L2JvZHk+XFxcXG5cXFwiKSxhKFxcXCI8L2h0bWw+XFxcXG5cXFwiKSxjYWxsQShoLFxcXCJlbmNvZGVcXFwiLG5ldyBoKHMpLG8sbmV3IGgoXFxcImlnbm9yZVxcXCIpKX0pLHtuYW1lOlxcXCJmb3JtYXR5ZWFycGFnZVxcXCIsYXJnczpbXFxcInRoZXllYXJcXFwiLFxcXCJ3aWR0aFxcXCIsXFxcImNzc1xcXCIsXFxcImVuY29kaW5nXFxcIl0sZGVmYXVsdHM6W04sbmV3IGgoXFxcImNhbGVuZGFyLmNzc1xcXCIpLG5ldyBoKFxcXCJ1dGYtOFxcXCIpXX0pLGNzc2NsYXNzZXM6bixjc3NjbGFzc2VzX3dlZWtkYXlfaGVhZDpyLGNzc2NsYXNzX25vZGF5OnMsY3NzY2xhc3NfbW9udGhfaGVhZDpkLGNzc2NsYXNzX21vbnRoOmwsY3NzY2xhc3NfeWVhcl9oZWFkOmMsY3NzY2xhc3NfeWVhcjp3fTtPYmplY3QuYXNzaWduKHQsYil9KSxcXFwiSFRNTENhbGVuZGFyXFxcIixba2VdKTtmdW5jdGlvbiB3aXRoTG9jYWxlKGUsdCl7Y29uc3Qgbj1FLmxvY2FsaXplQnlJZGVudGlmaWVyKGUudG9TdHJpbmcoKSk7di5zdHJmdGltZT1uO3RyeXtyZXR1cm4gdCgpfWZpbmFsbHl7di5zdHJmdGltZT1FfX1mdW5jdGlvbiBsb2NhbEluaXQoZSx0KXtUKHQpfHwodD1uZXcgaChcXFwiZW5fVVNcXFwiKSksZS5sb2NhbGU9dH1jb25zdCBiZT1MKFEsKChlLHQpPT57Y29uc3Qgbj1tYWtlUHlNZXRob2QuYmluZChudWxsLFxcXCJMb2NhbGVUZXh0Q2FsZW5kYXJcXFwiKSxyPXtfX2luaXRfXzpuKChmdW5jdGlvbiBfX2luaXRfXyhlLHQsbil7cmV0dXJuIGNhbGxBKHBlLFxcXCJfX2luaXRfX1xcXCIsZSx0KSxsb2NhbEluaXQoZSxuKSxmfSkse25hbWU6XFxcIl9faW5pdF9fXFxcIixhcmdzOltcXFwiZmlyc3R3ZWVrZGF5XFxcIixcXFwibG9jYWxlXFxcIl0sZGVmYXVsdHM6W1MsZl19KSxmb3JtYXR3ZWVrZGF5Om4oKGZ1bmN0aW9uIGZvcm1hdHdlZWtkYXkoZSx0LG4pe3JldHVybiB3aXRoTG9jYWxlKGUubG9jYWxlLCgoKT0+ZG9UZXh0Rm9ybWF0d2Vla2RheSgwLHQsbikpKX0pLHtuYW1lOlxcXCJmb3JtYXR3ZWVrZGF5XFxcIixhcmdzOltcXFwiZGF5XFxcIixcXFwid2lkdGhcXFwiXX0pLGZvcm1hdG1vbnRobmFtZTpuKChmdW5jdGlvbiBmb3JtYXRtb250aG5hbWUoZSx0LG4scixvKXtyZXR1cm4gd2l0aExvY2FsZShlLmxvY2FsZSwoKCk9PmRvVGV4dEZvcm1hdG1vbnRobmFtZSgwLHQsbixyLG8pKSl9KSx7bmFtZTpcXFwiZm9ybWF0bW9udGhuYW1lXFxcIixhcmdzOltcXFwidGhleWVhclxcXCIsXFxcInRoZW1vbnRoXFxcIixcXFwid2lkdGhcXFwiLFxcXCJ3aXRoeWVhclxcXCJdLGRlZmF1bHRzOlttXX0pfTtPYmplY3QuYXNzaWduKHQscil9KSxcXFwiTG9jYWxlVGV4dENhbGVuZGFyXFxcIixbcGVdKSxNZT1MKFEsKChlLHQpPT57Y29uc3Qgbj1tYWtlUHlNZXRob2QuYmluZChudWxsLFxcXCJMb2NhbGVIVE1MQ2FsZW5kYXJcXFwiKSxyPXtfX2luaXRfXzpuKChmdW5jdGlvbiBfX2luaXRfXyhlLHQsbil7cmV0dXJuIGNhbGxBKCRlLFxcXCJfX2luaXRfX1xcXCIsZSx0KSxsb2NhbEluaXQoZSxuKSxmfSkse25hbWU6XFxcIl9faW5pdF9fXFxcIixhcmdzOltcXFwiZmlyc3R3ZWVrZGF5XFxcIixcXFwibG9jYWxlXFxcIl0sZGVmYXVsdHM6W1MsZl19KSxmb3JtYXR3ZWVrZGF5Om4oKGZ1bmN0aW9uIGZvcm1hdHdlZWtkYXkoZSx0KXtyZXR1cm4gd2l0aExvY2FsZShlLmxvY2FsZSwoKCk9PmRvSHRtbEZvcm1hdHdlZWtkYXkoZSx0KSkpfSkse25hbWU6XFxcImZvcm1hdHdlZWtkYXlcXFwiLGFyZ3M6W1xcXCJkYXlcXFwiXX0pLGZvcm1hdG1vbnRobmFtZTpuKChmdW5jdGlvbiBmb3JtYXRtb250aG5hbWUoZSx0LG4scil7cmV0dXJuIHdpdGhMb2NhbGUoZS5sb2NhbGUsKCgpPT5kb0h0bWxGb3JtYXRtb250aG5hbWUoZSx0LG4scikpKX0pLHtuYW1lOlxcXCJmb3JtYXRtb250aG5hbWVcXFwiLGFyZ3M6W1xcXCJ0aGV5ZWFyXFxcIixcXFwidGhlbW9udGhcXFwiLFxcXCJ3aXRoeWVhclxcXCJdLGRlZmF1bHRzOlttXX0pfTtPYmplY3QuYXNzaWduKHQscil9KSxcXFwiTG9jYWxlSFRNTENhbGVuZGFyXFxcIixbJGVdKSxUZT1BKHBlLFtdKTtPYmplY3QuYXNzaWduKFEse0lsbGVnYWxNb250aEVycm9yOlosSWxsZWdhbFdlZWtkYXlFcnJvcjplZSxkYXlfbmFtZTptZSxtb250aF9uYW1lOmllLGRheV9hYmJyOmRlLG1vbnRoX2FiYnI6Y2UsSmFudWFyeTpuZXcgaSh0ZSksRmVicnVhcnk6bmV3IGkoYWUpLG1kYXlzOk0obmUpLE1PTkRBWTpuZXcgaShmZSksVFVFU0RBWTpuZXcgaShoZSksV0VETkVTREFZOm5ldyBpKHdlKSxUSFVSU0RBWTpuZXcgaSh5ZSksRlJJREFZOm5ldyBpKHVlKSxTQVRVUkRBWTpuZXcgaShfZSksU1VOREFZOm5ldyBpKGdlKSxDYWxlbmRhcjprZSxUZXh0Q2FsZW5kYXI6cGUsSFRNTENhbGVuZGFyOiRlLExvY2FsZVRleHRDYWxlbmRhcjpiZSxMb2NhbGVIVE1MQ2FsZW5kYXI6TWUsYzpUZSxmaXJzdHdlZWtkYXk6Z2V0QShUZSxcXFwiZ2V0Zmlyc3R3ZWVrZGF5XFxcIiksbW9udGhjYWxlbmRhcjpnZXRBKFRlLFxcXCJtb250aGRheXNjYWxlbmRhclxcXCIpLHByd2VlazpnZXRBKFRlLFxcXCJwcndlZWtcXFwiKSx3ZWVrOmdldEEoVGUsXFxcImZvcm1hdHdlZWtcXFwiKSx3ZWVraGVhZGVyOmdldEEoVGUsXFxcImZvcm1hdHdlZWtoZWFkZXJcXFwiKSxwcm1vbnRoOmdldEEoVGUsXFxcInBybW9udGhcXFwiKSxtb250aDpnZXRBKFRlLFxcXCJmb3JtYXRtb250aFxcXCIpLGNhbGVuZGFyOmdldEEoVGUsXFxcImZvcm1hdHllYXJcXFwiKSxwcmNhbDpnZXRBKFRlLFxcXCJwcnllYXJcXFwiKX0pO2NvbnN0IENlPW5ldyBpKDIwKSxPZT1SO2Z1bmN0aW9uIGZvcm1hdHN0cmluZyhlLHQsbil7dHx8KHQ9Q2UpLG58fChuPU9lKSxuPW11bChuLG5ldyBoKFxcXCIgXFxcIikpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG8gb2YgaXRlckpzKGUpKXIucHVzaChweUNlbnRlcihvLHQpLnRvU3RyaW5nKCkpO3JldHVybiBuZXcgaChyLmpvaW4obi50b1N0cmluZygpKSl9Y29uc3QgTGU9Z2V0QShWLFxcXCJ0b29yZGluYWxcXFwiKSx4ZT1BKExlLFtuZXcgVigxOTcwLDEsMSldKTtyZXR1cm4gdChcXFwiY2FsZW5kYXJcXFwiLFEse2lzbGVhcDp7JG1ldGg6ZT0+cyhpc2xlYXAoZSkpLCRmbGFnczp7TmFtZWRBcmdzOltcXFwieWVhclxcXCJdfSwkZG9jOlxcXCJSZXR1cm4gVHJ1ZSBmb3IgbGVhcCB5ZWFycywgRmFsc2UgZm9yIG5vbi1sZWFwIHllYXJzXFxcIn0sbGVhcGRheXM6eyRtZXRoKGUsdCl7ZT1GKGUpLTEsdD1GKHQpLTE7Y29uc3Qgbj1NYXRoLmZsb29yO3JldHVybiBuZXcgaShuKHQvNCktbihlLzQpLShuKHQvMTAwKS1uKGUvMTAwKSkrKG4odC80MDApLW4oZS80MDApKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn19LHdlZWtkYXk6eyRtZXRoOndlZWtkYXksJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ5ZWFyXFxcIixcXFwibW9udGhcXFwiLFxcXCJkYXlcXFwiXX0sJGRvYzpcXFwiUmV0dXJuIHdlZWtkYXkgKDAtNiB+IE1vbi1TdW4pIGZvciB5ZWFyLCBtb250aCAoMS0xMiksIGRheSAoMS0zMSkuXFxcIn0sbW9udGhyYW5nZTp7JG1ldGg6KGUsdCk9Pm5ldyB5KG1vbnRocmFuZ2UoZSx0KSksJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ5ZWFyXFxcIixcXFwibW9udGhcXFwiXX0sJGRvYzpcXFwiUmV0dXJuIHdlZWtkYXkgKDAtNiB+IE1vbi1TdW4pIGFuZCBudW1iZXIgb2YgZGF5cyAoMjgtMzEpIGZvciB5ZWFyLCBtb250aC5cXFwifSxzZXRmaXJzdHdlZWtkYXk6eyRtZXRoKGUpe2NvbnN0IHQ9RihlKTtpZighKGZlPD10JiZ0PD1nZSkpdGhyb3cgQShlZSxbZV0pO1RlLmZ3ZD1lfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcImZpcnN0d2Vla2RheVxcXCJdfX0sZm9ybWF0OnskbWV0aDpmdW5jdGlvbiBmb3JtYXQoZSx0LG4pe3JldHVybiBwKFtmb3JtYXRzdHJpbmcoZSx0LG4pXSksZn0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJjb2xzXFxcIixcXFwiY29sd2lkdGhcXFwiLFxcXCJzcGFjaW5nXFxcIl0sRGVmYXVsdHM6W0NlLE9lXX19LGZvcm1hdHN0cmluZzp7JG1ldGg6Zm9ybWF0c3RyaW5nLCRmbGFnczp7TmFtZWRBcmdzOltcXFwiY29sc1xcXCIsXFxcImNvbHdpZHRoXFxcIixcXFwic3BhY2luZ1xcXCJdLERlZmF1bHRzOltDZSxPZV19fSx0aW1lZ206eyRtZXRoKGUpe2NvbnN0W3QsbixyLG8scyxtXT1lLnZhbHVlT2YoKSxkPUEoVixbdCxuLEhdKSxsPUEoTGUsW2RdKSxpPWFkZChzdWIobCx4ZSksZGVjKHIpKSxjPWFkZChtdWwoaSxVKSxvKSxmPWFkZChtdWwoYyx6KSxzKTtyZXR1cm4gYWRkKG11bChmLHopLG0pfSwkZmxhZ3M6e09uZUFyZzohMH19fSksUX1cIixcInNyYy9saWIvY2VsbGJvdGljcy9fX2luaXRfXy5qc1wiOlwiXFxcInVzZSBzdHJpY3RcXFwiO2Z1bmN0aW9uIHByb21pc2VUb1B5KGUpe2NvbnN0IG49bmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb247bGV0IGksdDtyZXR1cm4gbi5yZXN1bWU9ZnVuY3Rpb24oKXtpZih0KXRocm93IHQ7cmV0dXJuIGl9LG4uZGF0YT17dHlwZTpcXFwiU2sucHJvbWlzZVxcXCIscHJvbWlzZTplLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBpPWUsZX0pLChmdW5jdGlvbihlKXtyZXR1cm4gdD1lLGV9KSl9LG59ZnVuY3Rpb24gcmVtYXBUb1B5KGUpe3JldHVybiBlIGluc3RhbmNlb2YgUHJvbWlzZSYmKGU9cHJvbWlzZVRvUHkoZSkpLFNrLmZmaS5yZW1hcFRvUHkoZSl9ZnVuY3Rpb24gcmVtYXBUb0pzRnVuYyhlLC4uLm4pe3JldHVybiBmdW5jdGlvbiguLi5pKXtuJiZTay5idWlsdGluLnB5Q2hlY2tBcmdzKGUubmFtZSxpLC4uLm4pLGk9aS5zbGljZSgxKTtyZXR1cm4gcmVtYXBUb1B5KGUoLi4uaS5tYXAoKGU9PlNrLmZmaS5yZW1hcFRvSnMoZSkpKSkpfX12YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHJlbWFwVG9QeShQcm9taXNlLmFsbChbcnVuZXN0b25lQ29tcG9uZW50cy5ydW5lc3RvbmVfaW1wb3J0KFxcXCJibGVcXFwiKSxydW5lc3RvbmVDb21wb25lbnRzLnJ1bmVzdG9uZV9pbXBvcnQoXFxcInNpbXBsZV9zZW5zb3JcXFwiKV0pLnRoZW4oKChbZSxuXSk9Pntjb25zdCBpPXtfX25hbWVfXzpuZXcgU2suYnVpbHRpbi5zdHIoXFxcImNlbGxib3RpY3NcXFwiKX0sZ2V0X3NlbGY9ZT0+ZSYmZS5fX2pzX2NsYXNzO2kuSnNQcm9wZXJ0eT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsbil7bi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiguLi5lKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJfX2luaXRfX1xcXCIsZSwyLDIpO2NvbnN0W24saV09ZTtuLl9fanNfcHJvcGVydHk9U2suZmZpLnJlbWFwVG9KcyhpKX0pKSxuLl9fZ2V0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oLi4uZSl7U2suYnVpbHRpbi5weUNoZWNrQXJncyhcXFwiX19nZXRfX1xcXCIsZSwyLDMpO2NvbnN0W24saSx0XT1lO3JldHVybiByZW1hcFRvUHkoZ2V0X3NlbGYoaSlbbi5fX2pzX3Byb3BlcnR5XSl9KSl9KSxcXFwiSnNQcm9wZXJ0eVxcXCIsW10pO2NvbnN0IHByb3Bfd3JhcD1lPT5Tay5taXNjZXZhbC5jYWxsc2ltKGkuSnNQcm9wZXJ0eSxuZXcgU2suYnVpbHRpbnMuc3RyKGUpKSx0PWUuY2VsbF9ib3RfYmxlX2d1aS5jZWxsX2JvdF9ibGU7dCYmKGkuQ2VsbEJvdD1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsbil7bi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtpZighdC5wYWlyZWQoKSl0aHJvd1xcXCJUaGUgQ2VsbEJvdCBpcyBub3QgcGFpcmVkLiBDbGljayBvbiB0aGUgUGFpciBidXR0b24gYmVmb3JlIHJ1bm5pbmcgeW91ciBwcm9ncmFtLlxcXCI7cmV0dXJuIHJlbWFwVG9QeSh0LnJlc2V0SGFyZHdhcmUoKS50aGVuKCgoKT0+e30pKSl9KSksbi5JTlBVVD1uZXcgU2suYnVpbHRpbi5pbnRfKHQuSU5QVVQpLG4uT1VUUFVUPW5ldyBTay5idWlsdGluLmludF8odC5PVVRQVVQpO2NvbnN0IHdyYXA9KGUsbik9Pm5ldyBTay5idWlsdGluLmZ1bmMocmVtYXBUb0pzRnVuYyhlLG4sbikpO24ucmVzZXRIYXJkd2FyZT13cmFwKHQucmVzZXRIYXJkd2FyZSwxKSxuLnBpbk1vZGU9d3JhcCh0LnBpbk1vZGUsMyksbi5kaWdpdGFsV3JpdGU9d3JhcCh0LmRpZ2l0YWxXcml0ZSwzKSxuLmRpZ2l0YWxSZWFkPXdyYXAodC5kaWdpdGFsUmVhZCwyKSxuLmxlZGNTZXR1cD13cmFwKHQubGVkY1NldHVwLDQpLG4ubGVkY0F0dGFjaFBpbj13cmFwKHQubGVkY0F0dGFjaFBpbiwzKSxuLmxlZGNEZXRhY2hQaW49d3JhcCh0LmxlZGNEZXRhY2hQaW4sMiksbi5sZWRjV3JpdGU9d3JhcCh0LmxlZGNXcml0ZSwzKX0pLFxcXCJDZWxsQm90XFxcIixbXSkpO2NvbnN0IG1ldGhvZF93cmFwPShlLG4pPT5uZXcgU2suYnVpbHRpbi5mdW5jKCgoLi4uaSk9PnJlbWFwVG9Kc0Z1bmMoZ2V0X3NlbGYoaVswXSlbZV0sbixuKSguLi5pKSkpO2kuX1NlbnNvcj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsbil7bi5zdGFydD1tZXRob2Rfd3JhcChcXFwic3RhcnRcXFwiLDEpLG4uc3RvcD1tZXRob2Rfd3JhcChcXFwic3RvcFxcXCIsMSl9KSxcXFwiX1NlbnNvclxcXCIsW10pLGkuX1hZWlNlbnNvcj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsbil7bi54PXByb3Bfd3JhcChcXFwieFxcXCIpLG4ueT1wcm9wX3dyYXAoXFxcInlcXFwiKSxuLno9cHJvcF93cmFwKFxcXCJ6XFxcIil9KSxcXFwiX1hZWlNlbnNvclxcXCIsW2kuX1NlbnNvcl0pLGkuX09yaWVudGF0aW9uU2Vuc29yPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoaSwoZnVuY3Rpb24oZSxuKXtuLnF1YXRlcm5pb249cHJvcF93cmFwKFxcXCJxdWF0ZXJuaW9uXFxcIil9KSxcXFwiX09yaWVudGF0aW9uU2Vuc29yXFxcIixbaS5fU2Vuc29yXSk7Y29uc3Qgc2Vuc29yX2ZhY3Rvcnk9KGUsbix0KT0+aVtlXT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsbil7bi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiguLi5lKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJfX2luaXRfX1xcXCIsW2VdLDEsMSksZVswXS5fX2pzX2NsYXNzPW5ldyB0fSkpfSksZSxbbl0pO3JldHVybiBpLkFtYmllbnRMaWdodFNlbnNvcj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGksKGZ1bmN0aW9uKGUsaSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiguLi5lKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJfX2luaXRfX1xcXCIsW2VdLDEsMSksZVswXS5fX2pzX2NsYXNzPW5ldyBuLlNpbXBsZUFtYmllbnRMaWdodFNlbnNvcn0pKSxpLmlsbHVtaW5hbmNlPXByb3Bfd3JhcChcXFwiaWxsdW1pbmFuY2VcXFwiKX0pLFxcXCJBbWJpZW50TGlnaHRTZW5zb3JcXFwiLFtpLl9TZW5zb3JdKSxpLkdlb2xvY2F0aW9uU2Vuc29yPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoaSwoZnVuY3Rpb24oZSxpKXtpLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKC4uLmUpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXFxcIl9faW5pdF9fXFxcIixbZV0sMSwxKSxlWzBdLl9fanNfY2xhc3M9bmV3IG4uU2ltcGxlR2VvbG9jYXRpb25TZW5zb3J9KSksaS5sYXRpdHVkZT1wcm9wX3dyYXAoXFxcImxhdGl0dWRlXFxcIiksaS5sb25naXR1ZGU9cHJvcF93cmFwKFxcXCJsb25naXR1ZGVcXFwiKSxpLmFsdGl0dWRlPXByb3Bfd3JhcChcXFwiYWx0aXR1ZGVcXFwiKSxpLmFjY3VyYWN5PXByb3Bfd3JhcChcXFwiYWNjdXJhY3lcXFwiKSxpLmFsdGl0dWRlQWNjdXJhY3k9cHJvcF93cmFwKFxcXCJhbHRpdHVkZUFjY3VyYWN5XFxcIiksaS5oZWFkaW5nPXByb3Bfd3JhcChcXFwiaGVhZGluZ1xcXCIpLGkuc3BlZWQ9cHJvcF93cmFwKFxcXCJzcGVlZFxcXCIpfSksXFxcIkdlb2xvY2F0aW9uU2Vuc29yXFxcIixbaS5fU2Vuc29yXSksc2Vuc29yX2ZhY3RvcnkoXFxcIkFjY2VsZXJvbWV0ZXJcXFwiLGkuX1hZWlNlbnNvcixuLlNpbXBsZUFjY2VsZXJvbWV0ZXIpLHNlbnNvcl9mYWN0b3J5KFxcXCJHeXJvc2NvcGVcXFwiLGkuX1hZWlNlbnNvcixuLlNpbXBsZUd5cm9zY29wZSksc2Vuc29yX2ZhY3RvcnkoXFxcIk1hZ25ldG9tZXRlclxcXCIsaS5fWFlaU2Vuc29yLG4uU2ltcGxlTWFnbmV0b21ldGVyKSxzZW5zb3JfZmFjdG9yeShcXFwiTGluZWFyQWNjZWxlcmF0aW9uU2Vuc29yXFxcIixpLl9YWVpTZW5zb3Isbi5TaW1wbGVMaW5lYXJBY2NlbGVyYXRpb25TZW5zb3IpLHNlbnNvcl9mYWN0b3J5KFxcXCJHcmF2aXR5U2Vuc29yXFxcIixpLl9YWVpTZW5zb3Isbi5TaW1wbGVHcmF2aXR5U2Vuc29yKSxzZW5zb3JfZmFjdG9yeShcXFwiQWJzb2x1dGVPcmllbnRhdGlvblNlbnNvclxcXCIsaS5fT3JpZW50YXRpb25TZW5zb3Isbi5TaW1wbGVBYnNvbHV0ZU9yaWVudGF0aW9uU2Vuc29yKSxzZW5zb3JfZmFjdG9yeShcXFwiUmVsYXRpdmVPcmllbnRhdGlvblNlbnNvclxcXCIsaS5fT3JpZW50YXRpb25TZW5zb3Isbi5TaW1wbGVSZWxhdGl2ZU9yaWVudGF0aW9uU2Vuc29yKSxpfSkpKX07XCIsXCJzcmMvbGliL2NvbGxlY3Rpb25zLmpzXCI6XCJmdW5jdGlvbiAkYnVpbHRpbm1vZHVsZSh0KXtjb25zdCBlPXt9O3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRNb2R1bGUoXFxcImtleXdvcmRcXFwiLCExLCEwKSwodD0+KGUuX2lza2V5d29yZD10LiRkLmlza2V5d29yZCxTay5pbXBvcnRNb2R1bGUoXFxcIml0ZXJ0b29sc1xcXCIsITEsITApKSksKHQ9PihlLl9jaGFpbj10LiRkLmNoYWluLGUuX3N0YXJtYXA9dC4kZC5zdGFybWFwLGUuX3JlcGVhdD10LiRkLnJlcGVhdCxTay5pbXBvcnRNb2R1bGUoXFxcIm9wZXJhdG9yXFxcIiwhMSwhMCkpKSwodD0+e2UuX2l0ZW1nZXR0ZXI9dC4kZC5pdGVtZ2V0dGVyfSksKCgpPT5jb2xsZWN0aW9uc19tb2QoZSkpKX1mdW5jdGlvbiBjb2xsZWN0aW9uc19tb2QodCl7ZnVuY3Rpb24gY291bnRlck51bWJlclNsb3QoZSl7cmV0dXJuIGZ1bmN0aW9uKGkpe2lmKHZvaWQgMCE9PWkmJiEoaSBpbnN0YW5jZW9mIHQuQ291bnRlcikpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IHM9bmV3IHQuQ291bnRlcjtyZXR1cm4gZS5jYWxsKHRoaXMscyxpKSxzfX1mdW5jdGlvbiBjb3VudGVySW5wbGFjZVNsb3QodCxlKXtyZXR1cm4gZnVuY3Rpb24oaSl7aWYoIShpIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIkNvdW50ZXIgXFxcIit0K1xcXCI9IFxcXCIrU2suYWJzdHIudHlwZU5hbWUoaSkrXFxcIiBpcyBub3Qgc3VwcG9ydGVkXFxcIik7cmV0dXJuIGUuY2FsbCh0aGlzLGkpLHRoaXMua2VlcCRwb3NpdGl2ZSgpfX10Ll9fYWxsX189bmV3IFNrLmJ1aWx0aW4ubGlzdChbXFxcImRlcXVlXFxcIixcXFwiZGVmYXVsdGRpY3RcXFwiLFxcXCJuYW1lZHR1cGxlXFxcIixcXFwiQ291bnRlclxcXCIsXFxcIk9yZGVyZWREaWN0XFxcIl0ubWFwKCh0PT5uZXcgU2suYnVpbHRpbi5zdHIodCkpKSksdC5kZWZhdWx0ZGljdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFxcXCJjb2xsZWN0aW9ucy5kZWZhdWx0ZGljdFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGRlZmF1bHRkaWN0KHQsZSl7dGhpcy5kZWZhdWx0X2ZhY3Rvcnk9dCxTay5idWlsdGluLmRpY3QuY2FsbCh0aGlzLGUpfSxiYXNlOlNrLmJ1aWx0aW4uZGljdCxtZXRob2RzOntjb3B5OnskbWV0aCgpe3JldHVybiB0aGlzLiRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfX0sX19jb3B5X186eyRtZXRoKCl7cmV0dXJuIHRoaXMuJGNvcHkoKX0sJGZsYWdzOntOb0FyZ3M6ITB9fSxfX21pc3NpbmdfXzp7JG1ldGgodCl7aWYoU2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5kZWZhdWx0X2ZhY3RvcnkpKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIodCkpO3tjb25zdCBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLmRlZmF1bHRfZmFjdG9yeSxbXSk7cmV0dXJuIHRoaXMubXAkYXNzX3N1YnNjcmlwdCh0LGUpLGV9fSwkZmxhZ3M6e09uZUFyZzohMH19fSxnZXRzZXRzOntkZWZhdWx0X2ZhY3Rvcnk6eyRnZXQoKXtyZXR1cm4gdGhpcy5kZWZhdWx0X2ZhY3Rvcnl9LCRzZXQodCl7dD10fHxTay5idWlsdGluLm5vbmUubm9uZSQsdGhpcy5kZWZhdWx0X2ZhY3Rvcnk9dH19fSxzbG90czp7dHAkZG9jOlxcXCJkZWZhdWx0ZGljdChkZWZhdWx0X2ZhY3RvcnlbLCAuLi5dKSAtLVxcXFx4M2UgZGljdCB3aXRoIGRlZmF1bHQgZmFjdG9yeVxcXFxuXFxcXG5UaGUgZGVmYXVsdCBmYWN0b3J5IGlzIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cyB0byBwcm9kdWNlXFxcXG5hIG5ldyB2YWx1ZSB3aGVuIGEga2V5IGlzIG5vdCBwcmVzZW50LCBpbiBfX2dldGl0ZW1fXyBvbmx5LlxcXFxuQSBkZWZhdWx0ZGljdCBjb21wYXJlcyBlcXVhbCB0byBhIGRpY3Qgd2l0aCB0aGUgc2FtZSBpdGVtcy5cXFxcbkFsbCByZW1haW5pbmcgYXJndW1lbnRzIGFyZSB0cmVhdGVkIHRoZSBzYW1lIGFzIGlmIHRoZXkgd2VyZVxcXFxucGFzc2VkIHRvIHRoZSBkaWN0IGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcga2V5d29yZCBhcmd1bWVudHMuXFxcXG5cXFwiLHRwJGluaXQodCxlKXtjb25zdCBpPXQuc2hpZnQoKTtpZih2b2lkIDA9PT1pKXRoaXMuZGVmYXVsdF9mYWN0b3J5PVNrLmJ1aWx0aW4ubm9uZS5ub25lJDtlbHNle2lmKCFTay5idWlsdGluLmNoZWNrQ2FsbGFibGUoaSkmJiFTay5idWlsdGluLmNoZWNrTm9uZShpKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImZpcnN0IGFyZ3VtZW50IG11c3QgYmUgY2FsbGFibGVcXFwiKTt0aGlzLmRlZmF1bHRfZmFjdG9yeT1pfXJldHVybiBTay5idWlsdGluLmRpY3QucHJvdG90eXBlLnRwJGluaXQuY2FsbCh0aGlzLHQsZSl9LCRyKCl7Y29uc3QgdD1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMuZGVmYXVsdF9mYWN0b3J5KSxlPVNrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUuJHIuY2FsbCh0aGlzKS52O3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXFxcImRlZmF1bHRkaWN0KFxcXCIrdCtcXFwiLCBcXFwiK2UrXFxcIilcXFwiKX19LHByb3RvOnskY29weSgpe2NvbnN0IGU9W107cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcih0aGlzKSwodD0+e2UucHVzaCh0KSxlLnB1c2godGhpcy5tcCRzdWJzY3JpcHQodCkpfSkpLG5ldyB0LmRlZmF1bHRkaWN0KHRoaXMuZGVmYXVsdF9mYWN0b3J5LGUpfX19KSx0LkNvdW50ZXI9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcXFwiQ291bnRlclxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIENvdW50ZXIoKXt0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3QsU2suYnVpbHRpbi5kaWN0LmFwcGx5KHRoaXMpfSxiYXNlOlNrLmJ1aWx0aW4uZGljdCxtZXRob2RzOntlbGVtZW50czp7JGZsYWdzOntOb0FyZ3M6ITB9LCRtZXRoKCl7Y29uc3QgZT10Ll9jaGFpbi50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcXFwiZnJvbV9pdGVyYWJsZVxcXCIpKSxpPXQuX3N0YXJtYXAscz10Ll9yZXBlYXQsbj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXk7cmV0dXJuIG4oZSxbbihpLFtzLG4odGhpcy50cCRnZXRhdHRyKHRoaXMuc3RyJGl0ZW1zKSldKV0pfX0sbW9zdF9jb21tb246eyRmbGFnczp7TmFtZWRBcmdzOltcXFwiblxcXCJdLERlZmF1bHRzOltTay5idWlsdGluLm5vbmUubm9uZSRdfSwkbWV0aCh0KXtjb25zdCBlPXRoaXMuc3EkbGVuZ3RoKCk7dD1Tay5idWlsdGluLmNoZWNrTm9uZSh0KXx8KHQ9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3codCkpPmU/ZTp0PDA/MDp0O2NvbnN0IGk9dGhpcy4kaXRlbXMoKS5zb3J0KCgodCxlKT0+U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHRbMV0sZVsxXSxcXFwiTHRcXFwiKT8xOlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0WzFdLGVbMV0sXFxcIkd0XFxcIik/LTE6MCkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGkuc2xpY2UoMCx0KS5tYXAoKHQ9Pm5ldyBTay5idWlsdGluLnR1cGxlKHQpKSkpfX0sdXBkYXRlOnskZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkbWV0aCh0LGUpe3JldHVybiBTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcInVwZGF0ZVxcXCIsdCwwLDEpLHRoaXMuY291bnRlciR1cGRhdGUodCxlKX19LHN1YnRyYWN0OnskZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkbWV0aCh0LGUpe1NrLmFic3RyLmNoZWNrQXJnc0xlbihcXFwic3VidHJhY3RcXFwiLHQsMCwxKTtjb25zdCBpPXRbMF07aWYodm9pZCAwIT09aSlpZihpIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KWZvcihsZXQgcz1Tay5hYnN0ci5pdGVyKGkpLG49cy50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PW47bj1zLnRwJGl0ZXJuZXh0KCkpe2NvbnN0IHQ9dGhpcy5tcCRzdWJzY3JpcHQobik7dGhpcy5tcCRhc3Nfc3Vic2NyaXB0KG4sU2suYWJzdHIubnVtYmVyQmluT3AodCxpLm1wJHN1YnNjcmlwdChuKSxcXFwiU3ViXFxcIikpfWVsc2UgZm9yKGxldCBzPVNrLmFic3RyLml0ZXIoaSksbj1zLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09bjtuPXMudHAkaXRlcm5leHQoKSl7Y29uc3QgdD10aGlzLm1wJHN1YnNjcmlwdChuKTt0aGlzLm1wJGFzc19zdWJzY3JpcHQobixTay5hYnN0ci5udW1iZXJCaW5PcCh0LHRoaXMuJG9uZSxcXFwiU3ViXFxcIikpfWU9ZXx8W107Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKz0yKXtjb25zdCB0PW5ldyBTay5idWlsdGluLnN0cihlW3NdKSxpPXRoaXMubXAkc3Vic2NyaXB0KHQpO3RoaXMubXAkYXNzX3N1YnNjcmlwdCh0LFNrLmFic3RyLm51bWJlckJpbk9wKGksZVtzKzFdLFxcXCJTdWJcXFwiKSl9cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LF9fbWlzc2luZ19fOnskbWV0aCh0KXtyZXR1cm4gdGhpcy4kemVyb30sJGZsYWdzOntPbmVBcmc6ITB9fSxjb3B5OnskbWV0aCgpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5Db3VudGVyLFt0aGlzXSl9LCRmbGFnczp7Tm9BcmdzOiEwfX19LGdldHNldHM6e19fZGljdF9fOlNrLmdlbmVyaWMuZ2V0U2V0RGljdH0sc2xvdHM6e3RwJGRvYzpcXFwiRGljdCBzdWJjbGFzcyBmb3IgY291bnRpbmcgaGFzaGFibGUgaXRlbXMuICBTb21ldGltZXMgY2FsbGVkIGEgYmFnXFxcXG4gICAgb3IgbXVsdGlzZXQuICBFbGVtZW50cyBhcmUgc3RvcmVkIGFzIGRpY3Rpb25hcnkga2V5cyBhbmQgdGhlaXIgY291bnRzXFxcXG4gICAgYXJlIHN0b3JlZCBhcyBkaWN0aW9uYXJ5IHZhbHVlcy5cXFxcblxcXFxuICAgID4+PiBjID0gQ291bnRlcignYWJjZGVhYmNkYWJjYWJhJykgICMgY291bnQgZWxlbWVudHMgZnJvbSBhIHN0cmluZ1xcXFxuXFxcXG4gICAgPj4+IGMubW9zdF9jb21tb24oMykgICAgICAgICAgICAgICAgIyB0aHJlZSBtb3N0IGNvbW1vbiBlbGVtZW50c1xcXFxuICAgIFsoJ2EnLCA1KSwgKCdiJywgNCksICgnYycsIDMpXVxcXFxuICAgID4+PiBzb3J0ZWQoYykgICAgICAgICAgICAgICAgICAgICAgICMgbGlzdCBhbGwgdW5pcXVlIGVsZW1lbnRzXFxcXG4gICAgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxcXFxuICAgID4+PiAnJy5qb2luKHNvcnRlZChjLmVsZW1lbnRzKCkpKSAgICMgbGlzdCBlbGVtZW50cyB3aXRoIHJlcGV0aXRpb25zXFxcXG4gICAgJ2FhYWFhYmJiYmNjY2RkZSdcXFxcbiAgICA+Pj4gc3VtKGMudmFsdWVzKCkpICAgICAgICAgICAgICAgICAjIHRvdGFsIG9mIGFsbCBjb3VudHNcXFxcbiAgICAxNVxcXFxuXFxcXG4gICAgPj4+IGNbJ2EnXSAgICAgICAgICAgICAgICAgICAgICAgICAgIyBjb3VudCBvZiBsZXR0ZXIgJ2EnXFxcXG4gICAgNVxcXFxuICAgID4+PiBmb3IgZWxlbSBpbiAnc2hhemFtJzogICAgICAgICAgICMgdXBkYXRlIGNvdW50cyBmcm9tIGFuIGl0ZXJhYmxlXFxcXG4gICAgLi4uICAgICBjW2VsZW1dICs9IDEgICAgICAgICAgICAgICAgIyBieSBhZGRpbmcgMSB0byBlYWNoIGVsZW1lbnQncyBjb3VudFxcXFxuICAgID4+PiBjWydhJ10gICAgICAgICAgICAgICAgICAgICAgICAgICMgbm93IHRoZXJlIGFyZSBzZXZlbiAnYSdcXFxcbiAgICA3XFxcXG4gICAgPj4+IGRlbCBjWydiJ10gICAgICAgICAgICAgICAgICAgICAgIyByZW1vdmUgYWxsICdiJ1xcXFxuICAgID4+PiBjWydiJ10gICAgICAgICAgICAgICAgICAgICAgICAgICMgbm93IHRoZXJlIGFyZSB6ZXJvICdiJ1xcXFxuICAgIDBcXFxcblxcXFxuICAgID4+PiBkID0gQ291bnRlcignc2ltc2FsYWJpbScpICAgICAgICMgbWFrZSBhbm90aGVyIGNvdW50ZXJcXFxcbiAgICA+Pj4gYy51cGRhdGUoZCkgICAgICAgICAgICAgICAgICAgICAjIGFkZCBpbiB0aGUgc2Vjb25kIGNvdW50ZXJcXFxcbiAgICA+Pj4gY1snYSddICAgICAgICAgICAgICAgICAgICAgICAgICAjIG5vdyB0aGVyZSBhcmUgbmluZSAnYSdcXFxcbiAgICA5XFxcXG5cXFxcbiAgICA+Pj4gYy5jbGVhcigpICAgICAgICAgICAgICAgICAgICAgICAjIGVtcHR5IHRoZSBjb3VudGVyXFxcXG4gICAgPj4+IGNcXFxcbiAgICBDb3VudGVyKClcXFxcblxcXFxuICAgIE5vdGU6ICBJZiBhIGNvdW50IGlzIHNldCB0byB6ZXJvIG9yIHJlZHVjZWQgdG8gemVybywgaXQgd2lsbCByZW1haW5cXFxcbiAgICBpbiB0aGUgY291bnRlciB1bnRpbCB0aGUgZW50cnkgaXMgZGVsZXRlZCBvciB0aGUgY291bnRlciBpcyBjbGVhcmVkOlxcXFxuXFxcXG4gICAgPj4+IGMgPSBDb3VudGVyKCdhYWFiYmMnKVxcXFxuICAgID4+PiBjWydiJ10gLT0gMiAgICAgICAgICAgICAgICAgICAgICMgcmVkdWNlIHRoZSBjb3VudCBvZiAnYicgYnkgdHdvXFxcXG4gICAgPj4+IGMubW9zdF9jb21tb24oKSAgICAgICAgICAgICAgICAgIyAnYicgaXMgc3RpbGwgaW4sIGJ1dCBpdHMgY291bnQgaXMgemVyb1xcXFxuICAgIFsoJ2EnLCAzKSwgKCdjJywgMSksICgnYicsIDApXVxcXFxuXFxcXG5cXFwiLHRwJGluaXQodCxlKXtyZXR1cm4gU2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMudHBqc19uYW1lLHQsMCwxKSx0aGlzLmNvdW50ZXIkdXBkYXRlKHQsZSl9LCRyKCl7Y29uc3QgdD10aGlzLnNpemU+MD9Tay5idWlsdGluLmRpY3QucHJvdG90eXBlLiRyLmNhbGwodGhpcykudjpcXFwiXFxcIjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1xcXCIoXFxcIit0K1xcXCIpXFxcIil9LHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsbXAkYXNzX3N1YnNjcmlwdCh0LGUpe3JldHVybiB2b2lkIDA9PT1lP3RoaXMubXAkbG9va3VwKHQpJiZTay5idWlsdGluLmRpY3QucHJvdG90eXBlLm1wJGFzc19zdWJzY3JpcHQuY2FsbCh0aGlzLHQsZSk6U2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS5tcCRhc3Nfc3Vic2NyaXB0LmNhbGwodGhpcyx0LGUpfSx0cCRhc19udW1iZXI6ITAsbmIkcG9zaXRpdmU6Y291bnRlck51bWJlclNsb3QoKGZ1bmN0aW9uKHQpe3RoaXMuJGl0ZW1zKCkuZm9yRWFjaCgoKFtlLGldKT0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChpLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJnQubXAkYXNzX3N1YnNjcmlwdChlLGkpfSkpfSkpLG5iJG5lZ2F0aXZlOmNvdW50ZXJOdW1iZXJTbG90KChmdW5jdGlvbih0KXt0aGlzLiRpdGVtcygpLmZvckVhY2goKChbZSxpXSk9PntTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaSx0aGlzLiR6ZXJvLFxcXCJMdFxcXCIpJiZ0Lm1wJGFzc19zdWJzY3JpcHQoZSxTay5hYnN0ci5udW1iZXJCaW5PcCh0aGlzLiR6ZXJvLGksXFxcIlN1YlxcXCIpKX0pKX0pKSxuYiRzdWJ0cmFjdDpjb3VudGVyTnVtYmVyU2xvdCgoZnVuY3Rpb24odCxlKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKChbaSxzXSk9Pntjb25zdCBuPVNrLmFic3RyLm51bWJlckJpbk9wKHMsZS5tcCRzdWJzY3JpcHQoaSksXFxcIlN1YlxcXCIpO1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChuLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJnQubXAkYXNzX3N1YnNjcmlwdChpLG4pfSkpLGUuJGl0ZW1zKCkuZm9yRWFjaCgoKFtlLGldKT0+e3ZvaWQgMD09PXRoaXMubXAkbG9va3VwKGUpJiZTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaSx0aGlzLiR6ZXJvLFxcXCJMdFxcXCIpJiZ0Lm1wJGFzc19zdWJzY3JpcHQoZSxTay5hYnN0ci5udW1iZXJCaW5PcCh0aGlzLiR6ZXJvLGksXFxcIlN1YlxcXCIpKX0pKX0pKSxuYiRhZGQ6Y291bnRlck51bWJlclNsb3QoKGZ1bmN0aW9uKHQsZSl7dGhpcy4kaXRlbXMoKS5mb3JFYWNoKCgoW2ksc10pPT57Y29uc3Qgbj1Tay5hYnN0ci5udW1iZXJCaW5PcChzLGUubXAkc3Vic2NyaXB0KGkpLFxcXCJBZGRcXFwiKTtTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wobix0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZ0Lm1wJGFzc19zdWJzY3JpcHQoaSxuKX0pKSxlLiRpdGVtcygpLmZvckVhY2goKChbZSxpXSk9Pnt2b2lkIDA9PT10aGlzLm1wJGxvb2t1cChlKSYmU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGksdGhpcy4kemVybyxcXFwiR3RcXFwiKSYmdC5tcCRhc3Nfc3Vic2NyaXB0KGUsaSl9KSl9KSksbmIkaW5wbGFjZV9hZGQ6Y291bnRlcklucGxhY2VTbG90KFxcXCIrXFxcIiwoZnVuY3Rpb24odCl7dC4kaXRlbXMoKS5mb3JFYWNoKCgoW3QsZV0pPT57Y29uc3QgaT1Tay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AodGhpcy5tcCRzdWJzY3JpcHQodCksZSxcXFwiQWRkXFxcIik7dGhpcy5tcCRhc3Nfc3Vic2NyaXB0KHQsaSl9KSl9KSksbmIkaW5wbGFjZV9zdWJ0cmFjdDpjb3VudGVySW5wbGFjZVNsb3QoXFxcIi1cXFwiLChmdW5jdGlvbih0KXt0LiRpdGVtcygpLmZvckVhY2goKChbdCxlXSk9Pntjb25zdCBpPVNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcCh0aGlzLm1wJHN1YnNjcmlwdCh0KSxlLFxcXCJTdWJcXFwiKTt0aGlzLm1wJGFzc19zdWJzY3JpcHQodCxpKX0pKX0pKSxuYiRvcjpjb3VudGVyTnVtYmVyU2xvdCgoZnVuY3Rpb24odCxlKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKChbaSxzXSk9Pntjb25zdCBuPWUubXAkc3Vic2NyaXB0KGkpLHI9U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHMsbixcXFwiTHRcXFwiKT9uOnM7U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHIsdGhpcy4kemVybyxcXFwiR3RcXFwiKSYmdC5tcCRhc3Nfc3Vic2NyaXB0KGkscil9KSksZS4kaXRlbXMoKS5mb3JFYWNoKCgoW2UsaV0pPT57dm9pZCAwPT09dGhpcy5tcCRsb29rdXAoZSkmJlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChpLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJnQubXAkYXNzX3N1YnNjcmlwdChlLGkpfSkpfSkpLG5iJGFuZDpjb3VudGVyTnVtYmVyU2xvdCgoZnVuY3Rpb24odCxlKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKChbaSxzXSk9Pntjb25zdCBuPWUubXAkc3Vic2NyaXB0KGkpLHI9U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHMsbixcXFwiTHRcXFwiKT9zOm47U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHIsdGhpcy4kemVybyxcXFwiR3RcXFwiKSYmdC5tcCRhc3Nfc3Vic2NyaXB0KGkscil9KSl9KSksbmIkaW5wbGFjZV9hbmQ6Y291bnRlcklucGxhY2VTbG90KFxcXCImXFxcIiwoZnVuY3Rpb24odCl7dGhpcy4kaXRlbXMoKS5mb3JFYWNoKCgoW2UsaV0pPT57Y29uc3Qgcz10Lm1wJHN1YnNjcmlwdChlKTtTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wocyxpLFxcXCJMdFxcXCIpJiZ0aGlzLm1wJGFzc19zdWJzY3JpcHQoZSxzKX0pKX0pKSxuYiRpbnBsYWNlX29yOmNvdW50ZXJJbnBsYWNlU2xvdChcXFwifFxcXCIsKGZ1bmN0aW9uKHQpe3QuJGl0ZW1zKCkuZm9yRWFjaCgoKFt0LGVdKT0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChlLHRoaXMubXAkc3Vic2NyaXB0KHQpLFxcXCJHdFxcXCIpJiZ0aGlzLm1wJGFzc19zdWJzY3JpcHQodCxlKX0pKX0pKSxuYiRyZWZsZWN0ZWRfYW5kOm51bGwsbmIkcmVmbGVjdGVkX29yOm51bGwsbmIkcmVmbGVjdGVkX2FkZDpudWxsLG5iJHJlZmxlY3RlZF9zdWJ0cmFjdDpudWxsfSxwcm90bzp7a2VlcCRwb3NpdGl2ZSgpe3JldHVybiB0aGlzLiRpdGVtcygpLmZvckVhY2goKChbdCxlXSk9PntTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZSx0aGlzLiR6ZXJvLFxcXCJMdEVcXFwiKSYmdGhpcy5tcCRhc3Nfc3Vic2NyaXB0KHQpfSkpLHRoaXN9LCR6ZXJvOm5ldyBTay5idWlsdGluLmludF8oMCksJG9uZTpuZXcgU2suYnVpbHRpbi5pbnRfKDEpLHN0ciRpdGVtczpuZXcgU2suYnVpbHRpbi5zdHIoXFxcIml0ZW1zXFxcIiksY291bnRlciR1cGRhdGUodCxlKXtjb25zdCBpPXRbMF07aWYodm9pZCAwIT09aSlpZihTay5idWlsdGluLmNoZWNrTWFwcGluZyhpKSlpZih0aGlzLnNxJGxlbmd0aCgpKWZvcihsZXQgcz1Tay5hYnN0ci5pdGVyKGkpLG49cy50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PW47bj1zLnRwJGl0ZXJuZXh0KCkpe2NvbnN0IHQ9dGhpcy5tcCRzdWJzY3JpcHQobik7dGhpcy5tcCRhc3Nfc3Vic2NyaXB0KG4sU2suYWJzdHIubnVtYmVyQmluT3AodCxpLm1wJHN1YnNjcmlwdChuKSxcXFwiQWRkXFxcIikpfWVsc2UgdGhpcy51cGRhdGUkY29tbW9uKHQsdm9pZCAwLFxcXCJ1cGRhdGVcXFwiKTtlbHNlIGZvcihsZXQgcz1Tay5hYnN0ci5pdGVyKGkpLG49cy50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PW47bj1zLnRwJGl0ZXJuZXh0KCkpe2NvbnN0IHQ9dGhpcy5tcCRzdWJzY3JpcHQobik7dGhpcy5tcCRhc3Nfc3Vic2NyaXB0KG4sU2suYWJzdHIubnVtYmVyQmluT3AodCx0aGlzLiRvbmUsXFxcIkFkZFxcXCIpKX1pZihlJiZlLmxlbmd0aClpZih0aGlzLnNxJGxlbmd0aCgpKWZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cys9Mil7Y29uc3QgdD1uZXcgU2suYnVpbHRpbi5zdHIoZVtzXSksaT10aGlzLm1wJHN1YnNjcmlwdCh0KTt0aGlzLm1wJGFzc19zdWJzY3JpcHQodCxTay5hYnN0ci5udW1iZXJCaW5PcChpLGVbcysxXSxcXFwiQWRkXFxcIikpfWVsc2UgdGhpcy51cGRhdGUkY29tbW9uKFtdLGUsXFxcInVwZGF0ZVxcXCIpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9fSxjbGFzc21ldGhvZHM6e2Zyb21rZXlzOnskbWV0aDpmdW5jdGlvbiBmcm9ta2V5cygpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXFxcIkNvdW50ZXIuZnJvbWtleXMoKSBpcyB1bmRlZmluZWQuICBVc2UgQ291bnRlcihpdGVyYWJsZSkgaW5zdGVhZC5cXFwiKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfX19fSksdC5PcmRlcmVkRGljdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFxcXCJjb2xsZWN0aW9ucy5PcmRlcmVkRGljdFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIE9yZGVyZWREaWN0KCl7U2suYnVpbHRpbi5kaWN0LmNhbGwodGhpcyl9LGJhc2U6U2suYnVpbHRpbi5kaWN0LHNsb3RzOnt0cCRkb2M6XFxcIkRpY3Rpb25hcnkgdGhhdCByZW1lbWJlcnMgaW5zZXJ0aW9uIG9yZGVyXFxcIiwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIuLi5cXFwiKTt0aGlzLmluJHJlcHI9ITA7bGV0IHQ9dGhpcy4kaXRlbXMoKS5tYXAoKChbdCxlXSk9PmAoJHtTay5taXNjZXZhbC5vYmplY3RSZXByKHQpfSwgJHtTay5taXNjZXZhbC5vYmplY3RSZXByKGUpfSlgKSk7cmV0dXJuIHQ9MD09PXQubGVuZ3RoP1xcXCJcXFwiOlxcXCJbXFxcIit0LmpvaW4oXFxcIiwgXFxcIikrXFxcIl1cXFwiLHRoaXMuaW4kcmVwcj0hMSxuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXFxcIihcXFwiK3QrXFxcIilcXFwiKX0sdHAkcmljaGNvbXBhcmUoZSxpKXtpZihcXFwiRXFcXFwiIT09aSYmXFxcIk5lXFxcIiE9PWkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2lmKCEoZSBpbnN0YW5jZW9mIHQuT3JkZXJlZERpY3QpKXJldHVybiBTay5idWlsdGluLmRpY3QucHJvdG90eXBlLnRwJHJpY2hjb21wYXJlLmNhbGwodGhpcyxlLGkpO2NvbnN0IHM9XFxcIkVxXFxcIj09aSxuPXRoaXMuc2l6ZTtpZihuIT09ZS5zaXplKXJldHVybiFzO2NvbnN0IHI9ZS4kaXRlbXMoKSxhPXRoaXMuJGl0ZW1zKCk7Zm9yKGxldCB0PTA7dDxuO3QrKyl7Y29uc3QgZT1hW3RdLGk9clt0XSxuPWVbMF0sbz1pWzBdO2lmKG4hPT1vJiYhU2subWlzY2V2YWwuaXNUcnVlKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChuLG8sXFxcIkVxXFxcIikpKXJldHVybiFzO2NvbnN0IGw9ZVsxXSxoPWlbMV07aWYobCE9PWgmJiFTay5taXNjZXZhbC5pc1RydWUoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGwsaCxcXFwiRXFcXFwiKSkpcmV0dXJuIXN9cmV0dXJuIHN9fSxtZXRob2RzOntwb3BpdGVtOnskZmxhZ3M6e05hbWVkQXJnczpbXFxcImxhc3RcXFwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ib29sLnRydWUkXX0sJG1ldGgodCl7Y29uc3QgZT10aGlzLmdldCRzaXplKCk7aWYoMD09PWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uS2V5RXJyb3IoXFxcImRpY3Rpb25hcnkgaXMgZW1wdHlcXFwiKTtjb25zdFtpLHNdPXRoaXMuJGl0ZW1zKClbU2subWlzY2V2YWwuaXNUcnVlKHQpP2UtMTowXTtyZXR1cm4gdGhpcy5wb3AkaXRlbShpKSxuZXcgU2suYnVpbHRpbi50dXBsZShbaSxzXSl9fSxtb3ZlX3RvX2VuZDp7JGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJrZXlcXFwiLFxcXCJsYXN0XFxcIl0sRGVmYXVsdHM6W1NrLmJ1aWx0aW4uYm9vbC50cnVlJF19LCRtZXRoKHQsZSl7bGV0IGk7Zm9yKGxldCBuIGluIHRoaXMuZW50cmllcyl7Y29uc3QgZT10aGlzLmVudHJpZXNbbl1bMF07aWYoZT09PXR8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChlLHQsXFxcIkVxXFxcIikpe2k9bjticmVha319aWYodm9pZCAwPT09aSl0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcih0KTtjb25zdCBzPXRoaXMuZW50cmllc1tpXTtyZXR1cm4gZGVsZXRlIHRoaXMuZW50cmllc1tpXSxTay5taXNjZXZhbC5pc1RydWUoZSk/dGhpcy5lbnRyaWVzW2ldPXM6dGhpcy5lbnRyaWVzPXtbaV06cywuLi50aGlzLmVudHJpZXN9LFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19fX0pLHQuZGVxdWU9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcXFwiY29sbGVjdGlvbnMuZGVxdWVcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBkZXF1ZSh0LGUsaSxzLG4pe3RoaXMuaGVhZD1pfHwwLHRoaXMudGFpbD1zfHwwLHRoaXMubWFzaz1ufHwxLHRoaXMubWF4bGVuPWUsdGhpcy52PXR8fG5ldyBBcnJheSgyKX0sc2xvdHM6e3RwJGRvYzpcXFwiZGVxdWUoW2l0ZXJhYmxlWywgbWF4bGVuXV0pIC0tXFxcXHgzZSBkZXF1ZSBvYmplY3RcXFxcblxcXFxuQSBsaXN0LWxpa2Ugc2VxdWVuY2Ugb3B0aW1pemVkIGZvciBkYXRhIGFjY2Vzc2VzIG5lYXIgaXRzIGVuZHBvaW50cy5cXFwiLHRwJGhhc2g6U2suYnVpbHRpbi5ub25lLm5vbmUkLHRwJG5ldzpTay5nZW5lcmljLm5ldyx0cCRpbml0KHQsZSl7bGV0W2ksc109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcImRlcXVlXFxcIixbXFxcIml0ZXJhYmxlXFxcIixcXFwibWF4bGVuXFxcIl0sdCxlKTtpZih2b2lkIDAhPT1zJiYhU2suYnVpbHRpbi5jaGVja05vbmUocykpe2lmKHM9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHMsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yLFxcXCJhbiBpbnRlZ2VyIGlzIHJlcXVpcmVkXFxcIiksczwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1heGxlbiBtdXN0IGJlIG5vbi1uZWdhdGl2ZVxcXCIpO3RoaXMubWF4bGVuPXN9dGhpcy4kY2xlYXIoKSx2b2lkIDAhPT1pJiZ0aGlzLiRleHRlbmQoaSl9LHRwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJHJpY2hjb21wYXJlKGUsaSl7aWYodGhpcz09PWUmJlNrLm1pc2NldmFsLm9wQWxsb3dzRXF1YWxpdHkoaSkpcmV0dXJuITA7aWYoIShlIGluc3RhbmNlb2YgdC5kZXF1ZSkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IHM9ZSxuPXRoaXMudjtlPWUudjtjb25zdCByPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrLGE9cy50YWlsLXMuaGVhZCZzLm1hc2s7bGV0IG8sbD1NYXRoLm1heChyLGEpO2lmKHI9PT1hKWZvcihsPTA7bDxyJiZsPGEmJihvPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChuW3RoaXMuaGVhZCtsJnRoaXMubWFza10sZVtzLmhlYWQrbCZzLm1hc2tdLFxcXCJFcVxcXCIpLG8pOysrbCk7aWYobD49cnx8bD49YSlzd2l0Y2goaSl7Y2FzZVxcXCJMdFxcXCI6cmV0dXJuIHI8YTtjYXNlXFxcIkx0RVxcXCI6cmV0dXJuIHI8PWE7Y2FzZVxcXCJFcVxcXCI6cmV0dXJuIHI9PT1hO2Nhc2VcXFwiTm90RXFcXFwiOnJldHVybiByIT09YTtjYXNlXFxcIkd0XFxcIjpyZXR1cm4gcj5hO2Nhc2VcXFwiR3RFXFxcIjpyZXR1cm4gcj49YX1yZXR1cm5cXFwiRXFcXFwiIT09aSYmKFxcXCJOb3RFcVxcXCI9PT1pfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woblt0aGlzLmhlYWQrbCZ0aGlzLm1hc2tdLGVbcy5oZWFkK2wmcy5tYXNrXSxpKSl9LHRwJGl0ZXIoKXtyZXR1cm4gbmV3IGUodGhpcyl9LCRyKCl7Y29uc3QgdD1bXSxlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2lmKHRoaXMuJGVudGVyZWRfcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJbLi4uXVxcXCIpO3RoaXMuJGVudGVyZWRfcmVwcj0hMDtmb3IobGV0IHM9MDtzPGU7cysrKXQucHVzaChTay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMudlt0aGlzLmhlYWQrcyZ0aGlzLm1hc2tdKSk7Y29uc3QgaT1Tay5hYnN0ci50eXBlTmFtZSh0aGlzKTtyZXR1cm4gdm9pZCAwIT09dGhpcy5tYXhsZW4/bmV3IFNrLmJ1aWx0aW4uc3RyKGkrXFxcIihbXFxcIit0LmZpbHRlcihCb29sZWFuKS5qb2luKFxcXCIsIFxcXCIpK1xcXCJdLCBtYXhsZW49XFxcIit0aGlzLm1heGxlbitcXFwiKVxcXCIpOih0aGlzLiRlbnRlcmVkX3JlcHI9dm9pZCAwLG5ldyBTay5idWlsdGluLnN0cihpK1xcXCIoW1xcXCIrdC5maWx0ZXIoQm9vbGVhbikuam9pbihcXFwiLCBcXFwiKStcXFwiXSlcXFwiKSl9LHRwJGFzX251bWJlcjohMCxuYiRib29sKCl7cmV0dXJuIDAhPSh0aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzayl9LHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsc3EkY29udGFpbnModCl7Zm9yKGxldCBlPXRoaXMudHAkaXRlcigpLGk9ZS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWk7aT1lLnRwJGl0ZXJuZXh0KCkpaWYoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGksdCxcXFwiRXFcXFwiKSlyZXR1cm4hMDtyZXR1cm4hMX0sc3EkY29uY2F0KGUpe2lmKCEoZSBpbnN0YW5jZW9mIHQuZGVxdWUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiY2FuIG9ubHkgY29uY2F0ZW5hdGUgZGVxdWUgKG5vdCAnXFxcIitTay5hYnN0ci50eXBlTmFtZShlKStcXFwiJykgdG8gZGVxdWVcXFwiKTtjb25zdCBpPXRoaXMuJGNvcHkoKTtmb3IobGV0IHQ9ZS50cCRpdGVyKCkscz10LnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09cztzPXQudHAkaXRlcm5leHQoKSlpLiRwdXNoKHMpO3JldHVybiBpfSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2t9LHNxJHJlcGVhdCh0KXt0PVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KHQsXFxcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAne3RwJG5hbWV9J1xcXCIpO2NvbnN0IGU9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2ssaT10aGlzLiRjb3B5KCk7bGV0IHM7dDw9MCYmaS4kY2xlYXIoKTtmb3IobGV0IG49MTtuPHQ7bisrKWZvcihsZXQgdD0wO3Q8ZTt0Kyspcz10aGlzLmhlYWQrdCZ0aGlzLm1hc2ssaS4kcHVzaCh0aGlzLnZbc10pO3JldHVybiBpfSxtcCRzdWJzY3JpcHQodCl7dD1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyh0KTtjb25zdCBlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2lmKHQ+PWV8fHQ8LWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcXFwiZGVxdWUgaW5kZXggb3V0IG9mIHJhbmdlXFxcIik7Y29uc3QgaT0odD49MD90aGlzLmhlYWQ6dGhpcy50YWlsKSt0JnRoaXMubWFzaztyZXR1cm4gdGhpcy52W2ldfSxtcCRhc3Nfc3Vic2NyaXB0KHQsZSl7dD1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyh0KTtjb25zdCBpPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2lmKHQ+PWl8fHQ8LWkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcXFwiZGVxdWUgaW5kZXggb3V0IG9mIHJhbmdlXFxcIik7dm9pZCAwPT09ZT90aGlzLmRlbCRpdGVtKHQpOnRoaXMuc2V0JGl0ZW0odCxlKX0sbmIkaW5wbGFjZV9hZGQodCl7dGhpcy5tYXhsZW49dm9pZCAwO2ZvcihsZXQgZT1Tay5hYnN0ci5pdGVyKHQpLGk9ZS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWk7aT1lLnRwJGl0ZXJuZXh0KCkpdGhpcy4kcHVzaChpKTtyZXR1cm4gdGhpc30sbmIkaW5wbGFjZV9tdWx0aXBseSh0KXsodD1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQodCxTay5idWlsdGluLk92ZXJmbG93RXJyb3IsXFxcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAne3RwJG5hbWV9J1xcXCIpKTw9MCYmdGhpcy4kY2xlYXIoKTtjb25zdCBlPXRoaXMuJGNvcHkoKSxpPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2ZvcihsZXQgcz0xO3M8dDtzKyspZm9yKGxldCB0PTA7dDxpO3QrKyl7Y29uc3QgaT10aGlzLmhlYWQrdCZ0aGlzLm1hc2s7ZS4kcHVzaCh0aGlzLnZbaV0pfXJldHVybiB0aGlzLnY9ZS52LHRoaXMuaGVhZD1lLmhlYWQsdGhpcy50YWlsPWUudGFpbCx0aGlzLm1hc2s9ZS5tYXNrLHRoaXN9fSxtZXRob2RzOnthcHBlbmQ6eyRtZXRoKHQpe3JldHVybiB0aGlzLiRwdXNoKHQpLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiQWRkIGFuIGVsZW1lbnQgdG8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGRlcXVlLlxcXCJ9LGFwcGVuZGxlZnQ6eyRtZXRoKHQpe3JldHVybiB0aGlzLiRwdXNoTGVmdCh0KSxTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkFkZCBhbiBlbGVtZW50IHRvIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGRlcXVlLlxcXCJ9LGNsZWFyOnskbWV0aCgpe3JldHVybiB0aGlzLiRjbGVhcigpLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBkZXF1ZS5cXFwifSxfX2NvcHlfXzp7JG1ldGgoKXtyZXR1cm4gdGhpcy4kY29weSgpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gYSBzaGFsbG93IGNvcHkgb2YgYSBkZXF1ZS5cXFwifSxjb3B5OnskbWV0aCgpe3JldHVybiB0aGlzLiRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBhIHNoYWxsb3cgY29weSBvZiBhIGRlcXVlLlxcXCJ9LGNvdW50OnskbWV0aCh0KXtjb25zdCBlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2xldCBpPTA7Zm9yKGxldCBzPTA7czxlO3MrKylTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy52W3RoaXMuaGVhZCtzJnRoaXMubWFza10sdCxcXFwiRXFcXFwiKSYmaSsrO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJELmNvdW50KHZhbHVlKSAtPiBpbnRlZ2VyIC0tIHJldHVybiBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdmFsdWVcXFwifSxleHRlbmQ6eyRtZXRoKHQpe3JldHVybiB0aGlzLiRleHRlbmQodCksU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJFeHRlbmQgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGRlcXVlIHdpdGggZWxlbWVudHMgZnJvbSB0aGUgaXRlcmFibGVcXFwifSxleHRlbmRsZWZ0OnskbWV0aCh0KXtmb3IobGV0IGU9U2suYWJzdHIuaXRlcih0KSxpPWUudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9ZS50cCRpdGVybmV4dCgpKXRoaXMuJHB1c2hMZWZ0KGkpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkV4dGVuZCB0aGUgbGVmdCBzaWRlIG9mIHRoZSBkZXF1ZSB3aXRoIGVsZW1lbnRzIGZyb20gdGhlIGl0ZXJhYmxlXFxcIn0saW5kZXg6eyRtZXRoKHQsZSxpKXtjb25zdCBzPXRoaXMuJGluZGV4KHQsZSxpKTtpZih2b2lkIDAhPT1zKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHMpO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoU2subWlzY2V2YWwub2JqZWN0UmVwcih0KStcXFwiIGlzIG5vdCBpbiBkZXF1ZVxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRC5pbmRleCh2YWx1ZSwgW3N0YXJ0LCBbc3RvcF1dKSAtPiBpbnRlZ2VyIC0tIHJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZS5cXFxcblJhaXNlcyBWYWx1ZUVycm9yIGlmIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudC5cXFwifSxpbnNlcnQ6eyRtZXRoKHQsZSl7dD1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyh0LFxcXCJpbnRlZ2VyIGFyZ3VtZW50IGV4cGVjdGVkLCBnb3Qge3RwJG5hbWV9XFxcIik7Y29uc3QgaT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztpZih2b2lkIDAhPT10aGlzLm1heGxlbiYmaT49dGhpcy5tYXhsZW4pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcXFwiZGVxdWUgYWxyZWFkeSBhdCBpdHMgbWF4aW11bSBzaXplXFxcIik7dD5pJiYodD1pKSx0PD0taSYmKHQ9MCk7Y29uc3Qgcz0odD49MD90aGlzLmhlYWQ6dGhpcy50YWlsKSt0JnRoaXMubWFzaztsZXQgbj10aGlzLnRhaWw7Zm9yKHRoaXMudGFpbD10aGlzLnRhaWwrMSZ0aGlzLm1hc2s7biE9PXM7KXtjb25zdCB0PW4tMSZ0aGlzLm1hc2s7dGhpcy52W25dPXRoaXMudlt0XSxuPXR9cmV0dXJuIHRoaXMudltzXT1lLHRoaXMuaGVhZD09PXRoaXMudGFpbCYmdGhpcy4kcmVzaXplKHRoaXMudi5sZW5ndGgsdGhpcy52Lmxlbmd0aDw8MSksU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRC5pbnNlcnQoaW5kZXgsIG9iamVjdCkgLS0gaW5zZXJ0IG9iamVjdCBiZWZvcmUgaW5kZXhcXFwifSxwb3A6eyRtZXRoKCl7cmV0dXJuIHRoaXMuJHBvcCgpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZW1vdmUgYW5kIHJldHVybiB0aGUgcmlnaHRtb3N0IGVsZW1lbnQuXFxcIn0scG9wbGVmdDp7JG1ldGgoKXtyZXR1cm4gdGhpcy4kcG9wTGVmdCgpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZW1vdmUgYW5kIHJldHVybiB0aGUgbGVmdG1vc3QgZWxlbWVudC5cXFwifSxyZW1vdmU6eyRtZXRoKHQpe2NvbnN0IGU9dGhpcy4kaW5kZXgodCk7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIodCkrXFxcIiBpcyBub3QgaW4gZGVxdWVcXFwiKTtsZXQgaT10aGlzLmhlYWQrZSZ0aGlzLm1hc2s7Zm9yKDtpIT09dGhpcy50YWlsOyl7Y29uc3QgdD1pKzEmdGhpcy5tYXNrO3RoaXMudltpXT10aGlzLnZbdF0saT10fXRoaXMudGFpbD10aGlzLnRhaWwtMSZ0aGlzLm1hc2s7dmFyIHM9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7czx0aGlzLm1hc2s+Pj4xJiZ0aGlzLiRyZXNpemUocyx0aGlzLnYubGVuZ3RoPj4+MSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkQucmVtb3ZlKHZhbHVlKSAtLSByZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB2YWx1ZS5cXFwifSxfX3JldmVyc2VkX186eyRtZXRoKCl7cmV0dXJuIG5ldyBpKHRoaXMpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJELl9fcmV2ZXJzZWRfXygpIC0tIHJldHVybiBhIHJldmVyc2UgaXRlcmF0b3Igb3ZlciB0aGUgZGVxdWVcXFwifSxyZXZlcnNlOnskbWV0aCgpe2NvbnN0IHQ9dGhpcy5oZWFkLGU9dGhpcy50YWlsLGk9dGhpcy5tYXNrLHM9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7Zm9yKGxldCBuPTA7bjx+fihzLzIpO24rKyl7Y29uc3Qgcz1lLW4tMSZpLHI9dCtuJmksYT10aGlzLnZbc107dGhpcy52W3NdPXRoaXMudltyXSx0aGlzLnZbcl09YX1yZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJELnJldmVyc2UoKSAtLSByZXZlcnNlICpJTiBQTEFDRSpcXFwifSxyb3RhdGU6eyRtZXRoKHQpe3Q9dm9pZCAwPT09dD8xOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh0LFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7Y29uc3QgZT10aGlzLmhlYWQsaT10aGlzLnRhaWw7aWYoMD09PXR8fGU9PT1pKXJldHVybiB0aGlzO2lmKHRoaXMuaGVhZD1lLXQmdGhpcy5tYXNrLHRoaXMudGFpbD1pLXQmdGhpcy5tYXNrLHQ+MClmb3IobGV0IHM9MTtzPD10O3MrKyl7Y29uc3QgdD1lLXMmdGhpcy5tYXNrLG49aS1zJnRoaXMubWFzazt0aGlzLnZbdF09dGhpcy52W25dLHRoaXMudltuXT12b2lkIDB9ZWxzZSBmb3IobGV0IHM9MDtzPnQ7cy0tKXtjb25zdCB0PWktcyZ0aGlzLm1hc2ssbj1lLXMmdGhpcy5tYXNrO3RoaXMudlt0XT10aGlzLnZbbl0sdGhpcy52W25dPXZvaWQgMH1yZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUm90YXRlIHRoZSBkZXF1ZSBuIHN0ZXBzIHRvIHRoZSByaWdodCAoZGVmYXVsdCBuPTEpLiAgSWYgbiBpcyBuZWdhdGl2ZSwgcm90YXRlcyBsZWZ0LlxcXCJ9fSxjbGFzc21ldGhvZHM6U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW0sZ2V0c2V0czp7bWF4bGVuOnskZ2V0KCl7cmV0dXJuIHZvaWQgMD09PXRoaXMubWF4bGVuP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMubWF4bGVuKX0sJGRvYzpcXFwibWF4aW11bSBzaXplIG9mIGEgZGVxdWUgb3IgTm9uZSBpZiB1bmJvdW5kZWRcXFwifX0scHJvdG86eyRjbGVhcigpe3RoaXMuaGVhZD0wLHRoaXMudGFpbD0wLHRoaXMubWFzaz0xLHRoaXMudj1uZXcgQXJyYXkoMil9LCRjb3B5KCl7cmV0dXJuIG5ldyB0LmRlcXVlKHRoaXMudi5zbGljZSgwKSx0aGlzLm1heGxlbix0aGlzLmhlYWQsdGhpcy50YWlsLHRoaXMubWFzayl9LCRleHRlbmQodCl7Zm9yKGxldCBlPVNrLmFic3RyLml0ZXIodCksaT1lLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09aTtpPWUudHAkaXRlcm5leHQoKSl0aGlzLiRwdXNoKGkpfSxzZXQkaXRlbSh0LGUpe2NvbnN0IGk9KHQ+PTA/dGhpcy5oZWFkOnRoaXMudGFpbCkrdCZ0aGlzLm1hc2s7dGhpcy52W2ldPWV9LGRlbCRpdGVtKHQpe2xldCBlPSh0Pj0wP3RoaXMuaGVhZDp0aGlzLnRhaWwpK3QmdGhpcy5tYXNrO2Zvcig7ZSE9PXRoaXMudGFpbDspe2NvbnN0IHQ9ZSsxJnRoaXMubWFzazt0aGlzLnZbZV09dGhpcy52W3RdLGU9dH1jb25zdCBpPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO3RoaXMudGFpbD10aGlzLnRhaWwtMSZ0aGlzLm1hc2ssaTx0aGlzLm1hc2s+Pj4xJiZ0aGlzLiRyZXNpemUoaSx0aGlzLnYubGVuZ3RoPj4+MSl9LCRwdXNoKHQpe3RoaXMudlt0aGlzLnRhaWxdPXQsdGhpcy50YWlsPXRoaXMudGFpbCsxJnRoaXMubWFzayx0aGlzLmhlYWQ9PT10aGlzLnRhaWwmJnRoaXMuJHJlc2l6ZSh0aGlzLnYubGVuZ3RoLHRoaXMudi5sZW5ndGg8PDEpO2NvbnN0IGU9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7cmV0dXJuIHZvaWQgMCE9PXRoaXMubWF4bGVuJiZlPnRoaXMubWF4bGVuJiZ0aGlzLiRwb3BMZWZ0KCksdGhpc30sJHB1c2hMZWZ0KHQpe3RoaXMuaGVhZD10aGlzLmhlYWQtMSZ0aGlzLm1hc2ssdGhpcy52W3RoaXMuaGVhZF09dCx0aGlzLmhlYWQ9PT10aGlzLnRhaWwmJnRoaXMuJHJlc2l6ZSh0aGlzLnYubGVuZ3RoLHRoaXMudi5sZW5ndGg8PDEpO2NvbnN0IGU9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7cmV0dXJuIHZvaWQgMCE9PXRoaXMubWF4bGVuJiZlPnRoaXMubWF4bGVuJiZ0aGlzLiRwb3AoKSx0aGlzfSwkcG9wKCl7aWYodGhpcy5oZWFkPT09dGhpcy50YWlsKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXFxcInBvcCBmcm9tIGFuIGVtcHR5IGRlcXVlXFxcIik7dGhpcy50YWlsPXRoaXMudGFpbC0xJnRoaXMubWFzaztjb25zdCB0PXRoaXMudlt0aGlzLnRhaWxdO3RoaXMudlt0aGlzLnRhaWxdPXZvaWQgMDtjb25zdCBlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO3JldHVybiBlPHRoaXMubWFzaz4+PjEmJnRoaXMuJHJlc2l6ZShlLHRoaXMudi5sZW5ndGg+Pj4xKSx0fSwkcG9wTGVmdCgpe2lmKHRoaXMuaGVhZD09PXRoaXMudGFpbCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFxcXCJwb3AgZnJvbSBhbiBlbXB0eSBkZXF1ZVxcXCIpO2NvbnN0IHQ9dGhpcy52W3RoaXMuaGVhZF07dGhpcy52W3RoaXMuaGVhZF09dm9pZCAwLHRoaXMuaGVhZD10aGlzLmhlYWQrMSZ0aGlzLm1hc2s7Y29uc3QgZT10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztyZXR1cm4gZTx0aGlzLm1hc2s+Pj4xJiZ0aGlzLiRyZXNpemUoZSx0aGlzLnYubGVuZ3RoPj4+MSksdH0sJHJlc2l6ZSh0LGUpe2NvbnN0IGk9dGhpcy5oZWFkLHM9dGhpcy5tYXNrO2lmKHRoaXMuaGVhZD0wLHRoaXMudGFpbD10LHRoaXMubWFzaz1lLTEsMD09PWkpcmV0dXJuIHZvaWQodGhpcy52Lmxlbmd0aD1lKTtjb25zdCBuPW5ldyBBcnJheShlKTtmb3IobGV0IHI9MDtyPHQ7cisrKW5bcl09dGhpcy52W2krciZzXTt0aGlzLnY9bn0sJGluZGV4KHQsZSxpKXtjb25zdCBzPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2U9dm9pZCAwPT09ZT8wOlNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGUpLGk9dm9pZCAwPT09aT9zOlNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGkpO2NvbnN0IG49dGhpcy5oZWFkLHI9dGhpcy5tYXNrLGE9dGhpcy52O2k9aT49MD9pOmk8LXM/MDpzK2k7Zm9yKGxldCBvPWU+PTA/ZTplPC1zPzA6cytlO288aTtvKyspaWYoYVtuK28mcl09PT10KXJldHVybiBvfSxzayRhc2FycmF5KCl7Y29uc3QgdD1bXSxlPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2ZvcihsZXQgaT0wO2k8ZTsrK2kpe2NvbnN0IGU9dGhpcy5oZWFkK2kmdGhpcy5tYXNrO3QucHVzaCh0aGlzLnZbZV0pfXJldHVybiB0fX19KTtjb25zdCBlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiX2NvbGxlY3Rpb25zLl9kZXF1ZV9pdGVyYXRvclxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIF9kZXF1ZV9pdGVyYXRvcih0KXt0aGlzLiRpbmRleD0wLHRoaXMuZHE9dC52LHRoaXMuJGxlbmd0aD10LnRhaWwtdC5oZWFkJnQubWFzayx0aGlzLiRoZWFkPXQuaGVhZCx0aGlzLiR0YWlsPXQudGFpbCx0aGlzLiRtYXNrPXQubWFza30saXRlcm5leHQoKXtpZih0aGlzLiRpbmRleD49dGhpcy4kbGVuZ3RoKXJldHVybjtjb25zdCB0PSh0aGlzLiRpbmRleD49MD90aGlzLiRoZWFkOnRoaXMuJHRhaWwpK3RoaXMuJGluZGV4JnRoaXMuJG1hc2s7cmV0dXJuIHRoaXMuJGluZGV4KyssdGhpcy5kcVt0XX0sbWV0aG9kczp7X19sZW5ndGhfaGludF9fOnskbWV0aDpmdW5jdGlvbiBfX2xlbmd0aF9oaW50X18oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRsZW5ndGgtdGhpcy4kaW5kZXgpfSwkZmxhZ3M6e05vQXJnczohMH19fX0pLGk9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJfY29sbGVjdGlvbnMuX2RlcXVlX3JldmVyc2VfaXRlcmF0b3JcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBfZGVxdWVfcmV2ZXJzZV9pdGVyYXRvcih0KXt0aGlzLiRpbmRleD0odC50YWlsLXQuaGVhZCZ0Lm1hc2spLTEsdGhpcy5kcT10LnYsdGhpcy4kaGVhZD10LmhlYWQsdGhpcy4kbWFzaz10Lm1hc2t9LGl0ZXJuZXh0KCl7aWYodGhpcy4kaW5kZXg8MClyZXR1cm47Y29uc3QgdD10aGlzLiRoZWFkK3RoaXMuJGluZGV4JnRoaXMuJG1hc2s7cmV0dXJuIHRoaXMuJGluZGV4LS0sdGhpcy5kcVt0XX0sbWV0aG9kczp7X19sZW5ndGhfaGludF9fOlNrLmdlbmVyaWMuaXRlclJldmVyc2VMZW5ndGhIaW50TWV0aG9kRGVmfX0pLHM9bmV3IFJlZ0V4cCgvXlswLTldLiovKSxuPW5ldyBSZWdFeHAoL15bMC05X10uKi8pLHI9bmV3IFJlZ0V4cCgvXlxcXFx3KiQvKSxhPS8sL2csbz0vXFxcXHMrLztmdW5jdGlvbiBuYW1lZHR1cGxlKGUsaSxsLGgsYyl7aWYoZT1lLnRwJHN0cigpLFNrLm1pc2NldmFsLmlzVHJ1ZShTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5faXNrZXl3b3JkLFtlXSkpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlR5cGUgbmFtZXMgYW5kIGZpZWxkIG5hbWVzIGNhbm5vdCBiZSBhIGtleXdvcmQ6ICdcXFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIoZSkrXFxcIidcXFwiKTtjb25zdCB1PWUuJGpzc3RyKCk7aWYocy50ZXN0KHUpfHwhci50ZXN0KHUpfHwhdSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJUeXBlIG5hbWVzIGFuZCBmaWVsZCBuYW1lcyBtdXN0IGJlIHZhbGlkIGlkZW50aWZpZXJzOiAnXFxcIit1K1xcXCInXFxcIik7bGV0IG0sZDtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGkpKW09aS4kanNzdHIoKS5yZXBsYWNlKGEsXFxcIiBcXFwiKS5zcGxpdChvKSwxPT1tLmxlbmd0aCYmXFxcIlxcXCI9PT1tWzBdJiYobT1bXSksZD1tLm1hcCgodD0+bmV3IFNrLmJ1aWx0aW4uc3RyKHQpKSk7ZWxzZXttPVtdLGQ9W107Zm9yKGxldCB0PVNrLmFic3RyLml0ZXIoaSksZT10LnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09ZTtlPXQudHAkaXRlcm5leHQoKSllPWUudHAkc3RyKCksZC5wdXNoKGUpLG0ucHVzaChlLiRqc3N0cigpKX1sZXQgcD1uZXcgU2V0O2lmKFNrLm1pc2NldmFsLmlzVHJ1ZShsKSlmb3IobGV0IHM9MDtzPG0ubGVuZ3RoO3MrKykoU2subWlzY2V2YWwuaXNUcnVlKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0Ll9pc2tleXdvcmQsW2Rbc11dKSl8fG4udGVzdChtW3NdKXx8IXIudGVzdChtW3NdKXx8IW1bc118fHAuaGFzKG1bc10pKSYmKG1bc109XFxcIl9cXFwiK3MsZFtzXT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIl9cXFwiK3MpKSxwLmFkZChtW3NdKTtlbHNlIGZvcihsZXQgcz0wO3M8bS5sZW5ndGg7cysrKXtpZihTay5taXNjZXZhbC5pc1RydWUoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHQuX2lza2V5d29yZCxbZFtzXV0pKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJUeXBlIG5hbWVzIGFuZCBmaWVsZCBuYW1lcyBjYW5ub3QgYmUgYSBrZXl3b3JkOiAnXFxcIittW3NdK1xcXCInXFxcIik7aWYobi50ZXN0KG1bc10pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkZpZWxkIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmU6ICdcXFwiK21bc10rXFxcIidcXFwiKTtpZighci50ZXN0KG1bc10pfHwhbVtzXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJUeXBlIG5hbWVzIGFuZCBmaWVsZCBuYW1lcyBtdXN0IGJlIHZhbGlkIGlkZW50aWZpZXJzOiAnXFxcIittW3NdK1xcXCInXFxcIik7aWYocC5oYXMobVtzXSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiRW5jb3VudGVyZWQgZHVwbGljYXRlIGZpZWxkIG5hbWU6ICdcXFwiK21bc10rXFxcIidcXFwiKTtwLmFkZChtW3NdKX1jb25zdCAkPW5ldyBTay5idWlsdGluLnR1cGxlKGQpLGs9W107bGV0IGI9W107aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGgpKXtpZihiPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGgpLGIubGVuZ3RoPm0ubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiR290IG1vcmUgZGVmYXVsdCB2YWx1ZXMgdGhhbiBmaWVsZCBuYW1lc1xcXCIpO2ZvcihsZXQgdD0wLGU9ZC5sZW5ndGgtYi5sZW5ndGg7ZTxkLmxlbmd0aDt0KyssZSsrKWsucHVzaChkW2VdKSxrLnB1c2goYlt0XSl9Y29uc3QgZj1uZXcgU2suYnVpbHRpbi5kaWN0KGspO2Z1bmN0aW9uIF9tYWtlKHQsZSl7cmV0dXJuIHQucHJvdG90eXBlLnRwJG5ldyhTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShlKSl9ZnVuY3Rpb24gX2FzZGljdCh0KXtjb25zdCBlPVtdO2ZvcihsZXQgaT0wO2k8dC5fZmllbGRzLnYubGVuZ3RoO2krKyllLnB1c2godC5fZmllbGRzLnZbaV0pLGUucHVzaCh0LnZbaV0pO3JldHVybiBuZXcgU2suYnVpbHRpbi5kaWN0KGUpfWZ1bmN0aW9uIF9yZXBsYWNlKHQsZSl7Y29uc3QgaT0odD1uZXcgU2suYnVpbHRpbi5kaWN0KHQpKS50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcXFwicG9wXFxcIikpLHM9U2suYWJzdHIuZ2F0dHIoZSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIl9tYWtlXFxcIikpLG49U2subWlzY2V2YWwuY2FsbHNpbUFycmF5LHI9bihzLFtuKFNrLmJ1aWx0aW4ubWFwXyxbaSwkLGVdKV0pO2lmKHQuc3EkbGVuZ3RoKCkpe2NvbnN0IGU9dC5zayRhc2FycmF5KCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiR290IHVuZXhwZWN0ZCBmaWVsZCBuYW1lczogW1xcXCIrZS5tYXAoKHQ9PlxcXCInXFxcIit0LiRqc3N0cigpK1xcXCInXFxcIikpK1xcXCJdXFxcIil9cmV0dXJuIHJ9X21ha2UuY29fdmFybmFtZXM9W1xcXCJfY2xzXFxcIixcXFwiaXRlcmFibGVcXFwiXSxfYXNkaWN0LmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCJdLF9yZXBsYWNlLmNvX2t3YXJncz0xLF9yZXBsYWNlLmNvX3Zhcm5hbWVzPVtcXFwiX3NlbGZcXFwiXTtjb25zdCBTPXt9O2ZvcihsZXQgcz0wO3M8bS5sZW5ndGg7cysrKVNbZFtzXS4kbWFuZ2xlZF09bmV3IFNrLmJ1aWx0aW4ucHJvcGVydHkobmV3IHQuX2l0ZW1nZXR0ZXIoW25ldyBTay5idWlsdGluLmludF8ocyldKSx2b2lkIDAsdm9pZCAwLG5ldyBTay5idWlsdGluLnN0cihcXFwiQWxpYXMgZm9yIGZpZWxkIG51bWJlciBcXFwiK3MpKTtyZXR1cm4gU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyh1LHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBOYW1lZFR1cGxlKCl7fSxiYXNlOlNrLmJ1aWx0aW4udHVwbGUsc2xvdHM6e3RwJGRvYzp1K1xcXCIoXFxcIittLmpvaW4oXFxcIiwgXFxcIikrXFxcIilcXFwiLHRwJG5ldyh0LGUpe3Q9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcIl9fbmV3X19cXFwiLG0sdCxlLGIpO2NvbnN0IGk9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIFNrLmJ1aWx0aW4udHVwbGUuY2FsbChpLHQpLGl9LCRyKCl7Y29uc3QgdD10aGlzLnYubWFwKCgodCxlKT0+bVtlXStcXFwiPVxcXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcih0KSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXFxcIihcXFwiK3Quam9pbihcXFwiLCBcXFwiKStcXFwiKVxcXCIpfX0sZmxhZ3M6e3NrJGtsYXNzOiEwfSxwcm90bzpPYmplY3QuYXNzaWduKHtfX21vZHVsZV9fOlNrLmJ1aWx0aW4uY2hlY2tOb25lKGMpP1NrLmdsb2JhbHMuX19uYW1lX186YyxfX3Nsb3RzX186bmV3IFNrLmJ1aWx0aW4udHVwbGUsX2ZpZWxkczokLF9maWVsZF9kZWZhdWx0czpmLF9tYWtlOm5ldyBTay5idWlsdGluLmNsYXNzbWV0aG9kKG5ldyBTay5idWlsdGluLmZ1bmMoX21ha2UpKSxfYXNkaWN0Om5ldyBTay5idWlsdGluLmZ1bmMoX2FzZGljdCksX3JlcGxhY2U6bmV3IFNrLmJ1aWx0aW4uZnVuYyhfcmVwbGFjZSl9LFMpfSl9cmV0dXJuIG5hbWVkdHVwbGUuY29fYXJnY291bnQ9MixuYW1lZHR1cGxlLmNvX2t3b25seWFyZ2NvdW50PTMsbmFtZWR0dXBsZS4ka3dkZWZzPVtTay5idWlsdGluLmJvb2wuZmFsc2UkLFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLm5vbmUubm9uZSRdLG5hbWVkdHVwbGUuY29fdmFybmFtZXM9W1xcXCJ0eXBlbmFtZVxcXCIsXFxcImZpZWxkX25hbWVzXFxcIixcXFwicmVuYW1lXFxcIixcXFwiZGVmYXVsdHNcXFwiLFxcXCJtb2R1bGVcXFwiXSx0Lm5hbWVkdHVwbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhuYW1lZHR1cGxlKSx0fVwiLFwic3JjL2xpYi9kYXRldGltZS5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUoKXtjb25zdHtpc1RydWU6dCxyaWNoQ29tcGFyZUJvb2w6ZSxhc0luZGV4T3JUaHJvdzpuLGFzSW5kZXhTaXplZDppLG9iamVjdFJlcHI6cyxvcEFsbG93c0VxdWFsaXR5Om8sY2FsbHNpbUFycmF5OnIsY2FsbHNpbU9yU3VzcGVuZEFycmF5OmF9PVNrLm1pc2NldmFsLHtudW1iZXJCaW5PcDokLHR5cGVOYW1lOmMsYnVpbGROYXRpdmVDbGFzczpoLGNoZWNrQXJnc0xlbjptLG9iamVjdEhhc2g6dSxjb3B5S2V5d29yZHNUb05hbWVkQXJnczpsfT1Tay5hYnN0cix7aW50XzpmLGZsb2F0XzpkLHN0cjp3LGJ5dGVzOl8sdHVwbGU6cCxib29sOnt0cnVlJDpnfSxub25lOntub25lJDp5fSxOb3RJbXBsZW1lbnRlZDp7Tm90SW1wbGVtZW50ZWQkOmJ9LFR5cGVFcnJvcjp6LFZhbHVlRXJyb3I6dixPdmVyZmxvd0Vycm9yOk0sWmVyb0RpdmlzaW9uRXJyb3I6QSxOb3RJbXBsZW1lbnRlZEVycm9yOngsY2hlY2tOdW1iZXI6TixjaGVja0Zsb2F0OlMsY2hlY2tTdHJpbmc6ayxjaGVja0ludDpPLGFzbnVtJDpJLHJvdW5kOkUsZ2V0YXR0cjpUfT1Tay5idWlsdGluLHtyZW1hcFRvUHk6RCxyZW1hcFRvSnM6Un09U2suZmZpLGludFJvdW5kPXQ9PkUodCkubmIkaW50KCkscT0kLEM9bmV3IHcoXFxcImF1dG9cXFwiKSxVPW5ldyB3KFxcXCJ1dGNvZmZzZXRcXFwiKSxZPW5ldyB3KFxcXCJ0em5hbWVcXFwiKSxqPW5ldyB3KFxcXCJhc19pbnRlZ2VyX3JhdGlvXFxcIiksRj1uZXcgdyhcXFwiZHN0XFxcIiksSD1uZXcgdyhcXFwiaXNvZm9ybWF0XFxcIiksSj1uZXcgdyhcXFwicmVwbGFjZVxcXCIpLEI9bmV3IHcoXFxcImZyb210aW1lc3RhbXBcXFwiKSxHPW5ldyB3KFxcXCJmcm9tb3JkaW5hbFxcXCIpLEw9bmV3IHcoXFxcInV0Y2Zyb210aW1lc3RhbXBcXFwiKSxYPW5ldyB3KFxcXCJzdHJmdGltZVxcXCIpLFA9bmV3IHcoXFxcImZyb211dGNcXFwiKSxXPW5ldyBmKDApLFo9bmV3IGQoMCksSz1uZXcgZig3KSxWPW5ldyBmKDYwKSxRPW5ldyBmKDM2MDApLHR0PW5ldyBmKDFlMyksZXQ9bmV3IGYoMWU2KSxudD1uZXcgZCgxZTYpLGl0PW5ldyBmKDg2NDAwKSxzdD1uZXcgZCg4NjQwMCk7bGV0IG90PW51bGw7ZnVuY3Rpb24gcHlEaXZNb2QodCxlKXtyZXR1cm4gcSh0LGUsXFxcIkRpdk1vZFxcXCIpLnZ9ZnVuY3Rpb24gJGRpdk1vZCh0LGUpe2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgdHx8XFxcIm51bWJlclxcXCIhPXR5cGVvZiBlKXJldHVybiB0PUpTQkkuQmlnSW50KHQpLGU9SlNCSS5CaWdJbnQoZSksW0pTQkkudG9OdW1iZXIoSlNCSS5kaXZpZGUodCxlKSksSlNCSS50b051bWJlcihKU0JJLnJlbWFpbmRlcih0LGUpKV07aWYoMD09PWUpdGhyb3cgbmV3IEEoXFxcImludGVnZXIgZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cXFwiKTtyZXR1cm5bTWF0aC5mbG9vcih0L2UpLHQtTWF0aC5mbG9vcih0L2UpKmVdfWZ1bmN0aW9uIG1vZGYodCl7Y29uc3QgZT0odD1JKHQpKTwwPy0xOjE7cmV0dXJuIHQ9TWF0aC5hYnModCksW25ldyBkKGUqKHQtTWF0aC5mbG9vcih0KSkpLG5ldyBkKGUqTWF0aC5mbG9vcih0KSldfWZ1bmN0aW9uIF9kKHQsZT1cXFwiMFxcXCIsbj0yKXtyZXR1cm4gdC50b1N0cmluZygpLnBhZFN0YXJ0KG4sZSl9Y29uc3QgcnQ9L15bMC05XSskLztmdW5jdGlvbiBfYXNfaW50ZWdlcih0KXtpZighcnQudGVzdCh0KSl0aHJvdyBuZXcgRXJyb3I7cmV0dXJuIHBhcnNlSW50KHQpfWZ1bmN0aW9uIF9hc19pbnRfcmF0aW8odCl7bGV0IGU9cih0LnRwJGdldGF0dHIoaikpO2lmKCEoZSBpbnN0YW5jZW9mIHApKXRocm93IG5ldyB6KFxcXCJ1bmV4cGVjdGVkIHJldHVybiB0eXBlIGZyb20gYXNfaW50ZWdlcl9yYXRpbygpOiBleHBlY3RlZCB0dXBsZSwgZ290ICdcXFwiK2MoZSkrXFxcIidcXFwiKTtpZihlPWUudiwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IHYoXFxcImFzX2ludGVnZXJfcmF0aW8oKSBtdXN0IHJldHVybiBhIDItdHVwbGVcXFwiKTtyZXR1cm4gZX1yZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFxcXCJ0aW1lXFxcIiwhMSwhMCksKGE9Pntjb25zdCAkPWEuJGQsRT17X19uYW1lX186bmV3IHcoXFxcImRhdGV0aW1lXFxcIiksX19hbGxfXzpuZXcgU2suYnVpbHRpbi5saXN0KFtcXFwiZGF0ZVxcXCIsXFxcImRhdGV0aW1lXFxcIixcXFwidGltZVxcXCIsXFxcInRpbWVkZWx0YVxcXCIsXFxcInRpbWV6b25lXFxcIixcXFwidHppbmZvXFxcIixcXFwiTUlOWUVBUlxcXCIsXFxcIk1BWFlFQVJcXFwiXS5tYXAoKHQ9Pm5ldyB3KHQpKSkpfTtmdW5jdGlvbiBfY21wKHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYodFtuXSE9PWVbbl0pcmV0dXJuIHRbbl0+ZVtuXT8xOi0xO3JldHVybiAwfWZ1bmN0aW9uIF9kb19jb21wYXJlKHQsZSxuKXtjb25zdCBpPXQuJGNtcChlLG4pO3N3aXRjaChuKXtjYXNlXFxcIkx0XFxcIjpyZXR1cm4gaTwwO2Nhc2VcXFwiTHRFXFxcIjpyZXR1cm4gaTw9MDtjYXNlXFxcIkVxXFxcIjpyZXR1cm4gMD09PWk7Y2FzZVxcXCJOb3RFcVxcXCI6cmV0dXJuIDAhPT1pO2Nhc2VcXFwiR3RcXFwiOnJldHVybiBpPjA7Y2FzZVxcXCJHdEVcXFwiOnJldHVybiBpPj0wfX1jb25zdCBqPTk5OTk7RS5NSU5ZRUFSPW5ldyBmKDEpLEUuTUFYWUVBUj1uZXcgZihqKTtjb25zdCBydD0zNjUyMDU5LGF0PVstMSwzMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sJHQ9Wy0xXTtsZXQgY3Q9MDtmdW5jdGlvbiBfaXNfbGVhcCh0KXtyZXR1cm4gdCU0PT0wJiYodCUxMDAhPTB8fHQlNDAwPT0wKX1mdW5jdGlvbiBfZGF5c19iZWZvcmVfeWVhcih0KXtjb25zdCBlPXQtMTtyZXR1cm4gMzY1KmUrTWF0aC5mbG9vcihlLzQpLU1hdGguZmxvb3IoZS8xMDApK01hdGguZmxvb3IoZS80MDApfWZ1bmN0aW9uIF9kYXlzX2JlZm9yZV9tb250aCh0LGUpe3JldHVybiAkdFtlXSsoZT4yJiZfaXNfbGVhcCh0KSl9ZnVuY3Rpb24gX3ltZDJvcmQodCxlLG4pe3JldHVybiBfZGF5c19iZWZvcmVfeWVhcih0KStfZGF5c19iZWZvcmVfbW9udGgodCxlKStufWF0LnNsaWNlKDEpLmZvckVhY2goKHQ9PnskdC5wdXNoKGN0KSxjdCs9dH0pKTtjb25zdCBodD1fZGF5c19iZWZvcmVfeWVhcig0MDEpLG10PV9kYXlzX2JlZm9yZV95ZWFyKDEwMSksdXQ9X2RheXNfYmVmb3JlX3llYXIoNSk7ZnVuY3Rpb24gX29yZDJ5bWQodCl7aWYoKHQ9bih0KSk+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IE0oXFxcIlB5dGhvbiBpbnQgdG9vIGxhcmdlIHRvIGNvbnZlcnQgdG8ganMgbnVtYmVyXFxcIik7aWYodDwxKXRocm93IG5ldyB2KFxcXCJvcmRpbmFsIG11c3QgYmUgPj0gMVxcXCIpO2xldCBlLGkscyxvO3QtPTEsW2UsdF09JGRpdk1vZCh0LGh0KTtsZXQgcj00MDAqZSsxO2lmKFtpLHRdPSRkaXZNb2QodCxtdCksW3MsdF09JGRpdk1vZCh0LHV0KSxbbyx0XT0kZGl2TW9kKHQsMzY1KSxyKz0xMDAqaSs0KnMrbyw0PT09b3x8ND09PWkpcmV0dXJuW3ItMSwxMiwzMV0ubWFwKCh0PT5uZXcgZih0KSkpO2NvbnN0IGE9Mz09PW8mJigyNCE9PXN8fDM9PT1pKTtsZXQgJD10KzUwPj41LGM9JHRbJF0rKCQ+MiYmYSk7cmV0dXJuIGM+dCYmKCQtPTEsYy09YXRbJF0rKDI9PT0kJiZhKSksW3IsJCwodC09YykrMV0ubWFwKCh0PT5uZXcgZih0KSkpfWNvbnN0IGx0PVtudWxsLFxcXCJKYW5cXFwiLFxcXCJGZWJcXFwiLFxcXCJNYXJcXFwiLFxcXCJBcHJcXFwiLFxcXCJNYXlcXFwiLFxcXCJKdW5cXFwiLFxcXCJKdWxcXFwiLFxcXCJBdWdcXFwiLFxcXCJTZXBcXFwiLFxcXCJPY3RcXFwiLFxcXCJOb3ZcXFwiLFxcXCJEZWNcXFwiXSxmdD1bbnVsbCxcXFwiTW9uXFxcIixcXFwiVHVlXFxcIixcXFwiV2VkXFxcIixcXFwiVGh1XFxcIixcXFwiRnJpXFxcIixcXFwiU2F0XFxcIixcXFwiU3VuXFxcIl07ZnVuY3Rpb24gX2J1aWxkX3N0cnVjdF90aW1lKHQsZSxuLGkscyxvLHIpe2NvbnN0IGE9KF95bWQyb3JkKHQsZSxuKSs2KSU3LGM9X2RheXNfYmVmb3JlX21vbnRoKHQsZSkrbjtyZXR1cm4gJC5zdHJ1Y3RfdGltZS50cCRjYWxsKFtuZXcgcChbdCxlLG4saSxzLG8sYSxjLHJdLm1hcCgodD0+bmV3IGYodCkpKSldKX1jb25zdCBkdD17aG91cnM6dD0+X2QodCksbWludXRlczoodCxlKT0+X2QodCkrXFxcIjpcXFwiK19kKGUpLHNlY29uZHM6KHQsZSxuKT0+X2QodCkrXFxcIjpcXFwiK19kKGUpK1xcXCI6XFxcIitfZChuKSxtaWxsaXNlY29uZHM6KHQsZSxuLGkpPT5fZCh0KStcXFwiOlxcXCIrX2QoZSkrXFxcIjpcXFwiK19kKG4pK1xcXCIuXFxcIitfZChpLFxcXCIwXFxcIiwzKSxtaWNyb3NlY29uZHM6KHQsZSxuLGkpPT5fZCh0KStcXFwiOlxcXCIrX2QoZSkrXFxcIjpcXFwiK19kKG4pK1xcXCIuXFxcIitfZChpLFxcXCIwXFxcIiw2KX07ZnVuY3Rpb24gX2Zvcm1hdF90aW1lKHQsZSxuLGkscz1cXFwiYXV0b1xcXCIpe2lmKFxcXCJzdHJpbmdcXFwiIT10eXBlb2YgcyYmIWsocykpdGhyb3cgbmV3IHooXFxcIm11c3QgYmUgc3RyLCBub3QgXFxcIitjKHMpKTtcXFwiYXV0b1xcXCI9PT0ocz1zLnRvU3RyaW5nKCkpP3M9aT9cXFwibWljcm9zZWNvbmRzXFxcIjpcXFwic2Vjb25kc1xcXCI6XFxcIm1pbGxpc2Vjb25kc1xcXCI9PT1zJiYoaT1NYXRoLmZsb29yKGkvMWUzKSk7bGV0IG89ZHRbc107aWYodm9pZCAwPT09byl0aHJvdyBuZXcgdihcXFwiVW5rbm93biB0aW1lc3BlYyB2YWx1ZVxcXCIpO3JldHVybiBvKHQsZSxuLGkpfWZ1bmN0aW9uIF9mb3JtYXRfb2Zmc2V0KHQpe2xldCBlLG49XFxcIlxcXCI7aWYodCE9PXkpe2xldCBpLHMsbztyZXR1cm4gdC4kZGF5czwwPyhlPVxcXCItXFxcIix0PW5ldyB3dCgtdC4kZGF5cywtdC4kc2VjcywtdC4kbWljcm8pKTplPVxcXCIrXFxcIixbaSxzXT1weURpdk1vZCh0LHB0KSxbcyxvXT1weURpdk1vZChzLGd0KSxuKz1lK2Ake19kKGkpfToke19kKHMpfWAsKG8uJHNlY3N8fG8uJG1pY3JvKSYmKG4rPVxcXCI6XFxcIitfZChvLiRzZWNzLFxcXCIwXFxcIiwyKSxvLiRtaWNybyYmKG4rPVxcXCIuXFxcIitfZChvLiRtaWNybyxcXFwiMFxcXCIsNikpKSxufX1mdW5jdGlvbiBfd3JhcF9zdHJmdGltZSh0LGUsbil7bGV0IGk9bnVsbCxzPW51bGwsbz1udWxsLGE9W10sYz0wO2NvbnN0IGg9ZS5sZW5ndGg7Zm9yKDtjPGg7KXtsZXQgbj1lW2NdO2lmKGMrPTEsXFxcIiVcXFwiPT09bilpZihjPGgpaWYobj1lW2NdLGMrPTEsXFxcImZcXFwiPT09biludWxsPT09aSYmKGk9X2QodC4kbWljcm98fDAsXFxcIjBcXFwiLDYpKSxhLnB1c2goaSk7ZWxzZSBpZihcXFwielxcXCI9PT1uKXtpZihudWxsPT09cyl7cz1cXFwiXFxcIjtjb25zdCBlPXQudHAkZ2V0YXR0cihVKTtpZih2b2lkIDAhPT1lKXtsZXQgdD1yKGUpO2lmKHQhPT15KXtsZXQgZSxuLGksbz1cXFwiK1xcXCI7dC4kZGF5czwwJiYodD1uZXcgd3QoLXQuJGRheXMsLXQuJHNlY3MsLXQuJG1pY3JvKSxvPVxcXCItXFxcIiksW2UsaV09cHlEaXZNb2QodCxwdCksW24saV09cHlEaXZNb2QoaSxndCk7Y29uc3Qgcj1pLiRzZWNzLGE9dC4kbWljcm87cz1hP28rX2QoZSkrX2QobikrX2QocikrXFxcIi5cXFwiK19kKGEsXFxcIjBcXFwiLDYpOnI/bytfZChlKStfZChuKStfZChyKTpvK19kKGUpK19kKG4pfX19YS5wdXNoKHMpfWVsc2UgaWYoXFxcIlpcXFwiPT09bil7aWYobnVsbD09PW8pe289XFxcIlxcXCI7Y29uc3QgZT10LnRwJGdldGF0dHIoWSk7aWYodm9pZCAwIT09ZSl7bGV0IHQ9cihlKTtpZih0IT09eSl7Y29uc3QgZT10LnRwJGdldGF0dHIoSik7aWYobz1yKGUsW25ldyB3KFxcXCIlXFxcIiksbmV3IHcoXFxcIiUlXFxcIildKSwhayhvKSl0aHJvdyBuZXcgeihcXFwidHpuYW1lLnJlcGxhY2UoKSBkaWQgbm90IHJldHVybiBhIHN0cmluZ1xcXCIpfX19YS5wdXNoKG8pfWVsc2UgYS5wdXNoKFxcXCIlXFxcIixuKTtlbHNlIGEucHVzaChcXFwiJVxcXCIpO2Vsc2UgYS5wdXNoKG4pfXJldHVybiBhPWEuam9pbihcXFwiXFxcIiksJC5zdHJmdGltZS50cCRjYWxsKFtuZXcgdyhhKSxuXSl9ZnVuY3Rpb24gX3BhcnNlX2lzb2Zvcm1hdF9kYXRlKHQpe2NvbnN0IGU9X2FzX2ludGVnZXIodC5zbGljZSgwLDQpKTtpZihcXFwiLVxcXCIhPT10WzRdKXRocm93IG5ldyB2KFxcXCJJbnZhbGlkIGRhdGUgc2VwYXJhdG9yOiBcXFwiK3RbNF0pO2NvbnN0IG49X2FzX2ludGVnZXIodC5zbGljZSg1LDcpKTtpZihcXFwiLVxcXCIhPT10WzddKXRocm93IG5ldyB2KFxcXCJJbnZhbGlkIGRhdGUgc2VwYXJhdG9yOiBcXFwiK3RbN10pO3JldHVybltlLG4sX2FzX2ludGVnZXIodC5zbGljZSg4LDEwKSldLm1hcCgodD0+bmV3IGYodCkpKX1mdW5jdGlvbiBfcGFyc2VfaGhfbW1fc3NfZmYodCl7Y29uc3QgZT10Lmxlbmd0aCxuPVswLDAsMCwwXTtsZXQgaT0wO2ZvcihsZXQgcz0wO3M8MztzKyspe2lmKGUtaTwyKXRocm93IG5ldyB2KFxcXCJJbmNvbXBsZXRlIHRpbWUgY29tcG9uZW50XFxcIik7bltzXT1fYXNfaW50ZWdlcih0LnNsaWNlKGksaSsyKSksaSs9Mjtjb25zdCBvPXQuc3Vic3RyKGksMSk7aWYoIW98fHM+PTIpYnJlYWs7aWYoXFxcIjpcXFwiIT09byl0aHJvdyBuZXcgdihcXFwiSW52YWxpZCB0aW1lIHNlcGFyYXRvcjogXFxcIitvKTtpKz0xfWlmKGk8ZSl7aWYoXFxcIi5cXFwiIT09dFtpXSl0aHJvdyBuZXcgdihcXFwiSW52YWxpZCBtaWNyb3NlY29uZCBjb21wb25lbnRcXFwiKTt7aSs9MTtjb25zdCBzPWUtaTtpZigzIT09cyYmNiE9PXMpdGhyb3cgbmV3IHYoXFxcIkludmFsaWQgbWljcm9zZWNvbmQgY29tcG9uZW50XFxcIik7blszXT1fYXNfaW50ZWdlcih0LnNsaWNlKGkpKSwzPT09cyYmKG5bM10qPTFlMyl9fXJldHVybiBufWZ1bmN0aW9uIF9wYXJzZV9pc29mb3JtYXRfdGltZSh0KXtpZih0Lmxlbmd0aDwyKXRocm93IG5ldyB2KFxcXCJJc29mb3JtYXQgdGltZSB0b28gc2hvcnRcXFwiKTtjb25zdCBlPXQuaW5kZXhPZihcXFwiLVxcXCIpKzF8fHQuaW5kZXhPZihcXFwiK1xcXCIpKzE7bGV0IG4saT1fcGFyc2VfaGhfbW1fc3NfZmYoZT4wP3Quc2xpY2UoMCxlLTEpOnQpLHM9eTtpZihlPjApe2lmKG49dC5zbGljZShlKSwhWzUsOCwxNV0uaW5jbHVkZXMobi5sZW5ndGgpKXRocm93IG5ldyB2KFxcXCJNYWxmb3JtZWQgdGltZSB6b25lIHN0cmluZ1xcXCIpO2NvbnN0IGk9X3BhcnNlX2hoX21tX3NzX2ZmKG4pO2lmKGkuZXZlcnkoKHQ9PjA9PT10KSkpcz1TdC5wcm90b3R5cGUudXRjO2Vsc2V7Y29uc3Qgbj1cXFwiLVxcXCI9PT10W2UtMV0/LTE6MSxvPW5ldyB3dCgwLG4qKDM2MDAqaVswXSs2MCppWzFdK2lbMl0pLG4qaVszXSk7cz1uZXcgU3Qobyl9fXJldHVybiBpPWkubWFwKCh0PT5uZXcgZih0KSkpLGkucHVzaChzKSxpfWZ1bmN0aW9uIF9jaGVja190em5hbWUodCl7aWYodCE9PXkmJiFrKHQpKXRocm93IG5ldyB6KFxcXCJ0emluZm8udHpuYW1lKCkgbXVzdCByZXR1cm4gTm9uZSBvciBzdHJpbmcsIG5vdCAnXFxcIitjKHQpK1xcXCInXFxcIil9ZnVuY3Rpb24gX2NoZWNrX3V0Y19vZmZzZXQodCxuKXtpZihuIT09eSl7aWYoIShuIGluc3RhbmNlb2Ygd3QpKXRocm93IG5ldyB6KGB0emluZm8uJHt0fSgpIG11c3QgcmV0dXJuIE5vbmUgb3IgdGltZWRlbHRhLCBub3QgJyR7YyhuKX0nYCk7aWYoIWUoenQsbixcXFwiTHRcXFwiKXx8IWUobixfdCxcXFwiTHRcXFwiKSl0aHJvdyBuZXcgdihgJHt0fSgpPSR7bi50b1N0cmluZygpfSwgbXVzdCBiZSBzdHJpY3RseSBiZXR3ZWVuIC10aW1lZGVsdGEoaG91cnM9MjQpIGFuZCB0aW1lZGVsdGEoaG91cnM9MjQpYCl9fWZ1bmN0aW9uIF9jaGVja19kYXRlX2ZpZWxkcyh0LGU9bnVsbCxpPW51bGwpe2lmKG51bGw9PT1lfHxudWxsPT09aSl7dGhyb3cgbmV3IHooYGZ1bmN0aW9uIG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgJyR7bnVsbD09PWk/XFxcImRheVxcXCI6XFxcIm1vbnRoXFxcIn0nIChwb3MgJHtudWxsPT09aT9cXFwiM1xcXCI6XFxcIjJcXFwifSlgKX1pZih0PW4odCksZT1uKGUpLGk9bihpKSwhKDE8PXQmJnQ8PWopKXRocm93IG5ldyB2KFxcXCJ5ZWFyIG11c3QgYmUgaW4gMS4uXFxcIitqLG5ldyBmKHQpKTtpZighKDE8PWUmJmU8PTEyKSl0aHJvdyBuZXcgdihcXFwibW9udGggbXVzdCBiZSBpbiAxLi4xMlxcXCIsbmV3IGYoZSkpO2NvbnN0IHM9ZnVuY3Rpb24gX2RheXNfaW5fbW9udGgodCxlKXtyZXR1cm4gMj09PWUmJl9pc19sZWFwKHQpPzI5OmF0W2VdfSh0LGUpO2lmKCEoMTw9aSYmaTw9cykpdGhyb3cgbmV3IHYoXFxcImRheSBtdXN0IGJlIGluIDEuLlxcXCIrcyxuZXcgZihpKSk7cmV0dXJuW3QsZSxpXX1mdW5jdGlvbiBfY2hlY2tfdGltZV9maWVsZHModCxlLGkscyxvKXtpZih0PW4odCksZT1uKGUpLGk9bihpKSxzPW4ocyksbz1uKG8pLCEoMDw9dCYmdDw9MjMpKXRocm93IG5ldyB2KFxcXCJob3VyIG11c3QgYmUgaW4gMC4uMjNcXFwiLG5ldyBmKHQpKTtpZighKDA8PWUmJmU8PTU5KSl0aHJvdyBuZXcgdihcXFwibWludXRlIG11c3QgYmUgaW4gMC4uNTlcXFwiLG5ldyBmKGUpKTtpZighKDA8PWkmJmk8PTU5KSl0aHJvdyBuZXcgdihcXFwic2Vjb25kIG11c3QgYmUgaW4gMC4uNTlcXFwiLG5ldyBmKGkpKTtpZighKDA8PXMmJnM8PTk5OTk5OSkpdGhyb3cgbmV3IHYoXFxcIm1pY3Jvc2Vjb25kIG11c3QgYmUgaW4gMC4uOTk5OTk5XFxcIixuZXcgZihzKSk7aWYoMCE9PW8mJjEhPT1vKXRocm93IG5ldyB2KFxcXCJmb2xkIG11c3QgYmUgZWl0aGVyIDAgb3IgMVxcXCIsbmV3IGYobykpO3JldHVyblt0LGUsaSxzLG9dfWZ1bmN0aW9uIF9jaGVja190emluZm9fYXJnKHQpe2lmKHQhPT15JiYhKHQgaW5zdGFuY2VvZiBNdCkpdGhyb3cgbmV3IHooXFxcInR6aW5mbyBhcmd1bWVudCBtdXN0IGJlIE5vbmUgb3Igb2YgYSB0emluZm8gc3ViY2xhc3NcXFwiKX1mdW5jdGlvbiBfZGl2aWRlX2FuZF9yb3VuZCh0LGUpe2xldFtuLGldPSRkaXZNb2QodCxlKTtyZXR1cm4gaSo9MiwoKGU+MD9pPmU6aTxlKXx8aT09PWUmJk1hdGguYWJzKG4pJTI9PTEpJiYobis9MSksbn1jb25zdCB3dD1FLnRpbWVkZWx0YT1oKFxcXCJkYXRldGltZS50aW1lZGVsdGFcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiB0aW1lZGVsdGEodD0wLGU9MCxuPTApe2xldCBpLHM7aWYoW2ksbl09JGRpdk1vZChuLDFlNiksZSs9aSxbcyxlXT0kZGl2TW9kKGUsODY0MDApLHQrPXMsdGhpcy4kZGF5cz10LHRoaXMuJHNlY3M9ZSx0aGlzLiRtaWNybz1uLHRoaXMuJGhhc2hjb2RlPS0xLE1hdGguYWJzKHQpPjk5OTk5OTk5OSl0aHJvdyBuZXcgTShgZGF5cz0ke3R9OyBtdXN0IGhhdmUgbWFnbml0dWRlIDw9IDk5OTk5OTk5OWApfSxzbG90czp7dHAkbmV3KHQsZSl7bGV0IGkscyxvLHIsYSwkLGMsW2gsbSx1LGQsdyxfLHBdPWwoXFxcInRpbWVkZWx0YVxcXCIsW1xcXCJkYXlzXFxcIixcXFwic2Vjb25kc1xcXCIsXFxcIm1pY3Jvc2Vjb25kc1xcXCIsXFxcIm1pbGxpc2Vjb25kc1xcXCIsXFxcIm1pbnV0ZXNcXFwiLFxcXCJob3Vyc1xcXCIsXFxcIndlZWtzXFxcIl0sdCxlLG5ldyBBcnJheSg3KS5maWxsKFcpKTtpPXM9bz1XLGg9cShoLHEocCxLLFxcXCJNdWx0XFxcIiksXFxcIkFkZFxcXCIpLG09cShtLHEocSh3LFYsXFxcIk11bHRcXFwiKSxxKF8sUSxcXFwiTXVsdFxcXCIpLFxcXCJBZGRcXFwiKSxcXFwiQWRkXFxcIiksdT1xKHUscShkLHR0LFxcXCJNdWx0XFxcIiksXFxcIkFkZFxcXCIpLFMoaCk/KFtyLGhdPW1vZGYoaCksW2EsJF09bW9kZihxKHIsc3QsXFxcIk11bHRcXFwiKSkscz1uZXcgZigkKSxpPW5ldyBmKGgpKTooYT1aLGk9aCksUyhtKT8oW2MsbV09bW9kZihtKSxtPW5ldyBmKG0pLGM9cShjLGEsXFxcIkFkZFxcXCIpKTpjPWEsW2gsbV09cHlEaXZNb2QobSxpdCksaT1xKGksaCxcXFwiQWRkXFxcIikscz1xKHMsbmV3IGYobSksXFxcIkFkZFxcXCIpO2NvbnN0IGc9cShjLG50LFxcXCJNdWx0XFxcIik7aWYoUyh1KT8odT1pbnRSb3VuZChxKHUsZyxcXFwiQWRkXFxcIikpLFttLHVdPXB5RGl2TW9kKHUsZXQpLFtoLG1dPXB5RGl2TW9kKG0saXQpLGk9cShpLGgsXFxcIkFkZFxcXCIpLHM9cShzLG0sXFxcIkFkZFxcXCIpKToodT1uZXcgZih1KSxbbSx1XT1weURpdk1vZCh1LGV0KSxbaCxtXT1weURpdk1vZChtLGl0KSxpPXEoaSxoLFxcXCJBZGRcXFwiKSxzPXEocyxtLFxcXCJBZGRcXFwiKSx1PWludFJvdW5kKHEodSxnLFxcXCJBZGRcXFwiKSkpLFttLG9dPXB5RGl2TW9kKHUsZXQpLHM9cShzLG0sXFxcIkFkZFxcXCIpLFtoLHNdPXB5RGl2TW9kKHMsaXQpLGk9cShpLGgsXFxcIkFkZFxcXCIpLGk9bihpKSxzPW4ocyksbz1uKG8pLE1hdGguYWJzKGkpPjk5OTk5OTk5OSl0aHJvdyBuZXcgTShcXFwidGltZWRlbHRhICMgb2YgZGF5cyBpcyB0b28gbGFyZ2U6IFxcXCIraC50b1N0cmluZygpKTtpZih0aGlzPT09d3QucHJvdG90eXBlKXJldHVybiBuZXcgd3QoaSxzLG8pO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiB3dC5jYWxsKHQsaSxzLG8pLHR9fSwkcigpe2NvbnN0IHQ9W107cmV0dXJuIHRoaXMuJGRheXMmJnQucHVzaChgZGF5cz0ke3RoaXMuJGRheXN9YCksdGhpcy4kc2VjcyYmdC5wdXNoKGBzZWNvbmRzPSR7dGhpcy4kc2Vjc31gKSx0aGlzLiRtaWNybyYmdC5wdXNoKGBtaWNyb3NlY29uZHM9JHt0aGlzLiRtaWNyb31gKSx0Lmxlbmd0aHx8dC5wdXNoKFxcXCIwXFxcIiksbmV3IHcoYCR7dGhpcy50cCRuYW1lfSgke3Quam9pbihcXFwiLCBcXFwiKX0pYCl9LHRwJHN0cigpe2NvbnN0IHQ9dGhpcy4kc2VjcyU2MDtsZXQgZT1NYXRoLmZsb29yKHRoaXMuJHNlY3MvNjApO2NvbnN0IG49TWF0aC5mbG9vcihlLzYwKTtlJT02MDtsZXQgaT1gJHtufToke19kKGUpfToke19kKHQpfWA7aWYodGhpcy4kZGF5cyl7aT1gJHt0aGlzLiRkYXlzfSBkYXkke2Z1bmN0aW9uIHBsdXJhbCh0KXtyZXR1cm4gMSE9PU1hdGguYWJzKHQpP1xcXCJzXFxcIjpcXFwiXFxcIn0odGhpcy4kZGF5cyl9LCBgK2l9cmV0dXJuIHRoaXMuJG1pY3JvJiYoaSs9YC4ke19kKHRoaXMuJG1pY3JvLFxcXCIwXFxcIiw2KX1gKSxuZXcgdyhpKX0sdHAkYXNfbnVtYmVyOiEwLG5iJGFkZCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0P25ldyB3dCh0aGlzLiRkYXlzK3QuJGRheXMsdGhpcy4kc2Vjcyt0LiRzZWNzLHRoaXMuJG1pY3JvK3QuJG1pY3JvKTpifSxuYiRzdWJ0cmFjdCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0P25ldyB3dCh0aGlzLiRkYXlzLXQuJGRheXMsdGhpcy4kc2Vjcy10LiRzZWNzLHRoaXMuJG1pY3JvLXQuJG1pY3JvKTpifSxuYiRwb3NpdGl2ZSgpe3JldHVybiB0aGlzfSxuYiRuZWdhdGl2ZSgpe3JldHVybiBuZXcgd3QoLXRoaXMuJGRheXMsLXRoaXMuJHNlY3MsLXRoaXMuJG1pY3JvKX0sbmIkYWJzKCl7cmV0dXJuIHRoaXMuJGRheXM8MD90aGlzLm5iJG5lZ2F0aXZlKCk6dGhpc30sbmIkbXVsdGlwbHkodCl7aWYoTyh0KSlyZXR1cm4gdD1pKHQsTSksbmV3IHd0KHRoaXMuJGRheXMqdCx0aGlzLiRzZWNzKnQsdGhpcy4kbWljcm8qdCk7aWYoUyh0KSl7Y29uc3QgZT10aGlzLiR0b01pY3Jvc2VjcygpO2xldFtzLG9dPV9hc19pbnRfcmF0aW8odCk7cmV0dXJuIHM9aShzLE0pLG89bihvKSxuZXcgd3QoMCwwLF9kaXZpZGVfYW5kX3JvdW5kKGUqcyxvKSl9cmV0dXJuIGJ9LG5iJGZsb29yX2RpdmlkZSh0KXtjb25zdCBlPXRoaXMuJHRvTWljcm9zZWNzKCk7aWYodCBpbnN0YW5jZW9mIHd0KXtjb25zdCBuPXQuJHRvTWljcm9zZWNzKCk7aWYoMD09PW4pdGhyb3cgbmV3IEEoXFxcImludGVnZXIgZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cXFwiKTtyZXR1cm4gbmV3IGYoTWF0aC5mbG9vcihlL24pKX1pZihPKHQpKXtpZigwPT09KHQ9aSh0LE0pKSl0aHJvdyBuZXcgQShcXFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1xcXCIpO3JldHVybiBuZXcgd3QoMCwwLE1hdGguZmxvb3IoZS90KSl9cmV0dXJuIGJ9LG5iJGRpdmlkZSh0KXtjb25zdCBlPXRoaXMuJHRvTWljcm9zZWNzKCk7aWYodCBpbnN0YW5jZW9mIHd0KXtpZigwPT09dC4kdG9NaWNyb3NlY3MoKSl0aHJvdyBuZXcgQShcXFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1xcXCIpO3JldHVybiBuZXcgZChlL3QuJHRvTWljcm9zZWNzKCkpfWlmKE8odCkpcmV0dXJuIHQ9bih0KSxuZXcgd3QoMCwwLF9kaXZpZGVfYW5kX3JvdW5kKGUsdCkpO2lmKFModCkpe2xldFtzLG9dPV9hc19pbnRfcmF0aW8odCk7cmV0dXJuIHM9bihzKSxvPWkobyxNKSxuZXcgd3QoMCwwLF9kaXZpZGVfYW5kX3JvdW5kKG8qZSxzKSl9cmV0dXJuIGJ9LG5iJHJlbWFpbmRlcih0KXtpZighKHQgaW5zdGFuY2VvZiB3dCkpcmV0dXJuIGI7Y29uc3QgZT10aGlzLiR0b01pY3Jvc2VjcygpLG49dC4kdG9NaWNyb3NlY3MoKTtpZigwPT09bil0aHJvdyBuZXcgQShcXFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1xcXCIpO2NvbnN0IGk9ZS1NYXRoLmZsb29yKGUvbikqbjtyZXR1cm4gbmV3IHd0KDAsMCxpKX0sbmIkZGl2bW9kKHQpe2lmKCEodCBpbnN0YW5jZW9mIHd0KSlyZXR1cm4gYjtjb25zdCBlPXRoaXMuJHRvTWljcm9zZWNzKCksbj10LiR0b01pY3Jvc2VjcygpLFtpLHNdPSRkaXZNb2QoZSxuKTtyZXR1cm4gbmV3IHAoW25ldyBmKGkpLG5ldyB3dCgwLDAscyldKX0sdHAkcmljaGNvbXBhcmUodCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0P19kb19jb21wYXJlKHRoaXMsdCxlKTpifSx0cCRoYXNoKCl7cmV0dXJuLTE9PT10aGlzLiRoYXNoY29kZSYmKHRoaXMuJGhhc2hjb2RlPXUobmV3IHAodGhpcy4kZ2V0U3RhdGUoKS5tYXAoKHQ9Pm5ldyBmKHQpKSkpKSksdGhpcy4kaGFzaGNvZGV9LG5iJGJvb2woKXtyZXR1cm4gMCE9PXRoaXMuJGRheXN8fDAhPT10aGlzLiRzZWNzfHwwIT09dGhpcy4kbWljcm99fSxtZXRob2RzOnt0b3RhbF9zZWNvbmRzOnskbWV0aCgpe3JldHVybiBuZXcgZCgoKDg2NDAwKnRoaXMuJGRheXMrdGhpcy4kc2VjcykqMTAqKjYrdGhpcy4kbWljcm8pLzEwKio2KX0sJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XFxcIlRvdGFsIHNlY29uZHMgaW4gdGhlIGR1cmF0aW9uLlxcXCJ9LF9fcmVkdWNlX186eyRtZXRoKCl7cmV0dXJuIG5ldyBwKFt0aGlzLm9iJHR5cGUsbmV3IHAodGhpcy4kZ2V0U3RhdGUoKS5tYXAoKHQ9PkQodCkpKSldKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiX19yZWR1Y2VfXygpIC0+IChjbHMsIHN0YXRlKVxcXCJ9fSxnZXRzZXRzOntkYXlzOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJGRheXMpfSwkZG9jOlxcXCJOdW1iZXIgb2YgZGF5cy5cXFwifSxzZWNvbmRzOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJHNlY3MpfSwkZG9jOlxcXCJOdW1iZXIgb2Ygc2Vjb25kcyAoPj0gMCBhbmQgbGVzcyB0aGFuIDEgZGF5KS5cXFwifSxtaWNyb3NlY29uZHM6eyRnZXQoKXtyZXR1cm4gbmV3IGYodGhpcy4kbWljcm8pfSwkZG9jOlxcXCJOdW1iZXIgb2YgbWljcm9zZWNvbmRzICg+PSAwIGFuZCBsZXNzIHRoYW4gMSBzZWNvbmQpLlxcXCJ9fSxwcm90bzp7JHRvTWljcm9zZWNzKCl7cmV0dXJuIDFlNiooODY0MDAqdGhpcy4kZGF5cyt0aGlzLiRzZWNzKSt0aGlzLiRtaWNyb30sJGNtcCh0KXtyZXR1cm4gX2NtcCh0aGlzLiRnZXRTdGF0ZSgpLHQuJGdldFN0YXRlKCkpfSwkZ2V0U3RhdGUoKXtyZXR1cm5bdGhpcy4kZGF5cyx0aGlzLiRzZWNzLHRoaXMuJG1pY3JvXX19fSk7d3QucHJvdG90eXBlLm1pbj1uZXcgd3QoLTk5OTk5OTk5OSksd3QucHJvdG90eXBlLm1heD1uZXcgd3QoOTk5OTk5OTk5LDg2Mzk5LDk5OTk5OSksd3QucHJvdG90eXBlLnJlc29sdXRpb249bmV3IHd0KDAsMCwxKTtjb25zdCBfdD1uZXcgd3QoMSkscHQ9bmV3IHd0KDAsMzYwMCksZ3Q9bmV3IHd0KDAsNjApLHl0PW5ldyB3dCgwLDEpLGJ0PW5ldyB3dCgwKSx6dD1uZXcgd3QoLTEpLHZ0PUUuZGF0ZT1oKFxcXCJkYXRldGltZS5kYXRlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gZGF0ZSh0LGUsbil7dGhpcy4keWVhcj10LHRoaXMuJG1vbnRoPWUsdGhpcy4kZGF5PW4sdGhpcy4kaGFzaGNvZGU9LTF9LHNsb3RzOnt0cCRuZXcodCxlKXtsZXQgbixbaSxzLG9dPWwoXFxcImRhdGVcXFwiLFtcXFwieWVhclxcXCIsXFxcIm1vbnRoXFxcIixcXFwiZGF5XFxcIl0sdCxlLFtudWxsLG51bGxdKTtpZihudWxsPT09cyYmaSBpbnN0YW5jZW9mIF8mJjQ9PT0obj1pLnZhbHVlT2YoKSkubGVuZ3RoJiYxPD1uWzJdJiZuWzJdPD0xMil7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gdC4kc2V0U3RhdGUobiksdH1pZihbaSxzLG9dPV9jaGVja19kYXRlX2ZpZWxkcyhpLHMsbyksdGhpcz09PXZ0LnByb3RvdHlwZSlyZXR1cm4gbmV3IHZ0KGkscyxvKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gdnQuY2FsbCh0LGkscyxvKSx0fX0sJHIoKXtyZXR1cm4gbmV3IHcoYCR7dGhpcy50cCRuYW1lfSgke3RoaXMuJHllYXJ9LCAke3RoaXMuJG1vbnRofSwgJHt0aGlzLiRkYXl9KWApfSx0cCRzdHIoKXtyZXR1cm4gdGhpcy50cCRnZXRhdHRyKEgpLnRwJGNhbGwoW10pfSx0cCRyaWNoY29tcGFyZSh0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgdnQ/X2RvX2NvbXBhcmUodGhpcyx0LGUpOmJ9LHRwJGhhc2goKXtyZXR1cm4tMT09PXRoaXMuJGhhc2hjb2RlJiYodGhpcy4kaGFzaGNvZGU9dSh0aGlzLiRnZXRTdGF0ZSgpKSksdGhpcy4kaGFzaGNvZGV9LHRwJGFzX251bWJlcjohMCxuYiRhZGQodCl7aWYodCBpbnN0YW5jZW9mIHd0KXtjb25zdCBlPXRoaXMuJHRvT3JkaW5hbCgpK3QuJGRheXM7aWYoMDxlJiZlPD1ydClyZXR1cm4gdGhpcy5vYiR0eXBlLnRwJGdldGF0dHIoRykudHAkY2FsbChbbmV3IGYoZSldKTt0aHJvdyBuZXcgTShcXFwicmVzdWx0IG91dCBvZiByYW5nZVxcXCIpfXJldHVybiBifSxuYiRzdWJ0cmFjdCh0KXtpZih0IGluc3RhbmNlb2Ygd3QpcmV0dXJuIHEodGhpcyxuZXcgd3QoLXQuJGRheXMpLFxcXCJBZGRcXFwiKTtpZih0IGluc3RhbmNlb2YgdnQpe2NvbnN0IGU9dGhpcy4kdG9PcmRpbmFsKCksbj10LiR0b09yZGluYWwoKTtyZXR1cm4gbmV3IHd0KGUtbil9cmV0dXJuIGJ9LG5iJHJlZmxlY3RlZF9zdWJ0cmFjdDpudWxsfSxjbGFzc21ldGhvZHM6e2Zyb210aW1lc3RhbXA6eyRtZXRoOmZ1bmN0aW9uIGZyb210aW1lc3RhbXAodCl7Y29uc3RbZSxuLGldPSQubG9jYWx0aW1lLnRwJGNhbGwoW3RdKS52O3JldHVybiB0aGlzLnRwJGNhbGwoW2UsbixpXSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcInRpbWVzdGFtcCAtPiBsb2NhbCBkYXRlIGZyb20gYSBQT1NJWCB0aW1lc3RhbXAgKGxpa2UgdGltZS50aW1lKCkpLlxcXCJ9LGZyb21vcmRpbmFsOnskbWV0aDpmdW5jdGlvbiBmcm9tb3JkaW5hbCh0KXtyZXR1cm4gdGhpcy50cCRjYWxsKF9vcmQyeW1kKHQpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiaW50IC0+IGRhdGUgY29ycmVzcG9uZGluZyB0byBhIHByb2xlcHRpYyBHcmVnb3JpYW4gb3JkaW5hbC5cXFwifSxmcm9taXNvY2FsZW5kYXI6eyRtZXRoOmZ1bmN0aW9uIGZyb21pc29jYWxlbmRhcih0LGUsaSl7aWYodD1uKHQpLGU9bihlKSxpPW4oaSksISgxPD10JiZ0PD1qKSl0aHJvdyBuZXcgdihgWWVhciBpcyBvdXQgb2YgcmFuZ2U6ICR7dH1gKTtsZXQgcyxvO2lmKCEoMDxlJiZlPDUzKSYmKHM9ITAsNTM9PT1lJiYobz1feW1kMm9yZCh0LDEsMSklNywoND09PW98fDM9PT1vJiZfaXNfbGVhcCh0KSkmJihzPSExKSkscykpdGhyb3cgbmV3IHYoYEludmFsaWQgd2VlazogJHtlfWApO2lmKCEoMDxpJiZpPDgpKXRocm93IG5ldyB2KGBJbnZhbGlkIHdlZWtkYXk6ICR7aX0gKHJhbmdlIGlzIFsxLCA3XSlgKTtjb25zdCByPTcqKGUtMSkrKGktMSksYT1faXNvd2VlazFtb25kYXkodCkrcjtyZXR1cm4gdGhpcy50cCRjYWxsKF9vcmQyeW1kKGEpKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ5ZWFyXFxcIixcXFwid2Vla1xcXCIsXFxcImRheVxcXCJdfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcImludCAtPiBkYXRlIGNvcnJlc3BvbmRpbmcgdG8gYSBwcm9sZXB0aWMgR3JlZ29yaWFuIG9yZGluYWwuXFxcIn0sZnJvbWlzb2Zvcm1hdDp7JG1ldGg6ZnVuY3Rpb24gZnJvbWlzb2Zvcm1hdCh0KXtpZighayh0KSl0aHJvdyBuZXcgeihcXFwiZnJvbWlzb2Zvcm1hdDogYXJndW1lbnQgbXVzdCBiZSBzdHJcXFwiKTt0PXQudG9TdHJpbmcoKTt0cnl7aWYoMTAhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3I7cmV0dXJuIHRoaXMudHAkY2FsbChfcGFyc2VfaXNvZm9ybWF0X2RhdGUodCkpfWNhdGNoKGUpe3Rocm93IG5ldyB2KFxcXCJJbnZhbGlkIGlzb2Zvcm1hdCBzdHJpbmc6ICdcXFwiK3QrXFxcIidcXFwiKX19LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcInN0ciAtPiBDb25zdHJ1Y3QgYSBkYXRlIGZyb20gdGhlIG91dHB1dCBvZiBkYXRlLmlzb2Zvcm1hdCgpXFxcIn0sdG9kYXk6eyRtZXRoOmZ1bmN0aW9uIHRvZGF5KCl7Y29uc3QgdD0kLnRpbWUudHAkY2FsbChbXSk7cmV0dXJuIHRoaXMudHAkZ2V0YXR0cihCKS50cCRjYWxsKFt0XSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkN1cnJlbnQgZGF0ZSBvciBkYXRldGltZTogIHNhbWUgYXMgc2VsZi5fX2NsYXNzX18uZnJvbXRpbWVzdGFtcCh0aW1lLnRpbWUoKSkuXFxcIn19LG1ldGhvZHM6e2N0aW1lOnskbWV0aDpmdW5jdGlvbiBjdGltZSgpe2NvbnN0IHQ9dGhpcy4kdG9PcmRpbmFsKCklN3x8NyxlPWZ0W3RdLG49bHRbdGhpcy4kbW9udGhdO3JldHVybiBuZXcgdyhgJHtlfSAke259ICR7X2QodGhpcy4kZGF5LFxcXCIgXFxcIiwyKX0gMDA6MDA6MDAgJHtfZCh0aGlzLiR5ZWFyLFxcXCIwXFxcIiw0KX1gKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIGN0aW1lKCkgc3R5bGUgc3RyaW5nLlxcXCJ9LHN0cmZ0aW1lOnskbWV0aDpmdW5jdGlvbiBzdHJmdGltZSh0KXtpZighayh0KSl0aHJvdyBuZXcgeihcXFwibXVzdCBiZSBzdHIsIG5vdCBcXFwiK2ModCkpO3JldHVybiBfd3JhcF9zdHJmdGltZSh0aGlzLHQ9dC50b1N0cmluZygpLHRoaXMuJHRpbWV0dXBsZSgpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiZm9ybWF0IC0+IHN0cmZ0aW1lKCkgc3R5bGUgc3RyaW5nLlxcXCJ9LF9fZm9ybWF0X186eyRtZXRoOmZ1bmN0aW9uIF9fZm9ybWF0X18odCl7aWYoIWsodCkpdGhyb3cgbmV3IHooXFxcIm11c3QgYmUgc3RyLCBub3QgXFxcIitjKHQpKTtyZXR1cm4gdCE9PXcuJGVtcHR5P3RoaXMudHAkZ2V0YXR0cihYKS50cCRjYWxsKFt0XSk6dGhpcy50cCRzdHIoKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRm9ybWF0cyBzZWxmIHdpdGggc3RyZnRpbWUuXFxcIn0sdGltZXR1cGxlOnskbWV0aDpmdW5jdGlvbiB0aW1ldHVwbGUoKXtyZXR1cm4gdGhpcy4kdGltZXR1cGxlKCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiB0aW1lIHR1cGxlLCBjb21wYXRpYmxlIHdpdGggdGltZS5sb2NhbHRpbWUoKS5cXFwifSxpc29jYWxlbmRhcjp7JG1ldGg6ZnVuY3Rpb24gaXNvY2FsZW5kYXIoKXtsZXQgdD10aGlzLiR5ZWFyLGU9X2lzb3dlZWsxbW9uZGF5KHQpO2NvbnN0IG49X3ltZDJvcmQodGhpcy4keWVhcix0aGlzLiRtb250aCx0aGlzLiRkYXkpO2xldFtpLHNdPSRkaXZNb2Qobi1lLDcpO3JldHVybiBpPDA/KHQtPTEsZT1faXNvd2VlazFtb25kYXkodCksW2ksc109JGRpdk1vZChuLWUsNykpOmk+PTUyJiZuPj1faXNvd2VlazFtb25kYXkodCsxKSYmKHQrPTEsaT0wKSxuZXcgQXQobmV3IGYodCksbmV3IGYoaSsxKSxuZXcgZihzKzEpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIGEgMy10dXBsZSBjb250YWluaW5nIElTTyB5ZWFyLCB3ZWVrIG51bWJlciwgYW5kIHdlZWtkYXkuXFxcIn0saXNvZm9ybWF0OnskbWV0aDpmdW5jdGlvbiBpc29mb3JtYXQoKXtyZXR1cm4gdGhpcy4kaXNvZm9ybWF0KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBzdHJpbmcgaW4gSVNPIDg2MDEgZm9ybWF0LCBZWVlZLU1NLURELlxcXCJ9LGlzb3dlZWtkYXk6eyRtZXRoOmZ1bmN0aW9uIGlzb3dlZWtkYXkoKXtyZXR1cm4gbmV3IGYodGhpcy4kdG9PcmRpbmFsKCklN3x8Nyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiB0aGUgZGF5IG9mIHRoZSB3ZWVrIHJlcHJlc2VudGVkIGJ5IHRoZSBkYXRlLlxcXFxuTW9uZGF5ID09IDEgLi4uIFN1bmRheSA9PSA3XFxcIn0sdG9vcmRpbmFsOnskbWV0aDpmdW5jdGlvbiB0b29yZGluYWwoKXtyZXR1cm4gbmV3IGYodGhpcy4kdG9PcmRpbmFsKCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gcHJvbGVwdGljIEdyZWdvcmlhbiBvcmRpbmFsLiAgSmFudWFyeSAxIG9mIHllYXIgMSBpcyBkYXkgMS5cXFwifSx3ZWVrZGF5OnskbWV0aDpmdW5jdGlvbiB3ZWVrZGF5KCl7cmV0dXJuIG5ldyBmKCh0aGlzLiR0b09yZGluYWwoKSs2KSU3KX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHRoZSBkYXkgb2YgdGhlIHdlZWsgcmVwcmVzZW50ZWQgYnkgdGhlIGRhdGUuXFxcXG5Nb25kYXkgPT0gMCAuLi4gU3VuZGF5ID09IDZcXFwifSxyZXBsYWNlOnskbWV0aDpmdW5jdGlvbiByZXBsYWNlKHQsZSxuKXtyZXR1cm4gdD09PXkmJih0PW5ldyBmKHRoaXMuJHllYXIpKSxlPT09eSYmKGU9bmV3IGYodGhpcy4kbW9udGgpKSxuPT09eSYmKG49bmV3IGYodGhpcy4kZGF5KSksdGhpcy5vYiR0eXBlLnRwJGNhbGwoW3QsZSxuXSl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwieWVhclxcXCIsXFxcIm1vbnRoXFxcIixcXFwiZGF5XFxcIl0sRGVmYXVsdHM6W3kseSx5XX0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gZGF0ZSB3aXRoIG5ldyBzcGVjaWZpZWQgZmllbGRzLlxcXCJ9LF9fcmVkdWNlX186eyRtZXRoKCl7cmV0dXJuIG5ldyBwKFt0aGlzLm9iJHR5cGUsbmV3IHAoW3RoaXMuJGdldFN0YXRlKCldKV0pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJfX3JlZHVjZV9fKCkgLT4gKGNscywgc3RhdGUpXFxcIn19LGdldHNldHM6e3llYXI6eyRnZXQoKXtyZXR1cm4gbmV3IGYodGhpcy4keWVhcil9LCRkb2M6XFxcInllYXIgKDEtOTk5OSlcXFwifSxtb250aDp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRtb250aCl9LCRkb2M6XFxcIm1vbnRoICgxLTEyKVxcXCJ9LGRheTp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRkYXkpfSwkZG9jOlxcXCJkYXkgKDEtMzEpXFxcIn19LHByb3RvOnskY21wKHQpe3JldHVybiBfY21wKFt0aGlzLiR5ZWFyLHRoaXMuJG1vbnRoLHRoaXMuJGRheV0sW3QuJHllYXIsdC4kbW9udGgsdC4kZGF5XSl9LCRnZXRTdGF0ZSgpe2NvbnN0W3QsZV09JGRpdk1vZCh0aGlzLiR5ZWFyLDI1Nik7cmV0dXJuIG5ldyBfKFt0LGUsdGhpcy4kbW9udGgsdGhpcy4kZGF5XSl9LCRzZXRTdGF0ZSh0KXtjb25zdFtlLG4saSxzXT10LG89MjU2KmUrbjt0aGlzLiR5ZWFyPW8sdGhpcy4kbW9udGg9aSx0aGlzLiRkYXk9c30sJHRvT3JkaW5hbCgpe3JldHVybiBfeW1kMm9yZCh0aGlzLiR5ZWFyLHRoaXMuJG1vbnRoLHRoaXMuJGRheSl9LCRpc29mb3JtYXQoKXtyZXR1cm4gbmV3IHcoYCR7X2QodGhpcy4keWVhcixcXFwiMFxcXCIsNCl9LSR7X2QodGhpcy4kbW9udGgsXFxcIjBcXFwiLDIpfS0ke19kKHRoaXMuJGRheSxcXFwiMFxcXCIsMil9YCl9LCR0aW1ldHVwbGUoKXtyZXR1cm4gX2J1aWxkX3N0cnVjdF90aW1lKHRoaXMuJHllYXIsdGhpcy4kbW9udGgsdGhpcy4kZGF5LHRoaXMuJGhvdXJ8fDAsdGhpcy4kbWlufHwwLHRoaXMuJHNlY3x8MCwtMSl9LCRzdHJmdGltZSh0PVxcXCJcXFwiKXtyZXR1cm4gX3dyYXBfc3RyZnRpbWUodGhpcyx0LnRvU3RyaW5nKCksdGhpcy4kdGltZXR1cGxlKCkpfX19KTt2dC5wcm90b3R5cGUubWluPW5ldyB2dCgxLDEsMSksdnQucHJvdG90eXBlLm1heD1uZXcgdnQoOTk5OSwxMiwzMSksdnQucHJvdG90eXBlLnJlc29sdXRpb249bmV3IHd0KDEpO2NvbnN0IE10PUUudHppbmZvPWgoXFxcImRhdGV0aW1lLnR6aW5mb1xcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHR6aW5mbygpe30sbWV0aG9kczp7dHpuYW1lOnskbWV0aDpmdW5jdGlvbiB0em5hbWUodCl7dGhyb3cgbmV3IHgoXFxcInR6aW5mbyBzdWJjbGFzcyBtdXN0IG92ZXJyaWRlIHR6bmFtZSgpXFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcImRhdGV0aW1lIC0+IHN0cmluZyBuYW1lIG9mIHRpbWUgem9uZS5cXFwifSx1dGNvZmZzZXQ6eyRtZXRoOmZ1bmN0aW9uIHV0Y29mZnNldCh0KXt0aHJvdyBuZXcgeChcXFwidHppbmZvIHN1YmNsYXNzIG11c3Qgb3ZlcnJpZGUgdXRjb2Zmc2V0KClcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiZGF0ZXRpbWUgLT4gdGltZWRlbHRhIHNob3dpbmcgb2Zmc2V0IGZyb20gVVRDLCBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGluZyBXZXN0IG9mIFVUQ1xcXCJ9LGRzdDp7JG1ldGg6ZnVuY3Rpb24gZHN0KHQpe3Rocm93IG5ldyB4KFxcXCJ0emluZm8gc3ViY2xhc3MgbXVzdCBvdmVycmlkZSBkc3QoKVxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJkYXRldGltZSAtPiBEU1Qgb2Zmc2V0IGFzIHRpbWVkZWx0YSBwb3NpdGl2ZSBlYXN0IG9mIFVUQy5cXFwifSxmcm9tdXRjOnskbWV0aDpmdW5jdGlvbiBmcm9tdXRjKGUpe2lmKCEoZSBpbnN0YW5jZW9mIE50KSl0aHJvdyBuZXcgeihcXFwiZnJvbXV0YygpIHJlcXVpcmVzIGEgZGF0ZXRpbWUgYXJndW1lbnRcXFwiKTtpZihlLiR0emluZm8hPT10aGlzKXRocm93IG5ldyB2KFxcXCJkdC50emluZm8gaXMgbm90IHNlbGZcXFwiKTtjb25zdCBuPXIoZS50cCRnZXRhdHRyKFUpKTtpZihuPT09eSl0aHJvdyBuZXcgdihcXFwiZnJvbXV0YygpIHJlcXVpcmVzIGEgbm9uLU5vbmUgdXRjb2Zmc2V0KCkgcmVzdWx0XFxcIik7bGV0IGk9cihlLnRwJGdldGF0dHIoRikpO2lmKGk9PT15KXRocm93IG5ldyB2KFxcXCJmcm9tdXRjKCkgcmVxdWlyZXMgYSBub24tTm9uZSBkc3QoKSByZXN1bHRcXFwiKTtjb25zdCBzPXEobixpLFxcXCJTdWJcXFwiKTtpZih0KHMpJiYoZT1xKGUscyxcXFwiQWRkXFxcIiksaT1yKGUudHAkZ2V0YXR0cihGKSksaT09PXkpKXRocm93IG5ldyB2KFxcXCJmcm9tdXRjKCk6IGR0LmRzdCBnYXZlIGluY29uc2lzdGVudCByZXN1bHRzOyBjYW5ub3QgY29udmVydFxcXCIpO3JldHVybiBxKGUsaSxcXFwiQWRkXFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcImRhdGV0aW1lIGluIFVUQyAtPiBkYXRldGltZSBpbiBsb2NhbCB0aW1lLlxcXCJ9LF9fcmVkdWNlX186eyRtZXRoKCl7bGV0IGUsbjtjb25zdCBpPVQodGhpcyxuZXcgdyhcXFwiX19nZXRpbml0YXJnc19fXFxcIikseSk7ZT1pIT09eT9yKGksW10pOm5ldyBwO2NvbnN0IHM9VCh0aGlzLG5ldyB3KFxcXCJfX2dldHN0YXRlX19cXFwiKSx5KTtyZXR1cm4gcyE9PXk/bj1yKHMsW10pOihuPVQodGhpcyxuZXcgdyhcXFwiX19kaWN0X19cXFwiKSx5KSxuPXQobik/bjp5KSxuZXcgcChuPT09eT9bdGhpcy5vYiR0eXBlLGVdOlt0aGlzLm9iJHR5cGUsZSxuXSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIi0+IChjbHMsIHN0YXRlKVxcXCJ9fX0pLEF0PWgoXFxcImRhdGV0aW1lLklzb0NhbGVuZGFyRGF0ZVxcXCIse2Jhc2U6cCxjb25zdHJ1Y3RvcjpmdW5jdGlvbiBJc29DYWxlbmRhckRhdGUodCxlLG4pe3RoaXMueT10LHRoaXMudz1lLHRoaXMud2Q9bixwLmNhbGwodGhpcyxbdCxlLG5dKX0sc2xvdHM6e3RwJG5ldyh0LGUpe2NvbnN0W24saSxzXT1sKFxcXCJJc29DYWxlbmRhckRhdGVcXFwiLFtcXFwieWVhclxcXCIsXFxcIndlZWtcXFwiLFxcXCJ3ZWVrZGF5XFxcIl0sdCxlKTtyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IobixpLHMpfSwkcigpe3JldHVybiBuZXcgdyhgJHt0aGlzLnRwJG5hbWV9KHllYXI9JHt0aGlzLnl9LCB3ZWVrPSR7dGhpcy53fSwgd2Vla2RheT0ke3RoaXMud2R9KWApfX0sZ2V0c2V0czp7eWVhcjp7JGdldCgpe3JldHVybiB0aGlzLnl9fSx3ZWVrOnskZ2V0KCl7cmV0dXJuIHRoaXMud319LHdlZWtkYXk6eyRnZXQoKXtyZXR1cm4gdGhpcy53ZH19fX0pLHh0PUUudGltZT1oKFxcXCJkYXRldGltZS50aW1lXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gdGltZSh0PTAsZT0wLG49MCxpPTAscz1udWxsLG89MCl7dGhpcy4kaG91cj10LHRoaXMuJG1pbj1lLHRoaXMuJHNlYz1uLHRoaXMuJG1pY3JvPWksdGhpcy4kdHppbmZvPXN8fHksdGhpcy4kZm9sZD1vLHRoaXMuJGhhc2hjb2RlPS0xfSxzbG90czp7dHAkbmV3KHQsZSl7bShcXFwidGltZVxcXCIsdCwwLDUpO2xldCBuLFtpLHMsbyxyLGEsJF09bChcXFwidGltZVxcXCIsW1xcXCJob3VyXFxcIixcXFwibWludXRlXFxcIixcXFwic2Vjb25kXFxcIixcXFwibWljcm9zZWNvbmRcXFwiLFxcXCJ0emluZm9cXFwiLFxcXCJmb2xkXFxcIl0sdCxlLFtXLFcsVyxXLHksV10pO2lmKGkgaW5zdGFuY2VvZiBfJiY2PT09KG49aS52YWx1ZU9mKCkpLmxlbmd0aCYmKDEyNyZuWzBdKTwyNCl7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gdC4kc2V0U3RhdGUobixzPT09Vz95OnMpLHR9aWYoW2kscyxvLHIsJF09X2NoZWNrX3RpbWVfZmllbGRzKGkscyxvLHIsJCksX2NoZWNrX3R6aW5mb19hcmcoYSksdGhpcz09PXh0LnByb3RvdHlwZSlyZXR1cm4gbmV3IHh0KGkscyxvLHIsYSwkKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4geHQuY2FsbCh0LGkscyxvLHIsYSwkKSx0fX0sdHAkcmljaGNvbXBhcmUodCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIHh0P19kb19jb21wYXJlKHRoaXMsdCxlKTpifSx0cCRoYXNoKCl7aWYoLTE9PT10aGlzLiRoYXNoY29kZSl7Y29uc3QgZT10aGlzLiRmb2xkP3IodGhpcy50cCRnZXRhdHRyKEopLFtdLFtcXFwiZm9sZFxcXCIsV10pOnRoaXMsbj1yKGUudHAkZ2V0YXR0cihVKSk7aWYodChuKSl7bGV0W3QsZV09cHlEaXZNb2QobmV3IHd0KDAsMzYwMCp0aGlzLiRob3VyKzYwKnRoaXMuJG1pbikubmIkc3VidHJhY3QobikscHQpO2U9ZS5uYiRmbG9vcl9kaXZpZGUoZ3QpLDA8PXQmJnQ8PTI0Pyh0PUkodCksZT1JKGUpLHRoaXMuJGhhc2hjb2RlPXUobmV3IHh0KHQsZSx0aGlzLiRzZWMsdGhpcy4kbWljcm8pKSk6dGhpcy4kaGFzaGNvZGU9dShuZXcgcChbdCxlLG5ldyBmKHRoaXMuJHNlYyksbmV3IGYodGhpcy4kbWljcm8pXSkpfWVsc2UgdGhpcy4kaGFzaGNvZGU9dShlLiRnZXRTdGF0ZSgpWzBdKX1yZXR1cm4gdGhpcy4kaGFzaGNvZGV9LCRyKCl7bGV0IHQ7cmV0dXJuIHQ9MCE9PXRoaXMuJG1pY3JvP2AsICR7dGhpcy4kc2VjfSwgJHt0aGlzLiRtaWNyb31gOjAhPT10aGlzLiRzZWM/YCwgJHt0aGlzLiRzZWN9YDpcXFwiXFxcIix0PWAke3RoaXMudHAkbmFtZX0oJHt0aGlzLiRob3VyfSwgJHt0aGlzLiRtaW59JHt0fSlgLHRoaXMuJHR6aW5mbyE9PXkmJih0PXQuc2xpY2UoMCwtMSkrXFxcIiwgdHppbmZvPVxcXCIrcyh0aGlzLiR0emluZm8pK1xcXCIpXFxcIiksdGhpcy4kZm9sZCYmKHQ9dC5zbGljZSgwLC0xKStcXFwiLCBmb2xkPTEpXFxcIiksbmV3IHcodCl9LHRwJHN0cigpe3JldHVybiB0aGlzLnRwJGdldGF0dHIoSCkudHAkY2FsbChbXSl9fSxtZXRob2RzOntpc29mb3JtYXQ6eyRtZXRoOmZ1bmN0aW9uIGlzb2Zvcm1hdCh0KXtsZXQgZT1fZm9ybWF0X3RpbWUodGhpcy4kaG91cix0aGlzLiRtaW4sdGhpcy4kc2VjLHRoaXMuJG1pY3JvLHQpO2NvbnN0IG49dGhpcy4kdHpzdHIoKTtyZXR1cm4gbiYmKGUrPW4pLG5ldyB3KGUpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInRpbWVzcGVjXFxcIl0sRGVmYXVsdHM6W0NdfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBzdHJpbmcgaW4gSVNPIDg2MDEgZm9ybWF0LCBbSEhbOk1NWzpTU1subW1tW3V1dV1dXV1dWytISDpNTV0uXFxcXG5cXFxcbnRpbWVzcGVjIHNwZWNpZmllcyB3aGF0IGNvbXBvbmVudHMgb2YgdGhlIHRpbWUgdG8gaW5jbHVkZS5cXFxcblxcXCJ9LHN0cmZ0aW1lOnskbWV0aDpmdW5jdGlvbiBzdHJmdGltZSh0KXtpZighayh0KSl0aHJvdyBuZXcgeihcXFwibXVzdCBiZSBzdHIsIG5vdCBcXFwiK2ModCkpO3JldHVybiBfd3JhcF9zdHJmdGltZSh0aGlzLHQ9dC50b1N0cmluZygpLG5ldyBwKFsxOTAwLDEsMSx0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsMCwxLC0xXS5tYXAoKHQ9Pm5ldyBmKHQpKSkpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiZm9ybWF0IC0+IHN0cmZ0aW1lKCkgc3R5bGUgc3RyaW5nLlxcXCJ9LF9fZm9ybWF0X186eyRtZXRoOmZ1bmN0aW9uIF9fZm9ybWF0X18odCl7aWYoIWsodCkpdGhyb3cgbmV3IHooXFxcIm11c3QgYmUgc3RyLCBub3QgXFxcIitjKHQpKTtyZXR1cm4gdCE9PXcuJGVtcHR5P3RoaXMudHAkZ2V0YXR0cihYKS50cCRjYWxsKFt0XSk6dGhpcy50cCRzdHIoKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRm9ybWF0cyBzZWxmIHdpdGggc3RyZnRpbWUuXFxcIn0sdXRjb2Zmc2V0OnskbWV0aDpmdW5jdGlvbiB1dGNvZmZzZXQoKXtpZih0aGlzLiR0emluZm89PT15KXJldHVybiB5O2NvbnN0IHQ9dGhpcy4kdHppbmZvLnRwJGdldGF0dHIoVSksZT1yKHQsW3ldKTtyZXR1cm4gX2NoZWNrX3V0Y19vZmZzZXQoXFxcInV0Y29mZnNldFxcXCIsZSksZX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHNlbGYudHppbmZvLnV0Y29mZnNldChzZWxmKS5cXFwifSx0em5hbWU6eyRtZXRoOmZ1bmN0aW9uIHR6bmFtZSgpe2lmKHRoaXMuJHR6aW5mbz09PXkpcmV0dXJuIHk7Y29uc3QgdD10aGlzLiR0emluZm8udHAkZ2V0YXR0cihZKSxlPXIodCxbeV0pO3JldHVybiBfY2hlY2tfdHpuYW1lKGUpLGV9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBzZWxmLnR6aW5mby50em5hbWUoc2VsZikuXFxcIn0sZHN0OnskbWV0aDpmdW5jdGlvbiBkc3QoKXtpZih0aGlzLiR0emluZm89PT15KXJldHVybiB5O2NvbnN0IHQ9dGhpcy4kdHppbmZvLnRwJGdldGF0dHIoRiksZT1yKHQsW3ldKTtyZXR1cm4gX2NoZWNrX3V0Y19vZmZzZXQoXFxcImRzdFxcXCIsZSksZX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHNlbGYudHppbmZvLmRzdChzZWxmKS5cXFwifSxyZXBsYWNlOnskbWV0aDpmdW5jdGlvbiByZXBsYWNlKHQsZSl7bShcXFwicmVwbGFjZVxcXCIsdCwwLDUpO2xldFtuLGkscyxvLHIsYV09bChcXFwicmVwbGFjZVxcXCIsW1xcXCJob3VyXFxcIixcXFwibWludXRlXFxcIixcXFwic2Vjb25kXFxcIixcXFwibWljcm9zZWNvbmRcXFwiLFxcXCJ0emluZm9cXFwiLFxcXCJmb2xkXFxcIl0sdCxlLFt5LHkseSx5LGcseV0pO3JldHVybiBuPT09eSYmKG49bmV3IGYodGhpcy4kaG91cikpLGk9PT15JiYoaT1uZXcgZih0aGlzLiRtaW4pKSxzPT09eSYmKHM9bmV3IGYodGhpcy4kc2VjKSksbz09PXkmJihvPW5ldyBmKHRoaXMuJG1pY3JvKSkscj09PWcmJihyPXRoaXMuJHR6aW5mbyksYT09PXkmJihhPW5ldyBmKHRoaXMuJGZvbGQpKSx0aGlzLm9iJHR5cGUudHAkY2FsbChbbixpLHMsbyxyXSxbXFxcImZvbGRcXFwiLGFdKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gdGltZSB3aXRoIG5ldyBzcGVjaWZpZWQgZmllbGRzLlxcXCJ9LF9fcmVkdWNlX2V4X186eyRtZXRoKHQpe3JldHVybiBuZXcgcChbdGhpcy5vYiR0eXBlLG5ldyBwKHRoaXMuJGdldFN0YXRlKFIodCkpKV0pfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJfX3JlZHVjZV9leF9fKHByb3RvKSAtPiAoY2xzLCBzdGF0ZSlcXFwifSxfX3JlZHVjZV9fOnskbWV0aCgpe3JldHVybiB0aGlzLnRwJGdldGF0dHIobmV3IHcoXFxcIl9fcmVkdWNlX2V4X19cXFwiKSkudHAkY2FsbChbbmV3IGYoMildKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiX19yZWR1Y2VfXygpIC0+IChjbHMsIHN0YXRlKVxcXCJ9fSxjbGFzc21ldGhvZHM6e2Zyb21pc29mb3JtYXQ6eyRtZXRoOmZ1bmN0aW9uIGZyb21pc29mb3JtYXQodCl7aWYoIWsodCkpdGhyb3cgbmV3IHooXFxcImZyb21pc29mb3JtYXQ6IGFyZ3VtZW50IG11c3QgYmUgc3RyXFxcIik7dD10LnRvU3RyaW5nKCk7dHJ5e3JldHVybiB0aGlzLnRwJGNhbGwoX3BhcnNlX2lzb2Zvcm1hdF90aW1lKHQpKX1jYXRjaHt0aHJvdyBuZXcgdihcXFwiSW52YWxpZCBpc29mcm1hdCBzdHJpbmc6ICdcXFwiK3QrXFxcIidcXFwiKX19LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcInN0cmluZyAtPiB0aW1lIGZyb20gdGltZS5pc29mb3JtYXQoKSBvdXRwdXRcXFwifX0sZ2V0c2V0czp7aG91cjp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRob3VyKX19LG1pbnV0ZTp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRtaW4pfX0sc2Vjb25kOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJHNlYyl9fSxtaWNyb3NlY29uZDp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRtaWNybyl9fSx0emluZm86eyRnZXQoKXtyZXR1cm4gdGhpcy4kdHppbmZvfX0sZm9sZDp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRmb2xkKX19fSxwcm90bzp7JGNtcCh0LG4pe2NvbnN0IHM9dGhpcy4kdHppbmZvLG89dC4kdHppbmZvO2xldCBhLCQsYztpZihhPSQ9eSxzPT09bz9jPSEwOihhPXIodGhpcy50cCRnZXRhdHRyKFUpKSwkPXIodC50cCRnZXRhdHRyKFUpKSxjPWUoYSwkLFxcXCJFcVxcXCIpKSxjKXJldHVybiBfY21wKFt0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsdGhpcy4kbWljcm9dLFt0LiRob3VyLHQuJG1pbix0LiRzZWMsdC4kbWljcm9dKTtpZihhPT09eXx8JD09PXkpe2lmKFxcXCJFcVxcXCI9PT1ufHxcXFwiTm90RXFcXFwiPT09bilyZXR1cm4gMjt0aHJvdyBuZXcgeihcXFwiY2Fubm90IGNvbXBhcmUgbmFpdmUgYW5kIGF3YXJlIHRpbWVzXFxcIil9Y29uc3QgaD02MCp0aGlzLiRob3VyK3RoaXMuJG1pbi1pKGEubmIkZmxvb3JfZGl2aWRlKGd0KSksbT02MCp0LiRob3VyK3QuJG1pbi1pKCQubmIkZmxvb3JfZGl2aWRlKGd0KSk7cmV0dXJuIF9jbXAoW2gsdGhpcy4kc2VjLHRoaXMuJG1pY3JvXSxbbSx0LiRzZWMsdC4kbWljcm9dKX0sJHR6c3RyKCl7cmV0dXJuIF9mb3JtYXRfb2Zmc2V0KHIodGhpcy50cCRnZXRhdHRyKFUpKSl9LCRnZXRTdGF0ZSh0PTMpe2xldFtlLG5dPSRkaXZNb2QodGhpcy4kbWljcm8sMjU2KSxbaSxzXT0kZGl2TW9kKGUsMjU2KSxvPXRoaXMuJGhvdXI7dGhpcy4kZm9sZCYmdD4zJiYobys9MTI4KTtjb25zdCByPW5ldyBfKFtvLHRoaXMuJG1pbix0aGlzLiRzZWMsaSxzLG5dKTtyZXR1cm4gdGhpcy4kdHppbmZvPT09eT9bcl06W3IsdGhpcy4kdHppbmZvXX0sJHNldFN0YXRlKHQsZSl7Y29uc3RbbixpLHMsbyxyLGFdPXQ7bj4xMjc/KHRoaXMuJGZvbGQ9MSx0aGlzLiRob3VyPW4tMTI4KToodGhpcy4kZm9sZD0wLHRoaXMuJGhvdXI9biksdGhpcy4kbWluPWksdGhpcy4kc2VjPXMsdGhpcy4kbWljcm89KG88PDh8cik8PDh8YSx0aGlzLiR0emluZm89ZX19fSk7eHQucHJvdG90eXBlLm1pbj1uZXcgeHQoMCwwLDApLHh0LnByb3RvdHlwZS5tYXg9bmV3IHh0KDIzLDU5LDU5LDk5OTk5OSkseHQucHJvdG90eXBlLnJlc29sdXRpb249bmV3IHd0O2NvbnN0IE50PUUuZGF0ZXRpbWU9aChcXFwiZGF0ZXRpbWUuZGF0ZXRpbWVcXFwiLHtiYXNlOnZ0LGNvbnN0cnVjdG9yOmZ1bmN0aW9uIGRhdGV0aW1lKHQsZSxuLGk9MCxzPTAsbz0wLHI9MCxhPW51bGwsJD0wKXt0aGlzLiR5ZWFyPXQsdGhpcy4kbW9udGg9ZSx0aGlzLiRkYXk9bix0aGlzLiRob3VyPWksdGhpcy4kbWluPXMsdGhpcy4kc2VjPW8sdGhpcy4kbWljcm89cix0aGlzLiR0emluZm89YXx8eSx0aGlzLiRmb2xkPSQsdGhpcy4kaGFzaGNvZGU9LTF9LHNsb3RzOnt0cCRuZXcodCxlKXttKFxcXCJkYXRldGltZVxcXCIsdCwwLDkpO2xldCBuLFtpLHMsbyxyLGEsJCxjLGgsdV09bChcXFwidGltZVxcXCIsW1xcXCJ5ZWFyXFxcIixcXFwibW9udGhcXFwiLFxcXCJkYXlcXFwiLFxcXCJob3VyXFxcIixcXFwibWludXRlXFxcIixcXFwic2Vjb25kXFxcIixcXFwibWljcm9zZWNvbmRcXFwiLFxcXCJ0emluZm9cXFwiLFxcXCJmb2xkXFxcIl0sdCxlLFtudWxsLG51bGwsVyxXLFcsVyx5LFddKTtpZihpIGluc3RhbmNlb2YgXyYmMTA9PT0obj1pLnZhbHVlT2YoKSkubGVuZ3RoJiYoMTI3Jm5bMl0pPD0xMil7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gdC4kc2V0U3RhdGUobixudWxsPT09cz95OnMpLHR9aWYoW2kscyxvXT1fY2hlY2tfZGF0ZV9maWVsZHMoaSxzLG8pLFtyLGEsJCxjLHVdPV9jaGVja190aW1lX2ZpZWxkcyhyLGEsJCxjLHUpLF9jaGVja190emluZm9fYXJnKGgpLHRoaXM9PT1OdC5wcm90b3R5cGUpcmV0dXJuIG5ldyBOdChpLHMsbyxyLGEsJCxjLGgsdSk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIE50LmNhbGwodCxpLHMsbyxyLGEsJCxjLGgsdSksdH19LCRyKCl7Y29uc3QgdD1bdGhpcy4keWVhcix0aGlzLiRtb250aCx0aGlzLiRkYXksdGhpcy4kaG91cix0aGlzLiRtaW4sdGhpcy4kc2VjLHRoaXMuJG1pY3JvXTswPT09dFt0Lmxlbmd0aC0xXSYmdC5wb3AoKSwwPT09dFt0Lmxlbmd0aC0xXSYmdC5wb3AoKTtsZXQgZT1gJHt0aGlzLnRwJG5hbWV9KCR7dC5qb2luKFxcXCIsIFxcXCIpfSlgO3JldHVybiB0aGlzLiR0emluZm8hPT15JiYoZT1lLnNsaWNlKDAsLTEpK1xcXCIsIHR6aW5mbz1cXFwiK3ModGhpcy4kdHppbmZvKStcXFwiKVxcXCIpLHRoaXMuJGZvbGQmJihlPWUuc2xpY2UoMCwtMSkrXFxcIiwgZm9sZD0xKVxcXCIpLG5ldyB3KGUpfSx0cCRzdHIoKXtyZXR1cm4gdGhpcy50cCRnZXRhdHRyKEgpLnRwJGNhbGwoW10sW1xcXCJzZXBcXFwiLG5ldyB3KFxcXCIgXFxcIildKX0sdHAkcmljaGNvbXBhcmUodCxlKXtpZih0IGluc3RhbmNlb2YgTnQpcmV0dXJuIF9kb19jb21wYXJlKHRoaXMsdCxlKTtpZighKHQgaW5zdGFuY2VvZiB2dCkpcmV0dXJuIGI7aWYoXFxcIkVxXFxcIj09PWV8fFxcXCJOb3RFcVxcXCI9PT1lKXJldHVyblxcXCJOb3RFcVxcXCI9PT1lO3Rocm93IG5ldyB6KGBjYW4ndCBjb21wYXJlICcke2ModGhpcyl9JyB0byAnJHtjKHQpfSdgKX0sdHAkYXNfbnVtYmVyOiEwLG5iJGFkZCh0KXtpZighKHQgaW5zdGFuY2VvZiB3dCkpcmV0dXJuIGI7bGV0IGU9bmV3IHd0KHRoaXMuJHRvT3JkaW5hbCgpLDM2MDAqdGhpcy4kaG91cis2MCp0aGlzLiRtaW4rdGhpcy4kc2VjLHRoaXMuJG1pY3JvKTtlPXEoZSx0LFxcXCJBZGRcXFwiKTtsZXRbbixpXT0kZGl2TW9kKGUuJHNlY3MsMzYwMCksW3Msb109JGRpdk1vZChpLDYwKTtpZigwPGUuJGRheXMmJmUuJGRheXM8PXJ0KXJldHVybiB0aGlzLm9iJHR5cGUudHAkZ2V0YXR0cihuZXcgdyhcXFwiY29tYmluZVxcXCIpKS50cCRjYWxsKFt2dC50cCRjYWxsKF9vcmQyeW1kKGUuJGRheXMpKSxuZXcgeHQobixzLG8sZS4kbWljcm8sdGhpcy4kdHppbmZvKV0pO3Rocm93IG5ldyBNKFxcXCJyZXN1bHQgb3V0IG9mIHJhbmdlXFxcIil9LG5iJHN1YnRyYWN0KHQpe2lmKCEodCBpbnN0YW5jZW9mIE50KSlyZXR1cm4gdCBpbnN0YW5jZW9mIHd0P3RoaXMubmIkYWRkKHQubmIkbmVnYXRpdmUoKSk6Yjtjb25zdCBuPXRoaXMuJHRvT3JkaW5hbCgpLGk9dC4kdG9PcmRpbmFsKCkscz10aGlzLiRzZWMrNjAqdGhpcy4kbWluKzM2MDAqdGhpcy4kaG91cixvPXQuJHNlYys2MCp0LiRtaW4rMzYwMCp0LiRob3VyLGE9bmV3IHd0KG4taSxzLW8sdGhpcy4kbWljcm8tdC4kbWljcm8pO2lmKHRoaXMuJHR6aW5mbz09PXQuJHR6aW5mbylyZXR1cm4gYTtjb25zdCAkPXIodGhpcy50cCRnZXRhdHRyKFUpKSxjPXIodC50cCRnZXRhdHRyKFUpKTtpZihlKCQsYyxcXFwiRXFcXFwiKSlyZXR1cm4gYTtpZigkPT09eXx8Yz09PXkpdGhyb3cgbmV3IHooXFxcImNhbm5vdCBtaXggbmFpdmUgYW5kIHRpbWV6b25lLWF3YXJlIHRpbWVcXFwiKTtyZXR1cm4gYS5uYiRhZGQoYykubmIkc3VidHJhY3QoJCl9LG5iJHJlZmxlY3RlZF9zdWJ0cmFjdDpudWxsLHRwJGhhc2goKXtpZigtMT09PXRoaXMuJGhhc2hjb2RlKXtjb25zdCB0PXRoaXMuJGZvbGQ/cih0aGlzLnRwJGdldGF0dHIoSiksW10sW1xcXCJmb2xkXFxcIixXXSk6dGhpcyxlPXIodC50cCRnZXRhdHRyKFUpKTtpZihlPT09eSl0aGlzLiRoYXNoY29kZT11KHQuJGdldFN0YXRlKClbMF0pO2Vsc2V7Y29uc3QgdD1feW1kMm9yZCh0aGlzLiR5ZWFyLHRoaXMuJG1vbnRoLHRoaXMuJGRheSksbj0zNjAwKnRoaXMuJGhvdXIrNjAqdGhpcy4kbWluK3RoaXMuJHNlYzt0aGlzLiRoYXNoY29kZT11KG5ldyB3dCh0LG4sdGhpcy4kbWljcm8pLm5iJHN1YnRyYWN0KGUpKX19cmV0dXJuIHRoaXMuJGhhc2hjb2RlfX0sbWV0aG9kczp7ZGF0ZTp7JG1ldGg6ZnVuY3Rpb24gX2RhdGUoKXtyZXR1cm4gbmV3IHZ0KHRoaXMuJHllYXIsdGhpcy4kbW9udGgsdGhpcy4kZGF5KX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIGRhdGUgb2JqZWN0IHdpdGggc2FtZSB5ZWFyLCBtb250aCBhbmQgZGF5LlxcXCJ9LHRpbWU6eyRtZXRoOmZ1bmN0aW9uIF90aW1lKCl7cmV0dXJuIG5ldyB4dCh0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsdGhpcy4kbWljcm8seSx0aGlzLiRmb2xkKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHRpbWUgb2JqZWN0IHdpdGggc2FtZSB0aW1lIGJ1dCB3aXRoIHR6aW5mbz1Ob25lLlxcXCJ9LHRpbWV0ejp7JG1ldGg6ZnVuY3Rpb24gdGltZXR6KCl7cmV0dXJuIG5ldyB4dCh0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsdGhpcy4kbWljcm8sdGhpcy4kdHppbmZvLHRoaXMuJGZvbGQpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gdGltZSBvYmplY3Qgd2l0aCBzYW1lIHRpbWUgYW5kIHR6aW5mby5cXFwifSxjdGltZTp7JG1ldGg6ZnVuY3Rpb24gY3RpbWUoKXtjb25zdCB0PXRoaXMuJHRvT3JkaW5hbCgpJTd8fDcsZT1mdFt0XSxuPWx0W3RoaXMuJG1vbnRoXTtyZXR1cm4gbmV3IHcoYCR7ZX0gJHtufSAke19kKHRoaXMuJGRheSxcXFwiIFxcXCIsMil9ICR7X2QodGhpcy4kaG91cixcXFwiMFxcXCIsMil9OiR7X2QodGhpcy4kbWluLFxcXCIwXFxcIiwyKX06JHtfZCh0aGlzLiRzZWMsXFxcIjBcXFwiLDIpfSAke19kKHRoaXMuJHllYXIsXFxcIjBcXFwiLDQpfWApfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gY3RpbWUoKSBzdHlsZSBzdHJpbmcuXFxcIn0sdGltZXR1cGxlOnskbWV0aDpmdW5jdGlvbiB0aW1ldHVwbGUoKXtsZXQgZT1yKHRoaXMudHAkZ2V0YXR0cihGKSk7cmV0dXJuIGU9ZT09PXk/LTE6dChlKT8xOjAsX2J1aWxkX3N0cnVjdF90aW1lKHRoaXMuJHllYXIsdGhpcy4kbW9udGgsdGhpcy4kZGF5LHRoaXMuJGhvdXIsdGhpcy4kbWluLHRoaXMuJHNlYyxlKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHRpbWUgdHVwbGUsIGNvbXBhdGlibGUgd2l0aCB0aW1lLmxvY2FsdGltZSgpLlxcXCJ9LHRpbWVzdGFtcDp7JG1ldGg6ZnVuY3Rpb24gdGltZXN0YW1wKCl7aWYodGhpcy4kdHppbmZvPT09eSl7bGV0IHQ9dGhpcy4kbWtUaW1lKCk7cmV0dXJuIHQ9SSh0KSxuZXcgZCh0K3RoaXMuJG1pY3JvLzFlNil9e2NvbnN0IHQ9cSh0aGlzLGt0LFxcXCJTdWJcXFwiKTtyZXR1cm4gbmV3IGQoKCg4NjQwMCp0LiRkYXlzK3QuJHNlY3MpKjEwKio2K3QuJG1pY3JvKS8xMCoqNil9fSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gUE9TSVggdGltZXN0YW1wIGFzIGZsb2F0LlxcXCJ9LHV0Y3RpbWV0dXBsZTp7JG1ldGg6ZnVuY3Rpb24gdXRjdGltZXR1cGxlKCl7Y29uc3QgZT1yKHRoaXMudHAkZ2V0YXR0cihVKSk7bGV0IG49dGhpcztyZXR1cm4gdChlKSYmKG49cShuLGUsXFxcIlN1YlxcXCIpKSxfYnVpbGRfc3RydWN0X3RpbWUobi4keWVhcixuLiRtb250aCxuLiRkYXksbi4kaG91cixuLiRtaW4sbi4kc2VjLDApfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gVVRDIHRpbWUgdHVwbGUsIGNvbXBhdGlibGUgd2l0aCB0aW1lLmxvY2FsdGltZSgpLlxcXCJ9LGlzb2Zvcm1hdDp7JG1ldGg6ZnVuY3Rpb24gaXNvZm9ybWF0KHQsZSl7aWYoIWsodCkpdGhyb3cgbmV3IHooXFxcInNlcCBtdXN0IGJlIHN0ciwgbm90IFxcXCIrYyh0KSk7bGV0IG49YCR7X2QodGhpcy4keWVhcixcXFwiMFxcXCIsNCl9LSR7X2QodGhpcy4kbW9udGgsXFxcIjBcXFwiLDIpfS0ke19kKHRoaXMuJGRheSxcXFwiMFxcXCIsMil9YCt0LnRvU3RyaW5nKCk7bis9X2Zvcm1hdF90aW1lKHRoaXMuJGhvdXIsdGhpcy4kbWluLHRoaXMuJHNlYyx0aGlzLiRtaWNybyxlKTtjb25zdCBpPV9mb3JtYXRfb2Zmc2V0KHIodGhpcy50cCRnZXRhdHRyKFUpKSk7cmV0dXJuIGkmJihuKz1pKSxuZXcgdyhuKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJzZXBcXFwiLFxcXCJ0aW1lc3BlY1xcXCJdLERlZmF1bHRzOltuZXcgdyhcXFwiVFxcXCIpLENdfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIltzZXBdIC0+IHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQsIFlZWVktTU0tRERUW0hIWzpNTVs6U1NbLm1tbVt1dXVdXV1dXVsrSEg6TU1dLlxcXFxuc2VwIGlzIHVzZWQgdG8gc2VwYXJhdGUgdGhlIHllYXIgZnJvbSB0aGUgdGltZSwgYW5kIGRlZmF1bHRzIHRvICdUJy5cXFxcbnRpbWVzcGVjIHNwZWNpZmllcyB3aGF0IGNvbXBvbmVudHMgb2YgdGhlIHRpbWUgdG8gaW5jbHVkZSAoYWxsb3dlZCB2YWx1ZXMgYXJlICdhdXRvJywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycsICdtaWxsaXNlY29uZHMnLCBhbmQgJ21pY3Jvc2Vjb25kcycpLlxcXFxuXFxcIn0sdXRjb2Zmc2V0OnskbWV0aDpmdW5jdGlvbiB1dGNvZmZzZXQoKXtpZih0aGlzLiR0emluZm89PT15KXJldHVybiB5O2NvbnN0IHQ9dGhpcy4kdHppbmZvLnRwJGdldGF0dHIoVSksZT1yKHQsW3RoaXNdKTtyZXR1cm4gX2NoZWNrX3V0Y19vZmZzZXQoXFxcInV0Y29mZnNldFxcXCIsZSksZX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHNlbGYudHppbmZvLnV0Y29mZnNldChzZWxmKS5cXFwifSx0em5hbWU6eyRtZXRoOmZ1bmN0aW9uIHR6bmFtZSgpe2lmKHRoaXMuJHR6aW5mbz09PXkpcmV0dXJuIHk7Y29uc3QgdD10aGlzLiR0emluZm8udHAkZ2V0YXR0cihZKSxlPXIodCxbdGhpc10pO3JldHVybiBfY2hlY2tfdHpuYW1lKGUpLGV9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBzZWxmLnR6aW5mby50em5hbWUoc2VsZikuXFxcIn0sZHN0OnskbWV0aDpmdW5jdGlvbiBkc3QoKXtpZih0aGlzLiR0emluZm89PT15KXJldHVybiB5O2NvbnN0IHQ9dGhpcy4kdHppbmZvLnRwJGdldGF0dHIoRiksZT1yKHQsW3RoaXNdKTtyZXR1cm4gX2NoZWNrX3V0Y19vZmZzZXQoXFxcImRzdFxcXCIsZSksZX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIHNlbGYudHppbmZvLmRzdChzZWxmKS5cXFwifSxyZXBsYWNlOnskbWV0aDpmdW5jdGlvbiByZXBsYWNlKHQsZSl7bShcXFwicmVwbGFjZVxcXCIsdCwwLDgpO2xldFtuLGkscyxvLHIsYSwkLGMsaF09bChcXFwicmVwbGFjZVxcXCIsW1xcXCJ5ZWFyXFxcIixcXFwibW9udGhcXFwiLFxcXCJkYXlcXFwiLFxcXCJob3VyXFxcIixcXFwibWludXRlXFxcIixcXFwic2Vjb25kXFxcIixcXFwibWljcm9zZWNvbmRcXFwiLFxcXCJ0emluZm9cXFwiLFxcXCJmb2xkXFxcIl0sdCxlLFt5LHkseSx5LHkseSx5LGcseV0pO3JldHVybiBuPT09eSYmKG49bmV3IGYodGhpcy4keWVhcikpLGk9PT15JiYoaT1uZXcgZih0aGlzLiRtb250aCkpLHM9PT15JiYocz1uZXcgZih0aGlzLiRkYXkpKSxvPT09eSYmKG89bmV3IGYodGhpcy4kaG91cikpLHI9PT15JiYocj1uZXcgZih0aGlzLiRtaW4pKSxhPT09eSYmKGE9bmV3IGYodGhpcy4kc2VjKSksJD09PXkmJigkPW5ldyBmKHRoaXMuJG1pY3JvKSksYz09PWcmJihjPXRoaXMuJHR6aW5mbyksaD09PXkmJihoPW5ldyBmKHRoaXMuJGZvbGQpKSx0aGlzLm9iJHR5cGUudHAkY2FsbChbbixpLHMsbyxyLGEsJCxjXSxbXFxcImZvbGRcXFwiLGhdKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZXR1cm4gZGF0ZXRpbWUgd2l0aCBuZXcgc3BlY2lmaWVkIGZpZWxkcy5cXFwifSxhc3RpbWV6b25lOnskbWV0aDpmdW5jdGlvbiBhc3RpbWV6b25lKHQpe2lmKHQ9PT15KXQ9dGhpcy4kbG9jYWxUaW1lem9uZSgpO2Vsc2UgaWYoISh0IGluc3RhbmNlb2YgTXQpKXRocm93IG5ldyB6KFxcXCJ0eiBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHR6aW5mb1xcXCIpO2xldCBlLG49dGhpcy4kdHppbmZvO2lmKG49PT15PyhuPXRoaXMuJGxvY2FsVGltZXpvbmUoKSxlPXIobi50cCRnZXRhdHRyKFUpLFt0aGlzXSkpOihlPXIobi50cCRnZXRhdHRyKFUpLFt0aGlzXSksZT09PXkmJihuPXIodGhpcy50cCRnZXRhdHRyKEopLFtdLFtcXFwidHppbmZvXFxcIix5XSkuJGxvY2FsVGltZXpvbmUoKSxlPXIobi50cCRnZXRhdHRyKFUpLFt0aGlzXSkpKSx0PT09bilyZXR1cm4gdGhpcztjb25zdCBpPXIodGhpcy5uYiRzdWJ0cmFjdChlKS50cCRnZXRhdHRyKEopLFtdLFtcXFwidHppbmZvXFxcIix0XSk7cmV0dXJuIHQudHAkZ2V0YXR0cihQKS50cCRjYWxsKFtpXSl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwidHpcXFwiXSxEZWZhdWx0czpbeV19LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwidHogLT4gY29udmVydCB0byBsb2NhbCB0aW1lIGluIG5ldyB0aW1lem9uZSB0elxcXFxuXFxcIn0sX19yZWR1Y2VfZXhfXzp7JG1ldGgodCl7cmV0dXJuIG5ldyBwKFt0aGlzLm9iJHR5cGUsbmV3IHAodGhpcy4kZ2V0U3RhdGUoUih0KSkpXSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIl9fcmVkdWNlX2V4X18ocHJvdG8pIC0+IChjbHMsIHN0YXRlKVxcXCJ9LF9fcmVkdWNlX186eyRtZXRoKCl7cmV0dXJuIHRoaXMudHAkZ2V0YXR0cihuZXcgdyhcXFwiX19yZWR1Y2VfZXhfX1xcXCIpKS50cCRjYWxsKFtuZXcgZigyKV0pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJfX3JlZHVjZV9fKCkgLT4gKGNscywgc3RhdGUpXFxcIn19LGNsYXNzbWV0aG9kczp7bm93OnskbWV0aDpmdW5jdGlvbiBub3codCl7Y29uc3QgZT0kLnRpbWUudHAkY2FsbChbXSk7cmV0dXJuIHRoaXMudHAkZ2V0YXR0cihCKS50cCRjYWxsKFtlLHRdKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ0elxcXCJdLERlZmF1bHRzOlt5XX0sJHRleHRzaWc6XFxcIigkdHlwZSwgLywgdHo9Tm9uZSlcXFwiLCRkb2M6XFxcIlJldHVybnMgbmV3IGRhdGV0aW1lIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCB0aW1lIGxvY2FsIHRvIHR6LlxcXFxuXFxcXG4gIHR6XFxcXG4gICAgVGltZXpvbmUgb2JqZWN0LlxcXFxuXFxcXG5JZiBubyB0eiBpcyBzcGVjaWZpZWQsIHVzZXMgbG9jYWwgdGltZXpvbmUuXFxcIn0sdXRjbm93OnskbWV0aDpmdW5jdGlvbiB1dGNub3coKXtjb25zdCB0PSQudGltZS50cCRjYWxsKFtdKTtyZXR1cm4gdGhpcy50cCRnZXRhdHRyKEwpLnRwJGNhbGwoW3RdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIGEgbmV3IGRhdGV0aW1lIHJlcHJlc2VudGluZyBVVEMgZGF5IGFuZCB0aW1lLlxcXCJ9LGZyb210aW1lc3RhbXA6eyRtZXRoOmZ1bmN0aW9uIGZyb210aW1lc3RhbXAodCxlKXtyZXR1cm4gX2NoZWNrX3R6aW5mb19hcmcoZSksdGhpcy5wcm90b3R5cGUuJGZyb210aW1lc3RhbXAuY2FsbCh0aGlzLHQsZSE9PXksZSl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwidGltZXN0YW1wXFxcIixcXFwidHpcXFwiXSxEZWZhdWx0czpbeV19LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwidGltZXN0YW1wWywgdHpdIC0+IHR6J3MgbG9jYWwgdGltZSBmcm9tIFBPU0lYIHRpbWVzdGFtcC5cXFwifSx1dGNmcm9tdGltZXN0YW1wOnskbWV0aDpmdW5jdGlvbiB1dGNmcm9tdGltZXN0YW1wKHQpe3JldHVybiB0aGlzLnByb3RvdHlwZS4kZnJvbXRpbWVzdGFtcC5jYWxsKHRoaXMsdCwhMCx5KX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiQ29uc3RydWN0IGEgbmFpdmUgVVRDIGRhdGV0aW1lIGZyb20gYSBQT1NJWCB0aW1lc3RhbXAuXFxcIn0sc3RycHRpbWU6eyRtZXRoOmZ1bmN0aW9uIHN0cnB0aW1lKHQsZSl7cmV0dXJuIG51bGw9PT1vdD9Tay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRNb2R1bGUoXFxcIl9zdHJwdGltZVxcXCIsITEsITApLChuPT4ob3Q9bi50cCRnZXRhdHRyKG5ldyB3KFxcXCJfc3RycHRpbWVfZGF0ZXRpbWVcXFwiKSksb3QudHAkY2FsbChbdGhpcyx0LGVdKSkpKTpvdC50cCRjYWxsKFt0aGlzLHQsZV0pfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwic3RyaW5nLCBmb3JtYXQgLT4gbmV3IGRhdGV0aW1lIHBhcnNlZCBmcm9tIGEgc3RyaW5nIChsaWtlIHRpbWUuc3RycHRpbWUoKSkuXFxcIn0sY29tYmluZTp7JG1ldGg6ZnVuY3Rpb24gY29tYmluZSh0LGUsbil7aWYoISh0IGluc3RhbmNlb2YgdnQpKXRocm93IG5ldyB6KFxcXCJkYXRlIGFyZ3VtZW50IG11c3QgYmUgYSBkYXRlIGluc3RhbmNlXFxcIik7aWYoIShlIGluc3RhbmNlb2YgeHQpKXRocm93IG5ldyB6KFxcXCJ0aW1lIGFyZ3VtZW50IG11c3QgYmUgYSB0aW1lIGluc3RhbmNlXFxcIik7bj09PWcmJihuPWUuJHR6aW5mbyk7Y29uc3QgaT1bdC4keWVhcix0LiRtb250aCx0LiRkYXksZS4kaG91cixlLiRtaW4sZS4kc2VjLGUuJG1pY3JvXS5tYXAoKHQ9Pm5ldyBmKHQpKSk7cmV0dXJuIGkucHVzaChuKSx0aGlzLnRwJGNhbGwoaSxbXFxcImZvbGRcXFwiLG5ldyBmKGUuJGZvbGQpXSl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwiZGF0ZVxcXCIsXFxcInRpbWVcXFwiLFxcXCJ0emluZm9cXFwiXSxEZWZhdWx0czpbZ119LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiZGF0ZSwgdGltZSAtPiBkYXRldGltZSB3aXRoIHNhbWUgZGF0ZSBhbmQgdGltZSBmaWVsZHNcXFwifSxmcm9taXNvZm9ybWF0OnskbWV0aDpmdW5jdGlvbiBmcm9taXNvZm9ybWF0KHQpe2lmKCFrKHQpKXRocm93IG5ldyB6KFxcXCJmcm9taXNvZm9ybWF0OiBhcmd1bWVudCBtdXN0IGJlIHN0clxcXCIpO2NvbnN0IGU9KHQ9dC50b1N0cmluZygpKS5zbGljZSgwLDEwKSxuPXQuc2xpY2UoMTEpO2xldCBpLHM7dHJ5e2k9X3BhcnNlX2lzb2Zvcm1hdF9kYXRlKGUpfWNhdGNoKG8pe3Rocm93IG5ldyB2KFxcXCJJbnZhbGlkIGlzb2Zvcm1hdCBzdHJpbmc6ICdcXFwiK3QrXFxcIidcXFwiKX1pZihuKXRyeXtzPV9wYXJzZV9pc29mb3JtYXRfdGltZShuKX1jYXRjaChvKXt0aHJvdyBuZXcgdihcXFwiSW52YWxpZCBpc29mb3JtYXQgc3RyaW5nOiAnXFxcIit0K1xcXCInXFxcIil9ZWxzZSBzPVtXLFcsVyxXLHldO3JldHVybiB0aGlzLnRwJGNhbGwoaS5jb25jYXQocykpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJzdHJpbmcgLT4gZGF0ZXRpbWUgZnJvbSBkYXRldGltZS5pc29mb3JtYXQoKSBvdXRwdXRcXFwifX0sZ2V0c2V0czp7aG91cjp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRob3VyKX19LG1pbnV0ZTp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRtaW4pfX0sc2Vjb25kOnskZ2V0KCl7cmV0dXJuIG5ldyBmKHRoaXMuJHNlYyl9fSxtaWNyb3NlY29uZDp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRtaWNybyl9fSx0emluZm86eyRnZXQoKXtyZXR1cm4gdGhpcy4kdHppbmZvfX0sZm9sZDp7JGdldCgpe3JldHVybiBuZXcgZih0aGlzLiRmb2xkKX19fSxwcm90bzp7JGNtcChuLGkpe2NvbnN0IHM9dGhpcy4kdHppbmZvLG89bi4kdHppbmZvO2xldCBhLCQsYztpZihhPSQ9eSxzPT09byljPSEwO2Vsc2V7aWYoYT1yKHRoaXMudHAkZ2V0YXR0cihVKSksJD1yKG4udHAkZ2V0YXR0cihVKSksXFxcIkVxXFxcIj09PWl8fFxcXCJOb3RFcVxcXCI9PT1pKXtjb25zdCB0PXIodGhpcy50cCRnZXRhdHRyKEopLFtdLFtcXFwiZm9sZFxcXCIsbmV3IGYoTnVtYmVyKCF0aGlzLiRmb2xkKSldKTtpZihlKGEscih0LnRwJGdldGF0dHIoVSkpLFxcXCJOb3RFcVxcXCIpKXJldHVybiAyO2NvbnN0IGk9cihuLnRwJGdldGF0dHIoSiksW10sW1xcXCJmb2xkXFxcIixuZXcgZihOdW1iZXIoIW4uJGZvbGQpKV0pO2lmKGUoJCxyKGkudHAkZ2V0YXR0cihVKSksXFxcIk5vdEVxXFxcIikpcmV0dXJuIDJ9Yz1lKGEsJCxcXFwiRXFcXFwiKX1pZihjKXJldHVybiBfY21wKFt0aGlzLiR5ZWFyLHRoaXMuJG1vbnRoLHRoaXMuJGRheSx0aGlzLiRob3VyLHRoaXMuJG1pbix0aGlzLiRzZWMsdGhpcy4kbWljcm9dLFtuLiR5ZWFyLG4uJG1vbnRoLG4uJGRheSxuLiRob3VyLG4uJG1pbixuLiRzZWMsbi4kbWljcm9dKTtpZihhPT09eXx8JD09PXkpe2lmKFxcXCJFcVxcXCI9PT1pfHxcXFwiTm90RXFcXFwiPT09aSlyZXR1cm4gMjt0aHJvdyBuZXcgeihcXFwiY2Fubm90IGNvbXBhcmUgbmFpdmUgYW5kIGF3YXJlIGRhdGV0aW1lc1xcXCIpfWNvbnN0IGg9dGhpcy5uYiRzdWJ0cmFjdChuKTtyZXR1cm4gaC4kZGF5czwwPy0xOnQoaCk/MTowfSwkbWtUaW1lKCl7Y29uc3QgdD1uZXcgTnQoMTk3MCwxLDEpLGU9dGhpcy5uYiRzdWJ0cmFjdCh0KS5uYiRmbG9vcl9kaXZpZGUoeXQpO2Z1bmN0aW9uIGxvY2FsKGUpe2NvbnN0W24saSxzLG8scixhXT0kLmxvY2FsdGltZS50cCRjYWxsKFtlXSkudjtyZXR1cm4gTnQudHAkY2FsbChbbixpLHMsbyxyLGFdKS5uYiRzdWJ0cmFjdCh0KS5uYiRmbG9vcl9kaXZpZGUoeXQpfWxldCBuLGkscz1sb2NhbChlKS5uYiRzdWJ0cmFjdChlKSxvPWUubmIkc3VidHJhY3Qocykscj1sb2NhbChvKTtpZihyLm9iJGVxKGUpKXtpZihuPW8ubmIkYWRkKFtuZXcgZigtODY0MDApLG5ldyBmKDg2NDAwKV1bdGhpcy4kZm9sZF0pLGk9bG9jYWwobikubmIkc3VidHJhY3Qobikscy5vYiRlcShpKSlyZXR1cm4gb31lbHNlIGk9ci5uYiRzdWJ0cmFjdChvKTtuPWUubmIkc3VidHJhY3QoaSk7aWYobG9jYWwobikub2IkZXEoZSkpcmV0dXJuIG47aWYoci5vYiRlcShlKSlyZXR1cm4gbztjb25zdCBhPW8ub2IkZ2Uobik/bzpuO3JldHVyblthLG89PT1hP246b11bdGhpcy4kZm9sZF19LCRmcm9tdGltZXN0YW1wKHQsbixzKXtsZXQgbztpZighTih0KSl0aHJvdyBuZXcgeihcXFwiYSBudW1iZXIgaXMgcmVxdWlyZWQsIChnb3QgJ1xcXCIrYyh0KStcXFwiJ1xcXCIpO1tvLHRdPW1vZGYodCk7bGV0IGE9aW50Um91bmQocShvLG50LFxcXCJNdWx0XFxcIikpO2E9YS52LHQ9dC52LGE+PTFlNj8odCs9MSxhLT0xZTYpOmE8MCYmKHQtPTEsYSs9MWU2KSx0PW5ldyBmKHQpLE51bWJlci5pc0ludGVnZXIoYSl8fChhPU1hdGgudHJ1bmMoYSkpLGE9bmV3IGYoYSk7Y29uc3QgaD1uPyQuZ210aW1lOiQubG9jYWx0aW1lO2Z1bmN0aW9uIGNvbnZlcnRlcih0KXtyZXR1cm4gaC50cCRjYWxsKFt0XSkudn1sZXRbbSx1LGwsZCxfLHBdPWNvbnZlcnRlcih0KTtwPW5ldyBmKE1hdGgubWluKGkocCksNTkpKTtsZXQgZz1yKHRoaXMsW20sdSxsLGQsXyxwLGEsc10pO2lmKHM9PT15KXtjb25zdCBuPTg2NDAwO1ttLHUsbCxkLF8scF09Y29udmVydGVyKHEodCxuZXcgZihuKSxcXFwiU3ViXFxcIikpO2NvbnN0IGk9cih0aGlzLFttLHUsbCxkLF8scCxhLHNdKSxvPXEocShnLGksXFxcIlN1YlxcXCIpLG5ldyB3dCgwLG4pLFxcXCJTdWJcXFwiKTtpZihvLiRkYXlzPDApe1ttLHUsbCxkLF8scF09Y29udmVydGVyKHEodCxxKG8seXQsXFxcIkZsb29yRGl2XFxcIiksXFxcIkFkZFxcXCIpKTtjb25zdCBuPXIodGhpcyxbbSx1LGwsZCxfLHAsYSxzXSk7ZShuLGcsXFxcIkVxXFxcIikmJihnLiRmb2xkPTEpfX1lbHNlIGc9cihzLnRwJGdldGF0dHIobmV3IHcoXFxcImZyb211dGNcXFwiKSksW2ddKTtyZXR1cm4gZ30sJGxvY2FsVGltZXpvbmUoKXtsZXQgdDt0PXRoaXMuJHR6aW5mbz09PXk/dGhpcy4kbWtUaW1lKCk6dGhpcy5uYiRzdWJ0cmFjdChrdCkubmIkZmxvb3JfZGl2aWRlKHl0KTtjb25zdCBlPSQubG9jYWx0aW1lLnRwJGNhbGwoW3RdKSxuPShOdC50cCRjYWxsKGUudi5zbGljZSgwLDYpKSxlLnRwJGdldGF0dHIobmV3IHcoXFxcInRtX2dtdG9mZlxcXCIpKSksaT1lLnRwJGdldGF0dHIobmV3IHcoXFxcInRtX3pvbmVcXFwiKSk7cmV0dXJuIG5ldyBTdCh3dC50cCRjYWxsKFtXLG5dKSxpKX0sJGdldFN0YXRlKHQ9Myl7bGV0W2Usbl09JGRpdk1vZCh0aGlzLiR5ZWFyLDI1NiksW2ksc109JGRpdk1vZCh0aGlzLiRtaWNybywyNTYpLFtvLHJdPSRkaXZNb2QoaSwyNTYpLGE9dGhpcy4kbW9udGg7dGhpcy4kZm9sZCYmdD4zJiYoYSs9MTI4KTtjb25zdCAkPW5ldyBfKFtlLG4sYSx0aGlzLiRkYXksdGhpcy4kaG91cix0aGlzLiRtaW4sdGhpcy4kc2VjLG8scixzXSk7cmV0dXJuIHRoaXMuJHR6aW5mbz09PXk/WyRdOlskLHRoaXMuJHR6aW5mb119LCRzZXRTdGF0ZSh0LGUpe2NvbnN0W24saSxzLG8scixhLCQsYyxoLG1dPXQ7cz4xMjc/KHRoaXMuJGZvbGQ9MSx0aGlzLiRtb250aD1zLTEyOCk6KHRoaXMuJGZvbGQ9MCx0aGlzLiRtb250aD1zKSx0aGlzLiR5ZWFyPTI1NipuK2ksdGhpcy4kZGF5PW8sdGhpcy4kaG91cj1yLHRoaXMuJG1pbj1hLHRoaXMuJHNlYz0kLHRoaXMuJG1pY3JvPShjPDw4fGgpPDw4fG0sdGhpcy4kdHppbmZvPWV9fX0pO2Z1bmN0aW9uIF9pc293ZWVrMW1vbmRheSh0KXtjb25zdCBlPV95bWQyb3JkKHQsMSwxKSxuPShlKzYpJTc7bGV0IGk9ZS1uO3JldHVybiBuPjMmJihpKz03KSxpfU50LnByb3RvdHlwZS5taW49bmV3IE50KDEsMSwxKSxOdC5wcm90b3R5cGUubWF4PW5ldyBOdCg5OTk5LDEyLDMxLDIzLDU5LDU5LDk5OTk5OSksTnQucHJvdG90eXBlLnJlc29sdXRpb249bmV3IHd0KDAsMCwxKTtjb25zdCBTdD1FLnRpbWV6b25lPWgoXFxcImRhdGV0aW1lLnRpbWV6b25lXFxcIix7YmFzZTpNdCxjb25zdHJ1Y3RvcjpmdW5jdGlvbiB0aW1lem9uZSh0LG4pe2lmKHRoaXMuJG9mZnNldD10LHRoaXMuJG5hbWU9bnx8eSwhZSh0aGlzLiRtaW5vZmZzZXQsdCxcXFwiTHRFXFxcIil8fCFlKHRoaXMuJG1heG9mZnNldCx0LFxcXCJHdEVcXFwiKSl0aHJvdyBuZXcgdihcXFwib2Zmc2V0IG11c3QgYmUgYSB0aW1lZGVsdGEgc3RyaWN0bHkgYmV0d2VlbiAtdGltZWRlbHRhKGhvdXJzPTI0KSBhbmQgdGltZWRlbHRhKGhvdXJzPTI0KS5cXFwiKX0sc2xvdHM6e3RwJG5ldyhlLG4pe2xldFtpLHNdPWwoXFxcInRpbWV6b25lXFxcIixbXFxcIm9mZnNldFxcXCIsXFxcIm5hbWVcXFwiXSxlLG4sW251bGxdKTtpZighKGkgaW5zdGFuY2VvZiB3dCkpdGhyb3cgbmV3IHooXFxcIm9mZnNldCBtdXN0IGJlIGEgdGltZWRlbHRhXFxcIik7aWYobnVsbD09PXMpe2lmKCF0KGkpKXJldHVybiB0aGlzLnV0YztzPXl9ZWxzZSBpZighayhzKSl0aHJvdyBuZXcgeihcXFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYodGhpcz09PVN0LnByb3RvdHlwZSlyZXR1cm4gbmV3IFN0KGkscyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIFN0LmNhbGwodCxpLHMpLHR9fSx0cCRyaWNoY29tcGFyZSh0LG4pe2lmKCEodCBpbnN0YW5jZW9mIFN0KSlyZXR1cm4gYjtjb25zdCBpPWUodGhpcy4kb2Zmc2V0LHQuJG9mZnNldCxcXFwiRXFcXFwiKTtyZXR1cm5cXFwiTm90RXFcXFwiPT09bj8haTpcXFwiRXFcXFwiPT09bnx8aSYmbyhuKT9pOmJ9LCRyKCl7cmV0dXJuIHRoaXM9PT10aGlzLnV0Yz9uZXcgdyhcXFwiZGF0ZXRpbWUudGltZXpvbmUudXRjXFxcIik6dGhpcy4kbmFtZT09PXk/bmV3IHcoYCR7dGhpcy50cCRuYW1lfSgke3ModGhpcy4kb2Zmc2V0KX0pYCk6bmV3IHcoYCR7dGhpcy50cCRuYW1lfSgke3ModGhpcy4kb2Zmc2V0KX0sICR7cyh0aGlzLiRuYW1lKX0pYCl9LHRwJHN0cigpe3JldHVybiB0aGlzLnRwJGdldGF0dHIoWSkudHAkY2FsbChbeV0pfSx0cCRoYXNoKCl7cmV0dXJuIHUodGhpcy4kb2Zmc2V0KX19LG1ldGhvZHM6e3R6bmFtZTp7JG1ldGg6ZnVuY3Rpb24gdHpuYW1lKHQpe2lmKHQgaW5zdGFuY2VvZiBOdHx8dD09PXkpcmV0dXJuIHRoaXMuJG5hbWU9PT15P3RoaXMuJG5hbWVGcm9tT2ZmKHRoaXMuJG9mZnNldCk6dGhpcy4kbmFtZTt0aHJvdyBuZXcgeihcXFwidHpuYW1lKCkgYXJndW1lbnQgbXVzdCBiZSBhIGRhdGV0aW1lIGluc3RhbmNlIG9yIE5vbmVcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiSWYgbmFtZSBpcyBzcGVjaWZpZWQgd2hlbiB0aW1lem9uZSBpcyBjcmVhdGVkLCByZXR1cm5zIHRoZSBuYW1lLiAgT3RoZXJ3aXNlIHJldHVybnMgb2Zmc2V0IGFzICdVVEMoK3wtKUhIOk1NJy5cXFwifSx1dGNvZmZzZXQ6eyRtZXRoOmZ1bmN0aW9uIHV0Y29mZnNldCh0KXtpZih0IGluc3RhbmNlb2YgTnR8fHQ9PT15KXJldHVybiB0aGlzLiRvZmZzZXQ7dGhyb3cgbmV3IHooXFxcInV0Y29mZnNldCgpIGFyZ3VtZW50IG11c3QgYmUgYSBkYXRldGltZSBpbnN0YW5jZSBvciBOb25lXFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBmaXhlZCBvZmZzZXQuXFxcIn0sZHN0OnskbWV0aDpmdW5jdGlvbiBkc3QodCl7aWYodCBpbnN0YW5jZW9mIE50fHx0PT09eSlyZXR1cm4geTt0aHJvdyBuZXcgeihcXFwiZHN0KCkgYXJndW1lbnQgbXVzdCBiZSBhIGRhdGV0aW1lIGluc3RhbmNlIG9yIE5vbmVcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIE5vbmUuXFxcIn0sZnJvbXV0Yzp7JG1ldGg6ZnVuY3Rpb24gZnJvbXV0Yyh0KXtpZih0IGluc3RhbmNlb2YgTnQpe2lmKHQuJHR6aW5mbyE9PXRoaXMpdGhyb3cgbmV3IHYoXFxcImZyb211dGM6IGR0LnR6aW5mbyBpcyBub3Qgc2VsZlxcXCIpO3JldHVybiBxKHQsdGhpcy4kb2Zmc2V0LFxcXCJBZGRcXFwiKX10aHJvdyBuZXcgeihcXFwiZnJvbXV0YygpIGFyZ3VtZW50IG11c3QgYmUgYSBkYXRldGltZSBpbnN0YW5jZSBvciBOb25lXFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcImRhdGV0aW1lIGluIFVUQyAtPiBkYXRldGltZSBpbiBsb2NhbCB0aW1lLlxcXCJ9LF9fZ2V0aW5pdGFyZ3NfXzp7JG1ldGgoKXtyZXR1cm4gdGhpcy4kbmFtZT09PXk/bmV3IHAoW3RoaXMuJG9mZnNldF0pOm5ldyBwKFt0aGlzLiRvZmZzZXQsdGhpcy4kbmFtZV0pfSwkZmxhZ3M6e05vQXJnczohMH19fSxwcm90bzp7JG1heG9mZnNldDpuZXcgd3QoMCw4NjM5OSw5OTk5OTkpLCRtaW5vZmZzZXQ6bmV3IHd0KC0xLDAsMSksJG5hbWVGcm9tT2ZmKG4pe2lmKCF0KG4pKXJldHVybiBuZXcgdyhcXFwiVVRDXFxcIik7bGV0IGkscyxvLHIsYSwkO3JldHVybiBlKG4sYnQsXFxcIkx0XFxcIik/KGk9XFxcIi1cXFwiLG49bi5uYiRuZWdhdGl2ZSgpKTppPVxcXCIrXFxcIixbcyxvXT1weURpdk1vZChuLHB0KSxbcixvXT1weURpdk1vZChvLGd0KSxhPW8uJHNlY3MsJD1vLiRtaWNybyxuZXcgdygkP2BVVEMke2l9JHtfZChzKX06JHtfZChyKX06JHtfZChhKX0uJHtfZCgkLFxcXCIwXFxcIiw2KX1gOmE/YFVUQyR7aX0ke19kKHMpfToke19kKHIpfToke19kKGEpfWA6YFVUQyR7aX0ke19kKHMpfToke19kKHIpfWApfX19KTtTdC5wcm90b3R5cGUudXRjPW5ldyBTdChuZXcgd3QoMCkpLFN0LnByb3RvdHlwZS5taW49bmV3IFN0KG5ldyB3dCgwLC04NjM0MCwwKSksU3QucHJvdG90eXBlLm1heD1uZXcgU3QobmV3IHd0KDAsODYzNDAsMCkpO2NvbnN0IGt0PW5ldyBOdCgxOTcwLDEsMSwwLDAsMCwwLFN0LnByb3RvdHlwZS51dGMpO3JldHVybiBFfSkpfVwiLFwic3JjL2xpYi9kb2N1bWVudC5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUoKXtjb25zdHtidWlsdGluOntzdHI6aX0sbWlzY2V2YWw6e2NhbGxzaW1BcnJheTpufSxmZmk6e3RvUHk6dH0sYWJzdHI6e2dhdHRyOmV9fT1TayxyPXtfX25hbWVfXzpuZXcgaShcXFwiZG9jdW1lbnRcXFwiKX0sbz10KFNrLmdsb2JhbC5kb2N1bWVudCk7cmV0dXJuIFNrLmFic3RyLnNldFVwTW9kdWxlTWV0aG9kcyhcXFwiZG9jdW1lbnRcXFwiLHIse19fZ2V0YXR0cl9fOnskbWV0aDppPT5lKG8saSwhMCksJGZsYWdzOntPbmVBcmc6ITB9fSxfX2Rpcl9fOnskbWV0aDooKT0+bihvLnRwJGdldGF0dHIoaS4kZGlyKSksJGZsYWdzOntOb0FyZ3M6ITB9fX0pLHIuY3VycmVudERpdj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PVNrLmRpdmlkKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suZGl2aWQpO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFxcXCJUaGVyZSBpcyBubyB2YWx1ZSBzZXQgZm9yIGRpdmlkXFxcIil9KSksci5jdXJyZW50Q291cnNlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZUJvb2tDb25maWcpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihlQm9va0NvbmZpZy5jb3Vyc2UpO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFxcXCJUaGVyZSBpcyBubyBjb3Vyc2VcXFwiKX0pKSxyLmN1cnJlbnRHcmFkaW5nQ29udGFpbmVyPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09U2suZ3JhZGVDb250YWluZXIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTay5ncmFkZUNvbnRhaW5lcik7aWYobnVsbCE9U2suZGl2aWQpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTay5kaXZpZCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXFxcIlRoZXJlIGlzIG5vIHZhbHVlIHNldCBmb3IgZ3JhZGluZ1xcXCIpfSkpLHIuZ2V0Q3VycmVudEVkaXRvclZhbHVlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09U2suZGl2aWQmJnZvaWQgMCE9PXdpbmRvdy5jb21wb25lbnRNYXApe2lmKFNrLmdyYWRlQ29udGFpbmVyIT1Tay5kaXZpZCl7dmFyIGk9U2suZ3JhZGVDb250YWluZXIrXFxcIiBcXFwiK1NrLmRpdmlkO3JldHVybiBpIGluIHdpbmRvdy5jb21wb25lbnRNYXA/bmV3IFNrLmJ1aWx0aW4uc3RyKHdpbmRvdy5jb21wb25lbnRNYXBbaV0uZWRpdG9yLmdldFZhbHVlKCkpOm5ldyBTay5idWlsdGluLnN0cih3aW5kb3cuY29tcG9uZW50TWFwW1NrLmRpdmlkXS5lZGl0b3IuZ2V0VmFsdWUoKSl9cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih3aW5kb3cuY29tcG9uZW50TWFwW1NrLmRpdmlkXS5lZGl0b3IuZ2V0VmFsdWUoKSl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXFxcIkNhbid0IGZpbmQgZWRpdG9yIGZvciB0aGlzIGRpdlxcXCIpfSkpLHIucG9wdXA9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oaSl7Y29uc3Qgbj1Tay5mZmkucmVtYXBUb0pzKGkpO2FsZXJ0KG4pfSkpLHJ9XCIsXCJzcmMvbGliL2ZyYWN0aW9ucy5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUodCl7Y29uc3QgZT17fTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFxcXCJtYXRoXFxcIiwhMSwhMCksKHQ9PihlLm1hdGg9dCxTay5pbXBvcnRNb2R1bGUoXFxcInN5c1xcXCIsITEsITApKSksKHQ9PihlLnN5cz10LGZyYWN0aW9uc01vZChlKSkpKX1mdW5jdGlvbiBmcmFjdGlvbnNNb2Qoe21hdGg6dCxzeXM6ZX0pe2NvbnN0e2J1aWx0aW46e2ludF86bixib29sOnt0cnVlJDppLGZhbHNlJDpyfSxub25lOntub25lJDpzfSxOb3RJbXBsZW1lbnRlZDp7Tm90SW1wbGVtZW50ZWQkOm99LHR1cGxlOmEsZmxvYXRfOiQsY29tcGxleDp1LHN0cjpoLGlzaW5zdGFuY2U6bCxUeXBlRXJyb3I6bSxaZXJvRGl2aXNpb25FcnJvcjpkLFZhbHVlRXJyb3I6ZixOb3RJbXBsZW1lbnRlZEVycm9yOmMsYWJzOl8scm91bmQ6Yixwb3c6cH0sZmZpOntyZW1hcFRvUHk6Z30sYWJzdHI6e2J1aWxkTmF0aXZlQ2xhc3M6dyxjb3B5S2V5d29yZHNUb05hbWVkQXJnczp2LG51bWJlckJpbk9wOnksdHlwZU5hbWU6ayxsb29rdXBTcGVjaWFsOkUsY2hlY2tBcmdzTGVuOk59LG1pc2NldmFsOntpc1RydWU6RixyaWNoQ29tcGFyZUJvb2w6QSxjYWxsc2ltQXJyYXk6UyxvYmplY3RSZXByOk19fT1TayxPPXtfX25hbWVfXzpuZXcgaChcXFwiZnJhY3Rpb25zXFxcIiksX19hbGxfXzpnKFtcXFwiRnJhY3Rpb25cXFwiXSl9LEQ9L15cXFxccyooPzxzaWduPlstK10/KSg/PVxcXFxkfFxcXFwuXFxcXGQpKD88bnVtPlxcXFxkKikoPzooPzpcXFxcLyg/PGRlbm9tPlxcXFxkKykpP3woPzpcXFxcLig/PGRlY2ltYWw+XFxcXGQqKSk/KD86RSg/PGV4cD5bLStdP1xcXFxkKykpPylcXFxccyokL2kscT1uZXcgbigwKSx4PW5ldyBuKDEpLHo9bmV3IG4oMiksST1uZXcgbigxMCksVD1uZXcgaChcXFwibnVtZXJhdG9yXFxcIiksUj1uZXcgaChcXFwiZGVub21pbmF0b3JcXFwiKSxCPW5ldyBoKFxcXCJhc19pbnRlZ2VyX3JhdGlvXFxcIiksQz1uZXcgaChcXFwiZnJvbV9mbG9hdFxcXCIpLGdldE51bWVyPXQ9PnQudHAkZ2V0YXR0cihUKSxnZXREZW5vbT10PT50LnRwJGdldGF0dHIoUiksbXVsPSh0LGUpPT55KHQsZSxcXFwiTXVsdFxcXCIpLGRpdj0odCxlKT0+eSh0LGUsXFxcIkRpdlxcXCIpLHBvdz0odCxlKT0+eSh0LGUsXFxcIlBvd1xcXCIpLGFkZD0odCxlKT0+eSh0LGUsXFxcIkFkZFxcXCIpLHN1Yj0odCxlKT0+eSh0LGUsXFxcIlN1YlxcXCIpLGZsb29yRGl2PSh0LGUpPT55KHQsZSxcXFwiRmxvb3JEaXZcXFwiKSxkaXZtb2Q9KHQsZSk9PnkodCxlLFxcXCJEaXZNb2RcXFwiKSxtb2Q9KHQsZSk9PnkodCxlLFxcXCJNb2RcXFwiKSxLPXQudHAkZ2V0YXR0cihuZXcgaChcXFwiZ2NkXFxcIikpLGVxPSh0LGUpPT5BKHQsZSxcXFwiRXFcXFwiKSxsdD0odCxlKT0+QSh0LGUsXFxcIkx0XFxcIiksZ2U9KHQsZSk9PkEodCxlLFxcXCJHdEVcXFwiKSxMPXtOb0FyZ3M6ITB9LFA9e09uZUFyZzohMH0saj1lLnRwJGdldGF0dHIobmV3IGgoXFxcImhhc2hfaW5mb1xcXCIpKSxHPWoudHAkZ2V0YXR0cihuZXcgaChcXFwibW9kdWx1c1xcXCIpKSxWPWoudHAkZ2V0YXR0cihuZXcgaChcXFwiaW5mXFxcIikpO2Z1bmN0aW9uIF9vcGVyYXRvcl9mYWxsYmFja3ModCxlKXtyZXR1cm5bZnVuY3Rpb24obil7cmV0dXJuIGlzUmF0aW9uYWwobik/dCh0aGlzLG4pOm4gaW5zdGFuY2VvZiAkP2UodGhpcy5uYiRmbG9hdCgpLG4pOm4gaW5zdGFuY2VvZiB1P2UoUyh1LFt0aGlzXSksbik6b30sZnVuY3Rpb24obil7cmV0dXJuIGlzUmF0aW9uYWwobik/dChuLHRoaXMpOm4gaW5zdGFuY2VvZiAkP2Uobix0aGlzLm5iJGZsb2F0KCkpOm4gaW5zdGFuY2VvZiB1P2UobixTKHUsW3RoaXNdKSk6b31dfWNvbnN0W1osSF09X29wZXJhdG9yX2ZhbGxiYWNrcygoKHQsZSk9Pntjb25zdCBuPWdldERlbm9tKHQpLGk9Z2V0RGVub20oZSk7cmV0dXJuIFMob3QsW2FkZChtdWwoZ2V0TnVtZXIodCksaSksbXVsKGdldE51bWVyKGUpLG4pKSxtdWwobixpKV0pfSksYWRkKSxbSixRXT1fb3BlcmF0b3JfZmFsbGJhY2tzKCgodCxlKT0+e2NvbnN0IG49Z2V0RGVub20odCksaT1nZXREZW5vbShlKTtyZXR1cm4gUyhvdCxbc3ViKG11bChnZXROdW1lcih0KSxpKSxtdWwoZ2V0TnVtZXIoZSksbikpLG11bChuLGkpXSl9KSxzdWIpLFtVLFddPV9vcGVyYXRvcl9mYWxsYmFja3MoKCh0LGUpPT5TKG90LFttdWwoZ2V0TnVtZXIodCksZ2V0TnVtZXIoZSkpLG11bChnZXREZW5vbSh0KSxnZXREZW5vbShlKSldKSksbXVsKSxbWCxZXT1fb3BlcmF0b3JfZmFsbGJhY2tzKCgodCxlKT0+UyhvdCxbbXVsKGdldE51bWVyKHQpLGdldERlbm9tKGUpKSxtdWwoZ2V0RGVub20odCksZ2V0TnVtZXIoZSkpXSkpLGRpdiksW3R0LGV0XT1fb3BlcmF0b3JfZmFsbGJhY2tzKCgodCxlKT0+Zmxvb3JEaXYobXVsKGdldE51bWVyKHQpLGdldERlbm9tKGUpKSxtdWwoZ2V0RGVub20odCksZ2V0TnVtZXIoZSkpKSksZmxvb3JEaXYpLFtudCxpdF09X29wZXJhdG9yX2ZhbGxiYWNrcygoKHQsZSk9Pntjb25zdCBuPWdldERlbm9tKHQpLGk9Z2V0RGVub20oZSksW3Isc109ZGl2bW9kKG11bChnZXROdW1lcih0KSxpKSxtdWwobixnZXROdW1lcihlKSkpLnZhbHVlT2YoKTtyZXR1cm4gbmV3IGEoW3IsUyhvdCxbcyxtdWwobixpKV0pXSl9KSxkaXZtb2QpLFtydCxzdF09X29wZXJhdG9yX2ZhbGxiYWNrcygoKHQsZSk9Pntjb25zdCBuPWdldERlbm9tKHQpLGk9Z2V0RGVub20oZSkscj1tb2QobXVsKGdldE51bWVyKHQpLGkpLG11bChnZXROdW1lcihlKSxuKSk7cmV0dXJuIFMob3QsW3IsbXVsKG4saSldKX0pLG1vZCksb3Q9Ty5GcmFjdGlvbj13KFxcXCJmcmFjdGlvbnMuRnJhY3Rpb25cXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbih0LGUpe3RoaXMuJG51bT10fHxxLHRoaXMuJGRlbj1lfHx4fSxzbG90czp7dHAkbmV3KHQsZSl7TihcXFwiRnJhY3Rpb25cXFwiLHQsMCwyKTtsZXRbcixvLGFdPXYoXFxcIkZyYWN0aW9uXFxcIixbXFxcIm51bWVyYXRvclxcXCIsXFxcImRlbm9taW5hdG9yXFxcIixcXFwiX25vcm1hbGl6ZVxcXCJdLHQsZSxbcSxzLGldKTtjb25zdCB1PW5ldyB0aGlzLmNvbnN0cnVjdG9yO2lmKG89PT1zKXtpZihyLm9iJHR5cGU9PT1uKXJldHVybiB1LiRudW09cix1LiRkZW49eCx1O2lmKGlzUmF0aW9uYWwocikpcmV0dXJuIHUuJG51bT1nZXROdW1lcihyKSx1LiRkZW49Z2V0RGVub20ociksdTtpZihyIGluc3RhbmNlb2YgJClyZXR1cm5bdS4kbnVtLHUuJGRlbl09UyhyLnRwJGdldGF0dHIoQikpLnZhbHVlT2YoKSx1O2lmKCEociBpbnN0YW5jZW9mIGgpKXRocm93IG5ldyBtKFxcXCJhcmd1bWVudCBzaG91bGQgYmUgYSBzdHJpbmcgb3IgYSBSYXRpb25hbCBpbnN0YW5jZVxcXCIpO3tjb25zdCB0PXIudG9TdHJpbmcoKS5tYXRjaChEKTtpZihudWxsPT09dCl0aHJvdyBuZXcgZihcXFwiSW52YWxpZCBsaXRlcmFsIGZvciBGcmFjdGlvbjogXFxcIitNKHIpKTtyPW5ldyBuKHQuZ3JvdXBzLm51bXx8XFxcIjBcXFwiKTtjb25zdCBlPXQuZ3JvdXBzLmRlbm9tO2lmKGUpbz1uZXcgbihlKTtlbHNle289eDtjb25zdCBlPXQuZ3JvdXBzLmRlY2ltYWw7aWYoZSl7Y29uc3QgdD1uZXcgbihcXFwiXFxcIisxMCoqZS5sZW5ndGgpO3I9YWRkKG11bChyLHQpLG5ldyBuKGUpKSxvPW11bChvLHQpfWxldCBpPXQuZ3JvdXBzLmV4cDtpJiYoaT1uZXcgbihpKSxsdChpLHEpP289bXVsKG8scG93KEksaS5uYiRuZWdhdGl2ZSgpKSk6cj1tdWwocixwb3coSSxpKSkpfVxcXCItXFxcIj09dC5ncm91cHMuc2lnbiYmKHI9ci5uYiRuZWdhdGl2ZSgpKX19ZWxzZSBpZihyLm9iJHR5cGU9PT1uJiZvLm9iJHR5cGU9PT1uKTtlbHNle2lmKCFpc1JhdGlvbmFsKHIpfHwhaXNSYXRpb25hbChvKSl0aHJvdyBuZXcgbShcXFwiYm90aCBhcmd1bWVudHMgc2hvdWxkIGJlIFJhdGlvbmFsIGluc3RhbmNlc1xcXCIpO1tyLG9dPVttdWwoZ2V0TnVtZXIociksZ2V0RGVub20obykpLG11bChnZXROdW1lcihvKSxnZXREZW5vbShyKSldfWlmKGVxKG8scSkpdGhyb3cgbmV3IGQoYEZyYWN0aW9uKCR7cn0sIDApYCk7aWYoRihhKSl7bGV0IHQ9UyhLLFtyLG9dKTtsdChvLHEpJiYodD10Lm5iJG5lZ2F0aXZlKCkpLHI9Zmxvb3JEaXYocix0KSxvPWZsb29yRGl2KG8sdCl9cmV0dXJuIHUuJG51bT1yLHUuJGRlbj1vLHV9LCRyKCl7Y29uc3QgdD1FKHRoaXMub2IkdHlwZSxoLiRuYW1lKTtyZXR1cm4gbmV3IGgoYCR7dH0oJHt0aGlzLiRudW19LCAke3RoaXMuJGRlbn0pYCl9LHRwJHN0cigpe3JldHVybiBlcSh0aGlzLiRkZW4seCk/bmV3IGgodGhpcy4kbnVtKTpuZXcgaChgJHt0aGlzLiRudW19LyR7dGhpcy4kZGVufWApfSx0cCRoYXNoKCl7Y29uc3QgdD1wKHRoaXMuJGRlbixzdWIoRyx6KSxHKTtsZXQgZTtlPUYodCk/bW9kKG11bChfKHRoaXMuJG51bSksdCksRyk6VjtsZXQgbj1nZSh0aGlzLHEpP2U6ZS5uYiRuZWdhdGl2ZSgpO3JldHVybiBuPW4udHAkaGFzaCgpLC0xPT09bj8tMjpufSx0cCRyaWNoY29tcGFyZSh0LGUpe2NvbnN0IG9wPSh0LG4pPT5BKHQsbixlKTtpZihcXFwiRXFcXFwiPT09ZXx8XFxcIk5vdEVxXFxcIj09ZSl7aWYodC5vYiR0eXBlPT09bil7Y29uc3Qgbj1lcSh0aGlzLiRudW0sdCkmJmVxKHRoaXMuJGRlbix4KTtyZXR1cm5cXFwiRXFcXFwiPT09ZT9uOiFufWlmKHQgaW5zdGFuY2VvZiBvdHx8dCBpbnN0YW5jZW9mIG4pe2NvbnN0IG49ZXEodGhpcy4kbnVtLGdldE51bWVyKHQpKSYmZXEodGhpcy4kZGVuLGdldERlbm9tKHQpKTtyZXR1cm5cXFwiRXFcXFwiPT09ZT9uOiFufXQgaW5zdGFuY2VvZiB1JiZlcSh0LnRwJGdldGF0dHIobmV3IGgoXFxcImltYWdcXFwiKSkscSkmJih0PXQudHAkZ2V0YXR0cihuZXcgaChcXFwicmVhbFxcXCIpKSl9cmV0dXJuIGlzUmF0aW9uYWwodCk/b3AobXVsKGdldE51bWVyKHRoaXMpLGdldERlbm9tKHQpKSxtdWwoZ2V0RGVub20odGhpcyksZ2V0TnVtZXIodCkpKTp0IGluc3RhbmNlb2YgJD9OdW1iZXIuaXNGaW5pdGUodC52YWx1ZU9mKCkpP29wKHRoaXMsUyh0aGlzLnRwJGdldGF0dHIoQyksW3RdKSk6b3AobmV3ICQoMCksdCk6b30sdHAkYXNfbnVtYmVyOiEwLG5iJGFkZDpaLG5iJHJlZmxlY3RlZF9hZGQ6SCxuYiRzdWJ0cmFjdDpKLG5iJHJlZmxlY3RlZF9zdWJ0cmFjdDpRLG5iJG11bHRpcGx5OlUsbmIkcmVmbGVjdGVkX211bHRpcGx5OlcsbmIkZGl2aWRlOlgsbmIkcmVmbGVjdGVkX2RpdmlkZTpZLG5iJGZsb29yX2RpdmlkZTp0dCxuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlOmV0LG5iJGRpdm1vZDpudCxuYiRyZWZsZWN0ZWRfZGl2bW9kOml0LG5iJHJlbWFpbmRlcjpydCxuYiRyZWZsZWN0ZWRfcmVtYWluZGVyOnN0LG5iJHBvd2VyKHQpe2lmKGlzUmF0aW9uYWwodCkpe2lmKGVxKGdldERlbm9tKHQpLHgpKXtsZXQgZT1nZXROdW1lcih0KTtyZXR1cm4gZ2UoZSxxKT9TKG90LFtwb3codGhpcy4kbnVtLGUpLHBvdyh0aGlzLiRkZW4sZSldLFtcXFwiX25vcm1hbGl6ZVxcXCIscl0pOmdlKHRoaXMuJG51bSxxKT8oZT1lLm5iJG5lZ2F0aXZlKCksUyhvdCxbcG93KHRoaXMuJGRlbixlKSxwb3codGhpcy4kbnVtLGUpXSxbXFxcIl9ub3JtYWxpemVcXFwiLHJdKSk6KGU9ZS5uYiRuZWdhdGl2ZSgpLFMob3QsW3Bvdyh0aGlzLiRkZW4ubmIkbmVnYXRpdmUoKSxlKSxwb3codGhpcy4kbnVtLm5iJG5lZ2F0aXZlKCksZSldLFtcXFwiX25vcm1hbGl6ZVxcXCIscl0pKX1yZXR1cm4gcG93KHRoaXMubmIkZmxvYXQoKSxTKCQsW3RdKSl9cmV0dXJuIHBvdyh0aGlzLm5iJGZsb2F0KCksdCl9LG5iJHJlZmxlY3RlZF9wb3dlcih0KXtyZXR1cm4gZXEodGhpcy4kZGVuLHgpJiZnZSh0aGlzLiRudW0scSk/cG93KHQsdGhpcy4kbnVtKTppc1JhdGlvbmFsKHQpP3BvdyhuZXcgb3QoZ2V0TnVtZXIodCksZ2V0RGVub20odCkpLHRoaXMpOmVxKHRoaXMuJGRlbix4KT9wb3codCx0aGlzLiRudW0pOnBvdyh0LHRoaXMubmIkZmxvYXQoKSl9LG5iJHBvc2l0aXZlKCl7cmV0dXJuIG5ldyBvdCh0aGlzLiRudW0sdGhpcy4kZGVuKX0sbmIkbmVnYXRpdmUoKXtyZXR1cm4gbmV3IG90KHRoaXMuJG51bS5uYiRuZWdhdGl2ZSgpLHRoaXMuJGRlbil9LG5iJGFicygpe3JldHVybiBuZXcgb3QodGhpcy4kbnVtLm5iJGFicygpLHRoaXMuJGRlbil9LG5iJGJvb2woKXtyZXR1cm4gdGhpcy4kbnVtLm5iJGJvb2woKX0sbmIkZmxvYXQoKXtyZXR1cm4gZGl2KHRoaXMuJG51bSx0aGlzLiRkZW4pfX0sbWV0aG9kczp7YXNfaW50ZWdlcl9yYXRpbzp7JG1ldGgoKXtyZXR1cm4gbmV3IGEoW3RoaXMuJG51bSx0aGlzLiRkZW5dKX0sJGZsYWdzOkx9LGxpbWl0X2Rlbm9taW5hdG9yOnskbWV0aCh0KXtpZihsdCh0LHgpKXRocm93IG5ldyBmKFxcXCJtYXhfZGVub21pbmF0b3Igc2hvdWxkIGJlIGF0IGxlYXN0IDFcXFwiKTtpZihnZSh0LHRoaXMuJGRlbikpcmV0dXJuIFMob3QsW3RoaXNdKTtsZXRbZSxuLGkscl09W3EseCx4LHFdLHM9dGhpcy4kbnVtLG89dGhpcy4kZGVuO2Zvcig7Oyl7Y29uc3QgYT1mbG9vckRpdihzLG8pLCQ9YWRkKG4sbXVsKGEscikpO2lmKGx0KHQsJCkpYnJlYWs7W2UsbixpLHJdPVtpLHIsYWRkKGUsbXVsKGEsaSkpLCRdLFtzLG9dPVtvLHN1YihzLG11bChhLG8pKV19Y29uc3QgYT1mbG9vckRpdihzdWIodCxuKSxyKSwkPVMob3QsW2FkZChlLG11bChhLGkpKSxhZGQobixtdWwoYSxyKSldKSx1PVMob3QsW2kscl0pO3JldHVybiBnZShfKHN1YigkLHRoaXMpKSxfKHN1Yih1LHRoaXMpKSk/dTokfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcIm1heF9kZW5vbWluYXRvclxcXCJdLERlZmF1bHRzOltuZXcgbigxZTYpXX19LF9fdHJ1bmNfXzp7JG1ldGgoKXtyZXR1cm4gbHQodGhpcy4kbnVtLHEpP2Zsb29yRGl2KHRoaXMuJG51bS5uYiRuZWdhdGl2ZSgpLHRoaXMuJGRlbikubmIkbmVnYXRpdmUoKTpmbG9vckRpdih0aGlzLiRudW0sdGhpcy4kZGVuKX0sJGZsYWdzOkx9LF9fZmxvb3JfXzp7JG1ldGgoKXtyZXR1cm4gZmxvb3JEaXYodGhpcy4kbnVtLHRoaXMuJGRlbil9LCRmbGFnczpMfSxfX2NlaWxfXzp7JG1ldGgoKXtyZXR1cm4gZmxvb3JEaXYodGhpcy4kbnVtLm5iJG5lZ2F0aXZlKCksdGhpcy4kZGVuKS5uYiRuZWdhdGl2ZSgpfSwkZmxhZ3M6TH0sX19yb3VuZF9fOnskbWV0aCh0KXtpZih0PT09cyl7Y29uc3RbdCxlXT1kaXZtb2QodGhpcy4kbnVtLHRoaXMuJGRlbikudmFsdWVPZigpLG49bXVsKGUseik7cmV0dXJuIGx0KG4sdGhpcy4kZGVuKT90Omx0KHRoaXMuJGRlbixuKT9hZGQodCx4KTplcShtb2QodCx6KSxxKT90OmFkZCh0LHgpfWNvbnN0IGU9cG93KEksXyh0KSk7cmV0dXJuIGx0KHEsdCk/UyhvdCxbYihtdWwodGhpcyxlKSksZV0pOlMob3QsW211bChiKGRpdih0aGlzLGUpKSxlKV0pfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcIm5kaWdpdHNcXFwiXSxEZWZhdWx0czpbc119fSxfX3JlZHVjZV9fOnskbWV0aCgpe3JldHVybiBuZXcgYShbdGhpcy5vYiR0eXBlLG5ldyBhKFtuZXcgaCh0aGlzKV0pXSl9LCRmbGFnczpMfSxfX2NvcHlfXzp7JG1ldGgoKXtyZXR1cm4gdGhpcy5vYiR0eXBlPT09b3Q/dGhpczpTKHRoaXMub2IkdHlwZSxbdGhpcy4kbnVtLHRoaXMuJGRlbl0pfSwkZmxhZ3M6TH0sX19kZWVwY29weV9fOnskbWV0aCh0KXtyZXR1cm4gdGhpcy5vYiR0eXBlPT09b3Q/dGhpczpTKHRoaXMub2IkdHlwZSxbdGhpcy4kbnVtLHRoaXMuJGRlbl0pfSwkZmxhZ3M6UH19LGNsYXNzbWV0aG9kczp7ZnJvbV9mbG9hdDp7JG1ldGgodCl7aWYodCBpbnN0YW5jZW9mIG4pcmV0dXJuIFModGhpcyxbdF0pO2lmKHQgaW5zdGFuY2VvZiAkKXtjb25zdFtlLG5dPVModC50cCRnZXRhdHRyKEIpKS52YWx1ZU9mKCk7cmV0dXJuIFModGhpcyxbZSxuXSl9dGhyb3cgbmV3IG0oYCR7ayh0aGlzKX0uZnJvbV9mbG9hdCgpIG9ubHkgdGFrZXMgZmxvYXRzLCBub3QgJHtNKHQpfSwgKCR7ayh0KX0pYCl9LCRmbGFnczpQfSxmcm9tX2RlY2ltYWw6eyRtZXRoKCl7dGhyb3cgYyhcXFwiZnJvbV9kZWNpbWFsIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU0t1bHB0XFxcIil9LCRmbGFnczpQfX0sZ2V0c2V0czp7bnVtZXJhdG9yOnskZ2V0KCl7cmV0dXJuIHRoaXMuJG51bX19LGRlbm9taW5hdG9yOnskZ2V0KCl7cmV0dXJuIHRoaXMuJGRlbn19LF9udW1lcmF0b3I6eyRnZXQoKXtyZXR1cm4gdGhpcy4kbnVtfSwkc2V0KHQpe3RoaXMuJG51bT10fX0sX2Rlbm9taW5hdG9yOnskZ2V0KCl7cmV0dXJuIHRoaXMuJGRlbn0sJHNldCh0KXt0aGlzLiRkZW49dH19fX0pLGF0PW5ldyBhKFtuLG90XSksaXNSYXRpb25hbD10PT5GKGwodCxhdCkpO3JldHVybiBPfVwiLFwic3JjL2xpYi9mdW5jdG9vbHMuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKCl7Y29uc3QgdD17fTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFxcXCJjb2xsZWN0aW9uc1xcXCIsITEsITApLChlPT4odC5fbmFtZWR0dXBsZT1lLiRkLm5hbWVkdHVwbGUsZnVuY3Rvb2xzX21vZCh0KSkpKX1mdW5jdGlvbiBmdW5jdG9vbHNfbW9kKHQpe2NvbnN0e29iamVjdDplLGludF86bixzdHI6cixsaXN0OnMsdHVwbGU6YSxkaWN0Omksbm9uZTp7bm9uZSQ6b30sYm9vbDp7ZmFsc2UkOmN9LE5vdEltcGxlbWVudGVkOntOb3RJbXBsZW1lbnRlZCQ6X30sYm9vbDpsLGZ1bmM6cCxtZXRob2Q6dSxUeXBlRXJyb3I6aCxSdW50aW1lRXJyb3I6ZCxWYWx1ZUVycm9yOmYsTm90SW1wbGVtZW50ZWRFcnJvcjptLEF0dHJpYnV0ZUVycnJvcjp3LE92ZXJmbG93RXJyb3I6ZyxjaGVja05vbmU6JCxjaGVja0Jvb2w6eSxjaGVja0NhbGxhYmxlOmssY2hlY2tDbGFzczpifT1Tay5idWlsdGluLHtjYWxsc2ltQXJyYXk6eCxjYWxsc2ltT3JTdXNwZW5kQXJyYXk6QSxpdGVyRm9yOlMsY2hhaW46RSxpc0luZGV4OnYsYXNJbmRleFNpemVkOk4saXNUcnVlOlAscmljaENvbXBhcmVCb29sOmosb2JqZWN0UmVwcjpSfT1Tay5taXNjZXZhbCx7cmVtYXBUb1B5Onp9PVNrLmZmaSx7YnVpbGROYXRpdmVDbGFzczpxLHNldFVwTW9kdWxlTWV0aG9kczpULGtleXdvcmRBcnJheUZyb21QeURpY3Q6SSxrZXl3b3JkQXJyYXlUb1B5RGljdDpELG9iamVjdEhhc2g6Qyxsb29rdXBTcGVjaWFsOk0sY29weUtleXdvcmRzVG9OYW1lZEFyZ3M6Vyx0eXBlTmFtZTpGLGl0ZXI6VSxnYXR0cjpPfT1Tay5hYnN0cix7Z2V0U2V0RGljdDpHLGdldEF0dHI6QixzZXRBdHRyOkt9PVNrLmdlbmVyaWM7ZnVuY3Rpb24gcHJveHlGYWlsKHQpe3JldHVybiBuZXcgcCgoKCk9Pnt0aHJvdyBuZXcgbSh0K1xcXCIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBza3VscHRcXFwiKX0pKX1PYmplY3QuYXNzaWduKHQse19fbmFtZV9fOm5ldyByKFxcXCJmdW5jdG9vbHNcXFwiKSxfX2RvY19fOm5ldyByKFxcXCJUb29scyBmb3Igd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBhbmQgY2FsbGFibGUgb2JqZWN0c1xcXCIpLF9fYWxsX186bmV3IHMoW1xcXCJ1cGRhdGVfd3JhcHBlclxcXCIsXFxcIndyYXBzXFxcIixcXFwiV1JBUFBFUl9BU1NJR05NRU5UU1xcXCIsXFxcIldSQVBQRVJfVVBEQVRFU1xcXCIsXFxcInRvdGFsX29yZGVyaW5nXFxcIixcXFwiY21wX3RvX2tleVxcXCIsXFxcImNhY2hlXFxcIixcXFwibHJ1X2NhY2hlXFxcIixcXFwicmVkdWNlXFxcIixcXFwicGFydGlhbFxcXCIsXFxcInBhcnRpYWxtZXRob2RcXFwiLFxcXCJzaW5nbGVkaXNwYXRjaFxcXCIsXFxcInNpbmdsZWRpc3BhdGNobWV0aG9kXFxcIixcXFwiY2FjaGVkX3Byb3BlcnR5XFxcIl0ubWFwKCh0PT5uZXcgcih0KSkpKSxXUkFQUEVSX0FTU0lHTk1FTlRTOm5ldyBhKFtcXFwiX19tb2R1bGVfX1xcXCIsXFxcIl9fbmFtZV9fXFxcIixcXFwiX19xdWFsbmFtZV9fXFxcIixcXFwiX19kb2NfX1xcXCIsXFxcIl9fYW5ub3RhdGlvbnNfX1xcXCJdLm1hcCgodD0+bmV3IHIodCkpKSksV1JBUFBFUl9VUERBVEVTOm5ldyBhKFtuZXcgcihcXFwiX19kaWN0X19cXFwiKV0pLHNpbmdsZWRpc3BhdGNoOnByb3h5RmFpbChcXFwic2luZ2xlZGlzcGF0Y2hcXFwiKSxzaW5nbGVkaXNwYXRjaG1ldGhvZDpwcm94eUZhaWwoXFxcInNpbmdsZWRpc3BhdGNobWV0aG9kXFxcIiksY2FjaGVkX3Byb3BlcnR5OnByb3h5RmFpbChcXFwiY2FjaGVkX3Byb3BlcnR5XFxcIil9KTtjb25zdCBMPW5ldyByKFxcXCJjYWNoZV9wYXJhbWV0ZXJzXFxcIik7ZnVuY3Rpb24gX2xydV9jYWNoZShlLG4pe2lmKG58fChuPWMpLHYoZSkpKGU9TihlLGcpKTwwJiYoZT0wKTtlbHNle2lmKGsoZSkmJnkobikpe2NvbnN0IHI9ZSxzPW5ldyBWKHIsZT0xMjgsbik7cmV0dXJuIHMudHAkc2V0YXR0cihMLG5ldyBwKCgoKT0+eih7bWF4c2l6ZTplLHR5cGVkOm59KSkpKSxBKHQudXBkYXRlX3dyYXBwZXIsW3Mscl0pfWlmKCEkKGUpKXRocm93IG5ldyBoKFxcXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBpbnRlZ2VyLCBhIGNhbGxhYmxlLCBvciBOb25lXFxcIil9cmV0dXJuIG5ldyBwKChyPT57Y29uc3Qgcz1uZXcgVihyLGUsbik7cmV0dXJuIHMudHAkc2V0YXR0cihMLG5ldyBwKCgoKT0+eih7bWF4c2l6ZTplLHR5cGVkOm59KSkpKSxBKHQudXBkYXRlX3dyYXBwZXIsW3Mscl0pfSkpfWNvbnN0IEg9dC5fQ2FjaGVJbmZvPXgodC5fbmFtZWR0dXBsZSxbXFxcIkNhY2hlSW5mb1xcXCIsW1xcXCJoaXRzXFxcIixcXFwibWlzc2VzXFxcIixcXFwibWF4c2l6ZVxcXCIsXFxcImN1cnJzaXplXFxcIl1dLm1hcCgodD0+eih0KSkpLFtcXFwibW9kdWxlXFxcIixuZXcgcihcXFwiZnVuY3Rvb2xzXFxcIildKSxWPXEoXFxcImZ1bmN0b29scy5fbHJ1X2NhY2hlX3dyYXBwZXJcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBfbHJ1X2NhY2hlX3dyYXBwZXIodCxlLG4scil7aWYoIWsodCkpdGhyb3cgbmV3IGgoXFxcInRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGNhbGxhYmxlXFxcIik7bGV0IHM7aWYoJChlKSlzPWluZmluaXRlX2xydV9jYWNoZV93cmFwcGVyLGU9LTE7ZWxzZXtpZighdihlKSl0aHJvdyBuZXcgaChcXFwibWF4c2l6ZSBzaG91bGQgYmUgaW50ZWdlciBvciBOb25lXFxcIik7KGU9TihlLGcpKTwwJiYoZT0wKSxzPTA9PT1lP3VuY2FjaGVkX2xydV9jYWNoZV93cmFwcGVyOmJvdW5kZWRfbHJ1X2NhY2hlX3dyYXBwZXJ9dGhpcy5yb290PXt9LHRoaXMucm9vdC5wcmV2PXRoaXMucm9vdC5uZXh0PXRoaXMucm9vdCx0aGlzLndyYXBwZXI9cyx0aGlzLm1heHNpemU9ZSx0aGlzLnR5cGVkPW4sdGhpcy5jYWNoZT1uZXcgaShbXSksdGhpcy5mdW5jPXQsdGhpcy5taXNzZXM9dGhpcy5oaXRzPTAsdGhpcy4kZD1uZXcgaShbXSl9LHNsb3RzOnt0cCRuZXcodCxlKXtjb25zdFtuLHIscyxhXT1XKFxcXCJfbHJ1X2NhY2hlX3dyYXBwZXJcXFwiLFtcXFwidXNlcl9mdW5jdGlvblxcXCIsXFxcIm1heHNpemVcXFwiLFxcXCJ0eXBlZFxcXCIsXFxcImNhY2hlX2luZm9fdHlwZVxcXCJdLHQsZSk7cmV0dXJuIG5ldyBWKG4scixzLGEpfSx0cCRjYWxsKHQsZSl7cmV0dXJuIHRoaXMud3JhcHBlcih0LGUpfSx0cCRkZXNjcl9nZXQodCxlKXtyZXR1cm4gbnVsbD09PXQ/dGhpczpuZXcgdSh0aGlzLHQpfSx0cCRkb2M6XFxcIkNyZWF0ZSBhIGNhY2hlZCBjYWxsYWJsZSB0aGF0IHdyYXBzIGFub3RoZXIgZnVuY3Rpb24uXFxcXG5cXFxcbnVzZXJfZnVuY3Rpb246ICAgICAgdGhlIGZ1bmN0aW9uIGJlaW5nIGNhY2hlZFxcXFxuXFxcXG5tYXhzaXplOiAgMCAgICAgICAgIGZvciBubyBjYWNoaW5nXFxcXG4gICAgICAgICAgTm9uZSAgICAgIGZvciB1bmxpbWl0ZWQgY2FjaGUgc2l6ZVxcXFxuICAgICAgICAgIG4gICAgICAgICBmb3IgYSBib3VuZGVkIGNhY2hlXFxcXG5cXFxcbnR5cGVkOiAgICBGYWxzZSAgICAgY2FjaGUgZigzKSBhbmQgZigzLjApIGFzIGlkZW50aWNhbCBjYWxsc1xcXFxuICAgICAgICAgIFRydWUgICAgICBjYWNoZSBmKDMpIGFuZCBmKDMuMCkgYXMgZGlzdGluY3QgY2FsbHNcXFxcblxcXFxuY2FjaGVfaW5mb190eXBlOiAgICBuYW1lZHR1cGxlIGNsYXNzIHdpdGggdGhlIGZpZWxkczpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdHMgbWlzc2VzIGN1cnJzaXplIG1heHNpemVcXFxcblxcXCJ9LG1ldGhvZHM6e2NhY2hlX2luZm86eyRtZXRoKCl7cmV0dXJuIEEoSCxbdGhpcy5oaXRzLHRoaXMubWlzc2VzLC0xPT09dGhpcy5tYXhzaXplP286dGhpcy5tYXhzaXplLHRoaXMuY2FjaGUuZ2V0JHNpemUoKV0ubWFwKCh0PT56KHQpKSkpfSwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcXFwiUmVwb3J0IGNhY2hlIHN0YXRpc3RpY3NcXFwifSxjYWNoZV9jbGVhcjp7JG1ldGgoKXtyZXR1cm4gdGhpcy5oaXRzPXRoaXMubWlzc2VzPTAsdGhpcy5yb290PXt9LHRoaXMucm9vdC5uZXh0PXRoaXMucm9vdC5wcmV2PXRoaXMucm9vdCxBKHRoaXMuY2FjaGUudHAkZ2V0YXR0cihuZXcgcihcXFwiY2xlYXJcXFwiKSwhMCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcXFwiQ2xlYXIgdGhlIGNhY2hlIGFuZCBjYWNoZSBzdGF0aXN0aWNzXFxcIn0sX19kZWVwY29weV9fOnskbWV0aCh0KXtyZXR1cm4gdGhpc30sJGZsYWdzOntPbmVBcmc6ITB9fSxfX2NvcHlfXzp7JG1ldGgoKXtyZXR1cm4gdGhpc30sJGZsYWdzOntOb0FyZ3M6ITB9fX0sZ2V0c2V0czp7X19kaWN0X186R319KTtmdW5jdGlvbiBpbmZpbml0ZV9scnVfY2FjaGVfd3JhcHBlcih0LGUpe2NvbnN0IG49X21ha2Vfa2V5KHQsZSx0aGlzLnR5cGVkKSxyPXRoaXMuY2FjaGUubXAkbG9va3VwKG4pO3JldHVybiB2b2lkIDAhPT1yPyh0aGlzLmhpdHMrKyxyKToodGhpcy5taXNzZXMrKyxFKEEodGhpcy5mdW5jLHQsZSksKHQ9Pih0aGlzLmNhY2hlLm1wJGFzc19zdWJzY3JpcHQobix0KSx0KSkpKX1mdW5jdGlvbiB1bmNhY2hlZF9scnVfY2FjaGVfd3JhcHBlcih0LGUpe3JldHVybiB0aGlzLm1pc3NlcysrLEEodGhpcy5mdW5jLHQsZSl9ZnVuY3Rpb24gYm91bmRlZF9scnVfY2FjaGVfd3JhcHBlcih0LGUpe2NvbnN0IG49X21ha2Vfa2V5KHQsZSx0aGlzLnR5cGVkKSxyPXRoaXMuY2FjaGUubXAkbG9va3VwKG4pO2lmKHZvaWQgMCE9PXIpe2NvbnN0e3Jlc3VsdDp0fT1yO3JldHVybiBscnVfY2FjaGVfZXh0cmFjdF9saW5rKHIpLGxydV9jYWNoZV9hcHBlbmRfbGluayh0aGlzLHIpLHRoaXMuaGl0cysrLHR9cmV0dXJuIHRoaXMubWlzc2VzKyssRShBKHRoaXMuZnVuYyx0LGUpLCh0PT57aWYodm9pZCAwIT09dGhpcy5jYWNoZS5tcCRsb29rdXAobikpcmV0dXJuIHQ7aWYodGhpcy5jYWNoZS5nZXQkc2l6ZSgpPHRoaXMubWF4c2l6ZXx8dGhpcy5yb290Lm5leHQ9PT10aGlzLnJvb3Qpe2NvbnN0IGU9e2tleTpuLHJlc3VsdDp0fTtyZXR1cm4gdGhpcy5jYWNoZS5tcCRhc3Nfc3Vic2NyaXB0KG4sZSksbHJ1X2NhY2hlX2FwcGVuZF9saW5rKHRoaXMsZSksdH1jb25zdCBlPXRoaXMucm9vdC5uZXh0O2xydV9jYWNoZV9leHRyYWN0X2xpbmsoZSk7aWYodm9pZCAwPT09dGhpcy5jYWNoZS5wb3AkaXRlbShlLmtleSkpdGhyb3cgZnVuY3Rpb24gbHJ1X2NhY2hlX3ByZXBlbmRfbGluayh0LGUpe2NvbnN0IG49dC5yb290LHI9bi5uZXh0O3IucHJldj1uLm5leHQ9ZSxlLnByZXY9bixlLm5leHQ9cn0odGhpcyxlKSxuZXcgZChcXFwiY2FjaGVkIGl0ZW0gcmVtb3ZlZCB1bmV4cGVjdGVkbHlcXFwiKTtyZXR1cm4gZS5rZXk9bixlLnJlc3VsdD10LHRoaXMuY2FjaGUubXAkYXNzX3N1YnNjcmlwdChuLGUpLGxydV9jYWNoZV9hcHBlbmRfbGluayh0aGlzLGUpLHR9KSl9ZnVuY3Rpb24gbHJ1X2NhY2hlX2V4dHJhY3RfbGluayh0KXtjb25zdHtwcmV2OmUsbmV4dDpufT10O2UubmV4dD10Lm5leHQsbi5wcmV2PXQucHJldn1mdW5jdGlvbiBscnVfY2FjaGVfYXBwZW5kX2xpbmsodCxlKXtjb25zdCBuPXQucm9vdCxyPW4ucHJldjtyLm5leHQ9bi5wcmV2PWUsZS5wcmV2PXIsZS5uZXh0PW59Y29uc3QgSj1xKFxcXCJfSGFjaGVkU2VxXFxcIix7YmFzZTpzLGNvbnN0cnVjdG9yOmZ1bmN0aW9uIF9IYWNoZWRTZXEodCl7dGhpcy4kaGFzaHZhbD1DKG5ldyBhKHQpKSxzLmNhbGwodGhpcyx0KX0sc2xvdHM6e3RwJGhhc2goKXtyZXR1cm4gdGhpcy4kaGFzaHZhbH19fSksUT1uZXcgZSxYPW5ldyBTZXQoW24scl0pO2Z1bmN0aW9uIF9tYWtlX2tleSh0LGUsbil7Y29uc3Qgcz10LnNsaWNlKDApLGk9W107aWYoZSYmZS5sZW5ndGgpe3MucHVzaChRKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrPTIpe2NvbnN0IG49ZVt0KzFdO2kucHVzaChuKSxzLnB1c2gobmV3IGEoW25ldyByKGVbdF0pLG5dKSl9fWlmKFAobikpcy5wdXNoKC4uLnQubWFwKCh0PT50Lm9iJHR5cGUpKSwuLi5pLm1hcCgodD0+dC5vYiR0eXBlKSkpO2Vsc2UgaWYoMT09PXMubGVuZ3RoJiZYLmhhcyhzWzBdLm9iJHR5cGUpKXJldHVybiBzWzBdO3JldHVybiBuZXcgSihzKX1mdW5jdGlvbiBwYXJ0aWFsX2FkanVzdF9hcmdzX2t3YXJncyh0LGUpe2lmKHQ9dGhpcy5hcmdfYXJyLmNvbmNhdCh0KSxlKXtlPUQoZSk7Y29uc3QgdD10aGlzLmt3ZGljdC5kaWN0JGNvcHkoKTt0LmRpY3QkbWVyZ2UoZSksZT1JKHQpfWVsc2UgZT1JKHRoaXMua3dkaWN0KTtyZXR1cm57YXJnczp0LGt3YXJnczplfX1mdW5jdGlvbiBwYXJ0aWFsX25ldyh0LGUpe2lmKHQubGVuZ3RoPDEpdGhyb3cgbmV3IGgoXFxcInR5cGUgJ3BhcnRpYWwnIHRha2VzIGF0IGxlYXN0IDEgYXJndW1lbnRcXFwiKTtsZXQgbixyLHM9dC5zaGlmdCgpO2lmKHMgaW5zdGFuY2VvZiB0aGlzLnNrJGJ1aWx0aW5CYXNlKXtjb25zdCB0PXM7cz10LmZuLG49dC5hcmdfYXJyLHI9dC5rd2RpY3R9dGhpcy5jaGVjayRmdW5jKHMpLG4mJih0PW4uY29uY2F0KHQpKTtsZXQgYT1EKGU9ZXx8W10pO2lmKHIpe2NvbnN0IHQ9ci5kaWN0JGNvcHkoKTt0LmRpY3QkbWVyZ2UoYSksYT10fWlmKHRoaXMuc2skYnVpbHRpbkJhc2U9PT10aGlzLmNvbnN0cnVjdG9yKXJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzLHQsYSk7e2NvbnN0IGU9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIHRoaXMuc2skYnVpbHRpbkJhc2UuY2FsbChlLHMsdCxhKSxlfX1mdW5jdGlvbiBwYXJ0aWFsX3JlcHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyByKFxcXCIuLi5cXFwiKTt0aGlzLmluJHJlcHI9ITA7Y29uc3QgdD1bUih0aGlzLmZuKV07cmV0dXJuIHRoaXMuYXJnX2Fyci5mb3JFYWNoKChlPT57dC5wdXNoKFIoZSkpfSkpLHRoaXMua3dkaWN0LiRpdGVtcygpLmZvckVhY2goKChbZSxuXSk9Pnt0LnB1c2goZS50b1N0cmluZygpK1xcXCI9XFxcIitSKG4pKX0pKSx0aGlzLmluJHJlcHI9ITEsbmV3IHIodGhpcy50cCRuYW1lK1xcXCIoXFxcIit0LmpvaW4oXFxcIiwgXFxcIikrXFxcIilcXFwiKX10LnBhcnRpYWw9cShcXFwiZnVuY3Rvb2xzLnBhcnRpYWxcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBwYXJ0aWFsKHQsZSxuKXt0aGlzLmZuPXQsdGhpcy5hcmdfYXJyPWUsdGhpcy5hcmdfdHVwPW5ldyBhKGUpLHRoaXMua3dkaWN0PW4sdGhpcy5pbiRyZXByPSExLHRoaXMuJGQ9bmV3IGkoW10pfSxzbG90czp7dHAkbmV3OnBhcnRpYWxfbmV3LHRwJGNhbGwodCxlKXtyZXR1cm4oe2FyZ3M6dCxrd2FyZ3M6ZX09dGhpcy5hZGokYXJnc19rd3ModCxlKSksdGhpcy5mbi50cCRjYWxsKHQsZSl9LHRwJGRvYzpcXFwicGFydGlhbChmdW5jLCAqYXJncywgKiprZXl3b3JkcykgLSBuZXcgZnVuY3Rpb24gd2l0aCBwYXJ0aWFsIGFwcGxpY2F0aW9uXFxcXG4gICAgb2YgdGhlIGdpdmVuIGFyZ3VtZW50cyBhbmQga2V5d29yZHMuXFxcXG5cXFwiLCRyOnBhcnRpYWxfcmVwcix0cCRnZXRhdHRyOkIsdHAkc2V0YXR0cjpLfSxnZXRzZXRzOntmdW5jOnskZ2V0KCl7cmV0dXJuIHRoaXMuZm59LCRkb2M6XFxcImZ1bmN0aW9uIG9iamVjdCB0byB1c2UgaW4gZnV0dXJlIHBhcnRpYWwgY2FsbHNcXFwifSxhcmdzOnskZ2V0KCl7cmV0dXJuIHRoaXMuYXJnX3R1cH0sJGRvYzpcXFwidHVwbGUgb2YgYXJndW1lbnRzIHRvIGZ1dHVyZSBwYXJ0aWFsIGNhbGxzXFxcIn0sa2V5d29yZHM6eyRnZXQoKXtyZXR1cm4gdGhpcy5rd2RpY3R9LCRkb2M6XFxcImRpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMgdG8gZnV0dXJlIHBhcnRpYWwgY2FsbHNcXFwifSxfX2RpY3RfXzpHfSxtZXRob2RzOnt9LGNsYXNzbWV0aG9kczpTay5nZW5lcmljLmNsYXNzR2V0SXRlbSxwcm90bzp7YWRqJGFyZ3Nfa3dzOnBhcnRpYWxfYWRqdXN0X2FyZ3Nfa3dhcmdzLGNoZWNrJGZ1bmModCl7aWYoIWsodCkpdGhyb3cgbmV3IGgoXFxcInRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGNhbGxhYmxlXFxcIil9fX0pLHQucGFydGlhbG1ldGhvZD1xKFxcXCJmdW5jdG9vbHMucGFydGlhbG1ldGhvZFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHBhcnRpYWxtZXRob2QodCxlLG4pe3RoaXMuZm49dCx0aGlzLmFyZ19hcnI9ZSx0aGlzLmFyZ190dXA9bmV3IGEoZSksdGhpcy5rd2RpY3Q9bn0sc2xvdHM6e3RwJG5ldzpwYXJ0aWFsX25ldyx0cCRkb2M6XFxcIk1ldGhvZCBkZXNjcmlwdG9yIHdpdGggcGFydGlhbCBhcHBsaWNhdGlvbiBvZiB0aGUgZ2l2ZW4gYXJndW1lbnRzXFxcXG4gICAgYW5kIGtleXdvcmRzLlxcXFxuXFxcXG4gICAgU3VwcG9ydHMgd3JhcHBpbmcgZXhpc3RpbmcgZGVzY3JpcHRvcnMgYW5kIGhhbmRsZXMgbm9uLWRlc2NyaXB0b3JcXFxcbiAgICBjYWxsYWJsZXMgYXMgaW5zdGFuY2UgbWV0aG9kcy5cXFxcbiAgICBcXFwiLCRyOnBhcnRpYWxfcmVwcix0cCRkZXNjcl9nZXQoZSxuKXtsZXQgcjtpZih0aGlzLmZuLnRwJGRlc2NyX2dldCl7Y29uc3Qgcz10aGlzLmZuLnRwJGRlc2NyX2dldChlLG4pO2lmKHMhPT10aGlzLmZuKXtpZighayhzKSl0aHJvdyBuZXcgaChcXFwidHlwZSAncGFydGlhbCcgcmVxdWlyZXMgYSBjYWxsYWJsZVxcXCIpO3I9bmV3IHQucGFydGlhbChzLHRoaXMuYXJnX2Fyci5zbGljZSgwKSx0aGlzLmt3ZGljdC5kaWN0JGNvcHkoKSk7Y29uc3QgZT1NKHMsdGhpcy5zdHIkc2VsZik7dm9pZCAwIT09ZSYmci50cCRzZXRhdHRyKHRoaXMuc3RyJHNlbGYsZSl9fXJldHVybiB2b2lkIDA9PT1yJiYocj10aGlzLm1ha2UkdW5ib3VuZCgpLnRwJGRlc2NyX2dldChlLG4pKSxyfX0sbWV0aG9kczp7X21ha2VfdW5ib3VuZF9tZXRob2Q6eyRtZXRoKCl7cmV0dXJuIHRoaXMubWFrZSR1bmJvdW5kKCl9LCRmbGFnczp7Tm9BcmdzOiEwfX19LGNsYXNzbWV0aG9kczpTay5nZW5lcmljLmNsYXNzR2V0SXRlbSxnZXRzZXRzOntmdW5jOnskZ2V0KCl7cmV0dXJuIHRoaXMuZm59LCRkb2M6XFxcImZ1bmN0aW9uIG9iamVjdCB0byB1c2UgaW4gZnV0dXJlIHBhcnRpYWwgY2FsbHNcXFwifSxhcmdzOnskZ2V0KCl7cmV0dXJuIHRoaXMuYXJnX3R1cH0sJGRvYzpcXFwidHVwbGUgb2YgYXJndW1lbnRzIHRvIGZ1dHVyZSBwYXJ0aWFsIGNhbGxzXFxcIn0sa2V5d29yZHM6eyRnZXQoKXtyZXR1cm4gdGhpcy5rd2RpY3R9LCRkb2M6XFxcImRpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMgdG8gZnV0dXJlIHBhcnRpYWwgY2FsbHNcXFwifSxfX2RpY3RfXzpHfSxwcm90bzp7c3RyJHNlbGY6bmV3IHIoXFxcIl9fc2VsZl9fXFxcIiksbWFrZSR1bmJvdW5kKCl7Y29uc3QgdD10aGlzO2Z1bmN0aW9uIF9tZXRob2QoZSxuKXtjb25zdCByPWUuc2hpZnQoKTtyZXR1cm4oe2FyZ3M6ZSxrd2FyZ3M6bn09dC5hZGokYXJnc19rd3MoZSxuKSksZS51bnNoaWZ0KHIpLEEodC5mbixlLG4pfXJldHVybiBfbWV0aG9kLmNvX2Zhc3RjYWxsPSEwLG5ldyBwKF9tZXRob2QpfSxhZGokYXJnc19rd3M6cGFydGlhbF9hZGp1c3RfYXJnc19rd2FyZ3MsY2hlY2skZnVuYyh0KXtpZighayh0KSYmdm9pZCAwPT09dC50cCRkZXNjcl9nZXQpdGhyb3cgbmV3IGgoUih0KStcXFwiIGlzIG5vdCBjYWxsYWJsZSBvciBhIGRlc2NyaXB0b3JcXFwiKX19fSk7Y29uc3QgWT17X19sdF9fOnIuJGx0LF9fbGVfXzpyLiRsZSxfX2d0X186ci4kZ3QsX19nZV9fOnIuJGdlfTtmdW5jdGlvbiBmcm9tX3Nsb3QodCxlKXtjb25zdCBuPVlbdF07ZnVuY3Rpb24gY29tcGFyZV9zbG90KHQscil7bGV0IHM9eCh0LnRwJGdldGF0dHIobiksW3JdKTtyZXR1cm4gcz09PV8/czoocz1QKHMpLG5ldyBsKGUocyx0LHIpKSl9cmV0dXJuIGNvbXBhcmVfc2xvdC5jb19uYW1lPW4sY29tcGFyZV9zbG90fWNvbnN0IFo9ZnJvbV9zbG90KFxcXCJfX2x0X19cXFwiLCgodCxlLG4pPT4hdCYmaihlLG4sXFxcIk5vdEVxXFxcIikpKSx0dD1mcm9tX3Nsb3QoXFxcIl9fbHRfX1xcXCIsKCh0LGUsbik9PnR8fGooZSxuLFxcXCJFcVxcXCIpKSksZXQ9ZnJvbV9zbG90KFxcXCJfX2x0X19cXFwiLCh0PT4hdCkpLG50PWZyb21fc2xvdChcXFwiX19sZV9fXFxcIiwoKHQsZSxuKT0+IXR8fGooZSxuLFxcXCJFcVxcXCIpKSkscnQ9ZnJvbV9zbG90KFxcXCJfX2xlX19cXFwiLCgodCxlLG4pPT50JiZqKGUsbixcXFwiTm90RXFcXFwiKSkpLHN0PWZyb21fc2xvdChcXFwiX19sZV9fXFxcIiwodD0+IXQpKSxhdD1mcm9tX3Nsb3QoXFxcIl9fZ3RfX1xcXCIsKCh0LGUsbik9PiF0JiZqKGUsbixcXFwiTm90RXFcXFwiKSkpLGl0PWZyb21fc2xvdChcXFwiX19ndF9fXFxcIiwoKHQsZSxuKT0+dHx8aihlLG4sXFxcIkVxXFxcIikpKSxvdD1mcm9tX3Nsb3QoXFxcIl9fZ3RfX1xcXCIsKHQ9PiF0KSksY3Q9ZnJvbV9zbG90KFxcXCJfX2dlX19cXFwiLCgodCxlLG4pPT4hdHx8aihlLG4sXFxcIkVxXFxcIikpKSxfdD1mcm9tX3Nsb3QoXFxcIl9fZ2VfX1xcXCIsKCh0LGUsbik9PnQmJmooZSxuLFxcXCJOb3RFcVxcXCIpKSksbHQ9ZnJvbV9zbG90KFxcXCJfX2dlX19cXFwiLCh0PT4hdCkpLHB0PXtfX2x0X186e19fZ3RfXzpuZXcgcChaKSxfX2xlX186bmV3IHAodHQpLF9fZ2VfXzpuZXcgcChldCl9LF9fbGVfXzp7X19nZV9fOm5ldyBwKG50KSxfX2x0X186bmV3IHAocnQpLF9fZ3RfXzpuZXcgcChzdCl9LF9fZ3RfXzp7X19sdF9fOm5ldyBwKGF0KSxfX2dlX186bmV3IHAoaXQpLF9fbGVfXzpuZXcgcChvdCl9LF9fZ2VfXzp7X19sZV9fOm5ldyBwKGN0KSxfX2d0X186bmV3IHAoX3QpLF9fbHRfXzpuZXcgcChsdCl9fSx1dD17X19sdF9fOlxcXCJvYiRsdFxcXCIsX19sZV9fOlxcXCJvYiRsZVxcXCIsX19ndF9fOlxcXCJvYiRndFxcXCIsX19nZV9fOlxcXCJvYiRnZVxcXCJ9O2NvbnN0IGh0PW5ldyBuKDApLGR0PXEoXFxcImZ1bmN0b29scy5LZXlXcmFwcGVyXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24odCxlKXt0aGlzLmNtcD10LHRoaXMub2JqPWV9LHNsb3RzOnt0cCRjYWxsKHQsZSl7Y29uc3Rbbl09VyhcXFwiS1xcXCIsW1xcXCJvYmpcXFwiXSx0LGUsW10pO3JldHVybiBuZXcgZHQodGhpcy5jbXAsbil9LHRwJHJpY2hjb21wYXJlKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZHQpKXRocm93IG5ldyBoKFxcXCJvdGhlciBhcmd1bWVudCBtdXN0IGJlIEsgaW5zdGFuY2VcXFwiKTtjb25zdCBuPXRoaXMub2JqLHI9dC5vYmo7aWYoIW58fCFyKXRocm93IG5ldyB3KFxcXCJvYmplY3RcXFwiKTtjb25zdCBzPUEodGhpcy5jbXAsW24scl0pO3JldHVybiBFKHMsKHQ9PmoodCxodCxlKSkpfSx0cCRnZXRhdHRyOkIsdHAkaGFzaDpvfSxnZXRzZXRzOntvYmo6eyRnZXQoKXtyZXR1cm4gdGhpcy5vYmp8fG99LCRzZXQodCl7dGhpcy5vYmo9dH0sJGRvYzpcXFwiVmFsdWUgd3JhcHBlZCBieSBhIGtleSBmdW5jdGlvbi5cXFwifX19KSxmdD1uZXcgcihcXFwidXBkYXRlXFxcIiksbXQ9bmV3IHIoXFxcIl9fd3JhcHBlZF9fXFxcIik7cmV0dXJuIFQoXFxcImZ1bmN0b29sc1xcXCIsdCx7Y2FjaGU6eyRtZXRoOmZ1bmN0aW9uIGNhY2hlKHQpe3JldHVybiBBKF9scnVfY2FjaGUobyksW3RdKX0sJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6J1NpbXBsZSBsaWdodHdlaWdodCB1bmJvdW5kZWQgY2FjaGUuICBTb21ldGltZXMgY2FsbGVkIFxcXCJtZW1vaXplXFxcIi4nLCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgdXNlcl9mdW5jdGlvbiwgLylcXFwifSxscnVfY2FjaGU6eyRtZXRoOl9scnVfY2FjaGUsJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJtYXhzaXplXFxcIixcXFwidHlwZWRcXFwiXSxEZWZhdWx0czpbbmV3IG4oMTI4KSxjXX0sJGRvYzpcXFwiTGVhc3QtcmVjZW50bHktdXNlZCBjYWNoZSBkZWNvcmF0b3IuXFxcXG5cXFxcbklmICptYXhzaXplKiBpcyBzZXQgdG8gTm9uZSwgdGhlIExSVSBmZWF0dXJlcyBhcmUgZGlzYWJsZWQgYW5kIHRoZSBjYWNoZVxcXFxuY2FuIGdyb3cgd2l0aG91dCBib3VuZC5cXFxcblxcXFxuSWYgKnR5cGVkKiBpcyBUcnVlLCBhcmd1bWVudHMgb2YgZGlmZmVyZW50IHR5cGVzIHdpbGwgYmUgY2FjaGVkIHNlcGFyYXRlbHkuXFxcXG5Gb3IgZXhhbXBsZSwgZigzLjApIGFuZCBmKDMpIHdpbGwgYmUgdHJlYXRlZCBhcyBkaXN0aW5jdCBjYWxscyB3aXRoXFxcXG5kaXN0aW5jdCByZXN1bHRzLlxcXFxuXFxcXG5Bcmd1bWVudHMgdG8gdGhlIGNhY2hlZCBmdW5jdGlvbiBtdXN0IGJlIGhhc2hhYmxlLlxcXFxuXFxcXG5WaWV3IHRoZSBjYWNoZSBzdGF0aXN0aWNzIG5hbWVkIHR1cGxlIChoaXRzLCBtaXNzZXMsIG1heHNpemUsIGN1cnJzaXplKVxcXFxud2l0aCBmLmNhY2hlX2luZm8oKS4gIENsZWFyIHRoZSBjYWNoZSBhbmQgc3RhdGlzdGljcyB3aXRoIGYuY2FjaGVfY2xlYXIoKS5cXFxcbkFjY2VzcyB0aGUgdW5kZXJseWluZyBmdW5jdGlvbiB3aXRoIGYuX193cmFwcGVkX18uXFxcXG5cXFxcblNlZTogIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXMjTGVhc3RfcmVjZW50bHlfdXNlZF8oTFJVKVxcXCJ9LGNtcF90b19rZXk6eyRtZXRoOmZ1bmN0aW9uIGNtcF90b19rZXkodCl7cmV0dXJuIG5ldyBkdCh0KX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJteWNtcFxcXCJdLERlZmF1bHRzOltdfSwkZG9jOlxcXCJDb252ZXJ0IGEgY21wPSBmdW5jdGlvbiBpbnRvIGEga2V5PSBmdW5jdGlvbi5cXFwiLCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgY21wLCAvKVxcXCJ9LHJlZHVjZTp7JG1ldGg6ZnVuY3Rpb24gcmVkdWNlKHQsZSxuKXtjb25zdCByPVUoZSk7bGV0IHM7cmV0dXJuIG49bnx8ci50cCRpdGVybmV4dCghMCksRShuLChlPT57aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgaChcXFwicmVkdWNlKCkgb2YgZW1wdHkgc2VxdWVuY2Ugd2l0aCBubyBpbml0aWFsIHZhbHVlXFxcIik7cmV0dXJuIHM9ZSxTKHIsKGU9PkUoQSh0LFtzLGVdKSwodD0+e3M9dH0pKSkpfSksKCgpPT5zKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6M30sJGRvYzpcXFwicmVkdWNlKGZ1bmN0aW9uLCBzZXF1ZW5jZVssIGluaXRpYWxdKSAtPiB2YWx1ZVxcXFxuXFxcXG5BcHBseSBhIGZ1bmN0aW9uIG9mIHR3byBhcmd1bWVudHMgY3VtdWxhdGl2ZWx5IHRvIHRoZSBpdGVtcyBvZiBhIHNlcXVlbmNlLFxcXFxuZnJvbSBsZWZ0IHRvIHJpZ2h0LCBzbyBhcyB0byByZWR1Y2UgdGhlIHNlcXVlbmNlIHRvIGEgc2luZ2xlIHZhbHVlLlxcXFxuRm9yIGV4YW1wbGUsIHJlZHVjZShsYW1iZGEgeCwgeTogeCt5LCBbMSwgMiwgMywgNCwgNV0pIGNhbGN1bGF0ZXNcXFxcbigoKCgxKzIpKzMpKzQpKzUpLiAgSWYgaW5pdGlhbCBpcyBwcmVzZW50LCBpdCBpcyBwbGFjZWQgYmVmb3JlIHRoZSBpdGVtc1xcXFxub2YgdGhlIHNlcXVlbmNlIGluIHRoZSBjYWxjdWxhdGlvbiwgYW5kIHNlcnZlcyBhcyBhIGRlZmF1bHQgd2hlbiB0aGVcXFxcbnNlcXVlbmNlIGlzIGVtcHR5LlxcXCIsJHRleHRzaWc6XFxcIigkbW9kdWxlLCBmdW5jdGlvbiwgc2VxdWVuY2VbLCBpbml0aWFsXSwgLylcXFwifSx0b3RhbF9vcmRlcmluZzp7JG1ldGg6ZnVuY3Rpb24gdG90YWxfb3JkZXJpbmcodCl7Y29uc3Qgbj1bXTtpZighYih0KSl0aHJvdyBuZXcgaChcXFwidG90YWwgb3JkZXJpbmcgb25seSBzdXBwb3J0ZWQgZm9yIHR5cGUgb2JqZWN0cyBub3QgJ1xcXCIrRih0KStcXFwiJ1xcXCIpO2lmKE9iamVjdC5rZXlzKHB0KS5mb3JFYWNoKChyPT57Y29uc3Qgcz11dFtyXTt0LnByb3RvdHlwZVtzXSE9PWUucHJvdG90eXBlW3NdJiZuLnB1c2gocil9KSksIW4ubGVuZ3RoKXRocm93IG5ldyBmKFxcXCJtdXN0IGRlZmluZSBhdGxlYXN0IG9uZSBvcmRlcmluZyBvcGVyYXRpb246IDwsID4sIDw9LCA+PVxcXCIpO2NvbnN0IHI9blswXTtyZXR1cm4gT2JqZWN0LmVudHJpZXMocHRbcl0pLmZvckVhY2goKChbZSxyXSk9PntuLmluY2x1ZGVzKGUpfHx0LnRwJHNldGF0dHIoWVtlXSxyKX0pKSx0fSwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcXFwiQ2xhc3MgZGVjb3JhdG9yIHRoYXQgZmlsbHMgaW4gbWlzc2luZyBvcmRlcmluZyBtZXRob2RzXFxcIn0sdXBkYXRlX3dyYXBwZXI6eyRtZXRoOmZ1bmN0aW9uIHVwZGF0ZV93cmFwcGVyKHQsZSxuLHIpe2xldCBzLGE9VShuKTtmb3IobGV0IGk9YS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWk7aT1hLnRwJGl0ZXJuZXh0KCkpdm9pZCAwIT09KHM9ZS50cCRnZXRhdHRyKGkpKSYmdC50cCRzZXRhdHRyKGkscyk7YT1VKHIpO2ZvcihsZXQgbz1hLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09bztvPWEudHAkaXRlcm5leHQoKSl7cz1lLnRwJGdldGF0dHIobyl8fG5ldyBpKFtdKTtjb25zdCBuPU8odCxvKSxyPU8obixmdCk7eChyLFtzXSl9cmV0dXJuIHQudHAkc2V0YXR0cihtdCxlKSx0fSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcIndyYXBwZXJcXFwiLFxcXCJ3cmFwcGVkXFxcIixcXFwiYXNzaWduZWRcXFwiLFxcXCJ1cGRhdGVkXFxcIl0sRGVmYXVsdHM6W3QuV1JBUFBFUl9BU1NJR05NRU5UUyx0LldSQVBQRVJfVVBEQVRFU119LCRkb2M6XFxcIlVwZGF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gdG8gbG9vayBsaWtlIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXFxcXG5cXFxcbiAgICAgICB3cmFwcGVyIGlzIHRoZSBmdW5jdGlvbiB0byBiZSB1cGRhdGVkXFxcXG4gICAgICAgd3JhcHBlZCBpcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb25cXFxcbiAgICAgICBhc3NpZ25lZCBpcyBhIHR1cGxlIG5hbWluZyB0aGUgYXR0cmlidXRlcyBhc3NpZ25lZCBkaXJlY3RseVxcXFxuICAgICAgIGZyb20gdGhlIHdyYXBwZWQgZnVuY3Rpb24gdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gKGRlZmF1bHRzIHRvXFxcXG4gICAgICAgZnVuY3Rvb2xzLldSQVBQRVJfQVNTSUdOTUVOVFMpXFxcXG4gICAgICAgdXBkYXRlZCBpcyBhIHR1cGxlIG5hbWluZyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgd3JhcHBlciB0aGF0XFxcXG4gICAgICAgYXJlIHVwZGF0ZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgZnJvbSB0aGUgd3JhcHBlZFxcXFxuICAgICAgIGZ1bmN0aW9uIChkZWZhdWx0cyB0byBmdW5jdG9vbHMuV1JBUFBFUl9VUERBVEVTKVxcXFxuICAgIFxcXCIsJHRleHRzaWc6XFxcIigkbW9kdWxlLCAvLCB3cmFwcGVyLCB3cmFwcGVkLCBhc3NpZ25lZD0oJ19fbW9kdWxlX18nLCAnX19uYW1lX18nLCAnX19xdWFsbmFtZV9fJywgJ19fZG9jX18nLCAnX19hbm5vdGF0aW9uc19fJyksIHVwZGF0ZWQ9KCdfX2RpY3RfXycsKSlcXFwifSx3cmFwczp7JG1ldGg6ZnVuY3Rpb24gd3JhcHMoZSxuLHIpe2NvbnN0IHM9W1xcXCJ3cmFwcGVkXFxcIixlLFxcXCJhc3NpZ25lZFxcXCIsbixcXFwidXBkYXRlZFxcXCIscl07cmV0dXJuIEEodC5wYXJ0aWFsLFt0LnVwZGF0ZV93cmFwcGVyXSxzKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJ3cmFwcGVkXFxcIixcXFwiYXNzaWduZWRcXFwiLFxcXCJ1cGRhdGVkXFxcIl0sRGVmYXVsdHM6W3QuV1JBUFBFUl9BU1NJR05NRU5UUyx0LldSQVBQRVJfVVBEQVRFU119LCRkb2M6XFxcIkRlY29yYXRvciBmYWN0b3J5IHRvIGFwcGx5IHVwZGF0ZV93cmFwcGVyKCkgdG8gYSB3cmFwcGVyIGZ1bmN0aW9uXFxcXG5cXFxcbiAgICAgICBSZXR1cm5zIGEgZGVjb3JhdG9yIHRoYXQgaW52b2tlcyB1cGRhdGVfd3JhcHBlcigpIHdpdGggdGhlIGRlY29yYXRlZFxcXFxuICAgICAgIGZ1bmN0aW9uIGFzIHRoZSB3cmFwcGVyIGFyZ3VtZW50IGFuZCB0aGUgYXJndW1lbnRzIHRvIHdyYXBzKCkgYXMgdGhlXFxcXG4gICAgICAgcmVtYWluaW5nIGFyZ3VtZW50cy4gRGVmYXVsdCBhcmd1bWVudHMgYXJlIGFzIGZvciB1cGRhdGVfd3JhcHBlcigpLlxcXFxuICAgICAgIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzaW1wbGlmeSBhcHBseWluZyBwYXJ0aWFsKCkgdG9cXFxcbiAgICAgICB1cGRhdGVfd3JhcHBlcigpLlxcXFxuICAgIFxcXCIsJHRleHRzaWc6XFxcIigkbW9kdWxlLCAvLCB3cmFwcGVkLCBhc3NpZ25lZD0oJ19fbW9kdWxlX18nLCAnX19uYW1lX18nLCAnX19xdWFsbmFtZV9fJywgJ19fZG9jX18nLCAnX19hbm5vdGF0aW9uc19fJyksIHVwZGF0ZWQ9KCdfX2RpY3RfXycsKSlcXFwifX0pLHR9XCIsXCJzcmMvbGliL2ltYWdlLmpzXCI6XCJ2YXIgSW1hZ2VNb2QsJGJ1aWx0aW5tb2R1bGU7SW1hZ2VNb2R8fCgoSW1hZ2VNb2Q9e30pLmNhbnZhc0xpYj1bXSksJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oZSl7dmFyIG4saSx0LGEsdSxsLHIsYz17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJpbWFnZVxcXCIpfTtyZXR1cm4gYy5JbWFnZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsKGZ1bmN0aW9uKGUsbil7dT1mdW5jdGlvbihlKXtlLndpZHRoPWUuaW1hZ2Uud2lkdGgsZS5oZWlnaHQ9ZS5pbWFnZS5oZWlnaHQsZS5kZWxheT0wLGUudXBkYXRlQ291bnQ9MCxlLnVwZGF0ZUludGVydmFsPTEsZS5sYXN0eD0wLGUubGFzdHk9MCxlLmNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKSxlLmNhbnZhcy5oZWlnaHQ9ZS5oZWlnaHQsZS5jYW52YXMud2lkdGg9ZS53aWR0aCxlLmN0eD1lLmNhbnZhcy5nZXRDb250ZXh0KFxcXCIyZFxcXCIpLGUuY3R4LmRyYXdJbWFnZShlLmltYWdlLDAsMCksZS5pbWFnZWRhdGE9ZS5jdHguZ2V0SW1hZ2VEYXRhKDAsMCxlLndpZHRoLGUuaGVpZ2h0KX0sbi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4pe3ZhciBpO1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIl9faW5pdF9fXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMik7dHJ5e2UuaW1hZ2U9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoU2suZmZpLnJlbWFwVG9KcyhuKSksbnVsbD09ZS5pbWFnZSYmKGUuaW1hZ2U9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZmlsZW5hbWU9XFxcIiR7U2suZmZpLnJlbWFwVG9KcyhuKX1cXFwiXWApKSx1KGUpfWNhdGNoKHQpe2UuaW1hZ2U9bnVsbH1pZihudWxsPT1lLmltYWdlKXJldHVybihpPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKS5yZXN1bWU9ZnVuY3Rpb24oKXtpZihpLmRhdGEuZXJyb3IpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihpLmRhdGEuZXJyb3IubWVzc2FnZSl9LGkuZGF0YT17dHlwZTpcXFwiU2sucHJvbWlzZVxcXCIscHJvbWlzZTpuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSx0KXt2YXIgYT1uZXcgSW1hZ2U7YS5jcm9zc09yaWdpbj1cXFwiXFxcIixhLm9uZXJyb3I9ZnVuY3Rpb24oKXt0KEVycm9yKFxcXCJGYWlsZWQgdG8gbG9hZCBVUkw6IFxcXCIrYS5zcmMpKX0sYS5vbmxvYWQ9ZnVuY3Rpb24oKXtlLmltYWdlPXRoaXMsdShlKSxpKCl9LGEuc3JjPXIobil9KSl9LGl9KSkscj1mdW5jdGlvbihlKXtsZXQgbj1Tay5mZmkucmVtYXBUb0pzKGUpO3RyeXtsZXQgZT1Tay5yZWFkKG4pO3JldHVybmBkYXRhOmltYWdlLyR7bi5zdWJzdHJpbmcobi5sYXN0SW5kZXhPZihcXFwiLlxcXCIpKzEpfTtiYXNlNjQsICR7ZX1gfWNhdGNoKHUpe2NvbnNvbGUubG9nKGAke259IGlzIG5vdCBpbiB0aGUgZGF0YWJhc2UgJHt1fWApfXZhciBpLHQsYT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgU2suaW1hZ2VQcm94eT9Tay5pbWFnZVByb3h5OmZ1bmN0aW9uKGUpe3JldHVybihpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImFcXFwiKSkuaHJlZj10LHdpbmRvdy5sb2NhdGlvbi5ob3N0IT09aS5ob3N0P1NrLmltYWdlUHJveHkrXFxcIi9cXFwiK2U6ZX07cmV0dXJuIHQ9YSh0PVNrLmZmaS5yZW1hcFRvSnMoZSkpfSxsPWZ1bmN0aW9uKGUsbixpKXtpZihuPDB8fGk8MHx8bj49ZS53aWR0aHx8aT49ZS5oZWlnaHQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiUGl4ZWwgaW5kZXggb3V0IG9mIHJhbmdlLlxcXCIpfTt2YXIgc2V0ZGVsYXk9ZnVuY3Rpb24oZSxuLGkpe3ZhciB0O1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNldGRlbGF5XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMyksZS5kZWxheT1Tay5mZmkucmVtYXBUb0pzKG4pLHQ9U2suYnVpbHRpbi5hc251bSQoaSksZS51cGRhdGVJbnRlcnZhbD10fHwxfTtuLnNldF9kZWxheT1uZXcgU2suYnVpbHRpbi5mdW5jKHNldGRlbGF5KSxuLnNldERlbGF5PW5ldyBTay5idWlsdGluLmZ1bmMoc2V0ZGVsYXkpO3ZhciBnZXRwaXhlbHM9ZnVuY3Rpb24oZSl7dmFyIG4saT1bXTtmb3IoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0cGl4ZWxzXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksbj0wO248ZS5pbWFnZS5oZWlnaHQqZS5pbWFnZS53aWR0aDtuKyspaVtuXT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZS5nZXRQaXhlbCxbZSxuJWUuaW1hZ2Uud2lkdGgsTWF0aC5mbG9vcihuL2UuaW1hZ2Uud2lkdGgpXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKGkpfTtuLmdldF9waXhlbHM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXRwaXhlbHMpLG4uZ2V0UGl4ZWxzPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0cGl4ZWxzKSxuLmdldERhdGE9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7dmFyIG4saSx0LGEsdSxyLGMscz1bXTtmb3IoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0RGF0YVxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLG49MDtuPGUuaW1hZ2UuaGVpZ2h0KmUuaW1hZ2Uud2lkdGg7bisrKWk9biVlLmltYWdlLndpZHRoLHQ9TWF0aC5mbG9vcihuL2UuaW1hZ2Uud2lkdGgpLGwoZSxpLHQpLGM9NCp0KmUud2lkdGgrNCppLGE9ZS5pbWFnZWRhdGEuZGF0YVtjXSx1PWUuaW1hZ2VkYXRhLmRhdGFbYysxXSxyPWUuaW1hZ2VkYXRhLmRhdGFbYysyXSxzW25dPW5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5pbnRfKGEpLG5ldyBTay5idWlsdGluLmludF8odSksbmV3IFNrLmJ1aWx0aW4uaW50XyhyKV0pO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHMpfSkpO3ZhciBnZXRwaXhlbD1mdW5jdGlvbihlLG4saSl7dmFyIHQsYSx1LHI7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHBpeGVsXFxcIixhcmd1bWVudHMubGVuZ3RoLDMsMyksbj1Tay5idWlsdGluLmFzbnVtJChuKSxpPVNrLmJ1aWx0aW4uYXNudW0kKGkpLGwoZSxuLGkpLHI9NCppKmUud2lkdGgrNCpuLHQ9ZS5pbWFnZWRhdGEuZGF0YVtyXSx1PWUuaW1hZ2VkYXRhLmRhdGFbcisxXSxhPWUuaW1hZ2VkYXRhLmRhdGFbcisyXSxTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QaXhlbCxbdCx1LGEsbixpXSl9O24uZ2V0X3BpeGVsPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0cGl4ZWwpLG4uZ2V0UGl4ZWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXRwaXhlbCksYT1mdW5jdGlvbihlLG4saSl7dmFyIHQ9bmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb247cmV0dXJuIHQucmVzdW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sdC5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOm5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe2UudXBkYXRlQ291bnQrKyxlLnVwZGF0ZUNvdW50JWUudXBkYXRlSW50ZXJ2YWw9PTB8fGUudXBkYXRlQ291bnQ9PT1lLndpZHRoKmUuaGVpZ2h0PyhlLmxhc3RDdHgucHV0SW1hZ2VEYXRhKGUuaW1hZ2VkYXRhLDAsMCksZS5kZWxheT4wP3dpbmRvdy5zZXRUaW1lb3V0KG4sZS5kZWxheSk6bigpKTpuKCl9KSl9LHR9O3ZhciBzZXRwaXhlbD1mdW5jdGlvbihlLG4saSx0KXt2YXIgdTtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2V0cGl4ZWxcXFwiLGFyZ3VtZW50cy5sZW5ndGgsNCw0KSxuPVNrLmJ1aWx0aW4uYXNudW0kKG4pLGk9U2suYnVpbHRpbi5hc251bSQoaSksbChlLG4saSksdT00KmkqZS53aWR0aCs0Km4sZS5pbWFnZWRhdGEuZGF0YVt1XT1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5nZXRSZWQsW3RdKSksZS5pbWFnZWRhdGEuZGF0YVt1KzFdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LmdldEdyZWVuLFt0XSkpLGUuaW1hZ2VkYXRhLmRhdGFbdSsyXT1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5nZXRCbHVlLFt0XSkpLGUuaW1hZ2VkYXRhLmRhdGFbdSszXT0yNTUsYShlKX07bi5zZXRfcGl4ZWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhzZXRwaXhlbCksbi5zZXRQaXhlbD1uZXcgU2suYnVpbHRpbi5mdW5jKHNldHBpeGVsKTt2YXIgc2V0cGl4ZWxhdD1mdW5jdGlvbihlLG4saSl7dmFyIHQsdSxyO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRwaXhlbGF0XFxcIixhcmd1bWVudHMubGVuZ3RoLDMsMyksdD0obj1Tay5idWlsdGluLmFzbnVtJChuKSklZS5pbWFnZS53aWR0aCx1PU1hdGguZmxvb3Iobi9lLmltYWdlLndpZHRoKSxsKGUsdCx1KSxyPTQqdSplLndpZHRoKzQqdCxlLmltYWdlZGF0YS5kYXRhW3JdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShpLmdldFJlZCxbaV0pKSxlLmltYWdlZGF0YS5kYXRhW3IrMV09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGkuZ2V0R3JlZW4sW2ldKSksZS5pbWFnZWRhdGEuZGF0YVtyKzJdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShpLmdldEJsdWUsW2ldKSksZS5pbWFnZWRhdGEuZGF0YVtyKzNdPTI1NSxhKGUpfTtuLnNldF9waXhlbF9hdD1uZXcgU2suYnVpbHRpbi5mdW5jKHNldHBpeGVsYXQpLG4uc2V0UGl4ZWxBdD1uZXcgU2suYnVpbHRpbi5mdW5jKHNldHBpeGVsYXQpO3ZhciB1cGRhdGVwaXhlbD1mdW5jdGlvbihlLG4pe3ZhciBpLHQsdTtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwidXBkYXRlcGl4ZWxcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxpPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLmdldFgsW25dKSksdD1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5nZXRZLFtuXSkpLGwoZSxpLHQpLHU9NCp0KmUud2lkdGgrNCppLGUuaW1hZ2VkYXRhLmRhdGFbdV09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uZ2V0UmVkLFtuXSkpLGUuaW1hZ2VkYXRhLmRhdGFbdSsxXT1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5nZXRHcmVlbixbbl0pKSxlLmltYWdlZGF0YS5kYXRhW3UrMl09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uZ2V0Qmx1ZSxbbl0pKSxlLmltYWdlZGF0YS5kYXRhW3UrM109MjU1LGEoZSl9O24udXBkYXRlX3BpeGVsPW5ldyBTay5idWlsdGluLmZ1bmModXBkYXRlcGl4ZWwpLG4udXBkYXRlUGl4ZWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyh1cGRhdGVwaXhlbCk7dmFyIGdldGhlaWdodD1mdW5jdGlvbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0aGVpZ2h0XFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksbmV3IFNrLmJ1aWx0aW4uaW50XyhlLmhlaWdodCl9O24uZ2V0X2hlaWdodD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldGhlaWdodCksbi5nZXRIZWlnaHQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXRoZWlnaHQpO3ZhciBnZXR3aWR0aD1mdW5jdGlvbihlLG4pe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXR3aWR0aFxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLG5ldyBTay5idWlsdGluLmludF8oZS53aWR0aCl9O24uZ2V0X3dpZHRoPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0d2lkdGgpLG4uZ2V0V2lkdGg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXR3aWR0aCksbi5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4pe3JldHVyblxcXCJoZWlnaHRcXFwiPT09KG49U2suZmZpLnJlbWFwVG9KcyhuKSk/U2suYnVpbHRpbi5hc3NrJChlLmhlaWdodCk6XFxcIndpZHRoXFxcIj09PW4/U2suYnVpbHRpbi5hc3NrJChlLndpZHRoKTp2b2lkIDB9KSksbi5fX3NldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4saSl7dGhyb3dcXFwiaGVpZ2h0XFxcIj09PShuPVNrLmZmaS5yZW1hcFRvSnMobikpfHxcXFwid2lkdGhcXFwiPT09bj9uZXcgU2suYnVpbHRpbi5FeGNlcHRpb24oXFxcIkNhbm5vdCBjaGFuZ2UgaGVpZ2h0IG9yIHdpZHRoIHRoZXkgY2FuIG9ubHkgYmUgc2V0IG9uIGNyZWF0aW9uXFxcIik6bmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJVbmtub3duIGF0dHJpYnV0ZTogXFxcIituKX0pKSxuLmRyYXc9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuLGksdCl7dmFyIGE7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImRyYXdcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiw0KSwoYT1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbikucmVzdW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sYS5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOm5ldyBQcm9taXNlKChmdW5jdGlvbihhLHUpe3ZhciBsO249U2suYnVpbHRpbi5hc251bSQobiksaT1Tay5idWlsdGluLmFzbnVtJChpKSx0PVNrLmJ1aWx0aW4uYXNudW0kKHQpLGw9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uZ2V0V2luLFtuXSkuZ2V0Q29udGV4dChcXFwiMmRcXFwiKSx2b2lkIDA9PT1pJiYoaT0wLHQ9MCksZS5sYXN0VWx4PWksZS5sYXN0VWx5PXQsZS5sYXN0Q3R4PWwsbC5wdXRJbWFnZURhdGEoZS5pbWFnZWRhdGEsaSx0KSxlLmRlbGF5PjA/d2luZG93LnNldFRpbWVvdXQoYSxlLmRlbGF5KTp3aW5kb3cuc2V0VGltZW91dChhLDIwMCl9KSl9LGF9KSl9KSxcXFwiSW1hZ2VcXFwiLFtdKSx0PWZ1bmN0aW9uKGUsbil7bi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4saSl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMywzKSxlLndpZHRoPVNrLmJ1aWx0aW4uYXNudW0kKG4pLGUuaGVpZ2h0PVNrLmJ1aWx0aW4uYXNudW0kKGkpLGUuY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImNhbnZhc1xcXCIpLGUuY3R4PWUuY2FudmFzLmdldENvbnRleHQoXFxcIjJkXFxcIiksZS5jYW52YXMuaGVpZ2h0PWUuaGVpZ2h0LGUuY2FudmFzLndpZHRoPWUud2lkdGgsZS5pbWFnZWRhdGE9ZS5jdHguZ2V0SW1hZ2VEYXRhKDAsMCxlLndpZHRoLGUuaGVpZ2h0KX0pKX0sYy5FbXB0eUltYWdlPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYyx0LFxcXCJFbXB0eUltYWdlXFxcIixbYy5JbWFnZV0pLGk9ZnVuY3Rpb24oZSxuKXtuLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbixpLHQsYSx1KXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLmxlbmd0aCw0LDYpLGUucmVkPVNrLmJ1aWx0aW4uYXNudW0kKG4pLGUuZ3JlZW49U2suYnVpbHRpbi5hc251bSQoaSksZS5ibHVlPVNrLmJ1aWx0aW4uYXNudW0kKHQpLGUueD1Tay5idWlsdGluLmFzbnVtJChhKSxlLnk9U2suYnVpbHRpbi5hc251bSQodSl9KSk7dmFyIGdldHJlZD1mdW5jdGlvbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0cmVkXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5hc3NrJChlLnJlZCl9O24uZ2V0X3JlZD1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHJlZCksbi5nZXRSZWQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXRyZWQpO3ZhciBnZXRncmVlbj1mdW5jdGlvbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0Z3JlZW5cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLmFzc2skKGUuZ3JlZW4pfTtuLmdldF9ncmVlbj1uZXcgU2suYnVpbHRpbi5mdW5jKGdldGdyZWVuKSxuLmdldEdyZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0Z3JlZW4pO3ZhciBnZXRibHVlPWZ1bmN0aW9uKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRibHVlXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5hc3NrJChlLmJsdWUpfTtuLmdldF9ibHVlPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0Ymx1ZSksbi5nZXRCbHVlPW5ldyBTay5idWlsdGluLmZ1bmMoZ2V0Ymx1ZSk7dmFyIGdldHg9ZnVuY3Rpb24oZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHhcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLmFzc2skKGUueCl9O24uZ2V0X3g9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXR4KSxuLmdldFg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnZXR4KTt2YXIgZ2V0eT1mdW5jdGlvbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0eVxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4uYXNzayQoZS55KX07bi5nZXRfeT1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHkpLG4uZ2V0WT1uZXcgU2suYnVpbHRpbi5mdW5jKGdldHkpO3ZhciBzZXRyZWQ9ZnVuY3Rpb24oZSxuKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRyZWRcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxlLnJlZD1Tay5idWlsdGluLmFzbnVtJChuKX07bi5zZXRfcmVkPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0cmVkKSxuLnNldFJlZD1uZXcgU2suYnVpbHRpbi5mdW5jKHNldHJlZCk7dmFyIHNldGdyZWVuPWZ1bmN0aW9uKGUsbil7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2V0Z3JlZW5cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxlLmdyZWVuPVNrLmJ1aWx0aW4uYXNudW0kKG4pfTtuLnNldF9ncmVlbj1uZXcgU2suYnVpbHRpbi5mdW5jKHNldGdyZWVuKSxuLnNldEdyZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0Z3JlZW4pO3ZhciBzZXRibHVlPWZ1bmN0aW9uKGUsbil7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2V0Ymx1ZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLGUuYmx1ZT1Tay5idWlsdGluLmFzbnVtJChuKX07bi5zZXRfYmx1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKHNldGJsdWUpLG4uc2V0Qmx1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKHNldGJsdWUpLG4uX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuKXtyZXR1cm5cXFwicmVkXFxcIj09PShuPVNrLmZmaS5yZW1hcFRvSnMobikpP1NrLmJ1aWx0aW4uYXNzayQoZS5yZWQpOlxcXCJncmVlblxcXCI9PT1uP1NrLmJ1aWx0aW4uYXNzayQoZS5ncmVlbik6XFxcImJsdWVcXFwiPT09bj9Tay5idWlsdGluLmFzc2skKGUuYmx1ZSk6dm9pZCAwfSkpLG4uX19zZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuLGkpe1xcXCJyZWRcXFwiIT09KG49U2suZmZpLnJlbWFwVG9KcyhuKSkmJlxcXCJncmVlblxcXCIhPT1uJiZcXFwiYmx1ZVxcXCIhPT1ufHwoZVtuXT1Tay5idWlsdGluLmFzbnVtJChpKSl9KSk7dmFyIHNldHg9ZnVuY3Rpb24oZSxuKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXR4XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksZS54PVNrLmJ1aWx0aW4uYXNudW0kKG4pfTtuLnNldF94PW5ldyBTay5idWlsdGluLmZ1bmMoc2V0eCksbi5zZXRYPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0eCk7dmFyIHNldHk9ZnVuY3Rpb24oZSxuKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXR5XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksZS55PVNrLmJ1aWx0aW4uYXNudW0kKG4pfTtuLnNldF95PW5ldyBTay5idWlsdGluLmZ1bmMoc2V0eSksbi5zZXRZPW5ldyBTay5idWlsdGluLmZ1bmMoc2V0eSksbi5fX2dldGl0ZW1fXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4pe3JldHVybiAwPT09KG49U2suYnVpbHRpbi5hc251bSQobikpP2UucmVkOjE9PW4/ZS5ncmVlbjoyPT1uP2UuYmx1ZTp2b2lkIDB9KSksbi5fX3N0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe3JldHVybiBTay5mZmkucmVtYXBUb1B5KFxcXCJbXFxcIitlLnJlZCtcXFwiLFxcXCIrZS5ncmVlbitcXFwiLFxcXCIrZS5ibHVlK1xcXCJdXFxcIil9KSksbi5nZXRDb2xvclR1cGxlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbixpKXt9KSksbi5zZXRSYW5nZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4pe2UubWF4PVNrLmJ1aWx0aW4uYXNudW0kKG4pfSkpfSxjLlBpeGVsPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYyxpLFxcXCJQaXhlbFxcXCIsW10pLG49ZnVuY3Rpb24oZSxuKXtuLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsbixpKXt2YXIgdCxhLHU7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwzKSx2b2lkIDA9PT0odD1JbWFnZU1vZC5jYW52YXNMaWJbU2suY2FudmFzXSk/KGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIiksdT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChTay5jYW52YXMpLGUudGhlU2NyZWVuPWEsdS5hcHBlbmRDaGlsZChhKSxJbWFnZU1vZC5jYW52YXNMaWJbU2suY2FudmFzXT1hLEltYWdlTW9kLmNhbnZhc0xpYltTay5jYW52YXNdPWUudGhlU2NyZWVuKTooZS50aGVTY3JlZW49dCxlLnRoZVNjcmVlbi5oZWlnaHQ9ZS50aGVTY3JlZW4uaGVpZ2h0KSx2b2lkIDAhPT1uPyhlLnRoZVNjcmVlbi5oZWlnaHQ9aS52LGUudGhlU2NyZWVuLndpZHRoPW4udik6KFNrLmF2YWlsYWJsZUhlaWdodCYmKGUudGhlU2NyZWVuLmhlaWdodD1Tay5hdmFpbGFibGVIZWlnaHQpLFNrLmF2YWlsYWJsZVdpZHRoJiYoZS50aGVTY3JlZW4ud2lkdGg9U2suYXZhaWxhYmxlV2lkdGgpKSxlLnRoZVNjcmVlbi5zdHlsZS5kaXNwbGF5PVxcXCJibG9ja1xcXCJ9KSksbi5nZXRXaW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7cmV0dXJuIGUudGhlU2NyZWVufSkpLG4uZXhpdG9uY2xpY2s9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7dmFyIG49ZS50aGVTY3JlZW4uaWQ7ZS50aGVTY3JlZW4ub25jbGljaz1mdW5jdGlvbigpe2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4pLnN0eWxlLmRpc3BsYXk9XFxcIm5vbmVcXFwiLGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4pLm9uY2xpY2s9bnVsbCxkZWxldGUgSW1hZ2VNb2QuY2FudmFzTGliW25dfX0pKX0sYy5JbWFnZVdpbj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsbixcXFwiSW1hZ2VXaW5cXFwiLFtdKSxjfTtcIixcInNyYy9saWIvaXRlcnRvb2xzLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24odCl7dmFyIGU9e307ZnVuY3Rpb24gY29tYmluYXRpb25zTmV3KHQsZSxpKXtsZXQgcixzO1tyLHNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKHQudHAkbmFtZSxbXFxcIml0ZXJhYmxlXFxcIixcXFwiclxcXCJdLGUsaSxbXSk7Y29uc3Qgbj1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShyKTtpZihzPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChzLFNrLmJ1aWx0aW4uT3ZlckZsb3dFcnJvciksczwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcInIgbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTtpZih0aGlzPT09dClyZXR1cm4gbmV3IHQuY29uc3RydWN0b3IobixzKTt7Y29uc3QgZT1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gdC5jb25zdHJ1Y3Rvci5jYWxsKGUsbixzKSxlfX1yZXR1cm4gZS5hY2N1bXVsYXRlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmFjY3VtdWxhdGVcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBhY2N1bXVsYXRlKHQsZSxpKXt0aGlzLml0ZXI9dCx0aGlzLmZ1bmM9ZSx0aGlzLnRvdGFsPWksdGhpcy50cCRpdGVybmV4dD0oKT0+KHRoaXMudG90YWw9U2suYnVpbHRpbi5jaGVja05vbmUodGhpcy50b3RhbCk/dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCk6dGhpcy50b3RhbCx0aGlzLnRwJGl0ZXJuZXh0PXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRwJGl0ZXJuZXh0LHRoaXMudG90YWwpfSxpdGVybmV4dCh0KXtsZXQgZT10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtpZih2b2lkIDAhPT1lKXJldHVybiB0aGlzLnRvdGFsPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLmZ1bmMsW3RoaXMudG90YWwsZV0pLHRoaXMudG90YWx9LHNsb3RzOnt0cCRkb2M6XFxcImFjY3VtdWxhdGUoaXRlcmFibGVbLCBmdW5jLCBpbml0aWFsXSkgLS1cXFxceDNlIGFjY3VtdWxhdGUgb2JqZWN0XFxcXG5cXFxcblJldHVybiBzZXJpZXMgb2YgYWNjdW11bGF0ZWQgc3VtcyAob3Igb3RoZXIgYmluYXJ5IGZ1bmN0aW9uIHJlc3VsdHMpLlxcXCIsdHAkbmV3KHQsaSl7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJhY2N1bXVsYXRlXFxcIix0LDAsMik7bGV0W3IscyxuXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwiYWNjdW11bGF0ZVxcXCIsW1xcXCJpdGVyYWJsZVxcXCIsXFxcImZ1bmNcXFwiLFxcXCJpbml0aWFsXFxcIl0sdCxpLFtTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ub25lLm5vbmUkXSk7aWYocj1Tay5hYnN0ci5pdGVyKHIpLHM9U2suYnVpbHRpbi5jaGVja05vbmUocyk/bmV3IFNrLmJ1aWx0aW4uZnVuYygoKHQsZSk9PlNrLmFic3RyLm51bWJlckJpbk9wKHQsZSxcXFwiQWRkXFxcIikpKTpzLHRoaXM9PT1lLmFjY3VtdWxhdGUucHJvdG90eXBlKXJldHVybiBuZXcgZS5hY2N1bXVsYXRlKHIscyxuKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS5hY2N1bXVsYXRlLmNhbGwodCxyLHMsbiksdH19fX0pLGUuY2hhaW49U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuY2hhaW5cXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBjaGFpbih0KXt0aGlzLml0ZXJhYmxlcz10LHRoaXMuY3VycmVudF9pdD1udWxsLHRoaXMudHAkaXRlcm5leHQ9KCk9PntpZih0aGlzLnRwJGl0ZXJuZXh0PXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRwJGl0ZXJuZXh0LHRoaXMuY3VycmVudF9pdD10aGlzLml0ZXJhYmxlcy50cCRpdGVybmV4dCgpLHZvaWQgMCE9PXRoaXMuY3VycmVudF9pdClyZXR1cm4gdGhpcy5jdXJyZW50X2l0PVNrLmFic3RyLml0ZXIodGhpcy5jdXJyZW50X2l0KSx0aGlzLnRwJGl0ZXJuZXh0KCk7dGhpcy50cCRpdGVybmV4dD0oKT0+e319fSxpdGVybmV4dCh0KXtsZXQgZTtmb3IoO3ZvaWQgMD09PWU7KXtpZihlPXRoaXMuY3VycmVudF9pdC50cCRpdGVybmV4dCgpLHZvaWQgMCE9PWUpcmV0dXJuIGU7aWYodGhpcy5jdXJyZW50X2l0PXRoaXMuaXRlcmFibGVzLnRwJGl0ZXJuZXh0KCksdm9pZCAwPT09dGhpcy5jdXJyZW50X2l0KXJldHVybiB2b2lkKHRoaXMudHAkaXRlcm5leHQ9KCk9Pnt9KTt0aGlzLmN1cnJlbnRfaXQ9U2suYWJzdHIuaXRlcih0aGlzLmN1cnJlbnRfaXQpfX0sc2xvdHM6e3RwJGRvYzpcXFwiY2hhaW4oKml0ZXJhYmxlcykgLS1cXFxceDNlIGNoYWluIG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gYSBjaGFpbiBvYmplY3Qgd2hvc2UgLl9fbmV4dF9fKCkgbWV0aG9kIHJldHVybnMgZWxlbWVudHMgZnJvbSB0aGVcXFxcbmZpcnN0IGl0ZXJhYmxlIHVudGlsIGl0IGlzIGV4aGF1c3RlZCwgdGhlbiBlbGVtZW50cyBmcm9tIHRoZSBuZXh0XFxcXG5pdGVyYWJsZSwgdW50aWwgYWxsIG9mIHRoZSBpdGVyYWJsZXMgYXJlIGV4aGF1c3RlZC5cXFwiLHRwJG5ldyh0LGkpe2lmKFNrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXFxcImNoYWluXFxcIixpKSx0PW5ldyBTay5idWlsdGluLnR1cGxlKHQuc2xpY2UoMCkpLnRwJGl0ZXIoKSx0aGlzPT09ZS5jaGFpbi5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLmNoYWluKHQpO3tjb25zdCBpPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmNoYWluLmNhbGwoaSx0KSxpfX19LGNsYXNzbWV0aG9kczpPYmplY3QuYXNzaWduKHtmcm9tX2l0ZXJhYmxlOnskbWV0aCh0KXtjb25zdCBpPVNrLmFic3RyLml0ZXIodCk7cmV0dXJuIG5ldyBlLmNoYWluKGkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcXFwiY2hhaW4uZnJvbV9pdGVyYWJsZShpdGVyYWJsZSkgLS1cXFxceDNlIGNoYWluIG9iamVjdFxcXFxuXFxcXG5BbHRlcm5hdGUgY2hhaW4oKSBjb25zdHJ1Y3RvciB0YWtpbmcgYSBzaW5nbGUgaXRlcmFibGUgYXJndW1lbnRcXFxcbnRoYXQgZXZhbHVhdGVzIGxhemlseS5cXFwiLCR0ZXh0c2lnOm51bGx9fSxTay5nZW5lcmljLmNsYXNzR2V0SXRlbSl9KSxlLmNvbWJpbmF0aW9ucz1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5jb21iaW5hdGlvbnNcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBjb21iaW5hdGlvbnModCxlKXt0aGlzLnBvb2w9dCx0aGlzLnI9ZSx0aGlzLmluZGljZXM9bmV3IEFycmF5KGUpLmZpbGwoKS5tYXAoKCh0LGUpPT5lKSksdGhpcy5uPXQubGVuZ3RoLHRoaXMudHAkaXRlcm5leHQ9KCk9PntpZighKHRoaXMucj50aGlzLm4pKXJldHVybiB0aGlzLnRwJGl0ZXJuZXh0PXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRwJGl0ZXJuZXh0LG5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMucG9vbC5zbGljZSgwLHRoaXMucikpfX0saXRlcm5leHQodCl7bGV0IGUsaT0hMTtmb3IoZT10aGlzLnItMTtlPj0wO2UtLSlpZih0aGlzLmluZGljZXNbZV0hPWUrdGhpcy5uLXRoaXMucil7aT0hMDticmVha31pZighaSlyZXR1cm4gdm9pZCh0aGlzLnI9MCk7dGhpcy5pbmRpY2VzW2VdKys7Zm9yKGxldCBzPWUrMTtzPHRoaXMucjtzKyspdGhpcy5pbmRpY2VzW3NdPXRoaXMuaW5kaWNlc1tzLTFdKzE7Y29uc3Qgcj10aGlzLmluZGljZXMubWFwKCh0PT50aGlzLnBvb2xbdF0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUocil9LHNsb3RzOnt0cCRkb2M6XFxcImNvbWJpbmF0aW9ucyhpdGVyYWJsZSwgcikgLS1cXFxceDNlIGNvbWJpbmF0aW9ucyBvYmplY3RcXFxcblxcXFxuUmV0dXJuIHN1Y2Nlc3NpdmUgci1sZW5ndGggY29tYmluYXRpb25zIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYWJsZS5cXFxcblxcXFxuY29tYmluYXRpb25zKHJhbmdlKDQpLCAzKSAtLVxcXFx4M2UgKDAsMSwyKSwgKDAsMSwzKSwgKDAsMiwzKSwgKDEsMiwzKVxcXCIsdHAkbmV3KHQsaSl7cmV0dXJuIGNvbWJpbmF0aW9uc05ldy5jYWxsKHRoaXMsZS5jb21iaW5hdGlvbnMucHJvdG90eXBlLHQsaSl9fX0pLGUuY29tYmluYXRpb25zX3dpdGhfcmVwbGFjZW1lbnQ9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuY29tYmluYXRpb25zX3dpdGhfcmVwbGFjZW1lbnRcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBjb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudCh0LGUpe3RoaXMucG9vbD10LHRoaXMucj1lLHRoaXMuaW5kaWNlcz1uZXcgQXJyYXkoZSkuZmlsbCgwKSx0aGlzLm49dC5sZW5ndGgsdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKHRoaXMuciYmIXRoaXMubilyZXR1cm47dGhpcy50cCRpdGVybmV4dD10aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS50cCRpdGVybmV4dDtjb25zdCB0PXRoaXMuaW5kaWNlcy5tYXAoKHQ9PnRoaXMucG9vbFt0XSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZSh0KX19LGl0ZXJuZXh0KHQpe2xldCBlLGk9ITE7Zm9yKGU9dGhpcy5yLTE7ZT49MDtlLS0paWYodGhpcy5pbmRpY2VzW2VdIT10aGlzLm4tMSl7aT0hMDticmVha31pZighaSlyZXR1cm4gdm9pZCh0aGlzLnI9MCk7Y29uc3Qgcj10aGlzLmluZGljZXNbZV0rMTtmb3IobGV0IG49ZTtuPHRoaXMucjtuKyspdGhpcy5pbmRpY2VzW25dPXI7Y29uc3Qgcz10aGlzLmluZGljZXMubWFwKCh0PT50aGlzLnBvb2xbdF0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUocyl9LHNsb3RzOnt0cCRkb2M6XFxcImNvbWJpbmF0aW9uc193aXRoX3JlcGxhY2VtZW50KGl0ZXJhYmxlLCByKSAtLVxcXFx4M2UgY29tYmluYXRpb25zX3dpdGhfcmVwbGFjZW1lbnQgb2JqZWN0XFxcXG5cXFxcblJldHVybiBzdWNjZXNzaXZlIHItbGVuZ3RoIGNvbWJpbmF0aW9ucyBvZiBlbGVtZW50cyBpbiB0aGUgaXRlcmFibGVcXFxcbmFsbG93aW5nIGluZGl2aWR1YWwgZWxlbWVudHMgdG8gaGF2ZSBzdWNjZXNzaXZlIHJlcGVhdHMuXFxcXG5jb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudCgnQUJDJywgMikgLS1cXFxceDNlIEFBIEFCIEFDIEJCIEJDIENDXFxcIix0cCRuZXcodCxpKXtyZXR1cm4gY29tYmluYXRpb25zTmV3LmNhbGwodGhpcyxlLmNvbWJpbmF0aW9uc193aXRoX3JlcGxhY2VtZW50LnByb3RvdHlwZSx0LGkpfX19KSxlLmNvbXByZXNzPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmNvbXByZXNzXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gY29tcHJlc3ModCxlKXt0aGlzLmRhdGE9dCx0aGlzLnNlbGVjdG9ycz1lfSxpdGVybmV4dCgpe2xldCB0PXRoaXMuZGF0YS50cCRpdGVybmV4dCgpLGU9dGhpcy5zZWxlY3RvcnMudHAkaXRlcm5leHQoKTtmb3IoO3ZvaWQgMCE9PXQmJnZvaWQgMCE9PWU7KXtpZihTay5taXNjZXZhbC5pc1RydWUoZSkpcmV0dXJuIHQ7dD10aGlzLmRhdGEudHAkaXRlcm5leHQoKSxlPXRoaXMuc2VsZWN0b3JzLnRwJGl0ZXJuZXh0KCl9fSxzbG90czp7dHAkZG9jOlxcXCJjb21wcmVzcyhkYXRhLCBzZWxlY3RvcnMpIC0tXFxcXHgzZSBpdGVyYXRvciBvdmVyIHNlbGVjdGVkIGRhdGFcXFxcblxcXFxuUmV0dXJuIGRhdGEgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0cnVlIHNlbGVjdG9yIGVsZW1lbnRzLlxcXFxuRm9ybXMgYSBzaG9ydGVyIGl0ZXJhdG9yIGZyb20gc2VsZWN0ZWQgZGF0YSBlbGVtZW50cyB1c2luZyB0aGVcXFxcbnNlbGVjdG9ycyB0byBjaG9vc2UgdGhlIGRhdGEgZWxlbWVudHMuXFxcIix0cCRuZXcodCxpKXtsZXQgcixzO2lmKFtyLHNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJjb21wcmVzc1xcXCIsW1xcXCJkYXRhXFxcIixcXFwic2VsZWN0b3JzXFxcIl0sdCxpLFtdKSxyPVNrLmFic3RyLml0ZXIocikscz1Tay5hYnN0ci5pdGVyKHMpLHRoaXM9PT1lLmNvdW50LnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuY29tcHJlc3MocixzKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS5jb21wcmVzcy5jYWxsKHQscixzKSx0fX19fSksZS5jb3VudD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5jb3VudFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGNvdW50KHQsZSl7dGhpcy5zdGFydD10LHRoaXMuc3RlcD1lfSxpdGVybmV4dCgpe2NvbnN0IHQ9dGhpcy5zdGFydDtyZXR1cm4gdGhpcy5zdGFydD1Tay5hYnN0ci5udW1iZXJCaW5PcCh0aGlzLnN0YXJ0LHRoaXMuc3RlcCxcXFwiQWRkXFxcIiksdH0sc2xvdHM6e3RwJGRvYzpcXFwiY291bnQoc3RhcnQ9MCwgc3RlcD0xKSAtLVxcXFx4M2UgY291bnQgb2JqZWN0XFxcXG5cXFxcblJldHVybiBhIGNvdW50IG9iamVjdCB3aG9zZSAuX19uZXh0X18oKSBtZXRob2QgcmV0dXJucyBjb25zZWN1dGl2ZSB2YWx1ZXMuXFxcXG5FcXVpdmFsZW50IHRvOlxcXFxuXFxcXG4gICAgZGVmIGNvdW50KGZpcnN0dmFsPTAsIHN0ZXA9MSk6XFxcXG4gICAgICAgIHggPSBmaXJzdHZhbFxcXFxuICAgICAgICB3aGlsZSAxOlxcXFxuICAgICAgICAgICAgeWllbGQgeFxcXFxuICAgICAgICAgICAgeCArPSBzdGVwXFxcXG5cXFwiLHRwJG5ldyh0LGkpe2NvbnN0W3Isc109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcImNvdW50XFxcIixbXFxcInN0YXJ0XFxcIixcXFwic3RlcFxcXCJdLHQsaSxbbmV3IFNrLmJ1aWx0aW4uaW50XygwKSxuZXcgU2suYnVpbHRpbi5pbnRfKDEpXSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIocikmJiFTay5idWlsdGluLmNoZWNrQ29tcGxleChyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImEgbnVtYmVyIGlzIHJlcXVpcmVkXFxcIik7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIocykmJiFTay5idWlsdGluLmNoZWNrQ29tcGxleChzKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImEgbnVtYmVyIGlzIHJlcXVpcmVkXFxcIik7aWYodGhpcz09PWUuY291bnQucHJvdG90eXBlKXJldHVybiBuZXcgZS5jb3VudChyLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmNvdW50LmNhbGwodCxyLHMpLHR9fSwkcigpe2NvbnN0IHQ9U2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLnN0YXJ0KTtsZXQgZT1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMuc3RlcCk7cmV0dXJuIGU9XFxcIjFcXFwiPT09ZT9cXFwiXFxcIjpcXFwiLCBcXFwiK2UsbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1xcXCIoXFxcIit0K2UrXFxcIilcXFwiKX19fSksZS5jeWNsZT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5jeWNsZVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGN5Y2xlKHQpe3RoaXMuaXRlcj10LHRoaXMuc2F2ZWQ9W10sdGhpcy5jb25zdW1lZD0hMSx0aGlzLmk9MCx0aGlzLmxlbmd0aH0saXRlcm5leHQoKXtsZXQgdDtpZighdGhpcy5jb25zdW1lZCl7aWYodD10aGlzLml0ZXIudHAkaXRlcm5leHQoKSx2b2lkIDAhPT10KXJldHVybiB0aGlzLnNhdmVkLnB1c2godCksdDtpZih0aGlzLmNvbnN1bWVkPSEwLHRoaXMubGVuZ3RoPXRoaXMuc2F2ZWQubGVuZ3RoLCF0aGlzLmxlbmd0aClyZXR1cm59cmV0dXJuIHQ9dGhpcy5zYXZlZFt0aGlzLmldLHRoaXMuaT0odGhpcy5pKzEpJXRoaXMubGVuZ3RoLHR9LHNsb3RzOnt0cCRkb2M6XFxcImN5Y2xlKGl0ZXJhYmxlKSAtLVxcXFx4M2UgY3ljbGUgb2JqZWN0XFxcXG5cXFxcblJldHVybiBlbGVtZW50cyBmcm9tIHRoZSBpdGVyYWJsZSB1bnRpbCBpdCBpcyBleGhhdXN0ZWQuXFxcXG5UaGVuIHJlcGVhdCB0aGUgc2VxdWVuY2UgaW5kZWZpbml0ZWx5LlxcXCIsdHAkbmV3KHQsaSl7U2suYWJzdHIuY2hlY2tPbmVBcmcoXFxcImN5Y2xlXFxcIix0LGkpO2NvbnN0IHI9U2suYWJzdHIuaXRlcih0WzBdKTtpZih0aGlzPT09ZS5jeWNsZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLmN5Y2xlKHIpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmN5Y2xlLmNhbGwodCxyKSx0fX19fSksZS5kcm9wd2hpbGU9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuZHJvcHdoaWxlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gZHJvcHdoaWxlKHQsZSl7dGhpcy5wcmVkaWNhdGU9dCx0aGlzLml0ZXI9ZSx0aGlzLnBhc3NlZH0saXRlcm5leHQoKXtsZXQgdD10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtmb3IoO3ZvaWQgMD09PXRoaXMucGFzc2VkJiZ2b2lkIDAhPT10Oyl7Y29uc3QgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5wcmVkaWNhdGUsW3RdKTtpZighU2subWlzY2V2YWwuaXNUcnVlKGUpKXJldHVybiB0aGlzLnBhc3NlZD0hMCx0O3Q9dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCl9cmV0dXJuIHR9LHNsb3RzOnt0cCRkb2M6XFxcImRyb3B3aGlsZShwcmVkaWNhdGUsIGl0ZXJhYmxlKSAtLVxcXFx4M2UgZHJvcHdoaWxlIG9iamVjdFxcXFxuXFxcXG5Ecm9wIGl0ZW1zIGZyb20gdGhlIGl0ZXJhYmxlIHdoaWxlIHByZWRpY2F0ZShpdGVtKSBpcyB0cnVlLlxcXFxuQWZ0ZXJ3YXJkcywgcmV0dXJuIGV2ZXJ5IGVsZW1lbnQgdW50aWwgdGhlIGl0ZXJhYmxlIGlzIGV4aGF1c3RlZC5cXFwiLHRwJG5ldyh0LGkpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXFxcImRyb3B3aGlsZVxcXCIsaSksU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJkcm9wd2hpbGVcXFwiLHQsMiwyKTtjb25zdCByPXRbMF0scz1Tay5hYnN0ci5pdGVyKHRbMV0pO2lmKHRoaXM9PT1lLmRyb3B3aGlsZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLmRyb3B3aGlsZShyLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmRyb3B3aGlsZS5jYWxsKHQscixzKSx0fX19fSksZS5maWx0ZXJmYWxzZT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5maWx0ZXJmYWxzZVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGZpbHRlcmZhbHNlKHQsZSl7dGhpcy5wcmVkaWNhdGU9dCx0aGlzLml0ZXI9ZX0saXRlcm5leHQodCl7bGV0IGU9dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCk7aWYodm9pZCAwPT09ZSlyZXR1cm47bGV0IGk9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMucHJlZGljYXRlLFtlXSk7Zm9yKDtTay5taXNjZXZhbC5pc1RydWUoaSk7KXtpZihlPXRoaXMuaXRlci50cCRpdGVybmV4dCgpLHZvaWQgMD09PWUpcmV0dXJuO2k9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMucHJlZGljYXRlLFtlXSl9cmV0dXJuIGV9LHNsb3RzOnt0cCRkb2M6XFxcImZpbHRlcmZhbHNlKGZ1bmN0aW9uIG9yIE5vbmUsIHNlcXVlbmNlKSAtLVxcXFx4M2UgZmlsdGVyZmFsc2Ugb2JqZWN0XFxcXG5cXFxcblJldHVybiB0aG9zZSBpdGVtcyBvZiBzZXF1ZW5jZSBmb3Igd2hpY2ggZnVuY3Rpb24oaXRlbSkgaXMgZmFsc2UuXFxcXG5JZiBmdW5jdGlvbiBpcyBOb25lLCByZXR1cm4gdGhlIGl0ZW1zIHRoYXQgYXJlIGZhbHNlLlxcXCIsdHAkbmV3KHQsaSl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcXFwiZmlsdGVyZmFsc2VcXFwiLGkpLFNrLmFic3RyLmNoZWNrQXJnc0xlbihcXFwiZmlsdGVyZmFsc2VcXFwiLHQsMiwyKTtjb25zdCByPVNrLmJ1aWx0aW4uY2hlY2tOb25lKHRbMF0pP1NrLmJ1aWx0aW4uYm9vbDp0WzBdLHM9U2suYWJzdHIuaXRlcih0WzFdKTtpZih0aGlzPT09ZS5maWx0ZXJmYWxzZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLmZpbHRlcmZhbHNlKHIscyk7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuZmlsdGVyZmFsc2UuY2FsbCh0LHIscyksdH19fX0pLGUuX2dyb3VwZXI9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuX2dyb3VwZXJcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBfZ3JvdXBlcih0LGUpe3RoaXMuZ3JvdXBieT10LHRoaXMudGd0a2V5PXQudGd0a2V5LHRoaXMuaWQ9dC5pZH0saXRlcm5leHQodCl7Y29uc3QgZT1Tay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy5ncm91cGJ5LmN1cnJrZXksdGhpcy50Z3RrZXksXFxcIkVxXFxcIik7aWYodGhpcy5ncm91cGJ5LmlkPT09dGhpcy5pZCYmZSl7bGV0IHQ9dGhpcy5ncm91cGJ5LmN1cnJ2YWw7cmV0dXJuIHRoaXMuZ3JvdXBieS5jdXJydmFsPXRoaXMuZ3JvdXBieS5pdGVyLnRwJGl0ZXJuZXh0KCksdm9pZCAwIT09dGhpcy5ncm91cGJ5LmN1cnJ2YWwmJih0aGlzLmdyb3VwYnkuY3VycmtleT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5ncm91cGJ5LmtleWYsW3RoaXMuZ3JvdXBieS5jdXJydmFsXSkpLHR9fX0pLGUuZ3JvdXBieT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5ncm91cGJ5XFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gZ3JvdXBieSh0LGUpe3RoaXMuaXRlcj10LHRoaXMua2V5Zj1lLHRoaXMuY3VycnZhbCx0aGlzLmN1cnJrZXk9dGhpcy50Z3RrZXk9bmV3IFNrLmJ1aWx0aW4ub2JqZWN0LHRoaXMuaWR9LGl0ZXJuZXh0KHQpe3RoaXMuaWQ9bmV3IE9iamVjdDtsZXQgaT1Tay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy5jdXJya2V5LHRoaXMudGd0a2V5LFxcXCJFcVxcXCIpO2Zvcig7aTspe2lmKHRoaXMuY3VycnZhbD10aGlzLml0ZXIudHAkaXRlcm5leHQoKSx2b2lkIDA9PT10aGlzLmN1cnJ2YWwpcmV0dXJuO3RoaXMuY3VycmtleT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5rZXlmLFt0aGlzLmN1cnJ2YWxdKSxpPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLmN1cnJrZXksdGhpcy50Z3RrZXksXFxcIkVxXFxcIil9dGhpcy50Z3RrZXk9dGhpcy5jdXJya2V5O2NvbnN0IHI9bmV3IGUuX2dyb3VwZXIodGhpcyk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt0aGlzLmN1cnJrZXkscl0pfSxzbG90czp7dHAkZG9jOlxcXCJncm91cGJ5KGl0ZXJhYmxlLCBrZXk9Tm9uZSkgLT4gbWFrZSBhbiBpdGVyYXRvciB0aGF0IHJldHVybnMgY29uc2VjdXRpdmVcXFxcbmtleXMgYW5kIGdyb3VwcyBmcm9tIHRoZSBpdGVyYWJsZS4gIElmIHRoZSBrZXkgZnVuY3Rpb24gaXMgbm90IHNwZWNpZmllZCBvclxcXFxuaXMgTm9uZSwgdGhlIGVsZW1lbnQgaXRzZWxmIGlzIHVzZWQgZm9yIGdyb3VwaW5nLlxcXFxuXFxcIix0cCRuZXcodCxpKXtsZXQgcixzO2lmKFtyLHNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJncm91cGJ5XFxcIixbXFxcIml0ZXJhYmxlXFxcIixcXFwia2V5XFxcIl0sdCxpLFtTay5idWlsdGluLm5vbmUubm9uZSRdKSxyPVNrLmFic3RyLml0ZXIocikscz1Tay5idWlsdGluLmNoZWNrTm9uZShzKT9uZXcgU2suYnVpbHRpbi5mdW5jKCh0PT50KSk6cyx0aGlzPT09ZS5ncm91cGJ5LnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuZ3JvdXBieShyLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmdyb3VwYnkuY2FsbCh0LHIscyksdH19fX0pLGUuaXNsaWNlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmlzbGljZVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGlzbGljZSh0LGUsaSxyKXt0aGlzLml0ZXI9dCx0aGlzLnByZXZpdD1lLHRoaXMuc3RvcD1pLHRoaXMuc3RlcD1yLHRoaXMudHAkaXRlcm5leHQ9KCk9PntpZih0aGlzLnRwJGl0ZXJuZXh0PXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRwJGl0ZXJuZXh0LCEodGhpcy5wcmV2aXQ+PXRoaXMuc3RvcCkpe2ZvcihsZXQgdD0wO3Q8dGhpcy5wcmV2aXQ7dCsrKXRoaXMuaXRlci50cCRpdGVybmV4dCgpO3JldHVybiB0aGlzLml0ZXIudHAkaXRlcm5leHQoKX1mb3IobGV0IHQ9MDt0PHRoaXMuc3RvcDt0KyspdGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCl9fSxpdGVybmV4dCh0KXtpZighKHRoaXMucHJldml0K3RoaXMuc3RlcD49dGhpcy5zdG9wKSl7Zm9yKGxldCB0PXRoaXMucHJldml0KzE7dDx0aGlzLnByZXZpdCt0aGlzLnN0ZXA7dCsrKXRoaXMuaXRlci50cCRpdGVybmV4dCgpO3JldHVybiB0aGlzLnByZXZpdCs9dGhpcy5zdGVwLHRoaXMuaXRlci50cCRpdGVybmV4dCgpfWZvcihsZXQgZT10aGlzLnByZXZpdCsxO2U8dGhpcy5zdG9wO2UrKyl0aGlzLnByZXZpdCs9dGhpcy5zdGVwLHRoaXMuaXRlci50cCRpdGVybmV4dCgpfSxzbG90czp7dHAkZG9jOlxcXCJpc2xpY2UoaXRlcmFibGUsIHN0b3ApIC0tXFxcXHgzZSBpc2xpY2Ugb2JqZWN0XFxcXG5pc2xpY2UoaXRlcmFibGUsIHN0YXJ0LCBzdG9wWywgc3RlcF0pIC0tXFxcXHgzZSBpc2xpY2Ugb2JqZWN0XFxcXG5cXFxcblJldHVybiBhbiBpdGVyYXRvciB3aG9zZSBuZXh0KCkgbWV0aG9kIHJldHVybnMgc2VsZWN0ZWQgdmFsdWVzIGZyb20gYW5cXFxcbml0ZXJhYmxlLiAgSWYgc3RhcnQgaXMgc3BlY2lmaWVkLCB3aWxsIHNraXAgYWxsIHByZWNlZGluZyBlbGVtZW50cztcXFxcbm90aGVyd2lzZSwgc3RhcnQgZGVmYXVsdHMgdG8gemVyby4gIFN0ZXAgZGVmYXVsdHMgdG8gb25lLiAgSWZcXFxcbnNwZWNpZmllZCBhcyBhbm90aGVyIHZhbHVlLCBzdGVwIGRldGVybWluZXMgaG93IG1hbnkgdmFsdWVzIGFyZSBcXFxcbnNraXBwZWQgYmV0d2VlbiBzdWNjZXNzaXZlIGNhbGxzLiAgV29ya3MgbGlrZSBhIHNsaWNlKCkgb24gYSBsaXN0XFxcXG5idXQgcmV0dXJucyBhbiBpdGVyYXRvci5cXFwiLHRwJG5ldyh0LGkpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXFxcImlzbGljZVxcXCIsaSksU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJpc2xpY2VcXFwiLHQsMiw0KTtjb25zdCByPVNrLmFic3RyLml0ZXIodFswXSk7bGV0IHM9dFsxXSxuPXRbMl0sbz10WzNdO2lmKHZvaWQgMD09PW4/KG49cyxzPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCxvPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk6dm9pZCAwPT09byYmKG89U2suYnVpbHRpbi5ub25lLm5vbmUkKSwhU2suYnVpbHRpbi5jaGVja05vbmUobikmJiFTay5taXNjZXZhbC5pc0luZGV4KG4pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlN0b3AgZm9yIGlzbGljZSgpIG11c3QgYmUgTm9uZSBvciBhbiBpbnRlZ2VyOiAwIDw9IHggPD0gc3lzLm1heHNpemUuXFxcIik7aWYobj1Tay5idWlsdGluLmNoZWNrTm9uZShuKT9OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQobiksbjwwfHxuPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlN0b3AgZm9yIGlzbGljZSgpIG11c3QgYmUgTm9uZSBvciBhbiBpbnRlZ2VyOiAwIDw9IHggPD0gc3lzLm1heHNpemUuXFxcIik7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKHMpJiYhU2subWlzY2V2YWwuaXNJbmRleChzKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJJbmRpY2VzIGZvciBpc2xpY2UoKSBtdXN0IGJlIE5vbmUgb3IgYW4gaW50ZWdlcjogMCA8PSB4IDw9IHN5cy5tYXhzaXplLlxcXCIpO2lmKHM9U2suYnVpbHRpbi5jaGVja05vbmUocyk/MDpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQocyksczwwfHxzPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkluZGljZXMgZm9yIGlzbGljZSgpIG11c3QgYmUgTm9uZSBvciBhbiBpbnRlZ2VyOiAwIDw9IHggPD0gc3lzLm1heHNpemUuXFxcIik7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKG8pJiYhU2subWlzY2V2YWwuaXNJbmRleChvKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJTdGVwIGZvciBpc2xpY2UoKSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciBOb25lXFxcIik7aWYobz1Tay5idWlsdGluLmNoZWNrTm9uZShvKT8xOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChvKSxvPD0wfHxvPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlN0ZXAgZm9yIGlzbGljZSgpIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIE5vbmUuXFxcIik7aWYodGhpcz09PWUuaXNsaWNlLnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuaXNsaWNlKHIscyxuLG8pO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmlzbGljZS5jYWxsKHQscixzLG4sbyksdH19fX0pLGUucGVybXV0YXRpb25zPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnBlcm11dGF0aW9uc1xcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHBlcm11dGF0aW9ucyh0LGUpe3RoaXMucG9vbD10LHRoaXMucj1lO2NvbnN0IGk9dC5sZW5ndGg7dGhpcy5pbmRpY2VzPW5ldyBBcnJheShpKS5maWxsKCkubWFwKCgodCxlKT0+ZSkpLHRoaXMuY3ljbGVzPW5ldyBBcnJheShlKS5maWxsKCkubWFwKCgodCxlKT0+aS1lKSksdGhpcy5uPWksdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKCEodGhpcy5yPnRoaXMubikpcmV0dXJuIHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsbmV3IFNrLmJ1aWx0aW4udHVwbGUodGhpcy5wb29sLnNsaWNlKDAsdGhpcy5yKSl9fSxpdGVybmV4dCh0KXtmb3IobGV0IGU9dGhpcy5yLTE7ZT49MDtlLS0pe2lmKHRoaXMuY3ljbGVzW2VdLS0sMCE9dGhpcy5jeWNsZXNbZV0pe2NvbnN0IHQ9dGhpcy5jeWNsZXNbZV07W3RoaXMuaW5kaWNlc1tlXSx0aGlzLmluZGljZXNbdGhpcy5uLXRdXT1bdGhpcy5pbmRpY2VzW3RoaXMubi10XSx0aGlzLmluZGljZXNbZV1dO2NvbnN0IGk9dGhpcy5pbmRpY2VzLm1hcCgodD0+dGhpcy5wb29sW3RdKSkuc2xpY2UoMCx0aGlzLnIpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShpKX10aGlzLmluZGljZXMucHVzaCh0aGlzLmluZGljZXMuc3BsaWNlKGUsMSlbMF0pLHRoaXMuY3ljbGVzW2VdPXRoaXMubi1lfXRoaXMucj0wfSxzbG90czp7dHAkZG9jOlxcXCJwZXJtdXRhdGlvbnMoaXRlcmFibGVbLCByXSkgLS1cXFxceDNlIHBlcm11dGF0aW9ucyBvYmplY3RcXFxcblxcXFxuUmV0dXJuIHN1Y2Nlc3NpdmUgci1sZW5ndGggcGVybXV0YXRpb25zIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYWJsZS5cXFxcblxcXFxucGVybXV0YXRpb25zKHJhbmdlKDMpLCAyKSAtLVxcXFx4M2UgKDAsMSksICgwLDIpLCAoMSwwKSwgKDEsMiksICgyLDApLCAoMiwxKVxcXCIsdHAkbmV3KHQsaSl7bGV0IHIscztbcixzXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwicGVybXV0YXRpb25zXFxcIixbXFxcIml0ZXJhYmxlXFxcIixcXFwiclxcXCJdLHQsaSxbU2suYnVpbHRpbi5ub25lLm5vbmUkXSk7Y29uc3Qgbj1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShyKTtpZihzPVNrLmJ1aWx0aW4uY2hlY2tOb25lKHMpP24ubGVuZ3RoOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChzLFNrLmJ1aWx0aW4uT3ZlckZsb3dFcnJvciksczwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcInIgbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTtpZih0aGlzPT09ZS5wZXJtdXRhdGlvbnMucHJvdG90eXBlKXJldHVybiBuZXcgZS5wZXJtdXRhdGlvbnMobixzKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS5wZXJtdXRhdGlvbnMuY2FsbCh0LG4scyksdH19fX0pLGUucHJvZHVjdD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5wcm9kdWN0XFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gcHJvZHVjdCh0KXt0aGlzLnBvb2xzPXQsdGhpcy5uPXQubGVuZ3RoLHRoaXMuaW5kaWNlcz1BcnJheSh0Lmxlbmd0aCkuZmlsbCgwKSx0aGlzLnBvb2xfc2l6ZXM9dC5tYXAoKHQ9PnQubGVuZ3RoKSksdGhpcy50cCRpdGVybmV4dD0oKT0+e3RoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQ7Y29uc3QgdD10aGlzLmluZGljZXMubWFwKCgodCxlKT0+dGhpcy5wb29sc1tlXVt0aGlzLmluZGljZXNbZV1dKSk7aWYoIXQuc29tZSgodD0+dm9pZCAwPT09dCkpKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZSh0KTt0aGlzLm49MH19LGl0ZXJuZXh0KHQpe2xldCBlPXRoaXMubi0xO2Zvcig7ZT49MCYmZTx0aGlzLm47KXRoaXMuaW5kaWNlc1tlXSsrLHRoaXMuaW5kaWNlc1tlXT49dGhpcy5wb29sX3NpemVzW2VdPyh0aGlzLmluZGljZXNbZV09LTEsZS0tKTplKys7aWYodGhpcy5uJiYhdGhpcy5pbmRpY2VzLmV2ZXJ5KCh0PT4tMT09PXQpKSl7Y29uc3QgdD10aGlzLmluZGljZXMubWFwKCgodCxlKT0+dGhpcy5wb29sc1tlXVt0aGlzLmluZGljZXNbZV1dKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKHQpfXRoaXMubj0wfSxzbG90czp7dHAkZG9jOlxcXCJwcm9kdWN0KCppdGVyYWJsZXMsIHJlcGVhdD0xKSAtLVxcXFx4M2UgcHJvZHVjdCBvYmplY3RcXFxcblxcXFxuQ2FydGVzaWFuIHByb2R1Y3Qgb2YgaW5wdXQgaXRlcmFibGVzLiAgRXF1aXZhbGVudCB0byBuZXN0ZWQgZm9yLWxvb3BzLlxcXFxuXFxcXG5Gb3IgZXhhbXBsZSwgcHJvZHVjdChBLCBCKSByZXR1cm5zIHRoZSBzYW1lIGFzOiAgKCh4LHkpIGZvciB4IGluIEEgZm9yIHkgaW4gQikuXFxcXG5UaGUgbGVmdG1vc3QgaXRlcmF0b3JzIGFyZSBpbiB0aGUgb3V0ZXJtb3N0IGZvci1sb29wLCBzbyB0aGUgb3V0cHV0IHR1cGxlc1xcXFxuY3ljbGUgaW4gYSBtYW5uZXIgc2ltaWxhciB0byBhbiBvZG9tZXRlciAod2l0aCB0aGUgcmlnaHRtb3N0IGVsZW1lbnQgY2hhbmdpbmdcXFxcbm9uIGV2ZXJ5IGl0ZXJhdGlvbikuXFxcXG5cXFxcblRvIGNvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYW4gaXRlcmFibGUgd2l0aCBpdHNlbGYsIHNwZWNpZnkgdGhlIG51bWJlclxcXFxub2YgcmVwZXRpdGlvbnMgd2l0aCB0aGUgb3B0aW9uYWwgcmVwZWF0IGtleXdvcmQgYXJndW1lbnQuIEZvciBleGFtcGxlLFxcXFxucHJvZHVjdChBLCByZXBlYXQ9NCkgbWVhbnMgdGhlIHNhbWUgYXMgcHJvZHVjdChBLCBBLCBBLCBBKS5cXFxcblxcXFxucHJvZHVjdCgnYWInLCByYW5nZSgzKSkgLS1cXFxceDNlICgnYScsMCkgKCdhJywxKSAoJ2EnLDIpICgnYicsMCkgKCdiJywxKSAoJ2InLDIpXFxcXG5wcm9kdWN0KCgwLDEpLCAoMCwxKSwgKDAsMSkpIC0tXFxcXHgzZSAoMCwwLDApICgwLDAsMSkgKDAsMSwwKSAoMCwxLDEpICgxLDAsMCkgLi4uXFxcIix0cCRuZXcodCxpKXtsZXRbcl09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcInByb2R1Y3RcXFwiLFtcXFwicmVwZWF0XFxcIl0sW10saSxbbmV3IFNrLmJ1aWx0aW4uaW50XygxKV0pO2lmKHI9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHIsU2suYnVpbHRpbi5PdmVyRmxvd0Vycm9yKSxyPDApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwicmVwZWF0IGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZVxcXCIpO2NvbnN0IHM9W107Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspcy5wdXNoKFNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKHRbZV0pKTtjb25zdCBuPVtdLmNvbmNhdCguLi5BcnJheShyKS5maWxsKHMpKTtpZih0aGlzPT09ZS5wcm9kdWN0LnByb3RvdHlwZSlyZXR1cm4gbmV3IGUucHJvZHVjdChuKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS5wcm9kdWN0LmNhbGwodCxuKSx0fX19fSksZS5yZXBlYXQ9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMucmVwZWF0XFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gcmVwZWF0KHQsZSl7dGhpcy5vYmplY3Q9dCx0aGlzLnRpbWVzPWUsdm9pZCAwPT09ZSYmKHRoaXMudHAkaXRlcm5leHQ9KCk9PnRoaXMub2JqZWN0KX0saXRlcm5leHQodCl7cmV0dXJuIHRoaXMudGltZXMtLSA+MD90aGlzLm9iamVjdDp2b2lkIDB9LHNsb3RzOnt0cCRkb2M6XFxcInJlcGVhdChvYmplY3QgWyx0aW1lc10pIC0+IGNyZWF0ZSBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBvYmplY3RcXFxcbmZvciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy4gIElmIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgdGhlIG9iamVjdFxcXFxuZW5kbGVzc2x5LlxcXCIsdHAkbmV3KHQsaSl7bGV0IHIscztpZihbcixzXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwicmVwZWF0XFxcIixbXFxcIm9iamVjdFxcXCIsXFxcInRpbWVzXFxcIl0sdCxpLFtudWxsXSkscz1udWxsIT09cz9Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQocyxTay5idWlsdGluLk92ZXJGbG93RXJyb3IpOnZvaWQgMCx0aGlzPT09ZS5yZXBlYXQucHJvdG90eXBlKXJldHVybiBuZXcgZS5yZXBlYXQocixzKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS5yZXBlYXQuY2FsbCh0LHIscyksdH19LCRyKCl7Y29uc3QgdD1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMub2JqZWN0KSxlPXZvaWQgMD09PXRoaXMudGltZXM/XFxcIlxcXCI6XFxcIiwgXFxcIisodGhpcy50aW1lcz49MD90aGlzLnRpbWVzOjApO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXFxcIihcXFwiK3QrZStcXFwiKVxcXCIpfX0sbWV0aG9kczp7X19sZW5naHRfaGludF9fOnskbWV0aCgpe2lmKHZvaWQgMD09PXRoaXMudGltZXMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJsZW4oKSBvZiB1bnNpemVkIG9iamVjdFxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMudGltZXMpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbH19fSksZS5zdGFybWFwPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnN0YXJtYXBcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBzdGFybWFwKHQsZSl7dGhpcy5mdW5jPXQsdGhpcy5pdGVyPWV9LGl0ZXJuZXh0KHQpe2NvbnN0IGU9dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCk7aWYodm9pZCAwPT09ZSlyZXR1cm47Y29uc3QgaT1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShlKTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMuZnVuYyxpKX0sc2xvdHM6e3RwJG5ldyh0LGkpe2xldCByLHM7aWYoW3Isc109U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcInN0YXJtYXBcXFwiLFtcXFwiZnVuY1xcXCIsXFxcIml0ZXJhYmxlXFxcIl0sdCxpLFtdKSxzPVNrLmFic3RyLml0ZXIocykscj1Tay5idWlsdGluLmNoZWNrTm9uZShyKT9Tay5idWlsdGluLmJvb2w6cix0aGlzPT09ZS5zdGFybWFwLnByb3RvdHlwZSlyZXR1cm4gbmV3IGUuc3Rhcm1hcChyLHMpO3tjb25zdCB0PW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLnN0YXJtYXAuY2FsbCh0LHIscyksdH19fX0pLGUudGFrZXdoaWxlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnRha2V3aGlsZVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHRha2V3aGlsZSh0LGUpe3RoaXMucHJlZGljYXRlPXQsdGhpcy5pdGVyPWV9LGl0ZXJuZXh0KCl7Y29uc3QgdD10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtpZih2b2lkIDAhPT10KXtjb25zdCBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLnByZWRpY2F0ZSxbdF0pO2lmKFNrLm1pc2NldmFsLmlzVHJ1ZShlKSlyZXR1cm4gdDt0aGlzLnRwJGl0ZXJuZXh0PSgpPT57fX19LHNsb3RzOnt0cCRkb2M6XFxcInRha2V3aGlsZShwcmVkaWNhdGUsIGl0ZXJhYmxlKSAtLVxcXFx4M2UgdGFrZXdoaWxlIG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gc3VjY2Vzc2l2ZSBlbnRyaWVzIGZyb20gYW4gaXRlcmFibGUgYXMgbG9uZyBhcyB0aGUgXFxcXG5wcmVkaWNhdGUgZXZhbHVhdGVzIHRvIHRydWUgZm9yIGVhY2ggZW50cnkuXFxcIix0cCRuZXcodCxpKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFxcXCJ0YWtld2hpbGVcXFwiLGkpLFNrLmFic3RyLmNoZWNrQXJnc0xlbihcXFwidGFrZXdoaWxlXFxcIix0LDIsMik7Y29uc3Qgcj10WzBdLHM9U2suYWJzdHIuaXRlcih0WzFdKTtpZih0aGlzPT09ZS50YWtld2hpbGUucHJvdG90eXBlKXJldHVybiBuZXcgZS50YWtld2hpbGUocixzKTt7Y29uc3QgdD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gZS50YWtld2hpbGUuY2FsbCh0LHIscyksdH19fX0pLGUudGVlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidGVlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9KSksZS56aXBfbG9uZ2VzdD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy56aXBfbG9uZ2VzdFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHppcF9sb25nZXN0KHQsZSl7dGhpcy5pdGVycz10LHRoaXMuZmlsbHZhbHVlPWUsdGhpcy5hY3RpdmU9dGhpcy5pdGVycy5sZW5ndGh9LGl0ZXJuZXh0KHQpe2lmKCF0aGlzLmFjdGl2ZSlyZXR1cm47bGV0IGk7Y29uc3Qgcj1bXTtmb3IobGV0IHM9MDtzPHRoaXMuaXRlcnMubGVuZ3RoO3MrKyl7aWYoaT10aGlzLml0ZXJzW3NdLnRwJGl0ZXJuZXh0KCksdm9pZCAwPT09aSl7aWYodGhpcy5hY3RpdmUtLSwhdGhpcy5hY3RpdmUpcmV0dXJuO3RoaXMuaXRlcnNbc109bmV3IGUucmVwZWF0KHRoaXMuZmlsbHZhbHVlKSxpPXRoaXMuZmlsbHZhbHVlfXIucHVzaChpKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUocil9LHNsb3RzOnt0cCRkb2M6XFxcInppcF9sb25nZXN0KGl0ZXIxIFssaXRlcjIgWy4uLl1dLCBbZmlsbHZhbHVlPU5vbmVdKSAtLVxcXFx4M2UgemlwX2xvbmdlc3Qgb2JqZWN0XFxcXG5cXFxcblJldHVybiBhIHppcF9sb25nZXN0IG9iamVjdCB3aG9zZSAuX19uZXh0X18oKSBtZXRob2QgcmV0dXJucyBhIHR1cGxlIHdoZXJlXFxcXG50aGUgaS10aCBlbGVtZW50IGNvbWVzIGZyb20gdGhlIGktdGggaXRlcmFibGUgYXJndW1lbnQuICBUaGUgLl9fbmV4dF9fKClcXFxcbm1ldGhvZCBjb250aW51ZXMgdW50aWwgdGhlIGxvbmdlc3QgaXRlcmFibGUgaW4gdGhlIGFyZ3VtZW50IHNlcXVlbmNlXFxcXG5pcyBleGhhdXN0ZWQgYW5kIHRoZW4gaXQgcmFpc2VzIFN0b3BJdGVyYXRpb24uICBXaGVuIHRoZSBzaG9ydGVyIGl0ZXJhYmxlc1xcXFxuYXJlIGV4aGF1c3RlZCwgdGhlIGZpbGx2YWx1ZSBpcyBzdWJzdGl0dXRlZCBpbiB0aGVpciBwbGFjZS4gIFRoZSBmaWxsdmFsdWVcXFxcbmRlZmF1bHRzIHRvIE5vbmUgb3IgY2FuIGJlIHNwZWNpZmllZCBieSBhIGtleXdvcmQgYXJndW1lbnQuXFxcXG5cXFwiLHRwJG5ldyh0LGkpe2NvbnN0W3JdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJ6aXBfbG9uZ2VzdFxcXCIsW1xcXCJmaWxsdmFsdWVcXFwiXSxbXSxpLFtTay5idWlsdGluLm5vbmUubm9uZSRdKSxzPVtdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXMucHVzaChTay5hYnN0ci5pdGVyKHRbZV0pKTtpZih0aGlzPT09ZS56aXBfbG9uZ2VzdC5wcm90b3R5cGUpcmV0dXJuIG5ldyBlLnppcF9sb25nZXN0KHMscik7e2NvbnN0IHQ9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGUuemlwX2xvbmdlc3QuY2FsbCh0LHMsciksdH19fX0pLGUuX19kb2NfXz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIkFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBweXRob24gaXRlcnRvb2xzIG1vZHVsZSBpbiBTa3VscHRcXFwiKSxlLl9fcGFja2FnZV9fPW5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIiksZX07XCIsXCJzcmMvbGliL2pzb24vX19pbml0X18uanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbih0KXtcXFwidXNlIHN0cmljdFxcXCI7dmFyIGU9e30sZHVtcHNfZj1mdW5jdGlvbih0KXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJkdW1wc1xcXCIsYXJndW1lbnRzLDEsMS8wLCEwLCExKTt2YXIgZSxuLGksdT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksZj1uZXcgU2suYnVpbHRpbnMuZGljdCh0KSxhPSExO3JldHVybiBlPXthc2NpaTohMCxzZXBhcmF0b3JzOntpdGVtX3NlcGFyYXRvcjpcXFwiLCBcXFwiLGtleV9zZXBhcmF0b3I6XFxcIjogXFxcIn19LGY9U2suZmZpLnJlbWFwVG9KcyhmKSxuPVNrLmZmaS5yZW1hcFRvSnModVswXSksXFxcImJvb2xlYW5cXFwiPT10eXBlb2YgZi5lbnN1cmVfYXNjaWkmJiExPT09Zi5lbnN1cmVfYXNjaWkmJihlLmFzY2lpPSExKSxcXFwiYm9vbGVhblxcXCI9PXR5cGVvZiBmLnNvcnRfa2V5cyYmZi5zb3J0X2tleXMmJihhPSEwKSxhfHwoZS5jbXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMH0pLFxcXCJvYmplY3RcXFwiPT10eXBlb2YgZi5zZXBhcmF0b3JzJiYyPT1mLnNlcGFyYXRvcnMubGVuZ3RoJiYoZS5zZXBhcmF0b3JzLml0ZW1fc2VwYXJhdG9yPWYuc2VwYXJhdG9yc1swXSxlLnNlcGFyYXRvcnMua2V5X3NlcGFyYXRvcj1mLnNlcGFyYXRvcnNbMV0pLGYuaW5kZW50JiYoZS5zcGFjZT1mLmluZGVudCksZi5kZWZhdWx0LGk9c3RyaW5naWZ5KG4sZSksbmV3IFNrLmJ1aWx0aW4uc3RyKGkpfTtkdW1wc19mLmNvX2t3YXJncz0hMCxlLmR1bXBzPW5ldyBTay5idWlsdGluLmZ1bmMoZHVtcHNfZik7dmFyIGxvYWRzX2Y9ZnVuY3Rpb24odCl7U2suYnVpbHRpbi5weUNoZWNrQXJncyhcXFwibG9hZHNcXFwiLGFyZ3VtZW50cywxLDEvMCwhMCwhMSk7dmFyIGUsbixpPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSx1PW5ldyBTay5idWlsdGlucy5kaWN0KHQpO3JldHVybiB1PVNrLmZmaS5yZW1hcFRvSnModSksZT1pWzBdLnYsbj1KU09OLnBhcnNlKGUpLFNrLmZmaS5yZW1hcFRvUHkobil9O3JldHVybiBsb2Fkc19mLmNvX2t3YXJncz0hMCxlLmxvYWRzPW5ldyBTay5idWlsdGluLmZ1bmMobG9hZHNfZiksZX07IWZ1bmN0aW9uIHIodCxlLG4pe2Z1bmN0aW9uIG8odSxmKXtpZighZVt1XSl7aWYoIXRbdV0pe3ZhciBhPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZhKXJldHVybiBhKHUsITApO2lmKGkpcmV0dXJuIGkodSwhMCk7dmFyIHM9bmV3IEVycm9yKFxcXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1xcXCIrdStcXFwiJ1xcXCIpO3Rocm93IHMuY29kZT1cXFwiTU9EVUxFX05PVF9GT1VORFxcXCIsc312YXIgYz1lW3VdPXtleHBvcnRzOnt9fTt0W3VdWzBdLmNhbGwoYy5leHBvcnRzLChmdW5jdGlvbihlKXtyZXR1cm4gbyh0W3VdWzFdW2VdfHxlKX0pLGMsYy5leHBvcnRzLHIsdCxlLG4pfXJldHVybiBlW3VdLmV4cG9ydHN9Zm9yKHZhciBpPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHU9MDt1PG4ubGVuZ3RoO3UrKylvKG5bdV0pO3JldHVybiBvfSh7MTpbZnVuY3Rpb24odCxlLG4pe3ZhciBpPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgSlNPTj9KU09OOnQoXFxcImpzb25pZnlcXFwiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSksXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGUmJihlPXtjbXA6ZX0pO3ZhciBuLGE9ZS5jbXAmJihuPWUuY21wLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLGkpe3ZhciB1PXtrZXk6ZSx2YWx1ZTp0W2VdfSxmPXtrZXk6aSx2YWx1ZTp0W2ldfTtyZXR1cm4gbih1LGYpfX0pO3JldHVybiBmdW5jdGlvbiBzdHJpbmdpZnkodCl7aWYoXFxcIm9iamVjdFxcXCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm4gaS5zdHJpbmdpZnkodCk7aWYodSh0KSl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rKyllLnB1c2goc3RyaW5naWZ5KHRbbl0pKTtyZXR1cm5cXFwiW1xcXCIrZS5qb2luKFxcXCIsXFxcIikrXFxcIl1cXFwifXZhciBzPWYodCkuc29ydChhJiZhKHQpKTtmb3IoZT1bXSxuPTA7bjxzLmxlbmd0aDtuKyspe3ZhciBjPXNbbl07ZS5wdXNoKHN0cmluZ2lmeShjKStcXFwiOlxcXCIrc3RyaW5naWZ5KHRbY10pKX1yZXR1cm5cXFwie1xcXCIrZS5qb2luKFxcXCIsXFxcIikrXFxcIn1cXFwifSh0KX07dmFyIHU9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24odCl7cmV0dXJuXFxcIltvYmplY3QgQXJyYXldXFxcIj09PXt9LnRvU3RyaW5nLmNhbGwodCl9LGY9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHl8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LG49W107Zm9yKHZhciBpIGluIHQpZS5jYWxsKHQsaSkmJm4ucHVzaChpKTtyZXR1cm4gbn19LHtqc29uaWZ5OjJ9XSwyOltmdW5jdGlvbih0LGUsbil7bi5wYXJzZT10KFxcXCIuL2xpYi9wYXJzZVxcXCIpLG4uc3RyaW5naWZ5PXQoXFxcIi4vbGliL3N0cmluZ2lmeVxcXCIpfSx7XFxcIi4vbGliL3BhcnNlXFxcIjozLFxcXCIuL2xpYi9zdHJpbmdpZnlcXFwiOjR9XSwzOltmdW5jdGlvbih0LGUsbil7dmFyIGksdSxmLGEscz17J1xcXCInOidcXFwiJyxcXFwiXFxcXFxcXFxcXFwiOlxcXCJcXFxcXFxcXFxcXCIsXFxcIi9cXFwiOlxcXCIvXFxcIixiOlxcXCJcXFxcYlxcXCIsZjpcXFwiXFxcXGZcXFwiLG46XFxcIlxcXFxuXFxcIixyOlxcXCJcXFxcclxcXCIsdDpcXFwiXFxcXHRcXFwifSxlcnJvcj1mdW5jdGlvbih0KXt0aHJvd3tuYW1lOlxcXCJTeW50YXhFcnJvclxcXCIsbWVzc2FnZTp0LGF0OmksdGV4dDpmfX0sbmV4dD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdCE9PXUmJmVycm9yKFxcXCJFeHBlY3RlZCAnXFxcIit0K1xcXCInIGluc3RlYWQgb2YgJ1xcXCIrdStcXFwiJ1xcXCIpLHU9Zi5jaGFyQXQoaSksaSs9MSx1fSxudW1iZXI9ZnVuY3Rpb24oKXt2YXIgdCxlPVxcXCJcXFwiO2ZvcihcXFwiLVxcXCI9PT11JiYoZT1cXFwiLVxcXCIsbmV4dChcXFwiLVxcXCIpKTt1Pj1cXFwiMFxcXCImJnU8PVxcXCI5XFxcIjspZSs9dSxuZXh0KCk7aWYoXFxcIi5cXFwiPT09dSlmb3IoZSs9XFxcIi5cXFwiO25leHQoKSYmdT49XFxcIjBcXFwiJiZ1PD1cXFwiOVxcXCI7KWUrPXU7aWYoXFxcImVcXFwiPT09dXx8XFxcIkVcXFwiPT09dSlmb3IoZSs9dSxuZXh0KCksXFxcIi1cXFwiIT09dSYmXFxcIitcXFwiIT09dXx8KGUrPXUsbmV4dCgpKTt1Pj1cXFwiMFxcXCImJnU8PVxcXCI5XFxcIjspZSs9dSxuZXh0KCk7aWYodD0rZSxpc0Zpbml0ZSh0KSlyZXR1cm4gdDtlcnJvcihcXFwiQmFkIG51bWJlclxcXCIpfSxzdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdCxlLG4saT1cXFwiXFxcIjtpZignXFxcIic9PT11KWZvcig7bmV4dCgpOyl7aWYoJ1xcXCInPT09dSlyZXR1cm4gbmV4dCgpLGk7aWYoXFxcIlxcXFxcXFxcXFxcIj09PXUpaWYobmV4dCgpLFxcXCJ1XFxcIj09PXUpe2ZvcihuPTAsZT0wO2U8NCYmKHQ9cGFyc2VJbnQobmV4dCgpLDE2KSxpc0Zpbml0ZSh0KSk7ZSs9MSluPTE2Km4rdDtpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pfWVsc2V7aWYoXFxcInN0cmluZ1xcXCIhPXR5cGVvZiBzW3VdKWJyZWFrO2krPXNbdV19ZWxzZSBpKz11fWVycm9yKFxcXCJCYWQgc3RyaW5nXFxcIil9LHdoaXRlPWZ1bmN0aW9uKCl7Zm9yKDt1JiZ1PD1cXFwiIFxcXCI7KW5leHQoKX07YT1mdW5jdGlvbigpe3N3aXRjaCh3aGl0ZSgpLHUpe2Nhc2VcXFwie1xcXCI6cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQsZT17fTtpZihcXFwie1xcXCI9PT11KXtpZihuZXh0KFxcXCJ7XFxcIiksd2hpdGUoKSxcXFwifVxcXCI9PT11KXJldHVybiBuZXh0KFxcXCJ9XFxcIiksZTtmb3IoO3U7KXtpZih0PXN0cmluZygpLHdoaXRlKCksbmV4dChcXFwiOlxcXCIpLE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJmVycm9yKCdEdXBsaWNhdGUga2V5IFxcXCInK3QrJ1xcXCInKSxlW3RdPWEoKSx3aGl0ZSgpLFxcXCJ9XFxcIj09PXUpcmV0dXJuIG5leHQoXFxcIn1cXFwiKSxlO25leHQoXFxcIixcXFwiKSx3aGl0ZSgpfX1lcnJvcihcXFwiQmFkIG9iamVjdFxcXCIpfSgpO2Nhc2VcXFwiW1xcXCI6cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9W107aWYoXFxcIltcXFwiPT09dSl7aWYobmV4dChcXFwiW1xcXCIpLHdoaXRlKCksXFxcIl1cXFwiPT09dSlyZXR1cm4gbmV4dChcXFwiXVxcXCIpLHQ7Zm9yKDt1Oyl7aWYodC5wdXNoKGEoKSksd2hpdGUoKSxcXFwiXVxcXCI9PT11KXJldHVybiBuZXh0KFxcXCJdXFxcIiksdDtuZXh0KFxcXCIsXFxcIiksd2hpdGUoKX19ZXJyb3IoXFxcIkJhZCBhcnJheVxcXCIpfSgpO2Nhc2UnXFxcIic6cmV0dXJuIHN0cmluZygpO2Nhc2VcXFwiLVxcXCI6cmV0dXJuIG51bWJlcigpO2RlZmF1bHQ6cmV0dXJuIHU+PVxcXCIwXFxcIiYmdTw9XFxcIjlcXFwiP251bWJlcigpOmZ1bmN0aW9uKCl7c3dpdGNoKHUpe2Nhc2VcXFwidFxcXCI6cmV0dXJuIG5leHQoXFxcInRcXFwiKSxuZXh0KFxcXCJyXFxcIiksbmV4dChcXFwidVxcXCIpLG5leHQoXFxcImVcXFwiKSwhMDtjYXNlXFxcImZcXFwiOnJldHVybiBuZXh0KFxcXCJmXFxcIiksbmV4dChcXFwiYVxcXCIpLG5leHQoXFxcImxcXFwiKSxuZXh0KFxcXCJzXFxcIiksbmV4dChcXFwiZVxcXCIpLCExO2Nhc2VcXFwiblxcXCI6cmV0dXJuIG5leHQoXFxcIm5cXFwiKSxuZXh0KFxcXCJ1XFxcIiksbmV4dChcXFwibFxcXCIpLG5leHQoXFxcImxcXFwiKSxudWxsfWVycm9yKFxcXCJVbmV4cGVjdGVkICdcXFwiK3UrXFxcIidcXFwiKX0oKX19LGUuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuO3JldHVybiBmPXQsaT0wLHU9XFxcIiBcXFwiLG49YSgpLHdoaXRlKCksdSYmZXJyb3IoXFxcIlN5bnRheCBlcnJvclxcXCIpLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlP2Z1bmN0aW9uIHdhbGsodCxuKXt2YXIgaSx1LGY9dFtuXTtpZihmJiZcXFwib2JqZWN0XFxcIj09dHlwZW9mIGYpZm9yKGkgaW4gZilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZixpKSYmKHZvaWQgMCE9PSh1PXdhbGsoZixpKSk/ZltpXT11OmRlbGV0ZSBmW2ldKTtyZXR1cm4gZS5jYWxsKHQsbixmKX0oe1xcXCJcXFwiOm59LFxcXCJcXFwiKTpufX0se31dLDQ6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgaSx1LGYsYT0vW1xcXFxcXFxcXFxcXFxcXCJcXFxceDAwLVxcXFx4MWZcXFxceDdmLVxcXFx4OWZcXFxcdTAwYWRcXFxcdTA2MDAtXFxcXHUwNjA0XFxcXHUwNzBmXFxcXHUxN2I0XFxcXHUxN2I1XFxcXHUyMDBjLVxcXFx1MjAwZlxcXFx1MjAyOC1cXFxcdTIwMmZcXFxcdTIwNjAtXFxcXHUyMDZmXFxcXHVmZWZmXFxcXHVmZmYwLVxcXFx1ZmZmZl0vZyxzPXtcXFwiXFxcXGJcXFwiOlxcXCJcXFxcXFxcXGJcXFwiLFxcXCJcXFxcdFxcXCI6XFxcIlxcXFxcXFxcdFxcXCIsXFxcIlxcXFxuXFxcIjpcXFwiXFxcXFxcXFxuXFxcIixcXFwiXFxcXGZcXFwiOlxcXCJcXFxcXFxcXGZcXFwiLFxcXCJcXFxcclxcXCI6XFxcIlxcXFxcXFxcclxcXCIsJ1xcXCInOidcXFxcXFxcXFxcXCInLFxcXCJcXFxcXFxcXFxcXCI6XFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwifTtmdW5jdGlvbiBxdW90ZSh0KXtyZXR1cm4gYS5sYXN0SW5kZXg9MCxhLnRlc3QodCk/J1xcXCInK3QucmVwbGFjZShhLChmdW5jdGlvbih0KXt2YXIgZT1zW3RdO3JldHVyblxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZT9lOlxcXCJcXFxcXFxcXHVcXFwiKyhcXFwiMDAwMFxcXCIrdC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpfSkpKydcXFwiJzonXFxcIicrdCsnXFxcIid9ZnVuY3Rpb24gc3RyKHQsZSl7dmFyIG4sYSxzLGMsbCxwPWkseT1lW3RdO3N3aXRjaCh5JiZcXFwib2JqZWN0XFxcIj09dHlwZW9mIHkmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB5LnRvSlNPTiYmKHk9eS50b0pTT04odCkpLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBmJiYoeT1mLmNhbGwoZSx0LHkpKSx0eXBlb2YgeSl7Y2FzZVxcXCJzdHJpbmdcXFwiOnJldHVybiBxdW90ZSh5KTtjYXNlXFxcIm51bWJlclxcXCI6cmV0dXJuIGlzRmluaXRlKHkpP1N0cmluZyh5KTpcXFwibnVsbFxcXCI7Y2FzZVxcXCJib29sZWFuXFxcIjpjYXNlXFxcIm51bGxcXFwiOnJldHVybiBTdHJpbmcoeSk7Y2FzZVxcXCJvYmplY3RcXFwiOmlmKCF5KXJldHVyblxcXCJudWxsXFxcIjtpZihpKz11LGw9W10sXFxcIltvYmplY3QgQXJyYXldXFxcIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoeSkpe2ZvcihjPXkubGVuZ3RoLG49MDtuPGM7bis9MSlsW25dPXN0cihuLHkpfHxcXFwibnVsbFxcXCI7cmV0dXJuIHM9MD09PWwubGVuZ3RoP1xcXCJbXVxcXCI6aT9cXFwiW1xcXFxuXFxcIitpK2wuam9pbihcXFwiLFxcXFxuXFxcIitpKStcXFwiXFxcXG5cXFwiK3ArXFxcIl1cXFwiOlxcXCJbXFxcIitsLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCIsaT1wLHN9aWYoZiYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBmKWZvcihjPWYubGVuZ3RoLG49MDtuPGM7bis9MSlcXFwic3RyaW5nXFxcIj09dHlwZW9mKGE9ZltuXSkmJihzPXN0cihhLHkpKSYmbC5wdXNoKHF1b3RlKGEpKyhpP1xcXCI6IFxcXCI6XFxcIjpcXFwiKStzKTtlbHNlIGZvcihhIGluIHkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHksYSkmJihzPXN0cihhLHkpKSYmbC5wdXNoKHF1b3RlKGEpKyhpP1xcXCI6IFxcXCI6XFxcIjpcXFwiKStzKTtyZXR1cm4gcz0wPT09bC5sZW5ndGg/XFxcInt9XFxcIjppP1xcXCJ7XFxcXG5cXFwiK2krbC5qb2luKFxcXCIsXFxcXG5cXFwiK2kpK1xcXCJcXFxcblxcXCIrcCtcXFwifVxcXCI6XFxcIntcXFwiK2wuam9pbihcXFwiLFxcXCIpK1xcXCJ9XFxcIixpPXAsc319ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgYTtpZihpPVxcXCJcXFwiLHU9XFxcIlxcXCIsXFxcIm51bWJlclxcXCI9PXR5cGVvZiBuKWZvcihhPTA7YTxuO2ErPTEpdSs9XFxcIiBcXFwiO2Vsc2VcXFwic3RyaW5nXFxcIj09dHlwZW9mIG4mJih1PW4pO2lmKGY9ZSxlJiZcXFwiZnVuY3Rpb25cXFwiIT10eXBlb2YgZSYmKFxcXCJvYmplY3RcXFwiIT10eXBlb2YgZXx8XFxcIm51bWJlclxcXCIhPXR5cGVvZiBlLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFxcXCJKU09OLnN0cmluZ2lmeVxcXCIpO3JldHVybiBzdHIoXFxcIlxcXCIse1xcXCJcXFwiOnR9KX19LHt9XSw1OltmdW5jdGlvbih0LGUsbil7dmFyIGksdSxmPWUuZXhwb3J0cz17fTtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFxcXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXFxcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcXFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXFxcIil9ZnVuY3Rpb24gcnVuVGltZW91dCh0KXtpZihpPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dCh0LDApO2lmKChpPT09ZGVmYXVsdFNldFRpbW91dHx8IWkpJiZzZXRUaW1lb3V0KXJldHVybiBpPXNldFRpbWVvdXQsc2V0VGltZW91dCh0LDApO3RyeXtyZXR1cm4gaSh0LDApfWNhdGNoKGUpe3RyeXtyZXR1cm4gaS5jYWxsKG51bGwsdCwwKX1jYXRjaChlKXtyZXR1cm4gaS5jYWxsKHRoaXMsdCwwKX19fSFmdW5jdGlvbigpe3RyeXtpPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6ZGVmYXVsdFNldFRpbW91dH1jYXRjaCh0KXtpPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e3U9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6ZGVmYXVsdENsZWFyVGltZW91dH1jYXRjaCh0KXt1PWRlZmF1bHRDbGVhclRpbWVvdXR9fSgpO3ZhciBhLHM9W10sYz0hMSxsPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2MmJmEmJihjPSExLGEubGVuZ3RoP3M9YS5jb25jYXQocyk6bD0tMSxzLmxlbmd0aCYmZHJhaW5RdWV1ZSgpKX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYoIWMpe3ZhciB0PXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtjPSEwO2Zvcih2YXIgZT1zLmxlbmd0aDtlOyl7Zm9yKGE9cyxzPVtdOysrbDxlOylhJiZhW2xdLnJ1bigpO2w9LTEsZT1zLmxlbmd0aH1hPW51bGwsYz0hMSxmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQodCl7aWYodT09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHQpO2lmKCh1PT09ZGVmYXVsdENsZWFyVGltZW91dHx8IXUpJiZjbGVhclRpbWVvdXQpcmV0dXJuIHU9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dCh0KTt0cnl7cmV0dXJuIHUodCl9Y2F0Y2goZSl7dHJ5e3JldHVybiB1LmNhbGwobnVsbCx0KX1jYXRjaChlKXtyZXR1cm4gdS5jYWxsKHRoaXMsdCl9fX0odCl9fWZ1bmN0aW9uIEl0ZW0odCxlKXt0aGlzLmZ1bj10LHRoaXMuYXJyYXk9ZX1mdW5jdGlvbiBub29wKCl7fWYubmV4dFRpY2s9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspZVtuLTFdPWFyZ3VtZW50c1tuXTtzLnB1c2gobmV3IEl0ZW0odCxlKSksMSE9PXMubGVuZ3RofHxjfHxydW5UaW1lb3V0KGRyYWluUXVldWUpfSxJdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSxmLnRpdGxlPVxcXCJicm93c2VyXFxcIixmLmJyb3dzZXI9ITAsZi5lbnY9e30sZi5hcmd2PVtdLGYudmVyc2lvbj1cXFwiXFxcIixmLnZlcnNpb25zPXt9LGYub249bm9vcCxmLmFkZExpc3RlbmVyPW5vb3AsZi5vbmNlPW5vb3AsZi5vZmY9bm9vcCxmLnJlbW92ZUxpc3RlbmVyPW5vb3AsZi5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcCxmLmVtaXQ9bm9vcCxmLnByZXBlbmRMaXN0ZW5lcj1ub29wLGYucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wLGYubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybltdfSxmLmJpbmRpbmc9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFxcXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFxcXCIpfSxmLmN3ZD1mdW5jdGlvbigpe3JldHVyblxcXCIvXFxcIn0sZi5jaGRpcj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXFxcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFxcXCIpfSxmLnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSx7fV0sNjpbZnVuY3Rpb24odCxlLG4peyhmdW5jdGlvbihuKXt2YXIgaT10KFxcXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcXFwiKTtuLmJyb3dzZXI/d2luZG93LnN0cmluZ2lmeT1pOmUuZXhwb3J0cz1pfSkuY2FsbCh0aGlzLHQoXFxcIl9wcm9jZXNzXFxcIikpfSx7X3Byb2Nlc3M6NSxcXFwianNvbi1zdGFibGUtc3RyaW5naWZ5XFxcIjoxfV19LHt9LFs2XSk7XCIsXCJzcmMvbGliL2pzb24vc3RyaW5naWZ5LmpzXCI6XCIhZnVuY3Rpb24gcih0LGUsbil7ZnVuY3Rpb24gbyh1LGYpe2lmKCFlW3VdKXtpZighdFt1XSl7dmFyIGM9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGModSwhMCk7aWYoaSlyZXR1cm4gaSh1LCEwKTt2YXIgYT1uZXcgRXJyb3IoXFxcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXFxcIit1K1xcXCInXFxcIik7dGhyb3cgYS5jb2RlPVxcXCJNT0RVTEVfTk9UX0ZPVU5EXFxcIixhfXZhciBzPWVbdV09e2V4cG9ydHM6e319O3RbdV1bMF0uY2FsbChzLmV4cG9ydHMsKGZ1bmN0aW9uKGUpe3JldHVybiBvKHRbdV1bMV1bZV18fGUpfSkscyxzLmV4cG9ydHMscix0LGUsbil9cmV0dXJuIGVbdV0uZXhwb3J0c31mb3IodmFyIGk9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsdT0wO3U8bi5sZW5ndGg7dSsrKW8oblt1XSk7cmV0dXJuIG99KHsxOltmdW5jdGlvbih0LGUsbil7dmFyIGk9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBKU09OP0pTT046dChcXFwianNvbmlmeVxcXCIpO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2V8fChlPXt9KSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKGU9e2NtcDplfSk7dmFyIG4sYz1lLmNtcCYmKG49ZS5jbXAsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHU9e2tleTplLHZhbHVlOnRbZV19LGY9e2tleTppLHZhbHVlOnRbaV19O3JldHVybiBuKHUsZil9fSk7cmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeSh0KXtpZihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVybiBpLnN0cmluZ2lmeSh0KTtpZih1KHQpKXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bisrKWUucHVzaChzdHJpbmdpZnkodFtuXSkpO3JldHVyblxcXCJbXFxcIitlLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCJ9dmFyIGE9Zih0KS5zb3J0KGMmJmModCkpO2ZvcihlPVtdLG49MDtuPGEubGVuZ3RoO24rKyl7dmFyIHM9YVtuXTtlLnB1c2goc3RyaW5naWZ5KHMpK1xcXCI6XFxcIitzdHJpbmdpZnkodFtzXSkpfXJldHVyblxcXCJ7XFxcIitlLmpvaW4oXFxcIixcXFwiKStcXFwifVxcXCJ9KHQpfTt2YXIgdT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cXFwiW29iamVjdCBBcnJheV1cXFwiPT09e30udG9TdHJpbmcuY2FsbCh0KX0sZj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odCl7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbj1bXTtmb3IodmFyIGkgaW4gdCllLmNhbGwodCxpKSYmbi5wdXNoKGkpO3JldHVybiBufX0se2pzb25pZnk6Mn1dLDI6W2Z1bmN0aW9uKHQsZSxuKXtuLnBhcnNlPXQoXFxcIi4vbGliL3BhcnNlXFxcIiksbi5zdHJpbmdpZnk9dChcXFwiLi9saWIvc3RyaW5naWZ5XFxcIil9LHtcXFwiLi9saWIvcGFyc2VcXFwiOjMsXFxcIi4vbGliL3N0cmluZ2lmeVxcXCI6NH1dLDM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgaSx1LGYsYyxhPXsnXFxcIic6J1xcXCInLFxcXCJcXFxcXFxcXFxcXCI6XFxcIlxcXFxcXFxcXFxcIixcXFwiL1xcXCI6XFxcIi9cXFwiLGI6XFxcIlxcXFxiXFxcIixmOlxcXCJcXFxcZlxcXCIsbjpcXFwiXFxcXG5cXFwiLHI6XFxcIlxcXFxyXFxcIix0OlxcXCJcXFxcdFxcXCJ9LGVycm9yPWZ1bmN0aW9uKHQpe3Rocm93e25hbWU6XFxcIlN5bnRheEVycm9yXFxcIixtZXNzYWdlOnQsYXQ6aSx0ZXh0OmZ9fSxuZXh0PWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0IT09dSYmZXJyb3IoXFxcIkV4cGVjdGVkICdcXFwiK3QrXFxcIicgaW5zdGVhZCBvZiAnXFxcIit1K1xcXCInXFxcIiksdT1mLmNoYXJBdChpKSxpKz0xLHV9LG51bWJlcj1mdW5jdGlvbigpe3ZhciB0LGU9XFxcIlxcXCI7Zm9yKFxcXCItXFxcIj09PXUmJihlPVxcXCItXFxcIixuZXh0KFxcXCItXFxcIikpO3U+PVxcXCIwXFxcIiYmdTw9XFxcIjlcXFwiOyllKz11LG5leHQoKTtpZihcXFwiLlxcXCI9PT11KWZvcihlKz1cXFwiLlxcXCI7bmV4dCgpJiZ1Pj1cXFwiMFxcXCImJnU8PVxcXCI5XFxcIjspZSs9dTtpZihcXFwiZVxcXCI9PT11fHxcXFwiRVxcXCI9PT11KWZvcihlKz11LG5leHQoKSxcXFwiLVxcXCIhPT11JiZcXFwiK1xcXCIhPT11fHwoZSs9dSxuZXh0KCkpO3U+PVxcXCIwXFxcIiYmdTw9XFxcIjlcXFwiOyllKz11LG5leHQoKTtpZih0PStlLGlzRmluaXRlKHQpKXJldHVybiB0O2Vycm9yKFxcXCJCYWQgbnVtYmVyXFxcIil9LHN0cmluZz1mdW5jdGlvbigpe3ZhciB0LGUsbixpPVxcXCJcXFwiO2lmKCdcXFwiJz09PXUpZm9yKDtuZXh0KCk7KXtpZignXFxcIic9PT11KXJldHVybiBuZXh0KCksaTtpZihcXFwiXFxcXFxcXFxcXFwiPT09dSlpZihuZXh0KCksXFxcInVcXFwiPT09dSl7Zm9yKG49MCxlPTA7ZTw0JiYodD1wYXJzZUludChuZXh0KCksMTYpLGlzRmluaXRlKHQpKTtlKz0xKW49MTYqbit0O2krPVN0cmluZy5mcm9tQ2hhckNvZGUobil9ZWxzZXtpZihcXFwic3RyaW5nXFxcIiE9dHlwZW9mIGFbdV0pYnJlYWs7aSs9YVt1XX1lbHNlIGkrPXV9ZXJyb3IoXFxcIkJhZCBzdHJpbmdcXFwiKX0sd2hpdGU9ZnVuY3Rpb24oKXtmb3IoO3UmJnU8PVxcXCIgXFxcIjspbmV4dCgpfTtjPWZ1bmN0aW9uKCl7c3dpdGNoKHdoaXRlKCksdSl7Y2FzZVxcXCJ7XFxcIjpyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdCxlPXt9O2lmKFxcXCJ7XFxcIj09PXUpe2lmKG5leHQoXFxcIntcXFwiKSx3aGl0ZSgpLFxcXCJ9XFxcIj09PXUpcmV0dXJuIG5leHQoXFxcIn1cXFwiKSxlO2Zvcig7dTspe2lmKHQ9c3RyaW5nKCksd2hpdGUoKSxuZXh0KFxcXCI6XFxcIiksT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXFxcIicrdCsnXFxcIicpLGVbdF09YygpLHdoaXRlKCksXFxcIn1cXFwiPT09dSlyZXR1cm4gbmV4dChcXFwifVxcXCIpLGU7bmV4dChcXFwiLFxcXCIpLHdoaXRlKCl9fWVycm9yKFxcXCJCYWQgb2JqZWN0XFxcIil9KCk7Y2FzZVxcXCJbXFxcIjpyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1bXTtpZihcXFwiW1xcXCI9PT11KXtpZihuZXh0KFxcXCJbXFxcIiksd2hpdGUoKSxcXFwiXVxcXCI9PT11KXJldHVybiBuZXh0KFxcXCJdXFxcIiksdDtmb3IoO3U7KXtpZih0LnB1c2goYygpKSx3aGl0ZSgpLFxcXCJdXFxcIj09PXUpcmV0dXJuIG5leHQoXFxcIl1cXFwiKSx0O25leHQoXFxcIixcXFwiKSx3aGl0ZSgpfX1lcnJvcihcXFwiQmFkIGFycmF5XFxcIil9KCk7Y2FzZSdcXFwiJzpyZXR1cm4gc3RyaW5nKCk7Y2FzZVxcXCItXFxcIjpyZXR1cm4gbnVtYmVyKCk7ZGVmYXVsdDpyZXR1cm4gdT49XFxcIjBcXFwiJiZ1PD1cXFwiOVxcXCI/bnVtYmVyKCk6ZnVuY3Rpb24oKXtzd2l0Y2godSl7Y2FzZVxcXCJ0XFxcIjpyZXR1cm4gbmV4dChcXFwidFxcXCIpLG5leHQoXFxcInJcXFwiKSxuZXh0KFxcXCJ1XFxcIiksbmV4dChcXFwiZVxcXCIpLCEwO2Nhc2VcXFwiZlxcXCI6cmV0dXJuIG5leHQoXFxcImZcXFwiKSxuZXh0KFxcXCJhXFxcIiksbmV4dChcXFwibFxcXCIpLG5leHQoXFxcInNcXFwiKSxuZXh0KFxcXCJlXFxcIiksITE7Y2FzZVxcXCJuXFxcIjpyZXR1cm4gbmV4dChcXFwiblxcXCIpLG5leHQoXFxcInVcXFwiKSxuZXh0KFxcXCJsXFxcIiksbmV4dChcXFwibFxcXCIpLG51bGx9ZXJyb3IoXFxcIlVuZXhwZWN0ZWQgJ1xcXCIrdStcXFwiJ1xcXCIpfSgpfX0sZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIGY9dCxpPTAsdT1cXFwiIFxcXCIsbj1jKCksd2hpdGUoKSx1JiZlcnJvcihcXFwiU3ludGF4IGVycm9yXFxcIiksXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGU/ZnVuY3Rpb24gd2Fsayh0LG4pe3ZhciBpLHUsZj10W25dO2lmKGYmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgZilmb3IoaSBpbiBmKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLGkpJiYodm9pZCAwIT09KHU9d2FsayhmLGkpKT9mW2ldPXU6ZGVsZXRlIGZbaV0pO3JldHVybiBlLmNhbGwodCxuLGYpfSh7XFxcIlxcXCI6bn0sXFxcIlxcXCIpOm59fSx7fV0sNDpbZnVuY3Rpb24odCxlLG4pe3ZhciBpLHUsZixjPS9bXFxcXFxcXFxcXFxcXFxcIlxcXFx4MDAtXFxcXHgxZlxcXFx4N2YtXFxcXHg5ZlxcXFx1MDBhZFxcXFx1MDYwMC1cXFxcdTA2MDRcXFxcdTA3MGZcXFxcdTE3YjRcXFxcdTE3YjVcXFxcdTIwMGMtXFxcXHUyMDBmXFxcXHUyMDI4LVxcXFx1MjAyZlxcXFx1MjA2MC1cXFxcdTIwNmZcXFxcdWZlZmZcXFxcdWZmZjAtXFxcXHVmZmZmXS9nLGE9e1xcXCJcXFxcYlxcXCI6XFxcIlxcXFxcXFxcYlxcXCIsXFxcIlxcXFx0XFxcIjpcXFwiXFxcXFxcXFx0XFxcIixcXFwiXFxcXG5cXFwiOlxcXCJcXFxcXFxcXG5cXFwiLFxcXCJcXFxcZlxcXCI6XFxcIlxcXFxcXFxcZlxcXCIsXFxcIlxcXFxyXFxcIjpcXFwiXFxcXFxcXFxyXFxcIiwnXFxcIic6J1xcXFxcXFxcXFxcIicsXFxcIlxcXFxcXFxcXFxcIjpcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCJ9O2Z1bmN0aW9uIHF1b3RlKHQpe3JldHVybiBjLmxhc3RJbmRleD0wLGMudGVzdCh0KT8nXFxcIicrdC5yZXBsYWNlKGMsKGZ1bmN0aW9uKHQpe3ZhciBlPWFbdF07cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBlP2U6XFxcIlxcXFxcXFxcdVxcXCIrKFxcXCIwMDAwXFxcIit0LmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9KSkrJ1xcXCInOidcXFwiJyt0KydcXFwiJ31mdW5jdGlvbiBzdHIodCxlKXt2YXIgbixjLGEscyxsLHA9aSx5PWVbdF07c3dpdGNoKHkmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgeSYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHkudG9KU09OJiYoeT15LnRvSlNPTih0KSksXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGYmJih5PWYuY2FsbChlLHQseSkpLHR5cGVvZiB5KXtjYXNlXFxcInN0cmluZ1xcXCI6cmV0dXJuIHF1b3RlKHkpO2Nhc2VcXFwibnVtYmVyXFxcIjpyZXR1cm4gaXNGaW5pdGUoeSk/U3RyaW5nKHkpOlxcXCJudWxsXFxcIjtjYXNlXFxcImJvb2xlYW5cXFwiOmNhc2VcXFwibnVsbFxcXCI6cmV0dXJuIFN0cmluZyh5KTtjYXNlXFxcIm9iamVjdFxcXCI6aWYoIXkpcmV0dXJuXFxcIm51bGxcXFwiO2lmKGkrPXUsbD1bXSxcXFwiW29iamVjdCBBcnJheV1cXFwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh5KSl7Zm9yKHM9eS5sZW5ndGgsbj0wO248cztuKz0xKWxbbl09c3RyKG4seSl8fFxcXCJudWxsXFxcIjtyZXR1cm4gYT0wPT09bC5sZW5ndGg/XFxcIltdXFxcIjppP1xcXCJbXFxcXG5cXFwiK2krbC5qb2luKFxcXCIsXFxcXG5cXFwiK2kpK1xcXCJcXFxcblxcXCIrcCtcXFwiXVxcXCI6XFxcIltcXFwiK2wuam9pbihcXFwiLFxcXCIpK1xcXCJdXFxcIixpPXAsYX1pZihmJiZcXFwib2JqZWN0XFxcIj09dHlwZW9mIGYpZm9yKHM9Zi5sZW5ndGgsbj0wO248cztuKz0xKVxcXCJzdHJpbmdcXFwiPT10eXBlb2YoYz1mW25dKSYmKGE9c3RyKGMseSkpJiZsLnB1c2gocXVvdGUoYykrKGk/XFxcIjogXFxcIjpcXFwiOlxcXCIpK2EpO2Vsc2UgZm9yKGMgaW4geSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSxjKSYmKGE9c3RyKGMseSkpJiZsLnB1c2gocXVvdGUoYykrKGk/XFxcIjogXFxcIjpcXFwiOlxcXCIpK2EpO3JldHVybiBhPTA9PT1sLmxlbmd0aD9cXFwie31cXFwiOmk/XFxcIntcXFxcblxcXCIraStsLmpvaW4oXFxcIixcXFxcblxcXCIraSkrXFxcIlxcXFxuXFxcIitwK1xcXCJ9XFxcIjpcXFwie1xcXCIrbC5qb2luKFxcXCIsXFxcIikrXFxcIn1cXFwiLGk9cCxhfX1lLmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciBjO2lmKGk9XFxcIlxcXCIsdT1cXFwiXFxcIixcXFwibnVtYmVyXFxcIj09dHlwZW9mIG4pZm9yKGM9MDtjPG47Yys9MSl1Kz1cXFwiIFxcXCI7ZWxzZVxcXCJzdHJpbmdcXFwiPT10eXBlb2YgbiYmKHU9bik7aWYoZj1lLGUmJlxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiBlJiYoXFxcIm9iamVjdFxcXCIhPXR5cGVvZiBlfHxcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGUubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXFxcIkpTT04uc3RyaW5naWZ5XFxcIik7cmV0dXJuIHN0cihcXFwiXFxcIix7XFxcIlxcXCI6dH0pfX0se31dLDU6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgaSx1LGY9ZS5leHBvcnRzPXt9O2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXFxcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcXFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFxcXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcXFwiKX1mdW5jdGlvbiBydW5UaW1lb3V0KHQpe2lmKGk9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KHQsMCk7aWYoKGk9PT1kZWZhdWx0U2V0VGltb3V0fHwhaSkmJnNldFRpbWVvdXQpcmV0dXJuIGk9c2V0VGltZW91dCxzZXRUaW1lb3V0KHQsMCk7dHJ5e3JldHVybiBpKHQsMCl9Y2F0Y2goZSl7dHJ5e3JldHVybiBpLmNhbGwobnVsbCx0LDApfWNhdGNoKGUpe3JldHVybiBpLmNhbGwodGhpcyx0LDApfX19IWZ1bmN0aW9uKCl7dHJ5e2k9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpkZWZhdWx0U2V0VGltb3V0fWNhdGNoKHQpe2k9ZGVmYXVsdFNldFRpbW91dH10cnl7dT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDpkZWZhdWx0Q2xlYXJUaW1lb3V0fWNhdGNoKHQpe3U9ZGVmYXVsdENsZWFyVGltZW91dH19KCk7dmFyIGMsYT1bXSxzPSExLGw9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7cyYmYyYmKHM9ITEsYy5sZW5ndGg/YT1jLmNvbmNhdChhKTpsPS0xLGEubGVuZ3RoJiZkcmFpblF1ZXVlKCkpfWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZighcyl7dmFyIHQ9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO3M9ITA7Zm9yKHZhciBlPWEubGVuZ3RoO2U7KXtmb3IoYz1hLGE9W107KytsPGU7KWMmJmNbbF0ucnVuKCk7bD0tMSxlPWEubGVuZ3RofWM9bnVsbCxzPSExLGZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dCh0KXtpZih1PT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQodCk7aWYoKHU9PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhdSkmJmNsZWFyVGltZW91dClyZXR1cm4gdT1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHQpO3RyeXtyZXR1cm4gdSh0KX1jYXRjaChlKXt0cnl7cmV0dXJuIHUuY2FsbChudWxsLHQpfWNhdGNoKGUpe3JldHVybiB1LmNhbGwodGhpcyx0KX19fSh0KX19ZnVuY3Rpb24gSXRlbSh0LGUpe3RoaXMuZnVuPXQsdGhpcy5hcnJheT1lfWZ1bmN0aW9uIG5vb3AoKXt9Zi5uZXh0VGljaz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyllW24tMV09YXJndW1lbnRzW25dO2EucHVzaChuZXcgSXRlbSh0LGUpKSwxIT09YS5sZW5ndGh8fHN8fHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSl9LEl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LGYudGl0bGU9XFxcImJyb3dzZXJcXFwiLGYuYnJvd3Nlcj0hMCxmLmVudj17fSxmLmFyZ3Y9W10sZi52ZXJzaW9uPVxcXCJcXFwiLGYudmVyc2lvbnM9e30sZi5vbj1ub29wLGYuYWRkTGlzdGVuZXI9bm9vcCxmLm9uY2U9bm9vcCxmLm9mZj1ub29wLGYucmVtb3ZlTGlzdGVuZXI9bm9vcCxmLnJlbW92ZUFsbExpc3RlbmVycz1ub29wLGYuZW1pdD1ub29wLGYucHJlcGVuZExpc3RlbmVyPW5vb3AsZi5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3AsZi5saXN0ZW5lcnM9ZnVuY3Rpb24odCl7cmV0dXJuW119LGYuYmluZGluZz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXFxcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXFxcIil9LGYuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXFxcIi9cXFwifSxmLmNoZGlyPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcXFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXFxcIil9LGYudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LHt9XSw2OltmdW5jdGlvbih0LGUsbil7KGZ1bmN0aW9uKG4pe3ZhciBpPXQoXFxcImpzb24tc3RhYmxlLXN0cmluZ2lmeVxcXCIpO24uYnJvd3Nlcj93aW5kb3cuc3RyaW5naWZ5PWk6ZS5leHBvcnRzPWl9KS5jYWxsKHRoaXMsdChcXFwiX3Byb2Nlc3NcXFwiKSl9LHtfcHJvY2Vzczo1LFxcXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcXFwiOjF9XX0se30sWzZdKTtcIixcInNyYy9saWIvanNvbi5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUoKXtjb25zdHtidWlsdGluOntzdHI6ZSxmbG9hdF86dCxsaXN0Om4sdHVwbGU6cixkaWN0Om8sZnVuYzpzLFR5cGVFcnJvcjppLFZhbHVlRXJyb3I6bCxOb3RJbXBsZW1lbnRlZEVycm9yOmEsc29ydGVkOmMsbm9uZTp7bm9uZSQ6dX0sYm9vbDp7dHJ1ZSQ6aCxmYWxzZSQ6ZH0sY2hlY2tTdHJpbmc6ZixjaGVja0J5dGVzOnB9LGZmaTp7dG9QeTpnLHRvSnM6bSx0b1B5RmxvYXQ6dyx0b1B5SW50Ol8saXNUcnVlOmJ9LGFic3RyOnt0eXBlTmFtZTp5LGJ1aWxkTmF0aXZlQ2xhc3M6TixjaGVja09uZUFyZzpPLHNldFVwTW9kdWxlTWV0aG9kczprLGNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzOlN9LG1pc2NldmFsOntvYmplY3RSZXByOkosY2FsbHNpbUFycmF5OiR9fT1TayxFPXtfX25hbWVfXzpuZXcgZShcXFwianNvblxcXCIpLF9fYWxsX186ZyhbXFxcImR1bXBcXFwiLFxcXCJkdW1wc1xcXCIsXFxcImxvYWRcXFwiLFxcXCJsb2Fkc1xcXCIsXFxcIkpTT05EZWNvZGVyXFxcIixcXFwiSlNPTkRlY29kZUVycm9yXFxcIixcXFwiSlNPTkVuY29kZXJcXFwiXSksZHVtcDpwcm94eUZhaWwoXFxcImR1bXBcXFwiKSxsb2FkOnByb3h5RmFpbChcXFwibG9hZFxcXCIpLEpTT05EZWNvZGVyOnByb3h5RmFpbChcXFwiSlNPTkRlY29kZXJcXFwiKSxKU09ORW5jb2Rlcjpwcm94eUZhaWwoXFxcIkpTT05FbmNvZGVyXFxcIil9O2Z1bmN0aW9uIHByb3h5RmFpbChlKXtyZXR1cm4gbmV3IHMoKCgpPT57dGhyb3cgbmV3IGEoZStcXFwiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gc2t1bHB0XFxcIil9KSl9Y29uc3Qgaj1FLkpTT05EZWNvZGVFcnJvcj1OKFxcXCJqc29uLkpTT05EZWNvZGVFcnJvclxcXCIse2Jhc2U6bCxjb25zdHJ1Y3RvcjpmdW5jdGlvbiBKU09ORGVjb2RlRXJyb3IoZSx0LG4pe2NvbnN0IHI9dC5zbGljZSgwLG4pLG89ci5zcGxpdChcXFwiXFxcXG5cXFwiKS5sZW5ndGgscz1uLXIubGFzdEluZGV4T2YoXFxcIlxcXFxuXFxcIiksaT1gJHtlfTogbGluZSAke299IGNvbHVtbiAke3N9IChjaGFyICR7bn0pYDtsLmNhbGwodGhpcyxpKSx0aGlzLiRtc2c9ZSx0aGlzLiRkb2M9dCx0aGlzLiRwb3M9bix0aGlzLiRsaW5lbm89byx0aGlzLiRjb2xubz1zfSxnZXRzZXRzOk9iamVjdC5mcm9tRW50cmllcyhbXFxcIm1zZ1xcXCIsXFxcImRvY1xcXCIsXFxcInBvc1xcXCIsXFxcImxpbmVub1xcXCIsXFxcImNvbG5vXFxcIl0ubWFwKChlPT5bZSx7JGdldCgpe3JldHVybiBnKHRoaXNbXFxcIiRcXFwiK2VdKX19XSkpKX0pO2NsYXNzIEpTT05FbmNvZGVye2NvbnN0cnVjdG9yKGUsdCxuLHIsbyxzLGksbCl7dGhpcy5za2lwa2V5cz1lLHRoaXMuZW5zdXJlX2FzY2lpPXQsdGhpcy5jaGVja19jaXJjdWxhcj1uLHRoaXMuYWxsb3dfbmFuPXIsdGhpcy5pbmRlbnQ9byx0aGlzLnNlcGFyYXRvcnM9cyx0aGlzLnNvcnRfa2V5cz1sLHRoaXMuaXRlbV9zZXBhcmF0b3I9XFxcIiwgXFxcIix0aGlzLmtleV9zZXBhcmF0b3I9XFxcIjogXFxcIixudWxsIT09dGhpcy5zZXBhcmF0b3JzP1t0aGlzLml0ZW1fc2VwYXJhdG9yLHRoaXMua2V5X3NlcGFyYXRvcl09dGhpcy5zZXBhcmF0b3JzOm51bGwhPT10aGlzLmluZGVudCYmKHRoaXMuaXRlbV9zZXBhcmF0b3I9XFxcIixcXFwiKSxudWxsIT09aSYmKHRoaXMuZGVmYXVsdD1pKSx0aGlzLmVuY29kZXI9dGhpcy5tYWtlX2VuY29kZXIoKX1kZWZhdWx0KGUpe3Rocm93IG5ldyBpKGBPYmplY3Qgb2YgdHlwZSAke3koZSl9IGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZWApfWVuY29kZSh0KXtyZXR1cm4gbmV3IGUodGhpcy5lbmNvZGVyKHQpKX1tYWtlX2VuY29kZXIoKXtsZXQgZSx0O2U9dGhpcy5jaGVja19jaXJjdWxhcj9uZXcgU2V0Om51bGwsdD0odGhpcy5lbnN1cmVfYXNjaWksSlNPTi5zdHJpbmdpZnkpO3JldHVybiBmdW5jdGlvbiBfbWFrZV9pdGVyZW5jb2RlKGUsdCxuLHIscyxhLHUsaCxkKXtudWxsIT09ciYmXFxcInN0cmluZ1xcXCIhPXR5cGVvZiByJiYocj1cXFwiIFxcXCIucmVwZWF0KHIpKTtsZXQgZixwLGcsdztudWxsIT09ZT8oZj10PT57aWYoZS5oYXModCkpdGhyb3cgbmV3IGwoXFxcIkNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZFxcXCIpO2UuYWRkKHQpfSxwPXQ9PmUuZGVsZXRlKHQpKTooZj1lPT57fSxwPWU9Pnt9KTtudWxsIT09cj8oZz0oZSx0KT0+e3QrPTE7Y29uc3Qgbj1cXFwiXFxcXG5cXFwiK3IucmVwZWF0KHQpO3JldHVybltlKz1uLHQsdStuXX0sdz0oZSx0LG4pPT4obi09MSxlKz1cXFwiXFxcXG5cXFwiK3IucmVwZWF0KG4pK3QpKTooZz0oZSx0KT0+W2UsdCx1XSx3PShlLHQsbik9PmUrdCk7Y29uc3QgX3VuaGFuZGxlZD0oZSxuKT0+e2YoZSk7Y29uc3Qgcj1faXRlcmVuY29kZSh0KGUpLG4pO3JldHVybiBwKGUpLHJ9LF9pdGVyZW5jb2RlX2xpc3Q9KGUsdCk9PntpZighZS5sZW5ndGgpcmV0dXJuXFxcIltdXFxcIjtsZXQgbixyO2YoZSksW24sdCxyXT1nKFxcXCJbXFxcIix0KTtsZXQgbz0hMDtmb3IobGV0IHMgb2YgZSlvP289ITE6bis9cixuKz1faXRlcmVuY29kZShzLHQpO3JldHVybiBwKGUpLHcobixcXFwiXVxcXCIsdCl9LF9pdGVyZW5jb2RlX2RpY3Q9KGUsdCk9PntpZighZS5zcSRsZW5ndGgoKSlyZXR1cm5cXFwie31cXFwiO2xldCByLGw7ZihlKSxbcix0LGxdPWcoXFxcIntcXFwiLHQpO2xldCB1PSEwO2lmKGgpe2NvbnN0IHQ9JChlLnRwJGdldGF0dHIodikpLG49Yyh0KTtlPSQobyxbbl0pfWZvcihsZXRbbyxjXW9mIGUuJGl0ZW1zKCkpe2NvbnN0IGU9by52YWx1ZU9mKCksaD10eXBlb2YgZTtpZihcXFwic3RyaW5nXFxcIj09PWgpbz1lO2Vsc2UgaWYoXFxcIm51bWJlclxcXCI9PT1oKW89cyhvKTtlbHNlIGlmKFxcXCJib29sZWFuXFxcIj09PWh8fG51bGw9PT1lKW89U3RyaW5nKGUpO2Vsc2V7aWYoIUpTQkkuX19pc0JpZ0ludChlKSl7aWYoZCljb250aW51ZTt0aHJvdyBuZXcgaShcXFwia2V5cyBtdXN0IGJlIHN0ciwgaW50LCBmbG9hdCwgYm9vbCBvciBOb25lLCBub3QgXFxcIit5KG8pKX1vPWUudG9TdHJpbmcoKX11P3U9ITE6cis9bCxyKz1uKG8pLHIrPWEscis9X2l0ZXJlbmNvZGUoYyx0KX1yZXR1cm4gcChlKSx3KHIsXFxcIn1cXFwiLHQpfSxfaXRlcmVuY29kZT0oZSx0PTApPT5TdHJpbmcobShlLHtzdHJpbmdIb29rOmU9Pm4oZSksbnVtYmVySG9vazooZSx0KT0+cyh0KSxiaWdpbnRIb29rOmU9PmUudG9TdHJpbmcoKSxkaWN0SG9vazplPT5faXRlcmVuY29kZV9kaWN0KGUsdCksYXJyYXlIb29rOmU9Pl9pdGVyZW5jb2RlX2xpc3QoZSx0KSxzZXRIb29rOmU9Pl91bmhhbmRsZWQoZSx0KSxmdW5jSG9vazooZSxuKT0+X3VuaGFuZGxlZChuLHQpLG9iamVjdGhvb2s6KGUsbik9Pl91bmhhbmRsZWQobix0KSx1bmhhbmRsZWRIb29rOmU9Pl91bmhhbmRsZWQoZSx0KX0pKTtyZXR1cm4gX2l0ZXJlbmNvZGV9KGUsdGhpcy5kZWZhdWx0LHQsdGhpcy5pbmRlbnQsKChlLHQ9dGhpcy5hbGxvd19uYW4pPT57Y29uc3Qgbj1lLnZhbHVlT2YoKTtsZXQgcjtpZihOdW1iZXIuaXNGaW5pdGUobikpcmV0dXJuIEooZSk7aWYocj1uLnRvU3RyaW5nKCksIXQpdGhyb3cgbmV3IGwoXFxcIk91dCBvZiByYW5nZSBmbG9hdCB2YWx1ZXMgYXJlIG5vdCBKU09OIGNvbXBsaWFudDogXFxcIitKKGUpKTtyZXR1cm4gcn0pLHRoaXMua2V5X3NlcGFyYXRvcix0aGlzLml0ZW1fc2VwYXJhdG9yLHRoaXMuc29ydF9rZXlzLHRoaXMuc2tpcGtleXMpfX1jb25zdCB2PW5ldyBlKFxcXCJpdGVtc1xcXCIpO2NvbnN0IHg9WyExLCEwLCEwLCEwLG51bGwsbnVsbCxudWxsLCExXSxEPW5ldyBKU09ORW5jb2RlciguLi54KSxGPS8oLT8oPzowfFsxLTldXFxcXGQqKSkoXFxcXC5cXFxcZCspPyhbZUVdWy0rXT9cXFxcZCspPy87Y29uc3QgST0vXFxcIlteXFxcIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXCJcXFxcXFxcXF0qKSpcXFwiL207ZnVuY3Rpb24gc2NhbnN0cmluZyh0LG4pe2NvbnN0IHI9dC5zdWJzdHJpbmcobi0xKS5tYXRjaChJKTtpZihudWxsPT09cil0aHJvdyBuZXcgaihcXFwiVW50ZXJtaW5hdGVkIHN0cmluZyBzdGFydGluZyBhdFxcXCIsdCxuLTEpO3RyeXtyZXR1cm5bbmV3IGUoSlNPTi5wYXJzZShyWzBdKSksbityWzBdLmxlbmd0aC0xXX1jYXRjaChvKXtsZXQgZT1vLm1lc3NhZ2UubWF0Y2goLyg/OmNvbHVtbnxwb3NpdGlvbikgKFxcXFxkKykvKTtlPWUmJk51bWJlcihlWzFdKTtuPW4rKGV8fDApLSh2b2lkIDA9PT1vLmNvbHVtbk51bWJlcj8xOjIpO2NvbnN0IHI9by5tZXNzYWdlLnJlcGxhY2UoXFxcIkpTT04ucGFyc2U6IFxcXCIsXFxcIlxcXCIpLnJlcGxhY2UoLyBhdCBsaW5lIFxcXFxkKyBjb2x1bW4gXFxcXGQrIG9mIHRoZSBKU09OIGRhdGEvLFxcXCJcXFwiKS5yZXBsYWNlKC8gaW4gSlNPTiBhdCBwb3NpdGlvbiBcXFxcZCskLyxcXFwiXFxcIik7dGhyb3cgbmV3IGoocix0LG4pfX1jb25zdCBBPS9bIFxcXFx0XFxcXG5cXFxccl0qLztmdW5jdGlvbiBKU09OQXJyYXkoZSx0LHIpe2NvbnN0IG89W107bGV0IHM9ZVt0XTtjb25zdCBhZGp1c3Rfd2hpdGVfc3BhY2U9KCk9PntpZihcXFwiIFxcXCI9PT1zfHxcXFwiXFxcXHRcXFwiPT09c3x8XFxcIlxcXFxuXFxcIj09PXN8fFxcXCJcXFxcclxcXCI9PT1zKXtjb25zdCBuPWUuc3Vic3RyaW5nKHQpLm1hdGNoKEEpO3QrPW5bMF0ubGVuZ3RoLHM9ZVt0XX19O2lmKGFkanVzdF93aGl0ZV9zcGFjZSgpLFxcXCJdXFxcIj09PXMpcmV0dXJuW25ldyBuKFtdKSx0KzFdO2Zvcig7Oyl7bGV0IG47aWYoW24sdF09cihlLHQpLHZvaWQgMD09PW4pdGhyb3cgbmV3IGooXFxcIkV4cGVjdGluZyB2YWx1ZVxcXCIsZSx0KTtpZihvLnB1c2gobikscz1lW3RdLGFkanVzdF93aGl0ZV9zcGFjZSgpLHQrKyxcXFwiXVxcXCI9PT1zKWJyZWFrO2lmKFxcXCIsXFxcIiE9PXMpdGhyb3cgbmV3IGooXFxcIkV4cGVjdGluZyAnLCcgZGVsaW1pdGVyXFxcIixlLHQtMSk7cz1lW3RdLGFkanVzdF93aGl0ZV9zcGFjZSgpfXJldHVybltuZXcgbihvKSx0XX1mdW5jdGlvbiBKU09OT2JqZWN0KGUsdCxzLGksbCl7bGV0IGE9W10sYz1lW3RdO2NvbnN0IGFkanVzdF93aGl0ZV9zcGFjZT0oKT0+e2lmKFxcXCIgXFxcIj09PWN8fFxcXCJcXFxcdFxcXCI9PT1jfHxcXFwiXFxcXG5cXFwiPT09Y3x8XFxcIlxcXFxyXFxcIj09PWMpe2NvbnN0IG49ZS5zdWJzdHJpbmcodCkubWF0Y2goQSk7dCs9blswXS5sZW5ndGgsYz1lW3RdfX07aWYoJ1xcXCInIT09Yyl7aWYoYWRqdXN0X3doaXRlX3NwYWNlKCksXFxcIn1cXFwiPT09Yyl7aWYobnVsbCE9PWwpe3JldHVybltsKG5ldyBuKFtdKSksdCsxXX1yZXR1cm4gYT1uZXcgbyhbXSksbnVsbCE9PWkmJihhPWkoYSkpLFthLHQrMV19aWYoJ1xcXCInIT09Yyl0aHJvdyBuZXcgaihcXFwiRXhwZWN0aW5nIHByb3BlcnR5IG5hbWUgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3Rlc1xcXCIsZSx0KX1sZXQgdSxoO2Zvcih0Kz0xOzspe2lmKFt1LHRdPXNjYW5zdHJpbmcoZSx0KSxcXFwiOlxcXCIhPT0oYz1lW3RdKSYmKGFkanVzdF93aGl0ZV9zcGFjZSgpLFxcXCI6XFxcIiE9PWVbdF0pKXRocm93IG5ldyBqKFxcXCJFeHBlY3RpbmcgJzonIGRlbGltaXRlclxcXCIsZSx0KTtpZihjPWVbKyt0XSxhZGp1c3Rfd2hpdGVfc3BhY2UoKSxbaCx0XT1zKGUsdCksdm9pZCAwPT09aCl0aHJvdyBuZXcgaihcXFwiRXhwZWN0aW5nIHZhbHVlXFxcIixlLHQpO2lmKGM9ZVt0XSxhLnB1c2goW3UsaF0pLGFkanVzdF93aGl0ZV9zcGFjZSgpLHQrKyxcXFwifVxcXCI9PT1jKWJyZWFrO2lmKFxcXCIsXFxcIiE9PWMpdGhyb3cgbmV3IGooXFxcIkV4cGVjdGluZyAnLCcgZGVsaW1pdGVyXFxcIixlLHQtMSk7aWYoYz1lW3RdLGFkanVzdF93aGl0ZV9zcGFjZSgpLHQrKywnXFxcIichPT1jKXRocm93IG5ldyBqKFxcXCJFeHBlY3RpbmcgcHJvcGVydHkgbmFtZSBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzXFxcIixlLHQtMSl9aWYobnVsbCE9PWwpe3JldHVybltsKG5ldyBuKGEubWFwKChlPT5uZXcgcihlKSkpKSksdF19cmV0dXJuIGE9bmV3IG8oYS5mbGF0KCkpLG51bGwhPT1pJiYoYT1pKGEpKSxbYSx0XX1jb25zdCBIPXtOYU46bmV3IHQoTmFOKSxJbmZpbml0eTpuZXcgdCgxLzApLFxcXCItSW5maW5pdHlcXFwiOm5ldyB0KC0xLzApfTtjbGFzcyBKU09ORGVjb2Rlcntjb25zdHJ1Y3RvcihlLHQsbixyLG8pe3RoaXMub2JqZWN0X2hvb2s9ZSx0aGlzLnBhcnNlX2Zsb2F0PXR8fHcsdGhpcy5wYXJzZV9pbnQ9bnx8Xyx0aGlzLnBhcnNlX2NvbnN0YW50PXJ8fChlPT5IW2VdKSx0aGlzLm9iamVjdF9wYWlyc19ob29rPW8sdGhpcy5wYXJzZV9vYmplY3Q9SlNPTk9iamVjdCx0aGlzLnBhcnNlX2FycmF5PUpTT05BcnJheSx0aGlzLnBhcnNlX3N0cmluZz1zY2Fuc3RyaW5nLHRoaXMuc2Nhbl9vbmNlPWZ1bmN0aW9uIG1ha2Vfc2Nhbm5lcihlKXtjb25zdHtwYXJzZV9vYmplY3Q6dCxwYXJzZV9hcnJheTpuLHBhcnNlX3N0cmluZzpyLHBhcnNlX2Zsb2F0Om8scGFyc2VfaW50OnMscGFyc2VfY29uc3RhbnQ6aSxvYmplY3RfaG9vazpsLG9iamVjdF9wYWlyc19ob29rOmF9PWUsc2Nhbl9vbmNlPShlLGMpPT57Y29uc3QgZj1lW2NdO2lmKHZvaWQgMD09PWYpcmV0dXJuW2YsY107aWYoJ1xcXCInPT09ZilyZXR1cm4gcihlLGMrMSk7aWYoXFxcIntcXFwiPT09ZilyZXR1cm4gdChlLGMrMSxzY2FuX29uY2UsbCxhKTtpZihcXFwiW1xcXCI9PT1mKXJldHVybiBuKGUsYysxLHNjYW5fb25jZSk7aWYoXFxcIm5cXFwiPT09ZiYmXFxcIm51bGxcXFwiPT09ZS5zdWJzdHJpbmcoYyxjKzQpKXJldHVyblt1LGMrNF07aWYoXFxcInRcXFwiPT09ZiYmXFxcInRydWVcXFwiPT09ZS5zdWJzdHJpbmcoYyxjKzQpKXJldHVybltoLGMrNF07aWYoXFxcImZcXFwiPT09ZiYmXFxcImZhbHNlXFxcIj09PWUuc3Vic3RyaW5nKGMsYys1KSlyZXR1cm5bZCxjKzVdO2NvbnN0IHA9ZS5zdWJzdHJpbmcoYykubWF0Y2goRik7aWYobnVsbCE9PXApe2xldCBlO2NvbnN0W3QsbixyLGldPXA7cmV0dXJuIGU9cnx8aT9vKG4rKHJ8fFxcXCJcXFwiKSsoaXx8XFxcIlxcXCIpKTpzKG4pLFtlLGMrdC5sZW5ndGhdfXJldHVyblxcXCJOXFxcIj09PWYmJlxcXCJOYU5cXFwiPT09ZS5zdWJzdHJpbmcoYyxjKzMpP1tpKFxcXCJOYU5cXFwiKSxjKzNdOlxcXCJJXFxcIj09ZiYmXFxcIkluZmluaXR5XFxcIj09PWUuc3Vic3RyaW5nKGMsYys4KT9baShcXFwiSW5maW5pdHlcXFwiKSxjKzhdOlxcXCItXFxcIj09ZiYmXFxcIi1JbmZpbml0eVxcXCI9PT1lLnN1YnN0cmluZyhjLGMrOSk/W2koXFxcIi1JbmZpbml0eVxcXCIpLGMrOV06W3ZvaWQgMCxjXX07cmV0dXJuIHNjYW5fb25jZX0odGhpcyl9d2hpdGUoZSx0KXtjb25zdCBuPSgwPT09dD9lOmUuc3Vic3RyaW5nKHQpKS5tYXRjaChBKTtyZXR1cm4gbnVsbCE9PW4mJih0Kz1uWzBdLmxlbmd0aCksdH1kZWNvZGUoZSl7ZT1lLnRvU3RyaW5nKCk7bGV0W3Qsbl09dGhpcy5zY2FuX29uY2UoZSx0aGlzLndoaXRlKGUsMCkpO2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IGooXFxcIkV4cGVjdGluZyB2YWx1ZVxcXCIsZSxuKTtpZihuPXRoaXMud2hpdGUoZSxuKSxuIT09ZS5sZW5ndGgpdGhyb3cgbmV3IGooXFxcIkV4dHJhIGRhdGFcXFwiLGUsbik7cmV0dXJuIHR9fWNvbnN0IFQ9QXJyYXkoNSkuZmlsbChudWxsKSxDPW5ldyBKU09ORGVjb2RlciguLi5UKTtmdW5jdGlvbiBjb252ZXJ0VG9OdWxsT3JGdW5jKGUpe3JldHVybiBudWxsPT09ZXx8ZT09PXU/bnVsbDp0PT4kKGUsW2codCldKX1yZXR1cm4gayhcXFwianNvblxcXCIsRSx7bG9hZHM6eyRtZXRoKGUsdCl7TyhcXFwiZHVtcHNcXFwiLGUpO2xldCBuPWVbMF07aWYoZihuKSk7ZWxzZXtpZighcChuKSl0aHJvdyBuZXcgaShgdGhlIEpTT04gb2JqZWN0IG11c3QgYmUgc3RyIG9yIGJ5dGVzLCBub3QgJHt5KG4pfWApO249KG5ldyBUZXh0RGVjb2RlcikuZGVjb2RlKG4udmFsdWVPZigpKX1jb25zdCByPVMoXFxcImR1bXBzXFxcIixbXFxcIm9iamVjdF9ob29rXFxcIixcXFwicGFyc2VfZmxvYXRcXFwiLFxcXCJwYXJzZV9pbnRcXFwiLFxcXCJwYXJzZV9jb25zdGFudFxcXCIsXFxcIm9iamVjdF9wYWlyc19ob29rXFxcIl0sW10sdCxUKS5tYXAoY29udmVydFRvTnVsbE9yRnVuYyk7cmV0dXJuIHIuZXZlcnkoKGU9Pm51bGw9PT1lKSk/Qy5kZWNvZGUobik6bmV3IEpTT05EZWNvZGVyKC4uLnIpLmRlY29kZShuKX0sJGRvYzpcXFwiRGVzZXJpYWxpemUgYGBzYGAgKGEgYGBzdHJgYCBvciBgYGJ5dGVzYGAgaW5zdGFuY2UgY29udGFpbmluZyBhIEpTT04gZG9jdW1lbnQpIHRvIGEgUHl0aG9uIG9iamVjdC5cXFwiLCRmbGFnczp7RmFzdENhbGw6ITB9fSxkdW1wczp7JG1ldGgoZSx0KXtPKFxcXCJkdW1wc1xcXCIsZSk7Y29uc3Qgbj1lWzBdO2xldFtyLG8scyxsLGEsYyx1LGhdPVMoXFxcImxvYWRzXFxcIixbXFxcInNraXBrZXlzXFxcIixcXFwiZW5zdXJlX2FzY2lpXFxcIixcXFwiY2hlY2tfY2lyY3VsYXJcXFwiLFxcXCJhbGxvd19uYW5cXFwiLFxcXCJpbmRlbnRcXFwiLFxcXCJzZXBhcmF0b3JzXFxcIixcXFwiZGVmYXVsdFxcXCIsXFxcInNvcnRfa2V5c1xcXCJdLFtdLHQseCk7aWYocj1iKHIpLG89YihvKSxzPWIocyksbD1iKGwpLGE9bShhKSxjPW0oYyksdT1jb252ZXJ0VG9OdWxsT3JGdW5jKHUpLGg9YihoKSwhciYmbyYmcyYmbCYmbnVsbD09PWEmJm51bGw9PT1jJiZudWxsPT09dSYmIWgpcmV0dXJuIEQuZW5jb2RlKG4pO2lmKG51bGw9PT1jKTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KGMpfHwyIT09Yy5sZW5ndGh8fFxcXCJzdHJpbmdcXFwiIT10eXBlb2YgY1swXXx8XFxcInN0cmluZ1xcXCIhPXR5cGVvZiBjWzFdKXRocm93IG5ldyBpKFxcXCJzZXBhcmF0b3JzIHNodWxkIGJlIGEgbGlzdCBvciB0dXBsZSBvZiBzdHJpbmdzIG9mIGxlbmd0aCAyXFxcIik7cmV0dXJuIG5ldyBKU09ORW5jb2RlcihyLG8scyxsLGEsYyx1LGgpLmVuY29kZShuKX0sJGRvYzpcXFwiU2VyaWFsaXplIGBgb2JqYGAgdG8gYSBKU09OIGZvcm1hdHRlZCBgYHN0cmBgXFxcIiwkZmxhZ3M6e0Zhc3RDYWxsOiEwfX19KSxFfVwiLFwic3JjL2xpYi9rZXl3b3JkLmpzXCI6XCJmdW5jdGlvbiAkYnVpbHRpbm1vZHVsZSgpe2NvbnN0e2ZmaTp7cmVtYXBUb1B5OnR9LGJ1aWx0aW46e2Zyb3plbnNldDplLHN0cjpzfX09U2ssaT1uZXcgcyhcXFwia2V5d29yZFxcXCIpLG49dChbXFxcImlza2V5d29yZFxcXCIsXFxcImlzc29mdGtleXdvcmRcXFwiLFxcXCJrd2xpc3RcXFwiLFxcXCJzb2Z0a3dsaXN0XFxcIl0pLG89dChbXFxcIkZhbHNlXFxcIixcXFwiTm9uZVxcXCIsXFxcIlRydWVcXFwiLFxcXCJhbmRcXFwiLFxcXCJhc1xcXCIsXFxcImFzc2VydFxcXCIsXFxcImFzeW5jXFxcIixcXFwiYXdhaXRcXFwiLFxcXCJicmVha1xcXCIsXFxcImNsYXNzXFxcIixcXFwiY29udGludWVcXFwiLFxcXCJkZWZcXFwiLFxcXCJkZWxcXFwiLFxcXCJlbGlmXFxcIixcXFwiZWxzZVxcXCIsXFxcImV4Y2VwdFxcXCIsXFxcImZpbmFsbHlcXFwiLFxcXCJmb3JcXFwiLFxcXCJmcm9tXFxcIixcXFwiZ2xvYmFsXFxcIixcXFwiaWZcXFwiLFxcXCJpbXBvcnRcXFwiLFxcXCJpblxcXCIsXFxcImlzXFxcIixcXFwibGFtYmRhXFxcIixcXFwibm9ubG9jYWxcXFwiLFxcXCJub3RcXFwiLFxcXCJvclxcXCIsXFxcInBhc3NcXFwiLFxcXCJyYWlzZVxcXCIsXFxcInJldHVyblxcXCIsXFxcInRyeVxcXCIsXFxcIndoaWxlXFxcIixcXFwid2l0aFxcXCIsXFxcInlpZWxkXFxcIl0pLGE9dChbXFxcIl9cXFwiLFxcXCJjYXNlXFxcIixcXFwibWF0Y2hcXFwiXSk7cmV0dXJue19fbmFtZV9fOmksX19hbGxfXzpuLGt3bGlzdDpvLHNvZnRrd2xpc3Q6YSxpc2tleXdvcmQ6bmV3IGUobykudHAkZ2V0YXR0cihzLiRjb250YWlucyksaXNzb2Z0a2V5d29yZDpuZXcgZShhKS50cCRnZXRhdHRyKHMuJGNvbnRhaW5zKX19XCIsXCJzcmMvbGliL21hdGguanNcIjpcImNvbnN0ICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKGUpe2NvbnN0e2J1aWx0aW46e3N0cjp0LGludF86bixmbG9hdF86aSxUeXBlRXJyb3I6cixweUNoZWNrVHlwZTp1LGNoZWNrTnVtYmVyOmx9LGFic3RyOntsb29rdXBTcGVjaWFsOm99LG1pc2NldmFsOntjYWxsc2ltT3JTdXNwZW5kQXJyYXk6YX19PVNrLHM9e3BpOm5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLlBJKSxlOm5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLkUpLHRhdTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oMipNYXRoLlBJKSxuYW46bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE5hTiksaW5mOm5ldyBTay5idWlsdGluLmZsb2F0XygxLzApfSxiPW5ldyB0KFxcXCJfX2NlaWxfX1xcXCIpO2NvbnN0IGdldF9zaWduPWZ1bmN0aW9uKGUpe3JldHVybiBlPWU/ZTwwPy0xOjE6MS9lPDA/LTE6MX07Y29uc3QgYz0xODtmdW5jdGlvbiBmYWN0b3JpYWwoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IHQ9U2suYnVpbHRpbi5hc251bSQoZSk7aWYoKGU9TWF0aC5mbG9vcih0KSkhPXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZmFjdG9yaWFsKCkgb25seSBhY2NlcHRzIGludGVncmFsIHZhbHVlc1xcXCIpO2lmKGU8MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJmYWN0b3JpYWwoKSBub3QgZGVmaW5lZCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xcXCIpO2xldCBuPTE7Zm9yKGxldCBpPTI7aTw9ZSYmaTw9YztpKyspbio9aTtpZihlPD1jKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKG4pO249SlNCSS5CaWdJbnQobik7Zm9yKGxldCBpPWMrMTtpPD1lO2krKyluPUpTQkkubXVsdGlwbHkobixKU0JJLkJpZ0ludChpKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8obil9Y29uc3QgbT1uZXcgdChcXFwiX19mbG9vcl9fXFxcIik7ZnVuY3Rpb24gX2djZF9pbnRlcm5hbChlLHQpe2xldCBuO3JldHVyblxcXCJudW1iZXJcXFwiPT10eXBlb2YgZSYmXFxcIm51bWJlclxcXCI9PXR5cGVvZiB0PyhuPWZ1bmN0aW9uIF9nY2QoZSx0KXtyZXR1cm4gMD09dD9lOl9nY2QodCxlJXQpfShlPU1hdGguYWJzKGUpLHQ9TWF0aC5hYnModCkpLG49bjwwPy1uOm4pOihuPWZ1bmN0aW9uIF9iaWdnY2QoZSx0KXtyZXR1cm4gSlNCSS5lcXVhbCh0LEpTQkkuX19aRVJPKT9lOl9iaWdnY2QodCxKU0JJLnJlbWFpbmRlcihlLHQpKX0oZT1KU0JJLkJpZ0ludChlKSx0PUpTQkkuQmlnSW50KHQpKSxKU0JJLmxlc3NUaGFuKG4sSlNCSS5fX1pFUk8pJiYobj1KU0JJLm11bHRpcGx5KG4sSlNCSS5CaWdJbnQoLTEpKSkpLG59cmV0dXJuIFNrLmFic3RyLnNldFVwTW9kdWxlTWV0aG9kcyhcXFwibWF0aFxcXCIscyx7YWNvczp7JG1ldGg6ZnVuY3Rpb24gYWNvcyhlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hY29zKFNrLmJ1aWx0aW4uYXNudW0kKGUpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGFyYyBjb3NpbmUgKG1lYXN1cmVkIGluIHJhZGlhbnMpIG9mIHguXFxcIn0sYWNvc2g6eyRtZXRoOmZ1bmN0aW9uIGFjb3NoKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9KGU9U2suYnVpbHRpbi5hc251bSQoZSkpK01hdGguc3FydChlKmUtMSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmxvZyh0KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGludmVyc2UgaHlwZXJib2xpYyBjb3NpbmUgb2YgeC5cXFwifSxhc2luOnskbWV0aDpmdW5jdGlvbiBhc2luKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmFzaW4oU2suYnVpbHRpbi5hc251bSQoZSkpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYXJjIHNpbmUgKG1lYXN1cmVkIGluIHJhZGlhbnMpIG9mIHguXFxcIn0sYXNpbmg6eyRtZXRoOmZ1bmN0aW9uIGFzaW5oKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9KGU9U2suYnVpbHRpbi5hc251bSQoZSkpK01hdGguc3FydChlKmUrMSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmxvZyh0KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGludmVyc2UgaHlwZXJib2xpYyBzaW5lIG9mIHguXFxcIn0sYXRhbjp7JG1ldGg6ZnVuY3Rpb24gYXRhbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hdGFuKFNrLmJ1aWx0aW4uYXNudW0kKGUpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGFyYyB0YW5nZW50IChtZWFzdXJlZCBpbiByYWRpYW5zKSBvZiB4LlxcXCJ9LGF0YW4yOnskbWV0aDpmdW5jdGlvbiBhdGFuMihlLHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hdGFuMihTay5idWlsdGluLmFzbnVtJChlKSxTay5idWlsdGluLmFzbnVtJCh0KSkpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYXJjIHRhbmdlbnQgKG1lYXN1cmVkIGluIHJhZGlhbnMpIG9mIHkveC5cXFxcblxcXFxuVW5saWtlIGF0YW4oeS94KSwgdGhlIHNpZ25zIG9mIGJvdGggeCBhbmQgeSBhcmUgY29uc2lkZXJlZC5cXFwifSxhdGFuaDp7JG1ldGg6ZnVuY3Rpb24gYXRhbmgoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7Y29uc3QgdD0oMSsoZT1Tay5idWlsdGluLmFzbnVtJChlKSkpLygxLWUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5sb2codCkvMil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGludmVyc2UgaHlwZXJib2xpYyB0YW5nZW50IG9mIHguXFxcIn0sY2VpbDp7JG1ldGg6ZnVuY3Rpb24gY2VpbChlKXtsZXQgdDtpZihlLm9iJHR5cGUhPT1pKXtjb25zdCBuPW8oZSxiKTtpZih2b2lkIDAhPT1uKXJldHVybiBhKG4pO3UoXFxcIlxcXCIsXFxcInJlYWwgbnVtYmVyXFxcIixsKGUpKSx0PVNrLmJ1aWx0aW4uYXNudW0kKGUpfWVsc2UgdD1lLnY7cmV0dXJuIG5ldyBuKE1hdGguY2VpbCh0KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGNlaWxpbmcgb2YgeCBhcyBhbiBJbnRlZ3JhbC5cXFxcblxcXFxuVGhpcyBpcyB0aGUgc21hbGxlc3QgaW50ZWdlciA+PSB4LlxcXCJ9LGNvbWI6eyRtZXRoOmZ1bmN0aW9uIGNvbWIoZSx0KXtsZXQgbj1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhlKSxpPVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KHQpO2lmKG48MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJuIG11c3QgYmUgYW4gbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZihpPDApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiayBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZihpPmUpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7ZT1uZXcgU2suYnVpbHRpbi5pbnRfKG4pLHQ9bmV3IFNrLmJ1aWx0aW4uaW50XyhpKTtsZXQgcj1Tay5mZmkucmVtYXBUb0pzKGUubmIkc3VidHJhY3QodCkpO2lmKHI8aSYmKGk9ciksMD09PWkpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMSk7aWYoaT5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFxcXCJtaW4obiAtIGssIGspIG11c3Qgbm90IGV4Y2VlZCBcXFwiK051bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtjb25zdCB1PW5ldyBTay5idWlsdGluLmludF8oMSk7bGV0IGw9ZTtmb3IobGV0IG89MTtvPGk7bysrKWU9ZS5uYiRzdWJ0cmFjdCh1KSxyPW5ldyBTay5idWlsdGluLmludF8obysxKSxsPWwubmIkbXVsdGlwbHkoZSksbD1sLm5iJGZsb29yX2RpdmlkZShyKTtyZXR1cm4gbH0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIG4sIGs9Tm9uZSwgLylcXFwiLCRkb2M6XFxcIk51bWJlciBvZiB3YXlzIHRvIGNob29zZSBrIGl0ZW1zIGZyb20gbiBpdGVtcyB3aXRob3V0IHJlcGV0aXRpb24gYW5kIHdpdGggb3JkZXIuXFxcXG5cXFxcbkV2YWx1YXRlcyB0byBuISAvIChuIC0gaykhIHdoZW4gayA8PSBuIGFuZCBldmFsdWF0ZXNcXFxcbnRvIHplcm8gd2hlbiBrID4gbi5cXFxcblxcXFxuSWYgayBpcyBub3Qgc3BlY2lmaWVkIG9yIGlzIE5vbmUsIHRoZW4gayBkZWZhdWx0cyB0byBuXFxcXG5hbmQgdGhlIGZ1bmN0aW9uIHJldHVybnMgbiEuXFxcXG5cXFxcblJhaXNlcyBUeXBlRXJyb3IgaWYgZWl0aGVyIG9mIHRoZSBhcmd1bWVudHMgYXJlIG5vdCBpbnRlZ2Vycy5cXFxcblJhaXNlcyBWYWx1ZUVycm9yIGlmIGVpdGhlciBvZiB0aGUgYXJndW1lbnRzIGFyZSBuZWdhdGl2ZS5cXFwifSxjb3B5c2lnbjp7JG1ldGg6ZnVuY3Rpb24gY29weXNpZ24oZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtjb25zdCBuPVNrLmJ1aWx0aW4uYXNudW0kKHQpLGk9U2suYnVpbHRpbi5hc251bSQoZSkscj1nZXRfc2lnbihpKSpnZXRfc2lnbihuKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkqcil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIGEgZmxvYXQgd2l0aCB0aGUgbWFnbml0dWRlIChhYnNvbHV0ZSB2YWx1ZSkgb2YgeCBidXQgdGhlIHNpZ24gb2YgeS5cXFxcblxcXFxuT24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydCBzaWduZWQgemVyb3MsIGNvcHlzaWduKDEuMCwgLTAuMClcXFxcbnJldHVybnMgLTEuMC5cXFxcblxcXCJ9LGNvczp7JG1ldGg6ZnVuY3Rpb24gY29zKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmNvcyhTay5idWlsdGluLmFzbnVtJChlKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBjb3NpbmUgb2YgeCAobWVhc3VyZWQgaW4gcmFkaWFucykuXFxcIn0sY29zaDp7JG1ldGg6ZnVuY3Rpb24gY29zaChlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxlPVNrLmJ1aWx0aW4uYXNudW0kKGUpO2NvbnN0IHQ9TWF0aC5FLG49TWF0aC5wb3codCxlKSxpPShuKzEvbikvMjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiB4LlxcXCJ9LGRlZ3JlZXM6eyRtZXRoOmZ1bmN0aW9uIGRlZ3JlZXMoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PTE4MC9NYXRoLlBJKlNrLmJ1aWx0aW4uYXNudW0kKGUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJDb252ZXJ0IGFuZ2xlIHggZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXFxcIn0sZGlzdDp7JG1ldGg6ZnVuY3Rpb24gZGlzdChlKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtYXRoLmRpc3QoKSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgcCwgcSwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgaW4gYW55IGRpbWVuc2lvbi5cXFwifSxlcmY6eyRtZXRoOmZ1bmN0aW9uIGVyZihlKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtYXRoLmVyZigpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJFcnJvciBmdW5jdGlvbiBhdCB4LlxcXCJ9LGVyZmM6eyRtZXRoOmZ1bmN0aW9uIGVyZmMoZSl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5lcmZjKCkgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIkNvbXBsZW1lbnRhcnkgZXJyb3IgZnVuY3Rpb24gYXQgeC5cXFwifSxleHA6eyRtZXRoOmZ1bmN0aW9uIGV4cChlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtsZXQgdD1lLnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiB0JiYodD1lLm5iJGZsb2F0KCkudiksdD09MS8wfHx0PT0tMS8wfHxpc05hTih0KSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguZXhwKHQpKTtjb25zdCBuPU1hdGguZXhwKHQpO2lmKCFpc0Zpbml0ZShuKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFxcXCJtYXRoIHJhbmdlIGVycm9yXFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhuKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBlIHJhaXNlZCB0byB0aGUgcG93ZXIgb2YgeC5cXFwifSxleHBtMTp7JG1ldGg6ZnVuY3Rpb24gZXhwbTEoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7Y29uc3QgdD1Tay5idWlsdGluLmFzbnVtJChlKTtpZihNYXRoLmFicyh0KTwuNyl7Y29uc3QgZT1NYXRoLmV4cCh0KTtpZigxPT1lKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odCk7e2NvbnN0IG49KGUtMSkqdC9NYXRoLmxvZyhlKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKG4pfX17Y29uc3QgZT1NYXRoLmV4cCh0KS0xO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oZSl9fSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIGV4cCh4KS0xLlxcXFxuXFxcXG5UaGlzIGZ1bmN0aW9uIGF2b2lkcyB0aGUgbG9zcyBvZiBwcmVjaXNpb24gaW52b2x2ZWQgaW4gdGhlIGRpcmVjdCBldmFsdWF0aW9uIG9mIGV4cCh4KS0xIGZvciBzbWFsbCB4LlxcXCJ9LGZhYnM6eyRtZXRoOmZ1bmN0aW9uIGZhYnMoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IHQ9ZS52O3JldHVybiBKU0JJLl9faXNCaWdJbnQodCkmJih0PWUubmIkZmxvYXQoKS52KSx0PU1hdGguYWJzKHQpLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGZsb2F0IHguXFxcIn0sZmFjdG9yaWFsOnskbWV0aDpmYWN0b3JpYWwsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIkZpbmQgeCEuXFxcXG5cXFxcblJhaXNlIGEgVmFsdWVFcnJvciBpZiB4IGlzIG5lZ2F0aXZlIG9yIG5vbi1pbnRlZ3JhbC5cXFwifSxmbG9vcjp7JG1ldGg6ZnVuY3Rpb24gZmxvb3IoZSl7bGV0IHQ7aWYoZS5vYiR0eXBlPT09aSl0PWUudjtlbHNle2NvbnN0IG49byhlLG0pO2lmKHZvaWQgMCE9PW4pcmV0dXJuIGEobik7dShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsbChlKSksdD1Tay5idWlsdGluLmFzbnVtJChlKX1yZXR1cm4gbmV3IG4oTWF0aC5mbG9vcih0KSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGZsb29yIG9mIHggYXMgYW4gSW50ZWdyYWwuXFxcXG5cXFxcblRoaXMgaXMgdGhlIGxhcmdlc3QgaW50ZWdlciA8PSB4LlxcXCJ9LGZtb2Q6eyRtZXRoOmZ1bmN0aW9uIGZtb2QoZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtsZXQgbj1lLnYsaT10LnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBuJiYobj1lLm5iJGZsb2F0KCkudiksXFxcIm51bWJlclxcXCIhPXR5cGVvZiBpJiYoaT10Lm5iJGZsb2F0KCkudiksKGk9PTEvMHx8aT09LTEvMCkmJmlzRmluaXRlKG4pKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obik7Y29uc3Qgcj1uJWk7aWYoaXNOYU4ocikmJiFpc05hTihuKSYmIWlzTmFOKGkpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhyKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIHksIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gZm1vZCh4LCB5KSwgYWNjb3JkaW5nIHRvIHBsYXRmb3JtIEMuXFxcXG5cXFxcbnggJSB5IG1heSBkaWZmZXIuXFxcIn0sZnJleHA6eyRtZXRoOmZ1bmN0aW9uIGZyZXhwKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9U2suYnVpbHRpbi5hc251bSQoZSksbj1bdCwwXTtpZigwIT09dCYmTnVtYmVyLmlzRmluaXRlKHQpKXtjb25zdCBlPU1hdGguYWJzKHQpO2xldCBpPU1hdGgubWF4KC0xMDIzLE1hdGguZmxvb3IoTWF0aC5sb2cyKGUpKSsxKSxyPWUqTWF0aC5wb3coMiwtaSk7Zm9yKDtyPC41OylyKj0yLGktLTtmb3IoO3I+PTE7KXIqPS41LGkrKzt0PDAmJihyPS1yKSxuWzBdPXIsblsxXT1pfXJldHVybiBuWzBdPW5ldyBTay5idWlsdGluLmZsb2F0XyhuWzBdKSxuWzFdPW5ldyBTay5idWlsdGluLmludF8oblsxXSksbmV3IFNrLmJ1aWx0aW4udHVwbGUobil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIG1hbnRpc3NhIGFuZCBleHBvbmVudCBvZiB4LCBhcyBwYWlyIChtLCBlKS5cXFxcblxcXFxubSBpcyBhIGZsb2F0IGFuZCBlIGlzIGFuIGludCwgc3VjaCB0aGF0IHggPSBtICogMi4qKmUuXFxcXG5JZiB4IGlzIDAsIG0gYW5kIGUgYXJlIGJvdGggMC4gIEVsc2UgMC41IDw9IGFicyhtKSA8IDEuMC5cXFwifSxmc3VtOnskbWV0aDpmdW5jdGlvbiBmc3VtKGUpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCInXFxcIitTay5hYnN0ci50eXBlTmFtZShlKStcXFwiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXFxcIik7bGV0IHQsbixpLHI9W107Zm9yKGxldCBsPShlPVNrLmFic3RyLml0ZXIoZSkpLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09bDtsPWUudHAkaXRlcm5leHQoKSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiXFxcIixcXFwicmVhbCBudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIobCkpLHQ9MDtsZXQgZT1sLnY7XFxcIm51bWJlclxcXCIhPXR5cGVvZiBlJiYoZT1sLm5iJGZsb2F0KCkudiksbD1lO2ZvcihsZXQgdT0wLG89ci5sZW5ndGg7dTxvO3UrKyl7bGV0IGU9clt1XTtpZihNYXRoLmFicyhsKTxNYXRoLmFicyhlKSl7bGV0IHQ9bDtsPWUsZT10fW49bCtlLGk9ZS0obi1sKSxpJiYoclt0XT1pLHQrKyksbD1ufXI9ci5zbGljZSgwLHQpLmNvbmNhdChbbF0pfWNvbnN0IHU9ci5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdH0pLDApO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHNlcSwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBhbiBhY2N1cmF0ZSBmbG9hdGluZyBwb2ludCBzdW0gb2YgdmFsdWVzIGluIHRoZSBpdGVyYWJsZSBzZXEuXFxcXG5cXFxcbkFzc3VtZXMgSUVFRS03NTQgZmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYy5cXFwifSxnYW1tYTp7JG1ldGg6ZnVuY3Rpb24gZ2FtbWEoZSl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5nYW1tYSgpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJHYW1tYSBmdW5jdGlvbiBhdCB4LlxcXCJ9LGdjZDp7JG1ldGg6ZnVuY3Rpb24gZ2NkKGUsdCl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiYVxcXCIsXFxcImludGVnZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tJbnQoZSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImJcXFwiLFxcXCJpbnRlZ2VyXFxcIixTay5idWlsdGluLmNoZWNrSW50KHQpKTtjb25zdCBuPV9nY2RfaW50ZXJuYWwoU2suYnVpbHRpbi5hc251bSQoZSksU2suYnVpbHRpbi5hc251bSQodCkpO3JldHVyblxcXCJudW1iZXJcXFwiPT10eXBlb2Ygbj9uZXcgU2suYnVpbHRpbi5pbnRfKG4pOm5ldyBTay5idWlsdGluLmludF8obi50b1N0cmluZygpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIHksIC8pXFxcIiwkZG9jOlxcXCJncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiB4IGFuZCB5XFxcIn0saHlwb3Q6eyRtZXRoOmZ1bmN0aW9uIGh5cG90KGUsdCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInlcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIodCkpLGU9U2suYnVpbHRpbi5hc251bSQoZSksdD1Tay5idWlsdGluLmFzbnVtJCh0KSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5zcXJ0KGUqZSt0KnQpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIHksIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSwgc3FydCh4KnggKyB5KnkpLlxcXCJ9LGlzY2xvc2U6eyRtZXRoOmZ1bmN0aW9uIGlzY2xvc2UoZSx0KXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcImlzY2xvc2VcXFwiLGUsMiwyKTtjb25zdCBuPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJpc2Nsb3NlXFxcIixbXFxcInJlbF90b2xcXFwiLFxcXCJhYnNfdG9sXFxcIl0sW10sdCxbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDFlLTkpLG5ldyBTay5idWlsdGluLmZsb2F0XygwKV0pLGk9ZVswXSxyPWVbMV0sdT1uWzBdLGw9blsxXTtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJhXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGkpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJiXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHIpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyZWxfdG9sXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJhYnNfdG9sXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGwpKTtjb25zdCBvPVNrLmJ1aWx0aW4uYXNudW0kKGkpLGE9U2suYnVpbHRpbi5hc251bSQocikscz1Tay5idWlsdGluLmFzbnVtJCh1KSxiPVNrLmJ1aWx0aW4uYXNudW0kKGwpO2lmKHM8MHx8YjwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcInRvbGVyYW5jZXMgbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTtpZihvPT1hKXJldHVybiBTay5idWlsdGluLmJvb2wudHJ1ZSQ7aWYobz09MS8wfHxvPT0tMS8wfHxhPT0xLzB8fGE9PS0xLzApcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7Y29uc3QgYz1NYXRoLmFicyhhLW8pLG09Yzw9TWF0aC5hYnMocyphKXx8Yzw9TWF0aC5hYnMocypvKXx8Yzw9YjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbChtKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCAvLCBhLCBiLCAqLCByZWxfdG9sPTFlLTA5LCBhYnNfdG9sPTAuMClcXFwiLCRkb2M6J0RldGVybWluZSB3aGV0aGVyIHR3byBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFyZSBjbG9zZSBpbiB2YWx1ZS5cXFxcblxcXFxuICByZWxfdG9sXFxcXG4gICAgbWF4aW11bSBkaWZmZXJlbmNlIGZvciBiZWluZyBjb25zaWRlcmVkIFxcXCJjbG9zZVxcXCIsIHJlbGF0aXZlIHRvIHRoZVxcXFxuICAgIG1hZ25pdHVkZSBvZiB0aGUgaW5wdXQgdmFsdWVzXFxcXG4gIGFic190b2xcXFxcbiAgICBtYXhpbXVtIGRpZmZlcmVuY2UgZm9yIGJlaW5nIGNvbnNpZGVyZWQgXFxcImNsb3NlXFxcIiwgcmVnYXJkbGVzcyBvZiB0aGVcXFxcbiAgICBtYWduaXR1ZGUgb2YgdGhlIGlucHV0IHZhbHVlc1xcXFxuXFxcXG5SZXR1cm4gVHJ1ZSBpZiBhIGlzIGNsb3NlIGluIHZhbHVlIHRvIGIsIGFuZCBGYWxzZSBvdGhlcndpc2UuXFxcXG5cXFxcbkZvciB0aGUgdmFsdWVzIHRvIGJlIGNvbnNpZGVyZWQgY2xvc2UsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlbVxcXFxubXVzdCBiZSBzbWFsbGVyIHRoYW4gYXQgbGVhc3Qgb25lIG9mIHRoZSB0b2xlcmFuY2VzLlxcXFxuXFxcXG4taW5mLCBpbmYgYW5kIE5hTiBiZWhhdmUgc2ltaWxhcmx5IHRvIHRoZSBJRUVFIDc1NCBTdGFuZGFyZC4gIFRoYXRcXFxcbmlzLCBOYU4gaXMgbm90IGNsb3NlIHRvIGFueXRoaW5nLCBldmVuIGl0c2VsZi4gIGluZiBhbmQgLWluZiBhcmVcXFxcbm9ubHkgY2xvc2UgdG8gdGhlbXNlbHZlcy4nfSxpc2Zpbml0ZTp7JG1ldGg6ZnVuY3Rpb24gaXNmaW5pdGUoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7Y29uc3QgdD1Tay5idWlsdGluLmFzbnVtJChlKTtyZXR1cm4gU2suYnVpbHRpbi5jaGVja0ludChlKXx8aXNGaW5pdGUodCk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gVHJ1ZSBpZiB4IGlzIG5laXRoZXIgYW4gaW5maW5pdHkgbm9yIGEgTmFOLCBhbmQgRmFsc2Ugb3RoZXJ3aXNlLlxcXCJ9LGlzaW5mOnskbWV0aDpmdW5jdGlvbiBpc2luZihlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PVNrLmJ1aWx0aW4uYXNudW0kKGUpO3JldHVybiBTay5idWlsdGluLmNoZWNrSW50KGUpfHxpc0Zpbml0ZSh0KXx8aXNOYU4odCk/U2suYnVpbHRpbi5ib29sLmZhbHNlJDpTay5idWlsdGluLmJvb2wudHJ1ZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gVHJ1ZSBpZiB4IGlzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW5maW5pdHksIGFuZCBGYWxzZSBvdGhlcndpc2UuXFxcIn0saXNuYW46eyRtZXRoOmZ1bmN0aW9uIGlzbmFuKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9U2suYnVpbHRpbi5hc251bSQoZSk7cmV0dXJuIGlzTmFOKHQpP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIFRydWUgaWYgeCBpcyBhIE5hTiAobm90IGEgbnVtYmVyKSwgYW5kIEZhbHNlIG90aGVyd2lzZS5cXFwifSxpc3FydDp7JG1ldGg6ZnVuY3Rpb24gaXNxcnQoZSl7bGV0IHQ9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coZSk7aWYodDwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImlzcXJ0KCkgYXJndW1lbnQgbXVzdCBiZSBub25uZWdhdGl2ZVxcXCIpO3JldHVybiAwPT10P25ldyBTay5idWlsdGluLmludF8oMCk6XFxcIm51bWJlclxcXCI9PXR5cGVvZiB0P25ldyBTay5idWlsdGluLmludF8oTWF0aC5mbG9vcihNYXRoLnNxcnQodCkpKTpmdW5jdGlvbiBiaWdpbnRfaXNxcnQoZSl7bGV0IHQ9ZS50b1N0cmluZygyKS5sZW5ndGg7dD1NYXRoLmZsb29yKCh0LTEpLzIpO2xldCBuPXQudG9TdHJpbmcoMikubGVuZ3RoO2NvbnN0IGk9SlNCSS5CaWdJbnQoMSkscj1KU0JJLkJpZ0ludCgyKSx1PUpTQkkuQmlnSW50KHQpLGw9SlNCSS5tdWx0aXBseShyLHUpO2xldCBvPWksYT1KU0JJLkJpZ0ludCgwKTtmb3IoO24+MDspe24tLTtsZXQgdD1hO2E9SlNCSS5zaWduZWRSaWdodFNoaWZ0KHUsSlNCSS5CaWdJbnQobikpO2NvbnN0IHI9SlNCSS5zdWJ0cmFjdChKU0JJLnN1YnRyYWN0KGEsdCksaSkscz1KU0JJLmxlZnRTaGlmdChvLHIpLGI9SlNCSS5hZGQoSlNCSS5zdWJ0cmFjdChKU0JJLnN1YnRyYWN0KGwsdCksYSksaSksYz1KU0JJLnNpZ25lZFJpZ2h0U2hpZnQoZSxiKTtvPUpTQkkuYWRkKHMsSlNCSS5kaXZpZGUoYyxvKSl9bGV0IHM9bztyZXR1cm4gSlNCSS5ncmVhdGVyVGhhbihKU0JJLm11bHRpcGx5KHMscyksZSkmJihzPUpTQkkuc3VidHJhY3QocyxpKSksSlNCSS5sZXNzVGhhbk9yRXF1YWwocyxKU0JJLkJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpJiYocz1OdW1iZXIocykpLG5ldyBTay5idWlsdGluLmludF8ocyl9KHQpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBuLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHNxdWFyZSByb290IG9mIHRoZSBpbnB1dC5cXFwifSxsY206eyRtZXRoOmZ1bmN0aW9uIGxjbSguLi5lKXtmdW5jdGlvbiBhYnMoZSl7cmV0dXJuXFxcIm51bWJlclxcXCI9PXR5cGVvZiBlP25ldyBTay5idWlsdGluLmludF8oTWF0aC5hYnMoZSkpOkpTQkkubGVzc1RoYW4oZSxKU0JJLl9fWkVSTyk/bmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLnVuYXJ5TWludXMoZSkpOm5ldyBTay5idWlsdGluLmludF8oZSl9Y29uc3QgdD1lLmxlbmd0aDtpZigwPT09dClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygxKTtsZXQgbjtmb3Iobj0wO248dDsrK24pZVtuXT1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhlW25dKTtsZXQgaSxyPWVbMF07aWYoMT09PXQpcmV0dXJuIGFicyhyKTtmb3Iobj0xO248dDsrK24pe2lmKGk9ZVtuXSwwPT09aSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygwKTtpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mIHImJlxcXCJudW1iZXJcXFwiPT10eXBlb2YgaSl7bGV0IGU9ci9fZ2NkX2ludGVybmFsKHIsaSkqaTtlPU1hdGguYWJzKGUpLHI9ZT5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUj9KU0JJLkJpZ0ludChyKTplfWVsc2Ugcj1KU0JJLkJpZ0ludChyKTtcXFwibnVtYmVyXFxcIiE9dHlwZW9mIHImJihpPUpTQkkuQmlnSW50KGkpLHI9SlNCSS5tdWx0aXBseShKU0JJLmRpdmlkZShyLF9nY2RfaW50ZXJuYWwocixpKSksaSkpfXJldHVybiBhYnMocil9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsICppbnRlZ2VycywgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlIG9mIHRoZSBzcGVjaWZpZWQgaW50ZWdlciBhcmd1bWVudHMuIElmIGFsbCBhcmd1bWVudHMgYXJlIG5vbnplcm8sIHRoZW4gdGhlIHJldHVybmVkIHZhbHVlIGlzIHRoZSBzbWFsbGVzdCBwb3NpdGl2ZSBpbnRlZ2VyIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiBhbGwgYXJndW1lbnRzLiBJZiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBpcyB6ZXJvLCB0aGVuIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyAwLiBsY20oKSB3aXRob3V0IGFyZ3VtZW50cyByZXR1cm5zIDEuXFxcIn0sbGRleHA6eyRtZXRoOmZ1bmN0aW9uIGxkZXhwKGUsdCl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiaVxcXCIsXFxcImludGVnZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tJbnQodCkpO2xldCBuPWUudjtcXFwibnVtYmVyXFxcIiE9dHlwZW9mIG4mJihuPWUubmIkZmxvYXQoKS52KTtjb25zdCBpPVNrLmJ1aWx0aW4uYXNudW0kKHQpO2lmKG49PTEvMHx8bj09LTEvMHx8MD09bnx8aXNOYU4obikpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhuKTtjb25zdCByPW4qTWF0aC5wb3coMixpKTtpZighaXNGaW5pdGUocikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcXFwibWF0aCByYW5nZSBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCBpLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHggKiAoMioqaSkuXFxcXG5cXFxcblRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIGludmVyc2Ugb2YgZnJleHAoKS5cXFwifSxsZ2FtbWE6eyRtZXRoOmZ1bmN0aW9uIGxnYW1tYShlKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtYXRoLmxnYW1tYSgpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJOYXR1cmFsIGxvZ2FyaXRobSBvZiBhYnNvbHV0ZSB2YWx1ZSBvZiBHYW1tYSBmdW5jdGlvbiBhdCB4LlxcXCJ9LGxvZzp7JG1ldGg6ZnVuY3Rpb24gbG9nKGUsdCl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IG4saSxyPVNrLmJ1aWx0aW4uYXNudW0kKGUpO2lmKHI8PTApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtpZih2b2lkIDA9PT10P249TWF0aC5FOihTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJiYXNlXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKSxuPVNrLmJ1aWx0aW4uYXNudW0kKHQpKSxuPD0wKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoU2suYnVpbHRpbi5jaGVja0Zsb2F0KGUpfHxyPE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKWk9TWF0aC5sb2cocikvTWF0aC5sb2cobik7ZWxzZXtyPW5ldyBTay5idWlsdGluLnN0cihlKS4kanNzdHIoKTtjb25zdCB0PXIubGVuZ3RoLHU9cGFyc2VGbG9hdChcXFwiMC5cXFwiK3IpO2k9KHQqTWF0aC5sb2coMTApK01hdGgubG9nKHUpKS9NYXRoLmxvZyhuKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwibG9nKHgsIFtiYXNlPWVdKVxcXFxuUmV0dXJuIHRoZSBsb2dhcml0aG0gb2YgeCB0byB0aGUgZ2l2ZW4gYmFzZS5cXFxcblxcXFxuSWYgdGhlIGJhc2Ugbm90IHNwZWNpZmllZCwgcmV0dXJucyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gKGJhc2UgZSkgb2YgeC5cXFwifSxsb2cxMDp7JG1ldGg6ZnVuY3Rpb24gbG9nMTAoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IHQsbj1Tay5idWlsdGluLmFzbnVtJChlKTtpZihuPD0wKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoU2suYnVpbHRpbi5jaGVja0Zsb2F0KGUpfHxuPE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXQ9TWF0aC5sb2cxMChuKTtlbHNle249bmV3IFNrLmJ1aWx0aW4uc3RyKGUpLiRqc3N0cigpO2NvbnN0IGk9bi5sZW5ndGgscj1wYXJzZUZsb2F0KFxcXCIwLlxcXCIrbik7dD1pK01hdGgubG9nMTAocil9cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYmFzZSAxMCBsb2dhcml0aG0gb2YgeC5cXFwifSxsb2cxcDp7JG1ldGg6ZnVuY3Rpb24gbG9nMXAoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSk7bGV0IHQ9ZS52O2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgdCYmKHQ9ZS5uYiRmbG9hdCgpLnYpLHQ8PS0xKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoMD09dClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHQpO2lmKE1hdGguYWJzKHQpPE51bWJlci5FUFNJTE9OLzIpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KTtpZigtLjU8PXQmJnQ8PTEpe2NvbnN0IGU9MSt0LG49TWF0aC5sb2coZSktKGUtMS10KS9lO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obil9e2NvbnN0IGU9TWF0aC5sb2coMSt0KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGUpfX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMSt4IChiYXNlIGUpLlxcXFxuXFxcXG5UaGUgcmVzdWx0IGlzIGNvbXB1dGVkIGluIGEgd2F5IHdoaWNoIGlzIGFjY3VyYXRlIGZvciB4IG5lYXIgemVyby5cXFwifSxsb2cyOnskbWV0aDpmdW5jdGlvbiBsb2cyKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2xldCB0LG49U2suYnVpbHRpbi5hc251bSQoZSk7aWYobjw9MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJtYXRoIGRvbWFpbiBlcnJvclxcXCIpO2lmKFNrLmJ1aWx0aW4uY2hlY2tGbG9hdChlKXx8bjxOdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0PU1hdGgubG9nMihuKTtlbHNle249bmV3IFNrLmJ1aWx0aW4uc3RyKGUpLiRqc3N0cigpO2NvbnN0IGk9bi5sZW5ndGgscj1wYXJzZUZsb2F0KFxcXCIwLlxcXCIrbik7dD1pKk1hdGgubG9nMigxMCkrTWF0aC5sb2cyKHIpfXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGJhc2UgMiBsb2dhcml0aG0gb2YgeC5cXFwifSxtb2RmOnskbWV0aDpmdW5jdGlvbiBtb2RmKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2xldCB0PVNrLmJ1aWx0aW4uYXNudW0kKGUpO2lmKCFpc0Zpbml0ZSh0KSl7aWYodD09MS8wKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KV0pO2lmKHQ9PS0xLzApcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8oLTApLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KV0pO2lmKGlzTmFOKHQpKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHQpLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KV0pfWNvbnN0IG49Z2V0X3NpZ24odCk7dD1NYXRoLmFicyh0KTtjb25zdCBpPW4qTWF0aC5mbG9vcih0KSxyPW4qKHQtTWF0aC5mbG9vcih0KSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8ociksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGkpXSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGZyYWN0aW9uYWwgYW5kIGludGVnZXIgcGFydHMgb2YgeC5cXFxcblxcXFxuQm90aCByZXN1bHRzIGNhcnJ5IHRoZSBzaWduIG9mIHggYW5kIGFyZSBmbG9hdHMuXFxcIn0scGVybTp7JG1ldGg6ZnVuY3Rpb24gcGVybShlLHQpe2lmKHZvaWQgMD09PXR8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKHQpKXJldHVybiBmYWN0b3JpYWwoZSk7aWYoZT1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhlKSx0PVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KHQpLGU8MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJuIG11c3QgYmUgYW4gbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZih0PDApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiayBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXJcXFwiKTtpZih0PmUpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7aWYoMD09PXQpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMSk7aWYodD5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFxcXCJrIG11c3Qgbm90IGV4Y2VlZCBcXFwiK051bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtjb25zdCBuPW5ldyBTay5idWlsdGluLmludF8oMSk7bGV0IGk9ZT1uZXcgU2suYnVpbHRpbi5pbnRfKGUpO2ZvcihsZXQgcj0xO3I8dDtyKyspZT1lLm5iJHN1YnRyYWN0KG4pLGk9aS5uYiRtdWx0aXBseShlKTtyZXR1cm4gaX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIG4sIGs9Tm9uZSwgLylcXFwiLCRkb2M6XFxcIidOdW1iZXIgb2Ygd2F5cyB0byBjaG9vc2UgayBpdGVtcyBmcm9tIG4gaXRlbXMgd2l0aG91dCByZXBldGl0aW9uIGFuZCB3aXRoIG9yZGVyLlxcXFxuXFxcXG5FdmFsdWF0ZXMgdG8gbiEgLyAobiAtIGspISB3aGVuIGsgPD0gbiBhbmQgZXZhbHVhdGVzXFxcXG50byB6ZXJvIHdoZW4gayA+IG4uXFxcXG5cXFxcbklmIGsgaXMgbm90IHNwZWNpZmllZCBvciBpcyBOb25lLCB0aGVuIGsgZGVmYXVsdHMgdG8gblxcXFxuYW5kIHRoZSBmdW5jdGlvbiByZXR1cm5zIG4hLlxcXFxuXFxcXG5SYWlzZXMgVHlwZUVycm9yIGlmIGVpdGhlciBvZiB0aGUgYXJndW1lbnRzIGFyZSBub3QgaW50ZWdlcnMuXFxcXG5SYWlzZXMgVmFsdWVFcnJvciBpZiBlaXRoZXIgb2YgdGhlIGFyZ3VtZW50cyBhcmUgbmVnYXRpdmUuJ1xcXCJ9LHByb2Q6eyRtZXRoOmZ1bmN0aW9uIHByb2QoZSx0KXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcInByb2RcXFwiLGUsMSwxKSxlPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJwcm9kXFxcIixbbnVsbCxcXFwic3RhcnRcXFwiXSxlLHQsW25ldyBTay5idWlsdGluLmludF8oMSldKTtjb25zdCBuPVNrLmFic3RyLml0ZXIoZVswXSk7bGV0IGkscj1lWzFdO3JldHVybiBpPXIuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmludF8/ZnVuY3Rpb24gZmFzdFByb2RJbnQoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihuLChlPT57aWYoZS5jb25zdHJ1Y3RvciE9PVNrLmJ1aWx0aW4uaW50XylyZXR1cm4gZS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRfPyhyPXIubmIkZmxvYXQoKS5uYiRtdWx0aXBseShlKSxuZXcgU2subWlzY2V2YWwuQnJlYWsoXFxcImZsb2F0XFxcIikpOihyPVNrLmFic3RyLm51bWJlckJpbk9wKHIsZSxcXFwiTXVsdFxcXCIpLG5ldyBTay5taXNjZXZhbC5CcmVhayhcXFwic2xvd1xcXCIpKTtyPXIubmIkbXVsdGlwbHkoZSl9KSl9KCk6ci5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRfP1xcXCJmbG9hdFxcXCI6XFxcInNsb3dcXFwiLFNrLm1pc2NldmFsLmNoYWluKGksKGU9PlxcXCJmbG9hdFxcXCI9PT1lP2Z1bmN0aW9uIGZhc3RQcm9kRmxvYXQoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihuLChlPT57aWYoZS5jb25zdHJ1Y3RvciE9PVNrLmJ1aWx0aW4uZmxvYXRfJiZlLmNvbnN0cnVjdG9yIT09U2suYnVpbHRpbi5pbnRfKXJldHVybiByPVNrLmFic3RyLm51bWJlckJpbk9wKHIsZSxcXFwiTXVsdFxcXCIpLG5ldyBTay5taXNjZXZhbC5CcmVhayhcXFwic2xvd1xcXCIpO3I9ci5uYiRtdWx0aXBseShlKX0pKX0oKTplKSwoZT0+e2lmKFxcXCJzbG93XFxcIj09PWUpcmV0dXJuIGZ1bmN0aW9uIHNsb3dQcm9kKCl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IobiwoZT0+e3I9U2suYWJzdHIubnVtYmVyQmluT3AocixlLFxcXCJNdWx0XFxcIil9KSl9KCl9KSwoKCk9PnIpKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBpdGVyYWJsZSwgLywgKiwgc3RhcnQ9MSlcXFwiLCRkb2M6XFxcIkNhbGN1bGF0ZSB0aGUgcHJvZHVjdCBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBpbnB1dCBpdGVyYWJsZS4gVGhlIGRlZmF1bHQgc3RhcnQgdmFsdWUgZm9yIHRoZSBwcm9kdWN0IGlzIDEuXFxcXG5cXFxcbldoZW4gdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCByZXR1cm4gdGhlIHN0YXJ0IHZhbHVlLiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHNwZWNpZmljYWxseSBmb3IgdXNlIHdpdGggbnVtZXJpYyB2YWx1ZXMgYW5kIG1heSByZWplY3Qgbm9uLW51bWVyaWMgdHlwZXMuXFxcIn0scG93OnskbWV0aDpmdW5jdGlvbiBwb3coZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtsZXQgbj1lLnYsaT10LnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBuJiYobj1lLm5iJGZsb2F0KCkudiksXFxcIm51bWJlclxcXCIhPXR5cGVvZiBpJiYoaT10Lm5iJGZsb2F0KCkudiksMD09biYmaTwwKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoMT09bilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDEpO2lmKE51bWJlci5pc0Zpbml0ZShuKSYmTnVtYmVyLmlzRmluaXRlKGkpJiZuPDAmJiFOdW1iZXIuaXNJbnRlZ2VyKGkpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoLTE9PW4mJihpPT0tMS8wfHxpPT0xLzApKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oMSk7Y29uc3Qgcj1NYXRoLnBvdyhuLGkpO2lmKCFOdW1iZXIuaXNGaW5pdGUobil8fCFOdW1iZXIuaXNGaW5pdGUoaSkpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhyKTtpZihyPT0xLzB8fHI9PS0xLzApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcXFwibWF0aCByYW5nZSBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHgqKnkgKHggdG8gdGhlIHBvd2VyIG9mIHkpLlxcXCJ9LHJhZGlhbnM6eyRtZXRoOmZ1bmN0aW9uIHJhZGlhbnMoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiZGVnXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PU1hdGguUEkvMTgwKlNrLmJ1aWx0aW4uYXNudW0kKGUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJDb252ZXJ0IGFuZ2xlIHggZnJvbSBkZWdyZWVzIHRvIHJhZGlhbnMuXFxcIn0scmVtYWluZGVyOnskbWV0aDpmdW5jdGlvbiByZW1haW5kZXIoZSx0KXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKTtsZXQgbj1lLnYsaT10LnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBuJiYobj1lLm5iJGZsb2F0KCkudiksXFxcIm51bWJlclxcXCIhPXR5cGVvZiBpJiYoaT10Lm5iJGZsb2F0KCkudiksaXNGaW5pdGUobikmJmlzRmluaXRlKGkpKXtsZXQgZSx0LHIsdSxsO2lmKDA9PWkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtpZihlPU1hdGguYWJzKG4pLHQ9TWF0aC5hYnMoaSksdT1lJXQscj10LXUsdTxyKWw9dTtlbHNlIGlmKHU+cilsPS1yO2Vsc2V7aWYodSE9cil0aHJvdyBuZXcgU2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcjtsPXUtLjUqKGUtdSkldCoyfXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oZ2V0X3NpZ24obikqbCl9aWYoaXNOYU4obikpcmV0dXJuIGU7aWYoaXNOYU4oaSkpcmV0dXJuIHQ7aWYobj09MS8wfHxuPT0tMS8wKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoaSE9MS8wJiZpIT0tMS8wKXRocm93IG5ldyBTay5idWlsdGluLkFzc2VydGlvbkVycm9yO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiRGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHRoZSBjbG9zZXN0IGludGVnZXIgbXVsdGlwbGUgb2YgeS5cXFxcblxcXFxuUmV0dXJuIHggLSBuKnkgd2hlcmUgbip5IGlzIHRoZSBjbG9zZXN0IGludGVnZXIgbXVsdGlwbGUgb2YgeS5cXFxcbkluIHRoZSBjYXNlIHdoZXJlIHggaXMgZXhhY3RseSBoYWxmd2F5IGJldHdlZW4gdHdvIG11bHRpcGxlcyBvZlxcXFxueSwgdGhlIG5lYXJlc3QgZXZlbiB2YWx1ZSBvZiBuIGlzIHVzZWQuIFRoZSByZXN1bHQgaXMgYWx3YXlzIGV4YWN0LlxcXCJ9LHNpbjp7JG1ldGg6ZnVuY3Rpb24gc2luKGUpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLnNpbihTay5idWlsdGluLmFzbnVtJChlKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBzaW5lIG9mIHggKG1lYXN1cmVkIGluIHJhZGlhbnMpLlxcXCJ9LHNpbmg6eyRtZXRoOmZ1bmN0aW9uIHNpbmgoZSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSksZT1Tay5idWlsdGluLmFzbnVtJChlKTtjb25zdCB0PU1hdGguRSxuPU1hdGgucG93KHQsZSksaT0obi0xL24pLzI7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIHguXFxcIn0sc3FydDp7JG1ldGg6ZnVuY3Rpb24gc3FydChlKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKTtjb25zdCB0PVNrLmJ1aWx0aW4uYXNudW0kKGUpO2lmKHQ8MCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJtYXRoIGRvbWFpbiBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5zcXJ0KHQpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgc3F1YXJlIHJvb3Qgb2YgeC5cXFwifSx0YW46eyRtZXRoOmZ1bmN0aW9uIHRhbihlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC50YW4oU2suYnVpbHRpbi5hc251bSQoZSkpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgdGFuZ2VudCBvZiB4IChtZWFzdXJlZCBpbiByYWRpYW5zKS5cXFwifSx0YW5oOnskbWV0aDpmdW5jdGlvbiB0YW5oKGUpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpO2NvbnN0IHQ9U2suYnVpbHRpbi5hc251bSQoZSk7aWYoMD09PXQpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KTtjb25zdCBuPU1hdGguRSxpPU1hdGgucG93KG4sdCkscj0xL2ksdT0oaS1yKS8yLygoaStyKS8yKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHUpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgeC5cXFwifSx0cnVuYzp7JG1ldGg6ZnVuY3Rpb24gdHJ1bmMoZSl7aWYoZS5vYiR0eXBlPT09aSlyZXR1cm4gZS5uYiRpbnQoKTtjb25zdCBuPW8oZSx0LiR0cnVuYyk7aWYodm9pZCAwPT09bil0aHJvdyBuZXcgcihgdHlwZSAke2UudHAkbmFtZX0gZG9lc24ndCBkZWZpbmUgX190cnVuY19fIG1ldGhvZGApO3JldHVybiBhKG4pfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiVHJ1bmNhdGVzIHRoZSBSZWFsIHggdG8gdGhlIG5lYXJlc3QgSW50ZWdyYWwgdG93YXJkIDAuXFxcXG5cXFxcblVzZXMgdGhlIF9fdHJ1bmNfXyBtYWdpYyBtZXRob2QuXFxcIn19KSxzfTtcIixcInNyYy9saWIvb3BlcmF0b3IuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKGUpe2NvbnN0e2J1aWx0aW46e3N0cjp0LHR1cGxlOmEsbGlzdDpyLGludF86byxib29sOm4sVHlwZUVycm9yOnMsVmFsdWVFcnJvcjppLG5vbmU6e25vbmUkOm19LE5vdEltcGxlbWVudGVkOntOb3RJbXBsZW1lbnRlZCQ6ZH0sYWJzOmwsbGVuOmgsY2hlY2tTdHJpbmc6dSxjaGVja0ludDpjfSxhYnN0cjp7YnVpbGROYXRpdmVDbGFzczpNLGNoZWNrTm9Ld2FyZ3M6YixjaGVja0FyZ3NMZW46ZyxjaGVja09uZUFyZzpmLG51bWJlclVuYXJ5T3A6cCxudW1iZXJCaW5PcDpBLG51bWJlcklucGxhY2VCaW5PcDprLG9iamVjdEdldEl0ZW06JCxvYmplY3REZWxJdGVtOl8sb2JqZWN0U2V0SXRlbTp3LHNlcXVlbmNlQ29uY2F0OnYsc2VxdWVuY2VDb250YWluczp4LHNlcXVlbmNlR2V0Q291bnRPZjpqLHNlcXVlbmNlR2V0SW5kZXhPZjpPLHNlcXVlbmNlSW5QbGFjZUNvbmNhdDpJLHR5cGVOYW1lOlMsbG9va3VwU3BlY2lhbDp5LGdhdHRyOnEsc2V0VXBNb2R1bGVNZXRob2RzOlJ9LG1pc2NldmFsOntyaWNoQ29tcGFyZUJvb2w6Qixhc0luZGV4T3JUaHJvdzpOLGNoYWluOkUsY2FsbHNpbUFycmF5OlQsY2FsbHNpbU9yU3VzcGVuZEFycmF5OkMsb2JqZWN0UmVwcjpEfSxnZW5lcmljOntnZXRBdHRyOkd9fT1TayxMPVtcXFwiYWJzXFxcIixcXFwiYWRkXFxcIixcXFwiYW5kX1xcXCIsXFxcImNvbmNhdFxcXCIsXFxcImNvbnRhaW5zXFxcIixcXFwiZGVsaXRlbVxcXCIsXFxcImVxXFxcIixcXFwiZmxvb3JkaXZcXFwiLFxcXCJnZVxcXCIsXFxcImdldGl0ZW1cXFwiLFxcXCJndFxcXCIsXFxcImlhZGRcXFwiLFxcXCJpYW5kXFxcIixcXFwiaWNvbmNhdFxcXCIsXFxcImlmbG9vcmRpdlxcXCIsXFxcImlsc2hpZnRcXFwiLFxcXCJpbWF0bXVsXFxcIixcXFwiaW1vZFxcXCIsXFxcImltdWxcXFwiLFxcXCJpbmRleFxcXCIsXFxcImludlxcXCIsXFxcImludmVydFxcXCIsXFxcImlvclxcXCIsXFxcImlwb3dcXFwiLFxcXCJpcnNoaWZ0XFxcIixcXFwiaXN1YlxcXCIsXFxcIml0cnVlZGl2XFxcIixcXFwiaXhvclxcXCIsXFxcImxlXFxcIixcXFwibHNoaWZ0XFxcIixcXFwibHRcXFwiLFxcXCJtYXRtdWxcXFwiLFxcXCJtb2RcXFwiLFxcXCJtdWxcXFwiLFxcXCJuZVxcXCIsXFxcIm5lZ1xcXCIsXFxcIm5vdF9cXFwiLFxcXCJvcl9cXFwiLFxcXCJwb3NcXFwiLFxcXCJwb3dcXFwiLFxcXCJyc2hpZnRcXFwiLFxcXCJzZXRpdGVtXFxcIixcXFwic3ViXFxcIixcXFwidHJ1ZWRpdlxcXCIsXFxcInhvclxcXCJdLEY9W1xcXCJhdHRyZ2V0dGVyXFxcIixcXFwiY291bnRPZlxcXCIsXFxcImluZGV4T2ZcXFwiLFxcXCJpc19cXFwiLFxcXCJpc19ub3RcXFwiLFxcXCJpdGVtZ2V0dGVyXFxcIixcXFwibGVuZ3RoX2hpbnRcXFwiLFxcXCJtZXRob2RjYWxsZXJcXFwiLFxcXCJ0cnV0aFxcXCIsLi4uTF0uc29ydCgpLFA9e19fbmFtZV9fOm5ldyB0KFxcXCJvcGVyYXRvclxcXCIpLF9fZG9jX186bmV3IHQoXFxcIk9wZXJhdG9yIGludGVyZmFjZS5cXFxcblxcXFxuVGhpcyBtb2R1bGUgZXhwb3J0cyBhIHNldCBvZiBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgaW4gamF2YXNjcmlwdCBjb3JyZXNwb25kaW5nXFxcXG50byB0aGUgaW50cmluc2ljIG9wZXJhdG9ycyBvZiBQeXRob24uICBGb3IgZXhhbXBsZSwgb3BlcmF0b3IuYWRkKHgsIHkpXFxcXG5pcyBlcXVpdmFsZW50IHRvIHRoZSBleHByZXNzaW9uIHgreS4gIFRoZSBmdW5jdGlvbiBuYW1lcyBhcmUgdGhvc2VcXFxcbnVzZWQgZm9yIHNwZWNpYWwgbWV0aG9kczsgdmFyaWFudHMgd2l0aG91dCBsZWFkaW5nIGFuZCB0cmFpbGluZ1xcXFxuJ19fJyBhcmUgYWxzbyBwcm92aWRlZCBmb3IgY29udmVuaWVuY2UuXFxcIiksX19hbGxfXzpuZXcgcihGLm1hcCgoZT0+bmV3IHQoZSkpKSl9O1AuaXRlbWdldHRlcj1NKFxcXCJvcGVyYXRvci5pdGVtZ2V0dGVyXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gaXRlbWdldHRlcihlKXt0aGlzLml0ZW1zPWUsdGhpcy5vbmVpdGVtPTE9PT1lLmxlbmd0aCx0aGlzLml0ZW09ZVswXSx0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOkcsdHAkbmV3OihlLHQpPT4oYihcXFwiaXRlbWdldHRlclxcXCIsdCksZyhcXFwiaXRlbWdldHRlclxcXCIsZSwxKSxuZXcgUC5pdGVtZ2V0dGVyKGUpKSx0cCRjYWxsKGUsdCl7ZihcXFwiaXRlbWdldHRlclxcXCIsZSx0KTtjb25zdCByPWVbMF07cmV0dXJuIHRoaXMub25laXRlbT8kKHIsdGhpcy5pdGVtLCEwKTpuZXcgYSh0aGlzLml0ZW1zLm1hcCgoZT0+JChyLGUpKSkpfSx0cCRkb2M6XFxcIlJldHVybiBhIGNhbGxhYmxlIG9iamVjdCB0aGF0IGZldGNoZXMgdGhlIGdpdmVuIGl0ZW0ocykgZnJvbSBpdHMgb3BlcmFuZC5cXFxcbiAgICAgICAgICAgIEFmdGVyIGYgPSBpdGVtZ2V0dGVyKDIpLCB0aGUgY2FsbCBmKHIpIHJldHVybnMgclsyXS5cXFxcbiAgICAgICAgICAgIEFmdGVyIGcgPSBpdGVtZ2V0dGVyKDIsIDUsIDMpLCB0aGUgY2FsbCBnKHIpIHJldHVybnMgKHJbMl0sIHJbNV0sIHJbM10pXFxcIiwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IHQodGhpcy50cCRuYW1lK1xcXCIoLi4uKVxcXCIpO3RoaXMuaW4kcmVwcj0hMDtjb25zdCBlPXRoaXMudHAkbmFtZStcXFwiKFxcXCIrdGhpcy5pdGVtcy5tYXAoKGU9PkQoZSkpKS5qb2luKFxcXCIsIFxcXCIpK1xcXCIpXFxcIjtyZXR1cm4gdGhpcy5pbiRyZXByPSExLGV9fX0pLFAuYXR0cmdldHRlcj1NKFxcXCJvcGVyYXRvci5hdHRyZ2V0dGVyXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gYXR0cmdldHRlcihlKXt0aGlzLmF0dHJzPWUsdGhpcy5vbmVhdHRyPTE9PT1lLmxlbmd0aCx0aGlzLmF0dHI9ZVswXSx0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOkcsdHAkbmV3KGUsYSl7YihcXFwiYXR0cmdldHRlclxcXCIsYSksZyhcXFwiYXR0cmdldHRlclxcXCIsZSwxKTtjb25zdCByPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bysrKXtjb25zdCBhPWVbb107aWYoIXUoYSkpdGhyb3cgbmV3IHMoXFxcImF0dHJpYnV0ZSBuYW1lIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtjb25zdCBuPWEudG9TdHJpbmcoKTtuLmluY2x1ZGVzKFxcXCIuXFxcIik/ci5wdXNoKG4uc3BsaXQoXFxcIi5cXFwiKS5tYXAoKGU9Pm5ldyB0KGUpKSkpOnIucHVzaChbYV0pfXJldHVybiBuZXcgUC5hdHRyZ2V0dGVyKHIpfSx0cCRjYWxsKGUsdCl7ZihcXFwiYXR0cmdldHRlclxcXCIsZSx0KTtjb25zdCByPWVbMF07aWYodGhpcy5vbmVhdHRyKXJldHVybiB0aGlzLmF0dHIucmVkdWNlKCgoZSx0KT0+cShlLHQpKSxyKTtjb25zdCBvPXRoaXMuYXR0cnMubWFwKChlPT5lLnJlZHVjZSgoKGUsdCk9PnEoZSx0KSkscikpKTtyZXR1cm4gbmV3IGEobyl9LHRwJGRvYzpcXFwiYXR0cmdldHRlcihhdHRyLCAuLi4pIC0tXFxcXHgzZSBhdHRyZ2V0dGVyIG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gYSBjYWxsYWJsZSBvYmplY3QgdGhhdCBmZXRjaGVzIHRoZSBnaXZlbiBhdHRyaWJ1dGUocykgZnJvbSBpdHMgb3BlcmFuZC5cXFxcbkFmdGVyIGYgPSBhdHRyZ2V0dGVyKCduYW1lJyksIHRoZSBjYWxsIGYocikgcmV0dXJucyByLm5hbWUuXFxcXG5BZnRlciBnID0gYXR0cmdldHRlcignbmFtZScsICdkYXRlJyksIHRoZSBjYWxsIGcocikgcmV0dXJucyAoci5uYW1lLCByLmRhdGUpLlxcXFxuQWZ0ZXIgaCA9IGF0dHJnZXR0ZXIoJ25hbWUuZmlyc3QnLCAnbmFtZS5sYXN0JyksIHRoZSBjYWxsIGgocikgcmV0dXJuc1xcXFxuKHIubmFtZS5maXJzdCwgci5uYW1lLmxhc3QpLlxcXCIsJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyB0KHRoaXMudHAkbmFtZStcXFwiKC4uLilcXFwiKTt0aGlzLmluJHJlcHI9ITA7Y29uc3QgZT10aGlzLnRwJG5hbWUrXFxcIihcXFwiK3RoaXMuaXRlbXMubWFwKChlPT5EKGUpKSkuam9pbihcXFwiLCBcXFwiKStcXFwiKVxcXCI7cmV0dXJuIHRoaXMuaW4kcmVwcj0hMSxlfX19KSxQLm1ldGhvZGNhbGxlcj1NKFxcXCJvcGVyYXRvci5tZXRob2RjYWxsZXJcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBtZXRob2RjYWxsZXIoZSx0LGEpe3RoaXMuJG5hbWU9ZSx0aGlzLmFyZ3M9dCx0aGlzLmt3YXJncz1hfHxbXSx0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOkcsdHAkbmV3KGUsdCl7ZyhcXFwibWV0aG9kY2FsbGVyXFxcIixlLDEpO2NvbnN0IGE9ZVswXTtpZighdShhKSl0aHJvdyBuZXcgcyhcXFwibWV0aG9kIG5hbWUgbXVzdCBiZSBhIHN0cmluZ1xcXCIpO3JldHVybiBuZXcgUC5tZXRob2RjYWxsZXIoYSxlLnNsaWNlKDEpLHQpfSx0cCRjYWxsKGUsdCl7ZihcXFwibWV0aG9kY2FsbGVyXFxcIixlLHQpO2NvbnN0IGE9ZVswXTtyZXR1cm4gRShxKGEsdGhpcy4kbmFtZSwhMCksKGU9PkMoZSx0aGlzLmFyZ3MsdGhpcy5rd2FyZ3MpKSl9LHRwJGRvYzpcXFwibWV0aG9kY2FsbGVyKG5hbWUsIC4uLikgLS1cXFxceDNlIG1ldGhvZGNhbGxlciBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGEgY2FsbGFibGUgb2JqZWN0IHRoYXQgY2FsbHMgdGhlIGdpdmVuIG1ldGhvZCBvbiBpdHMgb3BlcmFuZC5cXFxcbkFmdGVyIGYgPSBtZXRob2RjYWxsZXIoJ25hbWUnKSwgdGhlIGNhbGwgZihyKSByZXR1cm5zIHIubmFtZSgpLlxcXFxuQWZ0ZXIgZyA9IG1ldGhvZGNhbGxlcignbmFtZScsICdkYXRlJywgZm9vPTEpLCB0aGUgY2FsbCBnKHIpIHJldHVybnNcXFxcbnIubmFtZSgnZGF0ZScsIGZvbz0xKS5cXFwiLCRyKCl7aWYodGhpcy5pbiRyZXByKXJldHVybiBuZXcgdCh0aGlzLnRwJG5hbWUrXFxcIiguLi4pXFxcIik7dGhpcy5pbiRyZXByPSEwO2xldCBlPVtEKHRoaXMuJG5hbWUpXTtlLnB1c2goLi4udGhpcy5hcmdzLm1hcCgoZT0+RChlKSkpKTtmb3IobGV0IHQ9MDt0PHRoaXMua3dhcmdzLmxlbmd0aDt0Kz0yKWUucHVzaCh0aGlzLmt3YXJnc1t0XStcXFwiPVxcXCIrRCh0aGlzLmt3YXJnc1t0KzFdKSk7cmV0dXJuIGU9dGhpcy50cCRuYW1lK1xcXCIoXFxcIitlLmpvaW4oXFxcIiwgXFxcIikrXFxcIilcXFwiLHRoaXMuaW4kcmVwcj0hMSxlfX19KTtjb25zdCBVPXsxOnskZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCAvKVxcXCJ9LDI6eyRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCJ9LDM6eyRmbGFnczp7TWluQXJnczozLE1heEFyZ3M6M30sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCBjLCAvKVxcXCJ9fTtmdW5jdGlvbiBtYWtlTW9kdWxlTWV0aG9kKGUsdCl7cmV0dXJueyRtZXRoOmUsJGRvYzp0LC4uLlVbZS5sZW5ndGhdfX1mdW5jdGlvbiBzYW1lQXMoZSl7cmV0dXJuXFxcIlNhbWUgYXMgXFxcIitlK1xcXCIuXFxcIn1yZXR1cm4gUihcXFwib3BlcmF0b3JcXFwiLFAse2x0Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJMdFxcXCIpKSksc2FtZUFzKFxcXCJhIDwgYlxcXCIpKSxsZTptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+bihCKGUsdCxcXFwiTHRFXFxcIikpKSxzYW1lQXMoXFxcImEgPD0gYlxcXCIpKSxlcTptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+bihCKGUsdCxcXFwiRXFcXFwiKSkpLHNhbWVBcyhcXFwiYSA9PSBiXFxcIikpLG5lOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJOb3RFcVxcXCIpKSksc2FtZUFzKFxcXCJhICE9IGJcXFwiKSksZ2U6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9Pm4oQihlLHQsXFxcIkd0RVxcXCIpKSksc2FtZUFzKFxcXCJhID49IGJcXFwiKSksZ3Q6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9Pm4oQihlLHQsXFxcIkd0XFxcIikpKSxzYW1lQXMoXFxcImEgPiBiXFxcIikpLG5vdF86bWFrZU1vZHVsZU1ldGhvZCgoZT0+cChlLFxcXCJOb3RcXFwiKSksc2FtZUFzKFxcXCJub3QgYVxcXCIpKSx0cnV0aDptYWtlTW9kdWxlTWV0aG9kKChlPT5uKGUpKSxcXFwiUmV0dXJuIFRydWUgaWYgYSBpcyB0cnVlLCBGYWxzZSBvdGhlcndpc2UuXFxcIiksaXNfOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJJc1xcXCIpKSksc2FtZUFzKFxcXCJhIGlzIGJcXFwiKSksaXNfbm90Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5uKEIoZSx0LFxcXCJJc05vdFxcXCIpKSksc2FtZUFzKFxcXCJhIGlzIG5vdCBiXFxcIikpLGFiczptYWtlTW9kdWxlTWV0aG9kKChlPT5sKGUpKSxzYW1lQXMoXFxcImFicyhhKVxcXCIpKSxhZGQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJBZGRcXFwiKSksc2FtZUFzKFxcXCJhICsgYlxcXCIpKSxhbmRfOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5BKGUsdCxcXFwiQml0QW5kXFxcIikpLHNhbWVBcyhcXFwiYSAmIGJcXFwiKSksZmxvb3JkaXY6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJGbG9vckRpdlxcXCIpKSxzYW1lQXMoXFxcImEgLy8gYlxcXCIpKSxpbmRleDptYWtlTW9kdWxlTWV0aG9kKChlPT5uZXcgbyhOKGUpKSksc2FtZUFzKFxcXCJhLl9faW5kZXhfXygpXFxcIikpLGludjptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIkludmVydFxcXCIpKSxzYW1lQXMoXFxcIn5hXFxcIikpLGludmVydDptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIkludmVydFxcXCIpKSxzYW1lQXMoXFxcIn5hXFxcIikpLGxzaGlmdDptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+QShlLHQsXFxcIkxTaGlmdFxcXCIpKSxzYW1lQXMoXFxcImEgPDwgYlxcXCIpKSxtb2Q6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJNb2RcXFwiKSksc2FtZUFzKFxcXCJhICUgYlxcXCIpKSxtdWw6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJNdWx0XFxcIikpLHNhbWVBcyhcXFwiYSAqIGJcXFwiKSksbWF0bXVsOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5BKGUsdCxcXFwiTWF0TXVsdFxcXCIpKSxzYW1lQXMoXFxcImEgQCBiXFxcIikpLG5lZzptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIlVTdWJcXFwiKSksc2FtZUFzKFxcXCItYVxcXCIpKSxvcl86bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJCaXRPclxcXCIpKSxzYW1lQXMoXFxcImEgfCBiXFxcIikpLHBvczptYWtlTW9kdWxlTWV0aG9kKChlPT5wKGUsXFxcIlVBZGRcXFwiKSksc2FtZUFzKFxcXCIrYVxcXCIpKSxwb3c6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJQb3dcXFwiKSksc2FtZUFzKFxcXCJhICoqIGJcXFwiKSkscnNoaWZ0Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5BKGUsdCxcXFwiUlNoaWZ0XFxcIikpLHNhbWVBcyhcXFwiYSA+PiBiXFxcIikpLHN1YjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+QShlLHQsXFxcIlN1YlxcXCIpKSxzYW1lQXMoXFxcImEgLSBiXFxcIikpLHRydWVkaXY6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJEaXZcXFwiKSksc2FtZUFzKFxcXCJhIC8gYlxcXCIpKSx4b3I6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PkEoZSx0LFxcXCJCaXRYb3JcXFwiKSksc2FtZUFzKFxcXCJhIF4gYlxcXCIpKSxjb25jYXQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PnYoZSx0KSksc2FtZUFzKFxcXCJhICsgYiwgZm9yIGEgYW5kIGIgc2VxdWVuY2VzXFxcIikpLGNvbnRhaW5zOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5FKHgoZSx0KSxuKSksc2FtZUFzKFxcXCJiIGluIGEgKG5vdGUgcmV2ZXJzZWQgb3BlcmFuZHMpXFxcIikpLGNvdW50T2Y6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmooZSx0KSksXFxcIlJldHVybiB0aGVudW1iZXIgb2YgdGltZXMgYiBvY2N1cnMgaW4gYS5cXFwiKSxkZWxpdGVtOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5FKF8oZSx0LCEwKSwoKCk9Pm0pKSksc2FtZUFzKFxcXCJkZWwgYVtiXVxcXCIpKSxnZXRpdGVtOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT4kKGUsdCwhMCkpLHNhbWVBcyhcXFwiYVtiXVxcXCIpKSxpbmRleE9mOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5PKGUsdCkpLFxcXCJSZXR1cm4gdGhlIGZpcnN0IGluZGV4IG9mIGIgaW4gYVxcXCIpLHNldGl0ZW06bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCxhKT0+RSh3KGUsdCxhLCEwKSwoKCk9Pm0pKSksc2FtZUFzKFxcXCJhW2JdID0gY1xcXCIpKSxsZW5ndGhfaGludDp7JG1ldGg6ZnVuY3Rpb24gbGVuZ3RoX2hpbnQoZSxhKXtpZih2b2lkIDA9PT1hKWE9bmV3IG8oMCk7ZWxzZSBpZighYyhhKSl0aHJvdyBuZXcgcyhcXFwiJ1xcXCIrUyhhKStcXFwiJyBvYmplY3QgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGFuIGludGVnZXJcXFwiKTt0cnl7cmV0dXJuIGgoZSl9Y2F0Y2gobSl7aWYoIShtIGluc3RhbmNlb2YgcykpdGhyb3cgbX1jb25zdCByPXkoZSx0LiRsZW5ndGhfaGludCk7aWYodm9pZCAwPT09cilyZXR1cm4gYTtsZXQgbjt0cnl7bj1UKHIsW10pfWNhdGNoKG0pe2lmKCEobSBpbnN0YW5jZW9mIHMpKXRocm93IG07cmV0dXJuIGF9aWYobj09PWQpcmV0dXJuIGE7aWYoIWMobikpdGhyb3cgbmV3IHMoXFxcIl9fbGVuZ3RoX2hpbnRfXyBtdXN0IGJlIGFuIGludGVnZXIsIG5vdCBcXFwiK1MobikpO2lmKG4ubmIkaXNuZWdhdGl2ZSgpKXRocm93IG5ldyBpKFxcXCJfX2xlbmd0aF9oaW50X18oKSBzaG91bGQgcmV0dXJuID49IDBcXFwiKTtyZXR1cm4gbn0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIG9iaiwgZGVmYXVsdD0wLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIGFuIGVzdGltYXRlIG9mIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gb2JqLlxcXFxuXFxcXG5UaGlzIGlzIHVzZWZ1bCBmb3IgcHJlc2l6aW5nIGNvbnRhaW5lcnMgd2hlbiBidWlsZGluZyBmcm9tIGFuIGl0ZXJhYmxlLlxcXFxuXFxcXG5JZiB0aGUgb2JqZWN0IHN1cHBvcnRzIGxlbigpLCB0aGUgcmVzdWx0IHdpbGwgYmUgZXhhY3QuXFxcXG5PdGhlcndpc2UsIGl0IG1heSBvdmVyLSBvciB1bmRlci1lc3RpbWF0ZSBieSBhbiBhcmJpdHJhcnkgYW1vdW50LlxcXFxuVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGludGVnZXIgPj0gMC5cXFwifSxpYWRkOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5rKGUsdCxcXFwiQWRkXFxcIikpLHNhbWVBcyhcXFwiYSArPSBiXFxcIikpLGlhbmQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJCaXRBbmRcXFwiKSksc2FtZUFzKFxcXCJhICY9IGJcXFwiKSksaWNvbmNhdDptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+SShlLHQpKSxzYW1lQXMoXFxcImEgKz0gYiwgZm9yIGEgYW5kIGIgc2VxdWVuY2VzXFxcIikpLGlmbG9vcmRpdjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+ayhlLHQsXFxcIkZsb29yRGl2XFxcIikpLHNhbWVBcyhcXFwiYSAvLz0gYlxcXCIpKSxpbHNoaWZ0Om1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5rKGUsdCxcXFwiTFNoaWZ0XFxcIikpLHNhbWVBcyhcXFwiYSA8PD0gYlxcXCIpKSxpbW9kOm1ha2VNb2R1bGVNZXRob2QoKChlLHQpPT5rKGUsdCxcXFwiTW9kXFxcIikpLHNhbWVBcyhcXFwiYSAlPSBiXFxcIikpLGltdWw6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJNdWx0XFxcIikpLHNhbWVBcyhcXFwiYSAqPSBiXFxcIikpLGltYXRtdWw6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJNYXRNdWx0XFxcIikpLHNhbWVBcyhcXFwiYSBAPSBiXFxcIikpLGlvcjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+ayhlLHQsXFxcIkJpdE9yXFxcIikpLHNhbWVBcyhcXFwiYSB8PSBiXFxcIikpLGlwb3c6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJQb3dcXFwiKSksc2FtZUFzKFxcXCJhICoqPSBiXFxcIikpLGlyc2hpZnQ6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJSU2hpZnRcXFwiKSksc2FtZUFzKFxcXCJhID4+PSBiXFxcIikpLGlzdWI6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJTdWJcXFwiKSksc2FtZUFzKFxcXCJhIC09IGJcXFwiKSksaXRydWVkaXY6bWFrZU1vZHVsZU1ldGhvZCgoKGUsdCk9PmsoZSx0LFxcXCJEaXZcXFwiKSksc2FtZUFzKFxcXCJhIC89IGJcXFwiKSksaXhvcjptYWtlTW9kdWxlTWV0aG9kKCgoZSx0KT0+ayhlLHQsXFxcIkJpdFhvclxcXCIpKSxzYW1lQXMoXFxcImEgXj0gYlxcXCIpKX0pLEwuZm9yRWFjaCgoZT0+e1BbYF9fJHtlLnJlcGxhY2UoXFxcIl9cXFwiLFxcXCJcXFwiKX1fX2BdPVBbZV19KSksUC5kaXY9UC50cnVlZGl2LFAuX19kaXZfXz1QLmRpdixQfVwiLFwic3JjL2xpYi9wbGF0Zm9ybS5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG4pe3ZhciBlPXt9LGk9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3cmJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93Lm5hdmlnYXRvcjtyZXR1cm4gZS5weXRob25faW1wbGVtZW50YXRpb249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicHl0aG9uX2ltcGxlbWVudGF0aW9uXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMCksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJTa3VscHRcXFwiKX0pKSxlLm5vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwibm9kZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApLG5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIil9KSksZS52ZXJzaW9uPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInZlcnNpb25cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIlxcXCIpfSkpLGUucHl0aG9uX3ZlcnNpb249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicHl0aG9uX3ZlcnNpb25cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPVNrLl9fZnV0dXJlX18ucHl0aG9uX3ZlcnNpb24/XFxcIjMuMi4wXFxcIjpcXFwiMi43LjBcXFwiLG5ldyBTay5idWlsdGluLnN0cihuKX0pKSxlLnN5c3RlbT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3ZhciBuO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzeXN0ZW1cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPWk/d2luZG93Lm5hdmlnYXRvci5hcHBDb2RlTmFtZTpcXFwiXFxcIixuZXcgU2suYnVpbHRpbi5zdHIobil9KSksZS5tYWNoaW5lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm1hY2hpbmVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPWk/d2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybTpcXFwiXFxcIixuZXcgU2suYnVpbHRpbi5zdHIobil9KSksZS5yZWxlYXNlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInJlbGVhc2VcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuPWk/d2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uOlxcXCJcXFwiLG5ldyBTay5idWlsdGluLnN0cihuKX0pKSxlLmFyY2hpdGVjdHVyZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJhcmNoaXRlY3R1cmVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCI2NGJpdFxcXCIpLG5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIildKX0pKSxlLnByb2Nlc3Nvcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJwcm9jZXNzb3JcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIlxcXCIpfSkpLGV9O1wiLFwic3JjL2xpYi9wcm9jZXNzaW5nLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7dmFyIGksZSx0LHUsbyxzLGwsYz17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJwcm9jZXNzaW5nXFxcIil9LHI9W10sdj0hMCxmPW51bGw7Yy5wcm9jZXNzaW5nPW51bGwsYy5wPW51bGwsYy5YPW5ldyBTay5idWlsdGluLmludF8oMCksYy5ZPW5ldyBTay5idWlsdGluLmludF8oMSksYy5aPW5ldyBTay5idWlsdGluLmludF8oMiksYy5SPW5ldyBTay5idWlsdGluLmludF8oMyksYy5HPW5ldyBTay5idWlsdGluLmludF8oNCksYy5CPW5ldyBTay5idWlsdGluLmludF8oNSksYy5BPW5ldyBTay5idWlsdGluLmludF8oNiksYy5VPW5ldyBTay5idWlsdGluLmludF8oNyksYy5WPW5ldyBTay5idWlsdGluLmludF8oOCksYy5OWD1uZXcgU2suYnVpbHRpbi5pbnRfKDkpLGMuTlk9bmV3IFNrLmJ1aWx0aW4uaW50XygxMCksYy5OWj1uZXcgU2suYnVpbHRpbi5pbnRfKDExKSxjLkVER0U9bmV3IFNrLmJ1aWx0aW4uaW50XygxMiksYy5TUj1uZXcgU2suYnVpbHRpbi5pbnRfKDEzKSxjLlNHPW5ldyBTay5idWlsdGluLmludF8oMTQpLGMuU0I9bmV3IFNrLmJ1aWx0aW4uaW50XygxNSksYy5TQT1uZXcgU2suYnVpbHRpbi5pbnRfKDE2KSxjLlNXPW5ldyBTay5idWlsdGluLmludF8oMTcpLGMuVFg9bmV3IFNrLmJ1aWx0aW4uaW50XygxOCksYy5UWT1uZXcgU2suYnVpbHRpbi5pbnRfKDE5KSxjLlRaPW5ldyBTay5idWlsdGluLmludF8oMjApLGMuVlg9bmV3IFNrLmJ1aWx0aW4uaW50XygyMSksYy5WWT1uZXcgU2suYnVpbHRpbi5pbnRfKDIyKSxjLlZaPW5ldyBTay5idWlsdGluLmludF8oMjMpLGMuVlc9bmV3IFNrLmJ1aWx0aW4uaW50XygyNCksYy5BUj1uZXcgU2suYnVpbHRpbi5pbnRfKDI1KSxjLkFHPW5ldyBTay5idWlsdGluLmludF8oMjYpLGMuQUI9bmV3IFNrLmJ1aWx0aW4uaW50XygyNyksYy5EUj1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuREc9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxjLkRCPW5ldyBTay5idWlsdGluLmludF8oNSksYy5EQT1uZXcgU2suYnVpbHRpbi5pbnRfKDYpLGMuU1BSPW5ldyBTay5idWlsdGluLmludF8oMjgpLGMuU1BHPW5ldyBTay5idWlsdGluLmludF8oMjkpLGMuU1BCPW5ldyBTay5idWlsdGluLmludF8oMzApLGMuU0hJTkU9bmV3IFNrLmJ1aWx0aW4uaW50XygzMSksYy5FUj1uZXcgU2suYnVpbHRpbi5pbnRfKDMyKSxjLkVHPW5ldyBTay5idWlsdGluLmludF8oMzMpLGMuRUI9bmV3IFNrLmJ1aWx0aW4uaW50XygzNCksYy5CRUVOX0xJVD1uZXcgU2suYnVpbHRpbi5pbnRfKDM1KSxjLlZFUlRFWF9GSUVMRF9DT1VOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDM2KSxjLkNFTlRFUj1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuUkFESVVTPW5ldyBTay5idWlsdGluLmludF8oMiksYy5DT1JORVJTPW5ldyBTay5idWlsdGluLmludF8oMSksYy5DT1JORVI9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkRJQU1FVEVSPW5ldyBTay5idWlsdGluLmludF8oMyksYy5CQVNFTElORT1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuVE9QPW5ldyBTay5idWlsdGluLmludF8oMTAxKSxjLkJPVFRPTT1uZXcgU2suYnVpbHRpbi5pbnRfKDEwMiksYy5OT1JNQUw9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLk5PUk1BTElaRUQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLklNQUdFPW5ldyBTay5idWlsdGluLmludF8oMiksYy5NT0RFTD1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGMuU0hBUEU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1KSxjLkFNQklFTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkRJUkVDVElPTkFMPW5ldyBTay5idWlsdGluLmludF8oMSksYy5TUE9UPW5ldyBTay5idWlsdGluLmludF8oMyksYy5SR0I9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkFSR0I9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLkhTQj1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuQUxQSEE9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxjLkNNWUs9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1KSxjLlRJRkY9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLlRBUkdBPW5ldyBTay5idWlsdGluLmludF8oMSksYy5KUEVHPW5ldyBTay5idWlsdGluLmludF8oMiksYy5HSUY9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxjLk1JVEVSPW5ldyBTay5idWlsdGluLnN0cihcXFwibWl0ZXJcXFwiKSxjLkJFVkVMPW5ldyBTay5idWlsdGluLnN0cihcXFwiYmV2ZWxcXFwiKSxjLlJPVU5EPW5ldyBTay5idWlsdGluLnN0cihcXFwicm91bmRcXFwiKSxjLlNRVUFSRT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcImJ1dHRcXFwiKSxjLlBST0pFQ1Q9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJzcXVhcmVcXFwiKSxjLlAyRD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGMuSkFWQTJEPW5ldyBTay5idWlsdGluLmludF8oMSksYy5XRUJHTD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuUDNEPW5ldyBTay5idWlsdGluLmludF8oMiksYy5PUEVOR0w9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLlBERj1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuRFhGPW5ldyBTay5idWlsdGluLmludF8oMCksYy5PVEhFUj1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuV0lORE9XUz1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGMuTUFYT1NYPW5ldyBTay5idWlsdGluLmludF8oMiksYy5MSU5VWD1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuRVBTSUxPTj1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMWUtNCksYy5NQVhfRkxPQVQ9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDM0MDI4MjM1ZTMxKSxjLk1JTl9GTE9BVD1uZXcgU2suYnVpbHRpbi5mbG9hdF8oLTM0MDI4MjM1ZTMxKSxjLk1BWF9JTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygyMTQ3NDgzNjQ3KSxjLk1JTl9JTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygtMjE0NzQ4MzY0OCksYy5IQUxGX1BJPW5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLlBJLzIpLGMuVEhJUkRfUEk9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguUEkvMyksYy5QST1uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5QSSksYy5UV09fUEk9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDIqTWF0aC5QSSksYy5UQVU9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDIqTWF0aC5QSSksYy5RVUFSVEVSX1BJPW5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLlBJLzQpLGMuREVHX1RPX1JBRD1uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5QSS8xODApLGMuUkFEX1RPX0RFRz1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMTgwL01hdGguUEkpLGMuV0hJVEVTUEFDRT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIiBcXFxcdFxcXFxuXFxcXHJcXFxcZsKgXFxcIiksYy5QT0lOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuUE9JTlRTPW5ldyBTay5idWlsdGluLmludF8oMiksYy5MSU5FPW5ldyBTay5idWlsdGluLmludF8oNCksYy5MSU5FUz1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGMuVFJJQU5HTEU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg4KSxjLlRSSUFOR0xFUz1uZXcgU2suYnVpbHRpbi5pbnRfKDkpLGMuVFJJQU5HTEVfRkFOPW5ldyBTay5idWlsdGluLmludF8oMTEpLGMuVFJJQU5HTEVfU1RSSVA9bmV3IFNrLmJ1aWx0aW4uaW50XygxMCksYy5RVUFEPW5ldyBTay5idWlsdGluLmludF8oMTYpLGMuUVVBRFM9bmV3IFNrLmJ1aWx0aW4uaW50XygxNiksYy5RVUFEX1NUUklQPW5ldyBTay5idWlsdGluLmludF8oMTcpLGMuUE9MWUdPTj1uZXcgU2suYnVpbHRpbi5pbnRfKDIwKSxjLlBBVEg9bmV3IFNrLmJ1aWx0aW4uaW50XygyMSksYy5SRUNUPW5ldyBTay5idWlsdGluLmludF8oMzApLGMuRUxMSVBTRT1uZXcgU2suYnVpbHRpbi5pbnRfKDMxKSxjLkFSQz1uZXcgU2suYnVpbHRpbi5pbnRfKDMyKSxjLlNQSEVSRT1uZXcgU2suYnVpbHRpbi5pbnRfKDQwKSxjLkJPWD1uZXcgU2suYnVpbHRpbi5pbnRfKDQxKSxjLkdST1VQPW5ldyBTay5idWlsdGluLmludF8oMCksYy5QUklNSVRJVkU9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkdFT01FVFJZPW5ldyBTay5idWlsdGluLmludF8oMyksYy5WRVJURVg9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkJFWklFUl9WRVJURVg9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkNVUlZFX1ZFUlRFWD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuQlJFQUs9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxjLkNMT1NFU0hBUEU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxjLlJFUExBQ0U9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLkJMRU5EPW5ldyBTay5idWlsdGluLmludF8oMSksYy5BREQ9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLlNVQlRSQUNUPW5ldyBTay5idWlsdGluLmludF8oNCksYy5MSUdIVEVTVD1uZXcgU2suYnVpbHRpbi5pbnRfKDgpLGMuREFSS0VTVD1uZXcgU2suYnVpbHRpbi5pbnRfKDE2KSxjLkRJRkZFUkVOQ0U9bmV3IFNrLmJ1aWx0aW4uaW50XygzMiksYy5FWENMVVNJT049bmV3IFNrLmJ1aWx0aW4uaW50Xyg2NCksYy5NVUxUSVBMWT1uZXcgU2suYnVpbHRpbi5pbnRfKDEyOCksYy5TQ1JFRU49bmV3IFNrLmJ1aWx0aW4uaW50XygyNTYpLGMuT1ZFUkxBWT1uZXcgU2suYnVpbHRpbi5pbnRfKDUxMiksYy5IQVJEX0xJR0hUPW5ldyBTay5idWlsdGluLmludF8oMTAyNCksYy5TT0ZUX0xJR0hUPW5ldyBTay5idWlsdGluLmludF8oMjA0OCksYy5ET0RHRT1uZXcgU2suYnVpbHRpbi5pbnRfKDQwOTYpLGMuQlVSTj1uZXcgU2suYnVpbHRpbi5pbnRfKDgxOTIpLGMuQUxQSEFfTUFTSz1uZXcgU2suYnVpbHRpbi5pbnRfKDQyNzgxOTAwODApLGMuUkVEX01BU0s9bmV3IFNrLmJ1aWx0aW4uaW50XygxNjcxMTY4MCksYy5HUkVFTl9NQVNLPW5ldyBTay5idWlsdGluLmludF8oNjUyODApLGMuQkxVRV9NQVNLPW5ldyBTay5idWlsdGluLmludF8oMjU1KSxjLkNVU1RPTT1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMuT1JUSE9HUkFQSElDPW5ldyBTay5idWlsdGluLmludF8oMiksYy5QRVJTUEVDVElWRT1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGMuQVJST1c9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJkZWZhdWx0XFxcIiksYy5DUk9TUz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcImNyb3NzaGFpclxcXCIpLGMuSEFORD1uZXcgU2suYnVpbHRpbi5zdHIoXFxcInBvaW50ZXJcXFwiKSxjLk1PVkU9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJtb3ZlXFxcIiksYy5URVhUPW5ldyBTay5idWlsdGluLnN0cihcXFwidGV4dFxcXCIpLGMuV0FJVD1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIndhaXRcXFwiKSxjLk5PQ1VSU09SPVNrLmJ1aWx0aW4uYXNzayQoXFxcInVybCgnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBUC8vL3dBQUFDSDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUNSQUVBT3c9PScpLCBhdXRvXFxcIiksYy5ESVNBQkxFX09QRU5HTF8yWF9TTU9PVEg9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxjLkVOQUJMRV9PUEVOR0xfMlhfU01PT1RIPW5ldyBTay5idWlsdGluLmludF8oLTEpLGMuRU5BQkxFX09QRU5HTF80WF9TTU9PVEg9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxjLkVOQUJMRV9OQVRJVkVfRk9OVFM9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxjLkRJU0FCTEVfREVQVEhfVEVTVD1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGMuRU5BQkxFX0RFUFRIX1RFU1Q9bmV3IFNrLmJ1aWx0aW4uaW50XygtNCksYy5FTkFCTEVfREVQVEhfU09SVD1uZXcgU2suYnVpbHRpbi5pbnRfKDUpLGMuRElTQUJMRV9ERVBUSF9TT1JUPW5ldyBTay5idWlsdGluLmludF8oLTUpLGMuRElTQUJMRV9PUEVOR0xfRVJST1JfUkVQT1JUPW5ldyBTay5idWlsdGluLmludF8oNiksYy5FTkFCTEVfT1BFTkdMX0VSUk9SX1JFUE9SVD1uZXcgU2suYnVpbHRpbi5pbnRfKC02KSxjLkVOQUJMRV9BQ0NVUkFURV9URVhUVVJFUz1uZXcgU2suYnVpbHRpbi5pbnRfKDcpLGMuRElTQUJMRV9BQ0NVUkFURV9URVhUVVJFUz1uZXcgU2suYnVpbHRpbi5pbnRfKC03KSxjLkhJTlRfQ09VTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxMCksYy5PUEVOPW5ldyBTay5idWlsdGluLmludF8oMSksYy5DTE9TRT1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGMuQkxVUj1uZXcgU2suYnVpbHRpbi5pbnRfKDExKSxjLkdSQVk9bmV3IFNrLmJ1aWx0aW4uaW50XygxMiksYy5JTlZFUlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxMyksYy5PUEFRVUU9bmV3IFNrLmJ1aWx0aW4uaW50XygxNCksYy5QT1NURVJJWkU9bmV3IFNrLmJ1aWx0aW4uaW50XygxNSksYy5USFJFU0hPTEQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxNiksYy5FUk9ERT1uZXcgU2suYnVpbHRpbi5pbnRfKDE3KSxjLkRJTEFURT1uZXcgU2suYnVpbHRpbi5pbnRfKDE4KSxjLkJBQ0tTUEFDRT1uZXcgU2suYnVpbHRpbi5pbnRfKDgpLGMuVEFCPW5ldyBTay5idWlsdGluLmludF8oOSksYy5FTlRFUj1uZXcgU2suYnVpbHRpbi5pbnRfKDEwKSxjLlJFVFVSTj1uZXcgU2suYnVpbHRpbi5pbnRfKDEzKSxjLkVTQz1uZXcgU2suYnVpbHRpbi5pbnRfKDI3KSxjLkRFTEVURT1uZXcgU2suYnVpbHRpbi5pbnRfKDEyNyksYy5DT0RFRD1uZXcgU2suYnVpbHRpbi5pbnRfKDY1NTM1KSxjLlNISUZUPW5ldyBTay5idWlsdGluLmludF8oMTYpLGMuQ09OVFJPTD1uZXcgU2suYnVpbHRpbi5pbnRfKDE3KSxjLkFMVD1uZXcgU2suYnVpbHRpbi5pbnRfKDE4KSxjLkNBUFNMSz1uZXcgU2suYnVpbHRpbi5pbnRfKDIwKSxjLlBHVVA9bmV3IFNrLmJ1aWx0aW4uaW50XygzMyksYy5QR0ROPW5ldyBTay5idWlsdGluLmludF8oMzQpLGMuRU5EPW5ldyBTay5idWlsdGluLmludF8oMzUpLGMuSE9NRT1uZXcgU2suYnVpbHRpbi5pbnRfKDM2KSxjLkxFRlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygzNyksYy5VUD1uZXcgU2suYnVpbHRpbi5pbnRfKDM4KSxjLlJJR0hUPW5ldyBTay5idWlsdGluLmludF8oMzkpLGMuRE9XTj1uZXcgU2suYnVpbHRpbi5pbnRfKDQwKSxjLkYxPW5ldyBTay5idWlsdGluLmludF8oMTEyKSxjLkYyPW5ldyBTay5idWlsdGluLmludF8oMTEzKSxjLkYzPW5ldyBTay5idWlsdGluLmludF8oMTE0KSxjLkY0PW5ldyBTay5idWlsdGluLmludF8oMTE1KSxjLkY1PW5ldyBTay5idWlsdGluLmludF8oMTE2KSxjLkY2PW5ldyBTay5idWlsdGluLmludF8oMTE3KSxjLkY3PW5ldyBTay5idWlsdGluLmludF8oMTE4KSxjLkY4PW5ldyBTay5idWlsdGluLmludF8oMTE5KSxjLkY5PW5ldyBTay5idWlsdGluLmludF8oMTIwKSxjLkYxMD1uZXcgU2suYnVpbHRpbi5pbnRfKDEyMSksYy5GMTE9bmV3IFNrLmJ1aWx0aW4uaW50XygxMjIpLGMuRjEyPW5ldyBTay5idWlsdGluLmludF8oMTIzKSxjLk5VTUxLPW5ldyBTay5idWlsdGluLmludF8oMTQ0KSxjLk1FVEE9bmV3IFNrLmJ1aWx0aW4uaW50XygxNTcpLGMuSU5TRVJUPW5ldyBTay5idWlsdGluLmludF8oMTU1KSxjLlNJTkNPU19MRU5HVEg9bmV3IFNrLmJ1aWx0aW4uaW50Xyg3MjApLGMuUFJFQ0lTSU9OQj1uZXcgU2suYnVpbHRpbi5pbnRfKDE1KSxjLlBSRUNJU0lPTkY9bmV3IFNrLmJ1aWx0aW4uaW50XygzMjc2OCksYy5QUkVDX01BWFZBTD1uZXcgU2suYnVpbHRpbi5pbnRfKDMyNzY3KSxjLlBSRUNfQUxQSEFfU0hJRlQ9bmV3IFNrLmJ1aWx0aW4uaW50Xyg5KSxjLlBSRUNfUkVEX1NISUZUPW5ldyBTay5idWlsdGluLmludF8oMSksYy5OT1JNQUxfTU9ERV9BVVRPPW5ldyBTay5idWlsdGluLmludF8oMCksYy5OT1JNQUxfTU9ERV9TSEFQRT1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGMuTk9STUFMX01PREVfVkVSVEVYPW5ldyBTay5idWlsdGluLmludF8oMiksYy5NQVhfTElHSFRTPW5ldyBTay5idWlsdGluLmludF8oOCksYy5saW5lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe2MucHJvY2Vzc2luZy5saW5lKG4udixpLnYsZS52LHQudil9KSksYy5lbGxpcHNlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe2MucHJvY2Vzc2luZy5lbGxpcHNlKG4udixpLnYsZS52LHQudil9KSksYy5jaXJjbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe2MucHJvY2Vzc2luZy5lbGxpcHNlKG4udixpLnYsZS52LGUudil9KSksYy50ZXh0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtjLnByb2Nlc3NpbmcudGV4dChuLnYsaS52LGUudil9KSksYy5wb2ludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe2MucHJvY2Vzc2luZy5wb2ludChuLnYsaS52KX0pKSxjLmFyYz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLmFyYyhuLnYsaS52LGUudix0LnYsdS52LG8udil9KSksYy5xdWFkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCl7Yy5wcm9jZXNzaW5nLnF1YWQobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudil9KSksYy5yZWN0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB1P2MucHJvY2Vzc2luZy5yZWN0KG4udixpLnYsZS52LHQudik6Yy5wcm9jZXNzaW5nLnJlY3Qobi52LGkudixlLnYsdC52LHUudil9KSksYy50cmlhbmdsZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLnRyaWFuZ2xlKG4udixpLnYsZS52LHQudix1LnYsby52KX0pKSxjLmJlemllcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyxzLGwscix2LGYsUyl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiByP2MucHJvY2Vzc2luZy5iZXppZXIobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudik6Yy5wcm9jZXNzaW5nLmJlemllcihuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudix2LnYsZi52LFMudil9KSksYy5hbHBoYT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYWxwaGEobi52KSk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYWxwaGEobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYWxwaGEobi52LGkudixlLnYpKX0pKSxjLmFtYmllbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3NpbmcuYW1iaWVudChuLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcuYW1iaWVudChuLnYsaS52KTpjLnByb2Nlc3NpbmcuYW1iaWVudChuLnYsaS52LGUudil9KSksYy5hbWJpZW50TGlnaHQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1LG8pe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9jLnByb2Nlc3NpbmcuYW1iaWVudExpZ2h0KG4udixpLnYsZS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHU/Yy5wcm9jZXNzaW5nLmFtYmllbnRMaWdodChuLnYsaS52LGUudix0LnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygbz9jLnByb2Nlc3NpbmcuYW1iaWVudExpZ2h0KG4udixpLnYsZS52LHQudix1LnYpOmMucHJvY2Vzc2luZy5hbWJpZW50TGlnaHQobi52LGkudixlLnYsdC52LHUudixvLnYpfSkpLGMuYmVnaW5DYW1lcmE9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3NpbmcuYmVnaW5DYW1lcmEoKX0pKSxjLmJlZ2luU2hhcGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuJiYobj1jLlBPTFlHT04pLGMucHJvY2Vzc2luZy5iZWdpblNoYXBlKG4udil9KSksYy5iZXppZXJEZXRhaWw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7bj1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIG4/bi52OjIwLGMucHJvY2Vzc2luZy5iZXppZXJEZXRhaWwobil9KSksYy5iZXppZXJQb2ludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe2MucHJvY2Vzc2luZy5iZXppZXJQb2ludChuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmJlemllclRhbmdlbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtjLnByb2Nlc3NpbmcuYmV6aWVyVGFuZ2VudChuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmJlemllclZlcnRleD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyxzLGwscil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBzP2MucHJvY2Vzc2luZy5iZXppZXJWZXJ0ZXgobi52LGkudixlLnYsdC52LHUudixvLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgbD9jLnByb2Nlc3NpbmcuYmV6aWVyVmVydGV4KG4udixpLnYsZS52LHQudix1LnYsby52LHMudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiByP2MucHJvY2Vzc2luZy5iZXppZXJWZXJ0ZXgobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudik6Yy5wcm9jZXNzaW5nLmJlemllclZlcnRleChuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudil9KSksYy5ibGVuZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyxzLGwscix2KXtuIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRffHxuIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8/Yy5wcm9jZXNzaW5nLmJsZW5kKG4udixpLnYsZS52LHQudix1LnYsby52LHMudixsLnYsci52KTpjLnByb2Nlc3NpbmcuYmxlbmQobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYsdi52KX0pKSxjLmJsZW5kQ29sb3I9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3ZhciB0PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLmNvbG9yLFtuZXcgU2suYnVpbHRpbi5pbnRfKDApLG5ldyBTay5idWlsdGluLmludF8oMCksbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0pO3JldHVybiB0LnY9Yy5wcm9jZXNzaW5nLmJsZW5kQ29sb3Iobi52LGkudixlLnYpLHR9KSksYy5icmlnaHRuZXNzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5icmlnaHRuZXNzKG4udikpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLmJyaWdodG5lc3Mobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuYnJpZ2h0bmVzcyhuLnYsaS52LGUudikpfSkpLGMuY2FtZXJhPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCxyKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG4/Yy5wcm9jZXNzaW5nLmNhbWVyYSgpOmMucHJvY2Vzc2luZy5jYW1lcmEobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYpfSkpLGMuY29uc3RyYWluPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5jb25zdHJhaW4obi52LGkudixlLnYpKX0pKSxjLmNvcHk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1LG8scyxsLHIpe24gaW5zdGFuY2VvZiBTay5idWlsdGluLmludF98fG4gaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0Xz9jLnByb2Nlc3NpbmcuY29weShuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52KTpjLnByb2Nlc3NpbmcuY29weShuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudil9KSksYy5jcmVhdGVGb250PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe3ZhciB1PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBGb250KTtyZXR1cm4gdS52PVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcuY3JlYXRlRm9udChuLnYsaS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLmNyZWF0ZUZvbnQobi52LGkudixlLnYpOmMucHJvY2Vzc2luZy5jcmVhdGVGb250KG4udixpLnYsZS52LHQudiksdX0pKSxjLmNyZWF0ZUdyYXBoaWNzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe3ZhciB1PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBHcmFwaGljcyk7cmV0dXJuIHUudj1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLmNyZWF0ZUdyYXBoaWNzKG4udixpLnYsZS52KTpjLnByb2Nlc3NpbmcuY3JlYXRlR3JhcGhpY3Mobi52LGkudixlLnYsdC52KSx1fSkpLGMuY3JlYXRlSW1hZ2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3ZhciB0PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBJbWFnZSk7cmV0dXJuIHQudj1jLnByb2Nlc3NpbmcuY3JlYXRlSW1hZ2Uobi52LGkudixlLnYpLHR9KSksYy5jdXJzb3I9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygbj9jLnByb2Nlc3NpbmcuY3Vyc29yKCk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5jdXJzb3Iobi52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLmN1cnNvcihuLnYsaS52KTpjLnByb2Nlc3NpbmcuY3Vyc29yKG4udixpLnYsZS52KX0pKSxjLmN1cnZlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCxyLHYsZixTKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHI/Yy5wcm9jZXNzaW5nLmN1cnZlKG4udixpLnYsZS52LHQudix1LnYsby52LHMudixsLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygdj9jLnByb2Nlc3NpbmcuY3VydmUobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZj9jLnByb2Nlc3NpbmcuY3VydmUobi52LGkudixlLnYsdC52LHUudixvLnYscy52LGwudixyLnYsdi52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFM/Yy5wcm9jZXNzaW5nLmN1cnZlKG4udixpLnYsZS52LHQudix1LnYsby52LHMudixsLnYsci52LHYudixmLnYpOmMucHJvY2Vzc2luZy5jdXJ2ZShuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52LHIudix2LnYsZi52LFMudil9KSksYy5jdXJ2ZURldGFpbD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcuY3VydmVEZXRhaWwobi52KX0pKSxjLmN1cnZlUG9pbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtjLnByb2Nlc3NpbmcuY3VydmVQb2ludChuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmN1cnZlVGFuZ2VudD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe2MucHJvY2Vzc2luZy5jdXJ2ZVRhbmdlbnQobi52LGkudixlLnYsdC52LHUudil9KSksYy5jdXJ2ZVRpZ2h0bmVzcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcuY3VydmVUaWdodG5lc3Mobi52KX0pKSxjLmN1cnZlVmVydGV4PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLmN1cnZlVmVydGV4KG4udixpLnYpOmMucHJvY2Vzc2luZy5jdXJ2ZVZlcnRleChuLnYsaS52LGUudil9KSksYy5kYXk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcuZGF5KCkpfSkpLGMuZGVncmVlcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5kZWdyZWVzKG4udikpfSkpLGMuZGlyZWN0aW9uYWxMaWdodD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLmRpcmVjdGlvbmFsTGlnaHQobi52LGkudixlLnYsdC52LHUudixvLnYpfSkpLGMuZGlzdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB1P25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcuZGlzdChuLnYsaS52LGUudix0LnYpKTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG8/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5kaXN0KG4udixpLnYsZS52LHQudix1LnYpKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLmRpc3Qobi52LGkudixlLnYsdC52LHUudixvLnYpKX0pKSxjLmVtaXNzaXZlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLmVtaXNzaXZlKG4udik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP2MucHJvY2Vzc2luZy5lbWlzc2l2ZShuLnYsaS52KTpjLnByb2Nlc3NpbmcuZW1pc3NpdmUobi52LGkudixlLnYpfSkpLGMuZW5kQ2FtZXJhPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLmVuZENhbWVyYSgpfSkpLGMuZW5kU2hhcGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuP2MucHJvY2Vzc2luZy5lbmRTaGFwZSgpOmMucHJvY2Vzc2luZy5lbmRTaGFwZShuLnYpfSkpLGMuZmlsdGVyPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5maWx0ZXIobi52KTpjLnByb2Nlc3NpbmcuZmlsdGVyKG4udixpLnYpfSkpLGMuZnJ1c3R1bT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUsbyl7Yy5wcm9jZXNzaW5nLmZydXN0dW0obixpLGUsdCx1LG8pfSkpLGMuaGludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcuaGludChuKX0pKSxjLmhvdXI9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcuaG91cigpKX0pKSxjLmh1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5odWUobi52KSl9KSksYy5pbWFnZU1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLmltYWdlTW9kZShuLnYpfSkpLGMubGVycD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcubGVycChuLnYsaS52LGUudikpfSkpLGMubGVycENvbG9yPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXt2YXIgdD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5jb2xvcixbbmV3IFNrLmJ1aWx0aW4uaW50XygwKSxuZXcgU2suYnVpbHRpbi5pbnRfKDApLG5ldyBTay5idWlsdGluLmludF8oMCldKTtyZXR1cm4gdC52PWMucHJvY2Vzc2luZy5sZXJwQ29sb3Iobi52LGkudixlLnYpLHR9KSksYy5saWdodEZhbGxvZmY9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe2MucHJvY2Vzc2luZy5saWdodEZhbGxvZmYobi52LGkudixlLnYpfSkpLGMubGlnaHRzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLmxpZ2h0cygpfSkpLGMubGlnaHRTcGVjdWxhcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7Yy5wcm9jZXNzaW5nLmxpZ2h0U3BlY3VsYXIobi52LGkudixlLnYpfSkpLGMubG9hZEJ5dGVzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGMucHJvY2Vzc2luZy5sb2FkQnl0ZXMobi52KSl9KSksYy5sb2FkRm9udD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXt2YXIgaT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QRm9udCk7cmV0dXJuIGkudj1jLnByb2Nlc3NpbmcubG9hZEZvbnQobi52KSxpfSkpLGMubG9hZFNoYXBlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QU2hhcGVTVkcsW25ldyBTay5idWlsdGluLnN0cihcXFwic3RyaW5nXFxcIiksbl0pfSkpLGMubG9hZFN0cmluZ3M9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYy5wcm9jZXNzaW5nLmxvYWRTdHJpbmdzKG4udikpfSkpLGMubWFnPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5tYWcobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcubWFnKG4udixpLnYsZS52KSl9KSksYy5tYXA9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5tYXAobi52LGkudixlLnYsdC52LHUudikpfSkpLGMubWlsbGlzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLm1pbGxpcygpKX0pKSxjLm1pbnV0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5taW51dGUoKSl9KSksYy5tb2RlbFg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLm1vZGVsWChuLnYsaS52LGUudikpfSkpLGMubW9kZWxZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5tb2RlbFkobi52LGkudixlLnYpKX0pKSxjLm1vZGVsWj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcubW9kZWxaKG4udixpLnYsZS52KSl9KSksYy5tb250aD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5tb250aCgpKX0pKSxjLm5vQ3Vyc29yPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vQ3Vyc29yKCl9KSksYy5ub2lzZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3Npbmcubm9pc2Uobi52KSk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3Npbmcubm9pc2Uobi52LGkudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3Npbmcubm9pc2Uobi52LGkudixlLnYpKX0pKSxjLm5vaXNlRGV0YWlsPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7Yy5wcm9jZXNzaW5nLm5vaXNlRGV0YWlsKG4udixpLnYpfSkpLGMubm9pc2VTZWVkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLm5vaXNlU2VlZChuLnYpKX0pKSxjLm5vTGlnaHRzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vTGlnaHRzKCl9KSksYy5ub3JtPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5ub3JtKG4udixpLnYsZS52KSl9KSksYy5ub3JtYWw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe2MucHJvY2Vzc2luZy5ub3JtYWwobi52LGkudixlLnYpfSkpLGMubm9UaW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vVGludCgpfSkpLGMub3J0aG89bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1LG8pe2MucHJvY2Vzc2luZy5vcnRobyhuLnYsaS52LGUudix0LnYsdS52LG8udil9KSksYy5wZXJzcGVjdGl2ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG4/Yy5wcm9jZXNzaW5nLnBlcnNwZWN0aXZlKCk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5wZXJzcGVjdGl2ZShuLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcucGVyc3BlY3RpdmUobi52LGkudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0P2MucHJvY2Vzc2luZy5wZXJzcGVjdGl2ZShuLnYsaS52LGUudik6Yy5wcm9jZXNzaW5nLnBlcnNwZWN0aXZlKG4udixpLnYsZS52LHQudil9KSksYy5wb2ludExpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvKXtjLnByb2Nlc3NpbmcucG9pbnRMaWdodChuLnYsaS52LGUudix0LnYsdS52LG8udil9KSksYy5wcmludENhbWVyYT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2MucHJvY2Vzc2luZy5wcmludENhbWVyYSgpfSkpLGMucHJpbnRsbj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcucHJpbnRsbihuLnYpfSkpLGMucHJpbnRQcm9qZWN0aW9uPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnByaW50UHJvamVjdGlvbigpfSkpLGMucmFkaWFucz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5yYWRpYW5zKG4udikpfSkpLGMucmFuZG9tU2VlZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy5yYW5kb21TZWVkKG4udikpfSkpLGMucmFuZG9tPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuP25ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcucmFuZG9tKCkpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnJhbmRvbShuLnYpKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnJhbmRvbShuLnYsaS52KSl9KSksYy5yZXF1ZXN0SW1hZ2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXt2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QSW1hZ2UpO3JldHVybiBlLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP2MucHJvY2Vzc2luZy5yZXF1ZXN0SW1hZ2Uobi52KTpjLnByb2Nlc3NpbmcucmVxdWVzdEltYWdlKG4udixpLnYpLGV9KSksYy5zYXR1cmF0aW9uPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNhdHVyYXRpb24obi52KSl9KSksYy5zYXZlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5zYXZlKG4udil9KSksYy5zYXZlRnJhbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBuP2MucHJvY2Vzc2luZy5zYXZlRnJhbWUoKTpjLnByb2Nlc3Npbmcuc2F2ZUZyYW1lKG4udil9KSksYy5zYXZlU3RyaW5ncz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe2MucHJvY2Vzc2luZy5zYXZlU3RyaW5ncyhuLnYsaS52KX0pKSxjLnNjcmVlblg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNjcmVlblgobi52LGkudixlLnYpKX0pKSxjLnNjcmVlblk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNjcmVlblkobi52LGkudixlLnYpKX0pKSxjLnNjcmVlblo9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNjcmVlbloobi52LGkudixlLnYpKX0pKSxjLnNlY29uZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5zZWNvbmQoKSl9KSksYy5zaGFwZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3Npbmcuc2hhcGUobi52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLnNoYXBlKG4udixpLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9jLnByb2Nlc3Npbmcuc2hhcGUobi52LGkudixlLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdT9jLnByb2Nlc3Npbmcuc2hhcGUobi52LGkudixlLnYsdC52KTpjLnByb2Nlc3Npbmcuc2hhcGUobi52LGkudixlLnYsdC52LHUudil9KSksYy5zaGFwZU1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnNoYXBlTW9kZShuLnYpfSkpLGMuc2hpbmluZXNzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5zaGluaW5lc3Mobi52KX0pKSxjLnNwZWN1bGFyPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLnNwZWN1bGFyKG4udik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP2MucHJvY2Vzc2luZy5zcGVjdWxhcihuLnYsaS52KTpjLnByb2Nlc3Npbmcuc3BlY3VsYXIobi52LGkudixlLnYpfSkpLGMuc3BvdExpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQsdSxvLHMsbCl7Yy5wcm9jZXNzaW5nLnNwb3RMaWdodChuLnYsaS52LGUudix0LnYsdS52LG8udixzLnYsbC52KX0pKSxjLnNxPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYy5wcm9jZXNzaW5nLnNxKG4pKX0pKSxjLnN0YXR1cz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3Npbmcuc3RhdHVzKG4udil9KSksYy50ZXh0QWxpZ249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLnRleHRBbGlnbihuLnYpOmMucHJvY2Vzc2luZy50ZXh0QWxpZ24obi52LGkudil9KSksYy50ZXh0QXNjZW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcudGV4dEFzY2VudCgpKX0pKSxjLnRleHREZXNjZW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjLnByb2Nlc3NpbmcudGV4dERlc2NlbnQoKSl9KSksYy50ZXh0Rm9udD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3NpbmcudGV4dEZvbnQobi52KTpjLnByb2Nlc3NpbmcudGV4dEZvbnQobi52LGkudil9KSksYy50ZXh0TGVhZGluZz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcudGV4dExlYWRpbmcobi52KX0pKSxjLnRleHRNb2RlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy50ZXh0TW9kZShuLnYpfSkpLGMudGV4dFNpemU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnRleHRTaXplKG4udil9KSksYy50ZXh0dXJlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy50ZXh0dXJlKG4udil9KSksYy50ZXh0dXJlTW9kZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3NpbmcudGV4dHVyZU1vZGUobi52KX0pKSxjLnRleHRXaWR0aD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMucHJvY2Vzc2luZy50ZXh0V2lkdGgobi52KSl9KSksYy50aW50PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9jLnByb2Nlc3NpbmcudGludChuLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9jLnByb2Nlc3NpbmcudGludChuLnYsaS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLnRpbnQobi52LGkudixlLnYpOmMucHJvY2Vzc2luZy50aW50KG4udixpLnYsZS52LHQudil9KSksYy51cGRhdGVQaXhlbHM9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3NpbmcudXBkYXRlUGl4ZWxzKCl9KSksYy52ZXJ0ZXg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/Yy5wcm9jZXNzaW5nLnZlcnRleChuLnYsaS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/Yy5wcm9jZXNzaW5nLnZlcnRleChuLnYsaS52LGUudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB1P2MucHJvY2Vzc2luZy52ZXJ0ZXgobi52LGkudixlLnYsdC52KTpjLnByb2Nlc3NpbmcudmVydGV4KG4udixpLnYsZS52LHQudix1LnYpfSkpLGMueWVhcj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy55ZWFyKCkpfSkpLGMuYm94PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5ib3gobi52KX0pKSxjLnNwaGVyZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3Npbmcuc3BoZXJlKG4udil9KSksYy5zcGhlcmVEZXRhaWw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/Yy5wcm9jZXNzaW5nLnNwaGVyZURldGFpbChuLnYpOmMucHJvY2Vzc2luZy5zcGhlcmVEZXRhaWwobi52LGkudil9KSksYy5iYWNrZ3JvdW5kPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGkmJihpPWkudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBlJiYoZT1lLnYpLGMucHJvY2Vzc2luZy5iYWNrZ3JvdW5kKG4udixpLGUpfSkpLGMuZmlsbD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGkmJihpPWkudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBlJiYoZT1lLnYpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgdCYmKHQ9dC52KSxjLnByb2Nlc3NpbmcuZmlsbChuLnYsaSxlLHQpfSkpLGMuc3Ryb2tlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgaSYmKGk9aS52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGUmJihlPWUudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB0JiYodD10LnYpLGMucHJvY2Vzc2luZy5zdHJva2Uobi52LGksZSx0KX0pKSxjLm5vU3Ryb2tlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vU3Ryb2tlKCl9KSksYy5jb2xvck1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCx1KXtpPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT8yNTU6aS52LFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZSYmKGU9ZS52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHQmJih0PXQudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB1JiYodT11LnYpLGMucHJvY2Vzc2luZy5jb2xvck1vZGUobi52LGksZSx0LHUpfSkpLGMubm9GaWxsPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLm5vRmlsbCgpfSkpLGMubG9vcD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKG51bGw9PT1jLnByb2Nlc3NpbmcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJsb29wKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBydW4oKVxcXCIpO3Y9ITAsYy5wcm9jZXNzaW5nLmxvb3AoKX0pKSxjLm5vTG9vcD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2lmKG51bGw9PT1jLnByb2Nlc3NpbmcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJub0xvb3AoKSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHJ1bigpXFxcIik7dj0hMSxjLnByb2Nlc3Npbmcubm9Mb29wKCl9KSksYy5mcmFtZVJhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLmZyYW1lUmF0ZShuLnYpfSkpLGMud2lkdGg9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxjLmhlaWdodD1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGMucmVuZGVyTW9kZT1jLlAyRCxjLnNpemU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9Yy5QMkQpLGMucHJvY2Vzc2luZy5zaXplKG4udixpLnYsZS52KSxjLndpZHRoPW5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLndpZHRoKSxjLmhlaWdodD1uZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5oZWlnaHQpLGMucmVuZGVyTW9kZT1lfSkpLGMuZXhpdHA9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3NpbmcuZXhpdCgpfSkpLGMubW91c2VYPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLm1vdXNlWCl9KSksYy5tb3VzZVk9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcubW91c2VZKX0pKSxjLnBtb3VzZVg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcucG1vdXNlWCl9KSksYy5wbW91c2VZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLnBtb3VzZVkpfSkpLGMucmVjdE1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnJlY3RNb2RlKG4udil9KSksYy5zdHJva2VXZWlnaHQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnN0cm9rZVdlaWdodChuLnYpfSkpLGMuc21vb3RoPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnNtb290aCgpfSkpLGMubm9TbW9vdGg9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtjLnByb2Nlc3Npbmcubm9TbW9vdGgoKX0pKSxjLmVsbGlwc2VNb2RlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5lbGxpcHNlTW9kZShuLnYpfSkpLGMuc3Ryb2tlQ2FwPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5zdHJva2VDYXAobi52KX0pKSxjLnN0cm9rZUpvaW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Yy5wcm9jZXNzaW5nLnN0cm9rZUpvaW4obi52KX0pKSxjLnJvdGF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtjLnByb2Nlc3Npbmcucm90YXRlKG4udil9KSksYy5yb3RhdGVYPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5yb3RhdGVYKG4udil9KSksYy5yb3RhdGVZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5yb3RhdGVZKG4udil9KSksYy5yb3RhdGVaPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2MucHJvY2Vzc2luZy5yb3RhdGVaKG4udil9KSksYy5zY2FsZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSl7aT1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/MTppLnYsZT1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/MTplLnYsYy5wcm9jZXNzaW5nLnNjYWxlKG4udixpLGUpfSkpLGMudHJhbnNsYXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtpPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT8xOmkudixlPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT8xOmUudixjLnByb2Nlc3NpbmcudHJhbnNsYXRlKG4udixpLGUpfSkpLGMucG9wTWF0cml4PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnBvcE1hdHJpeCgpfSkpLGMucHVzaE1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe2MucHJvY2Vzc2luZy5wdXNoTWF0cml4KCl9KSksYy5hcHBseU1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3ZhciBuLGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDAsMTYpO2ZvcihuPTA7bjxpLmxlbmd0aDtuKyspaVtuXT1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGlbbl0/MDppW25dLnY7Yy5wcm9jZXNzaW5nLmFwcGx5TWF0cml4LmFwcGx5KGMucHJvY2Vzc2luZyxpKX0pKSxjLnJlc2V0TWF0cml4PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLnJlc2V0TWF0cml4KCl9KSksYy5wcmludE1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5mZmkucmVtYXBUb1B5KGMucHJvY2Vzc2luZy5wcmludE1hdHJpeCgpKX0pKSxjLnJ1bj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3ZhciBuPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNrLmNhbnZhcyk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFxcXCJQcm9jZXNzaW5nIG1vZHVsZTogQ2FudmFzIGVsZW1lbnQgbm90IHNwZWNpZmllZFxcXCIpO2lmKHdpbmRvdy5Qcm9jZXNzaW5nLmxvZ2dlcj17bG9nOmZ1bmN0aW9uKG4pe1NrLm1pc2NldmFsLnByaW50XyhuKX19LChmPXdpbmRvdy5Qcm9jZXNzaW5nLmdldEluc3RhbmNlQnlJZChTay5jYW52YXMpKSYmZi5leGl0KCksYy5wPW5ldyB3aW5kb3cuUHJvY2Vzc2luZyhuLChmdW5jdGlvbiBza2V0Y2hQcm9jKG4pe2MucHJvY2Vzc2luZz1uLG4uZHJhdz1mdW5jdGlvbigpe3ZhciBpPSExO2Zvcih2YXIgZSBpbiByKTA9PT1yW2VdLndpZHRoJiYoaT0hMCk7aWYoITA9PT1pKXJldHVybiEwPT09dj92b2lkIDA6dm9pZCBuLmxvb3AoKTtpZighMT09PXYmJm4ubm9Mb29wKCksYy5mcmFtZUNvdW50PW4uZnJhbWVDb3VudCxTay5nbG9iYWxzLmRyYXcpdHJ5e1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5nbG9iYWxzLmRyYXcpfWNhdGNoKHQpe1NrLnVuY2F1Z2h0RXhjZXB0aW9uKHQpfX07dmFyIGk9W1xcXCJzZXR1cFxcXCIsXFxcIm1vdXNlTW92ZWRcXFwiLFxcXCJtb3VzZUNsaWNrZWRcXFwiLFxcXCJtb3VzZURyYWdnZWRcXFwiLFxcXCJtb3VzZU1vdmVkXFxcIixcXFwibW91c2VPdXRcXFwiLFxcXCJtb3VzZU92ZXJcXFwiLFxcXCJtb3VzZVByZXNzZWRcXFwiLFxcXCJtb3VzZVJlbGVhc2VkXFxcIixcXFwia2V5UHJlc3NlZFxcXCIsXFxcImtleVJlbGVhc2VkXFxcIixcXFwia2V5VHlwZWRcXFwiXTtmb3IodmFyIGUgaW4gaSlTay5nbG9iYWxzW2lbZV1dJiYobltpW2VdXT1uZXcgRnVuY3Rpb24oXFxcInRyeSB7U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KFNrLmdsb2JhbHNbJ1xcXCIraVtlXStcXFwiJ10pO30gY2F0Y2goZSkge1NrLnVuY2F1Z2h0RXhjZXB0aW9uKGUpO31cXFwiKSl9KSksMD09PWMud2lkdGgudiYmMD09PWMuaGVpZ2h0LnYpe3ZhciBpPW4ub2Zmc2V0V2lkdGgsZT1uLm9mZnNldEhlaWdodDtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5zaXplLFtuZXcgU2suYnVpbHRpbi5pbnRfKGkpLG5ldyBTay5idWlsdGluLmludF8oZSksYy5yZW5kZXJNb2RlXSl9fSkpLHM9ZnVuY3Rpb24obixpKXtpLl9fZ2V0YXR0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuXFxcInhcXFwiPT09KGk9U2suZmZpLnJlbWFwVG9KcyhpKSk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3NpbmcubW91c2VYKTpcXFwieVxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLm1vdXNlWSk6XFxcInB4XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3NpbmcucG1vdXNlWCk6XFxcInB5XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3NpbmcucG1vdXNlWSk6XFxcInByZXNzZWRcXFwiPT09aT9uZXcgU2suYnVpbHRpbi5ib29sKGMucHJvY2Vzc2luZy5fX21vdXNlUHJlc3NlZCk6XFxcImJ1dHRvblxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLm1vdXNlQnV0dG9uKTp2b2lkIDB9KSl9LGMuTW91c2U9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLHMsXFxcIk1vdXNlXFxcIixbXSksYy5tb3VzZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5Nb3VzZSksbz1mdW5jdGlvbihuLGkpe2kuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtyZXR1cm5cXFwia2V5XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP25ldyBTay5idWlsdGluLnN0cihjLnByb2Nlc3Npbmcua2V5LnRvU3RyaW5nKCkpOlxcXCJrZXlDb2RlXFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3Npbmcua2V5Q29kZSk6XFxcImtleVByZXNzZWRcXFwiPT09aT9uZXcgU2suYnVpbHRpbi5zdHIoYy5wcm9jZXNzaW5nLmtleVByZXNzZWQpOnZvaWQgMH0pKX0sYy5LZXlib2FyZD1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsbyxcXFwiS2V5Ym9hcmRcXFwiLFtdKSxjLmtleWJvYXJkPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLktleWJvYXJkKSx1PWZ1bmN0aW9uKG4saSl7aS5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVyblxcXCJmcmFtZUNvdW50XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLmZyYW1lQ291bnQpOlxcXCJmcmFtZVJhdGVcXFwiPT09aT9Tay5idWlsdGluLmFzc2skKGMucHJvY2Vzc2luZy5mcmFtZVJhdGUpOlxcXCJoZWlnaHRcXFwiPT09aT9Tay5idWlsdGluLmFzc2skKGMucHJvY2Vzc2luZy5oZWlnaHQpOlxcXCJ3aWR0aFxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLndpZHRoKTpcXFwib25saW5lXFxcIj09PWk/bmV3IFNrLmJ1aWx0aW4uYm9vbChjLnByb2Nlc3Npbmcub25saW5lKTpcXFwiZm9jdXNlZFxcXCI9PT1pP25ldyBTay5idWlsdGluLmJvb2woYy5wcm9jZXNzaW5nLmZvY3VzZWQpOnZvaWQgMH0pKX0sYy5FbnZpcm9ubWVudD1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsdSxcXFwiRW52aXJvbm1lbnRcXFwiLFtdKSxjLmVudmlyb25tZW50PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLkVudmlyb25tZW50KSx0PWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtuLnBpeGVscz1udWxsfSkpLGkuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtyZXR1cm5cXFwiaGVpZ2h0XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQoYy5wcm9jZXNzaW5nLmhlaWdodCk6XFxcIndpZHRoXFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChjLnByb2Nlc3Npbmcud2lkdGgpOihcXFwicGl4ZWxzXFxcIj09PWkmJm51bGw9PW4ucGl4ZWxzJiYobi5waXhlbHM9bmV3IFNrLmJ1aWx0aW4ubGlzdChjLnByb2Nlc3NpbmcucGl4ZWxzLnRvQXJyYXkoKSkpLG4ucGl4ZWxzKX0pKX0sYy5TY3JlZW49U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLHQsXFxcIlNjcmVlblxcXCIsW10pLGMuc2NyZWVuPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlNjcmVlbiksYy5sb2FkUGl4ZWxzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKCl7Yy5wcm9jZXNzaW5nLmxvYWRQaXhlbHMoKX0pKSxlPWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZSYmKGU9ZS52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHQmJih0PXQudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB1JiYodT11LnYpLG4udj1jLnByb2Nlc3NpbmcuY29sb3IoaS52LGUsdCx1KX0pKX0sYy5jb2xvcj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsZSxcXFwiY29sb3JcXFwiLFtdKSxjLnJlZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcucmVkKG4udikpfSkpLGMuZ3JlZW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLmdyZWVuKG4udikpfSkpLGMuYmx1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjLnByb2Nlc3NpbmcuYmx1ZShuLnYpKX0pKSxpPWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBjLnByb2Nlc3NpbmcuUEltYWdlOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9uZXcgYy5wcm9jZXNzaW5nLlBJbWFnZShpLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9uZXcgYy5wcm9jZXNzaW5nLlBJbWFnZShpLnYsZS52KTpuZXcgYy5wcm9jZXNzaW5nLlBJbWFnZShpLnYsZS52LHQudil9KSksaS5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVyblxcXCJ3aWR0aFxcXCI9PT0oaT1Tay5mZmkucmVtYXBUb0pzKGkpKT9Tay5idWlsdGluLmFzc2skKG4udi53aWR0aCk6XFxcImhlaWdodFxcXCI9PT1pP1NrLmJ1aWx0aW4uYXNzayQobi52LmhlaWdodCk6dm9pZCAwfSkpfSxjLmxvYWRJbWFnZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXt2YXIgaT1jLnByb2Nlc3NpbmcubG9hZEltYWdlKG4udik7ci5wdXNoKGkpO3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBJbWFnZSk7cmV0dXJuIGUudj1pLGV9KSksYy5pbWFnZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0LHUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9jLnByb2Nlc3NpbmcuaW1hZ2Uobi52LGkudixlLnYpOmMucHJvY2Vzc2luZy5pbWFnZShuLnYsaS52LGUudix0LnYsdS52KX0pKSxjLmdldD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3ZhciBlPWMucHJvY2Vzc2luZy5nZXQobi52LGkudik7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLmNvbG9yLFtuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5yZWQoZSkpLG5ldyBTay5idWlsdGluLmludF8oYy5wcm9jZXNzaW5nLmdyZWVuKGUpKSxuZXcgU2suYnVpbHRpbi5pbnRfKGMucHJvY2Vzc2luZy5ibHVlKGUpKV0pfSkpLGMuc2V0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlKXtjLnByb2Nlc3Npbmcuc2V0KG4udixpLnYsZS52KX0pKSxsPWZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBjLnByb2Nlc3NpbmcuUFZlY3RvcjpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/bmV3IGMucHJvY2Vzc2luZy5QVmVjdG9yKGkudixlLnYpOm5ldyBjLnByb2Nlc3NpbmcuUFZlY3RvcihpLnYsZS52LHQudil9KSksaS5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVyblxcXCJ4XFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQobi52LngpOlxcXCJ5XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChuLnYueSk6XFxcInpcXFwiPT09aT9Tay5idWlsdGluLmFzc2skKG4udi56KTp2b2lkIDB9KSksaS5nZXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7dmFyIGk9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMuUFZlY3Rvcik7cmV0dXJuIGkudj1uLnYuZ2V0KCksaX0pKSxpLnNldD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHQ/bi52LnNldChpLnYsZS52KTpuLnYuc2V0KGkudixlLnYsdC52KX0pKSxpLm1hZz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gU2suYnVpbHRpbi5hc3NrJChuLnYubWFnKCkpfSkpLGkuYWRkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7dmFyIGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMuUFZlY3Rvcik7cmV0dXJuIGUudj1uLnYuYWRkKGkudiksZX0pKSxpLnN1Yj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBWZWN0b3IpO3JldHVybiBlLnY9bi52LnN1YihpLnYpLGV9KSksaS5tdWx0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7dmFyIGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMuUFZlY3Rvcik7cmV0dXJuIGUudj1uLnYubXVsdChpLnYpLGV9KSksaS5kaXY9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXt2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QVmVjdG9yKTtyZXR1cm4gZS52PW4udi5kaXYoaS52KSxlfSkpLGkuZGlzdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3JldHVybiBTay5idWlsdGluLmFzc2skKG4udi5kaXN0KGkudikpfSkpLGkuZG90PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe3JldHVyblxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9Tay5idWlsdGluLmFzc2skKG4udi5kb3QoaS52KSk6U2suYnVpbHRpbi5hc3NrJChuLnYuZG90KGkudixlLnYsdC52KSl9KSksaS5jcm9zcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLlBWZWN0b3IpO3JldHVybiBlLnY9bi52LmNyb3NzKGkudiksZX0pKSxpLm5vcm1hbGl6ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtuLnYubm9ybWFsaXplKCl9KSksaS5saW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe24udi5saW1pdChpLnYpfSkpLGkuYW5nbGVCZXR3ZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuIFNrLmJ1aWx0aW4uYXNzayQobi52LmFuZ2xlQmV0d2VlbihpLnYpKX0pKSxpLmFycmF5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KG4udi5hcnJheSgpKX0pKX07cmV0dXJuIGMuUEZvbnQ9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLChmdW5jdGlvbihuLGkpe2kuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP25ldyBjLnByb2Nlc3NpbmcuUEZvbnQ6bmV3IGMucHJvY2Vzc2luZy5QVmVjdG9yKGkudil9KSksaS5saXN0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KG4udi5saXN0KCkpfSkpfSksXFxcIlBGb250XFxcIixbXSksYy5QR3JhcGhpY3M9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLChmdW5jdGlvbihuLGkpe2kuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCl7bi52PVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9uZXcgYy5wcm9jZXNzaW5nLlBWZWN0b3I6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0P25ldyBjLnByb2Nlc3NpbmcuUFZlY3RvcihpLnYsZS52KTpuZXcgYy5wcm9jZXNzaW5nLlBWZWN0b3IoaS52LGUudix0LnYpfSkpLGkuYmVnaW5EcmF3PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe24udi5iZWdpbkRyYXcoKX0pKSxpLmVuZERyYXc9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7bi52LmVuZERyYXcoKX0pKX0pLFxcXCJQR3JhcGhpY3NcXFwiLFtdKSxjLlBTaGFwZVNWRz1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsKGZ1bmN0aW9uKG4saSl7aS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGksZSx0KXtuLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpP251bGw6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP25ldyBjLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGkudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0P25ldyBjLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGkudixlLnYpOm5ldyBjLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGkudixlLnYsdC52KX0pKSxpLl9fZ2V0YXR0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7cmV0dXJuXFxcIndpZHRoXFxcIj09PShpPVNrLmZmaS5yZW1hcFRvSnMoaSkpP1NrLmJ1aWx0aW4uYXNzayQobi52LndpZHRoKTpcXFwiaGVpZ2h0XFxcIj09PWk/U2suYnVpbHRpbi5hc3NrJChuLnYuaGVpZ2h0KTp2b2lkIDB9KSksaS5pc1Zpc2libGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2wobi52LmlzVmlzaWJsZSgpKX0pKSxpLnNldFZpc2libGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtuLnYuc2V0VmlzaWJsZShpLnYpfSkpLGkuZGlzYWJsZVN0eWxlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe24udi5kaXNhYmxlU3R5bGUoKX0pKSxpLmVuYWJsZVN0eWxlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe24udi5lbmFibGVTdHlsZSgpfSkpLGkuZ2V0Q2hpbGQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXt2YXIgZT1uLnYuZ2V0Q2hpbGQoaS52KTtpZihudWxsIT1lKXt2YXIgdD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5QU2hhcGVTVkcpO3JldHVybiB0LnY9ZSx0fXJldHVybiBudWxsfSkpLGkudHJhbnNsYXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSxlLHQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9uLnYudHJhbnNsYXRlKGkudixlLnYpOm4udi50cmFuc2xhdGUoaS52LGUudix0LnYpfSkpLGkucm90YXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7bi52LnJvdGF0ZShpLnYpfSkpLGkucm90YXRlWD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGkpe24udi5yb3RhdGVYKGkudil9KSksaS5yb3RhdGVZPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4saSl7bi52LnJvdGF0ZVkoaS52KX0pKSxpLnJvdGF0ZVo9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpKXtuLnYucm90YXRlWihpLnYpfSkpLGkuc2NhbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLGUsdCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP24udi5zY2FsZShpLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdD9uLnYuc2NhbGUoaS52LGUudik6bi52LnNjYWxlKGkudixlLnYsdC52KX0pKX0pLFxcXCJQU2hhcGVTVkdcXFwiLFtdKSxjLlBWZWN0b3I9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLGwsXFxcIlBWZWN0b3JcXFwiLFtdKSxjLlBJbWFnZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGMsaSxcXFwiUEltYWdlXFxcIixbXSksY307XCIsXCJzcmMvbGliL3JhbmRvbS5qc1wiOlwidmFyIE1lcnNlbm5lVHdpc3Rlcj1mdW5jdGlvbihuKXtudWxsPT1uJiYobj0obmV3IERhdGUpLmdldFRpbWUoKSksdGhpcy5OPTYyNCx0aGlzLk09Mzk3LHRoaXMuTUFUUklYX0E9MjU2NzQ4MzYxNSx0aGlzLlVQUEVSX01BU0s9MjE0NzQ4MzY0OCx0aGlzLkxPV0VSX01BU0s9MjE0NzQ4MzY0Nyx0aGlzLm10PW5ldyBBcnJheSh0aGlzLk4pLHRoaXMubXRpPXRoaXMuTisxLHRoaXMuaW5pdF9nZW5yYW5kKG4pfTtNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmluaXRfZ2VucmFuZD1mdW5jdGlvbihuKXtmb3IodGhpcy5tdFswXT1uPj4+MCx0aGlzLm10aT0xO3RoaXMubXRpPHRoaXMuTjt0aGlzLm10aSsrKW49dGhpcy5tdFt0aGlzLm10aS0xXV50aGlzLm10W3RoaXMubXRpLTFdPj4+MzAsdGhpcy5tdFt0aGlzLm10aV09KDE4MTI0MzMyNTMqKCg0Mjk0OTAxNzYwJm4pPj4+MTYpPDwxNikrMTgxMjQzMzI1MyooNjU1MzUmbikrdGhpcy5tdGksdGhpcy5tdFt0aGlzLm10aV0+Pj49MH0sTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5pbml0X2J5X2FycmF5PWZ1bmN0aW9uKG4sdCl7dmFyIGksZSxyO2Zvcih0aGlzLmluaXRfZ2VucmFuZCgxOTY1MDIxOCksaT0xLGU9MCxyPXRoaXMuTj50P3RoaXMuTjp0O3I7ci0tKXt2YXIgdT10aGlzLm10W2ktMV1edGhpcy5tdFtpLTFdPj4+MzA7dGhpcy5tdFtpXT0odGhpcy5tdFtpXV4oMTY2NDUyNSooKDQyOTQ5MDE3NjAmdSk+Pj4xNik8PDE2KSsxNjY0NTI1Kig2NTUzNSZ1KSkrbltlXStlLHRoaXMubXRbaV0+Pj49MCxlKyssKytpPj10aGlzLk4mJih0aGlzLm10WzBdPXRoaXMubXRbdGhpcy5OLTFdLGk9MSksZT49dCYmKGU9MCl9Zm9yKHI9dGhpcy5OLTE7cjtyLS0pe3U9dGhpcy5tdFtpLTFdXnRoaXMubXRbaS0xXT4+PjMwO3RoaXMubXRbaV09KHRoaXMubXRbaV1eKDE1NjYwODM5NDEqKCg0Mjk0OTAxNzYwJnUpPj4+MTYpPDwxNikrMTU2NjA4Mzk0MSooNjU1MzUmdSkpLWksdGhpcy5tdFtpXT4+Pj0wLCsraT49dGhpcy5OJiYodGhpcy5tdFswXT10aGlzLm10W3RoaXMuTi0xXSxpPTEpfXRoaXMubXRbMF09MjE0NzQ4MzY0OH0sTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5nZW5yYW5kX2ludDMyPWZ1bmN0aW9uKCl7dmFyIG4sdD1uZXcgQXJyYXkoMCx0aGlzLk1BVFJJWF9BKTtpZih0aGlzLm10aT49dGhpcy5OKXt2YXIgaTtmb3IodGhpcy5tdGk9PXRoaXMuTisxJiZ0aGlzLmluaXRfZ2VucmFuZCg1NDg5KSxpPTA7aTx0aGlzLk4tdGhpcy5NO2krKyluPXRoaXMubXRbaV0mdGhpcy5VUFBFUl9NQVNLfHRoaXMubXRbaSsxXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFtpXT10aGlzLm10W2krdGhpcy5NXV5uPj4+MV50WzEmbl07Zm9yKDtpPHRoaXMuTi0xO2krKyluPXRoaXMubXRbaV0mdGhpcy5VUFBFUl9NQVNLfHRoaXMubXRbaSsxXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFtpXT10aGlzLm10W2krKHRoaXMuTS10aGlzLk4pXV5uPj4+MV50WzEmbl07bj10aGlzLm10W3RoaXMuTi0xXSZ0aGlzLlVQUEVSX01BU0t8dGhpcy5tdFswXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFt0aGlzLk4tMV09dGhpcy5tdFt0aGlzLk0tMV1ebj4+PjFedFsxJm5dLHRoaXMubXRpPTB9cmV0dXJuIG49dGhpcy5tdFt0aGlzLm10aSsrXSxuXj1uPj4+MTEsbl49bjw8NyYyNjM2OTI4NjQwLG5ePW48PDE1JjQwMjI3MzA3NTIsKG5ePW4+Pj4xOCk+Pj4wfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfaW50MzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW5yYW5kX2ludDMyKCk+Pj4xfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW5yYW5kX2ludDMyKCkqKDEvNDI5NDk2NzI5NSl9LE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VucmFuZF9pbnQzMigpKigxLzQyOTQ5NjcyOTYpfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDM9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5nZW5yYW5kX2ludDMyKCkrLjUpKigxLzQyOTQ5NjcyOTYpfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVzNTM9ZnVuY3Rpb24oKXtyZXR1cm4oNjcxMDg4NjQqKHRoaXMuZ2VucmFuZF9pbnQzMigpPj4+NSkrKHRoaXMuZ2VucmFuZF9pbnQzMigpPj4+NikpKigxLzkwMDcxOTkyNTQ3NDA5OTIpfTt2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7dmFyIHQ9e30saT1uZXcgTWVyc2VubmVUd2lzdGVyLGU9dm9pZCAwO3Quc2VlZD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2VlZFxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLG49U2suYnVpbHRpbi5hc251bSQobiksaT1hcmd1bWVudHMubGVuZ3RoPjA/bmV3IE1lcnNlbm5lVHdpc3RlcihuKTpuZXcgTWVyc2VubmVUd2lzdGVyLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pKSx0LnJhbmRvbT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kb21cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oaS5nZW5yYW5kX3JlczUzKCkpfSkpO3ZhciB0b0ludD1mdW5jdGlvbihuKXtyZXR1cm4gMHxufSxyYW5kcmFuZ2U9ZnVuY3Rpb24obix0LGUpe3ZhciByLHUscztpZighU2suYnVpbHRpbi5jaGVja0ludChuKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJub24taW50ZWdlciBmaXJzdCBhcmd1bWVudCBmb3IgcmFuZHJhbmdlKClcXFwiKTtpZih2b2lkIDA9PT10KXJldHVybiBzPXRvSW50KGkuZ2VucmFuZF9yZXM1MygpKm4pLG5ldyBTay5idWlsdGluLmludF8ocyk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQodCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibm9uLWludGVnZXIgc3RvcCBmb3IgcmFuZHJhbmdlKClcXFwiKTtpZih2b2lkIDA9PT1lJiYoZT0xKSxyPXQtbiwxPT1lJiZyPjApcmV0dXJuIHM9bit0b0ludChpLmdlbnJhbmRfcmVzNTMoKSpyKSxuZXcgU2suYnVpbHRpbi5pbnRfKHMpO2lmKDE9PWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZW1wdHkgcmFuZ2UgZm9yIHJhbmRyYW5nZSgpIChcXFwiK24rXFxcIiwgXFxcIit0K1xcXCIsIFxcXCIrcitcXFwiKVxcXCIpO2lmKCFTay5idWlsdGluLmNoZWNrSW50KGUpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm5vbi1pbnRlZ2VyIHN0ZXAgZm9yIHJhbmRyYW5nZSgpXFxcIik7aWYoZT4wKXU9dG9JbnQoKHIrZS0xKS9lKTtlbHNle2lmKCEoZTwwKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJ6ZXJvIHN0ZXAgZm9yIHJhbmRyYW5nZSgpXFxcIik7dT10b0ludCgocitlKzEpL2UpfWlmKHU8PTApdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZW1wdHkgcmFuZ2UgZm9yIHJhbmRyYW5nZSgpXFxcIik7cmV0dXJuIHM9bitlKnRvSW50KGkuZ2VucmFuZF9yZXM1MygpKnUpLG5ldyBTay5idWlsdGluLmludF8ocyl9O3QucmFuZGludD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kaW50XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksbj1Tay5idWlsdGluLmFzbnVtJChuKSx0PVNrLmJ1aWx0aW4uYXNudW0kKHQpLHJhbmRyYW5nZShuLHQrMSl9KSksdC5yYW5kcmFuZ2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGkpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kcmFuZ2VcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwzKSxuPVNrLmJ1aWx0aW4uYXNudW0kKG4pLHQ9U2suYnVpbHRpbi5hc251bSQodCksaT1Tay5idWlsdGluLmFzbnVtJChpKSxyYW5kcmFuZ2Uobix0LGkpfSkpLHQudW5pZm9ybT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInVuaWZvcm1cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxuPVNrLmJ1aWx0aW4uYXNudW0kKG4pLHQ9U2suYnVpbHRpbi5hc251bSQodCk7Y29uc3QgZT1uK2kuZ2VucmFuZF9yZXM1MygpKih0LW4pO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oZSl9KSksdC50cmlhbmd1bGFyPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCxlKXt2YXIgcix1LHM7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInRyaWFuZ3VsYXJcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwzKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJsb3dcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIobikpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImhpZ2hcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIodCkpLChuPVNrLmJ1aWx0aW4uYXNudW0kKG4pKT4odD1Tay5idWlsdGluLmFzbnVtJCh0KSkmJihzPW4sbj10LHQ9cyksdm9pZCAwPT09ZXx8ZT09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJD9lPSh0LW4pLzI6KFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcIm1vZGVcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZSkpLGU9U2suYnVpbHRpbi5hc251bSQoZSkpLHU9KHI9aS5nZW5yYW5kX3JlczUzKCkpPChlLW4pLyh0LW4pP24rTWF0aC5zcXJ0KHIqKHQtbikqKGUtbikpOnQtTWF0aC5zcXJ0KCgxLXIpKih0LW4pKih0LWUpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8odSl9KSk7dmFyIG5vcm1hbFNhbXBsZT1mdW5jdGlvbihuLHQpe3ZhciByLHUscyxoLGw7cmV0dXJuIHZvaWQgMCE9PWU/KGw9ZSxlPXZvaWQgMCk6KHI9aS5nZW5yYW5kX3JlczUzKCksdT1pLmdlbnJhbmRfcmVzNTMoKSxzPU1hdGguc3FydCgtMipNYXRoLmxvZyhyKSksaD0yKk1hdGguUEkqdSxsPXMqTWF0aC5jb3MoaCksZT1zKk1hdGguc2luKGgpKSxuK3QqbH07cmV0dXJuIHQuZ2F1c3M9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0KXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2F1c3NcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJtdVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihuKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwic2lnbWFcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIodCkpLG49U2suYnVpbHRpbi5hc251bSQobiksdD1Tay5idWlsdGluLmFzbnVtJCh0KSxuZXcgU2suYnVpbHRpbi5mbG9hdF8obm9ybWFsU2FtcGxlKG4sdCkpfSkpLHQubm9ybWFsdmFyaWF0ZT10LmdhdXNzLHQubG9nbm9ybXZhcmlhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0KXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwibG9nbm9ybXZhcmlhdGVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJtdVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihuKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwic2lnbWFcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIodCkpLG49U2suYnVpbHRpbi5hc251bSQobiksdD1Tay5idWlsdGluLmFzbnVtJCh0KSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5leHAobm9ybWFsU2FtcGxlKG4sdCkpKX0pKSx0LmV4cG92YXJpYXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImV4cG92YXJpYXRlXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwibGFtYmRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIobikpLG49U2suYnVpbHRpbi5hc251bSQobik7dmFyIHQ9aS5nZW5yYW5kX3JlczUzKCk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XygtTWF0aC5sb2codCkvbil9KSksdC5jaG9pY2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiY2hvaWNlXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwic2VxXFxcIixcXFwic2VxdWVuY2VcXFwiLFNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZShuKSksdm9pZCAwIT09bi5zcSRsZW5ndGgpe3ZhciB0PW5ldyBTay5idWlsdGluLmludF8odG9JbnQoaS5nZW5yYW5kX3JlczUzKCkqbi5zcSRsZW5ndGgoKSkpO3JldHVybiBuLm1wJHN1YnNjcmlwdCh0KX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIm9iamVjdCBoYXMgbm8gbGVuZ3RoXFxcIil9KSksdC5zaHVmZmxlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNodWZmbGVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwic2VxdWVuY2VcXFwiLFNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZShuKSksbi5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4ubGlzdCl7Y29uc3QgdT1uLnY7Zm9yKHZhciB0PXUubGVuZ3RoLTE7dD4wO3QtPTEpe3ZhciBlPXVbcj10b0ludChpLmdlbnJhbmRfcmVzNTMoKSoodCsxKSldO3Vbcl09dVt0XSx1W3RdPWV9fWVsc2V7aWYodm9pZCAwPT09bi5zcSRsZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJvYmplY3QgaGFzIG5vIGxlbmd0aFxcXCIpO2lmKHZvaWQgMD09PW4ubXAkYXNzX3N1YnNjcmlwdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIm9iamVjdCBpcyBpbW11dGFibGVcXFwiKTtmb3IodD1uLnNxJGxlbmd0aCgpLTE7dD4wO3QtPTEpe3ZhciByPW5ldyBTay5idWlsdGluLmludF8odG9JbnQoaS5nZW5yYW5kX3JlczUzKCkqKHQrMSkpKTt0PW5ldyBTay5idWlsdGluLmludF8odCk7ZT1uLm1wJHN1YnNjcmlwdChyKTtuLm1wJGFzc19zdWJzY3JpcHQocixuLm1wJHN1YnNjcmlwdCh0KSksbi5tcCRhc3Nfc3Vic2NyaXB0KHQsZSl9fXJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KSksdC5zYW1wbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0KXt2YXIgZSxyLHUscyxoO2ZvcihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzYW1wbGVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJwb3B1bGF0aW9uXFxcIixcXFwiaXRlcmFibGVcXFwiLFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShuKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwia1xcXCIsXFxcImludGVnZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tJbnQodCkpLHQ9U2suYnVpbHRpbi5hc251bSQodCksaD1bXSxlPTAscz0odT1Tay5hYnN0ci5pdGVyKG4pKS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PXM7ZSsrLHM9dS50cCRpdGVybmV4dCgpKXI9TWF0aC5mbG9vcihpLmdlbnJhbmRfcmVzNTMoKSooZSsxKSksZTx0PyhyPGUmJihoW2VdPWhbcl0pLGhbcl09cyk6cjx0JiYoaFtyXT1zKTtpZihlPHQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwic2FtcGxlIGxhcmdlciB0aGFuIHBvcHVsYXRpb25cXFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChoKX0pKSx0fTtcIixcInNyYy9saWIvcmUuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKG5hbWUpe2NvbnN0e2J1aWx0aW46e2RpY3Q6cHlEaWN0LHN0cjpweVN0cixsaXN0OnB5TGlzdCxpbnRfOnB5SW50LHR5cGU6cHlUeXBlLHR1cGxlOnB5VHVwbGUsbWFwcGluZ3Byb3h5OnB5TWFwcGluZ1Byb3h5LHNsaWNlOnB5U2xpY2Usbm9uZTp7bm9uZSQ6cHlOb25lfSxOb3RJbXBsZW1lbnRlZDp7Tm90SW1wbGVtZW50ZWQkOnB5Tm90SW1wbGVtZW50ZWR9LEV4Y2VwdGlvbjpFeGNlcHRpb24sT3ZlcmZsb3dFcnJvcjpPdmVyZmxvd0Vycm9yLEluZGV4RXJyb3I6SW5kZXhFcnJvcixUeXBlRXJyb3I6VHlwZUVycm9yLFZhbHVlRXJyb3I6VmFsdWVFcnJvcixjaGVja0ludDpjaGVja0ludCxjaGVja1N0cmluZzpjaGVja1N0cmluZyxjaGVja0NhbGxhYmxlOmNoZWNrQ2FsbGFibGUsaGV4OmhleH0sYWJzdHI6e2J1aWxkTmF0aXZlQ2xhc3M6YnVpbGROYXRpdmVDbGFzcyx0eXBlTmFtZTp0eXBlTmFtZSxjaGVja09uZUFyZzpjaGVja09uZUFyZyxudW1iZXJCaW5PcDpudW1iZXJCaW5PcCxjb3B5S2V5d29yZFRvTmFtZWRBcmdzOmNvcHlLZXl3b3JkVG9OYW1lZEFyZ3Msc2V0VXBNb2R1bGVNZXRob2RzOnNldFVwTW9kdWxlTWV0aG9kc30sbWlzY2V2YWw6e2l0ZXJhdG9yOnB5SXRlcmF0b3Isb2JqZWN0UmVwcjpvYmplY3RSZXByLGFzSW5kZXhTaXplZDphc0luZGV4U2l6ZWQsaXNJbmRleDppc0luZGV4LGNhbGxzaW1BcnJheTpweUNhbGx9fT1TayxyZT17X19uYW1lX186bmV3IHB5U3RyKFxcXCJyZVxcXCIpLF9fYWxsX186bmV3IHB5TGlzdChbXFxcIm1hdGNoXFxcIixcXFwiZnVsbG1hdGNoXFxcIixcXFwic2VhcmNoXFxcIixcXFwic3ViXFxcIixcXFwic3ViblxcXCIsXFxcInNwbGl0XFxcIixcXFwiZmluZGFsbFxcXCIsXFxcImZpbmRpdGVyXFxcIixcXFwiY29tcGlsZVxcXCIsXFxcInB1cmdlXFxcIixcXFwidGVtcGxhdGVcXFwiLFxcXCJlc2NhcGVcXFwiLFxcXCJlcnJvclxcXCIsXFxcIlBhdHRlcm5cXFwiLFxcXCJNYXRjaFxcXCIsXFxcIkFcXFwiLFxcXCJJXFxcIixcXFwiTFxcXCIsXFxcIk1cXFwiLFxcXCJTXFxcIixcXFwiWFxcXCIsXFxcIlVcXFwiLFxcXCJBU0NJSVxcXCIsXFxcIklHTk9SRUNBU0VcXFwiLFxcXCJMT0NBTEVcXFwiLFxcXCJNVUxUSUxJTkVcXFwiLFxcXCJET1RBTExcXFwiLFxcXCJWRVJCT1NFXFxcIixcXFwiVU5JQ09ERVxcXCJdLm1hcCgoZT0+bmV3IHB5U3RyKGUpKSkpfSxfdmFsdWUybWVtYmVyPXt9LFJlZ2V4RmxhZ01ldGE9YnVpbGROYXRpdmVDbGFzcyhcXFwiUmVnZXhGbGFnTWV0YVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIFJlZ2V4RmxhZ01ldGEoKXt9LGJhc2U6cHlUeXBlLHNsb3RzOnt0cCRpdGVyKCl7Y29uc3QgZT1PYmplY3QudmFsdWVzKF9tZW1iZXJzKVtTeW1ib2wuaXRlcmF0b3JdKCk7cmV0dXJuIG5ldyBweUl0ZXJhdG9yKCgoKT0+ZS5uZXh0KCkudmFsdWUpKX0sc3EkY29udGFpbnMoZSl7aWYoIShlIGluc3RhbmNlb2YgdGhpcykpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwidW5zdXBwb3J0ZWQgb3BlcmFuZCB0eXBlKHMpIGZvciAnaW4nOiAnXFxcIit0eXBlTmFtZShlKStcXFwiJyBhbmQgJ1xcXCIrdHlwZU5hbWUodGhpcykrXFxcIidcXFwiKTtyZXR1cm4gT2JqZWN0LnZhbHVlcyhfbWVtYmVycykuaW5jbHVkZXMoZSl9fX0pO3JlLlJlZ2V4RmxhZz1idWlsZE5hdGl2ZUNsYXNzKFxcXCJSZWdleEZsYWdcXFwiLHttZXRhOlJlZ2V4RmxhZ01ldGEsYmFzZTpweUludCxjb25zdHJ1Y3RvcjpmdW5jdGlvbiBSZWdleEZsYWcoZSl7Y29uc3QgdD1fdmFsdWUybWVtYmVyW2VdO2lmKHQpcmV0dXJuIHQ7dGhpcy52PWUsX3ZhbHVlMm1lbWJlcltlXT10aGlzfSxzbG90czp7dHAkbmV3KGUsdCl7Y2hlY2tPbmVBcmcoXFxcIlJlZ2V4RmxhZ1xcXCIsZSx0KTtjb25zdCByPWVbMF0udmFsdWVPZigpO2lmKCFjaGVja0ludChyKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihvYmplY3RSZXByKHIpK1xcXCIgaXMgbm90IGEgdmFsaWQgUmVnZXhGbGFnXFxcIik7cmV0dXJuIG5ldyByZS5SZWdleEZsYWcocil9LCRyKCl7bGV0IGU9dGhpcy52YWx1ZU9mKCk7Y29uc3QgdD1lPDA7ZT10P35lOmU7Y29uc3Qgcj1bXTtPYmplY3QuZW50cmllcyhfbWVtYmVycykuZm9yRWFjaCgoKFt0LG5dKT0+e2NvbnN0IHM9bi52YWx1ZU9mKCk7ZSZzJiYoZSY9fnMsci5wdXNoKFxcXCJyZS5cXFwiK3QpKX0pKSxlJiZyLnB1c2goaGV4KGUpLnRvU3RyaW5nKCkpO2xldCBuPXIuam9pbihcXFwifFxcXCIpO3JldHVybiB0JiYobj1yLmxlbmd0aD4xP1xcXCJ+KFxcXCIrbitcXFwiKVxcXCI6XFxcIn5cXFwiK24pLG5ldyBweVN0cihuKX0sc3EkY29udGFpbnMoZSl7aWYoIShlIGluc3RhbmNlb2YgcmUuUmVnZXhGbGFnKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCInaW4nIHJlcXVpcmVzIGEgUmVnZXhGbGFnIG5vdCBcXFwiK3R5cGVOYW1lKGUpKTtyZXR1cm4gdGhpcy5uYiRhbmQoZSk9PT1lfSxuYiRhbmQ6ZmxhZ0JpdFNsb3QoKChlLHQpPT5lJnQpLEpTQkkuYml0d2lzZUFuZCksbmIkb3I6ZmxhZ0JpdFNsb3QoKChlLHQpPT5lfHQpLEpTQkkuYml0d2lzZU9yKSxuYiR4b3I6ZmxhZ0JpdFNsb3QoKChlLHQpPT5lXnQpLEpTQkkuYml0d2lzZVhvciksbmIkaW52ZXJ0OmZ1bmN0aW9uKCl7Y29uc3QgZT10aGlzLnY7cmV0dXJuXFxcIm51bWJlclxcXCI9PXR5cGVvZiBlP25ldyByZS5SZWdleEZsYWcofmUpOm5ldyByZS5SZWdleEZsYWcoSlNCSS5iaXR3aXNlTm90KGUpKX19LHByb3RvOnt2YWx1ZU9mKCl7cmV0dXJuIHRoaXMudn19LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9fSkscmUuVEVNUExBVEU9cmUuVD1uZXcgcmUuUmVnZXhGbGFnKDEpLHJlLklHTk9SRUNBU0U9cmUuST1uZXcgcmUuUmVnZXhGbGFnKDIpLHJlLkxPQ0FMRT1yZS5MPW5ldyByZS5SZWdleEZsYWcoNCkscmUuTVVMVElMSU5FPXJlLk09bmV3IHJlLlJlZ2V4RmxhZyg4KSxyZS5ET1RBTEw9cmUuUz1uZXcgcmUuUmVnZXhGbGFnKDE2KSxyZS5VTklDT0RFPXJlLlU9bmV3IHJlLlJlZ2V4RmxhZygzMikscmUuVkVSQk9TRT1yZS5YPW5ldyByZS5SZWdleEZsYWcoNjQpLHJlLkRFQlVHPW5ldyByZS5SZWdleEZsYWcoMTI4KSxyZS5BU0NJST1yZS5BPW5ldyByZS5SZWdleEZsYWcoMjU2KTtjb25zdCBfbWVtYmVycz17QVNDSUk6cmUuQSxJR05PUkVDQVNFOnJlLkksTE9DQUxFOnJlLkwsVU5JQ09ERTpyZS5VLE1VTFRJTElORTpyZS5NLERPVEFMTDpyZS5TLFZFUkJPU0U6cmUuWCxURU1QTEFURTpyZS5ULERFQlVHOnJlLkRFQlVHfTtmdW5jdGlvbiBmbGFnQml0U2xvdChlLHQpe3JldHVybiBmdW5jdGlvbihyKXtpZihyIGluc3RhbmNlb2YgcmUuUmVnZXhGbGFnfHxyIGluc3RhbmNlb2YgcHlJbnQpe2xldCBuPXRoaXMudixzPXIudjtpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mIG4mJlxcXCJudW1iZXJcXFwiPT10eXBlb2Ygcyl7bGV0IHQ9ZShuLHMpO3JldHVybiB0PDAmJih0Kz00Mjk0OTY3Mjk2KSxuZXcgcmUuUmVnZXhGbGFnKHQpfXJldHVybiBuPUpTQkkuQmlnVXAobikscz1KU0JJLkJpZ1VwKHMpLG5ldyByZS5SZWdleEZsYWcoSlNCSS5udW1iZXJJZlNhZmUodChuLHMpKSl9cmV0dXJuIHB5Tm90SW1wbGVtZW50ZWR9fWNvbnN0IGpzRmxhZ3M9e2k6cmUuSSxtOnJlLk0sczpyZS5TLHU6cmUuVX0sanNJbmxpbmVGbGFncz17aTpyZS5JLGE6cmUuQSxzOnJlLlMsTDpyZS5MLG06cmUuTSx1OnJlLlUseDpyZS5YfTtSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KFxcXCJzdGlja3lcXFwiKXx8ZGVsZXRlIGpzRmxhZ3MucyxSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KFxcXCJ1bmljb2RlXFxcIil8fGRlbGV0ZSBqc0ZsYWdzLnU7Y29uc3QgZmxhZ0ZhaWxzPU9iamVjdC5lbnRyaWVzKHtcXFwiY2Fubm90IHVzZSBMT0NBTEUgZmxhZyB3aXRoIGEgc3RyIHBhdHRlcm5cXFwiOnJlLkwsXFxcIkFTQ0lJIGFuZCBVTklDT0RFIGZsYWdzIGFyZSBpbmNvbXBhdGlibGVcXFwiOm5ldyByZS5SZWdleEZsYWcocmUuQS52YWx1ZU9mKCl8cmUuVS52YWx1ZU9mKCkpfSksaW5saW5lX3JlZ2V4PS9cXFxcKFxcXFw/KFtpc2FtdXhdKylcXFxcKS9nO2Z1bmN0aW9uIGFkanVzdEZsYWdzKGUsdCl7bGV0IHI9ZS50b1N0cmluZygpLG49XFxcImdcXFwiLHM9MDtyZXR1cm4gcj1yLnJlcGxhY2UoaW5saW5lX3JlZ2V4LCgoZSx0KT0+e2ZvcihsZXQgciBvZiB0KXtjb25zdCBlPWpzSW5saW5lRmxhZ3Nbcl07c3w9ZS52YWx1ZU9mKCl9cmV0dXJuXFxcIlxcXCJ9KSksZmxhZ0ZhaWxzLmZvckVhY2goKChbZSx0XSk9PntpZigodC52YWx1ZU9mKCkmcyk9PT10LnZhbHVlT2YoKSl0aHJvdyBuZXcgcmUuZXJyb3IoXFxcImJhZCBiYWQgaW5saW5lIGZsYWdzOiBcXFwiK2UpfSkpLHQ9bnVtYmVyQmluT3AobmV3IHJlLlJlZ2V4RmxhZyhzKSx0LFxcXCJCaXRPclxcXCIpLGZsYWdGYWlscy5mb3JFYWNoKCgoW2Uscl0pPT57aWYobnVtYmVyQmluT3Aocix0LFxcXCJCaXRBbmRcXFwiKT09PXIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoZSl9KSksbnVtYmVyQmluT3AocmUuQSx0LFxcXCJCaXRBbmRcXFwiKSE9PXJlLkEmJih0PW51bWJlckJpbk9wKHJlLlUsdCxcXFwiQml0T3JcXFwiKSksT2JqZWN0LmVudHJpZXMoanNGbGFncykuZm9yRWFjaCgoKFtlLHJdKT0+e251bWJlckJpbk9wKHIsdCxcXFwiQml0QW5kXFxcIik9PT1yJiYobis9ZSl9KSksdD1uZXcgcmUuUmVnZXhGbGFnKHQudmFsdWVPZigpKSxbcixuLHRdfWxldCBuZWdfbG9va2JlaGluZF9BPVxcXCIoPzwhXFxcXFxcXFxcXFxcXFxcXG4pXFxcIjsoZnVuY3Rpb24gY2hlY2tMb29rQmVoaW5kU3VwcG9ydCgpe3RyeXtldmFsKFxcXCIvKD88IWZvbykvXFxcIil9Y2F0Y2h7bmVnX2xvb2tiZWhpbmRfQT1cXFwiXFxcIn19KSgpO2NvbnN0IHB5X3RvX2pzX3JlZ2V4PS8oW15cXFxcXFxcXF0pKHssfFxcXFxcXFxcQXxcXFxcXFxcXFp8XFxcXCR8XFxcXChcXFxcP1A9KFteXFxcXGRcXFxcV11cXFxcdyopXFxcXCl8XFxcXChcXFxcP1A8KFteXFxcXGRcXFxcV11cXFxcdyopPikoPyFbXlxcXFxbXSpcXFxcXSkvZyxweV90b19qc191bmljb2RlX2VzY2FwZT0vXFxcXFxcXFxbXFxcXHRcXFxcclxcXFxuIFxcXFx2XFxcXGYjJn5cXFwiJyFdfFxcXFxcXFxcLSg/IVteXFxcXFtdKlxcXFxdKS9nLHF1YW50aWZpZXJfZXJyb3I9L0luY29tcGxldGUgcXVhbnRpZmllcnxMb25lIHF1YW50aWZpZXIvZyxfY29tcGlsZWRfcGF0dGVybnM9T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiBjb21waWxlX3BhdHRlcm4oZSx0KXtsZXQgcixuO1tyLG4sdF09YWRqdXN0RmxhZ3MoZSx0KTtjb25zdCBzPV9jb21waWxlZF9wYXR0ZXJuc1tlLnRvU3RyaW5nKCldO2lmKHMmJnMuJGZsYWdzPT09dClyZXR1cm4gcztjb25zdCBpPXt9O2xldCBvLGE7cj1cXFwiX1xcXCIrcixyPXIucmVwbGFjZShweV90b19qc19yZWdleCwoKHQscixuLHMsbyxhKT0+e3N3aXRjaChuKXtjYXNlXFxcIlxcXFxcXFxcQVxcXCI6cmV0dXJuIHIrbmVnX2xvb2tiZWhpbmRfQStcXFwiXlxcXCI7Y2FzZVxcXCJcXFxcXFxcXFpcXFwiOnJldHVybiByK1xcXCIkKD8hXFxcXFxcXFxuKVxcXCI7Y2FzZVxcXCJ7LFxcXCI6cmV0dXJuIHIrXFxcInswLFxcXCI7Y2FzZVxcXCIkXFxcIjpyZXR1cm4gcitcXFwiKD86KD89XFxcXFxcXFxuJCl8JClcXFwiO2RlZmF1bHQ6aWYobi5lbmRzV2l0aChcXFwiPlxcXCIpKXJldHVybiBpW29dPSEwLHIrXFxcIig/PFxcXCIrbytcXFwiPlxcXCI7aWYoIWlbc10pdGhyb3cgbmV3IHJlLmVycm9yKFxcXCJ1bmtub3duIGdyb3VwIG5hbWUgXFxcIitzK1xcXCIgYXQgcG9zaXRpb24gXFxcIithKzEsZSxuZXcgcHlJbnQoYSsxKSk7cmV0dXJuIHIrXFxcIlxcXFxcXFxcazxcXFwiK3MrXFxcIj5cXFwifX0pKSxyPXIuc2xpY2UoMSk7bGV0IGw9cjtuLmluY2x1ZGVzKFxcXCJ1XFxcIikmJihsPXIucmVwbGFjZShweV90b19qc191bmljb2RlX2VzY2FwZSwoZT0+e3N3aXRjaChlKXtjYXNlXFxcIlxcXFxcXFxcIFxcXCI6cmV0dXJuXFxcIiBcXFwiO2Nhc2VcXFwiXFxcXFxcXFxcXFxcdFxcXCI6cmV0dXJuXFxcIlxcXFxcXFxcdFxcXCI7Y2FzZVxcXCJcXFxcXFxcXFxcXFxuXFxcIjpyZXR1cm5cXFwiXFxcXFxcXFxuXFxcIjtjYXNlXFxcIlxcXFxcXFxcXFxcXHZcXFwiOnJldHVyblxcXCJcXFxcXFxcXHZcXFwiO2Nhc2VcXFwiXFxcXFxcXFxcXFxcZlxcXCI6cmV0dXJuXFxcIlxcXFxcXFxcZlxcXCI7Y2FzZVxcXCJcXFxcXFxcXHJcXFwiOnJldHVyblxcXCJcXFxcXFxcXHJcXFwiO2RlZmF1bHQ6cmV0dXJuIGUuc2xpY2UoMSl9fSkpKTt0cnl7bz1uZXcgUmVnRXhwKGwsbil9Y2F0Y2goZyl7aWYoIXF1YW50aWZpZXJfZXJyb3IudGVzdChnLm1lc3NhZ2UpKXRocm93IGE9Zy5tZXNzYWdlLnN1YnN0cmluZyhnLm1lc3NhZ2UubGFzdEluZGV4T2YoXFxcIjpcXFwiKSsyKStcXFwiIGluIHBhdHRlcm46IFxcXCIrZS50b1N0cmluZygpLG5ldyByZS5lcnJvcihhLGUpO3RyeXtvPW5ldyBSZWdFeHAocixuLnJlcGxhY2UoXFxcInVcXFwiLFxcXCJcXFwiKSl9Y2F0Y2goZyl7dGhyb3cgYT1nLm1lc3NhZ2Uuc3Vic3RyaW5nKGcubWVzc2FnZS5sYXN0SW5kZXhPZihcXFwiOlxcXCIpKzIpK1xcXCIgaW4gcGF0dGVybjogXFxcIitlLnRvU3RyaW5nKCksbmV3IHJlLmVycm9yKGEsZSl9fWNvbnN0IHA9bmV3IHJlLlBhdHRlcm4obyxlLHQpO3JldHVybiBfY29tcGlsZWRfcGF0dGVybnNbZS50b1N0cmluZygpXT1wLHB9ZnVuY3Rpb24gX2NvbXBpbGUoZSx0KXtpZihlIGluc3RhbmNlb2YgcmUuUGF0dGVybil7aWYodCE9PXplcm98fHQudmFsdWVPZigpKXRocm93IG5ldyBWYWx1ZUVycm9yKFxcXCJjYW5ub3QgcHJvY2VzcyBmbGFncyBhcmd1bWVudCB3aXRoIGNvbXBpbGVkIHBhdHRlcm5cXFwiKTtyZXR1cm4gZX1pZighY2hlY2tTdHJpbmcoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBzdHJpbmcgb3IgY29tcGlsZWQgcGF0dGVyblxcXCIpO3JldHVybiBjb21waWxlX3BhdHRlcm4oZSx0KX1yZS5lcnJvcj1idWlsZE5hdGl2ZUNsYXNzKFxcXCJyZS5lcnJvclxcXCIse2Jhc2U6RXhjZXB0aW9uLGNvbnN0cnVjdG9yOmZ1bmN0aW9uIGVycm9yKGUsdCxyKXt0aGlzLiRwYXR0ZXJuPXQsdGhpcy4kbXNnPWUsdGhpcy4kcG9zPXJ8fHB5Tm9uZSxFeGNlcHRpb24uY2FsbCh0aGlzLGUpfSxzbG90czp7dHAkZG9jOlxcXCJFeGNlcHRpb24gcmFpc2VkIGZvciBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXFxcXG5cXFxcbiAgICBBdHRyaWJ1dGVzOlxcXFxuXFxcXG4gICAgICAgIG1zZzogVGhlIHVuZm9ybWF0dGVkIGVycm9yIG1lc3NhZ2VcXFxcbiAgICAgICAgcGF0dGVybjogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuXFxcXG5cXFwiLHRwJGluaXQoZSx0KXtjb25zdFtyLG4sc109Y29weUtleXdvcmRUb05hbWVkQXJncyhcXFwicmUuZXJyb3JcXFwiLFtcXFwibXNnXFxcIixcXFwicGF0dGVyblxcXCIsXFxcInBvc1xcXCJdLGUsdCxbcHlOb25lLHB5Tm9uZV0pO3RoaXMuJHBhdHRlcm49bix0aGlzLiRwb3M9cyx0aGlzLiRtc2c9cn19LGdldHNldHM6e21zZzp7JGdldCgpe3JldHVybiB0aGlzLiRtc2d9fSxwYXR0ZXJuOnskZ2V0KCl7cmV0dXJuIHRoaXMuJHBhdHRlcm59fSxwb3M6eyRnZXQoKXtyZXR1cm4gdGhpcy4kcG9zfX19fSk7Y29uc3QgemVybz1uZXcgcHlJbnQoMCksbWF4c2l6ZT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtyZS5QYXR0ZXJuPWJ1aWxkTmF0aXZlQ2xhc3MoXFxcInJlLlBhdHRlcm5cXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihlLHQscil7dGhpcy52PWUsdGhpcy5zdHI9dCx0aGlzLiRmbGFncz1yLHRoaXMuJGdyb3Vwcz1udWxsLHRoaXMuJGdyb3VwaW5kZXg9bnVsbH0sc2xvdHM6eyRyKCl7Y29uc3QgZT1vYmplY3RSZXByKHRoaXMuc3RyKS5zbGljZSgwLDIwMCksdD1vYmplY3RSZXByKHRoaXMuJGZsYWdzLm5iJGFuZChyZS5VLm5iJGludmVydCgpKSk7cmV0dXJuIG5ldyBweVN0cihcXFwicmUuY29tcGlsZShcXFwiK2UrKHQ/XFxcIiwgXFxcIit0OlxcXCJcXFwiKStcXFwiKVxcXCIpfSx0cCRyaWNoY29tcGFyZShlLHQpe2lmKFxcXCJFcVxcXCIhPT10JiZcXFwiTm90RXFcXFwiIT09dHx8IShlIGluc3RhbmNlb2YgcmUuUGF0dGVybikpcmV0dXJuIHB5Tm90SW1wbGVtZW50ZWQ7Y29uc3Qgcj10aGlzLnN0cj09PWUuc3RyJiZ0aGlzLiRmbGFncz09PWUuJGZsYWdzO3JldHVyblxcXCJFcVxcXCI9PT10P3I6IXJ9LHRwJGhhc2goKXt9LHRwJGRvYzpcXFwiQ29tcGlsZWQgcmVndWxhciBleHByZXNzaW9uIG9iamVjdC5cXFwifSxtZXRob2RzOnttYXRjaDp7JG1ldGg6ZnVuY3Rpb24gbWF0Y2goZSx0LHIpe3JldHVybiB0aGlzLiRtYXRjaChlLHQscil9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwic3RyaW5nXFxcIixcXFwicG9zXFxcIixcXFwiZW5kcG9zXFxcIl0sRGVmYXVsdHM6W3plcm8sbWF4c2l6ZV19LCR0ZXh0c2lnOlxcXCIoJHNlbGYsIC8sIHN0cmluZywgcG9zPTAsIGVuZHBvcz1zeXMubWF4c2l6ZSlcXFwiLCRkb2M6XFxcIk1hdGNoZXMgemVybyBvciBtb3JlIGNoYXJhY3RlcnMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nLlxcXCJ9LGZ1bGxtYXRjaDp7JG1ldGg6ZnVuY3Rpb24gZnVsbG1hdGNoKGUsdCxyKXtyZXR1cm4gdGhpcy5mdWxsJG1hdGNoKGUsdCxyKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJzdHJpbmdcXFwiLFxcXCJwb3NcXFwiLFxcXCJlbmRwb3NcXFwiXSxEZWZhdWx0czpbemVybyxtYXhzaXplXX0sJHRleHRzaWc6XFxcIigkc2VsZiwgLywgc3RyaW5nLCBwb3M9MCwgZW5kcG9zPXN5cy5tYXhzaXplKVxcXCIsJGRvYzpcXFwiTWF0Y2hlcyBhZ2FpbnN0IGFsbCBvZiB0aGUgc3RyaW5nLlxcXCJ9LHNlYXJjaDp7JG1ldGg6ZnVuY3Rpb24gc2VhcmNoKGUsdCxyKXtyZXR1cm4gdGhpcy4kc2VhcmNoKGUsdCxyKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJzdHJpbmdcXFwiLFxcXCJwb3NcXFwiLFxcXCJlbmRwb3NcXFwiXSxEZWZhdWx0czpbemVybyxtYXhzaXplXX0sJHRleHRzaWc6XFxcIigkc2VsZiwgLywgc3RyaW5nLCBwb3M9MCwgZW5kcG9zPXN5cy5tYXhzaXplKVxcXCIsJGRvYzpcXFwiU2NhbiB0aHJvdWdoIHN0cmluZyBsb29raW5nIGZvciBhIG1hdGNoLCBhbmQgcmV0dXJuIGEgY29ycmVzcG9uZGluZyBtYXRjaCBvYmplY3QgaW5zdGFuY2UuXFxcXG5cXFxcblJldHVybiBOb25lIGlmIG5vIHBvc2l0aW9uIGluIHRoZSBzdHJpbmcgbWF0Y2hlcy5cXFwifSxzdWI6eyRtZXRoOmZ1bmN0aW9uIHN1YihlLHQscil7cmV0dXJuIHRoaXMuJHN1YihlLHQscil9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwicmVwbFxcXCIsXFxcInN0cmluZ1xcXCIsXFxcImNvdW50XFxcIl0sRGVmYXVsdHM6W3plcm9dfSwkdGV4dHNpZzpcXFwiKCRzZWxmLCAvLCByZXBsLCBzdHJpbmcsIGNvdW50PTApXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIHN0cmluZyBvYnRhaW5lZCBieSByZXBsYWNpbmcgdGhlIGxlZnRtb3N0IG5vbi1vdmVybGFwcGluZyBvY2N1cnJlbmNlcyBvZiBwYXR0ZXJuIGluIHN0cmluZyBieSB0aGUgcmVwbGFjZW1lbnQgcmVwbC5cXFwifSxzdWJuOnskbWV0aDpmdW5jdGlvbihlLHQscil7cmV0dXJuIHRoaXMuJHN1Ym4oZSx0LHIpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInJlcGxcXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJjb3VudFxcXCJdLERlZmF1bHRzOlt6ZXJvXX0sJHRleHRzaWc6XFxcIigkc2VsZiwgLywgcmVwbCwgc3RyaW5nLCBjb3VudD0wKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSB0dXBsZSAobmV3X3N0cmluZywgbnVtYmVyX29mX3N1YnNfbWFkZSkgZm91bmQgYnkgcmVwbGFjaW5nIHRoZSBsZWZ0bW9zdCBub24tb3ZlcmxhcHBpbmcgb2NjdXJyZW5jZXMgb2YgcGF0dGVybiB3aXRoIHRoZSByZXBsYWNlbWVudCByZXBsLlxcXCJ9LGZpbmRhbGw6eyRtZXRoOmZ1bmN0aW9uIGZpbmRhbGwoZSx0LHIpe3JldHVybiB0aGlzLmZpbmQkYWxsKGUsdCxyKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJzdHJpbmdcXFwiLFxcXCJwb3NcXFwiLFxcXCJlbmRwb3NcXFwiXSxEZWZhdWx0czpbemVybyxtYXhzaXplXX0sJHRleHRzaWc6XFxcIigkc2VsZiwgLywgc3RyaW5nLCBwb3M9MCwgZW5kcG9zPXN5cy5tYXhzaXplKVxcXCIsJGRvYzpcXFwiUmV0dXJuIGEgbGlzdCBvZiBhbGwgbm9uLW92ZXJsYXBwaW5nIG1hdGNoZXMgb2YgcGF0dGVybiBpbiBzdHJpbmcuXFxcIn0sc3BsaXQ6eyRtZXRoOmZ1bmN0aW9uIHNwbGl0KGUsdCl7cmV0dXJuIHRoaXMuJHNwbGl0KGUsdCl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwic3RyaW5nXFxcIixcXFwibWF4c3BsaXRcXFwiXSxEZWZhdWx0czpbemVyb119LCR0ZXh0c2lnOlxcXCIoJHNlbGYsIC8sIHN0cmluZywgbWF4c3BsaXQ9MClcXFwiLCRkb2M6XFxcIlNwbGl0IHN0cmluZyBieSB0aGUgb2NjdXJyZW5jZXMgb2YgcGF0dGVybi5cXFwifSxmaW5kaXRlcjp7JG1ldGg6ZnVuY3Rpb24gZmluZGl0ZXIoZSx0LHIpe3JldHVybiB0aGlzLmZpbmQkaXRlcihlLHQscil9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwic3RyaW5nXFxcIixcXFwicG9zXFxcIixcXFwiZW5kcG9zXFxcIl0sRGVmYXVsdHM6W3plcm8sbWF4c2l6ZV19LCR0ZXh0c2lnOlxcXCIoJHNlbGYsIC8sIHN0cmluZywgcG9zPTAsIGVuZHBvcz1zeXMubWF4c2l6ZSlcXFwiLCRkb2M6XFxcIlJldHVybiBhbiBpdGVyYXRvciBvdmVyIGFsbCBub24tb3ZlcmxhcHBpbmcgbWF0Y2hlcyBmb3IgdGhlIFJFIHBhdHRlcm4gaW4gc3RyaW5nLlxcXFxuXFxcXG5Gb3IgZWFjaCBtYXRjaCwgdGhlIGl0ZXJhdG9yIHJldHVybnMgYSBtYXRjaCBvYmplY3QuXFxcIn0sc2Nhbm5lcjp7JG1ldGg6ZnVuY3Rpb24gc2Nhbm5lcihlLHQscil7cmV0dXJuIHRoaXMuJHNjYW5uZXIoZSx0LHIpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInN0cmluZ1xcXCIsXFxcInBvc1xcXCIsXFxcImVuZHBvc1xcXCJdLERlZmF1bHRzOlt6ZXJvLG1heHNpemVdfSwkdGV4dHNpZzpcXFwiKCRzZWxmLCAvLCBzdHJpbmcsIHBvcz0wLCBlbmRwb3M9c3lzLm1heHNpemUpXFxcIiwkZG9jOm51bGx9LF9fY29weV9fOnskbWV0aDpmdW5jdGlvbiBjb3B5KCl7cmV0dXJuIHRoaXN9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcXFwiKCRzZWxmLCAvKVxcXCIsJGRvYzpudWxsfSxfX2RlZXBjb3B5X186eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRzZWxmLCBtZW1vLCAvKVxcXCIsJGRvYzpudWxsfX0sZ2V0c2V0czp7cGF0dGVybjp7JGdldCgpe3JldHVybiB0aGlzLnN0cn0sJGRvYzpcXFwiVGhlIHBhdHRlcm4gc3RyaW5nIGZyb20gd2hpY2ggdGhlIFJFIG9iamVjdCB3YXMgY29tcGlsZWQuXFxcIn0sZmxhZ3M6eyRnZXQoKXtyZXR1cm4gdGhpcy4kZmxhZ3N9LCRkb2M6XFxcIlRoZSByZWdleCBtYXRjaGluZyBmbGFncy5cXFwifSxncm91cHM6eyRnZXQoKXtpZihudWxsPT09dGhpcy4kZ3JvdXBzKXtjb25zdCBlPSh0aGlzLnN0ci52Lm1hdGNoKHRoaXMuZ3JvdXAkcmVnZXgpfHxbXSkubGVuZ3RoO3RoaXMuJGdyb3Vwcz1uZXcgcHlJbnQoZSl9cmV0dXJuIHRoaXMuJGdyb3Vwc30sJGRvYzpcXFwiVGhlIG51bWJlciBvZiBjYXB0dXJpbmcgZ3JvdXBzIGluIHRoZSBwYXR0ZXJuLlxcXCJ9LGdyb3VwaW5kZXg6eyRnZXQoKXtpZihudWxsPT09dGhpcy4kZ3JvdXBpbmRleCl7Y29uc3QgZT10aGlzLnN0ci52Lm1hdGNoQWxsKHRoaXMuZ3JvdXAkcmVnZXgpLHQ9W107bGV0IHI9MTtmb3IoY29uc3QgbiBvZiBlKW5bMV0mJih0LnB1c2gobmV3IHB5U3RyKG5bMV0pKSx0LnB1c2gobmV3IHB5SW50KHIpKSkscisrO3RoaXMuJGdyb3VwaW5kZXg9bmV3IHB5TWFwcGluZ1Byb3h5KG5ldyBweURpY3QodCkpfXJldHVybiB0aGlzLiRncm91cGluZGV4fSwkZG9jOlxcXCJBIGRpY3Rpb25hcnkgbWFwcGluZyBncm91cCBuYW1lcyB0byBncm91cCBudW1iZXJzLlxcXCJ9fSxwcm90bzp7Z3JvdXAkcmVnZXg6L1xcXFwoKD8hXFxcXD8oPyFQPCkuKikoPzpcXFxcP1A8KFteXFxcXGRcXFxcV11cXFxcdyopPik/KD8hW15cXFxcW10qXFxcXF0pL2csZ2V0JGNvdW50OmU9PihlPWFzSW5kZXhTaXplZChlLE92ZXJmbG93RXJyb3IpKXx8TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGdldCRqc3N0cihlLHQscil7aWYoIWNoZWNrU3RyaW5nKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcImV4cGVjdGVkIHN0cmluZyBvciBieXRlcy1saWtlIG9iamVjdFxcXCIpO2lmKHQ9PT16ZXJvJiZyPT09bWF4c2l6ZXx8dm9pZCAwPT09dCYmdm9pZCAwPT09cilyZXR1cm57anNzdHI6ZS50b1N0cmluZygpLHBvczp6ZXJvLnZhbHVlT2YoKSxlbmRwb3M6ZS5zcSRsZW5ndGgoKX07Y29uc3R7c3RhcnQ6bixlbmQ6c309cHlTbGljZS5zdGFydEVuZCR3cnQoZSx0LHIpO3JldHVybntqc3N0cjplLnRvU3RyaW5nKCkuc2xpY2UobixzKSxwb3M6bixlbmRwb3M6c319LGZpbmQkYWxsKGUsdCxyKXtsZXR7anNzdHI6bn09dGhpcy5nZXQkanNzdHIoZSx0LHIpO2NvbnN0IHM9dGhpcy52LGk9bi5tYXRjaEFsbChzKSxvPVtdO2ZvcihsZXQgYSBvZiBpKW8ucHVzaCgxPT09YS5sZW5ndGg/bmV3IHB5U3RyKGFbMF0pOjI9PT1hLmxlbmd0aD9uZXcgcHlTdHIoYVsxXSk6bmV3IHB5VHVwbGUoYS5zbGljZSgxKS5tYXAoKGU9Pm5ldyBweVN0cihlKSkpKSk7cmV0dXJuIG5ldyBweUxpc3Qobyl9LCRzcGxpdChlLHQpe3Q9KHQ9YXNJbmRleFNpemVkKHQpKXx8TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO2xldHtqc3N0cjpyfT10aGlzLmdldCRqc3N0cihlKTtjb25zdCBuPXRoaXMudixzPVtdO2xldCBpLG89MCxhPTA7Zm9yKDtudWxsIT09KGk9bi5leGVjKHIpKSYmbzx0OylpZihzLnB1c2gobmV3IHB5U3RyKHIuc3Vic3RyaW5nKGEsaS5pbmRleCkpKSxpLmxlbmd0aD4xJiZzLnB1c2goLi4uaS5zbGljZSgxKS5tYXAoKGU9PnZvaWQgMD09PWU/cHlOb25lOm5ldyBweVN0cihlKSkpKSxvKyssYT1uLmxhc3RJbmRleCxpLmluZGV4PT09bi5sYXN0SW5kZXgpe2lmKCFyKWJyZWFrO3I9ci5zbGljZShpLmluZGV4KSxhPTAsbi5sYXN0SW5kZXg9MX1yZXR1cm4gbi5sYXN0SW5kZXg9MCxzLnB1c2gobmV3IHB5U3RyKHIuc2xpY2UoYSkpKSxuZXcgcHlMaXN0KHMpfSxtYXRjaCRmcm9tX3JlcGwoZSx0LHIsbil7bGV0IHM7Y29uc3QgaT1lW2UubGVuZ3RoLTFdO3JldHVyblxcXCJvYmplY3RcXFwiPT10eXBlb2YgaT8ocz1lLnNsaWNlKDAsZS5sZW5ndGgtMyksT2JqZWN0LmFzc2lnbihzLHtncm91cHM6aX0pLHMuaW5kZXg9ZVtlLmxlbmd0aC0zXSk6KHM9ZS5zbGljZSgwLGUubGVuZ3RoLTIpLHMuZ3JvdXBzPXZvaWQgMCxzLmluZGV4PWVbZS5sZW5ndGgtMl0pLG5ldyByZS5NYXRjaChzLHRoaXMuc3RyLHQscixuKX0sZG8kc3ViKGUsdCxyKXtjb25zdHtqc3N0cjpuLHBvczpzLGVuZHBvczppfT10aGlzLmdldCRqc3N0cih0KTtsZXQgbztjaGVja0NhbGxhYmxlKGUpP289dD0+e2NvbnN0IHI9cHlDYWxsKGUsW3RdKTtpZighY2hlY2tTdHJpbmcocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiZXhwZWN0ZWQgc3RyIGluc3RhbmNlLCBcXFwiK3R5cGVOYW1lKHIpK1xcXCIgZm91bmRcXFwiKTtyZXR1cm4gci50b1N0cmluZygpfTooZT10aGlzLmdldCRqc3N0cihlKS5qc3N0cixvPXQ9PnQudGVtcGxhdGUkcmVwbChlKSkscj10aGlzLmdldCRjb3VudChyKTtsZXQgYT0wO2NvbnN0IGw9bi5yZXBsYWNlKHRoaXMudiwoKC4uLmUpPT57aWYoYT49cilyZXR1cm4gZVswXTthKys7Y29uc3Qgbj10aGlzLm1hdGNoJGZyb21fcmVwbChlLHQscyxpKTtyZXR1cm4gbyhuKX0pKTtyZXR1cm5bbmV3IHB5U3RyKGwpLG5ldyBweUludChhKV19LCRzdWIoZSx0LHIpe2NvbnN0W25dPXRoaXMuZG8kc3ViKGUsdCxyKTtyZXR1cm4gbn0sJHN1Ym4oZSx0LHIpe3JldHVybiBuZXcgcHlUdXBsZSh0aGlzLmRvJHN1YihlLHQscikpfSxkbyRtYXRjaChlLHQscixuKXtsZXQgczsoe2pzc3RyOnMscG9zOnIsZW5kcG9zOm59PXRoaXMuZ2V0JGpzc3RyKHQscixuKSk7Y29uc3QgaT1zLm1hdGNoKGUpO3JldHVybiBudWxsPT09aT9weU5vbmU6bmV3IHJlLk1hdGNoKGksdGhpcyx0LHIsbil9LCRzZWFyY2goZSx0LHIpe3ZhciBuPW5ldyBSZWdFeHAodGhpcy52LnNvdXJjZSx0aGlzLnYuZmxhZ3MucmVwbGFjZShcXFwiZ1xcXCIsXFxcIlxcXCIpKTtyZXR1cm4gdGhpcy5kbyRtYXRjaChuLGUsdCxyKX0sJG1hdGNoKGUsdCxyKXtsZXQgbj10aGlzLnYuc291cmNlLHM9dGhpcy52LmZsYWdzLnJlcGxhY2UoXFxcImdcXFwiLFxcXCJcXFwiKS5yZXBsYWNlKFxcXCJtXFxcIixcXFwiXFxcIik7bj1cXFwiXlxcXCIrbjt2YXIgaT1uZXcgUmVnRXhwKG4scyk7cmV0dXJuIHRoaXMuZG8kbWF0Y2goaSxlLHQscil9LGZ1bGwkbWF0Y2goZSx0LHIpe2xldCBuPXRoaXMudi5zb3VyY2Uscz10aGlzLnYuZmxhZ3MucmVwbGFjZShcXFwiZ1xcXCIsXFxcIlxcXCIpLnJlcGxhY2UoXFxcIm1cXFwiLFxcXCJcXFwiKTtuPVxcXCJeKD86XFxcIituK1xcXCIpJFxcXCI7dmFyIGk9bmV3IFJlZ0V4cChuLHMpO3JldHVybiB0aGlzLmRvJG1hdGNoKGksZSx0LHIpfSxmaW5kJGl0ZXIoZSx0LHIpe2xldCBuOyh7anNzdHI6bixwb3M6dCxlbmRwb3M6cn09dGhpcy5nZXQkanNzdHIoZSx0LHIpKTtjb25zdCBzPW4ubWF0Y2hBbGwodGhpcy52KTtyZXR1cm4gbmV3IHB5SXRlcmF0b3IoKCgpPT57Y29uc3Qgbj1zLm5leHQoKS52YWx1ZTtpZih2b2lkIDAhPT1uKXJldHVybiBuZXcgcmUuTWF0Y2gobix0aGlzLGUsdCxyKX0pKX19LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9fSkscmUuTWF0Y2g9YnVpbGROYXRpdmVDbGFzcyhcXFwicmUuTWF0Y2hcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihlLHQscixuLHMpe3RoaXMudj1lLHRoaXMuJG1hdGNoPW5ldyBweVN0cih0aGlzLnZbMF0pLHRoaXMuc3RyPXIsdGhpcy4kcmU9dCx0aGlzLiRwb3M9bix0aGlzLiRlbmRwb3M9cyx0aGlzLiRncm91cGRpY3Q9bnVsbCx0aGlzLiRncm91cHM9bnVsbCx0aGlzLiRsYXN0aW5kZXg9bnVsbCx0aGlzLiRsYXN0Z3JvdXA9bnVsbCx0aGlzLiRyZWdzPW51bGx9LHNsb3RzOnt0cCRkb2M6XFxcIlRoZSByZXN1bHQgb2YgcmUubWF0Y2goKSBhbmQgcmUuc2VhcmNoKCkuXFxcXG5NYXRjaCBvYmplY3RzIGFsd2F5cyBoYXZlIGEgYm9vbGVhbiB2YWx1ZSBvZiBUcnVlLlxcXCIsJHIoKXtsZXQgZT1cXFwiPHJlLk1hdGNoIG9iamVjdDsgXFxcIjtyZXR1cm4gZSs9XFxcInNwYW49KFxcXCIrdGhpcy52LmluZGV4K1xcXCIsIFxcXCIrKHRoaXMudi5pbmRleCt0aGlzLiRtYXRjaC5zcSRsZW5ndGgoKSkrXFxcIiksIFxcXCIsZSs9XFxcIm1hdGNoPVxcXCIrb2JqZWN0UmVwcih0aGlzLiRtYXRjaCkrXFxcIj5cXFwiLG5ldyBweVN0cihlKX0sdHAkYXNfc3F1ZW5jZV9vcl9tYXBwaW5nOiEwLG1wJHN1YnNjcmlwdChlKXtjb25zdCB0PXRoaXMuZ2V0JGdyb3VwKGUpO3JldHVybiB2b2lkIDA9PT10P3B5Tm9uZTpuZXcgcHlTdHIodCl9fSxtZXRob2RzOntncm91cDp7JG1ldGg6ZnVuY3Rpb24gZ3JvdXAoLi4uZSl7bGV0IHQ7cmV0dXJuIGUubGVuZ3RoPD0xPyh0PXRoaXMuZ2V0JGdyb3VwKGVbMF0pLHZvaWQgMD09PXQ/cHlOb25lOm5ldyBweVN0cih0KSk6KHQ9W10sZS5mb3JFYWNoKChlPT57ZT10aGlzLmdldCRncm91cChlKSx0LnB1c2godm9pZCAwPT09ZT9weU5vbmU6bmV3IHB5U3RyKGUpKX0pKSxuZXcgcHlUdXBsZSh0KSl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcImdyb3VwKFtncm91cDEsIC4uLl0pIC0+IHN0ciBvciB0dXBsZS5cXFxcbiAgICBSZXR1cm4gc3ViZ3JvdXAocykgb2YgdGhlIG1hdGNoIGJ5IGluZGljZXMgb3IgbmFtZXMuXFxcXG4gICAgRm9yIDAgcmV0dXJucyB0aGUgZW50aXJlIG1hdGNoLlxcXCJ9LHN0YXJ0OnskbWV0aDpmdW5jdGlvbiBzdGFydChlKXtjb25zdCB0PXRoaXMuZ2V0JGdyb3VwKGUpO3JldHVybiBuZXcgcHlJbnQodm9pZCAwPT09dD8tMTp0aGlzLnN0ci52LmluZGV4T2YodCx0aGlzLnYuaW5kZXgrdGhpcy4kcG9zKSl9LCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6XFxcIigkc2VsZiwgZ3JvdXA9MCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBpbmRleCBvZiB0aGUgc3RhcnQgb2YgdGhlIHN1YnN0cmluZyBtYXRjaGVkIGJ5IGdyb3VwLlxcXCJ9LGVuZDp7JG1ldGg6ZnVuY3Rpb24gZW5kKGUpe2NvbnN0IHQ9dGhpcy5nZXQkZ3JvdXAoZSk7cmV0dXJuIG5ldyBweUludCh2b2lkIDA9PT10Py0xOnRoaXMuc3RyLnYuaW5kZXhPZih0LHRoaXMudi5pbmRleCt0aGlzLiRwb3MpK1suLi50XS5sZW5ndGgpfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlxcXCIoJHNlbGYsIGdyb3VwPTAsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gaW5kZXggb2YgdGhlIGVuZCBvZiB0aGUgc3Vic3RyaW5nIG1hdGNoZWQgYnkgZ3JvdXAuXFxcIn0sc3Bhbjp7JG1ldGg6ZnVuY3Rpb24gc3BhbihlKXtyZXR1cm4gdGhpcy4kc3BhbihlKX0sJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcXFwiKCRzZWxmLCBncm91cD0wLCAvKVxcXCIsJGRvYzpcXFwiRm9yIG1hdGNoIG9iamVjdCBtLCByZXR1cm4gdGhlIDItdHVwbGUgKG0uc3RhcnQoZ3JvdXApLCBtLmVuZChncm91cCkpLlxcXCJ9LGdyb3Vwczp7JG1ldGg6ZnVuY3Rpb24gZ3JvdXBzKGUpe3JldHVybiBudWxsIT09dGhpcy4kZ3JvdXBzfHwodGhpcy4kZ3JvdXBzPUFycmF5LmZyb20odGhpcy52LnNsaWNlKDEpLCh0PT52b2lkIDA9PT10P2U6bmV3IHB5U3RyKHQpKSksdGhpcy4kZ3JvdXBzPW5ldyBweVR1cGxlKHRoaXMuJGdyb3VwcykpLHRoaXMuJGdyb3Vwc30sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJkZWZhdWx0XFxcIl0sRGVmYXVsdHM6W3B5Tm9uZV19LCR0ZXh0c2lnOlxcXCIoJHNlbGYsIC8sIGRlZmF1bHQ9Tm9uZSlcXFwiLCRkb2M6XFxcIlJldHVybiBhIHR1cGxlIGNvbnRhaW5pbmcgYWxsIHRoZSBzdWJncm91cHMgb2YgdGhlIG1hdGNoLCBmcm9tIDEuXFxcXG5cXFxcbiAgZGVmYXVsdFxcXFxuICAgIElzIHVzZWQgZm9yIGdyb3VwcyB0aGF0IGRpZCBub3QgcGFydGljaXBhdGUgaW4gdGhlIG1hdGNoLlxcXCJ9LGdyb3VwZGljdDp7JG1ldGg6ZnVuY3Rpb24gZ3JvdXBkaWN0KGUpe2lmKG51bGwhPT10aGlzLiRncm91cGRpY3QpcmV0dXJuIHRoaXMuJGdyb3VwZGljdDtpZih2b2lkIDA9PT10aGlzLnYuZ3JvdXBzKXRoaXMuJGdyb3VwZGljdD1uZXcgcHlEaWN0O2Vsc2V7Y29uc3QgdD1bXTtPYmplY3QuZW50cmllcyh0aGlzLnYuZ3JvdXBzKS5mb3JFYWNoKCgoW3Isbl0pPT57dC5wdXNoKG5ldyBweVN0cihyKSksdC5wdXNoKHZvaWQgMD09PW4/ZTpuZXcgcHlTdHIobikpfSkpLHRoaXMuJGdyb3VwZGljdD1uZXcgcHlEaWN0KHQpfXJldHVybiB0aGlzLiRncm91cGRpY3R9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwiZGVmYXVsdFxcXCJdLERlZmF1bHRzOltweU5vbmVdfSwkdGV4dHNpZzpcXFwiKCRzZWxmLCAvLCBkZWZhdWx0PU5vbmUpXFxcIiwkZG9jOlxcXCJSZXR1cm4gYSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgYWxsIHRoZSBuYW1lZCBzdWJncm91cHMgb2YgdGhlIG1hdGNoLCBrZXllZCBieSB0aGUgc3ViZ3JvdXAgbmFtZS5cXFxcblxcXFxuICBkZWZhdWx0XFxcXG4gICAgSXMgdXNlZCBmb3IgZ3JvdXBzIHRoYXQgZGlkIG5vdCBwYXJ0aWNpcGF0ZSBpbiB0aGUgbWF0Y2guXFxcIn0sZXhwYW5kOnskbWV0aDpmdW5jdGlvbiBleHBhbmQoZSl7aWYoIWNoZWNrU3RyaW5nKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcImV4cGVjdGVkIHN0ciBpbnN0YW5jZSBnb3QgXFxcIit0eXBlTmFtZShlKSk7cmV0dXJuIGU9ZS50b1N0cmluZygpLGU9dGhpcy50ZW1wbGF0ZSRyZXBsKGUpLG5ldyBweVN0cihlKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJHNlbGYsIC8sIHRlbXBsYXRlKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBzdHJpbmcgb2J0YWluZWQgYnkgZG9pbmcgYmFja3NsYXNoIHN1YnN0aXR1dGlvbiBvbiB0aGUgc3RyaW5nIHRlbXBsYXRlLCBhcyBkb25lIGJ5IHRoZSBzdWIoKSBtZXRob2QuXFxcIn0sX19jb3B5X186eyRtZXRoOmZ1bmN0aW9uIF9fY29weV9fKCl7cmV0dXJuIHRoaXN9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcXFwiKCRzZWxmLCAvKVxcXCIsJGRvYzpudWxsfSxfX2RlZXBjb3B5X186eyRtZXRoOmZ1bmN0aW9uIF9fZGVlcGNvcHlfXygpe3JldHVybiB0aGlzfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkc2VsZiwgbWVtbywgLylcXFwiLCRkb2M6bnVsbH19LGdldHNldHM6e2xhc3RpbmRleDp7JGdldCgpe2lmKG51bGwhPT10aGlzLiRsYXN0aW5kZXgpcmV0dXJuIHRoaXMuJGxhc3RpbmRleDtsZXQgZSx0PTA7cmV0dXJuIHRoaXMudi5mb3JFYWNoKCgocixuKT0+e24mJnZvaWQgMCE9PXImJmUhPT1yJiYodD1uLGU9cil9KSksdGhpcy4kbGFzdGluZGV4PXQ/bmV3IHB5SW50KHQpOnB5Tm9uZSx0aGlzLiRsYXN0aW5kZXh9LCRkb2M6XFxcIlRoZSBpbnRlZ2VyIGluZGV4IG9mIHRoZSBsYXN0IG1hdGNoZWQgY2FwdHVyaW5nIGdyb3VwLlxcXCJ9LGxhc3Rncm91cDp7JGdldCgpe2lmKG51bGwhPT10aGlzLiRsYXN0Z3JvdXApcmV0dXJuIHRoaXMuJGxhc3Rncm91cDtpZih2b2lkIDA9PT10aGlzLnYuZ3JvdXBzKXRoaXMuJGxhc3Rncm91cD1weU5vbmU7ZWxzZXtsZXQgZTtPYmplY3QuZW50cmllcyh0aGlzLnYuZ3JvdXBzKS5mb3JFYWNoKCgoW3Qscl0pPT57dm9pZCAwIT09ciYmKGU9dCl9KSksdGhpcy4kbGFzdGdyb3VwPXZvaWQgMD09PWU/cHlOb25lOm5ldyBweVN0cihlKX1yZXR1cm4gdGhpcy4kbGFzdGdyb3VwfSwkZG9jOlxcXCJUaGUgbmFtZSBvZiB0aGUgbGFzdCBtYXRjaGVkIGNhcHR1cmluZyBncm91cC5cXFwifSxyZWdzOnskZ2V0KCl7aWYobnVsbCE9PXRoaXMuJHJlZ3MpcmV0dXJuIHRoaXMuJHJlZ3M7Y29uc3QgZT1bXTtyZXR1cm4gdGhpcy52LmZvckVhY2goKCh0LHIpPT57ZS5wdXNoKHRoaXMuJHNwYW4ocikpfSkpLHRoaXMuJHJlZ3M9bmV3IHB5VHVwbGUoZSksdGhpcy4kcmVnc319LHN0cmluZzp7JGdldCgpe3JldHVybiB0aGlzLnN0cn0sJGRvYzpcXFwiVGhlIHN0cmluZyBwYXNzZWQgdG8gbWF0Y2goKSBvciBzZWFyY2goKS5cXFwifSxyZTp7JGdldCgpe3JldHVybiB0aGlzLiRyZX0sJGRvYzpcXFwiVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QuXFxcIn0scG9zOnskZ2V0KCl7cmV0dXJuIG5ldyBweUludCh0aGlzLiRwb3MpfSwkZG9jOlxcXCJUaGUgaW5kZXggaW50byB0aGUgc3RyaW5nIGF0IHdoaWNoIHRoZSBSRSBlbmdpbmUgc3RhcnRlZCBsb29raW5nIGZvciBhIG1hdGNoLlxcXCJ9LGVuZHBvczp7JGdldCgpe3JldHVybiBuZXcgcHlJbnQodGhpcy4kZW5kcG9zKX0sJGRvYzpcXFwiVGhlIGluZGV4IGludG8gdGhlIHN0cmluZyBiZXlvbmQgd2hpY2ggdGhlIFJFIGVuZ2luZSB3aWxsIG5vdCBnby5cXFwifX0scHJvdG86e2dldCRncm91cChlKXtpZih2b2lkIDA9PT1lKXJldHVybiB0aGlzLnZbMF07aWYoY2hlY2tTdHJpbmcoZSkpe2lmKGU9ZS50b1N0cmluZygpLHRoaXMudi5ncm91cHMmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnYuZ3JvdXBzLGUpKXJldHVybiB0aGlzLnYuZ3JvdXBzW2VdfWVsc2UgaWYoaXNJbmRleChlKSYmKGU9YXNJbmRleFNpemVkKGUpKT49MCYmZTx0aGlzLnYubGVuZ3RoKXJldHVybiB0aGlzLnZbZV07dGhyb3cgbmV3IEluZGV4RXJyb3IoXFxcIm5vIHN1Y2ggZ3JvdXBcXFwiKX0sJHNwYW4oZSl7Y29uc3QgdD10aGlzLmdldCRncm91cChlKTtpZih2b2lkIDA9PT10KXJldHVybiBuZXcgcHlUdXBsZShbbmV3IHB5SW50KC0xKSxuZXcgcHlJbnQoLTEpXSk7bGV0IHI7cmV0dXJuXFxcIlxcXCI9PT10JiZcXFwiXFxcIj09PXRoaXMudlswXT8ocj1uZXcgcHlJbnQodGhpcy52LmluZGV4KSxuZXcgcHlUdXBsZShbcixyXSkpOihyPXRoaXMuc3RyLnYuaW5kZXhPZih0LHRoaXMudi5pbmRleCt0aGlzLiRwb3MpLG5ldyBweVR1cGxlKFtuZXcgcHlJbnQociksbmV3IHB5SW50KHIrWy4uLnRdLmxlbmd0aCldKSl9LGhhc093blByb3BlcnR5Ok9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksdGVtcGxhdGUkcmVnZXg6L1xcXFxcXFxcKFsxLTldWzAtOV18WzEtOV0pfFxcXFxcXFxcZzwoWzEtOV1bMC05XSopPnxcXFxcXFxcXGc8KFteXFxcXGRcXFxcV11cXFxcdyopPnxcXFxcXFxcXGc8Py4qPj8vZyx0ZW1wbGF0ZSRyZXBsKGUpe3JldHVybiBlLnJlcGxhY2UodGhpcy50ZW1wbGF0ZSRyZWdleCwoKGUsdCxyLG4scyxpKT0+e2xldCBvO2lmKHZvaWQgMCE9PSh0PXR8fHIpP289dDx0aGlzLnYubGVuZ3RoP3RoaXMudlt0XXx8XFxcIlxcXCI6dm9pZCAwOnRoaXMudi5ncm91cHMmJnRoaXMuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnYuZ3JvdXBzLG4pJiYobz10aGlzLnYuZ3JvdXBzW25dfHxcXFwiXFxcIiksdm9pZCAwPT09byl7aWYobil0aHJvdyBuZXcgSW5kZXhFcnJvcihcXFwidW5rbm93biBncm91cCBuYW1lICdcXFwiK24rXFxcIidcXFwiKTt0aHJvdyBuZXcgcmUuZXJyb3IoXFxcImludmFsaWQgZ3JvdXAgcmVmZXJlbmNlIFxcXCIrKHR8fGUuc2xpY2UoMikpK1xcXCIgYXQgcG9zaXRpb24gXFxcIisocysxKSl9cmV0dXJuIG99KSl9fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pLHNldFVwTW9kdWxlTWV0aG9kcyhcXFwicmVcXFwiLHJlLHttYXRjaDp7JG1ldGg6ZnVuY3Rpb24gbWF0Y2goZSx0LHIpe3JldHVybiBfY29tcGlsZShlLHIpLiRtYXRjaCh0KX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJwYXR0ZXJuXFxcIixcXFwic3RyaW5nXFxcIixcXFwiZmxhZ3NcXFwiXSxEZWZhdWx0czpbemVyb119LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgLyAsIHBhdHRlcm4sIHN0cmluZywgZmxhZ3M9MClcXFwiLCRkb2M6XFxcIlRyeSB0byBhcHBseSB0aGUgcGF0dGVybiBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZywgcmV0dXJuaW5nXFxcXG4gICAgYSBNYXRjaCBvYmplY3QsIG9yIE5vbmUgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kLlxcXCJ9LGZ1bGxtYXRjaDp7JG1ldGg6ZnVuY3Rpb24gZnVsbG1hdGNoKGUsdCxyKXtyZXR1cm4gX2NvbXBpbGUoZSxyKS5mdWxsJG1hdGNoKHQpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInBhdHRlcm5cXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJmbGFnc1xcXCJdLERlZmF1bHRzOlt6ZXJvXX0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCAvICwgcGF0dGVybiwgc3RyaW5nLCBmbGFncz0wKVxcXCIsJGRvYzpcXFwiVHJ5IHRvIGFwcGx5IHRoZSBwYXR0ZXJuIHRvIGFsbCBvZiB0aGUgc3RyaW5nLCByZXR1cm5pbmdcXFxcbiAgICBhIE1hdGNoIG9iamVjdCwgb3IgTm9uZSBpZiBubyBtYXRjaCB3YXMgZm91bmQuXFxcIn0sc2VhcmNoOnskbWV0aDpmdW5jdGlvbiBzZWFyY2goZSx0LHIpe3JldHVybiBfY29tcGlsZShlLHIpLiRzZWFyY2godCl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwicGF0dGVyblxcXCIsXFxcInN0cmluZ1xcXCIsXFxcImZsYWdzXFxcIl0sRGVmYXVsdHM6W3plcm9dfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gLCBwYXR0ZXJuLCBzdHJpbmcsIGZsYWdzPTApXFxcIiwkZG9jOlxcXCJTY2FuIHRocm91Z2ggc3RyaW5nIGxvb2tpbmcgZm9yIGEgbWF0Y2ggdG8gdGhlIHBhdHRlcm4sIHJldHVybmluZ1xcXFxuICAgIGEgTWF0Y2ggb2JqZWN0LCBvciBOb25lIGlmIG5vIG1hdGNoIHdhcyBmb3VuZC5cXFwifSxzdWI6eyRtZXRoOmZ1bmN0aW9uIHN1YihlLHQscixuLHMpe3JldHVybiBfY29tcGlsZShlLHMpLiRzdWIodCxyLG4pfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInBhdHRlcm5cXFwiLFxcXCJyZXBsXFxcIixcXFwic3RyaW5nXFxcIixcXFwiY291bnRcXFwiLFxcXCJmbGFnc1xcXCJdLERlZmF1bHRzOlt6ZXJvLHplcm9dfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gLCBwYXR0ZXJuLCBzdHJpbmcsIGNvdW50PTAsIGZsYWdzPTApXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIHN0cmluZyBvYnRhaW5lZCBieSByZXBsYWNpbmcgdGhlIGxlZnRtb3N0XFxcXG4gICAgbm9uLW92ZXJsYXBwaW5nIG9jY3VycmVuY2VzIG9mIHRoZSBwYXR0ZXJuIGluIHN0cmluZyBieSB0aGVcXFxcbiAgICByZXBsYWNlbWVudCByZXBsLiAgcmVwbCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgY2FsbGFibGU7XFxcXG4gICAgaWYgYSBzdHJpbmcsIGJhY2tzbGFzaCBlc2NhcGVzIGluIGl0IGFyZSBwcm9jZXNzZWQuICBJZiBpdCBpc1xcXFxuICAgIGEgY2FsbGFibGUsIGl0J3MgcGFzc2VkIHRoZSBNYXRjaCBvYmplY3QgYW5kIG11c3QgcmV0dXJuXFxcXG4gICAgYSByZXBsYWNlbWVudCBzdHJpbmcgdG8gYmUgdXNlZC5cXFwifSxzdWJuOnskbWV0aDpmdW5jdGlvbiBzdWJuKGUsdCxyLG4scyl7cmV0dXJuIF9jb21waWxlKGUscykuJHN1Ym4odCxyLG4pfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInBhdHRlcm5cXFwiLFxcXCJyZXBsXFxcIixcXFwic3RyaW5nXFxcIixcXFwiY291bnRcXFwiLFxcXCJmbGFnc1xcXCJdLERlZmF1bHRzOlt6ZXJvLHplcm9dfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gLCBwYXR0ZXJuLCBzdHJpbmcsIGNvdW50PTAsIGZsYWdzPTApXFxcIiwkZG9jOlxcXCJSZXR1cm4gYSAyLXR1cGxlIGNvbnRhaW5pbmcgKG5ld19zdHJpbmcsIG51bWJlcikuXFxcXG4gICAgbmV3X3N0cmluZyBpcyB0aGUgc3RyaW5nIG9idGFpbmVkIGJ5IHJlcGxhY2luZyB0aGUgbGVmdG1vc3RcXFxcbiAgICBub24tb3ZlcmxhcHBpbmcgb2NjdXJyZW5jZXMgb2YgdGhlIHBhdHRlcm4gaW4gdGhlIHNvdXJjZVxcXFxuICAgIHN0cmluZyBieSB0aGUgcmVwbGFjZW1lbnQgcmVwbC4gIG51bWJlciBpcyB0aGUgbnVtYmVyIG9mXFxcXG4gICAgc3Vic3RpdHV0aW9ucyB0aGF0IHdlcmUgbWFkZS4gcmVwbCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFcXFxcbiAgICBjYWxsYWJsZTsgaWYgYSBzdHJpbmcsIGJhY2tzbGFzaCBlc2NhcGVzIGluIGl0IGFyZSBwcm9jZXNzZWQuXFxcXG4gICAgSWYgaXQgaXMgYSBjYWxsYWJsZSwgaXQncyBwYXNzZWQgdGhlIE1hdGNoIG9iamVjdCBhbmQgbXVzdFxcXFxuICAgIHJldHVybiBhIHJlcGxhY2VtZW50IHN0cmluZyB0byBiZSB1c2VkLlxcXCJ9LHNwbGl0OnskbWV0aDpmdW5jdGlvbiBzcGxpdChlLHQscixuKXtyZXR1cm4gX2NvbXBpbGUoZSxuKS4kc3BsaXQodCxyKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJwYXR0ZXJuXFxcIixcXFwic3RyaW5nXFxcIixcXFwibWF4c3BsaXRcXFwiLFxcXCJmbGFnc1xcXCJdLERlZmF1bHRzOlt6ZXJvLHplcm9dfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gLCBwYXR0ZXJuLCBzdHJpbmcsIG1heHNwbGl0PTAsIGZsYWdzPTApXFxcIiwkZG9jOlxcXCJTcGxpdCB0aGUgc291cmNlIHN0cmluZyBieSB0aGUgb2NjdXJyZW5jZXMgb2YgdGhlIHBhdHRlcm4sXFxcXG4gICAgcmV0dXJuaW5nIGEgbGlzdCBjb250YWluaW5nIHRoZSByZXN1bHRpbmcgc3Vic3RyaW5ncy4gIElmXFxcXG4gICAgY2FwdHVyaW5nIHBhcmVudGhlc2VzIGFyZSB1c2VkIGluIHBhdHRlcm4sIHRoZW4gdGhlIHRleHQgb2YgYWxsXFxcXG4gICAgZ3JvdXBzIGluIHRoZSBwYXR0ZXJuIGFyZSBhbHNvIHJldHVybmVkIGFzIHBhcnQgb2YgdGhlIHJlc3VsdGluZ1xcXFxuICAgIGxpc3QuICBJZiBtYXhzcGxpdCBpcyBub256ZXJvLCBhdCBtb3N0IG1heHNwbGl0IHNwbGl0cyBvY2N1cixcXFxcbiAgICBhbmQgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3RyaW5nIGlzIHJldHVybmVkIGFzIHRoZSBmaW5hbCBlbGVtZW50XFxcXG4gICAgb2YgdGhlIGxpc3QuXFxcIn0sZmluZGFsbDp7JG1ldGg6ZnVuY3Rpb24gZmluZGFsbChlLHQscil7cmV0dXJuIF9jb21waWxlKGUscikuZmluZCRhbGwodCl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwicGF0dGVyblxcXCIsXFxcInN0cmluZ1xcXCIsXFxcImZsYWdzXFxcIl0sRGVmYXVsdHM6W3plcm9dfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gLCBwYXR0ZXJuLCBzdHJpbmcsIGZsYWdzPTApXFxcIiwkZG9jOlxcXCJSZXR1cm4gYSBsaXN0IG9mIGFsbCBub24tb3ZlcmxhcHBpbmcgbWF0Y2hlcyBpbiB0aGUgc3RyaW5nLlxcXFxuXFxcXG4gICAgSWYgb25lIG9yIG1vcmUgY2FwdHVyaW5nIGdyb3VwcyBhcmUgcHJlc2VudCBpbiB0aGUgcGF0dGVybiwgcmV0dXJuXFxcXG4gICAgYSBsaXN0IG9mIGdyb3VwczsgdGhpcyB3aWxsIGJlIGEgbGlzdCBvZiB0dXBsZXMgaWYgdGhlIHBhdHRlcm5cXFxcbiAgICBoYXMgbW9yZSB0aGFuIG9uZSBncm91cC5cXFxcblxcXFxuICAgIEVtcHR5IG1hdGNoZXMgYXJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQuXFxcIn0sZmluZGl0ZXI6eyRtZXRoOmZ1bmN0aW9uIGZpbmRpdGVyKGUsdCxyKXtyZXR1cm4gX2NvbXBpbGUoZSxyKS5maW5kJGl0ZXIodCl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwicGF0dGVyblxcXCIsXFxcInN0cmluZ1xcXCIsXFxcImZsYWdzXFxcIl0sRGVmYXVsdHM6W3plcm9dfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gLCBwYXR0ZXJuLCBzdHJpbmcsIGZsYWdzPTApXFxcIiwkZG9jOlxcXCJSZXR1cm4gYW4gaXRlcmF0b3Igb3ZlciBhbGwgbm9uLW92ZXJsYXBwaW5nIG1hdGNoZXMgaW4gdGhlXFxcXG4gICAgc3RyaW5nLiAgRm9yIGVhY2ggbWF0Y2gsIHRoZSBpdGVyYXRvciByZXR1cm5zIGEgTWF0Y2ggb2JqZWN0LlxcXFxuXFxcXG4gICAgRW1wdHkgbWF0Y2hlcyBhcmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdC5cXFwifSxjb21waWxlOnskbWV0aDpmdW5jdGlvbiBjb21waWxlKGUsdCl7cmV0dXJuIF9jb21waWxlKGUsdCl9LCRmbGFnczp7TmFtZWRBcmdzOltcXFwicGF0dGVyblxcXCIsXFxcImZsYWdzXFxcIl0sRGVmYXVsdHM6W3plcm9dfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gLCBwYXR0ZXJuLCBmbGFncz0wKVxcXCIsJGRvYzpcXFwiQ29tcGlsZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLCByZXR1cm5pbmcgYSBQYXR0ZXJuIG9iamVjdC5cXFwifSxwdXJnZTp7JG1ldGg6ZnVuY3Rpb24gcHVyZ2UoKXtyZXR1cm4gT2JqZWN0LmtleXMoX2NvbXBpbGVkX3BhdHRlcm5zKS5mb3JFYWNoKChlPT57ZGVsZXRlIF9jb21waWxlZF9wYXR0ZXJuc1tlXX0pKSxweU5vbmV9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8gKVxcXCIsJGRvYzpcXFwiQ2xlYXIgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYWNoZXNcXFwifSx0ZW1wbGF0ZTp7JG1ldGg6ZnVuY3Rpb24gdGVtcGxhdGUoZSx0KXtyZXR1cm4gX2NvbXBpbGUoZSxudW1iZXJCaW5PcChyZS5ULHQsXFxcIkJpdE9yXFxcIikpfSwkZmxhZ3M6e05hbWVkQXJnczpbXFxcInBhdHRlcm5cXFwiLFxcXCJmbGFnc1xcXCJdLERlZmF1bHRzOlt6ZXJvXX0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCAvICwgcGF0dGVybiwgZmxhZ3M9MClcXFwiLCRkb2M6XFxcIkNvbXBpbGUgYSB0ZW1wbGF0ZSBwYXR0ZXJuLCByZXR1cm5pbmcgYSBQYXR0ZXJuIG9iamVjdFxcXCJ9LGVzY2FwZTp7JG1ldGg6ZnVuY3Rpb24oZSl7aWYoIWNoZWNrU3RyaW5nKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcImV4cGVjdGVkIGEgc3RyIGluc3RhbmNlcywgZ290IFxcXCIrdHlwZU5hbWUoZSkpO3JldHVybiBlPShlPWUudG9TdHJpbmcoKSkucmVwbGFjZShlc2NhcGVfY2hycyxcXFwiXFxcXFxcXFwkJlxcXCIpLG5ldyBweVN0cihlKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJwYXR0ZXJuXFxcIl0sRGVmYXVsdHM6W119LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgLyAsIHBhdHRlcm4pXFxcIiwkZG9jOlxcXCJcXFxcbiAgICBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nLlxcXFxuICAgIFxcXCJ9fSk7Y29uc3QgZXNjYXBlX2NocnM9L1tcXFxcJlxcXFx+XFxcXCMuKitcXFxcLT9eJHt9KCl8W1xcXFxdXFxcXFxcXFxcXFxcdFxcXFxyXFxcXHZcXFxcZlxcXFxuIF0vZztyZXR1cm4gcmV9XCIsXCJzcmMvbGliL3NpZ25hbC5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG4pe3ZhciBpPXt9O3JldHVybiBpLlNJR19ERkw9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxpLlNJR19JR049bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxpLkNUUkxfQ19FVkVOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGkuQ1RSTF9CUkVBS19FVkVOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGkuTlNJRz1uZXcgU2suYnVpbHRpbi5pbnRfKDIzKSxpLlNJR0hVUD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGkuU0lHTklOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGkuU0lHSUxMPW5ldyBTay5idWlsdGluLmludF8oNCksaS5TSUdGUEU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg4KSxpLlNJR0tJTEw9bmV3IFNrLmJ1aWx0aW4uaW50Xyg5KSxpLlNJR1NFR1Y9bmV3IFNrLmJ1aWx0aW4uaW50XygxMSksaS5TSUdURVJNPW5ldyBTay5idWlsdGluLmludF8oMTUpLGkuU0lHQlJFQUs9bmV3IFNrLmJ1aWx0aW4uaW50XygyMSksaS5TSUdBQlJUPW5ldyBTay5idWlsdGluLmludF8oMjIpLGkucGF1c2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJwYXVzZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApO3ZhciBuPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uO3JldHVybiBuLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LG4uZGF0YT17dHlwZTpcXFwiU2sucHJvbWlzZVxcXCIscHJvbWlzZTpuZXcgUHJvbWlzZSgoZnVuY3Rpb24obixpKXtpZihudWxsIT1Tay5zaWduYWxzJiZTay5zaWduYWxzLmFkZEV2ZW50TGlzdGVuZXIpe1NrLnNpZ25hbHMuYWRkRXZlbnRMaXN0ZW5lcigoZnVuY3Rpb24gaGFuZGxlU2lnbmFsKGkpe1NrLnNpZ25hbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVTaWduYWwpLG4oKX0pKX1lbHNlIGNvbnNvbGUud2FybihcXFwic2lnbmFsLnBhdXNlKCkgbm90IHN1cHBvcnRlZFxcXCIpLFNrLm1pc2NldmFsLnByaW50XyhcXFwic2lnbmFsLnBhdXNlKCkgbm90IHN1cHBvcnRlZFxcXCIpLG4oKX0pKX0sbn0pKSxpLnNpZ25hbD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXFxcInNpZ25hbC5zaWduYWwgaXMgbm90IHN1cHBvcnRlZC5cXFwiKX0pKSxpfTtcIixcInNyYy9saWIvc3RyaW5nLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oaSl7dmFyIHQ9e307cmV0dXJuIHQuYXNjaWlfbG93ZXJjYXNlPW5ldyBTay5idWlsdGluLnN0cihcXFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcXFwiKSx0LmFzY2lpX3VwcGVyY2FzZT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXFxcIiksdC5hc2NpaV9sZXR0ZXJzPW5ldyBTay5idWlsdGluLnN0cih0LmFzY2lpX2xvd2VyY2FzZS52K3QuYXNjaWlfdXBwZXJjYXNlLnYpLHQubG93ZXJjYXNlPW5ldyBTay5idWlsdGluLnN0cihcXFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcXFwiKSx0LnVwcGVyY2FzZT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXFxcIiksdC5sZXR0ZXJzPW5ldyBTay5idWlsdGluLnN0cih0Lmxvd2VyY2FzZS52K3QudXBwZXJjYXNlLnYpLHQuZGlnaXRzPW5ldyBTay5idWlsdGluLnN0cihcXFwiMDEyMzQ1Njc4OVxcXCIpLHQuaGV4ZGlnaXRzPW5ldyBTay5idWlsdGluLnN0cihcXFwiMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRlxcXCIpLHQub2N0ZGlnaXRzPW5ldyBTay5idWlsdGluLnN0cihcXFwiMDEyMzQ1NjdcXFwiKSx0LnB1bmN0dWF0aW9uPW5ldyBTay5idWlsdGluLnN0cihcXFwiIVxcXFxcXFwiIyQlJicoKSorLC0uLzo7PD0+P0BbXFxcXFxcXFxdXl9ge3x9flxcXCIpLHQud2hpdGVzcGFjZT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIlxcXFx0XFxcXG5cXFxcdlxcXFxmXFxcXHIgXFxcIiksdC5wcmludGFibGU9bmV3IFNrLmJ1aWx0aW4uc3RyKHQuZGlnaXRzLnYrdC5sZXR0ZXJzLnYrdC5wdW5jdHVhdGlvbi52K1xcXCIgXFxcXHRcXFxcblxcXFxyXFxcXHZcXFxcZlxcXCIpLHQuc3BsaXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oLi4uaSl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLnN0ci5wcm90b3R5cGUuc3BsaXQsaSl9KSksdC5jYXBpdGFsaXplPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGkpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoU2suYnVpbHRpbi5zdHIucHJvdG90eXBlLmNhcGl0YWxpemUsW2ldKX0pKSx0LmpvaW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oaSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIgXFxcIikpLFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLnN0ci5wcm90b3R5cGUuam9pbixbdCxpXSl9KSksdC5jYXB3b3Jkcz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihpLG4pe2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImNhcHdvcmRzXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMiksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoaSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJzIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZih2b2lkIDA9PT1uJiYobj1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIiBcXFwiKSksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcobikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJzZXAgbXVzdCBiZSBhIHN0cmluZ1xcXCIpO2Zvcih2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5zcGxpdCxbaSxuXSkudixyPVtdLGw9MDtsPGUubGVuZ3RoO2wrKyl7dmFyIHM9ZVtsXSx1PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LmNhcGl0YWxpemUsW3NdKTtyLnB1c2godSl9cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0LmpvaW4sW25ldyBTay5idWlsdGluLmxpc3Qociksbl0pfSkpLHR9O1wiLFwic3JjL2xpYi90aW1lLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24odCl7dmFyIGU9e307ZS5fX3BhY2thZ2VfXz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIlxcXCIpO3ZhciBuPVNrLmJ1aWx0aW4ubWFrZV9zdHJ1Y3RzZXEoXFxcInRpbWVcXFwiLFxcXCJzdHJ1Y3RfdGltZVxcXCIse3RtX3llYXI6XFxcInllYXIsIGZvciBleGFtcGxlLCAxOTkzXFxcIix0bV9tb246XFxcIm1vbnRoIG9mIHllYXIsIHJhbmdlIFsxLCAxMl1cXFwiLHRtX21kYXk6XFxcImRheSBvZiBtb250aCwgcmFuZ2UgWzEsIDMxXVxcXCIsdG1faG91cjpcXFwiaG91cnMsIHJhbmdlIFswLCAyM11cXFwiLHRtX21pbjpcXFwibWludXRlcywgcmFuZ2UgWzAsIDU5XVxcXCIsdG1fc2VjOlxcXCJzZWNvbmRzLCByYW5nZSBbMCwgNjFdXFxcIix0bV93ZGF5OlxcXCJkYXkgb2Ygd2VlaywgcmFuZ2UgWzAsIDZdLCBNb25kYXkgaXMgMFxcXCIsdG1feWRheTpcXFwiZGF5IG9mIHllYXIsIHJhbmdlIFsxLCAzNjZdXFxcIix0bV9pc2RzdDpcXFwiMSBpZiBzdW1tZXIgdGltZSBpcyBpbiBlZmZlY3QsIDAgaWYgbm90LCBhbmQgLTEgaWYgdW5rbm93blxcXCJ9LHt0bV96b25lOlxcXCJhYmJyZXZpYXRpb24gb2YgdGltZXpvbmUgbmFtZVxcXCIsdG1fZ210b2ZmOlxcXCJvZmZzZXQgZnJvbSBVVEMgaW4gc2Vjb25kc1xcXCJ9KTtmdW5jdGlvbiBwYWRMZWZ0KHQsZSxuKXt2YXIgaT10LnRvU3RyaW5nKCk7cmV0dXJuIEFycmF5KGUtaS5sZW5ndGgrMSkuam9pbihufHxcXFwiIFxcXCIpK2l9ZnVuY3Rpb24gZ2V0RGF5T2ZZZWFyKHQsZSl7dmFyIG49KGU9ZXx8ITEpP3QuZ2V0VVRDTW9udGgoKTp0LmdldE1vbnRoKCksaT1lP3QuZ2V0VVRDRGF0ZSgpOnQuZ2V0RGF0ZSgpLHU9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF1bbl0raTtyZXR1cm4gbj4xJiZmdW5jdGlvbiBpc0xlYXBZZWFyKHQpe3JldHVybiAwPT0oMyZ0KSYmKHQlMTAwIT0wfHx0JTQwMD09MCl9KGU/dC5nZXRVVENGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKSkmJnUrKyx1fWZ1bmN0aW9uIHN0ZFRpbWV6b25lT2Zmc2V0KCl7dmFyIHQ9bmV3IERhdGUoMjAwMiwwLDEpLGU9bmV3IERhdGUoMjAwMiw2LDEpO3JldHVybiBNYXRoLm1heCh0LmdldFRpbWV6b25lT2Zmc2V0KCksZS5nZXRUaW1lem9uZU9mZnNldCgpKX1mdW5jdGlvbiBkc3QodCl7cmV0dXJuIHQuZ2V0VGltZXpvbmVPZmZzZXQoKTxzdGRUaW1lem9uZU9mZnNldCgpfWZ1bmN0aW9uIHRpbWVab25lTmFtZSh0KXt2YXIgZSxuPS9cXFxcKCguKilcXFxcKS8uZXhlYyh0LnRvU3RyaW5nKCkpO2lmKG51bGwhPVNrLmdsb2JhbC5uYXZpZ2F0b3ImJihlPVNrLmdsb2JhbC5uYXZpZ2F0b3IudXNlckxhbmd1YWdlfHxTay5nbG9iYWwubmF2aWdhdG9yLmxhbmd1YWdlKSxuJiZuLmxlbmd0aD4xKXJldHVybiBuWzFdO2lmKHZvaWQgMD09PWUpcmV0dXJuIG51bGw7dHJ5e3JldHVybihuPXQudG9Mb2NhbGVTdHJpbmcoZSx7dGltZVpvbmVOYW1lOlxcXCJzaG9ydFxcXCJ9KS5zcGxpdChcXFwiIFxcXCIpKVtuLmxlbmd0aC0xXX1jYXRjaChpKXtyZXR1cm4gbnVsbH19ZnVuY3Rpb24gZnJvbV9zZWNvbmRzKHQsZSl7dmFyIGk9bmV3IERhdGU7aWYodCl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwic2Vjc1xcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcih0KSk7dmFyIHU9U2suYnVpbHRpbi5hc251bSQodCk7aS5zZXRUaW1lKDFlMyp1KX1yZXR1cm4gZnVuY3Rpb24gZGF0ZV90b19zdHJ1Y3RfdGltZSh0LGUpe2xldCBpO2lmKGU9ZXx8ITEpaT1bbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJVVENcXFwiKSxuZXcgU2suYnVpbHRpbi5pbnRfKDApXTtlbHNle3ZhciB1PS10LmdldFRpbWV6b25lT2Zmc2V0KCkvNjAscj0odTwwP1xcXCItXFxcIjpcXFwiK1xcXCIpKyhcXFwiXFxcIitNYXRoLmFicyh1KSkucGFkU3RhcnQoMixcXFwiMFxcXCIpO2k9W25ldyBTay5idWlsdGluLnN0cihyKSxuZXcgU2suYnVpbHRpbi5pbnRfKDM2MDAqdSldfXJldHVybiBuZXcgbihbU2suYnVpbHRpbi5hc3NrJChlP3QuZ2V0VVRDRnVsbFllYXIoKTp0LmdldEZ1bGxZZWFyKCkpLFNrLmJ1aWx0aW4uYXNzayQoKGU/dC5nZXRVVENNb250aCgpOnQuZ2V0TW9udGgoKSkrMSksU2suYnVpbHRpbi5hc3NrJChlP3QuZ2V0VVRDRGF0ZSgpOnQuZ2V0RGF0ZSgpKSxTay5idWlsdGluLmFzc2skKGU/dC5nZXRVVENIb3VycygpOnQuZ2V0SG91cnMoKSksU2suYnVpbHRpbi5hc3NrJChlP3QuZ2V0VVRDTWludXRlcygpOnQuZ2V0TWludXRlcygpKSxTay5idWlsdGluLmFzc2skKGU/dC5nZXRVVENTZWNvbmRzKCk6dC5nZXRTZWNvbmRzKCkpLFNrLmJ1aWx0aW4uYXNzayQoKChlP3QuZ2V0VVRDRGF5KCk6dC5nZXREYXkoKSkrNiklNyksU2suYnVpbHRpbi5hc3NrJChnZXREYXlPZlllYXIodCxlKSksU2suYnVpbHRpbi5hc3NrJChlPzA6ZHN0KHQpPzE6MCldLGkpfShpLGUpfWUuc3RydWN0X3RpbWU9bixlLnRpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwidGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApLG5ldyBTay5idWlsdGluLmZsb2F0XyhEYXRlLm5vdygpLzFlMyl9KSksZS5zbGVlcD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2xlZXBcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJkZWxheVxcXCIsXFxcImZsb2F0XFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKHQpKSxuZXcgU2subWlzY2V2YWwucHJvbWlzZVRvU3VzcGVuc2lvbihuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7U2suc2V0VGltZW91dCgoZnVuY3Rpb24oKXtlKFNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9KSwxZTMqU2suZmZpLnJlbWFwVG9Kcyh0KSl9KSkpfSkpLGUubG9jYWx0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJsb2NhbHRpbWVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwxKSxmcm9tX3NlY29uZHModCwhMSl9KSksZS5nbXRpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdtdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLGZyb21fc2Vjb25kcyh0LCEwKX0pKTt2YXIgaT1bXFxcIkphblxcXCIsXFxcIkZlYlxcXCIsXFxcIk1hclxcXCIsXFxcIkFwclxcXCIsXFxcIk1heVxcXCIsXFxcIkp1blxcXCIsXFxcIkp1bFxcXCIsXFxcIkF1Z1xcXCIsXFxcIlNlcFxcXCIsXFxcIk9jdFxcXCIsXFxcIk5vdlxcXCIsXFxcIkRlY1xcXCJdLHU9W1xcXCJNb25cXFwiLFxcXCJUdWVcXFwiLFxcXCJXZWRcXFwiLFxcXCJUaHVcXFwiLFxcXCJGcmlcXFwiLFxcXCJTYXRcXFwiLFxcXCJTdW5cXFwiXTtmdW5jdGlvbiBhc2N0aW1lX2YodCl7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiYXNjdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLCF0fHxTay5idWlsdGluLmNoZWNrTm9uZSh0KT90PWZyb21fc2Vjb25kcygpOnQgaW5zdGFuY2VvZiBufHwodD1uZXcgbih0KSksdCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUmJjk9PXQudi5sZW5ndGgpe3ZhciBlPVtdO3JldHVybiBlLnB1c2godVtTay5idWlsdGluLmFzbnVtJCh0LnZbNl0pXSksZS5wdXNoKGlbU2suYnVpbHRpbi5hc251bSQodC52WzFdKS0xXSksZS5wdXNoKHBhZExlZnQoU2suYnVpbHRpbi5hc251bSQodC52WzJdKS50b1N0cmluZygpLDIsXFxcIjBcXFwiKSksZS5wdXNoKHBhZExlZnQoU2suYnVpbHRpbi5hc251bSQodC52WzNdKS50b1N0cmluZygpLDIsXFxcIjBcXFwiKStcXFwiOlxcXCIrcGFkTGVmdChTay5idWlsdGluLmFzbnVtJCh0LnZbNF0pLnRvU3RyaW5nKCksMixcXFwiMFxcXCIpK1xcXCI6XFxcIitwYWRMZWZ0KFNrLmJ1aWx0aW4uYXNudW0kKHQudls1XSkudG9TdHJpbmcoKSwyLFxcXCIwXFxcIikpLGUucHVzaChwYWRMZWZ0KFNrLmJ1aWx0aW4uYXNudW0kKHQudlswXSkudG9TdHJpbmcoKSw0LFxcXCIwXFxcIikpLG5ldyBTay5idWlsdGluLnN0cihlLmpvaW4oXFxcIiBcXFwiKSl9fWZ1bmN0aW9uIG1rdGltZV9mKHQpe2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm1rdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLHQgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlJiY5PT10LnYubGVuZ3RoKXt2YXIgZT1uZXcgRGF0ZShTay5idWlsdGluLmFzbnVtJCh0LnZbMF0pLFNrLmJ1aWx0aW4uYXNudW0kKHQudlsxXSktMSxTay5idWlsdGluLmFzbnVtJCh0LnZbMl0pLFNrLmJ1aWx0aW4uYXNudW0kKHQudlszXSksU2suYnVpbHRpbi5hc251bSQodC52WzRdKSxTay5idWlsdGluLmFzbnVtJCh0LnZbNV0pKTtyZXR1cm4gU2suYnVpbHRpbi5hc3NrJChlLmdldFRpbWUoKS8xZTMsdm9pZCAwKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIm1rdGltZSgpIHJlcXVpcmVzIGEgc3RydWN0X3RpbWUgb3IgOS10dXBsZVxcXCIpfWUuYXNjdGltZT1uZXcgU2suYnVpbHRpbi5mdW5jKGFzY3RpbWVfZiksZS5jdGltZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiY3RpbWVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwxKSxhc2N0aW1lX2YoZnJvbV9zZWNvbmRzKHQpKX0pKSxlLm1rdGltZT1uZXcgU2suYnVpbHRpbi5mdW5jKG1rdGltZV9mKSxlLnRpbWV6b25lPW5ldyBTay5idWlsdGluLmludF8oNjAqc3RkVGltZXpvbmVPZmZzZXQoKSksZS5hbHR6b25lPW5ldyBTay5idWlsdGluLmludF8oNjAqZnVuY3Rpb24gYWx0VGltZXpvbmVPZmZzZXQoKXt2YXIgdD1uZXcgRGF0ZSgyMDAyLDAsMSksZT1uZXcgRGF0ZSgyMDAyLDYsMSk7cmV0dXJuIE1hdGgubWluKHQuZ2V0VGltZXpvbmVPZmZzZXQoKSxlLmdldFRpbWV6b25lT2Zmc2V0KCkpfSgpKSxlLmRheWxpZ2h0PW5ldyBTay5idWlsdGluLmludF8oZnVuY3Rpb24gZGF5bGlnaHRfY2hlY2soKXtjb25zdCB0PW5ldyBEYXRlKDIwMDIsMCwxKSxlPW5ldyBEYXRlKDIwMDIsNiwxKTtyZXR1cm4gdC5nZXRUaW1lem9uZU9mZnNldCgpIT1lLmdldFRpbWV6b25lT2Zmc2V0KCl9KCk/MTowKSxlLnR6bmFtZT1uZXcgU2suYnVpbHRpbi50dXBsZShmdW5jdGlvbiB0aW1lWm9uZU5hbWVzKCl7dmFyIHQ9bmV3IERhdGUoMjAwMiwwLDEpLGU9bmV3IERhdGUoMjAwMiw2LDEpO3JldHVybiBkc3QodCk/W25ldyBTay5idWlsdGluLnN0cih0aW1lWm9uZU5hbWUoZSkpLG5ldyBTay5idWlsdGluLnN0cih0aW1lWm9uZU5hbWUodCkpXTpbbmV3IFNrLmJ1aWx0aW4uc3RyKHRpbWVab25lTmFtZSh0KSksbmV3IFNrLmJ1aWx0aW4uc3RyKHRpbWVab25lTmFtZShlKSldfSgpKSxlLmFjY2VwdDJkeWVhcj1Tay5idWlsdGluLmFzc2skKDEpLGUuY2xvY2s9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXt2YXIgdD0wO3JldHVybiB0PVNrLmdsb2JhbC5wZXJmb3JtYW5jZSYmU2suZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdz9wZXJmb3JtYW5jZS5ub3coKS8xZTM6KG5ldyBEYXRlKS5nZXRUaW1lKCkvMWUzLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0KX0pKSxlLnN0cmZ0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uIHN0cmZ0aW1lX2YodCxlKXt2YXIgaTtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzdHJmdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDIpLCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHQpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiZm9ybWF0IG11c3QgYmUgYSBzdHJpbmdcXFwiKTtyZXR1cm4gZT9lIGluc3RhbmNlb2Ygbnx8KGU9bmV3IG4oZSkpOmU9ZnJvbV9zZWNvbmRzKCksZnVuY3Rpb24gY2hlY2tfc3RydWN0X3RpbWUodCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJSZXF1aXJlZCBhcmd1bWVudCAnc3RydWN0X3RpbWUnIG11c3QgYmUgb2YgdHlwZTogJ3N0cnVjdF90aW1lJ1xcXCIpO3ZhciBlLGk9dC52Lmxlbmd0aCx1PXQudjtmb3IoZT0wO2U8aTsrK2UpaWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQodVtlXSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJzdHJ1Y3RfdGltZSBtYXkgb25seSBjb250YWluIGludGVnZXJzXFxcIik7cmV0dXJuITB9KGUpLGk9U2suZmZpLnJlbWFwVG9Kcyh0KSxTay5mZmkucmVtYXBUb1B5KFNrLmdsb2JhbC5zdHJmdGltZShpLG5ldyBEYXRlKDFlMypta3RpbWVfZihlKS52KSkpfSkpLGUudHpzZXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gdHpzZXRfZigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRpbWUudHpzZXQoKSBpcyBub3QgeWV0IGltcGxlbWVudGVkXFxcIil9KSk7bGV0IHI9bnVsbDtyZXR1cm4gZS5zdHJwdGltZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBzdHJwdGltZV9mKC4uLnQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzdHJwdGltZVxcXCIsdC5sZW5ndGgsMSwyKSxudWxsPT09cj9Tay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRNb2R1bGUoXFxcIl9zdHJwdGltZVxcXCIsITEsITApLChlPT4ocj1lLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJfc3RycHRpbWVfdGltZVxcXCIpKSxyLnRwJGNhbGwodCkpKSk6ci50cCRjYWxsKHQpfSkpLGV9O1wiLFwic3JjL2xpYi90b2tlbi5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG4pe3ZhciBlPXt9O2UuX19maWxlX189bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIvc3JjL2xpYi90b2tlbi5weVxcXCIpO2NvbnN0IHQ9W107Zm9yKGxldCBpIGluIFNrLnRva2VuLnRva19uYW1lKXtjb25zdCBuPVNrLnRva2VuLnRva19uYW1lW2ldLnNsaWNlKDIpLGs9cGFyc2VJbnQoaSwxMCk7dC5wdXNoKFNrLmZmaS5yZW1hcFRvUHkoaykpLHQucHVzaChTay5mZmkucmVtYXBUb1B5KG4pKSxlW25dPVNrLmZmaS5yZW1hcFRvUHkoayl9cmV0dXJuIGUudG9rX25hbWU9bmV3IFNrLmJ1aWx0aW4uZGljdCh0KSxlLklTVEVSTUlOQUw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIklTVEVSTUlOQUxcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay50b2tlbi5JU1RFUk1JTkFMKFNrLmZmaS5yZW1hcFRvSnMobikpfSkpLGUuSVNOT05URVJNSU5BTD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiSVNOT05URVJNSU5BTFxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLnRva2VuLklTTk9OVEVSTUlOQUwoU2suZmZpLnJlbWFwVG9KcyhuKSl9KSksZS5JU0VPRj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiSVNFT0ZcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay50b2tlbi5JU0VPRihTay5mZmkucmVtYXBUb0pzKG4pKX0pKSxlfTtcIixcInNyYy9saWIvdG9rZW5pemUuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihlKXt2YXIgaT17fTtyZXR1cm4gaS50b2tlbml6ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJ0b2tlbml6ZVxcXCIsMSwxKSxTay5idWlsdGluLmNoZWNrRnVuY3Rpb24oZSk7Y29uc3QgaT1bXTtyZXR1cm4gU2suX3Rva2VuaXplKFxcXCI8c3RkaW4+XFxcIiwoZnVuY3Rpb24ganNSZWFkbGluZSgpe2NvbnN0IGk9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUpO3JldHVybiBTay5mZmkucmVtYXBUb0pzKGkpfSksXFxcIlVURi04XFxcIiwoZnVuY3Rpb24gcmVjZWl2ZVRva2VuKGUpe2kucHVzaChuZXcgU2suYnVpbHRpbi50dXBsZShbU2suZmZpLnJlbWFwVG9QeShlLnR5cGUpLFNrLmZmaS5yZW1hcFRvUHkoZS5zdHJpbmcpLG5ldyBTay5idWlsdGluLnR1cGxlKFtTay5mZmkucmVtYXBUb1B5KGUuc3RhcnRbMF0pLFNrLmZmaS5yZW1hcFRvUHkoZS5zdGFydFsxXSldKSxuZXcgU2suYnVpbHRpbi50dXBsZShbU2suZmZpLnJlbWFwVG9QeShlLmVuZFswXSksU2suZmZpLnJlbWFwVG9QeShlLmVuZFsxXSldKSxTay5mZmkucmVtYXBUb1B5KGUubGluZSldKSl9KSksbmV3IFNrLmJ1aWx0aW4ubGlzdChpKX0pKSxpfTtcIixcInNyYy9saWIvdHVydGxlLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oZSl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciB0PWZ1bmN0aW9uIGdldENvbmZpZ3VyZWRUYXJnZXQoKXt2YXIgZSx0O2Zvcih0PVxcXCJzdHJpbmdcXFwiPT10eXBlb2YoZT1Tay5UdXJ0bGVHcmFwaGljcyYmU2suVHVydGxlR3JhcGhpY3MudGFyZ2V0fHxcXFwidHVydGxlXFxcIik/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSk6ZTt0LmZpcnN0Q2hpbGQ7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKTtyZXR1cm4gdH0oKTtyZXR1cm4gdC50dXJ0bGVJbnN0YW5jZT90LnR1cnRsZUluc3RhbmNlLnJlc2V0KCk6dC50dXJ0bGVJbnN0YW5jZT1mdW5jdGlvbiBnZW5lcmF0ZVR1cnRsZU1vZHVsZShlKXt2YXIgdCxuLHIsaSxzLGEsbyxsLHU9e19fbmFtZV9fOm5ldyBTay5idWlsdGluLnN0cihcXFwidHVydGxlXFxcIil9LGM9ITAsaD0xZTMvMzAsZD17fSxmPXt9LF89e3RhcmdldDpcXFwidHVydGxlXFxcIix3aWR0aDo0MDAsaGVpZ2h0OjQwMCx3b3JsZFdpZHRoOjAsd29ybGRIZWlnaHQ6MCxhbmltYXRlOiEwLGJ1ZmZlclNpemU6MCxhbGxvd1VuZG86ITAsYXNzZXRzOnt9fTtmdW5jdGlvbiBnZXRBc3NldChlKXt2YXIgdD1pLmFzc2V0cyxuPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB0P3QoZSk6dFtlXTtyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIG4/bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQscil7dmFyIHM9bmV3IEltYWdlO3Mub25sb2FkPWZ1bmN0aW9uKCl7aS5hc3NldHNbZV09dGhpcyx0KHMpfSxzLm9uZXJyb3I9ZnVuY3Rpb24oKXtyKG5ldyBFcnJvcihcXFwiTWlzc2luZyBhc3NldDogXFxcIituKSl9LHMuc3JjPW59KSk6bmV3IEluc3RhbnRQcm9taXNlKHZvaWQgMCxuKX1mdW5jdGlvbiBJbnN0YW50UHJvbWlzZShlLHQpe3RoaXMubGFzdFJlc3VsdD10LHRoaXMubGFzdEVycm9yPWV9ZnVuY3Rpb24gRnJhbWVNYW5hZ2VyKCl7dGhpcy5yZXNldCgpfWZ1bmN0aW9uIGdldEZyYW1lTWFuYWdlcigpe3JldHVybiBvfHwobz1uZXcgRnJhbWVNYW5hZ2VyKSxvfWZ1bmN0aW9uIE1vdXNlSGFuZGxlcigpe3ZhciBlPXRoaXM7Zm9yKHZhciB0IGluIHRoaXMuX3RhcmdldD1nZXRUYXJnZXQoKSx0aGlzLl9tYW5hZ2Vycz17fSx0aGlzLl9oYW5kbGVycz17bW91c2Vkb3duOmZ1bmN0aW9uKHQpe2Uub25FdmVudChcXFwibW91c2Vkb3duXFxcIix0KX0sbW91c2V1cDpmdW5jdGlvbih0KXtlLm9uRXZlbnQoXFxcIm1vdXNldXBcXFwiLHQpfSxtb3VzZW1vdmU6ZnVuY3Rpb24odCl7ZS5vbkV2ZW50KFxcXCJtb3VzZW1vdmVcXFwiLHQpfX0sdGhpcy5faGFuZGxlcnMpdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodCx0aGlzLl9oYW5kbGVyc1t0XSl9ZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKGUsdCl7dGhpcy5fdHlwZT1lLHRoaXMuX3RhcmdldD10LHRoaXMuX2hhbmRsZXJzPXZvaWQgMCxmdW5jdGlvbiBnZXRNb3VzZUhhbmRsZXIoKXtyZXR1cm4gYXx8KGE9bmV3IE1vdXNlSGFuZGxlciksYX0oKS5hZGRNYW5hZ2VyKGUsdGhpcyl9ZnVuY3Rpb24gVHVydGxlKGUpe2lmKGdldEZyYW1lTWFuYWdlcigpLmFkZFR1cnRsZSh0aGlzKSx0aGlzLl9zY3JlZW49Z2V0U2NyZWVuKCksdGhpcy5fbWFuYWdlcnM9e30sdGhpcy5fc2hhcGU9ZS52LCFkLmhhc093blByb3BlcnR5KHRoaXMuX3NoYXBlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJTaGFwZTonXFxcIit0aGlzLl9zaGFwZStcXFwiJyBub3QgaW4gZGVmYXVsdCBzaGFwZSwgcGxlYXNlIGNoZWNrIHNoYXBlIGFnYWluIVxcXCIpO3RoaXMucmVzZXQoKX1mdW5jdGlvbiBTY3JlZW4oKXt2YXIgZSx0O3RoaXMuX2ZyYW1lcz0xLHRoaXMuX2RlbGF5PXZvaWQgMCx0aGlzLl9iZ2NvbG9yPVxcXCJub25lXFxcIix0aGlzLl9tb2RlPVxcXCJzdGFuZGFyZFxcXCIsdGhpcy5fbWFuYWdlcnM9e30sdGhpcy5fa2V5TG9nZ2VyPXt9LGU9KGkud29ybGRXaWR0aHx8aS53aWR0aHx8Z2V0V2lkdGgoKSkvMix0PShpLndvcmxkSGVpZ2h0fHxpLmhlaWdodHx8Z2V0SGVpZ2h0KCkpLzIsdGhpcy5zZXRVcFdvcmxkKC1lLC10LGUsdCl9ZnVuY3Rpb24gZW5zdXJlQW5vbnltb3VzKCl7cmV0dXJuIHN8fChzPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh1LlR1cnRsZSkpLHMuaW5zdGFuY2V9ZnVuY3Rpb24gZ2V0VGFyZ2V0KCl7cmV0dXJuIGV9ZnVuY3Rpb24gZ2V0U2NyZWVuKCl7cmV0dXJuIHJ8fChyPW5ldyBTY3JlZW4pLHJ9ZnVuY3Rpb24gZ2V0V2lkdGgoKXtyZXR1cm4gMHwociYmci5fd2lkdGh8fGkud2lkdGh8fGdldFRhcmdldCgpLmNsaWVudFdpZHRofHxfLndpZHRoKX1mdW5jdGlvbiBnZXRIZWlnaHQoKXtyZXR1cm4gMHwociYmci5faGVpZ2h0fHxpLmhlaWdodHx8Z2V0VGFyZ2V0KCkuY2xpZW50SGVpZ2h0fHxfLmhlaWdodCl9ZnVuY3Rpb24gY3JlYXRlTGF5ZXIoZSx0KXt2YXIgbixyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImNhbnZhc1xcXCIpLGk9Z2V0V2lkdGgoKSxzPWdldEhlaWdodCgpLGE9Z2V0VGFyZ2V0KCkuZmlyc3RDaGlsZD8tcytcXFwicHhcXFwiOlxcXCIwXFxcIjtyZXR1cm4gci53aWR0aD1pLHIuaGVpZ2h0PXMsci5zdHlsZS5wb3NpdGlvbj1cXFwicmVsYXRpdmVcXFwiLHIuc3R5bGUuZGlzcGxheT1cXFwiYmxvY2tcXFwiLHIuc3R5bGUuc2V0UHJvcGVydHkoXFxcIm1hcmdpbi10b3BcXFwiLGEpLHIuc3R5bGUuc2V0UHJvcGVydHkoXFxcInotaW5kZXhcXFwiLGUpLHQmJihyLnN0eWxlLmRpc3BsYXk9XFxcIm5vbmVcXFwiKSxnZXRUYXJnZXQoKS5hcHBlbmRDaGlsZChyKSwobj1yLmdldENvbnRleHQoXFxcIjJkXFxcIikpLmxpbmVDYXA9XFxcInJvdW5kXFxcIixuLmxpbmVKb2luPVxcXCJyb3VuZFxcXCIsYXBwbHlXb3JsZChnZXRTY3JlZW4oKSxuKSxufWZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKCl7dCYmKCh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSkodCksdD12b2lkIDApLG4mJih3aW5kb3cuY2xlYXJUaW1lb3V0KG4pLG49dm9pZCAwKX1mdW5jdGlvbiBhcHBseVdvcmxkKGUsdCl7dmFyIG49ZS5sbHgscj0oZS5sbHksZS51cngsZS51cnkpLGk9ZS54U2NhbGUscz1lLnlTY2FsZTt0JiYoY2xlYXJMYXllcih0KSx0LnJlc3RvcmUoKSx0LnNhdmUoKSx0LnNjYWxlKDEvaSwxL3MpLHQudHJhbnNsYXRlKC1uLC1yKSl9ZnVuY3Rpb24gcHVzaFVuZG8oZSl7dmFyIHQsbixyO2lmKGkuYWxsb3dVbmRvJiZlLl9idWZmZXJTaXplKXtmb3IoZS5fdW5kb0J1ZmZlcnx8KGUuX3VuZG9CdWZmZXI9W10pO2UuX3VuZG9CdWZmZXIubGVuZ3RoPmUuX2J1ZmZlclNpemU7KWUuX3VuZG9CdWZmZXIuc2hpZnQoKTtmb3Iobj17fSx0PVxcXCJ4IHkgYW5nbGUgcmFkaWFucyBjb2xvciBmaWxsIGRvd24gZmlsbGluZyBzaG93biBzaGFwZSBzaXplXFxcIi5zcGxpdChcXFwiIFxcXCIpLHI9MDtyPHQubGVuZ3RoO3IrKyluW3Rbcl1dPWVbXFxcIl9cXFwiK3Rbcl1dO3JldHVybiBlLl91bmRvQnVmZmVyLnB1c2gobiksZS5hZGRVcGRhdGUoKGZ1bmN0aW9uKCl7bi5maWxsQnVmZmVyPXRoaXMuZmlsbEJ1ZmZlcj90aGlzLmZpbGxCdWZmZXIuc2xpY2UoKTp2b2lkIDAsZS5fcGFwZXImJmUuX3BhcGVyLmNhbnZhcyYmKG4uaW1hZ2U9ZS5fcGFwZXIuY2FudmFzLnRvRGF0YVVSTCgpKX0pLCExKX19ZS5oYXNBdHRyaWJ1dGUoXFxcInRhYmluZGV4XFxcIil8fGUuc2V0QXR0cmlidXRlKFxcXCJ0YWJpbmRleFxcXCIsMCksZi5GTE9BVD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGUpfSxmLkNPTE9SPWZ1bmN0aW9uKGUpe2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGUpO2Zvcih2YXIgdD0wO3Q8Mzt0KyspZVt0XT1Tay5idWlsdGluLmFzc2skKGVbdF0pO3JldHVybiA0PT09ZS5sZW5ndGgmJihlWzNdPW5ldyBTay5idWlsdGluLmZsb2F0XyhlWzNdKSksbmV3IFNrLmJ1aWx0aW4udHVwbGUoZSl9LGYuVFVSVExFX0xJU1Q9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLG49MDtuPGUubGVuZ3RoO24rKyl0LnB1c2goZVtuXS5za0luc3RhbmNlKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUodCl9LGQuYXJyb3c9W1stMTAsMF0sWzEwLDBdLFswLDEwXV0sZC5zcXVhcmU9W1sxMCwtMTBdLFsxMCwxMF0sWy0xMCwxMF0sWy0xMCwtMTBdXSxkLnRyaWFuZ2xlPVtbMTAsLTUuNzddLFswLDExLjU1XSxbLTEwLC01Ljc3XV0sZC5jbGFzc2ljPVtbMCwwXSxbLTUsLTldLFswLC03XSxbNSwtOV1dLGQudHVydGxlPVtbMCwxNl0sWy0yLDE0XSxbLTEsMTBdLFstNCw3XSxbLTcsOV0sWy05LDhdLFstNiw1XSxbLTcsMV0sWy01LC0zXSxbLTgsLTZdLFstNiwtOF0sWy00LC01XSxbMCwtN10sWzQsLTVdLFs2LC04XSxbOCwtNl0sWzUsLTNdLFs3LDFdLFs2LDVdLFs5LDhdLFs3LDldLFs0LDddLFsxLDEwXSxbMiwxNF1dLGQuY2lyY2xlPVtbMTAsMF0sWzkuNTEsMy4wOV0sWzguMDksNS44OF0sWzUuODgsOC4wOV0sWzMuMDksOS41MV0sWzAsMTBdLFstMy4wOSw5LjUxXSxbLTUuODgsOC4wOV0sWy04LjA5LDUuODhdLFstOS41MSwzLjA5XSxbLTEwLDBdLFstOS41MSwtMy4wOV0sWy04LjA5LC01Ljg4XSxbLTUuODgsLTguMDldLFstMy4wOSwtOS41MV0sWy0wLC0xMF0sWzMuMDksLTkuNTFdLFs1Ljg4LC04LjA5XSxbOC4wOSwtNS44OF0sWzkuNTEsLTMuMDldXSxpPWZ1bmN0aW9uKCl7dmFyIGU7Zm9yKGUgaW4gU2suVHVydGxlR3JhcGhpY3N8fChTay5UdXJ0bGVHcmFwaGljcz17fSksXylTay5UdXJ0bGVHcmFwaGljcy5oYXNPd25Qcm9wZXJ0eShlKXx8KFNrLlR1cnRsZUdyYXBoaWNzW2VdPV9bZV0pO3JldHVybiBTay5UdXJ0bGVHcmFwaGljc30oKSxJbnN0YW50UHJvbWlzZS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihlKXtpZih0aGlzLmxhc3RFcnJvcilyZXR1cm4gdGhpczt0cnl7dGhpcy5sYXN0UmVzdWx0PWUodGhpcy5sYXN0UmVzdWx0KX1jYXRjaCh0KXt0aGlzLmxhc3RSZXN1bHQ9dm9pZCAwLHRoaXMubGFzdEVycm9yPXR9cmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2U/dGhpcy5sYXN0UmVzdWx0OnRoaXN9LEluc3RhbnRQcm9taXNlLnByb3RvdHlwZS5jYXRjaD1mdW5jdGlvbihlKXtpZih0aGlzLmxhc3RFcnJvcil0cnl7dGhpcy5sYXN0UmVzdWx0PWUodGhpcy5sYXN0RXJyb3IpLHRoaXMubGFzdEVycm9yPXZvaWQgMH1jYXRjaCh0KXt0aGlzLmxhc3RSZXN1bHQ9dm9pZCAwLHRoaXMubGFzdEVycm9yPXR9cmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2U/dGhpcy5sYXN0UmVzdWx0OnRoaXN9LGZ1bmN0aW9uKGUpe3ZhciByLHM7ZnVuY3Rpb24gYW5pbWF0aW9uRnJhbWUoZSl7cmV0dXJuIGkuYW5pbWF0ZT8hZSYmcj9yOmZ1bmN0aW9uKHQpe3JldHVybiBuPXdpbmRvdy5zZXRUaW1lb3V0KHQsZXx8aCl9OmZ1bmN0aW9uKGUpe2UoKX19KHM9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkmJihyPWZ1bmN0aW9uKGUpe3JldHVybiB0PXMoZSl9KSxlLndpbGxSZW5kZXJOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuISghdGhpcy5fYnVmZmVyfHx0aGlzLl9mcmFtZUNvdW50KzEhPT10aGlzLmZyYW1lQnVmZmVyKCkpfSxlLnR1cnRsZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdHVydGxlc30sZS5hZGRUdXJ0bGU9ZnVuY3Rpb24oZSl7dGhpcy5fdHVydGxlcy5wdXNoKGUpfSxlLnJlc2V0PWZ1bmN0aW9uKCl7aWYodGhpcy5fdHVydGxlcylmb3IodmFyIGU9dGhpcy5fdHVydGxlcy5sZW5ndGg7LS1lPj0wOyl0aGlzLl90dXJ0bGVzW2VdLnJlc2V0KCk7dGhpcy5fdHVydGxlcz1bXSx0aGlzLl9mcmFtZXM9W10sdGhpcy5fZnJhbWVDb3VudD0wLHRoaXMuX2J1ZmZlcj0xLHRoaXMuX3JhdGU9MCx0aGlzLl9hbmltYXRpb25GcmFtZT1hbmltYXRpb25GcmFtZSgpfSxlLmFkZEZyYW1lPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQmJih0aGlzLl9mcmFtZUNvdW50Kz0xKSx0aGlzLmZyYW1lcygpLnB1c2goZSksIWkuYW5pbWF0ZXx8dGhpcy5fYnVmZmVyJiZ0aGlzLl9mcmFtZUNvdW50PT09dGhpcy5mcmFtZUJ1ZmZlcigpP3RoaXMudXBkYXRlKCk6bmV3IEluc3RhbnRQcm9taXNlfSxlLmZyYW1lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9mcmFtZXN9LGUuZnJhbWVCdWZmZXI9ZnVuY3Rpb24oZSl7cmV0dXJuXFxcIm51bWJlclxcXCI9PXR5cGVvZiBlJiYodGhpcy5fYnVmZmVyPTB8ZSxlJiZlPD10aGlzLl9mcmFtZUNvdW50KT90aGlzLnVwZGF0ZSgpOnRoaXMuX2J1ZmZlcn0sZS5yZWZyZXNoSW50ZXJ2YWw9ZnVuY3Rpb24oZSl7cmV0dXJuXFxcIm51bWJlclxcXCI9PXR5cGVvZiBlJiYodGhpcy5fcmF0ZT0wfGUsdGhpcy5fYW5pbWF0aW9uRnJhbWU9YW5pbWF0aW9uRnJhbWUoZSkpLHRoaXMuX3JhdGV9LGUudXBkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZyYW1lcyYmdGhpcy5fZnJhbWVzLmxlbmd0aD90aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpOm5ldyBJbnN0YW50UHJvbWlzZX0sZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9ZnVuY3Rpb24oKXt2YXIgZSx0LG49dGhpcy5fZnJhbWVzLHI9dGhpcy5fYW5pbWF0aW9uRnJhbWUsaT10aGlzLl90dXJ0bGVzLHM9Z2V0U2NyZWVuKCkuc3ByaXRlTGF5ZXIoKTtyZXR1cm4gdGhpcy5fZnJhbWVzPVtdLHRoaXMuX2ZyYW1lQ291bnQ9MCxuZXcgUHJvbWlzZSgoZnVuY3Rpb24oYSl7cigoZnVuY3Rpb24gcGFpbnQoKXtmb3IodD0wO3Q8bi5sZW5ndGg7dCsrKW5bdF0mJm5bdF0oKTtmb3IoY2xlYXJMYXllcihzKSx0PTA7dDxpLmxlbmd0aDt0KyspKGU9aVt0XSkuZ2V0U3RhdGUoKS5zaG93biYmZHJhd1R1cnRsZShlLmdldFN0YXRlKCkscyk7YSgpfSkpfSkpfX0oRnJhbWVNYW5hZ2VyLnByb3RvdHlwZSksKGw9TW91c2VIYW5kbGVyLnByb3RvdHlwZSkub25FdmVudD1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxzLGEsbz10aGlzLl9tYW5hZ2Vyc1tlXSxsPXRoaXMuX21hbmFnZXJzLm1vdXNlbW92ZSx1PSExO2Z1bmN0aW9uIGNvbXB1dGVDb29yZGluYXRlcygpe2lmKCF1KXt2YXIgZT1nZXRTY3JlZW4oKSxhPWUuc3ByaXRlTGF5ZXIoKS5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bj10LmNsaWVudFgtYS5sZWZ0fDAscj10LmNsaWVudFktYS50b3B8MCxpPW4qZS54U2NhbGUrZS5sbHgscz1yKmUueVNjYWxlK2UudXJ5LHU9ITB9fWlmKChcXFwibW91c2Vkb3duXFxcIj09PWV8fFxcXCJtb3VzZXVwXFxcIj09PWUpJiZsJiZsLmxlbmd0aClmb3IoY29tcHV0ZUNvb3JkaW5hdGVzKCksYT1sLmxlbmd0aDstLWE+PTA7KWxbYV0udGVzdChuLHIsaSxzKSYmbFthXS5jYW5Nb3ZlKFxcXCJtb3VzZWRvd25cXFwiPT09ZSk7aWYobyYmby5sZW5ndGgpZm9yKGNvbXB1dGVDb29yZGluYXRlcygpLGE9by5sZW5ndGg7LS1hPj0wOykoXFxcIm1vdXNlbW92ZVxcXCI9PT1lJiZvW2FdLmNhbk1vdmUoKSYmb1thXS50ZXN0KG4scixpLHMpfHxcXFwibW91c2Vkb3duXFxcIj09PWUmJm9bYV0udGVzdChuLHIsaSxzKSkmJm9bYV0udHJpZ2dlcihbaSxzXSl9LGwucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9tYW5hZ2Vycz17fX0sbC5hZGRNYW5hZ2VyPWZ1bmN0aW9uKGUsdCl7dGhpcy5fbWFuYWdlcnNbZV18fCh0aGlzLl9tYW5hZ2Vyc1tlXT1bXSksdGhpcy5fbWFuYWdlcnNbZV0ucHVzaCh0KX0sZnVuY3Rpb24oZSl7ZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuX2hhbmRsZXJzPXZvaWQgMH0sZS5jYW5Nb3ZlPWZ1bmN0aW9uKGUpe3JldHVybiEoIXRoaXMuX3RhcmdldHx8IXRoaXMuX3RhcmdldC5oaXRUZXN0KSYmKHZvaWQgMCE9PWUmJih0aGlzLl90YXJnZXQuaGl0VGVzdC5oaXQ9ZSksdGhpcy5fdGFyZ2V0LmhpdFRlc3QuaGl0KX0sZS50ZXN0PWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLl90YXJnZXQmJnRoaXMuX3RhcmdldC5oaXRUZXN0P3RoaXMuX3RhcmdldC5oaXRUZXN0KGUsdCxuLHIpOiEhdGhpcy5fdGFyZ2V0fSxlLnRyaWdnZXI9ZnVuY3Rpb24oZSl7dmFyIHQsbj10aGlzLl9oYW5kbGVycztpZihuJiZuLmxlbmd0aClmb3IodD0wO3Q8bi5sZW5ndGg7dCsrKW5bdF0uYXBwbHkoe30sZSl9LGUuYWRkSGFuZGxlcj1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuX2hhbmRsZXJzO2lmKCF0JiZuJiZuLmxlbmd0aClmb3IoO24uc2hpZnQoKTspO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlPyhufHwobj10aGlzLl9oYW5kbGVycz1bXSksbi5wdXNoKGUpKTpuJiYhbi5sZW5ndGgmJnRoaXMucmVzZXQoKX19KEV2ZW50TWFuYWdlci5wcm90b3R5cGUpLFR1cnRsZS5SQURJQU5TPTIqTWF0aC5QSSxmdW5jdGlvbihlKXtmdW5jdGlvbiBjaXJjbGVSb3RhdGUoZSx0LG4pe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmFkZFVwZGF0ZSh2b2lkIDAsITEse2FuZ2xlOnQscmFkaWFuczpufSl9fWZ1bmN0aW9uIGNpcmNsZVNlZ21lbnQoZSx0LG4scixpLHMpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLnRyYW5zbGF0ZSh0LG4scixpLHMsITApfX1lLmhpdFRlc3Q9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9Z2V0U2NyZWVuKCkuaGl0VGVzdExheWVyKCk7Y2xlYXJMYXllcihpKSxkcmF3VHVydGxlKHRoaXMuZ2V0U3RhdGUoKSxpKTt2YXIgcz1pLmdldEltYWdlRGF0YShlLHQsMSwxKS5kYXRhO3JldHVybiBzWzNdfHxzWzBdfHxzWzFdfHxzWzJdfSxlLmFkZFVwZGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5nZXRTdGF0ZSgpLGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLG4/MjozKTtyZXR1cm4gZ2V0RnJhbWVNYW5hZ2VyKCkuYWRkRnJhbWUoKGZ1bmN0aW9uKCl7aWYoZSYmZS5hcHBseShyLGkpLG4pZm9yKHZhciB0IGluIG4pclt0XT1uW3RdfSksdCl9LGUuZ2V0U3RhdGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLl9zdGF0ZXx8KHRoaXMuX3N0YXRlPXt4OnRoaXMuX3gseTp0aGlzLl95LGFuZ2xlOnRoaXMuX2FuZ2xlLHJhZGlhbnM6dGhpcy5fcmFkaWFucyxzaGFwZTp0aGlzLl9zaGFwZSxjb2xvcjp0aGlzLl9jb2xvcixmaWxsOnRoaXMuX2ZpbGwsZmlsbGluZzp0aGlzLl9maWxsaW5nLHNpemU6dGhpcy5fc2l6ZSxzcGVlZDp0aGlzLl9jb21wdXRlZF9zcGVlZCxkb3duOnRoaXMuX2Rvd24sc2hvd246dGhpcy5fc2hvd24sY29sb3JNb2RlOnRoaXMuX2NvbG9yTW9kZSxjb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2V0UGFwZXIoKX19KSx0aGlzLl9zdGF0ZX0sZS50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0LG4scixpLHMpe3ZhciBhPXRoaXM7cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZShlLHQsbixyLGkscyxhKXt2YXIgbyxsPWUuX2NvbXB1dGVkX3NwZWVkLHU9Z2V0U2NyZWVuKCksYz1NYXRoLmFicyh1LnhTY2FsZSksaD1NYXRoLmFicyh1LnlTY2FsZSksZD10LGY9bixfPU1hdGguc3FydChyKnIqYytpKmkqaCksZz1sP01hdGgucm91bmQoTWF0aC5tYXgoMSxfL2wpKToxLHA9ci9nLG09aS9nLHY9Z2V0RnJhbWVNYW5hZ2VyKCkud2lsbFJlbmRlck5leHQoKT9Qcm9taXNlLnJlc29sdmUoKTpuZXcgSW5zdGFudFByb21pc2UseT0hKCFsJiZhKTtmb3IoZS5hZGRVcGRhdGUoKGZ1bmN0aW9uKCl7dGhpcy5maWxsaW5nJiZ0aGlzLmZpbGxCdWZmZXIucHVzaCh7eDp0aGlzLngseTp0aGlzLnksc3Ryb2tlOnRoaXMuZG93bixjb2xvcjp0aGlzLmNvbG9yLHNpemU6dGhpcy5zaXplfSl9KSwhMSksbz0wO288ZztvKyspZD10K3AqKG8rMSksZj1uK20qKG8rMSksdj12LnRoZW4ocGFydGlhbFRyYW5zbGF0ZShlLGQsZixzLHkpKSxzPSExO3JldHVybiB2LnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuW3QrcixuK2ldfSkpfSh0aGlzLGUsdCxuLHIsaSxzKS50aGVuKChmdW5jdGlvbihlKXthLl94PWVbMF0sYS5feT1lWzFdfSkpfSxlLnJvdGF0ZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcztyZXR1cm4gZnVuY3Rpb24gcm90YXRlKGUsdCxuLHIpe3ZhciBpLHM9ZS5fY29tcHV0ZWRfc3BlZWQsYT1uL2UuX2Z1bGxDaXJjbGUqMzYwLG89cz9NYXRoLnJvdW5kKE1hdGgubWF4KDEsTWF0aC5hYnMoYSkvcykpOjEsbD1uL28sdT17fSxjPSEoIXMmJnIpLGg9Z2V0RnJhbWVNYW5hZ2VyKCkud2lsbFJlbmRlck5leHQoKT9Qcm9taXNlLnJlc29sdmUoKTpuZXcgSW5zdGFudFByb21pc2U7Zm9yKGk9MDtpPG87aSsrKWNhbGN1bGF0ZUhlYWRpbmcoZSx0K2wqKGkrMSksdSksaD1oLnRoZW4ocGFydGlhbFJvdGF0ZShlLHUuYW5nbGUsdS5yYWRpYW5zLGMpKTtyZXR1cm4gaC50aGVuKChmdW5jdGlvbigpe3JldHVybiBjYWxjdWxhdGVIZWFkaW5nKGUsdCtuKX0pKX0odGhpcyxlLHQsbikudGhlbigoZnVuY3Rpb24oZSl7ci5fYW5nbGU9ZS5hbmdsZSxyLl9yYWRpYW5zPWUucmFkaWFuc30pKX0sZS5xdWV1ZU1vdmVCeT1mdW5jdGlvbihlLHQsbixyKXt2YXIgaT1NYXRoLmNvcyhuKSpyLHM9TWF0aC5zaW4obikqcjtyZXR1cm4gdGhpcy50cmFuc2xhdGUoZSx0LGkscywhMCl9LGUucXVldWVUdXJuVG89ZnVuY3Rpb24oZSx0KXtyZXR1cm4odCU9dGhpcy5fZnVsbENpcmNsZSk8MCYmKHQrPXRoaXMuX2Z1bGxDaXJjbGUpLHRoaXMucm90YXRlKGUsdC1lKX0sZS5nZXRNYW5hZ2VyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9tYW5hZ2Vyc1tlXXx8KHRoaXMuX21hbmFnZXJzW2VdPW5ldyBFdmVudE1hbmFnZXIoZSx0aGlzKSksdGhpcy5fbWFuYWdlcnNbZV19LGUuZ2V0UGFwZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGFwZXJ8fCh0aGlzLl9wYXBlcj1jcmVhdGVMYXllcigyKSl9LGUucmVzZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gdGhpcy5feD0wLHRoaXMuX3k9MCx0aGlzLl9yYWRpYW5zPTAsdGhpcy5fYW5nbGU9MCx0aGlzLl9zaG93bj0hMCx0aGlzLl9kb3duPSEwLHRoaXMuX2NvbG9yPVxcXCJibGFja1xcXCIsdGhpcy5fZmlsbD1cXFwiYmxhY2tcXFwiLHRoaXMuX3NpemU9MSx0aGlzLl9maWxsaW5nPSExLHRoaXMuX3VuZG9CdWZmZXI9W10sdGhpcy5fc3BlZWQ9Myx0aGlzLl9jb21wdXRlZF9zcGVlZD02LHRoaXMuX2NvbG9yTW9kZT0xLHRoaXMuX3N0YXRlPXZvaWQgMCx0aGlzLl9tYW5hZ2Vycyl0aGlzLl9tYW5hZ2Vyc1tlXS5yZXNldCgpO3RoaXMuX2lzUmFkaWFucz0hMSx0aGlzLl9mdWxsQ2lyY2xlPTM2MCx0aGlzLl9idWZmZXJTaXplPVxcXCJudW1iZXJcXFwiPT10eXBlb2YgaS5idWZmZXJTaXplP2kuYnVmZmVyU2l6ZTowLHJlbW92ZUxheWVyKHRoaXMuX3BhcGVyKSx0aGlzLl9wYXBlcj12b2lkIDB9LGUuJGRlZ3JlZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9XFxcIm51bWJlclxcXCI9PXR5cGVvZiBlP01hdGguYWJzKGUpOjM2MCx0aGlzLl9pc1JhZGlhbnM9ITEsZSYmdGhpcy5fZnVsbENpcmNsZT90aGlzLl9hbmdsZT10aGlzLl9hbmdsZS90aGlzLl9mdWxsQ2lyY2xlKmU6dGhpcy5fYW5nbGU9dGhpcy5fcmFkaWFucz0wLHRoaXMuX2Z1bGxDaXJjbGU9ZSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsITEse2FuZ2xlOnRoaXMuX2FuZ2xlLHJhZGlhbnM6dGhpcy5fcmFkaWFuc30pfSxlLiRkZWdyZWVzLm1pbkFyZ3M9MCxlLiRkZWdyZWVzLmNvX3Zhcm5hbWVzPVtcXFwiZnVsbGNpcmNsZVxcXCJdLGUuJGRlZ3JlZXMucmV0dXJuVHlwZT1mLkZMT0FULGUuJHJhZGlhbnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNSYWRpYW5zfHwodGhpcy5faXNSYWRpYW5zPSEwLHRoaXMuX2FuZ2xlPXRoaXMuX3JhZGlhbnMsdGhpcy5fZnVsbENpcmNsZT1UdXJ0bGUuUkFESUFOUyksdGhpcy5fYW5nbGV9LGUuJHJhZGlhbnMucmV0dXJuVHlwZT1mLkZMT0FULGUuJHBvc2l0aW9uPWUuJHBvcz1mdW5jdGlvbigpe3JldHVyblt0aGlzLiR4Y29yKCksdGhpcy4keWNvcigpXX0sZS4kcG9zaXRpb24ucmV0dXJuVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmZsb2F0XyhlWzBdKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oZVsxXSldKX0sZS4kdG93YXJkcz1mdW5jdGlvbihlLHQpe3ZhciBuPWdldENvb3JkaW5hdGVzKGUsdCk7cmV0dXJuKE1hdGguUEkrTWF0aC5hdGFuMih0aGlzLl95LW4ueSx0aGlzLl94LW4ueCkpKih0aGlzLl9mdWxsQ2lyY2xlL1R1cnRsZS5SQURJQU5TKX0sZS4kdG93YXJkcy5jb192YXJuYW1lcz1bXFxcInhcXFwiLFxcXCJ5XFxcIl0sZS4kdG93YXJkcy5taW5BcmdzPTEsZS4kdG93YXJkcy5yZXR1cm5UeXBlPWYuRkxPQVQsZS4kZGlzdGFuY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRDb29yZGluYXRlcyhlLHQpLHI9bi54LXRoaXMuX3gsaT1uLnktdGhpcy5feTtyZXR1cm4gTWF0aC5zcXJ0KHIqcitpKmkpfSxlLiRkaXN0YW5jZS5jb192YXJuYW1lcz1bXFxcInhcXFwiLFxcXCJ5XFxcIl0sZS4kZGlzdGFuY2UubWluQXJncz0xLGUuJGRpc3RhbmNlLnJldHVyblR5cGU9Zi5GTE9BVCxlLiRoZWFkaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMuX2FuZ2xlKTwxZS0xMz8wOnRoaXMuX2FuZ2xlfSxlLiRoZWFkaW5nLnJldHVyblR5cGU9Zi5GTE9BVCxlLiR4Y29yPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMuX3gpPDFlLTEzPzA6dGhpcy5feH0sZS4keGNvci5yZXR1cm5UeXBlPWYuRkxPQVQsZS4keWNvcj1mdW5jdGlvbigpe3JldHVybiBNYXRoLmFicyh0aGlzLl95KTwxZS0xMz8wOnRoaXMuX3l9LGUuJHljb3IucmV0dXJuVHlwZT1mLkZMT0FULGUuJGZvcndhcmQ9ZS4kZmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMucXVldWVNb3ZlQnkodGhpcy5feCx0aGlzLl95LHRoaXMuX3JhZGlhbnMsZSl9LGUuJGZvcndhcmQuY29fdmFybmFtZXM9ZS4kZmQuY29fdmFybmFtZXM9W1xcXCJkaXN0YW5jZVxcXCJdLGUuJHVuZG89ZnVuY3Rpb24oKXshZnVuY3Rpb24gcG9wVW5kbyhlKXt2YXIgdDtpZihlLl9idWZmZXJTaXplJiZlLl91bmRvQnVmZmVyJiYodD1lLl91bmRvQnVmZmVyLnBvcCgpKSl7Zm9yKHZhciBuIGluIHQpXFxcImltYWdlXFxcIiE9PW4mJlxcXCJmaWxsQnVmZmVyXFxcIiE9PW4mJihlW1xcXCJfXFxcIituXT10W25dKTtlLmFkZFVwZGF0ZSgoZnVuY3Rpb24oKXt0LmltYWdlJiYoZy5zcmM9dC5pbWFnZSksY2xlYXJMYXllcih0aGlzLmNvbnRleHQoKSwhMSxnKSxkZWxldGUgdC5pbWFnZX0pLCEwLHQpfX0odGhpcyl9LGUuJHVuZG9idWZmZXJlbnRyaWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VuZG9CdWZmZXIubGVuZ3RofSxlLiRzZXR1bmRvYnVmZmVyPWZ1bmN0aW9uKGUpe3RoaXMuX2J1ZmZlclNpemU9XFxcIm51bWJlclxcXCI9PXR5cGVvZiBlP01hdGgubWluKE1hdGguYWJzKGUpLDFlMyk6MH0sZS4kc2V0dW5kb2J1ZmZlci5jb192YXJuYW1lcz1bXFxcInNpemVcXFwiXSxlLiRiYWNrd2FyZD1lLiRiYWNrPWUuJGJrPWZ1bmN0aW9uKGUpe3JldHVybiBwdXNoVW5kbyh0aGlzKSx0aGlzLnF1ZXVlTW92ZUJ5KHRoaXMuX3gsdGhpcy5feSx0aGlzLl9yYWRpYW5zLC1lKX0sZS4kYmFja3dhcmQuY29fdmFybmFtZXM9ZS4kYmFjay5jb192YXJuYW1lcz1lLiRiay5jb192YXJuYW1lcz1bXFxcImRpc3RhbmNlXFxcIl0sZS4kZ290b18kcnckPWUuJHNldHBvcz1lLiRzZXRwb3NpdGlvbj1mdW5jdGlvbihlLHQpe3ZhciBuPWdldENvb3JkaW5hdGVzKGUsdCk7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMudHJhbnNsYXRlKHRoaXMuX3gsdGhpcy5feSxuLngtdGhpcy5feCxuLnktdGhpcy5feSwhMCl9LGUuJGdvdG9fJHJ3JC5jb192YXJuYW1lcz1lLiRzZXRwb3MuY29fdmFybmFtZXM9ZS4kc2V0cG9zaXRpb24uY29fdmFybmFtZXM9W1xcXCJ4XFxcIixcXFwieVxcXCJdLGUuJGdvdG9fJHJ3JC5taW5BcmdzPWUuJHNldHBvcy5taW5BcmdzPWUuJHNldHBvc2l0aW9uLm1pbkFyZ3M9MSxlLiRzZXR4PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRyYW5zbGF0ZSh0aGlzLl94LHRoaXMuX3ksZS10aGlzLl94LDAsITApfSxlLiRzZXR4LmNvX3Zhcm5hbWVzPVtcXFwieFxcXCJdLGUuJHNldHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudHJhbnNsYXRlKHRoaXMuX3gsdGhpcy5feSwwLGUtdGhpcy5feSwhMCl9LGUuJHNldHkuY29fdmFybmFtZXM9W1xcXCJ5XFxcIl0sZS4kaG9tZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLl9hbmdsZTtyZXR1cm4gcHVzaFVuZG8odGhpcyksZS50cmFuc2xhdGUodGhpcy5feCx0aGlzLl95LC10aGlzLl94LC10aGlzLl95LCEwKS50aGVuKChmdW5jdGlvbihuKXtyZXR1cm4gZS5xdWV1ZVR1cm5Ubyh0LDApfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe30pKX0sZS4kcmlnaHQ9ZS4kcnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMucm90YXRlKHRoaXMuX2FuZ2xlLC1lKX0sZS4kcmlnaHQuY29fdmFybmFtZXM9ZS4kcnQuY29fdmFybmFtZXM9W1xcXCJhbmdsZVxcXCJdLGUuJGxlZnQ9ZS4kbHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMucm90YXRlKHRoaXMuX2FuZ2xlLGUpfSxlLiRsZWZ0LmNvX3Zhcm5hbWVzPWUuJGx0LmNvX3Zhcm5hbWVzPVtcXFwiYW5nbGVcXFwiXSxlLiRzZXRoZWFkaW5nPWUuJHNldGg9ZnVuY3Rpb24oZSl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMucXVldWVUdXJuVG8odGhpcy5fYW5nbGUsZSl9LGUuJHNldGhlYWRpbmcuY29fdmFybmFtZXM9ZS4kc2V0aC5jb192YXJuYW1lcz1bXFxcImFuZ2xlXFxcIl0sZS4kY2lyY2xlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLHMsYSxvLGwsdSxjLGgsZD10aGlzLGY9dGhpcy5feCxfPXRoaXMuX3ksZz10aGlzLl9hbmdsZSxwPXt9LG09MS9nZXRTY3JlZW4oKS5saW5lU2NhbGUsdj0hMDtmb3IocHVzaFVuZG8odGhpcyksdm9pZCAwPT09dCYmKHQ9ZC5fZnVsbENpcmNsZSksdm9pZCAwPT09biYmKGk9TWF0aC5hYnModCkvZC5fZnVsbENpcmNsZSxuPTErKE1hdGgubWluKDExK01hdGguYWJzKGUqbSkvNiw1OSkqaXwwKSksYT0uNSoocz10L24pLG89MiplKk1hdGguc2luKHMqTWF0aC5QSS9kLl9mdWxsQ2lyY2xlKSxlPDA/KG89LW8scz0tcyxhPS1hLHI9Zy10KTpyPWcrdCxoPWdldEZyYW1lTWFuYWdlcigpLndpbGxSZW5kZXJOZXh0KCk/UHJvbWlzZS5yZXNvbHZlKCk6bmV3IEluc3RhbnRQcm9taXNlLGcrPWEsbD0wO2w8bjtsKyspY2FsY3VsYXRlSGVhZGluZyhkLGcrcypsLHApLHU9TWF0aC5jb3MocC5yYWRpYW5zKSpvLGM9TWF0aC5zaW4ocC5yYWRpYW5zKSpvLGg9aC50aGVuKGNpcmNsZVJvdGF0ZShkLHAuYW5nbGUscC5yYWRpYW5zKSkudGhlbihjaXJjbGVTZWdtZW50KGQsZixfLHUsYyx2KSksZis9dSxfKz1jLHY9ITE7cmV0dXJuIGgudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gY2FsY3VsYXRlSGVhZGluZyhkLHIscCksZC5fYW5nbGU9cC5hbmdsZSxkLl9yYWRpYW5zPXAucmFkaWFucyxkLmFkZFVwZGF0ZSh2b2lkIDAsITAscCl9KSl9LGUuJGNpcmNsZS5jb192YXJuYW1lcz1bXFxcInJhZGl1c1xcXCIsXFxcImV4dGVudFxcXCIsXFxcInN0ZXBzXFxcIl0sZS4kY2lyY2xlLm1pbkFyZ3M9MSxlLiRwZW51cD1lLiR1cD1lLiRwdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kb3duPSExLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCwhMSx7ZG93bjohMX0pfSxlLiRwZW5kb3duPWUuJGRvd249ZS4kcGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZG93bj0hMCx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsITEse2Rvd246ITB9KX0sZS4kaXNkb3duPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rvd259LGUuJHNwZWVkPWZ1bmN0aW9uKGUpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSlyZXR1cm4gdGhpcy5fc3BlZWQ7Y29uc3QgdD17ZmFzdGVzdDowLGZhc3Q6MTAsbm9ybWFsOjYsc2xvdzozLHNsb3dlc3Q6MX07aWYoZSBpbiB0JiYoZT10W2VdKSxcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGUpe2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZSl7Y29uc3QgZT1PYmplY3Qua2V5cyh0KS5qb2luKFxcXCIsIFxcXCIpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwic3BlZWQgc3RyaW5nIGV4cGVjdGVkIG9uZSBvZiBcXFwiK2UpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwic3BlZWQgZXhwZWN0ZWQgYSBzdHJpbmcgb3IgbnVtYmVyXFxcIil9cmV0dXJuIGU9ZT4uNSYmZTwxMC41P1NrLmJ1aWx0aW4uYXNudW0kKFNrLmJ1aWx0aW4ucm91bmQoU2suYnVpbHRpbi5hc3NrJChlKSkpOjAsdGhpcy5fc3BlZWQ9ZSx0aGlzLl9jb21wdXRlZF9zcGVlZD0yKmUsdGhpcy5hZGRVcGRhdGUodm9pZCAwLCExLHtzcGVlZDp0aGlzLl9jb21wdXRlZF9zcGVlZH0pfSxlLiRzcGVlZC5taW5BcmdzPTAsZS4kc3BlZWQuY29fdmFybmFtZXM9W1xcXCJzcGVlZFxcXCJdLGUuJHBlbmNvbG9yPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB2b2lkIDAhPT1lPyh0aGlzLl9jb2xvcj1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsZSx0LG4sciksdGhpcy5hZGRVcGRhdGUodm9pZCAwLHRoaXMuX3Nob3duLHtjb2xvcjp0aGlzLl9jb2xvcn0pKTpoZXhUb1JHQih0aGlzLl9jb2xvcil9LGUuJHBlbmNvbG9yLmNvX3Zhcm5hbWVzPVtcXFwiclxcXCIsXFxcImdcXFwiLFxcXCJiXFxcIixcXFwiYVxcXCJdLGUuJHBlbmNvbG9yLm1pbkFyZ3M9MCxlLiRwZW5jb2xvci5yZXR1cm5UeXBlPWYuQ09MT1IsZS4kZmlsbGNvbG9yPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB2b2lkIDAhPT1lPyh0aGlzLl9maWxsPWNyZWF0ZUNvbG9yKHRoaXMuX2NvbG9yTW9kZSxlLHQsbixyKSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsdGhpcy5fc2hvd24se2ZpbGw6dGhpcy5fZmlsbH0pKTpoZXhUb1JHQih0aGlzLl9maWxsKX0sZS4kZmlsbGNvbG9yLmNvX3Zhcm5hbWVzPVtcXFwiclxcXCIsXFxcImdcXFwiLFxcXCJiXFxcIixcXFwiYVxcXCJdLGUuJGZpbGxjb2xvci5taW5BcmdzPTAsZS4kZmlsbGNvbG9yLnJldHVyblR5cGU9Zi5DT0xPUixlLiRjb2xvcj1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdm9pZCAwIT09ZT8odm9pZCAwPT09dHx8dm9pZCAwIT09bj8odGhpcy5fY29sb3I9Y3JlYXRlQ29sb3IodGhpcy5fY29sb3JNb2RlLGUsdCxuLHIpLHRoaXMuX2ZpbGw9dGhpcy5fY29sb3IpOih0aGlzLl9jb2xvcj1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsZSksdGhpcy5fZmlsbD1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsdCkpLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCx0aGlzLl9zaG93bix7Y29sb3I6dGhpcy5fY29sb3IsZmlsbDp0aGlzLl9maWxsfSkpOlt0aGlzLiRwZW5jb2xvcigpLHRoaXMuJGZpbGxjb2xvcigpXX0sZS4kY29sb3IubWluQXJncz0wLGUuJGNvbG9yLmNvX3Zhcm5hbWVzPVtcXFwiY29sb3JcXFwiLFxcXCJmaWxsXFxcIixcXFwiYlxcXCIsXFxcImFcXFwiXSxlLiRjb2xvci5yZXR1cm5UeXBlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbZi5DT0xPUihlWzBdKSxmLkNPTE9SKGVbMV0pXSl9LGUuJGZpbGw9ZnVuY3Rpb24oZSl7aWYodm9pZCAwIT09ZSl7aWYoKGU9ISFlKT09PXRoaXMuX2ZpbGxpbmcpcmV0dXJuO3JldHVybiB0aGlzLl9maWxsaW5nPWUsZT8ocHVzaFVuZG8odGhpcyksdGhpcy5hZGRVcGRhdGUodm9pZCAwLCExLHtmaWxsaW5nOiEwLGZpbGxCdWZmZXI6W3t4OnRoaXMuX3gseTp0aGlzLl95fV19KSk6KHB1c2hVbmRvKHRoaXMpLHRoaXMuYWRkVXBkYXRlKChmdW5jdGlvbigpe3RoaXMuZmlsbEJ1ZmZlci5wdXNoKHRoaXMpLGRyYXdGaWxsLmNhbGwodGhpcyl9KSwhMCx7ZmlsbGluZzohMSxmaWxsQnVmZmVyOnZvaWQgMH0pKX1yZXR1cm4gdGhpcy5fZmlsbGluZ30sZS4kZmlsbC5jb192YXJuYW1lcz1bXFxcImZsYWdcXFwiXSxlLiRmaWxsLm1pbkFyZ3M9MCxlLiRiZWdpbl9maWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGZpbGwoITApfSxlLiRlbmRfZmlsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRmaWxsKCExKX0sZS4kc3RhbXA9ZnVuY3Rpb24oKXtyZXR1cm4gcHVzaFVuZG8odGhpcyksdGhpcy5hZGRVcGRhdGUoKGZ1bmN0aW9uKCl7ZHJhd1R1cnRsZSh0aGlzLHRoaXMuY29udGV4dCgpKX0pLCEwKX0sZS4kZG90PWZ1bmN0aW9uKGUsdCxuLHIsaSl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLGU9XFxcIm51bWJlclxcXCI9PXR5cGVvZihlPVNrLmJ1aWx0aW4uYXNudW0kKGUpKT9NYXRoLm1heCgxLDB8TWF0aC5hYnMoZSkpOk1hdGgubWF4KHRoaXMuX3NpemUrNCwyKnRoaXMuX3NpemUpLHQ9dm9pZCAwIT09dD9jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsdCxuLHIsaSk6dGhpcy5fY29sb3IsdGhpcy5hZGRVcGRhdGUoZHJhd0RvdCwhMCx2b2lkIDAsZSx0KX0sZS4kZG90LmNvX3Zhcm5hbWVzPVtcXFwic2l6ZVxcXCIsXFxcImNvbG9yXFxcIixcXFwiZ1xcXCIsXFxcImJcXFwiLFxcXCJhXFxcIl0sZS4kd3JpdGU9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGkscyxhLG8sbCx1PXRoaXM7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLGU9U3RyaW5nKGUpLHImJnIuY29uc3RydWN0b3I9PT1BcnJheSYmKHM9XFxcInN0cmluZ1xcXCI9PXR5cGVvZiByWzBdP3JbMF06XFxcIkFyaWFsXFxcIixhPVN0cmluZyhyWzFdfHxcXFwiMTJwdFxcXCIpLG89XFxcInN0cmluZ1xcXCI9PXR5cGVvZiByWzJdP3JbMl06XFxcIm5vcm1hbFxcXCIsL15cXFxcZCskLy50ZXN0KGEpJiYoYSs9XFxcInB0XFxcIikscj1bbyxhLHNdLmpvaW4oXFxcIiBcXFwiKSksbnx8KG49XFxcImxlZnRcXFwiKSxpPXRoaXMuYWRkVXBkYXRlKGRyYXdUZXh0LCEwLHZvaWQgMCxlLG4sciksIXR8fFxcXCJsZWZ0XFxcIiE9PW4mJlxcXCJjZW50ZXJcXFwiIT09bnx8KGw9ZnVuY3Rpb24gbWVhc3VyZVRleHQoZSx0KXtyZXR1cm4gdCYmKHAuZm9udD10KSxwLm1lYXN1cmVUZXh0KGUpLndpZHRofShlLHIpLFxcXCJjZW50ZXJcXFwiPT09biYmKGwvPTIpLGk9aS50aGVuKChmdW5jdGlvbigpe3ZhciBlPXUuZ2V0U3RhdGUoKTtyZXR1cm4gdS50cmFuc2xhdGUoZS54LGUueSxsLDAsITApfSkpKSxpfSxlLiR3cml0ZS5jb192YXJuYW1lcz1bXFxcIm1lc3NhZ2VcXFwiLFxcXCJtb3ZlXFxcIixcXFwiYWxpZ25cXFwiLFxcXCJmb250XFxcIl0sZS4kd3JpdGUubWluQXJncz0xLGUuJHBlbnNpemU9ZS4kd2lkdGg9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PWU/KHRoaXMuX3NpemU9ZSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsdGhpcy5fc2hvd24se3NpemU6ZX0pKTp0aGlzLl9zaXplfSxlLiRwZW5zaXplLm1pbkFyZ3M9ZS4kd2lkdGgubWluQXJncz0wLGUuJHBlbnNpemUuY29fdmFybmFtZXM9ZS4kd2lkdGguY29fdmFybmFtZXM9W1xcXCJ3aWR0aFxcXCJdLGUuJHNob3d0dXJ0bGU9ZS4kc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2hvd249ITAsdGhpcy5hZGRVcGRhdGUodm9pZCAwLCEwLHtzaG93bjohMH0pfSxlLiRoaWRldHVydGxlPWUuJGh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Nob3duPSExLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCwhMCx7c2hvd246ITF9KX0sZS4kaXN2aXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Nob3dufSxlLiRzaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZFtlXT8odGhpcy5fc2hhcGU9ZSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsdGhpcy5fc2hvd24se3NoYXBlOmV9KSk6dGhpcy5fc2hhcGV9LGUuJHNoYXBlLm1pbkFyZ3M9MCxlLiRzaGFwZS5jb192YXJuYW1lcz1bXFxcIm5hbWVcXFwiXSxlLiR3aW5kb3dfd2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NyZWVuLiR3aW5kb3dfd2lkdGgoKX0sZS4kd2luZG93X2hlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JlZW4uJHdpbmRvd19oZWlnaHQoKX0sZS4kdHJhY2VyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3NjcmVlbi4kdHJhY2VyKGUsdCl9LGUuJHRyYWNlci5taW5BcmdzPTAsZS4kdHJhY2VyLmNvX3Zhcm5hbWVzPVtcXFwiblxcXCIsXFxcImRlbGF5XFxcIl0sZS4kdXBkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjcmVlbi4kdXBkYXRlKCl9LGUuJGRlbGF5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zY3JlZW4uJGRlbGF5KGUpfSxlLiRkZWxheS5taW5BcmdzPTAsZS4kZGVsYXkuY29fdmFybmFtZXM9W1xcXCJkZWxheVxcXCJdLGUuJHJlc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzZXQoKSx0aGlzLiRjbGVhcigpfSxlLiRtYWlubG9vcD1lLiRkb25lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjcmVlbi4kbWFpbmxvb3AoKX0sZS4kY2xlYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGRVcGRhdGUoKGZ1bmN0aW9uKCl7Y2xlYXJMYXllcih0aGlzLmNvbnRleHQoKSl9KSwhMCl9LGUuJGRvdC5taW5BcmdzPTAsZS4kb25jbGljaz1mdW5jdGlvbihlLHQsbil7dGhpcy5nZXRNYW5hZ2VyKFxcXCJtb3VzZWRvd25cXFwiKS5hZGRIYW5kbGVyKGUsbil9LGUuJG9uY2xpY2subWluQXJncz0xLGUuJG9uY2xpY2suY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXSxlLiRvbnJlbGVhc2U9ZnVuY3Rpb24oZSx0LG4pe3RoaXMuZ2V0TWFuYWdlcihcXFwibW91c2V1cFxcXCIpLmFkZEhhbmRsZXIoZSxuKX0sZS4kb25yZWxlYXNlLm1pbkFyZ3M9MSxlLiRvbnJlbGVhc2UuY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXSxlLiRvbmRyYWc9ZnVuY3Rpb24oZSx0LG4pe3RoaXMuZ2V0TWFuYWdlcihcXFwibW91c2Vtb3ZlXFxcIikuYWRkSGFuZGxlcihlLG4pfSxlLiRvbmRyYWcubWluQXJncz0xLGUuJG9uZHJhZy5jb192YXJuYW1lcz1bXFxcIm1ldGhvZFxcXCIsXFxcImJ0blxcXCIsXFxcImFkZFxcXCJdLGUuJGdldHNjcmVlbj1mdW5jdGlvbigpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodS5TY3JlZW4pfSxlLiRnZXRzY3JlZW4uaXNTaz0hMCxlLiRjbG9uZT1mdW5jdGlvbigpe3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh1LlR1cnRsZSk7cmV0dXJuIGUuaW5zdGFuY2UuX3g9dGhpcy5feCxlLmluc3RhbmNlLl95PXRoaXMuX3ksZS5pbnN0YW5jZS5fYW5nbGU9dGhpcy5fYW5nbGUsZS5pbnN0YW5jZS5fcmFkaWFucz10aGlzLl9yYWRpYW5zLGUuaW5zdGFuY2UuX3NoYXBlPXRoaXMuX3NoYXBlLGUuaW5zdGFuY2UuX2NvbG9yPXRoaXMuX2NvbG9yLGUuaW5zdGFuY2UuX2ZpbGw9dGhpcy5fZmlsbCxlLmluc3RhbmNlLl9maWxsaW5nPXRoaXMuX2ZpbGxpbmcsZS5pbnN0YW5jZS5fc2l6ZT10aGlzLl9zaXplLGUuaW5zdGFuY2UuX2NvbXB1dGVkX3NwZWVkPXRoaXMuX2NvbXB1dGVkX3NwZWVkLGUuaW5zdGFuY2UuX2Rvd249dGhpcy5fZG93bixlLmluc3RhbmNlLl9zaG93bj10aGlzLl9zaG93bixlLmluc3RhbmNlLl9jb2xvck1vZGU9dGhpcy5fY29sb3JNb2RlLGUuaW5zdGFuY2UuX2lzUmFkaWFucz10aGlzLl9pc1JhZGlhbnMsZS5pbnN0YW5jZS5fZnVsbENpcmNsZT10aGlzLl9mdWxsQ2lyY2xlLGUuaW5zdGFuY2UuX2J1ZmZlclNpemU9dGhpcy5fYnVmZmVyU2l6ZSxlLmluc3RhbmNlLl91bmRvQnVmZmVyPXRoaXMuX3VuZG9CdWZmZXIsZS5fY2xvbmVkRnJvbT10aGlzLGV9LGUuJGNsb25lLnJldHVyblR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LGUuJGdldHR1cnRsZT1lLiRnZXRwZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5za0luc3RhbmNlfSxlLiRnZXR0dXJ0bGUuaXNTaz0hMH0oVHVydGxlLnByb3RvdHlwZSksZnVuY3Rpb24oZSl7ZS5zcHJpdGVMYXllcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zcHJpdGVzfHwodGhpcy5fc3ByaXRlcz1jcmVhdGVMYXllcigzKSl9LGUuYmdMYXllcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9iYWNrZ3JvdW5kfHwodGhpcy5fYmFja2dyb3VuZD1jcmVhdGVMYXllcigxKSl9LGUuaGl0VGVzdExheWVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hpdFRlc3R8fCh0aGlzLl9oaXRUZXN0PWNyZWF0ZUxheWVyKDAsITApKX0sZS5nZXRNYW5hZ2VyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9tYW5hZ2Vyc1tlXXx8KHRoaXMuX21hbmFnZXJzW2VdPW5ldyBFdmVudE1hbmFnZXIoZSx0aGlzKSksdGhpcy5fbWFuYWdlcnNbZV19LGUucmVzZXQ9ZnVuY3Rpb24oKXt2YXIgZTtmb3IoZSBpbiB0aGlzLl9rZXlMaXN0ZW5lcnM9dm9pZCAwLHRoaXMuX2tleUxvZ2dlcil3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9rZXlMb2dnZXJbZV0pLHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fa2V5TG9nZ2VyW2VdKSxkZWxldGUgdGhpcy5fa2V5TG9nZ2VyW2VdO2ZvcihlIGluIHRoaXMuX2tleURvd25MaXN0ZW5lciYmKGdldFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImtleWRvd25cXFwiLHRoaXMuX2tleURvd25MaXN0ZW5lciksdGhpcy5fa2V5RG93bkxpc3RlbmVyPXZvaWQgMCksdGhpcy5fa2V5VXBMaXN0ZW5lciYmKGdldFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImtleXVwXFxcIix0aGlzLl9rZXlVcExpc3RlbmVyKSx0aGlzLl9rZXlVcExpc3RlbmVyPXZvaWQgMCksdGhpcy5fdGltZXImJih3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSx0aGlzLl90aW1lcj12b2lkIDApLHRoaXMuX21hbmFnZXJzKXRoaXMuX21hbmFnZXJzW2VdLnJlc2V0KCk7dGhpcy5fbW9kZT1cXFwic3RhbmRhcmRcXFwiLHJlbW92ZUxheWVyKHRoaXMuX3Nwcml0ZXMpLHRoaXMuX3Nwcml0ZXM9dm9pZCAwLHJlbW92ZUxheWVyKHRoaXMuX2JhY2tncm91bmQpLHRoaXMuX2JhY2tncm91bmQ9dm9pZCAwfSxlLnNldFVwV29ybGQ9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9dGhpcztpLmxseD1lLGkubGx5PXQsaS51cng9bixpLnVyeT1yLGkueFNjYWxlPShuLWUpL2dldFdpZHRoKCksaS55U2NhbGU9LTEqKHItdCkvZ2V0SGVpZ2h0KCksaS5saW5lU2NhbGU9TWF0aC5taW4oTWF0aC5hYnMoaS54U2NhbGUpLE1hdGguYWJzKGkueVNjYWxlKSl9LGUuJHNldHVwPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBpc05hTihwYXJzZUZsb2F0KGUpKSYmKGU9Z2V0V2lkdGgoKSksaXNOYU4ocGFyc2VGbG9hdCh0KSkmJih0PWdldEhlaWdodCgpKSxlPD0xJiYoZT1nZXRXaWR0aCgpKmUpLHQ8PTEmJih0PWdldEhlaWdodCgpKnQpLHRoaXMuX3dpZHRoPWUsdGhpcy5faGVpZ2h0PXQsdGhpcy5feE9mZnNldD12b2lkIDA9PT1ufHxpc05hTihwYXJzZUludChuKSk/MDpwYXJzZUludChuKSx0aGlzLl95T2Zmc2V0PXZvaWQgMD09PXJ8fGlzTmFOKHBhcnNlSW50KHIpKT8wOnBhcnNlSW50KHIpLFxcXCJ3b3JsZFxcXCI9PT10aGlzLl9tb2RlP3RoaXMuX3NldHdvcmxkY29vcmRpbmF0ZXModGhpcy5sbHgsdGhpcy5sbHksdGhpcy51cngsdGhpcy51cnkpOnRoaXMuX3NldHdvcmxkY29vcmRpbmF0ZXMoLWUvMiwtdC8yLGUvMix0LzIpfSxlLiRzZXR1cC5taW5BcmdzPTAsZS4kc2V0dXAuY29fdmFybmFtZXM9W1xcXCJ3aWR0aFxcXCIsXFxcImhlaWdodFxcXCIsXFxcInN0YXJ0eFxcXCIsXFxcInN0YXJ0eVxcXCJdLGUuJHJlZ2lzdGVyX3NoYXBlPWUuJGFkZHNoYXBlPWZ1bmN0aW9uKGUsdCl7aWYoIXQpcmV0dXJuIGdldEFzc2V0KGUpLnRoZW4oKGZ1bmN0aW9uKHQpe2RbZV09dH0pKTtkW2VdPXR9LGUuJHJlZ2lzdGVyX3NoYXBlLm1pbkFyZ3M9MSxlLiRyZWdpc3Rlcl9zaGFwZS5jb192YXJuYW1lcz1bXFxcIm5hbWVcXFwiLFxcXCJzaGFwZVxcXCJdLGUuJGdldHNoYXBlcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyhkKX0sZS4kdHJhY2VyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMCE9PWV8fHZvaWQgMCE9PXQ/KFxcXCJudW1iZXJcXFwiPT10eXBlb2YgdCYmKHRoaXMuX2RlbGF5PXQsZ2V0RnJhbWVNYW5hZ2VyKCkucmVmcmVzaEludGVydmFsKHQpKSxcXFwibnVtYmVyXFxcIj09dHlwZW9mIGU/KHRoaXMuX2ZyYW1lcz1lLGdldEZyYW1lTWFuYWdlcigpLmZyYW1lQnVmZmVyKGUpKTp2b2lkIDApOnRoaXMuX2ZyYW1lc30sZS4kdHJhY2VyLmNvX3Zhcm5hbWVzPVtcXFwiZnJhbWVzXFxcIixcXFwiZGVsYXlcXFwiXSxlLiR0cmFjZXIubWluQXJncz0wLGUuJGRlbGF5PWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lP3RoaXMuJHRyYWNlcih2b2lkIDAsZSk6dm9pZCAwPT09dGhpcy5fZGVsYXk/aDp0aGlzLl9kZWxheX0sZS4kZGVsYXkuY29fdmFybmFtZXM9W1xcXCJkZWxheVxcXCJdLGUuX3NldHdvcmxkY29vcmRpbmF0ZXM9ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGdldEZyYW1lTWFuYWdlcigpLnR1cnRsZXMoKSx0aGlzLnNldFVwV29ybGQoZSx0LG4sciksdGhpcy5fc3ByaXRlcyYmYXBwbHlXb3JsZCh0aGlzLHRoaXMuX3Nwcml0ZXMpLHRoaXMuX2JhY2tncm91bmQmJmFwcGx5V29ybGQodGhpcyx0aGlzLl9iYWNrZ3JvdW5kKSx0aGlzLiRjbGVhcigpfSxlLiRzZXR3b3JsZGNvb3JkaW5hdGVzPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLl9tb2RlPVxcXCJ3b3JsZFxcXCIsdGhpcy5fc2V0d29ybGRjb29yZGluYXRlcyhlLHQsbixyKX0sZS4kc2V0d29ybGRjb29yZGluYXRlcy5jb192YXJuYW1lcz1bXFxcImxseFxcXCIsXFxcImxseVxcXCIsXFxcInVyeFxcXCIsXFxcInVyeVxcXCJdLGUubWluQXJncz00LGUuJGNsZWFyPWUuJGNsZWFyc2NyZWVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzZXQoKSx0aGlzLiRyZXNldCgpfSxlLiR1cGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0RnJhbWVNYW5hZ2VyKCkudXBkYXRlKCl9LGUuJHJlc2V0PWUuJHJlc2V0c2NyZWVuPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWdldEZyYW1lTWFuYWdlcigpLnR1cnRsZXMoKTtyZXR1cm4gZ2V0RnJhbWVNYW5hZ2VyKCkuYWRkRnJhbWUoKGZ1bmN0aW9uKCl7YXBwbHlXb3JsZChlLGUuX3Nwcml0ZXMpLGFwcGx5V29ybGQoZSxlLl9iYWNrZ3JvdW5kKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl0W25dLnJlc2V0KCksYXBwbHlXb3JsZChlLHRbbl0uX3BhcGVyKX0pLCEwKX0sZS4kd2luZG93X3dpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIGdldFdpZHRoKCl9LGUuJHdpbmRvd19oZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0SGVpZ2h0KCl9LGUuJGRlbGF5Lm1pbkFyZ3M9MCxlLiR0dXJ0bGVzPWZ1bmN0aW9uKCl7cmV0dXJuIGdldEZyYW1lTWFuYWdlcigpLnR1cnRsZXMoKX0sZS4kdHVydGxlcy5yZXR1cm5UeXBlPWYuVFVSVExFX0xJU1QsZS4kYmdwaWM9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIGU/KHQ9dGhpcyxnZXRBc3NldChlKS50aGVuKChmdW5jdGlvbihlKXtjbGVhckxheWVyKHQuYmdMYXllcigpLHZvaWQgMCxlKX0pKSk6dGhpcy5fYmdwaWN9LGUuJGJncGljLm1pbkFyZ3M9MCxlLiRiZ3BpYy5jb192YXJuYW1lcz1bXFxcIm5hbWVcXFwiXSxlLiRiZ2NvbG9yPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB2b2lkIDAhPT1lPyh0aGlzLl9iZ2NvbG9yPWNyZWF0ZUNvbG9yKHRoaXMuX2NvbG9yTW9kZSxlLHQsbixyKSx2b2lkIGNsZWFyTGF5ZXIodGhpcy5iZ0xheWVyKCksdGhpcy5fYmdjb2xvcikpOmhleFRvUkdCKHRoaXMuX2JnY29sb3IpfSxlLiRiZ2NvbG9yLm1pbkFyZ3M9MCxlLiRiZ2NvbG9yLmNvX3Zhcm5hbWVzPVtcXFwiY29sb3JcXFwiLFxcXCJnXFxcIixcXFwiYlxcXCIsXFxcImFcXFwiXSxlLiRiZ2NvbG9yLnJldHVyblR5cGU9Zi5DT0xPUixlLiRjb2xvcm1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PWU/KHRoaXMuX2NvbG9yTW9kZT0yNTU9PT1lPzI1NToxLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCx0aGlzLl9zaG93bix7Y29sb3JNb2RlOnRoaXMuX2NvbG9yTW9kZX0pKTp0aGlzLl9jb2xvck1vZGV9LGUuJGNvbG9ybW9kZS5taW5BcmdzPTAsZS4kY29sb3Jtb2RlLmNvX3Zhcm5hbWVzPVtcXFwiY21vZGVcXFwiXSxlLiRjb2xvcm1vZGUucmV0dXJuVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gMjU1PT09ZT9uZXcgU2suYnVpbHRpbi5pbnRfKDI1NSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDEpfSxlLiRtYWlubG9vcD1lLiRkb25lPWZ1bmN0aW9uKCl7fSxlLiRieWU9ZnVuY3Rpb24oKXtyZXR1cm4gU2suVHVydGxlR3JhcGhpY3MucmVzZXQoKX0sZS4kZXhpdG9uY2xpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXhpdE9uQ2xpY2s9ITAsdGhpcy5nZXRNYW5hZ2VyKFxcXCJtb3VzZWRvd25cXFwiKS5hZGRIYW5kbGVyKChmdW5jdGlvbigpe3Jlc2V0VHVydGxlKCl9KSwhMSl9LGUuJG9uY2xpY2s9ZnVuY3Rpb24oZSx0LG4pe3RoaXMuX2V4aXRPbkNsaWNrfHx0aGlzLmdldE1hbmFnZXIoXFxcIm1vdXNlZG93blxcXCIpLmFkZEhhbmRsZXIoZSxuKX0sZS4kb25jbGljay5taW5BcmdzPTEsZS4kb25jbGljay5jb192YXJuYW1lcz1bXFxcIm1ldGhvZFxcXCIsXFxcImJ0blxcXCIsXFxcImFkZFxcXCJdO3ZhciB0PXs4Oi9eYmFjayhzcGFjZSk/JC9pLDk6L150YWIkL2ksMTM6L14oZW50ZXJ8cmV0dXJuKSQvaSwxNjovXnNoaWZ0JC9pLDE3Oi9eKGN0cmx8Y29udHJvbCkkL2ksMTg6L15hbHQkL2ksMjc6L15lc2MoYXBlKT8kL2ksMzI6L15zcGFjZSQvaSwzMzovXnBhZ2VbXFxcXHNcXFxcLV0/dXAkL2ksMzQ6L15wYWdlW1xcXFxzXFxcXC1dP2Rvd24kL2ksMzU6L15lbmQkL2ksMzY6L15ob21lJC9pLDM3Oi9ebGVmdChbXFxcXHNcXFxcLV0/YXJyb3cpPyQvaSwzODovXnVwKFtcXFxcc1xcXFwtXT9hcnJvdyk/JC9pLDM5Oi9ecmlnaHQoW1xcXFxzXFxcXC1dP2Fycm93KT8kL2ksNDA6L15kb3duKFtcXFxcc1xcXFwtXT9hcnJvdyk/JC9pLDQ1Oi9eaW5zZXJ0JC9pLDQ2Oi9eZGVsKGV0ZSk/JC9pfTtlLl9jcmVhdGVLZXlSZXBlYXRlcj1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7bi5fa2V5TG9nZ2VyW3RdPXdpbmRvdy5zZXRUaW1lb3V0KChmdW5jdGlvbigpe24uX2tleUxpc3RlbmVyc1tlXSgpLG4uX2tleUxvZ2dlclt0XT13aW5kb3cuc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCl7bi5fa2V5TGlzdGVuZXJzW2VdKCl9KSw1MCl9KSwzMzMpfSxlLl9jcmVhdGVLZXlEb3duTGlzdGVuZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuX2tleURvd25MaXN0ZW5lcnx8KHRoaXMuX2tleURvd25MaXN0ZW5lcj1mdW5jdGlvbihuKXtpZihmb2N1c1R1cnRsZSgpKXt2YXIgcixpLHM9bi5jaGFyQ29kZXx8bi5rZXlDb2RlLGE9U3RyaW5nLmZyb21DaGFyQ29kZShzKS50b0xvd2VyQ2FzZSgpO2lmKCFlLl9rZXlMb2dnZXJbc10pZm9yKHIgaW4gZS5fa2V5TGlzdGVuZXJzKWlmKGk9ci5sZW5ndGg+MSYmdFtzXSYmdFtzXS50ZXN0KHIpLHI9PT1hfHxpKXtlLl9rZXlMaXN0ZW5lcnNbcl0oKSxlLl9jcmVhdGVLZXlSZXBlYXRlcihyLHMpLG4ucHJldmVudERlZmF1bHQoKTticmVha319fSxnZXRUYXJnZXQoKS5hZGRFdmVudExpc3RlbmVyKFxcXCJrZXlkb3duXFxcIix0aGlzLl9rZXlEb3duTGlzdGVuZXIpKX0sZS5fY3JlYXRlS2V5VXBMaXN0ZW5lcj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5fa2V5VXBMaXN0ZW5lcnx8KHRoaXMuX2tleVVwTGlzdGVuZXI9ZnVuY3Rpb24odCl7dmFyIG49ZS5fa2V5TG9nZ2VyW3QuY2hhckNvZGV8fHQua2V5Q29kZV07dm9pZCAwIT09biYmKHQucHJldmVudERlZmF1bHQoKSx3aW5kb3cuY2xlYXJJbnRlcnZhbChuKSx3aW5kb3cuY2xlYXJUaW1lb3V0KG4pLGRlbGV0ZSBlLl9rZXlMb2dnZXJbdC5jaGFyQ29kZXx8dC5rZXlDb2RlXSl9LGdldFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoXFxcImtleXVwXFxcIix0aGlzLl9rZXlVcExpc3RlbmVyKSl9LGUuJHRpdGxlPWZ1bmN0aW9uKGUpe2RvY3VtZW50LnRpdGxlPWV9LGUuJHRpdGxlLm1pbkFyZ3M9MSxlLiR0aXRsZS5jb192YXJuYW1lcz1bXFxcInRpdGxlXFxcIl0sZS4kbGlzdGVuPWZ1bmN0aW9uKCl7dGhpcy5fY3JlYXRlS2V5VXBMaXN0ZW5lcigpLHRoaXMuX2NyZWF0ZUtleURvd25MaXN0ZW5lcigpfSxlLiRvbmtleT1mdW5jdGlvbihlLHQpe2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB0KXt2YXIgbj1lO2U9dCx0PW59dD1TdHJpbmcodCkudG9Mb3dlckNhc2UoKSxlJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZT8odGhpcy5fa2V5TGlzdGVuZXJzfHwodGhpcy5fa2V5TGlzdGVuZXJzPXt9KSx0aGlzLl9rZXlMaXN0ZW5lcnNbdF09ZSk6ZGVsZXRlIHRoaXMuX2tleUxpc3RlbmVyc1t0XX0sZS4kb25rZXkubWluQXJncz0yLGUuJG9ua2V5LmNvX3Zhcm5hbWVzPVtcXFwibWV0aG9kXFxcIixcXFwia2V5VmFsdWVcXFwiXSxlLiRvbnNjcmVlbmNsaWNrPWZ1bmN0aW9uKGUsdCxuKXt0aGlzLmdldE1hbmFnZXIoXFxcIm1vdXNlZG93blxcXCIpLmFkZEhhbmRsZXIoZSxuKX0sZS4kb25zY3JlZW5jbGljay5taW5BcmdzPTEsZS4kb25zY3JlZW5jbGljay5jb192YXJuYW1lcz1bXFxcIm1ldGhvZFxcXCIsXFxcImJ0blxcXCIsXFxcImFkZFxcXCJdLGUuJG9udGltZXI9ZnVuY3Rpb24oZSx0KXt0aGlzLl90aW1lciYmKHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZXIpLHRoaXMuX3RpbWVyPXZvaWQgMCksZSYmXFxcIm51bWJlclxcXCI9PXR5cGVvZiB0JiYodGhpcy5fdGltZXI9d2luZG93LnNldFRpbWVvdXQoZSxNYXRoLm1heCgwLDB8dCkpKX0sZS4kb250aW1lci5taW5BcmdzPTAsZS4kb250aW1lci5jb192YXJuYW1lcz1bXFxcIm1ldGhvZFxcXCIsXFxcImludGVydmFsXFxcIl19KFNjcmVlbi5wcm90b3R5cGUpO3ZhciBnPW5ldyBJbWFnZTtmdW5jdGlvbiByZW1vdmVMYXllcihlKXtlJiZlLmNhbnZhcyYmZS5jYW52YXMucGFyZW50Tm9kZSYmZS5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlLmNhbnZhcyl9ZnVuY3Rpb24gY2xlYXJMYXllcihlLHQsbil7ZSYmKGUuc2F2ZSgpLGUuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKSx0PyhlLmZpbGxTdHlsZT10LGUuZmlsbFJlY3QoMCwwLGUuY2FudmFzLndpZHRoLGUuY2FudmFzLmhlaWdodCkpOmUuY2xlYXJSZWN0KDAsMCxlLmNhbnZhcy53aWR0aCxlLmNhbnZhcy5oZWlnaHQpLG4mJmUuZHJhd0ltYWdlKG4sMCwwKSxlLnJlc3RvcmUoKSl9ZnVuY3Rpb24gZHJhd1R1cnRsZShlLHQpe3ZhciBuLHIsaSxzPWRbZS5zaGFwZV0sYT1nZXRTY3JlZW4oKSxvPShnZXRXaWR0aCgpLGdldEhlaWdodCgpLGEueFNjYWxlKSxsPWEueVNjYWxlO2lmKHQpe2lmKG49TWF0aC5jb3MoZS5yYWRpYW5zKS9vLHI9TWF0aC5zaW4oZS5yYWRpYW5zKS9sLGk9TWF0aC5hdGFuMihyLG4pLU1hdGguUEkvMix0LnNhdmUoKSx0LnRyYW5zbGF0ZShlLngsZS55KSx0LnNjYWxlKG8sbCkscy5ub2RlTmFtZSl7dmFyIHU9cy5uYXR1cmFsV2lkdGgsYz1zLm5hdHVyYWxIZWlnaHQ7dC5kcmF3SW1hZ2UocywwLDAsdSxjLC11LzIsLWMvMix1LGMpfWVsc2V7dC5yb3RhdGUoaSksdC5iZWdpblBhdGgoKSx0LmxpbmVXaWR0aD0xLHQuc3Ryb2tlU3R5bGU9ZS5jb2xvcix0LmZpbGxTdHlsZT1lLmZpbGwsdC5tb3ZlVG8oLXNbMF1bMF0sc1swXVsxXSk7Zm9yKHZhciBoPTE7aDxzLmxlbmd0aDtoKyspdC5saW5lVG8oLXNbaF1bMF0sc1toXVsxXSk7dC5jbG9zZVBhdGgoKSx0LmZpbGwoKSx0LnN0cm9rZSgpfXQucmVzdG9yZSgpfX1mdW5jdGlvbiBkcmF3RG90KGUsdCl7dmFyIG49dGhpcy5jb250ZXh0KCkscj1nZXRTY3JlZW4oKSxpPXIueFNjYWxlLHM9ci55U2NhbGU7biYmKG4uYmVnaW5QYXRoKCksbi5tb3ZlVG8odGhpcy54LHRoaXMueSksZSo9TWF0aC5taW4oTWF0aC5hYnMoaSksTWF0aC5hYnMocykpLG4uYXJjKHRoaXMueCx0aGlzLnksZS8yLDAsVHVydGxlLlJBRElBTlMpLG4uY2xvc2VQYXRoKCksbi5maWxsU3R5bGU9dHx8dGhpcy5jb2xvcixuLmZpbGwoKSl9dmFyIHA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIikuZ2V0Q29udGV4dChcXFwiMmRcXFwiKTtmdW5jdGlvbiBkcmF3VGV4dChlLHQsbil7dmFyIHI9dGhpcy5jb250ZXh0KCk7ciYmKHIuc2F2ZSgpLG4mJihyLmZvbnQ9biksdCYmdC5tYXRjaCgvXihsZWZ0fHJpZ2h0fGNlbnRlcikkLykmJihyLnRleHRBbGlnbj10KSxyLnNjYWxlKDEsLTEpLHIuZmlsbFN0eWxlPXRoaXMuZmlsbCxyLmZpbGxUZXh0KGUsdGhpcy54LC10aGlzLnkpLHIucmVzdG9yZSgpKX1mdW5jdGlvbiBkcmF3TGluZShlLHQsbil7dmFyIHI9dGhpcy5jb250ZXh0KCk7ciYmKHQmJihyLmJlZ2luUGF0aCgpLHIubW92ZVRvKHRoaXMueCx0aGlzLnkpKSxyLmxpbmVXaWR0aD10aGlzLnNpemUqZ2V0U2NyZWVuKCkubGluZVNjYWxlLHIuc3Ryb2tlU3R5bGU9dGhpcy5jb2xvcixyLmxpbmVUbyhlLngsZS55KSxyLnN0cm9rZSgpKX1mdW5jdGlvbiBkcmF3RmlsbCgpe3ZhciBlLHQ9dGhpcy5jb250ZXh0KCksbj10aGlzLmZpbGxCdWZmZXI7aWYodCYmbiYmbi5sZW5ndGgpe2Zvcih0LnNhdmUoKSx0LmJlZ2luUGF0aCgpLHQubW92ZVRvKG5bMF0ueCxuWzBdLnkpLGU9MTtlPG4ubGVuZ3RoO2UrKyl0LmxpbmVUbyhuW2VdLngsbltlXS55KTtmb3IodC5jbG9zZVBhdGgoKSx0LmZpbGxTdHlsZT10aGlzLmZpbGwsdC5maWxsKCksZT0xO2U8bi5sZW5ndGg7ZSsrKW5bZV0uc3Ryb2tlJiYodC5iZWdpblBhdGgoKSx0Lm1vdmVUbyhuW2UtMV0ueCxuW2UtMV0ueSksdC5saW5lV2lkdGg9bltlXS5zaXplKmdldFNjcmVlbigpLmxpbmVTY2FsZSx0LnN0cm9rZVN0eWxlPW5bZV0uY29sb3IsdC5saW5lVG8obltlXS54LG5bZV0ueSksdC5zdHJva2UoKSk7dC5yZXN0b3JlKCl9fWZ1bmN0aW9uIHBhcnRpYWxUcmFuc2xhdGUoZSx0LG4scixpKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5hZGRVcGRhdGUoKGZ1bmN0aW9uKGUpe3RoaXMuZG93biYmZHJhd0xpbmUuY2FsbCh0aGlzLGUscil9KSxpLHt4OnQseTpufSxyKX19ZnVuY3Rpb24gcGFydGlhbFJvdGF0ZShlLHQsbixyKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5hZGRVcGRhdGUodm9pZCAwLHIse2FuZ2xlOnQscmFkaWFuczpufSl9fWZ1bmN0aW9uIGdldENvb3JkaW5hdGVzKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PWUmJihlLnl8fGUuX3l8fGVbMV0pfHwwLGU9ZSYmKGUueHx8ZS5feHx8ZVswXSl8fDApLHt4OmUseTp0fX1mdW5jdGlvbiBoZXhUb1JHQihlKXt2YXIgdCxuLHI7cmV0dXJuKHQ9L15yZ2JhP1xcXFwoKFxcXFxkKyksKFxcXFxkKyksKFxcXFxkKykoPzosKFsuXFxcXGRdKykpP1xcXFwpJC8uZXhlYyhlKSk/KHI9W3BhcnNlSW50KHRbMV0pLHBhcnNlSW50KHRbMl0pLHBhcnNlSW50KHRbM10pXSx0WzRdJiZyLnB1c2gocGFyc2VGbG9hdCh0WzRdKSkpOi9eIz9bYS1mXFxcXGRdezN9fFthLWZcXFxcZF17Nn0kL2kuZXhlYyhlKT8oND09PWUubGVuZ3RoJiYoZT1lLnJlcGxhY2UoL14jPyhbYS1mXFxcXGRdKShbYS1mXFxcXGRdKShbYS1mXFxcXGRdKSQvaSwoZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHQrdCtuK24rcityfSkpKSxuPS9eIz8oW2EtZlxcXFxkXXsyfSkoW2EtZlxcXFxkXXsyfSkoW2EtZlxcXFxkXXsyfSkkL2kuZXhlYyhlKSxyPVtwYXJzZUludChuWzFdLDE2KSxwYXJzZUludChuWzJdLDE2KSxwYXJzZUludChuWzNdLDE2KV0pOnI9ZSxyfWZ1bmN0aW9uIGNyZWF0ZUNvbG9yKGUsdCxuLHIsaSl7dmFyIHM7aWYodm9pZCAwIT09biYmKHQ9W3QsbixyLGldKSx0LmNvbnN0cnVjdG9yPT09QXJyYXkmJnQubGVuZ3RoKXtpZigyNTU9PT1lKWZvcihzPTA7czwzO3MrKyl7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiB0W3NdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImJhZCBjb2xvciBzZXF1ZW5jZVxcXCIpO3Rbc109TWF0aC5tYXgoMCxNYXRoLm1pbigyNTUscGFyc2VJbnQodFtzXSkpKX1lbHNlIGZvcihzPTA7czwzO3MrKyl7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiB0W3NdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImJhZCBjb2xvciBzZXF1ZW5jZVxcXCIpO2lmKCEodFtzXTw9MSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiYmFkIGNvbG9yIHNlcXVlbmNlXFxcIik7dFtzXT1NYXRoLm1heCgwLE1hdGgubWluKDI1NSxwYXJzZUludCgyNTUqdFtzXSkpKX1cXFwibnVtYmVyXFxcIj09dHlwZW9mIHRbc10/KHRbM109TWF0aC5tYXgoMCxNYXRoLm1pbigxLHRbc10pKSx0PVxcXCJyZ2JhKFxcXCIrdC5qb2luKFxcXCIsXFxcIikrXFxcIilcXFwiKTp0PVxcXCJyZ2IoXFxcIit0LnNsaWNlKDAsMykuam9pbihcXFwiLFxcXCIpK1xcXCIpXFxcIn1lbHNle2lmKFxcXCJzdHJpbmdcXFwiIT10eXBlb2YgdHx8dC5tYXRjaCgvXFxcXHMqdXJsXFxcXHMqXFxcXCgvaSkpcmV0dXJuXFxcImJsYWNrXFxcIjt0PXQucmVwbGFjZSgvXFxcXHMrL2csXFxcIlxcXCIpfXJldHVybiB0fWZ1bmN0aW9uIGNhbGN1bGF0ZUhlYWRpbmcoZSx0LG4pe3ZhciByPWUuX2FuZ2xlfHwwLGk9ZS5fcmFkaWFuc3x8MDtyZXR1cm4gbnx8KG49e30pLFxcXCJudW1iZXJcXFwiPT10eXBlb2YgdCYmKGUuX2lzUmFkaWFucz9yPWk9dCVUdXJ0bGUuUkFESUFOUzplLl9mdWxsQ2lyY2xlP2k9KHI9dCVlLl9mdWxsQ2lyY2xlKS9lLl9mdWxsQ2lyY2xlKlR1cnRsZS5SQURJQU5TOnI9aT0wLHI8MCYmKHIrPWUuX2Z1bGxDaXJjbGUsaSs9VHVydGxlLlJBRElBTlMpKSxuLmFuZ2xlPXIsbi5yYWRpYW5zPWksbn1mdW5jdGlvbiBweXRob25Ub0phdmFzY3JpcHRGdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShlKX0pKTtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHQmJm4udW5zaGlmdCh0KSxTay5taXNjZXZhbC5hcHBseUFzeW5jKHZvaWQgMCxlLHZvaWQgMCx2b2lkIDAsdm9pZCAwLG4pLmNhdGNoKFNrLnVuY2F1Z2h0RXhjZXB0aW9uKX19ZnVuY3Rpb24gYWRkTW9kdWxlTWV0aG9kKGUsdCxuLHIpe3ZhciBpLHM9bi5yZXBsYWNlKC9eXFxcXCQvLFxcXCJcXFwiKSxhPXMucmVwbGFjZSgvX1xcXFwkW2Etel0rXFxcXCQkL2ksXFxcIlxcXCIpLG89ZS5wcm90b3R5cGVbbl0ubGVuZ3RoLGw9ZS5wcm90b3R5cGVbbl0ubWluQXJncyx1PWUucHJvdG90eXBlW25dLmNvX3Zhcm5hbWVzfHxbXSxjPWUucHJvdG90eXBlW25dLnJldHVyblR5cGUsaD1lLnByb3RvdHlwZVtuXS5pc1NrO3ZvaWQgMD09PWwmJihsPW8pLGk9ZnVuY3Rpb24oKXt2YXIgZSx0LGkscyx1LGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApLGY9cj9yKCk6ZC5zaGlmdCgpLmluc3RhbmNlO2lmKGQubGVuZ3RoPGx8fGQubGVuZ3RoPm8pdGhyb3cgdT1sPT09bz9cXFwiZXhhY3RseSBcXFwiK286XFxcImJldHdlZW4gXFxcIitsK1xcXCIgYW5kIFxcXCIrbyxuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcXFwiKCkgdGFrZXMgXFxcIit1K1xcXCIgcG9zaXRpb25hbCBhcmd1bWVudChzKSAoXFxcIitkLmxlbmd0aCtcXFwiIGdpdmVuKVxcXCIpO2ZvcihlPWQubGVuZ3RoOy0tZT49MDspdm9pZCAwIT09ZFtlXSYmKGRbZV1pbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZnVuYz9kW2VdPXB5dGhvblRvSmF2YXNjcmlwdEZ1bmN0aW9uKGRbZV0pOmRbZV1pbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWV0aG9kP2RbZV09cHl0aG9uVG9KYXZhc2NyaXB0RnVuY3Rpb24oZFtlXS5pbV9mdW5jLGRbZV0uaW1fc2VsZik6ZFtlXSYmZFtlXS4kZCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCYmZFtlXS5pbnN0YW5jZT9kW2VdPWRbZV0uaW5zdGFuY2U6ZFtlXT1Tay5mZmkucmVtYXBUb0pzKGRbZV0pKTt2YXIgXz1kLnNsaWNlKDApO2ZvcihkPVtdLGU9Xy5sZW5ndGg7ZT49MDstLWUpbnVsbCE9PV9bZV0mJihkW2VdPV9bZV0pO3RyeXt0PWZbbl0uYXBwbHkoZixkKX1jYXRjaChnKXt0aHJvdyB3aW5kb3cmJndpbmRvdy5jb25zb2xlJiYod2luZG93LmNvbnNvbGUubG9nKFxcXCJ3cmFwcGVkIG1ldGhvZCBmYWlsZWRcXFwiKSx3aW5kb3cuY29uc29sZS5sb2coZy5zdGFjaykpLGd9cmV0dXJuIHQgaW5zdGFuY2VvZiBJbnN0YW50UHJvbWlzZSYmKHQ9dC5sYXN0UmVzdWx0KSx0IGluc3RhbmNlb2YgUHJvbWlzZT8odD10LmNhdGNoKChmdW5jdGlvbihlKXt0aHJvdyB3aW5kb3cmJndpbmRvdy5jb25zb2xlJiYod2luZG93LmNvbnNvbGUubG9nKFxcXCJwcm9taXNlIGZhaWxlZFxcXCIpLHdpbmRvdy5jb25zb2xlLmxvZyhlLnN0YWNrKSksZX0pKSwoaT1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbikucmVzdW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXM/U2suYnVpbHRpbi5ub25lLm5vbmUkOlNrLmZmaS5yZW1hcFRvUHkocyl9LGkuZGF0YT17dHlwZTpcXFwiU2sucHJvbWlzZVxcXCIscHJvbWlzZTp0LnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBzPWUsZX0pKX0saSk6dm9pZCAwPT09dD9Tay5idWlsdGluLm5vbmUubm9uZSQ6aD90OlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBjP2ModCk6U2suZmZpLnJlbWFwVG9QeSh0KX0saS5jb19uYW1lPW5ldyBTay5idWlsdGluLnN0cihhKSxpLmNvX3Zhcm5hbWVzPXUuc2xpY2UoKSxpLiRkZWZhdWx0cz1bXTtmb3IodmFyIGQ9bDtkPHUubGVuZ3RoO2QrKylpLiRkZWZhdWx0cy5wdXNoKFNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7cnx8aS5jb192YXJuYW1lcy51bnNoaWZ0KFxcXCJzZWxmXFxcIiksdFtzXT1uZXcgU2suYnVpbHRpbi5mdW5jKGkpfWZ1bmN0aW9uIGluaXRUdXJ0bGUoZSx0KXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLDIsMywhMSwhMSksZS5pbnN0YW5jZT1uZXcgVHVydGxlKHQpLGUuaW5zdGFuY2Uuc2tJbnN0YW5jZT1lfWZvcih2YXIgbSBpbiBpbml0VHVydGxlLmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInNoYXBlXFxcIl0saW5pdFR1cnRsZS5jb19uYW1lPW5ldyBTay5idWlsdGluLnN0cihcXFwiVHVydGxlXFxcIiksaW5pdFR1cnRsZS5jb19hcmdjb3VudD0yLGluaXRUdXJ0bGUuJGRlZmF1bHRzPVtTay5idWlsdGluLm5vbmUubm9uZSQsbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJjbGFzc2ljXFxcIildLFR1cnRsZS5wcm90b3R5cGUpL15cXFxcJFthLXpfXSsvLnRlc3QobSkmJmFkZE1vZHVsZU1ldGhvZChUdXJ0bGUsdSxtLGVuc3VyZUFub255bW91cyk7ZnVuY3Rpb24gZm9jdXNUdXJ0bGUoZSl7cmV0dXJuIHZvaWQgMCE9PWUmJigoYz0hIWUpP2dldFRhcmdldCgpLmZvY3VzKCk6Z2V0VGFyZ2V0KCkuYmx1cigpKSxjfWZ1bmN0aW9uIHJlc2V0VHVydGxlKCl7Zm9yKGNhbmNlbEFuaW1hdGlvbkZyYW1lKCksZ2V0U2NyZWVuKCkucmVzZXQoKSxnZXRGcmFtZU1hbmFnZXIoKS5yZXNldCgpO2UuZmlyc3RDaGlsZDspZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO2EmJmEucmVzZXQoKSxyPXZvaWQgMCxzPXZvaWQgMCxhPXZvaWQgMH1yZXR1cm4gYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkbWFpbmxvb3BcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkZG9uZVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRieWVcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkdHJhY2VyXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJHVwZGF0ZVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRkZWxheVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiR3aW5kb3dfd2lkdGhcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkd2luZG93X2hlaWdodFxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiR0aXRsZVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRvbmtleVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRsaXN0ZW5cXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkcmVnaXN0ZXJfc2hhcGVcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkY2xlYXJzY3JlZW5cXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkYmdjb2xvclxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRiZ3BpY1xcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRzZXR3b3JsZGNvb3JkaW5hdGVzXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4sdSxcXFwiJG9udGltZXJcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix1LFxcXCIkb25zY3JlZW5jbGlja1xcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRleGl0b25jbGlja1xcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRyZXNldHNjcmVlblxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiRzZXR1cFxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHUsXFxcIiR0dXJ0bGVzXFxcIixnZXRTY3JlZW4pLHUuVHVydGxlPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3ModSwoZnVuY3Rpb24gVHVydGxlV3JhcHBlcihlLHQpe2Zvcih2YXIgbiBpbiB0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoaW5pdFR1cnRsZSksVHVydGxlLnByb3RvdHlwZSkvXlxcXFwkW2Etel9dKy8udGVzdChuKSYmYWRkTW9kdWxlTWV0aG9kKFR1cnRsZSx0LG4pfSksXFxcIlR1cnRsZVxcXCIsW10pLHUuU2NyZWVuPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3ModSwoZnVuY3Rpb24gU2NyZWVuV3JhcHBlcihlLHQpe2Zvcih2YXIgbiBpbiB0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe2UuaW5zdGFuY2U9Z2V0U2NyZWVuKCl9KSksU2NyZWVuLnByb3RvdHlwZSkvXlxcXFwkW2Etel9dKy8udGVzdChuKSYmYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix0LG4pfSksXFxcIlNjcmVlblxcXCIsW10pLHtza01vZHVsZTp1LHJlc2V0OnJlc2V0VHVydGxlLHN0b3A6ZnVuY3Rpb24gc3RvcFR1cnRsZSgpe2NhbmNlbEFuaW1hdGlvbkZyYW1lKCksYSYmYS5yZXNldCgpLHI9dm9pZCAwLHM9dm9pZCAwLGE9dm9pZCAwfSxmb2N1czpmb2N1c1R1cnRsZSxUdXJ0bGU6VHVydGxlLFNjcmVlbjpTY3JlZW59fSh0KSxTay5UdXJ0bGVHcmFwaGljcy5tb2R1bGU9dC50dXJ0bGVJbnN0YW5jZS5za01vZHVsZSxTay5UdXJ0bGVHcmFwaGljcy5yZXNldD10LnR1cnRsZUluc3RhbmNlLnJlc2V0LFNrLlR1cnRsZUdyYXBoaWNzLnN0b3A9dC50dXJ0bGVJbnN0YW5jZS5zdG9wLFNrLlR1cnRsZUdyYXBoaWNzLmZvY3VzPXQudHVydGxlSW5zdGFuY2UuZm9jdXMsU2suVHVydGxlR3JhcGhpY3MucmF3PXtUdXJ0bGU6dC50dXJ0bGVJbnN0YW5jZS5UdXJ0bGUsU2NyZWVuOnQudHVydGxlSW5zdGFuY2UuU2NyZWVufSx0LnR1cnRsZUluc3RhbmNlLnNrTW9kdWxlfTtcIixcInNyYy9saWIvdXJsbGliL19faW5pdF9fLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24obil7cmV0dXJue319O1wiLFwic3JjL2xpYi91cmxsaWIvcmVxdWVzdC9fX2luaXRfXy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG4pe3ZhciBlPXt9O2UuUmVzcG9uc2U9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhlLChmdW5jdGlvbihuLGUpe2UuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixlKXtuLmRhdGEkPWUucmVzcG9uc2VUZXh0LG4ubGluZUxpc3Q9bi5kYXRhJC5zcGxpdChcXFwiXFxcXG5cXFwiKSxuLmxpbmVMaXN0PW4ubGluZUxpc3Quc2xpY2UoMCwtMSk7Zm9yKHZhciBpPTA7aTxuLmxpbmVMaXN0Lmxlbmd0aDtpKyspbi5saW5lTGlzdFtpXT1uLmxpbmVMaXN0W2ldK1xcXCJcXFxcblxcXCI7bi5jdXJyZW50TGluZT0wLG4ucG9zJD0wfSkpLGUuX19zdHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShcXFwiPFJlc3BvbnNlPlxcXCIpfSkpLGUuX19pdGVyX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7dmFyIGU9bi5saW5lTGlzdDtyZXR1cm4gU2suYnVpbHRpbi5tYWtlR2VuZXJhdG9yKChmdW5jdGlvbigpe2lmKCEodGhpcy4kaW5kZXg+PXRoaXMuJGxpbmVzLmxlbmd0aCkpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLiRsaW5lc1t0aGlzLiRpbmRleCsrXSl9KSx7JG9iajpuLCRpbmRleDowLCRsaW5lczplfSl9KSksZS5yZWFkPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sZSl7aWYobi5jbG9zZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiSS9PIG9wZXJhdGlvbiBvbiBjbG9zZWQgZmlsZVxcXCIpO3ZhciBpPW4uZGF0YSQubGVuZ3RoO3ZvaWQgMD09PWUmJihlPWkpO3ZhciB0PW5ldyBTay5idWlsdGluLnN0cihuLmRhdGEkLnN1YnN0cihuLnBvcyQsZSkpO3JldHVybiBuLnBvcyQrPWUsbi5wb3MkPj1pJiYobi5wb3MkPWkpLHR9KSksZS5yZWFkbGluZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLGUpe3ZhciBpPVxcXCJcXFwiO3JldHVybiBuLmN1cnJlbnRMaW5lPG4ubGluZUxpc3QubGVuZ3RoJiYoaT1uLmxpbmVMaXN0W24uY3VycmVudExpbmVdLG4uY3VycmVudExpbmUrKyksbmV3IFNrLmJ1aWx0aW4uc3RyKGkpfSkpLGUucmVhZGxpbmVzPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sZSl7Zm9yKHZhciBpPVtdLHQ9bi5jdXJyZW50TGluZTt0PG4ubGluZUxpc3QubGVuZ3RoO3QrKylpLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKG4ubGluZUxpc3RbdF0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChpKX0pKX0pLFxcXCJSZXNwb25zZVxcXCIsW10pO3JldHVybiBlLnVybG9wZW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixpLHQpe3ZhciByO3I9ZnVuY3Rpb24obil7dmFyIGU7aWYoIVNrLmpzb25wU2l0ZXMpcmV0dXJuITE7Zm9yKGU9MDtlPFNrLmpzb25wU2l0ZXMubGVuZ3RoO2UrKylpZihuLnN0YXJ0c1dpdGgoU2suanNvbnBTaXRlc1tlXSkpcmV0dXJuITA7cmV0dXJuITF9KG4udik/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGksdCl7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIik7ci5zcmM9bi52K1xcXCImY2FsbGJhY2s9U2suanNvbnBjYWxsYmFja1xcXCIsci5vbmVycm9yPWZ1bmN0aW9uKG4pe3QoXFxcIkFuIGVycm9yIG9jY3VyZWQgZ2V0dGluZyB0aGUgZGF0YVxcXCIpfSxTay5qc29ucGNhbGxiYWNrPWZ1bmN0aW9uKG4pe3ZhciB0PXtyZXNwb25zZVRleHQ6SlNPTi5zdHJpbmdpZnkobil9O2koU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUuUmVzcG9uc2UsW3RdKSl9O3RyeXtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHIpfWNhdGNoKHMpe2NvbnNvbGUubG9nKFxcXCJjYXVnaHQgZXJyb3IgaW4gdXJsb3BlblxcXCIrcyl9fSkpOm5ldyBQcm9taXNlKChmdW5jdGlvbih0LHIpe3ZhciBzPW5ldyBYTUxIdHRwUmVxdWVzdDtzLmFkZEV2ZW50TGlzdGVuZXIoXFxcImxvYWRlbmRcXFwiLChmdW5jdGlvbihuKXt0KFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLlJlc3BvbnNlLFtzXSkpfSkpLGk/KHMub3BlbihcXFwiUE9TVFxcXCIsbi52KSxzLnNldFJlcXVlc3RIZWFkZXIoXFxcIkNvbnRlbnQtdHlwZVxcXCIsXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCIpLHMuc2VuZChpLnYpKToocy5vcGVuKFxcXCJHRVRcXFwiLG4udikscy5zZW5kKG51bGwpKX0pKTt2YXIgcyx1PW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uO3JldHVybiB1LnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiBzfSx1LmRhdGE9e3R5cGU6XFxcIlNrLnByb21pc2VcXFwiLHByb21pc2U6ci50aGVuKChmdW5jdGlvbihuKXtyZXR1cm4gcz1uLG59KSwoZnVuY3Rpb24obil7cmV0dXJuIHM9XFxcIlxcXCIsbn0pKX0sdX0pKSxlfTtcIixcInNyYy9saWIvdXVpZC5qc1wiOlwiZnVuY3Rpb24gJGJ1aWx0aW5tb2R1bGUoKXtjb25zdHtidWlsdGluOntieXRlczplLHN0cjp0LGludF86bixUeXBlRXJyb3I6aSxWYWx1ZUVycm9yOnMsTm90SW1wbGVtZW50ZWRFcnJvcjpyLG5vbmU6e25vbmUkOm99LE5vdEltcGxlbWVudGVkOntOb3RJbXBsZW1lbnRlZCQ6bH19LGFic3RyOntidWlsZE5hdGl2ZUNsYXNzOmEsY2hlY2tBcmdzTGVuOm0sY29weUtleXdvcmRzVG9OYW1lZEFyZ3M6JCxsb29rdXBTcGVjaWFsOnUsc2V0VXBNb2R1bGVNZXRob2RzOmh9LG1pc2NldmFsOntjYWxsc2ltQXJyYXk6ZCxvYmplY3RSZXByOmMscmljaENvbXBhcmVCb29sOmd9fT1TayxwPXtfX25hbWVfXzpuZXcgdChcXFwidXVpZFxcXCIpLFJFU0VSVkVEX05DUzpvLFJGQ180MTIyOm8sUkVTRVJWRURfRlVUVVJFOm99O2xldCBmPVNrLmdsb2JhbC5jcnlwdG87XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmJiYoZj17Z2V0UmFuZG9tVmFsdWVzKGUpe2xldCB0PWUubGVuZ3RoO2Zvcig7dC0tOyllW3RdPU1hdGguZmxvb3IoMjU2Kk1hdGgucmFuZG9tKCkpO3JldHVybiBlfX0pO2NvbnN0IHc9bi50cCRnZXRhdHRyKG5ldyB0KFxcXCJmcm9tX2J5dGVzXFxcIikpLGI9bi50cCRnZXRhdHRyKG5ldyB0KFxcXCJ0b19ieXRlc1xcXCIpKSx5PW5ldyBuKDEpLm5iJGxzaGlmdChuZXcgbigxMjgpKSxfPW5ldyBuKDApLEk9bmV3IG4oNCksVT1uZXcgbigxNiksdj1uZXcgdChcXFwiYmlnXFxcIiksRT1uZXcgdChcXFwiJTAzMnhcXFwiKSxTPS8tL2c7ZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKXt0aHJvdyBuZXcgcihcXFwiTm90IHlldCBpbXBsZW1uZXRlZCBpbiBTa3VscHRcXFwiKX1mdW5jdGlvbiBzd2l0Y2hCeXRlc0J5dGVzTGUoZSl7Y29uc3QgdD1uZXcgVWludDhBcnJheShlKTtyZXR1cm4gdFswXT1lWzNdLHRbMV09ZVsyXSx0WzJdPWVbMV0sdFszXT1lWzBdLHRbNF09ZVs1XSx0WzVdPWVbNF0sdFs2XT1lWzddLHRbN109ZVs2XSx0fWNvbnN0IFI9cC5VVUlEPWEoXFxcInV1aWQuVVVJRFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7fSxzbG90czp7dHAkaW5pdChsLGEpe20oXFxcIlVVSURcXFwiLGwsMCw2KTtsZXRbdSxoLGMscCxmLGIsSV09JChcXFwiVVVJRFxcXCIsW1xcXCJoZXhcXFwiLFxcXCJieXRlc1xcXCIsXFxcImJ5dGVzX2xlXFxcIixcXFwiZmllbGRzXFxcIixcXFwiaW50XFxcIixcXFwidmVyc2lvblxcXCIsXFxcImlzX3NhZmVcXFwiXSxsLGEsW28sbyxvLG8sbyxvLG9dKTtpZig0IT09W3UsaCxjLHAsZl0uZmlsdGVyKChlPT5lPT09bykpLmxlbmd0aCl0aHJvdyBuZXcgaShcXFwib25lIG9mIHRoZSBoZXgsIGJ5dGVzLCBieXRlc19sZSwgZmllbGRzLCBvciBpbnQgYXJndW1lbnRzIG11c3QgYmUgZ2l2ZW5cXFwiKTtpZih1IT09byl7dT11LnRvU3RyaW5nKCkucmVwbGFjZShcXFwidXJuOlxcXCIsXFxcIlxcXCIpLnJlcGxhY2UoXFxcInV1aWQ6XFxcIixcXFwiXFxcIik7bGV0IGU9MCxpPXUubGVuZ3RoLTE7Zm9yKDtcXFwie31cXFwiLmluZGV4T2YodVtlXSk+PTA7KWUrKztmb3IoO1xcXCJ7fVxcXCIuaW5kZXhPZih1W2ldKT49MDspaS0tO2lmKHU9dS5zbGljZShlLGkrMSksdT11LnJlcGxhY2UoUyxcXFwiXFxcIiksMzIhPT11Lmxlbmd0aCl0aHJvdyBuZXcgcyhcXFwiYmFkbHkgZm9ybWVkIGhleGFkZWNpbWFsIFVVSUQgc3RyaW5nXFxcIik7Zj1kKG4sW25ldyB0KHUpLFVdKX1pZihjIT09byl7aWYoIShjIGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IGkoXFxcImJ5dGVzX2xlIHNob3VsZCBiZSBhIGJ5dGVzIGluc3RhbmNlXFxcIik7aWYoYz1jLnZhbHVlT2YoKSwxNiE9PWMubGVuZ3RoKXRocm93IG5ldyBzKFxcXCJieXRlc19sZSBpcyBub3QgYSAxNi1jaGFyIHN0cmluZ1xcXCIpO2g9c3dpdGNoQnl0ZXNCeXRlc0xlKGMpLGg9bmV3IGUoaCl9aWYoaCE9PW8pe2lmKCEoaCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBpKFxcXCJieXRlc19sZSBzaG91bGQgYmUgYSBieXRlcyBpbnN0YW5jZVxcXCIpO2lmKDE2IT09aC52YWx1ZU9mKCkubGVuZ3RoKXRocm93IG5ldyBzKFxcXCJieXRlcyBpcyBub3QgYSAxNi1jaGFyIHN0cmluZ1xcXCIpO2Y9ZCh3LFtoXSxbXFxcImJ5dGVvcmRlclxcXCIsdl0pfWlmKHAhPT1vKXRocm93IG5ldyByKFxcXCJmaWVsZHMgYXJndW1lbnQgaXMgbm90IHlldCBzdXBwb3J0ZWRcXFwiKTtpZihmIT09byYmKGcoZixfLFxcXCJMdFxcXCIpfHwoKGUsdCk9PmcoZSx0LFxcXCJHdEVcXFwiKSkoZix5KSkpdGhyb3cgbmV3IHMoXFxcImludCBpcyBvdXQgb2YgcmFuZ2UgKG5lZWQgYSAxMjgtYml0IHZhbHVlKVxcXCIpO3RoaXMuJGludD1mLHRoaXMuJGlzU2FmZT1JfSx0cCRzdHIoKXtjb25zdCBlPUUubmIkcmVtYWluZGVyKHRoaXMuJGludCkudG9TdHJpbmcoKTtyZXR1cm4gbmV3IHQoYCR7ZS5zbGljZSgwLDgpfS0ke2Uuc2xpY2UoOCwxMil9LSR7ZS5zbGljZSgxMiwxNil9LSR7ZS5zbGljZSgxNiwyMCl9LSR7ZS5zbGljZSgyMCl9YCl9LCRyKCl7Y29uc3QgZT11KHRoaXMub2IkdHlwZSx0LiRuYW1lKSxuPWModGhpcy50cCRzdHIoKSk7cmV0dXJuIG5ldyB0KGAke2V9KCR7bn0pYCl9LHRwJGhhc2goKXtyZXR1cm4gdGhpcy4kaW50LnRwJGhhc2goKX0sdHAkcmljaGNvbXBhcmUoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIFI/dGhpcy4kaW50LnRwJHJpY2hjb21wYXJlKGUuJGludCx0KTpsfSx0cCRhc19udW1iZXI6ITAsbmIkaW50KCl7cmV0dXJuIHRoaXMuJGludH19LGdldHNldHM6e2ludDp7JGdldCgpe3JldHVybiB0aGlzLiRpbnR9fSxpc19zYWZlOnskZ2V0KCl7cmV0dXJuIHRoaXMuJGlzU2FmZX19LGJ5dGVzOnskZ2V0KCl7cmV0dXJuIGQoYixbdGhpcy4kaW50LFUsdl0pfX0sYnl0ZXNfbGU6eyRnZXQoKXtjb25zdCBuPXRoaXMudHAkZ2V0YXR0cihuZXcgdChcXFwiYnl0ZXNcXFwiKSkudmFsdWVPZigpO3JldHVybiBuZXcgZShzd2l0Y2hCeXRlc0J5dGVzTGUobikpfX0sZmllbGRzOnskZ2V0OigpPT5ub3RJbXBsZW1lbnRlZCgpfSx0aW1lX2xvdzp7JGdldDooKT0+bm90SW1wbGVtZW50ZWQoKX0sdGltZV9taWQ6eyRnZXQ6KCk9Pm5vdEltcGxlbWVudGVkKCl9LHRpbWVfaGlfdmVyc2lvbjp7JGdldDooKT0+bm90SW1wbGVtZW50ZWQoKX0sY2xvY2tfc2VxX2hpX3ZhcmlhbnQ6eyRnZXQ6KCk9Pm5vdEltcGxlbWVudGVkKCl9LGNsb2NrX3NlcV9sb3c6eyRnZXQ6KCk9Pm5vdEltcGxlbWVudGVkKCl9LHRpbWU6eyRnZXQ6KCk9Pm5vdEltcGxlbWVudGVkKCl9LGNsb2NrX3NlcTp7JGdldDooKT0+bm90SW1wbGVtZW50ZWQoKX0sbm9kZTp7JGdldDooKT0+bm90SW1wbGVtZW50ZWQoKX0saGV4OnskZ2V0KCl7cmV0dXJuIEUubmIkcmVtYWluZGVyKHRoaXMuJGludCl9fSx1cm46eyRnZXQoKXtyZXR1cm4gbmV3IHQoYHVybjp1dWlkOiR7dGhpc31gKX19LHZhcmlhbnQ6eyRnZXQ6KCk9Pm5vdEltcGxlbWVudGVkKCl9LHZlcnNpb246eyRnZXQ6KCk9Pm5vdEltcGxlbWVudGVkKCl9fX0pO3JldHVybiBoKFxcXCJ1dWlkXFxcIixwLHt1dWlkMTp7JG1ldGgoKXtub3RJbXBsZW1lbnRlZCgpfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfX0sdXVpZDI6eyRtZXRoKCl7bm90SW1wbGVtZW50ZWQoKX0sJGZsYWdzOntGYXN0Q2FsbDohMH19LHV1aWQzOnskbWV0aCgpe25vdEltcGxlbWVudGVkKCl9LCRmbGFnczp7RmFzdENhbGw6ITB9fSx1dWlkNDp7JG1ldGgoKXtjb25zdCB0PW5ldyBlKGYuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSkpO3JldHVybiBkKFIsW10sW1xcXCJieXRlc1xcXCIsdCxcXFwidmVyc2lvblxcXCIsSV0pfSwkZmxhZ3M6e05vQXJnczohMH19LHV1aWQ1OnskbWV0aCgpe25vdEltcGxlbWVudGVkKCl9LCRmbGFnczp7RmFzdENhbGw6ITB9fX0pLHB9XCIsXCJzcmMvbGliL3dlYmJyb3dzZXIuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihuKXt2YXIgZT17fSx0PVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93JiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3I7ZnVuY3Rpb24gb3Blbl90YWIobil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInVybFxcXCIsXFxcInN0cmluZ1xcXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyhuKSksdD8obj1uLiRqc3N0cigpLHdpbmRvdy5vcGVuKG4sXFxcIl9ibGFua1xcXCIpLFNrLmJ1aWx0aW4uYm9vbC50cnVlJCk6U2suYnVpbHRpbi5ib29sLmZhbHNlJH1yZXR1cm4gZS5fX25hbWVfXz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIndlYmJyb3dzZXJcXFwiKSxlLm9wZW49bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gb3BlbihuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwib3BlblxcXCIsYXJndW1lbnRzLmxlbmd0aCsxLDEsMyksb3Blbl90YWIobil9KSksZS5vcGVuX25ldz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBvcGVuX25ldyhuKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwib3Blbl9uZXdcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxvcGVuX3RhYihuKX0pKSxlLm9wZW5fbmV3X3RhYj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBvcGVuX25ld190YWIobil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3X3RhYlxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLG9wZW5fdGFiKG4pfSkpLGUuRGVmYXVsdEJyb3dzZXI9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhlLChmdW5jdGlvbiBkZmxicm93c2VyKG4sZSl7ZS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBfX2luaXRfXyhuKXtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSkpLGUub3Blbj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbiBvcGVuKG4sZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiw0KSxvcGVuX3RhYihlKX0pKSxlLm9wZW5fbmV3PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uIG9wZW5fbmV3KG4sZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksb3Blbl90YWIoZSl9KSksZS5vcGVuX25ld190YWI9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gb3Blbl9uZXdfdGFiKG4sZSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3X3RhYlxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLG9wZW5fdGFiKGUpfSkpfSksXFxcIkRlZmF1bHRCcm93c2VyXFxcIixbXSksZS5nZXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldFxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLkRlZmF1bHRCcm93c2VyLFtdKX0pKSxlfTtcIixcInNyYy9saWIvd2ViZ2wvX19pbml0X18uanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihuKXt2YXIgdD17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ3ZWJnbFxcXCIpfSxtYWtlRmFpbEhUTUw9ZnVuY3Rpb24obil7cmV0dXJuJzx0YWJsZSBzdHlsZT1cXFwiYmFja2dyb3VuZC1jb2xvcjogIzhDRTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcXFwiPjx0cj48dGQgYWxpZ249XFxcImNlbnRlclxcXCI+PGRpdiBzdHlsZT1cXFwiZGlzcGxheTogdGFibGUtY2VsbDsgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXFwiPjxkaXYgc3R5bGU9XFxcIlxcXCI+JytuK1xcXCI8L2Rpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT5cXFwifSxlPSdUaGlzIHBhZ2UgcmVxdWlyZXMgYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgV2ViR0wuPGJyLz48YSBocmVmPVxcXCJodHRwOi8vZ2V0LndlYmdsLm9yZ1xcXCI+Q2xpY2sgaGVyZSB0byB1cGdyYWRlIHlvdXIgYnJvd3Nlci48L2E+JztyZXR1cm4gdC5Db250ZXh0PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3ModCwoZnVuY3Rpb24obix0KXt0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCl7dmFyIGk9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodC52KSxyPWZ1bmN0aW9uKG4sdCl7dmFyIGk9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobik7aWYodHx8KHQ9aS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiY2FudmFzXFxcIilbMF0pLHQpe3ZhciByPWZ1bmN0aW9uKG4pe2Zvcih2YXIgdD1bXFxcIndlYmdsXFxcIixcXFwiZXhwZXJpbWVudGFsLXdlYmdsXFxcIixcXFwid2Via2l0LTNkXFxcIixcXFwibW96LXdlYmdsXFxcIl0sZT1udWxsLGk9MDtpPHQubGVuZ3RoOysraSl7dHJ5e2U9bi5nZXRDb250ZXh0KHRbaV0pfWNhdGNoKHIpe31pZihlKWJyZWFrfWlmKGUpe2Z1bmN0aW9uIHJldHVybkZhbHNlKCl7cmV0dXJuITF9bi5vbnNlbGVjdHN0YXJ0PXJldHVybkZhbHNlLG4ub25tb3VzZWRvd249cmV0dXJuRmFsc2V9cmV0dXJuIGV9KHQpO2lmKCFyKXt2YXIgdT1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oXFxcXHcrXFxcXC8uKj8gKS9nKSxhPXt9O3RyeXtmb3IodmFyIG89MDtvPHUubGVuZ3RoOysrbyl7Zm9yKHZhciBsPXVbb10ubWF0Y2goLyhcXFxcdyspL2cpLGM9W10sZj0xO2Y8bC5sZW5ndGg7KytmKWMucHVzaChwYXJzZUludChsW2ZdKSk7YVtsWzBdXT1jfX1jYXRjaChzKXt9YS5DaHJvbWUmJihhLkNocm9tZVswXT43fHw3PT1hLkNocm9tZVswXSYmYS5DaHJvbWVbMV0+MHx8Nz09YS5DaHJvbWVbMF0mJjA9PWEuQ2hyb21lWzFdJiZhLkNocm9tZVsyXT49NTIxKT9pLmlubmVySFRNTD1tYWtlRmFpbEhUTUwoJ0l0IGRvZXNuXFxcXCd0IGFwcGVhciB5b3VyIGNvbXB1dGVyIGNhbiBzdXBwb3J0IFdlYkdMLjxici8+PGEgaHJlZj1cXFwiaHR0cDovL2dldC53ZWJnbC5vcmdcXFwiPkNsaWNrIGhlcmUgZm9yIG1vcmUgaW5mb3JtYXRpb24uPC9hPicpOmkuaW5uZXJIVE1MPW1ha2VGYWlsSFRNTChlKX1yZXR1cm4gcn1pLmlubmVySFRNTD1tYWtlRmFpbEhUTUwoZSl9KHQudixpKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXFxcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBXZWJHTC5cXFwiKTtmb3IodmFyIHUgaW4gbi5nbD1yLHIuX19wcm90b19fKWlmKFxcXCJudW1iZXJcXFwiPT10eXBlb2Ygci5fX3Byb3RvX19bdV0pU2suYWJzdHIub2JqZWN0U2V0SXRlbShuLiRkLG5ldyBTay5idWlsdGluLnN0cih1KSxyLl9fcHJvdG9fX1t1XSk7ZWxzZSBpZihcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygci5fX3Byb3RvX19bdV0pc3dpdGNoKHUpe2Nhc2VcXFwiYnVmZmVyRGF0YVxcXCI6Y2FzZVxcXCJjbGVhckNvbG9yXFxcIjpjYXNlXFxcImRyYXdBcnJheXNcXFwiOmNhc2VcXFwiZ2V0QXR0cmliTG9jYXRpb25cXFwiOmNhc2VcXFwiZ2V0VW5pZm9ybUxvY2F0aW9uXFxcIjpjYXNlXFxcInNoYWRlclNvdXJjZVxcXCI6Y2FzZVxcXCJ1bmlmb3JtTWF0cml4NGZ2XFxcIjpjYXNlXFxcInZlcnRleEF0dHJpYlBvaW50ZXJcXFwiOmNhc2VcXFwidmlld3BvcnRcXFwiOmJyZWFrO2RlZmF1bHQ6IWZ1bmN0aW9uKHQpe1NrLmFic3RyLm9iamVjdFNldEl0ZW0obi4kZCxuZXcgU2suYnVpbHRpbi5zdHIodSksbmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gci5fX3Byb3RvX19bdF0uYXBwbHkocixhcmd1bWVudHMpfSkpKX0odSl9ci5jbGVhckNvbG9yKDEwMC8yNTUsMTQ5LzI1NSwyMzcvMjU1LDEpLHIuY2xlYXIoci5DT0xPUl9CVUZGRVJfQklUKX0pKSx0LnRwJGdldGF0dHI9U2suZ2VuZXJpYy5nZXRBdHRyLHQuYnVmZmVyRGF0YT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSxpKXtuLmdsLmJ1ZmZlckRhdGEodCxlLnYsaSl9KSksdC5jbGVhckNvbG9yPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCxlLGkscil7bi5nbC5jbGVhckNvbG9yKFNrLmJ1aWx0aW4uYXNudW0kKHQpLFNrLmJ1aWx0aW4uYXNudW0kKGUpLFNrLmJ1aWx0aW4uYXNudW0kKGkpLFNrLmJ1aWx0aW4uYXNudW0kKHIpKX0pKSx0LmdldEF0dHJpYkxvY2F0aW9uPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCxlKXtyZXR1cm4gbi5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUudil9KSksdC5nZXRVbmlmb3JtTG9jYXRpb249bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUpe3JldHVybiBuLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUudil9KSksdC5zaGFkZXJTb3VyY2U9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUpe24uZ2wuc2hhZGVyU291cmNlKHQsZS52KX0pKSx0LmRyYXdBcnJheXM9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUsaSl7bi5nbC5kcmF3QXJyYXlzKFNrLmJ1aWx0aW4uYXNudW0kKHQpLFNrLmJ1aWx0aW4uYXNudW0kKGUpLFNrLmJ1aWx0aW4uYXNudW0kKGkpKX0pKSx0LnZlcnRleEF0dHJpYlBvaW50ZXI9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUsaSxyLHUsYSl7bi5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHQsU2suYnVpbHRpbi5hc251bSQoZSksU2suYnVpbHRpbi5hc251bSQoaSkscixTay5idWlsdGluLmFzbnVtJCh1KSxTay5idWlsdGluLmFzbnVtJChhKSl9KSksdC52aWV3cG9ydD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSxpLHIpe24uZ2wudmlld3BvcnQoU2suYnVpbHRpbi5hc251bSQodCksU2suYnVpbHRpbi5hc251bSQoZSksU2suYnVpbHRpbi5hc251bSQoaSksU2suYnVpbHRpbi5hc251bSQocikpfSkpLHQudW5pZm9ybU1hdHJpeDRmdj1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQsZSxpKXtuLmdsLnVuaWZvcm1NYXRyaXg0ZnYoU2suYnVpbHRpbi5hc251bSQodCksZSxpLnYpfSkpLHQuc2V0RHJhd0Z1bmM9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0KXt2YXIgZT0obmV3IERhdGUpLmdldFRpbWUoKTtzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKXtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodCxbbiwobmV3IERhdGUpLmdldFRpbWUoKS1lXSl9KSwxZTMvNjApfSkpfSksXFxcIkNvbnRleHRcXFwiLFtdKSx0LkZsb2F0MzJBcnJheT1Tay5taXNjZXZhbC5idWlsZENsYXNzKHQsKGZ1bmN0aW9uKG4sdCl7dC5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHQpe24udj1cXFwibnVtYmVyXFxcIj09dHlwZW9mIHQ/bmV3IEZsb2F0MzJBcnJheSh0KTpuZXcgRmxvYXQzMkFycmF5KFNrLmZmaS5yZW1hcFRvSnModCkpfSkpLHQuX19yZXByX189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obil7Zm9yKHZhciB0PVtdLGU9MDtlPG4udi5sZW5ndGg7KytlKXQucHVzaChuLnZbZV0pO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXFxcIltcXFwiK3Quam9pbihcXFwiLCBcXFwiKStcXFwiXVxcXCIpfSkpfSksXFxcIkZsb2F0MzJBcnJheVxcXCIsW10pLHQuTWF0cml4NHg0PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3ModCwoZnVuY3Rpb24obix0KXt0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCl7bi52PW5ldyBGbG9hdDMyQXJyYXkoU2suZmZpLnJlbWFwVG9Kcyh0KSl9KSksdC5pZGVudGl0eT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXt2YXIgdD1uLnY7dFswXT0xLHRbMV09MCx0WzJdPTAsdFszXT0wLHRbNF09MCx0WzVdPTEsdFs2XT0wLHRbN109MCx0WzhdPTAsdFs5XT0wLHRbMTBdPTEsdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCx0WzE1XT0xfSkpLHQucGVyc3BlY3RpdmU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obix0LGUsaSxyKXt2YXIgdT1NYXRoLnRhbiguNSpNYXRoLlBJLVNrLmJ1aWx0aW4uYXNudW0kKHQpKk1hdGguUEkvMTgwKi41KSxhPVNrLmJ1aWx0aW4uYXNudW0kKGUpLG89U2suYnVpbHRpbi5hc251bSQoaSksbD1Tay5idWlsdGluLmFzbnVtJChyKSxjPTEvKG8tbCksZj1uLnY7ZlswXT11L2EsZlsxXT0wLGZbMl09MCxmWzNdPTAsZls0XT0wLGZbNV09dSxmWzZdPTAsZls3XT0wLGZbOF09MCxmWzldPTAsZlsxMF09KG8rbCkqYyxmWzExXT0tMSxmWzEyXT0wLGZbMTNdPTAsZlsxNF09bypsKmMqMixmWzE1XT0wfSkpLHQudHJhbnNsYXRlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4sdCl7dmFyIGU9bi52LGk9U2suZmZpLnJlbWFwVG9Kcyh0KTtlWzBdPTEsZVsxXT0wLGVbMl09MCxlWzNdPTAsZVs0XT0wLGVbNV09MSxlWzZdPTAsZVs3XT0wLGVbOF09MCxlWzldPTAsZVsxMF09MSxlWzExXT0wLGVbMTJdPWlbMF0sZVsxM109aVsxXSxlWzE0XT1pWzJdLGVbMTVdPTF9KSksdC5fX3JlcHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuKXtmb3IodmFyIHQ9W10sZT0wO2U8bi52Lmxlbmd0aDsrK2UpdC5wdXNoKG4udltlXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcXFwiW1xcXCIrdC5qb2luKFxcXCIsIFxcXCIpK1xcXCJdXFxcIil9KSl9KSxcXFwiTWF0cml4NHg0XFxcIixbXSksdH07XCIsXCJzcmMvbGliL3dlYmdsL21hdGguanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihlKXt2YXIgbj17fTtyZXR1cm4gbi5NYXQ0ND1Tay5taXNjZXZhbC5idWlsZENsYXNzKG4sKGZ1bmN0aW9uKGUsdCl7dC5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodC5sb2FkSWRlbnRpdHksW2VdKSxlLnN0YWNrPVtdfSkpLHQucHVzaD1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtlLnN0YWNrLnB1c2goZS5lbGVtZW50cy5zbGljZSgwKSl9KSksdC5wb3A9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSl7ZS5lbGVtZW50cz1lLnN0YWNrLnBvcCgpfSkpLHQubG9hZElkZW50aXR5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUpe2UuZWxlbWVudHM9WzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdfSkpLHQudHJhbnNmb3JtMz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLHQpe3ZhciBsPWUuZWxlbWVudHM7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLlZlYzMsW2xbMF0qdC54K2xbNF0qdC55K2xbOF0qdC56LGxbMV0qdC54K2xbNV0qdC55K2xbOV0qdC56LGxbMl0qdC54K2xbNl0qdC55K2xbMTBdKnQuel0pfSkpLHQuc2NhbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuLHQsbCl7cmV0dXJuIGUuZWxlbWVudHNbMF0qPW4sZS5lbGVtZW50c1sxXSo9bixlLmVsZW1lbnRzWzJdKj1uLGUuZWxlbWVudHNbM10qPW4sZS5lbGVtZW50c1s0XSo9dCxlLmVsZW1lbnRzWzVdKj10LGUuZWxlbWVudHNbNl0qPXQsZS5lbGVtZW50c1s3XSo9dCxlLmVsZW1lbnRzWzhdKj1sLGUuZWxlbWVudHNbOV0qPWwsZS5lbGVtZW50c1sxMF0qPWwsZS5lbGVtZW50c1sxMV0qPWwsZX0pKSx0LnRyYW5zbGF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLG4sdCxsKXtyZXR1cm4gZS5lbGVtZW50c1sxMl0rPWUuZWxlbWVudHNbMF0qbitlLmVsZW1lbnRzWzRdKnQrZS5lbGVtZW50c1s4XSpsLGUuZWxlbWVudHNbMTNdKz1lLmVsZW1lbnRzWzFdKm4rZS5lbGVtZW50c1s1XSp0K2UuZWxlbWVudHNbOV0qbCxlLmVsZW1lbnRzWzE0XSs9ZS5lbGVtZW50c1syXSpuK2UuZWxlbWVudHNbNl0qdCtlLmVsZW1lbnRzWzEwXSpsLGUuZWxlbWVudHNbMTVdKz1lLmVsZW1lbnRzWzNdKm4rZS5lbGVtZW50c1s3XSp0K2UuZWxlbWVudHNbMTFdKmwsZX0pKSx0LnJvdGF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLHQsbCxzLG0pe3ZhciBpLGEsYyx1LHIsZixvLGssUyx5LGIsdj1NYXRoLnNxcnQobCpsK3MqcyttKm0pLF89TWF0aC5zaW4odCpNYXRoLlBJLzE4MCksdz1NYXRoLmNvcyh0Kk1hdGguUEkvMTgwKTt2PjAmJihpPShsLz12KSpsLGE9KHMvPXYpKnMsYz0obS89dikqbSx1PWwqcyxyPXMqbSxmPW0qbCxvPWwqXyxrPXMqXyxTPW0qXyx5PTEtdywoYj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5NYXQ0NCkpLmVsZW1lbnRzWzBdPXkqaSt3LGIuZWxlbWVudHNbMV09eSp1LVMsYi5lbGVtZW50c1syXT15KmYrayxiLmVsZW1lbnRzWzNdPTAsYi5lbGVtZW50c1s0XT15KnUrUyxiLmVsZW1lbnRzWzVdPXkqYSt3LGIuZWxlbWVudHNbNl09eSpyLW8sYi5lbGVtZW50c1s3XT0wLGIuZWxlbWVudHNbOF09eSpmLWssYi5lbGVtZW50c1s5XT15KnIrbyxiLmVsZW1lbnRzWzEwXT15KmMrdyxiLmVsZW1lbnRzWzExXT0wLGIuZWxlbWVudHNbMTJdPTAsYi5lbGVtZW50c1sxM109MCxiLmVsZW1lbnRzWzE0XT0wLGIuZWxlbWVudHNbMTVdPTEsYj1iLm11bHRpcGx5KGUpLGUuZWxlbWVudHM9Yi5lbGVtZW50cyk7cmV0dXJuIGV9KSksdC5tdWx0aXBseT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLHQpe2Zvcih2YXIgbD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5NYXQ0NCkscz0wO3M8NDtzKyspbC5lbGVtZW50c1s0KnMrMF09ZS5lbGVtZW50c1s0KnMrMF0qdC5lbGVtZW50c1swXStlLmVsZW1lbnRzWzQqcysxXSp0LmVsZW1lbnRzWzRdK2UuZWxlbWVudHNbNCpzKzJdKnQuZWxlbWVudHNbOF0rZS5lbGVtZW50c1s0KnMrM10qdC5lbGVtZW50c1sxMl0sbC5lbGVtZW50c1s0KnMrMV09ZS5lbGVtZW50c1s0KnMrMF0qdC5lbGVtZW50c1sxXStlLmVsZW1lbnRzWzQqcysxXSp0LmVsZW1lbnRzWzVdK2UuZWxlbWVudHNbNCpzKzJdKnQuZWxlbWVudHNbOV0rZS5lbGVtZW50c1s0KnMrM10qdC5lbGVtZW50c1sxM10sbC5lbGVtZW50c1s0KnMrMl09ZS5lbGVtZW50c1s0KnMrMF0qdC5lbGVtZW50c1syXStlLmVsZW1lbnRzWzQqcysxXSp0LmVsZW1lbnRzWzZdK2UuZWxlbWVudHNbNCpzKzJdKnQuZWxlbWVudHNbMTBdK2UuZWxlbWVudHNbNCpzKzNdKnQuZWxlbWVudHNbMTRdLGwuZWxlbWVudHNbNCpzKzNdPWUuZWxlbWVudHNbNCpzKzBdKnQuZWxlbWVudHNbM10rZS5lbGVtZW50c1s0KnMrMV0qdC5lbGVtZW50c1s3XStlLmVsZW1lbnRzWzQqcysyXSp0LmVsZW1lbnRzWzExXStlLmVsZW1lbnRzWzQqcyszXSp0LmVsZW1lbnRzWzE1XTtyZXR1cm4gZS5lbGVtZW50cz1sLmVsZW1lbnRzLGV9KSksdC5sb29rQXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSx0LGwscyxtLGksYSxjLHUscil7dmFyIGY9W3QtbSxsLWkscy1hXSxvPU1hdGguc3FydChmWzBdKmZbMF0rZlsxXSpmWzFdK2ZbMl0qZlsyXSk7byYmKGZbMF0vPW8sZlsxXS89byxmWzJdLz1vKTt2YXIgaz1bYyx1LHJdLFM9W107U1swXT1rWzFdKmZbMl0ta1syXSpmWzFdLFNbMV09LWtbMF0qZlsyXStrWzJdKmZbMF0sU1syXT1rWzBdKmZbMV0ta1sxXSpmWzBdLGtbMF09ZlsxXSpTWzJdLWZbMl0qU1sxXSxrWzFdPS1mWzBdKlNbMl0rZlsyXSpTWzBdLGtbMl09ZlswXSpTWzFdLWZbMV0qU1swXSwobz1NYXRoLnNxcnQoU1swXSpTWzBdK1NbMV0qU1sxXStTWzJdKlNbMl0pKSYmKFNbMF0vPW8sU1sxXS89byxTWzJdLz1vKSwobz1NYXRoLnNxcnQoa1swXSprWzBdK2tbMV0qa1sxXStrWzJdKmtbMl0pKSYmKGtbMF0vPW8sa1sxXS89byxrWzJdLz1vKTt2YXIgeT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5NYXQ0NCk7cmV0dXJuIHkuZWxlbWVudHNbMF09U1swXSx5LmVsZW1lbnRzWzRdPVNbMV0seS5lbGVtZW50c1s4XT1TWzJdLHkuZWxlbWVudHNbMTJdPTAseS5lbGVtZW50c1sxXT1rWzBdLHkuZWxlbWVudHNbNV09a1sxXSx5LmVsZW1lbnRzWzldPWtbMl0seS5lbGVtZW50c1sxM109MCx5LmVsZW1lbnRzWzJdPWZbMF0seS5lbGVtZW50c1s2XT1mWzFdLHkuZWxlbWVudHNbMTBdPWZbMl0seS5lbGVtZW50c1sxNF09MCx5LmVsZW1lbnRzWzNdPTAseS5lbGVtZW50c1s3XT0wLHkuZWxlbWVudHNbMTFdPTAseS5lbGVtZW50c1sxNV09MSx5PXkubXVsdGlwbHkoZSksZS5lbGVtZW50cz15LmVsZW1lbnRzLGUudHJhbnNsYXRlKC10LC1sLC1zKSxlfSkpfSksXFxcIk1hdDQ0XFxcIixbXSksbi5NYXQzMz1Tay5taXNjZXZhbC5idWlsZENsYXNzKG4sKGZ1bmN0aW9uKGUsbil7bi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobi5sb2FkSWRlbnRpdHksW2VdKX0pKSxuLmxvYWRJZGVudGl0eT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlKXtlLmVsZW1lbnRzPVsxLDAsMCwwLDEsMCwwLDAsMV19KSl9KSxcXFwiTWF0MzNcXFwiLFtdKSxuLlZlYzM9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhuLChmdW5jdGlvbihlLHQpe3QuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSxuLHQsbCl7ZS54PW4sZS55PXQsZS56PWx9KSksdC5fX3N1Yl9fPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShuLlZlYzMsW2UueC10LngsZS55LXQueSxlLnotdC56XSl9KSl9KSxcXFwiVmVjM1xcXCIsW10pLG4uY3Jvc3M9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24oZSx0KXtyZXR1cm4gU2suYXNzZXJ0cy5hc3NlcnQoZSBpbnN0YW5jZW9mIG4uVmVjMyYmdCBpbnN0YW5jZW9mIG4uVmVjMyksU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4uVmVjMyxbZS55KnQuei1lLnoqdC55LGUueip0LngtZS54KnQueixlLngqdC55LWUueSp0LnhdKX0pKSxufTtcIixcInNyYy9saWIvd2ViZ2wvbWF0cml4NC5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKG4pe3ZhciByPXt9LHQ9bmV3IEZsb2F0MzJBcnJheSgzKSxhPW5ldyBGbG9hdDMyQXJyYXkoMyksdT1uZXcgRmxvYXQzMkFycmF5KDMpLGU9KG5ldyBGbG9hdDMyQXJyYXkoNCksbmV3IEZsb2F0MzJBcnJheSg0KSxuZXcgRmxvYXQzMkFycmF5KDQpLG5ldyBGbG9hdDMyQXJyYXkoMTYpLG5ldyBGbG9hdDMyQXJyYXkoMTYpLG5ldyBGbG9hdDMyQXJyYXkoMTYpLGZ1bmN0aW9uKG4scil7Zm9yKHZhciB0PTAsYT1yLmxlbmd0aCx1PTA7dTxhOysrdSl0Kz1yW3VdKnJbdV07aWYoKHQ9TWF0aC5zcXJ0KHQpKT4xZS01KWZvcih1PTA7dTxhOysrdSluW3VdPXJbdV0vdDtlbHNlIGZvcih1PTA7dTxhOysrdSluW3VdPTA7cmV0dXJuIG59KSxjcm9zcz1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIG5bMF09clsxXSp0WzJdLXJbMl0qdFsxXSxuWzFdPXJbMl0qdFswXS1yWzBdKnRbMl0sblsyXT1yWzBdKnRbMV0tclsxXSp0WzBdLG59LGRvdD1mdW5jdGlvbihuLHIpe3JldHVybiBuWzBdKnJbMF0rblsxXSpyWzFdK25bMl0qclsyXX07cmV0dXJuIHIubG9va0F0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4scixpLG8pe3ZhciB2PWEsZj11LGw9ZSh0LGZ1bmN0aW9uKG4scix0KXtmb3IodmFyIGE9ci5sZW5ndGgsdT0wO3U8YTsrK3Upblt1XT1yW3VdLXRbdV07cmV0dXJuIG59KHQsci52LGkudikpLGM9ZSh2LGNyb3NzKHYsby52LGwpKSx3PWNyb3NzKGYsbCxjKSxoPW4udjtyZXR1cm4gaFswXT1jWzBdLGhbMV09d1swXSxoWzJdPWxbMF0saFszXT0wLGhbNF09Y1sxXSxoWzVdPXdbMV0saFs2XT1sWzFdLGhbN109MCxoWzhdPWNbMl0saFs5XT13WzJdLGhbMTBdPWxbMl0saFsxMV09MCxoWzEyXT0tZG90KGMsci52KSxoWzEzXT0tZG90KHcsci52KSxoWzE0XT0tZG90KGwsci52KSxoWzE1XT0xLG59KSksci5wZXJzcGVjdGl2ZT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHIsdCxhLHUpe3ZhciBlPU1hdGgudGFuKC41Kk1hdGguUEktcipNYXRoLlBJLzE4MCouNSksaT0xLyhhLXUpLG89bi52O3JldHVybiBvWzBdPWUvdCxvWzFdPTAsb1syXT0wLG9bM109MCxvWzRdPTAsb1s1XT1lLG9bNl09MCxvWzddPTAsb1s4XT0wLG9bOV09MCxvWzEwXT0oYSt1KSppLG9bMTFdPS0xLG9bMTJdPTAsb1sxM109MCxvWzE0XT1hKnUqaSoyLG9bMTVdPTAsbn0pKSxyLnJvdGF0aW9uWT1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihuLHIpe3ZhciB0PW4udixhPU1hdGguY29zKHIqTWF0aC5QSS8xODApLHU9TWF0aC5zaW4ocipNYXRoLlBJLzE4MCk7cmV0dXJuIHRbMF09YSx0WzFdPTAsdFsyXT0tdSx0WzNdPTAsdFs0XT0wLHRbNV09MSx0WzZdPTAsdFs3XT0wLHRbOF09dSx0WzldPTAsdFsxMF09YSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsbn0pKSxyLmlkZW50aXR5PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4pe3ZhciByPW4udjtyZXR1cm4gclswXT0xLHJbMV09MCxyWzJdPTAsclszXT0wLHJbNF09MCxyWzVdPTEscls2XT0wLHJbN109MCxyWzhdPTAscls5XT0wLHJbMTBdPTEsclsxMV09MCxyWzEyXT0wLHJbMTNdPTAsclsxNF09MCxyWzE1XT0xLG59KSksci5tdWw9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24obixyLHQpe3ZhciBhPW4udix1PXIudixlPXQudixpPXVbMF0sbz11WzFdLHY9dVsyXSxmPXVbM10sbD11WzRdLGM9dVs1XSx3PXVbNl0saD11WzddLHk9dVs4XSxBPXVbOV0sRj11WzEwXSxiPXVbMTFdLGs9dVsxMl0sTT11WzEzXSxzPXVbMTRdLFM9dVsxNV0sST1lWzBdLFA9ZVsxXSxwPWVbMl0sZD1lWzNdLGc9ZVs0XSxtPWVbNV0scT1lWzZdLFk9ZVs3XSwkPWVbOF0saj1lWzldLHg9ZVsxMF0sej1lWzExXSxCPWVbMTJdLEM9ZVsxM10sRD1lWzE0XSxFPWVbMTVdO3JldHVybiBhWzBdPWkqSStvKmcrdiokK2YqQixhWzFdPWkqUCtvKm0rdipqK2YqQyxhWzJdPWkqcCtvKnErdip4K2YqRCxhWzNdPWkqZCtvKlkrdip6K2YqRSxhWzRdPWwqSStjKmcrdyokK2gqQixhWzVdPWwqUCtjKm0rdypqK2gqQyxhWzZdPWwqcCtjKnErdyp4K2gqRCxhWzddPWwqZCtjKlkrdyp6K2gqRSxhWzhdPXkqSStBKmcrRiokK2IqQixhWzldPXkqUCtBKm0rRipqK2IqQyxhWzEwXT15KnArQSpxK0YqeCtiKkQsYVsxMV09eSpkK0EqWStGKnorYipFLGFbMTJdPWsqSStNKmcrcyokK1MqQixhWzEzXT1rKlArTSptK3MqaitTKkMsYVsxNF09aypwK00qcStzKngrUypELGFbMTVdPWsqZCtNKlkrcyp6K1MqRSxufSkpLHIuaW52ZXJ0PW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4scil7dmFyIHQ9bi52LGE9ci52LHU9YVswXSxlPWFbMV0saT1hWzJdLG89YVszXSx2PWFbNF0sZj1hWzVdLGw9YVs2XSxjPWFbN10sdz1hWzhdLGg9YVs5XSx5PWFbMTBdLEE9YVsxMV0sRj1hWzEyXSxiPWFbMTNdLGs9YVsxNF0sTT1hWzE1XSxzPXkqTSxTPWsqQSxJPWwqTSxQPWsqYyxwPWwqQSxkPXkqYyxnPWkqTSxtPWsqbyxxPWkqQSxZPXkqbywkPWkqYyxqPWwqbyx4PXcqYix6PUYqaCxCPXYqYixDPUYqZixEPXYqaCxFPXcqZixHPXUqYixIPUYqZSxKPXUqaCxLPXcqZSxMPXUqZixOPXYqZSxPPXMqZitQKmgrcCpiLShTKmYrSSpoK2QqYiksUT1TKmUrZypoK1kqYi0ocyplK20qaCtxKmIpLFI9SSplK20qZiskKmItKFAqZStnKmYraipiKSxUPWQqZStxKmYraipoLShwKmUrWSpmKyQqaCksVT0xLyh1Kk8rdipRK3cqUitGKlQpO3JldHVybiB0WzBdPVUqTyx0WzFdPVUqUSx0WzJdPVUqUix0WzNdPVUqVCx0WzRdPVUqKFMqditJKncrZCpGLShzKnYrUCp3K3AqRikpLHRbNV09VSoocyp1K20qdytxKkYtKFMqdStnKncrWSpGKSksdFs2XT1VKihQKnUrZyp2K2oqRi0oSSp1K20qdiskKkYpKSx0WzddPVUqKHAqdStZKnYrJCp3LShkKnUrcSp2K2oqdykpLHRbOF09VSooeCpjK0MqQStEKk0tKHoqYytCKkErRSpNKSksdFs5XT1VKih6Km8rRypBK0sqTS0oeCpvK0gqQStKKk0pKSx0WzEwXT1VKihCKm8rSCpjK0wqTS0oQypvK0cqYytOKk0pKSx0WzExXT1VKihFKm8rSipjK04qQS0oRCpvK0sqYytMKkEpKSx0WzEyXT1VKihCKnkrRSprK3oqbC0oRCprK3gqbCtDKnkpKSx0WzEzXT1VKihKKmsreCppK0gqeS0oRyp5K0sqayt6KmkpKSx0WzE0XT1VKihHKmwrTiprK0MqaS0oTCprK0IqaStIKmwpKSx0WzE1XT1VKihMKnkrRCppK0sqbC0oSipsK04qeStFKmkpKSxufSkpLHIudHJhbnNwb3NlPW5ldyBTay5idWlsdGluLmZ1bmMoKGZ1bmN0aW9uKG4scil7Zm9yKHZhciB0PW4udixhPXIudix1PTA7dTw0OysrdSlmb3IodmFyIGU9MDtlPDQ7KytlKXRbNCp1K2VdPWFbNCplK3VdO3JldHVybiB0fSkpLHJ9O1wiLFwic3JjL2xpYi93ZWJnbC9tb2RlbHMuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbih0KXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFxcXCJ3ZWJnbFxcXCIsITEsITApLChlPT57Y29uc3Qgbj1lLiRkO3ZhciByPXt9LEJ1ZmZlcj1mdW5jdGlvbih0LGUpe3ZhciByPWV8fG4uQVJSQVlfQlVGRkVSLGk9bi5jcmVhdGVCdWZmZXIoKTtpZih0aGlzLnRhcmdldD1yLHRoaXMuYnVmPWksdGhpcy5zZXQodCksdGhpcy5udW1Db21wb25lbnRzXz10Lm51bUNvbXBvbmVudHMsdGhpcy5udW1FbGVtZW50c189dC5udW1FbGVtZW50cyx0aGlzLnRvdGFsQ29tcG9uZW50c189dGhpcy5udW1Db21wb25lbnRzXyp0aGlzLm51bUVsZW1lbnRzXyx0LmJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSl0aGlzLnR5cGVfPW4uRkxPQVQ7ZWxzZSBpZih0LmJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdGhpcy50eXBlXz1uLlVOU0lHTkVEX0JZVEU7ZWxzZSBpZih0LmJ1ZmZlciBpbnN0YW5jZW9mIEludDhBcnJheSl0aGlzLnR5cGVfPW4uX0JZVEU7ZWxzZSBpZih0LmJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KXRoaXMudHlwZV89bi5VTlNJR05FRF9TSE9SVDtlbHNle2lmKCEodC5idWZmZXIgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSl0aHJvd1xcXCJ1bmhhbmRsZWQgdHlwZTpcXFwiK3R5cGVvZiB0LmJ1ZmZlcjt0aGlzLnR5cGVfPW4uU0hPUlR9fTtyZXR1cm4gQnVmZmVyLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCl7bi5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LHRoaXMuYnVmKSxuLmJ1ZmZlckRhdGEodGhpcy50YXJnZXQsdC5idWZmZXIsbi5TVEFUSUNfRFJBVyl9LEJ1ZmZlci5wcm90b3R5cGUudHlwZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR5cGVffSxCdWZmZXIucHJvdG90eXBlLm51bUNvbXBvbmVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1Db21wb25lbnRzX30sQnVmZmVyLnByb3RvdHlwZS5udW1FbGVtZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bUVsZW1lbnRzX30sQnVmZmVyLnByb3RvdHlwZS50b3RhbENvbXBvbmVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b3RhbENvbXBvbmVudHNffSxCdWZmZXIucHJvdG90eXBlLmJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1Zn0sQnVmZmVyLnByb3RvdHlwZS5zdHJpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sQnVmZmVyLnByb3RvdHlwZS5vZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sci5Nb2RlbD1Tay5taXNjZXZhbC5idWlsZENsYXNzKHIsKGZ1bmN0aW9uKGUscil7ci5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKChmdW5jdGlvbihlLHIsaSxmKXtlLmJ1ZmZlcnM9e307dmFyIHNldEJ1ZmZlcj1mdW5jdGlvbih0LHIpe3ZhciBpPVxcXCJpbmRpY2VzXFxcIj09dD9uLkVMRU1FTlRfQVJSQVlfQlVGRkVSOm4uQVJSQVlfQlVGRkVSO2xldCBmPWUuYnVmZmVyc1t0XTtmP2Yuc2V0KHIpOmY9bmV3IEJ1ZmZlcihyLGkpLGUuYnVmZmVyc1t0XT1mfTtmb3IodCBpbiBpKXNldEJ1ZmZlcih0LGlbdF0pO3ZhciBvPXt9LHM9MDtmb3IodmFyIHUgaW4gZilvW3VdPXMrKztlLm1vZGU9bi5UUklBTkdMRVMsZS50ZXh0dXJlcz1mLnYsZS50ZXh0dXJlVW5pdHM9byxlLnNoYWRlcj1yfSkpLHIuZHJhd1ByZXA9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24odCxlKXt2YXIgcj10LnNoYWRlcixpPXQuYnVmZmVycyxmPXQudGV4dHVyZXM7Zm9yKHZhciBvIGluIGU9U2suZmZpLnJlbWFwVG9KcyhlKSxTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoci51c2UsW3JdKSxpKXt2YXIgcz1pW29dO2lmKFxcXCJpbmRpY2VzXFxcIj09byluLmJpbmRCdWZmZXIobi5FTEVNRU5UX0FSUkFZX0JVRkZFUixzLmJ1ZmZlcigpKTtlbHNle3ZhciB1PXIuYXR0cmliW29dO3UmJnUocyl9fWZvcih2YXIgYSBpbiBmKXt2YXIgbT10LnRleHR1cmVVbml0c1thXTtyLnNldFVuaWZvcm0kaW1wbChyLGYsbSksZlthXS5iaW5kVG9Vbml0KG0pfWZvcih2YXIgcCBpbiBlKXIuc2V0VW5pZm9ybSRpbXBsKHIscCxlW3BdKX0pKSxyLmRyYXc9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24odCxlLHIpe3ZhciBpPXQuc2hhZGVyO2U9U2suZmZpLnJlbWFwVG9KcyhlKTtmb3IobGV0IG4gaW4gZSlpLnNldFVuaWZvcm0kaW1wbChpLG4sZVtuXSk7aWYocilmb3IodmFyIGYgaW4gcil7dmFyIG89dC50ZXh0dXJlVW5pdHNbZl07aS5zZXRVbmlmb3JtJGltcGwoaSxmLG8pLHJbZl0uYmluZFRvVW5pdChvKX12YXIgcz10LmJ1ZmZlcnM7bi5kcmF3RWxlbWVudHModC5tb2RlLHMuaW5kaWNlcy50b3RhbENvbXBvbmVudHMoKSxuLlVOU0lHTkVEX1NIT1JULDApfSkpfSksXFxcIk1vZGVsXFxcIixbXSkscn0pKX07XCIsXCJzcmMvbGliL3dlYmdsL3ByaW1pdGl2ZXMuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbih0KXt2YXIgbj17fSxBdHRyaWJCdWZmZXI9ZnVuY3Rpb24odCxuLGUpe2U9ZXx8XFxcIkZsb2F0MzJBcnJheVxcXCI7dmFyIHI9d2luZG93W2VdO24ubGVuZ3RoPyh0aGlzLmJ1ZmZlcj1uZXcgcihuKSxuPXRoaXMuYnVmZmVyLmxlbmd0aC90LHRoaXMuY3Vyc29yPW4pOih0aGlzLmJ1ZmZlcj1uZXcgcih0Km4pLHRoaXMuY3Vyc29yPTApLHRoaXMubnVtQ29tcG9uZW50cz10LHRoaXMubnVtRWxlbWVudHM9bix0aGlzLnR5cGU9ZX07cmV0dXJuIEF0dHJpYkJ1ZmZlci5wcm90b3R5cGUuc3RyaWRlPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LEF0dHJpYkJ1ZmZlci5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDB9LEF0dHJpYkJ1ZmZlci5wcm90b3R5cGUuZ2V0RWxlbWVudD1mdW5jdGlvbih0KXtmb3IodmFyIG49dCp0aGlzLm51bUNvbXBvbmVudHMsZT1bXSxyPTA7cjx0aGlzLm51bUNvbXBvbmVudHM7KytyKWUucHVzaCh0aGlzLmJ1ZmZlcltuK3JdKTtyZXR1cm4gZX0sQXR0cmliQnVmZmVyLnByb3RvdHlwZS5zZXRFbGVtZW50PWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlPXQqdGhpcy5udW1Db21wb25lbnRzLHI9MDtyPHRoaXMubnVtQ29tcG9uZW50czsrK3IpdGhpcy5idWZmZXJbZStyXT1uW3JdfSxBdHRyaWJCdWZmZXIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEF0dHJpYkJ1ZmZlcih0aGlzLm51bUNvbXBvbmVudHMsdGhpcy5udW1FbGVtZW50cyx0aGlzLnR5cGUpO3JldHVybiB0LnB1c2hBcnJheSh0aGlzKSx0fSxBdHRyaWJCdWZmZXIucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCl7dGhpcy5zZXRFbGVtZW50KHRoaXMuY3Vyc29yKyssdCl9LEF0dHJpYkJ1ZmZlci5wcm90b3R5cGUucHVzaEFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0wO248dC5udW1FbGVtZW50czsrK24pdGhpcy5wdXNoKHQuZ2V0RWxlbWVudChuKSl9LEF0dHJpYkJ1ZmZlci5wcm90b3R5cGUucHVzaEFycmF5V2l0aE9mZnNldD1mdW5jdGlvbih0LG4pe2Zvcih2YXIgZT0wO2U8dC5udW1FbGVtZW50czsrK2Upe2Zvcih2YXIgcj10LmdldEVsZW1lbnQoZSksbz0wO288bi5sZW5ndGg7KytvKXJbb10rPW5bb107dGhpcy5wdXNoKHIpfX0sQXR0cmliQnVmZmVyLnByb3RvdHlwZS5jb21wdXRlRXh0ZW50cz1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm51bUVsZW1lbnRzLG49dGhpcy5udW1Db21wb25lbnRzLGU9dGhpcy5nZXRFbGVtZW50KDApLHI9dGhpcy5nZXRFbGVtZW50KDApLG89MTtvPHQ7KytvKWZvcih2YXIgcz10aGlzLmdldEVsZW1lbnQobyksdT0wO3U8bjsrK3UpZVt1XT1NYXRoLm1pbihlW3VdLHNbdV0pLHJbdV09TWF0aC5tYXgoclt1XSxzW3VdKTtyZXR1cm57bWluOmUsbWF4OnJ9fSxuLmNyZWF0ZUN1YmU9bmV3IFNrLmJ1aWx0aW4uZnVuYygoZnVuY3Rpb24odCl7Zm9yKHZhciBuPVtbMyw3LDUsMV0sWzAsNCw2LDJdLFs2LDcsMywyXSxbMCwxLDUsNF0sWzUsNyw2LDRdLFsyLDMsMSwwXV0sZT10LzIscj1bWy1lLC1lLC1lXSxbK2UsLWUsLWVdLFstZSwrZSwtZV0sWytlLCtlLC1lXSxbLWUsLWUsK2VdLFsrZSwtZSwrZV0sWy1lLCtlLCtlXSxbK2UsK2UsK2VdXSxvPVtbMSwwLDBdLFstMSwwLDBdLFswLDEsMF0sWzAsLTEsMF0sWzAsMCwxXSxbMCwwLC0xXV0scz1bWzAsMF0sWzEsMF0sWzEsMV0sWzAsMV1dLHU9bmV3IEF0dHJpYkJ1ZmZlcigzLDI0KSxpPW5ldyBBdHRyaWJCdWZmZXIoMywyNCksaD1uZXcgQXR0cmliQnVmZmVyKDIsMjQpLHA9bmV3IEF0dHJpYkJ1ZmZlcigzLDEyLFxcXCJVaW50MTZBcnJheVxcXCIpLG09MDttPDY7KyttKXtmb3IodmFyIGY9blttXSxhPTA7YTw0OysrYSl7dmFyIGw9cltmW2FdXSxjPW9bbV0seT1zW2FdO3UucHVzaChsKSxpLnB1c2goYyksaC5wdXNoKHkpfXZhciB2PTQqbTtwLnB1c2goW3YrMCx2KzEsdisyXSkscC5wdXNoKFt2KzAsdisyLHYrM10pfXJldHVybntwb3NpdGlvbjp1LG5vcm1hbDppLHRleENvb3JkOmgsaW5kaWNlczpwfX0pKSxufTtcIn19IiwiKGZ1bmN0aW9uKCl7LypcbiB1bmljb2RlX2hhY2suanNcbiAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxMiAgTWFyY2VsbyBHaWJzb24gZGUgQ2FzdHJvIEdvbsOnYWx2ZXMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgICBDb3B5aW5nIGFuZCBkaXN0cmlidXRpb24gb2YgdGhpcyBmaWxlLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICAgIGFyZSBwZXJtaXR0ZWQgaW4gYW55IG1lZGl1bSB3aXRob3V0IHJveWFsdHkgcHJvdmlkZWQgdGhlIGNvcHlyaWdodFxuICAgIG5vdGljZSBhbmQgdGhpcyBub3RpY2UgYXJlIHByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBvZmZlcmVkIGFzLWlzLFxuICAgIHdpdGhvdXQgYW55IHdhcnJhbnR5LlxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgJGpzY29tcD0kanNjb21wfHx7fTskanNjb21wLnNjb3BlPXt9OyRqc2NvbXAuQVNTVU1FX0VTNT0hMTskanNjb21wLkFTU1VNRV9OT19OQVRJVkVfTUFQPSExOyRqc2NvbXAuQVNTVU1FX05PX05BVElWRV9TRVQ9ITE7JGpzY29tcC5TSU1QTEVfRlJPVU5EX1BPTFlGSUxMPSExOyRqc2NvbXAuSVNPTEFURV9QT0xZRklMTFM9ITE7JGpzY29tcC5GT1JDRV9QT0xZRklMTF9QUk9NSVNFPSExOyRqc2NvbXAuRk9SQ0VfUE9MWUZJTExfUFJPTUlTRV9XSEVOX05PX1VOSEFORExFRF9SRUpFQ1RJT049ITE7JGpzY29tcC5kZWZpbmVQcm9wZXJ0eT0kanNjb21wLkFTU1VNRV9FUzV8fFwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihGLFAsYil7aWYoRj09QXJyYXkucHJvdG90eXBlfHxGPT1PYmplY3QucHJvdG90eXBlKXJldHVybiBGO0ZbUF09Yi52YWx1ZTtyZXR1cm4gRn07XG4kanNjb21wLmdldEdsb2JhbD1mdW5jdGlvbihGKXtGPVtcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcyYmZ2xvYmFsVGhpcyxGLFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyxcIm9iamVjdFwiPT10eXBlb2Ygc2VsZiYmc2VsZixcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsJiZnbG9iYWxdO2Zvcih2YXIgUD0wO1A8Ri5sZW5ndGg7KytQKXt2YXIgYj1GW1BdO2lmKGImJmIuTWF0aD09TWF0aClyZXR1cm4gYn10aHJvdyBFcnJvcihcIkNhbm5vdCBmaW5kIGdsb2JhbCBvYmplY3RcIik7fTskanNjb21wLmdsb2JhbD0kanNjb21wLmdldEdsb2JhbCh0aGlzKTskanNjb21wLklTX1NZTUJPTF9OQVRJVkU9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09PXR5cGVvZiBTeW1ib2woXCJ4XCIpOyRqc2NvbXAuVFJVU1RfRVM2X1BPTFlGSUxMUz0hJGpzY29tcC5JU09MQVRFX1BPTFlGSUxMU3x8JGpzY29tcC5JU19TWU1CT0xfTkFUSVZFOyRqc2NvbXAucG9seWZpbGxzPXt9O1xuJGpzY29tcC5wcm9wZXJ0eVRvUG9seWZpbGxTeW1ib2w9e307JGpzY29tcC5QT0xZRklMTF9QUkVGSVg9XCIkanNjcCRcIjt2YXIgJGpzY29tcCRsb29rdXBQb2x5ZmlsbGVkVmFsdWU9ZnVuY3Rpb24oRixQKXt2YXIgYj0kanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbFtQXTtpZihudWxsPT1iKXJldHVybiBGW1BdO2I9RltiXTtyZXR1cm4gdm9pZCAwIT09Yj9iOkZbUF19OyRqc2NvbXAucG9seWZpbGw9ZnVuY3Rpb24oRixQLGIsZSl7UCYmKCRqc2NvbXAuSVNPTEFURV9QT0xZRklMTFM/JGpzY29tcC5wb2x5ZmlsbElzb2xhdGVkKEYsUCxiLGUpOiRqc2NvbXAucG9seWZpbGxVbmlzb2xhdGVkKEYsUCxiLGUpKX07XG4kanNjb21wLnBvbHlmaWxsVW5pc29sYXRlZD1mdW5jdGlvbihGLFAsYixlKXtiPSRqc2NvbXAuZ2xvYmFsO0Y9Ri5zcGxpdChcIi5cIik7Zm9yKGU9MDtlPEYubGVuZ3RoLTE7ZSsrKXt2YXIgZD1GW2VdO2lmKCEoZCBpbiBiKSlyZXR1cm47Yj1iW2RdfUY9RltGLmxlbmd0aC0xXTtlPWJbRl07UD1QKGUpO1AhPWUmJm51bGwhPVAmJiRqc2NvbXAuZGVmaW5lUHJvcGVydHkoYixGLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6UH0pfTtcbiRqc2NvbXAucG9seWZpbGxJc29sYXRlZD1mdW5jdGlvbihGLFAsYixlKXt2YXIgZD1GLnNwbGl0KFwiLlwiKTtGPTE9PT1kLmxlbmd0aDtlPWRbMF07ZT0hRiYmZSBpbiAkanNjb21wLnBvbHlmaWxscz8kanNjb21wLnBvbHlmaWxsczokanNjb21wLmdsb2JhbDtmb3IodmFyIGY9MDtmPGQubGVuZ3RoLTE7ZisrKXt2YXIgaD1kW2ZdO2lmKCEoaCBpbiBlKSlyZXR1cm47ZT1lW2hdfWQ9ZFtkLmxlbmd0aC0xXTtiPSRqc2NvbXAuSVNfU1lNQk9MX05BVElWRSYmXCJlczZcIj09PWI/ZVtkXTpudWxsO1A9UChiKTtudWxsIT1QJiYoRj8kanNjb21wLmRlZmluZVByb3BlcnR5KCRqc2NvbXAucG9seWZpbGxzLGQse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpQfSk6UCE9PWImJih2b2lkIDA9PT0kanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbFtkXSYmKCRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW2RdPSRqc2NvbXAuSVNfU1lNQk9MX05BVElWRT8kanNjb21wLmdsb2JhbC5TeW1ib2woZCk6XG4kanNjb21wLlBPTFlGSUxMX1BSRUZJWCtkKSwkanNjb21wLmRlZmluZVByb3BlcnR5KGUsJGpzY29tcC5wcm9wZXJ0eVRvUG9seWZpbGxTeW1ib2xbZF0se2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpQfSkpKX07JGpzY29tcC5wb2x5ZmlsbChcIkFycmF5LnByb3RvdHlwZS5mbGF0XCIsZnVuY3Rpb24oRil7cmV0dXJuIEY/RjpmdW5jdGlvbihQKXtQPXZvaWQgMD09PVA/MTpQO2Zvcih2YXIgYj1bXSxlPTA7ZTx0aGlzLmxlbmd0aDtlKyspe3ZhciBkPXRoaXNbZV07QXJyYXkuaXNBcnJheShkKSYmMDxQPyhkPUFycmF5LnByb3RvdHlwZS5mbGF0LmNhbGwoZCxQLTEpLGIucHVzaC5hcHBseShiLGQpKTpiLnB1c2goZCl9cmV0dXJuIGJ9fSxcImVzOVwiLFwiZXM1XCIpOyRqc2NvbXAuYXJyYXlJdGVyYXRvckltcGw9ZnVuY3Rpb24oRil7dmFyIFA9MDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gUDxGLmxlbmd0aD97ZG9uZTohMSx2YWx1ZTpGW1ArK119Ontkb25lOiEwfX19O1xuJGpzY29tcC5hcnJheUl0ZXJhdG9yPWZ1bmN0aW9uKEYpe3JldHVybntuZXh0OiRqc2NvbXAuYXJyYXlJdGVyYXRvckltcGwoRil9fTskanNjb21wLmluaXRTeW1ib2w9ZnVuY3Rpb24oKXt9OyRqc2NvbXAuaXRlcmF0b3JQcm90b3R5cGU9ZnVuY3Rpb24oRil7Rj17bmV4dDpGfTtGW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307cmV0dXJuIEZ9O1xuJGpzY29tcC5wb2x5ZmlsbChcIlN0cmluZy5wcm90b3R5cGUubWF0Y2hBbGxcIixmdW5jdGlvbihGKXtyZXR1cm4gRj9GOmZ1bmN0aW9uKFApe2lmKFAgaW5zdGFuY2VvZiBSZWdFeHAmJiFQLmdsb2JhbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVnRXhwIHBhc3NlZCBpbnRvIFN0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwoKSBtdXN0IGhhdmUgZ2xvYmFsIHRhZy5cIik7dmFyIGI9bmV3IFJlZ0V4cChQLFAgaW5zdGFuY2VvZiBSZWdFeHA/dm9pZCAwOlwiZ1wiKSxlPXRoaXMsZD0hMSxmPXtuZXh0OmZ1bmN0aW9uKCl7dmFyIGg9e30scD1iLmxhc3RJbmRleDtpZihkKXJldHVybnt2YWx1ZTp2b2lkIDAsZG9uZTohMH07dmFyIGc9Yi5leGVjKGUpO2lmKCFnKXJldHVybiBkPSEwLHt2YWx1ZTp2b2lkIDAsZG9uZTohMH07Yi5sYXN0SW5kZXg9PT1wJiYoYi5sYXN0SW5kZXgrPTEpO2gudmFsdWU9ZztoLmRvbmU9ITE7cmV0dXJuIGh9fTtmW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gZn07XG5yZXR1cm4gZn19LFwiZXNfMjAyMFwiLFwiZXMzXCIpOyRqc2NvbXAucG9seWZpbGwoXCJBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcIixmdW5jdGlvbihGKXtyZXR1cm4gRj9GOmZ1bmN0aW9uKFAsYil7dmFyIGU9dGhpcztlIGluc3RhbmNlb2YgU3RyaW5nJiYoZT1TdHJpbmcoZSkpO3ZhciBkPWUubGVuZ3RoO2I9Ynx8MDtmb3IoMD5iJiYoYj1NYXRoLm1heChiK2QsMCkpO2I8ZDtiKyspe3ZhciBmPWVbYl07aWYoZj09PVB8fE9iamVjdC5pcyhmLFApKXJldHVybiEwfXJldHVybiExfX0sXCJlczdcIixcImVzM1wiKTskanNjb21wLm93bnM9ZnVuY3Rpb24oRixQKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEYsUCl9O1xuJGpzY29tcC5wb2x5ZmlsbChcIk9iamVjdC5lbnRyaWVzXCIsZnVuY3Rpb24oRil7cmV0dXJuIEY/RjpmdW5jdGlvbihQKXt2YXIgYj1bXSxlO2ZvcihlIGluIFApJGpzY29tcC5vd25zKFAsZSkmJmIucHVzaChbZSxQW2VdXSk7cmV0dXJuIGJ9fSxcImVzOFwiLFwiZXMzXCIpO1xuJGpzY29tcC5wb2x5ZmlsbChcIk9iamVjdC5mcm9tRW50cmllc1wiLGZ1bmN0aW9uKEYpe3JldHVybiBGP0Y6ZnVuY3Rpb24oUCl7dmFyIGI9e307aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gUCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlwiK1ArXCIgaXMgbm90IGl0ZXJhYmxlXCIpO1A9UFtTeW1ib2wuaXRlcmF0b3JdLmNhbGwoUCk7Zm9yKHZhciBlPVAubmV4dCgpOyFlLmRvbmU7ZT1QLm5leHQoKSl7ZT1lLnZhbHVlO2lmKE9iamVjdChlKSE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhYmxlIGZvciBmcm9tRW50cmllcyBzaG91bGQgeWllbGQgb2JqZWN0c1wiKTtiW2VbMF1dPWVbMV19cmV0dXJuIGJ9fSxcImVzXzIwMTlcIixcImVzM1wiKTtcbiRqc2NvbXAuY2hlY2tTdHJpbmdBcmdzPWZ1bmN0aW9uKEYsUCxiKXtpZihudWxsPT1GKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgJ3RoaXMnIHZhbHVlIGZvciBTdHJpbmcucHJvdG90eXBlLlwiK2IrXCIgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWRcIik7aWYoUCBpbnN0YW5jZW9mIFJlZ0V4cCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmlyc3QgYXJndW1lbnQgdG8gU3RyaW5nLnByb3RvdHlwZS5cIitiK1wiIG11c3Qgbm90IGJlIGEgcmVndWxhciBleHByZXNzaW9uXCIpO3JldHVybiBGK1wiXCJ9OyRqc2NvbXAuc3RyaW5nUGFkZGluZz1mdW5jdGlvbihGLFApe0Y9dm9pZCAwIT09Rj9TdHJpbmcoRik6XCIgXCI7cmV0dXJuIDA8UCYmRj9GLnJlcGVhdChNYXRoLmNlaWwoUC9GLmxlbmd0aCkpLnN1YnN0cmluZygwLFApOlwiXCJ9O1xuJGpzY29tcC5wb2x5ZmlsbChcIlN0cmluZy5wcm90b3R5cGUucGFkU3RhcnRcIixmdW5jdGlvbihGKXtyZXR1cm4gRj9GOmZ1bmN0aW9uKFAsYil7dmFyIGU9JGpzY29tcC5jaGVja1N0cmluZ0FyZ3ModGhpcyxudWxsLFwicGFkU3RhcnRcIik7cmV0dXJuICRqc2NvbXAuc3RyaW5nUGFkZGluZyhiLFAtZS5sZW5ndGgpK2V9fSxcImVzOFwiLFwiZXMzXCIpOyRqc2NvbXAucG9seWZpbGwoXCJPYmplY3QudmFsdWVzXCIsZnVuY3Rpb24oRil7cmV0dXJuIEY/RjpmdW5jdGlvbihQKXt2YXIgYj1bXSxlO2ZvcihlIGluIFApJGpzY29tcC5vd25zKFAsZSkmJmIucHVzaChQW2VdKTtyZXR1cm4gYn19LFwiZXM4XCIsXCJlczNcIik7XG4kanNjb21wLml0ZXJhdG9yRnJvbUFycmF5PWZ1bmN0aW9uKEYsUCl7RiBpbnN0YW5jZW9mIFN0cmluZyYmKEYrPVwiXCIpO3ZhciBiPTAsZT0hMSxkPXtuZXh0OmZ1bmN0aW9uKCl7aWYoIWUmJmI8Ri5sZW5ndGgpe3ZhciBmPWIrKztyZXR1cm57dmFsdWU6UChmLEZbZl0pLGRvbmU6ITF9fWU9ITA7cmV0dXJue2RvbmU6ITAsdmFsdWU6dm9pZCAwfX19O2RbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiBkfTtyZXR1cm4gZH07JGpzY29tcC5wb2x5ZmlsbChcIkFycmF5LnByb3RvdHlwZS52YWx1ZXNcIixmdW5jdGlvbihGKXtyZXR1cm4gRj9GOmZ1bmN0aW9uKCl7cmV0dXJuICRqc2NvbXAuaXRlcmF0b3JGcm9tQXJyYXkodGhpcyxmdW5jdGlvbihQLGIpe3JldHVybiBifSl9fSxcImVzOFwiLFwiZXMzXCIpO1xuKGZ1bmN0aW9uKEYpe2Z1bmN0aW9uIFAoZSl7aWYoYltlXSlyZXR1cm4gYltlXS5leHBvcnRzO3ZhciBkPWJbZV09e2k6ZSxsOiExLGV4cG9ydHM6e319O0ZbZV0uY2FsbChkLmV4cG9ydHMsZCxkLmV4cG9ydHMsUCk7ZC5sPSEwO3JldHVybiBkLmV4cG9ydHN9dmFyIGI9e307UC5tPUY7UC5jPWI7UC5kPWZ1bmN0aW9uKGUsZCxmKXtQLm8oZSxkKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsZCx7ZW51bWVyYWJsZTohMCxnZXQ6Zn0pfTtQLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O1AudD1mdW5jdGlvbihlLGQpe2QmMSYmKGU9UChlKSk7aWYoZCY4fHxkJjQmJlwib2JqZWN0XCI9PT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO1xudmFyIGY9T2JqZWN0LmNyZWF0ZShudWxsKTtQLnIoZik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pO2lmKGQmMiYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBoIGluIGUpUC5kKGYsaCxmdW5jdGlvbihwKXtyZXR1cm4gZVtwXX0uYmluZChudWxsLGgpKTtyZXR1cm4gZn07UC5uPWZ1bmN0aW9uKGUpe3ZhciBkPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlW1wiZGVmYXVsdFwiXX06ZnVuY3Rpb24oKXtyZXR1cm4gZX07UC5kKGQsXCJhXCIsZCk7cmV0dXJuIGR9O1Aubz1mdW5jdGlvbihlLGQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxkKX07UC5wPVwiXCI7cmV0dXJuIFAoUC5zPTEpfSkoW2Z1bmN0aW9uKEYsUCl7UD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtQPVB8fChuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSkoKX1jYXRjaChiKXtcIm9iamVjdFwiPT09XG50eXBlb2Ygd2luZG93JiYoUD13aW5kb3cpfUYuZXhwb3J0cz1QfSxmdW5jdGlvbihGLFAsYil7YigyKTtTay5nbG9iYWwuc3RyZnRpbWU9YigzKTtiKDQpO2IoNik7Yig3KTtiKDkpO2IoMTApO2IoMTEpO2IoMTIpO2IoMTMpO2IoMTQpO2IoMTUpO2IoMTYpO2IoMTcpO2IoMTgpO1tTay5idWlsdGluLm9iamVjdCxTay5idWlsdGluLnR5cGVdLmZvckVhY2goZT0+e1NrLmFic3RyLnNldFVwU2xvdHMoZSk7U2suYWJzdHIuc2V0VXBNZXRob2RzKGUpO1NrLmFic3RyLnNldFVwR2V0U2V0cyhlKTtTay5hYnN0ci5zZXRVcENsYXNzTWV0aG9kcyhlKX0pO2IoMTkpO2IoMjApO2IoMjEpO1tTay5idWlsdGluLnN0cixTay5idWlsdGluLm5vbmUsU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZCxTay5idWlsdGluLm9iamVjdF0uZm9yRWFjaChlPT57ZT1lLnByb3RvdHlwZTtlLl9fZG9jX189ZS5oYXNPd25Qcm9wZXJ0eShcInRwJGRvY1wiKT9uZXcgU2suYnVpbHRpbi5zdHIoZS50cCRkb2MpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pO1xuYigyMik7YigyMyk7YigyNCk7YigyNSk7YigyNik7YigyNyk7YigyOCk7YigyOSk7YigzMSk7YigzMik7YigzMyk7YigzNCk7YigzNSk7YigzNik7YigzNyk7YigzOCk7YigzOSk7Yig0MCk7Yig0MSk7Yig0Mik7Yig0Myk7Yig0NCk7Yig0NSk7Yig0Nik7Yig0Nyk7Yig0OCk7Yig0OSk7Yig1MCk7Yig1MSk7Yig1Mik7Yig1Myk7Yig2Nik7Yig1NCk7Yig1NSk7Yig1Nik7Yig1Nyk7Yig1OCk7Yig1OSk7Yig2MCk7Yig2MSk7Yig2Mik7Yig2Myk7Yig2NCk7Yig2NSl9LGZ1bmN0aW9uKEYsUCxiKXsoZnVuY3Rpb24oZSl7dmFyIGQ9e2J1aWxkOntnaXRoYXNoOlwiMzk5YWE4ZDA1MDliMTAyMjU2MmYyMzdmMWQyMTkxOTc4Mjk0M2I0N1wiLGRhdGU6XCIyMDI0LTAzLTA0VDE1OjA2OjEyLjc3N1pcIn19O2QuZ2xvYmFsPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgZT9lOlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fTtkLmV4cG9ydFN5bWJvbD1cbmZ1bmN0aW9uKGYsaCl7Zj1mLnNwbGl0KFwiLlwiKTt2YXIgcD1kLmdsb2JhbCxnO2ZvcihnPTA7ZzxmLmxlbmd0aC0xO2crKyl7dmFyIGE9ZltnXTtwPXAuaGFzT3duUHJvcGVydHkoYSk/cFthXTpwW2FdPXt9fVwidW5kZWZpbmVkXCIhPT10eXBlb2YgaCYmKGE9ZltnXSxwW2FdPWgpfTtkLmlzQXJyYXlMaWtlPWZ1bmN0aW9uKGYpe3JldHVybiBmIGluc3RhbmNlb2YgQXJyYXl8fGYmJmYubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgZi5sZW5ndGg/ITA6ITF9O2QuanNfYmVhdXRpZnk9ZnVuY3Rpb24oZil7cmV0dXJuIGZ9O2QuZXhwb3J0U3ltYm9sKFwiU2tcIixkKTtkLmV4cG9ydFN5bWJvbChcIlNrLmdsb2JhbFwiLGQuZ2xvYmFsKTtkLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWxkXCIsZC5idWlsZCk7ZC5leHBvcnRTeW1ib2woXCJTay5leHBvcnRTeW1ib2xcIixkLmV4cG9ydFN5bWJvbCk7ZC5leHBvcnRTeW1ib2woXCJTay5pc0FycmF5TGlrZVwiLGQuaXNBcnJheUxpa2UpO2QuZXhwb3J0U3ltYm9sKFwiU2suanNfYmVhdXRpZnlcIixcbmQuanNfYmVhdXRpZnkpfSkuY2FsbCh0aGlzLGIoMCkpfSxmdW5jdGlvbihGLFApeyhmdW5jdGlvbigpe2Z1bmN0aW9uIGIoayx1LGwpe2Z1bmN0aW9uIHEoSSxNLFMsRSl7Zm9yKHZhciBIPVwiXCIseT1udWxsLEE9ITEsSj1JLmxlbmd0aCxRPSExLFg9MDtYPEo7WCsrKXt2YXIgYWE9SS5jaGFyQ29kZUF0KFgpO2lmKCEwPT09QSlpZig0NT09PWFhKXk9XCJcIjtlbHNlIGlmKDk1PT09YWEpeT1cIiBcIjtlbHNlIGlmKDQ4PT09YWEpeT1cIjBcIjtlbHNlIGlmKDU4PT09YWEpUSYmZyhcIltXQVJOSU5HXSBkZXRlY3RlZCB1c2Ugb2YgdW5zdXBwb3J0ZWQgJTo6IG9yICU6OjogbW9kaWZpZXJzIHRvIHN0cmZ0aW1lXCIpLFE9ITA7ZWxzZXtzd2l0Y2goYWEpe2Nhc2UgMzc6SCs9XCIlXCI7YnJlYWs7Y2FzZSA2NTpIKz1TLmRheXNbTS5nZXREYXkoKV07YnJlYWs7Y2FzZSA2NjpIKz1TLm1vbnRoc1tNLmdldE1vbnRoKCldO2JyZWFrO2Nhc2UgNjc6SCs9ZShNYXRoLmZsb29yKE0uZ2V0RnVsbFllYXIoKS8xMDApLFxueSk7YnJlYWs7Y2FzZSA2ODpIKz1xKFMuZm9ybWF0cy5ELE0sUyxFKTticmVhaztjYXNlIDcwOkgrPXEoUy5mb3JtYXRzLkYsTSxTLEUpO2JyZWFrO2Nhc2UgNzI6SCs9ZShNLmdldEhvdXJzKCkseSk7YnJlYWs7Y2FzZSA3MzpIKz1lKGYoTS5nZXRIb3VycygpKSx5KTticmVhaztjYXNlIDc2OkgrPWQoTWF0aC5mbG9vcihFJTFFMykpO2JyZWFrO2Nhc2UgNzc6SCs9ZShNLmdldE1pbnV0ZXMoKSx5KTticmVhaztjYXNlIDgwOkgrPTEyPk0uZ2V0SG91cnMoKT9TLmFtOlMucG07YnJlYWs7Y2FzZSA4MjpIKz1xKFMuZm9ybWF0cy5SLE0sUyxFKTticmVhaztjYXNlIDgzOkgrPWUoTS5nZXRTZWNvbmRzKCkseSk7YnJlYWs7Y2FzZSA4NDpIKz1xKFMuZm9ybWF0cy5ULE0sUyxFKTticmVhaztjYXNlIDg1OkgrPWUoaChNLFwic3VuZGF5XCIpLHkpO2JyZWFrO2Nhc2UgODc6SCs9ZShoKE0sXCJtb25kYXlcIikseSk7YnJlYWs7Y2FzZSA4ODpIKz1xKFMuZm9ybWF0cy5YLE0sUyxFKTticmVhaztjYXNlIDg5OkgrPVxuTS5nZXRGdWxsWWVhcigpO2JyZWFrO2Nhc2UgOTA6dCYmMD09PXI/SCs9XCJHTVRcIjooeT1NLHk9KHk9eS50b1N0cmluZygpLm1hdGNoKC9cXCgoW1xcd1xcc10rKVxcKS8pKSYmeVsxXSxIKz15fHxcIlwiKTticmVhaztjYXNlIDk3OkgrPVMuc2hvcnREYXlzW00uZ2V0RGF5KCldO2JyZWFrO2Nhc2UgOTg6SCs9Uy5zaG9ydE1vbnRoc1tNLmdldE1vbnRoKCldO2JyZWFrO2Nhc2UgOTk6SCs9cShTLmZvcm1hdHMuYyxNLFMsRSk7YnJlYWs7Y2FzZSAxMDA6SCs9ZShNLmdldERhdGUoKSx5KTticmVhaztjYXNlIDEwMTpIKz1lKE0uZ2V0RGF0ZSgpLG51bGw9PXk/XCIgXCI6eSk7YnJlYWs7Y2FzZSAxMDQ6SCs9Uy5zaG9ydE1vbnRoc1tNLmdldE1vbnRoKCldO2JyZWFrO2Nhc2UgMTA2Onk9bmV3IERhdGUoTS5nZXRGdWxsWWVhcigpLDAsMSk7eT1NYXRoLmNlaWwoKE0uZ2V0VGltZSgpLXkuZ2V0VGltZSgpKS84NjRFNSk7SCs9ZCh5KTticmVhaztjYXNlIDEwNzpIKz1lKE0uZ2V0SG91cnMoKSxudWxsPT1cbnk/XCIgXCI6eSk7YnJlYWs7Y2FzZSAxMDg6SCs9ZShmKE0uZ2V0SG91cnMoKSksbnVsbD09eT9cIiBcIjp5KTticmVhaztjYXNlIDEwOTpIKz1lKE0uZ2V0TW9udGgoKSsxLHkpO2JyZWFrO2Nhc2UgMTEwOkgrPVwiXFxuXCI7YnJlYWs7Y2FzZSAxMTE6eT1NLmdldERhdGUoKTtIPVMub3JkaW5hbFN1ZmZpeGVzP0grKFN0cmluZyh5KSsoUy5vcmRpbmFsU3VmZml4ZXNbeS0xXXx8cCh5KSkpOkgrKFN0cmluZyh5KStwKHkpKTticmVhaztjYXNlIDExMjpIKz0xMj5NLmdldEhvdXJzKCk/Uy5BTTpTLlBNO2JyZWFrO2Nhc2UgMTE0OkgrPXEoUy5mb3JtYXRzLnIsTSxTLEUpO2JyZWFrO2Nhc2UgMTE1OkgrPU1hdGguZmxvb3IoRS8xRTMpO2JyZWFrO2Nhc2UgMTE2OkgrPVwiXFx0XCI7YnJlYWs7Y2FzZSAxMTc6eT1NLmdldERheSgpO0grPTA9PT15Pzc6eTticmVhaztjYXNlIDExODpIKz1xKFMuZm9ybWF0cy52LE0sUyxFKTticmVhaztjYXNlIDExOTpIKz1NLmdldERheSgpO2JyZWFrO2Nhc2UgMTIwOkgrPVxucShTLmZvcm1hdHMueCxNLFMsRSk7YnJlYWs7Y2FzZSAxMjE6QT1NLmdldEZ1bGxZZWFyKCklMTAwO0grPWUoQSx5KTticmVhaztjYXNlIDEyMjp0JiYwPT09cj9IKz1RP1wiKzAwOjAwXCI6XCIrMDAwMFwiOih5PTAhPT1yP3IvNkU0Oi1NLmdldFRpbWV6b25lT2Zmc2V0KCksQT1RP1wiOlwiOlwiXCIsYWE9TWF0aC5hYnMoeSU2MCksSCs9KDA+eT9cIi1cIjpcIitcIikrZShNYXRoLmZsb29yKE1hdGguYWJzKHkvNjApKSkrQStlKGFhKSk7YnJlYWs7ZGVmYXVsdDpBJiYoSCs9XCIlXCIpLEgrPUlbWF19eT1udWxsO0E9ITF9ZWxzZSAzNz09PWFhP0E9ITA6SCs9SVtYXX1yZXR1cm4gSH12YXIgej1rfHxjLHI9dXx8MCx0PWx8fCExLHg9MCx2LEI9ZnVuY3Rpb24oSSxNKXtpZihNKXt2YXIgUz1NLmdldFRpbWUoKTtpZih0KXt2YXIgRT02RTQqKE0uZ2V0VGltZXpvbmVPZmZzZXQoKXx8MCk7TT1uZXcgRGF0ZShTK0Urcik7NkU0KihNLmdldFRpbWV6b25lT2Zmc2V0KCl8fDApIT09RSYmKE09NkU0KihNLmdldFRpbWV6b25lT2Zmc2V0KCl8fFxuMCksTT1uZXcgRGF0ZShTK00rcikpfX1lbHNlIFM9RGF0ZS5ub3coKSxTPng/KHg9Uyx2PW5ldyBEYXRlKHgpLFM9eCx0JiYodj1uZXcgRGF0ZSh4KzZFNCoodi5nZXRUaW1lem9uZU9mZnNldCgpfHwwKStyKSkpOlM9eCxNPXY7cmV0dXJuIHEoSSxNLHosUyl9O0IubG9jYWxpemU9ZnVuY3Rpb24oSSl7cmV0dXJuIG5ldyBiKEl8fHoscix0KX07Qi5sb2NhbGl6ZUJ5SWRlbnRpZmllcj1mdW5jdGlvbihJKXt2YXIgTT1hW0ldO3JldHVybiBNP0IubG9jYWxpemUoTSk6KGcoJ1tXQVJOSU5HXSBObyBsb2NhbGUgZm91bmQgd2l0aCBpZGVudGlmaWVyIFwiJytJKydcIi4nKSxCKX07Qi50aW1lem9uZT1mdW5jdGlvbihJKXt2YXIgTT1yLFM9dCxFPXR5cGVvZiBJO2lmKFwibnVtYmVyXCI9PT1FfHxcInN0cmluZ1wiPT09RSlTPSEwLFwic3RyaW5nXCI9PT1FPyhNPVwiLVwiPT09SVswXT8tMToxLEU9cGFyc2VJbnQoSS5zbGljZSgxLDMpLDEwKSxJPXBhcnNlSW50KEkuc2xpY2UoMyw1KSwxMCksTT1NKig2MCpcbkUrSSkqNkU0KTpcIm51bWJlclwiPT09RSYmKE09NkU0KkkpO3JldHVybiBuZXcgYih6LE0sUyl9O0IudXRjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBiKHosciwhMCl9O3JldHVybiBCfWZ1bmN0aW9uIGUoayx1KXtpZihcIlwiPT09dXx8OTxrKXJldHVyblwiXCIraztudWxsPT11JiYodT1cIjBcIik7cmV0dXJuIHUra31mdW5jdGlvbiBkKGspe3JldHVybiA5OTxrP2s6OTxrP1wiMFwiK2s6XCIwMFwiK2t9ZnVuY3Rpb24gZihrKXtyZXR1cm4gMD09PWs/MTI6MTI8az9rLTEyOmt9ZnVuY3Rpb24gaChrLHUpe3U9dXx8XCJzdW5kYXlcIjt2YXIgbD1rLmdldERheSgpO1wibW9uZGF5XCI9PT11JiYoMD09PWw/bD02OmwtLSk7dT1EYXRlLlVUQyhrLmdldEZ1bGxZZWFyKCksMCwxKTtrPURhdGUuVVRDKGsuZ2V0RnVsbFllYXIoKSxrLmdldE1vbnRoKCksay5nZXREYXRlKCkpO3JldHVybiBNYXRoLmZsb29yKChNYXRoLmZsb29yKChrLXUpLzg2NEU1KSs3LWwpLzcpfWZ1bmN0aW9uIHAoayl7dmFyIHU9ayUxMDtrJT1cbjEwMDtpZigxMTw9ayYmMTM+PWt8fDA9PT11fHw0PD11KXJldHVyblwidGhcIjtzd2l0Y2godSl7Y2FzZSAxOnJldHVyblwic3RcIjtjYXNlIDI6cmV0dXJuXCJuZFwiO2Nhc2UgMzpyZXR1cm5cInJkXCJ9fWZ1bmN0aW9uIGcoayl7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjb25zb2xlLndhcm4mJmNvbnNvbGUud2FybihrKX12YXIgYT17ZGVfREU6e2lkZW50aWZpZXI6XCJkZS1ERVwiLGRheXM6XCJTb25udGFnIE1vbnRhZyBEaWVuc3RhZyBNaXR0d29jaCBEb25uZXJzdGFnIEZyZWl0YWcgU2Ftc3RhZ1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJTbyBNbyBEaSBNaSBEbyBGciBTYVwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJKYW51YXIgRmVicnVhciBNXFx1MDBlNHJ6IEFwcmlsIE1haSBKdW5pIEp1bGkgQXVndXN0IFNlcHRlbWJlciBPa3RvYmVyIE5vdmVtYmVyIERlemVtYmVyXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiSmFuIEZlYiBNXFx1MDBlNHIgQXByIE1haSBKdW4gSnVsIEF1ZyBTZXAgT2t0IE5vdiBEZXpcIi5zcGxpdChcIiBcIiksXG5BTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsRDpcIiVkLiVtLiVZXCIsRjpcIiVZLSVtLSVkXCIsUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVUXCIseDpcIiVEXCJ9fSxlbl9DQTp7aWRlbnRpZmllcjpcImVuLUNBXCIsZGF5czpcIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdFwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNcIi5zcGxpdChcIiBcIiksb3JkaW5hbFN1ZmZpeGVzOlwic3QgbmQgcmQgdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggc3QgbmQgcmQgdGggdGggdGggdGggdGggdGggdGggc3RcIi5zcGxpdChcIiBcIiksXG5BTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsRDpcIiVkLyVtLyV5XCIsRjpcIiVZLSVtLSVkXCIsUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVyXCIseDpcIiVEXCJ9fSxlbl9VUzp7aWRlbnRpZmllcjpcImVuLVVTXCIsZGF5czpcIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdFwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNcIi5zcGxpdChcIiBcIiksb3JkaW5hbFN1ZmZpeGVzOlwic3QgbmQgcmQgdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggc3QgbmQgcmQgdGggdGggdGggdGggdGggdGggdGggc3RcIi5zcGxpdChcIiBcIiksXG5BTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsRDpcIiVtLyVkLyV5XCIsRjpcIiVZLSVtLSVkXCIsUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVyXCIseDpcIiVEXCJ9fSxlc19NWDp7aWRlbnRpZmllcjpcImVzLU1YXCIsZGF5czpcImRvbWluZ28gbHVuZXMgbWFydGVzIG1pXFx1MDBlOXJjb2xlcyBqdWV2ZXMgdmllcm5lcyBzXFx1MDBlMWJhZG9cIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiZG9tIGx1biBtYXIgbWlcXHUwMGU5IGp1ZSB2aWUgc1xcdTAwZTFiXCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcImVuZXJvIGZlYnJlcm8gbWFyem8gYWJyaWwgbWF5byBqdW5pbyBqdWxpbyBhZ29zdG8gc2VwdGllbWJyZSBvY3R1YnJlIG5vdmllbWJyZSBkaWNpZW1icmVcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJlbmUgZmViIG1hciBhYnIgbWF5IGp1biBqdWwgYWdvIHNlcCBvY3Qgbm92IGRpY1wiLnNwbGl0KFwiIFwiKSxcbkFNOlwiQU1cIixQTTpcIlBNXCIsYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQvJW0vJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LGZyX0ZSOntpZGVudGlmaWVyOlwiZnItRlJcIixkYXlzOlwiZGltYW5jaGUgbHVuZGkgbWFyZGkgbWVyY3JlZGkgamV1ZGkgdmVuZHJlZGkgc2FtZWRpXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcImRpbS4gbHVuLiBtYXIuIG1lci4gamV1LiB2ZW4uIHNhbS5cIi5zcGxpdChcIiBcIiksbW9udGhzOlwiamFudmllciBmXFx1MDBlOXZyaWVyIG1hcnMgYXZyaWwgbWFpIGp1aW4ganVpbGxldCBhb1xcdTAwZmJ0IHNlcHRlbWJyZSBvY3RvYnJlIG5vdmVtYnJlIGRcXHUwMGU5Y2VtYnJlXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiamFudi4gZlxcdTAwZTl2ci4gbWFycyBhdnJpbCBtYWkganVpbiBqdWlsLiBhb1xcdTAwZmJ0IHNlcHQuIG9jdC4gbm92LiBkXFx1MDBlOWMuXCIuc3BsaXQoXCIgXCIpLFxuQU06XCJBTVwiLFBNOlwiUE1cIixhbTpcImFtXCIscG06XCJwbVwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC8lbS8lWVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0saXRfSVQ6e2lkZW50aWZpZXI6XCJpdC1JVFwiLGRheXM6XCJkb21lbmljYSBsdW5lZFxcdTAwZWMgbWFydGVkXFx1MDBlYyBtZXJjb2xlZFxcdTAwZWMgZ2lvdmVkXFx1MDBlYyB2ZW5lcmRcXHUwMGVjIHNhYmF0b1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJkb20gbHVuIG1hciBtZXIgZ2lvIHZlbiBzYWJcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiZ2VubmFpbyBmZWJicmFpbyBtYXJ6byBhcHJpbGUgbWFnZ2lvIGdpdWdubyBsdWdsaW8gYWdvc3RvIHNldHRlbWJyZSBvdHRvYnJlIG5vdmVtYnJlIGRpY2VtYnJlXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiZ2VuIGZlYiBtYXIgYXByIG1hZyBnaXUgbHVnIGFnbyBzZXQgb3R0IG5vdiBkaWNcIi5zcGxpdChcIiBcIiksXG5BTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsRDpcIiVkLyVtLyVZXCIsRjpcIiVZLSVtLSVkXCIsUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVUXCIseDpcIiVEXCJ9fSxubF9OTDp7aWRlbnRpZmllcjpcIm5sLU5MXCIsZGF5czpcInpvbmRhZyBtYWFuZGFnIGRpbnNkYWcgd29lbnNkYWcgZG9uZGVyZGFnIHZyaWpkYWcgemF0ZXJkYWdcIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiem8gbWEgZGkgd28gZG8gdnIgemFcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiamFudWFyaSBmZWJydWFyaSBtYWFydCBhcHJpbCBtZWkganVuaSBqdWxpIGF1Z3VzdHVzIHNlcHRlbWJlciBva3RvYmVyIG5vdmVtYmVyIGRlY2VtYmVyXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiamFuIGZlYiBtcnQgYXByIG1laSBqdW4ganVsIGF1ZyBzZXAgb2t0IG5vdiBkZWNcIi5zcGxpdChcIiBcIiksQU06XCJBTVwiLFBNOlwiUE1cIixcbmFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsRDpcIiVkLSVtLSV5XCIsRjpcIiVZLSVtLSVkXCIsUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVUXCIseDpcIiVEXCJ9fSxwdF9CUjp7aWRlbnRpZmllcjpcInB0LUJSXCIsZGF5czpcImRvbWluZ28gc2VndW5kYSB0ZXJcXHUwMGU3YSBxdWFydGEgcXVpbnRhIHNleHRhIHNcXHUwMGUxYmFkb1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJEb20gU2VnIFRlciBRdWEgUXVpIFNleCBTXFx1MDBlMWJcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiamFuZWlybyBmZXZlcmVpcm8gbWFyXFx1MDBlN28gYWJyaWwgbWFpbyBqdW5obyBqdWxobyBhZ29zdG8gc2V0ZW1icm8gb3V0dWJybyBub3ZlbWJybyBkZXplbWJyb1wiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcIkphbiBGZXYgTWFyIEFiciBNYWkgSnVuIEp1bCBBZ28gU2V0IE91dCBOb3YgRGV6XCIuc3BsaXQoXCIgXCIpLEFNOlwiQU1cIixQTTpcIlBNXCIsXG5hbTpcImFtXCIscG06XCJwbVwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC0lbS0lWVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0scnVfUlU6e2lkZW50aWZpZXI6XCJydS1SVVwiLGRheXM6XCJcXHUwNDEyXFx1MDQzZVxcdTA0NDFcXHUwNDNhXFx1MDQ0MFxcdTA0MzVcXHUwNDQxXFx1MDQzNVxcdTA0M2RcXHUwNDRjXFx1MDQzNSBcXHUwNDFmXFx1MDQzZVxcdTA0M2RcXHUwNDM1XFx1MDQzNFxcdTA0MzVcXHUwNDNiXFx1MDQ0Y1xcdTA0M2RcXHUwNDM4XFx1MDQzYSBcXHUwNDEyXFx1MDQ0MlxcdTA0M2VcXHUwNDQwXFx1MDQzZFxcdTA0MzhcXHUwNDNhIFxcdTA0MjFcXHUwNDQwXFx1MDQzNVxcdTA0MzRcXHUwNDMwIFxcdTA0MjdcXHUwNDM1XFx1MDQ0MlxcdTA0MzJcXHUwNDM1XFx1MDQ0MFxcdTA0MzMgXFx1MDQxZlxcdTA0NGZcXHUwNDQyXFx1MDQzZFxcdTA0MzhcXHUwNDQ2XFx1MDQzMCBcXHUwNDIxXFx1MDQ0M1xcdTA0MzFcXHUwNDMxXFx1MDQzZVxcdTA0NDJcXHUwNDMwXCIuc3BsaXQoXCIgXCIpLFxuc2hvcnREYXlzOlwiXFx1MDQxMlxcdTA0NDEgXFx1MDQxZlxcdTA0M2QgXFx1MDQxMlxcdTA0NDIgXFx1MDQyMVxcdTA0NDAgXFx1MDQyN1xcdTA0NDIgXFx1MDQxZlxcdTA0NDIgXFx1MDQyMVxcdTA0MzFcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiXFx1MDQyZlxcdTA0M2RcXHUwNDMyXFx1MDQzMFxcdTA0NDBcXHUwNDRjIFxcdTA0MjRcXHUwNDM1XFx1MDQzMlxcdTA0NDBcXHUwNDMwXFx1MDQzYlxcdTA0NGMgXFx1MDQxY1xcdTA0MzBcXHUwNDQwXFx1MDQ0MiBcXHUwNDEwXFx1MDQzZlxcdTA0NDBcXHUwNDM1XFx1MDQzYlxcdTA0NGMgXFx1MDQxY1xcdTA0MzBcXHUwNDM5IFxcdTA0MThcXHUwNDRlXFx1MDQzZFxcdTA0NGMgXFx1MDQxOFxcdTA0NGVcXHUwNDNiXFx1MDQ0YyBcXHUwNDEwXFx1MDQzMlxcdTA0MzNcXHUwNDQzXFx1MDQ0MVxcdTA0NDIgXFx1MDQyMVxcdTA0MzVcXHUwNDNkXFx1MDQ0MlxcdTA0NGZcXHUwNDMxXFx1MDQ0MFxcdTA0NGMgXFx1MDQxZVxcdTA0M2FcXHUwNDQyXFx1MDQ0ZlxcdTA0MzFcXHUwNDQwXFx1MDQ0YyBcXHUwNDFkXFx1MDQzZVxcdTA0NGZcXHUwNDMxXFx1MDQ0MFxcdTA0NGMgXFx1MDQxNFxcdTA0MzVcXHUwNDNhXFx1MDQzMFxcdTA0MzFcXHUwNDQwXFx1MDQ0Y1wiLnNwbGl0KFwiIFwiKSxcbnNob3J0TW9udGhzOlwiXFx1MDQ0ZlxcdTA0M2RcXHUwNDMyIFxcdTA0NDRcXHUwNDM1XFx1MDQzMiBcXHUwNDNjXFx1MDQzMFxcdTA0NDAgXFx1MDQzMFxcdTA0M2ZcXHUwNDQwIFxcdTA0M2NcXHUwNDMwXFx1MDQzOSBcXHUwNDM4XFx1MDQ0ZVxcdTA0M2QgXFx1MDQzOFxcdTA0NGVcXHUwNDNiIFxcdTA0MzBcXHUwNDMyXFx1MDQzMyBcXHUwNDQxXFx1MDQzNVxcdTA0M2QgXFx1MDQzZVxcdTA0M2FcXHUwNDQyIFxcdTA0M2RcXHUwNDNlXFx1MDQ0ZiBcXHUwNDM0XFx1MDQzNVxcdTA0M2FcIi5zcGxpdChcIiBcIiksQU06XCJBTVwiLFBNOlwiUE1cIixhbTpcImFtXCIscG06XCJwbVwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWFwiLEQ6XCIlZC4lbS4leVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0sdHJfVFI6e2lkZW50aWZpZXI6XCJ0ci1UUlwiLGRheXM6XCJQYXphciBQYXphcnRlc2kgU2FsXFx1MDEzMSBcXHUwMGM3YXJcXHUwMTVmYW1iYSBQZXJcXHUwMTVmZW1iZSBDdW1hIEN1bWFydGVzaVwiLnNwbGl0KFwiIFwiKSxcbnNob3J0RGF5czpcIlBheiBQenQgU2FsIFxcdTAwYzdyXFx1MDE1ZiBQclxcdTAxNWYgQ3VtIEN0c1wiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJPY2FrIFxcdTAxNWV1YmF0IE1hcnQgTmlzYW4gTWF5XFx1MDEzMXMgSGF6aXJhbiBUZW1tdXogQVxcdTAxMWZ1c3RvcyBFeWxcXHUwMGZjbCBFa2ltIEthc1xcdTAxMzFtIEFyYWxcXHUwMTMxa1wiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcIk9jYSBcXHUwMTVldWIgTWFyIE5pcyBNYXkgSGF6IFRlbSBBXFx1MDExZnUgRXlsIEVraSBLYXMgQXJhXCIuc3BsaXQoXCIgXCIpLEFNOlwiXFx1MDBkNlxcdTAwZDZcIixQTTpcIlxcdTAwZDZTXCIsYW06XCJcXHUwMGQ2XFx1MDBkNlwiLHBtOlwiXFx1MDBkNlNcIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQtJW0tJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LHpoX0NOOntpZGVudGlmaWVyOlwiemgtQ05cIixkYXlzOlwiXFx1NjYxZlxcdTY3MWZcXHU2NWU1IFxcdTY2MWZcXHU2NzFmXFx1NGUwMCBcXHU2NjFmXFx1NjcxZlxcdTRlOGMgXFx1NjYxZlxcdTY3MWZcXHU0ZTA5IFxcdTY2MWZcXHU2NzFmXFx1NTZkYiBcXHU2NjFmXFx1NjcxZlxcdTRlOTQgXFx1NjYxZlxcdTY3MWZcXHU1MTZkXCIuc3BsaXQoXCIgXCIpLFxuc2hvcnREYXlzOlwiXFx1NjVlNVxcdTRlMDBcXHU0ZThjXFx1NGUwOVxcdTU2ZGJcXHU0ZTk0XFx1NTE2ZFwiLnNwbGl0KFwiXCIpLG1vbnRoczpcIlxcdTRlMDBcXHU2NzA4XFx1NGVmZCBcXHU0ZThjXFx1NjcwOFxcdTRlZmQgXFx1NGUwOVxcdTY3MDhcXHU0ZWZkIFxcdTU2ZGJcXHU2NzA4XFx1NGVmZCBcXHU0ZTk0XFx1NjcwOFxcdTRlZmQgXFx1NTE2ZFxcdTY3MDhcXHU0ZWZkIFxcdTRlMDNcXHU2NzA4XFx1NGVmZCBcXHU1MTZiXFx1NjcwOFxcdTRlZmQgXFx1NGU1ZFxcdTY3MDhcXHU0ZWZkIFxcdTUzNDFcXHU2NzA4XFx1NGVmZCBcXHU1MzQxXFx1NGUwMFxcdTY3MDhcXHU0ZWZkIFxcdTUzNDFcXHU0ZThjXFx1NjcwOFxcdTRlZmRcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJcXHU0ZTAwXFx1NjcwOCBcXHU0ZThjXFx1NjcwOCBcXHU0ZTA5XFx1NjcwOCBcXHU1NmRiXFx1NjcwOCBcXHU0ZTk0XFx1NjcwOCBcXHU1MTZkXFx1NjcwOCBcXHU0ZTAzXFx1NjcwOCBcXHU1MTZiXFx1NjcwOCBcXHU0ZTVkXFx1NjcwOCBcXHU1MzQxXFx1NjcwOCBcXHU1MzQxXFx1NGUwMFxcdTY3MDggXFx1NTM0MVxcdTRlOGNcXHU2NzA4XCIuc3BsaXQoXCIgXCIpLFxuQU06XCJcXHU0ZTBhXFx1NTM0OFwiLFBNOlwiXFx1NGUwYlxcdTUzNDhcIixhbTpcIlxcdTRlMGFcXHU1MzQ4XCIscG06XCJcXHU0ZTBiXFx1NTM0OFwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC8lbS8leVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlclwiLHg6XCIlRFwifX19LGM9YS5lbl9VUyxuPW5ldyBiKGMsMCwhMSk7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBGKXZhciBtPUYuZXhwb3J0cz1uO2Vsc2UgbT1mdW5jdGlvbigpe3JldHVybiB0aGlzfHwoMCxldmFsKShcInRoaXNcIil9KCksbS5zdHJmdGltZT1uO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBEYXRlLm5vdyYmKERhdGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfSl9KSgpfSxmdW5jdGlvbihGLFAsYil7Rj1iKDUpO2NvbnN0IGU9U2suZ2xvYmFsLkpTQkk9dm9pZCAwIT09U2suZ2xvYmFsLkJpZ0ludD97fTpGO3ZvaWQgMD09PVNrLmdsb2JhbC5CaWdJbnQ/XG4oZS5fX2lzQmlnSW50fHwoZS5fX2lzQmlnSW50PWQ9PmQgaW5zdGFuY2VvZiBlKSxlLnBvd2VybW9kPShkLGYsaCk9Pntjb25zdCBwPWUuQmlnSW50KDEpO2xldCBnPXA7Zm9yKGY9ZS5ncmVhdGVyVGhhbihmLGUuX19aRVJPKT9mOmUudW5hcnlNaW51cyhmKTtlLmdyZWF0ZXJUaGFuKGYsZS5fX1pFUk8pOyllLmJpdHdpc2VBbmQoZixwKSYmKGc9ZS5yZW1haW5kZXIoZS5tdWx0aXBseShnLGQpLGgpKSxmPWUuc2lnbmVkUmlnaHRTaGlmdChmLHApLGQ9ZS5yZW1haW5kZXIoZS5tdWx0aXBseShkLGQpLGgpO3JldHVybiBnfSk6T2JqZWN0LmFzc2lnbihlLHtCaWdJbnQ6U2suZ2xvYmFsLkJpZ0ludCx0b051bWJlcjpkPT5OdW1iZXIoZCksdG9TdHJpbmc6ZD0+ZC50b1N0cmluZygpLF9faXNCaWdJbnQ6ZD0+XCJiaWdpbnRcIj09PXR5cGVvZiBkLHVuYXJ5TWludXM6ZD0+LWQsYml0d2lzZU5vdDpkPT5+ZCxiaXR3aXNlQW5kOihkLGYpPT5kJmYsYml0d2lzZU9yOihkLGYpPT5kfGYsYml0d2lzZVhvcjooZCxcbmYpPT5kXmYsZXhwb25lbnRpYXRlOihkLGYpPT57Y29uc3QgaD1lLkJpZ0ludCgxKTtsZXQgcD1oO2ZvcihmPWY+ZS5fX1pFUk8/ZjotZjtmPmUuX19aRVJPOylmJmgmJihwKj1kKSxmPj49aCxkKj1kO3JldHVybiBwfSxwb3dlcm1vZDooZCxmLGgpPT57Y29uc3QgcD1lLkJpZ0ludCgxKTtsZXQgZz1wO2ZvcihmPWY+ZS5fX1pFUk8/ZjotZjtmPmUuX19aRVJPOylmJnAmJihnPWcqZCVoKSxmPj49cCxkPWQqZCVoO3JldHVybiBnfSxtdWx0aXBseTooZCxmKT0+ZCpmLGRpdmlkZTooZCxmKT0+ZC9mLHJlbWFpbmRlcjooZCxmKT0+ZCVmLGFkZDooZCxmKT0+ZCtmLHN1YnRyYWN0OihkLGYpPT5kLWYsbGVmdFNoaWZ0OihkLGYpPT5kPDxmLHNpZ25lZFJpZ2h0U2hpZnQ6KGQsZik9PmQ+PmYsdW5zaWduZWRSaWdodFNoaWZ0OihkLGYpPT5kPj4+ZixsZXNzVGhhbjooZCxmKT0+ZDxmLGxlc3NUaGFuT3JFcXVhbDooZCxmKT0+ZDw9ZixncmVhdGVyVGhhbjooZCxmKT0+ZD5mLGdyZWF0ZXJUaGFuT3JFcXVhbDooZCxcbmYpPT5kPj1mLGVxdWFsOihkLGYpPT5kPT09Zixub3RFcXVhbDooZCxmKT0+ZCE9PWZ9KTtlLl9fWkVSTz1lLkJpZ0ludCgwKTtlLl9fTUFYX1NBRkU9ZS5CaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO2UuX19NSU5fU0FGRT1lLkJpZ0ludCgtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO2UubnVtYmVySWZTYWZlPWQ9PmUubGVzc1RoYW4oZCxlLl9fTUFYX1NBRkUpJiZlLmdyZWF0ZXJUaGFuKGQsZS5fX01JTl9TQUZFKT9lLnRvTnVtYmVyKGQpOmQ7ZS5CaWdVcD1kPT5lLl9faXNCaWdJbnQoZCk/ZDplLkJpZ0ludChkKX0sZnVuY3Rpb24oRixQLGIpeyhmdW5jdGlvbihlLGQpe0YuZXhwb3J0cz1kKCl9KSh0aGlzLGZ1bmN0aW9uKCl7dmFyIGU9TWF0aC5pbXVsLGQ9TWF0aC5jbHozMixmPU1hdGguYWJzLGg9TWF0aC5tYXgscD1NYXRoLmZsb29yO2NsYXNzIGcgZXh0ZW5kcyBBcnJheXtjb25zdHJ1Y3RvcihhLGMpe2lmKHN1cGVyKGEpLHRoaXMuc2lnbj1jLGE+Zy5fX2tNYXhMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXhpbXVtIEJpZ0ludCBzaXplIGV4Y2VlZGVkXCIpO1xufXN0YXRpYyBCaWdJbnQoYSl7dmFyIGM9TnVtYmVyLmlzRmluaXRlO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXtpZigwPT09YSlyZXR1cm4gZy5fX3plcm8oKTtpZihnLl9faXNPbmVEaWdpdEludChhKSlyZXR1cm4gMD5hP2cuX19vbmVEaWdpdCgtYSwhMCk6Zy5fX29uZURpZ2l0KGEsITEpO2lmKCFjKGEpfHxwKGEpIT09YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBudW1iZXIgXCIrYStcIiBjYW5ub3QgYmUgY29udmVydGVkIHRvIEJpZ0ludCBiZWNhdXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXCIpO3JldHVybiBnLl9fZnJvbURvdWJsZShhKX1pZihcInN0cmluZ1wiPT10eXBlb2YgYSl7Yz1nLl9fZnJvbVN0cmluZyhhKTtpZihudWxsPT09Yyl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJDYW5ub3QgY29udmVydCBcIithK1wiIHRvIGEgQmlnSW50XCIpO3JldHVybiBjfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgYSlyZXR1cm4hMD09PWE/Zy5fX29uZURpZ2l0KDEsITEpOmcuX196ZXJvKCk7aWYoXCJvYmplY3RcIj09XG50eXBlb2YgYSl7aWYoYS5jb25zdHJ1Y3Rvcj09PWcpcmV0dXJuIGE7YT1nLl9fdG9QcmltaXRpdmUoYSk7cmV0dXJuIGcuQmlnSW50KGEpfXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCBcIithK1wiIHRvIGEgQmlnSW50XCIpO310b0RlYnVnU3RyaW5nKCl7Y29uc3QgYT1bXCJCaWdJbnRbXCJdO2Zvcihjb25zdCBjIG9mIHRoaXMpYS5wdXNoKChjPyhjPj4+MCkudG9TdHJpbmcoMTYpOmMpK1wiLCBcIik7cmV0dXJuIGEucHVzaChcIl1cIiksYS5qb2luKFwiXCIpfXRvU3RyaW5nKGEpe2E9dm9pZCAwPT09YT8xMDphO2lmKDI+YXx8MzY8YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRvU3RyaW5nKCkgcmFkaXggYXJndW1lbnQgbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2XCIpO3JldHVybiAwPT09dGhpcy5sZW5ndGg/XCIwXCI6MD09KGEmYS0xKT9nLl9fdG9TdHJpbmdCYXNlUG93ZXJPZlR3byh0aGlzLGEpOmcuX190b1N0cmluZ0dlbmVyaWModGhpcyxhLCExKX1zdGF0aWMgdG9OdW1iZXIoYSl7dmFyIGM9XG5hLmxlbmd0aDtpZigwPT09YylyZXR1cm4gMDtpZigxPT09Yyl7dmFyIG49YS5fX3Vuc2lnbmVkRGlnaXQoMCk7cmV0dXJuIGEuc2lnbj8tbjpufXZhciBtPWEuX19kaWdpdChjLTEpLGs9Zy5fX2NsejMwKG0pO249MzAqYy1rO2lmKDEwMjQ8bilyZXR1cm4gYS5zaWduPy1JbmZpbml0eToxLzA7LS1uO2xldCB1PWMtMTt2YXIgbD1rKzM7az0oMzI9PT1sPzA6bTw8bCk+Pj4xMjtjb25zdCBxPWwtMTI7Yz0xMjw9bD8wOm08PDIwK2w7bD0yMCtsO2ZvcigwPHEmJjA8dSYmKHUtLSxtPWEuX19kaWdpdCh1KSxrfD1tPj4+MzAtcSxjPW08PHErMixsPXErMik7MDxsJiYwPHU7KXUtLSxtPWEuX19kaWdpdCh1KSxjfD0zMDw9bD9tPDxsLTMwOm0+Pj4zMC1sLGwtPTMwO209Zy5fX2RlY2lkZVJvdW5kaW5nKGEsbCx1LG0pO2lmKCgxPT09bXx8MD09PW0mJjE9PSgxJmMpKSYmKGM9YysxPj4+MCwwPT09YyYmKGsrKywwIT1rPj4+MjAmJihrPTAsbisrLDEwMjM8bikpKSlyZXR1cm4gYS5zaWduPy1JbmZpbml0eTpcbjEvMDthPWEuc2lnbj8tMjE0NzQ4MzY0ODowO3JldHVybiBuPW4rMTAyMzw8MjAsZy5fX2tCaXRDb252ZXJzaW9uSW50c1sxXT1hfG58ayxnLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdPWMsZy5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdfXN0YXRpYyB1bmFyeU1pbnVzKGEpe2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gYTtjb25zdCBjPWEuX19jb3B5KCk7cmV0dXJuIGMuc2lnbj0hYS5zaWduLGN9c3RhdGljIGJpdHdpc2VOb3QoYSl7cmV0dXJuIGEuc2lnbj9nLl9fYWJzb2x1dGVTdWJPbmUoYSkuX190cmltKCk6Zy5fX2Fic29sdXRlQWRkT25lKGEsITApfXN0YXRpYyBleHBvbmVudGlhdGUoYSxjKXtpZihjLnNpZ24pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFeHBvbmVudCBtdXN0IGJlIHBvc2l0aXZlXCIpO2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gZy5fX29uZURpZ2l0KDEsITEpO2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gYTtpZigxPT09YS5sZW5ndGgmJjE9PT1hLl9fZGlnaXQoMCkpcmV0dXJuIGEuc2lnbiYmXG4wPT0oMSZjLl9fZGlnaXQoMCkpP2cudW5hcnlNaW51cyhhKTphO2lmKDE8Yy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCaWdJbnQgdG9vIGJpZ1wiKTtjPWMuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1jKXJldHVybiBhO2lmKGM+PWcuX19rTWF4TGVuZ3RoQml0cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO2lmKDE9PT1hLmxlbmd0aCYmMj09PWEuX19kaWdpdCgwKSl7dmFyIG49MSsoMHxjLzMwKTthPW5ldyBnKG4sYS5zaWduJiYwIT0oMSZjKSk7YS5fX2luaXRpYWxpemVEaWdpdHMoKTtyZXR1cm4gYS5fX3NldERpZ2l0KG4tMSwxPDxjJTMwKSxhfW49bnVsbDtsZXQgbT1hOzAhPSgxJmMpJiYobj1hKTtmb3IoYz4+PTE7MCE9PWM7Yz4+PTEpbT1nLm11bHRpcGx5KG0sbSksMCE9KDEmYykmJihudWxsPT09bj9uPW06bj1nLm11bHRpcGx5KG4sbSkpO3JldHVybiBufXN0YXRpYyBtdWx0aXBseShhLGMpe2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gYTtcbmlmKDA9PT1jLmxlbmd0aClyZXR1cm4gYzt2YXIgbj1hLmxlbmd0aCtjLmxlbmd0aDszMDw9YS5fX2Nsem1zZCgpK2MuX19jbHptc2QoKSYmbi0tO249bmV3IGcobixhLnNpZ24hPT1jLnNpZ24pO24uX19pbml0aWFsaXplRGlnaXRzKCk7Zm9yKGxldCBtPTA7bTxhLmxlbmd0aDttKyspZy5fX211bHRpcGx5QWNjdW11bGF0ZShjLGEuX19kaWdpdChtKSxuLG0pO3JldHVybiBuLl9fdHJpbSgpfXN0YXRpYyBkaXZpZGUoYSxjKXtpZigwPT09Yy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvXCIpO2lmKDA+Zy5fX2Fic29sdXRlQ29tcGFyZShhLGMpKXJldHVybiBnLl9femVybygpO2NvbnN0IG49YS5zaWduIT09Yy5zaWduLG09Yy5fX3Vuc2lnbmVkRGlnaXQoMCk7aWYoMT09PWMubGVuZ3RoJiYzMjc2Nz49bSl7aWYoMT09PW0pcmV0dXJuIG49PT1hLnNpZ24/YTpnLnVuYXJ5TWludXMoYSk7YT1nLl9fYWJzb2x1dGVEaXZTbWFsbChhLG0sbnVsbCl9ZWxzZSBhPVxuZy5fX2Fic29sdXRlRGl2TGFyZ2UoYSxjLCEwLCExKTtyZXR1cm4gYS5zaWduPW4sYS5fX3RyaW0oKX1zdGF0aWMgcmVtYWluZGVyKGEsYyl7aWYoMD09PWMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRGl2aXNpb24gYnkgemVyb1wiKTtpZigwPmcuX19hYnNvbHV0ZUNvbXBhcmUoYSxjKSlyZXR1cm4gYTtjb25zdCBuPWMuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1jLmxlbmd0aCYmMzI3Njc+PW4pe2lmKDE9PT1uKXJldHVybiBnLl9femVybygpO2M9Zy5fX2Fic29sdXRlTW9kU21hbGwoYSxuKTtyZXR1cm4gMD09PWM/Zy5fX3plcm8oKTpnLl9fb25lRGlnaXQoYyxhLnNpZ24pfWM9Zy5fX2Fic29sdXRlRGl2TGFyZ2UoYSxjLCExLCEwKTtyZXR1cm4gYy5zaWduPWEuc2lnbixjLl9fdHJpbSgpfXN0YXRpYyBhZGQoYSxjKXtjb25zdCBuPWEuc2lnbjtyZXR1cm4gbj09PWMuc2lnbj9nLl9fYWJzb2x1dGVBZGQoYSxjLG4pOjA8PWcuX19hYnNvbHV0ZUNvbXBhcmUoYSxjKT9cbmcuX19hYnNvbHV0ZVN1YihhLGMsbik6Zy5fX2Fic29sdXRlU3ViKGMsYSwhbil9c3RhdGljIHN1YnRyYWN0KGEsYyl7Y29uc3Qgbj1hLnNpZ247cmV0dXJuIG49PT1jLnNpZ24/MDw9Zy5fX2Fic29sdXRlQ29tcGFyZShhLGMpP2cuX19hYnNvbHV0ZVN1YihhLGMsbik6Zy5fX2Fic29sdXRlU3ViKGMsYSwhbik6Zy5fX2Fic29sdXRlQWRkKGEsYyxuKX1zdGF0aWMgbGVmdFNoaWZ0KGEsYyl7cmV0dXJuIDA9PT1jLmxlbmd0aHx8MD09PWEubGVuZ3RoP2E6Yy5zaWduP2cuX19yaWdodFNoaWZ0QnlBYnNvbHV0ZShhLGMpOmcuX19sZWZ0U2hpZnRCeUFic29sdXRlKGEsYyl9c3RhdGljIHNpZ25lZFJpZ2h0U2hpZnQoYSxjKXtyZXR1cm4gMD09PWMubGVuZ3RofHwwPT09YS5sZW5ndGg/YTpjLnNpZ24/Zy5fX2xlZnRTaGlmdEJ5QWJzb2x1dGUoYSxjKTpnLl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoYSxjKX1zdGF0aWMgdW5zaWduZWRSaWdodFNoaWZ0KCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkJpZ0ludHMgaGF2ZSBubyB1bnNpZ25lZCByaWdodCBzaGlmdDsgdXNlID4+IGluc3RlYWRcIik7XG59c3RhdGljIGxlc3NUaGFuKGEsYyl7cmV0dXJuIDA+Zy5fX2NvbXBhcmVUb0JpZ0ludChhLGMpfXN0YXRpYyBsZXNzVGhhbk9yRXF1YWwoYSxjKXtyZXR1cm4gMD49Zy5fX2NvbXBhcmVUb0JpZ0ludChhLGMpfXN0YXRpYyBncmVhdGVyVGhhbihhLGMpe3JldHVybiAwPGcuX19jb21wYXJlVG9CaWdJbnQoYSxjKX1zdGF0aWMgZ3JlYXRlclRoYW5PckVxdWFsKGEsYyl7cmV0dXJuIDA8PWcuX19jb21wYXJlVG9CaWdJbnQoYSxjKX1zdGF0aWMgZXF1YWwoYSxjKXtpZihhLnNpZ24hPT1jLnNpZ258fGEubGVuZ3RoIT09Yy5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjxhLmxlbmd0aDtuKyspaWYoYS5fX2RpZ2l0KG4pIT09Yy5fX2RpZ2l0KG4pKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBub3RFcXVhbChhLGMpe3JldHVybiFnLmVxdWFsKGEsYyl9c3RhdGljIGJpdHdpc2VBbmQoYSxjKXtpZighYS5zaWduJiYhYy5zaWduKXJldHVybiBnLl9fYWJzb2x1dGVBbmQoYSxjKS5fX3RyaW0oKTtcbmlmKGEuc2lnbiYmYy5zaWduKXtjb25zdCBuPWgoYS5sZW5ndGgsYy5sZW5ndGgpKzE7YT1nLl9fYWJzb2x1dGVTdWJPbmUoYSxuKTtjPWcuX19hYnNvbHV0ZVN1Yk9uZShjKTtyZXR1cm4gYT1nLl9fYWJzb2x1dGVPcihhLGMsYSksZy5fX2Fic29sdXRlQWRkT25lKGEsITAsYSkuX190cmltKCl9YS5zaWduJiYoW2EsY109W2MsYV0pO3JldHVybiBnLl9fYWJzb2x1dGVBbmROb3QoYSxnLl9fYWJzb2x1dGVTdWJPbmUoYykpLl9fdHJpbSgpfXN0YXRpYyBiaXR3aXNlWG9yKGEsYyl7aWYoIWEuc2lnbiYmIWMuc2lnbilyZXR1cm4gZy5fX2Fic29sdXRlWG9yKGEsYykuX190cmltKCk7aWYoYS5zaWduJiZjLnNpZ24pe3ZhciBuPWgoYS5sZW5ndGgsYy5sZW5ndGgpO2E9Zy5fX2Fic29sdXRlU3ViT25lKGEsbik7Yz1nLl9fYWJzb2x1dGVTdWJPbmUoYyk7cmV0dXJuIGcuX19hYnNvbHV0ZVhvcihhLGMsYSkuX190cmltKCl9bj1oKGEubGVuZ3RoLGMubGVuZ3RoKSsxO2Euc2lnbiYmKFthLFxuY109W2MsYV0pO2M9Zy5fX2Fic29sdXRlU3ViT25lKGMsbik7cmV0dXJuIGM9Zy5fX2Fic29sdXRlWG9yKGMsYSxjKSxnLl9fYWJzb2x1dGVBZGRPbmUoYywhMCxjKS5fX3RyaW0oKX1zdGF0aWMgYml0d2lzZU9yKGEsYyl7Y29uc3Qgbj1oKGEubGVuZ3RoLGMubGVuZ3RoKTtpZighYS5zaWduJiYhYy5zaWduKXJldHVybiBnLl9fYWJzb2x1dGVPcihhLGMpLl9fdHJpbSgpO2lmKGEuc2lnbiYmYy5zaWduKXJldHVybiBhPWcuX19hYnNvbHV0ZVN1Yk9uZShhLG4pLGM9Zy5fX2Fic29sdXRlU3ViT25lKGMpLGE9Zy5fX2Fic29sdXRlQW5kKGEsYyxhKSxnLl9fYWJzb2x1dGVBZGRPbmUoYSwhMCxhKS5fX3RyaW0oKTthLnNpZ24mJihbYSxjXT1bYyxhXSk7Yz1nLl9fYWJzb2x1dGVTdWJPbmUoYyxuKTtyZXR1cm4gYz1nLl9fYWJzb2x1dGVBbmROb3QoYyxhLGMpLGcuX19hYnNvbHV0ZUFkZE9uZShjLCEwLGMpLl9fdHJpbSgpfXN0YXRpYyBhc0ludE4oYSxjKXtpZigwPT09Yy5sZW5ndGgpcmV0dXJuIGM7XG5pZihhPXAoYSksMD5hKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB2YWx1ZTogbm90IChjb252ZXJ0aWJsZSB0bykgYSBzYWZlIGludGVnZXJcIik7aWYoMD09PWEpcmV0dXJuIGcuX196ZXJvKCk7aWYoYT49Zy5fX2tNYXhMZW5ndGhCaXRzKXJldHVybiBjO2NvbnN0IG49MHwoYSsyOSkvMzA7aWYoYy5sZW5ndGg8bilyZXR1cm4gYztjb25zdCBtPWMuX191bnNpZ25lZERpZ2l0KG4tMSksaz0xPDwoYS0xKSUzMDtpZihjLmxlbmd0aD09PW4mJm08aylyZXR1cm4gYztpZigobSZrKSE9PWspcmV0dXJuIGcuX190cnVuY2F0ZVRvTkJpdHMoYSxjKTtpZighYy5zaWduKXJldHVybiBnLl9fdHJ1bmNhdGVBbmRTdWJGcm9tUG93ZXJPZlR3byhhLGMsITApO2lmKDA9PShtJmstMSkpe2ZvcihsZXQgdT1uLTI7MDw9dTt1LS0paWYoMCE9PWMuX19kaWdpdCh1KSlyZXR1cm4gZy5fX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oYSxjLCExKTtyZXR1cm4gYy5sZW5ndGg9PT1uJiZtPT09XG5rP2M6Zy5fX3RydW5jYXRlVG9OQml0cyhhLGMpfXJldHVybiBnLl9fdHJ1bmNhdGVBbmRTdWJGcm9tUG93ZXJPZlR3byhhLGMsITEpfXN0YXRpYyBhc1VpbnROKGEsYyl7aWYoMD09PWMubGVuZ3RoKXJldHVybiBjO2lmKGE9cChhKSwwPmEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlOiBub3QgKGNvbnZlcnRpYmxlIHRvKSBhIHNhZmUgaW50ZWdlclwiKTtpZigwPT09YSlyZXR1cm4gZy5fX3plcm8oKTtpZihjLnNpZ24pe2lmKGE+Zy5fX2tNYXhMZW5ndGhCaXRzKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7cmV0dXJuIGcuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGEsYywhMSl9aWYoYT49Zy5fX2tNYXhMZW5ndGhCaXRzKXJldHVybiBjO2NvbnN0IG49MHwoYSsyOSkvMzA7aWYoYy5sZW5ndGg8bilyZXR1cm4gYztjb25zdCBtPWElMzA7cmV0dXJuIGMubGVuZ3RoIT1ufHwwIT09bSYmMCE9Yy5fX2RpZ2l0KG4tMSk+Pj5tP2cuX190cnVuY2F0ZVRvTkJpdHMoYSxcbmMpOmN9c3RhdGljIEFERChhLGMpe2lmKGE9Zy5fX3RvUHJpbWl0aXZlKGEpLGM9Zy5fX3RvUHJpbWl0aXZlKGMpLFwic3RyaW5nXCI9PXR5cGVvZiBhKXJldHVyblwic3RyaW5nXCIhPXR5cGVvZiBjJiYoYz1jLnRvU3RyaW5nKCkpLGErYztpZihcInN0cmluZ1wiPT10eXBlb2YgYylyZXR1cm4gYS50b1N0cmluZygpK2M7aWYoYT1nLl9fdG9OdW1lcmljKGEpLGM9Zy5fX3RvTnVtZXJpYyhjKSxnLl9faXNCaWdJbnQoYSkmJmcuX19pc0JpZ0ludChjKSlyZXR1cm4gZy5hZGQoYSxjKTtpZihcIm51bWJlclwiPT10eXBlb2YgYSYmXCJudW1iZXJcIj09dHlwZW9mIGMpcmV0dXJuIGErYzt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IG1peCBCaWdJbnQgYW5kIG90aGVyIHR5cGVzLCB1c2UgZXhwbGljaXQgY29udmVyc2lvbnNcIik7fXN0YXRpYyBMVChhLGMpe3JldHVybiBnLl9fY29tcGFyZShhLGMsMCl9c3RhdGljIExFKGEsYyl7cmV0dXJuIGcuX19jb21wYXJlKGEsYywxKX1zdGF0aWMgR1QoYSxjKXtyZXR1cm4gZy5fX2NvbXBhcmUoYSxcbmMsMil9c3RhdGljIEdFKGEsYyl7cmV0dXJuIGcuX19jb21wYXJlKGEsYywzKX1zdGF0aWMgRVEoYSxjKXtmb3IoOzspe2lmKGcuX19pc0JpZ0ludChhKSlyZXR1cm4gZy5fX2lzQmlnSW50KGMpP2cuZXF1YWwoYSxjKTpnLkVRKGMsYSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpe2lmKGcuX19pc0JpZ0ludChjKSlyZXR1cm4gZy5fX2VxdWFsVG9OdW1iZXIoYyxhKTtpZihcIm9iamVjdFwiIT10eXBlb2YgYylyZXR1cm4gYT09YztjPWcuX190b1ByaW1pdGl2ZShjKX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXtpZihnLl9faXNCaWdJbnQoYykpcmV0dXJuIGE9Zy5fX2Zyb21TdHJpbmcoYSksbnVsbCE9PWEmJmcuZXF1YWwoYSxjKTtpZihcIm9iamVjdFwiIT10eXBlb2YgYylyZXR1cm4gYT09YztjPWcuX190b1ByaW1pdGl2ZShjKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYSl7aWYoZy5fX2lzQmlnSW50KGMpKXJldHVybiBnLl9fZXF1YWxUb051bWJlcihjLCthKTtpZihcIm9iamVjdFwiIT1cbnR5cGVvZiBjKXJldHVybiBhPT1jO2M9Zy5fX3RvUHJpbWl0aXZlKGMpfWVsc2UgaWYoXCJzeW1ib2xcIj09dHlwZW9mIGEpe2lmKGcuX19pc0JpZ0ludChjKSlyZXR1cm4hMTtpZihcIm9iamVjdFwiIT10eXBlb2YgYylyZXR1cm4gYT09YztjPWcuX190b1ByaW1pdGl2ZShjKX1lbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtpZihcIm9iamVjdFwiPT10eXBlb2YgYyYmYy5jb25zdHJ1Y3RvciE9PWcpcmV0dXJuIGE9PWM7YT1nLl9fdG9QcmltaXRpdmUoYSl9ZWxzZSByZXR1cm4gYT09Y319c3RhdGljIE5FKGEsYyl7cmV0dXJuIWcuRVEoYSxjKX1zdGF0aWMgX196ZXJvKCl7cmV0dXJuIG5ldyBnKDAsITEpfXN0YXRpYyBfX29uZURpZ2l0KGEsYyl7Yz1uZXcgZygxLGMpO3JldHVybiBjLl9fc2V0RGlnaXQoMCxhKSxjfV9fY29weSgpe2NvbnN0IGE9bmV3IGcodGhpcy5sZW5ndGgsdGhpcy5zaWduKTtmb3IobGV0IGM9MDtjPHRoaXMubGVuZ3RoO2MrKylhW2NdPXRoaXNbY107cmV0dXJuIGF9X190cmltKCl7bGV0IGE9XG50aGlzLmxlbmd0aCxjPXRoaXNbYS0xXTtmb3IoOzA9PT1jOylhLS0sYz10aGlzW2EtMV0sdGhpcy5wb3AoKTtyZXR1cm4gMD09PWEmJih0aGlzLnNpZ249ITEpLHRoaXN9X19pbml0aWFsaXplRGlnaXRzKCl7Zm9yKGxldCBhPTA7YTx0aGlzLmxlbmd0aDthKyspdGhpc1thXT0wfXN0YXRpYyBfX2RlY2lkZVJvdW5kaW5nKGEsYyxuLG0pe2lmKDA8YylyZXR1cm4tMTtpZigwPmMpYz0tYy0xO2Vsc2V7aWYoMD09PW4pcmV0dXJuLTE7bi0tO209YS5fX2RpZ2l0KG4pO2M9Mjl9Yz0xPDxjO2lmKDA9PShtJmMpKXJldHVybi0xO2lmKC0tYywwIT0obSZjKSlyZXR1cm4gMTtmb3IoOzA8bjspaWYobi0tLDAhPT1hLl9fZGlnaXQobikpcmV0dXJuIDE7cmV0dXJuIDB9c3RhdGljIF9fZnJvbURvdWJsZShhKXtnLl9fa0JpdENvbnZlcnNpb25Eb3VibGVbMF09YTt2YXIgYz0oMjA0NyZnLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdPj4+MjApLTEwMjMsbj0oMHxjLzMwKSsxO2E9bmV3IGcobiwwPmEpO1xubGV0IG09MTA0ODU3NSZnLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdfDEwNDg1NzYsaz1nLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdO2MlPTMwO2xldCB1O2lmKDIwPmMpe3ZhciBsPTIwLWM7dT1sKzMyO2M9bT4+Pmw7bT1tPDwzMi1sfGs+Pj5sO2s8PD0zMi1sfWVsc2UgMjA9PT1jPyh1PTMyLGM9bSxtPWspOihsPWMtMjAsdT0zMi1sLGM9bTw8bHxrPj4+MzItbCxtPWs8PGwpLGs9MDthLl9fc2V0RGlnaXQobi0xLGMpO2ZvcihuLT0yOzA8PW47bi0tKTA8dT8odS09MzAsYz1tPj4+MixtPW08PDMwfGs+Pj4yLGs8PD0zMCk6Yz0wLGEuX19zZXREaWdpdChuLGMpO3JldHVybiBhLl9fdHJpbSgpfXN0YXRpYyBfX2lzV2hpdGVzcGFjZShhKXtyZXR1cm4hISgxMz49YSYmOTw9YSl8fCgxNTk+PWE/MzI9PWE6MTMxMDcxPj1hPzE2MD09YXx8NTc2MD09YToxOTY2MDc+PWE/KGEmPTEzMTA3MSwxMD49YXx8NDA9PWF8fDQxPT1hfHw0Nz09YXx8OTU9PWF8fDQwOTY9PWEpOjY1Mjc5PT1hKX1zdGF0aWMgX19mcm9tU3RyaW5nKGEsXG5jKXtjPXZvaWQgMD09PWM/MDpjO2xldCBuPTA7Y29uc3QgbT1hLmxlbmd0aDtsZXQgaz0wO2lmKGs9PT1tKXJldHVybiBnLl9femVybygpO2xldCB1PWEuY2hhckNvZGVBdChrKTtmb3IoO2cuX19pc1doaXRlc3BhY2UodSk7KXtpZigrK2s9PT1tKXJldHVybiBnLl9femVybygpO3U9YS5jaGFyQ29kZUF0KGspfWlmKDQzPT09dSl7aWYoKytrPT09bSlyZXR1cm4gbnVsbDt1PWEuY2hhckNvZGVBdChrKTtuPTF9ZWxzZSBpZig0NT09PXUpe2lmKCsraz09PW0pcmV0dXJuIG51bGw7dT1hLmNoYXJDb2RlQXQoayk7bj0tMX1pZigwPT09Yyl7aWYoYz0xMCw0OD09PXUpe2lmKCsraz09PW0pcmV0dXJuIGcuX196ZXJvKCk7aWYodT1hLmNoYXJDb2RlQXQoayksODg9PT11fHwxMjA9PT11KXtpZihjPTE2LCsraz09PW0pcmV0dXJuIG51bGw7dT1hLmNoYXJDb2RlQXQoayl9ZWxzZSBpZig3OT09PXV8fDExMT09PXUpe2lmKGM9OCwrK2s9PT1tKXJldHVybiBudWxsO3U9YS5jaGFyQ29kZUF0KGspfWVsc2UgaWYoNjY9PT1cbnV8fDk4PT09dSl7aWYoYz0yLCsraz09PW0pcmV0dXJuIG51bGw7dT1hLmNoYXJDb2RlQXQoayl9fX1lbHNlIGlmKDE2PT09YyYmNDg9PT11KXtpZigrK2s9PT1tKXJldHVybiBnLl9femVybygpO2lmKHU9YS5jaGFyQ29kZUF0KGspLDg4PT09dXx8MTIwPT09dSl7aWYoKytrPT09bSlyZXR1cm4gbnVsbDt1PWEuY2hhckNvZGVBdChrKX19aWYoMCE9biYmMTAhPT1jKXJldHVybiBudWxsO2Zvcig7NDg9PT11Oyl7aWYoKytrPT09bSlyZXR1cm4gZy5fX3plcm8oKTt1PWEuY2hhckNvZGVBdChrKX12YXIgbD1tLWs7bGV0IHE9Zy5fX2tNYXhCaXRzUGVyQ2hhcltjXTt2YXIgej1nLl9fa0JpdHNQZXJDaGFyVGFibGVNdWx0aXBsaWVyLTE7aWYobD4xMDczNzQxODI0L3EpcmV0dXJuIG51bGw7bD1uZXcgZygwfCgocSpsK3o+Pj5nLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdCkrMjkpLzMwLCExKTtjb25zdCByPTEwPmM/YzoxMCx0PTEwPGM/Yy0xMDowO2lmKDA9PShjJmMtMSkpe3E+Pj1nLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdDtcbmM9W107dmFyIHg9W10sdj0hMTtkb3tmb3IodmFyIEI9MCxJPTA7Oyl7aWYodS00OD4+PjA8cil6PXUtNDg7ZWxzZSBpZigoMzJ8dSktOTc+Pj4wPHQpej0oMzJ8dSktODc7ZWxzZXt2PSEwO2JyZWFrfWlmKEkrPXEsQj1CPDxxfHosKytrPT09bSl7dj0hMDticmVha31pZih1PWEuY2hhckNvZGVBdChrKSwzMDxJK3EpYnJlYWt9Yy5wdXNoKEIpO3gucHVzaChJKX13aGlsZSghdik7Zy5fX2ZpbGxGcm9tUGFydHMobCxjLHgpfWVsc2V7bC5fX2luaXRpYWxpemVEaWdpdHMoKTt4PSExO3Y9MDtkb3tCPTA7Zm9yKEk9MTs7KXtpZih1LTQ4Pj4+MDxyKXo9dS00ODtlbHNlIGlmKCgzMnx1KS05Nz4+PjA8dCl6PSgzMnx1KS04NztlbHNle3g9ITA7YnJlYWt9Y29uc3QgTT1JKmM7aWYoMTA3Mzc0MTgyMzxNKWJyZWFrO2lmKEk9TSxCPUIqYyt6LHYrKywrK2s9PT1tKXt4PSEwO2JyZWFrfXU9YS5jaGFyQ29kZUF0KGspfXo9MzAqZy5fX2tCaXRzUGVyQ2hhclRhYmxlTXVsdGlwbGllci0xO2wuX19pbnBsYWNlTXVsdGlwbHlBZGQoSSxcbkIsMHwocSp2K3o+Pj5nLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdCkvMzApfXdoaWxlKCF4KX1pZihrIT09bSl7aWYoIWcuX19pc1doaXRlc3BhY2UodSkpcmV0dXJuIG51bGw7Zm9yKGsrKztrPG07aysrKWlmKHU9YS5jaGFyQ29kZUF0KGspLCFnLl9faXNXaGl0ZXNwYWNlKHUpKXJldHVybiBudWxsfXJldHVybiBsLnNpZ249LTE9PW4sbC5fX3RyaW0oKX1zdGF0aWMgX19maWxsRnJvbVBhcnRzKGEsYyxuKXtsZXQgbT0wLGs9MCx1PTA7Zm9yKGxldCBsPWMubGVuZ3RoLTE7MDw9bDtsLS0pe2NvbnN0IHE9Y1tsXSx6PW5bbF07a3w9cTw8dTt1Kz16OzMwPT09dT8oYS5fX3NldERpZ2l0KG0rKyxrKSx1PTAsaz0wKTozMDx1JiYoYS5fX3NldERpZ2l0KG0rKywxMDczNzQxODIzJmspLHUtPTMwLGs9cT4+PnotdSl9aWYoMCE9PWspe2lmKG0+PWEubGVuZ3RoKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2EuX19zZXREaWdpdChtKyssayl9Zm9yKDttPGEubGVuZ3RoO20rKylhLl9fc2V0RGlnaXQobSxcbjApfXN0YXRpYyBfX3RvU3RyaW5nQmFzZVBvd2VyT2ZUd28oYSxjKXtjb25zdCBuPWEubGVuZ3RoO3ZhciBtPWMtMTttPSg4NSZtPj4+MSkrKDg1Jm0pO209KDUxJm0+Pj4yKSsoNTEmbSk7bT0oMTUmbT4+PjQpKygxNSZtKTstLWM7Y29uc3Qgaz1hLl9fZGlnaXQobi0xKTt2YXIgdT1nLl9fY2x6MzAoayksbD0wfCgzMCpuLXUrbS0xKS9tO2lmKGEuc2lnbiYmbCsrLDI2ODQzNTQ1NjxsKXRocm93IEVycm9yKFwic3RyaW5nIHRvbyBsb25nXCIpO3U9QXJyYXkobCk7LS1sO3ZhciBxPTAsej0wO2ZvcihsZXQgcj0wO3I8bi0xO3IrKyl7Y29uc3QgdD1hLl9fZGlnaXQocik7cT0ocXx0PDx6KSZjO3VbbC0tXT1nLl9fa0NvbnZlcnNpb25DaGFyc1txXTt6PW0tejtxPXQ+Pj56O2Zvcih6PTMwLXo7ej49bTspdVtsLS1dPWcuX19rQ29udmVyc2lvbkNoYXJzW3EmY10scT4+Pj1tLHotPW19dVtsLS1dPWcuX19rQ29udmVyc2lvbkNoYXJzWyhxfGs8PHopJmNdO2ZvcihxPWs+Pj5tLXo7MCE9PXE7KXVbbC0tXT1cbmcuX19rQ29udmVyc2lvbkNoYXJzW3EmY10scT4+Pj1tO2lmKGEuc2lnbiYmKHVbbC0tXT1cIi1cIiksLTEhPWwpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIHUuam9pbihcIlwiKX1zdGF0aWMgX190b1N0cmluZ0dlbmVyaWMoYSxjLG4pe3ZhciBtPWEubGVuZ3RoO2lmKDA9PT1tKXJldHVyblwiXCI7aWYoMT09PW0pcmV0dXJuIGM9YS5fX3Vuc2lnbmVkRGlnaXQoMCkudG9TdHJpbmcoYyksITE9PT1uJiZhLnNpZ24mJihjPVwiLVwiK2MpLGM7dmFyIGs9MzAqbS1nLl9fY2x6MzAoYS5fX2RpZ2l0KG0tMSkpO209Zy5fX2tNYXhCaXRzUGVyQ2hhcltjXS0xO2sqPWcuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI7bT0oMHwoaysobS0xKSkvbSkrMT4+MTtrPWcuZXhwb25lbnRpYXRlKGcuX19vbmVEaWdpdChjLCExKSxnLl9fb25lRGlnaXQobSwhMSkpO3ZhciB1PWsuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1rLmxlbmd0aCYmMzI3Njc+PXUpe2s9bmV3IGcoYS5sZW5ndGgsXG4hMSk7ay5fX2luaXRpYWxpemVEaWdpdHMoKTt2YXIgbD0wO2ZvcihsZXQgcT0yKmEubGVuZ3RoLTE7MDw9cTtxLS0pbD1sPDwxNXxhLl9faGFsZkRpZ2l0KHEpLGsuX19zZXRIYWxmRGlnaXQocSwwfGwvdSksbD0wfGwldTt1PWwudG9TdHJpbmcoYyl9ZWxzZSB1PWcuX19hYnNvbHV0ZURpdkxhcmdlKGEsaywhMCwhMCksaz11LnF1b3RpZW50LHU9dS5yZW1haW5kZXIuX190cmltKCksdT1nLl9fdG9TdHJpbmdHZW5lcmljKHUsYywhMCk7ay5fX3RyaW0oKTtmb3IoYz1nLl9fdG9TdHJpbmdHZW5lcmljKGssYywhMCk7dS5sZW5ndGg8bTspdT1cIjBcIit1O3JldHVybiExPT09biYmYS5zaWduJiYoYz1cIi1cIitjKSxjK3V9c3RhdGljIF9fdW5lcXVhbFNpZ24oYSl7cmV0dXJuIGE/LTE6MX1zdGF0aWMgX19hYnNvbHV0ZUdyZWF0ZXIoYSl7cmV0dXJuIGE/LTE6MX1zdGF0aWMgX19hYnNvbHV0ZUxlc3MoYSl7cmV0dXJuIGE/MTotMX1zdGF0aWMgX19jb21wYXJlVG9CaWdJbnQoYSxjKXtjb25zdCBuPVxuYS5zaWduO2lmKG4hPT1jLnNpZ24pcmV0dXJuIGcuX191bmVxdWFsU2lnbihuKTthPWcuX19hYnNvbHV0ZUNvbXBhcmUoYSxjKTtyZXR1cm4gMDxhP2cuX19hYnNvbHV0ZUdyZWF0ZXIobik6MD5hP2cuX19hYnNvbHV0ZUxlc3Mobik6MH1zdGF0aWMgX19jb21wYXJlVG9OdW1iZXIoYSxjKXtpZihnLl9faXNPbmVEaWdpdEludChjKSl7Y29uc3Qgbj1hLnNpZ24sbT0wPmM7aWYobiE9PW0pcmV0dXJuIGcuX191bmVxdWFsU2lnbihuKTtpZigwPT09YS5sZW5ndGgpe2lmKG0pdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIDA9PT1jPzA6LTF9aWYoMTxhLmxlbmd0aClyZXR1cm4gZy5fX2Fic29sdXRlR3JlYXRlcihuKTtjPWYoYyk7YT1hLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gYT5jP2cuX19hYnNvbHV0ZUdyZWF0ZXIobik6YTxjP2cuX19hYnNvbHV0ZUxlc3Mobik6MH1yZXR1cm4gZy5fX2NvbXBhcmVUb0RvdWJsZShhLGMpfXN0YXRpYyBfX2NvbXBhcmVUb0RvdWJsZShhLFxuYyl7aWYoYyE9PWMpcmV0dXJuIGM7aWYoYz09PTEvMClyZXR1cm4tMTtpZigtSW5maW5pdHk9PT1jKXJldHVybiAxO2NvbnN0IG49YS5zaWduO2lmKG4hPT0wPmMpcmV0dXJuIGcuX191bmVxdWFsU2lnbihuKTtpZigwPT09Yyl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Zzogc2hvdWxkIGJlIGhhbmRsZWQgZWxzZXdoZXJlXCIpO2lmKDA9PT1hLmxlbmd0aClyZXR1cm4tMTtnLl9fa0JpdENvbnZlcnNpb25Eb3VibGVbMF09YztjPTIwNDcmZy5fX2tCaXRDb252ZXJzaW9uSW50c1sxXT4+PjIwO2lmKDIwNDc9PWMpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IGhhbmRsZWQgZWxzZXdoZXJlXCIpO3ZhciBtPWMtMTAyMztpZigwPm0pcmV0dXJuIGcuX19hYnNvbHV0ZUdyZWF0ZXIobik7Yz1hLmxlbmd0aDt2YXIgaz1hLl9fZGlnaXQoYy0xKSx1PWcuX19jbHozMChrKSxsPTMwKmMtdTttKz0xO2lmKGw8bSlyZXR1cm4gZy5fX2Fic29sdXRlTGVzcyhuKTtpZihsPm0pcmV0dXJuIGcuX19hYnNvbHV0ZUdyZWF0ZXIobik7XG5tPTEwNDg1NzZ8MTA0ODU3NSZnLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdO2xldCBxPWcuX19rQml0Q29udmVyc2lvbkludHNbMF07dT0yOS11O2lmKHUhPT0oMHwobC0xKSUzMCkpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7aWYoMjA+dSl7dmFyIHo9MjAtdTt1PXorMzI7bD1tPj4+ejttPW08PDMyLXp8cT4+Pno7cTw8PTMyLXp9ZWxzZSAyMD09PXU/KHU9MzIsbD1tLG09cSk6KHo9dS0yMCx1PTMyLXosbD1tPDx6fHE+Pj4zMi16LG09cTw8eikscT0wO2lmKGs+Pj49MCxsPj4+PTAsaz5sKXJldHVybiBnLl9fYWJzb2x1dGVHcmVhdGVyKG4pO2lmKGs8bClyZXR1cm4gZy5fX2Fic29sdXRlTGVzcyhuKTtmb3IoYy09MjswPD1jO2MtLSl7MDx1Pyh1LT0zMCxsPW0+Pj4yLG09bTw8MzB8cT4+PjIscTw8PTMwKTpsPTA7az1hLl9fdW5zaWduZWREaWdpdChjKTtpZihrPmwpcmV0dXJuIGcuX19hYnNvbHV0ZUdyZWF0ZXIobik7aWYoazxsKXJldHVybiBnLl9fYWJzb2x1dGVMZXNzKG4pfWlmKDAhPT1cbm18fDAhPT1xKXtpZigwPT09dSl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gZy5fX2Fic29sdXRlTGVzcyhuKX1yZXR1cm4gMH1zdGF0aWMgX19lcXVhbFRvTnVtYmVyKGEsYyl7cmV0dXJuIGcuX19pc09uZURpZ2l0SW50KGMpPzA9PT1jPzA9PT1hLmxlbmd0aDoxPT09YS5sZW5ndGgmJmEuc2lnbj09PTA+YyYmYS5fX3Vuc2lnbmVkRGlnaXQoMCk9PT1mKGMpOjA9PT1nLl9fY29tcGFyZVRvRG91YmxlKGEsYyl9c3RhdGljIF9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChhLGMpe3JldHVybiAwPT09Yz8wPmE6MT09PWM/MD49YToyPT09Yz8wPGE6Mz09PWM/MDw9YTp2b2lkIDB9c3RhdGljIF9fY29tcGFyZShhLGMsbil7aWYoYT1nLl9fdG9QcmltaXRpdmUoYSksYz1nLl9fdG9QcmltaXRpdmUoYyksXCJzdHJpbmdcIj09dHlwZW9mIGEmJlwic3RyaW5nXCI9PXR5cGVvZiBjKXN3aXRjaChuKXtjYXNlIDA6cmV0dXJuIGE8YztjYXNlIDE6cmV0dXJuIGE8PWM7Y2FzZSAyOnJldHVybiBhPlxuYztjYXNlIDM6cmV0dXJuIGE+PWN9aWYoZy5fX2lzQmlnSW50KGEpJiZcInN0cmluZ1wiPT10eXBlb2YgYylyZXR1cm4gYz1nLl9fZnJvbVN0cmluZyhjKSxudWxsIT09YyYmZy5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woZy5fX2NvbXBhcmVUb0JpZ0ludChhLGMpLG4pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhJiZnLl9faXNCaWdJbnQoYykpcmV0dXJuIGE9Zy5fX2Zyb21TdHJpbmcoYSksbnVsbCE9PWEmJmcuX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGcuX19jb21wYXJlVG9CaWdJbnQoYSxjKSxuKTtpZihhPWcuX190b051bWVyaWMoYSksYz1nLl9fdG9OdW1lcmljKGMpLGcuX19pc0JpZ0ludChhKSl7aWYoZy5fX2lzQmlnSW50KGMpKXJldHVybiBnLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChnLl9fY29tcGFyZVRvQmlnSW50KGEsYyksbik7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIGcuX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGcuX19jb21wYXJlVG9OdW1iZXIoYSxcbmMpLG4pfWlmKFwibnVtYmVyXCIhPXR5cGVvZiBhKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2lmKGcuX19pc0JpZ0ludChjKSlyZXR1cm4gZy5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woZy5fX2NvbXBhcmVUb051bWJlcihjLGEpLDJebik7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIDA9PT1uP2E8YzoxPT09bj9hPD1jOjI9PT1uP2E+YzozPT09bj9hPj1jOnZvaWQgMH1fX2Nsem1zZCgpe3JldHVybiBnLl9fY2x6MzAodGhpcy5fX2RpZ2l0KHRoaXMubGVuZ3RoLTEpKX1zdGF0aWMgX19hYnNvbHV0ZUFkZChhLGMsbil7aWYoYS5sZW5ndGg8Yy5sZW5ndGgpcmV0dXJuIGcuX19hYnNvbHV0ZUFkZChjLGEsbik7aWYoMD09PWEubGVuZ3RoKXJldHVybiBhO2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gYS5zaWduPT09bj9hOmcudW5hcnlNaW51cyhhKTt2YXIgbT1hLmxlbmd0aDsoMD09PWEuX19jbHptc2QoKXx8XG5jLmxlbmd0aD09PWEubGVuZ3RoJiYwPT09Yy5fX2Nsem1zZCgpKSYmbSsrO249bmV3IGcobSxuKTtsZXQgaz1tPTA7Zm9yKDtrPGMubGVuZ3RoO2srKyl7Y29uc3QgdT1hLl9fZGlnaXQoaykrYy5fX2RpZ2l0KGspK207bT11Pj4+MzA7bi5fX3NldERpZ2l0KGssMTA3Mzc0MTgyMyZ1KX1mb3IoO2s8YS5sZW5ndGg7aysrKWM9YS5fX2RpZ2l0KGspK20sbT1jPj4+MzAsbi5fX3NldERpZ2l0KGssMTA3Mzc0MTgyMyZjKTtyZXR1cm4gazxuLmxlbmd0aCYmbi5fX3NldERpZ2l0KGssbSksbi5fX3RyaW0oKX1zdGF0aWMgX19hYnNvbHV0ZVN1YihhLGMsbil7aWYoMD09PWEubGVuZ3RoKXJldHVybiBhO2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gYS5zaWduPT09bj9hOmcudW5hcnlNaW51cyhhKTtuPW5ldyBnKGEubGVuZ3RoLG4pO2xldCBtPTAsaz0wO2Zvcig7azxjLmxlbmd0aDtrKyspe2NvbnN0IHU9YS5fX2RpZ2l0KGspLWMuX19kaWdpdChrKS1tO209MSZ1Pj4+MzA7bi5fX3NldERpZ2l0KGssXG4xMDczNzQxODIzJnUpfWZvcig7azxhLmxlbmd0aDtrKyspYz1hLl9fZGlnaXQoayktbSxtPTEmYz4+PjMwLG4uX19zZXREaWdpdChrLDEwNzM3NDE4MjMmYyk7cmV0dXJuIG4uX190cmltKCl9c3RhdGljIF9fYWJzb2x1dGVBZGRPbmUoYSxjLG4pe249dm9pZCAwPT09bj9udWxsOm47Y29uc3QgbT1hLmxlbmd0aDtudWxsPT09bj9uPW5ldyBnKG0sYyk6bi5zaWduPWM7Yz0xO2ZvcihsZXQgaz0wO2s8bTtrKyspe2NvbnN0IHU9YS5fX2RpZ2l0KGspK2M7Yz11Pj4+MzA7bi5fX3NldERpZ2l0KGssMTA3Mzc0MTgyMyZ1KX1yZXR1cm4gMCE9YyYmbi5fX3NldERpZ2l0R3JvdyhtLDEpLG59c3RhdGljIF9fYWJzb2x1dGVTdWJPbmUoYSxjKXtjb25zdCBuPWEubGVuZ3RoO2M9Y3x8bjtjb25zdCBtPW5ldyBnKGMsITEpO2xldCBrPTE7Zm9yKGxldCB1PTA7dTxuO3UrKyl7Y29uc3QgbD1hLl9fZGlnaXQodSktaztrPTEmbD4+PjMwO20uX19zZXREaWdpdCh1LDEwNzM3NDE4MjMmbCl9aWYoMCE9XG5rKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2ZvcihhPW47YTxjO2ErKyltLl9fc2V0RGlnaXQoYSwwKTtyZXR1cm4gbX1zdGF0aWMgX19hYnNvbHV0ZUFuZChhLGMsbil7bj12b2lkIDA9PT1uP251bGw6bjt2YXIgbT1hLmxlbmd0aCxrPWMubGVuZ3RoO2xldCB1PWs7bTxrJiYodT1tLG09YSxhPWMsYz1tKTttPXU7bnVsbD09PW4/bj1uZXcgZyhtLCExKTptPW4ubGVuZ3RoO2ZvcihrPTA7azx1O2srKyluLl9fc2V0RGlnaXQoayxhLl9fZGlnaXQoaykmYy5fX2RpZ2l0KGspKTtmb3IoO2s8bTtrKyspbi5fX3NldERpZ2l0KGssMCk7cmV0dXJuIG59c3RhdGljIF9fYWJzb2x1dGVBbmROb3QoYSxjLG4pe249dm9pZCAwPT09bj9udWxsOm47Y29uc3QgbT1hLmxlbmd0aDt2YXIgaz1jLmxlbmd0aDtsZXQgdT1rO208ayYmKHU9bSk7az1tO251bGw9PT1uP249bmV3IGcoaywhMSk6az1uLmxlbmd0aDtsZXQgbD0wO2Zvcig7bDx1O2wrKyluLl9fc2V0RGlnaXQobCxhLl9fZGlnaXQobCkmXG5+Yy5fX2RpZ2l0KGwpKTtmb3IoO2w8bTtsKyspbi5fX3NldERpZ2l0KGwsYS5fX2RpZ2l0KGwpKTtmb3IoO2w8aztsKyspbi5fX3NldERpZ2l0KGwsMCk7cmV0dXJuIG59c3RhdGljIF9fYWJzb2x1dGVPcihhLGMsbil7bj12b2lkIDA9PT1uP251bGw6bjtsZXQgbT1hLmxlbmd0aDt2YXIgaz1jLmxlbmd0aDtsZXQgdT1rO2lmKG08ayl7dT1tO3ZhciBsPWE7YT1jO209aztjPWx9az1tO251bGw9PT1uP249bmV3IGcoaywhMSk6az1uLmxlbmd0aDtmb3IobD0wO2w8dTtsKyspbi5fX3NldERpZ2l0KGwsYS5fX2RpZ2l0KGwpfGMuX19kaWdpdChsKSk7Zm9yKDtsPG07bCsrKW4uX19zZXREaWdpdChsLGEuX19kaWdpdChsKSk7Zm9yKDtsPGs7bCsrKW4uX19zZXREaWdpdChsLDApO3JldHVybiBufXN0YXRpYyBfX2Fic29sdXRlWG9yKGEsYyxuKXtuPXZvaWQgMD09PW4/bnVsbDpuO2xldCBtPWEubGVuZ3RoO3ZhciBrPWMubGVuZ3RoO2xldCB1PWs7aWYobTxrKXt1PW07dmFyIGw9YTthPWM7XG5tPWs7Yz1sfWs9bTtudWxsPT09bj9uPW5ldyBnKGssITEpOms9bi5sZW5ndGg7Zm9yKGw9MDtsPHU7bCsrKW4uX19zZXREaWdpdChsLGEuX19kaWdpdChsKV5jLl9fZGlnaXQobCkpO2Zvcig7bDxtO2wrKyluLl9fc2V0RGlnaXQobCxhLl9fZGlnaXQobCkpO2Zvcig7bDxrO2wrKyluLl9fc2V0RGlnaXQobCwwKTtyZXR1cm4gbn1zdGF0aWMgX19hYnNvbHV0ZUNvbXBhcmUoYSxjKXt2YXIgbj1hLmxlbmd0aC1jLmxlbmd0aDtpZigwIT1uKXJldHVybiBuO2ZvcihuPWEubGVuZ3RoLTE7MDw9biYmYS5fX2RpZ2l0KG4pPT09Yy5fX2RpZ2l0KG4pOyluLS07cmV0dXJuIDA+bj8wOmEuX191bnNpZ25lZERpZ2l0KG4pPmMuX191bnNpZ25lZERpZ2l0KG4pPzE6LTF9c3RhdGljIF9fbXVsdGlwbHlBY2N1bXVsYXRlKGEsYyxuLG0pe2lmKDAhPT1jKXt2YXIgaz0zMjc2NyZjLHU9Yz4+PjE1LGw9Yz0wO2ZvcihsZXQgdCx4PTA7eDxhLmxlbmd0aDt4KyssbSsrKXt0PW4uX19kaWdpdChtKTt2YXIgcT1cbmEuX19kaWdpdCh4KSx6PTMyNzY3JnEscj1xPj4+MTU7cT1nLl9faW11bCh6LGspO3o9Zy5fX2ltdWwoeix1KTtjb25zdCB2PWcuX19pbXVsKHIsayk7cj1nLl9faW11bChyLHUpO3QrPWwrcStjO2M9dD4+PjMwO3QmPTEwNzM3NDE4MjM7dCs9KCgzMjc2NyZ6KTw8MTUpKygoMzI3Njcmdik8PDE1KTtjKz10Pj4+MzA7bD1yKyh6Pj4+MTUpKyh2Pj4+MTUpO24uX19zZXREaWdpdChtLDEwNzM3NDE4MjMmdCl9Zm9yKDswIT1jfHwwIT09bDttKyspYT1uLl9fZGlnaXQobSksYSs9YytsLGw9MCxjPWE+Pj4zMCxuLl9fc2V0RGlnaXQobSwxMDczNzQxODIzJmEpfX1zdGF0aWMgX19pbnRlcm5hbE11bHRpcGx5QWRkKGEsYyxuLG0sayl7bGV0IHU9MDtmb3IobGV0IHo9MDt6PG07eisrKXt2YXIgbD1hLl9fZGlnaXQoeikscT1nLl9faW11bCgzMjc2NyZsLGMpO2w9Zy5fX2ltdWwobD4+PjE1LGMpO3E9cSsoKDMyNzY3JmwpPDwxNSkrdStuO249cT4+PjMwO3U9bD4+PjE1O2suX19zZXREaWdpdCh6LFxuMTA3Mzc0MTgyMyZxKX1pZihrLmxlbmd0aD5tKWZvcihrLl9fc2V0RGlnaXQobSsrLG4rdSk7bTxrLmxlbmd0aDspay5fX3NldERpZ2l0KG0rKywwKTtlbHNlIGlmKDAhPT1uK3UpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7fV9faW5wbGFjZU11bHRpcGx5QWRkKGEsYyxuKXtuPnRoaXMubGVuZ3RoJiYobj10aGlzLmxlbmd0aCk7Y29uc3QgbT0zMjc2NyZhO2E+Pj49MTU7bGV0IGs9MDtmb3IobGV0IHo9MDt6PG47eisrKXt2YXIgdT10aGlzLl9fZGlnaXQoeiksbD0zMjc2NyZ1LHE9dT4+PjE1O3U9Zy5fX2ltdWwobCxtKTtsPWcuX19pbXVsKGwsYSk7Y29uc3Qgcj1nLl9faW11bChxLG0pO3E9Zy5fX2ltdWwocSxhKTt1PWMrdStrO2s9dT4+PjMwO3UmPTEwNzM3NDE4MjM7dSs9KCgzMjc2NyZsKTw8MTUpKygoMzI3Njcmcik8PDE1KTtrKz11Pj4+MzA7Yz1xKyhsPj4+MTUpKyhyPj4+MTUpO3RoaXMuX19zZXREaWdpdCh6LDEwNzM3NDE4MjMmdSl9aWYoMCE9a3x8MCE9PVxuYyl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTt9c3RhdGljIF9fYWJzb2x1dGVEaXZTbWFsbChhLGMsbil7bj12b2lkIDA9PT1uP251bGw6bjtudWxsPT09biYmKG49bmV3IGcoYS5sZW5ndGgsITEpKTtsZXQgbT0wO2ZvcihsZXQgayx1PTIqYS5sZW5ndGgtMTswPD11O3UtPTIpe2s9KG08PDE1fGEuX19oYWxmRGlnaXQodSkpPj4+MDtjb25zdCBsPTB8ay9jO209MHxrJWM7az0obTw8MTV8YS5fX2hhbGZEaWdpdCh1LTEpKT4+PjA7Y29uc3QgcT0wfGsvYzttPTB8ayVjO24uX19zZXREaWdpdCh1Pj4+MSxsPDwxNXxxKX1yZXR1cm4gbn1zdGF0aWMgX19hYnNvbHV0ZU1vZFNtYWxsKGEsYyl7bGV0IG49MDtmb3IobGV0IG09MiphLmxlbmd0aC0xOzA8PW07bS0tKW49MHwoKG48PDE1fGEuX19oYWxmRGlnaXQobSkpPj4+MCklYztyZXR1cm4gbn1zdGF0aWMgX19hYnNvbHV0ZURpdkxhcmdlKGEsYyxuLG0pe2NvbnN0IGs9Yy5fX2hhbGZEaWdpdExlbmd0aCgpLHU9Yy5sZW5ndGg7XG52YXIgbD1hLl9faGFsZkRpZ2l0TGVuZ3RoKCktaztsZXQgcT1udWxsO24mJihxPW5ldyBnKGwrMj4+PjEsITEpLHEuX19pbml0aWFsaXplRGlnaXRzKCkpO2NvbnN0IHo9bmV3IGcoaysyPj4+MSwhMSk7ei5fX2luaXRpYWxpemVEaWdpdHMoKTtjb25zdCByPWcuX19jbHoxNShjLl9faGFsZkRpZ2l0KGstMSkpOzA8ciYmKGM9Zy5fX3NwZWNpYWxMZWZ0U2hpZnQoYyxyLDApKTthPWcuX19zcGVjaWFsTGVmdFNoaWZ0KGEsciwxKTtjb25zdCB0PWMuX19oYWxmRGlnaXQoay0xKTtsZXQgeD0wO2ZvcihsZXQgdixCPWw7MDw9QjtCLS0pe3Y9MzI3Njc7bD1hLl9faGFsZkRpZ2l0KEIrayk7aWYobCE9PXQpe2w9KGw8PDE1fGEuX19oYWxmRGlnaXQoQitrLTEpKT4+PjA7dj0wfGwvdDtsPTB8bCV0O2NvbnN0IEk9Yy5fX2hhbGZEaWdpdChrLTIpLE09YS5fX2hhbGZEaWdpdChCK2stMik7Zm9yKDtnLl9faW11bCh2LEkpPj4+MD4obDw8MTZ8TSk+Pj4wJiYodi0tLGwrPXQsISgzMjc2NzxsKSk7KTtcbn1nLl9faW50ZXJuYWxNdWx0aXBseUFkZChjLHYsMCx1LHopO2w9YS5fX2lucGxhY2VTdWIoeixCLGsrMSk7MCE9PWwmJihsPWEuX19pbnBsYWNlQWRkKGMsQixrKSxhLl9fc2V0SGFsZkRpZ2l0KEIraywzMjc2NyZhLl9faGFsZkRpZ2l0KEIraykrbCksdi0tKTtuJiYoMSZCP3g9djw8MTU6cS5fX3NldERpZ2l0KEI+Pj4xLHh8dikpfWlmKG0pcmV0dXJuIGEuX19pbnBsYWNlUmlnaHRTaGlmdChyKSxuP3txdW90aWVudDpxLHJlbWFpbmRlcjphfTphO2lmKG4pcmV0dXJuIHE7dGhyb3cgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKTt9c3RhdGljIF9fY2x6MTUoYSl7cmV0dXJuIGcuX19jbHozMChhKS0xNX1fX2lucGxhY2VBZGQoYSxjLG4pe2xldCBtPTA7Zm9yKGxldCBrPTA7azxuO2srKyl7Y29uc3QgdT10aGlzLl9faGFsZkRpZ2l0KGMraykrYS5fX2hhbGZEaWdpdChrKSttO209dT4+PjE1O3RoaXMuX19zZXRIYWxmRGlnaXQoYytrLDMyNzY3JnUpfXJldHVybiBtfV9faW5wbGFjZVN1YihhLFxuYyxuKXtsZXQgbT0wO2lmKDEmYyl7Yz4+PTE7Zm9yKHZhciBrPXRoaXMuX19kaWdpdChjKSx1PTMyNzY3JmssbD0wO2w8bi0xPj4+MTtsKyspe3ZhciBxPWEuX19kaWdpdChsKTtrPShrPj4+MTUpLSgzMjc2NyZxKS1tO209MSZrPj4+MTU7dGhpcy5fX3NldERpZ2l0KGMrbCwoMzI3Njcmayk8PDE1fDMyNzY3JnUpO2s9dGhpcy5fX2RpZ2l0KGMrbCsxKTt1PSgzMjc2NyZrKS0ocT4+PjE1KS1tO209MSZ1Pj4+MTV9cT1hLl9fZGlnaXQobCk7Y29uc3Qgej0oaz4+PjE1KS0oMzI3NjcmcSktbTttPTEmej4+PjE1O3RoaXMuX19zZXREaWdpdChjK2wsKDMyNzY3JnopPDwxNXwzMjc2NyZ1KTtpZihjK2wrMT49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgYm91bmRzXCIpOzA9PSgxJm4pJiYoaz10aGlzLl9fZGlnaXQoYytsKzEpLHU9KDMyNzY3JmspLShxPj4+MTUpLW0sbT0xJnU+Pj4xNSx0aGlzLl9fc2V0RGlnaXQoYythLmxlbmd0aCwxMDczNzA5MDU2Jmt8MzI3NjcmXG51KSl9ZWxzZXtjPj49MTtmb3IodT0wO3U8YS5sZW5ndGgtMTt1Kyspaz10aGlzLl9fZGlnaXQoYyt1KSxxPWEuX19kaWdpdCh1KSxsPSgzMjc2NyZrKS0oMzI3NjcmcSktbSxtPTEmbD4+PjE1LGs9KGs+Pj4xNSktKHE+Pj4xNSktbSxtPTEmaz4+PjE1LHRoaXMuX19zZXREaWdpdChjK3UsKDMyNzY3JmspPDwxNXwzMjc2NyZsKTtsPXRoaXMuX19kaWdpdChjK3UpO2E9YS5fX2RpZ2l0KHUpO2s9KDMyNzY3JmwpLSgzMjc2NyZhKS1tO209MSZrPj4+MTU7cT0wOzA9PSgxJm4pJiYocT0obD4+PjE1KS0oYT4+PjE1KS1tLG09MSZxPj4+MTUpO3RoaXMuX19zZXREaWdpdChjK3UsKDMyNzY3JnEpPDwxNXwzMjc2NyZrKX1yZXR1cm4gbX1fX2lucGxhY2VSaWdodFNoaWZ0KGEpe2lmKDAhPT1hKXt2YXIgYz10aGlzLl9fZGlnaXQoMCk+Pj5hLG49dGhpcy5sZW5ndGgtMTtmb3IobGV0IG09MDttPG47bSsrKXtjb25zdCBrPXRoaXMuX19kaWdpdChtKzEpO3RoaXMuX19zZXREaWdpdChtLDEwNzM3NDE4MjMmXG5rPDwzMC1hfGMpO2M9az4+PmF9dGhpcy5fX3NldERpZ2l0KG4sYyl9fXN0YXRpYyBfX3NwZWNpYWxMZWZ0U2hpZnQoYSxjLG4pe2NvbnN0IG09YS5sZW5ndGgsaz1uZXcgZyhtK24sITEpO2lmKDA9PT1jKXtmb3IoYz0wO2M8bTtjKyspay5fX3NldERpZ2l0KGMsYS5fX2RpZ2l0KGMpKTtyZXR1cm4gMDxuJiZrLl9fc2V0RGlnaXQobSwwKSxrfWxldCB1PTA7Zm9yKGxldCBsPTA7bDxtO2wrKyl7Y29uc3QgcT1hLl9fZGlnaXQobCk7ay5fX3NldERpZ2l0KGwsMTA3Mzc0MTgyMyZxPDxjfHUpO3U9cT4+PjMwLWN9cmV0dXJuIDA8biYmay5fX3NldERpZ2l0KG0sdSksa31zdGF0aWMgX19sZWZ0U2hpZnRCeUFic29sdXRlKGEsYyl7dmFyIG49Zy5fX3RvU2hpZnRBbW91bnQoYyk7aWYoMD5uKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7Yz0wfG4vMzA7dmFyIG09biUzMDtjb25zdCBrPWEubGVuZ3RoLHU9MCE9PW0mJjAhPWEuX19kaWdpdChrLTEpPj4+MzAtbTt2YXIgbD1cbmsrYysodT8xOjApO249bmV3IGcobCxhLnNpZ24pO2lmKDA9PT1tKXtmb3IobT0wO208YzttKyspbi5fX3NldERpZ2l0KG0sMCk7Zm9yKDttPGw7bSsrKW4uX19zZXREaWdpdChtLGEuX19kaWdpdChtLWMpKX1lbHNle2w9MDtmb3IodmFyIHE9MDtxPGM7cSsrKW4uX19zZXREaWdpdChxLDApO2ZvcihxPTA7cTxrO3ErKyl7Y29uc3Qgej1hLl9fZGlnaXQocSk7bi5fX3NldERpZ2l0KHErYywxMDczNzQxODIzJno8PG18bCk7bD16Pj4+MzAtbX1pZih1KW4uX19zZXREaWdpdChrK2MsbCk7ZWxzZSBpZigwIT09bCl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTt9cmV0dXJuIG4uX190cmltKCl9c3RhdGljIF9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoYSxjKXt2YXIgbj1hLmxlbmd0aCxtPWEuc2lnbixrPWcuX190b1NoaWZ0QW1vdW50KGMpO2lmKDA+aylyZXR1cm4gZy5fX3JpZ2h0U2hpZnRCeU1heGltdW0obSk7Yz0wfGsvMzA7dmFyIHU9ayUzMCxsPW4tYztpZigwPj1sKXJldHVybiBnLl9fcmlnaHRTaGlmdEJ5TWF4aW11bShtKTtcbms9ITE7aWYobSlpZigwIT0oYS5fX2RpZ2l0KGMpJigxPDx1KS0xKSlrPSEwO2Vsc2UgZm9yKHZhciBxPTA7cTxjO3ErKylpZigwIT09YS5fX2RpZ2l0KHEpKXtrPSEwO2JyZWFrfWsmJjA9PT11JiYwPT1+YS5fX2RpZ2l0KG4tMSkmJmwrKzttPW5ldyBnKGwsbSk7aWYoMD09PXUpZm9yKG0uX19zZXREaWdpdChsLTEsMCksdT1jO3U8bjt1KyspbS5fX3NldERpZ2l0KHUtYyxhLl9fZGlnaXQodSkpO2Vsc2V7bD1hLl9fZGlnaXQoYyk+Pj51O249bi1jLTE7Zm9yKHE9MDtxPG47cSsrKXtjb25zdCB6PWEuX19kaWdpdChxK2MrMSk7bS5fX3NldERpZ2l0KHEsMTA3Mzc0MTgyMyZ6PDwzMC11fGwpO2w9ej4+PnV9bS5fX3NldERpZ2l0KG4sbCl9cmV0dXJuIGsmJihtPWcuX19hYnNvbHV0ZUFkZE9uZShtLCEwLG0pKSxtLl9fdHJpbSgpfXN0YXRpYyBfX3JpZ2h0U2hpZnRCeU1heGltdW0oYSl7cmV0dXJuIGE/Zy5fX29uZURpZ2l0KDEsITApOmcuX196ZXJvKCl9c3RhdGljIF9fdG9TaGlmdEFtb3VudChhKXtpZigxPFxuYS5sZW5ndGgpcmV0dXJuLTE7YT1hLl9fdW5zaWduZWREaWdpdCgwKTtyZXR1cm4gYT5nLl9fa01heExlbmd0aEJpdHM/LTE6YX1zdGF0aWMgX190b1ByaW1pdGl2ZShhLGMpe2M9dm9pZCAwPT09Yz9cImRlZmF1bHRcIjpjO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBhfHxhLmNvbnN0cnVjdG9yPT09ZylyZXR1cm4gYTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlKXtjb25zdCBuPWFbU3ltYm9sLnRvUHJpbWl0aXZlXTtpZihuKXthPW4oYyk7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGEpcmV0dXJuIGE7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7fX1pZihjPWEudmFsdWVPZilpZihjPWMuY2FsbChhKSxcIm9iamVjdFwiIT10eXBlb2YgYylyZXR1cm4gYztpZihjPWEudG9TdHJpbmcpaWYoYT1jLmNhbGwoYSksXCJvYmplY3RcIiE9dHlwZW9mIGEpcmV0dXJuIGE7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59c3RhdGljIF9fdG9OdW1lcmljKGEpe3JldHVybiBnLl9faXNCaWdJbnQoYSk/YTorYX1zdGF0aWMgX19pc0JpZ0ludChhKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuY29uc3RydWN0b3I9PT1nfXN0YXRpYyBfX3RydW5jYXRlVG9OQml0cyhhLGMpe3ZhciBuPTB8KGErMjkpLzMwO2NvbnN0IG09bmV3IGcobixjLnNpZ24pOy0tbjtmb3IobGV0IGs9MDtrPG47aysrKW0uX19zZXREaWdpdChrLGMuX19kaWdpdChrKSk7Yz1jLl9fZGlnaXQobik7MCE9YSUzMCYmKGE9MzItYSUzMCxjPWM8PGE+Pj5hKTtyZXR1cm4gbS5fX3NldERpZ2l0KG4sYyksbS5fX3RyaW0oKX1zdGF0aWMgX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGEsYyxuKXt2YXIgbT1NYXRoLm1pbixrPTB8KGErMjkpLzMwO249bmV3IGcoayxuKTtsZXQgdT0wOy0tazt2YXIgbD0wO2ZvcihtPW0oayxjLmxlbmd0aCk7dTxtO3UrKyl7Y29uc3QgcT0wLWMuX19kaWdpdCh1KS1sO2w9MSZxPj4+XG4zMDtuLl9fc2V0RGlnaXQodSwxMDczNzQxODIzJnEpfWZvcig7dTxrO3UrKyluLl9fc2V0RGlnaXQodSwwfDEwNzM3NDE4MjMmLWwpO2M9azxjLmxlbmd0aD9jLl9fZGlnaXQoayk6MDthJT0zMDswPT1hP2w9MC1jLWwmMTA3Mzc0MTgyMzooYT0zMi1hLGM9Yzw8YT4+PmEsYT0xPDwzMi1hLGw9YS1jLWwsbCY9YS0xKTtyZXR1cm4gbi5fX3NldERpZ2l0KGssbCksbi5fX3RyaW0oKX1fX2RpZ2l0KGEpe3JldHVybiB0aGlzW2FdfV9fdW5zaWduZWREaWdpdChhKXtyZXR1cm4gdGhpc1thXT4+PjB9X19zZXREaWdpdChhLGMpe3RoaXNbYV09MHxjfV9fc2V0RGlnaXRHcm93KGEsYyl7dGhpc1thXT0wfGN9X19oYWxmRGlnaXRMZW5ndGgoKXtjb25zdCBhPXRoaXMubGVuZ3RoO3JldHVybiAzMjc2Nz49dGhpcy5fX3Vuc2lnbmVkRGlnaXQoYS0xKT8yKmEtMToyKmF9X19oYWxmRGlnaXQoYSl7cmV0dXJuIDMyNzY3JnRoaXNbYT4+PjFdPj4+MTUqKDEmYSl9X19zZXRIYWxmRGlnaXQoYSxjKXtjb25zdCBuPVxuYT4+PjEsbT10aGlzLl9fZGlnaXQobik7dGhpcy5fX3NldERpZ2l0KG4sMSZhPzMyNzY3Jm18Yzw8MTU6MTA3MzcwOTA1NiZtfDMyNzY3JmMpfXN0YXRpYyBfX2RpZ2l0UG93KGEsYyl7bGV0IG49MTtmb3IoOzA8YzspMSZjJiYobio9YSksYz4+Pj0xLGEqPWE7cmV0dXJuIG59c3RhdGljIF9faXNPbmVEaWdpdEludChhKXtyZXR1cm4oMTA3Mzc0MTgyMyZhKT09PWF9fXJldHVybiBnLl9fa01heExlbmd0aD0zMzU1NDQzMixnLl9fa01heExlbmd0aEJpdHM9Zy5fX2tNYXhMZW5ndGg8PDUsZy5fX2tNYXhCaXRzUGVyQ2hhcj1bMCwwLDMyLDUxLDY0LDc1LDgzLDkwLDk2LDEwMiwxMDcsMTExLDExNSwxMTksMTIyLDEyNiwxMjgsMTMxLDEzNCwxMzYsMTM5LDE0MSwxNDMsMTQ1LDE0NywxNDksMTUxLDE1MywxNTQsMTU2LDE1OCwxNTksMTYwLDE2MiwxNjMsMTY1LDE2Nl0sZy5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQ9NSxnLl9fa0JpdHNQZXJDaGFyVGFibGVNdWx0aXBsaWVyPTE8PGcuX19rQml0c1BlckNoYXJUYWJsZVNoaWZ0LFxuZy5fX2tDb252ZXJzaW9uQ2hhcnM9XCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5zcGxpdChcIlwiKSxnLl9fa0JpdENvbnZlcnNpb25CdWZmZXI9bmV3IEFycmF5QnVmZmVyKDgpLGcuX19rQml0Q29udmVyc2lvbkRvdWJsZT1uZXcgRmxvYXQ2NEFycmF5KGcuX19rQml0Q29udmVyc2lvbkJ1ZmZlciksZy5fX2tCaXRDb252ZXJzaW9uSW50cz1uZXcgSW50MzJBcnJheShnLl9fa0JpdENvbnZlcnNpb25CdWZmZXIpLGcuX19jbHozMD1kP2Z1bmN0aW9uKGEpe3JldHVybiBkKGEpLTJ9OmZ1bmN0aW9uKGEpe3ZhciBjPU1hdGguTE4yLG49TWF0aC5sb2c7cmV0dXJuIDA9PT1hPzMwOjB8MjktKDB8bihhPj4+MCkvYyl9LGcuX19pbXVsPWV8fGZ1bmN0aW9uKGEsYyl7cmV0dXJuIDB8YSpjfSxnfSl9LGZ1bmN0aW9uKEYsUCl7Wy4uLlwiYWJjXCJdLmZsYXQoKTtcImFcIi5tYXRjaEFsbCgvYS9nKX0sZnVuY3Rpb24oRixQLGIpeyhmdW5jdGlvbihlLGQpeyhmdW5jdGlvbihmLGgpe2Z1bmN0aW9uIHAodil7ZGVsZXRlIHFbdl19XG5mdW5jdGlvbiBnKHYpe2lmKHopc2V0VGltZW91dChnLDAsdik7ZWxzZXt2YXIgQj1xW3ZdO2lmKEIpe3o9ITA7dHJ5e3ZhciBJPUIuY2FsbGJhY2ssTT1CLmFyZ3M7c3dpdGNoKE0ubGVuZ3RoKXtjYXNlIDA6SSgpO2JyZWFrO2Nhc2UgMTpJKE1bMF0pO2JyZWFrO2Nhc2UgMjpJKE1bMF0sTVsxXSk7YnJlYWs7Y2FzZSAzOkkoTVswXSxNWzFdLE1bMl0pO2JyZWFrO2RlZmF1bHQ6SS5hcHBseShoLE0pfX1maW5hbGx5e3Aodiksej0hMX19fX1mdW5jdGlvbiBhKCl7dD1mdW5jdGlvbih2KXtkLm5leHRUaWNrKGZ1bmN0aW9uKCl7Zyh2KX0pfX1mdW5jdGlvbiBjKCl7aWYoZi5wb3N0TWVzc2FnZSYmIWYuaW1wb3J0U2NyaXB0cyl7dmFyIHY9ITAsQj1mLm9ubWVzc2FnZTtmLm9ubWVzc2FnZT1mdW5jdGlvbigpe3Y9ITF9O2YucG9zdE1lc3NhZ2UoXCJcIixcIipcIik7Zi5vbm1lc3NhZ2U9QjtyZXR1cm4gdn19ZnVuY3Rpb24gbigpe3ZhciB2PVwic2V0SW1tZWRpYXRlJFwiK01hdGgucmFuZG9tKCkrXG5cIiRcIixCPWZ1bmN0aW9uKEkpe0kuc291cmNlPT09ZiYmXCJzdHJpbmdcIj09PXR5cGVvZiBJLmRhdGEmJjA9PT1JLmRhdGEuaW5kZXhPZih2KSYmZygrSS5kYXRhLnNsaWNlKHYubGVuZ3RoKSl9O2YuYWRkRXZlbnRMaXN0ZW5lcj9mLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsQiwhMSk6Zi5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLEIpO3Q9ZnVuY3Rpb24oSSl7Zi5wb3N0TWVzc2FnZSh2K0ksXCIqXCIpfX1mdW5jdGlvbiBtKCl7dmFyIHY9bmV3IE1lc3NhZ2VDaGFubmVsO3YucG9ydDEub25tZXNzYWdlPWZ1bmN0aW9uKEIpe2coQi5kYXRhKX07dD1mdW5jdGlvbihCKXt2LnBvcnQyLnBvc3RNZXNzYWdlKEIpfX1mdW5jdGlvbiBrKCl7dmFyIHY9ci5kb2N1bWVudEVsZW1lbnQ7dD1mdW5jdGlvbihCKXt2YXIgST1yLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7SS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtnKEIpO0kub25yZWFkeXN0YXRlY2hhbmdlPW51bGw7di5yZW1vdmVDaGlsZChJKTtcbkk9bnVsbH07di5hcHBlbmRDaGlsZChJKX19ZnVuY3Rpb24gdSgpe3Q9ZnVuY3Rpb24odil7c2V0VGltZW91dChnLDAsdil9fWlmKCFmLnNldEltbWVkaWF0ZSl7dmFyIGw9MSxxPXt9LHo9ITEscj1mLmRvY3VtZW50LHQseD1PYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihmKTt4PXgmJnguc2V0VGltZW91dD94OmY7XCJbb2JqZWN0IHByb2Nlc3NdXCI9PT17fS50b1N0cmluZy5jYWxsKGYucHJvY2Vzcyk/YSgpOmMoKT9uKCk6Zi5NZXNzYWdlQ2hhbm5lbD9tKCk6ciYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluIHIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKT9rKCk6dSgpO3guc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKHYpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiB2JiYodj1uZXcgRnVuY3Rpb24oXCJcIit2KSk7Zm9yKHZhciBCPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksST0wO0k8Qi5sZW5ndGg7SSsrKUJbSV09YXJndW1lbnRzW0krMV07cVtsXT17Y2FsbGJhY2s6dixcbmFyZ3M6Qn07dChsKTtyZXR1cm4gbCsrfTt4LmNsZWFySW1tZWRpYXRlPXB9fSkoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBzZWxmP1widW5kZWZpbmVkXCI9PT10eXBlb2YgZT90aGlzOmU6c2VsZil9KS5jYWxsKHRoaXMsYigwKSxiKDgpKX0sZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKCl7dGhyb3cgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO31mdW5jdGlvbiBlKCl7dGhyb3cgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7fWZ1bmN0aW9uIGQocSl7aWYoYz09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQocSwwKTtpZigoYz09PWJ8fCFjKSYmc2V0VGltZW91dClyZXR1cm4gYz1zZXRUaW1lb3V0LHNldFRpbWVvdXQocSwwKTt0cnl7cmV0dXJuIGMocSwwKX1jYXRjaCh6KXt0cnl7cmV0dXJuIGMuY2FsbChudWxsLHEsMCl9Y2F0Y2gocil7cmV0dXJuIGMuY2FsbCh0aGlzLHEsMCl9fX1mdW5jdGlvbiBmKHEpe2lmKG49PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dChxKTtcbmlmKChuPT09ZXx8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChxKTt0cnl7cmV0dXJuIG4ocSl9Y2F0Y2goeil7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxxKX1jYXRjaChyKXtyZXR1cm4gbi5jYWxsKHRoaXMscSl9fX1mdW5jdGlvbiBoKCl7ayYmdSYmKGs9ITEsdS5sZW5ndGg/bT11LmNvbmNhdChtKTpsPS0xLG0ubGVuZ3RoJiZwKCkpfWZ1bmN0aW9uIHAoKXtpZighayl7dmFyIHE9ZChoKTtrPSEwO2Zvcih2YXIgej1tLmxlbmd0aDt6Oyl7dT1tO2ZvcihtPVtdOysrbDx6Oyl1JiZ1W2xdLnJ1bigpO2w9LTE7ej1tLmxlbmd0aH11PW51bGw7az0hMTtmKHEpfX1mdW5jdGlvbiBnKHEseil7dGhpcy5mdW49cTt0aGlzLmFycmF5PXp9ZnVuY3Rpb24gYSgpe31GPUYuZXhwb3J0cz17fTt0cnl7dmFyIGM9XCJmdW5jdGlvblwiPT09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpifWNhdGNoKHEpe2M9Yn10cnl7dmFyIG49XCJmdW5jdGlvblwiPT09XG50eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDplfWNhdGNoKHEpe249ZX12YXIgbT1bXSxrPSExLHUsbD0tMTtGLm5leHRUaWNrPWZ1bmN0aW9uKHEpe3ZhciB6PUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoMTxhcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspeltyLTFdPWFyZ3VtZW50c1tyXTttLnB1c2gobmV3IGcocSx6KSk7MSE9PW0ubGVuZ3RofHxrfHxkKHApfTtnLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTtGLnRpdGxlPVwiYnJvd3NlclwiO0YuYnJvd3Nlcj0hMDtGLmVudj17fTtGLmFyZ3Y9W107Ri52ZXJzaW9uPVwiXCI7Ri52ZXJzaW9ucz17fTtGLm9uPWE7Ri5hZGRMaXN0ZW5lcj1hO0Yub25jZT1hO0Yub2ZmPWE7Ri5yZW1vdmVMaXN0ZW5lcj1hO0YucmVtb3ZlQWxsTGlzdGVuZXJzPWE7Ri5lbWl0PWE7Ri5wcmVwZW5kTGlzdGVuZXI9YTtGLnByZXBlbmRPbmNlTGlzdGVuZXI9XG5hO0YubGlzdGVuZXJzPWZ1bmN0aW9uKHEpe3JldHVybltdfTtGLmJpbmRpbmc9ZnVuY3Rpb24ocSl7dGhyb3cgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKTt9O0YuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O0YuY2hkaXI9ZnVuY3Rpb24ocSl7dGhyb3cgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIik7fTtGLnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbihGLFApe1NrLmFzc2VydHM9e307U2suYXNzZXJ0cy5hc3NlcnQ9ZnVuY3Rpb24oYixlKXtyZXR1cm4gYn07U2suZXhwb3J0U3ltYm9sKFwiU2suYXNzZXJ0cy5hc3NlcnRcIixTay5hc3NlcnRzLmFzc2VydCk7U2suYXNzZXJ0cy5mYWlsPWZ1bmN0aW9uKGIpe307U2suZXhwb3J0U3ltYm9sKFwiU2suYXNzZXJ0cy5mYWlsXCIsU2suYXNzZXJ0cy5mYWlsKX0sZnVuY3Rpb24oRixQKXtTay5ib29sX2NoZWNrPWZ1bmN0aW9uKGIsZSl7aWYodm9pZCAwPT09Ynx8bnVsbD09PVxuYnx8XCJib29sZWFuXCIhPT10eXBlb2YgYil0aHJvdyBFcnJvcihcIm11c3Qgc3BlY2lmeSBcIitlK1wiIGFuZCBpdCBtdXN0IGJlIGEgYm9vbGVhblwiKTt9O1NrLnB5dGhvbjI9e3ByaW50X2Z1bmN0aW9uOiExLGRpdmlzaW9uOiExLGFic29sdXRlX2ltcG9ydDpudWxsLHVuaWNvZGVfbGl0ZXJhbHM6ITEscHl0aG9uMzohMSxjbGFzc19yZXByOiExLGluaGVyaXRfZnJvbV9vYmplY3Q6ITEsc3VwZXJfYXJnczohMSxvY3RhbF9udW1iZXJfbGl0ZXJhbDohMSxiYW5rZXJzX3JvdW5kaW5nOiExLHB5dGhvbl92ZXJzaW9uOiExLGR1bmRlcl9yb3VuZDohMSxleGNlcHRpb25zOiExLG5vX2xvbmdfdHlwZTohMSxjZWlsX2Zsb29yX2ludDohMSxzaWxlbnRfb2N0YWxfbGl0ZXJhbDohMH07U2sucHl0aG9uMz17cHJpbnRfZnVuY3Rpb246ITAsZGl2aXNpb246ITAsYWJzb2x1dGVfaW1wb3J0Om51bGwsdW5pY29kZV9saXRlcmFsczohMCxweXRob24zOiEwLGNsYXNzX3JlcHI6ITAsaW5oZXJpdF9mcm9tX29iamVjdDohMCxcbnN1cGVyX2FyZ3M6ITAsb2N0YWxfbnVtYmVyX2xpdGVyYWw6ITAsYmFua2Vyc19yb3VuZGluZzohMCxweXRob25fdmVyc2lvbjohMCxkdW5kZXJfcm91bmQ6ITAsZXhjZXB0aW9uczohMCxub19sb25nX3R5cGU6ITAsY2VpbF9mbG9vcl9pbnQ6ITAsc2lsZW50X29jdGFsX2xpdGVyYWw6ITF9O1NrLmNvbmZpZ3VyZT1mdW5jdGlvbihiKXtTay5vdXRwdXQ9Yi5vdXRwdXR8fFNrLm91dHB1dDtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2sub3V0cHV0KTtTay5maWxld3JpdGVyPWIuZmlsZXdyaXRlcnx8U2suZmlsZXdyaXRlcjtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suZmlsZXdyaXRlcik7U2suZGVidWdvdXQ9Yi5kZWJ1Z291dHx8U2suZGVidWdvdXQ7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLmRlYnVnb3V0KTtTay51bmNhdWdodEV4Y2VwdGlvbj1iLnVuY2F1Z2h0RXhjZXB0aW9ufHxTay51bmNhdWdodEV4Y2VwdGlvbjtcblNrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay51bmNhdWdodEV4Y2VwdGlvbik7U2sucmVhZD1iLnJlYWR8fFNrLnJlYWQ7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLnJlYWQpO1NrLm5vbnJlYWRvcGVuPWIubm9ucmVhZG9wZW58fCExO1NrLmFzc2VydHMuYXNzZXJ0KFwiYm9vbGVhblwiPT09dHlwZW9mIFNrLm5vbnJlYWRvcGVuKTtTay5maWxlb3Blbj1iLmZpbGVvcGVufHx2b2lkIDA7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLmZpbGVvcGVufHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIFNrLmZpbGVvcGVuKTtTay5maWxld3JpdGU9Yi5maWxld3JpdGV8fHZvaWQgMDtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suZmlsZXdyaXRlfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIFNrLmZpbGV3cml0ZSk7U2sudGltZW91dE1zZz1iLnRpbWVvdXRNc2d8fFNrLnRpbWVvdXRNc2c7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09XG50eXBlb2YgU2sudGltZW91dE1zZyk7U2suZXhwb3J0U3ltYm9sKFwiU2sudGltZW91dE1zZ1wiLFNrLnRpbWVvdXRNc2cpO1NrLnN5c2FyZ3Y9Yi5zeXNhcmd2fHxTay5zeXNhcmd2O1NrLmFzc2VydHMuYXNzZXJ0KFNrLmlzQXJyYXlMaWtlKFNrLnN5c2FyZ3YpKTtTay5fX2Z1dHVyZV9fPWIuX19mdXR1cmVfX3x8U2sucHl0aG9uMztTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18ucHJpbnRfZnVuY3Rpb24sXCJTay5fX2Z1dHVyZV9fLnByaW50X2Z1bmN0aW9uXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5kaXZpc2lvbixcIlNrLl9fZnV0dXJlX18uZGl2aXNpb25cIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLnVuaWNvZGVfbGl0ZXJhbHMsXCJTay5fX2Z1dHVyZV9fLnVuaWNvZGVfbGl0ZXJhbHNcIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLmNsYXNzX3JlcHIsXCJTay5fX2Z1dHVyZV9fLmNsYXNzX3JlcHJcIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLmluaGVyaXRfZnJvbV9vYmplY3QsXG5cIlNrLl9fZnV0dXJlX18uaW5oZXJpdF9mcm9tX29iamVjdFwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uc3VwZXJfYXJncyxcIlNrLl9fZnV0dXJlX18uc3VwZXJfYXJnc1wiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18ub2N0YWxfbnVtYmVyX2xpdGVyYWwsXCJTay5fX2Z1dHVyZV9fLm9jdGFsX251bWJlcl9saXRlcmFsXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nLFwiU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5weXRob25fdmVyc2lvbixcIlNrLl9fZnV0dXJlX18ucHl0aG9uX3ZlcnNpb25cIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLmR1bmRlcl9yb3VuZCxcIlNrLl9fZnV0dXJlX18uZHVuZGVyX3JvdW5kXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5leGNlcHRpb25zLFwiU2suX19mdXR1cmVfXy5leGNlcHRpb25zXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5ub19sb25nX3R5cGUsXG5cIlNrLl9fZnV0dXJlX18ubm9fbG9uZ190eXBlXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5jZWlsX2Zsb29yX2ludCxcIlNrLl9fZnV0dXJlX18uY2VpbF9mbG9vcl9pbnRcIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLnNpbGVudF9vY3RhbF9saXRlcmFsLFwiU2suX19mdXR1cmVfXy5zaWxlbnRfb2N0YWxfbGl0ZXJhbFwiKTtTay5pbWFnZVByb3h5PWIuaW1hZ2VQcm94eXx8XCJodHRwOi8vbG9jYWxob3N0OjgwODAvMzIweFwiO1NrLmFzc2VydHMuYXNzZXJ0KFwic3RyaW5nXCI9PT10eXBlb2YgU2suaW1hZ2VQcm94eXx8XCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLmltYWdlUHJveHkpO1NrLmlucHV0ZnVuPWIuaW5wdXRmdW58fFNrLmlucHV0ZnVuO1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5pbnB1dGZ1bik7U2suaW5wdXRmdW5UYWtlc1Byb21wdD1iLmlucHV0ZnVuVGFrZXNQcm9tcHR8fCExO1NrLmFzc2VydHMuYXNzZXJ0KFwiYm9vbGVhblwiPT09XG50eXBlb2YgU2suaW5wdXRmdW5UYWtlc1Byb21wdCk7U2sucmV0YWluR2xvYmFscz1iLnJldGFpbmdsb2JhbHN8fGIucmV0YWluR2xvYmFsc3x8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2sucmV0YWluR2xvYmFscyk7U2suZGVidWdnaW5nPWIuZGVidWdnaW5nfHwhMTtTay5hc3NlcnRzLmFzc2VydChcImJvb2xlYW5cIj09PXR5cGVvZiBTay5kZWJ1Z2dpbmcpO1NrLmtpbGxhYmxlV2hpbGU9Yi5raWxsYWJsZVdoaWxlfHwhMTtTay5hc3NlcnRzLmFzc2VydChcImJvb2xlYW5cIj09PXR5cGVvZiBTay5raWxsYWJsZVdoaWxlKTtTay5raWxsYWJsZUZvcj1iLmtpbGxhYmxlRm9yfHwhMTtTay5hc3NlcnRzLmFzc2VydChcImJvb2xlYW5cIj09PXR5cGVvZiBTay5raWxsYWJsZUZvcik7U2suc2lnbmFscz1iLnNpZ25hbHM7U2suc2lnbmFscz0hMD09PVNrLnNpZ25hbHM/e2xpc3RlbmVyczpbXSxhZGRFdmVudExpc3RlbmVyKGUpe1NrLnNpZ25hbHMubGlzdGVuZXJzLnB1c2goZSl9LFxucmVtb3ZlRXZlbnRMaXN0ZW5lcihlKXtlPVNrLnNpZ25hbHMubGlzdGVuZXJzLmluZGV4T2YoZSk7MDw9ZSYmU2suc2lnbmFscy5saXN0ZW5lcnMuc3BsaWNlKGUsMSl9LHNpZ25hbChlLGQpe2Zvcih2YXIgZj0wO2Y8U2suc2lnbmFscy5saXN0ZW5lcnMubGVuZ3RoO2YrKylTay5zaWduYWxzLmxpc3RlbmVyc1tmXS5jYWxsKG51bGwsZSxkKX19Om51bGw7U2suYXNzZXJ0cy5hc3NlcnQoXCJvYmplY3RcIj09PXR5cGVvZiBTay5zaWduYWxzKTtTay5icmVha3BvaW50cz1iLmJyZWFrcG9pbnRzfHxmdW5jdGlvbigpe3JldHVybiEwfTtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suYnJlYWtwb2ludHMpO1NrLnNldFRpbWVvdXQ9Yi5zZXRUaW1lb3V0O3ZvaWQgMD09PVNrLnNldFRpbWVvdXQmJihTay5zZXRUaW1lb3V0PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBzZXRUaW1lb3V0P2Z1bmN0aW9uKGUsZCl7c2V0VGltZW91dChlLGQpfTpmdW5jdGlvbihlLGQpe2UoKX0pO1xuU2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLnNldFRpbWVvdXQpO1wiZXhlY0xpbWl0XCJpbiBiJiYoU2suZXhlY0xpbWl0PWIuZXhlY0xpbWl0KTtcInlpZWxkTGltaXRcImluIGImJihTay55aWVsZExpbWl0PWIueWllbGRMaW1pdCk7Yi5zeXNwYXRoJiYoU2suc3lzcGF0aD1iLnN5c3BhdGgsU2suYXNzZXJ0cy5hc3NlcnQoU2suaXNBcnJheUxpa2UoU2suc3lzcGF0aCkpLFNrLnJlYWxzeXNwYXRoPXZvaWQgMCxTay5zeXNtb2R1bGVzPW5ldyBTay5idWlsdGluLmRpY3QoW10pKTtTay5taXNjZXZhbC5zb2Z0c3BhY2VfPSExO1NrLnN3aXRjaF92ZXJzaW9uKFNrLl9fZnV0dXJlX18ucHl0aG9uMyk7U2suYnVpbHRpbi5zdHIuJG5leHQ9U2suX19mdXR1cmVfXy5weXRob24zP25ldyBTay5idWlsdGluLnN0cihcIl9fbmV4dF9fXCIpOm5ldyBTay5idWlsdGluLnN0cihcIm5leHRcIik7U2suc2V0dXBPcGVyYXRvcnMoU2suX19mdXR1cmVfXy5weXRob24zKTtTay5zZXR1cER1bmRlck1ldGhvZHMoU2suX19mdXR1cmVfXy5weXRob24zKTtcblNrLnNldHVwT2JqZWN0cyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO1NrLnRva2VuLnNldHVwVG9rZW5zKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmNvbmZpZ3VyZVwiLFNrLmNvbmZpZ3VyZSk7U2sudW5jYXVnaHRFeGNlcHRpb249ZnVuY3Rpb24oYil7dGhyb3cgYjt9O1NrLnVuY2F1Z2h0RXhjZXB0aW9uPWZ1bmN0aW9uKGIpe3Rocm93IGI7fTtTay5leHBvcnRTeW1ib2woXCJTay51bmNhdWdodEV4Y2VwdGlvblwiLFNrLnVuY2F1Z2h0RXhjZXB0aW9uKTtTay50aW1lb3V0TXNnPWZ1bmN0aW9uKCl7cmV0dXJuXCJQcm9ncmFtIGV4Y2VlZGVkIHJ1biB0aW1lIGxpbWl0LlwifTtTay5leHBvcnRTeW1ib2woXCJTay50aW1lb3V0TXNnXCIsU2sudGltZW91dE1zZyk7U2suZXhlY0xpbWl0PU51bWJlci5QT1NJVElWRV9JTkZJTklUWTtTay55aWVsZExpbWl0PU51bWJlci5QT1NJVElWRV9JTkZJTklUWTtTay5vdXRwdXQ9ZnVuY3Rpb24oYil7fTtTay5yZWFkPWZ1bmN0aW9uKGIpe2lmKHZvaWQgMD09PVxuU2suYnVpbHRpbkZpbGVzKXRocm93XCJza3VscHQtc3RkbGliLmpzIGhhcyBub3QgYmVlbiBsb2FkZWRcIjtpZih2b2lkIDA9PT1Tay5idWlsdGluRmlsZXMuZmlsZXNbYl0pdGhyb3dcIkZpbGUgbm90IGZvdW5kOiAnXCIrYitcIidcIjtyZXR1cm4gU2suYnVpbHRpbkZpbGVzLmZpbGVzW2JdfTtTay5zeXNhcmd2PVtdO1NrLmdldFN5c0FyZ3Y9ZnVuY3Rpb24oKXtyZXR1cm4gU2suc3lzYXJndn07U2suZXhwb3J0U3ltYm9sKFwiU2suZ2V0U3lzQXJndlwiLFNrLmdldFN5c0FyZ3YpO1NrLnN5c3BhdGg9W107U2suaW5Ccm93c2VyPXZvaWQgMCE9PVNrLmdsb2JhbC5kb2N1bWVudDtTay5kZWJ1Z291dD1mdW5jdGlvbihiKXt9OyhmdW5jdGlvbigpe3ZvaWQgMCE9PVNrLmdsb2JhbC53cml0ZT8oU2sub3V0cHV0PVNrLmdsb2JhbC53cml0ZSxTay5maWxld3JpdGVyPVNrLmdsb2JhbC53cml0ZSk6dm9pZCAwIT09U2suZ2xvYmFsLmNvbnNvbGUmJnZvaWQgMCE9PVNrLmdsb2JhbC5jb25zb2xlLmxvZz9cbihTay5vdXRwdXQ9ZnVuY3Rpb24oYil7U2suZ2xvYmFsLmNvbnNvbGUubG9nKGIpfSxTay5maWxld3JpdGVyPVNrLm91dHB1dCk6dm9pZCAwIT09U2suZ2xvYmFsLnByaW50JiYoU2sub3V0cHV0PVNrLmdsb2JhbC5wcmludCxTay5maWxld3JpdGVyPVNrLm91dHB1dCk7dm9pZCAwIT09U2suZ2xvYmFsLmNvbnNvbGUmJnZvaWQgMCE9PVNrLmdsb2JhbC5jb25zb2xlLmxvZz9Tay5kZWJ1Z291dD1mdW5jdGlvbihiKXtTay5nbG9iYWwuY29uc29sZS5sb2coYil9OnZvaWQgMCE9PVNrLmdsb2JhbC5wcmludCYmKFNrLmRlYnVnb3V0PVNrLmdsb2JhbC5wcmludCl9KSgpO1NrLmlucHV0ZnVuPWZ1bmN0aW9uKGIpe3JldHVybiB3aW5kb3cucHJvbXB0KGIpfTtTay5zZXR1cF9tZXRob2RfbWFwcGluZ3M9ZnVuY3Rpb24oKXt9O1NrLnNldHVwRGljdEl0ZXJhdG9ycz1mdW5jdGlvbihiKXt9O1NrLnN3aXRjaF92ZXJzaW9uPWZ1bmN0aW9uKGIpe2NvbnN0IGU9e2Zsb2F0Xzp7bWV0aG9kX25hbWVzOltcIl9fcm91bmRfX1wiXSxcbjI6WyExXSwzOlshMF19LGludF86e21ldGhvZF9uYW1lczpbXCJfX3JvdW5kX19cIl0sMjpbITFdLDM6WyEwXX0sbGlzdDp7bWV0aG9kX25hbWVzOltcImNsZWFyXCIsXCJjb3B5XCIsXCJzb3J0XCJdLDI6WyExLCExLCEwXSwzOlshMCwhMCwhMF19LGRpY3Q6e21ldGhvZF9uYW1lczpbXCJoYXNfa2V5XCIsXCJrZXlzXCIsXCJpdGVtc1wiLFwidmFsdWVzXCJdLDI6WyEwLCEwLCEwLCEwXSwzOlshMSwhMCwhMCwhMF19fTtmb3IobGV0IHAgaW4gZSl7Y29uc3QgZz1Tay5idWlsdGluW3BdLGE9ZVtwXS5tZXRob2RfbmFtZXM7dmFyIGQ9ZVtwXVszXTtpZihiJiZ2b2lkIDA9PT1nLnB5MyRtZXRob2RzKWJyZWFrO2Vsc2UgaWYodm9pZCAwPT09Zy5weTMkbWV0aG9kcyl7Zy5weTMkbWV0aG9kcz17fTtmb3IodmFyIGY9MDtmPGEubGVuZ3RoO2YrKyl7dmFyIGg9YVtmXTtkW2ZdJiYoZy5weTMkbWV0aG9kc1toXT1nLnByb3RvdHlwZVtoXS5kJGRlZil9fWI/Zj1nLnB5MyRtZXRob2RzOihkPWVbcF1bMl0sZj1nLnB5MiRtZXRob2RzKTtcbmZvcihoPTA7aDxhLmxlbmd0aDtoKyspe2NvbnN0IGM9YVtoXTtkZWxldGUgZy5wcm90b3R5cGVbY107ZFtoXSYmKGcucHJvdG90eXBlW2NdPW5ldyBTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yKGcsZltjXSkpfX19O1NrLmV4cG9ydFN5bWJvbChcIlNrLl9fZnV0dXJlX19cIixTay5fX2Z1dHVyZV9fKTtTay5leHBvcnRTeW1ib2woXCJTay5pbnB1dGZ1blwiLFNrLmlucHV0ZnVuKX0sZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKGssdSxsKXtpZihrLmhhc093blByb3BlcnR5KHUpKXtjb25zdCBxPWtbdV07cSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZnVuYyYmKGtbdV09bmV3IFNrLmJ1aWx0aW5bbF0ocSkpfX1mdW5jdGlvbiBlKGspe3JldHVybiB0aGlzLnByb3RvdHlwZVtrLiRtYW5nbGVkXX1mdW5jdGlvbiBkKGspe2s9ay4kbWFuZ2xlZDtjb25zdCB1PXRoaXMucHJvdG90eXBlLnRwJG1ybztmb3IobGV0IGw9MDtsPHUubGVuZ3RoOysrbCl7Y29uc3QgcT11W2xdLnByb3RvdHlwZTtcbmlmKHEuaGFzT3duUHJvcGVydHkoaykpcmV0dXJuIHFba119fWZ1bmN0aW9uIGYoayx1LGwscSl7Y29uc3Qgej1oKGwpLHI9dS5wcm90b3R5cGU7U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZShrLHUseixxKTtrPW5ldyBTay5idWlsdGluLnN0cihrKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyLHtzayRwcm90b3R5cGljYWw6e3ZhbHVlOiEwLHdyaXRhYmxlOiEwfSx0cCRiYXNlczp7dmFsdWU6bCx3cml0YWJsZTohMH0sdHAkbXJvOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSxodCR0eXBlOnt2YWx1ZTohMCx3cml0YWJsZTohMH0saHQkbmFtZTp7dmFsdWU6ayx3cml0YWJsZTohMH0saHQkcXVhbG5hbWU6e3ZhbHVlOmssd3JpdGFibGU6ITB9fSk7ci50cCRtcm89dS4kYnVpbGRNUk8oKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh1LHskdHlwZUxvb2t1cDp7dmFsdWU6ci5zayRwcm90b3R5cGljYWw/ZTpkLHdyaXRhYmxlOiEwfSxzayRrbGFzczp7dmFsdWU6ITAsd3JpdGFibGU6ITB9fSl9XG5mdW5jdGlvbiBoKGspe2Z1bmN0aW9uIHUodCl7cmV0dXJuIHQuc2skc29saWRCYXNlfHx0LnNrJHNvbGlkU2xvdEJhc2U/dDp1KHQucHJvdG90eXBlLnRwJGJhc2UpfTA9PT1rLmxlbmd0aCYmay5wdXNoKFNrLmJ1aWx0aW4ub2JqZWN0KTtsZXQgbCxxLHoscjtmb3IobGV0IHQ9MDt0PGsubGVuZ3RoO3QrKyl7cj1rW3RdO2lmKCFTay5idWlsdGluLmNoZWNrQ2xhc3MocikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFzZXMgbXVzdCBiZSAndHlwZScgb2JqZWN0c1wiKTtpZihyLnNrJHVuYWNjZXB0YWJsZUJhc2UpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZSAnXCIrci5wcm90b3R5cGUudHAkbmFtZStcIicgaXMgbm90IGFuIGFjY2VwdGFibGUgYmFzZSB0eXBlXCIpO3o9dShyKTtpZih2b2lkIDA9PT1xKXE9eixsPXI7ZWxzZSBpZighcS4kaXNTdWJUeXBlKHopKWlmKHouJGlzU3ViVHlwZShxKSlxPXosbD1yO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibXVsdGlwbGUgYmFzZXMgaGF2ZSBpbnN0YW5jZSBsYXlvdXQgY29uZmxpY3RzXCIpO1xufXJldHVybiBsfWZ1bmN0aW9uIHAoayx1KXtjb25zdCBsPXUucHJvdG90eXBlLHE9bC5zayRuc2xvdHN8fDA7T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsXCJzayRuc2xvdHNcIix7dmFsdWU6cStrLmxlbmd0aCx3cml0YWJsZTohMH0pO2subGVuZ3RoJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodSxcInNrJHNvbGlkU2xvdEJhc2VcIix7dmFsdWU6ITAsd3JpdGFibGU6ITB9KTtrLmZvckVhY2goKHoscik9PntyKz1xO2xbei4kbWFuZ2xlZF09bmV3IFNrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3IodSx7JGdldCgpe2NvbnN0IHQ9dGhpcy4kc1tyXTtpZih2b2lkIDA9PT10KXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKHopO3JldHVybiB0fSwkc2V0KHQpe3RoaXMuJHNbcl09dH19KX0pfWZ1bmN0aW9uIGcoayl7Zm9yKDtudWxsIT09ay5wcm90b3R5cGUudHAkYmFzZTspe2lmKHZvaWQgMD09PWsuc2ska2xhc3MmJmsucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwiX19kaWN0X19cIikpcmV0dXJuIGs9XG5rLnByb3RvdHlwZS5fX2RpY3RfXyxTay5idWlsdGluLmNoZWNrRGF0YURlc2NyKGspP2s6dm9pZCAwO2s9ay5wcm90b3R5cGUudHAkYmFzZX19ZnVuY3Rpb24gYShrLHUsbCl7aWYodm9pZCAwPT09ay5zayRrbGFzcyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBzZXQgXCIray5wcm90b3R5cGUudHAkbmFtZStcIi5cIitsLiRqc3N0cigpKTtpZih2b2lkIDA9PT11KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IGRlbGV0ZSBcIitrLnByb3RvdHlwZS50cCRuYW1lK1wiLlwiK2wuJGpzc3RyKCkpO31mdW5jdGlvbiBjKGssdSl7az0obmV3IFNrLmJ1aWx0aW4uc3VwZXJfKGssaykpLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGluaXRzdWJjbGFzcyk7U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGssW10sdSl9ZnVuY3Rpb24gbihrKXtjb25zdCB1PWsucHJvdG90eXBlO09iamVjdC5rZXlzKHUpLmZvckVhY2gobD0+e2NvbnN0IHE9U2suYWJzdHIubG9va3VwU3BlY2lhbCh1W2xdLFxuU2suYnVpbHRpbi5zdHIuJHNldG5hbWUpO2lmKHZvaWQgMCE9PXEpdHJ5e1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShxLFtrLG5ldyBTay5idWlsdGluLnN0cihsKV0pfWNhdGNoKHope3Rocm93IGw9bmV3IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKFwiRXJyb3IgY2FsbGluZyBfX3NldF9uYW1lX18gb24gJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHVbbF0pK1wiJyBpbnN0YW5jZSAnXCIrbCtcIicgaW4gJ1wiK2sucHJvdG90eXBlLnRwJG5hbWUrXCInXCIpLGwuJGNhdXNlPXosbDt9fSl9dm9pZCAwPT09U2suYnVpbHRpbiYmKFNrLmJ1aWx0aW49e30pO1NrLmJ1aWx0aW4udHlwZT1mdW5jdGlvbihrKXt0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi50eXBlJiZTay5hc3NlcnRzLmZhaWwoXCJjYWxsaW5nIG5ldyBTay5idWlsdGluLnR5cGUgaXMgbm90IHNhZmVcIik7cmV0dXJuIGsub2IkdHlwZX07T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2suYnVpbHRpbi50eXBlLnByb3RvdHlwZSx7Y2FsbDp7dmFsdWU6RnVuY3Rpb24ucHJvdG90eXBlLmNhbGx9LFxuYXBwbHk6e3ZhbHVlOkZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseX0sdHAkc2xvdHM6e3ZhbHVlOnt0cCRkb2M6XCJ0eXBlKG9iamVjdF9vcl9uYW1lLCBiYXNlcywgZGljdClcXG50eXBlKG9iamVjdCkgLT4gdGhlIG9iamVjdCdzIHR5cGVcXG50eXBlKG5hbWUsIGJhc2VzLCBkaWN0KSAtPiBhIG5ldyB0eXBlXCIsdHAkY2FsbDpmdW5jdGlvbihrLHUpe2lmKHRoaXM9PT1Tay5idWlsdGluLnR5cGUpe2lmKDE9PT1rLmxlbmd0aCYmKHZvaWQgMD09PXV8fCF1Lmxlbmd0aCkpcmV0dXJuIGtbMF0ub2IkdHlwZTtpZigzIT09ay5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZSgpIHRha2VzIDEgb3IgMyBhcmd1bWVudHNcIik7fWxldCBsPXRoaXMucHJvdG90eXBlLnRwJG5ldyhrLHUpO2lmKGwuJGlzU3VzcGVuc2lvbilyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4obCxxPT57bD1xO2lmKGwub2IkdHlwZS4kaXNTdWJUeXBlKHRoaXMpKXJldHVybiBsLnRwJGluaXQoayx1KX0sXG4oKT0+bCk7aWYobC5vYiR0eXBlLiRpc1N1YlR5cGUodGhpcykpe2NvbnN0IHE9bC50cCRpbml0KGssdSk7cmV0dXJuIHZvaWQgMCE9PXEmJnEuJGlzU3VzcGVuc2lvbj9Tay5taXNjZXZhbC5jaGFpbihxLCgpPT5sKTpsfXJldHVybiBsfSx0cCRuZXc6ZnVuY3Rpb24oayx1KXtpZigzIT09ay5sZW5ndGgpe2lmKDE9PT1rLmxlbmd0aCYmKHZvaWQgMD09PXV8fCF1Lmxlbmd0aCkpcmV0dXJuIGtbMF0ub2IkdHlwZTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgdGFrZXMgMSBvciAzIGFyZ3VtZW50c1wiKTt9Y29uc3QgbD1rWzBdO3ZhciBxPWtbMV07Y29uc3Qgej1rWzJdO2lmKFwiZGljdFwiIT09ei50cCRuYW1lKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUoKSBhcmd1bWVudCAzIG11c3QgYmUgZGljdCwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKHopKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhsKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgYXJndW1lbnQgMSBtdXN0IGJlIHN0ciwgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUobCkpO2NvbnN0IHI9bC4kanNzdHIoKTtpZihcInR1cGxlXCIhPT1xLnRwJG5hbWUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZSgpIGFyZ3VtZW50IDIgbXVzdCBiZSB0dXBsZSwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKHEpKTtxPXEuc2skYXNhcnJheSgpO2s9ZnVuY3Rpb24oKXt0aGlzLnNrJGhhc0RpY3QmJih0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3QpO3RoaXMuJHM9W119O2YocixrLHEsdGhpcy5jb25zdHJ1Y3Rvcik7Y29uc3QgdD1rLnByb3RvdHlwZTtTay5nbG9iYWxzJiYodC5fX21vZHVsZV9fPVNrLmdsb2JhbHMuX19uYW1lX18pO3QuX19kb2NfXz1Tay5idWlsdGluLm5vbmUubm9uZSQ7cT16LnF1aWNrJGxvb2t1cChTay5idWlsdGluLnN0ci4kc2xvdHMpO2xldCB4PXZvaWQgMD09PXEsdj12b2lkIDAhPT1rLiR0eXBlTG9va3VwKFNrLmJ1aWx0aW4uc3RyLiRkaWN0KSxCO3ZvaWQgMCE9PXEmJihCPW5ldyBTZXQscT1cblNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcocSk/W3FdOlNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKHEpLHEuZm9yRWFjaChJPT57aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoSSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19zbG90c19fIGl0ZW1zIG11c3QgYmUgc3RyaW5ncywgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZShJKStcIidcIik7aWYoIUkuJGlzSWRlbnRpZmllcigpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fc2xvdHNfXyBtdXN0IGJlIGlkZW50aWZpZXJzXCIpO2lmKEk9PT1Tay5idWlsdGluLnN0ci4kZGljdCl7aWYodil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2RpY3RfXyBzbG90IGRpc2FsbG93ZWQ6IHdlIGFscmVhZHkgZ290IG9uZVwiKTt4PSEwfWVsc2UgQi5hZGQoU2subWFuZ2xlTmFtZShsLEkpKX0pLHE9Wy4uLkJdLnNvcnQoKEksTSk9PkkudG9TdHJpbmcoKS5sb2NhbGVDb21wYXJlKE0udG9TdHJpbmcoKSkpLFxucChxLGspKTt4JiYhdiYmKHQuX19kaWN0X189bmV3IFNrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3IoayxtKSx2PSEwKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LHtodCRzbG90czp7dmFsdWU6cXx8bnVsbCx3cml0YWJsZTohMH0sc2skaGFzRGljdDp7dmFsdWU6dix3cml0YWJsZTohMH19KTt6LiRpdGVtcygpLmZvckVhY2goST0+e3ZhciBbTSxTXT1JO2lmKEImJkIuaGFzKE0pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCInXCIrTS50b1N0cmluZygpK1wiJyBpbiBfX3Nsb3RzX18gY29uZmxpY3RzIHdpdGggY2xhc3MgdmFyaWFibGVcIik7dFtNLiRtYW5nbGVkXT1TfSk7aWYodC5oYXNPd25Qcm9wZXJ0eShcIl9fcXVhbG5hbWVfX1wiKSl7cT10Ll9fcXVhbG5hbWVfXztpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhxKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlIF9fcXVhbG5hbWVfXyBtdXN0IGJlIGEgc3RyLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHEpK1xuXCInXCIpO3QuaHQkcXVhbG5hbWU9cX1xPWsucHJvdG90eXBlO2IocSxcIl9faW5pdF9zdWJjbGFzc19fXCIsXCJjbGFzc21ldGhvZFwiKTtiKHEsXCJfX25ld19fXCIsXCJzdGF0aWNtZXRob2RcIik7YihxLFwiX19jbGFzc19nZXRpdGVtX19cIixcImNsYXNzbWV0aG9kXCIpO2suJGFsbG9jYXRlU2xvdHMoKTtuKGspO2Moayx1KTtyZXR1cm4ga30sdHAkaW5pdDpmdW5jdGlvbihrLHUpe2lmKGsmJjE9PWsubGVuZ3RoJiZ1JiZ1Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlLl9faW5pdF9fKCkgdGFrZXMgbm8ga2V5d29yZCBhcmd1bWVudHNcIik7aWYoMyE9ay5sZW5ndGgmJjEhPWsubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUuX19pbml0X18oKSB0YWtlcyAxIG9yIDMgYXJndW1lbnRzXCIpO3JldHVybiBTay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUudHAkaW5pdC5jYWxsKHRoaXMsW10pfSx0cCRnZXRhdHRyOmZ1bmN0aW9uKGssdSl7dmFyIGw9XG50aGlzLm9iJHR5cGU7Y29uc3QgcT1sLiR0eXBlTG9va3VwKGspO2xldCB6O2lmKHZvaWQgMCE9PXEmJih6PXEudHAkZGVzY3JfZ2V0LHZvaWQgMCE9PXomJnZvaWQgMCE9PXEudHAkZGVzY3Jfc2V0KSlyZXR1cm4gdT16LmNhbGwocSx0aGlzLGwsdSk7az10aGlzLiR0eXBlTG9va3VwKGspO2lmKHZvaWQgMCE9PWspcmV0dXJuIGw9ay50cCRkZXNjcl9nZXQsdm9pZCAwIT09bD91PWwuY2FsbChrLG51bGwsdGhpcyx1KTprO2lmKHZvaWQgMCE9PXopcmV0dXJuIHU9ei5jYWxsKHEsdGhpcyxsLHUpO2lmKHZvaWQgMCE9PXEpcmV0dXJuIHF9LHRwJHNldGF0dHI6ZnVuY3Rpb24oayx1LGwpe2lmKCF0aGlzLnNrJGtsYXNzKXtpZih2b2lkIDAhPT11KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IHNldCBhdHRyaWJ1dGVzIG9mIGJ1aWx0LWluL2V4dGVuc2lvbiB0eXBlICdcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiJ1wiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBkZWxldGUgYXR0cmlidXRlcyBvbiB0eXBlIG9iamVjdCAnXCIrXG50aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiJ1wiKTt9Y29uc3QgcT10aGlzLm9iJHR5cGUuJHR5cGVMb29rdXAoayk7aWYodm9pZCAwIT09cSl7Y29uc3Qgej1xLnRwJGRlc2NyX3NldDtpZih6KXJldHVybiB6LmNhbGwocSx0aGlzLHUsbCl9bD1rLiRtYW5nbGVkO2lmKHZvaWQgMD09PXUpaWYodT10aGlzLnByb3RvdHlwZSx1Lmhhc093blByb3BlcnR5KGwpKWRlbGV0ZSB1W2xdLGs9U2suZHVuZGVyVG9Ta3VscHRbbF0sdm9pZCAwIT09ayYmKGRlbGV0ZSB0aGlzLnByb3RvdHlwZVtrXSx1LnNrJHByb3RvdHlwaWNhbHx8dGhpcy4kYWxsb2NhdGVHZXR0ZXJTbG90KGwpKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwidHlwZSBvYmplY3QgJ1wiK3RoaXMucHJvdG90eXBlLnRwJG5hbWUrXCInIGhhcyBubyBhdHRyaWJ1dGUgJ1wiK2suJGpzc3RyKCkrXCInXCIpO2Vsc2UgdGhpcy5wcm90b3R5cGVbbF09dSxsIGluIFNrLmR1bmRlclRvU2t1bHB0JiZ0aGlzLiRhbGxvY2F0ZVNsb3QobCxcbnUpfSwkcjpmdW5jdGlvbigpe2xldCBrPXRoaXMucHJvdG90eXBlLl9fbW9kdWxlX18sdT1cIlwiLGw9XCJjbGFzc1wiO2smJlNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoayk/dT1rLnYrXCIuXCI6az1udWxsO2t8fHRoaXMuc2ska2xhc3N8fFNrLl9fZnV0dXJlX18uY2xhc3NfcmVwcnx8KGw9XCJ0eXBlXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8XCIrbCtcIiAnXCIrdSt0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiJz5cIil9fSx3cml0YWJsZTohMH0sdHAkbWV0aG9kczp7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0sdHAkY2xhc3NtZXRob2RzOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSx0cCRnZXRzZXRzOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSxzayR0eXBlOnt2YWx1ZTohMH0sJGlzU3ViVHlwZTp7dmFsdWU6ZnVuY3Rpb24oayl7cmV0dXJuIHRoaXM9PT1rfHx0aGlzLnByb3RvdHlwZSBpbnN0YW5jZW9mIGt8fCF0aGlzLnByb3RvdHlwZS5zayRwcm90b3R5cGljYWwmJnRoaXMucHJvdG90eXBlLnRwJG1yby5pbmNsdWRlcyhrKX19LFxuJGFsbG9jYXRlU2xvdDp7dmFsdWU6ZnVuY3Rpb24oayx1KXtrPVNrLnNsb3RzW2tdO2NvbnN0IGw9ay4kc2xvdF9uYW1lLHE9dGhpcy5wcm90b3R5cGU7cS5oYXNPd25Qcm9wZXJ0eShsKSYmZGVsZXRlIHFbbF07T2JqZWN0LmRlZmluZVByb3BlcnR5KHEsbCx7dmFsdWU6ay4kc2xvdF9mdW5jKHUpLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pfX0sJGFsbG9jYXRlU2xvdHM6e3ZhbHVlOmZ1bmN0aW9uKCl7Y29uc3Qgaz10aGlzLnByb3RvdHlwZTt0aGlzLnByb3RvdHlwZS5zayRwcm90b3R5cGljYWw/T2JqZWN0LmtleXMoaykuZm9yRWFjaCh1PT57dSBpbiBTay5zbG90cyYmdGhpcy4kYWxsb2NhdGVTbG90KHUsa1t1XSl9KTpPYmplY3Qua2V5cyhTay5zbG90cykuZm9yRWFjaCh1PT57ay5oYXNPd25Qcm9wZXJ0eSh1KT90aGlzLiRhbGxvY2F0ZVNsb3QodSxrW3VdKTp0aGlzLiRhbGxvY2F0ZUdldHRlclNsb3QodSl9KTtrLmhhc093blByb3BlcnR5KFwiX19lcV9fXCIpJiYhay5oYXNPd25Qcm9wZXJ0eShcIl9faGFzaF9fXCIpJiZcbihrLnRwJGhhc2g9ay5fX2hhc2hfXz1Tay5idWlsdGluLm5vbmUubm9uZSQpfX0sJGFsbG9jYXRlR2V0dGVyU2xvdDp7dmFsdWU6ZnVuY3Rpb24oayl7Y29uc3QgdT1Tay5zbG90c1trXS4kc2xvdF9uYW1lLGw9dGhpcy5wcm90b3R5cGU7bC5oYXNPd25Qcm9wZXJ0eSh1KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsdSx7Y29uZmlndXJhYmxlOiEwLGdldCgpe2NvbnN0IHE9bC50cCRtcm87Zm9yKGxldCB6PTE7ejxxLmxlbmd0aDt6Kyspe2NvbnN0IHI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihxW3pdLnByb3RvdHlwZSx1KTtpZih2b2lkIDAhPT1yJiZyLnZhbHVlKXJldHVybiByLnZhbHVlfX19KX19LCR0eXBlTG9va3VwOnt2YWx1ZTpmdW5jdGlvbihrKXtyZXR1cm4gdGhpcy5wcm90b3R5cGUuc2skcHJvdG90eXBpY2FsP3RoaXMucHJvdG90eXBlW2suJG1hbmdsZWRdOmQuY2FsbCh0aGlzLGspfSx3cml0YWJsZTohMH0sJG1yb01lcmdlOnt2YWx1ZTpmdW5jdGlvbihrKXt0aGlzLnByb3RvdHlwZS5zayRwcm90b3R5cGljYWw9XG4hMDtsZXQgdTtjb25zdCBsPVtdO2Zvcig7Oyl7Zm9yKHU9MDt1PGsubGVuZ3RoOysrdSl7dmFyIHE9a1t1XTtpZigwIT09cS5sZW5ndGgpYnJlYWt9aWYodT09PWsubGVuZ3RoKXJldHVybiBsO3ZhciB6PVtdO2Zvcih1PTA7dTxrLmxlbmd0aDsrK3UpaWYocT1rW3VdLDAhPT1xLmxlbmd0aCl7Y29uc3Qgcj1xWzBdO3E9MDthOmZvcig7cTxrLmxlbmd0aDsrK3Epe2NvbnN0IHQ9a1txXTtmb3IobGV0IHg9MTt4PHQubGVuZ3RoOysreClpZih0W3hdPT09cilicmVhayBhfXE9PT1rLmxlbmd0aCYmei5wdXNoKHIpfWlmKDA9PT16Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJJbmNvbnNpc3RlbnQgcHJlY2VkZW5jZXMgaW4gdHlwZSBoaWVyYXJjaHlcIik7ej16WzBdO2wubGVuZ3RoJiZ0aGlzLnByb3RvdHlwZS5zayRwcm90b3R5cGljYWwmJk9iamVjdC5nZXRQcm90b3R5cGVPZihsW2wubGVuZ3RoLTFdLnByb3RvdHlwZSkhPT16LnByb3RvdHlwZSYmKHRoaXMucHJvdG90eXBlLnNrJHByb3RvdHlwaWNhbD1cbiExKTtsLnB1c2goeik7Zm9yKHU9MDt1PGsubGVuZ3RoOysrdSlxPWtbdV0sMDxxLmxlbmd0aCYmcVswXT09PXomJnEuc3BsaWNlKDAsMSl9fX0sJGJ1aWxkTVJPOnt2YWx1ZTpmdW5jdGlvbigpe2NvbnN0IGs9W1t0aGlzXV0sdT10aGlzLnByb3RvdHlwZS50cCRiYXNlcztmb3IodmFyIGw9MDtsPHUubGVuZ3RoOysrbClrLnB1c2goWy4uLnVbbF0ucHJvdG90eXBlLnRwJG1yb10pO2w9W107Zm9yKGxldCBxPTA7cTx1Lmxlbmd0aDsrK3EpbC5wdXNoKHVbcV0pO2sucHVzaChsKTtyZXR1cm4gdGhpcy4kbXJvTWVyZ2Uoayl9fSxzayRhdHRyRXJyb3I6e3ZhbHVlKCl7cmV0dXJuXCJ0eXBlIG9iamVjdCAnXCIrdGhpcy5wcm90b3R5cGUudHAkbmFtZStcIidcIn0sd3JpdGFibGU6ITB9fSk7U2suYnVpbHRpbi50eXBlLnByb3RvdHlwZS50cCRnZXRzZXRzPXtfX2Jhc2VfXzp7JGdldCgpe3JldHVybiB0aGlzLnByb3RvdHlwZS50cCRiYXNlfHxTay5idWlsdGluLm5vbmUubm9uZSR9fSxfX2Jhc2VzX186eyRnZXQoKXt2b2lkIDA9PT1cbnRoaXMuc2skdHVwbGVfYmFzZXMmJih0aGlzLnNrJHR1cGxlX2Jhc2VzPW5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMucHJvdG90eXBlLnRwJGJhc2VzKSk7cmV0dXJuIHRoaXMuc2skdHVwbGVfYmFzZXN9fSxfX21yb19fOnskZ2V0KCl7dm9pZCAwPT09dGhpcy5zayR0dXBsZV9tcm8mJih0aGlzLnNrJHR1cGxlX21ybz1uZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLnByb3RvdHlwZS50cCRtcm8pKTtyZXR1cm4gdGhpcy5zayR0dXBsZV9tcm99fSxfX2RpY3RfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5tYXBwaW5ncHJveHkodGhpcy5wcm90b3R5cGUpfX0sX19kb2NfXzp7JGdldCgpe2NvbnN0IGs9dGhpcy4kdHlwZUxvb2t1cChTay5idWlsdGluLnN0ci4kZG9jKTtyZXR1cm4gaz92b2lkIDAhPT1rLnRwJGRlc2NyX2dldD90aGlzPT09U2suYnVpbHRpbi50eXBlP25ldyBTay5idWlsdGluLnN0cih0aGlzLnByb3RvdHlwZS50cCRkb2MpOmsudHAkZGVzY3JfZ2V0KG51bGwsXG50aGlzKTp0aGlzLnByb3RvdHlwZS5fX2RvY19fOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJHNldChrKXthKHRoaXMsayxTay5idWlsdGluLnN0ci4kZG9jKTt0aGlzLnByb3RvdHlwZS5fX2RvY19fPWt9fSxfX25hbWVfXzp7JGdldCgpe2xldCBrPXRoaXMucHJvdG90eXBlLmh0JG5hbWU7aWYodm9pZCAwIT09aylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGspO2s9dGhpcy5wcm90b3R5cGUudHAkbmFtZTtrLmluY2x1ZGVzKFwiLlwiKSYmKGs9ay5zbGljZShrLmxhc3RJbmRleE9mKFwiLlwiKSsxKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihrKX0sJHNldChrKXthKHRoaXMsayxTay5idWlsdGluLnN0ci4kbmFtZSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoaykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgYXNzaWduIHN0cmluZyB0byBcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiLl9fbmFtZV9fLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGspK1xuXCInXCIpO3RoaXMucHJvdG90eXBlLmh0JG5hbWU9azt0aGlzLnByb3RvdHlwZS50cCRuYW1lPWsuJGpzc3RyKCl9fSxfX3F1YWxuYW1lX186eyRnZXQoKXtyZXR1cm4gdGhpcy5wcm90b3R5cGUuaHQkcXVhbG5hbWV8fFNrLmFic3RyLmxvb2t1cFNwZWNpYWwodGhpcyxTay5idWlsdGluLnN0ci4kbmFtZSl9LCRzZXQoayl7YSh0aGlzLGssU2suYnVpbHRpbi5zdHIuJG5hbWUpO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGspKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbiBvbmx5IGFzc2lnbiBzdHJpbmcgdG8gXCIrdGhpcy5wcm90b3R5cGUudHAkbmFtZStcIi5fX3F1YWxuYW1lX18sIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoaykrXCInXCIpO3RoaXMucHJvdG90eXBlLmh0JHF1YWxuYW1lPWt9fSxfX21vZHVsZV9fOnskZ2V0KCl7Y29uc3Qgaz10aGlzLnByb3RvdHlwZSx1PWsuX19tb2R1bGVfXztyZXR1cm4gdSYmdS5vYiR0eXBlIT09U2suYnVpbHRpbi5nZXRzZXRfZGVzY3JpcHRvcj9cbnU6ay50cCRuYW1lLmluY2x1ZGVzKFwiLlwiKT9uZXcgU2suYnVpbHRpbi5zdHIoay50cCRuYW1lLnNsaWNlKDAsay50cCRuYW1lLmxhc3RJbmRleE9mKFwiLlwiKSkpOm5ldyBTay5idWlsdGluLnN0cihcImJ1aWx0aW5zXCIpfSwkc2V0KGspe2EodGhpcyxrLFNrLmJ1aWx0aW4uc3RyLiRtb2R1bGUpO3RoaXMucHJvdG90eXBlLl9fbW9kdWxlX189a319fTtTay5idWlsdGluLnR5cGUucHJvdG90eXBlLnRwJG1ldGhvZHM9e21ybzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLiRidWlsZE1STygpKX0sJGZsYWdzOntOb0FyZ3M6ITB9fSxfX2Rpcl9fOnskbWV0aDpmdW5jdGlvbigpe2NvbnN0IGs9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7dGhpcy4kbWVyZ2VDbGFzc0RpY3Qoayk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qoay5zayRhc2FycmF5KCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIlNwZWNpYWxpemVkIF9fZGlyX18gaW1wbGVtZW50YXRpb24gZm9yIHR5cGVzLlwifX07XG5Tay5idWlsdGluLnR5cGUudHAkY2xhc3NtZXRob2RzPXtfX3ByZXBhcmVfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZGljdChbXSl9LCRmbGFnczp7RmFzdENhbGw6ITB9fX07Y29uc3QgbT17JGdldCgpe2NvbnN0IGs9Zyh0aGlzLm9iJHR5cGUpO3JldHVybiB2b2lkIDAhPT1rP2sudHAkZGVzY3JfZ2V0KHRoaXMsdGhpcy5vYiR0eXBlKTpTay5nZW5lcmljLmdldFNldERpY3QuJGdldC5jYWxsKHRoaXMpfSwkc2V0KGspe2NvbnN0IHU9Zyh0aGlzLm9iJHR5cGUpO2lmKHZvaWQgMCE9PXUpcmV0dXJuIHUudHAkZGVzY3Jfc2V0KHRoaXMsayk7aWYodm9pZCAwPT09ayl0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3QoW10pO2Vsc2UgcmV0dXJuIFNrLmdlbmVyaWMuZ2V0U2V0RGljdC4kc2V0LmNhbGwodGhpcyxrKX0sJGRvYzpcImRpY3Rpb25hcnkgZm9yIGluc3RhbmNlIHZhcmlhYmxlcyAoaWYgZGVmaW5lZClcIiwkbmFtZTpcIl9fZGljdF9fXCJ9fSxmdW5jdGlvbihGLFApe1NrLmdlbmVyaWM9XG57fTtTay5nZW5lcmljLmdldEF0dHI9ZnVuY3Rpb24oYixlKXtsZXQgZDtjb25zdCBmPXRoaXMub2IkdHlwZSxoPWYuJHR5cGVMb29rdXAoYik7aWYodm9pZCAwIT09aCYmKGQ9aC50cCRkZXNjcl9nZXQsdm9pZCAwIT09ZCYmdm9pZCAwIT09aC50cCRkZXNjcl9zZXQpKXJldHVybiBkLmNhbGwoaCx0aGlzLGYsZSk7Y29uc3QgcD10aGlzLiRkO2lmKHZvaWQgMCE9PXAmJihiPXAucXVpY2skbG9va3VwKGIpLHZvaWQgMCE9PWIpKXJldHVybiBiO2lmKHZvaWQgMCE9PWQpcmV0dXJuIGQuY2FsbChoLHRoaXMsZixlKTtpZih2b2lkIDAhPT1oKXJldHVybiBofTtTay5leHBvcnRTeW1ib2woXCJTay5nZW5lcmljLmdldEF0dHJcIixTay5nZW5lcmljLmdldEF0dHIpO1NrLmdlbmVyaWMuc2V0QXR0cj1mdW5jdGlvbihiLGUsZCl7dmFyIGY9dGhpcy5vYiR0eXBlLiR0eXBlTG9va3VwKGIpO2lmKHZvaWQgMCE9PWYmJm51bGwhPT1mKXtjb25zdCBoPWYudHAkZGVzY3Jfc2V0O2lmKGgpcmV0dXJuIGguY2FsbChmLFxudGhpcyxlLGQpfWQ9dGhpcy4kZDtpZih2b2lkIDAhPT1kKWlmKGQubXAkYXNzX3N1YnNjcmlwdCl7aWYodm9pZCAwIT09ZSlyZXR1cm4gZC5tcCRhc3Nfc3Vic2NyaXB0KGIsZSk7dHJ5e3JldHVybiBkLm1wJGFzc19zdWJzY3JpcHQoYil9Y2F0Y2goaCl7aWYoaCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uS2V5RXJyb3IpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCInIG9iamVjdCBoYXMgbm8gYXR0cmlidXRlICdcIitiLiRqc3N0cigpK1wiJ1wiKTt0aHJvdyBoO319ZWxzZSBpZihcIm9iamVjdFwiPT09dHlwZW9mIGQpe2Y9Yi4kbWFuZ2xlZDtpZih2b2lkIDAhPT1lKXtkW2ZdPWU7cmV0dXJufWlmKHZvaWQgMCE9PWRbZl0pe2RlbGV0ZSBkW2ZdO3JldHVybn19dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IodGhpcy5zayRhdHRyRXJyb3IoKStcIiBoYXMgbm8gYXR0cmlidXRlICdcIitiLiRqc3N0cigpK1wiJ1wiKTtcbn07U2suZXhwb3J0U3ltYm9sKFwiU2suZ2VuZXJpYy5zZXRBdHRyXCIsU2suZ2VuZXJpYy5zZXRBdHRyKTtTay5nZW5lcmljLm5ldz1mdW5jdGlvbihiKXtyZXR1cm4gZnVuY3Rpb24oZSxkKXtpZih0aGlzLmNvbnN0cnVjdG9yPT09YilyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3I7ZT1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtiLmNhbGwoZSk7cmV0dXJuIGV9fTtTay5nZW5lcmljLm5ld01ldGhvZERlZj17JG1ldGgoYixlKXtjb25zdCBkPXRoaXMucHJvdG90eXBlO2lmKDE+Yi5sZW5ndGgpdGhyb3cgYj1kLnRwJG5hbWUsbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGIrXCIuX19uZXdfXygpOiBub3QgZW5vdWdoIGFyZ3VtZW50c1wiKTt2YXIgZj1iLnNoaWZ0KCk7aWYodm9pZCAwPT09Zi5zayR0eXBlKXRocm93IGI9ZC50cCRuYW1lLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihiK1wiX19uZXdfXyhYKTogWCBpcyBub3QgYSB0eXBlIG9iamVjdCAoXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCIpXCIpO1xuaWYoIWYuJGlzU3ViVHlwZSh0aGlzKSl0aHJvdyBiPWQudHAkbmFtZSxmPWYucHJvdG90eXBlLnRwJG5hbWUsbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGIrXCIuX19uZXdfXyhcIitmK1wiKTogXCIrZitcIiBpcyBub3QgYSBzdWJ0eXBlIG9mIFwiK2IpO2NvbnN0IGg9Zi5wcm90b3R5cGUuc2skc3RhdGljTmV3LnByb3RvdHlwZTtpZihoLnRwJG5ldyE9PWQudHAkbmV3KXRocm93IGI9ZC50cCRuYW1lLGY9Zi5wcm90b3R5cGUudHAkbmFtZSxuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYitcIi5fX25ld19fKFwiK2YrXCIpIGlzIG5vdCBzYWZlLCB1c2UgXCIraC50cCRuYW1lK1wiLl9fbmV3X18oKVwiKTtyZXR1cm4gZC50cCRuZXcuY2FsbChmLnByb3RvdHlwZSxiLGUpfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpcIigkdHlwZSwgKmFyZ3MsICoqa3dhcmdzKVwiLCRuYW1lOlwiX19uZXdfX1wifTtTay5nZW5lcmljLnNlbGZJdGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O1NrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXlDaGVja1NpemU9XG5mdW5jdGlvbigpe2lmKHRoaXMuJHNlcS5sZW5ndGghPT10aGlzLiRvcmlnLmdldCRzaXplKCkpe2NvbnN0IGI9dGhpcy50cCRuYW1lLnNwbGl0KFwiX1wiKVswXTt0aHJvdyBuZXcgU2suYnVpbHRpbi5SdW50aW1lRXJyb3IoYitcIiBjaGFuZ2VkIHNpemUgZHVyaW5nIGl0ZXJhdGlvblwiKTt9aWYoISh0aGlzLiRpbmRleD49dGhpcy4kc2VxLmxlbmd0aCkpcmV0dXJuIHRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXX07U2suZ2VuZXJpYy5pdGVyTmV4dFdpdGhBcnJheT1mdW5jdGlvbigpe2NvbnN0IGI9dGhpcy4kc2VxW3RoaXMuJGluZGV4KytdO3ZvaWQgMD09PWImJih0aGlzLnRwJGl0ZXJuZXh0PSgpPT57fSk7cmV0dXJuIGJ9O1NrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWY9eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy4kc2VxLmxlbmd0aC10aGlzLiRpbmRleCl9LCRmbGFnczp7Tm9BcmdzOiEwfX07U2suZ2VuZXJpYy5pdGVyUmV2ZXJzZUxlbmd0aEhpbnRNZXRob2REZWY9XG57JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpbmRleCl9LCRmbGFnczp7Tm9BcmdzOiEwfX07U2suZ2VuZXJpYy5nZXRTZXREaWN0PXskZ2V0KCl7cmV0dXJuIHRoaXMuJGR9LCRzZXQoYil7aWYodm9pZCAwPT09Yil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW5ub3QgZGVsZXRlIF9fZGljdF9fXCIpO2lmKGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpdGhpcy4kZD1iO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19kaWN0X18gbXVzdCBiZSBzZXQgdG8gYSBkaWN0aW9uYXJ5LCBub3QgYSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYikrXCInXCIpO30sJGRvYzpcImRpY3Rpb25hcnkgZm9yIGluc3RhbmNlIHZhcmlhYmxlcyAoaWYgZGVmaW5lZClcIiwkbmFtZTpcIl9fZGljdF9fXCJ9O1NrLmdlbmVyaWMuc2VxQ29tcGFyZT1mdW5jdGlvbihiLGUpe2lmKHRoaXM9PT1iJiZTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5KGUpKXJldHVybiEwO1xuaWYoIShiIGluc3RhbmNlb2YgdGhpcy5zayRidWlsdGluQmFzZSkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IGQ9dGhpcy52O2I9Yi52O2xldCBmO2lmKGQubGVuZ3RoIT09Yi5sZW5ndGgmJihcIkVxXCI9PT1lfHxcIk5vdEVxXCI9PT1lKSlyZXR1cm5cIkVxXCI9PT1lPyExOiEwO2ZvcihmPTA7ZjxkLmxlbmd0aCYmZjxiLmxlbmd0aCYmKGRbZl09PT1iW2ZdfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZFtmXSxiW2ZdLFwiRXFcIikpOysrZik7Y29uc3QgaD1kLmxlbmd0aCxwPWIubGVuZ3RoO2lmKGY+PWh8fGY+PXApc3dpdGNoKGUpe2Nhc2UgXCJMdFwiOnJldHVybiBoPHA7Y2FzZSBcIkx0RVwiOnJldHVybiBoPD1wO2Nhc2UgXCJFcVwiOnJldHVybiBoPT09cDtjYXNlIFwiTm90RXFcIjpyZXR1cm4gaCE9PXA7Y2FzZSBcIkd0XCI6cmV0dXJuIGg+cDtjYXNlIFwiR3RFXCI6cmV0dXJuIGg+PXA7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoKX1yZXR1cm5cIkVxXCI9PT1cbmU/ITE6XCJOb3RFcVwiPT09ZT8hMDpTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZFtmXSxiW2ZdLGUpfTtTay5nZW5lcmljLmNsYXNzR2V0SXRlbT17X19jbGFzc19nZXRpdGVtX186eyRtZXRoKGIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5HZW5lcmljQWxpYXModGhpcyxiKX0sJGZsYWdzOntPbmVBcmc6ITB9fX19LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5weUNoZWNrQXJncz1mdW5jdGlvbihiLGUsZCxmLGgscCl7ZT1lLmxlbmd0aDt2b2lkIDA9PT1mJiYoZj1JbmZpbml0eSk7aCYmLS1lO3AmJi0tZTtpZihlPGR8fGU+Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoKGQ9PT1mP2IrXCIoKSB0YWtlcyBleGFjdGx5IFwiK2QrXCIgYXJndW1lbnRzXCI6ZTxkP2IrXCIoKSB0YWtlcyBhdCBsZWFzdCBcIitkK1wiIGFyZ3VtZW50c1wiOjA8ZD9iK1wiKCkgdGFrZXMgYXQgbW9zdCBcIitmK1wiIGFyZ3VtZW50c1wiOmIrXCIoKSB0YWtlcyBubyBhcmd1bWVudHNcIikrKFwiIChcIitlK1wiIGdpdmVuKVwiKSk7XG59O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NcIixTay5idWlsdGluLnB5Q2hlY2tBcmdzKTtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuPWZ1bmN0aW9uKGIsZSxkLGYsaCxwKXt2b2lkIDA9PT1mJiYoZj1JbmZpbml0eSk7aCYmLS1lO3AmJi0tZTtpZihlPGR8fGU+Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoKGQ9PT1mP2IrXCIoKSB0YWtlcyBleGFjdGx5IFwiK2QrXCIgYXJndW1lbnRzXCI6ZTxkP2IrXCIoKSB0YWtlcyBhdCBsZWFzdCBcIitkK1wiIGFyZ3VtZW50c1wiOmIrXCIoKSB0YWtlcyBhdCBtb3N0IFwiK2YrXCIgYXJndW1lbnRzXCIpKyhcIiAoXCIrZStcIiBnaXZlbilcIikpO307U2suYnVpbHRpbi5weUNoZWNrVHlwZT1mdW5jdGlvbihiLGUsZCl7aWYoIWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGIrXCIgbXVzdCBiZSBhIFwiK2UpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5weUNoZWNrVHlwZVwiLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUpO1xuU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlPWZ1bmN0aW9uKGIpe3JldHVybiBudWxsIT1iJiZ2b2lkIDAhPT1iLm1wJHN1YnNjcmlwdH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlXCIsU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKTtTay5idWlsdGluLmNoZWNrSXRlcmFibGU9ZnVuY3Rpb24oYil7cmV0dXJuIHZvaWQgMD09PWI/ITE6Yi50cCRpdGVyP3ZvaWQgMCE9PWIudHAkaXRlcigpLnRwJGl0ZXJuZXh0OnZvaWQgMCE9PWIubXAkc3Vic2NyaXB0fTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrSXRlcmFibGVcIixTay5idWlsdGluLmNoZWNrSXRlcmFibGUpO1NrLmJ1aWx0aW4uY2hlY2tDYWxsYWJsZT1mdW5jdGlvbihiKXtyZXR1cm4gbnVsbCE9YiYmdm9pZCAwIT09Yi50cCRjYWxsfTtTay5idWlsdGluLmNoZWNrTnVtYmVyPWZ1bmN0aW9uKGIpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYnx8YiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8XG5iIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF98fGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZ307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja051bWJlclwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIpO1NrLmJ1aWx0aW4uY2hlY2tDb21wbGV4PWZ1bmN0aW9uKGIpe3JldHVybiBiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5jb21wbGV4fTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrQ29tcGxleFwiLFNrLmJ1aWx0aW4uY2hlY2tDb21wbGV4KTtTay5idWlsdGluLmNoZWNrSW50PWZ1bmN0aW9uKGIpe3JldHVybiBiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRffHxcIm51bWJlclwiPT09dHlwZW9mIGImJk51bWJlci5pc0ludGVnZXIoYil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tJbnRcIixTay5idWlsdGluLmNoZWNrSW50KTtTay5idWlsdGluLmNoZWNrRmxvYXQ9ZnVuY3Rpb24oYil7cmV0dXJuIGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0X307XG5Tay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrRmxvYXRcIixTay5idWlsdGluLmNoZWNrRmxvYXQpO1NrLmJ1aWx0aW4uY2hlY2tTdHJpbmc9ZnVuY3Rpb24oYil7cmV0dXJuIGIgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cn07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja1N0cmluZ1wiLFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcpO1NrLmJ1aWx0aW4uY2hlY2tCeXRlcz1mdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXN9O1NrLmJ1aWx0aW4uY2hlY2tDbGFzcz1mdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHlwZX07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0NsYXNzXCIsU2suYnVpbHRpbi5jaGVja0NsYXNzKTtTay5idWlsdGluLmNoZWNrQm9vbD1mdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0Jvb2xcIixcblNrLmJ1aWx0aW4uY2hlY2tCb29sKTtTay5idWlsdGluLmNoZWNrTm9uZT1mdW5jdGlvbihiKXtyZXR1cm4gYj09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja05vbmVcIixTay5idWlsdGluLmNoZWNrTm9uZSk7U2suYnVpbHRpbi5jaGVja0Z1bmN0aW9uPWZ1bmN0aW9uKGIpe3JldHVybiBudWxsIT1iJiZ2b2lkIDAhPT1iLnRwJGNhbGx9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tGdW5jdGlvblwiLFNrLmJ1aWx0aW4uY2hlY2tGdW5jdGlvbik7U2suYnVpbHRpbi5jaGVja0RhdGFEZXNjcj1mdW5jdGlvbihiKXtyZXR1cm4gYiYmdm9pZCAwIT09Yi50cCRkZXNjcl9zZXR9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tEYXRhRGVzY3JcIixTay5idWlsdGluLmNoZWNrRGF0YURlc2NyKTtTay5idWlsdGluLmNoZWNrQW55U2V0PWZ1bmN0aW9uKGIpe3JldHVybiBiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zZXR8fFxuYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZnJvemVuc2V0fTtTay5idWlsdGluLmNoZWNrTWFwcGluZz1mdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdHx8bnVsbCE9YiYmdm9pZCAwIT09Yi5tcCRzdWJzY3JpcHQmJnZvaWQgMCE9PVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYixTay5idWlsdGluLnN0ci4ka2V5cyl9fSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIobCxxKXtzd2l0Y2gocSl7Y2FzZSBcIkFkZFwiOnJldHVybiBsLm5iJGFkZDtjYXNlIFwiU3ViXCI6cmV0dXJuIGwubmIkc3VidHJhY3Q7Y2FzZSBcIk11bHRcIjpyZXR1cm4gbC5uYiRtdWx0aXBseTtjYXNlIFwiTWF0TXVsdFwiOmlmKFNrLl9fZnV0dXJlX18ucHl0aG9uMylyZXR1cm4gbC5uYiRtYXRyaXhfbXVsdGlwbHk7Y2FzZSBcIkRpdlwiOnJldHVybiBsLm5iJGRpdmlkZTtjYXNlIFwiRmxvb3JEaXZcIjpyZXR1cm4gbC5uYiRmbG9vcl9kaXZpZGU7Y2FzZSBcIk1vZFwiOnJldHVybiBsLm5iJHJlbWFpbmRlcjtcbmNhc2UgXCJEaXZNb2RcIjpyZXR1cm4gbC5uYiRkaXZtb2Q7Y2FzZSBcIlBvd1wiOnJldHVybiBsLm5iJHBvd2VyO2Nhc2UgXCJMU2hpZnRcIjpyZXR1cm4gbC5uYiRsc2hpZnQ7Y2FzZSBcIlJTaGlmdFwiOnJldHVybiBsLm5iJHJzaGlmdDtjYXNlIFwiQml0QW5kXCI6cmV0dXJuIGwubmIkYW5kO2Nhc2UgXCJCaXRYb3JcIjpyZXR1cm4gbC5uYiR4b3I7Y2FzZSBcIkJpdE9yXCI6cmV0dXJuIGwubmIkb3J9fWZ1bmN0aW9uIGUobCxxKXtzd2l0Y2gocSl7Y2FzZSBcIkFkZFwiOnJldHVybiBsLm5iJHJlZmxlY3RlZF9hZGQ7Y2FzZSBcIlN1YlwiOnJldHVybiBsLm5iJHJlZmxlY3RlZF9zdWJ0cmFjdDtjYXNlIFwiTXVsdFwiOnJldHVybiBsLm5iJHJlZmxlY3RlZF9tdWx0aXBseTtjYXNlIFwiTWF0TXVsdFwiOmlmKFNrLl9fZnV0dXJlX18ucHl0aG9uMylyZXR1cm4gbC5uYiRyZWZsZWN0ZWRfbWF0cml4X211bHRpcGx5O2Nhc2UgXCJEaXZcIjpyZXR1cm4gbC5uYiRyZWZsZWN0ZWRfZGl2aWRlO2Nhc2UgXCJGbG9vckRpdlwiOnJldHVybiBsLm5iJHJlZmxlY3RlZF9mbG9vcl9kaXZpZGU7XG5jYXNlIFwiTW9kXCI6cmV0dXJuIGwubmIkcmVmbGVjdGVkX3JlbWFpbmRlcjtjYXNlIFwiRGl2TW9kXCI6cmV0dXJuIGwubmIkcmVmbGVjdGVkX2Rpdm1vZDtjYXNlIFwiUG93XCI6cmV0dXJuIGwubmIkcmVmbGVjdGVkX3Bvd2VyO2Nhc2UgXCJMU2hpZnRcIjpyZXR1cm4gbC5uYiRyZWZsZWN0ZWRfbHNoaWZ0O2Nhc2UgXCJSU2hpZnRcIjpyZXR1cm4gbC5uYiRyZWZsZWN0ZWRfcnNoaWZ0O2Nhc2UgXCJCaXRBbmRcIjpyZXR1cm4gbC5uYiRyZWZsZWN0ZWRfYW5kO2Nhc2UgXCJCaXRYb3JcIjpyZXR1cm4gbC5uYiRyZWZsZWN0ZWRfeG9yO2Nhc2UgXCJCaXRPclwiOnJldHVybiBsLm5iJHJlZmxlY3RlZF9vcn19ZnVuY3Rpb24gZChsLHEpe3N3aXRjaChxKXtjYXNlIFwiQWRkXCI6cmV0dXJuIGwubmIkaW5wbGFjZV9hZGQ7Y2FzZSBcIlN1YlwiOnJldHVybiBsLm5iJGlucGxhY2Vfc3VidHJhY3Q7Y2FzZSBcIk11bHRcIjpyZXR1cm4gbC5uYiRpbnBsYWNlX211bHRpcGx5O2Nhc2UgXCJNYXRNdWx0XCI6aWYoU2suX19mdXR1cmVfXy5weXRob24zKXJldHVybiBsLm5iJGlucGxhY2VfbWF0cml4X211bHRpcGx5O1xuY2FzZSBcIkRpdlwiOnJldHVybiBsLm5iJGlucGxhY2VfZGl2aWRlO2Nhc2UgXCJGbG9vckRpdlwiOnJldHVybiBsLm5iJGlucGxhY2VfZmxvb3JfZGl2aWRlO2Nhc2UgXCJNb2RcIjpyZXR1cm4gbC5uYiRpbnBsYWNlX3JlbWFpbmRlcjtjYXNlIFwiUG93XCI6cmV0dXJuIGwubmIkaW5wbGFjZV9wb3dlcjtjYXNlIFwiTFNoaWZ0XCI6cmV0dXJuIGwubmIkaW5wbGFjZV9sc2hpZnQ7Y2FzZSBcIlJTaGlmdFwiOnJldHVybiBsLm5iJGlucGxhY2VfcnNoaWZ0O2Nhc2UgXCJCaXRBbmRcIjpyZXR1cm4gbC5uYiRpbnBsYWNlX2FuZDtjYXNlIFwiQml0T3JcIjpyZXR1cm4gbC5uYiRpbnBsYWNlX29yO2Nhc2UgXCJCaXRYb3JcIjpyZXR1cm4gbC5uYiRpbnBsYWNlX3hvcn19ZnVuY3Rpb24gZihsLHEseil7Y29uc3Qgcj1xLmNvbnN0cnVjdG9yLHQ9bC5jb25zdHJ1Y3RvcjtsZXQgeDtsZXQgdj0hMTtpZihyIT09dCYmdm9pZCAwPT09ci5zayRiYXNlQ2xhc3MmJnEgaW5zdGFuY2VvZiB0KWlmKHg9ZShxLHopLHZvaWQgMD09PVxueCl2PSEwO2Vsc2UgaWYoeCE9PWUobCx6KSl7dj0hMDt2YXIgQj14LmNhbGwocSxsKTtpZihCIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpcmV0dXJuIEJ9Qj1iKGwseik7aWYodm9pZCAwIT09QiYmKEI9Qi5jYWxsKGwscSksQiE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKXx8IXYmJnIhPT10JiYoeHx8KHg9ZShxLHopKSx2b2lkIDAhPT14JiYoQj14LmNhbGwocSxsKSxCIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpKSlyZXR1cm4gQn1mdW5jdGlvbiBoKGwscSx6KXt2YXIgcj1kKGwseik7cmV0dXJuIHZvaWQgMCE9PXImJihyPXIuY2FsbChsLHEpLHIhPT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCk/cjpmKGwscSx6KX1mdW5jdGlvbiBwKGwpe3UuZm9yRWFjaChxPT57dmFyIFt6LHJdPXE7bFtyXT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50cCRyaWNoY29tcGFyZSh0LFxueil9fSl9ZnVuY3Rpb24gZyhsKXtjb25zdCBxPVNrLnJlZmxlY3RlZE51bWJlclNsb3RzO09iamVjdC5rZXlzKHEpLmZvckVhY2goej0+e2lmKHZvaWQgMCE9PWxbel0pe2NvbnN0IHI9cVt6XSx0PXIucmVmbGVjdGVkLHg9bFt0XTt2b2lkIDAhPT14P251bGw9PT14JiZkZWxldGUgbFt0XTpsW3RdPXIuc2xvdHx8bFt6XX19KX1mdW5jdGlvbiBhKGwpe2NvbnN0IHE9U2suc2VxdWVuY2VBbmRNYXBwaW5nU2xvdHM7T2JqZWN0LmtleXMocSkuZm9yRWFjaCh6PT57dm9pZCAwIT09bFt6XSYmcVt6XS5mb3JFYWNoKHI9PntsW3JdPWxbel19KX0pfVNrLmFic3RyPXt9O1NrLmFic3RyLnR5cGVOYW1lPWZ1bmN0aW9uKGwpe2lmKG51bGwhPWwmJnZvaWQgMCE9PWwudHAkbmFtZSl7bGV0IHE9bC5odCRuYW1lO2lmKHZvaWQgMCE9PXEpcmV0dXJuIHEudG9TdHJpbmcoKTtxPWwudHAkbmFtZTtxLmluY2x1ZGVzKFwiLlwiKSYmKHE9cS5zbGljZShxLmxhc3RJbmRleE9mKFwiLlwiKSsxKSk7cmV0dXJuIHF9U2suYXNzZXJ0cy5mYWlsKGwrXG5cIiBwYXNzZWQgdG8gdHlwZU5hbWVcIik7cmV0dXJuXCI8aW52YWxpZCB0eXBlPlwifTtjb25zdCBjPXtBZGQ6XCIrXCIsU3ViOlwiLVwiLE11bHQ6XCIqXCIsTWF0TXVsdDpcIkBcIixEaXY6XCIvXCIsRmxvb3JEaXY6XCIvL1wiLE1vZDpcIiVcIixEaXZNb2Q6XCJkaXZtb2QoKVwiLFBvdzpcIioqIG9yIHBvdygpXCIsTFNoaWZ0OlwiPDxcIixSU2hpZnQ6XCI+PlwiLEJpdEFuZDpcIiZcIixCaXRYb3I6XCJeXCIsQml0T3I6XCJ8XCJ9LG49e1VBZGQ6XCIrXCIsVVN1YjpcIi1cIixJbnZlcnQ6XCJ+XCJ9O1NrLmFic3RyLm51bWJlckJpbk9wPWZ1bmN0aW9uKGwscSx6KXt2YXIgcjtpZighKHI9ZihsLHEseikpKXRocm93IGw9U2suYWJzdHIudHlwZU5hbWUobCkscT1Tay5hYnN0ci50eXBlTmFtZShxKSxuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYW5kIHR5cGUocykgZm9yIFwiK2Nbel0rXCI6ICdcIitsK1wiJyBhbmQgJ1wiK3ErXCInXCIpO3JldHVybiByfTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJCaW5PcFwiLFNrLmFic3RyLm51bWJlckJpbk9wKTtcblNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcD1mdW5jdGlvbihsLHEseil7dmFyIHI7aWYoIShyPWgobCxxLHopKSl0aHJvdyBsPVNrLmFic3RyLnR5cGVOYW1lKGwpLHE9U2suYWJzdHIudHlwZU5hbWUocSksbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmFuZCB0eXBlKHMpIGZvciBcIitjW3pdK1wiPTogJ1wiK2wrXCInIGFuZCAnXCIrcStcIidcIik7cmV0dXJuIHJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcFwiLFNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcCk7U2suYWJzdHIubnVtYmVyVW5hcnlPcD1mdW5jdGlvbihsLHEpe2lmKFwiTm90XCI9PT1xKXJldHVybiBTay5taXNjZXZhbC5pc1RydWUobCk/U2suYnVpbHRpbi5ib29sLmZhbHNlJDpTay5idWlsdGluLmJvb2wudHJ1ZSQ7Yjp7c3dpdGNoKHEpe2Nhc2UgXCJVU3ViXCI6dmFyIHo9bC5uYiRuZWdhdGl2ZTticmVhayBiO2Nhc2UgXCJVQWRkXCI6ej1sLm5iJHBvc2l0aXZlO2JyZWFrIGI7XG5jYXNlIFwiSW52ZXJ0XCI6ej1sLm5iJGludmVydDticmVhayBifXo9dm9pZCAwfXo9dm9pZCAwIT09ej96LmNhbGwobCk6dm9pZCAwO2lmKCF6KXRocm93IGw9U2suYWJzdHIudHlwZU5hbWUobCksbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFkIG9wZXJhbmQgdHlwZSBmb3IgdW5hcnkgXCIrbltxXStcIjogJ1wiK2wrXCInXCIpO3JldHVybiB6fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJVbmFyeU9wXCIsU2suYWJzdHIubnVtYmVyVW5hcnlPcCk7U2suYWJzdHIuZml4U2VxSW5kZXhfPWZ1bmN0aW9uKGwscSl7cT1Tay5idWlsdGluLmFzbnVtJChxKTswPnEmJmwuc3EkbGVuZ3RoJiYocSs9bC5zcSRsZW5ndGgoKSk7cmV0dXJuIHF9O1NrLmFic3RyLnNlcXVlbmNlQ29udGFpbnM9ZnVuY3Rpb24obCxxLHope2lmKGwuc3EkY29udGFpbnMpcmV0dXJuIGwuc3EkY29udGFpbnMocSx6KTtsPVNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihsKSxmdW5jdGlvbihyKXtyZXR1cm4gcj09PVxucXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHIscSxcIkVxXCIpP25ldyBTay5taXNjZXZhbC5CcmVhayghMCk6ITF9LCExKTtyZXR1cm4gej9sOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhsKX07U2suYWJzdHIuc2VxdWVuY2VDb25jYXQ9ZnVuY3Rpb24obCxxKXtpZihsLnNxJGNvbmNhdClyZXR1cm4gbC5zcSRjb25jYXQocSk7aWYoU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGwpJiZTay5idWlsdGluLmNoZWNrU2VxdWVuY2UocSkmJihxPWYobCxxLFwiQWRkXCIpLHZvaWQgMCE9PXEpKXJldHVybiBxO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShsKStcIicgb2JqZWN0IGNhbid0IGJlIGNvbmNhdGVuYXRlZFwiKTt9O1NrLmFic3RyLnNlcXVlbmNlSW5QbGFjZUNvbmNhdD1mdW5jdGlvbihsLHEpe2lmKGwuc3EkaW5wbGFjZV9jb25jYXQpcmV0dXJuIGwuc3EkaW5wbGFjZV9jb25jYXQocSk7aWYobC5zcSRjb25jYXQpcmV0dXJuIGwuc3EkY29uY2F0KHEpO1xuaWYoU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGwpJiZTay5idWlsdGluLmNoZWNrU2VxdWVuY2UocSkmJihxPWgobCxxLFwiQWRkXCIpLHZvaWQgMCE9PXEpKXJldHVybiBxO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShsKStcIicgb2JqZWN0IGNhbid0IGJlIGNvbmNhdGVuYXRlZFwiKTt9O1NrLmFic3RyLnNlcXVlbmNlR2V0SW5kZXhPZj1mdW5jdGlvbihsLHEpe2lmKGwuaW5kZXgpcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShsLmluZGV4LFtsLHFdKTtsZXQgej0wO2ZvcihsZXQgcj1Tay5hYnN0ci5pdGVyKGwpLHQ9ci50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PXQ7dD1yLnRwJGl0ZXJuZXh0KCkpe2lmKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChxLHQsXCJFcVwiKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh6KTt6Kz0xfXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzZXF1ZW5jZS5pbmRleCh4KTogeCBub3QgaW4gc2VxdWVuY2VcIik7XG59O1NrLmFic3RyLnNlcXVlbmNlR2V0Q291bnRPZj1mdW5jdGlvbihsLHEpe2lmKGwuY291bnQpcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShsLmNvdW50LFtsLHFdKTtsZXQgej0wO2ZvcihsZXQgcj1Tay5hYnN0ci5pdGVyKGwpLHQ9ci50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PXQ7dD1yLnRwJGl0ZXJuZXh0KCkpU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHEsdCxcIkVxXCIpJiYoeis9MSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oeil9O1NrLmFic3RyLnNlcXVlbmNlR2V0SXRlbT1mdW5jdGlvbihsLHEseil7XCJudW1iZXJcIj09PXR5cGVvZiBxJiYocT1uZXcgU2suYnVpbHRpbi5pbnRfKHEpKTtyZXR1cm4gU2suYWJzdHIub2JqZWN0R2V0SXRlbShsLHEseil9O1NrLmFic3RyLnNlcXVlbmNlU2V0SXRlbT1mdW5jdGlvbihsLHEseixyKXtcIm51bWJlclwiPT09dHlwZW9mIHEmJihxPW5ldyBTay5idWlsdGluLmludF8ocSkpO3JldHVybiBTay5hYnN0ci5vYmplY3RTZXRJdGVtKGwsXG5xLHoscil9O1NrLmFic3RyLnNlcXVlbmNlRGVsSXRlbT1mdW5jdGlvbihsLHEseil7cmV0dXJuIFNrLmFic3RyLm9iamVjdERlbEl0ZW0obCxxLHopfTtTay5hYnN0ci5zZXF1ZW5jZUdldFNsaWNlPWZ1bmN0aW9uKGwscSx6KXtyZXR1cm4gU2suYWJzdHIub2JqZWN0R2V0SXRlbShsLG5ldyBTay5idWlsdGluLnNsaWNlKHEseikpfTtTay5hYnN0ci5zZXF1ZW5jZURlbFNsaWNlPWZ1bmN0aW9uKGwscSx6KXtyZXR1cm4gU2suYWJzdHIub2JqZWN0RGVsSXRlbShsLG5ldyBTay5idWlsdGluLnNsaWNlKHEseikpfTtTay5hYnN0ci5zZXF1ZW5jZVNldFNsaWNlPWZ1bmN0aW9uKGwscSx6LHIpe3JldHVybiBTay5hYnN0ci5vYmplY3RTZXRJdGVtKGwsbmV3IFNrLmJ1aWx0aW4uc2xpY2UocSx6KSl9O1NrLmFic3RyLnNlcXVlbmNlVW5wYWNrPWZ1bmN0aW9uKGwscSx6LHIpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUobCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IHVucGFjayBub24taXRlcmFibGUgXCIrXG5Tay5hYnN0ci50eXBlTmFtZShsKStcIiBvYmplY3RcIik7Y29uc3QgdD1Tay5hYnN0ci5pdGVyKGwpLHg9W107bGV0IHY9MCxCOzA8cSYmKEI9U2subWlzY2V2YWwuaXRlckZvcih0LEk9Pnt4LnB1c2goSSk7aWYoKyt2PT09cSlyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrfSkpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihCLCgpPT57aWYoeC5sZW5ndGg8cSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibm90IGVub3VnaCB2YWx1ZXMgdG8gdW5wYWNrIChleHBlY3RlZCBhdCBsZWFzdCBcIit6K1wiLCBnb3QgXCIreC5sZW5ndGgrXCIpXCIpO2lmKCFyKXJldHVybiBTay5taXNjZXZhbC5jaGFpbih0LnRwJGl0ZXJuZXh0KCEwKSxNPT57aWYodm9pZCAwIT09TSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwidG9vIG1hbnkgdmFsdWVzIHRvIHVucGFjayAoZXhwZWN0ZWQgXCIrcStcIilcIik7cmV0dXJuIHh9KTtjb25zdCBJPVtdO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKHQsXG5NPT57SS5wdXNoKE0pfSksKCk9Pntjb25zdCBNPUkubGVuZ3RoK3EtejtpZigwPk0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5vdCBlbm91Z2ggdmFsdWVzIHRvIHVucGFjayAoZXhwZWN0ZWQgYXQgbGVhc3QgXCIreitcIiwgZ290IFwiKyh6K00pK1wiKVwiKTt4LnB1c2gobmV3IFNrLmJ1aWx0aW4ubGlzdChJLnNsaWNlKDAsTSkpKTt4LnB1c2goLi4uSS5zbGljZShNKSk7cmV0dXJuIHh9KX0pfTtTay5hYnN0ci5tYXBwaW5nVW5wYWNrSW50b0tleXdvcmRBcnJheT1mdW5jdGlvbihsLHEseil7aWYocSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdClxLiRpdGVtcygpLmZvckVhY2godD0+e3ZhciBbeCx2XT10O2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcigoei4kcXVhbG5hbWU/ei4kcXVhbG5hbWUrXCIoKSBcIjpcIlwiKStcImtleXdvcmRzIG11c3QgYmUgc3RyaW5nc1wiKTtsLnB1c2goeC52KTtsLnB1c2godil9KTtcbmVsc2V7dmFyIHI9U2suYWJzdHIubG9va3VwU3BlY2lhbChxLFNrLmJ1aWx0aW4uc3RyLiRrZXlzKTtpZih2b2lkIDA9PT1yKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgYSBtYXBwaW5nXCIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkociksdD0+U2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHQpLHg9PntpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyh4KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoKHouJHF1YWxuYW1lP3ouJHF1YWxuYW1lK1wiKCkgXCI6XCJcIikrXCJrZXl3b3JkcyBtdXN0IGJlIHN0cmluZ3NcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHEubXAkc3Vic2NyaXB0KHgsITApLHY9PntsLnB1c2goeC52KTtsLnB1c2godil9KX0pKX19O1NrLmFic3RyLmtleXdvcmRBcnJheUZyb21QeURpY3Q9ZnVuY3Rpb24obCl7Y29uc3QgcT1bXTtsLiRpdGVtcygpLmZvckVhY2goej0+XG57dmFyIFtyLHRdPXo7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcocikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwia2V5d29yZHMgbXVzdCBiZSBzdHJpbmdzXCIpO3EucHVzaChyLnRvU3RyaW5nKCkpO3EucHVzaCh0KX0pO3JldHVybiBxfTtTay5hYnN0ci5rZXl3b3JkQXJyYXlUb1B5RGljdD1mdW5jdGlvbihsKXtjb25zdCBxPW5ldyBTay5idWlsdGluLmRpY3Q7Zm9yKGxldCB6PTA7ejxsLmxlbmd0aDt6Kz0yKXEubXAkYXNzX3N1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5zdHIobFt6XSksbFt6KzFdKTtyZXR1cm4gcX07U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3M9ZnVuY3Rpb24obCxxLHoscix0KXtyPXJ8fFtdO3ZhciB4PXoubGVuZ3RoK3IubGVuZ3RoLzI7aWYoeD5xLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IobCtcIigpIGV4cGVjdGVkIGF0IG1vc3QgXCIrcS5sZW5ndGgrXCIgYXJndW1lbnRzIChcIit4K1wiIGdpdmVuKVwiKTtpZihyLmxlbmd0aHx8XG52b2lkIDAhPT10KXtpZih4PT09cS5sZW5ndGgmJiFyLmxlbmd0aClyZXR1cm4gejtpZigwPT09eCYmcS5sZW5ndGg9PT0odCYmdC5sZW5ndGgpKXJldHVybiB0fWVsc2UgcmV0dXJuIHo7ej16LnNsaWNlKDApO2Zvcih4PTA7eDxyLmxlbmd0aDt4Kz0yKXtjb25zdCB2PXJbeF0udG9TdHJpbmcoKSxCPXJbeCsxXSxJPXEuaW5kZXhPZih2KTtpZigwPD1JKXtpZih2b2lkIDAhPT16W0ldKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihsK1wiKCkgZ290IG11bHRpcGxlIHZhbHVlcyBmb3IgYXJndW1lbnQgJ1wiK3YrXCInXCIpO3pbSV09Qn1lbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihsK1wiKCkgZ290IGFuIHVuZXhwZWN0ZWQga2V5d29yZCBhcmd1bWVudCAnXCIrditcIidcIik7fWlmKHQpe3I9cS5sZW5ndGg7Zm9yKHg9ci0xOzA8PXg7eC0tKXZvaWQgMD09PXpbeF0mJih6W3hdPXRbdC5sZW5ndGgtMS0oci0xLXgpXSk7cT1xLmZpbHRlcigodixCKT0+dm9pZCAwPT09eltCXSk7XG5pZihxLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IobCtcIigpIG1pc3NpbmcgXCIrcS5sZW5ndGgrXCIgcmVxdWlyZWQgcG9zaXRpb25hbCBhcmd1bWVudHM6IFwiK3Euam9pbihcIiwgXCIpKTt9cmV0dXJuIHp9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzXCIsU2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MpO1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3M9ZnVuY3Rpb24obCxxKXtpZihxJiZxLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IobCtcIigpIHRha2VzIG5vIGtleXdvcmQgYXJndW1lbnRzXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuY2hlY2tOb0t3YXJnc1wiLFNrLmFic3RyLmNoZWNrTm9Ld2FyZ3MpO1NrLmFic3RyLmNoZWNrTm9BcmdzPWZ1bmN0aW9uKGwscSx6KXtpZihxPXEubGVuZ3RoKyh6P3oubGVuZ3RoOjApKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihsK1wiKCkgdGFrZXMgbm8gYXJndW1lbnRzIChcIitcbnErXCIgZ2l2ZW4pXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuY2hlY2tOb0FyZ3NcIixTay5hYnN0ci5jaGVja05vQXJncyk7U2suYWJzdHIuY2hlY2tPbmVBcmc9ZnVuY3Rpb24obCxxLHope1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MobCx6KTtpZigxIT09cS5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGwrXCIoKSB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCAoXCIrcS5sZW5ndGgrXCIgZ2l2ZW4pXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuY2hlY2tPbmVBcmdcIixTay5hYnN0ci5jaGVja09uZUFyZyk7U2suYWJzdHIuY2hlY2tBcmdzTGVuPWZ1bmN0aW9uKGwscSx6LHIpe3E9cS5sZW5ndGg7dm9pZCAwPT09ciYmKHI9SW5maW5pdHkpO2lmKHE8enx8cT5yKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcigoej09PXI/bCtcIigpIHRha2VzIGV4YWN0bHkgXCIreitcIiBhcmd1bWVudHNcIjpxPHo/bCtcIigpIHRha2VzIGF0IGxlYXN0IFwiK3orXCIgYXJndW1lbnRzXCI6XG5sK1wiKCkgdGFrZXMgYXQgbW9zdCBcIityK1wiIGFyZ3VtZW50c1wiKSsoXCIgKFwiK3ErXCIgZ2l2ZW4pXCIpKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLmNoZWNrQXJnc0xlblwiLFNrLmFic3RyLmNoZWNrQXJnc0xlbik7U2suYWJzdHIub2JqZWN0Rm9ybWF0PWZ1bmN0aW9uKGwscSl7aWYodm9pZCAwPT09cSlxPVNrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0cjtlbHNlIGlmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIkZvcm1hdCBzcGVjaWZpZXIgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKHEpKTtsPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwobCxTay5idWlsdGluLnN0ci4kZm9ybWF0KTtxPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShsLFtxXSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcocSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19mb3JtYXRfXyBtdXN0IHJldHVybiBhIHN0ciwgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUocSkpO3JldHVybiBxfTtTay5hYnN0ci5vYmplY3RIYXNoPWZ1bmN0aW9uKGwpe2NvbnN0IHE9bC50cCRoYXNoO2lmKHZvaWQgMCE9PXEpe2lmKFNrLmJ1aWx0aW4uY2hlY2tOb25lKHEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInVuaGFzaGFibGUgdHlwZTogJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGwpK1wiJ1wiKTtyZXR1cm4gbC50cCRoYXNoKCl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgSmF2YXNjcmlwdCB0eXBlXCIpO307U2suYWJzdHIub2JqZWN0QWRkPWZ1bmN0aW9uKGwscSl7aWYobC5uYiRhZGQpcmV0dXJuIGwubmIkYWRkKHEpO2w9U2suYWJzdHIudHlwZU5hbWUobCk7cT1Tay5hYnN0ci50eXBlTmFtZShxKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYW5kIHR5cGUocykgZm9yICs6ICdcIitsK1wiJyBhbmQgJ1wiK3ErXCInXCIpO307U2suYWJzdHIub2JqZWN0TmVnYXRpdmU9XG5mdW5jdGlvbihsKXtpZihsLm5iJG5lZ2F0aXZlKXJldHVybiBsLm5iJG5lZ2F0aXZlKCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFkIG9wZXJhbmQgdHlwZSBmb3IgdW5hcnkgLTogJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGwpK1wiJ1wiKTt9O1NrLmFic3RyLm9iamVjdFBvc2l0aXZlPWZ1bmN0aW9uKGwpe2lmKGwubmIkcG9zaXRpdmUpcmV0dXJuIGwubmIkcG9zaXRpdmUoKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJiYWQgb3BlcmFuZCB0eXBlIGZvciB1bmFyeSArOiAnXCIrU2suYWJzdHIudHlwZU5hbWUobCkrXCInXCIpO307U2suYWJzdHIub2JqZWN0RGVsSXRlbT1mdW5jdGlvbihsLHEseil7aWYobC5tcCRhc3Nfc3Vic2NyaXB0KXJldHVybiBsLm1wJGFzc19zdWJzY3JpcHQocSx2b2lkIDAseik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGwpK1wiJyBvYmplY3QgZG9lcyBub3Qgc3VwcG9ydCBpdGVtIGRlbGV0aW9uXCIpO1xufTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5vYmplY3REZWxJdGVtXCIsU2suYWJzdHIub2JqZWN0RGVsSXRlbSk7U2suYWJzdHIub2JqZWN0R2V0SXRlbT1mdW5jdGlvbihsLHEseil7aWYobC5tcCRzdWJzY3JpcHQpcmV0dXJuIGwubXAkc3Vic2NyaXB0KHEseik7aWYoU2suYnVpbHRpbi5jaGVja0NsYXNzKGwpKXtpZihsPT09U2suYnVpbHRpbi50eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi5HZW5lcmljQWxpYXMobCxxKTtjb25zdCByPVNrLmFic3RyLnR5cGVMb29rdXAobCxTay5idWlsdGluLnN0ci4kY2xhc3NfZ2V0aXRlbSk7aWYodm9pZCAwIT09cilyZXR1cm4gbD1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkocixbcV0pLHo/bDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3cobCl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGwpK1wiJyBkb2VzIG5vdCBzdXBwb3J0IGluZGV4aW5nXCIpO1xufTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5vYmplY3RHZXRJdGVtXCIsU2suYWJzdHIub2JqZWN0R2V0SXRlbSk7U2suYWJzdHIub2JqZWN0U2V0SXRlbT1mdW5jdGlvbihsLHEseixyKXtpZihsLm1wJGFzc19zdWJzY3JpcHQpcmV0dXJuIGwubXAkYXNzX3N1YnNjcmlwdChxLHoscik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGwpK1wiJyBkb2VzIG5vdCBzdXBwb3J0IGl0ZW0gYXNzaWdubWVudFwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLm9iamVjdFNldEl0ZW1cIixTay5hYnN0ci5vYmplY3RTZXRJdGVtKTtTay5hYnN0ci5nYXR0cj1mdW5jdGlvbihsLHEseil7ej1sLnRwJGdldGF0dHIocSx6KTtpZih2b2lkIDA9PT16KXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKGwuc2skYXR0ckVycm9yKCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSAnXCIrcS4kanNzdHIoKStcIidcIik7cmV0dXJuIHouJGlzU3VzcGVuc2lvbj9cblNrLm1pc2NldmFsLmNoYWluKHosZnVuY3Rpb24ocil7aWYodm9pZCAwPT09cil0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihsLnNrJGF0dHJFcnJvcigpK1wiIGhhcyBubyBhdHRyaWJ1dGUgJ1wiK3EuJGpzc3RyKCkrXCInXCIpO3JldHVybiByfSk6en07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuZ2F0dHJcIixTay5hYnN0ci5nYXR0cik7U2suYWJzdHIuc2F0dHI9ZnVuY3Rpb24obCxxLHoscil7cmV0dXJuIGwudHAkc2V0YXR0cihxLHoscil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLnNhdHRyXCIsU2suYWJzdHIuc2F0dHIpO1NrLmFic3RyLml0ZXJuZXh0PWZ1bmN0aW9uKGwscSl7cmV0dXJuIGwudHAkaXRlcm5leHQocSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLml0ZXJuZXh0XCIsU2suYWJzdHIuaXRlcm5leHQpO1NrLmFic3RyLml0ZXI9ZnVuY3Rpb24obCl7aWYobC50cCRpdGVyKXtsPWwudHAkaXRlcigpO2lmKGwudHAkaXRlcm5leHQpcmV0dXJuIGw7XG50aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpdGVyKCkgcmV0dXJuZWQgbm9uLWl0ZXJhdG9yIG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGwpK1wiJ1wiKTt9aWYobC5tcCRzdWJzY3JpcHQpcmV0dXJuIG5ldyBTay5idWlsdGluLnNlcV9pdGVyXyhsKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUobCkrXCInIG9iamVjdCBpcyBub3QgaXRlcmFibGVcIik7fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5pdGVyXCIsU2suYWJzdHIuaXRlcik7U2suYWJzdHIubG9va3VwU3BlY2lhbD1mdW5jdGlvbihsLHEpe3ZhciB6PWwub2IkdHlwZTtpZih2b2lkIDA9PT16KVNrLmFzc2VydHMuZmFpbChcImphdmFzY3JpcHQgb2JqZWN0IHNlbnQgdG8gbG9va3VwU3BlY2lhbFwiKTtlbHNlIGlmKHE9ei4kdHlwZUxvb2t1cChxKSx2b2lkIDAhPT1xKXJldHVybiB2b2lkIDAhPT1xLnRwJGRlc2NyX2dldCYmKHE9cS50cCRkZXNjcl9nZXQobCxcbnopKSxxfTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5sb29rdXBTcGVjaWFsXCIsU2suYWJzdHIubG9va3VwU3BlY2lhbCk7U2suYWJzdHIubG9va3VwQXR0cj1mdW5jdGlvbihsLHEpe3RyeXtyZXR1cm4gbC50cCRnZXRhdHRyKHEpfWNhdGNoKHope2lmKCEoeiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IpKXRocm93IHo7fX07U2suYWJzdHIudHlwZUxvb2t1cD1mdW5jdGlvbihsLHEpe3E9bC4kdHlwZUxvb2t1cChxKTtyZXR1cm4gdm9pZCAwIT09cSYmcS50cCRkZXNjcl9nZXQ/cS50cCRkZXNjcl9nZXQobnVsbCxsKTpxfTtTay5hYnN0ci5tYXJrVW5oYXNoYWJsZT1mdW5jdGlvbihsKXtsPWwucHJvdG90eXBlO2wuX19oYXNoX189U2suYnVpbHRpbi5ub25lLm5vbmUkO2wudHAkaGFzaD1Tay5idWlsdGluLm5vbmUubm9uZSR9O1NrLmFic3RyLnNldFVwSW5oZXJpdGFuY2U9ZnVuY3Rpb24obCxxLHoscil7cj1yfHxTay5idWlsdGluLnR5cGU7ej12b2lkIDA9PT1cbno/U2suYnVpbHRpbi5vYmplY3Q6ejtjb25zdCB0PW51bGwhPT16P3oucHJvdG90eXBlOm51bGw7T2JqZWN0LnNldFByb3RvdHlwZU9mKHEsci5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihxLnByb3RvdHlwZSx0KTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhxLnByb3RvdHlwZSx7c2skb2JqZWN0Ont2YWx1ZTpxLHdyaXRhYmxlOiEwfSxvYiR0eXBlOnt2YWx1ZTpxLHdyaXRhYmxlOiEwfSx0cCRuYW1lOnt2YWx1ZTpsLHdyaXRhYmxlOiEwfSx0cCRiYXNlOnt2YWx1ZTp6LHdyaXRhYmxlOiEwfX0pfTtTay5hYnN0ci5zZXRVcEJ1aWx0aW5Ncm89ZnVuY3Rpb24obCl7bGV0IHE9bC5wcm90b3R5cGUudHAkYmFzZTtjb25zdCB6PW51bGw9PT1xP1tdOltxXTtpZihxPT09U2suYnVpbHRpbi5vYmplY3R8fG51bGw9PT1xKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLFwic2skYmFzZUNsYXNzXCIse3ZhbHVlOiEwLHdyaXRhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFxuXCJzayRidWlsdGluQmFzZVwiLHt2YWx1ZTpsLHdyaXRhYmxlOiEwfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsXCJzayRzb2xpZEJhc2VcIix7dmFsdWU6ITAsd3JpdGFibGU6ITB9KTtjb25zdCByPVtsXTtmb3IoO251bGwhPT1xOylyLnB1c2gocSkscT1xLnByb3RvdHlwZS50cCRiYXNlO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGwucHJvdG90eXBlLHtzayRwcm90b3R5cGljYWw6e3ZhbHVlOiEwLHdyaXRhYmxlOiEwfSx0cCRiYXNlczp7dmFsdWU6eix3cml0YWJsZTohMH0sdHAkbXJvOnt2YWx1ZTpyLHdyaXRhYmxlOiEwfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLFwiJHR5cGVMb29rdXBcIix7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvdG90eXBlW3QuJG1hbmdsZWRdfSx3cml0YWJsZTohMH0pfTtsZXQgbT1sPT5Tay5idWlsdGluLnN0ciYmU2suYnVpbHRpbi5zdHIuJGZpeFJlc2VydmVkPyhtPVNrLmJ1aWx0aW4uc3RyLiRmaXhSZXNlcnZlZCxTay5idWlsdGluLnN0ci4kZml4UmVzZXJ2ZWQobCkpOlxubDtTay5hYnN0ci5zZXRVcEdldFNldHM9ZnVuY3Rpb24obCxxKXtpZih2b2lkIDAhPT1Tay5idWlsdGluLmdldHNldF9kZXNjcmlwdG9yKXt2YXIgej1sLnByb3RvdHlwZTtxPXF8fHoudHAkZ2V0c2V0c3x8e307T2JqZWN0LmVudHJpZXMocSkuZm9yRWFjaChyPT57dmFyIFt0LHhdPXI7eC4kbmFtZT10O3pbbSh0KV09bmV3IFNrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3IobCx4KX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh6LFwidHAkZ2V0c2V0c1wiLHt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSl9fTtTay5hYnN0ci5zZXRVcE1ldGhvZHM9ZnVuY3Rpb24obCxxKXtpZih2b2lkIDAhPT1Tay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yKXt2YXIgej1sLnByb3RvdHlwZTtxPXF8fHoudHAkbWV0aG9kc3x8e307T2JqZWN0LmVudHJpZXMocSkuZm9yRWFjaChyPT57dmFyIFt0LHhdPXI7eC4kbmFtZT10O3pbbSh0KV09bmV3IFNrLmJ1aWx0aW4ubWV0aG9kX2Rlc2NyaXB0b3IobCx4KX0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHosXCJ0cCRtZXRob2RzXCIse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KX19O1NrLmFic3RyLnNldFVwQ2xhc3NNZXRob2RzPWZ1bmN0aW9uKGwscSl7aWYodm9pZCAwIT09U2suYnVpbHRpbi5jbGFzc21ldGhvZF9kZXNjcmlwdG9yKXt2YXIgej1sLnByb3RvdHlwZTtxPXF8fHoudHAkY2xhc3NtZXRob2RzfHx7fTtPYmplY3QuZW50cmllcyhxKS5mb3JFYWNoKHI9Pnt2YXIgW3QseF09cjt4LiRuYW1lPXQ7elttKHQpXT1uZXcgU2suYnVpbHRpbi5jbGFzc21ldGhvZF9kZXNjcmlwdG9yKGwseCl9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeixcInRwJGNsYXNzbWV0aG9kc1wiLHt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSl9fTtjb25zdCBrPXtFcTpcIm9iJGVxXCIsTm90RXE6XCJvYiRuZVwiLEd0Olwib2IkZ3RcIixHdEU6XCJvYiRnZVwiLEx0Olwib2IkbHRcIixMdEU6XCJvYiRsZVwifSx1PU9iamVjdC5lbnRyaWVzKGspO1NrLmFic3RyLnNldFVwU2xvdHM9ZnVuY3Rpb24obCxcbnEpe2Z1bmN0aW9uIHoodixCKXt0W3ZdPW5ldyBTay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcihsLFNrLnNsb3RzW3ZdLEIpfWZ1bmN0aW9uIHIodixCKXtcInN0cmluZ1wiPT09dHlwZW9mIHY/eih2LEIpOnYuZm9yRWFjaChJPT57eihJLEIpfSl9aWYodm9pZCAwIT09U2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3Ipe3ZhciB0PWwucHJvdG90eXBlO3E9cXx8dC50cCRzbG90c3x8e307cS50cCRuZXc9PT1Tay5nZW5lcmljLm5ldyYmKHEudHAkbmV3PVNrLmdlbmVyaWMubmV3KGwpKTtxLnRwJHJpY2hjb21wYXJlP3AocSk6cS5vYiRlcSYmKHEudHAkcmljaGNvbXBhcmU9ZnVuY3Rpb24odixCKXtyZXR1cm4gdGhpc1trW0JdXS5jYWxsKHRoaXMsdil9KTtxLnRwJGFzX251bWJlciYmZyhxKTtxLnRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmcmJmEocSk7T2JqZWN0LmVudHJpZXMocSkuZm9yRWFjaCh2PT57dmFyIFtCLEldPXY7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsQix7dmFsdWU6SSxcbndyaXRhYmxlOiEwfSl9KTtxLnRwJG5ldyYmKHQuX19uZXdfXz1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoU2suZ2VuZXJpYy5uZXdNZXRob2REZWYsbCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJzayRzdGF0aWNOZXdcIix7dmFsdWU6bCx3cml0YWJsZTohMH0pKTtTay5zdWJTbG90cy5tYWluX3Nsb3RzLmZvckVhY2godj0+e3ZhciBbQixJXT12O3Y9cVtCXTt2b2lkIDAhPT12JiZyKEksdil9KTt2YXIgeD1xLnRwJGhhc2g7dm9pZCAwIT09eCYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiB4P3ooXCJfX2hhc2hfX1wiLHgpOng9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/dC5fX2hhc2hfXz14OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgdHAkaGFzaFwiKSk7cS50cCRhc19udW1iZXImJlNrLnN1YlNsb3RzLm51bWJlcl9zbG90cy5mb3JFYWNoKHY9Pnt2YXIgW0IsSV09djt2PXFbQl07dm9pZCAwIT09diYmcihJLHYpfSk7cS50cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nJiZTay5zdWJTbG90cy5zZXF1ZW5jZV9hbmRfbWFwcGluZ19zbG90cy5mb3JFYWNoKHY9Plxue3ZhciBbQixJXT12O3Y9cVtCXTt2b2lkIDAhPT12JiZyKEksdil9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInRwJHNsb3RzXCIse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KX19O1NrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3M9ZnVuY3Rpb24obCxxKXtxPXF8fHt9O1NrLmFzc2VydHMuYXNzZXJ0KHEuaGFzT3duUHJvcGVydHkoXCJjb25zdHJ1Y3RvclwiKSxcIkEgY29uc3RydWN0b3IgaXMgcmVxdWlyZWQgdG8gYnVpbGQgYSBuYXRpdmUgY2xhc3NcIik7bGV0IHo9cS5jb25zdHJ1Y3RvcjtTay5hYnN0ci5zZXRVcEluaGVyaXRhbmNlKGwseixxLmJhc2UscS5tZXRhKTtTay5hYnN0ci5zZXRVcEJ1aWx0aW5Ncm8oeik7Y29uc3Qgcj16LnByb3RvdHlwZTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyLHt0cCRzbG90czp7dmFsdWU6cS5zbG90cyx3cml0YWJsZTohMH0sdHAkZ2V0c2V0czp7dmFsdWU6cS5nZXRzZXRzLHdyaXRhYmxlOiEwfSx0cCRtZXRob2RzOnt2YWx1ZTpxLm1ldGhvZHMsXG53cml0YWJsZTohMH0sdHAkY2xhc3NtZXRob2RzOnt2YWx1ZTpxLmNsYXNzbWV0aG9kcyx3cml0YWJsZTohMH19KTtTay5hYnN0ci5zZXRVcFNsb3RzKHoscS5zbG90c3x8e30pO1NrLmFic3RyLnNldFVwTWV0aG9kcyh6LHEubWV0aG9kcyk7U2suYWJzdHIuc2V0VXBHZXRTZXRzKHoscS5nZXRzZXRzKTtTay5hYnN0ci5zZXRVcENsYXNzTWV0aG9kcyh6LHEuY2xhc3NtZXRob2RzKTtPYmplY3QuZW50cmllcyhxLnByb3RvfHx7fSkuZm9yRWFjaCh0PT57dmFyIFt4LHZdPXQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIseCx7dmFsdWU6dix3cml0YWJsZTohMCxlbnVtZXJhYmxlOiEoeC5pbmNsdWRlcyhcIiRcIil8fHggaW4gT2JqZWN0LnByb3RvdHlwZSl9KX0pO09iamVjdC5lbnRyaWVzKHEuZmxhZ3N8fHt9KS5mb3JFYWNoKHQ9Pnt2YXIgW3gsdl09dDtPYmplY3QuZGVmaW5lUHJvcGVydHkoeix4LHt2YWx1ZTp2LHdyaXRhYmxlOiEwfSl9KTtyLmhhc093blByb3BlcnR5KFwidHAkaXRlclwiKSYmXG4ocltTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHAkaXRlcigpW1N5bWJvbC5pdGVyYXRvcl0oKX0pO3ZvaWQgMCE9PVNrLmJ1aWx0aW4uc3RyJiZyLmhhc093blByb3BlcnR5KFwidHAkZG9jXCIpJiYhci5oYXNPd25Qcm9wZXJ0eShcIl9fZG9jX19cIikmJihsPXIudHAkZG9jfHxudWxsLHIuX19kb2NfXz1cInN0cmluZ1wiPT09dHlwZW9mIGw/bmV3IFNrLmJ1aWx0aW4uc3RyKGwpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7cmV0dXJuIHp9O1NrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcz1mdW5jdGlvbihsLHEpe1NrLmFzc2VydHMuYXNzZXJ0KHEuaGFzT3duUHJvcGVydHkoXCJjb25zdHJ1Y3RvclwiKSxcIm11c3QgcHJvdmlkZSBhIGNvbnN0cnVjdG9yXCIpO3Euc2xvdHM9cS5zbG90c3x8e307cS5zbG90cy50cCRpdGVyPVNrLmdlbmVyaWMuc2VsZkl0ZXI7cS5zbG90cy50cCRpdGVybmV4dD1xLnNsb3RzLnRwJGl0ZXJuZXh0fHxxLml0ZXJuZXh0O3Euc2xvdHMudHAkZ2V0YXR0cj1cbnEuc2xvdHMudHAkZ2V0YXR0cnx8U2suZ2VuZXJpYy5nZXRBdHRyO2w9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhsLHEpO1NrLmFic3RyLmJ1aWx0JGl0ZXJhdG9ycy5wdXNoKGwpO2wucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm57bmV4dDooKT0+e2NvbnN0IHo9dGhpcy50cCRpdGVybmV4dCgpO3JldHVybnt2YWx1ZTp6LGRvbmU6dm9pZCAwPT09en19fX07cmV0dXJuIGx9O1NrLmFic3RyLmJ1aWx0JGl0ZXJhdG9ycz1bXTtTay5hYnN0ci5zZXRVcE1vZHVsZU1ldGhvZHM9ZnVuY3Rpb24obCxxLHope09iamVjdC5lbnRyaWVzKHopLmZvckVhY2gocj0+e3ZhciBbdCx4XT1yO3guJG5hbWU9eC4kbmFtZXx8dDtxW3RdPW5ldyBTay5idWlsdGluLnNrX21ldGhvZCh4LG51bGwsbCl9KTtyZXR1cm4gcX07U2suYWJzdHIuc3VwZXJDb25zdHJ1Y3Rvcj1mdW5jdGlvbihsLHEseil7dmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLFxuMik7bC5wcm90b3R5cGUudHAkYmFzZS5hcHBseShxLHIpfX0sZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKGYpe2NvbnN0IGg9Zi5wcm90b3R5cGUscD1oLnRwJGJhc2U7aWYobnVsbD09cClyZXR1cm4hMTtjb25zdCBnPXAucHJvdG90eXBlO3JldHVybiBwLnNrJHNvbGlkU2xvdEJhc2V8fGYuc2skc29saWRTbG90QmFzZXx8Zy5zayRoYXNEaWN0IT09aC5zayRoYXNEaWN0fHxwLnNrJHNvbGlkQmFzZSYmcCE9PVNrLmJ1aWx0aW4ubW9kdWxlPyExOiEwfWZ1bmN0aW9uIGUoZixoKXtmPWYucHJvdG90eXBlO2g9aC5wcm90b3R5cGU7Y29uc3QgcD1mLmh0JHNsb3RzLGc9aC5odCRzbG90cztyZXR1cm4gZi5zayRoYXNEaWN0IT09aC5zayRoYXNEaWN0PyExOnA9PT1nPyEwOnAmJmc/cC5sZW5ndGg9PT1nLmxlbmd0aCYmcC5ldmVyeSgoYSxjKT0+YT09PWdbY10pOihwJiYocC5sZW5ndGh8fG51bGwpKT09PShnJiYoZy5sZW5ndGh8fG51bGwpKX1jb25zdCBkPW5ldyBXZWFrTWFwO1NrLmJ1aWx0aW4ub2JqZWN0PVxuU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIm9iamVjdFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLm9iamVjdCxcImJhZCBjYWxsIHRvIG9iamVjdCwgdXNlICduZXcnXCIpfSxiYXNlOm51bGwsc2xvdHM6e3RwJG5ldyhmLGgpe2lmKGYubGVuZ3RofHxoJiZoLmxlbmd0aCl7aWYodGhpcy50cCRuZXchPT1Tay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUudHAkbmV3KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm9iamVjdC5fX25ld19fKCkgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQgKHRoZSB0eXBlIHRvIGluc3RhbnRpYXRlKVwiKTtpZih0aGlzLnRwJGluaXQ9PT1Tay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUudHAkaW5pdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCIoKSB0YWtlcyBubyBhcmd1bWVudHNcIik7fXJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcn0sXG50cCRpbml0KGYsaCl7aWYoZi5sZW5ndGh8fGgmJmgubGVuZ3RoKXtpZih0aGlzLnRwJGluaXQhPT1Tay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUudHAkaW5pdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvYmplY3QuX19pbml0X18oKSB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCAodGhlIGluc3RhbmNlIHRvIGluaXRpYWxpemUpXCIpO2lmKHRoaXMudHAkbmV3PT09U2suYnVpbHRpbi5vYmplY3QucHJvdG90eXBlLnRwJG5ldyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCIuX19pbml0X18oKSB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCAodGhlIGluc3RhbmNlIHRvIGluaXRpYWxpemUpXCIpO319LHRwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJHNldGF0dHI6U2suZ2VuZXJpYy5zZXRBdHRyLCRyKCl7Y29uc3QgZj1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKHRoaXMsU2suYnVpbHRpbi5zdHIuJG1vZHVsZSk7XG5sZXQgaD1cIlwiO2YmJlNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZikmJihoPWYuditcIi5cIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxcIitoK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiIG9iamVjdD5cIil9LHRwJHN0cigpe3JldHVybiB0aGlzLiRyKCl9LHRwJGhhc2goKXtsZXQgZj1kLmdldCh0aGlzKTtpZih2b2lkIDAhPT1mKXJldHVybiBmO2Y9TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk51bWJlci5NQVhfU0FGRV9JTlRFR0VSLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLzIpO2Quc2V0KHRoaXMsZik7cmV0dXJuIGZ9LHRwJHJpY2hjb21wYXJlKGYsaCl7c3dpdGNoKGgpe2Nhc2UgXCJFcVwiOmY9dGhpcz09PWZ8fFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2JyZWFrO2Nhc2UgXCJOb3RFcVwiOmY9dGhpcy5vYiRlcShmLFwiRXFcIik7ZiE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkJiYoZj0hU2subWlzY2V2YWwuaXNUcnVlKGYpKTtcbmJyZWFrO2RlZmF1bHQ6Zj1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH1yZXR1cm4gZn0sdHAkZG9jOlwiVGhlIG1vc3QgYmFzZSB0eXBlXCJ9LGdldHNldHM6e19fY2xhc3NfXzp7JGdldCgpe3JldHVybiB0aGlzLm9iJHR5cGV9LCRzZXQoZil7aWYodm9pZCAwPT09Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBkZWxldGUgX19jbGFzc19fIGF0dHJpYnV0ZVwiKTtpZighU2suYnVpbHRpbi5jaGVja0NsYXNzKGYpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fY2xhc3NfXyBtdXN0IGJlIHNldCB0byBhIGNsYXNzLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGYpK1wiJyBvYmplY3RcIik7Y29uc3QgaD10aGlzLm9iJHR5cGU7aWYoIShoLiRpc1N1YlR5cGUoU2suYnVpbHRpbi5tb2R1bGUpJiZmLiRpc1N1YlR5cGUoU2suYnVpbHRpbi5tb2R1bGUpfHx2b2lkIDAhPT1oLnByb3RvdHlwZS5odCR0eXBlJiZ2b2lkIDAhPT1mLnByb3RvdHlwZS5odCR0eXBlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCIgX19jbGFzc19fIGFzc2lnbm1lbnQgb25seSBzdXBwb3J0ZWQgZm9yIGhlYXAgdHlwZXMgb3IgTW9kdWxlVHlwZSBzdWJjbGFzc2VzXCIpO1xue2xldCBwPWgsZz1mO2Zvcig7YihwKTspcD1wLnByb3RvdHlwZS50cCRiYXNlO2Zvcig7YihnKTspZz1nLnByb3RvdHlwZS50cCRiYXNlO2lmKHAhPT1nJiYocC5wcm90b3R5cGUudHAkYmFzZSE9PWcucHJvdG90eXBlLnRwJGJhc2V8fCFlKHAsZykpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fY2xhc3NfXyBhc3NpZ25tZW50OiAnXCIrZi5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IGxheW91dCBkaWZmZXJzIGZyb20gJ1wiK2gucHJvdG90eXBlLnRwJG5hbWUrXCInXCIpO31PYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxmLnByb3RvdHlwZSl9LCRkb2M6XCJ0aGUgb2JqZWN0J3MgY2xhc3NcIn19LG1ldGhvZHM6e19fZGlyX186eyRtZXRoOmZ1bmN0aW9uKCl7bGV0IGY9U2suYWJzdHIubG9va3VwQXR0cih0aGlzLFNrLmJ1aWx0aW4uc3RyLiRkaWN0KTtmPXZvaWQgMD09PWY/bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk6ZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdD9cbmYuZGljdCRjb3B5KCk6bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7Y29uc3QgaD1Tay5hYnN0ci5sb29rdXBBdHRyKHRoaXMsU2suYnVpbHRpbi5zdHIuJGNsYXNzKTt2b2lkIDAhPT1oJiZoLiRtZXJnZUNsYXNzRGljdChmKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChmLnNrJGFzYXJyYXkoKSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiRGVmYXVsdCBkaXIoKSBpbXBsZW1lbnRhdGlvbi5cIn0sX19mb3JtYXRfXzp7JG1ldGgoZil7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19mb3JtYXRfXygpIGFyZ3VtZW50IG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZikpO2lmKGYhPT1Tay5idWlsdGluLnN0ci4kZW1wdHkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGB1bnN1cHBvcnRlZCBmb3JtYXQgc3RyaW5nIHBhc3NlZCB0byAke1NrLmFic3RyLnR5cGVOYW1lKHRoaXMpfS5fX2Zvcm1hdF9fYCk7XG5yZXR1cm4gdGhpcy50cCRzdHIoKX0sJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJEZWZhdWx0IG9iamVjdCBmb3JtYXR0ZXIuXCJ9fSxjbGFzc21ldGhvZHM6e19faW5pdF9zdWJjbGFzc19fOnskbWV0aChmKXtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwLE5vS3dhcmdzOiEwfX19LHByb3RvOnt2YWx1ZU9mOk9iamVjdC5wcm90b3R5cGUudmFsdWVPZix0b1N0cmluZygpe3JldHVybiB0aGlzLnRwJHN0cigpLnZ9LGhhc093blByb3BlcnR5Ok9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksaHQkdHlwZTp2b2lkIDAsc2skYXR0ckVycm9yKCl7cmV0dXJuXCInXCIrdGhpcy50cCRuYW1lK1wiJyBvYmplY3RcIn0sJG1lcmdlQ2xhc3NEaWN0KGYpe3ZhciBoPVNrLmFic3RyLmxvb2t1cEF0dHIodGhpcyxTay5idWlsdGluLnN0ci4kZGljdCk7dm9pZCAwIT09aCYmZi5kaWN0JG1lcmdlKGgpO2g9U2suYWJzdHIubG9va3VwQXR0cih0aGlzLFNrLmJ1aWx0aW4uc3RyLiRiYXNlcyk7XG5pZih2b2lkIDAhPT1oKXt2YXIgcD1Tay5idWlsdGluLmxlbihoKS52YWx1ZU9mKCk7Zm9yKGxldCBnPTA7ZzxwO2crKylTay5hYnN0ci5vYmplY3RHZXRJdGVtKGgsbmV3IFNrLmJ1aWx0aW4uaW50XyhnKSkuJG1lcmdlQ2xhc3NEaWN0KGYpfX19fSk7U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZShcInR5cGVcIixTay5idWlsdGluLnR5cGUsU2suYnVpbHRpbi5vYmplY3QpO1NrLmFic3RyLnNldFVwQnVpbHRpbk1ybyhTay5idWlsdGluLnR5cGUpfSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIodCx4LHYpe1NrLmFic3RyLmNoZWNrTm9BcmdzKHRoaXMuJG5hbWUseCx2KTt0PXRoaXMuY2FsbCh0KTtyZXR1cm4gdm9pZCAwPT09dD9Tay5idWlsdGluLm5vbmUubm9uZSQ6dH1mdW5jdGlvbiBlKHQseCx2KXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLHgsdik7dD10aGlzLmNhbGwodCx4WzBdKTtyZXR1cm4gdm9pZCAwPT09dD9Tay5idWlsdGluLm5vbmUubm9uZSQ6dH1mdW5jdGlvbiBkKHQsXG54LHYpe1NrLmFic3RyLmNoZWNrT25lQXJnKHRoaXMuJG5hbWUseCx2KTt0PXRoaXMuY2FsbCh0LHhbMF0sITApO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0LEI9PnZvaWQgMD09PUI/U2suYnVpbHRpbi5ub25lLm5vbmUkOkIpfWZ1bmN0aW9uIGYodCx4LHYpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy4kbmFtZSx2KTtTay5hYnN0ci5jaGVja0FyZ3NMZW4odGhpcy4kbmFtZSx4LDEsMik7dD10aGlzLmNhbGwodCwuLi54KTtyZXR1cm4gdm9pZCAwPT09dD9Tay5idWlsdGluLm5vbmUubm9uZSQ6dH1mdW5jdGlvbiBoKHQseCx2KXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsdik7U2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMuJG5hbWUseCwyLDIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLmNhbGwodCx4WzBdLHhbMV0sITApLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfWZ1bmN0aW9uIHAodCx4LHYpe1NrLmFic3RyLmNoZWNrT25lQXJnKHRoaXMuJG5hbWUsXG54LHYpO3Q9dGhpcy5jYWxsKHQseFswXSx2b2lkIDAsITApO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0LEI9PnZvaWQgMD09PUI/U2suYnVpbHRpbi5ub25lLm5vbmUkOkIpfWZ1bmN0aW9uIGcodCx4LHYpe3Q9ZS5jYWxsKHRoaXMsdCx4LHYpO3JldHVybiB0PT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ/dDpuZXcgU2suYnVpbHRpbi5ib29sKHQpfWZ1bmN0aW9uIGEodCx4LHYpe3JldHVybiBmdW5jdGlvbihCLEksTSl7Qj10LmNhbGwodGhpcyxCLEksTSk7cmV0dXJuIHY/U2subWlzY2V2YWwuY2hhaW4oQix4KTp4KFNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhCKSl9fWZ1bmN0aW9uIGModCl7cmV0dXJuIGZ1bmN0aW9uKCl7Y29uc3QgeD10LnRwJGRlc2NyX2dldD90LnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSk6dDtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHgsW10pfX1mdW5jdGlvbiBuKHQsXG54LHYsQil7cmV0dXJuIGZ1bmN0aW9uKEkpe3JldHVybiBmdW5jdGlvbigpe3ZhciBNPUkudHAkZGVzY3JfZ2V0P0kudHAkZGVzY3JfZ2V0KHRoaXMsdGhpcy5vYiR0eXBlKTpJO009U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KE0sW10pO2lmKCF4KE0pKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0K1wiIHNob3VsZCByZXR1cm4gXCIrditcIiAocmV0dXJuZWQgXCIrU2suYWJzdHIudHlwZU5hbWUoTSkrXCIpXCIpO3JldHVybiB2b2lkIDAhPT1CP0IoTSk6TX19fWZ1bmN0aW9uIG0odCl7cmV0dXJuIGZ1bmN0aW9uKHgpe2NvbnN0IHY9dC50cCRkZXNjcl9nZXQ/dC50cCRkZXNjcl9nZXQodGhpcyx0aGlzLm9iJHR5cGUpOnQ7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh2LFt4XSl9fWZ1bmN0aW9uIGsodCx4KXtsZXQgdj10aGlzLm9iJHR5cGUuJHR5cGVMb29rdXAoU2suYnVpbHRpbi5zdHIuJGdldGF0dHJpYnV0ZSk7aWYodiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ud3JhcHBlcl9kZXNjcmlwdG9yKXJldHVybiB2LmQkd3JhcHBlZC5jYWxsKHRoaXMsXG50LHgpO3YudHAkZGVzY3JfZ2V0JiYodj12LnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSkpO2NvbnN0IEI9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh2LFt0XSksST0+e2lmKCEoSSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IpKXRocm93IEk7fSk7cmV0dXJuIHg/QjpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coQil9ZnVuY3Rpb24gdSh0LHgsdil7cmV0dXJuIGZ1bmN0aW9uKEIpe3JldHVybiBmdW5jdGlvbihJLE0sUyl7bGV0IEU7dm9pZCAwPT09TT8oRT14LHY9bnVsbCk6RT10O2xldCBIPXRoaXMub2IkdHlwZS4kdHlwZUxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoRSkpO2lmKEggaW5zdGFuY2VvZiBTay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcilyZXR1cm4gSC5kJHdyYXBwZWQuY2FsbCh0aGlzLEksTSk7SC50cCRkZXNjcl9nZXQmJihIPUgudHAkZGVzY3JfZ2V0KHRoaXMsXG50aGlzLm9iJHR5cGUsUykpO2lmKHZvaWQgMCE9PUgpST1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoSCx2b2lkIDA9PT1NP1tJXTpbSSxNXSk7ZWxzZXtpZih2KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIicgb2JqZWN0IFwiK3YpO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKEUpO31yZXR1cm4gUz9JOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhJKX19fWZ1bmN0aW9uIGwodCx4KXtsZXQgdj10Lm9iJHR5cGU7Zm9yKDt2JiZ2b2lkIDAhPT12LnNrJGtsYXNzOyl2PXYucHJvdG90eXBlLnRwJGJhc2U7aWYodiYmdi5wcm90b3R5cGUudHAkc2V0YXR0ciE9PXgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgYXBwbHkgdGhpcyBcIit4LiRuYW1lK1wiIHRvIFwiK1NrLmFic3RyLnR5cGVOYW1lKHQpK1wiIG9iamVjdFwiKTt9U2suc2xvdHM9T2JqZWN0LmNyZWF0ZShudWxsKTtcbkY9U2suc2xvdHM7U2suc2xvdHMuX19pbml0X189eyRuYW1lOlwiX19pbml0X19cIiwkc2xvdF9uYW1lOlwidHAkaW5pdFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHgsdil7Y29uc3QgQj10LnRwJGRlc2NyX2dldD90LnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSk6dDt4PVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShCLHgsdik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHgsST0+e2lmKCFTay5idWlsdGluLmNoZWNrTm9uZShJKSYmdm9pZCAwIT09SSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2luaXRfXygpIHNob3VsZCByZXR1cm4gTm9uZSwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKEkpKTt9KX19LCR3cmFwcGVyOmZ1bmN0aW9uKHQseCx2KXt0aGlzLmNhbGwodCx4LHYpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCAqYXJncywgKiprd2FyZ3MpXCIsJGZsYWdzOntGYXN0Q2FsbDohMH0sXG4kZG9jOlwiSW5pdGlhbGl6ZSBzZWxmLiAgU2VlIGhlbHAodHlwZShzZWxmKSkgZm9yIGFjY3VyYXRlIHNpZ25hdHVyZS5cIn07Ri5fX25ld19fPXskbmFtZTpcIl9fbmV3X19cIiwkc2xvdF9uYW1lOlwidHAkbmV3XCIsJHNsb3RfZnVuYzpmdW5jdGlvbih0KXtjb25zdCB4PWZ1bmN0aW9uKHYsQil7bGV0IEk9dDt0LnRwJGRlc2NyX2dldCYmKEk9dC50cCRkZXNjcl9nZXQobnVsbCx0aGlzLmNvbnN0cnVjdG9yKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShJLFt0aGlzLmNvbnN0cnVjdG9yLC4uLnZdLEIpfTt4LnNrJHN0YXRpY19uZXc9ITE7cmV0dXJuIHh9LCR3cmFwcGVyOm51bGwsJHRleHRzaWc6XCIoJHNlbGYsIC8sICphcmdzLCAqKmt3YXJncylcIiwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkZG9jOlwiQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgb2JqZWN0LlwifTtGLl9fY2FsbF9fPXskbmFtZTpcIl9fY2FsbF9fXCIsJHNsb3RfbmFtZTpcInRwJGNhbGxcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih4LFxudil7Y29uc3QgQj10LnRwJGRlc2NyX2dldD90LnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSk6dDtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KEIseCx2KX19LCR3cmFwcGVyOmZ1bmN0aW9uKHQseCx2KXt0PXQudHAkY2FsbCh4LHYpO3JldHVybiB2b2lkIDA9PT10P1NrLmJ1aWx0aW4ubm9uZS5ub25lJDp0fSwkdGV4dHNpZzpcIigkc2VsZiwgLywgKmFyZ3MsICoqa3dhcmdzKVwiLCRmbGFnczp7RmFzdENhbGw6ITB9LCRkb2M6XCJDYWxsIHNlbGYgYXMgYSBmdW5jdGlvbi5cIn07Ri5fX3JlcHJfXz17JG5hbWU6XCJfX3JlcHJfX1wiLCRzbG90X25hbWU6XCIkclwiLCRzbG90X2Z1bmM6bihcIl9fcmVwcl9fXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyxcInN0clwiKSwkd3JhcHBlcjpiLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiUmV0dXJuIHJlcHIoc2VsZikuXCJ9O0YuX19zdHJfXz17JG5hbWU6XCJfX3N0cl9fXCIsJHNsb3RfbmFtZTpcInRwJHN0clwiLFxuJHNsb3RfZnVuYzpuKFwiX19zdHJfX1wiLFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcsXCJzdHJcIiksJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIlJldHVybiBzdHIoc2VsZikuXCJ9O3ZhciBxPW4oXCJfX2hhc2hfX1wiLFNrLmJ1aWx0aW4uY2hlY2tJbnQsXCJpbnRcIix0PT5cIm51bWJlclwiPT09dHlwZW9mIHQudj90LnY6dC50cCRoYXNoKCkpO0YuX19oYXNoX189eyRuYW1lOlwiX19oYXNoX19cIiwkc2xvdF9uYW1lOlwidHAkaGFzaFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/U2suYnVpbHRpbi5ub25lLm5vbmUkOnEodCl9LCR3cmFwcGVyOmEoYix0PT5uZXcgU2suYnVpbHRpbi5pbnRfKHQpKSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIlJldHVybiBoYXNoKHNlbGYpLlwifTtGLl9fZ2V0YXR0cmlidXRlX189eyRuYW1lOlwiX19nZXRhdHRyaWJ1dGVfX1wiLFxuJHNsb3RfbmFtZTpcInRwJGdldGF0dHJcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih4LHYpe2xldCBCPXRoaXMub2IkdHlwZS4kdHlwZUxvb2t1cChTay5idWlsdGluLnN0ci4kZ2V0YXR0cik7aWYodm9pZCAwPT09QilyZXR1cm4gay5jYWxsKHRoaXMseCx2KTtjb25zdCBJPVNrLm1pc2NldmFsLmNoYWluKGsuY2FsbCh0aGlzLHgsdiksTT0+U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PntpZih2b2lkIDAhPT1NKXJldHVybiBNO0IudHAkZGVzY3JfZ2V0JiYoQj1CLnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSkpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoQixbeF0pfSxmdW5jdGlvbihTKXtpZighKFMgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBTO30pKTtyZXR1cm4gdj9JOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhJKX19LCR3cmFwcGVyOmZ1bmN0aW9uKHQsXG54LHYpe1NrLmFic3RyLmNoZWNrT25lQXJnKHRoaXMuJG5hbWUseCx2KTtjb25zdCBCPXhbMF07aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoQikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYXR0cmlidXRlIG5hbWUgbXVzdCBiZSBzdHJpbmcsIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoQikrXCInXCIpO3g9dGhpcy5jYWxsKHQsQiwhMCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHgsST0+e2lmKHZvaWQgMD09PUkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoU2suYWJzdHIudHlwZU5hbWUodCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSBcIitCLiRqc3N0cigpKTtyZXR1cm4gSX0pfSwkdGV4dHNpZzpcIigkc2VsZiwgbmFtZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBnZXRhdHRyKHNlbGYsIG5hbWUpLlwifTtGLl9fZ2V0YXR0cl9fPXskbmFtZTpcIl9fZ2V0YXR0cl9fXCIsJHNsb3RfbmFtZTpcInRwJGdldGF0dHJcIiwkc2xvdF9mdW5jOkYuX19nZXRhdHRyaWJ1dGVfXy4kc2xvdF9mdW5jLFxuJHdyYXBwZXI6bnVsbCwkdGV4dHNpZzpcIigkc2VsZiwgbmFtZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBnZXRhdHRyKHNlbGYsIG5hbWUpLlwifTtGLl9fc2V0YXR0cl9fPXskbmFtZTpcIl9fc2V0YXR0cl9fXCIsJHNsb3RfbmFtZTpcInRwJHNldGF0dHJcIiwkc2xvdF9mdW5jOnUoXCJfX3NldGF0dHJfX1wiLFwiX19kZWxhdHRyX19cIiksJHdyYXBwZXI6ZnVuY3Rpb24odCx4LHYpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy4kbmFtZSx2KTtTay5hYnN0ci5jaGVja0FyZ3NMZW4odGhpcy4kbmFtZSx4LDIsMik7bCh0LHRoaXMpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLmNhbGwodCx4WzBdLHhbMV0sITApLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfSwkdGV4dHNpZzpcIigkc2VsZiwgbmFtZSwgdmFsdWUsIC8pXCIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkZG9jOlwiSW1wbGVtZW50IHNldGF0dHIoc2VsZiwgbmFtZSwgdmFsdWUpLlwifTtGLl9fZGVsYXR0cl9fPVxueyRuYW1lOlwiX19kZWxhdHRyX19cIiwkc2xvdF9uYW1lOlwidHAkc2V0YXR0clwiLCRzbG90X2Z1bmM6Ri5fX3NldGF0dHJfXy4kc2xvdF9mdW5jLCR3cmFwcGVyOmZ1bmN0aW9uKHQseCx2KXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLHgsdik7bCh0LHRoaXMpO3RoaXMuY2FsbCh0LHhbMF0pO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuYW1lLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IGRlbGF0dHIoc2VsZiwgbmFtZSkuXCJ9O0YuX19nZXRfXz17JG5hbWU6XCJfX2dldF9fXCIsJHNsb3RfbmFtZTpcInRwJGRlc2NyX2dldFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHgsdixCKXtudWxsPT09eCYmKHg9U2suYnVpbHRpbi5ub25lLm5vbmUkKTtudWxsPT12JiYodj1Tay5idWlsdGluLm5vbmUubm9uZSQpO2NvbnN0IEk9dC50cCRkZXNjcl9nZXQ/dC50cCRkZXNjcl9nZXQodGhpcyx0aGlzLm9iJHR5cGUpOlxudDt4PVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShJLFt4LHZdKTtyZXR1cm4gQj94OlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyh4KX19LCR3cmFwcGVyOmZ1bmN0aW9uKHQseCx2KXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsdik7U2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMuJG5hbWUseCwxLDIpO3Y9eFswXTt4PXhbMV07dj09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCYmKHY9bnVsbCk7eD09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCYmKHg9bnVsbCk7aWYobnVsbD09PXgmJm51bGw9PT12KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fZ2V0X18oTm9uZSwgTm9uZSkgaXMgaW52YWxpZFwiKTtyZXR1cm4gdGhpcy5jYWxsKHQsdix4LCEwKX0sJHRleHRzaWc6XCIoJHNlbGYsIGluc3RhbmNlLCBvd25lciwgLylcIiwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCRkb2M6XCJSZXR1cm4gYW4gYXR0cmlidXRlIG9mIGluc3RhbmNlLCB3aGljaCBpcyBvZiB0eXBlIG93bmVyLlwifTtcbkYuX19zZXRfXz17JG5hbWU6XCJfX3NldF9fXCIsJHNsb3RfbmFtZTpcInRwJGRlc2NyX3NldFwiLCRzbG90X2Z1bmM6dShcIl9fc2V0X19cIixcIl9fZGVsZXRlX19cIiksJHdyYXBwZXI6aCwkdGV4dHNpZzpcIigkc2VsZiwgaW5zdGFuY2UsIHZhbHVlLCAvKVwiLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJGRvYzpcIlNldCBhbiBhdHRyaWJ1dGUgb2YgaW5zdGFuY2UgdG8gdmFsdWUuXCJ9O0YuX19kZWxldGVfXz17JG5hbWU6XCJfX2RlbGV0ZV9fXCIsJHNsb3RfbmFtZTpcInRwJGRlc2NyX3NldFwiLCRzbG90X2Z1bmM6Ri5fX3NldF9fLiRzbG90X2Z1bmMsJHdyYXBwZXI6cCwkdGV4dHNpZzpcIigkc2VsZiwgaW5zdGFuY2UsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJEZWxldGUgYW4gYXR0cmlidXRlIG9mIGluc3RhbmNlLlwifTtGLl9fZXFfXz17JG5hbWU6XCJfX2VxX19cIiwkc2xvdF9uYW1lOlwib2IkZXFcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsXG4kZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmPT12YWx1ZS5cIn07Ri5fX2dlX189eyRuYW1lOlwiX19nZV9fXCIsJHNsb3RfbmFtZTpcIm9iJGdlXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmcsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY+PXZhbHVlLlwifTtGLl9fZ3RfXz17JG5hbWU6XCJfX2d0X19cIiwkc2xvdF9uYW1lOlwib2IkZ3RcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZj52YWx1ZS5cIn07Ri5fX2xlX189eyRuYW1lOlwiX19sZV9fXCIsJHNsb3RfbmFtZTpcIm9iJGxlXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmcsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY8PXZhbHVlLlwifTtGLl9fbHRfXz17JG5hbWU6XCJfX2x0X19cIixcbiRzbG90X25hbWU6XCJvYiRsdFwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjpnLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmPHZhbHVlLlwifTtGLl9fbmVfXz17JG5hbWU6XCJfX25lX19cIiwkc2xvdF9uYW1lOlwib2IkbmVcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZiE9dmFsdWUuXCJ9O0YuX19pdGVyX189eyRuYW1lOlwiX19pdGVyX19cIiwkc2xvdF9uYW1lOlwidHAkaXRlclwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpiLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiSW1wbGVtZW50IGl0ZXIoc2VsZikuXCJ9O0YuX19uZXh0X189eyRuYW1lOlwiX19uZXh0X19cIiwkc2xvdF9uYW1lOlwidHAkaXRlcm5leHRcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih4KXtjb25zdCB2PVxudC50cCRkZXNjcl9nZXQ/dC50cCRkZXNjcl9nZXQodGhpcyx0aGlzLm9iJHR5cGUpOnQsQj1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHYsW10pLEk9PntpZihJIGluc3RhbmNlb2YgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uKXRoaXMuZ2kkcmV0PUkuJHZhbHVlO2Vsc2UgdGhyb3cgSTt9KTtyZXR1cm4geD9COlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhCKX19LCR3cmFwcGVyOmZ1bmN0aW9uKHQseCx2KXtTay5hYnN0ci5jaGVja05vQXJncyh0aGlzLiRuYW1lLHgsdik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHQudHAkaXRlcm5leHQoITApLEI9PntpZih2b2lkIDA9PT1CKXRocm93IG5ldyBTay5idWlsdGluLlN0b3BJdGVyYXRpb247cmV0dXJuIEJ9KX0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJJbXBsZW1lbnQgbmV4dChzZWxmKS5cIn07Ri5fX2xlbl9fPVxueyRuYW1lOlwiX19sZW5fX1wiLCRzbG90X25hbWU6XCJzcSRsZW5ndGhcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih4KXtjb25zdCB2PXQudHAkZGVzY3JfZ2V0P3QudHAkZGVzY3JfZ2V0KHRoaXMsdGhpcy5vYiR0eXBlKTp0O2lmKHgpcmV0dXJuIHg9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHYsW10pLFNrLm1pc2NldmFsLmNoYWluKHgsQj0+U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coQikpO3g9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHYsW10pO3JldHVybiBTay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyh4KX19LCR3cmFwcGVyOmEoZnVuY3Rpb24odCx4LHYpe1NrLmFic3RyLmNoZWNrTm9BcmdzKHRoaXMuJG5hbWUseCx2KTt0PXRoaXMuY2FsbCh0LCEwKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odCxCPT52b2lkIDA9PT1CP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpCKX0sdD0+bmV3IFNrLmJ1aWx0aW4uaW50Xyh0KSwhMCksJGZsYWdzOntOb0FyZ3M6ITB9LFxuJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBsZW4oc2VsZikuXCJ9O0YuX19jb250YWluc19fPXskbmFtZTpcIl9fY29udGFpbnNfX1wiLCRzbG90X25hbWU6XCJzcSRjb250YWluc1wiLCRzbG90X2Z1bmM6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHgsdil7Y29uc3QgQj10LnRwJGRlc2NyX2dldD90LnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSk6dDt4PVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShCLFt4XSk7eD1Tay5taXNjZXZhbC5jaGFpbih4LEk9PlNrLm1pc2NldmFsLmlzVHJ1ZShJKSk7cmV0dXJuIHguJGlzU3VzcGVuc2lvbj92P3g6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHgpOnh9fSwkd3JhcHBlcjphKGQsdD0+bmV3IFNrLmJ1aWx0aW4uYm9vbCh0KSwhMCksJHRleHRzaWc6XCIoJHNlbGYsIGtleSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBrZXkgaW4gc2VsZi5cIn07Ri5fX2dldGl0ZW1fXz1cbnskbmFtZTpcIl9fZ2V0aXRlbV9fXCIsJHNsb3RfbmFtZTpcIm1wJHN1YnNjcmlwdFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHgsdil7Y29uc3QgQj10LnRwJGRlc2NyX2dldD90LnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSk6dDt4PVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShCLFt4XSk7cmV0dXJuIHY/eDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coeCl9fSwkd3JhcHBlcjpkLCR0ZXh0c2lnOlwiKCRzZWxmLCBrZXksIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZltrZXldLlwifTtGLl9fc2V0aXRlbV9fPXskbmFtZTpcIl9fc2V0aXRlbV9fXCIsJHNsb3RfbmFtZTpcIm1wJGFzc19zdWJzY3JpcHRcIiwkc2xvdF9mdW5jOnUoXCJfX3NldGl0ZW1fX1wiLFwiX19kZWxpdGVtX19cIixcImRvZXMgbm90IHN1cHBvcnQgaXRlbSBhc3NpZ25tZW50XCIpLCR3cmFwcGVyOmgsJHRleHRzaWc6XCIoJHNlbGYsIGtleSwgdmFsdWUsIC8pXCIsXG4kZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCRkb2M6XCJTZXQgc2VsZltrZXldIHRvIHZhbHVlLlwifTtGLl9fZGVsaXRlbV9fPXskbmFtZTpcIl9fZGVsaXRlbV9fXCIsJHNsb3RfbmFtZTpcIm1wJGFzc19zdWJzY3JpcHRcIiwkc2xvdF9mdW5jOkYuX19zZXRpdGVtX18uJHNsb3RfZnVuYywkd3JhcHBlcjpwLCR0ZXh0c2lnOlwiKCRzZWxmLCBrZXksIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJEZWxldGUgc2VsZltrZXldLlwifTtGLl9fYWRkX189eyRuYW1lOlwiX19hZGRfX1wiLCRzbG90X25hbWU6XCJuYiRhZGRcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZit2YWx1ZS5cIn07Ri5fX3JhZGRfXz17JG5hbWU6XCJfX3JhZGRfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfYWRkXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLFxuJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUrc2VsZi5cIn07Ri5fX2lhZGRfXz17JG5hbWU6XCJfX2lhZGRfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX2FkZFwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmKz12YWx1ZS5cIn07Ri5fX3N1Yl9fPXskbmFtZTpcIl9fc3ViX19cIiwkc2xvdF9uYW1lOlwibmIkc3VidHJhY3RcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZi12YWx1ZS5cIn07Ri5fX3JzdWJfXz17JG5hbWU6XCJfX3JzdWJfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUtc2VsZi5cIn07XG5GLl9faW11bF9fPXskbmFtZTpcIl9faW11bF9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2VfbXVsdGlwbHlcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZio9dmFsdWUuXCJ9O0YuX19tdWxfXz17JG5hbWU6XCJfX211bF9fXCIsJHNsb3RfbmFtZTpcIm5iJG11bHRpcGx5XCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGYqdmFsdWUuXCJ9O0YuX19ybXVsX189eyRuYW1lOlwiX19ybXVsX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX211bHRpcGx5XCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlKnNlbGYuXCJ9O0YuX19pc3ViX189eyRuYW1lOlwiX19pc3ViX19cIixcbiRzbG90X25hbWU6XCJuYiRpbnBsYWNlX3N1YnRyYWN0XCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGYtPXZhbHVlLlwifTtGLl9fbW9kX189eyRuYW1lOlwiX19tb2RfX1wiLCRzbG90X25hbWU6XCJuYiRyZW1haW5kZXJcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZiV2YWx1ZS5cIn07Ri5fX3Jtb2RfXz17JG5hbWU6XCJfX3Jtb2RfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfcmVtYWluZGVyXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlJXNlbGYuXCJ9O0YuX19pbW9kX189eyRuYW1lOlwiX19pbW9kX19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9yZW1haW5kZXJcIixcbiRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCB2YWx1ZSU9c2VsZi5cIn07Ri5fX2Rpdm1vZF9fPXskbmFtZTpcIl9fZGl2bW9kX19cIiwkc2xvdF9uYW1lOlwibmIkZGl2bW9kXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIGRpdm1vZChzZWxmLCB2YWx1ZSkuXCJ9O0YuX19yZGl2bW9kX189eyRuYW1lOlwiX19yZGl2bW9kX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX2Rpdm1vZFwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBkaXZtb2QodmFsdWUsIHNlbGYpXCJ9O0YuX19wb3NfXz17JG5hbWU6XCJfX3Bvc19fXCIsJHNsb3RfbmFtZTpcIm5iJHBvc2l0aXZlXCIsJHNsb3RfZnVuYzpjLFxuJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIitzZWxmXCJ9O0YuX19uZWdfXz17JG5hbWU6XCJfX25lZ19fXCIsJHNsb3RfbmFtZTpcIm5iJG5lZ2F0aXZlXCIsJHNsb3RfZnVuYzpjLCR3cmFwcGVyOmIsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCItc2VsZlwifTtGLl9fYWJzX189eyRuYW1lOlwiX19hYnNfX1wiLCRzbG90X25hbWU6XCJuYiRhYnNcIiwkc2xvdF9mdW5jOmMsJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcImFicyhzZWxmKVwifTtGLl9fYm9vbF9fPXskbmFtZTpcIl9fYm9vbF9fXCIsJHNsb3RfbmFtZTpcIm5iJGJvb2xcIiwkc2xvdF9mdW5jOm4oXCJfX2Jvb2xfX1wiLFNrLmJ1aWx0aW4uY2hlY2tCb29sLFwiYm9vbFwiLHQ9PjAhPT10LnYpLCR3cmFwcGVyOmEoYix0PT5uZXcgU2suYnVpbHRpbi5ib29sKHQpKSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIixcbiRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwic2VsZiAhPSAwXCJ9O0YuX19pbnZlcnRfXz17JG5hbWU6XCJfX2ludmVydF9fXCIsJHNsb3RfbmFtZTpcIm5iJGludmVydFwiLCRzbG90X2Z1bmM6Yywkd3JhcHBlcjpiLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwifnNlbGZcIn07Ri5fX2xzaGlmdF9fPXskbmFtZTpcIl9fbHNoaWZ0X19cIiwkc2xvdF9uYW1lOlwibmIkbHNoaWZ0XCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY8PHZhbHVlLlwifTtGLl9fcmxzaGlmdF9fPXskbmFtZTpcIl9fcmxzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9sc2hpZnRcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWU8PHNlbGYuXCJ9O0YuX19yc2hpZnRfXz1cbnskbmFtZTpcIl9fcnNoaWZ0X19cIiwkc2xvdF9uYW1lOlwibmIkcnNoaWZ0XCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY+PnZhbHVlLlwifTtGLl9fcnJzaGlmdF9fPXskbmFtZTpcIl9fcnJzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9yc2hpZnRcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWU+PnNlbGYuXCJ9O0YuX19pbHNoaWZ0X189eyRuYW1lOlwiX19pbHNoaWZ0X19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9sc2hpZnRcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZjw8PXZhbHVlLlwifTtGLl9faXJzaGlmdF9fPXskbmFtZTpcIl9faXJzaGlmdF9fXCIsXG4kc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9yc2hpZnRcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZj0+PnZhbHVlLlwifTtGLl9fYW5kX189eyRuYW1lOlwiX19hbmRfX1wiLCRzbG90X25hbWU6XCJuYiRhbmRcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZiZ2YWx1ZS5cIn07Ri5fX3JhbmRfXz17JG5hbWU6XCJfX3JhbmRfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZlbGN0ZWRfYW5kXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlJnNlbGYuXCJ9O0YuX19pYW5kX189eyRuYW1lOlwiX19pYW5kX19cIiwkc2xvdF9uYW1lOlwibmIkYW5kXCIsJHNsb3RfZnVuYzptLFxuJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZiY9dmFsdWUuXCJ9O0YuX194b3JfXz17JG5hbWU6XCJfX3hvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJHhvclwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmXnZhbHVlLlwifTtGLl9fcnhvcl9fPXskbmFtZTpcIl9fcnhvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF94b3JcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWVec2VsZi5cIn07Ri5fX2l4b3JfXz17JG5hbWU6XCJfX2l4b3JfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX3hvclwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIixcbiRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGZePXZhbHVlLlwifTtGLl9fb3JfXz17JG5hbWU6XCJfX29yX19cIiwkc2xvdF9uYW1lOlwibmIkb3JcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZnx2YWx1ZS5cIn07Ri5fX3Jvcl9fPXskbmFtZTpcIl9fcm9yX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX29yXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlfHNlbGYuXCJ9O0YuX19pb3JfXz17JG5hbWU6XCJfX2lvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2Vfb3JcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZnw9dmFsdWUuXCJ9O1xuRi5fX2ludF9fPXskbmFtZTpcIl9faW50X19cIiwkc2xvdF9uYW1lOlwibmIkaW50XCIsJHNsb3RfZnVuYzpuKFwiX19pbnRfX1wiLFNrLmJ1aWx0aW4uY2hlY2tJbnQsXCJpbnRcIiksJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcImludChzZWxmKVwifTtGLl9fZmxvYXRfXz17JG5hbWU6XCJfX2Zsb2F0X19cIiwkc2xvdF9uYW1lOlwibmIkZmxvYXRcIiwkc2xvdF9mdW5jOm4oXCJfX2Zsb2F0X19cIixTay5idWlsdGluLmNoZWNrRmxvYXQsXCJmbG9hdFwiKSwkd3JhcHBlcjpiLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiZmxvYXQoc2VsZilcIn07Ri5fX2Zsb29yZGl2X189eyRuYW1lOlwiX19mbG9vcmRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJGZsb29yX2RpdmlkZVwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmLy92YWx1ZS5cIn07XG5GLl9fcmZsb29yZGl2X189eyRuYW1lOlwiX19yZmxvb3JkaXZfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlLy9zZWxmLlwifTtGLl9faWZsb29yZGl2X189eyRuYW1lOlwiX19pZmxvb3JkaXZfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX2Zsb29yX2RpdmlkZVwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmLy89dmFsdWUuXCJ9O0YuX190cnVlZGl2X189eyRuYW1lOlwiX190cnVlZGl2X19cIiwkc2xvdF9uYW1lOlwibmIkZGl2aWRlXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGYvdmFsdWUuXCJ9O1xuRi5fX3J0cnVlZGl2X189eyRuYW1lOlwiX19ydHJ1ZWRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9kaXZpZGVcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUvc2VsZi5cIn07Ri5fX2l0cnVlZGl2X189eyRuYW1lOlwiX19pdHJ1ZWRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2VfZGl2aWRlXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGYvPXZhbHVlLlwifTtGLl9faW5kZXhfXz17JG5hbWU6XCJfX2luZGV4X19cIiwkc2xvdF9uYW1lOlwibmIkaW5kZXhcIiwkc2xvdF9mdW5jOm4oXCJfX2luZGV4X19cIixTay5idWlsdGluLmNoZWNrSW50LFwiaW50XCIsdD0+dC52KSwkd3JhcHBlcjphKGIsdD0+bmV3IFNrLmJ1aWx0aW4uaW50Xyh0KSksJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsXG4kZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIlJldHVybiBzZWxmIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyLCBpZiBzZWxmIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgYW4gaW5kZXggaW50byBhIGxpc3QuXCJ9O0YuX19wb3dfXz17JG5hbWU6XCJfX3Bvd19fXCIsJHNsb3RfbmFtZTpcIm5iJHBvd2VyXCIsJHNsb3RfZnVuYzpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oeCx2KXtjb25zdCBCPXQudHAkZGVzY3JfZ2V0P3QudHAkZGVzY3JfZ2V0KHRoaXMsdGhpcy5vYiR0eXBlKTp0O3JldHVybiB2b2lkIDA9PXY/U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KEIsW3hdKTpTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoQixbeCx2XSl9fSwkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgbW9kPU5vbmUsIC8pXCIsJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkZG9jOlwiUmV0dXJuIHBvdyhzZWxmLCB2YWx1ZSwgbW9kKS5cIn07Ri5fX3Jwb3dfXz17JG5hbWU6XCJfX3Jwb3dfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfcG93ZXJcIixcbiRzbG90X2Z1bmM6Ri5fX3Bvd19fLiRzbG90X2Z1bmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIG1vZD1Ob25lLCAvKVwiLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJGRvYzpcIlJldHVybiBwb3codmFsdWUsIHNlbGYsIG1vZCkuXCJ9O0YuX19pcG93X189eyRuYW1lOlwiX19pcG93X19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9wb3dlclwiLCRzbG90X2Z1bmM6Ri5fX3Bvd19fLiRzbG90X2Z1bmMsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIG1vZD1Ob25lLCAvKVwiLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJGRvYzpcIkltcGxlbWVudCAqKj1cIn07Ri5fX21hdG11bF9fPXskbmFtZTpcIl9fbWF0bXVsX19cIiwkc2xvdF9uYW1lOlwibmIkbWF0cml4X211bHRpcGx5XCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGZAdmFsdWUuXCJ9O1xuRi5fX3JtYXRtdWxfXz17JG5hbWU6XCJfX3JtYXRtdWxfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfbWF0cml4X211bHRpcGx5XCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlQHNlbGYuXCJ9O0YuX19pbWF0bXVsX189eyRuYW1lOlwiX19pbWF0bXVsX19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9tYXRyaXhfbXVsdGlwbHlcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZkA9dmFsdWUuXCJ9O0YuX19sb25nX189eyRuYW1lOlwiX19sb25nX19cIiwkc2xvdF9uYW1lOlwibmIkbG9uZ1wiLCRzbG90X2Z1bmM6bihcIl9fbG9uZ19fXCIsU2suYnVpbHRpbi5jaGVja0ludCxcImludFwiKSwkd3JhcHBlcjpiLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSxcbiRkb2M6XCJpbnQoc2VsZilcIn07dmFyIHoscj17bmV4dDp7JG5hbWU6XCJuZXh0XCIsJHNsb3RfbmFtZTpcInRwJGl0ZXJuZXh0XCIsJHNsb3RfZnVuYzpGLl9fbmV4dF9fLiRzbG90X2Z1bmMsJHdyYXBwZXI6Ri5fX25leHRfXy4kd3JhcHBlciwkdGV4dHNpZzpGLl9fbmV4dF9fLiR0ZXh0c2lnLCRmbGFnczpGLl9fbmV4dF9fLiRmbGFnc30sX19ub256ZXJvX186eyRuYW1lOlwiX19ub256ZXJvX19cIiwkc2xvdF9uYW1lOlwibmIkYm9vbFwiLCRzbG90X2Z1bmM6bihcIl9fbm9uemVyb19fXCIsU2suYnVpbHRpbi5jaGVja0ludCxcImludFwiLHQ9PjAhPT10LnYpLCR3cmFwcGVyOmEoYix0PT5uZXcgU2suYnVpbHRpbi5ib29sKHQpKSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcInguX19ub256ZXJvX18oKSA8PT0+IHggIT0gMFwifSxfX2Rpdl9fOnskbmFtZTpcIl9fZGl2X19cIiwkc2xvdF9uYW1lOlwibmIkZGl2aWRlXCIsJHNsb3RfZnVuYzptLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIG90aGVyLylcIixcbiRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwieC5fX2Rpdl9fKHkpIDw9PT4geC95XCJ9LF9fcmRpdl9fOnskbmFtZTpcIl9fcmRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9kaXZpZGVcIiwkc2xvdF9mdW5jOm0sJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgb3RoZXIvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwieC5fX3JkaXZfXyh5KSA8PT0+IHgveVwifSxfX2lkaXZfXzp7JG5hbWU6XCJfX2lkaXZfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX2RpdmlkZVwiLCRzbG90X2Z1bmM6bSwkd3JhcHBlcjplLCR0ZXh0c2lnOlwiKCRzZWxmLCBvdGhlci8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJpbXBsZW1lbnQgc2VsZiAvPSBvdGhlclwifX07U2suc3ViU2xvdHM9e21haW5fc2xvdHM6T2JqZWN0LmVudHJpZXMoe3RwJGluaXQ6XCJfX2luaXRfX1wiLHRwJGNhbGw6XCJfX2NhbGxfX1wiLCRyOlwiX19yZXByX19cIix0cCRzdHI6XCJfX3N0cl9fXCIsdHAkZ2V0YXR0cjpcIl9fZ2V0YXR0cmlidXRlX19cIixcbnRwJHNldGF0dHI6W1wiX19zZXRhdHRyX19cIixcIl9fZGVsYXR0cl9fXCJdLG9iJGVxOlwiX19lcV9fXCIsb2IkbmU6XCJfX25lX19cIixvYiRsdDpcIl9fbHRfX1wiLG9iJGxlOlwiX19sZV9fXCIsb2IkZ3Q6XCJfX2d0X19cIixvYiRnZTpcIl9fZ2VfX1wiLHRwJGRlc2NyX2dldDpcIl9fZ2V0X19cIix0cCRkZXNjcl9zZXQ6W1wiX19zZXRfX1wiLFwiX19kZWxldGVfX1wiXSx0cCRpdGVyOlwiX19pdGVyX19cIix0cCRpdGVybmV4dDpcIl9fbmV4dF9fXCJ9KSxudW1iZXJfc2xvdHM6T2JqZWN0LmVudHJpZXMoe25iJGFiczpcIl9fYWJzX19cIixuYiRuZWdhdGl2ZTpcIl9fbmVnX19cIixuYiRwb3NpdGl2ZTpcIl9fcG9zX19cIixuYiRpbnQ6XCJfX2ludF9fXCIsbmIkbG9uZzpcIl9fbG9uZ19fXCIsbmIkZmxvYXQ6XCJfX2Zsb2F0X19cIixuYiRpbmRleDpcIl9faW5kZXhfX1wiLG5iJGFkZDpcIl9fYWRkX19cIixuYiRyZWZsZWN0ZWRfYWRkOlwiX19yYWRkX19cIixuYiRpbnBsYWNlX2FkZDpcIl9faWFkZF9fXCIsbmIkc3VidHJhY3Q6XCJfX3N1Yl9fXCIsbmIkcmVmbGVjdGVkX3N1YnRyYWN0OlwiX19yc3ViX19cIixcbm5iJGlucGxhY2Vfc3VidHJhY3Q6XCJfX2lzdWJfX1wiLG5iJG11bHRpcGx5OlwiX19tdWxfX1wiLG5iJHJlZmxlY3RlZF9tdWx0aXBseTpcIl9fcm11bF9fXCIsbmIkaW5wbGFjZV9tdWx0aXBseTpcIl9faW11bF9fXCIsbmIkZmxvb3JfZGl2aWRlOlwiX19mbG9vcmRpdl9fXCIsbmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZTpcIl9fcmZsb29yZGl2X19cIixuYiRpbnBsYWNlX2Zsb29yX2RpdmlkZTpcIl9faWZsb29yZGl2X19cIixuYiRpbnZlcnQ6XCJfX2ludmVydF9fXCIsbmIkcmVtYWluZGVyOlwiX19tb2RfX1wiLG5iJHJlZmxlY3RlZF9yZW1haW5kZXI6XCJfX3Jtb2RfX1wiLG5iJGlucGxhY2VfcmVtYWluZGVyOlwiX19pbW9kX19cIixuYiRkaXZtb2Q6XCJfX2Rpdm1vZF9fXCIsbmIkcmVmbGVjdGVkX2Rpdm1vZDpcIl9fcmRpdm1vZF9fXCIsbmIkcG93ZXI6XCJfX3Bvd19fXCIsbmIkcmVmbGVjdGVkX3Bvd2VyOlwiX19ycG93X19cIixuYiRpbnBsYWNlX3Bvd2VyOlwiX19pcG93X19cIixuYiRkaXZpZGU6XCJfX3RydWVkaXZfX1wiLG5iJHJlZmxlY3RlZF9kaXZpZGU6XCJfX3J0cnVlZGl2X19cIixcbm5iJGlucGxhY2VfZGl2aWRlOlwiX19pdHJ1ZWRpdl9fXCIsbmIkYm9vbDpcIl9fYm9vbF9fXCIsbmIkYW5kOlwiX19hbmRfX1wiLG5iJHJlZmxlY3RlZF9hbmQ6XCJfX3JhbmRfX1wiLG5iJGlucGxhY2VfYW5kOlwiX19pYW5kX19cIixuYiRvcjpcIl9fb3JfX1wiLG5iJHJlZmxlY3RlZF9vcjpcIl9fcm9yX19cIixuYiRpbnBsYWNlX29yOlwiX19pb3JfX1wiLG5iJHhvcjpcIl9feG9yX19cIixuYiRyZWZsZWN0ZWRfeG9yOlwiX19yeG9yX19cIixuYiRpbnBsYWNlX3hvcjpcIl9faXhvcl9fXCIsbmIkbHNoaWZ0OlwiX19sc2hpZnRfX1wiLG5iJHJlZmxlY3RlZF9sc2hpZnQ6XCJfX3Jsc2hpZnRfX1wiLG5iJHJzaGlmdDpcIl9fcnNoaWZ0X19cIixuYiRyZWZsZWN0ZWRfcnNoaWZ0OlwiX19ycnNoaWZ0X19cIixuYiRpbnBsYWNlX2xzaGlmdDpcIl9faWxzaGlmdF9fXCIsbmIkaW5wbGFjZV9yc2hpZnQ6XCJfX2lyc2hpZnRfX1wiLG5iJG1hdHJpeF9tdWx0aXBseTpcIl9fbWF0bXVsX19cIixuYiRyZWZsZWN0ZWRfbWF0cml4X211bHRpcGx5OlwiX19ybWF0bXVsX19cIixcbm5iJGlucGxhY2VfbWF0cml4X211bHRpcGx5OlwiX19pbWF0bXVsX19cIn0pLHNlcXVlbmNlX2FuZF9tYXBwaW5nX3Nsb3RzOk9iamVjdC5lbnRyaWVzKHtzcSRsZW5ndGg6XCJfX2xlbl9fXCIsc3EkY29udGFpbnM6XCJfX2NvbnRhaW5zX19cIixtcCRzdWJzY3JpcHQ6XCJfX2dldGl0ZW1fX1wiLG1wJGFzc19zdWJzY3JpcHQ6W1wiX19zZXRpdGVtX19cIixcIl9fZGVsaXRlbV9fXCJdLG5iJGFkZDpcIl9fYWRkX19cIixuYiRtdWx0aXBseTpcIl9fbXVsX19cIixuYiRyZWZsZWN0ZWRfbXVsdGlwbHk6XCJfX3JtdWxfX1wiLG5iJGlucGxhY2VfYWRkOlwiX19pYWRkX19cIixuYiRpbnBsYWNlX211bHRpcGx5OlwiX19pbXVsX19cIn0pfTtTay5yZWZsZWN0ZWROdW1iZXJTbG90cz17bmIkYWRkOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfYWRkXCJ9LG5iJHN1YnRyYWN0OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIixzbG90OmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9cbnQubmIkc3VidHJhY3QodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRtdWx0aXBseTp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX211bHRpcGx5XCJ9LG5iJGRpdmlkZTp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX2RpdmlkZVwiLHNsb3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP3QubmIkZGl2aWRlKHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkZmxvb3JfZGl2aWRlOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlXCIsc2xvdDpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/dC5uYiRmbG9vcl9kaXZpZGUodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRyZW1haW5kZXI6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9yZW1haW5kZXJcIixzbG90OmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2ZcbnRoaXMuY29uc3RydWN0b3I/dC5uYiRyZW1haW5kZXIodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRkaXZtb2Q6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9kaXZtb2RcIixzbG90OmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj90Lm5iJGRpdm1vZCh0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19LG5iJHBvd2VyOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfcG93ZXJcIixzbG90OmZ1bmN0aW9uKHQseCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP3QubmIkcG93ZXIodGhpcyx4KTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19LG5iJGFuZDp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX2FuZFwifSxuYiRvcjp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX29yXCJ9LG5iJHhvcjp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX3hvclwifSxcbm5iJGxzaGlmdDp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX2xzaGlmdFwiLHNsb3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP3QubmIkbHNoaWZ0KHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkcnNoaWZ0OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfcnNoaWZ0XCIsc2xvdDpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/dC5uYiRyc2hpZnQodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRtYXRyaXhfbXVsdGlwbHk6e3JlZmxlY3RlZDpcIm5iJHJlZmxleHRlZF9tYXRyaXhfbXVsdGlwbHlcIixzbG90OmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj90Lm5iJG1hdHJpeF9tdWx0aXBseSh0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19fTtcblNrLnNlcXVlbmNlQW5kTWFwcGluZ1Nsb3RzPXtzcSRjb25jYXQ6W1wibmIkYWRkXCJdLHNxJHJlcGVhdDpbXCJuYiRtdWx0aXBseVwiLFwibmIkcmVmbGVjdGVkX211bHRpcGx5XCJdLG1wJGxlbmd0aDpbXCJzcSRsZW5ndGhcIl0sc3EkaW5wbGFjZV9yZXBlYXQ6W1wibmIkaW5wbGFjZV9tdWx0aXBseVwiXSxzcSRpbnBsYWNlX2NvbmNhdDpbXCJuYiRpbnBsYWNlX2FkZFwiXX07U2suZHVuZGVyVG9Ta3VscHQ9e19fcmVwcl9fOlwiJHJcIixfX3N0cl9fOlwidHAkc3RyXCIsX19pbml0X186XCJ0cCRpbml0XCIsX19uZXdfXzpcInRwJG5ld1wiLF9faGFzaF9fOlwidHAkaGFzaFwiLF9fY2FsbF9fOlwidHAkY2FsbFwiLF9faXRlcl9fOlwidHAkaXRlclwiLF9fbmV4dF9fOlwidHAkaXRlcm5leHRcIixfX2VxX186XCJvYiRlcVwiLF9fbmVfXzpcIm9iJG5lXCIsX19sdF9fOlwib2IkbHRcIixfX2xlX186XCJvYiRsZVwiLF9fZ3RfXzpcIm9iJGd0XCIsX19nZV9fOlwib2IkZ2VcIixfX2Fic19fOlwibmIkYWJzXCIsX19uZWdfXzpcIm5iJG5lZ2F0aXZlXCIsX19wb3NfXzpcIm5iJHBvc2l0aXZlXCIsXG5fX2ludF9fOlwibmIkaW50XCIsX19mbG9hdF9fOlwibmIkZmxvYXRcIixfX2luZGV4X186XCJuYiRpbmRleFwiLF9fYWRkX186XCJuYiRhZGRcIixfX3JhZGRfXzpcIm5iJHJlZmxlY3RlZF9hZGRcIixfX2lhZGRfXzpcIm5iJGlucGxhY2VfYWRkXCIsX19zdWJfXzpcIm5iJHN1YnRyYWN0XCIsX19yc3ViX186XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIixfX2lzdWJfXzpcIm5iJGlucGxhY2Vfc3VidHJhY3RcIixfX211bF9fOlwibmIkbXVsdGlwbHlcIixfX3JtdWxfXzpcIm5iJHJlZmxlY3RlZF9tdWx0aXBseVwiLF9faW11bF9fOlwibmIkaW5wbGFjZV9tdWx0aXBseVwiLF9fdHJ1ZWRpdl9fOlwibmIkZGl2aWRlXCIsX19ydHJ1ZWRpdl9fOlwibmIkcmVmbGVjdGVkX2RpdmlkZVwiLF9faXRydWVkaXZfXzpcIm5iJGlucGxhY2VfZGl2aWRlXCIsX19mbG9vcmRpdl9fOlwibmIkZmxvb3JfZGl2aWRlXCIsX19yZmxvb3JkaXZfXzpcIm5iJHJlZmxlY3RlZF9mbG9vcl9kaXZpZGVcIixfX2lmbG9vcmRpdl9fOlwibmIkaW5wbGFjZV9mbG9vcl9kaXZpZGVcIixcbl9faW52ZXJ0X186XCJuYiRpbnZlcnRcIixfX21vZF9fOlwibmIkcmVtYWluZGVyXCIsX19ybW9kX186XCJuYiRyZWZsZWN0ZWRfcmVtYWluZGVyXCIsX19pbW9kX186XCJuYiRpbnBsYWNlX3JlbWFpbmRlclwiLF9fZGl2bW9kX186XCJuYiRkaXZtb2RcIixfX3JkaXZtb2RfXzpcIm5iJHJlZmxlY3RlZF9kaXZtb2RcIixfX3Bvd19fOlwibmIkcG93ZXJcIixfX3Jwb3dfXzpcIm5iJHJlZmxlY3RlZF9wb3dlclwiLF9faXBvd19fOlwibmIkaW5wbGFjZV9wb3dlclwiLF9fYm9vbF9fOlwibmIkYm9vbFwiLF9fbG9uZ19fOlwibmIkbG9uZ1wiLF9fbHNoaWZ0X186XCJuYiRsc2hpZnRcIixfX3Jsc2hpZnRfXzpcIm5iJHJlZmxlY3RlZF9sc2hpZnRcIixfX2lsc2hpZnRfXzpcIm5iJGlucGxhY2VfbHNoaWZ0XCIsX19yc2hpZnRfXzpcIm5iJHJzaGlmdFwiLF9fcnJzaGlmdF9fOlwibmIkcmVmbGVjdGVkX3JzaGlmdFwiLF9faXJzaGlmdF9fOlwibmIkaW5wbGFjZV9yc2hpZnRcIixfX2FuZF9fOlwibmIkYW5kXCIsX19yYW5kX186XCJuYiRyZWZsZWN0ZWRfYW5kXCIsXG5fX2lhbmRfXzpcIm5iJGlucGxhY2VfYW5kXCIsX19vcl9fOlwibmIkb3JcIixfX3Jvcl9fOlwibmIkcmVmbGVjdGVkX29yXCIsX19pb3JfXzpcIm5iJGlucGxhY2Vfb3JcIixfX3hvcl9fOlwibmIkeG9yXCIsX19yeG9yX186XCJuYiRyZWZsZWN0ZWRfeG9yXCIsX19peG9yX186XCJuYiRpbnBsYWNlX3hvclwiLF9fbWF0bXVsX186XCJuYiRtYXRyaXhfbXVsdGlwbHlcIixfX3JtYXRtdWxfXzpcIm5iJHJlZmxlY3RlZF9tYXRyaXhfbXVsdGlwbHlcIixfX2ltYXRtdWxfXzpcIm5iJGlucGxhY2VfbWF0cml4X211bHRpcGx5XCIsX19nZXRfXzpcInRwJGRlc2NyX2dldFwiLF9fc2V0X186XCJ0cCRkZXNjcl9zZXRcIixfX2RlbGV0ZV9fOlwidHAkZGVzY3Jfc2V0XCIsX19nZXRhdHRyaWJ1dGVfXzpcInRwJGdldGF0dHJcIixfX2dldGF0dHJfXzpcInRwJGdldGF0dHJcIixfX3NldGF0dHJfXzpcInRwJHNldGF0dHJcIixfX2RlbGF0dHJfXzpcInRwJHNldGF0dHJcIixfX2xlbl9fOlwic3EkbGVuZ3RoXCIsX19jb250YWluc19fOlwic3EkY29udGFpbnNcIixcbl9fZ2V0aXRlbV9fOlwibXAkc3Vic2NyaXB0XCIsX19zZXRpdGVtX186XCJtcCRhc3Nfc3Vic2NyaXB0XCIsX19kZWxpdGVtX186XCJtcCRhc3Nfc3Vic2NyaXB0XCJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnNldHVwRHVuZGVyTWV0aG9kc1wiLFNrLnNldHVwRHVuZGVyTWV0aG9kcyk7U2suc2V0dXBEdW5kZXJNZXRob2RzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHgoQSxKLFEpe2ZvcihsZXQgWD0wO1g8QS5sZW5ndGg7WCsrKXtjb25zdCBhYT1BW1hdLnByb3RvdHlwZTthYS5oYXNPd25Qcm9wZXJ0eShRKXx8KGFhW1FdPWFhW0pdLGRlbGV0ZSBhYVtKXSl9fXZhciB2PVNrLnNsb3RzO2lmKCF0fHx2b2lkIDAhPT16KXt2YXIgQj1Tay5hYnN0ci5idWlsdCRpdGVyYXRvcnMsST1bU2suYnVpbHRpbi5pbnRfLFNrLmJ1aWx0aW4ubG5nLFNrLmJ1aWx0aW4uZmxvYXRfLFNrLmJ1aWx0aW4uY29tcGxleF0sTT1Tay5zdWJTbG90cy5udW1iZXJfc2xvdHMsUz1Tay5zdWJTbG90cy5tYWluX3Nsb3RzLEU9Uy5maW5kSW5kZXgoQT0+XG5cInRwJGl0ZXJuZXh0XCI9PT1BWzBdKSxIPU0uZmluZEluZGV4KEE9PlwibmIkYm9vbFwiPT09QVswXSkseT1Tay5kdW5kZXJUb1NrdWxwdDtpZih0KXt5Ll9fYm9vbF9fPVwibmIkYm9vbFwiO3kuX19uZXh0X189XCJ0cCRpdGVybmV4dFwiO2RlbGV0ZSB5Ll9fbm9uemVyb19fO2RlbGV0ZSB5Ll9fZGl2X187ZGVsZXRlIHkuX19yZGl2X187ZGVsZXRlIHkuX19pZGl2X187ZGVsZXRlIHkubmV4dDtmb3IobGV0IEEgaW4geil2W0FdPXpbQV07Zm9yKGxldCBBIGluIHIpZGVsZXRlIHZbQV07Zm9yKHQ9MDt0PEkubGVuZ3RoO3QrKyl2PUlbdF0ucHJvdG90eXBlLGRlbGV0ZSB2Ll9fZGl2X18sZGVsZXRlIHYuX19yZGl2X187U1tFXVsxXT1cIl9fbmV4dF9fXCI7TVtIXVsxXT1cIl9fYm9vbF9fXCI7eChCLFwibmV4dFwiLFwiX19uZXh0X19cIik7eChJLFwiX19ib29sX19cIixcIl9fbm9uemVyb19fXCIpfWVsc2V7dm9pZCAwPT09eiYmKHYucHkzJHNsb3RzPXtfX25leHRfXzp2Ll9fbmV4dF9ffSx6PXYucHkzJHNsb3RzKTtcbnkubmV4dD1cInRwJGl0ZXJuZXh0XCI7eS5fX25vbnplcm9fXz1cIm5iJGJvb2xcIjt5Ll9fZGl2X189XCJuYiRkaXZpZGVcIjt5Ll9fcmRpdl9fPVwibmIkcmVmbGVjdGVkX2RpdmlkZVwiO3kuX19pZGl2X189XCJuYiRpbnBsYWNlX2RpdmlkZVwiO2RlbGV0ZSB5Ll9fYm9vbF9fO2RlbGV0ZSB5Ll9fbmV4dF9fO2ZvcihsZXQgQSBpbiByKXZbQV09cltBXTtmb3IobGV0IEEgaW4geilkZWxldGUgdltBXTtTW0VdWzFdPVwibmV4dFwiO01bSF1bMV09XCJfX25vbnplcm9fX1wiO3goQixcIl9fbmV4dF9fXCIsXCJuZXh0XCIpO3goSSxcIl9fbm9uemVyb19fXCIsXCJfX2Jvb2xfX1wiKTtmb3IoQj0wO0I8SS5sZW5ndGg7QisrKU09SVtCXSxTPU0ucHJvdG90eXBlLFMuaGFzT3duUHJvcGVydHkoXCJfX2Rpdl9fXCIpfHwoUy5fX2Rpdl9fPW5ldyBTay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcihNLHIuX19kaXZfXyxTLm5iJGRpdmlkZSksUy5fX3JkaXZfXz1uZXcgU2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3IoTSxyLl9fcmRpdl9fLFxuU2sucmVmbGVjdGVkTnVtYmVyU2xvdHMubmIkZGl2aWRlLnNsb3QpKX19fX0sZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKHAsZyxhKXtyZXR1cm4gU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhwLHtjb25zdHJ1Y3RvcjphLmNvbnN0cnVjdG9yLHNsb3RzOk9iamVjdC5hc3NpZ24oe3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLCRyOmZ9LGEuc2xvdHMpLGdldHNldHM6T2JqZWN0LmFzc2lnbihhLmdldHNldHN8fHt9LGgpLHByb3RvOk9iamVjdC5hc3NpZ24oYS5wcm90b3x8e30se2QkcmVwcl9uYW1lOmd8fHAsZCRjaGVjazplLGQkc2V0X2NoZWNrOmR9KSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KX1mdW5jdGlvbiBlKHApe2lmKG51bGw9PXApcmV0dXJuIHRoaXM7aWYoIXAub2IkdHlwZS4kaXNTdWJUeXBlKHRoaXMuZCR0eXBlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZXNjcmlwdG9yICdcIit0aGlzLmQkbmFtZStcIicgcmVxdWlyZXMgYSAnXCIrXG50aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IGJ1dCByZWNlaXZlZCBhICdcIitTay5hYnN0ci50eXBlTmFtZShwKStcIicgb2JqZWN0XCIpO31mdW5jdGlvbiBkKHApe2lmKCFwLm9iJHR5cGUuJGlzU3ViVHlwZSh0aGlzLmQkdHlwZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIHJlcXVpcmVzIGEgJ1wiK3RoaXMuZCR0eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJyBvYmplY3QgYnV0IHJlY2VpdmVkIGEgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHApK1wiJyBvYmplY3RcIik7fWZ1bmN0aW9uIGYoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPFwiK3RoaXMuZCRyZXByX25hbWUrXCIgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdHM+XCIpfWNvbnN0IGg9e19fZG9jX186eyRnZXQoKXtyZXR1cm4gdGhpcy5kJGRlZi4kZG9jP25ldyBTay5idWlsdGluLnN0cih0aGlzLmQkZGVmLiRkb2MpOlxuU2suYnVpbHRpbi5ub25lLm5vbmUkfX0sX19vYmpjbGFzc19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuZCR0eXBlfX0sX19uYW1lX186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuZCRuYW1lKX19fTtGPXtfX3RleHRfc2lnbmF0dXJlX186eyRnZXQoKXtyZXR1cm4gdGhpcy5kJGRlZi4kdGV4dHNpZz9uZXcgU2suYnVpbHRpbi5zdHIodGhpcy5kJGRlZi4kdGV4dHNpZyk6U2suYnVpbHRpbi5ub25lLm5vbmUkfX19O1NrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3I9YihcImdldHNldF9kZXNjcmlwdG9yXCIsdm9pZCAwLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihwLGcpe3RoaXMuZCRkZWY9Zzt0aGlzLiRnZXQ9Zy4kZ2V0O3RoaXMuJHNldD1nLiRzZXQ7dGhpcy5kJHR5cGU9cDt0aGlzLmQkbmFtZT1nLiRuYW1lfSxzbG90czp7dHAkZGVzY3JfZ2V0KHAsZyxhKXtpZihnPXRoaXMuZCRjaGVjayhwKSlyZXR1cm4gZztpZih2b2lkIDAhPT10aGlzLiRnZXQpcmV0dXJuIHA9XG50aGlzLiRnZXQuY2FsbChwKSxhP3A6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHApO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiZ2V0c2V0X2Rlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdHMgaXMgbm90IHJlYWRhYmxlXCIpO30sdHAkZGVzY3Jfc2V0KHAsZyxhKXt0aGlzLmQkc2V0X2NoZWNrKHApO2lmKHZvaWQgMCE9PXRoaXMuJHNldClyZXR1cm4gcD10aGlzLiRzZXQuY2FsbChwLGcpLGE/cDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3cocCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCJhdHRyaWJ1dGUgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdHMgaXMgcmVhZG9ubHlcIik7fX19KTtTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yPVxuYihcIm1ldGhvZF9kZXNjcmlwdG9yXCIsXCJtZXRob2RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocCxnKXt0aGlzLmQkZGVmPWc7dGhpcy4kbWV0aD1nLiRtZXRoO3RoaXMuZCR0eXBlPXA7dGhpcy5kJG5hbWU9Zy4kbmFtZXx8XCI8bmF0aXZlIEpTPlwiO3RoaXMuJGZsYWdzPXA9Zy4kZmxhZ3N8fHt9O3AuRmFzdENhbGwmJnAuTm9Ld2FyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJG1ldGhvZEZhc3RDYWxsTm9Ld2FyZ3M6cC5GYXN0Q2FsbD90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kRmFzdENhbGw6cC5Ob0FyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJG1ldGhvZENhbGxOb0FyZ3M6cC5PbmVBcmc/dGhpcy50cCRjYWxsPXRoaXMuJG1ldGhvZENhbGxPbmVBcmc6cC5OYW1lZEFyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJG1ldGhvZENhbGxOYW1lZEFyZ3M6dm9pZCAwIT09cC5NaW5BcmdzP3RoaXMudHAkY2FsbD10aGlzLiRtZXRob2RDYWxsTWluQXJnczoodGhpcy5mdW5jX2NvZGU9Zy4kbWV0aCx0aGlzLnRwJGNhbGw9XG50aGlzLiRkZWZhdWx0Q2FsbCx0aGlzLiRtZW1vaXNlRmxhZ3M9U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS4kbWVtb2lzZUZsYWdzLHRoaXMuJHJlc29sdmVBcmdzPVNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUuJHJlc29sdmVBcmdzKX0sc2xvdHM6e3RwJGNhbGwocCxnKXtyZXR1cm4gdGhpcy50cCRjYWxsKHAsZyl9LHRwJGRlc2NyX2dldChwLGcpe2xldCBhO3JldHVybihhPXRoaXMuZCRjaGVjayhwKSk/YTpuZXcgU2suYnVpbHRpbi5za19tZXRob2QodGhpcy5kJGRlZixwKX19LGdldHNldHM6Rixwcm90bzp7JG1ldGhvZEZhc3RDYWxsKHAsZyl7Y29uc3QgYT1wLnNoaWZ0KCk7dGhpcy5tJGNoZWNrc2VsZihhKTtyZXR1cm4gdGhpcy4kbWV0aC5jYWxsKGEscCxnKX0sJG1ldGhvZEZhc3RDYWxsTm9Ld2FyZ3MocCxnKXtjb25zdCBhPXAuc2hpZnQoKTt0aGlzLm0kY2hlY2tzZWxmKGEpO1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy5kJG5hbWUsZyk7cmV0dXJuIHRoaXMuJG1ldGguY2FsbChhLFxucCl9LCRtZXRob2RDYWxsTm9BcmdzKHAsZyl7Y29uc3QgYT1wLnNoaWZ0KCk7dGhpcy5tJGNoZWNrc2VsZihhKTtTay5hYnN0ci5jaGVja05vQXJncyh0aGlzLmQkbmFtZSxwLGcpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYSl9LCRtZXRob2RDYWxsT25lQXJnKHAsZyl7Y29uc3QgYT1wLnNoaWZ0KCk7dGhpcy5tJGNoZWNrc2VsZihhKTtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLmQkbmFtZSxwLGcpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYSxwWzBdKX0sJG1ldGhvZENhbGxOYW1lZEFyZ3MocCxnKXtjb25zdCBhPXAuc2hpZnQoKTt0aGlzLm0kY2hlY2tzZWxmKGEpO3A9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3ModGhpcy5kJG5hbWUsdGhpcy4kZmxhZ3MuTmFtZWRBcmdzLHAsZyx0aGlzLiRmbGFncy5EZWZhdWx0cyk7cmV0dXJuIHRoaXMuJG1ldGguY2FsbChhLC4uLnApfSwkbWV0aG9kQ2FsbE1pbkFyZ3MocCxnKXtjb25zdCBhPXAuc2hpZnQoKTt0aGlzLm0kY2hlY2tzZWxmKGEpO1xuU2suYWJzdHIuY2hlY2tOb0t3YXJncyh0aGlzLmQkbmFtZSxnKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4odGhpcy5kJG5hbWUscCx0aGlzLiRmbGFncy5NaW5BcmdzLHRoaXMuJGZsYWdzLk1heEFyZ3MpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYSwuLi5wKX0sJGRlZmF1bHRDYWxsKHAsZyl7dGhpcy5tJGNoZWNrc2VsZihwWzBdKTtyZXR1cm4gU2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRjYWxsLmNhbGwodGhpcyxwLGcpfSxtJGNoZWNrc2VsZihwKXtpZih2b2lkIDA9PT1wKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdCBuZWVkcyBhbiBhcmd1bWVudFwiKTt0aGlzLmQkY2hlY2socCl9fX0pO1NrLmJ1aWx0aW4ud3JhcHBlcl9kZXNjcmlwdG9yPWIoXCJ3cmFwcGVyX2Rlc2NyaXB0b3JcIixcInNsb3Qgd3JhcHBlclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihwLFxuZyxhKXt0aGlzLmQkZGVmPWc7dGhpcy5kJHR5cGU9cDt0aGlzLmQkbmFtZT1hLiRuYW1lPWcuJG5hbWU7dGhpcy5kJHdyYXBwZWQ9YX0sc2xvdHM6e3RwJGRlc2NyX2dldChwLGcpe2xldCBhO3JldHVybihhPXRoaXMuZCRjaGVjayhwKSk/YTpuZXcgU2suYnVpbHRpbi5tZXRob2Rfd3JhcHBlcih0aGlzLHApfSx0cCRjYWxsKHAsZyl7aWYoMT5wLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZXNjcmlwdG9yICdcIit0aGlzLmQkbmFtZStcIicgb2YgJ1wiK3RoaXMuZCR0eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJyBvYmplY3QgbmVlZHMgYW4gYXJndW1lbnRcIik7Y29uc3QgYT1wLnNoaWZ0KCk7aWYoIWEub2IkdHlwZS4kaXNTdWJUeXBlKHRoaXMuZCR0eXBlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZXNjcmlwdG9yICdcIit0aGlzLmQkbmFtZStcIicgcmVxdWlyZXMgYSAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdCBidXQgcmVjZWl2ZWQgYSAnXCIrXG5Tay5hYnN0ci50eXBlTmFtZShhKStcIidcIik7cmV0dXJuIHRoaXMucmF3JGNhbGwoYSxwLGcpfX0scHJvdG86e3JhdyRjYWxsKHAsZyxhKXt0aGlzLmQkd3JhcHBlZC4kbmFtZT10aGlzLmQkbmFtZTtyZXR1cm4gdGhpcy5kJGRlZi4kd3JhcHBlci5jYWxsKHRoaXMuZCR3cmFwcGVkLHAsZyxhKX19fSk7U2suYnVpbHRpbi5tZXRob2Rfd3JhcHBlcj1iKFwibWV0aG9kX3dyYXBwZXJcIix2b2lkIDAse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHAsZyl7dGhpcy5tJGRlc2NyPXA7dGhpcy5tJHNlbGY9Zzt0aGlzLmQkZGVmPXAuZCRkZWY7dGhpcy5kJG5hbWU9cC5kJG5hbWU7dGhpcy5kJHR5cGU9cC5kJHR5cGV9LHNsb3RzOnt0cCRjYWxsKHAsZyl7cmV0dXJuIHRoaXMubSRkZXNjci5yYXckY2FsbCh0aGlzLm0kc2VsZixwLGcpfSx0cCRyaWNoY29tcGFyZShwLGcpe2lmKFwiRXFcIiE9PWcmJlwiTm90RXFcIiE9PWd8fCEocCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWV0aG9kX3dyYXBwZXIpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtcbnA9dGhpcy5tJHNlbGY9PT1wLm0kc2VsZiYmdGhpcy5tJGRlc2NyPT09cC5tJGRlc2NyO3JldHVyblwiRXFcIj09PWc/cDohcH0sJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPG1ldGhvZC13cmFwcGVyICdcIit0aGlzLmQkbmFtZStcIicgb2YgXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcy5tJHNlbGYpK1wiIG9iamVjdD5cIil9fSxnZXRzZXRzOntfX3NlbGZfXzp7JGdldCgpe3JldHVybiB0aGlzLm0kc2VsZn19fX0pO1NrLmJ1aWx0aW4uY2xhc3NtZXRob2RfZGVzY3JpcHRvcj1iKFwiY2xhc3NtZXRob2RfZGVzY3JpcHRvclwiLFwibWV0aG9kXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHAsZyl7dGhpcy5kJGRlZj1nO3RoaXMuJG1ldGg9Zy4kbWV0aDt0aGlzLmQkdHlwZT1wO3RoaXMuZCRuYW1lPWcuJG5hbWV8fFwiPG5hdGl2ZSBKUz5cIn0sc2xvdHM6e3RwJGNhbGwocCxnKXtpZigxPnAubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1xuXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IG5lZWRzIGFuIGFyZ3VtZW50XCIpO2NvbnN0IGE9cC5zaGlmdCgpO3JldHVybiB0aGlzLnRwJGRlc2NyX2dldChudWxsLGEpLnRwJGNhbGwocCxnKX0sdHAkZGVzY3JfZ2V0KHAsZyxhKXtpZih2b2lkIDA9PT1nKWlmKG51bGwhPT1wKWc9Z3x8cC5vYiR0eXBlO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIGZvciB0eXBlICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgbmVlZHMgYW4gb2JqZWN0IG9yIGEgdHlwZVwiKTtpZighZy5vYiR0eXBlLiRpc1N1YlR5cGUoU2suYnVpbHRpbi50eXBlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZXNjcmlwdG9yICdcIit0aGlzLmQkbmFtZStcIicgZm9yIHR5cGUgJ1wiK3RoaXMuZCR0eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJyBuZWVkcyBhIHR5cGUgbm90IGEgJ1wiK1xuU2suYWJzdHIudHlwZU5hbWUoZykrXCInIGFzIGFyZyAyXCIpO2lmKCFnLiRpc1N1YlR5cGUodGhpcy5kJHR5cGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyByZXF1aXJlcyBhICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IGJ1dCByZWNlaXZlZCBhICdcIitTay5hYnN0ci50eXBlTmFtZShnKStcIicgb2JqZWN0XCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5za19tZXRob2QodGhpcy5kJGRlZixnKX19LGdldHNldHM6Rn0pO1tTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yLFNrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3IsU2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3IsU2suYnVpbHRpbi5tZXRob2Rfd3JhcHBlcixTay5idWlsdGluLmNsYXNzbWV0aG9kX2Rlc2NyaXB0b3JdLmZvckVhY2gocD0+e1NrLmFic3RyLnNldFVwU2xvdHMocCk7U2suYWJzdHIuc2V0VXBNZXRob2RzKHApO1xuU2suYWJzdHIuc2V0VXBHZXRTZXRzKHApfSl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5za19tZXRob2Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImJ1aWx0aW5fZnVuY3Rpb25fb3JfbWV0aG9kXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZSxkKXt0aGlzLiRtZXRoPWIuJG1ldGguYmluZChlKTt0aGlzLiRkb2M9Yi4kZG9jO3RoaXMuJHNlbGY9ZXx8bnVsbDt0aGlzLiRtb2R1bGU9ZD9uZXcgU2suYnVpbHRpbi5zdHIoZCk6bnVsbDt0aGlzLiRuYW1lPWIuJG5hbWV8fGIuJG1ldGgubmFtZXx8XCI8bmF0aXZlIEpTPlwiO3RoaXMubSRkZWY9Yjt0aGlzLiR0ZXh0c2lnPWIuJHRleHRzaWc7dGhpcy4kZmxhZ3M9Yj1iLiRmbGFnc3x8e307Yi5GYXN0Q2FsbCYmYi5Ob0t3YXJncz90aGlzLnRwJGNhbGw9dGhpcy4kZmFzdENhbGxOb0t3YXJnczpiLkZhc3RDYWxsP3RoaXMudHAkY2FsbD10aGlzLiRtZXRoOmIuTm9BcmdzP3RoaXMudHAkY2FsbD10aGlzLiRjYWxsTm9BcmdzOmIuT25lQXJnP1xudGhpcy50cCRjYWxsPXRoaXMuJGNhbGxPbmVBcmc6Yi5OYW1lZEFyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJGNhbGxOYW1lZEFyZ3M6dm9pZCAwIT09Yi5NaW5BcmdzP3RoaXMudHAkY2FsbD10aGlzLiRjYWxsTWluQXJnczoodGhpcy5mdW5jX2NvZGU9dGhpcy4kbWV0aCx0aGlzLnRwJGNhbGw9dGhpcy4kZGVmYXVsdENhbGxNZXRob2QpfSxwcm90bzp7JGZhc3RDYWxsTm9Ld2FyZ3MoYixlKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsZSk7cmV0dXJuIHRoaXMuJG1ldGgoYil9LCRjYWxsTm9BcmdzKGIsZSl7U2suYWJzdHIuY2hlY2tOb0FyZ3ModGhpcy4kbmFtZSxiLGUpO3JldHVybiB0aGlzLiRtZXRoKCl9LCRjYWxsT25lQXJnKGIsZSl7U2suYWJzdHIuY2hlY2tPbmVBcmcodGhpcy4kbmFtZSxiLGUpO3JldHVybiB0aGlzLiRtZXRoKGJbMF0pfSwkY2FsbE5hbWVkQXJncyhiLGUpe2I9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3ModGhpcy4kbmFtZSx0aGlzLiRmbGFncy5OYW1lZEFyZ3MsXG5iLGUsdGhpcy4kZmxhZ3MuRGVmYXVsdHMpO3JldHVybiB0aGlzLiRtZXRoKC4uLmIpfSwkY2FsbE1pbkFyZ3MoYixlKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsZSk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMuJG5hbWUsYix0aGlzLiRmbGFncy5NaW5BcmdzLHRoaXMuJGZsYWdzLk1heEFyZ3MpO3JldHVybiB0aGlzLiRtZXRoKC4uLmIpfSwkZGVmYXVsdENhbGxNZXRob2QoYixlKXtyZXR1cm4gbnVsbCE9PXRoaXMuJHNlbGY/U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRjYWxsLmNhbGwodGhpcyxbdGhpcy4kc2VsZiwuLi5iXSxlKTpTay5idWlsdGluLmZ1bmMucHJvdG90eXBlLnRwJGNhbGwuY2FsbCh0aGlzLGIsZSl9LCRtZW1vaXNlRmxhZ3MoKXtyZXR1cm4gU2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS4kbWVtb2lzZUZsYWdzLmNhbGwodGhpcyl9LCRyZXNvbHZlQXJncygpe3JldHVybiBTay5idWlsdGluLmZ1bmMucHJvdG90eXBlLiRyZXNvbHZlQXJncy5jYWxsKHRoaXMpfX0sXG5mbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLCRyKCl7cmV0dXJuIG51bGw9PT10aGlzLiRzZWxmP25ldyBTay5idWlsdGluLnN0cihcIjxidWlsdC1pbiBmdW5jdGlvbiBcIit0aGlzLiRuYW1lK1wiPlwiKTpuZXcgU2suYnVpbHRpbi5zdHIoXCI8YnVpbHQtaW4gbWV0aG9kIFwiK3RoaXMuJG5hbWUrXCIgb2YgXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcy4kc2VsZikrXCIgb2JqZWN0PlwiKX0sdHAkY2FsbChiLGUpe3JldHVybiB0aGlzLnRwJGNhbGwoYixlKX0sdHAkcmljaGNvbXBhcmUoYixlKXtpZihcIkVxXCIhPT1lJiZcIk5vdEVxXCIhPT1lfHwhKGIgaW5zdGFuY2VvZiBTay5idWlsdGluLnNrX21ldGhvZCkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2I9dGhpcy4kc2VsZj09PWIuJHNlbGYmJnRoaXMubSRkZWYuJG1ldGg9PT1iLm0kZGVmLiRtZXRoO3JldHVyblwiRXFcIj09PWU/YjohYn19LFxuZ2V0c2V0czp7X19tb2R1bGVfXzp7JGdldCgpe3JldHVybiB0aGlzLiRtb2R1bGV8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJHNldChiKXt0aGlzLiRtb2R1bGU9Yj1ifHxTay5idWlsdGluLm5vbmUubm9uZSR9fSxfX2RvY19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuJGRvYz9uZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kZG9jKTpTay5idWlsdGluLm5vbmUubm9uZSR9fSxfX25hbWVfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kbmFtZSl9fSxfX3RleHRfc2lnbmF0dXJlX186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJHRleHRzaWcpfX0sX19zZWxmX186eyRnZXQoKXtyZXR1cm4gdGhpcy4kc2VsZnx8U2suc3lzTW9kdWxlcy5tcCRsb29rdXAodGhpcy4kbW9kdWxlKXx8U2suYnVpbHRpbi5ub25lLm5vbmUkfX19fSl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5ub25lPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJOb25lVHlwZVwiLFxue2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sc2xvdHM6e3RwJG5ldyhiLGUpe1NrLmFic3RyLmNoZWNrTm9BcmdzKFwiTm9uZVR5cGVcIixiLGUpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIk5vbmVcIil9LHRwJGFzX251bWJlcjohMCxuYiRib29sKCl7cmV0dXJuITF9fSxwcm90bzp7dmFsdWVPZigpe3JldHVybiBudWxsfX0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSk7U2suYnVpbHRpbi5ub25lLm5vbmUkPU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5ub25lLnByb3RvdHlwZSx7djp7dmFsdWU6bnVsbCxlbnVtZXJhYmxlOiEwfX0pO1NrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQ9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIk5vdEltcGxlbWVudGVkVHlwZVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH0sXG5zbG90czp7JHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiTm90SW1wbGVtZW50ZWRcIil9LHRwJG5ldyhiLGUpe1NrLmFic3RyLmNoZWNrTm9BcmdzKFwiTm90SW1wbGVtZW50ZWRUeXBlXCIsYixlKTtyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KTtTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJD1PYmplY3QuY3JlYXRlKFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQucHJvdG90eXBlLHt2Ont2YWx1ZTpudWxsLGVudW1lcmFibGU6ITB9fSk7Rj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiZWxsaXBzaXNcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5FbGxpcHNpc30sc2xvdHM6e3RwJG5ldyhiLGUpe1NrLmFic3RyLmNoZWNrTm9BcmdzKFwiZWxsaXBzaXNcIixiLGUpO3JldHVybiBTay5idWlsdGluLkVsbGlwc2lzfSwkcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJFbGxpcHNpc1wiKX19LFxuZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSk7U2suYnVpbHRpbi5FbGxpcHNpcz1PYmplY3QuY3JlYXRlKEYucHJvdG90eXBlLHt2Ont2YWx1ZTpcIi4uLlwifX0pfSxmdW5jdGlvbihGLFApe2NvbnN0IGI9L14oPzooLik/KFs8Pj1cXF5dKSk/KFtcXCtcXC1cXHNdKT8oIyk/KDApPyhcXGQrKT8oLHxfKT8oPzpcXC4oXFxkKykpPyhbYmNkZUVmRmdHbm9zeFglXSk/JC87U2suZm9ybWF0dGluZz17fTtsZXQgZT1mdW5jdGlvbihhLGMsbixtKXtTay5hc3NlcnRzLmFzc2VydChcInN0cmluZ1wiPT09dHlwZW9mIGMpO2lmKGFbNl0pe3ZhciBrPXBhcnNlSW50KGFbNl0sMTApO209YVsyXXx8KGFbNV0/XCI9XCI6bT9cIj5cIjpcIjxcIik7bGV0IHU9ay0oYy5sZW5ndGgrKG4/bi5sZW5ndGg6MCkpO2lmKDA+PXUpcmV0dXJuIG4rYztrPShhWzFdfHwoYVs1XT9cIjBcIjpcIiBcIikpLnJlcGVhdCh1KTtzd2l0Y2gobSl7Y2FzZSBcIj1cIjppZihcInNcIj09PWFbOV0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIic9JyBhbGlnbm1lbnQgbm90IGFsbG93ZWQgaW4gc3RyaW5nIGZvcm1hdCBzcGVjaWZpZXJcIik7XG5yZXR1cm4gbitrK2M7Y2FzZSBcIj5cIjpyZXR1cm4gaytuK2M7Y2FzZSBcIjxcIjpyZXR1cm4gbitjK2s7Y2FzZSBcIl5cIjpyZXR1cm4gYT1NYXRoLmZsb29yKHUvMiksay5zdWJzdHJpbmcoMCxhKStuK2Mray5zdWJzdHJpbmcoYSl9fXJldHVybiBuK2N9LGQ9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYz9cIi1cIjpcIitcIj09PWFbM10/XCIrXCI6XCIgXCI9PT1hWzNdP1wiIFwiOlwiXCJ9O2NvbnN0IGY9L1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csaD0vXFxCKD89KFtBLVphLXowLTldezR9KSsoPyFbQS1aYS16MC05XSkpL2c7bGV0IHA9ZnVuY3Rpb24oYSxjLG4pe1NrLmFzc2VydHMuYXNzZXJ0KGMgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF98fGMgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZyk7aWYoYVs4XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiUHJlY2lzaW9uIG5vdCBhbGxvd2VkIGluIGludGVnZXIgZm9ybWF0XCIpO3ZhciBtPWMuc3RyJChuLCExKTtjPWMubmIkaXNuZWdhdGl2ZSgpO2M9XG5kKGEsYyk7YVs0XSYmKDE2PT09bj9jKz1cIjB4XCI6OD09PW4/Yys9XCIwb1wiOjI9PT1uJiYoYys9XCIwYlwiKSk7Y29uc3Qgaz1hWzldO1wiWFwiPT09ayYmKG09bS50b1VwcGVyQ2FzZSgpKTtpZihcIm5cIj09PWFbOV0pbT0oK20pLnRvTG9jYWxlU3RyaW5nKCk7ZWxzZSBpZihhWzddKXttPW0uc3BsaXQoXCIuXCIpO2NvbnN0IHU9YVs3XTtpZihcIixcIj09PXUmJjEwIT09bil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKGBDYW5ub3Qgc3BlY2lmeSAnLCcgd2l0aCAnJHtrfSdgKTttWzBdPW1bMF0ucmVwbGFjZSgxMD09PW4/ZjpoLHUpO209bS5qb2luKFwiLlwiKX1yZXR1cm4gZShhLG0sYywhMCl9LGc9ZnVuY3Rpb24oYSxjLG4pe2lmKCFjKXJldHVybiBhLnN0ciQoMTAsITApO2M9Yy5tYXRjaChiKTtpZighYyl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiSW52YWxpZCBmb3JtYXQgc3BlY2lmaWVyXCIpO3ZhciBtPWNbOV07bXx8KG09bj9cImdcIjpcImRcIik7aWYoLTE9PShuP1wiZkZlRWdHJVwiOlxuXCJiY2RveFhuZkZlRWdHJVwiKS5pbmRleE9mKG0pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJVbmtub3duIGZvcm1hdCBjb2RlICdcIitjWzldK1wiJyBmb3Igb2JqZWN0IG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTtzd2l0Y2gobSl7Y2FzZSBcImRcIjpjYXNlIFwiblwiOnJldHVybiBwKGMsYSwxMCk7Y2FzZSBcInhcIjpjYXNlIFwiWFwiOnJldHVybiBwKGMsYSwxNik7Y2FzZSBcIm9cIjpyZXR1cm4gcChjLGEsOCk7Y2FzZSBcImJcIjpyZXR1cm4gcChjLGEsMik7Y2FzZSBcImNcIjppZihjWzNdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJTaWduIG5vdCBhbGxvd2VkIHdpdGggaW50ZWdlciBmb3JtYXQgc3BlY2lmaWVyICdjJ1wiKTtpZihjWzRdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBbHRlcm5hdGUgZm9ybSBub3QgYWxsb3dlZCB3aXRoIGludGVnZXIgZm9ybWF0IHNwZWNpZmllciAnYydcIik7aWYoY1s3XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgJywnIHdpdGggJ2MnXCIpO1xuaWYoY1s4XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgJywnIHdpdGggJ2MnXCIpO3JldHVybiBlKGMsU3RyaW5nLmZyb21Db2RlUG9pbnQoU2suYnVpbHRpbi5hc251bSQoYSkpLFwiXCIsITApO2Nhc2UgXCJmXCI6Y2FzZSBcIkZcIjpjYXNlIFwiZVwiOmNhc2UgXCJFXCI6Y2FzZSBcImdcIjpjYXNlIFwiR1wiOntpZihjWzRdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBbHRlcm5hdGUgZm9ybSAoIykgbm90IGFsbG93ZWQgaW4gZmxvYXQgZm9ybWF0IHNwZWNpZmllclwiKTtuPVNrLmJ1aWx0aW4uYXNudW0kKGEpO1wic3RyaW5nXCI9PT10eXBlb2YgbiYmKG49TnVtYmVyKG4pKTtpZihJbmZpbml0eT09PW4pcmV0dXJuIGUoYyxcImluZlwiLFwiXCIsITApO2lmKC1JbmZpbml0eT09PW4pcmV0dXJuIGUoYyxcImluZlwiLFwiLVwiLCEwKTtpZihpc05hTihuKSlyZXR1cm4gZShjLFwibmFuXCIsXCJcIiwhMCk7YT0hMTswPm4mJihuPS1uLGE9ITApO3ZhciBrPVtcInRvRXhwb25lbnRpYWxcIixcblwidG9GaXhlZFwiLFwidG9QcmVjaXNpb25cIl1bXCJlZmdcIi5pbmRleE9mKG0udG9Mb3dlckNhc2UoKSldO2xldCB1PWNbOF0/cGFyc2VJbnQoY1s4XSwxMCk6NjtuPW5ba10odSk7LTEhPT1cIkVGR1wiLmluZGV4T2YobSkmJihuPW4udG9VcHBlckNhc2UoKSk7aWYoXCJnXCI9PT1tLnRvTG93ZXJDYXNlKCl8fCFjWzldKXtpZihrPW4ubWF0Y2goL1xcLihcXGQqWzEtOV0pPygwKykkLykpe2xldCBbLGwscV09aztuPW4uc2xpY2UoMCxsPy1xLmxlbmd0aDotKHEubGVuZ3RoKzEpKX0tMSE9bi5pbmRleE9mKFwiLlwiKXx8Y1s5XXx8KG4rPVwiLjBcIil9XCJlXCI9PT1tLnRvTG93ZXJDYXNlKCkmJihuPW4ucmVwbGFjZSgvXihbLStdP1swLTldKlxcLj9bMC05XStbZUVdWy0rXT8pKFswLTldKT8kLyxcIiQxMCQyXCIpKTtjWzddJiYobT1uLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLG1bMF09bVswXS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFwiLFwiKSxuPW0uam9pbihcIi5cIikpO3JldHVybiBlKGMsbixkKGMsYSksXG4hMCl9Y2FzZSBcIiVcIjppZihjWzRdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBbHRlcm5hdGUgZm9ybSAoIykgbm90IGFsbG93ZWQgd2l0aCBmb3JtYXQgc3BlY2lmaWVyICclJ1wiKTthPVNrLmJ1aWx0aW4uYXNudW0kKGEpO1wic3RyaW5nXCI9PT10eXBlb2YgYSYmKGE9TnVtYmVyKGEpKTtpZihJbmZpbml0eT09PWEpcmV0dXJuIGUoYyxcImluZiVcIixcIlwiLCEwKTtpZigtSW5maW5pdHk9PT1hKXJldHVybiBlKGMsXCJpbmYlXCIsXCItXCIsITApO2lmKGlzTmFOKGEpKXJldHVybiBlKGMsXCJuYW4lXCIsXCJcIiwhMCk7bT0hMTswPmEmJihhPS1hLG09ITApO249Y1s4XT9wYXJzZUludChjWzhdLDEwKTo2O2E9KDEwMCphKS50b0ZpeGVkKG4pK1wiJVwiO3JldHVybiBlKGMsYSxkKGMsbSksITApO2RlZmF1bHQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIlVua25vd24gZm9ybWF0IGNvZGUgJ1wiK2NbOV0rXCInXCIpO319O1NrLmZvcm1hdHRpbmcubWtOdW1iZXJfX2Zvcm1hdF9fPWE9PlxuZnVuY3Rpb24oYyl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZm9ybWF0KCkgYXJndW1lbnQgMiBtdXN0IGJlIHN0ciwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGMpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGcodGhpcyxjLiRqc3N0cigpLGEpKX07U2suZm9ybWF0dGluZy5mb3JtYXQ9ZnVuY3Rpb24oYSxjKXtjPWN8fFtdO2NvbnN0IG49e307Zm9yKGxldCBrPTA7azxjLmxlbmd0aDtrKz0yKW5bY1trXV09Y1trKzFdO2ZvcihsZXQgayBpbiBhKW5ba109YVtrXTtsZXQgbT0wO2E9dGhpcy52LnJlcGxhY2UoL3soKCg/OlxcZCspfCg/OlxcdyspKT8oKD86XFwuKFxcdyspKXwoPzpcXFsoKD86XFxkKyl8KD86XFx3KykpXFxdKT8pKT8oPzohKFtyc10pKT8oPzo6KFtefV0qKSk/fS9nLGZ1bmN0aW9uKGssdSxsLHEseixyLHQseCx2LEIpe2xldCBJO2lmKHZvaWQgMCE9PXImJlwiXCIhPT1yKWs9bltsXSxJPWsuY29uc3RydWN0b3I9PT1cbkFycmF5P2tbcl06L15cXGQrJC8udGVzdChyKT9Tay5hYnN0ci5vYmplY3RHZXRJdGVtKGssbmV3IFNrLmJ1aWx0aW4uaW50XyhwYXJzZUludChyLDEwKSksITEpOlNrLmFic3RyLm9iamVjdEdldEl0ZW0oayxuZXcgU2suYnVpbHRpbi5zdHIociksITEpLG0rKztlbHNlIGlmKHZvaWQgMCE9PXomJlwiXCIhPT16KUk9U2suYWJzdHIuZ2F0dHIobltsfHxtKytdLG5ldyBTay5idWlsdGluLnN0cih6KSk7ZWxzZSBpZih2b2lkIDAhPT1sJiZcIlwiIT09bClJPW5bbF07ZWxzZSBpZih2b2lkIDA9PT11fHxcIlwiPT09dSlJPW5bbV0sbSsrO2Vsc2UgaWYodSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8dSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRffHx1IGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmd8fC9eXFxkKyQvLnRlc3QodSkpST1uW3VdLG0rKztpZihcInNcIj09PXQpST1uZXcgU2suYnVpbHRpbi5zdHIoSSk7ZWxzZSBpZihcInJcIj09PXQpST1Tay5idWlsdGluLnJlcHIoSSk7ZWxzZSBpZihcIlwiIT09XG50JiZ2b2lkIDAhPT10KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJVbmtub3duIGNvbnZlcnNpb24gc3BlY2lmaWVyIFwiK3QpO3JldHVybiBTay5hYnN0ci5vYmplY3RGb3JtYXQoSSxuZXcgU2suYnVpbHRpbi5zdHIoeCkpLiRqc3N0cigpfSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihhKX07U2suZm9ybWF0dGluZy5mb3JtYXRTdHJpbmc9ZnVuY3Rpb24oYSl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZm9ybWF0KCkgYXJndW1lbnQgMiBtdXN0IGJlIHN0ciwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGEpKTthPWEuJGpzc3RyKCkubWF0Y2goYik7aWYoYVs5XSYmXCJzXCIhPT1hWzldKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJVbmtub3duIGZvcm1hdCBjb2RlICdcIithWzldK1wiJyBmb3Igb2JqZWN0IG9mIHR5cGUgJ3N0cidcIik7aWYoYVszXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiU2lnbiBub3QgYWxsb3dlZCBpbiBzdHJpbmcgZm9ybWF0IHNwZWNpZmllclwiKTtcbmlmKGFbNF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkFsdGVybmF0ZSBmb3JtICgjKSBub3QgYWxsb3dlZCB3aXRoIHN0cmluZyBmb3JtYXQgc3BlY2lmaWVyXCIpO2lmKGFbN10pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkNhbm5vdCBzcGVjaWZ5ICcsJyB3aXRoICdzJ1wiKTtsZXQgYz10aGlzLnY7YVs4XSYmKGM9Yy5zdWJzdHJpbmcoMCxhWzhdKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihlKGEsYyxcIlwiLCExKSl9fSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIocil7bGV0IHQ7Y29uc3QgeD1bXTtmb3IobGV0IHY9MDt2PHIubGVuZ3RoO3YrKyl0PXIuY2hhckF0KHYpLGsudGVzdCh0KT94LnB1c2godCk6XCJcXFxcMDAwXCI9PT10P3gucHVzaChcIlxcXFwwMDBcIik6eC5wdXNoKFwiXFxcXFwiK3QpO3JldHVybiB4LmpvaW4oXCJcIil9ZnVuY3Rpb24gZShyLHQseCl7dD1Tay5idWlsdGluLmNoZWNrTm9uZSh0KT9udWxsOnIuZ2V0JHRndCh0KTtpZihudWxsIT09dCYmXG4hdC5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImVtcHR5IHNlcGFyYXRvclwiKTtyPXIudjt2YXIgdj0wO2lmKG51bGw9PT10KXt2YXIgQj0vW1xcc1xceGEwXSsvZzt2PXIubGVuZ3RoO3I9ci5yZXBsYWNlKGwsXCJcIik7di09ci5sZW5ndGh9ZWxzZSBCPXQucmVwbGFjZSh1LFwiXFxcXCQxXCIpLEI9bmV3IFJlZ0V4cChCLFwiZ1wiKTtjb25zdCBJPVtdO2xldCBNPTAsUz0wLEU7Zm9yKHg9MD54P0luZmluaXR5Ong7bnVsbCE9KEU9Qi5leGVjKHIpKSYmUzx4JiZFLmluZGV4IT09Qi5sYXN0SW5kZXg7KUkucHVzaChNK3YpLEkucHVzaChFLmluZGV4K3YpLE09Qi5sYXN0SW5kZXgsUys9MTtpZihudWxsIT09dHx8ci5sZW5ndGgtTSlJLnB1c2goTSt2KSxJLnB1c2goci5sZW5ndGgrdik7cmV0dXJuIEl9ZnVuY3Rpb24gZChyLHQpe3JldHVybiBmdW5jdGlvbih4KXtpZih2b2lkIDA9PT14fHxTay5idWlsdGluLmNoZWNrTm9uZSh4KSl4PXI7ZWxzZSBpZih4IGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uc3RyKXg9Yih4LnYpLHg9bmV3IFJlZ0V4cCh0KHgpLFwiZ1wiKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN0cmlwIGFyZyBtdXN0IGJlIE5vbmUgb3Igc3RyXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnJlcGxhY2UoeCxcIlwiKSl9fWZ1bmN0aW9uIGYocil7cmV0dXJuIGZ1bmN0aW9uKHQpe3Q9dGhpcy5nZXQkdGd0KHQpO2NvbnN0IHg9dGhpcy52O2xldCB2O2lmKHIpe2lmKHY9eC5sYXN0SW5kZXhPZih0KSwwPnYpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5zdHIoXCJcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpLG5ldyBTay5idWlsdGluLnN0cih4KV0pfWVsc2UgaWYodj14LmluZGV4T2YodCksMD52KXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKHgpLG5ldyBTay5idWlsdGluLnN0cihcIlwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXCJcIildKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLnN0cih4LnN1YnN0cmluZygwLFxudikpLG5ldyBTay5idWlsdGluLnN0cih0KSxuZXcgU2suYnVpbHRpbi5zdHIoeC5zdWJzdHJpbmcodit0Lmxlbmd0aCkpXSl9fWZ1bmN0aW9uIGgocix0KXtyZXR1cm4gZnVuY3Rpb24oeCx2KXt4PVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh4LFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYodm9pZCAwPT09dil2PVwiIFwiO2Vsc2UgaWYodiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyJiYxPT09di5zcSRsZW5ndGgoKSl2PXYudjtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInRoZSBmaWxsIGNoYXJhY3RlciBtdXN0IGJlIGEgc3RyIG9mIGxlbmd0aCAxXCIpO3ZhciBCPXRoaXMuc3EkbGVuZ3RoKCk7aWYoQj49eClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudik7aWYodClyZXR1cm4gQj14LUIseD1NYXRoLmZsb29yKEIvMikrKEImeCYxKSx2PXYucmVwZWF0KHgpK3RoaXMudit2LnJlcGVhdChCLXgpLG5ldyBTay5idWlsdGluLnN0cih2KTt2PXYucmVwZWF0KHgtXG5CKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHI/dit0aGlzLnY6dGhpcy52K3YpfX1mdW5jdGlvbiBwKHIsdCx4KXsoe3N0YXJ0OnQsZW5kOnh9PVNrLmJ1aWx0aW4uc2xpY2Uuc3RhcnRFbmQkd3J0KHIsdCx4KSk7aWYoci4kaGFzQXN0cmFsQ29kZVBvaW50cygpKXtjb25zdCB2PXIuY29kZXBvaW50c1t0XTt0PXZvaWQgMD09PXY/dCtyLnYubGVuZ3RoLXIuY29kZXBvaW50cy5sZW5ndGg6djt4PXIuY29kZXBvaW50c1t4XTt4PXZvaWQgMD09PXg/ci52Lmxlbmd0aDp4fXJldHVybntzdGFydDp0LGVuZDp4fX1mdW5jdGlvbiBnKHIpe3JldHVybiBmdW5jdGlvbih0LHgsdil7dD10aGlzLmdldCR0Z3QodCk7KHtzdGFydDp4LGVuZDp2fT1wKHRoaXMseCx2KSk7aWYodjx4KXJldHVybi0xO3YtPXQubGVuZ3RoO3Q9cj90aGlzLnYubGFzdEluZGV4T2YodCx2KTp0aGlzLnYuaW5kZXhPZih0LHgpO3Q9dD49eCYmdDw9dj90Oi0xO2lmKHRoaXMuY29kZXBvaW50cyl7dj10aGlzLnNxJGxlbmd0aCgpO1xueD0tMTtmb3IobGV0IEI9MDtCPHY7QisrKXQ9PXRoaXMuY29kZXBvaW50c1tCXSYmKHg9Qil9ZWxzZSB4PXQ7cmV0dXJuIHh9fWZ1bmN0aW9uIGEocix0KXtyZXR1cm4gZnVuY3Rpb24oeCx2LEIpe2lmKCEoeCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyfHx4IGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHIrXCIgZmlyc3QgYXJnIG11c3QgYmUgc3RyIG9yIGEgdHVwbGUgb2Ygc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoeCkpOyh7c3RhcnQ6dixlbmQ6Qn09cCh0aGlzLHYsQikpO2lmKHY+QilyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDt2PXRoaXMudi5zbGljZSh2LEIpO2lmKHggaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKXtmb3IobGV0IEk9U2suYWJzdHIuaXRlcih4KSxNPUkudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1NO009SS50cCRpdGVybmV4dCgpKXtpZighKE0gaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHVwbGUgZm9yIFwiK1xucitcIiBtdXN0IG9ubHkgY29udGFpbiBzdHIsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShNKSk7aWYodCh2LE0udikpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJH1yZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJH1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0KHYseC52KSl9fWZ1bmN0aW9uIGMocil7cmV0dXJuIHZvaWQgMD09PXpbcl0/cjpyK1wiXyRydyRcIn12YXIgbj0vXlswLTkhI19dLyxtPU9iamVjdC5jcmVhdGUobnVsbCk7U2suYnVpbHRpbi5zdHI9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInN0clwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihyKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIsXCJiYWQgY2FsbCB0byBzdHIgLSB1c2UgJ25ldydcIik7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiByKWlmKHZvaWQgMD09PXIpcj1cIlwiO2Vsc2UgaWYobnVsbD09PXIpcj1cIk5vbmVcIjtlbHNle2lmKHZvaWQgMCE9PXIudHAkc3RyKXJldHVybiByLnRwJHN0cigpO1xuaWYoXCJudW1iZXJcIj09PXR5cGVvZiByKXI9TnVtYmVyLmlzRmluaXRlKHIpP1N0cmluZyhyKTpTdHJpbmcocikucmVwbGFjZShcIkluZmluaXR5XCIsXCJpbmZcIikucmVwbGFjZShcIk5hTlwiLFwibmFuXCIpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY291bGQgbm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHIpK1wiJyB0byBzdHJcIik7fWNvbnN0IHQ9bVtyXTtpZih2b2lkIDAhPT10KXJldHVybiB0O21bcl09dGhpczt0aGlzLiRtYW5nbGVkPWMocik7dGhpcy4kc2F2ZWRLZXlIYXNoPXIucmVwbGFjZShuLFwiISQmXCIpO3RoaXMudj1yfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRkb2M6XCJzdHIob2JqZWN0PScnKSAtPiBzdHJcXG5zdHIoYnl0ZXNfb3JfYnVmZmVyWywgZW5jb2RpbmdbLCBlcnJvcnNdXSkgLT4gc3RyXFxuXFxuQ3JlYXRlIGEgbmV3IHN0cmluZyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LiBJZiBlbmNvZGluZyBvclxcbmVycm9ycyBpcyBzcGVjaWZpZWQsIHRoZW4gdGhlIG9iamVjdCBtdXN0IGV4cG9zZSBhIGRhdGEgYnVmZmVyXFxudGhhdCB3aWxsIGJlIGRlY29kZWQgdXNpbmcgdGhlIGdpdmVuIGVuY29kaW5nIGFuZCBlcnJvciBoYW5kbGVyLlxcbk90aGVyd2lzZSwgcmV0dXJucyB0aGUgcmVzdWx0IG9mIG9iamVjdC5fX3N0cl9fKCkgKGlmIGRlZmluZWQpXFxub3IgcmVwcihvYmplY3QpLlxcbmVuY29kaW5nIGRlZmF1bHRzIHRvIHN5cy5nZXRkZWZhdWx0ZW5jb2RpbmcoKS5cXG5lcnJvcnMgZGVmYXVsdHMgdG8gJ3N0cmljdCcuXCIsXG50cCRuZXcocix0KXt0PXR8fFtdO2lmKHRoaXMhPT1Tay5idWlsdGluLnN0ci5wcm90b3R5cGUpcmV0dXJuIHRoaXMuJHN1YnR5cGVfbmV3KHIsdCk7aWYoMT49ci5sZW5ndGgmJiF0Lmxlbmd0aClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHJbMF0pO2lmKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl7Y29uc3QgW3gsdixCXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcInN0clwiLFtcIm9iamVjdFwiLFwiZW5jb2RpbmdcIixcImVycm9yc1wiXSxyLHQpO2lmKHZvaWQgMD09PXh8fHZvaWQgMD09PXYmJnZvaWQgMD09PUIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih4KTtTay5idWlsdGluLmJ5dGVzLmNoZWNrJGVuY29kZUFyZ3MoXCJzdHJcIix2LEIpO2lmKCFTay5idWlsdGluLmNoZWNrQnl0ZXMoeCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVjb2RpbmcgdG8gc3RyOiBuZWVkIGEgYnl0ZXMtbGlrZSBvYmplY3QsIFwiK1NrLmFic3RyLnR5cGVOYW1lKHgpK1wiIGZvdW5kXCIpO1xucmV0dXJuIFNrLmJ1aWx0aW4uYnl0ZXMuJGRlY29kZS5jYWxsKHgsdixCKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzdHIgdGFrZXMgYXQgbW9zdCBvbmUgYXJndW1lbnQgKFwiKyhyLmxlbmd0aCt0Lmxlbmd0aCkrXCIgZ2l2ZW4pXCIpO30sJHIoKXtsZXQgcj1cIidcIjstMSE9PXRoaXMudi5pbmRleE9mKFwiJ1wiKSYmLTE9PT10aGlzLnYuaW5kZXhPZignXCInKSYmKHI9J1wiJyk7Y29uc3QgdD10aGlzLnYubGVuZ3RoO2xldCB4PXI7Zm9yKGxldCBJPTA7STx0O0krKyl7dmFyIHY9dGhpcy52LmNoYXJBdChJKTt2YXIgQj10aGlzLnYuY2hhckNvZGVBdChJKTt2PT09cnx8XCJcXFxcXCI9PT12P3grPVwiXFxcXFwiK3Y6XCJcXHRcIj09PXY/eCs9XCJcXFxcdFwiOlwiXFxuXCI9PT12P3grPVwiXFxcXG5cIjpcIlxcclwiPT09dj94Kz1cIlxcXFxyXCI6KDI1NTxCJiY1NTI5Nj5CfHw1NzM0NDw9QikmJiFTay5fX2Z1dHVyZV9fLnB5dGhvbjM/eCs9XCJcXFxcdVwiKyhcIjAwMFwiK0IudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk6NTUyOTY8PUImJlxuIVNrLl9fZnV0dXJlX18ucHl0aG9uMz8odj10aGlzLnYuY29kZVBvaW50QXQoSSksSSsrLHY9di50b1N0cmluZygxNiksQj1cIjAwMDAwMDBcIit2LnRvU3RyaW5nKDE2KSx4PTQ8di5sZW5ndGg/eCsoXCJcXFxcVVwiK0Iuc2xpY2UoLTgpKTp4KyhcIlxcXFx1XCIrQi5zbGljZSgtNCkpKToyNTU8QiYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMz94Kz1cIlxcXFx1ZmZmZFwiOlwiIFwiPnZ8fDEyNzw9QiYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMz8odj12LmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLDI+di5sZW5ndGgmJih2PVwiMFwiK3YpLHgrPVwiXFxcXHhcIit2KTp4Kz12fXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoeCtyKX0sdHAkc3RyKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnN0cj90aGlzOm5ldyBTay5idWlsdGluLnN0cih0aGlzLnYpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBxKHRoaXMpfSx0cCRyaWNoY29tcGFyZShyLHQpe2lmKCEociBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7XG5zd2l0Y2godCl7Y2FzZSBcIkx0XCI6cmV0dXJuIHRoaXMudjxyLnY7Y2FzZSBcIkx0RVwiOnJldHVybiB0aGlzLnY8PXIudjtjYXNlIFwiRXFcIjpyZXR1cm4gdGhpcy52PT09ci52O2Nhc2UgXCJOb3RFcVwiOnJldHVybiB0aGlzLnYhPT1yLnY7Y2FzZSBcIkd0XCI6cmV0dXJuIHRoaXMudj5yLnY7Y2FzZSBcIkd0RVwiOnJldHVybiB0aGlzLnY+PXIudn19LG1wJHN1YnNjcmlwdChyKXtsZXQgdDtpZihTay5taXNjZXZhbC5pc0luZGV4KHIpKXtyPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChyLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7dD10aGlzLnNxJGxlbmd0aCgpOzA+ciYmKHIrPXQpO2lmKDA+cnx8cj49dCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFwic3RyaW5nIGluZGV4IG91dCBvZiByYW5nZVwiKTtyZXR1cm4gdGhpcy5jb2RlcG9pbnRzP25ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc3Vic3RyaW5nKHRoaXMuY29kZXBvaW50c1tyXSx0aGlzLmNvZGVwb2ludHNbcisxXSkpOlxubmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5jaGFyQXQocikpfWlmKHIgaW5zdGFuY2VvZiBTay5idWlsdGluLnNsaWNlKXtsZXQgeD1cIlwiO3Q9dGhpcy5zcSRsZW5ndGgoKTt0aGlzLmNvZGVwb2ludHM/ci5zc3NpdGVyJCh0LHY9Pnt4Kz10aGlzLnYuc3Vic3RyaW5nKHRoaXMuY29kZXBvaW50c1t2XSx0aGlzLmNvZGVwb2ludHNbdisxXSl9KTpyLnNzc2l0ZXIkKHQsdj0+e3grPXRoaXMudi5jaGFyQXQodil9KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHgpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN0cmluZyBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShyKSk7fSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy4kaGFzQXN0cmFsQ29kZVBvaW50cygpP3RoaXMuY29kZXBvaW50cy5sZW5ndGg6dGhpcy52Lmxlbmd0aH0sc3EkY29uY2F0KHIpe2lmKCEociBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW5ub3QgY29uY2F0ZW5hdGUgJ3N0cicgYW5kICdcIitcblNrLmFic3RyLnR5cGVOYW1lKHIpK1wiJyBvYmplY3RzXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52K3Iudil9LHNxJHJlcGVhdChyKXtpZighU2subWlzY2V2YWwuaXNJbmRleChyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHIpK1wiJ1wiKTtyPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChyLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYocip0aGlzLnYubGVuZ3RoPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3I7bGV0IHQ9XCJcIjtmb3IobGV0IHg9MDt4PHI7eCsrKXQrPXRoaXMudjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHQpfSxzcSRjb250YWlucyhyKXtpZighKHIgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ2luIDxzdHJpbmc+JyByZXF1aXJlcyBzdHJpbmcgYXMgbGVmdCBvcGVyYW5kIG5vdCBcIitcblNrLmFic3RyLnR5cGVOYW1lKHIpKTtyZXR1cm4tMSE9PXRoaXMudi5pbmRleE9mKHIudil9LHRwJGFzX251bWJlcjohMCxuYiRyZW1haW5kZXI6ZnVuY3Rpb24ocil7dmFyIHQ7Y29uc3QgeD10aGlzLnNrJGJ1aWx0aW5CYXNlO3IuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnR1cGxlfHxyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0fHxyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5tYXBwaW5ncHJveHl8fChyPW5ldyBTay5idWlsdGluLnR1cGxlKFtyXSkpO3ZhciB2PTA7dmFyIEI9dGhpcy4kanNzdHIoKS5yZXBsYWNlKC8lKFxcKFthLXpBLVowLTldK1xcKSk/KFsjMCArXFwtXSspPyhcXCp8WzAtOV0rKT8oXFwuKFxcKnxbMC05XSspKT9baGxMXT8oW2Rpb3V4WGVFZkZnR2Nyc2IlXSkvZyxmdW5jdGlvbihJLE0sUyxFLEgseSxBKXt2YXIgSixRLFgsYWEsZWE7RT1Tay5idWlsdGluLmFzbnVtJChFKTtIPVNrLmJ1aWx0aW4uYXNudW0kKEgpO3ZvaWQgMCE9PU0mJlwiXCIhPT1NfHxcIiVcIj09QXx8XG4oSj12KyspO1wiXCI9PT1IJiYoSD12b2lkIDApO3ZhciBuYT1RPVg9YWE9ZWE9ITE7UyYmKC0xIT09Uy5pbmRleE9mKFwiLVwiKT9hYT0hMDotMSE9PVMuaW5kZXhPZihcIjBcIikmJihlYT0hMCksLTEhPT1TLmluZGV4T2YoXCIrXCIpP1E9ITA6LTEhPT1TLmluZGV4T2YoXCIgXCIpJiYoWD0hMCksbmE9LTEhPT1TLmluZGV4T2YoXCIjXCIpKTtIJiYoSD1wYXJzZUludChILnN1YnN0cigxKSwxMCkpO1M9ZnVuY3Rpb24oY2EsbGEpe3ZhciBpYTtsYT1Tay5idWlsdGluLmFzbnVtJChsYSk7dmFyIGthPSExO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgY2EpezA+Y2EmJihjYT0tY2Esa2E9ITApO3ZhciBVPWNhLnRvU3RyaW5nKGxhKX1lbHNlIGNhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8/KFU9Y2Euc3RyJChsYSwhMSksMjxVLmxlbmd0aCYmXCIuMFwiPT09VS5zdWJzdHIoLTIpJiYoVT1VLnN1YnN0cigwLFUubGVuZ3RoLTIpKSxrYT1jYS5uYiRpc25lZ2F0aXZlKCkpOmNhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfP1xuKFU9Y2Euc3RyJChsYSwhMSksa2E9Y2EubmIkaXNuZWdhdGl2ZSgpKTpjYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nJiYoVT1jYS5zdHIkKGxhLCExKSxrYT1jYS5uYiRpc25lZ2F0aXZlKCkpO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMCE9PVUsXCJ1bmhhbmRsZWQgbnVtYmVyIGZvcm1hdFwiKTtjYT0hMTtpZihIKWZvcihpYT1VLmxlbmd0aDtpYTxIOysraWEpVT1cIjBcIitVLGNhPSEwO2lhPVwiXCI7a2E/aWE9XCItXCI6UT9pYT1cIitcIitpYTpYJiYoaWE9XCIgXCIraWEpO25hJiYoMTY9PT1sYT9pYSs9XCIweFwiOjghPT1sYXx8Y2F8fFwiMFwiPT09VXx8KGlhKz1cIjBcIikpO3JldHVybltpYSxVXX07ST1mdW5jdGlvbihjYSl7dmFyIGxhPWNhWzBdO2NhPWNhWzFdO2lmKEUpe0U9cGFyc2VJbnQoRSwxMCk7dmFyIGlhPWNhLmxlbmd0aCtsYS5sZW5ndGg7aWYoZWEpZm9yKDtpYTxFOysraWEpY2E9XCIwXCIrY2E7ZWxzZSBpZihhYSl7Zm9yKDtpYTxFOysraWEpY2ErPVwiIFwiO1NrLl9fZnV0dXJlX18ucHl0aG9uMyYmXG4oY2ErPWxhLGxhPVwiXCIpfWVsc2UgZm9yKDtpYTxFOysraWEpbGE9XCIgXCIrbGF9cmV0dXJuIGxhK2NhfTtpZihyLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi50dXBsZSlNPXIudltKXTtlbHNlIGlmKHZvaWQgMCE9PXIubXAkc3Vic2NyaXB0JiZ2b2lkIDAhPT1NKU09TS5zdWJzdHJpbmcoMSxNLmxlbmd0aC0xKSxNPXIubXAkc3Vic2NyaXB0KG5ldyB4KE0pKTtlbHNlIGlmKHIuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmRpY3R8fHIuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmxpc3QpTT1yO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3Ioci50cCRuYW1lK1wiIGluc3RhbmNlIGhhcyBubyBhdHRyaWJ1dGUgJ21wJHN1YnNjcmlwdCdcIik7aWYoXCJkXCI9PT1BfHxcImlcIj09PUEpe3ZhciBvYT1TKE0sMTApO2lmKHZvaWQgMD09PW9hWzFdKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIiVcIitBK1wiIGZvcm1hdDogYSBudW1iZXIgaXMgcmVxdWlyZWQsIG5vdCBcIitcblNrLmFic3RyLnR5cGVOYW1lKE0pKTtBPW9hWzFdO29hWzFdPS0xIT09QS5pbmRleE9mKFwiLlwiKT9wYXJzZUludChBLDEwKS50b1N0cmluZygpOkE7cmV0dXJuIEkob2EpfWlmKFwib1wiPT09QSlyZXR1cm4gSShTKE0sOCkpO2lmKFwieFwiPT09QSlyZXR1cm4gSShTKE0sMTYpKTtpZihcIlhcIj09PUEpcmV0dXJuIEkoUyhNLDE2KSkudG9VcHBlckNhc2UoKTtpZihcImZcIj09PUF8fFwiRlwiPT09QXx8XCJlXCI9PT1BfHxcIkVcIj09PUF8fFwiZ1wiPT09QXx8XCJHXCI9PT1BKXtvYT1Tay5idWlsdGluLmFzbnVtJChNKTtcInN0cmluZ1wiPT09dHlwZW9mIG9hJiYob2E9TnVtYmVyKG9hKSk7aWYoSW5maW5pdHk9PT1vYSlyZXR1cm5cImluZlwiO2lmKC1JbmZpbml0eT09PW9hKXJldHVyblwiLWluZlwiO2lmKGlzTmFOKG9hKSlyZXR1cm5cIm5hblwiO0o9W1widG9FeHBvbmVudGlhbFwiLFwidG9GaXhlZFwiLFwidG9QcmVjaXNpb25cIl1bXCJlZmdcIi5pbmRleE9mKEEudG9Mb3dlckNhc2UoKSldO2lmKHZvaWQgMD09PUh8fFwiXCI9PT1IKWlmKFwiZVwiPT09XG5BfHxcIkVcIj09PUEpSD02O2Vsc2UgaWYoXCJmXCI9PT1BfHxcIkZcIj09PUEpSD1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/Njo3O0o9b2FbSl0oSCk7U2suYnVpbHRpbi5jaGVja0Zsb2F0KE0pJiYwPT09b2EmJi1JbmZpbml0eT09PTEvb2EmJihKPVwiLVwiK0opO1NrLl9fZnV0dXJlX18ucHl0aG9uMyYmKDc8PUoubGVuZ3RoJiZcIjAuMDAwMFwiPT1KLnNsaWNlKDAsNikmJih0PXBhcnNlRmxvYXQoSiksSj10LnRvRXhwb25lbnRpYWwoKSksXCItXCI9PUouY2hhckF0KEoubGVuZ3RoLTIpJiYoSj1KLnNsaWNlKDAsSi5sZW5ndGgtMSkrXCIwXCIrSi5jaGFyQXQoSi5sZW5ndGgtMSkpKTstMSE9PVwiRUZHXCIuaW5kZXhPZihBKSYmKEo9Si50b1VwcGVyQ2FzZSgpKTtyZXR1cm4gSShbXCJcIixKXSl9aWYoXCJjXCI9PT1BKXtpZihcIm51bWJlclwiPT09dHlwZW9mIE0pcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoTSk7aWYoTSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8TSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKE0udik7XG5pZihNIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmcpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoTS5zdHIkKDEwLCExKVswXSk7aWYoTS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uc3RyKXJldHVybiBNLnYuc3Vic3RyKDAsMSk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTt9aWYoXCJyXCI9PT1BKXJldHVybiBBPVNrLmJ1aWx0aW4ucmVwcihNKSxIP0Eudi5zdWJzdHIoMCxIKTpBLnY7aWYoXCJzXCI9PT1BJiZ4PT09U2suYnVpbHRpbi5zdHIpe0E9bmV3IFNrLmJ1aWx0aW4uc3RyKE0pO0E9QS4kanNzdHIoKTtpZihIKXJldHVybiBBLnN1YnN0cigwLEgpO0UmJihBPUkoW1wiIFwiLEFdKSk7cmV0dXJuIEF9aWYoXCJiXCI9PT1BfHxcInNcIj09PUEpe2lmKHg9PT1Tay5idWlsdGluLnN0cil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwidW5zdXBwb3J0ZWQgZm9ybWF0IGNoYXJhY3RlciAnYidcIik7aWYoIShNIGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uYnl0ZXMpJiZ2b2lkIDA9PT0ob2E9U2suYWJzdHIubG9va3VwU3BlY2lhbChNLFNrLmJ1aWx0aW4uc3RyLiRieXRlcykpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIiViIHJlcXVpcmVzIGEgYnl0ZXMtbGlrZSBvYmplY3QsIG9yIGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMgX19ieXRlc19fLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKE0pK1wiJ1wiKTt2b2lkIDAhPT1vYSYmKE09bmV3IFNrLmJ1aWx0aW4uYnl0ZXMoTSkpO0E9TS4kanNzdHIoKTtpZihIKXJldHVybiBBLnN1YnN0cigwLEgpO0UmJihBPUkoW1wiIFwiLEFdKSk7cmV0dXJuIEF9aWYoXCIlXCI9PT1BKXJldHVyblwiJVwifSk7aWYociBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUmJnY8ci5zcSRsZW5ndGgoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJub3QgYWxsIGFyZ3VtZW50cyBjb252ZXJ0ZWQgZHVyaW5nIHN0cmluZyBmb3JtYXR0aW5nXCIpO3JldHVybiBuZXcgeChCKX19LFxucHJvdG86e3RvU3RyaW5nKCl7cmV0dXJuIHRoaXMudn0sJHN1YnR5cGVfbmV3KHIsdCl7Y29uc3QgeD1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyPVNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS50cCRuZXcocix0KTt4LiRtYW5nbGVkPXIuJG1hbmdsZWQ7eC4kc2F2ZWRLZXlIYXNoPXIuJHNhdmVkS2V5SGFzaDt4LnY9ci52O3JldHVybiB4fSwkanNzdHIoKXtyZXR1cm4gdGhpcy52fSwkaGFzQXN0cmFsQ29kZVBvaW50cygpe2lmKG51bGw9PT10aGlzLmNvZGVwb2ludHMpcmV0dXJuITE7aWYodm9pZCAwIT09dGhpcy5jb2RlcG9pbnRzKXJldHVybiEwO2Zvcih2YXIgcj0wO3I8dGhpcy52Lmxlbmd0aDtyKyspe2xldCB0PXRoaXMudi5jaGFyQ29kZUF0KHIpO2lmKDU1Mjk2PD10JiY1NzM0ND50KXt0aGlzLmNvZGVwb2ludHM9W107Zm9yKHI9MDtyPHRoaXMudi5sZW5ndGg7cisrKXRoaXMuY29kZXBvaW50cy5wdXNoKHIpLHQ9dGhpcy52LmNoYXJDb2RlQXQociksNTUyOTY8PXQmJjU2MzIwPlxudCYmcisrO3JldHVybiEwfX10aGlzLmNvZGVwb2ludHM9bnVsbDtyZXR1cm4hMX0sc2skYXNhcnJheSgpe2NvbnN0IHI9W107aWYodGhpcy4kaGFzQXN0cmFsQ29kZVBvaW50cygpKXt2YXIgdD10aGlzLmNvZGVwb2ludHM7Zm9yKGxldCB4PTA7eDx0Lmxlbmd0aDt4Kyspci5wdXNoKG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc3Vic3RyaW5nKHRbeF0sdFt4KzFdKSkpfWVsc2UgZm9yKHQ9MDt0PHRoaXMudi5sZW5ndGg7dCsrKXIucHVzaChuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52W3RdKSk7cmV0dXJuIHJ9LGZpbmQkbGVmdDpnKCExKSxmaW5kJHJpZ2h0OmcoITApLGdldCR0Z3Qocil7aWYociBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKXJldHVybiByLnY7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYSBzdHIgaW5zdGFuY2UgaXMgcmVxdWlyZWQgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZShyKStcIidcIik7fSx2YWx1ZU9mKCl7cmV0dXJuIHRoaXMudn0sJGlzSWRlbnRpZmllcigpe3JldHVybiBTay50b2tlbi5pc0lkZW50aWZpZXIodGhpcy52KX19LFxubWV0aG9kczp7ZW5jb2RlOnskbWV0aDpmdW5jdGlvbihyLHQpeyh7ZW5jb2Rpbmc6cixlcnJvcnM6dH09U2suYnVpbHRpbi5ieXRlcy5jaGVjayRlbmNvZGVBcmdzKFwiZW5jb2RlXCIscix0KSk7cj1Tay5idWlsdGluLmJ5dGVzLnN0ciRlbmNvZGUodGhpcyxyLHQpO3JldHVybiBTay5fX2Z1dHVyZV9fLnB5dGhvbjM/cjpuZXcgU2suYnVpbHRpbi5zdHIoci4kanNzdHIoKSl9LCRmbGFnczp7TmFtZWRBcmdzOltcImVuY29kaW5nXCIsXCJlcnJvcnNcIl19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBlbmNvZGluZz0ndXRmLTgnLCBlcnJvcnM9J3N0cmljdCcpXCIsJGRvYzpcIkVuY29kZSB0aGUgc3RyaW5nIHVzaW5nIHRoZSBjb2RlYyByZWdpc3RlcmVkIGZvciBlbmNvZGluZy5cXG5cXG4gIGVuY29kaW5nXFxuICAgIFRoZSBlbmNvZGluZyBpbiB3aGljaCB0byBlbmNvZGUgdGhlIHN0cmluZy5cXG4gIGVycm9yc1xcbiAgICBUaGUgZXJyb3IgaGFuZGxpbmcgc2NoZW1lIHRvIHVzZSBmb3IgZW5jb2RpbmcgZXJyb3JzLlxcbiAgICBUaGUgZGVmYXVsdCBpcyAnc3RyaWN0JyBtZWFuaW5nIHRoYXQgZW5jb2RpbmcgZXJyb3JzIHJhaXNlIGFcXG4gICAgVW5pY29kZUVuY29kZUVycm9yLiAgT3RoZXIgcG9zc2libGUgdmFsdWVzIGFyZSAnaWdub3JlJywgJ3JlcGxhY2UnIGFuZFxcbiAgICAneG1sY2hhcnJlZnJlcGxhY2UnIGFzIHdlbGwgYXMgYW55IG90aGVyIG5hbWUgcmVnaXN0ZXJlZCB3aXRoXFxuICAgIGNvZGVjcy5yZWdpc3Rlcl9lcnJvciB0aGF0IGNhbiBoYW5kbGUgVW5pY29kZUVuY29kZUVycm9ycy5cIn0sXG5yZXBsYWNlOnskbWV0aChyLHQseCl7cj10aGlzLmdldCR0Z3Qocik7dD10aGlzLmdldCR0Z3QodCk7eD12b2lkIDA9PT14Py0xOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZCh4LFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7cj1uZXcgUmVnRXhwKGIociksXCJnXCIpO2lmKDA+eClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5yZXBsYWNlKHIsdCkpO2xldCB2PTA7cj10aGlzLnYucmVwbGFjZShyLEI9PnYrKzx4P3Q6Qik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihyKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkc2VsZiwgb2xkLCBuZXcsIGNvdW50PS0xLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IHdpdGggYWxsIG9jY3VycmVuY2VzIG9mIHN1YnN0cmluZyBvbGQgcmVwbGFjZWQgYnkgbmV3LlxcblxcbiAgY291bnRcXG4gICAgTWF4aW11bSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgdG8gcmVwbGFjZS5cXG4gICAgLTEgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyByZXBsYWNlIGFsbCBvY2N1cnJlbmNlcy5cXG5cXG5JZiB0aGUgb3B0aW9uYWwgYXJndW1lbnQgY291bnQgaXMgZ2l2ZW4sIG9ubHkgdGhlIGZpcnN0IGNvdW50IG9jY3VycmVuY2VzIGFyZVxcbnJlcGxhY2VkLlwifSxcbnNwbGl0OnskbWV0aDpmdW5jdGlvbihyLHQpe3Q9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHQsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtyPWUodGhpcyxyLHQpO3Q9W107Zm9yKGxldCB4PTA7eDxyLmxlbmd0aDt4KyspdC5wdXNoKG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc3Vic3RyaW5nKHJbeF0sclsrK3hdKSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHQpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJzZXBcIixcIm1heHNwbGl0XCJdLERlZmF1bHRzOltTay5idWlsdGluLm5vbmUubm9uZSQsLTFdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgc2VwPU5vbmUsIG1heHNwbGl0PS0xKVwiLCRkb2M6XCJSZXR1cm4gYSBsaXN0IG9mIHRoZSB3b3JkcyBpbiB0aGUgc3RyaW5nLCB1c2luZyBzZXAgYXMgdGhlIGRlbGltaXRlciBzdHJpbmcuXFxuXFxuICBzZXBcXG4gICAgVGhlIGRlbGltaXRlciBhY2NvcmRpbmcgd2hpY2ggdG8gc3BsaXQgdGhlIHN0cmluZy5cXG4gICAgTm9uZSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIHNwbGl0IGFjY29yZGluZyB0byBhbnkgd2hpdGVzcGFjZSxcXG4gICAgYW5kIGRpc2NhcmQgZW1wdHkgc3RyaW5ncyBmcm9tIHRoZSByZXN1bHQuXFxuICBtYXhzcGxpdFxcbiAgICBNYXhpbXVtIG51bWJlciBvZiBzcGxpdHMgdG8gZG8uXFxuICAgIC0xICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgbm8gbGltaXQuXCJ9LFxucnNwbGl0OnskbWV0aDpmdW5jdGlvbihyLHQpe3Q9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHQsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtyPWUodGhpcyxyLC0xKTt2YXIgeD0wPnQ/MDoyKihyLmxlbmd0aC8yLXQpO3Q9W107Zm9yKDA+PXg/eD0wOnQucHVzaChuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnNsaWNlKDAsclt4LTFdKSkpO3g8ci5sZW5ndGg7eCsrKXQucHVzaChuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnN1YnN0cmluZyhyW3hdLHJbKyt4XSkpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0KX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wic2VwXCIsXCJtYXhzcGxpdFwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ub25lLm5vbmUkLC0xXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIHNlcD1Ob25lLCBtYXhzcGxpdD0tMSlcIiwkZG9jOlwiUmV0dXJuIGEgbGlzdCBvZiB0aGUgd29yZHMgaW4gdGhlIHN0cmluZywgdXNpbmcgc2VwIGFzIHRoZSBkZWxpbWl0ZXIgc3RyaW5nLlxcblxcbiAgc2VwXFxuICAgIFRoZSBkZWxpbWl0ZXIgYWNjb3JkaW5nIHdoaWNoIHRvIHNwbGl0IHRoZSBzdHJpbmcuXFxuICAgIE5vbmUgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyBzcGxpdCBhY2NvcmRpbmcgdG8gYW55IHdoaXRlc3BhY2UsXFxuICAgIGFuZCBkaXNjYXJkIGVtcHR5IHN0cmluZ3MgZnJvbSB0aGUgcmVzdWx0LlxcbiAgbWF4c3BsaXRcXG4gICAgTWF4aW11bSBudW1iZXIgb2Ygc3BsaXRzIHRvIGRvLlxcbiAgICAtMSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIG5vIGxpbWl0LlxcblxcblNwbGl0cyBhcmUgZG9uZSBzdGFydGluZyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgYW5kIHdvcmtpbmcgdG8gdGhlIGZyb250LlwifSxcbmpvaW46eyRtZXRoKHIpe2NvbnN0IHQ9W107cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihyKSx4PT57aWYoISh4IGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNlcXVlbmNlIGl0ZW0gXCIrdC5sZW5ndGgrXCI6IGV4cGVjdGVkIHN0ciwgXCIrU2suYWJzdHIudHlwZU5hbWUoeCkrXCIgZm91bmRcIik7dC5wdXNoKHgudil9KSwoKT0+bmV3IFNrLmJ1aWx0aW4uc3RyKHQuam9pbih0aGlzLnYpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgaXRlcmFibGUsIC8pXCIsJGRvYzpcIkNvbmNhdGVuYXRlIGFueSBudW1iZXIgb2Ygc3RyaW5ncy5cXG5cXG5UaGUgc3RyaW5nIHdob3NlIG1ldGhvZCBpcyBjYWxsZWQgaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiBlYWNoIGdpdmVuIHN0cmluZy5cXG5UaGUgcmVzdWx0IGlzIHJldHVybmVkIGFzIGEgbmV3IHN0cmluZy5cXG5cXG5FeGFtcGxlOiAnLicuam9pbihbJ2FiJywgJ3BxJywgJ3JzJ10pIC0+ICdhYi5wcS5ycydcIn0sXG5jYXBpdGFsaXplOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3RoaXMudi5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjYXBpdGFsaXplZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXFxuXFxuTW9yZSBzcGVjaWZpY2FsbHksIG1ha2UgdGhlIGZpcnN0IGNoYXJhY3RlciBoYXZlIHVwcGVyIGNhc2UgYW5kIHRoZSByZXN0IGxvd2VyXFxuY2FzZS5cIn0sdGl0bGU6eyRtZXRoOmZ1bmN0aW9uKCl7Y29uc3Qgcj10aGlzLnYucmVwbGFjZSgvW2Etel1bYS16XSovZ2ksdD0+dFswXS50b1VwcGVyQ2FzZSgpK3Quc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIocil9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgc3RyaW5nIHdoZXJlIGVhY2ggd29yZCBpcyB0aXRsZWNhc2VkLlxcblxcbk1vcmUgc3BlY2lmaWNhbGx5LCB3b3JkcyBzdGFydCB3aXRoIHVwcGVyY2FzZWQgY2hhcmFjdGVycyBhbmQgYWxsIHJlbWFpbmluZ1xcbmNhc2VkIGNoYXJhY3RlcnMgaGF2ZSBsb3dlciBjYXNlLlwifSxcbmNlbnRlcjp7JG1ldGg6aCghMSwhMCksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkc2VsZiwgd2lkdGgsIGZpbGxjaGFyPScgJywgLylcIiwkZG9jOlwiUmV0dXJuIGEgY2VudGVyZWQgc3RyaW5nIG9mIGxlbmd0aCB3aWR0aC5cXG5cXG5QYWRkaW5nIGlzIGRvbmUgdXNpbmcgdGhlIHNwZWNpZmllZCBmaWxsIGNoYXJhY3RlciAoZGVmYXVsdCBpcyBhIHNwYWNlKS5cIn0sY291bnQ6eyRtZXRoOmZ1bmN0aW9uKHIsdCx4KXtyPXRoaXMuZ2V0JHRndChyKTsoe3N0YXJ0OnQsZW5kOnh9PXAodGhpcyx0LHgpKTtpZih4PHQpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCk7cj1yLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLFwiXFxcXCQmXCIpO3I9bmV3IFJlZ0V4cChyLFwiZ1wiKTtyZXR1cm4odD10aGlzLnYuc2xpY2UodCx4KS5tYXRjaChyKSk/bmV3IFNrLmJ1aWx0aW4uaW50Xyh0Lmxlbmd0aCk6bmV3IFNrLmJ1aWx0aW4uaW50XygwKX0sJGZsYWdzOntNaW5BcmdzOjEsXG5NYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlMuY291bnQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBudW1iZXIgb2Ygbm9uLW92ZXJsYXBwaW5nIG9jY3VycmVuY2VzIG9mIHN1YnN0cmluZyBzdWIgaW5cXG5zdHJpbmcgU1tzdGFydDplbmRdLiAgT3B0aW9uYWwgYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlXFxuaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXCJ9LGV4cGFuZHRhYnM6eyRtZXRoOmZ1bmN0aW9uKHIpe2lmKFNrLmJ1aWx0aW4uY2hlY2tJbnQocikpcj1Tay5idWlsdGluLmFzbnVtJChyKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFuIGludGVnZXIgaXMgcmVxdWlyZWQsIGdvdCB0eXBlXCIrU2suYWJzdHIudHlwZU5hbWUocikpO2NvbnN0IHQ9QXJyYXkocisxKS5qb2luKFwiIFwiKSx4PXRoaXMudi5yZXBsYWNlKC8oW15cXHJcXG5cXHRdKilcXHQvZywodixCKT0+Qit0LnNsaWNlKEIubGVuZ3RoJXIpKTtcbnJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoeCl9LCRmbGFnczp7TmFtZWRBcmdzOltcInRhYnNpemVcIl0sRGVmYXVsdHM6WzhdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgdGFic2l6ZT04KVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IHdoZXJlIGFsbCB0YWIgY2hhcmFjdGVycyBhcmUgZXhwYW5kZWQgdXNpbmcgc3BhY2VzLlxcblxcbklmIHRhYnNpemUgaXMgbm90IGdpdmVuLCBhIHRhYiBzaXplIG9mIDggY2hhcmFjdGVycyBpcyBhc3N1bWVkLlwifSxmaW5kOnskbWV0aDpmdW5jdGlvbihyLHQseCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5maW5kJGxlZnQocix0LHgpKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLmZpbmQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBsb3dlc3QgaW5kZXggaW4gUyB3aGVyZSBzdWJzdHJpbmcgc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBTW3N0YXJ0OmVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SZXR1cm4gLTEgb24gZmFpbHVyZS5cIn0sXG5wYXJ0aXRpb246eyRtZXRoOmYoITEpLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgc2VwLCAvKVwiLCRkb2M6XCJQYXJ0aXRpb24gdGhlIHN0cmluZyBpbnRvIHRocmVlIHBhcnRzIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXFxuXFxuVGhpcyB3aWxsIHNlYXJjaCBmb3IgdGhlIHNlcGFyYXRvciBpbiB0aGUgc3RyaW5nLiAgSWYgdGhlIHNlcGFyYXRvciBpcyBmb3VuZCxcXG5yZXR1cm5zIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSBwYXJ0IGJlZm9yZSB0aGUgc2VwYXJhdG9yLCB0aGUgc2VwYXJhdG9yXFxuaXRzZWxmLCBhbmQgdGhlIHBhcnQgYWZ0ZXIgaXQuXFxuXFxuSWYgdGhlIHNlcGFyYXRvciBpcyBub3QgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIHN0cmluZ1xcbmFuZCB0d28gZW1wdHkgc3RyaW5ncy5cIn0saW5kZXg6eyRtZXRoOmZ1bmN0aW9uKHIsdCx4KXtyPXRoaXMuZmluZCRsZWZ0KHIsdCx4KTtpZigtMT09PXIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInN1YnN0cmluZyBub3QgZm91bmRcIik7XG5yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhyKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLmluZGV4KHN1YlssIHN0YXJ0WywgZW5kXV0pIC0+IGludFxcblxcblJldHVybiB0aGUgbG93ZXN0IGluZGV4IGluIFMgd2hlcmUgc3Vic3RyaW5nIHN1YiBpcyBmb3VuZCwgXFxuc3VjaCB0aGF0IHN1YiBpcyBjb250YWluZWQgd2l0aGluIFNbc3RhcnQ6ZW5kXS4gIE9wdGlvbmFsXFxuYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlxcblxcblJhaXNlcyBWYWx1ZUVycm9yIHdoZW4gdGhlIHN1YnN0cmluZyBpcyBub3QgZm91bmQuXCJ9LGxqdXN0OnskbWV0aDpoKCExLCExKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRzZWxmLCB3aWR0aCwgZmlsbGNoYXI9JyAnLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBsZWZ0LWp1c3RpZmllZCBzdHJpbmcgb2YgbGVuZ3RoIHdpZHRoLlxcblxcblBhZGRpbmcgaXMgZG9uZSB1c2luZyB0aGUgc3BlY2lmaWVkIGZpbGwgY2hhcmFjdGVyIChkZWZhdWx0IGlzIGEgc3BhY2UpLlwifSxcbmxvd2VyOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvTG93ZXJDYXNlKCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgb2YgdGhlIHN0cmluZyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlwifSxsc3RyaXA6eyRtZXRoOmQoL15cXHMrL2cscj0+XCJeW1wiK3IrXCJdK1wiKSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBjaGFycz1Ob25lLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZC5cXG5cXG5JZiBjaGFycyBpcyBnaXZlbiBhbmQgbm90IE5vbmUsIHJlbW92ZSBjaGFyYWN0ZXJzIGluIGNoYXJzIGluc3RlYWQuXCJ9LHJmaW5kOnskbWV0aChyLHQseCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5maW5kJHJpZ2h0KHIsdCx4KSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sXG4kdGV4dHNpZzpudWxsLCRkb2M6XCJTLnJmaW5kKHN1YlssIHN0YXJ0WywgZW5kXV0pIC0+IGludFxcblxcblJldHVybiB0aGUgaGlnaGVzdCBpbmRleCBpbiBTIHdoZXJlIHN1YnN0cmluZyBzdWIgaXMgZm91bmQsXFxuc3VjaCB0aGF0IHN1YiBpcyBjb250YWluZWQgd2l0aGluIFNbc3RhcnQ6ZW5kXS4gIE9wdGlvbmFsXFxuYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlxcblxcblJldHVybiAtMSBvbiBmYWlsdXJlLlwifSxyaW5kZXg6eyRtZXRoOmZ1bmN0aW9uKHIsdCx4KXtyPXRoaXMuZmluZCRyaWdodChyLHQseCk7aWYoLTE9PT1yKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzdWJzdHJpbmcgbm90IGZvdW5kXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHIpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlMucmluZGV4KHN1YlssIHN0YXJ0WywgZW5kXV0pIC0+IGludFxcblxcblJldHVybiB0aGUgaGlnaGVzdCBpbmRleCBpbiBTIHdoZXJlIHN1YnN0cmluZyBzdWIgaXMgZm91bmQsXFxuc3VjaCB0aGF0IHN1YiBpcyBjb250YWluZWQgd2l0aGluIFNbc3RhcnQ6ZW5kXS4gIE9wdGlvbmFsXFxuYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlxcblxcblJhaXNlcyBWYWx1ZUVycm9yIHdoZW4gdGhlIHN1YnN0cmluZyBpcyBub3QgZm91bmQuXCJ9LFxucmp1c3Q6eyRtZXRoOmgoITAsITEpLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJHNlbGYsIHdpZHRoLCBmaWxsY2hhcj0nICcsIC8pXCIsJGRvYzpcIlJldHVybiBhIHJpZ2h0LWp1c3RpZmllZCBzdHJpbmcgb2YgbGVuZ3RoIHdpZHRoLlxcblxcblBhZGRpbmcgaXMgZG9uZSB1c2luZyB0aGUgc3BlY2lmaWVkIGZpbGwgY2hhcmFjdGVyIChkZWZhdWx0IGlzIGEgc3BhY2UpLlwifSxyc3RyaXA6eyRtZXRoOmQoL1xccyskL2cscj0+XCJbXCIrcitcIl0rJFwiKSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBjaGFycz1Ob25lLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQuXFxuXFxuSWYgY2hhcnMgaXMgZ2l2ZW4gYW5kIG5vdCBOb25lLCByZW1vdmUgY2hhcmFjdGVycyBpbiBjaGFycyBpbnN0ZWFkLlwifSxycGFydGl0aW9uOnskbWV0aDpmKCEwKSwkZmxhZ3M6e09uZUFyZzohMH0sXG4kdGV4dHNpZzpcIigkc2VsZiwgc2VwLCAvKVwiLCRkb2M6XCJQYXJ0aXRpb24gdGhlIHN0cmluZyBpbnRvIHRocmVlIHBhcnRzIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXFxuXFxuVGhpcyB3aWxsIHNlYXJjaCBmb3IgdGhlIHNlcGFyYXRvciBpbiB0aGUgc3RyaW5nLCBzdGFydGluZyBhdCB0aGUgZW5kLiBJZlxcbnRoZSBzZXBhcmF0b3IgaXMgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhcnQgYmVmb3JlIHRoZVxcbnNlcGFyYXRvciwgdGhlIHNlcGFyYXRvciBpdHNlbGYsIGFuZCB0aGUgcGFydCBhZnRlciBpdC5cXG5cXG5JZiB0aGUgc2VwYXJhdG9yIGlzIG5vdCBmb3VuZCwgcmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0d28gZW1wdHkgc3RyaW5nc1xcbmFuZCB0aGUgb3JpZ2luYWwgc3RyaW5nLlwifSxzcGxpdGxpbmVzOnskbWV0aDpmdW5jdGlvbihyKXtyPVNrLm1pc2NldmFsLmlzVHJ1ZShyKTtjb25zdCB0PXRoaXMudix4PVtdLHY9dC5sZW5ndGg7dmFyIEI9XG4wO2ZvcihsZXQgTT0wO008djtNKyspe3ZhciBJPXQuY2hhckF0KE0pO2lmKFwiXFxuXCI9PT10LmNoYXJBdChNKzEpJiZcIlxcclwiPT09SSlJPU0rMixCPXQuc2xpY2UoQixJKSxyfHwoQj1CLnJlcGxhY2UoLyhcXHJ8XFxuKS9nLFwiXCIpKSx4LnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKEIpKSxCPUk7ZWxzZSBpZihcIlxcblwiPT09SSYmXCJcXHJcIiE9PXQuY2hhckF0KE0tMSl8fFwiXFxyXCI9PT1JKUk9TSsxLEI9dC5zbGljZShCLEkpLHJ8fChCPUIucmVwbGFjZSgvKFxccnxcXG4pL2csXCJcIikpLHgucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoQikpLEI9SX1CPHYmJihCPXQuc2xpY2UoQix2KSxyfHwoQj1CLnJlcGxhY2UoLyhcXHJ8XFxuKS9nLFwiXCIpKSx4LnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKEIpKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoeCl9LCRmbGFnczp7TmFtZWRBcmdzOltcImtlZXBlbmRzXCJdLERlZmF1bHRzOlshMV19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBrZWVwZW5kcz1GYWxzZSlcIiwkZG9jOlwiUmV0dXJuIGEgbGlzdCBvZiB0aGUgbGluZXMgaW4gdGhlIHN0cmluZywgYnJlYWtpbmcgYXQgbGluZSBib3VuZGFyaWVzLlxcblxcbkxpbmUgYnJlYWtzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBsaXN0IHVubGVzcyBrZWVwZW5kcyBpcyBnaXZlbiBhbmRcXG50cnVlLlwifSxcbnN0cmlwOnskbWV0aDpkKC9eXFxzK3xcXHMrJC9nLHI9PlwiXltcIityK1wiXSt8W1wiK3IrXCJdKyRcIiksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgY2hhcnM9Tm9uZSwgLylcIiwkZG9jOlwiUmV0dXJuIGEgY29weSBvZiB0aGUgc3RyaW5nIHdpdGggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSByZW1vdmUuXFxuXFxuSWYgY2hhcnMgaXMgZ2l2ZW4gYW5kIG5vdCBOb25lLCByZW1vdmUgY2hhcmFjdGVycyBpbiBjaGFycyBpbnN0ZWFkLlwifSxzd2FwY2FzZTp7JG1ldGgoKXtjb25zdCByPXRoaXMudi5yZXBsYWNlKC9bYS16XS9naSx0PT57Y29uc3QgeD10LnRvTG93ZXJDYXNlKCk7cmV0dXJuIHg9PT10P3QudG9VcHBlckNhc2UoKTp4fSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihyKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJDb252ZXJ0IHVwcGVyY2FzZSBjaGFyYWN0ZXJzIHRvIGxvd2VyY2FzZSBhbmQgbG93ZXJjYXNlIGNoYXJhY3RlcnMgdG8gdXBwZXJjYXNlLlwifSxcbnVwcGVyOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvVXBwZXJDYXNlKCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgb2YgdGhlIHN0cmluZyBjb252ZXJ0ZWQgdG8gdXBwZXJjYXNlLlwifSxzdGFydHN3aXRoOnskbWV0aDphKFwic3RhcnRzd2l0aFwiLChyLHQpPT4wPT09ci5pbmRleE9mKHQpKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlMuc3RhcnRzd2l0aChwcmVmaXhbLCBzdGFydFssIGVuZF1dKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgUyBzdGFydHMgd2l0aCB0aGUgc3BlY2lmaWVkIHByZWZpeCwgRmFsc2Ugb3RoZXJ3aXNlLlxcbldpdGggb3B0aW9uYWwgc3RhcnQsIHRlc3QgUyBiZWdpbm5pbmcgYXQgdGhhdCBwb3NpdGlvbi5cXG5XaXRoIG9wdGlvbmFsIGVuZCwgc3RvcCBjb21wYXJpbmcgUyBhdCB0aGF0IHBvc2l0aW9uLlxcbnByZWZpeCBjYW4gYWxzbyBiZSBhIHR1cGxlIG9mIHN0cmluZ3MgdG8gdHJ5LlwifSxcbmVuZHN3aXRoOnskbWV0aDphKFwiZW5kc3dpdGhcIiwocix0KT0+LTEhPT1yLmluZGV4T2YodCxyLmxlbmd0aC10Lmxlbmd0aCkpLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5lbmRzd2l0aChzdWZmaXhbLCBzdGFydFssIGVuZF1dKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgUyBlbmRzIHdpdGggdGhlIHNwZWNpZmllZCBzdWZmaXgsIEZhbHNlIG90aGVyd2lzZS5cXG5XaXRoIG9wdGlvbmFsIHN0YXJ0LCB0ZXN0IFMgYmVnaW5uaW5nIGF0IHRoYXQgcG9zaXRpb24uXFxuV2l0aCBvcHRpb25hbCBlbmQsIHN0b3AgY29tcGFyaW5nIFMgYXQgdGhhdCBwb3NpdGlvbi5cXG5zdWZmaXggY2FuIGFsc28gYmUgYSB0dXBsZSBvZiBzdHJpbmdzIHRvIHRyeS5cIn0saXNhc2NpaTp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCgvXltcXHgwMC1cXHg3Rl0qJC8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLFxuJGRvYzpcIlJldHVybiBUcnVlIGlmIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIEFTQ0lJLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQVNDSUkgY2hhcmFjdGVycyBoYXZlIGNvZGUgcG9pbnRzIGluIHRoZSByYW5nZSBVKzAwMDAtVSswMDdGLlxcbkVtcHR5IHN0cmluZyBpcyBBU0NJSSB0b28uXCJ9LGlzbG93ZXI6eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2wodGhpcy52Lmxlbmd0aCYmL1thLXpdLy50ZXN0KHRoaXMudikmJiEvW0EtWl0vLnRlc3QodGhpcy52KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIGxvd2VyY2FzZSBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyBsb3dlcmNhc2UgaWYgYWxsIGNhc2VkIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcmUgbG93ZXJjYXNlIGFuZFxcbnRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjYXNlZCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0sXG5pc3VwcGVyOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudi5sZW5ndGgmJiEvW2Etel0vLnRlc3QodGhpcy52KSYmL1tBLVpdLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYW4gdXBwZXJjYXNlIHN0cmluZywgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkEgc3RyaW5nIGlzIHVwcGVyY2FzZSBpZiBhbGwgY2FzZWQgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSB1cHBlcmNhc2UgYW5kXFxudGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNhc2VkIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxpc3RpdGxlOnskbWV0aDpmdW5jdGlvbigpe2NvbnN0IHI9dGhpcy52O2xldCB0PSExLHg9ITEsdjtmb3IobGV0IEI9MDtCPHIubGVuZ3RoO0IrKylpZih2PXIuY2hhckF0KEIpLCEvW2Etel0vLnRlc3QodikmJi9bQS1aXS8udGVzdCh2KSl7aWYoeClyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtcbnQ9eD0hMH1lbHNlIGlmKC9bYS16XS8udGVzdCh2KSYmIS9bQS1aXS8udGVzdCh2KSl7aWYoIXgpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7dD0hMH1lbHNlIHg9ITE7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2wodCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHRpdGxlLWNhc2VkIHN0cmluZywgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkluIGEgdGl0bGUtY2FzZWQgc3RyaW5nLCB1cHBlci0gYW5kIHRpdGxlLWNhc2UgY2hhcmFjdGVycyBtYXkgb25seVxcbmZvbGxvdyB1bmNhc2VkIGNoYXJhY3RlcnMgYW5kIGxvd2VyY2FzZSBjaGFyYWN0ZXJzIG9ubHkgY2FzZWQgb25lcy5cIn0saXNzcGFjZTp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCgvXlxccyskLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsXG4kZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHdoaXRlc3BhY2Ugc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgd2hpdGVzcGFjZSBpZiBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSB3aGl0ZXNwYWNlIGFuZCB0aGVyZVxcbmlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0saXNkaWdpdDp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCgvXlxcZCskLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBkaWdpdCBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyBhIGRpZ2l0IHN0cmluZyBpZiBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSBkaWdpdHMgYW5kIHRoZXJlXFxuaXMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxcbmlzbnVtZXJpYzp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0aGlzLnYubGVuZ3RoJiYhL1teMC05XS8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgbnVtZXJpYyBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyBudW1lcmljIGlmIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIG51bWVyaWMgYW5kIHRoZXJlIGlzIGF0XFxubGVhc3Qgb25lIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxpc2FscGhhOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudi5sZW5ndGgmJiEvW15hLXpBLVpdLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYW4gYWxwaGFiZXRpYyBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyBhbHBoYWJldGljIGlmIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIGFscGhhYmV0aWMgYW5kIHRoZXJlXFxuaXMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxcbmlzYWxudW06eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2wodGhpcy52Lmxlbmd0aCYmIS9bXmEtekEtWjAtOV0vLnRlc3QodGhpcy52KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIHN0cmluZyBpcyBhbiBhbHBoYS1udW1lcmljIHN0cmluZywgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkEgc3RyaW5nIGlzIGFscGhhLW51bWVyaWMgaWYgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcmUgYWxwaGEtbnVtZXJpYyBhbmRcXG50aGVyZSBpcyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuXCJ9LGlzaWRlbnRpZmllcjp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kaXNJZGVudGlmaWVyKCk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOidSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgUHl0aG9uIGlkZW50aWZpZXIsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5Vc2Uga2V5d29yZC5pc2tleXdvcmQoKSB0byB0ZXN0IGZvciByZXNlcnZlZCBpZGVudGlmaWVycyBzdWNoIGFzIFwiZGVmXCIgYW5kXFxuXCJjbGFzc1wiLid9LFxuemZpbGw6eyRtZXRoOmZ1bmN0aW9uKHIpe3I9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHIsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtsZXQgdD1cIlwiO3ItPXRoaXMudi5sZW5ndGg7Y29uc3QgeD1cIitcIj09PXRoaXMudlswXXx8XCItXCI9PT10aGlzLnZbMF0/MTowO2ZvcihsZXQgdj0wO3Y8cjt2KyspdCs9XCIwXCI7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc3Vic3RyKDAseCkrdCt0aGlzLnYuc3Vic3RyKHgpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCB3aWR0aCwgLylcIiwkZG9jOlwiUGFkIGEgbnVtZXJpYyBzdHJpbmcgd2l0aCB6ZXJvcyBvbiB0aGUgbGVmdCwgdG8gZmlsbCBhIGZpZWxkIG9mIHRoZSBnaXZlbiB3aWR0aC5cXG5cXG5UaGUgc3RyaW5nIGlzIG5ldmVyIHRydW5jYXRlZC5cIn0sZm9ybWF0OnskbWV0aDpTay5mb3JtYXR0aW5nLmZvcm1hdCwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLmZvcm1hdCgqYXJncywgKiprd2FyZ3MpIC0+IHN0clxcblxcblJldHVybiBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIFMsIHVzaW5nIHN1YnN0aXR1dGlvbnMgZnJvbSBhcmdzIGFuZCBrd2FyZ3MuXFxuVGhlIHN1YnN0aXR1dGlvbnMgYXJlIGlkZW50aWZpZWQgYnkgYnJhY2VzICgneycgYW5kICd9JykuXCJ9LFxuX19mb3JtYXRfXzp7JG1ldGg6U2suZm9ybWF0dGluZy5mb3JtYXRTdHJpbmcsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBmb3JtYXRfc3BlYywgLylcIiwkZG9jOlwiUmV0dXJuIGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIHN0cmluZyBhcyBkZXNjcmliZWQgYnkgZm9ybWF0X3NwZWMuXCJ9LF9fZ2V0bmV3YXJnc19fOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6bnVsbH19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5zdHJcIixTay5idWlsdGluLnN0cik7dmFyIGs9L15bQS1aYS16MC05XSskLyx1PS8oWy4qKz89fFxcXFxcXC8oKVxcW1xcXVxce1xcfV4kXSkvZyxsPS9eW1xcc1xceGEwXSsvO1NrLmJ1aWx0aW4uc3RyLiRweTJkZWNvZGU9bmV3IFNrLmJ1aWx0aW4ubWV0aG9kX2Rlc2NyaXB0b3IoU2suYnVpbHRpbi5zdHIseyRuYW1lOlwiZGVjb2RlXCIsXG4kbWV0aChyLHQpe2NvbnN0IHg9bmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52KTtyZXR1cm4gU2suYnVpbHRpbi5ieXRlcy4kZGVjb2RlLmNhbGwoeCxyLHQpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJlbmNvZGluZ1wiLFwiZXJyb3JzXCJdfX0pO3ZhciBxPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcInN0cl9pdGVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihyKXt0aGlzLiRpbmRleD0wO3IuJGhhc0FzdHJhbENvZGVQb2ludHMoKT8odGhpcy4kc2VxPXIuY29kZXBvaW50cyx0aGlzLnRwJGl0ZXJuZXh0PSgpPT57Y29uc3QgdD10aGlzLiRzZXFbdGhpcy4kaW5kZXhdO2lmKHZvaWQgMCE9PXQpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihyLnYuc3Vic3RyaW5nKHQsdGhpcy4kc2VxWysrdGhpcy4kaW5kZXhdKSl9KToodGhpcy4kc2VxPXIudix0aGlzLnRwJGl0ZXJuZXh0PSgpPT57Y29uc3QgdD10aGlzLiRzZXFbdGhpcy4kaW5kZXgrK107aWYodm9pZCAwIT09dClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHQpfSl9LFxuaXRlcm5leHQoKXtyZXR1cm4gdGhpcy50cCRpdGVybmV4dCgpfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSksej17YWJzdHJhY3Q6ITAsYXM6ITAsYm9vbGVhbjohMCxicmVhazohMCxieXRlOiEwLGNhc2U6ITAsY2F0Y2g6ITAsY2hhcjohMCxjbGFzczohMCxjb250aW51ZTohMCxjb25zdDohMCxkZWJ1Z2dlcjohMCxkZWZhdWx0OiEwLGRlbGV0ZTohMCxkbzohMCxkb3VibGU6ITAsZWxzZTohMCxlbnVtOiEwLGV4cG9ydDohMCxleHRlbmRzOiEwLGZhbHNlOiEwLGZpbmFsOiEwLGZpbmFsbHk6ITAsZmxvYXQ6ITAsZm9yOiEwLGZ1bmN0aW9uOiEwLGdvdG86ITAsaWY6ITAsaW1wbGVtZW50czohMCxpbXBvcnQ6ITAsaW46ITAsaW5zdGFuY2VvZjohMCxpbnQ6ITAsaW50ZXJmYWNlOiEwLGlzOiEwLGxvbmc6ITAsbmFtZXNwYWNlOiEwLG5hdGl2ZTohMCxcbm5ldzohMCxudWxsOiEwLHBhY2thZ2U6ITAscHJpdmF0ZTohMCxwcm90ZWN0ZWQ6ITAscHVibGljOiEwLHJldHVybjohMCxzaG9ydDohMCxzdGF0aWM6ITAsc3VwZXI6ITAsc3dpdGNoOiEwLHN5bmNocm9uaXplZDohMCx0aGlzOiEwLHRocm93OiEwLHRocm93czohMCx0cmFuc2llbnQ6ITAsdHJ1ZTohMCx0cnk6ITAsdHlwZW9mOiEwLHVzZTohMCx2YXI6ITAsdm9pZDohMCx2b2xhdGlsZTohMCx3aGlsZTohMCx3aXRoOiEwLGNvbnN0cnVjdG9yOiEwLF9fZGVmaW5lR2V0dGVyX186ITAsX19kZWZpbmVTZXR0ZXJfXzohMCxhcHBseTohMCxhcmd1bWVudHM6ITAsY2FsbDohMCxjYWxsZXI6ITAsZXZhbDohMCxoYXNPd25Qcm9wZXJ0eTohMCxpc1Byb3RvdHlwZU9mOiEwLF9fbG9va3VwR2V0dGVyX186ITAsX19sb29rdXBTZXR0ZXJfXzohMCxfX25vU3VjaE1ldGhvZF9fOiEwLHByb3BlcnR5SXNFbnVtZXJhYmxlOiEwLHByb3RvdHlwZTohMCx0b1NvdXJjZTohMCx0b0xvY2FsZVN0cmluZzohMCxcbnRvU3RyaW5nOiEwLHVud2F0Y2g6ITAsdmFsdWVPZjohMCx3YXRjaDohMCxsZW5ndGg6ITAsbmFtZTohMH07U2suYnVpbHRpbi5zdHIucmVzZXJ2ZWRXb3Jkc189ejtTay5idWlsdGluLnN0ci4kZml4UmVzZXJ2ZWQ9Y30sZnVuY3Rpb24oRixQKXtTay5idWlsdGluLmZ1bmM9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImZ1bmN0aW9uXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZSxkLGYpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmZ1bmMsXCJidWlsdGluIGZ1bmMgc2hvdWxkIGJlIGNhbGxlZCBhcyBhIGNsYXNzIHdpdGggYG5ld2BcIik7dGhpcy5mdW5jX2NvZGU9Yjt0aGlzLmZ1bmNfZ2xvYmFscz1lfHxudWxsO3RoaXMuJG5hbWU9Yi5jb19uYW1lJiZiLmNvX25hbWUudnx8Yi5uYW1lfHxcIjxuYXRpdmUgSlM+XCI7dGhpcy4kZD1Tay5idWlsdGluLmRpY3Q/bmV3IFNrLmJ1aWx0aW4uZGljdDp2b2lkIDA7dGhpcy4kZG9jPWIuY29fZG9jc3RyaW5nfHxcblNrLmJ1aWx0aW4ubm9uZS5ub25lJDt0aGlzLiRtb2R1bGU9U2suZ2xvYmFscyYmU2suZ2xvYmFscy5fX25hbWVfX3x8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMuJHF1YWxuYW1lPWIuY29fcXVhbG5hbWUmJmIuY29fcXVhbG5hbWUudnx8dGhpcy4kbmFtZTtpZih2b2lkIDAhPT1mKWZvcihsZXQgaCBpbiBmKWRbaF09ZltoXTt0aGlzLmZ1bmNfY2xvc3VyZT1kO3RoaXMuZnVuY19hbm5vdGF0aW9ucz1udWxsO3RoaXMuJG1lbW9pc2VGbGFncygpO3RoaXMubWVtb2lzZWQ9Yi5jb19mYXN0Y2FsbHx8bnVsbDt0aGlzLnRwJGNhbGw9Yi5jb19mYXN0Y2FsbD9iLmJpbmQodGhpcyk6U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRjYWxsLmJpbmQodGhpcyl9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRkZXNjcl9nZXQoYixlKXtyZXR1cm4gbnVsbD09PWI/dGhpczpuZXcgU2suYnVpbHRpbi5tZXRob2QodGhpcyxiKX0sJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGZ1bmN0aW9uIFwiK1xudGhpcy4kcXVhbG5hbWUrXCI+XCIpfSx0cCRjYWxsKGIsZSl7dGhpcy5tZW1vaXNlZHx8KHRoaXMuJG1lbW9pc2VGbGFncygpLHRoaXMubWVtb2lzZWQ9ITApO2lmKHZvaWQgMD09PXRoaXMuY29fYXJnY291bnQmJnZvaWQgMD09PXRoaXMuY29fdmFybmFtZXMmJiF0aGlzLmNvX2t3YXJncyYmIXRoaXMuZnVuY19jbG9zdXJlKXtpZihlJiYwIT09ZS5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHRoaXMuJG5hbWUrXCIoKSB0YWtlcyBubyBrZXl3b3JkIGFyZ3VtZW50c1wiKTtyZXR1cm4gdGhpcy5mdW5jX2NvZGUuYXBwbHkodGhpcy5mdW5jX2dsb2JhbHMsYil9Yj10aGlzLiRyZXNvbHZlQXJncyhiLGUpO3RoaXMuZnVuY19jbG9zdXJlJiZiLnB1c2godGhpcy5mdW5jX2Nsb3N1cmUpO3JldHVybiB0aGlzLmZ1bmNfY29kZS5hcHBseSh0aGlzLmZ1bmNfZ2xvYmFscyxiKX19LGdldHNldHM6e19fbmFtZV9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLiRuYW1lKX0sXG4kc2V0KGIpe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fbmFtZV9fIG11c3QgYmUgc2V0IHRvIGEgc3RyaW5nIG9iamVjdFwiKTt0aGlzLiRuYW1lPWIuJGpzc3RyKCl9fSxfX3F1YWxuYW1lX186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJHF1YWxuYW1lKX0sJHNldChiKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX3F1YWxuYW1lX18gbXVzdCBiZSBzZXQgdG8gYSBzdHJpbmcgb2JqZWN0XCIpO3RoaXMuJHF1YWxuYW1lPWIuJGpzc3RyKCl9fSxfX2RpY3RfXzpTay5nZW5lcmljLmdldFNldERpY3QsX19hbm5vdGF0aW9uc19fOnskZ2V0KCl7bnVsbD09PXRoaXMuZnVuY19hbm5vdGF0aW9ucz90aGlzLmZ1bmNfYW5ub3RhdGlvbnM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk6QXJyYXkuaXNBcnJheSh0aGlzLmZ1bmNfYW5ub3RhdGlvbnMpJiZcbih0aGlzLmZ1bmNfYW5ub3RhdGlvbnM9U2suYWJzdHIua2V5d29yZEFycmF5VG9QeURpY3QodGhpcy5mdW5jX2Fubm90YXRpb25zKSk7cmV0dXJuIHRoaXMuZnVuY19hbm5vdGF0aW9uc30sJHNldChiKXtpZih2b2lkIDA9PT1ifHxTay5idWlsdGluLmNoZWNrTm9uZShiKSl0aGlzLmZ1bmNfYW5ub3RhdGlvbnM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7ZWxzZSBpZihiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXRoaXMuZnVuY19hbm5vdGF0aW9ucz1iO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19hbm5vdGF0aW9uc19fIG11c3QgYmUgc2V0IHRvIGEgZGljdCBvYmplY3RcIik7fX0sX19kZWZhdWx0c19fOnskZ2V0KCl7cmV0dXJuIG51bGw9PXRoaXMuJGRlZmF1bHRzP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpuZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLiRkZWZhdWx0cyl9LCRzZXQoYil7aWYodm9pZCAwPT09Ynx8U2suYnVpbHRpbi5jaGVja05vbmUoYikpdGhpcy4kZGVmYXVsdHM9XG5udWxsO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpdGhpcy4kZGVmYXVsdHM9Yi52YWx1ZU9mKCk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2RlZmF1bHRzX18gbXVzdCBiZSBzZXQgdG8gYSB0dXBsZSBvYmplY3RcIik7fX0sX19kb2NfXzp7JGdldCgpe3JldHVybiB0aGlzLiRkb2N9LCRzZXQoYil7dGhpcy4kZG9jPWJ8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LF9fbW9kdWxlX186eyRnZXQoKXtyZXR1cm4gdGhpcy4kbW9kdWxlfSwkc2V0KGIpe3RoaXMuJG1vZHVsZT1ifHxTay5idWlsdGluLm5vbmUubm9uZSR9fX0scHJvdG86eyRtZW1vaXNlRmxhZ3MoKXt0aGlzLmNvX3Zhcm5hbWVzPXRoaXMuZnVuY19jb2RlLmNvX3Zhcm5hbWVzO3RoaXMuY29fYXJnY291bnQ9dGhpcy5mdW5jX2NvZGUuY29fYXJnY291bnQ7dm9pZCAwPT09dGhpcy5jb19hcmdjb3VudCYmdGhpcy5jb192YXJuYW1lcyYmKHRoaXMuY29fYXJnY291bnQ9dGhpcy5jb192YXJuYW1lcy5sZW5ndGgpO1xudGhpcy5jb19rd29ubHlhcmdjb3VudD10aGlzLmZ1bmNfY29kZS5jb19rd29ubHlhcmdjb3VudHx8MDt0aGlzLmNvX3ZhcmFyZ3M9dGhpcy5mdW5jX2NvZGUuY29fdmFyYXJnczt0aGlzLmNvX2t3YXJncz10aGlzLmZ1bmNfY29kZS5jb19rd2FyZ3M7dGhpcy4kZGVmYXVsdHM9dGhpcy5mdW5jX2NvZGUuJGRlZmF1bHRzO3RoaXMuJGt3ZGVmcz10aGlzLmZ1bmNfY29kZS4ka3dkZWZzfHxbXX0sJHJlc29sdmVBcmdzOmZ1bmN0aW9uKGIsZSl7dmFyIGQ9dGhpcy5jb19hcmdjb3VudDt2b2lkIDA9PT1kJiYoZD10aGlzLmNvX3Zhcm5hbWVzP3RoaXMuY29fdmFybmFtZXMubGVuZ3RoOmIubGVuZ3RoKTt2YXIgZj10aGlzLmNvX3Zhcm5hbWVzfHxbXSxoPXRoaXMuY29fa3dvbmx5YXJnY291bnR8fDA7bGV0IHA9ZCtoO2lmKCEoMCE9PWh8fHRoaXMuY29fa3dhcmdzfHxlJiYwIT09ZS5sZW5ndGh8fHRoaXMuY29fdmFyYXJncykpe2lmKGIubGVuZ3RoPT1kKXJldHVybiBiO2lmKDA9PT1iLmxlbmd0aCYmXG50aGlzLiRkZWZhdWx0cyYmdGhpcy4kZGVmYXVsdHMubGVuZ3RoPT09ZCl7Zm9yKGY9MDtmIT10aGlzLiRkZWZhdWx0cy5sZW5ndGg7ZisrKWJbZl09dGhpcy4kZGVmYXVsdHNbZl07cmV0dXJuIGJ9fWxldCBnO3RoaXMuY29fa3dhcmdzJiYoZz1bXSk7dmFyIGE9Yi5sZW5ndGg7bGV0IGM9Yi5sZW5ndGg8PWQ/YjpiLnNsaWNlKDAsZCk7aWYodGhpcy5jb192YXJhcmdzKWI9Yi5sZW5ndGg+Yy5sZW5ndGg/Yi5zbGljZShjLmxlbmd0aCk6W10sY1twXT1uZXcgU2suYnVpbHRpbi50dXBsZShiKTtlbHNlIGlmKGE+ZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYCR7dGhpcy4kbmFtZX1cIigpIHRha2VzICR7ZH0gcG9zaXRpb25hbCAkezE9PWQ/XCJhcmd1bWVudFwiOlwiYXJndW1lbnRzXCJ9IGJ1dCAke2F9ICR7MT09YT9cIndhc1wiOlwid2VyZVwifSBnaXZlbmApO2lmKGUpe2lmKHRoaXMuZnVuY19jb2RlLm5vX2t3KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1xuXCIoKSB0YWtlcyBubyBrZXl3b3JkIGFyZ3VtZW50c1wiKTtmb3IoYj0wO2I8ZS5sZW5ndGg7Yis9Mil7YT1lW2JdO3ZhciBuPWVbYisxXSxtPWYuaW5kZXhPZihhKTtpZigwPD1tKXtpZih2b2lkIDAhPT1jW21dKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgZ290IG11bHRpcGxlIHZhbHVlcyBmb3IgYXJndW1lbnQgJ1wiK2ErXCInXCIpO2NbbV09bn1lbHNlIGlmKGcpZy5wdXNoKG5ldyBTay5idWlsdGluLnN0cihhKSxuKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgZ290IGFuIHVuZXhwZWN0ZWQga2V5d29yZCBhcmd1bWVudCAnXCIrYStcIidcIik7fX1lPXRoaXMuJGRlZmF1bHRzfHxbXTtiPTA7YT1bXTtuPSExO2ZvcihtPWQtZS5sZW5ndGg7YjxtO2IrKyl2b2lkIDA9PT1jW2JdJiYoYS5wdXNoKGZbYl0pLHZvaWQgMD09PWZbYl0mJihuPSEwKSk7aWYoMCE9YS5sZW5ndGgmJih0aGlzLmNvX2FyZ2NvdW50fHxcbnRoaXMuY29fdmFybmFtZXMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgbWlzc2luZyBcIithLmxlbmd0aCtcIiByZXF1aXJlZCBhcmd1bWVudFwiKygxPT1hLmxlbmd0aD9cIlwiOlwic1wiKSsobj9cIlwiOlwiOiBcIithLm1hcChrPT5cIidcIitrK1wiJ1wiKS5qb2luKFwiLCBcIikpKTtmb3IoO2I8ZDtiKyspdm9pZCAwPT09Y1tiXSYmKGNbYl09ZVtiLW1dKTtpZigwPGgpe2g9W107ZT10aGlzLiRrd2RlZnM7Zm9yKGI9ZDtiPHA7YisrKXZvaWQgMD09PWNbYl0mJih2b2lkIDAhPT1lW2ItZF0/Y1tiXT1lW2ItZF06aC5wdXNoKGZbYl0pKTtpZigwIT09aC5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHRoaXMuJG5hbWUrXCIoKSBtaXNzaW5nIFwiK2gubGVuZ3RoK1wiIHJlcXVpcmVkIGtleXdvcmQgYXJndW1lbnRcIisoMT09aC5sZW5ndGg/XCJcIjpcInNcIikrXCI6IFwiK2guam9pbihcIiwgXCIpKTt9aWYodGhpcy5mdW5jX2Nsb3N1cmUmJmYpZm9yKGQ9Yy5sZW5ndGg7ZDxcbmYubGVuZ3RoO2QrKyljLnB1c2godm9pZCAwKTtnJiZjLnVuc2hpZnQoZyk7cmV0dXJuIGN9fX0pfSxmdW5jdGlvbihGLFApe1NrLmJ1aWx0aW4uYXNudW0kPWZ1bmN0aW9uKGYpe3JldHVybiB2b2lkIDA9PT1mfHxudWxsPT09Znx8XCJudW1iZXJcIj09PXR5cGVvZiBmP2Y6ZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50Xz9cIm51bWJlclwiPT09dHlwZW9mIGYudj9mLnY6Zi52LnRvU3RyaW5nKCk6ZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfP2YudjpmPT09U2suYnVpbHRpbi5ub25lLm5vbmUkP251bGw6Zn07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5hc251bSRcIixTay5idWlsdGluLmFzbnVtJCk7U2suYnVpbHRpbi5hc3NrJD1mdW5jdGlvbihmKXtyZXR1cm4gMD09PWYlMT9uZXcgU2suYnVpbHRpbi5pbnRfKGYpOm5ldyBTay5idWlsdGluLmZsb2F0XyhmKX07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5hc3NrJFwiLFNrLmJ1aWx0aW4uYXNzayQpO1NrLmJ1aWx0aW4uYXNudW0kbm9mbG9hdD1cbmZ1bmN0aW9uKGYpe2lmKHZvaWQgMD09PWZ8fG51bGw9PT1mKXJldHVybiBmO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZilmPWYudG9TdHJpbmcoKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pZj1mLnYudG9TdHJpbmcoKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XylmPWYudi50b1N0cmluZygpO2Vsc2V7aWYoZj09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJClyZXR1cm4gbnVsbDtyZXR1cm59aWYoMD5mLmluZGV4T2YoXCIuXCIpJiYwPmYuaW5kZXhPZihcImVcIikmJjA+Zi5pbmRleE9mKFwiRVwiKSlyZXR1cm4gZjt2YXIgaD0wO2lmKDA8PWYuaW5kZXhPZihcImVcIikpe3ZhciBwPWYuc3Vic3RyKDAsZi5pbmRleE9mKFwiZVwiKSk7aD1mLnN1YnN0cihmLmluZGV4T2YoXCJlXCIpKzEpfWVsc2UgMDw9Zi5pbmRleE9mKFwiRVwiKT8ocD1mLnN1YnN0cigwLGYuaW5kZXhPZihcImVcIikpLGg9Zi5zdWJzdHIoZi5pbmRleE9mKFwiRVwiKSsxKSk6cD1mO2g9cGFyc2VJbnQoaCxcbjEwKTtmPXAuaW5kZXhPZihcIi5cIik7aWYoMD5mKXtpZigwPD1oKXtmb3IoOzA8aC0tOylwKz1cIjBcIjtyZXR1cm4gcH1yZXR1cm4gcC5sZW5ndGg+LWg/cC5zdWJzdHIoMCxwLmxlbmd0aCtoKTowfXA9MD09PWY/cC5zdWJzdHIoMSk6ZjxwLmxlbmd0aD9wLnN1YnN0cigwLGYpK3Auc3Vic3RyKGYrMSk6cC5zdWJzdHIoMCxmKTtmb3IoZis9aDtmPnAubGVuZ3RoOylwKz1cIjBcIjtyZXR1cm4gcD0wPj1mPzA6cC5zdWJzdHIoMCxmKX07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5hc251bSRub2Zsb2F0XCIsU2suYnVpbHRpbi5hc251bSRub2Zsb2F0KTtTay5idWlsdGluLnJvdW5kPWZ1bmN0aW9uKGYsaCl7aWYodm9pZCAwPT09Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIGZsb2F0IGlzIHJlcXVpcmVkXCIpO2lmKCFTay5fX2Z1dHVyZV9fLmR1bmRlcl9yb3VuZCl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYSBmbG9hdCBpcyByZXF1aXJlZFwiKTtcbmlmKGYucm91bmQkKXJldHVybiBmLnJvdW5kJChoKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihTay5hYnN0ci50eXBlTmFtZShmKStcIiBpbnN0YW5jZSBoYXMgbm8gYXR0cmlidXRlICdfX2Zsb2F0X18nXCIpO31pZih2b2lkIDAhPT1oJiYhU2suYnVpbHRpbi5jaGVja05vbmUoaCkmJiFTay5taXNjZXZhbC5pc0luZGV4KGgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShoKStcIicgb2JqZWN0IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpbmRleFwiKTtmPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoZixTay5idWlsdGluLnN0ci4kcm91bmQpO2lmKHZvaWQgMCE9PWYpcmV0dXJuIHZvaWQgMCE9PWg/U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGYsW2hdKTpTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZixbXSk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYSBmbG9hdCBpcyByZXF1aXJlZFwiKTt9O1NrLmJ1aWx0aW4ubGVuPVxuZnVuY3Rpb24oZil7aWYoZi5zcSRsZW5ndGgpZj1mLnNxJGxlbmd0aCghMCk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvYmplY3Qgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCInIGhhcyBubyBsZW4oKVwiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZixoPT5uZXcgU2suYnVpbHRpbi5pbnRfKGgpKX07U2suYnVpbHRpbi5taW49ZnVuY3Rpb24oZixoKXtsZXQgcDtjb25zdCBnPWYubGVuZ3RoO2lmKCFnKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm1pbiBleHBlY3RlZCAxIGFyZ3VtZW50LCBnb3QgMFwiKTtjb25zdCBbYSxjXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcIm1pblwiLFtcImRlZmF1bHRcIixcImtleVwiXSxbXSxoLFtudWxsLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0pO2lmKDE8ZyYmbnVsbCE9PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgYSBkZWZhdWx0IGZvciBtaW4oKSB3aXRoIG11bHRpcGxlIHBvc2l0aW9uYWwgYXJndW1lbnRzXCIpO1xucD0xPT1nP1NrLmFic3RyLml0ZXIoZlswXSk6U2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi50dXBsZShmKSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGMpJiYhU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShjKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTtsZXQgbjtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4ocC50cCRpdGVybmV4dCghMCksbT0+e249bTtpZih2b2lkIDAhPT1uKXJldHVybiBTay5idWlsdGluLmNoZWNrTm9uZShjKT9Tay5taXNjZXZhbC5pdGVyRm9yKHAsaz0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChrLG4sXCJMdFwiKSYmKG49ayl9KTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxbbl0pLGs9PlNrLm1pc2NldmFsLml0ZXJGb3IocCx1PT5Tay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxcblt1XSksbD0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChsLGssXCJMdFwiKSYmKG49dSxrPWwpfSkpKX0sKCk9PntpZih2b2lkIDA9PT1uKXtpZihudWxsPT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibWluKCkgYXJnIGlzIGFuIGVtcHR5IHNlcXVlbmNlXCIpO249YX1yZXR1cm4gbn0pfTtTay5idWlsdGluLm1heD1mdW5jdGlvbihmLGgpe2xldCBwO2NvbnN0IGc9Zi5sZW5ndGg7aWYoIWcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibWF4IGV4cGVjdGVkIDEgYXJndW1lbnQsIGdvdCAwXCIpO2NvbnN0IFthLGNdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwibWF4XCIsW1wiZGVmYXVsdFwiLFwia2V5XCJdLFtdLGgsW251bGwsU2suYnVpbHRpbi5ub25lLm5vbmUkXSk7aWYoMTxnJiZudWxsIT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBhIGRlZmF1bHQgZm9yIG1heCgpIHdpdGggbXVsdGlwbGUgcG9zaXRpb25hbCBhcmd1bWVudHNcIik7XG5wPTE9PT1nP1NrLmFic3RyLml0ZXIoZlswXSk6U2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi50dXBsZShmKSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGMpJiYhU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShjKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTtsZXQgbjtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4ocC50cCRpdGVybmV4dCghMCksbT0+e249bTtpZih2b2lkIDAhPT1uKXJldHVybiBTay5idWlsdGluLmNoZWNrTm9uZShjKT9Tay5taXNjZXZhbC5pdGVyRm9yKHAsaz0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChrLG4sXCJHdFwiKSYmKG49ayl9KTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxbbl0pLGs9PlNrLm1pc2NldmFsLml0ZXJGb3IocCx1PT5Tay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxcblt1XSksbD0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChsLGssXCJHdFwiKSYmKG49dSxrPWwpfSkpKX0sKCk9PntpZih2b2lkIDA9PT1uKXtpZihudWxsPT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibWF4KCkgYXJnIGlzIGFuIGVtcHR5IHNlcXVlbmNlXCIpO249YX1yZXR1cm4gbn0pfTtTay5idWlsdGluLm1pbi5jb19mYXN0Y2FsbD1Tay5idWlsdGluLm1heC5jb19mYXN0Y2FsbD0xO1NrLmJ1aWx0aW4uYW55PWZ1bmN0aW9uKGYpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoZiksZnVuY3Rpb24oaCl7aWYoU2subWlzY2V2YWwuaXNUcnVlKGgpKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoU2suYnVpbHRpbi5ib29sLnRydWUkKX0pLGg9Pmh8fFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQpfTtTay5idWlsdGluLmFsbD1mdW5jdGlvbihmKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGYpLFxuZnVuY3Rpb24oaCl7aWYoIVNrLm1pc2NldmFsLmlzVHJ1ZShoKSlyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrKFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQpfSksaD0+aHx8U2suYnVpbHRpbi5ib29sLnRydWUkKX07U2suYnVpbHRpbi5zdW09ZnVuY3Rpb24oZixoKXtmdW5jdGlvbiBwKCl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoYyxtPT57aWYobS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uaW50XyluPW4ubmIkYWRkKG0pO2Vsc2V7aWYobS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZmxvYXRfKXJldHVybiBuPW4ubmIkZmxvYXQoKS5uYiRhZGQobSksbmV3IFNrLm1pc2NldmFsLkJyZWFrKFwiZmxvYXRcIik7bj1Tay5hYnN0ci5udW1iZXJCaW5PcChuLG0sXCJBZGRcIik7cmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayhcInNsb3dcIil9fSl9ZnVuY3Rpb24gZygpe3JldHVybiBTay5taXNjZXZhbC5pdGVyRm9yKGMsbT0+e2lmKG0uY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmZsb2F0X3x8XG5tLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5pbnRfKW49bi5uYiRhZGQobSk7ZWxzZSByZXR1cm4gbj1Tay5hYnN0ci5udW1iZXJCaW5PcChuLG0sXCJBZGRcIiksbmV3IFNrLm1pc2NldmFsLkJyZWFrKFwic2xvd1wiKX0pfWZ1bmN0aW9uIGEoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihjLG09PntuPVNrLmFic3RyLm51bWJlckJpbk9wKG4sbSxcIkFkZFwiKX0pfWNvbnN0IGM9U2suYWJzdHIuaXRlcihmKTtpZih2b2lkIDA9PT1oKXZhciBuPW5ldyBTay5idWlsdGluLmludF8oMCk7ZWxzZXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN1bSgpIGNhbid0IHN1bSBzdHJpbmdzIFt1c2UgJycuam9pbihzZXEpIGluc3RlYWRdXCIpO249aH1mPXZvaWQgMD09PWh8fGguY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmludF8/cCgpOmguY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmZsb2F0Xz9cImZsb2F0XCI6XCJzbG93XCI7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGYsXG5tPT5cImZsb2F0XCI9PT1tP2coKTptLG09PntpZihcInNsb3dcIj09PW0pcmV0dXJuIGEoKX0sKCk9Pm4pfTtTay5idWlsdGluLnppcD1mdW5jdGlvbigpe3ZhciBmLGg7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoW10pO3ZhciBwPVtdO2ZvcihoPTA7aDxhcmd1bWVudHMubGVuZ3RoO2grKylpZihTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYXJndW1lbnRzW2hdKSlwLnB1c2goU2suYWJzdHIuaXRlcihhcmd1bWVudHNbaF0pKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFyZ3VtZW50IFwiK2grXCIgbXVzdCBzdXBwb3J0IGl0ZXJhdGlvblwiKTt2YXIgZz1bXTtmb3IoZj0hMTshZjspe3ZhciBhPVtdO2ZvcihoPTA7aDxhcmd1bWVudHMubGVuZ3RoO2grKyl7dmFyIGM9cFtoXS50cCRpdGVybmV4dCgpO2lmKHZvaWQgMD09PWMpe2Y9ITA7YnJlYWt9YS5wdXNoKGMpfWZ8fGcucHVzaChuZXcgU2suYnVpbHRpbi50dXBsZShhKSl9cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoZyl9O1xuU2suYnVpbHRpbi5hYnM9ZnVuY3Rpb24oZil7aWYoZi5uYiRhYnMpcmV0dXJuIGYubmIkYWJzKCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFkIG9wZXJhbmQgdHlwZSBmb3IgYWJzKCk6ICdcIitTay5hYnN0ci50eXBlTmFtZShmKStcIidcIik7fTtTay5idWlsdGluLmZhYnM9ZnVuY3Rpb24oZil7cmV0dXJuIFNrLmJ1aWx0aW4uYWJzKGYpfTtTay5idWlsdGluLm9yZD1mdW5jdGlvbihmKXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGYpKXtpZigxIT09Zi52Lmxlbmd0aCYmMSE9PWYuc3EkbGVuZ3RoKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwib3JkKCkgZXhwZWN0ZWQgYSBjaGFyYWN0ZXIsIGJ1dCBzdHJpbmcgb2YgbGVuZ3RoIFwiK2Yudi5sZW5ndGgrXCIgZm91bmRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZi52LmNvZGVQb2ludEF0KDApKX1pZihTay5idWlsdGluLmNoZWNrQnl0ZXMoZikpe2lmKDEhPT1mLnNxJGxlbmd0aCgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm9yZCgpIGV4cGVjdGVkIGEgY2hhcmFjdGVyLCBidXQgc3RyaW5nIG9mIGxlbmd0aCBcIitcbmYudi5sZW5ndGgrXCIgZm91bmRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZi52WzBdKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvcmQoKSBleHBlY3RlZCBhIHN0cmluZyBvZiBsZW5ndGggMSwgYnV0IFwiK1NrLmFic3RyLnR5cGVOYW1lKGYpK1wiIGZvdW5kXCIpO307U2suYnVpbHRpbi5jaHI9ZnVuY3Rpb24oZil7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTtmPVNrLmJ1aWx0aW4uYXNudW0kKGYpO2lmKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl7aWYoMD5mfHwxMTE0MTEyPD1mKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjaHIoKSBhcmcgbm90IGluIHJhbmdlKDB4MTEwMDAwKVwiKTt9ZWxzZSBpZigwPmZ8fDI1Njw9Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY2hyKCkgYXJnIG5vdCBpbiByYW5nZSgyNTYpXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU3RyaW5nLmZyb21Db2RlUG9pbnQoZikpfTtcblNrLmJ1aWx0aW4udW5pY2hyPWZ1bmN0aW9uKGYpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXCJ1bmljaHJcIixhcmd1bWVudHMubGVuZ3RoLDEsMSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTtmPVNrLmJ1aWx0aW4uYXNudW0kKGYpO3RyeXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFN0cmluZy5mcm9tQ29kZVBvaW50KGYpKX1jYXRjaChoKXtpZihoIGluc3RhbmNlb2YgUmFuZ2VFcnJvcil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKGgubWVzc2FnZSk7dGhyb3cgaDt9fTtTay5idWlsdGluLmludDJzdHJfPWZ1bmN0aW9uKGYsaCxwKXtsZXQgZz1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhmKSxhPWcudG9TdHJpbmcoaCk7YT0wPmc/XCItXCIrcCthLnNsaWNlKDEpOnArYTsyIT09aCYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMyYmKGYgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZ3x8XG5KU0JJLl9faXNCaWdJbnQoZykpJiYoYSs9XCJMXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSl9O1NrLmJ1aWx0aW4uaGV4PWZ1bmN0aW9uKGYpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGYpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImhleCgpIGFyZ3VtZW50IGNhbid0IGJlIGNvbnZlcnRlZCB0byBoZXhcIik7cmV0dXJuIFNrLmJ1aWx0aW4uaW50MnN0cl8oZiwxNixcIjB4XCIpfTtTay5idWlsdGluLm9jdD1mdW5jdGlvbihmKXtpZighU2subWlzY2V2YWwuaXNJbmRleChmKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvY3QoKSBhcmd1bWVudCBjYW4ndCBiZSBjb252ZXJ0ZWQgdG8gaGV4XCIpO3JldHVybiBTay5fX2Z1dHVyZV9fLm9jdGFsX251bWJlcl9saXRlcmFsP1NrLmJ1aWx0aW4uaW50MnN0cl8oZiw4LFwiMG9cIik6U2suYnVpbHRpbi5pbnQyc3RyXyhmLDgsXCIwXCIpfTtTay5idWlsdGluLmJpbj1mdW5jdGlvbihmKXtpZighU2subWlzY2V2YWwuaXNJbmRleChmKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrXG5Tay5hYnN0ci50eXBlTmFtZShmKStcIicgb2JqZWN0IGNhbid0IGJlIGludGVycHJldGVkIGFzIGFuIGluZGV4XCIpO3JldHVybiBTay5idWlsdGluLmludDJzdHJfKGYsMixcIjBiXCIpfTtTay5idWlsdGluLmRpcj1mdW5jdGlvbihmKXtpZih2b2lkIDAhPT1mKXJldHVybiBmPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoZixTay5idWlsdGluLnN0ci4kZGlyKSxTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZixbXSksaD0+U2suYnVpbHRpbi5zb3J0ZWQoaCkpO3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJza3VscHQgZG9lcyBub3QgeWV0IHN1cHBvcnQgZGlyIHdpdGggbm8gYXJnc1wiKTt9O1NrLmJ1aWx0aW4ucmVwcj1mdW5jdGlvbihmKXtyZXR1cm4gZi4kcigpfTtTay5idWlsdGluLmFzY2lpPWZ1bmN0aW9uKGYpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihmLiRyKCksaD0+e2xldCBwLGc7Zm9yKGc9MDtnPGgudi5sZW5ndGg7ZysrKWlmKDEyNzw9XG5oLnYuY2hhckNvZGVBdChnKSl7cD1oLnYuc3Vic3RyKDAsZyk7YnJlYWt9aWYoIXApcmV0dXJuIGg7Zm9yKDtnPGgudi5sZW5ndGg7ZysrKXt2YXIgYT1oLnYuY2hhckF0KGcpLGM9aC52LmNoYXJDb2RlQXQoZyk7MTI3PGMmJjI1NT49Yz8oYT1jLnRvU3RyaW5nKDE2KSwyPmEubGVuZ3RoJiYoYT1cIjBcIithKSxwKz1cIlxcXFx4XCIrYSk6MTI3PGMmJjU1Mjk2PmN8fDU3MzQ0PD1jP3ArPVwiXFxcXHVcIisoXCIwMDBcIitjLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpOjU1Mjk2PD1jPyhhPWgudi5jb2RlUG9pbnRBdChnKSxnKyssYT1hLnRvU3RyaW5nKDE2KSxjPVwiMDAwMDAwMFwiK2EudG9TdHJpbmcoMTYpLHA9NDxhLmxlbmd0aD9wKyhcIlxcXFxVXCIrYy5zbGljZSgtOCkpOnArKFwiXFxcXHVcIitjLnNsaWNlKC00KSkpOnArPWF9cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihwKX0pfTtTay5idWlsdGluLm9wZW49ZnVuY3Rpb24oZixoLHApe3ZvaWQgMD09PWgmJihoPW5ldyBTay5idWlsdGluLnN0cihcInJcIikpO2lmKC9cXCsvLnRlc3QoaC52KSl0aHJvd1widG9kbzsgaGF2ZW4ndCBpbXBsZW1lbnRlZCByZWFkL3dyaXRlIG1vZGVcIjtcbmlmKChcIndcIj09PWgudnx8XCJ3YlwiPT09aC52fHxcImFcIj09PWgudnx8XCJhYlwiPT09aC52KSYmIVNrLm5vbnJlYWRvcGVuKXRocm93XCJ0b2RvOyBoYXZlbid0IGltcGxlbWVudGVkIG5vbi1yZWFkIG9wZW5zXCI7cmV0dXJuIG5ldyBTay5idWlsdGluLmZpbGUoZixoLHApfTtTay5idWlsdGluLmlzaW5zdGFuY2U9ZnVuY3Rpb24oZixoKXtpZighKFNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhoKXx8aCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImlzaW5zdGFuY2UoKSBhcmcgMiBtdXN0IGJlIGEgY2xhc3MsIHR5cGUsIG9yIHR1cGxlIG9mIGNsYXNzZXMgYW5kIHR5cGVzXCIpO3ZhciBwPWYub2IkdHlwZTtpZihwPT09aClyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO2lmKCEoaCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKXtpZihwLiRpc1N1YlR5cGUoaCkpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJDtmPWYudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kY2xhc3MpO1xucmV0dXJuIGYhPXAmJlNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhmKSYmZi4kaXNTdWJUeXBlKGgpP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfWZvcihwPTA7cDxoLnYubGVuZ3RoOysrcClpZihTay5taXNjZXZhbC5pc1RydWUoU2suYnVpbHRpbi5pc2luc3RhbmNlKGYsaC52W3BdKSkpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJDtyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJH07U2suYnVpbHRpbi5oYXNoPWZ1bmN0aW9uKGYpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKFNrLmFic3RyLm9iamVjdEhhc2goZikpfTtTay5idWlsdGluLmdldGF0dHI9ZnVuY3Rpb24oZixoLHApe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImF0dHJpYnV0ZSBuYW1lIG11c3QgYmUgc3RyaW5nXCIpO2NvbnN0IGc9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PmYudHAkZ2V0YXR0cihoLCEwKSxcbmE9PntpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBhO30pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihnLGE9PntpZih2b2lkIDA9PT1hKXtpZih2b2lkIDAhPT1wKXJldHVybiBwO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKGYuc2skYXR0ckVycm9yKCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKGgpKTt9cmV0dXJuIGF9KX07U2suYnVpbHRpbi5zZXRhdHRyPWZ1bmN0aW9uKGYsaCxwKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhdHRyaWJ1dGUgbmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZi50cCRzZXRhdHRyKGgscCwhMCksKCk9PlNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9O1NrLmJ1aWx0aW4ucmF3X2lucHV0PWZ1bmN0aW9uKGYpe3ZhciBoPWY/ZjpcIlwiO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRNb2R1bGUoXCJzeXNcIixcbiExLCEwKSxmdW5jdGlvbihwKXtyZXR1cm4gU2suaW5wdXRmdW5UYWtlc1Byb21wdD9Tay5idWlsdGluLmZpbGUuJHJlYWRsaW5lKHAuJGQuc3RkaW4sbnVsbCxoKTpTay5taXNjZXZhbC5jaGFpbih2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHAuJGQuc3Rkb3V0LndyaXRlLFtwLiRkLnN0ZG91dCxuZXcgU2suYnVpbHRpbi5zdHIoaCldKX0sZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHAuJGQuc3RkaW4ucmVhZGxpbmUsW3AuJGQuc3RkaW5dKX0pfSl9O1NrLmJ1aWx0aW4uaW5wdXQ9U2suYnVpbHRpbi5yYXdfaW5wdXQ7U2suYnVpbHRpbi5qc2V2YWw9ZnVuY3Rpb24oZil7Zj1Tay5nbG9iYWwuZXZhbChTay5mZmkucmVtYXBUb0pzKGYpKTtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShmKX07U2suYnVpbHRpbi5qc21pbGxpcz1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcImpzbWlsbGlzIGlzIGRlcHJlY2F0ZWRcIik7XG5yZXR1cm4obmV3IERhdGUpLnZhbHVlT2YoKX07Y29uc3QgYj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiY29kZVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihmLGgpe3RoaXMuY29tcGlsZWQ9aDt0aGlzLmNvZGU9aC5jb2RlO3RoaXMuZmlsZW5hbWU9Zn0sc2xvdHM6e3RwJG5ldyhmLGgpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IGEgY29kZSBvYmplY3QgaW4gc2t1bHB0XCIpO30sJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGNvZGUgb2JqZWN0IDxtb2R1bGU+LCBmaWxlIFwiK3RoaXMuZmlsZW5hbWUrXCI+XCIpfX19KTtTay5idWlsdGluLmNvbXBpbGU9ZnVuY3Rpb24oZixoLHAsZyxhLGMpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJzb3VyY2VcIixcInN0clwiLFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZikpO1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJmaWxlbmFtZVwiLFwic3RyXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyhoKSk7XG5Tay5idWlsdGluLnB5Q2hlY2tUeXBlKFwibW9kZVwiLFwic3RyXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyhwKSk7Zj1mLiRqc3N0cigpO2g9aC4kanNzdHIoKTtwPXAuJGpzc3RyKCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmNvbXBpbGUoZixoLHAsITApLG49Pm5ldyBiKGgsbikpfTtTay5idWlsdGluLmV4ZWM9ZnVuY3Rpb24oZixoLHApe2xldCBnPWgmJmguX19maWxlX187Zz12b2lkIDAhPT1nJiZTay5idWlsdGluLmNoZWNrU3RyaW5nKGcpP2cudG9TdHJpbmcoKTpcIjxzdHJpbmc+XCI7aWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhmKSlmPVNrLmNvbXBpbGUoZi4kanNzdHIoKSxnLFwiZXhlY1wiLCEwKTtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2YgZilmPVNrLmNvbXBpbGUoZixnLFwiZXhlY1wiLCEwKTtlbHNlIGlmKCEoZiBpbnN0YW5jZW9mIGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImV4ZWMoKSBhcmcgMSBtdXN0IGJlIGEgc3RyaW5nLCBieXRlcyBvciBjb2RlIG9iamVjdFwiKTtcblNrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMD09PWh8fGguY29uc3RydWN0b3I9PT1PYmplY3QsXCJpbnRlcm5hbCBjYWxscyB0byBleGVjIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhIGphdmFzY3JpcHQgb2JqZWN0IGZvciBnbG9iYWxzXCIpO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMD09PXB8fHAuY29uc3RydWN0b3I9PT1PYmplY3QsXCJpbnRlcm5hbCBjYWxscyB0byBleGVjIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhIGphdmFzY3JpcHQgb2JqZWN0IGZvciBsb2NhbHNcIik7Y29uc3QgYT1Tay5nbG9iYWxzO2g9aHx8YTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZixjPT5Tay5nbG9iYWwuZXZhbChjLmNvZGUpKGgscCksYz0+e1NrLmdsb2JhbHM9YTtyZXR1cm4gY30pfTtTay5idWlsdGluLmV2YWw9ZnVuY3Rpb24oZixoLHApe2lmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZikpZj1mLiRqc3N0cigpO2Vsc2UgaWYoU2suYnVpbHRpbi5jaGVja0J5dGVzKGYpKXRocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJieXRlcyBmb3IgZXZhbCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIHNrdWxwdFwiKTtcbmlmKFwic3RyaW5nXCI9PT10eXBlb2YgZil7Zj1mLnRyaW0oKTt2YXIgZz1Tay5wYXJzZShcIj9cIixmKTtnPVNrLmFzdEZyb21QYXJzZShnLmNzdCxcIj9cIixnLmZsYWdzKTtpZigxPGcuYm9keS5sZW5ndGh8fCEoZy5ib2R5WzBdaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5FeHByKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImludmFsaWQgc3ludGF4XCIpO2Y9XCJfX2ZpbmFsX3Jlc19fID0gXCIrZn1lbHNlIGlmKCEoZiBpbnN0YW5jZW9mIGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImV2YWwoKSBhcmcgMSBtdXN0IGJlIGEgc3RyaW5nLCBieXRlcyBvciBjb2RlIG9iamVjdFwiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suYnVpbHRpbi5leGVjKGYsaCxwKSxhPT57Y29uc3QgYz1hLl9fZmluYWxfcmVzX198fFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtkZWxldGUgYS5fX2ZpbmFsX3Jlc19fO3JldHVybiBjfSl9O1NrLmJ1aWx0aW4ubWFwPWZ1bmN0aW9uKGYsaCl7dmFyIHA9XG5bXSxnLGE7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcIm1hcFwiLGFyZ3VtZW50cy5sZW5ndGgsMik7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgYz1bXTt2YXIgbj1BcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKS5zbGljZSgxKTtmb3IoYT0wO2E8bi5sZW5ndGg7YSsrKXtpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKG5bYV0pKXt2YXIgbT1wYXJzZUludChhLDEwKSsyO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFyZ3VtZW50IFwiK20rXCIgdG8gbWFwKCkgbXVzdCBzdXBwb3J0IGl0ZXJhdGlvblwiKTt9blthXT1Tay5hYnN0ci5pdGVyKG5bYV0pfWZvcig7Oyl7dmFyIGs9W107Zm9yKGE9Zz0wO2E8bi5sZW5ndGg7YSsrKW09blthXS50cCRpdGVybmV4dCgpLHZvaWQgMD09PW0/KGsucHVzaChTay5idWlsdGluLm5vbmUubm9uZSQpLGcrKyk6ay5wdXNoKG0pO2lmKGchPT1uLmxlbmd0aCljLnB1c2goayk7ZWxzZSBicmVha31oPW5ldyBTay5idWlsdGluLmxpc3QoYyl9aWYoIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrXG5Tay5hYnN0ci50eXBlTmFtZShoKStcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGgpLGZ1bmN0aW9uKHUpe2lmKGY9PT1Tay5idWlsdGluLm5vbmUubm9uZSQpdSBpbnN0YW5jZW9mIEFycmF5JiYodT1uZXcgU2suYnVpbHRpbi50dXBsZSh1KSkscC5wdXNoKHUpO2Vsc2UgcmV0dXJuIHUgaW5zdGFuY2VvZiBBcnJheXx8KHU9W3VdKSxTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZix1KSxmdW5jdGlvbihsKXtwLnB1c2gobCl9KX0pLGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QocCl9KX07U2suYnVpbHRpbi5yZWR1Y2U9ZnVuY3Rpb24oZixoLHApe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoaCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGgpK1wiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO1xuaD1Tay5hYnN0ci5pdGVyKGgpO2lmKHZvaWQgMD09PXAmJihwPWgudHAkaXRlcm5leHQoKSx2b2lkIDA9PT1wKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJyZWR1Y2UoKSBvZiBlbXB0eSBzZXF1ZW5jZSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIik7dmFyIGc9cDtmb3IocD1oLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09cDtwPWgudHAkaXRlcm5leHQoKSlnPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShmLFtnLHBdKTtyZXR1cm4gZ307U2suYnVpbHRpbi5zb3J0ZWQ9ZnVuY3Rpb24oZixoLHAsZyl7Zj1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShmLCEwKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZixhPT57YT1uZXcgU2suYnVpbHRpbi5saXN0KGEpO2EubGlzdCRzb3J0KGgscCxnKTtyZXR1cm4gYX0pfTtTay5idWlsdGluLmZpbHRlcj1mdW5jdGlvbihmLGgpe3ZhciBwO1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXCJmaWx0ZXJcIixhcmd1bWVudHMubGVuZ3RoLFxuMiwyKTtpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShoKStcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTt2YXIgZz1mdW5jdGlvbigpe3JldHVybltdfTt2YXIgYT1mdW5jdGlvbihrLHUpe2sucHVzaCh1KTtyZXR1cm4ga307dmFyIGM9ZnVuY3Rpb24oayl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qoayl9O2gub2IkdHlwZT09PVNrLmJ1aWx0aW4uc3RyPyhnPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIlwiKX0sYT1mdW5jdGlvbihrLHUpe3JldHVybiBrLnNxJGNvbmNhdCh1KX0sYz1mdW5jdGlvbihrKXtyZXR1cm4ga30pOmgub2IkdHlwZT09PVNrLmJ1aWx0aW4udHVwbGUmJihjPWZ1bmN0aW9uKGspe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShrKX0pO3ZhciBuPWcoKTt2YXIgbT1Tay5hYnN0ci5pdGVyKGgpO2ZvcihwPW0udHAkaXRlcm5leHQoKTt2b2lkIDAhPT1cbnA7cD1tLnRwJGl0ZXJuZXh0KCkpZz1mPT09U2suYnVpbHRpbi5ub25lLm5vbmUkP25ldyBTay5idWlsdGluLmJvb2wocCk6U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGYsW3BdKSxTay5taXNjZXZhbC5pc1RydWUoZykmJihuPWEobixwKSk7cmV0dXJuIGMobil9O1NrLmJ1aWx0aW4uaGFzYXR0cj1mdW5jdGlvbihmLGgpe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImhhc2F0dHIoKTogYXR0cmlidXRlIG5hbWUgbXVzdCBiZSBzdHJpbmdcIik7Y29uc3QgcD1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+Zi50cCRnZXRhdHRyKGgsITApLGc9PntpZighKGcgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBnO30pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihwLGc9PnZvaWQgMD09PWc/U2suYnVpbHRpbi5ib29sLmZhbHNlJDpTay5idWlsdGluLmJvb2wudHJ1ZSQpfTtTay5idWlsdGluLnBvdz1cbmZ1bmN0aW9uKGYsaCxwKXtpZih2b2lkIDA9PT1wfHxTay5idWlsdGluLmNoZWNrTm9uZShwKSlyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoZixoLFwiUG93XCIpO2lmKCEoU2suYnVpbHRpbi5jaGVja0ludChmKSYmU2suYnVpbHRpbi5jaGVja0ludChoKSYmU2suYnVpbHRpbi5jaGVja0ludChwKSkpe2lmKFNrLmJ1aWx0aW4uY2hlY2tGbG9hdChmKXx8U2suYnVpbHRpbi5jaGVja0NvbXBsZXgoZikpcmV0dXJuIGYubmIkcG93ZXIoaCxwKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYW5kIHR5cGUocykgZm9yICoqIG9yIHBvdygpOiAnXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCInLCAnXCIrU2suYWJzdHIudHlwZU5hbWUoaCkrXCInLCAnXCIrU2suYWJzdHIudHlwZU5hbWUocCkrXCInXCIpO31yZXR1cm4gZi5uYiRwb3dlcihoLHApfTtTay5idWlsdGluLnF1aXQ9ZnVuY3Rpb24oZil7Zj0obmV3IFNrLmJ1aWx0aW4uc3RyKGYpKS52O3Rocm93IG5ldyBTay5idWlsdGluLlN5c3RlbUV4aXQoZik7XG59O1NrLmJ1aWx0aW4uaXNzdWJjbGFzcz1mdW5jdGlvbihmLGgpe2lmKCFTay5idWlsdGluLmNoZWNrQ2xhc3MoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaXNzdWJjbGFzcygpIGFyZyAxIG11c3QgYmUgYSBjbGFzc1wiKTt2YXIgcD1Tay5idWlsdGluLmNoZWNrQ2xhc3MoaCk7aWYoIShwfHxoIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaXNzdWJjbGFzcygpIGFyZyAyIG11c3QgYmUgYSBjbGFzcyBvciB0dXBsZSBvZiBjbGFzc2VzXCIpO2lmKHApcmV0dXJuIGYuJGlzU3ViVHlwZShoKT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJDtmb3IocD0wO3A8aC52Lmxlbmd0aDsrK3ApaWYoU2subWlzY2V2YWwuaXNUcnVlKFNrLmJ1aWx0aW4uaXNzdWJjbGFzcyhmLGgudltwXSkpKXJldHVybiBTay5idWlsdGluLmJvb2wudHJ1ZSQ7cmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9O1xuU2suYnVpbHRpbi5nbG9iYWxzPWZ1bmN0aW9uKCl7dmFyIGYsaD1uZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtmb3IoZiBpbiBTay5nbG9iYWxzKXt2YXIgcD1Tay51bmZpeFJlc2VydmVkKGYpO2gubXAkYXNzX3N1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5zdHIocCksU2suZ2xvYmFsc1tmXSl9cmV0dXJuIGh9O1NrLmJ1aWx0aW4uZGl2bW9kPWZ1bmN0aW9uKGYsaCl7cmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGYsaCxcIkRpdk1vZFwiKX07U2suYnVpbHRpbi5mb3JtYXQ9ZnVuY3Rpb24oZixoKXtyZXR1cm4gU2suYWJzdHIub2JqZWN0Rm9ybWF0KGYsaCl9O2NvbnN0IGU9bmV3IFdlYWtNYXA7bGV0IGQ9MDtTay5idWlsdGluLmlkPWZ1bmN0aW9uKGYpe2NvbnN0IGg9ZS5nZXQoZik7aWYodm9pZCAwIT09aClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhoKTtlLnNldChmLGQpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGQrKyl9O1NrLmJ1aWx0aW4uYnl0ZWFycmF5PWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImJ5dGVhcnJheSBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO1xufTtTay5idWlsdGluLmNhbGxhYmxlPWZ1bmN0aW9uKGYpe3JldHVybiBTay5idWlsdGluLmNoZWNrQ2FsbGFibGUoZik/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9O1NrLmJ1aWx0aW4uZGVsYXR0cj1mdW5jdGlvbihmLGgpe3JldHVybiBTay5idWlsdGluLnNldGF0dHIoZixoLHZvaWQgMCl9O1NrLmJ1aWx0aW4uZXhlY2ZpbGU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiZXhlY2ZpbGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uaGVscD1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJoZWxwIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7fTtTay5idWlsdGluLml0ZXI9ZnVuY3Rpb24oZixoKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/U2suYWJzdHIuaXRlcihmKTpTay5hYnN0ci5pdGVyKG5ldyBTay5idWlsdGluLmNhbGxhYmxlX2l0ZXJfKGYsXG5oKSl9O1NrLmJ1aWx0aW4ubG9jYWxzPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImxvY2FscyBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5tZW1vcnl2aWV3PWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcIm1lbW9yeXZpZXcgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4ubmV4dF89ZnVuY3Rpb24oZixoKXtpZighZi50cCRpdGVybmV4dCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCInIG9iamVjdCBpcyBub3QgYW4gaXRlcmF0b3JcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGYudHAkaXRlcm5leHQoITApLHA9PntpZih2b2lkIDA9PT1wKXtpZihoKXJldHVybiBoO3A9Zi5naSRyZXQ7aWYodm9pZCAwIT09cCYmcCE9PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uKHApO1xudGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbjt9cmV0dXJuIHB9KX07U2suYnVpbHRpbi5yZWxvYWQ9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwicmVsb2FkIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7fTtTay5idWlsdGluLnZhcnM9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwidmFycyBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5hcHBseV89ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiYXBwbHkgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uYnVmZmVyPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImJ1ZmZlciBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5jb2VyY2U9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiY29lcmNlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG59O1NrLmJ1aWx0aW4uaW50ZXJuPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImludGVybiBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO319LGZ1bmN0aW9uKEYsUCl7ZnVuY3Rpb24gYihWLFope1o9bmV3IHRoaXMuY29uc3RydWN0b3I7dGhpcy5odCR0eXBlJiZwLmNhbGwoWik7Wi5hcmdzPW5ldyBTay5idWlsdGluLnR1cGxlKFYuc2xpY2UoMCkpO3JldHVybiBafWZ1bmN0aW9uIGUoVixaKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpLFopO3RoaXMuYXJncz1uZXcgU2suYnVpbHRpbi50dXBsZShWLnNsaWNlKDApKX1mdW5jdGlvbiBkKCl7cmV0dXJuIDE+PXRoaXMuYXJncy52Lmxlbmd0aD9uZXcgU2suYnVpbHRpbi5zdHIodGhpcy5hcmdzLnZbMF0pOnRoaXMuYXJncy4kcigpfWZ1bmN0aW9uIGYoVixaLGZhLHFhLHBhLEQpe3BhfHwocGE9W10pO2NvbnN0IHc9cWE/e306e3NrJHNvbGlkQmFzZTohMX07XG5mYT17dHAkaW5pdDpxYXx8ZSx0cCRkb2M6ZmF9O0QmJihmYS50cCRzdHI9RCk7cmV0dXJuIFNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoWix7YmFzZTpWLGNvbnN0cnVjdG9yOmZ1bmN0aW9uKC4uLkMpe1YuYXBwbHkodGhpcyxDKTtwYS5mb3JFYWNoKChHLEwpPT57dGhpc1tcIiRcIitHXT1Tay5mZmkucmVtYXBUb1B5KENbTF0pfSl9LHNsb3RzOmZhLGdldHNldHM6T2JqZWN0LmZyb21FbnRyaWVzKHBhLm1hcChDPT5bQyx7JGdldCgpe3JldHVybiB0aGlzW1wiJFwiK0NdfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRzZXQoRyl7dGhpc1tcIiRcIitDXT1HfHxTay5idWlsdGluLm5vbmUubm9uZSR9fV0pKSxmbGFnczp3fSl9ZnVuY3Rpb24gaChWLFosZmEpe2NvbnN0IHFhPVYucHJvdG90eXBlLnRwJGluaXQ7ZmE9e3RwJGRvYzpmYSx0cCRpbml0OnFhfTtxYT09PWUmJihmYS50cCRuZXc9Yik7cmV0dXJuIFNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoWix7YmFzZTpWLGNvbnN0cnVjdG9yOmZ1bmN0aW9uKC4uLnBhKXtWLmFwcGx5KHRoaXMsXG5wYSl9LHNsb3RzOmZhLGZsYWdzOntzayRzb2xpZEJhc2U6ITF9fSl9Y29uc3QgcD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiQmFzZUV4Y2VwdGlvblwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBxYShaLC4uLmZhKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgcWEsXCJiYWQgY2FsbCB0byBleGNlcHRpb24gY29uc3RydWN0b3IsIHVzZSAnbmV3J1wiKTtcInN0cmluZ1wiPT09dHlwZW9mIFomJihaPW5ldyBTay5idWlsdGluLnN0cihaKSk7dGhpcy5hcmdzPW5ldyBTay5idWlsdGluLnR1cGxlKFo/W1pdOltdKTt0aGlzLnRyYWNlYmFjaz0yPD1mYS5sZW5ndGg/W3tmaWxlbmFtZTpmYVswXXx8XCI8dW5rbm93bj5cIixsaW5lbm86ZmFbMV19XTpbXTt0aGlzLmNvbnRleHQ9dGhpcy5jYXVzZT1udWxsO3RoaXMuJGQ9bmV3IFNrLmJ1aWx0aW4uZGljdH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGRvYzpcIkNvbW1vbiBiYXNlIGNsYXNzIGZvciBhbGwgZXhjZXB0aW9uc1wiLFxudHAkbmV3OmIsdHAkaW5pdDplLCRyKCl7bGV0IFo9dGhpcy50cCRuYW1lO1orPVwiKFwiK3RoaXMuYXJncy52Lm1hcChmYT0+U2subWlzY2V2YWwub2JqZWN0UmVwcihmYSkpLmpvaW4oXCIsIFwiKStcIilcIjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFopfSx0cCRzdHI6ZH0sZ2V0c2V0czp7YXJnczp7JGdldCgpe3JldHVybiB0aGlzLmFyZ3N9LCRzZXQoWil7aWYodm9pZCAwPT09Wil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhcmdzIG1heSBub3QgYmUgZGVsZXRlZFwiKTt0aGlzLmFyZ3M9bmV3IFNrLmJ1aWx0aW4udHVwbGUoWil9fSxfX2NhdXNlX186eyRnZXQoKXtyZXR1cm4gdGhpcy4kY2F1c2V8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJHNldChaKXtpZighKFNrLmJ1aWx0aW4uY2hlY2tOb25lKFopfHxaIGluc3RhbmNlb2YgU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uKSl0aHJvdyBuZXcgaWEoXCJleGNlcHRpb24gY2F1c2UgbXVzdCBiZSBOb25lIG9yIGRlcml2ZSBmcm9tIEJhc2VFeGNlcHRpb25cIik7XG50aGlzLiRjYXVzZT1afX0sX19kaWN0X186U2suZ2VuZXJpYy5nZXRTZXREaWN0fSxwcm90bzp7dG9TdHJpbmcoKXtsZXQgWj10aGlzLnRwJG5hbWU7Wis9XCI6IFwiK3RoaXMudHAkc3RyKCkudjtyZXR1cm4gWj0wIT09dGhpcy50cmFjZWJhY2subGVuZ3RoP1orKFwiIG9uIGxpbmUgXCIrdGhpcy50cmFjZWJhY2tbMF0ubGluZW5vKTpaK1wiIGF0IDx1bmtub3duPlwifX19KTtGPWgocCxcIlN5c3RlbUV4aXRcIixcIlJlcXVlc3QgdG8gZXhpdCBmcm9tIHRoZSBpbnRlcnByZXRlci5cIik7UD1oKHAsXCJLZXlib2FyZEludGVycnVwdFwiLFwiUHJvZ3JhbSBpbnRlcnJ1cHRlZCBieSB1c2VyLlwiKTtjb25zdCBnPWgocCxcIkdlbmVyYXRvckV4aXRcIixcIlJlcXVlc3QgdGhhdCBhIGdlbmVyYXRvciBleGl0LlwiKSxhPWgocCxcIkV4Y2VwdGlvblwiLFwiQ29tbW9uIGJhc2UgY2xhc3MgZm9yIGFsbCBub24tZXhpdCBleGNlcHRpb25zLlwiKSxjPWYoYSxcIlN0b3BJdGVyYXRpb25cIixcIlNpZ25hbCB0aGUgZW5kIGZyb20gaXRlcmF0b3IuX19uZXh0X18oKS5cIixcbmZ1bmN0aW9uKFosZmEpe2UuY2FsbCh0aGlzLFosZmEpO3RoaXMuJHZhbHVlPVpbMF18fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sW1widmFsdWVcIl0pLG49aChhLFwiU3RvcEFzeW5jSXRlcmF0aW9uXCIsXCJTaWduYWwgdGhlIGVuZCBmcm9tIGl0ZXJhdG9yLl9fYW5leHRfXygpLlwiKSxtPWgoYSxcIkFyaXRobWV0aWNFcnJvclwiLFwiQmFzZSBjbGFzcyBmb3IgYXJpdGhtZXRpYyBlcnJvcnMuXCIpLGs9aChtLFwiRmxvYXRpbmdQb2ludEVycm9yXCIsXCJGbG9hdGluZyBwb2ludCBvcGVyYXRpb24gZmFpbGVkLlwiKSx1PWgobSxcIk92ZXJmbG93RXJyb3JcIixcIlJlc3VsdCB0b28gbGFyZ2UgdG8gYmUgcmVwcmVzZW50ZWQuXCIpLGw9aChtLFwiWmVyb0RpdmlzaW9uRXJyb3JcIixcIlNlY29uZCBhcmd1bWVudCB0byBhIGRpdmlzaW9uIG9yIG1vZHVsbyBvcGVyYXRpb24gd2FzIHplcm8uXCIpLHE9aChhLFwiQXNzZXJ0aW9uRXJyb3JcIixcIkFzc2VydGlvbiBmYWlsZWQuXCIpLHo9aChhLFwiQXR0cmlidXRlRXJyb3JcIixcIkF0dHJpYnV0ZSBub3QgZm91bmQuXCIpLFxucj1oKGEsXCJCdWZmZXJFcnJvclwiLFwiQnVmZmVyIGVycm9yLlwiKSx0PWgoYSxcIkVPRkVycm9yXCIsXCJSZWFkIGJleW9uZCBlbmQgb2YgZmlsZS5cIikseD1mKGEsXCJJbXBvcnRFcnJvclwiLFwiSW1wb3J0IGNhbid0IGZpbmQgbW9kdWxlLCBvciBjYW4ndCBmaW5kIG5hbWUgaW4gbW9kdWxlLlwiLGZ1bmN0aW9uKFosZmEpe2UuY2FsbCh0aGlzLFopO2NvbnN0IFtxYSxwYV09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJJbXBvcnRFcnJvclwiLFtcIm5hbWVcIixcInBhdGhcIl0sW10sZmEpO3RoaXMuJG5hbWU9cWE7dGhpcy4kcGF0aD1wYTsxPT09Wi5sZW5ndGgmJih0aGlzLiRtc2c9WlswXSl9LFtcIm1zZ1wiLFwibmFtZVwiLFwicGF0aFwiXSxmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLmNoZWNrU3RyaW5nKHRoaXMuJG1zZyk/dGhpcy4kbXNnOmQuY2FsbCh0aGlzKX0pLHY9aCh4LFwiTW9kdWxlTm90Rm91bmRFcnJvclwiLFwiTW9kdWxlIG5vdCBmb3VuZC5cIiksQj1oKGEsXCJMb29rdXBFcnJvclwiLFxuXCJCYXNlIGNsYXNzIGZvciBsb29rdXAgZXJyb3JzLlwiKSxJPWgoQixcIkluZGV4RXJyb3JcIixcIlNlcXVlbmNlIGluZGV4IG91dCBvZiByYW5nZS5cIiksTT1mKEIsXCJLZXlFcnJvclwiLFwiTWFwcGluZyBrZXkgbm90IGZvdW5kLlwiLG51bGwsbnVsbCxmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5hcmdzLnYubGVuZ3RoP3RoaXMuYXJncy52WzBdLiRyKCk6ZC5jYWxsKHRoaXMpfSksUz1oKGEsXCJNZW1vcnlFcnJvclwiLFwiT3V0IG9mIG1lbW9yeS5cIiksRT1oKGEsXCJOYW1lRXJyb3JcIixcIk5hbWUgbm90IGZvdW5kIGdsb2JhbGx5LlwiKSxIPWgoRSxcIlVuYm91bmRMb2NhbEVycm9yXCIsXCJMb2NhbCBuYW1lIHJlZmVyZW5jZWQgYnV0IG5vdCBib3VuZCB0byBhIHZhbHVlLlwiKSx5PWYoYSxcIk9TRXJyb3JcIixcIkJhc2UgY2xhc3MgZm9yIEkvTyByZWxhdGVkIGVycm9ycy5cIixmdW5jdGlvbihaLGZhKXtlLmNhbGwodGhpcyxaLGZhKX0pLEE9aCh5LFwiRmlsZU5vdEZvdW5kRXJyb3JcIixcIkZpbGUgbm90IGZvdW5kLlwiKSxcbko9aCh5LFwiVGltZW91dEVycm9yXCIsXCJUaW1lb3V0IGV4cGlyZWQuXCIpLFE9aChhLFwiUmVmZXJlbmNlRXJyb3JcIixcIldlYWsgcmVmIHByb3h5IHVzZWQgYWZ0ZXIgcmVmZXJlbnQgd2VudCBhd2F5LlwiKSxYPWgoYSxcIlJ1bnRpbWVFcnJvclwiLFwiVW5zcGVjaWZpZWQgcnVuLXRpbWUgZXJyb3IuXCIpLGFhPWgoWCxcIk5vdEltcGxlbWVudGVkRXJyb3JcIixcIk1ldGhvZCBvciBmdW5jdGlvbiBoYXNuJ3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXCIpLGVhPWgoWCxcIlJlY3Vyc2lvbkVycm9yXCIsXCJSZWN1cnNpb24gbGltaXQgZXhjZWVkZWQuXCIpLG5hPWYoYSxcIlN5bnRheEVycm9yXCIsXCJJbnZhbGlkIHN5bnRheC5cIixmdW5jdGlvbihaLGZhKXtlLmNhbGwodGhpcyxaLGZhKTsxPD1aLmxlbmd0aCYmKHRoaXMuJG1zZz1aWzBdKTsyPT09Wi5sZW5ndGgmJihaPShuZXcgU2suYnVpbHRpbi50dXBsZShaWzFdKSkudix0aGlzLiRmaWxlbmFtZT1aWzBdLHRoaXMuJGxpbmVubz1aWzFdLHRoaXMuJG9mZnNldD1aWzJdLFxudGhpcy4kdGV4dD1aWzNdKX0sW1wibXNnXCIsXCJmaWxlbmFtZVwiLFwibGluZW5vXCIsXCJvZmZzZXRcIixcInRleHRcIl0sZnVuY3Rpb24oKXtyZXR1cm4gZC5jYWxsKHRoaXMpfSksb2E9aChuYSxcIkluZGVudGF0aW9uRXJyb3JcIixcIkltcHJvcGVyIGluZGVudGF0aW9uLlwiKSxjYT1oKG9hLFwiVGFiRXJyb3JcIixcIkltcHJvcGVyIG1peHR1cmUgb2Ygc3BhY2VzIGFuZCB0YWJzLlwiKSxsYT1oKGEsXCJTeXN0ZW1FcnJvclwiLFwiSW50ZXJuYWwgZXJyb3IgaW4gdGhlIFNrdWxwdCBpbnRlcnByZXRlci5cIiksaWE9aChhLFwiVHlwZUVycm9yXCIsXCJJbmFwcHJvcHJpYXRlIGFyZ3VtZW50IHR5cGUuXCIpLGthPWgoYSxcIlZhbHVlRXJyb3JcIixcIkluYXBwcm9wcmlhdGUgYXJndW1lbnQgdmFsdWUgKG9mIGNvcnJlY3QgdHlwZSkuXCIpLFU9aChrYSxcIlVuaWNvZGVFcnJvclwiLFwiVW5pY29kZSByZWxhdGVkIGVycm9yLlwiKSxqYT1oKFUsXCJVbmljb2RlRGVjb2RlRXJyb3JcIixcIlVuaWNvZGUgZGVjb2RpbmcgZXJyb3IuXCIpLE89aChVLFxuXCJVbmljb2RlRW5jb2RlRXJyb3JcIixcIlVuaWNvZGUgZW5jb2RpbmcgZXJyb3IuXCIpO09iamVjdC5hc3NpZ24oU2suYnVpbHRpbix7QmFzZUV4Y2VwdGlvbjpwLFN5c3RlbUV4aXQ6RixLZXlib2FyZEludGVycnVwdDpQLEdlbmVyYXRvckV4aXQ6ZyxFeGNlcHRpb246YSxTdG9wSXRlcmF0aW9uOmMsU3RvcEFzeW5jSXRlcmF0aW9uOm4sQXJpdGhtZXRpY0Vycm9yOm0sRmxvYXRpbmdQb2ludEVycm9yOmssT3ZlcmZsb3dFcnJvcjp1LFplcm9EaXZpc2lvbkVycm9yOmwsQXNzZXJ0aW9uRXJyb3I6cSxBdHRyaWJ1dGVFcnJvcjp6LEJ1ZmZlckVycm9yOnIsRU9GRXJyb3I6dCxJbXBvcnRFcnJvcjp4LE1vZHVsZU5vdEZvdW5kRXJyb3I6dixMb29rdXBFcnJvcjpCLEluZGV4RXJyb3I6SSxLZXlFcnJvcjpNLE1lbW9yeUVycm9yOlMsTmFtZUVycm9yOkUsVW5ib3VuZExvY2FsRXJyb3I6SCxPU0Vycm9yOnksSU9FcnJvcjp5LEZpbGVOb3RGb3VuZEVycm9yOkEsVGltZW91dEVycm9yOkosUmVmZXJlbmNlRXJyb3I6USxcblJ1bnRpbWVFcnJvcjpYLE5vdEltcGxlbWVudGVkRXJyb3I6YWEsUmVjdXJzaW9uRXJyb3I6ZWEsU3ludGF4RXJyb3I6bmEsSW5kZW50YXRpb25FcnJvcjpvYSxUYWJFcnJvcjpjYSxTeXN0ZW1FcnJvcjpsYSxUeXBlRXJyb3I6aWEsVmFsdWVFcnJvcjprYSxVbmljb2RlRXJyb3I6VSxVbmljb2RlRGVjb2RlRXJyb3I6amEsVW5pY29kZUVuY29kZUVycm9yOk99KTtTay5idWlsdGluLlN1c3BlbnNpb25FcnJvcj1oKGEsXCJTdXNwZW5zaW9uRXJyb3JcIixcIlVuc3VwcG9ydGVkIFN1c3BlbnNpb24gaW4gY29kZS5cIik7U2suYnVpbHRpbi5FeHRlcm5hbEVycm9yPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJFeHRlcm5hbEVycm9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKC4uLlope3RoaXMubmF0aXZlRXJyb3I9WlswXTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyh0aGlzLm5hdGl2ZUVycm9yKSYmKFpbMF09dGhpcy5uYXRpdmVFcnJvci50b1N0cmluZygpLFpbMF0uc3RhcnRzV2l0aChcIlJhbmdlRXJyb3I6IE1heGltdW0gY2FsbFwiKSkpcmV0dXJuIFpbMF09XG5cIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIsbmV3IGVhKC4uLlopO2EuYXBwbHkodGhpcyxaKX0sYmFzZTphfSk7U2suYnVpbHRpbi5nZXRFeGNJbmZvPWZ1bmN0aW9uKFope3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbWi5vYiR0eXBlfHxTay5idWlsdGluLm5vbmUubm9uZSQsWixTay5idWlsdGluLm5vbmUubm9uZSRdKX19LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5tZXRob2Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIm1ldGhvZFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihiLGUpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLm1ldGhvZCxcImJhZCBjYWxsIHRvIG1ldGhvZCBjb25zdHJ1Y3RvciwgdXNlICduZXcnXCIpO3RoaXMuaW1fZnVuYz1iO3RoaXMuaW1fc2VsZj1lO3RoaXMuaW1fY2FsbD1iLnRwJGNhbGx9LHNsb3RzOnskcigpe2xldCBiPXRoaXMuaW1fZnVuYy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRxdWFsbmFtZSl8fFxudGhpcy5pbV9mdW5jLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJG5hbWUpO2I9YiYmYi52fHxcIj9cIjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGJvdW5kIG1ldGhvZCBcIitiK1wiIG9mIFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5pbV9zZWxmKStcIj5cIil9LHRwJGhhc2goKXtjb25zdCBiPVNrLmFic3RyLm9iamVjdEhhc2godGhpcy5pbV9zZWxmKSxlPVNrLmFic3RyLm9iamVjdEhhc2godGhpcy5pbV9mdW5jKTtyZXR1cm4gYitlfSx0cCRjYWxsKGIsZSl7dmFyIGQ9dGhpcy5pbV9jYWxsO2lmKHZvaWQgMD09PWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMuaW1fZnVuYykrXCInIG9iamVjdCBpcyBub3QgY2FsbGFibGVcIik7Yj1bdGhpcy5pbV9zZWxmLC4uLmJdO3JldHVybiBkLmNhbGwodGhpcy5pbV9mdW5jLGIsZSl9LHRwJG5ldyhiLGUpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJtZXRob2RcIixlKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJtZXRob2RcIixcbmIsMiwyKTtlPWJbMF07Yj1iWzFdO2lmKCFTay5idWlsdGluLmNoZWNrQ2FsbGFibGUoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBjYWxsYWJsZVwiKTtpZihTay5idWlsdGluLmNoZWNrTm9uZShiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZWxmIG11c3Qgbm90IGJlIE5vbmVcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLm1ldGhvZChlLGIpfSx0cCRyaWNoY29tcGFyZShiLGUpe2lmKFwiRXFcIiE9ZSYmXCJOb3RFcVwiIT1lfHwhKGIgaW5zdGFuY2VvZiBTay5idWlsdGluLm1ldGhvZCkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2xldCBkO3RyeXtkPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLmltX3NlbGYsYi5pbV9zZWxmLFwiRXFcIiwhMSkmJnRoaXMuaW1fZnVuYz09Yi5pbV9mdW5jfWNhdGNoKGYpe2Q9ITF9cmV0dXJuXCJFcVwiPT1lP2Q6IWR9LHRwJGRlc2NyX2dldChiLFxuZSl7cmV0dXJuIHRoaXN9LHRwJGdldGF0dHIoYixlKXtjb25zdCBkPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwodGhpcyxiKTtyZXR1cm4gdm9pZCAwIT09ZD9kOnRoaXMuaW1fZnVuYy50cCRnZXRhdHRyKGIsZSl9fSxnZXRzZXRzOntfX2Z1bmNfXzp7JGdldCgpe3JldHVybiB0aGlzLmltX2Z1bmN9fSxfX3NlbGZfXzp7JGdldCgpe3JldHVybiB0aGlzLmltX3NlbGZ9fSxfX2RvY19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuaW1fZnVuYy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRkb2MpfX19LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pfSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIocCl7aWYobnVsbCE9PXAmJnZvaWQgMCE9PXApe2lmKCEwPT09cC5zayRpbnQpcmV0dXJuIHAudjtpZih2b2lkIDAhPT1wLm5iJGluZGV4KXJldHVybiBwLm5iJGluZGV4KCk7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBwJiZOdW1iZXIuaXNJbnRlZ2VyKHApKXJldHVybiBwfX1mdW5jdGlvbiBlKHAsXG5nKXtjb25zdCBhPWIocCk7aWYodm9pZCAwIT09YSlyZXR1cm4gYTtnPShnfHxcIid7dHAkbmFtZX0nIG9iamVjdCBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlclwiKS5yZXBsYWNlKFwie3RwJG5hbWV9XCIsU2suYWJzdHIudHlwZU5hbWUocCkpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihnKTt9ZnVuY3Rpb24gZCgpe2NvbnN0IHA9KFNrLmdsb2JhbC5uYXZpZ2F0b3J8fHt9KS51c2VyQWdlbnR8fFwiXCI7cmV0dXJuLTE8cC5pbmRleE9mKFwiTVNJRSBcIil8fC0xPHAuaW5kZXhPZihcIlRyaWRlbnQvXCIpfWZ1bmN0aW9uIGYocCxnKXtsZXQgYT1wO2cuZm9yRWFjaChjPT57Yz1jLm9iJHR5cGU7aWYoIWEuJGlzU3ViVHlwZShjKSlpZihjLiRpc1N1YlR5cGUoYSkpYT1jO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibWV0YWNsYXNzIGNvbmZsaWN0OiB0aGUgbWV0YWNsYXNzIG9mIGEgZGVyaXZlZCBjbGFzcyBtdXN0IGJlIGEgKG5vbi1zdHJpY3QpIHN1YmNsYXNzIG9mIHRoZSBtZXRhY2xhc3NlcyBvZiBhbGwgaXRzIGJhc2VzXCIpO1xufSk7cmV0dXJuIGF9ZnVuY3Rpb24gaChwLGcsYSxjLG4pe2NvbnN0IG09cC50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRwcmVwYXJlKTtsZXQgayx1PW51bGw7aWYodm9pZCAwPT09bSlyZXR1cm5bdSxrXTt1PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShtLFtnLGFdLGMpO2lmKCFTay5idWlsdGluLmNoZWNrTWFwcGluZyh1KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3Iobj9wLnByb3RvdHlwZS50cCRuYW1lOlwiPG1ldGFjbGFzcz4uX19wcmVwYXJlX18oKSBtdXN0IHJldHVybiBhIG1hcHBpbmcgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZSh1KStcIidcIik7az17Z2V0KGwscSl7dHJ5e3JldHVybiBTay5hYnN0ci5vYmplY3RHZXRJdGVtKGwsbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLnVuZml4UmVzZXJ2ZWQocSkpKX1jYXRjaCh6KXtpZighKHogaW5zdGFuY2VvZiBTay5idWlsdGluLktleUVycm9yKSl0aHJvdyB6O319LHNldChsLHEseil7U2suYWJzdHIub2JqZWN0U2V0SXRlbShsLFxubmV3IFNrLmJ1aWx0aW4uc3RyKFNrLnVuZml4UmVzZXJ2ZWQocSkpLHopO3JldHVybiEwfX07cmV0dXJuW3Usa119U2subWlzY2V2YWw9e307U2subWlzY2V2YWwuU3VzcGVuc2lvbj1mdW5jdGlvbihwLGcsYSl7dGhpcy4kaXNTdXNwZW5zaW9uPSEwO3ZvaWQgMCE9PXAmJnZvaWQgMCE9PWcmJih0aGlzLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiBwKGcucmVzdW1lKCkpfSk7dGhpcy5jaGlsZD1nO3RoaXMub3B0aW9uYWw9dm9pZCAwIT09ZyYmZy5vcHRpb25hbDt0aGlzLmRhdGE9dm9pZCAwPT09YSYmdm9pZCAwIT09Zz9nLmRhdGE6YX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuU3VzcGVuc2lvblwiLFNrLm1pc2NldmFsLlN1c3BlbnNpb24pO1NrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdz1mdW5jdGlvbihwLGcpe2Zvcig7cCBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLlN1c3BlbnNpb247KXtpZighcC5vcHRpb25hbCl7Zz1uZXcgU2suYnVpbHRpbi5TdXNwZW5zaW9uRXJyb3IoZ3x8XG5cIkNhbm5vdCBjYWxsIGEgZnVuY3Rpb24gdGhhdCBibG9ja3Mgb3Igc3VzcGVuZHMgaGVyZVwiKTtjb25zdCBhPVtdO2Zvcig7bnVsbCE9cDspcC4kbGluZW5vJiZhLnB1c2goe2ZpbGVuYW1lOnAuJGZpbGVuYW1lLGxpbmVubzpwLiRsaW5lbm8sY29sbm86cC4kY29sbm99KSxwPXAuY2hpbGQ7YS5yZXZlcnNlKCk7Zy50cmFjZWJhY2sucHVzaCguLi5hKTt0aHJvdyBnO31wPXAucmVzdW1lKCl9cmV0dXJuIHB9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvd1wiLFNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyk7U2subWlzY2V2YWwuaXNJbmRleD1mdW5jdGlvbihwKXtyZXR1cm4gbnVsbCE9PXAmJnZvaWQgMCE9PXAmJih2b2lkIDAhPT1wLm5iJGluZGV4fHxcIm51bWJlclwiPT09dHlwZW9mIHAmJk51bWJlci5pc0ludGVnZXIocCkpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5pc0luZGV4XCIsU2subWlzY2V2YWwuaXNJbmRleCk7XG5Tay5taXNjZXZhbC5hc0luZGV4PWI7U2subWlzY2V2YWwuYXNJbmRleFNpemVkPWZ1bmN0aW9uKHAsZyxhKXthPWUocCxhKTtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpcmV0dXJuIGE7aWYobnVsbD09ZylyZXR1cm4gSlNCSS5sZXNzVGhhbihhLEpTQkkuX19aRVJPKT8tTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI6TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7dGhyb3cgbmV3IGcoXCJjYW5ub3QgZml0ICdcIitTay5hYnN0ci50eXBlTmFtZShwKStcIicgaW50byBhbiBpbmRleC1zaXplZCBpbnRlZ2VyXCIpO307U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3c9ZTtTay5taXNjZXZhbC5hcHBseVNsaWNlPWZ1bmN0aW9uKHAsZyxhLGMpe3JldHVybiBTay5hYnN0ci5vYmplY3RHZXRJdGVtKHAsbmV3IFNrLmJ1aWx0aW4uc2xpY2UoZyxhLG51bGwpLGMpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5hcHBseVNsaWNlXCIsU2subWlzY2V2YWwuYXBwbHlTbGljZSk7U2subWlzY2V2YWwuYXNzaWduU2xpY2U9XG5mdW5jdGlvbihwLGcsYSxjLG4pe2c9bmV3IFNrLmJ1aWx0aW4uc2xpY2UoZyxhKTtyZXR1cm4gbnVsbD09PWM/U2suYWJzdHIub2JqZWN0RGVsSXRlbShwLGcpOlNrLmFic3RyLm9iamVjdFNldEl0ZW0ocCxnLGMsbil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFzc2lnblNsaWNlXCIsU2subWlzY2V2YWwuYXNzaWduU2xpY2UpO1NrLm1pc2NldmFsLmFycmF5RnJvbUFyZ3VtZW50cz1mdW5jdGlvbihwKXt2YXIgZztpZigxIT1wLmxlbmd0aClyZXR1cm4gcDt2YXIgYT1wWzBdO2EgaW5zdGFuY2VvZiBTay5idWlsdGluLnNldD9hPWEudHAkaXRlcigpLiRvYmo6YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCYmKGE9U2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS5rZXlzLmZ1bmNfY29kZShhKSk7aWYoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubGlzdHx8YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpcmV0dXJuIGEudjtpZihTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYSkpe3A9XG5bXTthPVNrLmFic3RyLml0ZXIoYSk7Zm9yKGc9YS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWc7Zz1hLnRwJGl0ZXJuZXh0KCkpcC5wdXNoKGcpO3JldHVybiBwfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShhKStcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFycmF5RnJvbUFyZ3VtZW50c1wiLFNrLm1pc2NldmFsLmFycmF5RnJvbUFyZ3VtZW50cyk7U2subWlzY2V2YWwuaXRlcmF0b3I9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocCxnKXt0aGlzLnRwJGl0ZXJuZXh0PWc/cDpmdW5jdGlvbihhKXtsZXQgYz1wKCk7cmV0dXJuIGF8fHZvaWQgMD09PWN8fCFjLiRpc1N1c3BlbnNpb24/YzpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coYyl9fSxpdGVybmV4dDpmdW5jdGlvbihwKXtyZXR1cm4gdGhpcy50cCRpdGVybmV4dChwKX0sXG5mbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KTtTay5taXNjZXZhbC5zd2FwcGVkT3BfPXtFcTpcIkVxXCIsTm90RXE6XCJOb3RFcVwiLEx0OlwiR3RcIixMdEU6XCJHdEVcIixHdDpcIkx0XCIsR3RFOlwiTHRFXCJ9O1NrLm1pc2NldmFsLm9wU3ltYm9scz17RXE6XCI9PVwiLE5vdEVxOlwiIT1cIixMdDpcIjxcIixMdEU6XCI8PVwiLEd0OlwiPlwiLEd0RTpcIj49XCIsSXM6XCJpc1wiLElzTm90OlwiaXMgbm90XCIsSW5fOlwiaW5cIixOb3RJbjpcIm5vdCBpblwifTtTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2w9ZnVuY3Rpb24ocCxnLGEsYyl7U2suYXNzZXJ0cy5hc3NlcnQocC5zayRvYmplY3QmJmcuc2skb2JqZWN0LFwiSlMgb2JqZWN0IHBhc3NlZCB0byByaWNoQ29tcGFyZUJvb2xcIik7dmFyIG49cC5vYiR0eXBlLG09Zy5vYiR0eXBlLGs9bSE9PW4mJnZvaWQgMD09PW0uc2skYmFzZUNsYXNzJiZtLiRpc1N1YlR5cGUobik7aWYoIVNrLl9fZnV0dXJlX18ucHl0aG9uMyYmbiE9PW0mJihcIkd0RVwiPT09YXx8XCJHdFwiPT09YXx8XCJMdEVcIj09PVxuYXx8XCJMdFwiPT09YSkpe3ZhciB1PVtTay5idWlsdGluLmZsb2F0XyxTay5idWlsdGluLmludF8sU2suYnVpbHRpbi5sbmcsU2suYnVpbHRpbi5ib29sXTtjb25zdCBxPVtTay5idWlsdGluLmRpY3QsU2suYnVpbHRpbi5lbnVtZXJhdGUsU2suYnVpbHRpbi5maWx0ZXJfLFNrLmJ1aWx0aW4ubGlzdCxTay5idWlsdGluLm1hcF8sU2suYnVpbHRpbi5zdHIsU2suYnVpbHRpbi50dXBsZSxTay5idWlsdGluLnppcF9dO3ZhciBsPXUuaW5kZXhPZihuKTtuPXEuaW5kZXhPZihuKTt1PXUuaW5kZXhPZihtKTttPXEuaW5kZXhPZihtKTtpZihwPT09U2suYnVpbHRpbi5ub25lLm5vbmUkKXN3aXRjaChhKXtjYXNlIFwiTHRcIjpyZXR1cm4hMDtjYXNlIFwiTHRFXCI6cmV0dXJuITA7Y2FzZSBcIkd0XCI6cmV0dXJuITE7Y2FzZSBcIkd0RVwiOnJldHVybiExfWlmKGc9PT1Tay5idWlsdGluLm5vbmUubm9uZSQpc3dpdGNoKGEpe2Nhc2UgXCJMdFwiOnJldHVybiExO2Nhc2UgXCJMdEVcIjpyZXR1cm4hMTtjYXNlIFwiR3RcIjpyZXR1cm4hMDtcbmNhc2UgXCJHdEVcIjpyZXR1cm4hMH1pZigtMSE9PWwmJi0xIT09bSlzd2l0Y2goYSl7Y2FzZSBcIkx0XCI6cmV0dXJuITA7Y2FzZSBcIkx0RVwiOnJldHVybiEwO2Nhc2UgXCJHdFwiOnJldHVybiExO2Nhc2UgXCJHdEVcIjpyZXR1cm4hMX1pZigtMSE9PW4mJi0xIT09dSlzd2l0Y2goYSl7Y2FzZSBcIkx0XCI6cmV0dXJuITE7Y2FzZSBcIkx0RVwiOnJldHVybiExO2Nhc2UgXCJHdFwiOnJldHVybiEwO2Nhc2UgXCJHdEVcIjpyZXR1cm4hMH1pZigtMSE9PW4mJi0xIT09bSlzd2l0Y2goYSl7Y2FzZSBcIkx0XCI6cmV0dXJuIG48bTtjYXNlIFwiTHRFXCI6cmV0dXJuIG48PW07Y2FzZSBcIkd0XCI6cmV0dXJuIG4+bTtjYXNlIFwiR3RFXCI6cmV0dXJuIG4+PW19fWlmKFwiSXNcIj09PWEpcmV0dXJuIHA9PT1nO2lmKFwiSXNOb3RcIj09PWEpcmV0dXJuIHAhPT1nO2lmKFwiSW5cIj09PWEpcmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmFic3RyLnNlcXVlbmNlQ29udGFpbnMoZyxwLGMpLFNrLm1pc2NldmFsLmlzVHJ1ZSk7aWYoXCJOb3RJblwiPT09XG5hKXJldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5hYnN0ci5zZXF1ZW5jZUNvbnRhaW5zKGcscCxjKSxmdW5jdGlvbihxKXtyZXR1cm4hU2subWlzY2V2YWwuaXNUcnVlKHEpfSk7bT17RXE6XCJvYiRlcVwiLE5vdEVxOlwib2IkbmVcIixHdDpcIm9iJGd0XCIsR3RFOlwib2IkZ2VcIixMdDpcIm9iJGx0XCIsTHRFOlwib2IkbGVcIn07bD1tW2FdO2lmKGsmJihjPW1bU2subWlzY2V2YWwuc3dhcHBlZE9wX1thXV0sKGM9Z1tjXShwKSkhPT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCl8fChjPXBbbF0oZykpIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR8fCFrJiYoYz1tW1NrLm1pc2NldmFsLnN3YXBwZWRPcF9bYV1dLChjPWdbY10ocCkpIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpKXJldHVybiBTay5taXNjZXZhbC5pc1RydWUoYyk7aWYoIVNrLl9fZnV0dXJlX18ucHl0aG9uMyl7aWYoaz1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKHAsXG5Tay5idWlsdGluLnN0ci4kY21wKSl0cnl7Yz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoayxbZ10pO2lmKFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYykpe2M9U2suYnVpbHRpbi5hc251bSQoYyk7aWYoXCJFcVwiPT09YSlyZXR1cm4gMD09PWM7aWYoXCJOb3RFcVwiPT09YSlyZXR1cm4gMCE9PWM7aWYoXCJMdFwiPT09YSlyZXR1cm4gMD5jO2lmKFwiR3RcIj09PWEpcmV0dXJuIDA8YztpZihcIkx0RVwiPT09YSlyZXR1cm4gMD49YztpZihcIkd0RVwiPT09YSlyZXR1cm4gMDw9Y31pZihjIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGFyaXNvbiBkaWQgbm90IHJldHVybiBhbiBpbnRcIik7fWNhdGNoKHEpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBhcmlzb24gZGlkIG5vdCByZXR1cm4gYW4gaW50XCIpO31pZihrPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoZyxTay5idWlsdGluLnN0ci4kY21wKSl0cnl7Yz1cblNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShrLFtwXSk7aWYoU2suYnVpbHRpbi5jaGVja051bWJlcihjKSl7Yz1Tay5idWlsdGluLmFzbnVtJChjKTtpZihcIkVxXCI9PT1hKXJldHVybiAwPT09YztpZihcIk5vdEVxXCI9PT1hKXJldHVybiAwIT09YztpZihcIkx0XCI9PT1hKXJldHVybiAwPGM7aWYoXCJHdFwiPT09YSlyZXR1cm4gMD5jO2lmKFwiTHRFXCI9PT1hKXJldHVybiAwPD1jO2lmKFwiR3RFXCI9PT1hKXJldHVybiAwPj1jfWlmKGMhPT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wYXJpc29uIGRpZCBub3QgcmV0dXJuIGFuIGludFwiKTt9Y2F0Y2gocSl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGFyaXNvbiBkaWQgbm90IHJldHVybiBhbiBpbnRcIik7fWlmKHA9PT1Tay5idWlsdGluLm5vbmUubm9uZSQmJmc9PT1Tay5idWlsdGluLm5vbmUubm9uZSQpe2lmKFwiRXFcIj09PWEpcmV0dXJuIHAudj09PVxuZy52O2lmKFwiTm90RXFcIj09PWEpcmV0dXJuIHAudiE9PWcudjtpZihcIkd0XCI9PT1hKXJldHVybiBwLnY+Zy52O2lmKFwiR3RFXCI9PT1hKXJldHVybiBwLnY+PWcudjtpZihcIkx0XCI9PT1hKXJldHVybiBwLnY8Zy52O2lmKFwiTHRFXCI9PT1hKXJldHVybiBwLnY8PWcudn19aWYoXCJFcVwiPT09YSlyZXR1cm4gcD09PWc7aWYoXCJOb3RFcVwiPT09YSlyZXR1cm4gcCE9PWc7cD1Tay5hYnN0ci50eXBlTmFtZShwKTtnPVNrLmFic3RyLnR5cGVOYW1lKGcpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5taXNjZXZhbC5vcFN5bWJvbHNbYV0rXCInIG5vdCBzdXBwb3J0ZWQgYmV0d2VlbiBpbnN0YW5jZXMgb2YgJ1wiK3ArXCInIGFuZCAnXCIrZytcIidcIik7fTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2xcIixTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wpO1NrLm1pc2NldmFsLm9iamVjdFJlcHI9ZnVuY3Rpb24ocCl7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09XG5wLFwidHJ5aW5nIHRvIHJlcHIgdW5kZWZpbmVkXCIpO2lmKG51bGwhPT1wJiZwLiRyKXJldHVybiBwLiRyKCkudjt0cnl7cmV0dXJuKG5ldyBTay5idWlsdGluLnN0cihwKSkudn1jYXRjaChnKXtpZihnIGluc3RhbmNlb2YgU2suYnVpbHRpbi5UeXBlRXJyb3IpcmV0dXJuXCI8dW5rbm93bj5cIjt0aHJvdyBnO319O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLm9iamVjdFJlcHJcIixTay5taXNjZXZhbC5vYmplY3RSZXByKTtTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5PWZ1bmN0aW9uKHApe3N3aXRjaChwKXtjYXNlIFwiTHRFXCI6Y2FzZSBcIkVxXCI6Y2FzZSBcIkd0RVwiOnJldHVybiEwfXJldHVybiExfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5XCIsU2subWlzY2V2YWwub3BBbGxvd3NFcXVhbGl0eSk7U2subWlzY2V2YWwuaXNUcnVlPWZ1bmN0aW9uKHApe3JldHVybiEwPT09cHx8cD09PVNrLmJ1aWx0aW4uYm9vbC50cnVlJD8hMDohMT09PXB8fFxucD09PVNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR8fG51bGw9PT1wfHx2b2lkIDA9PT1wPyExOnAubmIkYm9vbD9wLm5iJGJvb2woKTpwLnNxJGxlbmd0aD8wIT09cC5zcSRsZW5ndGgoKTohIXB9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmlzVHJ1ZVwiLFNrLm1pc2NldmFsLmlzVHJ1ZSk7U2subWlzY2V2YWwuc29mdHNwYWNlXz0hMTtTay5taXNjZXZhbC5wcmludF89ZnVuY3Rpb24ocCl7U2subWlzY2V2YWwuc29mdHNwYWNlXyYmKFwiXFxuXCIhPT1wJiZTay5vdXRwdXQoXCIgXCIpLFNrLm1pc2NldmFsLnNvZnRzcGFjZV89ITEpO3ZhciBnPW5ldyBTay5idWlsdGluLnN0cihwKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFwic3lzXCIsITEsITApLGZ1bmN0aW9uKGEpe3JldHVybiBTay5taXNjZXZhbC5hcHBseShhLiRkLnN0ZG91dC53cml0ZSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxbYS4kZC5zdGRvdXQsZ10pfSxmdW5jdGlvbigpe3ZhciBhOyhhPTA9PT1nLnYubGVuZ3RoKXx8XG4oYT1nLnZbZy52Lmxlbmd0aC0xXSxhPSEoXCJcXG5cIj09PWF8fFwiXFx0XCI9PT1hfHxcIlxcclwiPT09YSkpO2lmKGF8fFwiIFwiPT09Zy52W2cudi5sZW5ndGgtMV0pU2subWlzY2V2YWwuc29mdHNwYWNlXz0hMH0pfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5wcmludF9cIixTay5taXNjZXZhbC5wcmludF8pO1NrLm1pc2NldmFsLmxvYWRuYW1lPWZ1bmN0aW9uKHAsZyl7Zz1nW3BdO2lmKHZvaWQgMCE9PWcpcmV0dXJuIGc7Zz1Tay5idWlsdGluc1twXTtpZih2b2lkIDAhPT1nKXJldHVybiBnO3Rocm93IG5ldyBTay5idWlsdGluLk5hbWVFcnJvcihcIm5hbWUgJ1wiK1NrLnVuZml4UmVzZXJ2ZWQocCkrXCInIGlzIG5vdCBkZWZpbmVkXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwubG9hZG5hbWVcIixTay5taXNjZXZhbC5sb2FkbmFtZSk7U2subWlzY2V2YWwuY2FsbD1mdW5jdGlvbihwLGcsYSxjLG4pe249QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDQpO3JldHVybiBTay5taXNjZXZhbC5hcHBseShwLFxuZyxhLGMsbil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxcIixTay5taXNjZXZhbC5jYWxsKTtTay5taXNjZXZhbC5jYWxsQXN5bmM9ZnVuY3Rpb24ocCxnLGEsYyxuLG0pe209QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDUpO3JldHVybiBTay5taXNjZXZhbC5hcHBseUFzeW5jKHAsZyxhLGMsbixtKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2FsbEFzeW5jXCIsU2subWlzY2V2YWwuY2FsbEFzeW5jKTtTay5taXNjZXZhbC5jYWxsT3JTdXNwZW5kPWZ1bmN0aW9uKHAsZyxhLGMsbil7bj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsNCk7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKHAsZyxhLGMsbil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxPclN1c3BlbmRcIixTay5taXNjZXZhbC5jYWxsT3JTdXNwZW5kKTtTay5taXNjZXZhbC5jYWxsc2ltPWZ1bmN0aW9uKHAsZyl7Zz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsXG4xKTtyZXR1cm4gU2subWlzY2V2YWwuYXBwbHkocCx2b2lkIDAsdm9pZCAwLHZvaWQgMCxnKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2FsbHNpbVwiLFNrLm1pc2NldmFsLmNhbGxzaW0pO1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheT1mdW5jdGlvbihwLGcsYSl7Zz1nfHxbXTtyZXR1cm4gU2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShwLGcsYSkpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltQXJyYXlcIixTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkpO1NrLm1pc2NldmFsLmNhbGxzaW1Bc3luYz1mdW5jdGlvbihwLGcsYSl7YT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5QXN5bmMocCxnLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGEpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltQXN5bmNcIixcblNrLm1pc2NldmFsLmNhbGxzaW1Bc3luYyk7U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZD1mdW5jdGlvbihwLGcpe2c9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGcpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kXCIsU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZCk7U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5PWZ1bmN0aW9uKHAsZyxhKXtnPWd8fFtdO3JldHVybiB2b2lkIDAhPT1wJiZwLnRwJGNhbGw/cC50cCRjYWxsKGcsYSk6U2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQocCx2b2lkIDAsdm9pZCAwLGEsZyl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheVwiLFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSk7U2subWlzY2V2YWwuYXBwbHk9XG5mdW5jdGlvbihwLGcsYSxjLG4pe3A9U2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQocCxnLGEsYyxuKTtyZXR1cm4gcCBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLlN1c3BlbnNpb24/U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHApOnB9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFwcGx5XCIsU2subWlzY2V2YWwuYXBwbHkpO1NrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlPWZ1bmN0aW9uKHAsZyl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGEsYyl7dHJ5eyhmdW5jdGlvbiBrKG0pe3RyeXtmb3IodmFyIHU9ZnVuY3Rpb24oKXt0cnl7ayhtLnJlc3VtZSgpKX1jYXRjaCh0KXtjKHQpfX0sbD1mdW5jdGlvbih0KXt0cnl7bS5kYXRhLnJlc3VsdD10LHUoKX1jYXRjaCh4KXtjKHgpfX0scT1mdW5jdGlvbih0KXt0cnl7bS5kYXRhLmVycm9yPXQsdSgpfWNhdGNoKHgpe2MoeCl9fTttIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbjspe3ZhciB6PVxuZyYmKGdbbS5kYXRhLnR5cGVdfHxnW1wiKlwiXSk7aWYoeil7dmFyIHI9eihtKTtpZihyKXtyLnRoZW4oayxjKTtyZXR1cm59fWlmKFwiU2sucHJvbWlzZVwiPT1tLmRhdGEudHlwZSl7bS5kYXRhLnByb21pc2UudGhlbihsLHEpO3JldHVybn1pZihcIlNrLnlpZWxkXCI9PW0uZGF0YS50eXBlKXtTay5nbG9iYWwuc2V0SW1tZWRpYXRlKHUpO3JldHVybn1pZihcIlNrLmRlbGF5XCI9PW0uZGF0YS50eXBlKXtTay5nbG9iYWwuc2V0SW1tZWRpYXRlKHUpO3JldHVybn1pZihtLm9wdGlvbmFsKW09bS5yZXN1bWUoKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlN1c3BlbnNpb25FcnJvcihcIlVuaGFuZGxlZCBub24tb3B0aW9uYWwgc3VzcGVuc2lvbiBvZiB0eXBlICdcIittLmRhdGEudHlwZStcIidcIik7fWEobSl9Y2F0Y2godCl7Yyh0KX19KShwKCkpfWNhdGNoKG4pe2Mobil9fSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlXCIsU2subWlzY2V2YWwuYXN5bmNUb1Byb21pc2UpO1xuU2subWlzY2V2YWwuYXBwbHlBc3luYz1mdW5jdGlvbihwLGcsYSxjLG4sbSl7cmV0dXJuIFNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlKGZ1bmN0aW9uKCl7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKGcsYSxjLG4sbSl9LHApfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5hcHBseUFzeW5jXCIsU2subWlzY2V2YWwuYXBwbHlBc3luYyk7U2subWlzY2V2YWwuY2hhaW49ZnVuY3Rpb24ocCxnKXtmb3IodmFyIGE9MSxjPXAsbixtOzspe2lmKGE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGM7aWYoYyYmYy4kaXNTdXNwZW5zaW9uKWJyZWFrO2M9YXJndW1lbnRzW2FdKGMpO2ErK31tPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtYSk7Zm9yKG49MDtuPGFyZ3VtZW50cy5sZW5ndGgtYTtuKyspbVtuXT1hcmd1bWVudHNbYStuXTtuPTA7cmV0dXJuIGZ1bmN0aW9uIGwodSl7Zm9yKDtuPG0ubGVuZ3RoOyl7aWYodSBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLlN1c3BlbnNpb24pcmV0dXJuIG5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKGwsXG51KTt1PW1bbl0odSk7bisrfXJldHVybiB1fShjKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2hhaW5cIixTay5taXNjZXZhbC5jaGFpbik7U2subWlzY2V2YWwudHJ5Q2F0Y2g9ZnVuY3Rpb24ocCxnKXt0cnl7dmFyIGE9cCgpfWNhdGNoKGMpe3JldHVybiBnKGMpfXJldHVybiBhIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbj8ocD1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbih2b2lkIDAsYSkscC5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwudHJ5Q2F0Y2goYS5yZXN1bWUsZyl9LHApOmF9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLnRyeUNhdGNoXCIsU2subWlzY2V2YWwudHJ5Q2F0Y2gpO1NrLm1pc2NldmFsLml0ZXJGb3I9ZnVuY3Rpb24ocCxnLGEpe3ZhciBjPWEsbj1mdW5jdGlvbihtKXtjPW07cmV0dXJuIG0gaW5zdGFuY2VvZiBTay5taXNjZXZhbC5CcmVhaz9tOnAudHAkaXRlcm5leHQoITApfTtyZXR1cm4gZnVuY3Rpb24gdShrKXtmb3IoO3ZvaWQgMCE9PVxuazspe2lmKGsgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uKXJldHVybiBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbih1LGspO2lmKGs9PT1Tay5taXNjZXZhbC5CcmVha3x8ayBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLkJyZWFrKXJldHVybiBrLmJyVmFsdWU7az1Tay5taXNjZXZhbC5jaGFpbihnKGssYyksbil9cmV0dXJuIGN9KHAudHAkaXRlcm5leHQoITApKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuaXRlckZvclwiLFNrLm1pc2NldmFsLml0ZXJGb3IpO1NrLm1pc2NldmFsLml0ZXJBcnJheT1mdW5jdGlvbihwLGcsYSl7U2suYXNzZXJ0cy5hc3NlcnQoQXJyYXkuaXNBcnJheShwKSxcIml0ZXJBcmdzIHJlcXVpcmVzIGFuIGFycmF5XCIpO2xldCBjPTA7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3Ioe3RwJGl0ZXJuZXh0OigpPT5wW2MrK119LGcsYSl9O1NrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlPWZ1bmN0aW9uKHAsZyl7aWYodm9pZCAwPT09cClyZXR1cm5bXTtcbmlmKHZvaWQgMD09PXAuaHQkdHlwZSYmdm9pZCAwIT09cC5zayRhc2FycmF5KXJldHVybiBwLnNrJGFzYXJyYXkoKTtjb25zdCBhPVtdO3A9U2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHApLGM9PnthLnB1c2goYyl9KSwoKT0+YSk7cmV0dXJuIGc/cDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3cocCl9O1NrLm1pc2NldmFsLkJyZWFrPWZ1bmN0aW9uKHApe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLkJyZWFrKSlyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrKHApO3RoaXMuYnJWYWx1ZT1wfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5CcmVha1wiLFNrLm1pc2NldmFsLkJyZWFrKTtTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZD1mdW5jdGlvbihwLGcsYSxjLG4pe3ZhciBtO2lmKG51bGw9PXB8fHA9PT1Tay5idWlsdGluLm5vbmUubm9uZSQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1xuU2suYWJzdHIudHlwZU5hbWUocCkrXCInIG9iamVjdCBpcyBub3QgY2FsbGFibGVcIik7XCJmdW5jdGlvblwiPT09dHlwZW9mIHAmJnZvaWQgMD09PXAudHAkY2FsbCYmKHA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhwKSk7dmFyIGs9cC50cCRjYWxsO2lmKHZvaWQgMCE9PWspe2lmKGEpZm9yKGE9YS50cCRpdGVyKCksbT1hLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09bTttPWEudHAkaXRlcm5leHQoKSluLnB1c2gobSk7aWYoZylmb3IoYT1Tay5hYnN0ci5pdGVyKGcpLG09YS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PW07bT1hLnRwJGl0ZXJuZXh0KCkpe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKG0pKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIkZ1bmN0aW9uIGtleXdvcmRzIG11c3QgYmUgc3RyaW5nc1wiKTtjLnB1c2gobS52KTtjLnB1c2goU2suYWJzdHIub2JqZWN0R2V0SXRlbShnLG0sITEpKX1yZXR1cm4gay5jYWxsKHAsbixjLGcpfWs9cC5fX2NhbGxfXztpZih2b2lkIDAhPT1cbmspcmV0dXJuIG4udW5zaGlmdChwKSxTay5taXNjZXZhbC5hcHBseShrLGcsYSxjLG4pO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShwKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kXCIsU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQpO1NrLm1pc2NldmFsLnByb21pc2VUb1N1c3BlbnNpb249ZnVuY3Rpb24ocCl7dmFyIGc9bmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb247Zy5yZXN1bWU9ZnVuY3Rpb24oKXtpZihnLmRhdGEuZXJyb3IpdGhyb3cgZy5kYXRhLmVycm9yO3JldHVybiBnLmRhdGEucmVzdWx0fTtnLmRhdGE9e3R5cGU6XCJTay5wcm9taXNlXCIscHJvbWlzZTpwfTtyZXR1cm4gZ307U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwucHJvbWlzZVRvU3VzcGVuc2lvblwiLFNrLm1pc2NldmFsLnByb21pc2VUb1N1c3BlbnNpb24pO1NrLm1pc2NldmFsLmJ1aWxkQ2xhc3M9XG5mdW5jdGlvbihwLGcsYSxjLG4sbSl7YT1uZXcgU2suYnVpbHRpbi5zdHIoYSk7Y29uc3Qgaz1uZXcgU2suYnVpbHRpbi50dXBsZShjKTttPW18fFtdO2M9Y3x8W107bGV0IHU7dmFyIGw9ITA7Y29uc3QgcT1tLmluZGV4T2YoXCJtZXRhY2xhc3NcIik7LTE8cT8odT1tW3ErMV0sbVtxXT1tW20ubGVuZ3RoLTJdLG1bcSsxXT1tW20ubGVuZ3RoLTFdLG0ucG9wKCksbS5wb3AoKSxsPVNrLmJ1aWx0aW4uY2hlY2tDbGFzcyh1KSk6dT1jLmxlbmd0aD9jWzBdLm9iJHR5cGU6U2suYnVpbHRpbi50eXBlO2wmJih1PWYodSxjKSk7bGV0IHo9bnVsbDt1IT09U2suYnVpbHRpbi50eXBlJiYoW3osdF09aCh1LGEsayxtLGwpKTtjPSExO2xldCByPXt9O2lmKG51bGw9PT16KXo9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7ZWxzZSBpZih6LmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5kaWN0fHxkKCkpe3ZhciB0PVNrLmFic3RyLml0ZXIoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHoudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4ka2V5cykpKTtcbmZvcihsPXQudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1sO2w9dC50cCRpdGVybmV4dCgpKVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcobCkmJihyW2wudG9TdHJpbmcoKV09ei5tcCRzdWJzY3JpcHQobCkpfWVsc2Ugcj1uZXcgUHJveHkoeix0KSxjPSEwO3AuX19uYW1lX18mJihyLl9fbW9kdWxlX189cC5fX25hbWVfXyk7ZyhwLHIsdm9pZCAwPT09bj97fTpuKTtjfHxPYmplY3Qua2V5cyhyKS5mb3JFYWNoKHg9PntTay5hYnN0ci5vYmplY3RTZXRJdGVtKHosbmV3IFNrLmJ1aWx0aW4uc3RyKHgpLHJbeF0pfSk7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh1LFthLGssel0sbSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmJ1aWxkQ2xhc3NcIixTay5taXNjZXZhbC5idWlsZENsYXNzKX0sZnVuY3Rpb24oRixQKXtTay5idWlsdGluLmNhbGxhYmxlX2l0ZXJfPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImNhbGxhYmxlX2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsXG5lKXtpZighU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIml0ZXIodiwgdyk6IHYgbXVzdCBiZSBjYWxsYWJsZVwiKTt0aGlzLiRjYWxsYWJsZT1iO3RoaXMuJHNlbnRpbmVsPWU7dGhpcy4kZmxhZz0hMX0saXRlcm5leHQoYil7aWYoITAhPT10aGlzLiRmbGFnKXtpZihiKXJldHVybiBiPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLiRjYWxsYWJsZSxbXSksU2subWlzY2V2YWwuY2hhaW4oYixlPT57aWYoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGUsdGhpcy4kc2VudGluZWwsXCJFcVwiLCEwKSl0aGlzLiRmbGFnPSEwO2Vsc2UgcmV0dXJuIGV9KTtiPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLiRjYWxsYWJsZSxbXSk7aWYoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGIsdGhpcy4kc2VudGluZWwsXCJFcVwiLCExKSl0aGlzLiRmbGFnPSEwO2Vsc2UgcmV0dXJuIGJ9fSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KTtcblNrLmJ1aWx0aW4uc2VxX2l0ZXJfPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcIml0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWJ9LGl0ZXJuZXh0KGIpe2xldCBlO2U9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PnRoaXMuJHNlcS5tcCRzdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpbmRleCsrKSxiKSxkPT57aWYoZCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uSW5kZXhFcnJvcnx8ZCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbil0aGlzLmdpJHJldD1kLiR2YWx1ZXx8U2suYnVpbHRpbi5ub25lLm5vbmUkO2Vsc2UgdGhyb3cgZDt9KTtyZXR1cm4gYj9lOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhlKX0sbWV0aG9kczp7X19sZW5ndGhfaGludF9fOnskZmxhZ3M6e05vQXJnczohMH0sJG1ldGgoKXtpZih0aGlzLiRzZXEuc3EkbGVuZ3RoKXJldHVybiB0aGlzLiRzZXEuc3EkbGVuZ3RoKCktXG50aGlzLiRpbmRleDt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwibGVuIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcy4kc2VxKSk7fX19LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2FsbGFibGVfaXRlcl9cIixTay5idWlsdGluLmNhbGxhYmxlX2l0ZXJfKX0sZnVuY3Rpb24oRixQKXtTay5idWlsdGluLmxpc3Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImxpc3RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZCl7dm9pZCAwPT09ZD9kPVtdOkFycmF5LmlzQXJyYXkoZCl8fChkPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGQpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0LFwiYmFkIGNhbGwgdG8gbGlzdCwgdXNlICduZXcnIHdpdGggYW4gQXJyYXkgb2YgcHl0aG9uIG9iamVjdHNcIik7dGhpcy52PVxuZDt0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGhhc2g6U2suYnVpbHRpbi5ub25lLm5vbmUkLHRwJGRvYzpcIkJ1aWx0LWluIG11dGFibGUgc2VxdWVuY2UuXFxuXFxuSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjb25zdHJ1Y3RvciBjcmVhdGVzIGEgbmV3IGVtcHR5IGxpc3QuXFxuVGhlIGFyZ3VtZW50IG11c3QgYmUgYW4gaXRlcmFibGUgaWYgc3BlY2lmaWVkLlwiLHRwJG5ldzpTay5nZW5lcmljLm5ldyx0cCRpbml0KGQsZil7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcImxpc3RcIixmKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJsaXN0XCIsZCwwLDEpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShkWzBdLCEwKSxoPT57dGhpcy52PWh9KX0sJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIlsuLi5dXCIpO1xudGhpcy5pbiRyZXByPSEwO2NvbnN0IGQ9dGhpcy52Lm1hcChmPT5Tay5taXNjZXZhbC5vYmplY3RSZXByKGYpKTt0aGlzLmluJHJlcHI9ITE7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIltcIitkLmpvaW4oXCIsIFwiKStcIl1cIil9LHRwJHJpY2hjb21wYXJlOlNrLmdlbmVyaWMuc2VxQ29tcGFyZSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBiKHRoaXMpfSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy52Lmxlbmd0aH0sc3EkY29uY2F0KGQpe2lmKCEoZCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubGlzdCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgY29uY2F0ZW5hdGUgbGlzdCB0byBsaXN0XCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMudi5jb25jYXQoZC52KSl9LHNxJGNvbnRhaW5zKGQpe2ZvcihsZXQgZj10aGlzLnRwJGl0ZXIoKSxoPWYudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1oO2g9Zi50cCRpdGVybmV4dCgpKWlmKGg9PT1kfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaCxcbmQsXCJFcVwiKSlyZXR1cm4hMDtyZXR1cm4hMX0sc3EkcmVwZWF0KGQpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGQpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInXCIpO2Q9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGQsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtpZihkKnRoaXMudi5sZW5ndGg+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcjtjb25zdCBmPVtdO2ZvcihsZXQgaD0wO2g8ZDtoKyspZm9yKGxldCBwPTA7cDx0aGlzLnYubGVuZ3RoO3ArKylmLnB1c2godGhpcy52W3BdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChmKX0sbXAkc3Vic2NyaXB0KGQpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoZCkpcmV0dXJuIGQ9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGQsU2suYnVpbHRpbi5JbmRleEVycm9yKSxcbmQ9dGhpcy5saXN0JGluUmFuZ2UoZCxcImxpc3QgaW5kZXggb3V0IG9mIHJhbmdlXCIpLHRoaXMudltkXTtpZihkIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zbGljZSl7Y29uc3QgZj1bXTtkLnNzc2l0ZXIkKHRoaXMudi5sZW5ndGgsaD0+e2YucHVzaCh0aGlzLnZbaF0pfSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoZil9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibGlzdCBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3Igc2xpY2VzLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZCkpO30sbXAkYXNzX3N1YnNjcmlwdChkLGYpe3ZvaWQgMD09PWY/dGhpcy5kZWwkc3Vic2NyaXB0KGQpOnRoaXMuYXNzJHN1YnNjcmlwdChkLGYpfSxzcSRpbnBsYWNlX2NvbmNhdChkKXtyZXR1cm4gZD09PXRoaXM/KHRoaXMudi5wdXNoKC4uLnRoaXMudiksdGhpcyk6U2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGQpLGY9Pnt0aGlzLnYucHVzaChmKX0pLFxuKCk9PnRoaXMpfSxzcSRpbnBsYWNlX3JlcGVhdChkKXtpZighU2subWlzY2V2YWwuaXNJbmRleChkKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGQpK1wiJ1wiKTtkPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChkLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7Y29uc3QgZj10aGlzLnYubGVuZ3RoO2lmKDA+PWQpdGhpcy52Lmxlbmd0aD0wO2Vsc2UgaWYoZCpmPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3I7Zm9yKGxldCBoPTE7aDxkO2grKylmb3IobGV0IHA9MDtwPGY7cCsrKXRoaXMudi5wdXNoKHRoaXMudltwXSk7cmV0dXJuIHRoaXN9fSxtZXRob2RzOntfX3JldmVyc2VkX186eyRtZXRoKCl7cmV0dXJuIG5ldyBlKHRoaXMpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsXG4kZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBsaXN0LlwifSxjbGVhcjp7JG1ldGgoKXt0aGlzLnYubGVuZ3RoPTA7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZW1vdmUgYWxsIGl0ZW1zIGZyb20gbGlzdC5cIn0sY29weTp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLnYuc2xpY2UoMCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBhIHNoYWxsb3cgY29weSBvZiB0aGUgbGlzdC5cIn0sYXBwZW5kOnskbWV0aChkKXt0aGlzLnYucHVzaChkKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIG9iamVjdCwgLylcIiwkZG9jOlwiQXBwZW5kIG9iamVjdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlwifSxpbnNlcnQ6eyRtZXRoKGQsXG5mKXtkPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChkLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7KHtzdGFydDpkfT1Tay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydCh0aGlzLGQpKTt0aGlzLnYuc3BsaWNlKGQsMCxmKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRzZWxmLCBpbmRleCwgb2JqZWN0LCAvKVwiLCRkb2M6XCJJbnNlcnQgb2JqZWN0IGJlZm9yZSBpbmRleC5cIn0sZXh0ZW5kOnskbWV0aChkKXtyZXR1cm4gZD09PXRoaXM/KHRoaXMudi5wdXNoKC4uLnRoaXMudiksU2suYnVpbHRpbi5ub25lLm5vbmUkKTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoZCksZj0+e3RoaXMudi5wdXNoKGYpfSksKCk9PlNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgaXRlcmFibGUsIC8pXCIsJGRvYzpcIkV4dGVuZCBsaXN0IGJ5IGFwcGVuZGluZyBlbGVtZW50cyBmcm9tIHRoZSBpdGVyYWJsZS5cIn0sXG5wb3A6eyRtZXRoKGQpe2Q9dm9pZCAwPT09ZD90aGlzLnYubGVuZ3RoLTE6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGQsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtkPXRoaXMubGlzdCRpblJhbmdlKGQsXCJwb3AgaW5kZXggb3V0IG9mIHJhbmdlXCIpO2NvbnN0IGY9dGhpcy52W2RdO3RoaXMudi5zcGxpY2UoZCwxKTtyZXR1cm4gZn0sJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgaW5kZXg9LTEsIC8pXCIsJGRvYzpcIlJlbW92ZSBhbmQgcmV0dXJuIGl0ZW0gYXQgaW5kZXggKGRlZmF1bHQgbGFzdCkuXFxuXFxuUmFpc2VzIEluZGV4RXJyb3IgaWYgbGlzdCBpcyBlbXB0eSBvciBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXCJ9LHJlbW92ZTp7JG1ldGgoZCl7ZD10aGlzLmxpc3QkaW5kZXhPZihkKTtpZigtMT09PWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImxpc3QucmVtb3ZlKHgpOiB4IG5vdCBpbiBsaXN0XCIpO3RoaXMudi5zcGxpY2UoZCxcbjEpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGRvYzpcIlJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHZhbHVlLlxcblxcblJhaXNlcyBWYWx1ZUVycm9yIGlmIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudC5cIn0sc29ydDp7JG1ldGgoZCxmKXtpZihkLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzb3J0KCkgdGFrZXMgbm8gcG9zaXRpb25hbCBhcmd1bWVudHNcIik7Y29uc3QgW2gscF09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJzb3J0XCIsW1wia2V5XCIsXCJyZXZlcnNlXCJdLGQsZixbU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSRdKTtyZXR1cm4gdGhpcy5saXN0JHNvcnQodm9pZCAwLGgscCl9LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCAqLCBrZXk9Tm9uZSwgcmV2ZXJzZT1GYWxzZSlcIixcbiRkb2M6XCJTdGFibGUgc29ydCAqSU4gUExBQ0UqLlwifSxpbmRleDp7JG1ldGgoZCxmLGgpe2lmKHZvaWQgMCE9PWYmJiFTay5taXNjZXZhbC5pc0luZGV4KGYpfHx2b2lkIDAhPT1oJiYhU2subWlzY2V2YWwuaXNJbmRleChoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpO2Y9dGhpcy5saXN0JGluZGV4T2YoZCxmLGgpO2lmKC0xPT09Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIoZCkrXCIgaXMgbm90IGluIGxpc3RcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZil9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCBzdGFydD0wLCBzdG9wPXN5cy5tYXhzaXplLCAvKVwiLCRkb2M6XCJSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUuXFxuXFxuUmFpc2VzIFZhbHVlRXJyb3IgaWYgdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50LlwifSxcbmNvdW50OnskbWV0aChkKXtsZXQgZj0wO2NvbnN0IGg9dGhpcy52Lmxlbmd0aDtmb3IobGV0IHA9MDtwPGg7cCsrKWlmKHRoaXMudltwXT09PWR8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLnZbcF0sZCxcIkVxXCIpKWYrPTE7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGRvYzpcIlJldHVybiBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdmFsdWUuXCJ9LHJldmVyc2U6eyRtZXRoKCl7dGhpcy5saXN0JHJldmVyc2UoKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldmVyc2UgKklOIFBMQUNFKi5cIn19LGNsYXNzbWV0aG9kczpTay5nZW5lcmljLmNsYXNzR2V0SXRlbSxwcm90bzp7c2skYXNhcnJheSgpe3JldHVybiB0aGlzLnYuc2xpY2UoMCl9LGxpc3Qkc29ydDpmdW5jdGlvbihkLGYsXG5oKXtjb25zdCBwPW51bGwhPWYmJmYhPT1Tay5idWlsdGluLm5vbmUubm9uZSQ7dmFyIGc9bnVsbCE9ZCYmZCE9PVNrLmJ1aWx0aW4ubm9uZS5ub25lJDtsZXQgYTtpZih2b2lkIDA9PT1oKWE9ITE7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrSW50KGgpKWE9U2subWlzY2V2YWwuaXNUcnVlKGgpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZFwiKTtoPW5ldyBTay5idWlsdGluLnRpbVNvcnQodGhpcyk7dGhpcy52PVtdO2NvbnN0IGM9bmV3IFNrLmJ1aWx0aW4uaW50XygwKTtpZihwKXtoLmx0PWc/ZnVuY3Rpb24obixtKXtuPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShkLFtuWzBdLG1bMF1dKTtyZXR1cm4gU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKG4sYyxcIkx0XCIpfTpmdW5jdGlvbihuLG0pe3JldHVybiBTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woblswXSxtWzBdLFwiTHRcIil9O2ZvcihsZXQgbj0wO248aC5saXN0bGVuZ3RoO24rKyl7Zz1cbmgubGlzdC52W25dO2NvbnN0IG09U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGYsW2ddKTtoLmxpc3QudltuXT1bbSxnXX19ZWxzZSBnJiYoaC5sdD1mdW5jdGlvbihuLG0pe249U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGQsW24sbV0pO3JldHVybiBTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wobixjLFwiTHRcIil9KTthJiZoLmxpc3QubGlzdCRyZXZlcnNlKCk7aC5zb3J0KCk7YSYmaC5saXN0Lmxpc3QkcmV2ZXJzZSgpO2lmKHApZm9yKGY9MDtmPGgubGlzdGxlbmd0aDtmKyspZz1oLmxpc3QudltmXVsxXSxoLmxpc3QudltmXT1nO2Y9MDx0aGlzLnNxJGxlbmd0aCgpO3RoaXMudj1oLmxpc3QudjtpZihmKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJsaXN0IG1vZGlmaWVkIGR1cmluZyBzb3J0XCIpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LGxpc3QkaW5SYW5nZShkLGYpezA+ZCYmKGQrPXRoaXMudi5sZW5ndGgpO2lmKDA8PWQmJmQ8dGhpcy52Lmxlbmd0aClyZXR1cm4gZDtcbnRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoZik7fSxsaXN0JGluZGV4T2YoZCxmLGgpe2Zvcih7c3RhcnQ6ZixlbmQ6aH09U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxmLGgpO2Y8aCYmZjx0aGlzLnYubGVuZ3RoO2YrKylpZih0aGlzLnZbZl09PT1kfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy52W2ZdLGQsXCJFcVwiKSlyZXR1cm4gZjtyZXR1cm4tMX0sbGlzdCRyZXZlcnNlKCl7dGhpcy52LnJldmVyc2UoKX0sYXNzJHN1YnNjcmlwdChkLGYpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoZCkpdGhpcy5hc3MkaW5kZXgoZCxmKTtlbHNlIGlmKGQgaW5zdGFuY2VvZiBTay5idWlsdGluLnNsaWNlKXtjb25zdCB7c3RhcnQ6aCxzdG9wOnAsc3RlcDpnfT1kLnNsaWNlJGluZGljZXModGhpcy52Lmxlbmd0aCk7MT09PWc/dGhpcy5hc3Mkc2xpY2UoaCxwLGYpOnRoaXMuYXNzJGV4dF9zbGljZShkLGYpfWVsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibGlzdCBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3Igc2xpY2VzLCBub3QgXCIrXG5Tay5hYnN0ci50eXBlTmFtZShkKSk7fSxhc3MkaW5kZXgoZCxmKXtkPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChkLFNrLmJ1aWx0aW4uSW5kZXhFcnJvcik7ZD10aGlzLmxpc3QkaW5SYW5nZShkLFwibGlzdCBhc3NpZ25tZW50IGluZGV4IG91dCBvZiByYW5nZVwiKTt0aGlzLnZbZF09Zn0sYXNzJHNsaWNlKGQsZixoKXtpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbiBvbmx5IGFzc2lnbiBhbiBpdGVyYWJsZVwiKTtoPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGgpO3RoaXMudi5zcGxpY2UoZCxmLWQsLi4uaCl9LGFzcyRleHRfc2xpY2UoZCxmKXtjb25zdCBoPVtdO2Quc3NzaXRlciQodGhpcy52Lmxlbmd0aCxwPT57aC5wdXNoKHApfSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShmKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJtdXN0IGFzc2lnbiBpdGVyYWJsZSB0byBleHRlbmRlZCBzbGljZVwiKTtcbmQ9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZik7aWYoaC5sZW5ndGghPT1kLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiYXR0ZW1wdCB0byBhc3NpZ24gc2VxdWVuY2Ugb2Ygc2l6ZSBcIitkLmxlbmd0aCtcIiB0byBleHRlbmRlZCBzbGljZSBvZiBzaXplIFwiK2gubGVuZ3RoKTtmb3IoZj0wO2Y8aC5sZW5ndGg7ZisrKXRoaXMudi5zcGxpY2UoaFtmXSwxLGRbZl0pfSxkZWwkc3Vic2NyaXB0KGQpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoZCkpdGhpcy5kZWwkaW5kZXgoZCk7ZWxzZSBpZihkIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zbGljZSl7Y29uc3Qge3N0YXJ0OmYsc3RvcDpoLHN0ZXA6cH09ZC5zbGljZSRpbmRpY2VzKHRoaXMudi5sZW5ndGgpOzE9PT1wP3RoaXMuZGVsJHNsaWNlKGYsaCk6dGhpcy5kZWwkZXh0X3NsaWNlKGQsMDxwPzE6MCl9ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJsaXN0IGluZGljZXMgbXVzdCBiZSBpbnRlZ2Vycywgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUoZCkpO30sZGVsJGluZGV4KGQpe2Q9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGQsU2suYnVpbHRpbi5JbmRleEVycm9yKTtkPXRoaXMubGlzdCRpblJhbmdlKGQsXCJsaXN0IGFzc2lnbm1lbnQgaW5kZXggb3V0IG9mIHJhbmdlXCIpO3RoaXMudi5zcGxpY2UoZCwxKX0sZGVsJHNsaWNlKGQsZil7dGhpcy52LnNwbGljZShkLGYtZCl9LGRlbCRleHRfc2xpY2UoZCxmKXtsZXQgaD0wO2Quc3NzaXRlciQodGhpcy52Lmxlbmd0aCxwPT57dGhpcy52LnNwbGljZShwLWgsMSk7aCs9Zn0pfSx2YWx1ZU9mKCl7cmV0dXJuIHRoaXMudn19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5saXN0XCIsU2suYnVpbHRpbi5saXN0KTtTay5idWlsdGluLmxpc3QucHkyJG1ldGhvZHM9e3NvcnQ6eyRuYW1lOlwic29ydFwiLCRtZXRoKGQsZil7Y29uc3QgW2gscCxnXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcInNvcnRcIixbXCJjbXBcIixcImtleVwiLFwicmV2ZXJzZVwiXSxcbmQsZixbU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLmJvb2wuZmFsc2UkXSk7cmV0dXJuIHRoaXMubGlzdCRzb3J0KGgscCxnKX0sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGNtcD1Ob25lLCBrZXk9Tm9uZSwgcmV2ZXJzZT1GYWxzZSlcIiwkZG9jOlwiU3RhYmxlIHNvcnQgKklOIFBMQUNFKi5cIn19O3ZhciBiPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImxpc3RfaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZCl7dGhpcy4kaW5kZXg9MDt0aGlzLiRzZXE9ZC52fSxpdGVybmV4dDpTay5nZW5lcmljLml0ZXJOZXh0V2l0aEFycmF5LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJMZW5ndGhIaW50V2l0aEFycmF5TWV0aG9kRGVmfSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KSxlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImxpc3RfcmV2ZXJzZWl0ZXJhdG9yXCIsXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oZCl7dGhpcy4kaW5kZXg9ZC52Lmxlbmd0aC0xO3RoaXMuJHNlcT1kLnZ9LGl0ZXJuZXh0KCl7Y29uc3QgZD10aGlzLiRzZXFbdGhpcy4kaW5kZXgtLV07aWYodm9pZCAwPT09ZCl0aGlzLnRwJGl0ZXJuZXh0PSgpPT57fTtlbHNlIHJldHVybiBkfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyUmV2ZXJzZUxlbmd0aEhpbnRNZXRob2REZWZ9LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pfSxmdW5jdGlvbihGLFAsYil7ZnVuY3Rpb24gZShFKXt2YXIgSD1FLnJlcGxhY2UodixcIlwiKS5yZXBsYWNlKEIsXCJfXCIpLnRvTG93ZXJDYXNlKCk7SD14W0hdO3JldHVybiB2b2lkIDA9PT1IP0U6SH1mdW5jdGlvbiBkKEUsSCx5KXtpZih2b2lkIDA9PT1IKUg9XCJ1dGYtOFwiO2Vsc2UgaWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhIKSlIPUguJGpzc3RyKCk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoRStcblwiKCkgYXJndW1lbnQgXCIrKFwiYnl0ZXNzdHJcIi5pbmNsdWRlcyhFKT8yOjEpK1wiIG11c3QgYmUgc3RyIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShIKSk7aWYodm9pZCAwPT09eSl5PVwic3RyaWN0XCI7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKHkpKXk9eS4kanNzdHIoKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihFK1wiKCkgYXJndW1lbnQgXCIrKFwiYnl0ZXNzdHJcIi5pbmNsdWRlcyhFKT8zOjIpK1wiIG11c3QgYmUgc3RyIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZSh5KSk7cmV0dXJue2VuY29kaW5nOkgsZXJyb3JzOnl9fWZ1bmN0aW9uIGYoRSxILHkpe0U9RS4kanNzdHIoKTtIPWUoSCk7aWYoXCJzdHJpY3RcIiE9PXkmJlwiaWdub3JlXCIhPT15JiZcInJlcGxhY2VcIiE9PXkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcIidcIit5K1wiJyBlcnJvciBoYW5kbGluZyBub3QgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XCIpO2lmKFwiYXNjaWlcIj09PUgpe0g9XG5bXTtmb3IoQSBpbiBFKXtjb25zdCBKPUUuY2hhckNvZGVBdChBKTtpZigxMjc8Sil7aWYoXCJzdHJpY3RcIj09PXkpdGhyb3cgeT1oKEopLG5ldyBTay5idWlsdGluLlVuaWNvZGVFbmNvZGVFcnJvcihcIidhc2NpaScgY29kZWMgY2FuJ3QgZW5jb2RlIGNoYXJhY3RlciAnXCIreStcIicgaW4gcG9zaXRpb24gXCIrQStcIjogb3JkaW5hbCBub3QgaW4gcmFuZ2UoMTI4KVwiKTtcInJlcGxhY2VcIj09PXkmJkgucHVzaCg2Myl9ZWxzZSBILnB1c2goSil9dmFyIEE9bmV3IFVpbnQ4QXJyYXkoSCl9ZWxzZSBpZihcInV0Zi04XCI9PT1IKUE9SS5lbmNvZGUoRSk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5Mb29rdXBFcnJvcihcInVua25vd24gZW5jb2Rpbmc6IFwiK0gpO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhBKX1mdW5jdGlvbiBoKEUpe3ZhciBIPTI2NT49RT9cIlxcXFx4XCI6XCJcXFxcdVwiO0U9RS50b1N0cmluZygxNik7Mz09PUUubGVuZ3RoJiYoRT1FLnNsaWNlKDEsMykpO3JldHVybiBFPTE9PT1FLmxlbmd0aD9cbkgrXCIwXCIrRTpIK0V9ZnVuY3Rpb24gcChFLEgpeyh7ZW5jb2Rpbmc6RSxlcnJvcnM6SH09ZChcImRlY29kZVwiLEUsSCkpO0U9ZShFKTtpZihcInN0cmljdFwiIT09SCYmXCJpZ25vcmVcIiE9PUgmJlwicmVwbGFjZVwiIT09SCl0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiJ1wiK0grXCInIGVycm9yIGhhbmRsaW5nIG5vdCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcIik7aWYoXCJhc2NpaVwiPT09RSl7RT10aGlzLnY7dmFyIHk9XCJcIjtmb3IobGV0IEE9MDtBPEUubGVuZ3RoO0ErKyl7Y29uc3QgSj1FW0FdO2lmKDEyNzxKKXtpZihcInN0cmljdFwiPT09SCl0aHJvdyBuZXcgU2suYnVpbHRpbi5Vbmljb2RlRGVjb2RlRXJyb3IoXCInYXNjaWknIGNvZGVjIGNhbid0IGRlY29kZSBieXRlIDB4XCIrSi50b1N0cmluZygxNikrXCIgaW4gcG9zaXRpb24gXCIrQStcIjogb3JkaW5hbCBub3QgaW4gcmFuZ2UoMTI4KVwiKTtcInJlcGxhY2VcIj09PUgmJih5Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTMzKSl9ZWxzZSB5Kz1cblN0cmluZy5mcm9tQ2hhckNvZGUoSil9RT15fWVsc2UgaWYoXCJ1dGYtOFwiPT09RSlhOmlmKEU9dGhpcy52LHk9SCxIPU0uZGVjb2RlKEUpLFwicmVwbGFjZVwiPT09eSlFPUg7ZWxzZXtpZihcInN0cmljdFwiPT09eSl7eT1ILmluZGV4T2YoXCJcXHVmZmZkXCIpO2lmKC0xPT09eSl7RT1IO2JyZWFrIGF9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yKFwiJ3V0Zi04JyBjb2RlYyBjYW4ndCBkZWNvZGUgYnl0ZSAweFwiK0VbeV0udG9TdHJpbmcoMTYpK1wiIGluIHBvc2l0aW9uIFwiK3krXCI6IGludmFsaWQgc3RhcnQgYnl0ZVwiKTt9RT1ILnJlcGxhY2UoL1xcdWZmZmQvZyxcIlwiKX1lbHNlIHRocm93IG5ldyBTay5idWlsdGluLkxvb2t1cEVycm9yKFwidW5rbm93biBlbmNvZGluZzogXCIrRSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihFKX1mdW5jdGlvbiBnKEUsSCl7cmV0dXJuIGZ1bmN0aW9uKHksQSxKKXtpZighKHkgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzfHx5IGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4udHVwbGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihFK1wiIGZpcnN0IGFyZyBtdXN0IGJlIGJ5dGVzIG9yIGEgdHVwbGUgb2YgYnl0ZXMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZSh5KSk7KHtzdGFydDpBLGVuZDpKfT1Tay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydCh0aGlzLEEsSikpO2lmKEo8QSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtBPXRoaXMudi5zdWJhcnJheShBLEopO2lmKHkgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKXtmb3IobGV0IFE9U2suYWJzdHIuaXRlcih5KSxYPVEudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1YO1g9US50cCRpdGVybmV4dCgpKWlmKFg9dGhpcy5nZXQkcmF3KFgpLEgoQSxYKSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO3JldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkfXJldHVybiBIKEEseS52KT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH19XG5mdW5jdGlvbiBhKEUpe3JldHVybiBmdW5jdGlvbihILHksQSl7SD10aGlzLmdldCR0Z3QoSCk7KHtzdGFydDp5LGVuZDpBfT1Tay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydCh0aGlzLHksQSkpO3JldHVybiBBPHk/LTE6XCJudW1iZXJcIj09PXR5cGVvZiBIPyhIPUU/dGhpcy52Lmxhc3RJbmRleE9mKEgsQS0xKTp0aGlzLnYuaW5kZXhPZihILHkpLEg+PXkmJkg8QT9IOi0xKTpFP3RoaXMuZmluZCRzdWJyaWdodChILHksQSk6dGhpcy5maW5kJHN1YmxlZnQoSCx5LEEpfX1mdW5jdGlvbiBjKEUpe3JldHVybiBmdW5jdGlvbihIKXtIPXRoaXMuZ2V0JHJhdyhIKTtsZXQgeTtpZihFKXtpZih5PXRoaXMuZmluZCRzdWJyaWdodChILDAsdGhpcy52Lmxlbmd0aCksMD55KXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uYnl0ZXMsbmV3IFNrLmJ1aWx0aW4uYnl0ZXMsdGhpc10pfWVsc2UgaWYoeT10aGlzLmZpbmQkc3VibGVmdChILDAsdGhpcy52Lmxlbmd0aCksXG4wPnkpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt0aGlzLG5ldyBTay5idWlsdGluLmJ5dGVzLG5ldyBTay5idWlsdGluLmJ5dGVzXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoMCx5KSksbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoSCksbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KHkrSC5sZW5ndGgpKV0pfX1mdW5jdGlvbiBuKEUsSCl7cmV0dXJuIGZ1bmN0aW9uKHkpe3ZhciBBPXZvaWQgMD09PXl8fHk9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/bmV3IFVpbnQ4QXJyYXkoWzksMTAsMTEsMTIsMTMsMzIsMTMzXSk6dGhpcy5nZXQkcmF3KHkpO3k9MDt2YXIgSj10aGlzLnYubGVuZ3RoO2lmKEUpZm9yKDt5PEomJkEuaW5jbHVkZXModGhpcy52W3ldKTspeSsrO2lmKEgpZm9yKDtKPnkmJkEuaW5jbHVkZXModGhpcy52W0otMV0pOylKLS07QT1uZXcgVWludDhBcnJheShKLXkpO2ZvcihKPVxuMDtKPEEubGVuZ3RoO0orKylBW0pdPXRoaXMudltKK3ldO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhBKX19ZnVuY3Rpb24gbShFLEgseSl7cmV0dXJuIGZ1bmN0aW9uKEEsSil7aWYodm9pZCAwPT09SilKPTMyO2Vsc2UgaWYoSiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXMmJjE9PUoudi5sZW5ndGgpSj1KLnZbMF07ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoRStcIigpIGFyZ3VtZW50IDIgbXVzdCBiZSBhIGJ5dGUgc3RyaW5nIG9mIGxlbmd0aCAxLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoSikpO2NvbnN0IFE9dGhpcy52Lmxlbmd0aDtBPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChBLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoQTw9USlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52KTtjb25zdCBYPW5ldyBVaW50OEFycmF5KEEpO2xldCBhYSxlYTt5PyhhYT1NYXRoLmZsb29yKChBLVEpLzIpLGVhPShBLVEpJTI/YWErMTpcbmFhKTpIPyhhYT1BLVEsZWE9MCk6KGFhPTAsZWE9QS1RKTtYLmZpbGwoSiwwLGFhKTtmb3IobGV0IG5hPTA7bmE8UTtuYSsrKVhbbmErYWFdPXRoaXMudltuYV07WC5maWxsKEosQS1lYSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKFgpfX1mdW5jdGlvbiBrKEUpe3JldHVybiA5PD1FJiYxMz49RXx8MzI9PT1FfWZ1bmN0aW9uIHUoRSl7cmV0dXJuIDk3PD1FJiYxMjI+PUV9ZnVuY3Rpb24gbChFKXtyZXR1cm4gNjU8PUUmJjkwPj1FfWZ1bmN0aW9uIHEoRSl7cmV0dXJuIDQ4PD1FJiY1Nz49RX1mdW5jdGlvbiB6KEUsSCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLnYubGVuZ3RoP0g/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ6dGhpcy52LmV2ZXJ5KHk9PkUoeSkpP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfX1mdW5jdGlvbiByKEUsSCl7cmV0dXJuIGZ1bmN0aW9uKCl7bGV0IHk9ITE7Zm9yKGxldCBBPVxuMDtBPHRoaXMudi5sZW5ndGg7QSsrKXtpZihIKHRoaXMudltBXSkpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7IXkmJkUodGhpcy52W0FdKSYmKHk9ITApfXJldHVybiB5P1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfX1mdW5jdGlvbiB0KEUpe3JldHVybiBmdW5jdGlvbigpe2NvbnN0IEg9bmV3IFVpbnQ4QXJyYXkodGhpcy52Lmxlbmd0aCk7Zm9yKGxldCB5PTA7eTx0aGlzLnYubGVuZ3RoO3krKylIW3ldPUUodGhpcy52W3ldKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoSCl9fWIoMzApO2NvbnN0IHg9e3V0ZjpcInV0Zi04XCIsdXRmODpcInV0Zi04XCIsdXRmXzg6XCJ1dGYtOFwiLGFzY2lpOlwiYXNjaWlcIn07dmFyIHY9L1xccysvZyxCPS9bXy1dKy9nO2NvbnN0IEk9bmV3IFRleHRFbmNvZGVyLE09bmV3IFRleHREZWNvZGVyO1NrLmJ1aWx0aW4uYnl0ZXM9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImJ5dGVzXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKEUpe2lmKCEodGhpcyBpbnN0YW5jZW9mXG5Tay5idWlsdGluLmJ5dGVzKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYnl0ZXMgaXMgYSBjb25zdHJ1Y3RvciB1c2UgJ25ldydcIik7aWYodm9pZCAwPT09RSl0aGlzLnY9bmV3IFVpbnQ4QXJyYXk7ZWxzZSBpZihFIGluc3RhbmNlb2YgVWludDhBcnJheSl0aGlzLnY9RTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoRSkpU2suYXNzZXJ0cy5hc3NlcnQoRS5ldmVyeShIPT4wPD1IJiYyNTU+PUgpLFwiYmFkIGludGVybmFsIGNhbGwgdG8gYnl0ZXMgd2l0aCBhcnJheVwiKSx0aGlzLnY9bmV3IFVpbnQ4QXJyYXkoRSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIEUpe2xldCBIO2NvbnN0IHk9bmV3IFVpbnQ4QXJyYXkoRS5sZW5ndGgpLEE9RS5sZW5ndGg7Zm9yKGxldCBKPTA7SjxBO0orKyl7SD1FLmNoYXJDb2RlQXQoSik7aWYoMjU1PEgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yKFwiaW52YWxpZCBzdHJpbmcgYXQgaW5kZXggXCIrSitcIiAocG9zc2libHkgY29udGFpbnMgYSB1bmljb2RlIGNoYXJhY3RlcilcIik7XG55W0pdPUh9dGhpcy52PXl9ZWxzZSBpZihcIm51bWJlclwiPT09dHlwZW9mIEUpdGhpcy52PW5ldyBVaW50OEFycmF5KEUpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgYmFkIGludGVybmFsIGFyZ3VtZW50IHRvIGJ5dGVzIGNvbnN0cnVjdG9yIChnb3QgJyR7dHlwZW9mIEV9JzogJHtFfSlgKTt9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRkb2M6XCJieXRlcyhpdGVyYWJsZV9vZl9pbnRzKSAtPiBieXRlc1xcbmJ5dGVzKHN0cmluZywgZW5jb2RpbmdbLCBlcnJvcnNdKSAtPiBieXRlc1xcbmJ5dGVzKGJ5dGVzX29yX2J1ZmZlcikgLT4gaW1tdXRhYmxlIGNvcHkgb2YgYnl0ZXNfb3JfYnVmZmVyXFxuYnl0ZXMoaW50KSAtPiBieXRlcyBvYmplY3Qgb2Ygc2l6ZSBnaXZlbiBieSB0aGUgcGFyYW1ldGVyIGluaXRpYWxpemVkIHdpdGggbnVsbCBieXRlc1xcbmJ5dGVzKCkgLT4gZW1wdHkgYnl0ZXMgb2JqZWN0XFxuXFxuQ29uc3RydWN0IGFuIGltbXV0YWJsZSBhcnJheSBvZiBieXRlcyBmcm9tOlxcbiAgLSBhbiBpdGVyYWJsZSB5aWVsZGluZyBpbnRlZ2VycyBpbiByYW5nZSgyNTYpXFxuICAtIGEgdGV4dCBzdHJpbmcgZW5jb2RlZCB1c2luZyB0aGUgc3BlY2lmaWVkIGVuY29kaW5nXFxuICAtIGFueSBvYmplY3QgaW1wbGVtZW50aW5nIHRoZSBidWZmZXIgQVBJLlxcbiAgLSBhbiBpbnRlZ2VyXCIsXG50cCRuZXcoRSxIKXtpZih0aGlzIT09U2suYnVpbHRpbi5ieXRlcy5wcm90b3R5cGUpcmV0dXJuIHRoaXMuJHN1YnR5cGVfbmV3KEUsSCk7SD1IfHxbXTtsZXQgeTtpZigxPj1FLmxlbmd0aCYmMD09PStILmxlbmd0aClFPUVbMF07ZWxzZXtbRSxILHldPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiYnl0ZXNcIixbbnVsbCxcInB5U291cmNlXCIsXCJlcnJvcnNcIl0sRSxIKTsoe2VuY29kaW5nOkgsZXJyb3JzOnl9PWQoXCJieXRlc1wiLEgseSkpO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKEUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImVuY29kaW5nIG9yIGVycm9ycyB3aXRob3V0IGEgc3RyaW5nIGFyZ3VtZW50XCIpO3JldHVybiBmKEUsSCx5KX1pZih2b2lkIDA9PT1FKXJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcztpZih2b2lkIDAhPT0oSD1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKEUsU2suYnVpbHRpbi5zdHIuJGJ5dGVzKSkpcmV0dXJuIEU9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KEgsXG5bXSksU2subWlzY2V2YWwuY2hhaW4oRSxBPT57aWYoIVNrLmJ1aWx0aW4uY2hlY2tCeXRlcyhBKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2J5dGVzX18gcmV0dXJuZWQgbm9uLWJ5dGVzICh0eXBlIFwiK1NrLmFic3RyLnR5cGVOYW1lKEEpK1wiKVwiKTtyZXR1cm4gQX0pO2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoRSkpe0U9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKEUsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtpZigwPkUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5lZ2F0aXZlIGNvdW50XCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhFKX1pZihTay5idWlsdGluLmNoZWNrQnl0ZXMoRSkpcmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKEUudik7aWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhFKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzdHJpbmcgYXJndW1lbnQgd2l0aG91dCBhbiBlbmNvZGluZ1wiKTtpZihTay5idWlsdGluLmNoZWNrSXRlcmFibGUoRSkpe2xldCBBPVxuW107RT1Tay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoRSksSj0+e0o9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKEopO2lmKDA+Snx8MjU1PEopdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImJ5dGVzIG11c3QgYmUgaW4gcmFuZ2UoMCwgMjU2KVwiKTtBLnB1c2goSil9KTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oRSwoKT0+bmV3IFNrLmJ1aWx0aW4uYnl0ZXMoQSkpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbm5vdCBjb252ZXJ0ICdcIitTay5hYnN0ci50eXBlTmFtZShFKStcIicgb2JqZWN0IGludG8gYnl0ZXNcIik7fSwkcigpe2xldCBFLEg9XCInXCI7Y29uc3QgeT0tMSE9PXRoaXMudi5pbmRleE9mKDM0KTtsZXQgQT1cIlwiO2ZvcihsZXQgSj0wO0o8dGhpcy52Lmxlbmd0aDtKKyspaWYoRT10aGlzLnZbSl0sOT5FfHwxMDxFJiYxMz5FfHwxMzxFJiYzMj5FfHwxMjY8RSlBKz1oKEUpO2Vsc2UgaWYoOT09PUV8fDEwPT09RXx8MTM9PT1FfHwzOT09PVxuRXx8OTI9PT1FKXN3aXRjaChFKXtjYXNlIDk6QSs9XCJcXFxcdFwiO2JyZWFrO2Nhc2UgMTA6QSs9XCJcXFxcblwiO2JyZWFrO2Nhc2UgMTM6QSs9XCJcXFxcclwiO2JyZWFrO2Nhc2UgMzk6eT9BKz1cIlxcXFwnXCI6KEErPVwiJ1wiLEg9J1wiJyk7YnJlYWs7Y2FzZSA5MjpBKz1cIlxcXFxcXFxcXCJ9ZWxzZSBBKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJiXCIrSCtBK0gpfSx0cCRzdHIoKXtyZXR1cm4gdGhpcy4kcigpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBTKHRoaXMpfSx0cCRyaWNoY29tcGFyZShFLEgpe2lmKHRoaXM9PT1FJiZTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5KEgpKXJldHVybiEwO2lmKCEoRSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXMpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCB5PXRoaXMudjtFPUUudjtpZih5Lmxlbmd0aCE9PUUubGVuZ3RoJiYoXCJFcVwiPT09SHx8XCJOb3RFcVwiPT09SCkpcmV0dXJuXCJFcVwiPT09XG5IPyExOiEwO2xldCBBO2NvbnN0IEo9TWF0aC5taW4oeS5sZW5ndGgsRS5sZW5ndGgpO2ZvcihBPTA7QTxKJiZ5W0FdPT09RVtBXTtBKyspO3N3aXRjaChIKXtjYXNlIFwiTHRcIjpyZXR1cm4gQT09PUomJnkubGVuZ3RoPEUubGVuZ3RofHx5W0FdPEVbQV07Y2FzZSBcIkx0RVwiOnJldHVybiBBPT09SiYmeS5sZW5ndGg8PUUubGVuZ3RofHx5W0FdPD1FW0FdO2Nhc2UgXCJFcVwiOnJldHVybiBBPT09SjtjYXNlIFwiTm90RXFcIjpyZXR1cm4gQTxKO2Nhc2UgXCJHdFwiOnJldHVybiBBPT09SiYmeS5sZW5ndGg+RS5sZW5ndGh8fHlbQV0+RVtBXTtjYXNlIFwiR3RFXCI6cmV0dXJuIEE9PT1KJiZ5Lmxlbmd0aD49RS5sZW5ndGh8fHlbQV0+PUVbQV19fSx0cCRoYXNoKCl7cmV0dXJuKG5ldyBTay5idWlsdGluLnN0cih0aGlzLiRqc3N0cigpKSkudHAkaGFzaCgpfSx0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLG1wJHN1YnNjcmlwdChFKXtpZihTay5taXNjZXZhbC5pc0luZGV4KEUpKXtsZXQgSD1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoRSxcblNrLmJ1aWx0aW4uSW5kZXhFcnJvcik7aWYodm9pZCAwIT09SCl7MD5IJiYoSD10aGlzLnYubGVuZ3RoK0gpO2lmKDA+SHx8SD49dGhpcy52Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMudltIXSl9fWVsc2UgaWYoRSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2xpY2Upe2NvbnN0IEg9W107RS5zc3NpdGVyJCh0aGlzLnYubGVuZ3RoLHk9PntILnB1c2godGhpcy52W3ldKX0pO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhuZXcgVWludDhBcnJheShIKSl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYnl0ZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3Igc2xpY2VzLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoRSkpO30sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMudi5sZW5ndGh9LHNxJGNvbmNhdChFKXtpZighKEUgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBjb25jYXQgXCIrXG5Tay5hYnN0ci50eXBlTmFtZShFKStcIiB0byBieXRlc1wiKTtjb25zdCBIPW5ldyBVaW50OEFycmF5KHRoaXMudi5sZW5ndGgrRS52Lmxlbmd0aCk7bGV0IHk7Zm9yKHk9MDt5PHRoaXMudi5sZW5ndGg7eSsrKUhbeV09dGhpcy52W3ldO2ZvcihsZXQgQT0wO0E8RS52Lmxlbmd0aDtBKysseSsrKUhbeV09RS52W0FdO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhIKX0sc3EkcmVwZWF0KEUpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KEUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoRSkrXCInXCIpO0U9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKEUsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtjb25zdCBIPUUqdGhpcy52Lmxlbmd0aDtpZihIPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3I7aWYoMD49XG5FKXJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcztFPW5ldyBVaW50OEFycmF5KEgpO2xldCB5PTA7Zm9yKDt5PEg7KWZvcihsZXQgQT0wO0E8dGhpcy52Lmxlbmd0aDtBKyspRVt5KytdPXRoaXMudltBXTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoRSl9LHNxJGNvbnRhaW5zKEUpe3JldHVybi0xIT09dGhpcy5maW5kJGxlZnQoRSl9LHRwJGFzX251bWJlcjohMCxuYiRyZW1haW5kZXI6U2suYnVpbHRpbi5zdHIucHJvdG90eXBlLm5iJHJlbWFpbmRlcn0scHJvdG86eyRqc3N0cigpe2xldCBFPVwiXCI7Zm9yKGxldCBIPTA7SDx0aGlzLnYubGVuZ3RoO0grKylFKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMudltIXSk7cmV0dXJuIEV9LGdldCR0Z3QoRSl7aWYoRSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXMpcmV0dXJuIEUudjtFPVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KEUsXCJhcmd1bWVudCBzaG91bGQgYmUgaW50ZWdlciBvciBieXRlcy1saWtlIG9iamVjdCwgbm90IHt0cCRuYW1lfVwiKTtcbmlmKDA+RXx8MjU1PEUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImJ5dGVzIG11c3QgYmUgaW4gcmFuZ2UoMCwgMjU2KVwiKTtyZXR1cm4gRX0sZ2V0JHJhdyhFKXtpZihFIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ieXRlcylyZXR1cm4gRS52O3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImEgYnl0ZXMtbGlrZSBvYmplY3QgaXMgcmVxdWlyZWQsIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoRSkrXCInXCIpO30sZ2V0JHNwbGl0QXJnczpmdW5jdGlvbihFLEgpe0g9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKEgsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtIPTA+SD9JbmZpbml0eTpIO0U9U2suYnVpbHRpbi5jaGVja05vbmUoRSk/bnVsbDp0aGlzLmdldCRyYXcoRSk7aWYobnVsbCE9PUUmJiFFLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiZW1wdHkgc2VwYXJhdG9yXCIpO3JldHVybntzZXA6RSxtYXhzcGxpdDpIfX0sZmluZCRsZWZ0OmEoITEpLFxuZmluZCRyaWdodDphKCEwKSxmaW5kJHN1YmxlZnQ6ZnVuY3Rpb24oRSxILHkpe3k9eS1FLmxlbmd0aCsxO2xldCBBPUg7Zm9yKDtBPHk7KXtpZihFLmV2ZXJ5KChKLFEpPT5KPT09dGhpcy52W0ErUV0pKXJldHVybiBBO0ErK31yZXR1cm4tMX0sZmluZCRzdWJyaWdodChFLEgseSl7bGV0IEE9eS1FLmxlbmd0aDtmb3IoO0E+PUg7KXtpZihFLmV2ZXJ5KChKLFEpPT5KPT09dGhpcy52W0ErUV0pKXJldHVybiBBO0EtLX1yZXR1cm4tMX0sJHN1YnR5cGVfbmV3KEUsSCl7Y29uc3QgeT1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtFPVNrLmJ1aWx0aW4uYnl0ZXMucHJvdG90eXBlLnRwJG5ldyhFLEgpO3kudj1FLnY7cmV0dXJuIHl9LHNrJGFzYXJyYXkoKXtjb25zdCBFPVtdO3RoaXMudi5mb3JFYWNoKEg9PntFLnB1c2gobmV3IFNrLmJ1aWx0aW4uaW50XyhIKSl9KTtyZXR1cm4gRX0sdmFsdWVPZigpe3JldHVybiB0aGlzLnZ9fSxmbGFnczp7c3RyJGVuY29kZTpmLCRkZWNvZGU6cCxjaGVjayRlbmNvZGVBcmdzOmR9LFxubWV0aG9kczp7X19nZXRuZXdhcmdzX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOm51bGx9LGNhcGl0YWxpemU6eyRtZXRoKCl7Y29uc3QgRT10aGlzLnYubGVuZ3RoO2lmKDA9PT1FKXJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYpO2NvbnN0IEg9bmV3IFVpbnQ4QXJyYXkoRSk7bGV0IHk9dGhpcy52WzBdO0hbMF09dSh5KT95LTMyOnk7Zm9yKGxldCBBPTE7QTxFO0ErKyl5PXRoaXMudltBXSxIW0FdPWwoeSk/eSszMjp5O3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhIKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuY2FwaXRhbGl6ZSgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aXRoIG9ubHkgaXRzIGZpcnN0IGNoYXJhY3RlciBjYXBpdGFsaXplZCAoQVNDSUkpXFxuYW5kIHRoZSByZXN0IGxvd2VyLWNhc2VkLlwifSxcbmNlbnRlcjp7JG1ldGg6bShcImNlbnRlclwiLCExLCEwKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuY2VudGVyKHdpZHRoWywgZmlsbGNoYXJdKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gQiBjZW50ZXJlZCBpbiBhIHN0cmluZyBvZiBsZW5ndGggd2lkdGguICBQYWRkaW5nIGlzXFxuZG9uZSB1c2luZyB0aGUgc3BlY2lmaWVkIGZpbGwgY2hhcmFjdGVyIChkZWZhdWx0IGlzIGEgc3BhY2UpLlwifSxjb3VudDp7JG1ldGgoRSxILHkpe0U9dGhpcy5nZXQkdGd0KEUpOyh7c3RhcnQ6SCxlbmQ6eX09U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxILHkpKTtsZXQgQT0wO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgRSlmb3IoO0g8eTtIKyspdGhpcy52W0hdPT09RSYmQSsrO2Vsc2V7eT15LUUubGVuZ3RoKzE7Zm9yKGxldCBKPUg7Sjx5O0orKylFLmV2ZXJ5KChRLFgpPT5RPT09dGhpcy52W0orWF0pJiYoQSsrLEorPUUubGVuZ3RoLTEpfXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEEpfSxcbiRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5jb3VudChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIG51bWJlciBvZiBub24tb3ZlcmxhcHBpbmcgb2NjdXJyZW5jZXMgb2Ygc3Vic2VjdGlvbiBzdWIgaW5cXG5ieXRlcyBCW3N0YXJ0OmVuZF0uICBPcHRpb25hbCBhcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWRcXG5hcyBpbiBzbGljZSBub3RhdGlvbi5cIn0sZGVjb2RlOnskbWV0aDpwLCRmbGFnczp7TmFtZWRBcmdzOltcImVuY29kaW5nXCIsXCJlcnJvcnNcIl19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBlbmNvZGluZz0ndXRmLTgnLCBlcnJvcnM9J3N0cmljdCcpXCIsJGRvYzpcIkRlY29kZSB0aGUgYnl0ZXMgdXNpbmcgdGhlIGNvZGVjIHJlZ2lzdGVyZWQgZm9yIGVuY29kaW5nLlxcblxcbiAgZW5jb2RpbmdcXG4gICAgVGhlIGVuY29kaW5nIHdpdGggd2hpY2ggdG8gZGVjb2RlIHRoZSBieXRlcy5cXG4gIGVycm9yc1xcbiAgICBUaGUgZXJyb3IgaGFuZGxpbmcgc2NoZW1lIHRvIHVzZSBmb3IgdGhlIGhhbmRsaW5nIG9mIGRlY29kaW5nIGVycm9ycy5cXG4gICAgVGhlIGRlZmF1bHQgaXMgJ3N0cmljdCcgbWVhbmluZyB0aGF0IGRlY29kaW5nIGVycm9ycyByYWlzZSBhXFxuICAgIFVuaWNvZGVEZWNvZGVFcnJvci4gT3RoZXIgcG9zc2libGUgdmFsdWVzIGFyZSAnaWdub3JlJyBhbmQgJ3JlcGxhY2UnXFxuICAgIGFzIHdlbGwgYXMgYW55IG90aGVyIG5hbWUgcmVnaXN0ZXJlZCB3aXRoIGNvZGVjcy5yZWdpc3Rlcl9lcnJvciB0aGF0XFxuICAgIGNhbiBoYW5kbGUgVW5pY29kZURlY29kZUVycm9ycy5cIn0sXG5lbmRzd2l0aDp7JG1ldGg6ZyhcImVuZHN3aXRoXCIsKEUsSCk9Pntjb25zdCB5PUUubGVuZ3RoLUgubGVuZ3RoO3JldHVybiAwPD15JiZILmV2ZXJ5KChBLEopPT5BPT09RVt5K0pdKX0pLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5lbmRzd2l0aChzdWZmaXhbLCBzdGFydFssIGVuZF1dKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgQiBlbmRzIHdpdGggdGhlIHNwZWNpZmllZCBzdWZmaXgsIEZhbHNlIG90aGVyd2lzZS5cXG5XaXRoIG9wdGlvbmFsIHN0YXJ0LCB0ZXN0IEIgYmVnaW5uaW5nIGF0IHRoYXQgcG9zaXRpb24uXFxuV2l0aCBvcHRpb25hbCBlbmQsIHN0b3AgY29tcGFyaW5nIEIgYXQgdGhhdCBwb3NpdGlvbi5cXG5zdWZmaXggY2FuIGFsc28gYmUgYSB0dXBsZSBvZiBieXRlcyB0byB0cnkuXCJ9LGV4cGFuZHRhYnM6eyRtZXRoKEUpe0U9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKEUsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yLFwiYW4gaW50ZWdlciBpcyByZXF1aXJlZCAoZ290IHR5cGUge3RwJG5hbX0pXCIpO1xuY29uc3QgSD1bXTtsZXQgeT0wO2ZvcihsZXQgSj0wO0o8dGhpcy52Lmxlbmd0aDtKKyspe3ZhciBBPXRoaXMudltKXTs5PT09QT8oQT1FLXklRSxILnB1c2goLi4uQXJyYXkoQSkuZmlsbCgzMikpLHkrPUEpOjEwPT09QXx8MTM9PT1BPyhILnB1c2goQSkseT0wKTooSC5wdXNoKEEpLHkrKyl9cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKG5ldyBVaW50OEFycmF5KEgpKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1widGFic2l6ZVwiXSxEZWZhdWx0czpbOF19LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuZXhwYW5kdGFicyh0YWJzaXplPTgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aGVyZSBhbGwgdGFiIGNoYXJhY3RlcnMgYXJlIGV4cGFuZGVkIHVzaW5nIHNwYWNlcy5cXG5JZiB0YWJzaXplIGlzIG5vdCBnaXZlbiwgYSB0YWIgc2l6ZSBvZiA4IGNoYXJhY3RlcnMgaXMgYXNzdW1lZC5cIn0sZmluZDp7JG1ldGg6ZnVuY3Rpb24oRSxILHkpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuZmluZCRsZWZ0KEUsXG5ILHkpKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmZpbmQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBsb3dlc3QgaW5kZXggaW4gQiB3aGVyZSBzdWJzZWN0aW9uIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gQltzdGFydCxlbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmV0dXJuIC0xIG9uIGZhaWx1cmUuXCJ9LGhleDp7JG1ldGgoKXtsZXQgRT1cIlwiO2ZvcihsZXQgSD0wO0g8dGhpcy52Lmxlbmd0aDtIKyspRSs9dGhpcy52W0hdLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLFwiMFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKEUpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5oZXgoKSAtPiBzdHJpbmdcXG5cXG5DcmVhdGUgYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgbnVtYmVycyBmcm9tIGEgYnl0ZXMgb2JqZWN0LlxcbkV4YW1wbGU6IGInXFxcXHhiOVxcXFx4MDFcXFxceGVmJy5oZXgoKSAtPiAnYjkwMWVmJy5cIn0sXG5pbmRleDp7JG1ldGg6ZnVuY3Rpb24oRSxILHkpe0U9dGhpcy5maW5kJGxlZnQoRSxILHkpO2lmKC0xPT09RSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwic3Vic2VjdGlvbiBub3QgZm91bmRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oRSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5pbmRleChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGxvd2VzdCBpbmRleCBpbiBCIHdoZXJlIHN1YnNlY3Rpb24gc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBCW3N0YXJ0LGVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciB3aGVuIHRoZSBzdWJzZWN0aW9uIGlzIG5vdCBmb3VuZC5cIn0saXNhbG51bTp7JG1ldGg6eihFPT5xKEUpfHxcbnUoRSl8fGwoRSkpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmlzYWxudW0oKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgYWxsIGNoYXJhY3RlcnMgaW4gQiBhcmUgYWxwaGFudW1lcmljXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2FscGhhOnskbWV0aDp6KEU9PjY1PD1FJiY5MD49RXx8OTc8PUUmJjEyMj49RSksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNhbHBoYSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiBCIGFyZSBhbHBoYWJldGljXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2FzY2lpOnskbWV0aDp6KEU9PjA8PUUmJjEyNz49RSwhMCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNhc2NpaSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBCIGlzIGVtcHR5IG9yIGFsbCBjaGFyYWN0ZXJzIGluIEIgYXJlIEFTQ0lJLFxcbkZhbHNlIG90aGVyd2lzZS5cIn0sXG5pc2RpZ2l0OnskbWV0aDp6KHEpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmlzZGlnaXQoKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgYWxsIGNoYXJhY3RlcnMgaW4gQiBhcmUgZGlnaXRzXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2xvd2VyOnskbWV0aDpyKHUsbCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNsb3dlcigpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2FzZWQgY2hhcmFjdGVycyBpbiBCIGFyZSBsb3dlcmNhc2UgYW5kIHRoZXJlIGlzXFxuYXQgbGVhc3Qgb25lIGNhc2VkIGNoYXJhY3RlciBpbiBCLCBGYWxzZSBvdGhlcndpc2UuXCJ9LGlzc3BhY2U6eyRtZXRoOnooayksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNzcGFjZSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiBCIGFyZSB3aGl0ZXNwYWNlXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxcbmlzdGl0bGU6eyRtZXRoOmZ1bmN0aW9uKCl7bGV0IEU9ITEsSD0hMTtmb3IobGV0IHk9MDt5PHRoaXMudi5sZW5ndGg7eSsrKXtjb25zdCBBPXRoaXMudlt5XTtpZihsKEEpKXtpZihFKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO0g9RT0hMH1lbHNlIGlmKHUoQSkpe2lmKCFFKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO0g9ITB9ZWxzZSBFPSExfXJldHVybiBIP1NrLmJ1aWx0aW4uYm9vbC50cnVlJDpTay5idWlsdGluLmJvb2wuZmFsc2UkfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5pc3RpdGxlKCkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIEIgaXMgYSB0aXRsZWNhc2VkIHN0cmluZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXFxuY2hhcmFjdGVyIGluIEIsIGkuZS4gdXBwZXJjYXNlIGNoYXJhY3RlcnMgbWF5IG9ubHkgZm9sbG93IHVuY2FzZWRcXG5jaGFyYWN0ZXJzIGFuZCBsb3dlcmNhc2UgY2hhcmFjdGVycyBvbmx5IGNhc2VkIG9uZXMuIFJldHVybiBGYWxzZVxcbm90aGVyd2lzZS5cIn0sXG5pc3VwcGVyOnskbWV0aDpyKGwsdSksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXN1cHBlcigpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2FzZWQgY2hhcmFjdGVycyBpbiBCIGFyZSB1cHBlcmNhc2UgYW5kIHRoZXJlIGlzXFxuYXQgbGVhc3Qgb25lIGNhc2VkIGNoYXJhY3RlciBpbiBCLCBGYWxzZSBvdGhlcndpc2UuXCJ9LGpvaW46eyRtZXRoKEUpe2NvbnN0IEg9W107bGV0IHk9MDtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKEUpLEE9PntpZighKEEgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZXF1ZW5jZSBpdGVtIFwiK3krXCI6IGV4cGVjdGVkIGEgYnl0ZXMtbGlrZSBvYmplY3QsIFwiK1NrLmFic3RyLnR5cGVOYW1lKEEpK1wiIGZvdW5kXCIpO3krKztILmxlbmd0aCYmSC5wdXNoKC4uLnRoaXMudik7SC5wdXNoKC4uLkEudil9KSxcbigpPT5uZXcgU2suYnVpbHRpbi5ieXRlcyhuZXcgVWludDhBcnJheShIKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGl0ZXJhYmxlX29mX2J5dGVzLCAvKVwiLCRkb2M6XCJDb25jYXRlbmF0ZSBhbnkgbnVtYmVyIG9mIGJ5dGVzIG9iamVjdHMuXFxuXFxuVGhlIGJ5dGVzIHdob3NlIG1ldGhvZCBpcyBjYWxsZWQgaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiBlYWNoIHBhaXIuXFxuXFxuVGhlIHJlc3VsdCBpcyByZXR1cm5lZCBhcyBhIG5ldyBieXRlcyBvYmplY3QuXFxuXFxuRXhhbXBsZTogYicuJy5qb2luKFtiJ2FiJywgYidwcScsIGIncnMnXSkgLT4gYidhYi5wcS5ycycuXCJ9LGxqdXN0OnskbWV0aDptKFwibGp1c3RcIiwhMSwhMSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmxqdXN0KHdpZHRoWywgZmlsbGNoYXJdKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gQiBsZWZ0IGp1c3RpZmllZCBpbiBhIHN0cmluZyBvZiBsZW5ndGggd2lkdGguIFBhZGRpbmcgaXNcXG5kb25lIHVzaW5nIHRoZSBzcGVjaWZpZWQgZmlsbCBjaGFyYWN0ZXIgKGRlZmF1bHQgaXMgYSBzcGFjZSkuXCJ9LFxubG93ZXI6eyRtZXRoOnQoRT0+bChFKT9FKzMyOkUpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmxvd2VyKCkgLT4gY29weSBvZiBCXFxuXFxuUmV0dXJuIGEgY29weSBvZiBCIHdpdGggYWxsIEFTQ0lJIGNoYXJhY3RlcnMgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cIn0sbHN0cmlwOnskbWV0aDpuKCEwLCExKSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBieXRlcz1Ob25lLCAvKVwiLCRkb2M6XCJTdHJpcCBsZWFkaW5nIGJ5dGVzIGNvbnRhaW5lZCBpbiB0aGUgYXJndW1lbnQuXFxuXFxuSWYgdGhlIGFyZ3VtZW50IGlzIG9taXR0ZWQgb3IgTm9uZSwgc3RyaXAgbGVhZGluZyAgQVNDSUkgd2hpdGVzcGFjZS5cIn0scGFydGl0aW9uOnskbWV0aDpjKCExKSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIHNlcCwgLylcIiwkZG9jOlwiUGFydGl0aW9uIHRoZSBieXRlcyBpbnRvIHRocmVlIHBhcnRzIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXFxuXFxuVGhpcyB3aWxsIHNlYXJjaCBmb3IgdGhlIHNlcGFyYXRvciBzZXAgaW4gdGhlIGJ5dGVzLiBJZiB0aGUgc2VwYXJhdG9yIGlzIGZvdW5kLFxcbnJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhcnQgYmVmb3JlIHRoZSBzZXBhcmF0b3IsIHRoZSBzZXBhcmF0b3JcXG5pdHNlbGYsIGFuZCB0aGUgcGFydCBhZnRlciBpdC5cXG5cXG5JZiB0aGUgc2VwYXJhdG9yIGlzIG5vdCBmb3VuZCwgcmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgYnl0ZXNcXG5vYmplY3QgYW5kIHR3byBlbXB0eSBieXRlcyBvYmplY3RzLlwifSxcbnJlcGxhY2U6eyRtZXRoKEUsSCx5KXtFPXRoaXMuZ2V0JHJhdyhFKTtIPXRoaXMuZ2V0JHJhdyhIKTt5PXZvaWQgMD09PXk/LTE6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKHksU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTt5PTA+eT9JbmZpbml0eTp5O2NvbnN0IEE9W107bGV0IEo9MDtmb3IodmFyIFE9MDtRPHRoaXMudi5sZW5ndGgmJko8eTspe2NvbnN0IFg9dGhpcy5maW5kJHN1YmxlZnQoRSxRLHRoaXMudi5sZW5ndGgpO2lmKC0xPT09WClicmVhaztmb3IoO1E8WDtRKyspQS5wdXNoKHRoaXMudltRXSk7QS5wdXNoKC4uLkgpO1E9WCtFLmxlbmd0aDtKKyt9Zm9yKFE7UTx0aGlzLnYubGVuZ3RoO1ErKylBLnB1c2godGhpcy52W1FdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMobmV3IFVpbnQ4QXJyYXkoQSkpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjN9LCR0ZXh0c2lnOlwiKCRzZWxmLCBvbGQsIG5ldywgY291bnQ9LTEsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgd2l0aCBhbGwgb2NjdXJyZW5jZXMgb2Ygc3Vic3RyaW5nIG9sZCByZXBsYWNlZCBieSBuZXcuXFxuXFxuICBjb3VudFxcbiAgICBNYXhpbXVtIG51bWJlciBvZiBvY2N1cnJlbmNlcyB0byByZXBsYWNlLlxcbiAgICAtMSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIHJlcGxhY2UgYWxsIG9jY3VycmVuY2VzLlxcblxcbklmIHRoZSBvcHRpb25hbCBhcmd1bWVudCBjb3VudCBpcyBnaXZlbiwgb25seSB0aGUgZmlyc3QgY291bnQgb2NjdXJyZW5jZXMgYXJlXFxucmVwbGFjZWQuXCJ9LFxucmZpbmQ6eyRtZXRoKEUsSCx5KXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLmZpbmQkcmlnaHQoRSxILHkpKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLnJmaW5kKHN1YlssIHN0YXJ0WywgZW5kXV0pIC0+IGludFxcblxcblJldHVybiB0aGUgaGlnaGVzdCBpbmRleCBpbiBCIHdoZXJlIHN1YnNlY3Rpb24gc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBCW3N0YXJ0LGVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SZXR1cm4gLTEgb24gZmFpbHVyZS5cIn0scmluZGV4OnskbWV0aDpmdW5jdGlvbihFLEgseSl7RT10aGlzLmZpbmQkcmlnaHQoRSxILHkpO2lmKC0xPT09RSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwic3Vic2VjdGlvbiBub3QgZm91bmRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oRSl9LFxuJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLnJpbmRleChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGhpZ2hlc3QgaW5kZXggaW4gQiB3aGVyZSBzdWJzZWN0aW9uIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gQltzdGFydCxlbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmFpc2UgVmFsdWVFcnJvciB3aGVuIHRoZSBzdWJzZWN0aW9uIGlzIG5vdCBmb3VuZC5cIn0scmp1c3Q6eyRtZXRoOm0oXCJyanVzdFwiLCEwLCExKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIucmp1c3Qod2lkdGhbLCBmaWxsY2hhcl0pIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBCIHJpZ2h0IGp1c3RpZmllZCBpbiBhIHN0cmluZyBvZiBsZW5ndGggd2lkdGguIFBhZGRpbmcgaXNcXG5kb25lIHVzaW5nIHRoZSBzcGVjaWZpZWQgZmlsbCBjaGFyYWN0ZXIgKGRlZmF1bHQgaXMgYSBzcGFjZSlcIn0sXG5ycGFydGl0aW9uOnskbWV0aDpjKCEwKSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIHNlcCwgLylcIiwkZG9jOlwiUGFydGl0aW9uIHRoZSBieXRlcyBpbnRvIHRocmVlIHBhcnRzIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXFxuXFxuVGhpcyB3aWxsIHNlYXJjaCBmb3IgdGhlIHNlcGFyYXRvciBzZXAgaW4gdGhlIGJ5dGVzLCBzdGFydGluZyBhdCB0aGUgZW5kLiBJZlxcbnRoZSBzZXBhcmF0b3IgaXMgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhcnQgYmVmb3JlIHRoZVxcbnNlcGFyYXRvciwgdGhlIHNlcGFyYXRvciBpdHNlbGYsIGFuZCB0aGUgcGFydCBhZnRlciBpdC5cXG5cXG5JZiB0aGUgc2VwYXJhdG9yIGlzIG5vdCBmb3VuZCwgcmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0d28gZW1wdHkgYnl0ZXNcXG5vYmplY3RzIGFuZCB0aGUgb3JpZ2luYWwgYnl0ZXMgb2JqZWN0LlwifSxyc3BsaXQ6eyRtZXRoOmZ1bmN0aW9uKEUsSCl7KHtzZXA6RSxcbm1heHNwbGl0Okh9PXRoaXMuZ2V0JHNwbGl0QXJncyhFLEgpKTtjb25zdCB5PVtdO2xldCBBPTAsSj10aGlzLnYubGVuZ3RoO2lmKG51bGwhPT1FKXtmb3IoOzA8PUomJkE8SDspe2NvbnN0IFE9dGhpcy5maW5kJHN1YnJpZ2h0KEUsMCxKKTtpZigtMT09PVEpYnJlYWs7eS5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShRK0UubGVuZ3RoLEopKSk7Sj1RO0ErK315LnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KDAsSikpKX1lbHNle2ZvcihKLS07QTxIOyl7Zm9yKDtrKHRoaXMudltKXSk7KUotLTtpZigwPkopYnJlYWs7RT1KKzE7Zm9yKEotLTswPD1KJiYhayh0aGlzLnZbSl0pOylKLS07eS5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShKKzEsRSkpKTtBKyt9aWYoMDw9Sil7Zm9yKDtrKHRoaXMudltKXSk7KUotLTswPD1KJiZ5LnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KDAsXG5KKzEpKSl9fXJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHkucmV2ZXJzZSgpKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wic2VwXCIsXCJtYXhzcGxpdFwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ub25lLm5vbmUkLC0xXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIHNlcD1Ob25lLCBtYXhzcGxpdD0tMSlcIiwkZG9jOlwiUmV0dXJuIGEgbGlzdCBvZiB0aGUgc2VjdGlvbnMgaW4gdGhlIGJ5dGVzLCB1c2luZyBzZXAgYXMgdGhlIGRlbGltaXRlci5cXG5cXG4gIHNlcFxcbiAgICBUaGUgZGVsaW1pdGVyIGFjY29yZGluZyB3aGljaCB0byBzcGxpdCB0aGUgYnl0ZXMuXFxuICAgIE5vbmUgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyBzcGxpdCBvbiBBU0NJSSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcXG4gICAgKHNwYWNlLCB0YWIsIHJldHVybiwgbmV3bGluZSwgZm9ybWZlZWQsIHZlcnRpY2FsIHRhYikuXFxuICBtYXhzcGxpdFxcbiAgICBNYXhpbXVtIG51bWJlciBvZiBzcGxpdHMgdG8gZG8uXFxuICAgIC0xICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgbm8gbGltaXQuXFxuXFxuU3BsaXR0aW5nIGlzIGRvbmUgc3RhcnRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgYnl0ZXMgYW5kIHdvcmtpbmcgdG8gdGhlIGZyb250LlwifSxcbnJzdHJpcDp7JG1ldGg6bighMSwhMCksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgYnl0ZXM9Tm9uZSwgLylcIiwkZG9jOlwiU3RyaXAgdHJhaWxpbmcgYnl0ZXMgY29udGFpbmVkIGluIHRoZSBhcmd1bWVudC5cXG5cXG5JZiB0aGUgYXJndW1lbnQgaXMgb21pdHRlZCBvciBOb25lLCBzdHJpcCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlLlwifSxzcGxpdDp7JG1ldGg6ZnVuY3Rpb24oRSxIKXsoe3NlcDpFLG1heHNwbGl0Okh9PXRoaXMuZ2V0JHNwbGl0QXJncyhFLEgpKTtjb25zdCB5PVtdLEE9dGhpcy52Lmxlbmd0aDtsZXQgSj0wLFE9MDtpZihudWxsIT09RSl7Zm9yKDtRPEEmJko8SDspe2NvbnN0IFg9dGhpcy5maW5kJHN1YmxlZnQoRSxRLEEpO2lmKC0xPT09WClicmVhazt5LnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KFEsWCkpKTtRPVgrRS5sZW5ndGg7SisrfXkucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoUSxcbkEpKSl9ZWxzZXtmb3IoO0o8SDspe2Zvcig7ayh0aGlzLnZbUV0pOylRKys7aWYoUT09PUEpYnJlYWs7RT1RO2ZvcihRKys7UTxBJiYhayh0aGlzLnZbUV0pOylRKys7eS5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShFLFEpKSk7SisrfWlmKFE8QSl7Zm9yKDtrKHRoaXMudltRXSk7KVErKztRPEEmJnkucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoUSxBKSkpfX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh5KX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wic2VwXCIsXCJtYXhzcGxpdFwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ub25lLm5vbmUkLC0xXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIHNlcD1Ob25lLCBtYXhzcGxpdD0tMSlcIiwkZG9jOlwiUmV0dXJuIGEgbGlzdCBvZiB0aGUgc2VjdGlvbnMgaW4gdGhlIGJ5dGVzLCB1c2luZyBzZXAgYXMgdGhlIGRlbGltaXRlci5cXG5cXG4gIHNlcFxcbiAgICBUaGUgZGVsaW1pdGVyIGFjY29yZGluZyB3aGljaCB0byBzcGxpdCB0aGUgYnl0ZXMuXFxuICAgIE5vbmUgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyBzcGxpdCBvbiBBU0NJSSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcXG4gICAgKHNwYWNlLCB0YWIsIHJldHVybiwgbmV3bGluZSwgZm9ybWZlZWQsIHZlcnRpY2FsIHRhYikuXFxuICBtYXhzcGxpdFxcbiAgICBNYXhpbXVtIG51bWJlciBvZiBzcGxpdHMgdG8gZG8uXFxuICAgIC0xICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgbm8gbGltaXQuXCJ9LFxuc3BsaXRsaW5lczp7JG1ldGgoRSl7RT1Tay5taXNjZXZhbC5pc1RydWUoRSk7Y29uc3QgSD1bXTtsZXQgeT0wO2xldCBBPTA7Y29uc3QgSj10aGlzLnYubGVuZ3RoO2Zvcig7QTxKOyl7dmFyIFE9dGhpcy52W0FdO2lmKDEzPT09USl7Y29uc3QgWD0xMD09PXRoaXMudltBKzFdO1E9RT9YP0ErMjpBKzE6QTtILnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KHksUSkpKTtBPXk9WD9BKzI6QSsxfWVsc2UgMTA9PT1RPyhRPUU/QSsxOkEsSC5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheSh5LFEpKSksQT15PUErMSk6QSsrfXk8SiYmSC5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheSh5LEopKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoSCl9LCRmbGFnczp7TmFtZWRBcmdzOltcImtlZXBlbmRzXCJdLERlZmF1bHRzOlshMV19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBrZWVwZW5kcz1GYWxzZSlcIiwkZG9jOlwiUmV0dXJuIGEgbGlzdCBvZiB0aGUgbGluZXMgaW4gdGhlIGJ5dGVzLCBicmVha2luZyBhdCBsaW5lIGJvdW5kYXJpZXMuXFxuXFxuTGluZSBicmVha3MgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIGxpc3QgdW5sZXNzIGtlZXBlbmRzIGlzIGdpdmVuIGFuZFxcbnRydWUuXCJ9LFxuc3RhcnRzd2l0aDp7JG1ldGg6ZyhcInN0YXJ0c3dpdGhcIiwoRSxIKT0+SC5sZW5ndGg8PUUubGVuZ3RoJiZILmV2ZXJ5KCh5LEEpPT55PT09RVtBXSkpLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5zdGFydHN3aXRoKHByZWZpeFssIHN0YXJ0WywgZW5kXV0pIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBCIHN0YXJ0cyB3aXRoIHRoZSBzcGVjaWZpZWQgcHJlZml4LCBGYWxzZSBvdGhlcndpc2UuXFxuV2l0aCBvcHRpb25hbCBzdGFydCwgdGVzdCBCIGJlZ2lubmluZyBhdCB0aGF0IHBvc2l0aW9uLlxcbldpdGggb3B0aW9uYWwgZW5kLCBzdG9wIGNvbXBhcmluZyBCIGF0IHRoYXQgcG9zaXRpb24uXFxucHJlZml4IGNhbiBhbHNvIGJlIGEgdHVwbGUgb2YgYnl0ZXMgdG8gdHJ5LlwifSxzdHJpcDp7JG1ldGg6bighMCwhMCksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgYnl0ZXM9Tm9uZSwgLylcIiwkZG9jOlwiU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgYnl0ZXMgY29udGFpbmVkIGluIHRoZSBhcmd1bWVudC5cXG5cXG5JZiB0aGUgYXJndW1lbnQgaXMgb21pdHRlZCBvciBOb25lLCBzdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlLlwifSxcbnN3YXBjYXNlOnskbWV0aDp0KEU9PmwoRSk/RSszMjp1KEUpP0UtMzI6RSksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuc3dhcGNhc2UoKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gYSBjb3B5IG9mIEIgd2l0aCB1cHBlcmNhc2UgQVNDSUkgY2hhcmFjdGVycyBjb252ZXJ0ZWRcXG50byBsb3dlcmNhc2UgQVNDSUkgYW5kIHZpY2UgdmVyc2EuXCJ9LHRpdGxlOnskbWV0aCgpe2NvbnN0IEU9dGhpcy52Lmxlbmd0aCxIPW5ldyBVaW50OEFycmF5KEUpO2xldCB5PSExO2ZvcihsZXQgQT0wO0E8RTtBKyspe2NvbnN0IEo9dGhpcy52W0FdO2woSik/KEhbQV09eT9KKzMyOkoseT0hMCk6dShKKT8oSFtBXT15P0o6Si0zMix5PSEwKTooSFtBXT1KLHk9ITEpfXJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhIKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIudGl0bGUoKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gYSB0aXRsZWNhc2VkIHZlcnNpb24gb2YgQiwgaS5lLiBBU0NJSSB3b3JkcyBzdGFydCB3aXRoIHVwcGVyY2FzZVxcbmNoYXJhY3RlcnMsIGFsbCByZW1haW5pbmcgY2FzZWQgY2hhcmFjdGVycyBoYXZlIGxvd2VyY2FzZS5cIn0sXG51cHBlcjp7JG1ldGg6dChFPT51KEUpP0UtMzI6RSksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIudXBwZXIoKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gYSBjb3B5IG9mIEIgd2l0aCBhbGwgQVNDSUkgY2hhcmFjdGVycyBjb252ZXJ0ZWQgdG8gdXBwZXJjYXNlLlwifSx6ZmlsbDp7JG1ldGgoRSl7RT1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoRSxTay5idWlsdGluLkluZGV4RXJyb3IpO2NvbnN0IEg9RS10aGlzLnYubGVuZ3RoO2lmKDA+PUgpcmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudik7Y29uc3QgeT1uZXcgVWludDhBcnJheShFKTtsZXQgQT0wLEo7aWYoNDM9PT10aGlzLnZbMF18fDQ1PT09dGhpcy52WzBdKXlbMF09dGhpcy52WzBdLEErKzt5LmZpbGwoNDgsQSxBK0gpO0o9QTtmb3IoQSs9SDtBPEU7QSsrLEorKyl5W0FdPXRoaXMudltKXTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoeSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLFxuJGRvYzpcIkIuemZpbGwod2lkdGgpIC0+IGNvcHkgb2YgQlxcblxcblBhZCBhIG51bWVyaWMgc3RyaW5nIEIgd2l0aCB6ZXJvcyBvbiB0aGUgbGVmdCwgdG8gZmlsbCBhIGZpZWxkXFxub2YgdGhlIHNwZWNpZmllZCB3aWR0aC4gIEIgaXMgbmV2ZXIgdHJ1bmNhdGVkLlwifX0sY2xhc3NtZXRob2RzOntmcm9taGV4OnskbWV0aDpmdW5jdGlvbihFKXtmdW5jdGlvbiBIKGFhKXtmb3IobGV0IGVhPVE7ZWE8YWE7ZWErPTIpe2xldCBuYT1FLnN1YnN0cihlYSwyKTtpZighQS50ZXN0KG5hKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibm9uLWhleGFkZWNpbWFsIG51bWJlciBmb3VuZCBpbiBmcm9taGV4KCkgYXJnIGF0IHBvc2l0aW9uIFwiKyhlYSsxKSk7Si5wdXNoKHBhcnNlSW50KG5hLDE2KSl9fWlmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKEUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImZyb21oZXgoKSBhcmd1bWVudCBtdXN0IGJlIHN0ciwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKEUpKTtcbkU9RS4kanNzdHIoKTtjb25zdCB5PS9cXHMrL2csQT0vXlthYmNkZWZBQkNERUYwMTIzNDU2Nzg5XXsyfSQvLEo9W107bGV0IFE9MCxYO2Zvcig7bnVsbCE9PShYPXkuZXhlYyhFKSk7KUgoWC5pbmRleCksUT15Lmxhc3RJbmRleDtIKEUubGVuZ3RoKTtyZXR1cm4gbmV3IHRoaXMoSil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkdHlwZSwgc3RyaW5nLCAvKVwiLCRkb2M6XCJDcmVhdGUgYSBieXRlcyBvYmplY3QgZnJvbSBhIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBudW1iZXJzLlxcblxcblNwYWNlcyBiZXR3ZWVuIHR3byBudW1iZXJzIGFyZSBhY2NlcHRlZC5cXG5FeGFtcGxlOiBieXRlcy5mcm9taGV4KCdCOSAwMUVGJykgLT4gYidcXFxcXFxcXHhiOVxcXFxcXFxceDAxXFxcXFxcXFx4ZWYnLlwifX19KTt2YXIgUz1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJieXRlc19pdGVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihFKXt0aGlzLiRpbmRleD0wO3RoaXMuJHNlcT1FLnZ9LGl0ZXJuZXh0KCl7Y29uc3QgRT1cbnRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXTtpZih2b2lkIDAhPT1FKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEUpfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5ieXRlc1wiLFNrLmJ1aWx0aW4uYnl0ZXMpfSxmdW5jdGlvbihGLFAsYil7KGZ1bmN0aW9uKGUpeyhmdW5jdGlvbihkKXtmdW5jdGlvbiBmKCl7fWZ1bmN0aW9uIGgoKXt9dmFyIHA9U3RyaW5nLmZyb21DaGFyQ29kZSxnPXt9LnRvU3RyaW5nLGE9Zy5jYWxsKGQuU2hhcmVkQXJyYXlCdWZmZXIpLGM9ZygpLG49ZC5VaW50OEFycmF5LG09bnx8QXJyYXksaz1uP0FycmF5QnVmZmVyOm0sdT1rLmlzVmlld3x8ZnVuY3Rpb24ocil7cmV0dXJuIHImJlwibGVuZ3RoXCJpbiByfSxsPWcuY2FsbChrLnByb3RvdHlwZSk7az1oLnByb3RvdHlwZTtcbnZhciBxPWQuVGV4dEVuY29kZXIsej1uZXcgKG4/VWludDE2QXJyYXk6bSkoMzIpO2YucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihyKXtpZighdShyKSl7dmFyIHQ9Zy5jYWxsKHIpO2lmKHQhPT1sJiZ0IT09YSYmdCE9PWMpdGhyb3cgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2RlY29kZScgb24gJ1RleHREZWNvZGVyJzogVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7cj1uP25ldyBtKHIpOnJ8fFtdfWZvcih2YXIgeD10PVwiXCIsdj0wLEI9ci5sZW5ndGh8MCxJPUItMzJ8MCxNLFMsRT0wLEg9MCx5LEE9MCxKPS0xO3Y8Qjspe2ZvcihNPXY8PUk/MzI6Qi12fDA7QTxNO3Y9disxfDAsQT1BKzF8MCl7Uz1yW3ZdJjI1NTtzd2l0Y2goUz4+NCl7Y2FzZSAxNTp5PXJbdj12KzF8MF0mMjU1O2lmKDIhPT15Pj42fHwyNDc8Uyl7dj12LTF8MDticmVha31FPShTJjcpPDw2fHkmNjM7SD01O1M9MjU2O2Nhc2UgMTQ6eT1cbnJbdj12KzF8MF0mMjU1LEU8PD02LEV8PShTJjE1KTw8Nnx5JjYzLEg9Mj09PXk+PjY/SCs0fDA6MjQsUz1TKzI1NiY3Njg7Y2FzZSAxMzpjYXNlIDEyOnk9clt2PXYrMXwwXSYyNTUsRTw8PTYsRXw9KFMmMzEpPDw2fHkmNjMsSD1IKzd8MCx2PEImJjI9PT15Pj42JiZFPj5IJiYxMTE0MTEyPkU/KFM9RSxFPUUtNjU1MzZ8MCwwPD1FJiYoSj0oRT4+MTApKzU1Mjk2fDAsUz0oRSYxMDIzKSs1NjMyMHwwLDMxPkE/KHpbQV09SixBPUErMXwwLEo9LTEpOih5PUosSj1TLFM9eSkpKTooUz4+PTgsdj12LVMtMXwwLFM9NjU1MzMpLEU9SD0wLE09djw9ST8zMjpCLXZ8MDtkZWZhdWx0OnpbQV09Uztjb250aW51ZTtjYXNlIDExOmNhc2UgMTA6Y2FzZSA5OmNhc2UgODp9eltBXT02NTUzM314Kz1wKHpbMF0selsxXSx6WzJdLHpbM10sels0XSx6WzVdLHpbNl0sels3XSx6WzhdLHpbOV0selsxMF0selsxMV0selsxMl0selsxM10selsxNF0selsxNV0selsxNl0selsxN10selsxOF0selsxOV0selsyMF0sXG56WzIxXSx6WzIyXSx6WzIzXSx6WzI0XSx6WzI1XSx6WzI2XSx6WzI3XSx6WzI4XSx6WzI5XSx6WzMwXSx6WzMxXSk7MzI+QSYmKHg9eC5zbGljZSgwLEEtMzJ8MCkpO2lmKHY8Qil7aWYoelswXT1KLEE9fko+Pj4zMSxKPS0xLHgubGVuZ3RoPHQubGVuZ3RoKWNvbnRpbnVlfWVsc2UtMSE9PUomJih4Kz1wKEopKTt0Kz14O3g9XCJcIn1yZXR1cm4gdH07ay5lbmNvZGU9ZnVuY3Rpb24ocil7cj12b2lkIDA9PT1yP1wiXCI6XCJcIityO3ZhciB0PXIubGVuZ3RofDAseD1uZXcgbSgodDw8MSkrOHwwKSx2LEI9MCxJPSFuO2Zvcih2PTA7djx0O3Y9disxfDAsQj1CKzF8MCl7dmFyIE09ci5jaGFyQ29kZUF0KHYpfDA7aWYoMTI3Pj1NKXhbQl09TTtlbHNle2lmKDIwNDc+PU0peFtCXT0xOTJ8TT4+NjtlbHNle2E6e2lmKDU1Mjk2PD1NKWlmKDU2MzE5Pj1NKXt2YXIgUz1yLmNoYXJDb2RlQXQodj12KzF8MCl8MDtpZig1NjMyMDw9UyYmNTczNDM+PVMpe009KE08PDEwKStTLTU2NjEzODg4fDA7aWYoNjU1MzU8XG5NKXt4W0JdPTI0MHxNPj4xODt4W0I9QisxfDBdPTEyOHxNPj4xMiY2Mzt4W0I9QisxfDBdPTEyOHxNPj42JjYzO3hbQj1CKzF8MF09MTI4fE0mNjM7Y29udGludWV9YnJlYWsgYX1NPTY1NTMzfWVsc2UgNTczNDM+PU0mJihNPTY1NTMzKTshSSYmdjw8MTxCJiZ2PDwxPChCLTd8MCkmJihJPSEwLFM9bmV3IG0oMyp0KSxTLnNldCh4KSx4PVMpfXhbQl09MjI0fE0+PjEyO3hbQj1CKzF8MF09MTI4fE0+PjYmNjN9eFtCPUIrMXwwXT0xMjh8TSY2M319cmV0dXJuIG4/eC5zdWJhcnJheSgwLEIpOnguc2xpY2UoMCxCKX07cXx8KGQuVGV4dERlY29kZXI9ZixkLlRleHRFbmNvZGVyPWgpfSkoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGU/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/dGhpczpzZWxmOmUpfSkuY2FsbCh0aGlzLGIoMCkpfSxmdW5jdGlvbihGLFApe1NrLmJ1aWx0aW4udHVwbGU9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInR1cGxlXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGUpe3ZvaWQgMD09PVxuZT9lPVtdOkFycmF5LmlzQXJyYXkoZSl8fChlPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGUpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSxcImJhZCBjYWxsIHRvIHR1cGxlLCB1c2UgJ25ldycgd2l0aCBhbiBBcnJheSBvZiBweXRob24gb2JqZWN0c1wiKTt0aGlzLnY9ZTt0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGRvYzpcIkJ1aWx0LWluIGltbXV0YWJsZSBzZXF1ZW5jZS5cXG5cXG5JZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGNvbnN0cnVjdG9yIHJldHVybnMgYW4gZW1wdHkgdHVwbGUuXFxuSWYgaXRlcmFibGUgaXMgc3BlY2lmaWVkIHRoZSB0dXBsZSBpcyBpbml0aWFsaXplZCBmcm9tIGl0ZXJhYmxlJ3MgaXRlbXMuXFxuXFxuSWYgdGhlIGFyZ3VtZW50IGlzIGEgdHVwbGUsIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIHNhbWUgb2JqZWN0LlwiLFxuJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIiguLi4pXCIpO3RoaXMuaW4kcmVwcj0hMDtsZXQgZT10aGlzLnYubWFwKGQ9PlNrLm1pc2NldmFsLm9iamVjdFJlcHIoZCkpO3RoaXMuaW4kcmVwcj0hMTtlPWUuam9pbihcIiwgXCIpOzE9PT10aGlzLnYubGVuZ3RoJiYoZSs9XCIsXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCIoXCIrZStcIilcIil9LHRwJG5ldyhlLGQpe2lmKHRoaXMhPT1Tay5idWlsdGluLnR1cGxlLnByb3RvdHlwZSlyZXR1cm4gdGhpcy4kc3VidHlwZV9uZXcoZSxkKTtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwidHVwbGVcIixkKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJ0dXBsZVwiLGUsMCwxKTtlPWVbMF07cmV0dXJuIHZvaWQgMD09PWU/bmV3IFNrLmJ1aWx0aW4udHVwbGUoW10pOmUuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnR1cGxlP2U6U2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZSxcbiEwKSxmPT5uZXcgU2suYnVpbHRpbi50dXBsZShmKSl9LHRwJGhhc2goKXtsZXQgZSxkPTM0MzAwMDgsZj0xMDAwMDAzO2NvbnN0IGg9dGhpcy52Lmxlbmd0aDtmb3IobGV0IHA9MDtwPGg7KytwKXtlPVNrLmFic3RyLm9iamVjdEhhc2godGhpcy52W3BdKTtpZigtMT09PWUpcmV0dXJuLTE7ZD0oZF5lKSpmO2YrPTgyNTIwK2graH1kKz05NzUzMTstMT09PWQmJihkPS0yKTtyZXR1cm4gZHwwfSx0cCRyaWNoY29tcGFyZTpTay5nZW5lcmljLnNlcUNvbXBhcmUsdHAkaXRlcigpe3JldHVybiBuZXcgYih0aGlzKX0sbXAkc3Vic2NyaXB0KGUpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoZSkpe2U9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGUsU2suYnVpbHRpbi5JbmRleEVycm9yKTswPmUmJihlPXRoaXMudi5sZW5ndGgrZSk7aWYoMD5lfHxlPj10aGlzLnYubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXCJ0dXBsZSBpbmRleCBvdXQgb2YgcmFuZ2VcIik7cmV0dXJuIHRoaXMudltlXX1pZihlIGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uc2xpY2Upe2NvbnN0IGQ9W107ZS5zc3NpdGVyJCh0aGlzLnYubGVuZ3RoLGY9PntkLnB1c2godGhpcy52W2ZdKX0pO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShkKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0dXBsZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3Igc2xpY2VzLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZSkpO30sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMudi5sZW5ndGh9LHNxJHJlcGVhdChlKXtlPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChlLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoMT09PWUmJnRoaXMuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnR1cGxlKXJldHVybiB0aGlzO2NvbnN0IGQ9W107Zm9yKGxldCBmPTA7ZjxlO2YrKylmb3IobGV0IGg9MDtoPHRoaXMudi5sZW5ndGg7aCsrKWQucHVzaCh0aGlzLnZbaF0pO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShkKX0sc3EkY29uY2F0KGUpe2lmKCEoZSBpbnN0YW5jZW9mXG5Tay5idWlsdGluLnR1cGxlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4gb25seSBjb25jYXRlbmF0ZSB0dXBsZSAobm90ICdcIitTay5hYnN0ci50eXBlTmFtZShlKStcIicpIHRvIHR1cGxlXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLnYuY29uY2F0KGUudikpfSxzcSRjb250YWlucyhlKXtmb3IobGV0IGQ9dGhpcy50cCRpdGVyKCksZj1kLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09ZjtmPWQudHAkaXRlcm5leHQoKSlpZihmPT09ZXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGYsZSxcIkVxXCIpKXJldHVybiEwO3JldHVybiExfX0scHJvdG86eyRzdWJ0eXBlX25ldyhlLGQpe2Q9bmV3IHRoaXMuY29uc3RydWN0b3I7ZT1Tay5idWlsdGluLnR1cGxlLnByb3RvdHlwZS50cCRuZXcoZSk7ZC52PWUudjtyZXR1cm4gZH0sc2skYXNhcnJheSgpe3JldHVybiB0aGlzLnYuc2xpY2UoMCl9LHZhbHVlT2YoKXtyZXR1cm4gdGhpcy52fX0sbWV0aG9kczp7X19nZXRuZXdhcmdzX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMudi5zbGljZSgwKSl9LFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6bnVsbH0saW5kZXg6eyRtZXRoKGUsZCxmKXtpZih2b2lkIDAhPT1kJiYhU2subWlzY2V2YWwuaXNJbmRleChkKXx8dm9pZCAwIT09ZiYmIVNrLm1pc2NldmFsLmlzSW5kZXgoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic2xpY2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKTsoe3N0YXJ0OmQsZW5kOmZ9PVNrLmJ1aWx0aW4uc2xpY2Uuc3RhcnRFbmQkd3J0KHRoaXMsZCxmKSk7Y29uc3QgaD10aGlzLnY7Zm9yKDtkPGY7ZCsrKWlmKGhbZF09PT1lfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaFtkXSxlLFwiRXFcIikpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInR1cGxlLmluZGV4KHgpOiB4IG5vdCBpbiB0dXBsZVwiKTt9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sXG4kdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIHN0YXJ0PTAsIHN0b3A9c3lzLm1heHNpemUsIC8pXCIsJGRvYzpcIlJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZS5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciBpZiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQuXCJ9LGNvdW50OnskbWV0aChlKXtjb25zdCBkPXRoaXMudi5sZW5ndGgsZj10aGlzLnY7bGV0IGg9MDtmb3IobGV0IHA9MDtwPGQ7KytwKWlmKGZbcF09PT1lfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZltwXSxlLFwiRXFcIikpaCs9MTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhoKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZG9jOlwiUmV0dXJuIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB2YWx1ZS5cIn19LGNsYXNzbWV0aG9kczpTay5nZW5lcmljLmNsYXNzR2V0SXRlbX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4udHVwbGVcIixTay5idWlsdGluLnR1cGxlKTt2YXIgYj1cblNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcInR1cGxlX2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGUpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWUuc2skYXNhcnJheSgpfSxpdGVybmV4dDpTay5nZW5lcmljLml0ZXJOZXh0V2l0aEFycmF5LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJMZW5ndGhIaW50V2l0aEFycmF5TWV0aG9kRGVmfSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KX0sZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKHIpe2xldCB0PXIuJHNhdmVkS2V5SGFzaDtyZXR1cm4gdm9pZCAwIT09dD90OnQ9U2suYWJzdHIub2JqZWN0SGFzaChyKX1mdW5jdGlvbiBlKHIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zZXQoU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUocikpfWZ1bmN0aW9uIGQocix0KXtmb3IobGV0IHg9U2suYWJzdHIuaXRlcihyKSx2PXgudHAkaXRlcm5leHQoKTt2b2lkIDAhPT12O3Y9eC50cCRpdGVybmV4dCgpKWlmKCFTay5hYnN0ci5zZXF1ZW5jZUNvbnRhaW5zKHQsXG52KSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBmKHIsdCx4KXtjb25zdCB2PXtjb25zdHJ1Y3RvcjpmdW5jdGlvbihCKXtpZigxIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW5ub3QgY3JlYXRlICdcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIicgaW5zdGFuY2VzXCIpO3RoaXMuZGljdD1CO3RoaXMuaW4kcmVwcj0hMX19O3Yuc2xvdHM9T2JqZWN0LmFzc2lnbih0LGcpO3YubWV0aG9kcz17aXNkaXNqb2ludDp7JG1ldGgoQil7Y29uc3QgST1lKHRoaXMpO3JldHVybiBJLmlzZGlzam9pbnQuJG1ldGguY2FsbChJLEIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIHZpZXcgYW5kIHRoZSBnaXZlbiBpdGVyYWJsZSBoYXZlIGEgbnVsbCBpbnRlcnNlY3Rpb24uXCJ9LF9fcmV2ZXJzZWRfXzp7JG1ldGg6eCwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBkaWN0IGtleXMuXCJ9fTtcbnYuZmxhZ3M9e3NrJGFjY2VwdGFibGVfYXNfYmFzZTohMX07XCJkaWN0X3ZhbHVlc1wiPT09ciYmKGRlbGV0ZSB2LnNsb3RzLnRwJGFzX251bWJlcixkZWxldGUgdi5zbG90cy50cCRyaWNoY29tcGFyZSk7cmV0dXJuIFNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3Mocix2KX1mdW5jdGlvbiBoKHIsdCx4KXtyZXR1cm4gU2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKHIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKHYpe3RoaXMuJGluZGV4PTA7dGhpcy4kb3JpZz12O3RoaXMudHAkaXRlcm5leHQ9KCk9Pnt0aGlzLiRzZXE9di4kaXRlbXMoKTt0aGlzLiR2ZXJzaW9uPXYuJHZlcnNpb247eCYmKHRoaXMuJHNlcT10aGlzLiRzZXEucmV2ZXJzZSgpKTt0aGlzLnRwJGl0ZXJuZXh0PXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRwJGl0ZXJuZXh0O3JldHVybiB0aGlzLnRwJGl0ZXJuZXh0KCl9fSxpdGVybmV4dDp0LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJMZW5ndGhIaW50V2l0aEFycmF5TWV0aG9kRGVmfSxcbmZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfSxwcm90bzp7bmV4dCRpdGVtOnB9fSl9ZnVuY3Rpb24gcCgpe2lmKHRoaXMuJHZlcnNpb24hPT10aGlzLiRvcmlnLiR2ZXJzaW9uKXtpZih0aGlzLiRzZXEubGVuZ3RoIT09dGhpcy4kb3JpZy5nZXQkc2l6ZSgpKXRocm93IG5ldyBTay5idWlsdGluLlJ1bnRpbWVFcnJvcihcImRpY3QgY2hhbmdlZCBzaXplIGR1cmluZyBpdGVyYXRpb25cIik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKFwiZGljdGlvbmFyeSBrZXlzIGNoYW5nZWQgZHVyaW5nIGl0ZXJhdGlvblwiKTt9cmV0dXJuIHRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXX1Tay5idWlsdGluLmRpY3Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImRpY3RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24ocil7dm9pZCAwPT09ciYmKHI9W10pO1NrLmFzc2VydHMuYXNzZXJ0KEFycmF5LmlzQXJyYXkocikmJjA9PT1yLmxlbmd0aCUyJiZ0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0LFxuXCJiYWQgY2FsbCB0byBkaWN0IGNvbnN0cnVjdG9yXCIpO3RoaXMuc2l6ZT0wO3RoaXMuZW50cmllcz1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuYnVja2V0cz17fTtmb3IobGV0IHQ9MDt0PHIubGVuZ3RoO3QrPTIpdGhpcy5zZXQkaXRlbShyW3RdLHJbdCsxXSk7dGhpcy5pbiRyZXByPSExO3RoaXMuJHZlcnNpb249MH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkYXNfbnVtYmVyOiEwLHRwJGhhc2g6U2suYnVpbHRpbi5ub25lLm5vbmUkLHRwJGRvYzpcImRpY3QoKSAtPiBuZXcgZW1wdHkgZGljdGlvbmFyeVxcbmRpY3QobWFwcGluZykgLT4gbmV3IGRpY3Rpb25hcnkgaW5pdGlhbGl6ZWQgZnJvbSBhIG1hcHBpbmcgb2JqZWN0J3NcXG4gICAgKGtleSwgdmFsdWUpIHBhaXJzXFxuZGljdChpdGVyYWJsZSkgLT4gbmV3IGRpY3Rpb25hcnkgaW5pdGlhbGl6ZWQgYXMgaWYgdmlhOlxcbiAgICBkID0ge31cXG4gICAgZm9yIGssIHYgaW4gaXRlcmFibGU6XFxuICAgICAgICBkW2tdID0gdlxcbmRpY3QoKiprd2FyZ3MpIC0+IG5ldyBkaWN0aW9uYXJ5IGluaXRpYWxpemVkIHdpdGggdGhlIG5hbWU9dmFsdWUgcGFpcnNcXG4gICAgaW4gdGhlIGtleXdvcmQgYXJndW1lbnQgbGlzdC4gIEZvciBleGFtcGxlOiAgZGljdChvbmU9MSwgdHdvPTIpXCIsXG4kcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiey4uLn1cIik7dGhpcy5pbiRyZXByPSEwO2NvbnN0IHI9dGhpcy4kaXRlbXMoKS5tYXAodD0+e3ZhciBbeCx2XT10O3JldHVybiBTay5taXNjZXZhbC5vYmplY3RSZXByKHgpK1wiOiBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKHYpfSk7dGhpcy5pbiRyZXByPSExO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJ7XCIrci5qb2luKFwiLCBcIikrXCJ9XCIpfSx0cCRuZXc6U2suZ2VuZXJpYy5uZXcsdHAkaW5pdChyLHQpe3JldHVybiB0aGlzLnVwZGF0ZSRjb21tb24ocix0LFwiZGljdFwiKX0sdHAkaXRlcigpe3JldHVybiBuZXcgbSh0aGlzKX0sdHAkcmljaGNvbXBhcmUocix0KXtsZXQgeDtpZighKHIgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpfHxcIkVxXCIhPT10JiZcIk5vdEVxXCIhPT10KXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtpZihyPT09dGhpcyl4PSEwO2Vsc2UgaWYodGhpcy5zaXplIT09XG5yLnNpemUpeD0hMTtlbHNle2xldCB2O3g9dGhpcy4kaXRlbXMoKS5ldmVyeShCPT57dmFyIFtJLE1dPUI7dj1yLm1wJGxvb2t1cChJKTtyZXR1cm4gdm9pZCAwIT09diYmKHY9PT1NfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woTSx2LFwiRXFcIikpfSl9cmV0dXJuXCJFcVwiPT09dD94OiF4fSxuYiRvcihyKXtpZighKHIgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCB0PXRoaXMuZGljdCRjb3B5KCk7dC5kaWN0JG1lcmdlKHIpO3JldHVybiB0fSxuYiRyZWZsZWN0ZWRfb3Iocil7aWYoIShyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7cj1yLmRpY3QkY29weSgpO3IuZGljdCRtZXJnZSh0aGlzKTtyZXR1cm4gcn0sbmIkaW5wbGFjZV9vcihyKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy51cGRhdGUkb25lYXJnKHIpLFxuKCk9PnRoaXMpfSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy5nZXQkc2l6ZSgpfSxzcSRjb250YWlucyhyKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5tcCRsb29rdXAocil9LG1wJHN1YnNjcmlwdChyLHQpe3ZhciB4PXRoaXMubXAkbG9va3VwKHIpO2lmKHZvaWQgMCE9PXgpcmV0dXJuIHg7eD1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKHRoaXMsU2suYnVpbHRpbi5zdHIuJG1pc3NpbmcpO2lmKHZvaWQgMCE9PXgpcmV0dXJuIHI9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHgsW3JdKSx0P3I6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KHIpO3Rocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKHIpO30sbXAkYXNzX3N1YnNjcmlwdChyLHQpe2lmKHZvaWQgMD09PXQpe2lmKHZvaWQgMD09PXRoaXMucG9wJGl0ZW0ocikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uS2V5RXJyb3Iocik7fWVsc2UgdGhpcy5zZXQkaXRlbShyLHQpfX0sbWV0aG9kczp7X19yZXZlcnNlZF9fOnskbWV0aCgpe3JldHVybiBuZXcgbCh0aGlzKX0sXG4kZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBkaWN0IGtleXMuXCJ9LGdldDp7JG1ldGgocix0KXtyZXR1cm4gdGhpcy5tcCRsb29rdXAocil8fHR8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkc2VsZiwga2V5LCBkZWZhdWx0PU5vbmUsIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgdmFsdWUgZm9yIGtleSBpZiBrZXkgaXMgaW4gdGhlIGRpY3Rpb25hcnksIGVsc2UgZGVmYXVsdC5cIn0sc2V0ZGVmYXVsdDp7JG1ldGgocix0KXtsZXQgeDtjb25zdCB2PWIocik7eD1cInN0cmluZ1wiPT09dHlwZW9mIHY/dGhpcy5lbnRyaWVzW3ZdOnRoaXMuZ2V0JGJ1Y2tldF9pdGVtKHIsdik7aWYodm9pZCAwIT09eClyZXR1cm4geFsxXTt0PXR8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcInN0cmluZ1wiPT09dHlwZW9mIHY/dGhpcy5lbnRyaWVzW3ZdPVtyLHRdOlxudGhpcy5zZXQkYnVja2V0X2l0ZW0ocix0LHYpO3RoaXMuc2l6ZSsrO3RoaXMuJHZlcnNpb24rKztyZXR1cm4gdH0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkc2VsZiwga2V5LCBkZWZhdWx0PU5vbmUsIC8pXCIsJGRvYzpcIkluc2VydCBrZXkgd2l0aCBhIHZhbHVlIG9mIGRlZmF1bHQgaWYga2V5IGlzIG5vdCBpbiB0aGUgZGljdGlvbmFyeS5cXG5cXG5SZXR1cm4gdGhlIHZhbHVlIGZvciBrZXkgaWYga2V5IGlzIGluIHRoZSBkaWN0aW9uYXJ5LCBlbHNlIGRlZmF1bHQuXCJ9LHBvcDp7JG1ldGgocix0KXtjb25zdCB4PXRoaXMucG9wJGl0ZW0ocik7aWYodm9pZCAwIT09eClyZXR1cm4geFsxXTtpZih2b2lkIDAhPT10KXJldHVybiB0O3Rocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKHIpO30sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELnBvcChrWyxkXSkgLT4gdiwgcmVtb3ZlIHNwZWNpZmllZCBrZXkgYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cXG5JZiBrZXkgaXMgbm90IGZvdW5kLCBkIGlzIHJldHVybmVkIGlmIGdpdmVuLCBvdGhlcndpc2UgS2V5RXJyb3IgaXMgcmFpc2VkXCJ9LFxucG9waXRlbTp7JG1ldGgoKXtjb25zdCByPXRoaXMuZ2V0JHNpemUoKTtpZigwPT09cil0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcihcInBvcGl0ZW0oKTogZGljdGlvbmFyeSBpcyBlbXB0eVwiKTtjb25zdCBbdCx4XT10aGlzLiRpdGVtcygpW3ItMV07dGhpcy5wb3AkaXRlbSh0KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3QseF0pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5wb3BpdGVtKCkgLT4gKGssIHYpLCByZW1vdmUgYW5kIHJldHVybiBzb21lIChrZXksIHZhbHVlKSBwYWlyIGFzIGFcXG4yLXR1cGxlOyBidXQgcmFpc2UgS2V5RXJyb3IgaWYgRCBpcyBlbXB0eS5cIn0sa2V5czp7JG1ldGgoKXtyZXR1cm4gbmV3IGEodGhpcyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELmtleXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyBrZXlzXCJ9LGl0ZW1zOnskbWV0aCgpe3JldHVybiBuZXcgbih0aGlzKX0sXG4kZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5pdGVtcygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGl0ZW1zXCJ9LHZhbHVlczp7JG1ldGgoKXtyZXR1cm4gbmV3IGModGhpcyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELnZhbHVlcygpIC0+IGFuIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyB2YWx1ZXNcIn0sdXBkYXRlOnskbWV0aChyLHQpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLnVwZGF0ZSRjb21tb24ocix0LFwidXBkYXRlXCIpLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELnVwZGF0ZShbRSwgXSoqRikgLT4gTm9uZS4gIFVwZGF0ZSBEIGZyb20gZGljdC9pdGVyYWJsZSBFIGFuZCBGLlxcbklmIEUgaXMgcHJlc2VudCBhbmQgaGFzIGEgLmtleXMoKSBtZXRob2QsIHRoZW4gZG9lczogIGZvciBrIGluIEU6IERba10gPSBFW2tdXFxuSWYgRSBpcyBwcmVzZW50IGFuZCBsYWNrcyBhIC5rZXlzKCkgbWV0aG9kLCB0aGVuIGRvZXM6ICBmb3IgaywgdiBpbiBFOiBEW2tdID0gdlxcbkluIGVpdGhlciBjYXNlLCB0aGlzIGlzIGZvbGxvd2VkIGJ5OiBmb3IgayBpbiBGOiAgRFtrXSA9IEZba11cIn0sXG5jbGVhcjp7JG1ldGgoKXt0aGlzLnNpemU9MDt0aGlzLiR2ZXJzaW9uKys7dGhpcy5lbnRyaWVzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5idWNrZXRzPXt9fSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5jbGVhcigpIC0+IE5vbmUuICBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gRC5cIn0sY29weTp7JG1ldGgoKXtyZXR1cm4gdGhpcy5kaWN0JGNvcHkoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuY29weSgpIC0+IGEgc2hhbGxvdyBjb3B5IG9mIERcIn19LGNsYXNzbWV0aG9kczpPYmplY3QuYXNzaWduKHtmcm9ta2V5czp7JG1ldGg6ZnVuY3Rpb24ocix0KXt0PXR8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtsZXQgeD10aGlzPT09U2suYnVpbHRpbi5kaWN0P25ldyB0aGlzOnRoaXMudHAkY2FsbChbXSxbXSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHgsdj0+e3g9djtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHIpLFxuQj0+eC5tcCRhc3Nfc3Vic2NyaXB0KEIsdCwhMCkpfSwoKT0+eCl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJHR5cGUsIGl0ZXJhYmxlLCB2YWx1ZT1Ob25lLCAvKVwiLCRkb2M6XCJDcmVhdGUgYSBuZXcgZGljdGlvbmFyeSB3aXRoIGtleXMgZnJvbSBpdGVyYWJsZSBhbmQgdmFsdWVzIHNldCB0byB2YWx1ZS5cIn19LFNrLmdlbmVyaWMuY2xhc3NHZXRJdGVtKSxwcm90bzp7cXVpY2skbG9va3VwOmZ1bmN0aW9uKHIpe3I9dGhpcy5lbnRyaWVzW3IuJHNhdmVkS2V5SGFzaF07aWYodm9pZCAwIT09cilyZXR1cm4gclsxXX0sbXAkbG9va3VwOmZ1bmN0aW9uKHIpe2NvbnN0IHQ9YihyKTtyPVwic3RyaW5nXCI9PT10eXBlb2YgdD90aGlzLmVudHJpZXNbdF06dGhpcy5nZXQkYnVja2V0X2l0ZW0ocix0KTtpZih2b2lkIDAhPT1yKXJldHVybiByWzFdfSxnZXQkc2l6ZSgpe3JldHVybiB0aGlzLnNpemV9LHNrJGFzYXJyYXkoKXtyZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmVudHJpZXMpLm1hcChyPT5cbnJbMF0pfSx1cGRhdGUkY29tbW9uOmZ1bmN0aW9uKHIsdCx4KXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oeCxyLDAsMSk7cj1yWzBdO2xldCB2O3ZvaWQgMCE9PXImJih2PXRoaXMudXBkYXRlJG9uZWFyZyhyKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHYsKCk9PntpZih0KWZvcihsZXQgQj0wO0I8dC5sZW5ndGg7Qis9Mil0aGlzLnNldCRpdGVtKG5ldyBTay5idWlsdGluLnN0cih0W0JdKSx0W0IrMV0pfSl9LHVwZGF0ZSRvbmVhcmcocil7cmV0dXJuIHIgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3R8fHZvaWQgMCE9PVNrLmFic3RyLmxvb2t1cFNwZWNpYWwocixTay5idWlsdGluLnN0ci4ka2V5cyk/dGhpcy5kaWN0JG1lcmdlKHIpOnRoaXMuZGljdCRtZXJnZV9zZXEocil9LGRpY3QkY29weSgpe2NvbnN0IHI9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7ci5zaXplPXRoaXMuc2l6ZTt2YXIgdD1PYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpO2Zvcih2YXIgeCBpbiB0KXt2YXIgdj1cbnRbeF1bMV07ci5lbnRyaWVzW3RbeF1bMF1dPVt2WzBdLHZbMV1dfWZvcihsZXQgQiBpbiB0aGlzLmJ1Y2tldHMpZm9yKHg9dGhpcy5idWNrZXRzW0JdLHIuYnVja2V0c1tCXT10PVtdLHY9MDt2PHgubGVuZ3RoO3YrKyl0LnB1c2goci5lbnRyaWVzW1wiI1wiK0IrXCJfXCIrdl0pO3JldHVybiByfSwkaXRlbXMoKXtyZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmVudHJpZXMpfSxzZXQkaXRlbTpmdW5jdGlvbihyLHQpe2NvbnN0IHg9YihyKTtsZXQgdjtcInN0cmluZ1wiPT09dHlwZW9mIHg/KHY9dGhpcy5lbnRyaWVzW3hdLHZvaWQgMD09PXY/KHRoaXMuZW50cmllc1t4XT1bcix0XSx0aGlzLnNpemUrKyx0aGlzLiR2ZXJzaW9uKyspOnZbMV09dCk6KHY9dGhpcy5nZXQkYnVja2V0X2l0ZW0ocix4KSx2b2lkIDA9PT12Pyh0aGlzLnNldCRidWNrZXRfaXRlbShyLHQseCksdGhpcy5zaXplKyssdGhpcy4kdmVyc2lvbisrKTp2WzFdPXQpfSxnZXQkYnVja2V0X2l0ZW06ZnVuY3Rpb24ocix0KXt0PVxudGhpcy5idWNrZXRzW3RdO2lmKHZvaWQgMCE9PXQpZm9yKGxldCB2PTA7djx0Lmxlbmd0aDt2Kyspe3ZhciB4PXRbdl07aWYodm9pZCAwIT09eCYmKHhbMF09PT1yfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wocix4WzBdLFwiRXFcIikpKXJldHVybiB4fX0scG9wJGJ1Y2tldF9pdGVtOmZ1bmN0aW9uKHIsdCl7Y29uc3QgeD10aGlzLmJ1Y2tldHNbdF07bGV0IHY7aWYodm9pZCAwIT09eClmb3IobGV0IEI9MDtCPHgubGVuZ3RoO0IrKylpZih2PXhbQl0sdm9pZCAwIT09diYmKHZbMF09PT1yfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wocix2WzBdLFwiRXFcIikpKXJldHVybiBkZWxldGUgdGhpcy5lbnRyaWVzW1wiI1wiK3QrXCJfXCIrQl0seFtCXT12b2lkIDAseC5ldmVyeShJPT52b2lkIDA9PT1JKSYmZGVsZXRlIHRoaXMuYnVja2V0c1t0XSx2fSxzZXQkYnVja2V0X2l0ZW06ZnVuY3Rpb24ocix0LHgpe2xldCB2PXRoaXMuYnVja2V0c1t4XTtyPVtyLHRdO3ZvaWQgMD09PXY/KHRoaXMuYnVja2V0c1t4XT1cbltyXSx4PVwiI1wiK3grXCJfMFwiKToodD12LmluZGV4T2Yodm9pZCAwKSwtMSE9PXQ/KHg9XCIjXCIreCtcIl9cIit0LHZbdF09cik6KHg9XCIjXCIreCtcIl9cIit2Lmxlbmd0aCx2LnB1c2gocikpKTt0aGlzLmVudHJpZXNbeF09cn0scG9wJGl0ZW06ZnVuY3Rpb24ocil7Y29uc3QgdD1iKHIpO1wic3RyaW5nXCI9PT10eXBlb2YgdD8ocj10aGlzLmVudHJpZXNbdF0sZGVsZXRlIHRoaXMuZW50cmllc1t0XSk6cj10aGlzLnBvcCRidWNrZXRfaXRlbShyLHQpO2lmKHZvaWQgMCE9PXIpcmV0dXJuIHRoaXMuc2l6ZS0tLHRoaXMuJHZlcnNpb24rKyxyfSxkaWN0JG1lcmdlOmZ1bmN0aW9uKHIpe2lmKHIudHAkaXRlcj09PVNrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUudHAkaXRlcil7dmFyIHQ9ci50cCRpdGVyKCk7Zm9yKGxldCB4PXQudHAkaXRlcm5leHQoKTt2b2lkIDAhPT14O3g9dC50cCRpdGVybmV4dCgpKXtjb25zdCB2PXIubXAkc3Vic2NyaXB0KHgpO3RoaXMuc2V0JGl0ZW0oeCx2KX19ZWxzZXt0PVNrLmFic3RyLmxvb2t1cFNwZWNpYWwocixcblNrLmJ1aWx0aW4uc3RyLiRrZXlzKTtpZih2b2lkIDA9PT10KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShyKStcIicgb2JqZWN0IGlzIG5vdCBhIG1hcHBpbmdcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0KSx4PT5Tay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoeCksdj0+U2subWlzY2V2YWwuY2hhaW4oU2suYWJzdHIub2JqZWN0R2V0SXRlbShyLHYsITApLEI9Pnt0aGlzLnNldCRpdGVtKHYsQil9KSkpfX0sZGljdCRtZXJnZV9zZXE6ZnVuY3Rpb24ocil7bGV0IHQ9MDtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKHIpLHg9PntpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKHgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbm5vdCBjb252ZXJ0IGRpY3Rpb25hcnkgdXBkYXRlIHNlcXVlbmNlIGVsZW1lbnQgI1wiK1xudCtcIiB0byBhIHNlcXVlbmNlXCIpO3g9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoeCk7aWYoMiE9PXgubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJkaWN0aW9uYXJ5IHVwZGF0ZSBzZXF1ZW5jZSBlbGVtZW50ICNcIit0K1wiIGhhcyBsZW5ndGggXCIreC5sZW5ndGgrXCI7IDIgaXMgcmVxdWlyZWRcIik7dGhpcy5zZXQkaXRlbSh4WzBdLHhbMV0pO3QrK30pfX19KTtjb25zdCBnPXt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19udW1iZXI6ITAsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiLi4uXCIpO3RoaXMuaW4kcmVwcj0hMDtsZXQgcj1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZSh0aGlzKTtyPXIubWFwKHQ9PlNrLm1pc2NldmFsLm9iamVjdFJlcHIodCkpO3RoaXMuaW4kcmVwcj0hMTtcbnJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCIoW1wiK3Iuam9pbihcIiwgXCIpK1wiXSlcIil9LHRwJHJpY2hjb21wYXJlKHIsdCl7aWYoIShTay5idWlsdGluLmNoZWNrQW55U2V0KHIpfHxyIGluc3RhbmNlb2YgYXx8ciBpbnN0YW5jZW9mIG4pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCB4PXRoaXMuc3EkbGVuZ3RoKCksdj1yLnNxJGxlbmd0aCgpO3N3aXRjaCh0KXtjYXNlIFwiTm90RXFcIjpjYXNlIFwiRXFcIjpsZXQgQjt0aGlzPT09cj9CPSEwOng9PT12JiYoQj1kKHRoaXMscikpO3JldHVyblwiTm90RXFcIj09PXQ/IUI6QjtjYXNlIFwiTHRcIjpyZXR1cm4geDx2JiZkKHRoaXMscik7Y2FzZSBcIkx0RVwiOnJldHVybiB4PD12JiZkKHRoaXMscik7Y2FzZSBcIkd0XCI6cmV0dXJuIHg+diYmZChyLHRoaXMpO2Nhc2UgXCJHdEVcIjpyZXR1cm4geD49diYmZChyLHRoaXMpfX0sbmIkc3VidHJhY3Qocil7Y29uc3QgdD1cbmUodGhpcyk7cmV0dXJuIHQuZGlmZmVyZW5jZS4kbWV0aC5jYWxsKHQscil9LG5iJGFuZChyKXtjb25zdCB0PWUodGhpcyk7cmV0dXJuIHQuaW50ZXJzZWN0aW9uLiRtZXRoLmNhbGwodCxyKX0sbmIkb3Iocil7Y29uc3QgdD1lKHRoaXMpO3JldHVybiB0LnVuaW9uLiRtZXRoLmNhbGwodCxyKX0sbmIkeG9yKHIpe2NvbnN0IHQ9ZSh0aGlzKTtyZXR1cm4gdC5zeW1tZXRyaWNfZGlmZmVyZW5jZS4kbWV0aC5jYWxsKHQscil9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLmRpY3QuZ2V0JHNpemUoKX19O3ZhciBhPWYoXCJkaWN0X2tleXNcIix7c3EkY29udGFpbnMocil7cmV0dXJuIHZvaWQgMCE9PXRoaXMuZGljdC5tcCRsb29rdXAocil9LHRwJGl0ZXIoKXtyZXR1cm4gbmV3IG0odGhpcy5kaWN0KX19LGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBsKHRoaXMuZGljdCl9KSxjPWYoXCJkaWN0X3ZhbHVlc1wiLHt0cCRpdGVyKCl7cmV0dXJuIG5ldyB1KHRoaXMuZGljdCl9fSxmdW5jdGlvbigpe3JldHVybiBuZXcgeih0aGlzLmRpY3QpfSksXG5uPWYoXCJkaWN0X2l0ZW1zXCIse3NxJGNvbnRhaW5zKHIpe2lmKCEociBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUmJjI9PT1yLnNxJGxlbmd0aCgpKSlyZXR1cm4hMTt2YXIgdD1yLm1wJHN1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5pbnRfKDApKTtyPXIubXAkc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLmludF8oMSkpO3Q9dGhpcy5kaWN0Lm1wJGxvb2t1cCh0KTtyZXR1cm4gdm9pZCAwPT09dD8hMTp0PT09cnx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHQscixcIkVxXCIpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBrKHRoaXMuZGljdCl9fSxmdW5jdGlvbigpe3JldHVybiBuZXcgcSh0aGlzLmRpY3QpfSksbT1oKFwiZGljdF9rZXlpdGVyYXRvclwiLGZ1bmN0aW9uKCl7Y29uc3Qgcj10aGlzLm5leHQkaXRlbSgpO3JldHVybiByJiZyWzBdfSksaz1oKFwiZGljdF9pdGVtaXRlcmF0b3JcIixmdW5jdGlvbigpe2NvbnN0IHI9dGhpcy5uZXh0JGl0ZW0oKTtyZXR1cm4gciYmbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3JbMF0sXG5yWzFdXSl9KSx1PWgoXCJkaWN0X3ZhbHVlaXRlcmF0b3JcIixmdW5jdGlvbigpe2NvbnN0IHI9dGhpcy5uZXh0JGl0ZW0oKTtyZXR1cm4gciYmclsxXX0pLGw9aChcImRpY3RfcmV2ZXJzZWtleWl0ZXJhdG9yXCIsbS5wcm90b3R5cGUudHAkaXRlcm5leHQsITApLHE9aChcImRpY3RfcmV2ZXJzZWl0ZW1pdGVyYXRvclwiLGsucHJvdG90eXBlLnRwJGl0ZXJuZXh0LCEwKSx6PWgoXCJkaWN0X3JldmVyc2V2YWx1ZWl0ZXJhdG9yXCIsdS5wcm90b3R5cGUudHAkaXRlcm5leHQsITApO1NrLmJ1aWx0aW4uZGljdC5weTIkbWV0aG9kcz17aGFzX2tleTp7JG5hbWU6XCJoYXNfa2V5XCIsJGZsYWdzOntPbmVBcmc6ITB9LCRtZXRoKHIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMuc3EkY29udGFpbnMocikpfSwkZG9jOlwiRC5oYXNfa2V5KGspIC0+IFRydWUgaWYgRCBoYXMgYSBrZXkgaywgZWxzZSBGYWxzZVwifSxrZXlzOnskbmFtZTpcImtleXNcIiwkbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMuc2skYXNhcnJheSgpKX0sXG4kZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5rZXlzKCkgLT4gYSBzZXQtbGlrZSBvYmplY3QgcHJvdmlkaW5nIGEgdmlldyBvbiBEJ3Mga2V5c1wifSxpdGVtczp7JG5hbWU6XCJpdGVtc1wiLCRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QodGhpcy4kaXRlbXMoKS5tYXAocj0+e3ZhciBbdCx4XT1yO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbdCx4XSl9KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELml0ZW1zKCkgLT4gYSBzZXQtbGlrZSBvYmplY3QgcHJvdmlkaW5nIGEgdmlldyBvbiBEJ3MgaXRlbXNcIn0sdmFsdWVzOnskbmFtZTpcInZhbHVlc1wiLCRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QodGhpcy4kaXRlbXMoKS5tYXAocj0+e1sscl09cjtyZXR1cm4gcn0pKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQudmFsdWVzKCkgLT4gYW4gb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIHZhbHVlc1wifX19LFxuZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKGUsZCl7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSx7ZW50cmllczp7Z2V0OigpPT57Y29uc3QgZj1PYmplY3QuY3JlYXRlKG51bGwpO09iamVjdC5lbnRyaWVzKGQpLmZvckVhY2goaD0+e3ZhciBbcCxnXT1oO3A9U2sudW5maXhSZXNlcnZlZChwKTtwLmluY2x1ZGVzKFwiJFwiKXx8KHA9bmV3IFNrLmJ1aWx0aW4uc3RyKHApLGZbcC4kc2F2ZWRLZXlIYXNoXT1bcCxnXSl9KTtyZXR1cm4gZn0sY29uZmlndXJhYmxlOiEwfSxzaXplOntnZXQ6KCk9Pk9iamVjdC5rZXlzKGQpLm1hcChmPT5Tay51bmZpeFJlc2VydmVkKGYpKS5maWx0ZXIoZj0+IWYuaW5jbHVkZXMoXCIkXCIpKS5sZW5ndGgsY29uZmlndXJhYmxlOiEwfX0pfVNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJtYXBwaW5ncHJveHlcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZSl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5LFxuXCJiYWQgY2FsbCB0byBtYXBwaW5nIHByb3h5LCB1c2UgJ25ldydcIik7aWYodm9pZCAwIT09ZSl7Y29uc3QgZD1lLmNvbnN0cnVjdG9yO2Q9PT1PYmplY3R8fG51bGw9PT1kfHxlLmhhc093blByb3BlcnR5KFwic2skb2JqZWN0XCIpPyh0aGlzLm1hcHBpbmc9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSksYih0aGlzLm1hcHBpbmcsZSkpOlNrLmJ1aWx0aW4uY2hlY2tNYXBwaW5nKGUpP3RoaXMubWFwcGluZz1lOlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlIGZvciBtYXBwaW5ncHJveHlcIil9fSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRuZXcoZSxkKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwibWFwcGluZ3Byb3h5XCIsZCk7U2suYWJzdHIuY2hlY2tPbmVBcmcoXCJtYXBwaW5ncHJveHlcIixlLGQpO2U9ZVswXTtpZighU2suYnVpbHRpbi5jaGVja01hcHBpbmcoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibWFwcGluZ3Byb3h5KCkgYXJndW1lbnQgbXVzdCBiZSBhIG1hcHBpbmcsIG5vdCBcIitcblNrLmFic3RyLnR5cGVOYW1lKGUpKTtkPW5ldyBTay5idWlsdGluLm1hcHBpbmdwcm94eTtkLm1hcHBpbmc9ZTtyZXR1cm4gZH0sdHAkcmljaGNvbXBhcmUoZSxkKXtyZXR1cm4gU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHRoaXMubWFwcGluZyxlLGQpfSx0cCRzdHIoKXtyZXR1cm4gdGhpcy5tYXBwaW5nLnRwJHN0cigpfSwkcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJtYXBwaW5ncHJveHkoXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLm1hcHBpbmcpK1wiKVwiKX0sbXAkc3Vic2NyaXB0KGUsZCl7cmV0dXJuIHRoaXMubWFwcGluZy5tcCRzdWJzY3JpcHQoZSxkKX0sc3EkY29udGFpbnMoZSl7cmV0dXJuIHRoaXMubWFwcGluZy5zcSRjb250YWlucyhlKX0sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMubWFwcGluZy5zcSRsZW5ndGgoKX0sdHAkaXRlcigpe3JldHVybiB0aGlzLm1hcHBpbmcudHAkaXRlcigpfSx0cCRhc19udW1iZXI6ITAsbmIkb3IoZSl7ZSBpbnN0YW5jZW9mXG5Tay5idWlsdGluLm1hcHBpbmdwcm94eSYmKGU9ZS5tYXBwaW5nKTtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AodGhpcy5tYXBwaW5nLGUsXCJCaXRPclwiKX0sbmIkcmVmbGVjdGVkX29yKGUpe2UgaW5zdGFuY2VvZiBTay5idWlsdGluLm1hcHBpbmdwcm94eSYmKGU9ZS5tYXBwaW5nKTtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoZSx0aGlzLm1hcHBpbmcsXCJCaXRPclwiKX0sbmIkaW5wbGFjZV9vcihlKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInfD0nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCI7IHVzZSAnfCcgaW5zdGVhZFwiKTt9fSxtZXRob2RzOntnZXQ6eyRtZXRoKGUsZCl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLm1hcHBpbmcudHAkZ2V0YXR0cih0aGlzLnN0ciRnZXQpLGUsZCl9LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuZ2V0KGtbLGRdKSAtPiBEW2tdIGlmIGsgaW4gRCwgZWxzZSBkLiAgZCBkZWZhdWx0cyB0byBOb25lLlwifSxcbmtleXM6eyRtZXRoKCl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLm1hcHBpbmcudHAkZ2V0YXR0cih0aGlzLnN0ciRrZXlzKSxbXSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELmtleXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyBrZXlzXCJ9LGl0ZW1zOnskbWV0aCgpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5tYXBwaW5nLnRwJGdldGF0dHIodGhpcy5zdHIkaXRlbXMpLFtdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuaXRlbXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyBpdGVtc1wifSx2YWx1ZXM6eyRtZXRoKCl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLm1hcHBpbmcudHAkZ2V0YXR0cih0aGlzLnN0ciR2YWx1ZXMpLFtdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsXG4kZG9jOlwiRC52YWx1ZXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyB2YWx1ZXNcIn0sY29weTp7JG1ldGgoKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMubWFwcGluZy50cCRnZXRhdHRyKHRoaXMuc3RyJGNvcHkpLFtdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuY29weSgpIC0+IGEgc2hhbGxvdyBjb3B5IG9mIERcIn19LGNsYXNzbWV0aG9kczpTay5nZW5lcmljLmNsYXNzR2V0SXRlbSxwcm90bzp7c3RyJGdldDpuZXcgU2suYnVpbHRpbi5zdHIoXCJnZXRcIiksc3RyJGNvcHk6bmV3IFNrLmJ1aWx0aW4uc3RyKFwiY29weVwiKSxzdHIka2V5czpuZXcgU2suYnVpbHRpbi5zdHIoXCJrZXlzXCIpLHN0ciRpdGVtczpuZXcgU2suYnVpbHRpbi5zdHIoXCJpdGVtc1wiKSxzdHIkdmFsdWVzOm5ldyBTay5idWlsdGluLnN0cihcInZhbHVlc1wiKSxtcCRsb29rdXAoZSl7cmV0dXJuIHRoaXMubWFwcGluZy5tcCRsb29rdXAoZSl9fSxcbmZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pfSxmdW5jdGlvbihGLFApe1NrLmJ1aWx0aW4ucHJvcGVydHk9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInByb3BlcnR5XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZSxkLGYpe3RoaXMucHJvcCRnZXQ9Ynx8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMucHJvcCRzZXQ9ZXx8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMucHJvcCRkZWw9ZHx8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMucHJvcCRkb2M9Znx8YiYmYi4kZG9jfHxTay5idWlsdGluLm5vbmUubm9uZSR9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRuZXc6U2suZ2VuZXJpYy5uZXcsdHAkaW5pdChiLGUpe2I9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJwcm9wZXJ0eVwiLFtcImZnZXRcIixcImZzZXRcIixcImZkZWxcIixcImRvY1wiXSxiLGUsQXJyYXkoNCkuZmlsbChTay5idWlsdGluLm5vbmUubm9uZSQpKTt0aGlzLnByb3AkZ2V0PVxuYlswXTt0aGlzLnByb3Akc2V0PWJbMV07dGhpcy5wcm9wJGRlbD1iWzJdO1NrLmJ1aWx0aW4uY2hlY2tOb25lKGJbM10pP1NrLmJ1aWx0aW4uY2hlY2tOb25lKGJbMF0pfHwodGhpcy5wcm9wJGRvYz1iWzBdLiRkb2N8fGJbM10pOnRoaXMucHJvcCRkb2M9YlszXX0sdHAkZG9jOlwiUHJvcGVydHkgYXR0cmlidXRlLlxcblxcbiAgZmdldFxcbiAgICBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBnZXR0aW5nIGFuIGF0dHJpYnV0ZSB2YWx1ZVxcbiAgZnNldFxcbiAgICBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBzZXR0aW5nIGFuIGF0dHJpYnV0ZSB2YWx1ZVxcbiAgZmRlbFxcbiAgICBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBkZWwnaW5nIGFuIGF0dHJpYnV0ZVxcbiAgZG9jXFxuICAgIGRvY3N0cmluZ1xcblxcblR5cGljYWwgdXNlIGlzIHRvIGRlZmluZSBhIG1hbmFnZWQgYXR0cmlidXRlIHg6XFxuXFxuY2xhc3MgQyhvYmplY3QpOlxcbiAgICBkZWYgZ2V0eChzZWxmKTogcmV0dXJuIHNlbGYuX3hcXG4gICAgZGVmIHNldHgoc2VsZiwgdmFsdWUpOiBzZWxmLl94ID0gdmFsdWVcXG4gICAgZGVmIGRlbHgoc2VsZik6IGRlbCBzZWxmLl94XFxuICAgIHggPSBwcm9wZXJ0eShnZXR4LCBzZXR4LCBkZWx4LCAnSSdtIHRoZSAneCcgcHJvcGVydHkuJylcXG5cXG5EZWNvcmF0b3JzIG1ha2UgZGVmaW5pbmcgbmV3IHByb3BlcnRpZXMgb3IgbW9kaWZ5aW5nIGV4aXN0aW5nIG9uZXMgZWFzeTpcXG5cXG5jbGFzcyBDKG9iamVjdCk6XFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgeChzZWxmKTpcXG4gICAgICAgICdJIGFtIHRoZSAneCcgcHJvcGVydHkuJ1xcbiAgICAgICAgcmV0dXJuIHNlbGYuX3hcXG4gICAgQHguc2V0dGVyXFxuICAgIGRlZiB4KHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIHNlbGYuX3ggPSB2YWx1ZVxcbiAgICBAeC5kZWxldGVyXFxuICAgIGRlZiB4KHNlbGYpOlxcbiAgICAgICAgZGVsIHNlbGYuX3hcIixcbnRwJGRlc2NyX2dldChiLGUsZCl7aWYobnVsbD09PWIpcmV0dXJuIHRoaXM7aWYodm9pZCAwPT09dGhpcy5wcm9wJGdldCl0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcInVucmVhZGFibGUgYXR0cmlidXRlXCIpO2I9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHRoaXMucHJvcCRnZXQsW2JdKTtyZXR1cm4gZD9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKX0sdHAkZGVzY3Jfc2V0KGIsZSxkKXtsZXQgZjtmPW51bGw9PWU/dGhpcy5wcm9wJGRlbDp0aGlzLnByb3Akc2V0O2lmKFNrLmJ1aWx0aW4uY2hlY2tOb25lKGYpKXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiY2FuJ3QgXCIrKG51bGw9PWU/XCJkZWxldGVcIjpcInNldFwiKStcIiBhdHRyaWJ1dGVcIik7aWYoIWYudHAkY2FsbCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCInIGlzIG5vdCBjYWxsYWJsZVwiKTtcbmI9bnVsbD09ZT9mLnRwJGNhbGwoW2JdKTpmLnRwJGNhbGwoW2IsZV0pO3JldHVybiBkP2I6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGIpfX0sbWV0aG9kczp7Z2V0dGVyOnskbWV0aChiKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucHJvcGVydHkoYix0aGlzLnByb3Akc2V0LHRoaXMucHJvcCRkZWwsdGhpcy5wcm9wJGRvYyl9LCRmbGFnczp7T25lQXJnOiEwfX0sc2V0dGVyOnskbWV0aChiKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucHJvcGVydHkodGhpcy5wcm9wJGdldCxiLHRoaXMucHJvcCRkZWwsdGhpcy5wcm9wJGRvYyl9LCRmbGFnczp7T25lQXJnOiEwfX0sZGVsZXRlcjp7JG1ldGgoYil7cmV0dXJuIG5ldyBTay5idWlsdGluLnByb3BlcnR5KHRoaXMucHJvcCRnZXQsdGhpcy5wcm9wJHNldCxiLHRoaXMucHJvcCRkb2MpfSwkZmxhZ3M6e09uZUFyZzohMH19fSxnZXRzZXRzOntmZ2V0OnskZ2V0KCl7cmV0dXJuIHRoaXMucHJvcCRnZXR9fSxmc2V0OnskZ2V0KCl7cmV0dXJuIHRoaXMucHJvcCRzZXR9fSxcbmZkZWw6eyRnZXQoKXtyZXR1cm4gdGhpcy5wcm9wJGRlbH19LF9fZG9jX186eyRnZXQoKXtyZXR1cm4gdGhpcy5wcm9wJGRvY30sJHNldChiKXt0aGlzLnByb3AkZG9jPWI9Ynx8U2suYnVpbHRpbi5ub25lLm5vbmUkfX19fSk7U2suYnVpbHRpbi5jbGFzc21ldGhvZD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiY2xhc3NtZXRob2RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYil7dGhpcy5jbSRjYWxsYWJsZT1iO3RoaXMuJGQ9bmV3IFNrLmJ1aWx0aW4uZGljdH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJG5ldzpTay5nZW5lcmljLm5ldyx0cCRpbml0KGIsZSl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcImNsYXNzbWV0aG9kXCIsZSk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwiY2xhc3NtZXRob2RcIixiLDEsMSk7dGhpcy5jbSRjYWxsYWJsZT1iWzBdfSx0cCRkb2M6XCJjbGFzc21ldGhvZChmdW5jdGlvbikgLT4gbWV0aG9kXFxuXFxuQ29udmVydCBhIGZ1bmN0aW9uIHRvIGJlIGEgY2xhc3MgbWV0aG9kLlxcblxcbkEgY2xhc3MgbWV0aG9kIHJlY2VpdmVzIHRoZSBjbGFzcyBhcyBpbXBsaWNpdCBmaXJzdCBhcmd1bWVudCxcXG5qdXN0IGxpa2UgYW4gaW5zdGFuY2UgbWV0aG9kIHJlY2VpdmVzIHRoZSBpbnN0YW5jZS5cXG5UbyBkZWNsYXJlIGEgY2xhc3MgbWV0aG9kLCB1c2UgdGhpcyBpZGlvbTpcXG5cXG4gIGNsYXNzIEM6XFxuICAgICAgQGNsYXNzbWV0aG9kXFxuICAgICAgZGVmIGYoY2xzLCBhcmcxLCBhcmcyLCAuLi4pOlxcbiAgICAgICAgICAuLi5cXG5cXG5JdCBjYW4gYmUgY2FsbGVkIGVpdGhlciBvbiB0aGUgY2xhc3MgKGUuZy4gQy5mKCkpIG9yIG9uIGFuIGluc3RhbmNlXFxuKGUuZy4gQygpLmYoKSkuICBUaGUgaW5zdGFuY2UgaXMgaWdub3JlZCBleGNlcHQgZm9yIGl0cyBjbGFzcy5cXG5JZiBhIGNsYXNzIG1ldGhvZCBpcyBjYWxsZWQgZm9yIGEgZGVyaXZlZCBjbGFzcywgdGhlIGRlcml2ZWQgY2xhc3NcXG5vYmplY3QgaXMgcGFzc2VkIGFzIHRoZSBpbXBsaWVkIGZpcnN0IGFyZ3VtZW50LlxcblxcbkNsYXNzIG1ldGhvZHMgYXJlIGRpZmZlcmVudCB0aGFuIEMrKyBvciBKYXZhIHN0YXRpYyBtZXRob2RzLlxcbklmIHlvdSB3YW50IHRob3NlLCBzZWUgdGhlIHN0YXRpY21ldGhvZCBidWlsdGluLlwiLFxudHAkZGVzY3JfZ2V0KGIsZSxkKXtjb25zdCBmPXRoaXMuY20kY2FsbGFibGU7aWYodm9pZCAwPT09Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5SdW50aW1lRXJyb3IoXCJ1bmluaXRpYWxpemVkIGNsYXNzbWV0aG9kIG9iamVjdFwiKTt2b2lkIDA9PT1lJiYoZT1iLm9iJHR5cGUpO3JldHVybihiPWYudHAkZGVzY3JfZ2V0KT9iLmNhbGwoZixlLGQpOm5ldyBTay5idWlsdGluLm1ldGhvZChmLGUpfX0sZ2V0c2V0czp7X19mdW5jX186eyRnZXQoKXtyZXR1cm4gdGhpcy5jbSRjYWxsYWJsZX19LF9fZGljdF9fOlNrLmdlbmVyaWMuZ2V0U2V0RGljdH19KTtTay5idWlsdGluLnN0YXRpY21ldGhvZD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwic3RhdGljbWV0aG9kXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIpe3RoaXMuc20kY2FsbGFibGU9Yjt0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3R9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRuZXc6U2suZ2VuZXJpYy5uZXcsXG50cCRpbml0KGIsZSl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcInN0YXRpY21ldGhvZFwiLGUpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcInN0YXRpY21ldGhvZFwiLGIsMSwxKTt0aGlzLnNtJGNhbGxhYmxlPWJbMF19LHRwJGRvYzpcInN0YXRpY21ldGhvZChmdW5jdGlvbikgLT4gbWV0aG9kXFxuXFxuQ29udmVydCBhIGZ1bmN0aW9uIHRvIGJlIGEgc3RhdGljIG1ldGhvZC5cXG5cXG5BIHN0YXRpYyBtZXRob2QgZG9lcyBub3QgcmVjZWl2ZSBhbiBpbXBsaWNpdCBmaXJzdCBhcmd1bWVudC5cXG5UbyBkZWNsYXJlIGEgc3RhdGljIG1ldGhvZCwgdXNlIHRoaXMgaWRpb206XFxuXFxuICAgICBjbGFzcyBDOlxcbiAgICAgICAgIEBzdGF0aWNtZXRob2RcXG4gICAgICAgICBkZWYgZihhcmcxLCBhcmcyLCAuLi4pOlxcbiAgICAgICAgICAgICAuLi5cXG5cXG5JdCBjYW4gYmUgY2FsbGVkIGVpdGhlciBvbiB0aGUgY2xhc3MgKGUuZy4gQy5mKCkpIG9yIG9uIGFuIGluc3RhbmNlXFxuKGUuZy4gQygpLmYoKSkuICBUaGUgaW5zdGFuY2UgaXMgaWdub3JlZCBleGNlcHQgZm9yIGl0cyBjbGFzcy5cXG5cXG5TdGF0aWMgbWV0aG9kcyBpbiBQeXRob24gYXJlIHNpbWlsYXIgdG8gdGhvc2UgZm91bmQgaW4gSmF2YSBvciBDKysuXFxuRm9yIGEgbW9yZSBhZHZhbmNlZCBjb25jZXB0LCBzZWUgdGhlIGNsYXNzbWV0aG9kIGJ1aWx0aW4uXCIsXG50cCRkZXNjcl9nZXQoYixlKXtpZih2b2lkIDA9PT10aGlzLnNtJGNhbGxhYmxlKXRocm93IG5ldyBTay5idWlsdGluLlJ1bnRpbWVFcnJvcihcInVuaW5pdGlhbGl6ZWQgc3RhdGljbWV0aG9kIG9iamVjdFwiKTtyZXR1cm4gdGhpcy5zbSRjYWxsYWJsZX19LGdldHNldHM6e19fZnVuY19fOnskZ2V0KCl7cmV0dXJuIHRoaXMuc20kY2FsbGFibGV9fSxfX2RpY3RfXzpTay5nZW5lcmljLmdldFNldERpY3R9fSl9LGZ1bmN0aW9uKEYsUCl7ZnVuY3Rpb24gYih5LEEpe3JldHVybiBmdW5jdGlvbihKKXtpZighKEogaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtsZXQgUT10aGlzLnY7Sj1KLnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBRJiZcIm51bWJlclwiPT09dHlwZW9mIEope2NvbnN0IFg9eShRLEopO2lmKG4oWCkpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oWCl9UT1rKFEpO0o9ayhKKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhBKFEsXG5KKSl9fWZ1bmN0aW9uIGUoeSxBKXtyZXR1cm4gZnVuY3Rpb24oSil7aWYoIShKIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7bGV0IFE9dGhpcy52O0o9Si52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgUSYmXCJudW1iZXJcIj09PXR5cGVvZiBKKXJldHVybiB5KFEsSik7UT1rKFEpO0o9ayhKKTtyZXR1cm4gQShRLEopfX1mdW5jdGlvbiBkKHksQSl7cmV0dXJuIGZ1bmN0aW9uKCl7bGV0IEo9dGhpcy52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgSil7Y29uc3QgUT15KEopO2lmKHZvaWQgMCE9PVEpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oUSk7Sj1rKEopfXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEEoSikpfX1mdW5jdGlvbiBmKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy52KX1mdW5jdGlvbiBoKHksQSl7cmV0dXJuIGZ1bmN0aW9uKEope2lmKCEoSiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO1xubGV0IFE9dGhpcy52O0o9Si52O2lmKDA9PT1KKXRocm93IG5ldyBTay5idWlsdGluLlplcm9EaXZpc2lvbkVycm9yKFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiKTtpZihcIm51bWJlclwiPT09dHlwZW9mIFEmJlwibnVtYmVyXCI9PT10eXBlb2YgSilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh5KFEsSikpO1E9ayhRKTtKPWsoSik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oSlNCSS5udW1iZXJJZlNhZmUoQShRLEopKSl9fWZ1bmN0aW9uIHAoeSxBKXtyZXR1cm4gZnVuY3Rpb24oSil7aWYoIShKIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7aWYoSi5uYiRpc25lZ2F0aXZlKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5lZ2F0aXZlIHNoaWZ0IGNvdW50XCIpO2xldCBRPXRoaXMudjtpZigwPT09USlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygwKTtcbko9Si52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgUSYmXCJudW1iZXJcIj09PXR5cGVvZiBKJiY1Mz5KKXtjb25zdCBYPXkoUSxKKTtpZih2b2lkIDAhPT1YKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKFgpfVE9ayhRKTtKPWsoSik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oQShRLEopKX19ZnVuY3Rpb24gZyh5LEEpe3JldHVybiBmdW5jdGlvbihKKXtpZighKEogaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtsZXQgUT10aGlzLnY7Sj1KLnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBRJiZcIm51bWJlclwiPT09dHlwZW9mIEomJk1hdGguYWJzKFEpPE1hdGgucG93KDIsMzEpJiZNYXRoLmFicyhKKTxNYXRoLnBvdygyLDMxKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh5KFEsSikpO1E9ayhRKTtKPWsoSik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oSlNCSS5udW1iZXJJZlNhZmUoQShRLFxuSikpKX19ZnVuY3Rpb24gYSh5KXtyZXR1cm4gSlNCSS5sZXNzVGhhbih5LEpTQkkuX19aRVJPKT9KU0JJLnVuYXJ5TWludXMoeSk6eX1mdW5jdGlvbiBjKHksQSl7aWYoSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwoSlNCSS5iaXR3aXNlWG9yKHksQSksSlNCSS5fX1pFUk8pKXJldHVybiBKU0JJLmRpdmlkZSh5LEEpO3k9SlNCSS5sZXNzVGhhbih5LEpTQkkuX19aRVJPKT9KU0JJLmFkZCh5LHgpOkpTQkkuc3VidHJhY3QoeSx4KTtyZXR1cm4gSlNCSS5zdWJ0cmFjdChKU0JJLmRpdmlkZSh5LEEpLHgpfWZ1bmN0aW9uIG4oeSl7cmV0dXJuIHk8PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSJiZ5Pj0tTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ9ZnVuY3Rpb24gbSh5KXtyZXR1cm4geTw9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVImJnk+PS1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUj8reTpKU0JJLkJpZ0ludCh5KX1mdW5jdGlvbiBrKHkpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgeT9KU0JJLkJpZ0ludCh5KTpcbnl9ZnVuY3Rpb24gdSh5LEEpe0E9QSE9PVNrLmJ1aWx0aW4ubm9uZS5ub25lJD9Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhBKTpudWxsO2lmKHkgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cilyZXR1cm4gbnVsbD09PUEmJihBPTEwKSxuZXcgU2suYnVpbHRpbi5pbnRfKFNrLnN0cjJudW1iZXIoeS52LEEpKTtpZihudWxsIT09QSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpbnQoKSBjYW4ndCBjb252ZXJ0IG5vbi1zdHJpbmcgd2l0aCBleHBsaWNpdCBiYXNlXCIpO2lmKHZvaWQgMCE9PXkubmIkaW50KXJldHVybiB5Lm5iJGludCgpO2lmKHZvaWQgMCE9PXkubmIkaW5kZXgpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oeS5uYiRpbmRleCgpKTtpZihBPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoeSxTay5idWlsdGluLnN0ci4kdHJ1bmMpKXtBPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShBLFtdKTtpZighU2suYnVpbHRpbi5jaGVja0ludChBKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoU2suYnVpbHRpbi5zdHIuJHRydW5jLiRqc3N0cigpK1xuXCIgcmV0dXJuZWQgbm9uLUludGVncmFsICh0eXBlIFwiK1NrLmFic3RyLnR5cGVOYW1lKHkpK1wiKVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhBLnYpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImludCgpIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIGEgYnl0ZXMtbGlrZSBvYmplY3Qgb3IgYSBudW1iZXIsIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoeSkrXCInXCIpO31mdW5jdGlvbiBsKHkpe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKHkpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidieXRlb3JkZXInIG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoeSkpO3k9eS50b1N0cmluZygpO2lmKFwibGl0dGxlXCI9PT15KXJldHVybiAxO2lmKFwiYmlnXCI9PT15KXJldHVybiAwO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJieXRlb3JkZXIgbXVzdCBiZSBlaXRoZXIgJ2xpdHRsZScgb3IgJ2JpZydcIik7fVNrLmJ1aWx0aW4uaW50Xz1cblNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJpbnRcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oeSl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XyxcImJhZCBjYWxsIHRvIGludCB1c2UgJ25ldydcIik7bGV0IEE7aWYoXCJudW1iZXJcIj09PXR5cGVvZiB5KXtpZigtNjx5JiYyNTc+eSlyZXR1cm4gU1t5XTtBPXl9ZWxzZSBpZihKU0JJLl9faXNCaWdJbnQoeSkpQT15O2Vsc2V7aWYodm9pZCAwPT09eSlyZXR1cm4gRTtpZihcInN0cmluZ1wiPT09dHlwZW9mIHkpQT1tKHkpO2Vsc2V7aWYoeS5uYiRpbnQpcmV0dXJuIHkubmIkaW50KCk7U2suYXNzZXJ0cy5mYWlsKFwiYmFkIGFyZ3VtZW50IHRvIGludCBjb25zdHJ1Y3RvclwiKX19dGhpcy52PUF9LHNsb3RzOnt0cCRhc19udW1iZXI6ITAsdHAkZG9jOlwiaW50KHg9MCkgLT4gaW50ZWdlclxcbmludCh4LCBiYXNlPTEwKSAtPiBpbnRlZ2VyXFxuXFxuQ29udmVydCBhIG51bWJlciBvciBzdHJpbmcgdG8gYW4gaW50ZWdlciwgb3IgcmV0dXJuIDAgaWYgbm8gYXJndW1lbnRzXFxuYXJlIGdpdmVuLiAgSWYgeCBpcyBhIG51bWJlciwgcmV0dXJuIHguX19pbnRfXygpLiAgRm9yIGZsb2F0aW5nIHBvaW50XFxubnVtYmVycywgdGhpcyB0cnVuY2F0ZXMgdG93YXJkcyB6ZXJvLlxcblxcbklmIHggaXMgbm90IGEgbnVtYmVyIG9yIGlmIGJhc2UgaXMgZ2l2ZW4sIHRoZW4geCBtdXN0IGJlIGEgc3RyaW5nLFxcbmJ5dGVzLCBvciBieXRlYXJyYXkgaW5zdGFuY2UgcmVwcmVzZW50aW5nIGFuIGludGVnZXIgbGl0ZXJhbCBpbiB0aGVcXG5naXZlbiBiYXNlLiAgVGhlIGxpdGVyYWwgY2FuIGJlIHByZWNlZGVkIGJ5ICcrJyBvciAnLScgYW5kIGJlIHN1cnJvdW5kZWRcXG5ieSB3aGl0ZXNwYWNlLiAgVGhlIGJhc2UgZGVmYXVsdHMgdG8gMTAuICBWYWxpZCBiYXNlcyBhcmUgMCBhbmQgMi0zNi5cXG5CYXNlIDAgbWVhbnMgdG8gaW50ZXJwcmV0IHRoZSBiYXNlIGZyb20gdGhlIHN0cmluZyBhcyBhbiBpbnRlZ2VyIGxpdGVyYWwuXFxuPj4+IGludCgnMGIxMDAnLCBiYXNlPTApXFxuNFwiLFxuJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi50b1N0cmluZygpKX0sdHAkaGFzaCgpe3ZhciB5PXRoaXMudjtpZihcIm51bWJlclwiPT09dHlwZW9mIHkpe2lmKC0xPT09eSlyZXR1cm4tMjtpZig1MzY4NzA5MTE+eSYmLTUzNjg3MDkxMTx5KXJldHVybiB5O3k9ayh5KX15PUpTQkkudG9OdW1iZXIoSlNCSS5yZW1haW5kZXIoeSxxKSk7cmV0dXJuLTE9PT15Py0yOnl9LHRwJG5ldyh5LEEpezE9PT15Lmxlbmd0aCsoQT9BLmxlbmd0aDowKT8oQT15WzBdLHk9U2suYnVpbHRpbi5ub25lLm5vbmUkKTooeT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcImludFwiLFtudWxsLFwiYmFzZVwiXSx5LEEsW0UsU2suYnVpbHRpbi5ub25lLm5vbmUkXSksQT15WzBdLHk9eVsxXSk7QT11KEEseSk7aWYodGhpcz09PVNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGUpcmV0dXJuIEE7eT1uZXcgdGhpcy5jb25zdHJ1Y3Rvcjt5LnY9QS52O3JldHVybiB5fSx0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cixcbm9iJGVxOmUoKHksQSk9Pnk9PUEsSlNCSS5lcXVhbCksb2IkbmU6ZSgoeSxBKT0+eSE9QSxKU0JJLm5vdEVxdWFsKSxvYiRndDplKCh5LEEpPT55PkEsSlNCSS5ncmVhdGVyVGhhbiksb2IkZ2U6ZSgoeSxBKT0+eT49QSxKU0JJLmdyZWF0ZXJUaGFuT3JFcXVhbCksb2IkbHQ6ZSgoeSxBKT0+eTxBLEpTQkkubGVzc1RoYW4pLG9iJGxlOmUoKHksQSk9Pnk8PUEsSlNCSS5sZXNzVGhhbk9yRXF1YWwpLG5iJGludDpmLG5iJGluZGV4KCl7cmV0dXJuIHRoaXMudn0sbmIkZmxvYXQoKXt2YXIgeT10aGlzLnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiB5KXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oeSk7eT1wYXJzZUZsb2F0KEpTQkkudG9OdW1iZXIoeSkpO2lmKEluZmluaXR5PT09eXx8LUluZmluaXR5PT09eSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50IHRvbyBsYXJnZSB0byBjb252ZXJ0IHRvIGZsb2F0XCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oeSl9LFxubmIkaXNuZWdhdGl2ZSgpe2NvbnN0IHk9dGhpcy52O3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgeT8wPnk6SlNCSS5sZXNzVGhhbih5LEpTQkkuX19aRVJPKX0sbmIkaXNwb3NpdGl2ZSgpe2NvbnN0IHk9dGhpcy52O3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgeT8wPD15OkpTQkkuZ3JlYXRlclRoYW5PckVxdWFsKHksSlNCSS5fX1pFUk8pfSxuYiRib29sKCl7cmV0dXJuIDAhPT10aGlzLnZ9LG5iJHBvc2l0aXZlOmYsbmIkbmVnYXRpdmU6ZCh5PT4teSxKU0JJLnVuYXJ5TWludXMpLG5iJGFkZDpiKCh5LEEpPT55K0EsKHksQSk9PkpTQkkubnVtYmVySWZTYWZlKEpTQkkuYWRkKHksQSkpKSxuYiRzdWJ0cmFjdDpiKCh5LEEpPT55LUEsKHksQSk9PkpTQkkubnVtYmVySWZTYWZlKEpTQkkuc3VidHJhY3QoeSxBKSkpLG5iJG11bHRpcGx5OmIoKHksQSk9PnkqQSwoeSxBKT0+eT09PUpTQkkuX19aRVJPfHxBPT09SlNCSS5fX1pFUk8/MDpKU0JJLm11bHRpcGx5KHksQSkpLG5iJGRpdmlkZTpmdW5jdGlvbih5KXtpZighU2suX19mdXR1cmVfXy5weXRob24zKXJldHVybiB0aGlzLm5iJGZsb29yX2RpdmlkZSh5KTtcbmlmKCEoeSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO3ZhciBBPXRoaXMudixKPXkudjtpZigwPT09Sil0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImRpdmlzaW9uIGJ5IHplcm9cIik7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBBJiZcIm51bWJlclwiPT09dHlwZW9mIEopcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhBL0opO0E9ayhBKTtKPWsoSik7eT1KU0JJLmxlc3NUaGFuKEpTQkkuYml0d2lzZVhvcihBLEopLEpTQkkuX19aRVJPKTtpZihKU0JJLmVxdWFsKEEsSlNCSS5fX1pFUk8pKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oeT8tMDowKTtBPWEoQSk7Sj1hKEopO2lmKEpTQkkuZ3JlYXRlclRoYW5PckVxdWFsKEEsSlNCSS5tdWx0aXBseSh2LEopKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50L2ludCB0b28gbGFyZ2UgdG8gcmVwcmVzZW50IGFzIGEgZmxvYXRcIik7XG52YXIgUT1BLnRvU3RyaW5nKDIpLmxlbmd0aC1KLnRvU3RyaW5nKDIpLmxlbmd0aCxYPUpTQkkuQmlnSW50KDA+UT8tUTpRKTtpZigwPD1RJiZKU0JJLmdyZWF0ZXJUaGFuT3JFcXVhbChBLEpTQkkubXVsdGlwbHkoSlNCSS5leHBvbmVudGlhdGUodCxYKSxKKSl8fDA+USYmSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwoSlNCSS5tdWx0aXBseShBLEpTQkkuZXhwb25lbnRpYXRlKHQsWCkpLEopKVErPTE7UT1NYXRoLm1heChRLHIpLXo7QT1KU0JJLmxlZnRTaGlmdChBLEpTQkkuQmlnSW50KE1hdGgubWF4KC1RLDApKSk7Sj1KU0JJLmxlZnRTaGlmdChKLEpTQkkuQmlnSW50KE1hdGgubWF4KFEsMCkpKTtYPUpTQkkuZGl2aWRlKEEsSik7QT1KU0JJLnJlbWFpbmRlcihBLEopO0E9SlNCSS5tdWx0aXBseSh0LEEpO2lmKEpTQkkuZ3JlYXRlclRoYW4oQSxKKXx8SlNCSS5lcXVhbChBLEopJiZKU0JJLmVxdWFsKEpTQkkucmVtYWluZGVyKFgsdCkseCkpWD1KU0JJLmFkZChYLHgpO1g9SlNCSS50b051bWJlcihYKTtcbmlmKEluZmluaXR5PT09WHx8LUluZmluaXR5PT09WCl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50L2ludCB0b28gbGFyZ2UgdG8gcmVwcmVzZW50IGFzIGEgZmxvYXRcIik7Sj1YKk1hdGgucG93KDIsUSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh5Py1KOkopfSxuYiRmbG9vcl9kaXZpZGU6aCgoeSxBKT0+TWF0aC5mbG9vcih5L0EpLGMpLG5iJHJlbWFpbmRlcjpoKCh5LEEpPT55LU1hdGguZmxvb3IoeS9BKSpBLCh5LEEpPT5KU0JJLnN1YnRyYWN0KHksSlNCSS5tdWx0aXBseShBLGMoeSxBKSkpKSxuYiRkaXZtb2QoeSl7Y29uc3QgQT10aGlzLm5iJGZsb29yX2RpdmlkZSh5KTt5PXRoaXMubmIkcmVtYWluZGVyKHkpO3JldHVybiBBPT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR8fHk9PT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJD9Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDpcbm5ldyBTay5idWlsdGluLnR1cGxlKFtBLHldKX0sbmIkYW5kOmcoKHksQSk9PnkmQSxKU0JJLmJpdHdpc2VBbmQpLG5iJG9yOmcoKHksQSk9Pnl8QSxKU0JJLmJpdHdpc2VPciksbmIkeG9yOmcoKHksQSk9PnleQSxKU0JJLmJpdHdpc2VYb3IpLG5iJGFiczpkKE1hdGguYWJzLGEpLG5iJGxzaGlmdDpwKCh5LEEpPT57eT0yKnkqSVtBXTtpZihuKHkpKXJldHVybiB5fSxKU0JJLmxlZnRTaGlmdCksbmIkcnNoaWZ0OnAoKHksQSk9PntNYXRoLmZsb29yKHkvSVtBKzFdKX0sKHksQSk9PkpTQkkubnVtYmVySWZTYWZlKEpTQkkuc2lnbmVkUmlnaHRTaGlmdCh5LEEpKSksbmIkaW52ZXJ0OmQoeT0+TWF0aC5hYnMoeSk8TWF0aC5wb3coMiwzMSk/fnk6dm9pZCAwLHk9PkpTQkkubnVtYmVySWZTYWZlKEpTQkkuYml0d2lzZU5vdCh5KSkpLG5iJHBvd2VyKHksQSl7bGV0IEo7dm9pZCAwIT09QSYmU2suYnVpbHRpbi5jaGVja05vbmUoQSkmJihBPXZvaWQgMCk7aWYoISh5IGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfJiZcbih2b2lkIDA9PT1BfHxBIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKSkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IFE9eS5uYiRpc25lZ2F0aXZlKCk7aWYoUSYmdm9pZCAwPT09QSlyZXR1cm4gdGhpcy5uYiRmbG9hdCgpLm5iJHBvd2VyKHkubmIkZmxvYXQoKSk7bGV0IFg9dGhpcy52O3k9eS52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgWCYmXCJudW1iZXJcIj09PXR5cGVvZiB5KXtjb25zdCBhYT1NYXRoLnBvdyhYLHkpO2lmKG4oYWEpJiYoSj1uZXcgU2suYnVpbHRpbi5pbnRfKGFhKSx2b2lkIDA9PT1BKSlyZXR1cm4gSn1pZih2b2lkIDAhPT1BKXtpZihRKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJwb3coKSAybmQgYXJndW1lbnQgY2Fubm90IGJlIG5lZ2F0aXZlIHdoZW4gM3JkIGFyZ3VtZW50IHNwZWNpZmllZFwiKTtpZigwPT09QS52KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJwb3coKSAzcmQgYXJndW1lbnQgY2Fubm90IGJlIDBcIik7XG5yZXR1cm4gdm9pZCAwIT09Sj9KLm5iJHJlbWFpbmRlcihBKTpuZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkubnVtYmVySWZTYWZlKEpTQkkucG93ZXJtb2QoayhYKSxrKHkpLGsoQS52KSkpKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLmV4cG9uZW50aWF0ZShrKFgpLGsoeSkpKX0sbmIkbG9uZygpe3JldHVybiBuZXcgU2suYnVpbHRpbi5sbmcodGhpcy52KX19LGdldHNldHM6e3JlYWw6eyRnZXQ6ZiwkZG9jOlwidGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9LGltYWc6eyRnZXQoKXtyZXR1cm4gRX0sJGRvYzpcInRoZSBpbWFnaW5hcnkgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9LG51bWVyYXRvcjp7JGdldDpmfSxkZW5vbWluYXRvcjp7JGdldCgpe3JldHVybiBIfX19LGNsYXNzbWV0aG9kczp7ZnJvbV9ieXRlczp7JG1ldGgoeSxBKXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJmcm9tX2J5dGVzXCIseSwwLDIpO2xldCBbSixRLFhdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiZnJvbV9ieXRlc1wiLFxuW1wiYnl0ZXNcIixcImJ5dGVvcmRlclwiLFwic2lnbmVkXCJdLHksQSxbU2suYnVpbHRpbi5ib29sLmZhbHNlJF0pO3k9bChRKTtKIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ieXRlc3x8KEo9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KFNrLmJ1aWx0aW4uYnl0ZXMsW0pdKSk7aWYoU2subWlzY2V2YWwuaXNUcnVlKFgpKXRocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJmcm9tX2J5dGVzIHdpdGggc2lnbmVkPVRydWUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcIik7Y29uc3QgYWE9W107Si52YWx1ZU9mKCkuZm9yRWFjaChlYT0+e2FhLnB1c2goZWEudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsXCIwXCIpKX0pO3kmJmFhLnJldmVyc2UoKTt5PW5ldyBTay5idWlsdGluLmludF8oSlNCSS5udW1iZXJJZlNhZmUoSlNCSS5CaWdJbnQoXCIweFwiKyhhYS5qb2luKFwiXCIpfHxcIjBcIikpKSk7cmV0dXJuIHRoaXM9PT1Tay5idWlsdGluLmludF8/eTpTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcyxcblt5XSl9LCRmbGFnczp7RmFzdENhbGw6ITB9fX0sbWV0aG9kczp7Y29uanVnYXRlOnskbWV0aDpmLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm5zIHNlbGYsIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBhbnkgaW50LlwifSxiaXRfbGVuZ3RoOnskbWV0aCgpe2xldCB5PXRoaXMudjtpZigwPT09eSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygwKTt5PVwibnVtYmVyXCI9PT10eXBlb2YgeT9NYXRoLmFicyh5KTphKHkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHkudG9TdHJpbmcoMikubGVuZ3RoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJOdW1iZXIgb2YgYml0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHNlbGYgaW4gYmluYXJ5Llxcblxcbj4+PiBiaW4oMzcpXFxuJzBiMTAwMTAxJ1xcbj4+PiAoMzcpLmJpdF9sZW5ndGgoKVxcbjZcIn0sdG9fYnl0ZXM6eyRtZXRoKHksQSl7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwidG9fYnl0ZXNcIixcbnksMCwyKTtsZXQgW0osUSxYXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcInRvX2J5dGVzXCIsW1wibGVuZ3RoXCIsXCJieXRlb3JkZXJcIixcInNpZ25lZFwiXSx5LEEsW1NrLmJ1aWx0aW4uYm9vbC5mYWxzZSRdKTt5PWwoUSk7Sj1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoSixTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2lmKDA+Sil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibGVuZ3RoIGFyZ3VtZW50IG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO2lmKFNrLm1pc2NldmFsLmlzVHJ1ZShYKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwidG9fYnl0ZXMgd2l0aCBzaWduZWQ9VHJ1ZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFwiKTtpZih0aGlzLm5iJGlzbmVnYXRpdmUoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiY2FuJ3QgY29udmVydCBuZWdhdGl2ZSBpbnQgdG8gdW5zaWduZWRcIik7QT1KU0JJLkJpZ0ludCh0aGlzLnYpLnRvU3RyaW5nKDE2KTtcbkEubGVuZ3RoJTImJihBPVwiMFwiK0EpO3ZhciBhYT1BLmxlbmd0aC8yO2lmKGFhPkope2lmKDA9PT1KJiZcIjAwXCI9PT1BKXJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlczt0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50IHRvbyBiaWcgdG8gY29udmVydFwiKTt9Y29uc3QgZWE9QXJyYXkoSikuZmlsbCgwKTthYT1KLWFhO2xldCBuYT0wO2Zvcig7YWE8SjspZWFbYWFdPXBhcnNlSW50KEEuc2xpY2UobmEsbmErMiksMTYpLGFhKz0xLG5hKz0yO3kmJmVhLnJldmVyc2UoKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoZWEpfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgbGVuZ3RoLCBieXRlb3JkZXIsICosIHNpZ25lZD1GYWxzZSlcIiwkZG9jOlwiUmV0dXJuIGFuIGFycmF5IG9mIGJ5dGVzIHJlcHJlc2VudGluZyBhbiBpbnRlZ2VyLlxcblxcbiAgbGVuZ3RoXFxuICAgIExlbmd0aCBvZiBieXRlcyBvYmplY3QgdG8gdXNlLiAgQW4gT3ZlcmZsb3dFcnJvciBpcyByYWlzZWQgaWYgdGhlXFxuICAgIGludGVnZXIgaXMgbm90IHJlcHJlc2VudGFibGUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJ5dGVzLlxcbiAgYnl0ZW9yZGVyXFxuICAgIFRoZSBieXRlIG9yZGVyIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyLiAgSWYgYnl0ZW9yZGVyIGlzICdiaWcnLFxcbiAgICB0aGUgbW9zdCBzaWduaWZpY2FudCBieXRlIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJ5dGUgYXJyYXkuICBJZlxcbiAgICBieXRlb3JkZXIgaXMgJ2xpdHRsZScsIHRoZSBtb3N0IHNpZ25pZmljYW50IGJ5dGUgaXMgYXQgdGhlIGVuZCBvZiB0aGVcXG4gICAgYnl0ZSBhcnJheS4gIFRvIHJlcXVlc3QgdGhlIG5hdGl2ZSBieXRlIG9yZGVyIG9mIHRoZSBob3N0IHN5c3RlbSwgdXNlXFxuICAgIGBzeXMuYnl0ZW9yZGVyJyBhcyB0aGUgYnl0ZSBvcmRlciB2YWx1ZS5cXG4gIHNpZ25lZFxcbiAgICBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvJ3MgY29tcGxlbWVudCBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlci5cXG4gICAgSWYgc2lnbmVkIGlzIEZhbHNlIGFuZCBhIG5lZ2F0aXZlIGludGVnZXIgaXMgZ2l2ZW4sIGFuIE92ZXJmbG93RXJyb3JcXG4gICAgaXMgcmFpc2VkLlwifSxcbl9fdHJ1bmNfXzp7JG1ldGg6ZiwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiVHJ1bmNhdGluZyBhbiBJbnRlZ3JhbCByZXR1cm5zIGl0c2VsZi5cIn0sX19mbG9vcl9fOnskbWV0aDpmLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJGbG9vcmluZyBhbiBJbnRlZ3JhbCByZXR1cm5zIGl0c2VsZi5cIn0sX19jZWlsX186eyRtZXRoOmYsJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkNlaWxpbmcgb2YgYW4gSW50ZWdyYWwgcmV0dXJucyBpdHNlbGYuXCJ9LF9fcm91bmRfXzp7JG1ldGgoeSl7cmV0dXJuIHRoaXMucm91bmQkKHkpfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJvdW5kaW5nIGFuIEludGVncmFsIHJldHVybnMgaXRzZWxmLlxcblJvdW5kaW5nIHdpdGggYW4gbmRpZ2l0cyBhcmd1bWVudCBhbHNvIHJldHVybnMgYW4gaW50ZWdlci5cIn0sX19nZXRuZXdhcmdzX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMudildKX0sXG4kZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpTay5idWlsdGluLm5vbmUubm9uZSR9LF9fZm9ybWF0X186eyRtZXRoOlNrLmZvcm1hdHRpbmcubWtOdW1iZXJfX2Zvcm1hdF9fKCExKSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGZvcm1hdF9zcGVjLCAvKVwiLCRkb2M6U2suYnVpbHRpbi5ub25lLm5vbmUkfX0scHJvdG86e3N0ciQoeSxBKXt5PXZvaWQgMD09PXl8fDEwPT09eT90aGlzLnYudG9TdHJpbmcoKTp0aGlzLnYudG9TdHJpbmcoeSk7QXx8dm9pZCAwPT09QXx8XCItXCI9PT15WzBdJiYoeT15LnN1YnN0cmluZygxKSk7cmV0dXJuIHl9LHJvdW5kJCh5KXt5PXZvaWQgMD09PXk/MDpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoeSk7dmFyIEE9dGhpcy52O2lmKDA8PXkpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oQSk7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBBKXt7dmFyIEo9eTsoeT1KU0JJLmxlc3NUaGFuKEEsSlNCSS5fX1pFUk8pKSYmXG4oQT1KU0JJLnVuYXJ5TWludXMoQSkpO0o9SlNCSS5leHBvbmVudGlhdGUoSlNCSS5CaWdJbnQoMTApLEpTQkkudW5hcnlNaW51cyhKU0JJLkJpZ0ludChKKSkpO2xldCBRPUpTQkkuZGl2aWRlKEEsSik7QT1KU0JJLnJlbWFpbmRlcihBLEopO0E9SlNCSS5tdWx0aXBseShBLHQpO0pTQkkuZ3JlYXRlclRoYW4oQSxKKT9RPUpTQkkuYWRkKFEseCk6SlNCSS5lcXVhbChBLEopJiYoU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nP0pTQkkuZXF1YWwoSlNCSS5yZW1haW5kZXIoUSx0KSx4KSYmKFE9SlNCSS5hZGQoUSx4KSk6UT1KU0JJLmFkZChRLHgpKTtRPUpTQkkubXVsdGlwbHkoUSxKKTt5JiYoUT1KU0JJLnVuYXJ5TWludXMoUSkpO3k9bmV3IFNrLmJ1aWx0aW4uaW50XyhRKX1yZXR1cm4geX15PU1hdGgucG93KDEwLC15KTtpZih5LzEwPk1hdGguYWJzKEEpKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKDApO2lmKCFTay5fX2Z1dHVyZV9fLmJhbmtlcnNfcm91bmRpbmcpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oTWF0aC5yb3VuZChBL1xueSkqeSk7QS89eTtKPU1hdGgucm91bmQoQSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oKC41PT09KDA8QT9BOi1BKSUxPzA9PT1KJTI/SjpKLTE6SikqeSl9LHZhbHVlT2YoKXtyZXR1cm4gdGhpcy52fSxzayRpbnQ6ITB9fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5pbnRfXCIsU2suYnVpbHRpbi5pbnRfKTtjb25zdCBxPUpTQkkuQmlnSW50KFwiNTM2ODcwOTExXCIpLHo9TWF0aC5sb2cyKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtGPUpTQkkuQmlnSW50KE1hdGguZmxvb3IoTWF0aC5sb2cyKE51bWJlci5NQVhfVkFMVUUpKSk7Y29uc3Qgcj1NYXRoLmNlaWwoTWF0aC5sb2cyKE51bWJlci5NSU5fVkFMVUUpKSx0PUpTQkkuQmlnSW50KDIpLHg9SlNCSS5CaWdJbnQoMSksdj1KU0JJLnN1YnRyYWN0KEpTQkkuZXhwb25lbnRpYXRlKHQsRiksSlNCSS5leHBvbmVudGlhdGUodCxKU0JJLnN1YnRyYWN0KEYsSlNCSS5hZGQoSlNCSS5CaWdJbnQoeikseCkpKSksQj0vXyg/PVteX10pL2c7XG5Tay5zdHIybnVtYmVyPWZ1bmN0aW9uKHksQSl7dmFyIEo9eSxRPSExLFg7eT15LnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIik7XCItXCI9PT15LmNoYXJBdCgwKSYmKFE9ITAseT15LnN1YnN0cmluZygxKSk7XCIrXCI9PT15LmNoYXJBdCgwKSYmKHk9eS5zdWJzdHJpbmcoMSkpO2lmKG51bGw9PT1BfHx2b2lkIDA9PT1BKUE9MTA7aWYoKDI+QXx8MzY8QSkmJjAhPT1BKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnQoKSBiYXNlIG11c3QgYmUgPj0gMiBhbmQgPD0gMzZcIik7XCJzdHJpbmdcIj09PXR5cGVvZiBBJiYoQT1OdW1iZXIoQSkpO2lmKFwiMHhcIj09PXkuc3Vic3RyaW5nKDAsMikudG9Mb3dlckNhc2UoKSlpZigxNj09PUF8fDA9PT1BKXk9eS5zdWJzdHJpbmcoMiksQT0xNjtlbHNle2lmKDM0PkEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImludmFsaWQgbGl0ZXJhbCBmb3IgaW50KCkgd2l0aCBiYXNlIFwiK0ErXCI6ICdcIitKK1wiJ1wiKTt9ZWxzZSBpZihcIjBiXCI9PT1cbnkuc3Vic3RyaW5nKDAsMikudG9Mb3dlckNhc2UoKSlpZigyPT09QXx8MD09PUEpeT15LnN1YnN0cmluZygyKSxBPTI7ZWxzZXtpZigxMj5BKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitBK1wiOiAnXCIrSitcIidcIik7fWVsc2UgaWYoXCIwb1wiPT09eS5zdWJzdHJpbmcoMCwyKS50b0xvd2VyQ2FzZSgpKWlmKDg9PT1BfHwwPT09QSl5PXkuc3Vic3RyaW5nKDIpLEE9ODtlbHNle2lmKDI1PkEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImludmFsaWQgbGl0ZXJhbCBmb3IgaW50KCkgd2l0aCBiYXNlIFwiK0ErXCI6ICdcIitKK1wiJ1wiKTt9ZWxzZSBpZihcIjBcIj09PXkuY2hhckF0KDApKXtpZihcIjBcIj09PXkpcmV0dXJuIDA7aWYoOD09PUF8fDA9PT1BKUE9OH0wPT09QSYmKEE9MTApO2lmKC0xIT09eS5pbmRleE9mKFwiX1wiKSl7aWYoLTEhPT15LmluZGV4T2YoXCJfX1wiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiaW52YWxpZCBsaXRlcmFsIGZvciBpbnQoKSB3aXRoIGJhc2UgXCIrXG5BK1wiOiAnXCIrSitcIidcIik7eT0xMCE9PUE/eS5yZXBsYWNlKEIsXCJcIik6eS5jaGFyQXQoMCkreS5zdWJzdHJpbmcoMSkucmVwbGFjZShCLFwiXCIpfWlmKDA9PT15Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiaW52YWxpZCBsaXRlcmFsIGZvciBpbnQoKSB3aXRoIGJhc2UgXCIrQStcIjogJ1wiK0orXCInXCIpO2ZvcihYPTA7WDx5Lmxlbmd0aDtYKz0xKXt2YXIgYWE9eS5jaGFyQ29kZUF0KFgpO3ZhciBlYT1BOzQ4PD1hYSYmNTc+PWFhP2VhPWFhLTQ4OjY1PD1hYSYmOTA+PWFhP2VhPWFhLTY1KzEwOjk3PD1hYSYmMTIyPj1hYSYmKGVhPWFhLTk3KzEwKTtpZihlYT49QSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiaW52YWxpZCBsaXRlcmFsIGZvciBpbnQoKSB3aXRoIGJhc2UgXCIrQStcIjogJ1wiK0orXCInXCIpO31RJiYoeT1cIi1cIit5KTtlYT1wYXJzZUludCh5LEEpO2lmKG4oZWEpKXJldHVybiBlYTtKPSExO1wiLVwiPT09eVswXSYmKEo9ITAseT15LnN1YnN0cmluZygxKSk7XG5BPUpTQkkuQmlnSW50KEEpO1E9eDtYPUpTQkkuX19aRVJPO2ZvcihhYT15Lmxlbmd0aC0xOzA8PWFhO2FhLS0pZWE9eS5jaGFyQ29kZUF0KGFhKSw0ODw9ZWEmJjU3Pj1lYT9lYS09NDg6NjU8PWVhJiY5MD49ZWE/ZWE9ZWEtNjUrMTA6OTc8PWVhJiYxMjI+PWVhJiYoZWE9ZWEtOTcrMTApLGVhPUpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoZWEpLFEpLFg9SlNCSS5hZGQoWCxlYSksUT1KU0JJLm11bHRpcGx5KFEsQSk7SiYmKFg9SlNCSS5tdWx0aXBseShYLEpTQkkuQmlnSW50KC0xKSkpO3JldHVybiB5PVh9O1NrLmJ1aWx0aW4uaW50Xy5weTIkbWV0aG9kcz17fTtTay5sb25nRnJvbVN0cj1mdW5jdGlvbih5LEEpe2lmKFNrLl9fZnV0dXJlX18ucHl0aG9uMylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhtKHkpKTt5PVNrLnN0cjJudW1iZXIoeSxBKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubG5nKHkpfTtTay5leHBvcnRTeW1ib2woXCJTay5sb25nRnJvbVN0clwiLFNrLmxvbmdGcm9tU3RyKTtcblNrLmJ1aWx0aW4uaW50Xy53aXRoaW5UaHJlc2hvbGQ9bjtTay5idWlsdGluLmludF8uc3RyaW5nVG9OdW1iZXJPckJpZz1tO2NvbnN0IEk9Wy41LDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI1Niw1MTIsMTAyNCwyMDQ4LDQwOTYsODE5MiwxNjM4NCwzMjc2OCw2NTUzNiwxMzEwNzIsMjYyMTQ0LDUyNDI4OCwxMDQ4NTc2LDIwOTcxNTIsNDE5NDMwNCw4Mzg4NjA4LDE2Nzc3MjE2LDMzNTU0NDMyLDY3MTA4ODY0LDEzNDIxNzcyOCwyNjg0MzU0NTYsNTM2ODcwOTEyLDEwNzM3NDE4MjQsMjE0NzQ4MzY0OCw0Mjk0OTY3Mjk2LDg1ODk5MzQ1OTIsMTcxNzk4NjkxODQsMzQzNTk3MzgzNjgsNjg3MTk0NzY3MzYsMTM3NDM4OTUzNDcyLDI3NDg3NzkwNjk0NCw1NDk3NTU4MTM4ODgsMTA5OTUxMTYyNzc3NiwyMTk5MDIzMjU1NTUyLDQzOTgwNDY1MTExMDQsODc5NjA5MzAyMjIwOCwxNzU5MjE4NjA0NDQxNiwzNTE4NDM3MjA4ODgzMiw3MDM2ODc0NDE3NzY2NCwweDgwMDAwMDAwMDAwMCwyODE0NzQ5NzY3MTA2NTYsXG41NjI5NDk5NTM0MjEzMTIsMHg0MDAwMDAwMDAwMDAwLDB4ODAwMDAwMDAwMDAwMCw0NTAzNTk5NjI3MzcwNDk2LDkwMDcxOTkyNTQ3NDA5OTJdO1NrLmJ1aWx0aW4ubG5nPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJsb25nXCIse2Jhc2U6U2suYnVpbHRpbi5pbnRfLGNvbnN0cnVjdG9yOmZ1bmN0aW9uKHkpe3k9U2suYnVpbHRpbi5pbnRfLmNhbGwodGhpcyx5KTt2b2lkIDAhPT15JiYodGhpcy52PXkudil9LHNsb3RzOnskcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvU3RyaW5nKCkrXCJMXCIpfSx0cCRhc19udW1iZXI6ITAsbmIkbmVnYXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubG5nKE0ubmIkbmVnYXRpdmUuY2FsbCh0aGlzKS52KX0sbmIkcG9zaXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubG5nKE0ubmIkcG9zaXRpdmUuY2FsbCh0aGlzKS52KX19fSk7Y29uc3QgTT1Tay5idWlsdGluLmludF8ucHJvdG90eXBlLFM9W107Zm9yKEY9LTU7MjU3PlxuRjtGKyspU1tGXT1PYmplY3QuY3JlYXRlKFNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGUse3Y6e3ZhbHVlOkZ9fSk7Y29uc3QgRT1TWzBdLEg9U1sxXX0sZnVuY3Rpb24oRixQKXtjb25zdCBiPVNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGU7U2suYnVpbHRpbi5ib29sPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJib29sXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGUpe3JldHVybiBTay5taXNjZXZhbC5pc1RydWUoZSk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9LGJhc2U6U2suYnVpbHRpbi5pbnRfLHNsb3RzOnt0cCRkb2M6XCJib29sKHgpIC0+IGJvb2xcXG5cXG5SZXR1cm5zIFRydWUgd2hlbiB0aGUgYXJndW1lbnQgeCBpcyB0cnVlLCBGYWxzZSBvdGhlcndpc2UuXFxuVGhlIGJ1aWx0aW5zIFRydWUgYW5kIEZhbHNlIGFyZSB0aGUgb25seSB0d28gaW5zdGFuY2VzIG9mIHRoZSBjbGFzcyBib29sLlxcblRoZSBjbGFzcyBib29sIGlzIGEgc3ViY2xhc3Mgb2YgdGhlIGNsYXNzIGludCwgYW5kIGNhbm5vdCBiZSBzdWJjbGFzc2VkLlwiLFxudHAkbmV3KGUsZCl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcImJvb2xcIixkKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJib29sXCIsZSwwLDEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKGVbMF0pfSwkcigpe3JldHVybiB0aGlzLnY/dGhpcy5zdHIkVHJ1ZTp0aGlzLnN0ciRGYWxzZX0sdHAkYXNfbnVtYmVyOiEwLG5iJGFuZChlKXtyZXR1cm4gZS5vYiR0eXBlPT09U2suYnVpbHRpbi5ib29sP25ldyBTay5idWlsdGluLmJvb2wodGhpcy52JmUudik6Yi5uYiRhbmQuY2FsbCh0aGlzLGUpfSxuYiRvcihlKXtyZXR1cm4gZS5vYiR0eXBlPT09U2suYnVpbHRpbi5ib29sP25ldyBTay5idWlsdGluLmJvb2wodGhpcy52fGUudik6Yi5uYiRvci5jYWxsKHRoaXMsZSl9LG5iJHhvcihlKXtyZXR1cm4gZS5vYiR0eXBlPT09U2suYnVpbHRpbi5ib29sP25ldyBTay5idWlsdGluLmJvb2wodGhpcy52XmUudik6Yi5uYiR4b3IuY2FsbCh0aGlzLGUpfX0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9LFxubWV0aG9kczp7X19mb3JtYXRfXzp7JG1ldGgoKXtyZXR1cm4gdGhpcy4kcigpfSwkZmxhZ3M6e09uZUFyZzohMH19fSxwcm90bzp7c3RyJEZhbHNlOm5ldyBTay5idWlsdGluLnN0cihcIkZhbHNlXCIpLHN0ciRUcnVlOm5ldyBTay5idWlsdGluLnN0cihcIlRydWVcIiksdmFsdWVPZigpe3JldHVybiEhdGhpcy52fX19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmJvb2xcIixTay5idWlsdGluLmJvb2wpO1NrLmJ1aWx0aW4uYm9vbC50cnVlJD1PYmplY3QuY3JlYXRlKFNrLmJ1aWx0aW4uYm9vbC5wcm90b3R5cGUse3Y6e3ZhbHVlOjEsZW51bWVyYWJsZTohMH19KTtTay5idWlsdGluLmJvb2wuZmFsc2UkPU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5ib29sLnByb3RvdHlwZSx7djp7dmFsdWU6MCxlbnVtZXJhYmxlOiEwfX0pfSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIoayl7Y29uc3QgdT1baywwXTtpZigwPT09aylyZXR1cm4gdTt2YXIgbD1NYXRoLmFicyhrKTtsZXQgcT1NYXRoLm1heCgtMTAyMyxcbk1hdGguZmxvb3IoTWF0aC5sb2cyKGwpKSsxKTtmb3IobCo9TWF0aC5wb3coMiwtcSk7LjU+bDspbCo9MixxLS07Zm9yKDsxPD1sOylsKj0uNSxxKys7MD5rJiYobD0tbCk7dVswXT1sO3VbMV09cTtyZXR1cm4gdX1mdW5jdGlvbiBlKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLnYpfWZ1bmN0aW9uIGQoayl7cmV0dXJuIGZ1bmN0aW9uKHUpe2NvbnN0IGw9dGhpcy52O3U9dS52O2lmKFwibnVtYmVyXCIhPT10eXBlb2YgdSlpZihKU0JJLl9faXNCaWdJbnQodSkpe2lmKHU9cGFyc2VGbG9hdChKU0JJLnRvTnVtYmVyKHUpKSxJbmZpbml0eT09dXx8LUluZmluaXR5PT11KXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3IoXCJpbnQgdG9vIGxhcmdlIHRvIGNvbnZlcnQgdG8gZmxvYXRcIik7fWVsc2UgcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO3JldHVybiBrKGwsdSl9fWZ1bmN0aW9uIGYoayx1KXtyZXR1cm4gZnVuY3Rpb24obCl7Y29uc3QgcT1cbnRoaXMudjtsPWwudjtpZihcIm51bWJlclwiIT09dHlwZW9mIGwpe2lmKCFKU0JJLl9faXNCaWdJbnQobCkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2lmKHZvaWQgMCE9PXUpcmV0dXJuIHUocSxsKX1yZXR1cm4gayhxLGwpfX1mdW5jdGlvbiBoKGspe2NvbnN0IHU9ZChrKTtyZXR1cm4gZnVuY3Rpb24obCxxKXtpZih2b2lkIDAhPT1xJiYhU2suYnVpbHRpbi5jaGVja05vbmUocSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwicG93KCkgM3JkIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhbGwgYXJndW1lbnRzIGFyZSBpbnRlZ2Vyc1wiKTtyZXR1cm4gdS5jYWxsKHRoaXMsbCl9fWZ1bmN0aW9uIHAoayx1KXtpZigwPT09dSl0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImludGVnZXIgZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIik7cmV0dXJuIEluZmluaXR5PT09az9JbmZpbml0eT09PXV8fC1JbmZpbml0eT09PVxuaz9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTmFOKTowPnU/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC1JbmZpbml0eSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKEluZmluaXR5KTotSW5maW5pdHk9PT1rP0luZmluaXR5PT09dXx8LUluZmluaXR5PT09az9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTmFOKTowPnU/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKEluZmluaXR5KTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oLUluZmluaXR5KTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oay91KX1mdW5jdGlvbiBnKGssdSl7aWYoSW5maW5pdHk9PT1rfHwtSW5maW5pdHk9PT1rKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oTmFOKTtpZigwPT09dSl0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImludGVnZXIgZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIik7cmV0dXJuIEluZmluaXR5PT09dT8wPms/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC0xKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oMCk6XG4tSW5maW5pdHk9PT11PzA+a3x8MCE9PWs/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApOm5ldyBTay5idWlsdGluLmZsb2F0XygtMSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguZmxvb3Ioay91KSl9ZnVuY3Rpb24gYShrLHUpe2lmKDA9PT11KXRocm93IG5ldyBTay5idWlsdGluLlplcm9EaXZpc2lvbkVycm9yKFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiKTtpZigwPT09aylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApO2lmKEluZmluaXR5PT09dSlyZXR1cm4gSW5maW5pdHk9PT1rfHwtSW5maW5pdHk9PT1rP25ldyBTay5idWlsdGluLmZsb2F0XyhOYU4pOjA8az9uZXcgU2suYnVpbHRpbi5mbG9hdF8oayk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKEluZmluaXR5KTtsZXQgbD1rJXU7MD5rPzA8dSYmMD5sJiYobCs9dSk6MD51JiYwIT09bCYmKGwrPXUpOzA9PT1sJiYoMD51P2w9LTA6LUluZmluaXR5PT09SW5maW5pdHkvbCYmKGw9MCkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obCl9XG5mdW5jdGlvbiBjKGssdSl7aWYoMD5rJiYwIT09dSUxKXJldHVybihuZXcgU2suYnVpbHRpbi5jb21wbGV4KGssMCkpLm5iJHBvd2VyKG5ldyBTay5idWlsdGluLmNvbXBsZXgodSwwKSk7aWYoMD09PWsmJjA+dSl0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcIjAuMCBjYW5ub3QgYmUgcmFpc2VkIHRvIGEgbmVnYXRpdmUgcG93ZXJcIik7Y29uc3QgbD1NYXRoLnBvdyhrLHUpO2lmKEluZmluaXR5PT09TWF0aC5hYnMobCkmJkluZmluaXR5IT09TWF0aC5hYnMoaykmJkluZmluaXR5IT09TWF0aC5hYnModSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcIk51bWVyaWNhbCByZXN1bHQgb3V0IG9mIHJhbmdlXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obCl9U2suYnVpbHRpbi5mbG9hdF89U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImZsb2F0XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGspe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZlxuU2suYnVpbHRpbi5mbG9hdF8sXCJiYWQgY2FsbCB0byBmbG9hdCB1c2UgJ25ldydcIik7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBrKXRoaXMudj1rO2Vsc2UgaWYodm9pZCAwPT09ayl0aGlzLnY9MDtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2Ygayl0aGlzLnY9cGFyc2VGbG9hdChrKTtlbHNle2lmKGsubmIkZmxvYXQpcmV0dXJuIGsubmIkZmxvYXQoKTtTay5hc3NlcnRzLmZhaWwoXCJiYWQgYXJndW1lbnQgdG8gZmxvYXQgY29uc3RydWN0b3JcIil9fSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfbnVtYmVyOiEwLHRwJGRvYzpcIkNvbnZlcnQgYSBzdHJpbmcgb3IgbnVtYmVyIHRvIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCBpZiBwb3NzaWJsZS5cIix0cCRoYXNoKCl7dmFyIGs9dGhpcy52O2lmKCFOdW1iZXIuaXNGaW5pdGUoaykpcmV0dXJuIE51bWJlci5pc05hTihrKT8wOjA8az8zMTQxNTk6LTMxNDE1OTtsZXQgW3UsbF09YihrKTtrPTE7MD51JiYoaz0tMSxcbnU9LXUpO2xldCBxPTAsejtmb3IoO3U7KXE9cTw8MjgmNTM2ODcwOTExfHE+PjEsdSo9MjY4NDM1NDU2LGwtPTI4LHo9TWF0aC50cnVuYyh1KSx1LT16LHErPXosNTM2ODcwOTExPD1xJiYocS09NTM2ODcwOTExKTtsPTA8PWw/bCUyOToyOC0oLTEtbCklMjk7cT0ocTw8bCY1MzY4NzA5MTF8cT4+MjktbCkqaztyZXR1cm4tMT09PXE/LTI6cX0sJHIoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuc3RyJCgxMCwhMCkpfSx0cCRuZXcoayx1KXtpZih1JiZ1Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJmbG9hdCgpIHRha2VzIG5vIGtleXdvcmQgYXJndW1lbnRzXCIpO2lmKGsmJjE8ay5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZmxvYXQgZXhwZWN0ZWQgYXQgbW9zdCAxIGFyZ3VtZW50cywgZ290IFwiK2subGVuZ3RoKTtrPWtbMF07aWYodm9pZCAwPT09ayl2YXIgbD1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMCk7ZWxzZSBpZih2b2lkIDAhPT1cbmsubmIkZmxvYXQpbD1rLm5iJGZsb2F0KCk7ZWxzZSBpZih2b2lkIDAhPT1rLm5iJGluZGV4KWw9KG5ldyBTay5idWlsdGluLmludF8oay5uYiRpbmRleCgpKSkubmIkZmxvYXQoKTtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoaykpe2w9ay52O2s9bDtpZigtMSE9PWwuaW5kZXhPZihcIl9cIikpe2lmKG4udGVzdChsKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY291bGQgbm90IGNvbnZlcnQgc3RyaW5nIHRvIGZsb2F0OiAnXCIrbCtcIidcIik7az1sLmNoYXJBdCgwKStsLnN1YnN0cmluZygxKS5yZXBsYWNlKG0sXCJcIil9aWYobC5tYXRjaCgvXi1pbmYkL2kpKXZhciBxPS1JbmZpbml0eTtlbHNlIGwubWF0Y2goL15bK10/aW5mJC9pKT9xPUluZmluaXR5OmwubWF0Y2goL15bLStdP25hbiQvaSk/cT1OYU46aXNOYU4oayl8fChxPXBhcnNlRmxvYXQoayksTnVtYmVyLmlzTmFOKHEpJiYocT12b2lkIDApKTtpZih2b2lkIDA9PT1xKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb3VsZCBub3QgY29udmVydCBzdHJpbmcgdG8gZmxvYXQ6IFwiK1xuU2subWlzY2V2YWwub2JqZWN0UmVwcihuZXcgU2suYnVpbHRpbi5zdHIobCkpKTtsPW5ldyBTay5idWlsdGluLmZsb2F0XyhxKX1pZih2b2lkIDA9PT1sKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImZsb2F0KCkgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhIG51bWJlclwiKTtpZih0aGlzPT09U2suYnVpbHRpbi5mbG9hdF8ucHJvdG90eXBlKXJldHVybiBsO3E9bmV3IHRoaXMuY29uc3RydWN0b3I7cS52PWwudjtyZXR1cm4gcX0sbmIkaW50KCl7bGV0IGs9dGhpcy52O2lmKCFOdW1iZXIuaXNGaW5pdGUoaykpe2lmKEluZmluaXR5PT09a3x8LUluZmluaXR5PT09ayl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiY2Fubm90IGNvbnZlcnQgZmxvYXQgaW5maW5pdHkgdG8gaW50ZWdlclwiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY2Fubm90IGNvbnZlcnQgZmxvYXQgTmFOIHRvIGludGVnZXJcIik7fWs9MD5rP01hdGguY2VpbChrKTpcbk1hdGguZmxvb3Ioayk7cmV0dXJuIFNrLmJ1aWx0aW4uaW50Xy53aXRoaW5UaHJlc2hvbGQoayk/bmV3IFNrLmJ1aWx0aW4uaW50XyhrKTpuZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkuQmlnSW50KGspKX0sbmIkZmxvYXQ6ZSxuYiRsb25nKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxuZyh0aGlzLm5iJGludCgpLnYpfSxuYiRhZGQ6ZCgoayx1KT0+bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGsrdSkpLG5iJHN1YnRyYWN0OmQoKGssdSk9Pm5ldyBTay5idWlsdGluLmZsb2F0XyhrLXUpKSxuYiRyZWZsZWN0ZWRfc3VidHJhY3Q6ZCgoayx1KT0+bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHUtaykpLG5iJG11bHRpcGx5OmQoKGssdSk9Pm5ldyBTay5idWlsdGluLmZsb2F0XyhrKnUpKSxuYiRkaXZpZGU6ZChwKSxuYiRyZWZsZWN0ZWRfZGl2aWRlOmQoKGssdSk9PnAodSxrKSksbmIkZmxvb3JfZGl2aWRlOmQoZyksbmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZTpkKChrLHUpPT5nKHUsaykpLG5iJHJlbWFpbmRlcjpkKGEpLFxubmIkcmVmbGVjdGVkX3JlbWFpbmRlcjpkKChrLHUpPT5hKHUsaykpLG5iJGRpdm1vZDpkKChrLHUpPT5uZXcgU2suYnVpbHRpbi50dXBsZShbZyhrLHUpLGEoayx1KV0pKSxuYiRyZWZsZWN0ZWRfZGl2bW9kOmQoKGssdSk9Pm5ldyBTay5idWlsdGluLnR1cGxlKFtnKHUsayksYSh1LGspXSkpLG5iJHBvd2VyOmgoYyksbmIkcmVmbGVjdGVkX3Bvd2VyOmgoKGssdSk9PmModSxrKSksbmIkYWJzKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhNYXRoLmFicyh0aGlzLnYpKX0sbmIkbmVnYXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC10aGlzLnYpfSxuYiRwb3NpdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy52KX0sbmIkYm9vbCgpe3JldHVybiAwIT09dGhpcy52fSxuYiRpc25lZ2F0aXZlKCl7cmV0dXJuIDA+dGhpcy52fSxuYiRpc3Bvc2l0aXZlKCl7cmV0dXJuIDA8PXRoaXMudn0sb2IkZXE6Zigoayx1KT0+az09dSxKU0JJLkVRKSxcbm9iJG5lOmYoKGssdSk9PmshPXUsSlNCSS5ORSksb2IkZ3Q6Zigoayx1KT0+az51LEpTQkkuR1QpLG9iJGdlOmYoKGssdSk9Pms+PXUsSlNCSS5HRSksb2IkbHQ6Zigoayx1KT0+azx1LEpTQkkuTFQpLG9iJGxlOmYoKGssdSk9Pms8PXUsSlNCSS5MRSl9LGdldHNldHM6e3JlYWw6eyRnZXQ6ZSwkZG9jOlwidGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9LGltYWc6eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApfSwkZG9jOlwidGhlIGltYWdpbmFyeSBwYXJ0IG9mIGEgY29tcGxleCBudW1iZXJcIn19LG1ldGhvZHM6e2Nvbmp1Z2F0ZTp7JG1ldGg6ZSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBzZWxmLCB0aGUgY29tcGxleCBjb25qdWdhdGUgb2YgYW55IGZsb2F0LlwifSxfX3RydW5jX186eyRtZXRoKCl7cmV0dXJuIHRoaXMubmIkaW50KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIixcbiRkb2M6XCJSZXR1cm4gdGhlIEludGVncmFsIGNsb3Nlc3QgdG8geCBiZXR3ZWVuIDAgYW5kIHguXCJ9LF9fcm91bmRfXzp7JG1ldGgoayl7cmV0dXJuIHRoaXMucm91bmQkKGspfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuZGlnaXRzPU5vbmUsIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgSW50ZWdyYWwgY2xvc2VzdCB0byB4LCByb3VuZGluZyBoYWxmIHRvd2FyZCBldmVuLlxcblxcbldoZW4gYW4gYXJndW1lbnQgaXMgcGFzc2VkLCB3b3JrIGxpa2UgYnVpbHQtaW4gcm91bmQoeCwgbmRpZ2l0cykuXCJ9LGFzX2ludGVnZXJfcmF0aW86eyRtZXRoKCl7aWYoIU51bWJlci5pc0Zpbml0ZSh0aGlzLnYpKXtpZihOdW1iZXIuaXNOYU4odGhpcy52KSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY2Fubm90IGNvbnZlcnQgTmFOIHRvIGludGVnZXIgcmF0aW9cIik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcImNhbm5vdCBjb252ZXJ0IEluZmluaXR5IHRvIGludGVnZXIgcmF0aW9cIik7XG59bGV0IFtrLHVdPWIodGhpcy52KTtmb3IodmFyIGw9MDszMDA+bCYmayE9TWF0aC5mbG9vcihrKTtsKyspayo9Mix1LS07bD1uZXcgU2suYnVpbHRpbi5pbnRfKE1hdGguYWJzKHUpKTtsZXQgcT1uZXcgU2suYnVpbHRpbi5pbnRfKGspLHo9bmV3IFNrLmJ1aWx0aW4uaW50XygxKTswPHU/cT1xLm5iJGxzaGlmdChsKTp6PXoubmIkbHNoaWZ0KGwpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbcSx6XSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIGludGVnZXIgcmF0aW8uXFxuXFxuUmV0dXJuIGEgcGFpciBvZiBpbnRlZ2Vycywgd2hvc2UgcmF0aW8gaXMgZXhhY3RseSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgZmxvYXRcXG5hbmQgd2l0aCBhIHBvc2l0aXZlIGRlbm9taW5hdG9yLlxcblxcblJhaXNlIE92ZXJmbG93RXJyb3Igb24gaW5maW5pdGllcyBhbmQgYSBWYWx1ZUVycm9yIG9uIE5hTnMuXFxuXFxuPj4+ICgxMC4wKS5hc19pbnRlZ2VyX3JhdGlvKClcXG4oMTAsIDEpXFxuPj4+ICgwLjApLmFzX2ludGVnZXJfcmF0aW8oKVxcbigwLCAxKVxcbj4+PiAoLS4yNSkuYXNfaW50ZWdlcl9yYXRpbygpXFxuKC0xLCA0KVwifSxcbmlzX2ludGVnZXI6eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woTnVtYmVyLmlzSW50ZWdlcih0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgZmxvYXQgaXMgYW4gaW50ZWdlci5cIn0sX19nZXRuZXdhcmdzX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt0aGlzXSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sX19mb3JtYXRfXzp7JG1ldGg6U2suZm9ybWF0dGluZy5ta051bWJlcl9fZm9ybWF0X18oITApLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgZm9ybWF0X3NwZWMsIC8pXCIsJGRvYzpTay5idWlsdGluLm5vbmUubm9uZSR9fSxwcm90bzp7dmFsdWVPZigpe3JldHVybiB0aGlzLnZ9fX0pO2NvbnN0IG49L19bZUVdfFtlRV1ffFxcLl98X1xcLnxbKy1dX3xfXy8sXG5tPS9fKD89W15fXSkvZztTay5idWlsdGluLmZsb2F0Xy5QeUZsb2F0X0NoZWNrPWZ1bmN0aW9uKGspe3JldHVybiB2b2lkIDA9PT1rPyExOlNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoayl8fFNrLmJ1aWx0aW4uY2hlY2tGbG9hdChrKXx8ay5vYiR0eXBlLiRpc1N1YlR5cGUoU2suYnVpbHRpbi5mbG9hdF8pPyEwOiExfTtTay5idWlsdGluLmZsb2F0Xy5wcm90b3R5cGUudG9GaXhlZD1mdW5jdGlvbihrKXtrPVNrLmJ1aWx0aW4uYXNudW0kKGspO3JldHVybiB0aGlzLnYudG9GaXhlZChrKX07U2suYnVpbHRpbi5mbG9hdF8ucHJvdG90eXBlLnJvdW5kJD1mdW5jdGlvbihrKXt2YXIgdT1Tay5idWlsdGluLmFzbnVtJCh0aGlzKTt2YXIgbD12b2lkIDA9PT1rPzA6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGspO2lmKFNrLl9fZnV0dXJlX18uYmFua2Vyc19yb3VuZGluZyl7dSo9TWF0aC5wb3coMTAsbCk7dmFyIHE9TWF0aC5yb3VuZCh1KTtsPSguNT09PSgwPHU/dTotdSklMT8wPT09cSVcbjI/cTpxLTE6cSkvTWF0aC5wb3coMTAsbCk7cmV0dXJuIHZvaWQgMD09PWs/bmV3IFNrLmJ1aWx0aW4uaW50XyhsKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8obCl9az1NYXRoLnBvdygxMCxsKTtsPU1hdGgucm91bmQodSprKS9rO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obCl9O1NrLmJ1aWx0aW4uZmxvYXRfLnByb3RvdHlwZS5zdHIkPWZ1bmN0aW9uKGssdSl7aWYoaXNOYU4odGhpcy52KSlyZXR1cm5cIm5hblwiO3ZvaWQgMD09PXUmJih1PSEwKTtpZihJbmZpbml0eT09dGhpcy52KXJldHVyblwiaW5mXCI7aWYoLUluZmluaXR5PT10aGlzLnYmJnUpcmV0dXJuXCItaW5mXCI7aWYoLUluZmluaXR5PT10aGlzLnYmJiF1KXJldHVyblwiaW5mXCI7dT11P3RoaXMudjpNYXRoLmFicyh0aGlzLnYpO2lmKHZvaWQgMD09PWt8fDEwPT09ayl7dmFyIGw9U2suX19mdXR1cmVfXy5weXRob24zP3UudG9QcmVjaXNpb24oMTYpOnUudG9QcmVjaXNpb24oMTIpO3ZhciBxPWwuaW5kZXhPZihcIi5cIik7az1cbnUudG9TdHJpbmcoKS5zbGljZSgwLHEpO3E9dS50b1N0cmluZygpLnNsaWNlKHEpO2subWF0Y2goL14tPzAkLykmJnEuc2xpY2UoMSkubWF0Y2goL14wezQsfS8pJiYobD0xMj5sLmxlbmd0aD91LnRvRXhwb25lbnRpYWwoKTp1LnRvRXhwb25lbnRpYWwoMTEpKTtpZigwPmwuaW5kZXhPZihcImVcIikmJjA8PWwuaW5kZXhPZihcIi5cIikpe2Zvcig7XCIwXCI9PWwuY2hhckF0KGwubGVuZ3RoLTEpOylsPWwuc3Vic3RyaW5nKDAsbC5sZW5ndGgtMSk7XCIuXCI9PWwuY2hhckF0KGwubGVuZ3RoLTEpJiYobCs9XCIwXCIpfWw9bC5yZXBsYWNlKC9cXC4wK2UvLFwiZVwiLFwiaVwiKTtsPWwucmVwbGFjZSgvKGVbLStdKShbMS05XSkkLyxcIiQxMCQyXCIpO2w9bC5yZXBsYWNlKC8wKyhlLiopLyxcIiQxXCIpfWVsc2UgbD11LnRvU3RyaW5nKGspOzA9PT10aGlzLnYmJi1JbmZpbml0eT09PTEvdGhpcy52JiYobD1cIi1cIitsKTswPmwuaW5kZXhPZihcIi5cIikmJjA+bC5pbmRleE9mKFwiRVwiKSYmMD5sLmluZGV4T2YoXCJlXCIpJiYobCs9XG5cIi4wXCIpO3JldHVybiBsfTtTay5idWlsdGluLmZsb2F0Xy5weTIkbWV0aG9kcz17fX0sZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKGwpe2xldCBxPWwudjtpZihcIm51bWJlclwiPT09dHlwZW9mIHEpcmV0dXJuIHE7bC5uYiRmbG9hdCYmKHE9bC5uYiRmbG9hdCgpKTtpZih2b2lkIDA9PT1xKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImEgZmxvYXQgaXMgcmVxdWlyZWRcIik7cmV0dXJuIHEudn1mdW5jdGlvbiBlKGwscSx6KXtpZih6PT09U2suYnVpbHRpbi5jb21wbGV4LnByb3RvdHlwZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleChsLHEpO3o9bmV3IHouY29uc3RydWN0b3I7U2suYnVpbHRpbi5jb21wbGV4LmNhbGwoeixsLHEpO3JldHVybiB6fWZ1bmN0aW9uIGQobCxxKXtyZXR1cm4gZnVuY3Rpb24oeil7Y29uc3Qgcj10aGlzLnJlYWwsdD10aGlzLmltYWc7dmFyIHg9ei5yZWFsO2NvbnN0IHY9ei52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgeCl6PXouaW1hZztlbHNlIGlmKFwibnVtYmVyXCI9PT1cbnR5cGVvZiB2KXg9dix6PTA7ZWxzZSBpZihKU0JJLl9faXNCaWdJbnQodikpe2lmKHZvaWQgMD09PXEpe2lmKHg9cGFyc2VGbG9hdChKU0JJLnRvTnVtYmVyKHYpKSxJbmZpbml0eT09eHx8LUluZmluaXR5PT14KXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3IoXCJpbnQgdG9vIGxhcmdlIHRvIGNvbnZlcnQgdG8gZmxvYXRcIik7fWVsc2UgeD12LnRvU3RyaW5nKCk7ej0wfWVsc2UgcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO3JldHVybiBsKHIsdCx4LHopfX1mdW5jdGlvbiBmKGwscSx6LHIpe3ZhciB0PU1hdGguYWJzKHopO2NvbnN0IHg9TWF0aC5hYnMocik7aWYodD49eCl7aWYoMD09PXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJjb21wbGV4IGRpdmlzaW9uIGJ5IHplcm9cIik7dD1yL3o7eis9cip0O3I9KGwrcSp0KS96O2w9KHEtbCp0KS96fWVsc2UgeD49dD8odD16L3Isej16KnQrcixTay5hc3NlcnRzLmFzc2VydCgwIT09XG5yKSxyPShsKnQrcSkveixsPShxKnQtbCkveik6bD1yPU5hTjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleChyLGwpfWZ1bmN0aW9uIGgobCxxLHoscil7aWYoMD09PXomJjA9PT1yKXtyPTE7dmFyIHQ9MH1lbHNlIGlmKDA9PT1sJiYwPT09cSl7aWYoMCE9PXJ8fDA+eil0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImNvbXBsZXggZGl2aXNpb24gYnkgemVyb1wiKTt0PXI9MH1lbHNle2NvbnN0IHg9TWF0aC5oeXBvdChsLHEpO3Q9TWF0aC5wb3coeCx6KTtsPU1hdGguYXRhbjIocSxsKTt6Kj1sOzAhPT1yJiYodC89TWF0aC5leHAobCpyKSx6Kz1yKk1hdGgubG9nKHgpKTtyPXQqTWF0aC5jb3Moeik7dCo9TWF0aC5zaW4oeil9cmV0dXJuIG5ldyBTay5idWlsdGluLmNvbXBsZXgocix0KX1mdW5jdGlvbiBwKGwscSx6KXtsZXQgcj0xO3ZhciB0PW5ldyBTay5idWlsdGluLmNvbXBsZXgoMSwwKTtmb3IobD1uZXcgU2suYnVpbHRpbi5jb21wbGV4KGwscSk7MDxcbnImJno+PXI7KXomciYmKHQ9bmV3IFNrLmJ1aWx0aW4uY29tcGxleCh0LnJlYWwqbC5yZWFsLXQuaW1hZypsLmltYWcsdC5yZWFsKmwuaW1hZytsLnJlYWwqdC5pbWFnKSkscjw8PTEsbD1uZXcgU2suYnVpbHRpbi5jb21wbGV4KGwucmVhbCpsLnJlYWwtbC5pbWFnKmwuaW1hZywyKmwucmVhbCpsLmltYWcpO3JldHVybiB0fWZ1bmN0aW9uIGcobCxxLHoscix0KXt0PSExO3N3aXRjaChxKXtjYXNlIFwiZVwiOmNhc2UgXCJmXCI6Y2FzZSBcImdcIjpicmVhaztjYXNlIFwiRVwiOnQ9ITA7cT1cImVcIjticmVhaztjYXNlIFwiRlwiOnQ9ITA7cT1cImZcIjticmVhaztjYXNlIFwiclwiOmlmKDAhPT16KXRocm93IEVycm9yKFwiQmFkIGludGVybmFsbCBjYWxsXCIpO3o9MTc7cT1cImdcIjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiQmFkIGludGVybmFsbCBjYWxsXCIpO31pZihpc05hTihsKSlsPVwibmFuXCI7ZWxzZSBpZihJbmZpbml0eT09PWwpbD1cImluZlwiO2Vsc2UgaWYoLUluZmluaXR5PT09bClsPVwiLWluZlwiO2Vsc2V7ciZcbmcuUHlfRFRTRl9BRERfRE9UXzAmJihxPVwiZ1wiKTt2YXIgeD1cIiVcIisociZnLlB5X0RUU0ZfQUxUP1wiI1wiOlwiXCIpO251bGwhPXomJih4PXgrXCIuXCIreik7eD1uZXcgU2suYnVpbHRpbi5zdHIoeCtxKTtsPXgubmIkcmVtYWluZGVyKG5ldyBTay5idWlsdGluLmZsb2F0XyhsKSk7bD1sLnZ9ciZnLlB5X0RUU0ZfU0lHTiYmXCItXCIhPT1sWzBdJiYobD1cIitcIitsKTt0JiYobD1sLnRvVXBwZXJDYXNlKCkpO3JldHVybiBsfVNrLmJ1aWx0aW4uY29tcGxleD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiY29tcGxleFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihsLHEpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmNvbXBsZXgsXCJiYWQgY2FsbCB0byBjb21wbGV4IGNvbnN0cnVjdG9yLCB1c2UgJ25ldydcIik7dGhpcy5yZWFsPWw7dGhpcy5pbWFnPXF9LHNsb3RzOnt0cCRhc19udW1iZXI6ITAsdHAkZG9jOlwiQ3JlYXRlIGEgY29tcGxleCBudW1iZXIgZnJvbSBhIHJlYWwgcGFydCBhbmQgYW4gb3B0aW9uYWwgaW1hZ2luYXJ5IHBhcnQuXFxuXFxuVGhpcyBpcyBlcXVpdmFsZW50IHRvIChyZWFsICsgaW1hZyoxaikgd2hlcmUgaW1hZyBkZWZhdWx0cyB0byAwLlwiLFxudHAkaGFzaCgpe3ZhciBsPShuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy5yZWFsKSkudHAkaGFzaCgpO2w9MTAwMyoobmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHRoaXMuaW1hZykpLnRwJGhhc2goKStsO3JldHVybiBTay5idWlsdGluLmludF8ud2l0aGluVGhyZXNob2xkKGwpP2w6KG5ldyBTay5idWlsdGluLmludF8oSlNCSS5CaWdJbnQobCkpKS50cCRoYXNoKCl9LHRwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJG5ldyhsLHEpe2w9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJjb21wbGV4XCIsW1wicmVhbFwiLFwiaW1hZ1wiXSxsLHEsW251bGwsbnVsbF0pO3t2YXIgej1sWzFdLHI7bGV0IHg9cT0hMTt2YXIgdD1sWzBdO2lmKG51bGwhPXQmJnQuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmNvbXBsZXgmJm51bGw9PXopcT10O2Vsc2UgaWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyh0KSl7aWYobnVsbCE9eil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wbGV4KCkgY2FuJ3QgdGFrZSBzZWNvbmQgYXJnIGlmIGZpcnN0IGlzIGEgc3RyaW5nXCIpO1xucT1Tay5idWlsdGluLmNvbXBsZXguY29tcGxleF9zdWJ0eXBlX2Zyb21fc3RyaW5nKHQsdGhpcyl9ZWxzZXtpZihudWxsIT16JiZTay5idWlsdGluLmNoZWNrU3RyaW5nKHopKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBsZXgoKSBzZWNvbmQgYXJnIGNhbid0IGJlIGEgc3RyaW5nXCIpO251bGw9PXQ/bD1udWxsOihsPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwodCxTay5idWlsdGluLnN0ci4kY29tcGxleCksbD12b2lkIDAhPT1sP1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShsLFtdKTpudWxsKTtpZihudWxsIT1sJiZsIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpe2lmKCFhKGwpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fY29tcGxleF9fIHNob3VsZCByZXR1cm4gYSBjb21wbGV4IG9iamVjdFwiKTt0PWx9aWYobnVsbCE9dCYmdm9pZCAwPT09dC5uYiRmbG9hdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wbGV4KCkgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhIG51bWJlciwgbm90ICdcIitcblNrLmFic3RyLnR5cGVOYW1lKHQpK1wiJ1wiKTtpZihudWxsIT16JiZ2b2lkIDA9PT16Lm5iJGZsb2F0KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBsZXgoKSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciwgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZSh0KStcIidcIik7bnVsbD09dD90PWw9MDphKHQpPyhsPXQucmVhbCx0PXQuaW1hZyxxPSEwKToobD1iKHQpLHQ9MCk7bnVsbD09ej96PXI9MDphKHopPyhyPXoucmVhbCx6PXouaW1hZyx4PSEwKToocj1iKHopLHo9MCk7ITA9PT14JiYobC09eik7ITA9PT1xJiYocis9dCk7cT1lKGwscix0aGlzKX19cmV0dXJuIHF9LHRwJHJpY2hjb21wYXJlKGwscSl7aWYoXCJFcVwiIT09cSYmXCJOb3RFcVwiIT09cSl7aWYoU2suYnVpbHRpbi5jaGVja051bWJlcihsKXx8YShsKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJubyBvcmRlcmluZyByZWxhdGlvbiBpcyBkZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnNcIik7XG5yZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9cmV0dXJuIGQoZnVuY3Rpb24oeixyLHQseCl7ej16PT10JiZyPT14O3JldHVyblwiRXFcIj09PXE/ejohen0sITApLmNhbGwodGhpcyxsKX0sJHIoKXt7dmFyIGwscTtsZXQgdD1sPVwiXCI7dmFyIHo9dGhpcy5yZWFsO3ZhciByPXRoaXMuaW1hZztpZihxPTA9PT16KXE9MT09KHo/MD56Py0xOjE6MD4xL3o/LTE6MSk7cT8oej1cIlwiLHE9ZyhyLFwiZ1wiLG51bGwsMCxudWxsKSk6KHo9bD1nKHosXCJnXCIsbnVsbCwwLG51bGwpLHE9ZyhyLFwiZ1wiLG51bGwsZy5QeV9EVFNGX1NJR04sbnVsbCksMD09PXImJi1JbmZpbml0eT09PTEvciYmcSYmXCItXCIhPT1xWzBdJiYocT1cIi1cIitxKSxsPVwiKFwiLHQ9XCIpXCIpO3I9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIrbCt6K3ErXCJqXCIrdCl9cmV0dXJuIHJ9LG5iJGludCgpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgY29tcGxleCB0byBpbnRcIik7fSxcbm5iJGxvbmcoKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IGNvbXBsZXggdG8gbG9uZ1wiKTt9LG5iJGZsb2F0KCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBjb21wbGV4IHRvIGZsb2F0XCIpO30sbmIkcG9zaXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleCh0aGlzLnJlYWwsdGhpcy5pbWFnKX0sbmIkbmVnYXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleCgtdGhpcy5yZWFsLC10aGlzLmltYWcpfSxuYiRib29sKCl7cmV0dXJuIHRoaXMucmVhbHx8dGhpcy5pbWFnfSxuYiRhZGQ6ZCgobCxxLHoscik9Pm5ldyBTay5idWlsdGluLmNvbXBsZXgobCt6LHErcikpLG5iJHN1YnRyYWN0OmQoKGwscSx6LHIpPT5uZXcgU2suYnVpbHRpbi5jb21wbGV4KGwteixxLXIpKSxuYiRyZWZsZWN0ZWRfc3VidHJhY3Q6ZCgobCxxLHoscik9Pm5ldyBTay5idWlsdGluLmNvbXBsZXgoei1sLHItXG5xKSksbmIkbXVsdGlwbHk6ZCgobCxxLHoscik9Pm5ldyBTay5idWlsdGluLmNvbXBsZXgoeipsLXIqcSxsKnIrcSp6KSksbmIkZGl2aWRlOmQoZiksbmIkcmVmbGVjdGVkX2RpdmlkZTpkKChsLHEseixyKT0+Zih6LHIsbCxxKSksbmIkZmxvb3JfZGl2aWRlKGwpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IHRha2UgZmxvb3Igb2YgY29tcGxleCBudW1iZXIuXCIpO30sbmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZShsKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCB0YWtlIGZsb29yIG9mIGNvbXBsZXggbnVtYmVyLlwiKTt9LG5iJHJlbWFpbmRlcihsKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtb2QgY29tcGxleCBudW1iZXJzLlwiKTt9LG5iJHJlZmxlY3RlZF9yZW1haW5kZXIobCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgbW9kIGNvbXBsZXggbnVtYmVycy5cIik7fSxuYiRkaXZtb2QobCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgdGFrZSBmbG9vciBvciBtb2Qgb2YgY29tcGxleCBudW1iZXIuXCIpO1xufSxuYiRwb3dlcihsLHEpe2lmKG51bGwhPXEmJiFTay5idWlsdGluLmNoZWNrTm9uZShxKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY29tcGxleCBtb2R1bG9cIik7cmV0dXJuIGsuY2FsbCh0aGlzLGwpfSxuYiRyZWZsZWN0ZWRfcG93ZXIobCxxKXtpZihudWxsIT1xJiYhU2suYnVpbHRpbi5jaGVja05vbmUocSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImNvbXBsZXggbW9kdWxvXCIpO3JldHVybiB1LmNhbGwodGhpcyxsKX0sbmIkYWJzKCl7dmFyIGw9dGhpcy5yZWFsO2NvbnN0IHE9dGhpcy5pbWFnO2lmKCFOdW1iZXIuaXNGaW5pdGUobCl8fCFOdW1iZXIuaXNGaW5pdGUocSkpcmV0dXJuIEluZmluaXR5PT09bHx8LUluZmluaXR5PT09bD9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hYnMobCkpOkluZmluaXR5PT09cXx8LUluZmluaXR5PT09cT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hYnMocSkpOm5ldyBTay5idWlsdGluLmZsb2F0XyhOYU4pO1xubD1NYXRoLmh5cG90KGwscSk7aWYoIU51bWJlci5pc0Zpbml0ZShsKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiYWJzb2x1dGUgdmFsdWUgdG9vIGxhcmdlXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8obCl9fSxnZXRzZXRzOntyZWFsOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLnJlYWwpfSwkZG9jOlwidGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9LGltYWc6eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHRoaXMuaW1hZyl9LCRkb2M6XCJ0aGUgaW1hZ2luYXJ5IHBhcnQgb2YgYSBjb21wbGV4IG51bWJlclwifX0sbWV0aG9kczp7Y29uanVnYXRlOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5jb21wbGV4KHRoaXMucmVhbCwtdGhpcy5pbWFnKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcImNvbXBsZXguY29uanVnYXRlKCkgLT4gY29tcGxleFxcblxcblJldHVybiB0aGUgY29tcGxleCBjb25qdWdhdGUgb2YgaXRzIGFyZ3VtZW50LiAoMy00aikuY29uanVnYXRlKCkgPT0gMys0ai5cIn0sXG5fX2dldG5ld2FyZ3NfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLnJlYWwpLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLmltYWcpXSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6U2suYnVpbHRpbi5ub25lLm5vbmUkfSxfX2Zvcm1hdF9fOnskbWV0aChsKXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGwpKXRocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJfX2Zvcm1hdF9fIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgY29tcGxleCB0eXBlLlwiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2Zvcm1hdF9fIHJlcXVpcmVzIHN0clwiKTt9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJjb21wbGV4Ll9fZm9ybWF0X18oKSAtPiBzdHJcXG5cXG5Db252ZXJ0IHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBmb3JtYXRfc3BlYy5cIn19fSk7XG5Tay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNvbXBsZXhcIixTay5idWlsdGluLmNvbXBsZXgpO2NvbnN0IGE9U2suYnVpbHRpbi5jaGVja0NvbXBsZXgsYz0vX1tlRV18W2VFXV98XFwuX3xfXFwufFsrLV1ffF9qfGpfLyxuPS9fKD89W15fXSkvZztTay5idWlsdGluLmNvbXBsZXguY29tcGxleF9zdWJ0eXBlX2Zyb21fc3RyaW5nPWZ1bmN0aW9uKGwscSl7cT1xfHxTay5idWlsdGluLmNvbXBsZXgucHJvdG90eXBlO3ZhciB6PTAscj0wLHQ9ITE7aWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhsKSlsPVNrLmZmaS5yZW1hcFRvSnMobCk7ZWxzZSBpZihcInN0cmluZ1wiIT09dHlwZW9mIGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3ZpZGVkIHVuc3VwcG9ydGVkIHN0cmluZy1hbGlrZSBhcmd1bWVudFwiKTtpZigtMSE9PWwuaW5kZXhPZihcIlxceDAwXCIpfHwwPT09bC5sZW5ndGh8fFwiXCI9PT1sKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb21wbGV4KCkgYXJnIGlzIGEgbWFsZm9ybWVkIHN0cmluZ1wiKTtcbnZhciB4PTA7bD1sLnJlcGxhY2UoL2luZnxpbmZpbml0eS9naSxcIkluZmluaXR5XCIpO2ZvcihsPWwucmVwbGFjZSgvbmFuL2dpLFwiTmFOXCIpO1wiIFwiPT09bFt4XTspeCsrO2lmKFwiKFwiPT09bFt4XSlmb3IodD0hMCx4Kys7XCIgXCI9PT1sW3hdOyl4Kys7aWYoLTEhPT1sLmluZGV4T2YoXCJfXCIpKXtpZihjLnRlc3QobCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImNvdWxkIG5vdCBjb252ZXJ0IHN0cmluZyB0byBjb21wbGV4OiAnXCIrbCtcIidcIik7bD1sLmNoYXJBdCgwKStsLnN1YnN0cmluZygxKS5yZXBsYWNlKG4sXCJcIil9dmFyIHY9L14oPzpbKy1dPyg/Oig/Oig/OlxcZCpcXC5cXGQrKXwoPzpcXGQrXFwuPykpKD86W2VFXVsrLV0/XFxkKyk/fE5hTnxJbmZpbml0eSkpLzt2YXIgQj1sLnN1YnN0cih4KTt2YXIgST1CLm1hdGNoKHYpO2lmKG51bGwhPT1JKWlmKHgrPUlbMF0ubGVuZ3RoLFwialwiPT09bFt4XXx8XCJKXCI9PT1sW3hdKXI9cGFyc2VGbG9hdChJWzBdKSx4Kys7ZWxzZSBpZihcIitcIj09PVxubFt4XXx8XCItXCI9PT1sW3hdKXt6PXBhcnNlRmxvYXQoSVswXSk7ST1sLnN1YnN0cih4KS5tYXRjaCh2KTtudWxsIT09ST8ocj1wYXJzZUZsb2F0KElbMF0pLHgrPUlbMF0ubGVuZ3RoKToocj1cIitcIj09PWxbeF0/MTotMSx4KyspO2lmKFwialwiIT09bFt4XSYmXCJKXCIhPT1sW3hdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb21wbGV4KCkgYXJnIGlzIG1hbGZvcm1lZCBzdHJpbmdcIik7eCsrfWVsc2Ugej1wYXJzZUZsb2F0KElbMF0pO2Vsc2UgST1JPUIubWF0Y2goL14oWystXT9bakpdKS8pLG51bGwhPT1JJiYocj0xPT09SVswXS5sZW5ndGg/MTpcIitcIj09PUlbMF1bMF0/MTotMSx4Kz1JWzBdLmxlbmd0aCk7Zm9yKDtcIiBcIj09PWxbeF07KXgrKztpZih0KXtpZihcIilcIiE9PWxbeF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImNvbXBsZXgoKSBhcmcgaXMgbWFsZm9ybWVkIHN0cmluZ1wiKTtmb3IoeCsrO1wiIFwiPT09bFt4XTspeCsrfWlmKGwubGVuZ3RoIT09eCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY29tcGxleCgpIGFyZyBpcyBtYWxmb3JtZWQgc3RyaW5nXCIpO1xucmV0dXJuIGUoeixyLHEpfTtjb25zdCBtPShsLHEseixyKT0+e2NvbnN0IHQ9enwwO3JldHVybiAwPT09ciYmej09PXQ/KDEwMDx0fHwtMTAwPnQ/bD1oKGwscSx0LDApOjA8dD9sPXAobCxxLHQpOihsPXAobCxxLC10KSxsPWYoMSwwLGwucmVhbCxsLmltYWcpKSxsKTpoKGwscSx6LHIpfSxrPWQobSksdT1kKChsLHEseixyKT0+bSh6LHIsbCxxKSk7Zy5QeV9EVFNGX1NJR049MTtnLlB5X0RUU0ZfQUREX0RPVF8wPTI7Zy5QeV9EVFNGX0FMVD00O2cuUHlfRFRTVF9GSU5JVEU9MDtnLlB5X0RUU1RfSU5GSU5JVEU9MTtnLlB5X0RUU1RfTkFOPTJ9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5zbGljZT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwic2xpY2VcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYixlLGQpe3ZvaWQgMD09PWUmJnZvaWQgMD09PWQmJihlPWIsYj1Tay5idWlsdGluLm5vbmUubm9uZSQpO3ZvaWQgMD09PWUmJihlPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7dm9pZCAwPT09XG5kJiYoZD1Tay5idWlsdGluLm5vbmUubm9uZSQpO3RoaXMuc3RhcnQ9Yjt0aGlzLnN0b3A9ZTt0aGlzLnN0ZXA9ZH0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGRvYzpcInNsaWNlKHN0b3ApXFxuc2xpY2Uoc3RhcnQsIHN0b3BbLCBzdGVwXSlcXG5cXG5DcmVhdGUgYSBzbGljZSBvYmplY3QuICBUaGlzIGlzIHVzZWQgZm9yIGV4dGVuZGVkIHNsaWNpbmcgKGUuZy4gYVswOjEwOjJdKS5cIix0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRuZXcoYixlKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic2xpY2VcIixlKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJzbGljZVwiLGIsMSwzKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2xpY2UoLi4uYil9LCRyKCl7Y29uc3QgYj1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMuc3RhcnQpLGU9U2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLnN0b3ApLGQ9U2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLnN0ZXApO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJzbGljZShcIitcbmIrXCIsIFwiK2UrXCIsIFwiK2QrXCIpXCIpfSx0cCRyaWNoY29tcGFyZShiLGUpe2lmKGIub2IkdHlwZSE9PVNrLmJ1aWx0aW4uc2xpY2UpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IGQ9bmV3IFNrLmJ1aWx0aW4udHVwbGUoW3RoaXMuc3RhcnQsdGhpcy5zdG9wLHRoaXMuc3RlcF0pO2I9bmV3IFNrLmJ1aWx0aW4udHVwbGUoW2Iuc3RhcnQsYi5zdG9wLGIuc3RlcF0pO3JldHVybiBkLnRwJHJpY2hjb21wYXJlKGIsZSl9fSxnZXRzZXRzOntzdGFydDp7JGdldCgpe3JldHVybiB0aGlzLnN0YXJ0fX0sc3RlcDp7JGdldCgpe3JldHVybiB0aGlzLnN0ZXB9fSxzdG9wOnskZ2V0KCl7cmV0dXJuIHRoaXMuc3RvcH19fSxtZXRob2RzOntpbmRpY2VzOnskbWV0aDpmdW5jdGlvbihiKXtiPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChiLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoMD5iKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImxlbmd0aCBzaG91bGQgbm90IGJlIG5lZ2F0aXZlXCIpO1xuY29uc3Qge3N0YXJ0OmUsc3RvcDpkLHN0ZXA6Zn09dGhpcy5zbGljZSRpbmRpY2VzKGIpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50XyhlKSxuZXcgU2suYnVpbHRpbi5pbnRfKGQpLG5ldyBTay5idWlsdGluLmludF8oZildKX0sJGRvYzpcIlMuaW5kaWNlcyhsZW4pIC0+IChzdGFydCwgc3RvcCwgc3RyaWRlKVxcblxcbkFzc3VtaW5nIGEgc2VxdWVuY2Ugb2YgbGVuZ3RoIGxlbiwgY2FsY3VsYXRlIHRoZSBzdGFydCBhbmQgc3RvcFxcbmluZGljZXMsIGFuZCB0aGUgc3RyaWRlIGxlbmd0aCBvZiB0aGUgZXh0ZW5kZWQgc2xpY2UgZGVzY3JpYmVkIGJ5XFxuUy4gT3V0IG9mIGJvdW5kcyBpbmRpY2VzIGFyZSBjbGlwcGVkIGluIGEgbWFubmVyIGNvbnNpc3RlbnQgd2l0aCB0aGVcXG5oYW5kbGluZyBvZiBub3JtYWwgc2xpY2VzLlwiLCR0ZXh0c2lnOm51bGwsJGZsYWdzOntPbmVBcmc6ITB9fX0scHJvdG86e3NsaWNlJGFzX2luZGljZXMoYil7bGV0IGU7dmFyIGQ9XG5iP2Y9PlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChmLG51bGwsXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgTm9uZSBvciBoYXZlIGFuIF9faW5kZXhfXyBtZXRob2RcIik6Zj0+U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coZixcInNsaWNlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBOb25lIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKTtpZihTay5idWlsdGluLmNoZWNrTm9uZSh0aGlzLnN0ZXApKWU9MTtlbHNlIGlmKGU9ZCh0aGlzLnN0ZXApLDA9PT1lKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzbGljZSBzdGVwIGNhbm5vdCBiZSB6ZXJvXCIpO2I9U2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5zdGFydCk/bnVsbDpkKHRoaXMuc3RhcnQpO2Q9U2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5zdG9wKT9udWxsOmQodGhpcy5zdG9wKTtyZXR1cm57c3RhcnQ6YixzdG9wOmQsc3RlcDplfX0sJHdydChiLGUsZCxmLGgpe2g9aD9wPT5KU0JJLl9faXNCaWdJbnQocCk/XG5KU0JJLmFkZChwLEpTQkkuQmlnSW50KGIpKTpwK2I6cD0+cCtiOzA8Zj8obnVsbD09PWU/ZT0wOjA+ZSYmKGU9aChlKSwwPmUmJihlPTApKSxudWxsPT09ZD9kPWI6ZD5iP2Q9YjowPmQmJihkPWgoZCkpKToobnVsbD09PWU/ZT1iLTE6ZT49Yj9lPWItMTowPmUmJihlPWgoZSkpLG51bGw9PT1kP2Q9LTE6MD5kJiYoZD1oKGQpLDA+ZCYmKGQ9LTEpKSk7cmV0dXJue3N0YXJ0OmUsc3RvcDpkLHN0ZXA6Zn19LHNsaWNlJGluZGljZXMoYixlKXtsZXQge3N0YXJ0OmQsc3RvcDpmLHN0ZXA6aH09dGhpcy5zbGljZSRhc19pbmRpY2VzKCEwLGUpO3JldHVybiB0aGlzLiR3cnQoYixkLGYsaCxlKX0sc3NzaXRlciQoYixlKXtsZXQge3N0YXJ0OmQsc3RvcDpmLHN0ZXA6aH09dGhpcy5zbGljZSRpbmRpY2VzKGIsITApO2lmKDA8aClmb3IoYj1kO2I8ZjtiKz1oKWUoYik7ZWxzZSBmb3IoYj1kO2I+ZjtiKz1oKWUoYil9fSxmbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KTtTay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydD1cbmZ1bmN0aW9uKGIsZSxkKXtiPWIuc3EkbGVuZ3RoKCk7dm9pZCAwPT09ZXx8U2suYnVpbHRpbi5jaGVja05vbmUoZSk/ZT0wOihlPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChlLG51bGwsXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpLDA+ZSYmKGUrPWIsMD5lJiYoZT0wKSkpO3ZvaWQgMD09PWR8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGQpP2Q9YjooZD1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZCxudWxsLFwic2xpY2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKSwwPmQ/KGQrPWIsMD5kJiYoZD0wKSk6ZD5iJiYoZD1iKSk7cmV0dXJue3N0YXJ0OmUsZW5kOmR9fX0sZnVuY3Rpb24oRixQKXtmdW5jdGlvbiBiKGYpe3JldHVybiBmdW5jdGlvbihoKXtyZXR1cm4gU2suYnVpbHRpbi5jaGVja0FueVNldChoKT9mLmNhbGwodGhpcyxoKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19XG5mdW5jdGlvbiBlKGYpe2YgaW5zdGFuY2VvZiBTay5idWlsdGluLnNldCYmZi50cCRoYXNoPT09U2suYnVpbHRpbi5ub25lLm5vbmUkJiYoZj1uZXcgU2suYnVpbHRpbi5mcm96ZW5zZXQoU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZikpKTtyZXR1cm4gZn1GPXt9O1NrLmJ1aWx0aW4uc2V0PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJzZXRcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZil7dm9pZCAwPT09Zj9mPVtdOkFycmF5LmlzQXJyYXkoZil8fChmPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGYpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zZXQsXCJCYWQgY2FsbCB0byBzZXQgLSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIEFycmF5IGFuZCAnbmV3J1wiKTtjb25zdCBoPVtdO2ZvcihsZXQgcD0wO3A8Zi5sZW5ndGg7cCsrKWgucHVzaChmW3BdKSxoLnB1c2goITApO3RoaXMudj1uZXcgU2suYnVpbHRpbi5kaWN0KGgpO3RoaXMuaW4kcmVwcj1cbiExfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfbnVtYmVyOiEwLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkaGFzaDpTay5idWlsdGluLm5vbmUubm9uZSQsdHAkZG9jOlwic2V0KCkgLT4gbmV3IGVtcHR5IHNldCBvYmplY3RcXG5zZXQoaXRlcmFibGUpIC0+IG5ldyBzZXQgb2JqZWN0XFxuXFxuQnVpbGQgYW4gdW5vcmRlcmVkIGNvbGxlY3Rpb24gb2YgdW5pcXVlIGVsZW1lbnRzLlwiLHRwJGluaXQoZixoKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic2V0XCIsaCk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwic2V0XCIsZiwwLDEpO3RoaXMuc2V0JGNsZWFyKCk7cmV0dXJuKGY9ZlswXSkmJnRoaXMuc2V0JHVwZGF0ZShmKX0sdHAkbmV3OlNrLmdlbmVyaWMubmV3LCRyKCl7aWYodGhpcy5pbiRyZXByKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCIoLi4uKVwiKTt0aGlzLmluJHJlcHI9ITA7Y29uc3QgZj10aGlzLnNrJGFzYXJyYXkoKS5tYXAoaD0+XG5Tay5taXNjZXZhbC5vYmplY3RSZXByKGgpKTt0aGlzLmluJHJlcHI9ITE7cmV0dXJuIFNrLl9fZnV0dXJlX18ucHl0aG9uMz8wPT09Zi5sZW5ndGg/bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKClcIik6dGhpcy5vYiR0eXBlIT09U2suYnVpbHRpbi5zZXQ/bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKHtcIitmLmpvaW4oXCIsIFwiKStcIn0pXCIpOm5ldyBTay5idWlsdGluLnN0cihcIntcIitmLmpvaW4oXCIsIFwiKStcIn1cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKFtcIitmLmpvaW4oXCIsIFwiKStcIl0pXCIpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBkKHRoaXMpfSx0cCRyaWNoY29tcGFyZShmLGgpe2lmKCFTay5idWlsdGluLmNoZWNrQW55U2V0KGYpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtzd2l0Y2goaCl7Y2FzZSBcIk5vdEVxXCI6Y2FzZSBcIkVxXCI6cmV0dXJuIGY9XG50aGlzPT09Zj8hMDp0aGlzLmdldCRzaXplKCkhPT1mLmdldCRzaXplKCk/ITE6U2subWlzY2V2YWwuaXNUcnVlKHRoaXMuc2V0JGlzc3Vic2V0KGYpKSxcIkVxXCI9PT1oP2Y6IWY7Y2FzZSBcIkx0RVwiOnJldHVybiB0aGlzPT09Znx8U2subWlzY2V2YWwuaXNUcnVlKHRoaXMuc2V0JGlzc3Vic2V0KGYpKTtjYXNlIFwiR3RFXCI6cmV0dXJuIHRoaXM9PT1mfHxTay5taXNjZXZhbC5pc1RydWUoZi5zZXQkaXNzdWJzZXQodGhpcykpO2Nhc2UgXCJMdFwiOnJldHVybiB0aGlzLmdldCRzaXplKCk8Zi5nZXQkc2l6ZSgpJiZTay5taXNjZXZhbC5pc1RydWUodGhpcy5zZXQkaXNzdWJzZXQoZikpO2Nhc2UgXCJHdFwiOnJldHVybiB0aGlzLmdldCRzaXplKCk+Zi5nZXQkc2l6ZSgpJiZTay5taXNjZXZhbC5pc1RydWUoZi5zZXQkaXNzdWJzZXQodGhpcykpfX0sbmIkc3VidHJhY3Q6YihmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5kaWZmZXJlbmNlLiRtZXRoLmNhbGwodGhpcyxmKX0pLG5iJGFuZDpiKGZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmludGVyc2VjdGlvbi4kbWV0aC5jYWxsKHRoaXMsXG5mKX0pLG5iJG9yOmIoZnVuY3Rpb24oZil7cmV0dXJuIHRoaXMudW5pb24uJG1ldGguY2FsbCh0aGlzLGYpfSksbmIkeG9yOmIoZnVuY3Rpb24oZil7cmV0dXJuIHRoaXMuc3ltbWV0cmljX2RpZmZlcmVuY2UuJG1ldGguY2FsbCh0aGlzLGYpfSksbmIkaW5wbGFjZV9zdWJ0cmFjdDpiKGZ1bmN0aW9uKGYpe2Y9PT10aGlzJiYoZj1mLnNldCRjb3B5KCkpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLmRpZmZlcmVuY2VfdXBkYXRlLiRtZXRoLmNhbGwodGhpcyxmKSwoKT0+dGhpcyl9KSxuYiRpbnBsYWNlX2FuZDpiKGZ1bmN0aW9uKGYpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLmludGVyc2VjdGlvbl91cGRhdGUuJG1ldGguY2FsbCh0aGlzLGYpLCgpPT50aGlzKX0pLG5iJGlucGxhY2Vfb3I6YihmdW5jdGlvbihmKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy51cGRhdGUuJG1ldGguY2FsbCh0aGlzLGYpLCgpPT50aGlzKX0pLG5iJGlucGxhY2VfeG9yOmIoZnVuY3Rpb24oZil7Zj09PVxudGhpcyYmKGY9Zi5zZXQkY29weSgpKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy5zeW1tZXRyaWNfZGlmZmVyZW5jZV91cGRhdGUuJG1ldGguY2FsbCh0aGlzLGYpLCgpPT50aGlzKX0pLHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLmdldCRzaXplKCl9LHNxJGNvbnRhaW5zKGYpe2Y9ZShmKTtyZXR1cm4gdGhpcy52LnNxJGNvbnRhaW5zKGYpfX0sbWV0aG9kczp7YWRkOnskbWV0aChmKXt0aGlzLnNldCRhZGQoZik7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkFkZCBhbiBlbGVtZW50IHRvIGEgc2V0LlxcblxcblRoaXMgaGFzIG5vIGVmZmVjdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHByZXNlbnQuXCJ9LGNsZWFyOnskbWV0aCgpe3RoaXMuc2V0JGNsZWFyKCk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGlzIHNldC5cIn0sXG5jb3B5OnskbWV0aCgpe3JldHVybiB0aGlzLnNldCRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gYSBzaGFsbG93IGNvcHkgb2YgYSBzZXQuXCJ9LGRpc2NhcmQ6eyRtZXRoKGYpe2Y9ZShmKTt0aGlzLnNldCRkaXNjYXJkKGYpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgc2V0IGlmIGl0IGlzIGEgbWVtYmVyLlxcblxcbklmIHRoZSBlbGVtZW50IGlzIG5vdCBhIG1lbWJlciwgZG8gbm90aGluZy5cIn0sZGlmZmVyZW5jZTp7JG1ldGgoLi4uZil7Y29uc3QgaD10aGlzLnNldCRjb3B5KCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheShmLHA9Pmguc2V0JGRpZmZlcmVuY2VfdXBkYXRlKHApKSwoKT0+aCl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gdGhlIGRpZmZlcmVuY2Ugb2YgdHdvIG9yIG1vcmUgc2V0cyBhcyBhIG5ldyBzZXQuXFxuXFxuKGkuZS4gYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGluIHRoaXMgc2V0IGJ1dCBub3QgdGhlIG90aGVycy4pXCJ9LFxuZGlmZmVyZW5jZV91cGRhdGU6eyRtZXRoKC4uLmYpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyQXJyYXkoZixoPT50aGlzLnNldCRkaWZmZXJlbmNlX3VwZGF0ZShoKSksKCk9PlNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZW1vdmUgYWxsIGVsZW1lbnRzIG9mIGFub3RoZXIgc2V0IGZyb20gdGhpcyBzZXQuXCJ9LGludGVyc2VjdGlvbjp7JG1ldGgoLi4uZil7cmV0dXJuIHRoaXMuc2V0JGludGVyc2VjdGlvbl9tdWx0aSguLi5mKX0sJGZsYWdzOntNaW5BcmdzOjB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBzZXRzIGFzIGEgbmV3IHNldC5cXG5cXG4oaS5lLiBhbGwgZWxlbWVudHMgdGhhdCBhcmUgaW4gYm90aCBzZXRzLilcIn0saW50ZXJzZWN0aW9uX3VwZGF0ZTp7JG1ldGgoLi4uZil7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHRoaXMuc2V0JGludGVyc2VjdGlvbl9tdWx0aSguLi5mKSxcbmg9Pnt0aGlzLnN3YXAkYm9kaWVzKGgpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KX0sJGZsYWdzOntNaW5BcmdzOjB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlVwZGF0ZSBhIHNldCB3aXRoIHRoZSBpbnRlcnNlY3Rpb24gb2YgaXRzZWxmIGFuZCBhbm90aGVyLlwifSxpc2Rpc2pvaW50OnskbWV0aChmKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGYpLGg9PntpZih0aGlzLnNxJGNvbnRhaW5zKGgpKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoU2suYnVpbHRpbi5ib29sLmZhbHNlJCl9KSxoPT5ofHxTay5idWlsdGluLmJvb2wudHJ1ZSQpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdHdvIHNldHMgaGF2ZSBhIG51bGwgaW50ZXJzZWN0aW9uLlwifSxpc3N1YnNldDp7JG1ldGgoZil7U2suYnVpbHRpbi5jaGVja0FueVNldChmKXx8KGY9dGhpcy5zZXQkbWFrZV9iYXNldHlwZShmKSk7XG5yZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZixoPT50aGlzLnNldCRpc3N1YnNldChoKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXBvcnQgd2hldGhlciBhbm90aGVyIHNldCBjb250YWlucyB0aGlzIHNldC5cIn0saXNzdXBlcnNldDp7JG1ldGgoZil7U2suYnVpbHRpbi5jaGVja0FueVNldChmKXx8KGY9dGhpcy5zZXQkbWFrZV9iYXNldHlwZShmKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGYsaD0+aC5zZXQkaXNzdWJzZXQodGhpcykpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmVwb3J0IHdoZXRoZXIgdGhpcyBzZXQgY29udGFpbnMgYW5vdGhlciBzZXQuXCJ9LHBvcDp7JG1ldGgoKXtpZigwPT09dGhpcy5nZXQkc2l6ZSgpKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKFwicG9wIGZyb20gYW4gZW1wdHkgc2V0XCIpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy52LnBvcGl0ZW0sW3RoaXMudl0pLnZbMF19LFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlbW92ZSBhbmQgcmV0dXJuIGFuIGFyYml0cmFyeSBzZXQgZWxlbWVudC5cXG5SYWlzZXMgS2V5RXJyb3IgaWYgdGhlIHNldCBpcyBlbXB0eS5cIn0scmVtb3ZlOnskbWV0aChmKXtjb25zdCBoPWUoZik7aWYodGhpcy52Lm1wJGxvb2t1cChoKSlyZXR1cm4gdGhpcy52Lm1wJGFzc19zdWJzY3JpcHQoaCksU2suYnVpbHRpbi5ub25lLm5vbmUkO3Rocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKGYpO30sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlbW92ZSBhbiBlbGVtZW50IGZyb20gYSBzZXQ7IGl0IG11c3QgYmUgYSBtZW1iZXIuXFxuXFxuSWYgdGhlIGVsZW1lbnQgaXMgbm90IGEgbWVtYmVyLCByYWlzZSBhIEtleUVycm9yLlwifSxzeW1tZXRyaWNfZGlmZmVyZW5jZTp7JG1ldGgoZil7bGV0IGg7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHRoaXMuc2V0JG1ha2VfYmFzZXR5cGUoZikscD0+XG57aD1wO3JldHVybiBoLnNldCRzeW1tZXRyaWNfZGlmZl91cGRhdGUodGhpcyl9LCgpPT5oKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiB0aGUgc3ltbWV0cmljIGRpZmZlcmVuY2Ugb2YgdHdvIHNldHMgYXMgYSBuZXcgc2V0LlxcblxcbihpLmUuIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBpbiBleGFjdGx5IG9uZSBvZiB0aGUgc2V0cy4pXCJ9LHN5bW1ldHJpY19kaWZmZXJlbmNlX3VwZGF0ZTp7JG1ldGgoZil7U2suYnVpbHRpbi5jaGVja0FueVNldChmKXx8KGY9dGhpcy5zZXQkbWFrZV9iYXNldHlwZShmKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGYsaD0+dGhpcy5zZXQkc3ltbWV0cmljX2RpZmZfdXBkYXRlKGgpLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiVXBkYXRlIGEgc2V0IHdpdGggdGhlIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIGl0c2VsZiBhbmQgYW5vdGhlci5cIn0sXG51bmlvbjp7JG1ldGgoLi4uZil7Y29uc3QgaD10aGlzLnNldCRjb3B5KCk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheShmLHA9Pmguc2V0JHVwZGF0ZShwKSksKCk9PmgpfSwkZmxhZ3M6e01pbkFyZ3M6MH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIHRoZSB1bmlvbiBvZiBzZXRzIGFzIGEgbmV3IHNldC5cXG5cXG4oaS5lLiBhbGwgZWxlbWVudHMgdGhhdCBhcmUgaW4gZWl0aGVyIHNldC4pXCJ9LHVwZGF0ZTp7JG1ldGgoLi4uZil7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheShmLGg9PnRoaXMuc2V0JHVwZGF0ZShoKSksKCk9PlNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJVcGRhdGUgYSBzZXQgd2l0aCB0aGUgdW5pb24gb2YgaXRzZWxmIGFuZCBvdGhlcnMuXCJ9fSxjbGFzc21ldGhvZHM6U2suZ2VuZXJpYy5jbGFzc0dldEl0ZW0scHJvdG86T2JqZWN0LmFzc2lnbihGLFxue3NrJGFzYXJyYXkoKXtyZXR1cm4gdGhpcy52LnNrJGFzYXJyYXkoKX0sZ2V0JHNpemUoKXtyZXR1cm4gdGhpcy52LnNxJGxlbmd0aCgpfSxzZXQkYWRkKGYpe3RoaXMudi5tcCRhc3Nfc3Vic2NyaXB0KGYsITApfSxzZXQkbWFrZV9iYXNldHlwZShmKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZiwhMCksaD0+bmV3IHRoaXMuc2skYnVpbHRpbkJhc2UoaCkpfSxzZXQkZGlzY2FyZChmKXtyZXR1cm4gdGhpcy52LnBvcCRpdGVtKGYpfSxzZXQkY2xlYXIoKXt0aGlzLnY9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSl9LHNldCRjb3B5KCl7Y29uc3QgZj1uZXcgdGhpcy5zayRidWlsdGluQmFzZTtmLnY9dGhpcy52LmRpY3QkY29weSgpO3JldHVybiBmfSxzZXQkZGlmZmVyZW5jZV91cGRhdGUoZil7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihmKSxoPT57dGhpcy5zZXQkZGlzY2FyZChoKX0pfSxzZXQkaW50ZXJzZWN0aW9uKGYpe2NvbnN0IGg9XG5uZXcgdGhpcy5zayRidWlsdGluQmFzZTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGYpLHA9Pnt0aGlzLnNxJGNvbnRhaW5zKHApJiZoLnNldCRhZGQocCl9KSwoKT0+aCl9LHNldCRpbnRlcnNlY3Rpb25fbXVsdGkoLi4uZil7aWYoIWYubGVuZ3RoKXJldHVybiB0aGlzLnNldCRjb3B5KCk7bGV0IGg9dGhpcztyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckFycmF5KGYscD0+U2subWlzY2V2YWwuY2hhaW4oaC5zZXQkaW50ZXJzZWN0aW9uKHApLGc9PntoPWd9KSksKCk9PmgpfSxzZXQkaXNzdWJzZXQoZil7Y29uc3QgaD10aGlzLmdldCRzaXplKCkscD1mLmdldCRzaXplKCk7aWYoaD5wKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO2ZvcihsZXQgZz10aGlzLnRwJGl0ZXIoKSxhPWcudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1hO2E9Zy50cCRpdGVybmV4dCgpKWlmKCFmLnNxJGNvbnRhaW5zKGEpKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO1xucmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJH0sc2V0JHN5bW1ldHJpY19kaWZmX3VwZGF0ZShmKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGYpLGg9Pnt2b2lkIDA9PT10aGlzLnNldCRkaXNjYXJkKGgpJiZ0aGlzLnNldCRhZGQoaCl9KX0sc2V0JHVwZGF0ZShmKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGYpLGg9Pnt0aGlzLnNldCRhZGQoaCl9KX0sc3dhcCRib2RpZXMoZil7dGhpcy52PWYudn19KX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uc2V0XCIsU2suYnVpbHRpbi5zZXQpO1A9U2suYnVpbHRpbi5zZXQucHJvdG90eXBlO1NrLmJ1aWx0aW4uZnJvemVuc2V0PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJmcm96ZW5zZXRcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZil7dm9pZCAwPT09Zj9mPVtdOkFycmF5LmlzQXJyYXkoZil8fChmPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGYpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uZnJvemVuc2V0LFwiYmFkIGNhbGwgdG8gZnJvemVuIHNldCAtIG11c3QgYmUgY2FsbGVkIHdpdGggJ25ldydcIik7Y29uc3QgaD1bXTtmb3IobGV0IHA9MDtwPGYubGVuZ3RoO3ArKyloLnB1c2goZltwXSksaC5wdXNoKCEwKTt0aGlzLnY9bmV3IFNrLmJ1aWx0aW4uZGljdChoKTt0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19udW1iZXI6ITAsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRkb2M6XCJmcm96ZW5zZXQoKSAtPiBlbXB0eSBmcm96ZW5zZXQgb2JqZWN0XFxuZnJvemVuc2V0KGl0ZXJhYmxlKSAtPiBmcm96ZW5zZXQgb2JqZWN0XFxuXFxuQnVpbGQgYW4gaW1tdXRhYmxlIHVub3JkZXJlZCBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBlbGVtZW50cy5cIix0cCRoYXNoKCl7bGV0IGY9MTkyNzg2ODIzNztjb25zdCBoPXRoaXMuc2skYXNhcnJheSgpO2YqPWgubGVuZ3RoKzE7Zm9yKGxldCBwPTA7cDxoLmxlbmd0aDtwKyspe2NvbnN0IGc9XG5Tay5hYnN0ci5vYmplY3RIYXNoKGhbcF0pO2ZePTM2NDQ3OTgxNjcqKGdeZzw8MTZeODk4Njk3NDcpfXJldHVybiA2OTA2OSpmKzkwNzEzMzkyM30sdHAkbmV3KGYsaCl7aWYodGhpcyE9PVNrLmJ1aWx0aW4uZnJvemVuc2V0LnByb3RvdHlwZSlyZXR1cm4gdGhpcy4kc3VidHlwZV9uZXcoZixoKTtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwiZnJvemVuc2V0XCIsaCk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwiZnJvemVuc2V0XCIsZiwwLDEpO2Y9ZlswXTtyZXR1cm4gdm9pZCAwIT09ZiYmZi5vYiR0eXBlPT09U2suYnVpbHRpbi5mcm96ZW5zZXQ/ZjpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShmLCEwKSxwPT5wLmxlbmd0aD9uZXcgU2suYnVpbHRpbi5mcm96ZW5zZXQocCk6U2suYnVpbHRpbi5mcm96ZW5zZXQuJGVtcHR5c2V0KX0sJHI6UC4kcix0cCRpdGVyOlAudHAkaXRlcix0cCRyaWNoY29tcGFyZTpQLnRwJHJpY2hjb21wYXJlLG5iJHN1YnRyYWN0OlAubmIkc3VidHJhY3QsXG5uYiRhbmQ6UC5uYiRhbmQsbmIkb3I6UC5uYiRvcixuYiR4b3I6UC5uYiR4b3Isc3EkbGVuZ3RoOlAuc3EkbGVuZ3RoLHNxJGNvbnRhaW5zOlAuc3EkY29udGFpbnN9LG1ldGhvZHM6e2NvcHk6T2JqZWN0LmFzc2lnbih7fSxQLmNvcHkuZCRkZWYseyRtZXRoKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3I9PT10aGlzLnNrJGJ1aWx0aW5CYXNlP3RoaXM6bmV3IFNrLmJ1aWx0aW4uZnJvemVuc2V0KHRoaXMuc2skYXNhcnJheSgpKX19KSxkaWZmZXJlbmNlOlAuZGlmZmVyZW5jZS5kJGRlZixpbnRlcnNlY3Rpb246UC5pbnRlcnNlY3Rpb24uZCRkZWYsaXNkaXNqb2ludDpQLmlzZGlzam9pbnQuZCRkZWYsaXNzdWJzZXQ6UC5pc3N1YnNldC5kJGRlZixpc3N1cGVyc2V0OlAuaXNzdXBlcnNldC5kJGRlZixzeW1tZXRyaWNfZGlmZmVyZW5jZTpQLnN5bW1ldHJpY19kaWZmZXJlbmNlLmQkZGVmLHVuaW9uOlAudW5pb24uZCRkZWZ9LGNsYXNzbWV0aG9kczpTay5nZW5lcmljLmNsYXNzR2V0SXRlbSxcbnByb3RvOk9iamVjdC5hc3NpZ24oeyRzdWJ0eXBlX25ldyhmLGgpe2NvbnN0IHA9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmJ1aWx0aW4uZnJvemVuc2V0LnByb3RvdHlwZS50cCRuZXcoZiksZz0+e3Audj1nLnY7cmV0dXJuIHB9KX19LEYpfSk7U2suYnVpbHRpbi5mcm96ZW5zZXQuJGVtcHR5c2V0PW5ldyBTay5idWlsdGluLmZyb3plbnNldChbXSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5mcm96ZW5zZXRcIixTay5idWlsdGluLmZyb3plbnNldCk7dmFyIGQ9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwic2V0X2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGYpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWYuc2skYXNhcnJheSgpO3RoaXMuJG9yaWc9Zn0saXRlcm5leHQ6U2suZ2VuZXJpYy5pdGVyTmV4dFdpdGhBcnJheUNoZWNrU2l6ZSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sXG5mbGFnczp7c2skdW5hY2NlcHRhYmxlQmFzZTohMH19KX0sZnVuY3Rpb24oRixQKXtTay5idWlsdGluLnByaW50PWZ1bmN0aW9uKGIsZSl7bGV0IFtkLGYsaF09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJwcmludFwiLFtcInNlcFwiLFwiZW5kXCIsXCJmaWxlXCIsXCJmbHVzaFwiXSxbXSxlKTtpZih2b2lkIDA9PT1kfHxTay5idWlsdGluLmNoZWNrTm9uZShkKSlkPVwiIFwiO2Vsc2UgaWYoU2suYnVpbHRpbi5jaGVja1N0cmluZyhkKSlkPWQuJGpzc3RyKCk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZXAgbXVzdCBiZSBOb25lIG9yIGEgc3RyaW5nLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZCkpO2lmKHZvaWQgMD09PWZ8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGYpKWY9XCJcXG5cIjtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZikpZj1mLiRqc3N0cigpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZW5kIG11c3QgYmUgTm9uZSBvciBhIHN0cmluZywgbm90IFwiK1xuU2suYWJzdHIudHlwZU5hbWUoZikpO2xldCBwO2lmKHZvaWQgMCE9PWgmJiFTay5idWlsdGluLmNoZWNrTm9uZShoKSYmKHA9U2suYWJzdHIubG9va3VwU3BlY2lhbChoLFNrLmJ1aWx0aW4uc3RyLiR3cml0ZSksdm9pZCAwPT09cCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoaCkrXCInIG9iamVjdCBoYXMgbm8gYXR0cmlidXRlICd3cml0ZSdcIik7Y29uc3QgZz1uZXcgU2suYnVpbHRpbi5zdHIoYi5tYXAoYT0+KG5ldyBTay5idWlsdGluLnN0cihhKSkudG9TdHJpbmcoKSkuam9pbihkKStmKTtpZih2b2lkIDAhPT1wKVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShwLFtnXSk7ZWxzZSByZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFwic3lzXCIsITEsITApLGE9PihwPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYS4kZC5zdGRvdXQsU2suYnVpbHRpbi5zdHIuJHdyaXRlKSkmJlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShwLFxuW2ddKSl9O1NrLmJ1aWx0aW4ucHJpbnQuY29fZmFzdGNhbGw9MX0sZnVuY3Rpb24oRixQKXtTay5idWlsdGluLm1vZHVsZT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwibW9kdWxlXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7dGhpcy4kZD17fX0sc2xvdHM6e3RwJGRvYzpcIkNyZWF0ZSBhIG1vZHVsZSBvYmplY3QuXFxuXFxuVGhlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzsgdGhlIG9wdGlvbmFsIGRvYyBhcmd1bWVudCBjYW4gaGF2ZSBhbnkgdHlwZS5cIix0cCRnZXRhdHRyKGIsZSl7dmFyIGQ9dGhpcy4kZFtiLiRtYW5nbGVkXTtpZih2b2lkIDAhPT1kKXJldHVybiBkO2Q9dGhpcy5vYiR0eXBlLiR0eXBlTG9va3VwKGIpO2lmKHZvaWQgMCE9PWQpe2NvbnN0IGg9ZC50cCRkZXNjcl9nZXQ7cmV0dXJuIGg/aC5jYWxsKGQsdGhpcyx0aGlzLm9iJHR5cGUsZSk6ZH1jb25zdCBmPXRoaXMuJGQuX19nZXRhdHRyX187aWYodm9pZCAwIT09ZilyZXR1cm4gZD1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+XG5Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZixbYl0pLGg9PntpZighKGggaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBoO30pLGU/ZDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coZCl9LHRwJHNldGF0dHI6U2suZ2VuZXJpYy5zZXRBdHRyLHRwJG5ldzpTay5nZW5lcmljLm5ldyx0cCRpbml0KGIsZSl7Y29uc3QgW2QsZl09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJtb2R1bGVcIixbXCJuYW1lXCIsXCJkb2NcIl0sYixlLFtTay5idWlsdGluLm5vbmUubm9uZSRdKTtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwibW9kdWxlXCIsXCJzdHJpbmdcIixkKTt0aGlzLmluaXQkZGljdChkLGYpfSwkcigpe2xldCBiPXRoaXMuZ2V0JG5hbWUoKTtpZih2b2lkIDAhPT1iKXt2YXIgZT10aGlzLmdldCRtb2RfcmVwcmYoKTtpZih2b2lkIDAhPT1lKXJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZSxcblt0aGlzXSl9Yj12b2lkIDA9PT1iP1wiJz8nXCI6YjtlPXRoaXMuZnJvbSRmaWxlKCk7ZT12b2lkIDA9PT1lP3RoaXMuZW1wdHlfb3IkbG9hZGVyKCk6ZTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPG1vZHVsZSBcIitiK2UrXCI+XCIpfX0sZ2V0c2V0czp7X19kaWN0X186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5KHRoaXMuJGQpfX19LG1ldGhvZHM6e19fZGlyX186eyRtZXRoKCl7Y29uc3QgYj10aGlzLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGRpY3QpO2lmKCFTay5idWlsdGluLmNoZWNrTWFwcGluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2RpY3RfXyBpcyBub3QgYSBkaWN0aW9uYXJ5XCIpO2NvbnN0IGU9Yi5tcCRsb29rdXAoU2suYnVpbHRpbi5zdHIuJGRpcik7cmV0dXJuIHZvaWQgMCE9PWU/U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGUsW10pOm5ldyBTay5idWlsdGluLmxpc3QoU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoYikpfSxcbiRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiX19kaXJfXygpIC0+IGxpc3RcXG5zcGVjaWFsaXplZCBkaXIoKSBpbXBsZW1lbnRhdGlvblwifX0scHJvdG86e3NrJGhhc0RpY3Q6ITAsaW5pdCRkaWN0KGIsZSl7dGhpcy4kZC5fX25hbWVfXz1iO3RoaXMuJGQuX19kb2NfXz1lO3RoaXMuJGQuX19wYWNrYWdlX189U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMuJGQuX19zcGVjX189U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMuJGQuX19sb2FkZXJfXz1Tay5idWlsdGluLm5vbmUubm9uZSR9LHNrJGF0dHJFcnJvcigpe2xldCBiPXRoaXMuZ2V0JG5hbWUoKTtiPXZvaWQgMD09PWI/XCJtb2R1bGVcIjpcIm1vZHVsZSBcIitiO3RoaXMuJGluaXRpYWxpemluZyYmKGI9XCIobW9zdCBsaWtlbHkgZHVlIHRvIGEgY2lyY3VsYXIgaW1wb3J0KSBwYXJ0aWFsbHkgaW5pdGlhbGl6ZWQgXCIrYik7cmV0dXJuIGJ9LGdldCRuYW1lKCl7Y29uc3QgYj10aGlzLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJG5hbWUpO1xucmV0dXJuIGImJlNrLm1pc2NldmFsLm9iamVjdFJlcHIoYil9LGZyb20kZmlsZSgpe2NvbnN0IGI9dGhpcy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRmaWxlKTtyZXR1cm4gYiYmXCIgZnJvbSBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKGIpfSxlbXB0eV9vciRsb2FkZXIoKXtpZih0aGlzLiRqcyYmdGhpcy4kanMuaW5jbHVkZXMoXCIkYnVpbHRpbm1vZHVsZVwiKSlyZXR1cm5cIiAoYnVpbHQtaW4pXCI7Y29uc3QgYj10aGlzLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGxvYWRlcik7cmV0dXJuIHZvaWQgMD09PWJ8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGIpP1wiXCI6XCIgKFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIoYikrXCIpXCJ9LGdldCRtb2RfcmVwcmYoKXtjb25zdCBiPXRoaXMudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kbG9hZGVyKTtyZXR1cm4gYiYmYi50cCRnZXRhdHRyKHRoaXMuc3RyJG1vZF9yZXByKX0sc3RyJG1vZF9yZXByOm5ldyBTay5idWlsdGluLnN0cihcIm1vZHVsZV9yZXByXCIpfX0pO1xuU2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5tb2R1bGVcIixTay5idWlsdGluLm1vZHVsZSl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5zdHJ1Y3RzZXFfdHlwZXM9e307U2suYnVpbHRpbi5tYWtlX3N0cnVjdHNlcT1mdW5jdGlvbihiLGUsZCxmLGgpe2Y9dm9pZCAwPT09Zj97fTpmO2g9dm9pZCAwPT09aD9udWxsOmg7Y29uc3QgcD1iK1wiLlwiK2UsZz1bXSxhPXt9O09iamVjdC5rZXlzKGQpLmZvckVhY2goKGssdSk9PntnLnB1c2goayk7YVtrXT17JGdldCgpe3JldHVybiB0aGlzLnZbdV19LCRkb2M6ZFtrXX19KTtjb25zdCBjPWcubGVuZ3RoO2xldCBuPWM7T2JqZWN0LmtleXMoZikuZm9yRWFjaCgoayx1KT0+e2Fba109eyRnZXQoKXtyZXR1cm4gdGhpcy4kaGlkZGVuW3VdfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRkb2M6ZltrXX07bisrfSk7dmFyIG09U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhwLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihrLHUpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZlxubSk7U2suYnVpbHRpbi50dXBsZS5jYWxsKHRoaXMsayk7dGhpcy4kaGlkZGVuPXV8fFtdfSxiYXNlOlNrLmJ1aWx0aW4udHVwbGUsc2xvdHM6e3RwJG5ldyhrLHUpe1NrLmFic3RyLmNoZWNrT25lQXJnKHAsayx1KTtrPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGtbMF0pO2lmKGsubGVuZ3RoPGMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHArXCIoKSB0YWtlcyBhbiBhdCBsZWFzdCBcIitjK1wiLXNlcXVlbmNlIChcIitrLmxlbmd0aCtcIi1zZXF1ZW5jZSBnaXZlbilcIik7aWYoay5sZW5ndGg+bil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IocCtcIigpIHRha2VzIGFuIGF0IG1vc3QgXCIrbitcIi1zZXF1ZW5jZSAoXCIray5sZW5ndGgrXCItc2VxdWVuY2UgZ2l2ZW4pXCIpO3JldHVybiBuZXcgbShrLnNsaWNlKDAsYyksay5zbGljZShjKSl9LHRwJGRvYzpoP2g6U2suYnVpbHRpbi5ub25lLm5vbmUkLCRyKCl7dmFyIGs7aWYoMD09PXRoaXMudi5sZW5ndGgpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihwK1xuXCIoKVwiKTt2YXIgdT1bXTtmb3Ioaz0wO2s8Zy5sZW5ndGg7KytrKXVba109Z1trXStcIj1cIitTay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMudltrXSk7az11LmpvaW4oXCIsIFwiKTsxPT09dGhpcy52Lmxlbmd0aCYmKGsrPVwiLFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHArXCIoXCIraytcIilcIil9fSxtZXRob2RzOntfX3JlZHVjZV9fOnskbWV0aCgpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJfX3JlZHVjZV9fIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTt9LCRmbGFnczp7Tm9BcmdzOiEwfX19LGdldHNldHM6YSxwcm90bzp7bnVtX3NlcXVlbmNlX2ZpZWxkczpuZXcgU2suYnVpbHRpbi5pbnRfKGMpfX0pO3JldHVybiBtfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLm1ha2Vfc3RydWN0c2VxXCIsU2suYnVpbHRpbi5tYWtlX3N0cnVjdHNlcSl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5nZW5lcmF0b3I9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiZ2VuZXJhdG9yXCIsXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oYixlLGQsZixoKXt2YXIgcDtpZihiKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmdlbmVyYXRvcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcImJhZCBpbnRlcm5hbCBjYWxsIHRvIGdlbmVyYXRvciwgdXNlICduZXcnXCIpO3RoaXMuZnVuY19jb2RlPWI7dGhpcy5mdW5jX2dsb2JhbHM9ZXx8bnVsbDt0aGlzLmdpJHJ1bm5pbmc9ITE7dGhpcy5naSRyZXN1bWVhdD0wO3RoaXMuZ2kkc2VudHZhbHVlPVNrLmJ1aWx0aW4ubm9uZS5ub25lJDt0aGlzLmdpJGxvY2Fscz17fTt0aGlzLmdpJGNlbGxzPXt9O2lmKDA8ZC5sZW5ndGgpZm9yKGU9MDtlPGIuY29fdmFybmFtZXMubGVuZ3RoOysrZSl0aGlzLmdpJGxvY2Fsc1tiLmNvX3Zhcm5hbWVzW2VdXT1kW2VdO2lmKHZvaWQgMCE9PWgpZm9yKHAgaW4gaClmW3BdPWhbcF07dGhpcy5mdW5jX2Nsb3N1cmU9Zn19LHNsb3RzOnskcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8Z2VuZXJhdG9yIG9iamVjdCBcIitcbnRoaXMuZnVuY19jb2RlLmNvX25hbWUuditcIj5cIil9fSxpdGVybmV4dChiLGUpe3ZhciBkPXRoaXM7aWYodGhpcy5naSRydW5uaW5nKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJnZW5lcmF0b3IgYWxyZWFkeSBleGVjdXRpbmdcIik7dGhpcy5naSRydW5uaW5nPSEwO3ZvaWQgMD09PWUmJihlPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7dGhpcy5naSRzZW50dmFsdWU9ZTtlPVt0aGlzXTt0aGlzLmZ1bmNfY2xvc3VyZSYmZS5wdXNoKHRoaXMuZnVuY19jbG9zdXJlKTtyZXR1cm4gZnVuY3Rpb24gcChoKXtpZihoIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbil7aWYoYilyZXR1cm4gbmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb24ocCxoKTtoPVNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhoKX1kLmdpJHJ1bm5pbmc9ITE7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09aCk7aWYoQXJyYXkuaXNBcnJheShoKSlyZXR1cm4gZC5naSRyZXN1bWVhdD1cbmhbMF0saD1oWzFdO2QuZ2kkcmV0PWh9KHRoaXMuZnVuY19jb2RlLmFwcGx5KHRoaXMuZnVuY19nbG9iYWxzLGUpKX0sbWV0aG9kczp7c2VuZDp7JG1ldGgoYil7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKHRoaXMudHAkaXRlcm5leHQoITAsYiksZT0+e2lmKHZvaWQgMD09PWUpdGhyb3cgZT10aGlzLmdpJHJldCx2b2lkIDAhPT1lJiZlIT09U2suYnVpbHRpbi5ub25lLm5vbmUkP25ldyBTay5idWlsdGluLlN0b3BJdGVyYXRpb24oZSk6bmV3IFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbjtyZXR1cm4gZX0pfSwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcInNlbmQoYXJnKSAtPiBzZW5kICdhcmcnIGludG8gZ2VuZXJhdG9yLFxcbnJldHVybiBuZXh0IHlpZWxkZWQgdmFsdWUgb3IgcmFpc2UgU3RvcEl0ZXJhdGlvbi5cIn19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5nZW5lcmF0b3JcIixTay5idWlsdGluLmdlbmVyYXRvcik7U2suYnVpbHRpbi5tYWtlR2VuZXJhdG9yPWZ1bmN0aW9uKGIsXG5lKXt2YXIgZCxmPW5ldyBTay5idWlsdGluLmdlbmVyYXRvcihudWxsLG51bGwsbnVsbCk7Zi50cCRpdGVybmV4dD1iO2ZvcihkIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShkKSYmKGZbZF09ZVtkXSk7cmV0dXJuIGZ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ubWFrZUdlbmVyYXRvclwiLFNrLmJ1aWx0aW4ubWFrZUdlbmVyYXRvcil9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5maWxlPWZ1bmN0aW9uKGIsZSxkKXt2YXIgZjtpZighKHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmZpbGUpKXJldHVybiBuZXcgU2suYnVpbHRpbi5maWxlKGIsZSxkKTt0aGlzLm1vZGU9ZTt0aGlzLm5hbWU9U2suZmZpLnJlbWFwVG9KcyhiKTt0aGlzLmNsb3NlZD0hMTtpZihcIi9kZXYvc3Rkb3V0XCI9PT10aGlzLm5hbWUpdGhpcy5kYXRhJD1Tay5idWlsdGluLm5vbmUubm9uZSQsdGhpcy5maWxlbm89MTtlbHNlIGlmKFwiL2Rldi9zdGRpblwiPT09dGhpcy5uYW1lKXRoaXMuZmlsZW5vPTA7ZWxzZSBpZihcIi9kZXYvc3RkZXJyXCI9PT1cbnRoaXMubmFtZSl0aGlzLmZpbGVubz0yO2Vsc2V7aWYoXCJ3XCI9PT1Tay5mZmkucmVtYXBUb0pzKHRoaXMubW9kZSkpdGhpcy5maWxlbm89U2suYnVpbHRpbi5maWxlLmN1cnJlbnRGaWxlbm8rKztlbHNlIGZvcihmIGluIHRoaXMuZmlsZW5vPVNrLmluQnJvd3Nlcj8xMDoxMSx0aGlzLmRhdGEkPVNrLnJlYWQoYi52KSx0aGlzLmxpbmVMaXN0PXRoaXMuZGF0YSQuc3BsaXQoXCJcXG5cIiksdGhpcy5saW5lTGlzdD10aGlzLmxpbmVMaXN0LnNsaWNlKDAsLTEpLHRoaXMubGluZUxpc3QpdGhpcy5saW5lTGlzdFtmXSs9XCJcXG5cIjt0aGlzLmN1cnJlbnRMaW5lPTB9dGhpcy5wb3MkPTA7U2suZmlsZW9wZW4mJjEwPD10aGlzLmZpbGVubyYmU2suZmlsZW9wZW4odGhpcyk7cmV0dXJuIHRoaXN9O1NrLmJ1aWx0aW4uZmlsZS5jdXJyZW50RmlsZW5vPTEyO1NrLmFic3RyLnNldFVwSW5oZXJpdGFuY2UoXCJmaWxlXCIsU2suYnVpbHRpbi5maWxlLFNrLmJ1aWx0aW4ub2JqZWN0KTtTay5hYnN0ci5zZXRVcEJ1aWx0aW5Ncm8oU2suYnVpbHRpbi5maWxlKTtcblNrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuJHI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPFwiKyh0aGlzLmNsb3NlZD9cImNsb3NlZFwiOlwib3BlblwiKStcImZpbGUgJ1wiK3RoaXMubmFtZStcIicsIG1vZGUgJ1wiK1NrLmZmaS5yZW1hcFRvSnModGhpcy5tb2RlKStcIic+XCIpfTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnRwJGl0ZXI9ZnVuY3Rpb24oKXt2YXIgYj17dHAkaXRlcjpmdW5jdGlvbigpe3JldHVybiBifSwkb2JqOnRoaXMsJGluZGV4OnRoaXMuY3VycmVudExpbmUsJGxpbmVzOnRoaXMubGluZUxpc3QsdHAkaXRlcm5leHQ6ZnVuY3Rpb24oKXtpZighKGIuJGluZGV4Pj1iLiRsaW5lcy5sZW5ndGgpKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYi4kbGluZXNbYi4kaW5kZXgrK10pfX07cmV0dXJuIGJ9O1NrLmFic3RyLnNldFVwU2xvdHMoU2suYnVpbHRpbi5maWxlKTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLl9fZW50ZXJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIpe3JldHVybiBifSk7XG5Tay5idWlsdGluLmZpbGUucHJvdG90eXBlLl9fZXhpdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYil7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLmZpbGUucHJvdG90eXBlLmNsb3NlLFtiXSl9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLmNsb3NlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYil7Yi5jbG9zZWQ9ITA7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuZmx1c2g9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihiKXt9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLmZpbGVubz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLmZpbGVub30pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuaXNhdHR5PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYil7cmV0dXJuITF9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnJlYWQ9XG5uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZSl7dmFyIGQ9Yi5kYXRhJC5sZW5ndGg7aWYoYi5jbG9zZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkkvTyBvcGVyYXRpb24gb24gY2xvc2VkIGZpbGVcIik7dmFyIGY9dm9pZCAwPT09ZT9kOlNrLmZmaS5yZW1hcFRvSnMoZSk7Zj1uZXcgU2suYnVpbHRpbi5zdHIoYi5kYXRhJC5zdWJzdHIoYi5wb3MkLGYpKTtiLnBvcyQ9dm9pZCAwPT09ZT9kOmIucG9zJCtTay5mZmkucmVtYXBUb0pzKGUpO2IucG9zJD49ZCYmKGIucG9zJD1kKTtyZXR1cm4gZn0pO1NrLmJ1aWx0aW4uZmlsZS4kcmVhZGxpbmU9ZnVuY3Rpb24oYixlLGQpe2lmKDA9PT1iLmZpbGVubyl7Yj1Tay5mZmkucmVtYXBUb0pzKGQpO2I9U2suaW5wdXRmdW4oYj9iOlwiXCIpO2lmKGIgaW5zdGFuY2VvZiBQcm9taXNlfHxiJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi50aGVuKXt2YXIgZj1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbjtmLnJlc3VtZT1mdW5jdGlvbigpe2lmKGYuZGF0YS5lcnJvcil0aHJvdyBmLmRhdGEuZXJyb3I7XG5yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGYuZGF0YS5yZXN1bHQpfTtmLmRhdGE9e3R5cGU6XCJTay5wcm9taXNlXCIscHJvbWlzZTpifTtyZXR1cm4gZn1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGIpfWU9XCJcIjtiLmN1cnJlbnRMaW5lPGIubGluZUxpc3QubGVuZ3RoJiYoZT1iLmxpbmVMaXN0W2IuY3VycmVudExpbmVdLGIuY3VycmVudExpbmUrKyk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihlKX07U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS5yZWFkbGluZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZSl7cmV0dXJuIFNrLmJ1aWx0aW4uZmlsZS4kcmVhZGxpbmUoYixlLHZvaWQgMCl9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnJlYWRsaW5lcz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZSl7aWYoMD09PWIuZmlsZW5vKXJldHVybiBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwicmVhZGxpbmVzIGlucyd0IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlIHdlYiBkb2Vzbid0IHN1cHBvcnQgQ3RybCtEXCIpO1xudmFyIGQ9W107Zm9yKGU9Yi5jdXJyZW50TGluZTtlPGIubGluZUxpc3QubGVuZ3RoO2UrKylkLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKGIubGluZUxpc3RbZV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChkKX0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuc2Vlaz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZSxkKXtlPVNrLmZmaS5yZW1hcFRvSnMoZSk7dm9pZCAwPT09ZCYmKGQ9MCk7MD09PWQ/Yi5wb3MkPWU6MT09ZD9iLnBvcyQ9Yi5kYXRhJC5sZW5ndGgrZToyPT1kJiYoYi5wb3MkPWIuZGF0YSQubGVuZ3RoK2UpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnRlbGw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihiKXtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShiLnBvcyQpfSk7U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS50cnVuY2F0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsXG5lKXtTay5hc3NlcnRzLmZhaWwoKX0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUud3JpdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihiLGUpe3ZhciBkPVNrLmZmaS5yZW1hcFRvSnMoYi5tb2RlKTtTay5mZmkucmVtYXBUb0pzKGUpO2lmKFwid1wiPT09ZHx8XCJ3YlwiPT09ZHx8XCJhXCI9PT1kfHxcImFiXCI9PT1kKWlmKFNrLmZpbGV3cml0ZSl7aWYoYi5jbG9zZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkkvTyBvcGVyYXRpb24gb24gY2xvc2VkIGZpbGVcIik7MT09PWIuZmlsZW5vP1NrLm91dHB1dChTay5mZmkucmVtYXBUb0pzKGUpKTpTay5maWxld3JpdGUoYixlKX1lbHNlIDE9PT1iLmZpbGVubz9Tay5vdXRwdXQoU2suZmZpLnJlbWFwVG9KcyhlKSk6U2suYXNzZXJ0cy5mYWlsKCk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uZmlsZVwiLFNrLmJ1aWx0aW4uZmlsZSl9LGZ1bmN0aW9uKEYsUCl7ZnVuY3Rpb24gYih2LFxuQil7aWYobnVsbD09PXZ8fHZvaWQgMD09PXYpcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtpZih2LnNrJG9iamVjdClyZXR1cm4gdjtpZih2LiRpc1B5V3JhcHBlZCYmdi51bndyYXApcmV0dXJuIHYudW53cmFwKCk7dmFyIEk9dHlwZW9mIHY7Qj1CfHx7fTtpZihcInN0cmluZ1wiPT09SSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHYpO2lmKFwibnVtYmVyXCI9PT1JKXJldHVybiBoKHYpO2lmKFwiYm9vbGVhblwiPT09SSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh2KTtpZihcImZ1bmN0aW9uXCI9PT1JKXJldHVybiBCLmZ1bmNIb29rP0IuZnVuY0hvb2sodik6YSh2KTtpZihKU0JJLl9faXNCaWdJbnQodikpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oSlNCSS5udW1iZXJJZlNhZmUodikpO2lmKEFycmF5LmlzQXJyYXkodikpcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qodi5tYXAoTT0+YihNLEIpKSk7aWYoXCJvYmplY3RcIj09PUkpe0k9di5jb25zdHJ1Y3RvcjtpZihJPT09T2JqZWN0JiZcbk9iamVjdC5nZXRQcm90b3R5cGVPZih2KT09PWN8fHZvaWQgMD09PUkpcmV0dXJuIEIuZGljdEhvb2s/Qi5kaWN0SG9vayh2KTpnKHYsQik7aWYoST09PVVpbnQ4QXJyYXkpcmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKHYpO2lmKEk9PT1TZXQpcmV0dXJuIHAodixCKTtpZihJPT09TWFwKXtjb25zdCBNPW5ldyBTay5idWlsdGluLmRpY3Q7di5mb3JFYWNoKChTLEUpPT57TS5tcCRhc3Nfc3Vic2NyaXB0KGIoRSxCKSxiKFMsQikpfSk7cmV0dXJuIE19cmV0dXJuIEk9PT1Tay5taXNjZXZhbC5TdXNwZW5zaW9uP3Y6Qi5wcm94eUhvb2s/Qi5wcm94eUhvb2sodik6YSh2KX1pZihCLnVuaGFuZGxlZEhvb2spcmV0dXJuIEIudW5oYW5kbGVkSG9vayh2KTtTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgcmVtYXAgY2FzZSBvZiB0eXBlIFwiK0kpfWZ1bmN0aW9uIGUodixCKXtpZih2b2lkIDA9PT12fHxudWxsPT09dilyZXR1cm4gdjtjb25zdCBJPXYudmFsdWVPZigpO2lmKG51bGw9PT1JKXJldHVybiBJO1xuY29uc3QgTT10eXBlb2YgSTtCPUJ8fHt9O2lmKFwic3RyaW5nXCI9PT1NKXJldHVybiBCLnN0cmluZ0hvb2s/Qi5zdHJpbmdIb29rKEkpOkk7aWYoXCJib29sZWFuXCI9PT1NKXJldHVybiBJO2lmKFwibnVtYmVyXCI9PT1NKXJldHVybiBCLm51bWJlckhvb2s/Qi5udW1iZXJIb29rKEksdik6STtpZihKU0JJLl9faXNCaWdJbnQoSSkpcmV0dXJuIEIuYmlnaW50SG9vaz9CLmJpZ2ludEhvb2soSSx2KTpJO2lmKEFycmF5LmlzQXJyYXkoSSkpcmV0dXJuIEIuYXJyYXlIb29rP0IuYXJyYXlIb29rKEksdik6SS5tYXAoUz0+ZShTLEIpKTtpZihJLnNrJG9iamVjdClyZXR1cm4gdiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdD9CLmRpY3RIb29rP0IuZGljdEhvb2sodik6Zih2LEIpOnYgaW5zdGFuY2VvZiBTay5idWlsdGluLnNldD9CLnNldEhvb2s/Qi5zZXRIb29rKHYpOm5ldyBTZXQoZCh2LEIpKTpCLnVuaGFuZGxlZEhvb2s/Qi51bmhhbmRsZWRIb29rKHYpOnZvaWQgMDtpZihcIm9iamVjdFwiPT09XG5NKXJldHVybiBCLm9iamVjdEhvb2s/Qi5vYmplY3RIb29rKEksdik6STtpZihcImZ1bmN0aW9uXCI9PT1NKXJldHVybiBCLmZ1bmNIb29rP0IuZnVuY0hvb2soSSx2KTpJO1NrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCB0eXBlIFwiK00pfWZ1bmN0aW9uIGQodixCKXtyZXR1cm4gQXJyYXkuZnJvbSh2LEk9PmUoSSxCKSl9ZnVuY3Rpb24gZih2LEIpe2NvbnN0IEk9e307di4kaXRlbXMoKS5mb3JFYWNoKE09Pnt2YXIgW1MsRV09TTtJW1MudmFsdWVPZigpXT1lKEUsQil9KTtyZXR1cm4gSX1mdW5jdGlvbiBoKHYpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHYpP01hdGguYWJzKHYpPE51bWJlci5NQVhfU0FGRV9JTlRFR0VSP25ldyBTay5idWlsdGluLmludF8odik6bmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLkJpZ0ludCh2KSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHYpfWZ1bmN0aW9uIHAodixCKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2V0KEFycmF5LmZyb20odixJPT5iKEksQikpKX1cbmZ1bmN0aW9uIGcodixCKXtjb25zdCBJPW5ldyBTay5idWlsdGluLmRpY3Q7T2JqZWN0LmVudHJpZXModikuZm9yRWFjaChNPT57dmFyIFtTLEVdPU07SS5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihTKSxiKEUsQikpfSk7cmV0dXJuIEl9ZnVuY3Rpb24gYSh2LEIpe2lmKG51bGw9PT12fHx2b2lkIDA9PT12KXJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7dmFyIEk9dHlwZW9mIHY7aWYoXCJvYmplY3RcIiE9PUkmJlwiZnVuY3Rpb25cIiE9PUkpcmV0dXJuIGIodik7Qj1CfHx7fTtpZihJPWsuZ2V0KHYpKXtpZihCLmJvdW5kPT09SS4kYm91bmQpcmV0dXJuIEk7Qi5uYW1lfHwoQi5uYW1lPUkuJG5hbWUpfUI9bmV3IHoodixCKTtrLnNldCh2LEIpO3JldHVybiBCfVNrLmZmaT17cmVtYXBUb1B5OmIscmVtYXBUb0pzOmUsdG9QeTpiLHRvSnM6ZSxpc1RydWU6ZnVuY3Rpb24odil7cmV0dXJuIG51bGwhPXYmJnYubmIkYm9vbD92Lm5iJGJvb2woKTp2LnNxJGxlbmd0aD9cbjAhPT12LnNxJGxlbmd0aCgpOiEhdn0sdG9Kc1N0cmluZzpmdW5jdGlvbih2KXtyZXR1cm4gU3RyaW5nKHYpfSx0b0pzTnVtYmVyOmZ1bmN0aW9uKHYpe3JldHVybiBOdW1iZXIodil9LHRvSnNBcnJheTpkLHRvSnNIYXNoTWFwOmYsdG9QeURpY3Q6Zyx0b1B5RmxvYXQ6ZnVuY3Rpb24odil7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhOdW1iZXIodikpfSx0b1B5SW50OmZ1bmN0aW9uKHYpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgdilyZXR1cm4gdj1NYXRoLnRydW5jKHYpLE1hdGguYWJzKHYpPE51bWJlci5NQVhfU0FGRV9JTlRFR0VSP25ldyBTay5idWlsdGluLmludF8odik6bmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLkJpZ0ludCh2KSk7aWYoSlNCSS5fX2lzQmlnSW50KHYpKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkubnVtYmVySWZTYWZlKHYpKTtpZihcInN0cmluZ1wiPT09dHlwZW9mIHYmJnYubWF0Y2gobSkpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odik7XG50aHJvdyBuZXcgVHlwZUVycm9yKFwiYmFkIHR5cGUgcGFzc2VkIHRvIHRvUHlJbnQoKSBnb3QgXCIrdik7fSx0b1B5TnVtYmVyOmZ1bmN0aW9uKHYpe2NvbnN0IEI9dHlwZW9mIHY7cmV0dXJuXCJudW1iZXJcIj09PUI/aCh2KTpcInN0cmluZ1wiPT09Qj92Lm1hdGNoKG0pP25ldyBTay5idWlsdGluLmludF8odik6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHBhcnNlRmxvYXQodikpOkpTQkkuX19pc0JpZ0ludCh2KT9uZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkubnVtYmVySWZTYWZlKHYpKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oTnVtYmVyKHYpKX0sdG9QeVN0cjpmdW5jdGlvbih2KXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHYpfSx0b1B5TGlzdDpmdW5jdGlvbih2LEIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KEFycmF5LmZyb20odixJPT5iKEksQikpKX0sdG9QeVR1cGxlOmZ1bmN0aW9uKHYsQil7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKEFycmF5LmZyb20odixJPT5iKEksXG5CKSkpfSx0b1B5U2V0OnAsbnVtYmVyVG9QeTpoLHByb3h5OmF9O2NvbnN0IGM9T2JqZWN0LnByb3RvdHlwZSxuPUZ1bmN0aW9uLnByb3RvdHlwZSxtPS9eLT9cXGQrJC8saz1uZXcgV2Vha01hcCx1PXtkaWN0SG9vazp2PT5hKHYpLHVuaGFuZGxlZEhvb2s6dj0+U3RyaW5nKHYpfSxsPSh2LEIpPT4oe2RpY3RIb29rOkk9PmEoSSksZnVuY0hvb2s6ST0+YShJLHtib3VuZDp2LG5hbWU6Qn0pLHVuaGFuZGxlZEhvb2s6ST0+U3RyaW5nKEkpfSkscT17dW5oYW5kbGVkSG9vazp2PT57dmFyIEI9ay5nZXQodik7aWYoQilyZXR1cm4gQjtCPXt2LCRpc1B5V3JhcHBlZDohMCx1bndyYXA6KCk9PnZ9O2lmKHZvaWQgMD09PXYudHAkY2FsbClyZXR1cm4gay5zZXQodixCKSxCO2NvbnN0IEk9KC4uLk0pPT57TT1NLm1hcChFPT5iKEUsdSkpO2xldCBTPVNrLm1pc2NldmFsLnRyeUNhdGNoKCgpPT5Tay5taXNjZXZhbC5jaGFpbih2LnRwJGNhbGwoTSksRT0+ZShFLHEpKSxFPT57aWYoU2sudW5jYXVnaHRFeGNlcHRpb24pU2sudW5jYXVnaHRFeGNlcHRpb24oRSk7XG5lbHNlIHRocm93IEU7fSk7Zm9yKDtTIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbjspe2lmKCFTLm9wdGlvbmFsKXJldHVybiBTay5taXNjZXZhbC5hc3luY1RvUHJvbWlzZSgoKT0+Uyk7Uz1TLnJlc3VtZSgpfXJldHVybiBTfTtrLnNldCh2LE9iamVjdC5hc3NpZ24oSSxCKSk7cmV0dXJuIEl9fSx6PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJQcm94eVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbih2LEIpe2lmKHZvaWQgMD09PXYpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiUHJveHkgY2Fubm90IGJlIGNhbGxlZCBmcm9tIHB5dGhvblwiKTt0aGlzLmpzJHdyYXBwZWQ9djt0aGlzLiRtb2R1bGU9bnVsbDt0aGlzLiRtZXRob2RzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5pbiRyZXByPSExO0J8fChCPXt9KTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHRoaXMubWVtb2l6ZWQkc2xvdHMpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiB2Pyh0aGlzLmlzJGNhbGxhYmxlPVxuITAsdGhpcy4kYm91bmQ9Qi5ib3VuZCx0aGlzLiRuYW1lPUIubmFtZXx8di5uYW1lfHxcIihuYXRpdmUgSlMpXCIsMj49dGhpcy4kbmFtZS5sZW5ndGgmJih0aGlzLiRuYW1lKz1cIiAobmF0aXZlIEpTKVwiKSk6KHRoaXMuaXMkY2FsbGFibGU9ITEsZGVsZXRlIHRoaXMuaXMkdHlwZSx0aGlzLmlzJHR5cGU9ITEsdGhpcy4kbmFtZT1CLm5hbWUpfSxzbG90czp7dHAkZG9jOlwicHJveHkgZm9yIGEgamF2YXNjcmlwdCBvYmplY3RcIix0cCRoYXNoKCl7cmV0dXJuIFNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRoYXNoLmNhbGwodGhpcy5qcyR3cmFwcGVkKX0sdHAkZ2V0YXR0cih2KXtyZXR1cm4gdGhpcy4kbG9va3VwKHYpfHxTay5nZW5lcmljLmdldEF0dHIuY2FsbCh0aGlzLHYpfSx0cCRzZXRhdHRyKHYsQil7dj12LnRvU3RyaW5nKCk7dm9pZCAwPT09Qj9kZWxldGUgdGhpcy5qcyR3cmFwcGVkW3ZdOnRoaXMuanMkd3JhcHBlZFt2XT1lKEIscSl9LCRyKCl7aWYodGhpcy5pcyRjYWxsYWJsZSl7aWYodGhpcy5pcyR0eXBlfHxcbiF0aGlzLiRib3VuZClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPFwiK3RoaXMudHAkbmFtZStcIiAnXCIrdGhpcy4kbmFtZStcIic+XCIpO3ZhciB2PVNrLm1pc2NldmFsLm9iamVjdFJlcHIoYSh0aGlzLiRib3VuZCkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8Ym91bmQgXCIrdGhpcy50cCRuYW1lK1wiICdcIit0aGlzLiRuYW1lK1wiJyBvZiBcIit2K1wiPlwiKX1pZih0aGlzLmpzJHByb3RvPT09Yyl7aWYodGhpcy5pbiRyZXByKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJ7Li4ufVwiKTt0aGlzLmluJHJlcHI9ITA7dj1PYmplY3QuZW50cmllcyh0aGlzLmpzJHdyYXBwZWQpLm1hcChCPT57dmFyIFtJLE1dPUI7TT1iKE0sbCh0aGlzLmpzJHdyYXBwZWQsSSkpO3JldHVyblwiJ1wiK0krXCInOiBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKE0pfSk7dj1uZXcgU2suYnVpbHRpbi5zdHIoXCJwcm94eW9iamVjdCh7XCIrdi5qb2luKFwiLCBcIikrXCJ9KVwiKTt0aGlzLmluJHJlcHI9ITE7cmV0dXJuIHZ9cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxcIitcbnRoaXMudHAkbmFtZStcIiBcIisoXCJwcm94eW9iamVjdFwiPT09dGhpcy50cCRuYW1lP1wib2JqZWN0XCI6XCJwcm94eW9iamVjdFwiKStcIj5cIil9LHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsbXAkc3Vic2NyaXB0KHYpe2NvbnN0IEI9dGhpcy4kbG9va3VwKHYpO2lmKHZvaWQgMD09PUIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTG9va3VwRXJyb3Iodik7cmV0dXJuIEJ9LG1wJGFzc19zdWJzY3JpcHQodixCKXtyZXR1cm4gdGhpcy50cCRzZXRhdHRyKHYsQil9LHNxJGNvbnRhaW5zKHYpe3JldHVybiBlKHYpaW4gdGhpcy5qcyR3cmFwcGVkfSxvYiRlcSh2KXtyZXR1cm4gdGhpcy5qcyR3cmFwcGVkPT09di5qcyR3cmFwcGVkfSxvYiRuZSh2KXtyZXR1cm4gdGhpcy5qcyR3cmFwcGVkIT09di5qcyR3cmFwcGVkfSx0cCRhc19udW1iZXI6ITAsbmIkYm9vbCgpe3JldHVybiB0aGlzLmpzJHByb3RvPT09Yz8wPE9iamVjdC5rZXlzKHRoaXMuanMkd3JhcHBlZCkubGVuZ3RoOnRoaXMuc3EkbGVuZ3RoP1xuMDx0aGlzLnNxJGxlbmd0aCgpOiEwfX0sbWV0aG9kczp7X19kaXJfXzp7JG1ldGgoKXtjb25zdCB2PVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLnR5cGUucHJvdG90eXBlLl9fZGlyX18sW3pdKS52YWx1ZU9mKCk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qodi5jb25jYXQoQXJyYXkuZnJvbSh0aGlzLiRkaXIsQj0+bmV3IFNrLmJ1aWx0aW4uc3RyKEIpKSkpfSwkZmxhZ3M6e05vQXJnczohMH19LF9fbmV3X186eyRtZXRoKHYsLi4uQil7aWYoISh2IGluc3RhbmNlb2YgeikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZXhwZWN0ZWQgYSBwcm94eSBvYmplY3QgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IG5vdCBcIitTay5hYnN0ci50eXBlTmFtZSh2KSk7dHJ5e3JldHVybiB2LiRuZXcoQil9Y2F0Y2goSSl7aWYoSSBpbnN0YW5jZW9mIFR5cGVFcnJvciYmSS5tZXNzYWdlLmluY2x1ZGVzKFwibm90IGEgY29uc3RydWN0b3JcIikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIodikrXG5cIiBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTt0aHJvdyBJO319LCRmbGFnczp7TWluQXJnczoxfX0sX19jYWxsX186eyRtZXRoKHYsQil7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHRoaXMuanMkd3JhcHBlZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrdGhpcy50cCRuYW1lK1wiJyBvYmplY3QgaXMgbm90IGNhbGxhYmxlXCIpO3JldHVybiB0aGlzLiRjYWxsKHYsQil9LCRmbGFnczp7RmFzdENhbGw6ITB9fSxrZXlzOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KE9iamVjdC5rZXlzKHRoaXMuanMkd3JhcHBlZCkubWFwKHY9Pm5ldyBTay5idWlsdGluLnN0cih2KSkpfSwkZmxhZ3M6e05vQXJnczohMH19LGdldDp7JG1ldGgodixCKXtyZXR1cm4gdGhpcy4kbG9va3VwKHYpfHxCfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn19fSxnZXRzZXRzOntfX2NsYXNzX186eyRnZXQoKXtyZXR1cm4gYih0aGlzLmpzJHdyYXBwZWQuY29uc3RydWN0b3IsXG51KX0sJHNldCgpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm5vdCB3cml0YWJsZVwiKTt9fSxfX25hbWVfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kbmFtZSl9fSxfX21vZHVsZV9fOnskZ2V0KCl7cmV0dXJuIHRoaXMuJG1vZHVsZXx8U2suYnVpbHRpbi5ub25lLm5vbmUkfSwkc2V0KHYpe3RoaXMuJG1vZHVsZT12fX19LHByb3RvOnt2YWx1ZU9mKCl7cmV0dXJuIHRoaXMuanMkd3JhcHBlZH0sJG5ldyh2LEIpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJfX25ld19fXCIsQik7cmV0dXJuIGIobmV3IHRoaXMuanMkd3JhcHBlZCguLi52Lm1hcChJPT5lKEkscSkpKSx7ZGljdEhvb2s6ST0+YShJKSxwcm94eUhvb2s6ST0+YShJLHtuYW1lOnRoaXMuJG5hbWV9KX0pfSwkY2FsbCh2LEIpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJfX2NhbGxfX1wiLEIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLmpzJHdyYXBwZWQuYXBwbHkodGhpcy4kYm91bmQsXG52Lm1hcChJPT5lKEkscSkpKSxJPT5JIGluc3RhbmNlb2YgUHJvbWlzZT9Tay5taXNjZXZhbC5wcm9taXNlVG9TdXNwZW5zaW9uKEkpOkksST0+YihJLHUpKX0sJGxvb2t1cCh2KXt2PXYudG9TdHJpbmcoKTtjb25zdCBCPXRoaXMuanMkd3JhcHBlZFt2XTtpZih2b2lkIDAhPT1CKXJldHVybiBiKEIsbCh0aGlzLmpzJHdyYXBwZWQsdikpO2lmKHYgaW4gdGhpcy5qcyR3cmFwcGVkKXJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LG1lbW9pemVkJHNsb3RzOntqcyRwcm90bzp7Y29uZmlndXJhYmxlOiEwLGdldCgpe2RlbGV0ZSB0aGlzLmpzJHByb3RvO3JldHVybiB0aGlzLmpzJHByb3RvPU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLmpzJHdyYXBwZWQpfX0sJGRpcjp7Y29uZmlndXJhYmxlOiEwLGdldCgpe2NvbnN0IHY9W107bGV0IEI9dGhpcy5qcyR3cmFwcGVkO2Zvcig7bnVsbCE9QiYmQiE9PWMmJkIhPT1uOyl2LnB1c2goLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQikpLFxuQj1PYmplY3QuZ2V0UHJvdG90eXBlT2YoQik7cmV0dXJuIG5ldyBTZXQodil9fSx0cCRpdGVyOntjb25maWd1cmFibGU6ITAsZ2V0KCl7ZGVsZXRlIHRoaXMudHAkaXRlcjtyZXR1cm4gdm9pZCAwIT09dGhpcy5qcyR3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0/dGhpcy50cCRpdGVyPSgpPT5hKHRoaXMuanMkd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkpOnRoaXMudHAkaXRlcj0oKT0+e3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihTay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMpK1wiIGlzIG5vdCBpdGVyYWJsZVwiKTt9fX0sdHAkaXRlcm5leHQ6e2NvbmZpZ3VyYWJsZTohMCxnZXQoKXtkZWxldGUgdGhpcy50cCRpdGVybmV4dDtpZih2b2lkIDAhPT10aGlzLmpzJHdyYXBwZWQubmV4dClyZXR1cm4gdGhpcy50cCRpdGVybmV4dD0oKT0+e2NvbnN0IHY9dGhpcy5qcyR3cmFwcGVkLm5leHQoKS52YWx1ZTtyZXR1cm4gdiYmYih2LHUpfX19LHNxJGxlbmd0aDp7Y29uZmlndXJhYmxlOiEwLFxuZ2V0KCl7ZGVsZXRlIHRoaXMuc3EkbGVuZ3RoO2lmKCF0aGlzLmlzJGNhbGxhYmxlJiZ2b2lkIDAhPT10aGlzLmpzJHdyYXBwZWQubGVuZ3RoKXJldHVybiB0aGlzLnNxJGxlbmd0aD0oKT0+dGhpcy5qcyR3cmFwcGVkLmxlbmd0aH19LHRwJGNhbGw6e2NvbmZpZ3VyYWJsZTohMCxnZXQoKXtkZWxldGUgdGhpcy50cCRjYWxsO2lmKHRoaXMuaXMkY2FsbGFibGUpcmV0dXJuIHRoaXMudHAkY2FsbD10aGlzLmlzJHR5cGU/dGhpcy4kbmV3OnRoaXMuJGNhbGx9fSx0cCRuYW1lOntjb25maWd1cmFibGU6ITAsZ2V0KCl7ZGVsZXRlIHRoaXMudHAkbmFtZTtpZih0aGlzLmlzJGNhbGxhYmxlKXJldHVybiB0aGlzLnRwJG5hbWU9dGhpcy5pcyR0eXBlP1wicHJveHljbGFzc1wiOnRoaXMuJGJvdW5kP1wicHJveHltZXRob2RcIjpcInByb3h5ZnVuY3Rpb25cIjt7Y29uc3Qgdj10aGlzLmpzJHdyYXBwZWQ7bGV0IEI9dltTeW1ib2wudG9TdHJpbmdUYWddfHx0aGlzLiRuYW1lfHx2LmNvbnN0cnVjdG9yJiZ2LmNvbnN0cnVjdG9yLm5hbWV8fFxuXCJwcm94eW9iamVjdFwiO1wiT2JqZWN0XCI9PT1CP0I9XCJwcm94eW9iamVjdFwiOjI+PUIubGVuZ3RoJiYoQj1hKHYuY29uc3RydWN0b3IpLiRuYW1lKTtyZXR1cm4gdGhpcy50cCRuYW1lPUJ9fX0saXMkdHlwZTp7Y29uZmlndXJhYmxlOiEwLGdldCgpe2RlbGV0ZSB0aGlzLmlzJHR5cGU7dmFyIHY9dGhpcy5qcyR3cmFwcGVkO2NvbnN0IEI9di5wcm90b3R5cGU7aWYodm9pZCAwPT09QilyZXR1cm4gdGhpcy5pcyR0eXBlPXY9PT1Tay5nbG9iYWwuUHJveHk7e2NvbnN0IEk9dC5jYWxsKHYpLm1hdGNoKHIpO3Y9bnVsbD09PUk/bnVsbDpcImNsYXNzXCI9PT1JWzBdPyEwOiF4Lmhhcyh2KX1yZXR1cm4hMD09PXY/dGhpcy5pcyR0eXBlPSEwOiExPT09dj90aGlzLmlzJHR5cGU9ITE6MTxPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhCKS5sZW5ndGg/dGhpcy5pcyR0eXBlPSEwOnRoaXMuaXMkdHlwZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YoQikhPT1jfX19fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pLFxucj0vXmNsYXNzfF5mdW5jdGlvblthLXpBLVpcXGRcXChcXClcXHtcXHNdK1xcW25hdGl2ZSBjb2RlXFxdXFxzK1xcfSQvLHQ9bi50b1N0cmluZyx4PW5ldyBTZXQoW051bWJlcixTdHJpbmcsU3ltYm9sLEJvb2xlYW5dKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIFNrLmdsb2JhbC5CaWdJbnQmJnguYWRkKFNrLmdsb2JhbC5CaWdJbnQpfSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIoaCxwLGcpe2g9dm9pZCAwPT09aD9oOlNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGgpO3A9dm9pZCAwPT09cD9wOlNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KHApO2c9dm9pZCAwPT09Zz9nOlNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGcpO2lmKHZvaWQgMD09PXAmJnZvaWQgMD09PWcpcD1oLGg9MCxnPTE7ZWxzZSBpZih2b2lkIDA9PT1nKWc9MTtlbHNlIGlmKDA9PT1nKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJyYW5nZSgpIHN0ZXAgYXJndW1lbnQgbXVzdCBub3QgYmUgemVyb1wiKTtjb25zdCBhPVxuW107aWYoXCJudW1iZXJcIj09PXR5cGVvZiBoJiZcIm51bWJlclwiPT09dHlwZW9mIHAmJlwibnVtYmVyXCI9PT10eXBlb2YgZylpZigwPGcpZm9yKHZhciBjPWg7YzxwO2MrPWcpYS5wdXNoKG5ldyBTay5idWlsdGluLmludF8oYykpO2Vsc2UgZm9yKGM9aDtjPnA7Yys9ZylhLnB1c2gobmV3IFNrLmJ1aWx0aW4uaW50XyhjKSk7ZWxzZXtoPWM9SlNCSS5CaWdJbnQoaCk7Zz1KU0JJLkJpZ0ludChnKTtwPUpTQkkuQmlnSW50KHApO2lmKEpTQkkuZ3JlYXRlclRoYW4oZyxKU0JJLl9fWkVSTykpZm9yKDtKU0JJLmxlc3NUaGFuKGMscCk7KWEucHVzaChuZXcgU2suYnVpbHRpbi5pbnRfKGUoYykpKSxjPUpTQkkuYWRkKGMsZyk7ZWxzZSBmb3IoO0pTQkkuZ3JlYXRlclRoYW4oYyxwKTspYS5wdXNoKG5ldyBTay5idWlsdGluLmludF8oZShjKSkpLGM9SlNCSS5hZGQoYyxnKTtoPWUoaCk7Zz1lKGcpO3A9ZShwKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucmFuZ2VfKGgscCxnLGEpfWZ1bmN0aW9uIGUoaCl7cmV0dXJuIEpTQkkubGVzc1RoYW4oaCxcbkpTQkkuX19NQVhfU0FGRSkmJkpTQkkuZ3JlYXRlclRoYW4oaCxKU0JJLl9fTUlOX1NBRkUpP0pTQkkudG9OdW1iZXIoaCk6aH1Tay5idWlsdGluLnJhbmdlXz1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwicmFuZ2VcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oaCxwLGcsYSl7dGhpcy5zdGFydD1oO3RoaXMuc3RvcD1wO3RoaXMuc3RlcD1nO3RoaXMudj1hfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRkb2M6XCJyYW5nZShzdG9wKSAtPiByYW5nZSBvYmplY3RcXG5yYW5nZShzdGFydCwgc3RvcFssIHN0ZXBdKSAtPiByYW5nZSBvYmplY3RcXG5cXG5SZXR1cm4gYW4gb2JqZWN0IHRoYXQgcHJvZHVjZXMgYSBzZXF1ZW5jZSBvZiBpbnRlZ2VycyBmcm9tIHN0YXJ0IChpbmNsdXNpdmUpXFxudG8gc3RvcCAoZXhjbHVzaXZlKSBieSBzdGVwLiAgcmFuZ2UoaSwgaikgcHJvZHVjZXMgaSwgaSsxLCBpKzIsIC4uLiwgai0xLlxcbnN0YXJ0IGRlZmF1bHRzIHRvIDAsIGFuZCBzdG9wIGlzIG9taXR0ZWQhICByYW5nZSg0KSBwcm9kdWNlcyAwLCAxLCAyLCAzLlxcblRoZXNlIGFyZSBleGFjdGx5IHRoZSB2YWxpZCBpbmRpY2VzIGZvciBhIGxpc3Qgb2YgNCBlbGVtZW50cy5cXG5XaGVuIHN0ZXAgaXMgZ2l2ZW4sIGl0IHNwZWNpZmllcyB0aGUgaW5jcmVtZW50IChvciBkZWNyZW1lbnQpLlwiLFxudHAkbmV3KGgscCl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcInJhbmdlXCIscCk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwicmFuZ2VcIixoLDEsMyk7cmV0dXJuIGIoaFswXSxoWzFdLGhbMl0pfSwkcigpe2xldCBoPVwicmFuZ2UoXCIrdGhpcy5zdGFydCtcIiwgXCIrdGhpcy5zdG9wOzEhPXRoaXMuc3RlcCYmKGgrPVwiLCBcIit0aGlzLnN0ZXApO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoaCtcIilcIil9LHRwJHJpY2hjb21wYXJlKGgscCl7aWYoXCJFcVwiIT09cCYmXCJOb3RFcVwiIT09cHx8aC5vYiR0eXBlIT09U2suYnVpbHRpbi5yYW5nZV8pcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2g9bmV3IFNrLmJ1aWx0aW4ubGlzdChoLnYpO3JldHVybihuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMudikpLnRwJHJpY2hjb21wYXJlKGgscCl9LHRwJGl0ZXIoKXtyZXR1cm4gbmV3IGQodGhpcyl9LG5iJGJvb2woKXtyZXR1cm4gMCE9PXRoaXMudi5sZW5ndGh9LHNxJGNvbnRhaW5zKGgpe2NvbnN0IHA9XG50aGlzLnY7Zm9yKGxldCBnPTA7ZzxwLmxlbmd0aDtnKyspaWYoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGgscFtnXSxcIkVxXCIpKXJldHVybiEwO3JldHVybiExfSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy52Lmxlbmd0aH0sbXAkc3Vic2NyaXB0KGgpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoaCkpe2g9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGgpOzA+aCYmKGg9dGhpcy52Lmxlbmd0aCtoKTtpZigwPmh8fGg+PXRoaXMudi5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcInJhbmdlIG9iamVjdCBpbmRleCBvdXQgb2YgcmFuZ2VcIik7cmV0dXJuIHRoaXMudltoXX1pZihoLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5zbGljZSl7Y29uc3QgcD1bXSxnPXRoaXMudjtoLnNzc2l0ZXIkKGcubGVuZ3RoLG09PntwLnB1c2goZ1ttXSl9KTtsZXQge3N0YXJ0OmEsc3RvcDpjLHN0ZXA6bn09aC5zbGljZSRpbmRpY2VzKGcubGVuZ3RoKTthPVNrLm1pc2NldmFsLmFzSW5kZXgoZ1thXSl8fFxudGhpcy5zdGFydDtjPVNrLm1pc2NldmFsLmFzSW5kZXgoZ1tjXSl8fHRoaXMuc3RvcDtuPVwibnVtYmVyXCI9PT10eXBlb2YgdGhpcy5zdGVwP24qdGhpcy5zdGVwOkpTQkkubXVsdGlwbHkodGhpcy5zdGVwLEpTQkkuQmlnSW50KG4pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucmFuZ2VfKGEsYyxuLHApfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInJhbmdlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBzbGljZXMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShoKSk7fX0sZ2V0c2V0czp7c3RhcnQ6eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLnN0YXJ0KX19LHN0ZXA6eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLnN0ZXApfX0sc3RvcDp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuc3RvcCl9fX0sbWV0aG9kczp7X19yZXZlcnNlZF9fOnskbWV0aCgpe3JldHVybiBuZXcgZih0aGlzKX0sJGZsYWdzOntOb0FyZ3M6ITB9LFxuJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvci5cIn0sY291bnQ6eyRtZXRoKGgpe2xldCBwPTA7Zm9yKGxldCBnPTA7Zzx0aGlzLnYubGVuZ3RoO2crKylTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaCx0aGlzLnZbZ10sXCJFcVwiKSYmcCsrO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHApfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwicmFuZ2VvYmplY3QuY291bnQodmFsdWUpIC0+IGludGVnZXIgLS0gcmV0dXJuIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB2YWx1ZVwifSxpbmRleDp7JG1ldGgoaCl7Zm9yKGxldCBwPTA7cDx0aGlzLnYubGVuZ3RoO3ArKylpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woaCx0aGlzLnZbcF0sXCJFcVwiKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhwKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIoaCkrXCJpcyBub3QgaW4gcmFuZ2VcIik7XG59LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJyYW5nZW9iamVjdC5pbmRleCh2YWx1ZSwgW3N0YXJ0LCBbc3RvcF1dKSAtPiBpbnRlZ2VyIC0tIHJldHVybiBpbmRleCBvZiB2YWx1ZS5cXG5SYWlzZSBWYWx1ZUVycm9yIGlmIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudC5cIn19LHByb3RvOntzayRhc2FycmF5KCl7cmV0dXJuIHRoaXMudi5zbGljZSgwKX19LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pO3ZhciBkPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcInJhbmdlX2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGgpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWgudn0saXRlcm5leHQoKXtyZXR1cm4gdGhpcy4kc2VxW3RoaXMuJGluZGV4KytdfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sZmxhZ3M6e3NrJHVuYWNjZXB0YWJsZUJhc2U6ITB9fSksZj1cblNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcInJhbmdlX3JldmVyc2VpdGVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihoKXt0aGlzLiRzZXE9aC52O3RoaXMuJGluZGV4PXRoaXMuJHNlcS5sZW5ndGgtMX0saXRlcm5leHQoKXtyZXR1cm4gdGhpcy4kc2VxW3RoaXMuJGluZGV4LS1dfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyUmV2ZXJzZUxlbmd0aEhpbnRNZXRob2REZWZ9LGZsYWdzOntzayR1bmFjY2VwdGFibGVCYXNlOiEwfX0pO1NrLmJ1aWx0aW4ucmFuZ2U9U2suYnVpbHRpbi54cmFuZ2U9ZnVuY3Rpb24oaCxwLGcpe2g9YihoLHAsZyk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoaC52KX19LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5lbnVtZXJhdGU9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiZW51bWVyYXRlXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5lbnVtZXJhdGUpKXRocm93IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ2VudW1lcmF0ZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yXCIpO1xudGhpcy4kaXRlcmFibGU9Yjt0aGlzLiRpbmRleD1lO3JldHVybiB0aGlzfSxpdGVybmV4dChiKXtjb25zdCBlPVNrLm1pc2NldmFsLmNoYWluKHRoaXMuJGl0ZXJhYmxlLnRwJGl0ZXJuZXh0KGIpLGQ9PntpZih2b2lkIDAhPT1kKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpbmRleCsrKSxkXSl9KTtyZXR1cm4gYj9lOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhlKX0sc2xvdHM6e3RwJGRvYzpcIlJldHVybiBhbiBlbnVtZXJhdGUgb2JqZWN0LlxcblxcbiAgaXRlcmFibGVcXG4gICAgYW4gb2JqZWN0IHN1cHBvcnRpbmcgaXRlcmF0aW9uXFxuXFxuVGhlIGVudW1lcmF0ZSBvYmplY3QgeWllbGRzIHBhaXJzIGNvbnRhaW5pbmcgYSBjb3VudCAoZnJvbSBzdGFydCwgd2hpY2hcXG5kZWZhdWx0cyB0byB6ZXJvKSBhbmQgYSB2YWx1ZSB5aWVsZGVkIGJ5IHRoZSBpdGVyYWJsZSBhcmd1bWVudC5cXG5cXG5lbnVtZXJhdGUgaXMgdXNlZnVsIGZvciBvYnRhaW5pbmcgYW4gaW5kZXhlZCBsaXN0OlxcbiAgICAoMCwgc2VxWzBdKSwgKDEsIHNlcVsxXSksICgyLCBzZXFbMl0pLCAuLi5cIixcbnRwJG5ldyhiLGUpe2xldCBbZCxmXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcImVudW1lcmF0ZVwiLFtcIml0ZXJhYmxlXCIsXCJzdGFydFwiXSxiLGUsW25ldyBTay5idWlsdGluLmludF8oMCldKTtkPVNrLmFic3RyLml0ZXIoZCk7Zj1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhmKTtpZih0aGlzPT09U2suYnVpbHRpbi5lbnVtZXJhdGUucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi5lbnVtZXJhdGUoZCxmKTtiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO1NrLmJ1aWx0aW4uZW51bWVyYXRlLmNhbGwoYixkLGYpO3JldHVybiBifX0sY2xhc3NtZXRob2RzOlNrLmdlbmVyaWMuY2xhc3NHZXRJdGVtfSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5lbnVtZXJhdGVcIixTay5idWlsdGluLmVudW1lcmF0ZSl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5maWx0ZXJfPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImZpbHRlclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihiLFxuZSl7dGhpcy4kZnVuYz1iO3RoaXMuJGl0ZXJhYmxlPWV9LGl0ZXJuZXh0KGIpe2NvbnN0IGU9U2subWlzY2V2YWwuaXRlckZvcih0aGlzLiRpdGVyYWJsZSxkPT5Tay5taXNjZXZhbC5jaGFpbih0aGlzLmNoZWNrJGZpbHRlcihkKSxmPT5mP25ldyBTay5taXNjZXZhbC5CcmVhayhmKTp2b2lkIDApKTtyZXR1cm4gYj9lOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhlKX0sc2xvdHM6e3RwJGRvYzpcIlJldHVybiBhbiBpdGVyYXRvciB5aWVsZGluZyB0aG9zZSBpdGVtcyBvZiBpdGVyYWJsZSBmb3Igd2hpY2ggZnVuY3Rpb24oaXRlbSlcXG5pcyB0cnVlLiBJZiBmdW5jdGlvbiBpcyBOb25lLCByZXR1cm4gdGhlIGl0ZW1zIHRoYXQgYXJlIHRydWUuXCIsdHAkbmV3KGIsZSl7bGV0IFtkLGZdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiZmlsdGVyXCIsW1wicHJlZGljYXRlXCIsXCJpdGVyYWJsZVwiXSxiLGUsW10pO2Q9U2suYnVpbHRpbi5jaGVja05vbmUoZCk/XG5udWxsOmQ7Zj1Tay5hYnN0ci5pdGVyKGYpO2lmKHRoaXM9PT1Tay5idWlsdGluLmZpbHRlcl8ucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi5maWx0ZXJfKGQsZik7Yj1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtTay5idWlsdGluLmZpbHRlcl8uY2FsbChiLGQsZik7cmV0dXJuIGJ9fSxwcm90bzp7Y2hlY2skZmlsdGVyKGIpe2xldCBlO2U9bnVsbD09PXRoaXMuJGZ1bmM/YjpTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkodGhpcy4kZnVuYyxbYl0pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihlLGQ9PlNrLm1pc2NldmFsLmlzVHJ1ZShkKT9iOnZvaWQgMCl9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uZmlsdGVyX1wiLFNrLmJ1aWx0aW4uZmlsdGVyXyl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5tYXBfPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcIm1hcFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihiLGUpe3RoaXMuJGZ1bmM9Yjt0aGlzLiRpdGVycz1cbmV9LGl0ZXJuZXh0KGIpe2NvbnN0IGU9W10sZD1Tay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyQXJyYXkodGhpcy4kaXRlcnMsZj0+U2subWlzY2V2YWwuY2hhaW4oZi50cCRpdGVybmV4dChiKSxoPT57aWYodm9pZCAwPT09aClyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrKCEwKTtlLnB1c2goaCl9KSksZj0+Zj92b2lkIDA6U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHRoaXMuJGZ1bmMsZSkpO3JldHVybiBiP2Q6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGQpfSxzbG90czp7dHAkZG9jOlwibWFwKGZ1bmMsICppdGVyYWJsZXMpIC0tXFx4M2UgbWFwIG9iamVjdFxcblxcbk1ha2UgYW4gaXRlcmF0b3IgdGhhdCBjb21wdXRlcyB0aGUgZnVuY3Rpb24gdXNpbmcgYXJndW1lbnRzIGZyb21cXG5lYWNoIG9mIHRoZSBpdGVyYWJsZXMuICBTdG9wcyB3aGVuIHRoZSBzaG9ydGVzdCBpdGVyYWJsZSBpcyBleGhhdXN0ZWQuXCIsdHAkbmV3KGIsXG5lKXt0aGlzPT09U2suYnVpbHRpbi5tYXBfLnByb3RvdHlwZSYmU2suYWJzdHIuY2hlY2tOb0t3YXJncyhcIm1hcFwiLGUpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcIm1hcFwiLGIsMik7ZT1iWzBdO2NvbnN0IGQ9W107Zm9yKGxldCBmPTE7ZjxiLmxlbmd0aDtmKyspZC5wdXNoKFNrLmFic3RyLml0ZXIoYltmXSkpO2lmKHRoaXM9PT1Tay5idWlsdGluLm1hcF8ucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi5tYXBfKGUsZCk7Yj1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtTay5idWlsdGluLm1hcF8uY2FsbChiLGUsZCk7cmV0dXJuIGJ9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ubWFwX1wiLFNrLmJ1aWx0aW4ubWFwXyl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5yZXZlcnNlZD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJyZXZlcnNlZFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihiKXt0aGlzLiRpZHg9Yi5zcSRsZW5ndGgoKS0xO3RoaXMuJHNlcT1iO3JldHVybiB0aGlzfSxcbml0ZXJuZXh0KGIpe2lmKCEoMD50aGlzLiRpZHgpKXt2YXIgZT1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+U2suYWJzdHIub2JqZWN0R2V0SXRlbSh0aGlzLiRzZXEsbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpZHgtLSksYiksZD0+e2lmKGQgaW5zdGFuY2VvZiBTay5idWlsdGluLkluZGV4RXJyb3IpdGhpcy4kaWR4PS0xO2Vsc2UgdGhyb3cgZDt9KTtyZXR1cm4gYj9lOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhlKX19LHNsb3RzOnt0cCRkb2M6XCJSZXR1cm4gYSByZXZlcnNlIGl0ZXJhdG9yIG92ZXIgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc2VxdWVuY2UuXCIsdHAkbmV3KGIsZSl7dGhpcz09PVNrLmJ1aWx0aW4ucmV2ZXJzZWQucHJvdG90eXBlJiZTay5hYnN0ci5jaGVja05vS3dhcmdzKFwicmV2ZXJzZWRcIixlKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJyZXZlcnNlZFwiLGIsMSwxKTtiPWJbMF07ZT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsXG5Tay5idWlsdGluLnN0ci4kcmV2ZXJzZWQpO2lmKHZvaWQgMCE9PWUpcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLFtdKTtpZighU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGIpfHx2b2lkIDA9PT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsU2suYnVpbHRpbi5zdHIuJGxlbikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGIpK1wiJyBvYmplY3QgaXMgbm90IGEgc2VxdWVuY2VcIik7aWYodGhpcz09PVNrLmJ1aWx0aW4ucmV2ZXJzZWQucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi5yZXZlcnNlZChiKTtlPW5ldyB0aGlzLmNvbnN0cnVjdG9yO1NrLmJ1aWx0aW4ucmV2ZXJzZWQuY2FsbChlLGIpO3JldHVybiBlfX0sbWV0aG9kczp7X19sZW5ndGhfaGludF9fOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiAwPD10aGlzLiRpZHg/bmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpZHgpOm5ldyBTay5idWlsdGluLmludF8oMCl9LFxuJGZsYWdzOntOb0FyZ3M6ITB9fX19KX0sZnVuY3Rpb24oRixQKXtTay5idWlsdGluLnppcF89U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiemlwXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIpe3RoaXMuJGl0ZXJzPWI7MD09PWIubGVuZ3RoJiYodGhpcy50cCRpdGVybmV4dD0oKT0+e30pfSxpdGVybmV4dChiKXtjb25zdCBlPVtdLGQ9U2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckFycmF5KHRoaXMuJGl0ZXJzLGY9PlNrLm1pc2NldmFsLmNoYWluKGYudHAkaXRlcm5leHQoYiksaD0+e2lmKHZvaWQgMD09PWgpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayghMCk7ZS5wdXNoKGgpfSkpLGY9PmY/dm9pZCAwOm5ldyBTay5idWlsdGluLnR1cGxlKGUpKTtyZXR1cm4gYj9kOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhkKX0sc2xvdHM6e3RwJGRvYzpcInppcChpdGVyMSBbLGl0ZXIyIFsuLi5dXSkgLS1cXHgzZSB6aXAgb2JqZWN0XFxuXFxuUmV0dXJuIGEgemlwIG9iamVjdCB3aG9zZSAuX19uZXh0X18oKSBtZXRob2QgcmV0dXJucyBhIHR1cGxlIHdoZXJlXFxudGhlIGktdGggZWxlbWVudCBjb21lcyBmcm9tIHRoZSBpLXRoIGl0ZXJhYmxlIGFyZ3VtZW50LiAgVGhlIC5fX25leHRfXygpXFxubWV0aG9kIGNvbnRpbnVlcyB1bnRpbCB0aGUgc2hvcnRlc3QgaXRlcmFibGUgaW4gdGhlIGFyZ3VtZW50IHNlcXVlbmNlXFxuaXMgZXhoYXVzdGVkIGFuZCB0aGVuIGl0IHJhaXNlcyBTdG9wSXRlcmF0aW9uLlwiLFxudHAkbmV3KGIsZSl7dGhpcz09PVNrLmJ1aWx0aW4uemlwXy5wcm90b3R5cGUmJlNrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJ6aXBcIixlKTtlPVtdO2ZvcihsZXQgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXRyeXtlLnB1c2goU2suYWJzdHIuaXRlcihiW2RdKSl9Y2F0Y2goZil7aWYoZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uVHlwZUVycm9yKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInppcCBhcmd1bWVudCAjXCIrKGQrMSkrXCIgbXVzdCBzdXBwb3J0IGl0ZXJhdGlvblwiKTt0aHJvdyBmO31pZih0aGlzPT09U2suYnVpbHRpbi56aXBfLnByb3RvdHlwZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uemlwXyhlKTtiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO1NrLmJ1aWx0aW4uemlwXy5jYWxsKGIsZSk7cmV0dXJuIGJ9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uemlwX1wiLFNrLmJ1aWx0aW4uemlwXyl9LGZ1bmN0aW9uKEYsUCl7dmFyIGI9e1RfRU5ETUFSS0VSOjAsVF9OQU1FOjEsXG5UX05VTUJFUjoyLFRfU1RSSU5HOjMsVF9ORVdMSU5FOjQsVF9JTkRFTlQ6NSxUX0RFREVOVDo2LFRfTFBBUjo3LFRfUlBBUjo4LFRfTFNRQjo5LFRfUlNRQjoxMCxUX0NPTE9OOjExLFRfQ09NTUE6MTIsVF9TRU1JOjEzLFRfUExVUzoxNCxUX01JTlVTOjE1LFRfU1RBUjoxNixUX1NMQVNIOjE3LFRfVkJBUjoxOCxUX0FNUEVSOjE5LFRfTEVTUzoyMCxUX0dSRUFURVI6MjEsVF9FUVVBTDoyMixUX0RPVDoyMyxUX1BFUkNFTlQ6MjQsVF9MQlJBQ0U6MjUsVF9SQlJBQ0U6MjYsVF9FUUVRVUFMOjI3LFRfTk9URVFVQUw6MjgsVF9MRVNTRVFVQUw6MjksVF9HUkVBVEVSRVFVQUw6MzAsVF9USUxERTozMSxUX0NJUkNVTUZMRVg6MzIsVF9MRUZUU0hJRlQ6MzMsVF9SSUdIVFNISUZUOjM0LFRfRE9VQkxFU1RBUjozNSxUX1BMVVNFUVVBTDozNixUX01JTkVRVUFMOjM3LFRfU1RBUkVRVUFMOjM4LFRfU0xBU0hFUVVBTDozOSxUX1BFUkNFTlRFUVVBTDo0MCxUX0FNUEVSRVFVQUw6NDEsVF9WQkFSRVFVQUw6NDIsXG5UX0NJUkNVTUZMRVhFUVVBTDo0MyxUX0xFRlRTSElGVEVRVUFMOjQ0LFRfUklHSFRTSElGVEVRVUFMOjQ1LFRfRE9VQkxFU1RBUkVRVUFMOjQ2LFRfRE9VQkxFU0xBU0g6NDcsVF9ET1VCTEVTTEFTSEVRVUFMOjQ4LFRfQVQ6NDksVF9BVEVRVUFMOjUwLFRfUkFSUk9XOjUxLFRfRUxMSVBTSVM6NTIsVF9PUDo1MyxUX0FXQUlUOjU0LFRfQVNZTkM6NTUsVF9FUlJPUlRPS0VOOjU2LFRfTlRfT0ZGU0VUOjI1NixUX05fVE9LRU5TOjYwLFRfQ09NTUVOVDo1NyxUX05MOjU4LFRfRU5DT0RJTkc6NTl9O0Y9e1wiIT1cIjpiLlRfTk9URVFVQUwsXCIlXCI6Yi5UX1BFUkNFTlQsXCIlPVwiOmIuVF9QRVJDRU5URVFVQUwsXCImXCI6Yi5UX0FNUEVSLFwiJj1cIjpiLlRfQU1QRVJFUVVBTCxcIihcIjpiLlRfTFBBUixcIilcIjpiLlRfUlBBUixcIipcIjpiLlRfU1RBUixcIioqXCI6Yi5UX0RPVUJMRVNUQVIsXCIqKj1cIjpiLlRfRE9VQkxFU1RBUkVRVUFMLFwiKj1cIjpiLlRfU1RBUkVRVUFMLFwiK1wiOmIuVF9QTFVTLFwiKz1cIjpiLlRfUExVU0VRVUFMLFxuXCIsXCI6Yi5UX0NPTU1BLFwiLVwiOmIuVF9NSU5VUyxcIi09XCI6Yi5UX01JTkVRVUFMLFwiLT5cIjpiLlRfUkFSUk9XLFwiLlwiOmIuVF9ET1QsXCIuLi5cIjpiLlRfRUxMSVBTSVMsXCIvXCI6Yi5UX1NMQVNILFwiLy9cIjpiLlRfRE9VQkxFU0xBU0gsXCIvLz1cIjpiLlRfRE9VQkxFU0xBU0hFUVVBTCxcIi89XCI6Yi5UX1NMQVNIRVFVQUwsXCI6XCI6Yi5UX0NPTE9OLFwiO1wiOmIuVF9TRU1JLFwiPFwiOmIuVF9MRVNTLFwiPDxcIjpiLlRfTEVGVFNISUZULFwiPDw9XCI6Yi5UX0xFRlRTSElGVEVRVUFMLFwiPD1cIjpiLlRfTEVTU0VRVUFMLFwiPVwiOmIuVF9FUVVBTCxcIj09XCI6Yi5UX0VRRVFVQUwsXCI+XCI6Yi5UX0dSRUFURVIsXCI+PVwiOmIuVF9HUkVBVEVSRVFVQUwsXCI+PlwiOmIuVF9SSUdIVFNISUZULFwiPj49XCI6Yi5UX1JJR0hUU0hJRlRFUVVBTCxcIkBcIjpiLlRfQVQsXCJAPVwiOmIuVF9BVEVRVUFMLFwiW1wiOmIuVF9MU1FCLFwiXVwiOmIuVF9SU1FCLFwiXlwiOmIuVF9DSVJDVU1GTEVYLFwiXj1cIjpiLlRfQ0lSQ1VNRkxFWEVRVUFMLFwie1wiOmIuVF9MQlJBQ0UsXG5cInxcIjpiLlRfVkJBUixcInw9XCI6Yi5UX1ZCQVJFUVVBTCxcIn1cIjpiLlRfUkJSQUNFLFwiflwiOmIuVF9USUxERX07dmFyIGU9e307KGZ1bmN0aW9uKCl7Zm9yKHZhciBkIGluIGIpZVtiW2RdXT1kfSkoKTtbXCJ0b2tfbmFtZVwiLFwiSVNURVJNSU5BTFwiLFwiSVNOT05URVJNSU5BTFwiLFwiSVNFT0ZcIl0uY29uY2F0KE9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbihkKXtyZXR1cm4gZVtkXX0pKTtTay50b2tlbj17fTtTay50b2tlbi50b2tlbnM9YjtTay50b2tlbi50b2tfbmFtZT1lO1NrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTPUY7U2sudG9rZW4uSVNURVJNSU5BTD1mdW5jdGlvbihkKXtyZXR1cm4gZDxiLlRfTlRfT0ZGU0VUfTtTay50b2tlbi5JU05PTlRFUk1JTkFMPWZ1bmN0aW9uKGQpe3JldHVybiBkPj1iLlRfTlRfT0ZGU0VUfTtTay50b2tlbi5JU0VPRj1mdW5jdGlvbihkKXtyZXR1cm4gZD09Yi5UX0VORE1BUktFUn07U2suZXhwb3J0U3ltYm9sKFwiU2sudG9rZW5cIixTay50b2tlbik7U2suZXhwb3J0U3ltYm9sKFwiU2sudG9rZW4udG9rZW5zXCIsXG5Tay50b2tlbi50b2tlbnMpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLnRva19uYW1lXCIsU2sudG9rZW4udG9rX25hbWUpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTXCIpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLklTVEVSTUlOQUxcIixTay50b2tlbi5JU1RFUk1JTkFMKTtTay5leHBvcnRTeW1ib2woXCJTay50b2tlbi5JU05PTlRFUk1JTkFMXCIsU2sudG9rZW4uSVNOT05URVJNSU5BTCk7U2suZXhwb3J0U3ltYm9sKFwiU2sudG9rZW4uSVNFT0ZcIixTay50b2tlbi5JU0VPRil9LGZ1bmN0aW9uKEYsUCl7U2suT3BNYXA9e1wiKFwiOlNrLnRva2VuLnRva2Vucy5UX0xQQVIsXCIpXCI6U2sudG9rZW4udG9rZW5zLlRfUlBBUixcIltcIjpTay50b2tlbi50b2tlbnMuVF9MU1FCLFwiXVwiOlNrLnRva2VuLnRva2Vucy5UX1JTUUIsXCI6XCI6U2sudG9rZW4udG9rZW5zLlRfQ09MT04sXCIsXCI6U2sudG9rZW4udG9rZW5zLlRfQ09NTUEsXCI7XCI6U2sudG9rZW4udG9rZW5zLlRfU0VNSSxcblwiK1wiOlNrLnRva2VuLnRva2Vucy5UX1BMVVMsXCItXCI6U2sudG9rZW4udG9rZW5zLlRfTUlOVVMsXCIqXCI6U2sudG9rZW4udG9rZW5zLlRfU1RBUixcIi9cIjpTay50b2tlbi50b2tlbnMuVF9TTEFTSCxcInxcIjpTay50b2tlbi50b2tlbnMuVF9WQkFSLFwiJlwiOlNrLnRva2VuLnRva2Vucy5UX0FNUEVSLFwiPFwiOlNrLnRva2VuLnRva2Vucy5UX0xFU1MsXCI+XCI6U2sudG9rZW4udG9rZW5zLlRfR1JFQVRFUixcIj1cIjpTay50b2tlbi50b2tlbnMuVF9FUVVBTCxcIi5cIjpTay50b2tlbi50b2tlbnMuVF9ET1QsXCIlXCI6U2sudG9rZW4udG9rZW5zLlRfUEVSQ0VOVCxcImBcIjpTay50b2tlbi50b2tlbnMuVF9CQUNLUVVPVEUsXCJ7XCI6U2sudG9rZW4udG9rZW5zLlRfTEJSQUNFLFwifVwiOlNrLnRva2VuLnRva2Vucy5UX1JCUkFDRSxcIkBcIjpTay50b2tlbi50b2tlbnMuVF9BVCxcIkA9XCI6U2sudG9rZW4udG9rZW5zLlRfQVRFUVVBTCxcIj09XCI6U2sudG9rZW4udG9rZW5zLlRfRVFFUVVBTCxcIiE9XCI6U2sudG9rZW4udG9rZW5zLlRfTk9URVFVQUwsXG5cIjw+XCI6U2sudG9rZW4udG9rZW5zLlRfTk9URVFVQUwsXCI8PVwiOlNrLnRva2VuLnRva2Vucy5UX0xFU1NFUVVBTCxcIj49XCI6U2sudG9rZW4udG9rZW5zLlRfR1JFQVRFUkVRVUFMLFwiflwiOlNrLnRva2VuLnRva2Vucy5UX1RJTERFLFwiXlwiOlNrLnRva2VuLnRva2Vucy5UX0NJUkNVTUZMRVgsXCI8PFwiOlNrLnRva2VuLnRva2Vucy5UX0xFRlRTSElGVCxcIj4+XCI6U2sudG9rZW4udG9rZW5zLlRfUklHSFRTSElGVCxcIioqXCI6U2sudG9rZW4udG9rZW5zLlRfRE9VQkxFU1RBUixcIis9XCI6U2sudG9rZW4udG9rZW5zLlRfUExVU0VRVUFMLFwiLT1cIjpTay50b2tlbi50b2tlbnMuVF9NSU5FUVVBTCxcIio9XCI6U2sudG9rZW4udG9rZW5zLlRfU1RBUkVRVUFMLFwiLz1cIjpTay50b2tlbi50b2tlbnMuVF9TTEFTSEVRVUFMLFwiJT1cIjpTay50b2tlbi50b2tlbnMuVF9QRVJDRU5URVFVQUwsXCImPVwiOlNrLnRva2VuLnRva2Vucy5UX0FNUEVSRVFVQUwsXCJ8PVwiOlNrLnRva2VuLnRva2Vucy5UX1ZCQVJFUVVBTCxcIl49XCI6U2sudG9rZW4udG9rZW5zLlRfQ0lSQ1VNRkxFWEVRVUFMLFxuXCI8PD1cIjpTay50b2tlbi50b2tlbnMuVF9MRUZUU0hJRlRFUVVBTCxcIj4+PVwiOlNrLnRva2VuLnRva2Vucy5UX1JJR0hUU0hJRlRFUVVBTCxcIioqPVwiOlNrLnRva2VuLnRva2Vucy5UX0RPVUJMRVNUQVJFUVVBTCxcIi8vXCI6U2sudG9rZW4udG9rZW5zLlRfRE9VQkxFU0xBU0gsXCIvLz1cIjpTay50b2tlbi50b2tlbnMuVF9ET1VCTEVTTEFTSEVRVUFMLFwiLT5cIjpTay50b2tlbi50b2tlbnMuVF9SQVJST1csXCIuLi5cIjpTay50b2tlbi50b2tlbnMuVF9FTExJUFNJU307U2suUGFyc2VUYWJsZXM9e3N5bTp7YW5kX2V4cHI6MjU3LGFuZF90ZXN0OjI1OCxhbm5hc3NpZ246MjU5LGFyZ2xpc3Q6MjYwLGFyZ3VtZW50OjI2MSxhcml0aF9leHByOjI2Mixhc3NlcnRfc3RtdDoyNjMsYXN5bmNfZnVuY2RlZjoyNjQsYXN5bmNfc3RtdDoyNjUsYXRvbToyNjYsYXRvbV9leHByOjI2NyxhdWdhc3NpZ246MjY4LGJyZWFrX3N0bXQ6MjY5LGNsYXNzZGVmOjI3MCxjb21wX2ZvcjoyNzEsY29tcF9pZjoyNzIsY29tcF9pdGVyOjI3MyxcbmNvbXBfb3A6Mjc0LGNvbXBhcmlzb246Mjc1LGNvbXBvdW5kX3N0bXQ6Mjc2LGNvbnRpbnVlX3N0bXQ6Mjc3LGRlYnVnZ2VyX3N0bXQ6Mjc4LGRlY29yYXRlZDoyNzksZGVjb3JhdG9yOjI4MCxkZWNvcmF0b3JzOjI4MSxkZWxfc3RtdDoyODIsZGljdG9yc2V0bWFrZXI6MjgzLGRvdHRlZF9hc19uYW1lOjI4NCxkb3R0ZWRfYXNfbmFtZXM6Mjg1LGRvdHRlZF9uYW1lOjI4NixlbmNvZGluZ19kZWNsOjI4NyxldmFsX2lucHV0OjI4OCxleGNlcHRfY2xhdXNlOjI4OSxleHByOjI5MCxleHByX3N0bXQ6MjkxLGV4cHJsaXN0OjI5MixmYWN0b3I6MjkzLGZpbGVfaW5wdXQ6Mjk0LGZsb3dfc3RtdDoyOTUsZm9yX3N0bXQ6Mjk2LGZ1bmNkZWY6Mjk3LGdsb2JhbF9zdG10OjI5OCxpZl9zdG10OjI5OSxpbXBvcnRfYXNfbmFtZTozMDAsaW1wb3J0X2FzX25hbWVzOjMwMSxpbXBvcnRfZnJvbTozMDIsaW1wb3J0X25hbWU6MzAzLGltcG9ydF9zdG10OjMwNCxsYW1iZGVmOjMwNSxsYW1iZGVmX25vY29uZDozMDYsXG5ub25sb2NhbF9zdG10OjMwNyxub3RfdGVzdDozMDgsb3JfdGVzdDozMDkscGFyYW1ldGVyczozMTAscGFzc19zdG10OjMxMSxwb3dlcjozMTIscHJpbnRfc3RtdDozMTMscmFpc2Vfc3RtdDozMTQscmV0dXJuX3N0bXQ6MzE1LHNoaWZ0X2V4cHI6MzE2LHNpbXBsZV9zdG10OjMxNyxzaW5nbGVfaW5wdXQ6MjU2LHNsaWNlb3A6MzE4LHNtYWxsX3N0bXQ6MzE5LHN0YXJfZXhwcjozMjAsc3RtdDozMjEsc3Vic2NyaXB0OjMyMixzdWJzY3JpcHRsaXN0OjMyMyxzdWl0ZTozMjQsdGVybTozMjUsdGVzdDozMjYsdGVzdF9ub2NvbmQ6MzI3LHRlc3RsaXN0OjMyOCx0ZXN0bGlzdF9jb21wOjMyOSx0ZXN0bGlzdF9zdGFyX2V4cHI6MzMwLHRmcGRlZjozMzEsdHJhaWxlcjozMzIsdHJ5X3N0bXQ6MzMzLHR5cGVkYXJnc2xpc3Q6MzM0LHZhcmFyZ3NsaXN0OjMzNSx2ZnBkZWY6MzM2LHdoaWxlX3N0bXQ6MzM3LHdpdGhfaXRlbTozMzgsd2l0aF9zdG10OjMzOSx4b3JfZXhwcjozNDAseWllbGRfYXJnOjM0MSxcbnlpZWxkX2V4cHI6MzQyLHlpZWxkX3N0bXQ6MzQzfSxudW1iZXIyc3ltYm9sOnsyNTY6XCJzaW5nbGVfaW5wdXRcIiwyNTc6XCJhbmRfZXhwclwiLDI1ODpcImFuZF90ZXN0XCIsMjU5OlwiYW5uYXNzaWduXCIsMjYwOlwiYXJnbGlzdFwiLDI2MTpcImFyZ3VtZW50XCIsMjYyOlwiYXJpdGhfZXhwclwiLDI2MzpcImFzc2VydF9zdG10XCIsMjY0OlwiYXN5bmNfZnVuY2RlZlwiLDI2NTpcImFzeW5jX3N0bXRcIiwyNjY6XCJhdG9tXCIsMjY3OlwiYXRvbV9leHByXCIsMjY4OlwiYXVnYXNzaWduXCIsMjY5OlwiYnJlYWtfc3RtdFwiLDI3MDpcImNsYXNzZGVmXCIsMjcxOlwiY29tcF9mb3JcIiwyNzI6XCJjb21wX2lmXCIsMjczOlwiY29tcF9pdGVyXCIsMjc0OlwiY29tcF9vcFwiLDI3NTpcImNvbXBhcmlzb25cIiwyNzY6XCJjb21wb3VuZF9zdG10XCIsMjc3OlwiY29udGludWVfc3RtdFwiLDI3ODpcImRlYnVnZ2VyX3N0bXRcIiwyNzk6XCJkZWNvcmF0ZWRcIiwyODA6XCJkZWNvcmF0b3JcIiwyODE6XCJkZWNvcmF0b3JzXCIsMjgyOlwiZGVsX3N0bXRcIiwyODM6XCJkaWN0b3JzZXRtYWtlclwiLFxuMjg0OlwiZG90dGVkX2FzX25hbWVcIiwyODU6XCJkb3R0ZWRfYXNfbmFtZXNcIiwyODY6XCJkb3R0ZWRfbmFtZVwiLDI4NzpcImVuY29kaW5nX2RlY2xcIiwyODg6XCJldmFsX2lucHV0XCIsMjg5OlwiZXhjZXB0X2NsYXVzZVwiLDI5MDpcImV4cHJcIiwyOTE6XCJleHByX3N0bXRcIiwyOTI6XCJleHBybGlzdFwiLDI5MzpcImZhY3RvclwiLDI5NDpcImZpbGVfaW5wdXRcIiwyOTU6XCJmbG93X3N0bXRcIiwyOTY6XCJmb3Jfc3RtdFwiLDI5NzpcImZ1bmNkZWZcIiwyOTg6XCJnbG9iYWxfc3RtdFwiLDI5OTpcImlmX3N0bXRcIiwzMDA6XCJpbXBvcnRfYXNfbmFtZVwiLDMwMTpcImltcG9ydF9hc19uYW1lc1wiLDMwMjpcImltcG9ydF9mcm9tXCIsMzAzOlwiaW1wb3J0X25hbWVcIiwzMDQ6XCJpbXBvcnRfc3RtdFwiLDMwNTpcImxhbWJkZWZcIiwzMDY6XCJsYW1iZGVmX25vY29uZFwiLDMwNzpcIm5vbmxvY2FsX3N0bXRcIiwzMDg6XCJub3RfdGVzdFwiLDMwOTpcIm9yX3Rlc3RcIiwzMTA6XCJwYXJhbWV0ZXJzXCIsMzExOlwicGFzc19zdG10XCIsMzEyOlwicG93ZXJcIiwzMTM6XCJwcmludF9zdG10XCIsXG4zMTQ6XCJyYWlzZV9zdG10XCIsMzE1OlwicmV0dXJuX3N0bXRcIiwzMTY6XCJzaGlmdF9leHByXCIsMzE3Olwic2ltcGxlX3N0bXRcIiwzMTg6XCJzbGljZW9wXCIsMzE5Olwic21hbGxfc3RtdFwiLDMyMDpcInN0YXJfZXhwclwiLDMyMTpcInN0bXRcIiwzMjI6XCJzdWJzY3JpcHRcIiwzMjM6XCJzdWJzY3JpcHRsaXN0XCIsMzI0Olwic3VpdGVcIiwzMjU6XCJ0ZXJtXCIsMzI2OlwidGVzdFwiLDMyNzpcInRlc3Rfbm9jb25kXCIsMzI4OlwidGVzdGxpc3RcIiwzMjk6XCJ0ZXN0bGlzdF9jb21wXCIsMzMwOlwidGVzdGxpc3Rfc3Rhcl9leHByXCIsMzMxOlwidGZwZGVmXCIsMzMyOlwidHJhaWxlclwiLDMzMzpcInRyeV9zdG10XCIsMzM0OlwidHlwZWRhcmdzbGlzdFwiLDMzNTpcInZhcmFyZ3NsaXN0XCIsMzM2OlwidmZwZGVmXCIsMzM3Olwid2hpbGVfc3RtdFwiLDMzODpcIndpdGhfaXRlbVwiLDMzOTpcIndpdGhfc3RtdFwiLDM0MDpcInhvcl9leHByXCIsMzQxOlwieWllbGRfYXJnXCIsMzQyOlwieWllbGRfZXhwclwiLDM0MzpcInlpZWxkX3N0bXRcIn0sZGZhczp7MjU2OltbW1sxLDFdLFxuWzIsMV0sWzMsMl1dLFtbMCwxXV0sW1syLDFdXV0sezI6MSw0OjEsNToxLDY6MSw3OjEsODoxLDk6MSwxMDoxLDExOjEsMTI6MSwxMzoxLDE0OjEsMTU6MSwxNjoxLDE3OjEsMTg6MSwxOToxLDIwOjEsMjE6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNDoxLDM1OjEsMzY6MSwzNzoxLDM4OjEsMzk6MSw0MDoxLDQxOjEsNDI6MSw0MzoxfV0sMjU3OltbW1s0NCwxXV0sW1s0NSwwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyNTg6W1tbWzQ2LDFdXSxbWzQ3LDBdLFswLDFdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyNTk6W1tbWzQ4LDFdXSxbWzQ5LDJdXSxbWzUwLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzAsNF1dXSx7NDg6MX1dLFxuMjYwOltbW1s1MSwxXV0sW1s1MiwyXSxbMCwxXV0sW1s1MSwxXSxbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTU6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MSw1MzoxfV0sMjYxOltbW1s0OSwxXSxbMTUsMl0sWzUzLDJdXSxbWzUwLDJdLFs1NCwzXSxbMCwxXV0sW1s0OSwzXV0sW1swLDNdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxLDUzOjF9XSwyNjI6W1tbWzU1LDFdXSxbWzMwLDBdLFs0MywwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyNjM6W1tbWzI0LDFdXSxbWzQ5LDJdXSxbWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzAsNF1dXSx7MjQ6MX1dLDI2NDpbW1tbMTAsMV1dLFtbNTYsMl1dLFtbMCwyXV1dLHsxMDoxfV0sXG4yNjU6W1tbWzEwLDFdXSxbWzU3LDJdLFs1NiwyXSxbNTgsMl1dLFtbMCwyXV1dLHsxMDoxfV0sMjY2OltbW1s2LDFdLFsyNSwxXSxbMzMsMV0sWzksMV0sWzExLDFdLFsxMiwyXSxbMzUsM10sWzM4LDRdLFsxOSwxXSxbNyw1XV0sW1swLDFdXSxbWzU5LDFdLFs2MCw2XV0sW1s2MSwxXSxbNjIsN10sWzYzLDddXSxbWzY0LDFdLFs2Myw4XV0sW1s3LDVdLFswLDVdXSxbWzU5LDFdXSxbWzYxLDFdXSxbWzY0LDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDI1OjEsMzM6MSwzNToxLDM4OjF9XSwyNjc6W1tbWzI5LDFdLFs2NSwyXV0sW1s2NSwyXV0sW1s2NiwyXSxbMCwyXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyNToxLDI5OjEsMzM6MSwzNToxLDM4OjF9XSwyNjg6W1tbWzY3LDFdLFs2OCwxXSxbNjksMV0sWzcwLDFdLFs3MSwxXSxbNzIsMV0sWzczLDFdLFs3NCwxXSxbNzUsMV0sWzc2LDFdLFs3NywxXSxbNzgsMV0sWzc5LDFdXSxbWzAsMV1dXSx7Njc6MSxcbjY4OjEsNjk6MSw3MDoxLDcxOjEsNzI6MSw3MzoxLDc0OjEsNzU6MSw3NjoxLDc3OjEsNzg6MSw3OToxfV0sMjY5OltbW1szOSwxXV0sW1swLDFdXV0sezM5OjF9XSwyNzA6W1tbWzEzLDFdXSxbWzI1LDJdXSxbWzQ4LDNdLFszNSw0XV0sW1s4MCw1XV0sW1s2MSw2XSxbODEsN11dLFtbMCw1XV0sW1s0OCwzXV0sW1s2MSw2XV1dLHsxMzoxfV0sMjcxOltbW1sxMCwxXSxbMzQsMl1dLFtbMzQsMl1dLFtbODIsM11dLFtbODMsNF1dLFtbODQsNV1dLFtbODUsNl0sWzAsNV1dLFtbMCw2XV1dLHsxMDoxLDM0OjF9XSwyNzI6W1tbWzM3LDFdXSxbWzg2LDJdXSxbWzg1LDNdLFswLDJdXSxbWzAsM11dXSx7Mzc6MX1dLDI3MzpbW1tbODcsMV0sWzU0LDFdXSxbWzAsMV1dXSx7MTA6MSwzNDoxLDM3OjF9XSwyNzQ6W1tbWzg4LDFdLFs4OSwxXSxbOCwyXSxbOTAsMV0sWzg4LDFdLFs4MywxXSxbOTEsMV0sWzkyLDNdLFs5MywxXSxbOTQsMV1dLFtbMCwxXV0sW1s4MywxXV0sW1s4LDFdLFswLDNdXV0sXG57ODoxLDgzOjEsODg6MSw4OToxLDkwOjEsOTE6MSw5MjoxLDkzOjEsOTQ6MX1dLDI3NTpbW1tbOTUsMV1dLFtbOTYsMF0sWzAsMV1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMjc2OltbW1s5NywxXSxbOTgsMV0sWzU4LDFdLFs5OSwxXSxbNTcsMV0sWzEwMCwxXSxbNTYsMV0sWzEwMSwxXSxbMTAyLDFdXSxbWzAsMV1dXSx7NDoxLDEwOjEsMTM6MSwyMDoxLDIxOjEsMzQ6MSwzNzoxLDQxOjEsNDI6MX1dLDI3NzpbW1tbNDAsMV1dLFtbMCwxXV1dLHs0MDoxfV0sMjc4OltbW1sxNywxXV0sW1swLDFdXV0sezE3OjF9XSwyNzk6W1tbWzEwMywxXV0sW1s1NiwyXSxbMTA0LDJdLFs5OSwyXV0sW1swLDJdXV0sezQxOjF9XSwyODA6W1tbWzQxLDFdXSxbWzEwNSwyXV0sW1syLDRdLFszNSwzXV0sW1s2MSw1XSxbODEsNl1dLFtbMCw0XV0sW1syLDRdXSxbWzYxLDVdXV0sezQxOjF9XSwyODE6W1tbWzEwNixcbjFdXSxbWzEwNiwxXSxbMCwxXV1dLHs0MToxfV0sMjgyOltbW1syNywxXV0sW1s4MiwyXV0sW1swLDJdXV0sezI3OjF9XSwyODM6W1tbWzQ5LDFdLFsxMDcsMl0sWzUzLDNdXSxbWzQ4LDRdLFs1NCw1XSxbNTIsNl0sWzAsMV1dLFtbNTQsNV0sWzUyLDZdLFswLDJdXSxbWzk1LDddXSxbWzQ5LDddXSxbWzAsNV1dLFtbNDksOF0sWzEwNyw4XSxbMCw2XV0sW1s1NCw1XSxbNTIsOV0sWzAsN11dLFtbNTIsNl0sWzAsOF1dLFtbNDksMTBdLFs1MywxMV0sWzAsOV1dLFtbNDgsMTJdXSxbWzk1LDEzXV0sW1s0OSwxM11dLFtbNTIsOV0sWzAsMTNdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxLDUzOjF9XSwyODQ6W1tbWzEwNSwxXV0sW1sxMDgsMl0sWzAsMV1dLFtbMjUsM11dLFtbMCwzXV1dLHsyNToxfV0sMjg1OltbW1sxMDksMV1dLFtbNTIsMF0sWzAsMV1dXSx7MjU6MX1dLDI4NjpbW1tbMjUsXG4xXV0sW1sxMTAsMF0sWzAsMV1dXSx7MjU6MX1dLDI4NzpbW1tbMjUsMV1dLFtbMCwxXV1dLHsyNToxfV0sMjg4OltbW1sxMTEsMV1dLFtbMiwxXSxbMTEyLDJdXSxbWzAsMl1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMjg5OltbW1sxMTMsMV1dLFtbNDksMl0sWzAsMV1dLFtbMTA4LDNdLFs1MiwzXSxbMCwyXV0sW1s0OSw0XV0sW1swLDRdXV0sezExMzoxfV0sMjkwOltbW1sxMTQsMV1dLFtbMTE1LDBdLFswLDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI5MTpbW1tbMTE2LDFdXSxbWzExNywyXSxbNTAsM10sWzExOCw0XSxbMCwxXV0sW1sxMTEsNF0sWzYyLDRdXSxbWzExNiw1XSxbNjIsNV1dLFtbMCw0XV0sW1s1MCwzXSxbMCw1XV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsXG4xNToxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMjkyOltbW1s5NSwxXSxbMTA3LDFdXSxbWzUyLDJdLFswLDFdXSxbWzk1LDFdLFsxMDcsMV0sWzAsMl1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE1OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyOTM6W1tbWzExOSwyXSxbMzAsMV0sWzIyLDFdLFs0MywxXV0sW1sxMjAsMl1dLFtbMCwyXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyOTQ6W1tbWzIsMF0sWzExMiwxXSxbMTIxLDBdXSxbWzAsMV1dXSx7MjoxLDQ6MSw1OjEsNjoxLDc6MSw4OjEsOToxLDEwOjEsMTE6MSwxMjoxLDEzOjEsMTQ6MSwxNToxLDE2OjEsMTc6MSwxODoxLDE5OjEsMjA6MSwyMToxLDIyOjEsMjM6MSwyNDoxLDI1OjEsMjY6MSwyNzoxLDI4OjEsMjk6MSwzMDoxLDMxOjEsMzI6MSwzMzoxLFxuMzQ6MSwzNToxLDM2OjEsMzc6MSwzODoxLDM5OjEsNDA6MSw0MToxLDQyOjEsNDM6MSwxMTI6MX1dLDI5NTpbW1tbMTIyLDFdLFsxMjMsMV0sWzEyNCwxXSxbMTI1LDFdLFsxMjYsMV1dLFtbMCwxXV1dLHs1OjEsMjM6MSwzMToxLDM5OjEsNDA6MX1dLDI5NjpbW1tbMzQsMV1dLFtbODIsMl1dLFtbODMsM11dLFtbMTExLDRdXSxbWzQ4LDVdXSxbWzgwLDZdXSxbWzEyNyw3XSxbMCw2XV0sW1s0OCw4XV0sW1s4MCw5XV0sW1swLDldXV0sezM0OjF9XSwyOTc6W1tbWzQsMV1dLFtbMjUsMl1dLFtbMTI4LDNdXSxbWzQ4LDRdLFsxMjksNV1dLFtbODAsNl1dLFtbNDksN11dLFtbMCw2XV0sW1s0OCw0XV1dLHs0OjF9XSwyOTg6W1tbWzI2LDFdXSxbWzI1LDJdXSxbWzUyLDFdLFswLDJdXV0sezI2OjF9XSwyOTk6W1tbWzM3LDFdXSxbWzQ5LDJdXSxbWzQ4LDNdXSxbWzgwLDRdXSxbWzEyNyw1XSxbMTMwLDFdLFswLDRdXSxbWzQ4LDZdXSxbWzgwLDddXSxbWzAsN11dXSx7Mzc6MX1dLDMwMDpbW1tbMjUsXG4xXV0sW1sxMDgsMl0sWzAsMV1dLFtbMjUsM11dLFtbMCwzXV1dLHsyNToxfV0sMzAxOltbW1sxMzEsMV1dLFtbNTIsMl0sWzAsMV1dLFtbMTMxLDFdLFswLDJdXV0sezI1OjF9XSwzMDI6W1tbWzM2LDFdXSxbWzEwNSwyXSxbMTksM10sWzExMCwzXV0sW1szMiw0XV0sW1sxMDUsMl0sWzE5LDNdLFszMiw0XSxbMTEwLDNdXSxbWzEzMiw1XSxbMTUsNV0sWzM1LDZdXSxbWzAsNV1dLFtbMTMyLDddXSxbWzYxLDVdXV0sezM2OjF9XSwzMDM6W1tbWzMyLDFdXSxbWzEzMywyXV0sW1swLDJdXV0sezMyOjF9XSwzMDQ6W1tbWzEzNCwxXSxbMTM1LDFdXSxbWzAsMV1dXSx7MzI6MSwzNjoxfV0sMzA1OltbW1sxNCwxXV0sW1s0OCwyXSxbMTM2LDNdXSxbWzQ5LDRdXSxbWzQ4LDJdXSxbWzAsNF1dXSx7MTQ6MX1dLDMwNjpbW1tbMTQsMV1dLFtbNDgsMl0sWzEzNiwzXV0sW1s4Niw0XV0sW1s0OCwyXV0sW1swLDRdXV0sezE0OjF9XSwzMDc6W1tbWzE4LDFdXSxbWzI1LDJdXSxbWzUyLDFdLFswLDJdXV0sXG57MTg6MX1dLDMwODpbW1tbOCwxXSxbMTM3LDJdXSxbWzQ2LDJdXSxbWzAsMl1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMwOTpbW1tbMTM4LDFdXSxbWzEzOSwwXSxbMCwxXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzEwOltbW1szNSwxXV0sW1s2MSwyXSxbMTQwLDNdXSxbWzAsMl1dLFtbNjEsMl1dXSx7MzU6MX1dLDMxMTpbW1tbMjgsMV1dLFtbMCwxXV1dLHsyODoxfV0sMzEyOltbW1sxNDEsMV1dLFtbNTMsMl0sWzAsMV1dLFtbMTIwLDNdXSxbWzAsM11dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjU6MSwyOToxLDMzOjEsMzU6MSwzODoxfV0sMzEzOltbW1sxNiwxXV0sW1s0OSwyXSxbMTQyLDNdLFswLDFdXSxbWzUyLDRdLFswLDJdXSxbWzQ5LDVdXSxbWzQ5LDJdLFswLDRdXSxcbltbNTIsNl0sWzAsNV1dLFtbNDksN11dLFtbNTIsOF0sWzAsN11dLFtbNDksN10sWzAsOF1dXSx7MTY6MX1dLDMxNDpbW1tbNSwxXV0sW1s0OSwyXSxbMCwxXV0sW1szNiwzXSxbNTIsM10sWzAsMl1dLFtbNDksNF1dLFtbNTIsNV0sWzAsNF1dLFtbNDksNl1dLFtbMCw2XV1dLHs1OjF9XSwzMTU6W1tbWzIzLDFdXSxbWzExMSwyXSxbMCwxXV0sW1swLDJdXV0sezIzOjF9XSwzMTY6W1tbWzE0MywxXV0sW1sxNDQsMF0sWzE0MiwwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMTc6W1tbWzE0NSwxXV0sW1syLDJdLFsxNDYsM11dLFtbMCwyXV0sW1sxNDUsMV0sWzIsMl1dXSx7NToxLDY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE2OjEsMTc6MSwxODoxLDE5OjEsMjI6MSwyMzoxLDI0OjEsMjU6MSwyNjoxLDI3OjEsMjg6MSwyOToxLDMwOjEsMzE6MSwzMjoxLDMzOjEsMzU6MSxcbjM2OjEsMzg6MSwzOToxLDQwOjEsNDM6MX1dLDMxODpbW1tbNDgsMV1dLFtbNDksMl0sWzAsMV1dLFtbMCwyXV1dLHs0ODoxfV0sMzE5OltbW1sxNDcsMV0sWzE0OCwxXSxbMTQ5LDFdLFsxNTAsMV0sWzE1MSwxXSxbMTUyLDFdLFsxNTMsMV0sWzE1NCwxXSxbMTU1LDFdLFsxNTYsMV1dLFtbMCwxXV1dLHs1OjEsNjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTY6MSwxNzoxLDE4OjEsMTk6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNToxLDM2OjEsMzg6MSwzOToxLDQwOjEsNDM6MX1dLDMyMDpbW1tbMTUsMV1dLFtbOTUsMl1dLFtbMCwyXV1dLHsxNToxfV0sMzIxOltbW1sxLDFdLFszLDFdXSxbWzAsMV1dXSx7NDoxLDU6MSw2OjEsNzoxLDg6MSw5OjEsMTA6MSwxMToxLDEyOjEsMTM6MSwxNDoxLDE1OjEsMTY6MSwxNzoxLDE4OjEsMTk6MSwyMDoxLDIxOjEsMjI6MSwyMzoxLDI0OjEsMjU6MSwyNjoxLFxuMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNDoxLDM1OjEsMzY6MSwzNzoxLDM4OjEsMzk6MSw0MDoxLDQxOjEsNDI6MSw0MzoxfV0sMzIyOltbW1s0OSwxXSxbNDgsMl1dLFtbNDgsMl0sWzAsMV1dLFtbNDksM10sWzE1Nyw0XSxbMCwyXV0sW1sxNTcsNF0sWzAsM11dLFtbMCw0XV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjEsNDg6MX1dLDMyMzpbW1tbMTU4LDFdXSxbWzUyLDJdLFswLDFdXSxbWzE1OCwxXSxbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjEsNDg6MX1dLDMyNDpbW1tbMSwxXSxbMiwyXV0sW1swLDFdXSxbWzE1OSwzXV0sW1sxMjEsNF1dLFtbMTYwLDFdLFsxMjEsNF1dXSx7MjoxLDU6MSw2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTU6MSwxNjoxLFxuMTc6MSwxODoxLDE5OjEsMjI6MSwyMzoxLDI0OjEsMjU6MSwyNjoxLDI3OjEsMjg6MSwyOToxLDMwOjEsMzE6MSwzMjoxLDMzOjEsMzU6MSwzNjoxLDM4OjEsMzk6MSw0MDoxLDQzOjF9XSwzMjU6W1tbWzEyMCwxXV0sW1sxNjEsMF0sWzE1LDBdLFsxNjIsMF0sWzQxLDBdLFsxNjMsMF0sWzAsMV1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzI2OltbW1s4NCwxXSxbMTY0LDJdXSxbWzM3LDNdLFswLDFdXSxbWzAsMl1dLFtbODQsNF1dLFtbMTI3LDVdXSxbWzQ5LDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMyNzpbW1tbMTY1LDFdLFs4NCwxXV0sW1swLDFdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLFxuMzI4OltbW1s0OSwxXV0sW1s1MiwyXSxbMCwxXV0sW1s0OSwxXSxbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMjk6W1tbWzQ5LDFdLFsxMDcsMV1dLFtbNTQsMl0sWzUyLDNdLFswLDFdXSxbWzAsMl1dLFtbNDksNF0sWzEwNyw0XSxbMCwzXV0sW1s1MiwzXSxbMCw0XV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTU6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMzMDpbW1tbNDksMV0sWzEwNywxXV0sW1s1MiwyXSxbMCwxXV0sW1s0OSwxXSxbMTA3LDFdLFswLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzMxOltbW1syNSwxXV0sW1s0OCwyXSxbMCwxXV0sW1s0OSwzXV0sW1swLDNdXV0sezI1OjF9XSxcbjMzMjpbW1tbMzUsMV0sWzExMCwyXSxbMzgsM11dLFtbNjEsNF0sWzgxLDVdXSxbWzI1LDRdXSxbWzE2Niw2XV0sW1swLDRdXSxbWzYxLDRdXSxbWzY0LDRdXV0sezM1OjEsMzg6MSwxMTA6MX1dLDMzMzpbW1tbMjAsMV1dLFtbNDgsMl1dLFtbODAsM11dLFtbMTY3LDRdLFsxNjgsNV1dLFtbNDgsNl1dLFtbNDgsN11dLFtbODAsOF1dLFtbODAsOV1dLFtbMTY3LDRdLFsxMjcsMTBdLFsxNjgsNV0sWzAsOF1dLFtbMCw5XV0sW1s0OCwxMV1dLFtbODAsMTJdXSxbWzE2OCw1XSxbMCwxMl1dXSx7MjA6MX1dLDMzNDpbW1tbMTUsMV0sWzE2OSwyXSxbNTMsM11dLFtbMTY5LDRdLFs1Miw1XSxbMCwxXV0sW1s1MCw2XSxbNTIsN10sWzAsMl1dLFtbMTY5LDhdXSxbWzUyLDVdLFswLDRdXSxbWzE2OSw5XSxbNTMsM10sWzAsNV1dLFtbNDksMTBdXSxbWzE1LDExXSxbMTY5LDJdLFs1MywzXSxbMCw3XV0sW1s1MiwxMl0sWzAsOF1dLFtbNTAsMTNdLFs1Miw1XSxbMCw5XV0sW1s1Miw3XSxbMCwxMF1dLFxuW1sxNjksMTRdLFs1MiwxNV0sWzAsMTFdXSxbWzAsMTJdXSxbWzQ5LDRdXSxbWzUyLDE1XSxbMCwxNF1dLFtbMTY5LDE2XSxbNTMsM10sWzAsMTVdXSxbWzUwLDE3XSxbNTIsMTVdLFswLDE2XV0sW1s0OSwxNF1dXSx7MTU6MSwyNToxLDUzOjF9XSwzMzU6W1tbWzE1LDFdLFs1MywyXSxbMTcwLDNdXSxbWzE3MCw1XSxbNTIsNF0sWzAsMV1dLFtbMTcwLDZdXSxbWzUwLDddLFs1Miw4XSxbMCwzXV0sW1s1MywyXSxbMTcwLDldLFswLDRdXSxbWzUyLDRdLFswLDVdXSxbWzUyLDEwXSxbMCw2XV0sW1s0OSwxMV1dLFtbMTUsMTJdLFs1MywyXSxbMTcwLDNdLFswLDhdXSxbWzUwLDEzXSxbNTIsNF0sWzAsOV1dLFtbMCwxMF1dLFtbNTIsOF0sWzAsMTFdXSxbWzUyLDE1XSxbMTcwLDE0XSxbMCwxMl1dLFtbNDksNV1dLFtbNTIsMTVdLFswLDE0XV0sW1s1MywyXSxbMTcwLDE2XSxbMCwxNV1dLFtbNTAsMTddLFs1MiwxNV0sWzAsMTZdXSxbWzQ5LDE0XV1dLHsxNToxLDI1OjEsNTM6MX1dLDMzNjpbW1tbMjUsXG4xXV0sW1swLDFdXV0sezI1OjF9XSwzMzc6W1tbWzIxLDFdXSxbWzQ5LDJdXSxbWzQ4LDNdXSxbWzgwLDRdXSxbWzEyNyw1XSxbMCw0XV0sW1s0OCw2XV0sW1s4MCw3XV0sW1swLDddXV0sezIxOjF9XSwzMzg6W1tbWzQ5LDFdXSxbWzEwOCwyXSxbMCwxXV0sW1s5NSwzXV0sW1swLDNdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMzOTpbW1tbNDIsMV1dLFtbMTcxLDJdXSxbWzQ4LDNdLFs1MiwxXV0sW1s4MCw0XV0sW1swLDRdXV0sezQyOjF9XSwzNDA6W1tbWzE3MiwxXV0sW1sxNzMsMF0sWzAsMV1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzQxOltbW1sxMTEsMl0sWzM2LDFdXSxbWzQ5LDJdXSxbWzAsMl1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE5OjEsMjI6MSwyNToxLDI5OjEsXG4zMDoxLDMzOjEsMzU6MSwzNjoxLDM4OjEsNDM6MX1dLDM0MjpbW1tbMzEsMV1dLFtbMTc0LDJdLFswLDFdXSxbWzAsMl1dXSx7MzE6MX1dLDM0MzpbW1tbNjIsMV1dLFtbMCwxXV1dLHszMToxfV19LHN0YXRlczpbW1tbMSwxXSxbMiwxXSxbMywyXV0sW1swLDFdXSxbWzIsMV1dXSxbW1s0NCwxXV0sW1s0NSwwXSxbMCwxXV1dLFtbWzQ2LDFdXSxbWzQ3LDBdLFswLDFdXV0sW1tbNDgsMV1dLFtbNDksMl1dLFtbNTAsM10sWzAsMl1dLFtbNDksNF1dLFtbMCw0XV1dLFtbWzUxLDFdXSxbWzUyLDJdLFswLDFdXSxbWzUxLDFdLFswLDJdXV0sW1tbNDksMV0sWzE1LDJdLFs1MywyXV0sW1s1MCwyXSxbNTQsM10sWzAsMV1dLFtbNDksM11dLFtbMCwzXV1dLFtbWzU1LDFdXSxbWzMwLDBdLFs0MywwXSxbMCwxXV1dLFtbWzI0LDFdXSxbWzQ5LDJdXSxbWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzAsNF1dXSxbW1sxMCwxXV0sW1s1NiwyXV0sW1swLDJdXV0sW1tbMTAsMV1dLFtbNTcsMl0sWzU2LFxuMl0sWzU4LDJdXSxbWzAsMl1dXSxbW1s2LDFdLFsyNSwxXSxbMzMsMV0sWzksMV0sWzExLDFdLFsxMiwyXSxbMzUsM10sWzM4LDRdLFsxOSwxXSxbNyw1XV0sW1swLDFdXSxbWzU5LDFdLFs2MCw2XV0sW1s2MSwxXSxbNjIsN10sWzYzLDddXSxbWzY0LDFdLFs2Myw4XV0sW1s3LDVdLFswLDVdXSxbWzU5LDFdXSxbWzYxLDFdXSxbWzY0LDFdXV0sW1tbMjksMV0sWzY1LDJdXSxbWzY1LDJdXSxbWzY2LDJdLFswLDJdXV0sW1tbNjcsMV0sWzY4LDFdLFs2OSwxXSxbNzAsMV0sWzcxLDFdLFs3MiwxXSxbNzMsMV0sWzc0LDFdLFs3NSwxXSxbNzYsMV0sWzc3LDFdLFs3OCwxXSxbNzksMV1dLFtbMCwxXV1dLFtbWzM5LDFdXSxbWzAsMV1dXSxbW1sxMywxXV0sW1syNSwyXV0sW1s0OCwzXSxbMzUsNF1dLFtbODAsNV1dLFtbNjEsNl0sWzgxLDddXSxbWzAsNV1dLFtbNDgsM11dLFtbNjEsNl1dXSxbW1sxMCwxXSxbMzQsMl1dLFtbMzQsMl1dLFtbODIsM11dLFtbODMsNF1dLFtbODQsNV1dLFtbODUsXG42XSxbMCw1XV0sW1swLDZdXV0sW1tbMzcsMV1dLFtbODYsMl1dLFtbODUsM10sWzAsMl1dLFtbMCwzXV1dLFtbWzg3LDFdLFs1NCwxXV0sW1swLDFdXV0sW1tbODgsMV0sWzg5LDFdLFs4LDJdLFs5MCwxXSxbODgsMV0sWzgzLDFdLFs5MSwxXSxbOTIsM10sWzkzLDFdLFs5NCwxXV0sW1swLDFdXSxbWzgzLDFdXSxbWzgsMV0sWzAsM11dXSxbW1s5NSwxXV0sW1s5NiwwXSxbMCwxXV1dLFtbWzk3LDFdLFs5OCwxXSxbNTgsMV0sWzk5LDFdLFs1NywxXSxbMTAwLDFdLFs1NiwxXSxbMTAxLDFdLFsxMDIsMV1dLFtbMCwxXV1dLFtbWzQwLDFdXSxbWzAsMV1dXSxbW1sxNywxXV0sW1swLDFdXV0sW1tbMTAzLDFdXSxbWzU2LDJdLFsxMDQsMl0sWzk5LDJdXSxbWzAsMl1dXSxbW1s0MSwxXV0sW1sxMDUsMl1dLFtbMiw0XSxbMzUsM11dLFtbNjEsNV0sWzgxLDZdXSxbWzAsNF1dLFtbMiw0XV0sW1s2MSw1XV1dLFtbWzEwNiwxXV0sW1sxMDYsMV0sWzAsMV1dXSxbW1syNywxXV0sW1s4MiwyXV0sXG5bWzAsMl1dXSxbW1s0OSwxXSxbMTA3LDJdLFs1MywzXV0sW1s0OCw0XSxbNTQsNV0sWzUyLDZdLFswLDFdXSxbWzU0LDVdLFs1Miw2XSxbMCwyXV0sW1s5NSw3XV0sW1s0OSw3XV0sW1swLDVdXSxbWzQ5LDhdLFsxMDcsOF0sWzAsNl1dLFtbNTQsNV0sWzUyLDldLFswLDddXSxbWzUyLDZdLFswLDhdXSxbWzQ5LDEwXSxbNTMsMTFdLFswLDldXSxbWzQ4LDEyXV0sW1s5NSwxM11dLFtbNDksMTNdXSxbWzUyLDldLFswLDEzXV1dLFtbWzEwNSwxXV0sW1sxMDgsMl0sWzAsMV1dLFtbMjUsM11dLFtbMCwzXV1dLFtbWzEwOSwxXV0sW1s1MiwwXSxbMCwxXV1dLFtbWzI1LDFdXSxbWzExMCwwXSxbMCwxXV1dLFtbWzI1LDFdXSxbWzAsMV1dXSxbW1sxMTEsMV1dLFtbMiwxXSxbMTEyLDJdXSxbWzAsMl1dXSxbW1sxMTMsMV1dLFtbNDksMl0sWzAsMV1dLFtbMTA4LDNdLFs1MiwzXSxbMCwyXV0sW1s0OSw0XV0sW1swLDRdXV0sW1tbMTE0LDFdXSxbWzExNSwwXSxbMCwxXV1dLFtbWzExNiwxXV0sXG5bWzExNywyXSxbNTAsM10sWzExOCw0XSxbMCwxXV0sW1sxMTEsNF0sWzYyLDRdXSxbWzExNiw1XSxbNjIsNV1dLFtbMCw0XV0sW1s1MCwzXSxbMCw1XV1dLFtbWzk1LDFdLFsxMDcsMV1dLFtbNTIsMl0sWzAsMV1dLFtbOTUsMV0sWzEwNywxXSxbMCwyXV1dLFtbWzExOSwyXSxbMzAsMV0sWzIyLDFdLFs0MywxXV0sW1sxMjAsMl1dLFtbMCwyXV1dLFtbWzIsMF0sWzExMiwxXSxbMTIxLDBdXSxbWzAsMV1dXSxbW1sxMjIsMV0sWzEyMywxXSxbMTI0LDFdLFsxMjUsMV0sWzEyNiwxXV0sW1swLDFdXV0sW1tbMzQsMV1dLFtbODIsMl1dLFtbODMsM11dLFtbMTExLDRdXSxbWzQ4LDVdXSxbWzgwLDZdXSxbWzEyNyw3XSxbMCw2XV0sW1s0OCw4XV0sW1s4MCw5XV0sW1swLDldXV0sW1tbNCwxXV0sW1syNSwyXV0sW1sxMjgsM11dLFtbNDgsNF0sWzEyOSw1XV0sW1s4MCw2XV0sW1s0OSw3XV0sW1swLDZdXSxbWzQ4LDRdXV0sW1tbMjYsMV1dLFtbMjUsMl1dLFtbNTIsMV0sWzAsMl1dXSxbW1szNyxcbjFdXSxbWzQ5LDJdXSxbWzQ4LDNdXSxbWzgwLDRdXSxbWzEyNyw1XSxbMTMwLDFdLFswLDRdXSxbWzQ4LDZdXSxbWzgwLDddXSxbWzAsN11dXSxbW1syNSwxXV0sW1sxMDgsMl0sWzAsMV1dLFtbMjUsM11dLFtbMCwzXV1dLFtbWzEzMSwxXV0sW1s1MiwyXSxbMCwxXV0sW1sxMzEsMV0sWzAsMl1dXSxbW1szNiwxXV0sW1sxMDUsMl0sWzE5LDNdLFsxMTAsM11dLFtbMzIsNF1dLFtbMTA1LDJdLFsxOSwzXSxbMzIsNF0sWzExMCwzXV0sW1sxMzIsNV0sWzE1LDVdLFszNSw2XV0sW1swLDVdXSxbWzEzMiw3XV0sW1s2MSw1XV1dLFtbWzMyLDFdXSxbWzEzMywyXV0sW1swLDJdXV0sW1tbMTM0LDFdLFsxMzUsMV1dLFtbMCwxXV1dLFtbWzE0LDFdXSxbWzQ4LDJdLFsxMzYsM11dLFtbNDksNF1dLFtbNDgsMl1dLFtbMCw0XV1dLFtbWzE0LDFdXSxbWzQ4LDJdLFsxMzYsM11dLFtbODYsNF1dLFtbNDgsMl1dLFtbMCw0XV1dLFtbWzE4LDFdXSxbWzI1LDJdXSxbWzUyLDFdLFswLDJdXV0sW1tbOCxcbjFdLFsxMzcsMl1dLFtbNDYsMl1dLFtbMCwyXV1dLFtbWzEzOCwxXV0sW1sxMzksMF0sWzAsMV1dXSxbW1szNSwxXV0sW1s2MSwyXSxbMTQwLDNdXSxbWzAsMl1dLFtbNjEsMl1dXSxbW1syOCwxXV0sW1swLDFdXV0sW1tbMTQxLDFdXSxbWzUzLDJdLFswLDFdXSxbWzEyMCwzXV0sW1swLDNdXV0sW1tbMTYsMV1dLFtbNDksMl0sWzE0MiwzXSxbMCwxXV0sW1s1Miw0XSxbMCwyXV0sW1s0OSw1XV0sW1s0OSwyXSxbMCw0XV0sW1s1Miw2XSxbMCw1XV0sW1s0OSw3XV0sW1s1Miw4XSxbMCw3XV0sW1s0OSw3XSxbMCw4XV1dLFtbWzUsMV1dLFtbNDksMl0sWzAsMV1dLFtbMzYsM10sWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzUyLDVdLFswLDRdXSxbWzQ5LDZdXSxbWzAsNl1dXSxbW1syMywxXV0sW1sxMTEsMl0sWzAsMV1dLFtbMCwyXV1dLFtbWzE0MywxXV0sW1sxNDQsMF0sWzE0MiwwXSxbMCwxXV1dLFtbWzE0NSwxXV0sW1syLDJdLFsxNDYsM11dLFtbMCwyXV0sW1sxNDUsMV0sWzIsMl1dXSxcbltbWzQ4LDFdXSxbWzQ5LDJdLFswLDFdXSxbWzAsMl1dXSxbW1sxNDcsMV0sWzE0OCwxXSxbMTQ5LDFdLFsxNTAsMV0sWzE1MSwxXSxbMTUyLDFdLFsxNTMsMV0sWzE1NCwxXSxbMTU1LDFdLFsxNTYsMV1dLFtbMCwxXV1dLFtbWzE1LDFdXSxbWzk1LDJdXSxbWzAsMl1dXSxbW1sxLDFdLFszLDFdXSxbWzAsMV1dXSxbW1s0OSwxXSxbNDgsMl1dLFtbNDgsMl0sWzAsMV1dLFtbNDksM10sWzE1Nyw0XSxbMCwyXV0sW1sxNTcsNF0sWzAsM11dLFtbMCw0XV1dLFtbWzE1OCwxXV0sW1s1MiwyXSxbMCwxXV0sW1sxNTgsMV0sWzAsMl1dXSxbW1sxLDFdLFsyLDJdXSxbWzAsMV1dLFtbMTU5LDNdXSxbWzEyMSw0XV0sW1sxNjAsMV0sWzEyMSw0XV1dLFtbWzEyMCwxXV0sW1sxNjEsMF0sWzE1LDBdLFsxNjIsMF0sWzQxLDBdLFsxNjMsMF0sWzAsMV1dXSxbW1s4NCwxXSxbMTY0LDJdXSxbWzM3LDNdLFswLDFdXSxbWzAsMl1dLFtbODQsNF1dLFtbMTI3LDVdXSxbWzQ5LDJdXV0sW1tbMTY1LDFdLFxuWzg0LDFdXSxbWzAsMV1dXSxbW1s0OSwxXV0sW1s1MiwyXSxbMCwxXV0sW1s0OSwxXSxbMCwyXV1dLFtbWzQ5LDFdLFsxMDcsMV1dLFtbNTQsMl0sWzUyLDNdLFswLDFdXSxbWzAsMl1dLFtbNDksNF0sWzEwNyw0XSxbMCwzXV0sW1s1MiwzXSxbMCw0XV1dLFtbWzQ5LDFdLFsxMDcsMV1dLFtbNTIsMl0sWzAsMV1dLFtbNDksMV0sWzEwNywxXSxbMCwyXV1dLFtbWzI1LDFdXSxbWzQ4LDJdLFswLDFdXSxbWzQ5LDNdXSxbWzAsM11dXSxbW1szNSwxXSxbMTEwLDJdLFszOCwzXV0sW1s2MSw0XSxbODEsNV1dLFtbMjUsNF1dLFtbMTY2LDZdXSxbWzAsNF1dLFtbNjEsNF1dLFtbNjQsNF1dXSxbW1syMCwxXV0sW1s0OCwyXV0sW1s4MCwzXV0sW1sxNjcsNF0sWzE2OCw1XV0sW1s0OCw2XV0sW1s0OCw3XV0sW1s4MCw4XV0sW1s4MCw5XV0sW1sxNjcsNF0sWzEyNywxMF0sWzE2OCw1XSxbMCw4XV0sW1swLDldXSxbWzQ4LDExXV0sW1s4MCwxMl1dLFtbMTY4LDVdLFswLDEyXV1dLFtbWzE1LDFdLFxuWzE2OSwyXSxbNTMsM11dLFtbMTY5LDRdLFs1Miw1XSxbMCwxXV0sW1s1MCw2XSxbNTIsN10sWzAsMl1dLFtbMTY5LDhdXSxbWzUyLDVdLFswLDRdXSxbWzE2OSw5XSxbNTMsM10sWzAsNV1dLFtbNDksMTBdXSxbWzE1LDExXSxbMTY5LDJdLFs1MywzXSxbMCw3XV0sW1s1MiwxMl0sWzAsOF1dLFtbNTAsMTNdLFs1Miw1XSxbMCw5XV0sW1s1Miw3XSxbMCwxMF1dLFtbMTY5LDE0XSxbNTIsMTVdLFswLDExXV0sW1swLDEyXV0sW1s0OSw0XV0sW1s1MiwxNV0sWzAsMTRdXSxbWzE2OSwxNl0sWzUzLDNdLFswLDE1XV0sW1s1MCwxN10sWzUyLDE1XSxbMCwxNl1dLFtbNDksMTRdXV0sW1tbMTUsMV0sWzUzLDJdLFsxNzAsM11dLFtbMTcwLDVdLFs1Miw0XSxbMCwxXV0sW1sxNzAsNl1dLFtbNTAsN10sWzUyLDhdLFswLDNdXSxbWzUzLDJdLFsxNzAsOV0sWzAsNF1dLFtbNTIsNF0sWzAsNV1dLFtbNTIsMTBdLFswLDZdXSxbWzQ5LDExXV0sW1sxNSwxMl0sWzUzLDJdLFsxNzAsM10sWzAsOF1dLFxuW1s1MCwxM10sWzUyLDRdLFswLDldXSxbWzAsMTBdXSxbWzUyLDhdLFswLDExXV0sW1s1MiwxNV0sWzE3MCwxNF0sWzAsMTJdXSxbWzQ5LDVdXSxbWzUyLDE1XSxbMCwxNF1dLFtbNTMsMl0sWzE3MCwxNl0sWzAsMTVdXSxbWzUwLDE3XSxbNTIsMTVdLFswLDE2XV0sW1s0OSwxNF1dXSxbW1syNSwxXV0sW1swLDFdXV0sW1tbMjEsMV1dLFtbNDksMl1dLFtbNDgsM11dLFtbODAsNF1dLFtbMTI3LDVdLFswLDRdXSxbWzQ4LDZdXSxbWzgwLDddXSxbWzAsN11dXSxbW1s0OSwxXV0sW1sxMDgsMl0sWzAsMV1dLFtbOTUsM11dLFtbMCwzXV1dLFtbWzQyLDFdXSxbWzE3MSwyXV0sW1s0OCwzXSxbNTIsMV1dLFtbODAsNF1dLFtbMCw0XV1dLFtbWzE3MiwxXV0sW1sxNzMsMF0sWzAsMV1dXSxbW1sxMTEsMl0sWzM2LDFdXSxbWzQ5LDJdXSxbWzAsMl1dXSxbW1szMSwxXV0sW1sxNzQsMl0sWzAsMV1dLFtbMCwyXV1dLFtbWzYyLDFdXSxbWzAsMV1dXV0sbGFiZWxzOltbMCxcIkVNUFRZXCJdLFszMTcsXG5udWxsXSxbNCxudWxsXSxbMjc2LG51bGxdLFsxLFwiZGVmXCJdLFsxLFwicmFpc2VcIl0sWzEsXCJUcnVlXCJdLFszLG51bGxdLFsxLFwibm90XCJdLFsxLFwiTm9uZVwiXSxbNTUsbnVsbF0sWzIsbnVsbF0sWzI1LG51bGxdLFsxLFwiY2xhc3NcIl0sWzEsXCJsYW1iZGFcIl0sWzE2LG51bGxdLFsxLFwicHJpbnRcIl0sWzEsXCJkZWJ1Z2dlclwiXSxbMSxcIm5vbmxvY2FsXCJdLFs1MixudWxsXSxbMSxcInRyeVwiXSxbMSxcIndoaWxlXCJdLFszMSxudWxsXSxbMSxcInJldHVyblwiXSxbMSxcImFzc2VydFwiXSxbMSxudWxsXSxbMSxcImdsb2JhbFwiXSxbMSxcImRlbFwiXSxbMSxcInBhc3NcIl0sWzU0LG51bGxdLFsxNSxudWxsXSxbMSxcInlpZWxkXCJdLFsxLFwiaW1wb3J0XCJdLFsxLFwiRmFsc2VcIl0sWzEsXCJmb3JcIl0sWzcsbnVsbF0sWzEsXCJmcm9tXCJdLFsxLFwiaWZcIl0sWzksbnVsbF0sWzEsXCJicmVha1wiXSxbMSxcImNvbnRpbnVlXCJdLFs0OSxudWxsXSxbMSxcIndpdGhcIl0sWzE0LG51bGxdLFszMTYsbnVsbF0sWzE5LG51bGxdLFszMDgsbnVsbF0sXG5bMSxcImFuZFwiXSxbMTEsbnVsbF0sWzMyNixudWxsXSxbMjIsbnVsbF0sWzI2MSxudWxsXSxbMTIsbnVsbF0sWzM1LG51bGxdLFsyNzEsbnVsbF0sWzMyNSxudWxsXSxbMjk3LG51bGxdLFszMzksbnVsbF0sWzI5NixudWxsXSxbMjYsbnVsbF0sWzI4MyxudWxsXSxbOCxudWxsXSxbMzQyLG51bGxdLFszMjksbnVsbF0sWzEwLG51bGxdLFsyNjYsbnVsbF0sWzMzMixudWxsXSxbNDUsbnVsbF0sWzM4LG51bGxdLFs0MCxudWxsXSxbNTAsbnVsbF0sWzQ2LG51bGxdLFs0MSxudWxsXSxbNDIsbnVsbF0sWzM2LG51bGxdLFs0MyxudWxsXSxbNDgsbnVsbF0sWzQ0LG51bGxdLFszNyxudWxsXSxbMzksbnVsbF0sWzMyNCxudWxsXSxbMjYwLG51bGxdLFsyOTIsbnVsbF0sWzEsXCJpblwiXSxbMzA5LG51bGxdLFsyNzMsbnVsbF0sWzMyNyxudWxsXSxbMjcyLG51bGxdLFsyOCxudWxsXSxbMjEsbnVsbF0sWzI3LG51bGxdLFsyOSxudWxsXSxbMSxcImlzXCJdLFszMCxudWxsXSxbMjAsbnVsbF0sWzI5MCxcbm51bGxdLFsyNzQsbnVsbF0sWzMzMyxudWxsXSxbMjk5LG51bGxdLFsyNzAsbnVsbF0sWzMzNyxudWxsXSxbMjc5LG51bGxdLFsyNjUsbnVsbF0sWzI4MSxudWxsXSxbMjY0LG51bGxdLFsyODYsbnVsbF0sWzI4MCxudWxsXSxbMzIwLG51bGxdLFsxLFwiYXNcIl0sWzI4NCxudWxsXSxbMjMsbnVsbF0sWzMyOCxudWxsXSxbMCxudWxsXSxbMSxcImV4Y2VwdFwiXSxbMzQwLG51bGxdLFsxOCxudWxsXSxbMzMwLG51bGxdLFsyNjgsbnVsbF0sWzI1OSxudWxsXSxbMzEyLG51bGxdLFsyOTMsbnVsbF0sWzMyMSxudWxsXSxbMjY5LG51bGxdLFsyNzcsbnVsbF0sWzMxNCxudWxsXSxbMzE1LG51bGxdLFszNDMsbnVsbF0sWzEsXCJlbHNlXCJdLFszMTAsbnVsbF0sWzUxLG51bGxdLFsxLFwiZWxpZlwiXSxbMzAwLG51bGxdLFszMDEsbnVsbF0sWzI4NSxudWxsXSxbMzAzLG51bGxdLFszMDIsbnVsbF0sWzMzNSxudWxsXSxbMjc1LG51bGxdLFsyNTgsbnVsbF0sWzEsXCJvclwiXSxbMzM0LG51bGxdLFsyNjcsbnVsbF0sXG5bMzQsbnVsbF0sWzI2MixudWxsXSxbMzMsbnVsbF0sWzMxOSxudWxsXSxbMTMsbnVsbF0sWzI5NSxudWxsXSxbMjYzLG51bGxdLFsyOTEsbnVsbF0sWzMxMSxudWxsXSxbMzA3LG51bGxdLFszMTMsbnVsbF0sWzI4MixudWxsXSxbMjk4LG51bGxdLFszMDQsbnVsbF0sWzI3OCxudWxsXSxbMzE4LG51bGxdLFszMjIsbnVsbF0sWzUsbnVsbF0sWzYsbnVsbF0sWzQ3LG51bGxdLFsxNyxudWxsXSxbMjQsbnVsbF0sWzMwNSxudWxsXSxbMzA2LG51bGxdLFszMjMsbnVsbF0sWzI4OSxudWxsXSxbMSxcImZpbmFsbHlcIl0sWzMzMSxudWxsXSxbMzM2LG51bGxdLFszMzgsbnVsbF0sWzI1NyxudWxsXSxbMzIsbnVsbF0sWzM0MSxudWxsXV0sa2V5d29yZHM6e0ZhbHNlOjMzLE5vbmU6OSxUcnVlOjYsYW5kOjQ3LGFzOjEwOCxhc3NlcnQ6MjQsXCJicmVha1wiOjM5LFwiY2xhc3NcIjoxMyxcImNvbnRpbnVlXCI6NDAsXCJkZWJ1Z2dlclwiOjE3LGRlZjo0LGRlbDoyNyxlbGlmOjEzMCxcImVsc2VcIjoxMjcsZXhjZXB0OjExMyxcblwiZmluYWxseVwiOjE2OCxcImZvclwiOjM0LGZyb206MzYsZ2xvYmFsOjI2LFwiaWZcIjozNyxcImltcG9ydFwiOjMyLFwiaW5cIjo4Myxpczo5MixsYW1iZGE6MTQsbm9ubG9jYWw6MTgsbm90Ojgsb3I6MTM5LHBhc3M6MjgscHJpbnQ6MTYscmFpc2U6NSxcInJldHVyblwiOjIzLFwidHJ5XCI6MjAsXCJ3aGlsZVwiOjIxLFwid2l0aFwiOjQyLHlpZWxkOjMxfSx0b2tlbnM6ezA6MTEyLDE6MjUsMjoxMSwzOjcsNDoyLDU6MTU5LDY6MTYwLDc6MzUsODo2MSw5OjM4LDEwOjY0LDExOjQ4LDEyOjUyLDEzOjE0NiwxNDo0MywxNTozMCwxNjoxNSwxNzoxNjIsMTg6MTE1LDE5OjQ1LDIwOjk0LDIxOjg5LDIyOjUwLDIzOjExMCwyNDoxNjMsMjU6MTIsMjY6NTksMjc6OTAsMjg6ODgsMjk6OTEsMzA6OTMsMzE6MjIsMzI6MTczLDMzOjE0NCwzNDoxNDIsMzU6NTMsMzY6NzQsMzc6NzgsMzg6NjgsMzk6NzksNDA6NjksNDE6NzIsNDI6NzMsNDM6NzUsNDQ6NzcsNDU6NjcsNDY6NzEsNDc6MTYxLDQ4Ojc2LDQ5OjQxLDUwOjcwLFxuNTE6MTI5LDUyOjE5LDU0OjI5LDU1OjEwfSxzdGFydDoyNTZ9fSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIoZCxmKXt0aGlzLmZpbGVuYW1lPWQ7dGhpcy5ncmFtbWFyPWY7dGhpcy5wX2ZsYWdzPTA7cmV0dXJuIHRoaXN9ZnVuY3Rpb24gZShkLGYpe3ZvaWQgMD09PWYmJihmPVwiZmlsZV9pbnB1dFwiKTtkPW5ldyBiKGQsU2suUGFyc2VUYWJsZXMpO1wiZmlsZV9pbnB1dFwiPT09Zj9kLnNldHVwKFNrLlBhcnNlVGFibGVzLnN5bS5maWxlX2lucHV0KTpTay5hc3NlcnRzLmZhaWwoXCJ0b2RvO1wiKTtyZXR1cm4gZH1iLkZVVFVSRV9QUklOVF9GVU5DVElPTj1cInByaW50X2Z1bmN0aW9uXCI7Yi5GVVRVUkVfVU5JQ09ERV9MSVRFUkFMUz1cInVuaWNvZGVfbGl0ZXJhbHNcIjtiLkZVVFVSRV9ESVZJU0lPTj1cImRpdmlzaW9uXCI7Yi5GVVRVUkVfQUJTT0xVVEVfSU1QT1JUPVwiYWJzb2x1dGVfaW1wb3J0XCI7Yi5GVVRVUkVfV0lUSF9TVEFURU1FTlQ9XCJ3aXRoX3N0YXRlbWVudFwiO2IuRlVUVVJFX05FU1RFRF9TQ09QRVM9XG5cIm5lc3RlZF9zY29wZXNcIjtiLkZVVFVSRV9HRU5FUkFUT1JTPVwiZ2VuZXJhdG9yc1wiO2IuQ09fRlVUVVJFX1BSSU5UX0ZVTkNUSU9OPTY1NTM2O2IuQ09fRlVUVVJFX1VOSUNPREVfTElURVJBTFM9MTMxMDcyO2IuQ09fRlVUVVJFX0RJVklTT049ODE5MjtiLkNPX0ZVVFVSRV9BQlNPTFVURV9JTVBPUlQ9MTYzODQ7Yi5DT19GVVRVUkVfV0lUSF9TVEFURU1FTlQ9MzI3Njg7Yi5wcm90b3R5cGUuc2V0dXA9ZnVuY3Rpb24oZCl7ZD1kfHx0aGlzLmdyYW1tYXIuc3RhcnQ7dGhpcy5zdGFjaz1be2RmYTp0aGlzLmdyYW1tYXIuZGZhc1tkXSxzdGF0ZTowLG5vZGU6e3R5cGU6ZCx2YWx1ZTpudWxsLGNvbnRleHQ6bnVsbCxjaGlsZHJlbjpbXX19XTt0aGlzLnVzZWRfbmFtZXM9e319O2IucHJvdG90eXBlLmFkZHRva2VuPWZ1bmN0aW9uKGQsZixoKXt2YXIgcCxnPXRoaXMuY2xhc3NpZnkoZCxmLGgpO2E6Zm9yKDs7KXt2YXIgYT10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdO3ZhciBjPVxuYS5kZmFbMF07dmFyIG49Y1thLnN0YXRlXTtmb3IocD0wO3A8bi5sZW5ndGg7KytwKXt2YXIgbT1uW3BdWzBdO3ZhciBrPW5bcF1bMV07dmFyIHU9dGhpcy5ncmFtbWFyLmxhYmVsc1ttXVswXTtpZihnPT09bSl7U2suYXNzZXJ0cy5hc3NlcnQoMjU2PnUpO3RoaXMuc2hpZnQoZCxmLGssaCk7Zm9yKGg9azsxPT09Y1toXS5sZW5ndGgmJjA9PT1jW2hdWzBdWzBdJiZjW2hdWzBdWzFdPT09aDspe3RoaXMucG9wKCk7aWYoMD09PXRoaXMuc3RhY2subGVuZ3RoKXJldHVybiEwO2E9dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtoPWEuc3RhdGU7Yz1hLmRmYVswXX1yZXR1cm4hMX1pZigyNTY8PXUmJihtPXRoaXMuZ3JhbW1hci5kZmFzW3VdLG09bVsxXSxtLmhhc093blByb3BlcnR5KGcpKSl7dGhpcy5wdXNoKHUsdGhpcy5ncmFtbWFyLmRmYXNbdV0sayxoKTtjb250aW51ZSBhfX1iOntjPVswLGEuc3RhdGVdO2ZvcihhPW4ubGVuZ3RoO2EtLTspaWYoblthXVswXT09PWNbMF0mJlxublthXVsxXT09PWNbMV0pe249ITA7YnJlYWsgYn1uPSExfWlmKG4pe2lmKHRoaXMucG9wKCksMD09PXRoaXMuc3RhY2subGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidG9vIG11Y2ggaW5wdXRcIix0aGlzLmZpbGVuYW1lKTt9ZWxzZSB0aHJvdyBkPWhbMF1bMF0sbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJiYWQgaW5wdXRcIix0aGlzLmZpbGVuYW1lLGQsaCk7fX07Yi5wcm90b3R5cGUuY2xhc3NpZnk9ZnVuY3Rpb24oZCxmLGgpe2lmKGQ9PT1Tay50b2tlbi50b2tlbnMuVF9OQU1FKXt0aGlzLnVzZWRfbmFtZXNbZl09ITA7dmFyIHA9dGhpcy5ncmFtbWFyLmtleXdvcmRzLmhhc093blByb3BlcnR5KGYpJiZ0aGlzLmdyYW1tYXIua2V5d29yZHNbZl07XCJwcmludFwiPT09ZiYmKHRoaXMucF9mbGFncyZiLkNPX0ZVVFVSRV9QUklOVF9GVU5DVElPTnx8ITA9PT1Tay5fX2Z1dHVyZV9fLnByaW50X2Z1bmN0aW9uKSYmKHA9ITEpO2lmKHApcmV0dXJuIHB9cD10aGlzLmdyYW1tYXIudG9rZW5zLmhhc093blByb3BlcnR5KGQpJiZcbnRoaXMuZ3JhbW1hci50b2tlbnNbZF07aWYoIXApe2Y9XCIjXCIrZDtmb3IobGV0IGcgaW4gU2sudG9rZW4udG9rZW5zKWlmKFNrLnRva2VuLnRva2Vuc1tnXT09ZCl7Zj1nO2JyZWFrfXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYmFkIHRva2VuIFwiK2YsdGhpcy5maWxlbmFtZSxoWzBdWzBdLGgpO31yZXR1cm4gcH07Yi5wcm90b3R5cGUuc2hpZnQ9ZnVuY3Rpb24oZCxmLGgscCl7dmFyIGc9dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXS5kZmEsYT10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGU7YS5jaGlsZHJlbi5wdXNoKHt0eXBlOmQsdmFsdWU6ZixsaW5lbm86cFswXVswXSxjb2xfb2Zmc2V0OnBbMF1bMV0sY2hpbGRyZW46bnVsbH0pO3RoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV09e2RmYTpnLHN0YXRlOmgsbm9kZTphfX07Yi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihkLGYsaCxwKXtkPXt0eXBlOmQsdmFsdWU6bnVsbCxsaW5lbm86cFswXVswXSxcbmNvbF9vZmZzZXQ6cFswXVsxXSxjaGlsZHJlbjpbXX07dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXT17ZGZhOnRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV0uZGZhLHN0YXRlOmgsbm9kZTp0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGV9O3RoaXMuc3RhY2sucHVzaCh7ZGZhOmYsc3RhdGU6MCxub2RlOmR9KX07Yi5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5zdGFjay5wb3AoKS5ub2RlO2lmKGQpaWYoMCE9PXRoaXMuc3RhY2subGVuZ3RoKXt2YXIgZj10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGU7Zi5jaGlsZHJlbi5wdXNoKGQpfWVsc2UgdGhpcy5yb290bm9kZT1kLHRoaXMucm9vdG5vZGUudXNlZF9uYW1lcz10aGlzLnVzZWRfbmFtZXN9O1NrLnBhcnNlPWZ1bmN0aW9uKGQsZil7dmFyIGg9U2sudG9rZW4udG9rZW5zLlRfQ09NTUVOVCxwPVNrLnRva2VuLnRva2Vucy5UX05MLGc9U2sudG9rZW4udG9rZW5zLlRfT1AsXG5hPVNrLnRva2VuLnRva2Vucy5UX0VORE1BUktFUixjPVNrLnRva2VuLnRva2Vucy5UX0VOQ09ESU5HLG49ITEsbT1lKGQpO1NrLl90b2tlbml6ZShkLGZ1bmN0aW9uKGspe3ZhciB1PWsuc3BsaXQoXCJcXG5cIikucmV2ZXJzZSgpLm1hcChmdW5jdGlvbihsKXtyZXR1cm4gbCtcIlxcblwifSk7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoMD09PXUubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLkV4Y2VwdGlvbihcIkVPRlwiKTtyZXR1cm4gdS5wb3AoKX19KGYpLFwidXRmLThcIixmdW5jdGlvbihrKXt2YXIgdT1udWxsO2sudHlwZSE9PWgmJmsudHlwZSE9PXAmJmsudHlwZSE9PWMmJihrLnR5cGU9PT1nJiYodT1Tay5PcE1hcFtrLnN0cmluZ10pLG0uYWRkdG9rZW4odXx8ay50eXBlLGsuc3RyaW5nLFtrLnN0YXJ0LGsuZW5kLGsubGluZV0pLGsudHlwZT09PWEmJihuPSEwKSl9KTtpZighbil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImluY29tcGxldGUgaW5wdXRcIix0aGlzLmZpbGVuYW1lKTtcbnJldHVybntjc3Q6bS5yb290bm9kZSxmbGFnczptLnBfZmxhZ3N9fTtTay5wYXJzZVRyZWVEdW1wPWZ1bmN0aW9uKGQsZil7dmFyIGg7Zj1mfHxcIlwiO3ZhciBwPVwiXCIrZjtpZigyNTY8PWQudHlwZSlmb3IocCs9U2suUGFyc2VUYWJsZXMubnVtYmVyMnN5bWJvbFtkLnR5cGVdK1wiXFxuXCIsaD0wO2g8ZC5jaGlsZHJlbi5sZW5ndGg7KytoKXArPVNrLnBhcnNlVHJlZUR1bXAoZC5jaGlsZHJlbltoXSxmK1wiICBcIik7ZWxzZSBwKz1Tay50b2tlbi50b2tfbmFtZVtkLnR5cGVdK1wiOiBcIisobmV3IFNrLmJ1aWx0aW4uc3RyKGQudmFsdWUpKS4kcigpLnYrXCJcXG5cIjtyZXR1cm4gcH07U2suZXhwb3J0U3ltYm9sKFwiU2suUGFyc2VyXCIsYik7U2suZXhwb3J0U3ltYm9sKFwiU2sucGFyc2VcIixTay5wYXJzZSk7U2suZXhwb3J0U3ltYm9sKFwiU2sucGFyc2VUcmVlRHVtcFwiLFNrLnBhcnNlVHJlZUR1bXApfSxmdW5jdGlvbihGLFApe1NrLmFzdG5vZGVzPXt9O1NrLmFzdG5vZGVzLkxvYWQ9ZnVuY3Rpb24oKXt9O1xuU2suYXN0bm9kZXMuU3RvcmU9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkRlbD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQXVnTG9hZD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQXVnU3RvcmU9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlBhcmFtPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5BbmQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLk9yPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5BZGQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlN1Yj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTXVsdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTWF0TXVsdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuRGl2PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Nb2Q9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlBvdz1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTFNoaWZ0PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5SU2hpZnQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkJpdE9yPVxuZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkJpdFhvcj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQml0QW5kPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5GbG9vckRpdj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuSW52ZXJ0PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Ob3Q9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlVBZGQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlVTdWI9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkVxPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Ob3RFcT1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTHQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkx0RT1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuR3Q9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkd0RT1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuSXM9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLklzTm90PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Jbj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTm90SW49XG5mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTW9kdWxlPWZ1bmN0aW9uKGIsZSl7dGhpcy5ib2R5PWI7dGhpcy5kb2NzdHJpbmc9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuSW50ZXJhY3RpdmU9ZnVuY3Rpb24oYil7dGhpcy5ib2R5PWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkV4cHJlc3Npb249ZnVuY3Rpb24oYil7dGhpcy5ib2R5PWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlN1aXRlPWZ1bmN0aW9uKGIpe3RoaXMuYm9keT1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZj1mdW5jdGlvbihiLGUsZCxmLGgscCxnLGEpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YSYmdm9pZCAwIT09YSk7dGhpcy5uYW1lPWI7dGhpcy5hcmdzPWU7dGhpcy5ib2R5PWQ7dGhpcy5kZWNvcmF0b3JfbGlzdD1mO3RoaXMucmV0dXJucz1oO3RoaXMuZG9jc3RyaW5nPXA7dGhpcy5saW5lbm89Zzt0aGlzLmNvbF9vZmZzZXQ9XG5hO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmPWZ1bmN0aW9uKGIsZSxkLGYsaCxwLGcsYSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWcmJnZvaWQgMCE9PWcpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1hJiZ2b2lkIDAhPT1hKTt0aGlzLm5hbWU9Yjt0aGlzLmFyZ3M9ZTt0aGlzLmJvZHk9ZDt0aGlzLmRlY29yYXRvcl9saXN0PWY7dGhpcy5yZXR1cm5zPWg7dGhpcy5kb2NzdHJpbmc9cDt0aGlzLmxpbmVubz1nO3RoaXMuY29sX29mZnNldD1hO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5DbGFzc0RlZj1mdW5jdGlvbihiLGUsZCxmLGgscCxnLGEpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1nJiZ2b2lkIDAhPT1nKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YSYmdm9pZCAwIT09YSk7dGhpcy5uYW1lPWI7dGhpcy5iYXNlcz1lO3RoaXMua2V5d29yZHM9ZDt0aGlzLmJvZHk9Zjt0aGlzLmRlY29yYXRvcl9saXN0PWg7dGhpcy5kb2NzdHJpbmc9XG5wO3RoaXMubGluZW5vPWc7dGhpcy5jb2xfb2Zmc2V0PWE7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlJldHVybj1mdW5jdGlvbihiLGUsZCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTt0aGlzLnZhbHVlPWI7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRGVsZXRlPWZ1bmN0aW9uKGIsZSxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO3RoaXMudGFyZ2V0cz1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFzc2lnbj1mdW5jdGlvbihiLGUsZCxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PVxuZik7dGhpcy50YXJnZXRzPWI7dGhpcy52YWx1ZT1lO3RoaXMubGluZW5vPWQ7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkF1Z0Fzc2lnbj1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy50YXJnZXQ9Yjt0aGlzLm9wPWU7dGhpcy52YWx1ZT1kO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWg7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFubkFzc2lnbj1mdW5jdGlvbihiLGUsZCxmLGgscCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWgmJnZvaWQgMCE9PWgpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1wJiZ2b2lkIDAhPT1wKTt0aGlzLnRhcmdldD1iO3RoaXMuYW5ub3RhdGlvbj1lO3RoaXMudmFsdWU9ZDt0aGlzLnNpbXBsZT1mO3RoaXMubGluZW5vPWg7dGhpcy5jb2xfb2Zmc2V0PXA7cmV0dXJuIHRoaXN9O1xuU2suYXN0bm9kZXMuRm9yPWZ1bmN0aW9uKGIsZSxkLGYsaCxwKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PXAmJnZvaWQgMCE9PXApO3RoaXMudGFyZ2V0PWI7dGhpcy5pdGVyPWU7dGhpcy5ib2R5PWQ7dGhpcy5vcmVsc2U9Zjt0aGlzLmxpbmVubz1oO3RoaXMuY29sX29mZnNldD1wO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Bc3luY0Zvcj1mdW5jdGlvbihiLGUsZCxmLGgscCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWgmJnZvaWQgMCE9PWgpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1wJiZ2b2lkIDAhPT1wKTt0aGlzLnRhcmdldD1iO3RoaXMuaXRlcj1lO3RoaXMuYm9keT1kO3RoaXMub3JlbHNlPWY7dGhpcy5saW5lbm89aDt0aGlzLmNvbF9vZmZzZXQ9cDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuV2hpbGU9ZnVuY3Rpb24oYixlLGQsZixoKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmXG52b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy50ZXN0PWI7dGhpcy5ib2R5PWU7dGhpcy5vcmVsc2U9ZDt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1oO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JZj1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy50ZXN0PWI7dGhpcy5ib2R5PWU7dGhpcy5vcmVsc2U9ZDt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1oO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5XaXRoPWZ1bmN0aW9uKGIsZSxkLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5pdGVtcz1iO3RoaXMuYm9keT1lO3RoaXMubGluZW5vPWQ7dGhpcy5jb2xfb2Zmc2V0PVxuZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQXN5bmNXaXRoPWZ1bmN0aW9uKGIsZSxkLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5pdGVtcz1iO3RoaXMuYm9keT1lO3RoaXMubGluZW5vPWQ7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlJhaXNlPWZ1bmN0aW9uKGIsZSxkLGYsaCxwKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PXAmJnZvaWQgMCE9PXApO3RoaXMuZXhjPWI7dGhpcy5jYXVzZT1lO3RoaXMuaW5zdD1kO3RoaXMudGJhY2s9Zjt0aGlzLmxpbmVubz1oO3RoaXMuY29sX29mZnNldD1wO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Ucnk9ZnVuY3Rpb24oYixlLGQsZixoLHApe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1oJiZ2b2lkIDAhPT1oKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XG5wJiZ2b2lkIDAhPT1wKTt0aGlzLmJvZHk9Yjt0aGlzLmhhbmRsZXJzPWU7dGhpcy5vcmVsc2U9ZDt0aGlzLmZpbmFsYm9keT1mO3RoaXMubGluZW5vPWg7dGhpcy5jb2xfb2Zmc2V0PXA7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFzc2VydD1mdW5jdGlvbihiLGUsZCxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMudGVzdD1iO3RoaXMubXNnPWU7dGhpcy5saW5lbm89ZDt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuSW1wb3J0PWZ1bmN0aW9uKGIsZSxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO3RoaXMubmFtZXM9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1kO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JbXBvcnRGcm9tPWZ1bmN0aW9uKGIsXG5lLGQsZixoKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWgmJnZvaWQgMCE9PWgpO3RoaXMubW9kdWxlPWI7dGhpcy5uYW1lcz1lO3RoaXMubGV2ZWw9ZDt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1oO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5HbG9iYWw9ZnVuY3Rpb24oYixlLGQpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7dGhpcy5uYW1lcz1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk5vbmxvY2FsPWZ1bmN0aW9uKGIsZSxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO3RoaXMubmFtZXM9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1cbmQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkV4cHI9ZnVuY3Rpb24oYixlLGQpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7dGhpcy52YWx1ZT1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlBhc3M9ZnVuY3Rpb24oYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkJyZWFrPWZ1bmN0aW9uKGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Db250aW51ZT1cbmZ1bmN0aW9uKGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5QcmludD1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy5kZXN0PWI7dGhpcy52YWx1ZXM9ZTt0aGlzLm5sPWQ7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9aDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRGVidWdnZXI9ZnVuY3Rpb24oYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkJvb2xPcD1cbmZ1bmN0aW9uKGIsZSxkLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5vcD1iO3RoaXMudmFsdWVzPWU7dGhpcy5saW5lbm89ZDt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQmluT3A9ZnVuY3Rpb24oYixlLGQsZixoKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWgmJnZvaWQgMCE9PWgpO3RoaXMubGVmdD1iO3RoaXMub3A9ZTt0aGlzLnJpZ2h0PWQ7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9aDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuVW5hcnlPcD1mdW5jdGlvbihiLGUsZCxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMub3A9Yjt0aGlzLm9wZXJhbmQ9XG5lO3RoaXMubGluZW5vPWQ7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkxhbWJkYT1mdW5jdGlvbihiLGUsZCxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMuYXJncz1iO3RoaXMuYm9keT1lO3RoaXMubGluZW5vPWQ7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLklmRXhwPWZ1bmN0aW9uKGIsZSxkLGYsaCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1oJiZ2b2lkIDAhPT1oKTt0aGlzLnRlc3Q9Yjt0aGlzLmJvZHk9ZTt0aGlzLm9yZWxzZT1kO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWg7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkRpY3Q9ZnVuY3Rpb24oYixlLGQsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PVxuZCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMua2V5cz1iO3RoaXMudmFsdWVzPWU7dGhpcy5saW5lbm89ZDt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuU2V0PWZ1bmN0aW9uKGIsZSxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO3RoaXMuZWx0cz1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkxpc3RDb21wPWZ1bmN0aW9uKGIsZSxkLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5lbHQ9Yjt0aGlzLmdlbmVyYXRvcnM9ZTt0aGlzLmxpbmVubz1kO3RoaXMuY29sX29mZnNldD1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5TZXRDb21wPWZ1bmN0aW9uKGIsXG5lLGQsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTt0aGlzLmVsdD1iO3RoaXMuZ2VuZXJhdG9ycz1lO3RoaXMubGluZW5vPWQ7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkRpY3RDb21wPWZ1bmN0aW9uKGIsZSxkLGYsaCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1oJiZ2b2lkIDAhPT1oKTt0aGlzLmtleT1iO3RoaXMudmFsdWU9ZTt0aGlzLmdlbmVyYXRvcnM9ZDt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1oO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5HZW5lcmF0b3JFeHA9ZnVuY3Rpb24oYixlLGQsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTt0aGlzLmVsdD1cbmI7dGhpcy5nZW5lcmF0b3JzPWU7dGhpcy5saW5lbm89ZDt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQXdhaXQ9ZnVuY3Rpb24oYixlLGQpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7dGhpcy52YWx1ZT1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLllpZWxkPWZ1bmN0aW9uKGIsZSxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO3RoaXMudmFsdWU9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1kO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5ZaWVsZEZyb209ZnVuY3Rpb24oYixlLGQpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XG5kJiZ2b2lkIDAhPT1kKTt0aGlzLnZhbHVlPWI7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ29tcGFyZT1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy5sZWZ0PWI7dGhpcy5vcHM9ZTt0aGlzLmNvbXBhcmF0b3JzPWQ7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9aDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ2FsbD1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy5mdW5jPWI7dGhpcy5hcmdzPWU7dGhpcy5rZXl3b3Jkcz1kO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWg7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk51bT1mdW5jdGlvbihiLFxuZSxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO3RoaXMubj1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlN0cj1mdW5jdGlvbihiLGUsZCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTt0aGlzLnM9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1kO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Gb3JtYXR0ZWRWYWx1ZT1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy52YWx1ZT1iO3RoaXMuY29udmVyc2lvbj1lO3RoaXMuZm9ybWF0X3NwZWM9ZDt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1cbmg7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkpvaW5lZFN0cj1mdW5jdGlvbihiLGUsZCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTt0aGlzLnZhbHVlcz1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkJ5dGVzPWZ1bmN0aW9uKGIsZSxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO3RoaXMucz1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk5hbWVDb25zdGFudD1mdW5jdGlvbihiLGUsZCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTt0aGlzLnZhbHVlPWI7dGhpcy5saW5lbm89XG5lO3RoaXMuY29sX29mZnNldD1kO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5FbGxpcHNpcz1mdW5jdGlvbihiLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1iKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ29uc3RhbnQ9ZnVuY3Rpb24oYixlLGQpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7dGhpcy52YWx1ZT1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkF0dHJpYnV0ZT1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy52YWx1ZT1cbmI7dGhpcy5hdHRyPWU7dGhpcy5jdHg9ZDt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1oO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5TdWJzY3JpcHQ9ZnVuY3Rpb24oYixlLGQsZixoKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWgmJnZvaWQgMCE9PWgpO3RoaXMudmFsdWU9Yjt0aGlzLnNsaWNlPWU7dGhpcy5jdHg9ZDt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1oO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5TdGFycmVkPWZ1bmN0aW9uKGIsZSxkLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy52YWx1ZT1iO3RoaXMuY3R4PWU7dGhpcy5saW5lbm89ZDt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuTmFtZT1mdW5jdGlvbihiLGUsZCxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XG5kJiZ2b2lkIDAhPT1kKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5pZD1iO3RoaXMuY3R4PWU7dGhpcy5saW5lbm89ZDt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuTGlzdD1mdW5jdGlvbihiLGUsZCxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZCYmdm9pZCAwIT09ZCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMuZWx0cz1iO3RoaXMuY3R4PWU7dGhpcy5saW5lbm89ZDt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuVHVwbGU9ZnVuY3Rpb24oYixlLGQsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PWQpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTt0aGlzLmVsdHM9Yjt0aGlzLmN0eD1lO3RoaXMubGluZW5vPWQ7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlNsaWNlPVxuZnVuY3Rpb24oYixlLGQpe3RoaXMubG93ZXI9Yjt0aGlzLnVwcGVyPWU7dGhpcy5zdGVwPWQ7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkV4dFNsaWNlPWZ1bmN0aW9uKGIpe3RoaXMuZGltcz1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JbmRleD1mdW5jdGlvbihiKXt0aGlzLnZhbHVlPWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLmNvbXByZWhlbnNpb249ZnVuY3Rpb24oYixlLGQsZil7dGhpcy50YXJnZXQ9Yjt0aGlzLml0ZXI9ZTt0aGlzLmlmcz1kO3RoaXMuaXNfYXN5bmM9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlcj1mdW5jdGlvbihiLGUsZCxmLGgpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7dGhpcy50eXBlPWI7dGhpcy5uYW1lPWU7dGhpcy5ib2R5PWQ7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9aDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuYXJndW1lbnRzXz1cbmZ1bmN0aW9uKGIsZSxkLGYsaCxwKXt0aGlzLmFyZ3M9Yjt0aGlzLnZhcmFyZz1lO3RoaXMua3dvbmx5YXJncz1kO3RoaXMua3dfZGVmYXVsdHM9Zjt0aGlzLmt3YXJnPWg7dGhpcy5kZWZhdWx0cz1wO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5hcmc9ZnVuY3Rpb24gYihiLGUpe3RoaXMuYXJnPWI7dGhpcy5hbm5vdGF0aW9uPWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLmtleXdvcmQ9ZnVuY3Rpb24oYixlKXt0aGlzLmFyZz1iO3RoaXMudmFsdWU9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuYWxpYXM9ZnVuY3Rpb24oYixlKXt0aGlzLm5hbWU9Yjt0aGlzLmFzbmFtZT1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy53aXRoaXRlbT1mdW5jdGlvbihiLGUpe3RoaXMuY29udGV4dF9leHByPWI7dGhpcy5vcHRpb25hbF92YXJzPWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk1vZHVsZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJNb2R1bGVcIjtTay5hc3Rub2Rlcy5Nb2R1bGUucHJvdG90eXBlLl9maWVsZHM9XG5bXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJkb2NzdHJpbmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kb2NzdHJpbmd9XTtTay5hc3Rub2Rlcy5JbnRlcmFjdGl2ZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJJbnRlcmFjdGl2ZVwiO1NrLmFzdG5vZGVzLkludGVyYWN0aXZlLnByb3RvdHlwZS5fZmllbGRzPVtcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fV07U2suYXN0bm9kZXMuRXhwcmVzc2lvbi5wcm90b3R5cGUuX2FzdG5hbWU9XCJFeHByZXNzaW9uXCI7U2suYXN0bm9kZXMuRXhwcmVzc2lvbi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLlN1aXRlLnByb3RvdHlwZS5fYXN0bmFtZT1cIlN1aXRlXCI7U2suYXN0bm9kZXMuU3VpdGUucHJvdG90eXBlLl9maWVsZHM9W1wiYm9keVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmJvZHl9XTtTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZi5wcm90b3R5cGUuX2FzdG5hbWU9XG5cIkZ1bmN0aW9uRGVmXCI7U2suYXN0bm9kZXMuRnVuY3Rpb25EZWYucHJvdG90eXBlLl9maWVsZHM9W1wibmFtZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm5hbWV9LFwiYXJnc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmFyZ3N9LFwiYm9keVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmJvZHl9LFwiZGVjb3JhdG9yX2xpc3RcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kZWNvcmF0b3JfbGlzdH0sXCJyZXR1cm5zXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIucmV0dXJuc30sXCJkb2NzdHJpbmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kb2NzdHJpbmd9XTtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFzeW5jRnVuY3Rpb25EZWZcIjtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmLnByb3RvdHlwZS5fZmllbGRzPVtcIm5hbWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5uYW1lfSxcImFyZ3NcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hcmdzfSxcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fSxcblwiZGVjb3JhdG9yX2xpc3RcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kZWNvcmF0b3JfbGlzdH0sXCJyZXR1cm5zXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIucmV0dXJuc30sXCJkb2NzdHJpbmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kb2NzdHJpbmd9XTtTay5hc3Rub2Rlcy5DbGFzc0RlZi5wcm90b3R5cGUuX2FzdG5hbWU9XCJDbGFzc0RlZlwiO1NrLmFzdG5vZGVzLkNsYXNzRGVmLnByb3RvdHlwZS5fZmllbGRzPVtcIm5hbWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5uYW1lfSxcImJhc2VzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYmFzZXN9LFwia2V5d29yZHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5rZXl3b3Jkc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJkZWNvcmF0b3JfbGlzdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRlY29yYXRvcl9saXN0fSxcImRvY3N0cmluZ1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRvY3N0cmluZ31dO1NrLmFzdG5vZGVzLlJldHVybi5wcm90b3R5cGUuX2FzdG5hbWU9XG5cIlJldHVyblwiO1NrLmFzdG5vZGVzLlJldHVybi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuRGVsZXRlLnByb3RvdHlwZS5fYXN0bmFtZT1cIkRlbGV0ZVwiO1NrLmFzdG5vZGVzLkRlbGV0ZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0c31dO1NrLmFzdG5vZGVzLkFzc2lnbi5wcm90b3R5cGUuX2FzdG5hbWU9XCJBc3NpZ25cIjtTay5hc3Rub2Rlcy5Bc3NpZ24ucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0c1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRhcmdldHN9LFwidmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLkF1Z0Fzc2lnbi5wcm90b3R5cGUuX2FzdG5hbWU9XCJBdWdBc3NpZ25cIjtTay5hc3Rub2Rlcy5BdWdBc3NpZ24ucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0fSxcblwib3BcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcH0sXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuQW5uQXNzaWduLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFubkFzc2lnblwiO1NrLmFzdG5vZGVzLkFubkFzc2lnbi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi50YXJnZXR9LFwiYW5ub3RhdGlvblwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmFubm90YXRpb259LFwidmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX0sXCJzaW1wbGVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5zaW1wbGV9XTtTay5hc3Rub2Rlcy5Gb3IucHJvdG90eXBlLl9hc3RuYW1lPVwiRm9yXCI7U2suYXN0bm9kZXMuRm9yLnByb3RvdHlwZS5fZmllbGRzPVtcInRhcmdldFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRhcmdldH0sXCJpdGVyXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuaXRlcn0sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXG5cIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX1dO1NrLmFzdG5vZGVzLkFzeW5jRm9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFzeW5jRm9yXCI7U2suYXN0bm9kZXMuQXN5bmNGb3IucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0fSxcIml0ZXJcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVyfSxcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fSxcIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX1dO1NrLmFzdG5vZGVzLldoaWxlLnByb3RvdHlwZS5fYXN0bmFtZT1cIldoaWxlXCI7U2suYXN0bm9kZXMuV2hpbGUucHJvdG90eXBlLl9maWVsZHM9W1widGVzdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRlc3R9LFwiYm9keVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmJvZHl9LFwib3JlbHNlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIub3JlbHNlfV07U2suYXN0bm9kZXMuSWYucHJvdG90eXBlLl9hc3RuYW1lPVwiSWZcIjtcblNrLmFzdG5vZGVzLklmLnByb3RvdHlwZS5fZmllbGRzPVtcInRlc3RcIixmdW5jdGlvbihiKXtyZXR1cm4gYi50ZXN0fSxcImJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5ib2R5fSxcIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX1dO1NrLmFzdG5vZGVzLldpdGgucHJvdG90eXBlLl9hc3RuYW1lPVwiV2l0aFwiO1NrLmFzdG5vZGVzLldpdGgucHJvdG90eXBlLl9maWVsZHM9W1wiaXRlbXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVtc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLkFzeW5jV2l0aC5wcm90b3R5cGUuX2FzdG5hbWU9XCJBc3luY1dpdGhcIjtTay5hc3Rub2Rlcy5Bc3luY1dpdGgucHJvdG90eXBlLl9maWVsZHM9W1wiaXRlbXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVtc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLlJhaXNlLnByb3RvdHlwZS5fYXN0bmFtZT1cIlJhaXNlXCI7XG5Tay5hc3Rub2Rlcy5SYWlzZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJleGNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5leGN9LFwiY2F1c2VcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jYXVzZX0sXCJpbnN0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuaW5zdH0sXCJ0YmFja1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnRiYWNrfV07U2suYXN0bm9kZXMuVHJ5LnByb3RvdHlwZS5fYXN0bmFtZT1cIlRyeVwiO1NrLmFzdG5vZGVzLlRyeS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJoYW5kbGVyc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmhhbmRsZXJzfSxcIm9yZWxzZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9yZWxzZX0sXCJmaW5hbGJvZHlcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5maW5hbGJvZHl9XTtTay5hc3Rub2Rlcy5Bc3NlcnQucHJvdG90eXBlLl9hc3RuYW1lPVwiQXNzZXJ0XCI7U2suYXN0bm9kZXMuQXNzZXJ0LnByb3RvdHlwZS5fZmllbGRzPVtcInRlc3RcIixcbmZ1bmN0aW9uKGIpe3JldHVybiBiLnRlc3R9LFwibXNnXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubXNnfV07U2suYXN0bm9kZXMuSW1wb3J0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkltcG9ydFwiO1NrLmFzdG5vZGVzLkltcG9ydC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm5hbWVzfV07U2suYXN0bm9kZXMuSW1wb3J0RnJvbS5wcm90b3R5cGUuX2FzdG5hbWU9XCJJbXBvcnRGcm9tXCI7U2suYXN0bm9kZXMuSW1wb3J0RnJvbS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJtb2R1bGVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5tb2R1bGV9LFwibmFtZXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5uYW1lc30sXCJsZXZlbFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmxldmVsfV07U2suYXN0bm9kZXMuR2xvYmFsLnByb3RvdHlwZS5fYXN0bmFtZT1cIkdsb2JhbFwiO1NrLmFzdG5vZGVzLkdsb2JhbC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm5hbWVzfV07XG5Tay5hc3Rub2Rlcy5Ob25sb2NhbC5wcm90b3R5cGUuX2FzdG5hbWU9XCJOb25sb2NhbFwiO1NrLmFzdG5vZGVzLk5vbmxvY2FsLnByb3RvdHlwZS5fZmllbGRzPVtcIm5hbWVzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmFtZXN9XTtTay5hc3Rub2Rlcy5FeHByLnByb3RvdHlwZS5fYXN0bmFtZT1cIkV4cHJcIjtTay5hc3Rub2Rlcy5FeHByLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9XTtTay5hc3Rub2Rlcy5QYXNzLnByb3RvdHlwZS5fYXN0bmFtZT1cIlBhc3NcIjtTay5hc3Rub2Rlcy5QYXNzLnByb3RvdHlwZS5fZmllbGRzPVtdO1NrLmFzdG5vZGVzLkJyZWFrLnByb3RvdHlwZS5fYXN0bmFtZT1cIkJyZWFrXCI7U2suYXN0bm9kZXMuQnJlYWsucHJvdG90eXBlLl9maWVsZHM9W107U2suYXN0bm9kZXMuQ29udGludWUucHJvdG90eXBlLl9hc3RuYW1lPVwiQ29udGludWVcIjtTay5hc3Rub2Rlcy5Db250aW51ZS5wcm90b3R5cGUuX2ZpZWxkcz1bXTtcblNrLmFzdG5vZGVzLlByaW50LnByb3RvdHlwZS5fYXN0bmFtZT1cIlByaW50XCI7U2suYXN0bm9kZXMuUHJpbnQucHJvdG90eXBlLl9maWVsZHM9W1wiZGVzdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRlc3R9LFwidmFsdWVzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWVzfSxcIm5sXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmx9XTtTay5hc3Rub2Rlcy5EZWJ1Z2dlci5wcm90b3R5cGUuX2FzdG5hbWU9XCJEZWJ1Z2dlclwiO1NrLmFzdG5vZGVzLkRlYnVnZ2VyLnByb3RvdHlwZS5fZmllbGRzPVtdO1NrLmFzdG5vZGVzLkJvb2xPcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJCb29sT3BcIjtTay5hc3Rub2Rlcy5Cb29sT3AucHJvdG90eXBlLl9maWVsZHM9W1wib3BcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcH0sXCJ2YWx1ZXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZXN9XTtTay5hc3Rub2Rlcy5CaW5PcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJCaW5PcFwiO1NrLmFzdG5vZGVzLkJpbk9wLnByb3RvdHlwZS5fZmllbGRzPVxuW1wibGVmdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmxlZnR9LFwib3BcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcH0sXCJyaWdodFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnJpZ2h0fV07U2suYXN0bm9kZXMuVW5hcnlPcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJVbmFyeU9wXCI7U2suYXN0bm9kZXMuVW5hcnlPcC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJvcFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm9wfSxcIm9wZXJhbmRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcGVyYW5kfV07U2suYXN0bm9kZXMuTGFtYmRhLnByb3RvdHlwZS5fYXN0bmFtZT1cIkxhbWJkYVwiO1NrLmFzdG5vZGVzLkxhbWJkYS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJhcmdzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYXJnc30sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLklmRXhwLnByb3RvdHlwZS5fYXN0bmFtZT1cIklmRXhwXCI7U2suYXN0bm9kZXMuSWZFeHAucHJvdG90eXBlLl9maWVsZHM9W1widGVzdFwiLFxuZnVuY3Rpb24oYil7cmV0dXJuIGIudGVzdH0sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX0sXCJvcmVsc2VcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcmVsc2V9XTtTay5hc3Rub2Rlcy5EaWN0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkRpY3RcIjtTay5hc3Rub2Rlcy5EaWN0LnByb3RvdHlwZS5fZmllbGRzPVtcImtleXNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5rZXlzfSxcInZhbHVlc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlc31dO1NrLmFzdG5vZGVzLlNldC5wcm90b3R5cGUuX2FzdG5hbWU9XCJTZXRcIjtTay5hc3Rub2Rlcy5TZXQucHJvdG90eXBlLl9maWVsZHM9W1wiZWx0c1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmVsdHN9XTtTay5hc3Rub2Rlcy5MaXN0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJMaXN0Q29tcFwiO1NrLmFzdG5vZGVzLkxpc3RDb21wLnByb3RvdHlwZS5fZmllbGRzPVtcImVsdFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmVsdH0sXCJnZW5lcmF0b3JzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuZ2VuZXJhdG9yc31dO1xuU2suYXN0bm9kZXMuU2V0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJTZXRDb21wXCI7U2suYXN0bm9kZXMuU2V0Q29tcC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5lbHR9LFwiZ2VuZXJhdG9yc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmdlbmVyYXRvcnN9XTtTay5hc3Rub2Rlcy5EaWN0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJEaWN0Q29tcFwiO1NrLmFzdG5vZGVzLkRpY3RDb21wLnByb3RvdHlwZS5fZmllbGRzPVtcImtleVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmtleX0sXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfSxcImdlbmVyYXRvcnNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5nZW5lcmF0b3JzfV07U2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwLnByb3RvdHlwZS5fYXN0bmFtZT1cIkdlbmVyYXRvckV4cFwiO1NrLmFzdG5vZGVzLkdlbmVyYXRvckV4cC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5lbHR9LFxuXCJnZW5lcmF0b3JzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuZ2VuZXJhdG9yc31dO1NrLmFzdG5vZGVzLkF3YWl0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkF3YWl0XCI7U2suYXN0bm9kZXMuQXdhaXQucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLllpZWxkLnByb3RvdHlwZS5fYXN0bmFtZT1cIllpZWxkXCI7U2suYXN0bm9kZXMuWWllbGQucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLllpZWxkRnJvbS5wcm90b3R5cGUuX2FzdG5hbWU9XCJZaWVsZEZyb21cIjtTay5hc3Rub2Rlcy5ZaWVsZEZyb20ucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi52YWx1ZX1dO1NrLmFzdG5vZGVzLkNvbXBhcmUucHJvdG90eXBlLl9hc3RuYW1lPVwiQ29tcGFyZVwiO1NrLmFzdG5vZGVzLkNvbXBhcmUucHJvdG90eXBlLl9maWVsZHM9XG5bXCJsZWZ0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubGVmdH0sXCJvcHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5vcHN9LFwiY29tcGFyYXRvcnNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jb21wYXJhdG9yc31dO1NrLmFzdG5vZGVzLkNhbGwucHJvdG90eXBlLl9hc3RuYW1lPVwiQ2FsbFwiO1NrLmFzdG5vZGVzLkNhbGwucHJvdG90eXBlLl9maWVsZHM9W1wiZnVuY1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmZ1bmN9LFwiYXJnc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmFyZ3N9LFwia2V5d29yZHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5rZXl3b3Jkc31dO1NrLmFzdG5vZGVzLk51bS5wcm90b3R5cGUuX2FzdG5hbWU9XCJOdW1cIjtTay5hc3Rub2Rlcy5OdW0ucHJvdG90eXBlLl9maWVsZHM9W1wiblwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLm59XTtTay5hc3Rub2Rlcy5TdHIucHJvdG90eXBlLl9hc3RuYW1lPVwiU3RyXCI7U2suYXN0bm9kZXMuU3RyLnByb3RvdHlwZS5fZmllbGRzPVtcInNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5zfV07XG5Tay5hc3Rub2Rlcy5Gb3JtYXR0ZWRWYWx1ZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJGb3JtYXR0ZWRWYWx1ZVwiO1NrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwiY29udmVyc2lvblwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmNvbnZlcnNpb259LFwiZm9ybWF0X3NwZWNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5mb3JtYXRfc3BlY31dO1NrLmFzdG5vZGVzLkpvaW5lZFN0ci5wcm90b3R5cGUuX2FzdG5hbWU9XCJKb2luZWRTdHJcIjtTay5hc3Rub2Rlcy5Kb2luZWRTdHIucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWVzfV07U2suYXN0bm9kZXMuQnl0ZXMucHJvdG90eXBlLl9hc3RuYW1lPVwiQnl0ZXNcIjtTay5hc3Rub2Rlcy5CeXRlcy5wcm90b3R5cGUuX2ZpZWxkcz1bXCJzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuc31dO1NrLmFzdG5vZGVzLk5hbWVDb25zdGFudC5wcm90b3R5cGUuX2FzdG5hbWU9XG5cIk5hbWVDb25zdGFudFwiO1NrLmFzdG5vZGVzLk5hbWVDb25zdGFudC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuRWxsaXBzaXMucHJvdG90eXBlLl9hc3RuYW1lPVwiRWxsaXBzaXNcIjtTay5hc3Rub2Rlcy5FbGxpcHNpcy5wcm90b3R5cGUuX2ZpZWxkcz1bXTtTay5hc3Rub2Rlcy5Db25zdGFudC5wcm90b3R5cGUuX2FzdG5hbWU9XCJDb25zdGFudFwiO1NrLmFzdG5vZGVzLkNvbnN0YW50LnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9XTtTay5hc3Rub2Rlcy5BdHRyaWJ1dGUucHJvdG90eXBlLl9hc3RuYW1lPVwiQXR0cmlidXRlXCI7U2suYXN0bm9kZXMuQXR0cmlidXRlLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwiYXR0clwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmF0dHJ9LFwiY3R4XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuY3R4fV07XG5Tay5hc3Rub2Rlcy5TdWJzY3JpcHQucHJvdG90eXBlLl9hc3RuYW1lPVwiU3Vic2NyaXB0XCI7U2suYXN0bm9kZXMuU3Vic2NyaXB0LnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwic2xpY2VcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5zbGljZX0sXCJjdHhcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jdHh9XTtTay5hc3Rub2Rlcy5TdGFycmVkLnByb3RvdHlwZS5fYXN0bmFtZT1cIlN0YXJyZWRcIjtTay5hc3Rub2Rlcy5TdGFycmVkLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9LFwiY3R4XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuY3R4fV07U2suYXN0bm9kZXMuTmFtZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJOYW1lXCI7U2suYXN0bm9kZXMuTmFtZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJpZFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlkfSxcImN0eFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmN0eH1dO1NrLmFzdG5vZGVzLkxpc3QucHJvdG90eXBlLl9hc3RuYW1lPVxuXCJMaXN0XCI7U2suYXN0bm9kZXMuTGlzdC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuZWx0c30sXCJjdHhcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5jdHh9XTtTay5hc3Rub2Rlcy5UdXBsZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJUdXBsZVwiO1NrLmFzdG5vZGVzLlR1cGxlLnByb3RvdHlwZS5fZmllbGRzPVtcImVsdHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5lbHRzfSxcImN0eFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmN0eH1dO1NrLmFzdG5vZGVzLkxvYWQucHJvdG90eXBlLl9hc3RuYW1lPVwiTG9hZFwiO1NrLmFzdG5vZGVzLkxvYWQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuU3RvcmUucHJvdG90eXBlLl9hc3RuYW1lPVwiU3RvcmVcIjtTay5hc3Rub2Rlcy5TdG9yZS5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5EZWwucHJvdG90eXBlLl9hc3RuYW1lPVwiRGVsXCI7U2suYXN0bm9kZXMuRGVsLnByb3RvdHlwZS5faXNlbnVtPSEwO1xuU2suYXN0bm9kZXMuQXVnTG9hZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJBdWdMb2FkXCI7U2suYXN0bm9kZXMuQXVnTG9hZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5BdWdTdG9yZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJBdWdTdG9yZVwiO1NrLmFzdG5vZGVzLkF1Z1N0b3JlLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLlBhcmFtLnByb3RvdHlwZS5fYXN0bmFtZT1cIlBhcmFtXCI7U2suYXN0bm9kZXMuUGFyYW0ucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuU2xpY2UucHJvdG90eXBlLl9hc3RuYW1lPVwiU2xpY2VcIjtTay5hc3Rub2Rlcy5TbGljZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJsb3dlclwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmxvd2VyfSxcInVwcGVyXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudXBwZXJ9LFwic3RlcFwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnN0ZXB9XTtTay5hc3Rub2Rlcy5FeHRTbGljZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJFeHRTbGljZVwiO1xuU2suYXN0bm9kZXMuRXh0U2xpY2UucHJvdG90eXBlLl9maWVsZHM9W1wiZGltc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmRpbXN9XTtTay5hc3Rub2Rlcy5JbmRleC5wcm90b3R5cGUuX2FzdG5hbWU9XCJJbmRleFwiO1NrLmFzdG5vZGVzLkluZGV4LnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudmFsdWV9XTtTay5hc3Rub2Rlcy5BbmQucHJvdG90eXBlLl9hc3RuYW1lPVwiQW5kXCI7U2suYXN0bm9kZXMuQW5kLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLk9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIk9yXCI7U2suYXN0bm9kZXMuT3IucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuQWRkLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFkZFwiO1NrLmFzdG5vZGVzLkFkZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5TdWIucHJvdG90eXBlLl9hc3RuYW1lPVwiU3ViXCI7U2suYXN0bm9kZXMuU3ViLnByb3RvdHlwZS5faXNlbnVtPSEwO1xuU2suYXN0bm9kZXMuTXVsdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJNdWx0XCI7U2suYXN0bm9kZXMuTXVsdC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5NYXRNdWx0LnByb3RvdHlwZS5fYXN0bmFtZT1cIk1hdE11bHRcIjtTay5hc3Rub2Rlcy5NYXRNdWx0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkRpdi5wcm90b3R5cGUuX2FzdG5hbWU9XCJEaXZcIjtTay5hc3Rub2Rlcy5EaXYucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTW9kLnByb3RvdHlwZS5fYXN0bmFtZT1cIk1vZFwiO1NrLmFzdG5vZGVzLk1vZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Qb3cucHJvdG90eXBlLl9hc3RuYW1lPVwiUG93XCI7U2suYXN0bm9kZXMuUG93LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkxTaGlmdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJMU2hpZnRcIjtTay5hc3Rub2Rlcy5MU2hpZnQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuUlNoaWZ0LnByb3RvdHlwZS5fYXN0bmFtZT1cblwiUlNoaWZ0XCI7U2suYXN0bm9kZXMuUlNoaWZ0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkJpdE9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIkJpdE9yXCI7U2suYXN0bm9kZXMuQml0T3IucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuQml0WG9yLnByb3RvdHlwZS5fYXN0bmFtZT1cIkJpdFhvclwiO1NrLmFzdG5vZGVzLkJpdFhvci5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5CaXRBbmQucHJvdG90eXBlLl9hc3RuYW1lPVwiQml0QW5kXCI7U2suYXN0bm9kZXMuQml0QW5kLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkZsb29yRGl2LnByb3RvdHlwZS5fYXN0bmFtZT1cIkZsb29yRGl2XCI7U2suYXN0bm9kZXMuRmxvb3JEaXYucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuSW52ZXJ0LnByb3RvdHlwZS5fYXN0bmFtZT1cIkludmVydFwiO1NrLmFzdG5vZGVzLkludmVydC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Ob3QucHJvdG90eXBlLl9hc3RuYW1lPVxuXCJOb3RcIjtTay5hc3Rub2Rlcy5Ob3QucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuVUFkZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJVQWRkXCI7U2suYXN0bm9kZXMuVUFkZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5VU3ViLnByb3RvdHlwZS5fYXN0bmFtZT1cIlVTdWJcIjtTay5hc3Rub2Rlcy5VU3ViLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkVxLnByb3RvdHlwZS5fYXN0bmFtZT1cIkVxXCI7U2suYXN0bm9kZXMuRXEucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTm90RXEucHJvdG90eXBlLl9hc3RuYW1lPVwiTm90RXFcIjtTay5hc3Rub2Rlcy5Ob3RFcS5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5MdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJMdFwiO1NrLmFzdG5vZGVzLkx0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkx0RS5wcm90b3R5cGUuX2FzdG5hbWU9XCJMdEVcIjtTay5hc3Rub2Rlcy5MdEUucHJvdG90eXBlLl9pc2VudW09XG4hMDtTay5hc3Rub2Rlcy5HdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJHdFwiO1NrLmFzdG5vZGVzLkd0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkd0RS5wcm90b3R5cGUuX2FzdG5hbWU9XCJHdEVcIjtTay5hc3Rub2Rlcy5HdEUucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuSXMucHJvdG90eXBlLl9hc3RuYW1lPVwiSXNcIjtTay5hc3Rub2Rlcy5Jcy5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Jc05vdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJJc05vdFwiO1NrLmFzdG5vZGVzLklzTm90LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkluLnByb3RvdHlwZS5fYXN0bmFtZT1cIkluXCI7U2suYXN0bm9kZXMuSW4ucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTm90SW4ucHJvdG90eXBlLl9hc3RuYW1lPVwiTm90SW5cIjtTay5hc3Rub2Rlcy5Ob3RJbi5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5jb21wcmVoZW5zaW9uLnByb3RvdHlwZS5fYXN0bmFtZT1cblwiY29tcHJlaGVuc2lvblwiO1NrLmFzdG5vZGVzLmNvbXByZWhlbnNpb24ucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudGFyZ2V0fSxcIml0ZXJcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5pdGVyfSxcImlmc1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlmc30sXCJpc19hc3luY1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlzX2FzeW5jfV07U2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlci5wcm90b3R5cGUuX2FzdG5hbWU9XCJFeGNlcHRIYW5kbGVyXCI7U2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlci5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0eXBlXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIudHlwZX0sXCJuYW1lXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmFtZX0sXCJib2R5XCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYm9keX1dO1NrLmFzdG5vZGVzLmFyZ3VtZW50c18ucHJvdG90eXBlLl9hc3RuYW1lPVwiYXJndW1lbnRzXCI7U2suYXN0bm9kZXMuYXJndW1lbnRzXy5wcm90b3R5cGUuX2ZpZWxkcz1cbltcImFyZ3NcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hcmdzfSxcInZhcmFyZ1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhcmFyZ30sXCJrd29ubHlhcmdzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIua3dvbmx5YXJnc30sXCJrd19kZWZhdWx0c1wiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmt3X2RlZmF1bHRzfSxcImt3YXJnXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIua3dhcmd9LFwiZGVmYXVsdHNcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5kZWZhdWx0c31dO1NrLmFzdG5vZGVzLmFyZy5wcm90b3R5cGUuX2FzdG5hbWU9XCJhcmdcIjtTay5hc3Rub2Rlcy5hcmcucHJvdG90eXBlLl9maWVsZHM9W1wiYXJnXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIuYXJnfSxcImFubm90YXRpb25cIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hbm5vdGF0aW9ufV07U2suYXN0bm9kZXMua2V5d29yZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJrZXl3b3JkXCI7U2suYXN0bm9kZXMua2V5d29yZC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJhcmdcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hcmd9LFxuXCJ2YWx1ZVwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLnZhbHVlfV07U2suYXN0bm9kZXMuYWxpYXMucHJvdG90eXBlLl9hc3RuYW1lPVwiYWxpYXNcIjtTay5hc3Rub2Rlcy5hbGlhcy5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIubmFtZX0sXCJhc25hbWVcIixmdW5jdGlvbihiKXtyZXR1cm4gYi5hc25hbWV9XTtTay5hc3Rub2Rlcy53aXRoaXRlbS5wcm90b3R5cGUuX2FzdG5hbWU9XCJ3aXRoaXRlbVwiO1NrLmFzdG5vZGVzLndpdGhpdGVtLnByb3RvdHlwZS5fZmllbGRzPVtcImNvbnRleHRfZXhwclwiLGZ1bmN0aW9uKGIpe3JldHVybiBiLmNvbnRleHRfZXhwcn0sXCJvcHRpb25hbF92YXJzXCIsZnVuY3Rpb24oYil7cmV0dXJuIGIub3B0aW9uYWxfdmFyc31dO1NrLmV4cG9ydFN5bWJvbChcIlNrLmFzdG5vZGVzXCIsU2suYXN0bm9kZXMpfSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIoRCx3LEMpe3RoaXMuY19lbmNvZGluZz1EO3RoaXMuY19maWxlbmFtZT13O3RoaXMuY19mbGFncz1cbkN8fDB9ZnVuY3Rpb24gZShEKXtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1ELFwibm9kZSBtdXN0IGJlIGRlZmluZWRcIik7cmV0dXJuIG51bGw9PT1ELmNoaWxkcmVuPzA6RC5jaGlsZHJlbi5sZW5ndGh9ZnVuY3Rpb24gZChELHcpe1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMCE9PUQsXCJub2RlIG11c3QgYmUgZGVmaW5lZFwiKTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT13LFwiaW5kZXggb2YgY2hpbGQgbXVzdCBiZSBzcGVjaWZpZWRcIik7cmV0dXJuIEQuY2hpbGRyZW5bd119ZnVuY3Rpb24gZihELHcpe1NrLmFzc2VydHMuYXNzZXJ0KEQudHlwZT09PXcsXCJub2RlIHdhc24ndCBleHBlY3RlZCB0eXBlXCIpfWZ1bmN0aW9uIGgoRCx3LEMpe3Rocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKEMsRC5jX2ZpbGVuYW1lLHcubGluZW5vKTt9ZnVuY3Rpb24gcChEKXtTay5hc3NlcnRzLmFzc2VydChcInN0cmluZ1wiPT09dHlwZW9mIEQsXCJleHBlY3Rpbmcgc3RyaW5nLCBnb3QgXCIrdHlwZW9mIEQpO1xucmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihEKX1mdW5jdGlvbiBnKEQpe3ZhciB3LEM7c3dpdGNoKEQudHlwZSl7Y2FzZSBPLnNpbmdsZV9pbnB1dDppZihkKEQsMCkudHlwZT09PVYuVF9ORVdMSU5FKWJyZWFrO2Vsc2UgcmV0dXJuIGcoZChELDApKTtjYXNlIE8uZmlsZV9pbnB1dDpmb3Iodz1DPTA7dzxlKEQpOysrdyl7dmFyIEc9ZChELHcpO0cudHlwZT09PU8uc3RtdCYmKEMrPWcoRykpfXJldHVybiBDO2Nhc2UgTy5zdG10OnJldHVybiBnKGQoRCwwKSk7Y2FzZSBPLmNvbXBvdW5kX3N0bXQ6cmV0dXJuIDE7Y2FzZSBPLnNpbXBsZV9zdG10OnJldHVybiBNYXRoLmZsb29yKGUoRCkvMik7Y2FzZSBPLnN1aXRlOmlmKDE9PT1lKEQpKXJldHVybiBnKGQoRCwwKSk7Qz0wO2Zvcih3PTI7dzxlKEQpLTE7Kyt3KUMrPWcoZChELHcpKTtyZXR1cm4gQztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcIk5vbi1zdGF0ZW1lbnQgZm91bmRcIil9cmV0dXJuIDB9ZnVuY3Rpb24gYShELHcsQyxHKXtDIGluc3RhbmNlb2ZcblNrLmJ1aWx0aW4uc3RyJiYoQz1DLnYpO2lmKFwiTm9uZVwiPT09Qyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImFzc2lnbm1lbnQgdG8gTm9uZVwiLEQuY19maWxlbmFtZSxHKTtpZihcIlRydWVcIj09PUN8fFwiRmFsc2VcIj09PUMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhc3NpZ25tZW50IHRvIFRydWUgb3IgRmFsc2UgaXMgZm9yYmlkZGVuXCIsRC5jX2ZpbGVuYW1lLEcpO31mdW5jdGlvbiBjKEQsdyxDLEcpe3ZhciBMO1NrLmFzc2VydHMuYXNzZXJ0KEMhPT1Tay5hc3Rub2Rlcy5BdWdTdG9yZSYmQyE9PVNrLmFzdG5vZGVzLkF1Z0xvYWQsXCJjb250ZXh0IG5vdCBBdWdTdG9yZSBvciBBdWdMb2FkXCIpO3ZhciBLPUw9bnVsbDtzd2l0Y2gody5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5BdHRyaWJ1dGU6Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOkM9PT1Tay5hc3Rub2Rlcy5TdG9yZSYmYShELEcsdy5hdHRyLEcubGluZW5vKTt3LmN0eD1DO2JyZWFrO1xuY2FzZSBTay5hc3Rub2Rlcy5TdGFycmVkOncuY3R4PUM7YyhELHcudmFsdWUsQyxHKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlN1YnNjcmlwdDp3LmN0eD1DO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdDp3LmN0eD1DO0w9dy5lbHRzO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuVHVwbGU6aWYoMD09PXcuZWx0cy5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJjYW4ndCBhc3NpZ24gdG8gKClcIixELmNfZmlsZW5hbWUsRy5saW5lbm8pO3cuY3R4PUM7TD13LmVsdHM7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5MYW1iZGE6Sz1cImxhbWJkYVwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ2FsbDpLPVwiZnVuY3Rpb24gY2FsbFwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQm9vbE9wOmNhc2UgU2suYXN0bm9kZXMuQmluT3A6Y2FzZSBTay5hc3Rub2Rlcy5VbmFyeU9wOks9XCJvcGVyYXRvclwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOks9XCJnZW5lcmF0b3IgZXhwcmVzc2lvblwiO1xuYnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZDpLPVwieWllbGQgZXhwcmVzc2lvblwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdENvbXA6Sz1cImxpc3QgY29tcHJlaGVuc2lvblwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU2V0Q29tcDpLPVwic2V0IGNvbXByZWhlbnNpb25cIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRpY3RDb21wOks9XCJkaWN0IGNvbXByZWhlbnNpb25cIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRpY3Q6Y2FzZSBTay5hc3Rub2Rlcy5TZXQ6Y2FzZSBTay5hc3Rub2Rlcy5OdW06Y2FzZSBTay5hc3Rub2Rlcy5TdHI6Sz1cImxpdGVyYWxcIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudDpLPVwiVHJ1ZSwgRmFsc2Ugb3IgTm9uZVwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ29tcGFyZTpLPVwiY29tcGFyaXNvblwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuUmVwcjpLPVwicmVwclwiO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSWZFeHA6Sz1cImNvbmRpdGlvbmFsIGV4cHJlc3Npb25cIjtcbmJyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGV4cHJlc3Npb24gaW4gYXNzaWdubWVudFwiKX1pZihLKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiY2FuJ3QgXCIrKEM9PT1Tay5hc3Rub2Rlcy5TdG9yZT9cImFzc2lnbiB0b1wiOlwiZGVsZXRlXCIpK1wiIFwiK0ssRC5jX2ZpbGVuYW1lLEcubGluZW5vKTtpZihMKWZvcih3PTA7dzxMLmxlbmd0aDsrK3cpYyhELExbd10sQyxHKX1mdW5jdGlvbiBuKEQpe2lmKHZvaWQgMD09PWZhW0QudHlwZV0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJpbnZhbGlkIHN5bnRheFwiLEQudHlwZSxELmxpbmVubyk7cmV0dXJuIGZhW0QudHlwZV19ZnVuY3Rpb24gbShELHcpe3JldHVybiBELnZhbHVlP25ldyBTay5idWlsdGluLnN0cihELnZhbHVlKTpuZXcgU2suYnVpbHRpbi5zdHIoRCl9ZnVuY3Rpb24gayhELHcpe2YodyxPLmNvbXBfb3ApO2lmKDE9PT1lKHcpKXN3aXRjaCh3PWQodywwKSx3LnR5cGUpe2Nhc2UgVi5UX0xFU1M6cmV0dXJuIFNrLmFzdG5vZGVzLkx0O1xuY2FzZSBWLlRfR1JFQVRFUjpyZXR1cm4gU2suYXN0bm9kZXMuR3Q7Y2FzZSBWLlRfRVFFUVVBTDpyZXR1cm4gU2suYXN0bm9kZXMuRXE7Y2FzZSBWLlRfTEVTU0VRVUFMOnJldHVybiBTay5hc3Rub2Rlcy5MdEU7Y2FzZSBWLlRfR1JFQVRFUkVRVUFMOnJldHVybiBTay5hc3Rub2Rlcy5HdEU7Y2FzZSBWLlRfTk9URVFVQUw6cmV0dXJuIFNrLmFzdG5vZGVzLk5vdEVxO2Nhc2UgVi5UX05BTUU6aWYoXCJpblwiPT09dy52YWx1ZSlyZXR1cm4gU2suYXN0bm9kZXMuSW47aWYoXCJpc1wiPT09dy52YWx1ZSlyZXR1cm4gU2suYXN0bm9kZXMuSXN9ZWxzZSBpZigyPT09ZSh3KSYmZCh3LDApLnR5cGU9PT1WLlRfTkFNRSl7aWYoXCJpblwiPT09ZCh3LDEpLnZhbHVlKXJldHVybiBTay5hc3Rub2Rlcy5Ob3RJbjtpZihcImlzXCI9PT1kKHcsMCkudmFsdWUpcmV0dXJuIFNrLmFzdG5vZGVzLklzTm90fVNrLmFzc2VydHMuZmFpbChcImludmFsaWQgY29tcF9vcFwiKX1mdW5jdGlvbiB1KEQsdyl7RCYmKEQubGluZW5vPVxudy5saW5lbm8sRC5jb2xfb2Zmc2V0PXcuY29sX29mZnNldCxELmVuZF9saW5lbm89dy5lbmRfbGluZW5vLEQuZW5kX2NvbF9vZmZzZXQ9dy5lbmRfY29sX29mZnNldCk7cmV0dXJuIER9ZnVuY3Rpb24gbChELHcpe3ZhciBDLEc9W107U2suYXNzZXJ0cy5hc3NlcnQody50eXBlPT09Ty50ZXN0bGlzdHx8dy50eXBlPT09Ty50ZXN0bGlzdF9zdGFyX2V4cHJ8fHcudHlwZT09PU8ubGlzdG1ha2VyfHx3LnR5cGU9PT1PLnRlc3RsaXN0X2NvbXB8fHcudHlwZT09PU8udGVzdGxpc3Rfc2FmZXx8dy50eXBlPT09Ty50ZXN0bGlzdDEsXCJub2RlIHR5cGUgbXVzdCBiZSBsaXN0bGlrZVwiKTtmb3IoQz0wO0M8ZSh3KTtDKz0yKVNrLmFzc2VydHMuYXNzZXJ0KGQodyxDKS50eXBlPT09Ty50ZXN0fHxkKHcsQykudHlwZT09PU8ub2xkX3Rlc3R8fGQodyxDKS50eXBlPT09Ty5zdGFyX2V4cHIpLEdbQy8yXT1VKEQsZCh3LEMpKTtyZXR1cm4gR31mdW5jdGlvbiBxKEQsdyl7dmFyIEM7Zih3LE8uc3VpdGUpO1xudmFyIEc9W107dmFyIEw9MDtpZihkKHcsMCkudHlwZT09PU8uc2ltcGxlX3N0bXQpe3c9ZCh3LDApO3ZhciBLPWUodyktMTtkKHcsSy0xKS50eXBlPT09Vi5UX1NFTUkmJi0tSztmb3IoQz0wO0M8SztDKz0yKUdbTCsrXT1qYShELGQodyxDKSl9ZWxzZSBmb3IoQz0yO0M8ZSh3KS0xOysrQyl7Sz1kKHcsQyk7ZihLLE8uc3RtdCk7dmFyIE49ZyhLKTtpZigxPT09TilHW0wrK109amEoRCxLKTtlbHNlIGZvcihLPWQoSywwKSxmKEssTy5zaW1wbGVfc3RtdCksTj0wO048ZShLKTtOKz0yKXtpZigwPT09ZShkKEssTikpKXtTay5hc3NlcnRzLmFzc2VydChOKzE9PT1lKEspKTticmVha31HW0wrK109amEoRCxkKEssTikpfX1Tay5hc3NlcnRzLmFzc2VydChMPT09Zyh3KSk7cmV0dXJuIEd9ZnVuY3Rpb24geihELHcsQyl7dmFyIEc7Zih3LE8uZXhwcmxpc3QpO3ZhciBMPVtdO2ZvcihHPTA7RzxlKHcpO0crPTIpe3ZhciBLPVUoRCxkKHcsRykpO0xbRy8yXT1LO0MmJmMoRCxLLEMsZCh3LEcpKX1yZXR1cm4gTH1cbmZ1bmN0aW9uIHIoRCx3KXthOmZvcig7Oylzd2l0Y2gody50eXBlKXtjYXNlIE8uaW1wb3J0X2FzX25hbWU6RD1udWxsO3ZhciBDPXAoZCh3LDApLnZhbHVlKTszPT09ZSh3KSYmKEQ9ZCh3LDIpLnZhbHVlKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKEMsbnVsbD09RD9udWxsOnAoRCkpO2Nhc2UgTy5kb3R0ZWRfYXNfbmFtZTppZigxPT09ZSh3KSl7dz1kKHcsMCk7Y29udGludWUgYX1lbHNlIHJldHVybiBEPXIoRCxkKHcsMCkpLFNrLmFzc2VydHMuYXNzZXJ0KCFELmFzbmFtZSksRC5hc25hbWU9cChkKHcsMikudmFsdWUpLEQ7Y2FzZSBPLmRvdHRlZF9uYW1lOmlmKDE9PT1lKHcpKXJldHVybiBuZXcgU2suYXN0bm9kZXMuYWxpYXMocChkKHcsMCkudmFsdWUpLG51bGwpO0Q9XCJcIjtmb3IoQz0wO0M8ZSh3KTtDKz0yKUQrPWQodyxDKS52YWx1ZStcIi5cIjtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKHAoRC5zdWJzdHIoMCxELmxlbmd0aC0xKSksbnVsbCk7Y2FzZSBWLlRfU1RBUjpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKHAoXCIqXCIpLFxubnVsbCk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInVuZXhwZWN0ZWQgaW1wb3J0IG5hbWVcIixELmNfZmlsZW5hbWUsdy5saW5lbm8pO319ZnVuY3Rpb24gdChELHcpe1NrLmFzc2VydHMuYXNzZXJ0KHcudHlwZT09Ty50ZXN0bGlzdF9jb21wfHx3LnR5cGU9PU8uYXJndW1lbnQpO3JldHVybiBRKEQsdywwKX1mdW5jdGlvbiB4KEQsdyl7aWYoZCh3LDApLnR5cGU9PT1WLlRfTUlOVVMmJjI9PT1lKHcpKXt2YXIgQz1kKHcsMSk7aWYoQy50eXBlPT09Ty5mYWN0b3ImJjE9PT1lKEMpJiYoQz1kKEMsMCksQy50eXBlPT09Ty5wb3dlciYmMT09PWUoQykpKXt2YXIgRz1kKEMsMCk7aWYoRy50eXBlPT09Ty5hdG9tJiYoQz1kKEcsMCksQy50eXBlPT09Vi5UX05VTUJFUikpcmV0dXJuIEMudmFsdWU9XCItXCIrQy52YWx1ZSxpYShELEcpfX1EPVUoRCxkKHcsMSkpO3N3aXRjaChkKHcsMCkudHlwZSl7Y2FzZSBWLlRfUExVUzpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlVuYXJ5T3AoU2suYXN0bm9kZXMuVUFkZCxcbkQsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTtjYXNlIFYuVF9NSU5VUzpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlVuYXJ5T3AoU2suYXN0bm9kZXMuVVN1YixELHcubGluZW5vLHcuY29sX29mZnNldCk7Y2FzZSBWLlRfVElMREU6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5VbmFyeU9wKFNrLmFzdG5vZGVzLkludmVydCxELHcubGluZW5vLHcuY29sX29mZnNldCl9U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGZhY3RvclwiKX1mdW5jdGlvbiB2KEQsdyxDLEcpe3ZhciBMLEssTjtmKHcsTy5hcmdsaXN0KTtmb3IoTD1OPUs9MDtMPGUodyk7TCsrKXt2YXIgUj1kKHcsTCk7Ui50eXBlPT1PLmFyZ3VtZW50JiYoMT09ZShSKT9LKys6ZChSLDEpLnR5cGU9PU8uY29tcF9mb3I/KEsrKyxHfHxoKEQsUixcImludmFsaWQgc3ludGF4XCIpLDE8ZSh3KSYmaChELFIsXCJHZW5lcmF0b3IgZXhwcmVzc2lvbiBtdXN0IGJlIHBhcmVudGhlc2l6ZWRcIikpOmQoUiwwKS50eXBlPT1WLlRfU1RBUj9LKys6TisrKX12YXIgVz1cbltdO3ZhciBUPVtdO2ZvcihMPUc9Tj1LPTA7TDxlKHcpO0wrKylpZihSPWQodyxMKSxSLnR5cGU9PU8uYXJndW1lbnQpe3ZhciBiYT1kKFIsMCk7aWYoMT09ZShSKSl7TiYmKEc/aChELGJhLFwicG9zaXRpb25hbCBhcmd1bWVudCBmb2xsb3dzIGtleXdvcmQgYXJndW1lbnQgdW5wYWNraW5nXCIpOmgoRCxiYSxcInBvc2l0aW9uYWwgYXJndW1lbnQgZm9sbG93cyBrZXl3b3JkIGFyZ3VtZW50XCIpKTt2YXIgWT1VKEQsYmEpO2lmKCFZKXJldHVybiBudWxsO1dbSysrXT1ZfWVsc2UgaWYoYmEudHlwZT09Vi5UX1NUQVIpe2lmKEcpcmV0dXJuIGgoRCxiYSxcIml0ZXJhYmxlIGFyZ3VtZW50IHVucGFja2luZyBmb2xsb3dzIGtleXdvcmQgYXJndW1lbnQgdW5wYWNraW5nXCIpLG51bGw7WT1VKEQsZChSLDEpKTtpZighWSlyZXR1cm4gbnVsbDtSPW5ldyBTay5hc3Rub2Rlcy5TdGFycmVkKFksU2suYXN0bm9kZXMuTG9hZCxiYS5saW5lbm8sYmEuY29sX29mZnNldCk7V1tLKytdPVJ9ZWxzZSBpZihiYS50eXBlPT1cblYuVF9ET1VCTEVTVEFSKXtMKys7WT1VKEQsZChSLDEpKTtpZighWSlyZXR1cm4gbnVsbDtSPW5ldyBTay5hc3Rub2Rlcy5rZXl3b3JkKG51bGwsWSk7VFtOKytdPVI7RysrfWVsc2UgaWYoZChSLDEpLnR5cGU9PU8uY29tcF9mb3Ipe1k9dChELFIpO2lmKCFZKXJldHVybiBudWxsO1dbSysrXT1ZfWVsc2V7dmFyIGRhO1k9VShELGJhKTtpZighWSlyZXR1cm4gbnVsbDtpZihZLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuTGFtYmRhKXJldHVybiBoKEQsYmEsXCJsYW1iZGEgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudFwiKSxudWxsO2lmKFkuY29uc3RydWN0b3IhPT1Tay5hc3Rub2Rlcy5OYW1lKXJldHVybiBoKEQsYmEsXCJrZXl3b3JkIGNhbid0IGJlIGFuIGV4cHJlc3Npb25cIiksbnVsbDtpZihhKEQsWS5pZCxSLDEpKXJldHVybiBudWxsO3ZhciBtYT1ZLmlkO2ZvcihkYT0wO2RhPE47ZGErKylpZigoWT1UW2RhXS5hcmcpJiZZPT09bWEpcmV0dXJuIGgoRCxiYSxcImtleXdvcmQgYXJndW1lbnQgcmVwZWF0ZWRcIiksXG5udWxsO1k9VShELGQoUiwyKSk7aWYoIVkpcmV0dXJuIG51bGw7Uj1uZXcgU2suYXN0bm9kZXMua2V5d29yZChtYSxZKTtUW04rK109Un19cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5DYWxsKEMsVyxULEMubGluZW5vLEMuY29sX29mZnNldCl9ZnVuY3Rpb24gQihELHcsQyl7Zih3LE8udHJhaWxlcik7aWYoZCh3LDApLnR5cGU9PVYuVF9MUEFSKXJldHVybiAyPT1lKHcpP25ldyBTay5hc3Rub2Rlcy5DYWxsKEMsbnVsbCxudWxsLHcubGluZW5vLHcuY29sX29mZnNldCk6dihELGQodywxKSxDLCEwKTtpZihkKHcsMCkudHlwZT09Vi5UX0RPVCl7dmFyIEc9bShkKHcsMSkpO3JldHVybiBHP25ldyBTay5hc3Rub2Rlcy5BdHRyaWJ1dGUoQyxHLFNrLmFzdG5vZGVzLkxvYWQsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTpudWxsfWYoZCh3LDApLFYuVF9MU1FCKTtmKGQodywyKSxWLlRfUlNRQik7dz1kKHcsMSk7aWYoMT09ZSh3KSlyZXR1cm4oRz1sYShELGQodywwKSkpP25ldyBTay5hc3Rub2Rlcy5TdWJzY3JpcHQoQyxcbkcsU2suYXN0bm9kZXMuTG9hZCx3LmxpbmVubyx3LmNvbF9vZmZzZXQpOm51bGw7dmFyIEwsSz0xLE49W107Zm9yKEw9MDtMPGUodyk7TCs9Mil7Rz1sYShELGQodyxMKSk7aWYoIUcpcmV0dXJuIG51bGw7Ry5raW5kIT1aLkluZGV4X2tpbmQmJihLPTApO05bTC8yXT1HfWlmKCFLKXJldHVybiBuZXcgU2suYXN0bm9kZXMuU3Vic2NyaXB0KEMsbmV3IFNrLmFzdG5vZGVzLkV4dFNsaWNlKE4pLFNrLmFzdG5vZGVzLkxvYWQsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTtEPVtdO2ZvcihMPTA7TDxOLmxlbmd0aDsrK0wpRz1OW0xdLFNrLmFzc2VydHMuYXNzZXJ0KEcua2luZD09Wi5JbmRleF9raW5kJiZHLnYuSW5kZXgudmFsdWUpLERbTF09Ry52LkluZGV4LnZhbHVlO0c9bmV3IFNrLmFzdG5vZGVzLlR1cGxlKEQsU2suYXN0bm9kZXMuTG9hZCx3LmxpbmVubyx3LmNvbF9vZmZzZXQpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuU3Vic2NyaXB0KEMsbmV3IFNrLmFzdG5vZGVzLkluZGV4KEcpLFxuU2suYXN0bm9kZXMuTG9hZCx3LmxpbmVubyx3LmNvbF9vZmZzZXQpfWZ1bmN0aW9uIEkoRCx3KXtmKHcsTy5mbG93X3N0bXQpO3ZhciBDPWQodywwKTtzd2l0Y2goQy50eXBlKXtjYXNlIE8uYnJlYWtfc3RtdDpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkJyZWFrKHcubGluZW5vLHcuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk7Y2FzZSBPLmNvbnRpbnVlX3N0bXQ6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Db250aW51ZSh3LmxpbmVubyx3LmNvbF9vZmZzZXQsdy5lbmRfbGluZW5vLHcuZW5kX2NvbF9vZmZzZXQpO2Nhc2UgTy55aWVsZF9zdG10OnJldHVybihEPVUoRCxkKEMsMCkpKT9uZXcgU2suYXN0bm9kZXMuRXhwcihELHcubGluZW5vLHcuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk6bnVsbDtjYXNlIE8ucmV0dXJuX3N0bXQ6aWYoMT09ZShDKSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlJldHVybihudWxsLHcubGluZW5vLFxudy5jb2xfb2Zmc2V0LHcuZW5kX2xpbmVubyx3LmVuZF9jb2xfb2Zmc2V0KTt2YXIgRz1hYShELGQoQywxKSk7cmV0dXJuIEc/bmV3IFNrLmFzdG5vZGVzLlJldHVybihHLHcubGluZW5vLHcuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk6bnVsbDtjYXNlIE8ucmFpc2Vfc3RtdDppZigxPT1lKEMpKXJldHVybiBuZXcgU2suYXN0bm9kZXMuUmFpc2UobnVsbCxudWxsLG51bGwsbnVsbCx3LmxpbmVubyx3LmNvbF9vZmZzZXQsdy5lbmRfbGluZW5vLHcuZW5kX2NvbF9vZmZzZXQpO2lmKDI8PWUoQykpe3ZhciBMPW51bGw7Rz1VKEQsZChDLDEpKTt2YXIgSz1udWxsLE49bnVsbDs0PT1lKEMpJiZcImZyb21cIj09ZChDLDIpLnZhbHVlPyhTay5fX2Z1dHVyZV9fLnB5dGhvbjN8fGgoRCxkKEMsMiksXCJyYWlzZSAuLi4gZnJvbSAuLi4gaXMgbm90IGF2YWlsYWJsZSBpbiBQeXRob24gMlwiKSxMPVUoRCxkKEMsMykpKTo0PD1lKEMpJiZcIixcIj09ZChDLDIpLnZhbHVlJiYoU2suX19mdXR1cmVfXy5weXRob24zJiZcbmgoRCx3LFwiT2xkIHJhaXNlIHN5bnRheCBpcyBub3QgYXZhaWxhYmxlIGluIFB5dGhvbiAzXCIpLEs9VShELGQoQywzKSksNj09ZShDKSYmKE49VShELGQoQyw1KSkpKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlJhaXNlKEcsTCxLLE4sdy5saW5lbm8sdy5jb2xfb2Zmc2V0LHcuZW5kX2xpbmVubyx3LmVuZF9jb2xfb2Zmc2V0KX1kZWZhdWx0OnJldHVybiBTay5hc3NlcnRzLmZhaWwoXCJ1bmV4cGVjdGVkIGZsb3dfc3RtdDogXCIsQy50eXBlKSxudWxsfX1mdW5jdGlvbiBNKEQsdyl7dmFyIEM9bnVsbDtTay5hc3NlcnRzLmFzc2VydCh3LnR5cGU9PT1PLnRmcGRlZnx8dy50eXBlPT09Ty52ZnBkZWYpO3ZhciBHPWQodywwKTthKEQsRyxHLnZhbHVlLEcubGluZW5vKTtHPXAoRy52YWx1ZSk7Mz09ZSh3KSYmZCh3LDEpLnR5cGU9PT1WLlRfQ09MT04mJihDPVUoRCxkKHcsMikpKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFyZyhHLEMsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KX1mdW5jdGlvbiBTKEQsXG53LEMsRyxMKXt2YXIgSz1DLE49MDtHfHxoKEQsZCh3LEMpLFwibmFtZWQgYXJndW1lbnRzIG11c3QgZm9sbG93IGJhcmUgKlwiKTtmb3IoU2suYXNzZXJ0cy5hc3NlcnQoTCk7SzxlKHcpOyl7dmFyIFI9ZCh3LEspO3N3aXRjaChSLnR5cGUpe2Nhc2UgTy52ZnBkZWY6Y2FzZSBPLnRmcGRlZjpLKzE8ZSh3KSYmZCh3LEsrMSkudHlwZT09Vi5UX0VRVUFMPyhMW05dPVUoRCxkKHcsSysyKSksSys9Mik6TFtOXT1udWxsO3ZhciBXPTM9PWUoUik/VShELGQoUiwyKSk6bnVsbDtSPWQoUiwwKTthKEQsUixSLnZhbHVlLFIubGluZW5vKTtDPXAoUi52YWx1ZSk7R1tOKytdPW5ldyBTay5hc3Rub2Rlcy5hcmcoQyxXLFIubGluZW5vLFIuY29sX29mZnNldCk7Sys9MjticmVhaztjYXNlIFYuVF9ET1VCTEVTVEFSOnJldHVybiBLO2RlZmF1bHQ6aChELFIsXCJ1bmV4cGVjdGVkIG5vZGVcIil9fXJldHVybiBLfWZ1bmN0aW9uIEUoRCx3KXt2YXIgQyxHLEwsSz1bXSxOPVtdLFI9W10sVz1bXSxUPW51bGwsXG5iYT1udWxsO2lmKHcudHlwZT09PU8ucGFyYW1ldGVycyl7aWYoMj09PWUodykpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5hcmd1bWVudHNfKFtdLG51bGwsW10sW10sbnVsbCxbXSk7dz1kKHcsMSl9U2suYXNzZXJ0cy5hc3NlcnQody50eXBlPT09Ty52YXJhcmdzbGlzdHx8dy50eXBlPT09Ty50eXBlZGFyZ3NsaXN0KTtmb3IoQz1HPUw9MDtMPGUodyk7KXt2YXIgWT1kKHcsTCk7c3dpdGNoKFkudHlwZSl7Y2FzZSBPLnRmcGRlZjpjYXNlIE8udmZwZGVmOmlmKEwrMTxlKHcpJiZkKHcsTCsxKS50eXBlPT1WLlRfRVFVQUwpe05bRysrXT1VKEQsZCh3LEwrMikpO0wrPTI7dmFyIGRhPTF9ZWxzZSBpZihkYSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5vbi1kZWZhdWx0IGFyZ3VtZW50IGZvbGxvd3MgZGVmYXVsdCBhcmd1bWVudFwiLEQuY19maWxlbmFtZSx3LmxpbmVubyk7S1tDKytdPU0oRCxZKTtMKz0yO2JyZWFrO2Nhc2UgVi5UX1NUQVI6aWYoTCsxPj1lKHcpfHxMK1xuMj09ZSh3KSYmZCh3LEwrMSkudHlwZT09Vi5UX0NPTU1BKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwibmFtZWQgYXJndW1lbnRzIG11c3QgZm9sbG93IGJhcmUgKlwiLEQuY19maWxlbmFtZSx3LmxpbmVubyk7WT1kKHcsTCsxKTtZLnR5cGU9PVYuVF9DT01NQT8oTCs9MixMPVMoRCx3LEwsUixXKSk6KFQ9TShELFkpLEwrPTMsTDxlKHcpJiYoZCh3LEwpLnR5cGU9PU8udGZwZGVmfHxkKHcsTCkudHlwZT09Ty52ZnBkZWYpJiYoTD1TKEQsdyxMLFIsVykpKTticmVhaztjYXNlIFYuVF9ET1VCTEVTVEFSOlk9ZCh3LEwrMSk7U2suYXNzZXJ0cy5hc3NlcnQoWS50eXBlPT1PLnRmcGRlZnx8WS50eXBlPT1PLnZmcGRlZik7YmE9TShELFkpO0wrPTM7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmV4cGVjdGVkIG5vZGUgaW4gdmFyYXJnc2xpc3RcIik7cmV0dXJufX1yZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFyZ3VtZW50c18oSyxULFIsVyxiYSxOKX1mdW5jdGlvbiBIKEQsXG53LEMsRyl7dmFyIEw9Rz9kKHcsMSk6dyxLPW51bGwsTj0xLFI9bnVsbDtpZihHJiY1PkQuY19mZWF0dXJlX3ZlcnNpb24pcmV0dXJuIGgoRCxMLFwiQXN5bmMgZnVuY3Rpb25zIGFyZSBvbmx5IHN1cHBvcnRlZCBpbiBQeXRob24gMy41IGFuZCBncmVhdGVyXCIpLG51bGw7ZihMLE8uZnVuY2RlZik7dmFyIFc9bShkKEwsTikpO2lmKGEoRCxXLGQoTCxOKSwwKSlyZXR1cm4gbnVsbDt2YXIgVD1FKEQsZChMLE4rMSkpO2lmKCFUKXJldHVybiBudWxsO2lmKGQoTCxOKzIpLnR5cGU9PVYuVF9SQVJST1cpe0s9VShELGQoTCxOKzMpKTtpZighSylyZXR1cm4gbnVsbDtOKz0yfWlmKGQoTCxOKzMpLnR5cGU9PVYuVF9UWVBFX0NPTU1FTlQpe1I9Vi5UX05FV19UWVBFX0NPTU1FTlQoZChMLE4rMykpO2lmKCFSKXJldHVybiBudWxsO04rPTF9dmFyIGJhPXEoRCxkKEwsTiszKSk7aWYoIWJhKXJldHVybiBudWxsO2lmKDE8ZShkKEwsTiszKSkmJihOPWQoZChMLE4rMyksMSksTi50eXBlPT1WLlRfVFlQRV9DT01NRU5UKSl7aWYobnVsbCE9XG5SKXJldHVybiBoKEQsTCxcIkNhbm5vdCBoYXZlIHR3byB0eXBlIGNvbW1lbnRzIG9uIGRlZlwiKSxudWxsO1I9Vi5UX05FV19UWVBFX0NPTU1FTlQoTik7aWYoIVIpcmV0dXJuIG51bGx9cmV0dXJuIEc/bmV3IFNrLmFzdG5vZGVzLkFzeW5jRnVuY3Rpb25EZWYoVyxULGJhLEMsSyxSLHcubGluZW5vLHcuY29sX29mZnNldCx2b2lkIDAsdm9pZCAwKTpuZXcgU2suYXN0bm9kZXMuRnVuY3Rpb25EZWYoVyxULGJhLEMsSyxSLEwubGluZW5vLEwuY29sX29mZnNldCx2b2lkIDAsdm9pZCAwKX1mdW5jdGlvbiB5KEQsdyxDKXtmKHcsTy5jbGFzc2RlZik7aWYoND09ZSh3KSl7dmFyIEc9cShELGQodywzKSk7dmFyIEw9bShkKHcsMSkudmFsdWUpO2EoRCxkKHcsMyksTCx3LmxpbmVubyk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5DbGFzc0RlZihMLFtdLFtdLEcsQyxudWxsLHcubGluZW5vLHcuY29sX29mZnNldCl9aWYoZCh3LDMpLnR5cGU9PT1WLlRfUlBBUilyZXR1cm4gRz1xKEQsZCh3LDUpKSxcbkw9bShkKHcsMSkudmFsdWUpLGEoRCxkKHcsMyksTCxkKHcsMykubGluZW5vKSxuZXcgU2suYXN0bm9kZXMuQ2xhc3NEZWYoTCxbXSxbXSxHLEMsbnVsbCx3LmxpbmVubyx3LmNvbF9vZmZzZXQpO0w9bShkKHcsMSkpO0w9bmV3IFNrLmFzdG5vZGVzLk5hbWUoTCxTay5hc3Rub2Rlcy5Mb2FkLHcubGluZW5vLHcuY29sX29mZnNldCk7dmFyIEs9dihELGQodywzKSxMLCExKTtHPXEoRCxkKHcsNikpO0w9bShkKHcsMSkudmFsdWUpO2EoRCxkKHcsMSksTCxkKHcsMSkubGluZW5vKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkNsYXNzRGVmKEwsSy5hcmdzLEsua2V5d29yZHMsRyxDLG51bGwsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KX1mdW5jdGlvbiBBKEQsdyl7ZnVuY3Rpb24gQyhZLGRhKXtmb3IoWT0wOzspe2YoZGEsTy5jb21wX2l0ZXIpO2lmKGQoZGEsMCkudHlwZT09PU8uY29tcF9mb3IpcmV0dXJuIFk7ZGE9ZChkYSwwKTtmKGRhLE8uY29tcF9pZik7WSsrO2lmKDI9PT1lKGRhKSlyZXR1cm4gWTtcbmRhPWQoZGEsMil9fXZhciBHO3ZhciBMPWZ1bmN0aW9uKFksZGEpe1k9MDthOmZvcig7Oyl7WSsrO2YoZGEsTy5jb21wX2Zvcik7aWYoNT09PWUoZGEpKWRhPWQoZGEsNCk7ZWxzZSByZXR1cm4gWTtiOmZvcig7Oyl7ZihkYSxPLmNvbXBfaXRlcik7ZGE9ZChkYSwwKTtpZihkYS50eXBlPT09Ty5jb21wX2Zvciljb250aW51ZSBhO2Vsc2UgaWYoZGEudHlwZT09PU8uY29tcF9pZilpZigzPT09ZShkYSkpe2RhPWQoZGEsMik7Y29udGludWUgYn1lbHNlIHJldHVybiBZO2JyZWFrfWJyZWFrfVNrLmFzc2VydHMuZmFpbChcImxvZ2ljIGVycm9yIGluIGNvdW50Q29tcEZvcnNcIil9KEQsdyk7dmFyIEs9W107Zm9yKEc9MDtHPEw7KytHKXtmKHcsTy5jb21wX2Zvcik7dmFyIE49ZCh3LDEpO3ZhciBSPXooRCxOLFNrLmFzdG5vZGVzLlN0b3JlKTt2YXIgVz1VKEQsZCh3LDMpKTt2YXIgVD0xPT09ZShOKT9uZXcgU2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbihSWzBdLFcsW10pOm5ldyBTay5hc3Rub2Rlcy5jb21wcmVoZW5zaW9uKG5ldyBTay5hc3Rub2Rlcy5UdXBsZShSLFxuU2suYXN0bm9kZXMuU3RvcmUsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KSxXLFtdKTtpZig1PT09ZSh3KSl7dz1kKHcsNCk7dmFyIGJhPUMoRCx3KTtOPVtdO2ZvcihSPTA7UjxiYTsrK1IpZih3LE8uY29tcF9pdGVyKSx3PWQodywwKSxmKHcsTy5jb21wX2lmKSxXPVUoRCxkKHcsMSkpLE5bUl09VywzPT09ZSh3KSYmKHc9ZCh3LDIpKTt3LnR5cGU9PT1PLmNvbXBfaXRlciYmKHc9ZCh3LDApKTtULmlmcz1OfUtbR109VH1yZXR1cm4gS31mdW5jdGlvbiBKKEQsdyl7dmFyIEM9W107YTp7dmFyIEc9dzt2YXIgTD0wO2I6Zm9yKDs7KXt2YXIgSz0wO0wrKztmKEcsTy5jb21wX2Zvcik7ZChHLDApLnR5cGU9PVYuVF9BU1lOQyYmKEs9MSk7aWYoZShHKT09NStLKUc9ZChHLDQrSyk7ZWxzZSBicmVhayBhO2M6Zm9yKDs7KXtmKEcsTy5jb21wX2l0ZXIpO0c9ZChHLDApO2lmKEcudHlwZT09PU8uY29tcF9mb3IpY29udGludWUgYjtlbHNlIGlmKEcudHlwZT09PU8uY29tcF9pZilpZigzPT09ZShHKSl7Rz1cbmQoRywyKTtjb250aW51ZSBjfWVsc2UgYnJlYWsgYTticmVha31icmVha31MPXZvaWQgMH1mb3IoRz0wO0c8TDtHKyspe3ZhciBOPTA7ZCh3LDApLnR5cGU9PVYuVF9BU1lOQyYmKE49MSk7dmFyIFI9ZCh3LDErTik7dmFyIFc9eihELFIsU2suYXN0bm9kZXMuU3RvcmUpO2lmKCFXKXJldHVybiBudWxsO0s9VShELGQodywzK04pKTtpZighSylyZXR1cm4gbnVsbDt2YXIgVD1XWzBdO1c9MT09ZShSKT9uZXcgU2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbihULEssbnVsbCxOKTpuZXcgU2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbihuZXcgU2suYXN0bm9kZXMuVHVwbGUoVyxTay5hc3Rub2Rlcy5TdG9yZSxULmxpbmVubyxULmNvbF9vZmZzZXQsUi5lbmRfbGluZW5vLFIuZW5kX2NvbF9vZmZzZXQpLEssbnVsbCxOKTtpZihlKHcpPT01K04pe1Q9W107dz1kKHcsNCtOKTthOmZvcihLPXcsTj0wOzspe2YoSyxPLmNvbXBfaXRlcik7aWYoZChLLDApLnR5cGU9PU8uY29tcF9mb3Ipe1I9TjticmVhayBhfUs9XG5kKEssMCk7ZihLLE8uY29tcF9pZik7TisrO2lmKDI9PWUoSykpe1I9TjticmVhayBhfUs9ZChLLDIpfWlmKC0xPT1SKXJldHVybiBudWxsO2ZvcihOPTA7TjxSO04rKyl7Zih3LE8uY29tcF9pdGVyKTt3PWQodywwKTtmKHcsTy5jb21wX2lmKTtLPVUoRCxkKHcsMSkpO2lmKCFLKXJldHVybiBudWxsO1RbTl09SzszPT1lKHcpJiYodz1kKHcsMikpfXcudHlwZT09Ty5jb21wX2l0ZXImJih3PWQodywwKSk7Vy5pZnM9VH1DW0ddPVd9cmV0dXJuIEN9ZnVuY3Rpb24gUShELHcsQyl7U2suYXNzZXJ0cy5hc3NlcnQoMTxlKHcpKTt2YXIgRz1kKHcsMCk7dmFyIEw9VShELEcpO2lmKEwuY29uc3RydWN0b3I9PT1Tay5hc3Rub2Rlcy5TdGFycmVkKXJldHVybiBoKEQsRyxcIml0ZXJhYmxlIHVucGFja2luZyBjYW5ub3QgYmUgdXNlZCBpbiBjb21wcmVoZW5zaW9uXCIpLG51bGw7RD1KKEQsZCh3LDEpKTtyZXR1cm4gMD09Qz9uZXcgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwKEwsRCx3LmxpbmVubyxcbncuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk6MT09Qz9uZXcgU2suYXN0bm9kZXMuTGlzdENvbXAoTCxELHcubGluZW5vLHcuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk6Mj09Qz9uZXcgU2suYXN0bm9kZXMuU2V0Q29tcChMLEQsdy5saW5lbm8sdy5jb2xfb2Zmc2V0LHcuZW5kX2xpbmVubyx3LmVuZF9jb2xfb2Zmc2V0KTpudWxsfWZ1bmN0aW9uIFgoRCx3KXtmKHcsTy5hdWdhc3NpZ24pO3c9ZCh3LDApO3N3aXRjaCh3LnZhbHVlLmNoYXJBdCgwKSl7Y2FzZSBcIitcIjpyZXR1cm4gU2suYXN0bm9kZXMuQWRkO2Nhc2UgXCItXCI6cmV0dXJuIFNrLmFzdG5vZGVzLlN1YjtjYXNlIFwiL1wiOnJldHVyblwiL1wiPT09dy52YWx1ZS5jaGFyQXQoMSk/U2suYXN0bm9kZXMuRmxvb3JEaXY6U2suYXN0bm9kZXMuRGl2O2Nhc2UgXCIlXCI6cmV0dXJuIFNrLmFzdG5vZGVzLk1vZDtjYXNlIFwiPFwiOnJldHVybiBTay5hc3Rub2Rlcy5MU2hpZnQ7Y2FzZSBcIj5cIjpyZXR1cm4gU2suYXN0bm9kZXMuUlNoaWZ0O1xuY2FzZSBcIiZcIjpyZXR1cm4gU2suYXN0bm9kZXMuQml0QW5kO2Nhc2UgXCJeXCI6cmV0dXJuIFNrLmFzdG5vZGVzLkJpdFhvcjtjYXNlIFwifFwiOnJldHVybiBTay5hc3Rub2Rlcy5CaXRPcjtjYXNlIFwiKlwiOnJldHVyblwiKlwiPT09dy52YWx1ZS5jaGFyQXQoMSk/U2suYXN0bm9kZXMuUG93OlNrLmFzdG5vZGVzLk11bHQ7Y2FzZSBcIkBcIjppZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpcmV0dXJuIFNrLmFzdG5vZGVzLk1hdE11bHQ7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJpbnZhbGlkIGF1Z2Fzc2lnblwiKX19ZnVuY3Rpb24gYWEoRCx3KXtTay5hc3NlcnRzLmFzc2VydCgwPGUodykpO3cudHlwZT09PU8udGVzdGxpc3RfY29tcD8xPGUodykmJlNrLmFzc2VydHMuYXNzZXJ0KGQodywxKS50eXBlIT09Ty5jb21wX2Zvcik6U2suYXNzZXJ0cy5hc3NlcnQody50eXBlPT09Ty50ZXN0bGlzdHx8dy50eXBlPT09Ty50ZXN0bGlzdF9zdGFyX2V4cHIpO3JldHVybiAxPT09ZSh3KT9VKEQsZCh3LDApKTpcbm5ldyBTay5hc3Rub2Rlcy5UdXBsZShsKEQsdyksU2suYXN0bm9kZXMuTG9hZCx3LmxpbmVubyx3LmNvbF9vZmZzZXQpfWZ1bmN0aW9uIGVhKEQsdyl7Zih3LE8uZXhwcl9zdG10KTtpZigxPT09ZSh3KSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkV4cHIoYWEoRCxkKHcsMCkpLHcubGluZW5vLHcuY29sX29mZnNldCk7aWYoZCh3LDEpLnR5cGU9PT1PLmF1Z2Fzc2lnbil7dmFyIEM9ZCh3LDApO3ZhciBHPWFhKEQsQyk7YyhELEcsU2suYXN0bm9kZXMuU3RvcmUsQyk7c3dpdGNoKEcuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuTmFtZTp2YXIgTD1HLmlkO2EoRCxDLEwsdy5saW5lbm8pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOmNhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYXVnbWVudGVkIGFzc2lnbm1lbnQgdG8gZ2VuZXJhdG9yIGV4cHJlc3Npb24gbm90IHBvc3NpYmxlXCIsXG5ELmNfZmlsZW5hbWUsdy5saW5lbm8pO2Nhc2UgU2suYXN0bm9kZXMuWWllbGQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhdWdtZW50ZWQgYXNzaWdubWVudCB0byB5aWVsZCBleHByZXNzaW9uIG5vdCBwb3NzaWJsZVwiLEQuY19maWxlbmFtZSx3LmxpbmVubyk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImlsbGVnYWwgZXhwcmVzc2lvbiBmb3IgYXVnbWVudGVkIGFzc2lnbm1lbnRcIixELmNfZmlsZW5hbWUsdy5saW5lbm8pO31DPWQodywyKTtMPUMudHlwZT09PU8udGVzdGxpc3Q/YWEoRCxDKTpVKEQsQyk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5BdWdBc3NpZ24oRyxYKEQsZCh3LDEpKSxMLHcubGluZW5vLHcuY29sX29mZnNldCl9aWYoZCh3LDEpLnR5cGU9PT1PLmFubmFzc2lnbil7aWYoIVNrLl9fZnV0dXJlX18ucHl0aG9uMyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIkFubm90YXRlZCBhc3NpZ25tZW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIixcbkQuY19maWxlbmFtZSx3LmxpbmVubyk7Qz1kKHcsMCk7dmFyIEs9ZCh3LDEpO3ZhciBOPTE7Zm9yKEc9QzsxPT1lKEcpOylHPWQoRywwKTswPGUoRykmJmQoRywwKS50eXBlPT1WLlRfTFBBUiYmKE49MCk7Rz1hYShELEMpO3N3aXRjaChHLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLk5hbWU6TD1HLmlkO2EoRCxDLEwsdy5saW5lbm8pO2MoRCxHLFNrLmFzdG5vZGVzLlN0b3JlLEMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOkw9Ry5hdHRyO2EoRCxDLEwsdy5saW5lbm8pO2MoRCxHLFNrLmFzdG5vZGVzLlN0b3JlLEMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OmMoRCxHLFNrLmFzdG5vZGVzLlN0b3JlLEMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm9ubHkgc2luZ2xlIHRhcmdldCAobm90IGxpc3QpIGNhbiBiZSBhbm5vdGF0ZWRcIixELmNfZmlsZW5hbWUsdy5saW5lbm8pO1xuY2FzZSBTay5hc3Rub2Rlcy5UdXBsZTp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm9ubHkgc2luZ2xlIHRhcmdldCAobm90IHR1cGxlKSBjYW4gYmUgYW5ub3RhdGVkXCIsRC5jX2ZpbGVuYW1lLHcubGluZW5vKTtkZWZhdWx0OnRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaWxsZWdhbCB0YXJnZXQgZm9yIGFubm90YXRpb25cIixELmNfZmlsZW5hbWUsdy5saW5lbm8pO31HLmNvbnN0cnVjdG9yIT1Tay5hc3Rub2Rlcy5OYW1lJiYoTj0wKTtDPWQoSywxKTtMPVUoRCxDKTtpZigyPT1lKEspKXJldHVybiBuZXcgU2suYXN0bm9kZXMuQW5uQXNzaWduKEcsTCxudWxsLE4sdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTtDPWQoSywzKTtEPVUoRCxDKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkFubkFzc2lnbihHLEwsRCxOLHcubGluZW5vLHcuY29sX29mZnNldCl9ZihkKHcsMSksVi5UX0VRVUFMKTtOPVtdO2ZvcihHPTA7RzxlKHcpLTI7Rys9Mil7Qz1kKHcsRyk7aWYoQy50eXBlPT09XG5PLnlpZWxkX2V4cHIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhc3NpZ25tZW50IHRvIHlpZWxkIGV4cHJlc3Npb24gbm90IHBvc3NpYmxlXCIsRC5jX2ZpbGVuYW1lLHcubGluZW5vKTtDPWFhKEQsQyk7YyhELEMsU2suYXN0bm9kZXMuU3RvcmUsZCh3LEcpKTtOW0cvMl09Q31DPWQodyxlKHcpLTEpO0Q9Qy50eXBlPT09Ty50ZXN0bGlzdF9zdGFyX2V4cHI/YWEoRCxDKTpVKEQsQyk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Bc3NpZ24oTixELHcubGluZW5vLHcuY29sX29mZnNldCl9ZnVuY3Rpb24gbmEoRCx3LEMsRyxMKXtTay5hc3NlcnRzLmFzc2VydChDPj13KTtTay5hc3NlcnRzLmFzc2VydChcIntcIj09RC5jaGFyQXQody0xKSk7U2suYXNzZXJ0cy5hc3NlcnQoXCJ9XCI9PUQuY2hhckF0KEMpfHxcIiFcIj09RC5jaGFyQXQoQyl8fFwiOlwiPT1ELmNoYXJBdChDKSk7RD1ELnN1YnN0cmluZyh3LEMpOy9eXFxzKiQvLnRlc3QoRCkmJmgoRyxMLFwiZi1zdHJpbmc6IGVtcHR5IGV4cHJlc3Npb24gbm90IGFsbG93ZWRcIik7XG50cnl7bGV0IE49U2sucGFyc2UoXCI8ZnN0cmluZz5cIixcIihcIitEK1wiKVwiKTt2YXIgSz1Tay5hc3RGcm9tUGFyc2UoTi5jc3QsXCI8ZnN0cmluZz5cIixOLmZsYWdzKX1jYXRjaChOKXt0aHJvdyBOLnRyYWNlYmFjayYmTi50cmFjZWJhY2tbMF0mJihLPU4udHJhY2ViYWNrWzBdLEsubGluZW5vPShLLmxpbmVub3x8MSktMStMLmxpbmVubyxLLmZpbGVuYW1lPUcuY19maWxlbmFtZSksTjt9U2suYXNzZXJ0cy5hc3NlcnQoMT09Sy5ib2R5Lmxlbmd0aCYmSy5ib2R5WzBdLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuRXhwcik7cmV0dXJuIEsuYm9keVswXS52YWx1ZX1mdW5jdGlvbiBvYShELHcsQyxHLEwsSyxOKXtTay5hc3NlcnRzLmFzc2VydChcIntcIj09RC5jaGFyQXQodykpO3crKzt2YXIgUj13O2xldCBXPW51bGwsVD0wLGJhPTAsWSxkYSxtYT0oKT0+aChLLE4sXCJmLXN0cmluZzogZXhwZWN0aW5nICd9J1wiKTtmb3IoU2suYXNzZXJ0cy5hc3NlcnQodzw9Qyk7dzxDO3crKyl7bGV0IGhhPUQuY2hhckF0KHcpO1xuXCJcXFxcXCI9PWhhJiZoKEssTixcImYtc3RyaW5nIGV4cHJlc3Npb24gcGFydCBjYW5ub3QgaW5jbHVkZSBhIGJhY2tzbGFzaFwiKTtpZihXKWhhPT1XJiYoMz09VD93KzI8QyYmRC5jaGFyQXQodysxKT09aGEmJkQuY2hhckF0KHcrMik9PWhhJiYodys9MixXPVQ9MCk6VD1XPTApO2Vsc2UgaWYoXCInXCI9PWhhfHwnXCInPT1oYSl3KzI8QyYmRC5jaGFyQXQodysxKT09aGEmJkQuY2hhckF0KHcrMik9PWhhPyhUPTMsdys9Mik6VD0xLFc9aGE7ZWxzZSBpZihcIltcIj09aGF8fFwie1wiPT1oYXx8XCIoXCI9PWhhKWJhKys7ZWxzZSBpZigwIT1iYSYmKFwiXVwiPT1oYXx8XCJ9XCI9PWhhfHxcIilcIj09aGEpKWJhLS07ZWxzZSBpZihcIiNcIj09aGEpaChLLE4sXCJmLXN0cmluZyBleHByZXNzaW9uIHBhcnQgY2Fubm90IGluY2x1ZGUgJyMnXCIpO2Vsc2UgaWYoISgwIT1iYXx8XCIhXCIhPWhhJiZcIjpcIiE9aGEmJlwifVwiIT1oYXx8XCIhXCI9PWhhJiZ3KzE8QyYmXCI9XCI9PUQuY2hhckF0KHcrMSkpKWJyZWFrfVcmJmgoSyxOLFwiZi1zdHJpbmc6IHVudGVybWluYXRlZCBzdHJpbmdcIik7XG5iYSYmaChLLE4sXCJmLXN0cmluZzogbWlzbWF0Y2hlZCAnKCcsICd7Jywgb3IgJ1snXCIpO1I9bmEoRCxSLHcsSyxOKTtcIiFcIj09RC5jaGFyQXQodykmJih3Kyssdz49QyYmbWEoKSxkYT1ELmNoYXJBdCh3KSx3KyssXCJzXCIhPWRhJiZcInJcIiE9ZGEmJlwiYVwiIT1kYSYmaChLLE4sXCJmLXN0cmluZzogaW52YWxpZCBjb252ZXJzaW9uIGNoYXJhY3RlcjogZXhwZWN0ZWQgJ3MnLCAncicsIG9yICdhJ1wiKSk7dz49QyYmbWEoKTtcIjpcIj09RC5jaGFyQXQodykmJih3Kyssdz49QyYmbWEoKSxbWSx3XT1jYShELHcsQyxHLEwrMSxLLE4pKTsodz49Q3x8XCJ9XCIhPUQuY2hhckF0KHcpKSYmbWEoKTt3Kys7cmV0dXJuW25ldyBTay5hc3Rub2Rlcy5Gb3JtYXR0ZWRWYWx1ZShSLGRhLFksTi5saW5lbm8sTi5jb2xfb2Zmc2V0KSx3XX1mdW5jdGlvbiBjYShELHcsQyxHLEwsSyxOKXtsZXQgUj1bXSxXPVQ9PntpZigtMSE9PVQuaW5kZXhPZihcIn1cIikpe2lmKC8oXnxbXn1dKX0ofX0pKigkfFtefV0pLy50ZXN0KFQpKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiZi1zdHJpbmc6IHNpbmdsZSAnfScgaXMgbm90IGFsbG93ZWRcIixcbksuY19maWxlbmFtZSxOLmxpbmVubyxOLmNvbF9vZmZzZXQpO1Q9VC5yZXBsYWNlKC99fS9nLFwifVwiKX1SLnB1c2gobmV3IFNrLmFzdG5vZGVzLlN0cihuZXcgU2suYnVpbHRpbi5zdHIoVCksTi5saW5lbm8sTi5jb2xfb2Zmc2V0LEsuZW5kX2xpbmVubyxOLmVuZF9jb2xfb2Zmc2V0KSl9O2Zvcig7dzxDOyl7bGV0IFQ9RC5pbmRleE9mKFwie1wiLHcpO2lmKDAhPT1MKXtsZXQgYmE9RC5pbmRleE9mKFwifVwiLHcpOy0xIT09YmEmJigtMT09PVQ/Qz1iYTpUPmJhJiYoVD0tMSxDPWJhKSl9aWYoLTE9PT1UKXtXKEQuc3Vic3RyaW5nKHcsQykpO3c9QzticmVha31lbHNlIGlmKFQrMTxDJiZcIntcIj09PUQuY2hhckF0KFQrMSkpVyhELnN1YnN0cmluZyh3LFQrMSkpLHc9VCsyO2Vsc2V7VyhELnN1YnN0cmluZyh3LFQpKTt3PVQ7bGV0IFtiYSxZXT1vYShELFQsQyxHLEwsSyxOKTtSLnB1c2goYmEpO3c9WX19cmV0dXJuW25ldyBTay5hc3Rub2Rlcy5Kb2luZWRTdHIoUixOLmxpbmVubyxOLmNvbF9vZmZzZXQpLFxud119ZnVuY3Rpb24gbGEoRCx3KXt2YXIgQyxHO2YodyxPLnN1YnNjcmlwdCk7dmFyIEw9ZCh3LDApO3ZhciBLPUM9Rz1udWxsO2lmKEwudHlwZT09PVYuVF9ET1QpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5FbGxpcHNpcztpZigxPT09ZSh3KSYmTC50eXBlPT09Ty50ZXN0KXJldHVybiBuZXcgU2suYXN0bm9kZXMuSW5kZXgoVShELEwpKTtMLnR5cGU9PT1PLnRlc3QmJihHPVUoRCxMKSk7TC50eXBlPT09Vi5UX0NPTE9OPzE8ZSh3KSYmKEw9ZCh3LDEpLEwudHlwZT09PU8udGVzdCYmKEM9VShELEwpKSk6MjxlKHcpJiYoTD1kKHcsMiksTC50eXBlPT09Ty50ZXN0JiYoQz1VKEQsTCkpKTtMPWQodyxlKHcpLTEpO0wudHlwZT09PU8uc2xpY2VvcCYmKDE9PT1lKEwpPyhMPWQoTCwwKSxLPW5ldyBTay5hc3Rub2Rlcy5OYW1lQ29uc3RhbnQoU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmFzdG5vZGVzLkxvYWQsTC5saW5lbm8sTC5jb2xfb2Zmc2V0KSk6KEw9ZChMLDEpLEwudHlwZT09PU8udGVzdCYmXG4oSz1VKEQsTCkpKSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5TbGljZShHLEMsSyl9ZnVuY3Rpb24gaWEoRCx3KXt2YXIgQz1kKHcsMCk7c3dpdGNoKEMudHlwZSl7Y2FzZSBWLlRfTkFNRTp2YXIgRz1DLnZhbHVlO2lmKDQ8PUcubGVuZ3RoJiY1Pj1HLmxlbmd0aCl7aWYoXCJOb25lXCI9PT1HKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50KFNrLmJ1aWx0aW4ubm9uZS5ub25lJCx3LmxpbmVubyx3LmNvbF9vZmZzZXQpO2lmKFwiVHJ1ZVwiPT09RylyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudChTay5idWlsdGluLmJvb2wudHJ1ZSQsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTtpZihcIkZhbHNlXCI9PT1HKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50KFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KX1EPW0oRyxEKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk5hbWUoRCxTay5hc3Rub2Rlcy5Mb2FkLHcubGluZW5vLFxudy5jb2xfb2Zmc2V0LHcuZW5kX2xpbmVubyx3LmVuZF9jb2xfb2Zmc2V0KTtjYXNlIFYuVF9TVFJJTkc6Qz1bXTtmb3IodmFyIEw9MDtMPGUodyk7KytMKXt2YXIgSz1kKHcsTCkudmFsdWU7dmFyIE49RDt2YXIgUj1kKHcsTCk7dmFyIFc9Szt2YXIgVD1XLmNoYXJBdCgwKTtmb3IodmFyIGJhPSExLFk9Sz0hMTs7KXtpZihcInVcIiE9PVQmJlwiVVwiIT09VClpZihcInJcIj09PVR8fFwiUlwiPT09VCliYT0hMDtlbHNlIGlmKFwiYlwiPT09VHx8XCJCXCI9PT1UKVk9ITA7ZWxzZSBpZihcImZcIj09PVR8fFwiRlwiPT09VClLPSEwO2Vsc2UgYnJlYWs7Vz1XLnN1YnN0cigxKTtUPVcuY2hhckF0KDApfVNrLmFzc2VydHMuYXNzZXJ0KFwiJ1wiPT09VHx8J1wiJz09PVQmJlcuY2hhckF0KFcubGVuZ3RoLTEpPT09VCk7Vz1XLnN1YnN0cigxLFcubGVuZ3RoLTIpOzQ8PVcubGVuZ3RoJiZXLmNoYXJBdCgwKT09PVQmJlcuY2hhckF0KDEpPT09VCYmKFNrLmFzc2VydHMuYXNzZXJ0KFcuY2hhckF0KFcubGVuZ3RoLTEpPT09VCYmXG5XLmNoYXJBdChXLmxlbmd0aC0yKT09PVQpLFc9Vy5zdWJzdHIoMixXLmxlbmd0aC00KSk7aWYoYmF8fC0xPT09Vy5pbmRleE9mKFwiXFxcXFwiKSl7aWYoWSlmb3IoVD0wO1Q8Vy5sZW5ndGg7VCsrKTEyNzxXLmNoYXJDb2RlQXQoVCkmJmgoTixSLFwiYnl0ZXMgY2FuIG9ubHkgY29udGFpbiBBU0NJSSBsaXRlcmFsIGNoYXJhY3RlcnNcIik7Tj1bcChXKSxLLFldfWVsc2V7YmE9Vzt2YXIgZGE9YmEubGVuZ3RoLG1hPVwiXCI7Zm9yKFc9MDtXPGRhOysrVylUPWJhLmNoYXJBdChXKSxcIlxcXFxcIj09PVQ/KCsrVyxUPWJhLmNoYXJBdChXKSxcIm5cIj09PVQ/bWErPVwiXFxuXCI6XCJcXFxcXCI9PT1UP21hKz1cIlxcXFxcIjpcInRcIj09PVQ/bWErPVwiXFx0XCI6XCJyXCI9PT1UP21hKz1cIlxcclwiOlwiYlwiPT09VD9tYSs9XCJcXGJcIjpcImZcIj09PVQ/bWErPVwiXFxmXCI6XCJ2XCI9PT1UP21hKz1cIlxcdlwiOlwiMFwiPT09VD9tYSs9XCJcXHgwMFwiOidcIic9PT1UP21hKz0nXCInOlwiJ1wiPT09VD9tYSs9XCInXCI6XCJcXG5cIiE9PVQmJihcInhcIj09PVQ/KFcrMj49ZGEmJmgoTixSLFwiVHJ1bmNhdGVkIFxcXFx4Tk4gZXNjYXBlXCIpLFxubWErPVN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYmEuc3Vic3RyKFcrMSwyKSwxNikpLFcrPTIpOll8fFwidVwiIT09VD9ZfHxcIlVcIiE9PVQ/bWErPVwiXFxcXFwiK1Q6KFcrOD49ZGEmJmgoTixSLFwiVHJ1bmNhdGVkIFxcXFxVWFhYWFhYWFggZXNjYXBlXCIpLG1hKz1TdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChiYS5zdWJzdHIoVysxLDgpLDE2KSksVys9OCk6KFcrND49ZGEmJmgoTixSLFwiVHJ1bmNhdGVkIFxcXFx1WFhYWCBlc2NhcGVcIiksbWErPVN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYmEuc3Vic3RyKFcrMSw0KSwxNikpLFcrPTQpKSk6WSYmMTI3PFQuY2hhckNvZGVBdCgwKT9oKE4sUixcImJ5dGVzIGNhbiBvbmx5IGNvbnRhaW4gQVNDSUkgbGl0ZXJhbCBjaGFyYWN0ZXJzXCIpOm1hKz1UO049bWE7Tj1bcChOKSxLLFldfUs9TjtOPUtbMF07Uj1LWzFdO0s9S1syXTswIT1MJiZHIT09SyYmaChELHcsXCJjYW5ub3QgbWl4IGJ5dGVzIGFuZCBub25ieXRlcyBsaXRlcmFsc1wiKTtcbkc9SztpZihSKXtpZighU2suX19mdXR1cmVfXy5weXRob24zKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW52YWxpZCBzdHJpbmcgKGYtc3RyaW5ncyBhcmUgbm90IHN1cHBvcnRlZCBpbiBQeXRob24gMilcIixELmNfZmlsZW5hbWUsZCh3LEwpLmxpbmVubyk7dmFyIGhhPU4uJGpzc3RyKCk7W2hhXT1jYShoYSwwLGhhLmxlbmd0aCwhMSwwLEQsZCh3LEwpKTtDLnB1c2guYXBwbHkoQyxoYS52YWx1ZXMpO2hhPW51bGx9ZWxzZSBoYT9oYS5zPWhhLnMuc3EkY29uY2F0KE4pOihoYT1uZXcgKEc/U2suYXN0bm9kZXMuQnl0ZXM6U2suYXN0bm9kZXMuU3RyKShOLHcubGluZW5vLHcuY29sX29mZnNldCxELmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCksQy5wdXNoKGhhKSl9dz0xPT09Qy5sZW5ndGgmJkNbMF0uY29uc3RydWN0b3I9PT1Tay5hc3Rub2Rlcy5TdHI/Q1swXTpuZXcgU2suYXN0bm9kZXMuSm9pbmVkU3RyKEMsdy5saW5lbm8sdy5jb2xfb2Zmc2V0LEQuZW5kX2xpbmVubyxcbncuZW5kX2NvbF9vZmZzZXQpO3JldHVybiB3O2Nhc2UgVi5UX05VTUJFUjpEPVNrLmFzdG5vZGVzLk51bTtHPUMudmFsdWU7Rz1HLnJlcGxhY2UocGEsXCJcIik7TD1HW0cubGVuZ3RoLTFdO2lmKFwialwiPT09THx8XCJKXCI9PT1MKUc9bmV3IFNrLmJ1aWx0aW4uY29tcGxleCgwLHBhcnNlRmxvYXQoRy5zbGljZSgwLC0xKSkpO2Vsc2UgaWYocWEudGVzdChHKSlHPW5ldyBTay5idWlsdGluLmZsb2F0XyhwYXJzZUZsb2F0KEcpKTtlbHNle1wiMFwiPT09R1swXSYmXCIwXCIhPT1HJiY2NT5HLmNoYXJDb2RlQXQoMSkmJihHPVwiMG9cIitHLnN1YnN0cmluZygxKSk7Qz0hMDtpZihcImxcIj09PUx8fFwiTFwiPT09TClHPUcuc2xpY2UoMCwtMSksQz0hMTtMPU51bWJlcihHKTtHPUw+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI/Qz9uZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkuQmlnSW50KEcpKTpuZXcgU2suYnVpbHRpbi5sbmcoSlNCSS5CaWdJbnQoRykpOkM/bmV3IFNrLmJ1aWx0aW4uaW50XyhMKTpuZXcgU2suYnVpbHRpbi5sbmcoTCl9cmV0dXJuIG5ldyBEKEcsXG53LmxpbmVubyx3LmNvbF9vZmZzZXQpO2Nhc2UgVi5UX0VMTElQU0lTOnJldHVybiBuZXcgU2suYXN0bm9kZXMuRWxsaXBzaXMody5saW5lbm8sdy5jb2xfb2Zmc2V0LHcuZW5kX2xpbmVubyx3LmVuZF9jb2xfb2Zmc2V0KTtjYXNlIFYuVF9MUEFSOnJldHVybiBDPWQodywxKSxDLnR5cGU9PVYuVF9SUEFSP25ldyBTay5hc3Rub2Rlcy5UdXBsZShbXSxTay5hc3Rub2Rlcy5Mb2FkLHcubGluZW5vLHcuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk6Qy50eXBlPT1PLnlpZWxkX2V4cHI/VShELEMpOjE9PWUoQyk/YWEoRCxDKTpkKEMsMSkudHlwZT09Ty5jb21wX2Zvcj91KHQoRCxDKSx3KTp1KGFhKEQsQyksdyk7Y2FzZSBWLlRfTFNRQjpDPWQodywxKTtpZihDLnR5cGU9PVYuVF9SU1FCKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTGlzdChbXSxTay5hc3Rub2Rlcy5Mb2FkLHcubGluZW5vLHcuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk7XG5mKEMsTy50ZXN0bGlzdF9jb21wKTtpZigxPT1lKEMpfHxkKEMsMSkudHlwZT09Vi5UX0NPTU1BKXJldHVybihEPWwoRCxDKSk/bmV3IFNrLmFzdG5vZGVzLkxpc3QoRCxTay5hc3Rub2Rlcy5Mb2FkLHcubGluZW5vLHcuY29sX29mZnNldCx3LmVuZF9saW5lbm8sdy5lbmRfY29sX29mZnNldCk6bnVsbDtHPUM7U2suYXNzZXJ0cy5hc3NlcnQoRy50eXBlPT1PLnRlc3RsaXN0X2NvbXApO0Q9UShELEcsMSk7cmV0dXJuIHUoRCx3KTtjYXNlIFYuVF9MQlJBQ0U6Qz1kKHcsMSk7aWYoQy50eXBlPT1WLlRfUkJSQUNFKXJldHVybiBuZXcgU2suYXN0bm9kZXMuRGljdChudWxsLG51bGwsdy5saW5lbm8sdy5jb2xfb2Zmc2V0LHcuZW5kX2xpbmVubyx3LmVuZF9jb2xfb2Zmc2V0KTtHPWQoQywwKS50eXBlPT1WLlRfRE9VQkxFU1RBUjtpZigxPT1lKEMpfHwxPGUoQykmJmQoQywxKS50eXBlPT1WLlRfQ09NTUEpe0c9QztMPVtdO1NrLmFzc2VydHMuYXNzZXJ0KEcudHlwZT09PU8uZGljdG9yc2V0bWFrZXIpO1xuZm9yKEM9MDtDPGUoRyk7Qys9MiloYT1VKEQsZChHLEMpKSxMW0MvMl09aGE7RD1uZXcgU2suYXN0bm9kZXMuU2V0KEwsRy5saW5lbm8sRy5jb2xfb2Zmc2V0KX1lbHNlIGlmKDE8ZShDKSYmZChDLDEpLnR5cGU9PU8uY29tcF9mb3IpRz1DLFNrLmFzc2VydHMuYXNzZXJ0KEcudHlwZT09PU8uZGljdG9yc2V0bWFrZXIpLFNrLmFzc2VydHMuYXNzZXJ0KDE8ZShHKSksQz1VKEQsZChHLDApKSxEPUEoRCxkKEcsMSkpLEQ9bmV3IFNrLmFzdG5vZGVzLlNldENvbXAoQyxELEcubGluZW5vLEcuY29sX29mZnNldCk7ZWxzZSBpZihlKEMpPjMtRyYmZChDLDMtRykudHlwZT09Ty5jb21wX2Zvcil7aWYoRylyZXR1cm4gaChELHcsXCJkaWN0IHVucGFja2luZyBjYW5ub3QgYmUgdXNlZCBpbiBkaWN0IGNvbXByZWhlbnNpb25cIiksbnVsbDtHPUM7U2suYXNzZXJ0cy5hc3NlcnQoMzxlKEcpKTtmKGQoRywxKSxWLlRfQ09MT04pO0M9VShELGQoRywwKSk7TD1VKEQsZChHLDIpKTtEPUEoRCxkKEcsMykpO1xuRD1uZXcgU2suYXN0bm9kZXMuRGljdENvbXAoQyxMLEQsRy5saW5lbm8sRy5jb2xfb2Zmc2V0KX1lbHNle0c9QztMPVtdO2hhPVtdO2ZvcihLPUM9MDtLPGUoRyk7SysrKU49RCxSPUcsWT1LLGQoUixZKS50eXBlPT1WLlRfRE9VQkxFU1RBUj8oU2suYXNzZXJ0cy5hc3NlcnQoMjw9ZShSKS1ZKSxLPVUoTixkKFIsWSsxKSksTj17a2V5Om51bGwsdmFsdWU6SyxpOlkrMn0pOihTay5hc3NlcnRzLmFzc2VydCgzPD1lKFIpLVkpLChLPVUoTixkKFIsWSkpKT8oVz1LLGYoZChSLFkrMSksVi5UX0NPTE9OKSxOPShLPVUoTixkKFIsWSsyKSkpP3trZXk6Vyx2YWx1ZTpLLGk6WSszfTohMSk6Tj0wKSxLPU4uaSxMW0NdPU4ua2V5LGhhW0NdPU4udmFsdWUsQysrO0Q9bmV3IFNrLmFzdG5vZGVzLkRpY3QoTCxoYSxHLmxpbmVubyxHLmNvbF9vZmZzZXQsRy5lbmRfbGluZW5vLEcuZW5kX2NvbF9vZmZzZXQpfXJldHVybiB1KEQsdyk7ZGVmYXVsdDpyZXR1cm4gU2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGF0b20gXCIrXG5DLnR5cGUpLG51bGx9fWZ1bmN0aW9uIGthKEQsdyl7dmFyIEMsRz0wO2YodyxPLmF0b21fZXhwcik7dmFyIEw9ZSh3KTtkKHcsMCkudHlwZT09PVYuVF9BV0FJVCYmKEc9MSxTay5hc3NlcnRzLmFzc2VydCgxPEwpKTt2YXIgSz1pYShELGQodyxHKSk7aWYoIUspcmV0dXJuIG51bGw7aWYoMT09PUwpcmV0dXJuIEs7aWYoRyYmMj09PUwpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Bd2FpdChLLHcubGluZW5vLHcuY29sX29mZnNldCk7Zm9yKEM9RysxO0M8TDtDKyspe3ZhciBOPWQodyxDKTtpZihOLnR5cGUhPT1PLnRyYWlsZXIpYnJlYWs7Tj1CKEQsTixLKTtpZighTilyZXR1cm4gbnVsbDtOLmxpbmVubz1LLmxpbmVubztOLmNvbF9vZmZzZXQ9Sy5jb2xfb2Zmc2V0O0s9Tn1yZXR1cm4gRz9uZXcgU2suYXN0bm9kZXMuQXdhaXQoSyx3LmxpbmUsdy5jb2xfb2Zmc2V0KTpLfWZ1bmN0aW9uIFUoRCx3KXthOmZvcig7Oyl7c3dpdGNoKHcudHlwZSl7Y2FzZSBPLnRlc3Q6Y2FzZSBPLnRlc3Rfbm9jb25kOmlmKGQodyxcbjApLnR5cGU9PT1PLmxhbWJkZWZ8fGQodywwKS50eXBlPT09Ty5sYW1iZGVmX25vY29uZCl7dmFyIEM9ZCh3LDApOzM9PT1lKEMpPyh3PW5ldyBTay5hc3Rub2Rlcy5hcmd1bWVudHNfKFtdLG51bGwsbnVsbCxbXSksRD1VKEQsZChDLDIpKSk6KHc9RShELGQoQywxKSksRD1VKEQsZChDLDMpKSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5MYW1iZGEodyxELEMubGluZW5vLEMuY29sX29mZnNldCl9aWYoMTxlKHcpKXJldHVybiBTay5hc3NlcnRzLmFzc2VydCg1PT09ZSh3KSksbmV3IFNrLmFzdG5vZGVzLklmRXhwKFUoRCxkKHcsMikpLFUoRCxkKHcsMCkpLFUoRCxkKHcsNCkpLHcubGluZW5vLHcuY29sX29mZnNldCk7Y2FzZSBPLm9yX3Rlc3Q6Y2FzZSBPLmFuZF90ZXN0OmlmKDE9PT1lKHcpKXt3PWQodywwKTtjb250aW51ZSBhfXZhciBHPVtdO2ZvcihDPTA7QzxlKHcpO0MrPTIpR1tDLzJdPVUoRCxkKHcsQykpO2lmKFwiYW5kXCI9PT1kKHcsMSkudmFsdWUpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Cb29sT3AoU2suYXN0bm9kZXMuQW5kLFxuRyx3LmxpbmVubyx3LmNvbF9vZmZzZXQpO1NrLmFzc2VydHMuYXNzZXJ0KFwib3JcIj09PWQodywxKS52YWx1ZSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Cb29sT3AoU2suYXN0bm9kZXMuT3IsRyx3LmxpbmVubyx3LmNvbF9vZmZzZXQpO2Nhc2UgTy5ub3RfdGVzdDppZigxPT09ZSh3KSl7dz1kKHcsMCk7Y29udGludWUgYX1lbHNlIHJldHVybiBuZXcgU2suYXN0bm9kZXMuVW5hcnlPcChTay5hc3Rub2Rlcy5Ob3QsVShELGQodywxKSksdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTtjYXNlIE8uY29tcGFyaXNvbjppZigxPT09ZSh3KSl7dz1kKHcsMCk7Y29udGludWUgYX1lbHNle3ZhciBMPVtdO0c9W107Zm9yKEM9MTtDPGUodyk7Qys9MilMWyhDLTEpLzJdPWsoRCxkKHcsQykpLEdbKEMtMSkvMl09VShELGQodyxDKzEpKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkNvbXBhcmUoVShELGQodywwKSksTCxHLHcubGluZW5vLHcuY29sX29mZnNldCl9Y2FzZSBPLnN0YXJfZXhwcjpyZXR1cm4gZih3LFxuTy5zdGFyX2V4cHIpLG5ldyBTay5hc3Rub2Rlcy5TdGFycmVkKFUoRCxkKHcsMSkpLFNrLmFzdG5vZGVzLkxvYWQsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTtjYXNlIE8uZXhwcjpjYXNlIE8ueG9yX2V4cHI6Y2FzZSBPLmFuZF9leHByOmNhc2UgTy5zaGlmdF9leHByOmNhc2UgTy5hcml0aF9leHByOmNhc2UgTy50ZXJtOmlmKDE9PT1lKHcpKXt3PWQodywwKTtjb250aW51ZSBhfXZhciBLPXcsTj1uZXcgU2suYXN0bm9kZXMuQmluT3AoVShELGQoSywwKSksbihkKEssMSkpLFUoRCxkKEssMikpLEsubGluZW5vLEsuY29sX29mZnNldCksUj0oZShLKS0xKS8yO2Zvcih3PTE7dzxSOysrdylDPWQoSywyKncrMSksRz1uKEMpLEw9VShELGQoSywyKncrMikpLE49bmV3IFNrLmFzdG5vZGVzLkJpbk9wKE4sRyxMLEMubGluZW5vLEMuY29sX29mZnNldCk7cmV0dXJuIE47Y2FzZSBPLnlpZWxkX2V4cHI6cmV0dXJuIEc9ITEsTD1udWxsLDE8ZSh3KSYmKEM9ZCh3LDEpKSxDJiYoTD1kKEMsZShDKS1cbjEpLDI9PWUoQyk/KEc9ITAsTD1VKEQsTCkpOkw9YWEoRCxMKSksRz9uZXcgU2suYXN0bm9kZXMuWWllbGRGcm9tKEwsdy5saW5lbm8sdy5jb2xfb2Zmc2V0KTpuZXcgU2suYXN0bm9kZXMuWWllbGQoTCx3LmxpbmVubyx3LmNvbF9vZmZzZXQpO2Nhc2UgTy5mYWN0b3I6aWYoMT09PWUodykpe3c9ZCh3LDApO2NvbnRpbnVlIGF9cmV0dXJuIHgoRCx3KTtjYXNlIE8ucG93ZXI6cmV0dXJuIEM9dyxmKEMsTy5wb3dlciksdz1rYShELGQoQywwKSksMSE9PWUoQykmJmQoQyxlKEMpLTEpLnR5cGU9PT1PLmZhY3RvciYmKEQ9VShELGQoQyxlKEMpLTEpKSx3PW5ldyBTay5hc3Rub2Rlcy5CaW5PcCh3LFNrLmFzdG5vZGVzLlBvdyxELEMubGluZW5vLEMuY29sX29mZnNldCkpLHc7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgZXhwclwiLFwibi50eXBlOiAlZFwiLHcudHlwZSl9YnJlYWt9fWZ1bmN0aW9uIGphKEQsdyl7dy50eXBlPT09Ty5zdG10JiYoU2suYXNzZXJ0cy5hc3NlcnQoMT09PVxuZSh3KSksdz1kKHcsMCkpO3cudHlwZT09PU8uc2ltcGxlX3N0bXQmJihTay5hc3NlcnRzLmFzc2VydCgxPT09Zyh3KSksdz1kKHcsMCkpO2lmKHcudHlwZT09PU8uc21hbGxfc3RtdClzd2l0Y2godz1kKHcsMCksdy50eXBlKXtjYXNlIE8uZXhwcl9zdG10OnJldHVybiBlYShELHcpO2Nhc2UgTy5kZWxfc3RtdDp2YXIgQz13O2YoQyxPLmRlbF9zdG10KTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkRlbGV0ZSh6KEQsZChDLDEpLFNrLmFzdG5vZGVzLkRlbCksQy5saW5lbm8sQy5jb2xfb2Zmc2V0KTtjYXNlIE8ucGFzc19zdG10OnJldHVybiBuZXcgU2suYXN0bm9kZXMuUGFzcyh3LmxpbmVubyx3LmNvbF9vZmZzZXQpO2Nhc2UgTy5mbG93X3N0bXQ6cmV0dXJuIEkoRCx3KTtjYXNlIE8uaW1wb3J0X3N0bXQ6dmFyIEc9dyxMO2YoRyxPLmltcG9ydF9zdG10KTt2YXIgSz1HLmxpbmVubzt3PUcuY29sX29mZnNldDtHPWQoRywwKTtpZihHLnR5cGU9PT1PLmltcG9ydF9uYW1lKXtHPWQoRywxKTtcbmYoRyxPLmRvdHRlZF9hc19uYW1lcyk7dmFyIE49W107Zm9yKEw9MDtMPGUoRyk7TCs9MilOW0wvMl09cihELGQoRyxMKSk7RD1uZXcgU2suYXN0bm9kZXMuSW1wb3J0KE4sSyx3KX1lbHNlIGlmKEcudHlwZT09PU8uaW1wb3J0X2Zyb20pe3ZhciBSPW51bGw7Qz0wO2ZvcihOPTE7TjxlKEcpOysrTilpZihkKEcsTikudHlwZT09PU8uZG90dGVkX25hbWUpe1I9cihELGQoRyxOKSk7TisrO2JyZWFrfWVsc2UgaWYoZChHLE4pLnR5cGU9PT1WLlRfRE9UKUMrKztlbHNlIGlmKGQoRyxOKS50eXBlPT09Vi5UX0VMTElQU0lTKUMrPTM7ZWxzZSBicmVhazsrK047c3dpdGNoKGQoRyxOKS50eXBlKXtjYXNlIFYuVF9TVEFSOkc9ZChHLE4pO2JyZWFrO2Nhc2UgVi5UX0xQQVI6Rz1kKEcsTisxKTtlKEcpO2JyZWFrO2Nhc2UgTy5pbXBvcnRfYXNfbmFtZXM6Rz1kKEcsTik7Tj1lKEcpO2lmKDA9PT1OJTIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJ0cmFpbGluZyBjb21tYSBub3QgYWxsb3dlZCB3aXRob3V0IHN1cnJvdW5kaW5nIHBhcmVudGhlc2VzXCIsXG5ELmNfZmlsZW5hbWUsRy5saW5lbm8pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUtdHlwZSBpbiBmcm9tLWltcG9ydFwiLEQuY19maWxlbmFtZSxHLmxpbmVubyk7fU49W107aWYoRy50eXBlPT09Vi5UX1NUQVIpTlswXT1yKEQsRyk7ZWxzZSBmb3IoTD0wO0w8ZShHKTtMKz0yKU5bTC8yXT1yKEQsZChHLEwpKTtEPVI/Ui5uYW1lLnY6XCJcIjtEPW5ldyBTay5hc3Rub2Rlcy5JbXBvcnRGcm9tKHAoRCksTixDLEssdyl9ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInVua25vd24gaW1wb3J0IHN0YXRlbWVudFwiLEQuY19maWxlbmFtZSxHLmxpbmVubyk7cmV0dXJuIEQ7Y2FzZSBPLmdsb2JhbF9zdG10OkQ9dzt3PVtdO2YoRCxPLmdsb2JhbF9zdG10KTtmb3IoQz0xO0M8ZShEKTtDKz0yKXdbKEMtMSkvMl09cChkKEQsQykudmFsdWUpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuR2xvYmFsKHcsRC5saW5lbm8sXG5ELmNvbF9vZmZzZXQpO2Nhc2UgTy5ub25sb2NhbF9zdG10OmgoRCx3LFwiTm90IGltcGxlbWVudGVkOiBub25sb2NhbFwiKTticmVhaztjYXNlIE8uYXNzZXJ0X3N0bXQ6cmV0dXJuIEM9dyxmKEMsTy5hc3NlcnRfc3RtdCksMj09PWUoQyk/RD1uZXcgU2suYXN0bm9kZXMuQXNzZXJ0KFUoRCxkKEMsMSkpLG51bGwsQy5saW5lbm8sQy5jb2xfb2Zmc2V0KTo0PT09ZShDKT9EPW5ldyBTay5hc3Rub2Rlcy5Bc3NlcnQoVShELGQoQywxKSksVShELGQoQywzKSksQy5saW5lbm8sQy5jb2xfb2Zmc2V0KTooU2suYXNzZXJ0cy5mYWlsKFwiaW1wcm9wZXIgbnVtYmVyIG9mIHBhcnRzIHRvIGFzc2VydCBzdG10XCIpLEQ9dm9pZCAwKSxEO2Nhc2UgTy5wcmludF9zdG10OkM9dztTay5fX2Z1dHVyZV9fLnByaW50X2Z1bmN0aW9uJiZoKEQsQyxcIk1pc3NpbmcgcGFyZW50aGVzZXMgaW4gY2FsbCB0byAncHJpbnQnXCIpO0c9MTtLPW51bGw7ZihDLE8ucHJpbnRfc3RtdCk7Mjw9ZShDKSYmZChDLDEpLnR5cGU9PT1cblYuVF9SSUdIVFNISUZUJiYoSz1VKEQsZChDLDIpKSxHPTQpO3c9W107Zm9yKFI9MDtHPGUoQyk7Rys9MiwrK1Ipd1tSXT1VKEQsZChDLEcpKTtEPWQoQyxlKEMpLTEpLnR5cGU9PT1WLlRfQ09NTUE/ITE6ITA7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5QcmludChLLHcsRCxDLmxpbmVubyxDLmNvbF9vZmZzZXQpO2Nhc2UgTy5kZWJ1Z2dlcl9zdG10OnJldHVybiBuZXcgU2suYXN0bm9kZXMuRGVidWdnZXIody5saW5lbm8sdy5jb2xfb2Zmc2V0KTtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBzbWFsbF9zdG10XCIpfWVsc2Ugc3dpdGNoKEM9ZCh3LDApLGYodyxPLmNvbXBvdW5kX3N0bXQpLEMudHlwZSl7Y2FzZSBPLmlmX3N0bXQ6ZihDLE8uaWZfc3RtdCk7aWYoND09PWUoQykpRD1uZXcgU2suYXN0bm9kZXMuSWYoVShELGQoQywxKSkscShELGQoQywzKSksW10sQy5saW5lbm8sQy5jb2xfb2Zmc2V0KTtlbHNlIGlmKHc9ZChDLDQpLnZhbHVlLmNoYXJBdCgyKSxcInNcIj09PVxudylEPW5ldyBTay5hc3Rub2Rlcy5JZihVKEQsZChDLDEpKSxxKEQsZChDLDMpKSxxKEQsZChDLDYpKSxDLmxpbmVubyxDLmNvbF9vZmZzZXQpO2Vsc2UgaWYoXCJpXCI9PT13KXtLPWUoQyktNDtHPSExO3c9W107ZChDLEsrMSkudHlwZT09PVYuVF9OQU1FJiZcInNcIj09PWQoQyxLKzEpLnZhbHVlLmNoYXJBdCgyKSYmKEc9ITAsSy09Myk7Sy89NDtHJiYodz1bbmV3IFNrLmFzdG5vZGVzLklmKFUoRCxkKEMsZShDKS02KSkscShELGQoQyxlKEMpLTQpKSxxKEQsZChDLGUoQyktMSkpLGQoQyxlKEMpLTYpLmxpbmVubyxkKEMsZShDKS02KS5jb2xfb2Zmc2V0KV0sSy0tKTtmb3IoUj0wO1I8SzsrK1IpRz01KzQqKEstUi0xKSx3PVtuZXcgU2suYXN0bm9kZXMuSWYoVShELGQoQyxHKSkscShELGQoQyxHKzIpKSx3LGQoQyxHKS5saW5lbm8sZChDLEcpLmNvbF9vZmZzZXQpXTtEPW5ldyBTay5hc3Rub2Rlcy5JZihVKEQsZChDLDEpKSxxKEQsZChDLDMpKSx3LEMubGluZW5vLEMuY29sX29mZnNldCl9ZWxzZSBTay5hc3NlcnRzLmZhaWwoXCJ1bmV4cGVjdGVkIHRva2VuIGluICdpZicgc3RhdGVtZW50XCIpLFxuRD12b2lkIDA7cmV0dXJuIEQ7Y2FzZSBPLndoaWxlX3N0bXQ6cmV0dXJuIGYoQyxPLndoaWxlX3N0bXQpLDQ9PT1lKEMpP0Q9bmV3IFNrLmFzdG5vZGVzLldoaWxlKFUoRCxkKEMsMSkpLHEoRCxkKEMsMykpLFtdLEMubGluZW5vLEMuY29sX29mZnNldCk6Nz09PWUoQyk/RD1uZXcgU2suYXN0bm9kZXMuV2hpbGUoVShELGQoQywxKSkscShELGQoQywzKSkscShELGQoQyw2KSksQy5saW5lbm8sQy5jb2xfb2Zmc2V0KTooU2suYXNzZXJ0cy5mYWlsKFwid3JvbmcgbnVtYmVyIG9mIHRva2VucyBmb3IgJ3doaWxlJyBzdG10XCIpLEQ9dm9pZCAwKSxEO2Nhc2UgTy5mb3Jfc3RtdDpyZXR1cm4gdz1bXSxmKEMsTy5mb3Jfc3RtdCksOT09PWUoQykmJih3PXEoRCxkKEMsOCkpKSxHPWQoQywxKSxLPXooRCxHLFNrLmFzdG5vZGVzLlN0b3JlKSxLPTE9PT1lKEcpP0tbMF06bmV3IFNrLmFzdG5vZGVzLlR1cGxlKEssU2suYXN0bm9kZXMuU3RvcmUsQy5saW5lbm8sQy5jb2xfb2Zmc2V0KSxuZXcgU2suYXN0bm9kZXMuRm9yKEssXG5hYShELGQoQywzKSkscShELGQoQyw1KSksdyxDLmxpbmVubyxDLmNvbF9vZmZzZXQpO2Nhc2UgTy50cnlfc3RtdDp3PVtdO0w9ZShDKTtLPShMLTMpLzM7Uj1bXTtOPW51bGw7ZihDLE8udHJ5X3N0bXQpO0c9cShELGQoQywyKSk7aWYoZChDLEwtMykudHlwZT09PVYuVF9OQU1FKVwiZmluYWxseVwiPT09ZChDLEwtMykudmFsdWU/KDk8PUwmJmQoQyxMLTYpLnR5cGU9PT1WLlRfTkFNRSYmKFI9cShELGQoQyxMLTQpKSxLLS0pLE49cShELGQoQyxMLTEpKSk6Uj1xKEQsZChDLEwtMSkpLEstLTtlbHNlIGlmKGQoQyxMLTMpLnR5cGUhPT1PLmV4Y2VwdF9jbGF1c2UpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJtYWxmb3JtZWQgJ3RyeScgc3RhdGVtZW50XCIsRC5jX2ZpbGVuYW1lLEMubGluZW5vKTtpZigwPEspZm9yKEw9MDtMPEs7TCsrKXt2YXIgVz1MO3ZhciBUPUQsYmE9ZChDLDMrMypMKSxZPWQoQyw1KzMqTCk7ZihiYSxPLmV4Y2VwdF9jbGF1c2UpO2YoWSxPLnN1aXRlKTtcbmlmKDE9PT1lKGJhKSl2YXIgZGE9bmV3IFNrLmFzdG5vZGVzLkV4Y2VwdEhhbmRsZXIobnVsbCxudWxsLHEoVCxZKSxiYS5saW5lbm8sYmEuY29sX29mZnNldCk7ZWxzZSAyPT09ZShiYSk/ZGE9bmV3IFNrLmFzdG5vZGVzLkV4Y2VwdEhhbmRsZXIoVShULGQoYmEsMSkpLG51bGwscShULFkpLGJhLmxpbmVubyxiYS5jb2xfb2Zmc2V0KTo0PT09ZShiYSk/KFNrLl9fZnV0dXJlX18ucHl0aG9uMyYmXCIsXCI9PWQoYmEsMikudmFsdWUmJmgoVCxiYSxcIk9sZC1zdHlsZSAnZXhjZXB0JyBjbGF1c2VzIGFyZSBub3Qgc3VwcG9ydGVkIGluIFB5dGhvbiAzXCIpLFUoVCxkKGJhLDEpKSxkYT1VKFQsZChiYSwzKSksYyhULGRhLFNrLmFzdG5vZGVzLlN0b3JlLGQoYmEsMykpLGRhPW5ldyBTay5hc3Rub2Rlcy5FeGNlcHRIYW5kbGVyKFUoVCxkKGJhLDEpKSxkYSxxKFQsWSksYmEubGluZW5vLGJhLmNvbF9vZmZzZXQpKTooU2suYXNzZXJ0cy5mYWlsKFwid3JvbmcgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciBleGNlcHQgY2xhdXNlXCIpLFxuZGE9dm9pZCAwKTt3W1ddPWRhfVNrLmFzc2VydHMuYXNzZXJ0KCEhTnx8MCE9dy5sZW5ndGgpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuVHJ5KEcsdyxSLE4sQy5saW5lbm8sQy5jb2xfb2Zmc2V0KTtjYXNlIE8ud2l0aF9zdG10Onc9W107ZihDLE8ud2l0aF9zdG10KTtmb3IoSz0xO0s8ZShDKS0yO0srPTIpRz12b2lkIDAsTj1ELEw9ZChDLEspLGYoTCxPLndpdGhfaXRlbSksUj1VKE4sZChMLDApKSwzPT1lKEwpJiYoRz1VKE4sZChMLDIpKSxjKE4sRyxTay5hc3Rub2Rlcy5TdG9yZSxMKSksRz1uZXcgU2suYXN0bm9kZXMud2l0aGl0ZW0oUixHKSx3WyhLLTEpLzJdPUc7RD1xKEQsZChDLGUoQyktMSkpO0Q9bmV3IFNrLmFzdG5vZGVzLldpdGgodyxELEMubGluZW5vLEMuY29sX29mZnNldCk7cmV0dXJuIEQ7Y2FzZSBPLmZ1bmNkZWY6cmV0dXJuIEgoRCxDLFtdLCExKTtjYXNlIE8uY2xhc3NkZWY6cmV0dXJuIHkoRCxDLFtdKTtjYXNlIE8uZGVjb3JhdGVkOks9bnVsbDtmKEMsTy5kZWNvcmF0ZWQpO1xuRz1kKEMsMCk7ZihHLE8uZGVjb3JhdG9ycyk7dz1bXTtmb3IoUj0wO1I8ZShHKTsrK1Ipe049dztMPVI7Vz1EO2RhPWQoRyxSKTtmKGRhLE8uZGVjb3JhdG9yKTtmKGQoZGEsMCksVi5UX0FUKTtmKGQoZGEsZShkYSktMSksVi5UX05FV0xJTkUpO3ZhciBtYSxoYT1kKGRhLDEpO2YoaGEsTy5kb3R0ZWRfbmFtZSk7VD1oYS5saW5lbm87YmE9aGEuY29sX29mZnNldDtZPXAoZChoYSwwKS52YWx1ZSk7dmFyIHJhPW5ldyBTay5hc3Rub2Rlcy5OYW1lKFksU2suYXN0bm9kZXMuTG9hZCxULGJhKTtmb3IobWE9MjttYTxlKGhhKTttYSs9MilZPXAoZChoYSxtYSkudmFsdWUpLHJhPW5ldyBTay5hc3Rub2Rlcy5BdHRyaWJ1dGUocmEsWSxTay5hc3Rub2Rlcy5Mb2FkLFQsYmEpO1Q9cmE7Vz0zPT09ZShkYSk/VDo1PT09ZShkYSk/bmV3IFNrLmFzdG5vZGVzLkNhbGwoVCxbXSxbXSxkYS5saW5lbm8sZGEuY29sX29mZnNldCk6dihXLGQoZGEsMyksVCk7TltMXT1XfVNrLmFzc2VydHMuYXNzZXJ0KGQoQyxcbjEpLnR5cGU9PU8uZnVuY2RlZnx8ZChDLDEpLnR5cGU9PU8uYXN5bmNfZnVuY2RlZnx8ZChDLDEpLnR5cGU9PU8uY2xhc3NkZWYpO2QoQywxKS50eXBlPT1PLmZ1bmNkZWY/KEs9ZChDLDEpLEs9SChELEssdywhMSkpOmQoQywxKS50eXBlPT1PLmNsYXNzZGVmP0s9eShELGQoQywxKSx3KTpkKEMsMSkudHlwZT09Ty5hc3luY19mdW5jZGVmJiYoSz1kKEMsMSksZihLLE8uYXN5bmNfZnVuY2RlZiksZihkKEssMCksVi5UX05BTUUpLFNrLmFzc2VydHMuYXNzZXJ0KChcImFzeW5jXCI9PT1kKEssMCkpLnZhbHVlKSxmKGQoSywxKSxPLmZ1bmNkZWYpLEs9SChELEssdywhMCkpO0smJihLLmxpbmVubz1DLmxpbmVubyxLLmNvbF9vZmZzZXQ9Qy5jb2xfb2Zmc2V0KTtyZXR1cm4gSztjYXNlIE8uYXN5bmNfc3RtdDpoKEQsQyxcIk5vdCBpbXBsZW1lbnRlZDogYXN5bmNcIik7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmFzc2VydChcInVuaGFuZGxlZCBjb21wb3VuZF9zdG10XCIpfX12YXIgTz1Tay5QYXJzZVRhYmxlcy5zeW0sXG5WPVNrLnRva2VuLnRva2VucyxaPXtTbGljZV9raW5kOjEsRXh0U2xpY2Vfa2luZDoyLEluZGV4X2tpbmQ6M30sZmE9e307ZmFbVi5UX1ZCQVJdPVNrLmFzdG5vZGVzLkJpdE9yO2ZhW1YuVF9DSVJDVU1GTEVYXT1Tay5hc3Rub2Rlcy5CaXRYb3I7ZmFbVi5UX0FNUEVSXT1Tay5hc3Rub2Rlcy5CaXRBbmQ7ZmFbVi5UX0xFRlRTSElGVF09U2suYXN0bm9kZXMuTFNoaWZ0O2ZhW1YuVF9SSUdIVFNISUZUXT1Tay5hc3Rub2Rlcy5SU2hpZnQ7ZmFbVi5UX1BMVVNdPVNrLmFzdG5vZGVzLkFkZDtmYVtWLlRfTUlOVVNdPVNrLmFzdG5vZGVzLlN1YjtmYVtWLlRfU1RBUl09U2suYXN0bm9kZXMuTXVsdDtmYVtWLlRfU0xBU0hdPVNrLmFzdG5vZGVzLkRpdjtmYVtWLlRfRE9VQkxFU0xBU0hdPVNrLmFzdG5vZGVzLkZsb29yRGl2O2ZhW1YuVF9QRVJDRU5UXT1Tay5hc3Rub2Rlcy5Nb2Q7U2suc2V0dXBPcGVyYXRvcnM9ZnVuY3Rpb24oRCl7RD9mYVtWLlRfQVRdPVNrLmFzdG5vZGVzLk1hdE11bHQ6XG5mYVtWLlRfQVRdJiZkZWxldGUgZmFbVi5UX0FUXX07U2suZXhwb3J0U3ltYm9sKFwiU2suc2V0dXBPcGVyYXRvcnNcIixTay5zZXR1cE9wZXJhdG9ycyk7Y29uc3QgcWE9bmV3IFJlZ0V4cChcIl5cIitTay5fdG9rZW5pemUuRmxvYXRudW1iZXIrXCIkXCIpLHBhPS9fL2c7U2suYXN0RnJvbVBhcnNlPWZ1bmN0aW9uKEQsdyxDKXt2YXIgRyxMPW5ldyBiKFwidXRmLThcIix3LEMpLEs9W10sTj0wO3N3aXRjaChELnR5cGUpe2Nhc2UgTy5maWxlX2lucHV0OmZvcihHPTA7RzxlKEQpLTE7KytHKXt2YXIgUj1kKEQsRyk7aWYoUi50eXBlIT09Vi5UX05FV0xJTkUpaWYoZihSLE8uc3RtdCksQz1nKFIpLDE9PT1DKUtbTisrXT1qYShMLFIpO2Vsc2UgZm9yKFI9ZChSLDApLGYoUixPLnNpbXBsZV9zdG10KSx3PTA7dzxDOysrdylLW04rK109amEoTCxkKFIsMip3KSl9cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Nb2R1bGUoSyk7Y2FzZSBPLmV2YWxfaW5wdXQ6U2suYXNzZXJ0cy5mYWlsKFwidG9kbztcIik7Y2FzZSBPLnNpbmdsZV9pbnB1dDpTay5hc3NlcnRzLmZhaWwoXCJ0b2RvO1wiKTtcbmRlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidG9kbztcIil9fTtTay5hc3REdW1wPWZ1bmN0aW9uKEQpe3ZhciB3PWZ1bmN0aW9uKEcpe3ZhciBMLEs9XCJcIjtmb3IoTD0wO0w8RzsrK0wpSys9XCIgXCI7cmV0dXJuIEt9LEM9ZnVuY3Rpb24oRyxMKXt2YXIgSztpZihudWxsPT09RylyZXR1cm4gTCtcIk5vbmVcIjtpZihHLnByb3RvdHlwZSYmdm9pZCAwIT09Ry5wcm90b3R5cGUuX2FzdG5hbWUmJkcucHJvdG90eXBlLl9pc2VudW0pcmV0dXJuIEwrRy5wcm90b3R5cGUuX2FzdG5hbWUrXCIoKVwiO2lmKHZvaWQgMCE9PUcuX2FzdG5hbWUpe3ZhciBOPXcoRy5fYXN0bmFtZS5sZW5ndGgrMSk7dmFyIFI9W107Zm9yKEs9MDtLPEcuX2ZpZWxkcy5sZW5ndGg7Sys9Mil7dmFyIFc9Ry5fZmllbGRzW0tdO3ZhciBUPUcuX2ZpZWxkc1tLKzFdKEcpO3ZhciBiYT13KFcubGVuZ3RoKzEpO1IucHVzaChbVyxDKFQsTCtOK2JhKV0pfVQ9W107Zm9yKEs9MDtLPFIubGVuZ3RoOysrSyliYT1SW0tdLFQucHVzaChiYVswXStcblwiPVwiK2JhWzFdLnJlcGxhY2UoL15cXHMrLyxcIlwiKSk7Sz1ULmpvaW4oXCIsXFxuXCIrTCtOKTtyZXR1cm4gTCtHLl9hc3RuYW1lK1wiKFwiK0srXCIpXCJ9aWYoU2suaXNBcnJheUxpa2UoRykpe049W107Zm9yKEs9MDtLPEcubGVuZ3RoOysrSylSPUdbS10sTi5wdXNoKEMoUixMK1wiIFwiKSk7Rz1OLmpvaW4oXCIsXFxuXCIpO3JldHVybiBMK1wiW1wiK0cucmVwbGFjZSgvXlxccysvLFwiXCIpK1wiXVwifUc9ITA9PT1HP1wiVHJ1ZVwiOiExPT09Rz9cIkZhbHNlXCI6RyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nP0cudHAkc3RyKCkudjpHIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHI/Ry4kcigpLnY6XCJcIitHO3JldHVybiBMK0d9O3JldHVybiBDKEQsXCJcIil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFzdEZyb21QYXJzZVwiLFNrLmFzdEZyb21QYXJzZSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYXN0RHVtcFwiLFNrLmFzdER1bXApfSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIoZyxhLGMpe3RoaXMuX19uYW1lPWc7dGhpcy5fX2ZsYWdzPVxuYTt0aGlzLl9fc2NvcGU9YT4+MTEmNzt0aGlzLl9fbmFtZXNwYWNlcz1jfHxbXX1mdW5jdGlvbiBlKGcsYSxjLG4sbSl7dGhpcy5zeW1GbGFncz17fTt0aGlzLm5hbWU9YTt0aGlzLnZhcm5hbWVzPVtdO3RoaXMuY2hpbGRyZW49W107dGhpcy5ibG9ja1R5cGU9Yzt0aGlzLnJldHVybnNWYWx1ZT10aGlzLnZhcmtleXdvcmRzPXRoaXMudmFyYXJncz10aGlzLmdlbmVyYXRvcj10aGlzLmNoaWxkSGFzRnJlZT10aGlzLmhhc0ZyZWU9dGhpcy5pc05lc3RlZD0hMTt0aGlzLmxpbmVubz1tO3RoaXMudGFibGU9ZztnLmN1ciYmKGcuY3VyLm5lc3RlZHx8XCJmdW5jdGlvblwiPT09Zy5jdXIuYmxvY2tUeXBlKSYmKHRoaXMuaXNOZXN0ZWQ9ITApO24uc2NvcGVJZD1wKys7Zy5zdHNzW24uc2NvcGVJZF09dGhpczt0aGlzLnN5bWJvbHM9e319ZnVuY3Rpb24gZChnKXt0aGlzLmZpbGVuYW1lPWc7dGhpcy50b3A9dGhpcy5jdXI9bnVsbDt0aGlzLnN0YWNrPVtdO3RoaXMuY3VyQ2xhc3M9dGhpcy5nbG9iYWw9XG5udWxsO3RoaXMudG1wbmFtZT0wO3RoaXMuc3Rzcz17fX1mdW5jdGlvbiBmKGcsYSl7dmFyIGM7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKylnKGFbY10pfWZ1bmN0aW9uIGgoZyxhKXtmb3IodmFyIGMgaW4gYSlnW2NdPWFbY119U2suZXhwb3J0U3ltYm9sKFwiU2suU1lNVEFCX0NPTlNUU1wiLHtERUZfR0xPQkFMOjEsREVGX0xPQ0FMOjIsREVGX1BBUkFNOjQsVVNFOjgsREVGX1NUQVI6MTYsREVGX0RPVUJMRVNUQVI6MzIsREVGX0lOVFVQTEU6NjQsREVGX0ZSRUU6MTI4LERFRl9GUkVFX0dMT0JBTDoyNTYsREVGX0ZSRUVfQ0xBU1M6NTEyLERFRl9JTVBPUlQ6MTAyNCxERUZfQk9VTkQ6MTAzMCxTQ09QRV9PRkY6MTEsU0NPUEVfTUFTSzo3LExPQ0FMOjEsR0xPQkFMX0VYUExJQ0lUOjIsR0xPQkFMX0lNUExJQ0lUOjMsRlJFRTo0LENFTEw6NSxPUFRfSU1QT1JUX1NUQVI6MSxPUFRfRVhFQzoyLE9QVF9CQVJFX0VYRUM6NCxPUFRfVE9QTEVWRUw6OCxHRU5FUkFUT1I6MixHRU5FUkFUT1JfRVhQUkVTU0lPTjoyLFxuTW9kdWxlQmxvY2s6XCJtb2R1bGVcIixGdW5jdGlvbkJsb2NrOlwiZnVuY3Rpb25cIixDbGFzc0Jsb2NrOlwiY2xhc3NcIn0pO2IucHJvdG90eXBlLmdldF9uYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19uYW1lfTtiLnByb3RvdHlwZS5pc19yZWZlcmVuY2VkPWZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5fX2ZsYWdzJjgpfTtiLnByb3RvdHlwZS5pc19wYXJhbWV0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLl9fZmxhZ3MmNCl9O2IucHJvdG90eXBlLmlzX2dsb2JhbD1mdW5jdGlvbigpe3JldHVybiAzPT09dGhpcy5fX3Njb3BlfHwyPT10aGlzLl9fc2NvcGV9O2IucHJvdG90eXBlLmlzX2RlY2xhcmVkX2dsb2JhbD1mdW5jdGlvbigpe3JldHVybiAyPT10aGlzLl9fc2NvcGV9O2IucHJvdG90eXBlLmlzX2xvY2FsPWZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5fX2ZsYWdzJjEwMzApfTtiLnByb3RvdHlwZS5pc19mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuIDQ9PXRoaXMuX19zY29wZX07XG5iLnByb3RvdHlwZS5pc19pbXBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEhKHRoaXMuX19mbGFncyYxMDI0KX07Yi5wcm90b3R5cGUuaXNfYXNzaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLl9fZmxhZ3MmMil9O2IucHJvdG90eXBlLmlzX25hbWVzcGFjZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fbmFtZXNwYWNlcyYmMDx0aGlzLl9fbmFtZXNwYWNlcy5sZW5ndGh9O2IucHJvdG90eXBlLmdldF9uYW1lc3BhY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19uYW1lc3BhY2VzfTt2YXIgcD0wO2UucHJvdG90eXBlLmdldF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmxvY2tUeXBlfTtlLnByb3RvdHlwZS5nZXRfbmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9O2UucHJvdG90eXBlLmdldF9saW5lbm89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lbm99O2UucHJvdG90eXBlLmlzX25lc3RlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmVzdGVkfTtcbmUucHJvdG90eXBlLmhhc19jaGlsZHJlbj1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuY2hpbGRyZW4ubGVuZ3RofTtlLnByb3RvdHlwZS5nZXRfaWRlbnRpZmllcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oKXtyZXR1cm4hMH0pfTtlLnByb3RvdHlwZS5sb29rdXA9ZnVuY3Rpb24oZyl7aWYodGhpcy5zeW1ib2xzLmhhc093blByb3BlcnR5KGcpKWc9dGhpcy5zeW1ib2xzW2ddO2Vsc2V7dmFyIGE9dGhpcy5zeW1GbGFnc1tnXTt2YXIgYz10aGlzLl9fY2hlY2tfY2hpbGRyZW4oZyk7Zz10aGlzLnN5bWJvbHNbZ109bmV3IGIoZyxhLGMpfXJldHVybiBnfTtlLnByb3RvdHlwZS5fX2NoZWNrX2NoaWxkcmVuPWZ1bmN0aW9uKGcpe3ZhciBhLGM9W107Zm9yKGE9MDthPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOysrYSl7dmFyIG49dGhpcy5jaGlsZHJlblthXTtuLm5hbWU9PT1nJiZjLnB1c2gobil9cmV0dXJuIGN9O2UucHJvdG90eXBlLl9pZGVudHNNYXRjaGluZz1cbmZ1bmN0aW9uKGcpe3ZhciBhLGM9W107Zm9yKGEgaW4gdGhpcy5zeW1GbGFncyl0aGlzLnN5bUZsYWdzLmhhc093blByb3BlcnR5KGEpJiZnKHRoaXMuc3ltRmxhZ3NbYV0pJiZjLnB1c2goYSk7Yy5zb3J0KCk7cmV0dXJuIGN9O2UucHJvdG90eXBlLmdldF9wYXJhbWV0ZXJzPWZ1bmN0aW9uKCl7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT10aGlzLmdldF90eXBlKCksXCJnZXRfcGFyYW1ldGVycyBvbmx5IHZhbGlkIGZvciBmdW5jdGlvbiBzY29wZXNcIik7dGhpcy5fZnVuY1BhcmFtc3x8KHRoaXMuX2Z1bmNQYXJhbXM9dGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oZyl7cmV0dXJuIGcmNH0pKTtyZXR1cm4gdGhpcy5fZnVuY1BhcmFtc307ZS5wcm90b3R5cGUuZ2V0X2xvY2Fscz1mdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09dGhpcy5nZXRfdHlwZSgpLFwiZ2V0X2xvY2FscyBvbmx5IHZhbGlkIGZvciBmdW5jdGlvbiBzY29wZXNcIik7dGhpcy5fZnVuY0xvY2Fsc3x8XG4odGhpcy5fZnVuY0xvY2Fscz10aGlzLl9pZGVudHNNYXRjaGluZyhmdW5jdGlvbihnKXtyZXR1cm4gZyYxMDMwfSkpO3JldHVybiB0aGlzLl9mdW5jTG9jYWxzfTtlLnByb3RvdHlwZS5nZXRfZ2xvYmFscz1mdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09dGhpcy5nZXRfdHlwZSgpLFwiZ2V0X2dsb2JhbHMgb25seSB2YWxpZCBmb3IgZnVuY3Rpb24gc2NvcGVzXCIpO3RoaXMuX2Z1bmNHbG9iYWxzfHwodGhpcy5fZnVuY0dsb2JhbHM9dGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oZyl7Zz1nPj4xMSY3O3JldHVybiAzPT1nfHwyPT1nfSkpO3JldHVybiB0aGlzLl9mdW5jR2xvYmFsc307ZS5wcm90b3R5cGUuZ2V0X2ZyZWVzPWZ1bmN0aW9uKCl7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT10aGlzLmdldF90eXBlKCksXCJnZXRfZnJlZXMgb25seSB2YWxpZCBmb3IgZnVuY3Rpb24gc2NvcGVzXCIpO3RoaXMuX2Z1bmNGcmVlc3x8KHRoaXMuX2Z1bmNGcmVlcz1cbnRoaXMuX2lkZW50c01hdGNoaW5nKGZ1bmN0aW9uKGcpe3JldHVybiA0PT0oZz4+MTEmNyl9KSk7cmV0dXJuIHRoaXMuX2Z1bmNGcmVlc307ZS5wcm90b3R5cGUuZ2V0X21ldGhvZHM9ZnVuY3Rpb24oKXt2YXIgZztTay5hc3NlcnRzLmFzc2VydChcImNsYXNzXCI9PXRoaXMuZ2V0X3R5cGUoKSxcImdldF9tZXRob2RzIG9ubHkgdmFsaWQgZm9yIGNsYXNzIHNjb3Blc1wiKTtpZighdGhpcy5fY2xhc3NNZXRob2RzKXt2YXIgYT1bXTtmb3IoZz0wO2c8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytnKWEucHVzaCh0aGlzLmNoaWxkcmVuW2ddLm5hbWUpO2Euc29ydCgpO3RoaXMuX2NsYXNzTWV0aG9kcz1hfXJldHVybiB0aGlzLl9jbGFzc01ldGhvZHN9O2UucHJvdG90eXBlLmdldFNjb3BlPWZ1bmN0aW9uKGcpe2c9dGhpcy5zeW1GbGFnc1tnXTtyZXR1cm4gdm9pZCAwPT09Zz8wOmc+PjExJjd9O2QucHJvdG90eXBlLmdldFN0c0ZvckFzdD1mdW5jdGlvbihnKXtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1cbmcuc2NvcGVJZCxcImFzdCB3YXNuJ3QgYWRkZWQgdG8gc3Q/XCIpO2c9dGhpcy5zdHNzW2cuc2NvcGVJZF07U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09ZyxcInVua25vd24gc3ltIHRhYiBlbnRyeVwiKTtyZXR1cm4gZ307ZC5wcm90b3R5cGUuU0VRU3RtdD1mdW5jdGlvbihnKXt2YXIgYSxjO2lmKG51bGwhPT1nKXtTay5hc3NlcnRzLmFzc2VydChTay5pc0FycmF5TGlrZShnKSxcIlNFUTogbm9kZXMgaXNuJ3QgYXJyYXk/IGdvdCBcIitnLnRvU3RyaW5nKCkpO3ZhciBuPWcubGVuZ3RoO2ZvcihjPTA7YzxuOysrYykoYT1nW2NdKSYmdGhpcy52aXNpdFN0bXQoYSl9fTtkLnByb3RvdHlwZS5TRVFFeHByPWZ1bmN0aW9uKGcpe3ZhciBhLGM7aWYobnVsbCE9PWcpe1NrLmFzc2VydHMuYXNzZXJ0KFNrLmlzQXJyYXlMaWtlKGcpLFwiU0VROiBub2RlcyBpc24ndCBhcnJheT8gZ290IFwiK2cudG9TdHJpbmcoKSk7dmFyIG49Zy5sZW5ndGg7Zm9yKGM9MDtjPG47KytjKShhPWdbY10pJiZ0aGlzLnZpc2l0RXhwcihhKX19O1xuZC5wcm90b3R5cGUuZW50ZXJCbG9jaz1mdW5jdGlvbihnLGEsYyxuKXtnPVNrLmZpeFJlc2VydmVkKGcpO3ZhciBtPW51bGw7dGhpcy5jdXImJihtPXRoaXMuY3VyLHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cikpO3RoaXMuY3VyPW5ldyBlKHRoaXMsZyxhLGMsbik7XCJ0b3BcIj09PWcmJih0aGlzLmdsb2JhbD10aGlzLmN1ci5zeW1GbGFncyk7bSYmbS5jaGlsZHJlbi5wdXNoKHRoaXMuY3VyKX07ZC5wcm90b3R5cGUuZXhpdEJsb2NrPWZ1bmN0aW9uKCl7dGhpcy5jdXI9bnVsbDswPHRoaXMuc3RhY2subGVuZ3RoJiYodGhpcy5jdXI9dGhpcy5zdGFjay5wb3AoKSl9O2QucHJvdG90eXBlLnZpc2l0UGFyYW1zPWZ1bmN0aW9uKGcsYSl7dmFyIGM7Zm9yKGM9MDtjPGcubGVuZ3RoOysrYylpZihhPWdbY10sYS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLmFyZyl0aGlzLmFkZERlZihhLmFyZyw0LGEubGluZW5vKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW52YWxpZCBleHByZXNzaW9uIGluIHBhcmFtZXRlciBsaXN0XCIsXG50aGlzLmZpbGVuYW1lKTt9O2QucHJvdG90eXBlLnZpc2l0QW5ub3RhdGlvbnM9ZnVuY3Rpb24oZyxhKXtnLnBvc29ubHlhcmdzJiZ0aGlzLnZpc2l0QXJnQW5ub3RhdGlvbnMoZy5wb3Nvbmx5YXJncyk7Zy5hcmdzJiZ0aGlzLnZpc2l0QXJnQW5ub3RhdGlvbnMoZy5hcmdzKTtnLnZhcmFyZyYmZy52YXJhcmcuYW5ub3RhdGlvbiYmdGhpcy52aXNpdEV4cHIoZy52YXJhcmcuYW5ub3RhdGlvbik7Zy5rd2FyZyYmZy5rd2FyZy5hbm5vdGF0aW9uJiZ0aGlzLnZpc2l0RXhwcihnLmt3YXJnLmFubm90YXRpb24pO2cua3dvbmx5YXJncyYmdGhpcy52aXNpdEFyZ0Fubm90YXRpb25zKGcua3dvbmx5YXJncyk7YSYmdGhpcy52aXNpdEV4cHIoYSl9O2QucHJvdG90eXBlLnZpc2l0QXJnQW5ub3RhdGlvbnM9ZnVuY3Rpb24oZyl7Zm9yKGxldCBhPTA7YTxnLmxlbmd0aDthKyspe2NvbnN0IGM9Z1thXTtjLmFubm90YXRpb24mJnRoaXMudmlzaXRFeHByKGMuYW5ub3RhdGlvbil9fTtkLnByb3RvdHlwZS52aXNpdEFyZ3VtZW50cz1cbmZ1bmN0aW9uKGcsYSl7Zy5hcmdzJiZ0aGlzLnZpc2l0UGFyYW1zKGcuYXJncywhMCk7Zy5rd29ubHlhcmdzJiZ0aGlzLnZpc2l0UGFyYW1zKGcua3dvbmx5YXJncywhMCk7Zy52YXJhcmcmJih0aGlzLmFkZERlZihnLnZhcmFyZy5hcmcsNCxhKSx0aGlzLmN1ci52YXJhcmdzPSEwKTtnLmt3YXJnJiYodGhpcy5hZGREZWYoZy5rd2FyZy5hcmcsNCxhKSx0aGlzLmN1ci52YXJrZXl3b3Jkcz0hMCl9O2QucHJvdG90eXBlLm5ld1RtcG5hbWU9ZnVuY3Rpb24oZyl7dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwiX1tcIisgKyt0aGlzLnRtcG5hbWUrXCJdXCIpLDIsZyl9O2QucHJvdG90eXBlLmFkZERlZj1mdW5jdGlvbihnLGEsYyl7dmFyIG49U2subWFuZ2xlTmFtZSh0aGlzLmN1ckNsYXNzLGcpLnY7bj1Tay5maXhSZXNlcnZlZChuKTt2YXIgbT10aGlzLmN1ci5zeW1GbGFnc1tuXTtpZih2b2lkIDAhPT1tKXtpZihhJjQmJm0mNCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImR1cGxpY2F0ZSBhcmd1bWVudCAnXCIrXG5nLnYrXCInIGluIGZ1bmN0aW9uIGRlZmluaXRpb25cIix0aGlzLmZpbGVuYW1lLGMpO218PWF9ZWxzZSBtPWE7dGhpcy5jdXIuc3ltRmxhZ3Nbbl09bTthJjQ/dGhpcy5jdXIudmFybmFtZXMucHVzaChuKTphJjEmJihtPWEsZz10aGlzLmdsb2JhbFtuXSx2b2lkIDAhPT1nJiYobXw9ZyksdGhpcy5nbG9iYWxbbl09bSl9O2QucHJvdG90eXBlLnZpc2l0U2xpY2U9ZnVuY3Rpb24oZyl7dmFyIGE7c3dpdGNoKGcuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuU2xpY2U6Zy5sb3dlciYmdGhpcy52aXNpdEV4cHIoZy5sb3dlcik7Zy51cHBlciYmdGhpcy52aXNpdEV4cHIoZy51cHBlcik7Zy5zdGVwJiZ0aGlzLnZpc2l0RXhwcihnLnN0ZXApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRXh0U2xpY2U6Zm9yKGE9MDthPGcuZGltcy5sZW5ndGg7KythKXRoaXMudmlzaXRTbGljZShnLmRpbXNbYV0pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSW5kZXg6dGhpcy52aXNpdEV4cHIoZy52YWx1ZSl9fTtcbmQucHJvdG90eXBlLnZpc2l0U3RtdD1mdW5jdGlvbihnKXt2YXIgYTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1nLFwidmlzaXRTdG10IGNhbGxlZCB3aXRoIHVuZGVmaW5lZFwiKTtzd2l0Y2goZy5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZjp0aGlzLmFkZERlZihnLm5hbWUsMixnLmxpbmVubyk7Zy5hcmdzLmRlZmF1bHRzJiZ0aGlzLlNFUUV4cHIoZy5hcmdzLmRlZmF1bHRzKTtnLmRlY29yYXRvcl9saXN0JiZ0aGlzLlNFUUV4cHIoZy5kZWNvcmF0b3JfbGlzdCk7dGhpcy52aXNpdEFubm90YXRpb25zKGcuYXJncyxnLnJldHVybnMpO3RoaXMuZW50ZXJCbG9jayhnLm5hbWUudixcImZ1bmN0aW9uXCIsZyxnLmxpbmVubyk7dGhpcy52aXNpdEFyZ3VtZW50cyhnLmFyZ3MsZy5saW5lbm8pO3RoaXMuU0VRU3RtdChnLmJvZHkpO3RoaXMuZXhpdEJsb2NrKCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5DbGFzc0RlZjp0aGlzLmFkZERlZihnLm5hbWUsMixnLmxpbmVubyk7XG50aGlzLlNFUUV4cHIoZy5iYXNlcyk7Zy5kZWNvcmF0b3JfbGlzdCYmdGhpcy5TRVFFeHByKGcuZGVjb3JhdG9yX2xpc3QpO3RoaXMuZW50ZXJCbG9jayhnLm5hbWUudixcImNsYXNzXCIsZyxnLmxpbmVubyk7dGhpcy5jdXJDbGFzcz1nLm5hbWU7dGhpcy5TRVFTdG10KGcuYm9keSk7dGhpcy5leGl0QmxvY2soKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlJldHVybjpnLnZhbHVlJiYodGhpcy52aXNpdEV4cHIoZy52YWx1ZSksdGhpcy5jdXIucmV0dXJuc1ZhbHVlPSEwKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbGV0ZTp0aGlzLlNFUUV4cHIoZy50YXJnZXRzKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkFzc2lnbjp0aGlzLlNFUUV4cHIoZy50YXJnZXRzKTt0aGlzLnZpc2l0RXhwcihnLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkFubkFzc2lnbjppZihnLnRhcmdldC5jb25zdHJ1Y3Rvcj09U2suYXN0bm9kZXMuTmFtZSl7dmFyIGM9Zy50YXJnZXQ7dmFyIG49U2subWFuZ2xlTmFtZSh0aGlzLmN1ckNsYXNzLFxuYy5pZCkudjtuPVNrLmZpeFJlc2VydmVkKG4pO2M9dGhpcy5jdXIuc3ltRmxhZ3Nbbl07aWYoYyYyMDQ5JiZ0aGlzLmdsb2JhbCE9dGhpcy5jdXIuc3ltRmxhZ3MmJmcuc2ltcGxlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYW5ub3RhdGVkIG5hbWUgJ1wiK24rXCInIGNhbid0IGJlIGdsb2JhbFwiLHRoaXMuZmlsZW5hbWUsZy5saW5lbm8pO2cuc2ltcGxlP3RoaXMuYWRkRGVmKG5ldyBTay5idWlsdGluLnN0cihuKSw0MDk4LGcubGluZW5vKTpnLnZhbHVlJiZ0aGlzLmFkZERlZihuZXcgU2suYnVpbHRpbi5zdHIobiksMixnLmxpbmVubyl9ZWxzZSB0aGlzLnZpc2l0RXhwcihnLnRhcmdldCk7dGhpcy52aXNpdEV4cHIoZy5hbm5vdGF0aW9uKTtnLnZhbHVlJiZ0aGlzLnZpc2l0RXhwcihnLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkF1Z0Fzc2lnbjp0aGlzLnZpc2l0RXhwcihnLnRhcmdldCk7dGhpcy52aXNpdEV4cHIoZy52YWx1ZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5QcmludDpnLmRlc3QmJlxudGhpcy52aXNpdEV4cHIoZy5kZXN0KTt0aGlzLlNFUUV4cHIoZy52YWx1ZXMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRm9yOnRoaXMudmlzaXRFeHByKGcudGFyZ2V0KTt0aGlzLnZpc2l0RXhwcihnLml0ZXIpO3RoaXMuU0VRU3RtdChnLmJvZHkpO2cub3JlbHNlJiZ0aGlzLlNFUVN0bXQoZy5vcmVsc2UpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuV2hpbGU6dGhpcy52aXNpdEV4cHIoZy50ZXN0KTt0aGlzLlNFUVN0bXQoZy5ib2R5KTtnLm9yZWxzZSYmdGhpcy5TRVFTdG10KGcub3JlbHNlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLklmOnRoaXMudmlzaXRFeHByKGcudGVzdCk7dGhpcy5TRVFTdG10KGcuYm9keSk7Zy5vcmVsc2UmJnRoaXMuU0VRU3RtdChnLm9yZWxzZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5SYWlzZTpnLmV4YyYmKHRoaXMudmlzaXRFeHByKGcuZXhjKSxnLmluc3QmJih0aGlzLnZpc2l0RXhwcihnLmluc3QpLGcudGJhY2smJnRoaXMudmlzaXRFeHByKGcudGJhY2spKSxcbmcuY2F1c2UmJnRoaXMudmlzaXRFeHByKGcuY2F1c2UpKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkFzc2VydDp0aGlzLnZpc2l0RXhwcihnLnRlc3QpO2cubXNnJiZ0aGlzLnZpc2l0RXhwcihnLm1zZyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5JbXBvcnQ6Y2FzZSBTay5hc3Rub2Rlcy5JbXBvcnRGcm9tOnRoaXMudmlzaXRBbGlhcyhnLm5hbWVzLGcubGluZW5vKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkdsb2JhbDp2YXIgbT1nLm5hbWVzLmxlbmd0aDtmb3IoYT0wO2E8bTsrK2Epe249U2subWFuZ2xlTmFtZSh0aGlzLmN1ckNsYXNzLGcubmFtZXNbYV0pLnY7bj1Tay5maXhSZXNlcnZlZChuKTtjPXRoaXMuY3VyLnN5bUZsYWdzW25dO2lmKGMmMTApe2lmKGMmMil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5hbWUgJ1wiK24rXCInIGlzIGFzc2lnbmVkIHRvIGJlZm9yZSBnbG9iYWwgZGVjbGFyYXRpb25cIix0aGlzLmZpbGVuYW1lLGcubGluZW5vKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5hbWUgJ1wiK1xubitcIicgaXMgdXNlZCBwcmlvciB0byBnbG9iYWwgZGVjbGFyYXRpb25cIix0aGlzLmZpbGVuYW1lLGcubGluZW5vKTt9dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKG4pLDEsZy5saW5lbm8pfWJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRXhwcjp0aGlzLnZpc2l0RXhwcihnLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlBhc3M6Y2FzZSBTay5hc3Rub2Rlcy5CcmVhazpjYXNlIFNrLmFzdG5vZGVzLkNvbnRpbnVlOmNhc2UgU2suYXN0bm9kZXMuRGVidWdnZXI6YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5XaXRoOmYodGhpcy52aXNpdF93aXRoaXRlbS5iaW5kKHRoaXMpLGcuaXRlbXMpO2YodGhpcy52aXNpdFN0bXQuYmluZCh0aGlzKSxnLmJvZHkpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuVHJ5OnRoaXMuU0VRU3RtdChnLmJvZHkpO3RoaXMudmlzaXRFeGNlcHRoYW5kbGVycyhnLmhhbmRsZXJzKTt0aGlzLlNFUVN0bXQoZy5vcmVsc2UpO3RoaXMuU0VRU3RtdChnLmZpbmFsYm9keSk7XG5icmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcIlVuaGFuZGxlZCB0eXBlIFwiK2cuY29uc3RydWN0b3IubmFtZStcIiBpbiB2aXNpdFN0bXRcIil9fTtkLnByb3RvdHlwZS52aXNpdF93aXRoaXRlbT1mdW5jdGlvbihnKXt0aGlzLnZpc2l0RXhwcihnLmNvbnRleHRfZXhwcik7Zy5vcHRpb25hbF92YXJzJiZ0aGlzLnZpc2l0RXhwcihnLm9wdGlvbmFsX3ZhcnMpfTtkLnByb3RvdHlwZS52aXNpdEV4cHI9ZnVuY3Rpb24oZyl7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09ZyxcInZpc2l0RXhwciBjYWxsZWQgd2l0aCB1bmRlZmluZWRcIik7c3dpdGNoKGcuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuQm9vbE9wOnRoaXMuU0VRRXhwcihnLnZhbHVlcyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5CaW5PcDp0aGlzLnZpc2l0RXhwcihnLmxlZnQpO3RoaXMudmlzaXRFeHByKGcucmlnaHQpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuVW5hcnlPcDp0aGlzLnZpc2l0RXhwcihnLm9wZXJhbmQpO1xuYnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5MYW1iZGE6dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwibGFtYmRhXCIpLDIsZy5saW5lbm8pO2cuYXJncy5kZWZhdWx0cyYmdGhpcy5TRVFFeHByKGcuYXJncy5kZWZhdWx0cyk7dGhpcy5lbnRlckJsb2NrKFwibGFtYmRhXCIsXCJmdW5jdGlvblwiLGcsZy5saW5lbm8pO3RoaXMudmlzaXRBcmd1bWVudHMoZy5hcmdzLGcubGluZW5vKTt0aGlzLnZpc2l0RXhwcihnLmJvZHkpO3RoaXMuZXhpdEJsb2NrKCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5JZkV4cDp0aGlzLnZpc2l0RXhwcihnLnRlc3QpO3RoaXMudmlzaXRFeHByKGcuYm9keSk7dGhpcy52aXNpdEV4cHIoZy5vcmVsc2UpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGljdDp0aGlzLlNFUUV4cHIoZy5rZXlzKTt0aGlzLlNFUUV4cHIoZy52YWx1ZXMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGljdENvbXA6Y2FzZSBTay5hc3Rub2Rlcy5TZXRDb21wOnRoaXMudmlzaXRDb21wcmVoZW5zaW9uKGcuZ2VuZXJhdG9ycyxcbjApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdENvbXA6dGhpcy5uZXdUbXBuYW1lKGcubGluZW5vKTt0aGlzLnZpc2l0RXhwcihnLmVsdCk7dGhpcy52aXNpdENvbXByZWhlbnNpb24oZy5nZW5lcmF0b3JzLDApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnRoaXMudmlzaXRHZW5leHAoZyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZEZyb206Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZDpnLnZhbHVlJiZ0aGlzLnZpc2l0RXhwcihnLnZhbHVlKTt0aGlzLmN1ci5nZW5lcmF0b3I9ITA7aWYodGhpcy5jdXIucmV0dXJuc1ZhbHVlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ3JldHVybicgd2l0aCBhcmd1bWVudCBpbnNpZGUgZ2VuZXJhdG9yXCIsdGhpcy5maWxlbmFtZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Db21wYXJlOnRoaXMudmlzaXRFeHByKGcubGVmdCk7dGhpcy5TRVFFeHByKGcuY29tcGFyYXRvcnMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ2FsbDp0aGlzLnZpc2l0RXhwcihnLmZ1bmMpO1xuaWYoZy5hcmdzKWZvcihsZXQgYSBvZiBnLmFyZ3MpYS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQ/dGhpcy52aXNpdEV4cHIoYS52YWx1ZSk6dGhpcy52aXNpdEV4cHIoYSk7aWYoZy5rZXl3b3Jkcylmb3IobGV0IGEgb2YgZy5rZXl3b3Jkcyl0aGlzLnZpc2l0RXhwcihhLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLk51bTpjYXNlIFNrLmFzdG5vZGVzLlN0cjpjYXNlIFNrLmFzdG5vZGVzLkJ5dGVzOmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSm9pbmVkU3RyOmZvcihsZXQgYSBvZiBnLnZhbHVlcyl0aGlzLnZpc2l0RXhwcihhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlOnRoaXMudmlzaXRFeHByKGcudmFsdWUpO2cuZm9ybWF0X3NwZWMmJnRoaXMudmlzaXRFeHByKGcuZm9ybWF0X3NwZWMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOnRoaXMudmlzaXRFeHByKGcudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OnRoaXMudmlzaXRFeHByKGcudmFsdWUpO1xudGhpcy52aXNpdFNsaWNlKGcuc2xpY2UpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTmFtZTp0aGlzLmFkZERlZihnLmlkLGcuY3R4PT09U2suYXN0bm9kZXMuTG9hZD84OjIsZy5saW5lbm8pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50OmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdDpjYXNlIFNrLmFzdG5vZGVzLlR1cGxlOmNhc2UgU2suYXN0bm9kZXMuU2V0OnRoaXMuU0VRRXhwcihnLmVsdHMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3RhcnJlZDp0aGlzLnZpc2l0RXhwcihnLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkVsbGlwc2lzOmJyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwiVW5oYW5kbGVkIHR5cGUgXCIrZy5jb25zdHJ1Y3Rvci5uYW1lK1wiIGluIHZpc2l0RXhwclwiKX19O2QucHJvdG90eXBlLnZpc2l0Q29tcHJlaGVuc2lvbj1mdW5jdGlvbihnLGEpe3ZhciBjLG49Zy5sZW5ndGg7Zm9yKGM9YTtjPG47KytjKWE9Z1tjXSx0aGlzLnZpc2l0RXhwcihhLnRhcmdldCksXG50aGlzLnZpc2l0RXhwcihhLml0ZXIpLHRoaXMuU0VRRXhwcihhLmlmcyl9O2QucHJvdG90eXBlLnZpc2l0QWxpYXM9ZnVuY3Rpb24oZyxhKXt2YXIgYyxuO2ZvcihuPTA7bjxnLmxlbmd0aDsrK24pe3ZhciBtPWdbbl07dmFyIGs9Yz1udWxsPT09bS5hc25hbWU/bS5uYW1lLnY6bS5hc25hbWUudjttPWMuaW5kZXhPZihcIi5cIik7LTEhPT1tJiYoaz1jLnN1YnN0cigwLG0pKTtpZihcIipcIiE9PWMpdGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKGspLDEwMjQsYSk7ZWxzZSBpZihcIm1vZHVsZVwiIT09dGhpcy5jdXIuYmxvY2tUeXBlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW1wb3J0ICogb25seSBhbGxvd2VkIGF0IG1vZHVsZSBsZXZlbFwiLHRoaXMuZmlsZW5hbWUpO319O2QucHJvdG90eXBlLnZpc2l0R2VuZXhwPWZ1bmN0aW9uKGcpe3ZhciBhPWcuZ2VuZXJhdG9yc1swXTt0aGlzLnZpc2l0RXhwcihhLml0ZXIpO3RoaXMuZW50ZXJCbG9jayhcImdlbmV4cHJcIixcImZ1bmN0aW9uXCIsXG5nLGcubGluZW5vKTt0aGlzLmN1ci5nZW5lcmF0b3I9ITA7dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwiLjBcIiksNCxnLmxpbmVubyk7dGhpcy52aXNpdEV4cHIoYS50YXJnZXQpO3RoaXMuU0VRRXhwcihhLmlmcyk7dGhpcy52aXNpdENvbXByZWhlbnNpb24oZy5nZW5lcmF0b3JzLDEpO3RoaXMudmlzaXRFeHByKGcuZWx0KTt0aGlzLmV4aXRCbG9jaygpfTtkLnByb3RvdHlwZS52aXNpdEV4Y2VwdGhhbmRsZXJzPWZ1bmN0aW9uKGcpe3ZhciBhLGM7Zm9yKGE9MDtjPWdbYV07KythKWMudHlwZSYmdGhpcy52aXNpdEV4cHIoYy50eXBlKSxjLm5hbWUmJnRoaXMudmlzaXRFeHByKGMubmFtZSksdGhpcy5TRVFTdG10KGMuYm9keSl9O2QucHJvdG90eXBlLmFuYWx5emVCbG9jaz1mdW5jdGlvbihnLGEsYyxuKXt2YXIgbT17fTt2YXIgaz17fSx1PXt9LGw9e30scT17fTtcImNsYXNzXCI9PWcuYmxvY2tUeXBlJiYoaCh1LG4pLGEmJmgobCxhKSk7Zm9yKHIgaW4gZy5zeW1GbGFncyl7dmFyIHo9XG5nLnN5bUZsYWdzW3JdO3RoaXMuYW5hbHl6ZU5hbWUoZyxrLHIseixhLG0sYyxuKX1cImNsYXNzXCIhPT1nLmJsb2NrVHlwZSYmKFwiZnVuY3Rpb25cIj09PWcuYmxvY2tUeXBlJiZoKGwsbSksYSYmaChsLGEpLGgodSxuKSk7bT17fTt2YXIgcj1nLmNoaWxkcmVuLmxlbmd0aDtmb3Ioej0wO3o8cjsrK3opaWYobj1nLmNoaWxkcmVuW3pdLHRoaXMuYW5hbHl6ZUNoaWxkQmxvY2sobixsLHEsdSxtKSxuLmhhc0ZyZWV8fG4uY2hpbGRIYXNGcmVlKWcuY2hpbGRIYXNGcmVlPSEwO2gocSxtKTtcImZ1bmN0aW9uXCI9PT1nLmJsb2NrVHlwZSYmdGhpcy5hbmFseXplQ2VsbHMoayxxKTthPXRoaXMudXBkYXRlU3ltYm9scyhnLnN5bUZsYWdzLGssYSxxLFwiY2xhc3NcIj09PWcuYmxvY2tUeXBlKTtnLmhhc0ZyZWU9Zy5oYXNGcmVlfHxhO2goYyxxKX07ZC5wcm90b3R5cGUuYW5hbHl6ZUNoaWxkQmxvY2s9ZnVuY3Rpb24oZyxhLGMsbixtKXt2YXIgaz17fTtoKGssYSk7YT17fTtoKGEsYyk7Yz17fTtoKGMsbik7XG50aGlzLmFuYWx5emVCbG9jayhnLGssYSxjKTtoKG0sYSl9O2QucHJvdG90eXBlLmFuYWx5emVDZWxscz1mdW5jdGlvbihnLGEpe3ZhciBjO2ZvcihjIGluIGcpe3ZhciBuPWdbY107MT09PW4mJnZvaWQgMCE9PWFbY10mJihnW2NdPTUsZGVsZXRlIGFbY10pfX07ZC5wcm90b3R5cGUudXBkYXRlU3ltYm9scz1mdW5jdGlvbihnLGEsYyxuLG0pe3ZhciBrLHU9ITE7Zm9yKGsgaW4gZyl7dmFyIGw9Z1trXTt2YXIgcT1hW2tdO2x8PXE8PDExO2dba109bH1mb3IoayBpbiBuKWE9Z1trXSx2b2lkIDAhPT1hP20mJmEmMTAzMSYmKGF8PTUxMixnW2tdPWEpOnZvaWQgMCE9PWNba10mJihnW2tdPTgxOTIsdT0hMCk7cmV0dXJuIHV9O2QucHJvdG90eXBlLmFuYWx5emVOYW1lPWZ1bmN0aW9uKGcsYSxjLG4sbSxrLHUsbCl7aWYobiYxKXtpZihuJjQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJuYW1lICdcIitjK1wiJyBpcyBsb2NhbCBhbmQgZ2xvYmFsXCIsdGhpcy5maWxlbmFtZSxnLmxpbmVubyk7XG5hW2NdPTI7bFtjXT1udWxsO20mJnZvaWQgMCE9PW1bY10mJmRlbGV0ZSBtW2NdfWVsc2UgbiYxMDMwPyhhW2NdPTEsa1tjXT1udWxsLGRlbGV0ZSBsW2NdKTptJiZ2b2lkIDAhPT1tW2NdPyhhW2NdPTQsZy5oYXNGcmVlPSEwLHVbY109bnVsbCk6KGwmJnZvaWQgMCE9PWxbY118fCFnLmlzTmVzdGVkfHwoZy5oYXNGcmVlPSEwKSxhW2NdPTMpfTtkLnByb3RvdHlwZS5hbmFseXplPWZ1bmN0aW9uKCl7dGhpcy5hbmFseXplQmxvY2sodGhpcy50b3AsbnVsbCx7fSx7fSl9O1NrLnN5bWJvbHRhYmxlPWZ1bmN0aW9uKGcsYSl7dmFyIGM9bmV3IGQoYSk7Yy5lbnRlckJsb2NrKFwidG9wXCIsXCJtb2R1bGVcIixnLDApO2MudG9wPWMuY3VyO2ZvcihhPTA7YTxnLmJvZHkubGVuZ3RoOysrYSljLnZpc2l0U3RtdChnLmJvZHlbYV0pO2MuZXhpdEJsb2NrKCk7Yy5hbmFseXplKCk7cmV0dXJuIGN9O1NrLmR1bXBTeW10YWI9ZnVuY3Rpb24oZyl7dmFyIGE9ZnVuY3Rpb24obSl7cmV0dXJuIG0/XCJUcnVlXCI6XG5cIkZhbHNlXCJ9LGM9ZnVuY3Rpb24obSl7dmFyIGssdT1bXTtmb3Ioaz0wO2s8bS5sZW5ndGg7KytrKXUucHVzaCgobmV3IFNrLmJ1aWx0aW4uc3RyKG1ba10pKS4kcigpLnYpO3JldHVyblwiW1wiK3Uuam9pbihcIiwgXCIpK1wiXVwifSxuPWZ1bmN0aW9uKG0sayl7dmFyIHUsbDt2b2lkIDA9PT1rJiYoaz1cIlwiKTt2YXIgcT1rK1wiU3ltX3R5cGU6IFwiK20uZ2V0X3R5cGUoKStcIlxcblwiO3ErPWsrXCJTeW1fbmFtZTogXCIrbS5nZXRfbmFtZSgpK1wiXFxuXCI7cSs9aytcIlN5bV9saW5lbm86IFwiK20uZ2V0X2xpbmVubygpK1wiXFxuXCI7cSs9aytcIlN5bV9uZXN0ZWQ6IFwiK2EobS5pc19uZXN0ZWQoKSkrXCJcXG5cIjtxKz1rK1wiU3ltX2hhc2NoaWxkcmVuOiBcIithKG0uaGFzX2NoaWxkcmVuKCkpK1wiXFxuXCI7XCJjbGFzc1wiPT09bS5nZXRfdHlwZSgpP3ErPWsrXCJDbGFzc19tZXRob2RzOiBcIitjKG0uZ2V0X21ldGhvZHMoKSkrXCJcXG5cIjpcImZ1bmN0aW9uXCI9PT1tLmdldF90eXBlKCkmJihxKz1rK1wiRnVuY19wYXJhbXM6IFwiK2MobS5nZXRfcGFyYW1ldGVycygpKStcblwiXFxuXCIscSs9aytcIkZ1bmNfbG9jYWxzOiBcIitjKG0uZ2V0X2xvY2FscygpKStcIlxcblwiLHErPWsrXCJGdW5jX2dsb2JhbHM6IFwiK2MobS5nZXRfZ2xvYmFscygpKStcIlxcblwiLHErPWsrXCJGdW5jX2ZyZWVzOiBcIitjKG0uZ2V0X2ZyZWVzKCkpK1wiXFxuXCIpO3ErPWsrXCItLSBJZGVudGlmaWVycyAtLVxcblwiO3ZhciB6PW0uZ2V0X2lkZW50aWZpZXJzKCk7dmFyIHI9ei5sZW5ndGg7Zm9yKGw9MDtsPHI7KytsKXt2YXIgdD1tLmxvb2t1cCh6W2xdKTtxKz1rK1wibmFtZTogXCIrdC5nZXRfbmFtZSgpK1wiXFxuXCI7cSs9aytcIiAgaXNfcmVmZXJlbmNlZDogXCIrYSh0LmlzX3JlZmVyZW5jZWQoKSkrXCJcXG5cIjtxKz1rK1wiICBpc19pbXBvcnRlZDogXCIrYSh0LmlzX2ltcG9ydGVkKCkpK1wiXFxuXCI7cSs9aytcIiAgaXNfcGFyYW1ldGVyOiBcIithKHQuaXNfcGFyYW1ldGVyKCkpK1wiXFxuXCI7cSs9aytcIiAgaXNfZ2xvYmFsOiBcIithKHQuaXNfZ2xvYmFsKCkpK1wiXFxuXCI7cSs9aytcIiAgaXNfZGVjbGFyZWRfZ2xvYmFsOiBcIithKHQuaXNfZGVjbGFyZWRfZ2xvYmFsKCkpK1xuXCJcXG5cIjtxKz1rK1wiICBpc19sb2NhbDogXCIrYSh0LmlzX2xvY2FsKCkpK1wiXFxuXCI7cSs9aytcIiAgaXNfZnJlZTogXCIrYSh0LmlzX2ZyZWUoKSkrXCJcXG5cIjtxKz1rK1wiICBpc19hc3NpZ25lZDogXCIrYSh0LmlzX2Fzc2lnbmVkKCkpK1wiXFxuXCI7cSs9aytcIiAgaXNfbmFtZXNwYWNlOiBcIithKHQuaXNfbmFtZXNwYWNlKCkpK1wiXFxuXCI7dmFyIHg9dC5nZXRfbmFtZXNwYWNlcygpO3ZhciB2PXgubGVuZ3RoO3ErPWsrXCIgIG5hbWVzcGFjZXM6IFtcXG5cIjt2YXIgQj1bXTtmb3IodT0wO3U8djsrK3UpdD14W3VdLEIucHVzaChuKHQsaytcIiAgICBcIikpO3ErPUIuam9pbihcIlxcblwiKTtxKz1rK1wiICBdXFxuXCJ9cmV0dXJuIHF9O3JldHVybiBuKGcudG9wLFwiXCIpfTtTay5leHBvcnRTeW1ib2woXCJTay5zeW1ib2x0YWJsZVwiLFNrLnN5bWJvbHRhYmxlKTtTay5leHBvcnRTeW1ib2woXCJTay5kdW1wU3ltdGFiXCIsU2suZHVtcFN5bXRhYil9LGZ1bmN0aW9uKEYsUCl7ZnVuY3Rpb24gYihhLGMsbixtLGspe3RoaXMuZmlsZW5hbWU9XG5hO3RoaXMuc3Q9Yzt0aGlzLmZsYWdzPW47dGhpcy5jYW5TdXNwZW5kPW07dGhpcy5pbnRlcmFjdGl2ZT0hMTt0aGlzLm5lc3RsZXZlbD0wO3RoaXMudT1udWxsO3RoaXMuc3RhY2s9W107dGhpcy5yZXN1bHQ9W107dGhpcy5hbGxVbml0cz1bXTt0aGlzLnNvdXJjZT1rP2suc3BsaXQoXCJcXG5cIik6ITF9ZnVuY3Rpb24gZSgpe3RoaXMubmFtZT10aGlzLnN0ZT1udWxsO3RoaXMuZG9lc1N1c3BlbmQ9dGhpcy5jYW5TdXNwZW5kPSExO3RoaXMucHJpdmF0ZV89bnVsbDt0aGlzLmxpbmVubz10aGlzLmZpcnN0bGluZW5vPTA7dGhpcy5saW5lbm9TZXQ9ITE7dGhpcy5sb2NhbG5hbWVzPVtdO3RoaXMubG9jYWx0ZW1wcz1bXTt0aGlzLnRlbXBzVG9TYXZlPVtdO3RoaXMuYmxvY2tudW09MDt0aGlzLmJsb2Nrcz1bXTt0aGlzLmN1cmJsb2NrPTA7dGhpcy5jb25zdHM9e307dGhpcy5zY29wZW5hbWU9bnVsbDt0aGlzLnN1ZmZpeENvZGU9dGhpcy5zd2l0Y2hDb2RlPXRoaXMudmFyRGVjbHNDb2RlPXRoaXMucHJlZml4Q29kZT1cblwiXCI7dGhpcy5icmVha0Jsb2Nrcz1bXTt0aGlzLmNvbnRpbnVlQmxvY2tzPVtdO3RoaXMuZXhjZXB0QmxvY2tzPVtdO3RoaXMuZmluYWxseUJsb2Nrcz1bXX1mdW5jdGlvbiBkKGEpe3JldHVybiB2b2lkIDA9PT1wW2FdP2E6YStcIl8kcnckXCJ9ZnVuY3Rpb24gZihhLGMpe3ZhciBuPWMudjtpZihudWxsPT09YXx8bnVsbD09PW58fFwiX1wiIT09bi5jaGFyQXQoMCl8fFwiX1wiIT09bi5jaGFyQXQoMSl8fFwiX1wiPT09bi5jaGFyQXQobi5sZW5ndGgtMSkmJlwiX1wiPT09bi5jaGFyQXQobi5sZW5ndGgtMikpcmV0dXJuIGM7dmFyIG09YS52O20ucmVwbGFjZSgvXy9nLFwiXCIpO2lmKFwiXCI9PT1tKXJldHVybiBjO209YS52O20ucmVwbGFjZSgvXl8qLyxcIlwiKTtyZXR1cm4gbT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfXCIrbStuKX12YXIgaDtTay5nZW5zeW1jb3VudD0wO2UucHJvdG90eXBlLmFjdGl2YXRlU2NvcGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2g9ZnVuY3Rpb24oKXt2YXIgYyxuPWEuYmxvY2tzW2EuY3VyYmxvY2tdO1xuaWYobnVsbD09PW4uX25leHQpZm9yKGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7KytjKW4ucHVzaChhcmd1bWVudHNbY10pfX07Yi5wcm90b3R5cGUuZ2V0U291cmNlTGluZT1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzLnNvdXJjZSk7cmV0dXJuIHRoaXMuc291cmNlW2EtMV19O2IucHJvdG90eXBlLmFubm90YXRlU291cmNlPWZ1bmN0aW9uKGEpe3ZhciBjO2lmKHRoaXMuc291cmNlKXt2YXIgbj1hLmxpbmVubzt2YXIgbT1hLmNvbF9vZmZzZXQ7aChcIlxcbi8vXFxuLy8gbGluZSBcIixuLFwiOlxcbi8vIFwiLHRoaXMuZ2V0U291cmNlTGluZShuKSxcIlxcbi8vIFwiKTtmb3IoYz0wO2M8bTsrK2MpaChcIiBcIik7aChcIl5cXG4vL1xcblwiKTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1hLmxpbmVubyYmdm9pZCAwIT09YS5jb2xfb2Zmc2V0KTtoKFwiJGN1cnJMaW5lTm8gPSBcIixuLFwiO1xcbiRjdXJyQ29sTm8gPSBcIixtLFwiO1xcblxcblwiKX19O2IucHJvdG90eXBlLmdlbnN5bT1mdW5jdGlvbihhKXtyZXR1cm4gYT1cblwiJFwiKyhhfHxcIlwiKStTay5nZW5zeW1jb3VudCsrfTtiLnByb3RvdHlwZS5uaWNlTmFtZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZW5zeW0oYS5yZXBsYWNlKFwiPFwiLFwiXCIpLnJlcGxhY2UoXCI+XCIsXCJcIikucmVwbGFjZShcIiBcIixcIl9cIikpfTt2YXIgcD1Tay5idWlsdGluLnN0ci5yZXNlcnZlZFdvcmRzXztiLnByb3RvdHlwZS5tYWtlQ29uc3RhbnQ9ZnVuY3Rpb24oYSl7dmFyIGMsbj1cIlwiO2ZvcihjPTA7Yzxhcmd1bWVudHMubGVuZ3RoOysrYyluKz1hcmd1bWVudHNbY107Zm9yKG0gaW4gdGhpcy51LmNvbnN0cylpZih0aGlzLnUuY29uc3RzLmhhc093blByb3BlcnR5KG0pJiYoYz10aGlzLnUuY29uc3RzW21dLGM9PW4pKXJldHVybiBtO3ZhciBtPXRoaXMudS5zY29wZW5hbWUrXCIuXCIrdGhpcy5nZW5zeW0oXCJjb25zdFwiKTt0aGlzLnUuY29uc3RzW21dPW47cmV0dXJuIG19O2IucHJvdG90eXBlLl9ncj1mdW5jdGlvbihhLGMpe3ZhciBuLG09dGhpcy5nZW5zeW0oYSk7dGhpcy51LmxvY2FsdGVtcHMucHVzaChtKTtcbmgoXCJ2YXIgXCIsbSxcIj1cIik7Zm9yKG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7KytuKWgoYXJndW1lbnRzW25dKTtoKFwiO1wiKTtyZXR1cm4gbX07Yi5wcm90b3R5cGUub3V0cHV0SW50ZXJydXB0VGVzdD1mdW5jdGlvbigpe3ZhciBhPVwiXCI7aWYobnVsbCE9PVNrLmV4ZWNMaW1pdHx8bnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kKWErPVwidmFyICRkYXRlTm93ID0gRGF0ZS5ub3coKTtcIixudWxsIT09U2suZXhlY0xpbWl0JiYoYSs9XCJpZiAoJGRhdGVOb3cgLSBTay5leGVjU3RhcnQgPiBTay5leGVjTGltaXQpIHt0aHJvdyBuZXcgU2suYnVpbHRpbi5UaW1lb3V0RXJyb3IoU2sudGltZW91dE1zZygpKX1cIiksbnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kJiYoYT1hK1wiaWYgKCEkd2FraW5nICYmICgkZGF0ZU5vdyAtIFNrLmxhc3RZaWVsZCA+IFNrLnlpZWxkTGltaXQpKSB7dmFyICRzdXNwID0gJHNhdmVTdXNwZW5zaW9uKHtkYXRhOiB7dHlwZTogJ1NrLnlpZWxkJ30sIHJlc3VtZTogZnVuY3Rpb24oKSB7fX0sICdcIitcbih0aGlzLmZpbGVuYW1lK1wiJywkY3VyckxpbmVObywkY3VyckNvbE5vKTtcIiksYSs9XCIkc3VzcC4kYmxrID0gJGJsazskc3VzcC5vcHRpb25hbCA9IHRydWU7cmV0dXJuICRzdXNwO30kd2FraW5nID0gZmFsc2U7XCIsdGhpcy51LmRvZXNTdXNwZW5kPSEwKTtyZXR1cm4gYX07Yi5wcm90b3R5cGUuX2p1bXBmYWxzZT1mdW5jdGlvbihhLGMpe2E9dGhpcy5fZ3IoXCJqZmFsc2VcIixcIihcIixhLFwiPT09ZmFsc2V8fCFTay5taXNjZXZhbC5pc1RydWUoXCIsYSxcIikpXCIpO2goXCJpZihcIixhLFwiKXsvKnRlc3QgZmFpbGVkICovJGJsaz1cIixjLFwiO2NvbnRpbnVlO31cIil9O2IucHJvdG90eXBlLl9qdW1wdW5kZWY9ZnVuY3Rpb24oYSxjKXtoKFwiaWYoXCIsYSxcIj09PXVuZGVmaW5lZCl7JGJsaz1cIixjLFwiO2NvbnRpbnVlO31cIil9O2IucHJvdG90eXBlLl9qdW1wbm90dW5kZWY9ZnVuY3Rpb24oYSxjKXtoKFwiaWYoXCIsYSxcIiE9PXVuZGVmaW5lZCl7JGJsaz1cIixjLFwiO2NvbnRpbnVlO31cIil9O2IucHJvdG90eXBlLl9qdW1wdHJ1ZT1cbmZ1bmN0aW9uKGEsYyl7YT10aGlzLl9ncihcImp0cnVlXCIsXCIoXCIsYSxcIj09PXRydWV8fFNrLm1pc2NldmFsLmlzVHJ1ZShcIixhLFwiKSlcIik7aChcImlmKFwiLGEsXCIpey8qdGVzdCBwYXNzZWQgKi8kYmxrPVwiLGMsXCI7Y29udGludWU7fVwiKX07Yi5wcm90b3R5cGUuX2p1bXA9ZnVuY3Rpb24oYSl7bnVsbD09PXRoaXMudS5ibG9ja3NbdGhpcy51LmN1cmJsb2NrXS5fbmV4dCYmKGgoXCIkYmxrPVwiLGEsXCI7XCIpLHRoaXMudS5ibG9ja3NbdGhpcy51LmN1cmJsb2NrXS5fbmV4dD1hKX07Yi5wcm90b3R5cGUuX2NoZWNrU3VzcGVuc2lvbj1mdW5jdGlvbihhKXtpZih0aGlzLnUuY2FuU3VzcGVuZCl7dmFyIGM9dGhpcy5uZXdCbG9jayhcImZ1bmN0aW9uIHJldHVybiBvciByZXN1bWUgc3VzcGVuc2lvblwiKTt0aGlzLl9qdW1wKGMpO3RoaXMuc2V0QmxvY2soYyk7YT1hfHx7bGluZW5vOlwiJGN1cnJMaW5lTm9cIixjb2xfb2Zmc2V0OlwiJGN1cnJDb2xOb1wifTtoKFwiaWYgKCRyZXQgJiYgJHJldC4kaXNTdXNwZW5zaW9uKSB7IHJldHVybiAkc2F2ZVN1c3BlbnNpb24oJHJldCwnXCIrXG50aGlzLmZpbGVuYW1lK1wiJyxcIithLmxpbmVubytcIixcIithLmNvbF9vZmZzZXQrXCIpOyB9XCIpO3RoaXMudS5kb2VzU3VzcGVuZD0hMDt0aGlzLnUudGVtcHNUb1NhdmU9dGhpcy51LnRlbXBzVG9TYXZlLmNvbmNhdCh0aGlzLnUubG9jYWx0ZW1wcyl9ZWxzZSBoKFwiaWYgKCRyZXQgJiYgJHJldC4kaXNTdXNwZW5zaW9uKSB7ICRyZXQgPSBTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coJHJldCk7IH1cIil9O2IucHJvdG90eXBlLmN1bnBhY2tzdGFyc3RvYXJyYXk9ZnVuY3Rpb24oYSxjKXtpZighYXx8MD09YS5sZW5ndGgpcmV0dXJuXCJbXVwiO2xldCBuPSExO2ZvcihsZXQgbSBvZiBhKXtpZihjJiZuKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiRXh0ZW5kZWQgYXJndW1lbnQgdW5wYWNraW5nIGlzIG5vdCBwZXJtaXR0ZWQgaW4gUHl0aG9uIDJcIik7bS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQmJihuPSEwKX1pZihuKXtjPXRoaXMuX2dyKFwidW5wYWNrXCIsXG5cIltdXCIpO2ZvcihsZXQgbSBvZiBhKW0uY29uc3RydWN0b3IhPT1Tay5hc3Rub2Rlcy5TdGFycmVkP2goYyxcIi5wdXNoKFwiLHRoaXMudmV4cHIobSksXCIpO1wiKTooaChcIiRyZXQgPSBTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoXCIsdGhpcy52ZXhwcihtLnZhbHVlKSxcIiksIGZ1bmN0aW9uKGUpIHsgXCIsYyxcIi5wdXNoKGUpOyB9KTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCkpO3JldHVybiBjfXJldHVyblwiW1wiK2EubWFwKG09PnRoaXMudmV4cHIobSkpLmpvaW4oXCIsXCIpK1wiXVwifTtiLnByb3RvdHlwZS5jdW5wYWNra3dzdG9hcnJheT1mdW5jdGlvbihhLGMpe3ZhciBuPVwidW5kZWZpbmVkXCI7aWYoYSYmMDxhLmxlbmd0aCl7bGV0IG09ITE7bj1bXTtmb3IobGV0IGsgb2YgYSl7aWYobSYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMyl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBZHZhbmNlZCB1bnBhY2tpbmcgb2YgZnVuY3Rpb24gYXJndW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIik7XG5rLmFyZz8obi5wdXNoKFwiJ1wiK2suYXJnLnYrXCInXCIpLG4ucHVzaCh0aGlzLnZleHByKGsudmFsdWUpKSk6bT0hMH1uPVwiW1wiK24uam9pbihcIixcIikrXCJdXCI7aWYobSl7bj10aGlzLl9ncihcImtleXdvcmRBcmdzXCIsbik7Zm9yKGxldCBrIG9mIGEpay5hcmd8fChoKFwiJHJldCA9IFNrLmFic3RyLm1hcHBpbmdVbnBhY2tJbnRvS2V5d29yZEFycmF5KFwiLG4sXCIsXCIsdGhpcy52ZXhwcihrLnZhbHVlKSxcIixcIixjLFwiKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCkpfX1yZXR1cm4gbn07Yi5wcm90b3R5cGUuY3R1cGxlbGlzdG9yc2V0PWZ1bmN0aW9uKGEsYyxuKXt2YXIgbTtTay5hc3NlcnRzLmFzc2VydChcInR1cGxlXCI9PT1ufHxcImxpc3RcIj09PW58fFwic2V0XCI9PT1uKTt2YXIgaz0hMTtmb3IobT0wO208YS5lbHRzLmxlbmd0aDttKyspaWYoYS5lbHRzW21dLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuU3RhcnJlZCl7az0hMDt2YXIgdT1tO2JyZWFrfWlmKGEuY3R4PT09U2suYXN0bm9kZXMuU3RvcmUpe2lmKGspe2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhc3NpZ25tZW50IHVucGFja2luZyB3aXRoIHN0YXJzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIixcbnRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO2ZvcihtPXUrMTttPGEuZWx0cy5sZW5ndGg7bSsrKWlmKGEuZWx0c1ttXS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJtdWx0aXBsZSBzdGFycmVkIGV4cHJlc3Npb25zIGluIGFzc2lnbm1lbnRcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTt9bj1rP3U6YS5lbHRzLmxlbmd0aDtoKFwiJHJldCA9IFNrLmFic3RyLnNlcXVlbmNlVW5wYWNrKFwiK2MrXCIsXCIrbitcIixcIisoaz9hLmVsdHMubGVuZ3RoLTE6bikrXCIsIFwiK2srXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oKTtjPXRoaXMuX2dyKFwiaXRlbXNcIixcIiRyZXRcIik7Zm9yKG09MDttPGEuZWx0cy5sZW5ndGg7KyttKW09PT11P3RoaXMudmV4cHIoYS5lbHRzW21dLnZhbHVlLGMrXCJbXCIrbStcIl1cIik6dGhpcy52ZXhwcihhLmVsdHNbbV0sYytcIltcIittK1wiXVwiKX1lbHNlIGlmKGEuY3R4PT09U2suYXN0bm9kZXMuTG9hZHx8XCJzZXRcIj09PVxubil7aWYoayl7aWYoIVNrLl9fZnV0dXJlX18ucHl0aG9uMyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIkxpc3QgcGFja2luZyB3aXRoIHN0YXJzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIik7cmV0dXJuIHRoaXMuX2dyKFwibG9hZFwiK24sXCJuZXcgU2suYnVpbHRpbnNbJ1wiLG4sXCInXShcIix0aGlzLmN1bnBhY2tzdGFyc3RvYXJyYXkoYS5lbHRzKSxcIilcIil9aWYoXCJ0dXBsZVwiPT09bil7az0hMDtjPVtdO2ZvcihtPTA7bTxhLmVsdHMubGVuZ3RoOysrbSl1PXRoaXMudmV4cHIoYS5lbHRzW21dKSxrJiYtMT09dS5pbmRleE9mKFwiJGNvbnN0XCIpJiYoaz0hMSksYy5wdXNoKHUpO2lmKGspcmV0dXJuIHRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4udHVwbGUoW1wiK2MrXCJdKVwiKTtmb3IobT0wO208Yy5sZW5ndGg7KyttKWNbbV09dGhpcy5fZ3IoXCJlbGVtXCIsY1ttXSk7cmV0dXJuIHRoaXMuX2dyKFwibG9hZFwiK24sXCJuZXcgU2suYnVpbHRpbnNbJ1wiLG4sXCInXShbXCIsXG5jLFwiXSlcIil9Yz1bXTtmb3IobT0wO208YS5lbHRzLmxlbmd0aDsrK20pYy5wdXNoKHRoaXMuX2dyKFwiZWxlbVwiLHRoaXMudmV4cHIoYS5lbHRzW21dKSkpO3JldHVybiB0aGlzLl9ncihcImxvYWRcIituLFwibmV3IFNrLmJ1aWx0aW5zWydcIixuLFwiJ10oW1wiLGMsXCJdKVwiKX19O2IucHJvdG90eXBlLmNzdWJkaWN0PWZ1bmN0aW9uKGEsYyxuKXtjb25zdCBtPVtdO2Zvcig7YzxuO2MrKyltLnB1c2godGhpcy52ZXhwcihhLmtleXNbY10pKSxtLnB1c2godGhpcy52ZXhwcihhLnZhbHVlc1tjXSkpO3JldHVybiB0aGlzLl9ncihcImxvYWRkaWN0XCIsXCJuZXcgU2suYnVpbHRpbnNbJ2RpY3QnXShbXCIsbSxcIl0pXCIpfTtiLnByb3RvdHlwZS5jZGljdD1mdW5jdGlvbihhKXtsZXQgYz0wO3ZhciBuO2NvbnN0IG09YS52YWx1ZXM/YS52YWx1ZXMubGVuZ3RoOjA7bGV0IGs9MCx1O2ZvcihsZXQgbD0wO2w8bTtsKyspKG49bnVsbD09PWEua2V5c1tsXSk/KGsmJihuPXRoaXMuY3N1YmRpY3QoYSxsLWssbCksYz9cbmgodSxcIi5kaWN0JG1lcmdlKFwiLG4sXCIpO1wiKToodT1uLGM9MSksaz0wKSwwPT09YyYmKHU9dGhpcy5fZ3IoXCJsb2FkZGljdFwiLFwibmV3IFNrLmJ1aWx0aW5zLmRpY3QoW10pXCIpLGM9MSksbj10aGlzLnZleHByKGEudmFsdWVzW2xdKSxoKFwiJHJldCA9IFwiLHUsXCIuZGljdCRtZXJnZShcIixuLFwiKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpKTprKys7ayYmKG49dGhpcy5jc3ViZGljdChhLG0tayxtKSxjP2godSxcIi5kaWN0JG1lcmdlKFwiLG4sXCIpO1wiKToodT1uLGM9MSkpOzA9PT1jJiYodT10aGlzLl9ncihcImxvYWRkaWN0XCIsXCJuZXcgU2suYnVpbHRpbnMuZGljdChbXSlcIikpO3JldHVybiB1fTtiLnByb3RvdHlwZS5jbGlzdGNvbXA9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkxpc3RDb21wKTt2YXIgYz10aGlzLl9ncihcIl9jb21wclwiLFwibmV3IFNrLmJ1aWx0aW5zWydsaXN0J10oW10pXCIpO3JldHVybiB0aGlzLmNjb21wZ2VuKFwibGlzdFwiLFxuYyxhLmdlbmVyYXRvcnMsMCxhLmVsdCxudWxsLGEpfTtiLnByb3RvdHlwZS5jZGljdGNvbXA9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkRpY3RDb21wKTt2YXIgYz10aGlzLl9ncihcIl9kY29tcHJcIixcIm5ldyBTay5idWlsdGlucy5kaWN0KFtdKVwiKTtyZXR1cm4gdGhpcy5jY29tcGdlbihcImRpY3RcIixjLGEuZ2VuZXJhdG9ycywwLGEudmFsdWUsYS5rZXksYSl9O2IucHJvdG90eXBlLmNzZXRjb21wPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5TZXRDb21wKTt2YXIgYz10aGlzLl9ncihcIl9zZXRjb21wclwiLFwibmV3IFNrLmJ1aWx0aW5zLnNldChbXSlcIik7cmV0dXJuIHRoaXMuY2NvbXBnZW4oXCJzZXRcIixjLGEuZ2VuZXJhdG9ycywwLGEuZWx0LG51bGwsYSl9O2IucHJvdG90eXBlLmNjb21wZ2VuPWZ1bmN0aW9uKGEsYyxuLG0sayx1LGwpe3ZhciBxPXRoaXMubmV3QmxvY2soYStcIiBjb21wIHN0YXJ0XCIpLFxuej10aGlzLm5ld0Jsb2NrKGErXCIgY29tcCBza2lwXCIpLHI9dGhpcy5uZXdCbG9jayhhK1wiIGNvbXAgYW5jaG9yXCIpLHQ9blttXSx4PXRoaXMudmV4cHIodC5pdGVyKTt4PXRoaXMuX2dyKFwiaXRlclwiLFwiU2suYWJzdHIuaXRlcihcIix4LFwiKVwiKTt2YXIgdjt0aGlzLl9qdW1wKHEpO3RoaXMuc2V0QmxvY2socSk7aChcIiRyZXQgPSBTay5hYnN0ci5pdGVybmV4dChcIix4LFwiLCB0cnVlKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGwpO3g9dGhpcy5fZ3IoXCJuZXh0XCIsXCIkcmV0XCIpO3RoaXMuX2p1bXB1bmRlZih4LHIpO3RoaXMudmV4cHIodC50YXJnZXQseCk7dmFyIEI9dC5pZnM/dC5pZnMubGVuZ3RoOjA7Zm9yKHY9MDt2PEI7Kyt2KXg9dGhpcy52ZXhwcih0Lmlmc1t2XSksdGhpcy5fanVtcGZhbHNlKHgscSk7KyttPG4ubGVuZ3RoJiZ0aGlzLmNjb21wZ2VuKGEsYyxuLG0sayx1LGwpO20+PW4ubGVuZ3RoJiYobj10aGlzLnZleHByKGspLFwiZGljdFwiPT09YT8oYT10aGlzLnZleHByKHUpLGgoYyxcblwiLm1wJGFzc19zdWJzY3JpcHQoXCIsYSxcIixcIixuLFwiKTtcIikpOlwibGlzdFwiPT09YT9oKGMsXCIudi5wdXNoKFwiLG4sXCIpO1wiKTpcInNldFwiPT09YSYmaChjLFwiLnYubXAkYXNzX3N1YnNjcmlwdChcIixuLFwiLCB0cnVlKTtcIiksdGhpcy5fanVtcCh6KSx0aGlzLnNldEJsb2NrKHopKTt0aGlzLl9qdW1wKHEpO3RoaXMuc2V0QmxvY2socik7cmV0dXJuIGN9O2IucHJvdG90eXBlLmN5aWVsZD1mdW5jdGlvbihhKXtpZih0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jayl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIid5aWVsZCcgb3V0c2lkZSBmdW5jdGlvblwiLHRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO3ZhciBjPVwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7YS52YWx1ZSYmKGM9dGhpcy52ZXhwcihhLnZhbHVlKSk7YT10aGlzLm5ld0Jsb2NrKFwiYWZ0ZXIgeWllbGRcIik7aChcInJldHVybiBbLypyZXN1bWUqL1wiLGEsXCIsLypyZXQqL1wiLGMsXCJdO1wiKTtcbnRoaXMuc2V0QmxvY2soYSk7cmV0dXJuXCIkZ2VuLmdpJHNlbnR2YWx1ZVwifTtiLnByb3RvdHlwZS5jeWllbGRmcm9tPWZ1bmN0aW9uKGEpe2lmKHRoaXMudS5zdGUuYmxvY2tUeXBlIT09U2suU1lNVEFCX0NPTlNUUy5GdW5jdGlvbkJsb2NrKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ3lpZWxkJyBvdXRzaWRlIGZ1bmN0aW9uXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7dmFyIGM9dGhpcy52ZXhwcihhLnZhbHVlKTtjPXRoaXMuX2dyKFwiaXRlclwiLFwiU2suYWJzdHIuaXRlcihcIixjLFwiKVwiKTtoKFwiJGdlbi5cIitjK1wiPVwiLGMsXCI7XCIpO3ZhciBuPXRoaXMubmV3QmxvY2soXCJhZnRlciBpdGVyXCIpLG09dGhpcy5uZXdCbG9jayhcImFmdGVyIHlpZWxkIGZyb21cIik7dGhpcy5fanVtcChuKTt0aGlzLnNldEJsb2NrKG4pO3ZhciBrPXRoaXMuZ2Vuc3ltKFwicmV0dmFsXCIpO2goYyxcIj0kZ2VuLlwiLGMsXCI7XCIpO2goXCJ2YXIgXCIsayxcIjtcIik7aChcImlmICgkZ2VuLmdpJHNlbnR2YWx1ZSA9PT0gU2suYnVpbHRpbi5ub25lLm5vbmUkIHx8IFwiK1xuYytcIi5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5nZW5lcmF0b3IpIHtcIik7aChcIiRyZXQ9XCIsYyxcIi50cCRpdGVybmV4dCh0cnVlLCAkZ2VuLmdpJHNlbnR2YWx1ZSk7XCIpO2goXCJ9IGVsc2Uge1wiKTt2YXIgdT10aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLnN0cignc2VuZCcpO1wiKTtoKFwiJHJldD1Tay5taXNjZXZhbC50cnlDYXRjaChcIik7aChcImZ1bmN0aW9uKCl7XCIpO2goXCJyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KFNrLmFic3RyLmdhdHRyKFwiLGMsXCIsXCIsdSxcIiksIFskZ2VuLmdpJHNlbnR2YWx1ZV0pO30sXCIpO2goXCJmdW5jdGlvbiAoZSkgeyBcIik7aChcImlmIChlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uKSB7IFwiKTtoKGMsXCIuZ2kkcmV0ID0gZS4kdmFsdWU7XCIpO2goXCJyZXR1cm4gdW5kZWZpbmVkO1wiKTtoKFwifSBlbHNlIHsgdGhyb3cgZTsgfVwiKTtoKFwifVwiKTtoKFwiKTtcIik7aChcIn1cIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO1xuaChrLFwiPSRyZXQ7XCIpO2goXCJpZihcIixrLFwiPT09dW5kZWZpbmVkKSB7XCIpO2goXCIkZ2VuLmdpJHNlbnR2YWx1ZT0kZ2VuLlwiK2MrXCIuZ2kkcmV0O1wiKTtoKFwiJGJsaz1cIixtLFwiO2NvbnRpbnVlO1wiKTtoKFwifVwiKTtoKFwicmV0dXJuIFsvKnJlc3VtZSovXCIsbixcIiwvKnJldCovXCIsayxcIl07XCIpO3RoaXMuc2V0QmxvY2sobSk7cmV0dXJuXCIkZ2VuLmdpJHNlbnR2YWx1ZVwifTtiLnByb3RvdHlwZS5jY29tcGFyZT1mdW5jdGlvbihhKXt2YXIgYztTay5hc3NlcnRzLmFzc2VydChhLm9wcy5sZW5ndGg9PT1hLmNvbXBhcmF0b3JzLmxlbmd0aCk7dmFyIG49dGhpcy52ZXhwcihhLmxlZnQpO3ZhciBtPWEub3BzLmxlbmd0aDt2YXIgaz10aGlzLm5ld0Jsb2NrKFwiZG9uZVwiKTt2YXIgdT10aGlzLl9ncihcImNvbXBhcmVyZXNcIixcIm51bGxcIik7Zm9yKGM9MDtjPG07KytjKXt2YXIgbD10aGlzLnZleHByKGEuY29tcGFyYXRvcnNbY10pO2NvbnN0IHE9YS5vcHNbY107cT09PVNrLmFzdG5vZGVzLklzP2goXCIkcmV0ID0gXCIsXG5uLFwiPT09XCIsbCxcIjtcIik6cT09PVNrLmFzdG5vZGVzLklzTm90P2goXCIkcmV0ID0gXCIsbixcIiE9PVwiLGwsXCI7XCIpOihoKFwiJHJldCA9IFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChcIixuLFwiLFwiLGwsXCIsJ1wiLHEucHJvdG90eXBlLl9hc3RuYW1lLFwiJywgdHJ1ZSk7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbihhKSk7aCh1LFwiPVNrLmJ1aWx0aW4uYm9vbCgkcmV0KTtcIik7dGhpcy5fanVtcGZhbHNlKFwiJHJldFwiLGspO249bH10aGlzLl9qdW1wKGspO3RoaXMuc2V0QmxvY2soayk7cmV0dXJuIHV9O2IucHJvdG90eXBlLmNjYWxsPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMudmV4cHIoYS5mdW5jKTtsZXQgbj10aGlzLmN1bnBhY2tzdGFyc3RvYXJyYXkoYS5hcmdzLCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpLG09dGhpcy5jdW5wYWNra3dzdG9hcnJheShhLmtleXdvcmRzLGMpO1NrLl9fZnV0dXJlX18uc3VwZXJfYXJncyYmYS5mdW5jLmlkJiZcInN1cGVyXCI9PT1hLmZ1bmMuaWQudiYmXCJbXVwiPT09XG5uJiYodGhpcy51LnRlbXBzVG9TYXZlLnB1c2goXCIkc3VwXCIpLGgoJ2lmICh0eXBlb2YgJHN1cCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0aHJvdyBuZXcgU2suYnVpbHRpbi5SdW50aW1lRXJyb3IoXCJzdXBlcigpOiBubyBhcmd1bWVudHNcIikgfTsnKSxuPVwiWyRnYmwuX19jbGFzc19fLCRzdXBdXCIpO2goXCIkcmV0ID0gKFwiLGMsXCIudHAkY2FsbCk/XCIsYyxcIi50cCRjYWxsKFwiLG4sXCIsXCIsbSxcIikgOiBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChcIixjLFwiLHVuZGVmaW5lZCx1bmRlZmluZWQsXCIsbSxcIixcIixuLFwiKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO3JldHVybiB0aGlzLl9ncihcImNhbGxcIixcIiRyZXRcIil9O2IucHJvdG90eXBlLmNzbGljZT1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuU2xpY2UpO2lmKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl7dmFyIGM9YS5sb3dlcj90aGlzLnZleHByKGEubG93ZXIpOlwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7XG52YXIgbj1hLnVwcGVyP3RoaXMudmV4cHIoYS51cHBlcik6XCJTay5idWlsdGluLm5vbmUubm9uZSRcIn1lbHNlIGM9YS5sb3dlcj90aGlzLnZleHByKGEubG93ZXIpOmEuc3RlcD9cIlNrLmJ1aWx0aW4ubm9uZS5ub25lJFwiOlwibmV3IFNrLmJ1aWx0aW4uaW50XygwKVwiLG49YS51cHBlcj90aGlzLnZleHByKGEudXBwZXIpOmEuc3RlcD9cIlNrLmJ1aWx0aW4ubm9uZS5ub25lJFwiOlwibmV3IFNrLmJ1aWx0aW4uaW50XygyMTQ3NDgzNjQ3KVwiO2E9YS5zdGVwP3RoaXMudmV4cHIoYS5zdGVwKTpcIlNrLmJ1aWx0aW4ubm9uZS5ub25lJFwiO3JldHVybiB0aGlzLl9ncihcInNsaWNlXCIsXCJuZXcgU2suYnVpbHRpbnNbJ3NsaWNlJ10oXCIsYyxcIixcIixuLFwiLFwiLGEsXCIpXCIpfTtiLnByb3RvdHlwZS5lc2xpY2U9ZnVuY3Rpb24oYSl7dmFyIGM7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIEFycmF5KTt2YXIgbj1bXTtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKW4ucHVzaCh0aGlzLnZzbGljZXN1YihhW2NdKSk7XG5yZXR1cm4gdGhpcy5fZ3IoXCJleHRzbGljZVwiLFwibmV3IFNrLmJ1aWx0aW5zWyd0dXBsZSddKFtcIixuLFwiXSlcIil9O2IucHJvdG90eXBlLnZzbGljZXN1Yj1mdW5jdGlvbihhKXtzd2l0Y2goYS5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5JbmRleDp2YXIgYz10aGlzLnZleHByKGEudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU2xpY2U6Yz10aGlzLmNzbGljZShhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkVsbGlwc2lzOlNrLmFzc2VydHMuZmFpbChcInRvZG8gY29tcGlsZS5qcyBFbGxpcHNpcztcIik7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5FeHRTbGljZTpjPXRoaXMuZXNsaWNlKGEuZGltcyk7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJpbnZhbGlkIHN1YnNjcmlwdCBraW5kXCIpfXJldHVybiBjfTtiLnByb3RvdHlwZS52c2xpY2U9ZnVuY3Rpb24oYSxjLG4sbSl7YT10aGlzLnZzbGljZXN1YihhKTtyZXR1cm4gdGhpcy5jaGFuZGxlc3Vic2NyKGMsbixhLFxubSl9O2IucHJvdG90eXBlLmNoYW5kbGVzdWJzY3I9ZnVuY3Rpb24oYSxjLG4sbSl7aWYoYT09PVNrLmFzdG5vZGVzLkxvYWR8fGE9PT1Tay5hc3Rub2Rlcy5BdWdMb2FkKXJldHVybiBoKFwiJHJldCA9IFNrLmFic3RyLm9iamVjdEdldEl0ZW0oXCIsYyxcIixcIixuLFwiLCB0cnVlKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCksdGhpcy5fZ3IoXCJsc3Vic2NyXCIsXCIkcmV0XCIpO2E9PT1Tay5hc3Rub2Rlcy5TdG9yZXx8YT09PVNrLmFzdG5vZGVzLkF1Z1N0b3JlPyhoKFwiJHJldCA9IFNrLmFic3RyLm9iamVjdFNldEl0ZW0oXCIsYyxcIixcIixuLFwiLFwiLG0sXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oKSk6YT09PVNrLmFzdG5vZGVzLkRlbD9oKFwiU2suYWJzdHIub2JqZWN0RGVsSXRlbShcIixjLFwiLFwiLG4sXCIpO1wiKTpTay5hc3NlcnRzLmZhaWwoXCJoYW5kbGVzdWJzY3IgZmFpbFwiKX07Yi5wcm90b3R5cGUuY2Jvb2xvcD1mdW5jdGlvbihhKXt2YXIgYyxuO1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZlxuU2suYXN0bm9kZXMuQm9vbE9wKTt2YXIgbT1hLm9wPT09U2suYXN0bm9kZXMuQW5kP3RoaXMuX2p1bXBmYWxzZTp0aGlzLl9qdW1wdHJ1ZTt2YXIgaz10aGlzLm5ld0Jsb2NrKFwiZW5kIG9mIGJvb2xvcFwiKTt2YXIgdT1hLnZhbHVlczt2YXIgbD11Lmxlbmd0aDtmb3IoYz0wO2M8bDsrK2MpYT10aGlzLnZleHByKHVbY10pLDA9PT1jJiYobj10aGlzLl9ncihcImJvb2xvcHN1Y2NcIixhKSksaChuLFwiPVwiLGEsXCI7XCIpLG0uY2FsbCh0aGlzLGEsayk7dGhpcy5fanVtcChrKTt0aGlzLnNldEJsb2NrKGspO3JldHVybiBufTtiLnByb3RvdHlwZS5jam9pbmVkc3RyPWZ1bmN0aW9uKGEpe2xldCBjO1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5Kb2luZWRTdHIpO2ZvcihsZXQgbiBvZiBhLnZhbHVlcylhPXRoaXMudmV4cHIobiksYz9oKGMsXCI9XCIsYyxcIi5zcSRjb25jYXQoXCIsYSxcIik7XCIpOmM9dGhpcy5fZ3IoXCJqb2luZWRzdHJcIixhKTtjfHwoYz1cIlNrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0clwiKTtcbnJldHVybiBjfTtiLnByb3RvdHlwZS5jZm9ybWF0dGVkdmFsdWU9ZnVuY3Rpb24oYSl7bGV0IGM9dGhpcy52ZXhwcihhLnZhbHVlKTtzd2l0Y2goYS5jb252ZXJzaW9uKXtjYXNlIFwic1wiOmM9dGhpcy5fZ3IoXCJ2YWx1ZVwiLFwibmV3IFNrLmJ1aWx0aW4uc3RyKFwiLGMsXCIpXCIpO2JyZWFrO2Nhc2UgXCJhXCI6Yz10aGlzLl9ncihcInZhbHVlXCIsXCJTay5idWlsdGluLmFzY2lpKFwiLGMsXCIpXCIpO2JyZWFrO2Nhc2UgXCJyXCI6Yz10aGlzLl9ncihcInZhbHVlXCIsXCJTay5idWlsdGluLnJlcHIoXCIsYyxcIilcIil9YT1hLmZvcm1hdF9zcGVjP3RoaXMudmV4cHIoYS5mb3JtYXRfc3BlYyk6XCJTay5idWlsdGluLnN0ci4kZW1wdHlzdHJcIjtyZXR1cm4gdGhpcy5fZ3IoXCJmb3JtYXR0ZWRcIixcIlNrLmFic3RyLm9iamVjdEZvcm1hdChcIitjK1wiLFwiK2ErXCIpXCIpfTtiLnByb3RvdHlwZS52ZXhwcj1mdW5jdGlvbihhLGMsbixtKXt2YXIgazthLmxpbmVubz50aGlzLnUubGluZW5vJiYodGhpcy51LmxpbmVubz1hLmxpbmVubyxcbnRoaXMudS5saW5lbm9TZXQ9ITEpO3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLkJvb2xPcDpyZXR1cm4gdGhpcy5jYm9vbG9wKGEpO2Nhc2UgU2suYXN0bm9kZXMuQmluT3A6cmV0dXJuIHRoaXMuX2dyKFwiYmlub3BcIixcIlNrLmFic3RyLm51bWJlckJpbk9wKFwiLHRoaXMudmV4cHIoYS5sZWZ0KSxcIixcIix0aGlzLnZleHByKGEucmlnaHQpLFwiLCdcIixhLm9wLnByb3RvdHlwZS5fYXN0bmFtZSxcIicpXCIpO2Nhc2UgU2suYXN0bm9kZXMuVW5hcnlPcDpyZXR1cm4gdGhpcy5fZ3IoXCJ1bmFyeW9wXCIsXCJTay5hYnN0ci5udW1iZXJVbmFyeU9wKFwiLHRoaXMudmV4cHIoYS5vcGVyYW5kKSxcIiwnXCIsYS5vcC5wcm90b3R5cGUuX2FzdG5hbWUsXCInKVwiKTtjYXNlIFNrLmFzdG5vZGVzLkxhbWJkYTpyZXR1cm4gdGhpcy5jbGFtYmRhKGEpO2Nhc2UgU2suYXN0bm9kZXMuSWZFeHA6cmV0dXJuIHRoaXMuY2lmZXhwKGEpO2Nhc2UgU2suYXN0bm9kZXMuRGljdDpyZXR1cm4gdGhpcy5jZGljdChhKTtcbmNhc2UgU2suYXN0bm9kZXMuTGlzdENvbXA6cmV0dXJuIHRoaXMuY2xpc3Rjb21wKGEpO2Nhc2UgU2suYXN0bm9kZXMuRGljdENvbXA6cmV0dXJuIHRoaXMuY2RpY3Rjb21wKGEpO2Nhc2UgU2suYXN0bm9kZXMuU2V0Q29tcDpyZXR1cm4gdGhpcy5jc2V0Y29tcChhKTtjYXNlIFNrLmFzdG5vZGVzLkdlbmVyYXRvckV4cDpyZXR1cm4gdGhpcy5jZ2VuZXhwKGEpO2Nhc2UgU2suYXN0bm9kZXMuWWllbGQ6cmV0dXJuIHRoaXMuY3lpZWxkKGEpO2Nhc2UgU2suYXN0bm9kZXMuWWllbGRGcm9tOnJldHVybiB0aGlzLmN5aWVsZGZyb20oYSk7Y2FzZSBTay5hc3Rub2Rlcy5Db21wYXJlOnJldHVybiB0aGlzLmNjb21wYXJlKGEpO2Nhc2UgU2suYXN0bm9kZXMuQ2FsbDpyZXR1cm4gYz10aGlzLmNjYWxsKGEpLHRoaXMuYW5ub3RhdGVTb3VyY2UoYSksYztjYXNlIFNrLmFzdG5vZGVzLk51bTppZihcIm51bWJlclwiPT09dHlwZW9mIGEubilyZXR1cm4gYS5uO2lmKGEubiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKXJldHVybiB0aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLmxuZygnXCIrXG5hLm4udi50b1N0cmluZygpK1wiJylcIik7aWYoYS5uIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKXJldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYS5uLnY/dGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5pbnRfKFwiK2Eubi52K1wiKVwiKTp0aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLmludF8oJ1wiK2Eubi52LnRvU3RyaW5nKCkrXCInKVwiKTtpZihhLm4gaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XylyZXR1cm4gYT0wPT09YS5uLnYmJi1JbmZpbml0eT09PTEvYS5uLnY/XCItMFwiOmEubi52LHRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uZmxvYXRfKFwiK2ErXCIpXCIpO2lmKGEubiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uY29tcGxleClyZXR1cm4gdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5jb21wbGV4KFwiKygwPT09YS5uLnJlYWwmJi1JbmZpbml0eT09PTEvYS5uLnJlYWw/XCItMFwiOmEubi5yZWFsKStcIiwgXCIrKDA9PT1hLm4uaW1hZyYmXG4tSW5maW5pdHk9PT0xL2Eubi5pbWFnP1wiLTBcIjphLm4uaW1hZykrXCIpXCIpO1NrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBOdW0gdHlwZVwiKTtjYXNlIFNrLmFzdG5vZGVzLkJ5dGVzOmlmKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl7Yz1bXTthPWEucy4kanNzdHIoKTtmb3Iobj0wO248YS5sZW5ndGg7bisrKWMucHVzaChhLmNoYXJDb2RlQXQobikpO3JldHVybiB0aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLmJ5dGVzKFtcIixjLmpvaW4oXCIsIFwiKSxcIl0pXCIpfWNhc2UgU2suYXN0bm9kZXMuU3RyOmM9dGhpcy5tYWtlQ29uc3RhbnQ7YT1hLnMuJGpzc3RyKCk7bj0nXCInO2ZvcihrPTA7azxhLmxlbmd0aDtrKyspbT1hLmNoYXJDb2RlQXQoayksbj0xMD09bT9uK1wiXFxcXG5cIjo5Mj09bT9uK1wiXFxcXFxcXFxcIjozND09bXx8MzI+bXx8MTI3PD1tJiYyNTY+bT9uKyhcIlxcXFx4XCIrKFwiMFwiK20udG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpKToyNTY8PW0/bisoXCJcXFxcdVwiKyhcIjAwMFwiK20udG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpKTpcbm4rYS5jaGFyQXQoayk7YT1uKydcIic7cmV0dXJuIGMuY2FsbCh0aGlzLFwibmV3IFNrLmJ1aWx0aW4uc3RyKFwiLGEsXCIpXCIpO2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOmEuY3R4IT09U2suYXN0bm9kZXMuQXVnTG9hZCYmYS5jdHghPT1Tay5hc3Rub2Rlcy5BdWdTdG9yZSYmKGs9dGhpcy52ZXhwcihhLnZhbHVlKSk7bT1hLmF0dHIuJHIoKS52O209bS5zdWJzdHJpbmcoMSxtLmxlbmd0aC0xKTttPWYodGhpcy51LnByaXZhdGVfLG5ldyBTay5idWlsdGluLnN0cihtKSkudjttPXRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uc3RyKCdcIittK1wiJylcIik7c3dpdGNoKGEuY3R4KXtjYXNlIFNrLmFzdG5vZGVzLkF1Z0xvYWQ6cmV0dXJuIGgoXCIkcmV0ID0gXCIsbixcIi50cCRnZXRhdHRyKFwiLG0sXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oYSksaChcIlxcbmlmICgkcmV0ID09PSB1bmRlZmluZWQpIHtcIiksaChcIlxcbnRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiLFxubiwnLnNrJGF0dHJFcnJvcigpICsgXCIgaGFzIG5vIGF0dHJpYnV0ZSBcXCdcIiArICcsbSwnLiRqc3N0cigpICsgXCJcXCdcIik7JyksaChcIlxcbn07XCIpLHRoaXMuX2dyKFwibGF0dHJcIixcIiRyZXRcIik7Y2FzZSBTay5hc3Rub2Rlcy5Mb2FkOnJldHVybiBoKFwiJHJldCA9IFwiLGssXCIudHAkZ2V0YXR0cihcIixtLFwiLCB0cnVlKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpLGgoXCJcXG5pZiAoJHJldCA9PT0gdW5kZWZpbmVkKSB7XCIpLGgoXCJcXG50aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcIixrLCcuc2skYXR0ckVycm9yKCkgKyBcIiBoYXMgbm8gYXR0cmlidXRlIFxcJ1wiICsgJyxtLCcuJGpzc3RyKCkgKyBcIlxcJ1wiKTsnKSxoKFwiXFxufTtcIiksdGhpcy5fZ3IoXCJsYXR0clwiLFwiJHJldFwiKTtjYXNlIFNrLmFzdG5vZGVzLkF1Z1N0b3JlOmgoXCIkcmV0ID0gdW5kZWZpbmVkO1wiKTtoKFwiaWYoXCIsYyxcIiE9PXVuZGVmaW5lZCl7XCIpO2goXCIkcmV0ID0gXCIsbixcIi50cCRzZXRhdHRyKFwiLG0sXCIsXCIsYyxcblwiLCB0cnVlKTtcIik7aChcIn1cIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3RvcmU6aChcIiRyZXQgPSBcIixrLFwiLnRwJHNldGF0dHIoXCIsbSxcIixcIixjLFwiLCB0cnVlKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGVsOmgoXCIkcmV0ID0gXCIsayxcIi50cCRzZXRhdHRyKFwiLG0sXCIsIHVuZGVmaW5lZCwgdHJ1ZSk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgYXR0cmlidXRlIGV4cHJlc3Npb25cIil9YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5TdWJzY3JpcHQ6c3dpdGNoKGEuY3R4KXtjYXNlIFNrLmFzdG5vZGVzLkF1Z0xvYWQ6cmV0dXJuIGgoXCIkcmV0ID0gU2suYWJzdHIub2JqZWN0R2V0SXRlbShcIixuLFwiLFwiLG0sXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oYSksdGhpcy5fZ3IoXCJnaXRlbVwiLFwiJHJldFwiKTtjYXNlIFNrLmFzdG5vZGVzLkxvYWQ6Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTpjYXNlIFNrLmFzdG5vZGVzLkRlbDpyZXR1cm4gdGhpcy52c2xpY2UoYS5zbGljZSxcbmEuY3R4LHRoaXMudmV4cHIoYS52YWx1ZSksYyk7Y2FzZSBTay5hc3Rub2Rlcy5BdWdTdG9yZTpoKFwiJHJldD11bmRlZmluZWQ7XCIpO2goXCJpZihcIixjLFwiIT09dW5kZWZpbmVkKXtcIik7aChcIiRyZXQ9U2suYWJzdHIub2JqZWN0U2V0SXRlbShcIixuLFwiLFwiLG0sXCIsXCIsYyxcIiwgdHJ1ZSlcIik7aChcIn1cIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwiaW52YWxpZCBzdWJzY3JpcHQgZXhwcmVzc2lvblwiKX1icmVhaztjYXNlIFNrLmFzdG5vZGVzLk5hbWU6cmV0dXJuIHRoaXMubmFtZW9wKGEuaWQsYS5jdHgsYyk7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lQ29uc3RhbnQ6aWYoYS5jdHg9PT1Tay5hc3Rub2Rlcy5TdG9yZXx8YS5jdHg9PT1Tay5hc3Rub2Rlcy5BdWdTdG9yZXx8YS5jdHg9PT1Tay5hc3Rub2Rlcy5EZWwpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJjYW4gbm90IGFzc2lnbiB0byBhIGNvbnN0YW50IG5hbWVcIik7XG5zd2l0Y2goYS52YWx1ZSl7Y2FzZSBTay5idWlsdGluLm5vbmUubm9uZSQ6cmV0dXJuXCJTay5idWlsdGluLm5vbmUubm9uZSRcIjtjYXNlIFNrLmJ1aWx0aW4uYm9vbC50cnVlJDpyZXR1cm5cIlNrLmJ1aWx0aW4uYm9vbC50cnVlJFwiO2Nhc2UgU2suYnVpbHRpbi5ib29sLmZhbHNlJDpyZXR1cm5cIlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSRcIjtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgbmFtZWQgY29uc3RhbnRcIil9YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5MaXN0OnJldHVybiB0aGlzLmN0dXBsZWxpc3RvcnNldChhLGMsXCJsaXN0XCIpO2Nhc2UgU2suYXN0bm9kZXMuVHVwbGU6cmV0dXJuIHRoaXMuY3R1cGxlbGlzdG9yc2V0KGEsYyxcInR1cGxlXCIpO2Nhc2UgU2suYXN0bm9kZXMuU2V0OnJldHVybiB0aGlzLmN0dXBsZWxpc3RvcnNldChhLGMsXCJzZXRcIik7Y2FzZSBTay5hc3Rub2Rlcy5TdGFycmVkOnN3aXRjaChhLmN0eCl7Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInN0YXJyZWQgYXNzaWdubWVudCB0YXJnZXQgbXVzdCBiZSBpbiBhIGxpc3Qgb3IgdHVwbGVcIixcbnRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO2RlZmF1bHQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJjYW4ndCB1c2Ugc3RhcnJlZCBleHByZXNzaW9uIGhlcmVcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTt9Y2FzZSBTay5hc3Rub2Rlcy5Kb2luZWRTdHI6cmV0dXJuIHRoaXMuY2pvaW5lZHN0cihhKTtjYXNlIFNrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlOnJldHVybiB0aGlzLmNmb3JtYXR0ZWR2YWx1ZShhKTtjYXNlIFNrLmFzdG5vZGVzLkVsbGlwc2lzOnJldHVybiB0aGlzLm1ha2VDb25zdGFudChcIlNrLmJ1aWx0aW4uRWxsaXBzaXNcIik7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgY2FzZSBcIithLmNvbnN0cnVjdG9yLm5hbWUrXCIgdmV4cHJcIil9fTtiLnByb3RvdHlwZS52c2VxZXhwcj1mdW5jdGlvbihhLGMpe3ZhciBuO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMD09PWN8fGEubGVuZ3RoPT09Yy5sZW5ndGgpO3ZhciBtPVtdO2ZvcihuPTA7bjxhLmxlbmd0aDsrK24pbS5wdXNoKHRoaXMudmV4cHIoYVtuXSxcbnZvaWQgMD09PWM/dm9pZCAwOmNbbl0pKTtyZXR1cm4gbX07Yi5wcm90b3R5cGUuY2FubmFzc2lnbj1mdW5jdGlvbihhKXt2YXIgYz1hLnRhcmdldDtsZXQgbj1hLnZhbHVlO24mJihuPXRoaXMudmV4cHIoYS52YWx1ZSksdGhpcy52ZXhwcihjLG4pKTtzd2l0Y2goYy5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOiFhLnNpbXBsZXx8dGhpcy51LnN0ZS5ibG9ja1R5cGUhPT1Tay5TWU1UQUJfQ09OU1RTLkNsYXNzQmxvY2smJnRoaXMudS5zdGUuYmxvY2tUeXBlIT1Tay5TWU1UQUJfQ09OU1RTLk1vZHVsZUJsb2NrfHwodGhpcy51Lmhhc0Fubm90YXRpb25zPSEwLGE9dGhpcy52ZXhwcihhLmFubm90YXRpb24pLGM9Zih0aGlzLnUucHJpdmF0ZV8sYy5pZCkudixjPXRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uc3RyKCdcIitjK1wiJylcIiksdGhpcy5jaGFuZGxlc3Vic2NyKFNrLmFzdG5vZGVzLlN0b3JlLFwiJGxvYy5fX2Fubm90YXRpb25zX19cIixjLGEpKX19O1xuYi5wcm90b3R5cGUuY2F1Z2Fzc2lnbj1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuQXVnQXNzaWduKTt2YXIgYz1hLnRhcmdldDtzd2l0Y2goYy5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5BdHRyaWJ1dGU6dmFyIG49dGhpcy52ZXhwcihjLnZhbHVlKTtjPW5ldyBTay5hc3Rub2Rlcy5BdHRyaWJ1dGUoYy52YWx1ZSxjLmF0dHIsU2suYXN0bm9kZXMuQXVnTG9hZCxjLmxpbmVubyxjLmNvbF9vZmZzZXQpO3ZhciBtPXRoaXMudmV4cHIoYyx2b2lkIDAsbik7dmFyIGs9dGhpcy52ZXhwcihhLnZhbHVlKTthPXRoaXMuX2dyKFwiaW5wbGJpbm9wYXR0clwiLFwiU2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKFwiLG0sXCIsXCIsayxcIiwnXCIsYS5vcC5wcm90b3R5cGUuX2FzdG5hbWUsXCInKVwiKTtjLmN0eD1Tay5hc3Rub2Rlcy5BdWdTdG9yZTtyZXR1cm4gdGhpcy52ZXhwcihjLGEsbik7Y2FzZSBTay5hc3Rub2Rlcy5TdWJzY3JpcHQ6bj1cbnRoaXMudmV4cHIoYy52YWx1ZSk7dmFyIHU9dGhpcy52c2xpY2VzdWIoYy5zbGljZSk7Yz1uZXcgU2suYXN0bm9kZXMuU3Vic2NyaXB0KGMudmFsdWUsdSxTay5hc3Rub2Rlcy5BdWdMb2FkLGMubGluZW5vLGMuY29sX29mZnNldCk7bT10aGlzLnZleHByKGMsdm9pZCAwLG4sdSk7az10aGlzLnZleHByKGEudmFsdWUpO2E9dGhpcy5fZ3IoXCJpbnBsYmlub3BzdWJzY3JcIixcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChcIixtLFwiLFwiLGssXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFwiJylcIik7Yy5jdHg9U2suYXN0bm9kZXMuQXVnU3RvcmU7cmV0dXJuIHRoaXMudmV4cHIoYyxhLG4sdSk7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOnJldHVybiBuPXRoaXMubmFtZW9wKGMuaWQsU2suYXN0bm9kZXMuTG9hZCksaz10aGlzLnZleHByKGEudmFsdWUpLGE9dGhpcy5fZ3IoXCJpbnBsYmlub3BcIixcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChcIixuLFwiLFwiLGssXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFxuXCInKVwiKSx0aGlzLm5hbWVvcChjLmlkLFNrLmFzdG5vZGVzLlN0b3JlLGEpO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGNhc2UgaW4gYXVnYXNzaWduXCIpfX07Yi5wcm90b3R5cGUuZXhwckNvbnN0YW50PWZ1bmN0aW9uKGEpe3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLk51bTpyZXR1cm4gU2subWlzY2V2YWwuaXNUcnVlKGEubik/MTowO2Nhc2UgU2suYXN0bm9kZXMuU3RyOnJldHVybiBTay5taXNjZXZhbC5pc1RydWUoYS5zKT8xOjA7ZGVmYXVsdDpyZXR1cm4tMX19O2IucHJvdG90eXBlLm5ld0Jsb2NrPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMudS5ibG9ja251bSsrO3RoaXMudS5ibG9ja3NbY109W107dGhpcy51LmJsb2Nrc1tjXS5fbmFtZT1hfHxcIjx1bm5hbWVkPlwiO3RoaXMudS5ibG9ja3NbY10uX25leHQ9bnVsbDtyZXR1cm4gY307Yi5wcm90b3R5cGUuc2V0QmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmXG5hPHRoaXMudS5ibG9ja251bSk7dGhpcy51LmN1cmJsb2NrPWF9O2IucHJvdG90eXBlLnB1c2hCcmVha0Jsb2NrPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KDA8PWEmJmE8dGhpcy51LmJsb2NrbnVtKTt0aGlzLnUuYnJlYWtCbG9ja3MucHVzaChhKX07Yi5wcm90b3R5cGUucG9wQnJlYWtCbG9jaz1mdW5jdGlvbigpe3RoaXMudS5icmVha0Jsb2Nrcy5wb3AoKX07Yi5wcm90b3R5cGUucHVzaENvbnRpbnVlQmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO3RoaXMudS5jb250aW51ZUJsb2Nrcy5wdXNoKGEpfTtiLnByb3RvdHlwZS5wb3BDb250aW51ZUJsb2NrPWZ1bmN0aW9uKCl7dGhpcy51LmNvbnRpbnVlQmxvY2tzLnBvcCgpfTtiLnByb3RvdHlwZS5wdXNoRXhjZXB0QmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO3RoaXMudS5leGNlcHRCbG9ja3MucHVzaChhKX07XG5iLnByb3RvdHlwZS5wb3BFeGNlcHRCbG9jaz1mdW5jdGlvbigpe3RoaXMudS5leGNlcHRCbG9ja3MucG9wKCl9O2IucHJvdG90eXBlLnB1c2hGaW5hbGx5QmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGg9PT10aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoKTt0aGlzLnUuZmluYWxseUJsb2Nrcy5wdXNoKHtibGs6YSxicmVha0RlcHRoOnRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGh9KX07Yi5wcm90b3R5cGUucG9wRmluYWxseUJsb2NrPWZ1bmN0aW9uKCl7dGhpcy51LmZpbmFsbHlCbG9ja3MucG9wKCl9O2IucHJvdG90eXBlLnBlZWtGaW5hbGx5QmxvY2s9ZnVuY3Rpb24oKXtyZXR1cm4gMDx0aGlzLnUuZmluYWxseUJsb2Nrcy5sZW5ndGg/dGhpcy51LmZpbmFsbHlCbG9ja3NbdGhpcy51LmZpbmFsbHlCbG9ja3MubGVuZ3RoLTFdOnZvaWQgMH07XG5iLnByb3RvdHlwZS5zZXR1cEV4Y2VwdD1mdW5jdGlvbihhKXtoKFwiJGV4Yy5wdXNoKFwiLGEsXCIpO1wiKX07Yi5wcm90b3R5cGUuZW5kRXhjZXB0PWZ1bmN0aW9uKCl7aChcIiRleGMucG9wKCk7XCIpfTtiLnByb3RvdHlwZS5vdXRwdXRMb2NhbHM9ZnVuY3Rpb24oYSl7dmFyIGMsbj17fTtmb3IoYz0wO2EuYXJnbmFtZXMmJmM8YS5hcmduYW1lcy5sZW5ndGg7KytjKW5bYS5hcmduYW1lc1tjXV09ITA7YS5sb2NhbG5hbWVzLnNvcnQoKTt2YXIgbT1bXTtmb3IoYz0wO2M8YS5sb2NhbG5hbWVzLmxlbmd0aDsrK2Mpe3ZhciBrPWEubG9jYWxuYW1lc1tjXTt2b2lkIDA9PT1uW2tdJiYobS5wdXNoKGspLG5ba109ITApfXJldHVybiAwPG0ubGVuZ3RoP1widmFyIFwiK20uam9pbihcIixcIikrXCI7IC8qIGxvY2FscyAqL1wiOlwiXCJ9O2IucHJvdG90eXBlLm91dHB1dFN1c3BlbnNpb25IZWxwZXJzPWZ1bmN0aW9uKGEpe3ZhciBjLG49W10sbT1hLmxvY2FsbmFtZXMuY29uY2F0KGEudGVtcHNUb1NhdmUpLGs9e30sXG51PWEuc3RlLmJsb2NrVHlwZT09PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jayYmYS5zdGUuY2hpbGRIYXNGcmVlLGw9KDA8bS5sZW5ndGg/XCJ2YXIgXCIrbS5qb2luKFwiLFwiKStcIjtcIjpcIlwiKStcInZhciAkd2FrZUZyb21TdXNwZW5zaW9uID0gZnVuY3Rpb24oKSB7dmFyIHN1c3AgPSBcIithLnNjb3BlbmFtZStcIi4kd2FraW5nU3VzcGVuc2lvbjsgXCIrYS5zY29wZW5hbWUrXCIuJHdha2luZ1N1c3BlbnNpb24gPSB1bmRlZmluZWQ7JGJsaz1zdXNwLiRibGs7ICRsb2M9c3VzcC4kbG9jOyAkZ2JsPXN1c3AuJGdibDsgJGV4Yz1zdXNwLiRleGM7ICRlcnI9c3VzcC4kZXJyOyAkcG9zdGZpbmFsbHk9c3VzcC4kcG9zdGZpbmFsbHk7JGN1cnJMaW5lTm89c3VzcC4kbGluZW5vOyAkY3VyckNvbE5vPXN1c3AuJGNvbG5vOyBTay5sYXN0WWllbGQ9RGF0ZS5ub3coKTtcIisodT9cIiRjZWxsPXN1c3AuJGNlbGw7XCI6XCJcIik7Zm9yKGM9MDtjPG0ubGVuZ3RoO2MrKyl7dmFyIHE9bVtjXTt2b2lkIDA9PT1cbmtbcV0mJihsKz1xK1wiPXN1c3AuJHRtcHMuXCIrcStcIjtcIixrW3FdPSEwKX1sKz1cInRyeSB7ICRyZXQ9c3VzcC5jaGlsZC5yZXN1bWUoKTsgfSBjYXRjaChlcnIpIHsgaWYgKCEoZXJyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uKSkgeyBlcnIgPSBuZXcgU2suYnVpbHRpbi5FeHRlcm5hbEVycm9yKGVycik7IH0gZXJyLnRyYWNlYmFjay5wdXNoKHtsaW5lbm86ICRjdXJyTGluZU5vLCBjb2xubzogJGN1cnJDb2xObywgZmlsZW5hbWU6ICdcIit0aGlzLmZpbGVuYW1lK1wiJ30pOyBpZigkZXhjLmxlbmd0aD4wKSB7ICRlcnI9ZXJyOyAkYmxrPSRleGMucG9wKCk7IH0gZWxzZSB7IHRocm93IGVycjsgfSB9fTtcIjtsKz1cInZhciAkc2F2ZVN1c3BlbnNpb24gPSBmdW5jdGlvbigkY2hpbGQsICRmaWxlbmFtZSwgJGxpbmVubywgJGNvbG5vKSB7dmFyIHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpOyBzdXNwLmNoaWxkPSRjaGlsZDtzdXNwLnJlc3VtZT1mdW5jdGlvbigpe1wiK1xuYS5zY29wZW5hbWUrXCIuJHdha2luZ1N1c3BlbnNpb249c3VzcDsgcmV0dXJuIFwiK2Euc2NvcGVuYW1lK1wiKFwiKyhhLnN0ZS5nZW5lcmF0b3I/XCIkZ2VuXCI6XCJcIikrXCIpOyB9O3N1c3AuZGF0YT1zdXNwLmNoaWxkLmRhdGE7c3VzcC4kYmxrPSRibGs7c3VzcC4kbG9jPSRsb2M7c3VzcC4kZ2JsPSRnYmw7c3VzcC4kZXhjPSRleGM7c3VzcC4kZXJyPSRlcnI7c3VzcC4kcG9zdGZpbmFsbHk9JHBvc3RmaW5hbGx5O3N1c3AuJGZpbGVuYW1lPSRmaWxlbmFtZTtzdXNwLiRsaW5lbm89JGxpbmVubztzdXNwLiRjb2xubz0kY29sbm87c3VzcC5vcHRpb25hbD1zdXNwLmNoaWxkLm9wdGlvbmFsO1wiKyh1P1wic3VzcC4kY2VsbD0kY2VsbDtcIjpcIlwiKTtrPXt9O2ZvcihjPTA7YzxtLmxlbmd0aDtjKyspcT1tW2NdLHZvaWQgMD09PWtbcV0mJihuLnB1c2goJ1wiJytxKydcIjonK3EpLGtbcV09ITApO3JldHVybiBsKz1cInN1c3AuJHRtcHM9e1wiK24uam9pbihcIixcIikrXCJ9O3JldHVybiBzdXNwO307XCJ9O2IucHJvdG90eXBlLm91dHB1dEFsbFVuaXRzPVxuZnVuY3Rpb24oKXt2YXIgYSxjLG49XCJcIjtmb3IoYz0wO2M8dGhpcy5hbGxVbml0cy5sZW5ndGg7KytjKXt2YXIgbT10aGlzLmFsbFVuaXRzW2NdO24rPW0ucHJlZml4Q29kZTtuKz10aGlzLm91dHB1dExvY2FscyhtKTttLmRvZXNTdXNwZW5kJiYobis9dGhpcy5vdXRwdXRTdXNwZW5zaW9uSGVscGVycyhtKSk7bis9bS52YXJEZWNsc0NvZGU7bis9bS5zd2l0Y2hDb2RlO3ZhciBrPW0uYmxvY2tzO3ZhciB1PU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGE9MDthPGsubGVuZ3RoOysrYSl7dmFyIGw9YTtpZighKGwgaW4gdSkpZm9yKDs7KWlmKHVbbF09ITAsbis9XCJjYXNlIFwiK2wrXCI6IC8qIC0tLSBcIitrW2xdLl9uYW1lK1wiIC0tLSAqL1wiLG4rPWtbbF0uam9pbihcIlwiKSxudWxsIT09a1tsXS5fbmV4dClpZihrW2xdLl9uZXh0IGluIHUpe24rPVwiLyoganVtcCAqLyBjb250aW51ZTtcIjticmVha31lbHNlIG4rPVwiLyogYWxsb3dpbmcgY2FzZSBmYWxsdGhyb3VnaCAqL1wiLGw9a1tsXS5fbmV4dDtcbmVsc2V7bis9XCJ0aHJvdyBuZXcgU2suYnVpbHRpbi5TeXN0ZW1FcnJvcignaW50ZXJuYWwgZXJyb3I6IHVudGVybWluYXRlZCBibG9jaycpO1wiO2JyZWFrfX1uKz1tLnN1ZmZpeENvZGV9cmV0dXJuIG59O2IucHJvdG90eXBlLmNpZj1mdW5jdGlvbihhKXt2YXIgYztTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuSWYpO3ZhciBuPXRoaXMuZXhwckNvbnN0YW50KGEudGVzdCk7aWYoMD09PW4pYS5vcmVsc2UmJjA8YS5vcmVsc2UubGVuZ3RoJiZ0aGlzLnZzZXFzdG10KGEub3JlbHNlKTtlbHNlIGlmKDE9PT1uKXRoaXMudnNlcXN0bXQoYS5ib2R5KTtlbHNle3ZhciBtPXRoaXMubmV3QmxvY2soXCJlbmQgb2YgaWZcIik7YS5vcmVsc2UmJjA8YS5vcmVsc2UubGVuZ3RoJiYoYz10aGlzLm5ld0Jsb2NrKFwibmV4dCBicmFuY2ggb2YgaWZcIikpO249dGhpcy52ZXhwcihhLnRlc3QpO2Eub3JlbHNlJiYwPGEub3JlbHNlLmxlbmd0aD8odGhpcy5fanVtcGZhbHNlKG4sYyksXG50aGlzLnZzZXFzdG10KGEuYm9keSksdGhpcy5fanVtcChtKSx0aGlzLnNldEJsb2NrKGMpLHRoaXMudnNlcXN0bXQoYS5vcmVsc2UpKToodGhpcy5fanVtcGZhbHNlKG4sbSksdGhpcy52c2Vxc3RtdChhLmJvZHkpKTt0aGlzLl9qdW1wKG0pO3RoaXMuc2V0QmxvY2sobSl9fTtiLnByb3RvdHlwZS5jd2hpbGU9ZnVuY3Rpb24oYSl7aWYoMD09PXRoaXMuZXhwckNvbnN0YW50KGEudGVzdCkpYS5vcmVsc2UmJnRoaXMudnNlcXN0bXQoYS5vcmVsc2UpO2Vsc2V7dmFyIGM9dGhpcy5uZXdCbG9jayhcIndoaWxlIHRlc3RcIik7dGhpcy5fanVtcChjKTt0aGlzLnNldEJsb2NrKGMpO2lmKChTay5kZWJ1Z2dpbmd8fFNrLmtpbGxhYmxlV2hpbGUpJiZ0aGlzLnUuY2FuU3VzcGVuZCl7dmFyIG49dGhpcy5uZXdCbG9jayhcImRlYnVnIGJyZWFrcG9pbnQgZm9yIGxpbmUgXCIrYS5saW5lbm8pO2goXCJpZiAoU2suYnJlYWtwb2ludHMoJ1wiK3RoaXMuZmlsZW5hbWUrXCInLFwiK2EubGluZW5vK1wiLFwiK2EuY29sX29mZnNldCtcblwiKSkge1wiLFwidmFyICRzdXNwID0gJHNhdmVTdXNwZW5zaW9uKHtkYXRhOiB7dHlwZTogJ1NrLmRlbGF5J30sIHJlc3VtZTogZnVuY3Rpb24oKSB7fX0sICdcIit0aGlzLmZpbGVuYW1lK1wiJyxcIithLmxpbmVubytcIixcIithLmNvbF9vZmZzZXQrXCIpO1wiLFwiJHN1c3AuJGJsayA9IFwiK24rXCI7XCIsXCIkc3VzcC5vcHRpb25hbCA9IHRydWU7XCIsXCJyZXR1cm4gJHN1c3A7XCIsXCJ9XCIpO3RoaXMuX2p1bXAobik7dGhpcy5zZXRCbG9jayhuKTt0aGlzLnUuZG9lc1N1c3BlbmQ9ITB9dmFyIG09dGhpcy5uZXdCbG9jayhcImFmdGVyIHdoaWxlXCIpO3ZhciBrPTA8YS5vcmVsc2UubGVuZ3RoP3RoaXMubmV3QmxvY2soXCJ3aGlsZSBvcmVsc2VcIik6bnVsbDtuPXRoaXMubmV3QmxvY2soXCJ3aGlsZSBib2R5XCIpO3RoaXMuYW5ub3RhdGVTb3VyY2UoYSk7dGhpcy5fanVtcGZhbHNlKHRoaXMudmV4cHIoYS50ZXN0KSxrP2s6bSk7dGhpcy5fanVtcChuKTt0aGlzLnB1c2hCcmVha0Jsb2NrKG0pO3RoaXMucHVzaENvbnRpbnVlQmxvY2soYyk7XG50aGlzLnNldEJsb2NrKG4pO3RoaXMudnNlcXN0bXQoYS5ib2R5KTt0aGlzLl9qdW1wKGMpO3RoaXMucG9wQ29udGludWVCbG9jaygpO3RoaXMucG9wQnJlYWtCbG9jaygpOzA8YS5vcmVsc2UubGVuZ3RoJiYodGhpcy5zZXRCbG9jayhrKSx0aGlzLnZzZXFzdG10KGEub3JlbHNlKSx0aGlzLl9qdW1wKG0pKTt0aGlzLnNldEJsb2NrKG0pfX07Yi5wcm90b3R5cGUuY2Zvcj1mdW5jdGlvbihhKXt2YXIgYz10aGlzLm5ld0Jsb2NrKFwiZm9yIHN0YXJ0XCIpLG49dGhpcy5uZXdCbG9jayhcImZvciBjbGVhbnVwXCIpLG09dGhpcy5uZXdCbG9jayhcImZvciBlbmRcIik7dGhpcy5wdXNoQnJlYWtCbG9jayhtKTt0aGlzLnB1c2hDb250aW51ZUJsb2NrKGMpO3ZhciBrPXRoaXMudmV4cHIoYS5pdGVyKTtpZih0aGlzLnUuc3RlLmdlbmVyYXRvcil7dmFyIHU9XCIkbG9jLlwiK3RoaXMuZ2Vuc3ltKFwiaXRlclwiKTtoKHUsXCI9U2suYWJzdHIuaXRlcihcIixrLFwiKTtcIil9ZWxzZSB1PXRoaXMuX2dyKFwiaXRlclwiLFwiU2suYWJzdHIuaXRlcihcIixcbmssXCIpXCIpLHRoaXMudS50ZW1wc1RvU2F2ZS5wdXNoKHUpO3RoaXMuX2p1bXAoYyk7dGhpcy5zZXRCbG9jayhjKTtoKFwiJHJldCA9IFNrLmFic3RyLml0ZXJuZXh0KFwiLHUsdGhpcy51LmNhblN1c3BlbmQ/XCIsIHRydWVcIjpcIiwgZmFsc2VcIixcIik7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTt1PXRoaXMuX2dyKFwibmV4dFwiLFwiJHJldFwiKTt0aGlzLl9qdW1wdW5kZWYodSxuKTt0aGlzLnZleHByKGEudGFyZ2V0LHUpOyhTay5kZWJ1Z2dpbmd8fFNrLmtpbGxhYmxlRm9yKSYmdGhpcy51LmNhblN1c3BlbmQmJih1PXRoaXMubmV3QmxvY2soXCJkZWJ1ZyBicmVha3BvaW50IGZvciBsaW5lIFwiK2EubGluZW5vKSxoKFwiaWYgKFNrLmJyZWFrcG9pbnRzKCdcIit0aGlzLmZpbGVuYW1lK1wiJyxcIithLmxpbmVubytcIixcIithLmNvbF9vZmZzZXQrXCIpKSB7XCIsXCJ2YXIgJHN1c3AgPSAkc2F2ZVN1c3BlbnNpb24oe2RhdGE6IHt0eXBlOiAnU2suZGVsYXknfSwgcmVzdW1lOiBmdW5jdGlvbigpIHt9fSwgJ1wiK1xudGhpcy5maWxlbmFtZStcIicsXCIrYS5saW5lbm8rXCIsXCIrYS5jb2xfb2Zmc2V0K1wiKTtcIixcIiRzdXNwLiRibGsgPSBcIit1K1wiO1wiLFwiJHN1c3Aub3B0aW9uYWwgPSB0cnVlO1wiLFwicmV0dXJuICRzdXNwO1wiLFwifVwiKSx0aGlzLl9qdW1wKHUpLHRoaXMuc2V0QmxvY2sodSksdGhpcy51LmRvZXNTdXNwZW5kPSEwKTt0aGlzLnZzZXFzdG10KGEuYm9keSk7dGhpcy5fanVtcChjKTt0aGlzLnNldEJsb2NrKG4pO3RoaXMucG9wQ29udGludWVCbG9jaygpO3RoaXMucG9wQnJlYWtCbG9jaygpO3RoaXMudnNlcXN0bXQoYS5vcmVsc2UpO3RoaXMuX2p1bXAobSk7dGhpcy5zZXRCbG9jayhtKX07Yi5wcm90b3R5cGUuY3JhaXNlPWZ1bmN0aW9uKGEpe2lmKGEuZXhjKXt2YXIgYz10aGlzLl9ncihcImV4Y1wiLHRoaXMudmV4cHIoYS5leGMpKSxuPXRoaXMubmV3QmxvY2soXCJleGNlcHRpb24gbm93IGluc3RhbnRpYXRlZFwiKSxtPXRoaXMuX2dyKFwiaXNjbGFzc1wiLGMrXCIucHJvdG90eXBlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uXCIpO1xudGhpcy5fanVtcGZhbHNlKG0sbik7YS5pbnN0PyhtPXRoaXMuX2dyKFwiaW5zdFwiLHRoaXMudmV4cHIoYS5pbnN0KSksaChcImlmKCEoXCIsbSxcIiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKSB7XCIsbSxcIj0gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW1wiLG0sXCJdKTtcIixcIn1cIiksaChcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoXCIsYyxcIixcIixtLFwiLnYpO1wiKSk6aChcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kKFwiLGMsXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7aChjLFwiPSRyZXQ7XCIpO3RoaXMuX2p1bXAobik7dGhpcy5zZXRCbG9jayhuKTtoKFwiaWYgKFwiLGMsXCIgaW5zdGFuY2VvZiBTay5idWlsdGluLkJhc2VFeGNlcHRpb24pIHt0aHJvdyBcIixjLFwiO30gZWxzZSB7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKCdleGNlcHRpb25zIG11c3QgZGVyaXZlIGZyb20gQmFzZUV4Y2VwdGlvbicpO307XCIpfWVsc2UgaChcInRocm93ICRlcnI7XCIpfTtcbmIucHJvdG90eXBlLm91dHB1dEZpbmFsbHlDYXNjYWRlPWZ1bmN0aW9uKGEpe2lmKDA9PXRoaXMudS5maW5hbGx5QmxvY2tzLmxlbmd0aCloKFwiaWYoJHBvc3RmaW5hbGx5IT09dW5kZWZpbmVkKSB7IGlmICgkcG9zdGZpbmFsbHkucmV0dXJuaW5nKSB7IHJldHVybiAkcG9zdGZpbmFsbHkucmV0dXJuaW5nOyB9IGVsc2UgeyAkYmxrPSRwb3N0ZmluYWxseS5nb3RvQmxvY2s7ICRwb3N0ZmluYWxseT11bmRlZmluZWQ7IGNvbnRpbnVlOyB9IH1cIik7ZWxzZXt2YXIgYz10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTtoKFwiaWYoJHBvc3RmaW5hbGx5IT09dW5kZWZpbmVkKSB7XCIsXCJpZiAoJHBvc3RmaW5hbGx5LnJldHVybmluZ1wiLGMuYnJlYWtEZXB0aD09YS5icmVha0RlcHRoP1wifHwgJHBvc3RmaW5hbGx5LmlzQnJlYWtcIjpcIlwiLFwiKSB7XCIsXCIkYmxrPVwiLGMuYmxrLFwiO2NvbnRpbnVlO1wiLFwifSBlbHNlIHtcIixcIiRibGs9JHBvc3RmaW5hbGx5LmdvdG9CbG9jazskcG9zdGZpbmFsbHk9dW5kZWZpbmVkO2NvbnRpbnVlO1wiLFxuXCJ9XCIsXCJ9XCIpfX07Yi5wcm90b3R5cGUuY3RyeT1mdW5jdGlvbihhKXt2YXIgYyxuPWEuaGFuZGxlcnMubGVuZ3RoO2lmKGEuZmluYWxib2R5KXt2YXIgbT10aGlzLm5ld0Jsb2NrKFwiZmluYWxib2R5XCIpO3ZhciBrPXRoaXMubmV3QmxvY2soXCJmaW5hbGV4aFwiKTt2YXIgdT10aGlzLl9ncihcImZpbmFsbHlfcmVyYWlzZVwiLFwidW5kZWZpbmVkXCIpO3RoaXMudS50ZW1wc1RvU2F2ZS5wdXNoKHUpO3RoaXMucHVzaEZpbmFsbHlCbG9jayhtKTt2YXIgbD10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTt0aGlzLnNldHVwRXhjZXB0KGspfXZhciBxPVtdO2ZvcihjPTA7YzxuOysrYylxLnB1c2godGhpcy5uZXdCbG9jayhcImV4Y2VwdF9cIitjK1wiX1wiKSk7dmFyIHo9dGhpcy5uZXdCbG9jayhcInVuaGFuZGxlZFwiKTt2YXIgcj10aGlzLm5ld0Jsb2NrKFwib3JlbHNlXCIpO3ZhciB0PXRoaXMubmV3QmxvY2soXCJlbmRcIik7MCE9cS5sZW5ndGgmJnRoaXMuc2V0dXBFeGNlcHQocVswXSk7dGhpcy52c2Vxc3RtdChhLmJvZHkpO1xuMCE9cS5sZW5ndGgmJnRoaXMuZW5kRXhjZXB0KCk7dGhpcy5fanVtcChyKTtmb3IoYz0wO2M8bjsrK2Mpe3RoaXMuc2V0QmxvY2socVtjXSk7dmFyIHg9YS5oYW5kbGVyc1tjXTtpZigheC50eXBlJiZjPG4tMSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImRlZmF1bHQgJ2V4Y2VwdDonIG11c3QgYmUgbGFzdFwiLHRoaXMuZmlsZW5hbWUseC5saW5lbm8pO2lmKHgudHlwZSl7dmFyIHY9dGhpcy52ZXhwcih4LnR5cGUpO3ZhciBCPWM9PW4tMT96OnFbYysxXTt2PXRoaXMuX2dyKFwiaW5zdGFuY2VcIixcIlNrLm1pc2NldmFsLmlzVHJ1ZShTay5idWlsdGluLmlzaW5zdGFuY2UoJGVyciwgXCIsdixcIikpXCIpO3RoaXMuX2p1bXBmYWxzZSh2LEIpfXgubmFtZSYmdGhpcy52ZXhwcih4Lm5hbWUsXCIkZXJyXCIpO3RoaXMudnNlcXN0bXQoeC5ib2R5KTt0aGlzLl9qdW1wKHQpfXRoaXMuc2V0QmxvY2soeik7aChcInRocm93ICRlcnI7XCIpO3RoaXMuc2V0QmxvY2socik7dGhpcy52c2Vxc3RtdChhLm9yZWxzZSk7XG50aGlzLl9qdW1wKHQpO3RoaXMuc2V0QmxvY2sodCk7YS5maW5hbGJvZHkmJih0aGlzLmVuZEV4Y2VwdCgpLHRoaXMuX2p1bXAobSksdGhpcy5zZXRCbG9jayhrKSxoKHUsXCI9JGVycjtcIiksdGhpcy5fanVtcChtKSx0aGlzLnNldEJsb2NrKG0pLHRoaXMucG9wRmluYWxseUJsb2NrKCksdGhpcy52c2Vxc3RtdChhLmZpbmFsYm9keSksaChcImlmKFwiLHUsXCIhPT11bmRlZmluZWQpIHsgdGhyb3cgXCIsdSxcIjt9XCIpLHRoaXMub3V0cHV0RmluYWxseUNhc2NhZGUobCkpfTtiLnByb3RvdHlwZS5jd2l0aD1mdW5jdGlvbihhLGMpe3ZhciBuPXRoaXMubmV3QmxvY2soXCJ3aXRoZXhoXCIpLG09dGhpcy5uZXdCbG9jayhcIndpdGh0aWR5dXBcIiksaz10aGlzLm5ld0Jsb2NrKFwid2l0aGNhcnJ5b25cIik7dmFyIHU9dGhpcy5fZ3IoXCJtZ3JcIix0aGlzLnZleHByKGEuaXRlbXNbY10uY29udGV4dF9leHByKSk7aChcIiRyZXQgPSBTay5hYnN0ci5sb29rdXBTcGVjaWFsKFwiLHUsXCIsU2suYnVpbHRpbi5zdHIuJGV4aXQpO1wiKTtcbnRoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTt2YXIgbD10aGlzLl9ncihcImV4aXRcIixcIiRyZXRcIik7dGhpcy51LnRlbXBzVG9TYXZlLnB1c2gobCk7aChcIiRyZXQgPSBTay5hYnN0ci5sb29rdXBTcGVjaWFsKFwiLHUsXCIsU2suYnVpbHRpbi5zdHIuJGVudGVyKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2goXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KCRyZXQpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7dT10aGlzLl9ncihcInZhbHVlXCIsXCIkcmV0XCIpO3RoaXMucHVzaEZpbmFsbHlCbG9jayhtKTt2YXIgcT10aGlzLnUuZmluYWxseUJsb2Nrc1t0aGlzLnUuZmluYWxseUJsb2Nrcy5sZW5ndGgtMV07dGhpcy5zZXR1cEV4Y2VwdChuKTthLml0ZW1zW2NdLm9wdGlvbmFsX3ZhcnMmJnRoaXMubmFtZW9wKGEuaXRlbXNbY10ub3B0aW9uYWxfdmFycy5pZCxTay5hc3Rub2Rlcy5TdG9yZSx1KTtjKzE8YS5pdGVtcy5sZW5ndGg/dGhpcy5jd2l0aChhLGMrXG4xKTp0aGlzLnZzZXFzdG10KGEuYm9keSk7dGhpcy5lbmRFeGNlcHQoKTt0aGlzLl9qdW1wKG0pO3RoaXMuc2V0QmxvY2sobik7aChcIiRyZXQgPSBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChcIixsLFwiLHVuZGVmaW5lZCxTay5idWlsdGluLmdldEV4Y0luZm8oJGVyciksdW5kZWZpbmVkLFtdKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO3RoaXMuX2p1bXB0cnVlKFwiJHJldFwiLGspO2goXCJ0aHJvdyAkZXJyO1wiKTt0aGlzLnNldEJsb2NrKG0pO3RoaXMucG9wRmluYWxseUJsb2NrKCk7aChcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoXCIsbCxcIixbU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLm5vbmUubm9uZSRdKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO3RoaXMub3V0cHV0RmluYWxseUNhc2NhZGUocSk7dGhpcy5fanVtcChrKTt0aGlzLnNldEJsb2NrKGspfTtiLnByb3RvdHlwZS5jYXNzZXJ0PVxuZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy52ZXhwcihhLnRlc3QpLG49dGhpcy5uZXdCbG9jayhcImVuZFwiKTt0aGlzLl9qdW1wdHJ1ZShjLG4pO2goXCJ0aHJvdyBuZXcgU2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcihcIixhLm1zZz90aGlzLnZleHByKGEubXNnKTpcIlwiLFwiKTtcIik7dGhpcy5zZXRCbG9jayhuKX07Yi5wcm90b3R5cGUuY2ltcG9ydGFzPWZ1bmN0aW9uKGEsYyxuKXthPWEudjt2YXIgbT1hLmluZGV4T2YoXCIuXCIpLGs9bjtpZigtMSE9PW0pZm9yKGE9YS5zdWJzdHIobSsxKTstMSE9PW07KW09YS5pbmRleE9mKFwiLlwiKSxuPS0xIT09bT9hLnN1YnN0cigwLG0pOmEsaz10aGlzLl9ncihcImxhdHRyXCIsXCJTay5hYnN0ci5nYXR0cihcIixrLFwiLCBuZXcgU2suYnVpbHRpbi5zdHIoJ1wiLG4sXCInKSlcIiksYT1hLnN1YnN0cihtKzEpO3JldHVybiB0aGlzLm5hbWVvcChjLFNrLmFzdG5vZGVzLlN0b3JlLGspfTtiLnByb3RvdHlwZS5jaW1wb3J0PWZ1bmN0aW9uKGEpe3ZhciBjLG49YS5uYW1lcy5sZW5ndGg7XG5mb3IoYz0wO2M8bjsrK2Mpe3ZhciBtPWEubmFtZXNbY107aChcIiRyZXQgPSBTay5idWlsdGluLl9faW1wb3J0X18oXCIsbS5uYW1lLiRyKCkudixcIiwkZ2JsLCRsb2MsW10sXCIsU2suX19mdXR1cmVfXy5hYnNvbHV0ZV9pbXBvcnQ/MDotMSxcIik7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTt2YXIgaz10aGlzLl9ncihcIm1vZHVsZVwiLFwiJHJldFwiKTtpZihtLmFzbmFtZSl0aGlzLmNpbXBvcnRhcyhtLm5hbWUsbS5hc25hbWUsayk7ZWxzZXt2YXIgdT1tLm5hbWU7bT11LnYuaW5kZXhPZihcIi5cIik7LTEhPT1tJiYodT1uZXcgU2suYnVpbHRpbi5zdHIodS52LnN1YnN0cigwLG0pKSk7dGhpcy5uYW1lb3AodSxTay5hc3Rub2Rlcy5TdG9yZSxrKX19fTtiLnByb3RvdHlwZS5jZnJvbWltcG9ydD1mdW5jdGlvbihhKXt2YXIgYyxuPWEubmFtZXMubGVuZ3RoO3ZhciBtPVtdO3ZhciBrPWEubGV2ZWw7MCE9a3x8U2suX19mdXR1cmVfXy5hYnNvbHV0ZV9pbXBvcnR8fChrPS0xKTtmb3IoYz0wO2M8XG5uOysrYyltW2NdPVwiJ1wiK2EubmFtZXNbY10ubmFtZS52K1wiJ1wiO2goXCIkcmV0ID0gU2suYnVpbHRpbi5fX2ltcG9ydF9fKFwiLGEubW9kdWxlLiRyKCkudixcIiwkZ2JsLCRsb2MsW1wiLG0sXCJdLFwiLGssXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7az10aGlzLl9ncihcIm1vZHVsZVwiLFwiJHJldFwiKTtmb3IoYz0wO2M8bjsrK2Mpe209YS5uYW1lc1tjXTt2YXIgdT1cIidcIittLm5hbWUuditcIidcIjtpZigwPT09YyYmXCIqXCI9PT1tLm5hbWUudil7U2suYXNzZXJ0cy5hc3NlcnQoMT09PW4pO2goXCJTay5pbXBvcnRTdGFyKFwiLGssXCIsJGxvYywgJGdibCk7XCIpO2JyZWFrfXZhciBsPXRoaXMuX2dyKFwiaXRlbVwiLFwiU2suYWJzdHIuZ2F0dHIoXCIsayxcIiwgbmV3IFNrLmJ1aWx0aW4uc3RyKFwiLHUsXCIpLCB1bmRlZmluZWQpXCIpO3U9bS5uYW1lO20uYXNuYW1lJiYodT1tLmFzbmFtZSk7dGhpcy5uYW1lb3AodSxTay5hc3Rub2Rlcy5TdG9yZSxsKX19O2IucHJvdG90eXBlLmJ1aWxkY29kZW9iaj1mdW5jdGlvbihhLFxuYyxuLG0sayx1KXt2YXIgbD1bXSxxLHo9W10scj1bXSx0PVtdLHg9bnVsbCx2PW51bGw7biYmKHo9dGhpcy52c2VxZXhwcihuKSk7bSYmbS5kZWZhdWx0cyYmKHI9dGhpcy52c2VxZXhwcihtLmRlZmF1bHRzKSk7bj10aGlzLmNhbm5vdGF0aW9ucyhtLGEucmV0dXJucyk7bSYmbS5rd19kZWZhdWx0cyYmKHQ9bS5rd19kZWZhdWx0cy5tYXAoSj0+Sj90aGlzLnZleHByKEopOlwidW5kZWZpbmVkXCIpKTttJiZtLnZhcmFyZyYmKHg9bS52YXJhcmcpO20mJm0ua3dhcmcmJih2PW0ua3dhcmcpO2lmKCFTay5fX2Z1dHVyZV9fLnB5dGhvbjMmJm0mJm0ua3dvbmx5YXJncyYmMCE9bS5rd29ubHlhcmdzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIktleXdvcmQtb25seSBhcmd1bWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIik7dmFyIEI9dGhpcy5lbnRlclNjb3BlKGMsYSxhLmxpbmVubyx0aGlzLmNhblN1c3BlbmQpO3ZhciBJPXRoaXMudS5zdGUuZ2VuZXJhdG9yO1xudmFyIE09dGhpcy51LnN0ZS5oYXNGcmVlO3ZhciBTPXRoaXMudS5zdGUuY2hpbGRIYXNGcmVlO3ZhciBFPXRoaXMubmV3QmxvY2soXCJjb2Rlb2JqIGVudHJ5XCIpO3RoaXMudS5wcmVmaXhDb2RlPVwidmFyIFwiK0IrXCI9KGZ1bmN0aW9uIFwiK3RoaXMubmljZU5hbWUoYy52KStcIiQoXCI7dmFyIEg9W107aWYoSSl7aWYodil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihjLnYrXCIoKToga2V5d29yZCBhcmd1bWVudHMgaW4gZ2VuZXJhdG9ycyBub3Qgc3VwcG9ydGVkXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7aWYoeCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihjLnYrXCIoKTogdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBnZW5lcmF0b3JzIG5vdCBzdXBwb3J0ZWRcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTtILnB1c2goXCIkZ2VuXCIpfWVsc2V7diYmKEgucHVzaChcIiRrd2FcIiksdGhpcy51LnRlbXBzVG9TYXZlLnB1c2goXCIka3dhXCIpKTtmb3IocT0wO20mJlxucTxtLmFyZ3MubGVuZ3RoOysrcSlILnB1c2godGhpcy5uYW1lb3AobS5hcmdzW3FdLmFyZyxTay5hc3Rub2Rlcy5QYXJhbSkpO2ZvcihxPTA7bSYmbS5rd29ubHlhcmdzJiZxPG0ua3dvbmx5YXJncy5sZW5ndGg7KytxKUgucHVzaCh0aGlzLm5hbWVvcChtLmt3b25seWFyZ3NbcV0uYXJnLFNrLmFzdG5vZGVzLlBhcmFtKSk7eCYmSC5wdXNoKHRoaXMubmFtZW9wKG0udmFyYXJnLmFyZyxTay5hc3Rub2Rlcy5QYXJhbSkpfWxldCB5PSFJO00mJih5fHxILnB1c2goXCIkZnJlZVwiKSx0aGlzLnUudGVtcHNUb1NhdmUucHVzaChcIiRmcmVlXCIpKTt0aGlzLnUucHJlZml4Q29kZT15P3RoaXMudS5wcmVmaXhDb2RlK1wiJHBvc2FyZ3MsJGt3YXJnc1wiOnRoaXMudS5wcmVmaXhDb2RlK0guam9pbihcIixcIik7dGhpcy51LnByZWZpeENvZGUrPVwiKXtcIjtJJiYodGhpcy51LnByZWZpeENvZGUrPVwiXFxuLy8gZ2VuZXJhdG9yXFxuXCIpO00mJih0aGlzLnUucHJlZml4Q29kZSs9XCJcXG4vLyBoYXMgZnJlZVxcblwiKTtTJiZcbih0aGlzLnUucHJlZml4Q29kZSs9XCJcXG4vLyBoYXMgY2VsbFxcblwiKTt5JiYodGhpcy51LnByZWZpeENvZGUrPVwiXFxuLy8gZmFzdCBjYWxsXFxuXCIpO3ZhciBBPVwie31cIjtJJiYoRT1cIiRnZW4uZ2kkcmVzdW1lYXRcIixBPVwiJGdlbi5naSRsb2NhbHNcIik7cT1cIiwkY2VsbD17fVwiO1MmJkkmJihxPVwiLCRjZWxsPSRnZW4uZ2kkY2VsbHNcIik7dGhpcy51LnZhckRlY2xzQ29kZSs9XCJ2YXIgJGJsaz1cIitFK1wiLCRleGM9W10sJGxvYz1cIitBK3ErXCIsJGdibD1cIisoeT9cInRoaXMgJiYgdGhpcy5mdW5jX2dsb2JhbHNcIjpcInRoaXNcIikrKHkmJk0/XCIsJGZyZWU9dGhpcyAmJiB0aGlzLmZ1bmNfY2xvc3VyZVwiOlwiXCIpK1wiLCRlcnI9dW5kZWZpbmVkLCRyZXQ9dW5kZWZpbmVkLCRwb3N0ZmluYWxseT11bmRlZmluZWQsJGN1cnJMaW5lTm89dW5kZWZpbmVkLCRjdXJyQ29sTm89dW5kZWZpbmVkO1wiO251bGwhPT1Tay5leGVjTGltaXQmJih0aGlzLnUudmFyRGVjbHNDb2RlKz1cImlmICh0eXBlb2YgU2suZXhlY1N0YXJ0ID09PSAndW5kZWZpbmVkJykge1NrLmV4ZWNTdGFydCA9IERhdGUubm93KCl9XCIpO1xubnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kJiYodGhpcy51LnZhckRlY2xzQ29kZSs9XCJpZiAodHlwZW9mIFNrLmxhc3RZaWVsZCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5sYXN0WWllbGQgPSBEYXRlLm5vdygpfVwiKTt0aGlzLnUudmFyRGVjbHNDb2RlKz1cInZhciAkd2FraW5nPWZhbHNlOyBpZiAoXCIrQitcIi4kd2FraW5nU3VzcGVuc2lvbiE9PXVuZGVmaW5lZCkgeyAkd2FrZUZyb21TdXNwZW5zaW9uKCk7ICR3YWtpbmc9dHJ1ZTsgfSBlbHNlIHtcIjtpZih5KXt0aGlzLnUudmFyRGVjbHNDb2RlPXZ8fHh8fG0mJm0ua3dvbmx5YXJncyYmMCE9PW0ua3dvbmx5YXJncy5sZW5ndGg/dGhpcy51LnZhckRlY2xzQ29kZStcIlxcbnZhciAkYXJncyA9IHRoaXMuJHJlc29sdmVBcmdzKCRwb3NhcmdzLCRrd2FyZ3MpXFxuXCI6dGhpcy51LnZhckRlY2xzQ29kZSsoXCJ2YXIgJGFyZ3MgPSAoKCEka3dhcmdzIHx8ICRrd2FyZ3MubGVuZ3RoPT09MCkgJiYgJHBvc2FyZ3MubGVuZ3RoPT09XCIrXG5ILmxlbmd0aCtcIikgPyAkcG9zYXJncyA6IHRoaXMuJHJlc29sdmVBcmdzKCRwb3NhcmdzLCRrd2FyZ3MpXCIpO2ZvcihxPTA7cTxILmxlbmd0aDtxKyspdGhpcy51LnZhckRlY2xzQ29kZSs9XCIsXCIrSFtxXStcIj0kYXJnc1tcIitxK1wiXVwiO2lmKHE9SFt2PzE6MF0pdGhpcy51LnZhckRlY2xzQ29kZSs9YCwkc3VwPSR7cX1gO3RoaXMudS52YXJEZWNsc0NvZGUrPVwiO1xcblwifWlmKEkmJjA8ci5sZW5ndGgpZm9yKEU9bS5hcmdzLmxlbmd0aC1yLmxlbmd0aCxxPTA7cTxyLmxlbmd0aDsrK3EpSD10aGlzLm5hbWVvcChtLmFyZ3NbcStFXS5hcmcsU2suYXN0bm9kZXMuUGFyYW0pLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiaWYoXCIrSCtcIj09PXVuZGVmaW5lZClcIitIK1wiPVwiK0IrXCIuJGRlZmF1bHRzW1wiK3ErXCJdO1wiO2ZvcihxPTA7bSYmcTxtLmFyZ3MubGVuZ3RoOysrcSlIPW0uYXJnc1txXS5hcmcsdGhpcy5pc0NlbGwoSCkmJihIPWQoZih0aGlzLnUucHJpdmF0ZV8sSCkudiksdGhpcy51LnZhckRlY2xzQ29kZSs9XG5cIiRjZWxsLlwiK0grXCI9XCIrSCtcIjtcIik7Zm9yKHE9MDttJiZtLmt3b25seWFyZ3MmJnE8bS5rd29ubHlhcmdzLmxlbmd0aDsrK3EpSD1tLmt3b25seWFyZ3NbcV0uYXJnLHRoaXMuaXNDZWxsKEgpJiYoSD1kKGYodGhpcy51LnByaXZhdGVfLEgpLnYpLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGNlbGwuXCIrSCtcIj1cIitIK1wiO1wiKTt4JiZ0aGlzLmlzQ2VsbCh4LmFyZykmJihxPWQoZih0aGlzLnUucHJpdmF0ZV8seC5hcmcpLnYpLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGNlbGwuXCIrcStcIj1cIitxK1wiO1wiKTt2JiYodGhpcy51LmxvY2FsbmFtZXMucHVzaCh2LmFyZy52KSx0aGlzLnUudmFyRGVjbHNDb2RlKz12LmFyZy52K1wiPW5ldyBTay5idWlsdGluc1snZGljdCddKCRrd2EpO1wiLHRoaXMuaXNDZWxsKHYuYXJnKSYmKHE9ZChmKHRoaXMudS5wcml2YXRlXyx2LmFyZykudiksdGhpcy51LnZhckRlY2xzQ29kZSs9XCIkY2VsbC5cIitxK1wiPVwiK3ErXCI7XCIpKTt0aGlzLnUudmFyRGVjbHNDb2RlKz1cIn1cIjtcblNrLl9fZnV0dXJlX18ucHl0aG9uMyYmdSYmKHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGdibC5fX2NsYXNzX189JGdibC5cIit1LnYrXCI7XCIpO3RoaXMudS5zd2l0Y2hDb2RlPVwid2hpbGUodHJ1ZSl7dHJ5e1wiO3RoaXMudS5zd2l0Y2hDb2RlKz10aGlzLm91dHB1dEludGVycnVwdFRlc3QoKTt0aGlzLnUuc3dpdGNoQ29kZSs9XCJzd2l0Y2goJGJsayl7XCI7dGhpcy51LnN1ZmZpeENvZGU9XCJ9IH1jYXRjaChlcnIpeyBpZiAoIShlcnIgaW5zdGFuY2VvZiBTay5idWlsdGluLkJhc2VFeGNlcHRpb24pKSB7IGVyciA9IG5ldyBTay5idWlsdGluLkV4dGVybmFsRXJyb3IoZXJyKTsgfSBlcnIudHJhY2ViYWNrLnB1c2goe2xpbmVubzogJGN1cnJMaW5lTm8sIGNvbG5vOiAkY3VyckNvbE5vLCBmaWxlbmFtZTogJ1wiK3RoaXMuZmlsZW5hbWUrXCInfSk7IGlmICgkZXhjLmxlbmd0aD4wKSB7ICRlcnIgPSBlcnI7ICRibGs9JGV4Yy5wb3AoKTsgY29udGludWU7IH0gZWxzZSB7IHRocm93IGVycjsgfX0gfX0pO1wiO1xuay5jYWxsKHRoaXMsQik7aWYobSl7Zm9yKGxldCBKIG9mIG0uYXJncylsLnB1c2goSi5hcmcudik7Zm9yKGxldCBKIG9mIG0ua3dvbmx5YXJnc3x8W10pbC5wdXNoKEouYXJnLnYpO3RoaXMudS5hcmduYW1lcz1sfXRoaXMuZXhpdFNjb3BlKCk7MDxyLmxlbmd0aCYmaChCLFwiLiRkZWZhdWx0cz1bXCIsci5qb2luKFwiLFwiKSxcIl07XCIpO20mJm0ua3dvbmx5YXJncyYmMDxtLmt3b25seWFyZ3MubGVuZ3RoJiYoaChCLFwiLmNvX2FyZ2NvdW50PVwiLG0uYXJncy5sZW5ndGgsXCI7XCIpLGgoQixcIi5jb19rd29ubHlhcmdjb3VudD1cIixtLmt3b25seWFyZ3MubGVuZ3RoLFwiO1wiKSxoKEIsXCIuJGt3ZGVmcz1bXCIsdC5qb2luKFwiLFwiKSxcIl07XCIpKTswPGwubGVuZ3RoP2goQixcIi5jb192YXJuYW1lcz1bJ1wiLGwuam9pbihcIicsJ1wiKSxcIiddO1wiKTpoKEIsXCIuY29fdmFybmFtZXM9W107XCIpO2goQixcIi5jb19kb2NzdHJpbmc9XCIsdGhpcy5jRG9jc3RyaW5nT2ZDb2RlKGEpLFwiO1wiKTt2JiZoKEIsXCIuY29fa3dhcmdzPTE7XCIpO1xueCYmaChCLFwiLmNvX3ZhcmFyZ3M9MTtcIik7SXx8aChCLFwiLmNvX2Zhc3RjYWxsPTE7XCIpO2E9XCJcIjtNJiYoYT1cIiwkY2VsbFwiLChrPXRoaXMudS5zdGUuaGFzRnJlZSkmJihhKz1cIiwkZnJlZVwiKSk7aWYoSSlyZXR1cm4gbSYmMDxtLmFyZ3MubGVuZ3RoP3RoaXMuX2dyKFwiZ2VuZXJcIixcIm5ldyBTay5idWlsdGluc1snZnVuY3Rpb24nXSgoZnVuY3Rpb24oKXt2YXIgJG9yaWdhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiXCIsYy52LCdcIixhcmd1bWVudHMubGVuZ3RoLCcsbS5hcmdzLmxlbmd0aC1yLmxlbmd0aCxcIixcIixtLmFyZ3MubGVuZ3RoLFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW5zWydnZW5lcmF0b3InXShcIixCLFwiLCRnYmwsJG9yaWdhcmdzXCIsYSxcIik7fSkpXCIpOnRoaXMuX2dyKFwiZ2VuZXJcIixcIm5ldyBTay5idWlsdGluc1snZnVuY3Rpb24nXSgoZnVuY3Rpb24oKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJcIixcbmMudixcIlxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApO3JldHVybiBuZXcgU2suYnVpbHRpbnNbJ2dlbmVyYXRvciddKFwiLEIsXCIsJGdibCxbXVwiLGEsXCIpO30pKVwiKTtpZigwPHoubGVuZ3RoKXtoKFwiJHJldCA9IG5ldyBTay5idWlsdGluc1snZnVuY3Rpb24nXShcIixCLFwiLCRnYmxcIixhLFwiKTtcIik7Zm9yKGxldCBKIG9mIHoucmV2ZXJzZSgpKWgoXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KFwiLEosXCIsWyRyZXRdKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCk7Yz10aGlzLl9ncihcImZ1bmNvYmpcIixcIiRyZXRcIil9ZWxzZSBjPXRoaXMuX2dyKFwiZnVuY29ialwiLFwibmV3IFNrLmJ1aWx0aW5zWydmdW5jdGlvbiddKFwiLEIsXCIsJGdibFwiLGEsXCIpXCIpO24mJmgoYyxcIi5mdW5jX2Fubm90YXRpb25zPVwiLG4sXCI7XCIpO3JldHVybiBjfTtiLnByb3RvdHlwZS5jYXJnYW5ub3RhdGlvbj1mdW5jdGlvbihhLGMsbil7YyYmKGE9Zih0aGlzLnUucHJpdmF0ZV8sYSkudixuLnB1c2goYCcke2F9J2ApLFxubi5wdXNoKHRoaXMudmV4cHIoYykpKX07Yi5wcm90b3R5cGUuY2FyZ2Fubm90YXRpb25zPWZ1bmN0aW9uKGEsYyl7aWYoYSlmb3IobGV0IG49MDtuPGEubGVuZ3RoO24rKyl7Y29uc3QgbT1hW25dO3RoaXMuY2FyZ2Fubm90YXRpb24obS5hcmcsbS5hbm5vdGF0aW9uLGMpfX07Y29uc3QgZz1uZXcgU2suYnVpbHRpbi5zdHIoXCJyZXR1cm5cIik7Yi5wcm90b3R5cGUuY2Fubm90YXRpb25zPWZ1bmN0aW9uKGEsYyl7Y29uc3Qgbj1bXTthJiYodGhpcy5jYXJnYW5ub3RhdGlvbnMoYS5wb3Nvbmx5YXJncyxuKSx0aGlzLmNhcmdhbm5vdGF0aW9ucyhhLmFyZ3MsbiksYS52YXJhcmcmJmEudmFyYXJnLmFubm90YXRpb24mJnRoaXMuY2FyZ2Fubm90YXRpb24oYS52YXJhcmcuYXJnLGEudmFyYXJnLmFubm90YXRpb24sbiksdGhpcy5jYXJnYW5ub3RhdGlvbnMoYS5rd29ubHlhcmdzLG4pLGEua3dhcmcmJmEua3dhcmcuYW5ub3RhdGlvbiYmdGhpcy5jYXJnYW5ub3RhdGlvbihhLmt3YXJnLmFyZyxcbmEua3dhcmcuYW5ub3RhdGlvbixuKSk7YyYmdGhpcy5jYXJnYW5ub3RhdGlvbihnLGMsbik7aWYoMCE9PW4ubGVuZ3RoKXJldHVyblwiW1wiK24uam9pbihcIixcIikrXCJdXCJ9O2IucHJvdG90eXBlLm1heWJlQ0RvY3N0cmluZ09mQm9keT1mdW5jdGlvbihhKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuIG51bGw7YT1hWzBdO2lmKGEuY29uc3RydWN0b3IhPT1Tay5hc3Rub2Rlcy5FeHByKXJldHVybiBudWxsO2E9YS52YWx1ZTtyZXR1cm4gYS5jb25zdHJ1Y3RvciE9PVNrLmFzdG5vZGVzLlN0cj9udWxsOnRoaXMudmV4cHIoYSl9O2IucHJvdG90eXBlLmNEb2NzdHJpbmdPZkNvZGU9ZnVuY3Rpb24oYSl7c3dpdGNoKGEuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuQXN5bmNGdW5jdGlvbkRlZjpjYXNlIFNrLmFzdG5vZGVzLkZ1bmN0aW9uRGVmOnJldHVybiB0aGlzLm1heWJlQ0RvY3N0cmluZ09mQm9keShhLmJvZHkpfHxcIlNrLmJ1aWx0aW4ubm9uZS5ub25lJFwiO2Nhc2UgU2suYXN0bm9kZXMuTGFtYmRhOmNhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnJldHVyblwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7XG5kZWZhdWx0OlNrLmFzc2VydHMuZmFpbChgdW5leHBlY3RlZCBub2RlIGtpbmQgJHthLmNvbnN0cnVjdG9yLm5hbWV9YCl9fTtiLnByb3RvdHlwZS5jZnVuY3Rpb249ZnVuY3Rpb24oYSxjKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuRnVuY3Rpb25EZWYpO2M9dGhpcy5idWlsZGNvZGVvYmooYSxhLm5hbWUsYS5kZWNvcmF0b3JfbGlzdCxhLmFyZ3MsZnVuY3Rpb24obil7dGhpcy52c2Vxc3RtdChhLmJvZHkpO2goXCJyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1wiKX0sYyk7dGhpcy5uYW1lb3AoYS5uYW1lLFNrLmFzdG5vZGVzLlN0b3JlLGMpfTtiLnByb3RvdHlwZS5jbGFtYmRhPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5MYW1iZGEpO3JldHVybiB0aGlzLmJ1aWxkY29kZW9iaihhLG5ldyBTay5idWlsdGluLnN0cihcIjxsYW1iZGE+XCIpLG51bGwsYS5hcmdzLGZ1bmN0aW9uKGMpe2M9dGhpcy52ZXhwcihhLmJvZHkpO1xuaChcInJldHVybiBcIixjLFwiO1wiKX0pfTtiLnByb3RvdHlwZS5jaWZleHA9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5uZXdCbG9jayhcIm5leHQgb2YgaWZleHBcIiksbj10aGlzLm5ld0Jsb2NrKFwiZW5kIG9mIGlmZXhwXCIpLG09dGhpcy5fZ3IoXCJyZXNcIixcIm51bGxcIiksaz10aGlzLnZleHByKGEudGVzdCk7dGhpcy5fanVtcGZhbHNlKGssYyk7aChtLFwiPVwiLHRoaXMudmV4cHIoYS5ib2R5KSxcIjtcIik7dGhpcy5fanVtcChuKTt0aGlzLnNldEJsb2NrKGMpO2gobSxcIj1cIix0aGlzLnZleHByKGEub3JlbHNlKSxcIjtcIik7dGhpcy5fanVtcChuKTt0aGlzLnNldEJsb2NrKG4pO3JldHVybiBtfTtiLnByb3RvdHlwZS5jZ2VuZXhwZ2VuPWZ1bmN0aW9uKGEsYyxuKXt2YXIgbT10aGlzLm5ld0Jsb2NrKFwic3RhcnQgZm9yIFwiK2MpLGs9dGhpcy5uZXdCbG9jayhcInNraXAgZm9yIFwiK2MpO3RoaXMubmV3QmxvY2soXCJpZiBjbGVhbnVwIGZvciBcIitjKTt2YXIgdT10aGlzLm5ld0Jsb2NrKFwiZW5kIGZvciBcIitjKSxcbmw9YVtjXTtpZigwPT09Yyl2YXIgcT1cIiRsb2MuJGl0ZXIwXCI7ZWxzZXt2YXIgej10aGlzLnZleHByKGwuaXRlcik7cT1cIiRsb2MuXCIrdGhpcy5nZW5zeW0oXCJpdGVyXCIpO2gocSxcIj1cIixcIlNrLmFic3RyLml0ZXIoXCIseixcIik7XCIpfXRoaXMuX2p1bXAobSk7dGhpcy5zZXRCbG9jayhtKTt0aGlzLmFubm90YXRlU291cmNlKG4pO2goXCIkcmV0ID0gU2suYWJzdHIuaXRlcm5leHQoXCIscSx0aGlzLnUuY2FuU3VzcGVuZD9cIiwgdHJ1ZVwiOlwiLCBmYWxzZVwiLFwiKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKG4pO3o9dGhpcy5fZ3IoXCJuZXh0XCIsXCIkcmV0XCIpO3RoaXMuX2p1bXB1bmRlZih6LHUpO3RoaXMudmV4cHIobC50YXJnZXQseik7dmFyIHI9bC5pZnM/bC5pZnMubGVuZ3RoOjA7Zm9yKHE9MDtxPHI7KytxKXRoaXMuYW5ub3RhdGVTb3VyY2UobC5pZnNbcV0pLHo9dGhpcy52ZXhwcihsLmlmc1txXSksdGhpcy5fanVtcGZhbHNlKHosbSk7KytjPGEubGVuZ3RoJiZ0aGlzLmNnZW5leHBnZW4oYSxcbmMsbik7Yz49YS5sZW5ndGgmJih0aGlzLmFubm90YXRlU291cmNlKG4pLGE9dGhpcy52ZXhwcihuKSxoKFwicmV0dXJuIFtcIixrLFwiLypyZXN1bWUqLyxcIixhLFwiLypyZXQqL107XCIpLHRoaXMuc2V0QmxvY2soaykpO3RoaXMuX2p1bXAobSk7dGhpcy5zZXRCbG9jayh1KTsxPT09YyYmaChcInJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XCIpfTtiLnByb3RvdHlwZS5jZ2VuZXhwPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuYnVpbGRjb2Rlb2JqKGEsbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGdlbmV4cHI+XCIpLG51bGwsbnVsbCxmdW5jdGlvbihuKXt0aGlzLmNnZW5leHBnZW4oYS5nZW5lcmF0b3JzLDAsYS5lbHQpfSk7Yz10aGlzLl9ncihcImdlbmVyXCIsXCJTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoXCIsYyxcIik7XCIpO2goYyxcIi5naSRsb2NhbHMuJGl0ZXIwPVNrLmFic3RyLml0ZXIoXCIsdGhpcy52ZXhwcihhLmdlbmVyYXRvcnNbMF0uaXRlciksXCIpO1wiKTtyZXR1cm4gY307Yi5wcm90b3R5cGUuY2NsYXNzPVxuZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkNsYXNzRGVmKTt2YXIgYz10aGlzLnZzZXFleHByKGEuZGVjb3JhdG9yX2xpc3QpO3ZhciBuPXRoaXMudnNlcWV4cHIoYS5iYXNlcyk7bGV0IG09dGhpcy5jdW5wYWNra3dzdG9hcnJheShhLmtleXdvcmRzKTt2YXIgaz10aGlzLmVudGVyU2NvcGUoYS5uYW1lLGEsYS5saW5lbm8pO3ZhciB1PXRoaXMubmV3QmxvY2soXCJjbGFzcyBlbnRyeVwiKTt0aGlzLnUucHJlZml4Q29kZT1cInZhciBcIitrK1wiPShmdW5jdGlvbiAkXCIrYS5uYW1lLnYrXCIkY2xhc3Nfb3V0ZXIoJGdsb2JhbHMsJGxvY2FscywkY2VsbCl7dmFyICRnYmw9JGdsb2JhbHMsJGxvYz0kbG9jYWxzLCRmcmVlPSRnbG9iYWxzO1wiO3RoaXMudS5zd2l0Y2hDb2RlKz1cIihmdW5jdGlvbiAkXCIrYS5uYW1lLnYrXCIkX2Nsb3N1cmUoJGNlbGwpe1wiO3RoaXMudS5zd2l0Y2hDb2RlKz1cInZhciAkYmxrPVwiK3UrXCIsJGV4Yz1bXSwkcmV0PXVuZGVmaW5lZCwkcG9zdGZpbmFsbHk9dW5kZWZpbmVkLCRjdXJyTGluZU5vPXVuZGVmaW5lZCwkY3VyckNvbE5vPXVuZGVmaW5lZDtcIjtcbm51bGwhPT1Tay5leGVjTGltaXQmJih0aGlzLnUuc3dpdGNoQ29kZSs9XCJpZiAodHlwZW9mIFNrLmV4ZWNTdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5leGVjU3RhcnQgPSBEYXRlLm5vdygpfVwiKTtudWxsIT09U2sueWllbGRMaW1pdCYmdGhpcy51LmNhblN1c3BlbmQmJih0aGlzLnUuc3dpdGNoQ29kZSs9XCJpZiAodHlwZW9mIFNrLmxhc3RZaWVsZCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5sYXN0WWllbGQgPSBEYXRlLm5vdygpfVwiKTt0aGlzLnUuc3dpdGNoQ29kZSs9XCJ3aGlsZSh0cnVlKXt0cnl7XCI7dGhpcy51LnN3aXRjaENvZGUrPXRoaXMub3V0cHV0SW50ZXJydXB0VGVzdCgpO3RoaXMudS5zd2l0Y2hDb2RlKz1cInN3aXRjaCgkYmxrKXtcIjt0aGlzLnUuc3VmZml4Q29kZT1cIn19Y2F0Y2goZXJyKXsgaWYgKCEoZXJyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uKSkgeyBlcnIgPSBuZXcgU2suYnVpbHRpbi5FeHRlcm5hbEVycm9yKGVycik7IH0gZXJyLnRyYWNlYmFjay5wdXNoKHtsaW5lbm86ICRjdXJyTGluZU5vLCBjb2xubzogJGN1cnJDb2xObywgZmlsZW5hbWU6ICdcIitcbnRoaXMuZmlsZW5hbWUrXCInfSk7IGlmICgkZXhjLmxlbmd0aD4wKSB7ICRlcnIgPSBlcnI7ICRibGs9JGV4Yy5wb3AoKTsgY29udGludWU7IH0gZWxzZSB7IHRocm93IGVycjsgfX19XCI7dGhpcy51LnN1ZmZpeENvZGUrPVwifSkuY2FsbChudWxsLCAkY2VsbCk7fSk7XCI7dGhpcy51LnByaXZhdGVfPWEubmFtZTt0aGlzLmNib2R5KGEuYm9keSxhLm5hbWUpO2goXCJyZXR1cm47XCIpO3RoaXMuZXhpdFNjb3BlKCk7aChcIiRyZXQgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKCRnYmwsXCIsayxcIixcIixhLm5hbWUuJHIoKS52LFwiLFtcIixuLFwiXSwgJGNlbGwsIFwiLG0sXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oKTtmb3IobGV0IGwgb2YgYy5yZXZlcnNlKCkpaChcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoXCIsbCxcIiwgWyRyZXRdKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCk7dGhpcy5uYW1lb3AoYS5uYW1lLFNrLmFzdG5vZGVzLlN0b3JlLFwiJHJldFwiKX07Yi5wcm90b3R5cGUuY2NvbnRpbnVlPVxuZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5wZWVrRmluYWxseUJsb2NrKCk7aWYoMD09dGhpcy51LmNvbnRpbnVlQmxvY2tzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIidjb250aW51ZScgb3V0c2lkZSBsb29wXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7YT10aGlzLnUuY29udGludWVCbG9ja3NbdGhpcy51LmNvbnRpbnVlQmxvY2tzLmxlbmd0aC0xXTtTay5hc3NlcnRzLmFzc2VydCh0aGlzLnUuYnJlYWtCbG9ja3MubGVuZ3RoPT09dGhpcy51LmNvbnRpbnVlQmxvY2tzLmxlbmd0aCk7YyYmYy5icmVha0RlcHRoPT10aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoP2goXCIkcG9zdGZpbmFsbHk9e2lzQnJlYWs6dHJ1ZSxnb3RvQmxvY2s6XCIsYSxcIn07XCIpOnRoaXMuX2p1bXAoYSl9O2IucHJvdG90eXBlLmNicmVhaz1mdW5jdGlvbihhKXt2YXIgYz10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTtpZigwPT09dGhpcy51LmJyZWFrQmxvY2tzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIidicmVhaycgb3V0c2lkZSBsb29wXCIsXG50aGlzLmZpbGVuYW1lLGEubGluZW5vKTthPXRoaXMudS5icmVha0Jsb2Nrc1t0aGlzLnUuYnJlYWtCbG9ja3MubGVuZ3RoLTFdO2MmJmMuYnJlYWtEZXB0aD09dGhpcy51LmJyZWFrQmxvY2tzLmxlbmd0aD9oKFwiJHBvc3RmaW5hbGx5PXtpc0JyZWFrOnRydWUsZ290b0Jsb2NrOlwiLGEsXCJ9O1wiKTp0aGlzLl9qdW1wKGEpfTtiLnByb3RvdHlwZS52c3RtdD1mdW5jdGlvbihhLGMpe3RoaXMudS5saW5lbm89YS5saW5lbm87dGhpcy51LmxpbmVub1NldD0hMTt0aGlzLnUubG9jYWx0ZW1wcz1bXTtpZihTay5kZWJ1Z2dpbmcmJnRoaXMudS5jYW5TdXNwZW5kKXt2YXIgbj10aGlzLm5ld0Jsb2NrKFwiZGVidWcgYnJlYWtwb2ludCBmb3IgbGluZSBcIithLmxpbmVubyk7aChcImlmIChTay5icmVha3BvaW50cygnXCIrdGhpcy5maWxlbmFtZStcIicsXCIrYS5saW5lbm8rXCIsXCIrYS5jb2xfb2Zmc2V0K1wiKSkge1wiLFwidmFyICRzdXNwID0gJHNhdmVTdXNwZW5zaW9uKHtkYXRhOiB7dHlwZTogJ1NrLmRlYnVnJ30sIHJlc3VtZTogZnVuY3Rpb24oKSB7fX0sICdcIitcbnRoaXMuZmlsZW5hbWUrXCInLFwiK2EubGluZW5vK1wiLFwiK2EuY29sX29mZnNldCtcIik7XCIsXCIkc3VzcC4kYmxrID0gXCIrbitcIjtcIixcIiRzdXNwLm9wdGlvbmFsID0gdHJ1ZTtcIixcInJldHVybiAkc3VzcDtcIixcIn1cIik7dGhpcy5fanVtcChuKTt0aGlzLnNldEJsb2NrKG4pO3RoaXMudS5kb2VzU3VzcGVuZD0hMH10aGlzLmFubm90YXRlU291cmNlKGEpO3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLkZ1bmN0aW9uRGVmOnRoaXMuY2Z1bmN0aW9uKGEsYyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5DbGFzc0RlZjp0aGlzLmNjbGFzcyhhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlJldHVybjppZih0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jayl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIidyZXR1cm4nIG91dHNpZGUgZnVuY3Rpb25cIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTtuPWEudmFsdWU/dGhpcy52ZXhwcihhLnZhbHVlKTpcblwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7MD09dGhpcy51LmZpbmFsbHlCbG9ja3MubGVuZ3RoP2goXCJyZXR1cm4gXCIsbixcIjtcIik6KGgoXCIkcG9zdGZpbmFsbHk9e3JldHVybmluZzpcIixuLFwifTtcIiksdGhpcy5fanVtcCh0aGlzLnBlZWtGaW5hbGx5QmxvY2soKS5ibGspKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbGV0ZTp0aGlzLnZzZXFleHByKGEudGFyZ2V0cyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Bc3NpZ246dmFyIG09YS50YXJnZXRzLmxlbmd0aDtuPXRoaXMudmV4cHIoYS52YWx1ZSk7Zm9yKGM9MDtjPG07KytjKXRoaXMudmV4cHIoYS50YXJnZXRzW2NdLG4pO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQW5uQXNzaWduOnJldHVybiB0aGlzLmNhbm5hc3NpZ24oYSk7Y2FzZSBTay5hc3Rub2Rlcy5BdWdBc3NpZ246cmV0dXJuIHRoaXMuY2F1Z2Fzc2lnbihhKTtjYXNlIFNrLmFzdG5vZGVzLlByaW50OnRoaXMuY3ByaW50KGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRm9yOnJldHVybiB0aGlzLmNmb3IoYSk7XG5jYXNlIFNrLmFzdG5vZGVzLldoaWxlOnJldHVybiB0aGlzLmN3aGlsZShhKTtjYXNlIFNrLmFzdG5vZGVzLklmOnJldHVybiB0aGlzLmNpZihhKTtjYXNlIFNrLmFzdG5vZGVzLlJhaXNlOnJldHVybiB0aGlzLmNyYWlzZShhKTtjYXNlIFNrLmFzdG5vZGVzLlRyeTpyZXR1cm4gdGhpcy5jdHJ5KGEpO2Nhc2UgU2suYXN0bm9kZXMuV2l0aDpyZXR1cm4gdGhpcy5jd2l0aChhLDApO2Nhc2UgU2suYXN0bm9kZXMuQXNzZXJ0OnJldHVybiB0aGlzLmNhc3NlcnQoYSk7Y2FzZSBTay5hc3Rub2Rlcy5JbXBvcnQ6cmV0dXJuIHRoaXMuY2ltcG9ydChhKTtjYXNlIFNrLmFzdG5vZGVzLkltcG9ydEZyb206cmV0dXJuIHRoaXMuY2Zyb21pbXBvcnQoYSk7Y2FzZSBTay5hc3Rub2Rlcy5HbG9iYWw6YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5FeHByOnRoaXMudmV4cHIoYS52YWx1ZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5QYXNzOmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQnJlYWs6dGhpcy5jYnJlYWsoYSk7XG5icmVhaztjYXNlIFNrLmFzdG5vZGVzLkNvbnRpbnVlOnRoaXMuY2NvbnRpbnVlKGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGVidWdnZXI6aChcImRlYnVnZ2VyO1wiKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlIGluIHZzdG10OiBcIitKU09OLnN0cmluZ2lmeShhKSl9fTtiLnByb3RvdHlwZS52c2Vxc3RtdD1mdW5jdGlvbihhKXt2YXIgYztmb3IoYz0wO2M8YS5sZW5ndGg7KytjKXRoaXMudnN0bXQoYVtjXSl9O2IucHJvdG90eXBlLmlzQ2VsbD1mdW5jdGlvbihhKXthPWQoZih0aGlzLnUucHJpdmF0ZV8sYSkudik7cmV0dXJuIHRoaXMudS5zdGUuZ2V0U2NvcGUoYSk9PT1Tay5TWU1UQUJfQ09OU1RTLkNFTEx9O2IucHJvdG90eXBlLm5hbWVvcD1mdW5jdGlvbihhLGMsbil7aWYoKGM9PT1Tay5hc3Rub2Rlcy5TdG9yZXx8Yz09PVNrLmFzdG5vZGVzLkF1Z1N0b3JlfHxjPT09U2suYXN0bm9kZXMuRGVsKSYmXCJfX2RlYnVnX19cIj09PWEudil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImNhbiBub3QgYXNzaWduIHRvIF9fZGVidWdfX1wiLFxudGhpcy5maWxlbmFtZSx0aGlzLnUubGluZW5vKTtTay5hc3NlcnRzLmFzc2VydChcIk5vbmVcIiE9PWEudik7aWYoXCJOb3RJbXBsZW1lbnRlZFwiPT09YS52KXJldHVyblwiU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCRcIjt2YXIgbT1mKHRoaXMudS5wcml2YXRlXyxhKS52O209ZChtKTt2YXIgaz0zO3ZhciB1PXRoaXMudS5zdGUuZ2V0U2NvcGUobSk7dmFyIGw9bnVsbDtzd2l0Y2godSl7Y2FzZSBTay5TWU1UQUJfQ09OU1RTLkZSRUU6bD1cIiRmcmVlXCI7az0yO2JyZWFrO2Nhc2UgU2suU1lNVEFCX0NPTlNUUy5DRUxMOmw9XCIkY2VsbFwiO2s9MjticmVhaztjYXNlIFNrLlNZTVRBQl9DT05TVFMuTE9DQUw6dGhpcy51LnN0ZS5ibG9ja1R5cGUhPT1Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2t8fHRoaXMudS5zdGUuZ2VuZXJhdG9yfHwoaz0wKTticmVhaztjYXNlIFNrLlNZTVRBQl9DT05TVFMuR0xPQkFMX0lNUExJQ0lUOnRoaXMudS5zdGUuYmxvY2tUeXBlPT09XG5Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2smJihrPTEpO2JyZWFrO2Nhc2UgU2suU1lNVEFCX0NPTlNUUy5HTE9CQUxfRVhQTElDSVQ6az0xfVNrLmFzc2VydHMuYXNzZXJ0KHV8fFwiX1wiPT09YS52LmNoYXJBdCgxKSk7YT1tO3RoaXMudS5zdGUuZ2VuZXJhdG9yfHx0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jaz9tPVwiJGxvYy5cIittOigwPT09a3x8Mz09PWspJiZ0aGlzLnUubG9jYWxuYW1lcy5wdXNoKG0pO3N3aXRjaChrKXtjYXNlIDA6c3dpdGNoKGMpe2Nhc2UgU2suYXN0bm9kZXMuTG9hZDpjYXNlIFNrLmFzdG5vZGVzLlBhcmFtOnJldHVybiBoKFwiaWYgKFwiLG0sXCIgPT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgU2suYnVpbHRpbi5VbmJvdW5kTG9jYWxFcnJvcignbG9jYWwgdmFyaWFibGUgXFxcXCdcIixtLFwiXFxcXCcgcmVmZXJlbmNlZCBiZWZvcmUgYXNzaWdubWVudCcpOyB9XFxuXCIpLG07Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTpoKG0sXG5cIj1cIixuLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbDpoKFwiZGVsZXRlIFwiLG0sXCI7XCIpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkXCIpfWJyZWFrO2Nhc2UgMzpzd2l0Y2goYyl7Y2FzZSBTay5hc3Rub2Rlcy5Mb2FkOnJldHVybiB0aGlzLl9ncihcImxvYWRuYW1lXCIsbSxcIiE9PXVuZGVmaW5lZD9cIixtLFwiOlNrLm1pc2NldmFsLmxvYWRuYW1lKCdcIixhLFwiJywkZ2JsKTtcIik7Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTpoKG0sXCI9XCIsbixcIjtcIik7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EZWw6aChcImRlbGV0ZSBcIixtLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlBhcmFtOnJldHVybiBtO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkXCIpfWJyZWFrO2Nhc2UgMTpzd2l0Y2goYyl7Y2FzZSBTay5hc3Rub2Rlcy5Mb2FkOnJldHVybiB0aGlzLl9ncihcImxvYWRnYmxcIixcIlNrLm1pc2NldmFsLmxvYWRuYW1lKCdcIixhLFwiJywkZ2JsKVwiKTtjYXNlIFNrLmFzdG5vZGVzLlN0b3JlOmgoXCIkZ2JsLlwiLFxuYSxcIj1cIixuLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkRlbDpoKFwiZGVsZXRlICRnYmwuXCIsYSk7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgY2FzZSBpbiBuYW1lIG9wX2dsb2JhbFwiKX1icmVhaztjYXNlIDI6c3dpdGNoKGMpe2Nhc2UgU2suYXN0bm9kZXMuTG9hZDpyZXR1cm4gbCtcIi5cIithO2Nhc2UgU2suYXN0bm9kZXMuU3RvcmU6aChsLFwiLlwiLGEsXCI9XCIsbixcIjtcIik7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5QYXJhbTpyZXR1cm4gYTtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlIGluIG5hbWUgb3BfZGVyZWZcIil9YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgY2FzZVwiKX19O2IucHJvdG90eXBlLmVudGVyU2NvcGU9ZnVuY3Rpb24oYSxjLG4sbSl7dmFyIGs9bmV3IGU7ay5zdGU9dGhpcy5zdC5nZXRTdHNGb3JBc3QoYyk7ay5uYW1lPWE7ay5maXJzdGxpbmVubz1uO2suY2FuU3VzcGVuZD1tfHxcbiExO3RoaXMudSYmdGhpcy51LnByaXZhdGVfJiYoay5wcml2YXRlXz10aGlzLnUucHJpdmF0ZV8pO3RoaXMuc3RhY2sucHVzaCh0aGlzLnUpO3RoaXMuYWxsVW5pdHMucHVzaChrKTthPXRoaXMuZ2Vuc3ltKFwic2NvcGVcIik7ay5zY29wZW5hbWU9YTt0aGlzLnU9azt0aGlzLnUuYWN0aXZhdGVTY29wZSgpO3RoaXMubmVzdGxldmVsKys7cmV0dXJuIGF9O2IucHJvdG90eXBlLmV4aXRTY29wZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMudTt0aGlzLm5lc3RsZXZlbC0tOyh0aGlzLnU9MDw9dGhpcy5zdGFjay5sZW5ndGgtMT90aGlzLnN0YWNrLnBvcCgpOm51bGwpJiZ0aGlzLnUuYWN0aXZhdGVTY29wZSgpO2lmKFwiPG1vZHVsZT5cIiE9PWEubmFtZS52KXt2YXIgYz1hLm5hbWUuJHIoKS52O2M9Yy5zdWJzdHJpbmcoMSxjLmxlbmd0aC0xKTtoKGEuc2NvcGVuYW1lLFwiLmNvX25hbWU9bmV3IFNrLmJ1aWx0aW5zWydzdHInXSgnXCIsYyxcIicpO1wiKTt0aGlzLnN0YWNrLmxlbmd0aCYmXCJjbGFzc1wiPT1cbnRoaXMudS5zdGUuYmxvY2tUeXBlJiZoKGEuc2NvcGVuYW1lLFwiLmNvX3F1YWxuYW1lPW5ldyBTay5idWlsdGluc1snc3RyJ10oJ1wiK3RoaXMudS5uYW1lLnYrXCIuXCIrYytcIicpO1wiKX1mb3IodmFyIG4gaW4gYS5jb25zdHMpYS5jb25zdHMuaGFzT3duUHJvcGVydHkobikmJihhLnN1ZmZpeENvZGUrPW4rXCIgPSBcIithLmNvbnN0c1tuXStcIjtcIil9O2IucHJvdG90eXBlLmNib2R5PWZ1bmN0aW9uKGEsYyl7dmFyIG49MDtjb25zdCBtPXRoaXMubWF5YmVDRG9jc3RyaW5nT2ZCb2R5KGEpO251bGwhPT1tJiYoaChcIiRsb2MuX19kb2NfXyA9IFwiLG0sXCI7XCIpLG49MSk7Zm9yKDtuPGEubGVuZ3RoOysrbil0aGlzLnZzdG10KGFbbl0sYyk7dGhpcy51Lmhhc0Fubm90YXRpb25zJiYodGhpcy51LnZhckRlY2xzQ29kZSs9XCIkbG9jLl9fYW5ub3RhdGlvbnNfXyB8fCAoJGxvYy5fX2Fubm90YXRpb25zX18gPSBuZXcgU2suYnVpbHRpbi5kaWN0KCkpO1wiKX07Yi5wcm90b3R5cGUuY3ByaW50PWZ1bmN0aW9uKGEpe3ZhciBjO1xuU2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLlByaW50KTthLmRlc3QmJnRoaXMudmV4cHIoYS5kZXN0KTt2YXIgbj1hLnZhbHVlcy5sZW5ndGg7Zm9yKGM9MDtjPG47KytjKWgoXCIkcmV0ID0gU2subWlzY2V2YWwucHJpbnRfKFwiLFwibmV3IFNrLmJ1aWx0aW5zWydzdHInXShcIix0aGlzLnZleHByKGEudmFsdWVzW2NdKSxcIikudik7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTthLm5sJiYoaChcIiRyZXQgPSBTay5taXNjZXZhbC5wcmludF8oXCIsJ1wiXFxcXG5cIik7JyksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpKX07Yi5wcm90b3R5cGUuY21vZD1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmVudGVyU2NvcGUobmV3IFNrLmJ1aWx0aW4uc3RyKFwiPG1vZHVsZT5cIiksYSwwLHRoaXMuY2FuU3VzcGVuZCksbj10aGlzLm5ld0Jsb2NrKFwibW9kdWxlIGVudHJ5XCIpO3RoaXMudS5wcmVmaXhDb2RlPVwidmFyIFwiK2MrXCI9KGZ1bmN0aW9uKCRmb3JjZWdibCwgJGZvcmNlbG9jKXtcIjtcbnRoaXMudS52YXJEZWNsc0NvZGU9XCJ2YXIgJGdibCA9ICRmb3JjZWdibCB8fCB7fSwgJGJsaz1cIituK1wiLCRleGM9W10sJGxvYz0kZm9yY2Vsb2MgfHwgJGdibCwkY2VsbD17fSwkZXJyPXVuZGVmaW5lZDt2YXIgJHJldD11bmRlZmluZWQsJHBvc3RmaW5hbGx5PXVuZGVmaW5lZCwkY3VyckxpbmVObz11bmRlZmluZWQsJGN1cnJDb2xObz11bmRlZmluZWQ7XCI7bnVsbCE9PVNrLmV4ZWNMaW1pdCYmKHRoaXMudS52YXJEZWNsc0NvZGUrPVwiaWYgKHR5cGVvZiBTay5leGVjU3RhcnQgPT09ICd1bmRlZmluZWQnKSB7U2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKX1cIik7bnVsbCE9PVNrLnlpZWxkTGltaXQmJnRoaXMudS5jYW5TdXNwZW5kJiYodGhpcy51LnZhckRlY2xzQ29kZSs9XCJpZiAodHlwZW9mIFNrLmxhc3RZaWVsZCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5sYXN0WWllbGQgPSBEYXRlLm5vdygpfVwiKTt0aGlzLnUudmFyRGVjbHNDb2RlKz1cInZhciAkd2FraW5nPWZhbHNlOyBpZiAoXCIrYytcblwiLiR3YWtpbmdTdXNwZW5zaW9uIT09dW5kZWZpbmVkKSB7ICR3YWtlRnJvbVN1c3BlbnNpb24oKTsgJHdha2luZz10cnVlOyB9aWYgKFNrLnJldGFpbkdsb2JhbHMpIHsgICAgaWYgKFNrLmdsb2JhbHMpIHsgJGdibCA9IFNrLmdsb2JhbHM7IFNrLmdsb2JhbHMgPSAkZ2JsOyAkbG9jID0gJGdibDsgfSAgICBlbHNlIHsgU2suZ2xvYmFscyA9ICRnYmw7IH19IGVsc2UgeyBTay5nbG9iYWxzID0gJGdibDsgfVwiO3RoaXMudS5zd2l0Y2hDb2RlPVwid2hpbGUodHJ1ZSl7dHJ5e1wiO3RoaXMudS5zd2l0Y2hDb2RlKz10aGlzLm91dHB1dEludGVycnVwdFRlc3QoKTt0aGlzLnUuc3dpdGNoQ29kZSs9XCJzd2l0Y2goJGJsayl7XCI7dGhpcy51LnN1ZmZpeENvZGU9XCJ9XCI7dGhpcy51LnN1ZmZpeENvZGUrPVwifWNhdGNoKGVycil7IGlmICghKGVyciBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikpIHsgZXJyID0gbmV3IFNrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvcihlcnIpOyB9IGVyci50cmFjZWJhY2sucHVzaCh7bGluZW5vOiAkY3VyckxpbmVObywgY29sbm86ICRjdXJyQ29sTm8sIGZpbGVuYW1lOiAnXCIrXG50aGlzLmZpbGVuYW1lK1wiJ30pOyBpZiAoJGV4Yy5sZW5ndGg+MCkgeyAkZXJyID0gZXJyOyAkYmxrPSRleGMucG9wKCk7IGNvbnRpbnVlOyB9IGVsc2UgeyB0aHJvdyBlcnI7IH19IH0gfSk7XCI7c3dpdGNoKGEuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuTW9kdWxlOnRoaXMuY2JvZHkoYS5ib2R5KTtoKFwicmV0dXJuICRsb2M7XCIpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidG9kbzsgdW5oYW5kbGVkIGNhc2UgaW4gY29tcGlsZXJNb2RcIil9dGhpcy5leGl0U2NvcGUoKTt0aGlzLnJlc3VsdC5wdXNoKHRoaXMub3V0cHV0QWxsVW5pdHMoKSk7cmV0dXJuIGN9O1NrLmNvbXBpbGU9ZnVuY3Rpb24oYSxjLG4sbSl7bj1Tay5fX2Z1dHVyZV9fO1NrLl9fZnV0dXJlX189T2JqZWN0LmNyZWF0ZShTay5fX2Z1dHVyZV9fKTt2YXIgaz1Tay5wYXJzZShjLGEpLHU9U2suYXN0RnJvbVBhcnNlKGsuY3N0LGMsay5mbGFncyk7az1rLmZsYWdzO3ZhciBsPVNrLnN5bWJvbHRhYmxlKHUsXG5jKTthPW5ldyBiKGMsbCxrLG0sYSk7bT1hLmNtb2QodSk7U2suX19mdXR1cmVfXz1uO3JldHVybntmdW5jbmFtZTpcIiRjb21waWxlZG1vZFwiLGNvZGU6YHZhciAkY29tcGlsZWRtb2QgPSBmdW5jdGlvbigpIHske2EucmVzdWx0LmpvaW4oXCJcIil9XFxucmV0dXJuICR7bX07fSgpO1xcbiRjb21waWxlZG1vZDtgLGZpbGVuYW1lOmN9fTtTay5leHBvcnRTeW1ib2woXCJTay5jb21waWxlXCIsU2suY29tcGlsZSk7U2sucmVzZXRDb21waWxlcj1mdW5jdGlvbigpe1NrLmdlbnN5bWNvdW50PTB9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnJlc2V0Q29tcGlsZXJcIixTay5yZXNldENvbXBpbGVyKTtTay5maXhSZXNlcnZlZD1kO1NrLmV4cG9ydFN5bWJvbChcIlNrLmZpeFJlc2VydmVkXCIsU2suZml4UmVzZXJ2ZWQpO1NrLnVuZml4UmVzZXJ2ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvX1xcJHJ3XFwkJC8sXCJcIil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnVuZml4UmVzZXJ2ZWRcIixTay51bmZpeFJlc2VydmVkKTtcblNrLm1hbmdsZU5hbWU9ZjtTay5leHBvcnRTeW1ib2woXCJTay5tYW5nbGVOYW1lXCIsU2subWFuZ2xlTmFtZSk7U2sucmVzZXJ2ZWRXb3Jkc189cDtTay5leHBvcnRTeW1ib2woXCJTay5yZXNlcnZlZFdvcmRzX1wiLFNrLnJlc2VydmVkV29yZHNfKX0sZnVuY3Rpb24oRixQKXtTay5zeXNtb2R1bGVzPW5ldyBTay5idWlsdGluLmRpY3QoW10pO1NrLnJlYWxzeXNwYXRoPXZvaWQgMDtTay5pbXBvcnRTZWFyY2hQYXRoRm9yTmFtZT1mdW5jdGlvbihiLGUsZCl7dmFyIGY9Yi5yZXBsYWNlKC9cXC4vZyxcIi9cIiksaD1mdW5jdGlvbihwLGcpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC50cnlDYXRjaChmdW5jdGlvbigpe3JldHVybiBTay5yZWFkKHApfSxmdW5jdGlvbihhKXt9KSxmdW5jdGlvbihhKXtpZih2b2lkIDAhPT1hKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoe2ZpbGVuYW1lOnAsY29kZTphLHBhY2thZ2VQYXRoOmd9KX0pfTt2b2lkIDA9PT1kJiYoZD1Tay5yZWFsc3lzcGF0aCk7XG5yZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihkLnRwJGl0ZXIoKSxmdW5jdGlvbihwKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oaChwLnYrXCIvXCIrZitlLCExKSxmdW5jdGlvbihnKXtyZXR1cm4gZz9nOmgocC52K1wiL1wiK2YrXCIvX19pbml0X19cIitlLHAuditcIi9cIitmKX0pfSl9O1NrLmltcG9ydFNldFVwUGF0aD1mdW5jdGlvbihiKXtpZighU2sucmVhbHN5c3BhdGgpe3ZhciBlPVtuZXcgU2suYnVpbHRpbi5zdHIoXCJzcmMvYnVpbHRpblwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXCJzcmMvbGliXCIpLG5ldyBTay5idWlsdGluLnN0cihcIi5cIildO2ZvcihiPTA7YjxTay5zeXNwYXRoLmxlbmd0aDsrK2IpZS5wdXNoKG5ldyBTay5idWlsdGluLnN0cihTay5zeXNwYXRoW2JdKSk7U2sucmVhbHN5c3BhdGg9bmV3IFNrLmJ1aWx0aW4ubGlzdChlKX19O1NrLmltcG9ydE1vZHVsZUludGVybmFsXz1mdW5jdGlvbihiLGUsZCxmLGgscCxnKXt2YXIgYSxjLG4sbSxrPW51bGwsdT12b2lkIDAhPT1oP1xuaC50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRuYW1lKTp2b2lkIDAsbD12b2lkIDAhPT11P3UuditcIi5cIjpcIlwiLHE9dm9pZCAwIT09aD9oLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJHBhdGgpOnZvaWQgMDtTay5pbXBvcnRTZXRVcFBhdGgoZyk7aWYoaCYmIXUpe2lmKHApcmV0dXJuO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBdHRlbXB0ZWQgdG8gaW1wb3J0IHJlbGF0aXZlIHRvIGludmFsaWQgcGFja2FnZSAobm8gbmFtZSlcIik7fXZvaWQgMD09PWQmJihkPWwrYik7dmFyIHo9Yi5zcGxpdChcIi5cIik7aWYoMTx6Lmxlbmd0aCl7dmFyIHI9ei5zbGljZSgwLHoubGVuZ3RoLTEpLmpvaW4oXCIuXCIpO2s9U2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKHIsZSx2b2lkIDAsdm9pZCAwLGgscCxnKX12YXIgdD1Tay5taXNjZXZhbC5jaGFpbihrLGZ1bmN0aW9uKHgpe2s9eDtjPVNrLnN5c21vZHVsZXMucXVpY2skbG9va3VwKG5ldyBTay5idWlsdGluLnN0cihkKSk7cmV0dXJuIHZvaWQgMCE9PVxuYz9rfHxjOlNrLm1pc2NldmFsLmNoYWluKHZvaWQgMCxmdW5jdGlvbigpe3ZhciB2PWI7aWYoMTx6Lmxlbmd0aCl7aWYoIWspcmV0dXJuO249U2suc3lzbW9kdWxlcy5tcCRzdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc3RyKGwrcikpO3Y9elt6Lmxlbmd0aC0xXTtxPW4udHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kcGF0aCl9bT1uZXcgU2suYnVpbHRpbi5tb2R1bGU7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBmKXthPWIrXCIucHlcIjt2YXIgQj1Tay5jb21waWxlKGYsYSxcImV4ZWNcIixnKX1lbHNlIEI9U2subWlzY2V2YWwuY2hhaW4odm9pZCAwLGZ1bmN0aW9uKCl7aWYoU2sub25CZWZvcmVJbXBvcnQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5vbkJlZm9yZUltcG9ydClyZXR1cm4gU2sub25CZWZvcmVJbXBvcnQoYil9LGZ1bmN0aW9uKEkpe2lmKCExPT09SSl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbXBvcnRFcnJvcihcIkltcG9ydGluZyBcIitiK1wiIGlzIG5vdCBhbGxvd2VkXCIpO2lmKFwic3RyaW5nXCI9PT1cbnR5cGVvZiBJKXRocm93IG5ldyBTay5idWlsdGluLkltcG9ydEVycm9yKEkpO3JldHVybiBTay5pbXBvcnRTZWFyY2hQYXRoRm9yTmFtZSh2LFwiLmpzXCIscSl9LGZ1bmN0aW9uKEkpe3JldHVybiBJP3tmdW5jbmFtZTpcIiRidWlsdGlubW9kdWxlXCIsY29kZTpJLmNvZGUsZmlsZW5hbWU6SS5maWxlbmFtZSxwYWNrYWdlUGF0aDpJLnBhY2thZ2VQYXRofTpTay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRTZWFyY2hQYXRoRm9yTmFtZSh2LFwiLnB5XCIscSksZnVuY3Rpb24oTSl7aWYoST1NKXJldHVybiBTay5jb21waWxlKEkuY29kZSxJLmZpbGVuYW1lLFwiZXhlY1wiLGcpfSxmdW5jdGlvbihNKXtpZihNKXJldHVybiBNLnBhY2thZ2VQYXRoPUkucGFja2FnZVBhdGgsTX0pfSk7cmV0dXJuIEJ9LGZ1bmN0aW9uKHYpe2lmKHYpe3ZhciBCPW0uJGpzPXYuY29kZTtudWxsPT1hJiYoYT12LmZpbGVuYW1lKTtudWxsIT1Tay5kYXRlU2V0JiZTay5kYXRlU2V0fHwoQj1cIlNrLmV4ZWNTdGFydCA9IFNrLmxhc3RZaWVsZCA9IG5ldyBEYXRlKCk7XFxuXCIrXG52LmNvZGUsU2suZGF0ZVNldD0hMCk7aWYoZSl7dmFyIEk9ZnVuY3Rpb24oeSl7dmFyIEEsSj1Tay5qc19iZWF1dGlmeSh5KS5zcGxpdChcIlxcblwiKTtmb3IoQT0xO0E8PUoubGVuZ3RoOysrQSl7dmFyIFE9KFwiXCIrQSkubGVuZ3RoO2Zvcih5PVwiXCI7NT5ROysrUSl5Kz1cIiBcIjtKW0EtMV09XCIvKiBcIit5K0ErXCIgKi8gXCIrSltBLTFdfXJldHVybiBKLmpvaW4oXCJcXG5cIil9O0I9SShCKTtTay5kZWJ1Z291dChCKX1cIiRjb21waWxlZG1vZFwiIT09di5mdW5jbmFtZSYmKEIrPVwiXFxuXCIrdi5mdW5jbmFtZStcIjtcIik7dmFyIE09bmV3IFNrLmJ1aWx0aW4uc3RyKGQpLFM9bmV3IFNrLmJ1aWx0aW4uc3RyKGIpO1NrLnN5c21vZHVsZXMubXAkYXNzX3N1YnNjcmlwdChNLG0pO2gmJmgudHAkc2V0YXR0cihTLG0pO3ZhciBFPVNrLmdsb2JhbC5ldmFsKEIpO20uaW5pdCRkaWN0KE0sU2suYnVpbHRpbi5ub25lLm5vbmUkKTttLiRkLl9fcGFja2FnZV9fPXYucGFja2FnZVBhdGg/TTpyP25ldyBTay5idWlsdGluLnN0cihsK1xucik6dT91OlNrLmJ1aWx0aW4ubm9uZS5ub25lJDt2LnBhY2thZ2VQYXRoJiYobS4kZC5fX3BhdGhfXz1uZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKHYucGFja2FnZVBhdGgpXSkpO3YuZmlsZW5hbWUmJlwiJGJ1aWx0aW5tb2R1bGVcIiE9PXYuZnVuY25hbWUmJihtLiRkLl9fZmlsZV9fPW5ldyBTay5idWlsdGluLnN0cih2LmZpbGVuYW1lKSk7dmFyIEg9aCYmaC4kaW5pdGlhbGl6aW5nO20uJGluaXRpYWxpemluZz0hMDtoJiYhSCYmKGguJGluaXRpYWxpemluZz0hMCk7cmV0dXJuIFNrLm1pc2NldmFsLnRyeUNhdGNoKCgpPT5Tay5taXNjZXZhbC5jaGFpbihFKG0uJGQpLHk9PnttLiRpbml0aWFsaXppbmc9ITE7aCYmIUgmJihoLiRpbml0aWFsaXppbmc9ITEpO3JldHVybiB5fSkseT0+e3RyeXtTay5hYnN0ci5vYmplY3REZWxJdGVtKFNrLnN5c21vZHVsZXMsTSl9Y2F0Y2goQSl7fWlmKGgpdHJ5e2gudHAkc2V0YXR0cihTLHZvaWQgMCl9Y2F0Y2goQSl7fW0uJGluaXRpYWxpemluZz1cbiExO2gmJiFIJiYoaC4kaW5pdGlhbGl6aW5nPSExKTt0aHJvdyB5O30pfX0sZnVuY3Rpb24odil7dmFyIEI7aWYodm9pZCAwPT09dil7aWYocCYmIWspcmV0dXJuO3Rocm93IG5ldyBTay5idWlsdGluLk1vZHVsZU5vdEZvdW5kRXJyb3IoXCJObyBtb2R1bGUgbmFtZWQgXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcihuZXcgU2suYnVpbHRpbi5zdHIoYikpKTt9aWYodiE9PW0uJGQpe2ZvcihCIGluIG0uJGQpdltCXXx8KHZbQl09bS4kZFtCXSk7bS4kZD12fWlmKFNrLm9uQWZ0ZXJJbXBvcnQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5vbkFmdGVySW1wb3J0KXRyeXtTay5vbkFmdGVySW1wb3J0KGIpfWNhdGNoKEkpe31yZXR1cm4gaz8obi50cCRzZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cih6W3oubGVuZ3RoLTFdKSxtKSxrKTptfSl9KTtyZXR1cm4gZz90OlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyh0KX07U2suaW1wb3J0TW9kdWxlPWZ1bmN0aW9uKGIsXG5lLGQpe3JldHVybiBTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oYixlLHZvaWQgMCx2b2lkIDAsdm9pZCAwLCExLGQpfTtTay5pbXBvcnRNYWluPWZ1bmN0aW9uKGIsZSxkKXtTay5kYXRlU2V0PSExO1NrLmZpbGVzTG9hZGVkPSExO1NrLnN5c21vZHVsZXM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7U2sucmVhbHN5c3BhdGg9dm9pZCAwO1NrLnJlc2V0Q29tcGlsZXIoKTtyZXR1cm4gU2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKGIsZSxcIl9fbWFpbl9fXCIsdm9pZCAwLHZvaWQgMCwhMSxkKX07U2suaW1wb3J0TWFpbldpdGhCb2R5PWZ1bmN0aW9uKGIsZSxkLGYpe1NrLmRhdGVTZXQ9ITE7U2suZmlsZXNMb2FkZWQ9ITE7U2suc3lzbW9kdWxlcz1uZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtTay5yZWFsc3lzcGF0aD12b2lkIDA7U2sucmVzZXRDb21waWxlcigpO3JldHVybiBTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oYixlLFwiX19tYWluX19cIixkLHZvaWQgMCwhMSxmKX07U2suaW1wb3J0QnVpbHRpbldpdGhCb2R5PVxuZnVuY3Rpb24oYixlLGQsZil7cmV0dXJuIFNrLmltcG9ydE1vZHVsZUludGVybmFsXyhiLGUsXCJfX2J1aWx0aW5fXy5cIitiLGQsdm9pZCAwLCExLGYpfTtTay5idWlsdGluLl9faW1wb3J0X189ZnVuY3Rpb24oYixlLGQsZixoKXtiPWIudG9TdHJpbmcoKTt2YXIgcD1Tay5nbG9iYWxzLGc7bnVsbD09aCYmKGg9U2suX19mdXR1cmVfXy5hYnNvbHV0ZV9pbXBvcnQ/MDotMSk7aWYoMCE9PWgmJmUuX19wYWNrYWdlX18mJmUuX19wYWNrYWdlX18hPT1Tay5idWlsdGluLm5vbmUubm9uZSQpe2lmKChnPWUuX19wYWNrYWdlX18udikmJjA8aCl7ZT1nLnNwbGl0KFwiLlwiKTtpZihoLTE+PWUubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLkltcG9ydEVycm9yKFwiQXR0ZW1wdGVkIHJlbGF0aXZlIGltcG9ydCBiZXlvbmQgdG9wbGV2ZWwgcGFja2FnZVwiKTtlLmxlbmd0aC09aC0xO2c9ZS5qb2luKFwiLlwiKX12YXIgYT1Tay5zeXNtb2R1bGVzLnF1aWNrJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoZykpfWlmKDA8XG5oJiZ2b2lkIDA9PT1hKXRocm93IG5ldyBTay5idWlsdGluLkltcG9ydEVycm9yKFwiQXR0ZW1wdGVkIHJlbGF0aXZlIGltcG9ydCBpbiBub24tcGFja2FnZVwiKTtiLnNwbGl0KFwiLlwiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odm9pZCAwLGZ1bmN0aW9uKCl7aWYoMCE9PWgmJnZvaWQgMCE9PWEpcmV0dXJuXCJcIj09PWI/YTpTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oYix2b2lkIDAsZytcIi5cIitiLHZvaWQgMCxhLC0xPT1oLCEwKX0sZnVuY3Rpb24oYyl7cmV0dXJuIHZvaWQgMD09PWM/KGc9YT12b2lkIDAsU2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKGIsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLCExLCEwKSk6Y30sZnVuY3Rpb24oYyl7aWYoZiYmMCE9PWYubGVuZ3RoKXtjPVtudWxsXTtjb25zdCBuPVNrLnN5c21vZHVsZXMubXAkc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cigoZ3x8XCJcIikrKGcmJmI/XCIuXCI6XCJcIikrYikpO2ZvcihsZXQgbT0wO208Zi5sZW5ndGg7bSsrKXtjb25zdCBrPVxuZlttXTtcIipcIiE9PWsmJnZvaWQgMD09PW4udHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoaykpJiZjLnB1c2goKCk9PlNrLmltcG9ydE1vZHVsZUludGVybmFsXyhrLHZvaWQgMCx2b2lkIDAsdm9pZCAwLG4sITAsITApKX1yZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oLi4uYyxmdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KG4pO3JldHVybiBufSl9cmV0dXJuIGN9LGZ1bmN0aW9uKGMpe3AhPT1Tay5nbG9iYWxzJiYoU2suZ2xvYmFscz1wKTtyZXR1cm4gY30pfTtTay5pbXBvcnRTdGFyPWZ1bmN0aW9uKGIsZSxkKXtpZihkPWIudHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXCJfX2FsbF9fXCIpKSlmb3IobGV0IGY9U2suYWJzdHIuaXRlcihkKSxoPWYudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1oO2g9Zi50cCRpdGVybmV4dCgpKWVbaC52XT1Tay5hYnN0ci5nYXR0cihiLGgpO2Vsc2V7ZD1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiLiRkKTtmb3IobGV0IGYgaW4gZClcIl9cIiE9XG5kW2ZdLmNoYXJBdCgwKSYmKGVbZFtmXV09Yi4kZFtkW2ZdXSl9fTtTay5leHBvcnRTeW1ib2woXCJTay5pbXBvcnRNYWluXCIsU2suaW1wb3J0TWFpbik7U2suZXhwb3J0U3ltYm9sKFwiU2suaW1wb3J0TWFpbldpdGhCb2R5XCIsU2suaW1wb3J0TWFpbldpdGhCb2R5KTtTay5leHBvcnRTeW1ib2woXCJTay5pbXBvcnRCdWlsdGluV2l0aEJvZHlcIixTay5pbXBvcnRCdWlsdGluV2l0aEJvZHkpO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uX19pbXBvcnRfX1wiLFNrLmJ1aWx0aW4uX19pbXBvcnRfXyk7U2suZXhwb3J0U3ltYm9sKFwiU2suaW1wb3J0U3RhclwiLFNrLmltcG9ydFN0YXIpfSxmdW5jdGlvbihGLFApe1NrLmJ1aWx0aW4udGltU29ydD1mdW5jdGlvbihiLGUpe3RoaXMubGlzdD1uZXcgU2suYnVpbHRpbi5saXN0KGIudik7dGhpcy5NSU5fR0FMTE9QPTc7dGhpcy5saXN0bGVuZ3RoPWU/ZTpiLnNxJGxlbmd0aCgpfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmx0PWZ1bmN0aW9uKGIsXG5lKXtyZXR1cm4gU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGIsZSxcIkx0XCIpfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmxlPWZ1bmN0aW9uKGIsZSl7cmV0dXJuIXRoaXMubHQoZSxiKX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5zZXRpdGVtPWZ1bmN0aW9uKGIsZSl7dGhpcy5saXN0LnZbYl09ZX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5iaW5hcnlfc29ydD1mdW5jdGlvbihiLGUpe3ZhciBkO2ZvcihkPWIuYmFzZStlO2Q8Yi5iYXNlK2IubGVuO2QrKyl7dmFyIGY9Yi5iYXNlO3ZhciBoPWQ7Zm9yKGU9Yi5nZXRpdGVtKGgpO2Y8aDspe3ZhciBwPWYrKGgtZj4+MSk7dGhpcy5sdChlLGIuZ2V0aXRlbShwKSk/aD1wOmY9cCsxfVNrLmFzc2VydHMuYXNzZXJ0KGY9PT1oKTtmb3IocD1kO3A+ZjtwLS0pYi5zZXRpdGVtKHAsYi5nZXRpdGVtKHAtMSkpO2Iuc2V0aXRlbShmLGUpfX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5jb3VudF9ydW49XG5mdW5jdGlvbihiKXt2YXIgZTtpZigxPj1iLmxlbil7dmFyIGQ9Yi5sZW47dmFyIGY9ITF9ZWxzZSBpZihkPTIsdGhpcy5sdChiLmdldGl0ZW0oYi5iYXNlKzEpLGIuZ2V0aXRlbShiLmJhc2UpKSlmb3IoZj0hMCxlPWIuYmFzZSsyO2U8Yi5iYXNlK2IubGVuO2UrKylpZih0aGlzLmx0KGIuZ2V0aXRlbShlKSxiLmdldGl0ZW0oZS0xKSkpZCsrO2Vsc2UgYnJlYWs7ZWxzZSBmb3IoZj0hMSxlPWIuYmFzZSsyO2U8Yi5iYXNlK2IubGVuJiYhdGhpcy5sdChiLmdldGl0ZW0oZSksYi5nZXRpdGVtKGUtMSkpO2UrKylkKys7cmV0dXJue3J1bjpuZXcgU2suYnVpbHRpbi5saXN0U2xpY2UoYi5saXN0LGIuYmFzZSxkKSxkZXNjZW5kaW5nOmZ9fTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLnNvcnQ9ZnVuY3Rpb24oKXt2YXIgYixlPW5ldyBTay5idWlsdGluLmxpc3RTbGljZSh0aGlzLmxpc3QsMCx0aGlzLmxpc3RsZW5ndGgpO2lmKCEoMj5lLmxlbikpe3RoaXMubWVyZ2VfaW5pdCgpO2ZvcihiPVxudGhpcy5tZXJnZV9jb21wdXRlX21pbnJ1bihlLmxlbik7MDxlLmxlbjspe3ZhciBkPXRoaXMuY291bnRfcnVuKGUpO2QuZGVzY2VuZGluZyYmZC5ydW4ucmV2ZXJzZSgpO2lmKGQucnVuLmxlbjxiKXt2YXIgZj1kLnJ1bi5sZW47ZC5ydW4ubGVuPWI8ZS5sZW4/YjplLmxlbjt0aGlzLmJpbmFyeV9zb3J0KGQucnVuLGYpfWUuYWR2YW5jZShkLnJ1bi5sZW4pO3RoaXMucGVuZGluZy5wdXNoKGQucnVuKTt0aGlzLm1lcmdlX2NvbGxhcHNlKCl9U2suYXNzZXJ0cy5hc3NlcnQoZS5iYXNlPT10aGlzLmxpc3RsZW5ndGgpO3RoaXMubWVyZ2VfZm9yY2VfY29sbGFwc2UoKTtTay5hc3NlcnRzLmFzc2VydCgxPT10aGlzLnBlbmRpbmcubGVuZ3RoKTtTay5hc3NlcnRzLmFzc2VydCgwPT09dGhpcy5wZW5kaW5nWzBdLmJhc2UpO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMucGVuZGluZ1swXS5sZW49PXRoaXMubGlzdGxlbmd0aCl9fTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmdhbGxvcD1mdW5jdGlvbihiLFxuZSxkLGYpe3ZhciBoO1NrLmFzc2VydHMuYXNzZXJ0KDA8PWQmJmQ8ZS5sZW4pO3ZhciBwPXRoaXM7Zj1mP2Z1bmN0aW9uKG4sbSl7cmV0dXJuIHAubGUobixtKX06ZnVuY3Rpb24obixtKXtyZXR1cm4gcC5sdChuLG0pfTt2YXIgZz1lLmJhc2UrZDt2YXIgYT0wO3ZhciBjPTE7aWYoZihlLmdldGl0ZW0oZyksYikpe2ZvcihoPWUubGVuLWQ7YzxoOylpZihmKGUuZ2V0aXRlbShnK2MpLGIpKXthPWM7dHJ5e2M9KGM8PDEpKzF9Y2F0Y2gobil7Yz1ofX1lbHNlIGJyZWFrO2M+aCYmKGM9aCk7YSs9ZDtjKz1kfWVsc2V7Zm9yKGg9ZCsxO2M8aCYmIWYoZS5nZXRpdGVtKGctYyksYik7KXthPWM7dHJ5e2M9KGM8PDEpKzF9Y2F0Y2gobil7Yz1ofX1jPmgmJihjPWgpO2c9ZC1hO2E9ZC1jO2M9Z31Tay5hc3NlcnRzLmFzc2VydCgtMTw9YTxjPD1lLmxlbik7Zm9yKGErPTE7YTxjOylkPWErKGMtYT4+MSksZihlLmdldGl0ZW0oZS5iYXNlK2QpLGIpP2E9ZCsxOmM9ZDtTay5hc3NlcnRzLmFzc2VydChhPT1cbmMpO3JldHVybiBjfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2luaXQ9ZnVuY3Rpb24oKXt0aGlzLm1pbl9nYWxsb3A9dGhpcy5NSU5fR0FMTE9QO3RoaXMucGVuZGluZz1bXX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5tZXJnZV9sbz1mdW5jdGlvbihiLGUpe3ZhciBkLGYsaDtTay5hc3NlcnRzLmFzc2VydCgwPGIubGVuJiYwPGUubGVuJiZiLmJhc2UrYi5sZW49PWUuYmFzZSk7dmFyIHA9dGhpcy5taW5fZ2FsbG9wO3ZhciBnPWIuYmFzZTtiPWIuY29weWl0ZW1zKCk7dHJ5e2lmKHRoaXMuc2V0aXRlbShnLGUucG9wbGVmdCgpKSxnKyssMSE9Yi5sZW4mJjAhPT1lLmxlbilmb3IoOzspe2ZvcihmPWQ9MDs7KWlmKHRoaXMubHQoZS5nZXRpdGVtKGUuYmFzZSksYi5nZXRpdGVtKGIuYmFzZSkpKXt0aGlzLnNldGl0ZW0oZyxlLnBvcGxlZnQoKSk7ZysrO2lmKDA9PT1lLmxlbilyZXR1cm47ZisrO2Q9MDtpZihmPj1wKWJyZWFrfWVsc2V7dGhpcy5zZXRpdGVtKGcsXG5iLnBvcGxlZnQoKSk7ZysrO2lmKDE9PWIubGVuKXJldHVybjtkKys7Zj0wO2lmKGQ+PXApYnJlYWt9Zm9yKHArPTE7Oyl7dGhpcy5taW5fZ2FsbG9wPXAtPTE8cDtkPXRoaXMuZ2FsbG9wKGUuZ2V0aXRlbShlLmJhc2UpLGIsMCwhMCk7Zm9yKGg9Yi5iYXNlO2g8Yi5iYXNlK2Q7aCsrKXRoaXMuc2V0aXRlbShnLGIuZ2V0aXRlbShoKSksZysrO2IuYWR2YW5jZShkKTtpZigxPj1iLmxlbilyZXR1cm47dGhpcy5zZXRpdGVtKGcsZS5wb3BsZWZ0KCkpO2crKztpZigwPT09ZS5sZW4pcmV0dXJuO2Y9dGhpcy5nYWxsb3AoYi5nZXRpdGVtKGIuYmFzZSksZSwwLCExKTtmb3IoaD1lLmJhc2U7aDxlLmJhc2UrZjtoKyspdGhpcy5zZXRpdGVtKGcsZS5nZXRpdGVtKGgpKSxnKys7ZS5hZHZhbmNlKGYpO2lmKDA9PT1lLmxlbilyZXR1cm47dGhpcy5zZXRpdGVtKGcsYi5wb3BsZWZ0KCkpO2crKztpZigxPT1iLmxlbilyZXR1cm47aWYoZDx0aGlzLk1JTl9HQUxMT1AmJmY8dGhpcy5NSU5fR0FMTE9QKWJyZWFrO1xucCsrO3RoaXMubWluX2dhbGxvcD1wfX19ZmluYWxseXtTay5hc3NlcnRzLmFzc2VydCgwPD1iLmxlbiYmMDw9ZS5sZW4pO2ZvcihoPWUuYmFzZTtoPGUuYmFzZStlLmxlbjtoKyspdGhpcy5zZXRpdGVtKGcsZS5nZXRpdGVtKGgpKSxnKys7Zm9yKGg9Yi5iYXNlO2g8Yi5iYXNlK2IubGVuO2grKyl0aGlzLnNldGl0ZW0oZyxiLmdldGl0ZW0oaCkpLGcrK319O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfaGk9ZnVuY3Rpb24oYixlKXt2YXIgZCxmLGg7U2suYXNzZXJ0cy5hc3NlcnQoMDxiLmxlbiYmMDxlLmxlbiYmYi5iYXNlK2IubGVuPT1lLmJhc2UpO3ZhciBwPXRoaXMubWluX2dhbGxvcDt2YXIgZz1lLmJhc2UrZS5sZW47ZT1lLmNvcHlpdGVtcygpO3RyeXtpZihnLS0sdGhpcy5zZXRpdGVtKGcsYi5wb3ByaWdodCgpKSwwIT09Yi5sZW4mJjEhPWUubGVuKWZvcig7Oyl7Zm9yKGY9ZD0wOzspe3ZhciBhPWIuZ2V0aXRlbShiLmJhc2UrYi5sZW4tMSk7dmFyIGM9ZS5nZXRpdGVtKGUuYmFzZStcbmUubGVuLTEpO2lmKHRoaXMubHQoYyxhKSl7Zy0tO3RoaXMuc2V0aXRlbShnLGEpO2IubGVuLS07aWYoMD09PWIubGVuKXJldHVybjtkKys7Zj0wO2lmKGQ+PXApYnJlYWt9ZWxzZXtnLS07dGhpcy5zZXRpdGVtKGcsYyk7ZS5sZW4tLTtpZigxPT1lLmxlbilyZXR1cm47ZisrO2Q9MDtpZihmPj1wKWJyZWFrfX1mb3IocCs9MTs7KXt0aGlzLm1pbl9nYWxsb3A9cC09MTxwO2M9ZS5nZXRpdGVtKGUuYmFzZStlLmxlbi0xKTt2YXIgbj10aGlzLmdhbGxvcChjLGIsYi5sZW4tMSwhMCk7ZD1iLmxlbi1uO2ZvcihoPWIuYmFzZStiLmxlbi0xO2g+Yi5iYXNlK24tMTtoLS0pZy0tLHRoaXMuc2V0aXRlbShnLGIuZ2V0aXRlbShoKSk7Yi5sZW4tPWQ7aWYoMD09PWIubGVuKXJldHVybjtnLS07dGhpcy5zZXRpdGVtKGcsZS5wb3ByaWdodCgpKTtpZigxPT1lLmxlbilyZXR1cm47YT1iLmdldGl0ZW0oYi5iYXNlK2IubGVuLTEpO249dGhpcy5nYWxsb3AoYSxlLGUubGVuLTEsITEpO2Y9ZS5sZW4tbjtcbmZvcihoPWUuYmFzZStlLmxlbi0xO2g+ZS5iYXNlK24tMTtoLS0pZy0tLHRoaXMuc2V0aXRlbShnLGUuZ2V0aXRlbShoKSk7ZS5sZW4tPWY7aWYoMT49ZS5sZW4pcmV0dXJuO2ctLTt0aGlzLnNldGl0ZW0oZyxiLnBvcHJpZ2h0KCkpO2lmKDA9PT1iLmxlbilyZXR1cm47aWYoZDx0aGlzLk1JTl9HQUxMT1AmJmY8dGhpcy5NSU5fR0FMTE9QKWJyZWFrO3ArKzt0aGlzLm1pbl9nYWxsb3A9cH19fWZpbmFsbHl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9Yi5sZW4mJjA8PWUubGVuKTtmb3IoaD1iLmJhc2UrYi5sZW4tMTtoPmIuYmFzZS0xO2gtLSlnLS0sdGhpcy5zZXRpdGVtKGcsYi5nZXRpdGVtKGgpKTtmb3IoaD1lLmJhc2UrZS5sZW4tMTtoPmUuYmFzZS0xO2gtLSlnLS0sdGhpcy5zZXRpdGVtKGcsZS5nZXRpdGVtKGgpKX19O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfYXQ9ZnVuY3Rpb24oYil7MD5iJiYoYj10aGlzLnBlbmRpbmcubGVuZ3RoK2IpO3ZhciBlPXRoaXMucGVuZGluZ1tiXTtcbnZhciBkPXRoaXMucGVuZGluZ1tiKzFdO1NrLmFzc2VydHMuYXNzZXJ0KDA8ZS5sZW4mJjA8ZC5sZW4pO1NrLmFzc2VydHMuYXNzZXJ0KGUuYmFzZStlLmxlbj09ZC5iYXNlKTt0aGlzLnBlbmRpbmdbYl09bmV3IFNrLmJ1aWx0aW4ubGlzdFNsaWNlKHRoaXMubGlzdCxlLmJhc2UsZS5sZW4rZC5sZW4pO3RoaXMucGVuZGluZy5zcGxpY2UoYisxLDEpO2I9dGhpcy5nYWxsb3AoZC5nZXRpdGVtKGQuYmFzZSksZSwwLCEwKTtlLmFkdmFuY2UoYik7MCE9PWUubGVuJiYoZC5sZW49dGhpcy5nYWxsb3AoZS5nZXRpdGVtKGUuYmFzZStlLmxlbi0xKSxkLGQubGVuLTEsITEpLDAhPT1kLmxlbiYmKGUubGVuPD1kLmxlbj90aGlzLm1lcmdlX2xvKGUsZCk6dGhpcy5tZXJnZV9oaShlLGQpKSl9O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfY29sbGFwc2U9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5wZW5kaW5nOzE8Yi5sZW5ndGg7KWlmKDM8PWIubGVuZ3RoJiZiW2IubGVuZ3RoLVxuM10ubGVuPD1iW2IubGVuZ3RoLTJdLmxlbitiW2IubGVuZ3RoLTFdLmxlbiliW2IubGVuZ3RoLTNdLmxlbjxiW2IubGVuZ3RoLTFdLmxlbj90aGlzLm1lcmdlX2F0KC0zKTp0aGlzLm1lcmdlX2F0KC0yKTtlbHNlIGlmKGJbYi5sZW5ndGgtMl0ubGVuPD1iW2IubGVuZ3RoLTFdLmxlbil0aGlzLm1lcmdlX2F0KC0yKTtlbHNlIGJyZWFrfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2ZvcmNlX2NvbGxhcHNlPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPXRoaXMucGVuZGluZzsxPGIubGVuZ3RoOykzPD1iLmxlbmd0aCYmYltiLmxlbmd0aC0zXS5sZW48YltiLmxlbmd0aC0xXS5sZW4/dGhpcy5tZXJnZV9hdCgtMyk6dGhpcy5tZXJnZV9hdCgtMil9O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfY29tcHV0ZV9taW5ydW49ZnVuY3Rpb24oYil7Zm9yKHZhciBlPTA7NjQ8PWI7KWV8PWImMSxiPj49MTtyZXR1cm4gYitlfTtTay5idWlsdGluLmxpc3RTbGljZT1mdW5jdGlvbihiLFxuZSxkKXt0aGlzLmxpc3Q9Yjt0aGlzLmJhc2U9ZTt0aGlzLmxlbj1kfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUuY29weWl0ZW1zPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5iYXNlLGU9dGhpcy5iYXNlK3RoaXMubGVuO1NrLmFzc2VydHMuYXNzZXJ0KDA8PWI8PWUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0U2xpY2UobmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLmxpc3Qudi5zbGljZShiLGUpKSwwLHRoaXMubGVuKX07U2suYnVpbHRpbi5saXN0U2xpY2UucHJvdG90eXBlLmFkdmFuY2U9ZnVuY3Rpb24oYil7dGhpcy5iYXNlKz1iO3RoaXMubGVuLT1iO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMuYmFzZTw9dGhpcy5saXN0LnNxJGxlbmd0aCgpKX07U2suYnVpbHRpbi5saXN0U2xpY2UucHJvdG90eXBlLmdldGl0ZW09ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMubGlzdC52W2JdfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUuc2V0aXRlbT1mdW5jdGlvbihiLGUpe3RoaXMubGlzdC52W2JdPVxuZX07U2suYnVpbHRpbi5saXN0U2xpY2UucHJvdG90eXBlLnBvcGxlZnQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmxpc3Qudlt0aGlzLmJhc2VdO3RoaXMuYmFzZSsrO3RoaXMubGVuLS07cmV0dXJuIGJ9O1NrLmJ1aWx0aW4ubGlzdFNsaWNlLnByb3RvdHlwZS5wb3ByaWdodD1mdW5jdGlvbigpe3RoaXMubGVuLS07cmV0dXJuIHRoaXMubGlzdC52W3RoaXMuYmFzZSt0aGlzLmxlbl19O1NrLmJ1aWx0aW4ubGlzdFNsaWNlLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKCl7Zm9yKHZhciBiLGUsZD10aGlzLmxpc3QsZj10aGlzLmJhc2UsaD1mK3RoaXMubGVuLTE7ZjxoOyliPWQudltoXSxlPWQudltmXSxkLnZbZl09YixkLnZbaF09ZSxmKyssaC0tfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmxpc3RTbGljZVwiLFNrLmJ1aWx0aW4ubGlzdFNsaWNlKTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLnRpbVNvcnRcIixTay5idWlsdGluLnRpbVNvcnQpfSxmdW5jdGlvbihGLFApe1NrLmJ1aWx0aW4uc3VwZXJfPVxuU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInN1cGVyXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3VwZXJfLFwiYmFkIGNhbGwgdG8gc3VwZXIsIHVzZSAnbmV3J1wiKTt0aGlzLnR5cGU9Yjt0aGlzLm9iaj1lO2lmKHZvaWQgMCE9PWImJiFTay5idWlsdGluLmNoZWNrQ2xhc3MoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibXVzdCBiZSB0eXBlLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYikpO3RoaXMub2JqX3R5cGU9dm9pZCAwIT09dGhpcy5vYmo/dGhpcy4kc3VwZXJjaGVjayhiLHRoaXMub2JqKTpudWxsfSxzbG90czp7dHAkZG9jOlwic3VwZXIoKSAtPiBzYW1lIGFzIHN1cGVyKF9fY2xhc3NfXywgPGZpcnN0IGFyZ3VtZW50PilcXG5zdXBlcih0eXBlKSAtPiB1bmJvdW5kIHN1cGVyIG9iamVjdFxcbnN1cGVyKHR5cGUsIG9iaikgLT4gYm91bmQgc3VwZXIgb2JqZWN0OyByZXF1aXJlcyBpc2luc3RhbmNlKG9iaiwgdHlwZSlcXG5zdXBlcih0eXBlLCB0eXBlMikgLT4gYm91bmQgc3VwZXIgb2JqZWN0OyByZXF1aXJlcyBpc3N1YmNsYXNzKHR5cGUyLCB0eXBlKVxcblR5cGljYWwgdXNlIHRvIGNhbGwgYSBjb29wZXJhdGl2ZSBzdXBlcmNsYXNzIG1ldGhvZDpcXG5jbGFzcyBDKEIpOlxcbiAgICBkZWYgbWV0aChzZWxmLCBhcmcpOlxcbiAgICAgICAgc3VwZXIoKS5tZXRoKGFyZylcXG5UaGlzIHdvcmtzIGZvciBjbGFzcyBtZXRob2RzIHRvbzpcXG5jbGFzcyBDKEIpOlxcbiAgICBAY2xhc3NtZXRob2RcXG4gICAgZGVmIGNtZXRoKGNscywgYXJnKTpcXG4gICAgICAgIHN1cGVyKCkuY21ldGgoYXJnKVxcblwiLFxudHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYixlKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic3VwZXJcIixlKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJzdXBlclwiLGIsMSwyKTtlPWJbMF07Yj1iWzFdO2lmKCFTay5idWlsdGluLmNoZWNrQ2xhc3MoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibXVzdCBiZSB0eXBlLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZSkpO3RoaXMub2JqPWI7dGhpcy50eXBlPWU7bnVsbCE9dGhpcy5vYmomJih0aGlzLm9ial90eXBlPXRoaXMuJHN1cGVyY2hlY2soZSx0aGlzLm9iaikpfSwkcigpe3JldHVybiB0aGlzLm9iaj9uZXcgU2suYnVpbHRpbi5zdHIoXCI8c3VwZXI6IDxjbGFzcyAnXCIrdGhpcy50eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJz4sIDxcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzLm9iaikrXCIgb2JqZWN0Pj5cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFwiPHN1cGVyOiA8Y2xhc3MgJ1wiK3RoaXMudHlwZS5wcm90b3R5cGUudHAkbmFtZStcblwiJz4sIE5VTEw+XCIpfSx0cCRnZXRhdHRyKGIsZSl7bGV0IGQ9dGhpcy5vYmpfdHlwZTtpZihudWxsPT1kKXJldHVybiBTay5nZW5lcmljLmdldEF0dHIuY2FsbCh0aGlzLGIsZSk7dmFyIGY9ZC5wcm90b3R5cGUudHAkbXJvO2NvbnN0IGg9Zi5sZW5ndGg7aWYoYj09PVNrLmJ1aWx0aW4uc3RyLiRjbGFzcylyZXR1cm4gU2suZ2VuZXJpYy5nZXRBdHRyLmNhbGwodGhpcyxiLGUpO2xldCBwO2ZvcihwPTA7cCsxPGgmJnRoaXMudHlwZSE9PWZbcF07cCsrKTtwKys7aWYocD49aClyZXR1cm4gU2suZ2VuZXJpYy5nZXRBdHRyLmNhbGwodGhpcyxiLGUpO2I9Yi4kbWFuZ2xlZDtsZXQgZztmb3IoO3A8aDspe2U9ZltwXS5wcm90b3R5cGU7ZS5oYXNPd25Qcm9wZXJ0eShiKSYmKGc9ZVtiXSk7aWYodm9pZCAwIT09ZylyZXR1cm4gZj1nLnRwJGRlc2NyX2dldCx2b2lkIDAhPT1mJiYoZz1mLmNhbGwoZyx0aGlzLm9iaj09PWQ/bnVsbDp0aGlzLm9iaixkKSksZztwKyt9fSx0cCRkZXNjcl9nZXQoYixcbmUsZCl7aWYobnVsbD09PWJ8fG51bGwhPXRoaXMub2JqKXJldHVybiB0aGlzO2lmKHRoaXMub2IkdHlwZSE9PVNrLmJ1aWx0aW4uc3VwZXJfKXJldHVybiBiPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLm9iJHR5cGUsW3RoaXMudHlwZSxiXSksZD9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKTtkPXRoaXMuJHN1cGVyY2hlY2sodGhpcy50eXBlLGIpO2U9bmV3IFNrLmJ1aWx0aW4uc3VwZXJfO2UudHlwZT10aGlzLnR5cGU7ZS5vYmo9YjtlLm9ial90eXBlPWQ7cmV0dXJuIGV9fSxnZXRzZXRzOntfX3RoaXNjbGFzc19fOnskZ2V0KCl7cmV0dXJuIHRoaXMudHlwZX0sJGRvYzpcInRoZSBjbGFzcyBpbnZva2luZyBzdXBlcigpXCJ9LF9fc2VsZl9fOnskZ2V0KCl7cmV0dXJuIHRoaXMub2JqfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRkb2M6XCJ0aGUgaW5zdGFuY2UgaW52b2tpbmcgc3VwZXIoKTsgbWF5IGJlIE5vbmVcIn0sX19zZWxmX2NsYXNzX186eyRnZXQoKXtyZXR1cm4gdGhpcy5vYmpfdHlwZXx8XG5Tay5idWlsdGluLm5vbmUubm9uZSR9LCRkb2M6XCJ0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgaW52b2tpbmcgc3VwZXIoKTsgbWF5IGJlIE5vbmVcIn19LHByb3RvOnskc3VwZXJjaGVjayhiLGUpe2lmKFNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhlKSYmZS4kaXNTdWJUeXBlKGIpKXJldHVybiBlO2lmKGUub2IkdHlwZS4kaXNTdWJUeXBlKGIpKXJldHVybiBlLm9iJHR5cGU7e2NvbnN0IGQ9ZS50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRjbGFzcyk7aWYodm9pZCAwIT09ZCYmZCE9PWUub2IkdHlwZSYmU2suYnVpbHRpbi5jaGVja0NsYXNzKGQpJiZkLiRpc1N1YlR5cGUoYikpcmV0dXJuIGR9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic3VwZXIodHlwZSwgb2JqKTogb2JqIG11c3QgYmUgYW4gaW5zdGFuY2Ugb3Igc3VidHlwZSBvZiB0eXBlXCIpO319fSl9LGZ1bmN0aW9uKEYsUCl7U2suYnVpbHRpbi5HZW5lcmljQWxpYXM9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInR5cGVzLkdlbmVyaWNBbGlhc1wiLFxue2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGIsZSl7dGhpcy4kb3JpZ2luPWI7ZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGV8fChlPW5ldyBTay5idWlsdGluLnR1cGxlKFtlXSkpO3RoaXMuJGFyZ3M9ZTt0aGlzLiRwYXJhbXM9bnVsbH0sc2xvdHM6e3RwJG5ldyhiLGUpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJHZW5lcmljQWxpYXNcIixlKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJHZW5lcmljQWxpYXNcIixiLDIsMik7cmV0dXJuIG5ldyBTay5idWlsdGluLkdlbmVyaWNBbGlhcyhiWzBdLGJbMV0pfSx0cCRnZXRhdHRyKGIsZSl7cmV0dXJuIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikmJiF0aGlzLmF0dHIkZXhjLmluY2x1ZGVzKGIpP3RoaXMuJG9yaWdpbi50cCRnZXRhdHRyKGIsZSk6U2suZ2VuZXJpYy5nZXRBdHRyLmNhbGwodGhpcyxiLGUpfSwkcigpe2NvbnN0IGI9dGhpcy5nYSRyZXByKHRoaXMuJG9yaWdpbik7bGV0IGU9XCJcIjt0aGlzLiRhcmdzLnYuZm9yRWFjaCgoZCxmKT0+XG57ZSs9MDxmP1wiLCBcIjpcIlwiO2UrPXRoaXMuZ2EkcmVwcihkKX0pO2V8fChlPVwiKClcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihiK1wiW1wiK2UrXCJdXCIpfSx0cCRkb2M6XCJSZXByZXNlbnQgYSBQRVAgNTg1IGdlbmVyaWMgdHlwZVxcblxcbkUuZy4gZm9yIHQgPSBsaXN0W2ludF0sIHQub3JpZ2luIGlzIGxpc3QgYW5kIHQuYXJncyBpcyAoaW50LCkuXCIsdHAkaGFzaCgpe2NvbnN0IGI9U2suYWJzdHIub2JqZWN0SGFzaCh0aGlzLiRvcmlnaW4pO2lmKC0xPT1iKXJldHVybi0xO2NvbnN0IGU9U2suYWJzdHIub2JqZWN0SGFzaCh0aGlzLiRhcmdzKTtyZXR1cm4tMT09ZT8tMTpiXmV9LHRwJGNhbGwoYixlKXtiPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLiRvcmlnaW4sYixlKTt0cnl7Yi50cCRzZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcIl9fb3JpZ19jbGFzc19fXCIpLHRoaXMpfWNhdGNoKGQpe2lmKCEoZCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3J8fGQgaW5zdGFuY2VvZlxuU2suYnVpbHRpbi5UeXBlRXJyb3IpKXRocm93IGQ7fXJldHVybiBifSx0cCRyaWNoY29tcGFyZShiLGUpe2lmKCEoYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uR2VuZXJpY0FsaWFzKXx8XCJFcVwiIT09ZSYmXCJOb3RFcVwiIT09ZSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3QgZD1Tay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy4kb3JpZ2luLGIuJG9yaWdpbixcIkVxXCIpO2lmKCFkKXJldHVyblwiRXFcIj09PWU/ZDohZDtiPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLiRhcmdzLGIuJGFyZ3MsXCJFcVwiKTtyZXR1cm5cIkVxXCI9PT1lP2I6IWJ9LHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsbXAkc3Vic2NyaXB0KGIpe251bGw9PT10aGlzLiRwYXJhbXMmJnRoaXMubWskcGFyYW1zKCk7aWYoMD09PXRoaXMuJHBhcmFtcy5zcSRsZW5ndGgoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJUaGVyZSBhcmUgbm8gdHlwZSB2YXJpYWJsZXMgbGVmdCBpbiBcIitcblNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcykpO319LG1ldGhvZHM6e19fbXJvX2VudHJpZXNfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW3RoaXMuJG9yaWdpbl0pfSwkZmxhZ3M6e05vQXJnczohMH19LF9faW5zdGFuY2VjaGVja19fOnskbWV0aChiKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpc2luc3RhbmNlKCkgYXJndW1lbnQgMiBjYW5ub3QgYmUgYSBwYXJhbWV0ZXJpemVkIGdlbmVyaWNcIik7fSwkZmxhZ3M6e09uZUFyZzohMH19LF9fc3ViY2xhc3NjaGVja19fOnskbWV0aChiKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpc3N1YmNsYXNzKCkgYXJndW1lbnQgMiBjYW5ub3QgYmUgYSBwYXJhbWV0ZXJpemVkIGdlbmVyaWNcIik7fSwkZmxhZ3M6e09uZUFyZzohMH19fSxnZXRzZXRzOntfX3BhcmFtZXRlcnNfXzp7JGdldCgpe251bGw9PT10aGlzLiRwYXJhbXMmJnRoaXMubWskcGFyYW1zKCk7cmV0dXJuIHRoaXMuJHBhcmFtc30sXG4kZG9jOlwiVHlwZSB2YXJpYWJsZXMgaW4gdGhlIEdlbmVyaWNBbGlhcy5cIn0sX19vcmlnaW5fXzp7JGdldCgpe3JldHVybiB0aGlzLiRvcmlnaW59fSxfX2FyZ3NfXzp7JGdldCgpe3JldHVybiB0aGlzLiRhcmdzfX19LHByb3RvOnttayRwYXJhbXMoKXtjb25zdCBiPVtdO3RoaXMuJGFyZ3Mudi5mb3JFYWNoKGU9Pnt0aGlzLmlzJHR5cGV2YXIoZSkmJjA+dGhpcy50dXBsZSRpbmRleChiLGUpJiZiLnB1c2goZSl9KTt0aGlzLiRwYXJhbXM9bmV3IFNrLmJ1aWx0aW4udHVwbGUoYil9LHR1cGxlJGluZGV4KGIsZSl7cmV0dXJuIGIuaW5kZXhPZihlKX0saXMkdHlwZXZhcihiKXtpZihcIlR5cGVWYXJcIiE9PWIudHAkbmFtZSlyZXR1cm4hMTtiPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYixTay5idWlsdGluLnN0ci4kbW9kdWxlKTtpZih2b2lkIDA9PT1iKXRocm93IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKFwiZm91bmQgb2JqZWN0IHdpdGhvdWdodCBhIF9fbW9kdWxlX19cIik7cmV0dXJuXCJ0eXBpbmdcIj09PVxuYi50b1N0cmluZygpfSxnYSRyZXByKGIpe2lmKGI9PT1Tay5idWlsdGluLkVsbGlwc2lzKXJldHVyblwiLi4uXCI7aWYoU2suYWJzdHIubG9va3VwU3BlY2lhbChiLHRoaXMuc3RyJG9yaWcpJiZTay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsdGhpcy5zdHIkYXJncykpcmV0dXJuIFNrLm1pc2NldmFsLm9iamVjdFJlcHIoYik7Y29uc3QgZT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsU2suYnVpbHRpbi5zdHIuJHF1YWxuYW1lKTtpZih2b2lkIDA9PT1lKXJldHVybiBTay5taXNjZXZhbC5vYmplY3RSZXByKGIpO2NvbnN0IGQ9U2suYWJzdHIubG9va3VwU3BlY2lhbChiLFNrLmJ1aWx0aW4uc3RyLiRtb2R1bGUpO3JldHVybiB2b2lkIDA9PT1kfHxTay5idWlsdGluLmNoZWNrTm9uZShkKT9Tay5taXNjZXZhbC5vYmplY3RSZXByKGIpOlwiYnVpbHRpbnNcIj09PWQudG9TdHJpbmcoKT9lLnRvU3RyaW5nKCk6ZC50b1N0cmluZygpK1wiLlwiK2UudG9TdHJpbmcoKX0sc3RyJG9yaWc6bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19vcmlnaW5fX1wiKSxcbnN0ciRhcmdzOm5ldyBTay5idWlsdGluLnN0cihcIl9fYXJnc19fXCIpLGF0dHIkZXhjOlwiX19vcmlnaW5fXyBfX2FyZ3NfXyBfX3BhcmFtZXRlcnNfXyBfX21yb19lbnRyaWVzX18gX19yZWR1Y2VfZXhfXyBfX3JlZHVjZV9fXCIuc3BsaXQoXCIgXCIpLm1hcChiPT5uZXcgU2suYnVpbHRpbi5zdHIoYikpfX0pfSxmdW5jdGlvbihGLFApe2Z1bmN0aW9uIGIoZixoKXtsZXQgcD12b2lkIDA7aWYodm9pZCAwPT09Znx8U2suYnVpbHRpbi5jaGVja05vbmUoZikpZj12b2lkIDA7ZWxzZSBpZihmIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXA9e30sZi4kaXRlbXMoKS5mb3JFYWNoKGc9Pnt2YXIgW2EsY109ZztTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpJiYocFthLiRtYW5nbGVkXT1jKX0pO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGgrXCIgbXVzdCBiZSBhIGRpY3Qgb3IgTm9uZSwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGYpKTtyZXR1cm4gcH1mdW5jdGlvbiBlKGYsXG5oKXtpZih2b2lkIDAhPT1mJiYhU2suYnVpbHRpbi5jaGVja05vbmUoZikpZm9yKGxldCBwIGluIGgpZi5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihTay51bmZpeFJlc2VydmVkKHApKSxoW3BdKX1Tay5idWlsdGlucz17cm91bmQ6bnVsbCxsZW46bnVsbCxtaW46bnVsbCxtYXg6bnVsbCxzdW06bnVsbCxhYnM6bnVsbCxmYWJzOm51bGwsb3JkOm51bGwsY2hyOm51bGwsaGV4Om51bGwsb2N0Om51bGwsYmluOm51bGwsZGlyOm51bGwscmVwcjpudWxsLG9wZW46bnVsbCxpc2luc3RhbmNlOm51bGwsaGFzaDpudWxsLGdldGF0dHI6bnVsbCxoYXNhdHRyOm51bGwsaWQ6bnVsbCxzb3J0ZWQ6bnVsbCxhbnk6bnVsbCxhbGw6bnVsbCxlbnVtZXJhdGU6U2suYnVpbHRpbi5lbnVtZXJhdGUsZmlsdGVyOlNrLmJ1aWx0aW4uZmlsdGVyXyxtYXA6U2suYnVpbHRpbi5tYXBfLHJhbmdlOlNrLmJ1aWx0aW4ucmFuZ2VfLHJldmVyc2VkOlNrLmJ1aWx0aW4ucmV2ZXJzZWQsemlwOlNrLmJ1aWx0aW4uemlwXyxcbkJhc2VFeGNlcHRpb246U2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uLEF0dHJpYnV0ZUVycm9yOlNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IsVmFsdWVFcnJvcjpTay5idWlsdGluLlZhbHVlRXJyb3IsRXhjZXB0aW9uOlNrLmJ1aWx0aW4uRXhjZXB0aW9uLFplcm9EaXZpc2lvbkVycm9yOlNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IsQXNzZXJ0aW9uRXJyb3I6U2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcixJbXBvcnRFcnJvcjpTay5idWlsdGluLkltcG9ydEVycm9yLE1vZHVsZU5vdEZvdW5kRXJyb3I6U2suYnVpbHRpbi5Nb2R1bGVOb3RGb3VuZEVycm9yLEluZGVudGF0aW9uRXJyb3I6U2suYnVpbHRpbi5JbmRlbnRhdGlvbkVycm9yLEluZGV4RXJyb3I6U2suYnVpbHRpbi5JbmRleEVycm9yLExvb2t1cEVycm9yOlNrLmJ1aWx0aW4uTG9va3VwRXJyb3IsS2V5RXJyb3I6U2suYnVpbHRpbi5LZXlFcnJvcixUeXBlRXJyb3I6U2suYnVpbHRpbi5UeXBlRXJyb3IsVW5pY29kZURlY29kZUVycm9yOlNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yLFxuVW5pY29kZUVuY29kZUVycm9yOlNrLmJ1aWx0aW4uVW5pY29kZUVuY29kZUVycm9yLE5hbWVFcnJvcjpTay5idWlsdGluLk5hbWVFcnJvcixVbmJvdW5kTG9jYWxFcnJvcjpTay5idWlsdGluLlVuYm91bmRMb2NhbEVycm9yLElPRXJyb3I6U2suYnVpbHRpbi5JT0Vycm9yLE5vdEltcGxlbWVudGVkRXJyb3I6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yLFN5c3RlbUV4aXQ6U2suYnVpbHRpbi5TeXN0ZW1FeGl0LE92ZXJmbG93RXJyb3I6U2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yLE9wZXJhdGlvbkVycm9yOlNrLmJ1aWx0aW4uT3BlcmF0aW9uRXJyb3IsTmVnYXRpdmVQb3dlckVycm9yOlNrLmJ1aWx0aW4uTmVnYXRpdmVQb3dlckVycm9yLFJ1bnRpbWVFcnJvcjpTay5idWlsdGluLlJ1bnRpbWVFcnJvcixSZWN1cnNpb25FcnJvcjpTay5idWlsdGluLlJlY3Vyc2lvbkVycm9yLFN0b3BJdGVyYXRpb246U2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uLFN5bnRheEVycm9yOlNrLmJ1aWx0aW4uU3ludGF4RXJyb3IsXG5TeXN0ZW1FcnJvcjpTay5idWlsdGluLlN5c3RlbUVycm9yLEtleWJvYXJkSW50ZXJydXB0OlNrLmJ1aWx0aW4uS2V5Ym9hcmRJbnRlcnJ1cHQsZmxvYXRfJHJ3JDpTay5idWlsdGluLmZsb2F0XyxpbnRfJHJ3JDpTay5idWlsdGluLmludF8sYm9vbDpTay5idWlsdGluLmJvb2wsY29tcGxleDpTay5idWlsdGluLmNvbXBsZXgsZGljdDpTay5idWlsdGluLmRpY3QsZmlsZTpTay5idWlsdGluLmZpbGUsZnJvemVuc2V0OlNrLmJ1aWx0aW4uZnJvemVuc2V0LFwiZnVuY3Rpb25cIjpTay5idWlsdGluLmZ1bmMsZ2VuZXJhdG9yOlNrLmJ1aWx0aW4uZ2VuZXJhdG9yLGxpc3Q6U2suYnVpbHRpbi5saXN0LGxvbmdfJHJ3JDpTay5idWlsdGluLmxuZyxtZXRob2Q6U2suYnVpbHRpbi5tZXRob2Qsb2JqZWN0OlNrLmJ1aWx0aW4ub2JqZWN0LHNsaWNlOlNrLmJ1aWx0aW4uc2xpY2Usc3RyOlNrLmJ1aWx0aW4uc3RyLHNldDpTay5idWlsdGluLnNldCx0dXBsZTpTay5idWlsdGluLnR1cGxlLHR5cGU6U2suYnVpbHRpbi50eXBlLFxuaW5wdXQ6bnVsbCxyYXdfaW5wdXQ6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnJhd19pbnB1dCksc2V0YXR0cjpudWxsLGpzZXZhbDpTay5idWlsdGluLmpzZXZhbCxqc21pbGxpczpTay5idWlsdGluLmpzbWlsbGlzLHF1aXQ6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnF1aXQpLGV4aXQ6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnF1aXQpLHByaW50Om51bGwsZGl2bW9kOm51bGwsZm9ybWF0Om51bGwsZ2xvYmFsczpudWxsLGlzc3ViY2xhc3M6bnVsbCxpdGVyOm51bGwsZXhlY2ZpbGU6U2suYnVpbHRpbi5leGVjZmlsZSxoZWxwOlNrLmJ1aWx0aW4uaGVscCxtZW1vcnl2aWV3OlNrLmJ1aWx0aW4ubWVtb3J5dmlldyxyZWxvYWQ6U2suYnVpbHRpbi5yZWxvYWQsc3VwZXJfJHJ3JDpTay5idWlsdGluLnN1cGVyXyx1bmljaHI6bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnVuaWNociksdmFyczpTay5idWlsdGluLnZhcnMsYXBwbHlfJHJ3JDpTay5idWlsdGluLmFwcGx5XyxcbmJ1ZmZlcjpTay5idWlsdGluLmJ1ZmZlcixjb2VyY2U6U2suYnVpbHRpbi5jb2VyY2UsaW50ZXJuOlNrLmJ1aWx0aW4uaW50ZXJuLHByb3BlcnR5OlNrLmJ1aWx0aW4ucHJvcGVydHksY2xhc3NtZXRob2Q6U2suYnVpbHRpbi5jbGFzc21ldGhvZCxzdGF0aWNtZXRob2Q6U2suYnVpbHRpbi5zdGF0aWNtZXRob2QsRWxsaXBzaXM6U2suYnVpbHRpbi5FbGxpcHNpc307Rj1Tay5idWlsdGluLm5vbmUubm9uZSQ7UD1uZXcgU2suYnVpbHRpbi50dXBsZTtjb25zdCBkPW5ldyBTay5idWlsdGluLmludF8oMCk7U2suYWJzdHIuc2V0VXBNb2R1bGVNZXRob2RzKFwiYnVpbHRpbnNcIixTay5idWlsdGlucyx7X19pbXBvcnRfXzp7JG1ldGgoZixoLHAsZyxhKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhmKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2ltcG9ydF9fKCkgYXJndW1lbnQgMSBtdXN0IGJlIHN0ciwgbm90IFwiK2YudHAkbmFtZSk7aWYoZj09PVNrLmJ1aWx0aW4uc3RyLiRlbXB0eSYmXG4wPT09YS52KXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJFbXB0eSBtb2R1bGUgbmFtZVwiKTtoPWIoaCxcImdsb2JhbHNcIil8fHt9O2c9U2suZmZpLnJlbWFwVG9KcyhnKTthPVNrLmZmaS5yZW1hcFRvSnMoYSk7cmV0dXJuIFNrLmJ1aWx0aW4uX19pbXBvcnRfXyhmLGgsdm9pZCAwLGcsYSl9LCRmbGFnczp7TmFtZWRBcmdzOltcIm5hbWVcIixcImdsb2JhbHNcIixcImxvY2Fsc1wiLFwiZnJvbWxpc3RcIixcImxldmVsXCJdLERlZmF1bHRzOltGLEYsUCxkXX0sJHRleHRzaWc6bnVsbCwkZG9jOlwiX19pbXBvcnRfXyhuYW1lLCBnbG9iYWxzPU5vbmUsIGxvY2Fscz1Ob25lLCBmcm9tbGlzdD0oKSwgbGV2ZWw9MCkgLT4gbW9kdWxlXFxuXFxuSW1wb3J0IGEgbW9kdWxlLiBCZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgZm9yIHVzZSBieSB0aGUgUHl0aG9uXFxuaW50ZXJwcmV0ZXIgYW5kIG5vdCBmb3IgZ2VuZXJhbCB1c2UsIGl0IGlzIGJldHRlciB0byB1c2VcXG5pbXBvcnRsaWIuaW1wb3J0X21vZHVsZSgpIHRvIHByb2dyYW1tYXRpY2FsbHkgaW1wb3J0IGEgbW9kdWxlLlxcblxcblRoZSBnbG9iYWxzIGFyZ3VtZW50IGlzIG9ubHkgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNvbnRleHQ7XFxudGhleSBhcmUgbm90IG1vZGlmaWVkLiAgVGhlIGxvY2FscyBhcmd1bWVudCBpcyB1bnVzZWQuICBUaGUgZnJvbWxpc3RcXG5zaG91bGQgYmUgYSBsaXN0IG9mIG5hbWVzIHRvIGVtdWxhdGUgYGBmcm9tIG5hbWUgaW1wb3J0IC4uLicnLCBvciBhblxcbmVtcHR5IGxpc3QgdG8gZW11bGF0ZSBgYGltcG9ydCBuYW1lJycuXFxuV2hlbiBpbXBvcnRpbmcgYSBtb2R1bGUgZnJvbSBhIHBhY2thZ2UsIG5vdGUgdGhhdCBfX2ltcG9ydF9fKCdBLkInLCAuLi4pXFxucmV0dXJucyBwYWNrYWdlIEEgd2hlbiBmcm9tbGlzdCBpcyBlbXB0eSwgYnV0IGl0cyBzdWJtb2R1bGUgQiB3aGVuXFxuZnJvbWxpc3QgaXMgbm90IGVtcHR5LiAgVGhlIGxldmVsIGFyZ3VtZW50IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG9cXG5wZXJmb3JtIGFic29sdXRlIG9yIHJlbGF0aXZlIGltcG9ydHM6IDAgaXMgYWJzb2x1dGUsIHdoaWxlIGEgcG9zaXRpdmUgbnVtYmVyXFxuaXMgdGhlIG51bWJlciBvZiBwYXJlbnQgZGlyZWN0b3JpZXMgdG8gc2VhcmNoIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IG1vZHVsZS5cIn0sXG5hYnM6eyRtZXRoOlNrLmJ1aWx0aW4uYWJzLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB4LCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBhcmd1bWVudC5cIn0sYWxsOnskbWV0aDpTay5idWlsdGluLmFsbCwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaXRlcmFibGUsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIGJvb2woeCkgaXMgVHJ1ZSBmb3IgYWxsIHZhbHVlcyB4IGluIHRoZSBpdGVyYWJsZS5cXG5cXG5JZiB0aGUgaXRlcmFibGUgaXMgZW1wdHksIHJldHVybiBUcnVlLlwifSxhbnk6eyRtZXRoOlNrLmJ1aWx0aW4uYW55LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBpdGVyYWJsZSwgLylcIiwkZG9jOlwiUmV0dXJuIFRydWUgaWYgYm9vbCh4KSBpcyBUcnVlIGZvciBhbnkgeCBpbiB0aGUgaXRlcmFibGUuXFxuXFxuSWYgdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCByZXR1cm4gRmFsc2UuXCJ9LFxuYXNjaWk6eyRtZXRoOlNrLmJ1aWx0aW4uYXNjaWksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIGFuIEFTQ0lJLW9ubHkgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxcblxcbkFzIHJlcHIoKSwgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYW5cXG5vYmplY3QsIGJ1dCBlc2NhcGUgdGhlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgcmV0dXJuZWQgYnlcXG5yZXByKCkgdXNpbmcgXFxcXFxcXFx4LCBcXFxcXFxcXHUgb3IgXFxcXFxcXFxVIGVzY2FwZXMuIFRoaXMgZ2VuZXJhdGVzIGEgc3RyaW5nIHNpbWlsYXJcXG50byB0aGF0IHJldHVybmVkIGJ5IHJlcHIoKSBpbiBQeXRob24gMi5cIn0sYmluOnskbWV0aDpTay5idWlsdGluLmJpbiwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgbnVtYmVyLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxcblxcbiAgID4+PiBiaW4oMjc5NjIwMilcXG4gICAnMGIxMDEwMTAxMDEwMTAxMDEwMTAxMDEwJ1wifSxcbmNhbGxhYmxlOnskbWV0aDpTay5idWlsdGluLmNhbGxhYmxlLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiB3aGV0aGVyIHRoZSBvYmplY3QgaXMgY2FsbGFibGUgKGkuZS4sIHNvbWUga2luZCBvZiBmdW5jdGlvbikuXFxuXFxuTm90ZSB0aGF0IGNsYXNzZXMgYXJlIGNhbGxhYmxlLCBhcyBhcmUgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBhXFxuX19jYWxsX18oKSBtZXRob2QuXCJ9LGNocjp7JG1ldGg6U2suYnVpbHRpbi5jaHIsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGksIC8pXCIsJGRvYzpcIlJldHVybiBhIFVuaWNvZGUgc3RyaW5nIG9mIG9uZSBjaGFyYWN0ZXIgd2l0aCBvcmRpbmFsIGk7IDAgPD0gaSA8PSAweDEwZmZmZi5cIn0sY29tcGlsZTp7JG1ldGg6U2suYnVpbHRpbi5jb21waWxlLCRmbGFnczp7TWluQXJnczozLE1heEFyZ3M6Nn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgLywgc291cmNlLCBmaWxlbmFtZSwgbW9kZSwgZmxhZ3M9MCxcXG4gICAgICAgIGRvbnRfaW5oZXJpdD1GYWxzZSwgb3B0aW1pemU9LTEpXCIsXG4kZG9jOlwiQ29tcGlsZSBzb3VyY2UgaW50byBhIGNvZGUgb2JqZWN0IHRoYXQgY2FuIGJlIGV4ZWN1dGVkIGJ5IGV4ZWMoKSBvciBldmFsKCkuXFxuXFxuVGhlIHNvdXJjZSBjb2RlIG1heSByZXByZXNlbnQgYSBQeXRob24gbW9kdWxlLCBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbi5cXG5UaGUgZmlsZW5hbWUgd2lsbCBiZSB1c2VkIGZvciBydW4tdGltZSBlcnJvciBtZXNzYWdlcy5cXG5UaGUgbW9kZSBtdXN0IGJlICdleGVjJyB0byBjb21waWxlIGEgbW9kdWxlLCAnc2luZ2xlJyB0byBjb21waWxlIGFcXG5zaW5nbGUgKGludGVyYWN0aXZlKSBzdGF0ZW1lbnQsIG9yICdldmFsJyB0byBjb21waWxlIGFuIGV4cHJlc3Npb24uXFxuVGhlIGZsYWdzIGFyZ3VtZW50LCBpZiBwcmVzZW50LCBjb250cm9scyB3aGljaCBmdXR1cmUgc3RhdGVtZW50cyBpbmZsdWVuY2VcXG50aGUgY29tcGlsYXRpb24gb2YgdGhlIGNvZGUuXFxuVGhlIGRvbnRfaW5oZXJpdCBhcmd1bWVudCwgaWYgdHJ1ZSwgc3RvcHMgdGhlIGNvbXBpbGF0aW9uIGluaGVyaXRpbmdcXG50aGUgZWZmZWN0cyBvZiBhbnkgZnV0dXJlIHN0YXRlbWVudHMgaW4gZWZmZWN0IGluIHRoZSBjb2RlIGNhbGxpbmdcXG5jb21waWxlOyBpZiBhYnNlbnQgb3IgZmFsc2UgdGhlc2Ugc3RhdGVtZW50cyBkbyBpbmZsdWVuY2UgdGhlIGNvbXBpbGF0aW9uLFxcbmluIGFkZGl0aW9uIHRvIGFueSBmZWF0dXJlcyBleHBsaWNpdGx5IHNwZWNpZmllZC5cIn0sXG5kZWxhdHRyOnskbWV0aDpTay5idWlsdGluLmRlbGF0dHIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIG5hbWUsIC8pXCIsJGRvYzpcIkRlbGV0ZXMgdGhlIG5hbWVkIGF0dHJpYnV0ZSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXFxuXFxuZGVsYXR0cih4LCAneScpIGlzIGVxdWl2YWxlbnQgdG8gYGBkZWwgeC55JydcIn0sZGlyOnskbWV0aDpTay5idWlsdGluLmRpciwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOm51bGwsJGRvYzpcImRpcihbb2JqZWN0XSkgLT4gbGlzdCBvZiBzdHJpbmdzXFxuXFxuSWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHJldHVybiB0aGUgbmFtZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUuXFxuRWxzZSwgcmV0dXJuIGFuIGFscGhhYmV0aXplZCBsaXN0IG9mIG5hbWVzIGNvbXByaXNpbmcgKHNvbWUgb2YpIHRoZSBhdHRyaWJ1dGVzXFxub2YgdGhlIGdpdmVuIG9iamVjdCwgYW5kIG9mIGF0dHJpYnV0ZXMgcmVhY2hhYmxlIGZyb20gaXQuXFxuSWYgdGhlIG9iamVjdCBzdXBwbGllcyBhIG1ldGhvZCBuYW1lZCBfX2Rpcl9fLCBpdCB3aWxsIGJlIHVzZWQ7IG90aGVyd2lzZVxcbnRoZSBkZWZhdWx0IGRpcigpIGxvZ2ljIGlzIHVzZWQgYW5kIHJldHVybnM6XFxuICBmb3IgYSBtb2R1bGUgb2JqZWN0OiB0aGUgbW9kdWxlJ3MgYXR0cmlidXRlcy5cXG4gIGZvciBhIGNsYXNzIG9iamVjdDogIGl0cyBhdHRyaWJ1dGVzLCBhbmQgcmVjdXJzaXZlbHkgdGhlIGF0dHJpYnV0ZXNcXG4gICAgb2YgaXRzIGJhc2VzLlxcbiAgZm9yIGFueSBvdGhlciBvYmplY3Q6IGl0cyBhdHRyaWJ1dGVzLCBpdHMgY2xhc3MncyBhdHRyaWJ1dGVzLCBhbmRcXG4gICAgcmVjdXJzaXZlbHkgdGhlIGF0dHJpYnV0ZXMgb2YgaXRzIGNsYXNzJ3MgYmFzZSBjbGFzc2VzLlwifSxcbmRpdm1vZDp7JG1ldGg6U2suYnVpbHRpbi5kaXZtb2QsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB4LCB5LCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIHR1cGxlICh4Ly95LCB4JXkpLiAgSW52YXJpYW50OiBkaXYqeSArIG1vZCA9PSB4LlwifSxldmFsXyRydyQ6eyRuYW1lOlwiZXZhbFwiLCRtZXRoOmZ1bmN0aW9uKGYsaCxwKXtjb25zdCBnPWIoaCxcImdsb2JhbHNcIiksYT1iKHAsXCJsb2NhbHNcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmJ1aWx0aW4uZXZhbChmLGcsYSksYz0+e2UoaCxnKTtlKHAsYSk7cmV0dXJuIGN9KX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBzb3VyY2UsIGdsb2JhbHM9Tm9uZSwgbG9jYWxzPU5vbmUsIC8pXCIsJGRvYzpcIkV2YWx1YXRlIHRoZSBnaXZlbiBzb3VyY2UgaW4gdGhlIGNvbnRleHQgb2YgZ2xvYmFscyBhbmQgbG9jYWxzLlxcblxcblRoZSBzb3VyY2UgbWF5IGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFB5dGhvbiBleHByZXNzaW9uXFxub3IgYSBjb2RlIG9iamVjdCBhcyByZXR1cm5lZCBieSBjb21waWxlKCkuXFxuVGhlIGdsb2JhbHMgbXVzdCBiZSBhIGRpY3Rpb25hcnkgYW5kIGxvY2FscyBjYW4gYmUgYW55IG1hcHBpbmcsXFxuZGVmYXVsdGluZyB0byB0aGUgY3VycmVudCBnbG9iYWxzIGFuZCBsb2NhbHMuXFxuSWYgb25seSBnbG9iYWxzIGlzIGdpdmVuLCBsb2NhbHMgZGVmYXVsdHMgdG8gaXQuXCJ9LFxuZXhlYzp7JG1ldGg6ZnVuY3Rpb24oZixoLHApe2NvbnN0IGc9YihoLFwiZ2xvYmFsc1wiKSxhPWIocCxcImxvY2Fsc1wiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suYnVpbHRpbi5leGVjKGYsZyxhKSxjPT57ZShoLGcpO2UocCxhKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJG1vZHVsZSwgc291cmNlLCBnbG9iYWxzPU5vbmUsIGxvY2Fscz1Ob25lLCAvKVwiLCRkb2M6XCJFeGVjdXRlIHRoZSBnaXZlbiBzb3VyY2UgaW4gdGhlIGNvbnRleHQgb2YgZ2xvYmFscyBhbmQgbG9jYWxzLlxcblxcblRoZSBzb3VyY2UgbWF5IGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBvbmUgb3IgbW9yZSBQeXRob24gc3RhdGVtZW50c1xcbm9yIGEgY29kZSBvYmplY3QgYXMgcmV0dXJuZWQgYnkgY29tcGlsZSgpLlxcblRoZSBnbG9iYWxzIG11c3QgYmUgYSBkaWN0aW9uYXJ5IGFuZCBsb2NhbHMgY2FuIGJlIGFueSBtYXBwaW5nLFxcbmRlZmF1bHRpbmcgdG8gdGhlIGN1cnJlbnQgZ2xvYmFscyBhbmQgbG9jYWxzLlxcbklmIG9ubHkgZ2xvYmFscyBpcyBnaXZlbiwgbG9jYWxzIGRlZmF1bHRzIHRvIGl0LlwifSxcbmZvcm1hdDp7JG1ldGg6U2suYnVpbHRpbi5mb3JtYXQsJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB2YWx1ZSwgZm9ybWF0X3NwZWM9JycsIC8pXCIsJGRvYzpcIlJldHVybiB2YWx1ZS5fX2Zvcm1hdF9fKGZvcm1hdF9zcGVjKVxcblxcbmZvcm1hdF9zcGVjIGRlZmF1bHRzIHRvIHRoZSBlbXB0eSBzdHJpbmcuXFxuU2VlIHRoZSBGb3JtYXQgU3BlY2lmaWNhdGlvbiBNaW5pLUxhbmd1YWdlIHNlY3Rpb24gb2YgaGVscCgnRk9STUFUVElORycpIGZvclxcbmRldGFpbHMuXCJ9LGdldGF0dHI6eyRtZXRoOlNrLmJ1aWx0aW4uZ2V0YXR0ciwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcImdldGF0dHIob2JqZWN0LCBuYW1lWywgZGVmYXVsdF0pIC0+IHZhbHVlXFxuXFxuR2V0IGEgbmFtZWQgYXR0cmlidXRlIGZyb20gYW4gb2JqZWN0OyBnZXRhdHRyKHgsICd5JykgaXMgZXF1aXZhbGVudCB0byB4LnkuXFxuV2hlbiBhIGRlZmF1bHQgYXJndW1lbnQgaXMgZ2l2ZW4sIGl0IGlzIHJldHVybmVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBkb2Vzbid0XFxuZXhpc3Q7IHdpdGhvdXQgaXQsIGFuIGV4Y2VwdGlvbiBpcyByYWlzZWQgaW4gdGhhdCBjYXNlLlwifSxcbmdsb2JhbHM6eyRtZXRoOlNrLmJ1aWx0aW4uZ2xvYmFscywkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2NvcGUncyBnbG9iYWwgdmFyaWFibGVzLlxcblxcbk5PVEU6IFVwZGF0ZXMgdG8gdGhpcyBkaWN0aW9uYXJ5ICp3aWxsKiBhZmZlY3QgbmFtZSBsb29rdXBzIGluIHRoZSBjdXJyZW50XFxuZ2xvYmFsIHNjb3BlIGFuZCB2aWNlLXZlcnNhLlwifSxoYXNhdHRyOnskbWV0aDpTay5idWlsdGluLmhhc2F0dHIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIG5hbWUsIC8pXCIsJGRvYzpcIlJldHVybiB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxcblxcblRoaXMgaXMgZG9uZSBieSBjYWxsaW5nIGdldGF0dHIob2JqLCBuYW1lKSBhbmQgY2F0Y2hpbmcgQXR0cmlidXRlRXJyb3IuXCJ9LFxuaGFzaDp7JG1ldGg6U2suYnVpbHRpbi5oYXNoLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgaGFzaCB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9iamVjdC5cXG5cXG5Ud28gb2JqZWN0cyB0aGF0IGNvbXBhcmUgZXF1YWwgbXVzdCBhbHNvIGhhdmUgdGhlIHNhbWUgaGFzaCB2YWx1ZSwgYnV0IHRoZVxcbnJldmVyc2UgaXMgbm90IG5lY2Vzc2FyaWx5IHRydWUuXCJ9LGhleDp7JG1ldGg6U2suYnVpbHRpbi5oZXgsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG51bWJlciwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxcblxcbiAgID4+PiBoZXgoMTI2NDg0MzApXFxuICAgJzB4YzBmZmVlJ1wifSxpZDp7JG1ldGg6U2suYnVpbHRpbi5pZCwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgb2JqLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGlkZW50aXR5IG9mIGFuIG9iamVjdC5cXG5cXG5UaGlzIGlzIGd1YXJhbnRlZWQgdG8gYmUgdW5pcXVlIGFtb25nIHNpbXVsdGFuZW91c2x5IGV4aXN0aW5nIG9iamVjdHMuXFxuKENQeXRob24gdXNlcyB0aGUgb2JqZWN0J3MgbWVtb3J5IGFkZHJlc3MuKVwifSxcbmlucHV0OnskbWV0aDpTay5idWlsdGluLmlucHV0LCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6XCIoJG1vZHVsZSwgcHJvbXB0PU5vbmUsIC8pXCIsJGRvYzpcIlJlYWQgYSBzdHJpbmcgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIFRoZSB0cmFpbGluZyBuZXdsaW5lIGlzIHN0cmlwcGVkLlxcblxcblRoZSBwcm9tcHQgc3RyaW5nLCBpZiBnaXZlbiwgaXMgcHJpbnRlZCB0byBzdGFuZGFyZCBvdXRwdXQgd2l0aG91dCBhXFxudHJhaWxpbmcgbmV3bGluZSBiZWZvcmUgcmVhZGluZyBpbnB1dC5cXG5cXG5JZiB0aGUgdXNlciBoaXRzIEVPRiAoKm5peDogQ3RybC1ELCBXaW5kb3dzOiBDdHJsLVorUmV0dXJuKSwgcmFpc2UgRU9GRXJyb3IuXFxuT24gKm5peCBzeXN0ZW1zLCByZWFkbGluZSBpcyB1c2VkIGlmIGF2YWlsYWJsZS5cIn0saXNpbnN0YW5jZTp7JG1ldGg6U2suYnVpbHRpbi5pc2luc3RhbmNlLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgb2JqLCBjbGFzc19vcl90dXBsZSwgLylcIixcbiRkb2M6XCJSZXR1cm4gd2hldGhlciBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyBvciBvZiBhIHN1YmNsYXNzIHRoZXJlb2YuXFxuXFxuQSB0dXBsZSwgYXMgaW4gYGBpc2luc3RhbmNlKHgsIChBLCBCLCAuLi4pKWBgLCBtYXkgYmUgZ2l2ZW4gYXMgdGhlIHRhcmdldCB0b1xcbmNoZWNrIGFnYWluc3QuIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgYGlzaW5zdGFuY2UoeCwgQSkgb3IgaXNpbnN0YW5jZSh4LCBCKVxcbm9yIC4uLmBgIGV0Yy5cIn0saXNzdWJjbGFzczp7JG1ldGg6U2suYnVpbHRpbi5pc3N1YmNsYXNzLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgY2xzLCBjbGFzc19vcl90dXBsZSwgLylcIiwkZG9jOlwiUmV0dXJuIHdoZXRoZXIgJ2NscycgaXMgYSBkZXJpdmVkIGZyb20gYW5vdGhlciBjbGFzcyBvciBpcyB0aGUgc2FtZSBjbGFzcy5cXG5cXG5BIHR1cGxlLCBhcyBpbiBgYGlzc3ViY2xhc3MoeCwgKEEsIEIsIC4uLikpYGAsIG1heSBiZSBnaXZlbiBhcyB0aGUgdGFyZ2V0IHRvXFxuY2hlY2sgYWdhaW5zdC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBgaXNzdWJjbGFzcyh4LCBBKSBvciBpc3N1YmNsYXNzKHgsIEIpXFxub3IgLi4uYGAgZXRjLlwifSxcbml0ZXI6eyRtZXRoOlNrLmJ1aWx0aW4uaXRlciwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGl0ZXJhYmxlIC8pXCIsJGRvYzpcIml0ZXIoaXRlcmFibGUpIC0+IGl0ZXJhdG9yXFxuaXRlcihjYWxsYWJsZSwgc2VudGluZWwpIC0+IGl0ZXJhdG9yXFxuXFxuR2V0IGFuIGl0ZXJhdG9yIGZyb20gYW4gb2JqZWN0LiAgSW4gdGhlIGZpcnN0IGZvcm0sIHRoZSBhcmd1bWVudCBtdXN0XFxuc3VwcGx5IGl0cyBvd24gaXRlcmF0b3IsIG9yIGJlIGEgc2VxdWVuY2UuXFxuSW4gdGhlIHNlY29uZCBmb3JtLCB0aGUgY2FsbGFibGUgaXMgY2FsbGVkIHVudGlsIGl0IHJldHVybnMgdGhlIHNlbnRpbmVsLlwifSxsZW46eyRtZXRoOlNrLmJ1aWx0aW4ubGVuLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIGEgY29udGFpbmVyLlwifSxsb2NhbHM6eyRtZXRoOlNrLmJ1aWx0aW4ubG9jYWxzLFxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIC8pXCIsJGRvYzpcIlJldHVybiBhIGRpY3Rpb25hcnkgY29udGFpbmluZyB0aGUgY3VycmVudCBzY29wZSdzIGxvY2FsIHZhcmlhYmxlcy5cXG5cXG5OT1RFOiBXaGV0aGVyIG9yIG5vdCB1cGRhdGVzIHRvIHRoaXMgZGljdGlvbmFyeSB3aWxsIGFmZmVjdCBuYW1lIGxvb2t1cHMgaW5cXG50aGUgbG9jYWwgc2NvcGUgYW5kIHZpY2UtdmVyc2EgaXMgKmltcGxlbWVudGF0aW9uIGRlcGVuZGVudCogYW5kIG5vdFxcbmNvdmVyZWQgYnkgYW55IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGd1YXJhbnRlZXMuXCJ9LG1heDp7JG1ldGg6U2suYnVpbHRpbi5tYXgsJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwibWF4KGl0ZXJhYmxlLCAqWywgZGVmYXVsdD1vYmosIGtleT1mdW5jXSkgLT4gdmFsdWVcXG5tYXgoYXJnMSwgYXJnMiwgKmFyZ3MsICpbLCBrZXk9ZnVuY10pIC0+IHZhbHVlXFxuXFxuV2l0aCBhIHNpbmdsZSBpdGVyYWJsZSBhcmd1bWVudCwgcmV0dXJuIGl0cyBiaWdnZXN0IGl0ZW0uIFRoZVxcbmRlZmF1bHQga2V5d29yZC1vbmx5IGFyZ3VtZW50IHNwZWNpZmllcyBhbiBvYmplY3QgdG8gcmV0dXJuIGlmXFxudGhlIHByb3ZpZGVkIGl0ZXJhYmxlIGlzIGVtcHR5LlxcbldpdGggdHdvIG9yIG1vcmUgYXJndW1lbnRzLCByZXR1cm4gdGhlIGxhcmdlc3QgYXJndW1lbnQuXCJ9LFxubWluOnskbWV0aDpTay5idWlsdGluLm1pbiwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJtaW4oaXRlcmFibGUsICpbLCBkZWZhdWx0PW9iaiwga2V5PWZ1bmNdKSAtPiB2YWx1ZVxcbm1pbihhcmcxLCBhcmcyLCAqYXJncywgKlssIGtleT1mdW5jXSkgLT4gdmFsdWVcXG5cXG5XaXRoIGEgc2luZ2xlIGl0ZXJhYmxlIGFyZ3VtZW50LCByZXR1cm4gaXRzIHNtYWxsZXN0IGl0ZW0uIFRoZVxcbmRlZmF1bHQga2V5d29yZC1vbmx5IGFyZ3VtZW50IHNwZWNpZmllcyBhbiBvYmplY3QgdG8gcmV0dXJuIGlmXFxudGhlIHByb3ZpZGVkIGl0ZXJhYmxlIGlzIGVtcHR5LlxcbldpdGggdHdvIG9yIG1vcmUgYXJndW1lbnRzLCByZXR1cm4gdGhlIHNtYWxsZXN0IGFyZ3VtZW50LlwifSxuZXh0OnskbmFtZTpcIm5leHRcIiwkbWV0aDpTay5idWlsdGluLm5leHRfLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6bnVsbCwkZG9jOlwibmV4dChpdGVyYXRvclssIGRlZmF1bHRdKVxcblxcblJldHVybiB0aGUgbmV4dCBpdGVtIGZyb20gdGhlIGl0ZXJhdG9yLiBJZiBkZWZhdWx0IGlzIGdpdmVuIGFuZCB0aGUgaXRlcmF0b3JcXG5pcyBleGhhdXN0ZWQsIGl0IGlzIHJldHVybmVkIGluc3RlYWQgb2YgcmFpc2luZyBTdG9wSXRlcmF0aW9uLlwifSxcbm9jdDp7JG1ldGg6U2suYnVpbHRpbi5vY3QsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG51bWJlciwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBvY3RhbCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxcblxcbiAgID4+PiBvY3QoMzQyMzkxKVxcbiAgICcwbzEyMzQ1NjcnXCJ9LG9wZW46eyRtZXRoOlNrLmJ1aWx0aW4ub3BlbiwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIm9wZW4obmFtZVssIG1vZGVbLCBidWZmZXJpbmddXSkgLT4gZmlsZSBvYmplY3RcXG5cXG5PcGVuIGEgZmlsZSB1c2luZyB0aGUgZmlsZSgpIHR5cGUsIHJldHVybnMgYSBmaWxlIG9iamVjdC4gIFRoaXMgaXMgdGhlXFxucHJlZmVycmVkIHdheSB0byBvcGVuIGEgZmlsZS4gIFNlZSBmaWxlLl9fZG9jX18gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24uXCJ9LG9yZDp7JG1ldGg6U2suYnVpbHRpbi5vcmQsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGMsIC8pXCIsXG4kZG9jOlwiUmV0dXJuIHRoZSBVbmljb2RlIGNvZGUgcG9pbnQgZm9yIGEgb25lLWNoYXJhY3RlciBzdHJpbmcuXCJ9LHBvdzp7JG1ldGg6U2suYnVpbHRpbi5wb3csJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB4LCB5LCB6PU5vbmUsIC8pXCIsJGRvYzpcIkVxdWl2YWxlbnQgdG8geCoqeSAod2l0aCB0d28gYXJndW1lbnRzKSBvciB4Kip5ICUgeiAod2l0aCB0aHJlZSBhcmd1bWVudHMpXFxuXFxuU29tZSB0eXBlcywgc3VjaCBhcyBpbnRzLCBhcmUgYWJsZSB0byB1c2UgYSBtb3JlIGVmZmljaWVudCBhbGdvcml0aG0gd2hlblxcbmludm9rZWQgdXNpbmcgdGhlIHRocmVlIGFyZ3VtZW50IGZvcm0uXCJ9LHByaW50OnskbWV0aDpTay5idWlsdGluLnByaW50LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcInByaW50KHZhbHVlLCAuLi4sIHNlcD0nICcsIGVuZD0nXFxcXG4nLCBmaWxlPXN5cy5zdGRvdXQsIGZsdXNoPUZhbHNlKVxcblxcblByaW50cyB0aGUgdmFsdWVzIHRvIGEgc3RyZWFtLCBvciB0byBzeXMuc3Rkb3V0IGJ5IGRlZmF1bHQuXFxuT3B0aW9uYWwga2V5d29yZCBhcmd1bWVudHM6XFxuZmlsZTogIGEgZmlsZS1saWtlIG9iamVjdCAoc3RyZWFtKTsgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgc3lzLnN0ZG91dC5cXG5zZXA6ICAgc3RyaW5nIGluc2VydGVkIGJldHdlZW4gdmFsdWVzLCBkZWZhdWx0IGEgc3BhY2UuXFxuZW5kOiAgIHN0cmluZyBhcHBlbmRlZCBhZnRlciB0aGUgbGFzdCB2YWx1ZSwgZGVmYXVsdCBhIG5ld2xpbmUuXFxuZmx1c2g6IHdoZXRoZXIgdG8gZm9yY2libHkgZmx1c2ggdGhlIHN0cmVhbS5cIn0sXG5yZXByOnskbWV0aDpTay5idWlsdGluLnJlcHIsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBjYW5vbmljYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXFxuXFxuRm9yIG1hbnkgb2JqZWN0IHR5cGVzLCBpbmNsdWRpbmcgbW9zdCBidWlsdGlucywgZXZhbChyZXByKG9iaikpID09IG9iai5cIn0scm91bmQ6eyRtZXRoOlNrLmJ1aWx0aW4ucm91bmQsJGZsYWdzOntOYW1lZEFyZ3M6W1wibnVtYmVyXCIsXCJuZGlnaXRzXCJdfSwkdGV4dHNpZzpcIigkbW9kdWxlLCAvLCBudW1iZXIsIG5kaWdpdHM9Tm9uZSlcIiwkZG9jOlwiUm91bmQgYSBudW1iZXIgdG8gYSBnaXZlbiBwcmVjaXNpb24gaW4gZGVjaW1hbCBkaWdpdHMuXFxuXFxuVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGlmIG5kaWdpdHMgaXMgb21pdHRlZCBvciBOb25lLiAgT3RoZXJ3aXNlXFxudGhlIHJldHVybiB2YWx1ZSBoYXMgdGhlIHNhbWUgdHlwZSBhcyB0aGUgbnVtYmVyLiAgbmRpZ2l0cyBtYXkgYmUgbmVnYXRpdmUuXCJ9LFxuc2V0YXR0cjp7JG1ldGg6U2suYnVpbHRpbi5zZXRhdHRyLCRmbGFnczp7TWluQXJnczozLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJG1vZHVsZSwgb2JqLCBuYW1lLCB2YWx1ZSwgLylcIiwkZG9jOlwiU2V0cyB0aGUgbmFtZWQgYXR0cmlidXRlIG9uIHRoZSBnaXZlbiBvYmplY3QgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cXG5cXG5zZXRhdHRyKHgsICd5JywgdikgaXMgZXF1aXZhbGVudCB0byBgYHgueSA9IHYnJ1wifSxzb3J0ZWQ6eyRtZXRoOlNrLmJ1aWx0aW4uc29ydGVkLCRmbGFnczp7TmFtZWRBcmdzOltudWxsLFwiY21wXCIsXCJrZXlcIixcInJldmVyc2VcIl0sRGVmYXVsdHM6W1NrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ib29sLmZhbHNlJF19LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGl0ZXJhYmxlLCAvLCAqLCBrZXk9Tm9uZSwgcmV2ZXJzZT1GYWxzZSlcIiwkZG9jOlwiUmV0dXJuIGEgbmV3IGxpc3QgY29udGFpbmluZyBhbGwgaXRlbXMgZnJvbSB0aGUgaXRlcmFibGUgaW4gYXNjZW5kaW5nIG9yZGVyLlxcblxcbkEgY3VzdG9tIGtleSBmdW5jdGlvbiBjYW4gYmUgc3VwcGxpZWQgdG8gY3VzdG9taXplIHRoZSBzb3J0IG9yZGVyLCBhbmQgdGhlXFxucmV2ZXJzZSBmbGFnIGNhbiBiZSBzZXQgdG8gcmVxdWVzdCB0aGUgcmVzdWx0IGluIGRlc2NlbmRpbmcgb3JkZXIuXCJ9LFxuc3VtOnskbWV0aDpTay5idWlsdGluLnN1bSwkZmxhZ3M6e05hbWVkQXJnczpbbnVsbCxcInN0YXJ0XCJdLERlZmF1bHRzOltuZXcgU2suYnVpbHRpbi5pbnRfKDApXX0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaXRlcmFibGUsIC8sIHN0YXJ0PTApXCIsJGRvYzpcIlJldHVybiB0aGUgc3VtIG9mIGEgJ3N0YXJ0JyB2YWx1ZSAoZGVmYXVsdDogMCkgcGx1cyBhbiBpdGVyYWJsZSBvZiBudW1iZXJzXFxuXFxuV2hlbiB0aGUgaXRlcmFibGUgaXMgZW1wdHksIHJldHVybiB0aGUgc3RhcnQgdmFsdWUuXFxuVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCBzcGVjaWZpY2FsbHkgZm9yIHVzZSB3aXRoIG51bWVyaWMgdmFsdWVzIGFuZCBtYXlcXG5yZWplY3Qgbm9uLW51bWVyaWMgdHlwZXMuXCJ9LHZhcnM6eyRtZXRoOlNrLmJ1aWx0aW4udmFycywkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOm51bGwsJGRvYzpcInZhcnMoW29iamVjdF0pIC0+IGRpY3Rpb25hcnlcXG5cXG5XaXRob3V0IGFyZ3VtZW50cywgZXF1aXZhbGVudCB0byBsb2NhbHMoKS5cXG5XaXRoIGFuIGFyZ3VtZW50LCBlcXVpdmFsZW50IHRvIG9iamVjdC5fX2RpY3RfXy5cIn19KTtcblNrLnNldHVwT2JqZWN0cz1mdW5jdGlvbihmKXtmPyhTay5idWlsdGlucy5maWx0ZXI9U2suYnVpbHRpbi5maWx0ZXJfLFNrLmJ1aWx0aW5zLm1hcD1Tay5idWlsdGluLm1hcF8sU2suYnVpbHRpbnMuemlwPVNrLmJ1aWx0aW4uemlwXyxTay5idWlsdGlucy5yYW5nZT1Tay5idWlsdGluLnJhbmdlXyxkZWxldGUgU2suYnVpbHRpbnMucmVkdWNlLGRlbGV0ZSBTay5idWlsdGlucy54cmFuZ2UsZGVsZXRlIFNrLmJ1aWx0aW5zLlN0YW5kYXJkRXJyb3IsZGVsZXRlIFNrLmJ1aWx0aW5zLnVuaWNvZGUsZGVsZXRlIFNrLmJ1aWx0aW5zLmJhc2VzdHJpbmcsZGVsZXRlIFNrLmJ1aWx0aW5zLmxvbmdfJHJ3JCxTay5idWlsdGluLmludF8ucHJvdG90eXBlLiRyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYudG9TdHJpbmcoKSl9LGRlbGV0ZSBTay5idWlsdGluLmludF8ucHJvdG90eXBlLnRwJHN0cixkZWxldGUgU2suYnVpbHRpbi5ib29sLnByb3RvdHlwZS50cCRzdHIsXG5kZWxldGUgU2suYnVpbHRpbnMucmF3X2lucHV0LGRlbGV0ZSBTay5idWlsdGlucy51bmljaHIsZGVsZXRlIFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5kZWNvZGUsU2suYnVpbHRpbnMuYnl0ZXM9U2suYnVpbHRpbi5ieXRlcyxTay5idWlsdGlucy5hc2NpaT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4uYXNjaWksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIGFuIEFTQ0lJLW9ubHkgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxcblxcbkFzIHJlcHIoKSwgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYW5cXG5vYmplY3QsIGJ1dCBlc2NhcGUgdGhlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgcmV0dXJuZWQgYnlcXG5yZXByKCkgdXNpbmcgXFxcXFxcXFx4LCBcXFxcXFxcXHUgb3IgXFxcXFxcXFxVIGVzY2FwZXMuIFRoaXMgZ2VuZXJhdGVzIGEgc3RyaW5nIHNpbWlsYXJcXG50byB0aGF0IHJldHVybmVkIGJ5IHJlcHIoKSBpbiBQeXRob24gMi5cIn0sXG5udWxsLFwiYnVpbHRpbnNcIikpOihTay5idWlsdGlucy5yYW5nZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ucmFuZ2UsJG5hbWU6XCJyYW5nZVwiLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M319LHZvaWQgMCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLnhyYW5nZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ueHJhbmdlLCRuYW1lOlwieHJhbmdlXCIsJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfX0sbnVsbCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLnJlZHVjZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ucmVkdWNlLCRuYW1lOlwicmVkdWNlXCIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczozfX0sbnVsbCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLmZpbHRlcj1uZXcgU2suYnVpbHRpbi5mdW5jKFNrLmJ1aWx0aW4uZmlsdGVyKSxTay5idWlsdGlucy5tYXA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLm1hcCksXG5Tay5idWlsdGlucy56aXA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnppcCksU2suYnVpbHRpbnMuU3RhbmRhcmRFcnJvcj1Tay5idWlsdGluLkV4Y2VwdGlvbixTay5idWlsdGlucy51bmljb2RlPVNrLmJ1aWx0aW4uc3RyLFNrLmJ1aWx0aW5zLmJhc2VzdHJpbmc9U2suYnVpbHRpbi5zdHIsU2suYnVpbHRpbnMubG9uZ18kcnckPVNrLmJ1aWx0aW4ubG5nLFNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGUuJHI9ZnVuY3Rpb24oKXtjb25zdCBoPXRoaXMudjtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGg/bmV3IFNrLmJ1aWx0aW4uc3RyKGgudG9TdHJpbmcoKSk6bmV3IFNrLmJ1aWx0aW4uc3RyKGgudG9TdHJpbmcoKStcIkxcIil9LFNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGUudHAkc3RyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYudG9TdHJpbmcoKSl9LFNrLmJ1aWx0aW4uYm9vbC5wcm90b3R5cGUudHAkc3RyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJHIoKX0sXG5Tay5idWlsdGlucy5yYXdfaW5wdXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnJhd19pbnB1dCksU2suYnVpbHRpbnMudW5pY2hyPW5ldyBTay5idWlsdGluLmZ1bmMoU2suYnVpbHRpbi51bmljaHIpLFNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS5kZWNvZGU9U2suYnVpbHRpbi5zdHIuJHB5MmRlY29kZSxkZWxldGUgU2suYnVpbHRpbnMuYnl0ZXMsZGVsZXRlIFNrLmJ1aWx0aW5zLmFzY2lpKX07U2suZXhwb3J0U3ltYm9sKFwiU2suc2V0dXBPYmplY3RzXCIsU2suc2V0dXBPYmplY3RzKTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluc1wiLFNrLmJ1aWx0aW5zKX0sZnVuY3Rpb24oRixQKXtTay5idWlsdGluLnN0ci4kZW1wdHk9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpO1NrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0cj1Tay5idWlsdGluLnN0ci4kZW1wdHk7U2suYnVpbHRpbi5zdHIuJHV0Zjg9bmV3IFNrLmJ1aWx0aW4uc3RyKFwidXRmLThcIik7U2suYnVpbHRpbi5zdHIuJGFzY2lpPVxubmV3IFNrLmJ1aWx0aW4uc3RyKFwiYXNjaWlcIik7U2suYnVpbHRpbi5zdHIuJGRlZmF1bHRfZmFjdG9yeT1uZXcgU2suYnVpbHRpbi5zdHIoXCJkZWZhdWx0X2ZhY3RvcnlcIik7U2suYnVpbHRpbi5zdHIuJGltYWc9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiaW1hZ1wiKTtTay5idWlsdGluLnN0ci4kcmVhbD1uZXcgU2suYnVpbHRpbi5zdHIoXCJyZWFsXCIpO1NrLmJ1aWx0aW4uc3RyLiRhYnM9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19hYnNfX1wiKTtTay5idWlsdGluLnN0ci4kYmFzZXM9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19iYXNlc19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRieXRlcz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2J5dGVzX19cIik7U2suYnVpbHRpbi5zdHIuJGNhbGw9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19jYWxsX19cIik7U2suYnVpbHRpbi5zdHIuJGNsYXNzPW5ldyBTay5idWlsdGluLnN0cihcIl9fY2xhc3NfX1wiKTtTay5idWlsdGluLnN0ci4kY2xhc3NfZ2V0aXRlbT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2NsYXNzX2dldGl0ZW1fX1wiKTtcblNrLmJ1aWx0aW4uc3RyLiRjbXA9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19jbXBfX1wiKTtTay5idWlsdGluLnN0ci4kY29tcGxleD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2NvbXBsZXhfX1wiKTtTay5idWlsdGluLnN0ci4kY29udGFpbnM9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19jb250YWluc19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRjb3B5PW5ldyBTay5idWlsdGluLnN0cihcIl9fY29weV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRkaWN0PW5ldyBTay5idWlsdGluLnN0cihcIl9fZGljdF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRkaXI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19kaXJfX1wiKTtTay5idWlsdGluLnN0ci4kZG9jPW5ldyBTay5idWlsdGluLnN0cihcIl9fZG9jX19cIik7U2suYnVpbHRpbi5zdHIuJGVudGVyPW5ldyBTay5idWlsdGluLnN0cihcIl9fZW50ZXJfX1wiKTtTay5idWlsdGluLnN0ci4kZXE9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19lcV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRleGl0PW5ldyBTay5idWlsdGluLnN0cihcIl9fZXhpdF9fXCIpO1xuU2suYnVpbHRpbi5zdHIuJGluZGV4PW5ldyBTay5idWlsdGluLnN0cihcIl9faW5kZXhfX1wiKTtTay5idWlsdGluLnN0ci4kaW5pdD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2luaXRfX1wiKTtTay5idWlsdGluLnN0ci4kaW5pdHN1YmNsYXNzPW5ldyBTay5idWlsdGluLnN0cihcIl9faW5pdF9zdWJjbGFzc19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRpbnRfPW5ldyBTay5idWlsdGluLnN0cihcIl9faW50X19cIik7U2suYnVpbHRpbi5zdHIuJGl0ZXI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19pdGVyX19cIik7U2suYnVpbHRpbi5zdHIuJGZpbGU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19maWxlX19cIik7U2suYnVpbHRpbi5zdHIuJGZsb2F0Xz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2Zsb2F0X19cIik7U2suYnVpbHRpbi5zdHIuJGZvcm1hdD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2Zvcm1hdF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRnZT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2dlX19cIik7U2suYnVpbHRpbi5zdHIuJGdldGF0dHI9XG5uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2dldGF0dHJfX1wiKTtTay5idWlsdGluLnN0ci4kZ2V0YXR0cmlidXRlPW5ldyBTay5idWlsdGluLnN0cihcIl9fZ2V0YXR0cmlidXRlX19cIik7U2suYnVpbHRpbi5zdHIuJGdldGl0ZW09bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19nZXRpdGVtX19cIik7U2suYnVpbHRpbi5zdHIuJGd0PW5ldyBTay5idWlsdGluLnN0cihcIl9fZ3RfX1wiKTtTay5idWlsdGluLnN0ci4ka2V5cz1uZXcgU2suYnVpbHRpbi5zdHIoXCJrZXlzXCIpO1NrLmJ1aWx0aW4uc3RyLiRsZT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2xlX19cIik7U2suYnVpbHRpbi5zdHIuJGxlbj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2xlbl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRsZW5ndGhfaGludD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2xlbmd0aF9oaW50X19cIik7U2suYnVpbHRpbi5zdHIuJGxvYWRlcj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2xvYWRlcl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRsdD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2x0X19cIik7XG5Tay5idWlsdGluLnN0ci4kbW9kdWxlPW5ldyBTay5idWlsdGluLnN0cihcIl9fbW9kdWxlX19cIik7U2suYnVpbHRpbi5zdHIuJG1pc3Npbmc9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19taXNzaW5nX19cIik7U2suYnVpbHRpbi5zdHIuJG5hbWU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19uYW1lX19cIik7U2suYnVpbHRpbi5zdHIuJG5lPW5ldyBTay5idWlsdGluLnN0cihcIl9fbmVfX1wiKTtTay5idWlsdGluLnN0ci4kbmV3PW5ldyBTay5idWlsdGluLnN0cihcIl9fbmV3X19cIik7U2suYnVpbHRpbi5zdHIuJG5leHQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19uZXh0X19cIik7U2suYnVpbHRpbi5zdHIuJHBhdGg9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19wYXRoX19cIik7U2suYnVpbHRpbi5zdHIuJHByZXBhcmU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19wcmVwYXJlX19cIik7U2suYnVpbHRpbi5zdHIuJHF1YWxuYW1lPW5ldyBTay5idWlsdGluLnN0cihcIl9fcXVhbG5hbWVfX1wiKTtTay5idWlsdGluLnN0ci4kcmVwcj1cbm5ldyBTay5idWlsdGluLnN0cihcIl9fcmVwcl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRyZXZlcnNlZD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3JldmVyc2VkX19cIik7U2suYnVpbHRpbi5zdHIuJHJvdW5kPW5ldyBTay5idWlsdGluLnN0cihcIl9fcm91bmRfX1wiKTtTay5idWlsdGluLnN0ci4kc2V0YXR0cj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3NldGF0dHJfX1wiKTtTay5idWlsdGluLnN0ci4kc2V0aXRlbT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3NldGl0ZW1fX1wiKTtTay5idWlsdGluLnN0ci4kc2xvdHM9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19zbG90c19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRzdHI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19zdHJfX1wiKTtTay5idWlsdGluLnN0ci4kc2V0bmFtZT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3NldF9uYW1lX19cIik7U2suYnVpbHRpbi5zdHIuJHRydW5jPW5ldyBTay5idWlsdGluLnN0cihcIl9fdHJ1bmNfX1wiKTtTay5idWlsdGluLnN0ci4kd3JpdGU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwid3JpdGVcIik7XG5Tay5taXNjZXZhbC5vcDJtZXRob2RfPXtFcTpTay5idWlsdGluLnN0ci4kZXEsTm90RXE6U2suYnVpbHRpbi5zdHIuJG5lLEd0OlNrLmJ1aWx0aW4uc3RyLiRndCxHdEU6U2suYnVpbHRpbi5zdHIuJGdlLEx0OlNrLmJ1aWx0aW4uc3RyLiRsdCxMdEU6U2suYnVpbHRpbi5zdHIuJGxlfX0sZnVuY3Rpb24oRixQLGIpe2Z1bmN0aW9uIGUoY2EsbGEsaWEsa2EsVSl7dGhpcy50eXBlPWNhO3RoaXMuc3RyaW5nPWxhO3RoaXMuc3RhcnQ9aWE7dGhpcy5lbmQ9a2E7dGhpcy5saW5lPVV9ZnVuY3Rpb24gZChjYSl7cmV0dXJuXCIoXCIrQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwifFwiKStcIilcIn1mdW5jdGlvbiBmKGNhKXtyZXR1cm4gZC5hcHBseShudWxsLGFyZ3VtZW50cykrXCI/XCJ9ZnVuY3Rpb24gaChjYSxsYSl7Zm9yKHZhciBpYT1jYS5sZW5ndGg7aWEtLTspaWYoY2FbaWFdPT09bGEpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcChjYSl7Y2E9Y2Eubm9ybWFsaXplKFwiTkZLQ1wiKTtcbnJldHVybiBFLnRlc3QoY2EpfWZ1bmN0aW9uIGcoKXtyZXR1cm5cIiBGUiBSRiBCciBCUiBGciByIEIgUiBiIGJSIGYgcmIgckIgRiBSZiBVIHJGIHUgUkIgYnIgZlIgZnIgcmYgUmJcIi5zcGxpdChcIiBcIil9ZnVuY3Rpb24gYShjYSl7Y2E/ZGVsZXRlIFNrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTW1wiPD5cIl06U2sudG9rZW4uRVhBQ1RfVE9LRU5fVFlQRVNbXCI8PlwiXT1Tay50b2tlbi50b2tlbnMuVF9OT1RFUVVBTDtBPU9iamVjdC5rZXlzKFNrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTKS5zb3J0KCk7Sj1kLmFwcGx5KHRoaXMsQS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKGxhKXtyZXR1cm4gbGEmJnUudGVzdChsYSk/bGEucmVwbGFjZShrLFwiXFxcXCQmXCIpOmxhfSkpO1E9ZChcIlxcXFxyP1xcXFxuXCIsSil9Yi5yKFApO0Y9e0NjOlwiXFxcXDAtXFxcXHgxRlxcXFx4N0YtXFxcXHg5RlwiLENmOlwiXFxcXHhBRFxcXFx1MDYwMC1cXFxcdTA2MDVcXFxcdTA2MUNcXFxcdTA2RERcXFxcdTA3MEZcXFxcdTA4RTJcXFxcdTE4MEVcXFxcdTIwMEItXFxcXHUyMDBGXFxcXHUyMDJBLVxcXFx1MjAyRVxcXFx1MjA2MC1cXFxcdTIwNjRcXFxcdTIwNjYtXFxcXHUyMDZGXFxcXHVGRUZGXFxcXHVGRkY5LVxcXFx1RkZGQlwiLFxuQ286XCJcXFxcdUUwMDAtXFxcXHVGOEZGXCIsQ3M6XCJcXFxcdUQ4MDAtXFxcXHVERkZGXCIsTGw6XCJhLXpcXFxceEI1XFxcXHhERi1cXFxceEY2XFxcXHhGOC1cXFxceEZGXFxcXHUwMTAxXFxcXHUwMTAzXFxcXHUwMTA1XFxcXHUwMTA3XFxcXHUwMTA5XFxcXHUwMTBCXFxcXHUwMTBEXFxcXHUwMTBGXFxcXHUwMTExXFxcXHUwMTEzXFxcXHUwMTE1XFxcXHUwMTE3XFxcXHUwMTE5XFxcXHUwMTFCXFxcXHUwMTFEXFxcXHUwMTFGXFxcXHUwMTIxXFxcXHUwMTIzXFxcXHUwMTI1XFxcXHUwMTI3XFxcXHUwMTI5XFxcXHUwMTJCXFxcXHUwMTJEXFxcXHUwMTJGXFxcXHUwMTMxXFxcXHUwMTMzXFxcXHUwMTM1XFxcXHUwMTM3XFxcXHUwMTM4XFxcXHUwMTNBXFxcXHUwMTNDXFxcXHUwMTNFXFxcXHUwMTQwXFxcXHUwMTQyXFxcXHUwMTQ0XFxcXHUwMTQ2XFxcXHUwMTQ4XFxcXHUwMTQ5XFxcXHUwMTRCXFxcXHUwMTREXFxcXHUwMTRGXFxcXHUwMTUxXFxcXHUwMTUzXFxcXHUwMTU1XFxcXHUwMTU3XFxcXHUwMTU5XFxcXHUwMTVCXFxcXHUwMTVEXFxcXHUwMTVGXFxcXHUwMTYxXFxcXHUwMTYzXFxcXHUwMTY1XFxcXHUwMTY3XFxcXHUwMTY5XFxcXHUwMTZCXFxcXHUwMTZEXFxcXHUwMTZGXFxcXHUwMTcxXFxcXHUwMTczXFxcXHUwMTc1XFxcXHUwMTc3XFxcXHUwMTdBXFxcXHUwMTdDXFxcXHUwMTdFLVxcXFx1MDE4MFxcXFx1MDE4M1xcXFx1MDE4NVxcXFx1MDE4OFxcXFx1MDE4Q1xcXFx1MDE4RFxcXFx1MDE5MlxcXFx1MDE5NVxcXFx1MDE5OS1cXFxcdTAxOUJcXFxcdTAxOUVcXFxcdTAxQTFcXFxcdTAxQTNcXFxcdTAxQTVcXFxcdTAxQThcXFxcdTAxQUFcXFxcdTAxQUJcXFxcdTAxQURcXFxcdTAxQjBcXFxcdTAxQjRcXFxcdTAxQjZcXFxcdTAxQjlcXFxcdTAxQkFcXFxcdTAxQkQtXFxcXHUwMUJGXFxcXHUwMUM2XFxcXHUwMUM5XFxcXHUwMUNDXFxcXHUwMUNFXFxcXHUwMUQwXFxcXHUwMUQyXFxcXHUwMUQ0XFxcXHUwMUQ2XFxcXHUwMUQ4XFxcXHUwMURBXFxcXHUwMURDXFxcXHUwMUREXFxcXHUwMURGXFxcXHUwMUUxXFxcXHUwMUUzXFxcXHUwMUU1XFxcXHUwMUU3XFxcXHUwMUU5XFxcXHUwMUVCXFxcXHUwMUVEXFxcXHUwMUVGXFxcXHUwMUYwXFxcXHUwMUYzXFxcXHUwMUY1XFxcXHUwMUY5XFxcXHUwMUZCXFxcXHUwMUZEXFxcXHUwMUZGXFxcXHUwMjAxXFxcXHUwMjAzXFxcXHUwMjA1XFxcXHUwMjA3XFxcXHUwMjA5XFxcXHUwMjBCXFxcXHUwMjBEXFxcXHUwMjBGXFxcXHUwMjExXFxcXHUwMjEzXFxcXHUwMjE1XFxcXHUwMjE3XFxcXHUwMjE5XFxcXHUwMjFCXFxcXHUwMjFEXFxcXHUwMjFGXFxcXHUwMjIxXFxcXHUwMjIzXFxcXHUwMjI1XFxcXHUwMjI3XFxcXHUwMjI5XFxcXHUwMjJCXFxcXHUwMjJEXFxcXHUwMjJGXFxcXHUwMjMxXFxcXHUwMjMzLVxcXFx1MDIzOVxcXFx1MDIzQ1xcXFx1MDIzRlxcXFx1MDI0MFxcXFx1MDI0MlxcXFx1MDI0N1xcXFx1MDI0OVxcXFx1MDI0QlxcXFx1MDI0RFxcXFx1MDI0Ri1cXFxcdTAyOTNcXFxcdTAyOTUtXFxcXHUwMkFGXFxcXHUwMzcxXFxcXHUwMzczXFxcXHUwMzc3XFxcXHUwMzdCLVxcXFx1MDM3RFxcXFx1MDM5MFxcXFx1MDNBQy1cXFxcdTAzQ0VcXFxcdTAzRDBcXFxcdTAzRDFcXFxcdTAzRDUtXFxcXHUwM0Q3XFxcXHUwM0Q5XFxcXHUwM0RCXFxcXHUwM0REXFxcXHUwM0RGXFxcXHUwM0UxXFxcXHUwM0UzXFxcXHUwM0U1XFxcXHUwM0U3XFxcXHUwM0U5XFxcXHUwM0VCXFxcXHUwM0VEXFxcXHUwM0VGLVxcXFx1MDNGM1xcXFx1MDNGNVxcXFx1MDNGOFxcXFx1MDNGQlxcXFx1MDNGQ1xcXFx1MDQzMC1cXFxcdTA0NUZcXFxcdTA0NjFcXFxcdTA0NjNcXFxcdTA0NjVcXFxcdTA0NjdcXFxcdTA0NjlcXFxcdTA0NkJcXFxcdTA0NkRcXFxcdTA0NkZcXFxcdTA0NzFcXFxcdTA0NzNcXFxcdTA0NzVcXFxcdTA0NzdcXFxcdTA0NzlcXFxcdTA0N0JcXFxcdTA0N0RcXFxcdTA0N0ZcXFxcdTA0ODFcXFxcdTA0OEJcXFxcdTA0OERcXFxcdTA0OEZcXFxcdTA0OTFcXFxcdTA0OTNcXFxcdTA0OTVcXFxcdTA0OTdcXFxcdTA0OTlcXFxcdTA0OUJcXFxcdTA0OURcXFxcdTA0OUZcXFxcdTA0QTFcXFxcdTA0QTNcXFxcdTA0QTVcXFxcdTA0QTdcXFxcdTA0QTlcXFxcdTA0QUJcXFxcdTA0QURcXFxcdTA0QUZcXFxcdTA0QjFcXFxcdTA0QjNcXFxcdTA0QjVcXFxcdTA0QjdcXFxcdTA0QjlcXFxcdTA0QkJcXFxcdTA0QkRcXFxcdTA0QkZcXFxcdTA0QzJcXFxcdTA0QzRcXFxcdTA0QzZcXFxcdTA0QzhcXFxcdTA0Q0FcXFxcdTA0Q0NcXFxcdTA0Q0VcXFxcdTA0Q0ZcXFxcdTA0RDFcXFxcdTA0RDNcXFxcdTA0RDVcXFxcdTA0RDdcXFxcdTA0RDlcXFxcdTA0REJcXFxcdTA0RERcXFxcdTA0REZcXFxcdTA0RTFcXFxcdTA0RTNcXFxcdTA0RTVcXFxcdTA0RTdcXFxcdTA0RTlcXFxcdTA0RUJcXFxcdTA0RURcXFxcdTA0RUZcXFxcdTA0RjFcXFxcdTA0RjNcXFxcdTA0RjVcXFxcdTA0RjdcXFxcdTA0RjlcXFxcdTA0RkJcXFxcdTA0RkRcXFxcdTA0RkZcXFxcdTA1MDFcXFxcdTA1MDNcXFxcdTA1MDVcXFxcdTA1MDdcXFxcdTA1MDlcXFxcdTA1MEJcXFxcdTA1MERcXFxcdTA1MEZcXFxcdTA1MTFcXFxcdTA1MTNcXFxcdTA1MTVcXFxcdTA1MTdcXFxcdTA1MTlcXFxcdTA1MUJcXFxcdTA1MURcXFxcdTA1MUZcXFxcdTA1MjFcXFxcdTA1MjNcXFxcdTA1MjVcXFxcdTA1MjdcXFxcdTA1MjlcXFxcdTA1MkJcXFxcdTA1MkRcXFxcdTA1MkZcXFxcdTA1NjAtXFxcXHUwNTg4XFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGRC1cXFxcdTEwRkZcXFxcdTEzRjgtXFxcXHUxM0ZEXFxcXHUxQzgwLVxcXFx1MUM4OFxcXFx1MUQwMC1cXFxcdTFEMkJcXFxcdTFENkItXFxcXHUxRDc3XFxcXHUxRDc5LVxcXFx1MUQ5QVxcXFx1MUUwMVxcXFx1MUUwM1xcXFx1MUUwNVxcXFx1MUUwN1xcXFx1MUUwOVxcXFx1MUUwQlxcXFx1MUUwRFxcXFx1MUUwRlxcXFx1MUUxMVxcXFx1MUUxM1xcXFx1MUUxNVxcXFx1MUUxN1xcXFx1MUUxOVxcXFx1MUUxQlxcXFx1MUUxRFxcXFx1MUUxRlxcXFx1MUUyMVxcXFx1MUUyM1xcXFx1MUUyNVxcXFx1MUUyN1xcXFx1MUUyOVxcXFx1MUUyQlxcXFx1MUUyRFxcXFx1MUUyRlxcXFx1MUUzMVxcXFx1MUUzM1xcXFx1MUUzNVxcXFx1MUUzN1xcXFx1MUUzOVxcXFx1MUUzQlxcXFx1MUUzRFxcXFx1MUUzRlxcXFx1MUU0MVxcXFx1MUU0M1xcXFx1MUU0NVxcXFx1MUU0N1xcXFx1MUU0OVxcXFx1MUU0QlxcXFx1MUU0RFxcXFx1MUU0RlxcXFx1MUU1MVxcXFx1MUU1M1xcXFx1MUU1NVxcXFx1MUU1N1xcXFx1MUU1OVxcXFx1MUU1QlxcXFx1MUU1RFxcXFx1MUU1RlxcXFx1MUU2MVxcXFx1MUU2M1xcXFx1MUU2NVxcXFx1MUU2N1xcXFx1MUU2OVxcXFx1MUU2QlxcXFx1MUU2RFxcXFx1MUU2RlxcXFx1MUU3MVxcXFx1MUU3M1xcXFx1MUU3NVxcXFx1MUU3N1xcXFx1MUU3OVxcXFx1MUU3QlxcXFx1MUU3RFxcXFx1MUU3RlxcXFx1MUU4MVxcXFx1MUU4M1xcXFx1MUU4NVxcXFx1MUU4N1xcXFx1MUU4OVxcXFx1MUU4QlxcXFx1MUU4RFxcXFx1MUU4RlxcXFx1MUU5MVxcXFx1MUU5M1xcXFx1MUU5NS1cXFxcdTFFOURcXFxcdTFFOUZcXFxcdTFFQTFcXFxcdTFFQTNcXFxcdTFFQTVcXFxcdTFFQTdcXFxcdTFFQTlcXFxcdTFFQUJcXFxcdTFFQURcXFxcdTFFQUZcXFxcdTFFQjFcXFxcdTFFQjNcXFxcdTFFQjVcXFxcdTFFQjdcXFxcdTFFQjlcXFxcdTFFQkJcXFxcdTFFQkRcXFxcdTFFQkZcXFxcdTFFQzFcXFxcdTFFQzNcXFxcdTFFQzVcXFxcdTFFQzdcXFxcdTFFQzlcXFxcdTFFQ0JcXFxcdTFFQ0RcXFxcdTFFQ0ZcXFxcdTFFRDFcXFxcdTFFRDNcXFxcdTFFRDVcXFxcdTFFRDdcXFxcdTFFRDlcXFxcdTFFREJcXFxcdTFFRERcXFxcdTFFREZcXFxcdTFFRTFcXFxcdTFFRTNcXFxcdTFFRTVcXFxcdTFFRTdcXFxcdTFFRTlcXFxcdTFFRUJcXFxcdTFFRURcXFxcdTFFRUZcXFxcdTFFRjFcXFxcdTFFRjNcXFxcdTFFRjVcXFxcdTFFRjdcXFxcdTFFRjlcXFxcdTFFRkJcXFxcdTFFRkRcXFxcdTFFRkYtXFxcXHUxRjA3XFxcXHUxRjEwLVxcXFx1MUYxNVxcXFx1MUYyMC1cXFxcdTFGMjdcXFxcdTFGMzAtXFxcXHUxRjM3XFxcXHUxRjQwLVxcXFx1MUY0NVxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNjAtXFxcXHUxRjY3XFxcXHUxRjcwLVxcXFx1MUY3RFxcXFx1MUY4MC1cXFxcdTFGODdcXFxcdTFGOTAtXFxcXHUxRjk3XFxcXHUxRkEwLVxcXFx1MUZBN1xcXFx1MUZCMC1cXFxcdTFGQjRcXFxcdTFGQjZcXFxcdTFGQjdcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2XFxcXHUxRkM3XFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENlxcXFx1MUZEN1xcXFx1MUZFMC1cXFxcdTFGRTdcXFxcdTFGRjItXFxcXHUxRkY0XFxcXHUxRkY2XFxcXHUxRkY3XFxcXHUyMTBBXFxcXHUyMTBFXFxcXHUyMTBGXFxcXHUyMTEzXFxcXHUyMTJGXFxcXHUyMTM0XFxcXHUyMTM5XFxcXHUyMTNDXFxcXHUyMTNEXFxcXHUyMTQ2LVxcXFx1MjE0OVxcXFx1MjE0RVxcXFx1MjE4NFxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjFcXFxcdTJDNjVcXFxcdTJDNjZcXFxcdTJDNjhcXFxcdTJDNkFcXFxcdTJDNkNcXFxcdTJDNzFcXFxcdTJDNzNcXFxcdTJDNzRcXFxcdTJDNzYtXFxcXHUyQzdCXFxcXHUyQzgxXFxcXHUyQzgzXFxcXHUyQzg1XFxcXHUyQzg3XFxcXHUyQzg5XFxcXHUyQzhCXFxcXHUyQzhEXFxcXHUyQzhGXFxcXHUyQzkxXFxcXHUyQzkzXFxcXHUyQzk1XFxcXHUyQzk3XFxcXHUyQzk5XFxcXHUyQzlCXFxcXHUyQzlEXFxcXHUyQzlGXFxcXHUyQ0ExXFxcXHUyQ0EzXFxcXHUyQ0E1XFxcXHUyQ0E3XFxcXHUyQ0E5XFxcXHUyQ0FCXFxcXHUyQ0FEXFxcXHUyQ0FGXFxcXHUyQ0IxXFxcXHUyQ0IzXFxcXHUyQ0I1XFxcXHUyQ0I3XFxcXHUyQ0I5XFxcXHUyQ0JCXFxcXHUyQ0JEXFxcXHUyQ0JGXFxcXHUyQ0MxXFxcXHUyQ0MzXFxcXHUyQ0M1XFxcXHUyQ0M3XFxcXHUyQ0M5XFxcXHUyQ0NCXFxcXHUyQ0NEXFxcXHUyQ0NGXFxcXHUyQ0QxXFxcXHUyQ0QzXFxcXHUyQ0Q1XFxcXHUyQ0Q3XFxcXHUyQ0Q5XFxcXHUyQ0RCXFxcXHUyQ0REXFxcXHUyQ0RGXFxcXHUyQ0UxXFxcXHUyQ0UzXFxcXHUyQ0U0XFxcXHUyQ0VDXFxcXHUyQ0VFXFxcXHUyQ0YzXFxcXHUyRDAwLVxcXFx1MkQyNVxcXFx1MkQyN1xcXFx1MkQyRFxcXFx1QTY0MVxcXFx1QTY0M1xcXFx1QTY0NVxcXFx1QTY0N1xcXFx1QTY0OVxcXFx1QTY0QlxcXFx1QTY0RFxcXFx1QTY0RlxcXFx1QTY1MVxcXFx1QTY1M1xcXFx1QTY1NVxcXFx1QTY1N1xcXFx1QTY1OVxcXFx1QTY1QlxcXFx1QTY1RFxcXFx1QTY1RlxcXFx1QTY2MVxcXFx1QTY2M1xcXFx1QTY2NVxcXFx1QTY2N1xcXFx1QTY2OVxcXFx1QTY2QlxcXFx1QTY2RFxcXFx1QTY4MVxcXFx1QTY4M1xcXFx1QTY4NVxcXFx1QTY4N1xcXFx1QTY4OVxcXFx1QTY4QlxcXFx1QTY4RFxcXFx1QTY4RlxcXFx1QTY5MVxcXFx1QTY5M1xcXFx1QTY5NVxcXFx1QTY5N1xcXFx1QTY5OVxcXFx1QTY5QlxcXFx1QTcyM1xcXFx1QTcyNVxcXFx1QTcyN1xcXFx1QTcyOVxcXFx1QTcyQlxcXFx1QTcyRFxcXFx1QTcyRi1cXFxcdUE3MzFcXFxcdUE3MzNcXFxcdUE3MzVcXFxcdUE3MzdcXFxcdUE3MzlcXFxcdUE3M0JcXFxcdUE3M0RcXFxcdUE3M0ZcXFxcdUE3NDFcXFxcdUE3NDNcXFxcdUE3NDVcXFxcdUE3NDdcXFxcdUE3NDlcXFxcdUE3NEJcXFxcdUE3NERcXFxcdUE3NEZcXFxcdUE3NTFcXFxcdUE3NTNcXFxcdUE3NTVcXFxcdUE3NTdcXFxcdUE3NTlcXFxcdUE3NUJcXFxcdUE3NURcXFxcdUE3NUZcXFxcdUE3NjFcXFxcdUE3NjNcXFxcdUE3NjVcXFxcdUE3NjdcXFxcdUE3NjlcXFxcdUE3NkJcXFxcdUE3NkRcXFxcdUE3NkZcXFxcdUE3NzEtXFxcXHVBNzc4XFxcXHVBNzdBXFxcXHVBNzdDXFxcXHVBNzdGXFxcXHVBNzgxXFxcXHVBNzgzXFxcXHVBNzg1XFxcXHVBNzg3XFxcXHVBNzhDXFxcXHVBNzhFXFxcXHVBNzkxXFxcXHVBNzkzLVxcXFx1QTc5NVxcXFx1QTc5N1xcXFx1QTc5OVxcXFx1QTc5QlxcXFx1QTc5RFxcXFx1QTc5RlxcXFx1QTdBMVxcXFx1QTdBM1xcXFx1QTdBNVxcXFx1QTdBN1xcXFx1QTdBOVxcXFx1QTdBRlxcXFx1QTdCNVxcXFx1QTdCN1xcXFx1QTdCOVxcXFx1QTdCQlxcXFx1QTdCRFxcXFx1QTdCRlxcXFx1QTdDM1xcXFx1QTdDOFxcXFx1QTdDQVxcXFx1QTdGNlxcXFx1QTdGQVxcXFx1QUIzMC1cXFxcdUFCNUFcXFxcdUFCNjAtXFxcXHVBQjY4XFxcXHVBQjcwLVxcXFx1QUJCRlxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGRjQxLVxcXFx1RkY1QVwiLFxuTG06XCJcXFxcdTAyQjAtXFxcXHUwMkMxXFxcXHUwMkM2LVxcXFx1MDJEMVxcXFx1MDJFMC1cXFxcdTAyRTRcXFxcdTAyRUNcXFxcdTAyRUVcXFxcdTAzNzRcXFxcdTAzN0FcXFxcdTA1NTlcXFxcdTA2NDBcXFxcdTA2RTVcXFxcdTA2RTZcXFxcdTA3RjRcXFxcdTA3RjVcXFxcdTA3RkFcXFxcdTA4MUFcXFxcdTA4MjRcXFxcdTA4MjhcXFxcdTA5NzFcXFxcdTBFNDZcXFxcdTBFQzZcXFxcdTEwRkNcXFxcdTE3RDdcXFxcdTE4NDNcXFxcdTFBQTdcXFxcdTFDNzgtXFxcXHUxQzdEXFxcXHUxRDJDLVxcXFx1MUQ2QVxcXFx1MUQ3OFxcXFx1MUQ5Qi1cXFxcdTFEQkZcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyQzdDXFxcXHUyQzdEXFxcXHUyRDZGXFxcXHUyRTJGXFxcXHUzMDA1XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzQlxcXFx1MzA5RFxcXFx1MzA5RVxcXFx1MzBGQy1cXFxcdTMwRkVcXFxcdUEwMTVcXFxcdUE0RjgtXFxcXHVBNEZEXFxcXHVBNjBDXFxcXHVBNjdGXFxcXHVBNjlDXFxcXHVBNjlEXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTc3MFxcXFx1QTc4OFxcXFx1QTdGOFxcXFx1QTdGOVxcXFx1QTlDRlxcXFx1QTlFNlxcXFx1QUE3MFxcXFx1QUFERFxcXFx1QUFGM1xcXFx1QUFGNFxcXFx1QUI1Qy1cXFxcdUFCNUZcXFxcdUFCNjlcXFxcdUZGNzBcXFxcdUZGOUVcXFxcdUZGOUZcIixcbkxvOlwiXFxcXHhBQVxcXFx4QkFcXFxcdTAxQkJcXFxcdTAxQzAtXFxcXHUwMUMzXFxcXHUwMjk0XFxcXHUwNUQwLVxcXFx1MDVFQVxcXFx1MDVFRi1cXFxcdTA1RjJcXFxcdTA2MjAtXFxcXHUwNjNGXFxcXHUwNjQxLVxcXFx1MDY0QVxcXFx1MDY2RVxcXFx1MDY2RlxcXFx1MDY3MS1cXFxcdTA2RDNcXFxcdTA2RDVcXFxcdTA2RUVcXFxcdTA2RUZcXFxcdTA2RkEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyRlxcXFx1MDc0RC1cXFxcdTA3QTVcXFxcdTA3QjFcXFxcdTA3Q0EtXFxcXHUwN0VBXFxcXHUwODAwLVxcXFx1MDgxNVxcXFx1MDg0MC1cXFxcdTA4NThcXFxcdTA4NjAtXFxcXHUwODZBXFxcXHUwOEEwLVxcXFx1MDhCNFxcXFx1MDhCNi1cXFxcdTA4QzdcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNEXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3Mi1cXFxcdTA5ODBcXFxcdTA5ODUtXFxcXHUwOThDXFxcXHUwOThGXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlBOFxcXFx1MDlBQS1cXFxcdTA5QjBcXFxcdTA5QjJcXFxcdTA5QjYtXFxcXHUwOUI5XFxcXHUwOUJEXFxcXHUwOUNFXFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFMVxcXFx1MDlGMFxcXFx1MDlGMVxcXFx1MDlGQ1xcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEE1OS1cXFxcdTBBNUNcXFxcdTBBNUVcXFxcdTBBNzItXFxcXHUwQTc0XFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkRcXFxcdTBBRDBcXFxcdTBBRTBcXFxcdTBBRTFcXFxcdTBBRjlcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNEXFxcXHUwQjVDXFxcXHUwQjVEXFxcXHUwQjVGLVxcXFx1MEI2MVxcXFx1MEI3MVxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkQwXFxcXHUwQzA1LVxcXFx1MEMwQ1xcXFx1MEMwRS1cXFxcdTBDMTBcXFxcdTBDMTItXFxcXHUwQzI4XFxcXHUwQzJBLVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OC1cXFxcdTBDNUFcXFxcdTBDNjBcXFxcdTBDNjFcXFxcdTBDODBcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCRFxcXFx1MENERVxcXFx1MENFMFxcXFx1MENFMVxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwNC1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRFxcXFx1MEQ0RVxcXFx1MEQ1NC1cXFxcdTBENTZcXFxcdTBENUYtXFxcXHUwRDYxXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBFMDEtXFxcXHUwRTMwXFxcXHUwRTMyXFxcXHUwRTMzXFxcXHUwRTQwLVxcXFx1MEU0NVxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4Ni1cXFxcdTBFOEFcXFxcdTBFOEMtXFxcXHUwRUEzXFxcXHUwRUE1XFxcXHUwRUE3LVxcXFx1MEVCMFxcXFx1MEVCMlxcXFx1MEVCM1xcXFx1MEVCRFxcXFx1MEVDMC1cXFxcdTBFQzRcXFxcdTBFREMtXFxcXHUwRURGXFxcXHUwRjAwXFxcXHUwRjQwLVxcXFx1MEY0N1xcXFx1MEY0OS1cXFxcdTBGNkNcXFxcdTBGODgtXFxcXHUwRjhDXFxcXHUxMDAwLVxcXFx1MTAyQVxcXFx1MTAzRlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNUEtXFxcXHUxMDVEXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZFLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOEVcXFxcdTExMDAtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTE0MDEtXFxcXHUxNjZDXFxcXHUxNjZGLVxcXFx1MTY3RlxcXFx1MTY4MS1cXFxcdTE2OUFcXFxcdTE2QTAtXFxcXHUxNkVBXFxcXHUxNkYxLVxcXFx1MTZGOFxcXFx1MTcwMC1cXFxcdTE3MENcXFxcdTE3MEUtXFxcXHUxNzExXFxcXHUxNzIwLVxcXFx1MTczMVxcXFx1MTc0MC1cXFxcdTE3NTFcXFxcdTE3NjAtXFxcXHUxNzZDXFxcXHUxNzZFLVxcXFx1MTc3MFxcXFx1MTc4MC1cXFxcdTE3QjNcXFxcdTE3RENcXFxcdTE4MjAtXFxcXHUxODQyXFxcXHUxODQ0LVxcXFx1MTg3OFxcXFx1MTg4MC1cXFxcdTE4ODRcXFxcdTE4ODctXFxcXHUxOEE4XFxcXHUxOEFBXFxcXHUxOEIwLVxcXFx1MThGNVxcXFx1MTkwMC1cXFxcdTE5MUVcXFxcdTE5NTAtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QUJcXFxcdTE5QjAtXFxcXHUxOUM5XFxcXHUxQTAwLVxcXFx1MUExNlxcXFx1MUEyMC1cXFxcdTFBNTRcXFxcdTFCMDUtXFxcXHUxQjMzXFxcXHUxQjQ1LVxcXFx1MUI0QlxcXFx1MUI4My1cXFxcdTFCQTBcXFxcdTFCQUVcXFxcdTFCQUZcXFxcdTFCQkEtXFxcXHUxQkU1XFxcXHUxQzAwLVxcXFx1MUMyM1xcXFx1MUM0RC1cXFxcdTFDNEZcXFxcdTFDNUEtXFxcXHUxQzc3XFxcXHUxQ0U5LVxcXFx1MUNFQ1xcXFx1MUNFRS1cXFxcdTFDRjNcXFxcdTFDRjVcXFxcdTFDRjZcXFxcdTFDRkFcXFxcdTIxMzUtXFxcXHUyMTM4XFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ4MC1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MzAwNlxcXFx1MzAzQ1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRlxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJGXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQkZcXFxcdTRFMDAtXFxcXHU5RkZDXFxcXHVBMDAwLVxcXFx1QTAxNFxcXFx1QTAxNi1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEY3XFxcXHVBNTAwLVxcXFx1QTYwQlxcXFx1QTYxMC1cXFxcdUE2MUZcXFxcdUE2MkFcXFxcdUE2MkJcXFxcdUE2NkVcXFxcdUE2QTAtXFxcXHVBNkU1XFxcXHVBNzhGXFxcXHVBN0Y3XFxcXHVBN0ZCLVxcXFx1QTgwMVxcXFx1QTgwMy1cXFxcdUE4MDVcXFxcdUE4MDctXFxcXHVBODBBXFxcXHVBODBDLVxcXFx1QTgyMlxcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODItXFxcXHVBOEIzXFxcXHVBOEYyLVxcXFx1QThGN1xcXFx1QThGQlxcXFx1QThGRFxcXFx1QThGRVxcXFx1QTkwQS1cXFxcdUE5MjVcXFxcdUE5MzAtXFxcXHVBOTQ2XFxcXHVBOTYwLVxcXFx1QTk3Q1xcXFx1QTk4NC1cXFxcdUE5QjJcXFxcdUE5RTAtXFxcXHVBOUU0XFxcXHVBOUU3LVxcXFx1QTlFRlxcXFx1QTlGQS1cXFxcdUE5RkVcXFxcdUFBMDAtXFxcXHVBQTI4XFxcXHVBQTQwLVxcXFx1QUE0MlxcXFx1QUE0NC1cXFxcdUFBNEJcXFxcdUFBNjAtXFxcXHVBQTZGXFxcXHVBQTcxLVxcXFx1QUE3NlxcXFx1QUE3QVxcXFx1QUE3RS1cXFxcdUFBQUZcXFxcdUFBQjFcXFxcdUFBQjVcXFxcdUFBQjZcXFxcdUFBQjktXFxcXHVBQUJEXFxcXHVBQUMwXFxcXHVBQUMyXFxcXHVBQURCXFxcXHVBQURDXFxcXHVBQUUwLVxcXFx1QUFFQVxcXFx1QUFGMlxcXFx1QUIwMS1cXFxcdUFCMDZcXFxcdUFCMDktXFxcXHVBQjBFXFxcXHVBQjExLVxcXFx1QUIxNlxcXFx1QUIyMC1cXFxcdUFCMjZcXFxcdUFCMjgtXFxcXHVBQjJFXFxcXHVBQkMwLVxcXFx1QUJFMlxcXFx1QUMwMC1cXFxcdUQ3QTNcXFxcdUQ3QjAtXFxcXHVEN0M2XFxcXHVEN0NCLVxcXFx1RDdGQlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjFEXFxcXHVGQjFGLVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkY2Ni1cXFxcdUZGNkZcXFxcdUZGNzEtXFxcXHVGRjlEXFxcXHVGRkEwLVxcXFx1RkZCRVxcXFx1RkZDMi1cXFxcdUZGQzdcXFxcdUZGQ0EtXFxcXHVGRkNGXFxcXHVGRkQyLVxcXFx1RkZEN1xcXFx1RkZEQS1cXFxcdUZGRENcIixcbkx0OlwiXFxcXHUwMUM1XFxcXHUwMUM4XFxcXHUwMUNCXFxcXHUwMUYyXFxcXHUxRjg4LVxcXFx1MUY4RlxcXFx1MUY5OC1cXFxcdTFGOUZcXFxcdTFGQTgtXFxcXHUxRkFGXFxcXHUxRkJDXFxcXHUxRkNDXFxcXHUxRkZDXCIsTHU6XCJBLVpcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4REVcXFxcdTAxMDBcXFxcdTAxMDJcXFxcdTAxMDRcXFxcdTAxMDZcXFxcdTAxMDhcXFxcdTAxMEFcXFxcdTAxMENcXFxcdTAxMEVcXFxcdTAxMTBcXFxcdTAxMTJcXFxcdTAxMTRcXFxcdTAxMTZcXFxcdTAxMThcXFxcdTAxMUFcXFxcdTAxMUNcXFxcdTAxMUVcXFxcdTAxMjBcXFxcdTAxMjJcXFxcdTAxMjRcXFxcdTAxMjZcXFxcdTAxMjhcXFxcdTAxMkFcXFxcdTAxMkNcXFxcdTAxMkVcXFxcdTAxMzBcXFxcdTAxMzJcXFxcdTAxMzRcXFxcdTAxMzZcXFxcdTAxMzlcXFxcdTAxM0JcXFxcdTAxM0RcXFxcdTAxM0ZcXFxcdTAxNDFcXFxcdTAxNDNcXFxcdTAxNDVcXFxcdTAxNDdcXFxcdTAxNEFcXFxcdTAxNENcXFxcdTAxNEVcXFxcdTAxNTBcXFxcdTAxNTJcXFxcdTAxNTRcXFxcdTAxNTZcXFxcdTAxNThcXFxcdTAxNUFcXFxcdTAxNUNcXFxcdTAxNUVcXFxcdTAxNjBcXFxcdTAxNjJcXFxcdTAxNjRcXFxcdTAxNjZcXFxcdTAxNjhcXFxcdTAxNkFcXFxcdTAxNkNcXFxcdTAxNkVcXFxcdTAxNzBcXFxcdTAxNzJcXFxcdTAxNzRcXFxcdTAxNzZcXFxcdTAxNzhcXFxcdTAxNzlcXFxcdTAxN0JcXFxcdTAxN0RcXFxcdTAxODFcXFxcdTAxODJcXFxcdTAxODRcXFxcdTAxODZcXFxcdTAxODdcXFxcdTAxODktXFxcXHUwMThCXFxcXHUwMThFLVxcXFx1MDE5MVxcXFx1MDE5M1xcXFx1MDE5NFxcXFx1MDE5Ni1cXFxcdTAxOThcXFxcdTAxOUNcXFxcdTAxOURcXFxcdTAxOUZcXFxcdTAxQTBcXFxcdTAxQTJcXFxcdTAxQTRcXFxcdTAxQTZcXFxcdTAxQTdcXFxcdTAxQTlcXFxcdTAxQUNcXFxcdTAxQUVcXFxcdTAxQUZcXFxcdTAxQjEtXFxcXHUwMUIzXFxcXHUwMUI1XFxcXHUwMUI3XFxcXHUwMUI4XFxcXHUwMUJDXFxcXHUwMUM0XFxcXHUwMUM3XFxcXHUwMUNBXFxcXHUwMUNEXFxcXHUwMUNGXFxcXHUwMUQxXFxcXHUwMUQzXFxcXHUwMUQ1XFxcXHUwMUQ3XFxcXHUwMUQ5XFxcXHUwMURCXFxcXHUwMURFXFxcXHUwMUUwXFxcXHUwMUUyXFxcXHUwMUU0XFxcXHUwMUU2XFxcXHUwMUU4XFxcXHUwMUVBXFxcXHUwMUVDXFxcXHUwMUVFXFxcXHUwMUYxXFxcXHUwMUY0XFxcXHUwMUY2LVxcXFx1MDFGOFxcXFx1MDFGQVxcXFx1MDFGQ1xcXFx1MDFGRVxcXFx1MDIwMFxcXFx1MDIwMlxcXFx1MDIwNFxcXFx1MDIwNlxcXFx1MDIwOFxcXFx1MDIwQVxcXFx1MDIwQ1xcXFx1MDIwRVxcXFx1MDIxMFxcXFx1MDIxMlxcXFx1MDIxNFxcXFx1MDIxNlxcXFx1MDIxOFxcXFx1MDIxQVxcXFx1MDIxQ1xcXFx1MDIxRVxcXFx1MDIyMFxcXFx1MDIyMlxcXFx1MDIyNFxcXFx1MDIyNlxcXFx1MDIyOFxcXFx1MDIyQVxcXFx1MDIyQ1xcXFx1MDIyRVxcXFx1MDIzMFxcXFx1MDIzMlxcXFx1MDIzQVxcXFx1MDIzQlxcXFx1MDIzRFxcXFx1MDIzRVxcXFx1MDI0MVxcXFx1MDI0My1cXFxcdTAyNDZcXFxcdTAyNDhcXFxcdTAyNEFcXFxcdTAyNENcXFxcdTAyNEVcXFxcdTAzNzBcXFxcdTAzNzJcXFxcdTAzNzZcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFXFxcXHUwMzhGXFxcXHUwMzkxLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzQUJcXFxcdTAzQ0ZcXFxcdTAzRDItXFxcXHUwM0Q0XFxcXHUwM0Q4XFxcXHUwM0RBXFxcXHUwM0RDXFxcXHUwM0RFXFxcXHUwM0UwXFxcXHUwM0UyXFxcXHUwM0U0XFxcXHUwM0U2XFxcXHUwM0U4XFxcXHUwM0VBXFxcXHUwM0VDXFxcXHUwM0VFXFxcXHUwM0Y0XFxcXHUwM0Y3XFxcXHUwM0Y5XFxcXHUwM0ZBXFxcXHUwM0ZELVxcXFx1MDQyRlxcXFx1MDQ2MFxcXFx1MDQ2MlxcXFx1MDQ2NFxcXFx1MDQ2NlxcXFx1MDQ2OFxcXFx1MDQ2QVxcXFx1MDQ2Q1xcXFx1MDQ2RVxcXFx1MDQ3MFxcXFx1MDQ3MlxcXFx1MDQ3NFxcXFx1MDQ3NlxcXFx1MDQ3OFxcXFx1MDQ3QVxcXFx1MDQ3Q1xcXFx1MDQ3RVxcXFx1MDQ4MFxcXFx1MDQ4QVxcXFx1MDQ4Q1xcXFx1MDQ4RVxcXFx1MDQ5MFxcXFx1MDQ5MlxcXFx1MDQ5NFxcXFx1MDQ5NlxcXFx1MDQ5OFxcXFx1MDQ5QVxcXFx1MDQ5Q1xcXFx1MDQ5RVxcXFx1MDRBMFxcXFx1MDRBMlxcXFx1MDRBNFxcXFx1MDRBNlxcXFx1MDRBOFxcXFx1MDRBQVxcXFx1MDRBQ1xcXFx1MDRBRVxcXFx1MDRCMFxcXFx1MDRCMlxcXFx1MDRCNFxcXFx1MDRCNlxcXFx1MDRCOFxcXFx1MDRCQVxcXFx1MDRCQ1xcXFx1MDRCRVxcXFx1MDRDMFxcXFx1MDRDMVxcXFx1MDRDM1xcXFx1MDRDNVxcXFx1MDRDN1xcXFx1MDRDOVxcXFx1MDRDQlxcXFx1MDRDRFxcXFx1MDREMFxcXFx1MDREMlxcXFx1MDRENFxcXFx1MDRENlxcXFx1MDREOFxcXFx1MDREQVxcXFx1MDREQ1xcXFx1MDRERVxcXFx1MDRFMFxcXFx1MDRFMlxcXFx1MDRFNFxcXFx1MDRFNlxcXFx1MDRFOFxcXFx1MDRFQVxcXFx1MDRFQ1xcXFx1MDRFRVxcXFx1MDRGMFxcXFx1MDRGMlxcXFx1MDRGNFxcXFx1MDRGNlxcXFx1MDRGOFxcXFx1MDRGQVxcXFx1MDRGQ1xcXFx1MDRGRVxcXFx1MDUwMFxcXFx1MDUwMlxcXFx1MDUwNFxcXFx1MDUwNlxcXFx1MDUwOFxcXFx1MDUwQVxcXFx1MDUwQ1xcXFx1MDUwRVxcXFx1MDUxMFxcXFx1MDUxMlxcXFx1MDUxNFxcXFx1MDUxNlxcXFx1MDUxOFxcXFx1MDUxQVxcXFx1MDUxQ1xcXFx1MDUxRVxcXFx1MDUyMFxcXFx1MDUyMlxcXFx1MDUyNFxcXFx1MDUyNlxcXFx1MDUyOFxcXFx1MDUyQVxcXFx1MDUyQ1xcXFx1MDUyRVxcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEM3XFxcXHUxMENEXFxcXHUxM0EwLVxcXFx1MTNGNVxcXFx1MUM5MC1cXFxcdTFDQkFcXFxcdTFDQkQtXFxcXHUxQ0JGXFxcXHUxRTAwXFxcXHUxRTAyXFxcXHUxRTA0XFxcXHUxRTA2XFxcXHUxRTA4XFxcXHUxRTBBXFxcXHUxRTBDXFxcXHUxRTBFXFxcXHUxRTEwXFxcXHUxRTEyXFxcXHUxRTE0XFxcXHUxRTE2XFxcXHUxRTE4XFxcXHUxRTFBXFxcXHUxRTFDXFxcXHUxRTFFXFxcXHUxRTIwXFxcXHUxRTIyXFxcXHUxRTI0XFxcXHUxRTI2XFxcXHUxRTI4XFxcXHUxRTJBXFxcXHUxRTJDXFxcXHUxRTJFXFxcXHUxRTMwXFxcXHUxRTMyXFxcXHUxRTM0XFxcXHUxRTM2XFxcXHUxRTM4XFxcXHUxRTNBXFxcXHUxRTNDXFxcXHUxRTNFXFxcXHUxRTQwXFxcXHUxRTQyXFxcXHUxRTQ0XFxcXHUxRTQ2XFxcXHUxRTQ4XFxcXHUxRTRBXFxcXHUxRTRDXFxcXHUxRTRFXFxcXHUxRTUwXFxcXHUxRTUyXFxcXHUxRTU0XFxcXHUxRTU2XFxcXHUxRTU4XFxcXHUxRTVBXFxcXHUxRTVDXFxcXHUxRTVFXFxcXHUxRTYwXFxcXHUxRTYyXFxcXHUxRTY0XFxcXHUxRTY2XFxcXHUxRTY4XFxcXHUxRTZBXFxcXHUxRTZDXFxcXHUxRTZFXFxcXHUxRTcwXFxcXHUxRTcyXFxcXHUxRTc0XFxcXHUxRTc2XFxcXHUxRTc4XFxcXHUxRTdBXFxcXHUxRTdDXFxcXHUxRTdFXFxcXHUxRTgwXFxcXHUxRTgyXFxcXHUxRTg0XFxcXHUxRTg2XFxcXHUxRTg4XFxcXHUxRThBXFxcXHUxRThDXFxcXHUxRThFXFxcXHUxRTkwXFxcXHUxRTkyXFxcXHUxRTk0XFxcXHUxRTlFXFxcXHUxRUEwXFxcXHUxRUEyXFxcXHUxRUE0XFxcXHUxRUE2XFxcXHUxRUE4XFxcXHUxRUFBXFxcXHUxRUFDXFxcXHUxRUFFXFxcXHUxRUIwXFxcXHUxRUIyXFxcXHUxRUI0XFxcXHUxRUI2XFxcXHUxRUI4XFxcXHUxRUJBXFxcXHUxRUJDXFxcXHUxRUJFXFxcXHUxRUMwXFxcXHUxRUMyXFxcXHUxRUM0XFxcXHUxRUM2XFxcXHUxRUM4XFxcXHUxRUNBXFxcXHUxRUNDXFxcXHUxRUNFXFxcXHUxRUQwXFxcXHUxRUQyXFxcXHUxRUQ0XFxcXHUxRUQ2XFxcXHUxRUQ4XFxcXHUxRURBXFxcXHUxRURDXFxcXHUxRURFXFxcXHUxRUUwXFxcXHUxRUUyXFxcXHUxRUU0XFxcXHUxRUU2XFxcXHUxRUU4XFxcXHUxRUVBXFxcXHUxRUVDXFxcXHUxRUVFXFxcXHUxRUYwXFxcXHUxRUYyXFxcXHUxRUY0XFxcXHUxRUY2XFxcXHUxRUY4XFxcXHUxRUZBXFxcXHUxRUZDXFxcXHUxRUZFXFxcXHUxRjA4LVxcXFx1MUYwRlxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjgtXFxcXHUxRjJGXFxcXHUxRjM4LVxcXFx1MUYzRlxcXFx1MUY0OC1cXFxcdTFGNERcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUZcXFxcdTFGNjgtXFxcXHUxRjZGXFxcXHUxRkI4LVxcXFx1MUZCQlxcXFx1MUZDOC1cXFxcdTFGQ0JcXFxcdTFGRDgtXFxcXHUxRkRCXFxcXHUxRkU4LVxcXFx1MUZFQ1xcXFx1MUZGOC1cXFxcdTFGRkJcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMEItXFxcXHUyMTBEXFxcXHUyMTEwLVxcXFx1MjExMlxcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTMwLVxcXFx1MjEzM1xcXFx1MjEzRVxcXFx1MjEzRlxcXFx1MjE0NVxcXFx1MjE4M1xcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDNjBcXFxcdTJDNjItXFxcXHUyQzY0XFxcXHUyQzY3XFxcXHUyQzY5XFxcXHUyQzZCXFxcXHUyQzZELVxcXFx1MkM3MFxcXFx1MkM3MlxcXFx1MkM3NVxcXFx1MkM3RS1cXFxcdTJDODBcXFxcdTJDODJcXFxcdTJDODRcXFxcdTJDODZcXFxcdTJDODhcXFxcdTJDOEFcXFxcdTJDOENcXFxcdTJDOEVcXFxcdTJDOTBcXFxcdTJDOTJcXFxcdTJDOTRcXFxcdTJDOTZcXFxcdTJDOThcXFxcdTJDOUFcXFxcdTJDOUNcXFxcdTJDOUVcXFxcdTJDQTBcXFxcdTJDQTJcXFxcdTJDQTRcXFxcdTJDQTZcXFxcdTJDQThcXFxcdTJDQUFcXFxcdTJDQUNcXFxcdTJDQUVcXFxcdTJDQjBcXFxcdTJDQjJcXFxcdTJDQjRcXFxcdTJDQjZcXFxcdTJDQjhcXFxcdTJDQkFcXFxcdTJDQkNcXFxcdTJDQkVcXFxcdTJDQzBcXFxcdTJDQzJcXFxcdTJDQzRcXFxcdTJDQzZcXFxcdTJDQzhcXFxcdTJDQ0FcXFxcdTJDQ0NcXFxcdTJDQ0VcXFxcdTJDRDBcXFxcdTJDRDJcXFxcdTJDRDRcXFxcdTJDRDZcXFxcdTJDRDhcXFxcdTJDREFcXFxcdTJDRENcXFxcdTJDREVcXFxcdTJDRTBcXFxcdTJDRTJcXFxcdTJDRUJcXFxcdTJDRURcXFxcdTJDRjJcXFxcdUE2NDBcXFxcdUE2NDJcXFxcdUE2NDRcXFxcdUE2NDZcXFxcdUE2NDhcXFxcdUE2NEFcXFxcdUE2NENcXFxcdUE2NEVcXFxcdUE2NTBcXFxcdUE2NTJcXFxcdUE2NTRcXFxcdUE2NTZcXFxcdUE2NThcXFxcdUE2NUFcXFxcdUE2NUNcXFxcdUE2NUVcXFxcdUE2NjBcXFxcdUE2NjJcXFxcdUE2NjRcXFxcdUE2NjZcXFxcdUE2NjhcXFxcdUE2NkFcXFxcdUE2NkNcXFxcdUE2ODBcXFxcdUE2ODJcXFxcdUE2ODRcXFxcdUE2ODZcXFxcdUE2ODhcXFxcdUE2OEFcXFxcdUE2OENcXFxcdUE2OEVcXFxcdUE2OTBcXFxcdUE2OTJcXFxcdUE2OTRcXFxcdUE2OTZcXFxcdUE2OThcXFxcdUE2OUFcXFxcdUE3MjJcXFxcdUE3MjRcXFxcdUE3MjZcXFxcdUE3MjhcXFxcdUE3MkFcXFxcdUE3MkNcXFxcdUE3MkVcXFxcdUE3MzJcXFxcdUE3MzRcXFxcdUE3MzZcXFxcdUE3MzhcXFxcdUE3M0FcXFxcdUE3M0NcXFxcdUE3M0VcXFxcdUE3NDBcXFxcdUE3NDJcXFxcdUE3NDRcXFxcdUE3NDZcXFxcdUE3NDhcXFxcdUE3NEFcXFxcdUE3NENcXFxcdUE3NEVcXFxcdUE3NTBcXFxcdUE3NTJcXFxcdUE3NTRcXFxcdUE3NTZcXFxcdUE3NThcXFxcdUE3NUFcXFxcdUE3NUNcXFxcdUE3NUVcXFxcdUE3NjBcXFxcdUE3NjJcXFxcdUE3NjRcXFxcdUE3NjZcXFxcdUE3NjhcXFxcdUE3NkFcXFxcdUE3NkNcXFxcdUE3NkVcXFxcdUE3NzlcXFxcdUE3N0JcXFxcdUE3N0RcXFxcdUE3N0VcXFxcdUE3ODBcXFxcdUE3ODJcXFxcdUE3ODRcXFxcdUE3ODZcXFxcdUE3OEJcXFxcdUE3OERcXFxcdUE3OTBcXFxcdUE3OTJcXFxcdUE3OTZcXFxcdUE3OThcXFxcdUE3OUFcXFxcdUE3OUNcXFxcdUE3OUVcXFxcdUE3QTBcXFxcdUE3QTJcXFxcdUE3QTRcXFxcdUE3QTZcXFxcdUE3QThcXFxcdUE3QUEtXFxcXHVBN0FFXFxcXHVBN0IwLVxcXFx1QTdCNFxcXFx1QTdCNlxcXFx1QTdCOFxcXFx1QTdCQVxcXFx1QTdCQ1xcXFx1QTdCRVxcXFx1QTdDMlxcXFx1QTdDNC1cXFxcdUE3QzdcXFxcdUE3QzlcXFxcdUE3RjVcXFxcdUZGMjEtXFxcXHVGRjNBXCIsXG5NOlwiXFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MDQ4My1cXFxcdTA0ODlcXFxcdTA1OTEtXFxcXHUwNUJEXFxcXHUwNUJGXFxcXHUwNUMxXFxcXHUwNUMyXFxcXHUwNUM0XFxcXHUwNUM1XFxcXHUwNUM3XFxcXHUwNjEwLVxcXFx1MDYxQVxcXFx1MDY0Qi1cXFxcdTA2NUZcXFxcdTA2NzBcXFxcdTA2RDYtXFxcXHUwNkRDXFxcXHUwNkRGLVxcXFx1MDZFNFxcXFx1MDZFN1xcXFx1MDZFOFxcXFx1MDZFQS1cXFxcdTA2RURcXFxcdTA3MTFcXFxcdTA3MzAtXFxcXHUwNzRBXFxcXHUwN0E2LVxcXFx1MDdCMFxcXFx1MDdFQi1cXFxcdTA3RjNcXFxcdTA3RkRcXFxcdTA4MTYtXFxcXHUwODE5XFxcXHUwODFCLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJEXFxcXHUwODU5LVxcXFx1MDg1QlxcXFx1MDhEMy1cXFxcdTA4RTFcXFxcdTA4RTMtXFxcXHUwOTAzXFxcXHUwOTNBLVxcXFx1MDkzQ1xcXFx1MDkzRS1cXFxcdTA5NEZcXFxcdTA5NTEtXFxcXHUwOTU3XFxcXHUwOTYyXFxcXHUwOTYzXFxcXHUwOTgxLVxcXFx1MDk4M1xcXFx1MDlCQ1xcXFx1MDlCRS1cXFxcdTA5QzRcXFxcdTA5QzdcXFxcdTA5QzhcXFxcdTA5Q0ItXFxcXHUwOUNEXFxcXHUwOUQ3XFxcXHUwOUUyXFxcXHUwOUUzXFxcXHUwOUZFXFxcXHUwQTAxLVxcXFx1MEEwM1xcXFx1MEEzQ1xcXFx1MEEzRS1cXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTcwXFxcXHUwQTcxXFxcXHUwQTc1XFxcXHUwQTgxLVxcXFx1MEE4M1xcXFx1MEFCQ1xcXFx1MEFCRS1cXFxcdTBBQzVcXFxcdTBBQzctXFxcXHUwQUM5XFxcXHUwQUNCLVxcXFx1MEFDRFxcXFx1MEFFMlxcXFx1MEFFM1xcXFx1MEFGQS1cXFxcdTBBRkZcXFxcdTBCMDEtXFxcXHUwQjAzXFxcXHUwQjNDXFxcXHUwQjNFLVxcXFx1MEI0NFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0Qi1cXFxcdTBCNERcXFxcdTBCNTUtXFxcXHUwQjU3XFxcXHUwQjYyXFxcXHUwQjYzXFxcXHUwQjgyXFxcXHUwQkJFLVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNEXFxcXHUwQkQ3XFxcXHUwQzAwLVxcXFx1MEMwNFxcXFx1MEMzRS1cXFxcdTBDNDRcXFxcdTBDNDYtXFxcXHUwQzQ4XFxcXHUwQzRBLVxcXFx1MEM0RFxcXFx1MEM1NVxcXFx1MEM1NlxcXFx1MEM2MlxcXFx1MEM2M1xcXFx1MEM4MS1cXFxcdTBDODNcXFxcdTBDQkNcXFxcdTBDQkUtXFxcXHUwQ0M0XFxcXHUwQ0M2LVxcXFx1MENDOFxcXFx1MENDQS1cXFxcdTBDQ0RcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBDRTJcXFxcdTBDRTNcXFxcdTBEMDAtXFxcXHUwRDAzXFxcXHUwRDNCXFxcXHUwRDNDXFxcXHUwRDNFLVxcXFx1MEQ0NFxcXFx1MEQ0Ni1cXFxcdTBENDhcXFxcdTBENEEtXFxcXHUwRDREXFxcXHUwRDU3XFxcXHUwRDYyXFxcXHUwRDYzXFxcXHUwRDgxLVxcXFx1MEQ4M1xcXFx1MERDQVxcXFx1MERDRi1cXFxcdTBERDRcXFxcdTBERDZcXFxcdTBERDgtXFxcXHUwRERGXFxcXHUwREYyXFxcXHUwREYzXFxcXHUwRTMxXFxcXHUwRTM0LVxcXFx1MEUzQVxcXFx1MEU0Ny1cXFxcdTBFNEVcXFxcdTBFQjFcXFxcdTBFQjQtXFxcXHUwRUJDXFxcXHUwRUM4LVxcXFx1MEVDRFxcXFx1MEYxOFxcXFx1MEYxOVxcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOVxcXFx1MEYzRVxcXFx1MEYzRlxcXFx1MEY3MS1cXFxcdTBGODRcXFxcdTBGODZcXFxcdTBGODdcXFxcdTBGOEQtXFxcXHUwRjk3XFxcXHUwRjk5LVxcXFx1MEZCQ1xcXFx1MEZDNlxcXFx1MTAyQi1cXFxcdTEwM0VcXFxcdTEwNTYtXFxcXHUxMDU5XFxcXHUxMDVFLVxcXFx1MTA2MFxcXFx1MTA2Mi1cXFxcdTEwNjRcXFxcdTEwNjctXFxcXHUxMDZEXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4Mi1cXFxcdTEwOERcXFxcdTEwOEZcXFxcdTEwOUEtXFxcXHUxMDlEXFxcXHUxMzVELVxcXFx1MTM1RlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN0I0LVxcXFx1MTdEM1xcXFx1MTdERFxcXFx1MTgwQi1cXFxcdTE4MERcXFxcdTE4ODVcXFxcdTE4ODZcXFxcdTE4QTlcXFxcdTE5MjAtXFxcXHUxOTJCXFxcXHUxOTMwLVxcXFx1MTkzQlxcXFx1MUExNy1cXFxcdTFBMUJcXFxcdTFBNTUtXFxcXHUxQTVFXFxcXHUxQTYwLVxcXFx1MUE3Q1xcXFx1MUE3RlxcXFx1MUFCMC1cXFxcdTFBQzBcXFxcdTFCMDAtXFxcXHUxQjA0XFxcXHUxQjM0LVxcXFx1MUI0NFxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODAtXFxcXHUxQjgyXFxcXHUxQkExLVxcXFx1MUJBRFxcXFx1MUJFNi1cXFxcdTFCRjNcXFxcdTFDMjQtXFxcXHUxQzM3XFxcXHUxQ0QwLVxcXFx1MUNEMlxcXFx1MUNENC1cXFxcdTFDRThcXFxcdTFDRURcXFxcdTFDRjRcXFxcdTFDRjctXFxcXHUxQ0Y5XFxcXHUxREMwLVxcXFx1MURGOVxcXFx1MURGQi1cXFxcdTFERkZcXFxcdTIwRDAtXFxcXHUyMEYwXFxcXHUyQ0VGLVxcXFx1MkNGMVxcXFx1MkQ3RlxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTMwMkEtXFxcXHUzMDJGXFxcXHUzMDk5XFxcXHUzMDlBXFxcXHVBNjZGLVxcXFx1QTY3MlxcXFx1QTY3NC1cXFxcdUE2N0RcXFxcdUE2OUVcXFxcdUE2OUZcXFxcdUE2RjBcXFxcdUE2RjFcXFxcdUE4MDJcXFxcdUE4MDZcXFxcdUE4MEJcXFxcdUE4MjMtXFxcXHVBODI3XFxcXHVBODJDXFxcXHVBODgwXFxcXHVBODgxXFxcXHVBOEI0LVxcXFx1QThDNVxcXFx1QThFMC1cXFxcdUE4RjFcXFxcdUE4RkZcXFxcdUE5MjYtXFxcXHVBOTJEXFxcXHVBOTQ3LVxcXFx1QTk1M1xcXFx1QTk4MC1cXFxcdUE5ODNcXFxcdUE5QjMtXFxcXHVBOUMwXFxcXHVBOUU1XFxcXHVBQTI5LVxcXFx1QUEzNlxcXFx1QUE0M1xcXFx1QUE0Q1xcXFx1QUE0RFxcXFx1QUE3Qi1cXFxcdUFBN0RcXFxcdUFBQjBcXFxcdUFBQjItXFxcXHVBQUI0XFxcXHVBQUI3XFxcXHVBQUI4XFxcXHVBQUJFXFxcXHVBQUJGXFxcXHVBQUMxXFxcXHVBQUVCLVxcXFx1QUFFRlxcXFx1QUFGNVxcXFx1QUFGNlxcXFx1QUJFMy1cXFxcdUFCRUFcXFxcdUFCRUNcXFxcdUFCRURcXFxcdUZCMUVcXFxcdUZFMDAtXFxcXHVGRTBGXFxcXHVGRTIwLVxcXFx1RkUyRlwiLFxuTWM6XCJcXFxcdTA5MDNcXFxcdTA5M0JcXFxcdTA5M0UtXFxcXHUwOTQwXFxcXHUwOTQ5LVxcXFx1MDk0Q1xcXFx1MDk0RVxcXFx1MDk0RlxcXFx1MDk4MlxcXFx1MDk4M1xcXFx1MDlCRS1cXFxcdTA5QzBcXFxcdTA5QzdcXFxcdTA5QzhcXFxcdTA5Q0JcXFxcdTA5Q0NcXFxcdTA5RDdcXFxcdTBBMDNcXFxcdTBBM0UtXFxcXHUwQTQwXFxcXHUwQTgzXFxcXHUwQUJFLVxcXFx1MEFDMFxcXFx1MEFDOVxcXFx1MEFDQlxcXFx1MEFDQ1xcXFx1MEIwMlxcXFx1MEIwM1xcXFx1MEIzRVxcXFx1MEI0MFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0QlxcXFx1MEI0Q1xcXFx1MEI1N1xcXFx1MEJCRVxcXFx1MEJCRlxcXFx1MEJDMVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNDXFxcXHUwQkQ3XFxcXHUwQzAxLVxcXFx1MEMwM1xcXFx1MEM0MS1cXFxcdTBDNDRcXFxcdTBDODJcXFxcdTBDODNcXFxcdTBDQkVcXFxcdTBDQzAtXFxcXHUwQ0M0XFxcXHUwQ0M3XFxcXHUwQ0M4XFxcXHUwQ0NBXFxcXHUwQ0NCXFxcXHUwQ0Q1XFxcXHUwQ0Q2XFxcXHUwRDAyXFxcXHUwRDAzXFxcXHUwRDNFLVxcXFx1MEQ0MFxcXFx1MEQ0Ni1cXFxcdTBENDhcXFxcdTBENEEtXFxcXHUwRDRDXFxcXHUwRDU3XFxcXHUwRDgyXFxcXHUwRDgzXFxcXHUwRENGLVxcXFx1MEREMVxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERjJcXFxcdTBERjNcXFxcdTBGM0VcXFxcdTBGM0ZcXFxcdTBGN0ZcXFxcdTEwMkJcXFxcdTEwMkNcXFxcdTEwMzFcXFxcdTEwMzhcXFxcdTEwM0JcXFxcdTEwM0NcXFxcdTEwNTZcXFxcdTEwNTdcXFxcdTEwNjItXFxcXHUxMDY0XFxcXHUxMDY3LVxcXFx1MTA2RFxcXFx1MTA4M1xcXFx1MTA4NFxcXFx1MTA4Ny1cXFxcdTEwOENcXFxcdTEwOEZcXFxcdTEwOUEtXFxcXHUxMDlDXFxcXHUxN0I2XFxcXHUxN0JFLVxcXFx1MTdDNVxcXFx1MTdDN1xcXFx1MTdDOFxcXFx1MTkyMy1cXFxcdTE5MjZcXFxcdTE5MjktXFxcXHUxOTJCXFxcXHUxOTMwXFxcXHUxOTMxXFxcXHUxOTMzLVxcXFx1MTkzOFxcXFx1MUExOVxcXFx1MUExQVxcXFx1MUE1NVxcXFx1MUE1N1xcXFx1MUE2MVxcXFx1MUE2M1xcXFx1MUE2NFxcXFx1MUE2RC1cXFxcdTFBNzJcXFxcdTFCMDRcXFxcdTFCMzVcXFxcdTFCM0JcXFxcdTFCM0QtXFxcXHUxQjQxXFxcXHUxQjQzXFxcXHUxQjQ0XFxcXHUxQjgyXFxcXHUxQkExXFxcXHUxQkE2XFxcXHUxQkE3XFxcXHUxQkFBXFxcXHUxQkU3XFxcXHUxQkVBLVxcXFx1MUJFQ1xcXFx1MUJFRVxcXFx1MUJGMlxcXFx1MUJGM1xcXFx1MUMyNC1cXFxcdTFDMkJcXFxcdTFDMzRcXFxcdTFDMzVcXFxcdTFDRTFcXFxcdTFDRjdcXFxcdTMwMkVcXFxcdTMwMkZcXFxcdUE4MjNcXFxcdUE4MjRcXFxcdUE4MjdcXFxcdUE4ODBcXFxcdUE4ODFcXFxcdUE4QjQtXFxcXHVBOEMzXFxcXHVBOTUyXFxcXHVBOTUzXFxcXHVBOTgzXFxcXHVBOUI0XFxcXHVBOUI1XFxcXHVBOUJBXFxcXHVBOUJCXFxcXHVBOUJFLVxcXFx1QTlDMFxcXFx1QUEyRlxcXFx1QUEzMFxcXFx1QUEzM1xcXFx1QUEzNFxcXFx1QUE0RFxcXFx1QUE3QlxcXFx1QUE3RFxcXFx1QUFFQlxcXFx1QUFFRVxcXFx1QUFFRlxcXFx1QUFGNVxcXFx1QUJFM1xcXFx1QUJFNFxcXFx1QUJFNlxcXFx1QUJFN1xcXFx1QUJFOVxcXFx1QUJFQVxcXFx1QUJFQ1wiLFxuTWU6XCJcXFxcdTA0ODhcXFxcdTA0ODlcXFxcdTFBQkVcXFxcdTIwREQtXFxcXHUyMEUwXFxcXHUyMEUyLVxcXFx1MjBFNFxcXFx1QTY3MC1cXFxcdUE2NzJcIixNbjpcIlxcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNTkxLVxcXFx1MDVCRFxcXFx1MDVCRlxcXFx1MDVDMVxcXFx1MDVDMlxcXFx1MDVDNFxcXFx1MDVDNVxcXFx1MDVDN1xcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2NEItXFxcXHUwNjVGXFxcXHUwNjcwXFxcXHUwNkQ2LVxcXFx1MDZEQ1xcXFx1MDZERi1cXFxcdTA2RTRcXFxcdTA2RTdcXFxcdTA2RThcXFxcdTA2RUEtXFxcXHUwNkVEXFxcXHUwNzExXFxcXHUwNzMwLVxcXFx1MDc0QVxcXFx1MDdBNi1cXFxcdTA3QjBcXFxcdTA3RUItXFxcXHUwN0YzXFxcXHUwN0ZEXFxcXHUwODE2LVxcXFx1MDgxOVxcXFx1MDgxQi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyRFxcXFx1MDg1OS1cXFxcdTA4NUJcXFxcdTA4RDMtXFxcXHUwOEUxXFxcXHUwOEUzLVxcXFx1MDkwMlxcXFx1MDkzQVxcXFx1MDkzQ1xcXFx1MDk0MS1cXFxcdTA5NDhcXFxcdTA5NERcXFxcdTA5NTEtXFxcXHUwOTU3XFxcXHUwOTYyXFxcXHUwOTYzXFxcXHUwOTgxXFxcXHUwOUJDXFxcXHUwOUMxLVxcXFx1MDlDNFxcXFx1MDlDRFxcXFx1MDlFMlxcXFx1MDlFM1xcXFx1MDlGRVxcXFx1MEEwMVxcXFx1MEEwMlxcXFx1MEEzQ1xcXFx1MEE0MVxcXFx1MEE0MlxcXFx1MEE0N1xcXFx1MEE0OFxcXFx1MEE0Qi1cXFxcdTBBNERcXFxcdTBBNTFcXFxcdTBBNzBcXFxcdTBBNzFcXFxcdTBBNzVcXFxcdTBBODFcXFxcdTBBODJcXFxcdTBBQkNcXFxcdTBBQzEtXFxcXHUwQUM1XFxcXHUwQUM3XFxcXHUwQUM4XFxcXHUwQUNEXFxcXHUwQUUyXFxcXHUwQUUzXFxcXHUwQUZBLVxcXFx1MEFGRlxcXFx1MEIwMVxcXFx1MEIzQ1xcXFx1MEIzRlxcXFx1MEI0MS1cXFxcdTBCNDRcXFxcdTBCNERcXFxcdTBCNTVcXFxcdTBCNTZcXFxcdTBCNjJcXFxcdTBCNjNcXFxcdTBCODJcXFxcdTBCQzBcXFxcdTBCQ0RcXFxcdTBDMDBcXFxcdTBDMDRcXFxcdTBDM0UtXFxcXHUwQzQwXFxcXHUwQzQ2LVxcXFx1MEM0OFxcXFx1MEM0QS1cXFxcdTBDNERcXFxcdTBDNTVcXFxcdTBDNTZcXFxcdTBDNjJcXFxcdTBDNjNcXFxcdTBDODFcXFxcdTBDQkNcXFxcdTBDQkZcXFxcdTBDQzZcXFxcdTBDQ0NcXFxcdTBDQ0RcXFxcdTBDRTJcXFxcdTBDRTNcXFxcdTBEMDBcXFxcdTBEMDFcXFxcdTBEM0JcXFxcdTBEM0NcXFxcdTBENDEtXFxcXHUwRDQ0XFxcXHUwRDREXFxcXHUwRDYyXFxcXHUwRDYzXFxcXHUwRDgxXFxcXHUwRENBXFxcXHUwREQyLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEUzMVxcXFx1MEUzNC1cXFxcdTBFM0FcXFxcdTBFNDctXFxcXHUwRTRFXFxcXHUwRUIxXFxcXHUwRUI0LVxcXFx1MEVCQ1xcXFx1MEVDOC1cXFxcdTBFQ0RcXFxcdTBGMThcXFxcdTBGMTlcXFxcdTBGMzVcXFxcdTBGMzdcXFxcdTBGMzlcXFxcdTBGNzEtXFxcXHUwRjdFXFxcXHUwRjgwLVxcXFx1MEY4NFxcXFx1MEY4NlxcXFx1MEY4N1xcXFx1MEY4RC1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDJELVxcXFx1MTAzMFxcXFx1MTAzMi1cXFxcdTEwMzdcXFxcdTEwMzlcXFxcdTEwM0FcXFxcdTEwM0RcXFxcdTEwM0VcXFxcdTEwNThcXFxcdTEwNTlcXFxcdTEwNUUtXFxcXHUxMDYwXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4MlxcXFx1MTA4NVxcXFx1MTA4NlxcXFx1MTA4RFxcXFx1MTA5RFxcXFx1MTM1RC1cXFxcdTEzNUZcXFxcdTE3MTItXFxcXHUxNzE0XFxcXHUxNzMyLVxcXFx1MTczNFxcXFx1MTc1MlxcXFx1MTc1M1xcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTdCNFxcXFx1MTdCNVxcXFx1MTdCNy1cXFxcdTE3QkRcXFxcdTE3QzZcXFxcdTE3QzktXFxcXHUxN0QzXFxcXHUxN0REXFxcXHUxODBCLVxcXFx1MTgwRFxcXFx1MTg4NVxcXFx1MTg4NlxcXFx1MThBOVxcXFx1MTkyMC1cXFxcdTE5MjJcXFxcdTE5MjdcXFxcdTE5MjhcXFxcdTE5MzJcXFxcdTE5MzktXFxcXHUxOTNCXFxcXHUxQTE3XFxcXHUxQTE4XFxcXHUxQTFCXFxcXHUxQTU2XFxcXHUxQTU4LVxcXFx1MUE1RVxcXFx1MUE2MFxcXFx1MUE2MlxcXFx1MUE2NS1cXFxcdTFBNkNcXFxcdTFBNzMtXFxcXHUxQTdDXFxcXHUxQTdGXFxcXHUxQUIwLVxcXFx1MUFCRFxcXFx1MUFCRlxcXFx1MUFDMFxcXFx1MUIwMC1cXFxcdTFCMDNcXFxcdTFCMzRcXFxcdTFCMzYtXFxcXHUxQjNBXFxcXHUxQjNDXFxcXHUxQjQyXFxcXHUxQjZCLVxcXFx1MUI3M1xcXFx1MUI4MFxcXFx1MUI4MVxcXFx1MUJBMi1cXFxcdTFCQTVcXFxcdTFCQThcXFxcdTFCQTlcXFxcdTFCQUItXFxcXHUxQkFEXFxcXHUxQkU2XFxcXHUxQkU4XFxcXHUxQkU5XFxcXHUxQkVEXFxcXHUxQkVGLVxcXFx1MUJGMVxcXFx1MUMyQy1cXFxcdTFDMzNcXFxcdTFDMzZcXFxcdTFDMzdcXFxcdTFDRDAtXFxcXHUxQ0QyXFxcXHUxQ0Q0LVxcXFx1MUNFMFxcXFx1MUNFMi1cXFxcdTFDRThcXFxcdTFDRURcXFxcdTFDRjRcXFxcdTFDRjhcXFxcdTFDRjlcXFxcdTFEQzAtXFxcXHUxREY5XFxcXHUxREZCLVxcXFx1MURGRlxcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyQ0VGLVxcXFx1MkNGMVxcXFx1MkQ3RlxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTMwMkEtXFxcXHUzMDJEXFxcXHUzMDk5XFxcXHUzMDlBXFxcXHVBNjZGXFxcXHVBNjc0LVxcXFx1QTY3RFxcXFx1QTY5RVxcXFx1QTY5RlxcXFx1QTZGMFxcXFx1QTZGMVxcXFx1QTgwMlxcXFx1QTgwNlxcXFx1QTgwQlxcXFx1QTgyNVxcXFx1QTgyNlxcXFx1QTgyQ1xcXFx1QThDNFxcXFx1QThDNVxcXFx1QThFMC1cXFxcdUE4RjFcXFxcdUE4RkZcXFxcdUE5MjYtXFxcXHVBOTJEXFxcXHVBOTQ3LVxcXFx1QTk1MVxcXFx1QTk4MC1cXFxcdUE5ODJcXFxcdUE5QjNcXFxcdUE5QjYtXFxcXHVBOUI5XFxcXHVBOUJDXFxcXHVBOUJEXFxcXHVBOUU1XFxcXHVBQTI5LVxcXFx1QUEyRVxcXFx1QUEzMVxcXFx1QUEzMlxcXFx1QUEzNVxcXFx1QUEzNlxcXFx1QUE0M1xcXFx1QUE0Q1xcXFx1QUE3Q1xcXFx1QUFCMFxcXFx1QUFCMi1cXFxcdUFBQjRcXFxcdUFBQjdcXFxcdUFBQjhcXFxcdUFBQkVcXFxcdUFBQkZcXFxcdUFBQzFcXFxcdUFBRUNcXFxcdUFBRURcXFxcdUFBRjZcXFxcdUFCRTVcXFxcdUFCRThcXFxcdUFCRURcXFxcdUZCMUVcXFxcdUZFMDAtXFxcXHVGRTBGXFxcXHVGRTIwLVxcXFx1RkUyRlwiLFxuTmQ6XCIwLTlcXFxcdTA2NjAtXFxcXHUwNjY5XFxcXHUwNkYwLVxcXFx1MDZGOVxcXFx1MDdDMC1cXFxcdTA3QzlcXFxcdTA5NjYtXFxcXHUwOTZGXFxcXHUwOUU2LVxcXFx1MDlFRlxcXFx1MEE2Ni1cXFxcdTBBNkZcXFxcdTBBRTYtXFxcXHUwQUVGXFxcXHUwQjY2LVxcXFx1MEI2RlxcXFx1MEJFNi1cXFxcdTBCRUZcXFxcdTBDNjYtXFxcXHUwQzZGXFxcXHUwQ0U2LVxcXFx1MENFRlxcXFx1MEQ2Ni1cXFxcdTBENkZcXFxcdTBERTYtXFxcXHUwREVGXFxcXHUwRTUwLVxcXFx1MEU1OVxcXFx1MEVEMC1cXFxcdTBFRDlcXFxcdTBGMjAtXFxcXHUwRjI5XFxcXHUxMDQwLVxcXFx1MTA0OVxcXFx1MTA5MC1cXFxcdTEwOTlcXFxcdTE3RTAtXFxcXHUxN0U5XFxcXHUxODEwLVxcXFx1MTgxOVxcXFx1MTk0Ni1cXFxcdTE5NEZcXFxcdTE5RDAtXFxcXHUxOUQ5XFxcXHUxQTgwLVxcXFx1MUE4OVxcXFx1MUE5MC1cXFxcdTFBOTlcXFxcdTFCNTAtXFxcXHUxQjU5XFxcXHUxQkIwLVxcXFx1MUJCOVxcXFx1MUM0MC1cXFxcdTFDNDlcXFxcdTFDNTAtXFxcXHUxQzU5XFxcXHVBNjIwLVxcXFx1QTYyOVxcXFx1QThEMC1cXFxcdUE4RDlcXFxcdUE5MDAtXFxcXHVBOTA5XFxcXHVBOUQwLVxcXFx1QTlEOVxcXFx1QTlGMC1cXFxcdUE5RjlcXFxcdUFBNTAtXFxcXHVBQTU5XFxcXHVBQkYwLVxcXFx1QUJGOVxcXFx1RkYxMC1cXFxcdUZGMTlcIixcbk5sOlwiXFxcXHUxNkVFLVxcXFx1MTZGMFxcXFx1MjE2MC1cXFxcdTIxODJcXFxcdTIxODUtXFxcXHUyMTg4XFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyOVxcXFx1MzAzOC1cXFxcdTMwM0FcXFxcdUE2RTYtXFxcXHVBNkVGXCIsTm86XCJcXFxceEIyXFxcXHhCM1xcXFx4QjlcXFxceEJDLVxcXFx4QkVcXFxcdTA5RjQtXFxcXHUwOUY5XFxcXHUwQjcyLVxcXFx1MEI3N1xcXFx1MEJGMC1cXFxcdTBCRjJcXFxcdTBDNzgtXFxcXHUwQzdFXFxcXHUwRDU4LVxcXFx1MEQ1RVxcXFx1MEQ3MC1cXFxcdTBENzhcXFxcdTBGMkEtXFxcXHUwRjMzXFxcXHUxMzY5LVxcXFx1MTM3Q1xcXFx1MTdGMC1cXFxcdTE3RjlcXFxcdTE5REFcXFxcdTIwNzBcXFxcdTIwNzQtXFxcXHUyMDc5XFxcXHUyMDgwLVxcXFx1MjA4OVxcXFx1MjE1MC1cXFxcdTIxNUZcXFxcdTIxODlcXFxcdTI0NjAtXFxcXHUyNDlCXFxcXHUyNEVBLVxcXFx1MjRGRlxcXFx1Mjc3Ni1cXFxcdTI3OTNcXFxcdTJDRkRcXFxcdTMxOTItXFxcXHUzMTk1XFxcXHUzMjIwLVxcXFx1MzIyOVxcXFx1MzI0OC1cXFxcdTMyNEZcXFxcdTMyNTEtXFxcXHUzMjVGXFxcXHUzMjgwLVxcXFx1MzI4OVxcXFx1MzJCMS1cXFxcdTMyQkZcXFxcdUE4MzAtXFxcXHVBODM1XCIsUGM6XCJfXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHVGRTMzXFxcXHVGRTM0XFxcXHVGRTRELVxcXFx1RkU0RlxcXFx1RkYzRlwiLFxuUGQ6XCJcXFxcLVxcXFx1MDU4QVxcXFx1MDVCRVxcXFx1MTQwMFxcXFx1MTgwNlxcXFx1MjAxMC1cXFxcdTIwMTVcXFxcdTJFMTdcXFxcdTJFMUFcXFxcdTJFM0FcXFxcdTJFM0JcXFxcdTJFNDBcXFxcdTMwMUNcXFxcdTMwMzBcXFxcdTMwQTBcXFxcdUZFMzFcXFxcdUZFMzJcXFxcdUZFNThcXFxcdUZFNjNcXFxcdUZGMERcIixQZTpcIlxcXFwpXFxcXF1cXFxcfVxcXFx1MEYzQlxcXFx1MEYzRFxcXFx1MTY5Q1xcXFx1MjA0NlxcXFx1MjA3RVxcXFx1MjA4RVxcXFx1MjMwOVxcXFx1MjMwQlxcXFx1MjMyQVxcXFx1Mjc2OVxcXFx1Mjc2QlxcXFx1Mjc2RFxcXFx1Mjc2RlxcXFx1Mjc3MVxcXFx1Mjc3M1xcXFx1Mjc3NVxcXFx1MjdDNlxcXFx1MjdFN1xcXFx1MjdFOVxcXFx1MjdFQlxcXFx1MjdFRFxcXFx1MjdFRlxcXFx1Mjk4NFxcXFx1Mjk4NlxcXFx1Mjk4OFxcXFx1Mjk4QVxcXFx1Mjk4Q1xcXFx1Mjk4RVxcXFx1Mjk5MFxcXFx1Mjk5MlxcXFx1Mjk5NFxcXFx1Mjk5NlxcXFx1Mjk5OFxcXFx1MjlEOVxcXFx1MjlEQlxcXFx1MjlGRFxcXFx1MkUyM1xcXFx1MkUyNVxcXFx1MkUyN1xcXFx1MkUyOVxcXFx1MzAwOVxcXFx1MzAwQlxcXFx1MzAwRFxcXFx1MzAwRlxcXFx1MzAxMVxcXFx1MzAxNVxcXFx1MzAxN1xcXFx1MzAxOVxcXFx1MzAxQlxcXFx1MzAxRVxcXFx1MzAxRlxcXFx1RkQzRVxcXFx1RkUxOFxcXFx1RkUzNlxcXFx1RkUzOFxcXFx1RkUzQVxcXFx1RkUzQ1xcXFx1RkUzRVxcXFx1RkU0MFxcXFx1RkU0MlxcXFx1RkU0NFxcXFx1RkU0OFxcXFx1RkU1QVxcXFx1RkU1Q1xcXFx1RkU1RVxcXFx1RkYwOVxcXFx1RkYzRFxcXFx1RkY1RFxcXFx1RkY2MFxcXFx1RkY2M1wiLFxuUGY6XCJcXFxceEJCXFxcXHUyMDE5XFxcXHUyMDFEXFxcXHUyMDNBXFxcXHUyRTAzXFxcXHUyRTA1XFxcXHUyRTBBXFxcXHUyRTBEXFxcXHUyRTFEXFxcXHUyRTIxXCIsUGk6XCJcXFxceEFCXFxcXHUyMDE4XFxcXHUyMDFCXFxcXHUyMDFDXFxcXHUyMDFGXFxcXHUyMDM5XFxcXHUyRTAyXFxcXHUyRTA0XFxcXHUyRTA5XFxcXHUyRTBDXFxcXHUyRTFDXFxcXHUyRTIwXCIsUG86XCIhLSMlLSdcXFxcKixcXFxcLlxcXFwvOjtcXFxcP0BcXFxceEExXFxcXHhBN1xcXFx4QjZcXFxceEI3XFxcXHhCRlxcXFx1MDM3RVxcXFx1MDM4N1xcXFx1MDU1QS1cXFxcdTA1NUZcXFxcdTA1ODlcXFxcdTA1QzBcXFxcdTA1QzNcXFxcdTA1QzZcXFxcdTA1RjNcXFxcdTA1RjRcXFxcdTA2MDlcXFxcdTA2MEFcXFxcdTA2MENcXFxcdTA2MERcXFxcdTA2MUJcXFxcdTA2MUVcXFxcdTA2MUZcXFxcdTA2NkEtXFxcXHUwNjZEXFxcXHUwNkQ0XFxcXHUwNzAwLVxcXFx1MDcwRFxcXFx1MDdGNy1cXFxcdTA3RjlcXFxcdTA4MzAtXFxcXHUwODNFXFxcXHUwODVFXFxcXHUwOTY0XFxcXHUwOTY1XFxcXHUwOTcwXFxcXHUwOUZEXFxcXHUwQTc2XFxcXHUwQUYwXFxcXHUwQzc3XFxcXHUwQzg0XFxcXHUwREY0XFxcXHUwRTRGXFxcXHUwRTVBXFxcXHUwRTVCXFxcXHUwRjA0LVxcXFx1MEYxMlxcXFx1MEYxNFxcXFx1MEY4NVxcXFx1MEZEMC1cXFxcdTBGRDRcXFxcdTBGRDlcXFxcdTBGREFcXFxcdTEwNEEtXFxcXHUxMDRGXFxcXHUxMEZCXFxcXHUxMzYwLVxcXFx1MTM2OFxcXFx1MTY2RVxcXFx1MTZFQi1cXFxcdTE2RURcXFxcdTE3MzVcXFxcdTE3MzZcXFxcdTE3RDQtXFxcXHUxN0Q2XFxcXHUxN0Q4LVxcXFx1MTdEQVxcXFx1MTgwMC1cXFxcdTE4MDVcXFxcdTE4MDctXFxcXHUxODBBXFxcXHUxOTQ0XFxcXHUxOTQ1XFxcXHUxQTFFXFxcXHUxQTFGXFxcXHUxQUEwLVxcXFx1MUFBNlxcXFx1MUFBOC1cXFxcdTFBQURcXFxcdTFCNUEtXFxcXHUxQjYwXFxcXHUxQkZDLVxcXFx1MUJGRlxcXFx1MUMzQi1cXFxcdTFDM0ZcXFxcdTFDN0VcXFxcdTFDN0ZcXFxcdTFDQzAtXFxcXHUxQ0M3XFxcXHUxQ0QzXFxcXHUyMDE2XFxcXHUyMDE3XFxcXHUyMDIwLVxcXFx1MjAyN1xcXFx1MjAzMC1cXFxcdTIwMzhcXFxcdTIwM0ItXFxcXHUyMDNFXFxcXHUyMDQxLVxcXFx1MjA0M1xcXFx1MjA0Ny1cXFxcdTIwNTFcXFxcdTIwNTNcXFxcdTIwNTUtXFxcXHUyMDVFXFxcXHUyQ0Y5LVxcXFx1MkNGQ1xcXFx1MkNGRVxcXFx1MkNGRlxcXFx1MkQ3MFxcXFx1MkUwMFxcXFx1MkUwMVxcXFx1MkUwNi1cXFxcdTJFMDhcXFxcdTJFMEJcXFxcdTJFMEUtXFxcXHUyRTE2XFxcXHUyRTE4XFxcXHUyRTE5XFxcXHUyRTFCXFxcXHUyRTFFXFxcXHUyRTFGXFxcXHUyRTJBLVxcXFx1MkUyRVxcXFx1MkUzMC1cXFxcdTJFMzlcXFxcdTJFM0MtXFxcXHUyRTNGXFxcXHUyRTQxXFxcXHUyRTQzLVxcXFx1MkU0RlxcXFx1MkU1MlxcXFx1MzAwMS1cXFxcdTMwMDNcXFxcdTMwM0RcXFxcdTMwRkJcXFxcdUE0RkVcXFxcdUE0RkZcXFxcdUE2MEQtXFxcXHVBNjBGXFxcXHVBNjczXFxcXHVBNjdFXFxcXHVBNkYyLVxcXFx1QTZGN1xcXFx1QTg3NC1cXFxcdUE4NzdcXFxcdUE4Q0VcXFxcdUE4Q0ZcXFxcdUE4RjgtXFxcXHVBOEZBXFxcXHVBOEZDXFxcXHVBOTJFXFxcXHVBOTJGXFxcXHVBOTVGXFxcXHVBOUMxLVxcXFx1QTlDRFxcXFx1QTlERVxcXFx1QTlERlxcXFx1QUE1Qy1cXFxcdUFBNUZcXFxcdUFBREVcXFxcdUFBREZcXFxcdUFBRjBcXFxcdUFBRjFcXFxcdUFCRUJcXFxcdUZFMTAtXFxcXHVGRTE2XFxcXHVGRTE5XFxcXHVGRTMwXFxcXHVGRTQ1XFxcXHVGRTQ2XFxcXHVGRTQ5LVxcXFx1RkU0Q1xcXFx1RkU1MC1cXFxcdUZFNTJcXFxcdUZFNTQtXFxcXHVGRTU3XFxcXHVGRTVGLVxcXFx1RkU2MVxcXFx1RkU2OFxcXFx1RkU2QVxcXFx1RkU2QlxcXFx1RkYwMS1cXFxcdUZGMDNcXFxcdUZGMDUtXFxcXHVGRjA3XFxcXHVGRjBBXFxcXHVGRjBDXFxcXHVGRjBFXFxcXHVGRjBGXFxcXHVGRjFBXFxcXHVGRjFCXFxcXHVGRjFGXFxcXHVGRjIwXFxcXHVGRjNDXFxcXHVGRjYxXFxcXHVGRjY0XFxcXHVGRjY1XCIsXG5QczpcIlxcXFwoXFxcXFtcXFxce1xcXFx1MEYzQVxcXFx1MEYzQ1xcXFx1MTY5QlxcXFx1MjAxQVxcXFx1MjAxRVxcXFx1MjA0NVxcXFx1MjA3RFxcXFx1MjA4RFxcXFx1MjMwOFxcXFx1MjMwQVxcXFx1MjMyOVxcXFx1Mjc2OFxcXFx1Mjc2QVxcXFx1Mjc2Q1xcXFx1Mjc2RVxcXFx1Mjc3MFxcXFx1Mjc3MlxcXFx1Mjc3NFxcXFx1MjdDNVxcXFx1MjdFNlxcXFx1MjdFOFxcXFx1MjdFQVxcXFx1MjdFQ1xcXFx1MjdFRVxcXFx1Mjk4M1xcXFx1Mjk4NVxcXFx1Mjk4N1xcXFx1Mjk4OVxcXFx1Mjk4QlxcXFx1Mjk4RFxcXFx1Mjk4RlxcXFx1Mjk5MVxcXFx1Mjk5M1xcXFx1Mjk5NVxcXFx1Mjk5N1xcXFx1MjlEOFxcXFx1MjlEQVxcXFx1MjlGQ1xcXFx1MkUyMlxcXFx1MkUyNFxcXFx1MkUyNlxcXFx1MkUyOFxcXFx1MkU0MlxcXFx1MzAwOFxcXFx1MzAwQVxcXFx1MzAwQ1xcXFx1MzAwRVxcXFx1MzAxMFxcXFx1MzAxNFxcXFx1MzAxNlxcXFx1MzAxOFxcXFx1MzAxQVxcXFx1MzAxRFxcXFx1RkQzRlxcXFx1RkUxN1xcXFx1RkUzNVxcXFx1RkUzN1xcXFx1RkUzOVxcXFx1RkUzQlxcXFx1RkUzRFxcXFx1RkUzRlxcXFx1RkU0MVxcXFx1RkU0M1xcXFx1RkU0N1xcXFx1RkU1OVxcXFx1RkU1QlxcXFx1RkU1RFxcXFx1RkYwOFxcXFx1RkYzQlxcXFx1RkY1QlxcXFx1RkY1RlxcXFx1RkY2MlwiLFxuU2M6XCJcXFxcJFxcXFx4QTItXFxcXHhBNVxcXFx1MDU4RlxcXFx1MDYwQlxcXFx1MDdGRVxcXFx1MDdGRlxcXFx1MDlGMlxcXFx1MDlGM1xcXFx1MDlGQlxcXFx1MEFGMVxcXFx1MEJGOVxcXFx1MEUzRlxcXFx1MTdEQlxcXFx1MjBBMC1cXFxcdTIwQkZcXFxcdUE4MzhcXFxcdUZERkNcXFxcdUZFNjlcXFxcdUZGMDRcXFxcdUZGRTBcXFxcdUZGRTFcXFxcdUZGRTVcXFxcdUZGRTZcIixTazpcIlxcXFxeYFxcXFx4QThcXFxceEFGXFxcXHhCNFxcXFx4QjhcXFxcdTAyQzItXFxcXHUwMkM1XFxcXHUwMkQyLVxcXFx1MDJERlxcXFx1MDJFNS1cXFxcdTAyRUJcXFxcdTAyRURcXFxcdTAyRUYtXFxcXHUwMkZGXFxcXHUwMzc1XFxcXHUwMzg0XFxcXHUwMzg1XFxcXHUxRkJEXFxcXHUxRkJGLVxcXFx1MUZDMVxcXFx1MUZDRC1cXFxcdTFGQ0ZcXFxcdTFGREQtXFxcXHUxRkRGXFxcXHUxRkVELVxcXFx1MUZFRlxcXFx1MUZGRFxcXFx1MUZGRVxcXFx1MzA5QlxcXFx1MzA5Q1xcXFx1QTcwMC1cXFxcdUE3MTZcXFxcdUE3MjBcXFxcdUE3MjFcXFxcdUE3ODlcXFxcdUE3OEFcXFxcdUFCNUJcXFxcdUFCNkFcXFxcdUFCNkJcXFxcdUZCQjItXFxcXHVGQkMxXFxcXHVGRjNFXFxcXHVGRjQwXFxcXHVGRkUzXCIsU206XCJcXFxcKzwtPlxcXFx8flxcXFx4QUNcXFxceEIxXFxcXHhEN1xcXFx4RjdcXFxcdTAzRjZcXFxcdTA2MDYtXFxcXHUwNjA4XFxcXHUyMDQ0XFxcXHUyMDUyXFxcXHUyMDdBLVxcXFx1MjA3Q1xcXFx1MjA4QS1cXFxcdTIwOENcXFxcdTIxMThcXFxcdTIxNDAtXFxcXHUyMTQ0XFxcXHUyMTRCXFxcXHUyMTkwLVxcXFx1MjE5NFxcXFx1MjE5QVxcXFx1MjE5QlxcXFx1MjFBMFxcXFx1MjFBM1xcXFx1MjFBNlxcXFx1MjFBRVxcXFx1MjFDRVxcXFx1MjFDRlxcXFx1MjFEMlxcXFx1MjFENFxcXFx1MjFGNC1cXFxcdTIyRkZcXFxcdTIzMjBcXFxcdTIzMjFcXFxcdTIzN0NcXFxcdTIzOUItXFxcXHUyM0IzXFxcXHUyM0RDLVxcXFx1MjNFMVxcXFx1MjVCN1xcXFx1MjVDMVxcXFx1MjVGOC1cXFxcdTI1RkZcXFxcdTI2NkZcXFxcdTI3QzAtXFxcXHUyN0M0XFxcXHUyN0M3LVxcXFx1MjdFNVxcXFx1MjdGMC1cXFxcdTI3RkZcXFxcdTI5MDAtXFxcXHUyOTgyXFxcXHUyOTk5LVxcXFx1MjlEN1xcXFx1MjlEQy1cXFxcdTI5RkJcXFxcdTI5RkUtXFxcXHUyQUZGXFxcXHUyQjMwLVxcXFx1MkI0NFxcXFx1MkI0Ny1cXFxcdTJCNENcXFxcdUZCMjlcXFxcdUZFNjJcXFxcdUZFNjQtXFxcXHVGRTY2XFxcXHVGRjBCXFxcXHVGRjFDLVxcXFx1RkYxRVxcXFx1RkY1Q1xcXFx1RkY1RVxcXFx1RkZFMlxcXFx1RkZFOS1cXFxcdUZGRUNcIixcblNvOlwiXFxcXHhBNlxcXFx4QTlcXFxceEFFXFxcXHhCMFxcXFx1MDQ4MlxcXFx1MDU4RFxcXFx1MDU4RVxcXFx1MDYwRVxcXFx1MDYwRlxcXFx1MDZERVxcXFx1MDZFOVxcXFx1MDZGRFxcXFx1MDZGRVxcXFx1MDdGNlxcXFx1MDlGQVxcXFx1MEI3MFxcXFx1MEJGMy1cXFxcdTBCRjhcXFxcdTBCRkFcXFxcdTBDN0ZcXFxcdTBENEZcXFxcdTBENzlcXFxcdTBGMDEtXFxcXHUwRjAzXFxcXHUwRjEzXFxcXHUwRjE1LVxcXFx1MEYxN1xcXFx1MEYxQS1cXFxcdTBGMUZcXFxcdTBGMzRcXFxcdTBGMzZcXFxcdTBGMzhcXFxcdTBGQkUtXFxcXHUwRkM1XFxcXHUwRkM3LVxcXFx1MEZDQ1xcXFx1MEZDRVxcXFx1MEZDRlxcXFx1MEZENS1cXFxcdTBGRDhcXFxcdTEwOUVcXFxcdTEwOUZcXFxcdTEzOTAtXFxcXHUxMzk5XFxcXHUxNjZEXFxcXHUxOTQwXFxcXHUxOURFLVxcXFx1MTlGRlxcXFx1MUI2MS1cXFxcdTFCNkFcXFxcdTFCNzQtXFxcXHUxQjdDXFxcXHUyMTAwXFxcXHUyMTAxXFxcXHUyMTAzLVxcXFx1MjEwNlxcXFx1MjEwOFxcXFx1MjEwOVxcXFx1MjExNFxcXFx1MjExNlxcXFx1MjExN1xcXFx1MjExRS1cXFxcdTIxMjNcXFxcdTIxMjVcXFxcdTIxMjdcXFxcdTIxMjlcXFxcdTIxMkVcXFxcdTIxM0FcXFxcdTIxM0JcXFxcdTIxNEFcXFxcdTIxNENcXFxcdTIxNERcXFxcdTIxNEZcXFxcdTIxOEFcXFxcdTIxOEJcXFxcdTIxOTUtXFxcXHUyMTk5XFxcXHUyMTlDLVxcXFx1MjE5RlxcXFx1MjFBMVxcXFx1MjFBMlxcXFx1MjFBNFxcXFx1MjFBNVxcXFx1MjFBNy1cXFxcdTIxQURcXFxcdTIxQUYtXFxcXHUyMUNEXFxcXHUyMUQwXFxcXHUyMUQxXFxcXHUyMUQzXFxcXHUyMUQ1LVxcXFx1MjFGM1xcXFx1MjMwMC1cXFxcdTIzMDdcXFxcdTIzMEMtXFxcXHUyMzFGXFxcXHUyMzIyLVxcXFx1MjMyOFxcXFx1MjMyQi1cXFxcdTIzN0JcXFxcdTIzN0QtXFxcXHUyMzlBXFxcXHUyM0I0LVxcXFx1MjNEQlxcXFx1MjNFMi1cXFxcdTI0MjZcXFxcdTI0NDAtXFxcXHUyNDRBXFxcXHUyNDlDLVxcXFx1MjRFOVxcXFx1MjUwMC1cXFxcdTI1QjZcXFxcdTI1QjgtXFxcXHUyNUMwXFxcXHUyNUMyLVxcXFx1MjVGN1xcXFx1MjYwMC1cXFxcdTI2NkVcXFxcdTI2NzAtXFxcXHUyNzY3XFxcXHUyNzk0LVxcXFx1MjdCRlxcXFx1MjgwMC1cXFxcdTI4RkZcXFxcdTJCMDAtXFxcXHUyQjJGXFxcXHUyQjQ1XFxcXHUyQjQ2XFxcXHUyQjRELVxcXFx1MkI3M1xcXFx1MkI3Ni1cXFxcdTJCOTVcXFxcdTJCOTctXFxcXHUyQkZGXFxcXHUyQ0U1LVxcXFx1MkNFQVxcXFx1MkU1MFxcXFx1MkU1MVxcXFx1MkU4MC1cXFxcdTJFOTlcXFxcdTJFOUItXFxcXHUyRUYzXFxcXHUyRjAwLVxcXFx1MkZENVxcXFx1MkZGMC1cXFxcdTJGRkJcXFxcdTMwMDRcXFxcdTMwMTJcXFxcdTMwMTNcXFxcdTMwMjBcXFxcdTMwMzZcXFxcdTMwMzdcXFxcdTMwM0VcXFxcdTMwM0ZcXFxcdTMxOTBcXFxcdTMxOTFcXFxcdTMxOTYtXFxcXHUzMTlGXFxcXHUzMUMwLVxcXFx1MzFFM1xcXFx1MzIwMC1cXFxcdTMyMUVcXFxcdTMyMkEtXFxcXHUzMjQ3XFxcXHUzMjUwXFxcXHUzMjYwLVxcXFx1MzI3RlxcXFx1MzI4QS1cXFxcdTMyQjBcXFxcdTMyQzAtXFxcXHUzM0ZGXFxcXHU0REMwLVxcXFx1NERGRlxcXFx1QTQ5MC1cXFxcdUE0QzZcXFxcdUE4MjgtXFxcXHVBODJCXFxcXHVBODM2XFxcXHVBODM3XFxcXHVBODM5XFxcXHVBQTc3LVxcXFx1QUE3OVxcXFx1RkRGRFxcXFx1RkZFNFxcXFx1RkZFOFxcXFx1RkZFRFxcXFx1RkZFRVxcXFx1RkZGQ1xcXFx1RkZGRFwiLFxuWmw6XCJcXFxcdTIwMjhcIixacDpcIlxcXFx1MjAyOVwiLFpzOlwiIFxcXFx4QTBcXFxcdTE2ODBcXFxcdTIwMDAtXFxcXHUyMDBBXFxcXHUyMDJGXFxcXHUyMDVGXFxcXHUzMDAwXCJ9O0YuQz1GLkNjK0YuQ2YrRi5DcytGLkNvO0YuTD1GLkx1K0YuTGwrRi5MdCtGLkxtK0YuTW4rRi5MbztGLkxDPUYuTHUrRi5MbCtGLkx0O0YuTT1GLk1uK0YuTWMrRi5NZTtGLk49Ri5OZCtGLk5sK0YuTm87Ri5QPUYuUGMrRi5QZCtGLlBzK0YuUGUrRi5QaStGLlBmK0YuUG87Ri5TPUYuU20rRi5TYytGLlNrK0YuU287Ri5aPUYuWnMrRi5abCtGLlpwO0Yudz1cIl9cIitGLkwrRi5OO0YuYj1cIig/OltcIitGLncrXCJdKD86W15cIitGLncrXCJdfCQpfCg/Ol58W15cIitGLncrXCJdKVtcIitGLncrXCJdKVwiO0YuYk91dD1cIig/PVteXCIrRi53K1wiXXwkKVwiO0YuYkluPVwiKD86XnxbXlwiK0YudytcIl0pXCI7Ri5iSW5DYXB0dXJlPVwiKD86XnwoW15cIitGLncrXCJdKSlcIjtGLkI9XCIoPzpbXCIrRi53K1wiXVtcIitGLncrXCJdfFteXCIrRi53K1wiXVteXCIrRi53K1wiXSlcIjtGLmQ9Ri5OO1xudmFyIGM9U2sudG9rZW4udG9rZW5zO2NvbnN0IG49U2suYnVpbHRpbi5TeW50YXhFcnJvcixtPVNrLmJ1aWx0aW4uU3ludGF4RXJyb3I7ZS5wcm90b3R5cGUuZXhhY3RfdHlwZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR5cGU9PWMuVF9PUCYmdGhpcy5zdHJpbmcgaW4gU2sudG9rZW4uRVhBQ1RfVE9LRU5fVFlQRVM/U2sudG9rZW4uRVhBQ1RfVE9LRU5fVFlQRVNbdGhpcy5zdHJpbmddOnRoaXMudHlwZX07dmFyIGs9L1tcXFxcXiQuKis/KClbXFxde318XS9nLHU9UmVnRXhwKGsuc291cmNlKTtjb25zdCB7THU6bCxMbDpxLEx0OnosTG06cixMbzp0LE5sOngsTW46dixNYzpCLE5kOkksUGM6TX09RjtGPWwrcSt6K3IrdCt4K1wiX1xcXFx1MTg4NS1cXFxcdTE4ODZcXFxcdTIxMThcXFxcdTIxMkVcXFxcdTMwOUItXFxcXHUzMDlDXCI7Y29uc3QgUz1cIltcIitGK1wiXStbXCIrKEYrditCK0krTStcIlxcXFx1MDBCN1xcXFx1MDM4N1xcXFx1MTM2OS1cXFxcdTEzNzFcXFxcdTE5REFdKlwiKSxFPW5ldyBSZWdFeHAoXCJeXCIrUytcIiRcIik7U2sudG9rZW4uaXNJZGVudGlmaWVyPVxucDsoZnVuY3Rpb24oY2Epe3JldHVybiBkLmFwcGx5KG51bGwsYXJndW1lbnRzKStcIipcIn0pKFwiXFxcXFxcXFxcXFxccj9cXFxcblsgXFxcXGZcXFxcdF0qXCIpO2YoXCIjW15cXFxcclxcXFxuXSpcIik7Rj1kKFwiWzAtOV0oPzpfP1swLTldKSpcXFxcLig/OlswLTldKD86Xz9bMC05XSkqKT9cIixcIlxcXFwuWzAtOV0oPzpfP1swLTldKSpcIikrZihcIltlRV1bLStdP1swLTldKD86Xz9bMC05XSkqXCIpO3ZhciBIPWQoRixcIlswLTldKD86Xz9bMC05XSkqW2VFXVstK10/WzAtOV0oPzpfP1swLTldKSpcIikseT1kKFwiWzAtOV0oPzpfP1swLTldKSpbakpdXCIsSCtcIltqSl1cIik7Rj1kLmFwcGx5KG51bGwsZygpKTtQPWQoRitcIicnJ1wiLEYrJ1wiXCJcIicpO2QoRitcIidbXlxcXFxuJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuJ1xcXFxcXFxcXSopKidcIixGKydcIlteXFxcXG5cIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuXCJcXFxcXFxcXF0qKSpcIicpO3ZhciBBLEosUTthKCEwKTtTay50b2tlbi5zZXR1cFRva2Vucz1hO3ZhciBYPWQoRitcIidbXlxcXFxuJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuJ1xcXFxcXFxcXSopKlwiK1xuZChcIidcIixcIlxcXFxcXFxcXFxcXHI/XFxcXG5cIiksRisnXCJbXlxcXFxuXCJcXFxcXFxcXF0qKD86XFxcXFxcXFwuW15cXFxcblwiXFxcXFxcXFxdKikqJytkKCdcIicsXCJcXFxcXFxcXFxcXFxyP1xcXFxuXCIpKSxhYT1kKFwiXFxcXFxcXFxcXFxccj9cXFxcbnwkXCIsXCIjW15cXFxcclxcXFxuXSpcIixQKSxlYT17fTtGPWcoKTtmb3IobGV0IGNhIG9mIEYpZWFbY2ErXCInXCJdPVwiXlteJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXidcXFxcXFxcXF0qKSonXCIsZWFbY2ErJ1wiJ109J15bXlwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXCJcXFxcXFxcXF0qKSpcIicsZWFbY2ErXCInJydcIl09XCJeW14nXFxcXFxcXFxdKig/Oig/OlxcXFxcXFxcLnwnKD8hJycpKVteJ1xcXFxcXFxcXSopKicnJ1wiLGVhW2NhKydcIlwiXCInXT0nXlteXCJcXFxcXFxcXF0qKD86KD86XFxcXFxcXFwufFwiKD8hXCJcIikpW15cIlxcXFxcXFxcXSopKlwiXCJcIic7bGV0IG5hPVtdLG9hPVtdO2ZvcihsZXQgY2Egb2YgRiluYS5wdXNoKGNhKydcIicpLG5hLnB1c2goY2ErXCInXCIpLG9hLnB1c2goY2ErJ1wiXCJcIicpLG9hLnB1c2goY2ErXCInJydcIik7U2suX3Rva2VuaXplPWZ1bmN0aW9uKGNhLGxhLGlhLGthKXt2YXIgVT1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/XG5cIlwiOlwiKD86TD8pXCI7VT1kKFwiMFt4WF0oPzpfP1swLTlhLWZBLUZdKStcIitVLFwiMFtiQl0oPzpfP1swMV0pK1wiK1UsU2suX19mdXR1cmVfXy5zaWxlbnRfb2N0YWxfbGl0ZXJhbD9cIjAoW29PXT8pKD86Xz9bMC03XSkrXCIrVTpcIjAoW29PXSkoPzpfP1swLTddKStcIitVLFwiKD86MCg/Ol8/MCkqfFsxLTldKD86Xz9bMC05XSkqKVwiK1UpO1U9ZCh5LEgsVSk7VT1cIlsgXFxcXGZcXFxcdF0qXCIrZChhYSxVLFEsWCxTKTtVPW5ldyBSZWdFeHAoVSk7dmFyIGphPTAsTz0wLFY9MCxaPVwiXCIsZmE9MCxxYT1udWxsLHBhPVswXSxELHc9dm9pZCAwLEM9dm9pZCAwLEcsTDt2b2lkIDAhPT1pYSYmKFwidXRmLTgtc2lnXCI9PWlhJiYoaWE9XCJ1dGYtOFwiKSxrYShuZXcgZShjLlRfRU5DT0RJTkcsaWEsWzAsMF0sWzAsMF0sXCJcIikpKTtmb3IodmFyIEs9aWE9XCJcIjs7KXt0cnl7aWE9SyxLPWxhKCl9Y2F0Y2goWSl7Sz1cIlwifWphKz0xO3ZhciBOPTAsUj1LLmxlbmd0aDtpZihaKXtpZighSyl0aHJvdyBuZXcgbihcIkVPRiBpbiBtdWx0aS1saW5lIHN0cmluZ1wiLFxuY2EsQ1swXSxDWzFdKTt3Lmxhc3RJbmRleD0wO3ZhciBXPXcuZXhlYyhLKTtpZihXKU49Rz1XWzBdLmxlbmd0aCxrYShuZXcgZShjLlRfU1RSSU5HLForSy5zdWJzdHJpbmcoMCxHKSxDLFtqYSxHXSxxYStLKSksWj1cIlwiLGZhPTAscWE9bnVsbDtlbHNle2ZhJiZcIlxcXFxcXG5cIiE9PUsuc3Vic3RyaW5nKEsubGVuZ3RoLTIpJiZcIlxcXFxcXHJcXG5cIiE9PUsuc3Vic3RyaW5nKEsubGVuZ3RoLTMpPyhrYShuZXcgZShjLlRfRVJST1JUT0tFTixaK0ssQyxbamEsSy5sZW5ndGhdLHFhKSksWj1cIlwiLHFhPW51bGwpOihaKz1LLHFhKz1LKTtjb250aW51ZX19ZWxzZSBpZigwIT1PfHxWKXtpZighSyl0aHJvdyBuZXcgbihcIkVPRiBpbiBtdWx0aS1saW5lIHN0YXRlbWVudFwiLGNhLGphLDApO1Y9MH1lbHNle2lmKCFLKWJyZWFrO2ZvcihEPTA7TjxSOyl7aWYoXCIgXCI9PUtbTl0pRCs9MTtlbHNlIGlmKFwiXFx0XCI9PUtbTl0pRD04Kk1hdGguZmxvb3IoRC84KzEpO2Vsc2UgaWYoXCJcXGZcIj09S1tOXSlEPTA7ZWxzZSBicmVhaztcbk4rPTF9aWYoTj09UilicmVhaztpZihoKFwiI1xcclxcblwiLEtbTl0pKXtpZihcIiNcIj09S1tOXSl7RD1LLnN1YnN0cmluZyhOKTtmb3IoUj1ELmxlbmd0aDswPFImJi0xIT09XCJcXHJcXG5cIi5pbmRleE9mKEQuY2hhckF0KFItMSkpOy0tUik7Uj1ELnN1YnN0cmluZygwLFIpO2thKG5ldyBlKGMuVF9DT01NRU5ULFIsW2phLE5dLFtqYSxOK1IubGVuZ3RoXSxLKSk7Tis9Ui5sZW5ndGh9a2EobmV3IGUoYy5UX05MLEsuc3Vic3RyaW5nKE4pLFtqYSxOXSxbamEsSy5sZW5ndGhdLEspKTtjb250aW51ZX1EPnBhW3BhLmxlbmd0aC0xXSYmKHBhLnB1c2goRCksa2EobmV3IGUoYy5UX0lOREVOVCxLLnN1YnN0cmluZyhOKSxbamEsMF0sW2phLE5dLEspKSk7Zm9yKDtEPHBhW3BhLmxlbmd0aC0xXTspe2lmKCFoKHBhLEQpKXRocm93IG5ldyBtKFwidW5pbmRlbnQgZG9lcyBub3QgbWF0Y2ggYW55IG91dGVyIGluZGVudGF0aW9uIGxldmVsXCIsY2EsamEsTik7cGE9cGEuc2xpY2UoMCwtMSk7a2EobmV3IGUoYy5UX0RFREVOVCxcblwiXCIsW2phLE5dLFtqYSxOXSxLKSl9fWZvcig7TjxSOyl7Zm9yKEQ9Sy5jaGFyQXQoTik7XCIgXCI9PT1EfHxcIlxcZlwiPT09RHx8XCJcXHRcIj09PUQ7KU4rPTEsRD1LLmNoYXJBdChOKTtpZihMPVUuZXhlYyhLLnN1YnN0cmluZyhOKSkpe2lmKEQ9TixHPUQrTFsxXS5sZW5ndGgsTD1bamEsRF0sVz1bamEsR10sTj1HLEQhPUcpe0c9Sy5zdWJzdHJpbmcoRCxHKTt2YXIgVD1LW0RdO2lmKGgoXCIwMTIzNDU2Nzg5XCIsVCl8fFwiLlwiPT1UJiZcIi5cIiE9RyYmXCIuLi5cIiE9RylrYShuZXcgZShjLlRfTlVNQkVSLEcsTCxXLEspKTtlbHNlIGlmKGgoXCJcXHJcXG5cIixUKSkwPE8/a2EobmV3IGUoYy5UX05MLEcsTCxXLEspKTprYShuZXcgZShjLlRfTkVXTElORSxHLEwsVyxLKSk7ZWxzZSBpZihcIiNcIj09VClrYShuZXcgZShjLlRfQ09NTUVOVCxHLEwsVyxLKSk7ZWxzZSBpZihoKG9hLEcpKWlmKHc9UmVnRXhwKGVhW0ddKSxXPXcuZXhlYyhLLnN1YnN0cmluZyhOKSkpTj1XWzBdLmxlbmd0aCtOLEc9Sy5zdWJzdHJpbmcoRCxcbk4pLGthKG5ldyBlKGMuVF9TVFJJTkcsRyxMLFtqYSxOXSxLKSk7ZWxzZXtDPVtqYSxEXTtaPUsuc3Vic3RyaW5nKEQpO3FhPUs7YnJlYWt9ZWxzZSBpZihoKG5hLFQpfHxoKG5hLEcuc3Vic3RyaW5nKDAsMikpfHxoKG5hLEcuc3Vic3RyaW5nKDAsMykpKWlmKFwiXFxuXCI9PUdbRy5sZW5ndGgtMV0pe0M9W2phLERdO3c9UmVnRXhwKGVhW1RdfHxlYVtHWzFdXXx8ZWFbR1syXV0pO1o9Sy5zdWJzdHJpbmcoRCk7ZmE9MTtxYT1LO2JyZWFrfWVsc2Uga2EobmV3IGUoYy5UX1NUUklORyxHLEwsVyxLKSk7ZWxzZSBwKFQpP2thKG5ldyBlKGMuVF9OQU1FLEcsTCxXLEspKTpcIlxcXFxcIj09VD9WPTE6KGgoXCIoW3tcIixUKT9PKz0xOmgoXCIpXX1cIixUKSYmLS1PLGthKG5ldyBlKGMuVF9PUCxHLEwsVyxLKSkpfX1lbHNlIGthKG5ldyBlKGMuVF9FUlJPUlRPS0VOLEtbTl0sW2phLE5dLFtqYSxOKzFdLEspKSxOKz0xfX1pYSYmIWgoXCJcXHJcXG5cIixpYVtpYS5sZW5ndGgtMV0pJiZrYShuZXcgZShjLlRfTkVXTElORSxcblwiXCIsW2phLTEsaWEubGVuZ3RoXSxbamEtMSxpYS5sZW5ndGgrMV0sXCJcIikpO2Zvcih2YXIgYmEgaW4gcGEuc2xpY2UoMSkpa2EobmV3IGUoYy5UX0RFREVOVCxcIlwiLFtqYSwwXSxbamEsMF0sXCJcIikpO2thKG5ldyBlKGMuVF9FTkRNQVJLRVIsXCJcIixbamEsMF0sW2phLDBdLFwiXCIpKX07U2suX3Rva2VuaXplLkZsb2F0bnVtYmVyPUg7U2suZXhwb3J0U3ltYm9sKFwiU2suX3Rva2VuaXplXCIsU2suX3Rva2VuaXplKX1dKTt9KS5jYWxsKHRoaXMgfHwgd2luZG93KVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1za3VscHQubWluLmpzLm1hcCIsIi8qXG5UaGUgVGltZWRBY3RpdmVjb2RlIGNsYXNzZXMgYXJlIGEgZ3JlYXQgZXhhbXBsZSBvZiB3aGVyZSBtdWx0aXBsZSBpbmhlcml0YW5jZSB3b3VsZCBiZSB1c2VmdWxcbkJ1dCBzaW5jZSBKYXZhc2NyaXB0IGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgaW5oZXJpdGFuY2Ugd2UgdXNlIHRoZSBtaXhpbiBwYXR0ZXJuLlxuXG4qL1xuaW1wb3J0IExpdmVDb2RlIGZyb20gXCIuL2xpdmVjb2RlXCI7XG5pbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZVwiO1xuaW1wb3J0IEpTQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX2pzXCI7XG5pbXBvcnQgSFRNTEFjdGl2ZUNvZGUgZnJvbSBcIi4vYWN0aXZlY29kZV9odG1sXCI7XG5pbXBvcnQgU1FMQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX3NxbFwiO1xuXG52YXIgVGltZWRBY3RpdmVDb2RlTWl4aW4gPSB7XG4gICAgdGltZWRJbml0OiBhc3luYyBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB0aGlzLmlzVGltZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhpZGVCdXR0b25zKCk7XG4gICAgICAgIHRoaXMubmVlZHNSZWluaXRpYWxpemF0aW9uID0gdHJ1ZTsgLy8gdGhlIHJ1biBidXR0b24gY2xpY2sgbGlzdGVuZXIgbmVlZHMgdG8gYmUgcmVpbml0aWFsaXplZFxuICAgICAgICB0aGlzLmNvbnRhaW5lckRpdi5jbGFzc0xpc3QuYWRkKFwidGltZWRDb21wb25lbnRcIik7XG4gICAgICAgIHdpbmRvdy5jb21wb25lbnRNYXBbdGhpcy5kaXZpZF0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgaGlkZUJ1dHRvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkxpc3QgPSBbXG4gICAgICAgICAgICB0aGlzLnNhdmVCdXR0b24sXG4gICAgICAgICAgICB0aGlzLmxvYWRCdXR0b24sXG4gICAgICAgICAgICB0aGlzLmdyYWRlQnV0dG9uLFxuICAgICAgICAgICAgdGhpcy5zaG93SGlkZUJ1dHQsXG4gICAgICAgICAgICB0aGlzLmNvYWNoQnV0dG9uLFxuICAgICAgICAgICAgdGhpcy5hdEJ1dHRvbixcbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidXR0b25MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmIGJ1dHRvbkxpc3RbaV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgJChidXR0b25MaXN0W2ldKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gYmplIC0gbm90IG5lZWRlZCBhbnltb3JlXG4gICAgcmVuZGVyVGltZWRJY29uOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIC8vIHJlbmRlcnMgdGhlIGNsb2NrIGljb24gb24gdGltZWQgY29tcG9uZW50cy4gICAgVGhlIGNvbXBvbmVudCBwYXJhbWV0ZXJcbiAgICAgICAgLy8gaXMgdGhlIGVsZW1lbnQgdGhhdCB0aGUgaWNvbiBzaG91bGQgYmUgYXBwZW5kZWQgdG8uXG4gICAgICAgIHZhciB0aW1lSWNvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciB0aW1lSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICQodGltZUljb24pLmF0dHIoe1xuICAgICAgICAgICAgc3JjOiBcIi4uL19zdGF0aWMvY2xvY2sucG5nXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJ3aWR0aDoxNXB4O2hlaWdodDoxNXB4XCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lSWNvbkRpdi5jbGFzc05hbWUgPSBcInRpbWVUaXBcIjtcbiAgICAgICAgdGltZUljb25EaXYudGl0bGUgPSBcIlwiO1xuICAgICAgICB0aW1lSWNvbkRpdi5hcHBlbmRDaGlsZCh0aW1lSWNvbik7XG4gICAgICAgICQoY29tcG9uZW50KS5wcmVwZW5kKHRpbWVJY29uRGl2KTtcbiAgICB9LFxuXG4gICAgY2hlY2tDb3JyZWN0VGltZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcGN0X2NvcnJlY3QgaXMgc2V0IGJ5IHRoZSB1bml0dGVzdC9ndWkucHkgbW9kdWxlIGluIHNrdWxwdC5cbiAgICAgICAgLy8gaXQgcmVsaWVzIG9uIGZpbmRpbmcgdGhpcyBvYmplY3QgaW4gdGhlIGVkTGlzdFxuICAgICAgICBpZiAodGhpcy5pc0Fuc3dlcmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wY3RfY29ycmVjdCA+PSAxMDAuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlRcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiRlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSVwiOyAvLyB3ZSBpZ25vcmUgdGhpcyBpbiB0aGUgZ3JhZGluZyBpZiBubyB1bml0dGVzdHNcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWRlRmVlZGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICB9LFxuXG4gICAgcmVpbml0aWFsaXplTGlzdGVuZXJzOiBmdW5jdGlvbiAodGFrZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bkJ1dHRvbi5vbmNsaWNrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlYXR0YWNoaW5nIHJ1bmJ1dHRvbmhhbmRsZXJcIik7XG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5vbmNsaWNrID0gdGhpcy5ydW5CdXR0b25IYW5kZXIuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMuY29kZURpdikuc2hvdygpO1xuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAkKHRoaXMuY29kZURpdikucmVtb3ZlQ2xhc3MoXCJhYy1kaXNhYmxlZFwiKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICBpZiAodGhpcy5oaXN0b3J5U2NydWJiZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcih7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgc2xpZGU6IHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIGNoYW5nZTogdGhpcy5zbGlkZWl0LmJpbmQodGhpcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFrZW4pIHtcbiAgICAgICAgICAgICQoYCMke3RoaXMuZGl2aWR9X3VuaXRfcmVzdWx0c2ApLnNob3coKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgY2xhc3MgVGltZWRMaXZlQ29kZSBleHRlbmRzIExpdmVDb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLnRpbWVkSW5pdChvcHRzKTtcbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oVGltZWRMaXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcblxuZXhwb3J0IGNsYXNzIFRpbWVkQWN0aXZlQ29kZSBleHRlbmRzIEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0Q29tcGxldGUgPSB0aGlzLnRpbWVkSW5pdChvcHRzKTtcbiAgICB9XG5cbiAgICAvLyBmb3IgdGltZWQgZXhhbXMgd2UgbmVlZCB0byBjYWxsIHJ1blByb2cgYW5kIHRlbGwgaXQgdGhhdCB0aGVyZSBpc1xuICAgIC8vIG5vIEdVSSBmb3Igc2xpZGVycyBvciBvdGhlciB0aGluZ3MuXG4gICAgLy8gdGhlIGFuc3dlcnMuXG4gICAgYXN5bmMgY2hlY2tDdXJyZW50QW5zd2VyKCkge1xuICAgICAgICBsZXQgbm9VSSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudGltZWRJbml0Q29tcGxldGU7XG4gICAgICAgIGlmICh0aGlzLmlzQW5zd2VyZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuUHJvZyhub1VJLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oVGltZWRBY3RpdmVDb2RlLnByb3RvdHlwZSwgVGltZWRBY3RpdmVDb2RlTWl4aW4pO1xuXG5leHBvcnQgY2xhc3MgVGltZWRKU0FjdGl2ZUNvZGUgZXh0ZW5kcyBKU0FjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xuICAgIH1cbn1cbk9iamVjdC5hc3NpZ24oVGltZWRKU0FjdGl2ZUNvZGUucHJvdG90eXBlLCBUaW1lZEFjdGl2ZUNvZGVNaXhpbik7XG5cbmV4cG9ydCBjbGFzcyBUaW1lZEhUTUxBY3RpdmVDb2RlIGV4dGVuZHMgSFRNTEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xuICAgIH1cbn1cbk9iamVjdC5hc3NpZ24oVGltZWRIVE1MQWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcblxuZXhwb3J0IGNsYXNzIFRpbWVkU1FMQWN0aXZlQ29kZSBleHRlbmRzIFNRTEFjdGl2ZUNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xuICAgIH1cbn1cbk9iamVjdC5hc3NpZ24oVGltZWRTUUxBY3RpdmVDb2RlLnByb3RvdHlwZSwgVGltZWRBY3RpdmVDb2RlTWl4aW4pO1xuIiwiLypcblxuaGlnaGxpZ2h0IHY0XG5cbkhpZ2hsaWdodHMgYXJiaXRyYXJ5IHRlcm1zLlxuXG48aHR0cDovL2pvaGFubmJ1cmthcmQuZGUvYmxvZy9wcm9ncmFtbWluZy9qYXZhc2NyaXB0L2hpZ2hsaWdodC1qYXZhc2NyaXB0LXRleHQtaGlnbGlnaHRpbmctanF1ZXJ5LXBsdWdpbi5odG1sPlxuXG5NSVQgbGljZW5zZS5cblxuSm9oYW5uIEJ1cmthcmRcbjxodHRwOi8vam9oYW5uYnVya2FyZC5kZT5cbjxtYWlsdG86amJAZWFpby5jb20+XG5cbiovXG5cbmpRdWVyeS5mbi5oaWdobGlnaHQgPSBmdW5jdGlvbihwYXQpIHtcbiBmdW5jdGlvbiBpbm5lckhpZ2hsaWdodChub2RlLCBwYXQpIHtcbiAgdmFyIHNraXAgPSAwO1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICB2YXIgcG9zID0gbm9kZS5kYXRhLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihwYXQpO1xuICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHNwYW5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHNwYW5ub2RlLmNsYXNzTmFtZSA9ICdoaWdobGlnaHQnO1xuICAgIHZhciBtaWRkbGViaXQgPSBub2RlLnNwbGl0VGV4dChwb3MpO1xuICAgIHZhciBlbmRiaXQgPSBtaWRkbGViaXQuc3BsaXRUZXh0KHBhdC5sZW5ndGgpO1xuICAgIHZhciBtaWRkbGVjbG9uZSA9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgc3Bhbm5vZGUuYXBwZW5kQ2hpbGQobWlkZGxlY2xvbmUpO1xuICAgIG1pZGRsZWJpdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzcGFubm9kZSwgbWlkZGxlYml0KTtcbiAgICBza2lwID0gMTtcbiAgIH1cbiAgfVxuICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jaGlsZE5vZGVzICYmICEvKHNjcmlwdHxzdHlsZSkvaS50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaSArPSBpbm5lckhpZ2hsaWdodChub2RlLmNoaWxkTm9kZXNbaV0sIHBhdCk7XG4gICB9XG4gIH1cbiAgcmV0dXJuIHNraXA7XG4gfVxuIHJldHVybiB0aGlzLmxlbmd0aCAmJiBwYXQgJiYgcGF0Lmxlbmd0aCA/IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgaW5uZXJIaWdobGlnaHQodGhpcywgcGF0LnRvVXBwZXJDYXNlKCkpO1xuIH0pIDogdGhpcztcbn07XG5cbmpRdWVyeS5mbi5yZW1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gdGhpcy5maW5kKFwic3Bhbi5oaWdobGlnaHRcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQubm9kZU5hbWU7XG4gIHdpdGggKHRoaXMucGFyZW50Tm9kZSkge1xuICAgcmVwbGFjZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCwgdGhpcyk7XG4gICBub3JtYWxpemUoKTtcbiAgfVxuIH0pLmVuZCgpO1xufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==